[
  {
    "id" : "9c54d486-3e05-4435-bd60-3b127d151622",
    "prId" : 4974,
    "prUrl" : "https://github.com/root-project/root/pull/4974#pullrequestreview-361008574",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e7b475b3-91a9-451b-9e51-474d93fe0eec",
        "parentId" : null,
        "authorId" : "09b7e073-cbeb-42e8-aa22-8b1468de56ae",
        "body" : "Nice approach!",
        "createdAt" : "2020-02-19T11:01:19Z",
        "updatedAt" : "2020-02-21T14:57:09Z",
        "lastEditedBy" : "09b7e073-cbeb-42e8-aa22-8b1468de56ae",
        "tags" : [
        ]
      }
    ],
    "commit" : "d99aee5521254c363b9b471586a021273fc37b34",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +113,117 @@\n   /// Merge with other RHistStatContent, assuming same bin configuration\n   void Add(const RHistStatContent& other) {\n      assert(fBinContent.size() == other.fBinContent.size());\n      fEntries += other.fEntries;"
  },
  {
    "id" : "7b2e4130-4655-44de-acbe-604bf5ffddaf",
    "prId" : 5190,
    "prUrl" : "https://github.com/root-project/root/pull/5190#pullrequestreview-398919704",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bd2090eb-1438-4995-9138-bc9e2292f805",
        "parentId" : null,
        "authorId" : "09b7e073-cbeb-42e8-aa22-8b1468de56ae",
        "body" : "Slight improvement (a pattern):\r\n\r\n```suggestion\r\n      for (size_t b = 0, e = fOverflowSumWeightsSquared.size(); b < e; ++b)\r\n```\r\n\r\nElse we have an extra indirections, see https://www.godbolt.org/z/LYaswm `.L3` block vs `.L12` block in the assembly.",
        "createdAt" : "2020-04-22T10:07:13Z",
        "updatedAt" : "2020-04-23T15:16:48Z",
        "lastEditedBy" : "09b7e073-cbeb-42e8-aa22-8b1468de56ae",
        "tags" : [
        ]
      },
      {
        "id" : "6092dc8d-66cd-4ad4-b279-d15cebb981ee",
        "parentId" : "bd2090eb-1438-4995-9138-bc9e2292f805",
        "authorId" : "3df28d96-a205-4719-b340-8cee17a01629",
        "body" : "I'm not familiar with this problem, could you explain a bit more what this is about, please?",
        "createdAt" : "2020-04-23T08:55:29Z",
        "updatedAt" : "2020-04-23T15:16:48Z",
        "lastEditedBy" : "3df28d96-a205-4719-b340-8cee17a01629",
        "tags" : [
        ]
      },
      {
        "id" : "fd02aed6-d36e-4618-926a-cf43f18134aa",
        "parentId" : "bd2090eb-1438-4995-9138-bc9e2292f805",
        "authorId" : "7c164ac9-b625-4880-85f4-7389c0783002",
        "body" : "I would guess that the compiler fails to prove that the subsequent bin addition operations will not modify the vector's size, and therefore has to constantly re-check the vector size on every loop iteration unless said vector size is manually cached.\r\n\r\nOne reason why this may happen (not sure if that's the actual reason) is that in C/++, a pointer can point to pretty much everything, and therefore the compiler cannot prove that `vector[index]` doesn't actually point to the vector struct's inner size field.\r\n\r\nEDIT: That's does not seem to be the problem here though, because otherwise, Axel's example would be optimized correctly...\r\n\r\nEDIT2: Actually, I think I know why Axel's example does not optimize. Consider the following scenario:\r\n\r\n- There is an `std::vector<S>` that is stored in a global variable.\r\n- The caller of `LONG` and `CACHED` may pass them this vector as input.\r\n- The implementation of `call(size_t)`, which is unknown of the compiler, may modify the global vector and in particular change its size.\r\n\r\nSo it is indeed not okay for the compiler to optimize `LONG` into `CACHED`. But this godbolt study does not prove anything about your code, because your loop should not have any non-inlined function in it.",
        "createdAt" : "2020-04-23T09:26:07Z",
        "updatedAt" : "2020-04-23T15:16:48Z",
        "lastEditedBy" : "7c164ac9-b625-4880-85f4-7389c0783002",
        "tags" : [
        ]
      }
    ],
    "commit" : "92d5fa3a3d1ee0c05de9bbfa8af3793c7d09da24",
    "line" : 235,
    "diffHunk" : "@@ -1,1 +367,371 @@      for (size_t b = 0; b < fSumWeightsSquared.size(); ++b)\n         fSumWeightsSquared[b] += other.fSumWeightsSquared[b];\n      for (size_t b = 0; b < fOverflowSumWeightsSquared.size(); ++b)\n         fOverflowSumWeightsSquared[b] += other.fOverflowSumWeightsSquared[b];\n   }"
  }
]
[
  {
    "id" : "b5e5dfee-e2a4-49dd-8ad3-41337632dafd",
    "prId" : 102890,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/102890#pullrequestreview-694083097",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a77e0c4e-5912-4f4d-8cc6-f2232f6aed37",
        "parentId" : null,
        "authorId" : "e58080d6-2177-419f-a546-b51075d7bcb8",
        "body" : "We probably want at least some beta tests in here?",
        "createdAt" : "2021-06-24T13:34:54Z",
        "updatedAt" : "2021-06-24T13:41:24Z",
        "lastEditedBy" : "e58080d6-2177-419f-a546-b51075d7bcb8",
        "tags" : [
        ]
      },
      {
        "id" : "11f603ba-49aa-4f8a-a483-ad3a0bad1258",
        "parentId" : "a77e0c4e-5912-4f4d-8cc6-f2232f6aed37",
        "authorId" : "3facb628-1605-4337-a02a-e4886173f7bf",
        "body" : "hoping https://github.com/kubernetes/kubernetes/pull/102890/commits/34ffddfc7a905e5aacf8e127e9d78ab458646f45 adds enough beta coverage",
        "createdAt" : "2021-06-28T15:15:25Z",
        "updatedAt" : "2021-06-28T15:15:26Z",
        "lastEditedBy" : "3facb628-1605-4337-a02a-e4886173f7bf",
        "tags" : [
        ]
      }
    ],
    "commit" : "20e1c4d7548de0b39a2d70a748ca0b9aab28f631",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +126,130 @@\t\t\t\t\t\tValue: `{\n\t\t\t\t\t\t\t\t\t\t\"kind\": \"ExecCredential\",\n\t\t\t\t\t\t\t\t\t\t\"apiVersion\": \"client.authentication.k8s.io/v1\",\n\t\t\t\t\t\t\t\t\t\t\"status\": {\n\t\t\t\t\t\t\t\t\t\t\t\"token\": \"unauthorized\""
  },
  {
    "id" : "6630d29e-2194-423a-bb71-07d37e7e65c9",
    "prId" : 102152,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/102152#pullrequestreview-664376376",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e6d4ddf2-ab09-427c-9aa3-6dfd10223d2f",
        "parentId" : null,
        "authorId" : "e58080d6-2177-419f-a546-b51075d7bcb8",
        "body" : "ðŸ¤® at the global state.",
        "createdAt" : "2021-05-19T20:28:21Z",
        "updatedAt" : "2021-05-19T20:33:09Z",
        "lastEditedBy" : "e58080d6-2177-419f-a546-b51075d7bcb8",
        "tags" : [
        ]
      },
      {
        "id" : "6952a24a-195a-46d2-a3d4-0014853cb07e",
        "parentId" : "e6d4ddf2-ab09-427c-9aa3-6dfd10223d2f",
        "authorId" : "3facb628-1605-4337-a02a-e4886173f7bf",
        "body" : "Same.",
        "createdAt" : "2021-05-20T13:24:17Z",
        "updatedAt" : "2021-05-20T13:24:17Z",
        "lastEditedBy" : "3facb628-1605-4337-a02a-e4886173f7bf",
        "tags" : [
        ]
      }
    ],
    "commit" : "584acb2cfe32e2a8683aee299fad7def6bc78ea7",
    "line" : 260,
    "diffHunk" : "@@ -1,1 +499,503 @@\tt.Cleanup(func() {\n\t\tmetrics.ExecPluginCalls = previousCallsMetric\n\t})\n\n\tactualMetrics := &execPluginMetrics{}"
  },
  {
    "id" : "144a29e2-ca3a-47eb-9163-8110942ed682",
    "prId" : 101726,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/101726#pullrequestreview-659814304",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "418c3a25-a65b-4a26-b776-ac1b8e21bd4a",
        "parentId" : null,
        "authorId" : "e58080d6-2177-419f-a546-b51075d7bcb8",
        "body" : "ðŸ˜¬ so we wait for 30 seconds in this case?",
        "createdAt" : "2021-05-11T19:43:57Z",
        "updatedAt" : "2021-05-11T20:06:41Z",
        "lastEditedBy" : "e58080d6-2177-419f-a546-b51075d7bcb8",
        "tags" : [
        ]
      },
      {
        "id" : "2547d0a7-ce93-437c-af28-157ebb2d3175",
        "parentId" : "418c3a25-a65b-4a26-b776-ac1b8e21bd4a",
        "authorId" : "3facb628-1605-4337-a02a-e4886173f7bf",
        "body" : "Yeah :(. Same with `waitForInformerSync` when `!wantSynced`. I could shorten the timeout to like 10 seconds when `!wantEvents`, but I was worried that would produce some false positives. I looked around in other integration test code and it seemed like there was some precedent of 30 second timeouts. I tried changing the timeouts to 20 seconds and the test failed locally...",
        "createdAt" : "2021-05-14T12:59:42Z",
        "updatedAt" : "2021-05-14T12:59:42Z",
        "lastEditedBy" : "3facb628-1605-4337-a02a-e4886173f7bf",
        "tags" : [
        ]
      }
    ],
    "commit" : "a14cd8e3de619e81375cf5418a392a05093aaef2",
    "line" : 107,
    "diffHunk" : "@@ -1,1 +458,462 @@\t\t}\n\t} else {\n\t\tif !errors.Is(err, wait.ErrWaitTimeout) {\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"wanted no events, but got error: %v\", err)"
  },
  {
    "id" : "8fcafc47-a5b6-460b-b9ed-b6ca23a5b971",
    "prId" : 101726,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/101726#pullrequestreview-661338826",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6eb0bf01-f36a-47d4-9ad9-88fe10766304",
        "parentId" : null,
        "authorId" : "e58080d6-2177-419f-a546-b51075d7bcb8",
        "body" : "`t.Parallel()`?  How long does this test take to run?",
        "createdAt" : "2021-05-11T20:02:08Z",
        "updatedAt" : "2021-05-11T20:06:41Z",
        "lastEditedBy" : "e58080d6-2177-419f-a546-b51075d7bcb8",
        "tags" : [
        ]
      },
      {
        "id" : "bf0998fa-d594-4ee0-a916-7552aae965ed",
        "parentId" : "6eb0bf01-f36a-47d4-9ad9-88fe10766304",
        "authorId" : "3facb628-1605-4337-a02a-e4886173f7bf",
        "body" : "On my machine, `make test-integration WHAT=\"./test/integration/client\" KUBE_TEST_ARGS=\"-run TestExecPluginRotat\"` runs in `138.622s` (before any changes made in response to PR comments).\r\n\r\nIs it OK for an integration test to run in parallel that makes writes to the API? I was worried that I would screw up other tests (e.g., we create a Namespace and a ConfigMap in this test). I'm all for adding a `t.Parallel()` if that wouldn't mess anything else up: e9c17c84b6a.",
        "createdAt" : "2021-05-14T12:59:48Z",
        "updatedAt" : "2021-05-14T12:59:48Z",
        "lastEditedBy" : "3facb628-1605-4337-a02a-e4886173f7bf",
        "tags" : [
        ]
      },
      {
        "id" : "07d2de84-87ea-4159-b4e7-08b18f7cbe5d",
        "parentId" : "6eb0bf01-f36a-47d4-9ad9-88fe10766304",
        "authorId" : "e58080d6-2177-419f-a546-b51075d7bcb8",
        "body" : "> Is it OK for an integration test to run in parallel that makes writes to the API?\r\n\r\nEach test (or maybe it is only test suite) is supposed to have it own sub section of etcd so it should be fine to run in parallel.",
        "createdAt" : "2021-05-17T19:26:57Z",
        "updatedAt" : "2021-05-17T19:27:09Z",
        "lastEditedBy" : "e58080d6-2177-419f-a546-b51075d7bcb8",
        "tags" : [
        ]
      }
    ],
    "commit" : "a14cd8e3de619e81375cf5418a392a05093aaef2",
    "line" : 191,
    "diffHunk" : "@@ -1,1 +586,590 @@}\n\nfunc TestExecPluginRotationViaInformer(t *testing.T) {\n\tt.Parallel()\n"
  },
  {
    "id" : "ae9bc61a-fdeb-470e-9531-181eef36fbea",
    "prId" : 99713,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/99713#pullrequestreview-629011657",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ba50a516-8f02-4d0b-a25c-339e18698754",
        "parentId" : null,
        "authorId" : "e58080d6-2177-419f-a546-b51075d7bcb8",
        "body" : "While I think the existing `2` tests are fine as a starting point, we really need to test the informer over time - i.e., if the creds under it rotate, does it keep working (and if the creds stop working for some time, and then start working again, does it recover, ...).",
        "createdAt" : "2021-04-05T19:45:12Z",
        "updatedAt" : "2021-04-07T18:46:57Z",
        "lastEditedBy" : "e58080d6-2177-419f-a546-b51075d7bcb8",
        "tags" : [
        ]
      },
      {
        "id" : "540222c1-a0cc-4c95-ad62-6ca236338444",
        "parentId" : "ba50a516-8f02-4d0b-a25c-339e18698754",
        "authorId" : "3facb628-1605-4337-a02a-e4886173f7bf",
        "body" : "Totes agreed. That is the next step. Figured I would start small to follow a \"simple PR first\" principle.",
        "createdAt" : "2021-04-06T14:04:25Z",
        "updatedAt" : "2021-04-07T18:46:57Z",
        "lastEditedBy" : "3facb628-1605-4337-a02a-e4886173f7bf",
        "tags" : [
        ]
      }
    ],
    "commit" : "d00202bd3eb5832b5167b77734ade025d745e7ed",
    "line" : 199,
    "diffHunk" : "@@ -1,1 +442,446 @@}\n\nfunc TestExecPluginViaInformer(t *testing.T) {\n\tresult, clientAuthorizedToken, clientCertFileName, clientKeyFileName := startTestServer(t)\n"
  },
  {
    "id" : "fa968be3-38f2-4f80-9c82-08b9912b625c",
    "prId" : 97775,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/97775#pullrequestreview-600902310",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f32ceccb-86b6-4961-b557-25b420c54130",
        "parentId" : null,
        "authorId" : "e58080d6-2177-419f-a546-b51075d7bcb8",
        "body" : "mm should we check that this favors token somehow?",
        "createdAt" : "2021-02-23T18:31:13Z",
        "updatedAt" : "2021-03-01T19:34:21Z",
        "lastEditedBy" : "e58080d6-2177-419f-a546-b51075d7bcb8",
        "tags" : [
        ]
      },
      {
        "id" : "0f16551d-77cd-4411-9357-00a9be6034fe",
        "parentId" : "f32ceccb-86b6-4961-b557-25b420c54130",
        "authorId" : "3facb628-1605-4337-a02a-e4886173f7bf",
        "body" : "i thought if the exec plugin returns both a token and a cert, then client-go will use both the cert (as a client cert) and the token (in an http header). so when you say \"favors token\" do you mean asserting that the identity extracted by the apiserver is from the token and not the cert?",
        "createdAt" : "2021-02-23T18:56:28Z",
        "updatedAt" : "2021-03-01T19:34:21Z",
        "lastEditedBy" : "3facb628-1605-4337-a02a-e4886173f7bf",
        "tags" : [
        ]
      },
      {
        "id" : "fca5a98e-5763-45ee-8771-355311b3a527",
        "parentId" : "f32ceccb-86b6-4961-b557-25b420c54130",
        "authorId" : "e58080d6-2177-419f-a546-b51075d7bcb8",
        "body" : "Right.  `client-go` should always use both when specified.  `favors` here refers to the API server itself (I guess we have two levels of processing - in `client-go` and on the server - maybe we should focus on the client?).",
        "createdAt" : "2021-02-23T18:58:59Z",
        "updatedAt" : "2021-03-01T19:34:21Z",
        "lastEditedBy" : "e58080d6-2177-419f-a546-b51075d7bcb8",
        "tags" : [
        ]
      },
      {
        "id" : "8220b9ee-c7bc-4910-acd1-c0a86ca9383a",
        "parentId" : "f32ceccb-86b6-4961-b557-25b420c54130",
        "authorId" : "3facb628-1605-4337-a02a-e4886173f7bf",
        "body" : "281f7f9f53ed88ce8ab564967d7deac4e25fcf4b\r\n\r\nWe had a side convo over Zoom, and decided it made sense to only assert behavior from the client in this integration test. Therefore, we added specific assertions about the token and cert used by the client when making requests.",
        "createdAt" : "2021-03-01T16:07:01Z",
        "updatedAt" : "2021-03-01T19:34:21Z",
        "lastEditedBy" : "3facb628-1605-4337-a02a-e4886173f7bf",
        "tags" : [
        ]
      }
    ],
    "commit" : "8834aa133c0007b5a6accff118511d2d88aaf344",
    "line" : 193,
    "diffHunk" : "@@ -1,1 +191,195 @@\t\t},\n\t\t{\n\t\t\tname: \"authorized token and certificate\",\n\t\t\tclientConfigFunc: func(c *rest.Config) {\n\t\t\t\tc.ExecProvider.Env = []clientcmdapi.ExecEnvVar{"
  },
  {
    "id" : "02fc5640-f62e-4acf-88fa-68ca3c3e1d79",
    "prId" : 97775,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/97775#pullrequestreview-601009437",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a105db26-f8ce-43fd-aa38-55d4d052e6c4",
        "parentId" : null,
        "authorId" : "e58080d6-2177-419f-a546-b51075d7bcb8",
        "body" : "uh is this what we want to happen?",
        "createdAt" : "2021-02-23T18:32:16Z",
        "updatedAt" : "2021-03-01T19:34:21Z",
        "lastEditedBy" : "e58080d6-2177-419f-a546-b51075d7bcb8",
        "tags" : [
        ]
      },
      {
        "id" : "4eb4aa21-e98b-42d8-a6b9-28f8785742c7",
        "parentId" : "a105db26-f8ce-43fd-aa38-55d4d052e6c4",
        "authorId" : "3facb628-1605-4337-a02a-e4886173f7bf",
        "body" : "hmmm. i think i had convinced myself that this is what we wanted to happen because the exec authenticator doesn't have any way of detecting that the underlying transport is using a static auth cert and key. altho, that is merely an implementation argument, which might not capture what the user would expect. were you thinking that the user would expect that the static auth cert and key would completely supersede any authentication material returned by the exec authenticator? ",
        "createdAt" : "2021-02-23T18:58:25Z",
        "updatedAt" : "2021-03-01T19:34:21Z",
        "lastEditedBy" : "3facb628-1605-4337-a02a-e4886173f7bf",
        "tags" : [
        ]
      },
      {
        "id" : "9415213b-ec93-4582-958c-8e1b03657aaa",
        "parentId" : "a105db26-f8ce-43fd-aa38-55d4d052e6c4",
        "authorId" : "e58080d6-2177-419f-a546-b51075d7bcb8",
        "body" : "> were you thinking that the user would expect that the static auth cert and key would completely supersede any authentication material returned by the exec authenticator?\r\n\r\nIsn't a similar assertion made by the `good token with static auth basic creds favors static auth basic creds` test case?",
        "createdAt" : "2021-02-23T19:02:00Z",
        "updatedAt" : "2021-03-01T19:34:21Z",
        "lastEditedBy" : "e58080d6-2177-419f-a546-b51075d7bcb8",
        "tags" : [
        ]
      },
      {
        "id" : "e0aa5cb5-9d45-4bc6-98e8-8c6fc326f87d",
        "parentId" : "a105db26-f8ce-43fd-aa38-55d4d052e6c4",
        "authorId" : "3facb628-1605-4337-a02a-e4886173f7bf",
        "body" : "5afdaa85ed57533ef46af75c55d8c87f1ced2b76",
        "createdAt" : "2021-03-01T17:53:03Z",
        "updatedAt" : "2021-03-01T19:34:21Z",
        "lastEditedBy" : "3facb628-1605-4337-a02a-e4886173f7bf",
        "tags" : [
        ]
      }
    ],
    "commit" : "8834aa133c0007b5a6accff118511d2d88aaf344",
    "line" : 322,
    "diffHunk" : "@@ -1,1 +320,324 @@\t\t\t// This is not the behavior we would expect, see\n\t\t\t//   https://github.com/kubernetes/kubernetes/issues/99603\n\t\t\tname: \"good token with static auth cert and key favors exec plugin\",\n\t\t\tclientConfigFunc: func(c *rest.Config) {\n\t\t\t\tc.ExecProvider.Env = []clientcmdapi.ExecEnvVar{"
  }
]
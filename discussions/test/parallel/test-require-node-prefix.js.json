[
  {
    "id" : "df655621-e26a-4965-8257-e9f1ec2c1494",
    "prId" : 37246,
    "prUrl" : "https://github.com/nodejs/node/pull/37246#pullrequestreview-605337361",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "aeda0b37-5652-49a1-87f5-758c134320cb",
        "parentId" : null,
        "authorId" : "ba098e5c-acf7-422b-a104-11cbd9de80d9",
        "body" : "this differs from other builtins, I love it, but want to be sure it is intentional.",
        "createdAt" : "2021-02-06T16:41:54Z",
        "updatedAt" : "2021-03-19T11:35:38Z",
        "lastEditedBy" : "ba098e5c-acf7-422b-a104-11cbd9de80d9",
        "tags" : [
        ]
      },
      {
        "id" : "4069db8c-0b6e-4a8b-966d-12c5c2ea232a",
        "parentId" : "aeda0b37-5652-49a1-87f5-758c134320cb",
        "authorId" : "459cdd07-be0b-4fbf-97b3-6bfcb04cffe8",
        "body" : "this actually seems like an issue - it means someone who replaces a builtin intentionally can’t replace one of these (altho presumably mutating a builtin would be visible in both). That could cause an issue where someone wants to use a package to instrument or lock down `fs` (and thus, policies are not an ergonomic option, unless I’m misunderstanding how policies work), but accidentally leaves a gaping security hole when an attacker requires `node:fs`.",
        "createdAt" : "2021-02-06T16:48:52Z",
        "updatedAt" : "2021-03-19T11:35:38Z",
        "lastEditedBy" : "459cdd07-be0b-4fbf-97b3-6bfcb04cffe8",
        "tags" : [
        ]
      },
      {
        "id" : "756f1c80-01d1-438b-89fe-1dafb727781a",
        "parentId" : "aeda0b37-5652-49a1-87f5-758c134320cb",
        "authorId" : "ba098e5c-acf7-422b-a104-11cbd9de80d9",
        "body" : "policies should intercept before any of the resolution helpers even get called https://github.com/nodejs/node/blob/36cc0ee993a07174f47ea598b6c2c75a66cb052c/lib/internal/modules/cjs/helpers.js#L52 , if any module redirection is in place (including complete shutdown) then it would never call out to `module.require` and get here without some kind of opt-in to the behavior (like `dependencies:true`).",
        "createdAt" : "2021-02-06T18:15:04Z",
        "updatedAt" : "2021-03-19T11:35:38Z",
        "lastEditedBy" : "ba098e5c-acf7-422b-a104-11cbd9de80d9",
        "tags" : [
        ]
      },
      {
        "id" : "b6527255-28ff-4601-a171-9474c526414a",
        "parentId" : "aeda0b37-5652-49a1-87f5-758c134320cb",
        "authorId" : "23c9565c-5fe0-4faf-82b2-dc40116c9bfa",
        "body" : "At the very least this needs documentation and probably a strong indication people using policies + instrumenting fs now need to update the policy.",
        "createdAt" : "2021-02-06T18:25:31Z",
        "updatedAt" : "2021-03-19T11:35:38Z",
        "lastEditedBy" : "23c9565c-5fe0-4faf-82b2-dc40116c9bfa",
        "tags" : [
        ]
      },
      {
        "id" : "d6468688-0144-4f63-b977-85b65848ff7a",
        "parentId" : "aeda0b37-5652-49a1-87f5-758c134320cb",
        "authorId" : "459cdd07-be0b-4fbf-97b3-6bfcb04cffe8",
        "body" : "My point was that policies aren’t currently required to ensure this for CJS - a package (not the app itself) can do it. Forcing policies to be the mechanism means packages are no longer capable of abstracting this for users.",
        "createdAt" : "2021-02-06T19:25:45Z",
        "updatedAt" : "2021-03-19T11:35:38Z",
        "lastEditedBy" : "459cdd07-be0b-4fbf-97b3-6bfcb04cffe8",
        "tags" : [
        ]
      },
      {
        "id" : "16e93f21-601e-4e27-b564-e0330e55bd4c",
        "parentId" : "aeda0b37-5652-49a1-87f5-758c134320cb",
        "authorId" : "ba098e5c-acf7-422b-a104-11cbd9de80d9",
        "body" : "@ljharb ah, yes that is true. I just wanted to be clear that policies can prevent this intentionally and should not be considered to have support for such a workflow.",
        "createdAt" : "2021-02-06T20:25:10Z",
        "updatedAt" : "2021-03-19T11:35:38Z",
        "lastEditedBy" : "ba098e5c-acf7-422b-a104-11cbd9de80d9",
        "tags" : [
        ]
      },
      {
        "id" : "0794764e-e0d4-43d2-965a-7ad5806e4baa",
        "parentId" : "aeda0b37-5652-49a1-87f5-758c134320cb",
        "authorId" : "459cdd07-be0b-4fbf-97b3-6bfcb04cffe8",
        "body" : "Totally understood. Given that policies are the superior mechanism for app developers to lock things down, what's the benefit of adding special, inconsistent, cache-bypassing behavior for `require` with a `node:` prefix?",
        "createdAt" : "2021-02-06T21:34:56Z",
        "updatedAt" : "2021-03-19T11:35:38Z",
        "lastEditedBy" : "459cdd07-be0b-4fbf-97b3-6bfcb04cffe8",
        "tags" : [
        ]
      },
      {
        "id" : "838bfe52-097d-4ecf-a06b-8027f7fd2b62",
        "parentId" : "aeda0b37-5652-49a1-87f5-758c134320cb",
        "authorId" : "ba098e5c-acf7-422b-a104-11cbd9de80d9",
        "body" : "@ljharb i have no strong opinion on if we should diverge, but cache first behavior of CJS isn't shared by ESM and isn't robust against things like core destructuring the original impls. My like is just that it isn't a confusing situation like with `fs/`.",
        "createdAt" : "2021-02-07T03:48:38Z",
        "updatedAt" : "2021-03-19T11:35:38Z",
        "lastEditedBy" : "ba098e5c-acf7-422b-a104-11cbd9de80d9",
        "tags" : [
        ]
      },
      {
        "id" : "40d29845-9e58-445a-b21b-7e74e5fdd2f0",
        "parentId" : "aeda0b37-5652-49a1-87f5-758c134320cb",
        "authorId" : "e56038a1-969b-45e4-9251-03873e734a44",
        "body" : "> but cache first behavior of CJS isn't shared by ESM and isn't robust against things like core destructuring the original impls.\r\n\r\nThis is demonstrated by:\r\n```js\r\nconst fs = require('fs');\r\n\r\nconst fakeModule = {};\r\nrequire.cache.fs = { exports: fakeModule };\r\n\r\nassert.strictEqual((await import('fs')).default, fs);\r\n```\r\n\r\n",
        "createdAt" : "2021-02-08T09:42:56Z",
        "updatedAt" : "2021-03-19T11:35:38Z",
        "lastEditedBy" : "e56038a1-969b-45e4-9251-03873e734a44",
        "tags" : [
        ]
      },
      {
        "id" : "2e4e9733-406e-4aa3-ad07-068a7cc1e382",
        "parentId" : "aeda0b37-5652-49a1-87f5-758c134320cb",
        "authorId" : "459cdd07-be0b-4fbf-97b3-6bfcb04cffe8",
        "body" : "indeed, but that doesn’t mean it’s a good idea to make CJS inconsistent with itself.",
        "createdAt" : "2021-02-08T16:03:03Z",
        "updatedAt" : "2021-03-19T11:35:38Z",
        "lastEditedBy" : "459cdd07-be0b-4fbf-97b3-6bfcb04cffe8",
        "tags" : [
        ]
      },
      {
        "id" : "f7a66f7b-4f38-47e0-a693-858743593dfb",
        "parentId" : "aeda0b37-5652-49a1-87f5-758c134320cb",
        "authorId" : "ba098e5c-acf7-422b-a104-11cbd9de80d9",
        "body" : "I don't think CJS is able to be claimed as consistent with itself since in general the natives don't normally populate the cache. I think it was just ad-hoc written together and the cache behavior is evolutionary not intentional or well understood (even by me).",
        "createdAt" : "2021-03-05T15:27:48Z",
        "updatedAt" : "2021-03-19T11:35:38Z",
        "lastEditedBy" : "ba098e5c-acf7-422b-a104-11cbd9de80d9",
        "tags" : [
        ]
      }
    ],
    "commit" : "95391fe689ec78a809d16d06a4bd8ae8a472dec9",
    "line" : 32,
    "diffHunk" : "@@ -1,1 +30,34 @@}\n\n// `node:`-prefixed `require(...)` calls bypass the require cache:\n{\n  const fakeModule = {};"
  }
]
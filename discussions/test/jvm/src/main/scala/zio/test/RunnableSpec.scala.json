[
  {
    "id" : "14084b1d-d57e-4f25-8acf-57f282c68e04",
    "prId" : 1446,
    "prUrl" : "https://github.com/zio/zio/pull/1446#pullrequestreview-277519317",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a1a96a2b-900d-4167-aa06-c60ebbb33131",
        "parentId" : null,
        "authorId" : "73db9f28-01ba-4a29-946b-7a2ae5ac5350",
        "body" : "I remember there was `sys.exit` before and we removed it because it was exiting the current sbt session when you ran the tests from an sbt shell. Isn't it the case here?",
        "createdAt" : "2019-08-20T23:59:42Z",
        "updatedAt" : "2019-08-20T23:59:46Z",
        "lastEditedBy" : "73db9f28-01ba-4a29-946b-7a2ae5ac5350",
        "tags" : [
        ]
      },
      {
        "id" : "da768acc-7f36-4f43-9a5d-6dba71132a17",
        "parentId" : "a1a96a2b-900d-4167-aa06-c60ebbb33131",
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "You need to trap the `SecurityException` like I do here to prevent that. I just tested it locally and confirmed that this does not exit from the current SBT session.",
        "createdAt" : "2019-08-21T01:31:27Z",
        "updatedAt" : "2019-08-21T01:31:28Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      },
      {
        "id" : "ca2ce7be-23ef-413b-97d3-2d17f67da8d2",
        "parentId" : "a1a96a2b-900d-4167-aa06-c60ebbb33131",
        "authorId" : "73db9f28-01ba-4a29-946b-7a2ae5ac5350",
        "body" : "Nice!",
        "createdAt" : "2019-08-21T01:32:49Z",
        "updatedAt" : "2019-08-21T01:32:49Z",
        "lastEditedBy" : "73db9f28-01ba-4a29-946b-7a2ae5ac5350",
        "tags" : [
        ]
      }
    ],
    "commit" : "fcc13d0ceed0310499bb60ce91474c948c8744a6",
    "line" : 39,
    "diffHunk" : "@@ -1,1 +37,41 @@    val results     = runner.unsafeRun(spec)\n    val hasFailures = results.exists { case TestCase(_, test) => test.failure; case _ => false }\n    try if (hasFailures) sys.exit(1) else sys.exit(0)\n    catch { case _: SecurityException => }\n  }"
  },
  {
    "id" : "2a7828c2-41c1-4dfa-b25c-581cef09da43",
    "prId" : 1438,
    "prUrl" : "https://github.com/zio/zio/pull/1438#pullrequestreview-281431565",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "882f92a9-1ad2-42ce-886f-e075af99182e",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "I think perhaps we should be using declaration-site variance here, but let's not worry about that now.",
        "createdAt" : "2019-08-27T12:43:50Z",
        "updatedAt" : "2019-08-31T01:34:31Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      },
      {
        "id" : "1bed5114-a2ab-4d6d-aafb-76c8b145ab1c",
        "parentId" : "882f92a9-1ad2-42ce-886f-e075af99182e",
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "You mean try to move `E` and `S` to be parameters of methods on the class instead of the class itself? I tried to do that and the issue I ran into is that a `RunnableSpec` needs to be able to turn a `Spec[L, T]` into an `ExecutedSpec[L, E, S]`. So if the class isn't parameterized on those it isn't clear where those parameters come from.",
        "createdAt" : "2019-08-27T20:32:44Z",
        "updatedAt" : "2019-08-31T01:34:31Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      },
      {
        "id" : "f7a55751-5529-47e6-b41f-02c773923ec6",
        "parentId" : "882f92a9-1ad2-42ce-886f-e075af99182e",
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "I mean using `+` and `-` on output / input channels, respectively. But we can do that later.",
        "createdAt" : "2019-08-29T07:09:59Z",
        "updatedAt" : "2019-08-31T01:34:31Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      },
      {
        "id" : "60ce0d99-29f6-49d9-bdea-a460c2ee82c4",
        "parentId" : "882f92a9-1ad2-42ce-886f-e075af99182e",
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "Got it. I tried that and I'm not sure we can since we have `TestRunner[L, -T, E, S]` and `Spec[+L, +T]` so we don't have any terms where we are covariant or contravariant in both. But can definitely come back to this.",
        "createdAt" : "2019-08-29T12:48:37Z",
        "updatedAt" : "2019-08-31T01:34:31Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      }
    ],
    "commit" : "655bd32fcc5c8743fdc7579c8c386e81985d7a51",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +22,26 @@ * A `RunnableSpec` has a main function and can be run by the JVM / Scala.js.\n */\nabstract class RunnableSpec[L, T, E, S](runner0: TestRunner[L, T, E, S])(spec0: => Spec[L, T])\n    extends AbstractRunnableSpec {\n  override type Label   = L"
  }
]
[
  {
    "id" : "ae142fb3-1093-41fe-9b7d-60d7fad948b5",
    "prId" : 2660,
    "prUrl" : "https://github.com/zio/zio/pull/2660#pullrequestreview-345571213",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3489337f-687e-4609-a8a2-bf6add1ea097",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "Are there conditions in which we would want to `spy` but not `mock`? If so, we should severe the relationship between Spyable and Mockable, and make them independent.",
        "createdAt" : "2020-01-20T23:08:28Z",
        "updatedAt" : "2020-01-29T06:19:34Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      },
      {
        "id" : "6b059a33-a387-4f1f-9730-f8ae0f69002a",
        "parentId" : "3489337f-687e-4609-a8a2-bf6add1ea097",
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "The issue is we need to be able to `mock` to implement `spy`. Because to `spy` we need to be able to turn a live service into a mock with `mock`, modify the mock with the specified partial function, and then turn the modified mock back into a live service with `environment` from `Mockable`.\r\n\r\nWhat we could potentially do is have something like:\r\n\r\n```scala\r\ntrait Mockable {\r\n  def environment[A](mock: Mock): Has[A]\r\n}\r\n\r\ntrait Unmockable {\r\n  def mock[A](environment: Has[A]): Mock\r\n}\r\n\r\ntrait Spyable extends Mockable with Unmockable {\r\n  def spy = ???\r\n}\r\n```\r\n\r\nThat is definitely more orthogonal but it also adds more complexity so I think the question is whether the complexity is worth it, and in particular how much use you can get out of the `Unmockable` interface itself or whatever we call it. With that interface you can turn a live service into a mock and modify the mock, but you're stuck with just having a mock. So if you have a bunch of ready made `Method` values you could feed those to it and get results back, but if you wanted to interact with other systems they are going to be expecting the service being mocked and not the mock type.",
        "createdAt" : "2020-01-20T23:20:50Z",
        "updatedAt" : "2020-01-29T06:19:34Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      },
      {
        "id" : "531becf5-8676-4b3d-b9d0-636577715f85",
        "parentId" : "3489337f-687e-4609-a8a2-bf6add1ea097",
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "You're right, I'd leave it like it is! ðŸ‘ ",
        "createdAt" : "2020-01-20T23:30:16Z",
        "updatedAt" : "2020-01-29T06:19:34Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      }
    ],
    "commit" : "29055e4968413f7582da28e4369a4395ae1fcf7c",
    "line" : 29,
    "diffHunk" : "@@ -1,1 +27,31 @@ * then convert the mock back to a live environment to spy on the service.\n */\ntrait Spyable[A] extends Mockable[A] { self =>\n\n  /**"
  },
  {
    "id" : "0641c8f2-5ba7-4448-a821-e76f2d3c510d",
    "prId" : 2660,
    "prUrl" : "https://github.com/zio/zio/pull/2660#pullrequestreview-345566766",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ad7b3703-066b-4776-b3d1-0f9acb8afe6a",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "I like the simpler sig.",
        "createdAt" : "2020-01-20T23:09:20Z",
        "updatedAt" : "2020-01-29T06:19:34Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      }
    ],
    "commit" : "29055e4968413f7582da28e4369a4395ae1fcf7c",
    "line" : 41,
    "diffHunk" : "@@ -1,1 +39,43 @@   * and update state based on them.\n   */\n  final def spy(environment: Has[A])(f: PartialFunction[Invocation[A, _, _], UIO[Unit]]): Has[A] = {\n    val mocked = mock(environment)\n    val spied = new Mock {"
  }
]
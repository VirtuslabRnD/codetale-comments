[
  {
    "id" : "f3bcc1e3-4ed7-4d33-979a-03b2ad83fd5f",
    "prId" : 1438,
    "prUrl" : "https://github.com/zio/zio/pull/1438#pullrequestreview-280157579",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f89831a8-c502-410f-a8b6-ae1c39968abb",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "Nice! ❤️ ",
        "createdAt" : "2019-08-27T12:54:19Z",
        "updatedAt" : "2019-08-31T01:34:31Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      }
    ],
    "commit" : "655bd32fcc5c8743fdc7579c8c386e81985d7a51",
    "line" : 55,
    "diffHunk" : "@@ -1,1 +56,60 @@   * in this assert result.\n   */\n  final def collect[B](p: PartialFunction[A, B]): Option[AssertResult[B]] =\n    fold(a => p.lift(a).map(value))(\n      {"
  },
  {
    "id" : "93945276-9059-4055-ba4e-00f25a793d7a",
    "prId" : 1438,
    "prUrl" : "https://github.com/zio/zio/pull/1438#pullrequestreview-280157579",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5f62b46e-32f1-452f-8c33-91fc975cf204",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "👍 ",
        "createdAt" : "2019-08-27T12:54:30Z",
        "updatedAt" : "2019-08-31T01:34:31Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      }
    ],
    "commit" : "655bd32fcc5c8743fdc7579c8c386e81985d7a51",
    "line" : 86,
    "diffHunk" : "@@ -1,1 +87,91 @@   * values, and then combining the `B` values, using the specified functions.\n   */\n  final def fold[B](caseValue: A => B)(caseAnd: (B, B) => B, caseOr: (B, B) => B): B =\n    self match {\n      case Value(v) =>"
  },
  {
    "id" : "0aae8016-bf05-4346-b110-5bff8d572b4c",
    "prId" : 1438,
    "prUrl" : "https://github.com/zio/zio/pull/1438#pullrequestreview-281258432",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "759b6b63-9163-4ff2-a7a1-89ed6beba348",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "Hmm, probably need to clarify semantic here. Does `isSuccess` mean _any_ success, or _all_ success? If _all_ success, wouldn't we want `&&` for both `and` and `or` (not just `and`)?",
        "createdAt" : "2019-08-27T12:55:29Z",
        "updatedAt" : "2019-08-31T01:34:31Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      },
      {
        "id" : "5d21bf75-b656-4793-b9c5-41ce994f6fdf",
        "parentId" : "759b6b63-9163-4ff2-a7a1-89ed6beba348",
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "It means it is overall a success using logical conjunction and disjunction. We need this because all of our assertions produce:\r\n\r\n```scala\r\ntype AssertionResult = AssertResult[Either[AssertionValue, Unit]]\r\n```\r\n\r\nSo the result of an assertion is basically a tree of either failing assertions or unit values indicating the assertion passed. When we combine assertions using `&&` and `||` those methods run each assertion to get an `AssertResult` and then combine those with the `&&` and `||` methods on `AssertResult`, which just build a tree. So then when we call `isSuccess` on the tree if we have `Or(Left(_), Right(_))` that would be an assertion that is successful, whereas `And(Left(_), Right(_))` would be an assertion that is failed. I can definitely clean up the documentation, but does that make sense?",
        "createdAt" : "2019-08-27T20:41:09Z",
        "updatedAt" : "2019-08-31T01:34:31Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      },
      {
        "id" : "7b37521c-12ec-496a-9d4a-1bc02dc27797",
        "parentId" : "759b6b63-9163-4ff2-a7a1-89ed6beba348",
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "Yes, that makes sense! Basically, \"enough succeeded\" rather than \"all\" or \"some\".",
        "createdAt" : "2019-08-29T07:12:29Z",
        "updatedAt" : "2019-08-31T01:34:31Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      }
    ],
    "commit" : "655bd32fcc5c8743fdc7579c8c386e81985d7a51",
    "line" : 142,
    "diffHunk" : "@@ -1,1 +127,131 @@   */\n  final def isSuccess(implicit ev: A <:< Either[_, _]): Boolean =\n    fold(a => ev(a).isRight)(_ && _, _ || _)\n\n  /**"
  },
  {
    "id" : "df9636df-efe5-40d9-8dfe-2d604d4585ff",
    "prId" : 1438,
    "prUrl" : "https://github.com/zio/zio/pull/1438#pullrequestreview-280157579",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6697c56c-8d6a-4a9f-bc32-d5ff587335b0",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "👍 ",
        "createdAt" : "2019-08-27T12:56:10Z",
        "updatedAt" : "2019-08-31T01:34:31Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      }
    ],
    "commit" : "655bd32fcc5c8743fdc7579c8c386e81985d7a51",
    "line" : 161,
    "diffHunk" : "@@ -1,1 +143,147 @@  final case class And[+A](left: AssertResult[A], right: AssertResult[A]) extends AssertResult[A] { self =>\n    override final def equals(that: Any): Boolean = that match {\n      case other: AssertResult[_] =>\n        equal(other) ||\n          commutative(other) ||"
  }
]
[
  {
    "id" : "2f46729f-a127-4c2f-b9d7-602a3ea8345a",
    "prId" : 2937,
    "prUrl" : "https://github.com/zio/zio/pull/2937#pullrequestreview-362894572",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f2e1ebd2-383f-49c0-b5c2-69945c89af57",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "It's really nice to see all these deprecations. The endless variations were confusing.",
        "createdAt" : "2020-02-21T19:58:06Z",
        "updatedAt" : "2020-02-21T20:35:51Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      },
      {
        "id" : "240382f2-fdaf-4d84-b55f-cafcc3e324c2",
        "parentId" : "f2e1ebd2-383f-49c0-b5c2-69945c89af57",
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "Totally agree! Especially for `Spec`.",
        "createdAt" : "2020-02-21T20:23:13Z",
        "updatedAt" : "2020-02-21T20:35:51Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      }
    ],
    "commit" : "4448be6cb3f8f3b66a177f37f5cb2948db5a6744",
    "line" : 72,
    "diffHunk" : "@@ -1,1 +399,403 @@   * a shared version of their required environment.\n   */\n  @deprecated(\"use provideLayerShared\", \"1.0.0\")\n  final def provideManagedShared[E1 >: E](managed: Managed[E1, R])(implicit ev: NeedsEnv[R]): Spec[Any, E1, T] =\n    provideSomeManagedShared(managed)"
  },
  {
    "id" : "98aaaf4f-82e7-4da1-be7d-106495c4d27d",
    "prId" : 2769,
    "prUrl" : "https://github.com/zio/zio/pull/2769#pullrequestreview-351981587",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0880137a-f64d-40fd-9afd-0caa83451ec8",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "```suggestion\r\n   * the specified predicate. If no tags satisfy the specified predicate then\r\n```",
        "createdAt" : "2020-02-03T00:40:19Z",
        "updatedAt" : "2020-02-03T00:40:19Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      }
    ],
    "commit" : "e31cbb3e9984cbf963f08c9df088669f1f5a0ed3",
    "line" : 91,
    "diffHunk" : "@@ -1,1 +137,141 @@  /**\n   * Returns a new spec with only those suites and tests with tags satisfying\n   * the specified predicate. If not tags satisfy the specified predicate then\n   * returns `Some` with an empty suite with the root label if this is a suite\n   * or `None` otherwise."
  },
  {
    "id" : "83bed7e7-d830-419e-8387-05b33c0cff8f",
    "prId" : 2192,
    "prUrl" : "https://github.com/zio/zio/pull/2192#pullrequestreview-314554511",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fab0c249-ae08-4ba1-9686-1580997855d3",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "Great change!",
        "createdAt" : "2019-11-09T11:46:35Z",
        "updatedAt" : "2019-11-09T12:19:21Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      }
    ],
    "commit" : "31f69819e3403f7eb2e19b65d69f671fe2e83118",
    "line" : 24,
    "diffHunk" : "@@ -1,1 +133,137 @@            )\n          case ExecutionStrategy.Sequential =>\n            specs.foldCauseM(\n              c => f(SuiteCase(label, ZIO.halt(c), exec)),\n              ZIO"
  },
  {
    "id" : "b3bc50ef-8906-4082-bbd2-7446edc309b9",
    "prId" : 2145,
    "prUrl" : "https://github.com/zio/zio/pull/2145#pullrequestreview-310878123",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "36c71cf5-2089-4e30-80e5-fcc3074f4414",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "While generally I like implicit evidence, given the cost of the bimap, may be worth pushing `@@` to be a syntax (extension method) in the companion object, which is added only to specs with `TestFailure` and `TestSuccess` as the S / T. Alternately we could consider specializing all of `Spec` to these types, but the more polymorphic version is nicer because most methods don't need to know about that structure.",
        "createdAt" : "2019-11-04T04:20:21Z",
        "updatedAt" : "2019-11-04T05:11:05Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      },
      {
        "id" : "f8d281c4-9791-4f51-8afd-29708999fb37",
        "parentId" : "36c71cf5-2089-4e30-80e5-fcc3074f4414",
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "If we are worried about performance could we use `asInstanceOf` since we have the implicit evidence?\r\n\r\nI explored specialized `Spec` when I was working on this PR and I don't think we want to go down that road. If we specialize `Spec` on a type that has a error we lose the ability to set the error channel to `Nothing` in `ExecutedSpec` to express that those specs can't fail, which is quite important now that they are effectual to be able to safely traverse them.\r\n\r\nAlso we moved `@@` to `Spec` originally to solve type inference issues, so not to say we can't come up with another way but I'm worried we are going to take a step back there.",
        "createdAt" : "2019-11-04T04:30:28Z",
        "updatedAt" : "2019-11-04T05:11:05Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      },
      {
        "id" : "783b5696-f6d8-446f-bc7d-b33c72cc61c8",
        "parentId" : "36c71cf5-2089-4e30-80e5-fcc3074f4414",
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "All right, cast sounds good to me as long as it is sound.",
        "createdAt" : "2019-11-04T04:46:13Z",
        "updatedAt" : "2019-11-04T05:11:05Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      }
    ],
    "commit" : "9741c4916a2c2eb6452e3498df56bcee7afc14ac",
    "line" : 19,
    "diffHunk" : "@@ -1,1 +37,41 @@  final def @@[R0 <: R1, R1 <: R, E0, E1, E2 >: E0 <: E1, S0, S1, S >: S0 <: S1](\n    aspect: TestAspect[R0, R1, E0, E1, S0, S1]\n  )(implicit ev1: E <:< TestFailure[E2], ev2: T <:< TestSuccess[S]): ZSpec[R1, E2, L, S] =\n    aspect(self.asInstanceOf[ZSpec[R1, E2, L, S]])\n"
  },
  {
    "id" : "41084312-bf09-48fa-a1c3-5ab629fe7dfd",
    "prId" : 1986,
    "prUrl" : "https://github.com/zio/zio/pull/1986#pullrequestreview-302734536",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9299f996-ebca-401d-bdf5-2db0aa74518a",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "I think you should `mapTest` with `ev` to avoid the unsafe cast.",
        "createdAt" : "2019-10-16T16:29:16Z",
        "updatedAt" : "2019-10-16T16:29:17Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      },
      {
        "id" : "93a1c5c1-7efa-4973-b184-47022da474b6",
        "parentId" : "9299f996-ebca-401d-bdf5-2db0aa74518a",
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "Good idea. I will submit a follow up PR.",
        "createdAt" : "2019-10-16T17:06:08Z",
        "updatedAt" : "2019-10-16T17:06:09Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      }
    ],
    "commit" : "75e1400432faf7e219790405bf73ef3000caa04d",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +39,43 @@  )(implicit ev: T <:< Either[TestFailure[Nothing], TestSuccess[S]]): Spec[R1, E1, L, T1] = {\n    val _ = ev\n    aspect(self.asInstanceOf[ZSpec[R, E, L, S]]).asInstanceOf[Spec[R1, E1, L, T1]]\n  }\n"
  },
  {
    "id" : "7b3ad73f-0550-4d61-af4f-922aba15ccc5",
    "prId" : 1664,
    "prUrl" : "https://github.com/zio/zio/pull/1664#pullrequestreview-289170717",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ce32344b-aa30-40af-a4e2-9e7bdcaba948",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "Ah, I see you propagated `R` and `E` into `SpecCase`. A lot of type parameters but inference should be extremely good due to lower order nature + variance annotations.\r\n\r\nWhat the design really wants to be is:\r\n\r\n```scala\r\nsealed trait SpecCase[F[_], +L, +T, +A]\r\n```\r\n\r\nSo we can have:\r\n\r\n```scala\r\nfinal case class Effect[F[_], +L, +T, +A](fa: F[A]) extends SpecCase[F, L, T, A]\r\n```\r\n\r\nwhere in a common case, `F[A] = ZIO[R, E, A]`. And in another case, `F[A] = A`.\r\n\r\nThe problem is ZIO eschews higher-kinded types for teachability / inference, so doing so here would be rather inconsistent with the rest of ZIO, and is almost certain to diminish inference. Although I suppose we could test it.",
        "createdAt" : "2019-09-17T10:23:03Z",
        "updatedAt" : "2019-10-03T14:25:53Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      },
      {
        "id" : "f9f75f43-a5d6-44c1-8093-1c8f13339f29",
        "parentId" : "ce32344b-aa30-40af-a4e2-9e7bdcaba948",
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "Yes I was thinking the same thing but if we managed to do functional effects and streaming without higher order types it seems like we should be able to do make it work for testing. ðŸ˜ƒ ",
        "createdAt" : "2019-09-17T10:35:24Z",
        "updatedAt" : "2019-10-03T14:25:53Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      },
      {
        "id" : "b6d210f4-1f24-4890-8afd-52f0d0b7130c",
        "parentId" : "ce32344b-aa30-40af-a4e2-9e7bdcaba948",
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "True, we should keep trying. ðŸ˜„ ",
        "createdAt" : "2019-09-17T10:40:36Z",
        "updatedAt" : "2019-10-03T14:25:53Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      }
    ],
    "commit" : "575f2a3e67704b91d7e3cf8e6a227fd7ba625d6f",
    "line" : 303,
    "diffHunk" : "@@ -1,1 +256,260 @@\nobject Spec {\n  sealed trait SpecCase[-R, +E, +L, +T, +A] { self =>\n    final def map[B](f: A => B): SpecCase[R, E, L, T, B] = self match {\n      case SuiteCase(label, specs, exec) => SuiteCase(label, specs.map(_.map(f)), exec)"
  },
  {
    "id" : "8cfdbe50-c8e2-4d5f-98f5-d6f60a57c823",
    "prId" : 1664,
    "prUrl" : "https://github.com/zio/zio/pull/1664#pullrequestreview-296715801",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e5339939-e29a-4505-9542-9d118ea6a92b",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "This maybe should be called `existsM`?",
        "createdAt" : "2019-10-02T23:20:39Z",
        "updatedAt" : "2019-10-03T14:25:53Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      },
      {
        "id" : "8d0cdd35-b60a-4455-9180-9ad2996ba296",
        "parentId" : "e5339939-e29a-4505-9542-9d118ea6a92b",
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "Yes we can definitely do that.",
        "createdAt" : "2019-10-03T08:33:00Z",
        "updatedAt" : "2019-10-03T14:25:53Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      }
    ],
    "commit" : "575f2a3e67704b91d7e3cf8e6a227fd7ba625d6f",
    "line" : 41,
    "diffHunk" : "@@ -1,1 +42,46 @@   * Determines if any node in the spec is satisfied by the given predicate.\n   */\n  final def exists[R1 <: R, E1 >: E](f: SpecCase[R, E, L, T, Any] => ZIO[R1, E1, Boolean]): ZIO[R1, E1, Boolean] =\n    fold[ZIO[R1, E1, Boolean]] {\n      case c @ SuiteCase(_, specs, _) => specs.flatMap(ZIO.collectAll(_).map(_.exists(identity))).zipWith(f(c))(_ || _)"
  },
  {
    "id" : "f0aa8aa8-a7ba-450c-be95-9d88f4a60903",
    "prId" : 1664,
    "prUrl" : "https://github.com/zio/zio/pull/1664#pullrequestreview-296724989",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "dc03f780-6699-425f-a311-f6521db6d20f",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "Sequential specialization. Possibly look at the strategy in the node?",
        "createdAt" : "2019-10-02T23:23:19Z",
        "updatedAt" : "2019-10-03T14:25:53Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      },
      {
        "id" : "ada71950-bc66-420f-a216-027cdda83e4d",
        "parentId" : "dc03f780-6699-425f-a311-f6521db6d20f",
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "We could. The only time this method is used in the code base today is on executed specs. This goes a little to some of the other points about the value of these methods on specs that haven't been executed now that the suites are effectual.",
        "createdAt" : "2019-10-03T08:50:11Z",
        "updatedAt" : "2019-10-03T14:25:53Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      }
    ],
    "commit" : "575f2a3e67704b91d7e3cf8e6a227fd7ba625d6f",
    "line" : 107,
    "diffHunk" : "@@ -1,1 +98,102 @@  final def forall[R1 <: R, E1 >: E](f: SpecCase[R, E, L, T, Any] => ZIO[R1, E1, Boolean]): ZIO[R1, E1, Boolean] =\n    fold[ZIO[R1, E1, Boolean]] {\n      case c @ SuiteCase(_, specs, _) => specs.flatMap(ZIO.collectAll(_).map(_.forall(identity))).zipWith(f(c))(_ && _)\n      case c @ TestCase(_, _)         => f(c)\n    }"
  },
  {
    "id" : "626b62b5-6b83-4f61-8872-7627040ec644",
    "prId" : 1664,
    "prUrl" : "https://github.com/zio/zio/pull/1664#pullrequestreview-296722391",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "cfb3e8e8-5780-493f-81ad-107292e50609",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "It seems like `transform` is awfully low-level for this, do we have anything that just allows function application to `specs` and `test`?",
        "createdAt" : "2019-10-02T23:25:54Z",
        "updatedAt" : "2019-10-03T14:25:53Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      },
      {
        "id" : "1e12b0e5-adb7-4f62-9d93-591f0b076214",
        "parentId" : "cfb3e8e8-5780-493f-81ad-107292e50609",
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "I agree. How about something like:\r\n\r\n```scala\r\n  final def mapTests[R1, E1, L1 >: L, T1](\r\n    suiteCase: ZIO[R, E, Vector[Spec[R1, E1, L1, T1]]] => ZIO[R1, E1, Vector[Spec[R1, E1, L1, T1]]],\r\n    testCase: ZIO[R, E, T] => ZIO[R1, E1, T1]\r\n  ): Spec[R1, E1, L1, T1] =\r\n    caseValue match {\r\n      case SuiteCase(label, specs, exec) =>\r\n        Spec.suite(label, suiteCase(specs.map(_.map(_.mapTests(suiteCase, testCase)))), exec)\r\n      case TestCase(label, test) => Spec.test(label, testCase(test))\r\n    }\r\n```\r\n\r\nThen we could do:\r\n\r\n```scala\r\n  final def provideManaged[E1 >: E](managed: Managed[E1, R]): Spec[Any, E1, L, T] =\r\n    mapTests[Any, E1, L, T](_.provideManaged(managed), _.provideManaged(managed))\r\n```",
        "createdAt" : "2019-10-03T08:45:32Z",
        "updatedAt" : "2019-10-03T14:25:53Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      }
    ],
    "commit" : "575f2a3e67704b91d7e3cf8e6a227fd7ba625d6f",
    "line" : 197,
    "diffHunk" : "@@ -1,1 +173,177 @@  final def provideManaged[E1 >: E](managed: Managed[E1, R]): Spec[Any, E1, L, T] =\n    transform[Any, E1, L, T] {\n      case SuiteCase(label, specs, exec) => SuiteCase(label, specs.provideManaged(managed), exec)\n      case TestCase(label, test)         => TestCase(label, test.provideManaged(managed))\n    }"
  },
  {
    "id" : "9560cdfe-239f-4ec1-a1c1-d446b48570a9",
    "prId" : 1664,
    "prUrl" : "https://github.com/zio/zio/pull/1664#pullrequestreview-296729292",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c5e1e780-2137-4f74-a7cb-0ccea9bef78a",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "I feel like this `loop` suggests the need for another traversal scheme.",
        "createdAt" : "2019-10-02T23:27:20Z",
        "updatedAt" : "2019-10-03T14:25:53Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      },
      {
        "id" : "2d7ad8f3-eebe-4d36-98d4-495a99fa57f3",
        "parentId" : "c5e1e780-2137-4f74-a7cb-0ccea9bef78a",
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "I agree. I've been struggling a bit to find the right encoding. I think what we want is a  function that takes a `ZIO[R, E, T]` in the test case to a `ZIO[R1, E1, T]`, where there are no constrains on `R1` and `E1` being subtypes / supertypes of `R` and `E`. And then I think for the suite case we basically need a universally quantified function that takes a `ZIO[R, E, X]` to a `ZIO[R1, E1, X]`, so the suite case can change the effect but should delegate changing the child specs to recursively calling the traversal. Otherwise we run into issues with the environment and error types getting widened to the union of `R` and `R1` and `E` and `E1` instead of just getting `R1 ` and `E`.",
        "createdAt" : "2019-10-03T08:58:08Z",
        "updatedAt" : "2019-10-03T14:25:53Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      }
    ],
    "commit" : "575f2a3e67704b91d7e3cf8e6a227fd7ba625d6f",
    "line" : 211,
    "diffHunk" : "@@ -1,1 +184,188 @@   */\n  final def provideManagedShared[E1 >: E](managed: Managed[E1, R]): Spec[Any, E1, L, T] = {\n    def loop(r: R)(spec: Spec[R, E, L, T]): ZIO[Any, E, Spec[Any, E, L, T]] =\n      spec.caseValue match {\n        case SuiteCase(label, specs, exec) =>"
  },
  {
    "id" : "85296e93-0af4-471f-87c3-e78f93ca2885",
    "prId" : 1664,
    "prUrl" : "https://github.com/zio/zio/pull/1664#pullrequestreview-296720136",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e1384cb8-b60d-4e1d-83d9-4a94c1488bbe",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "I wonder just how useful all these become in an effectful world. Basically computing the size here could, in theory, allocate and de-allocate resources required only to run the tests!",
        "createdAt" : "2019-10-02T23:28:08Z",
        "updatedAt" : "2019-10-03T14:25:53Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      },
      {
        "id" : "933a0c85-f05e-4c7c-b0b8-de7df13386e2",
        "parentId" : "e1384cb8-b60d-4e1d-83d9-4a94c1488bbe",
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "I totally agree. I wonder if we move these to some type of syntax class for executed Specs or require implicit evidence that the spec has been executed. The only variants of these `fold` type methods we use are `exists` and `forall` in checking if all executed specs passed.",
        "createdAt" : "2019-10-03T08:41:22Z",
        "updatedAt" : "2019-10-03T14:25:53Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      }
    ],
    "commit" : "575f2a3e67704b91d7e3cf8e6a227fd7ba625d6f",
    "line" : 229,
    "diffHunk" : "@@ -1,1 +202,206 @@   * Computes the size of the spec, i.e. the number of tests in the spec.\n   */\n  final def size: ZIO[R, E, Int] =\n    fold[ZIO[R, E, Int]] {\n      case SuiteCase(_, counts, _) => counts.flatMap(ZIO.collectAll(_).map(_.sum))"
  }
]
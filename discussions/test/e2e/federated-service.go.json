[
  {
    "id" : "78b53ca5-c540-4843-aaa7-c12c83b4560e",
    "prId" : 37870,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/37870#pullrequestreview-11125184",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "10fc2b18-7d09-47f9-bc65-44eeabf0e353",
        "parentId" : null,
        "authorId" : "ab8bc7c5-233d-47c1-b03a-767fb930c021",
        "body" : "Just fail the test. Not working cloner is something that should not go unnoticed.",
        "createdAt" : "2016-12-01T23:51:08Z",
        "updatedAt" : "2016-12-05T18:33:29Z",
        "lastEditedBy" : "ab8bc7c5-233d-47c1-b03a-767fb930c021",
        "tags" : [
        ]
      },
      {
        "id" : "a728cfec-0f4a-4c04-a4ae-2c4dccc32a51",
        "parentId" : "10fc2b18-7d09-47f9-bc65-44eeabf0e353",
        "authorId" : "f6905dc9-1980-4381-8220-a1c7ad8d5c82",
        "body" : "The test will fail, see `framework.ExpectNoError()` in the if block.\r\n\r\nAlso the problem with just failing the test without doing this shallow copy is, we will never really get a chance to clean up the underlying services when the cloner fails for a reason not in our control, such as cloner bug or such. That will cause resources to leak and the entire suite to fail soon.",
        "createdAt" : "2016-12-02T02:31:56Z",
        "updatedAt" : "2016-12-05T18:33:29Z",
        "lastEditedBy" : "f6905dc9-1980-4381-8220-a1c7ad8d5c82",
        "tags" : [
        ]
      },
      {
        "id" : "e56c596e-2d9e-4014-98f6-bc6f4f5aab74",
        "parentId" : "10fc2b18-7d09-47f9-bc65-44eeabf0e353",
        "authorId" : "ab8bc7c5-233d-47c1-b03a-767fb930c021",
        "body" : "Then please add an extensive comment on why we are doing this.",
        "createdAt" : "2016-12-02T09:02:46Z",
        "updatedAt" : "2016-12-05T18:33:29Z",
        "lastEditedBy" : "ab8bc7c5-233d-47c1-b03a-767fb930c021",
        "tags" : [
        ]
      }
    ],
    "commit" : "28a7ff3cd089f1445b0d1bc8aee0df76083b72e8",
    "line" : null,
    "diffHunk" : "@@ -1,1 +186,190 @@\t\t\t\t// if DeepCopy fails, we are going to try with shallow\n\t\t\t\t// copy as a last resort.\n\t\t\t\tif err != nil {\n\t\t\t\t\tserviceCopy := *service\n\t\t\t\t\tserviceShard = &serviceCopy"
  },
  {
    "id" : "72947f12-daca-47d5-bb35-00d29334df8d",
    "prId" : 37870,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/37870#pullrequestreview-11125234",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bda054a7-358c-469f-ab6a-6f6656bb461e",
        "parentId" : null,
        "authorId" : "ab8bc7c5-233d-47c1-b03a-767fb930c021",
        "body" : "Same here. If the object is not castable to service then something is REALLY broken.",
        "createdAt" : "2016-12-01T23:51:49Z",
        "updatedAt" : "2016-12-05T18:33:29Z",
        "lastEditedBy" : "ab8bc7c5-233d-47c1-b03a-767fb930c021",
        "tags" : [
        ]
      },
      {
        "id" : "fd993ea5-694c-4d34-902e-782d438e0e88",
        "parentId" : "bda054a7-358c-469f-ab6a-6f6656bb461e",
        "authorId" : "f6905dc9-1980-4381-8220-a1c7ad8d5c82",
        "body" : "Agreed. But same comment as above.",
        "createdAt" : "2016-12-02T02:32:38Z",
        "updatedAt" : "2016-12-05T18:33:29Z",
        "lastEditedBy" : "f6905dc9-1980-4381-8220-a1c7ad8d5c82",
        "tags" : [
        ]
      },
      {
        "id" : "57522b09-bcf5-425d-b945-0170de5e6170",
        "parentId" : "bda054a7-358c-469f-ab6a-6f6656bb461e",
        "authorId" : "ab8bc7c5-233d-47c1-b03a-767fb930c021",
        "body" : "Same here.",
        "createdAt" : "2016-12-02T09:03:07Z",
        "updatedAt" : "2016-12-05T18:33:29Z",
        "lastEditedBy" : "ab8bc7c5-233d-47c1-b03a-767fb930c021",
        "tags" : [
        ]
      }
    ],
    "commit" : "28a7ff3cd089f1445b0d1bc8aee0df76083b72e8",
    "line" : null,
    "diffHunk" : "@@ -1,1 +195,199 @@\t\t\t\t// Same argument as above about using shallow copy\n\t\t\t\t// as a last resort.\n\t\t\t\tif !ok {\n\t\t\t\t\tserviceCopy := *service\n\t\t\t\t\tserviceShard = &serviceCopy"
  },
  {
    "id" : "19a500b0-cd9a-4455-826a-ac1be879c9da",
    "prId" : 37411,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/37411#pullrequestreview-10611460",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2d3ca6a8-65bd-46da-8954-b08f6354c8d0",
        "parentId" : null,
        "authorId" : "f6905dc9-1980-4381-8220-a1c7ad8d5c82",
        "body" : "Nit. You can fix this in a follow up. Since all our e2e tests except the node ones are in the same package (`e2e`), it is better to prefix them with the test or test group name to avoid namespace pollution.",
        "createdAt" : "2016-11-28T23:00:06Z",
        "updatedAt" : "2016-11-29T08:31:49Z",
        "lastEditedBy" : "f6905dc9-1980-4381-8220-a1c7ad8d5c82",
        "tags" : [
        ]
      },
      {
        "id" : "024726aa-fe60-4e68-baab-91195ac2ce57",
        "parentId" : "2d3ca6a8-65bd-46da-8954-b08f6354c8d0",
        "authorId" : "f2369046-26b1-4b8c-a8cd-5671ab22066c",
        "body" : "This is the default value of configmap name that kube-dns looks for. To change the name here, will also need to update the config map name flag passed to kube dns.\r\nLeaving it as is",
        "createdAt" : "2016-11-29T08:33:17Z",
        "updatedAt" : "2016-11-29T08:33:17Z",
        "lastEditedBy" : "f2369046-26b1-4b8c-a8cd-5671ab22066c",
        "tags" : [
        ]
      },
      {
        "id" : "07e28e1e-e9f5-40c2-8c63-3616124cd8c7",
        "parentId" : "2d3ca6a8-65bd-46da-8954-b08f6354c8d0",
        "authorId" : "f6905dc9-1980-4381-8220-a1c7ad8d5c82",
        "body" : "Yeah, but this file isn't the appropriate place for this variable. If this is the name of the constant that you want to reuse everywhere, it should probably in a more generic or appropriate location. Why is it in federated service test?",
        "createdAt" : "2016-11-29T19:16:56Z",
        "updatedAt" : "2016-11-29T19:17:01Z",
        "lastEditedBy" : "f6905dc9-1980-4381-8220-a1c7ad8d5c82",
        "tags" : [
        ]
      }
    ],
    "commit" : "6b8d0caac2b37a7ad342d32a7065a44a9674e119",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +36,40 @@\tFederatedServicePodName = \"federated-service-test-pod\"\n\n\tKubeDNSConfigMapName      = \"kube-dns\"\n\tKubeDNSConfigMapNamespace = \"kube-system\"\n)"
  },
  {
    "id" : "c3a9b0c4-10fb-49c5-92fa-41e4ac09efc6",
    "prId" : 37353,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/37353#pullrequestreview-9932600",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "88a5f774-09b7-4d97-96bc-6e5302cde454",
        "parentId" : null,
        "authorId" : "f6905dc9-1980-4381-8220-a1c7ad8d5c82",
        "body" : "I am not entirely sure about failing here. It should log an error and continue?\r\n\r\nAlso, I would just put this in a `defer` block.",
        "createdAt" : "2016-11-23T19:02:59Z",
        "updatedAt" : "2016-11-23T21:02:53Z",
        "lastEditedBy" : "f6905dc9-1980-4381-8220-a1c7ad8d5c82",
        "tags" : [
        ]
      },
      {
        "id" : "68cf7a41-cf43-4413-b2ef-e17e8203cdd7",
        "parentId" : "88a5f774-09b7-4d97-96bc-6e5302cde454",
        "authorId" : "f2369046-26b1-4b8c-a8cd-5671ab22066c",
        "body" : "aah the comment \"Cleanup\" was wrong. This is the test. We want to verify that services are not deleted from underlying clusters. Removed the comment.\r\n\r\nAfterEach deletes these services.",
        "createdAt" : "2016-11-23T19:39:55Z",
        "updatedAt" : "2016-11-23T21:02:53Z",
        "lastEditedBy" : "f2369046-26b1-4b8c-a8cd-5671ab22066c",
        "tags" : [
        ]
      }
    ],
    "commit" : "34eae2207ee81209ef4e072367f116acf03b12b0",
    "line" : 21,
    "diffHunk" : "@@ -1,1 +128,132 @@\t\t\t\t\t_, err := clusterClientset.Core().Services(service.Namespace).Get(service.Name)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tframework.Failf(\"Unexpected error in fetching service %s in cluster %s, %s\", service.Name, clusterName, err)\n\t\t\t\t\t}\n\t\t\t\t}"
  },
  {
    "id" : "2e9e235f-e801-4ae1-a4c7-cbad84a32a14",
    "prId" : 28388,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "eb34b841-c5d2-4158-89bd-a1f17822bc93",
        "parentId" : null,
        "authorId" : "f6905dc9-1980-4381-8220-a1c7ad8d5c82",
        "body" : "We use the last cluster as the primary cluster in our setup/teardown scripts - https://github.com/kubernetes/kubernetes/blob/master/hack/e2e-internal/e2e-up.sh#L34\n",
        "createdAt" : "2016-07-01T23:25:31Z",
        "updatedAt" : "2016-07-06T23:31:59Z",
        "lastEditedBy" : "f6905dc9-1980-4381-8220-a1c7ad8d5c82",
        "tags" : [
        ]
      },
      {
        "id" : "45f7fad1-0f41-4969-8adc-9184e7e609ef",
        "parentId" : "eb34b841-c5d2-4158-89bd-a1f17822bc93",
        "authorId" : null,
        "body" : "Also, the ordering of clusterlist depends on the ordering of the list returned by the API call to list clusters, which is not, as far as I know, well defined.  I think that we need a more definitive means of determining the \"primary cluster\".  It's the cluster in which the federation control plane is running (irrespective of where it appears in the list).\n",
        "createdAt" : "2016-07-06T17:38:15Z",
        "updatedAt" : "2016-07-06T23:31:59Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "d618e5329bfb86c266ab324add9bcf10cdb77bbc",
    "line" : null,
    "diffHunk" : "@@ -1,1 +119,123 @@\n\t\t\tclusters = map[string]*cluster{}\n\t\t\tprimaryClusterName = clusterList.Items[0].Name\n\t\t\tBy(fmt.Sprintf(\"Labeling %q as the first cluster\", primaryClusterName))\n\t\t\tfor i, c := range clusterList.Items {"
  },
  {
    "id" : "8aba6d76-25fb-4f61-a650-5be234812fed",
    "prId" : 28388,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c966bcae-7765-4c02-a536-b5e566ba0cf4",
        "parentId" : null,
        "authorId" : null,
        "body" : "nit: You're not actually labelling it, are you?\n",
        "createdAt" : "2016-07-06T17:40:33Z",
        "updatedAt" : "2016-07-06T23:31:59Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "0f9ba44a-59bd-46a2-b7db-36b83d4a15ae",
        "parentId" : "c966bcae-7765-4c02-a536-b5e566ba0cf4",
        "authorId" : "d324e241-a7f0-4ace-bda2-4174b07bdb18",
        "body" : "Marking?  Recording?\n",
        "createdAt" : "2016-07-06T18:37:44Z",
        "updatedAt" : "2016-07-06T23:31:59Z",
        "lastEditedBy" : "d324e241-a7f0-4ace-bda2-4174b07bdb18",
        "tags" : [
        ]
      }
    ],
    "commit" : "d618e5329bfb86c266ab324add9bcf10cdb77bbc",
    "line" : null,
    "diffHunk" : "@@ -1,1 +120,124 @@\t\t\tclusters = map[string]*cluster{}\n\t\t\tprimaryClusterName = clusterList.Items[0].Name\n\t\t\tBy(fmt.Sprintf(\"Labeling %q as the first cluster\", primaryClusterName))\n\t\t\tfor i, c := range clusterList.Items {\n\t\t\t\tframework.Logf(\"Creating a clientset for the cluster %s\", c.Name)"
  },
  {
    "id" : "de5e659b-efc5-4286-9121-2ebf4f32f0f2",
    "prId" : 28165,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fee1f7c1-3759-49ea-b75e-55dde9184612",
        "parentId" : null,
        "authorId" : "d324e241-a7f0-4ace-bda2-4174b07bdb18",
        "body" : "FYI, I'll be converting all this to a single map keyed on cluster name, and this list of bools will become a field in the struct.\n",
        "createdAt" : "2016-06-28T18:24:18Z",
        "updatedAt" : "2016-06-28T20:01:37Z",
        "lastEditedBy" : "d324e241-a7f0-4ace-bda2-4174b07bdb18",
        "tags" : [
        ]
      },
      {
        "id" : "e53e206d-a476-48a8-8294-46ee2b2b72e3",
        "parentId" : "fee1f7c1-3759-49ea-b75e-55dde9184612",
        "authorId" : null,
        "body" : "Cool, that would be much better.\n",
        "createdAt" : "2016-06-28T19:25:06Z",
        "updatedAt" : "2016-06-28T20:01:37Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "28fab489ea7cdd2352b1fc8bc4147ef63f2f7bf4",
    "line" : 34,
    "diffHunk" : "@@ -1,1 +66,70 @@\tf := framework.NewDefaultFederatedFramework(\"federated-service\")\n\tvar clusterClientSets []*release_1_3.Clientset\n\tvar clusterNamespaceCreated []bool // Did we need to create a new namespace in each of the above clusters?  If so, we should delete it.\n\tvar federationName string\n"
  },
  {
    "id" : "f78235ec-a99b-4c78-9e38-177e53477278",
    "prId" : 27972,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f06670ce-adf5-49d0-a600-df5d39dc9434",
        "parentId" : null,
        "authorId" : null,
        "body" : "minor nit: Prefer \"for i, port := ....\".  Then you can just use \"port.NodePort below. \n",
        "createdAt" : "2016-06-23T21:06:27Z",
        "updatedAt" : "2016-06-24T00:41:02Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "71efd352-25d8-488a-bafe-3740767d7899",
        "parentId" : "f06670ce-adf5-49d0-a600-df5d39dc9434",
        "authorId" : "d324e241-a7f0-4ace-bda2-4174b07bdb18",
        "body" : "That actually doesn't work, as port is a value type and ends up being a copy of the object and your changes get lost.\n\nI'll add a comment explaining this, as I banged my head against it for quite awhile.\n",
        "createdAt" : "2016-06-23T21:17:25Z",
        "updatedAt" : "2016-06-24T00:41:02Z",
        "lastEditedBy" : "d324e241-a7f0-4ace-bda2-4174b07bdb18",
        "tags" : [
        ]
      },
      {
        "id" : "e80e5e79-fe54-421a-b1cd-19766b52be46",
        "parentId" : "f06670ce-adf5-49d0-a600-df5d39dc9434",
        "authorId" : null,
        "body" : "Doh!  Of course you're right :-)\n",
        "createdAt" : "2016-06-23T21:19:47Z",
        "updatedAt" : "2016-06-24T00:41:02Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "e2021ef2417a8ce5a7a5469b1136c2dbec5b83e7",
    "line" : null,
    "diffHunk" : "@@ -1,1 +267,271 @@\t\t// N.B. We cannot iterate over the port objects directly, as their values\n\t\t// only get copied and our updates will get lost.\n\t\tfor i := range clSvc.Spec.Ports {\n\t\t\tclSvc.Spec.Ports[i].NodePort = service.Spec.Ports[i].NodePort\n\t\t}"
  },
  {
    "id" : "b7c63945-3fcb-4154-8825-7d4c7e720eb0",
    "prId" : 27972,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "be9700ac-3014-4df2-a025-cf5a361ffeb2",
        "parentId" : null,
        "authorId" : null,
        "body" : "nit: 10 times seems excessive?  Surely this should succeed within 2 \\* DNSTTL?\n",
        "createdAt" : "2016-06-23T21:09:15Z",
        "updatedAt" : "2016-06-24T00:41:02Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "e2021ef2417a8ce5a7a5469b1136c2dbec5b83e7",
    "line" : 147,
    "diffHunk" : "@@ -1,1 +369,373 @@\tif exists {\n\t\t// TODO(mml): Eventually check the IP address is correct, too.\n\t\tEventually(podExitCodeDetector(f, FederatedServicePod, 0), 10*DNSTTL, time.Second*2).\n\t\t\tShould(BeNil(), \"%q should exit 0, but it never did\", command)\n\t} else {"
  },
  {
    "id" : "821508d8-7566-4c21-abf3-d3a0e1c28876",
    "prId" : 27972,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "eacde189-ea3f-4a1e-9715-f39ac49e09d5",
        "parentId" : null,
        "authorId" : null,
        "body" : "As above.\n",
        "createdAt" : "2016-06-23T21:09:21Z",
        "updatedAt" : "2016-06-24T00:41:02Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "e2021ef2417a8ce5a7a5469b1136c2dbec5b83e7",
    "line" : 151,
    "diffHunk" : "@@ -1,1 +372,376 @@\t\t\tShould(BeNil(), \"%q should exit 0, but it never did\", command)\n\t} else {\n\t\tConsistently(podExitCodeDetector(f, FederatedServicePod, 0), 10*DNSTTL, time.Second*2).\n\t\t\tShouldNot(BeNil(), \"%q should never exit 0, but it did\", command)\n\t}"
  },
  {
    "id" : "873929d7-c6f0-4894-9f45-b3f9d6f198f9",
    "prId" : 27972,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8d60577b-8233-4cb7-88a4-ae4d706a2ee3",
        "parentId" : null,
        "authorId" : null,
        "body" : "nit: Probably more resilient if you create a replcaset of 1 here.  That way if it crashes or ends up on a dead node or similar, a new one will be created automatically.\n",
        "createdAt" : "2016-06-23T21:10:43Z",
        "updatedAt" : "2016-06-24T00:41:02Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "e2021ef2417a8ce5a7a5469b1136c2dbec5b83e7",
    "line" : 159,
    "diffHunk" : "@@ -1,1 +380,384 @@\tname := \"backend\"\n\n\tpod := &v1.Pod{\n\t\tObjectMeta: v1.ObjectMeta{\n\t\t\tName:      name,"
  },
  {
    "id" : "41796c17-5ff4-438e-8076-f99104463d82",
    "prId" : 27636,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8a7f9f3e-44e8-469c-bdf1-4e419cc5c664",
        "parentId" : null,
        "authorId" : "f2369046-26b1-4b8c-a8cd-5671ab22066c",
        "body" : "Use the versioned client now that we have that?\n(We aim to eliminate all uses of unversioned client and remove them)\n",
        "createdAt" : "2016-06-17T21:03:24Z",
        "updatedAt" : "2016-06-17T21:03:24Z",
        "lastEditedBy" : "f2369046-26b1-4b8c-a8cd-5671ab22066c",
        "tags" : [
        ]
      }
    ],
    "commit" : "b0a4fdea4da07a236694886b6d556f49b1cfa941",
    "line" : 147,
    "diffHunk" : "@@ -1,1 +347,351 @@\t}\n\n\t_, err := f.Client.Pods(f.Namespace.Name).Create(pod)\n\tExpect(err).NotTo(HaveOccurred(), \"Trying to create pod to run %q\", command)\n\tdefer f.Client.Pods(f.Namespace.Name).Delete(FederatedServicePod, api.NewDeleteOptions(0))"
  },
  {
    "id" : "631978f4-e46e-4877-b349-3a47ca62163b",
    "prId" : 27636,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6cb535d8-4022-4a09-b9a7-097cfe9e9485",
        "parentId" : null,
        "authorId" : null,
        "body" : "Ideally you should rather make the following public, and reference that directly, otherwise that and this could get out of sync, and break the tests in the future.\n\nhttps://github.com/kubernetes/kubernetes/blob/master/federation/pkg/federation-controller/service/dns.go#L29\n",
        "createdAt" : "2016-06-17T21:10:17Z",
        "updatedAt" : "2016-06-17T21:10:17Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "9b7f4aeb-4b4e-45af-82fe-e01dec984329",
        "parentId" : "6cb535d8-4022-4a09-b9a7-097cfe9e9485",
        "authorId" : null,
        "body" : "In an even more ideal world :-), that constant would be a command line flag :-)\n",
        "createdAt" : "2016-06-17T21:11:26Z",
        "updatedAt" : "2016-06-17T21:11:26Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "b0a4fdea4da07a236694886b6d556f49b1cfa941",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +53,57 @@\n\t// We use this to decide how long to wait for our DNS probes to succeed.\n\tDNSTTL = 180 * time.Second\n)\n"
  },
  {
    "id" : "f7631c7f-3c2a-4239-8d8f-1a33d2d13298",
    "prId" : 27636,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5d0544de-daac-4e2d-95f7-cd33f221d643",
        "parentId" : null,
        "authorId" : null,
        "body" : "I'd suggest adding a doc comment to explain what the parameters mean, especially exists.\n",
        "createdAt" : "2016-06-17T21:16:17Z",
        "updatedAt" : "2016-06-17T21:16:17Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "b0a4fdea4da07a236694886b6d556f49b1cfa941",
    "line" : 126,
    "diffHunk" : "@@ -1,1 +326,330 @@}\n\nfunc discoverService(f *framework.Framework, name string, exists bool) {\n\tcommand := []string{\"sh\", \"-c\", fmt.Sprintf(\"until nslookup '%s'; do sleep 1; done\", name)}\n\tBy(fmt.Sprintf(\"Looking up %q\", name))"
  },
  {
    "id" : "d166bbf9-d758-4087-82e4-e4b087b34706",
    "prId" : 27636,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c7bc1ab3-9d11-48e4-b9c3-0035f9b312bc",
        "parentId" : null,
        "authorId" : null,
        "body" : "This structure is not quite right, but lets fix that in a separate PR.\n",
        "createdAt" : "2016-06-17T21:19:43Z",
        "updatedAt" : "2016-06-17T21:19:43Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "b0a4fdea4da07a236694886b6d556f49b1cfa941",
    "line" : 43,
    "diffHunk" : "@@ -1,1 +197,201 @@\t\t\t\t// TODO(mml): This currently takes 9 minutes.  Consider reducing the\n\t\t\t\t// TTL and/or running the pods in parallel.\n\t\t\t\tContext(\"[Slow]\", func() {\n\t\t\t\t\tlocalSvcDNSNames := []string{\n\t\t\t\t\t\tFederatedServiceName,"
  },
  {
    "id" : "2b6fb8cd-77db-46d5-bd57-36fe37149953",
    "prId" : 27587,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5dba94d7-06cc-4afa-9552-7e93fa4b0c8a",
        "parentId" : null,
        "authorId" : null,
        "body" : "I think you accidentally left in the 'F'?\n",
        "createdAt" : "2016-06-17T01:20:01Z",
        "updatedAt" : "2016-06-17T01:20:01Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "c68990cc-ef74-4baf-8855-65894812b52f",
        "parentId" : "5dba94d7-06cc-4afa-9552-7e93fa4b0c8a",
        "authorId" : null,
        "body" : "Heh!  You beat me to it :-)\n",
        "createdAt" : "2016-06-17T01:20:17Z",
        "updatedAt" : "2016-06-17T01:20:17Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "6ae801f5b8857734d8b2fcb1b9a93a9315ee2ca1",
    "line" : 89,
    "diffHunk" : "@@ -1,1 +179,183 @@\t\t\t})\n\n\t\t\tIt(\"should be able to discover a non-local federated service\", func() {\n\t\t\t\tframework.SkipUnlessFederated(f.Client)\n"
  },
  {
    "id" : "c3ee738a-95f2-4e42-a50d-200ba225065d",
    "prId" : 27587,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "cd7ed696-4b7a-444d-b800-1aecf027ae9c",
        "parentId" : null,
        "authorId" : null,
        "body" : "There are a few problems here, as discussed in person:\n1. Deleting the service from the local cluster won't actually work, as the Federation Service Controller will re-create it (or at least it should, and if it doesn't, that's a bug).  Instead you'll have to remove all of the endpoints from the service (by deleting all pods that match the service's selector).  That should remove the DNS entry for the local shard of the federated service.  Again, if it doesn't, then that's a bug.\n2. Even once the DNS records have been deleted,  DNS propagation will take at least TTL seconds (currently set to 180 in the Federated Service Controller) to propagate.  To get around that you'd probably need to resolve before deleting the service's backends, and then after deleting, until the IP address changes (which might take up to 180 seconds, due to DNS caching).  We might consider reducing that TTL in e2e test clusters to speed up the tests.\n",
        "createdAt" : "2016-06-17T01:56:34Z",
        "updatedAt" : "2016-06-17T01:56:34Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "31238b8a-fb41-4807-a4c3-9395cf5eeb36",
        "parentId" : "cd7ed696-4b7a-444d-b800-1aecf027ae9c",
        "authorId" : "d324e241-a7f0-4ace-bda2-4174b07bdb18",
        "body" : "Bug filed: #27623\n",
        "createdAt" : "2016-06-17T16:12:18Z",
        "updatedAt" : "2016-06-17T16:12:18Z",
        "lastEditedBy" : "d324e241-a7f0-4ace-bda2-4174b07bdb18",
        "tags" : [
        ]
      }
    ],
    "commit" : "6ae801f5b8857734d8b2fcb1b9a93a9315ee2ca1",
    "line" : 94,
    "diffHunk" : "@@ -1,1 +184,188 @@\t\t\t\tsvcDNSNames := []string{\n\t\t\t\t\tfmt.Sprintf(\"%s.%s.%s\", FederatedServiceName, f.Namespace.Name, federationName),\n\t\t\t\t\tfmt.Sprintf(\"%s.%s.%s.svc.cluster.local.\", FederatedServiceName, f.Namespace.Name, federationName),\n\t\t\t\t}\n\t\t\t\tfor _, name := range svcDNSNames {"
  },
  {
    "id" : "f0367e73-2fdd-4644-8292-89703e14f1bc",
    "prId" : 27587,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "cd7430f2-d115-40ab-9f36-7c09326da509",
        "parentId" : null,
        "authorId" : null,
        "body" : "As above, try for DNS TTL seconds (currently configured to180).\n",
        "createdAt" : "2016-06-17T01:57:49Z",
        "updatedAt" : "2016-06-17T01:57:49Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "f9ca5589-a8e0-496b-a80f-153fcb976467",
        "parentId" : "cd7430f2-d115-40ab-9f36-7c09326da509",
        "authorId" : "d324e241-a7f0-4ace-bda2-4174b07bdb18",
        "body" : "I can do that, but it adds 9 minutes to every run when things are passing.  I guess I can leave a TODO saying consider dialing down the TTL and consider parallelizing the pod execution.  I already mentioned the latter elsewhere.\n",
        "createdAt" : "2016-06-17T16:14:47Z",
        "updatedAt" : "2016-06-17T16:14:47Z",
        "lastEditedBy" : "d324e241-a7f0-4ace-bda2-4174b07bdb18",
        "tags" : [
        ]
      },
      {
        "id" : "f1634a07-0362-4194-bcb6-3e94666c4322",
        "parentId" : "cd7430f2-d115-40ab-9f36-7c09326da509",
        "authorId" : null,
        "body" : "Yeah, I'm happy to leave this test disabled until we've dialed down the TTL. Just wanted to explain what the solution would be :-)\n",
        "createdAt" : "2016-06-17T17:34:52Z",
        "updatedAt" : "2016-06-17T17:34:52Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "6ae801f5b8857734d8b2fcb1b9a93a9315ee2ca1",
    "line" : 102,
    "diffHunk" : "@@ -1,1 +192,196 @@\t\t\t\t// TODO(mml): Unclear how to make this meaningful and not terribly\n\t\t\t\t// slow.  How long (how many minutes?) do we verify that a given DNS\n\t\t\t\t// lookup *doesn't* work before we call it a success?  For now,\n\t\t\t\t// commenting out.\n\t\t\t\t/*"
  },
  {
    "id" : "894db463-147b-4bfd-8f0b-1baa382d9567",
    "prId" : 27587,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3588d830-32bd-4724-9680-c71fbf62d45a",
        "parentId" : null,
        "authorId" : null,
        "body" : "I think that you have a potentially endless loop here, right?\n",
        "createdAt" : "2016-06-17T02:02:39Z",
        "updatedAt" : "2016-06-17T02:02:39Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "0ec00bc7-feac-4781-9d75-afbe14246d30",
        "parentId" : "3588d830-32bd-4724-9680-c71fbf62d45a",
        "authorId" : null,
        "body" : "nit: Didn't you decide that \"sh\" -\"c\" was the wrong way to do this?\n",
        "createdAt" : "2016-06-17T02:03:26Z",
        "updatedAt" : "2016-06-17T02:03:26Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "1dcb7e2b-72ee-4dfa-b315-ddf7a87cfe78",
        "parentId" : "3588d830-32bd-4724-9680-c71fbf62d45a",
        "authorId" : "d324e241-a7f0-4ace-bda2-4174b07bdb18",
        "body" : "It's the write way as long as the next argument is a single string representing a bash command.  Before we had \"sh\" \"-c\" \"nslookup\" \"foo\", and when you do that, the \"foo\" goes nowhere.\n\nThere is an endless loop here if nslookup never succeeds.  But the Eventually has a timeout, and when we reach that timeout, the test fails and we'll delete the pod on the way out of the test.\n",
        "createdAt" : "2016-06-17T16:16:54Z",
        "updatedAt" : "2016-06-17T16:16:54Z",
        "lastEditedBy" : "d324e241-a7f0-4ace-bda2-4174b07bdb18",
        "tags" : [
        ]
      },
      {
        "id" : "35dd0202-f8a1-4606-9c65-33186862c7d1",
        "parentId" : "3588d830-32bd-4724-9680-c71fbf62d45a",
        "authorId" : "d324e241-a7f0-4ace-bda2-4174b07bdb18",
        "body" : "> write way\n\n:laughing: \n",
        "createdAt" : "2016-06-17T16:20:37Z",
        "updatedAt" : "2016-06-17T16:20:37Z",
        "lastEditedBy" : "d324e241-a7f0-4ace-bda2-4174b07bdb18",
        "tags" : [
        ]
      },
      {
        "id" : "b13bce31-d30d-4903-bf8e-2842f0507797",
        "parentId" : "3588d830-32bd-4724-9680-c71fbf62d45a",
        "authorId" : null,
        "body" : "Agreed.  Just wanted to check.  Best check what the timeout on Eventually is.  I'm not sure offhand.\n",
        "createdAt" : "2016-06-17T17:36:13Z",
        "updatedAt" : "2016-06-17T17:36:13Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "6ae801f5b8857734d8b2fcb1b9a93a9315ee2ca1",
    "line" : 143,
    "diffHunk" : "@@ -1,1 +283,287 @@\nfunc discoverService(f *framework.Framework, name string) {\n\tcommand := []string{\"sh\", \"-c\", fmt.Sprintf(\"until nslookup '%s'; do sleep 1; done\", name)}\n\n\tdefer f.Client.Pods(f.Namespace.Name).Delete(FederatedServicePod, api.NewDeleteOptions(0))"
  },
  {
    "id" : "3b722dc3-8dad-49ce-9805-15827b8081e9",
    "prId" : 27587,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4f3740d2-52e7-4be2-bcc0-cf8ef2c267cb",
        "parentId" : null,
        "authorId" : null,
        "body" : "Probably better to do this only if the pod creation succeeded below.\n",
        "createdAt" : "2016-06-17T02:04:15Z",
        "updatedAt" : "2016-06-17T02:04:15Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "6ae801f5b8857734d8b2fcb1b9a93a9315ee2ca1",
    "line" : 146,
    "diffHunk" : "@@ -1,1 +285,289 @@\tcommand := []string{\"sh\", \"-c\", fmt.Sprintf(\"until nslookup '%s'; do sleep 1; done\", name)}\n\n\tdefer f.Client.Pods(f.Namespace.Name).Delete(FederatedServicePod, api.NewDeleteOptions(0))\n\n\tpod := &api.Pod{"
  },
  {
    "id" : "542df092-ec9c-4784-99eb-73d0eca807d3",
    "prId" : 27587,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ceab9c18-0308-4b75-a983-870f66d33fe6",
        "parentId" : null,
        "authorId" : null,
        "body" : "Prefer this on one line?\n",
        "createdAt" : "2016-06-17T02:05:47Z",
        "updatedAt" : "2016-06-17T02:05:47Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "6ae801f5b8857734d8b2fcb1b9a93a9315ee2ca1",
    "line" : 168,
    "diffHunk" : "@@ -1,1 +305,309 @@\n\t_, err := f.Client.Pods(f.Namespace.Name).Create(pod)\n\tExpect(err).\n\t\tNotTo(HaveOccurred(), \"Trying to create pod to run %q\", command)\n"
  },
  {
    "id" : "b44fd3d1-6dc6-4579-aed6-37bc63b7ee71",
    "prId" : 27587,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "83f5b1ed-8863-4182-8437-ad072b0dcb36",
        "parentId" : null,
        "authorId" : null,
        "body" : "Perhaps neater and more re-usable to factor this out into a separate function that others can use?\n",
        "createdAt" : "2016-06-17T02:07:29Z",
        "updatedAt" : "2016-06-17T02:07:29Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "e2905884-3c01-4094-a59a-31ed4bceb6d7",
        "parentId" : "83f5b1ed-8863-4182-8437-ad072b0dcb36",
        "authorId" : "d324e241-a7f0-4ace-bda2-4174b07bdb18",
        "body" : "I agree, but I'm not sure the final form the test is going to take.  E.g., adding back in the \"DNS record missing\" assertions, possibly checking the output for the correct IP address.  When it feels solidified, I will go back and extract stuff.\n",
        "createdAt" : "2016-06-17T16:19:09Z",
        "updatedAt" : "2016-06-17T16:19:09Z",
        "lastEditedBy" : "d324e241-a7f0-4ace-bda2-4174b07bdb18",
        "tags" : [
        ]
      },
      {
        "id" : "3f022692-9e6b-4310-a093-524a7ac6c4ec",
        "parentId" : "83f5b1ed-8863-4182-8437-ad072b0dcb36",
        "authorId" : null,
        "body" : "Fair enough.\n",
        "createdAt" : "2016-06-17T17:36:27Z",
        "updatedAt" : "2016-06-17T17:36:27Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "6ae801f5b8857734d8b2fcb1b9a93a9315ee2ca1",
    "line" : 174,
    "diffHunk" : "@@ -1,1 +311,315 @@\tlogs := \"\"\n\n\tlogerr := func(err error) error {\n\t\tif err == nil {\n\t\t\treturn nil"
  },
  {
    "id" : "e606502b-7cf5-412e-bfe5-b70c76bcf5ae",
    "prId" : 27587,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "75bbbf7e-4a62-47f3-997e-b6fb3b56eb7e",
        "parentId" : null,
        "authorId" : null,
        "body" : "nit: Similar comment to above.  Perhaps better as a standalone function?\n",
        "createdAt" : "2016-06-17T02:09:52Z",
        "updatedAt" : "2016-06-17T02:09:52Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "6ae801f5b8857734d8b2fcb1b9a93a9315ee2ca1",
    "line" : 186,
    "diffHunk" : "@@ -1,1 +323,327 @@\t// TODO(mml): Eventually check the IP address is correct, too.\n\tEventually(func() error {\n\t\tpod, err := f.Client.Pods(f.Namespace.Name).Get(FederatedServicePod)\n\t\tif err != nil {\n\t\t\treturn logerr(err)"
  },
  {
    "id" : "a0517ce3-6ab1-4097-9c31-f2e07b21fb51",
    "prId" : 27585,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "96e0b813-0e9c-4e5a-b6ac-211279a06001",
        "parentId" : null,
        "authorId" : "d324e241-a7f0-4ace-bda2-4174b07bdb18",
        "body" : "Can we combine these and just mention the namespace in the assertion line?  Those only get printed if something goes wrong.\n",
        "createdAt" : "2016-06-17T19:07:04Z",
        "updatedAt" : "2016-06-17T19:39:21Z",
        "lastEditedBy" : "d324e241-a7f0-4ace-bda2-4174b07bdb18",
        "tags" : [
        ]
      },
      {
        "id" : "794fd90d-2954-462a-bef9-110cf4e7b752",
        "parentId" : "96e0b813-0e9c-4e5a-b6ac-211279a06001",
        "authorId" : null,
        "body" : "The log messages are also output when the --verbose option is used, even when they pass.  I'd suggest we leave as is.\n",
        "createdAt" : "2016-06-17T19:09:42Z",
        "updatedAt" : "2016-06-17T19:39:21Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "4445dc2b596d8de6677b709b66d92b2db0042fd3",
    "line" : 80,
    "diffHunk" : "@@ -1,1 +268,272 @@\tnservice, err := fcs.Core().Services(namespace).Create(service)\n\tframework.Logf(\"Trying to create service %q in namespace %q\", service.ObjectMeta.Name, service.ObjectMeta.Namespace)\n\tExpect(err).NotTo(HaveOccurred(), fmt.Sprintf(\"creating service %s: %+v\", service.Name, err))\n\tfor _, cs := range clusterClientSets {\n\t\twaitForFederatedServiceShard(cs, namespace, nservice, 1)"
  },
  {
    "id" : "7819dd07-a831-408a-9a59-5d1809c265ca",
    "prId" : 27480,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "268e8a53-730f-4a6e-9f2d-4ca63b626641",
        "parentId" : null,
        "authorId" : "f2369046-26b1-4b8c-a8cd-5671ab22066c",
        "body" : "Add a comment here saying why are we clearing this.\n",
        "createdAt" : "2016-06-15T23:01:11Z",
        "updatedAt" : "2016-06-16T00:18:10Z",
        "lastEditedBy" : "f2369046-26b1-4b8c-a8cd-5671ab22066c",
        "tags" : [
        ]
      }
    ],
    "commit" : "adbd4d802948e655fe052ce480aaeb598c4ab63e",
    "line" : null,
    "diffHunk" : "@@ -1,1 +218,222 @@\t\t// The federation service has no cluster IP.  Clear any cluster IP before\n\t\t// comparison.\n\t\tclSvc.Spec.ClusterIP = \"\"\n\n\t\tExpect(clSvc.Name).To(Equal(service.Name))"
  },
  {
    "id" : "c0c1df04-5dfd-46c8-881e-3988ffa4ec32",
    "prId" : 26636,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8d21e9da-59d0-437b-9d55-2a0a7c7da136",
        "parentId" : null,
        "authorId" : null,
        "body" : "You should also skip all of the BeforeEach() stuff above (cluster registration etc) unless we're federated. \n",
        "createdAt" : "2016-06-08T22:20:19Z",
        "updatedAt" : "2016-06-13T18:18:15Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "ee6f0f89-f9ab-417b-93e4-af42e43fd7ae",
        "parentId" : "8d21e9da-59d0-437b-9d55-2a0a7c7da136",
        "authorId" : "f6905dc9-1980-4381-8220-a1c7ad8d5c82",
        "body" : "Done.\n",
        "createdAt" : "2016-06-13T10:09:40Z",
        "updatedAt" : "2016-06-13T18:18:15Z",
        "lastEditedBy" : "f6905dc9-1980-4381-8220-a1c7ad8d5c82",
        "tags" : [
        ]
      }
    ],
    "commit" : "839d98adfb85df64ee375ca32056ec48d6af0db4",
    "line" : 145,
    "diffHunk" : "@@ -1,1 +143,147 @@\n\tIt(\"should be able to discover a federated service\", func() {\n\t\tframework.SkipUnlessFederated(f.Client)\n\n\t\tcreateService(f.FederationClientset, clusterClientSets, f.Namespace.Name)"
  },
  {
    "id" : "ae42a1c6-e8a5-4ea6-aef8-ed5f44f4722f",
    "prId" : 26636,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2f7ca6de-1e79-4158-b9e6-1e97ee811bac",
        "parentId" : null,
        "authorId" : null,
        "body" : "minor nit: Probably worth adding a brief comment describing what this function does.\n",
        "createdAt" : "2016-06-08T22:23:55Z",
        "updatedAt" : "2016-06-13T18:18:15Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "564cd928-c754-4cb8-9a8d-e495045cbc36",
        "parentId" : "2f7ca6de-1e79-4158-b9e6-1e97ee811bac",
        "authorId" : "f6905dc9-1980-4381-8220-a1c7ad8d5c82",
        "body" : "Done.\n",
        "createdAt" : "2016-06-13T10:10:04Z",
        "updatedAt" : "2016-06-13T18:18:15Z",
        "lastEditedBy" : "f6905dc9-1980-4381-8220-a1c7ad8d5c82",
        "tags" : [
        ]
      }
    ],
    "commit" : "839d98adfb85df64ee375ca32056ec48d6af0db4",
    "line" : null,
    "diffHunk" : "@@ -1,1 +192,196 @@// cluster. If the shard count, i.e. numSvcs is expected to be at least one, then\n// it also checks if the first shard's name and spec matches that of the given service.\nfunc waitForFederatedServiceShard(cs *release_1_3.Clientset, namespace string, service *api.Service, numSvcs int) {\n\tBy(\"Fetching a federated service shard\")\n\tvar clSvcList *v1.ServiceList"
  },
  {
    "id" : "c9d4060d-fb12-4f90-b999-abdadf459e05",
    "prId" : 26636,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bf2a0ed7-7ff1-4da7-aff4-789609962e30",
        "parentId" : null,
        "authorId" : null,
        "body" : "This only seems to work for numSvcs == 1 ?  The semantics of this function are rather confusing.  As far as I can tell it will wait until the number of services in the specifed namespace reaches numSvcs, and (presumably this only works if 'service' is not nil) if numSvcs >0, that the first listed service matches the one passed in?  You should definitely document the semantics in the header, and also check for service != nil before dereferencing it. \n",
        "createdAt" : "2016-06-08T22:41:15Z",
        "updatedAt" : "2016-06-13T18:18:15Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "696d30ab-51f5-40c7-a7e9-4e128ee8b569",
        "parentId" : "bf2a0ed7-7ff1-4da7-aff4-789609962e30",
        "authorId" : "f6905dc9-1980-4381-8220-a1c7ad8d5c82",
        "body" : "> This only seems to work for numSvcs == 1 ?\n\nThat's right and that's intentional. It only makes sense to execute the block inside the `if` only if we expect to have at least one shard.\n\n> The semantics of this function are rather confusing. As far as I can tell it will wait until the number of services in the specifed namespace reaches numSvcs, and (presumably this only works if 'service' is not nil) if numSvcs >0, that the first listed service matches the one passed in? You should definitely document the semantics in the header, and also check for service != nil before dereferencing it.\n\nThanks for catching that. Added a check for service != nil. Also added the doc string for the function.\n",
        "createdAt" : "2016-06-13T09:45:21Z",
        "updatedAt" : "2016-06-13T18:18:15Z",
        "lastEditedBy" : "f6905dc9-1980-4381-8220-a1c7ad8d5c82",
        "tags" : [
        ]
      }
    ],
    "commit" : "839d98adfb85df64ee375ca32056ec48d6af0db4",
    "line" : null,
    "diffHunk" : "@@ -1,1 +213,217 @@\tif numSvcs > 0 && service != nil {\n\t\t// Renaming for clarity/readability\n\t\tclSvc := clSvcList.Items[0]\n\t\tExpect(clSvc.Name).To(Equal(service.Name))\n\t\tExpect(clSvc.Spec).To(Equal(service.Spec))"
  },
  {
    "id" : "6e810892-1cdc-4d25-882d-43fd3c083e76",
    "prId" : 26636,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2d289788-6e14-4f74-a995-9a5d549276da",
        "parentId" : null,
        "authorId" : "f2369046-26b1-4b8c-a8cd-5671ab22066c",
        "body" : "name this federation-service?\n",
        "createdAt" : "2016-06-13T08:28:17Z",
        "updatedAt" : "2016-06-13T18:18:15Z",
        "lastEditedBy" : "f2369046-26b1-4b8c-a8cd-5671ab22066c",
        "tags" : [
        ]
      },
      {
        "id" : "e1f7fd03-1f2b-4dcd-94dd-b0365e221f4c",
        "parentId" : "2d289788-6e14-4f74-a995-9a5d549276da",
        "authorId" : "f6905dc9-1980-4381-8220-a1c7ad8d5c82",
        "body" : "This shouldn't be renamed to \"federation-service\" like the way we call other items that belong to the federation. This service is \"federated\" across a federation, a verb, in addition to being part of the federation. \n",
        "createdAt" : "2016-06-13T08:36:09Z",
        "updatedAt" : "2016-06-13T18:18:15Z",
        "lastEditedBy" : "f6905dc9-1980-4381-8220-a1c7ad8d5c82",
        "tags" : [
        ]
      }
    ],
    "commit" : "839d98adfb85df64ee375ca32056ec48d6af0db4",
    "line" : 1,
    "diffHunk" : "@@ -1,1 +-1,3 @@/*\nCopyright 2016 The Kubernetes Authors All rights reserved.\n"
  },
  {
    "id" : "879e931c-6fa1-4758-bbe8-7a2be8875c41",
    "prId" : 26636,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "52f5691c-bf8c-4901-86ca-726c287c31ee",
        "parentId" : null,
        "authorId" : null,
        "body" : "nit: I don't understand how one could ever have more than 1 instance of the service in a given cluster at the same time.  There would be a name clash, right?  In which case, is the numSvcs parameter essentially a boolean?  Would it ever make sense to call this function with that parameter not equal to either 0 or 1?\n",
        "createdAt" : "2016-06-13T20:18:23Z",
        "updatedAt" : "2016-06-13T20:18:23Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "839d98adfb85df64ee375ca32056ec48d6af0db4",
    "line" : 194,
    "diffHunk" : "@@ -1,1 +192,196 @@// cluster. If the shard count, i.e. numSvcs is expected to be at least one, then\n// it also checks if the first shard's name and spec matches that of the given service.\nfunc waitForFederatedServiceShard(cs *release_1_3.Clientset, namespace string, service *api.Service, numSvcs int) {\n\tBy(\"Fetching a federated service shard\")\n\tvar clSvcList *v1.ServiceList"
  },
  {
    "id" : "775ab317-4e88-4e20-b77d-e1d77b8d7537",
    "prId" : 26636,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f18a74d1-0ee6-4e42-9819-b6e0e7687e85",
        "parentId" : null,
        "authorId" : null,
        "body" : "Don't you only want to list the service with the given name (service.Name()) here?  I realize that this test should run in it's own namespace, and that there should be no other services in that namespace, but the logic in this function still seems overly complex and confusing to me. \n\nShould you not simply be listing the services with the given name, and confirming that the length of the returned list is either 0 or 1 (depending on the value of numServices, which I suspect should be a bool, not an int).\n",
        "createdAt" : "2016-06-13T20:23:45Z",
        "updatedAt" : "2016-06-13T20:23:45Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "839d98adfb85df64ee375ca32056ec48d6af0db4",
    "line" : 199,
    "diffHunk" : "@@ -1,1 +197,201 @@\tif err := wait.PollImmediate(framework.Poll, FederatedServiceTimeout, func() (bool, error) {\n\t\tvar err error\n\t\tclSvcList, err = cs.Core().Services(namespace).List(api.ListOptions{})\n\t\tif err != nil {\n\t\t\treturn false, err"
  },
  {
    "id" : "d8f2fc8d-9698-47b1-91a7-547a06aa373f",
    "prId" : 26636,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f3c76426-8205-4f84-9d98-4730a042e95b",
        "parentId" : null,
        "authorId" : null,
        "body" : "You're listing services here, not clusters.  Cut-n-paste error?\n",
        "createdAt" : "2016-06-13T20:25:30Z",
        "updatedAt" : "2016-06-13T20:25:30Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "839d98adfb85df64ee375ca32056ec48d6af0db4",
    "line" : 210,
    "diffHunk" : "@@ -1,1 +208,212 @@\t\treturn false, nil\n\t}); err != nil {\n\t\tframework.Failf(\"Failed to list registered clusters: %+v\", err)\n\t}\n"
  },
  {
    "id" : "9d99f701-e1a2-4931-a4bf-f04a8077f9d6",
    "prId" : 26636,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a8d2e8c8-f193-479a-9b1f-0c30de32f012",
        "parentId" : null,
        "authorId" : null,
        "body" : "You need to add a deferred function here to delete the created service.\n",
        "createdAt" : "2016-06-13T20:27:13Z",
        "updatedAt" : "2016-06-13T20:27:13Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "839d98adfb85df64ee375ca32056ec48d6af0db4",
    "line" : 252,
    "diffHunk" : "@@ -1,1 +250,254 @@\t_, err := fcs.Core().Services(namespace).Create(service)\n\tExpect(err).NotTo(HaveOccurred())\n\tfor _, cs := range clusterClientSets {\n\t\twaitForFederatedServiceShard(cs, namespace, service, 1)\n\t}"
  },
  {
    "id" : "8c591259-3b5f-434a-b2ae-c2dea1064d4b",
    "prId" : 26636,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "408cffaf-74dd-44db-8ed9-a07e679ae45d",
        "parentId" : null,
        "authorId" : null,
        "body" : "nit: Wouldn't it be better to use a simpler regex like [0-9]{1,3}.){4}\n",
        "createdAt" : "2016-06-13T20:59:28Z",
        "updatedAt" : "2016-06-13T20:59:40Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "92f71a66-a963-48cb-b759-7a6c61a2d5da",
        "parentId" : "408cffaf-74dd-44db-8ed9-a07e679ae45d",
        "authorId" : null,
        "body" : "nit: This is not specific to anything federated.  Would it not be better to call it something like IPv4Regexp and put it in the utils library for other people to also use?\n",
        "createdAt" : "2016-06-13T21:01:41Z",
        "updatedAt" : "2016-06-13T21:01:41Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "839d98adfb85df64ee375ca32056ec48d6af0db4",
    "line" : 53,
    "diffHunk" : "@@ -1,1 +51,55 @@\n\t// TODO: Only suppoprts IPv4 addresses. Also add a regexp for IPv6 addresses.\n\tFederatedIPAddrRegexp  = `(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])`\n\tFederatedDNS1123Regexp = `([a-z0-9]([-a-z0-9]*[a-z0-9])?\\.)*([a-z0-9]([-a-z0-9]*[a-z0-9])?)`\n)"
  },
  {
    "id" : "334c3eae-b0f5-4281-a2ac-a8b92f10fd71",
    "prId" : 26636,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6b3cbeab-22fa-4459-9c21-c54e5fc5c31c",
        "parentId" : null,
        "authorId" : null,
        "body" : "nit: Similar comment to above.\n",
        "createdAt" : "2016-06-13T21:02:04Z",
        "updatedAt" : "2016-06-13T21:02:04Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "839d98adfb85df64ee375ca32056ec48d6af0db4",
    "line" : 54,
    "diffHunk" : "@@ -1,1 +52,56 @@\t// TODO: Only suppoprts IPv4 addresses. Also add a regexp for IPv6 addresses.\n\tFederatedIPAddrRegexp  = `(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])`\n\tFederatedDNS1123Regexp = `([a-z0-9]([-a-z0-9]*[a-z0-9])?\\.)*([a-z0-9]([-a-z0-9]*[a-z0-9])?)`\n)\n"
  },
  {
    "id" : "4779bfb9-a708-4476-b174-bb88c4264036",
    "prId" : 26636,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1ad18bcb-e504-4465-860c-b7d9302df0a3",
        "parentId" : null,
        "authorId" : null,
        "body" : "nit: Surely you want the actual name of the service in FederatedDNS1123Regexp?  Otherwise you'll match any DNS name that comes back.  I guess that doesn't really matter in practise.  To make this test more robust I think it would be better to only distinguish between DNS lookup success and failure.  The exact output and format of the nslookup tool is mostly irrelevant, and might change over time and/or platform.  I checked the nslookup tool and unfortunately it returns zero on both success and failure.  \n\nBut the 'host' tool is a little better for this.  It is pretty ubiquitous, and prints the name and address on success, but prints nothing on failure. That might be a simpler, more robust test.\n\n```\n$ host www.google.com\nwww.google.com has address 172.217.2.228\n$ host rubbish\n$\n```\n",
        "createdAt" : "2016-06-13T21:15:56Z",
        "updatedAt" : "2016-06-13T21:15:56Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "839d98adfb85df64ee375ca32056ec48d6af0db4",
    "line" : 276,
    "diffHunk" : "@@ -1,1 +274,278 @@\tif exists {\n\t\tf.TestContainerOutputRegexp(\"federated service discovery\", pod, 0, []string{\n\t\t\t`Name:\\s+` + FederatedDNS1123Regexp + `\\nAddress \\d+:\\s+` + FederatedIPAddrRegexp + `\\s+` + FederatedDNS1123Regexp,\n\t\t})\n\t} else {"
  },
  {
    "id" : "b9de71c9-dac6-47bc-83b8-5dab2dbb947f",
    "prId" : 26636,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "75922904-f311-4032-9947-33480999025e",
        "parentId" : null,
        "authorId" : "f2369046-26b1-4b8c-a8cd-5671ab22066c",
        "body" : "No one is setting this env var anywhere?\nSo the tests right now will definitely fail?\n",
        "createdAt" : "2016-06-13T21:58:38Z",
        "updatedAt" : "2016-06-13T21:58:38Z",
        "lastEditedBy" : "f2369046-26b1-4b8c-a8cd-5671ab22066c",
        "tags" : [
        ]
      },
      {
        "id" : "f96481b5-d449-4968-b130-2d35d674f907",
        "parentId" : "75922904-f311-4032-9947-33480999025e",
        "authorId" : "f6905dc9-1980-4381-8220-a1c7ad8d5c82",
        "body" : "Yeah, I wasn't expecting this PR to merge before waking up.\n",
        "createdAt" : "2016-06-14T04:17:09Z",
        "updatedAt" : "2016-06-14T04:17:09Z",
        "lastEditedBy" : "f6905dc9-1980-4381-8220-a1c7ad8d5c82",
        "tags" : [
        ]
      },
      {
        "id" : "1eccc1d3-7bb7-427f-b42b-55312f24894d",
        "parentId" : "75922904-f311-4032-9947-33480999025e",
        "authorId" : "f2369046-26b1-4b8c-a8cd-5671ab22066c",
        "body" : "I have https://github.com/kubernetes/kubernetes/pull/27333 to fix this\n",
        "createdAt" : "2016-06-14T04:35:33Z",
        "updatedAt" : "2016-06-14T04:35:33Z",
        "lastEditedBy" : "f2369046-26b1-4b8c-a8cd-5671ab22066c",
        "tags" : [
        ]
      },
      {
        "id" : "5b8e1fdd-203c-4c00-982e-3c63df360dce",
        "parentId" : "75922904-f311-4032-9947-33480999025e",
        "authorId" : "f6905dc9-1980-4381-8220-a1c7ad8d5c82",
        "body" : "Thanks!\n",
        "createdAt" : "2016-06-14T04:42:18Z",
        "updatedAt" : "2016-06-14T04:42:18Z",
        "lastEditedBy" : "f6905dc9-1980-4381-8220-a1c7ad8d5c82",
        "tags" : [
        ]
      }
    ],
    "commit" : "839d98adfb85df64ee375ca32056ec48d6af0db4",
    "line" : 66,
    "diffHunk" : "@@ -1,1 +64,68 @@\n\t\t// TODO: Federation API server should be able to answer this.\n\t\tif federationName = os.Getenv(\"FEDERATION_NAME\"); federationName == \"\" {\n\t\t\t// Tests cannot proceed without this value, so fail early here.\n\t\t\tframework.Failf(\"FEDERATION_NAME environment variable must be set\")"
  }
]
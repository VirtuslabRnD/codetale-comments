[
  {
    "id" : "94a3cb8d-50e4-4814-a5a0-a2a0be776600",
    "prId" : 16984,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "130d008c-27e8-4bd5-bb51-687448ffa62d",
        "parentId" : null,
        "authorId" : "719d0e19-fcef-4b47-afac-404318b9514f",
        "body" : "```\n# k8s.io/kubernetes/test/e2e\n_output/local/go/src/k8s.io/kubernetes/test/e2e/reboot.go:127: not enough arguments in call to rebootNode\n_output/local/go/src/k8s.io/kubernetes/test/e2e/reboot.go:127: rebootNode(c, testContext.Provider, n.ObjectMeta.Name, rebootCmd) used as value\n```\n",
        "createdAt" : "2015-11-09T23:29:08Z",
        "updatedAt" : "2015-11-16T23:09:06Z",
        "lastEditedBy" : "719d0e19-fcef-4b47-afac-404318b9514f",
        "tags" : [
        ]
      },
      {
        "id" : "659ba95b-735b-4796-854b-7769c8a6bbba",
        "parentId" : "130d008c-27e8-4bd5-bb51-687448ffa62d",
        "authorId" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "body" : "fixed.\n",
        "createdAt" : "2015-11-12T05:54:09Z",
        "updatedAt" : "2015-11-16T23:09:06Z",
        "lastEditedBy" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "tags" : [
        ]
      }
    ],
    "commit" : "ed91d5564b84cb8aa7228172dcaca279ee9d684b",
    "line" : 77,
    "diffHunk" : "@@ -1,1 +129,133 @@\t\t\tdefer wg.Done()\n\t\t\tn := nodelist.Items[ix]\n\t\t\tresult[ix] = rebootNode(c, testContext.Provider, n.ObjectMeta.Name, rebootCmd)\n\t\t\tif !result[ix] {\n\t\t\t\tfailed = true"
  },
  {
    "id" : "5d41ce4e-05f0-4603-80d4-02aeee091798",
    "prId" : 16984,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3fad4fb4-efc5-4ff5-851e-dfdded6ffe43",
        "parentId" : null,
        "authorId" : "719d0e19-fcef-4b47-afac-404318b9514f",
        "body" : "f.Client will be nil due to NewFramework's `AfterEach`.\n\nthe workaround for now is to call `NewFramework` after this `AfterEach` is defined.\n",
        "createdAt" : "2015-11-09T23:30:12Z",
        "updatedAt" : "2015-11-16T23:09:06Z",
        "lastEditedBy" : "719d0e19-fcef-4b47-afac-404318b9514f",
        "tags" : [
        ]
      },
      {
        "id" : "7e7e7449-ac00-4e82-8258-0a573d96b156",
        "parentId" : "3fad4fb4-efc5-4ff5-851e-dfdded6ffe43",
        "authorId" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "body" : "done.\n",
        "createdAt" : "2015-11-12T05:54:02Z",
        "updatedAt" : "2015-11-16T23:09:06Z",
        "lastEditedBy" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "tags" : [
        ]
      }
    ],
    "commit" : "ed91d5564b84cb8aa7228172dcaca279ee9d684b",
    "line" : null,
    "diffHunk" : "@@ -1,1 +62,66 @@\t\t\tnamespaceName := api.NamespaceSystem\n\t\t\tBy(fmt.Sprintf(\"Collecting events from namespace %q.\", namespaceName))\n\t\t\tevents, err := f.Client.Events(namespaceName).List(labels.Everything(), fields.Everything())\n\t\t\tExpect(err).NotTo(HaveOccurred())\n"
  },
  {
    "id" : "95da9cf8-96db-49ea-a434-150065339cd6",
    "prId" : 8784,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e5504fb5-855d-4de1-8d96-6695799b3eb6",
        "parentId" : null,
        "authorId" : null,
        "body" : "I'm pretty sure that your ssh connection will be dropped as soon as the ifdown kicks in, so the rest of the command will not execute, and the node will be borked forever.  Have you tested this?\n\nAssuming that my assumption above is right, you could schedule a cron job or execute a nohup to make it happen even after the ssh connection gets dropped.\n",
        "createdAt" : "2015-05-28T03:18:00Z",
        "updatedAt" : "2015-05-28T03:18:00Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "e69d9b26-ae20-4ccb-bf5b-480dee38c65a",
        "parentId" : "e5504fb5-855d-4de1-8d96-6695799b3eb6",
        "authorId" : "c929c906-4dfb-433b-9bc7-1b4b05c176f8",
        "body" : "I did run the test and all cases are passing. Probably the timeout for ssh session is longer then 2 minutes. Still, adding nohup will make it more robust.\n",
        "createdAt" : "2015-05-28T14:15:26Z",
        "updatedAt" : "2015-05-28T14:15:26Z",
        "lastEditedBy" : "c929c906-4dfb-433b-9bc7-1b4b05c176f8",
        "tags" : [
        ]
      },
      {
        "id" : "e9779528-8b67-4295-8a64-c47dafb3beaf",
        "parentId" : "e5504fb5-855d-4de1-8d96-6695799b3eb6",
        "authorId" : null,
        "body" : "Aah - that makes sense.\nIn that case I'm fairly happy to merge this as is, and make it more robust with nohup or cron in a separate PR. \n",
        "createdAt" : "2015-05-28T17:38:58Z",
        "updatedAt" : "2015-05-28T17:38:58Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "039314cce13a859a36d78f2fa052ceb009e124a7",
    "line" : 52,
    "diffHunk" : "@@ -1,1 +81,85 @@\tIt(\"each node by switching off the network interface and ensure they function upon switch on\", func() {\n\t\t// switch the network interface off for a while to simulate a network outage\n\t\ttestReboot(c, \"sudo ifdown eth0 && sleep 120 && sudo ifup eth0\")\n\t})\n"
  },
  {
    "id" : "1905e78b-278e-4fa6-b4a7-e7c83fbdd2e2",
    "prId" : 8784,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "48f6cd37-ef0b-4cd2-b25d-b129bd3afbb2",
        "parentId" : null,
        "authorId" : null,
        "body" : "packets, not packages\n",
        "createdAt" : "2015-05-28T03:18:19Z",
        "updatedAt" : "2015-05-28T03:18:19Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "039314cce13a859a36d78f2fa052ceb009e124a7",
    "line" : 55,
    "diffHunk" : "@@ -1,1 +84,88 @@\t})\n\n\tIt(\"each node by dropping all inbound packages for a while and ensure they function afterwards\", func() {\n\t\t// tell the firewall to drop all inbound packets for a while\n\t\ttestReboot(c, \"sudo iptables -A INPUT -j DROP && sleep 120 && sudo iptables -D INPUT -j DROP\")"
  },
  {
    "id" : "1af20ab4-85df-47bd-b2f9-8738f4809ef0",
    "prId" : 8784,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d7fc2ee3-14f9-45d9-aec5-7484c26c05b9",
        "parentId" : null,
        "authorId" : null,
        "body" : "Same comment as above.  I don't think that this will work.  Same workaround.  Please test it properly, as I'm only speculating that it will work.\n",
        "createdAt" : "2015-05-28T03:18:54Z",
        "updatedAt" : "2015-05-28T03:18:54Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "039314cce13a859a36d78f2fa052ceb009e124a7",
    "line" : 57,
    "diffHunk" : "@@ -1,1 +86,90 @@\tIt(\"each node by dropping all inbound packages for a while and ensure they function afterwards\", func() {\n\t\t// tell the firewall to drop all inbound packets for a while\n\t\ttestReboot(c, \"sudo iptables -A INPUT -j DROP && sleep 120 && sudo iptables -D INPUT -j DROP\")\n\t})\n"
  },
  {
    "id" : "ddf747d6-578e-445b-b716-3027f64f1574",
    "prId" : 8784,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c8bd949d-264c-4a65-863f-6580faa91299",
        "parentId" : null,
        "authorId" : null,
        "body" : "packets, not packages.\n",
        "createdAt" : "2015-05-28T03:19:08Z",
        "updatedAt" : "2015-05-28T03:19:08Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "039314cce13a859a36d78f2fa052ceb009e124a7",
    "line" : 60,
    "diffHunk" : "@@ -1,1 +89,93 @@\t})\n\n\tIt(\"each node by dropping all outbound packages for a while and ensure they function afterwards\", func() {\n\t\t// tell the firewall to drop all outbound packets for a while\n\t\ttestReboot(c, \"sudo iptables -A OUTPUT -j DROP && sleep 120 && sudo iptables -D OUTPUT -j DROP\")"
  },
  {
    "id" : "7217205b-86f6-4057-8e83-7e20fc47eb59",
    "prId" : 8784,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e6672279-a696-4baa-9c62-70a01b681159",
        "parentId" : null,
        "authorId" : null,
        "body" : "Same comment as above.  Have you tested that this actually works?\n",
        "createdAt" : "2015-05-28T03:19:29Z",
        "updatedAt" : "2015-05-28T03:19:29Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "039314cce13a859a36d78f2fa052ceb009e124a7",
    "line" : 62,
    "diffHunk" : "@@ -1,1 +91,95 @@\tIt(\"each node by dropping all outbound packages for a while and ensure they function afterwards\", func() {\n\t\t// tell the firewall to drop all outbound packets for a while\n\t\ttestReboot(c, \"sudo iptables -A OUTPUT -j DROP && sleep 120 && sudo iptables -D OUTPUT -j DROP\")\n\t})\n})"
  },
  {
    "id" : "014e7fc0-4c51-419a-bd9e-ce067f02e787",
    "prId" : 8784,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "609d237e-085f-47ad-a663-c3d7c3a3936e",
        "parentId" : null,
        "authorId" : null,
        "body" : "No, I think that you need to error out and fail the test if the ssh session fails. Use nohup or a cron job so that you can cleanly terminate the ssh session before the actual reboot occurs.\n",
        "createdAt" : "2015-05-28T03:23:23Z",
        "updatedAt" : "2015-05-28T03:23:23Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "039314cce13a859a36d78f2fa052ceb009e124a7",
    "line" : 161,
    "diffHunk" : "@@ -1,1 +198,202 @@\t// Reboot the node.\n\tif err = issueSSHCommand(node, provider, rebootCmd); err != nil {\n\t\t// Just log the error as reboot may cause unclean termination of ssh session, which is expected.\n\t\tLogf(\"Error while issuing ssh command: %v\", err)\n\t}"
  }
]
[
  {
    "id" : "6ed7bc99-646a-4c9f-b286-fa27fda18bb8",
    "prId" : 94246,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/94246#pullrequestreview-475840747",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0b196968-0f5e-483f-b267-36ccc095699d",
        "parentId" : null,
        "authorId" : "d10fef96-5a18-44e7-b23e-735de7561af7",
        "body" : "The comments for skipUnsupportedTest may also need to be updated.",
        "createdAt" : "2020-08-26T20:37:58Z",
        "updatedAt" : "2020-08-26T20:37:58Z",
        "lastEditedBy" : "d10fef96-5a18-44e7-b23e-735de7561af7",
        "tags" : [
        ]
      }
    ],
    "commit" : "d35eb5632251a6969a4dcb9f271f7f0755c6be94",
    "line" : 30,
    "diffHunk" : "@@ -1,1 +150,154 @@\tvar isSupported bool\n\n\t// 1. Check if Whether volType is supported by driver from its interface\n\tswitch pattern.VolType {\n\tcase testpatterns.InlineVolume:"
  },
  {
    "id" : "dfff09e3-3f62-49a0-8705-df8693a77576",
    "prId" : 80382,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/80382#pullrequestreview-266333229",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "94420f4f-534d-4cc9-9e51-01465b42b768",
        "parentId" : null,
        "authorId" : "5f2c1de8-4266-42c0-b343-ba247af3578f",
        "body" : "I guess from a storage perspective, it made sense to split this one out? If your only goal was to de-dupe the instantiation of the PVC VolumeSource, then I think it was small enough to have twice.",
        "createdAt" : "2019-07-24T23:22:45Z",
        "updatedAt" : "2019-07-24T23:25:06Z",
        "lastEditedBy" : "5f2c1de8-4266-42c0-b343-ba247af3578f",
        "tags" : [
        ]
      }
    ],
    "commit" : "e194cf24cccc88b9d7190465bb20931abed21f55",
    "line" : 34,
    "diffHunk" : "@@ -1,1 +243,247 @@}\n\nfunc createVolumeSource(pvcName string, readOnly bool) *v1.VolumeSource {\n\treturn &v1.VolumeSource{\n\t\tPersistentVolumeClaim: &v1.PersistentVolumeClaimVolumeSource{"
  },
  {
    "id" : "7c630f41-a54f-4398-a43a-f1a5cc497b17",
    "prId" : 78306,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/78306#pullrequestreview-243853155",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c188b22c-8841-40b2-8e95-ef14afa6c5b5",
        "parentId" : null,
        "authorId" : "ba0b9c6e-ec4c-4d1b-832e-751e6109bf38",
        "body" : "Can this be left empty if the test suite has no particular restrictions? For example, specifying a maximum size seems unnecessary.\r\n\r\n",
        "createdAt" : "2019-05-29T18:40:10Z",
        "updatedAt" : "2019-10-07T17:34:11Z",
        "lastEditedBy" : "ba0b9c6e-ec4c-4d1b-832e-751e6109bf38",
        "tags" : [
        ]
      },
      {
        "id" : "f43dcd51-ed9a-42c1-8238-c4f55e721663",
        "parentId" : "c188b22c-8841-40b2-8e95-ef14afa6c5b5",
        "authorId" : "156ad04f-2e51-4f89-8894-641967cb026b",
        "body" : "Specifying a maximum size is necessary if It use `getSizeRangesIntersection`  otherwise it may skip because it don't know how to decide `Intersection`",
        "createdAt" : "2019-05-30T15:13:15Z",
        "updatedAt" : "2019-10-07T17:34:11Z",
        "lastEditedBy" : "156ad04f-2e51-4f89-8894-641967cb026b",
        "tags" : [
        ]
      }
    ],
    "commit" : "b5c14323286d26490f8c12884fb1d7f36e2d9eeb",
    "line" : 35,
    "diffHunk" : "@@ -1,1 +75,79 @@\tfeatureTag         string                     // featureTag for the TestSuite\n\ttestPatterns       []testpatterns.TestPattern // Slice of TestPattern for the TestSuite\n\tsupportedSizeRange volume.SizeRange           // Size range supported by the test suite\n}\n"
  },
  {
    "id" : "8ac347cb-e79a-432f-b36d-f3cc7e1b7226",
    "prId" : 78306,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/78306#pullrequestreview-271393425",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ddf5b9cf-c7ba-4ff5-9dbc-b072199e8947",
        "parentId" : null,
        "authorId" : "ba0b9c6e-ec4c-4d1b-832e-751e6109bf38",
        "body" : "I think this logic of setting the default size before the comparison is wrong.\r\n\r\nConsider this example: `first` is empty (no min, no max set) and `second` is `Min = 1Mi`, `Max = 1Mi`. My expectation is that this results in `1Mi` being returned. I think what the code does instead is replace `first.Min` with `defaultMinSize  = \"5Gi\"` and then fails to find an intersection.\r\n\r\nThe bottom line is, you need a table-driven unit test for this function. It's non-trivial to ensure that the corner cases are handled.\r\n\r\n\r\n",
        "createdAt" : "2019-07-17T05:48:05Z",
        "updatedAt" : "2019-10-07T17:34:11Z",
        "lastEditedBy" : "ba0b9c6e-ec4c-4d1b-832e-751e6109bf38",
        "tags" : [
        ]
      },
      {
        "id" : "781c8f1e-98a7-45b7-b8eb-b0426f214119",
        "parentId" : "ddf5b9cf-c7ba-4ff5-9dbc-b072199e8947",
        "authorId" : "156ad04f-2e51-4f89-8894-641967cb026b",
        "body" : "I have updated this PR base on all points you mentioned. There's a UT  Test_getSizeRangesIntersection to test all corner cases. \r\nPlease tell me if I miss something.",
        "createdAt" : "2019-08-06T14:37:06Z",
        "updatedAt" : "2019-10-07T17:34:11Z",
        "lastEditedBy" : "156ad04f-2e51-4f89-8894-641967cb026b",
        "tags" : [
        ]
      }
    ],
    "commit" : "b5c14323286d26490f8c12884fb1d7f36e2d9eeb",
    "line" : 77,
    "diffHunk" : "@@ -1,1 +427,431 @@// intersection of the intervals (if it exists) and return the minimum of the intersection\n// to be used as the claim size for the test.\n// if value not set, that means there's no minimum or maximum size limitation and we set default size for it.\nfunc getSizeRangesIntersection(first volume.SizeRange, second volume.SizeRange) (string, error) {\n\tvar firstMin, firstMax, secondMin, secondMax resource.Quantity"
  },
  {
    "id" : "112ead6a-8ec9-4f43-b396-cf005220890b",
    "prId" : 78051,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/78051#pullrequestreview-243439810",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2309ada9-c514-45e2-acd3-aca99709af1e",
        "parentId" : null,
        "authorId" : "c9194ca8-ba2f-414b-a596-d6a97308f1aa",
        "body" : "I'm not a fan of hard-coding provider information anywhere in the code base. I would prefer to see a change that makes it possible for a provider to override the list. Of course, this make the scope of the patch get larger but as we're moving to remove more cloud provider code from upstream kubernetes it's important that we stop hard-coding provider behavior.",
        "createdAt" : "2019-05-27T10:17:10Z",
        "updatedAt" : "2019-05-27T10:17:25Z",
        "lastEditedBy" : "c9194ca8-ba2f-414b-a596-d6a97308f1aa",
        "tags" : [
        ]
      },
      {
        "id" : "984a18a9-30c5-4e23-800e-ea5bab4e6279",
        "parentId" : "2309ada9-c514-45e2-acd3-aca99709af1e",
        "authorId" : "542e5d2f-2ff9-4674-ab44-78f31768e7a1",
        "body" : "could you clarify what you mean by this?\r\n\r\nbtw. This issue is breaking running the tests on a local machine so its pretty important to get in. But I'm willing to understand what you mean and create an issue to work on later",
        "createdAt" : "2019-05-29T18:26:37Z",
        "updatedAt" : "2019-05-29T18:26:37Z",
        "lastEditedBy" : "542e5d2f-2ff9-4674-ab44-78f31768e7a1",
        "tags" : [
        ]
      }
    ],
    "commit" : "9854ecbeefcb0b641ef812a071117275f073f1d7",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +508,512 @@\nfunc getVolumeOpCounts(c clientset.Interface, pluginName string) opCounts {\n\tif !framework.ProviderIs(\"gce\", \"gke\", \"aws\") {\n\t\treturn opCounts{}\n\t}"
  },
  {
    "id" : "6de76702-3575-4b80-aeb1-f30cdf4963f1",
    "prId" : 77101,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/77101#pullrequestreview-230934704",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e74846f3-008b-42a4-86ce-fcd2a575b901",
        "parentId" : null,
        "authorId" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "body" : "Maybe call the field in the driver config InTreePluginName then if you don't want it to be used for csi drivers",
        "createdAt" : "2019-04-26T00:14:28Z",
        "updatedAt" : "2019-05-01T18:24:28Z",
        "lastEditedBy" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "tags" : [
        ]
      }
    ],
    "commit" : "1271237d23bf828758a42eec531483d53cc006d5",
    "line" : 146,
    "diffHunk" : "@@ -1,1 +585,589 @@\nfunc validateMigrationVolumeOpCounts(cs clientset.Interface, pluginName string, oldInTreeOps, oldMigratedOps opCounts) {\n\tif len(pluginName) == 0 {\n\t\t// This is a native CSI Driver and we don't check ops\n\t\treturn"
  },
  {
    "id" : "1c1b086f-f696-48f1-a95b-abafd37e2403",
    "prId" : 77101,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/77101#pullrequestreview-231305693",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ec274f3d-0e10-42fc-944a-6bdf7877e326",
        "parentId" : null,
        "authorId" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "body" : "Should we check this first? It saves querying the components for the metrics",
        "createdAt" : "2019-04-26T00:16:05Z",
        "updatedAt" : "2019-05-01T18:24:28Z",
        "lastEditedBy" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "tags" : [
        ]
      },
      {
        "id" : "20911c1e-c3ea-45ef-bdde-2aeb6fba9c22",
        "parentId" : "ec274f3d-0e10-42fc-944a-6bdf7877e326",
        "authorId" : "542e5d2f-2ff9-4674-ab44-78f31768e7a1",
        "body" : "even if this condition is not true, we want to get the `newInTreeOps`. However, with https://github.com/kubernetes/kubernetes/pull/77101#discussion_r279062110 this may no longer be true",
        "createdAt" : "2019-04-26T18:41:04Z",
        "updatedAt" : "2019-05-01T18:24:28Z",
        "lastEditedBy" : "542e5d2f-2ff9-4674-ab44-78f31768e7a1",
        "tags" : [
        ]
      }
    ],
    "commit" : "1271237d23bf828758a42eec531483d53cc006d5",
    "line" : 151,
    "diffHunk" : "@@ -1,1 +590,594 @@\t}\n\n\tif sets.NewString(strings.Split(*migratedPlugins, \",\")...).Has(pluginName) {\n\t\t// If this plugin is migrated based on the test flag storage.migratedPlugins\n\t\tnewInTreeOps, _ := getMigrationVolumeOpCounts(cs, pluginName)"
  },
  {
    "id" : "4d2b887d-23c9-4f9f-8517-77bfac319fbb",
    "prId" : 77101,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/77101#pullrequestreview-231308299",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c6789f1f-9b0d-4ec6-9ae3-2e7d335624d0",
        "parentId" : null,
        "authorId" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "body" : "Can this be 0? Why would the intree metric be emitted?",
        "createdAt" : "2019-04-26T01:18:07Z",
        "updatedAt" : "2019-05-01T18:24:28Z",
        "lastEditedBy" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "tags" : [
        ]
      },
      {
        "id" : "51c5fb10-c1e1-43fa-8ee5-34df3887b204",
        "parentId" : "c6789f1f-9b0d-4ec6-9ae3-2e7d335624d0",
        "authorId" : "542e5d2f-2ff9-4674-ab44-78f31768e7a1",
        "body" : "yes, they can both be 0. The in-tree metric would be emitted if CSI Migration was not working and the operation was actually done with the in-tree plugin",
        "createdAt" : "2019-04-26T18:47:05Z",
        "updatedAt" : "2019-05-01T18:24:28Z",
        "lastEditedBy" : "542e5d2f-2ff9-4674-ab44-78f31768e7a1",
        "tags" : [
        ]
      }
    ],
    "commit" : "1271237d23bf828758a42eec531483d53cc006d5",
    "line" : 156,
    "diffHunk" : "@@ -1,1 +595,599 @@\n\t\tfor op, count := range newInTreeOps {\n\t\t\tif count != oldInTreeOps[op] {\n\t\t\t\tframework.Failf(\"In-tree plugin %v migrated to CSI Driver, however found %v %v metrics for in-tree plugin\", pluginName, count-oldInTreeOps[op], op)\n\t\t\t}"
  },
  {
    "id" : "3ee56bc3-66b7-4b80-ac7e-37171b7df424",
    "prId" : 75796,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/75796#pullrequestreview-219747380",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9e3064db-baa7-4430-8b02-84eb1774c76d",
        "parentId" : null,
        "authorId" : "34f61776-88da-4b26-aa20-3c4f92530d05",
        "body" : "do callers of `createVolumeSourceWithPVCPVFromDynamicProvisionSC()` handle nil PVC and PVs gracefully?",
        "createdAt" : "2019-03-27T21:40:44Z",
        "updatedAt" : "2019-03-29T22:00:37Z",
        "lastEditedBy" : "34f61776-88da-4b26-aa20-3c4f92530d05",
        "tags" : [
        ]
      },
      {
        "id" : "9fabc89e-84ff-4866-a8d1-828e919347af",
        "parentId" : "9e3064db-baa7-4430-8b02-84eb1774c76d",
        "authorId" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "body" : "at least in this file yes.  I'm currently running all of the tests to see if I can find other issues",
        "createdAt" : "2019-03-27T21:57:41Z",
        "updatedAt" : "2019-03-29T22:00:37Z",
        "lastEditedBy" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "tags" : [
        ]
      }
    ],
    "commit" : "634be030a82a20c5e7d273e92d5ea397366035df",
    "line" : 15,
    "diffHunk" : "@@ -1,1 +326,330 @@\tExpect(err).NotTo(HaveOccurred())\n\n\tif !isDelayedBinding(sc) {\n\t\terr = framework.WaitForPersistentVolumeClaimPhase(v1.ClaimBound, cs, pvc.Namespace, pvc.Name, framework.Poll, framework.ClaimProvisionTimeout)\n\t\tExpect(err).NotTo(HaveOccurred())"
  },
  {
    "id" : "09732ed1-4453-4c3d-8933-625b5ec6a541",
    "prId" : 72434,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/72434#pullrequestreview-191327535",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "18a7b548-3c59-4e63-8af9-c806462479e0",
        "parentId" : null,
        "authorId" : "82a1304b-df47-4b74-9e13-c485af95af2f",
        "body" : "Should `r.volume` be set to `nil` after this?",
        "createdAt" : "2019-01-08T15:53:13Z",
        "updatedAt" : "2019-02-15T10:06:24Z",
        "lastEditedBy" : "82a1304b-df47-4b74-9e13-c485af95af2f",
        "tags" : [
        ]
      },
      {
        "id" : "fe93abe7-c2b7-4498-9ad1-79aea98f6a19",
        "parentId" : "18a7b548-3c59-4e63-8af9-c806462479e0",
        "authorId" : "ba0b9c6e-ec4c-4d1b-832e-751e6109bf38",
        "body" : "`r.volume` is still valid and `r` goes out of scope soon after. I personally wouldn't bother.\r\n",
        "createdAt" : "2019-01-10T17:33:12Z",
        "updatedAt" : "2019-02-15T10:06:24Z",
        "lastEditedBy" : "ba0b9c6e-ec4c-4d1b-832e-751e6109bf38",
        "tags" : [
        ]
      }
    ],
    "commit" : "ec3655a1d40ced6b1873e627b736aae1cf242477",
    "line" : 189,
    "diffHunk" : "@@ -1,1 +253,257 @@\t// Cleanup volume for pre-provisioned volume tests\n\tif r.volume != nil {\n\t\tr.volume.DeleteVolume()\n\t}\n}"
  },
  {
    "id" : "b30910c2-2dbb-4ab4-82c3-d6537326ffce",
    "prId" : 68025,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/68025#pullrequestreview-173136040",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e6ff246e-29f3-408d-b1a1-6a1edd08e3ab",
        "parentId" : null,
        "authorId" : "ba0b9c6e-ec4c-4d1b-832e-751e6109bf38",
        "body" : "Is framework.VolumeTestConfig a good choice here? It has lots of options that don't seem to be used anymore, or at least don't have an effect. For example, provisioning.go only uses ClientNodeName but ignores NodeSelector.\r\n\r\nDo you think it might be clear to have a testsuite.Config which has just the options that really matter for the testsuite package?\r\n",
        "createdAt" : "2018-11-08T17:05:47Z",
        "updatedAt" : "2018-11-08T17:05:47Z",
        "lastEditedBy" : "ba0b9c6e-ec4c-4d1b-832e-751e6109bf38",
        "tags" : [
        ]
      },
      {
        "id" : "fd875d24-2bd9-44c7-8f60-0b5945997b28",
        "parentId" : "e6ff246e-29f3-408d-b1a1-6a1edd08e3ab",
        "authorId" : "9ce7bd1a-5286-4173-88a4-039146bf0d46",
        "body" : "Good points. \r\n\r\nThis framework has created in a way that existing tests can be called in a common way for any drivers. (These tests were originally tightly bound to particular driver's particular source, like volume source, pv source, or storage class. And this PR was aimed to separate them to drivers and testsuites, and make testsuites called in a common loop.) \r\n\r\nIn the process, I tried to keep the existing tests as much as they were so that I won't break how tests were working. In other word, how the test is called was changed, but how each test works haven't been improved, yet. \r\n\r\nNow, above aim was achieved, so we are ready to consider improving how each test works. Defining a new testsuite.Config that can be commonly used in all testsuites will be one of the remaining items on how each test works. And it will be helpful in adding more testsuites easily without bugs in the future.\r\n\r\n\r\n ",
        "createdAt" : "2018-11-08T19:34:35Z",
        "updatedAt" : "2018-11-08T19:34:35Z",
        "lastEditedBy" : "9ce7bd1a-5286-4173-88a4-039146bf0d46",
        "tags" : [
        ]
      }
    ],
    "commit" : "b89b367247039f4a46a1ca2f0e4e906d723d79d2",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +67,71 @@\n// RunTestSuite runs all testpatterns of all testSuites for a driver\nfunc RunTestSuite(f *framework.Framework, config framework.VolumeTestConfig, driver drivers.TestDriver, tsInits []func() TestSuite, tunePatternFunc func([]testpatterns.TestPattern) []testpatterns.TestPattern) {\n\tfor _, testSuiteInit := range tsInits {\n\t\tsuite := testSuiteInit()"
  }
]
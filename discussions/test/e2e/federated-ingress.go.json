[
  {
    "id" : "b73927dc-e121-40dd-ae54-6ad605c79129",
    "prId" : 36630,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/36630#pullrequestreview-9165623",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8034aa59-873b-4913-8d1d-4ae23c3da247",
        "parentId" : null,
        "authorId" : "f6905dc9-1980-4381-8220-a1c7ad8d5c82",
        "body" : "Can we decide that this wait is over if `err != nil`? It is possible that there was an error due to an intermittent client-server connection failure. I think they should be separated out and `false` should be returned for `err != nil` case.\n",
        "createdAt" : "2016-11-16T21:16:07Z",
        "updatedAt" : "2016-11-18T22:44:36Z",
        "lastEditedBy" : "f6905dc9-1980-4381-8220-a1c7ad8d5c82",
        "tags" : [
        ]
      },
      {
        "id" : "bd47a290-c3f1-4ebd-ac24-ef1bbbf840d5",
        "parentId" : "8034aa59-873b-4913-8d1d-4ae23c3da247",
        "authorId" : "f2369046-26b1-4b8c-a8cd-5671ab22066c",
        "body" : "You mean we should still return `false, nil` even if err != nil?\nI dont think that we should do that. If there was an error, we should return `false, nil` (except when the error was NotFound, which is what we want and hence return true)\n",
        "createdAt" : "2016-11-18T03:52:36Z",
        "updatedAt" : "2016-11-18T22:44:36Z",
        "lastEditedBy" : "f2369046-26b1-4b8c-a8cd-5671ab22066c",
        "tags" : [
        ]
      }
    ],
    "commit" : "90645ce2b7e1ba85c8e27d8391b58deea8b5dae8",
    "line" : null,
    "diffHunk" : "@@ -1,1 +328,332 @@\terr = wait.Poll(framework.Poll, wait.ForeverTestTimeout, func() (bool, error) {\n\t\t_, err := clientset.Extensions().Ingresses(namespace).Get(ingressName)\n\t\tif err != nil && errors.IsNotFound(err) {\n\t\t\treturn true, nil\n\t\t}"
  },
  {
    "id" : "8f765243-b7a7-4e2a-add5-e3b45078f024",
    "prId" : 36630,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/36630#pullrequestreview-9318599",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "15511219-0509-42c8-b0c2-b528a587809e",
        "parentId" : null,
        "authorId" : "f6905dc9-1980-4381-8220-a1c7ad8d5c82",
        "body" : "I am not a big fan of having lots of logic in tests and I still think it should be split into 3 separate functions. But it is fine for now, I guess.\n",
        "createdAt" : "2016-11-18T22:21:48Z",
        "updatedAt" : "2016-11-18T22:44:36Z",
        "lastEditedBy" : "f6905dc9-1980-4381-8220-a1c7ad8d5c82",
        "tags" : [
        ]
      }
    ],
    "commit" : "90645ce2b7e1ba85c8e27d8391b58deea8b5dae8",
    "line" : 123,
    "diffHunk" : "@@ -1,1 +229,233 @@\tfor clusterName, clusterClientset := range clusters {\n\t\t_, err := clusterClientset.Extensions().Ingresses(nsName).Get(ingressName)\n\t\tif shouldExist && errors.IsNotFound(err) {\n\t\t\terrMessages = append(errMessages, fmt.Sprintf(\"unexpected NotFound error for ingress %s in cluster %s, expected ingress to exist\", ingressName, clusterName))\n\t\t} else if !shouldExist && !errors.IsNotFound(err) {"
  },
  {
    "id" : "0e273bad-a3cd-4994-941c-6e58de050ba5",
    "prId" : 34652,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/34652#pullrequestreview-3977237",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "44d98906-0ae8-4e52-b49d-62f5c56e7602",
        "parentId" : null,
        "authorId" : "f2369046-26b1-4b8c-a8cd-5671ab22066c",
        "body" : "Instead of passing the clientset, you can pass  IngressesGetter or IngressInterface or just a func(namespace, ingressName) that deletes the ingress. You wont need to duplicate the func then.\n",
        "createdAt" : "2016-10-12T22:30:05Z",
        "updatedAt" : "2016-10-12T22:30:28Z",
        "lastEditedBy" : "f2369046-26b1-4b8c-a8cd-5671ab22066c",
        "tags" : [
        ]
      },
      {
        "id" : "755392dd-ad2c-4ea2-84db-946f0fdd41aa",
        "parentId" : "44d98906-0ae8-4e52-b49d-62f5c56e7602",
        "authorId" : null,
        "body" : "Agreed, will do in followup PR.\n",
        "createdAt" : "2016-10-12T22:45:55Z",
        "updatedAt" : "2016-10-12T22:45:55Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "455e79bd526825b2994f8d31e4d6a8a586efdd8b",
    "line" : 45,
    "diffHunk" : "@@ -1,1 +278,282 @@\n// TODO: quinton: This is largely a cut 'n paste of the above.  Yuck! Refactor as soon as we have a common interface implmented by both fedclientset.Clientset and kubeclientset.Clientset\nfunc deleteClusterIngressOrFail(clusterName string, clientset *kubeclientset.Clientset, namespace string, ingressName string) {\n\tif clientset == nil || len(namespace) == 0 || len(ingressName) == 0 {\n\t\tFail(fmt.Sprintf(\"Internal error: invalid parameters passed to deleteClusterIngressOrFail: cluster: %q, clientset: %v, namespace: %v, ingress: %v\", clusterName, clientset, namespace, ingressName))"
  },
  {
    "id" : "4ee5744d-de7a-4b3a-bbd0-d2518a3495bd",
    "prId" : 34652,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/34652#pullrequestreview-3975342",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2da652ff-24af-4470-b101-3a36f10ea616",
        "parentId" : null,
        "authorId" : "f6905dc9-1980-4381-8220-a1c7ad8d5c82",
        "body" : ":+1: Thanks!\n",
        "createdAt" : "2016-10-12T22:30:42Z",
        "updatedAt" : "2016-10-12T22:37:51Z",
        "lastEditedBy" : "f6905dc9-1980-4381-8220-a1c7ad8d5c82",
        "tags" : [
        ]
      }
    ],
    "commit" : "455e79bd526825b2994f8d31e4d6a8a586efdd8b",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +65,69 @@\t\tIt(\"should be created and deleted successfully\", func() {\n\t\t\tframework.SkipUnlessFederated(f.Client)\n\t\t\tframework.SkipUnlessProviderIs(\"gce\", \"gke\") // TODO: Federated ingress is not yet supported on non-GCP platforms.\n\t\t\tnsName := f.FederationNamespace.Name\n\t\t\tingress := createIngressOrFail(f.FederationClientset_1_5, nsName)"
  },
  {
    "id" : "45a179f7-568d-4267-bb0d-4472004c941f",
    "prId" : 34652,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/34652#pullrequestreview-3977145",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "76f11f3b-04e7-4e7c-9790-bd18522fb893",
        "parentId" : null,
        "authorId" : "f6905dc9-1980-4381-8220-a1c7ad8d5c82",
        "body" : "Is there a reason you cannot use `deleteClusterIngressOrFail()` here?\n",
        "createdAt" : "2016-10-12T22:32:11Z",
        "updatedAt" : "2016-10-12T22:37:51Z",
        "lastEditedBy" : "f6905dc9-1980-4381-8220-a1c7ad8d5c82",
        "tags" : [
        ]
      },
      {
        "id" : "abd8c304-14c3-4f9f-97de-0d51c727e37f",
        "parentId" : "76f11f3b-04e7-4e7c-9790-bd18522fb893",
        "authorId" : "f6905dc9-1980-4381-8220-a1c7ad8d5c82",
        "body" : "Also, I think you need to do something akin to `cleanupServiceShardsAndProviderResources()` (https://github.com/kubernetes/kubernetes/blob/master/test/e2e/federated-ingress.go#L139) to ensure the underlying cloud resources are cleaned up. \n\nFor an Ingress specific example, see the Ingress e2e test - https://github.com/kubernetes/kubernetes/blob/master/test/e2e/ingress_utils.go#L311\n\nBut let's get this PR in first.\n",
        "createdAt" : "2016-10-12T22:35:40Z",
        "updatedAt" : "2016-10-12T22:37:51Z",
        "lastEditedBy" : "f6905dc9-1980-4381-8220-a1c7ad8d5c82",
        "tags" : [
        ]
      },
      {
        "id" : "6445a0d6-472f-4cfc-93b8-85521ac8bac7",
        "parentId" : "76f11f3b-04e7-4e7c-9790-bd18522fb893",
        "authorId" : null,
        "body" : "Regarding your first comment, I followed the existing style used for the deletion of the federated ingresses.\n\nAgreed about the GCE resources.  I'll add that in a separate PR.\n",
        "createdAt" : "2016-10-12T22:45:11Z",
        "updatedAt" : "2016-10-12T22:45:21Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "455e79bd526825b2994f8d31e4d6a8a586efdd8b",
    "line" : 24,
    "diffHunk" : "@@ -1,1 +108,112 @@\t\t\t\tframework.ExpectNoError(err, \"Error deleting ingress %q/%q in federation\", ns, ingress.Name)\n\t\t\t\tfor clusterName, cluster := range clusters {\n\t\t\t\t\terr := cluster.Ingresses(ns).Delete(ingress.Name, &v1.DeleteOptions{})\n\t\t\t\t\tframework.ExpectNoError(err, \"Error deleting ingress %q/%q in cluster %q\", ns, ingress.Name, clusterName)\n\t\t\t\t}"
  },
  {
    "id" : "9d75228c-1d8c-4bb9-b7f5-1b886306fd99",
    "prId" : 32105,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c7bd0c55-95e8-4ff8-8d2d-91ad9b9be274",
        "parentId" : null,
        "authorId" : "f2369046-26b1-4b8c-a8cd-5671ab22066c",
        "body" : "nit: At other places in this test, we use nsName. Should be consistent.\n",
        "createdAt" : "2016-09-06T18:56:43Z",
        "updatedAt" : "2016-09-06T18:56:43Z",
        "lastEditedBy" : "f2369046-26b1-4b8c-a8cd-5671ab22066c",
        "tags" : [
        ]
      }
    ],
    "commit" : "b789e226184f22cbf7907655c463526e2f59a08b",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +94,98 @@\t\t\tclusters = map[string]*cluster{}\n\t\t\tprimaryClusterName = registerClusters(clusters, UserAgentName, federationName, f)\n\t\t\tns = f.FederationNamespace.Name\n\t\t})\n"
  }
]
[
  {
    "id" : "cf7be1b4-dcd0-4653-83cf-131c1ccddb42",
    "prId" : 103158,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/103158#pullrequestreview-710506634",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0e43beee-401f-421d-8996-f942368887eb",
        "parentId" : null,
        "authorId" : "c490e441-2b9f-41f2-8559-d47be0ea8836",
        "body" : "What does this mean? It seems to me that the original assertion was \"all connections to pod a in nsX should fail, but everything else should succeed\" (which is correct), while the new assertion is \"all connections from any pod in nsX to anywhere should fail, but everything else should succeed\"... which is totally wrong. Or am I misunderstanding the reachability dsl?",
        "createdAt" : "2021-07-19T19:00:32Z",
        "updatedAt" : "2021-07-19T19:00:32Z",
        "lastEditedBy" : "c490e441-2b9f-41f2-8559-d47be0ea8836",
        "tags" : [
        ]
      },
      {
        "id" : "59390ea9-d3c4-4cc7-9e09-75441c826b45",
        "parentId" : "0e43beee-401f-421d-8996-f942368887eb",
        "authorId" : "13779685-87a1-45d2-907c-e13dd79f0984",
        "body" : "This says that ingress to all pods in nsX should be denied but pods from nsX can connect to pods in nsY or nsZ. \r\n\r\nIn this test, the very first policy we have is to `deny ingress` to all pods(empty label selector) in nsX. We then apply a policy to allow SCTP traffic to pod a in nsX but this policy is OR'ed with the previous ones so ingress to other pods in nsX is still denied. \r\n\r\nOriginally we were checking for only pod a in reachability matrix and the new assertion checks for all pods in nsX. \r\n\r\ncontext for reachability matrix: https://prow.k8s.io/view/gs/kubernetes-jenkins/logs/ci-kubernetes-e2e-ubuntu-gce-network-policies/1417140063304683520#1:build-log.txt%3A39543",
        "createdAt" : "2021-07-19T20:23:22Z",
        "updatedAt" : "2021-07-19T20:30:09Z",
        "lastEditedBy" : "13779685-87a1-45d2-907c-e13dd79f0984",
        "tags" : [
        ]
      },
      {
        "id" : "dd6e4584-e832-4b12-82ff-c911b3e57d28",
        "parentId" : "0e43beee-401f-421d-8996-f942368887eb",
        "authorId" : "c490e441-2b9f-41f2-8559-d47be0ea8836",
        "body" : "doh, I mentally swapped the `from` and `to` when reading the definition of `ExpectPeer`. ok, so it doesn't say \"all connections from any pod in nsX to anywhere should fail, but everything else should succeed\", it says \"all connections _to_ any pod in nsX from anywhere should fail, but everything else should succeed\". OK, got it",
        "createdAt" : "2021-07-20T12:16:02Z",
        "updatedAt" : "2021-07-20T12:16:03Z",
        "lastEditedBy" : "c490e441-2b9f-41f2-8559-d47be0ea8836",
        "tags" : [
        ]
      }
    ],
    "commit" : "266ffa85266f828eafc3fa89f70478593214e1da",
    "line" : 15,
    "diffHunk" : "@@ -1,1 +1078,1082 @@\t\t\tginkgo.By(\"Trying to connect to TCP port 81, which should be blocked by the deny-ingress policy.\")\n\t\t\treachability := NewReachability(model.AllPods(), true)\n\t\t\treachability.ExpectPeer(&Peer{}, &Peer{Namespace: nsX}, false)\n\t\t\tValidateOrFail(k8s, model, &TestCase{ToPort: 81, Protocol: v1.ProtocolTCP, Reachability: reachability})\n\t\t})"
  },
  {
    "id" : "fb4be89a-aab4-429b-b176-21e43ca36b3c",
    "prId" : 97524,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/97524#pullrequestreview-559465023",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6a2d37c3-3a7c-4cde-9862-ccddd2ff3bf7",
        "parentId" : null,
        "authorId" : "a5be0b3b-3db2-4c99-a598-55f8708db5df",
        "body" : "this is an interesting policy so glad you put it in the comments.. but if we do this... we should really explain the matrix in this block as well?  like maybe put a `*` around the \"y/b\" column on the \"x/a\" row",
        "createdAt" : "2020-12-26T16:29:08Z",
        "updatedAt" : "2021-01-05T16:47:59Z",
        "lastEditedBy" : "a5be0b3b-3db2-4c99-a598-55f8708db5df",
        "tags" : [
        ]
      },
      {
        "id" : "09972c7e-b577-46fe-9105-ae1c2df109ca",
        "parentId" : "6a2d37c3-3a7c-4cde-9862-ccddd2ff3bf7",
        "authorId" : "8e140bba-8aa7-4a19-8eaf-4e6f48d09a6a",
        "body" : "I'll add an additional comment highlighting this. ",
        "createdAt" : "2020-12-26T17:13:10Z",
        "updatedAt" : "2021-01-05T16:47:59Z",
        "lastEditedBy" : "8e140bba-8aa7-4a19-8eaf-4e6f48d09a6a",
        "tags" : [
        ]
      },
      {
        "id" : "7564c5c8-6fe4-4e5d-87bc-6463abe9da7c",
        "parentId" : "6a2d37c3-3a7c-4cde-9862-ccddd2ff3bf7",
        "authorId" : "926b3d62-1827-40fe-b6db-0be5877e79d0",
        "body" : "Here's an idea just for consideration -- feel free to not do this unless you feel like it makes this test more clear!\r\n\r\nLaying out separate \"egress\" and \"ingress\" tables, and a \"combined egress/ingress = actual connectivity\" table will help to illustrate the counterintuitive aspect of netpol behavior that this test case illuminates!\r\n\r\n",
        "createdAt" : "2020-12-27T13:33:41Z",
        "updatedAt" : "2021-01-05T16:47:59Z",
        "lastEditedBy" : "926b3d62-1827-40fe-b6db-0be5877e79d0",
        "tags" : [
        ]
      },
      {
        "id" : "da0a4f13-5c95-48a3-8754-7602c28c38f5",
        "parentId" : "6a2d37c3-3a7c-4cde-9862-ccddd2ff3bf7",
        "authorId" : "8e140bba-8aa7-4a19-8eaf-4e6f48d09a6a",
        "body" : "I added that to the comments. I hope it helps clarify the scenario.",
        "createdAt" : "2020-12-28T20:27:12Z",
        "updatedAt" : "2021-01-05T16:47:59Z",
        "lastEditedBy" : "8e140bba-8aa7-4a19-8eaf-4e6f48d09a6a",
        "tags" : [
        ]
      },
      {
        "id" : "924557dc-6f10-4fef-866d-a1a7e1b0f212",
        "parentId" : "6a2d37c3-3a7c-4cde-9862-ccddd2ff3bf7",
        "authorId" : "926b3d62-1827-40fe-b6db-0be5877e79d0",
        "body" : "üëç ",
        "createdAt" : "2020-12-29T10:13:53Z",
        "updatedAt" : "2021-01-05T16:47:59Z",
        "lastEditedBy" : "926b3d62-1827-40fe-b6db-0be5877e79d0",
        "tags" : [
        ]
      }
    ],
    "commit" : "eaad78c8fedfa7f670f72651ce1d452f57ffa37b",
    "line" : 67,
    "diffHunk" : "@@ -1,1 +687,691 @@\t\t\t// zc\t.\t.\tX\tX\t.\t.\t.\t.\t.\n\t\t\t// In the resulting truth table, connections from x/a should only be allowed to y/a. x/a to y/b should be blocked by the egress on x/a.\n\t\t\t// Expected results\n\t\t\t// \txa\txb\txc\tya\tyb\tyc\tza\tzb\tzc\n\t\t\t// xa\tX\tX\tX\t.\t*X*\tX\tX\tX\tX"
  },
  {
    "id" : "744806ab-625d-467f-bada-e6e7f0b20f4f",
    "prId" : 97524,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/97524#pullrequestreview-559292502",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f1461d48-7ddc-4e15-8e42-9eb65129358b",
        "parentId" : null,
        "authorId" : "926b3d62-1827-40fe-b6db-0be5877e79d0",
        "body" : "nbd , but possible opportunity to dedupe `allowedIngressPods` and `allowedEgressPods`",
        "createdAt" : "2020-12-27T13:19:09Z",
        "updatedAt" : "2021-01-05T16:47:59Z",
        "lastEditedBy" : "926b3d62-1827-40fe-b6db-0be5877e79d0",
        "tags" : [
        ]
      },
      {
        "id" : "d75f7c50-10a3-4a59-9e34-2bef29310e9e",
        "parentId" : "f1461d48-7ddc-4e15-8e42-9eb65129358b",
        "authorId" : "8e140bba-8aa7-4a19-8eaf-4e6f48d09a6a",
        "body" : "The allowEgressPods refers to y/a; while the allowIngressPods refers to x/a. I agree that the object itself is the same as we have a separate namespaceSelector. For readability, I would suggest to keep them as separate objects.",
        "createdAt" : "2020-12-28T20:29:44Z",
        "updatedAt" : "2021-01-05T16:47:59Z",
        "lastEditedBy" : "8e140bba-8aa7-4a19-8eaf-4e6f48d09a6a",
        "tags" : [
        ]
      }
    ],
    "commit" : "eaad78c8fedfa7f670f72651ce1d452f57ffa37b",
    "line" : 32,
    "diffHunk" : "@@ -1,1 +652,656 @@\t\t\t\t},\n\t\t\t}\n\t\t\tallowedIngressPods := &metav1.LabelSelector{\n\t\t\t\tMatchLabels: map[string]string{\n\t\t\t\t\t\"pod\": \"a\","
  },
  {
    "id" : "6b229367-fc0a-41b6-b055-de1c1d54eb44",
    "prId" : 97524,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/97524#pullrequestreview-559233363",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1eba1ca7-8151-471b-a02b-6dfb07bc1b9b",
        "parentId" : null,
        "authorId" : "926b3d62-1827-40fe-b6db-0be5877e79d0",
        "body" : "Is this test case the counterpart of https://github.com/kubernetes/kubernetes/blob/0a839c6c3b9489716e216b4fc9dd2f9c17948c16/test/e2e/network/netpol/network_policy.go#L802 ?  If so, perhaps they should be placed together and be organized/commented similarly.  (Could also be a follow-on PR, not trying to drop the kitchen sink on this PR -- I think it's great!)",
        "createdAt" : "2020-12-27T13:49:39Z",
        "updatedAt" : "2021-01-05T16:47:59Z",
        "lastEditedBy" : "926b3d62-1827-40fe-b6db-0be5877e79d0",
        "tags" : [
        ]
      },
      {
        "id" : "a8fc7644-06f5-42f5-bc75-2f41e0feecba",
        "parentId" : "1eba1ca7-8151-471b-a02b-6dfb07bc1b9b",
        "authorId" : "a5be0b3b-3db2-4c99-a598-55f8708db5df",
        "body" : "Ah yeah, like move them under the same describe, ... \r\n```\r\nginkgo.Describe(\"policies can be controlled independently\" func() {\r\n \t\tginkgo.It(\" should support denying of egress traffic on the client side (even if the server explicitly allows this traffic) [Feature:NetworkPolicy]  based on PodSelector\", func() {\r\n\r\n                  }\r\n               ginkgo.It(\"should enforce policies to check ingress and egress policies can be controlled independently based on PodSelector [Feature:NetworkPolicy]  based on PodSelector\", func() {\r\n\r\n                  }\r\n} \r\n```\r\n\r\nBecause we want to confirm that these\r\n-  works equivalently for namespaceSelectors\r\n-  works equivalently for ports\r\n\r\n@mattfenwick can you create a follow on issue summarizing ^ , ?",
        "createdAt" : "2020-12-28T14:59:47Z",
        "updatedAt" : "2021-01-05T16:47:59Z",
        "lastEditedBy" : "a5be0b3b-3db2-4c99-a598-55f8708db5df",
        "tags" : [
        ]
      },
      {
        "id" : "fafbc266-fbcd-4574-b557-efa73de20647",
        "parentId" : "1eba1ca7-8151-471b-a02b-6dfb07bc1b9b",
        "authorId" : "926b3d62-1827-40fe-b6db-0be5877e79d0",
        "body" : "just wrote it up here https://github.com/kubernetes/kubernetes/issues/97553\r\n\r\nüëç üëç ",
        "createdAt" : "2020-12-28T17:25:58Z",
        "updatedAt" : "2021-01-05T16:47:59Z",
        "lastEditedBy" : "926b3d62-1827-40fe-b6db-0be5877e79d0",
        "tags" : [
        ]
      }
    ],
    "commit" : "eaad78c8fedfa7f670f72651ce1d452f57ffa37b",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +624,628 @@\t\t})\n\n\t\tginkgo.It(\"should support denying of egress traffic on the client side (even if the server explicitly allows this traffic) [Feature:NetworkPolicy]\", func() {\n\t\t\t// x/a --> y/a and y/b\n\t\t\t// Egress allowed to y/a only. Egress to y/b should be blocked"
  },
  {
    "id" : "e513ed1c-1328-4330-9b1b-fe484a8ecca3",
    "prId" : 91592,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/91592#pullrequestreview-521150399",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "46577e4e-4b71-44e7-9ff6-6fceb451d6b1",
        "parentId" : null,
        "authorId" : "a5be0b3b-3db2-4c99-a598-55f8708db5df",
        "body" : "@mattfenwick +1 to leave this comment at the beginning.  IMO we should leave an \"why\" note like this at the top of every test In the e2e suite over time, especially services.go could use one of these ",
        "createdAt" : "2020-10-30T19:43:40Z",
        "updatedAt" : "2020-12-23T12:44:21Z",
        "lastEditedBy" : "a5be0b3b-3db2-4c99-a598-55f8708db5df",
        "tags" : [
        ]
      },
      {
        "id" : "3589b461-3118-4a46-aeba-1cb754e1749e",
        "parentId" : "46577e4e-4b71-44e7-9ff6-6fceb451d6b1",
        "authorId" : "926b3d62-1827-40fe-b6db-0be5877e79d0",
        "body" : "üëç ‚ù§Ô∏è ",
        "createdAt" : "2020-10-31T16:11:14Z",
        "updatedAt" : "2020-12-23T12:44:21Z",
        "lastEditedBy" : "926b3d62-1827-40fe-b6db-0be5877e79d0",
        "tags" : [
        ]
      }
    ],
    "commit" : "36ae8fd91a66409546f4751bfaf36f67941abc8f",
    "line" : 58,
    "diffHunk" : "@@ -1,1 +56,60 @@)\n\n/*\nYou might be wondering, why are there multiple namespaces used for each test case?\n"
  },
  {
    "id" : "b5828bf0-323a-41bb-9e7c-ebc11b65b0ed",
    "prId" : 91592,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/91592#pullrequestreview-535986890",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "282cb979-4927-4ff8-9260-3bbea234faf6",
        "parentId" : null,
        "authorId" : "a5be0b3b-3db2-4c99-a598-55f8708db5df",
        "body" : "@thockin @bowei I brought this up in sig today, this is I think the ideal way to define all these tests in the future , i.e. as json/yaml raw ...   we did it for this one case as a start but can expand to the others in a potential follow on later if folks decide its more readable ",
        "createdAt" : "2020-11-12T23:52:48Z",
        "updatedAt" : "2020-12-23T12:44:21Z",
        "lastEditedBy" : "a5be0b3b-3db2-4c99-a598-55f8708db5df",
        "tags" : [
        ]
      },
      {
        "id" : "90a99e5c-b926-426f-945a-7d551ef12cac",
        "parentId" : "282cb979-4927-4ff8-9260-3bbea234faf6",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "Thoughts:\r\n\r\nMain downside is that a mistake in JSON will not compile-fail and may not even visibly runtime fail.  That's pretty significant\r\n\r\nI might suggest a different take - there's a lot of boilerplate here.  Can you condense all of this down to *JUST* the bits that are different between each testcase.  Maybe even shoot for tabular form.\r\n\r\nE.g., can this be reduced to:\r\n\r\n```\r\n{\r\n    it: \"should support a 'default-deny-all' policy [Feature:NetworkPolicy]\",\r\n    name: \"deny-all-tcp-allow-dns\",\r\n    podSelector: select(),\r\n    egress: egress(ports(port(53, \"UDP\")), policyTypes(\"Ingress\", \"Egress\"), Peers()),\r\n    expectReachable: ...\r\n    expectUnreachable: ...\r\n}, {\r\n   // more\r\n```\r\n\r\nYou can use all sorts of clever variadic functions and funtions that return `func(*NetworkPolicySpec)` to make a \"DSL\" of sorts that retains type-safety and brevity and makes it super-easy to see what is important in this testcase.  As you loop over the table you re-assemble the policy you want.\r\n\r\nThe reductivist test",
        "createdAt" : "2020-11-20T19:57:39Z",
        "updatedAt" : "2020-12-23T12:44:21Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "81ef5b71-5088-4860-9d41-1e4ea2cb8457",
        "parentId" : "282cb979-4927-4ff8-9260-3bbea234faf6",
        "authorId" : "a5be0b3b-3db2-4c99-a598-55f8708db5df",
        "body" : "We originally had a full blown dsl, but roughly qouting @caseydavenport  ...\r\n\r\n```\r\nthere are already 2 ways to express network policies: structs and json.  adding a third way \r\ncreates cognitive load without being entiirely necessary \r\n```\r\n\r\nso we just stuck w/ go structs for this PR :).  but i think maybe we could convince folks that A DSL would be good long term.  Was thinking to do that in a follow on ? @mattfenwick has i think some ideas there.",
        "createdAt" : "2020-11-20T21:22:54Z",
        "updatedAt" : "2020-12-23T12:44:21Z",
        "lastEditedBy" : "a5be0b3b-3db2-4c99-a598-55f8708db5df",
        "tags" : [
        ]
      },
      {
        "id" : "643f0bc5-d684-47c9-92e0-0f2f19e79966",
        "parentId" : "282cb979-4927-4ff8-9260-3bbea234faf6",
        "authorId" : "d168965e-f2a1-46dc-9041-18f8ba845ebe",
        "body" : "I did push back against the original suggestion to invent a new way to express policies, but I am happy to be proven wrong!\r\n\r\nIt if were me, I'd try to avoid the extra layer of abstraction that a new network-policy-builder \"language\" would introduce. To me, that makes it harder to read / write new tests if you need to learn or modify some new NP declaration framework rather than using the raw API structs themselves, with the added benefit of it being more obvious exactly what the NP under test is.\r\n\r\nMaybe some sort of compromise? \r\n\r\n```\r\n// Returns a NP with the name / namespace, the rest unset.\r\nfunc newBasicPolicy(name, namespace string) NetworkPolicy {}\r\n\r\n```\r\n\r\nthen\r\n\r\n```\r\nnpUnderTest = newBasicPolicy(name, ns)\r\nnpUnderTest.Spec.Selector = . . .\r\nnpUnderTest.Spec.Ingress = . . .\r\nnpUnderTest.Spec.Egress = . . .\r\n```\r\n\r\nAt least then you are dealing directly with the structs, but hiding most of the boilerplate within a helper function? ",
        "createdAt" : "2020-11-20T22:29:19Z",
        "updatedAt" : "2020-12-23T12:44:21Z",
        "lastEditedBy" : "d168965e-f2a1-46dc-9041-18f8ba845ebe",
        "tags" : [
        ]
      },
      {
        "id" : "d8b7887f-2c1e-4518-85c7-9f161877f721",
        "parentId" : "282cb979-4927-4ff8-9260-3bbea234faf6",
        "authorId" : "d168965e-f2a1-46dc-9041-18f8ba845ebe",
        "body" : "@jayunit100 it sounds like I might be outnumbered, so feel free to bypass my objections :smile: \r\n\r\n> Main downside is that a mistake in JSON will not compile-fail and may not even visibly runtime fail. That's pretty significant\r\n\r\nBut I definitely agree with this. compile-time checking is something we should keep. ",
        "createdAt" : "2020-11-20T23:18:34Z",
        "updatedAt" : "2020-12-23T12:44:21Z",
        "lastEditedBy" : "d168965e-f2a1-46dc-9041-18f8ba845ebe",
        "tags" : [
        ]
      },
      {
        "id" : "7f50abe5-eeb8-4c82-8dc5-b98e4cc0a86d",
        "parentId" : "282cb979-4927-4ff8-9260-3bbea234faf6",
        "authorId" : "a5be0b3b-3db2-4c99-a598-55f8708db5df",
        "body" : "Ok... DSL is definetly cool but.. ok to move this to a follow on issue? \n\nSeems like it's an iteration on top of this,  since the KEP which we're implementing specifically concluded \"no DSL ... yet\".\n",
        "createdAt" : "2020-11-21T01:48:03Z",
        "updatedAt" : "2020-12-23T12:44:21Z",
        "lastEditedBy" : "a5be0b3b-3db2-4c99-a598-55f8708db5df",
        "tags" : [
        ]
      },
      {
        "id" : "a81c506c-8c3f-4a39-8ecb-9dfb617e9ab7",
        "parentId" : "282cb979-4927-4ff8-9260-3bbea234faf6",
        "authorId" : "a5be0b3b-3db2-4c99-a598-55f8708db5df",
        "body" : "btw casey what were doing in this PR is (almost) exactly the comprimise you suggest above :), after all it was your idea we stole here,  to use raw structs... so that should make you smile a little inside :) \r\n\r\n```\r\n        policy := GetAllowIngressByPod(\"allow-client-a-via-pod-selector\", map[string]string{\"pod\": \"a\"}, allowedPodLabels)\r\n\tpolicy.Spec.Egress = ... \r\n\tpolicy.Spec.PolicyTypes = []networkingv1.PolicyType{networkingv1.PolicyTypeEgress, networkingv1.PolicyTypeIngress}\r\n        nsX, _, _, model, k8s := getK8SModel(f)\r\n\t CreatePolicy(k8s, policy, nsX)\r\n\r\n\treachabilityPort80 := NewReachability(model.AllPods(), true)\r\n\treachabilityPort80.ExpectAllIngress(NewPodString(nsX, \"a\"), false)\r\n\treachabilityPort80.Expect(NewPodString(nsX, \"b\"), NewPodString(nsX, \"a\"), true)\r\n\tValidateOrFail(k8s, model, &TestCase{FromPort: 81, ToPort: 80, Protocol: v1.ProtocolTCP, Reachability: reachabilityPort80})\r\n``` \r\n\r\n:) ",
        "createdAt" : "2020-11-21T18:36:15Z",
        "updatedAt" : "2020-12-23T12:44:21Z",
        "lastEditedBy" : "a5be0b3b-3db2-4c99-a598-55f8708db5df",
        "tags" : [
        ]
      }
    ],
    "commit" : "36ae8fd91a66409546f4751bfaf36f67941abc8f",
    "line" : 161,
    "diffHunk" : "@@ -1,1 +159,163 @@\t\t})\n\n\t\tginkgo.It(\"should support a 'default-deny-all' policy [Feature:NetworkPolicy]\", func() {\n\t\t\tnp := &networkingv1.NetworkPolicy{}\n\t\t\tpolicy := `"
  }
]
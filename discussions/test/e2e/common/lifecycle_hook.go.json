[
  {
    "id" : "d9c43bb5-c7a0-4e7b-bae7-5ce48e8d9b2d",
    "prId" : 75245,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/75245#pullrequestreview-228515795",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a24781cd-f8d5-4c67-ac5a-f73d95612fe7",
        "parentId" : null,
        "authorId" : "26bd3fa6-ac8d-4cb0-b746-a30dc1dc2931",
        "body" : "I was hoping we can have a more consistent way to handle IPv6 cases like this --- just a bit worried to see subtle logic scattered around.\r\n\r\nThough I guess this is okay for now?",
        "createdAt" : "2019-04-18T20:48:43Z",
        "updatedAt" : "2019-04-18T20:49:11Z",
        "lastEditedBy" : "26bd3fa6-ac8d-4cb0-b746-a30dc1dc2931",
        "tags" : [
        ]
      },
      {
        "id" : "1a3b973e-9079-430b-b6ed-04c4d58d8d7a",
        "parentId" : "a24781cd-f8d5-4c67-ac5a-f73d95612fe7",
        "authorId" : "203dfb85-d185-4057-88b3-a1b4f09fd1fd",
        "body" : "@MrHohn I can add a function to build correct IPv6 urls so it can be reused \r\n\r\n```\r\n// FormatLiteralIPURL Returns a valid URL for literal IP addresses\r\n// https://tools.ietf.org/html/rfc2732\r\nfunc FormatLiteralIPURL (ip string) string {\r\n\t\t\tif strings.Contains(ip, \":\") {\r\n\t\t\t\treturn fmt.Sprintf(\"[%s]\", ip)\r\n\t\t\t}\r\n                        return ip\r\n}\r\n``` \r\n\r\njust let me know what will be the best place to add it",
        "createdAt" : "2019-04-18T21:08:58Z",
        "updatedAt" : "2019-04-18T21:08:59Z",
        "lastEditedBy" : "203dfb85-d185-4057-88b3-a1b4f09fd1fd",
        "tags" : [
        ]
      },
      {
        "id" : "b9ab5807-b6c2-47f0-8baf-7125c9ac7049",
        "parentId" : "a24781cd-f8d5-4c67-ac5a-f73d95612fe7",
        "authorId" : "26bd3fa6-ac8d-4cb0-b746-a30dc1dc2931",
        "body" : "Looks good, probably add to https://github.com/kubernetes/kubernetes/blob/master/test/e2e/framework/networking_utils.go for now. We can find a more common place outside of the test folder later if needed.",
        "createdAt" : "2019-04-18T21:30:32Z",
        "updatedAt" : "2019-04-18T21:30:33Z",
        "lastEditedBy" : "26bd3fa6-ac8d-4cb0-b746-a30dc1dc2931",
        "tags" : [
        ]
      }
    ],
    "commit" : "527d2aa2bd75fc4b7add814d124de03df7cb0eef",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +41,45 @@\t)\n\tContext(\"when create a pod with lifecycle hook\", func() {\n\t\tvar targetIP, targetURL string\n\t\tpodHandleHookRequest := &v1.Pod{\n\t\t\tObjectMeta: metav1.ObjectMeta{"
  },
  {
    "id" : "d885889d-405a-4e33-aacb-23c6d601041e",
    "prId" : 67100,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/67100#pullrequestreview-146931965",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "998f2db2-79ef-4a7d-acff-b477f97859a9",
        "parentId" : null,
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "Success is verified by looking for the GET in the logs of the serving pod/container?\r\n\r\nWhat image/command is running in the pod/container with the pre-start hook? We need to ensure the primary container isn't racing with the hook.\r\n\r\nIs the Netexec image built with multi-arch support?\r\n\r\nNote: Some test(s) needs to explicitly validate that pod networking works as intended. Something like this could potentially do that if we constrained the 2 pods to run on different nodes and verified that their IPs weren't the same as the node IPs.\r\n",
        "createdAt" : "2018-08-13T23:26:26Z",
        "updatedAt" : "2018-08-13T23:26:26Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "02e14a18-88ba-4ecf-ac98-62743724c74d",
        "parentId" : "998f2db2-79ef-4a7d-acff-b477f97859a9",
        "authorId" : "bd5b5c8f-ef3a-4fe8-b461-469914a100ac",
        "body" : "a) There are 2 pods present in the scenario:\r\n1) serving pod\r\n- [image](https://console.cloud.google.com/gcr/images/kubernetes-e2e-test-images/GLOBAL/netexec@sha256:738c96036e6e0a90fdae3499c8c9ee9a7d75c0dae70cd22440f69d027c6686d7/details?tab=info) has references to different archs (amd64 / arm / arm64 / ppc64le / s390x)\r\n2) invoker pod\r\n- has the post-start-hook, that will invoke the uri exposed on the \"serving pod\".\r\n- [image](https://console.cloud.google.com/gcr/images/kubernetes-e2e-test-images/GLOBAL/hostexec@sha256:90dfe59da029f9e536385037bc64e86cd3d6e55bae613ddbe69e554d79b0639d/details?tab=info) has references to different archs (amd64 / arm64/ ppc64le)\r\n\r\nb) _Success is verified by looking for the GET in the logs of the serving pod/container?_\r\n its checking that the log in the invoker pod (that has the hook) contains the consequence of curl invocation.\r\n\r\nc) _What image/command is running in the pod/container with the pre-start hook? We need to ensure the primary container isn't racing with the hook._\r\n-  the command run is curl http://\" + targetIP + \":8080/echo?msg=poststart\r\n\r\nd) _Note_\r\nHow would you like us to proceed regarding networking?\r\n",
        "createdAt" : "2018-08-14T20:52:32Z",
        "updatedAt" : "2018-08-16T14:31:41Z",
        "lastEditedBy" : "bd5b5c8f-ef3a-4fe8-b461-469914a100ac",
        "tags" : [
        ]
      },
      {
        "id" : "ba1ba1b2-0bd0-41d3-81d3-6db2307634c9",
        "parentId" : "998f2db2-79ef-4a7d-acff-b477f97859a9",
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "Thanks. I see that the image waits forever:\r\nhttps://github.com/kubernetes/kubernetes/blob/master/test/images/hostexec/Dockerfile\r\n\r\nNetworking doesn't need to be addressed by these tests. Let's address that in tests focused on that issue.",
        "createdAt" : "2018-08-16T16:51:49Z",
        "updatedAt" : "2018-08-16T16:51:49Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      }
    ],
    "commit" : "95a6dc4f33f10af3d90e1d44f1291c6aba069d4d",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +90,94 @@\t\t\tDescription: When a post start handler is specified in the container lifecycle using a ‘Exec’ action, then the handler MUST be invoked after the start of the container. A server pod is created that will serve http requests, create a second pod with a container lifecycle specifying a post start that invokes the server pod using ExecAction to validate that the post start is executed.\n\t\t*/\n\t\tframework.ConformanceIt(\"should execute poststart exec hook properly [NodeConformance]\", func() {\n\t\t\tlifecycle := &v1.Lifecycle{\n\t\t\t\tPostStart: &v1.Handler{"
  }
]
[
  {
    "id" : "f033b806-4152-42b4-81ca-fcd92fb49e6c",
    "prId" : 9418,
    "prUrl" : "https://github.com/apache/kafka/pull/9418#pullrequestreview-514207123",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6ee63066-8d05-4ba3-b423-b1ab6446e5bc",
        "parentId" : null,
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "Is this going to be used for non-testing code in the future? If it is only going to be for metrics purposes maybe we can allow it to be non thread-safe just to not blocking on other critical paths.",
        "createdAt" : "2020-10-21T00:49:26Z",
        "updatedAt" : "2020-10-27T03:04:10Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "8ecec46a-4194-4608-a693-6888638fd93a",
        "parentId" : "6ee63066-8d05-4ba3-b423-b1ab6446e5bc",
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "I am not sure. We don't have a metric yet, so I thought we might as well start with a thread-safe implementation. If we add a metric in the future, we can probably use an `AtomicInteger` or something and eliminate the locking.",
        "createdAt" : "2020-10-21T21:40:59Z",
        "updatedAt" : "2020-10-27T03:04:10Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      }
    ],
    "commit" : "fac5c0a9507f9f40f99dac017242d12500a97d5d",
    "line" : 278,
    "diffHunk" : "@@ -1,1 +276,280 @@     * written to (if it exists).\n     */\n    public int count() {\n        appendLock.lock();\n        try {"
  },
  {
    "id" : "67005db1-7f46-421d-9921-ce107ae9c1f4",
    "prId" : 9418,
    "prUrl" : "https://github.com/apache/kafka/pull/9418#pullrequestreview-516114788",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a73e9441-1f87-4400-8270-58d9de304ae9",
        "parentId" : null,
        "authorId" : "4a7c311c-0954-4671-a0d2-266cb67437ad",
        "body" : "What are you trying to protect with this check? For example, the signature could be `public long append(List<T> records)` with the accumulator writing the correct epoch.\r\n\r\nIn https://github.com/apache/kafka/pull/9482 you implemented `handleClaim` in to only fire when the `Listener`'s \"acknowledged\" offset + 1 is >= to the leader's epoch start offset.\r\n\r\nThinking through the code's behaviour, I see this check catching the case the the raft replica lost leadership and won leadership before the `Listener` was able to asynchronously process `handleResign` and `handleClaim`.",
        "createdAt" : "2020-10-23T19:22:25Z",
        "updatedAt" : "2020-10-27T03:04:10Z",
        "lastEditedBy" : "4a7c311c-0954-4671-a0d2-266cb67437ad",
        "tags" : [
        ]
      },
      {
        "id" : "98a9ec7f-5c41-49e1-831d-f71a0222bc06",
        "parentId" : "a73e9441-1f87-4400-8270-58d9de304ae9",
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "Right. It is important to ensure that the state machine has observed the latest leader epoch. Otherwise there may be committed data inflight which the state machine has yet to see.",
        "createdAt" : "2020-10-23T23:50:34Z",
        "updatedAt" : "2020-10-27T03:04:10Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      }
    ],
    "commit" : "fac5c0a9507f9f40f99dac017242d12500a97d5d",
    "line" : 99,
    "diffHunk" : "@@ -1,1 +97,101 @@            // has not gotten the notification about the latest epoch change.\n            // In this case, ignore the append and return a large offset value\n            // which will never be committed.\n            return Long.MAX_VALUE;\n        }"
  }
]
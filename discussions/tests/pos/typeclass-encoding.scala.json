[
  {
    "id" : "5a5e8bb5-fb43-44d7-8c24-abb004cd38f0",
    "prId" : 4102,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/4102#pullrequestreview-102952400",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c0533cda-7b82-4473-94d6-be9468716a63",
        "parentId" : null,
        "authorId" : "348fab8e-49e2-442e-884d-850c7f41fdde",
        "body" : "why backticks around `add`?",
        "createdAt" : "2018-03-11T21:17:33Z",
        "updatedAt" : "2018-03-11T21:17:34Z",
        "lastEditedBy" : "348fab8e-49e2-442e-884d-850c7f41fdde",
        "tags" : [
        ]
      },
      {
        "id" : "2725be22-d374-4771-9726-0681cf9da13b",
        "parentId" : "c0533cda-7b82-4473-94d6-be9468716a63",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "I am experimenting with the idiom to always require them around alphanumeric infix operators.  Trying to evaluate how natural that feels after some usage.",
        "createdAt" : "2018-03-12T08:28:30Z",
        "updatedAt" : "2018-03-12T08:28:30Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "e6a403a4f5f132cf4880603817392d1160ca5dc4",
    "line" : 88,
    "diffHunk" : "@@ -1,1 +86,90 @@\n  def sum[T](xs: List[T])(implicit $ev: Implementation[T] { type Implemented = Monoid } ) = {\n    (instance[T, Monoid].unit /: xs)((x, y) => inject(x) `add` y)\n    (instance[T, Monoid].unit /: xs)((x, y) => x `add` y)  // fails in scalac and previous dotc.\n  }"
  },
  {
    "id" : "00a3e1cd-ccab-476c-9973-5699d2db49d7",
    "prId" : 4102,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/4102#pullrequestreview-102952381",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5b125874-5c9c-4ce9-af42-2d2d85a0e17e",
        "parentId" : null,
        "authorId" : "348fab8e-49e2-442e-884d-850c7f41fdde",
        "body" : "why not swap `ev1` and `ev2` and make `ev1` (now second argument) have type `Implementation[From] { type Implemented = To } & ev2.StaticPart[From]`? Let's ignore inference issues for a second.*\r\n\r\nIt seems all that could be replaced by replacing, e.g., `MonoidStatic[T] with Implementation[T]` with\r\n```scala\r\nclass MonoidDict[T] extends Implementation[T] {\r\n  def unit: T\r\n   def inject($this: T) = new Monoid {\r\n      type This = T\r\n      def add(that: T): T\r\n   }\r\n}\r\n```\r\n\r\nIn fact, at that point it's clearer that MonoidDict instances encode differently the same info as\r\n\r\n```scala\r\ntrait MonoidDict[T] extends Implementation[T] {\r\n  def unit: T\r\n  def add($this: T, that: T): T\r\n}\r\n```\r\n\r\n*If inference has problems with that, maybe we want to get curried implicits in first, but I'd first try simplifying the encoding further.",
        "createdAt" : "2018-03-11T21:36:47Z",
        "updatedAt" : "2018-03-11T22:14:02Z",
        "lastEditedBy" : "348fab8e-49e2-442e-884d-850c7f41fdde",
        "tags" : [
        ]
      },
      {
        "id" : "8891d599-8e68-43ce-9032-605b8fca1666",
        "parentId" : "5b125874-5c9c-4ce9-af42-2d2d85a0e17e",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "This is by no means the last word in encodings. It's a first attempt to see what it would take. We should experiment with lots of other schemes.",
        "createdAt" : "2018-03-12T08:28:26Z",
        "updatedAt" : "2018-03-12T08:28:26Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "e6a403a4f5f132cf4880603817392d1160ca5dc4",
    "line" : 43,
    "diffHunk" : "@@ -1,1 +41,45 @@      implicit ev1: Implementation[From] { type Implemented = To },\n      ev2: CompanionOf[To]): Implementation[From] { type Implemented = To } & ev2.StaticPart[From] =\n    ev1.asInstanceOf  // can we avoid the cast?\n\n  implicit def inject[From](x: From)("
  }
]
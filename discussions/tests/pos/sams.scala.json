[
  {
    "id" : "130e8215-6cec-4180-99cb-c0980acb45bb",
    "prId" : 509,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "927e3b8d-048c-4cce-a68c-dc3174c6d4c8",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Where does this restriction comes from? Currently Dotty uses `LambdaMetaFactory` for this case and it works fine at runtime, also `Exception` is a subclass of `Object` so I don't understand what a \"non-object class\" is.\n",
        "createdAt" : "2015-04-30T22:41:44Z",
        "updatedAt" : "2015-05-02T17:08:08Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "40e842bd-0baa-4fd0-8868-9a18d80130cb",
        "parentId" : "927e3b8d-048c-4cce-a68c-dc3174c6d4c8",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "\"non-object class\": class other than java.lang.Object. \n\nThe problem is in the runtime types. If we write\n\n```\nval lambda = (x => e): C\n```\n\nwe expect that `lambda.isInstanveOf[C]`. \n",
        "createdAt" : "2015-05-01T07:12:27Z",
        "updatedAt" : "2015-05-02T17:08:08Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "de02db81-e320-4c05-91c4-0e69ce034671",
        "parentId" : "927e3b8d-048c-4cce-a68c-dc3174c6d4c8",
        "authorId" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "body" : "> it works fine at runtime\n\nIt does not. LambdaMetaFactory explicitly checks that `invokedType` returns an interface.\nThis is both spec'd and implemented.\n",
        "createdAt" : "2015-05-01T11:20:40Z",
        "updatedAt" : "2015-05-02T17:08:08Z",
        "lastEditedBy" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "tags" : [
        ]
      },
      {
        "id" : "91d64db7-0a44-46ae-8825-2c792a8b8b44",
        "parentId" : "927e3b8d-048c-4cce-a68c-dc3174c6d4c8",
        "authorId" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "body" : "```\nobject O {\n  abstract class D {\n    def foo(a: Int): Int\n  }\n\n  def main(args: Array[String]): Unit = {\n    val a: D = x => x\n    a.foo(1)\n  }\n}\n```\n\n```\nException in thread \"main\" java.lang.BootstrapMethodError: call site initialization exception\n    at java.lang.invoke.CallSite.makeSite(CallSite.java:328)\n    at java.lang.invoke.MethodHandleNatives.linkCallSite(MethodHandleNatives.java:296)\n    at O$.main(CLM.scala:5)\n    at O.main(CLM.scala)\nCaused by: java.lang.invoke.LambdaConversionException: Functional interface O$$D is not an interface\n    at java.lang.invoke.AbstractValidatingLambdaMetafactory.<init>(AbstractValidatingLambdaMetafactory.java:145)\n    at java.lang.invoke.InnerClassLambdaMetafactory.<init>(InnerClassLambdaMetafactory.java:155)\n    at java.lang.invoke.LambdaMetafactory.metafactory(LambdaMetafactory.java:299)\n    at java.lang.invoke.CallSite.makeSite(CallSite.java:289)\n    ... 3 more\n```\n",
        "createdAt" : "2015-05-01T11:25:12Z",
        "updatedAt" : "2015-05-02T17:08:08Z",
        "lastEditedBy" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "tags" : [
        ]
      },
      {
        "id" : "131882b3-668d-4cd4-b30f-03da86916f56",
        "parentId" : "927e3b8d-048c-4cce-a68c-dc3174c6d4c8",
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "> we expect that lambda.isInstanceOf[C]. \n\nThis is the case in this example:\n\n``` scala\nobject Foo {\n  trait V extends Exception { def foo(x: Int): Int }\n\n  val v: V = (x: Int) => 2\n\n  def main(args: Array[String]): Unit = {\n    println(v.isInstanceOf[V])\n  }\n}\n```\n\nIn master right now it will print \"true\". This makes sense: for each trait, Dotty will generate an interface, and `LambdaMetaFactory` will return an instance of that interface.\n\n@DarkDimius : Your example is something else entirely: abstract class should not be SAM types, only traits can be SAM types.\n",
        "createdAt" : "2015-05-02T21:38:16Z",
        "updatedAt" : "2015-05-02T21:38:16Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "23f8ff0e-e4e5-483f-a8f4-e8612cff736b",
        "parentId" : "927e3b8d-048c-4cce-a68c-dc3174c6d4c8",
        "authorId" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "body" : "@smarter, yes, this is something else entirely, and this is what is tested here.\nQuoting Martin:\n\n> \"non-object class\": class other than java.lang.Object. \n\nIn this example, `trait V` extends `class Exception`. So it could not be implemented by a JVM SAM.\n",
        "createdAt" : "2015-05-02T21:41:58Z",
        "updatedAt" : "2015-05-02T21:41:58Z",
        "lastEditedBy" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "tags" : [
        ]
      },
      {
        "id" : "1070e105-7c0e-4aa6-b488-64a8752ff7f2",
        "parentId" : "927e3b8d-048c-4cce-a68c-dc3174c6d4c8",
        "authorId" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "body" : "If you want your test to fail, try to test if `v.isInstanceOf[Exception]`.\n",
        "createdAt" : "2015-05-02T21:42:45Z",
        "updatedAt" : "2015-05-02T21:42:45Z",
        "lastEditedBy" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "tags" : [
        ]
      },
      {
        "id" : "88c04b0b-390f-47b8-a809-1e781d99594f",
        "parentId" : "927e3b8d-048c-4cce-a68c-dc3174c6d4c8",
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Ah, I get it now, thanks.\n",
        "createdAt" : "2015-05-02T21:47:41Z",
        "updatedAt" : "2015-05-02T21:47:41Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      }
    ],
    "commit" : "349c436348407b0e862e3feb65c959275549d86b",
    "line" : 20,
    "diffHunk" : "@@ -1,1 +18,22 @@  trait V extends Exception { def foo(x: Int): Int }\n\n  val v: V = (x: Int) => 2   // needs to be an anonymous class because the trait extends a non-object class\n\n  trait Y extends X {"
  }
]
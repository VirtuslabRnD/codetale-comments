[
  {
    "id" : "1223035c-1d8a-4d1d-9031-510341936d4b",
    "prId" : 7386,
    "prUrl" : "https://github.com/apache/kafka/pull/7386#pullrequestreview-296493811",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3f200fd1-9f97-4cf3-92f9-447dee0aa348",
        "parentId" : null,
        "authorId" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "body" : "Why change here?",
        "createdAt" : "2019-10-02T18:40:36Z",
        "updatedAt" : "2019-10-06T23:53:51Z",
        "lastEditedBy" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "tags" : [
        ]
      },
      {
        "id" : "7526c419-1d0f-48e1-ab93-fd2f36388a55",
        "parentId" : "3f200fd1-9f97-4cf3-92f9-447dee0aa348",
        "authorId" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "body" : "The processor used here keeps track of the `numRecordsProcessed` and outputs this whenever it's a multiple of 100. It also resets in `init`, so the eos test watches for a rebalance and then looks for the `numRecordsProcessed` to hit 500 again, knowing it should have started over again from 0.\r\nBut the whole point of cooperative rebalancing is we may not have needed to revoke/reinitialize this task during a rebalance, and the counter may be reset after a rebalance. ",
        "createdAt" : "2019-10-02T20:07:22Z",
        "updatedAt" : "2019-10-06T23:53:51Z",
        "lastEditedBy" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "tags" : [
        ]
      }
    ],
    "commit" : "f047cd9bea88a4ffc88ce2b4f82946d52202c539",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +160,164 @@    def wait_for_startup(self, monitor, processor):\n        self.wait_for(monitor, processor, \"StateChange: REBALANCING -> RUNNING\")\n        self.wait_for(monitor, processor, \"processed [0-9]* records from topic\")\n\n    def wait_for(self, monitor, processor, output):"
  },
  {
    "id" : "80ab6307-0aaa-4103-bd26-26d3d39e1035",
    "prId" : 7693,
    "prUrl" : "https://github.com/apache/kafka/pull/7693#pullrequestreview-319801371",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0d8b0bdf-f6aa-4bdf-838d-73cd7ad97c95",
        "parentId" : null,
        "authorId" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "body" : "We can move the unsetting of the clean-up flag after the first start of `processor1` to ensure that the node is cleaned up during the start (see [code line in ducktape](https://github.com/confluentinc/ducktape/blob/f540a740222ca6eaf703d7315228e67b65db3aa9/ducktape/services/service.py#L228)).",
        "createdAt" : "2019-11-20T12:25:44Z",
        "updatedAt" : "2019-11-20T12:55:01Z",
        "lastEditedBy" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "tags" : [
        ]
      }
    ],
    "commit" : "c3009ac3aa1be0e150354a37de61804b6b4491dd",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +60,64 @@\n        self.add_streams(processor1)\n        processor1.clean_node_enabled = False\n        self.add_streams2(processor1, processor2)\n        self.add_streams3(processor1, processor2, processor3)"
  },
  {
    "id" : "300f05da-5f02-4b32-a3cc-0800240776b3",
    "prId" : 7693,
    "prUrl" : "https://github.com/apache/kafka/pull/7693#pullrequestreview-319801371",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ee8515b0-c935-4c84-8f07-ff8be0d39520",
        "parentId" : null,
        "authorId" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "body" : "We can set the clean-up flag here again to ensure that the node is cleaned when the test is torn down.",
        "createdAt" : "2019-11-20T12:26:54Z",
        "updatedAt" : "2019-11-20T12:55:02Z",
        "lastEditedBy" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "tags" : [
        ]
      }
    ],
    "commit" : "c3009ac3aa1be0e150354a37de61804b6b4491dd",
    "line" : 15,
    "diffHunk" : "@@ -1,1 +68,72 @@        self.stop_streams2(processor1, processor3)\n        self.stop_streams(processor1)\n        processor1.clean_node_enabled = True\n\n        self.driver.stop()"
  },
  {
    "id" : "9abcdd13-aa10-4990-86a1-4cbf7bdc2748",
    "prId" : 7693,
    "prUrl" : "https://github.com/apache/kafka/pull/7693#pullrequestreview-319801371",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8470f058-218c-47b3-ac03-c144c7919f54",
        "parentId" : null,
        "authorId" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "body" : "We do similar here because that was actually the issue in the system tests. Tests `test_failure_and_recovery()` and  `test_failure_and_recovery_complex()` were executed before `test_rebalance_simple` and `test_rebalance_complex` and they were scheduled on the same worker node, respectively. Thus, the latter tests read the local state of the former tests instead of starting with an empty state. ",
        "createdAt" : "2019-11-20T12:32:12Z",
        "updatedAt" : "2019-11-20T12:55:02Z",
        "lastEditedBy" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "tags" : [
        ]
      }
    ],
    "commit" : "c3009ac3aa1be0e150354a37de61804b6b4491dd",
    "line" : 35,
    "diffHunk" : "@@ -1,1 +111,115 @@        self.stop_streams(processor1)\n        processor1.clean_node_enabled = True\n\n        self.driver.stop()\n"
  }
]
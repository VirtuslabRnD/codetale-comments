[
  {
    "id" : "1bcdeb54-820e-49f4-b782-0454710b11c3",
    "prId" : 36615,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/36615#pullrequestreview-354864994",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5d7b0ee4-f357-4468-9159-e4441c81c831",
        "parentId" : null,
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "why does this test file end with \"_typeOnly2\"?",
        "createdAt" : "2020-02-06T23:23:54Z",
        "updatedAt" : "2020-02-10T21:46:08Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      },
      {
        "id" : "721d085c-7964-4e6a-a796-91a3e274a4aa",
        "parentId" : "5d7b0ee4-f357-4468-9159-e4441c81c831",
        "authorId" : "7b7aae27-4774-41a7-bce2-94c871708547",
        "body" : "Since there is `@importsNotUsedAsValues: error`, when we see `const a: A`, we register the import fix as type-only. Then, we get to `new A()`, and we register an import fix as _not_ type-only. The point of this test is to ensure that when there is a conflict, we _don’t_ write the final import clause as type-only. It’s the natural next test case after `importNameCodeFix_typeOnly.ts` verifies the positive, though I see how the name might look confusing taken alone.",
        "createdAt" : "2020-02-07T00:26:57Z",
        "updatedAt" : "2020-02-10T21:46:09Z",
        "lastEditedBy" : "7b7aae27-4774-41a7-bce2-94c871708547",
        "tags" : [
        ]
      }
    ],
    "commit" : "7de6c0346270caf46607cc5978e197651bca7b5a",
    "line" : 16,
    "diffHunk" : "@@ -1,1 +14,18 @@  fixId: \"fixMissingImport\",\n  newFileContent:\n`import { A } from \"./types\";\n\nconst a: A = new A();`"
  }
]
[
  {
    "id" : "07f0ff40-f3be-4dbe-b366-6153c763c98a",
    "prId" : 28490,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/28490#pullrequestreview-174135705",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1df3cee0-7bd0-411b-9de9-fa6835597433",
        "parentId" : null,
        "authorId" : "cb16561c-58c1-4f0a-a738-613be01155c9",
        "body" : "Interesting. This is not circular generic type though so this shouldn't run into the circularity print in the first place. So to me it feels like we are missing something else that we can account in ID (eg. instantiations of the type as well?)",
        "createdAt" : "2018-11-12T22:33:12Z",
        "updatedAt" : "2018-11-12T22:33:12Z",
        "lastEditedBy" : "cb16561c-58c1-4f0a-a738-613be01155c9",
        "tags" : [
        ]
      },
      {
        "id" : "d3ecb287-0169-41dc-bade-73d9090fc2cb",
        "parentId" : "1df3cee0-7bd0-411b-9de9-fa6835597433",
        "authorId" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "body" : "Right, so we track how many times we visit the same symbol, since we don't know if the symbol is generative or not (ie, does each member produce a type whose member is a new instantiation of the type) and we have tests to that effect. In this case, we do produce a type with a member of the same symbol as the overall type, but it's finite - just 2 levels deep. The explicit `depth` check helps distinguish these cases (rather than assuming that all recursive instantiations could be circular and printing as `any`).",
        "createdAt" : "2018-11-12T22:44:00Z",
        "updatedAt" : "2018-11-12T22:49:25Z",
        "lastEditedBy" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "tags" : [
        ]
      },
      {
        "id" : "4e176f98-bc01-49a0-9dea-a768fb7c5fa2",
        "parentId" : "1df3cee0-7bd0-411b-9de9-fa6835597433",
        "authorId" : "cb16561c-58c1-4f0a-a738-613be01155c9",
        "body" : "I understand why you are tracking depth but what i meant was why not add (symbol.links.instatiations.typeId) to determine if we are recuring into symbol + type combination. Thus we would still not have to print something like `z : { y2: { y2: { y2: { y2: { y2: { y2: { y2: { y2: { y2: { y2: { y2: any; }; }; }; }; }; }; }; }; }; }; }`",
        "createdAt" : "2018-11-12T23:18:12Z",
        "updatedAt" : "2018-11-12T23:18:12Z",
        "lastEditedBy" : "cb16561c-58c1-4f0a-a738-613be01155c9",
        "tags" : [
        ]
      },
      {
        "id" : "5852eec7-188a-4db3-a1c5-24ac512dc443",
        "parentId" : "1df3cee0-7bd0-411b-9de9-fa6835597433",
        "authorId" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "body" : "Every `y2` in that type is within a differently id'd object literal type backed by the same (well, 1 of 2, the test is mutual recursion) symbol. No `symbol + type` id pair will ever repeat because it generates new `type` ids infinitely as it recurs. Which is why we just have to track symbol depth, similarly to how we do in instantiation itself.",
        "createdAt" : "2018-11-12T23:22:06Z",
        "updatedAt" : "2018-11-12T23:40:19Z",
        "lastEditedBy" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "tags" : [
        ]
      }
    ],
    "commit" : "25a691ae1671369cc732434fe95ca78ac89639ba",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +5,9 @@////declare const b: boolean;\n////const obj/*1*/ = schema(b);\n////const actualTypeOfNested/*2*/ = schema(obj);\n\nverify.quickInfos({"
  }
]
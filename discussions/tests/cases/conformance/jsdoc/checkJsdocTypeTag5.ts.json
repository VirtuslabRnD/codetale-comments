[
  {
    "id" : "102c8def-d191-4099-8738-40cb2d1dc10a",
    "prId" : 25580,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/25580#pullrequestreview-136431003",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d6c85b88-dd7a-474e-b36e-236d1ea7e275",
        "parentId" : null,
        "authorId" : "39105c25-586e-496a-9515-4fce35443a7c",
        "body" : "The error here doesn't say anything about overloads through. (`error TS2322: Type '1 | 2' is not assignable to type '2 | 3'.`) The inferred return type of the function `1 | 2` is used, but it really shouldn't if there was an explicit type annotation. If the function returned `any`, there would be silent failure here, even though it had an explicit type annotation.",
        "createdAt" : "2018-07-11T17:26:15Z",
        "updatedAt" : "2018-07-12T16:12:45Z",
        "lastEditedBy" : "39105c25-586e-496a-9515-4fce35443a7c",
        "tags" : [
        ]
      },
      {
        "id" : "80351a97-8bca-4b13-90da-8cc8a96fb8f5",
        "parentId" : "d6c85b88-dd7a-474e-b36e-236d1ea7e275",
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "You're right, it's only an error because we go back to ignoring the type annotation. The correct thing is to treat a type annotation with multiple signatures as an overload set and use the normal typescript rules for checking that the implementation signature is assignable to the overload set. \r\n\r\nBut the JS implementation isn't typed, so that check doesn't really make sense. Basically, I left it the way it was because I couldn't think of any useful checking.",
        "createdAt" : "2018-07-11T20:42:36Z",
        "updatedAt" : "2018-07-12T16:12:45Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      },
      {
        "id" : "2f1414ab-5328-463a-9d97-7c8b50b3c6d0",
        "parentId" : "d6c85b88-dd7a-474e-b36e-236d1ea7e275",
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "After discussing this in person, here's what we decided\r\n\r\n1. `/** @type {number} */` should error. It doesn't today, but I think it's clearly wrong *enough* to deserve an error.\r\n2. `/** @type {Gioconda} */` should give `monaLisa` an overload type, and the function parameters and return type should be checked according to the typescript overload rules. This will usually succeed since the parameters will be `any`, and the return type will therefore usually be `any`. But it will give the desired overload type to callers of the function, which is why somebody would write this type in the first place.\r\n3. (2) is not just a simple fix so I will leave the current silent-fallback behaviour in this PR and open an issue to track it.",
        "createdAt" : "2018-07-11T21:11:53Z",
        "updatedAt" : "2018-07-12T16:12:45Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      },
      {
        "id" : "07801ccb-18f9-4db7-886d-d5014f1317cc",
        "parentId" : "d6c85b88-dd7a-474e-b36e-236d1ea7e275",
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "Opened #25590 to track (2).",
        "createdAt" : "2018-07-11T21:34:30Z",
        "updatedAt" : "2018-07-12T16:12:45Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      }
    ],
    "commit" : "81bc176b61783a0278ea215b73d555c60597c2fa",
    "line" : 23,
    "diffHunk" : "@@ -1,1 +36,40 @@\n/** @type {2 | 3} - overloads are not supported, so there will be an error */\nvar twothree = monaLisa(false);"
  }
]
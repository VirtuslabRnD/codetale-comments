[
  {
    "id" : "29672bf0-179f-47f6-acf7-661c0354dec5",
    "prId" : 31687,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/31687#pullrequestreview-244608623",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b3324169-b886-4be2-9125-3ec924532483",
        "parentId" : null,
        "authorId" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "body" : "Why is this `unknown` and not an error? (Is it just because inference fails and \"a thing with an inferrable index\" is assignable to a `{[x: number]: unknown}`?) I'd think that yeah, `E2` has an inferrable index type, sure, but we know that it has no numbers in it at all. But, from the stance that the number index signature (were it present in the type) would need to be assignable to the string index, this'd need to be `E2`.",
        "createdAt" : "2019-05-31T19:34:30Z",
        "updatedAt" : "2019-05-31T19:34:31Z",
        "lastEditedBy" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "tags" : [
        ]
      },
      {
        "id" : "417f8f38-4708-4d6d-b500-8a700597d80c",
        "parentId" : "b3324169-b886-4be2-9125-3ec924532483",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "Because we infer nothing for `T` in the call to `getNumberIndexValue`. Keep in mind we're not doing an assignment here, we're just doing inference.",
        "createdAt" : "2019-05-31T20:26:38Z",
        "updatedAt" : "2019-05-31T20:26:39Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "dba30c81-22a7-480e-838a-5a196143cad0",
        "parentId" : "b3324169-b886-4be2-9125-3ec924532483",
        "authorId" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "body" : "Well, we are doing an assignment - we're saying that a `{[x: string]: E2}` is assignable to a `{[x: number]: unknown}`. I guess the output type here just irks me a tad - it could only possibly be an `E2` or `keyof typeof E2`, rather than an `unknown`.\r\n\r\nLike, if I write `enum StrNum { Zero = \"0\", One = \"1\" }`, indexing by `0` or `1` is gunna get me `Zero` or `One`, likewise if I write `enum NumStr { \"0\" = \"Zero\", \"1\" = \"One\" }`, indexing by `Zero` or `One` is gunna get me `\"0\"` or `\"1\"`.",
        "createdAt" : "2019-05-31T21:51:19Z",
        "updatedAt" : "2019-05-31T21:51:20Z",
        "lastEditedBy" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "tags" : [
        ]
      },
      {
        "id" : "1e4a69ff-939e-4fdf-859f-ee7f98792d74",
        "parentId" : "b3324169-b886-4be2-9125-3ec924532483",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "No, indexing your `StrNum` by `0` or `1` is going to get you `undefined` (there's no reverse mapping for string valued members), and `NumStr` is an error because members can't have numeric names.",
        "createdAt" : "2019-06-02T00:42:53Z",
        "updatedAt" : "2019-06-02T00:42:53Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "49115e73-16ee-4332-b5a7-3b7601555d3b",
        "parentId" : "b3324169-b886-4be2-9125-3ec924532483",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "Anyway, the `unknown` type is consistent with what we infer for object literal types that have no numerically named members. In some sense it would be more consistent to return `undefined` since that's what you're going to get, but that really is an orthogonal issue.",
        "createdAt" : "2019-06-02T00:50:25Z",
        "updatedAt" : "2019-06-02T00:50:25Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "01e41470-57f1-4e9d-821b-b9bfce084666",
        "parentId" : "b3324169-b886-4be2-9125-3ec924532483",
        "authorId" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "body" : "> there's no reverse mapping for string valued member\r\n\r\nI always forget about that.\r\n\r\n> Anyway, the unknown type is consistent with what we infer for object literal types that have no numerically named members\r\n\r\nOh, ick. Ok.",
        "createdAt" : "2019-06-02T03:47:59Z",
        "updatedAt" : "2019-06-02T03:47:59Z",
        "lastEditedBy" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "tags" : [
        ]
      }
    ],
    "commit" : "bb15df3e435e14a85b4a6dc15c000f7eb6af50af",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +53,57 @@    const v3 = getStringIndexValue(E3);\n    const v4 = getNumberIndexValue(E1);\n    const v5 = getNumberIndexValue(E2);\n    const v6 = getNumberIndexValue(E3);\n}"
  }
]
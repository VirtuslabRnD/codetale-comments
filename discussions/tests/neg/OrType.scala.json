[
  {
    "id" : "7c0b1133-063c-4b64-ac15-c76397aedab1",
    "prId" : 1550,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/1550#pullrequestreview-2482915",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7d494fff-e168-439b-bc15-f9396ac8967d",
        "parentId" : null,
        "authorId" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "body" : "why is it an error now?\n",
        "createdAt" : "2016-10-01T20:33:24Z",
        "updatedAt" : "2016-10-11T17:22:53Z",
        "lastEditedBy" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "tags" : [
        ]
      },
      {
        "id" : "aab15731-b9fa-4b56-9f70-8cf46b4dbf10",
        "parentId" : "7d494fff-e168-439b-bc15-f9396ac8967d",
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "I assume this is caused by the change to `findMember`, we now always approximate union prefixes, I think this should be reconsidered since it considerably diminishes the usability of union types, it also breaks the nice symmetry with selection on intersection types.\n",
        "createdAt" : "2016-10-01T20:48:49Z",
        "updatedAt" : "2016-10-11T17:22:53Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "efc7450f-3396-41a7-9ff8-176ce0bfb26d",
        "parentId" : "7d494fff-e168-439b-bc15-f9396ac8967d",
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "@odersky If you don't have the time to investigate the issues with `union-types-narrow-prefix` I could have a look next week.\n",
        "createdAt" : "2016-10-01T20:55:28Z",
        "updatedAt" : "2016-10-11T17:22:53Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "0e45fd34-507c-42e2-83ff-2d7cd5f4f1e7",
        "parentId" : "7d494fff-e168-439b-bc15-f9396ac8967d",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "@smarter Do you have a realistic scenario where the utility of union types is diminished? \n",
        "createdAt" : "2016-10-01T22:07:39Z",
        "updatedAt" : "2016-10-11T17:22:53Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "bac8e77f-26c3-4d45-b026-95f6eeef7337",
        "parentId" : "7d494fff-e168-439b-bc15-f9396ac8967d",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "@darkdimius The previous findMember operation on union types would often fail to instantiate member types properly. I wonder whether that's an issue in the linker as well, since the linker seems to use union types pervasively. \n",
        "createdAt" : "2016-10-01T22:19:05Z",
        "updatedAt" : "2016-10-11T17:22:53Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "88abab97-80ab-4943-b34c-14c71babe849",
        "parentId" : "7d494fff-e168-439b-bc15-f9396ac8967d",
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "I think it might help in some situations where people currently use structural types, for example https://github.com/lampepfl/dotty/issues/1175#issuecomment-242684995.\nThe proposed solution is to use a typeclass but if you assume that everyone should extend `java.io.Closeable` but still want to handle a few special cases that do not implement the interface but still follows its contract (like `scala.io.Source`) you could do:\n\n``` scala\ntype Closeable = java.io.Closeable | scala.io.Source\n```\n",
        "createdAt" : "2016-10-01T22:20:32Z",
        "updatedAt" : "2016-10-11T17:22:53Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "485a43f5-50d6-48b6-b5a4-2791b59cc1ba",
        "parentId" : "7d494fff-e168-439b-bc15-f9396ac8967d",
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Another use case is reducing boilerplate in pattern matching without introducing intermediate traits:\n\n``` scala\nsealed trait Tree\nclass Assign(lhs: Tree, rhs: Tree) extends Tree\nclass Plus(lhs: Tree, rhs: Tree) extends Tree\nclass Foo(x: Tree) extends Tree\n\n(x: Tree) match {\n  case x: (Assign | Plus) => foo(x.lhs, x.rhs)\n  case _ =>\n}\n```\n",
        "createdAt" : "2016-10-01T22:24:49Z",
        "updatedAt" : "2016-10-11T17:22:53Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "05192d9d-b450-4dfd-b47a-7f9235aceb93",
        "parentId" : "7d494fff-e168-439b-bc15-f9396ac8967d",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "@smarter I pushed `union-types-narrow-prefix` to staging. I am a bit skeptical this one can be made to work, though. In particular I don't know what the theoretical foundations of doing it this way would be. \n",
        "createdAt" : "2016-10-01T22:26:33Z",
        "updatedAt" : "2016-10-11T17:22:53Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "58560dea-6cc3-46be-a323-a6186bbdbd22",
        "parentId" : "7d494fff-e168-439b-bc15-f9396ac8967d",
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "I also assume that there might be nice use cases when interfacing with JS APIs, https://github.com/Microsoft/TypeScript/wiki/What's-new-in-TypeScript#union-types has some examples.\n",
        "createdAt" : "2016-10-01T22:28:44Z",
        "updatedAt" : "2016-10-11T17:22:53Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "93270243-2c17-4b4a-bce8-c36ac556c2fb",
        "parentId" : "7d494fff-e168-439b-bc15-f9396ac8967d",
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "@odersky I wonder if we could somehow make something like https://github.com/lampepfl/dotty/blob/master/src/dotty/tools/dotc/transform/Splitter.scala be a part of Typer to avoid having to select on a union type at all\n",
        "createdAt" : "2016-10-01T22:30:48Z",
        "updatedAt" : "2016-10-11T17:22:53Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "594a5092-21d2-48ea-b25c-a3157cc97790",
        "parentId" : "7d494fff-e168-439b-bc15-f9396ac8967d",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "@smarter Both examples make use of the fact that the alternatives have \"coincidentally\" members with the same type. Both also require possibly expensive splitting under the cover. Maybe it's more honest to require one match for `Assign` and another for `Plus`. For now, it looks to me like the use cases are close to code smells.\n",
        "createdAt" : "2016-10-01T22:42:12Z",
        "updatedAt" : "2016-10-11T17:22:53Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "5de4398e-fbf8-427f-8c40-e6a3d9efb0dc",
        "parentId" : "7d494fff-e168-439b-bc15-f9396ac8967d",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : ">  I wonder if we could somehow make something like https://github.com/lampepfl/dotty/blob/master/src/dotty/tools/dotc/transform/Splitter.scala be a part of Typer to avoid having to select on a union type at all\n\nYes, I believe we'd need something like that to make findMember work correctly without widening the qualifier. This would work if findMember was only called when typing a Select node in source code. Unfortunately, it's called in a lot of other situations as well... \n",
        "createdAt" : "2016-10-01T22:48:07Z",
        "updatedAt" : "2016-10-11T17:22:53Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "f2d6f498-7650-4b00-b60e-626b1e83e6d7",
        "parentId" : "7d494fff-e168-439b-bc15-f9396ac8967d",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "To summarize it, the change is on the safe, conservative side. It's a simple way to avoid bugs and keep result types small (no propagation of disjunctions). It requires sometimes manual splitting, hence more verbose code. But it seems that code can always be transformed through manual splitting to fit the new model.\n",
        "createdAt" : "2016-10-01T22:52:30Z",
        "updatedAt" : "2016-10-11T17:22:53Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "36f69b03-320e-438b-8636-5742df9187d6",
        "parentId" : "7d494fff-e168-439b-bc15-f9396ac8967d",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Regarding the linker, if disjunction propagation through selection is required, the linker could do the splitting itself.\n",
        "createdAt" : "2016-10-01T22:54:13Z",
        "updatedAt" : "2016-10-11T17:22:53Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "147bfda3-41e4-42da-9e3e-a596ccd5aa53",
        "parentId" : "7d494fff-e168-439b-bc15-f9396ac8967d",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Another note: The change led to a 5% increase in compilation speed on the junit tests. Not a scientific benchmark, so it might not be a very exact number. But I was fearing it would slow compilation down, so it's nice to see an indication to the contrary.\n",
        "createdAt" : "2016-10-01T22:57:38Z",
        "updatedAt" : "2016-10-11T17:22:53Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "74b8a17c-a269-4a73-8ea5-4d9801f56790",
        "parentId" : "7d494fff-e168-439b-bc15-f9396ac8967d",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "@smarter Actually, even splitting Select nodes is non-trivial. Can you come up with a safe splitting scheme that guarantees all types make sense? I couldn't, because splitting changes path identity. I think that highlights some of the problem we are facing here.\n",
        "createdAt" : "2016-10-02T10:52:35Z",
        "updatedAt" : "2016-10-11T17:22:53Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "61dfc73d-3473-449d-a617-2fb768ec408f",
        "parentId" : "7d494fff-e168-439b-bc15-f9396ac8967d",
        "authorId" : "5a9cd756-9120-4d5e-ac88-e9c636084f0e",
        "body" : "> I also assume that there might be nice use cases when interfacing with JS APIs\n\nI don't think widening the prefix of member selection will be an issue for JS APIs. Also, I agree with @odersky that the use cases look like code smell to me.\n",
        "createdAt" : "2016-10-03T08:25:13Z",
        "updatedAt" : "2016-10-11T17:22:53Z",
        "lastEditedBy" : "5a9cd756-9120-4d5e-ac88-e9c636084f0e",
        "tags" : [
        ]
      }
    ],
    "commit" : "ba18173c4ac655eb07eca036a81a7a8b9e76caa7",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +3,7 @@\nobject Test{\n  def bar(x: B | C): Int | Double = x.x  // error\n  def main(args: Array[String]): Unit = {\n    val b = new B(1)"
  }
]
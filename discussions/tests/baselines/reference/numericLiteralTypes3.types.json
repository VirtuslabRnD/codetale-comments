[
  {
    "id" : "5ffbf8d2-b65f-424a-a81d-32a8aa7b829c",
    "prId" : 42149,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/42149#pullrequestreview-563962472",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "684e060f-3447-49bb-beda-553dec258070",
        "parentId" : null,
        "authorId" : "8ef7dcc8-4842-40e3-9f9a-182aa5f9b120",
        "body" : "This is an interesting reversion; any comments?",
        "createdAt" : "2021-01-07T22:43:09Z",
        "updatedAt" : "2021-01-09T00:34:45Z",
        "lastEditedBy" : "8ef7dcc8-4842-40e3-9f9a-182aa5f9b120",
        "tags" : [
        ]
      },
      {
        "id" : "7c648196-1aa5-44fc-9d00-9d696014eb4f",
        "parentId" : "684e060f-3447-49bb-beda-553dec258070",
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "It seems like, possibly, this happens because when you narrow, you're going to construct a new union. Previously, you'd have an existing type ID to match to an alias.\r\n\r\nI think the weird thing to me is that even if C was declared in terms of B, you wouldn't see it. I think in that case you'd need to introduce origin type narrowing. Not able to test right now though.",
        "createdAt" : "2021-01-07T23:06:15Z",
        "updatedAt" : "2021-01-09T00:34:45Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "7c6b7e51-2952-4827-94c9-6d71f727bcd3",
        "parentId" : "684e060f-3447-49bb-beda-553dec258070",
        "authorId" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "body" : "Seems like an interesting side effect of control flow. In the preceding line, `c: C` was narrowed to `c: B`, but reassigning `c: B` to itself seems to change the type?",
        "createdAt" : "2021-01-07T23:07:54Z",
        "updatedAt" : "2021-01-09T00:34:45Z",
        "lastEditedBy" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "tags" : [
        ]
      },
      {
        "id" : "871e8d5f-f1c5-4b6e-be90-9b7d7b17aa0e",
        "parentId" : "684e060f-3447-49bb-beda-553dec258070",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "The `c = b` assignment on the preceding line narrows the type of `c` to those constituents of `c` for which `b` might provide a value. In other words, `2 | 3`. This happens to be the same type as `B`, but it is strictly speaking unrelated. We could add logic to recognize that it exactly matches the assigned type and then go with the assigned type which would pick up the alias. Not sure it's that important though.",
        "createdAt" : "2021-01-08T02:27:14Z",
        "updatedAt" : "2021-01-09T00:34:45Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      }
    ],
    "commit" : "8881f01fad9b89926a84a175180d361ebbd3a0fb",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +86,90 @@\n    c = c;\n>c = c : 2 | 3\n>c : C\n>c : 2 | 3"
  }
]
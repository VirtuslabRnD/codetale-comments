[
  {
    "id" : "7c736bb5-1dec-4229-96ec-39e30cad803a",
    "prId" : 41544,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/41544#pullrequestreview-546428965",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "304a73bc-fed0-4d71-bd93-d1758b4c0149",
        "parentId" : null,
        "authorId" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "body" : "This one seems wrong. A `[string?]` is equivalent to `[] | [string | undefined]`, so I'd expect something equivalent to `[number, boolean] | [number, string | undefined, boolean]` to pop out (if not that, verbatim). There's no error here, so quietly swallowing the optionality without reflecting it in the result seems ripe for bad behavior.",
        "createdAt" : "2020-12-07T18:42:56Z",
        "updatedAt" : "2020-12-07T19:04:15Z",
        "lastEditedBy" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "tags" : [
        ]
      }
    ],
    "commit" : "77722bb64c311acbc07d83192e85a0f9758bbb08",
    "line" : 17,
    "diffHunk" : "@@ -1,1 +15,19 @@\ntype V20 = Tup3<[number], string[], [number]>;  // [number, ...string[], number]\ntype V21 = Tup3<[number], [string?], [boolean]>;  // [number, string | undefined, boolean]\ntype V22 = Tup3<[number], string[], boolean[]>;  // [number, (string | boolean)[]]\ntype V23 = Tup3<[number], string[], [boolean?]>;  // [number, (string | boolean | undefined)[]]"
  },
  {
    "id" : "070f66b8-40be-4ea1-aa8b-ed6c98032515",
    "prId" : 41544,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/41544#pullrequestreview-546428965",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "42583b73-3f18-4a44-ae40-45c1a8ef4f2e",
        "parentId" : null,
        "authorId" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "body" : "This doesn't seem equivalent? A sequence of strings followed by a sequence of booleans is certainly different than a mixed sequence of strings and booleans. Specifically, the later admits a type like `[number, string, boolean, string, boolean]` that the former does not. Why can we not preserve `[number, ...string[], ...boolean[]]` ? It certainly seems to me to be distinct from this.",
        "createdAt" : "2020-12-07T18:46:02Z",
        "updatedAt" : "2020-12-07T19:04:15Z",
        "lastEditedBy" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "tags" : [
        ]
      }
    ],
    "commit" : "77722bb64c311acbc07d83192e85a0f9758bbb08",
    "line" : 18,
    "diffHunk" : "@@ -1,1 +16,20 @@type V20 = Tup3<[number], string[], [number]>;  // [number, ...string[], number]\ntype V21 = Tup3<[number], [string?], [boolean]>;  // [number, string | undefined, boolean]\ntype V22 = Tup3<[number], string[], boolean[]>;  // [number, (string | boolean)[]]\ntype V23 = Tup3<[number], string[], [boolean?]>;  // [number, (string | boolean | undefined)[]]\ntype V24 = Tup3<[number], [boolean?], string[]>;  // [number, boolean?, ...string[]]"
  },
  {
    "id" : "8cfe35cb-16f9-4fb7-90c9-ec9d5f346262",
    "prId" : 41544,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/41544#pullrequestreview-546428965",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c40bd5ec-5962-4474-95b3-e2a23fcddd44",
        "parentId" : null,
        "authorId" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "body" : "Since we \"support\" middle rests with this, I'd expect to support them in non-generic scenarios as well - building on my above comments, I'd expect `[number, ...string[]] | [number, ...string[], boolean | undefined]` or even `[number, ...string[], boolean?]` exactly. The inputs here would seem to insist that we shouldn't admit `[number, boolean, string]`, but under the current calculation we do.",
        "createdAt" : "2020-12-07T18:51:42Z",
        "updatedAt" : "2020-12-07T19:04:15Z",
        "lastEditedBy" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "tags" : [
        ]
      }
    ],
    "commit" : "77722bb64c311acbc07d83192e85a0f9758bbb08",
    "line" : 19,
    "diffHunk" : "@@ -1,1 +17,21 @@type V21 = Tup3<[number], [string?], [boolean]>;  // [number, string | undefined, boolean]\ntype V22 = Tup3<[number], string[], boolean[]>;  // [number, (string | boolean)[]]\ntype V23 = Tup3<[number], string[], [boolean?]>;  // [number, (string | boolean | undefined)[]]\ntype V24 = Tup3<[number], [boolean?], string[]>;  // [number, boolean?, ...string[]]\ntype V25 = Tup3<string[], number[], boolean[]>;  // (string | number | boolean)[]"
  },
  {
    "id" : "bb54990c-12ee-4950-8715-d9b18549f866",
    "prId" : 41544,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/41544#pullrequestreview-546428965",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "07a32ff3-1e93-4a4c-b844-8dbf1801bced",
        "parentId" : null,
        "authorId" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "body" : "Yeah, again, the resulting type here is _much_, _much_ looser than the sequence the inputs imply here. Since we support `[...A, ...B, ...C]` in generic cases, we should support preserving that sequencing in cases without generics. The resulting type here should allow assigning `[\"ok\", 0, true]` to it, but _not_ `[true, 0, \"ok\"]`. We really should preserve that sequencing information that we're using on generics in the nongeneric cases. Which, in this case, means I think the resulting output type can only be `[...string[], ...number[], ...boolean[]]`. I liken this to our pattern literal types. This is very much like a `${string}${number}${boolean}` - that pattern has meaning in its ordering, and shouldn't be collapsed.",
        "createdAt" : "2020-12-07T18:55:29Z",
        "updatedAt" : "2020-12-07T19:04:15Z",
        "lastEditedBy" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "tags" : [
        ]
      }
    ],
    "commit" : "77722bb64c311acbc07d83192e85a0f9758bbb08",
    "line" : 21,
    "diffHunk" : "@@ -1,1 +19,23 @@type V23 = Tup3<[number], string[], [boolean?]>;  // [number, (string | boolean | undefined)[]]\ntype V24 = Tup3<[number], [boolean?], string[]>;  // [number, boolean?, ...string[]]\ntype V25 = Tup3<string[], number[], boolean[]>;  // (string | number | boolean)[]\ntype V26 = Tup3<string[], number[], [boolean]>;  // [...(string | number)[], boolean]\ntype V27 = Tup3<[number?], [string], [boolean?]>;  // [number | undefined, string, boolean?]"
  },
  {
    "id" : "5d158f57-05c8-4b04-b84d-ea43c549e93b",
    "prId" : 41544,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/41544#pullrequestreview-546428965",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9ec35dba-88a1-435e-ab1f-93a9d7fcd233",
        "parentId" : null,
        "authorId" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "body" : "Yeah, I'm probably going to stop pointing out the \"the result is much looser than the inputs imply because we're not preserving multiple spreads in nongeneric cases\" - there's a lot of those in these tests, and I think I've said all I need to at this point.",
        "createdAt" : "2020-12-07T18:56:31Z",
        "updatedAt" : "2020-12-07T19:04:15Z",
        "lastEditedBy" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "tags" : [
        ]
      }
    ],
    "commit" : "77722bb64c311acbc07d83192e85a0f9758bbb08",
    "line" : 22,
    "diffHunk" : "@@ -1,1 +20,24 @@type V24 = Tup3<[number], [boolean?], string[]>;  // [number, boolean?, ...string[]]\ntype V25 = Tup3<string[], number[], boolean[]>;  // (string | number | boolean)[]\ntype V26 = Tup3<string[], number[], [boolean]>;  // [...(string | number)[], boolean]\ntype V27 = Tup3<[number?], [string], [boolean?]>;  // [number | undefined, string, boolean?]\n"
  },
  {
    "id" : "8f6f2ffc-28cc-4de8-a207-7c877a115d60",
    "prId" : 41544,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/41544#pullrequestreview-546428965",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "79437d31-a09a-4f37-b865-75f6a25bf65d",
        "parentId" : null,
        "authorId" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "body" : "I think I'd prefer `[number | undefined, string, boolean?] | [string, boolean?]` here, similarly to one of my above comments. I'm not a fan of dropping the arity-optionality without reflecting it in the resulting type.",
        "createdAt" : "2020-12-07T18:57:58Z",
        "updatedAt" : "2020-12-07T19:04:15Z",
        "lastEditedBy" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "tags" : [
        ]
      }
    ],
    "commit" : "77722bb64c311acbc07d83192e85a0f9758bbb08",
    "line" : 23,
    "diffHunk" : "@@ -1,1 +21,25 @@type V25 = Tup3<string[], number[], boolean[]>;  // (string | number | boolean)[]\ntype V26 = Tup3<string[], number[], [boolean]>;  // [...(string | number)[], boolean]\ntype V27 = Tup3<[number?], [string], [boolean?]>;  // [number | undefined, string, boolean?]\n\ntype V30<A extends unknown[]> = Tup3<A, string[], number[]>;  // [...A, ...(string | number)[]]"
  }
]
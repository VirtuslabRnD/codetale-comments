[
  {
    "id" : "f1ff739d-8c63-4ccf-b1cc-87dffb7d5aef",
    "prId" : 30790,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/30790#pullrequestreview-257775716",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "495a01d2-adaa-492f-8d4a-77db244c5a20",
        "parentId" : null,
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "wasn't this `T=any` elsewhere? Does strictNullChecks change this?",
        "createdAt" : "2019-07-01T18:27:44Z",
        "updatedAt" : "2019-07-04T03:48:16Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      },
      {
        "id" : "3627fa9e-7ed2-4e72-9bdc-b161e4ab1b21",
        "parentId" : "495a01d2-adaa-492f-8d4a-77db244c5a20",
        "authorId" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "body" : "I'm not sure what you mean by elsewhere, but I'll duplicate this test with strictNullChecks disabled",
        "createdAt" : "2019-07-03T23:32:54Z",
        "updatedAt" : "2019-07-04T03:48:16Z",
        "lastEditedBy" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "tags" : [
        ]
      }
    ],
    "commit" : "5f94886850b185bce3e442c40d7b638890f0de7b",
    "line" : 17,
    "diffHunk" : "@@ -1,1 +15,19 @@// 'yield' iteration type inference\nfunction* g001() { // Generator<undefined, void, unknown>\n>g001 : () => Generator<undefined, void, unknown>\n\n    yield;"
  },
  {
    "id" : "6cf51ac8-c7c8-43f2-8818-484b4f9772f7",
    "prId" : 30790,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/30790#pullrequestreview-257775392",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ce93d3fe-819d-46ac-8447-fc6bf193e397",
        "parentId" : null,
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "shouldn't this be `unknown` since that is what's inferred for the entire function?",
        "createdAt" : "2019-07-01T18:29:02Z",
        "updatedAt" : "2019-07-04T03:48:16Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      },
      {
        "id" : "3a9d9de2-6730-450a-bc1e-f44816c21bb0",
        "parentId" : "ce93d3fe-819d-46ac-8447-fc6bf193e397",
        "authorId" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "body" : "This is because we fall back to `any` in `checkYieldExpression` if we don't have a return type annotation. I can make this `unknown`, but I could also possibly infer it from other yield expressions:\r\n\r\n```ts\r\nfunction *g() {\r\n  let x: string = yield;\r\n  let y = yield; // should `y` be `unknown` or `string`?\r\n}\r\n```\r\n\r\nI need to verify the logic isn't circular, but it could be feasible to infer `string` for `y` by first inferring the return type of `g`, then inferring the result of `yield` from `TNext` of the inferred return type. At first glance it doesn't seem to be circular as we only infer `TNext` contextually from type annotations (so `x` is a candidate for contextual typing of `TNext`, but not `y`).",
        "createdAt" : "2019-07-03T19:31:30Z",
        "updatedAt" : "2019-07-04T03:48:16Z",
        "lastEditedBy" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "tags" : [
        ]
      },
      {
        "id" : "cf03462b-49b3-42a8-a0c9-ad79e899ab9b",
        "parentId" : "ce93d3fe-819d-46ac-8447-fc6bf193e397",
        "authorId" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "body" : "In general that seems to work however I have an odd case of an escaping type parameter for this test case:\r\n\r\n*generatorReturnTypeInference.ts*\r\n```ts\r\ndeclare function f2<T>(x: T): T;\r\nfunction* g204() { // Generator<number, void, any>\r\n    const x = f2(yield 1);\r\n}\r\n```\r\n\r\n*generatorReturnTypeInference.types*\r\n```\r\nfunction* g204() { // Generator<number, void, any>\r\n>g204 : () => Generator<number, void, T>\r\n```\r\n\r\nYou end up with an undeclared `T` that comes from `f2`.",
        "createdAt" : "2019-07-03T19:42:54Z",
        "updatedAt" : "2019-07-04T03:48:16Z",
        "lastEditedBy" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "tags" : [
        ]
      },
      {
        "id" : "98d0f607-df44-4f77-9e6a-e8442c3a4444",
        "parentId" : "ce93d3fe-819d-46ac-8447-fc6bf193e397",
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "Relying on other statements in the body sounds hard to get right. `any` is fine with me for now, and `undefined` even better. I just got confused with the variety of possible return types.",
        "createdAt" : "2019-07-03T22:26:02Z",
        "updatedAt" : "2019-07-04T03:48:16Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      },
      {
        "id" : "607c2580-c0ee-45bf-8cc2-ecc9b1900c5b",
        "parentId" : "ce93d3fe-819d-46ac-8447-fc6bf193e397",
        "authorId" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "body" : "Yeah, I've looked into it and there are a number of issues with trying to set up the machinery for that. `yield` returning `any` when there is no return type annotation is the best we can do currently.",
        "createdAt" : "2019-07-03T23:31:15Z",
        "updatedAt" : "2019-07-04T03:48:16Z",
        "lastEditedBy" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "tags" : [
        ]
      }
    ],
    "commit" : "5f94886850b185bce3e442c40d7b638890f0de7b",
    "line" : 27,
    "diffHunk" : "@@ -1,1 +25,29 @@\n    yield 1;\n>yield 1 : any\n>1 : 1\n}"
  },
  {
    "id" : "effed442-7a4f-415e-adbd-cadf4062f576",
    "prId" : 30790,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/30790#pullrequestreview-257761320",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ba03e483-6f6b-40d3-9703-464d71a54b85",
        "parentId" : null,
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "I don't understand why `yield* []` results in `TStep=undefined`.\n",
        "createdAt" : "2019-07-01T18:36:57Z",
        "updatedAt" : "2019-07-04T03:48:16Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      },
      {
        "id" : "9dade859-ded3-4eaa-9fff-47ca802e4e51",
        "parentId" : "ba03e483-6f6b-40d3-9703-464d71a54b85",
        "authorId" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "body" : "The result of a `yield*` is the _return_ type of the delegated generator, not its yield type.",
        "createdAt" : "2019-07-01T21:22:50Z",
        "updatedAt" : "2019-07-04T03:48:16Z",
        "lastEditedBy" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "tags" : [
        ]
      },
      {
        "id" : "43880981-0688-47a0-9bc4-62f1ba272a04",
        "parentId" : "ba03e483-6f6b-40d3-9703-464d71a54b85",
        "authorId" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "body" : "And an `IterableIterator` like an array doesn't have a `TReturn` (so it is `undefined` by default), ofc. :3",
        "createdAt" : "2019-07-01T21:23:12Z",
        "updatedAt" : "2019-07-04T03:48:16Z",
        "lastEditedBy" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "tags" : [
        ]
      },
      {
        "id" : "847da90a-9108-47e9-b6b3-dcd5443199fb",
        "parentId" : "ba03e483-6f6b-40d3-9703-464d71a54b85",
        "authorId" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "body" : "(And, likewise, the hosting generator needs to support the same `TStep` as the delegated generator, which in the case of an `IterableIterator` is `undefined`)",
        "createdAt" : "2019-07-01T21:24:37Z",
        "updatedAt" : "2019-07-04T03:48:16Z",
        "lastEditedBy" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "tags" : [
        ]
      },
      {
        "id" : "a5acfcc2-6904-4001-92cd-7b0bcd278a21",
        "parentId" : "ba03e483-6f6b-40d3-9703-464d71a54b85",
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "Hm. I think I must have confused `T` and `TStep` when I asked this question, but I'm not sure. `T=never` makes perfect sense because `[] : never[]`.",
        "createdAt" : "2019-07-03T22:28:35Z",
        "updatedAt" : "2019-07-04T03:48:16Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      }
    ],
    "commit" : "5f94886850b185bce3e442c40d7b638890f0de7b",
    "line" : 35,
    "diffHunk" : "@@ -1,1 +33,37 @@\n    yield* [];\n>yield* [] : any\n>[] : never[]\n}"
  },
  {
    "id" : "aa3e95b8-14d0-4abb-baf0-2e94ba435fce",
    "prId" : 30790,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/30790#pullrequestreview-257679246",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a853e8af-13c1-4ae6-9e80-7f0441f39f8a",
        "parentId" : null,
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "why infer string from the contextual type? we usually take the last overload when we can't decide between signatures, so I think something more complicated is happening.",
        "createdAt" : "2019-07-01T20:02:02Z",
        "updatedAt" : "2019-07-04T03:48:16Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      },
      {
        "id" : "41defefb-c419-4c92-80e0-6db25787c2d5",
        "parentId" : "a853e8af-13c1-4ae6-9e80-7f0441f39f8a",
        "authorId" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "body" : "I thought we take the first overload? I'm not doing anything unique here, just calling into our existing contextual typing behavior, so it should be consistent.",
        "createdAt" : "2019-07-03T18:53:55Z",
        "updatedAt" : "2019-07-04T03:48:16Z",
        "lastEditedBy" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "tags" : [
        ]
      }
    ],
    "commit" : "5f94886850b185bce3e442c40d7b638890f0de7b",
    "line" : 140,
    "diffHunk" : "@@ -1,1 +138,142 @@>g203 : () => Generator<number, void, string>\n\n\tconst x = f1(yield 1);\n>x : void\n>f1(yield 1) : void"
  }
]
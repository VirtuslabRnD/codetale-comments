[
  {
    "id" : "7929cd15-2cfd-4c20-a5c0-74879f4eb951",
    "prId" : 2164,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7440765a-8704-4a59-b793-ff1bc35cc169",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Also a great test. However, I realized that the semantics of this if you used a `let` binding could be different.\n\n``` TypeScript\nlet v = [1,2,3,4,5]\nfor (let v of v) {\n    console.log(v);\n}\n```\n\nIf I try this out in Traceur, I get each element echoed to my console. I'm not necessarily sure whether this is the expected behavior since I'm not as familiar with this part of the spec. Doesn't look like there exists a test for this, so let's  add one and make sure we have the right semantics.\n",
        "createdAt" : "2015-03-01T23:26:11Z",
        "updatedAt" : "2015-03-02T23:28:19Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "9b424488-a849-4196-95e1-d57a8671c4eb",
        "parentId" : "7440765a-8704-4a59-b793-ff1bc35cc169",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Good catch. I'll try it out, thanks! I'll also test the three bullets you mentioned above, and see what happens. It is possible they will have to be fixed more holistically with regular variable declarations if they are broken.\n",
        "createdAt" : "2015-03-02T00:08:05Z",
        "updatedAt" : "2015-03-02T23:28:19Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "e32728f8-7075-433a-b255-0d84a5c6b0bc",
        "parentId" : "7440765a-8704-4a59-b793-ff1bc35cc169",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "I'm reading the spec section 13.6.4.12, ForIn/OfHeadEvaluation, and for this `let v of v` case, it looks like v is in a temporal dead zone. I'm not very familiar with these, but I guess that means referencing v in that position would be an error. I may simply open a bug for this, but I want to double check what the compiler is supposed to do for a case like that. I did notice that in the case of `let v = v;`, we treat it as having type any, so at least this is consistent.\n",
        "createdAt" : "2015-03-02T02:15:17Z",
        "updatedAt" : "2015-03-02T23:28:19Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "7f4e8eb9-d0da-45c4-82d6-4eb0e3226c1f",
        "parentId" : "7440765a-8704-4a59-b793-ff1bc35cc169",
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "I would assume it means that `v` as declared in the `for-of` statement is not usable from within the expression, so an outer-defined `v` would not be shadowed (and thus, still usable) at that point. Let's discuss tomorrow.\n",
        "createdAt" : "2015-03-02T04:35:00Z",
        "updatedAt" : "2015-03-02T23:28:19Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "e0227d12b90582ec0c6c7389d0a6170813b494d3",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +3,7 @@\n==== tests/cases/conformance/es6/for-ofStatements/for-of32.ts (1 errors) ====\n    for (var v of v) { }\n             ~\n!!! error TS7022: 'v' implicitly has type 'any' because it is does not have a type annotation and is referenced directly or indirectly in its own initializer."
  }
]
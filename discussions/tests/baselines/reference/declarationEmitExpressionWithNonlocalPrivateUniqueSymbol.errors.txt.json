[
  {
    "id" : "46033f63-d8e6-43c5-8b9c-2bafca9be988",
    "prId" : 40886,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/40886#pullrequestreview-501335255",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a708c8ae-b183-459f-a481-e5e93701c2a4",
        "parentId" : null,
        "authorId" : "7b7aae27-4774-41a7-bce2-94c871708547",
        "body" : "Wait, why couldnâ€™t it just serialize as `typeof A` (or `typeof import('./a').A` if the import gets erased) here?",
        "createdAt" : "2020-10-02T16:59:43Z",
        "updatedAt" : "2020-10-02T16:59:43Z",
        "lastEditedBy" : "7b7aae27-4774-41a7-bce2-94c871708547",
        "tags" : [
        ]
      },
      {
        "id" : "9f179db3-6a71-4c67-9fca-1b05a572bf61",
        "parentId" : "a708c8ae-b183-459f-a481-e5e93701c2a4",
        "authorId" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "body" : "I said as why in the issue, but I'll restate it here: because that could only work for specific patterns of assignments, and while we may carve out syntactic patterns for checking JS, we do not for TS. So because it doesn't generalize beyond `var x = entity.name` assignments to all assignments, it doesn't make sense to do, really.",
        "createdAt" : "2020-10-02T17:54:23Z",
        "updatedAt" : "2020-10-02T17:54:23Z",
        "lastEditedBy" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "tags" : [
        ]
      }
    ],
    "commit" : "b86dc3438683327ed8928802a76e2a22603af706",
    "line" : 9,
    "diffHunk" : "@@ -1,1 +7,11 @@==== tests/cases/compiler/b.ts (1 errors) ====\n    import { A } from './a';\n    export const A1 = A;\n                 ~~\n!!! error TS2527: The inferred type of 'A1' references an inaccessible 'unique symbol' type. A type annotation is necessary."
  }
]
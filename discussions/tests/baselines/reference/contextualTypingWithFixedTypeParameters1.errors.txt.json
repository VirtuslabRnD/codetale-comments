[
  {
    "id" : "c0d73e6c-03ac-444f-8f0d-53386895453c",
    "prId" : 1861,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "afbea427-e353-43a3-9ad9-17268e6769a1",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "This seems incorrect. I think you want an error like the one that used to be there. It should read something like:\n\n```\nThe type argument for type parameter 'T' cannot be inferred from the usage. Consider specifying the type arguments explicitly.\n\nType argument candidate 'string' is not a valid type argument because it is not a supertype of candidate 'number'.\n```\n\nWhat should happen is the middle argument is context sensitive, so we get no inferences from it initially, and the two candidates are string and number. Then we do the second pass, and it comes time to fix, and we error that 'T' cannot be inferred because candidate 'string' is not a supertype of candidate 'number'.\n",
        "createdAt" : "2015-01-30T08:50:08Z",
        "updatedAt" : "2015-02-02T18:26:39Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "36815884-f931-48b8-b04c-21eadb6a0cfd",
        "parentId" : "afbea427-e353-43a3-9ad9-17268e6769a1",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "We don't consider the outer arrow function to be context sensitive (it has no contextually typed parameters), but the contextual typing of the inner arrow function causes T to be fixed at its current set of inferences (string) during the initial pass. The later inference of number is ignored because T is already fixed.\n\nThe issue isn't related to this PR and I'm not sure that we want to fix it--nor am I sure how.\n",
        "createdAt" : "2015-01-30T17:47:39Z",
        "updatedAt" : "2015-02-02T18:26:39Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "c053a415-c146-4fc0-b85c-1b51438a2cbf",
        "parentId" : "afbea427-e353-43a3-9ad9-17268e6769a1",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "But the inner arrow function is context sensitive, so shouldn't we skip it in the first pass, and thus not fix T?\n",
        "createdAt" : "2015-01-30T19:08:36Z",
        "updatedAt" : "2015-02-02T18:26:39Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "4fdb9dd6-f1a4-4c6a-bab4-72fa045ae0d4",
        "parentId" : "afbea427-e353-43a3-9ad9-17268e6769a1",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "Well, knowing that it is context sensitive (in the return type) would require us to analyze all return expressions in the function expression, which starts to get rather complicated.\n",
        "createdAt" : "2015-01-30T21:40:14Z",
        "updatedAt" : "2015-02-02T18:26:39Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "dc7ba880-781d-444d-aed1-2a819c5d34c4",
        "parentId" : "afbea427-e353-43a3-9ad9-17268e6769a1",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "I think we need to do that.\n",
        "createdAt" : "2015-01-30T21:41:41Z",
        "updatedAt" : "2015-02-02T18:26:39Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "8dfc14b8-702f-4a69-b07b-d06429aa028d",
        "parentId" : "afbea427-e353-43a3-9ad9-17268e6769a1",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "I don't think we _need_ to do it, but it certainly would be better. Either way, it's another orthogonal issue that isn't really related to the PR.\n",
        "createdAt" : "2015-01-30T21:46:27Z",
        "updatedAt" : "2015-02-02T18:26:39Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "78a90c8b-a71b-4609-8772-a24d882ac86e",
        "parentId" : "afbea427-e353-43a3-9ad9-17268e6769a1",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Fair, it would be better.\n",
        "createdAt" : "2015-01-30T21:47:33Z",
        "updatedAt" : "2015-02-02T18:26:39Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "34ed45df8e21de17c061ac01933c7d34058480b5",
    "line" : 22,
    "diffHunk" : "@@ -1,1 +13,17 @@!!! error TS2339: Property 'foo' does not exist on type 'string'.\n                                         ~\n!!! error TS2345: Argument of type 'number' is not assignable to parameter of type 'string'."
  },
  {
    "id" : "0d3b7422-2fec-4aff-990b-9801c1227258",
    "prId" : 1648,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "42fd4bce-942e-4e2b-aab6-2ad1ecd22f62",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "'T' in this message should say 'number'\n",
        "createdAt" : "2015-01-12T19:54:48Z",
        "updatedAt" : "2015-01-12T19:54:48Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "6783e35f89c54cbf8797511693d9775716742de6",
    "line" : 18,
    "diffHunk" : "@@ -1,1 +13,17 @@             ~~~\n!!! error TS2453: The type argument for type parameter 'T' cannot be inferred from the usage. Consider specifying the type arguments explicitly.\n!!! error TS2453:   Type argument candidate 'string' is not a valid type argument because it is not a supertype of candidate 'T'.\n                                   ~~~\n!!! error TS2339: Property 'foo' does not exist on type 'T'."
  },
  {
    "id" : "7bf69707-5c59-45cc-9a29-8de2db952e82",
    "prId" : 824,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "be462baa-ef2b-4785-9760-2d26808519a0",
        "parentId" : null,
        "authorId" : "062f3bee-c17a-4517-ad46-ba1c73ac0962",
        "body" : "breaking change here.\n\nWe used to infer `any` for T because we would attempt to relate the return type of `b` and find `any` as a candidate for T (to go along with string and number candidates). It's not clear to me yet exactly how the inference changes have affected this.\n",
        "createdAt" : "2014-10-08T23:52:14Z",
        "updatedAt" : "2014-10-13T23:16:25Z",
        "lastEditedBy" : "062f3bee-c17a-4517-ad46-ba1c73ac0962",
        "tags" : [
        ]
      },
      {
        "id" : "8d7e87b0-a669-4128-a23a-5b6cf9893c51",
        "parentId" : "be462baa-ef2b-4785-9760-2d26808519a0",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "I'm not sure how (or if) we would infer `any` in the old compiler. I think we would have inferred `{}` because that was the best common type of number and string. We wouldn't make any inferences from `a` in the lambda argument since it has no type annotation.\n\nIn the new compiler we error now because none of the inferred types is a supertype of all others.\n",
        "createdAt" : "2014-10-09T17:07:43Z",
        "updatedAt" : "2014-10-13T23:16:25Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "6bf2fc74-5534-4765-bc69-ed66a24f34d0",
        "parentId" : "be462baa-ef2b-4785-9760-2d26808519a0",
        "authorId" : "062f3bee-c17a-4517-ad46-ba1c73ac0962",
        "body" : "The argument `() => (a => a.foo)` is not contextually typed so `a` gets `any` and then we attempt to relate the return type `a => a.foo` to the parameter type `(a:T) => void` and get `any` as an additional candidate for T. I believe it's this bit in 3.8.6:\n\n> o  If M is a call signature and a corresponding call signature N exists in S, N is instantiated with the Any type as an argument for each type parameter (if any) and inferences are made from parameter types in N to the corresponding parameter types in M for positions that are present in both signatures, and from the return type of N to the return type of M.\n\nI can see why the new compiler is giving an error if `any` is not added to the candidate set but I'm not clear on what rule makes us stop gathering the `any` there as the old compiler appears to be per spec there.\n",
        "createdAt" : "2014-10-09T18:21:34Z",
        "updatedAt" : "2014-10-13T23:16:25Z",
        "lastEditedBy" : "062f3bee-c17a-4517-ad46-ba1c73ac0962",
        "tags" : [
        ]
      },
      {
        "id" : "29c1e912-041b-4482-bf46-b59fca8a68c3",
        "parentId" : "be462baa-ef2b-4785-9760-2d26808519a0",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "Ok, I missed the subtlety of parentheses around the inner lambda. The change in behavior actually relates to how the new compiler does overload resolution. Because the _outer lambda_ in `() => (...)` has no type parameters or type annotations, it is considered subject to contextual typing and therefore excluded from the first round of type argument inference. That causes us to infer number and string (but not any) for T and therefore inference fails. If you put yet another set of parentheses around the argument\n\n``` TypeScript\nvar r9 = f10('', (() => (a => a.foo)), 1);\n```\n\nyou get old behavior because the argument is no longer subject to contextual typing.\n\nMany subtleties here, but I think the new behavior is just fine.\n",
        "createdAt" : "2014-10-09T18:50:10Z",
        "updatedAt" : "2014-10-13T23:16:25Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      }
    ],
    "commit" : "f5cd4145d5e2e02672018c267dbfc00ee1d2ebcb",
    "line" : null,
    "diffHunk" : "@@ -1,1 +10,14 @@    var r9 = f10('', () => (a => a.foo), 1); // error\n             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n!!! error TS2346: Supplied parameters do not match any signature of call target."
  }
]
[
  {
    "id" : "b28a2119-b44b-4c9d-892a-1a869f527844",
    "prId" : 42620,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/42620#pullrequestreview-587128254",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "eca5892e-73f4-47c1-a8bd-3cbfc5188b23",
        "parentId" : null,
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "The addition of the type parameter seems a *little* odd. Why does a contextual signature give this function a type parameter?",
        "createdAt" : "2021-02-09T00:03:36Z",
        "updatedAt" : "2021-02-22T21:11:07Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      },
      {
        "id" : "2602203b-72da-45d5-b02e-76cf70c6967a",
        "parentId" : "eca5892e-73f4-47c1-a8bd-3cbfc5188b23",
        "authorId" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "body" : "`Array`'s call signature has type parameters (and multiple overloads, hence why we only now pick it up), so our contextual signature logic says to persist those type parameters onto the inferred signature (so they can be inferred and used at the parameter types). That type parameter just happens to end up unused, since the parameters are all annotated with types that override the inferred ones. Specifically, it has the signatures:\r\n```\r\n    (arrayLength?: number): any[];\r\n    <T>(arrayLength: number): T[];\r\n    <T>(...items: T[]): T[];\r\n```\r\nso it used to be that you'd get no contextual signature whatsoever, whereas now the contextual signature is something like `<T>(arrayLengthOrItem?: number | T, ...items: T[]): T[]`. Technically any time a contextually typed signature has all the parameter types specified, we could probably omit these type parameters. Probably. You can see similar behavior in the `types` baselines today with only one overload and something like:\r\n```ts\r\n// @strictFunctionTypes: false\r\ninterface MyCallable {\r\n    <T>(a: T | number): T[];\r\n}\r\n\r\nconst x: MyCallable = function (arg: number) { return null as any };\r\n```\r\n(`strictFunctionTypes` has to be off for the assignment to succeed, in both cases). I don't know _why_, but we also only do this for _function expressions_ and not _arrow functions_... that's probably indicative of some bug somewhere; but it's a preexisting one.",
        "createdAt" : "2021-02-09T02:07:32Z",
        "updatedAt" : "2021-02-22T21:11:07Z",
        "lastEditedBy" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "tags" : [
        ]
      },
      {
        "id" : "975f9938-7f9a-4341-a84b-e8c1171de6fa",
        "parentId" : "eca5892e-73f4-47c1-a8bd-3cbfc5188b23",
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "OK, I figured it was pre-existing.",
        "createdAt" : "2021-02-09T23:56:49Z",
        "updatedAt" : "2021-02-22T21:11:07Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      }
    ],
    "commit" : "961bcc0bccbce7d47920716c3de86923ce5b70b0",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +1,5 @@=== tests/cases/compiler/redefineArray.ts ===\nArray = function (n:number, s:string) {return n;};\n>Array = function (n:number, s:string) {return n;} : <T>(n: number, s: string) => number\n>Array : ArrayConstructor\n>function (n:number, s:string) {return n;} : <T>(n: number, s: string) => number"
  }
]
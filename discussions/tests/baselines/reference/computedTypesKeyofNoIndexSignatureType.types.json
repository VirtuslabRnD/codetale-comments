[
  {
    "id" : "610c03f1-c31b-4186-a54c-ced7e132f1bb",
    "prId" : 41976,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/41976#pullrequestreview-577759872",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b2c1f331-e4d6-4622-b40e-33ba3e0f5fe9",
        "parentId" : null,
        "authorId" : "7b7aae27-4774-41a7-bce2-94c871708547",
        "body" : "Is this right? `WithoutIndex` appears, at least in quick info, not to have an index signature at all (not sure if it’s represented differently under the hood), so it seems like you shouldn’t be allowed to index into it with `number`?",
        "createdAt" : "2021-01-13T23:45:47Z",
        "updatedAt" : "2021-01-27T21:17:55Z",
        "lastEditedBy" : "7b7aae27-4774-41a7-bce2-94c871708547",
        "tags" : [
        ]
      },
      {
        "id" : "2b44313a-e9fc-4056-b49f-a10fa7128700",
        "parentId" : "b2c1f331-e4d6-4622-b40e-33ba3e0f5fe9",
        "authorId" : "7b7aae27-4774-41a7-bce2-94c871708547",
        "body" : "Slight simplification of the test case, FWIW:\r\n\r\n```ts\r\ntype OmitIndex<T> = {\r\n    [K in keyof T as (string extends K ? never : K)]: T[K];\r\n};\r\n\r\ntype WithIndex = { [x: string]: unknown, foo: \"hello\", bar: \"world\" };\r\ntype WithoutIndex = OmitIndex<WithIndex>; // { foo: \"hello\"; bar: \"world\"; }                  <-- OK\r\n\r\ntype WithIndexKey = keyof WithIndex;\r\ntype WithoutIndexKey = keyof WithoutIndex; // number          <-- Expected: \"foo\" | \"bar\" \r\n```",
        "createdAt" : "2021-01-13T23:48:38Z",
        "updatedAt" : "2021-01-27T21:17:55Z",
        "lastEditedBy" : "7b7aae27-4774-41a7-bce2-94c871708547",
        "tags" : [
        ]
      },
      {
        "id" : "9927b84a-9c9b-4996-a1d5-8e7476223f56",
        "parentId" : "b2c1f331-e4d6-4622-b40e-33ba3e0f5fe9",
        "authorId" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "body" : "_Arguable_ - the `OmitIndex` type is only omitting the `string` key, _however_, a `string` index signature adds both a `string` and `number` key to the `keyof` of the type, since a `string` index signature implies and allows indexing by `number`!",
        "createdAt" : "2021-01-13T23:52:23Z",
        "updatedAt" : "2021-01-27T21:17:55Z",
        "lastEditedBy" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "tags" : [
        ]
      },
      {
        "id" : "3e831e3c-366c-459e-9abd-0a6215fa1c80",
        "parentId" : "b2c1f331-e4d6-4622-b40e-33ba3e0f5fe9",
        "authorId" : "7b7aae27-4774-41a7-bce2-94c871708547",
        "body" : "That makes sense, but two follow up questions:\r\n\r\n1. Why doesn’t quick info show the number index signature in `WithoutIndex`?\r\n2. How should the type `{ [K in keyof { [key: string]: any }]: K }` be understood? Why isn’t it `{ [x: string]: string | number }` or `{ [x: string]: string & number }` or `{ [x: string]: string, [x: number]: number }`?",
        "createdAt" : "2021-01-14T18:26:58Z",
        "updatedAt" : "2021-01-27T21:17:55Z",
        "lastEditedBy" : "7b7aae27-4774-41a7-bce2-94c871708547",
        "tags" : [
        ]
      },
      {
        "id" : "13bd74db-a309-4a62-9a04-2342087fbe0f",
        "parentId" : "b2c1f331-e4d6-4622-b40e-33ba3e0f5fe9",
        "authorId" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "body" : "For 1: The _keyof_ logic includes `number` in the key type, however mapped type mappings iterate over the set of properties/indexes in the original `modifiersType` directly if available (and homomorphic), leading to the discrepancy.\r\nAs for 2: We have no principled answer and our behaviors are arbitrarily chosen. I think I went over the inconsistency at a design meeting just after key mappings were introduced and we decided to stick with all the inconsistencies so we didn't break anyone.",
        "createdAt" : "2021-01-14T19:43:51Z",
        "updatedAt" : "2021-01-27T21:17:55Z",
        "lastEditedBy" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "tags" : [
        ]
      },
      {
        "id" : "9a0066b7-e500-4b9c-8786-8c1a20b33720",
        "parentId" : "b2c1f331-e4d6-4622-b40e-33ba3e0f5fe9",
        "authorId" : "7b7aae27-4774-41a7-bce2-94c871708547",
        "body" : "It feels troubling that\r\n\r\n```ts\r\ndeclare let withoutIndex: WithoutIndex;\r\nwithoutIndex[3];\r\n```\r\n\r\nis an error even though `keyof typeof withoutIndex` includes `number`. Is there any way to observe the numberyness of the keys besides `keyof`?",
        "createdAt" : "2021-01-14T21:58:11Z",
        "updatedAt" : "2021-01-27T21:17:55Z",
        "lastEditedBy" : "7b7aae27-4774-41a7-bce2-94c871708547",
        "tags" : [
        ]
      },
      {
        "id" : "e8398ee7-4d1b-4fe3-be3f-759a7d307011",
        "parentId" : "b2c1f331-e4d6-4622-b40e-33ba3e0f5fe9",
        "authorId" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "body" : "```ts\r\ntype WithIndex = { [x: string]: unknown, foo: \"hello\", bar: \"world\" };\r\n\r\ntype StringOrNumber = keyof WithIndex;\r\n```\r\nis already how keyof already works, so, we allow\r\n```ts\r\ndeclare const val: WithIndex;\r\n\r\nval[12];\r\n\r\nval[null as any as number];\r\n```\r\n\r\nThe `number`-yness of string indexers is pretty visible everywhere it can be shown, IMO. I can't think of somewhere we actually forbid using a number on a string index signature... such a location would probably constitute a bug.",
        "createdAt" : "2021-01-27T20:58:27Z",
        "updatedAt" : "2021-01-27T21:17:55Z",
        "lastEditedBy" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "tags" : [
        ]
      },
      {
        "id" : "8273851c-988a-4d3e-8391-8600f39b2ed8",
        "parentId" : "b2c1f331-e4d6-4622-b40e-33ba3e0f5fe9",
        "authorId" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "body" : "> is an error even though keyof typeof withoutIndex includes number. \r\n\r\nYou can blame this on how we construct mapped types. While the `keyof` result excludes string, mapped type construction actually doesn't use `keyof` at all for homomorphic mapped types (heh), and instead iterates over the slots visible on the modifiers type. If the `string` indexer has been filtered out it doesn't check \"oh, well, maybe a `number` indexer is still appropriate given the filter applied to the modifier\", it just drops it.\r\n\r\nIn any case, `number` is present in the keys is true both before and after this change, so I'm thinking probably doesn't have too much bearing on this change as-is? That could be a separate enhancement/change to how we create mapped types with `as` clauses.",
        "createdAt" : "2021-01-27T21:09:16Z",
        "updatedAt" : "2021-01-27T21:17:55Z",
        "lastEditedBy" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "tags" : [
        ]
      }
    ],
    "commit" : "335a4e39372d7885d3d1337f3badfa5903c7df70",
    "line" : 42,
    "diffHunk" : "@@ -1,1 +40,44 @@\ntype WithoutIndexKey = keyof WithoutIndex; // number          <-- Expected: \"foo\" | \"bar\"\n>WithoutIndexKey : number | \"foo\" | \"bar\"\n"
  }
]
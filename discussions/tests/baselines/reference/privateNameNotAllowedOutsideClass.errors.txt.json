[
  {
    "id" : "c5bec970-645d-41ca-80f5-3db49643bb01",
    "prId" : 30829,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/30829#pullrequestreview-263023832",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f9b5b863-c7be-44f8-afce-3f85a87ddc6d",
        "parentId" : null,
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "a specific, non-parse error message would be better here. It would be worthwhile parsing privates in this location to make that happen.",
        "createdAt" : "2019-07-01T23:34:07Z",
        "updatedAt" : "2019-12-24T10:22:58Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      },
      {
        "id" : "70784b85-020c-4f8c-8038-9fc019d8727d",
        "parentId" : "f9b5b863-c7be-44f8-afce-3f85a87ddc6d",
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "The error I'm looking for is like the one for misuse of contextual keywords, which are closer to what privates are:\r\n\r\n```ts\r\nlet let = 1\r\n    ~~~\r\n   'let' is not allowed to be used as a name in 'let' or 'const' declarations\r\n///////// or\r\nvar let = 1\r\n    ~~~\r\n   Identifier expected. 'let' is a reserved word in strict mode. Modules are automatically in strict mode.\r\n```\r\nAdmittedly, that's a higher standard than some of our other special syntax, like decorators, so it's probably ok to ship without it.\r\n\r\nLet's continue to discuss representation on the main thread; I think computed properties is not a good model.",
        "createdAt" : "2019-07-02T22:06:19Z",
        "updatedAt" : "2019-12-24T10:22:58Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      },
      {
        "id" : "28b35592-d135-406b-aeea-fe0e020ffbc2",
        "parentId" : "f9b5b863-c7be-44f8-afce-3f85a87ddc6d",
        "authorId" : "7c818427-dca2-4bb8-94a1-f7e70e4a264a",
        "body" : "Agreed. As a user I would appreciate an error message that says something about how private names are only allowed in class bodies.\r\n\r\nWhich approach would you recommend for fixing it? I jotted some ideas down here: https://github.com/microsoft/TypeScript/pull/30829#discussion_r299706018\r\n",
        "createdAt" : "2019-07-02T22:19:07Z",
        "updatedAt" : "2019-12-24T10:22:58Z",
        "lastEditedBy" : "7c818427-dca2-4bb8-94a1-f7e70e4a264a",
        "tags" : [
        ]
      },
      {
        "id" : "19c0fc30-3393-44a7-a052-f04047708b6f",
        "parentId" : "f9b5b863-c7be-44f8-afce-3f85a87ddc6d",
        "authorId" : "7c818427-dca2-4bb8-94a1-f7e70e4a264a",
        "body" : "@sandersn @rbuckton @DanielRosenwasser  hoping we can get consensus on the approach in the checker. I summarized the approaches and trade-offs to the best of my knowledge here: https://github.com/microsoft/TypeScript/pull/30829#discussion_r299706018\r\n\r\nalso cc @weswigham , this is relevant to your comment https://github.com/microsoft/TypeScript/pull/30829#issuecomment-507841364",
        "createdAt" : "2019-07-09T13:37:13Z",
        "updatedAt" : "2019-12-24T10:22:58Z",
        "lastEditedBy" : "7c818427-dca2-4bb8-94a1-f7e70e4a264a",
        "tags" : [
        ]
      },
      {
        "id" : "bdc04d8a-17cd-4fdc-82bd-456a86a47e85",
        "parentId" : "f9b5b863-c7be-44f8-afce-3f85a87ddc6d",
        "authorId" : "7c818427-dca2-4bb8-94a1-f7e70e4a264a",
        "body" : "whoops: correct link to the summary: https://github.com/microsoft/TypeScript/pull/30829#discussion_r299706018",
        "createdAt" : "2019-07-09T15:17:00Z",
        "updatedAt" : "2019-12-24T10:22:58Z",
        "lastEditedBy" : "7c818427-dca2-4bb8-94a1-f7e70e4a264a",
        "tags" : [
        ]
      },
      {
        "id" : "51102e30-b7e3-4cc7-aa69-eb9bb4e44739",
        "parentId" : "f9b5b863-c7be-44f8-afce-3f85a87ddc6d",
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "I'll let you know when we've discussed it and decided on something.",
        "createdAt" : "2019-07-09T16:20:31Z",
        "updatedAt" : "2019-12-24T10:22:58Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      },
      {
        "id" : "385cf3dd-12fd-43b8-872a-79bfa606e0cb",
        "parentId" : "f9b5b863-c7be-44f8-afce-3f85a87ddc6d",
        "authorId" : "7c818427-dca2-4bb8-94a1-f7e70e4a264a",
        "body" : "Thanks Nathan and Ron! Your consolidated feedback on the checker approach is [here](https://github.com/microsoft/TypeScript/pull/30829#issuecomment-509839268). I'll consolidate answers here since that comment doesn't allow threading.\r\n\r\nre consolidated error reporting with that for `private` modifier, particularly for `propertiesRelatedTo`:\r\n- I'll review the other error handling and look for points of consolidation.\r\n- Reply re `propertiesRelatedTo`: https://github.com/microsoft/TypeScript/pull/30829/files#r302071097. I think the concerns there re consolidation might generalize.\r\n\r\nre index-access code: If the part we're talking about changing is `getLiteralTypeForPropertyName`:\r\n- it's true that the `return neverType` isn't needed for banning `foo[#bar]` syntax\r\n- However, the `return neverType` seems to be load-bearing with regard to the the behavior of `keyof` with private names:\r\n    - If we remove the `if` entirely, then `checker.ts` doesn't type-check\r\n    - If I add an `assert`, the `assert` gets hit when the `privateNamesAndkeyof` test case is run.\r\n\r\n- re tests: thanks Ron! will incorporate those test cases",
        "createdAt" : "2019-07-11T11:01:29Z",
        "updatedAt" : "2019-12-24T10:22:58Z",
        "lastEditedBy" : "7c818427-dca2-4bb8-94a1-f7e70e4a264a",
        "tags" : [
        ]
      },
      {
        "id" : "70718bef-af35-441f-b4d4-fe5e4b9e7aa7",
        "parentId" : "f9b5b863-c7be-44f8-afce-3f85a87ddc6d",
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "The check should probably go in getLiteralTypeFromProperty, where normal privates are excluded:\r\n\r\n```ts\r\n        function getLiteralTypeFromProperty(prop: Symbol, include: TypeFlags) {\r\n            if (!(getDeclarationModifierFlagsFromSymbol(prop) & ModifierFlags.NonPublicAccessibilityModifier)) {\r\n```\r\n\r\nDoes that work? You probably still need an assert, or a cast in getLiteralTypeFromProperty, to make the compiler happy.",
        "createdAt" : "2019-07-11T22:02:25Z",
        "updatedAt" : "2019-12-24T10:22:58Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      },
      {
        "id" : "6c241037-7584-446a-923f-6f6fdfe4c0e3",
        "parentId" : "f9b5b863-c7be-44f8-afce-3f85a87ddc6d",
        "authorId" : "7c818427-dca2-4bb8-94a1-f7e70e4a264a",
        "body" : "I've added a check for private identifiers to `getLiteralTypeFromProperty` as you suggested, is it OK to keep both checks in both places (`getLiteralTypeFromProperty` and `getLiteralTypeFromPropertyName`)? I hesitate to rely on implicit knowledge of the call graph for safety and think `neverType` expresses intent (based on my limited understanding at this point).\r\n\r\nI take your point about trying to have private identifiers treated like `private` modifier where feasible, but the semantics are very different and often seem to push toward slightly different handling.\r\n\r\nIn this particular case our intents with regard to `private` modifier and `PrivateIdentifier` seem different as follows:\r\n- The way `getLiteralTypeFromPropertyName` for `private` modifier is that it gets the property, even if that property happens to be behind a `private modifier`. The privacy check happens later\r\n- This strategy doesn't seem to make as much sense for private identifiers (#foo) because there is **never** a literal type for private identifiers.  Doing `if (isPrivateIdentifier(name)) { return neverType; }` seems to express this intent. Whereas the intent of a Debug.fail here seems more like \"the order in which these functions are called must not change\".\r\n\r\n\r\n",
        "createdAt" : "2019-07-15T15:52:24Z",
        "updatedAt" : "2019-12-24T10:22:58Z",
        "lastEditedBy" : "7c818427-dca2-4bb8-94a1-f7e70e4a264a",
        "tags" : [
        ]
      },
      {
        "id" : "5f17412d-2419-4bc6-92a4-1fbf237b7f2b",
        "parentId" : "f9b5b863-c7be-44f8-afce-3f85a87ddc6d",
        "authorId" : "7c818427-dca2-4bb8-94a1-f7e70e4a264a",
        "body" : "discussed elsewhere, resolving",
        "createdAt" : "2019-07-17T14:44:50Z",
        "updatedAt" : "2019-12-24T10:22:58Z",
        "lastEditedBy" : "7c818427-dca2-4bb8-94a1-f7e70e4a264a",
        "tags" : [
        ]
      }
    ],
    "commit" : "fbb84d1e81b35f944d994f6c71c3eda40f944b85",
    "line" : 9,
    "diffHunk" : "@@ -1,1 +7,11 @@    const #foo = 3;\n          ~~~~\n!!! error TS1134: Variable declaration expected.\n               ~\n!!! error TS1134: Variable declaration expected."
  }
]
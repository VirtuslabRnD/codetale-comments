[
  {
    "id" : "b50aca9a-4f8e-4331-8d73-20ec86e59bc2",
    "prId" : 5540,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/5540#pullrequestreview-181201872",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "37390044-d7ab-4ca6-a6fa-51545b515b81",
        "parentId" : null,
        "authorId" : "4107dafe-4e7b-4e85-8d5b-63e06e0e6318",
        "body" : "How would we handle optional case class fields? Some pickled representations omit optional fields to optimize space. How would we implement a special pickling/unpickling treatment for optional fields?\r\n\r\nI guess here we should do something with an `implicit match` clause to detect if the field has type `Option[U]`?",
        "createdAt" : "2018-12-03T20:56:24Z",
        "updatedAt" : "2019-01-19T16:40:59Z",
        "lastEditedBy" : "4107dafe-4e7b-4e85-8d5b-63e06e0e6318",
        "tags" : [
        ]
      },
      {
        "id" : "031412f4-9770-4863-bb04-02ab3548da06",
        "parentId" : "37390044-d7ab-4ca6-a6fa-51545b515b81",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Yes, I think so. So that would be up to the user-written code in the typeclasses.",
        "createdAt" : "2018-12-04T11:09:43Z",
        "updatedAt" : "2019-01-19T16:40:59Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "5e4fa24b6ef68b20f91541da8b6a779426a5cd03",
    "line" : 96,
    "diffHunk" : "@@ -1,1 +94,98 @@      inline erasedValue[Elems] match {\n        case _: (elem *: elems1) =>\n          tryPickle[elem](buf, elems(n).asInstanceOf[elem])\n          pickleElems[elems1](buf, elems, n + 1)\n        case _: Unit =>"
  },
  {
    "id" : "139dc37d-e240-45da-a15e-21fdff760166",
    "prId" : 5540,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/5540#pullrequestreview-181275783",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "93f3f24c-0ba7-4372-9d8a-64cbfc482da0",
        "parentId" : null,
        "authorId" : "4107dafe-4e7b-4e85-8d5b-63e06e0e6318",
        "body" : "I find it a bit fragile that we have to manually manage the `n` counter. Would it be possible to get the corresponding field mirror as a parameter? Or maybe to *extract* it?\r\n\r\n~~~ scala\r\ncase _: (mirrorred(elem, label) *: elems1) =>\r\n~~~",
        "createdAt" : "2018-12-03T20:57:14Z",
        "updatedAt" : "2019-01-19T16:40:59Z",
        "lastEditedBy" : "4107dafe-4e7b-4e85-8d5b-63e06e0e6318",
        "tags" : [
        ]
      },
      {
        "id" : "1c2ab60c-e8b7-4cfc-898b-39f49329d545",
        "parentId" : "93f3f24c-0ba7-4372-9d8a-64cbfc482da0",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "That means we'd have to handle extractors in the inlining framework, which is not yet possible. ",
        "createdAt" : "2018-12-04T11:11:55Z",
        "updatedAt" : "2019-01-19T16:40:59Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "5d743b9b-dfb8-487f-8487-948e39c79025",
        "parentId" : "93f3f24c-0ba7-4372-9d8a-64cbfc482da0",
        "authorId" : "4107dafe-4e7b-4e85-8d5b-63e06e0e6318",
        "body" : "OK, so maybe forget about using an extractor. Still, I think it would be better to provide the typeclass implementers a correctly typed `elem` value (to avoid the `asInstanceOf`) along with its label, without requiring them to manage an elements counter.",
        "createdAt" : "2018-12-04T12:22:03Z",
        "updatedAt" : "2019-01-19T16:40:59Z",
        "lastEditedBy" : "4107dafe-4e7b-4e85-8d5b-63e06e0e6318",
        "tags" : [
        ]
      },
      {
        "id" : "24ceb83c-717d-4404-ad3d-01badd1e7b40",
        "parentId" : "93f3f24c-0ba7-4372-9d8a-64cbfc482da0",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Yes, I can see that as part of a framework, which could also be built on top of what we have here. ",
        "createdAt" : "2018-12-04T14:14:04Z",
        "updatedAt" : "2019-01-19T16:40:59Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "5e4fa24b6ef68b20f91541da8b6a779426a5cd03",
    "line" : 97,
    "diffHunk" : "@@ -1,1 +95,99 @@        case _: (elem *: elems1) =>\n          tryPickle[elem](buf, elems(n).asInstanceOf[elem])\n          pickleElems[elems1](buf, elems, n + 1)\n        case _: Unit =>\n      }"
  },
  {
    "id" : "f232fb6d-fc88-4f0e-bed3-86216997a90a",
    "prId" : 5540,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/5540#pullrequestreview-181202284",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3eb9162e-0de2-4377-9608-7d199ac02c88",
        "parentId" : null,
        "authorId" : "4107dafe-4e7b-4e85-8d5b-63e06e0e6318",
        "body" : "Itâ€™s unclear to me at what time is this exception raised. Is it at compile-time or at run-time?\r\n\r\nAlso, how do we report at compile-time to the user that a typeclass instance for the shape of its type can not be generically derived?",
        "createdAt" : "2018-12-03T20:59:32Z",
        "updatedAt" : "2019-01-19T16:40:59Z",
        "lastEditedBy" : "4107dafe-4e7b-4e85-8d5b-63e06e0e6318",
        "tags" : [
        ]
      },
      {
        "id" : "8aafb976-4bf8-47bb-a79b-fcfa0878ee57",
        "parentId" : "3eb9162e-0de2-4377-9608-7d199ac02c88",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "It's at runtime. There's a typelevel.error method that gives a compile-time error message.",
        "createdAt" : "2018-12-04T11:10:52Z",
        "updatedAt" : "2019-01-19T16:40:59Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "5e4fa24b6ef68b20f91541da8b6a779426a5cd03",
    "line" : 138,
    "diffHunk" : "@@ -1,1 +136,140 @@          else unpickleCases[T, alts1](gen, buf, ordinal, n + 1)\n        case _ =>\n          throw new IndexOutOfBoundsException(s\"unexpected ordinal number: $ordinal\")\n      }\n"
  }
]
[
  {
    "id" : "6f43cecb-cd7b-411d-a451-182b5a1773de",
    "prId" : 259,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "eb4334b3-fb53-4ee2-a5ff-1a0a4fd72f02",
        "parentId" : null,
        "authorId" : "577c64bd-5c11-49bb-82b2-27b3fea6bb6e",
        "body" : "isn't procedural syntax deprecated?\n",
        "createdAt" : "2016-08-05T00:52:01Z",
        "updatedAt" : "2016-08-05T00:52:01Z",
        "lastEditedBy" : "577c64bd-5c11-49bb-82b2-27b3fea6bb6e",
        "tags" : [
        ]
      },
      {
        "id" : "d804cfad-8c43-4b79-ba25-10b997aa5a9b",
        "parentId" : "eb4334b3-fb53-4ee2-a5ff-1a0a4fd72f02",
        "authorId" : "8e1ba0a4-3944-431a-8038-82f68ca7fa41",
        "body" : "Procedural or imperative style is always hard to beat if you have concerns about code size, memory consumption and eficiency.\n\nFor example, code like `for (i <- 0 until\u007f len)` create objects under the scene.\n\nFInally, the following is a educated guess, I would have to try it to be sure.   The LLVM backends are optimized for imperative language like C/C++.  Functional style will generate IR code that will be difficult to optimize by these backend compilers.  As more functional language target LLVM, more functional specific optimization pass will be added.\n\nUntil then, I believe it's better to stick to imperative style in a heavily used library.\n",
        "createdAt" : "2016-08-05T01:40:40Z",
        "updatedAt" : "2016-08-05T01:40:40Z",
        "lastEditedBy" : "8e1ba0a4-3944-431a-8038-82f68ca7fa41",
        "tags" : [
        ]
      },
      {
        "id" : "2b144ce5-a7b1-4ceb-88b5-4fd6be18e356",
        "parentId" : "eb4334b3-fb53-4ee2-a5ff-1a0a4fd72f02",
        "authorId" : "0f96d83b-618e-4d06-9aeb-e1d46fa92077",
        "body" : "@Milyardo It's planned to be deprecated. It's not deprecated yet. We should probably avoid it in the future. \n",
        "createdAt" : "2016-08-05T07:56:16Z",
        "updatedAt" : "2016-08-05T07:56:16Z",
        "lastEditedBy" : "0f96d83b-618e-4d06-9aeb-e1d46fa92077",
        "tags" : [
        ]
      },
      {
        "id" : "2f5b77b6-da5c-4453-9a3d-d7ee0cca51d1",
        "parentId" : "eb4334b3-fb53-4ee2-a5ff-1a0a4fd72f02",
        "authorId" : "58a404cb-e346-427a-864c-81e46662c373",
        "body" : "I think he meant\ndef main(args: Array[String]) {\n\nshould be\ndef main(args: Array[String]) = {\n\nOn Fri, Aug 5, 2016, 13:40 Francois Bertrand notifications@github.com\nwrote:\n\n> In\n> tests/run/C_argc_argv-to-java_args/src/main/scala/CArgcArgvToJavaArgs.scala\n> https://github.com/scala-native/scala-native/pull/259#discussion_r73631053\n> :\n> \n> > @@ -0,0 +1,10 @@\n> > +object CArgcArgvToJavaArgs {\n> > -  def main(args: Array[String]) {\n> \n> Procedural or imperative style is always hard to beat if you have concerns\n> about code size, memory consumption and eficiency.\n> \n> For example, code like for (i <- 0 until� len) create objects under the\n> scene.\n> \n> FInally, the following is a educated guess, I would have to try it to be\n> sure. The LLVM backends are optimized for imperative language like C/C++.\n> Functional style will generate IR code that will be difficult to optimize\n> by these backend compilers. As more functional language target LLVM, more\n> functional specific optimization pass will be added.\n> \n> Until then, I believe it's better to stick to imperative style in a\n> heavily used library.\n> \n> —\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub\n> https://github.com/scala-native/scala-native/pull/259/files/ea9c87de71ea11c14fdb543876875bb5a0f25835#r73631053,\n> or mute the thread\n> https://github.com/notifications/unsubscribe-auth/AEG1Z4_8Gn2JOude1W5xP9tnghb6O0Oyks5qcpScgaJpZM4Jb-SL\n> .\n",
        "createdAt" : "2016-08-05T08:03:30Z",
        "updatedAt" : "2016-08-05T08:03:30Z",
        "lastEditedBy" : "58a404cb-e346-427a-864c-81e46662c373",
        "tags" : [
        ]
      }
    ],
    "commit" : "ea9c87de71ea11c14fdb543876875bb5a0f25835",
    "line" : 2,
    "diffHunk" : "@@ -1,1 +0,4 @@object CArgcArgvToJavaArgs {\n  def main(args: Array[String]) {\n    val len = args.length\n"
  }
]
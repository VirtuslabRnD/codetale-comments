[
  {
    "id" : "02e4870c-01c8-4255-a3f9-14538923c1ef",
    "prId" : 1487,
    "prUrl" : "https://github.com/scalameta/metals/pull/1487#pullrequestreview-373444383",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5b5f1ec8-25cf-4734-9441-806adb060cdb",
        "parentId" : null,
        "authorId" : "f252b48f-54a9-478d-8bbb-85f01e5c28e7",
        "body" : "Awesome!",
        "createdAt" : "2020-03-12T11:52:45Z",
        "updatedAt" : "2020-03-24T16:45:28Z",
        "lastEditedBy" : "f252b48f-54a9-478d-8bbb-85f01e5c28e7",
        "tags" : [
        ]
      }
    ],
    "commit" : "55838e6c9f4127bc8d06a8d31a6df496a0b729a8",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +11,15 @@      \"\"\"\n        |package a\n        |trait A { def <<1->0>>xxx: String = \"A\" }\n        |trait B extends A { override def <<2->1>>xxx: String = \"B -> \" + super.xxx }\n        |trait C extends A { override def <<3->1>>xxx: String = \"C -> \" + super.xxx }"
  },
  {
    "id" : "0b6570af-a901-4871-bb21-a919be736823",
    "prId" : 1487,
    "prUrl" : "https://github.com/scalameta/metals/pull/1487#pullrequestreview-374439495",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "abc86cb6-471d-4df7-a20e-a7fe283b753b",
        "parentId" : null,
        "authorId" : "f252b48f-54a9-478d-8bbb-85f01e5c28e7",
        "body" : "Same as in SuperHierarchyLspSuite, this can be simplified by finding the offset and using the scalameta Postion\r\n\r\n",
        "createdAt" : "2020-03-12T11:56:50Z",
        "updatedAt" : "2020-03-24T16:45:28Z",
        "lastEditedBy" : "f252b48f-54a9-478d-8bbb-85f01e5c28e7",
        "tags" : [
        ]
      },
      {
        "id" : "acdfe827-06a7-473a-895c-798b26af46bf",
        "parentId" : "abc86cb6-471d-4df7-a20e-a7fe283b753b",
        "authorId" : "a9556b50-da77-420c-9fe7-08817ae53bff",
        "body" : "I can understand searching for <<1>> <<2>> until not found, but searching for every <<X->Y>> ?\r\nI might not get idea, can you provide more defails how it should work?",
        "createdAt" : "2020-03-13T15:59:59Z",
        "updatedAt" : "2020-03-24T16:45:28Z",
        "lastEditedBy" : "a9556b50-da77-420c-9fe7-08817ae53bff",
        "tags" : [
        ]
      },
      {
        "id" : "e50527cf-0e74-458d-9897-4d429019133b",
        "parentId" : "abc86cb6-471d-4df7-a20e-a7fe283b753b",
        "authorId" : "f252b48f-54a9-478d-8bbb-85f01e5c28e7",
        "body" : "Ok, I was thinking we could make it simpler, but after thinking it might be more complex to rework.",
        "createdAt" : "2020-03-13T16:26:00Z",
        "updatedAt" : "2020-03-24T16:45:28Z",
        "lastEditedBy" : "f252b48f-54a9-478d-8bbb-85f01e5c28e7",
        "tags" : [
        ]
      }
    ],
    "commit" : "55838e6c9f4127bc8d06a8d31a6df496a0b729a8",
    "line" : 293,
    "diffHunk" : "@@ -1,1 +291,295 @@  private def parse(\n      code: String\n  ): (Map[Int, Position], Map[Int, Option[Int]]) = {\n    var line: Int = 0\n    var character: Int = 0"
  }
]
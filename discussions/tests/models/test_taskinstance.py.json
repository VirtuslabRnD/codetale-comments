[
  {
    "id" : "26485124-a190-47d5-9685-e9a0cf97e9aa",
    "prId" : 5372,
    "prUrl" : "https://github.com/apache/airflow/pull/5372#pullrequestreview-247258705",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6a7972ed-597f-4107-9e74-784c9c2653ae",
        "parentId" : null,
        "authorId" : "f73f66ab-2657-4a50-be7a-2ca3ca98c202",
        "body" : "```suggestion\r\n            dag.create_dagrun(\r\n                dag_id=dag.id\r\n```",
        "createdAt" : "2019-06-07T10:25:39Z",
        "updatedAt" : "2019-06-07T19:16:52Z",
        "lastEditedBy" : "f73f66ab-2657-4a50-be7a-2ca3ca98c202",
        "tags" : [
        ]
      },
      {
        "id" : "152113d0-8169-469f-83f2-7fb6d1d9937e",
        "parentId" : "6a7972ed-597f-4107-9e74-784c9c2653ae",
        "authorId" : "a1587925-b1c0-4469-a592-51497b162e71",
        "body" : "create_dagrun does not take dag_id arg",
        "createdAt" : "2019-06-07T17:32:05Z",
        "updatedAt" : "2019-06-07T19:16:52Z",
        "lastEditedBy" : "a1587925-b1c0-4469-a592-51497b162e71",
        "tags" : [
        ]
      },
      {
        "id" : "d4ce9c66-e8f9-44b7-bb33-abd255c71241",
        "parentId" : "6a7972ed-597f-4107-9e74-784c9c2653ae",
        "authorId" : "f73f66ab-2657-4a50-be7a-2ca3ca98c202",
        "body" : "Good point :)",
        "createdAt" : "2019-06-07T19:01:15Z",
        "updatedAt" : "2019-06-07T19:16:52Z",
        "lastEditedBy" : "f73f66ab-2657-4a50-be7a-2ca3ca98c202",
        "tags" : [
        ]
      }
    ],
    "commit" : "50dad99ea5e30492b87f3ba92abc30d5155840e1",
    "line" : 45,
    "diffHunk" : "@@ -1,1 +1004,1008 @@\n        def get_test_ti(session, execution_date: pendulum.datetime, state: str) -> TI:\n            dag.create_dagrun(\n                run_id='scheduled__{}'.format(execution_date.to_iso8601_string()),\n                state=state,"
  },
  {
    "id" : "a86e53f7-66d7-495b-bbd2-3cd41135938d",
    "prId" : 5372,
    "prUrl" : "https://github.com/apache/airflow/pull/5372#pullrequestreview-247267538",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e2783999-9124-4f04-a297-c0a55c885f98",
        "parentId" : null,
        "authorId" : "f73f66ab-2657-4a50-be7a-2ca3ca98c202",
        "body" : "Overall these tests are much nicer! However there is a case missing - we don't check the behaviour when there is no successful previous TI at all. \r\n\r\nUsing the `param` fn from Parameterized we could do something like this:\r\n\r\n```python\r\n    @parameterized.expand((\r\n        ('cron/catchup', '0 0 * * * ', True),\r\n        ('cron/no-catchup', '0 0 * * *', False),\r\n        ('no-sched/catchup', None, True),\r\n        ('no-sched/no-catchup', None, False),\r\n        ('timedelta/catchup', datetime.timedelta(days=1), True),\r\n        ('timedelta/no-catchup', datetime.timedelta(days=1), False),\r\n        param('something_previous_failed', datetime.timedelta(days=1), False, all_previous_failed=True),\r\n    ))\r\n```\r\n\r\n\r\n\r\n```suggestion\r\n    def test_previous_ti_success(self, _, schedule_interval, catchup, all_previous_failed=False) -> None:\r\n```\r\n\r\n(and then use all_previous_failed in `_test_previous_dates_setup` and to change the assertions we run etc.)",
        "createdAt" : "2019-06-07T10:27:01Z",
        "updatedAt" : "2019-06-07T19:16:52Z",
        "lastEditedBy" : "f73f66ab-2657-4a50-be7a-2ca3ca98c202",
        "tags" : [
        ]
      },
      {
        "id" : "8b9f6541-840a-44de-b828-481f358bc5dc",
        "parentId" : "e2783999-9124-4f04-a297-c0a55c885f98",
        "authorId" : "a1587925-b1c0-4469-a592-51497b162e71",
        "body" : "So we already test that something previous failed.  This is what I get for not using verbose variable names. ;) \r\n\r\nThe `number` in `ti{number}_{letter}` means sequence in time.  The `letter` means failed or successful.  The 3 test TIs are `ti1_s`, `ti2_f`, `ti3_s`.\r\n\r\nBecause `ti3_s` returns `ti1_s` _(skipping over the failed TI `ti2_f`)_, we verify that it skips failed TIs.\r\n\r\nAnd because `ti1_s` returns `None`, we verify that when it finds no prior successful runs, `None` is the value returned.\r\n\r\nIf you still think we're missing a case LMK!\r\n",
        "createdAt" : "2019-06-07T17:11:43Z",
        "updatedAt" : "2019-06-07T19:16:52Z",
        "lastEditedBy" : "a1587925-b1c0-4469-a592-51497b162e71",
        "tags" : [
        ]
      },
      {
        "id" : "28955648-df63-4e44-a3f7-8d48b40d0f09",
        "parentId" : "e2783999-9124-4f04-a297-c0a55c885f98",
        "authorId" : "f73f66ab-2657-4a50-be7a-2ca3ca98c202",
        "body" : "I think we are missing when _all_ previous TIs failed. (i.e. previous_ti_success would return None). The subtle difference between this case and `ti1_s` is that ti1_s didn't have any previous ones (successful or otherwise).",
        "createdAt" : "2019-06-07T17:19:27Z",
        "updatedAt" : "2019-06-07T19:16:52Z",
        "lastEditedBy" : "f73f66ab-2657-4a50-be7a-2ca3ca98c202",
        "tags" : [
        ]
      },
      {
        "id" : "634e0796-fc7a-4c12-adfb-2393267fcd79",
        "parentId" : "e2783999-9124-4f04-a297-c0a55c885f98",
        "authorId" : "a1587925-b1c0-4469-a592-51497b162e71",
        "body" : "OK so how about I add a `ti0_f`.  Then this case is covered by the first assert, which checks that `ti1_s.previous_ti_success` returns `None`.",
        "createdAt" : "2019-06-07T17:21:24Z",
        "updatedAt" : "2019-06-07T19:16:52Z",
        "lastEditedBy" : "a1587925-b1c0-4469-a592-51497b162e71",
        "tags" : [
        ]
      },
      {
        "id" : "9667d974-0c3f-4935-b0aa-c29c016846f9",
        "parentId" : "e2783999-9124-4f04-a297-c0a55c885f98",
        "authorId" : "a1587925-b1c0-4469-a592-51497b162e71",
        "body" : "OK -- I refactored the setup helper to allow you so set up arbitrary scenarios in a given test, doing away with the static constants.  \r\n\r\nThis is way better.  Thank you for shepherding me through this learning process and forcing me to do this better.  Never really written tests before!\r\n\r\nAnyway, now a test looks like so:\r\n```\r\n        scenario = [State.SUCCESS, State.FAILED, State.SUCCESS]\r\n\r\n        ti_list = self._test_previous_dates_setup(schedule_interval, catchup, scenario)\r\n\r\n        self.assertIsNone(ti_list[0].previous_ti)\r\n\r\n        self.assertEqual(\r\n            ti_list[2].previous_ti.execution_date,\r\n            ti_list[1].execution_date\r\n        )\r\n\r\n        self.assertNotEqual(\r\n            ti_list[2].previous_ti.execution_date,\r\n            ti_list[0].execution_date\r\n        )\r\n```\r\n\r\nEach test can set up whatever scenario it needs, in order to test desired behavior.  The indexes of `ti_list` are the same as the `scenario` list.\r\n\r\nSo, returning to your concern here, for `previous_ti_success`, I used the FSFS scenario, and it tests that `ti_list[1].previous_ti_success` is `None`.\r\n\r\nPlease take a look when you have a sec and let me know if you'd like anything further.",
        "createdAt" : "2019-06-07T19:23:55Z",
        "updatedAt" : "2019-06-07T19:26:49Z",
        "lastEditedBy" : "a1587925-b1c0-4469-a592-51497b162e71",
        "tags" : [
        ]
      }
    ],
    "commit" : "50dad99ea5e30492b87f3ba92abc30d5155840e1",
    "line" : 98,
    "diffHunk" : "@@ -1,1 +1057,1061 @@\n    @parameterized.expand(_prev_dates_param_list)\n    def test_previous_ti_success(self, _, schedule_interval, catchup) -> None:\n\n        scenario = [State.FAILED, State.SUCCESS, State.FAILED, State.SUCCESS]"
  },
  {
    "id" : "dc9d3087-14a6-4801-b214-5207b3477542",
    "prId" : 5372,
    "prUrl" : "https://github.com/apache/airflow/pull/5372#pullrequestreview-247743812",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "212f47ff-8db7-4fb5-a858-ec2cb0d9bf50",
        "parentId" : null,
        "authorId" : "f73f66ab-2657-4a50-be7a-2ca3ca98c202",
        "body" : "Nice - this makes the test super clear!",
        "createdAt" : "2019-06-10T17:35:30Z",
        "updatedAt" : "2019-06-10T17:35:30Z",
        "lastEditedBy" : "f73f66ab-2657-4a50-be7a-2ca3ca98c202",
        "tags" : [
        ]
      }
    ],
    "commit" : "50dad99ea5e30492b87f3ba92abc30d5155840e1",
    "line" : 100,
    "diffHunk" : "@@ -1,1 +1059,1063 @@    def test_previous_ti_success(self, _, schedule_interval, catchup) -> None:\n\n        scenario = [State.FAILED, State.SUCCESS, State.FAILED, State.SUCCESS]\n\n        ti_list = self._test_previous_dates_setup(schedule_interval, catchup, scenario)"
  },
  {
    "id" : "4437c187-cdaa-49ad-99b7-2fea1c3be604",
    "prId" : 6461,
    "prUrl" : "https://github.com/apache/airflow/pull/6461#pullrequestreview-309855876",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4cce0b82-ddca-4ded-9156-88ea6265b742",
        "parentId" : null,
        "authorId" : "03e41e23-f438-4a06-9652-8f20638d2c3a",
        "body" : "Thanks @ashb for reviewing. Appreciate it.\r\n\r\nI've updated this test because it was passing before, but it was actually invalid. The `xcom_pull` would invoke the `XCom.get_one()` many times, and transform it into an iterable. Therefore ordering would be lost. Now we get the xcom's descending by execution_date, insertion_date.",
        "createdAt" : "2019-10-31T12:56:15Z",
        "updatedAt" : "2019-11-19T21:01:03Z",
        "lastEditedBy" : "03e41e23-f438-4a06-9652-8f20638d2c3a",
        "tags" : [
        ]
      }
    ],
    "commit" : "b7ad4ef892f6f63eca41a24c162137b6dbbbdf99",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +870,874 @@        result = ti1.xcom_pull(\n            task_ids=['test_xcom_1', 'test_xcom_2'], key='foo')\n        self.assertEqual(result, ['baz', 'bar'])\n\n    def test_xcom_pull_after_success(self):"
  },
  {
    "id" : "091763c1-b9d5-4747-86a5-615496bd6558",
    "prId" : 7735,
    "prUrl" : "https://github.com/apache/airflow/pull/7735#pullrequestreview-406696641",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f2d08b22-d25f-4b60-abce-57c5f5221e24",
        "parentId" : null,
        "authorId" : "c25957e2-1132-4c48-a536-3824307fd862",
        "body" : "There was another test in the original PR:\r\n\r\n```python\r\n    def test_respects_prev_dagrun_dep(self):\r\n        dag = models.DAG(dag_id='test_dag')\r\n        task = DummyOperator(dag=dag, task_id='test_task', start_date=DEFAULT_DATE)\r\n        ti = TI(task, DEFAULT_DATE)\r\n        failing_status = [TIDepStatus('test fail status name', False, 'test fail reason')]\r\n        passing_status = [TIDepStatus('test pass status name', True, 'test passing reason')]\r\n        with patch('airflow.ti_deps.deps.prev_dagrun_dep.PrevDagrunDep.get_dep_statuses',\r\n                   return_value=failing_status):\r\n            self.assertFalse(ti.are_dependencies_met())\r\n        with patch('airflow.ti_deps.deps.prev_dagrun_dep.PrevDagrunDep.get_dep_statuses',\r\n                   return_value=passing_status):\r\n            self.assertTrue(ti.are_dependencies_met())\r\n```\r\n\r\nAny reason why we didn't include it?",
        "createdAt" : "2020-05-06T09:19:28Z",
        "updatedAt" : "2020-05-11T02:42:11Z",
        "lastEditedBy" : "c25957e2-1132-4c48-a536-3824307fd862",
        "tags" : [
        ]
      },
      {
        "id" : "a2828913-7a15-4bc8-a63c-bfd8f0942af9",
        "parentId" : "f2d08b22-d25f-4b60-abce-57c5f5221e24",
        "authorId" : "6bfcfa60-5640-4f1e-b0a1-7e0fd1cd2d84",
        "body" : "Ah good point there. I somehow reasoned this wasn't necessary. I couldn't quite remember what the exact reason was. But it could be a misjudgement because now that I take a second look at it, I think we should add it in. Thanks for catching that!",
        "createdAt" : "2020-05-06T14:19:22Z",
        "updatedAt" : "2020-05-11T02:42:11Z",
        "lastEditedBy" : "6bfcfa60-5640-4f1e-b0a1-7e0fd1cd2d84",
        "tags" : [
        ]
      },
      {
        "id" : "b9cc5252-dea3-4097-96ee-d9b469d9a3d3",
        "parentId" : "f2d08b22-d25f-4b60-abce-57c5f5221e24",
        "authorId" : "6bfcfa60-5640-4f1e-b0a1-7e0fd1cd2d84",
        "body" : "Added! :) I really couldn't remember why I omitted it previously",
        "createdAt" : "2020-05-06T14:55:16Z",
        "updatedAt" : "2020-05-11T02:42:11Z",
        "lastEditedBy" : "6bfcfa60-5640-4f1e-b0a1-7e0fd1cd2d84",
        "tags" : [
        ]
      }
    ],
    "commit" : "37b1c890050292037ee05e06c1cafaf8ed06ffb1",
    "line" : 17,
    "diffHunk" : "@@ -1,1 +869,873 @@            self.assertTrue(ti.are_dependencies_met())\n\n    @parameterized.expand([\n        (State.SUCCESS, True),\n        (State.SKIPPED, True),"
  },
  {
    "id" : "a9a864d5-c02e-4c20-bd5e-027624eb3f85",
    "prId" : 14416,
    "prUrl" : "https://github.com/apache/airflow/pull/14416#pullrequestreview-598285161",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3a827fae-db1b-4277-8e2d-1aa459e0a075",
        "parentId" : null,
        "authorId" : "59d531be-9d1e-478d-99a0-6e20963d3e21",
        "body" : "This may be different from the example scenario you gave in the PR description? (\"*e.g. previous instance was marked success without running*\")",
        "createdAt" : "2021-02-24T12:23:55Z",
        "updatedAt" : "2021-02-25T08:02:49Z",
        "lastEditedBy" : "59d531be-9d1e-478d-99a0-6e20963d3e21",
        "tags" : [
        ]
      },
      {
        "id" : "f388aa15-1673-4c9e-b950-0256e5756d64",
        "parentId" : "3a827fae-db1b-4277-8e2d-1aa459e0a075",
        "authorId" : "59d531be-9d1e-478d-99a0-6e20963d3e21",
        "body" : "On the other hand, a very minor suggestion (let me know if it makes sense to you or not :) ): I understand the default `start_date` is `None` for `dag.create_dagrun()`, but may be good to explicitly specify `start_date=None` here, so it's very straight forward for the people reading this chunk later.",
        "createdAt" : "2021-02-24T12:28:24Z",
        "updatedAt" : "2021-02-25T08:02:49Z",
        "lastEditedBy" : "59d531be-9d1e-478d-99a0-6e20963d3e21",
        "tags" : [
        ]
      },
      {
        "id" : "be413211-f4f8-450f-8de0-bf134cf89bd5",
        "parentId" : "3a827fae-db1b-4277-8e2d-1aa459e0a075",
        "authorId" : "c25957e2-1132-4c48-a536-3824307fd862",
        "body" : "@yuqian90 ",
        "createdAt" : "2021-02-24T22:43:30Z",
        "updatedAt" : "2021-02-25T08:02:49Z",
        "lastEditedBy" : "c25957e2-1132-4c48-a536-3824307fd862",
        "tags" : [
        ]
      },
      {
        "id" : "43ec4772-f906-4cc1-857f-9508af20f1fa",
        "parentId" : "3a827fae-db1b-4277-8e2d-1aa459e0a075",
        "authorId" : "f85ef659-e88b-40c6-856b-c86350e0d001",
        "body" : "Hi @XD-DENG , in fact, any scenario that results in the previous execution_date's TaskInstance not having a `start_date` causes this crash. Marking the previous day's TaskInstance success is one way to run into this situation. There are many other ways, e.g. the DagRun for previous execution_date's TaskInstance has not run yet because it's still waiting for the scheduler to run it, or because its dependencies are not yet met). In this test here, the previous dagrun is created without running op, so it has no start_date. This triggers the bug described in the PR summary. I also updated the summary to include more example scenarios. \r\n\r\nRegarding passing `start_date=None` to DagRun. I don't fully understand the use of `DagRun.start_date`. The issue in this PR is caused by the `TaskInstance` not having a `start_date`, not caused by the `DagRun` start_date. Maybe it's because i dont' understand how `DagRun.start_date` is used. Is it used to set the `TaskInstance.start_date` in some way?",
        "createdAt" : "2021-02-25T05:07:06Z",
        "updatedAt" : "2021-02-25T08:02:49Z",
        "lastEditedBy" : "f85ef659-e88b-40c6-856b-c86350e0d001",
        "tags" : [
        ]
      },
      {
        "id" : "865b4547-4707-4ed7-9613-49d7e1569a7d",
        "parentId" : "3a827fae-db1b-4277-8e2d-1aa459e0a075",
        "authorId" : "59d531be-9d1e-478d-99a0-6e20963d3e21",
        "body" : "Hi @yuqian90 , thanks for the clarification.\r\n\r\nRegarding the 2nd point (`start_date=None`), I agree with you and I think I asked a dumb question. So please ignore it :)\r\n\r\nComing back to the first point: I agree with you that there are many scenarios that may lead to this situation. My main point is to have clear description/comment in the test case so that later people can understand it easily (ideally it can cover more than one scenario as well).",
        "createdAt" : "2021-02-25T07:36:15Z",
        "updatedAt" : "2021-02-25T08:02:49Z",
        "lastEditedBy" : "59d531be-9d1e-478d-99a0-6e20963d3e21",
        "tags" : [
        ]
      },
      {
        "id" : "35e9fbf5-a491-484a-af15-77826098c574",
        "parentId" : "3a827fae-db1b-4277-8e2d-1aa459e0a075",
        "authorId" : "f85ef659-e88b-40c6-856b-c86350e0d001",
        "body" : "Thanks @XD-DENG . I've updated the test to make it's intention clearer.",
        "createdAt" : "2021-02-25T08:03:23Z",
        "updatedAt" : "2021-02-25T08:03:23Z",
        "lastEditedBy" : "f85ef659-e88b-40c6-856b-c86350e0d001",
        "tags" : [
        ]
      }
    ],
    "commit" : "d8a9c72241954bc8a47e5a0433174b3b67195cdd",
    "line" : 19,
    "diffHunk" : "@@ -1,1 +1504,1508 @@        dagrun_1 = dag.create_dagrun(\n            execution_date=day_1,\n            state=State.RUNNING,\n            run_type=DagRunType.MANUAL,\n        )"
  },
  {
    "id" : "03330f31-133e-4761-9dcf-bc4004c3fb06",
    "prId" : 16301,
    "prUrl" : "https://github.com/apache/airflow/pull/16301#pullrequestreview-715731402",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c2ae766d-71b2-496b-9814-78bf85395e58",
        "parentId" : null,
        "authorId" : "c7b0cb1c-ff95-4ec9-a0c6-a9f1b5135a52",
        "body" : "```suggestion\r\n            os.kill(os.getpid(), signal.SIGTERM)\r\n```",
        "createdAt" : "2021-07-27T10:09:43Z",
        "updatedAt" : "2021-07-27T10:09:44Z",
        "lastEditedBy" : "c7b0cb1c-ff95-4ec9-a0c6-a9f1b5135a52",
        "tags" : [
        ]
      }
    ],
    "commit" : "089a3c20f367233afefc3818a9a090f11f330e45",
    "line" : 20,
    "diffHunk" : "@@ -1,1 +540,544 @@        def task_function(ti):\n            # pylint: disable=unused-argument\n            os.kill(ti.pid, signal.SIGTERM)\n\n        task = PythonOperator("
  },
  {
    "id" : "c1d213e3-ebcd-4fb3-a235-1ee85376cbcf",
    "prId" : 16686,
    "prUrl" : "https://github.com/apache/airflow/pull/16686#pullrequestreview-694288568",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6af3736f-b356-420b-a676-c852a279c411",
        "parentId" : null,
        "authorId" : "06976a04-f2fc-42f7-903a-bbe73fdfb46f",
        "body" : "this test cover only connection defined in the database.\r\nconnection can also be in secret backend - will the macro work with it? shouldn't it be also covered in test?",
        "createdAt" : "2021-06-28T18:46:48Z",
        "updatedAt" : "2021-06-28T18:46:52Z",
        "lastEditedBy" : "06976a04-f2fc-42f7-903a-bbe73fdfb46f",
        "tags" : [
        ]
      },
      {
        "id" : "e1a0626d-7646-4502-a9a5-b8c64f33702d",
        "parentId" : "6af3736f-b356-420b-a676-c852a279c411",
        "authorId" : "e8563344-32ea-4c07-9731-a2fed8d2edf2",
        "body" : "It's covered already by the unit tests of the methods used `get_connection_from_secrets`. There is no need to repeat those.",
        "createdAt" : "2021-06-28T18:52:41Z",
        "updatedAt" : "2021-06-28T18:52:41Z",
        "lastEditedBy" : "e8563344-32ea-4c07-9731-a2fed8d2edf2",
        "tags" : [
        ]
      }
    ],
    "commit" : "a535dd048a7c8254ddb3c5e16c0ce4f5d5a8f91e",
    "line" : 40,
    "diffHunk" : "@@ -1,1 +1569,1573 @@        ]\n    )\n    def test_template_with_connection(self, content, expected_output):\n        \"\"\"\n        Test the availability of variables in templates"
  },
  {
    "id" : "fa5c4adc-227b-4bcf-aa32-df46ba3addf4",
    "prId" : 17425,
    "prUrl" : "https://github.com/apache/airflow/pull/17425#pullrequestreview-723399652",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8eba674d-27f5-486a-aca2-03847d773259",
        "parentId" : null,
        "authorId" : "c7b0cb1c-ff95-4ec9-a0c6-a9f1b5135a52",
        "body" : "This test is failing, any ideas?",
        "createdAt" : "2021-08-05T14:06:07Z",
        "updatedAt" : "2021-08-05T14:06:07Z",
        "lastEditedBy" : "c7b0cb1c-ff95-4ec9-a0c6-a9f1b5135a52",
        "tags" : [
        ]
      }
    ],
    "commit" : "b396c6850c91fbf02d7e214021c10cb1d07c468e",
    "line" : 1691,
    "diffHunk" : "@@ -1,1 +1916,1920 @@    @mock.patch.dict(os.environ, {\"AIRFLOW_IS_K8S_EXECUTOR_POD\": \"True\"})\n    @mock.patch.object(RenderedTaskInstanceFields, 'get_k8s_pod_yaml')\n    def test_get_rendered_k8s_spec(self, rtif_get_k8s_pod_yaml, dag_maker):\n        # Create new TI for the same Task\n        with dag_maker('test_get_rendered_k8s_spec'):"
  }
]
[
  {
    "id" : "26485124-a190-47d5-9685-e9a0cf97e9aa",
    "prId" : 5372,
    "prUrl" : "https://github.com/apache/airflow/pull/5372#pullrequestreview-247258705",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6a7972ed-597f-4107-9e74-784c9c2653ae",
        "parentId" : null,
        "authorId" : "f73f66ab-2657-4a50-be7a-2ca3ca98c202",
        "body" : "```suggestion\r\n            dag.create_dagrun(\r\n                dag_id=dag.id\r\n```",
        "createdAt" : "2019-06-07T10:25:39Z",
        "updatedAt" : "2019-06-07T19:16:52Z",
        "lastEditedBy" : "f73f66ab-2657-4a50-be7a-2ca3ca98c202",
        "tags" : [
        ]
      },
      {
        "id" : "152113d0-8169-469f-83f2-7fb6d1d9937e",
        "parentId" : "6a7972ed-597f-4107-9e74-784c9c2653ae",
        "authorId" : "a1587925-b1c0-4469-a592-51497b162e71",
        "body" : "create_dagrun does not take dag_id arg",
        "createdAt" : "2019-06-07T17:32:05Z",
        "updatedAt" : "2019-06-07T19:16:52Z",
        "lastEditedBy" : "a1587925-b1c0-4469-a592-51497b162e71",
        "tags" : [
        ]
      },
      {
        "id" : "d4ce9c66-e8f9-44b7-bb33-abd255c71241",
        "parentId" : "6a7972ed-597f-4107-9e74-784c9c2653ae",
        "authorId" : "f73f66ab-2657-4a50-be7a-2ca3ca98c202",
        "body" : "Good point :)",
        "createdAt" : "2019-06-07T19:01:15Z",
        "updatedAt" : "2019-06-07T19:16:52Z",
        "lastEditedBy" : "f73f66ab-2657-4a50-be7a-2ca3ca98c202",
        "tags" : [
        ]
      }
    ],
    "commit" : "50dad99ea5e30492b87f3ba92abc30d5155840e1",
    "line" : 45,
    "diffHunk" : "@@ -1,1 +1004,1008 @@\n        def get_test_ti(session, execution_date: pendulum.datetime, state: str) -> TI:\n            dag.create_dagrun(\n                run_id='scheduled__{}'.format(execution_date.to_iso8601_string()),\n                state=state,"
  },
  {
    "id" : "a86e53f7-66d7-495b-bbd2-3cd41135938d",
    "prId" : 5372,
    "prUrl" : "https://github.com/apache/airflow/pull/5372#pullrequestreview-247267538",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e2783999-9124-4f04-a297-c0a55c885f98",
        "parentId" : null,
        "authorId" : "f73f66ab-2657-4a50-be7a-2ca3ca98c202",
        "body" : "Overall these tests are much nicer! However there is a case missing - we don't check the behaviour when there is no successful previous TI at all. \r\n\r\nUsing the `param` fn from Parameterized we could do something like this:\r\n\r\n```python\r\n    @parameterized.expand((\r\n        ('cron/catchup', '0 0 * * * ', True),\r\n        ('cron/no-catchup', '0 0 * * *', False),\r\n        ('no-sched/catchup', None, True),\r\n        ('no-sched/no-catchup', None, False),\r\n        ('timedelta/catchup', datetime.timedelta(days=1), True),\r\n        ('timedelta/no-catchup', datetime.timedelta(days=1), False),\r\n        param('something_previous_failed', datetime.timedelta(days=1), False, all_previous_failed=True),\r\n    ))\r\n```\r\n\r\n\r\n\r\n```suggestion\r\n    def test_previous_ti_success(self, _, schedule_interval, catchup, all_previous_failed=False) -> None:\r\n```\r\n\r\n(and then use all_previous_failed in `_test_previous_dates_setup` and to change the assertions we run etc.)",
        "createdAt" : "2019-06-07T10:27:01Z",
        "updatedAt" : "2019-06-07T19:16:52Z",
        "lastEditedBy" : "f73f66ab-2657-4a50-be7a-2ca3ca98c202",
        "tags" : [
        ]
      },
      {
        "id" : "8b9f6541-840a-44de-b828-481f358bc5dc",
        "parentId" : "e2783999-9124-4f04-a297-c0a55c885f98",
        "authorId" : "a1587925-b1c0-4469-a592-51497b162e71",
        "body" : "So we already test that something previous failed.  This is what I get for not using verbose variable names. ;) \r\n\r\nThe `number` in `ti{number}_{letter}` means sequence in time.  The `letter` means failed or successful.  The 3 test TIs are `ti1_s`, `ti2_f`, `ti3_s`.\r\n\r\nBecause `ti3_s` returns `ti1_s` _(skipping over the failed TI `ti2_f`)_, we verify that it skips failed TIs.\r\n\r\nAnd because `ti1_s` returns `None`, we verify that when it finds no prior successful runs, `None` is the value returned.\r\n\r\nIf you still think we're missing a case LMK!\r\n",
        "createdAt" : "2019-06-07T17:11:43Z",
        "updatedAt" : "2019-06-07T19:16:52Z",
        "lastEditedBy" : "a1587925-b1c0-4469-a592-51497b162e71",
        "tags" : [
        ]
      },
      {
        "id" : "28955648-df63-4e44-a3f7-8d48b40d0f09",
        "parentId" : "e2783999-9124-4f04-a297-c0a55c885f98",
        "authorId" : "f73f66ab-2657-4a50-be7a-2ca3ca98c202",
        "body" : "I think we are missing when _all_ previous TIs failed. (i.e. previous_ti_success would return None). The subtle difference between this case and `ti1_s` is that ti1_s didn't have any previous ones (successful or otherwise).",
        "createdAt" : "2019-06-07T17:19:27Z",
        "updatedAt" : "2019-06-07T19:16:52Z",
        "lastEditedBy" : "f73f66ab-2657-4a50-be7a-2ca3ca98c202",
        "tags" : [
        ]
      },
      {
        "id" : "634e0796-fc7a-4c12-adfb-2393267fcd79",
        "parentId" : "e2783999-9124-4f04-a297-c0a55c885f98",
        "authorId" : "a1587925-b1c0-4469-a592-51497b162e71",
        "body" : "OK so how about I add a `ti0_f`.  Then this case is covered by the first assert, which checks that `ti1_s.previous_ti_success` returns `None`.",
        "createdAt" : "2019-06-07T17:21:24Z",
        "updatedAt" : "2019-06-07T19:16:52Z",
        "lastEditedBy" : "a1587925-b1c0-4469-a592-51497b162e71",
        "tags" : [
        ]
      },
      {
        "id" : "9667d974-0c3f-4935-b0aa-c29c016846f9",
        "parentId" : "e2783999-9124-4f04-a297-c0a55c885f98",
        "authorId" : "a1587925-b1c0-4469-a592-51497b162e71",
        "body" : "OK -- I refactored the setup helper to allow you so set up arbitrary scenarios in a given test, doing away with the static constants.  \r\n\r\nThis is way better.  Thank you for shepherding me through this learning process and forcing me to do this better.  Never really written tests before!\r\n\r\nAnyway, now a test looks like so:\r\n```\r\n        scenario = [State.SUCCESS, State.FAILED, State.SUCCESS]\r\n\r\n        ti_list = self._test_previous_dates_setup(schedule_interval, catchup, scenario)\r\n\r\n        self.assertIsNone(ti_list[0].previous_ti)\r\n\r\n        self.assertEqual(\r\n            ti_list[2].previous_ti.execution_date,\r\n            ti_list[1].execution_date\r\n        )\r\n\r\n        self.assertNotEqual(\r\n            ti_list[2].previous_ti.execution_date,\r\n            ti_list[0].execution_date\r\n        )\r\n```\r\n\r\nEach test can set up whatever scenario it needs, in order to test desired behavior.  The indexes of `ti_list` are the same as the `scenario` list.\r\n\r\nSo, returning to your concern here, for `previous_ti_success`, I used the FSFS scenario, and it tests that `ti_list[1].previous_ti_success` is `None`.\r\n\r\nPlease take a look when you have a sec and let me know if you'd like anything further.",
        "createdAt" : "2019-06-07T19:23:55Z",
        "updatedAt" : "2019-06-07T19:26:49Z",
        "lastEditedBy" : "a1587925-b1c0-4469-a592-51497b162e71",
        "tags" : [
        ]
      }
    ],
    "commit" : "50dad99ea5e30492b87f3ba92abc30d5155840e1",
    "line" : 98,
    "diffHunk" : "@@ -1,1 +1057,1061 @@\n    @parameterized.expand(_prev_dates_param_list)\n    def test_previous_ti_success(self, _, schedule_interval, catchup) -> None:\n\n        scenario = [State.FAILED, State.SUCCESS, State.FAILED, State.SUCCESS]"
  },
  {
    "id" : "dc9d3087-14a6-4801-b214-5207b3477542",
    "prId" : 5372,
    "prUrl" : "https://github.com/apache/airflow/pull/5372#pullrequestreview-247743812",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "212f47ff-8db7-4fb5-a858-ec2cb0d9bf50",
        "parentId" : null,
        "authorId" : "f73f66ab-2657-4a50-be7a-2ca3ca98c202",
        "body" : "Nice - this makes the test super clear!",
        "createdAt" : "2019-06-10T17:35:30Z",
        "updatedAt" : "2019-06-10T17:35:30Z",
        "lastEditedBy" : "f73f66ab-2657-4a50-be7a-2ca3ca98c202",
        "tags" : [
        ]
      }
    ],
    "commit" : "50dad99ea5e30492b87f3ba92abc30d5155840e1",
    "line" : 100,
    "diffHunk" : "@@ -1,1 +1059,1063 @@    def test_previous_ti_success(self, _, schedule_interval, catchup) -> None:\n\n        scenario = [State.FAILED, State.SUCCESS, State.FAILED, State.SUCCESS]\n\n        ti_list = self._test_previous_dates_setup(schedule_interval, catchup, scenario)"
  },
  {
    "id" : "4437c187-cdaa-49ad-99b7-2fea1c3be604",
    "prId" : 6461,
    "prUrl" : "https://github.com/apache/airflow/pull/6461#pullrequestreview-309855876",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4cce0b82-ddca-4ded-9156-88ea6265b742",
        "parentId" : null,
        "authorId" : "03e41e23-f438-4a06-9652-8f20638d2c3a",
        "body" : "Thanks @ashb for reviewing. Appreciate it.\r\n\r\nI've updated this test because it was passing before, but it was actually invalid. The `xcom_pull` would invoke the `XCom.get_one()` many times, and transform it into an iterable. Therefore ordering would be lost. Now we get the xcom's descending by execution_date, insertion_date.",
        "createdAt" : "2019-10-31T12:56:15Z",
        "updatedAt" : "2019-11-19T21:01:03Z",
        "lastEditedBy" : "03e41e23-f438-4a06-9652-8f20638d2c3a",
        "tags" : [
        ]
      }
    ],
    "commit" : "b7ad4ef892f6f63eca41a24c162137b6dbbbdf99",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +870,874 @@        result = ti1.xcom_pull(\n            task_ids=['test_xcom_1', 'test_xcom_2'], key='foo')\n        self.assertEqual(result, ['baz', 'bar'])\n\n    def test_xcom_pull_after_success(self):"
  },
  {
    "id" : "091763c1-b9d5-4747-86a5-615496bd6558",
    "prId" : 7735,
    "prUrl" : "https://github.com/apache/airflow/pull/7735#pullrequestreview-406696641",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f2d08b22-d25f-4b60-abce-57c5f5221e24",
        "parentId" : null,
        "authorId" : "c25957e2-1132-4c48-a536-3824307fd862",
        "body" : "There was another test in the original PR:\r\n\r\n```python\r\n    def test_respects_prev_dagrun_dep(self):\r\n        dag = models.DAG(dag_id='test_dag')\r\n        task = DummyOperator(dag=dag, task_id='test_task', start_date=DEFAULT_DATE)\r\n        ti = TI(task, DEFAULT_DATE)\r\n        failing_status = [TIDepStatus('test fail status name', False, 'test fail reason')]\r\n        passing_status = [TIDepStatus('test pass status name', True, 'test passing reason')]\r\n        with patch('airflow.ti_deps.deps.prev_dagrun_dep.PrevDagrunDep.get_dep_statuses',\r\n                   return_value=failing_status):\r\n            self.assertFalse(ti.are_dependencies_met())\r\n        with patch('airflow.ti_deps.deps.prev_dagrun_dep.PrevDagrunDep.get_dep_statuses',\r\n                   return_value=passing_status):\r\n            self.assertTrue(ti.are_dependencies_met())\r\n```\r\n\r\nAny reason why we didn't include it?",
        "createdAt" : "2020-05-06T09:19:28Z",
        "updatedAt" : "2020-05-11T02:42:11Z",
        "lastEditedBy" : "c25957e2-1132-4c48-a536-3824307fd862",
        "tags" : [
        ]
      },
      {
        "id" : "a2828913-7a15-4bc8-a63c-bfd8f0942af9",
        "parentId" : "f2d08b22-d25f-4b60-abce-57c5f5221e24",
        "authorId" : "6bfcfa60-5640-4f1e-b0a1-7e0fd1cd2d84",
        "body" : "Ah good point there. I somehow reasoned this wasn't necessary. I couldn't quite remember what the exact reason was. But it could be a misjudgement because now that I take a second look at it, I think we should add it in. Thanks for catching that!",
        "createdAt" : "2020-05-06T14:19:22Z",
        "updatedAt" : "2020-05-11T02:42:11Z",
        "lastEditedBy" : "6bfcfa60-5640-4f1e-b0a1-7e0fd1cd2d84",
        "tags" : [
        ]
      },
      {
        "id" : "b9cc5252-dea3-4097-96ee-d9b469d9a3d3",
        "parentId" : "f2d08b22-d25f-4b60-abce-57c5f5221e24",
        "authorId" : "6bfcfa60-5640-4f1e-b0a1-7e0fd1cd2d84",
        "body" : "Added! :) I really couldn't remember why I omitted it previously",
        "createdAt" : "2020-05-06T14:55:16Z",
        "updatedAt" : "2020-05-11T02:42:11Z",
        "lastEditedBy" : "6bfcfa60-5640-4f1e-b0a1-7e0fd1cd2d84",
        "tags" : [
        ]
      }
    ],
    "commit" : "37b1c890050292037ee05e06c1cafaf8ed06ffb1",
    "line" : 17,
    "diffHunk" : "@@ -1,1 +869,873 @@            self.assertTrue(ti.are_dependencies_met())\n\n    @parameterized.expand([\n        (State.SUCCESS, True),\n        (State.SKIPPED, True),"
  }
]
[
  {
    "id" : "a168b85e-8c8b-4d7f-b517-d38e6f3f1494",
    "prId" : 4045,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/4045#pullrequestreview-101539049",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "937c0112-c0eb-4368-9cab-e564c410d98e",
        "parentId" : null,
        "authorId" : "348fab8e-49e2-442e-884d-850c7f41fdde",
        "body" : "Looking at this with @liufengyun, we realize this complication has to do with compiling a match like:\r\n\r\n```scala\r\ndef eval[T](e: Exp[T]) = e match {\r\n  case f @ Fun(x: Fun[Int, Double]) => ???\r\n}\r\n```\r\n\r\nThe correct desugaring is a bit surprising to me, because we want to ensure `f: Fun[Int, Double]`, but this is not justified where `f` is bound but only after the inner match.\r\n\r\n```scala\r\ndef eval[T](e: Exp[T]) = e match {\r\n  case f1: Fun[a1, b1] =>\r\n    f1.f match {\r\n      case f2: Fun[Int, Double] =>\r\n        //***Here*** we learn that a1 = Int and b1 = Double\r\n        //So only ***here*** we can bind `f` with the correct type.\r\n        val f: Fun[Int, Double] = f1\r\n    }\r\n}\r\n```\r\n\r\nWe suspect the typechecker currently refines type variables `a1` and `b1` too soon, which has been fine until now, but strictly speaking means (I think) the current typechecker output is not well-typed in a sound typesystem.\r\n\r\nEDIT: as usual, up to misunderstandings.",
        "createdAt" : "2018-03-06T13:21:20Z",
        "updatedAt" : "2018-04-05T14:26:58Z",
        "lastEditedBy" : "348fab8e-49e2-442e-884d-850c7f41fdde",
        "tags" : [
        ]
      }
    ],
    "commit" : "2b00b7a8b352f1adbedfca70946a2170c8148b94",
    "line" : 8,
    "diffHunk" : "@@ -1,1 +6,10 @@    case Fun(x: Fun[Int, Double]) => ???          // error\n    case Fun(x: Exp[Int => String]) => ???        // error\n  }\n}"
  }
]
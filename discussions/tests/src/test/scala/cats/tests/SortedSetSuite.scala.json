[
  {
    "id" : "2eb9d341-b703-4408-8341-fa532b94da1c",
    "prId" : 2915,
    "prUrl" : "https://github.com/typelevel/cats/pull/2915#pullrequestreview-255294286",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fafd28fe-5c5e-4711-a1d6-2cdb9845479e",
        "parentId" : null,
        "authorId" : "9ef0156b-afd7-4f35-80a6-bb89d6331b7c",
        "body" : "@kailuowang Do we still need these?",
        "createdAt" : "2019-06-27T14:18:34Z",
        "updatedAt" : "2019-06-27T14:18:34Z",
        "lastEditedBy" : "9ef0156b-afd7-4f35-80a6-bb89d6331b7c",
        "tags" : [
        ]
      },
      {
        "id" : "f5ba515c-84f5-4416-8faf-309ce376e59e",
        "parentId" : "fafd28fe-5c5e-4711-a1d6-2cdb9845479e",
        "authorId" : "6b760ef7-e448-44a7-b744-0c25c840a80a",
        "body" : "It is redundant, but we are not very consistent when it comes testing laws already covered by the type class laws lower in the hierarchy. That's why I didn't raise an objection here. There is benefit in redundant tests, also sometimes it's hard to track which tests are already covered and remove them. Reducing redundancy to minimum (i.e. always test only the laws lowest in the hierarchy) might have its own problem as well. So right now we are doing it rather arbitrarily. We should probably come up with a principle and add it to the guideline. I created an issue for it https://github.com/typelevel/cats/issues/2919\r\n",
        "createdAt" : "2019-06-27T15:10:01Z",
        "updatedAt" : "2019-06-27T15:10:02Z",
        "lastEditedBy" : "6b760ef7-e448-44a7-b744-0c25c840a80a",
        "tags" : [
        ]
      }
    ],
    "commit" : "dab66fb50eda76d9b5e4945d61e774a572ea6692",
    "line" : 15,
    "diffHunk" : "@@ -1,1 +22,26 @@  checkAll(\"Order[SortedSet[Int]]\", OrderTests[SortedSet[Int]].order)\n  checkAll(\"Order.reverse(Order[SortedSet[Int]])\", OrderTests(Order.reverse(Order[SortedSet[Int]])).order)\n  checkAll(\"PartialOrder[SortedSet[Int]]\", PartialOrderTests[SortedSet[Int]].partialOrder)\n  checkAll(\"PartialOrder.reverse(PartialOrder[SortedSet[Int]])\",\n           PartialOrderTests(PartialOrder.reverse(PartialOrder[SortedSet[Int]])).partialOrder)"
  }
]
[
  {
    "id" : "8f2f0ada-6a33-4a5a-a9b7-8d4ccde2f43d",
    "prId" : 6596,
    "prUrl" : "https://github.com/apache/airflow/pull/6596#pullrequestreview-318952823",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "748f1544-49a4-451f-b17c-5dbcc539c290",
        "parentId" : null,
        "authorId" : "f73f66ab-2657-4a50-be7a-2ca3ca98c202",
        "body" : "Shouldn't be needed.",
        "createdAt" : "2019-11-18T09:54:43Z",
        "updatedAt" : "2019-12-03T13:41:00Z",
        "lastEditedBy" : "f73f66ab-2657-4a50-be7a-2ca3ca98c202",
        "tags" : [
        ]
      },
      {
        "id" : "38c30244-8a3b-4a15-b637-001d32a47111",
        "parentId" : "748f1544-49a4-451f-b17c-5dbcc539c290",
        "authorId" : "e8563344-32ea-4c07-9731-a2fed8d2edf2",
        "body" : "Correct it's not needed. However I still do not like that you can import classes from two places and none of them is \"preferred\". It leads to a number of inconsistencies - sometimes you do 'from airflow import DAG' sometimes 'from airflow.models import DAG' and sometimes 'from airflow.models.dag import DAG'.  And it is very easy for someone to add such unwanted/cyclic dependencies if we have such \"umbrella\" __init__ packages. This is exactly what happened in this case - changes in KubernetesExecutor caused it to import something in airflow and this in-turned caused import of KubernetesExecutor... This can happen all the times if we have such __init__'s with logic + umbrella __init__'s that bring in unnecessary dependencies even if we import one thing from them.\r\n\r\nI am going to deprecate 'from airflow import DAG' (precisely because of the potential cyclic imports it introduces). \r\n\r\nEach of the imports has different implications - for example importing from airflow brings more dependencies and potentially executing some plugin code, importing from models brings implicit dependencies to other models, importing from models.dag is I think best approach - you do not bring additional dependencies only the ones you are interested in. \r\n\r\nAn average (or even experienced) developer of Airflow has no idea about those consequences of different ways of importing such classes from different packages. \r\n\r\nI think we should encourage people to import all classes directly and discourage (by deprecation) importing from \"umbrella\" modules - those bringing a lot of potentially disruptive dependencies. It's really 'explicit is better than implicit' case IMHO. By importing anything from airflow or from airflow.models we bring a lot of implicit dependencies without even knowing about it.\r\n\r\nWDYT @ashb ?\r\n\r\nWhat are the benefits of importing such classes from higher-level packages? I cannot see any except a bit shorter import - I would love if we can simply deprecate all of the non-direct imports. This would make cyclic imports like the one we are dealing with much less of a problem.",
        "createdAt" : "2019-11-18T13:53:30Z",
        "updatedAt" : "2019-12-03T13:41:00Z",
        "lastEditedBy" : "e8563344-32ea-4c07-9731-a2fed8d2edf2",
        "tags" : [
        ]
      },
      {
        "id" : "699237de-f231-4e02-b7c3-823701e53422",
        "parentId" : "748f1544-49a4-451f-b17c-5dbcc539c290",
        "authorId" : "f73f66ab-2657-4a50-be7a-2ca3ca98c202",
        "body" : "> sometimes you do 'from airflow import DAG' sometimes 'from airflow.models import DAG' and sometimes 'from airflow.models.dag import DAG\r\n\r\nFrom a end user point of view I don't want them to have to know which models are in which sub-package as it is a implementation detail that they shouldn't need to care about. (I mostly don't like the one-class-per-package style so want to avoid that where possible. Pet peave of mine I know)\r\n\r\n> I am going to deprecate 'from airflow import DAG'\r\n\r\nI'm not a fan of this as it would require almost every single DAG that exists right now to be changed.\r\n\r\nWe can manage the cyclic imports by explicitly moving some imports to the end of `airflow/__init__.py` \r\n\r\n> An average (or even experienced) developer [user] of Airflow has no idea about those consequences of different ways of importing such classes from different packages.\r\n\r\nOnce `import airflow` has happened then all the packages are loaded an import order doesn't matter, so we can handle this all \"internally\" (which we already do via our unit tests). If it's working right now, then no mater what order it is imported by the user no import cycles are possible is my understanding.",
        "createdAt" : "2019-11-18T16:40:06Z",
        "updatedAt" : "2019-12-03T13:41:00Z",
        "lastEditedBy" : "f73f66ab-2657-4a50-be7a-2ca3ca98c202",
        "tags" : [
        ]
      },
      {
        "id" : "34b6088a-950a-4e37-a640-92b8ddf2db64",
        "parentId" : "748f1544-49a4-451f-b17c-5dbcc539c290",
        "authorId" : "e8563344-32ea-4c07-9731-a2fed8d2edf2",
        "body" : "I think the main reason for our disagreement here is because (in this case) I think more about contributors (especially first-time ones) and you think more about DAG developers. This is the old \"library\" vs \"application\" thing. And we are both kind of right (but with different users in mind).\r\n\r\nI agree that users should have a stable place to import DAG and AirflowException from (in this view airflow is a library), while it confuses developers (and might easily lead to circular imports).\r\n\r\nLet's try to find some approach here that will be good for both. I split the discussion into several smaller subjects to make it more productive.\r\n\r\n## Finding imports\r\n\r\nI know not everyone ;) likes IDEs, but a lot of people does. This is what it looks like when I try to (in PyCharm) import AirflowException:\r\n\r\nBefore my change:\r\n\r\n![Screenshot 2019-11-18 at 20 58 19](https://user-images.githubusercontent.com/595491/69085738-6c594680-0a46-11ea-9da0-a6356a575b5f.png)\r\n\r\nAnd after:\r\n\r\n![Screenshot 2019-11-18 at 20 59 01](https://user-images.githubusercontent.com/595491/69086124-84c96100-0a46-11ea-9950-786d76d0efaa.png)\r\n\r\nThe class that throws deprecation warning is not even shown as importable and I know exactly which class I have to import and i even get a chance to import it locally. Same with DAG.  It's a nuance and not something must-have, but it's nice.\r\n\r\n## Result of the current situation\r\n\r\nI can assure that myself (and many other people) got confused at this point - which is the place we should import DAG from. And it's hard data, not guessing: \r\n\r\n```\r\n[potiuk:~/code/airflow] remove-dag-out-of-airflow-package-import+ 3d6h54m19s ± git show HEAD | grep 'from airflow import DAG' | grep ^- | wc\r\n      80     346    2219\r\n[potiuk:~/code/airflow] remove-dag-out-of-airflow-package-import+ 3d6h54m23s ± git show HEAD | grep 'from airflow.models import DAG' | grep ^- | wc\r\n      97     507    4233\r\n```\r\nWe have now 80 places where someone used `from airflow import DAG` and 97 where people used `from airflow.models import DAG`.  Maybe we have some rules, but they are neither documented nor enforced.\r\n\r\nCan you tell  which way is better? Are you sure people know consequences of using them and the circular imports they might create this way ? I really, really doubt this. As a new user I cannot reason about the distinction. I am confused why those different import path exist. I have no idea which import should I use in my code. Seems like people randomly choose the import they should use without knowing the consequences. Certainly from an \"application/contributors\" point of view it's not good.\r\n\r\n## DAG developer's perspective\r\n\r\n> I'm not a fan of this as it would require almost every single DAG that exists right now to be changed.\r\n\r\nIt does not require them to change - it's merely deprecation warning. But indeed it encourages them to use the models.dag package rather than airflow.DAG. And yes - I agree that having a single place to import for is good for airflow-as-a-library but not necessary good for airflow-as-an-application . \r\n\r\nSo maybe we should do something else instead. Mabe the deprecation warning should only be thrown if you are importing airflow from within airflow core code itself? I will certainly look for a solution here - maybe you can also think of something? And it would be ideal the other way round - if the DAG developers were discouraged to import the airflow.models.dag DAG.\r\n\r\nAnd thinking more about it in the context of AIP-21 - I think those circular imports are only a problem of the \"core\" of airflow and that the \"providers\" part should be treated differently. Especially that we have to be careful about backporting. Since we plan all the providers package to be 1.10.* installable, they should use airflow.DAG likely as import. \r\n\r\nI hope you can agree with me that it makes sense for Airflow \"core\" in airflow repository use a single, direct import (airflow.models.dag.DAG) where circular imports will be least likely. And then \"providers\" might use the \"airflow.DAG\" for backwards compatibility (and serving as model for other integrations). Then I yet have to see if I can make deprecation works in the way I want.\r\n\r\nI think pre-commits + AIP-21 are a good place to start - we could enforce different rules for different parts of the code in fact and educate people this way.\r\n\r\nWDYT @ashb?\r\n\r\n## Avoiding cyclic imports \r\n\r\n> We can manage the cyclic imports by explicitly moving some imports to the end of airflow/__init__.py\r\n\r\nWhich ones? Do you know by heart? I am utterly confused when it comes to the sequence of imports there and I always have to go through many files and imports to understand what's going on -> airflow imports executors -> import kubernetes executor -> import pod -> import pod launcher -> import baseoperator -> import dag  -> import airflow ....... Good import structure should be in fact a .... DAG (!) .... Only then you can start reasoning about it :). \r\n\r\n## Importing 'airflow' package first \r\n\r\n> Once import airflow has happened then all the packages are loaded an import order doesn't matter, so we can handle this all \"internally\" (which we already do via our unit tests). If it's working right now, then no matter what order it is imported by the user no import cycles are possible is my understanding.\r\n\r\nBut I think we should really be able to not airflow first. I had really hard time trying to fix and correct some tests precisely because of the \"import airflow\" first. That's an anti-pattern especially that in tests we had to reload the configuration as it has already been loaded and we had to reload it. The way we run it now is really bad for tests.\r\n\r\nThere is some initialisation magic happening in __init__ which then requires you to reload configuration in a specific way and some tests require this, some not. I know also @nuclearpinguin had a lot of problems trying to fix it in pytest context (and I had it for a long time at many opportunities). \r\n\r\nIn an ideal world there should be no requirement to import airflow first (eventually). We should be able to run some initialisation method or create an object to bootstrap airflow but importing airflow should not have this initialisation side-effect (it's really a side-effect).\r\n\r\nRunning code in __init__.py is, I think, good for library (when you have to perform certain initialisations with however loads the library) but it's not really good for application such as airflow where you have a few clear entry-points and you can run the initialisation explicitly.\r\n\r\nI hope that one day we will get there - and this import restructuring might be one of the steps that could get us there.",
        "createdAt" : "2019-11-18T20:59:31Z",
        "updatedAt" : "2019-12-03T13:41:00Z",
        "lastEditedBy" : "e8563344-32ea-4c07-9731-a2fed8d2edf2",
        "tags" : [
        ]
      },
      {
        "id" : "8aa317d9-3cf8-425b-9094-a8461f8b5395",
        "parentId" : "748f1544-49a4-451f-b17c-5dbcc539c290",
        "authorId" : "f73f66ab-2657-4a50-be7a-2ca3ca98c202",
        "body" : "## Result of the current situation\r\n\r\n> Can you tell which way is better\r\n\r\nNeither :) They both work. But yes, having some internal/enforce rules for the airflow code base is probably a good thing for consistency.\r\n\r\n> Seems like people randomly choose the import they should use without knowing the consequences\r\n\r\nThe only consequence is \"if we change the layout it might break in the future\". There is zero effect right now to import cycles or not.\r\n\r\n## DAG developer's perspective\r\n\r\n> Mabe the deprecation warning should only be thrown if you are importing airflow from within airflow core code itself\r\n\r\nYes if this was achievable I would be happy with this approach.\r\n\r\nYes, the deprecation warning wouldn't _require_ a rewrite, but it would be annoying/noisy until the change was done - i.e. not something I want to force on users without a definite benefit to it.\r\n\r\n> I hope you can agree with me that it makes sense for Airflow \"core\" in airflow repository use a single, direct import (airflow.models.dag.DAG) where circular imports will be least likely\r\n\r\nGrudgingly, because people will look at the internals and copy that, and I really feel like this is leaking abstractions and `airflow.models.DAG` or `airflow.DAG` is what consumers of the library should be using.\r\n\r\nPart of this might be fixed by updating the docs to not build/publish docs for any `airflow.model.*` package (and bonus points for re-writing any references to just `airflow.models.Class`?) \r\n\r\n## Avoiding cyclic imports\r\n\r\nThe avoiding cycling imports doesn't worry me, as the code either works, or it crashes the tests and we fix it on a case-by-base basis. I haven't ever seen a case where what an end user imports causes or avoids a cyclic import -- it's all only within airflow PRs. Is there a case I've not seen where we've got a broken import based on which order packages are imported in tests/user code?  \r\n\r\n## Importing 'airflow' package first\r\n\r\n`python -c import airflow.hooks` will _always_ import `airflow/__init__.py` first and then load `airflow/hooks/__init__.py`. That is how python imports work.\r\n\r\nI'm all in favour of removing the side-effect-from-importing (I reported https://issues.apache.org/jira/browse/AIRFLOW-1931 a long time ago) but the cyclic import issue is just not a concern to me -- to my knowledge import cycles can only be created when _changing_ the airflow code (i.e. writing a PR) if you aren't changing the code then it is impossible to get a cycle.",
        "createdAt" : "2019-11-19T11:06:29Z",
        "updatedAt" : "2019-12-03T13:41:00Z",
        "lastEditedBy" : "f73f66ab-2657-4a50-be7a-2ca3ca98c202",
        "tags" : [
        ]
      }
    ],
    "commit" : "0904b516d3537e9ca52592972e6380ee6fb25125",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +25,29 @@from datetime import datetime, timedelta\n\nfrom airflow.models.dag import DAG\nfrom airflow.operators.dummy_operator import DummyOperator\nfrom airflow.operators.subdag_operator import SubDagOperator"
  }
]
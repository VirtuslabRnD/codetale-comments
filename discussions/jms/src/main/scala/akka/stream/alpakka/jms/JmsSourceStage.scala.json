[
  {
    "id" : "49f4206a-fac7-4475-9956-750049677b22",
    "prId" : 674,
    "prUrl" : "https://github.com/akka/alpakka/pull/674#pullrequestreview-86540073",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "cc75249b-7202-4188-b6a2-790b1392545f",
        "parentId" : null,
        "authorId" : "7b601e48-f550-477f-a23e-0dc6ca34c971",
        "body" : "Do we really need to materialize that killswitch? Can't the stage easily keep track of outstanding non-ack:ed `Message`s and keep going until those are done?",
        "createdAt" : "2018-01-02T08:25:38Z",
        "updatedAt" : "2018-01-06T01:55:34Z",
        "lastEditedBy" : "7b601e48-f550-477f-a23e-0dc6ca34c971",
        "tags" : [
        ]
      },
      {
        "id" : "0e6468c2-ec5a-47f7-a636-537d7435b9da",
        "parentId" : "cc75249b-7202-4188-b6a2-790b1392545f",
        "authorId" : "0ce149e1-76d5-48b6-baaa-612972fcc400",
        "body" : "Only if you use the proprietary `INDIVIDUAL_ACKNOWLEDGE`. Also, what is the formal way to stop the stream? Sticking an extra `KillSwitch` behind the source allows for messages to be fetched and not processed. This will cause re-delivery in the appropriate ack modes and transactional mode, and message loss in `AUTO_ACKNOWLEDGE`. Actually, IMO, any message consumer sources (Kafka included) should have a proper `KillSwitch` at materialization time. Kindly review the shutdown process in JmsSourceStage.",
        "createdAt" : "2018-01-04T02:04:46Z",
        "updatedAt" : "2018-01-06T01:55:34Z",
        "lastEditedBy" : "0ce149e1-76d5-48b6-baaa-612972fcc400",
        "tags" : [
        ]
      }
    ],
    "commit" : "00048ec22994eb21a3a1d57c6e73973c7f69c0fa",
    "line" : 22,
    "diffHunk" : "@@ -1,1 +21,25 @@\nfinal class JmsSourceStage(settings: JmsSourceSettings)\n    extends GraphStageWithMaterializedValue[SourceShape[Message], KillSwitch] {\n\n  private val out = Outlet[Message](\"JmsSource.out\")"
  },
  {
    "id" : "a28187a6-394a-4096-952e-8d4686751627",
    "prId" : 674,
    "prUrl" : "https://github.com/akka/alpakka/pull/674#pullrequestreview-100491244",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "884f64be-106e-4bf1-bbfb-8b3e35d80c64",
        "parentId" : null,
        "authorId" : "f2936d3a-3d13-43a5-9bbe-3432f2a5ab0f",
        "body" : "@akara will this work for `CLIENT_ACKNOWLEDGE`? As it acknowledges all the messages on the session shouldn't this be reset to 0 (and all actions removed from `ackQueue`)?",
        "createdAt" : "2018-03-01T11:26:24Z",
        "updatedAt" : "2018-03-01T12:26:17Z",
        "lastEditedBy" : "f2936d3a-3d13-43a5-9bbe-3432f2a5ab0f",
        "tags" : [
        ]
      },
      {
        "id" : "1bb1c5a6-e5e6-460d-bcfa-a5884bcbd16f",
        "parentId" : "884f64be-106e-4bf1-bbfb-8b3e35d80c64",
        "authorId" : "f2936d3a-3d13-43a5-9bbe-3432f2a5ab0f",
        "body" : "@akara Or thinking about it for `CLIENT_ACKNOWLEDGE` should it only be possible to set `maxPendingAck` to 0?",
        "createdAt" : "2018-03-01T15:53:20Z",
        "updatedAt" : "2018-03-01T15:53:20Z",
        "lastEditedBy" : "f2936d3a-3d13-43a5-9bbe-3432f2a5ab0f",
        "tags" : [
        ]
      },
      {
        "id" : "834798d9-b4bc-4146-a144-39348cd76e5b",
        "parentId" : "884f64be-106e-4bf1-bbfb-8b3e35d80c64",
        "authorId" : "7b601e48-f550-477f-a23e-0dc6ca34c971",
        "body" : "This PR is already merged, please open a new ticket for issues or use some other channel (gitter or akka-user mailing list) if it is more of a discussion/question, thanks!",
        "createdAt" : "2018-03-01T16:01:37Z",
        "updatedAt" : "2018-03-01T16:01:38Z",
        "lastEditedBy" : "7b601e48-f550-477f-a23e-0dc6ca34c971",
        "tags" : [
        ]
      },
      {
        "id" : "083d4a65-6d86-4ab4-9810-7c61bad79706",
        "parentId" : "884f64be-106e-4bf1-bbfb-8b3e35d80c64",
        "authorId" : "f2936d3a-3d13-43a5-9bbe-3432f2a5ab0f",
        "body" : "Ah sorry was just looking at the history and didn't think it's probably a strange communication channel! I'll get on gitter or create an issue if I find something wrong. Thanks.",
        "createdAt" : "2018-03-01T16:10:00Z",
        "updatedAt" : "2018-03-01T16:10:00Z",
        "lastEditedBy" : "f2936d3a-3d13-43a5-9bbe-3432f2a5ab0f",
        "tags" : [
        ]
      }
    ],
    "commit" : "00048ec22994eb21a3a1d57c6e73973c7f69c0fa",
    "line" : 156,
    "diffHunk" : "@@ -1,1 +118,122 @@                          val action = session.ackQueue.take()\n                          action()\n                          session.pendingAck -= 1\n                        }\n                        ackQueued()"
  },
  {
    "id" : "47c9f861-134c-4e51-a7a7-79b5b78577f5",
    "prId" : 80,
    "prUrl" : "https://github.com/akka/alpakka/pull/80#pullrequestreview-10841848",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a84672ca-9866-4ce7-a08b-a7102240d9db",
        "parentId" : null,
        "authorId" : "b8cd968d-9321-417f-8dcf-5300bfdd199e",
        "body" : "just to be nice to GC (and in case the stage is still referenced from somewhere) you could clear the queue in `postStop`",
        "createdAt" : "2016-11-30T20:53:57Z",
        "updatedAt" : "2016-12-21T17:10:57Z",
        "lastEditedBy" : "b8cd968d-9321-417f-8dcf-5300bfdd199e",
        "tags" : [
        ]
      }
    ],
    "commit" : "643e05ec750a97e40c89d4d52c8e857c86e378a8",
    "line" : null,
    "diffHunk" : "@@ -1,1 +33,37 @@\n      private val bufferSize = settings.bufferSize\n      private val queue = mutable.Queue[Message]()\n      private val backpressure = new Semaphore(bufferSize)\n"
  },
  {
    "id" : "274019a0-9a6c-4191-8871-77538fe68649",
    "prId" : 80,
    "prUrl" : "https://github.com/akka/alpakka/pull/80#pullrequestreview-10917090",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "70d2a06e-e99b-4750-bc6e-fd0adc93c0ff",
        "parentId" : null,
        "authorId" : "b8cd968d-9321-417f-8dcf-5300bfdd199e",
        "body" : "Here is another typical example where we could use something like the `Committable` in akka-stream-kafka. That is for a later PR. Makes it much more complicated, but very useful. I have created issue https://github.com/akka/alpakka/issues/104 for this.",
        "createdAt" : "2016-11-30T21:01:11Z",
        "updatedAt" : "2016-12-21T17:10:57Z",
        "lastEditedBy" : "b8cd968d-9321-417f-8dcf-5300bfdd199e",
        "tags" : [
        ]
      },
      {
        "id" : "493cb9a1-0829-445d-b57e-a660ae20c961",
        "parentId" : "70d2a06e-e99b-4750-bc6e-fd0adc93c0ff",
        "authorId" : "eab7e58f-298a-458b-a53c-f4fff6509653",
        "body" : "The `message.acknowledge()` must be called in the thread where onMessage is called. It make this really hard to implement with commitable ? ",
        "createdAt" : "2016-12-01T08:14:13Z",
        "updatedAt" : "2016-12-21T17:10:57Z",
        "lastEditedBy" : "eab7e58f-298a-458b-a53c-f4fff6509653",
        "tags" : [
        ]
      }
    ],
    "commit" : "643e05ec750a97e40c89d4d52c8e857c86e378a8",
    "line" : 66,
    "diffHunk" : "@@ -1,1 +64,68 @@                backpressure.acquire()\n                try {\n                  message.acknowledge()\n                  handleMessage.invoke(message)\n                } catch {"
  }
]
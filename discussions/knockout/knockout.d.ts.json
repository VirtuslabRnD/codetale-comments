[
  {
    "id" : "69f009d6-b3a0-4e96-af1b-0283d28d5039",
    "prId" : 2745,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f0d5a3a9-e608-4b0f-9415-0fc6ff7efa4b",
        "parentId" : null,
        "authorId" : "1e1dcea1-00d3-4083-8360-099f29168ec2",
        "body" : "`register` can also take `any` as config parameter. It's up to component loader how to interpret configuration.\n",
        "createdAt" : "2014-09-01T05:38:22Z",
        "updatedAt" : "2014-09-01T05:38:22Z",
        "lastEditedBy" : "1e1dcea1-00d3-4083-8360-099f29168ec2",
        "tags" : [
        ]
      },
      {
        "id" : "9501f969-b21a-481a-ae43-5e6042f43fa5",
        "parentId" : "f0d5a3a9-e608-4b0f-9415-0fc6ff7efa4b",
        "authorId" : "1e1dcea1-00d3-4083-8360-099f29168ec2",
        "body" : "Also, I suggest to create possible interfaces for `template` and `viewModel` properties of config separately.\nThen you can annotate `config` as inline type with all combinations of types for `template`/`viewModel`.\nI think it would be more clear, since we have no type unions in TS yet.\n",
        "createdAt" : "2014-09-01T05:43:36Z",
        "updatedAt" : "2014-09-01T05:43:36Z",
        "lastEditedBy" : "1e1dcea1-00d3-4083-8360-099f29168ec2",
        "tags" : [
        ]
      },
      {
        "id" : "415fd2f0-f354-4ba1-8c07-e4535cc0a87f",
        "parentId" : "f0d5a3a9-e608-4b0f-9415-0fc6ff7efa4b",
        "authorId" : "35122758-613f-43bf-9e36-8a2a01c201ec",
        "body" : "Not sure I know how to do that: viewModel can be a string, a function, or an object with properties - I didn't know how to represent those overloads in a single interface\n",
        "createdAt" : "2014-09-01T08:10:31Z",
        "updatedAt" : "2014-09-01T08:10:31Z",
        "lastEditedBy" : "35122758-613f-43bf-9e36-8a2a01c201ec",
        "tags" : [
        ]
      },
      {
        "id" : "3de52901-1217-4aef-8c7b-488007216a34",
        "parentId" : "f0d5a3a9-e608-4b0f-9415-0fc6ff7efa4b",
        "authorId" : "1ca557cb-9bb4-423a-b1d5-159e2bc35c32",
        "body" : "@Igorbek \n",
        "createdAt" : "2014-09-15T13:39:36Z",
        "updatedAt" : "2014-09-15T13:39:36Z",
        "lastEditedBy" : "1ca557cb-9bb4-423a-b1d5-159e2bc35c32",
        "tags" : [
        ]
      },
      {
        "id" : "d57814cc-f19a-4031-b9f1-ac45b3787111",
        "parentId" : "f0d5a3a9-e608-4b0f-9415-0fc6ff7efa4b",
        "authorId" : "1e1dcea1-00d3-4083-8360-099f29168ec2",
        "body" : "@conficient unfortunetely, you cannot do it in single interface. Need to create separate interfaces for each possible type of each property.\nFor example `template` can be `A` or `B` and `viewModel` can be `C` or `D` or `E`. So you need to create overloads like:\n\n``` ts\n...(config: { template: A; viewModel: C });\n...(config: { template: A; viewModel: D });\n...(config: { template: A; viewModel?: E });\n...(config: { template?: B; viewModel: C });\n...(config: { template?: B; viewModel: D });\n...(config: { template?: B; viewModel?: E });\n```\n",
        "createdAt" : "2014-09-16T15:11:35Z",
        "updatedAt" : "2014-09-16T15:11:35Z",
        "lastEditedBy" : "1e1dcea1-00d3-4083-8360-099f29168ec2",
        "tags" : [
        ]
      }
    ],
    "commit" : "dade09fe9d0b5205c4c2f5de9f185f64e59c701c",
    "line" : 10,
    "diffHunk" : "@@ -1,1 +562,566 @@    register(componentName: string, config: KnockoutComponentRegisterFnViewModel): void;\n    register(componentName: string, config: KnockoutComponentRegisterStringTemplateFnViewModel): void;\n    register(componentName: string, config: KnockoutComponentRegisterAMD): void;\n\n\tisRegistered(componentName: string): boolean;"
  }
]
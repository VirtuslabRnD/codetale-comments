[
  {
    "id" : "5c4a81cd-b0d0-4602-a020-717fc6fc98fc",
    "prId" : 20845,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e5c027e7-4281-4d49-9dae-a41195c800bb",
        "parentId" : null,
        "authorId" : "aefa6d0d-0ad0-4062-966c-ddc56e70652b",
        "body" : "probably add a TODO about how this can be ripped out once we have mesos native containerization support factored into a custom kubelet runtime\n",
        "createdAt" : "2016-02-09T21:51:42Z",
        "updatedAt" : "2016-02-10T19:19:11Z",
        "lastEditedBy" : "aefa6d0d-0ad0-4062-966c-ddc56e70652b",
        "tags" : [
        ]
      }
    ],
    "commit" : "fc1c43507eb3efb4c871702a220f761c21df3077",
    "line" : null,
    "diffHunk" : "@@ -1,1 +52,56 @@\n// envContainerID is the name of the environment variable that contains the\n// Mesos-assigned container ID of the Executor.\nconst envContainerID = \"MESOS_EXECUTOR_CONTAINER_UUID\"\n"
  },
  {
    "id" : "e8d14489-268a-41f2-a6b2-36fa9fe19f56",
    "prId" : 20845,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b4951643-2330-42e6-a3fd-ff036403db25",
        "parentId" : null,
        "authorId" : "aefa6d0d-0ad0-4062-966c-ddc56e70652b",
        "body" : "I do like the simplicity of this :) makes me question my motives for `PrependFilter` (which requires this class to understand podsource filters at a deeper level)\n",
        "createdAt" : "2016-02-09T21:52:57Z",
        "updatedAt" : "2016-02-10T19:19:11Z",
        "lastEditedBy" : "aefa6d0d-0ad0-4062-966c-ddc56e70652b",
        "tags" : [
        ]
      }
    ],
    "commit" : "fc1c43507eb3efb4c871702a220f761c21df3077",
    "line" : 80,
    "diffHunk" : "@@ -1,1 +233,237 @@\tif s.containerID != \"\" {\n\t\t// tag all pod containers with the containerID so that they can be properly GC'd by Mesos\n\t\tcontainerOptions = append(containerOptions, podsource.ContainerEnvOverlay([]api.EnvVar{\n\t\t\t{Name: envContainerID, Value: s.containerID},\n\t\t}))"
  },
  {
    "id" : "27afb5fd-ed57-45a0-bfe2-b5f52211a4a2",
    "prId" : 20845,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "94945962-d3b5-4b20-9568-ccd94ba90606",
        "parentId" : null,
        "authorId" : "aefa6d0d-0ad0-4062-966c-ddc56e70652b",
        "body" : "pretty sure that the `HostnameOverride` here is the same as the agent name that was being used from the `SlaveInfo` during registration. Need to double-check\n",
        "createdAt" : "2016-02-09T22:53:05Z",
        "updatedAt" : "2016-02-10T19:19:11Z",
        "lastEditedBy" : "aefa6d0d-0ad0-4062-966c-ddc56e70652b",
        "tags" : [
        ]
      }
    ],
    "commit" : "fc1c43507eb3efb4c871702a220f761c21df3077",
    "line" : 41,
    "diffHunk" : "@@ -1,1 +97,101 @@\t\t// to accomplish the same; we do this because the k8sm scheduler works differently.\n\t\tpodutil.Annotator(map[string]string{\n\t\t\tmeta.BindingHostKey: s.HostnameOverride,\n\t\t}),\n\t}"
  },
  {
    "id" : "91fd2cad-d845-4c21-be6f-b9a956364189",
    "prId" : 14260,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0a5c4ef4-ed4f-4a6c-9ee9-6f4efc79e29d",
        "parentId" : null,
        "authorId" : "aefa6d0d-0ad0-4062-966c-ddc56e70652b",
        "body" : "probably useful to write:\n\n``` go\ndriverStopped := runtime.After(func() { ... }) // via contrib/mesos/pkg/runtime\n```\n\nand then, later:\n\n``` go\nselect {\ncase <-driverStopped:\n  // driver aborted before registration complete?! should probably die here.. by returning an error\ncase <-exec.InitialRegComplete():\n  // proceed with initialization\n}\n```\n",
        "createdAt" : "2015-09-21T13:21:15Z",
        "updatedAt" : "2015-10-10T19:25:00Z",
        "lastEditedBy" : "aefa6d0d-0ad0-4062-966c-ddc56e70652b",
        "tags" : [
        ]
      }
    ],
    "commit" : "1435077820c4c3c3bd19f42f8274aa6136bc49f3",
    "line" : null,
    "diffHunk" : "@@ -1,1 +131,135 @@\n\t// start the driver\n\tgo func() {\n\t\tif _, err := driver.Run(); err != nil {\n\t\t\tlog.Fatalf(\"executor driver failed: %v\", err)"
  },
  {
    "id" : "a148a369-6457-4cce-8d12-ab5c98001826",
    "prId" : 14260,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "143d2605-ac97-4ff8-b534-383db8560d49",
        "parentId" : null,
        "authorId" : "aefa6d0d-0ad0-4062-966c-ddc56e70652b",
        "body" : "just `log.Errorf` here instead\n",
        "createdAt" : "2015-09-21T13:21:29Z",
        "updatedAt" : "2015-10-10T19:25:00Z",
        "lastEditedBy" : "aefa6d0d-0ad0-4062-966c-ddc56e70652b",
        "tags" : [
        ]
      }
    ],
    "commit" : "1435077820c4c3c3bd19f42f8274aa6136bc49f3",
    "line" : null,
    "diffHunk" : "@@ -1,1 +133,137 @@\tgo func() {\n\t\tif _, err := driver.Run(); err != nil {\n\t\t\tlog.Fatalf(\"executor driver failed: %v\", err)\n\t\t}\n\t\tlog.Info(\"executor Run completed\")"
  },
  {
    "id" : "2e7dcec1-f7ab-4c63-90cb-ffd5aef5dc5a",
    "prId" : 13036,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "893ede7a-8464-4682-9986-31c4e4372fa4",
        "parentId" : null,
        "authorId" : "aefa6d0d-0ad0-4062-966c-ddc56e70652b",
        "body" : "hostnameOverride used to contain the slave's hostname (because podtask was filling in this value based on the hostname in the offer details). this change affects the driver binding as well as the kubelet (which also consumed hostnameoverride). GetHostIP (used in PodStatusFunc) depends on this value indirectly (if i remember correctly). i'm somewhat scared of the impact here.\n",
        "createdAt" : "2015-08-24T16:41:33Z",
        "updatedAt" : "2015-10-10T09:54:34Z",
        "lastEditedBy" : "aefa6d0d-0ad0-4062-966c-ddc56e70652b",
        "tags" : [
        ]
      },
      {
        "id" : "c80fff2a-725c-4a70-b0e0-6c5a33bd62a9",
        "parentId" : "893ede7a-8464-4682-9986-31c4e4372fa4",
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "This is exactly the part where I need your critical eyes whether the restructuring broke anything ;-) I tried to avoid any behaviour change while refactoring that. But maybe I missed some implicit dependency.\n\nThis work is also a preparation for a real split of the executor and the kubelet processes. So we have to decouple those initializations.\n",
        "createdAt" : "2015-08-24T17:19:26Z",
        "updatedAt" : "2015-10-10T09:54:34Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      },
      {
        "id" : "b56f280d-8795-40c9-a2ea-f567f7a0fa04",
        "parentId" : "893ede7a-8464-4682-9986-31c4e4372fa4",
        "authorId" : "aefa6d0d-0ad0-4062-966c-ddc56e70652b",
        "body" : "the node name situation is kind of a mess. will need to carefully review\nthe current state of the kubelet code.\n\nOn Mon, Aug 24, 2015 at 1:20 PM, Dr. Stefan Schimanski <\nnotifications@github.com> wrote:\n\n> In contrib/mesos/pkg/executor/service/service.go\n> https://github.com/kubernetes/kubernetes/pull/13036#discussion_r37776231\n> :\n> \n> > -           status.Phase = kubelet.GetPhase(&pod.Spec, status.ContainerStatuses)\n> > -           hostIP, err := s.klet.GetHostIP()\n> > -           if err != nil {\n> > -               log.Errorf(\"Cannot get host IP: %v\", err)\n> > -           } else {\n> > -               status.HostIP = hostIP.String()\n> > -           }\n> > -           return status, nil\n> > -       },\n> > -       StaticPodsConfigPath: staticPodsConfigPath,\n> > -   })\n> >   +\n> > -   // initialize driver and initialize the executor with it\n> > -   dconfig := bindings.DriverConfig{\n> > -       Executor:         exec,\n> > -       HostnameOverride: s.HostnameOverride,\n> \n> This is exactly the part where I need your critical eyes whether the\n> restructuring broke anything ;-) I tried to avoid any behaviour change\n> while refactoring that. But maybe I missed some implicit dependency.\n> \n> This work is also a preparation for a real split of the executor and the\n> kubelet processes. So we have to decouple those initializations.\n> \n> —\n> Reply to this email directly or view it on GitHub\n> https://github.com/kubernetes/kubernetes/pull/13036/files#r37776231.\n",
        "createdAt" : "2015-08-24T17:55:06Z",
        "updatedAt" : "2015-10-10T09:54:34Z",
        "lastEditedBy" : "aefa6d0d-0ad0-4062-966c-ddc56e70652b",
        "tags" : [
        ]
      },
      {
        "id" : "21a75148-5b19-4444-806f-c7ea8a9d9716",
        "parentId" : "893ede7a-8464-4682-9986-31c4e4372fa4",
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "If the standalone kubelet supports `--hostname-override` I tend to remove the hostname overriding from the cloud provider again. We don't need both ways.\n",
        "createdAt" : "2015-08-24T18:08:03Z",
        "updatedAt" : "2015-10-10T09:54:34Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      },
      {
        "id" : "8fe80030-a09a-4d5b-a29f-6f4f464aee72",
        "parentId" : "893ede7a-8464-4682-9986-31c4e4372fa4",
        "authorId" : "aefa6d0d-0ad0-4062-966c-ddc56e70652b",
        "body" : "yes standalone kubelet supports hostname override.\n\nOn Mon, Aug 24, 2015 at 2:09 PM, Dr. Stefan Schimanski <\nnotifications@github.com> wrote:\n\n> In contrib/mesos/pkg/executor/service/service.go\n> https://github.com/kubernetes/kubernetes/pull/13036#discussion_r37782043\n> :\n> \n> > -           status.Phase = kubelet.GetPhase(&pod.Spec, status.ContainerStatuses)\n> > -           hostIP, err := s.klet.GetHostIP()\n> > -           if err != nil {\n> > -               log.Errorf(\"Cannot get host IP: %v\", err)\n> > -           } else {\n> > -               status.HostIP = hostIP.String()\n> > -           }\n> > -           return status, nil\n> > -       },\n> > -       StaticPodsConfigPath: staticPodsConfigPath,\n> > -   })\n> >   +\n> > -   // initialize driver and initialize the executor with it\n> > -   dconfig := bindings.DriverConfig{\n> > -       Executor:         exec,\n> > -       HostnameOverride: s.HostnameOverride,\n> \n> If the standalone kubelet supports --hostname-override I tend to remove\n> the hostname overriding from the cloud provider again. We don't need both\n> ways.\n> \n> —\n> Reply to this email directly or view it on GitHub\n> https://github.com/kubernetes/kubernetes/pull/13036/files#r37782043.\n",
        "createdAt" : "2015-08-24T18:11:22Z",
        "updatedAt" : "2015-10-10T09:54:34Z",
        "lastEditedBy" : "aefa6d0d-0ad0-4062-966c-ddc56e70652b",
        "tags" : [
        ]
      }
    ],
    "commit" : "0d8384c82034f26edfc91ac0f3363d476618217e",
    "line" : null,
    "diffHunk" : "@@ -1,1 +119,123 @@\tdconfig := bindings.DriverConfig{\n\t\tExecutor:         exec,\n\t\tHostnameOverride: s.HostnameOverride,\n\t\tBindingAddress:   s.Address,\n\t}"
  },
  {
    "id" : "40564fd3-3e3c-4860-a268-3b5a93f1fabd",
    "prId" : 13036,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "91c4cd98-3d16-44c6-8f8c-3a3a2f50ceb1",
        "parentId" : null,
        "authorId" : "aefa6d0d-0ad0-4062-966c-ddc56e70652b",
        "body" : "is this even possible? if so it's data-racy\n",
        "createdAt" : "2015-08-24T16:45:01Z",
        "updatedAt" : "2015-10-10T09:54:34Z",
        "lastEditedBy" : "aefa6d0d-0ad0-4062-966c-ddc56e70652b",
        "tags" : [
        ]
      },
      {
        "id" : "ead2f83d-cf2e-428c-9218-7e8ebab2b0c8",
        "parentId" : "91c4cd98-3d16-44c6-8f8c-3a3a2f50ceb1",
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "Good spot. We could add a lock. But maybe we have to think about how to do this when executor and kubelet processes are split. Maybe we can also use directly the apiserver client. No need to call into the kubelet.\n",
        "createdAt" : "2015-08-24T17:23:04Z",
        "updatedAt" : "2015-10-10T09:54:34Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      }
    ],
    "commit" : "0d8384c82034f26edfc91ac0f3363d476618217e",
    "line" : null,
    "diffHunk" : "@@ -1,1 +92,96 @@\t\t\tdefer s.kletLock.Unlock()\n\n\t\t\tif s.klet == nil {\n\t\t\t\treturn nil, fmt.Errorf(\"PodStatucFunc called before kubelet is initialized\")\n\t\t\t}"
  },
  {
    "id" : "b12032ff-335e-45df-998d-af6b43c0cce4",
    "prId" : 13036,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "977de811-18f0-483d-a269-811797bc10cd",
        "parentId" : null,
        "authorId" : "aefa6d0d-0ad0-4062-966c-ddc56e70652b",
        "body" : "this is more involved than the prior PodStatusFunc impl, why?\n",
        "createdAt" : "2015-09-08T14:04:28Z",
        "updatedAt" : "2015-10-10T09:54:34Z",
        "lastEditedBy" : "aefa6d0d-0ad0-4062-966c-ddc56e70652b",
        "tags" : [
        ]
      },
      {
        "id" : "6e9f1439-4867-4d36-a4b4-4007b8b1e18a",
        "parentId" : "977de811-18f0-483d-a269-811797bc10cd",
        "authorId" : "aefa6d0d-0ad0-4062-966c-ddc56e70652b",
        "body" : "nevermind, I see why\n",
        "createdAt" : "2015-09-08T14:05:39Z",
        "updatedAt" : "2015-10-10T09:54:34Z",
        "lastEditedBy" : "aefa6d0d-0ad0-4062-966c-ddc56e70652b",
        "tags" : [
        ]
      },
      {
        "id" : "b946706d-a750-43d8-b414-62c45d9b287f",
        "parentId" : "977de811-18f0-483d-a269-811797bc10cd",
        "authorId" : "aefa6d0d-0ad0-4062-966c-ddc56e70652b",
        "body" : "this still feels dirty, doing locking here because of the order of init\n",
        "createdAt" : "2015-09-08T14:06:18Z",
        "updatedAt" : "2015-10-10T09:54:34Z",
        "lastEditedBy" : "aefa6d0d-0ad0-4062-966c-ddc56e70652b",
        "tags" : [
        ]
      },
      {
        "id" : "f90a3c6b-da89-4690-b371-b5a9ee256cdf",
        "parentId" : "977de811-18f0-483d-a269-811797bc10cd",
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "It is dirty. Explicitly dirty ;-) I want to get rid of this whole callback mechanism. Why can't we just use the apiserver to get this information?\n\nMy mid-term goal is to run the executor and the kubelet without any need to synchronize their start-up sequence.\n",
        "createdAt" : "2015-09-08T14:15:01Z",
        "updatedAt" : "2015-10-10T09:54:34Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      },
      {
        "id" : "84ce1adf-ca6f-4ea1-ae70-8e485c3689f3",
        "parentId" : "977de811-18f0-483d-a269-811797bc10cd",
        "authorId" : "aefa6d0d-0ad0-4062-966c-ddc56e70652b",
        "body" : "this func is what provides information to the apiserver.\n\nOn Tue, Sep 8, 2015 at 10:15 AM, Dr. Stefan Schimanski <\nnotifications@github.com> wrote:\n\n> In contrib/mesos/pkg/executor/service/service.go\n> https://github.com/kubernetes/kubernetes/pull/13036#discussion_r38930044\n> :\n> \n> > -   execUpdates := make(chan kubelet.PodUpdate, 1)\n> > -   exec := executor.New(executor.Config{\n> > -       Updates:         execUpdates,\n> > -       APIClient:       apiclient,\n> > -       Docker:          dockerClient,\n> > -       SuicideTimeout:  s.SuicideTimeout,\n> > -       KubeletFinished: kubeletFinished,\n> > -       ShutdownAlert: func() {\n> > -           if shutdownCloser != nil {\n> > -               if e := shutdownCloser.Close(); e != nil {\n> > -                   log.Warningf(\"failed to signal shutdown to external watcher: %v\", e)\n> > -               }\n> > -           }\n> > -       },\n> > -       ExitFunc: os.Exit,\n> > -       PodStatusFunc: func(pod _api.Pod) (_api.PodStatus, error) {\n> \n> It is dirty. Explicitly dirty ;-) I want to get rid of this whole callback\n> mechanism. Why can't we just use the apiserver to get this information?\n> \n> My mid-term goal is to run the executor and the kubelet without any need\n> to synchronize their start-up sequence.\n> \n> —\n> Reply to this email directly or view it on GitHub\n> https://github.com/kubernetes/kubernetes/pull/13036/files#r38930044.\n",
        "createdAt" : "2015-09-08T15:22:28Z",
        "updatedAt" : "2015-10-10T09:54:34Z",
        "lastEditedBy" : "aefa6d0d-0ad0-4062-966c-ddc56e70652b",
        "tags" : [
        ]
      },
      {
        "id" : "99b9dd38-7e49-4d94-a0eb-7ec6dc24851b",
        "parentId" : "977de811-18f0-483d-a269-811797bc10cd",
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "Isn't the status manager not running inside the kubelet?\n",
        "createdAt" : "2015-09-08T16:39:45Z",
        "updatedAt" : "2015-10-10T09:54:34Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      },
      {
        "id" : "71e871ab-00f3-4572-bc4a-91a91a9ccf9b",
        "parentId" : "977de811-18f0-483d-a269-811797bc10cd",
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "Actually it is according to the logs: \n\n```\nstatus_manager.go:77] Starting to sync pod status with apiserver\n```\n",
        "createdAt" : "2015-09-08T16:53:05Z",
        "updatedAt" : "2015-10-10T09:54:34Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      }
    ],
    "commit" : "0d8384c82034f26edfc91ac0f3363d476618217e",
    "line" : null,
    "diffHunk" : "@@ -1,1 +88,92 @@\t\tKubeletFinished: kubeletFinished,\n\t\tExitFunc:        os.Exit,\n\t\tPodStatusFunc: func(pod *api.Pod) (*api.PodStatus, error) {\n\t\t\ts.kletLock.Lock()\n\t\t\tdefer s.kletLock.Unlock()"
  },
  {
    "id" : "93a160cf-3d2e-4b06-b067-6008059a94bb",
    "prId" : 13036,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "aeaf0187-0cb2-4270-8c2e-a59d4bdd1b0d",
        "parentId" : null,
        "authorId" : "aefa6d0d-0ad0-4062-966c-ddc56e70652b",
        "body" : "we don't want a cloud provider to be initialized. invoking the upstream Run() doesn't give us that option.\n",
        "createdAt" : "2015-09-23T14:17:07Z",
        "updatedAt" : "2015-10-10T09:54:34Z",
        "lastEditedBy" : "aefa6d0d-0ad0-4062-966c-ddc56e70652b",
        "tags" : [
        ]
      },
      {
        "id" : "c09fcff0-6d49-4f89-b00b-fbf2a038c1d2",
        "parentId" : "aeaf0187-0cb2-4270-8c2e-a59d4bdd1b0d",
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "The cloud provider is only setup if nil is passed to Run.\n",
        "createdAt" : "2015-09-23T14:18:48Z",
        "updatedAt" : "2015-10-10T09:54:34Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      },
      {
        "id" : "8b7a7bc7-6f6c-4d7c-b136-280631d07ee0",
        "parentId" : "aeaf0187-0cb2-4270-8c2e-a59d4bdd1b0d",
        "authorId" : "aefa6d0d-0ad0-4062-966c-ddc56e70652b",
        "body" : "I don't understand this comment. I see nothing in the upstream Run() that\nchecks for nil relating to cloudprovider. What am I missing?\n\nOn Wed, Sep 23, 2015 at 10:19 AM, Dr. Stefan Schimanski <\nnotifications@github.com> wrote:\n\n> In contrib/mesos/pkg/executor/service/service.go\n> https://github.com/kubernetes/kubernetes/pull/13036#discussion_r40208334\n> :\n> \n> > -   hostNetworkSources, err := kubelet.GetValidatedSources(strings.Split(s.HostNetworkSources, \",\"))\n> > -           for u := range execUpdates {\n> > -               u.Source = MESOS_CFG_SOURCE\n> > -               updates <- u\n> > -           }\n> > -       }()\n> >   +\n> > -       // create static-pods directory file source\n> > -       log.V(2).Infof(\"initializing static pods source factory, configured at path %q\", staticPodsConfigPath)\n> > -       fileSourceUpdates := kcfg.PodConfig.Channel(kubelet.FileSource)\n> > -       kconfig.NewSourceFile(staticPodsConfigPath, kcfg.HostnameOverride, kcfg.FileCheckFrequency, fileSourceUpdates)\n> >   +\n> > -       // run the kubelet, until execUpdates is closed\n> > -       err = s.KubeletServer.Run(kcfg)\n> \n> The cloud provider is only setup if nil is passed to Run.\n> \n> —\n> Reply to this email directly or view it on GitHub\n> https://github.com/kubernetes/kubernetes/pull/13036/files#r40208334.\n",
        "createdAt" : "2015-09-23T14:40:42Z",
        "updatedAt" : "2015-10-10T09:54:34Z",
        "lastEditedBy" : "aefa6d0d-0ad0-4062-966c-ddc56e70652b",
        "tags" : [
        ]
      },
      {
        "id" : "5fa4a742-84ab-4a8d-b6bf-c971a5aa525f",
        "parentId" : "aeaf0187-0cb2-4270-8c2e-a59d4bdd1b0d",
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "https://github.com/kubernetes/kubernetes/blob/master/cmd/kubelet/app/server.go#L424\n",
        "createdAt" : "2015-09-23T14:43:29Z",
        "updatedAt" : "2015-10-10T09:54:34Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      },
      {
        "id" : "01aa9300-f2d9-4693-8f3e-66542e15ca00",
        "parentId" : "aeaf0187-0cb2-4270-8c2e-a59d4bdd1b0d",
        "authorId" : "aefa6d0d-0ad0-4062-966c-ddc56e70652b",
        "body" : "ugh. was looking at older/cached code - thanks\n\nOn Wed, Sep 23, 2015 at 10:44 AM, Dr. Stefan Schimanski <\nnotifications@github.com> wrote:\n\n> In contrib/mesos/pkg/executor/service/service.go\n> https://github.com/kubernetes/kubernetes/pull/13036#discussion_r40211400\n> :\n> \n> > -   hostNetworkSources, err := kubelet.GetValidatedSources(strings.Split(s.HostNetworkSources, \",\"))\n> > -           for u := range execUpdates {\n> > -               u.Source = MESOS_CFG_SOURCE\n> > -               updates <- u\n> > -           }\n> > -       }()\n> >   +\n> > -       // create static-pods directory file source\n> > -       log.V(2).Infof(\"initializing static pods source factory, configured at path %q\", staticPodsConfigPath)\n> > -       fileSourceUpdates := kcfg.PodConfig.Channel(kubelet.FileSource)\n> > -       kconfig.NewSourceFile(staticPodsConfigPath, kcfg.HostnameOverride, kcfg.FileCheckFrequency, fileSourceUpdates)\n> >   +\n> > -       // run the kubelet, until execUpdates is closed\n> > -       err = s.KubeletServer.Run(kcfg)\n> \n> https://github.com/kubernetes/kubernetes/blob/master/cmd/kubelet/app/server.go#L424\n> \n> —\n> Reply to this email directly or view it on GitHub\n> https://github.com/kubernetes/kubernetes/pull/13036/files#r40211400.\n",
        "createdAt" : "2015-09-23T14:46:48Z",
        "updatedAt" : "2015-10-10T09:54:34Z",
        "lastEditedBy" : "aefa6d0d-0ad0-4062-966c-ddc56e70652b",
        "tags" : [
        ]
      }
    ],
    "commit" : "0d8384c82034f26edfc91ac0f3363d476618217e",
    "line" : null,
    "diffHunk" : "@@ -1,1 +202,206 @@\t\t//       that because then every kubelet instance would query the master\n\t\t//       state.json which does not scale.\n\t\terr = s.KubeletServer.Run(kcfg)\n\t}\n"
  },
  {
    "id" : "6ad75f02-f20d-44a9-a7e2-c259f0177dfd",
    "prId" : 13036,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bf8445ef-8ca9-4f6b-bd01-94b33209469a",
        "parentId" : null,
        "authorId" : "aefa6d0d-0ad0-4062-966c-ddc56e70652b",
        "body" : "I'd like to see us force-set kcfg's cloud-provider to nil\n",
        "createdAt" : "2015-10-07T19:08:16Z",
        "updatedAt" : "2015-10-10T09:54:34Z",
        "lastEditedBy" : "aefa6d0d-0ad0-4062-966c-ddc56e70652b",
        "tags" : [
        ]
      },
      {
        "id" : "875fa54c-a428-4a2a-9dad-5b560eca0265",
        "parentId" : "bf8445ef-8ca9-4f6b-bd01-94b33209469a",
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "I add a panic when it's set to fail hard and early.\n",
        "createdAt" : "2015-10-07T23:34:22Z",
        "updatedAt" : "2015-10-10T09:54:34Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      }
    ],
    "commit" : "0d8384c82034f26edfc91ac0f3363d476618217e",
    "line" : null,
    "diffHunk" : "@@ -1,1 +179,183 @@\t\t\tpanic(\"cloud provider must not be set\")\n\t\t}\n\n\t\t// create main pod source\n\t\tupdates := kcfg.PodConfig.Channel(MESOS_CFG_SOURCE)"
  },
  {
    "id" : "7793a37d-42d0-41a0-a600-ae6967b44833",
    "prId" : 13036,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6c937053-2cbd-48f7-9b6e-a2af2c358fee",
        "parentId" : null,
        "authorId" : "aefa6d0d-0ad0-4062-966c-ddc56e70652b",
        "body" : "TODO: our kubelet.Run() override also closes this chan, be careful when refactoring\n",
        "createdAt" : "2015-10-07T19:15:19Z",
        "updatedAt" : "2015-10-10T09:54:34Z",
        "lastEditedBy" : "aefa6d0d-0ad0-4062-966c-ddc56e70652b",
        "tags" : [
        ]
      },
      {
        "id" : "c915e17e-4895-4db0-bf20-85d79ed22e95",
        "parentId" : "6c937053-2cbd-48f7-9b6e-a2af2c358fee",
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "added comments on both sides.\n",
        "createdAt" : "2015-10-07T23:38:53Z",
        "updatedAt" : "2015-10-10T09:54:34Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      }
    ],
    "commit" : "0d8384c82034f26edfc91ac0f3363d476618217e",
    "line" : null,
    "diffHunk" : "@@ -1,1 +208,212 @@\t\t// close the channel here. When Run returns without error, the executorKubelet is\n\t\t// responsible to do this. If it returns with an error, we are responsible here.\n\t\tclose(kubeletDone)\n\t}\n\treturn err"
  },
  {
    "id" : "d2e96622-f0ff-49fb-86b3-dffc2276a490",
    "prId" : 13036,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c124214f-a7fc-4fb0-82c4-3f84af1ec8e6",
        "parentId" : null,
        "authorId" : "aefa6d0d-0ad0-4062-966c-ddc56e70652b",
        "body" : ":+1: \n",
        "createdAt" : "2015-10-08T16:14:07Z",
        "updatedAt" : "2015-10-10T09:54:34Z",
        "lastEditedBy" : "aefa6d0d-0ad0-4062-966c-ddc56e70652b",
        "tags" : [
        ]
      }
    ],
    "commit" : "0d8384c82034f26edfc91ac0f3363d476618217e",
    "line" : 191,
    "diffHunk" : "@@ -1,1 +177,181 @@\t\t\t// fail early and hard because having the cloud provider loaded would go unnoticed,\n\t\t\t// but break bigger cluster because accessing the state.json from every slave kills the master.\n\t\t\tpanic(\"cloud provider must not be set\")\n\t\t}\n"
  },
  {
    "id" : "f3af349e-af3f-4446-bf1b-cd3e1657b432",
    "prId" : 10049,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0f6e043a-ac44-4b51-8982-b95c08332943",
        "parentId" : null,
        "authorId" : "ef33f76a-ca59-4720-94a5-47e86994ee8d",
        "body" : "I'm not sure how this change got in here. Maybe in need of rebase?\n",
        "createdAt" : "2015-06-30T18:44:02Z",
        "updatedAt" : "2015-08-05T17:48:49Z",
        "lastEditedBy" : "ef33f76a-ca59-4720-94a5-47e86994ee8d",
        "tags" : [
        ]
      },
      {
        "id" : "4a4a21e7-93f4-40ac-bb04-721294a66758",
        "parentId" : "0f6e043a-ac44-4b51-8982-b95c08332943",
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "This is merged on master. Just rebase and skip that patch.\n",
        "createdAt" : "2015-06-30T18:49:07Z",
        "updatedAt" : "2015-08-05T17:48:49Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      }
    ],
    "commit" : "f5fa688908173704b83a17af7775d7680b015ffe",
    "line" : null,
    "diffHunk" : "@@ -1,1 +386,390 @@\t\t// Create file source only when we are called back. Otherwise, it is never marked unseen.\n\t\tfileSourceUpdates := pc.Channel(kubelet.FileSource)\n\n\t\tkconfig.NewSourceFile(staticPodsConfigPath, kc.Hostname, kc.FileCheckFrequency, fileSourceUpdates)\n\t})"
  },
  {
    "id" : "8b96664b-5cdd-4a4e-9cda-07d3ed5a08f0",
    "prId" : 9722,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "595cc32e-2dde-49a8-9dfa-d519688815f1",
        "parentId" : null,
        "authorId" : "aefa6d0d-0ad0-4062-966c-ddc56e70652b",
        "body" : ":+1: \n",
        "createdAt" : "2015-06-12T18:32:25Z",
        "updatedAt" : "2015-06-12T18:38:02Z",
        "lastEditedBy" : "aefa6d0d-0ad0-4062-966c-ddc56e70652b",
        "tags" : [
        ]
      }
    ],
    "commit" : "5896ac9e073c48b60dfbb864abd49dbd0e2b3ad7",
    "line" : 28,
    "diffHunk" : "@@ -1,1 +329,333 @@\t\tpc.SeenAllSources,\n\t\tkc.RegisterNode,\n\t\tkc.StandaloneMode,\n\t\tkc.ClusterDomain,\n\t\tnet.IP(kc.ClusterDNS),"
  },
  {
    "id" : "34dae920-60cf-414a-9ebb-9373b25fb514",
    "prId" : 9722,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e30bf1c6-550e-4a38-9764-3177654b31cc",
        "parentId" : null,
        "authorId" : "aefa6d0d-0ad0-4062-966c-ddc56e70652b",
        "body" : ":+1: \n",
        "createdAt" : "2015-06-12T19:05:39Z",
        "updatedAt" : "2015-06-12T19:05:39Z",
        "lastEditedBy" : "aefa6d0d-0ad0-4062-966c-ddc56e70652b",
        "tags" : [
        ]
      }
    ],
    "commit" : "5896ac9e073c48b60dfbb864abd49dbd0e2b3ad7",
    "line" : 20,
    "diffHunk" : "@@ -1,1 +227,231 @@\t\tMaxContainerCount:       s.MaxContainerCount,\n\t\tRegisterNode:            s.RegisterNode,\n\t\t// StandaloneMode: false\n\t\tClusterDomain:                  s.ClusterDomain,\n\t\tClusterDNS:                     s.ClusterDNS,"
  }
]
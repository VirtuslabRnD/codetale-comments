[
  {
    "id" : "3d2559af-273d-41e2-9b75-5fbdd94cd062",
    "prId" : 15775,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9e3b753a-8907-461b-ae79-43a7b42eee34",
        "parentId" : null,
        "authorId" : "aefa6d0d-0ad0-4062-966c-ddc56e70652b",
        "body" : "it'll be interesting to see how executor port resources will fit into this mold. not a problem that we have to solve here, just food for thought.\n",
        "createdAt" : "2015-11-16T14:42:55Z",
        "updatedAt" : "2015-11-23T16:27:27Z",
        "lastEditedBy" : "aefa6d0d-0ad0-4062-966c-ddc56e70652b",
        "tags" : [
        ]
      }
    ],
    "commit" : "9eae47c6e62d23b5329100aa5bdbe81457ce3e82",
    "line" : null,
    "diffHunk" : "@@ -1,1 +40,44 @@\t\tNewPodResourcesProcurement(),\n\t\tNewPortsProcurement(),\n\t\tNewExecutorResourceProcurer(prototype.GetResources(), eir),\n\t})\n}"
  },
  {
    "id" : "9c14511d-8ebe-48c4-830b-656daee152b7",
    "prId" : 15775,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f293c689-3c41-4828-bd24-32b786e1d95d",
        "parentId" : null,
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "This comment is out of date.\n",
        "createdAt" : "2015-11-17T08:39:20Z",
        "updatedAt" : "2015-11-23T16:27:27Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      },
      {
        "id" : "4f987f7b-d532-46da-8958-0f25c96c8503",
        "parentId" : "f293c689-3c41-4828-bd24-32b786e1d95d",
        "authorId" : "39a87e74-3afd-4203-9f90-c761ddc10ff7",
        "body" : "done\n",
        "createdAt" : "2015-11-18T15:02:03Z",
        "updatedAt" : "2015-11-23T16:27:27Z",
        "lastEditedBy" : "39a87e74-3afd-4203-9f90-c761ddc10ff7",
        "tags" : [
        ]
      }
    ],
    "commit" : "9eae47c6e62d23b5329100aa5bdbe81457ce3e82",
    "line" : 100,
    "diffHunk" : "@@ -1,1 +102,106 @@type AllOrNothingProcurement []Procurement\n\n// Procure runs each Procurement in the receiver list. The first Procurement func that\n// fails triggers T.Reset() and the error is returned, otherwise returns nil.\nfunc (a AllOrNothingProcurement) Procure(t *T, n *api.Node, ps *ProcureState) error {"
  },
  {
    "id" : "56120f9b-6c9a-4f29-af40-12f218a69eab",
    "prId" : 15775,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2d44dd6a-2e5a-4c65-8578-e2fcc119331f",
        "parentId" : null,
        "authorId" : "aefa6d0d-0ad0-4062-966c-ddc56e70652b",
        "body" : ":+1: docs\n",
        "createdAt" : "2015-11-20T17:23:44Z",
        "updatedAt" : "2015-11-23T16:27:27Z",
        "lastEditedBy" : "aefa6d0d-0ad0-4062-966c-ddc56e70652b",
        "tags" : [
        ]
      },
      {
        "id" : "8c94115c-294b-40c5-a096-322309a06f6c",
        "parentId" : "2d44dd6a-2e5a-4c65-8578-e2fcc119331f",
        "authorId" : "aefa6d0d-0ad0-4062-966c-ddc56e70652b",
        "body" : "should also note that `mesos.Offer.Resources` may be modified by a procurement func\n",
        "createdAt" : "2015-11-20T17:32:54Z",
        "updatedAt" : "2015-11-23T16:27:27Z",
        "lastEditedBy" : "aefa6d0d-0ad0-4062-966c-ddc56e70652b",
        "tags" : [
        ]
      }
    ],
    "commit" : "9eae47c6e62d23b5329100aa5bdbe81457ce3e82",
    "line" : null,
    "diffHunk" : "@@ -1,1 +61,65 @@//\n// In contrast T.Spec is meant not to be filled by the procurement chain\n// but rather by a final scheduler instance.\ntype Procurement interface {\n\tProcure(*T, *api.Node, *ProcureState) error"
  },
  {
    "id" : "15c4921e-7eb6-44c5-90e0-4cd892ec0774",
    "prId" : 15775,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "14210db6-6f3a-4cdc-a61e-117e53c59d86",
        "parentId" : null,
        "authorId" : "aefa6d0d-0ad0-4062-966c-ddc56e70652b",
        "body" : "interesting to note that someone in the MESOS community is working on some changes to allow a framework to request additional resources for tasks (MESOS-938). seems like something that would complement this TODO\n",
        "createdAt" : "2015-11-20T17:25:46Z",
        "updatedAt" : "2015-11-23T16:27:27Z",
        "lastEditedBy" : "aefa6d0d-0ad0-4062-966c-ddc56e70652b",
        "tags" : [
        ]
      },
      {
        "id" : "915190dc-b5f8-4f16-b8a9-f019d2c2d8ef",
        "parentId" : "14210db6-6f3a-4cdc-a61e-117e53c59d86",
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "In fact, I was just thinking about accepting offers with resources between request and limit, as a fallback. But of course something dynamic would be even better.\n",
        "createdAt" : "2015-11-21T07:52:54Z",
        "updatedAt" : "2015-11-23T16:27:27Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      }
    ],
    "commit" : "9eae47c6e62d23b5329100aa5bdbe81457ce3e82",
    "line" : null,
    "diffHunk" : "@@ -1,1 +156,160 @@func NewPodResourcesProcurement() Procurement {\n\treturn ProcurementFunc(func(t *T, _ *api.Node, ps *ProcureState) error {\n\t\t// TODO(sttts): fall back to requested resources if resource limit cannot be fulfilled by the offer\n\t\t_, limits, err := api.PodRequestsAndLimits(&t.Pod)\n\t\tif err != nil {"
  },
  {
    "id" : "88f343b1-acb0-4a95-b646-9b7e62dee9f8",
    "prId" : 13421,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "acf0077c-b080-4700-85d3-1f65cced2d0d",
        "parentId" : null,
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "Please comment AllOrNothingProcurement.\n",
        "createdAt" : "2015-09-02T11:08:28Z",
        "updatedAt" : "2015-09-04T00:52:58Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      }
    ],
    "commit" : "a1cea8dd8795d5173d4a0d0dd07bc9a41b0aafd5",
    "line" : null,
    "diffHunk" : "@@ -1,1 +50,54 @@// objectives: the failure of any Procurement in the set results in Procure failing.\n// see AllOrNothingProcurement.Procure\ntype AllOrNothingProcurement []Procurement\n\n// Procure runs each Procurement in the receiver list. The first Procurement func that"
  },
  {
    "id" : "4cedc56a-2a5b-43f1-9d3b-ef0812ac6ac5",
    "prId" : 13421,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3774143d-efcd-4007-be14-9a23a95628f7",
        "parentId" : null,
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "IMO this does not belong into the procurement. Can we move that back into the caller? It modified t.executor, not only t.spec.\n",
        "createdAt" : "2015-09-02T11:12:07Z",
        "updatedAt" : "2015-09-04T00:52:58Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      },
      {
        "id" : "52d76757-56c4-42ad-858c-e66c15a5a794",
        "parentId" : "3774143d-efcd-4007-be14-9a23a95628f7",
        "authorId" : "aefa6d0d-0ad0-4062-966c-ddc56e70652b",
        "body" : "Agree, this feels dirty. I'll see what the impact is of extacting this bit\ninto the caller.\n\nOn Wed, Sep 2, 2015 at 7:12 AM, Dr. Stefan Schimanski <\nnotifications@github.com> wrote:\n\n> In contrib/mesos/pkg/scheduler/podtask/procurement.go\n> https://github.com/kubernetes/kubernetes/pull/13421#discussion_r38520729\n> :\n> \n> > -   // the kubelet node status checker/updater is very unhappy\n> > -   const HOSTNAME_OVERRIDE_FLAG = \"--hostname-override=\"\n> > -   hostname := details.GetHostname() // required field, non-empty\n> > -   hostnameOverride := HOSTNAME_OVERRIDE_FLAG + hostname\n> >   +\n> > -   argv := t.executor.Command.Arguments\n> > -   overwrite := false\n> > -   for i, arg := range argv {\n> > -       if strings.HasPrefix(arg, HOSTNAME_OVERRIDE_FLAG) {\n> > -           overwrite = true\n> > -           argv[i] = hostnameOverride\n> > -           break\n> > -       }\n> > -   }\n> > -   if !overwrite {\n> > -       t.executor.Command.Arguments = append(argv, hostnameOverride)\n> \n> IMO this does not belong into the procurement. Can we move that back into\n> the caller? It modified t.executor, not only t.spec.\n> \n> â€”\n> Reply to this email directly or view it on GitHub\n> https://github.com/kubernetes/kubernetes/pull/13421/files#r38520729.\n",
        "createdAt" : "2015-09-02T18:58:02Z",
        "updatedAt" : "2015-09-04T00:52:58Z",
        "lastEditedBy" : "aefa6d0d-0ad0-4062-966c-ddc56e70652b",
        "tags" : [
        ]
      },
      {
        "id" : "b179cf31-6600-4d92-bd2b-5b4616e980bc",
        "parentId" : "3774143d-efcd-4007-be14-9a23a95628f7",
        "authorId" : "aefa6d0d-0ad0-4062-966c-ddc56e70652b",
        "body" : "I don't really like it in the caller either. If anything is going to manipulate the internal state of the task object, I'd rather it live in podtask\n",
        "createdAt" : "2015-09-03T01:45:09Z",
        "updatedAt" : "2015-09-04T00:52:58Z",
        "lastEditedBy" : "aefa6d0d-0ad0-4062-966c-ddc56e70652b",
        "tags" : [
        ]
      },
      {
        "id" : "e1344c20-b91d-41b0-adb9-8c89d1b9f479",
        "parentId" : "3774143d-efcd-4007-be14-9a23a95628f7",
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "This will go away with my \"decouple executor + kubelet\" patch. Then the kubelet will know from the SlaveInfo who it is.\n",
        "createdAt" : "2015-09-03T08:55:18Z",
        "updatedAt" : "2015-09-04T00:52:58Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      },
      {
        "id" : "94e57486-0fb4-4651-9704-a2d239c97a4a",
        "parentId" : "3774143d-efcd-4007-be14-9a23a95628f7",
        "authorId" : "aefa6d0d-0ad0-4062-966c-ddc56e70652b",
        "body" : "Yes, but will kube-proxy? In master they've updated kube-proxy to generate\nevents to the apiserver, and kube-proxy needs this value.\n\nOn Thu, Sep 3, 2015 at 4:56 AM, Dr. Stefan Schimanski <\nnotifications@github.com> wrote:\n\n> In contrib/mesos/pkg/scheduler/podtask/procurement.go\n> https://github.com/kubernetes/kubernetes/pull/13421#discussion_r38625087\n> :\n> \n> > -   // the kubelet node status checker/updater is very unhappy\n> > -   const HOSTNAME_OVERRIDE_FLAG = \"--hostname-override=\"\n> > -   hostname := details.GetHostname() // required field, non-empty\n> > -   hostnameOverride := HOSTNAME_OVERRIDE_FLAG + hostname\n> >   +\n> > -   argv := t.executor.Command.Arguments\n> > -   overwrite := false\n> > -   for i, arg := range argv {\n> > -       if strings.HasPrefix(arg, HOSTNAME_OVERRIDE_FLAG) {\n> > -           overwrite = true\n> > -           argv[i] = hostnameOverride\n> > -           break\n> > -       }\n> > -   }\n> > -   if !overwrite {\n> > -       t.executor.Command.Arguments = append(argv, hostnameOverride)\n> \n> This will go away with my \"decouple executor + kubelet\" patch. Then the\n> kubelet will know from the SlaveInfo who it is.\n> \n> â€”\n> Reply to this email directly or view it on GitHub\n> https://github.com/kubernetes/kubernetes/pull/13421/files#r38625087.\n",
        "createdAt" : "2015-09-03T14:22:10Z",
        "updatedAt" : "2015-09-04T00:52:58Z",
        "lastEditedBy" : "aefa6d0d-0ad0-4062-966c-ddc56e70652b",
        "tags" : [
        ]
      },
      {
        "id" : "53d92095-2e4d-4e4d-af9a-2323ee05e5ba",
        "parentId" : "3774143d-efcd-4007-be14-9a23a95628f7",
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "Why does it need it? Isn't it the same value as the hostname in the SlaveInfo?\n",
        "createdAt" : "2015-09-03T15:55:24Z",
        "updatedAt" : "2015-09-04T00:52:58Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      },
      {
        "id" : "18c324cf-1ef3-48d6-bad0-d3713f5198ce",
        "parentId" : "3774143d-efcd-4007-be14-9a23a95628f7",
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "Which is connected to the question how to get the SlaveInfo hostname and other info to the minion to start kube-proxy and later the kubelet...\n",
        "createdAt" : "2015-09-03T15:56:26Z",
        "updatedAt" : "2015-09-04T00:52:58Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      },
      {
        "id" : "e9a91cbd-ffe2-46e7-bb34-ac6426241b8e",
        "parentId" : "3774143d-efcd-4007-be14-9a23a95628f7",
        "authorId" : "aefa6d0d-0ad0-4062-966c-ddc56e70652b",
        "body" : "kube-proxy probably needs to use the same hostname as the kubelet when reporting events. i don't know what happens if it doesn't, other than probably confusing an operator looking at the event logs\n",
        "createdAt" : "2015-09-04T01:00:22Z",
        "updatedAt" : "2015-09-04T01:00:22Z",
        "lastEditedBy" : "aefa6d0d-0ad0-4062-966c-ddc56e70652b",
        "tags" : [
        ]
      }
    ],
    "commit" : "a1cea8dd8795d5173d4a0d0dd07bc9a41b0aafd5",
    "line" : 99,
    "diffHunk" : "@@ -1,1 +97,101 @@\t}\n\tif !overwrite {\n\t\tt.executor.Command.Arguments = append(argv, hostnameOverride)\n\t}\n\treturn nil"
  },
  {
    "id" : "17b8436d-9ff6-4584-a2f5-4e26523bf241",
    "prId" : 13421,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6a4cab06-308d-4161-8c65-52e1a5bf0385",
        "parentId" : null,
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "this is also a change outside of t.spec. Not sure I like it here.\n\nWe could create a deep copy of t.Pod in t.Spec to clean this up.\n",
        "createdAt" : "2015-09-02T11:15:06Z",
        "updatedAt" : "2015-09-04T00:52:58Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      },
      {
        "id" : "580f48cd-6129-4767-ac96-4ceb2ef7da44",
        "parentId" : "6a4cab06-308d-4161-8c65-52e1a5bf0385",
        "authorId" : "aefa6d0d-0ad0-4062-966c-ddc56e70652b",
        "body" : "Agree, but I think we should do that in a follow-up PR. I suspect such a\nchange will lead to unintended breakage and will require additional effort\nthat I don't think we should take on here. I'll add a TODO stating that we\nshould refactor this.\n\nOn Wed, Sep 2, 2015 at 7:15 AM, Dr. Stefan Schimanski <\nnotifications@github.com> wrote:\n\n> In contrib/mesos/pkg/scheduler/podtask/procurement.go\n> https://github.com/kubernetes/kubernetes/pull/13421#discussion_r38520916\n> :\n> \n> > -   if !overwrite {\n> > -       t.executor.Command.Arguments = append(argv, hostnameOverride)\n> > -   }\n> > -   return nil\n> >   +}\n> >   +\n> >   +type RequireSomePodResources struct {\n> > -   defaultContainerCPULimit mresource.CPUShares\n> > -   defaultContainerMemLimit mresource.MegaBytes\n> >   +}\n> >   +\n> >   +func (r *RequireSomePodResources) Procure(t *T, details *mesos.Offer) error {\n> > -   // write resource limits into the pod spec which is transferred to the executor. From here\n> > -   // on we can expect that the pod spec of a task has proper limits for CPU and memory.\n> > -   // TODO(sttts): For a later separation of the kubelet and the executor also patch the pod on the apiserver\n> > -   if unlimitedCPU := mresource.LimitPodCPU(&t.Pod, r.defaultContainerCPULimit); unlimitedCPU {\n> \n> this is also a change outside of t.spec. Not sure I like it here.\n> \n> We could create a deep copy of t.Pod in t.Spec to clean this up.\n> \n> â€”\n> Reply to this email directly or view it on GitHub\n> https://github.com/kubernetes/kubernetes/pull/13421/files#r38520916.\n",
        "createdAt" : "2015-09-02T18:57:07Z",
        "updatedAt" : "2015-09-04T00:52:58Z",
        "lastEditedBy" : "aefa6d0d-0ad0-4062-966c-ddc56e70652b",
        "tags" : [
        ]
      }
    ],
    "commit" : "a1cea8dd8795d5173d4a0d0dd07bc9a41b0aafd5",
    "line" : null,
    "diffHunk" : "@@ -1,1 +113,117 @@\t// TODO(jdef): changing the state of t.Pod here feels dirty, especially since we don't use a kosher\n\t// method to clone the api.Pod state in T.Clone(). This needs some love.\n\tif unlimitedCPU := mresource.LimitPodCPU(&t.Pod, r.defaultContainerCPULimit); unlimitedCPU {\n\t\tlog.Warningf(\"Pod %s/%s without cpu limits is admitted %.2f cpu shares\", t.Pod.Namespace, t.Pod.Name, mresource.PodCPULimit(&t.Pod))\n\t}"
  }
]
[
  {
    "id" : "eca32a76-2634-4e5e-b187-767a7651165d",
    "prId" : 1216,
    "prUrl" : "https://github.com/scala-native/scala-native/pull/1216#pullrequestreview-136154516",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f9a569f5-70b7-4bf5-9b98-5366884cdb2a",
        "parentId" : null,
        "authorId" : "0f96d83b-618e-4d06-9aeb-e1d46fa92077",
        "body" : "Do these cached values play well with file attributes changing? i.e. what happens if file changes after the attributes where read and then the attribute info is requested later? ",
        "createdAt" : "2018-07-10T14:56:38Z",
        "updatedAt" : "2018-07-11T03:55:40Z",
        "lastEditedBy" : "0f96d83b-618e-4d06-9aeb-e1d46fa92077",
        "tags" : [
        ]
      },
      {
        "id" : "b91b250b-28f3-4e82-9c97-0fdd1585f8d2",
        "parentId" : "f9a569f5-70b7-4bf5-9b98-5366884cdb2a",
        "authorId" : "a79847b3-f184-4eed-a75a-998c93d1ae98",
        "body" : "The updated semantics should be the same as on the jvm. It isn't clear from the javadoc, but when you call `Files.readAttributes`, you get a snapshot of the file attributes at the moment that the sys call to stat is invoked. For example, I ran this in the console:\r\n```\r\nscala> import java.nio.file._\r\nimport java.nio.file._\r\n\r\nscala> val dir = Files.createTempDirectory(\"foo\")\r\ndir: java.nio.file.Path = /var/folders/7q/s3vq91lx3zv9fw4l5l5c43nr0000gn/T/foo5386655488881479548\r\n\r\nscala> val dirAttrs = Files.readAttributes(dir, classOf[attribute.BasicFileAttributes])\r\ndirAttrs: java.nio.file.attribute.BasicFileAttributes = sun.nio.fs.UnixFileAttributes$UnixAsBasicFileAttributes@1856eae9\r\n\r\nscala> Files.delete(dir)\r\n\r\nscala> Files.createFile(dir)\r\nres1: java.nio.file.Path = /var/folders/7q/s3vq91lx3zv9fw4l5l5c43nr0000gn/T/foo5386655488881479548\r\n\r\nscala> val attrs = Files.readAttributes(dir, classOf[attribute.BasicFileAttributes])\r\nattrs: java.nio.file.attribute.BasicFileAttributes = sun.nio.fs.UnixFileAttributes$UnixAsBasicFileAttributes@285bb22a\r\n\r\nscala> attrs.isRegularFile\r\nres2: Boolean = true\r\n\r\nscala> attrs.isDirectory\r\nres3: Boolean = false\r\n\r\nscala> dirAttrs.isRegularFile\r\nres4: Boolean = false\r\n\r\nscala> dirAttrs.isDirectory\r\nres5: Boolean = true\r\n```",
        "createdAt" : "2018-07-10T23:20:50Z",
        "updatedAt" : "2018-07-11T03:55:40Z",
        "lastEditedBy" : "a79847b3-f184-4eed-a75a-998c93d1ae98",
        "tags" : [
        ]
      },
      {
        "id" : "dff431bd-0bd5-4622-b1db-98d85c833bba",
        "parentId" : "f9a569f5-70b7-4bf5-9b98-5366884cdb2a",
        "authorId" : "0f96d83b-618e-4d06-9aeb-e1d46fa92077",
        "body" : "Good point, it's all good then.",
        "createdAt" : "2018-07-11T09:17:24Z",
        "updatedAt" : "2018-07-11T09:17:24Z",
        "lastEditedBy" : "0f96d83b-618e-4d06-9aeb-e1d46fa92077",
        "tags" : [
        ]
      }
    ],
    "commit" : "d48d6c1ac16cc6f8fcae6346a3df87725038b6e9",
    "line" : 82,
    "diffHunk" : "@@ -1,1 +81,85 @@      private[this] var st_blksize: stat.blksize_t = _\n      private[this] var st_nlink: stat.nlink_t     = _\n      private[this] var st_mode: stat.mode_t       = _\n\n      Zone { implicit z =>"
  },
  {
    "id" : "e9a7af40-53f8-4814-98d3-ebf8e7929a7a",
    "prId" : 733,
    "prUrl" : "https://github.com/scala-native/scala-native/pull/733#pullrequestreview-40239912",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0a6fc729-4bc1-4837-917a-86c283f2da93",
        "parentId" : null,
        "authorId" : "8ea77260-a6ff-49da-9900-245920bdc998",
        "body" : "Any reason why you want to re-retrieve the `stat` struct for each query on an attribute?",
        "createdAt" : "2017-05-25T08:55:45Z",
        "updatedAt" : "2017-05-25T08:55:54Z",
        "lastEditedBy" : "8ea77260-a6ff-49da-9900-245920bdc998",
        "tags" : [
        ]
      },
      {
        "id" : "a8c9d292-bb96-4204-b842-c23679036ad2",
        "parentId" : "0a6fc729-4bc1-4837-917a-86c283f2da93",
        "authorId" : "0f96d83b-618e-4d06-9aeb-e1d46fa92077",
        "body" : "If you cache unmanaged pointer in a managed object, then you'll need to clean it up only when object itself is unreachable (i.e. garbaged collected.) On JVM you can use finalizers for that, but we don't support them at the moment, hence no caching.",
        "createdAt" : "2017-05-25T08:58:04Z",
        "updatedAt" : "2017-05-25T08:58:04Z",
        "lastEditedBy" : "0f96d83b-618e-4d06-9aeb-e1d46fa92077",
        "tags" : [
        ]
      },
      {
        "id" : "8d61a42e-c9d7-41da-a203-a7e62d42eb80",
        "parentId" : "0a6fc729-4bc1-4837-917a-86c283f2da93",
        "authorId" : "8ea77260-a6ff-49da-9900-245920bdc998",
        "body" : "Thanks for the clarifications!",
        "createdAt" : "2017-05-25T09:13:04Z",
        "updatedAt" : "2017-05-25T09:13:04Z",
        "lastEditedBy" : "8ea77260-a6ff-49da-9900-245920bdc998",
        "tags" : [
        ]
      }
    ],
    "commit" : "9fefd28ad484aac63a3e7739f3f816aad0de8820",
    "line" : 100,
    "diffHunk" : "@@ -1,1 +71,75 @@    new PosixFileAttributes {\n      private def fileStat()(implicit z: Zone) =\n        getStat()\n\n      private def fileMode()(implicit z: Zone) ="
  }
]
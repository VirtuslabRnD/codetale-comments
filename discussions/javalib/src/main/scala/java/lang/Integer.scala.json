[
  {
    "id" : "5e08a28c-8a05-40d5-a0a8-ee915f9bd513",
    "prId" : 2270,
    "prUrl" : "https://github.com/scala-native/scala-native/pull/2270#pullrequestreview-644554078",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f686b0b9-9a1e-43f1-9d93-2378b6c1f974",
        "parentId" : null,
        "authorId" : "f4f243c6-89af-4952-a717-72ea9d628eb2",
        "body" : "We were producing an error for `decode(\"+1324\")` when that's a valid input",
        "createdAt" : "2021-04-26T11:21:04Z",
        "updatedAt" : "2021-04-28T01:03:45Z",
        "lastEditedBy" : "f4f243c6-89af-4952-a717-72ea9d628eb2",
        "tags" : [
        ]
      }
    ],
    "commit" : "4d9063039f4d7d0e983efef9c043e3a16a5c7c85",
    "line" : 21,
    "diffHunk" : "@@ -1,1 +222,226 @@    val positive = first == '+'\n\n    if (negative || positive) {\n      if (length == 1) fail(nm)\n      i += 1"
  },
  {
    "id" : "0a54af26-5528-45df-bf38-46e6b986d0c2",
    "prId" : 2270,
    "prUrl" : "https://github.com/scala-native/scala-native/pull/2270#pullrequestreview-644554524",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "cc33dbb4-8663-4188-9e3c-b3ed78594fea",
        "parentId" : null,
        "authorId" : "f4f243c6-89af-4952-a717-72ea9d628eb2",
        "body" : "Break downs in the different type of errors",
        "createdAt" : "2021-04-26T11:21:39Z",
        "updatedAt" : "2021-04-28T01:03:45Z",
        "lastEditedBy" : "f4f243c6-89af-4952-a717-72ea9d628eb2",
        "tags" : [
        ]
      }
    ],
    "commit" : "4d9063039f4d7d0e983efef9c043e3a16a5c7c85",
    "line" : 58,
    "diffHunk" : "@@ -1,1 +311,315 @@    if (radix > Character.MAX_RADIX)\n      throw new NumberFormatException(\n        s\"radix $radix greater than Character.MAX_RADIX\")\n\n    val length = s.length()"
  },
  {
    "id" : "3bcc6ea1-2249-497d-99a8-255a27aa3247",
    "prId" : 346,
    "prUrl" : "https://github.com/scala-native/scala-native/pull/346#pullrequestreview-5346387",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bb9d6e35-a574-470f-811f-ea379311c8d3",
        "parentId" : null,
        "authorId" : "ae189121-dea4-445f-87d0-303740ceff41",
        "body" : "One test case for you: `Integer.parseUnsignedInt(\"4294967296\")`. It should fail with `NumberFormatException`, but currently this will succeed and return 0. That's because the (unsigned) addition overflows.\nYou need to test that, after the addition of `digit`, `result` is not smaller than `digit` (which would signal an overflow during the addition):\n\n``` scala\nif (compareUnsigned(result, digit) < 0) throw new NumberFormatException(s)\n```\n",
        "createdAt" : "2016-10-22T09:37:04Z",
        "updatedAt" : "2016-10-24T20:17:08Z",
        "lastEditedBy" : "ae189121-dea4-445f-87d0-303740ceff41",
        "tags" : [
        ]
      }
    ],
    "commit" : "447905ab4bcdb07c44fb14c6049d8537c1120295",
    "line" : null,
    "diffHunk" : "@@ -1,1 +490,494 @@      if (compareUnsigned(digit, result) > 0)\n        throw new NumberFormatException(s)\n    }\n\n    result"
  },
  {
    "id" : "45080c5b-f9f0-478e-9cac-7a519a943078",
    "prId" : 238,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e5535d15-78ad-4a09-83f7-146f8a28ea67",
        "parentId" : null,
        "authorId" : "0f96d83b-618e-4d06-9aeb-e1d46fa92077",
        "body" : "This one can become branchless if we introduce `select` intrinsic.\n",
        "createdAt" : "2016-07-11T14:59:56Z",
        "updatedAt" : "2016-07-13T11:57:13Z",
        "lastEditedBy" : "0f96d83b-618e-4d06-9aeb-e1d46fa92077",
        "tags" : [
        ]
      },
      {
        "id" : "f93be15d-bd51-446a-bb77-96370dd6e014",
        "parentId" : "e5535d15-78ad-4a09-83f7-146f8a28ea67",
        "authorId" : "0f96d83b-618e-4d06-9aeb-e1d46fa92077",
        "body" : "Done.\n",
        "createdAt" : "2016-07-11T15:44:17Z",
        "updatedAt" : "2016-07-13T11:57:13Z",
        "lastEditedBy" : "0f96d83b-618e-4d06-9aeb-e1d46fa92077",
        "tags" : [
        ]
      }
    ],
    "commit" : "2a694216a42c5461c756b55a54fbad96343674b4",
    "line" : null,
    "diffHunk" : "@@ -1,1 +175,179 @@    value\n\n  @inline def highestOneBit(i: scala.Int): scala.Int =\n    select(i == 0, 0, (1 << 31) >>> numberOfLeadingZeros(i))\n"
  },
  {
    "id" : "48dcbe36-2026-4811-9bb2-a30c7dffaffa",
    "prId" : 238,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6bcfbbc2-b18d-4425-a9d9-7477caf21059",
        "parentId" : null,
        "authorId" : "ae189121-dea4-445f-87d0-303740ceff41",
        "body" : "I'm not sure whether you want to keep the complete semantics of the JDK. The JDK mandates that values from -128 to 127 be cached. (Same for `Byte`, `Short` and `Long`, IIRC).\n\nIt would probably be good for GC pressure as well, in the case of SN.\n",
        "createdAt" : "2016-07-11T15:20:57Z",
        "updatedAt" : "2016-07-13T11:57:13Z",
        "lastEditedBy" : "ae189121-dea4-445f-87d0-303740ceff41",
        "tags" : [
        ]
      },
      {
        "id" : "76581053-0f8f-4da0-bba2-11d8bd41f1c5",
        "parentId" : "6bcfbbc2-b18d-4425-a9d9-7477caf21059",
        "authorId" : "ae189121-dea4-445f-87d0-303740ceff41",
        "body" : "From https://docs.oracle.com/javase/7/docs/api/java/lang/Integer.html#valueOf(int)\n\n> This method will always cache values in the range -128 to 127, inclusive, and may cache other values outside of this range.\n",
        "createdAt" : "2016-07-11T15:21:38Z",
        "updatedAt" : "2016-07-13T11:57:13Z",
        "lastEditedBy" : "ae189121-dea4-445f-87d0-303740ceff41",
        "tags" : [
        ]
      },
      {
        "id" : "b2561adb-4801-4632-8464-64d313293687",
        "parentId" : "6bcfbbc2-b18d-4425-a9d9-7477caf21059",
        "authorId" : "7f86f120-7838-4bea-9217-738bb0d42f82",
        "body" : "A minor note: the range of values to cache is specified by undocumented option `-XX:AutoBoxCacheMax` \n",
        "createdAt" : "2016-07-11T15:32:31Z",
        "updatedAt" : "2016-07-13T11:57:13Z",
        "lastEditedBy" : "7f86f120-7838-4bea-9217-738bb0d42f82",
        "tags" : [
        ]
      },
      {
        "id" : "29a4a050-eb2d-4e31-922d-de5204b17179",
        "parentId" : "6bcfbbc2-b18d-4425-a9d9-7477caf21059",
        "authorId" : "0f96d83b-618e-4d06-9aeb-e1d46fa92077",
        "body" : "I think that SMI optimisation is the real solution to this performance-wise. We can pack most primitive values into pointers with tagging. This makes 90%+ of all boxing not to allocate at all and also is compliant with JVM caching semantics for -128 to 127 range of numbers. The only issue that stands in our way to do this is interaction of pointer packing with GC. \n",
        "createdAt" : "2016-07-12T12:31:39Z",
        "updatedAt" : "2016-07-13T11:57:13Z",
        "lastEditedBy" : "0f96d83b-618e-4d06-9aeb-e1d46fa92077",
        "tags" : [
        ]
      }
    ],
    "commit" : "2a694216a42c5461c756b55a54fbad96343674b4",
    "line" : 589,
    "diffHunk" : "@@ -1,1 +478,482 @@\n  @inline def valueOf(i: scala.Int): Integer =\n    new Integer(i)\n\n  @inline def valueOf(s: String): Integer ="
  }
]
[
  {
    "id" : "dc5c56a4-0692-4d42-b031-5e43015cea53",
    "prId" : 2487,
    "prUrl" : "https://github.com/root-project/root/pull/2487#pullrequestreview-149334519",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "96aa30be-e925-48b9-baff-5f071137a39b",
        "parentId" : null,
        "authorId" : "09b7e073-cbeb-42e8-aa22-8b1468de56ae",
        "body" : "I don't understand that pattern. Is this asserting that `~TWebWindowManagerGuard()` is releasing not more than what has been locked? I don't think that's needed? Maybe use an atomic in the manager itself, and assert in there that the amount of connections stays positive?",
        "createdAt" : "2018-08-23T22:08:44Z",
        "updatedAt" : "2018-08-24T14:54:18Z",
        "lastEditedBy" : "09b7e073-cbeb-42e8-aa22-8b1468de56ae",
        "tags" : [
        ]
      },
      {
        "id" : "74805802-e9d6-462f-8163-3aee7135d64d",
        "parentId" : "96aa30be-e925-48b9-baff-5f071137a39b",
        "authorId" : "e4571402-a12a-4377-8cca-960e88b81e3d",
        "body" : "It is same story with booked mutex I explained before.\r\nHere is just extra check for some fatal error, which should never happens",
        "createdAt" : "2018-08-24T14:46:56Z",
        "updatedAt" : "2018-08-24T14:54:19Z",
        "lastEditedBy" : "e4571402-a12a-4377-8cca-960e88b81e3d",
        "tags" : [
        ]
      }
    ],
    "commit" : "4b80ffa0b0dc5c64fd2f792943e625c8f88d201a",
    "line" : 60,
    "diffHunk" : "@@ -1,1 +75,79 @@      {\n         std::lock_guard<std::mutex> grd(fMgr.fMutex);\n         if (!fMgr.fMutexBooked) {\n            R__ERROR_HERE(\"WebDisplay\") << \"fMutexBooked counter is empty - fatal error\";\n         } else {"
  },
  {
    "id" : "a0cfe823-367f-4748-97f0-25856e9bbc98",
    "prId" : 2487,
    "prUrl" : "https://github.com/root-project/root/pull/2487#pullrequestreview-149336238",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6ef7b38c-bc5a-435a-a10f-8cb05836159b",
        "parentId" : null,
        "authorId" : "09b7e073-cbeb-42e8-aa22-8b1468de56ae",
        "body" : "Can this static be put inside a function, please? That reduces sequencing issues of static initialization.",
        "createdAt" : "2018-08-23T22:12:58Z",
        "updatedAt" : "2018-08-24T14:54:19Z",
        "lastEditedBy" : "09b7e073-cbeb-42e8-aa22-8b1468de56ae",
        "tags" : [
        ]
      },
      {
        "id" : "387aa534-024a-4621-acdd-ab94527f265c",
        "parentId" : "6ef7b38c-bc5a-435a-a10f-8cb05836159b",
        "authorId" : "e4571402-a12a-4377-8cca-960e88b81e3d",
        "body" : "This I mentioned before - it is just workaround, which I would like to be solved by ROOT.\r\nBut in current form I really want to have initialization at the moment when library is loaded - I see no other way to \"ping\" main thread ",
        "createdAt" : "2018-08-24T14:51:07Z",
        "updatedAt" : "2018-08-24T14:54:19Z",
        "lastEditedBy" : "e4571402-a12a-4377-8cca-960e88b81e3d",
        "tags" : [
        ]
      }
    ],
    "commit" : "4b80ffa0b0dc5c64fd2f792943e625c8f88d201a",
    "line" : 87,
    "diffHunk" : "@@ -1,1 +116,120 @@/// Main thread can only make sense if special processing runs there and one can inject own functionality there\n\nstatic std::thread::id gWebWinMainThrd = std::this_thread::get_id();\n\n//////////////////////////////////////////////////////////////////////////////////////////"
  }
]
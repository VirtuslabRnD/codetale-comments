[
  {
    "id" : "bda1926b-daa3-46c7-845d-437ea054a0ce",
    "prId" : 13552,
    "prUrl" : "https://github.com/DefinitelyTyped/DefinitelyTyped/pull/13552#pullrequestreview-14691939",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "96c70c8f-3b21-4c78-846b-8822e490801e",
        "parentId" : null,
        "authorId" : "3869aabd-5b54-4208-bd58-934576e71b3a",
        "body" : "An empty interface is equivalent to `{}`.",
        "createdAt" : "2016-12-28T22:50:31Z",
        "updatedAt" : "2017-01-04T22:50:34Z",
        "lastEditedBy" : "3869aabd-5b54-4208-bd58-934576e71b3a",
        "tags" : [
        ]
      },
      {
        "id" : "535f6ae2-fdc4-4bf0-8678-1ef792957120",
        "parentId" : "96c70c8f-3b21-4c78-846b-8822e490801e",
        "authorId" : "ad36a973-efe6-4227-b39a-ea25498327eb",
        "body" : "Well, yes and no :-) It seems like a bit more context is needed here.\r\n\r\nTo notify a `Listener` of different phases in the test scenario lifecycle, Cucumber emits events which contain a field of \"type\" `EventPayload`, which value you can retrieve via the `getEventPayload(name)` method on the `Event` object. Regretfully, those different types of payloads have nothing in common API-wise, only the fact that they're passed as part of the event. \r\n\r\nI used the marker interface to:\r\n- satisfy the signature to `Event::getPayloadItem(name: string): EventPayload` \r\n- highlight that the method can return all those different kinds of events\r\n\r\nAn alternative approach would be to define the method signature as returning `any`, remove the marker interface and disassociate the payloads from each other since they don't have anything in common design-wise, but I didn't find it convincing. I could be missing other alternatives though so I'm open to suggestions!\r\n\r\nThe nice thing about having both the method signature and the payloads typed though is that you can define a listener like this:\r\n\r\n```typescript\r\n\r\nlet listener = Object.assign(cucumber.Listener(), {\r\n    handleBeforeScenarioEvent,\r\n    // ...\r\n});\r\n\r\nfunction handleBeforeScenarioEvent (scenario: cucumber.events.ScenarioPayload, callback: () => void) {\r\n    \r\n    // stuff\r\n\r\n    callback();\r\n}\r\n```",
        "createdAt" : "2016-12-28T23:58:32Z",
        "updatedAt" : "2017-01-04T22:50:34Z",
        "lastEditedBy" : "ad36a973-efe6-4227-b39a-ea25498327eb",
        "tags" : [
        ]
      },
      {
        "id" : "12734f7d-daf6-4bd6-bece-e900f1069949",
        "parentId" : "96c70c8f-3b21-4c78-846b-8822e490801e",
        "authorId" : "3869aabd-5b54-4208-bd58-934576e71b3a",
        "body" : "Could you provide an example of using the `EventPayload` type?\r\nTo clarify, an empty interface really is equivalent to `{}` and doesn't \"mark\" anything. So `const foo: EventPayload = 0;` would compile without error.\r\nIf you need to specify that only the things you've designated here as `EventPayload`s qualify, you could use a union type: `type EventPayload = FeaturesPayload | FeatueresResultPayload | ... | StepResultPayload`.",
        "createdAt" : "2016-12-29T15:54:35Z",
        "updatedAt" : "2017-01-04T22:50:34Z",
        "lastEditedBy" : "3869aabd-5b54-4208-bd58-934576e71b3a",
        "tags" : [
        ]
      },
      {
        "id" : "b3e2bac9-8c15-4b8b-8785-6a928b9c64da",
        "parentId" : "96c70c8f-3b21-4c78-846b-8822e490801e",
        "authorId" : "ad36a973-efe6-4227-b39a-ea25498327eb",
        "body" : "Ah yes, that's a good point. A union type might actually work better here, thanks for your suggestion. I'll update the PR tonight.",
        "createdAt" : "2016-12-29T17:42:48Z",
        "updatedAt" : "2017-01-04T22:50:34Z",
        "lastEditedBy" : "ad36a973-efe6-4227-b39a-ea25498327eb",
        "tags" : [
        ]
      }
    ],
    "commit" : "c033ddcde58758e10594f45cc78c931d8e09da7a",
    "line" : 33,
    "diffHunk" : "@@ -1,1 +92,96 @@\t\t}\n\n\t\tinterface EventPayload {\n\t\t}\n"
  }
]
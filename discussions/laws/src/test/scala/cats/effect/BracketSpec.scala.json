[
  {
    "id" : "e0bf9199-cd1a-4edd-9e95-2def0009e9ee",
    "prId" : 894,
    "prUrl" : "https://github.com/typelevel/cats-effect/pull/894#pullrequestreview-433399017",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "45c9ba7d-4226-43b8-9d98-7385079406a7",
        "parentId" : null,
        "authorId" : "3b5d55eb-40d5-4d14-a8a4-3ed1601b5bff",
        "body" : "Is there more coming for an inductive `EitherT` instance?",
        "createdAt" : "2020-06-18T03:57:54Z",
        "updatedAt" : "2020-06-18T03:57:55Z",
        "lastEditedBy" : "3b5d55eb-40d5-4d14-a8a4-3ed1601b5bff",
        "tags" : [
        ]
      },
      {
        "id" : "50dc1e3f-0cbf-433c-98b9-351ea5c1496d",
        "parentId" : "45c9ba7d-4226-43b8-9d98-7385079406a7",
        "authorId" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "body" : "At present, this is just a demonstration of what's possible. Further inductive instances will definitely be added.\r\n\r\nAs an aside, there are some problems with this approach. For example:\r\n\r\n```scala\r\ndef foo[F[_], E, A](fa: F[A])(implicit F: Bracket[F, E]) =\r\n  Bracket[OptionT[F, *], E].onCase(fa) { \r\n    case cs => ???\r\n  }\r\n\r\ndef bar[F[_], E, A](fa: F[A])(implicit F: ConcurrentBracket[F, E]) =\r\n  Bracket[OptionT[F, *], E].onCase(fa) { \r\n    case cs => ???\r\n  }\r\n```\r\n\r\nThe types of `cs` in `foo` and `bar` are not even remotely related. In `foo`, `cs` will have type `OptionT[F.Case, A]`, while in `bar`, `cs` will have type `Outcome[OptionT[F, *], E, A]`. I'm trying to decide whether or not users will be confused by this.",
        "createdAt" : "2020-06-18T14:48:26Z",
        "updatedAt" : "2020-06-18T14:48:26Z",
        "lastEditedBy" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "tags" : [
        ]
      },
      {
        "id" : "5dfb5e50-d0a1-4e16-bfdb-f45ac7928cf0",
        "parentId" : "45c9ba7d-4226-43b8-9d98-7385079406a7",
        "authorId" : "3b5d55eb-40d5-4d14-a8a4-3ed1601b5bff",
        "body" : "Interesting. Past comprehension, it's still possible for `F[_]` to be cancelled, even if you only have a `Bracket` class instance in scope, right? It seems like `Bracket` wouldn't let you *observe* cancellation, but it can still happen.",
        "createdAt" : "2020-06-18T15:13:55Z",
        "updatedAt" : "2020-06-18T15:13:55Z",
        "lastEditedBy" : "3b5d55eb-40d5-4d14-a8a4-3ed1601b5bff",
        "tags" : [
        ]
      },
      {
        "id" : "d2607fb6-4723-4ac8-8381-15f10b6d6a79",
        "parentId" : "45c9ba7d-4226-43b8-9d98-7385079406a7",
        "authorId" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "body" : "> It seems like Bracket wouldn't let you observe cancellation, but it can still happen.\r\n\r\nActually it'll still let you observe cancelation, it's just going to get wrapped up a bit differently. So to be clear, the `F.Case` existential type constructor is actually `Outcome[F, E, A]` if we assume that `foo` and `bar` can be called from the same call-site. So it's basically up to the type signatures to figure out whether or not you want the capability to observe cancelation *and* usefully act on it.\r\n\r\nSo specifically, you can constrain `Case` to be something:\r\n\r\n```scala\r\ndef foo[F[_], C[_], E, A](fa: F[A])(implicit F: Bracket.Aux[F, E, C], C: ApplicativeError[C, E]) = ???\r\n```\r\n\r\nOkay, that's a bit of a gimme, since that same `ApplicativeError` instance will be available from `F.CaseInstance`, but you can further constrain things if you really want to. Like, for example:\r\n\r\n```scala\r\ndef foo[F[_], C[_], E, A](fa: F[A])(implicit F: Bracket.Aux[F, E, C], C: ApplicativeError[C, E], filter: FunctorFilter[C]) = ???\r\n```\r\n\r\nNow `C` is very likely to characterize something a lot like `Outcome`, though we can't necessarily *observe* it since we have no way of extracting cases, given these signatures, but you see where I'm going with this. Basically, if you need to be able to do something with cancelation *specifically* in the body of `foo` (as opposed to just responding generically to an opaque existential `Case`), then you need to define what `Case` is in the constraints.",
        "createdAt" : "2020-06-18T15:27:18Z",
        "updatedAt" : "2020-06-18T15:27:18Z",
        "lastEditedBy" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "tags" : [
        ]
      }
    ],
    "commit" : "4e2a07aaf980cf93a8aa77dfc6d45db36e485b2c",
    "line" : 36,
    "diffHunk" : "@@ -1,1 +34,38 @@  checkAll(\n    \"OptionT[Either[Int, *], *]\",\n    BracketTests[OptionT[Either[Int, *], *], Int].bracket[Int, Int, Int])\n}"
  }
]
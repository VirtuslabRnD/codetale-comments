[
  {
    "id" : "a1da7382-c3c8-42a6-a39b-49db9340542f",
    "prId" : 2279,
    "prUrl" : "https://github.com/typelevel/cats/pull/2279#pullrequestreview-137566643",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3e8709a6-d130-4a6e-bea2-5a0802c763a0",
        "parentId" : null,
        "authorId" : "7e3d5e72-6b63-4e9d-8d2b-da0bc51b173c",
        "body" : "Unsuspended vars in laws make me feel uneasy. First of all I fear that such laws will not have a long life.\r\n\r\nTo fix it, you can defer the whole thing:\r\n```scala\r\n  def deferDoesNotEvaluate[A](f: Boolean => F[A]): IsEq[Boolean] = {\r\n    val lh = F.defer {\r\n      var evaluated = false\r\n      F.defer {\r\n        evaluated = true\r\n        f(evaluated)\r\n      }\r\n      f(evaluated)\r\n    }\r\n    lh <-> f(false)\r\n  }\r\n```",
        "createdAt" : "2018-06-25T12:45:32Z",
        "updatedAt" : "2018-07-20T17:35:12Z",
        "lastEditedBy" : "7e3d5e72-6b63-4e9d-8d2b-da0bc51b173c",
        "tags" : [
        ]
      },
      {
        "id" : "bd7ddc34-568a-43e2-a145-f9ae6aa8e9fc",
        "parentId" : "3e8709a6-d130-4a6e-bea2-5a0802c763a0",
        "authorId" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "body" : "I‚Äôm nervous that if you pass a function that ignores the Boolean this is true trivially.",
        "createdAt" : "2018-07-16T19:39:06Z",
        "updatedAt" : "2018-07-20T17:35:12Z",
        "lastEditedBy" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "tags" : [
        ]
      }
    ],
    "commit" : "c86ece02a70e937379efa1432c4cd08f6e0f63ca",
    "line" : 15,
    "diffHunk" : "@@ -1,1 +13,17 @@\n  def deferDoesNotEvaluate[A](fa: Unit => F[A]): IsEq[Boolean] = {\n    var evaluated = false\n    val deferUnit = F.defer {\n      evaluated = true;"
  },
  {
    "id" : "22e4fe0d-2abe-4e7c-97a5-2caedd41a187",
    "prId" : 2279,
    "prUrl" : "https://github.com/typelevel/cats/pull/2279#pullrequestreview-132295810",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6f857221-38ac-48a1-94fd-949bff82e454",
        "parentId" : null,
        "authorId" : "7e3d5e72-6b63-4e9d-8d2b-da0bc51b173c",
        "body" : "This law is interesting, but in case an `F[_]` provides such a powerful `defer`, what about the behavior of `flatMap`? Shouldn't `flatMap` also be stack safe if `defer` is?\r\n\r\nAlso the question on my mind would be: is `defer` any relevant without a `Monad` restriction? Or in other words, do we have any data type that can implement `Defer`, but not `Monad`?\r\n\r\nNote that we also have a `StackSafeMonad`.",
        "createdAt" : "2018-06-25T12:47:40Z",
        "updatedAt" : "2018-07-20T17:35:12Z",
        "lastEditedBy" : "7e3d5e72-6b63-4e9d-8d2b-da0bc51b173c",
        "tags" : [
        ]
      },
      {
        "id" : "6e9a0bdc-2015-415f-850b-a767d95e43e1",
        "parentId" : "6f857221-38ac-48a1-94fd-949bff82e454",
        "authorId" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "body" : "That's a good question about making the law stronger: if there is a monad, flatMap must be stack safe. The function cases wouldn't pass this law.\r\n\r\nAs to what might not be a monad: command line parsing is often done with an applicative, not a monad (see optparse-applicative library in haskell or https://github.com/bkirwi/decline for a cats version). Those types can still have a lawful Defer.",
        "createdAt" : "2018-06-26T18:39:04Z",
        "updatedAt" : "2018-07-20T17:35:12Z",
        "lastEditedBy" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "tags" : [
        ]
      },
      {
        "id" : "80a29929-5ba0-470d-899c-987c2f7c3a4c",
        "parentId" : "6f857221-38ac-48a1-94fd-949bff82e454",
        "authorId" : "7e3d5e72-6b63-4e9d-8d2b-da0bc51b173c",
        "body" : "If we have `Applicative` examples without a Monad definition, I guess that's fine üëç",
        "createdAt" : "2018-06-27T06:13:18Z",
        "updatedAt" : "2018-07-20T17:35:12Z",
        "lastEditedBy" : "7e3d5e72-6b63-4e9d-8d2b-da0bc51b173c",
        "tags" : [
        ]
      }
    ],
    "commit" : "c86ece02a70e937379efa1432c4cd08f6e0f63ca",
    "line" : 26,
    "diffHunk" : "@@ -1,1 +24,28 @@    def loop(c: Int): F[A] =\n      if (c <= 0) F.defer(fa(()))\n      else F.defer(loop(c - 1))\n\n    val cnt = if (Platform.isJvm) 20000 else 2000"
  },
  {
    "id" : "61ab63d7-5906-46c3-93c1-bd31164f42e4",
    "prId" : 2279,
    "prUrl" : "https://github.com/typelevel/cats/pull/2279#pullrequestreview-137566264",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a9da8283-63a6-42d0-899f-fe8c9d5500e0",
        "parentId" : null,
        "authorId" : "7e3d5e72-6b63-4e9d-8d2b-da0bc51b173c",
        "body" : "In my experience these arbitrary values hurt for `F[_]` data types that have an expensive `flatMap`, for example streaming data types, because you're not talking of a single event being emitted, but multiple ones, per `flatMap`. \r\n\r\nIn Cats-Effect what I did was to introduce an `iterations: Int` in `SyncLaws` (see [sample](https://github.com/typelevel/cats-effect/blob/master/laws/shared/src/main/scala/cats/effect/laws/SyncLaws.scala#L134)) and an implicit `Parameters` in `SyncTests` (see [definition](https://github.com/typelevel/cats-effect/blob/master/laws/shared/src/main/scala/cats/effect/laws/discipline/Parameters.scala#L43) and [usage](https://github.com/typelevel/cats-effect/blob/master/laws/shared/src/main/scala/cats/effect/laws/discipline/SyncTests.scala#L76)). Otherwise those tests would choke for Monix's `Iterant` for example, especially when executed on Travis.\r\n\r\nAnd in absence of that, I'd use smaller values:\r\n\r\n```scala\r\nval cnt = if (Platform.isJvm) 10000 else 1000\r\n```",
        "createdAt" : "2018-06-25T12:52:53Z",
        "updatedAt" : "2018-07-20T17:35:12Z",
        "lastEditedBy" : "7e3d5e72-6b63-4e9d-8d2b-da0bc51b173c",
        "tags" : [
        ]
      },
      {
        "id" : "2ddf35e2-b422-4eb0-bd48-0a7ec77db3b1",
        "parentId" : "a9da8283-63a6-42d0-899f-fe8c9d5500e0",
        "authorId" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "body" : "I don‚Äôt see a compelling reason why this is only 2x too large. Can you give an idea?",
        "createdAt" : "2018-07-16T19:37:55Z",
        "updatedAt" : "2018-07-20T17:35:12Z",
        "lastEditedBy" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "tags" : [
        ]
      }
    ],
    "commit" : "c86ece02a70e937379efa1432c4cd08f6e0f63ca",
    "line" : 28,
    "diffHunk" : "@@ -1,1 +26,30 @@      else F.defer(loop(c - 1))\n\n    val cnt = if (Platform.isJvm) 20000 else 2000\n    loop(cnt) <-> (fa(()))\n  }"
  }
]
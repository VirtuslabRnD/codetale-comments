[
  {
    "id" : "bbe21dc1-90f2-4b9d-9798-e8bd040f451d",
    "prId" : 555,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b6c0ab5b-b3f3-4889-8a52-7585282d8bba",
        "parentId" : null,
        "authorId" : "1b80f00c-b2ed-49b7-8651-8be183b8980a",
        "body" : "Can we define the left/right identity and associativity laws here, but instead of returning `IsEq[X]`, return a tuple, because the first and second elements will have different but isomorphic types?  For example, the left identity law would return a `(F[(Unit, A)], F[A])`. This stresses that this type class is not lawless, even if we need some type of functor in order to do the equality check for most `F`s.\n",
        "createdAt" : "2015-11-11T00:21:52Z",
        "updatedAt" : "2015-12-10T20:21:51Z",
        "lastEditedBy" : "1b80f00c-b2ed-49b7-8651-8be183b8980a",
        "tags" : [
        ]
      },
      {
        "id" : "f8a308b7-23cc-4cfa-ba6e-efb46e822f86",
        "parentId" : "b6c0ab5b-b3f3-4889-8a52-7585282d8bba",
        "authorId" : "1b80f00c-b2ed-49b7-8651-8be183b8980a",
        "body" : "We'd then bind these laws in `InvariantTests`, using the `Invariant[F]` instance.\n",
        "createdAt" : "2015-11-11T00:29:16Z",
        "updatedAt" : "2015-12-10T20:21:51Z",
        "lastEditedBy" : "1b80f00c-b2ed-49b7-8651-8be183b8980a",
        "tags" : [
        ]
      }
    ],
    "commit" : "9e84c04114f03d36c14367442ee0f4f6f3dfa8d2",
    "line" : null,
    "diffHunk" : "@@ -1,1 +2,6 @@package laws\n\ntrait MonoidalLaws[F[_]] {\n\n  implicit def F: Monoidal[F]"
  }
]
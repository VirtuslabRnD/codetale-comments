[
  {
    "id" : "1309536e-b15e-4e58-8f2d-15c96d8c7f79",
    "prId" : 2371,
    "prUrl" : "https://github.com/typelevel/cats/pull/2371#pullrequestreview-146504566",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4c26e4eb-cfff-4be2-8eaf-61ddf2453158",
        "parentId" : null,
        "authorId" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "body" : "I don’t know what the fromSeq is doing here because we are just folding it. I don’t love this generator because it does not generate any internal Wrap nodes and is always left associated.\r\n\r\nCould we do something like: for size n we either wrap a seq or create a two random chains of size a and b such that a + b == n and we combine those.\r\n\r\nIf we do this, I think we can get the coverage up nice and high.",
        "createdAt" : "2018-08-15T16:08:43Z",
        "updatedAt" : "2018-08-15T16:09:20Z",
        "lastEditedBy" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "tags" : [
        ]
      }
    ],
    "commit" : "bc66361dd5beee411a76a437f98de66adbb99d83",
    "line" : 10,
    "diffHunk" : "@@ -1,1 +283,287 @@      case 2 => A.arbitrary.flatMap(a1 => A.arbitrary.flatMap(a2 =>\n        Chain.concat(Chain.one(a1), Chain.one(a2))))\n      case n => Chain.fromSeq(Range.apply(0, n)).foldLeft(Gen.const(Chain.empty[A])) { (gen, _) =>\n        gen.flatMap(cat => A.arbitrary.map(a => cat :+ a))\n      }"
  },
  {
    "id" : "1f7f0f3f-acf7-4202-b151-71e6b7e58f43",
    "prId" : 1878,
    "prUrl" : "https://github.com/typelevel/cats/pull/1878#pullrequestreview-60132912",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "18e946be-c177-47ed-a7cd-81e45132061d",
        "parentId" : null,
        "authorId" : "6b760ef7-e448-44a7-b744-0c25c840a80a",
        "body" : "👍  this makes a lot more sense ",
        "createdAt" : "2017-09-01T13:22:02Z",
        "updatedAt" : "2017-09-01T18:48:15Z",
        "lastEditedBy" : "6b760ef7-e448-44a7-b744-0c25c840a80a",
        "tags" : [
        ]
      }
    ],
    "commit" : "adcb06be7e8dd252d3e4eefd725a25b83d28b64e",
    "line" : 23,
    "diffHunk" : "@@ -1,1 +147,151 @@\n  implicit def catsLawsArbitraryForPartialOrder[A: Arbitrary]: Arbitrary[PartialOrder[A]] =\n    Arbitrary(getArbitrary[Int => Double].map(f => new PartialOrder[A] {\n      def partialCompare(x: A, y: A): Double =\n        if (x.## == y.##) 0.0 else f(x.##) - f(y.##)"
  },
  {
    "id" : "9f7890ba-32f1-40d2-b4b8-9b526392a976",
    "prId" : 1345,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "07ad6a1e-4fb3-426c-ae44-0edc2203c714",
        "parentId" : null,
        "authorId" : "b714495a-5740-47d4-aaaa-98f354f5c0a7",
        "body" : "A lot of these instances also look like they are defined in scalacheck. Same question as https://github.com/typelevel/cats/pull/1345/files#r77895807\n",
        "createdAt" : "2016-09-07T20:23:17Z",
        "updatedAt" : "2016-09-08T01:52:31Z",
        "lastEditedBy" : "b714495a-5740-47d4-aaaa-98f354f5c0a7",
        "tags" : [
        ]
      },
      {
        "id" : "1970e294-08f5-47dc-a441-383c0cadbfd4",
        "parentId" : "07ad6a1e-4fb3-426c-ae44-0edc2203c714",
        "authorId" : "89a3e0e3-e301-4aa8-b150-74070eb5a619",
        "body" : "@ceedubs I'll go back through and see which ones I can delete (it's possible some of these are only in ScalaCheck's _master_).\n",
        "createdAt" : "2016-09-07T20:50:07Z",
        "updatedAt" : "2016-09-08T01:52:31Z",
        "lastEditedBy" : "89a3e0e3-e301-4aa8-b150-74070eb5a619",
        "tags" : [
        ]
      }
    ],
    "commit" : "91fdbbfa7f98cfe9b283df993805af07d06e5e6e",
    "line" : null,
    "diffHunk" : "@@ -1,1 +30,34 @@  // remove this once a newer version is available.\n  implicit def catsLawsCogenForFunction0[A](implicit A: Cogen[A]): Cogen[Function0[A]] =\n    A.contramap(_())\n\n  implicit def catsLawsArbitraryForConst[A, B](implicit A: Arbitrary[A]): Arbitrary[Const[A, B]] ="
  }
]
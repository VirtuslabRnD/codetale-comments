[
  {
    "id" : "9d56cfac-0e40-4d51-b581-ca8b925c477e",
    "prId" : 3241,
    "prUrl" : "https://github.com/typelevel/cats/pull/3241#pullrequestreview-342063308",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fad7f98f-05e8-4f5d-9ccf-dc19531c567e",
        "parentId" : null,
        "authorId" : "c922a9b6-a191-4a1d-b6d1-67a1b509a11b",
        "body" : "Another way might be `Arbitrary[F[_]].map(_.attempt)`... But that's probably problematic in other ways (depending on the behavior of attempt)",
        "createdAt" : "2020-01-12T21:39:57Z",
        "updatedAt" : "2020-01-12T21:39:57Z",
        "lastEditedBy" : "c922a9b6-a191-4a1d-b6d1-67a1b509a11b",
        "tags" : [
        ]
      },
      {
        "id" : "aa60ddca-526e-4e71-8c84-e826cedcac33",
        "parentId" : "fad7f98f-05e8-4f5d-9ccf-dc19531c567e",
        "authorId" : "9e8a6a6c-6f4e-49b4-ab87-ee2c5ced7e78",
        "body" : "Well, the problem is then you need a function `E => A`. That's not doable without breaking binary compatibility.",
        "createdAt" : "2020-01-12T21:53:53Z",
        "updatedAt" : "2020-01-12T21:53:53Z",
        "lastEditedBy" : "9e8a6a6c-6f4e-49b4-ab87-ee2c5ced7e78",
        "tags" : [
        ]
      },
      {
        "id" : "ea45b7c0-5648-4bef-b055-d88386ae1c9b",
        "parentId" : "fad7f98f-05e8-4f5d-9ccf-dc19531c567e",
        "authorId" : "c922a9b6-a191-4a1d-b6d1-67a1b509a11b",
        "body" : "Why binary compatibility? I fail to see that here...",
        "createdAt" : "2020-01-13T08:41:08Z",
        "updatedAt" : "2020-01-13T08:41:08Z",
        "lastEditedBy" : "c922a9b6-a191-4a1d-b6d1-67a1b509a11b",
        "tags" : [
        ]
      },
      {
        "id" : "1cee03e4-029d-421d-b3aa-680c2783cd38",
        "parentId" : "fad7f98f-05e8-4f5d-9ccf-dc19531c567e",
        "authorId" : "9e8a6a6c-6f4e-49b4-ab87-ee2c5ced7e78",
        "body" : "In order to have an `Arbitrary[E => A]`, we need a `Cogen[E]` and an `Arbitrary[A]`. We have the former, but not the latter (in `ApplicativeErrorTests`). In order to *get* the latter, we would need to add it as a parameter to the `applicativeError` function, which breaks binary compatibility.",
        "createdAt" : "2020-01-13T18:52:39Z",
        "updatedAt" : "2020-01-13T18:52:39Z",
        "lastEditedBy" : "9e8a6a6c-6f4e-49b4-ab87-ee2c5ced7e78",
        "tags" : [
        ]
      },
      {
        "id" : "7e537c23-9f75-4b67-a54d-fdfbd1aeeb25",
        "parentId" : "fad7f98f-05e8-4f5d-9ccf-dc19531c567e",
        "authorId" : "c922a9b6-a191-4a1d-b6d1-67a1b509a11b",
        "body" : "Ohhh. Yeah, you're absolutely right.",
        "createdAt" : "2020-01-13T18:54:49Z",
        "updatedAt" : "2020-01-13T18:54:49Z",
        "lastEditedBy" : "c922a9b6-a191-4a1d-b6d1-67a1b509a11b",
        "tags" : [
        ]
      }
    ],
    "commit" : "9d5542ff914783ce28a1f770f1c3059217dcd2cd",
    "line" : 8,
    "diffHunk" : "@@ -1,1 +59,63 @@   * These laws, taken together with applicativeErrorHandle, show that errors dominate in\n   * ap, *and* show that handle has lexical semantics over ap. F.unit is used in both laws\n   * because we don't have another way of expressing \"an F[_] which does *not* contain any\n   * errors\". We could make these laws considerably stronger if such a thing were\n   * expressible. Specifically, what we're missing here is the ability to say that"
  }
]
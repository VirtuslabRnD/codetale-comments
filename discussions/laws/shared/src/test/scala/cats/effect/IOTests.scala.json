[
  {
    "id" : "f7340be3-a875-4c9d-96c2-1c36b9914eee",
    "prId" : 706,
    "prUrl" : "https://github.com/typelevel/cats-effect/pull/706#pullrequestreview-335660888",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "097dc52a-9708-4244-ae48-f5342721cd8a",
        "parentId" : null,
        "authorId" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "body" : "Is this something which should be codified by laws?",
        "createdAt" : "2019-12-06T17:59:07Z",
        "updatedAt" : "2019-12-06T17:59:21Z",
        "lastEditedBy" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "tags" : [
        ]
      },
      {
        "id" : "d5978782-face-4d3d-9653-4991c7f03502",
        "parentId" : "097dc52a-9708-4244-ae48-f5342721cd8a",
        "authorId" : "a680c99b-0d47-47f6-a175-cad1562111ac",
        "body" : "I'm not sure what's the criteria but I came up with this: (fails before the change)\r\n\r\n```scala\r\n  def bracketUseDoesNotEvaluateOnCancel(implicit EQ: Eq[F[(Boolean, Boolean)]]) = {\r\n    var use = false\r\n    var release = false\r\n\r\n    val fa: F[(Boolean, Boolean)] = for {\r\n      pa <- Deferred[F, Unit]\r\n      pb <- Deferred[F, Unit]\r\n      pc <- Deferred[F, Unit]\r\n      task = F.bracket(pa.complete(()) >> pb.get)(_ => F.delay { use = true})(_ => F.delay { release = true } >> pc.complete(()))\r\n      fiber <- F.start(task)\r\n      _ <- pa.get\r\n      _ <- F.start(fiber.cancel)\r\n      _ <- pb.complete(())\r\n      _ <- pc.get\r\n\r\n    } yield (use, release)\r\n\r\n    EQ.eqv(fa, F.pure((false, true)))\r\n  }\r\n```\r\n\r\nIt is not a property based test so I return `Boolean` and then wrap it in `Prop`:\r\n```scala\r\n\"use of bracket is not evaluated when cancel is called during acquire\" -> Prop(laws.bracketUseDoesNotEvaluateOnCancel)\r\n```",
        "createdAt" : "2019-12-13T09:24:51Z",
        "updatedAt" : "2019-12-13T09:24:52Z",
        "lastEditedBy" : "a680c99b-0d47-47f6-a175-cad1562111ac",
        "tags" : [
        ]
      },
      {
        "id" : "61bf6732-bc8d-4d7e-83a5-6ea97d4fac12",
        "parentId" : "097dc52a-9708-4244-ae48-f5342721cd8a",
        "authorId" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "body" : "Meh. We'll revisit this in CE3. :-) It has better mechanisms for expressing this type of thing deterministically.",
        "createdAt" : "2019-12-22T17:21:31Z",
        "updatedAt" : "2019-12-22T17:21:31Z",
        "lastEditedBy" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "tags" : [
        ]
      }
    ],
    "commit" : "c554dfe4d207dde7a2cf2970c8e664ec09f6eeb7",
    "line" : 22,
    "diffHunk" : "@@ -1,1 +770,774 @@    use shouldBe false\n    release shouldBe true\n  }\n\n  test(\"unsafeRunSync works for IO.cancelBoundary\") {"
  },
  {
    "id" : "2566776a-ef01-41b4-82f6-68b4484d1326",
    "prId" : 31,
    "prUrl" : "https://github.com/typelevel/cats-effect/pull/31#pullrequestreview-34636514",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1b3075b0-3b46-4879-bd00-35f4fa01bb85",
        "parentId" : null,
        "authorId" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "body" : "ðŸ‘ ",
        "createdAt" : "2017-04-25T17:44:40Z",
        "updatedAt" : "2017-04-26T05:41:10Z",
        "lastEditedBy" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "tags" : [
        ]
      }
    ],
    "commit" : "086b311bf4489d1b201f2bdf4111e30c5a7389ae",
    "line" : 48,
    "diffHunk" : "@@ -1,1 +195,199 @@  testAsync(\"IO.async does not break referential transparency\") { implicit ec =>\n    val io = IO.async[Int](_(Right(10)))\n    val sum = for (a <- io; b <- io; c <- io) yield a + b + c\n    val f = sum.unsafeToFuture()\n"
  }
]
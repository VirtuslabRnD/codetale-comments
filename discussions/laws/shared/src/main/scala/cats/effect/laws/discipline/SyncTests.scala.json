[
  {
    "id" : "c2bcd452-7bed-4116-96bb-89c930837b3d",
    "prId" : 69,
    "prUrl" : "https://github.com/typelevel/cats-effect/pull/69#pullrequestreview-53216694",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3e8e0173-9e47-474c-94bb-27353c385cc1",
        "parentId" : null,
        "authorId" : "efc45bfc-463c-4c9e-946d-ad472fabc9f0",
        "body" : "Running stack safety tests on top of Javascript is still valuable and what I'd do here is to use a different count, e.g. 1000 instead of 10000 binds.\r\n\r\nThis is because we might end up with projects implementing `Sync` that don't care about the JVM at all.",
        "createdAt" : "2017-06-24T08:43:49Z",
        "updatedAt" : "2017-06-24T08:44:43Z",
        "lastEditedBy" : "efc45bfc-463c-4c9e-946d-ad472fabc9f0",
        "tags" : [
        ]
      },
      {
        "id" : "b9966de7-9de4-4e1d-981a-b7d3d940878f",
        "parentId" : "3e8e0173-9e47-474c-94bb-27353c385cc1",
        "authorId" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "body" : "What would be the best way to empirically determine the appropriate count?",
        "createdAt" : "2017-06-26T20:24:23Z",
        "updatedAt" : "2017-06-26T20:24:23Z",
        "lastEditedBy" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "tags" : [
        ]
      },
      {
        "id" : "ec2999bc-9b2e-4bb5-9943-1137367fe2b9",
        "parentId" : "3e8e0173-9e47-474c-94bb-27353c385cc1",
        "authorId" : "efc45bfc-463c-4c9e-946d-ad472fabc9f0",
        "body" : "I have no idea; basically you pick a value, then see if the tests run in a reasonable amount of time for `cats.effect.IO`.",
        "createdAt" : "2017-06-26T20:40:09Z",
        "updatedAt" : "2017-06-26T20:40:10Z",
        "lastEditedBy" : "efc45bfc-463c-4c9e-946d-ad472fabc9f0",
        "tags" : [
        ]
      },
      {
        "id" : "18a7aae9-e343-4c5f-adf7-6d54999e80ce",
        "parentId" : "3e8e0173-9e47-474c-94bb-27353c385cc1",
        "authorId" : "efc45bfc-463c-4c9e-946d-ad472fabc9f0",
        "body" : "I would set it to 1000. It's better than nothing and should be manageable on top of Node.js",
        "createdAt" : "2017-06-26T20:40:49Z",
        "updatedAt" : "2017-06-26T20:40:49Z",
        "lastEditedBy" : "efc45bfc-463c-4c9e-946d-ad472fabc9f0",
        "tags" : [
        ]
      },
      {
        "id" : "353985d4-28cc-4f1a-83d6-26ac83d32293",
        "parentId" : "3e8e0173-9e47-474c-94bb-27353c385cc1",
        "authorId" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "body" : "In the interest of not stalling this on the petard of my lack of time, I'm going to merge this PR and open a new issue for reenabling the stack safety tests on JS with lower limits.",
        "createdAt" : "2017-07-07T09:13:10Z",
        "updatedAt" : "2017-07-07T09:13:10Z",
        "lastEditedBy" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "tags" : [
        ]
      },
      {
        "id" : "498de11f-7c48-4b14-b993-f0e0e094c8d3",
        "parentId" : "3e8e0173-9e47-474c-94bb-27353c385cc1",
        "authorId" : "144dd9dd-1563-4a99-bb87-1693310f43dd",
        "body" : "The threshold for stack-safety is in my experience closer to 70000 function compositions than 10000, let alone 1000. That's what every cats stack-safety test uses. Does this test fail as is with a stack-unsafe monad?",
        "createdAt" : "2017-07-29T20:53:44Z",
        "updatedAt" : "2017-07-29T20:53:44Z",
        "lastEditedBy" : "144dd9dd-1563-4a99-bb87-1693310f43dd",
        "tags" : [
        ]
      },
      {
        "id" : "aa7d932e-23c5-4849-845b-d69c6061709a",
        "parentId" : "3e8e0173-9e47-474c-94bb-27353c385cc1",
        "authorId" : "efc45bfc-463c-4c9e-946d-ad472fabc9f0",
        "body" : "I've seen tests fail for a stack depth of 1000, because it's usually multiplied by whatever else you're doing for each of those frames.\r\n\r\nBut indeed the number is chosen arbitrarily.\r\n\r\nWe should do a quick / simple Thunk-based implementation and measure with that.",
        "createdAt" : "2017-07-30T15:19:17Z",
        "updatedAt" : "2017-07-30T15:19:17Z",
        "lastEditedBy" : "efc45bfc-463c-4c9e-946d-ad472fabc9f0",
        "tags" : [
        ]
      },
      {
        "id" : "9c4cf7bb-3b0f-4b93-883b-4898e8013c78",
        "parentId" : "3e8e0173-9e47-474c-94bb-27353c385cc1",
        "authorId" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "body" : "@edmundnoble It does fail as it is with a stack-unsafe monad.  I think it's just because there are more stack frames floating around.  Or maybe it's just because my machine is allocating less stack space.  Either way, it did seem to be pretty consistent when I was playing with it.",
        "createdAt" : "2017-07-30T23:34:23Z",
        "updatedAt" : "2017-07-30T23:34:23Z",
        "lastEditedBy" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "tags" : [
        ]
      },
      {
        "id" : "fd8d6514-0e9c-4ab7-bec5-a57fc71e59c5",
        "parentId" : "3e8e0173-9e47-474c-94bb-27353c385cc1",
        "authorId" : "144dd9dd-1563-4a99-bb87-1693310f43dd",
        "body" : "Alright nice, thanks :) I bet we could cut it down for cats too.",
        "createdAt" : "2017-07-31T13:29:22Z",
        "updatedAt" : "2017-07-31T13:29:22Z",
        "lastEditedBy" : "144dd9dd-1563-4a99-bb87-1693310f43dd",
        "tags" : [
        ]
      }
    ],
    "commit" : "09e64a7d932a8a1372cdf0f9fa1543ce7ccd965e",
    "line" : 33,
    "diffHunk" : "@@ -1,1 +66,70 @@        \"propagate errors through bind (suspend)\" -> forAll(laws.propagateErrorsThroughBindSuspend[A] _))\n\n      val jvmProps = Seq(\n        \"stack-safe on left-associated binds\" -> Prop.lzy(laws.stackSafetyOnRepeatedLeftBinds),\n        \"stack-safe on right-associated binds\" -> Prop.lzy(laws.stackSafetyOnRepeatedRightBinds),"
  }
]
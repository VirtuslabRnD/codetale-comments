[
  {
    "id" : "375ad349-c52b-4938-88be-5b8032bd83d0",
    "prId" : 36,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e199a2bd-92f1-41cd-85bf-43d70fc43e8c",
        "parentId" : null,
        "authorId" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "body" : "do we need the `Or` suffix on these names given they are namespaced by the `Or` object already?\n",
        "createdAt" : "2015-02-02T19:21:30Z",
        "updatedAt" : "2015-02-04T22:16:06Z",
        "lastEditedBy" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "tags" : [
        ]
      },
      {
        "id" : "037f423c-0c12-4d41-9a7a-9402a2ba222b",
        "parentId" : "e199a2bd-92f1-41cd-85bf-43d70fc43e8c",
        "authorId" : "841f9474-2dfc-46b8-9cfa-77b23455116a",
        "body" : "It is convenient when the name of the class is unique when you use auto import\n",
        "createdAt" : "2015-02-02T19:32:16Z",
        "updatedAt" : "2015-02-04T22:16:06Z",
        "lastEditedBy" : "841f9474-2dfc-46b8-9cfa-77b23455116a",
        "tags" : [
        ]
      },
      {
        "id" : "afc07edb-c942-4b36-ab25-40fb1fa1bd0c",
        "parentId" : "e199a2bd-92f1-41cd-85bf-43d70fc43e8c",
        "authorId" : "8106957f-b999-418b-b22b-14067e9a3932",
        "body" : "Agree. It's really easy to run into trouble when you're shadowing names that are already in scope by default. Common point of bafflement in `#scala` for people in the Coursera course, which has exercises to implement `List` and `Set`.\n",
        "createdAt" : "2015-02-02T19:39:52Z",
        "updatedAt" : "2015-02-04T22:16:06Z",
        "lastEditedBy" : "8106957f-b999-418b-b22b-14067e9a3932",
        "tags" : [
        ]
      }
    ],
    "commit" : "bb26aeee5fa5721668c155f934010ee928d40ec1",
    "line" : null,
    "diffHunk" : "@@ -1,1 +107,111 @@\nobject Or extends OrInstances with OrFunctions {\n  final case class LeftOr[+A](a: A) extends (A Or Nothing)\n\n  final case class RightOr[+B](b: B) extends (Nothing Or B)"
  },
  {
    "id" : "74e062a1-4a9d-40df-805b-33b22b6ddc0a",
    "prId" : 36,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5180be49-1511-41a8-83a6-003c89637afa",
        "parentId" : null,
        "authorId" : "841f9474-2dfc-46b8-9cfa-77b23455116a",
        "body" : "shall we implement it in terms of fold like most of the other methods?\n",
        "createdAt" : "2015-02-03T08:29:38Z",
        "updatedAt" : "2015-02-04T22:16:06Z",
        "lastEditedBy" : "841f9474-2dfc-46b8-9cfa-77b23455116a",
        "tags" : [
        ]
      },
      {
        "id" : "4913f36d-357e-4e13-9f27-3205cb5844fd",
        "parentId" : "5180be49-1511-41a8-83a6-003c89637afa",
        "authorId" : "2ed5d687-cc94-4d72-ba74-717be38944e9",
        "body" : "This saves an allocation by passing `left` through instead unwrapping and rewrapping `a`.  I microbenchmarked a small difference.\n",
        "createdAt" : "2015-02-03T16:31:31Z",
        "updatedAt" : "2015-02-04T22:16:06Z",
        "lastEditedBy" : "2ed5d687-cc94-4d72-ba74-717be38944e9",
        "tags" : [
        ]
      },
      {
        "id" : "13651a1d-b25c-4fa9-bfc3-d388f2154798",
        "parentId" : "5180be49-1511-41a8-83a6-003c89637afa",
        "authorId" : "841f9474-2dfc-46b8-9cfa-77b23455116a",
        "body" : "good point, shall we do the same for filter as we return `this` in one of the branch?\n",
        "createdAt" : "2015-02-03T16:33:34Z",
        "updatedAt" : "2015-02-04T22:16:06Z",
        "lastEditedBy" : "841f9474-2dfc-46b8-9cfa-77b23455116a",
        "tags" : [
        ]
      }
    ],
    "commit" : "bb26aeee5fa5721668c155f934010ee928d40ec1",
    "line" : null,
    "diffHunk" : "@@ -1,1 +62,66 @@  }\n\n  def flatMap[AA >: A, D](f: B => AA Or D): AA Or D = this match {\n    case left @ LeftOr(_) => left\n    case RightOr(b) => f(b)"
  },
  {
    "id" : "9d3a007c-797d-41df-bcce-5d2518fbffab",
    "prId" : 9,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "75a1eb55-490f-4769-abf7-7bf15682d7c5",
        "parentId" : null,
        "authorId" : "64d7f629-ef5c-4472-bf31-18525b62f63d",
        "body" : "can we just kill the zombie code?\n",
        "createdAt" : "2015-01-30T20:34:07Z",
        "updatedAt" : "2015-01-30T20:37:38Z",
        "lastEditedBy" : "64d7f629-ef5c-4472-bf31-18525b62f63d",
        "tags" : [
        ]
      },
      {
        "id" : "df34aa33-e716-4eea-b3f3-6b05e7b073e7",
        "parentId" : "75a1eb55-490f-4769-abf7-7bf15682d7c5",
        "authorId" : "2ed5d687-cc94-4d72-ba74-717be38944e9",
        "body" : "I see the following dichotomy of zombies:\n1. Depends on types that don't exist yet.\n2. Depends on types that won't exist.\n\nI'd like to kill zombie type 2 and leave zombie type 1, if we can distinguish them.  But I'm not opposed to killing all the zombies and gradually adding things back as their dependencies are born.\n",
        "createdAt" : "2015-01-30T20:42:09Z",
        "updatedAt" : "2015-01-30T20:42:09Z",
        "lastEditedBy" : "2ed5d687-cc94-4d72-ba74-717be38944e9",
        "tags" : [
        ]
      },
      {
        "id" : "a23109f5-d193-4d82-bc8f-7c23b1dd8355",
        "parentId" : "75a1eb55-490f-4769-abf7-7bf15682d7c5",
        "authorId" : "64d7f629-ef5c-4472-bf31-18525b62f63d",
        "body" : "sounds good\n",
        "createdAt" : "2015-01-30T20:54:01Z",
        "updatedAt" : "2015-01-30T20:54:01Z",
        "lastEditedBy" : "64d7f629-ef5c-4472-bf31-18525b62f63d",
        "tags" : [
        ]
      }
    ],
    "commit" : "e61baff28b6a6d1e83fdcb93016409aa3f9c2f4c",
    "line" : 482,
    "diffHunk" : "@@ -1,1 +480,484 @@      )\n  }\n  */\n}\n"
  }
]
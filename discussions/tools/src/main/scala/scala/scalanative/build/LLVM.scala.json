[
  {
    "id" : "fac4a36f-7e76-49ad-8c8c-e369bbe09f1b",
    "prId" : 2033,
    "prUrl" : "https://github.com/scala-native/scala-native/pull/2033#pullrequestreview-555942822",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "dab83f31-c733-4c1a-a984-81ab328e94fa",
        "parentId" : null,
        "authorId" : "7fb21642-3dce-4a48-bff0-74a660a4631f",
        "body" : "Keep in mind that when you change the target triple these files need to be invalidated.\r\nThis if there will be a target triple setting changeable by the users.",
        "createdAt" : "2020-12-11T21:42:26Z",
        "updatedAt" : "2020-12-23T20:12:37Z",
        "lastEditedBy" : "7fb21642-3dce-4a48-bff0-74a660a4631f",
        "tags" : [
        ]
      },
      {
        "id" : "48f5537a-4a5e-4bce-8f79-edc7c7cae055",
        "parentId" : "dab83f31-c733-4c1a-a984-81ab328e94fa",
        "authorId" : "7993fb77-2703-437b-8884-a8af6767e218",
        "body" : "As you can see I avoided different output directories but I thought it might be best to see how this goes. I think changing the target triple in the build and `reload`ing the build probably means you should `clean`.\r\n\r\nThe build currently removes the `.ll` on every build but I am not sure of that history. It is probably just because we have no timestamp checking between `.nir` and `.ll` and it is not a one to one mapping. https://github.com/scala-native/scala-native/pull/2033/files#diff-ba1b9a87401a482acad7eb0588b7cc93ffeabdd871c5abd747b7bd5a79cf6a4fR67-R68\r\n\r\nNow that I think about it we may need a `Discover.targetTriple` so we can have an environment variable because other wise how could you use this in a CI build? Another option might be to have `Seq(targetTriple1, targetTriple2, ...)`. I hate to over engineer a feature on its first try especially since we need experience and feedback to find the sweet spot.",
        "createdAt" : "2020-12-11T23:51:45Z",
        "updatedAt" : "2020-12-23T20:12:37Z",
        "lastEditedBy" : "7993fb77-2703-437b-8884-a8af6767e218",
        "tags" : [
        ]
      },
      {
        "id" : "c2bb3cc1-820c-4d05-b56a-2a107884a7fc",
        "parentId" : "dab83f31-c733-4c1a-a984-81ab328e94fa",
        "authorId" : "ae07a374-5c7b-4f0c-a981-c4f03721cd63",
        "body" : "@ekrich and somewhere here we jump back to our discussion :)\r\n\r\nI feel that we should force user to use different sbt task for different targetTriple.",
        "createdAt" : "2020-12-12T00:16:58Z",
        "updatedAt" : "2020-12-23T20:12:37Z",
        "lastEditedBy" : "ae07a374-5c7b-4f0c-a981-c4f03721cd63",
        "tags" : [
        ]
      },
      {
        "id" : "4591eb78-a01f-4c45-803d-77db82017daf",
        "parentId" : "dab83f31-c733-4c1a-a984-81ab328e94fa",
        "authorId" : "ae189121-dea4-445f-87d0-303740ceff41",
        "body" : "I think the currently implemented solution is good: when changing the target triple, like any other config option, the user should `clean`. There is no difference between the target triple and, say, the GC configuration.\r\n\r\n> Now that I think about it we may need a Discover.targetTriple so we can have an environment variable because other wise how could you use this in a CI build?\r\n\r\nUsing\r\n```\r\n$ sbt 'set nativeConfig ~= { _.withTargetTriple(\"whatever\") }' test\r\n```\r\nThere's no need for an environment variable.",
        "createdAt" : "2020-12-14T10:55:19Z",
        "updatedAt" : "2020-12-23T20:12:37Z",
        "lastEditedBy" : "ae189121-dea4-445f-87d0-303740ceff41",
        "tags" : [
        ]
      },
      {
        "id" : "2666c859-0bf6-4485-bf02-7f68e9da2c71",
        "parentId" : "dab83f31-c733-4c1a-a984-81ab328e94fa",
        "authorId" : "7993fb77-2703-437b-8884-a8af6767e218",
        "body" : "That is good.",
        "createdAt" : "2020-12-14T18:36:04Z",
        "updatedAt" : "2020-12-23T20:12:37Z",
        "lastEditedBy" : "7993fb77-2703-437b-8884-a8af6767e218",
        "tags" : [
        ]
      },
      {
        "id" : "19bf110c-06e3-48cf-9c76-458e7abea0b8",
        "parentId" : "dab83f31-c733-4c1a-a984-81ab328e94fa",
        "authorId" : "7993fb77-2703-437b-8884-a8af6767e218",
        "body" : "A clean is required after changing settings at least the way things are now. A workaround is perhaps to have different projects for different targets or in CI I don't think that would be a problem because each build would be mostly clean.",
        "createdAt" : "2020-12-14T18:47:06Z",
        "updatedAt" : "2020-12-23T20:12:37Z",
        "lastEditedBy" : "7993fb77-2703-437b-8884-a8af6767e218",
        "tags" : [
        ]
      },
      {
        "id" : "a4a62181-bf3b-4a9b-b9a3-5e842e698f9e",
        "parentId" : "dab83f31-c733-4c1a-a984-81ab328e94fa",
        "authorId" : "7fb21642-3dce-4a48-bff0-74a660a4631f",
        "body" : "Personally I think this is a pity. One of the selling points of Scala Native compared to, say, GraalVM Native Image is that it could allow fast cross-compilation to generate programs for various operative systems. We're not yet there, this is sure, but I think that imposing a `clean` to change target is a waste of build time that will lower this benefit.\r\nCompilation to NIR doesn't change between targets and this way if you want to cross compile you're asking to re-do this work over and over.\r\nI hope that in the future \\(when we will see usages of cross-compiling, for example [throw Zig](https://ziglang.org/#Zig-is-also-a-C-compiler)\\) this decision will be revised.",
        "createdAt" : "2020-12-18T09:36:43Z",
        "updatedAt" : "2020-12-23T20:12:37Z",
        "lastEditedBy" : "7fb21642-3dce-4a48-bff0-74a660a4631f",
        "tags" : [
        ]
      },
      {
        "id" : "4ac4139b-251f-4c5e-9a77-adf9aa0c8d78",
        "parentId" : "dab83f31-c733-4c1a-a984-81ab328e94fa",
        "authorId" : "7993fb77-2703-437b-8884-a8af6767e218",
        "body" : "I agree that this is not ideal but we don't know when build settings change. Removing that check would slow down the normal use case. This check was there so that is not changing and I am not sure removing it is a great idea.\r\n\r\nI am open to a `Seq[\"target triple\"]` and individual build directories and lots of other stuff but I think it is better to have a nice change like this first and then when we prove things out we might find out that there are even better ways to do things.",
        "createdAt" : "2020-12-18T15:53:27Z",
        "updatedAt" : "2020-12-23T20:12:37Z",
        "lastEditedBy" : "7993fb77-2703-437b-8884-a8af6767e218",
        "tags" : [
        ]
      },
      {
        "id" : "8ee25b0c-3eb8-448e-8415-702e2240714b",
        "parentId" : "dab83f31-c733-4c1a-a984-81ab328e94fa",
        "authorId" : "ae189121-dea4-445f-87d0-303740ceff41",
        "body" : "If we do anything about this, it should be the same way that we invalidate the output of the linker if the config has changed in Scala.js:\r\nhttps://github.com/scala-js/scala-js/blob/a27c22bc0bf15a84b14745231815ea0a4a12c90f/sbt-plugin/src/main/scala/org/scalajs/sbtplugin/ScalaJSPluginInternal.scala#L188-L205\r\n\r\nBut that is for a different PR.",
        "createdAt" : "2020-12-19T12:26:33Z",
        "updatedAt" : "2020-12-23T20:12:37Z",
        "lastEditedBy" : "ae189121-dea4-445f-87d0-303740ceff41",
        "tags" : [
        ]
      },
      {
        "id" : "5d67ab17-5519-47f1-83e4-c284848b8ed1",
        "parentId" : "dab83f31-c733-4c1a-a984-81ab328e94fa",
        "authorId" : "7fb21642-3dce-4a48-bff0-74a660a4631f",
        "body" : "Thank you @ekrich and @sjrd .\r\nAs you said, Eric, this is a good starting point to start playing with cross-compilation and it doesn't necessarily mean that can't be improved in the future when if we find better ways to do things.",
        "createdAt" : "2020-12-19T13:50:59Z",
        "updatedAt" : "2020-12-23T20:12:37Z",
        "lastEditedBy" : "7fb21642-3dce-4a48-bff0-74a660a4631f",
        "tags" : [
        ]
      }
    ],
    "commit" : "4c49190f35694592f75da289c49f874e0ac54ed6",
    "line" : 47,
    "diffHunk" : "@@ -1,1 +137,141 @@      val opath   = path + oExt\n      val objPath = Paths.get(opath)\n      if (!Files.exists(objPath)) {\n        val isCpp    = path.endsWith(cppExt)\n        val compiler = if (isCpp) config.clangPP.abs else config.clang.abs"
  },
  {
    "id" : "88ec15d1-89b0-4f65-a837-754c05eb57e8",
    "prId" : 1281,
    "prUrl" : "https://github.com/scala-native/scala-native/pull/1281#pullrequestreview-139880311",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "dd3b51e2-6b46-47b6-8f8c-7f8e0fdfadd6",
        "parentId" : null,
        "authorId" : "d1cbb5a4-1605-48d2-8efe-eeb6295c931f",
        "body" : "In order for this flag to automatically be picked up by projects that require compiling C/C++ code it would be better to make the LTO flag part of `config.compileOptions` and `compile.linkingOptions` and thus automatically exposing it in sbt and other build tools.\r\n\r\nCoincidentally it would probably also make the PR simpler.",
        "createdAt" : "2018-07-20T12:52:55Z",
        "updatedAt" : "2018-07-25T11:35:42Z",
        "lastEditedBy" : "d1cbb5a4-1605-48d2-8efe-eeb6295c931f",
        "tags" : [
        ]
      },
      {
        "id" : "1ef054cd-a689-465b-b500-bc0044c89b76",
        "parentId" : "dd3b51e2-6b46-47b6-8f8c-7f8e0fdfadd6",
        "authorId" : "7993fb77-2703-437b-8884-a8af6767e218",
        "body" : "This also coincides with some of the ideas here about some of the hardcoded values for debug and release as well. https://github.com/scala-native/scala-native/issues/1205",
        "createdAt" : "2018-07-20T13:07:07Z",
        "updatedAt" : "2018-07-25T11:35:42Z",
        "lastEditedBy" : "7993fb77-2703-437b-8884-a8af6767e218",
        "tags" : [
        ]
      },
      {
        "id" : "04edc071-d5a3-409f-99b8-2151ad932533",
        "parentId" : "dd3b51e2-6b46-47b6-8f8c-7f8e0fdfadd6",
        "authorId" : "0f96d83b-618e-4d06-9aeb-e1d46fa92077",
        "body" : "`nativeCompileOptions` has semantics of \"additional options passed to clang\", not \"all the options passed to clang\". Otherwise doing `set nativeCompileOptions := Seq(\"-O2\")` would disable every single default option which is extremely surprising. This semantics works well in practice because clang supports the same option being passed multiple times and the last one wins. So user-defined options come last they always override the defaults.",
        "createdAt" : "2018-07-23T11:24:48Z",
        "updatedAt" : "2018-07-25T11:35:42Z",
        "lastEditedBy" : "0f96d83b-618e-4d06-9aeb-e1d46fa92077",
        "tags" : [
        ]
      },
      {
        "id" : "3e155613-627c-4f1d-b1f1-b0dd071be6f3",
        "parentId" : "dd3b51e2-6b46-47b6-8f8c-7f8e0fdfadd6",
        "authorId" : "d1cbb5a4-1605-48d2-8efe-eeb6295c931f",
        "body" : "Okay, makes sense. Then ideally this will be handled by #657.",
        "createdAt" : "2018-07-24T13:08:32Z",
        "updatedAt" : "2018-07-25T11:35:42Z",
        "lastEditedBy" : "d1cbb5a4-1605-48d2-8efe-eeb6295c931f",
        "tags" : [
        ]
      }
    ],
    "commit" : "b52c74fafdca052eb9aab25182a22c3a892b3af7",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +97,101 @@        val flags = (if (isCpp) Seq(\"-std=c++11\")\n                     else Seq(\"-std=gnu11\")) ++ config.compileOptions\n        val compilec = Seq(compiler) ++ flto(config) ++ flags ++ Seq(\"-c\",\n                                                                     path,\n                                                                     \"-o\","
  }
]
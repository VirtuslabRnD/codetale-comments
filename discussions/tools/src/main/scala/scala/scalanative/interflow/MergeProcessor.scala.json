[
  {
    "id" : "65cb1bbc-37c7-4f7e-9cc0-23e831b5a6d4",
    "prId" : 1877,
    "prUrl" : "https://github.com/scala-native/scala-native/pull/1877#pullrequestreview-472534404",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "198d26bf-e1e7-45ca-aab1-733c1c57092a",
        "parentId" : null,
        "authorId" : "ae189121-dea4-445f-87d0-303740ceff41",
        "body" : "Why is it OK to use `j.l.Object`, here?",
        "createdAt" : "2020-08-20T15:40:53Z",
        "updatedAt" : "2020-10-06T16:52:57Z",
        "lastEditedBy" : "ae189121-dea4-445f-87d0-303740ceff41",
        "tags" : [
        ]
      },
      {
        "id" : "ed5a4a68-f384-4f16-9814-aa35184b3591",
        "parentId" : "198d26bf-e1e7-45ca-aab1-733c1c57092a",
        "authorId" : "ec81b063-dc9d-4604-ae13-ab5cd6be1355",
        "body" : "Provided `j.l.Object` here as the superclass of all classes, i.e. the generic safe choice, since this call path did not cause any problems.",
        "createdAt" : "2020-08-21T11:06:45Z",
        "updatedAt" : "2020-10-06T16:52:57Z",
        "lastEditedBy" : "ec81b063-dc9d-4604-ae13-ab5cd6be1355",
        "tags" : [
        ]
      },
      {
        "id" : "78e70976-d3e0-4676-9335-0e5296bd0955",
        "parentId" : "198d26bf-e1e7-45ca-aab1-733c1c57092a",
        "authorId" : "ae189121-dea4-445f-87d0-303740ceff41",
        "body" : "It's only a safe choice if the result is never used in a place that could have an expected type more specific than `Object`. Is there a reason that this never happens here? If yes, it deserves comment to explain that reason. If not, it deserves even more a comment with `!!!` telling that we're going YOLO here.",
        "createdAt" : "2020-08-21T11:28:42Z",
        "updatedAt" : "2020-10-06T16:52:57Z",
        "lastEditedBy" : "ae189121-dea4-445f-87d0-303740ceff41",
        "tags" : [
        ]
      },
      {
        "id" : "8b371a6b-b8c2-4e50-ba4a-c9dcc5a11449",
        "parentId" : "198d26bf-e1e7-45ca-aab1-733c1c57092a",
        "authorId" : "ec81b063-dc9d-4604-ae13-ab5cd6be1355",
        "body" : "Hmm, the way the algorithm works, it will always choose the LUB type of the candidate types. The candidates are computed [here](https://github.com/errikos/scala-native/blob/topic/2.12.x-support/tools/src/main/scala/scala/scalanative/linker/Sub.scala#L115-L116), and they will always include only super-types of both types and sub-types of the bound type (in this case `j.l.Object`). However, the bound type is never included in the candidates, so I think that `j.l.Object` cannot be the resulting type, except if expected.\r\n\r\n(the above is based on a very quick analysis)",
        "createdAt" : "2020-08-21T11:45:36Z",
        "updatedAt" : "2020-10-06T16:52:57Z",
        "lastEditedBy" : "ec81b063-dc9d-4604-ae13-ab5cd6be1355",
        "tags" : [
        ]
      },
      {
        "id" : "40bd3161-02c2-4a53-a543-1c5ac43520c5",
        "parentId" : "198d26bf-e1e7-45ca-aab1-733c1c57092a",
        "authorId" : "ae189121-dea4-445f-87d0-303740ceff41",
        "body" : "No, `j.l.Object` can't be the resulting type. But you could get `HasForeachEntry` even though you wanted `Map`, because `HasForeachEntry` is a supertype of all the alternatives.\r\n\r\nThis is exactly the same scenario as the one you had to fix for one of the cases. It can happen elsewhere in other circumstances.",
        "createdAt" : "2020-08-21T12:31:42Z",
        "updatedAt" : "2020-10-06T16:52:57Z",
        "lastEditedBy" : "ae189121-dea4-445f-87d0-303740ceff41",
        "tags" : [
        ]
      },
      {
        "id" : "d41779b7-7353-4dcc-8edc-f5047e6ebcee",
        "parentId" : "198d26bf-e1e7-45ca-aab1-733c1c57092a",
        "authorId" : "ec81b063-dc9d-4604-ae13-ab5cd6be1355",
        "body" : "You're right. I added a caution message at the calls, for the moment.",
        "createdAt" : "2020-08-21T14:23:50Z",
        "updatedAt" : "2020-10-06T16:52:57Z",
        "lastEditedBy" : "ec81b063-dc9d-4604-ae13-ab5cd6be1355",
        "tags" : [
        ]
      }
    ],
    "commit" : "fce1234368bb0af02f2e0a329da7a4054b4e52b9",
    "line" : 86,
    "diffHunk" : "@@ -1,1 +415,419 @@      // !!! specific than j.l.Object is expected as the return type, then Sub.lub may\n      // !!! calculate the wrong type.\n      val retTy = Sub.lub(tys, Type.Ref(Global.Top(\"java.lang.Object\")))\n\n      // Create synthetic label and block where all returning blocks"
  }
]
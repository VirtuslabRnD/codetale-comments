[
  {
    "id" : "743eb0c0-7716-4c97-8f02-96bf17798421",
    "prId" : 16565,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/16565#pullrequestreview-41667561",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fca70fdb-3ff1-4a7c-a7e8-f1869cd9fe20",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "yep!",
        "createdAt" : "2017-06-02T00:07:30Z",
        "updatedAt" : "2017-06-02T00:07:30Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "83bdc59036fbad4531d36973a4236649d7b47711",
    "line" : 17,
    "diffHunk" : "@@ -1,1 +255,259 @@        self.miint.is_monotonic\n\n    def time_remove_unused_levels(self):\n        self.mi_unused_levels.remove_unused_levels()\n"
  },
  {
    "id" : "05c99703-fddf-49df-b919-43044a329a87",
    "prId" : 17956,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/17956#pullrequestreview-71840529",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "eb8aab57-7a19-4b74-ae1d-fdbc90d4a0d5",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "can you add for ``.loc`` (and might as well for ``.ix``)",
        "createdAt" : "2017-10-25T10:39:47Z",
        "updatedAt" : "2017-10-27T11:09:20Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "a820f5e1-09e1-4a9c-bc2e-110f8505874c",
        "parentId" : "eb8aab57-7a19-4b74-ae1d-fdbc90d4a0d5",
        "authorId" : "7c84fc55-a848-4ca2-a014-28c856c6d6e2",
        "body" : "Ok, done.",
        "createdAt" : "2017-10-25T12:28:25Z",
        "updatedAt" : "2017-10-27T11:09:20Z",
        "lastEditedBy" : "7c84fc55-a848-4ca2-a014-28c856c6d6e2",
        "tags" : [
        ]
      }
    ],
    "commit" : "efe021daebcca3d706aa8ced3eb90c2e12c41fb4",
    "line" : 10,
    "diffHunk" : "@@ -1,1 +294,298 @@\n    def setup(self):\n        self.s = Series(range(10))\n\n    def time_lookup_iloc(self):"
  },
  {
    "id" : "285326ff-ca53-4e3c-ab63-a6d221b385e8",
    "prId" : 38148,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/38148#pullrequestreview-540494188",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3fe4989a-2513-4ee2-845d-0bec250f1539",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "do we also have the concat example (you can put it here)?",
        "createdAt" : "2020-11-29T15:55:40Z",
        "updatedAt" : "2020-11-29T19:08:07Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "f312778c-e7d8-40fb-888d-4a5f7680340f",
        "parentId" : "3fe4989a-2513-4ee2-845d-0bec250f1539",
        "authorId" : "f3e7d5fe-a112-47db-9178-8be42b4a8eab",
        "body" : "Done",
        "createdAt" : "2020-11-29T16:15:37Z",
        "updatedAt" : "2020-11-29T19:08:07Z",
        "lastEditedBy" : "f3e7d5fe-a112-47db-9178-8be42b4a8eab",
        "tags" : [
        ]
      }
    ],
    "commit" : "d4b76e524d684f114f7993e95408eef6b68ac983",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +359,363 @@            self.df[i] = np.random.randn(self.N)\n\n    def time_assign_list_like_with_setitem(self):\n        np.random.seed(1234)\n        self.df[list(range(100))] = np.random.randn(self.N, 100)"
  },
  {
    "id" : "67f3e6dd-4ba6-46bb-ab3f-fdd206dfecbb",
    "prId" : 38476,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/38476#pullrequestreview-554081967",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "dabc8f0c-f139-4e2d-aabf-a9e2e3cff2fc",
        "parentId" : null,
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "What is the timing you get for this? Because `data_unique` is only a small index, while `data` uses `N = 10 ** 5`. We might want to make `data_unique` larger as well?\r\n\r\n(there is a `rands` helper in pandas._testing to create random strings of a certain length)",
        "createdAt" : "2020-12-15T13:12:20Z",
        "updatedAt" : "2020-12-15T13:12:33Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      },
      {
        "id" : "641a0897-4a36-4174-a340-dbe5009d0eb0",
        "parentId" : "dabc8f0c-f139-4e2d-aabf-a9e2e3cff2fc",
        "authorId" : "eb0b5a98-1084-4e61-8414-5fb19728b91f",
        "body" : "After #38372, `CategoricalIndex.get_indexer` raises an error if if the index has duplicate values; so I think to keep this benchmark we need to use this smaller index.",
        "createdAt" : "2020-12-15T17:38:27Z",
        "updatedAt" : "2020-12-15T17:38:28Z",
        "lastEditedBy" : "eb0b5a98-1084-4e61-8414-5fb19728b91f",
        "tags" : [
        ]
      },
      {
        "id" : "df4190bf-23d9-4885-ba8e-4d105a8da7c0",
        "parentId" : "dabc8f0c-f139-4e2d-aabf-a9e2e3cff2fc",
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "You can still have more unique strings when combining multiple characters (which is what `rands` does). Just want to be sure that it's not a tiny benchmark that might not catch actual regressions",
        "createdAt" : "2020-12-15T22:11:34Z",
        "updatedAt" : "2020-12-15T22:11:34Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      },
      {
        "id" : "989c6aad-cd49-492c-b1ed-4355d2dbcb7a",
        "parentId" : "dabc8f0c-f139-4e2d-aabf-a9e2e3cff2fc",
        "authorId" : "eb0b5a98-1084-4e61-8414-5fb19728b91f",
        "body" : "Ah good point. Here's a short timeit of this benchmark.\r\n\r\n```\r\nIn [3]: %timeit idx.get_indexer(['a', 'c'])\r\n736 µs ± 3.34 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)\r\n```\r\n\r\nIf you think this is too tiny I can bump it up, though I think asv regressions are reported as a percentage correct?\r\n",
        "createdAt" : "2020-12-16T01:33:29Z",
        "updatedAt" : "2020-12-16T01:33:29Z",
        "lastEditedBy" : "eb0b5a98-1084-4e61-8414-5fb19728b91f",
        "tags" : [
        ]
      },
      {
        "id" : "6961215d-4e01-48f3-beca-81b170c55a76",
        "parentId" : "dabc8f0c-f139-4e2d-aabf-a9e2e3cff2fc",
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "I think that's too little. Based on a quick profile, we are mostly measuring here the overhead (converting ['a', 'c'] to an Index, checking the dtypes, etc), which doesn't necessarily scale linearly with the size of the data. While the actual indexing operation is only about 10% of the time. So assume that we have a regression there that makes it go x2, we would hardly notice that in this benchmark's timing.\r\n\r\nNow, we would maybe also solve that by making `cat_list` longer, instead of making `idx` longer (eg `int_list` has 10000 elements, `cat_list` only 2. Doing `cat_list = ['a', 'c'] * 5000` would probably already help.",
        "createdAt" : "2020-12-16T21:03:31Z",
        "updatedAt" : "2020-12-16T21:03:31Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      }
    ],
    "commit" : "542a7fc6152cf8bb58535cbb744ccec809d58f69",
    "line" : 21,
    "diffHunk" : "@@ -1,1 +284,288 @@\n    def time_get_indexer_list(self, index):\n        self.data_unique.get_indexer(self.cat_list)\n\n"
  }
]
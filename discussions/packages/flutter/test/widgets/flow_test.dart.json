[
  {
    "id" : "b9eb441a-7ec7-473c-af1c-2d08f2431edf",
    "prId" : 15543,
    "prUrl" : "https://github.com/flutter/flutter/pull/15543#pullrequestreview-104353019",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e1244baf-3410-419e-99fb-287347595b2a",
        "parentId" : null,
        "authorId" : "9b5a6de7-1648-432f-a400-7a47bea935d8",
        "body" : "looks good. for completeness' sake, let's also have the opposite test (when opacity == 1.0), just to be sure.\r\n\r\n(I assume this test fails without your fix?)",
        "createdAt" : "2018-03-15T19:33:59Z",
        "updatedAt" : "2018-03-15T19:41:06Z",
        "lastEditedBy" : "9b5a6de7-1648-432f-a400-7a47bea935d8",
        "tags" : [
        ]
      },
      {
        "id" : "abef871e-0964-4cf8-ad5a-3a3316820a2b",
        "parentId" : "e1244baf-3410-419e-99fb-287347595b2a",
        "authorId" : "96a98276-7acb-4411-9633-960c20044a6f",
        "body" : "The code works the same for all opacity values.  The bug was making the layers affected by opacity siblings of the opacity layer, when they should have been children of the opacity layer.\r\n\r\nThe malformed tree wasn't noticeable when opacity is 1.0 because the opacity layer would not have affected rendering.\r\n",
        "createdAt" : "2018-03-15T19:43:00Z",
        "updatedAt" : "2018-03-15T19:43:01Z",
        "lastEditedBy" : "96a98276-7acb-4411-9633-960c20044a6f",
        "tags" : [
        ]
      }
    ],
    "commit" : "608b0abff120b1d4fac8d803da7b76f2c0a61d93",
    "line" : 53,
    "diffHunk" : "@@ -1,1 +118,122 @@    expect(opacityLayer.alpha, equals(opacity * 255));\n    expect(layer.firstChild, const isInstanceOf<TransformLayer>());\n  });\n}"
  }
]
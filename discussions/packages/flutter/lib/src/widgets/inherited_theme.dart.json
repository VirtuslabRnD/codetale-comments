[
  {
    "id" : "ce7b4b48-8f0e-4403-9d9f-8bfad8cca1bc",
    "prId" : 38583,
    "prUrl" : "https://github.com/flutter/flutter/pull/38583#pullrequestreview-275688493",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "196bc9c0-4150-47b6-8d93-d8a4dc39ea85",
        "parentId" : null,
        "authorId" : "a28d4bf0-9b21-4633-a08e-c383b294a037",
        "body" : "Maybe we can move this to framework.dart so it has access to `_inheritedWidgets`?",
        "createdAt" : "2019-08-15T19:24:15Z",
        "updatedAt" : "2019-08-21T15:24:56Z",
        "lastEditedBy" : "a28d4bf0-9b21-4633-a08e-c383b294a037",
        "tags" : [
        ]
      },
      {
        "id" : "a2e2045b-fbb8-4ec5-a6a2-70afda06f491",
        "parentId" : "196bc9c0-4150-47b6-8d93-d8a4dc39ea85",
        "authorId" : "9ae618fc-fa71-4bc9-be97-de7c674590eb",
        "body" : "I don't think that there's a real performance problem due to walking past all of the ancestors; however you're right that this could perform a little better if the code was in framework.dart. On the other hand, framework.dart is quite big; keeping InheritedTheme separate makes everything just a little easier to read.",
        "createdAt" : "2019-08-15T21:50:51Z",
        "updatedAt" : "2019-08-21T15:24:56Z",
        "lastEditedBy" : "9ae618fc-fa71-4bc9-be97-de7c674590eb",
        "tags" : [
        ]
      }
    ],
    "commit" : "2f48c04927e707cdea07be1cb09718dd1ae3ec46",
    "line" : 117,
    "diffHunk" : "@@ -1,1 +115,119 @@\n    final List<InheritedTheme> themes = <InheritedTheme>[];\n    context.visitAncestorElements((Element ancestor) {\n      if (ancestor is InheritedElement && ancestor.widget is InheritedTheme) {\n        final InheritedTheme theme = ancestor.widget;"
  },
  {
    "id" : "47acef56-60aa-45c9-bb3a-89cf73a5f683",
    "prId" : 38583,
    "prUrl" : "https://github.com/flutter/flutter/pull/38583#pullrequestreview-275687125",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5c6476d7-2049-46a7-b028-6ccc5e5010b8",
        "parentId" : null,
        "authorId" : "8214f119-d2d3-484d-aea2-02799ab41da5",
        "body" : "I'm not sure I understand what \"visible\" means. Is this to say that if an inherited theme of the same type has already been found, ignore the InheritedThemes of the same type further up the element tree?",
        "createdAt" : "2019-08-15T21:33:31Z",
        "updatedAt" : "2019-08-21T15:24:56Z",
        "lastEditedBy" : "8214f119-d2d3-484d-aea2-02799ab41da5",
        "tags" : [
        ]
      },
      {
        "id" : "a0514a49-6145-4618-86df-d938bf82fb6c",
        "parentId" : "5c6476d7-2049-46a7-b028-6ccc5e5010b8",
        "authorId" : "9ae618fc-fa71-4bc9-be97-de7c674590eb",
        "body" : "It means that if the identical inherited theme would be inherited by child, then there's no need to wrap child with the same theme.\r\n\r\nFor example if Theme.of(context) is non-null then Theme is \"visible\" in context. If the Theme widget we stashed away in InheritedThemes.captureAll(context, child) is identical to the one that's visible to the returned widget when it's built (in the context where it will actually appear), then there's no need to wrap the child with the saved Theme.",
        "createdAt" : "2019-08-15T21:47:05Z",
        "updatedAt" : "2019-08-21T15:24:56Z",
        "lastEditedBy" : "9ae618fc-fa71-4bc9-be97-de7c674590eb",
        "tags" : [
        ]
      }
    ],
    "commit" : "2f48c04927e707cdea07be1cb09718dd1ae3ec46",
    "line" : 98,
    "diffHunk" : "@@ -1,1 +96,100 @@  /// Return a copy of this inherited theme with the specified [child].\n  ///\n  /// If the identical inherited theme is already visible from [context] then\n  /// just return the [child].\n  ///"
  },
  {
    "id" : "76ff0f36-b518-4d26-afda-f3ea9684ca57",
    "prId" : 39089,
    "prUrl" : "https://github.com/flutter/flutter/pull/39089#pullrequestreview-278749751",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e7a7cf13-1a59-42e1-b7d7-c84b5dd00d4a",
        "parentId" : null,
        "authorId" : "b050a012-8ac0-4fb8-8058-231ac0263df1",
        "body" : "Rather than only recording one theme of each type, could you instead pass `themes.reversed` to `_CaptureAll(...)` below? That way it's a slightly more accurate recreation of the \"`Theme`\" tree.\r\n\r\nI highly doubt this ever happens, but if you had `Theme(child: IconTheme(child: Theme(...)))`, and the `IconTheme` called `Theme.of(context)`, we'd still want it to return the outer theme. ",
        "createdAt" : "2019-08-23T00:08:22Z",
        "updatedAt" : "2019-08-23T00:10:56Z",
        "lastEditedBy" : "b050a012-8ac0-4fb8-8058-231ac0263df1",
        "tags" : [
        ]
      },
      {
        "id" : "8822ff61-07df-4636-b83b-3eca4d33ac6b",
        "parentId" : "e7a7cf13-1a59-42e1-b7d7-c84b5dd00d4a",
        "authorId" : "9ae618fc-fa71-4bc9-be97-de7c674590eb",
        "body" : "The theme wrapping does proceed inside-out (so to speak).  The source of the problem being fixed here was the InheritTheme wrap methods which look like:\r\n```\r\n  Widget wrap(BuildContext context, Widget child) {\r\n    final IconTheme ancestorTheme = context.ancestorWidgetOfExactType(IconTheme);\r\n    return identical(this, ancestorTheme) ? child : IconTheme(data: data, child: child);\r\n  }\r\n```\r\nThe identical test defends against the common case where the same inherited theme is visible in both the captureAll() and the wrap() contexts. When the same theme is visible in both contexts we don't bother wrapping a copy of the theme around the child. \r\n\r\nThe source of the bug was the result of applying this test to an outer theme that was shadowed by an inner theme of the same type.  In that case the code was mistakenly wrapping the child with the outer theme because it wasn't identical to the inner one. Since the outer theme is shadowed by the inner one, we now just discard it in captureAll().\r\n\r\nYou're right that one could create an InheritedTheme whose build method created a dependency on the same type of theme. We definitely don't have\"cascading\" themes that work in this way although, currently we don't do anything to actively prevent it.",
        "createdAt" : "2019-08-23T00:34:18Z",
        "updatedAt" : "2019-08-23T00:34:18Z",
        "lastEditedBy" : "9ae618fc-fa71-4bc9-be97-de7c674590eb",
        "tags" : [
        ]
      }
    ],
    "commit" : "3b57010d643b388b90403ade4faed60bfc2474c6",
    "line" : 9,
    "diffHunk" : "@@ -1,1 +119,123 @@      if (ancestor is InheritedElement && ancestor.widget is InheritedTheme) {\n        final InheritedTheme theme = ancestor.widget;\n        final Type themeType = theme.runtimeType;\n        // Only remember the first theme of any type. This assumes\n        // that inherited themes completely shadow ancestors of the"
  }
]
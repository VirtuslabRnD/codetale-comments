[
  {
    "id" : "e2b79351-2c1e-4d8f-b677-783929842002",
    "prId" : 34712,
    "prUrl" : "https://github.com/flutter/flutter/pull/34712#pullrequestreview-260260287",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f7350357-755e-4fcb-a704-7d1b7d238948",
        "parentId" : null,
        "authorId" : "db47316c-0a85-441a-8891-3b84e8bfe474",
        "body" : "I think we need to better understand how this could happen.  I'm concerned that this may arise because some node that is supposed to be kept alive is actually not being kept alive, and that's why we're losing it.  Making this change would hide that, if it is in fact the problem.",
        "createdAt" : "2019-06-26T21:44:02Z",
        "updatedAt" : "2019-07-12T06:35:59Z",
        "lastEditedBy" : "db47316c-0a85-441a-8891-3b84e8bfe474",
        "tags" : [
        ]
      },
      {
        "id" : "f2cd58c1-2707-4ef0-95c3-95825ba6ad1e",
        "parentId" : "f7350357-755e-4fcb-a704-7d1b7d238948",
        "authorId" : "32c18370-b804-47c0-afc6-52fe97ae9791",
        "body" : "This situation is widespread in the Sliver component. \r\nsuch as GridView(#34153):  when we move the focus down, grid element slides up. The grid elements would be unmount if they out of grid container, which cause history kept an unreachable node.\r\n",
        "createdAt" : "2019-06-27T01:57:37Z",
        "updatedAt" : "2019-07-12T06:35:59Z",
        "lastEditedBy" : "32c18370-b804-47c0-afc6-52fe97ae9791",
        "tags" : [
        ]
      },
      {
        "id" : "363c1c75-341f-45e8-9346-cf1c9127e4bf",
        "parentId" : "f7350357-755e-4fcb-a704-7d1b7d238948",
        "authorId" : "fd82dff4-bfc7-4076-8507-e7e4521446f2",
        "body" : "Why just the last element in the history?  Couldn't any of the nodes have been unmounted?\r\n\r\nHow about this instead:\r\n```suggestion\r\n      // If a node has been removed from the tree, then we should stop\r\n      // referencing it and reset the scope data so that we don't try and\r\n      // request focus on it. This can happen in slivers where the rendered node\r\n      // has been unmounted. This has the side effect that hysteresis might not\r\n      // be avoided when items that go off screen get unmounted.\r\n      if (policyData.history.lastWhere(\r\n            (_DirectionalPolicyDataEntry node) => node.node.parent == null,\r\n            orElse: () => null,\r\n          ) != null) {\r\n        invalidateScopeData(nearestScope);\r\n        return false;\r\n      }\r\n```",
        "createdAt" : "2019-07-09T15:20:32Z",
        "updatedAt" : "2019-07-12T06:35:59Z",
        "lastEditedBy" : "fd82dff4-bfc7-4076-8507-e7e4521446f2",
        "tags" : [
        ]
      },
      {
        "id" : "0c5fa26c-3282-42ca-9a12-f488033926b5",
        "parentId" : "f7350357-755e-4fcb-a704-7d1b7d238948",
        "authorId" : "32c18370-b804-47c0-afc6-52fe97ae9791",
        "body" : "What I think is that the last element might not be unmounted, in this situation, the last node can still be used to avoid hysteresis. ",
        "createdAt" : "2019-07-10T03:26:01Z",
        "updatedAt" : "2019-07-12T06:35:59Z",
        "lastEditedBy" : "32c18370-b804-47c0-afc6-52fe97ae9791",
        "tags" : [
        ]
      },
      {
        "id" : "c566e6f1-a04a-4648-b1be-5fd4ca3a1fa8",
        "parentId" : "f7350357-755e-4fcb-a704-7d1b7d238948",
        "authorId" : "fd82dff4-bfc7-4076-8507-e7e4521446f2",
        "body" : "Yes, I guess that makes sense, just because a previous node is already unmounted doesn't mean that the last one is invalid. OK.  I do think you should add the comment I suggested above, though, to explain what's going on.",
        "createdAt" : "2019-07-10T14:51:12Z",
        "updatedAt" : "2019-07-12T06:35:59Z",
        "lastEditedBy" : "fd82dff4-bfc7-4076-8507-e7e4521446f2",
        "tags" : [
        ]
      },
      {
        "id" : "489cc1cf-def1-4f84-9013-749cb3f9dbc6",
        "parentId" : "f7350357-755e-4fcb-a704-7d1b7d238948",
        "authorId" : "32c18370-b804-47c0-afc6-52fe97ae9791",
        "body" : "Yes, I think I should add a comment to explain why this code was added.",
        "createdAt" : "2019-07-10T17:55:07Z",
        "updatedAt" : "2019-07-12T06:35:59Z",
        "lastEditedBy" : "32c18370-b804-47c0-afc6-52fe97ae9791",
        "tags" : [
        ]
      }
    ],
    "commit" : "cb00fecb66b15ee187182684c457ce183a0cc1c6",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +312,316 @@    final _DirectionalPolicyData policyData = _policyData[nearestScope];\n    if (policyData != null && policyData.history.isNotEmpty && policyData.history.first.direction != direction) {\n      if (policyData.history.last.node.parent == null) {\n        // If a node has been removed from the tree, then we should stop\n        // referencing it and reset the scope data so that we don't try and"
  }
]
[
  {
    "id" : "b7a9e631-399e-4381-b89f-a7a88c12fbb7",
    "prId" : 6413,
    "prUrl" : "https://github.com/flutter/flutter/pull/6413#pullrequestreview-5340491",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "28d6c4f6-6f5a-4ede-b0ad-60778d3d8285",
        "parentId" : null,
        "authorId" : "1dc608b7-5634-49db-a2de-36dd357356e8",
        "body" : "Docs out of date\n",
        "createdAt" : "2016-10-22T01:26:14Z",
        "updatedAt" : "2016-10-22T01:26:14Z",
        "lastEditedBy" : "1dc608b7-5634-49db-a2de-36dd357356e8",
        "tags" : [
        ]
      }
    ],
    "commit" : "8559b3eb675a942cf4a3c9f94c8b8a9b29f3bbdf",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +12,16 @@import 'platform_messages.dart';\n\n/// Ensures that the [MojoShell] singleton is created synchronously\n/// during binding initialization. This allows other binding classes\n/// to register services in the same call stack as the services are"
  },
  {
    "id" : "22e23224-ca8d-4004-bfb0-06d9c0c3990e",
    "prId" : 14206,
    "prUrl" : "https://github.com/flutter/flutter/pull/14206#pullrequestreview-91691544",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9f8c7cec-51ca-4e7c-badf-237a67a0c555",
        "parentId" : null,
        "authorId" : "ac2c92fd-803c-4666-96b1-db1044c762c5",
        "body" : "I think this is the same as `new Future(... logic ...)`. Does not require a completer.",
        "createdAt" : "2018-01-22T22:58:42Z",
        "updatedAt" : "2018-01-22T22:58:53Z",
        "lastEditedBy" : "ac2c92fd-803c-4666-96b1-db1044c762c5",
        "tags" : [
        ]
      },
      {
        "id" : "fe9d9dc1-9732-4380-a71b-ba374ee52d6c",
        "parentId" : "9f8c7cec-51ca-4e7c-badf-237a67a0c555",
        "authorId" : "9b5a6de7-1648-432f-a400-7a47bea935d8",
        "body" : "Not sure I understand what you mean. Can you show a snippet of how you'd use `new Future` to do this?",
        "createdAt" : "2018-01-23T00:54:39Z",
        "updatedAt" : "2018-01-23T00:54:39Z",
        "lastEditedBy" : "9b5a6de7-1648-432f-a400-7a47bea935d8",
        "tags" : [
        ]
      },
      {
        "id" : "42517f86-8bb8-4ff2-a683-7d03a5425465",
        "parentId" : "9f8c7cec-51ca-4e7c-badf-237a67a0c555",
        "authorId" : "ac2c92fd-803c-4666-96b1-db1044c762c5",
        "body" : "I may be missing something, but was thinking this:\r\n\r\n```dart\r\n// The callback passed to `new Future` is passed to Timer.run.\r\nfinal String rawLicenses = await new Future<String>(\r\n  () => rootBundle.loadString('LICENSE', cache: false),\r\n);\r\nfinal List<LicenseEntry> parsedLicenses = await new Future<List<LicenseEntry>>(\r\n  () => compute(_parseLicenses, rawLicenses, debugLabel: 'parseLicenses'),\r\n);\r\n```\r\n",
        "createdAt" : "2018-01-23T01:21:34Z",
        "updatedAt" : "2018-01-23T01:22:19Z",
        "lastEditedBy" : "ac2c92fd-803c-4666-96b1-db1044c762c5",
        "tags" : [
        ]
      },
      {
        "id" : "8976f477-56ea-4ca5-9a96-0e28b0bc2f39",
        "parentId" : "9f8c7cec-51ca-4e7c-badf-237a67a0c555",
        "authorId" : "ac2c92fd-803c-4666-96b1-db1044c762c5",
        "body" : "[update: fixed the code a little]",
        "createdAt" : "2018-01-23T01:22:45Z",
        "updatedAt" : "2018-01-23T01:22:51Z",
        "lastEditedBy" : "ac2c92fd-803c-4666-96b1-db1044c762c5",
        "tags" : [
        ]
      },
      {
        "id" : "ca96f0c8-40ac-4c61-91dc-8241c649ba80",
        "parentId" : "9f8c7cec-51ca-4e7c-badf-237a67a0c555",
        "authorId" : "9b5a6de7-1648-432f-a400-7a47bea935d8",
        "body" : "If you don't use `Timer.run`, you're using microtasks, which all run before the next event loop iteration, and thus it becomes impossible for the engine to render a frame between the first future `compute` completing the future and the second starting its isolate, both of which are very expensive operations (see the bugs linked to in the comment).",
        "createdAt" : "2018-01-25T21:50:25Z",
        "updatedAt" : "2018-01-25T21:50:25Z",
        "lastEditedBy" : "9b5a6de7-1648-432f-a400-7a47bea935d8",
        "tags" : [
        ]
      },
      {
        "id" : "cbe81cb2-aca3-4136-9d17-80613ca5df4a",
        "parentId" : "9f8c7cec-51ca-4e7c-badf-237a67a0c555",
        "authorId" : "9b5a6de7-1648-432f-a400-7a47bea935d8",
        "body" : "Or to put it another way, there's no difference between your code and:\r\n```dart\r\nfinal String rawLicenses = await rootBundle.loadString('LICENSE', cache: false);\r\nfinal List<LicenseEntry> parsedLicenses = await compute(_parseLicenses, rawLicenses, debugLabel: 'parseLicenses');\r\n```\r\n...which is what it was before. :-)",
        "createdAt" : "2018-01-25T21:51:27Z",
        "updatedAt" : "2018-01-25T21:51:28Z",
        "lastEditedBy" : "9b5a6de7-1648-432f-a400-7a47bea935d8",
        "tags" : [
        ]
      },
      {
        "id" : "36d05685-1d24-4441-8266-23bb33e5b36c",
        "parentId" : "9f8c7cec-51ca-4e7c-badf-237a67a0c555",
        "authorId" : "ac2c92fd-803c-4666-96b1-db1044c762c5",
        "body" : "Yep, `new Future(...)` uses `Time.run` (at least, according to the [docs](https://api.dartlang.org/stable/1.24.3/dart-async/Future/Future.html)).",
        "createdAt" : "2018-01-25T22:07:51Z",
        "updatedAt" : "2018-01-25T22:07:51Z",
        "lastEditedBy" : "ac2c92fd-803c-4666-96b1-db1044c762c5",
        "tags" : [
        ]
      },
      {
        "id" : "a4a71e92-b7f4-4e91-9a91-3076c6e21851",
        "parentId" : "9f8c7cec-51ca-4e7c-badf-237a67a0c555",
        "authorId" : "9b5a6de7-1648-432f-a400-7a47bea935d8",
        "body" : "Aah, yeah, then it's the same. Huh. What a weird API choice.",
        "createdAt" : "2018-01-25T22:17:55Z",
        "updatedAt" : "2018-01-25T22:17:55Z",
        "lastEditedBy" : "9b5a6de7-1648-432f-a400-7a47bea935d8",
        "tags" : [
        ]
      }
    ],
    "commit" : "f985e7916fb1fee937ff92c56af6877e5f0fa544",
    "line" : 26,
    "diffHunk" : "@@ -1,1 +60,64 @@      rawLicenses.complete(rootBundle.loadString('LICENSE', cache: false));\n    });\n    await rawLicenses.future;\n    final Completer<List<LicenseEntry>> parsedLicenses = new Completer<List<LicenseEntry>>();\n    Timer.run(() async {"
  },
  {
    "id" : "e81a7c51-aea5-4f25-bb75-6c68b314ce97",
    "prId" : 37489,
    "prUrl" : "https://github.com/flutter/flutter/pull/37489#pullrequestreview-270432877",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d3ce3359-2e81-4944-8769-54203c0531ed",
        "parentId" : null,
        "authorId" : "9b5a6de7-1648-432f-a400-7a47bea935d8",
        "body" : "I think you want to flip these around. The getter should be the way to access this, to make it clear that we're not initializing a new value each time. The method should be protected, and should be called during initInstances to configure a field that defaultBinaryMessenger returns.",
        "createdAt" : "2019-08-02T17:30:05Z",
        "updatedAt" : "2019-08-09T00:48:27Z",
        "lastEditedBy" : "9b5a6de7-1648-432f-a400-7a47bea935d8",
        "tags" : [
        ]
      },
      {
        "id" : "8eb0fef5-e5be-4ecb-954b-cb13eeb26411",
        "parentId" : "d3ce3359-2e81-4944-8769-54203c0531ed",
        "authorId" : "191b853a-2a89-4c2f-ad5d-09a244d276dc",
        "body" : "Updated. I was wrong by treating the `binaryMessenger` field as private member (which is public accessible), and had this provideBinaryMessenger as the getter for it. ",
        "createdAt" : "2019-08-02T23:51:10Z",
        "updatedAt" : "2019-08-09T00:48:27Z",
        "lastEditedBy" : "191b853a-2a89-4c2f-ad5d-09a244d276dc",
        "tags" : [
        ]
      }
    ],
    "commit" : "98f08084236fcf14efd4b3951991d859642add16",
    "line" : 35,
    "diffHunk" : "@@ -1,1 +47,51 @@    return const _DefaultBinaryMessenger._();\n  }\n\n  /// Adds relevant licenses to the [LicenseRegistry].\n  ///"
  },
  {
    "id" : "cf2b5c76-16c5-4353-87a1-110e4364a0ed",
    "prId" : 37489,
    "prUrl" : "https://github.com/flutter/flutter/pull/37489#pullrequestreview-272871278",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "364ed1a6-1c31-427a-8c64-e762ac91dd58",
        "parentId" : null,
        "authorId" : "1dc608b7-5634-49db-a2de-36dd357356e8",
        "body" : "Is there a reason this can't be private?  Do we expect subclasses to override it to return a different binary messenger than the default?",
        "createdAt" : "2019-08-08T19:01:42Z",
        "updatedAt" : "2019-08-09T00:48:27Z",
        "lastEditedBy" : "1dc608b7-5634-49db-a2de-36dd357356e8",
        "tags" : [
        ]
      },
      {
        "id" : "61dd5cc6-f7c2-45e1-9b33-a21c909a4e7e",
        "parentId" : "364ed1a6-1c31-427a-8c64-e762ac91dd58",
        "authorId" : "191b853a-2a89-4c2f-ad5d-09a244d276dc",
        "body" : "Ya, exactly. We'll want to set a different binary messenger for the ServicesBinding used in tests.",
        "createdAt" : "2019-08-08T22:32:54Z",
        "updatedAt" : "2019-08-09T00:48:27Z",
        "lastEditedBy" : "191b853a-2a89-4c2f-ad5d-09a244d276dc",
        "tags" : [
        ]
      }
    ],
    "commit" : "98f08084236fcf14efd4b3951991d859642add16",
    "line" : 31,
    "diffHunk" : "@@ -1,1 +43,47 @@  /// Creates a default [BinaryMessenger] instance that can be used for sending\n  /// platform messages.\n  @protected\n  BinaryMessenger createBinaryMessenger() {\n    return const _DefaultBinaryMessenger._();"
  }
]
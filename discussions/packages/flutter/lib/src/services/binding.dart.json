[
  {
    "id" : "b7a9e631-399e-4381-b89f-a7a88c12fbb7",
    "prId" : 6413,
    "prUrl" : "https://github.com/flutter/flutter/pull/6413#pullrequestreview-5340491",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "28d6c4f6-6f5a-4ede-b0ad-60778d3d8285",
        "parentId" : null,
        "authorId" : "1dc608b7-5634-49db-a2de-36dd357356e8",
        "body" : "Docs out of date\n",
        "createdAt" : "2016-10-22T01:26:14Z",
        "updatedAt" : "2016-10-22T01:26:14Z",
        "lastEditedBy" : "1dc608b7-5634-49db-a2de-36dd357356e8",
        "tags" : [
        ]
      }
    ],
    "commit" : "8559b3eb675a942cf4a3c9f94c8b8a9b29f3bbdf",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +12,16 @@import 'platform_messages.dart';\n\n/// Ensures that the [MojoShell] singleton is created synchronously\n/// during binding initialization. This allows other binding classes\n/// to register services in the same call stack as the services are"
  },
  {
    "id" : "22e23224-ca8d-4004-bfb0-06d9c0c3990e",
    "prId" : 14206,
    "prUrl" : "https://github.com/flutter/flutter/pull/14206#pullrequestreview-91691544",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9f8c7cec-51ca-4e7c-badf-237a67a0c555",
        "parentId" : null,
        "authorId" : "ac2c92fd-803c-4666-96b1-db1044c762c5",
        "body" : "I think this is the same as `new Future(... logic ...)`. Does not require a completer.",
        "createdAt" : "2018-01-22T22:58:42Z",
        "updatedAt" : "2018-01-22T22:58:53Z",
        "lastEditedBy" : "ac2c92fd-803c-4666-96b1-db1044c762c5",
        "tags" : [
        ]
      },
      {
        "id" : "fe9d9dc1-9732-4380-a71b-ba374ee52d6c",
        "parentId" : "9f8c7cec-51ca-4e7c-badf-237a67a0c555",
        "authorId" : "9b5a6de7-1648-432f-a400-7a47bea935d8",
        "body" : "Not sure I understand what you mean. Can you show a snippet of how you'd use `new Future` to do this?",
        "createdAt" : "2018-01-23T00:54:39Z",
        "updatedAt" : "2018-01-23T00:54:39Z",
        "lastEditedBy" : "9b5a6de7-1648-432f-a400-7a47bea935d8",
        "tags" : [
        ]
      },
      {
        "id" : "42517f86-8bb8-4ff2-a683-7d03a5425465",
        "parentId" : "9f8c7cec-51ca-4e7c-badf-237a67a0c555",
        "authorId" : "ac2c92fd-803c-4666-96b1-db1044c762c5",
        "body" : "I may be missing something, but was thinking this:\r\n\r\n```dart\r\n// The callback passed to `new Future` is passed to Timer.run.\r\nfinal String rawLicenses = await new Future<String>(\r\n  () => rootBundle.loadString('LICENSE', cache: false),\r\n);\r\nfinal List<LicenseEntry> parsedLicenses = await new Future<List<LicenseEntry>>(\r\n  () => compute(_parseLicenses, rawLicenses, debugLabel: 'parseLicenses'),\r\n);\r\n```\r\n",
        "createdAt" : "2018-01-23T01:21:34Z",
        "updatedAt" : "2018-01-23T01:22:19Z",
        "lastEditedBy" : "ac2c92fd-803c-4666-96b1-db1044c762c5",
        "tags" : [
        ]
      },
      {
        "id" : "8976f477-56ea-4ca5-9a96-0e28b0bc2f39",
        "parentId" : "9f8c7cec-51ca-4e7c-badf-237a67a0c555",
        "authorId" : "ac2c92fd-803c-4666-96b1-db1044c762c5",
        "body" : "[update: fixed the code a little]",
        "createdAt" : "2018-01-23T01:22:45Z",
        "updatedAt" : "2018-01-23T01:22:51Z",
        "lastEditedBy" : "ac2c92fd-803c-4666-96b1-db1044c762c5",
        "tags" : [
        ]
      },
      {
        "id" : "ca96f0c8-40ac-4c61-91dc-8241c649ba80",
        "parentId" : "9f8c7cec-51ca-4e7c-badf-237a67a0c555",
        "authorId" : "9b5a6de7-1648-432f-a400-7a47bea935d8",
        "body" : "If you don't use `Timer.run`, you're using microtasks, which all run before the next event loop iteration, and thus it becomes impossible for the engine to render a frame between the first future `compute` completing the future and the second starting its isolate, both of which are very expensive operations (see the bugs linked to in the comment).",
        "createdAt" : "2018-01-25T21:50:25Z",
        "updatedAt" : "2018-01-25T21:50:25Z",
        "lastEditedBy" : "9b5a6de7-1648-432f-a400-7a47bea935d8",
        "tags" : [
        ]
      },
      {
        "id" : "cbe81cb2-aca3-4136-9d17-80613ca5df4a",
        "parentId" : "9f8c7cec-51ca-4e7c-badf-237a67a0c555",
        "authorId" : "9b5a6de7-1648-432f-a400-7a47bea935d8",
        "body" : "Or to put it another way, there's no difference between your code and:\r\n```dart\r\nfinal String rawLicenses = await rootBundle.loadString('LICENSE', cache: false);\r\nfinal List<LicenseEntry> parsedLicenses = await compute(_parseLicenses, rawLicenses, debugLabel: 'parseLicenses');\r\n```\r\n...which is what it was before. :-)",
        "createdAt" : "2018-01-25T21:51:27Z",
        "updatedAt" : "2018-01-25T21:51:28Z",
        "lastEditedBy" : "9b5a6de7-1648-432f-a400-7a47bea935d8",
        "tags" : [
        ]
      },
      {
        "id" : "36d05685-1d24-4441-8266-23bb33e5b36c",
        "parentId" : "9f8c7cec-51ca-4e7c-badf-237a67a0c555",
        "authorId" : "ac2c92fd-803c-4666-96b1-db1044c762c5",
        "body" : "Yep, `new Future(...)` uses `Time.run` (at least, according to the [docs](https://api.dartlang.org/stable/1.24.3/dart-async/Future/Future.html)).",
        "createdAt" : "2018-01-25T22:07:51Z",
        "updatedAt" : "2018-01-25T22:07:51Z",
        "lastEditedBy" : "ac2c92fd-803c-4666-96b1-db1044c762c5",
        "tags" : [
        ]
      },
      {
        "id" : "a4a71e92-b7f4-4e91-9a91-3076c6e21851",
        "parentId" : "9f8c7cec-51ca-4e7c-badf-237a67a0c555",
        "authorId" : "9b5a6de7-1648-432f-a400-7a47bea935d8",
        "body" : "Aah, yeah, then it's the same. Huh. What a weird API choice.",
        "createdAt" : "2018-01-25T22:17:55Z",
        "updatedAt" : "2018-01-25T22:17:55Z",
        "lastEditedBy" : "9b5a6de7-1648-432f-a400-7a47bea935d8",
        "tags" : [
        ]
      }
    ],
    "commit" : "f985e7916fb1fee937ff92c56af6877e5f0fa544",
    "line" : 26,
    "diffHunk" : "@@ -1,1 +60,64 @@      rawLicenses.complete(rootBundle.loadString('LICENSE', cache: false));\n    });\n    await rawLicenses.future;\n    final Completer<List<LicenseEntry>> parsedLicenses = new Completer<List<LicenseEntry>>();\n    Timer.run(() async {"
  },
  {
    "id" : "e81a7c51-aea5-4f25-bb75-6c68b314ce97",
    "prId" : 37489,
    "prUrl" : "https://github.com/flutter/flutter/pull/37489#pullrequestreview-270432877",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d3ce3359-2e81-4944-8769-54203c0531ed",
        "parentId" : null,
        "authorId" : "9b5a6de7-1648-432f-a400-7a47bea935d8",
        "body" : "I think you want to flip these around. The getter should be the way to access this, to make it clear that we're not initializing a new value each time. The method should be protected, and should be called during initInstances to configure a field that defaultBinaryMessenger returns.",
        "createdAt" : "2019-08-02T17:30:05Z",
        "updatedAt" : "2019-08-09T00:48:27Z",
        "lastEditedBy" : "9b5a6de7-1648-432f-a400-7a47bea935d8",
        "tags" : [
        ]
      },
      {
        "id" : "8eb0fef5-e5be-4ecb-954b-cb13eeb26411",
        "parentId" : "d3ce3359-2e81-4944-8769-54203c0531ed",
        "authorId" : "191b853a-2a89-4c2f-ad5d-09a244d276dc",
        "body" : "Updated. I was wrong by treating the `binaryMessenger` field as private member (which is public accessible), and had this provideBinaryMessenger as the getter for it. ",
        "createdAt" : "2019-08-02T23:51:10Z",
        "updatedAt" : "2019-08-09T00:48:27Z",
        "lastEditedBy" : "191b853a-2a89-4c2f-ad5d-09a244d276dc",
        "tags" : [
        ]
      }
    ],
    "commit" : "98f08084236fcf14efd4b3951991d859642add16",
    "line" : 35,
    "diffHunk" : "@@ -1,1 +47,51 @@    return const _DefaultBinaryMessenger._();\n  }\n\n  /// Adds relevant licenses to the [LicenseRegistry].\n  ///"
  },
  {
    "id" : "cf2b5c76-16c5-4353-87a1-110e4364a0ed",
    "prId" : 37489,
    "prUrl" : "https://github.com/flutter/flutter/pull/37489#pullrequestreview-272871278",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "364ed1a6-1c31-427a-8c64-e762ac91dd58",
        "parentId" : null,
        "authorId" : "1dc608b7-5634-49db-a2de-36dd357356e8",
        "body" : "Is there a reason this can't be private?  Do we expect subclasses to override it to return a different binary messenger than the default?",
        "createdAt" : "2019-08-08T19:01:42Z",
        "updatedAt" : "2019-08-09T00:48:27Z",
        "lastEditedBy" : "1dc608b7-5634-49db-a2de-36dd357356e8",
        "tags" : [
        ]
      },
      {
        "id" : "61dd5cc6-f7c2-45e1-9b33-a21c909a4e7e",
        "parentId" : "364ed1a6-1c31-427a-8c64-e762ac91dd58",
        "authorId" : "191b853a-2a89-4c2f-ad5d-09a244d276dc",
        "body" : "Ya, exactly. We'll want to set a different binary messenger for the ServicesBinding used in tests.",
        "createdAt" : "2019-08-08T22:32:54Z",
        "updatedAt" : "2019-08-09T00:48:27Z",
        "lastEditedBy" : "191b853a-2a89-4c2f-ad5d-09a244d276dc",
        "tags" : [
        ]
      }
    ],
    "commit" : "98f08084236fcf14efd4b3951991d859642add16",
    "line" : 31,
    "diffHunk" : "@@ -1,1 +43,47 @@  /// Creates a default [BinaryMessenger] instance that can be used for sending\n  /// platform messages.\n  @protected\n  BinaryMessenger createBinaryMessenger() {\n    return const _DefaultBinaryMessenger._();"
  },
  {
    "id" : "9e800a5e-c49d-4b64-bbee-21af6e31d34f",
    "prId" : 40165,
    "prUrl" : "https://github.com/flutter/flutter/pull/40165#pullrequestreview-289197559",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ec8ce66a-194a-423d-ba55-17d6fd9dcdfe",
        "parentId" : null,
        "authorId" : "291e083f-dfb6-49b2-b8f5-2f0ce7f9b936",
        "body" : "Since this is an entirely new API that we built and we can make it do anything we want, how about:\r\n\r\nMake the dart:ui side always push all messages into the buffer unless that one channel had its buffer drained at least once. i.e., instead of switching on onPlatformMessage being null or not, just always push into the channelBuffers. In the channel buffers, keep a list of channels that's been drained. If drained once, stop queueing more into it. We can rename that thing DrainOnceChannelBuffer or something to make it clear. \r\n\r\nThe main advantage would be it being self-contained and not needing orchestration from both sides to function. \r\n\r\nWhat do you think?",
        "createdAt" : "2019-09-17T00:24:00Z",
        "updatedAt" : "2019-09-19T19:05:27Z",
        "lastEditedBy" : "291e083f-dfb6-49b2-b8f5-2f0ce7f9b936",
        "tags" : [
        ]
      },
      {
        "id" : "67e7599a-27b0-48c5-8fd9-96b1a202442c",
        "parentId" : "ec8ce66a-194a-423d-ba55-17d6fd9dcdfe",
        "authorId" : "b565e8d4-349d-472b-89fe-c7310f57516e",
        "body" : "An interesting idea.  I've thought of something similar where all messages are put into channel buffers as part of normal message passing.  I decided against that since it's kind of wasteful to use channelBuffers when we don't need to.  Communicating via the callstack seems safer.\r\n\r\nResponding more directly, it doesn't eliminate orchestration since we still need to drain here.  I think it is a bit harder to follow logically.  Given 2 options I usually prefer the option that results in less state.  Many bugs come from bad stored state because it's harder to reason about when reading code, more stored state means more chances for bugs.",
        "createdAt" : "2019-09-17T01:34:50Z",
        "updatedAt" : "2019-09-19T19:05:27Z",
        "lastEditedBy" : "b565e8d4-349d-472b-89fe-c7310f57516e",
        "tags" : [
        ]
      },
      {
        "id" : "88780601-f17e-4f10-9885-2a1e995f1837",
        "parentId" : "ec8ce66a-194a-423d-ba55-17d6fd9dcdfe",
        "authorId" : "291e083f-dfb6-49b2-b8f5-2f0ce7f9b936",
        "body" : "Ok SG. \r\n\r\nLet's add some tests on this current mechanism",
        "createdAt" : "2019-09-17T11:37:11Z",
        "updatedAt" : "2019-09-19T19:05:27Z",
        "lastEditedBy" : "291e083f-dfb6-49b2-b8f5-2f0ce7f9b936",
        "tags" : [
        ]
      }
    ],
    "commit" : "4c5b264091899bc8d162b0a666dade0e69a2ff29",
    "line" : 8,
    "diffHunk" : "@@ -1,1 +190,194 @@        response = await handler(data);\n      } else {\n        ui.channelBuffers.push(channel, data, callback);\n      }\n    } catch (exception, stack) {"
  },
  {
    "id" : "f8af1467-f2cf-491b-84cc-b84b0588163b",
    "prId" : 40165,
    "prUrl" : "https://github.com/flutter/flutter/pull/40165#pullrequestreview-290795871",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0b0ff7ea-51e4-4d07-945d-cd92d2e1df00",
        "parentId" : null,
        "authorId" : "291e083f-dfb6-49b2-b8f5-2f0ce7f9b936",
        "body" : "Add some code comments for what's going on here",
        "createdAt" : "2019-09-19T19:33:42Z",
        "updatedAt" : "2019-09-20T00:18:18Z",
        "lastEditedBy" : "291e083f-dfb6-49b2-b8f5-2f0ce7f9b936",
        "tags" : [
        ]
      }
    ],
    "commit" : "4c5b264091899bc8d162b0a666dade0e69a2ff29",
    "line" : 8,
    "diffHunk" : "@@ -1,1 +190,194 @@        response = await handler(data);\n      } else {\n        ui.channelBuffers.push(channel, data, callback);\n      }\n    } catch (exception, stack) {"
  },
  {
    "id" : "a58f4b97-0609-4db5-bd29-6005d72f0ea7",
    "prId" : 40165,
    "prUrl" : "https://github.com/flutter/flutter/pull/40165#pullrequestreview-290795871",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ae6d04c5-9c67-49b3-9953-c1600101baa3",
        "parentId" : null,
        "authorId" : "291e083f-dfb6-49b2-b8f5-2f0ce7f9b936",
        "body" : "People might be lost reading at this point since it's crossing the boundaries a few times. Add some code comments for what this await here does.",
        "createdAt" : "2019-09-19T19:34:33Z",
        "updatedAt" : "2019-09-20T00:18:19Z",
        "lastEditedBy" : "291e083f-dfb6-49b2-b8f5-2f0ce7f9b936",
        "tags" : [
        ]
      }
    ],
    "commit" : "4c5b264091899bc8d162b0a666dade0e69a2ff29",
    "line" : 18,
    "diffHunk" : "@@ -1,1 +219,223 @@      _handlers[channel] = handler;\n    ui.channelBuffers.drain(channel, (ByteData data, ui.PlatformMessageResponseCallback callback) async {\n      await handlePlatformMessage(channel, data, callback);\n    });\n  }"
  },
  {
    "id" : "46a6938b-ef3b-4504-801f-2ab8c04b758f",
    "prId" : 54493,
    "prUrl" : "https://github.com/flutter/flutter/pull/54493#pullrequestreview-395822591",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1e2f56d8-f1b2-40ee-831c-06b5e2498d0f",
        "parentId" : null,
        "authorId" : "e0434781-f3ea-47e1-a154-a4678df4de4e",
        "body" : "Not sure whether this is the right priority",
        "createdAt" : "2020-04-10T21:31:17Z",
        "updatedAt" : "2020-04-18T16:07:58Z",
        "lastEditedBy" : "e0434781-f3ea-47e1-a154-a4678df4de4e",
        "tags" : [
        ]
      },
      {
        "id" : "16aafc3d-12f1-4d89-8f16-ef08b79e8a91",
        "parentId" : "1e2f56d8-f1b2-40ee-831c-06b5e2498d0f",
        "authorId" : "d61ab95a-0bf0-4571-9098-19991dd821ca",
        "body" : "Seems like the right priority. ",
        "createdAt" : "2020-04-17T23:21:07Z",
        "updatedAt" : "2020-04-18T16:07:58Z",
        "lastEditedBy" : "d61ab95a-0bf0-4571-9098-19991dd821ca",
        "tags" : [
        ]
      }
    ],
    "commit" : "81d49a6d19ca1ad8a7e71677946b24ea02d3a377",
    "line" : 22,
    "diffHunk" : "@@ -1,1 +103,107 @@    scheduleTask(() async {\n      rawLicenses.complete(rootBundle.loadString('LICENSE', cache: false));\n    }, Priority.animation);\n    await rawLicenses.future;\n    final Completer<List<LicenseEntry>> parsedLicenses = Completer<List<LicenseEntry>>();"
  }
]
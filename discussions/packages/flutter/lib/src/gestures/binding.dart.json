[
  {
    "id" : "084cd98a-8590-4363-8fad-d1c7b886625a",
    "prId" : 902,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1d75e382-e5c9-4992-8795-e4b5c26c17f2",
        "parentId" : null,
        "authorId" : "0a6b99c1-e18d-4971-abe3-b52228030462",
        "body" : "Pointerer is kind of a goofy name.  PointerBinding?\n",
        "createdAt" : "2015-12-14T05:50:47Z",
        "updatedAt" : "2015-12-14T07:35:35Z",
        "lastEditedBy" : "0a6b99c1-e18d-4971-abe3-b52228030462",
        "tags" : [
        ]
      },
      {
        "id" : "6b67b487-6401-47bf-a4d7-1fd5819fb893",
        "parentId" : "1d75e382-e5c9-4992-8795-e4b5c26c17f2",
        "authorId" : "9b5a6de7-1648-432f-a400-7a47bea935d8",
        "body" : "Yeah, Pointerer was my placeholder name. I was thinking maybe Gesturer?\n\nI'm trying to keep a consistent naming scheme between the various binding mixins. There's one in the scheduler library, one in the gestures library, one in the rendering library, and maybe one in the widgets library, though at the moment I'm not using a mixin for the last one, that's a concrete class. (There's also a concrete class at the rendering level though that one just brings in the mixins without additional logic involved.)\n",
        "createdAt" : "2015-12-14T06:06:05Z",
        "updatedAt" : "2015-12-14T07:35:35Z",
        "lastEditedBy" : "9b5a6de7-1648-432f-a400-7a47bea935d8",
        "tags" : [
        ]
      }
    ],
    "commit" : "ade93651ac31fc7826474a149b804366aee475ca",
    "line" : 19,
    "diffHunk" : "@@ -1,1 +17,21 @@import 'pointer_router.dart';\n\nabstract class Pointerer extends BindingBase implements HitTestTarget, HitTestable {\n\n  void initInstances() {"
  },
  {
    "id" : "7e143cec-c204-488e-b396-5b1f39200109",
    "prId" : 24830,
    "prUrl" : "https://github.com/flutter/flutter/pull/24830#pullrequestreview-193896282",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7b40192d-0973-43d3-a3fa-ead01c12a469",
        "parentId" : null,
        "authorId" : "9b5a6de7-1648-432f-a400-7a47bea935d8",
        "body" : "do we expect this to be useful long term?",
        "createdAt" : "2019-01-17T23:40:07Z",
        "updatedAt" : "2019-01-29T15:55:30Z",
        "lastEditedBy" : "9b5a6de7-1648-432f-a400-7a47bea935d8",
        "tags" : [
        ]
      },
      {
        "id" : "30c2dfb4-839a-40b0-ba6e-7ea9af619133",
        "parentId" : "7b40192d-0973-43d3-a3fa-ead01c12a469",
        "authorId" : "fd82dff4-bfc7-4076-8507-e7e4521446f2",
        "body" : "Yes, I do think that people building interfaces will occasionally want to see the hover events as they occur.",
        "createdAt" : "2019-01-17T23:48:10Z",
        "updatedAt" : "2019-01-29T15:55:30Z",
        "lastEditedBy" : "fd82dff4-bfc7-4076-8507-e7e4521446f2",
        "tags" : [
        ]
      }
    ],
    "commit" : "f684a923245b2b3f1be91086d491a0128fd641fd",
    "line" : 38,
    "diffHunk" : "@@ -1,1 +142,146 @@        debugPrint('$event');\n      return true;\n    }());\n    if (hitTestResult != null ||\n        event is PointerHoverEvent ||"
  },
  {
    "id" : "d96402d0-7621-4c50-a487-0ddb5f86fd8b",
    "prId" : 24830,
    "prUrl" : "https://github.com/flutter/flutter/pull/24830#pullrequestreview-195193406",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8af8792f-7a2b-4ede-a636-13de85898dbe",
        "parentId" : null,
        "authorId" : "9b5a6de7-1648-432f-a400-7a47bea935d8",
        "body" : "this seems like a major change? don't we want to be dispatching other events anymore?",
        "createdAt" : "2019-01-17T23:41:30Z",
        "updatedAt" : "2019-01-29T15:55:30Z",
        "lastEditedBy" : "9b5a6de7-1648-432f-a400-7a47bea935d8",
        "tags" : [
        ]
      },
      {
        "id" : "7ff83c4b-e294-46fb-91cc-5e995ab57994",
        "parentId" : "8af8792f-7a2b-4ede-a636-13de85898dbe",
        "authorId" : "fd82dff4-bfc7-4076-8507-e7e4521446f2",
        "body" : "It's not a major change: all events that have a hit test result will still be processed as before. This is saying \"dispatch the event if there is hit test information [as before], or if there is a PointerHoverEvent, PointerAddedEvent or PointerRemovedEvent that doesn't have hit test information\".  I have broadened the conditional this way because unlike other events, these three events are meant to be dispatched even when they don't have hit test information. They weren't being handled before.",
        "createdAt" : "2019-01-17T23:52:05Z",
        "updatedAt" : "2019-01-29T15:55:30Z",
        "lastEditedBy" : "fd82dff4-bfc7-4076-8507-e7e4521446f2",
        "tags" : [
        ]
      },
      {
        "id" : "a26aff55-ecc8-47f0-8ea9-51b503311b94",
        "parentId" : "8af8792f-7a2b-4ede-a636-13de85898dbe",
        "authorId" : "9b5a6de7-1648-432f-a400-7a47bea935d8",
        "body" : "Oh, I see. `!= null` covers the previously covered cases. Got it.",
        "createdAt" : "2019-01-22T19:35:57Z",
        "updatedAt" : "2019-01-29T15:55:30Z",
        "lastEditedBy" : "9b5a6de7-1648-432f-a400-7a47bea935d8",
        "tags" : [
        ]
      }
    ],
    "commit" : "f684a923245b2b3f1be91086d491a0128fd641fd",
    "line" : 44,
    "diffHunk" : "@@ -1,1 +148,152 @@        event is PointerRemovedEvent) {\n      dispatchEvent(event, hitTestResult);\n    }\n  }\n"
  },
  {
    "id" : "a9626983-a080-4e24-a360-26bd8e09acc0",
    "prId" : 24830,
    "prUrl" : "https://github.com/flutter/flutter/pull/24830#pullrequestreview-195690145",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9fcd666d-9660-4318-b9f6-3eb67cf64670",
        "parentId" : null,
        "authorId" : "d61ab95a-0bf0-4571-9098-19991dd821ca",
        "body" : "The documentation above this line probably needs updating. It claims that results must not be null, but the first line of the method implements logic for when it is null.",
        "createdAt" : "2019-01-23T00:16:36Z",
        "updatedAt" : "2019-01-29T15:55:30Z",
        "lastEditedBy" : "d61ab95a-0bf0-4571-9098-19991dd821ca",
        "tags" : [
        ]
      },
      {
        "id" : "515f534a-5d9f-4abb-876f-dba47568979e",
        "parentId" : "9fcd666d-9660-4318-b9f6-3eb67cf64670",
        "authorId" : "fd82dff4-bfc7-4076-8507-e7e4521446f2",
        "body" : "Done.",
        "createdAt" : "2019-01-23T19:01:00Z",
        "updatedAt" : "2019-01-29T15:55:30Z",
        "lastEditedBy" : "fd82dff4-bfc7-4076-8507-e7e4521446f2",
        "tags" : [
        ]
      }
    ],
    "commit" : "f684a923245b2b3f1be91086d491a0128fd641fd",
    "line" : 61,
    "diffHunk" : "@@ -1,1 +163,167 @@  /// might throw. The [hitTestResult] argument may only be null for\n  /// [PointerHoverEvent], [PointerAddedEvent], or [PointerRemovedEvent] events.\n  @override // from HitTestDispatcher\n  void dispatchEvent(PointerEvent event, HitTestResult hitTestResult) {\n    assert(!locked);"
  },
  {
    "id" : "d56d9f3f-78be-48bb-a802-7394654376e3",
    "prId" : 24830,
    "prUrl" : "https://github.com/flutter/flutter/pull/24830#pullrequestreview-197310249",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "560b27d5-adf5-4982-b018-8a9f77767dd1",
        "parentId" : null,
        "authorId" : "d61ab95a-0bf0-4571-9098-19991dd821ca",
        "body" : "Should this comment (and the doc comment above) be expressed as an assert?",
        "createdAt" : "2019-01-25T20:37:14Z",
        "updatedAt" : "2019-01-29T15:55:30Z",
        "lastEditedBy" : "d61ab95a-0bf0-4571-9098-19991dd821ca",
        "tags" : [
        ]
      },
      {
        "id" : "73d930cd-6931-4d72-ac08-0482196072bd",
        "parentId" : "560b27d5-adf5-4982-b018-8a9f77767dd1",
        "authorId" : "fd82dff4-bfc7-4076-8507-e7e4521446f2",
        "body" : "Sure.",
        "createdAt" : "2019-01-28T23:24:50Z",
        "updatedAt" : "2019-01-29T15:55:30Z",
        "lastEditedBy" : "fd82dff4-bfc7-4076-8507-e7e4521446f2",
        "tags" : [
        ]
      }
    ],
    "commit" : "f684a923245b2b3f1be91086d491a0128fd641fd",
    "line" : 67,
    "diffHunk" : "@@ -1,1 +166,170 @@  void dispatchEvent(PointerEvent event, HitTestResult hitTestResult) {\n    assert(!locked);\n    // No hit test information implies that this is a hover or pointer\n    // add/remove event.\n    if (hitTestResult == null) {"
  },
  {
    "id" : "5ca7a801-2622-487f-82a3-2b726148b506",
    "prId" : 60558,
    "prUrl" : "https://github.com/flutter/flutter/pull/60558#pullrequestreview-467613921",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a5c17d4f-b7a1-48ec-9b91-7e3d33ec23cf",
        "parentId" : null,
        "authorId" : "f76bcc8a-9965-41ac-ba63-53a03a848567",
        "body" : "So should this number depend on the frame refresh rate? e.g. on 90Hz device like Pixel 4, should this be smaller? ",
        "createdAt" : "2020-08-14T13:10:27Z",
        "updatedAt" : "2020-08-23T18:41:33Z",
        "lastEditedBy" : "f76bcc8a-9965-41ac-ba63-53a03a848567",
        "tags" : [
        ]
      },
      {
        "id" : "bbab8dbe-2ad6-409c-a184-b8d62296b8f5",
        "parentId" : "a5c17d4f-b7a1-48ec-9b91-7e3d33ec23cf",
        "authorId" : "fdee1bed-4587-4bf9-ba6a-db6822c78fc0",
        "body" : "The ideal value typically depend on:\r\n\r\n1. Sensor frequency.\r\n2. Platform processing overhead. E.g. how long does it take for the event to arrive here.\r\n3. The amount of input latency that an app is willing to add for smooth event processing.\r\n\r\nBest way to find a good default values here are through experimentation. The value used by default for now has been proven to work well on Fuchsia systems where the sensor is ~60hz. Shorter duration will result in poor resampling results as it becomes more likely that we don't have events queued that can be used for resampling.",
        "createdAt" : "2020-08-14T13:27:21Z",
        "updatedAt" : "2020-08-23T18:41:33Z",
        "lastEditedBy" : "fdee1bed-4587-4bf9-ba6a-db6822c78fc0",
        "tags" : [
        ]
      },
      {
        "id" : "cb772331-1767-4b71-ae25-9e2a5b09b9aa",
        "parentId" : "a5c17d4f-b7a1-48ec-9b91-7e3d33ec23cf",
        "authorId" : "fdee1bed-4587-4bf9-ba6a-db6822c78fc0",
        "body" : "We could reduce this to -21.333 and add refresh rate interval on top of it. Not sure that's much better though as the 21.333 value is still what needs to be determined through testing. We currently add 16.667 to this value here assuming that we start producing a frame for the currentSystemFrameTimeStamp at that offset. That's not the best assumption but making it \"1000 / refreshRate\" is also not good as that gives the appearance that we're always using the interval as frame scheduling offset.",
        "createdAt" : "2020-08-14T14:20:31Z",
        "updatedAt" : "2020-08-23T18:41:33Z",
        "lastEditedBy" : "fdee1bed-4587-4bf9-ba6a-db6822c78fc0",
        "tags" : [
        ]
      }
    ],
    "commit" : "b7802f69f91e1b5466d6b5b58e98193160964ca5",
    "line" : 136,
    "diffHunk" : "@@ -1,1 +142,146 @@// is 33.334 ms. This however assumes zero latency from the input driver.\n// 4.666 ms margin is added for this.\nconst Duration _defaultSamplingOffset = Duration(milliseconds: -38);\n\n/// A binding for the gesture subsystem."
  },
  {
    "id" : "eca0b48d-c4ea-439e-bbd4-ec2bd40f4e01",
    "prId" : 60558,
    "prUrl" : "https://github.com/flutter/flutter/pull/60558#pullrequestreview-467743509",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6e5452a2-b31d-4a3e-95f2-4bdcbea94939",
        "parentId" : null,
        "authorId" : "f76bcc8a-9965-41ac-ba63-53a03a848567",
        "body" : "If this offset can be device refresh rate dependent, should we also calculate this number instead of set a fixed one? I was told we can get the refresh rate from a service protocol extension `_flutter.getDisplayRefreshRate`, if that information is somewhat helpful. ",
        "createdAt" : "2020-08-14T13:20:21Z",
        "updatedAt" : "2020-08-23T18:41:33Z",
        "lastEditedBy" : "f76bcc8a-9965-41ac-ba63-53a03a848567",
        "tags" : [
        ]
      },
      {
        "id" : "77ae00e9-58d0-4010-9e63-bf31385fc5bd",
        "parentId" : "6e5452a2-b31d-4a3e-95f2-4bdcbea94939",
        "authorId" : "fdee1bed-4587-4bf9-ba6a-db6822c78fc0",
        "body" : "Refresh rate is not meaningful for this offset. input sensor frequency is but that's not something that platforms typically expose.\r\n\r\nI think we should create a follow up task to determine good default values for different devices. The best way to do that is likely through some automatic test that can also be used to detect regressions. Automatic test is how the current default value was established on Fuchsia.",
        "createdAt" : "2020-08-14T13:30:50Z",
        "updatedAt" : "2020-08-23T18:41:33Z",
        "lastEditedBy" : "fdee1bed-4587-4bf9-ba6a-db6822c78fc0",
        "tags" : [
        ]
      },
      {
        "id" : "8dfc40ae-9644-4de5-92b8-44a10d8ad7f1",
        "parentId" : "6e5452a2-b31d-4a3e-95f2-4bdcbea94939",
        "authorId" : "f76bcc8a-9965-41ac-ba63-53a03a848567",
        "body" : "So as a particular case, Pixel4 has input frequency about 120Hz, and refresh rate 90Hz, and one use case we are planning for the resampler is to help resample this 120Hz input to 90Hz, for better scrolling smoothness. Does this sounds like need a smaller `samplingOffset`?",
        "createdAt" : "2020-08-14T13:57:01Z",
        "updatedAt" : "2020-08-23T18:41:33Z",
        "lastEditedBy" : "f76bcc8a-9965-41ac-ba63-53a03a848567",
        "tags" : [
        ]
      },
      {
        "id" : "997c7570-b924-4ddd-abf6-2421fda51885",
        "parentId" : "6e5452a2-b31d-4a3e-95f2-4bdcbea94939",
        "authorId" : "fdee1bed-4587-4bf9-ba6a-db6822c78fc0",
        "body" : "samplingOffset being too large will not hurt smoothness but it will hurt input latency so it's in our interest to keep it as low as possible while still making sure resampling works well.\r\n\r\nIf input frequency is 120Hz then we need 8.333 ms to ensure that we have 2 input events that can be used for resampling. We need some margin for events to be delivered from the input driver to flutter. Let's use 4.667 ms to account for the situation when device is under heavy load. 90Hz doesn't really affect anything but I'd guess that the app [VSYNC â€” App reads input and generates next frame](https://source.android.com/devices/graphics/implement-vsync) (when flutter produces a frame) is relatively low on a device with that refresh rate. Let's guess 9 ms.\r\n\r\nGiven above, I'd try using samplingOffset=Duration(milliseconds: -22);  // 8.333 + 4.667 + 9",
        "createdAt" : "2020-08-14T17:21:18Z",
        "updatedAt" : "2020-08-23T18:41:33Z",
        "lastEditedBy" : "fdee1bed-4587-4bf9-ba6a-db6822c78fc0",
        "tags" : [
        ]
      }
    ],
    "commit" : "b7802f69f91e1b5466d6b5b58e98193160964ca5",
    "line" : 193,
    "diffHunk" : "@@ -1,1 +395,399 @@  /// Non-negative [samplingOffset] is allowed but will effectively\n  /// disable resampling.\n  Duration samplingOffset = _defaultSamplingOffset;\n}\n"
  },
  {
    "id" : "29928762-b860-4c13-abcc-45e3e9615b6a",
    "prId" : 60558,
    "prUrl" : "https://github.com/flutter/flutter/pull/60558#pullrequestreview-469491006",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bf06e23f-2790-4263-aa87-6336893c5f56",
        "parentId" : null,
        "authorId" : "d61ab95a-0bf0-4571-9098-19991dd821ca",
        "body" : "Add to the docs: When would I typically set this to true if I want resampling? e.g. before runApp?",
        "createdAt" : "2020-08-17T18:27:37Z",
        "updatedAt" : "2020-08-23T18:41:33Z",
        "lastEditedBy" : "d61ab95a-0bf0-4571-9098-19991dd821ca",
        "tags" : [
        ]
      },
      {
        "id" : "10a82968-1a5a-498e-9f37-8077ad7683f4",
        "parentId" : "bf06e23f-2790-4263-aa87-6336893c5f56",
        "authorId" : "fdee1bed-4587-4bf9-ba6a-db6822c78fc0",
        "body" : "Done. Typically during initialization but can also be changed dynamically if desired. Also made some minor updates to the code to handle dynamic changes better.",
        "createdAt" : "2020-08-18T14:06:57Z",
        "updatedAt" : "2020-08-23T18:41:33Z",
        "lastEditedBy" : "fdee1bed-4587-4bf9-ba6a-db6822c78fc0",
        "tags" : [
        ]
      }
    ],
    "commit" : "b7802f69f91e1b5466d6b5b58e98193160964ca5",
    "line" : 187,
    "diffHunk" : "@@ -1,1 +389,393 @@  /// can be adjusted dynamically in case the application only\n  /// wants resampling for some period of time.\n  bool resamplingEnabled = false;\n\n  /// Offset relative to current frame time that should be used for"
  },
  {
    "id" : "8dfeafbc-2c51-4817-a0c4-450d7575a80b",
    "prId" : 60558,
    "prUrl" : "https://github.com/flutter/flutter/pull/60558#pullrequestreview-472091377",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "954da619-a171-48cb-b3d0-f91a6fd96eb5",
        "parentId" : null,
        "authorId" : "0dfb4b67-cdbe-4905-93ea-e8b19d917e2a",
        "body" : "Can everything below also get encapsulated inside `_Resampler`?\r\n\r\nFor example, instead of calling `_resampler.addEvent(event)`, we can send in a list of events `_resampler.addEvents(_pendingPointerEvents)`. The `_resampler` can also save the callback `_handlePointerEvent` as its field so it can schedule a sample callback by its own?",
        "createdAt" : "2020-08-19T17:15:14Z",
        "updatedAt" : "2020-08-23T18:41:33Z",
        "lastEditedBy" : "0dfb4b67-cdbe-4905-93ea-e8b19d917e2a",
        "tags" : [
        ]
      },
      {
        "id" : "ce5da7af-2694-4ad0-9685-7eed5ca66ae2",
        "parentId" : "954da619-a171-48cb-b3d0-f91a6fd96eb5",
        "authorId" : "fdee1bed-4587-4bf9-ba6a-db6822c78fc0",
        "body" : "We would fail to detect when resampling is disabled in that case but we could introduce some callback cancel logic to handle that. We would also need some wrapper to ensure that we're not violating the \"if (!locked)\" condition. The overall complexity might increase but if encapsulation is highest priority then it might still make sense. Wdyt?",
        "createdAt" : "2020-08-19T22:27:13Z",
        "updatedAt" : "2020-08-23T18:41:33Z",
        "lastEditedBy" : "fdee1bed-4587-4bf9-ba6a-db6822c78fc0",
        "tags" : [
        ]
      },
      {
        "id" : "6996ad7b-9e7c-41e7-b134-888261a48767",
        "parentId" : "954da619-a171-48cb-b3d0-f91a6fd96eb5",
        "authorId" : "fdee1bed-4587-4bf9-ba6a-db6822c78fc0",
        "body" : "I did this additional encapsulation in latest version of this CL",
        "createdAt" : "2020-08-21T01:47:09Z",
        "updatedAt" : "2020-08-23T18:41:33Z",
        "lastEditedBy" : "fdee1bed-4587-4bf9-ba6a-db6822c78fc0",
        "tags" : [
        ]
      }
    ],
    "commit" : "b7802f69f91e1b5466d6b5b58e98193160964ca5",
    "line" : 154,
    "diffHunk" : "@@ -1,1 +236,240 @@    // resampling was never enabled.\n    _resampler.stop();\n\n    while (_pendingPointerEvents.isNotEmpty)\n      _handlePointerEvent(_pendingPointerEvents.removeFirst());"
  },
  {
    "id" : "2eae3755-89dd-40a7-a94a-2ec7cf80e419",
    "prId" : 60558,
    "prUrl" : "https://github.com/flutter/flutter/pull/60558#pullrequestreview-472115808",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3ae55fd1-fde7-462e-8abc-4603967cc9d6",
        "parentId" : null,
        "authorId" : "f76bcc8a-9965-41ac-ba63-53a03a848567",
        "body" : "It's immediately initialized. It seems that `late` is not necessary?",
        "createdAt" : "2020-08-21T02:18:57Z",
        "updatedAt" : "2020-08-23T18:41:33Z",
        "lastEditedBy" : "f76bcc8a-9965-41ac-ba63-53a03a848567",
        "tags" : [
        ]
      },
      {
        "id" : "ac5ebca9-c48d-42d0-80fc-0ca3b5f5760d",
        "parentId" : "3ae55fd1-fde7-462e-8abc-4603967cc9d6",
        "authorId" : "fdee1bed-4587-4bf9-ba6a-db6822c78fc0",
        "body" : "I needed this to be able to pass \"_handlePointerEvent, _handleSampleTimeChanged\" to this ctor. Let me know if there's a better way to solve that.",
        "createdAt" : "2020-08-21T02:38:14Z",
        "updatedAt" : "2020-08-23T18:41:33Z",
        "lastEditedBy" : "fdee1bed-4587-4bf9-ba6a-db6822c78fc0",
        "tags" : [
        ]
      },
      {
        "id" : "d06df2fa-06db-4f96-9d0a-c27928dcc3e1",
        "parentId" : "3ae55fd1-fde7-462e-8abc-4603967cc9d6",
        "authorId" : "f76bcc8a-9965-41ac-ba63-53a03a848567",
        "body" : "Sorry I misunderstood the keyword. ",
        "createdAt" : "2020-08-21T03:03:24Z",
        "updatedAt" : "2020-08-23T18:41:33Z",
        "lastEditedBy" : "f76bcc8a-9965-41ac-ba63-53a03a848567",
        "tags" : [
        ]
      }
    ],
    "commit" : "b7802f69f91e1b5466d6b5b58e98193160964ca5",
    "line" : 171,
    "diffHunk" : "@@ -1,1 +373,377 @@  // Resampler used to filter incoming pointer events when resampling\n  // is enabled.\n  late final _Resampler _resampler = _Resampler(\n    _handlePointerEvent,\n    _handleSampleTimeChanged,"
  },
  {
    "id" : "d2a18a28-c4db-4ecd-8e0c-28e08a7f3d18",
    "prId" : 60558,
    "prUrl" : "https://github.com/flutter/flutter/pull/60558#pullrequestreview-473682548",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "15fa36de-1860-442a-be19-dce79c75fdeb",
        "parentId" : null,
        "authorId" : "f76bcc8a-9965-41ac-ba63-53a03a848567",
        "body" : "Is it true that when this constructor is called (i.e., `event.device` key is absent in `_resamplers`), `event` can only be `PointerAddedEvent` or `PointerDownEvent`?",
        "createdAt" : "2020-08-24T14:46:06Z",
        "updatedAt" : "2020-08-24T14:46:07Z",
        "lastEditedBy" : "f76bcc8a-9965-41ac-ba63-53a03a848567",
        "tags" : [
        ]
      },
      {
        "id" : "44de9fdb-4eec-4faa-b169-1118372f30b2",
        "parentId" : "15fa36de-1860-442a-be19-dce79c75fdeb",
        "authorId" : "fdee1bed-4587-4bf9-ba6a-db6822c78fc0",
        "body" : "No, that would only be true if resampling was enabled before the first pointer event. If you enable resampling after first receiving a down event then we'll need to create the resampler here when processing a move event.",
        "createdAt" : "2020-08-24T16:54:09Z",
        "updatedAt" : "2020-08-24T16:54:09Z",
        "lastEditedBy" : "fdee1bed-4587-4bf9-ba6a-db6822c78fc0",
        "tags" : [
        ]
      }
    ],
    "commit" : "b7802f69f91e1b5466d6b5b58e98193160964ca5",
    "line" : 61,
    "diffHunk" : "@@ -1,1 +67,71 @@        final PointerEventResampler resampler = _resamplers.putIfAbsent(\n          event.device,\n          () => PointerEventResampler(),\n        );\n        resampler.addEvent(event);"
  },
  {
    "id" : "2a6aa3f2-78d3-487c-a135-a419df9142d8",
    "prId" : 60558,
    "prUrl" : "https://github.com/flutter/flutter/pull/60558#pullrequestreview-501398312",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ce92f3c6-ef29-414f-9bb8-82d7e75753e8",
        "parentId" : null,
        "authorId" : "f76bcc8a-9965-41ac-ba63-53a03a848567",
        "body" : "Does this mean that, when the pending event queue in the resampler is not empty, but there are no more future inputs, these pending events will stay in the queue and will not be processed, since _flushPointerEventQueue is not called?\r\nI realize this when I'm trying to move resampler to handlePointerEvent.\r\ncc @liyuqian",
        "createdAt" : "2020-09-28T21:12:30Z",
        "updatedAt" : "2020-09-28T21:12:30Z",
        "lastEditedBy" : "f76bcc8a-9965-41ac-ba63-53a03a848567",
        "tags" : [
        ]
      },
      {
        "id" : "ab34ead6-53b3-4533-beef-1ea7127a344d",
        "parentId" : "ce92f3c6-ef29-414f-9bb8-82d7e75753e8",
        "authorId" : "0dfb4b67-cdbe-4905-93ea-e8b19d917e2a",
        "body" : "No, the `_Resampler` will schedule `_handleSampleTimeChanged` after frame callback which will call `_flushPointerEventQueue`. See: https://github.com/flutter/flutter/pull/60558/files/b7802f69f91e1b5466d6b5b58e98193160964ca5#diff-6305361e0c7677f0eebfb05dfcbe0336",
        "createdAt" : "2020-10-02T19:35:36Z",
        "updatedAt" : "2020-10-02T19:35:37Z",
        "lastEditedBy" : "0dfb4b67-cdbe-4905-93ea-e8b19d917e2a",
        "tags" : [
        ]
      }
    ],
    "commit" : "b7802f69f91e1b5466d6b5b58e98193160964ca5",
    "line" : 147,
    "diffHunk" : "@@ -1,1 +229,233 @@    if (resamplingEnabled) {\n      _resampler.addOrDispatchAll(_pendingPointerEvents);\n      _resampler.sample(samplingOffset);\n      return;\n    }"
  }
]
[
  {
    "id" : "38a88976-8021-402f-a888-36f3a2dbe302",
    "prId" : 1496,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4407bc83-2dd5-4038-bae0-d0d910b7aecb",
        "parentId" : null,
        "authorId" : "9b5a6de7-1648-432f-a400-7a47bea935d8",
        "body" : "`onSelectionChanged` is a bit misleading. The selection property doesn't change. It's more like `onSelectionChangeRequest` or something like that. It took me a while to understand the ownership model for the selection.\n",
        "createdAt" : "2016-01-30T19:06:27Z",
        "updatedAt" : "2016-01-31T05:57:23Z",
        "lastEditedBy" : "9b5a6de7-1648-432f-a400-7a47bea935d8",
        "tags" : [
        ]
      },
      {
        "id" : "c0ea6add-4a50-4d7c-927a-7cc4ea8da9e6",
        "parentId" : "4407bc83-2dd5-4038-bae0-d0d910b7aecb",
        "authorId" : "9b5a6de7-1648-432f-a400-7a47bea935d8",
        "body" : "(This is a bit weird. The RenderObject model would be to have the RenderObject own and mutate its own selection rather than having the owner be in charge of how to respond to selection move requests.)\n",
        "createdAt" : "2016-01-30T19:09:09Z",
        "updatedAt" : "2016-01-31T05:57:23Z",
        "lastEditedBy" : "9b5a6de7-1648-432f-a400-7a47bea935d8",
        "tags" : [
        ]
      },
      {
        "id" : "f310f6fc-bb12-40af-9c44-231e1773a1c5",
        "parentId" : "4407bc83-2dd5-4038-bae0-d0d910b7aecb",
        "authorId" : "0a6b99c1-e18d-4971-abe3-b52228030462",
        "body" : "Yeah, the current design doesn't work well.  We probably should move the ownership of the interaction with the keyboard all the way down to the rendering layer.  The widget layer would then just signal that it wanted this render object to interact with the keyboard and get notifications of state changes.\n",
        "createdAt" : "2016-01-30T19:31:12Z",
        "updatedAt" : "2016-01-31T05:57:23Z",
        "lastEditedBy" : "0a6b99c1-e18d-4971-abe3-b52228030462",
        "tags" : [
        ]
      }
    ],
    "commit" : "3609938327b56b3af96e8922842c8c60473625ca",
    "line" : 72,
    "diffHunk" : "@@ -1,1 +171,175 @@    if (onSelectionChanged != null) {\n      TextPosition position = _textPainter.getPositionForOffset(globalToLocal(global).toOffset());\n      onSelectionChanged(new TextSelection.fromPosition(position));\n    }\n  }"
  },
  {
    "id" : "05c37667-2ea7-471b-81e6-75beea01b383",
    "prId" : 3223,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3cc4557b-aa68-4725-9343-c299101d519d",
        "parentId" : null,
        "authorId" : "0a6b99c1-e18d-4971-abe3-b52228030462",
        "body" : "Yeah, this only works in English (and not even really then).  You should ask the engine to compute the word boundaries for you.  It's a super complex process in some languages.  In C++, there's a WordIterator that knows how to do it.\n",
        "createdAt" : "2016-04-08T20:15:14Z",
        "updatedAt" : "2016-04-21T17:32:49Z",
        "lastEditedBy" : "0a6b99c1-e18d-4971-abe3-b52228030462",
        "tags" : [
        ]
      }
    ],
    "commit" : "2927db3426d24dab2edc7a084488837a8144f760",
    "line" : 130,
    "diffHunk" : "@@ -1,1 +250,254 @@    while (start >= 0 && str[start] != ' ')\n      --start;\n    ++start;\n\n    int end = position.offset;"
  },
  {
    "id" : "9e35f9ee-d8d2-4f7f-87d1-971b768b7a88",
    "prId" : 3223,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "38f214e9-7a89-44db-9041-f647d2dd2469",
        "parentId" : null,
        "authorId" : "0a6b99c1-e18d-4971-abe3-b52228030462",
        "body" : "Yeah, we need to re-think how we handle the text painter's layout more generally.  Not something we need to solve in this patch.\n",
        "createdAt" : "2016-04-15T04:37:04Z",
        "updatedAt" : "2016-04-21T17:32:49Z",
        "lastEditedBy" : "0a6b99c1-e18d-4971-abe3-b52228030462",
        "tags" : [
        ]
      }
    ],
    "commit" : "2927db3426d24dab2edc7a084488837a8144f760",
    "line" : 48,
    "diffHunk" : "@@ -1,1 +129,133 @@\n  List<TextSelectionPoint> getEndpointsForSelection(TextSelection selection) {\n    _textPainter.layout(); // TODO(mpcomplete): is this hacky?\n\n    Offset offset = _paintOffset + new Offset(0.0, -_kCaretHeightOffset);"
  },
  {
    "id" : "b16c22d0-5a8b-4c4f-9b69-131bc46e382f",
    "prId" : 6310,
    "prUrl" : "https://github.com/flutter/flutter/pull/6310#pullrequestreview-4174247",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b23e4d99-2505-47d1-924e-a0027389af03",
        "parentId" : null,
        "authorId" : "354333fe-86e0-40ca-aa4b-29a9d64d7f86",
        "body" : "changed the caret rect I use here, dropping the vertical padding so that we scroll all the way to the edge when it moves.\n",
        "createdAt" : "2016-10-13T22:00:41Z",
        "updatedAt" : "2016-10-13T22:00:41Z",
        "lastEditedBy" : "354333fe-86e0-40ca-aa4b-29a9d64d7f86",
        "tags" : [
        ]
      }
    ],
    "commit" : "85b41ff65f9f56c5d850c3e3d21e30c35197024e",
    "line" : 81,
    "diffHunk" : "@@ -1,1 +211,215 @@    // This rect is the same as _caretPrototype but without the vertical padding.\n    return new Rect.fromLTWH(0.0, 0.0, _kCaretWidth, lineHeight).shift(caretOffset + _paintOffset);\n  }\n\n  Size _contentSize;"
  }
]
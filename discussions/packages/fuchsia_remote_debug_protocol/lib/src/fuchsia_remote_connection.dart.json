[
  {
    "id" : "c8890803-c0b2-4cdd-9ba1-c4e82702145e",
    "prId" : 20597,
    "prUrl" : "https://github.com/flutter/flutter/pull/20597#pullrequestreview-146295097",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ff1bab19-39e6-4d13-9630-1073b53995c5",
        "parentId" : null,
        "authorId" : "1dc608b7-5634-49db-a2de-36dd357356e8",
        "body" : "You should probably add `onDone` and `onError` params here too, to keep from waiting the entire timeout period when we know we don't need to.",
        "createdAt" : "2018-08-14T22:52:37Z",
        "updatedAt" : "2018-08-15T00:26:24Z",
        "lastEditedBy" : "1dc608b7-5634-49db-a2de-36dd357356e8",
        "tags" : [
        ]
      },
      {
        "id" : "8edbff02-9585-4c09-a145-f8e5f75fceb7",
        "parentId" : "ff1bab19-39e6-4d13-9630-1073b53995c5",
        "authorId" : "b630ecfe-71a4-4b74-8a0b-695c4dd9a014",
        "body" : "So I wasn't sure what to do about this, because right now at least, the listen method is implemented as a `Future<Null>` (see line 137) rather than a stream subscription.  At the moment the stream is returned as a broadcast, which has me a bit confused about how the implementation would work for the stream controller.",
        "createdAt" : "2018-08-14T23:01:37Z",
        "updatedAt" : "2018-08-15T00:26:24Z",
        "lastEditedBy" : "b630ecfe-71a4-4b74-8a0b-695c4dd9a014",
        "tags" : [
        ]
      },
      {
        "id" : "08aa7baa-08a0-4b47-a77b-826ee5ce59d8",
        "parentId" : "ff1bab19-39e6-4d13-9630-1073b53995c5",
        "authorId" : "1dc608b7-5634-49db-a2de-36dd357356e8",
        "body" : "Ok, so in this case, you're never sending error events... but you are closing the connection (at line 143), so adding an `onDone` callback here would at least allow you to handle the case of the stream closing before you've found a match.  ... and in the case of `onDone`, you don't need to worry about cancelling the subscription anyway since the stream is done.",
        "createdAt" : "2018-08-14T23:10:38Z",
        "updatedAt" : "2018-08-15T00:26:24Z",
        "lastEditedBy" : "1dc608b7-5634-49db-a2de-36dd357356e8",
        "tags" : [
        ]
      },
      {
        "id" : "763267c5-9402-4a26-98f6-09b05f0094ea",
        "parentId" : "ff1bab19-39e6-4d13-9630-1073b53995c5",
        "authorId" : "b630ecfe-71a4-4b74-8a0b-695c4dd9a014",
        "body" : "Hmmm, I think the `onDone` case wouldn't lead to anything but a warning log.  The only way for that event to come up would be if the user called `stop` before finding the isolate in question (which I think can only happen if the user doesn't use `await` for `getMainIsolatesByPattern` and then calls `stop`).",
        "createdAt" : "2018-08-15T00:02:29Z",
        "updatedAt" : "2018-08-15T00:26:24Z",
        "lastEditedBy" : "b630ecfe-71a4-4b74-8a0b-695c4dd9a014",
        "tags" : [
        ]
      }
    ],
    "commit" : "485a7f1e526bbe853c81d874674ec16d19525afc",
    "line" : 17,
    "diffHunk" : "@@ -1,1 +253,257 @@        new Completer<List<IsolateRef>>();\n    _onDartVmEvent.listen(\n      (DartVmEvent event) async {\n        if (event.eventType == DartVmEventType.started) {\n          _log.fine('New VM found on port: ${event.servicePort}. Searching '"
  }
]
[
  {
    "id" : "7b63a942-7a8d-49d8-8633-ea85fe94f045",
    "prId" : 4063,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e127f66f-aa9e-41d7-8bce-188d3bf924a0",
        "parentId" : null,
        "authorId" : "0fc1222a-8e68-4923-bf2e-18203f0657f2",
        "body" : "We'll need to reconcile this asymmetry in how ios and android work. For android devices, building and `startApp()` are separate; for ios devices and ios simulators, `startApp()` both builds and runs the app; this is why the build mode is ignored in the android startApp implementation.\n\nCan you open an issue for this? One solution about be to add an abstract `build()` method to `Device`, call the apk build functionality from there for android, and move the ios building functionality out of startApp for ios+ios devices.\n",
        "createdAt" : "2016-05-20T03:46:18Z",
        "updatedAt" : "2016-05-23T19:51:02Z",
        "lastEditedBy" : "0fc1222a-8e68-4923-bf2e-18203f0657f2",
        "tags" : [
        ]
      },
      {
        "id" : "d519015d-24f8-4f4a-8651-04fd74116dd1",
        "parentId" : "e127f66f-aa9e-41d7-8bce-188d3bf924a0",
        "authorId" : "5c85d36f-d476-470a-8ea7-252cdb4fb025",
        "body" : "I am not sure I understand the asymmetry. If I build the application in `debug` and attempt to start it in `release`, the tools would still need to be able to understand that the existing APK is invalid and must be rebuilt. So how can the mode be ignored when starting the application.\n",
        "createdAt" : "2016-05-20T21:11:06Z",
        "updatedAt" : "2016-05-23T19:51:02Z",
        "lastEditedBy" : "5c85d36f-d476-470a-8ea7-252cdb4fb025",
        "tags" : [
        ]
      },
      {
        "id" : "0b4d23af-fcd5-4ef6-af6c-4db939595e4d",
        "parentId" : "e127f66f-aa9e-41d7-8bce-188d3bf924a0",
        "authorId" : "0fc1222a-8e68-4923-bf2e-18203f0657f2",
        "body" : "Flutter_tools will always issue a build before a startApp, so we won't get into a situation where the apk is built for the wrong mode than startApp would want.\n\nNot for this PR, but I want to iteratively refactor the tool so that the Android and iOS workflows are substantially similar, and differences captured in the device subclasses. Right now we still have some instance of checks spread throughout the tool, to handle Android and iOS differently.\n",
        "createdAt" : "2016-05-21T03:44:46Z",
        "updatedAt" : "2016-05-23T19:51:02Z",
        "lastEditedBy" : "0fc1222a-8e68-4923-bf2e-18203f0657f2",
        "tags" : [
        ]
      },
      {
        "id" : "e9884d72-a49d-4c72-aec1-1ed4b9a49503",
        "parentId" : "e127f66f-aa9e-41d7-8bce-188d3bf924a0",
        "authorId" : "5c85d36f-d476-470a-8ea7-252cdb4fb025",
        "body" : "Got it.\n",
        "createdAt" : "2016-05-23T19:48:38Z",
        "updatedAt" : "2016-05-23T19:51:02Z",
        "lastEditedBy" : "5c85d36f-d476-470a-8ea7-252cdb4fb025",
        "tags" : [
        ]
      }
    ],
    "commit" : "e9fd55090b79e9f2c0d861bd6b884348679ab0a2",
    "line" : 17,
    "diffHunk" : "@@ -1,1 +166,170 @@\n    // Step 1: Install the precompiled/DBC application if necessary.\n    bool buildResult = await buildIOSXcodeProject(app, mode, buildForDevice: true);\n    if (!buildResult) {\n      printError('Could not build the precompiled application for the device.');"
  },
  {
    "id" : "991ca662-875d-45ce-bcf0-7df08039d02a",
    "prId" : 4424,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "851f54eb-e89a-4c8b-b9b0-c5ba47d35abd",
        "parentId" : null,
        "authorId" : "0fc1222a-8e68-4923-bf2e-18203f0657f2",
        "body" : "It should hopefully be sufficient to check `debuggingOptions.debuggingEnabled`.\n",
        "createdAt" : "2016-06-14T15:52:46Z",
        "updatedAt" : "2016-06-14T18:33:10Z",
        "lastEditedBy" : "0fc1222a-8e68-4923-bf2e-18203f0657f2",
        "tags" : [
        ]
      }
    ],
    "commit" : "3b8f397529dc732da080e7106b04e769f93f7792",
    "line" : 65,
    "diffHunk" : "@@ -1,1 +233,237 @@    int localDiagPort;\n\n    if (!debuggingOptions.debuggingEnabled || mode == BuildMode.release) {\n      // If debugging is not enabled, just launch the application and continue.\n      printTrace(\"Debugging is not enabled\");"
  },
  {
    "id" : "1518edbd-7978-440c-b5be-f40a78b33c58",
    "prId" : 4976,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5348832a-4078-4061-9a6a-4db423a09ddc",
        "parentId" : null,
        "authorId" : "29909713-5424-4233-a02b-b02672141af4",
        "body" : "Does `flutter analyze` not catch this?\n",
        "createdAt" : "2016-07-20T04:11:14Z",
        "updatedAt" : "2016-07-20T04:11:14Z",
        "lastEditedBy" : "29909713-5424-4233-a02b-b02672141af4",
        "tags" : [
        ]
      },
      {
        "id" : "e38e0230-96df-4a62-b484-f4b01b165f59",
        "parentId" : "5348832a-4078-4061-9a6a-4db423a09ddc",
        "authorId" : "ac2c92fd-803c-4666-96b1-db1044c762c5",
        "body" : "It does now. An older version of the analyzer had a bug and failed to catch this. We started seeing failures after we picked up a new analyzer.\n",
        "createdAt" : "2016-07-20T04:14:22Z",
        "updatedAt" : "2016-07-20T04:14:22Z",
        "lastEditedBy" : "ac2c92fd-803c-4666-96b1-db1044c762c5",
        "tags" : [
        ]
      }
    ],
    "commit" : "9919caa57a822329d89c025cafdbdf6ec892fbea",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +261,265 @@                                                   debuggingOptions.diagnosticPort);\n        } else {\n          forwardDiagPort = new Future<int>.value(null);\n        }\n"
  },
  {
    "id" : "8d57fc58-f7b9-4863-85a5-9c958dec0787",
    "prId" : 6898,
    "prUrl" : "https://github.com/flutter/flutter/pull/6898#pullrequestreview-8941725",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "acc24b5c-d3cd-4304-9963-f70ddc744bf2",
        "parentId" : null,
        "authorId" : "5a8dd24e-c20a-4956-a91a-c1198c83ac54",
        "body" : "Where are you removing dead _logReaders from this map?\n",
        "createdAt" : "2016-11-16T23:33:42Z",
        "updatedAt" : "2016-11-16T23:41:09Z",
        "lastEditedBy" : "5a8dd24e-c20a-4956-a91a-c1198c83ac54",
        "tags" : [
        ]
      },
      {
        "id" : "14d40843-5ceb-4313-be89-37d619c95837",
        "parentId" : "acc24b5c-d3cd-4304-9963-f70ddc744bf2",
        "authorId" : "1dc608b7-5634-49db-a2de-36dd357356e8",
        "body" : "I was purposely letting them live as long as the process to match what was being done before with the instance variable.  Yes, this could _theoretically_ grow without bound, but practically speaking, we're only going to have one `ApplicationPackage` we're passing around.\n\nIf we felt like being super careful, we could override `equals()` and `hashCode()` in `ApplicationPackage`...\n",
        "createdAt" : "2016-11-16T23:44:27Z",
        "updatedAt" : "2016-11-16T23:44:27Z",
        "lastEditedBy" : "1dc608b7-5634-49db-a2de-36dd357356e8",
        "tags" : [
        ]
      },
      {
        "id" : "d1ce6d5e-8673-439c-bdb5-bb07236317a3",
        "parentId" : "acc24b5c-d3cd-4304-9963-f70ddc744bf2",
        "authorId" : "5a8dd24e-c20a-4956-a91a-c1198c83ac54",
        "body" : "Yeah, it occurred to me that almost everything in flutter_tools lives as long as the process and so this isn't any different.\n\nMy long term dream would be for flutter_tools to actually live a long time and operate like a daemon that clients speak to, at that point it may matter. I don't think we need to address this in this CL but maybe add a TODO where we add to the maps to someday remove from them too.\n",
        "createdAt" : "2016-11-17T00:48:31Z",
        "updatedAt" : "2016-11-17T00:48:31Z",
        "lastEditedBy" : "5a8dd24e-c20a-4956-a91a-c1198c83ac54",
        "tags" : [
        ]
      }
    ],
    "commit" : "4a055e20c993bbd84accc439c30f25638fed387b",
    "line" : null,
    "diffHunk" : "@@ -1,1 +380,384 @@  @override\n  DeviceLogReader getLogReader({ApplicationPackage app}) {\n    _logReaders ??= <ApplicationPackage, _IOSDeviceLogReader>{};\n    return _logReaders.putIfAbsent(app, () => new _IOSDeviceLogReader(this, app));\n  }"
  }
]
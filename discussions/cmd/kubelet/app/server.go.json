[
  {
    "id" : "be8409fe-8153-4b32-8778-333fd100a2e9",
    "prId" : 101480,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/101480#pullrequestreview-645743609",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3847cab5-b3bb-4e28-813e-c8a2a1aa4efc",
        "parentId" : null,
        "authorId" : "a08a031e-c5d0-4521-a805-73ac0bc08c9a",
        "body" : "We should capitalise the first letter of the error message as per the migration guide: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-instrumentation/migration-to-structured-logging.md#remove-string-formatting-from-log-message\r\n\r\nI'm curious about where we've mentioned that error messages shouldn't be captalised as we need to fix it :) ",
        "createdAt" : "2021-04-27T10:50:01Z",
        "updatedAt" : "2021-04-28T07:27:27Z",
        "lastEditedBy" : "a08a031e-c5d0-4521-a805-73ac0bc08c9a",
        "tags" : [
        ]
      },
      {
        "id" : "e2b4269d-17f0-4dc4-b0f2-9deba0ca9c9d",
        "parentId" : "3847cab5-b3bb-4e28-813e-c8a2a1aa4efc",
        "authorId" : "ac20bfc0-048b-4f7c-8f40-c004ff5299e1",
        "body" : "That document is  for klog style, but here may be golang style, and as golang code style suggested here: https://github.com/golang/go/wiki/CodeReviewComments#error-strings ",
        "createdAt" : "2021-04-27T11:30:37Z",
        "updatedAt" : "2021-04-28T07:27:27Z",
        "lastEditedBy" : "ac20bfc0-048b-4f7c-8f40-c004ff5299e1",
        "tags" : [
        ]
      }
    ],
    "commit" : "bebca30309c0bed34e412cf5c57a290adfaaa74f",
    "line" : 10,
    "diffHunk" : "@@ -1,1 +505,509 @@\treservedCPUSet, err := cpuset.Parse(cpus)\n\tif err != nil {\n\t\treturn emptyCPUSet, fmt.Errorf(\"unable to parse reserved-cpus list: %s\", err)\n\t}\n\tallCPUSet := topo.CPUDetails.CPUs()"
  },
  {
    "id" : "b29f38bb-a34a-482c-802b-62967382b1be",
    "prId" : 101302,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/101302#pullrequestreview-650764556",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e0d5aba4-a189-45f2-9a4a-c1c924c4e0c9",
        "parentId" : null,
        "authorId" : "4e418bc8-21fb-4523-80c1-9c751c193126",
        "body" : "Why not also update these to %w, and below?",
        "createdAt" : "2021-05-03T22:14:44Z",
        "updatedAt" : "2021-05-03T22:14:47Z",
        "lastEditedBy" : "4e418bc8-21fb-4523-80c1-9c751c193126",
        "tags" : [
        ]
      }
    ],
    "commit" : "5109c3d5489768bfab3c9dcbbb020135d3454444",
    "line" : 18,
    "diffHunk" : "@@ -1,1 +501,505 @@\ttopo, err := topology.Discover(machineInfo)\n\tif err != nil {\n\t\treturn emptyCPUSet, fmt.Errorf(\"unable to discover CPU topology info: %s\", err)\n\t}\n\treservedCPUSet, err := cpuset.Parse(cpus)"
  },
  {
    "id" : "2a151186-e851-4621-800f-6122888b7353",
    "prId" : 98334,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/98334#pullrequestreview-608779149",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0905e742-b073-4020-97a0-2339995c7dee",
        "parentId" : null,
        "authorId" : "6ea93d56-a0ec-4969-ac42-11a78c2085e6",
        "body" : "Could we move `klog.ErrorS` call above `cmd.Usage()` to be consistent with invocation above. ",
        "createdAt" : "2021-03-10T14:33:47Z",
        "updatedAt" : "2021-03-17T00:36:08Z",
        "lastEditedBy" : "6ea93d56-a0ec-4969-ac42-11a78c2085e6",
        "tags" : [
        ]
      }
    ],
    "commit" : "ae381fcf09635c15a3d09641aac2a15d25e26514",
    "line" : 31,
    "diffHunk" : "@@ -1,1 +162,166 @@\t\t\tcmds := cleanFlagSet.Args()\n\t\t\tif len(cmds) > 0 {\n\t\t\t\tklog.ErrorS(nil, \"Unknown command\", \"command\", cmds[0])\n\t\t\t\tcmd.Usage()\n\t\t\t\tos.Exit(1)"
  },
  {
    "id" : "fdd1c57a-9b7d-4aa7-8b5e-04cb3cd48f92",
    "prId" : 94643,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/94643#pullrequestreview-487364298",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a900e281-2d4c-4d0b-b8f0-e9718f0cd4c3",
        "parentId" : null,
        "authorId" : "5c4757f6-5a7a-438b-b77f-778928cb6979",
        "body" : "no need to define errParse, next line you can write like this \r\n> reservedSystemCPUs, errParse := cpuset.Parse(s.ReservedSystemCPUs)",
        "createdAt" : "2020-09-10T13:28:24Z",
        "updatedAt" : "2020-09-10T13:28:57Z",
        "lastEditedBy" : "5c4757f6-5a7a-438b-b77f-778928cb6979",
        "tags" : [
        ]
      },
      {
        "id" : "3dc9006e-1a81-4f57-9e08-01107b24e872",
        "parentId" : "a900e281-2d4c-4d0b-b8f0-e9718f0cd4c3",
        "authorId" : "b443af66-0c45-41ad-acf0-ee5f77b8d190",
        "body" : "No, the result will not as expect as you, see: https://play.golang.org/p/G4CwknE4G1X",
        "createdAt" : "2020-09-13T14:45:22Z",
        "updatedAt" : "2020-09-13T14:45:22Z",
        "lastEditedBy" : "b443af66-0c45-41ad-acf0-ee5f77b8d190",
        "tags" : [
        ]
      },
      {
        "id" : "d2246eed-e6c8-4a1a-97a4-3647a7c45505",
        "parentId" : "a900e281-2d4c-4d0b-b8f0-e9718f0cd4c3",
        "authorId" : "5c4757f6-5a7a-438b-b77f-778928cb6979",
        "body" : "sorry, you are right.",
        "createdAt" : "2020-09-14T01:21:18Z",
        "updatedAt" : "2020-09-14T01:22:20Z",
        "lastEditedBy" : "5c4757f6-5a7a-438b-b77f-778928cb6979",
        "tags" : [
        ]
      },
      {
        "id" : "3fb2126b-bdca-4922-a470-e828f32d31ae",
        "parentId" : "a900e281-2d4c-4d0b-b8f0-e9718f0cd4c3",
        "authorId" : "5c4757f6-5a7a-438b-b77f-778928cb6979",
        "body" : ":(, sorry, you are right.",
        "createdAt" : "2020-09-14T01:22:20Z",
        "updatedAt" : "2020-09-14T01:22:20Z",
        "lastEditedBy" : "5c4757f6-5a7a-438b-b77f-778928cb6979",
        "tags" : [
        ]
      }
    ],
    "commit" : "8fe3b7f8b7a69f0c57861d72eab7d7a43eeba055",
    "line" : 19,
    "diffHunk" : "@@ -1,1 +655,659 @@\t\t\t\treservedSystemCPUs = cpuset.NewCPUSet()\n\t\t\t} else {\n\t\t\t\tvar errParse error\n\t\t\t\treservedSystemCPUs, errParse = cpuset.Parse(s.ReservedSystemCPUs)\n\t\t\t\tif errParse != nil {"
  },
  {
    "id" : "1f28742d-23b5-4143-8b53-04fb85bb398c",
    "prId" : 94643,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/94643#pullrequestreview-525387587",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "01d1c87a-f803-468f-b697-094848379f47",
        "parentId" : null,
        "authorId" : "3eccedfc-5c53-4555-94cb-69f2b56e485c",
        "body" : "we should reuse the err from line 651.\r\n\r\n```\r\nreservedSystemCPUs, err = cpuset.Parse(s.ReservedSystemCPUs)\r\n```",
        "createdAt" : "2020-11-06T18:16:48Z",
        "updatedAt" : "2020-11-06T18:16:54Z",
        "lastEditedBy" : "3eccedfc-5c53-4555-94cb-69f2b56e485c",
        "tags" : [
        ]
      }
    ],
    "commit" : "8fe3b7f8b7a69f0c57861d72eab7d7a43eeba055",
    "line" : 20,
    "diffHunk" : "@@ -1,1 +656,660 @@\t\t\t} else {\n\t\t\t\tvar errParse error\n\t\t\t\treservedSystemCPUs, errParse = cpuset.Parse(s.ReservedSystemCPUs)\n\t\t\t\tif errParse != nil {\n\t\t\t\t\t// invalid cpu list is provided, set reservedSystemCPUs to empty, so it won't overwrite kubeReserved/systemReserved"
  },
  {
    "id" : "852351c0-c5c8-4f37-95d6-3db9c2aef5ae",
    "prId" : 86752,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/86752#pullrequestreview-337669893",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b0d4ed2e-9ff8-4fdb-bc4c-c55d68f0ee7e",
        "parentId" : null,
        "authorId" : "d7870cae-47b0-4c8e-8527-be8fc4be86de",
        "body" : "Can you share more about the situations in which setting the `Rlimit` could fail?\r\n\r\nAlso, is there any reason that we need to run this check after `createAndInitKubelet`? If not, can I propose we move it to the top of this function, so that if setting the Rlimit does fail, we don't need to wait to create and init the Kubelet to find that out?\r\n\r\n",
        "createdAt" : "2020-01-01T20:43:08Z",
        "updatedAt" : "2020-04-01T22:34:31Z",
        "lastEditedBy" : "d7870cae-47b0-4c8e-8527-be8fc4be86de",
        "tags" : [
        ]
      },
      {
        "id" : "c9f4faf1-8f99-460f-80c7-bcb89397f8f5",
        "parentId" : "b0d4ed2e-9ff8-4fdb-bc4c-c55d68f0ee7e",
        "authorId" : "e7b8fd7e-f93b-44b6-b6d0-4331207d901c",
        "body" : "It is a low-level system call associated with the operating system.\r\nI'm not sure what circumstances might cause this call to fail, but I think it's worth doing something to make the code more robust.\r\n\r\nI agree with you that we should move it to the top of this function if possible. \r\nThanks @mattjmcnaughton\r\n\r\n",
        "createdAt" : "2020-01-02T02:26:14Z",
        "updatedAt" : "2020-04-01T22:34:31Z",
        "lastEditedBy" : "e7b8fd7e-f93b-44b6-b6d0-4331207d901c",
        "tags" : [
        ]
      },
      {
        "id" : "28c64da9-04d0-4f0b-98a5-6e4e6e8f2763",
        "parentId" : "b0d4ed2e-9ff8-4fdb-bc4c-c55d68f0ee7e",
        "authorId" : "d7870cae-47b0-4c8e-8527-be8fc4be86de",
        "body" : "Yeah, plus one I'm also not really sure what could cause this system call to fail... however, if it does feel, I agree we want to know about it.",
        "createdAt" : "2020-01-02T14:02:21Z",
        "updatedAt" : "2020-04-01T22:34:31Z",
        "lastEditedBy" : "d7870cae-47b0-4c8e-8527-be8fc4be86de",
        "tags" : [
        ]
      }
    ],
    "commit" : "c27ceb6449383ac7141a5e5c737c6b7a5fd2a77a",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +1101,1105 @@\tpodCfg := kubeDeps.PodConfig\n\n\tif err := rlimit.RlimitNumFiles(uint64(kubeServer.MaxOpenFiles)); err != nil {\n\t\tklog.Errorf(\"Failed to set rlimit on max file handles: %v\", err)\n\t}"
  },
  {
    "id" : "0aa97b1b-2553-4f14-a71e-f0eb888b5b2c",
    "prId" : 83592,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/83592#pullrequestreview-300583683",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "35d24a87-7249-4ff0-b2cc-9d440fbcf730",
        "parentId" : null,
        "authorId" : "6eca0ade-9879-4dd7-ad14-547e16f5c041",
        "body" : "so kube-reserved and system-reserved has imagined a topology where kubelet itself was managed in a separate part of cgroup topology than the rest of the system.  \r\n\r\nFor example, system.slice for system-reserved and kube.slice for kube-reserved.  I am not aware of any deployment that actually configured kubelet as such versus running it traditionally under a common systemd unit via system.slice.  The idea was the we could measure resource usage of kube component separately from normal system services and also configure them with different cfs shares.\r\n\r\nIn a deployment where you use isolcpu, it’s arguable you do not want to bother with setting shares on system.slice separate from kube.slice, and just pin those components to the reserved cpu list.",
        "createdAt" : "2019-10-09T23:50:35Z",
        "updatedAt" : "2019-11-06T12:37:36Z",
        "lastEditedBy" : "6eca0ade-9879-4dd7-ad14-547e16f5c041",
        "tags" : [
        ]
      },
      {
        "id" : "8d7193f7-89aa-4fe9-9f6a-dd7e1633493c",
        "parentId" : "35d24a87-7249-4ff0-b2cc-9d440fbcf730",
        "authorId" : "ee2e11d3-eec2-40c5-837f-b7bd6985d0e9",
        "body" : "Ack. Actual deployments seems just have the systemd unit via system.slice. I see your point, we need to have a further discuss in a design meeting",
        "createdAt" : "2019-10-11T09:56:32Z",
        "updatedAt" : "2019-11-06T12:37:36Z",
        "lastEditedBy" : "ee2e11d3-eec2-40c5-837f-b7bd6985d0e9",
        "tags" : [
        ]
      }
    ],
    "commit" : "89dfd244838f21ecaf9bc9bf28662a7cccdd8425",
    "line" : 42,
    "diffHunk" : "@@ -1,1 +668,672 @@\t\t}\n\n\t\tif reservedSystemCPUs.Size() > 0 {\n\t\t\t// at cmd option valication phase it is tested either --system-reserved-cgroup or --kube-reserved-cgroup is specified, so overwrite should be ok\n\t\t\tklog.Infof(\"Option --reserved-cpus is specified, it will overwrite the cpu setting in KubeReserved=\\\"%v\\\", SystemReserved=\\\"%v\\\".\", s.KubeReserved, s.SystemReserved)"
  },
  {
    "id" : "c1b87e40-3a75-4125-867d-9098881b759c",
    "prId" : 83592,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/83592#pullrequestreview-300586309",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "08ca6601-bff4-4cba-baeb-d150384d2992",
        "parentId" : null,
        "authorId" : "6eca0ade-9879-4dd7-ad14-547e16f5c041",
        "body" : "Ok, so this explicitly prevents reserving cfs shares for system versus kubelet separately.  I am personally ok with this because my experience is that no one understands the difference between kube and system reserved.  In the deployment topology you target, would you desire separate cfs shares?  In practice, I imagine if you did, you would just set it direct in kubelet unit.  Let’s discuss in sig-node.",
        "createdAt" : "2019-10-09T23:59:24Z",
        "updatedAt" : "2019-11-06T12:37:36Z",
        "lastEditedBy" : "6eca0ade-9879-4dd7-ad14-547e16f5c041",
        "tags" : [
        ]
      },
      {
        "id" : "955b37dd-1231-4dde-9cb6-8a26a0c5e492",
        "parentId" : "08ca6601-bff4-4cba-baeb-d150384d2992",
        "authorId" : "6eca0ade-9879-4dd7-ad14-547e16f5c041",
        "body" : "So by overriding, this will ensure that you don’t reserve more than capacity with normal validation... the error message may be confusing as it will complain about system-reserved...",
        "createdAt" : "2019-10-10T00:05:11Z",
        "updatedAt" : "2019-11-06T12:37:36Z",
        "lastEditedBy" : "6eca0ade-9879-4dd7-ad14-547e16f5c041",
        "tags" : [
        ]
      },
      {
        "id" : "ff00e797-9eb2-4cbd-8cba-799e9fdc7515",
        "parentId" : "08ca6601-bff4-4cba-baeb-d150384d2992",
        "authorId" : "ee2e11d3-eec2-40c5-837f-b7bd6985d0e9",
        "body" : "Ack, will fix the error message.",
        "createdAt" : "2019-10-11T10:01:44Z",
        "updatedAt" : "2019-11-06T12:37:36Z",
        "lastEditedBy" : "ee2e11d3-eec2-40c5-837f-b7bd6985d0e9",
        "tags" : [
        ]
      }
    ],
    "commit" : "89dfd244838f21ecaf9bc9bf28662a7cccdd8425",
    "line" : 51,
    "diffHunk" : "@@ -1,1 +677,681 @@\t\t\t\ts.SystemReserved = make(map[string]string)\n\t\t\t}\n\t\t\ts.SystemReserved[\"cpu\"] = strconv.Itoa(reservedSystemCPUs.Size())\n\t\t\tklog.Infof(\"After cpu setting is overwritten, KubeReserved=\\\"%v\\\", SystemReserved=\\\"%v\\\"\", s.KubeReserved, s.SystemReserved)\n\t\t}"
  },
  {
    "id" : "03014b7f-d1bd-4396-93a5-618eca6e0727",
    "prId" : 83592,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/83592#pullrequestreview-309244013",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "642e0c9b-2cb3-4650-890f-8c234d3d9225",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "if the parsing is static, can this go in ValidateKubeletConfiguration? that would catch errors in malformed values earlier\r\n\r\nedit: it looks like this is already being done in kubelet config validation.",
        "createdAt" : "2019-10-30T14:27:30Z",
        "updatedAt" : "2019-11-06T12:37:36Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "89dfd244838f21ecaf9bc9bf28662a7cccdd8425",
    "line" : 17,
    "diffHunk" : "@@ -1,1 +643,647 @@\t\tif s.ReservedSystemCPUs != \"\" {\n\t\t\treservedSystemCPUs, errParse = cpuset.Parse(s.ReservedSystemCPUs)\n\t\t\tif errParse != nil {\n\t\t\t\t// invalid cpu list is provided, set reservedSystemCPUs to empty, so it won't overwrite kubeReserved/systemReserved\n\t\t\t\tklog.Infof(\"Invalid ReservedSystemCPUs \\\"%s\\\"\", s.ReservedSystemCPUs)"
  },
  {
    "id" : "434b408d-c8ea-4c97-896d-21e3891a26fc",
    "prId" : 83592,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/83592#pullrequestreview-309277537",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "03fcb64f-6609-410e-b871-91a28ff980c1",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "ignoring malformed config values doesn't seem correct, is this intentional? I'd expect a malformed config to not start.\r\n\r\nedit: it looks like this is being done in kubelet config validation. if we get here and still have a parse error, we should exit, not continue",
        "createdAt" : "2019-10-30T14:28:09Z",
        "updatedAt" : "2019-11-06T12:37:36Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "024b3389-e39c-4f8c-b598-afe6d1acf9f9",
        "parentId" : "03fcb64f-6609-410e-b871-91a28ff980c1",
        "authorId" : "ee2e11d3-eec2-40c5-837f-b7bd6985d0e9",
        "body" : "yes this is intentional, if it makes this far, I wanted it to fall back to the old behavior (the none-explicit way) as if this option was not defined. I debated about this myself and will change it.",
        "createdAt" : "2019-10-30T15:04:39Z",
        "updatedAt" : "2019-11-06T12:37:36Z",
        "lastEditedBy" : "ee2e11d3-eec2-40c5-837f-b7bd6985d0e9",
        "tags" : [
        ]
      }
    ],
    "commit" : "89dfd244838f21ecaf9bc9bf28662a7cccdd8425",
    "line" : 27,
    "diffHunk" : "@@ -1,1 +653,657 @@\t\t\t\t// if can't use CAdvisor here, fall back to non-explicit cpu list behavor\n\t\t\t\tklog.Warning(\"Failed to get MachineInfo, set reservedSystemCPUs to empty\")\n\t\t\t\treservedSystemCPUs = cpuset.NewCPUSet()\n\t\t\t} else {\n\t\t\t\treservedList := reservedSystemCPUs.ToSlice()"
  },
  {
    "id" : "a4fa6358-5ac0-4a39-80c5-841ce3cb373c",
    "prId" : 78016,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/78016#pullrequestreview-239199441",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5b000f6f-7450-43e3-8c27-80c80c34e90a",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "this loses the safety checks UpdateTransport did to ensure an existing transport on the config was not set",
        "createdAt" : "2019-05-17T15:56:05Z",
        "updatedAt" : "2019-05-23T14:18:42Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "e6aa4b04-2cbe-492c-b467-7dd695d27004",
        "parentId" : "5b000f6f-7450-43e3-8c27-80c80c34e90a",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "yeah, you can't override a dialer",
        "createdAt" : "2019-05-17T17:14:43Z",
        "updatedAt" : "2019-05-23T14:18:42Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "df187858-d4ee-4ea7-a861-fdbf6b9f00b1",
        "parentId" : "5b000f6f-7450-43e3-8c27-80c80c34e90a",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "I think we need to move connrotation into rest client at a low level",
        "createdAt" : "2019-05-17T17:16:14Z",
        "updatedAt" : "2019-05-23T14:18:42Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "6025070c-8272-448f-ab13-632f964c1a39",
        "parentId" : "5b000f6f-7450-43e3-8c27-80c80c34e90a",
        "authorId" : "b3df7daa-d323-438c-89a4-583f939bcfae",
        "body" : "> this loses the safety checks UpdateTransport did to ensure an existing transport on the config was not set\r\n\r\nDone, please take another look.\r\n\r\n\r\n\r\n> I think we need to move connrotation into rest client at a low level\r\n\r\nYes, I agree with you. I will move this package in another PR",
        "createdAt" : "2019-05-18T13:57:50Z",
        "updatedAt" : "2019-05-23T14:18:42Z",
        "lastEditedBy" : "b3df7daa-d323-438c-89a4-583f939bcfae",
        "tags" : [
        ]
      }
    ],
    "commit" : "1d07d303059ef3b2378cec1548f2611ec7022c5d",
    "line" : 31,
    "diffHunk" : "@@ -1,1 +819,823 @@\n// updateDialer instruments a restconfig with a dial. the returned function allows forcefully closing all active connections.\nfunc updateDialer(clientConfig *restclient.Config) (func(), error) {\n\tif clientConfig.Transport != nil || clientConfig.Dial != nil {\n\t\treturn nil, fmt.Errorf(\"there is already a transport or dialer configured\")"
  },
  {
    "id" : "c70b4ed9-f20f-4c11-9787-0b97a478587c",
    "prId" : 78016,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/78016#pullrequestreview-241237760",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fe87ded3-273e-4e20-9b8c-e0eb45c2de8e",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "if we require buildKubeletClientConfig to always give us back a closeall function, that would have caught this earlier. Can we add that check here and error early, rather than assigning `nil` to `OnHeartbeatFailure`?\r\n\r\nhttps://github.com/kubernetes/kubernetes/blob/d5876954e15678eb643456d25e7e150d04706113/cmd/kubelet/app/server.go#L566-L570",
        "createdAt" : "2019-05-22T17:32:00Z",
        "updatedAt" : "2019-05-23T14:18:42Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "9bcc8c4a-9030-4389-92ab-660d4438236d",
        "parentId" : "fe87ded3-273e-4e20-9b8c-e0eb45c2de8e",
        "authorId" : "b3df7daa-d323-438c-89a4-583f939bcfae",
        "body" : "IMHO, this check seems to be a little bit tedious, since if err is `nil`,  `closeAllConns` must not be nil :) ",
        "createdAt" : "2019-05-23T12:21:48Z",
        "updatedAt" : "2019-05-23T14:18:42Z",
        "lastEditedBy" : "b3df7daa-d323-438c-89a4-583f939bcfae",
        "tags" : [
        ]
      },
      {
        "id" : "11524ede-b4cd-44f1-802d-9d6de8c3478c",
        "parentId" : "fe87ded3-273e-4e20-9b8c-e0eb45c2de8e",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "the logic in buildKubeletClientConfig is sufficiently complex that if it changed, and started returning a nil closeAllConns, no clear failures would occur, it would pass CI, and make it back into a release as another regression. A nil check before assigning to OnHeartbeatFailure would make the error immediately clear.",
        "createdAt" : "2019-05-23T13:27:58Z",
        "updatedAt" : "2019-05-23T14:18:42Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "3ba83188-3e17-4914-8482-6aa94416309a",
        "parentId" : "fe87ded3-273e-4e20-9b8c-e0eb45c2de8e",
        "authorId" : "b3df7daa-d323-438c-89a4-583f939bcfae",
        "body" : "done, thanks for the explanation.",
        "createdAt" : "2019-05-23T14:24:15Z",
        "updatedAt" : "2019-05-23T14:24:15Z",
        "lastEditedBy" : "b3df7daa-d323-438c-89a4-583f939bcfae",
        "tags" : [
        ]
      }
    ],
    "commit" : "1d07d303059ef3b2378cec1548f2611ec7022c5d",
    "line" : 26,
    "diffHunk" : "@@ -1,1 +815,819 @@\t\treturn nil, nil, err\n\t}\n\treturn clientConfig, closeAllConns, nil\n}\n"
  },
  {
    "id" : "d3a933c6-2cef-4e9a-a1bc-97beb2358834",
    "prId" : 71174,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/71174#pullrequestreview-176530677",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d5d14d28-e8c1-4144-bbb2-e44585ec94d7",
        "parentId" : null,
        "authorId" : "2ce2b44c-9841-49e7-983e-fb7696974908",
        "body" : "thanks a lot working on this and the detailed comments!\r\ndo you think that kubeadm should move away from the high-powered kubeconfig model?\r\n\r\nto me it feels like we are adding a workaround for something that kubeadm is doing.\r\n\r\nwill cc @luxas here, although not sure if he will have the time to take a look.\r\n",
        "createdAt" : "2018-11-19T15:43:50Z",
        "updatedAt" : "2018-11-19T15:48:26Z",
        "lastEditedBy" : "2ce2b44c-9841-49e7-983e-fb7696974908",
        "tags" : [
        ]
      },
      {
        "id" : "53a55a9b-2a2f-46e1-82f6-8da00d2056c8",
        "parentId" : "d5d14d28-e8c1-4144-bbb2-e44585ec94d7",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "For back compat we need to continue to support it.  I think kubeadm should be able to switch to setting bootstrap-kubeconfig equal to their high powered cert on masters, because all root file access on masters is powerful.  Then we could remove the need to support this case.",
        "createdAt" : "2018-11-19T22:34:20Z",
        "updatedAt" : "2018-11-19T22:34:20Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "9bb5d2ad-9d1c-4d80-ae0d-a83eeee6d9b8",
        "parentId" : "d5d14d28-e8c1-4144-bbb2-e44585ec94d7",
        "authorId" : "2ce2b44c-9841-49e7-983e-fb7696974908",
        "body" : "we briefly discussed this today with @fabriziopandini and he had a proposal.\r\n",
        "createdAt" : "2018-11-19T22:37:45Z",
        "updatedAt" : "2018-11-19T22:37:45Z",
        "lastEditedBy" : "2ce2b44c-9841-49e7-983e-fb7696974908",
        "tags" : [
        ]
      }
    ],
    "commit" : "fde87329cbfbd08c6cdf3b6b8dd354ee8e10a858",
    "line" : 146,
    "diffHunk" : "@@ -1,1 +755,759 @@\t\t// the kubeconfig file be managed by this process. For backwards compatibility with kubeadm,\n\t\t// which provides a high powered kubeconfig on the master with cert/key data, we must\n\t\t// bootstrap the cert manager with the contents of the initial client config.\n\n\t\tklog.Infof(\"Client rotation is on, will bootstrap in background\")"
  },
  {
    "id" : "cbcc9ebb-cc9e-4c4d-baf3-27c53b969820",
    "prId" : 69890,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/69890#pullrequestreview-167198944",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "13c39c8f-e94c-41f6-84c6-523f7174281e",
        "parentId" : null,
        "authorId" : "e81e699e-eb6c-4380-bfd5-16ab81ac51d6",
        "body" : "Should this get called before starting the cert managed above?",
        "createdAt" : "2018-10-17T22:34:59Z",
        "updatedAt" : "2018-11-17T02:51:21Z",
        "lastEditedBy" : "e81e699e-eb6c-4380-bfd5-16ab81ac51d6",
        "tags" : [
        ]
      },
      {
        "id" : "cb453659-c950-4831-bf90-06711b007d42",
        "parentId" : "13c39c8f-e94c-41f6-84c6-523f7174281e",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "this is in the unmanaged path.  In the managed path bootstrap is managed by the manager.",
        "createdAt" : "2018-10-23T03:28:41Z",
        "updatedAt" : "2018-11-17T02:51:21Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      }
    ],
    "commit" : "de293b2d7ddb687850258370f2a7f30f224f0ec1",
    "line" : 160,
    "diffHunk" : "@@ -1,1 +769,773 @@\t}\n\n\tif len(s.BootstrapKubeconfig) > 0 {\n\t\tif err := bootstrap.LoadClientCert(s.KubeConfig, s.BootstrapKubeconfig, s.CertDirectory, nodeName); err != nil {\n\t\t\treturn nil, nil, err"
  },
  {
    "id" : "0e3c084a-f185-4c69-8c06-26504e3e4563",
    "prId" : 69890,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/69890#pullrequestreview-176037428",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c4cd27e6-62f2-4f64-9c18-ea66dea7d886",
        "parentId" : null,
        "authorId" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "body" : "stray new line.",
        "createdAt" : "2018-11-17T01:56:47Z",
        "updatedAt" : "2018-11-17T02:51:21Z",
        "lastEditedBy" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "tags" : [
        ]
      },
      {
        "id" : "5b334e59-7771-4442-b31e-888efb76defe",
        "parentId" : "c4cd27e6-62f2-4f64-9c18-ea66dea7d886",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "intentional to make the blocks easier to read.  I may make this a switch instead.",
        "createdAt" : "2018-11-17T02:45:33Z",
        "updatedAt" : "2018-11-17T02:51:21Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      }
    ],
    "commit" : "de293b2d7ddb687850258370f2a7f30f224f0ec1",
    "line" : 38,
    "diffHunk" : "@@ -1,1 +547,551 @@\t\tkubeDeps.HeartbeatClient = nil\n\t\tklog.Warningf(\"standalone mode, no API client\")\n\n\tcase kubeDeps.KubeClient == nil, kubeDeps.EventClient == nil, kubeDeps.HeartbeatClient == nil, kubeDeps.DynamicKubeClient == nil:\n\t\tclientConfig, closeAllConns, err := buildKubeletClientConfig(s, nodeName)"
  },
  {
    "id" : "1ad857e7-3650-4619-9ac7-0ce792931ee9",
    "prId" : 67803,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/67803#pullrequestreview-151572801",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d9520a05-2d86-4442-91e0-0dbaa0a6b393",
        "parentId" : null,
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "What value does csiClient have at this point? It is referenced below. Typically one assumes one shouldn't use a value paired with a non-nil error.",
        "createdAt" : "2018-08-31T20:49:09Z",
        "updatedAt" : "2018-08-31T21:07:59Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "f1de9b39-6bd2-4100-a7a4-be72f656a370",
        "parentId" : "d9520a05-2d86-4442-91e0-0dbaa0a6b393",
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "The pattern in this files seems to be just log it and use the value any way. I'm happy to change it for this to either return an error (fail fast) or nil the `csiClient` before continuing. Let me know what you prefer.",
        "createdAt" : "2018-08-31T23:33:19Z",
        "updatedAt" : "2018-08-31T23:33:19Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      }
    ],
    "commit" : "fdeb895d25f21ad67ed4db488879532d40aae16e",
    "line" : 24,
    "diffHunk" : "@@ -1,1 +614,618 @@\t\tcsiClient, err := csiclientset.NewForConfig(clientConfig)\n\t\tif err != nil {\n\t\t\tglog.Warningf(\"Failed to create CSI API client: %v\", err)\n\t\t}\n"
  },
  {
    "id" : "cc4f1e9c-2c99-48e1-9860-14a9b122eaaf",
    "prId" : 63859,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/63859#pullrequestreview-123491629",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d883fd45-0c90-47fc-ad5b-3f838f2cfd40",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "so `done`  is a lockfile-based method for telling the kublet to shut down, and stopCh is a signal-based mechanism? I'm surprised we weren't already passing `done` down into RunKubelet to get graceful shutdowns",
        "createdAt" : "2018-05-24T19:29:52Z",
        "updatedAt" : "2018-05-24T19:52:40Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "079dd772-183b-4b79-b535-ec2f5ddaa509",
        "parentId" : "d883fd45-0c90-47fc-ad5b-3f838f2cfd40",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "should we be calling `SdNotify(false, \"STOPPING=1\")` as part of shutdown?\r\n\r\ndo we have to wait until RunKubelet has finished responding to the closed stopCh (presumably it is doing teardown sorts of things) before we return?",
        "createdAt" : "2018-05-24T19:31:44Z",
        "updatedAt" : "2018-05-24T19:52:40Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "f248ce46-ee89-46c2-b4f3-31de9c260d7d",
        "parentId" : "d883fd45-0c90-47fc-ad5b-3f838f2cfd40",
        "authorId" : "6f007220-e297-4289-a947-06c164b528d2",
        "body" : "> should we be calling SdNotify(false, \"STOPPING=1\") as part of shutdown?\r\n\r\nThat I don't know; I'm speculating that we don't see this call in the tree at all because we didn't really gracefully shutdown before. \r\n",
        "createdAt" : "2018-05-24T19:59:55Z",
        "updatedAt" : "2018-05-24T20:16:46Z",
        "lastEditedBy" : "6f007220-e297-4289-a947-06c164b528d2",
        "tags" : [
        ]
      },
      {
        "id" : "7dc653cd-af5f-4908-83cb-1265538d41e6",
        "parentId" : "d883fd45-0c90-47fc-ad5b-3f838f2cfd40",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "You don't have to call the shutdown signal.",
        "createdAt" : "2018-05-25T19:37:53Z",
        "updatedAt" : "2018-05-25T19:37:53Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      }
    ],
    "commit" : "ca58578b240a40da487f366b0200698616aa2017",
    "line" : 66,
    "diffHunk" : "@@ -1,1 +740,744 @@\tgo daemon.SdNotify(false, \"READY=1\")\n\n\tselect {\n\tcase <-done:\n\t\tbreak"
  },
  {
    "id" : "195373da-c073-4d82-8a29-1ff4168fd10d",
    "prId" : 63314,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/63314#pullrequestreview-119976949",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4979bdf6-5359-4fa0-948e-9d6fb471ceab",
        "parentId" : null,
        "authorId" : "d2b16581-e7e9-48b8-9f76-6f6bcb9ec300",
        "body" : "nit: i'm generally not a fan of giving nil an implicit meaning.  I would rather have an explicit return value indicating if we should use local or remote.",
        "createdAt" : "2018-05-10T23:53:40Z",
        "updatedAt" : "2018-05-15T18:25:25Z",
        "lastEditedBy" : "d2b16581-e7e9-48b8-9f76-6f6bcb9ec300",
        "tags" : [
        ]
      },
      {
        "id" : "b58f3bad-90a7-43e0-b8b7-7ac151b5e177",
        "parentId" : "4979bdf6-5359-4fa0-948e-9d6fb471ceab",
        "authorId" : "881df817-68e6-43dd-b4ea-f0b973f7dc41",
        "body" : "I'm not sure I agree in this case.\r\nThe controller bootstrap returns the dynamic config if it exists.\r\nIf there's no dynamic config to use it returns nil (`nil` => `Nothing` is a common idiom in Go). \r\nIn the case that there's no dynamic config to use, we just move on and use the local.\r\n\r\nI think adding a fourth return value to tag the result is unnecessary, given the ubiquity of that idiom.",
        "createdAt" : "2018-05-11T17:11:28Z",
        "updatedAt" : "2018-05-15T18:25:25Z",
        "lastEditedBy" : "881df817-68e6-43dd-b4ea-f0b973f7dc41",
        "tags" : [
        ]
      },
      {
        "id" : "37637109-e28b-47ff-a2f9-530c51bcfa7e",
        "parentId" : "4979bdf6-5359-4fa0-948e-9d6fb471ceab",
        "authorId" : "d2b16581-e7e9-48b8-9f76-6f6bcb9ec300",
        "body" : "sgtm",
        "createdAt" : "2018-05-14T19:32:37Z",
        "updatedAt" : "2018-05-15T18:25:25Z",
        "lastEditedBy" : "d2b16581-e7e9-48b8-9f76-6f6bcb9ec300",
        "tags" : [
        ]
      }
    ],
    "commit" : "fcc1f8e7b6f457940f75943638a83a1a26405358",
    "line" : 26,
    "diffHunk" : "@@ -1,1 +211,215 @@\t\t\t\t}\n\t\t\t\t// If we should just use our existing, local config, the controller will return a nil config\n\t\t\t\tif dynamicKubeletConfig != nil {\n\t\t\t\t\tkubeletConfig = dynamicKubeletConfig\n\t\t\t\t\t// We must enforce flag precedence by re-parsing the command line into the new object."
  },
  {
    "id" : "e1439cf2-b6a9-45e9-9bc2-416f26fee270",
    "prId" : 62183,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/62183#pullrequestreview-112162467",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "805102a1-7284-4677-9c11-e154512f254a",
        "parentId" : null,
        "authorId" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "body" : "still need this?",
        "createdAt" : "2018-04-11T21:01:08Z",
        "updatedAt" : "2018-04-13T20:09:20Z",
        "lastEditedBy" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "tags" : [
        ]
      },
      {
        "id" : "8dd4799b-652c-4e56-a87c-14344c886f92",
        "parentId" : "805102a1-7284-4677-9c11-e154512f254a",
        "authorId" : "881df817-68e6-43dd-b4ea-f0b973f7dc41",
        "body" : "I've used this in a number of debugging scenarios, I figure we might as well leave it at v=5.",
        "createdAt" : "2018-04-13T21:18:38Z",
        "updatedAt" : "2018-04-13T21:18:38Z",
        "lastEditedBy" : "881df817-68e6-43dd-b4ea-f0b973f7dc41",
        "tags" : [
        ]
      }
    ],
    "commit" : "420edc7b50ff035fb5773e0590c2f6d21898d5f8",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +230,234 @@\n\t\t\t// run the kubelet\n\t\t\tglog.V(5).Infof(\"KubeletConfiguration: %#v\", kubeletServer.KubeletConfiguration)\n\t\t\tif err := Run(kubeletServer, kubeletDeps); err != nil {\n\t\t\t\tglog.Fatal(err)"
  },
  {
    "id" : "85c98481-78ee-4205-b1fb-5489bd30af10",
    "prId" : 59062,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/59062#pullrequestreview-92696409",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ba033e8b-37e4-4f76-90d9-72ee1a442f35",
        "parentId" : null,
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "This has a default, right?",
        "createdAt" : "2018-01-30T19:04:20Z",
        "updatedAt" : "2018-01-30T19:43:58Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "ab513cf0-d0eb-4d3f-bf16-224e401a52bd",
        "parentId" : "ba033e8b-37e4-4f76-90d9-72ee1a442f35",
        "authorId" : "881df817-68e6-43dd-b4ea-f0b973f7dc41",
        "body" : "Yes, default is -1: https://github.com/kubernetes/kubernetes/blob/master/pkg/kubelet/apis/kubeletconfig/v1alpha1/defaults.go#L132",
        "createdAt" : "2018-01-30T19:46:05Z",
        "updatedAt" : "2018-01-30T19:46:05Z",
        "lastEditedBy" : "881df817-68e6-43dd-b4ea-f0b973f7dc41",
        "tags" : [
        ]
      }
    ],
    "commit" : "da41a6e793ba7f913e430db525615e347d41953b",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +654,658 @@\t\t\t\tExperimentalCPUManagerPolicy:          s.CPUManagerPolicy,\n\t\t\t\tExperimentalCPUManagerReconcilePeriod: s.CPUManagerReconcilePeriod.Duration,\n\t\t\t\tExperimentalPodPidsLimit:              s.PodPidsLimit,\n\t\t\t},\n\t\t\ts.FailSwapOn,"
  },
  {
    "id" : "170de28f-a775-4a93-89c9-d27bb382fbdd",
    "prId" : 58405,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/58405#pullrequestreview-89627885",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "155f6c64-3c43-4855-ba88-c4dc8b53fa87",
        "parentId" : null,
        "authorId" : "881df817-68e6-43dd-b4ea-f0b973f7dc41",
        "body" : "We will need to make sure it's still possible for the Kubelet to re-parse its command line multiple times during its bootstrap, see #56995 and #56171. I'd suppose this can be done with the args []string passed in here but need to make sure.",
        "createdAt" : "2018-01-17T23:06:47Z",
        "updatedAt" : "2018-01-18T15:14:53Z",
        "lastEditedBy" : "881df817-68e6-43dd-b4ea-f0b973f7dc41",
        "tags" : [
        ]
      },
      {
        "id" : "c6d4adde-b430-4183-b454-477b150485f9",
        "parentId" : "155f6c64-3c43-4855-ba88-c4dc8b53fa87",
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "Reparsing is possible. I'll link you to some OpenShift code that does it. In general, be careful about doing it.",
        "createdAt" : "2018-01-17T23:24:16Z",
        "updatedAt" : "2018-01-18T15:14:53Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      }
    ],
    "commit" : "d113f0fe05ace643128b24baed81af767740dd21",
    "line" : 36,
    "diffHunk" : "@@ -1,1 +125,129 @@HTTP server: The kubelet can also listen for HTTP and respond to a simple API\n(underspec'd currently) to submit a new manifest.`,\n\t\tRun: func(cmd *cobra.Command, args []string) {\n\t\t\t// short-circuit on verflag\n\t\t\tverflag.PrintAndExitIfRequested()"
  },
  {
    "id" : "98a4ed41-f6b5-4b7b-a314-3efb5aa39a20",
    "prId" : 56995,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/56995#pullrequestreview-90364848",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "703d76f1-8e3b-4c32-b993-b81b9065da8d",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "does it strip any parent command args (e.g. `hyperkube kubelet`) or does it leave us with essentially `os.Args[1:]`?",
        "createdAt" : "2018-01-20T05:34:47Z",
        "updatedAt" : "2018-01-29T18:10:10Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "3b99fc1e-caed-49d7-8900-29799428a080",
        "parentId" : "703d76f1-8e3b-4c32-b993-b81b9065da8d",
        "authorId" : "881df817-68e6-43dd-b4ea-f0b973f7dc41",
        "body" : "I think it strips parent command args, based on my reading of the cobra internals, but I still have to write a small test program to confirm.",
        "createdAt" : "2018-01-22T02:01:16Z",
        "updatedAt" : "2018-01-29T18:10:10Z",
        "lastEditedBy" : "881df817-68e6-43dd-b4ea-f0b973f7dc41",
        "tags" : [
        ]
      },
      {
        "id" : "17d0d169-9439-42b9-b0aa-0bdd4b4927ba",
        "parentId" : "703d76f1-8e3b-4c32-b993-b81b9065da8d",
        "authorId" : "881df817-68e6-43dd-b4ea-f0b973f7dc41",
        "body" : "It strips parent command names.\r\n\r\nTest program:\r\n```\r\npackage main\r\n\r\nimport (\r\n\t\"fmt\"\r\n\t\"os\"\r\n\r\n\t\"github.com/spf13/cobra\"\r\n)\r\n\r\nfunc main() {\r\n\tparent := &cobra.Command{\r\n\t\tUse: \"parent\",\r\n\t\tRun: func(cmd *cobra.Command, args []string) {},\r\n\t}\r\n\tchild := &cobra.Command{\r\n\t\tUse:                \"child\",\r\n\t\tDisableFlagParsing: true,\r\n\t\tRun: func(cmd *cobra.Command, args []string) {\r\n\t\t\tfmt.Println(args)\r\n\t\t},\r\n\t}\r\n\tparent.AddCommand(child)\r\n\tif err := parent.Execute(); err != nil {\r\n\t\tfmt.Fprintf(os.Stderr, \"%v\\n\", err)\r\n\t\tos.Exit(1)\r\n\t}\r\n}\r\n```\r\n\r\nOutput:\r\n```\r\n$ ./parent child --foo\r\n[--foo]\r\n```",
        "createdAt" : "2018-01-22T03:41:29Z",
        "updatedAt" : "2018-01-29T18:10:10Z",
        "lastEditedBy" : "881df817-68e6-43dd-b4ea-f0b973f7dc41",
        "tags" : [
        ]
      }
    ],
    "commit" : "42589266407e32fdf716d1fef689f0aee7142cd9",
    "line" : 47,
    "diffHunk" : "@@ -1,1 +134,138 @@\t\t// DisableFlagParsing=true provides the full set of flags passed to the kubelet in the\n\t\t// `args` arg to Run, without Cobra's interference.\n\t\tDisableFlagParsing: true,\n\t\tRun: func(cmd *cobra.Command, args []string) {\n\t\t\t// initial flag parse, since we disable cobra's flag parsing"
  },
  {
    "id" : "af463b98-4020-4027-b5b1-ce94a9cfc140",
    "prId" : 53088,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/53088#pullrequestreview-68416270",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5a63a737-ff80-4308-a100-8b4e605599ca",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "holy crap, can't we just pass the whole flags?",
        "createdAt" : "2017-10-10T19:56:08Z",
        "updatedAt" : "2017-10-11T16:53:07Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "be3e17a6-e063-425b-8aa0-cadfdac390be",
        "parentId" : "5a63a737-ff80-4308-a100-8b4e605599ca",
        "authorId" : "881df817-68e6-43dd-b4ea-f0b973f7dc41",
        "body" : "People don't like it if pkg depends on cmd, which it would have to to get the type for the flags struct. Doesn't necessarily make sense to move the flags struct to pkg if it contains stuff that's only used in cmd.",
        "createdAt" : "2017-10-10T20:31:41Z",
        "updatedAt" : "2017-10-11T16:53:07Z",
        "lastEditedBy" : "881df817-68e6-43dd-b4ea-f0b973f7dc41",
        "tags" : [
        ]
      }
    ],
    "commit" : "8180536bedd8bee2e7d05922c9a135b2ef9afd54",
    "line" : 15,
    "diffHunk" : "@@ -1,1 +700,704 @@\tk, err := builder(kubeCfg,\n\t\tkubeDeps,\n\t\t&kubeFlags.ContainerRuntimeOptions,\n\t\tkubeFlags.HostnameOverride,\n\t\tkubeFlags.NodeIP,"
  },
  {
    "id" : "db2c7686-bd7c-4f93-a7ba-e9d59777b161",
    "prId" : 41912,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/41912#pullrequestreview-41072845",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "63b56925-c8ca-4428-bf90-687da421b5bd",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "you can't assume the `clientConfig` is cert-based, right? starting a node with a `--kubeconfig` that authenticates with a token is completely valid. What does the certificate manager do in that case?",
        "createdAt" : "2017-05-23T20:29:34Z",
        "updatedAt" : "2017-06-01T16:29:51Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "8d120161-23a5-479b-b81c-a3a1bdec65f3",
        "parentId" : "63b56925-c8ca-4428-bf90-687da421b5bd",
        "authorId" : "b8d9ba23-8a1c-44a6-afe2-8ac9498838bb",
        "body" : "If the clientConfig doesn't have certificate data then the certificate manager is initialized without any certs. It will try to use the client to get some as soon `.Start()` is called. However the Certificate Signing Request client is initialized and authenticated is outside the responsibility of the certificate manager. It just uses whatever it is given.\r\n\r\nDo you think that if a token is supplied and no certs then the certificate manager should be disabled?",
        "createdAt" : "2017-05-29T19:42:59Z",
        "updatedAt" : "2017-06-01T16:29:51Z",
        "lastEditedBy" : "b8d9ba23-8a1c-44a6-afe2-8ac9498838bb",
        "tags" : [
        ]
      },
      {
        "id" : "5c1229ff-2825-4192-9a47-3a29456c4b0e",
        "parentId" : "63b56925-c8ca-4428-bf90-687da421b5bd",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "Maybe I misread what this is used for. We can't use it to build the client used to obtain/renew the cert (since a token would be just as valid as a starting credential).",
        "createdAt" : "2017-05-29T19:48:18Z",
        "updatedAt" : "2017-06-01T16:29:51Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "6d60e880-0f42-4ddd-8035-92c7186976c6",
        "parentId" : "63b56925-c8ca-4428-bf90-687da421b5bd",
        "authorId" : "b8d9ba23-8a1c-44a6-afe2-8ac9498838bb",
        "body" : "When do you think the token should be used vs the cert?",
        "createdAt" : "2017-05-30T17:54:04Z",
        "updatedAt" : "2017-06-01T16:29:51Z",
        "lastEditedBy" : "b8d9ba23-8a1c-44a6-afe2-8ac9498838bb",
        "tags" : [
        ]
      },
      {
        "id" : "ab9da970-b3c0-4993-a428-928fb15d4222",
        "parentId" : "63b56925-c8ca-4428-bf90-687da421b5bd",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "talked offline, I misunderstood what the initial cert/key were used for, especially since no CSR client was being passed in here",
        "createdAt" : "2017-05-30T20:58:57Z",
        "updatedAt" : "2017-06-01T16:29:51Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "1519bb94dc9a50534c0fc0409267b758a5e78cc8",
    "line" : 45,
    "diffHunk" : "@@ -1,1 +460,464 @@\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tclientCertificateManager, err = initializeClientCertificateManager(s.CertDirectory, nodeName, clientConfig.CertData, clientConfig.KeyData)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err"
  },
  {
    "id" : "e6e4bf95-6d67-4d87-a532-ac0cace19ad3",
    "prId" : 41912,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/41912#pullrequestreview-41078633",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6c83e612-709f-44a3-a816-70430edb1fdd",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "can be a follow-up or future improvement, but do we want the certificate manager to log events about cert renewals? write to the audit log?",
        "createdAt" : "2017-05-30T21:02:15Z",
        "updatedAt" : "2017-06-01T16:29:51Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "8a7744ec-4b11-4c4c-9c49-066c5dc9b4e6",
        "parentId" : "6c83e612-709f-44a3-a816-70430edb1fdd",
        "authorId" : "b8d9ba23-8a1c-44a6-afe2-8ac9498838bb",
        "body" : "I have a log statement in the certificate_manager each time it [requests](https://github.com/kubernetes/kubernetes/blob/master/pkg/kubelet/certificate/certificate_manager.go#L324) a certificate.",
        "createdAt" : "2017-05-30T21:07:23Z",
        "updatedAt" : "2017-06-01T16:29:51Z",
        "lastEditedBy" : "b8d9ba23-8a1c-44a6-afe2-8ac9498838bb",
        "tags" : [
        ]
      },
      {
        "id" : "f70207ad-6c27-4523-bc92-a8ed1952ac23",
        "parentId" : "6c83e612-709f-44a3-a816-70430edb1fdd",
        "authorId" : "b8d9ba23-8a1c-44a6-afe2-8ac9498838bb",
        "body" : "Audit log when the request is complete so there can be a review certificate updates in the cluster?",
        "createdAt" : "2017-05-30T21:14:35Z",
        "updatedAt" : "2017-06-01T16:29:51Z",
        "lastEditedBy" : "b8d9ba23-8a1c-44a6-afe2-8ac9498838bb",
        "tags" : [
        ]
      },
      {
        "id" : "418d44ad-1405-4a0f-8211-8811bdbdb112",
        "parentId" : "6c83e612-709f-44a3-a816-70430edb1fdd",
        "authorId" : "0adf587c-aaa2-4e47-be0f-a26d4fde14ac",
        "body" : "We don't really have auditing in the kubelet yet, but the CSR should be picked up in the apiserver audit log (as long as it's configured).",
        "createdAt" : "2017-05-30T21:21:41Z",
        "updatedAt" : "2017-06-01T16:29:51Z",
        "lastEditedBy" : "0adf587c-aaa2-4e47-be0f-a26d4fde14ac",
        "tags" : [
        ]
      }
    ],
    "commit" : "1519bb94dc9a50534c0fc0409267b758a5e78cc8",
    "line" : 59,
    "diffHunk" : "@@ -1,1 +474,478 @@\t\t\t} else if kubeClient.Certificates() != nil && clientCertificateManager != nil {\n\t\t\t\tglog.V(2).Info(\"Starting client certificate rotation.\")\n\t\t\t\tclientCertificateManager.SetCertificateSigningRequestClient(kubeClient.Certificates().CertificateSigningRequests())\n\t\t\t\tclientCertificateManager.Start()\n\t\t\t}"
  },
  {
    "id" : "1c83290a-763d-4b8a-b25f-17d078eef30c",
    "prId" : 41912,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/41912#pullrequestreview-41354935",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b6af6e30-cad5-4e84-971e-a79dad3b869a",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "mutating one clientConfig like this is going to cause mismatches between clients built in different parts of the kubelet init process (there's even a mismatch in this file in the other place we invoke `CreateAPIServerClientConfig(s)`)",
        "createdAt" : "2017-05-31T15:47:14Z",
        "updatedAt" : "2017-06-01T16:29:51Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "6f1eb9fe-be40-4ed3-93a0-23132f168bc9",
        "parentId" : "b6af6e30-cad5-4e84-971e-a79dad3b869a",
        "authorId" : "b8d9ba23-8a1c-44a6-afe2-8ac9498838bb",
        "body" : "Not familiar with `CreateAPIServerClientConfig` but `updateTransport` is called where the certificate manager is initialized, so if there are other clientConfigs that aren't getting updated then that should mean they don't have an associated certificate manager. Are they using the same certificates?\r\n\r\nIn order to get live certificate rotation, I need to attach a callback function to the tls.Transport. Do you have a different approach in mind you would like to suggest?",
        "createdAt" : "2017-05-31T17:49:22Z",
        "updatedAt" : "2017-06-01T16:29:51Z",
        "lastEditedBy" : "b8d9ba23-8a1c-44a6-afe2-8ac9498838bb",
        "tags" : [
        ]
      },
      {
        "id" : "b80ba54d-3ba3-4e9d-bc9d-1479d828480a",
        "parentId" : "b6af6e30-cad5-4e84-971e-a79dad3b869a",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "looks like the dynamic kubelet config loader is the only other user of CreateAPIServerClientConfig (today)... need a follow-up to plumb the cert-rotating-enabled client to the background process responsible for monitoring config",
        "createdAt" : "2017-05-31T20:49:10Z",
        "updatedAt" : "2017-06-01T16:29:51Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "7ff1aad1-f1ad-4eeb-b9b2-b8b4239576c9",
        "parentId" : "b6af6e30-cad5-4e84-971e-a79dad3b869a",
        "authorId" : "b8d9ba23-8a1c-44a6-afe2-8ac9498838bb",
        "body" : "https://github.com/kubernetes/kubernetes/issues/46730",
        "createdAt" : "2017-05-31T20:56:29Z",
        "updatedAt" : "2017-06-01T16:29:51Z",
        "lastEditedBy" : "b8d9ba23-8a1c-44a6-afe2-8ac9498838bb",
        "tags" : [
        ]
      }
    ],
    "commit" : "1519bb94dc9a50534c0fc0409267b758a5e78cc8",
    "line" : 68,
    "diffHunk" : "@@ -1,1 +623,627 @@}\n\nfunc updateTransport(clientConfig *restclient.Config, clientCertificateManager certificate.Manager) error {\n\tif clientConfig.Transport != nil {\n\t\treturn fmt.Errorf(\"there is already a transport configured\")"
  },
  {
    "id" : "0e167cd6-75b6-4972-914f-58e1e7834f40",
    "prId" : 41912,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/41912#pullrequestreview-41348269",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c9d5240c-94cc-412c-af51-3d6d9066f320",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "empty CAFile as well",
        "createdAt" : "2017-05-31T17:39:20Z",
        "updatedAt" : "2017-06-01T16:29:51Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "ee74efab-d082-48ba-85a7-c7ecf9258383",
        "parentId" : "c9d5240c-94cc-412c-af51-3d6d9066f320",
        "authorId" : "b8d9ba23-8a1c-44a6-afe2-8ac9498838bb",
        "body" : "Done.",
        "createdAt" : "2017-05-31T20:31:46Z",
        "updatedAt" : "2017-06-01T16:29:51Z",
        "lastEditedBy" : "b8d9ba23-8a1c-44a6-afe2-8ac9498838bb",
        "tags" : [
        ]
      }
    ],
    "commit" : "1519bb94dc9a50534c0fc0409267b758a5e78cc8",
    "line" : 101,
    "diffHunk" : "@@ -1,1 +656,660 @@\tclientConfig.CertFile = \"\"\n\tclientConfig.KeyFile = \"\"\n\tclientConfig.CAData = nil\n\tclientConfig.CAFile = \"\"\n\treturn nil"
  },
  {
    "id" : "f86a0e75-e60a-46d6-9eca-b391eef28a84",
    "prId" : 41912,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/41912#pullrequestreview-41349187",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "98322617-5c07-456f-bead-5e407fab68d3",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "if clientConfig already has a Transport set, return an error",
        "createdAt" : "2017-05-31T17:46:24Z",
        "updatedAt" : "2017-06-01T16:29:51Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "02793065-f622-48a5-bd69-8da813a93867",
        "parentId" : "98322617-5c07-456f-bead-5e407fab68d3",
        "authorId" : "b8d9ba23-8a1c-44a6-afe2-8ac9498838bb",
        "body" : "Done.",
        "createdAt" : "2017-05-31T20:35:04Z",
        "updatedAt" : "2017-06-01T16:29:51Z",
        "lastEditedBy" : "b8d9ba23-8a1c-44a6-afe2-8ac9498838bb",
        "tags" : [
        ]
      }
    ],
    "commit" : "1519bb94dc9a50534c0fc0409267b758a5e78cc8",
    "line" : 68,
    "diffHunk" : "@@ -1,1 +623,627 @@}\n\nfunc updateTransport(clientConfig *restclient.Config, clientCertificateManager certificate.Manager) error {\n\tif clientConfig.Transport != nil {\n\t\treturn fmt.Errorf(\"there is already a transport configured\")"
  },
  {
    "id" : "d3435d1b-2ff8-42aa-8c93-7dbbfcf6f75c",
    "prId" : 40867,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/40867#pullrequestreview-19809058",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b868a9f9-4a7d-450c-b458-b7e6486b1a23",
        "parentId" : null,
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "It's not really something the admin will understand.",
        "createdAt" : "2017-02-02T15:21:24Z",
        "updatedAt" : "2017-02-02T15:21:24Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      },
      {
        "id" : "1db62257-791a-4863-96f2-e4c9f13a992b",
        "parentId" : "b868a9f9-4a7d-450c-b458-b7e6486b1a23",
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "> It's not really something the admin will understand.\r\n\r\nPrexisting from the original",
        "createdAt" : "2017-02-02T15:24:41Z",
        "updatedAt" : "2017-02-02T15:24:41Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      }
    ],
    "commit" : "ab7e4d568ef5f3aee7494ca1f8143869d669bd7d",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +399,403 @@\t\t\texternalKubeClient, err = clientgoclientset.NewForConfig(clientConfig)\n\t\t\tif err != nil {\n\t\t\t\tglog.Warningf(\"New kubeClient from clientConfig error: %v\", err)\n\t\t\t}\n\t\t\t// make a separate client for events"
  },
  {
    "id" : "e50ad244-ba42-49cc-a6d4-516d83b038c8",
    "prId" : 40710,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/40710#pullrequestreview-19329020",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ac2ea52c-8bba-4bb8-8c8c-ce30685b14e9",
        "parentId" : null,
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "this is getting complicate. Some import with `client` prefix are from client-go, some are not.",
        "createdAt" : "2017-01-31T14:03:05Z",
        "updatedAt" : "2017-02-01T00:55:03Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      },
      {
        "id" : "2c6c5961-d467-4886-b774-728dd56bbd71",
        "parentId" : "ac2ea52c-8bba-4bb8-8c8c-ce30685b14e9",
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "> this is getting complicate. Some import with client prefix are from client-go, some are not.\r\n\r\nI was trying to avoid changing import prefixes where I could to keep the diff smaller.  Force consistency later or you want it here?  ",
        "createdAt" : "2017-01-31T14:05:30Z",
        "updatedAt" : "2017-02-01T00:55:03Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      },
      {
        "id" : "fa4b6a80-7656-4076-ae91-f41c24543d58",
        "parentId" : "ac2ea52c-8bba-4bb8-8c8c-ce30685b14e9",
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "No, keeping it small is fine. We have tons of those renames to do. These few do not make a big difference.",
        "createdAt" : "2017-01-31T14:44:35Z",
        "updatedAt" : "2017-02-01T00:55:03Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      }
    ],
    "commit" : "a12d45a24031d20dfffd5186eef675f77260b2bd",
    "line" : 17,
    "diffHunk" : "@@ -1,1 +60,64 @@\t\"k8s.io/kubernetes/pkg/capabilities\"\n\t\"k8s.io/kubernetes/pkg/client/chaosclient\"\n\t\"k8s.io/kubernetes/pkg/client/clientset_generated/clientset\"\n\t\"k8s.io/kubernetes/pkg/cloudprovider\"\n\t\"k8s.io/kubernetes/pkg/credentialprovider\""
  },
  {
    "id" : "35b965e6-c886-4a35-8f26-30afb2ebca10",
    "prId" : 39442,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/39442#pullrequestreview-15336549",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4a8f445b-d77b-4345-bf50-00fff7267cbf",
        "parentId" : null,
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "put some comments why we have all this client-go logic now.",
        "createdAt" : "2017-01-05T15:59:34Z",
        "updatedAt" : "2017-01-09T21:53:26Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      },
      {
        "id" : "1e8f1746-8908-4959-84c9-d1deb14f6b11",
        "parentId" : "4a8f445b-d77b-4345-bf50-00fff7267cbf",
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "done",
        "createdAt" : "2017-01-05T16:20:46Z",
        "updatedAt" : "2017-01-09T21:53:26Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      }
    ],
    "commit" : "1df5b658f2755092f94582791b3a8618158362e0",
    "line" : null,
    "diffHunk" : "@@ -1,1 +417,421 @@\t\t// up from scratch twice.\n\t\t// TODO eventually the kubelet should only use the client-go library\n\t\tclientGoConfig, err := createAPIServerClientGoConfig(s)\n\t\tif err == nil {\n\t\t\texternalKubeClient, err = clientgoclientset.NewForConfig(clientGoConfig)"
  },
  {
    "id" : "5543be51-6cd9-4a89-b3f2-0944534de88a",
    "prId" : 33066,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/33066#pullrequestreview-1049496",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "89dbc57c-b67e-49af-b2d6-7d63e2bd1924",
        "parentId" : null,
        "authorId" : "881df817-68e6-43dd-b4ea-f0b973f7dc41",
        "body" : "Are we sure we want to connect to the docker client this early? IMO the decision comes down to whether we typically want the docker client to already be connected to the daemon when we inject the client into the Kubelet, or if at this early a stage we just want the client to be set up so it can try connecting later. The former fails faster if it can't connect, the latter is lighter weight as far as building dependencies to inject. What do you think?\n",
        "createdAt" : "2016-09-21T16:30:47Z",
        "updatedAt" : "2016-09-21T16:30:47Z",
        "lastEditedBy" : "881df817-68e6-43dd-b4ea-f0b973f7dc41",
        "tags" : [
        ]
      },
      {
        "id" : "65d1166b-0add-4dd5-83a1-ef9c2be015b5",
        "parentId" : "89dbc57c-b67e-49af-b2d6-7d63e2bd1924",
        "authorId" : "4e418bc8-21fb-4523-80c1-9c751c193126",
        "body" : "We don't want, but we have to now.\nWe must set correct docker client api version so that docker can talk with daemon with correct version of remote api. Because we support multiple docker versions, we can only get it from docker daemon and update our client instead of hard coding the version.\n",
        "createdAt" : "2016-09-21T18:38:05Z",
        "updatedAt" : "2016-09-21T20:03:27Z",
        "lastEditedBy" : "4e418bc8-21fb-4523-80c1-9c751c193126",
        "tags" : [
        ]
      },
      {
        "id" : "4256fb93-ebbf-4fe6-bb72-8862f574e4d8",
        "parentId" : "89dbc57c-b67e-49af-b2d6-7d63e2bd1924",
        "authorId" : "881df817-68e6-43dd-b4ea-f0b973f7dc41",
        "body" : "Ok, gotta do what we gotta do.\n",
        "createdAt" : "2016-09-21T18:52:59Z",
        "updatedAt" : "2016-09-21T18:52:59Z",
        "lastEditedBy" : "881df817-68e6-43dd-b4ea-f0b973f7dc41",
        "tags" : [
        ]
      },
      {
        "id" : "26577800-d134-4dd1-b0c5-09f7baba6151",
        "parentId" : "89dbc57c-b67e-49af-b2d6-7d63e2bd1924",
        "authorId" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "body" : "There are ways to bypass this. E.g., we can add a variable `versionUpdated` in docker client, and check that before each call to make sure we've called `UpdateClientVersion` at least once. It'd add some more complexity.\n",
        "createdAt" : "2016-09-21T20:26:51Z",
        "updatedAt" : "2016-09-21T20:26:51Z",
        "lastEditedBy" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "tags" : [
        ]
      },
      {
        "id" : "53fe10f7-024a-45ce-b631-724a86165548",
        "parentId" : "89dbc57c-b67e-49af-b2d6-7d63e2bd1924",
        "authorId" : "4e418bc8-21fb-4523-80c1-9c751c193126",
        "body" : "@yujuhong I've also considered that, but it looks more complex. :( Hahaha\nAnother possible way is to do it in `runtime.Status()` and only mark runtime as ready when we've updated client version.\nHowever, it seems that some other components may still work even sync loop is blocked, such as image gc manager.\n",
        "createdAt" : "2016-09-21T21:46:54Z",
        "updatedAt" : "2016-09-21T21:53:59Z",
        "lastEditedBy" : "4e418bc8-21fb-4523-80c1-9c751c193126",
        "tags" : [
        ]
      }
    ],
    "commit" : "08d74f33f6a79f1fd3205b690689b491c7c9294e",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +127,131 @@\tvar dockerClient dockertools.DockerInterface\n\tif s.ContainerRuntime == \"docker\" {\n\t\tdockerClient = dockertools.ConnectToDockerOrDie(s.DockerEndpoint, s.RuntimeRequestTimeout.Duration)\n\t} else {\n\t\tdockerClient = nil"
  },
  {
    "id" : "9b172497-00c9-4030-9ff6-ec4897db842a",
    "prId" : 30922,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0b8b5428-68db-490b-adb5-d1d1ffa9e167",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "having this factored out is good, but we should use it in RunKubelet as well or we'll drift from how the node name is computed for real. pushed a commit to https://github.com/liggitt/kubernetes/commits/tls-bootstrap that unifies those two paths (and fixes the NPE at https://github.com/kubernetes/kubernetes/pull/30922/files/4120179db5ce6c3fadc872a268347f5be038f98f#r75416356)\n",
        "createdAt" : "2016-08-19T01:49:47Z",
        "updatedAt" : "2016-08-19T22:27:43Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "129e8161-aa61-4674-8a50-1fc4b9c7b735",
        "parentId" : "0b8b5428-68db-490b-adb5-d1d1ffa9e167",
        "authorId" : "227eb550-8b08-4420-9a78-279f840bd8de",
        "body" : "Fixed.\n",
        "createdAt" : "2016-08-19T18:18:32Z",
        "updatedAt" : "2016-08-19T22:27:43Z",
        "lastEditedBy" : "227eb550-8b08-4420-9a78-279f840bd8de",
        "tags" : [
        ]
      }
    ],
    "commit" : "26a66232610e627d4912fbd3dfb37afa8036dcf8",
    "line" : 68,
    "diffHunk" : "@@ -1,1 +457,461 @@// getNodeName returns the node name according to the cloud provider\n// if cloud provider is specified. Otherwise, returns the hostname of the node.\nfunc getNodeName(cloud cloudprovider.Interface, hostname string) (string, error) {\n\tif cloud == nil {\n\t\treturn hostname, nil"
  },
  {
    "id" : "ff7f01f2-42ce-4cb5-8a98-79e75a719ed9",
    "prId" : 30798,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "80d0a6cb-80eb-4eee-aac1-86fbb6cfe891",
        "parentId" : null,
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "We want the bootstrapping path to return a single error, so I moved this below so we don't get extraneous output from this part before we check the config (in bootstrapping it'll be common not to have a kube config)\n",
        "createdAt" : "2016-08-17T19:54:08Z",
        "updatedAt" : "2016-08-17T20:27:01Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      }
    ],
    "commit" : "a66828d73e0f8ca411daf93b6bc7c9ba029956ff",
    "line" : 60,
    "diffHunk" : "@@ -1,1 +356,360 @@\t\t}\n\n\t\tcfg, err := UnsecuredKubeletConfig(s)\n\t\tif err != nil {\n\t\t\treturn err"
  },
  {
    "id" : "66a8394c-c781-4439-ba60-1f30be682978",
    "prId" : 30090,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7b73e5b1-da82-4b34-8334-78ce19228cfb",
        "parentId" : null,
        "authorId" : "a6409368-42e0-44a9-bf79-9d3042ac3b65",
        "body" : "cc/ @zmerlynn @Random-Liu  on aws case. Potential hostname issue?\n",
        "createdAt" : "2016-08-19T21:31:45Z",
        "updatedAt" : "2016-08-23T14:42:59Z",
        "lastEditedBy" : "a6409368-42e0-44a9-bf79-9d3042ac3b65",
        "tags" : [
        ]
      },
      {
        "id" : "f3e167c6-d2d9-4ce5-907c-f2e9a377fb4f",
        "parentId" : "7b73e5b1-da82-4b34-8334-78ce19228cfb",
        "authorId" : "a6409368-42e0-44a9-bf79-9d3042ac3b65",
        "body" : "Please note that the below @mtaufen carefully get nodename from hostname through the cloud provider. I think there shouldn't be any confusion, but still want aws experts to double check here. \n",
        "createdAt" : "2016-08-19T21:34:58Z",
        "updatedAt" : "2016-08-23T14:42:59Z",
        "lastEditedBy" : "a6409368-42e0-44a9-bf79-9d3042ac3b65",
        "tags" : [
        ]
      },
      {
        "id" : "73e5af92-015e-4d20-a781-a098d6366129",
        "parentId" : "7b73e5b1-da82-4b34-8334-78ce19228cfb",
        "authorId" : "4e418bc8-21fb-4523-80c1-9c751c193126",
        "body" : "Yeah. Here we kept the original implementation https://github.com/kubernetes/kubernetes/blob/master/cmd/kubelet/app/server.go#L476-L494, which should be fine. :)\n",
        "createdAt" : "2016-08-23T05:36:01Z",
        "updatedAt" : "2016-08-23T14:42:59Z",
        "lastEditedBy" : "4e418bc8-21fb-4523-80c1-9c751c193126",
        "tags" : [
        ]
      }
    ],
    "commit" : "e780bb5fbdc83c718dfea7ebf992f06b4f5992bc",
    "line" : 52,
    "diffHunk" : "@@ -1,1 +330,334 @@\tconfigmap, err := func() (*api.ConfigMap, error) {\n\t\tvar nodename string\n\t\thostname := nodeutil.GetHostname(s.HostnameOverride)\n\n\t\tif kcfg != nil && kcfg.Cloud != nil {"
  },
  {
    "id" : "3d6dcd84-1a6e-4862-83c8-fb520394f318",
    "prId" : 30090,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "56339736-0cb2-455e-92af-a65da60929aa",
        "parentId" : null,
        "authorId" : "a6409368-42e0-44a9-bf79-9d3042ac3b65",
        "body" : "What happen to the standalone Kubelet mode? Add comment for this case please. \n",
        "createdAt" : "2016-08-19T21:46:15Z",
        "updatedAt" : "2016-08-23T14:42:59Z",
        "lastEditedBy" : "a6409368-42e0-44a9-bf79-9d3042ac3b65",
        "tags" : [
        ]
      }
    ],
    "commit" : "e780bb5fbdc83c718dfea7ebf992f06b4f5992bc",
    "line" : 136,
    "diffHunk" : "@@ -1,1 +414,418 @@\t\t// Couldn't get a configuration from the API server yet.\n\t\t// Restart as soon as anything comes back from the API server.\n\t\tstartKubeletConfigSyncLoop(s, \"\")\n\t\treturn nil, err\n\t}"
  },
  {
    "id" : "5ab547f7-2997-4b20-87c6-7587195df686",
    "prId" : 27874,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4065e65e-7cd2-4b52-bd7a-02d3f7f938d1",
        "parentId" : null,
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "gofmt doesn't complain here?\n",
        "createdAt" : "2016-06-22T15:14:14Z",
        "updatedAt" : "2016-08-11T11:50:14Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      },
      {
        "id" : "c88e744f-36ad-432c-9777-dc88da4491af",
        "parentId" : "4065e65e-7cd2-4b52-bd7a-02d3f7f938d1",
        "authorId" : "c63e1ceb-64bd-4726-b8ef-e647d73dae0c",
        "body" : "gofmt did that I swear :)\n",
        "createdAt" : "2016-06-22T15:17:18Z",
        "updatedAt" : "2016-08-11T11:50:14Z",
        "lastEditedBy" : "c63e1ceb-64bd-4726-b8ef-e647d73dae0c",
        "tags" : [
        ]
      }
    ],
    "commit" : "587b1f845a445e83a2288545f59cb22bf211cf52",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +281,285 @@\t\tBabysitDaemons:                 s.BabysitDaemons,\n\t\tExperimentalFlannelOverlay:     s.ExperimentalFlannelOverlay,\n\t\tNodeIP:                net.ParseIP(s.NodeIP),\n\t\tEvictionConfig:        evictionConfig,\n\t\tPodsPerCore:           int(s.PodsPerCore),"
  },
  {
    "id" : "9ff110b3-743f-4be7-9fe5-5ef10d79c535",
    "prId" : 26169,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9c81e598-6499-4363-96f0-5f114dc921e9",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "+1, thanks\n",
        "createdAt" : "2016-05-25T02:13:07Z",
        "updatedAt" : "2016-05-25T16:15:01Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "d3f3e6c969dca256f736f3eb3725af22efc823de",
    "line" : 9,
    "diffHunk" : "@@ -1,1 +417,421 @@\t\t\t// Can't use TLSv1.0 because of POODLE and BEAST using CBC cipher\n\t\t\t// Can't use TLSv1.1 because of RC4 cipher usage\n\t\t\tMinVersion: tls.VersionTLS12,\n\t\t\t// Populate PeerCertificates in requests, but don't yet reject connections without certificates.\n\t\t\tClientAuth: tls.RequestClientCert,"
  },
  {
    "id" : "df5ce424-095b-44ab-8cb1-f10ee8a58967",
    "prId" : 26001,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c4be28cf-f18e-4573-9fbd-572eeff28b07",
        "parentId" : null,
        "authorId" : "0adf587c-aaa2-4e47-be0f-a26d4fde14ac",
        "body" : "Ideally we would rebuild the image... should we do this in the salt configuration as a temporary measure?\n",
        "createdAt" : "2016-05-20T23:33:39Z",
        "updatedAt" : "2016-05-25T18:48:17Z",
        "lastEditedBy" : "0adf587c-aaa2-4e47-be0f-a26d4fde14ac",
        "tags" : [
        ]
      },
      {
        "id" : "093d019d-60ff-4af8-8d72-40f8f59a7449",
        "parentId" : "c4be28cf-f18e-4573-9fbd-572eeff28b07",
        "authorId" : "a6409368-42e0-44a9-bf79-9d3042ac3b65",
        "body" : "I just don't want to cut another image release since it is time sink at validation stage. We shouldn't put this to image once we finished the validation. I am ok to go with salt, but thought there is no difference since it is a temporary solution.\n",
        "createdAt" : "2016-05-20T23:37:31Z",
        "updatedAt" : "2016-05-25T18:48:17Z",
        "lastEditedBy" : "a6409368-42e0-44a9-bf79-9d3042ac3b65",
        "tags" : [
        ]
      },
      {
        "id" : "cfd16a33-ccfa-48d3-834f-d126d0ff5a79",
        "parentId" : "c4be28cf-f18e-4573-9fbd-572eeff28b07",
        "authorId" : "a6409368-42e0-44a9-bf79-9d3042ac3b65",
        "body" : "cc/ @mikedanese for salt configuration \n",
        "createdAt" : "2016-05-20T23:38:03Z",
        "updatedAt" : "2016-05-25T18:48:17Z",
        "lastEditedBy" : "a6409368-42e0-44a9-bf79-9d3042ac3b65",
        "tags" : [
        ]
      },
      {
        "id" : "88b9ae70-5fbe-4352-aadd-8378b30746f2",
        "parentId" : "c4be28cf-f18e-4573-9fbd-572eeff28b07",
        "authorId" : "0adf587c-aaa2-4e47-be0f-a26d4fde14ac",
        "body" : "The difference is we can limit the change in salt to the container VM GCE setup, but here it goes out to everyone.\n",
        "createdAt" : "2016-05-20T23:38:22Z",
        "updatedAt" : "2016-05-25T18:48:17Z",
        "lastEditedBy" : "0adf587c-aaa2-4e47-be0f-a26d4fde14ac",
        "tags" : [
        ]
      },
      {
        "id" : "beca21ed-a0a6-442a-a0b7-a590b417b147",
        "parentId" : "c4be28cf-f18e-4573-9fbd-572eeff28b07",
        "authorId" : "a6409368-42e0-44a9-bf79-9d3042ac3b65",
        "body" : "Yes, this one is goes to everyone. The number I chose (1000000) is actually the default one for other os distro including CoreOS, GCI, etc. If you want, I can read the number and reconfig it if the configured number < the default one? \n",
        "createdAt" : "2016-05-20T23:43:03Z",
        "updatedAt" : "2016-05-25T18:48:17Z",
        "lastEditedBy" : "a6409368-42e0-44a9-bf79-9d3042ac3b65",
        "tags" : [
        ]
      },
      {
        "id" : "307f024a-f9d5-4388-803b-67a342b819d5",
        "parentId" : "c4be28cf-f18e-4573-9fbd-572eeff28b07",
        "authorId" : "a6409368-42e0-44a9-bf79-9d3042ac3b65",
        "body" : "Also we do the similar thing for other daemons, like kube_proxy: https://github.com/kubernetes/kubernetes/blob/dae5ac482861382e18b1e7b2943b1b7f333c6a2a/cmd/kube-proxy/app/conntrack.go#L42\n",
        "createdAt" : "2016-05-20T23:45:22Z",
        "updatedAt" : "2016-05-25T18:48:17Z",
        "lastEditedBy" : "a6409368-42e0-44a9-bf79-9d3042ac3b65",
        "tags" : [
        ]
      },
      {
        "id" : "a2e39be9-1d7f-4297-b461-cb74891dd65f",
        "parentId" : "c4be28cf-f18e-4573-9fbd-572eeff28b07",
        "authorId" : "a6409368-42e0-44a9-bf79-9d3042ac3b65",
        "body" : "@mikedanese is ok with updating this through salt. I will re-do this then. \n",
        "createdAt" : "2016-05-20T23:47:02Z",
        "updatedAt" : "2016-05-25T18:48:17Z",
        "lastEditedBy" : "a6409368-42e0-44a9-bf79-9d3042ac3b65",
        "tags" : [
        ]
      },
      {
        "id" : "a187f55b-ad8d-4430-9748-ebea0657b4cf",
        "parentId" : "c4be28cf-f18e-4573-9fbd-572eeff28b07",
        "authorId" : "a6409368-42e0-44a9-bf79-9d3042ac3b65",
        "body" : "I gave up on salt. Here is the block change I made, \n\n{% if grains.cloud is defined\n   and grains.cloud == 'gce' %}\n/proc/sys/kernel/keys/root_maxkeys:\n  file.managed:\n    - content: |\n       - '200000'\n    - replace: True\n    - show_diff: True\n{% endif %}\n\nBut salt think the file has right content, and refuse to update:\n\n[INFO    ] Running state [/proc/sys/kernel/keys/root_maxkeys] at time 00:27:59.681909\n[INFO    ] Executing state file.managed for /proc/sys/kernel/keys/root_maxkeys\n[INFO    ] File /proc/sys/kernel/keys/root_maxkeys is in the correct state\n[INFO    ] Completed state [/proc/sys/kernel/keys/root_maxkeys] at time 00:27:59.684949\n          ID: /proc/sys/kernel/keys/root_maxkeys\n     Comment: File /proc/sys/kernel/keys/root_maxkeys is in the correct state\n",
        "createdAt" : "2016-05-21T00:31:11Z",
        "updatedAt" : "2016-05-25T18:48:17Z",
        "lastEditedBy" : "a6409368-42e0-44a9-bf79-9d3042ac3b65",
        "tags" : [
        ]
      },
      {
        "id" : "554f3a60-6747-43d8-9f30-3f69415b9c55",
        "parentId" : "c4be28cf-f18e-4573-9fbd-572eeff28b07",
        "authorId" : "0adf587c-aaa2-4e47-be0f-a26d4fde14ac",
        "body" : "Oh well... let's just try to remember to remove this once the fix gets in the image.\n",
        "createdAt" : "2016-05-21T00:38:04Z",
        "updatedAt" : "2016-05-25T18:48:17Z",
        "lastEditedBy" : "0adf587c-aaa2-4e47-be0f-a26d4fde14ac",
        "tags" : [
        ]
      },
      {
        "id" : "adafa023-521d-457b-85b9-86ade6bb4a33",
        "parentId" : "c4be28cf-f18e-4573-9fbd-572eeff28b07",
        "authorId" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "body" : "We have set sysctl's before and we have always done it in code. Why wouldn't you want this in all clouds? I prefer this approach.\n",
        "createdAt" : "2016-05-21T16:54:54Z",
        "updatedAt" : "2016-05-25T18:48:17Z",
        "lastEditedBy" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "tags" : [
        ]
      },
      {
        "id" : "bb8921ca-5459-4446-bd8e-e9fc48b35e9a",
        "parentId" : "c4be28cf-f18e-4573-9fbd-572eeff28b07",
        "authorId" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "body" : "+1. We need to change this logic to be run only when needed. \n",
        "createdAt" : "2016-05-23T17:03:28Z",
        "updatedAt" : "2016-05-25T18:48:17Z",
        "lastEditedBy" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "tags" : [
        ]
      }
    ],
    "commit" : "a8ac041c44a55bba0eae9d29a5f8ecd5d6a6021a",
    "line" : null,
    "diffHunk" : "@@ -1,1 +704,708 @@\t\t\t}\n\t\t}\n\t}\n\n\t// process pods and exit."
  },
  {
    "id" : "0d071857-bd63-4a91-a28a-28a0aa757a0c",
    "prId" : 26001,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fe0047e3-387e-4145-beaa-4db8b4e1896e",
        "parentId" : null,
        "authorId" : "0adf587c-aaa2-4e47-be0f-a26d4fde14ac",
        "body" : "This logic is pretty close to the maxKeys logic, consider abstracting it to a function.\n",
        "createdAt" : "2016-05-24T00:15:11Z",
        "updatedAt" : "2016-05-25T18:48:17Z",
        "lastEditedBy" : "0adf587c-aaa2-4e47-be0f-a26d4fde14ac",
        "tags" : [
        ]
      },
      {
        "id" : "2a11f362-1bad-447c-9bb9-9b86b64b4c67",
        "parentId" : "fe0047e3-387e-4145-beaa-4db8b4e1896e",
        "authorId" : "a6409368-42e0-44a9-bf79-9d3042ac3b65",
        "body" : "Can we handle this one through https://github.com/kubernetes/kubernetes/issues/26005? We plan to clean up those shortly. \n",
        "createdAt" : "2016-05-24T00:20:37Z",
        "updatedAt" : "2016-05-25T18:48:17Z",
        "lastEditedBy" : "a6409368-42e0-44a9-bf79-9d3042ac3b65",
        "tags" : [
        ]
      },
      {
        "id" : "307d7c2a-e8d5-4244-874c-f8051aec8acf",
        "parentId" : "fe0047e3-387e-4145-beaa-4db8b4e1896e",
        "authorId" : "0adf587c-aaa2-4e47-be0f-a26d4fde14ac",
        "body" : "SGTM.\n",
        "createdAt" : "2016-05-24T00:21:38Z",
        "updatedAt" : "2016-05-25T18:48:17Z",
        "lastEditedBy" : "0adf587c-aaa2-4e47-be0f-a26d4fde14ac",
        "tags" : [
        ]
      }
    ],
    "commit" : "a8ac041c44a55bba0eae9d29a5f8ecd5d6a6021a",
    "line" : 46,
    "diffHunk" : "@@ -1,1 +704,708 @@\t\t\t}\n\t\t}\n\t}\n\n\t// process pods and exit."
  },
  {
    "id" : "47afc616-6b10-4c43-92b4-164a6b1f5243",
    "prId" : 15914,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0aac910f-1fb2-460c-a2c0-dbc092a3a453",
        "parentId" : null,
        "authorId" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "body" : "@derekwaynecarr: Let me know if this new flag description works.\n",
        "createdAt" : "2015-10-23T00:20:36Z",
        "updatedAt" : "2015-10-23T00:20:36Z",
        "lastEditedBy" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "tags" : [
        ]
      },
      {
        "id" : "86261aeb-3300-461b-a8b8-5bc69828fa99",
        "parentId" : "0aac910f-1fb2-460c-a2c0-dbc092a3a453",
        "authorId" : "6eca0ade-9879-4dd7-ad14-547e16f5c041",
        "body" : "@vishh - looks good\n",
        "createdAt" : "2015-10-23T00:29:41Z",
        "updatedAt" : "2015-10-23T00:29:41Z",
        "lastEditedBy" : "6eca0ade-9879-4dd7-ad14-547e16f5c041",
        "tags" : [
        ]
      }
    ],
    "commit" : "0df4b46d4ca8e6244455c8199a06ee0fe960ced6",
    "line" : 41,
    "diffHunk" : "@@ -1,1 +296,300 @@\tfs.Float32Var(&s.KubeApiQps, \"kube-api-qps\", s.KubeApiQps, \"QPS to use while talking with kubernetes apiserver\")\n\tfs.IntVar(&s.KubeApiBurst, \"kube-api-burst\", s.KubeApiBurst, \"Burst to use while talking with kubernetes apiserver\")\n\tfs.BoolVar(&s.SerializeImagePulls, \"serialize-image-pulls\", s.SerializeImagePulls, \"Pull images one at a time. We recommend *not* changing the default value on nodes that run docker daemon with version < 1.9 or an Aufs storage backend. Issue #10959 has more details. [default=true]\")\n}\n"
  },
  {
    "id" : "8737b014-2000-4ed9-93e1-fa3ba3d95ce6",
    "prId" : 15021,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "532c9fa3-f5ed-4a8a-a26b-ef3db6f57703",
        "parentId" : null,
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "Please update the flag documentation also:\nhttps://github.com/kubernetes/kubernetes/blob/7f9df8c062a693fb05923b1407d5995724f96b44/cmd/kubelet/app/server.go#L231\n",
        "createdAt" : "2015-10-02T21:51:15Z",
        "updatedAt" : "2015-10-02T22:26:29Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "e692b914-7f3b-4cd5-bf03-4919a5259701",
        "parentId" : "532c9fa3-f5ed-4a8a-a26b-ef3db6f57703",
        "authorId" : "0970b119-085d-41b4-8f33-e10409965eba",
        "body" : "done\n",
        "createdAt" : "2015-10-02T22:29:00Z",
        "updatedAt" : "2015-10-02T22:29:00Z",
        "lastEditedBy" : "0970b119-085d-41b4-8f33-e10409965eba",
        "tags" : [
        ]
      }
    ],
    "commit" : "37692d498c4ff997c9f456ad97ba782e570a47f8",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +174,178 @@\t\tHealthzBindAddress:          net.ParseIP(\"127.0.0.1\"),\n\t\tHealthzPort:                 10248,\n\t\tHostNetworkSources:          kubelet.AllSource,\n\t\tHostPIDSources:              kubelet.AllSource,\n\t\tHostIPCSources:              kubelet.AllSource,"
  },
  {
    "id" : "f3187085-3b1e-4cae-a8a2-05b5487e87b2",
    "prId" : 14700,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f7ee8fec-aafd-4286-983f-9b73b25f9d54",
        "parentId" : null,
        "authorId" : null,
        "body" : "I think it's worth making it very clear from the flag name that this is unauthenticated?  unauth-ro-port?  Something like that?  \n",
        "createdAt" : "2015-10-06T15:42:32Z",
        "updatedAt" : "2015-10-09T07:11:10Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "d75ef49b-6744-4098-ab7d-06b2c7970939",
        "parentId" : "f7ee8fec-aafd-4286-983f-9b73b25f9d54",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "CLI args are external facing… can't just change them. I would prefer we work to deprecate/remove this over time, rather than rename and carry a deprecated flag for compatibility. \n",
        "createdAt" : "2015-10-06T16:08:01Z",
        "updatedAt" : "2015-10-09T07:11:10Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "d8edd1a2-e54a-4d5b-b51f-acab2c738082",
        "parentId" : "f7ee8fec-aafd-4286-983f-9b73b25f9d54",
        "authorId" : null,
        "body" : "That's fine.  Please open an issues for the deprecation.\n",
        "createdAt" : "2015-10-06T20:59:20Z",
        "updatedAt" : "2015-10-09T07:11:10Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "705d3bf8-72ef-43ad-bba1-f182c4a38816",
        "parentId" : "f7ee8fec-aafd-4286-983f-9b73b25f9d54",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "https://github.com/kubernetes/kubernetes/issues/13598 and https://github.com/kubernetes/kubernetes/issues/12968 are already open asking about removing it\n",
        "createdAt" : "2015-10-06T21:10:32Z",
        "updatedAt" : "2015-10-09T07:11:10Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "9d6b52881d835cd76aa5fe2ce92cf578dd5900c9",
    "line" : 16,
    "diffHunk" : "@@ -1,1 +217,221 @@\tfs.IPVar(&s.Address, \"address\", s.Address, \"The IP address for the Kubelet to serve on (set to 0.0.0.0 for all interfaces)\")\n\tfs.UintVar(&s.Port, \"port\", s.Port, \"The port for the Kubelet to serve on. Note that \\\"kubectl logs\\\" will not work if you set this flag.\") // see #9325\n\tfs.UintVar(&s.ReadOnlyPort, \"read-only-port\", s.ReadOnlyPort, \"The read-only port for the Kubelet to serve on with no authentication/authorization (set to 0 to disable)\")\n\tfs.StringVar(&s.TLSCertFile, \"tls-cert-file\", s.TLSCertFile, \"\"+\n\t\t\"File containing x509 Certificate for HTTPS.  (CA cert, if any, concatenated after server cert). \"+"
  },
  {
    "id" : "7c5285bf-7308-4e48-a33d-cc6dbd7f7102",
    "prId" : 14381,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a6c4dbb1-05e7-4115-a35c-8f7010dfa3a0",
        "parentId" : null,
        "authorId" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "body" : "This is fd's right? Not just files, but sockets, dentries, etc?\n",
        "createdAt" : "2015-09-22T21:58:28Z",
        "updatedAt" : "2015-09-22T22:18:44Z",
        "lastEditedBy" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "tags" : [
        ]
      },
      {
        "id" : "8cd6d9f7-eb77-4a13-b94b-92b8ad65b21c",
        "parentId" : "a6c4dbb1-05e7-4115-a35c-8f7010dfa3a0",
        "authorId" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "body" : "Do we have to expose a flag? Do we expect this number to vary based on the some variable like number of pods, etc?\n",
        "createdAt" : "2015-09-22T22:04:48Z",
        "updatedAt" : "2015-09-22T22:18:44Z",
        "lastEditedBy" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "tags" : [
        ]
      },
      {
        "id" : "d6e0057c-dcbb-49d4-86c6-5baf57e53e4a",
        "parentId" : "a6c4dbb1-05e7-4115-a35c-8f7010dfa3a0",
        "authorId" : "a6409368-42e0-44a9-bf79-9d3042ac3b65",
        "body" : "Yes, it is, the name of MaxOpenFiles matches /proc/pid/limits \n\n```\n# cat /proc/2856/limits \nLimit                     Soft Limit           Hard Limit           Units     \nMax cpu time              unlimited            unlimited            seconds   \nMax file size             unlimited            unlimited            bytes     \nMax data size             unlimited            unlimited            bytes     \nMax stack size            8388608              unlimited            bytes     \nMax core file size        0                    unlimited            bytes     \nMax resident set          unlimited            unlimited            bytes     \nMax processes             14829                14829                processes \nMax open files            1000000              1000000              files     \nMax locked memory         65536                65536                bytes     \nMax address space         unlimited            unlimited            bytes     \nMax file locks            unlimited            unlimited            locks     \nMax pending signals       14829                14829                signals   \nMax msgqueue size         819200               819200               bytes     \nMax nice priority         0                    0                    \nMax realtime priority     0                    0                    \nMax realtime timeout      unlimited            unlimited            us        \n```\n",
        "createdAt" : "2015-09-22T22:08:38Z",
        "updatedAt" : "2015-09-22T22:18:44Z",
        "lastEditedBy" : "a6409368-42e0-44a9-bf79-9d3042ac3b65",
        "tags" : [
        ]
      },
      {
        "id" : "b3df736b-e722-4147-bb35-d3c3a2ce21de",
        "parentId" : "a6c4dbb1-05e7-4115-a35c-8f7010dfa3a0",
        "authorId" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "body" : "Thanks for clarifying Dawn! LGTM\n",
        "createdAt" : "2015-09-22T22:32:47Z",
        "updatedAt" : "2015-09-22T22:32:47Z",
        "lastEditedBy" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "tags" : [
        ]
      }
    ],
    "commit" : "5649939a360fcfeb62850a27674c323b6a5aefbe",
    "line" : 20,
    "diffHunk" : "@@ -1,1 +278,282 @@\tfs.Float64Var(&s.ChaosChance, \"chaos-chance\", s.ChaosChance, \"If > 0.0, introduce random client errors and latency. Intended for testing. [default=0.0]\")\n\tfs.BoolVar(&s.Containerized, \"containerized\", s.Containerized, \"Experimental support for running kubelet in a container.  Intended for testing. [default=false]\")\n\tfs.Uint64Var(&s.MaxOpenFiles, \"max-open-files\", 1000000, \"Number of files that can be opened by Kubelet process. [default=1000000]\")\n}\n"
  },
  {
    "id" : "51afe07a-c6d2-4a82-a29f-99b25ffaf097",
    "prId" : 14054,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d0875448-a956-4001-a463-50090fb99a81",
        "parentId" : null,
        "authorId" : "c2b5c827-efcd-438f-8db5-52d917b1cde9",
        "body" : "Can you briefly explain why we need this in addition to the configureCBR0 flag? Why would we want to configure cbr0 but not reconcile the CIDR from the master?\n",
        "createdAt" : "2015-09-16T19:52:09Z",
        "updatedAt" : "2015-10-09T04:21:34Z",
        "lastEditedBy" : "c2b5c827-efcd-438f-8db5-52d917b1cde9",
        "tags" : [
        ]
      },
      {
        "id" : "a610255d-b0e5-425c-a10a-9735829a765a",
        "parentId" : "d0875448-a956-4001-a463-50090fb99a81",
        "authorId" : "c2b5c827-efcd-438f-8db5-52d917b1cde9",
        "body" : "/cc @cjcullen \n",
        "createdAt" : "2015-09-16T19:52:18Z",
        "updatedAt" : "2015-10-09T04:21:34Z",
        "lastEditedBy" : "c2b5c827-efcd-438f-8db5-52d917b1cde9",
        "tags" : [
        ]
      },
      {
        "id" : "2e6f72b5-727f-4bf8-ac9c-5651a9297b85",
        "parentId" : "d0875448-a956-4001-a463-50090fb99a81",
        "authorId" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "body" : "@roberthbailey To clarify, do you want me to explain it here or in a comment? (or both?)\n",
        "createdAt" : "2015-09-16T20:01:48Z",
        "updatedAt" : "2015-10-09T04:21:34Z",
        "lastEditedBy" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "tags" : [
        ]
      },
      {
        "id" : "342df785-37aa-441a-8d56-bbd36773e799",
        "parentId" : "d0875448-a956-4001-a463-50090fb99a81",
        "authorId" : "c2b5c827-efcd-438f-8db5-52d917b1cde9",
        "body" : "If it's non-trivial, a comment would be best. \n",
        "createdAt" : "2015-09-16T20:03:39Z",
        "updatedAt" : "2015-10-09T04:21:34Z",
        "lastEditedBy" : "c2b5c827-efcd-438f-8db5-52d917b1cde9",
        "tags" : [
        ]
      },
      {
        "id" : "a05234ff-1d99-4a16-aad3-fae2fff3ed64",
        "parentId" : "d0875448-a956-4001-a463-50090fb99a81",
        "authorId" : "a6409368-42e0-44a9-bf79-9d3042ac3b65",
        "body" : "Here is the reason: We removed salt-based of concileCIDR completely on all nodes, no matter master node or worker nodes, then master node's cidr bridge won't be configured by Kubelet at all. Introducing this one is to reconfige cidr for minion per apiserver. \n\nI think we can eventually consolidate some of those flags, but ok as it is today. :-)\n",
        "createdAt" : "2015-09-16T20:42:53Z",
        "updatedAt" : "2015-10-09T04:21:34Z",
        "lastEditedBy" : "a6409368-42e0-44a9-bf79-9d3042ac3b65",
        "tags" : [
        ]
      },
      {
        "id" : "e2714bc3-2bf8-4474-be68-302bbf1ea893",
        "parentId" : "d0875448-a956-4001-a463-50090fb99a81",
        "authorId" : "c2b5c827-efcd-438f-8db5-52d917b1cde9",
        "body" : "I guess I'm confused as to why passing `--configure-cbr0=false` doesn't have the desired effect of preventing the kubelet running on the master from messing with the bridge. \n",
        "createdAt" : "2015-09-16T21:06:03Z",
        "updatedAt" : "2015-10-09T04:21:34Z",
        "lastEditedBy" : "c2b5c827-efcd-438f-8db5-52d917b1cde9",
        "tags" : [
        ]
      },
      {
        "id" : "17771015-5139-4129-89d5-864dc3c59aed",
        "parentId" : "d0875448-a956-4001-a463-50090fb99a81",
        "authorId" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "body" : "The bridge cbr0 doesn't exist and docker is configured to use cbr0. We used to have container_bridge.py to create the bridge on the master so we could either readd container_bridge.py it our use kubelet to configure the bridge.\n",
        "createdAt" : "2015-09-16T23:19:21Z",
        "updatedAt" : "2015-10-09T04:21:34Z",
        "lastEditedBy" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "tags" : [
        ]
      },
      {
        "id" : "13165c3d-ebad-4375-877a-5ce4b496a72b",
        "parentId" : "d0875448-a956-4001-a463-50090fb99a81",
        "authorId" : "c2b5c827-efcd-438f-8db5-52d917b1cde9",
        "body" : "So `configure-cbr0` tells the kubelet whether or not to create / configure cbr0 and `reconcile-cidr` tells the kubelet whether or not to _reconfigure_ the bridge based on the cidr allocation from the apiserver. Is the reason that we don't want to reconfigure the bridge because the interaction of restarting docker + supervisord causes the cluster to be unhealthy? If we want to make the master node schedulable at some point then it will need to be able to reconfigure cbr0 when it gets a cidr assigned. \n",
        "createdAt" : "2015-09-18T22:44:48Z",
        "updatedAt" : "2015-10-09T04:21:34Z",
        "lastEditedBy" : "c2b5c827-efcd-438f-8db5-52d917b1cde9",
        "tags" : [
        ]
      }
    ],
    "commit" : "fa60bbe8e6b1b50bfc82f13a8c1e7ed059d8ea99",
    "line" : null,
    "diffHunk" : "@@ -1,1 +284,288 @@\tfs.BoolVar(&s.Containerized, \"containerized\", s.Containerized, \"Experimental support for running kubelet in a container.  Intended for testing. [default=false]\")\n\tfs.Uint64Var(&s.MaxOpenFiles, \"max-open-files\", 1000000, \"Number of files that can be opened by Kubelet process. [default=1000000]\")\n\tfs.BoolVar(&s.ReconcileCIDR, \"reconcile-cidr\", s.ReconcileCIDR, \"Reconcile node CIDR with the CIDR specified by the API server. No-op if register-node or configure-cbr0 is false. [default=true]\")\n\tfs.BoolVar(&s.RegisterSchedulable, \"register-schedulable\", s.RegisterSchedulable, \"Register the node as schedulable. No-op if register-node is false. [default=true]\")\n}"
  },
  {
    "id" : "a13b685a-8c4e-444a-8fd3-8c5ed7e9a7a5",
    "prId" : 13571,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "54bec98d-9576-42f3-ad54-06b49434f964",
        "parentId" : null,
        "authorId" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "body" : "Seems like a pretty big change that is not strictly related to the point of this PR... am I missing something?\n",
        "createdAt" : "2015-11-13T19:22:50Z",
        "updatedAt" : "2015-11-13T19:22:50Z",
        "lastEditedBy" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "tags" : [
        ]
      },
      {
        "id" : "d87a0606-0f21-4e91-89f8-1e087f0ca72c",
        "parentId" : "54bec98d-9576-42f3-ad54-06b49434f964",
        "authorId" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "body" : "The primary focus of this PR is to reduce redundant syncs (10 second periodic syncs) when there is no change. The added PLEG already checks the container runtime frequently for any container changes. We keep the periodic sync as a fallback, in case anything is missed, but it should be less frequent. \n",
        "createdAt" : "2015-11-13T19:28:00Z",
        "updatedAt" : "2015-11-13T19:28:00Z",
        "lastEditedBy" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "tags" : [
        ]
      },
      {
        "id" : "3daf4f97-8e93-4c42-9b6f-e0ef20e386d9",
        "parentId" : "54bec98d-9576-42f3-ad54-06b49434f964",
        "authorId" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "body" : "@yujuhong cool, that makes sense to me -- this seems like the kind of thing that could affect some of the E2Es that are outside the merge path -- have you run any of those?\n",
        "createdAt" : "2015-11-14T04:50:45Z",
        "updatedAt" : "2015-11-14T04:50:45Z",
        "lastEditedBy" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "tags" : [
        ]
      }
    ],
    "commit" : "ac778e8203e1f6ea43555152c48f130063cc20c2",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +217,221 @@\t\tSerializeImagePulls:            true,\n\t\tStreamingConnectionIdleTimeout: 5 * time.Minute,\n\t\tSyncFrequency:                  1 * time.Minute,\n\t\tSystemContainer:                \"\",\n\t\tReconcileCIDR:                  true,"
  },
  {
    "id" : "7c16efdd-0475-46a2-9a81-082d28dff139",
    "prId" : 10211,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "989bc31f-20b8-41d1-ad3a-8c94218deec1",
        "parentId" : null,
        "authorId" : "c2b5c827-efcd-438f-8db5-52d917b1cde9",
        "body" : "What happens in stand-alone mode if this isn't set? (if we put this into 0.20.0 and then put that into a container vm release, the kubelet needs to work for folks running a [standalone container vm](https://cloud.google.com/compute/docs/containers/container_vms)).\n",
        "createdAt" : "2015-06-23T18:51:34Z",
        "updatedAt" : "2015-06-23T23:29:53Z",
        "lastEditedBy" : "c2b5c827-efcd-438f-8db5-52d917b1cde9",
        "tags" : [
        ]
      },
      {
        "id" : "2dd22392-d619-48b7-b427-7eaa95a54063",
        "parentId" : "989bc31f-20b8-41d1-ad3a-8c94218deec1",
        "authorId" : "a92f8f9e-31fd-4510-b4d9-3553f7025485",
        "body" : "And why not just have a default value here if so?\n",
        "createdAt" : "2015-06-23T18:56:35Z",
        "updatedAt" : "2015-06-23T23:29:53Z",
        "lastEditedBy" : "a92f8f9e-31fd-4510-b4d9-3553f7025485",
        "tags" : [
        ]
      },
      {
        "id" : "192c2e47-f26b-4fef-b932-62eccaa517c3",
        "parentId" : "989bc31f-20b8-41d1-ad3a-8c94218deec1",
        "authorId" : "a6409368-42e0-44a9-bf79-9d3042ac3b65",
        "body" : "The standalone here means master node only. For container vm case, the feature is controlled by flag --configure-cbr0, which should be false. I mentioned this in our earlier meeting.\n\n@zmerlynn what do you mean the default value here? In our master node case, kubelet obtains the value from environment variable $MASTER_IP_RANCE. \n",
        "createdAt" : "2015-06-23T19:09:32Z",
        "updatedAt" : "2015-06-23T23:29:53Z",
        "lastEditedBy" : "a6409368-42e0-44a9-bf79-9d3042ac3b65",
        "tags" : [
        ]
      },
      {
        "id" : "15a5cbab-9848-4b06-9307-3ca00c6d9d77",
        "parentId" : "989bc31f-20b8-41d1-ad3a-8c94218deec1",
        "authorId" : "a92f8f9e-31fd-4510-b4d9-3553f7025485",
        "body" : "Misunderstanding of the word \"standalone\".\n",
        "createdAt" : "2015-06-23T19:55:32Z",
        "updatedAt" : "2015-06-23T23:29:53Z",
        "lastEditedBy" : "a92f8f9e-31fd-4510-b4d9-3553f7025485",
        "tags" : [
        ]
      }
    ],
    "commit" : "9dbe6fe4e45aeeb5cb5abad8a7d216a3da1d6f57",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +243,247 @@\tfs.IntVar(&s.MaxPods, \"max-pods\", 100, \"Number of Pods that can run on this Kubelet.\")\n\tfs.StringVar(&s.DockerExecHandlerName, \"docker-exec-handler\", s.DockerExecHandlerName, \"Handler to use when executing a command in a container. Valid values are 'native' and 'nsenter'. Defaults to 'native'.\")\n\tfs.StringVar(&s.PodCIDR, \"pod-cidr\", \"\", \"The CIDR to use for pod IP addresses, only used in standalone mode.  In cluster mode, this is obtained from the master.\")\n\t// Flags intended for testing, not recommended used in production environments.\n\tfs.BoolVar(&s.ReallyCrashForTesting, \"really-crash-for-testing\", s.ReallyCrashForTesting, \"If true, when panics occur crash. Intended for testing.\")"
  },
  {
    "id" : "6ef70e5b-3600-49f9-bdab-b299ac98b98a",
    "prId" : 9728,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3238529a-9131-43d2-96fb-9162e7c1067c",
        "parentId" : null,
        "authorId" : "a6409368-42e0-44a9-bf79-9d3042ac3b65",
        "body" : "why do we still want to keep hostname? why not replace hostname with nodename completely? but still keep hostname_override flag? and marked it to be deprecated? then introducing another one called nodename_override, and it not specified, make it equals to hostname_override?\n",
        "createdAt" : "2015-06-16T05:50:06Z",
        "updatedAt" : "2015-06-17T04:40:25Z",
        "lastEditedBy" : "a6409368-42e0-44a9-bf79-9d3042ac3b65",
        "tags" : [
        ]
      },
      {
        "id" : "1b23241c-7f95-4e2e-940d-e0983f0d95e1",
        "parentId" : "3238529a-9131-43d2-96fb-9162e7c1067c",
        "authorId" : "a6409368-42e0-44a9-bf79-9d3042ac3b65",
        "body" : "I think you are breaking ppl using hostname_override now. Should we treat the value of flag hostname_override as node_name here? \n",
        "createdAt" : "2015-06-16T05:55:13Z",
        "updatedAt" : "2015-06-17T04:40:25Z",
        "lastEditedBy" : "a6409368-42e0-44a9-bf79-9d3042ac3b65",
        "tags" : [
        ]
      },
      {
        "id" : "9cba1d3e-13d2-4ed5-aeda-c33720aaa1f1",
        "parentId" : "3238529a-9131-43d2-96fb-9162e7c1067c",
        "authorId" : "8fc8f958-3c0e-47dd-a0fb-b8cc483b4efb",
        "body" : "I don't think I am breaking hostname_override, except maybe on AWS, where if it is broken I want to break it :-)\n\nThe logic is this: we build Hostname, just as before: hostname from the OS, but can be overridden by hostname_override.  If we have a CloudProvider, we ask it to determine the node-name, but all the implementations apart from AWS simply echo back the maybe-overridden hostname.\n\nThat is why we pass hostname in to CurrentNodeName.  It is admittedly a weird argument to pass in - it feels a little out of place.  Maybe it would be cleaner if we didn't pass in anything, but only changed the nodeName if CurrentNodeName returned non-empty?  But then that makes the function even more specialized.  I think post V1 we will want a function which returns the CurrentNode() (see https://github.com/GoogleCloudPlatform/kubernetes/blob/master/pkg/kubelet/kubelet.go#L721-L735)\n\nhostname (& hostname_override) do determine the SSL self-signed cert subject, so I think we have to keep this.\n\nI do agree that we will likely end up with a nodename_override (or just nodename?) but I'm hoping that maybe we can avoid it - that it will only be needed on bare-metal, and on bare-metal the hostname is the logical identifier for nodes.\n\nThis is possibly optimistic, but I'd rather avoid introducing another flag until we have someone that needs it!\n\nIf you'd prefer, I can create nodename_override, but I don't think anyone will have to use it today.\n",
        "createdAt" : "2015-06-16T12:30:42Z",
        "updatedAt" : "2015-06-17T04:40:25Z",
        "lastEditedBy" : "8fc8f958-3c0e-47dd-a0fb-b8cc483b4efb",
        "tags" : [
        ]
      },
      {
        "id" : "f45fa644-8e06-4742-b676-25102b0a0fdf",
        "parentId" : "3238529a-9131-43d2-96fb-9162e7c1067c",
        "authorId" : "aefa6d0d-0ad0-4062-966c-ddc56e70652b",
        "body" : "[EDIT] ~~in `contrib/mesos/pkg/executor/service/service.go` set `kcfg.NodeName = kcfg.Hostname`.~~\nignore prior statement\n\nalso, some unit tests may need updating in `contrib/mesos/pkg/executor/executor_test.go`\n",
        "createdAt" : "2015-06-16T13:03:44Z",
        "updatedAt" : "2015-06-17T04:40:25Z",
        "lastEditedBy" : "aefa6d0d-0ad0-4062-966c-ddc56e70652b",
        "tags" : [
        ]
      },
      {
        "id" : "fd9b70ca-e4ca-402c-b00b-a1adc69e4d38",
        "parentId" : "3238529a-9131-43d2-96fb-9162e7c1067c",
        "authorId" : "a6409368-42e0-44a9-bf79-9d3042ac3b65",
        "body" : "@justinsb I agreed we shouldn't need nodename_override. The only reason I suggested it above is that I thought we could completely remove hostname\\* term from our source base, and I think it is very misleading. But you are right that today we need it for SSL cert. \n",
        "createdAt" : "2015-06-16T22:52:28Z",
        "updatedAt" : "2015-06-17T04:40:25Z",
        "lastEditedBy" : "a6409368-42e0-44a9-bf79-9d3042ac3b65",
        "tags" : [
        ]
      }
    ],
    "commit" : "77e1bd3f56fea95a128bd3d9fe02fa78e9c6492c",
    "line" : 3,
    "diffHunk" : "@@ -1,1 +565,569 @@// Eventually, #2 will be replaced with instances of #3\nfunc RunKubelet(kcfg *KubeletConfig, builder KubeletBuilder) error {\n\tkcfg.Hostname = nodeutil.GetHostname(kcfg.HostnameOverride)\n\n\tif kcfg.NodeName == \"\" {"
  },
  {
    "id" : "a5df9ba7-e0ca-4721-97e3-17c34b3e68c7",
    "prId" : 9728,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "252fe0f2-8a0e-4a48-beb9-e0a5b1bcde42",
        "parentId" : null,
        "authorId" : "aefa6d0d-0ad0-4062-966c-ddc56e70652b",
        "body" : "need similar change in `contrib/mesos/pkg/executor/service/service.go` call to `NewMainKubelet`\n",
        "createdAt" : "2015-06-16T13:01:20Z",
        "updatedAt" : "2015-06-17T04:40:25Z",
        "lastEditedBy" : "aefa6d0d-0ad0-4062-966c-ddc56e70652b",
        "tags" : [
        ]
      }
    ],
    "commit" : "77e1bd3f56fea95a128bd3d9fe02fa78e9c6492c",
    "line" : 65,
    "diffHunk" : "@@ -1,1 +739,743 @@\tk, err = kubelet.NewMainKubelet(\n\t\tkc.Hostname,\n\t\tkc.NodeName,\n\t\tkc.DockerClient,\n\t\tkubeClient,"
  },
  {
    "id" : "7770bfad-a9d4-4848-a593-b2871d2d9dfe",
    "prId" : 9423,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "301fcecf-8818-4e12-a414-6760e9b628d2",
        "parentId" : null,
        "authorId" : "82da2b23-9f40-4abd-8af5-56ba07c1fc0a",
        "body" : "I would change this to\n\nif (err != nil) {\n  return err\n}\napiclient, err = client.New(clientConfig)\n...\n",
        "createdAt" : "2015-06-09T04:49:38Z",
        "updatedAt" : "2015-06-10T02:14:22Z",
        "lastEditedBy" : "82da2b23-9f40-4abd-8af5-56ba07c1fc0a",
        "tags" : [
        ]
      },
      {
        "id" : "20e520bf-8ad2-4bd9-b950-1fd998899183",
        "parentId" : "301fcecf-8818-4e12-a414-6760e9b628d2",
        "authorId" : "aefa6d0d-0ad0-4062-966c-ddc56e70652b",
        "body" : "will do\n\nOn Tue, Jun 9, 2015 at 12:50 AM, David Oppenheimer <notifications@github.com\n\n> wrote:\n> \n> In cmd/kubelet/app/server.go\n> https://github.com/GoogleCloudPlatform/kubernetes/pull/9423#discussion_r31982539\n> :\n> \n> > @@ -253,7 +253,11 @@ func (s *KubeletServer) Run(_ []string) error {\n> >         glog.Warning(err)\n> >     }\n> > -   client, err := s.createAPIServerClient()\n> > -   var apiclient *client.Client\n> > -   clientConfig, err := s.CreateAPIServerClientConfig()\n> > -   if err == nil {\n> \n> I would change this to\n> \n> if (err != nil) {\n> return err\n> }\n> apiclient, err = client.New(clientConfig)\n> ...\n> \n> —\n> Reply to this email directly or view it on GitHub\n> https://github.com/GoogleCloudPlatform/kubernetes/pull/9423/files#r31982539\n> .\n",
        "createdAt" : "2015-06-09T12:20:09Z",
        "updatedAt" : "2015-06-10T02:14:22Z",
        "lastEditedBy" : "aefa6d0d-0ad0-4062-966c-ddc56e70652b",
        "tags" : [
        ]
      },
      {
        "id" : "681dd905-f4f4-43ca-8df2-4720da189b6a",
        "parentId" : "301fcecf-8818-4e12-a414-6760e9b628d2",
        "authorId" : "aefa6d0d-0ad0-4062-966c-ddc56e70652b",
        "body" : "@davidopp pretty sure that change is breaking the tests because it causes Run() to abort when there's no API client configured for the kubelet.\n",
        "createdAt" : "2015-06-09T21:38:08Z",
        "updatedAt" : "2015-06-10T02:14:22Z",
        "lastEditedBy" : "aefa6d0d-0ad0-4062-966c-ddc56e70652b",
        "tags" : [
        ]
      }
    ],
    "commit" : "f54eeeb8d64f5327e19a41135ad504581bdb1334",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +256,260 @@\tvar apiclient *client.Client\n\tclientConfig, err := s.CreateAPIServerClientConfig()\n\tif err == nil {\n\t\tapiclient, err = client.New(clientConfig)\n\t}"
  },
  {
    "id" : "3cbf0833-ef46-4c48-8b7b-18d9208cd610",
    "prId" : 8681,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "07863032-f647-47a0-a2f6-5f56c03b5c39",
        "parentId" : null,
        "authorId" : "88a0ee93-4188-47b5-8881-3624e4a411f2",
        "body" : "Discussed offline: We should tie this to CgroupRoot.\n",
        "createdAt" : "2015-05-22T17:32:11Z",
        "updatedAt" : "2015-05-27T03:52:29Z",
        "lastEditedBy" : "88a0ee93-4188-47b5-8881-3624e4a411f2",
        "tags" : [
        ]
      }
    ],
    "commit" : "c97dda068dd96ab3ca759453a1e77791c98eb257",
    "line" : 21,
    "diffHunk" : "@@ -1,1 +231,235 @@\tfs.StringVar(&s.CgroupRoot, \"cgroup_root\", s.CgroupRoot, \"Optional root cgroup to use for pods. This is handled by the container runtime on a best effort basis. Default: '', which means use the container runtime default.\")\n\tfs.StringVar(&s.ContainerRuntime, \"container_runtime\", s.ContainerRuntime, \"The container runtime to use. Possible values: 'docker', 'rkt'. Default: 'docker'.\")\n\tfs.StringVar(&s.SystemContainer, \"system-container\", s.SystemContainer, \"Optional resource-only container in which to place all non-kernel processes that are not already in a container. Empty for no container. Rolling back the flag requires a reboot. (Default: \\\"\\\").\")\n\tfs.BoolVar(&s.ConfigureCBR0, \"configure-cbr0\", s.ConfigureCBR0, \"If true, kubelet will configure cbr0 based on Node.Spec.PodCIDR.\")\n\tfs.IntVar(&s.MaxPods, \"max-pods\", 100, \"Number of Pods that can run on this Kubelet.\")"
  },
  {
    "id" : "8eede061-080c-454a-960a-ac3d14554ed3",
    "prId" : 6620,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3d6cb7f8-ffa3-4512-80af-fee79b842d8b",
        "parentId" : null,
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "I know that this formatting is pretty strange - but this is what gofmt expects.\nI've reported an issue for it: https://github.com/golang/go/issues/10392\n",
        "createdAt" : "2015-04-09T09:01:47Z",
        "updatedAt" : "2015-04-09T09:01:47Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "37ea722b7b53ce9535c8d91449d711da0ba5e8b6",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +282,286 @@\t\tImageGCPolicy:                  imageGCPolicy,\n\t\tCloud:                          cloud,\n\t\tNodeStatusUpdateFrequency: s.NodeStatusUpdateFrequency,\n\t}\n"
  },
  {
    "id" : "752e0277-1376-415c-9b74-21d532805c7f",
    "prId" : 6243,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "476dcd67-5a46-4393-9b58-ca216ebcd545",
        "parentId" : null,
        "authorId" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "body" : "FYI @liggitt @hmrm you were both interested in this in #2799\n",
        "createdAt" : "2015-04-01T16:29:22Z",
        "updatedAt" : "2015-04-01T16:29:22Z",
        "lastEditedBy" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "tags" : [
        ]
      },
      {
        "id" : "c0f70739-b476-4f5c-86b7-812a21d99718",
        "parentId" : "476dcd67-5a46-4393-9b58-ca216ebcd545",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "That'll just request, but not require (or validate) client certs\n",
        "createdAt" : "2015-04-01T17:12:00Z",
        "updatedAt" : "2015-04-01T17:12:00Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "aa70400b-4a66-4d1c-a8ce-20604b4d9190",
        "parentId" : "476dcd67-5a46-4393-9b58-ca216ebcd545",
        "authorId" : "c2b5c827-efcd-438f-8db5-52d917b1cde9",
        "body" : "Right. I didn't want to also require the master to send client certs as part of the same change. This could probably be left out since we aren't doing anything with certs yet, but I don't think it hurts to leave it in. \n",
        "createdAt" : "2015-04-01T17:19:31Z",
        "updatedAt" : "2015-04-01T17:19:31Z",
        "lastEditedBy" : "c2b5c827-efcd-438f-8db5-52d917b1cde9",
        "tags" : [
        ]
      },
      {
        "id" : "045b441e-bcd5-490f-890c-8620ce8000f4",
        "parentId" : "476dcd67-5a46-4393-9b58-ca216ebcd545",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "I agree, just noting it\n",
        "createdAt" : "2015-04-01T17:20:46Z",
        "updatedAt" : "2015-04-01T17:20:46Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "dd9ec46cc0a671dbe50907a59b9aa95a3ea8624b",
    "line" : 60,
    "diffHunk" : "@@ -1,1 +219,223 @@\t\tConfig: &tls.Config{\n\t\t\t// Change default from SSLv3 to TLSv1.0 (because of POODLE vulnerability).\n\t\t\tMinVersion: tls.VersionTLS10,\n\t\t\t// Populate PeerCertificates in requests, but don't yet reject connections without certificates.\n\t\t\tClientAuth: tls.RequestClientCert,"
  },
  {
    "id" : "d814a8af-1ea6-4255-b492-f7036afa0e58",
    "prId" : 5619,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b577af56-73a4-467c-a796-b0e3135242df",
        "parentId" : null,
        "authorId" : "a6409368-42e0-44a9-bf79-9d3042ac3b65",
        "body" : "What is the diff here? Same for FileCheckFrequency, and other below except PodStatusUpdateFrequency\n",
        "createdAt" : "2015-03-18T22:52:26Z",
        "updatedAt" : "2015-03-18T22:52:26Z",
        "lastEditedBy" : "a6409368-42e0-44a9-bf79-9d3042ac3b65",
        "tags" : [
        ]
      },
      {
        "id" : "f77e9433-c7e1-4b25-9d60-368767862962",
        "parentId" : "b577af56-73a4-467c-a796-b0e3135242df",
        "authorId" : "b7abca6a-d6be-4008-a014-3b5ca0e90529",
        "body" : "It only adds an initialization of PodStatusUpdateFrequency. That made Gofmt redo the spacing which is why there is such a large diff.\n",
        "createdAt" : "2015-03-18T22:53:51Z",
        "updatedAt" : "2015-03-18T22:53:51Z",
        "lastEditedBy" : "b7abca6a-d6be-4008-a014-3b5ca0e90529",
        "tags" : [
        ]
      }
    ],
    "commit" : "cda4b6c598a273da8e6774487af7ad764ae64e9a",
    "line" : 19,
    "diffHunk" : "@@ -1,1 +85,89 @@func NewKubeletServer() *KubeletServer {\n\treturn &KubeletServer{\n\t\tSyncFrequency:            10 * time.Second,\n\t\tFileCheckFrequency:       20 * time.Second,\n\t\tHTTPCheckFrequency:       20 * time.Second,"
  },
  {
    "id" : "e2ecc0ab-d1dd-42d8-853b-857a1167f6f1",
    "prId" : 5619,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "dcc8f27e-ed2f-4e56-9c53-c8a2bcaada62",
        "parentId" : null,
        "authorId" : "a6409368-42e0-44a9-bf79-9d3042ac3b65",
        "body" : "ditto and below many lines\n",
        "createdAt" : "2015-03-18T22:52:54Z",
        "updatedAt" : "2015-03-18T22:52:54Z",
        "lastEditedBy" : "a6409368-42e0-44a9-bf79-9d3042ac3b65",
        "tags" : [
        ]
      }
    ],
    "commit" : "cda4b6c598a273da8e6774487af7ad764ae64e9a",
    "line" : 65,
    "diffHunk" : "@@ -1,1 +278,282 @@\t\tManifestURL:            manifestURL,\n\t\tPodInfraContainerImage: kubelet.PodInfraContainerImage,\n\t\tPort:                     port,\n\t\tAddress:                  util.IP(net.ParseIP(address)),\n\t\tEnableServer:             true,"
  },
  {
    "id" : "f2049233-bdc9-4341-b74c-799f4ad6db41",
    "prId" : 5547,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7e7962c3-0e07-4939-a038-35b1f0304f0b",
        "parentId" : null,
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "@gmarek @davidopp \nLook at all other flags. What do you notice?\n",
        "createdAt" : "2015-05-18T20:11:40Z",
        "updatedAt" : "2015-05-18T20:11:40Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      }
    ],
    "commit" : "27d660d0acadef7ea6fb8c878fd8f6b70cc7223e",
    "line" : 12,
    "diffHunk" : "@@ -1,1 +228,232 @@\tfs.StringVar(&s.DockerDaemonContainer, \"docker-daemon-container\", s.DockerDaemonContainer, \"Optional resource-only container in which to place the Docker Daemon. Empty for no container (Default: /docker-daemon).\")\n\tfs.BoolVar(&s.ConfigureCBR0, \"configure-cbr0\", s.ConfigureCBR0, \"If true, kubelet will configure cbr0 based on Node.Spec.PodCIDR.\")\n\tfs.IntVar(&s.MaxPods, \"max_pods\", 100, \"Number of Pods that can run on this Kubelet.\")\n\n\t// Flags intended for testing, not recommended used in production environments."
  }
]
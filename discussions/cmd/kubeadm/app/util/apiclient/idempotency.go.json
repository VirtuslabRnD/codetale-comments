[
  {
    "id" : "18b4e313-9ecc-4bb8-a5ea-a73c54129644",
    "prId" : 91952,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/91952#pullrequestreview-427904532",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ce9f20c6-d5ca-4ea2-bd8b-e8d6632038ca",
        "parentId" : null,
        "authorId" : "cccc7bed-95f4-42a9-83ef-6ba1a4dca7ec",
        "body" : "Note to myself: `context.TODO()` nested in a `PollImmediate()` is not a viable long term thing.",
        "createdAt" : "2020-06-10T10:03:27Z",
        "updatedAt" : "2020-06-10T16:32:05Z",
        "lastEditedBy" : "cccc7bed-95f4-42a9-83ef-6ba1a4dca7ec",
        "tags" : [
        ]
      }
    ],
    "commit" : "04ef3628e3b1fab1c07128f3b37cb3781ec9a85c",
    "line" : 67,
    "diffHunk" : "@@ -1,1 +204,208 @@\tvar lastError error\n\terr := wait.PollImmediate(constants.APICallRetryInterval, constants.APICallWithWriteTimeout, func() (bool, error) {\n\t\tif _, err := client.RbacV1().Roles(role.ObjectMeta.Namespace).Create(context.TODO(), role, metav1.CreateOptions{}); err != nil {\n\t\t\tif !apierrors.IsAlreadyExists(err) {\n\t\t\t\tlastError = errors.Wrap(err, \"unable to create RBAC role\")"
  },
  {
    "id" : "b0d07c82-b2dd-41f0-a13b-5de5e6298bf8",
    "prId" : 85763,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/85763#pullrequestreview-324909479",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "459c187c-6bac-467a-b0fb-ff8d1034f0e2",
        "parentId" : null,
        "authorId" : "2ce2b44c-9841-49e7-983e-fb7696974908",
        "body" : "at some point we need to figure out how to make all api calls have some sort of uniformity in terms of backoff.\r\n\r\npotentially:\r\n```\r\nfunc FuncionName(.... backoff *wait.Backoff)\r\n```\r\n\r\nwhere if `backoff` is `nil` a default backoff is used, a backoff that is the same for all api calls.\r\n\r\n/lgtm\r\n\r\n",
        "createdAt" : "2019-11-30T21:31:41Z",
        "updatedAt" : "2019-11-30T21:48:41Z",
        "lastEditedBy" : "2ce2b44c-9841-49e7-983e-fb7696974908",
        "tags" : [
        ]
      },
      {
        "id" : "5cc98aad-2198-4b38-af54-7248a40cb33f",
        "parentId" : "459c187c-6bac-467a-b0fb-ff8d1034f0e2",
        "authorId" : "67bc6085-2cd9-4674-9dbc-d2a266f478be",
        "body" : "Yes, my priority was to first make control plane join stable. After this PR I was thinking in sitting in front of all the requests we make and get to a proposal on how to make all this uniform and intuitive.",
        "createdAt" : "2019-11-30T21:33:26Z",
        "updatedAt" : "2019-11-30T21:48:41Z",
        "lastEditedBy" : "67bc6085-2cd9-4674-9dbc-d2a266f478be",
        "tags" : [
        ]
      }
    ],
    "commit" : "14fe7225c1499e20d5c0734f4c9d7e250a2b476c",
    "line" : 26,
    "diffHunk" : "@@ -1,1 +66,70 @@\t\tDuration: 500 * time.Millisecond,\n\t\tFactor:   1.0,\n\t\tJitter:   0.1,\n\t}, func() (bool, error) {\n\t\tif _, err := client.CoreV1().ConfigMaps(cm.ObjectMeta.Namespace).Create(cm); err != nil {"
  },
  {
    "id" : "a07ef460-818d-4ade-8a9a-765588e1945e",
    "prId" : 83339,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/83339#pullrequestreview-298228833",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4a4495dd-73ba-4068-a57c-5c7f66a8dffa",
        "parentId" : null,
        "authorId" : "cccc7bed-95f4-42a9-83ef-6ba1a4dca7ec",
        "body" : "Do we need to pre-fill `LabelHostname`? Kubelet is going to fill in the correct value itself.\r\nIf we need to fill it for some reason upon create, we should probably comment here why and supply it with `nodeName` as a value.",
        "createdAt" : "2019-10-07T10:01:16Z",
        "updatedAt" : "2019-10-07T15:45:34Z",
        "lastEditedBy" : "cccc7bed-95f4-42a9-83ef-6ba1a4dca7ec",
        "tags" : [
        ]
      },
      {
        "id" : "134fd8f3-8eef-402a-99c9-01e2eabc94f3",
        "parentId" : "4a4495dd-73ba-4068-a57c-5c7f66a8dffa",
        "authorId" : "2ce2b44c-9841-49e7-983e-fb7696974908",
        "body" : "the comment on top of the function says:\r\n```\r\nAdding a placeholder v1.LabelHostname label makes the object suitable for patching using PatchNodeOnce.\r\n```\r\nprefiling it with nodeName is fine too.\r\nfrankly i don't see the need for PatchNodeOnce to even require it.\r\n",
        "createdAt" : "2019-10-07T10:43:12Z",
        "updatedAt" : "2019-10-07T15:45:34Z",
        "lastEditedBy" : "2ce2b44c-9841-49e7-983e-fb7696974908",
        "tags" : [
        ]
      },
      {
        "id" : "596d1f1e-f29f-48d1-a00c-15427fb18a99",
        "parentId" : "4a4495dd-73ba-4068-a57c-5c7f66a8dffa",
        "authorId" : "2ce2b44c-9841-49e7-983e-fb7696974908",
        "body" : "i'm leaving this out, but the comment above the function definition now has more info.",
        "createdAt" : "2019-10-07T15:47:02Z",
        "updatedAt" : "2019-10-07T15:54:56Z",
        "lastEditedBy" : "2ce2b44c-9841-49e7-983e-fb7696974908",
        "tags" : [
        ]
      }
    ],
    "commit" : "71cb27836d6ddda01551f36ec255444c528e77b6",
    "line" : 15,
    "diffHunk" : "@@ -1,1 +297,301 @@\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:   nodeName,\n\t\t\tLabels: map[string]string{v1.LabelHostname: \"\"},\n\t\t},\n\t}"
  },
  {
    "id" : "64ce13bd-f8fe-42ce-a085-a846e7424a6b",
    "prId" : 78915,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/78915#pullrequestreview-248858613",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4601eedb-41b8-44e1-a5b5-775f3ee555f8",
        "parentId" : null,
        "authorId" : "f81960f6-a033-4403-bebf-c8ebb484e444",
        "body" : "Do we have a specific error condition that occurs on the race of new members joining?  \r\n/cc @gyuho ",
        "createdAt" : "2019-06-12T15:32:49Z",
        "updatedAt" : "2019-06-12T15:49:53Z",
        "lastEditedBy" : "f81960f6-a033-4403-bebf-c8ebb484e444",
        "tags" : [
        ]
      },
      {
        "id" : "53e5fe14-5767-4c66-ae49-cd24a3e8d7c8",
        "parentId" : "4601eedb-41b8-44e1-a5b5-775f3ee555f8",
        "authorId" : "2ce2b44c-9841-49e7-983e-fb7696974908",
        "body" : "we are not convinced this issue is directly related to etcd member join.\r\n\r\n",
        "createdAt" : "2019-06-12T15:39:28Z",
        "updatedAt" : "2019-06-12T15:49:53Z",
        "lastEditedBy" : "2ce2b44c-9841-49e7-983e-fb7696974908",
        "tags" : [
        ]
      },
      {
        "id" : "deadc7c2-7368-4395-b75e-8e258aa7c0a8",
        "parentId" : "4601eedb-41b8-44e1-a5b5-775f3ee555f8",
        "authorId" : "f81960f6-a033-4403-bebf-c8ebb484e444",
        "body" : "At minimum we need a //TODO + open an issue to fix in the next releases. ",
        "createdAt" : "2019-06-12T15:44:13Z",
        "updatedAt" : "2019-06-12T15:49:53Z",
        "lastEditedBy" : "f81960f6-a033-4403-bebf-c8ebb484e444",
        "tags" : [
        ]
      },
      {
        "id" : "793a0d20-2d50-4b54-9286-6f16355cfcb2",
        "parentId" : "4601eedb-41b8-44e1-a5b5-775f3ee555f8",
        "authorId" : "67bc6085-2cd9-4674-9dbc-d2a266f478be",
        "body" : "PR updated to include the TODO comment.",
        "createdAt" : "2019-06-12T15:50:35Z",
        "updatedAt" : "2019-06-12T15:50:35Z",
        "lastEditedBy" : "67bc6085-2cd9-4674-9dbc-d2a266f478be",
        "tags" : [
        ]
      },
      {
        "id" : "960c8697-fe5c-4da4-a3f5-9571d67ce9a4",
        "parentId" : "4601eedb-41b8-44e1-a5b5-775f3ee555f8",
        "authorId" : "2ce2b44c-9841-49e7-983e-fb7696974908",
        "body" : "TODO added and ticket created: https://github.com/kubernetes/kubeadm/issues/1606",
        "createdAt" : "2019-06-12T15:53:27Z",
        "updatedAt" : "2019-06-12T15:53:27Z",
        "lastEditedBy" : "2ce2b44c-9841-49e7-983e-fb7696974908",
        "tags" : [
        ]
      }
    ],
    "commit" : "26c9965a970016d7437e6173bcc7a6a5aa65120f",
    "line" : 12,
    "diffHunk" : "@@ -1,1 +302,306 @@\tvar cm *v1.ConfigMap\n\tvar lastError error\n\terr := wait.ExponentialBackoff(clientsetretry.DefaultBackoff, func() (bool, error) {\n\t\tvar err error\n\t\tcm, err = client.CoreV1().ConfigMaps(namespace).Get(name, metav1.GetOptions{})"
  },
  {
    "id" : "14ff7b7e-e87e-4222-a16a-525b204b56e6",
    "prId" : 76821,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/76821#pullrequestreview-228820714",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6df7f4de-a805-4b88-bc3e-c8bf0321f615",
        "parentId" : null,
        "authorId" : "f81960f6-a033-4403-bebf-c8ebb484e444",
        "body" : "Don't you want to still pass if it's empty?  ",
        "createdAt" : "2019-04-19T20:22:11Z",
        "updatedAt" : "2019-04-23T13:41:10Z",
        "lastEditedBy" : "f81960f6-a033-4403-bebf-c8ebb484e444",
        "tags" : [
        ]
      },
      {
        "id" : "40d28174-b00a-4987-b900-34deb0f62e3c",
        "parentId" : "6df7f4de-a805-4b88-bc3e-c8bf0321f615",
        "authorId" : "67bc6085-2cd9-4674-9dbc-d2a266f478be",
        "body" : "`MutateConfigMap` has slightly different semantics in my opinion than `CreateOrMutateConfigMap`; this is used when `reset` for example. I think that in this case it makes sense that we assume the configmap should exist (despite `reset` will ignore that error in any case because it wants to reset as much as possible, and not quit if the configmap is not present)",
        "createdAt" : "2019-04-19T20:41:36Z",
        "updatedAt" : "2019-04-23T13:41:10Z",
        "lastEditedBy" : "67bc6085-2cd9-4674-9dbc-d2a266f478be",
        "tags" : [
        ]
      }
    ],
    "commit" : "bc8bafd825816844b1a93af98b22b86a3f32a65e",
    "line" : 60,
    "diffHunk" : "@@ -1,1 +82,86 @@\t}, func() error {\n\t\tconfigMap, err := client.CoreV1().ConfigMaps(meta.Namespace).Get(meta.Name, metav1.GetOptions{})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}"
  },
  {
    "id" : "ff107129-8eaa-4d42-b00c-68401c8084b3",
    "prId" : 76821,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/76821#pullrequestreview-228825731",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ae1529a0-b4e3-4b55-a808-1e70d3389f60",
        "parentId" : null,
        "authorId" : "f81960f6-a033-4403-bebf-c8ebb484e444",
        "body" : "How are you ensuring multiple concurrent writers aren't overwriting each other? ",
        "createdAt" : "2019-04-19T20:27:42Z",
        "updatedAt" : "2019-04-23T13:41:10Z",
        "lastEditedBy" : "f81960f6-a033-4403-bebf-c8ebb484e444",
        "tags" : [
        ]
      },
      {
        "id" : "61704bec-0124-4edd-bd79-af47c3fc3265",
        "parentId" : "ae1529a0-b4e3-4b55-a808-1e70d3389f60",
        "authorId" : "f81960f6-a033-4403-bebf-c8ebb484e444",
        "body" : "Only a Patch would be safe in this scenario. ",
        "createdAt" : "2019-04-19T20:29:55Z",
        "updatedAt" : "2019-04-23T13:41:10Z",
        "lastEditedBy" : "f81960f6-a033-4403-bebf-c8ebb484e444",
        "tags" : [
        ]
      },
      {
        "id" : "06ccd225-64bf-4f96-933e-219bc50ee75c",
        "parentId" : "ae1529a0-b4e3-4b55-a808-1e70d3389f60",
        "authorId" : "67bc6085-2cd9-4674-9dbc-d2a266f478be",
        "body" : "* [client1] Fetch `kubeadm-config` (v1)\r\n* [client2] Fetch `kubeadm-config` (v1)\r\n* [client1] Mutate `kubeadm-config` locally (v1)\r\n* [client2] Mutate `kubeadm-config` locally (v1)\r\n* [client1] Update `kubeadm-config` (v2) - client1 wins the `Update`\r\n* [client2] Update `kubeadm-config` (v1) - CONFLICT\r\n* [client2] Fetch `kubeadm-config`  (v2)\r\n* [client2] Mutate `kubeadm-config` locally (v2)\r\n* [client2] Update `kubeadm-config` (v3)\r\n\r\n`Patch` vs `Update` does not give more or less safety in this case, the conflict will happen in both cases, `Patch` is just handier to only provide a subset of properties to be altered. At least this is my understanding, please tell me if I'm understanding something in a wrong way.",
        "createdAt" : "2019-04-19T20:38:38Z",
        "updatedAt" : "2019-04-23T13:41:10Z",
        "lastEditedBy" : "67bc6085-2cd9-4674-9dbc-d2a266f478be",
        "tags" : [
        ]
      },
      {
        "id" : "942071e2-b9d5-4a51-ae63-6a5c04db02f9",
        "parentId" : "ae1529a0-b4e3-4b55-a808-1e70d3389f60",
        "authorId" : "f81960f6-a033-4403-bebf-c8ebb484e444",
        "body" : "Update doesn't care though it's blind and dumb, there is no conflict, it's just a raw put. \r\n```\r\nresult = &v1.ConfigMap{}\r\n        err = c.client.Put().\r\n                Namespace(c.ns).\r\n                Resource(\"configmaps\").\r\n                Name(configMap.Name).\r\n                Body(configMap).\r\n                Do().\r\n                Into(result)\r\n```\r\nThere is no conflict it's just a straight overwrite.  \r\n",
        "createdAt" : "2019-04-19T20:47:33Z",
        "updatedAt" : "2019-04-23T13:41:10Z",
        "lastEditedBy" : "f81960f6-a033-4403-bebf-c8ebb484e444",
        "tags" : [
        ]
      },
      {
        "id" : "3616e1a9-231a-48d4-af0a-e886332d35ed",
        "parentId" : "ae1529a0-b4e3-4b55-a808-1e70d3389f60",
        "authorId" : "f81960f6-a033-4403-bebf-c8ebb484e444",
        "body" : "Patch would indeed give you more safety b/c order would not matter. \r\n",
        "createdAt" : "2019-04-19T20:48:46Z",
        "updatedAt" : "2019-04-23T13:41:10Z",
        "lastEditedBy" : "f81960f6-a033-4403-bebf-c8ebb484e444",
        "tags" : [
        ]
      },
      {
        "id" : "38b708d9-e055-4bcb-a591-cd88f03c0d05",
        "parentId" : "ae1529a0-b4e3-4b55-a808-1e70d3389f60",
        "authorId" : "67bc6085-2cd9-4674-9dbc-d2a266f478be",
        "body" : "I can ensure `Update` does indeed return a conflict if the version of the resource that you are updating is not the latest stored in `etcd`.",
        "createdAt" : "2019-04-19T20:50:50Z",
        "updatedAt" : "2019-04-23T13:41:10Z",
        "lastEditedBy" : "67bc6085-2cd9-4674-9dbc-d2a266f478be",
        "tags" : [
        ]
      },
      {
        "id" : "da6c90b3-be58-4b56-8d2f-fb77bada754d",
        "parentId" : "ae1529a0-b4e3-4b55-a808-1e70d3389f60",
        "authorId" : "f81960f6-a033-4403-bebf-c8ebb484e444",
        "body" : "So long as resource version is decoded from the `get` and passed again on the update you're right.  Sorry, it's been too long since I thought about this. ",
        "createdAt" : "2019-04-19T21:01:11Z",
        "updatedAt" : "2019-04-23T13:41:10Z",
        "lastEditedBy" : "f81960f6-a033-4403-bebf-c8ebb484e444",
        "tags" : [
        ]
      }
    ],
    "commit" : "bc8bafd825816844b1a93af98b22b86a3f32a65e",
    "line" : 66,
    "diffHunk" : "@@ -1,1 +88,92 @@\t\t\treturn errors.Wrap(err, \"unable to mutate ConfigMap\")\n\t\t}\n\t\t_, err = client.CoreV1().ConfigMaps(configMap.ObjectMeta.Namespace).Update(configMap)\n\t\treturn err\n\t})"
  },
  {
    "id" : "5b9f6c7b-6dbe-4226-8089-b2a335cb8515",
    "prId" : 76821,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/76821#pullrequestreview-229091804",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8abea990-7776-440d-9de9-20c24dbf4d75",
        "parentId" : null,
        "authorId" : "cccc7bed-95f4-42a9-83ef-6ba1a4dca7ec",
        "body" : "This one may need a simple test case too.",
        "createdAt" : "2019-04-22T14:57:37Z",
        "updatedAt" : "2019-04-23T13:41:10Z",
        "lastEditedBy" : "cccc7bed-95f4-42a9-83ef-6ba1a4dca7ec",
        "tags" : [
        ]
      }
    ],
    "commit" : "bc8bafd825816844b1a93af98b22b86a3f32a65e",
    "line" : 38,
    "diffHunk" : "@@ -1,1 +60,64 @@// to conflicts, and a retry will be issued if the ConfigMap was modified on the server between the refresh and the update (while the mutation was\n// taking place)\nfunc CreateOrMutateConfigMap(client clientset.Interface, cm *v1.ConfigMap, mutator ConfigMapMutator) error {\n\tif _, err := client.CoreV1().ConfigMaps(cm.ObjectMeta.Namespace).Create(cm); err != nil {\n\t\tif !apierrors.IsAlreadyExists(err) {"
  },
  {
    "id" : "0328091e-1e80-4edd-a083-d347519efa3c",
    "prId" : 64210,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/64210#pullrequestreview-123995791",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "52214b82-0445-4746-b327-a50e6cc8263e",
        "parentId" : null,
        "authorId" : "f81960f6-a033-4403-bebf-c8ebb484e444",
        "body" : "Do you patch b/c dynamic kubelet config is not default?  ",
        "createdAt" : "2018-05-25T19:49:35Z",
        "updatedAt" : "2018-05-29T14:52:36Z",
        "lastEditedBy" : "f81960f6-a033-4403-bebf-c8ebb484e444",
        "tags" : [
        ]
      },
      {
        "id" : "5e30ab40-4675-4232-85b6-c7b133d1808b",
        "parentId" : "52214b82-0445-4746-b327-a50e6cc8263e",
        "authorId" : "bfe6ebf1-cfa7-4758-abb1-9960fa09b194",
        "body" : "No this is used when e.g. setting the master label/taint, and generically modifying the Node object.",
        "createdAt" : "2018-05-29T13:40:47Z",
        "updatedAt" : "2018-05-29T14:52:36Z",
        "lastEditedBy" : "bfe6ebf1-cfa7-4758-abb1-9960fa09b194",
        "tags" : [
        ]
      }
    ],
    "commit" : "8bcbc1e9bdf67f253d749db95251f1c9234ed913",
    "line" : 27,
    "diffHunk" : "@@ -1,1 +195,199 @@\n// PatchNode tries to patch a node using the following client, executing patchFn for the actual mutating logic\nfunc PatchNode(client clientset.Interface, nodeName string, patchFn func(*v1.Node)) error {\n\t// Loop on every false return. Return with an error if raised. Exit successfully if true is returned.\n\treturn wait.Poll(constants.APICallRetryInterval, constants.PatchNodeTimeout, func() (bool, error) {"
  },
  {
    "id" : "f7e5fce2-8996-441c-a35b-ca8f48a3cc1b",
    "prId" : 63400,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/63400#pullrequestreview-118744189",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "50250ee2-cf7a-4de8-8b09-b3bd813f18ac",
        "parentId" : null,
        "authorId" : "2ce2b44c-9841-49e7-983e-fb7696974908",
        "body" : "i would do this do remove one level of indentation:\r\n```php\r\nfunc CreateOrRetainConfigMap(client clientset.Interface, cm *v1.ConfigMap, configMapName string) error {\r\n\tif _, err := client.CoreV1().ConfigMaps(cm.ObjectMeta.Namespace).Get(configMapName, metav1.GetOptions{}); err != nil {\r\n\t\tif !apierrors.IsNotFound(err) {\r\n\t\t\treturn nil\r\n\t\t}\r\n\t\tif _, err := client.CoreV1().ConfigMaps(cm.ObjectMeta.Namespace).Create(cm); err != nil {\r\n\t\t\tif !apierrors.IsAlreadyExists(err) {\r\n\t\t\t\treturn fmt.Errorf(\"unable to create configmap: %v\", err)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn nil\r\n}\r\n```",
        "createdAt" : "2018-05-09T13:47:18Z",
        "updatedAt" : "2018-05-09T16:37:44Z",
        "lastEditedBy" : "2ce2b44c-9841-49e7-983e-fb7696974908",
        "tags" : [
        ]
      }
    ],
    "commit" : "379c8e83da6d89cf8ef39788294f1000e3756d27",
    "line" : 17,
    "diffHunk" : "@@ -1,1 +58,62 @@\t}\n\treturn nil\n}\n\n// CreateOrUpdateSecret creates a Secret if the target resource doesn't exist. If the resource exists already, this function will update the resource instead."
  },
  {
    "id" : "d36cdb36-2540-4b44-a05c-1d0bec76dbb6",
    "prId" : 50626,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/50626#pullrequestreview-56254109",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c7775ffd-a1d9-41f5-8cfd-e270f16d6cae",
        "parentId" : null,
        "authorId" : "f81960f6-a033-4403-bebf-c8ebb484e444",
        "body" : "You could probably create closure wrappers for all of this, but meh.  ",
        "createdAt" : "2017-08-15T03:06:17Z",
        "updatedAt" : "2017-08-15T12:52:59Z",
        "lastEditedBy" : "f81960f6-a033-4403-bebf-c8ebb484e444",
        "tags" : [
        ]
      }
    ],
    "commit" : "8c5c3ca197c54628a2cba151350cc03bc8ab9053",
    "line" : 24,
    "diffHunk" : "@@ -1,1 +31,35 @@\n// CreateOrUpdateConfigMap creates a ConfigMap if the target resource doesn't exist. If the resource exists already, this function will update the resource instead.\nfunc CreateOrUpdateConfigMap(client clientset.Interface, cm *v1.ConfigMap) error {\n\tif _, err := client.CoreV1().ConfigMaps(cm.ObjectMeta.Namespace).Create(cm); err != nil {\n\t\tif !apierrors.IsAlreadyExists(err) {"
  }
]
[
  {
    "id" : "8524f55e-690e-402a-b9d9-370da66cc30a",
    "prId" : 94504,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/94504#pullrequestreview-489883718",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f485589c-353c-4339-9473-f0eb014e93d8",
        "parentId" : null,
        "authorId" : "0de88c3b-1f1a-401f-9fd1-cd63adc590fd",
        "body" : "Is the cache used to not print the same warning a lot of time? Or because the validation take too long to run?",
        "createdAt" : "2020-09-16T17:59:49Z",
        "updatedAt" : "2020-09-16T18:02:02Z",
        "lastEditedBy" : "0de88c3b-1f1a-401f-9fd1-cd63adc590fd",
        "tags" : [
        ]
      },
      {
        "id" : "04ac24cf-3f39-4495-9375-0c85efd93a7c",
        "parentId" : "f485589c-353c-4339-9473-f0eb014e93d8",
        "authorId" : "2ce2b44c-9841-49e7-983e-fb7696974908",
        "body" : "i'm still debating whether the cache is wanted here. the only benefit is that during a \"kubeadm\" process execution, it can omit printing the same validation warning multiple times for the same certificate.",
        "createdAt" : "2020-09-16T18:09:04Z",
        "updatedAt" : "2020-09-16T18:09:04Z",
        "lastEditedBy" : "2ce2b44c-9841-49e7-983e-fb7696974908",
        "tags" : [
        ]
      }
    ],
    "commit" : "b5b9698fbf43152a950504a0b68d0b4b2eda6d7b",
    "line" : 83,
    "diffHunk" : "@@ -1,1 +462,466 @@// is not valid related to the current time. It does so only if the certificate was not validated already\n// by keeping track with a cache.\nfunc CheckCertificatePeriodValidity(baseName string, cert *x509.Certificate) {\n\tcertPeriodValidationMutex.Lock()\n\tif _, exists := certPeriodValidation[baseName]; exists {"
  },
  {
    "id" : "9e107528-febe-4c57-ada0-bc11ee402a05",
    "prId" : 75431,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/75431#pullrequestreview-215790347",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7e7baa47-64ea-49d2-99de-f4c2a48d23cd",
        "parentId" : null,
        "authorId" : "2ce2b44c-9841-49e7-983e-fb7696974908",
        "body" : "as per the above comment, it seems that this change might affect our CSR code?\r\ne.g.:\r\nhttps://kubernetes.io/docs/tasks/administer-cluster/kubeadm/kubeadm-certs/\r\n\r\nbut arguably getting HA right is the higher priority.\r\n",
        "createdAt" : "2019-03-18T14:13:12Z",
        "updatedAt" : "2019-03-18T14:20:12Z",
        "lastEditedBy" : "2ce2b44c-9841-49e7-983e-fb7696974908",
        "tags" : [
        ]
      },
      {
        "id" : "44405bbc-509a-4326-b98a-010359e4055e",
        "parentId" : "7e7baa47-64ea-49d2-99de-f4c2a48d23cd",
        "authorId" : "8a27151d-3530-4221-90e8-48b3a85cba37",
        "body" : "@neolit123 this change should not affect CSR code.\r\n\r\nHowever, being the CSR thing built \"improperly\" on top of phases and the init workflow, there is a high risk that a change on one will impact the other.\r\n\r\nMy personal opinion is that in the long term CSR should be moved away because they are not part of the kubeadm init workflow\r\n",
        "createdAt" : "2019-03-18T14:34:04Z",
        "updatedAt" : "2019-03-18T14:34:04Z",
        "lastEditedBy" : "8a27151d-3530-4221-90e8-48b3a85cba37",
        "tags" : [
        ]
      },
      {
        "id" : "45e65bd8-62ef-42e3-a7eb-aa226d5ef6ea",
        "parentId" : "7e7baa47-64ea-49d2-99de-f4c2a48d23cd",
        "authorId" : "2ce2b44c-9841-49e7-983e-fb7696974908",
        "body" : "> My personal opinion is that in the long term CSR should be moved away because they are not part of the kubeadm init workflow\r\n\r\nabsolutely. \r\ni think there was a feature request about CSR in k/kubeadm, but i must say i mostly missed the demand -> implementation process on this one.\r\n",
        "createdAt" : "2019-03-18T18:53:14Z",
        "updatedAt" : "2019-03-18T18:53:15Z",
        "lastEditedBy" : "2ce2b44c-9841-49e7-983e-fb7696974908",
        "tags" : [
        ]
      }
    ],
    "commit" : "ff072aa639614551a23e9d843dab0a7243b3d919",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +356,360 @@// UsingExternalCA determines whether the user is relying on an external CA.  We currently implicitly determine this is the case\n// when the CA Cert is present but the CA Key is not.\n// This allows us to, e.g., skip generating certs or not start the csr signing controller.\n// In case we are using an external front-proxy CA, the function validates the certificates signed by front-proxy CA that should be provided by the user.\nfunc UsingExternalCA(cfg *kubeadmapi.ClusterConfiguration) (bool, error) {"
  },
  {
    "id" : "8fa76edc-858e-412f-ba7f-465568a97970",
    "prId" : 70809,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/70809#pullrequestreview-174796250",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8c047378-55c9-4935-b6a5-c3a6332b13b5",
        "parentId" : null,
        "authorId" : "cccc7bed-95f4-42a9-83ef-6ba1a4dca7ec",
        "body" : "I'd rather put a big comment on top of this one, to prevent people from accidentally calling it.",
        "createdAt" : "2018-11-14T10:47:08Z",
        "updatedAt" : "2018-11-15T18:48:06Z",
        "lastEditedBy" : "cccc7bed-95f4-42a9-83ef-6ba1a4dca7ec",
        "tags" : [
        ]
      }
    ],
    "commit" : "5fc1a9a87ca18d4181a0cf2fa207c9a8369d2756",
    "line" : 33,
    "diffHunk" : "@@ -1,1 +299,303 @@// If there already is a CSR file at the given path; kubeadm tries to load it and check if it's a valid certificate.\n// otherwise this function returns an error.\nfunc writeCSRFilesIfNotExist(csrDir string, baseName string, csr *x509.CertificateRequest, key *rsa.PrivateKey) error {\n\tif pkiutil.CSROrKeyExist(csrDir, baseName) {\n\t\t_, _, err := pkiutil.TryLoadCSRAndKeyFromDisk(csrDir, baseName)"
  },
  {
    "id" : "24132fd9-b7e7-48e6-8bd8-cebc2478c560",
    "prId" : 70809,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/70809#pullrequestreview-175149667",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5a0b85f8-abc5-4e50-837f-cd82d250ca3f",
        "parentId" : null,
        "authorId" : "cccc7bed-95f4-42a9-83ef-6ba1a4dca7ec",
        "body" : "Do we really have to load the key here? In the wake of Meltdown and Spectre I am a bit hesitant to load a key in memory, just to check if it exists. Probably a good old `os.Stat` of a `*.key` file can do the trick here?\r\nIt's better to keep it in this way in the testing code though (but not in production code).",
        "createdAt" : "2018-11-14T10:50:37Z",
        "updatedAt" : "2018-11-15T18:48:06Z",
        "lastEditedBy" : "cccc7bed-95f4-42a9-83ef-6ba1a4dca7ec",
        "tags" : [
        ]
      },
      {
        "id" : "6818d4aa-aae8-4a8f-970b-d11acc516844",
        "parentId" : "5a0b85f8-abc5-4e50-837f-cd82d250ca3f",
        "authorId" : "a2762dd2-4f61-45ce-b5d5-d94727263ab7",
        "body" : "I'd prefer to keep this consistent with the other similar methods. Maybe file an issue against kubernetes/kubeadm to fix this everywhere? It should be pretty straightforward",
        "createdAt" : "2018-11-15T00:54:34Z",
        "updatedAt" : "2018-11-15T18:48:06Z",
        "lastEditedBy" : "a2762dd2-4f61-45ce-b5d5-d94727263ab7",
        "tags" : [
        ]
      }
    ],
    "commit" : "5fc1a9a87ca18d4181a0cf2fa207c9a8369d2756",
    "line" : 35,
    "diffHunk" : "@@ -1,1 +301,305 @@func writeCSRFilesIfNotExist(csrDir string, baseName string, csr *x509.CertificateRequest, key *rsa.PrivateKey) error {\n\tif pkiutil.CSROrKeyExist(csrDir, baseName) {\n\t\t_, _, err := pkiutil.TryLoadCSRAndKeyFromDisk(csrDir, baseName)\n\t\tif err != nil {\n\t\t\treturn errors.Wrapf(err, \"%s CSR existed but it could not be loaded properly\", baseName)"
  },
  {
    "id" : "e7807203-be4c-4d9c-adae-30317babe55d",
    "prId" : 68481,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/68481#pullrequestreview-153897751",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "88742172-ba94-4dd6-943c-5c25483c6b10",
        "parentId" : null,
        "authorId" : "e43f24e2-6fac-4de6-9e06-a6b1f93501a6",
        "body" : "this one complained about having `%s` but not using Infof",
        "createdAt" : "2018-09-10T18:10:16Z",
        "updatedAt" : "2018-09-11T03:38:24Z",
        "lastEditedBy" : "e43f24e2-6fac-4de6-9e06-a6b1f93501a6",
        "tags" : [
        ]
      }
    ],
    "commit" : "9865aef21b38fd9d520df6fe6c3b8e31500a124a",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +111,115 @@\t\treturn fmt.Errorf(\"This function should only be used for CAs, but cert %s has CA %s\", certSpec.Name, certSpec.CAName)\n\t}\n\tglog.V(1).Infof(\"creating a new certificate authority for %s\", certSpec.Name)\n\n\tcertConfig, err := certSpec.GetConfig(cfg)"
  },
  {
    "id" : "93bcf8e0-7d6a-4362-9e20-4057c5d35288",
    "prId" : 68296,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/68296#pullrequestreview-153033039",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "518b6ec8-374e-4db1-9ce3-8b512c1f7a8c",
        "parentId" : null,
        "authorId" : "659c7c1f-39ba-41a7-8331-fcc6b3b5f2fb",
        "body" : "not urgent, but might be good to get test cases for this function.",
        "createdAt" : "2018-09-06T16:44:26Z",
        "updatedAt" : "2018-09-06T16:44:27Z",
        "lastEditedBy" : "659c7c1f-39ba-41a7-8331-fcc6b3b5f2fb",
        "tags" : [
        ]
      },
      {
        "id" : "dde36a39-75cf-42dd-a937-bd6c34ea008f",
        "parentId" : "518b6ec8-374e-4db1-9ce3-8b512c1f7a8c",
        "authorId" : "a2762dd2-4f61-45ce-b5d5-d94727263ab7",
        "body" : "It's just a slight generalisation of the existing validateSignedCert so I didn't bother.",
        "createdAt" : "2018-09-06T17:13:22Z",
        "updatedAt" : "2018-09-06T17:13:22Z",
        "lastEditedBy" : "a2762dd2-4f61-45ce-b5d5-d94727263ab7",
        "tags" : [
        ]
      }
    ],
    "commit" : "cda8c39f7712931a0efa38db3b82f65273792b54",
    "line" : 8,
    "diffHunk" : "@@ -1,1 +401,405 @@\n// validateSignedCertWithCA tries to load a certificate and validate it with the given caCert\nfunc validateSignedCertWithCA(l certKeyLocation, caCert *x509.Certificate) error {\n\t// Try to load key and signed certificate\n\tsignedCert, _, err := pkiutil.TryLoadCertAndKeyFromDisk(l.pkiDir, l.baseName)"
  },
  {
    "id" : "6a0c08b4-328b-4b86-9938-188af810dadc",
    "prId" : 65020,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/65020#pullrequestreview-128042180",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "eff5ff5f-0cef-4e2a-95b0-bcb7dbd7a906",
        "parentId" : null,
        "authorId" : "f81960f6-a033-4403-bebf-c8ebb484e444",
        "body" : "Could you log an issue against etcd and add a //TODO to fix this in the future. ",
        "createdAt" : "2018-06-12T16:15:15Z",
        "updatedAt" : "2018-06-12T16:15:24Z",
        "lastEditedBy" : "f81960f6-a033-4403-bebf-c8ebb484e444",
        "tags" : [
        ]
      }
    ],
    "commit" : "b8e8e353338574ec7e7cfa4748e6d1af036186ba",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +378,382 @@\t\tCommonName: cfg.NodeRegistration.Name,\n\t\tAltNames:   *altNames,\n\t\tUsages:     []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth, x509.ExtKeyUsageClientAuth},\n\t}\n\tetcdServerCert, etcdServerKey, err := pkiutil.NewCertAndKey(caCert, caKey, config)"
  },
  {
    "id" : "c5056d1c-636d-4ff1-9602-ba3edc28d3cb",
    "prId" : 62643,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/62643#pullrequestreview-128547516",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ddde7a5d-d9ec-4600-8f1a-4c79526a3cde",
        "parentId" : null,
        "authorId" : "2d9afee7-a404-4340-8fd9-d3187ed4f1da",
        "body" : "- [ ] Should we call `validateCACert` here instead of `validateSignedCert`?  \r\n  Note that at line 645 above, if `err` satisfies `os.IsNotExist`, we keep going, instead of concluding that the front proxy CA key is not present.",
        "createdAt" : "2018-06-13T18:27:24Z",
        "updatedAt" : "2018-06-13T18:30:08Z",
        "lastEditedBy" : "2d9afee7-a404-4340-8fd9-d3187ed4f1da",
        "tags" : [
        ]
      },
      {
        "id" : "20f3f93d-78f7-421a-bd97-80e19b403fc2",
        "parentId" : "ddde7a5d-d9ec-4600-8f1a-4c79526a3cde",
        "authorId" : "2d9afee7-a404-4340-8fd9-d3187ed4f1da",
        "body" : "Oh, I see; `validateSignedCert` loads the CA certificate, the client certificate, and the client key. It does not try to load the CA key.",
        "createdAt" : "2018-06-13T20:18:54Z",
        "updatedAt" : "2018-06-13T20:18:55Z",
        "lastEditedBy" : "2d9afee7-a404-4340-8fd9-d3187ed4f1da",
        "tags" : [
        ]
      }
    ],
    "commit" : "511ac8a064869450098b2730d05c074d1330c183",
    "line" : 35,
    "diffHunk" : "@@ -1,1 +647,651 @@\t}\n\n\tif err := validateSignedCert(certKeyLocation{cfg.CertificatesDir, kubeadmconstants.FrontProxyCACertAndKeyBaseName, kubeadmconstants.FrontProxyClientCertAndKeyBaseName, \"front-proxy client\"}); err != nil {\n\t\treturn false, err\n\t}"
  },
  {
    "id" : "0fa9b41c-e019-4d76-aeca-8adcd1b53d7e",
    "prId" : 59288,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/59288#pullrequestreview-96669111",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fffec672-a846-4085-abef-0a2bd772a6cd",
        "parentId" : null,
        "authorId" : "a09f2d48-fec0-4c0d-bd81-6de7378a6ebf",
        "body" : "Shouldn't we also validate that `ControlPlaneEndpoint` is a proper DNS subdomain, i.e., `validation.IsDNS1123Subdomain(ControlPlaneEndpoint)`?",
        "createdAt" : "2018-02-13T02:04:43Z",
        "updatedAt" : "2018-02-15T17:05:50Z",
        "lastEditedBy" : "a09f2d48-fec0-4c0d-bd81-6de7378a6ebf",
        "tags" : [
        ]
      },
      {
        "id" : "4c7afdd0-10b7-4909-93b6-31688511812e",
        "parentId" : "fffec672-a846-4085-abef-0a2bd772a6cd",
        "authorId" : "b0af83a5-aab3-42a9-9f4b-63e513d410c7",
        "body" : "I added this and also covered with tests. ",
        "createdAt" : "2018-02-14T21:47:35Z",
        "updatedAt" : "2018-02-15T17:05:50Z",
        "lastEditedBy" : "b0af83a5-aab3-42a9-9f4b-63e513d410c7",
        "tags" : [
        ]
      }
    ],
    "commit" : "dc03cc003540b2f486c67db2b91f020033834b62",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +550,554 @@\n\t// add api server dns advertise address\n\tif len(cfg.API.ControlPlaneEndpoint) > 0 {\n\t\taltNames.DNSNames = append(altNames.DNSNames, cfg.API.ControlPlaneEndpoint)\n\t}"
  },
  {
    "id" : "fab7f086-fca6-4ac6-b518-afad487f741e",
    "prId" : 57415,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/57415#pullrequestreview-97424743",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5454c0df-6834-46f1-9b43-cb8bfb2ecc08",
        "parentId" : null,
        "authorId" : "a09f2d48-fec0-4c0d-bd81-6de7378a6ebf",
        "body" : "s/generate/generates",
        "createdAt" : "2018-01-09T01:50:39Z",
        "updatedAt" : "2018-02-24T00:05:51Z",
        "lastEditedBy" : "a09f2d48-fec0-4c0d-bd81-6de7378a6ebf",
        "tags" : [
        ]
      },
      {
        "id" : "fae5c5de-a42b-487d-9a21-ec3e181e320b",
        "parentId" : "5454c0df-6834-46f1-9b43-cb8bfb2ecc08",
        "authorId" : "bf66f693-b705-46d8-a378-3750b55f033c",
        "body" : "not going to do this in this PR -- all of the functions have similar phrasing for their docstrings",
        "createdAt" : "2018-02-19T00:56:18Z",
        "updatedAt" : "2018-02-24T00:05:51Z",
        "lastEditedBy" : "bf66f693-b705-46d8-a378-3750b55f033c",
        "tags" : [
        ]
      }
    ],
    "commit" : "509e9af5223de6849b7d99dbb53796f794876752",
    "line" : 198,
    "diffHunk" : "@@ -1,1 +345,349 @@}\n\n// NewAPIServerEtcdClientCertAndKey generate CA certificate for the apiservers to connect to etcd securely, signed by the given CA.\nfunc NewAPIServerEtcdClientCertAndKey(caCert *x509.Certificate, caKey *rsa.PrivateKey) (*x509.Certificate, *rsa.PrivateKey, error) {\n"
  },
  {
    "id" : "cf9b0187-2354-4a90-ada9-934eda22b82b",
    "prId" : 57415,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/57415#pullrequestreview-97791656",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4fbe121e-935f-47ce-97b7-8d47092704a4",
        "parentId" : null,
        "authorId" : "bdc500eb-fd23-4d89-81ce-2986aa831dfa",
        "body" : "I think I prefer nesting all etcd certs into a new dir, e.g. cfg.CertificatesDir + \"/etcd\"",
        "createdAt" : "2018-01-12T17:38:26Z",
        "updatedAt" : "2018-02-24T00:05:51Z",
        "lastEditedBy" : "bdc500eb-fd23-4d89-81ce-2986aa831dfa",
        "tags" : [
        ]
      },
      {
        "id" : "477eb73c-90db-4db6-a273-98609b7f5777",
        "parentId" : "4fbe121e-935f-47ce-97b7-8d47092704a4",
        "authorId" : "f81960f6-a033-4403-bebf-c8ebb484e444",
        "body" : "agreed.",
        "createdAt" : "2018-01-17T02:08:48Z",
        "updatedAt" : "2018-02-24T00:05:51Z",
        "lastEditedBy" : "f81960f6-a033-4403-bebf-c8ebb484e444",
        "tags" : [
        ]
      },
      {
        "id" : "ad206646-b26d-4eac-b5f7-cb66bcd57d6e",
        "parentId" : "4fbe121e-935f-47ce-97b7-8d47092704a4",
        "authorId" : "bf66f693-b705-46d8-a378-3750b55f033c",
        "body" : "I'll take a look at this -- need to consider path joining and tests",
        "createdAt" : "2018-01-17T16:10:49Z",
        "updatedAt" : "2018-02-24T00:05:51Z",
        "lastEditedBy" : "bf66f693-b705-46d8-a378-3750b55f033c",
        "tags" : [
        ]
      },
      {
        "id" : "3817a0e8-7029-476d-92f9-27af8ca83a06",
        "parentId" : "4fbe121e-935f-47ce-97b7-8d47092704a4",
        "authorId" : "bf66f693-b705-46d8-a378-3750b55f033c",
        "body" : "730e91c3ae addresses this by hardcoding `etcd/` as a prefix in kubeadmconstants.\r\nI found this to be the cleanest implementation.\r\nWe're already hardcoding forward-slashes for defaults such as `/etc/kubernetes/pki`.\r\n\r\nI had concerns about adding a subdirectory prefixed to a fileName, but it turns out to be fine:\r\n- `certutils.WriteKey()` does a `MkdirAll(filepath.Dir(joinedPath), ...)`\r\n- `testutils.AssertFileExists()` does a `filepath.Join(dirName, fileName)`\r\n\r\nNot hardcoding this value requires us to add `filepath.Join(cfg.CerticatesDir, kubeadmconstants.Etcd, ...` multiple times in 4 files:\r\n```diff\r\ndiff --git a/cmd/kubeadm/app/phases/certs/certs.go b/cmd/kubeadm/app/phases/certs/certs.go\r\nindex 86583f4cf5..c377a9e2b1 100644\r\n--- a/cmd/kubeadm/app/phases/certs/certs.go\r\n+++ b/cmd/kubeadm/app/phases/certs/certs.go\r\n@@ -138,7 +138,7 @@ func CreateEtcdServerCertAndKeyFiles(cfg *kubeadmapi.MasterConfiguration) error\r\n \t}\r\n \r\n \treturn writeCertificateFilesIfNotExist(\r\n-\t\tcfg.CertificatesDir,\r\n+\t\tfilepath.Join(cfg.CertificatesDir, kubeadmconstants.Etcd),\r\n \t\tkubeadmconstants.EtcdServerCertAndKeyBaseName,\r\n \t\tcaCert,\r\n \t\tetcdServerCert,\r\n@@ -162,7 +162,7 @@ func CreateEtcdPeerCertAndKeyFiles(cfg *kubeadmapi.MasterConfiguration) error {\r\n \t}\r\n \r\n \treturn writeCertificateFilesIfNotExist(\r\n-\t\tcfg.CertificatesDir,\r\n+\t\tfilepath.Join(cfg.CertificatesDir, kubeadmconstants.Etcd),\r\n \t\tkubeadmconstants.EtcdPeerCertAndKeyBaseName,\r\n \t\tcaCert,\r\n \t\tetcdPeerCert,\r\ndiff --git a/cmd/kubeadm/app/phases/certs/certs_test.go b/cmd/kubeadm/app/phases/certs/certs_test.go\r\nindex fbd77208ad..343c8c61f8 100644\r\n--- a/cmd/kubeadm/app/phases/certs/certs_test.go\r\n+++ b/cmd/kubeadm/app/phases/certs/certs_test.go\r\n@@ -579,6 +579,11 @@ func TestCreateCertificateFilesMethods(t *testing.T) {\r\n \t\t\t\tkubeadmconstants.CACertName, kubeadmconstants.CAKeyName,\r\n \t\t\t\tkubeadmconstants.APIServerCertName, kubeadmconstants.APIServerKeyName,\r\n \t\t\t\tkubeadmconstants.APIServerKubeletClientCertName, kubeadmconstants.APIServerKubeletClientKeyName,\r\n+\t\t\t\tfilepath.Join(kubeadmconstants.Etcd, kubeadmconstants.EtcdServerCertName),\r\n+\t\t\t\tfilepath.Join(kubeadmconstants.Etcd, kubeadmconstants.EtcdServerKeyName),\r\n+\t\t\t\tfilepath.Join(kubeadmconstants.Etcd, kubeadmconstants.EtcdPeerCertName),\r\n+\t\t\t\tfilepath.Join(kubeadmconstants.Etcd, kubeadmconstants.EtcdPeerKeyName),\r\n+\t\t\t\tkubeadmconstants.APIServerEtcdClientCertName, kubeadmconstants.APIServerEtcdClientKeyName,\r\n \t\t\t\tkubeadmconstants.ServiceAccountPrivateKeyName, kubeadmconstants.ServiceAccountPublicKeyName,\r\n \t\t\t\tkubeadmconstants.FrontProxyCACertName, kubeadmconstants.FrontProxyCAKeyName,\r\n \t\t\t\tkubeadmconstants.FrontProxyClientCertName, kubeadmconstants.FrontProxyClientKeyName,\r\n@@ -599,14 +604,20 @@ func TestCreateCertificateFilesMethods(t *testing.T) {\r\n \t\t\texpectedFiles: []string{kubeadmconstants.APIServerKubeletClientCertName, kubeadmconstants.APIServerKubeletClientKeyName},\r\n \t\t},\r\n \t\t{\r\n-\t\t\tsetupFunc:     CreateCACertAndKeyfiles,\r\n-\t\t\tcreateFunc:    CreateEtcdServerCertAndKeyFiles,\r\n-\t\t\texpectedFiles: []string{kubeadmconstants.EtcdServerCertName, kubeadmconstants.EtcdServerKeyName},\r\n+\t\t\tsetupFunc:  CreateCACertAndKeyfiles,\r\n+\t\t\tcreateFunc: CreateEtcdServerCertAndKeyFiles,\r\n+\t\t\texpectedFiles: []string{\r\n+\t\t\t\tfilepath.Join(kubeadmconstants.Etcd, kubeadmconstants.EtcdServerCertName),\r\n+\t\t\t\tfilepath.Join(kubeadmconstants.Etcd, kubeadmconstants.EtcdServerKeyName),\r\n+\t\t\t},\r\n \t\t},\r\n \t\t{\r\n-\t\t\tsetupFunc:     CreateCACertAndKeyfiles,\r\n-\t\t\tcreateFunc:    CreateEtcdPeerCertAndKeyFiles,\r\n-\t\t\texpectedFiles: []string{kubeadmconstants.EtcdPeerCertName, kubeadmconstants.EtcdPeerKeyName},\r\n+\t\t\tsetupFunc:  CreateCACertAndKeyfiles,\r\n+\t\t\tcreateFunc: CreateEtcdPeerCertAndKeyFiles,\r\n+\t\t\texpectedFiles: []string{\r\n+\t\t\t\tfilepath.Join(kubeadmconstants.Etcd, kubeadmconstants.EtcdPeerCertName),\r\n+\t\t\t\tfilepath.Join(kubeadmconstants.Etcd, kubeadmconstants.EtcdPeerKeyName),\r\n+\t\t\t},\r\n \t\t},\r\n \t\t{\r\n \t\t\tsetupFunc:     CreateCACertAndKeyfiles,\r\ndiff --git a/cmd/kubeadm/app/phases/certs/doc.go b/cmd/kubeadm/app/phases/certs/doc.go\r\nindex 7e66cd344c..641907e6c8 100644\r\n--- a/cmd/kubeadm/app/phases/certs/doc.go\r\n+++ b/cmd/kubeadm/app/phases/certs/doc.go\r\n@@ -38,12 +38,12 @@ package certs\r\n \t\t - apiserver.key\r\n \t\t - apiserver-kubelet-client.crt\r\n \t\t - apiserver-kubelet-client.key\r\n-\t\t - etcd-server.crt\r\n-\t\t - etcd-server.key\r\n-\t\t - etcd-peer.crt\r\n-\t\t - etcd-peer.key\r\n \t\t - apiserver-etcd-client.crt\r\n \t\t - apiserver-etcd-client.key\r\n+\t\t - etcd/server.crt\r\n+\t\t - etcd/server.key\r\n+\t\t - etcd/peer.crt\r\n+\t\t - etcd/peer.key\r\n \t\t - sa.pub\r\n \t\t - sa.key\r\n \t\t - front-proxy-ca.crt\r\ndiff --git a/cmd/kubeadm/app/phases/etcd/local.go b/cmd/kubeadm/app/phases/etcd/local.go\r\nindex d25503521f..4a78c8b7c2 100644\r\n--- a/cmd/kubeadm/app/phases/etcd/local.go\r\n+++ b/cmd/kubeadm/app/phases/etcd/local.go\r\n@@ -75,12 +75,12 @@ func getEtcdCommand(cfg *kubeadmapi.MasterConfiguration) []string {\r\n \t\t\"listen-client-urls\":    \"https://127.0.0.1:2379\",\r\n \t\t\"advertise-client-urls\": \"https://127.0.0.1:2379\",\r\n \t\t\"data-dir\":              cfg.Etcd.DataDir,\r\n-\t\t\"cert-file\":             filepath.Join(cfg.CertificatesDir, kubeadmconstants.EtcdServerCertName),\r\n-\t\t\"key-file\":              filepath.Join(cfg.CertificatesDir, kubeadmconstants.EtcdServerKeyName),\r\n+\t\t\"cert-file\":             filepath.Join(cfg.CertificatesDir, kubeadmconstants.Etcd, kubeadmconstants.EtcdServerCertName),\r\n+\t\t\"key-file\":              filepath.Join(cfg.CertificatesDir, kubeadmconstants.Etcd, kubeadmconstants.EtcdServerKeyName),\r\n \t\t\"trusted-ca-file\":       filepath.Join(cfg.CertificatesDir, kubeadmconstants.CACertName),\r\n \t\t\"client-cert-auth\":      \"true\",\r\n-\t\t\"peer-cert-file\":        filepath.Join(cfg.CertificatesDir, kubeadmconstants.EtcdPeerCertName),\r\n-\t\t\"peer-key-file\":         filepath.Join(cfg.CertificatesDir, kubeadmconstants.EtcdPeerKeyName),\r\n+\t\t\"peer-cert-file\":        filepath.Join(cfg.CertificatesDir, kubeadmconstants.Etcd, kubeadmconstants.EtcdPeerCertName),\r\n+\t\t\"peer-key-file\":         filepath.Join(cfg.CertificatesDir, kubeadmconstants.Etcd, kubeadmconstants.EtcdPeerKeyName),\r\n \t\t\"peer-trusted-ca-file\":  filepath.Join(cfg.CertificatesDir, kubeadmconstants.CACertName),\r\n \t\t\"peer-client-cert-auth\": \"true\",\r\n \t}\r\ndiff --git a/cmd/kubeadm/app/phases/etcd/local_test.go b/cmd/kubeadm/app/phases/etcd/local_test.go\r\nindex 920680e059..425a96416c 100644\r\n--- a/cmd/kubeadm/app/phases/etcd/local_test.go\r\n+++ b/cmd/kubeadm/app/phases/etcd/local_test.go\r\n@@ -82,12 +82,12 @@ func TestGetEtcdCommand(t *testing.T) {\r\n \t\t\t\t\"--listen-client-urls=https://127.0.0.1:2379\",\r\n \t\t\t\t\"--advertise-client-urls=https://127.0.0.1:2379\",\r\n \t\t\t\t\"--data-dir=/var/lib/etcd\",\r\n-\t\t\t\t\"--cert-file=etcd-server.crt\",\r\n-\t\t\t\t\"--key-file=etcd-server.key\",\r\n+\t\t\t\t\"--cert-file=etcd/server.crt\",\r\n+\t\t\t\t\"--key-file=etcd/server.key\",\r\n \t\t\t\t\"--trusted-ca-file=ca.crt\",\r\n \t\t\t\t\"--client-cert-auth=true\",\r\n-\t\t\t\t\"--peer-cert-file=etcd-peer.crt\",\r\n-\t\t\t\t\"--peer-key-file=etcd-peer.key\",\r\n+\t\t\t\t\"--peer-cert-file=etcd/peer.crt\",\r\n+\t\t\t\t\"--peer-key-file=etcd/peer.key\",\r\n \t\t\t\t\"--peer-trusted-ca-file=ca.crt\",\r\n \t\t\t\t\"--peer-client-cert-auth=true\",\r\n \t\t\t},\r\n@@ -107,12 +107,12 @@ func TestGetEtcdCommand(t *testing.T) {\r\n \t\t\t\t\"--listen-client-urls=https://10.0.1.10:2379\",\r\n \t\t\t\t\"--advertise-client-urls=https://10.0.1.10:2379\",\r\n \t\t\t\t\"--data-dir=/var/lib/etcd\",\r\n-\t\t\t\t\"--cert-file=etcd-server.crt\",\r\n-\t\t\t\t\"--key-file=etcd-server.key\",\r\n+\t\t\t\t\"--cert-file=etcd/server.crt\",\r\n+\t\t\t\t\"--key-file=etcd/server.key\",\r\n \t\t\t\t\"--trusted-ca-file=ca.crt\",\r\n \t\t\t\t\"--client-cert-auth=true\",\r\n-\t\t\t\t\"--peer-cert-file=etcd-peer.crt\",\r\n-\t\t\t\t\"--peer-key-file=etcd-peer.key\",\r\n+\t\t\t\t\"--peer-cert-file=etcd/peer.crt\",\r\n+\t\t\t\t\"--peer-key-file=etcd/peer.key\",\r\n \t\t\t\t\"--peer-trusted-ca-file=ca.crt\",\r\n \t\t\t\t\"--peer-client-cert-auth=true\",\r\n \t\t\t},\r\n@@ -126,12 +126,12 @@ func TestGetEtcdCommand(t *testing.T) {\r\n \t\t\t\t\"--listen-client-urls=https://127.0.0.1:2379\",\r\n \t\t\t\t\"--advertise-client-urls=https://127.0.0.1:2379\",\r\n \t\t\t\t\"--data-dir=/etc/foo\",\r\n-\t\t\t\t\"--cert-file=etcd-server.crt\",\r\n-\t\t\t\t\"--key-file=etcd-server.key\",\r\n+\t\t\t\t\"--cert-file=etcd/server.crt\",\r\n+\t\t\t\t\"--key-file=etcd/server.key\",\r\n \t\t\t\t\"--trusted-ca-file=ca.crt\",\r\n \t\t\t\t\"--client-cert-auth=true\",\r\n-\t\t\t\t\"--peer-cert-file=etcd-peer.crt\",\r\n-\t\t\t\t\"--peer-key-file=etcd-peer.key\",\r\n+\t\t\t\t\"--peer-cert-file=etcd/peer.crt\",\r\n+\t\t\t\t\"--peer-key-file=etcd/peer.key\",\r\n \t\t\t\t\"--peer-trusted-ca-file=ca.crt\",\r\n \t\t\t\t\"--peer-client-cert-auth=true\",\r\n \t\t\t},\r\n```",
        "createdAt" : "2018-02-20T11:34:39Z",
        "updatedAt" : "2018-02-24T00:05:51Z",
        "lastEditedBy" : "bf66f693-b705-46d8-a378-3750b55f033c",
        "tags" : [
        ]
      }
    ],
    "commit" : "509e9af5223de6849b7d99dbb53796f794876752",
    "line" : 78,
    "diffHunk" : "@@ -1,1 +139,143 @@\n\treturn writeCertificateFilesIfNotExist(\n\t\tcfg.CertificatesDir,\n\t\tkubeadmconstants.EtcdServerCertAndKeyBaseName,\n\t\tcaCert,"
  },
  {
    "id" : "1826816c-521c-4adf-bc50-155baa53e8ac",
    "prId" : 57415,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/57415#pullrequestreview-97971189",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "605ed7a4-24b9-4ca9-a205-faa06a6a5497",
        "parentId" : null,
        "authorId" : "6746e0cc-0c52-4344-889b-945a672c83e3",
        "body" : "I think unless we can guarantee that a k8s client cert does not grant access directly to etcd and an etcd client cert does not grant access to the api server, then defaulting to a separate CA for etcd/k8s is probably a good idea here.",
        "createdAt" : "2018-02-20T18:44:51Z",
        "updatedAt" : "2018-02-24T00:05:51Z",
        "lastEditedBy" : "6746e0cc-0c52-4344-889b-945a672c83e3",
        "tags" : [
        ]
      },
      {
        "id" : "8121891a-4700-410a-81b4-ee80b3390818",
        "parentId" : "605ed7a4-24b9-4ca9-a205-faa06a6a5497",
        "authorId" : "bf66f693-b705-46d8-a378-3750b55f033c",
        "body" : "Thanks @detiber!\r\nAfter today's banter about CN-based Authentication with etcd v3.3 being difficult to implement in the short-term, an immediate path we can take is to implement the separate etcd CA. This may be the simplest, secure option.\r\n\r\n@jbeda also mentioned using Etcd RBAC to achieve similar results without the flag from the v3.3 PR: https://github.com/coreos/etcd/pull/8616.\r\nI don't know anything about this right now.",
        "createdAt" : "2018-02-20T19:55:23Z",
        "updatedAt" : "2018-02-24T00:05:51Z",
        "lastEditedBy" : "bf66f693-b705-46d8-a378-3750b55f033c",
        "tags" : [
        ]
      },
      {
        "id" : "485461a4-ebb0-4065-8771-73f76c065957",
        "parentId" : "605ed7a4-24b9-4ca9-a205-faa06a6a5497",
        "authorId" : "bf66f693-b705-46d8-a378-3750b55f033c",
        "body" : "Looks like you can make etcd authN a user based off of a cert's CN with `--client-cert-auth=true` and `etcdctl auth enable`\r\nhttps://coreos.com/etcd/docs/latest/op-guide/authentication.html#using-tls-common-name\r\n\r\nThe new `--peer-cert-allowed-cn` implies that this doesn't affect Peer Certificates though.\r\nMaybe it's because that's before the cluster is bootstrapped? 🤔",
        "createdAt" : "2018-02-20T20:08:15Z",
        "updatedAt" : "2018-02-24T00:05:51Z",
        "lastEditedBy" : "bf66f693-b705-46d8-a378-3750b55f033c",
        "tags" : [
        ]
      },
      {
        "id" : "51bec2ae-72e2-413e-899e-072128408275",
        "parentId" : "605ed7a4-24b9-4ca9-a205-faa06a6a5497",
        "authorId" : "bf66f693-b705-46d8-a378-3750b55f033c",
        "body" : "> unless we can guarantee that a k8s client cert does not grant access directly to etcd\r\n\r\n^ we've started discussing this\r\n\r\n> and an etcd client cert does not grant access to the api server\r\n\r\n^ we haven't really considered this other half yet",
        "createdAt" : "2018-02-20T20:10:32Z",
        "updatedAt" : "2018-02-24T00:05:51Z",
        "lastEditedBy" : "bf66f693-b705-46d8-a378-3750b55f033c",
        "tags" : [
        ]
      }
    ],
    "commit" : "509e9af5223de6849b7d99dbb53796f794876752",
    "line" : 67,
    "diffHunk" : "@@ -1,1 +128,132 @@func CreateEtcdServerCertAndKeyFiles(cfg *kubeadmapi.MasterConfiguration) error {\n\n\tcaCert, caKey, err := loadCertificateAuthority(cfg.CertificatesDir, kubeadmconstants.CACertAndKeyBaseName)\n\tif err != nil {\n\t\treturn err"
  },
  {
    "id" : "b0cfc291-acc3-4a13-bd19-e2a2714d5b9d",
    "prId" : 57415,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/57415#pullrequestreview-98309053",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "01960dc1-89b9-4d8f-8fb9-3fd5ad22c234",
        "parentId" : null,
        "authorId" : "2eb6ad87-e305-458f-a360-22c64806994c",
        "body" : "`creates` (applies for other function comments below)",
        "createdAt" : "2018-02-21T18:34:43Z",
        "updatedAt" : "2018-02-24T00:05:51Z",
        "lastEditedBy" : "2eb6ad87-e305-458f-a360-22c64806994c",
        "tags" : [
        ]
      }
    ],
    "commit" : "509e9af5223de6849b7d99dbb53796f794876752",
    "line" : 62,
    "diffHunk" : "@@ -1,1 +123,127 @@}\n\n// CreateEtcdServerCertAndKeyFiles create a new certificate and key file for etcd.\n// If the etcd serving certificate and key file already exist in the target folder, they are used only if evaluated equal; otherwise an error is returned.\n// It assumes the cluster CA certificate and key file exist in the CertificatesDir"
  },
  {
    "id" : "ece942cd-581a-47f5-b8c4-7c949245370f",
    "prId" : 57415,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/57415#pullrequestreview-98309053",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "41c6fcef-e7a5-4850-99ab-21643ac73058",
        "parentId" : null,
        "authorId" : "2eb6ad87-e305-458f-a360-22c64806994c",
        "body" : "Maybe `evaluated to be equal` (applies for other function comments below)",
        "createdAt" : "2018-02-21T18:35:28Z",
        "updatedAt" : "2018-02-24T00:05:51Z",
        "lastEditedBy" : "2eb6ad87-e305-458f-a360-22c64806994c",
        "tags" : [
        ]
      }
    ],
    "commit" : "509e9af5223de6849b7d99dbb53796f794876752",
    "line" : 63,
    "diffHunk" : "@@ -1,1 +124,128 @@\n// CreateEtcdServerCertAndKeyFiles create a new certificate and key file for etcd.\n// If the etcd serving certificate and key file already exist in the target folder, they are used only if evaluated equal; otherwise an error is returned.\n// It assumes the cluster CA certificate and key file exist in the CertificatesDir\nfunc CreateEtcdServerCertAndKeyFiles(cfg *kubeadmapi.MasterConfiguration) error {"
  },
  {
    "id" : "2240bfd6-7edb-41dc-ab11-af8a5e882caf",
    "prId" : 57415,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/57415#pullrequestreview-98309053",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c5e7438c-c5dc-40cd-8205-297a4f604cfb",
        "parentId" : null,
        "authorId" : "2eb6ad87-e305-458f-a360-22c64806994c",
        "body" : "Maybe be more specific, `etcd server key`",
        "createdAt" : "2018-02-21T18:40:32Z",
        "updatedAt" : "2018-02-24T00:05:51Z",
        "lastEditedBy" : "2eb6ad87-e305-458f-a360-22c64806994c",
        "tags" : [
        ]
      }
    ],
    "commit" : "509e9af5223de6849b7d99dbb53796f794876752",
    "line" : 171,
    "diffHunk" : "@@ -1,1 +318,322 @@\tetcdServerCert, etcdServerKey, err := pkiutil.NewCertAndKey(caCert, caKey, config)\n\tif err != nil {\n\t\treturn nil, nil, fmt.Errorf(\"failure while creating etcd key and certificate: %v\", err)\n\t}\n"
  },
  {
    "id" : "a082813c-e573-42f4-998d-85fe04d57fdc",
    "prId" : 50832,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/50832#pullrequestreview-59392739",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8b18ba9c-e7b6-4b25-bb59-aac914f1a64c",
        "parentId" : null,
        "authorId" : "bfe6ebf1-cfa7-4758-abb1-9960fa09b194",
        "body" : "Not needed for this PR; but in some future PR we should make sure the public key in the cert and key match each other (we have other places that do similar functionality like this so...)",
        "createdAt" : "2017-08-29T21:55:08Z",
        "updatedAt" : "2017-08-31T17:13:28Z",
        "lastEditedBy" : "bfe6ebf1-cfa7-4758-abb1-9960fa09b194",
        "tags" : [
        ]
      }
    ],
    "commit" : "e0ab0b57abc60a42075f7b1ef3844852120c4dd6",
    "line" : 78,
    "diffHunk" : "@@ -1,1 +466,470 @@\t}\n\n\t_, err := pkiutil.TryLoadKeyFromDisk(l.pkiDir, l.caBaseName)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failure loading key for %s: %v\", l.uxName, err)"
  },
  {
    "id" : "a25da650-e632-4a57-887c-90513c52b040",
    "prId" : 50691,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/50691#pullrequestreview-57176451",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e6c09c4b-9e9a-4fcd-adb1-f992057badd0",
        "parentId" : null,
        "authorId" : "bfe6ebf1-cfa7-4758-abb1-9960fa09b194",
        "body" : "This means that it always generates new certs in-memory; and then conditionally writes to disk if a valid cert/key doesn't already exist, right?",
        "createdAt" : "2017-08-18T11:31:08Z",
        "updatedAt" : "2017-08-18T11:36:25Z",
        "lastEditedBy" : "bfe6ebf1-cfa7-4758-abb1-9960fa09b194",
        "tags" : [
        ]
      }
    ],
    "commit" : "c6bb8fbb4aaa8981da8863b88e88ba7aed3ff3d0",
    "line" : 82,
    "diffHunk" : "@@ -1,1 +100,104 @@// If the apiserver-kubelet-client certificate and key files already exists in the target folder, they are used only if evaluated equals; otherwise an error is returned.\n// It assumes the cluster CA certificate and key files should exists into the CertificatesDir\nfunc CreateAPIServerKubeletClientCertAndKeyFiles(cfg *kubeadmapi.MasterConfiguration) error {\n\n\tcaCert, caKey, err := loadCertificateAuthorithy(cfg.CertificatesDir, kubeadmconstants.CACertAndKeyBaseName)"
  },
  {
    "id" : "74faf3c2-a036-428a-a31c-6e00a894507c",
    "prId" : 50691,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/50691#pullrequestreview-57176451",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fe44e30c-c3e2-4d7b-b1dc-8e4e08000cba",
        "parentId" : null,
        "authorId" : "bfe6ebf1-cfa7-4758-abb1-9960fa09b194",
        "body" : "Nit: This func and `NewCACertAndKey` is identical; might be worth calling just `NewCACertAndKey` in the front-proxy code...",
        "createdAt" : "2017-08-18T11:33:09Z",
        "updatedAt" : "2017-08-18T11:36:25Z",
        "lastEditedBy" : "bfe6ebf1-cfa7-4758-abb1-9960fa09b194",
        "tags" : [
        ]
      }
    ],
    "commit" : "c6bb8fbb4aaa8981da8863b88e88ba7aed3ff3d0",
    "line" : 174,
    "diffHunk" : "@@ -1,1 +242,246 @@\n// NewFrontProxyCACertAndKey generate a self signed front proxy CA.\nfunc NewFrontProxyCACertAndKey() (*x509.Certificate, *rsa.PrivateKey, error) {\n\n\tfrontProxyCACert, frontProxyCAKey, err := pkiutil.NewCertificateAuthority()"
  },
  {
    "id" : "56742175-764c-4fc5-9a45-9ca29003df24",
    "prId" : 50691,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/50691#pullrequestreview-57176451",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d96196a9-7e77-4e07-92f5-f37a0c5e992a",
        "parentId" : null,
        "authorId" : "bfe6ebf1-cfa7-4758-abb1-9960fa09b194",
        "body" : "is this really needed here? If some of them doesn't exist `TryLoadCertAndKeyFromDisk` will fail instead, right?",
        "createdAt" : "2017-08-18T11:34:02Z",
        "updatedAt" : "2017-08-18T11:36:25Z",
        "lastEditedBy" : "bfe6ebf1-cfa7-4758-abb1-9960fa09b194",
        "tags" : [
        ]
      }
    ],
    "commit" : "c6bb8fbb4aaa8981da8863b88e88ba7aed3ff3d0",
    "line" : 184,
    "diffHunk" : "@@ -1,1 +270,274 @@func loadCertificateAuthorithy(pkiDir string, baseName string) (*x509.Certificate, *rsa.PrivateKey, error) {\n\t// Checks if certificate authorithy exists in the PKI directory\n\tif !pkiutil.CertOrKeyExist(pkiDir, baseName) {\n\t\treturn nil, nil, fmt.Errorf(\"couldn't load %s certificate authorithy from %s\", baseName, pkiDir)\n\t}"
  },
  {
    "id" : "1a81807c-a9bd-43ee-b78f-b9011561f88c",
    "prId" : 40292,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/40292#pullrequestreview-17992476",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "88205dd8-c981-4292-9d5a-62a7a484a402",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "this doesn't belong in the serving cert, it's meaningless there. you want this in the client cert you need to make for the master",
        "createdAt" : "2017-01-23T18:05:54Z",
        "updatedAt" : "2017-01-23T18:05:54Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "a9ba8ab0-e838-4b37-9e12-7a3fd0a9dace",
        "parentId" : "88205dd8-c981-4292-9d5a-62a7a484a402",
        "authorId" : "bfe6ebf1-cfa7-4758-abb1-9960fa09b194",
        "body" : "Yeah, I'm gonna fix that. Misunderstood which way you meant it should be created, but it's clearer now, thank you.",
        "createdAt" : "2017-01-23T18:16:04Z",
        "updatedAt" : "2017-01-23T18:16:04Z",
        "lastEditedBy" : "bfe6ebf1-cfa7-4758-abb1-9960fa09b194",
        "tags" : [
        ]
      },
      {
        "id" : "19576ccc-b833-468c-bf5b-75fb62f92deb",
        "parentId" : "88205dd8-c981-4292-9d5a-62a7a484a402",
        "authorId" : "bfe6ebf1-cfa7-4758-abb1-9960fa09b194",
        "body" : "@liggitt Do you think something like this will work then?\r\n```\r\n--- a/cmd/kubeadm/app/constants/constants.go\r\n+++ b/cmd/kubeadm/app/constants/constants.go\r\n@@ -24,4 +24,8 @@ const (\r\n        APIServerCertAndKeyBaseName = \"apiserver\"\r\n        APIServerCertName           = \"apiserver.crt\"\r\n        APIServerKeyName            = \"apiserver.key\"\r\n+\r\n+       APIServerKubeletClientCertAndKeyBaseName = \"apiserver-kubelet-client\"\r\n+       APIServerKubeletClientCertName           = \"apiserver-kubelet-client.crt\"\r\n+       APIServerKubeletClientKeyName            = \"apiserver-kubelet-client.key\"\r\n )\r\ndiff --git a/cmd/kubeadm/app/master/manifests.go b/cmd/kubeadm/app/master/manifests.go\r\nindex bf44fad..b234b70 100644\r\n--- a/cmd/kubeadm/app/master/manifests.go\r\n+++ b/cmd/kubeadm/app/master/manifests.go\r\n@@ -322,8 +322,8 @@ func getAPIServerCommand(cfg *kubeadmapi.MasterConfiguration, selfHosted bool) [\r\n                \"--client-ca-file=\"+getCertFilePath(kubeadmconstants.CACertName),\r\n                \"--tls-cert-file=\"+getCertFilePath(kubeadmconstants.APIServerCertName),\r\n                \"--tls-private-key-file=\"+getCertFilePath(kubeadmconstants.APIServerKeyName),\r\n-               \"--kubelet-client-certificate=\"+getCertFilePath(kubeadmconstants.APIServerCertName),\r\n-               \"--kubelet-client-key=\"+getCertFilePath(kubeadmconstants.APIServerKeyName),\r\n+               \"--kubelet-client-certificate=\"+getCertFilePath(kubeadmconstants.APIServerKubeletClientCertName),\r\n+               \"--kubelet-client-key=\"+getCertFilePath(kubeadmconstants.APIServerKubeletClientKeyName),\r\n                \"--token-auth-file=\"+kubeadmapi.GlobalEnvParams.HostPKIPath+\"/tokens.csv\",\r\n                fmt.Sprintf(\"--secure-port=%d\", cfg.API.Port),\r\n                \"--allow-privileged\",\r\ndiff --git a/cmd/kubeadm/app/phases/certs/certs.go b/cmd/kubeadm/app/phases/certs/certs.go\r\nindex 78d5533..4ac2a13 100644\r\n--- a/cmd/kubeadm/app/phases/certs/certs.go\r\n+++ b/cmd/kubeadm/app/phases/certs/certs.go\r\n@@ -123,8 +123,6 @@ func CreatePKIAssets(cfg *kubeadmapi.MasterConfiguration, pkiDir string) error {\r\n                config := certutil.Config{\r\n                        CommonName: \"kube-apiserver\",\r\n                        AltNames:   altNames,\r\n-                       // This makes the apiserver allowed to talk to the kubelets in the cluster\r\n-                       Organization: []string{\"system:masters\"},\r\n                        Usages:       []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth},\r\n                }\r\n                apiCert, apiKey, err := pkiutil.NewCertAndKey(caCert, caKey, config)\r\n@@ -138,6 +136,35 @@ func CreatePKIAssets(cfg *kubeadmapi.MasterConfiguration, pkiDir string) error {\r\n                fmt.Println(\"[certificates] Generated API server certificate and key.\")\r\n        }\r\n \r\n+       // If at least one of them exists, we should try to load them\r\n+       // In the case that only one exists, there will most likely be an error anyway\r\n+       if pkiutil.CertOrKeyExist(pkiDir, kubeadmconstants.APIServerKubeletClientCertAndKeyBaseName) {\r\n+               // Try to load ca.crt and ca.key from the PKI directory\r\n+               apiCert, apiKey, err := pkiutil.TryLoadCertAndKeyFromDisk(pkiDir, kubeadmconstants.APIServerKubeletClientCertAndKeyBaseName)\r\n+               if err != nil || apiCert == nil || apiKey == nil {\r\n+                       return fmt.Errorf(\"certificate and/or key existed but they could not be loaded properly\")\r\n+               }\r\n+\r\n+               fmt.Println(\"[certificates] Using the existing API Server certificate and key.\")\r\n+       } else {\r\n+               // The certificate and the key did NOT exist, let's generate them now\r\n+               // TODO: Add a test case to verify that this cert has the x509.ExtKeyUsageClientAuth flag\r\n+               config := certutil.Config{\r\n+                       CommonName: \"kube-apiserver-kubelet-client\",\r\n+                       Organization: []string{\"system:masters\"},\r\n+                       Usages:       []x509.ExtKeyUsage{x509.ExtKeyUsageClientAuth},\r\n+               }\r\n+               apiClientCert, apiClientKey, err := pkiutil.NewCertAndKey(caCert, caKey, config)\r\n+               if err != nil {\r\n+                       return fmt.Errorf(\"failure while creating API server client key and certificate [%v]\", err)\r\n+               }\r\n+\r\n+               if err = pkiutil.WriteCertAndKey(pkiDir, kubeadmconstants.APIServerKubeletClientCertAndKeyBaseName, apiClientCert, apiClientKey); err != nil {\r\n+                       return fmt.Errorf(\"failure while saving API server client certificate and key [%v]\", err)\r\n+               }\r\n+               fmt.Println(\"[certificates] Generated API server certificate and key.\")\r\n+       }\r\n+\r\n        fmt.Printf(\"[certificates] Valid certificates and keys now exist in %q\\n\", pkiDir)\r\n \r\n        return nil\r\n```",
        "createdAt" : "2017-01-23T18:28:20Z",
        "updatedAt" : "2017-01-23T18:28:20Z",
        "lastEditedBy" : "bfe6ebf1-cfa7-4758-abb1-9960fa09b194",
        "tags" : [
        ]
      },
      {
        "id" : "166f596d-b666-42c8-95b2-a04fee1d04a2",
        "parentId" : "88205dd8-c981-4292-9d5a-62a7a484a402",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "at first glance, that seems more correct",
        "createdAt" : "2017-01-23T18:35:37Z",
        "updatedAt" : "2017-01-23T18:35:37Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "6a37f450ae5c62770f5befd4e5334833ada513dd",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +125,129 @@\t\t\tAltNames:   altNames,\n\t\t\t// This makes the apiserver allowed to talk to the kubelets in the cluster\n\t\t\tOrganization: []string{\"system:masters\"},\n\t\t\tUsages:       []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth},\n\t\t}"
  },
  {
    "id" : "f3a39eea-541f-4afe-be2f-36dcba81b5cb",
    "prId" : 39638,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/39638#pullrequestreview-15936145",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ac3774e7-385e-4d6f-a06b-2f9a30a7b634",
        "parentId" : null,
        "authorId" : "0ac5d6cd-da87-46a2-9b30-0d21db1063a2",
        "body" : "Why not return fast if name is found?\r\n\r\n```go\r\nfor _, dnsNameThatShouldExist := range altNames.DNSNames {\r\n\tfound := false\r\n\tfor _, dnsName := range DNSNames {\r\n\t\tif dnsName == dnsNameThatShouldExist {\r\n\t\t\tfound = true\r\n\t\t\tbreak\r\n\t\t}\r\n\t}\r\n\r\n\tif !found {\r\n\t\treturn false\r\n\t}\r\n}\r\n```",
        "createdAt" : "2017-01-10T18:41:26Z",
        "updatedAt" : "2017-01-21T09:15:46Z",
        "lastEditedBy" : "0ac5d6cd-da87-46a2-9b30-0d21db1063a2",
        "tags" : [
        ]
      }
    ],
    "commit" : "e8ebfa02ff4731c3d8290c63d8065c0fb997a06c",
    "line" : 172,
    "diffHunk" : "@@ -1,1 +150,154 @@\t\t\treturn false\n\t\t}\n\t}\n\n\tfor _, ipThatShouldExist := range altNames.IPs {"
  },
  {
    "id" : "ee97a82d-1133-40c4-8c56-9741bff60df1",
    "prId" : 39638,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/39638#pullrequestreview-15936145",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d6461973-4f2e-4772-a724-fc6408f6bfa5",
        "parentId" : null,
        "authorId" : "0ac5d6cd-da87-46a2-9b30-0d21db1063a2",
        "body" : "Why not return fast if name is found?\r\n\r\n```go\r\nfor _, ipThatShouldExist := range altNames.IPs {\r\n\tfound := false\r\n\tfor _, dnsName := range IPs {\r\n\t\tif ip.Equal(ipThatShouldExist) {\r\n\t\t\tfound = true\r\n\t\t\tbreak\r\n\t\t}\r\n\t}\r\n\r\n\tif !found {\r\n\t\treturn false\r\n\t}\r\n}\r\n```",
        "createdAt" : "2017-01-10T18:42:32Z",
        "updatedAt" : "2017-01-21T09:15:46Z",
        "lastEditedBy" : "0ac5d6cd-da87-46a2-9b30-0d21db1063a2",
        "tags" : [
        ]
      }
    ],
    "commit" : "e8ebfa02ff4731c3d8290c63d8065c0fb997a06c",
    "line" : 172,
    "diffHunk" : "@@ -1,1 +164,168 @@\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}"
  }
]
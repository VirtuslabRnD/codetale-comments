[
  {
    "id" : "1c68d23e-a574-441a-9538-85ff2271f8e7",
    "prId" : 8369,
    "prUrl" : "https://github.com/root-project/root/pull/8369#pullrequestreview-702003575",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1af5dde7-fe92-4094-aaa0-5ccbf634211a",
        "parentId" : null,
        "authorId" : "09b7e073-cbeb-42e8-aa22-8b1468de56ae",
        "body" : "Should these be additional overloads, leaving the perf of the `double` version? Or have them as templates, only offering `double` and `long double` specializations (and possibly `float`)?",
        "createdAt" : "2021-07-08T09:51:53Z",
        "updatedAt" : "2021-07-08T09:51:53Z",
        "lastEditedBy" : "09b7e073-cbeb-42e8-aa22-8b1468de56ae",
        "tags" : [
        ]
      },
      {
        "id" : "6bbf8408-7972-44f7-bcce-2bc755b50fe1",
        "parentId" : "1af5dde7-fe92-4094-aaa0-5ccbf634211a",
        "authorId" : "4809a10a-85e2-4d0e-8c00-5a0777cea24e",
        "body" : "We discussed this, and concluded that it's unlikely to cause issues. The two potential problems would be:\r\n\r\n1. On some more exotic platform the long doubles may not be implemented or differently and the (bit-wise exact) tests will not pass. However, it is unclear what platforms this would be. GPU computation, for instance, would not be affected, because the parameter transformations are not part of the main calculation that would be offloaded to the GPU.\r\n2. This also means performance is not expected to be a big issue. With big fits, the parameter transformations are a minute part of the Minuit run time. Most time by far is spent in the function calls. The only situation in which it could be an issue is if you have a very cheap function with a huge amount of parameters. This seems quite unlikely for realistic fits.",
        "createdAt" : "2021-07-08T10:10:19Z",
        "updatedAt" : "2021-07-08T10:10:51Z",
        "lastEditedBy" : "4809a10a-85e2-4d0e-8c00-5a0777cea24e",
        "tags" : [
        ]
      },
      {
        "id" : "f61ab726-87b1-466f-a3f7-a4b27418f8ae",
        "parentId" : "1af5dde7-fe92-4094-aaa0-5ccbf634211a",
        "authorId" : "4809a10a-85e2-4d0e-8c00-5a0777cea24e",
        "body" : "One could also argue that a pro of using `long double` is that it clearly signals that these trigonometric transformations can lose some bits. This happens when you use the `double` versions and transform back and forth. In some situations, you can then lose 1 or 2 bits, just because of the trigonometric implementations. An alternative solution would be more precise sine etc functions. Though, actually, I'm not sure if that helps, because the needed information may be in the extra bits that will not be stored for any `double` version...",
        "createdAt" : "2021-07-08T10:14:03Z",
        "updatedAt" : "2021-07-08T10:15:17Z",
        "lastEditedBy" : "4809a10a-85e2-4d0e-8c00-5a0777cea24e",
        "tags" : [
        ]
      },
      {
        "id" : "48d8542e-e0f4-4d59-add7-b05131afcc56",
        "parentId" : "1af5dde7-fe92-4094-aaa0-5ccbf634211a",
        "authorId" : "09b7e073-cbeb-42e8-aa22-8b1468de56ae",
        "body" : "Thanks!\r\n\r\n> and the (bit-wise exact) tests will not pass\r\n\r\nThat's curious - how do you \"survive\" on Windows? https://docs.microsoft.com/en-us/cpp/cpp/fundamental-types-cpp?view=msvc-160#floating-point-types\r\n\r\nWhich tests, by the way?",
        "createdAt" : "2021-07-08T10:45:32Z",
        "updatedAt" : "2021-07-08T10:46:37Z",
        "lastEditedBy" : "09b7e073-cbeb-42e8-aa22-8b1468de56ae",
        "tags" : [
        ]
      },
      {
        "id" : "b7a24964-2664-4bf4-9eb2-6871e01a02b1",
        "parentId" : "1af5dde7-fe92-4094-aaa0-5ccbf634211a",
        "authorId" : "3cdeea47-0921-4380-9f86-57ac2ba3546a",
        "body" : "Windows will use the double version and it will then use few bits when using the external calculator with the multiprocess. Will the multiprocess be available on Windows ? Probably not",
        "createdAt" : "2021-07-08T11:50:52Z",
        "updatedAt" : "2021-07-08T11:50:52Z",
        "lastEditedBy" : "3cdeea47-0921-4380-9f86-57ac2ba3546a",
        "tags" : [
        ]
      },
      {
        "id" : "d3c66806-75c4-4000-b59f-52e0d556af88",
        "parentId" : "1af5dde7-fe92-4094-aaa0-5ccbf634211a",
        "authorId" : "09b7e073-cbeb-42e8-aa22-8b1468de56ae",
        "body" : "OK - but if there's only a `long double` version then which \"double version\" are you referring to? \"Bit-wise exact\" still depends on implementation / architecture. I trust this is handled, just making sure you're aware. (And I still don't know where these tests are.)",
        "createdAt" : "2021-07-08T12:22:02Z",
        "updatedAt" : "2021-07-08T12:22:02Z",
        "lastEditedBy" : "09b7e073-cbeb-42e8-aa22-8b1468de56ae",
        "tags" : [
        ]
      },
      {
        "id" : "ccbd85d4-701d-42e3-b70e-a673c5592732",
        "parentId" : "1af5dde7-fe92-4094-aaa0-5ccbf634211a",
        "authorId" : "4809a10a-85e2-4d0e-8c00-5a0777cea24e",
        "body" : "The tests in #8596 for instance @Axel-Naumann :) Btw, they don't pass currently either, due to changes in master that I hadn't incorporated yet. On the todo list.\r\n\r\nBut good question about Windows. I haven't tested at all there yet. So probably, at least for the time being, it will have to be disabled on Windows, as @lmoneta says. In principle, ZeroMQ works on all platforms, so that is not the bottleneck. However, I have no idea how/whether forking works on Windows.",
        "createdAt" : "2021-07-08T12:24:37Z",
        "updatedAt" : "2021-07-08T12:24:37Z",
        "lastEditedBy" : "4809a10a-85e2-4d0e-8c00-5a0777cea24e",
        "tags" : [
        ]
      },
      {
        "id" : "e6dd7d49-ba49-449f-b121-f315ee6da66e",
        "parentId" : "1af5dde7-fe92-4094-aaa0-5ccbf634211a",
        "authorId" : "4809a10a-85e2-4d0e-8c00-5a0777cea24e",
        "body" : "Just so you don't have to dig into the code: the test compares the results of fitting with RooMinimizerFcn vs fitting the same function with RooGradMinimizerFcn. We put a lot of effort into making those two fits run *exactly* the same way. Small bit-wise differences quickly accumulate in the algorithm to end up with different results (past the desired precision, so e.g. in the 6th decimal if you wanted the fit to converge to 5).",
        "createdAt" : "2021-07-08T12:33:23Z",
        "updatedAt" : "2021-07-08T12:33:24Z",
        "lastEditedBy" : "4809a10a-85e2-4d0e-8c00-5a0777cea24e",
        "tags" : [
        ]
      }
    ],
    "commit" : "49bf5c7cf13480399ddc1ed24f6b3cd77ff218f4",
    "line" : 16,
    "diffHunk" : "@@ -1,1 +31,35 @@   long double Int2ext(long double Value, long double Upper, long double Lower) const;\n   long double Ext2int(long double Value, long double Upper, long double Lower, const MnMachinePrecision &) const;\n   long double DInt2Ext(long double Value, long double Upper, long double Lower) const;\n\nprivate:"
  }
]
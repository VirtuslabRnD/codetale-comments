[
  {
    "id" : "4e21a2fd-55b1-4f75-9d19-4280cb054132",
    "prId" : 4880,
    "prUrl" : "https://github.com/apache/kafka/pull/4880#pullrequestreview-112987447",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9e1815e1-3cad-4a69-a7f8-d45462bc03d7",
        "parentId" : null,
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "Could we just call `decodeVersionTwoData` as we did for `processVersionThreeAssignment`?",
        "createdAt" : "2018-04-17T18:36:04Z",
        "updatedAt" : "2018-04-17T20:51:18Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "62e52942-e0f4-4a48-8257-93b5a70cac86",
        "parentId" : "9e1815e1-3cad-4a69-a7f8-d45462bc03d7",
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "It seems like these two approaches are fighting for dominance in this code.\r\n\r\nPersonally, I favor the \"flat\" design, where these methods don't call each other. It's just easier to read when each one in isolation lists all the operations it needs to do.\r\n\r\nIt's also more general, since a hypothetical future version N might add some new metadata in the middle, or even drop some previous metadata and so wouldn't be able to call decodeVersion{N-1} in its implementation.",
        "createdAt" : "2018-04-17T19:36:08Z",
        "updatedAt" : "2018-04-17T20:51:18Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      },
      {
        "id" : "e356dda6-0406-413f-9025-80fc49445552",
        "parentId" : "9e1815e1-3cad-4a69-a7f8-d45462bc03d7",
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "Version three will change and be different to version two. Thus, I prefer to not just call encodeVersionTwo. Guess it's personal taste.",
        "createdAt" : "2018-04-17T20:35:53Z",
        "updatedAt" : "2018-04-17T20:51:18Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      }
    ],
    "commit" : "0e762d6e1f24dc67a738950aa75264801b98a27f",
    "line" : 190,
    "diffHunk" : "@@ -1,1 +296,300 @@    private static void decodeVersionThreeData(final AssignmentInfo assignmentInfo,\n                                               final DataInputStream in) throws IOException {\n        decodeActiveTasks(assignmentInfo, in);\n        decodeStandbyTasks(assignmentInfo, in);\n        decodeGlobalAssignmentData(assignmentInfo, in);"
  },
  {
    "id" : "2944f0a0-64a0-4e5c-afe5-800ff4084168",
    "prId" : 7185,
    "prUrl" : "https://github.com/apache/kafka/pull/7185#pullrequestreview-280564359",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6a115a09-1ba8-433a-bb2d-fd51ad829f0c",
        "parentId" : null,
        "authorId" : "478a572c-b267-486a-b845-4847ccf71f62",
        "body" : "@guozhangwang Upon further testing, a simple dictionary encoding on the wire, saves almost the same amount as the index position based approach.. \r\n\r\nThis is much much simpler and does not interfere with the protocol or topology changes in anyway. thoughts? ",
        "createdAt" : "2019-08-12T17:40:47Z",
        "updatedAt" : "2019-09-03T23:47:18Z",
        "lastEditedBy" : "478a572c-b267-486a-b845-4847ccf71f62",
        "tags" : [
        ]
      },
      {
        "id" : "0262519d-44b6-4eac-b1a4-44ca5596c5b7",
        "parentId" : "6a115a09-1ba8-433a-bb2d-fd51ad829f0c",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "I like this idea. It's indeed much simplified. I think the dictionary map cost is marginal if we are having a large number of clients with large number of partitions per topic.",
        "createdAt" : "2019-08-28T02:46:06Z",
        "updatedAt" : "2019-09-03T23:47:18Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      }
    ],
    "commit" : "9ab9b54afa2442365850883bd0197a88395976ae",
    "line" : 76,
    "diffHunk" : "@@ -1,1 +203,207 @@    }\n\n    private void encodePartitionsByHostAsDictionary(final DataOutputStream out) throws IOException {\n\n        // Build a dictionary to encode topicNames"
  }
]
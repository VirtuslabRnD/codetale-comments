[
  {
    "id" : "2c6a7adc-d8bd-4c34-9080-4e7bc0875bee",
    "prId" : 6565,
    "prUrl" : "https://github.com/apache/kafka/pull/6565#pullrequestreview-227329382",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5730c6ea-e740-4822-86e3-b890e766a983",
        "parentId" : null,
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "`otherRecord.key` is quite confusing to first-time reader isn't it .. :)",
        "createdAt" : "2019-04-15T17:00:21Z",
        "updatedAt" : "2019-04-16T07:39:30Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "8e031b65-ac4d-4a76-9809-26a61057ae63",
        "parentId" : "5730c6ea-e740-4822-86e3-b890e766a983",
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "Yes... Suggestions to improve it?",
        "createdAt" : "2019-04-16T00:22:09Z",
        "updatedAt" : "2019-04-16T07:39:30Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "b4edd078-a482-4966-9e32-fdd853d8aaa6",
        "parentId" : "5730c6ea-e740-4822-86e3-b890e766a983",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "Well, we have KIP-439 isn't it :) Just joking about how confusing it could be for the current WindowStoreIterator.",
        "createdAt" : "2019-04-16T17:08:42Z",
        "updatedAt" : "2019-04-16T17:08:42Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      }
    ],
    "commit" : "99988da93bfdb13aaed4a0391620e29f0d2c3e3d",
    "line" : 32,
    "diffHunk" : "@@ -1,1 +99,103 @@                        key,\n                        joiner.apply(value, otherRecord.value),\n                        To.all().withTimestamp(Math.max(inputRecordTimestamp, otherRecord.key)));\n                }\n"
  },
  {
    "id" : "ea408bf6-0b56-432d-b413-b389a71a7000",
    "prId" : 10462,
    "prUrl" : "https://github.com/apache/kafka/pull/10462#pullrequestreview-647742112",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "04fe9c47-fbde-4cb4-be1a-6118a9eb0a3b",
        "parentId" : null,
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "Not sure if I understand the second condition?",
        "createdAt" : "2021-04-13T04:10:32Z",
        "updatedAt" : "2021-04-28T11:46:56Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "5d17589a-c196-485a-b49e-371bb8468dec",
        "parentId" : "04fe9c47-fbde-4cb4-be1a-6118a9eb0a3b",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "I think the motivation is that if the current record's timestamp is too small (i.e. it is too late), then it should not be added into the book-keeping store but can be \"expired\" immediately. But I also feel the condition seems a bit off here: for the record to be \"too late\", its timestamp just need to be smaller than the expiration boundary, which is observed-stream-time - join-after - grace-period, right?",
        "createdAt" : "2021-04-19T23:29:55Z",
        "updatedAt" : "2021-04-28T11:46:57Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "17cd325b-04ea-43e2-b77b-f72e8523ba1d",
        "parentId" : "04fe9c47-fbde-4cb4-be1a-6118a9eb0a3b",
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "Well, while we should have a check like this, it seems it should go to the top of this method, next to the key/value `null` check? We should also add a corresponding `lateRecordDropSensor` (cf `KStreamWindowAggregate.java`).\r\n\r\nWe can also `return` from `process()` early, as if we have a late record, we know that stream-time does not advance and thus we don't need to emit anything downstream.",
        "createdAt" : "2021-04-20T00:54:13Z",
        "updatedAt" : "2021-04-28T11:46:57Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "2b1acb59-33c8-4a59-8d96-c5f7670675f7",
        "parentId" : "04fe9c47-fbde-4cb4-be1a-6118a9eb0a3b",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "@spena seems there are a few different conditions we can consider here:\r\n\r\n1) record time < stream time - window length - grace length: the record is too late, we should drop it up front and also record the `droppedRecordsSensorOrExpiredWindowRecordDropSensor`.\r\n\r\n2) record time >= stream time - window length - grace length, but < stream time: the record is still late, but joinable, since the stream time would not be advanced we would not have to check and emit non-joined records, but just try to join this record with the other window. Note that like @mjsax said, for the returned matching record, we also need to check if the other record time >= stream time - window length - grace length or not.\r\n\r\n3) record time > stream time, we would first try to emit non-joined records, and then try to join this record.",
        "createdAt" : "2021-04-29T00:29:15Z",
        "updatedAt" : "2021-04-29T00:55:54Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      }
    ],
    "commit" : "f10ff2ca65515666c40469de2b8cc81f5c78c509",
    "line" : 138,
    "diffHunk" : "@@ -1,1 +164,168 @@                    // This condition below allows us to process the out-of-order records without the need\n                    // to hold it in the temporary outer store\n                    if (!outerJoinWindowStore.isPresent() || timeTo < maxObservedStreamTime.get()) {\n                        context().forward(key, joiner.apply(key, value, null));\n                    } else {"
  },
  {
    "id" : "92e2640c-c680-4b7b-8099-0fcd5cd87621",
    "prId" : 10462,
    "prUrl" : "https://github.com/apache/kafka/pull/10462#pullrequestreview-647742112",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "58728c36-cb26-4b3f-b06c-327a4c392b31",
        "parentId" : null,
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "Side improvement: I think we should skip late record directly and also record it in `TaskMetrics.droppedRecordsSensorOrExpiredWindowRecordDropSensor` ",
        "createdAt" : "2021-04-13T04:12:52Z",
        "updatedAt" : "2021-04-28T11:46:56Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "6bf30871-dd56-4913-8c1b-8664db9915ff",
        "parentId" : "58728c36-cb26-4b3f-b06c-327a4c392b31",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "@spena @mjsax I left another comment below regarding the time. Please LMK id you think that makes sense.",
        "createdAt" : "2021-04-29T00:54:44Z",
        "updatedAt" : "2021-04-29T00:55:54Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      }
    ],
    "commit" : "f10ff2ca65515666c40469de2b8cc81f5c78c509",
    "line" : 95,
    "diffHunk" : "@@ -1,1 +123,127 @@\n            maxObservedStreamTime.advance(inputRecordTimestamp);\n\n            // Emit all non-joined records which window has closed\n            if (inputRecordTimestamp == maxObservedStreamTime.get()) {"
  },
  {
    "id" : "3be9d8f3-8f1a-4e48-aebe-32a802b20927",
    "prId" : 10462,
    "prUrl" : "https://github.com/apache/kafka/pull/10462#pullrequestreview-647742112",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "290b83de-bd79-496d-9288-f248f9010a54",
        "parentId" : null,
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "Side improvement: atm `windowStore` does not have a guarantee of a strict retention time, ie, even if retention time passed, it may still have expired data in it, and return it. Thus, we should have an additional check if `otherRecordTimestamp < stream-time - windowSize - gracePeriod` and drop the \"other record\" for this case, to get a strict time bound (we don't need to report this in any metric).\r\n\r\nWe should extend our tests accordingly.",
        "createdAt" : "2021-04-13T04:14:56Z",
        "updatedAt" : "2021-04-28T11:46:56Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "aa224880-1c71-467a-afb5-e478d89c2a17",
        "parentId" : "290b83de-bd79-496d-9288-f248f9010a54",
        "authorId" : "92abc720-96d9-4067-bc18-9bf1fa4019a1",
        "body" : "Interesting. Is this a current bug with the old join semantics?",
        "createdAt" : "2021-04-15T18:35:16Z",
        "updatedAt" : "2021-04-28T11:46:57Z",
        "lastEditedBy" : "92abc720-96d9-4067-bc18-9bf1fa4019a1",
        "tags" : [
        ]
      },
      {
        "id" : "c9af3347-f78f-4101-9d4f-017d3479a571",
        "parentId" : "290b83de-bd79-496d-9288-f248f9010a54",
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "Yes, it a bug in the current implementation...",
        "createdAt" : "2021-04-16T03:33:00Z",
        "updatedAt" : "2021-04-28T11:46:57Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "d12344b6-fcc3-40ea-b6bc-d223029f8f9e",
        "parentId" : "290b83de-bd79-496d-9288-f248f9010a54",
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "Seems this comment was not address yet. Or do you not want to add this additional fix into this PR?",
        "createdAt" : "2021-04-20T00:49:53Z",
        "updatedAt" : "2021-04-28T11:46:57Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "80fdde9a-dc84-4723-8b69-6eb1c996697c",
        "parentId" : "290b83de-bd79-496d-9288-f248f9010a54",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "@spena just ping to make sure you get this on the follow-up PR.",
        "createdAt" : "2021-04-29T00:55:29Z",
        "updatedAt" : "2021-04-29T00:55:54Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      }
    ],
    "commit" : "f10ff2ca65515666c40469de2b8cc81f5c78c509",
    "line" : 105,
    "diffHunk" : "@@ -1,1 +133,137 @@                    needOuterJoin = false;\n                    final KeyValue<Long, V2> otherRecord = iter.next();\n                    final long otherRecordTimestamp = otherRecord.key;\n\n                    outerJoinWindowStore.ifPresent(store -> {"
  },
  {
    "id" : "94770135-847b-4964-aee7-a3895a1458f0",
    "prId" : 10462,
    "prUrl" : "https://github.com/apache/kafka/pull/10462#pullrequestreview-640052938",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c542a7a7-a720-4cc2-b22b-c62e9423ae7c",
        "parentId" : null,
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "nit : I think this function can just be inlined now?",
        "createdAt" : "2021-04-19T22:28:55Z",
        "updatedAt" : "2021-04-28T11:46:57Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "a94cd1f9-be09-4f43-bfe7-46bc4a7ab6eb",
        "parentId" : "c542a7a7-a720-4cc2-b22b-c62e9423ae7c",
        "authorId" : "92abc720-96d9-4067-bc18-9bf1fa4019a1",
        "body" : "Done",
        "createdAt" : "2021-04-20T14:49:51Z",
        "updatedAt" : "2021-04-28T11:46:57Z",
        "lastEditedBy" : "92abc720-96d9-4067-bc18-9bf1fa4019a1",
        "tags" : [
        ]
      }
    ],
    "commit" : "f10ff2ca65515666c40469de2b8cc81f5c78c509",
    "line" : 65,
    "diffHunk" : "@@ -1,1 +81,85 @@\n    private class KStreamKStreamJoinProcessor extends AbstractProcessor<K, V1> {\n        private final Predicate<Windowed<KeyAndJoinSide<K>>> recordWindowHasClosed =\n            windowedKey -> windowedKey.window().start() + joinAfterMs + joinGraceMs < maxObservedStreamTime.get();\n"
  },
  {
    "id" : "bd4653b4-13f2-4163-af1e-e61cfc829174",
    "prId" : 10861,
    "prUrl" : "https://github.com/apache/kafka/pull/10861#pullrequestreview-680578337",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5aeba950-ef9f-4d11-b8ec-c82b0a189435",
        "parentId" : null,
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "This was done by the caller before, ie, `KStreamImplJoin` from above. As we only pass one parameter now, we need to do the flip here if necessary.",
        "createdAt" : "2021-06-10T09:54:18Z",
        "updatedAt" : "2021-06-10T10:08:52Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      }
    ],
    "commit" : "dad2fe801497ebb301f354af0a48cae6a905722b",
    "line" : 25,
    "diffHunk" : "@@ -1,1 +66,70 @@        this.isLeftSide = isLeftSide;\n        this.otherWindowName = otherWindowName;\n        if (isLeftSide) {\n            this.joinBeforeMs = windows.beforeMs;\n            this.joinAfterMs = windows.afterMs;"
  },
  {
    "id" : "22585a8e-0b10-4b70-b26b-9369dc779231",
    "prId" : 10861,
    "prUrl" : "https://github.com/apache/kafka/pull/10861#pullrequestreview-685400743",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a3003565-4b0b-4336-8568-987fa4ca6ede",
        "parentId" : null,
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "We evaluate the feature flag twice. This is the first time. So we add the new flag, too.",
        "createdAt" : "2021-06-10T09:55:30Z",
        "updatedAt" : "2021-06-10T10:08:52Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "3258605c-4965-47a9-ae92-6d0a49fa1323",
        "parentId" : "a3003565-4b0b-4336-8568-987fa4ca6ede",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "Thinking a bit more to not evaluate the condition twice: since we call `addStateStore` in the logical plan, a.k.a. `StreamStreamJoinNode` first if both conditions are met, could we just blindly try to get the store from `context.getStateStore()` here, which would return `null` if the store was not added during logical plan and hence does not exist anyways. If it is `null` we can still convert it to an `Optional.empty()`.",
        "createdAt" : "2021-06-13T00:10:33Z",
        "updatedAt" : "2021-06-13T00:14:24Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "bec73339-91da-4eb2-9152-e2673f29063b",
        "parentId" : "a3003565-4b0b-4336-8568-987fa4ca6ede",
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "I don't think that checking the condition twice is a real issue? Also, it seem to be better to do the check, because otherwise (if we might have a bug and incorrectly get a `null` store back) we might mask the bug?",
        "createdAt" : "2021-06-15T00:29:44Z",
        "updatedAt" : "2021-06-15T00:29:44Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "87f09a81-dbae-4015-a34f-3650ce23ae60",
        "parentId" : "a3003565-4b0b-4336-8568-987fa4ca6ede",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "I'm thinking exactly the opposite :) if we have a bug which would cause us to create a state store, checking it twice may actually mask the bug: we would end up creating the state store, and then on the second check not getting it, so the behavior is still correct, and it'll be hard for us to discover we are creating state stores unnecessarily.\r\n\r\nIf we have a bug and do not create state stores when needed, then we would behave in the old way without the fix; the key point here is that, we only have one decision point to make, and either that decision is correct or buggy, we can get it surfaced quickly.",
        "createdAt" : "2021-06-15T17:01:31Z",
        "updatedAt" : "2021-06-15T17:01:31Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "9b583be6-0094-422a-998a-3d8dfe7bff35",
        "parentId" : "a3003565-4b0b-4336-8568-987fa4ca6ede",
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "After update the code with the `else` a few tests started to fail. The issue is, that for left/outer join we _always_ set the store name (even if the feature is disabled...) -- only for inner join, we get an `Optinal.empty()`. Thus, we can actually not verify the `else` case (ie, we added a store even if we don't need it) at runtime. I guess we need to rely on the added unit tests instead to cover this case.",
        "createdAt" : "2021-06-16T05:13:34Z",
        "updatedAt" : "2021-06-16T05:13:34Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "f4a116bb-b8f4-41f5-9f50-09a08c2d5a29",
        "parentId" : "a3003565-4b0b-4336-8568-987fa4ca6ede",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "Okay I think I know what's the messy part here: we are setting the stores during KStreamJoin which is only at the parsing phase, but not the logical plan generation phase. The key difference is that the latter has access to the user's configuration whereas the former is not. And because of that we have an unclean settings, we should decide e.g. which stores to create only at the logical plan aka StreamStreamJoinNode.\r\n\r\nThis is a general issue with Streams parsing/logical plan generation, and I will file a ticket for it.",
        "createdAt" : "2021-06-16T16:24:32Z",
        "updatedAt" : "2021-06-16T16:24:32Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "a81e8f72-cd6e-4d80-aec0-4ddacc2dff4b",
        "parentId" : "a3003565-4b0b-4336-8568-987fa4ca6ede",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "Filed https://issues.apache.org/jira/browse/KAFKA-12957",
        "createdAt" : "2021-06-16T16:31:33Z",
        "updatedAt" : "2021-06-16T16:31:33Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      }
    ],
    "commit" : "dad2fe801497ebb301f354af0a48cae6a905722b",
    "line" : 42,
    "diffHunk" : "@@ -1,1 +98,102 @@            otherWindowStore = context.getStateStore(otherWindowName);\n\n            if (enableSpuriousResultFix\n                && StreamsConfig.InternalConfig.getBoolean(\n                    context().appConfigs(),"
  }
]
[
  {
    "id" : "45d56121-199d-465a-8a36-2f78d8595f9f",
    "prId" : 8337,
    "prUrl" : "https://github.com/apache/kafka/pull/8337#pullrequestreview-385143546",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "276faf42-0106-4efa-af05-62a9b0b578bd",
        "parentId" : null,
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "This is a bit suspicious... If we're polling the queue, we should just loop until the queue is empty, not iterate over another another collection we happen to know has the same number of elements.\r\n\r\nMore specifically, `poll` might return `null`, but `offer` throws an NPE if `client` is `null`.",
        "createdAt" : "2020-03-31T02:17:39Z",
        "updatedAt" : "2020-04-01T19:33:13Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      },
      {
        "id" : "85ec4702-e725-4e2c-9a4e-f1750ff6c5e7",
        "parentId" : "276faf42-0106-4efa-af05-62a9b0b578bd",
        "authorId" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "body" : "I do not agree. We need to distribute the stateless tasks, therefore the loop is over the stateless tasks. For each task we need to find the client with the least load which is done with the priority queue (i.e. min-heap). Since we poll a client and add the updated client in each iteration, `poll()` cannot return `null`.\r\n\r\nMy question would be why we only consider the stateful active tasks assignment and not the assignment of all tasks, i.e., also standby tasks and warm-up replica in the priority queue. Also those tasks contribute to the load of a client.",
        "createdAt" : "2020-03-31T13:33:54Z",
        "updatedAt" : "2020-04-01T19:33:13Z",
        "lastEditedBy" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "tags" : [
        ]
      },
      {
        "id" : "92512486-7c22-42db-bc28-cfbca2c92316",
        "parentId" : "276faf42-0106-4efa-af05-62a9b0b578bd",
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "fair enough",
        "createdAt" : "2020-03-31T20:06:32Z",
        "updatedAt" : "2020-04-01T19:33:13Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      },
      {
        "id" : "8ddbeb0f-591c-419d-8624-bc41ad42c48f",
        "parentId" : "276faf42-0106-4efa-af05-62a9b0b578bd",
        "authorId" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "body" : "@cadonna I was thinking that we should try to balance the active tasks and standby tasks separately, but maybe a standby task is closer to the workload of a stateful active task than a stateless active task is. So, I think I agree that we should include all tasks here",
        "createdAt" : "2020-04-01T01:02:49Z",
        "updatedAt" : "2020-04-01T19:33:13Z",
        "lastEditedBy" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "tags" : [
        ]
      }
    ],
    "commit" : "f473f60b99f3b3b2f549b5ae48b2be01fc5cf461",
    "line" : 160,
    "diffHunk" : "@@ -1,1 +158,162 @@            statelessActiveTaskAssignment.get(client).add(task);\n            statelessActiveTaskClientsQueue.offer(client);\n        }\n\n        // ---------------- Assign Tasks To Clients ---------------- //"
  },
  {
    "id" : "7b64556a-8978-467b-82ec-e5b36db618f5",
    "prId" : 8337,
    "prUrl" : "https://github.com/apache/kafka/pull/8337#pullrequestreview-385965920",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "be6d7d32-85ee-49d3-a331-2c178cb2b91a",
        "parentId" : null,
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "I'm starting to lose track of the details... What is the impact of setting these tasks' ranks as `-1` instead of `0`?\r\n\r\nIf memory serves, we proposed to just treat all caught-up clients as the same for the purpose of assignments.",
        "createdAt" : "2020-03-31T02:35:28Z",
        "updatedAt" : "2020-04-01T19:33:13Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      },
      {
        "id" : "1f7536df-8d2a-4e70-8729-0e5dec967e88",
        "parentId" : "be6d7d32-85ee-49d3-a331-2c178cb2b91a",
        "authorId" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "body" : "I see what you mean. I do not have any heart feelings here. Would be interesting to see in experiments how the two approaches differ.",
        "createdAt" : "2020-03-31T14:09:41Z",
        "updatedAt" : "2020-04-01T19:33:13Z",
        "lastEditedBy" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "tags" : [
        ]
      },
      {
        "id" : "381bc29e-c82d-4dec-8d14-413a07282b4c",
        "parentId" : "be6d7d32-85ee-49d3-a331-2c178cb2b91a",
        "authorId" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "body" : "I think we should still prioritize the client that had the active task over one with a caught-up standby. For one thing, with KIP-429 we have to revoke an active task before moving it to a new client in a followup rebalance. This means deadtime for that active task between being closed on one client, waiting for another rebalance, and finally being recreated from a standby on a new client. We also lose the cache, buffers, etc",
        "createdAt" : "2020-03-31T20:10:54Z",
        "updatedAt" : "2020-04-01T19:33:13Z",
        "lastEditedBy" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "tags" : [
        ]
      },
      {
        "id" : "e087d123-2803-44ec-ba2b-2c109948b606",
        "parentId" : "be6d7d32-85ee-49d3-a331-2c178cb2b91a",
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "That's fair. My concern about the impact was whether it results in non-termination of the probing rebalance cycle, if we always prefer to re-assign the prior active and always propose to move the task to the same caught-up standby, but never consider just giving the active to the caught-up standby, since there is a prior active.",
        "createdAt" : "2020-03-31T21:46:49Z",
        "updatedAt" : "2020-04-01T19:33:13Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      },
      {
        "id" : "c55eecd2-25aa-4bc4-a724-3f2f1e8c783a",
        "parentId" : "be6d7d32-85ee-49d3-a331-2c178cb2b91a",
        "authorId" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "body" : "Actually I'm pretty concerned about the same thing, but I'm not sure I see how ranking previous active tasks saves us from getting trapped in the rebalancing cycle. Might be worth chatting about offline..",
        "createdAt" : "2020-04-01T04:32:11Z",
        "updatedAt" : "2020-04-01T19:33:13Z",
        "lastEditedBy" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "tags" : [
        ]
      },
      {
        "id" : "cdabc5fd-30d3-4226-86de-794eda830bb8",
        "parentId" : "be6d7d32-85ee-49d3-a331-2c178cb2b91a",
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "I suppose that this, among other things, will become clear when we add some integration and system tests.",
        "createdAt" : "2020-04-01T21:34:15Z",
        "updatedAt" : "2020-04-01T21:34:15Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      }
    ],
    "commit" : "f473f60b99f3b3b2f549b5ae48b2be01fc5cf461",
    "line" : 303,
    "diffHunk" : "@@ -1,1 +301,305 @@                final long clientRank;\n                if (taskLag == Task.LATEST_OFFSET) {\n                    clientRank = Task.LATEST_OFFSET;\n                } else if (taskLag == UNKNOWN_OFFSET_SUM) {\n                    clientRank = 1L;"
  },
  {
    "id" : "c9679d5a-1e77-4c4f-be81-affe844530a0",
    "prId" : 8337,
    "prUrl" : "https://github.com/apache/kafka/pull/8337#pullrequestreview-385143546",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "32c9fa9f-0b4c-497c-8e5e-e7f28513c79b",
        "parentId" : null,
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "If I read this right, the current method doesn't actually consider the new proposed assignment. Are we mutating some fields, or could this method actually be invoked at the beginning of the assignment to gate if the current assignment is \"good enough\"?",
        "createdAt" : "2020-03-31T02:44:45Z",
        "updatedAt" : "2020-04-01T19:33:13Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      },
      {
        "id" : "db11fd5d-12bd-40ad-89c0-98a5285bf13d",
        "parentId" : "32c9fa9f-0b4c-497c-8e5e-e7f28513c79b",
        "authorId" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "body" : "Another artifact of removing an optimization. I think we can move it up to the beginning now, yes",
        "createdAt" : "2020-03-31T22:16:04Z",
        "updatedAt" : "2020-04-01T19:33:13Z",
        "lastEditedBy" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "tags" : [
        ]
      }
    ],
    "commit" : "f473f60b99f3b3b2f549b5ae48b2be01fc5cf461",
    "line" : 344,
    "diffHunk" : "@@ -1,1 +342,346 @@\n    /**\n     * Determines whether to use the new proposed assignment or just return the group's previous assignment. The\n     * previous assignment will be chosen and returned iff all of the following are true:\n     *   1) it satisfies the state constraint, ie all tasks with caught up clients are assigned to one of those clients"
  },
  {
    "id" : "d1f00766-3b7b-40c5-a358-21a3e8cfc172",
    "prId" : 8337,
    "prUrl" : "https://github.com/apache/kafka/pull/8337#pullrequestreview-385920937",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e1e99549-cc90-4c06-b971-31151d37a878",
        "parentId" : null,
        "authorId" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "body" : "IMO, those comments are more confusing than helping. I would prefer to have methods with meaningful names to structure the code. For example,\r\n- `assignStatefulTasksAndWarmUpReplica()` or `computeAssignmentFor...`\r\n- `assignStandByTasks()` or `computeAssignmentFor...`\r\n- `assignStatelessTasks()` or `computeAssignmentFor...`",
        "createdAt" : "2020-03-31T13:20:38Z",
        "updatedAt" : "2020-04-01T19:33:13Z",
        "lastEditedBy" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "tags" : [
        ]
      },
      {
        "id" : "3d68f2c6-93af-45e1-bae8-9a029d03ae05",
        "parentId" : "e1e99549-cc90-4c06-b971-31151d37a878",
        "authorId" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "body" : "Do you mind if this is saved for a followup PR? Specifically, when we move some of the static methods/classes to a separate file, and it's easier to get oriented in the `HighAvailabilityTaskAssignor` file",
        "createdAt" : "2020-04-01T20:22:20Z",
        "updatedAt" : "2020-04-01T20:22:20Z",
        "lastEditedBy" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "tags" : [
        ]
      }
    ],
    "commit" : "f473f60b99f3b3b2f549b5ae48b2be01fc5cf461",
    "line" : 94,
    "diffHunk" : "@@ -1,1 +92,96 @@        final Map<ID, List<TaskId>> statelessActiveTaskAssignment = initializeEmptyTaskAssignmentMap();\n\n        // ---------------- Stateful Active Tasks ---------------- //\n\n        final Map<ID, List<TaskId>> statefulActiveTaskAssignment ="
  },
  {
    "id" : "ef91babb-dae1-4387-bf98-74fe34c13f98",
    "prId" : 8337,
    "prUrl" : "https://github.com/apache/kafka/pull/8337#pullrequestreview-385966305",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "12bb0c5e-16cc-4661-8524-6b754655a43a",
        "parentId" : null,
        "authorId" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "body" : "Q: I might have missed the discussion. Why does an unknown offset result in `1` and not in `Long.MAX_VALUE`? Sorry if you have already answered this question elsewhere.    ",
        "createdAt" : "2020-03-31T14:12:44Z",
        "updatedAt" : "2020-04-01T19:33:13Z",
        "lastEditedBy" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "tags" : [
        ]
      },
      {
        "id" : "1d48cab0-6955-4ceb-ac18-c808a6b3c39c",
        "parentId" : "12bb0c5e-16cc-4661-8524-6b754655a43a",
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "It seems like it's worth including the explanation in the javadoc at the top of this method.",
        "createdAt" : "2020-03-31T20:11:27Z",
        "updatedAt" : "2020-04-01T19:33:13Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      },
      {
        "id" : "c7d354de-936f-4eab-bd7e-304ac7a105da",
        "parentId" : "12bb0c5e-16cc-4661-8524-6b754655a43a",
        "authorId" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "body" : "Added to the javadocs, but please lmk if the description is still too short to be clear",
        "createdAt" : "2020-04-01T04:25:16Z",
        "updatedAt" : "2020-04-01T19:33:13Z",
        "lastEditedBy" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "tags" : [
        ]
      },
      {
        "id" : "86a0a51b-ad93-42c4-bcec-1e52945a72cb",
        "parentId" : "12bb0c5e-16cc-4661-8524-6b754655a43a",
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "It looks good to me.",
        "createdAt" : "2020-04-01T21:34:54Z",
        "updatedAt" : "2020-04-01T21:34:55Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      }
    ],
    "commit" : "f473f60b99f3b3b2f549b5ae48b2be01fc5cf461",
    "line" : 305,
    "diffHunk" : "@@ -1,1 +303,307 @@                    clientRank = Task.LATEST_OFFSET;\n                } else if (taskLag == UNKNOWN_OFFSET_SUM) {\n                    clientRank = 1L;\n                } else if (taskLag <= acceptableRecoveryLag) {\n                    clientRank = 0L;"
  },
  {
    "id" : "9b66401a-7aa9-4b84-ba10-ad5f11136c55",
    "prId" : 8337,
    "prUrl" : "https://github.com/apache/kafka/pull/8337#pullrequestreview-385022551",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ae2692eb-e9ce-48f8-86b4-36a0faa3b425",
        "parentId" : null,
        "authorId" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "body" : "Q: There are a lot of methods that are package-private for testing. I would avoid to do that too much. If we feel we need to test sub components of a class then we might want to factor this components out to their own classes that we can test separately. For example, the validation of the previous assignment can be encapsulated into its own class. Does not need to be in this PR, though. WDYT?  ",
        "createdAt" : "2020-03-31T16:06:48Z",
        "updatedAt" : "2020-04-01T19:33:13Z",
        "lastEditedBy" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "tags" : [
        ]
      },
      {
        "id" : "d92ef76a-d150-45a8-b645-76512fd99e02",
        "parentId" : "ae2692eb-e9ce-48f8-86b4-36a0faa3b425",
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "For my part, I think that several of the static inner classes of this assignor should be pulled out into top-level classes, which would have the side effect of pulling several of these tests that are unrelated to the HATA's contract itself. But I don't think it's high value right now, as I also want to refactor this module a bit before we finalize the feature.\r\n\r\nAs far as having visible-for-testing methods, I agree it's generally a failure of encapsulation, but in this particular case, we don't rely on the HATA's built-in public interface, but always access it via the `TaskAssignor` interface in the production code path, which makes package-visible methods in HATA much more palatable. It's also mitigating the risk that this method doesn't mutate the assignor, so I don't find this particular case too concerning.\r\n\r\nAltogether, if we had a package-visible static method on another object to do this, or a package-visible instance method on this object, it seems to be equally visible, so I guess it's no practical difference in this particular case. If you really want to encapsulate the method, the solution for both approaches is to put the HATA in its own package: `o.a.k.s.p.i.assignment.ha.*`, but it feels like diminishing returns.\r\n\r\nI _do_ look forward to dropping support for Java 8 so that we can declare module public interfaces and not have to contend with compromises like this. ",
        "createdAt" : "2020-03-31T16:23:34Z",
        "updatedAt" : "2020-04-01T19:33:13Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      },
      {
        "id" : "3b7c6463-f05d-49c8-adec-ee5905c3b75f",
        "parentId" : "ae2692eb-e9ce-48f8-86b4-36a0faa3b425",
        "authorId" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "body" : "I agree with you that in this specific case, it might not be that concerning and that we can leave refactoring as a follow-up. However, I see the practice visible-for-testing a lot across the code base and I would like to keep it at the absolute minimum in new code.   ",
        "createdAt" : "2020-03-31T19:00:39Z",
        "updatedAt" : "2020-04-01T19:33:13Z",
        "lastEditedBy" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "tags" : [
        ]
      },
      {
        "id" : "638ef2cf-4737-47ff-a6ac-7a9c79faae02",
        "parentId" : "ae2692eb-e9ce-48f8-86b4-36a0faa3b425",
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "Oh, yeah, I'm 100% on board with you there. `// visible for testing` always reads to me like `// setting a trap for the future:`. ",
        "createdAt" : "2020-03-31T19:04:26Z",
        "updatedAt" : "2020-04-01T19:33:13Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      }
    ],
    "commit" : "f473f60b99f3b3b2f549b5ae48b2be01fc5cf461",
    "line" : 216,
    "diffHunk" : "@@ -1,1 +214,218 @@     * @return true iff all active tasks with caught-up client are assigned to one of them, and all tasks are assigned\n     */\n    boolean previousAssignmentIsValid() {\n        final Set<TaskId> unassignedActiveTasks = new HashSet<>(allTasks);\n        final Map<TaskId, Integer> unassignedStandbyTasks ="
  },
  {
    "id" : "9bfe4355-670c-4851-9d01-92b7e893cb67",
    "prId" : 8337,
    "prUrl" : "https://github.com/apache/kafka/pull/8337#pullrequestreview-385961051",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "95ab6126-2611-4d89-b378-daff37a088c6",
        "parentId" : null,
        "authorId" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "body" : "Q: IIUC, we do not check if the movement is for free. That is, if the destination is a caught-up client. If it were we would not need to assign a warm-up replica and could consider one more movement. I am also fine with post-poning that to a follow-up PR. ",
        "createdAt" : "2020-04-01T07:06:29Z",
        "updatedAt" : "2020-04-01T19:33:13Z",
        "lastEditedBy" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "tags" : [
        ]
      },
      {
        "id" : "587408d6-84b0-4cb8-813c-3c55dff34870",
        "parentId" : "95ab6126-2611-4d89-b378-daff37a088c6",
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "Oh, that's a really good point. We should totally do that, but I agree it would be easier to do it in a follow-on.",
        "createdAt" : "2020-04-01T18:33:41Z",
        "updatedAt" : "2020-04-01T19:33:13Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      },
      {
        "id" : "ebee26b8-201d-4618-befa-32dc6a3eac9b",
        "parentId" : "95ab6126-2611-4d89-b378-daff37a088c6",
        "authorId" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "body" : "Sounds good",
        "createdAt" : "2020-04-01T21:26:10Z",
        "updatedAt" : "2020-04-01T21:26:10Z",
        "lastEditedBy" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "tags" : [
        ]
      }
    ],
    "commit" : "f473f60b99f3b3b2f549b5ae48b2be01fc5cf461",
    "line" : 118,
    "diffHunk" : "@@ -1,1 +116,120 @@        for (final Movement<ID> movement : movements) {\n            warmupTaskAssignment.get(movement.destination).add(movement.task);\n        }\n\n        // ---------------- Standby Replica Tasks ---------------- //"
  },
  {
    "id" : "62418d0d-ab3a-4740-aec0-2cc923a79de8",
    "prId" : 8497,
    "prUrl" : "https://github.com/apache/kafka/pull/8497#pullrequestreview-396439844",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "27977592-ce2a-4067-a13c-12c4ef958910",
        "parentId" : null,
        "authorId" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "body" : "I love it when a comment gets killed by a meaningful method name!",
        "createdAt" : "2020-04-20T13:13:44Z",
        "updatedAt" : "2020-04-21T19:20:52Z",
        "lastEditedBy" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "tags" : [
        ]
      }
    ],
    "commit" : "2a6dc0b002bf6e6f46d9a910d0358cbcf81dd1f7",
    "line" : 33,
    "diffHunk" : "@@ -1,1 +90,94 @@            statefulTasks.stream().collect(Collectors.toMap(task -> task, t -> configs.numStandbyReplicas));\n\n        final boolean followupRebalanceNeeded = assignStatefulActiveTasks(tasksToRemainingStandbys);\n\n        assignStandbyReplicaTasks(tasksToRemainingStandbys);"
  }
]
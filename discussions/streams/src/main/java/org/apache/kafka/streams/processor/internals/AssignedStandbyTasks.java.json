[
  {
    "id" : "22b89f96-d491-4d7a-aa3c-1947ffdc1fcf",
    "prId" : 7238,
    "prUrl" : "https://github.com/apache/kafka/pull/7238#pullrequestreview-286897280",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a002ba66-09e9-475d-8c9e-e972d86acfd1",
        "parentId" : null,
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "Seems we should add `AssignedStandbyTasksTest.java` to unit test the new `commit()` behavior.",
        "createdAt" : "2019-09-06T19:01:13Z",
        "updatedAt" : "2019-09-11T16:35:57Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "fac88b87-07b0-434f-83f4-21cc68c090e6",
        "parentId" : "a002ba66-09e9-475d-8c9e-e972d86acfd1",
        "authorId" : "12543f19-3885-429e-8f77-e0f748c56d1f",
        "body" : "We could add a test here, but it is super implementation specific. This is not really the best home for the code, just the most convenient at the moment. All we would test, I think, is that we called allowUpdateOfOffsetLimit? The integration test covers this in a more comprehensive way and doesn't break when we move this code. What do you think?",
        "createdAt" : "2019-09-06T19:30:35Z",
        "updatedAt" : "2019-09-11T16:35:57Z",
        "lastEditedBy" : "12543f19-3885-429e-8f77-e0f748c56d1f",
        "tags" : [
        ]
      },
      {
        "id" : "15b70d7b-e101-408e-8abe-25a163e088c5",
        "parentId" : "a002ba66-09e9-475d-8c9e-e972d86acfd1",
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "> All we would test, I think, is that we called allowUpdateOfOffsetLimit?\r\n\r\nYes, the test should be `shouldUpdateOffsetsLimtOnCommit()`.\r\n\r\n> The integration test covers this in a more comprehensive way and doesn't break when we move this code.\r\n\r\n\"and _doesn't_ break\" -- I guess it should break? The main purpose of the unit test is, that is would be hard to debug the integration test and figure out the root cause why it fails.",
        "createdAt" : "2019-09-10T23:18:25Z",
        "updatedAt" : "2019-09-11T16:35:57Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "b9a57c72-5d0e-4727-8d4f-4f42e2ba3692",
        "parentId" : "a002ba66-09e9-475d-8c9e-e972d86acfd1",
        "authorId" : "12543f19-3885-429e-8f77-e0f748c56d1f",
        "body" : "I added back the StandbyTask tests that will cover this with a much more narrow test - specifically to cover when to update the offset limit. If this gets moved into StandbyTask that test should not fail, provided it was done right. If it's broken in any way that test will flag it and it should be easy to look at the test failure and the changed code to determine the cause.\r\n\r\nDo you think StandbyTaskTest sufficiently addresses your concern?",
        "createdAt" : "2019-09-11T15:53:45Z",
        "updatedAt" : "2019-09-11T16:35:57Z",
        "lastEditedBy" : "12543f19-3885-429e-8f77-e0f748c56d1f",
        "tags" : [
        ]
      }
    ],
    "commit" : "0b14fbdce1f31b17070923325715f68c0238d43d",
    "line" : 11,
    "diffHunk" : "@@ -1,1 +32,36 @@        // we only call commit if commitNeeded is true, which means that we need a way to indicate\n        // that we are eligible for updating the offset limit outside of commit.\n        running.forEach((id, task) -> task.allowUpdateOfOffsetLimit());\n        return committed;\n    }"
  },
  {
    "id" : "23abe1b5-492c-4963-b273-d74c57c6447f",
    "prId" : 7321,
    "prUrl" : "https://github.com/apache/kafka/pull/7321#pullrequestreview-291277775",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e30fc410-db54-46a9-bf05-b7668fd372d3",
        "parentId" : null,
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "I searched the call trace but did not find where we removed the partitions from the restore-consumer, did we do it anywhere?\r\n\r\nBTW after checking the code again I agree with your analysis in another comment that today, we only incrementally add partitions for tasks that have finished initialization (i.e. we've found the log-end offset) and migrating to restoring, BUT we do not decrementally remove partitions, rather just unsubscribe all of them when we finished all the restoring tasks. \r\n\r\nThat also means we effectively tries to only process active tasks after we've completed all restoring tasks, which we could consider refactoring to make this logic clearer in another PR.\r\n\r\nAs for this PR, I think we should make sure: 1) when a standby task is closed, we also remove its partition from the restore-consumer, and 2) as you mentioned, when a new restoring task is added, remove all partitions from the restore-consumer to assign only the restoring task until we've back to process standby tasks.",
        "createdAt" : "2019-09-20T16:57:36Z",
        "updatedAt" : "2019-09-24T05:45:47Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "dc48ec79-65f0-4778-b95a-ac351dcdac44",
        "parentId" : "e30fc410-db54-46a9-bf05-b7668fd372d3",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "NVM I think both are done already :)",
        "createdAt" : "2019-09-20T17:33:56Z",
        "updatedAt" : "2019-09-24T05:45:47Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      }
    ],
    "commit" : "c3935aa6be7cc55911bb4e24332557df24d01f18",
    "line" : 25,
    "diffHunk" : "@@ -1,1 +48,52 @@     * @return the changelogs of all standby tasks that were reassigned\n     */\n    List<TopicPartition> closeRevokedStandbyTasks(final Map<TaskId, Set<TopicPartition>> revokedTasks) {\n        log.debug(\"Closing revoked standby tasks {}\", revokedTasks);\n"
  },
  {
    "id" : "c64465c3-e38b-4daf-bff8-82155bf3c0a8",
    "prId" : 7608,
    "prUrl" : "https://github.com/apache/kafka/pull/7608#pullrequestreview-308822028",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "77215065-fea9-49bf-8afe-2d56849dd682",
        "parentId" : null,
        "authorId" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "body" : "Is this necessary?",
        "createdAt" : "2019-10-29T18:54:32Z",
        "updatedAt" : "2019-10-29T23:41:43Z",
        "lastEditedBy" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "tags" : [
        ]
      },
      {
        "id" : "0fb62411-136b-45a7-b754-8ac2b5a43286",
        "parentId" : "77215065-fea9-49bf-8afe-2d56849dd682",
        "authorId" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "body" : "Yeah actually `removeTaskFromRunning` takes in a `<T extends Task>` type specifically. But it's good cleanup anyway",
        "createdAt" : "2019-10-29T20:45:20Z",
        "updatedAt" : "2019-10-29T23:41:43Z",
        "lastEditedBy" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "tags" : [
        ]
      }
    ],
    "commit" : "01a2aedaf962ef937687f97786c637ed6821efd5",
    "line" : 16,
    "diffHunk" : "@@ -1,1 +64,68 @@        for (final Map.Entry<TaskId, Set<TopicPartition>> entry : revokedTasks.entrySet()) {\n            final TaskId taskId = entry.getKey();\n            final StandbyTask task;\n\n            if (running.containsKey(taskId)) {"
  }
]
[
  {
    "id" : "c899acd2-fcce-4a66-b694-ff4acf53d03e",
    "prId" : 4983,
    "prUrl" : "https://github.com/apache/kafka/pull/4983#pullrequestreview-120819433",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fc84f046-d8ad-49cf-bdbc-5eb7f90a959a",
        "parentId" : null,
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "Probably need rebase here.",
        "createdAt" : "2018-05-11T21:50:54Z",
        "updatedAt" : "2018-06-15T03:52:33Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "31dfaea1-1b42-4f9e-b0cb-026734af1d9d",
        "parentId" : "fc84f046-d8ad-49cf-bdbc-5eb7f90a959a",
        "authorId" : "4c968502-bb3d-46ee-8719-0c0bdbc6242f",
        "body" : "done",
        "createdAt" : "2018-05-16T21:04:04Z",
        "updatedAt" : "2018-06-15T03:52:33Z",
        "lastEditedBy" : "4c968502-bb3d-46ee-8719-0c0bdbc6242f",
        "tags" : [
        ]
      }
    ],
    "commit" : "679568bc781f609b8fdf5b95924a8202c9e3c592",
    "line" : 46,
    "diffHunk" : "@@ -1,1 +124,128 @@\n    private KTable<K, V> doFilter(final Predicate<? super K, ? super V> predicate,\n                                  final MaterializedInternal<K, V, KeyValueStore<Bytes, byte[]>> materializedInternal,\n                                  final boolean filterNot) {\n        final String name = builder.newProcessorName(FILTER_NAME);"
  },
  {
    "id" : "deca9e36-8fd4-459e-9c71-14675c4e0fea",
    "prId" : 4983,
    "prUrl" : "https://github.com/apache/kafka/pull/4983#pullrequestreview-120819463",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d7fc5d5a-ffb1-4bc7-8f65-ae17733e2aaf",
        "parentId" : null,
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "Ditto here.",
        "createdAt" : "2018-05-11T21:51:09Z",
        "updatedAt" : "2018-06-15T03:52:33Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "f7792357-88fe-4208-ae2a-c6aeace1374e",
        "parentId" : "d7fc5d5a-ffb1-4bc7-8f65-ae17733e2aaf",
        "authorId" : "4c968502-bb3d-46ee-8719-0c0bdbc6242f",
        "body" : "done",
        "createdAt" : "2018-05-16T21:04:09Z",
        "updatedAt" : "2018-06-15T03:52:33Z",
        "lastEditedBy" : "4c968502-bb3d-46ee-8719-0c0bdbc6242f",
        "tags" : [
        ]
      }
    ],
    "commit" : "679568bc781f609b8fdf5b95924a8202c9e3c592",
    "line" : 99,
    "diffHunk" : "@@ -1,1 +196,200 @@\n    private <VR> KTable<K, VR> doMapValues(final ValueMapperWithKey<? super K, ? super V, ? extends VR> mapper,\n                                           final MaterializedInternal<K, VR, KeyValueStore<Bytes, byte[]>> materializedInternal) {\n        final String name = builder.newProcessorName(MAPVALUES_NAME);\n"
  },
  {
    "id" : "f723ea38-fbb5-434e-8c85-1aba8293fa3a",
    "prId" : 4983,
    "prUrl" : "https://github.com/apache/kafka/pull/4983#pullrequestreview-126583270",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "53281981-11b8-465a-9b63-fc17a3191bb1",
        "parentId" : null,
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "Why do we pass `null` ?",
        "createdAt" : "2018-05-29T23:58:11Z",
        "updatedAt" : "2018-06-15T03:52:33Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "8a05ba76-12bb-48d8-b953-18139563ecb5",
        "parentId" : "53281981-11b8-465a-9b63-fc17a3191bb1",
        "authorId" : "4c968502-bb3d-46ee-8719-0c0bdbc6242f",
        "body" : "These `KTable` implementations aren't used individually to construct the overall topology but are components of the join merger.",
        "createdAt" : "2018-05-31T00:17:06Z",
        "updatedAt" : "2018-06-15T03:52:33Z",
        "lastEditedBy" : "4c968502-bb3d-46ee-8719-0c0bdbc6242f",
        "tags" : [
        ]
      },
      {
        "id" : "f117a276-228d-49b3-8add-09296b6cd8ee",
        "parentId" : "53281981-11b8-465a-9b63-fc17a3191bb1",
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "Sorry, but cannot follow. Can you elaborate?",
        "createdAt" : "2018-05-31T01:41:44Z",
        "updatedAt" : "2018-06-15T03:52:33Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "5e5c4e23-ffe5-4ee4-8214-3a58c2ca7d07",
        "parentId" : "53281981-11b8-465a-9b63-fc17a3191bb1",
        "authorId" : "4c968502-bb3d-46ee-8719-0c0bdbc6242f",
        "body" : "Sorry, re-reading my original description I realize it is a bit unclear.\r\n\r\nIn most cases the `KStream` or `KTable` instance created is returned to the caller, thus becoming a parent node in the graph and is eventually used to build the topology.  In those cases the graphNode created is passed to the newly created `KStream` or `KTable` instance as the parent graph node for the next operation.\r\n\r\nIn this case,  the two `KTable` instances in question are components in the `KTableKTableJoinMerger` class and never have any child nodes, since they are used by the join merge processor.  There is no graphNode created to pass along as the parent graph node.\r\n\r\nDoes this make sense?",
        "createdAt" : "2018-05-31T22:56:26Z",
        "updatedAt" : "2018-06-15T03:52:33Z",
        "lastEditedBy" : "4c968502-bb3d-46ee-8719-0c0bdbc6242f",
        "tags" : [
        ]
      },
      {
        "id" : "7c80fb6b-eca8-45b6-8dc2-3f803f50749a",
        "parentId" : "53281981-11b8-465a-9b63-fc17a3191bb1",
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "At a high level yes -- still need to think about the details. Thanks.",
        "createdAt" : "2018-06-06T22:50:03Z",
        "updatedAt" : "2018-06-15T03:52:33Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      }
    ],
    "commit" : "679568bc781f609b8fdf5b95924a8202c9e3c592",
    "line" : 249,
    "diffHunk" : "@@ -1,1 +474,478 @@\n        final KTableKTableJoinMerger<K, R> joinMerge = new KTableKTableJoinMerger<>(\n            new KTableImpl<K, V, R>(builder, joinThisName, joinThis, sourceNodes, this.queryableStoreName, false, null),\n            new KTableImpl<K, V1, R>(builder, joinOtherName, joinOther, ((KTableImpl<K, ?, ?>) other).sourceNodes,\n                                     ((KTableImpl<K, ?, ?>) other).queryableStoreName, false, null),"
  },
  {
    "id" : "5c3860a7-a5c3-4e38-b5c3-4c30991865be",
    "prId" : 5521,
    "prUrl" : "https://github.com/apache/kafka/pull/5521#pullrequestreview-147329631",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f5cadbde-b470-45c1-86b8-453f832763bd",
        "parentId" : null,
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "This is another bug that I observed: we should pass in the source nodes list, but instead we are passing the processor name. It was not exposed anywhere since currently we never use the source names of this KGroupedTable.",
        "createdAt" : "2018-08-17T17:24:56Z",
        "updatedAt" : "2018-10-01T04:30:31Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "ee44a33c-e17e-45cb-ac0e-b23db96cbb6c",
        "parentId" : "f5cadbde-b470-45c1-86b8-453f832763bd",
        "authorId" : "4c968502-bb3d-46ee-8719-0c0bdbc6242f",
        "body" : "good catch!",
        "createdAt" : "2018-08-17T19:29:08Z",
        "updatedAt" : "2018-10-01T04:30:31Z",
        "lastEditedBy" : "4c968502-bb3d-46ee-8719-0c0bdbc6242f",
        "tags" : [
        ]
      }
    ],
    "commit" : "1278ae279c9fa20317e55ded8aeb364eab097127",
    "line" : 279,
    "diffHunk" : "@@ -1,1 +580,584 @@            builder,\n            selectName,\n            sourceNodes,\n            serializedInternal.keySerde(),\n            serializedInternal.valueSerde(),"
  },
  {
    "id" : "d5434e0f-fa7e-4db9-9579-a56cdf28e0d5",
    "prId" : 5521,
    "prUrl" : "https://github.com/apache/kafka/pull/5521#pullrequestreview-147298533",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "29b08b8d-7dfa-45d8-be32-6b61a0eebe86",
        "parentId" : null,
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "The above is some cleanup: we do not necessarily create two dummy KTableImpl object to just expose the processor-supplier / enable sending changes in the merge node. Since this is internal classes, I've modified the KTableKTableJoinMerger constructor parameter to simplify the logic.",
        "createdAt" : "2018-08-17T17:26:00Z",
        "updatedAt" : "2018-10-01T04:30:31Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      }
    ],
    "commit" : "1278ae279c9fa20317e55ded8aeb364eab097127",
    "line" : 203,
    "diffHunk" : "@@ -1,1 +512,516 @@        }\n\n        final KTableKTableJoinMerger<K, R> joinMerge = new KTableKTableJoinMerger<>(joinThis, joinOther, internalQueryableName);\n\n        final KTableKTableJoinNode.KTableKTableJoinNodeBuilder<K, Change<V>, Change<V1>, Change<R>> kTableJoinNodeBuilder = KTableKTableJoinNode.kTableKTableJoinNodeBuilder();"
  },
  {
    "id" : "6962310b-2f80-4f76-a93c-dbd3a20d57a2",
    "prId" : 5521,
    "prUrl" : "https://github.com/apache/kafka/pull/5521#pullrequestreview-147402476",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ff19c8b0-e062-463f-8cd8-897c30b3490f",
        "parentId" : null,
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "maybe add comment that we cannot forward `valueSerde` to be consistent?",
        "createdAt" : "2018-08-17T19:10:24Z",
        "updatedAt" : "2018-10-01T04:30:31Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "80fd85e7-e83b-48c4-9a22-4f789f9e6185",
        "parentId" : "ff19c8b0-e062-463f-8cd8-897c30b3490f",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "In this case, we can indeed forward `valSerde` from `Materialized` since the materialized object is for the transformed KTable. Again, if it is null that is also fine passing in, as the key/val Serde objects are null-able.",
        "createdAt" : "2018-08-17T22:16:11Z",
        "updatedAt" : "2018-10-01T04:30:31Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "34ce769f-0674-4a7b-97b4-85b3b44694ad",
        "parentId" : "ff19c8b0-e062-463f-8cd8-897c30b3490f",
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "that's not what I mean -- I meant the \"else\" branch that returns `null` -- even if we get a `valueSerde` from upstream, we cannot forward it, but we can only forward if provided via `Materialized`. This is different to what we can do for the key.",
        "createdAt" : "2018-08-17T22:39:41Z",
        "updatedAt" : "2018-10-01T04:30:31Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "b0709de3-1ad0-44fb-8161-8dc893803905",
        "parentId" : "ff19c8b0-e062-463f-8cd8-897c30b3490f",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "We actually can since the materialized object may contain key/value serdes for the resulted KTable.",
        "createdAt" : "2018-08-17T22:52:19Z",
        "updatedAt" : "2018-10-01T04:30:31Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "53d74246-5cb2-4e33-8d7e-ab4ae3bef838",
        "parentId" : "ff19c8b0-e062-463f-8cd8-897c30b3490f",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "Ignore my comment above: I was not seeing the latest comment from you.",
        "createdAt" : "2018-08-17T22:56:16Z",
        "updatedAt" : "2018-10-01T04:30:31Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "bd0478a9-4ee2-4917-94bf-752c32e85cfe",
        "parentId" : "ff19c8b0-e062-463f-8cd8-897c30b3490f",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "> from upstream, we cannot forward it, but we can only forward if provided via Materialized. This is different to what we can do for the key.\r\n\r\nI see, yes I can add the comment.",
        "createdAt" : "2018-08-17T22:57:27Z",
        "updatedAt" : "2018-10-01T04:30:31Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      }
    ],
    "commit" : "1278ae279c9fa20317e55ded8aeb364eab097127",
    "line" : 119,
    "diffHunk" : "@@ -1,1 +318,322 @@            name,\n            materialized != null && materialized.keySerde() != null ? materialized.keySerde() : keySerde,\n            materialized != null ? materialized.valueSerde() : null,\n            sourceNodes,\n            shouldMaterialize ? materialized.storeName() : this.queryableStoreName,"
  },
  {
    "id" : "5a9b80a7-1dcb-45b7-b4e1-074d23683564",
    "prId" : 5521,
    "prUrl" : "https://github.com/apache/kafka/pull/5521#pullrequestreview-147323574",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ae1e1b76-9ffa-48ff-84b7-6f0f21b0b8dc",
        "parentId" : null,
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "add comment?",
        "createdAt" : "2018-08-17T19:14:28Z",
        "updatedAt" : "2018-10-01T04:30:31Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      }
    ],
    "commit" : "1278ae279c9fa20317e55ded8aeb364eab097127",
    "line" : 238,
    "diffHunk" : "@@ -1,1 +541,545 @@            joinMergeName,\n            materializedInternal != null && materializedInternal.keySerde() != null ? materializedInternal.keySerde() : keySerde,\n            materializedInternal != null ? materializedInternal.valueSerde() : null,\n            allSourceNodes,\n            internalQueryableName,"
  },
  {
    "id" : "38dbd18d-3f44-4155-86f4-79889597ee03",
    "prId" : 5521,
    "prUrl" : "https://github.com/apache/kafka/pull/5521#pullrequestreview-160132436",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fc867970-bf18-4e5b-bb3f-5576d58c9383",
        "parentId" : null,
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "I think these comments would be more helpful if they explained the exceptions.\r\n\r\nIt is generally true on any DSL method that an explicitly provided serde overrides the one passed from the parent.\r\n\r\nBy the way, since the serdes are nullable, null is always the last option (as in the comment on L132, maybe it doesn't need to be stated).\r\n\r\nFor example, in this case, we could simply say `// don't inherit parent value serde, since this operation may change the value type`.",
        "createdAt" : "2018-08-28T17:37:01Z",
        "updatedAt" : "2018-10-01T04:30:31Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      },
      {
        "id" : "073596f1-8bc2-4f91-b35c-0008efeca1ba",
        "parentId" : "fc867970-bf18-4e5b-bb3f-5576d58c9383",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "I want to specifically state the precedence ordering if the serde is explicitly specified from multiple places. But I agree it's better to add the explanation where we would not inherit from parent.",
        "createdAt" : "2018-09-20T22:07:24Z",
        "updatedAt" : "2018-10-01T04:30:31Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "e8d40a76-4e8a-455d-82c8-e2555740e978",
        "parentId" : "fc867970-bf18-4e5b-bb3f-5576d58c9383",
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "Cf my comment above.",
        "createdAt" : "2018-09-30T23:35:25Z",
        "updatedAt" : "2018-10-01T04:30:31Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      }
    ],
    "commit" : "1278ae279c9fa20317e55ded8aeb364eab097127",
    "line" : 90,
    "diffHunk" : "@@ -1,1 +218,222 @@        // don't inherit parent value serde, since this operation may change the value type, more specifically:\n        // we preserve the key following the order of 1) materialized, 2) parent, 3) null\n        // we preserve the value following the order of 1) materialized, 2) null\n        return new KTableImpl<>(\n            name,"
  },
  {
    "id" : "7a237c05-6f58-406b-8130-b901a800ab69",
    "prId" : 5521,
    "prUrl" : "https://github.com/apache/kafka/pull/5521#pullrequestreview-160150059",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "218f400b-8cb8-47d3-aacf-b0bf4e08e72f",
        "parentId" : null,
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "Nit: Why this extensive comment? If you think we need this comment, we should add it to `KStreamImpl` cases, too. It's the same pattern for all operators for which user can provide Serdes.",
        "createdAt" : "2018-09-30T23:33:47Z",
        "updatedAt" : "2018-10-01T04:30:31Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "5fc270ac-587b-4233-a00e-866d6dd682e8",
        "parentId" : "218f400b-8cb8-47d3-aacf-b0bf4e08e72f",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "This was suggested by @vvcephei , I've also added the comment in AbstractStream as stated in the ticket (I do not think this needs to be stated in public APIs as the inheritance rule so far is still best-effort and may be evolved later).",
        "createdAt" : "2018-10-01T01:45:08Z",
        "updatedAt" : "2018-10-01T04:30:31Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "147bd13a-21fa-44e7-a651-96e60be23887",
        "parentId" : "218f400b-8cb8-47d3-aacf-b0bf4e08e72f",
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "I agree that we don't need it in public API, however, only `KTableImpl` has extensive comments -- `KStreamImpl` has very limited comment -- thus, we should add those to `KStreamImpl`, too (for consistency). For example here: https://github.com/apache/kafka/pull/5521/files/e9eecd3b54def3df6b687acd93bd0957fc2687a0#diff-5142e1d4a6410459d6bf6df98828e5afR401 (there are others, too---basically all operators that allow to specify Serdes: through, join, etc)",
        "createdAt" : "2018-10-01T03:55:58Z",
        "updatedAt" : "2018-10-01T04:30:31Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      }
    ],
    "commit" : "1278ae279c9fa20317e55ded8aeb364eab097127",
    "line" : 71,
    "diffHunk" : "@@ -1,1 +143,147 @@        // we can inherit parent key and value serde if user do not provide specific overrides, more specifically:\n        // we preserve the key following the order of 1) materialized, 2) parent\n        // we preserve the value following the order of 1) materialized, 2) parent\n        return new KTableImpl<>(name,\n                                materializedInternal != null && materializedInternal.keySerde() != null ? materializedInternal.keySerde() : keySerde,"
  },
  {
    "id" : "f64a0bfe-afe3-4388-98f2-01dfcd8e1497",
    "prId" : 5521,
    "prUrl" : "https://github.com/apache/kafka/pull/5521#pullrequestreview-160132436",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c732d517-c923-4dcf-98c7-2ae52af1c268",
        "parentId" : null,
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "This comment is more brief than the others -- we should align all comments to be equally expressive.",
        "createdAt" : "2018-09-30T23:39:59Z",
        "updatedAt" : "2018-10-01T04:30:31Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      }
    ],
    "commit" : "1278ae279c9fa20317e55ded8aeb364eab097127",
    "line" : 233,
    "diffHunk" : "@@ -1,1 +537,541 @@        builder.addGraphNode(this.streamsGraphNode, kTableKTableJoinNode);\n\n        // we can inherit parent key serde if user do not provide specific overrides\n        return new KTableImpl<K, Change<R>, R>(\n            joinMergeName,"
  },
  {
    "id" : "36d0b62e-bd01-49b0-9da6-edf3ab4e0708",
    "prId" : 5527,
    "prUrl" : "https://github.com/apache/kafka/pull/5527#pullrequestreview-252549428",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4cacc814-bf0e-42d5-9a98-dd9d5c2b82a8",
        "parentId" : null,
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "Missing `@Override`",
        "createdAt" : "2019-05-06T21:54:17Z",
        "updatedAt" : "2019-10-02T17:56:32Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      },
      {
        "id" : "c2434262-f68a-4c40-8dcb-fbcb3a82bcb3",
        "parentId" : "4cacc814-bf0e-42d5-9a98-dd9d5c2b82a8",
        "authorId" : "d8d11f3d-4fbd-4882-a206-bfece798cdcd",
        "body" : "Done.",
        "createdAt" : "2019-05-14T14:06:58Z",
        "updatedAt" : "2019-10-02T17:56:32Z",
        "lastEditedBy" : "d8d11f3d-4fbd-4882-a206-bfece798cdcd",
        "tags" : [
        ]
      },
      {
        "id" : "64811c91-f888-48c0-b8e0-73a2801eca8b",
        "parentId" : "4cacc814-bf0e-42d5-9a98-dd9d5c2b82a8",
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "Thanks! You can \"resolve\" this comment to clean up the PR.",
        "createdAt" : "2019-06-20T21:38:09Z",
        "updatedAt" : "2019-10-02T17:56:32Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      }
    ],
    "commit" : "6e1b6a1a41c8e05ff009ad988b705baeb42800ad",
    "line" : 94,
    "diffHunk" : "@@ -1,1 +835,839 @@\n    @Override\n    public <VR, KO, VO> KTable<K, VR> join(final KTable<KO, VO> other,\n                                           final Function<V, KO> foreignKeyExtractor,\n                                           final ValueJoiner<V, VO, VR> joiner,"
  },
  {
    "id" : "bcf80bd6-0cb6-41b9-8dae-4aabca77e8bb",
    "prId" : 5527,
    "prUrl" : "https://github.com/apache/kafka/pull/5527#pullrequestreview-289615108",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7e44c046-ebfd-4055-ab41-51bef97ef9d2",
        "parentId" : null,
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "@bellemare @vvcephei @bbejeck \r\n\r\nSeems we need to update `StreamsResetter` to delete those topics, too?",
        "createdAt" : "2019-09-12T23:12:49Z",
        "updatedAt" : "2019-10-02T17:56:32Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "4154688b-c398-47fd-aab1-f53869589081",
        "parentId" : "7e44c046-ebfd-4055-ab41-51bef97ef9d2",
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "Yes, we do. Good catch!",
        "createdAt" : "2019-09-18T00:27:57Z",
        "updatedAt" : "2019-10-02T17:56:32Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      }
    ],
    "commit" : "6e1b6a1a41c8e05ff009ad988b705baeb42800ad",
    "line" : 160,
    "diffHunk" : "@@ -1,1 +901,905 @@\n        final NamedInternal renamed = new NamedInternal(joinName);\n        final String subscriptionTopicName = renamed.suffixWithOrElseGet(\"-subscription-registration\", builder, SUBSCRIPTION_REGISTRATION) + TOPIC_SUFFIX;\n        builder.internalTopologyBuilder.addInternalTopic(subscriptionTopicName);\n        final CombinedKeySchema<KO, K> combinedKeySchema = new CombinedKeySchema<>(subscriptionTopicName, foreignKeySerde, keySerde);"
  },
  {
    "id" : "cb2339c7-f42d-46c6-8661-bb9fc7dfbc92",
    "prId" : 5527,
    "prUrl" : "https://github.com/apache/kafka/pull/5527#pullrequestreview-287750794",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "33cb2693-649f-4e86-8063-914a826756ea",
        "parentId" : null,
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "@bellemare @vvcephei @bbejeck As above.",
        "createdAt" : "2019-09-12T23:13:15Z",
        "updatedAt" : "2019-10-02T17:56:32Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      }
    ],
    "commit" : "6e1b6a1a41c8e05ff009ad988b705baeb42800ad",
    "line" : 246,
    "diffHunk" : "@@ -1,1 +987,991 @@\n\n        final String finalRepartitionTopicName = renamed.suffixWithOrElseGet(\"-subscription-response\", builder, SUBSCRIPTION_RESPONSE) + TOPIC_SUFFIX;\n        builder.internalTopologyBuilder.addInternalTopic(finalRepartitionTopicName);\n"
  },
  {
    "id" : "b83625a1-627d-443e-8914-7b4904f77a39",
    "prId" : 5567,
    "prUrl" : "https://github.com/apache/kafka/pull/5567#pullrequestreview-149479075",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4dfd2386-4b59-4efc-8375-228b96ed0684",
        "parentId" : null,
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "on-the-side fixup of the generic types for groupBy.",
        "createdAt" : "2018-08-24T22:40:59Z",
        "updatedAt" : "2018-09-24T14:28:33Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      }
    ],
    "commit" : "035b26310e76216b502839a6b9f22bf1fc75fee2",
    "line" : 122,
    "diffHunk" : "@@ -1,1 +588,592 @@\n        // select the aggregate key and values (old and new), it would require parent to send old values\n        final ProcessorGraphNode<K, Change<V>> groupByMapNode = new ProcessorGraphNode<>(\n            selectName,\n            processorParameters,"
  },
  {
    "id" : "01d8318d-81f7-4c94-9ca7-12f84e59a644",
    "prId" : 5687,
    "prUrl" : "https://github.com/apache/kafka/pull/5687#pullrequestreview-158294736",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2687d69e-08bb-4668-995d-776d5d4040ab",
        "parentId" : null,
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "This will be fixed in part 3",
        "createdAt" : "2018-09-24T21:04:23Z",
        "updatedAt" : "2018-09-25T17:39:14Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      }
    ],
    "commit" : "b40354ce9f18459f56b1bc8ca8249a52d4ec9cef",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +365,369 @@        final String name = builder.newProcessorName(SUPPRESS_NAME);\n\n        // TODO: follow-up pr to forward the k/v serdes\n        final ProcessorSupplier<K, Change<V>> suppressionSupplier =\n            () -> new KTableSuppressProcessor<>("
  },
  {
    "id" : "9f305499-6fc7-403e-8bda-6079edd7f16a",
    "prId" : 5693,
    "prUrl" : "https://github.com/apache/kafka/pull/5693#pullrequestreview-160339834",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "82b95cd3-fc69-4e9e-b599-c009400617d0",
        "parentId" : null,
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "Could we extend `wrapOrCast` to add a `null` check and return `null` for this case and use it here to make code more readable?",
        "createdAt" : "2018-10-01T04:19:29Z",
        "updatedAt" : "2018-10-02T03:20:17Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "4c0bee59-8350-4344-8ede-55fd6a96898b",
        "parentId" : "82b95cd3-fc69-4e9e-b599-c009400617d0",
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "I can and will.",
        "createdAt" : "2018-10-01T14:56:22Z",
        "updatedAt" : "2018-10-02T03:20:17Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      },
      {
        "id" : "ef5e2aeb-f830-4eba-9f34-abcda2d6d760",
        "parentId" : "82b95cd3-fc69-4e9e-b599-c009400617d0",
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "I've added that check because `context.valueSerde()` (called elsewhere) could return null.\r\n\r\nIf it's ok with you, though, I prefer the current code right here. This code ensures that `valSerde` is of the correct type (notice that no casting is necessary). In general, I think we should avoid casting unless we actually need it, as it makes regressions harder to catch.",
        "createdAt" : "2018-10-01T15:00:59Z",
        "updatedAt" : "2018-10-02T03:20:17Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      }
    ],
    "commit" : "ddd78d9ad6826da2d821584232f2750d022ef34a",
    "line" : 20,
    "diffHunk" : "@@ -1,1 +361,365 @@                buildSuppress(suppressed),\n                keySerde,\n                valSerde == null ? null : new FullChangeSerde<>(valSerde)\n            );\n"
  }
]
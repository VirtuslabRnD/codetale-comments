[
  {
    "id" : "c899acd2-fcce-4a66-b694-ff4acf53d03e",
    "prId" : 4983,
    "prUrl" : "https://github.com/apache/kafka/pull/4983#pullrequestreview-120819433",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fc84f046-d8ad-49cf-bdbc-5eb7f90a959a",
        "parentId" : null,
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "Probably need rebase here.",
        "createdAt" : "2018-05-11T21:50:54Z",
        "updatedAt" : "2018-06-15T03:52:33Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "31dfaea1-1b42-4f9e-b0cb-026734af1d9d",
        "parentId" : "fc84f046-d8ad-49cf-bdbc-5eb7f90a959a",
        "authorId" : "4c968502-bb3d-46ee-8719-0c0bdbc6242f",
        "body" : "done",
        "createdAt" : "2018-05-16T21:04:04Z",
        "updatedAt" : "2018-06-15T03:52:33Z",
        "lastEditedBy" : "4c968502-bb3d-46ee-8719-0c0bdbc6242f",
        "tags" : [
        ]
      }
    ],
    "commit" : "679568bc781f609b8fdf5b95924a8202c9e3c592",
    "line" : 46,
    "diffHunk" : "@@ -1,1 +124,128 @@\n    private KTable<K, V> doFilter(final Predicate<? super K, ? super V> predicate,\n                                  final MaterializedInternal<K, V, KeyValueStore<Bytes, byte[]>> materializedInternal,\n                                  final boolean filterNot) {\n        final String name = builder.newProcessorName(FILTER_NAME);"
  },
  {
    "id" : "deca9e36-8fd4-459e-9c71-14675c4e0fea",
    "prId" : 4983,
    "prUrl" : "https://github.com/apache/kafka/pull/4983#pullrequestreview-120819463",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d7fc5d5a-ffb1-4bc7-8f65-ae17733e2aaf",
        "parentId" : null,
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "Ditto here.",
        "createdAt" : "2018-05-11T21:51:09Z",
        "updatedAt" : "2018-06-15T03:52:33Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "f7792357-88fe-4208-ae2a-c6aeace1374e",
        "parentId" : "d7fc5d5a-ffb1-4bc7-8f65-ae17733e2aaf",
        "authorId" : "4c968502-bb3d-46ee-8719-0c0bdbc6242f",
        "body" : "done",
        "createdAt" : "2018-05-16T21:04:09Z",
        "updatedAt" : "2018-06-15T03:52:33Z",
        "lastEditedBy" : "4c968502-bb3d-46ee-8719-0c0bdbc6242f",
        "tags" : [
        ]
      }
    ],
    "commit" : "679568bc781f609b8fdf5b95924a8202c9e3c592",
    "line" : 99,
    "diffHunk" : "@@ -1,1 +196,200 @@\n    private <VR> KTable<K, VR> doMapValues(final ValueMapperWithKey<? super K, ? super V, ? extends VR> mapper,\n                                           final MaterializedInternal<K, VR, KeyValueStore<Bytes, byte[]>> materializedInternal) {\n        final String name = builder.newProcessorName(MAPVALUES_NAME);\n"
  },
  {
    "id" : "f723ea38-fbb5-434e-8c85-1aba8293fa3a",
    "prId" : 4983,
    "prUrl" : "https://github.com/apache/kafka/pull/4983#pullrequestreview-126583270",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "53281981-11b8-465a-9b63-fc17a3191bb1",
        "parentId" : null,
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "Why do we pass `null` ?",
        "createdAt" : "2018-05-29T23:58:11Z",
        "updatedAt" : "2018-06-15T03:52:33Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "8a05ba76-12bb-48d8-b953-18139563ecb5",
        "parentId" : "53281981-11b8-465a-9b63-fc17a3191bb1",
        "authorId" : "4c968502-bb3d-46ee-8719-0c0bdbc6242f",
        "body" : "These `KTable` implementations aren't used individually to construct the overall topology but are components of the join merger.",
        "createdAt" : "2018-05-31T00:17:06Z",
        "updatedAt" : "2018-06-15T03:52:33Z",
        "lastEditedBy" : "4c968502-bb3d-46ee-8719-0c0bdbc6242f",
        "tags" : [
        ]
      },
      {
        "id" : "f117a276-228d-49b3-8add-09296b6cd8ee",
        "parentId" : "53281981-11b8-465a-9b63-fc17a3191bb1",
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "Sorry, but cannot follow. Can you elaborate?",
        "createdAt" : "2018-05-31T01:41:44Z",
        "updatedAt" : "2018-06-15T03:52:33Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "5e5c4e23-ffe5-4ee4-8214-3a58c2ca7d07",
        "parentId" : "53281981-11b8-465a-9b63-fc17a3191bb1",
        "authorId" : "4c968502-bb3d-46ee-8719-0c0bdbc6242f",
        "body" : "Sorry, re-reading my original description I realize it is a bit unclear.\r\n\r\nIn most cases the `KStream` or `KTable` instance created is returned to the caller, thus becoming a parent node in the graph and is eventually used to build the topology.  In those cases the graphNode created is passed to the newly created `KStream` or `KTable` instance as the parent graph node for the next operation.\r\n\r\nIn this case,  the two `KTable` instances in question are components in the `KTableKTableJoinMerger` class and never have any child nodes, since they are used by the join merge processor.  There is no graphNode created to pass along as the parent graph node.\r\n\r\nDoes this make sense?",
        "createdAt" : "2018-05-31T22:56:26Z",
        "updatedAt" : "2018-06-15T03:52:33Z",
        "lastEditedBy" : "4c968502-bb3d-46ee-8719-0c0bdbc6242f",
        "tags" : [
        ]
      },
      {
        "id" : "7c80fb6b-eca8-45b6-8dc2-3f803f50749a",
        "parentId" : "53281981-11b8-465a-9b63-fc17a3191bb1",
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "At a high level yes -- still need to think about the details. Thanks.",
        "createdAt" : "2018-06-06T22:50:03Z",
        "updatedAt" : "2018-06-15T03:52:33Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      }
    ],
    "commit" : "679568bc781f609b8fdf5b95924a8202c9e3c592",
    "line" : 249,
    "diffHunk" : "@@ -1,1 +474,478 @@\n        final KTableKTableJoinMerger<K, R> joinMerge = new KTableKTableJoinMerger<>(\n            new KTableImpl<K, V, R>(builder, joinThisName, joinThis, sourceNodes, this.queryableStoreName, false, null),\n            new KTableImpl<K, V1, R>(builder, joinOtherName, joinOther, ((KTableImpl<K, ?, ?>) other).sourceNodes,\n                                     ((KTableImpl<K, ?, ?>) other).queryableStoreName, false, null),"
  }
]
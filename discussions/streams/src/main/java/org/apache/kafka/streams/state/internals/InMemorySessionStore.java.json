[
  {
    "id" : "a968e019-9a2e-4982-811b-06b94b446999",
    "prId" : 6525,
    "prUrl" : "https://github.com/apache/kafka/pull/6525#pullrequestreview-225866353",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ce8cac49-dd5d-4e60-abf8-3ecd8e2cc3bc",
        "parentId" : null,
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "This has been a point of debate in the past, and not everyone agrees with me, but I'll bring it up just once because it's my honest feedback...\r\n\r\nThis style of having one-sided conditionals and early returns generally makes it harder to trace the flow of execution. It's more verbose, but also more resistant to bugs to prefer keeping both `if` and `else` branches (or using ternary operators), and (again, generally) not returning early or falling though to a catch-all return at the end of a method.\r\n\r\nThis feedback applies elsewhere in this PR as well.",
        "createdAt" : "2019-04-11T23:51:40Z",
        "updatedAt" : "2019-04-24T16:45:06Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      },
      {
        "id" : "a700ff37-7295-4fe0-a5e7-ca0fff128812",
        "parentId" : "ce8cac49-dd5d-4e60-abf8-3ecd8e2cc3bc",
        "authorId" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "body" : "Hm, I see your point. I think this is unavoidable in places but some other methods (hasNext) can be cleaned up",
        "createdAt" : "2019-04-12T01:43:10Z",
        "updatedAt" : "2019-04-24T16:45:06Z",
        "lastEditedBy" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "tags" : [
        ]
      }
    ],
    "commit" : "13682aaca862c3bc3c99280ee07870ccae89c07f",
    "line" : 147,
    "diffHunk" : "@@ -1,1 +145,149 @@            }\n        }\n        return null;\n    }\n"
  },
  {
    "id" : "ab343dd9-0612-4f7c-acd0-146914764206",
    "prId" : 7132,
    "prUrl" : "https://github.com/apache/kafka/pull/7132#pullrequestreview-268160553",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d8086d08-d40f-4567-aecf-0f2f6b8a27ec",
        "parentId" : null,
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "How could `keyMap` be `null`, ie, why would we call `remove()`for a non-existing session (at least in the DSL)?\r\n\r\nNot saying that the fix does not make sense, I am just wondering if we need an additional fix for the DSL?",
        "createdAt" : "2019-07-29T23:48:12Z",
        "updatedAt" : "2019-07-30T17:48:46Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "79e21261-21b2-43cd-85cb-eb3eaa42c397",
        "parentId" : "d8086d08-d40f-4567-aecf-0f2f6b8a27ec",
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "Well. Thinking about it twice, during restore maybe? Tombstone are preserved longer in the changelog, hence, for a deleted session we only have the tombstone. On restore, we would never see and \"insert\" but only the delete.\r\n\r\nMaybe worth double checking in the DSL code anyway.",
        "createdAt" : "2019-07-29T23:50:10Z",
        "updatedAt" : "2019-07-30T17:48:46Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "99a007bc-407c-4ed6-bc5b-ebf0446ed587",
        "parentId" : "d8086d08-d40f-4567-aecf-0f2f6b8a27ec",
        "authorId" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "body" : "I assume a tombstone was being restored, where the corresponding put was already cleaned up from the changelog?",
        "createdAt" : "2019-07-29T23:51:15Z",
        "updatedAt" : "2019-07-30T17:48:46Z",
        "lastEditedBy" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "tags" : [
        ]
      },
      {
        "id" : "c8ce1c90-c6c1-4e1b-982b-00c9455f1a18",
        "parentId" : "d8086d08-d40f-4567-aecf-0f2f6b8a27ec",
        "authorId" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "body" : "Answered yourself quicker than me. But ok, I'll look around regardless",
        "createdAt" : "2019-07-29T23:52:12Z",
        "updatedAt" : "2019-07-30T17:48:46Z",
        "lastEditedBy" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "tags" : [
        ]
      },
      {
        "id" : "37a16030-1377-44cb-ae57-7e492ea25016",
        "parentId" : "d8086d08-d40f-4567-aecf-0f2f6b8a27ec",
        "authorId" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "body" : "I'm fairly confident the only affected case is on the restore path when the changelog contains a tombstone that outlived its corresponding \"put\" -- during normal processing, if the delete arrives after the key has already been cleaned up it will be dropped as a late record anyways. Assuming we aren't accidentally sending double tombstones anywhere.",
        "createdAt" : "2019-07-30T05:19:09Z",
        "updatedAt" : "2019-07-30T17:48:46Z",
        "lastEditedBy" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "tags" : [
        ]
      }
    ],
    "commit" : "23303c20f3c74afb97767c5941d2ffffcee450cd",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +121,125 @@    public void remove(final Windowed<Bytes> sessionKey) {\n        final ConcurrentNavigableMap<Bytes, ConcurrentNavigableMap<Long, byte[]>> keyMap = endTimeMap.get(sessionKey.window().end());\n        if (keyMap == null) {\n            return;\n        }"
  },
  {
    "id" : "9e6814f6-065d-4e70-930b-250716aa8b23",
    "prId" : 7416,
    "prUrl" : "https://github.com/apache/kafka/pull/7416#pullrequestreview-296093410",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e33ddd5d-b76e-405c-90e9-91c9beb80592",
        "parentId" : null,
        "authorId" : "4c968502-bb3d-46ee-8719-0c0bdbc6242f",
        "body" : "as above",
        "createdAt" : "2019-10-01T16:47:20Z",
        "updatedAt" : "2019-10-04T08:23:54Z",
        "lastEditedBy" : "4c968502-bb3d-46ee-8719-0c0bdbc6242f",
        "tags" : [
        ]
      },
      {
        "id" : "44c89c94-d41e-4eeb-98a9-97accccb54b6",
        "parentId" : "e33ddd5d-b76e-405c-90e9-91c9beb80592",
        "authorId" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "body" : "Also fixed in PR #7429.",
        "createdAt" : "2019-10-02T09:48:51Z",
        "updatedAt" : "2019-10-04T08:23:54Z",
        "lastEditedBy" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "tags" : [
        ]
      }
    ],
    "commit" : "ab3c0436cf659dd6f76b2b6b5360d327bad385bb",
    "line" : 16,
    "diffHunk" : "@@ -1,1 +88,92 @@            expiredRecordSensor,\n            \"stream-\" + metricScope + \"-metrics\",\n            metrics.tagMap(threadId, \"task-id\", taskName, metricScope + \"-id\", name()),\n            EXPIRED_WINDOW_RECORD_DROP\n        );"
  },
  {
    "id" : "036bf222-1150-437f-a09a-57817d96ee27",
    "prId" : 9396,
    "prUrl" : "https://github.com/apache/kafka/pull/9396#pullrequestreview-505010286",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f2610983-a1d9-4e33-b8e6-1c31c0cc605f",
        "parentId" : null,
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "As a testament to `MockProcessorContextStateStoreTest`, it actually found this bug. I had overlooked this usage while making the other root stores context-implementation agnostic in the last PR.",
        "createdAt" : "2020-10-08T17:51:57Z",
        "updatedAt" : "2020-10-08T18:12:54Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      }
    ],
    "commit" : "428c6f32f056fd791f8d676a5febc7f5f8de654f",
    "line" : 19,
    "diffHunk" : "@@ -1,1 +81,85 @@        // The provided context is not required to implement InternalProcessorContext,\n        // If it doesn't, we can't record this metric.\n        if (context instanceof InternalProcessorContext) {\n            this.context = (InternalProcessorContext) context;\n            final StreamsMetricsImpl metrics = this.context.metrics();"
  }
]
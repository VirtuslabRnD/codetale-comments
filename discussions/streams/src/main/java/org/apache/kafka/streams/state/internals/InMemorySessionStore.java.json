[
  {
    "id" : "a968e019-9a2e-4982-811b-06b94b446999",
    "prId" : 6525,
    "prUrl" : "https://github.com/apache/kafka/pull/6525#pullrequestreview-225866353",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ce8cac49-dd5d-4e60-abf8-3ecd8e2cc3bc",
        "parentId" : null,
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "This has been a point of debate in the past, and not everyone agrees with me, but I'll bring it up just once because it's my honest feedback...\r\n\r\nThis style of having one-sided conditionals and early returns generally makes it harder to trace the flow of execution. It's more verbose, but also more resistant to bugs to prefer keeping both `if` and `else` branches (or using ternary operators), and (again, generally) not returning early or falling though to a catch-all return at the end of a method.\r\n\r\nThis feedback applies elsewhere in this PR as well.",
        "createdAt" : "2019-04-11T23:51:40Z",
        "updatedAt" : "2019-04-24T16:45:06Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      },
      {
        "id" : "a700ff37-7295-4fe0-a5e7-ca0fff128812",
        "parentId" : "ce8cac49-dd5d-4e60-abf8-3ecd8e2cc3bc",
        "authorId" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "body" : "Hm, I see your point. I think this is unavoidable in places but some other methods (hasNext) can be cleaned up",
        "createdAt" : "2019-04-12T01:43:10Z",
        "updatedAt" : "2019-04-24T16:45:06Z",
        "lastEditedBy" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "tags" : [
        ]
      }
    ],
    "commit" : "13682aaca862c3bc3c99280ee07870ccae89c07f",
    "line" : 147,
    "diffHunk" : "@@ -1,1 +145,149 @@            }\n        }\n        return null;\n    }\n"
  },
  {
    "id" : "ab343dd9-0612-4f7c-acd0-146914764206",
    "prId" : 7132,
    "prUrl" : "https://github.com/apache/kafka/pull/7132#pullrequestreview-268160553",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d8086d08-d40f-4567-aecf-0f2f6b8a27ec",
        "parentId" : null,
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "How could `keyMap` be `null`, ie, why would we call `remove()`for a non-existing session (at least in the DSL)?\r\n\r\nNot saying that the fix does not make sense, I am just wondering if we need an additional fix for the DSL?",
        "createdAt" : "2019-07-29T23:48:12Z",
        "updatedAt" : "2019-07-30T17:48:46Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "79e21261-21b2-43cd-85cb-eb3eaa42c397",
        "parentId" : "d8086d08-d40f-4567-aecf-0f2f6b8a27ec",
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "Well. Thinking about it twice, during restore maybe? Tombstone are preserved longer in the changelog, hence, for a deleted session we only have the tombstone. On restore, we would never see and \"insert\" but only the delete.\r\n\r\nMaybe worth double checking in the DSL code anyway.",
        "createdAt" : "2019-07-29T23:50:10Z",
        "updatedAt" : "2019-07-30T17:48:46Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "99a007bc-407c-4ed6-bc5b-ebf0446ed587",
        "parentId" : "d8086d08-d40f-4567-aecf-0f2f6b8a27ec",
        "authorId" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "body" : "I assume a tombstone was being restored, where the corresponding put was already cleaned up from the changelog?",
        "createdAt" : "2019-07-29T23:51:15Z",
        "updatedAt" : "2019-07-30T17:48:46Z",
        "lastEditedBy" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "tags" : [
        ]
      },
      {
        "id" : "c8ce1c90-c6c1-4e1b-982b-00c9455f1a18",
        "parentId" : "d8086d08-d40f-4567-aecf-0f2f6b8a27ec",
        "authorId" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "body" : "Answered yourself quicker than me. But ok, I'll look around regardless",
        "createdAt" : "2019-07-29T23:52:12Z",
        "updatedAt" : "2019-07-30T17:48:46Z",
        "lastEditedBy" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "tags" : [
        ]
      },
      {
        "id" : "37a16030-1377-44cb-ae57-7e492ea25016",
        "parentId" : "d8086d08-d40f-4567-aecf-0f2f6b8a27ec",
        "authorId" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "body" : "I'm fairly confident the only affected case is on the restore path when the changelog contains a tombstone that outlived its corresponding \"put\" -- during normal processing, if the delete arrives after the key has already been cleaned up it will be dropped as a late record anyways. Assuming we aren't accidentally sending double tombstones anywhere.",
        "createdAt" : "2019-07-30T05:19:09Z",
        "updatedAt" : "2019-07-30T17:48:46Z",
        "lastEditedBy" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "tags" : [
        ]
      }
    ],
    "commit" : "23303c20f3c74afb97767c5941d2ffffcee450cd",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +121,125 @@    public void remove(final Windowed<Bytes> sessionKey) {\n        final ConcurrentNavigableMap<Bytes, ConcurrentNavigableMap<Long, byte[]>> keyMap = endTimeMap.get(sessionKey.window().end());\n        if (keyMap == null) {\n            return;\n        }"
  }
]
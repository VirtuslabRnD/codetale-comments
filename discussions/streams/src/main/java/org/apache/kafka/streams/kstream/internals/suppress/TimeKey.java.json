[
  {
    "id" : "f5d5611c-5d14-4d33-b99e-6d8d0b5ccdff",
    "prId" : 5693,
    "prUrl" : "https://github.com/apache/kafka/pull/5693#pullrequestreview-160151744",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "119d1307-75bb-4808-8bbf-97b55e7b92a4",
        "parentId" : null,
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "aka, ordering of keys that share a timestamp is arbitrarily. If anyone cares, we can do \"better\" by requiring K to be Comparable (but I don't think anyone should care, so I kept it simple)",
        "createdAt" : "2018-09-25T23:31:02Z",
        "updatedAt" : "2018-10-02T03:20:17Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      },
      {
        "id" : "19d982b9-bdeb-44c7-958e-84a0c10ca722",
        "parentId" : "119d1307-75bb-4808-8bbf-97b55e7b92a4",
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "While I think, it's semantically fine, it might be nice to get the same eviction behavior for a reprocessing use-case... I am also realizing, that `TimeKey` is actually always used with `Bytes` -- thus, I would recommend to remove the generic type, and exploit that `Bytes` implements `Comparable` already.",
        "createdAt" : "2018-10-01T05:22:47Z",
        "updatedAt" : "2018-10-02T03:20:17Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      }
    ],
    "commit" : "ddd78d9ad6826da2d821584232f2750d022ef34a",
    "line" : 56,
    "diffHunk" : "@@ -1,1 +54,58 @@    @Override\n    public int compareTo(final TimeKey o) {\n        // ordering of keys within a time uses hashCode.\n        final int timeComparison = Long.compare(time, o.time);\n        return timeComparison == 0 ? key.compareTo(o.key) : timeComparison;"
  }
]
[
  {
    "id" : "4bdcd2d0-4feb-4ed4-bd54-a8ed1beeb9a9",
    "prId" : 6667,
    "prUrl" : "https://github.com/apache/kafka/pull/6667#pullrequestreview-234182364",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5c91c985-ebc9-45b9-abc5-67ab8d0f8f40",
        "parentId" : null,
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "Fix bug that was exposed with this PR.",
        "createdAt" : "2019-05-02T21:22:22Z",
        "updatedAt" : "2019-05-11T12:26:17Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "aa715c9a-56e0-480d-9161-d346fc841904",
        "parentId" : "5c91c985-ebc9-45b9-abc5-67ab8d0f8f40",
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "Oof. Good catch!",
        "createdAt" : "2019-05-06T20:39:37Z",
        "updatedAt" : "2019-05-11T12:26:17Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      }
    ],
    "commit" : "21e5dee3c8c50f5d8d88ce0f1b78b351e30768ba",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +52,56 @@            ProcessorStateManager.storeChangelogTopic(context.applicationId(), name()),\n            keySerde == null ? (Serde<K>) context.keySerde() : keySerde,\n            valueSerde == null ? new ValueAndTimestampSerde<>((Serde<V>) context.valueSerde()) : valueSerde);\n    }\n}"
  },
  {
    "id" : "708adcf1-69aa-4ca1-95f2-8383ef751789",
    "prId" : 8254,
    "prUrl" : "https://github.com/apache/kafka/pull/8254#pullrequestreview-391808835",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bb31a128-6069-4050-b36e-6040ce91ec23",
        "parentId" : null,
        "authorId" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "body" : "req: Please add unit tests for this method.",
        "createdAt" : "2020-04-07T10:43:38Z",
        "updatedAt" : "2020-05-12T18:10:57Z",
        "lastEditedBy" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "tags" : [
        ]
      },
      {
        "id" : "e733079d-bcb9-4555-9fbd-951021832e6c",
        "parentId" : "bb31a128-6069-4050-b36e-6040ce91ec23",
        "authorId" : "32d43f1c-0232-4c2f-9548-9c3dfd6f181a",
        "body" : "Done.",
        "createdAt" : "2020-04-11T23:50:01Z",
        "updatedAt" : "2020-05-12T18:10:57Z",
        "lastEditedBy" : "32d43f1c-0232-4c2f-9548-9c3dfd6f181a",
        "tags" : [
        ]
      }
    ],
    "commit" : "2a3d93dbcd9324ad3a4393541a86258df61722de",
    "line" : 29,
    "diffHunk" : "@@ -1,1 +58,62 @@    }\n\n    public RawAndDeserializedValue<V> getWithBinary(final K key) {\n        try {\n            return maybeMeasureLatency(() -> { "
  },
  {
    "id" : "f1fb425d-8339-4bf7-a6cc-0621eaab07c1",
    "prId" : 8254,
    "prUrl" : "https://github.com/apache/kafka/pull/8254#pullrequestreview-391808832",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "00db6ba6-becb-4846-9edd-1076e5293210",
        "parentId" : null,
        "authorId" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "body" : "req: Please add unit tests for this method.",
        "createdAt" : "2020-04-07T10:44:18Z",
        "updatedAt" : "2020-05-12T18:10:57Z",
        "lastEditedBy" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "tags" : [
        ]
      },
      {
        "id" : "612699b1-3c53-426a-be65-c93b0a514c21",
        "parentId" : "00db6ba6-becb-4846-9edd-1076e5293210",
        "authorId" : "32d43f1c-0232-4c2f-9548-9c3dfd6f181a",
        "body" : "Done.",
        "createdAt" : "2020-04-11T23:49:58Z",
        "updatedAt" : "2020-05-12T18:10:57Z",
        "lastEditedBy" : "32d43f1c-0232-4c2f-9548-9c3dfd6f181a",
        "tags" : [
        ]
      }
    ],
    "commit" : "2a3d93dbcd9324ad3a4393541a86258df61722de",
    "line" : 41,
    "diffHunk" : "@@ -1,1 +70,74 @@    }\n\n    public boolean putIfDifferentValues(final K key,\n                                        final ValueAndTimestamp<V> newValue,\n                                        final byte[] oldSerializedValue) {"
  },
  {
    "id" : "8628eac2-8f9d-4389-aad3-2268d2d4ef82",
    "prId" : 8254,
    "prUrl" : "https://github.com/apache/kafka/pull/8254#pullrequestreview-411608013",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8c282d3a-83f6-4c45-a957-984a3c61a9ea",
        "parentId" : null,
        "authorId" : "5b2b5fa0-0fb4-4e52-a4f9-9d4318b5ae5d",
        "body" : "@ConcurrencyPractitioner @vvcephei I'm trying to understand this to debug some broken tests in ksql. Couple questions:\r\n\r\nWhen the timestamp of the newer value is lower (ignoring the value), why do we want to put the new value into the store? Surely the store should have the value with the newer timestamp? Otherwise we could wind up with a corrupt store.\r\n\r\nDon't we still want to put the value in the store (even if we don't forward it on to the next context) if the values are the same but the timestamp is newer? Otherwise if we get an out-of-order update with a different value, but a timestamp in between the rows with the same value, we'd incorrectly put that value into the store, e.g. the following updates:\r\n\r\nTS: 1, K: X, V: A\r\nTS: 3, K: X, V: A\r\nTS: 2, K: X, V: B\r\n\r\nwould result in the table containing `K: X, V: B`, which is wrong.",
        "createdAt" : "2020-05-14T07:57:11Z",
        "updatedAt" : "2020-05-14T08:01:20Z",
        "lastEditedBy" : "5b2b5fa0-0fb4-4e52-a4f9-9d4318b5ae5d",
        "tags" : [
        ]
      },
      {
        "id" : "91558084-e7e3-4d9d-a71a-b7789c96bbe5",
        "parentId" : "8c282d3a-83f6-4c45-a957-984a3c61a9ea",
        "authorId" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "body" : "> Why when the timestamp of the newer value is lower, do we want to put the new value into the store? Surely the store should have the value with the newer timestamp? Otherwise we could wind up with a corrupt store.\r\n\r\nThis behavior was there also before this PR. If a out-of-order record is encountered, a log message was written, but the record was nevertheless put into the state store (cf. https://github.com/apache/kafka/blob/7624e6247984223901aa34d7b7c2789c3e1d0c3f/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KTableSource.java#L122). The only thing that changed is that if the serialized value of the new record is equal to the serialized value of the old value and the timestamp of the new record is equal or newer, we drop the record because it is a idempotent update.\r\nCould you elaborate on why a store should get corrupted because of this? \r\n\r\n> would result in the table containing K: X, V: B, which is wrong.\r\n\r\nAs said above, this behavior should not have been changed.",
        "createdAt" : "2020-05-14T08:46:23Z",
        "updatedAt" : "2020-05-14T08:51:04Z",
        "lastEditedBy" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "tags" : [
        ]
      },
      {
        "id" : "63aff1b2-1f84-45f5-abc7-67a7930979ce",
        "parentId" : "8c282d3a-83f6-4c45-a957-984a3c61a9ea",
        "authorId" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "body" : "> Don't we still want to put the value in the store (even if we don't forward it on to the next context) if the values are the same but the timestamp is newer?\r\n\r\nIf we just put the value in the store but did not forward it, then the store would actually be corrupted, because the local state would not be consistent with downstream anymore.\r\n\r\nNot putting a record with the same value but a newer timestamp in the store and not forwarding it was the main point of this KIP.",
        "createdAt" : "2020-05-14T09:06:31Z",
        "updatedAt" : "2020-05-14T09:08:10Z",
        "lastEditedBy" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "tags" : [
        ]
      }
    ],
    "commit" : "2a3d93dbcd9324ad3a4393541a86258df61722de",
    "line" : 51,
    "diffHunk" : "@@ -1,1 +80,84 @@                        return false;\n                    } else {\n                        wrapped().put(keyBytes(key), newSerializedValue);\n                        return true;\n                    }"
  }
]
[
  {
    "id" : "c1df9b6c-d320-4de5-bb34-7734371f6758",
    "prId" : 4955,
    "prUrl" : "https://github.com/apache/kafka/pull/4955#pullrequestreview-120876375",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b6b6aa54-aa33-4b71-85be-eaee0a73b10e",
        "parentId" : null,
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "Do we need to update `equals` and `hashCode`? (not sure)",
        "createdAt" : "2018-05-16T04:02:16Z",
        "updatedAt" : "2018-05-22T16:57:39Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "fb602aab-f0e7-489b-8920-a22f74ce0c32",
        "parentId" : "b6b6aa54-aa33-4b71-85be-eaee0a73b10e",
        "authorId" : "f58052af-021e-47d1-bcb5-e22f46383a12",
        "body" : "I think so. I think there is not reason to have the same records, from the same cluster with different headers. Adding it.",
        "createdAt" : "2018-05-17T02:06:32Z",
        "updatedAt" : "2018-05-22T16:57:39Z",
        "lastEditedBy" : "f58052af-021e-47d1-bcb5-e22f46383a12",
        "tags" : [
        ]
      }
    ],
    "commit" : "19db8d2e3a8dfb123eba9ea6637938017a4324aa",
    "line" : 40,
    "diffHunk" : "@@ -1,1 +70,74 @@\n    @Override\n    public boolean equals(final Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;"
  },
  {
    "id" : "a5f554da-0719-4f97-bd54-9f539cbeba63",
    "prId" : 5693,
    "prUrl" : "https://github.com/apache/kafka/pull/5693#pullrequestreview-160561804",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5c9b4db3-647b-49bf-94f0-a701b02e6a16",
        "parentId" : null,
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "Each Java object has a natural overhead -- might be worth to add this here? would need to search the internet how many bytes, however, we would have it for `ProcessorRecordContext` itself, as well as `topic`, `headers` (including it's nested `Header` objects).",
        "createdAt" : "2018-10-01T05:30:19Z",
        "updatedAt" : "2018-10-02T03:20:17Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "47dab7f1-3981-4ffd-9cc5-b9a1690ddfb6",
        "parentId" : "5c9b4db3-647b-49bf-94f0-a701b02e6a16",
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "I agree that this is an under-estimate, but I don't think there's much point in being exact.\r\nThe overhead is dependent on the JVM implementation, so we'd have to detect the JVM and maintain a mapping for each different implementation. Even then, we don't know how much extra memory we're using in the various garbage collectors, of which there are now three different implementations in the Oracle JDK alone...\r\n\r\nI'd rather just make the best effort we reasonably can to live more-or-less within the desired boundary. For example, storing the `byte[]` value is much closer than storing the object. But beyond that, we get into diminishing returns for quickly increasing complexity.\r\n",
        "createdAt" : "2018-10-01T17:44:39Z",
        "updatedAt" : "2018-10-02T03:20:18Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      },
      {
        "id" : "fc93cd19-dffc-41e8-bae4-8a7d1dfc4e5e",
        "parentId" : "5c9b4db3-647b-49bf-94f0-a701b02e6a16",
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "Ack. That's fair. The existing caches also use rough estimates only. (Might be interesting how much we are off though... But this could be a follow up improvement.)",
        "createdAt" : "2018-10-02T00:08:26Z",
        "updatedAt" : "2018-10-02T03:20:18Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "ebc5742b-12c7-4fd0-b816-93ba5d3c6afe",
        "parentId" : "5c9b4db3-647b-49bf-94f0-a701b02e6a16",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "Makes sense.",
        "createdAt" : "2018-10-02T04:13:10Z",
        "updatedAt" : "2018-10-02T04:13:10Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      }
    ],
    "commit" : "ddd78d9ad6826da2d821584232f2750d022ef34a",
    "line" : 12,
    "diffHunk" : "@@ -1,1 +80,84 @@    }\n\n    public long sizeBytes() {\n        long size = 0L;\n        size += 8; // value.context.timestamp"
  },
  {
    "id" : "69fa0918-620f-4400-9430-5c31c398e7b4",
    "prId" : 5693,
    "prUrl" : "https://github.com/apache/kafka/pull/5693#pullrequestreview-160409418",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "51d338cc-5e13-40b2-af8c-b88cf3ee7e1b",
        "parentId" : null,
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "a `String` also store the length (it's a `char[]` internally) -- should we add 4 more bytes here?\r\n\r\nAlso, has a `char[]` similar overhead than a regular object?",
        "createdAt" : "2018-10-01T05:32:06Z",
        "updatedAt" : "2018-10-02T03:20:17Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "b554597e-351b-4cd0-b87f-95bf473789df",
        "parentId" : "51d338cc-5e13-40b2-af8c-b88cf3ee7e1b",
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "I believe arrays also store their types. But again, we are getting into JVM implementation details. There are too many JVM implementations for us to be expected to worry about this, IMHO.",
        "createdAt" : "2018-10-01T17:46:16Z",
        "updatedAt" : "2018-10-02T03:20:18Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      }
    ],
    "commit" : "ddd78d9ad6826da2d821584232f2750d022ef34a",
    "line" : 17,
    "diffHunk" : "@@ -1,1 +85,89 @@        size += 8; // value.context.offset\n        if (topic != null) {\n            size += topic.toCharArray().length;\n        }\n        size += 4; // partition"
  },
  {
    "id" : "4fa7617b-d937-4e84-918f-e17fdf6262f2",
    "prId" : 6484,
    "prUrl" : "https://github.com/apache/kafka/pull/6484#pullrequestreview-217558001",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4c6acfc6-9679-408d-9e9c-fd604858449c",
        "parentId" : null,
        "authorId" : "4c968502-bb3d-46ee-8719-0c0bdbc6242f",
        "body" : "Add a check here that `header.key()` doesn't return `null`?",
        "createdAt" : "2019-03-21T18:08:58Z",
        "updatedAt" : "2019-03-21T18:19:43Z",
        "lastEditedBy" : "4c968502-bb3d-46ee-8719-0c0bdbc6242f",
        "tags" : [
        ]
      },
      {
        "id" : "1bf0feda-7caf-4e4c-afb6-21dfe17d8b26",
        "parentId" : "4c6acfc6-9679-408d-9e9c-fd604858449c",
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "The key cannot be `null` -- compare https://github.com/apache/kafka/blob/trunk/clients/src/main/java/org/apache/kafka/common/header/internals/RecordHeader.java",
        "createdAt" : "2019-03-22T01:01:44Z",
        "updatedAt" : "2019-03-22T01:01:45Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "90cf8f92-8a6a-4436-bab2-0acaa41ec4ba",
        "parentId" : "4c6acfc6-9679-408d-9e9c-fd604858449c",
        "authorId" : "4c968502-bb3d-46ee-8719-0c0bdbc6242f",
        "body" : "Thanks for the clarification.",
        "createdAt" : "2019-03-22T01:16:45Z",
        "updatedAt" : "2019-03-22T01:16:45Z",
        "lastEditedBy" : "4c968502-bb3d-46ee-8719-0c0bdbc6242f",
        "tags" : [
        ]
      }
    ],
    "commit" : "f587e6cc1433697abc3b294efc3b1970338c90d5",
    "line" : 3,
    "diffHunk" : "@@ -1,1 +90,94 @@        if (headers != null) {\n            for (final Header header : headers) {\n                size += header.key().toCharArray().length;\n                final byte[] value = header.value();\n                if (value != null) {"
  },
  {
    "id" : "bba937d0-6d2d-46ff-8461-41580c72bab0",
    "prId" : 6536,
    "prUrl" : "https://github.com/apache/kafka/pull/6536#pullrequestreview-228859727",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2ab02cc5-4ebf-4bd6-a13d-2a3c3526683d",
        "parentId" : null,
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "How could `topic` be `null`?",
        "createdAt" : "2019-04-12T17:25:37Z",
        "updatedAt" : "2019-04-19T21:52:28Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "43ce0375-7d73-42b4-83a7-494879113a48",
        "parentId" : "2ab02cc5-4ebf-4bd6-a13d-2a3c3526683d",
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "I could see making an assumption that a specific ConsumerRecord is always has a topic (because that's where they come from), but this is the ProcessorRecordContext. The class has no null checks on the topic field, so rather than tracing all the usages to find out whether it can ever be null, in main code or test code, it's simpler and bulletproof just to check for it.",
        "createdAt" : "2019-04-12T22:07:25Z",
        "updatedAt" : "2019-04-19T21:52:28Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      },
      {
        "id" : "88549ab2-d342-4d10-8310-656eff71ad4f",
        "parentId" : "2ab02cc5-4ebf-4bd6-a13d-2a3c3526683d",
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "`ProcessorRecordContext` would only set the topic to `null` for calls into `init()`, `close()`, and punctuation callbacks. Thus, it should never be `null` here IMHO and I believe it would indicate a bug, if it's `null` here. Hence, this check might masked a bug and we should rather fail with a NPE for this case. \\cc @guozhangwang to confirm.",
        "createdAt" : "2019-04-14T03:03:23Z",
        "updatedAt" : "2019-04-19T21:52:28Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "9ba34674-8263-4734-800b-fc1cce320171",
        "parentId" : "2ab02cc5-4ebf-4bd6-a13d-2a3c3526683d",
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "Ok, so I have a clarification: this method is used to estimate the size of the record context in memory, for a variety of usages not restricted to processing. Including some of the cases where you point out it may be null, so we do need the null-check in this method.\r\n\r\nIn the de//serialize methods below, I've removed the null-check, following the spirit of your feedback.",
        "createdAt" : "2019-04-17T15:21:17Z",
        "updatedAt" : "2019-04-19T21:52:28Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      },
      {
        "id" : "ac9e3d5e-a9b7-4a0a-a1ad-974987aa850c",
        "parentId" : "2ab02cc5-4ebf-4bd6-a13d-2a3c3526683d",
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "I understand your argument. However, I am not 100% sure if this does not introduce a weird asymmetry? Also, we only estimate the size _if_ we serialize the context. We don't estimate in-memory/object space usage, do we?\r\n",
        "createdAt" : "2019-04-19T01:44:20Z",
        "updatedAt" : "2019-04-19T21:52:28Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "71cf770e-79a0-4bf1-aab1-6a7772a230ca",
        "parentId" : "2ab02cc5-4ebf-4bd6-a13d-2a3c3526683d",
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "Yes, we do. This is also used for computing the size of the record cache to determine cached state store flushing, etc. (I was a little surprised when a bunch of \"unrelated\" tests failed as a result of the change I tried here).\r\n\r\nI shared your concern about the asymmetry, but I think it's actually ok, even if you only consider the suppression buffer. The `sizeBytes` method is an estimation of the resident size of this object in memory, which is only loosely related to the size of the serialized form of the data in this object.",
        "createdAt" : "2019-04-19T21:03:00Z",
        "updatedAt" : "2019-04-19T21:52:28Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      },
      {
        "id" : "3ebef044-b50a-4015-8875-066c9495e9fa",
        "parentId" : "2ab02cc5-4ebf-4bd6-a13d-2a3c3526683d",
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "Ack. Thanks for being patient with me :)",
        "createdAt" : "2019-04-20T01:08:02Z",
        "updatedAt" : "2019-04-20T01:08:02Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      }
    ],
    "commit" : "f5bd0999c3376588b891016efbec78274a3714ec",
    "line" : 26,
    "diffHunk" : "@@ -1,1 +89,93 @@        size += Long.BYTES; // value.context.timestamp\n        size += Long.BYTES; // value.context.offset\n        if (topic != null) {\n            size += topic.toCharArray().length;\n        }"
  },
  {
    "id" : "603c4117-e8ab-46d5-b8d1-920eeb9d4149",
    "prId" : 6536,
    "prUrl" : "https://github.com/apache/kafka/pull/6536#pullrequestreview-228838893",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e364b7d2-12d0-4d6f-8c75-57a29e95e5cc",
        "parentId" : null,
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "Why this block?",
        "createdAt" : "2019-04-19T01:45:13Z",
        "updatedAt" : "2019-04-19T21:52:28Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "a942a916-db88-488e-9326-419b4faf9f7b",
        "parentId" : "e364b7d2-12d0-4d6f-8c75-57a29e95e5cc",
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "It just prevents polluting the method scope with the temp variable `topicBytes`",
        "createdAt" : "2019-04-19T22:00:18Z",
        "updatedAt" : "2019-04-19T22:00:18Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      }
    ],
    "commit" : "f5bd0999c3376588b891016efbec78274a3714ec",
    "line" : 108,
    "diffHunk" : "@@ -1,1 +175,179 @@        final int topicSize = buffer.getInt();\n        final String topic;\n        {\n            // not handling the null topic condition, because we believe the topic will never be null when we serialize\n            final byte[] topicBytes = new byte[topicSize];"
  },
  {
    "id" : "fe50007b-1ef7-480c-9a31-9a4fab54f763",
    "prId" : 6602,
    "prUrl" : "https://github.com/apache/kafka/pull/6602#pullrequestreview-230282664",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c035c9f1-baad-45c2-ab6f-88ccc197d49e",
        "parentId" : null,
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "some on-the-side cleanup of `ProcessorRecordContext` I encountered while writing my test.",
        "createdAt" : "2019-04-24T18:30:01Z",
        "updatedAt" : "2019-04-26T13:35:41Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      }
    ],
    "commit" : "7414ed063c920aa5c2f4bb29c81664fecb851b9b",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +34,38 @@    private final String topic;\n    private final int partition;\n    private final Headers headers;\n\n    public ProcessorRecordContext(final long timestamp,"
  },
  {
    "id" : "cc7cdd5f-c687-4bdf-b5b0-cca6bb217ecd",
    "prId" : 6602,
    "prUrl" : "https://github.com/apache/kafka/pull/6602#pullrequestreview-231344688",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "199b2de2-599f-46be-96df-69646ff95f11",
        "parentId" : null,
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "No need to deprecate internal method. If we want to remove it, we should just do it.",
        "createdAt" : "2019-04-26T05:15:35Z",
        "updatedAt" : "2019-04-26T13:35:41Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "bdebb394-1085-45a3-924b-966362224a02",
        "parentId" : "199b2de2-599f-46be-96df-69646ff95f11",
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "We can't remove `hashCode`, since it's defined by `Object`. Marking it as deprecated isn't necessary, since any attempt to use it results in an exception, but it's just extra documentation that `hashCode` is not to be used on `ProcessorRecordContext`.\r\n\r\nI implemented it because implementing `equals` without `hashCode` is a bug, and a very subtle one. But I wanted `equals` in support of the test validation. And we also can't provide a correct implementation of `hashCode`, since there is mutable state in this object. This all basically amounts to a flaw in Java, that you can't define equality without implying that an object is stably hashable. Ideally, we could plug in a different notion of equality, but all the testing frameworks have built-in dependency on `equals`. Throwing the exception and adding a deprecation is essentially finding a middle ground, we wind up with safe code that can also be used in tests.",
        "createdAt" : "2019-04-26T13:09:45Z",
        "updatedAt" : "2019-04-26T13:35:41Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      },
      {
        "id" : "3e15e48a-a7ab-4b5b-8ca9-4fe2e1317c76",
        "parentId" : "199b2de2-599f-46be-96df-69646ff95f11",
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "What I meant by \"remove\" was, to remove the overwrite :)\r\n\r\nThanks to clarify why you want to overwrite and throw. But this does not mean that the method is deprecated... Using the annotation implies that we want to remove this overwrite in the future was is miss leading. I would prefer to remove the annotation. \\cc @guozhangwang @bbejeck \r\n\r\n",
        "createdAt" : "2019-04-26T16:55:22Z",
        "updatedAt" : "2019-04-26T16:55:22Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "6ae92e40-0e97-481b-98ea-3aa14dca823b",
        "parentId" : "199b2de2-599f-46be-96df-69646ff95f11",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "I think that throwing the exception in its override implementation is sufficient for future bug-proof, as regarding to documentation I feel neutral either way.",
        "createdAt" : "2019-04-26T17:06:02Z",
        "updatedAt" : "2019-04-26T17:06:02Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "b7b65d6a-6f55-47a1-95d4-b4c04c0f9f5a",
        "parentId" : "199b2de2-599f-46be-96df-69646ff95f11",
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "We should still add JavaDocs and explain that we throw and why. But deprecation != documentation IMHO.",
        "createdAt" : "2019-04-26T20:23:33Z",
        "updatedAt" : "2019-04-26T20:23:34Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      }
    ],
    "commit" : "7414ed063c920aa5c2f4bb29c81664fecb851b9b",
    "line" : 38,
    "diffHunk" : "@@ -1,1 +222,226 @@     * Equality is implemented in support of tests, *not* for use in Hash collections, since this class is mutable.\n     */\n    @Deprecated\n    @Override\n    public int hashCode() {"
  },
  {
    "id" : "3993f535-2700-45e2-9b77-ab56cbb9fc4e",
    "prId" : 6848,
    "prUrl" : "https://github.com/apache/kafka/pull/6848#pullrequestreview-246826936",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ebbedc57-0c76-460a-b684-18c0f9960469",
        "parentId" : null,
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "I should have renamed this method last time I touched this ecosystem. It was confusingly named, since the memory size is closely related to, but different from the serialized format size. I'm just renaming it now, as cleanup.",
        "createdAt" : "2019-05-31T01:39:35Z",
        "updatedAt" : "2019-06-06T21:40:34Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      },
      {
        "id" : "58e8e7f8-b60d-4bd4-80d9-051ab9bf086b",
        "parentId" : "ebbedc57-0c76-460a-b684-18c0f9960469",
        "authorId" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "body" : "Can you elaborate? Is this not just counting the serialized bytes?",
        "createdAt" : "2019-06-04T02:36:20Z",
        "updatedAt" : "2019-06-06T21:40:34Z",
        "lastEditedBy" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "tags" : [
        ]
      },
      {
        "id" : "5e7bce42-4ceb-4f0b-84b0-5b8563412242",
        "parentId" : "ebbedc57-0c76-460a-b684-18c0f9960469",
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "no, this method is used for estimating the amount of heap this object occupies. It definitely includes the serialized bytes of the key and value (and headers), but it does not have to include (for example) all the array-size integers we have to add to the serialized format so that we can deserialize them later. These array bounds actually wind up inflating the size of the output quite a bit.",
        "createdAt" : "2019-06-06T21:33:02Z",
        "updatedAt" : "2019-06-06T21:40:34Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      }
    ],
    "commit" : "166ec22f7b131b5f2501287ce2d7022e67575f0e",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +74,78 @@    }\n\n    public long residentMemorySizeEstimate() {\n        long size = 0;\n        size += Long.BYTES; // value.context.timestamp"
  },
  {
    "id" : "8146b767-09e2-49c6-8946-ea8812ddc300",
    "prId" : 9361,
    "prUrl" : "https://github.com/apache/kafka/pull/9361#pullrequestreview-500554881",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "926e62fb-a880-4c94-868f-d8ba46e302b7",
        "parentId" : null,
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "Here's the implementation of RecordMetadata.",
        "createdAt" : "2020-10-01T20:52:56Z",
        "updatedAt" : "2020-10-02T15:50:27Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      }
    ],
    "commit" : "a8de75f6f16cf8bdcccbcb1bc1fc0a11dd40c1d1",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +31,35 @@import static org.apache.kafka.common.utils.Utils.getNullableSizePrefixedArray;\n\npublic class ProcessorRecordContext implements RecordContext, RecordMetadata {\n\n    private final long timestamp;"
  }
]
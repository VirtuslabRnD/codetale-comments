[
  {
    "id" : "584e5dba-97b8-4ecc-b798-5e967a55d493",
    "prId" : 4508,
    "prUrl" : "https://github.com/apache/kafka/pull/4508#pullrequestreview-94140112",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8e45b356-b88e-4bb8-a474-f656b25e2f57",
        "parentId" : null,
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "This is also intentional but I'd like to have at least a few more careful checks on: I think our current handling of delete, which is to remove from cache and remove from store immediately is not correct, since by doing this, the deletion will not be forwarded to downstream processors (even if the store is flushed later). So I changed it to just putting a null byte arrays into the cache, which will also be picked over the underlying store in the merge-sort iterators.\r\n\r\nBut I want to make sure that there are no other corner cases that may be affected by this change. @dguy @mjsax @bbejeck ?",
        "createdAt" : "2018-02-03T19:49:09Z",
        "updatedAt" : "2018-02-06T01:08:20Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "c8f94ee3-4953-4e49-8591-89e9f9c52ec8",
        "parentId" : "8e45b356-b88e-4bb8-a474-f656b25e2f57",
        "authorId" : "4c968502-bb3d-46ee-8719-0c0bdbc6242f",
        "body" : "I believe this to be correct as well, as all the underlying stores handle the put of a `null` as a delete and it seems compatible with the new change to not have `all()` include null values.",
        "createdAt" : "2018-02-05T17:47:52Z",
        "updatedAt" : "2018-02-06T01:08:20Z",
        "lastEditedBy" : "4c968502-bb3d-46ee-8719-0c0bdbc6242f",
        "tags" : [
        ]
      },
      {
        "id" : "7b881f6d-9282-4463-9f85-b04fa462f927",
        "parentId" : "8e45b356-b88e-4bb8-a474-f656b25e2f57",
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "I am not 100% familiar with the details here, but it sounds reasonable. If you are correct and our old code is incorrect, we should write a test that fails with the old code but passed with the new code.\r\n\r\nOr is this exposed already by a newly added test as mentioned here https://github.com/apache/kafka/pull/4508/files#r165542967",
        "createdAt" : "2018-02-05T19:47:17Z",
        "updatedAt" : "2018-02-06T01:08:20Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "6743c952-c163-4556-a4d3-8b4e6c60fef4",
        "parentId" : "8e45b356-b88e-4bb8-a474-f656b25e2f57",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "The reason I think we did not capture this issue earlier, is that `tuple forward in flushing` is only used for DSL, and in our current DSL's KTableXX operators we never explicitly trigger `delete` and hence that's why we never realize this issue.\r\n\r\nBut even without the scenario that could expose this bug, not using write-through caching for delete still have a performance benefits of write-back caching.",
        "createdAt" : "2018-02-05T20:59:36Z",
        "updatedAt" : "2018-02-06T01:08:20Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      }
    ],
    "commit" : "98b78ecd73a08d76506318623561b797d1659c49",
    "line" : 80,
    "diffHunk" : "@@ -1,1 +272,276 @@    }\n\n    private byte[] deleteInternal(final Bytes key) {\n        final byte[] v = getInternal(key);\n        putInternal(key, null);"
  },
  {
    "id" : "4d9be8c4-03b8-423d-90fe-7ace479cd6a8",
    "prId" : 4988,
    "prUrl" : "https://github.com/apache/kafka/pull/4988#pullrequestreview-118896585",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6e15c7e6-5892-449b-98fe-8471a9b1b0c0",
        "parentId" : null,
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "Should we do this change for `CachingSessionStore` as well?",
        "createdAt" : "2018-05-09T20:40:18Z",
        "updatedAt" : "2018-05-09T20:53:52Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      }
    ],
    "commit" : "7d4508cb22d8a270c237c831850939b788e0b577",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +62,66 @@    public void init(final ProcessorContext context, final StateStore root) {\n        initInternal(context);\n        underlying.init(context, root);\n        // save the stream thread as we only ever want to trigger a flush\n        // when the stream thread is the current thread."
  }
]
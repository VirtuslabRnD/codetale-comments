[
  {
    "id" : "973f242c-f1d8-45d1-b8d0-bee5ceff8623",
    "prId" : 4998,
    "prUrl" : "https://github.com/apache/kafka/pull/4998#pullrequestreview-119274280",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f4f9d465-bc74-41c0-88f9-b7bdd574afb1",
        "parentId" : null,
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "Update the above TODO with only admin client left.",
        "createdAt" : "2018-05-10T22:55:59Z",
        "updatedAt" : "2018-05-15T16:31:43Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      }
    ],
    "commit" : "8c857b9a7f14178e17b0a647af540b7af3bed2cf",
    "line" : 9,
    "diffHunk" : "@@ -1,1 +388,392 @@        final Map<MetricName, Metric> result = new LinkedHashMap<>();\n        for (final StreamThread thread : threads) {\n            result.putAll(thread.producerMetrics());\n            result.putAll(thread.consumerMetrics());\n        }"
  },
  {
    "id" : "39f846d4-b8e9-447a-9f0b-40b15b894678",
    "prId" : 5682,
    "prUrl" : "https://github.com/apache/kafka/pull/5682#pullrequestreview-161804660",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f640e6d3-6d4e-4478-be45-f08c7375e88f",
        "parentId" : null,
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "@guozhangwang @bbejeck @vvcephei Should we change this to \"zero or negative\" ? Comparing the implementation, passing in a negative timestamp will \"expire\" the timeout even without checking the state transition at all and return immediately (with `false`) even if the state transition was successful.",
        "createdAt" : "2018-09-30T21:04:48Z",
        "updatedAt" : "2018-10-04T14:34:18Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "92810b3b-f3ad-4b4d-86fe-17c58b71a260",
        "parentId" : "f640e6d3-6d4e-4478-be45-f08c7375e88f",
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "I'm fine with those semantics, maybe we can make a Jira.\r\n\r\nThinking about it more, though, wouldn't it make more sense to:\r\n* reject negative numbers\r\n* make 0 just signal and return immediately (after checking the state once)\r\n* if I want to wait \"forever\", I can use `ofYears(1)` or `ofMillis(Long.MAX_VALUE)` or some other intuitively \"long enough to be forever\" value instead of a magic value.\r\n\r\nRegardless, I agree the current behavior is a little weird, and I'd be in favor of a Jira/KIP to revise it.",
        "createdAt" : "2018-10-01T14:34:28Z",
        "updatedAt" : "2018-10-04T14:34:19Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      },
      {
        "id" : "a3542d14-99af-441d-a421-f7ef9d5e353c",
        "parentId" : "f640e6d3-6d4e-4478-be45-f08c7375e88f",
        "authorId" : "4c968502-bb3d-46ee-8719-0c0bdbc6242f",
        "body" : "Overall I'm ok with the semantics.\r\n \r\nBut my first instinct of a timeout of `0` implies shutdown immediately with no wait and blocking forever takes a value of `Long.MAX_VALUE`.\r\n\r\nIn short, I'm +1 as well on revising the behavior. ",
        "createdAt" : "2018-10-01T21:13:46Z",
        "updatedAt" : "2018-10-04T14:34:19Z",
        "lastEditedBy" : "4c968502-bb3d-46ee-8719-0c0bdbc6242f",
        "tags" : [
        ]
      },
      {
        "id" : "1e17e274-693c-44fd-a1ac-1a6c21dbc050",
        "parentId" : "f640e6d3-6d4e-4478-be45-f08c7375e88f",
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "Created: https://issues.apache.org/jira/browse/KAFKA-7477",
        "createdAt" : "2018-10-03T20:17:52Z",
        "updatedAt" : "2018-10-04T14:34:19Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      },
      {
        "id" : "0b290fa4-a871-4627-bea8-15eb72f3ac42",
        "parentId" : "f640e6d3-6d4e-4478-be45-f08c7375e88f",
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "I think, we should fix this in 2.1 -- I am suggestion this, because we could use the new semantics for `close(Duration)` only and stay with old semantics for `close(long, TimeUnit)` -- if we don't so this, it would be an backward incompatible change and thus we could only do it in `3.0.0.`.",
        "createdAt" : "2018-10-03T22:21:12Z",
        "updatedAt" : "2018-10-04T14:34:19Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "ec5da148-c2a0-44ff-ab14-f8ec70ebc79b",
        "parentId" : "f640e6d3-6d4e-4478-be45-f08c7375e88f",
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "@nizhikov Are you willing for address 7477 in this PR? If not, it's also fine and we do a follow up PR. However, it should be part of the KIP description. Could you update the KIP accordingly?",
        "createdAt" : "2018-10-03T22:56:34Z",
        "updatedAt" : "2018-10-04T14:34:19Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "50e8fcfa-d762-4039-a9ab-c8507d421a18",
        "parentId" : "f640e6d3-6d4e-4478-be45-f08c7375e88f",
        "authorId" : "fe0be475-2786-4ac9-8152-c07fa363b977",
        "body" : "@mjsax I'll take care of KAFKA-7477 in follow up PR.\r\n\r\n[KIP-358](https://cwiki.apache.org/confluence/display/KAFKA/KIP-358%3A+Migrate+Streams+API+to+Duration+instead+of+long+ms+times) updated. Please, see, \"Proposed Changes\" section.",
        "createdAt" : "2018-10-04T09:59:13Z",
        "updatedAt" : "2018-10-04T14:34:19Z",
        "lastEditedBy" : "fe0be475-2786-4ac9-8152-c07fa363b977",
        "tags" : [
        ]
      },
      {
        "id" : "be0561a0-b6e6-4fc0-8f58-b0e62a025738",
        "parentId" : "f640e6d3-6d4e-4478-be45-f08c7375e88f",
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "Did you start working on KAFKA-7477 already @nizhikov ?",
        "createdAt" : "2018-10-04T16:43:20Z",
        "updatedAt" : "2018-10-04T16:43:21Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "94812d04-dd5a-46ff-a1ed-b5ed5ea3ac2b",
        "parentId" : "f640e6d3-6d4e-4478-be45-f08c7375e88f",
        "authorId" : "fe0be475-2786-4ac9-8152-c07fa363b977",
        "body" : "As far as I can understand thus fix is trivial.\r\nI'm planning to provide PR in a 24 hour after this PR finish. Is it OK?",
        "createdAt" : "2018-10-04T18:49:40Z",
        "updatedAt" : "2018-10-04T18:49:40Z",
        "lastEditedBy" : "fe0be475-2786-4ac9-8152-c07fa363b977",
        "tags" : [
        ]
      },
      {
        "id" : "32d9f463-8a83-45c9-b0ca-50729bcc4d85",
        "parentId" : "f640e6d3-6d4e-4478-be45-f08c7375e88f",
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "Wouldn't call it trivial, but sure, this sound good! Thanks a lot. Just want to make sure we get it on time to not miss code freeze deadline. Thanks a lot!",
        "createdAt" : "2018-10-04T20:50:39Z",
        "updatedAt" : "2018-10-04T20:50:39Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      }
    ],
    "commit" : "5210f9fff117c695cb1f3024c94eff7f49599a6a",
    "line" : 33,
    "diffHunk" : "@@ -1,1 +903,907 @@     * Shutdown this {@code KafkaStreams} by signaling all the threads to stop, and then wait up to the timeout for the\n     * threads to join.\n     * A {@code timeout} of 0 means to wait forever.\n     *\n     * @param timeout  how long to wait for the threads to shutdown"
  },
  {
    "id" : "6925f1d7-d3cf-492c-b1ec-485f6af6670c",
    "prId" : 5696,
    "prUrl" : "https://github.com/apache/kafka/pull/5696#pullrequestreview-171455665",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "72d94a2e-acc9-48be-a82f-b4e745ea17ee",
        "parentId" : null,
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "We should add a new test to `KafkaStreamsTest` to check that no directory is created for this case",
        "createdAt" : "2018-11-04T03:11:28Z",
        "updatedAt" : "2018-11-21T09:44:56Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "727e1382-96ab-42a4-a6d2-e5cec7625d20",
        "parentId" : "72d94a2e-acc9-48be-a82f-b4e745ea17ee",
        "authorId" : "85578594-6b0b-4724-b709-a8c84f206391",
        "body" : "For the above case, `TopologyDiskAccessTest` class is added.  `KafkaStreamsTest` tests only the KafkaStreams logic (It doesn't create any topology which is required for the above case). ",
        "createdAt" : "2018-11-04T09:39:17Z",
        "updatedAt" : "2018-11-21T09:44:56Z",
        "lastEditedBy" : "85578594-6b0b-4724-b709-a8c84f206391",
        "tags" : [
        ]
      },
      {
        "id" : "a25b8e84-589f-45c9-b1c0-882be39d9cb8",
        "parentId" : "72d94a2e-acc9-48be-a82f-b4e745ea17ee",
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "> KafkaStreamsTest tests only the KafkaStreams logic\r\n\r\nWell, because `KafkaStreams` is responsible to create/or-not-crate the directory, this is part of `KafkaStreams` logic, isn't it? Thus, IMHO we should test this behavior in `KafkaStreamsTest`. Nothing prevents you create any topology in the test for this.\r\n\r\nAlso, `TopologyDisAccessTest` does not use `KafkaStreams` but `TopologyTestDriver` and thus, does not cover this code path.",
        "createdAt" : "2018-11-04T17:33:33Z",
        "updatedAt" : "2018-11-21T09:44:56Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "710a3047-0d47-43ea-a668-7b171c2b4292",
        "parentId" : "72d94a2e-acc9-48be-a82f-b4e745ea17ee",
        "authorId" : "85578594-6b0b-4724-b709-a8c84f206391",
        "body" : "Agree, moved the test cases to `KafkaStreamsTest`.",
        "createdAt" : "2018-11-05T08:50:29Z",
        "updatedAt" : "2018-11-21T09:44:56Z",
        "lastEditedBy" : "85578594-6b0b-4724-b709-a8c84f206391",
        "tags" : [
        ]
      }
    ],
    "commit" : "cdd60cb5ad70b8796e3ef74f1e5a94245cf8f7f9",
    "line" : 26,
    "diffHunk" : "@@ -1,1 +675,679 @@        final ProcessorTopology globalTaskTopology = internalTopologyBuilder.buildGlobalStateTopology();\n        final long cacheSizePerThread = totalCacheSize / (threads.length + (globalTaskTopology == null ? 0 : 1));\n        final boolean createStateDirectory = taskTopology.hasPersistentLocalStore() ||\n                (globalTaskTopology != null && globalTaskTopology.hasPersistentGlobalStore());\n"
  },
  {
    "id" : "ff999106-4702-482d-9d9e-865509cb6048",
    "prId" : 5747,
    "prUrl" : "https://github.com/apache/kafka/pull/5747#pullrequestreview-162648793",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9f9e30fd-9ea1-4fe8-9cc3-b71002c882f2",
        "parentId" : null,
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "We cannot change the semantics of exiting `close(long, TimeUnit)` -- this would be a backward incompatible change. We can only change the semantics for the new `close(Duration)` method.\r\n\r\nWe also should point out the different semantics in L830:\r\n```\r\n@deprecated Use {@link #close(Duration)} instead; note, that {@link #close(Duration)} has different semantics and does not block on zero, e.g., `Duration.ofMillis(0)`.",
        "createdAt" : "2018-10-05T17:43:46Z",
        "updatedAt" : "2018-10-08T21:40:04Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "a25aa812-456a-4bf7-8df8-ae6cc0bb6f46",
        "parentId" : "9f9e30fd-9ea1-4fe8-9cc3-b71002c882f2",
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "Seems this comment was not addressed yet.",
        "createdAt" : "2018-10-08T21:22:51Z",
        "updatedAt" : "2018-10-08T21:40:04Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "bc039738-a625-434d-bb03-24a3d2e12bd4",
        "parentId" : "9f9e30fd-9ea1-4fe8-9cc3-b71002c882f2",
        "authorId" : "fe0be475-2786-4ac9-8152-c07fa363b977",
        "body" : "Fixed.",
        "createdAt" : "2018-10-08T21:38:57Z",
        "updatedAt" : "2018-10-08T21:40:04Z",
        "lastEditedBy" : "fe0be475-2786-4ac9-8152-c07fa363b977",
        "tags" : [
        ]
      }
    ],
    "commit" : "d055d3e380704470a874bc477902c3a649298717",
    "line" : 20,
    "diffHunk" : "@@ -1,1 +819,823 @@     * A {@code timeout} of 0 means to wait forever.\n     *\n     * @param timeout  how long to wait for the threads to shutdown. Can't be negative. If {@code timeout=0} just checking the state and return immediately.\n     * @param timeUnit unit of time used for timeout\n     * @return {@code true} if all threads were successfully stopped&mdash;{@code false} if the timeout was reached"
  },
  {
    "id" : "fd1beb28-1761-41fb-ae2f-7aef82650f87",
    "prId" : 5954,
    "prUrl" : "https://github.com/apache/kafka/pull/5954#pullrequestreview-179629376",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9632f937-e306-4a66-b06f-7827e78d724a",
        "parentId" : null,
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "@ijuma Removed the `SuppressWarning` annotation and rewrote the code. Also have a PR for 2.1 branch: https://github.com/apache/kafka/pull/5963 for this fix.",
        "createdAt" : "2018-11-28T21:09:28Z",
        "updatedAt" : "2018-12-11T09:51:36Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "04044a72-350f-4a0a-a731-4aac7c11ba6f",
        "parentId" : "9632f937-e306-4a66-b06f-7827e78d724a",
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "We translate old default of zero to Long.MAX_VALUE within deprecated `close(final long timeout, final TimeUnit timeUnit)` -- we can call `private close()` directly instead.",
        "createdAt" : "2018-11-28T21:12:29Z",
        "updatedAt" : "2018-12-11T09:51:36Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "8a5b63df-586a-4585-82e4-2b2afc40f6f6",
        "parentId" : "9632f937-e306-4a66-b06f-7827e78d724a",
        "authorId" : "d8c7cf80-a55a-474c-a4f4-f60a9efda52c",
        "body" : "Thanks, this looks better.",
        "createdAt" : "2018-11-29T05:01:39Z",
        "updatedAt" : "2018-12-11T09:51:36Z",
        "lastEditedBy" : "d8c7cf80-a55a-474c-a4f4-f60a9efda52c",
        "tags" : [
        ]
      }
    ],
    "commit" : "c9c692fa9804850c0cdd372d825db005bf3851f8",
    "line" : 99,
    "diffHunk" : "@@ -1,1 +808,812 @@     */\n    public void close() {\n        close(Long.MAX_VALUE);\n    }\n"
  },
  {
    "id" : "978f0d8a-e9b5-4d0d-a782-1239d7a8c4d9",
    "prId" : 5963,
    "prUrl" : "https://github.com/apache/kafka/pull/5963#pullrequestreview-179518887",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5dce7be0-b76c-481b-9820-7f3ffd012c20",
        "parentId" : null,
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "We translate old default of zero to Long.MAX_VALUE within deprecated `close(final long timeout, final TimeUnit timeUnit)` -- we can call `private close()` directly instead.",
        "createdAt" : "2018-11-28T21:11:57Z",
        "updatedAt" : "2018-11-28T21:11:57Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      }
    ],
    "commit" : "65462041543d7f9f12ffa5fab6c0bcc45403e83d",
    "line" : 29,
    "diffHunk" : "@@ -1,1 +811,815 @@     */\n    public void close() {\n        close(Long.MAX_VALUE);\n    }\n"
  },
  {
    "id" : "3213f5d7-b9f5-42ec-86eb-ddf58739cef1",
    "prId" : 6018,
    "prUrl" : "https://github.com/apache/kafka/pull/6018#pullrequestreview-184656205",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5f18710d-807b-4baa-8129-80ee7dc3843f",
        "parentId" : null,
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "This is for 1).",
        "createdAt" : "2018-12-09T23:22:45Z",
        "updatedAt" : "2019-01-04T22:37:02Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "1f09a998-9753-4c8a-b92a-4d6fa3a1772d",
        "parentId" : "5f18710d-807b-4baa-8129-80ee7dc3843f",
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "I don't get why we need this? `onChange()` is `synchronized`, so how can a race condition happen?",
        "createdAt" : "2018-12-13T14:08:22Z",
        "updatedAt" : "2019-01-04T22:37:02Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      }
    ],
    "commit" : "a32c0e8aeca9e6a022faa4f72d679f75214b1868",
    "line" : 175,
    "diffHunk" : "@@ -1,1 +395,399 @@        private GlobalStreamThread.State globalThreadState;\n        // this lock should always be held before the state lock\n        private final Object threadStatesLock;\n\n        StreamStateListener(final Map<Long, StreamThread.State> threadState,"
  },
  {
    "id" : "3882b8bc-8648-4081-a40c-e511db48f44e",
    "prId" : 6018,
    "prUrl" : "https://github.com/apache/kafka/pull/6018#pullrequestreview-185286174",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ee712804-dd02-4022-baf5-fbd520aa6218",
        "parentId" : null,
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "This is for 1) as well: we allow REBALANCE -> REBALANCE and RUNNING -> RUNNING because of the deferred check.",
        "createdAt" : "2018-12-09T23:24:08Z",
        "updatedAt" : "2019-01-04T22:37:02Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "4a91920c-3466-4260-9c29-2fbeca41a6f6",
        "parentId" : "ee712804-dd02-4022-baf5-fbd520aa6218",
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "Just looking at this, it seems we need to assign `oldState = state` after we go the lock?",
        "createdAt" : "2018-12-13T13:55:37Z",
        "updatedAt" : "2019-01-04T22:37:02Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "296baa8c-a29c-47ab-8c02-51155629d3ff",
        "parentId" : "ee712804-dd02-4022-baf5-fbd520aa6218",
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "Also below, when calling `stateListener.onChange(state, oldState);` -- would we need to call `stateListener.onChange(newState, oldState);` instead? Otherwise, `state` could change before we do the callback because the lock is released already.\r\n\r\n",
        "createdAt" : "2018-12-13T13:56:45Z",
        "updatedAt" : "2019-01-04T22:37:02Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "fcf7a0f8-d100-48d4-a2bb-7473616e50fe",
        "parentId" : "ee712804-dd02-4022-baf5-fbd520aa6218",
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "I cannot follow here. Why would this happen? Similar for RUNNING?",
        "createdAt" : "2018-12-13T14:05:41Z",
        "updatedAt" : "2019-01-04T22:37:02Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "d0f9d087-e20d-4cd1-8c73-cb127f9ee51a",
        "parentId" : "ee712804-dd02-4022-baf5-fbd520aa6218",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "Re first two comments: good call, lgtm.\r\n\r\nRe last comment: REBALANCING -> REBALANCING is quite normal, note that before this PR we check this before calling `setState(State.REBALANCING);` so this is prevented, but part of this fix is to move the logic that needs to access the state into a single place (here). Similarly RUNNING -> RUNNING is possible during starting up phase, where we first set the instance state to RUNNING directly to avoid it transit from CREATED -> REBALANCING, and then when threads are starting, it is possible that `maybeSetRunning` went through and hence calls `setState(RUNNING)` again.",
        "createdAt" : "2018-12-14T21:09:58Z",
        "updatedAt" : "2019-01-04T22:37:02Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      }
    ],
    "commit" : "a32c0e8aeca9e6a022faa4f72d679f75214b1868",
    "line" : 69,
    "diffHunk" : "@@ -1,1 +252,256 @@                // will be refused but we do not throw exception here, to allow idempotent close calls\n                return false;\n            } else if (state == State.REBALANCING && newState == State.REBALANCING) {\n                // when the state is already in REBALANCING, it should not transit to REBALANCING\n                return false;"
  },
  {
    "id" : "3af27371-8d50-4ae3-a3c3-287c33ec2540",
    "prId" : 6018,
    "prUrl" : "https://github.com/apache/kafka/pull/6018#pullrequestreview-183000687",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "81eed83d-de45-4312-9d03-20ec2d2e082f",
        "parentId" : null,
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "This one-liner is for 2).",
        "createdAt" : "2018-12-09T23:24:36Z",
        "updatedAt" : "2019-01-04T22:37:02Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      }
    ],
    "commit" : "a32c0e8aeca9e6a022faa4f72d679f75214b1868",
    "line" : 210,
    "diffHunk" : "@@ -1,1 +426,430 @@            // state can be transferred to RUNNING if all threads are either RUNNING or DEAD\n            for (final StreamThread.State state : threadState.values()) {\n                if (state != StreamThread.State.RUNNING && state != StreamThread.State.DEAD) {\n                    return;\n                }"
  },
  {
    "id" : "7cb0566d-4b87-47e8-b5de-e66e67ad3c4d",
    "prId" : 6018,
    "prUrl" : "https://github.com/apache/kafka/pull/6018#pullrequestreview-185282740",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a590d369-4518-43b2-9cff-536e6386f5c6",
        "parentId" : null,
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "Does it make sense to set the instance to RUNNING if all threads are DEAD ?",
        "createdAt" : "2018-12-13T13:21:11Z",
        "updatedAt" : "2019-01-04T22:37:02Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "38c58a07-ff20-4981-ba68-ed0a28195c79",
        "parentId" : "a590d369-4518-43b2-9cff-536e6386f5c6",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "Note this is triggered only when a thread transited to RUNNING.\r\n\r\nWhen all threads are DEAD, by the time the last thread transited to DEAD the `maybeSetError` will proceed and the state will transit to ERROR.",
        "createdAt" : "2018-12-14T20:58:37Z",
        "updatedAt" : "2019-01-04T22:37:02Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      }
    ],
    "commit" : "a32c0e8aeca9e6a022faa4f72d679f75214b1868",
    "line" : 207,
    "diffHunk" : "@@ -1,1 +424,428 @@         */\n        private void maybeSetRunning() {\n            // state can be transferred to RUNNING if all threads are either RUNNING or DEAD\n            for (final StreamThread.State state : threadState.values()) {\n                if (state != StreamThread.State.RUNNING && state != StreamThread.State.DEAD) {"
  },
  {
    "id" : "46f0327d-6f21-4dc0-bd6e-0c8e17167446",
    "prId" : 6018,
    "prUrl" : "https://github.com/apache/kafka/pull/6018#pullrequestreview-189542384",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4e75185e-ecad-4265-82ae-45d344ed785c",
        "parentId" : null,
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "With the state transitions changes for `StreamThread` is this still possible?",
        "createdAt" : "2018-12-19T09:40:03Z",
        "updatedAt" : "2019-01-04T22:37:02Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "3f9d1d61-a0a6-4ba3-b9e3-94121d792fa0",
        "parentId" : "4e75185e-ecad-4265-82ae-45d344ed785c",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "Good point, I can remove it here.",
        "createdAt" : "2019-01-04T21:53:34Z",
        "updatedAt" : "2019-01-04T22:37:02Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      }
    ],
    "commit" : "a32c0e8aeca9e6a022faa4f72d679f75214b1868",
    "line" : 73,
    "diffHunk" : "@@ -1,1 +256,260 @@                return false;\n//            } else if (state == State.RUNNING && newState == State.RUNNING) {\n                // when the state is already in RUNNING, it should not transit to RUNNING\n                // this can happen during starting up\n//                return false;"
  },
  {
    "id" : "ebcbb2c3-5331-44b5-bc24-e2143bf92711",
    "prId" : 6018,
    "prUrl" : "https://github.com/apache/kafka/pull/6018#pullrequestreview-189509479",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "81951a80-c33d-45bd-b259-c41be193ed3d",
        "parentId" : null,
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "Why do we need `threadStateLock`? Can't we use `this`?",
        "createdAt" : "2018-12-19T09:43:40Z",
        "updatedAt" : "2019-01-04T22:37:02Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "f9445e7e-ea74-42db-850e-926fadfde2e1",
        "parentId" : "81951a80-c33d-45bd-b259-c41be193ed3d",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "We can; but since we have a `stateLock` already I want to distinguish it with another dedicated object.",
        "createdAt" : "2019-01-04T20:03:25Z",
        "updatedAt" : "2019-01-04T22:37:02Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      }
    ],
    "commit" : "a32c0e8aeca9e6a022faa4f72d679f75214b1868",
    "line" : 242,
    "diffHunk" : "@@ -1,1 +445,449 @@                                          final ThreadStateTransitionValidator abstractNewState,\n                                          final ThreadStateTransitionValidator abstractOldState) {\n            synchronized (threadStatesLock) {\n                // StreamThreads first\n                if (thread instanceof StreamThread) {"
  },
  {
    "id" : "5f3155d9-4fd0-4db7-8d50-3bfc38a3a225",
    "prId" : 6018,
    "prUrl" : "https://github.com/apache/kafka/pull/6018#pullrequestreview-189510538",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c68db677-5dd7-43bb-917e-efd9028596f0",
        "parentId" : null,
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "If we want to encapsulate state handling at instance/thread level, maybe rewrite this to:\r\n```\r\nif (newState == GlobalStreamThread.State.DEAD) {\r\n    setState(State.ERROR);\r\n    log.error(\"Global thread has died. The instance will be in error state and should be closed.\");\r\n}\r\n```\r\n\r\nGlobalStreamThread would call this method only once anyway, and `setState()` should handle idempotent `setState(State.ERROR)` internally?",
        "createdAt" : "2018-12-19T09:51:04Z",
        "updatedAt" : "2019-01-04T22:37:02Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "b4d7031f-57dd-4e7e-a60d-8193b96c96ea",
        "parentId" : "c68db677-5dd7-43bb-917e-efd9028596f0",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "I can do that, but I need to let `State.ERROR` transit to `State.ERROR` (currently it is not allowed, and hence will cause illegal state exception). Will do that.",
        "createdAt" : "2019-01-04T20:06:58Z",
        "updatedAt" : "2019-01-04T22:37:02Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      }
    ],
    "commit" : "a32c0e8aeca9e6a022faa4f72d679f75214b1868",
    "line" : 263,
    "diffHunk" : "@@ -1,1 +466,470 @@                    if (newState == GlobalStreamThread.State.DEAD) {\n                        setState(State.ERROR);\n                        log.error(\"Global thread has died. The instance will be in error state and should be closed.\");\n                    }\n                }"
  },
  {
    "id" : "1cd4e424-e639-4c62-ab64-25fd5c13710f",
    "prId" : 6018,
    "prUrl" : "https://github.com/apache/kafka/pull/6018#pullrequestreview-189512662",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e9365ee7-fbe7-4def-9293-29b7c697a9be",
        "parentId" : null,
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "Not sure if this holds. Don't we need to block state transitions while we cleanup is running?",
        "createdAt" : "2018-12-19T09:54:14Z",
        "updatedAt" : "2019-01-04T22:37:02Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "2288ce29-5f71-434b-90af-7839cc75fd32",
        "parentId" : "e9365ee7-fbe7-4def-9293-29b7c697a9be",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "`stateDirectory.cleanRemovedTasks(cleanupDelay);` itself have synchronization barriers as well, so we do not need to have the whole function in `synchronized(stateLock)`; and in that case, just locking `stateLock` for reading its value does not bring any additional guarantees.",
        "createdAt" : "2019-01-04T20:14:10Z",
        "updatedAt" : "2019-01-04T22:37:02Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      }
    ],
    "commit" : "a32c0e8aeca9e6a022faa4f72d679f75214b1868",
    "line" : 286,
    "diffHunk" : "@@ -1,1 +791,795 @@            final Long cleanupDelay = config.getLong(StreamsConfig.STATE_CLEANUP_DELAY_MS_CONFIG);\n            stateDirCleaner.scheduleAtFixedRate(() -> {\n                // we do not use lock here since we only read on the value and act on it\n                if (state == State.RUNNING) {\n                    stateDirectory.cleanRemovedTasks(cleanupDelay);"
  },
  {
    "id" : "8e6a0b59-271a-4b46-8bbf-03437c1e7d4e",
    "prId" : 6018,
    "prUrl" : "https://github.com/apache/kafka/pull/6018#pullrequestreview-189514003",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "688c09f2-dfbb-4dcc-9487-e03cc74ab8b8",
        "parentId" : null,
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "Why do we want to disallow calling `start()` twice? Could be idempotent no-op, too.",
        "createdAt" : "2018-12-19T09:55:45Z",
        "updatedAt" : "2019-01-04T22:37:02Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "3826ab16-f13b-4a52-8db5-5e32154fb561",
        "parentId" : "688c09f2-dfbb-4dcc-9487-e03cc74ab8b8",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "Good question.. this was added at the very beginning when we try to fix a few state transition bugs, and one of them as calling start() twice which may re-create threads etc. Arguably we can still allow calling it twice while making second / future calls no-op.\r\n\r\nI'd suggest we leave it as a separate improvement.",
        "createdAt" : "2019-01-04T20:18:22Z",
        "updatedAt" : "2019-01-04T22:37:02Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      }
    ],
    "commit" : "a32c0e8aeca9e6a022faa4f72d679f75214b1868",
    "line" : 298,
    "diffHunk" : "@@ -1,1 +797,801 @@            }, cleanupDelay, cleanupDelay, TimeUnit.MILLISECONDS);\n        } else {\n            throw new IllegalStateException(\"The client is either already started or already stopped, cannot re-start\");\n        }\n    }"
  },
  {
    "id" : "fa3ee244-7af9-4c1a-b9c0-4ea6ff0e6f1d",
    "prId" : 6107,
    "prUrl" : "https://github.com/apache/kafka/pull/6107#pullrequestreview-198331265",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3f9b44ac-99e3-489a-93d3-28ebf107af9d",
        "parentId" : null,
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "why not go ahead and do this now?",
        "createdAt" : "2019-01-30T22:04:59Z",
        "updatedAt" : "2019-01-30T22:04:59Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      }
    ],
    "commit" : "65e8c144ba2d48adfd7b35fdfc7224106c295254",
    "line" : 17,
    "diffHunk" : "@@ -1,1 +381,385 @@            // admin client is shared, so we can actually move it\n            // to result.putAll(adminClient.metrics()).\n            // we did it intentionally just for flexibility.\n            result.putAll(thread.adminClientMetrics());\n        }"
  }
]
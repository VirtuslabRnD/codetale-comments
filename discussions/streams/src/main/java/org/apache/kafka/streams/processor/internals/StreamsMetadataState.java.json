[
  {
    "id" : "7e4c7035-d80e-45b1-a6ac-8481a09024b4",
    "prId" : 8233,
    "prUrl" : "https://github.com/apache/kafka/pull/8233#pullrequestreview-369988829",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "04e25e1d-34bb-4333-8f0d-50b781efe892",
        "parentId" : null,
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "Why move the reset into the condition? if the passed in values are empty we should still set it to empty because the previous map may be out-dated right?",
        "createdAt" : "2020-03-05T22:45:42Z",
        "updatedAt" : "2020-03-05T22:49:34Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "4c210b56-7e32-4bcf-9053-9698bda0064b",
        "parentId" : "04e25e1d-34bb-4333-8f0d-50b781efe892",
        "authorId" : "e431deb4-a19e-4e78-a775-12af049c9089",
        "body" : "Well, with this change you're always going to get either the old or new metadata from `getAllMetadata`.  Where as if I clear the list at the start of this method, then `getAllMetadata` can return empty.\r\n\r\nQuestion is: which is preferable?  I figured there's a strong possibility that at least some of the old metadata may still be correct - so why ditch it?",
        "createdAt" : "2020-03-05T23:31:28Z",
        "updatedAt" : "2020-03-05T23:31:29Z",
        "lastEditedBy" : "e431deb4-a19e-4e78-a775-12af049c9089",
        "tags" : [
        ]
      },
      {
        "id" : "67c4d428-231c-4c76-b5a7-cef008edb12a",
        "parentId" : "04e25e1d-34bb-4333-8f0d-50b781efe892",
        "authorId" : "e431deb4-a19e-4e78-a775-12af049c9089",
        "body" : "By returning `empty` we're forcing callers to handle this case. But if we return stale data, then it's no different to if they had called `getAllMetadata` a few ns earlier.",
        "createdAt" : "2020-03-05T23:38:57Z",
        "updatedAt" : "2020-03-05T23:38:57Z",
        "lastEditedBy" : "e431deb4-a19e-4e78-a775-12af049c9089",
        "tags" : [
        ]
      }
    ],
    "commit" : "51c76fedd9da8c27b667075d334dc8da9bed6489",
    "line" : 45,
    "diffHunk" : "@@ -1,1 +317,321 @@                                 final Map<HostInfo, Set<TopicPartition>> standbyPartitionHostMap) {\n        if (activePartitionHostMap.isEmpty() && standbyPartitionHostMap.isEmpty()) {\n            allMetadata = Collections.emptyList();\n            return;\n        }"
  },
  {
    "id" : "81bae2e7-046d-4a71-8697-7366d8c170f3",
    "prId" : 8900,
    "prUrl" : "https://github.com/apache/kafka/pull/8900#pullrequestreview-436195211",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "70cdbe42-b82c-4ff3-b0ba-80d4280fba1a",
        "parentId" : null,
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "Should we fix this in older branches (2.5/2.4), too? (ie follow up PR)",
        "createdAt" : "2020-06-23T21:23:44Z",
        "updatedAt" : "2020-06-23T22:09:07Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "d2952aad-0fc1-4e8c-a3c9-e47c58f99b0b",
        "parentId" : "70cdbe42-b82c-4ff3-b0ba-80d4280fba1a",
        "authorId" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "body" : "Will do",
        "createdAt" : "2020-06-23T21:36:02Z",
        "updatedAt" : "2020-06-23T22:09:07Z",
        "lastEditedBy" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "tags" : [
        ]
      },
      {
        "id" : "e7aa0e98-b10b-4faa-b70e-1df1bc7054d1",
        "parentId" : "70cdbe42-b82c-4ff3-b0ba-80d4280fba1a",
        "authorId" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "body" : "https://github.com/apache/kafka/pull/8919",
        "createdAt" : "2020-06-23T22:11:37Z",
        "updatedAt" : "2020-06-23T22:11:37Z",
        "lastEditedBy" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "tags" : [
        ]
      }
    ],
    "commit" : "20321fd1325d402405a4b5899c22c83a51732b1c",
    "line" : 8,
    "diffHunk" : "@@ -1,1 +155,159 @@            // global stores are on every node. if we don't have the host info\n            // for this host then just pick the first metadata\n            if (thisHost.equals(UNKNOWN_HOST)) {\n                return allMetadata.get(0);\n            }"
  }
]
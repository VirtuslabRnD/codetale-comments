[
  {
    "id" : "7e4c7035-d80e-45b1-a6ac-8481a09024b4",
    "prId" : 8233,
    "prUrl" : "https://github.com/apache/kafka/pull/8233#pullrequestreview-369988829",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "04e25e1d-34bb-4333-8f0d-50b781efe892",
        "parentId" : null,
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "Why move the reset into the condition? if the passed in values are empty we should still set it to empty because the previous map may be out-dated right?",
        "createdAt" : "2020-03-05T22:45:42Z",
        "updatedAt" : "2020-03-05T22:49:34Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "4c210b56-7e32-4bcf-9053-9698bda0064b",
        "parentId" : "04e25e1d-34bb-4333-8f0d-50b781efe892",
        "authorId" : "e431deb4-a19e-4e78-a775-12af049c9089",
        "body" : "Well, with this change you're always going to get either the old or new metadata from `getAllMetadata`.  Where as if I clear the list at the start of this method, then `getAllMetadata` can return empty.\r\n\r\nQuestion is: which is preferable?  I figured there's a strong possibility that at least some of the old metadata may still be correct - so why ditch it?",
        "createdAt" : "2020-03-05T23:31:28Z",
        "updatedAt" : "2020-03-05T23:31:29Z",
        "lastEditedBy" : "e431deb4-a19e-4e78-a775-12af049c9089",
        "tags" : [
        ]
      },
      {
        "id" : "67c4d428-231c-4c76-b5a7-cef008edb12a",
        "parentId" : "04e25e1d-34bb-4333-8f0d-50b781efe892",
        "authorId" : "e431deb4-a19e-4e78-a775-12af049c9089",
        "body" : "By returning `empty` we're forcing callers to handle this case. But if we return stale data, then it's no different to if they had called `getAllMetadata` a few ns earlier.",
        "createdAt" : "2020-03-05T23:38:57Z",
        "updatedAt" : "2020-03-05T23:38:57Z",
        "lastEditedBy" : "e431deb4-a19e-4e78-a775-12af049c9089",
        "tags" : [
        ]
      }
    ],
    "commit" : "51c76fedd9da8c27b667075d334dc8da9bed6489",
    "line" : 45,
    "diffHunk" : "@@ -1,1 +317,321 @@                                 final Map<HostInfo, Set<TopicPartition>> standbyPartitionHostMap) {\n        if (activePartitionHostMap.isEmpty() && standbyPartitionHostMap.isEmpty()) {\n            allMetadata = Collections.emptyList();\n            return;\n        }"
  },
  {
    "id" : "81bae2e7-046d-4a71-8697-7366d8c170f3",
    "prId" : 8900,
    "prUrl" : "https://github.com/apache/kafka/pull/8900#pullrequestreview-436195211",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "70cdbe42-b82c-4ff3-b0ba-80d4280fba1a",
        "parentId" : null,
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "Should we fix this in older branches (2.5/2.4), too? (ie follow up PR)",
        "createdAt" : "2020-06-23T21:23:44Z",
        "updatedAt" : "2020-06-23T22:09:07Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "d2952aad-0fc1-4e8c-a3c9-e47c58f99b0b",
        "parentId" : "70cdbe42-b82c-4ff3-b0ba-80d4280fba1a",
        "authorId" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "body" : "Will do",
        "createdAt" : "2020-06-23T21:36:02Z",
        "updatedAt" : "2020-06-23T22:09:07Z",
        "lastEditedBy" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "tags" : [
        ]
      },
      {
        "id" : "e7aa0e98-b10b-4faa-b70e-1df1bc7054d1",
        "parentId" : "70cdbe42-b82c-4ff3-b0ba-80d4280fba1a",
        "authorId" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "body" : "https://github.com/apache/kafka/pull/8919",
        "createdAt" : "2020-06-23T22:11:37Z",
        "updatedAt" : "2020-06-23T22:11:37Z",
        "lastEditedBy" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "tags" : [
        ]
      }
    ],
    "commit" : "20321fd1325d402405a4b5899c22c83a51732b1c",
    "line" : 8,
    "diffHunk" : "@@ -1,1 +155,159 @@            // global stores are on every node. if we don't have the host info\n            // for this host then just pick the first metadata\n            if (thisHost.equals(UNKNOWN_HOST)) {\n                return allMetadata.get(0);\n            }"
  },
  {
    "id" : "61167297-e46c-45d6-b72d-713097d51f0b",
    "prId" : 8929,
    "prUrl" : "https://github.com/apache/kafka/pull/8929#pullrequestreview-438622077",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7c916993-b73b-4f48-af17-f8256992dc02",
        "parentId" : null,
        "authorId" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "body" : "Will this get us NullPointer? Do we need to get an initial value for localMetadata?",
        "createdAt" : "2020-06-25T22:15:05Z",
        "updatedAt" : "2020-06-29T16:33:08Z",
        "lastEditedBy" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "tags" : [
        ]
      },
      {
        "id" : "5c79bc6d-0ff4-46a7-948b-1c4396e3eb29",
        "parentId" : "7c916993-b73b-4f48-af17-f8256992dc02",
        "authorId" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "body" : "Yeah good catch, see above",
        "createdAt" : "2020-06-25T22:27:28Z",
        "updatedAt" : "2020-06-29T16:33:08Z",
        "lastEditedBy" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "tags" : [
        ]
      },
      {
        "id" : "5bfd313a-238c-432f-a0da-4e41f7574003",
        "parentId" : "7c916993-b73b-4f48-af17-f8256992dc02",
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "Very good catch. Thanks, @abbccdda .",
        "createdAt" : "2020-06-26T02:27:28Z",
        "updatedAt" : "2020-06-29T16:33:08Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      },
      {
        "id" : "093a838b-3060-4f16-a472-f9c38e5742fc",
        "parentId" : "7c916993-b73b-4f48-af17-f8256992dc02",
        "authorId" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "body" : "Hmm, why do we still keep it? Based on the reviews for previous version, I believe that there is some strict ordering for getting `localMetadata` initialized to be non-null on L352 first before hitting this logic, but still a null check sound more resilient to me, unless we want to have a NullPointerException to be thrown explicitly.",
        "createdAt" : "2020-06-26T20:56:34Z",
        "updatedAt" : "2020-06-29T16:33:08Z",
        "lastEditedBy" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "tags" : [
        ]
      },
      {
        "id" : "3ae6c224-27ac-414a-b13c-6dca99c400d0",
        "parentId" : "7c916993-b73b-4f48-af17-f8256992dc02",
        "authorId" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "body" : "This gets initialized during the rebalance and IQ isn't available until Streams has reached RUNNING. ",
        "createdAt" : "2020-06-26T21:03:27Z",
        "updatedAt" : "2020-06-29T16:33:08Z",
        "lastEditedBy" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "tags" : [
        ]
      },
      {
        "id" : "3295bf38-c823-437c-ba74-9615985493f6",
        "parentId" : "7c916993-b73b-4f48-af17-f8256992dc02",
        "authorId" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "body" : "I looked through the StreamsMetadataState and it does seem like it could technically be null if this instance was never assigned any active or standby tasks at all, ever. That really _shouldn't_ happen, but of course it can if you massively over-provisioned your app and we shouldn't throw an NPE over that.\r\n\r\nSeems like this is actually an existing bug that we should fix. Then we can improve the initialization check on the side",
        "createdAt" : "2020-06-26T22:08:18Z",
        "updatedAt" : "2020-06-29T16:33:08Z",
        "lastEditedBy" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "tags" : [
        ]
      }
    ],
    "commit" : "21ca71a4bb08ad17bd2ccdcdb61dce47f958d29e",
    "line" : 40,
    "diffHunk" : "@@ -1,1 +228,232 @@                return new KeyQueryMetadata(allMetadata.get(0).hostInfo(), Collections.emptySet(), -1);\n            }\n            return new KeyQueryMetadata(localMetadata.get().hostInfo(), Collections.emptySet(), -1);\n        }\n"
  }
]
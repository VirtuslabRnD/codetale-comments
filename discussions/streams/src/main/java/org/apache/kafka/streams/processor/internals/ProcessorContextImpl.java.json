[
  {
    "id" : "2e3f3e6d-1df1-4ba3-98cb-ca35a889128c",
    "prId" : 5954,
    "prUrl" : "https://github.com/apache/kafka/pull/5954#pullrequestreview-179480273",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a08a796e-8896-4dae-871f-a7b5b0b9a892",
        "parentId" : null,
        "authorId" : "d8c7cf80-a55a-474c-a4f4-f60a9efda52c",
        "body" : "Again, why are we adding calls to deprecated code?",
        "createdAt" : "2018-11-28T08:59:52Z",
        "updatedAt" : "2018-12-11T09:51:36Z",
        "lastEditedBy" : "d8c7cf80-a55a-474c-a4f4-f60a9efda52c",
        "tags" : [
        ]
      },
      {
        "id" : "99ec811d-9aed-4bfa-b11b-0486fea727fa",
        "parentId" : "a08a796e-8896-4dae-871f-a7b5b0b9a892",
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "We don't add calls -- this call was always there and we need to keep it for backward compatibility until we remove those methods (by making them private).",
        "createdAt" : "2018-11-28T19:37:56Z",
        "updatedAt" : "2018-12-11T09:51:36Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      }
    ],
    "commit" : "c9c692fa9804850c0cdd372d825db005bf3851f8",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +179,183 @@    }\n\n    @SuppressWarnings(\"deprecation\")\n    @Override\n    public Cancellable schedule(final Duration interval,"
  },
  {
    "id" : "855f67f5-f884-4c80-b7f2-f5fbab21cc1b",
    "prId" : 6016,
    "prUrl" : "https://github.com/apache/kafka/pull/6016#pullrequestreview-183196921",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1ebddb57-717c-4ac4-bc25-80115bb8d609",
        "parentId" : null,
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "Good catch!",
        "createdAt" : "2018-12-10T14:16:45Z",
        "updatedAt" : "2018-12-10T16:11:13Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      }
    ],
    "commit" : "6e2ba437831d97e39916c5e6f99380ccde4a2168",
    "line" : 195,
    "diffHunk" : "@@ -1,1 +357,361 @@\n        @Override\n        public KeyValueIterator<Windowed<K>, AGG> fetch(final K from, final K to) {\n            return getInner().fetch(from, to);\n        }"
  },
  {
    "id" : "8853ef77-0bf4-499d-bf71-a6350124baf8",
    "prId" : 6173,
    "prUrl" : "https://github.com/apache/kafka/pull/6173#pullrequestreview-197971519",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "85c34186-b8b3-4885-96b6-e218894ee514",
        "parentId" : null,
        "authorId" : "4c968502-bb3d-46ee-8719-0c0bdbc6242f",
        "body" : "Since the new classes are static maybe they could go in their own package along with the other pre-existing `decorators`? Probably not on this PR but in a follow-up.",
        "createdAt" : "2019-01-30T07:42:37Z",
        "updatedAt" : "2019-03-07T22:13:34Z",
        "lastEditedBy" : "4c968502-bb3d-46ee-8719-0c0bdbc6242f",
        "tags" : [
        ]
      },
      {
        "id" : "1495c0fd-0ae4-43de-97eb-2141b49353f4",
        "parentId" : "85c34186-b8b3-4885-96b6-e218894ee514",
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "I am open to add new packages -- @vvcephei was suggestion this too (for example for RocksDB classes). I would prefer to do this a follow up PRs (it's internal anyway).",
        "createdAt" : "2019-01-30T09:20:43Z",
        "updatedAt" : "2019-03-07T22:13:34Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      }
    ],
    "commit" : "5a3613b4a03c0e0caa683f19026aca726248d191",
    "line" : 31,
    "diffHunk" : "@@ -1,1 +346,350 @@    }\n\n    private static class TimestampedWindowStoreReadOnlyDecorator<K, V>\n        extends WindowStoreReadOnlyDecorator<K, ValueAndTimestamp<V>>\n        implements TimestampedWindowStore<K, V> {"
  },
  {
    "id" : "6c800f17-244e-4a5b-a068-40fbff80eb46",
    "prId" : 6255,
    "prUrl" : "https://github.com/apache/kafka/pull/6255#pullrequestreview-203043571",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0a0d15dd-a607-4b7e-80ba-2d76dcec555d",
        "parentId" : null,
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "This is a meta thought orthogonal to this PR, but I'd leave it here and then create a JIRA ticket later: The `StateStore` interface is really designed to be \"implemented by users, and called by library\" -- maybe one can argue that users may want to explicitly call `flush` as well, but I'd say it is okay to NOT allow users do so. And the extended interface, like `KeyValueStore` are designed to be \"implemented by library or user-customizable, and called by user\".\r\n\r\nGiven this thought, we should probably consider refactoring the hierarchy of state stores more as:\r\n\r\n1) `interface StateStore`\r\n2) `interface ReadOnlyKeyValueStore`\r\n3) `interface KeyValueStateStore extends StateStore, ReadOnlyKeyValueStore` (note the name difference)\r\n4) `interface KeyValueStore extends ReadOnlyKeyValueStore`.\r\n\r\nAnd 3) would be the one used in `Stores` factory, i.e. required for either built-in or user-customization, while 4) would be the one returned from `ProcessorContext.getStateStore`. The returned object would, in fact, always be extending `StateStore` as well but only library will care to cast and call its inner functions.\r\n\r\nI'm not sure if there's a better way to do this in order to get rid of all such decorators, @vvcephei wdyt?",
        "createdAt" : "2019-02-12T01:48:03Z",
        "updatedAt" : "2019-02-13T14:39:33Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "cd93cfec-31f9-4eb4-b799-8b1371e8eb3a",
        "parentId" : "0a0d15dd-a607-4b7e-80ba-2d76dcec555d",
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "While I completely agree (all the \"decorators\" are only necessary because we got the API wrong, leaking \"internal\" API like `flush()`, `close()` etc into PAPI).\r\n\r\nHowever, I this possible to refactor without breaking the public API?",
        "createdAt" : "2019-02-12T19:46:24Z",
        "updatedAt" : "2019-02-13T14:39:33Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "4c3a3c7e-b76f-4196-8bb5-ebc99de21a8b",
        "parentId" : "0a0d15dd-a607-4b7e-80ba-2d76dcec555d",
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "I agree 100%, and would very much like to see something like this. It would also help us to avoid leaking other administrative methods if we add them (besides just `init`, `flush`, `close`).\r\n\r\nI think cleanest the way to do it backwards compatibly is to introduce a new store hierarchy and deprecate the old one.",
        "createdAt" : "2019-02-12T23:19:57Z",
        "updatedAt" : "2019-02-13T14:39:33Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      },
      {
        "id" : "57ec7d8e-29dd-4bc6-ad09-46c3e0faf181",
        "parentId" : "0a0d15dd-a607-4b7e-80ba-2d76dcec555d",
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "> I think cleanest the way to do it backwards compatibly is to introduce a new store hierarchy and deprecate the old one.\r\n\r\nI am afraid that might be the only way to do it -- deprecation hell -- users won't be happy -- thus we should think hard if it's worth to do or not...",
        "createdAt" : "2019-02-13T00:33:58Z",
        "updatedAt" : "2019-02-13T14:39:33Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "a563f42c-e126-44ae-a960-e3582cc8e73d",
        "parentId" : "0a0d15dd-a607-4b7e-80ba-2d76dcec555d",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "Cool, I will create a JIRA ticket for now to keep track of it.",
        "createdAt" : "2019-02-13T06:15:42Z",
        "updatedAt" : "2019-02-13T14:39:33Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      }
    ],
    "commit" : "1e871f2a26bed0701a074e91e41c4e47f48f6b9e",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +215,219 @@    }\n\n    private abstract static class StateStoreReadOnlyDecorator<T extends StateStore> extends WrappedStateStore<T> {\n        static final String ERROR_MESSAGE = \"Global store is read only\";\n"
  },
  {
    "id" : "f46be6ae-1198-4c5c-8936-2c5f9540a91d",
    "prId" : 6393,
    "prUrl" : "https://github.com/apache/kafka/pull/6393#pullrequestreview-212510179",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "279d995f-a0a5-460c-96c4-2f2acecfa064",
        "parentId" : null,
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "Should we consider saving/restoring the whole record context, just in case downstream processors have changed other parts of the context, not just the timestamp?",
        "createdAt" : "2019-03-08T22:18:52Z",
        "updatedAt" : "2019-03-08T22:18:52Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      },
      {
        "id" : "49f86c2c-598f-41b8-911a-e9b08863d3ae",
        "parentId" : "279d995f-a0a5-460c-96c4-2f2acecfa064",
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "Headers work differently. Users would mutate the input record header so they understand that the header changes.\r\n\r\nWe can still address it (I agree that the current header API is not great) but I would exclude it from this PR. Feel free to create a ticket for it.",
        "createdAt" : "2019-03-08T22:31:46Z",
        "updatedAt" : "2019-03-08T22:31:46Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "0a51f382-772e-4e02-8217-323850d7eb3a",
        "parentId" : "279d995f-a0a5-460c-96c4-2f2acecfa064",
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "Ah, this is a good point. I was thinking that downstream processors were directly manipulating the record context, but if they do that, it's clearly their responsibility to restore it when they're done.\r\n\r\nI think I won't bother with a ticket right now, it seems like the mutable-headers thing is actually just part of the key and value also being mutable. Plus, there's a bunch of other stuff that's not well defined about header handling in Streams. It seems like altogether too much to scope in a ticket without investing some serious design work up front.\r\n\r\nI think the current change is fine as-is. Thanks!",
        "createdAt" : "2019-03-08T22:40:09Z",
        "updatedAt" : "2019-03-08T22:40:09Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      }
    ],
    "commit" : "b3cfc1ac9a0bcf35d5346461bd070315f89a1c7f",
    "line" : 24,
    "diffHunk" : "@@ -1,1 +171,175 @@            }\n        } finally {\n            recordContext.timestamp = currentTimestamp;\n            setCurrentNode(previousNode);\n        }"
  },
  {
    "id" : "b8ebc968-d346-44b6-87e2-5fa10e9a56af",
    "prId" : 6645,
    "prUrl" : "https://github.com/apache/kafka/pull/6645#pullrequestreview-236281841",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c0cfeaa8-faec-411e-9921-cca4c59ce210",
        "parentId" : null,
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "@vvcephei I put this fix to make `ProcessorRecordContext` immutable -- however, after you comment about headers being mutable, I am wondering if this is an issue we need to address here or not. Maybe not, because it's a general issue and the users responsibility to deep-copy headers is they are modified. Just wanted to double check and point it out.",
        "createdAt" : "2019-05-10T19:42:31Z",
        "updatedAt" : "2019-05-12T13:26:58Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      }
    ],
    "commit" : "43873294c59da42142246aa9c261e0f903f0f3d4",
    "line" : 16,
    "diffHunk" : "@@ -1,1 +171,175 @@                    recordContext.partition(),\n                    recordContext.topic(),\n                    recordContext.headers());\n            }\n"
  },
  {
    "id" : "04c6a816-d27d-49de-b2d9-25bb14f3f350",
    "prId" : 8251,
    "prUrl" : "https://github.com/apache/kafka/pull/8251#pullrequestreview-371742271",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "72e1b492-ff6c-41c1-8e9c-b7de1d8982ad",
        "parentId" : null,
        "authorId" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "body" : "What's the purpose of adding generic here?",
        "createdAt" : "2020-03-09T04:38:52Z",
        "updatedAt" : "2020-03-10T18:18:24Z",
        "lastEditedBy" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "tags" : [
        ]
      },
      {
        "id" : "7f41ee60-d1ca-4168-95c8-62f6eb423df4",
        "parentId" : "72e1b492-ff6c-41c1-8e9c-b7de1d8982ad",
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "To avoid warnings about \"raw type\" usage. Gradle does not fail on this, but IntelliJ highlights it, and it's best practice to avoid \"raw types\"",
        "createdAt" : "2020-03-10T08:07:42Z",
        "updatedAt" : "2020-03-10T18:18:24Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      }
    ],
    "commit" : "6520dc7a626c4049a56d436e0cde9b7bfeaa73a7",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +86,90 @@        if (global != null) {\n            if (global instanceof TimestampedKeyValueStore) {\n                return new TimestampedKeyValueStoreReadOnlyDecorator<>((TimestampedKeyValueStore<?, ?>) global);\n            } else if (global instanceof KeyValueStore) {\n                return new KeyValueStoreReadOnlyDecorator<>((KeyValueStore<?, ?>) global);"
  },
  {
    "id" : "037e95fb-19b0-43ef-81db-b91d8a1740c9",
    "prId" : 8251,
    "prUrl" : "https://github.com/apache/kafka/pull/8251#pullrequestreview-371745844",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "932f72b2-ac0e-48f7-a1e2-0df88dd034f7",
        "parentId" : null,
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "Could you left some comments on the places you remove the casting to explain why it's okay to do so?",
        "createdAt" : "2020-03-09T17:36:12Z",
        "updatedAt" : "2020-03-10T18:18:24Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "f193dc43-20c7-4856-9668-8b8db6a3056e",
        "parentId" : "932f72b2-ac0e-48f7-a1e2-0df88dd034f7",
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "I rely on IntelliJ -- it highlight all redundant casts. For this case, the return type of `children()` is `List<ProcessorNode<?, ?>>` and thus no reason to cast.",
        "createdAt" : "2020-03-10T08:15:07Z",
        "updatedAt" : "2020-03-10T18:18:24Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      }
    ],
    "commit" : "6520dc7a626c4049a56d436e0cde9b7bfeaa73a7",
    "line" : 68,
    "diffHunk" : "@@ -1,1 +140,144 @@            key,\n            value,\n            To.child((currentNode().children()).get(childIndex).name()));\n    }\n"
  },
  {
    "id" : "5fab2785-74c4-4e7e-ac77-1c9863c093b9",
    "prId" : 8251,
    "prUrl" : "https://github.com/apache/kafka/pull/8251#pullrequestreview-372288120",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3c901177-85aa-4224-aba5-c7aef6083fcf",
        "parentId" : null,
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "Hmm, not clear about this change -- seems we are just delaying the casting by two lines of code here?",
        "createdAt" : "2020-03-09T17:58:43Z",
        "updatedAt" : "2020-03-10T18:18:24Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "870e198e-1de4-481b-9913-16dc16e9e9c1",
        "parentId" : "3c901177-85aa-4224-aba5-c7aef6083fcf",
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "That is somewhat correct, but it make its explicit in the code _where_ the actual cast happens and this if there is an issue easier to debug. With \"raw types\" is totally unclear where cast actually take place.",
        "createdAt" : "2020-03-10T08:16:13Z",
        "updatedAt" : "2020-03-10T18:18:24Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "3244a410-eeca-4c6f-81e1-b38eac850d87",
        "parentId" : "3c901177-85aa-4224-aba5-c7aef6083fcf",
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "The compiler inserts cast lazily and it's better the track it down where the compiler needs (and will) insert cast (if raw types are used) by avoiding raw types and specifying the cast explicitly in the code where necessary.",
        "createdAt" : "2020-03-10T08:17:55Z",
        "updatedAt" : "2020-03-10T18:18:24Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "d7b097b7-32fd-49d0-a158-29d9f8b98c13",
        "parentId" : "3c901177-85aa-4224-aba5-c7aef6083fcf",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "Sounds good.",
        "createdAt" : "2020-03-10T20:15:14Z",
        "updatedAt" : "2020-03-10T20:15:14Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      }
    ],
    "commit" : "6520dc7a626c4049a56d436e0cde9b7bfeaa73a7",
    "line" : 91,
    "diffHunk" : "@@ -1,1 +172,176 @@            final String sendTo = toInternal.child();\n            if (sendTo == null) {\n                final List<ProcessorNode<?, ?>> children = currentNode().children();\n                for (final ProcessorNode<?, ?> child : children) {\n                    forward((ProcessorNode<K, V>) child, key, value);"
  },
  {
    "id" : "0857b5f7-5de8-4b4a-912f-f30f408ea014",
    "prId" : 8669,
    "prUrl" : "https://github.com/apache/kafka/pull/8669#pullrequestreview-413032013",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "89323680-c1c5-4565-90fa-010cee1ca7ae",
        "parentId" : null,
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "nit: we can add a validation that if streamTask != null then stateMgr.taskType() == ACTIVE.",
        "createdAt" : "2020-05-16T00:59:12Z",
        "updatedAt" : "2020-05-18T16:57:45Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      }
    ],
    "commit" : "f807b4f8da716905265a37eb0a2966496781cae4",
    "line" : 63,
    "diffHunk" : "@@ -1,1 +60,64 @@                         final ThreadCache cache) {\n        super(id, config, metrics, stateMgr, cache);\n        this.streamTask = streamTask;\n        this.collector = collector;\n"
  },
  {
    "id" : "bb6b6580-ee9b-4009-8f10-619bb05a206d",
    "prId" : 8669,
    "prUrl" : "https://github.com/apache/kafka/pull/8669#pullrequestreview-413550470",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e0134ee1-311c-4ba5-a5ed-9d953d063b0c",
        "parentId" : null,
        "authorId" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "body" : "req: Please unit test a processor context for a standby with the unsupported methods. That is, all code paths that involve a call to `throwUnsupportedOperationExceptionIfStandby()`.   ",
        "createdAt" : "2020-05-18T12:35:41Z",
        "updatedAt" : "2020-05-18T16:57:45Z",
        "lastEditedBy" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "tags" : [
        ]
      }
    ],
    "commit" : "f807b4f8da716905265a37eb0a2966496781cae4",
    "line" : 112,
    "diffHunk" : "@@ -1,1 +108,112 @@                          final byte[] value,\n                          final long timestamp) {\n        throwUnsupportedOperationExceptionIfStandby(\"logChange\");\n        // Sending null headers to changelog topics (KIP-244)\n        collector.send("
  },
  {
    "id" : "8e608d8f-06be-4c90-98e3-d12f0bc3981e",
    "prId" : 8882,
    "prUrl" : "https://github.com/apache/kafka/pull/8882#pullrequestreview-431929185",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "02f8f7f3-ac11-4599-b28e-d2d0803f7d52",
        "parentId" : null,
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "This previously relied on a lookup of the actual current system time. I thought we decided to use the cached system time. Can you set me straight, @ableegoldman ?",
        "createdAt" : "2020-06-16T20:15:44Z",
        "updatedAt" : "2020-06-17T03:42:08Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      },
      {
        "id" : "a6da21f8-cd84-425c-85ea-bd0058cc4480",
        "parentId" : "02f8f7f3-ac11-4599-b28e-d2d0803f7d52",
        "authorId" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "body" : "Oh, hm, I thought we decided to push the stateful-node-level metrics to TRACE so we could get the actual time at each node without a (potential) performance hit. But with the INFO-level metrics it would be ok since we're only updating it twice per process.\r\nBut maybe I'm misremembering...I suppose ideally we could run some benchmarks for both cases and see if it really makes a difference...",
        "createdAt" : "2020-06-16T21:54:11Z",
        "updatedAt" : "2020-06-17T03:42:08Z",
        "lastEditedBy" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "tags" : [
        ]
      },
      {
        "id" : "5fdb8bdd-c4be-47d1-939b-c3241c05c38e",
        "parentId" : "02f8f7f3-ac11-4599-b28e-d2d0803f7d52",
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "Ok, but right now, this is an INFO level metric, right?",
        "createdAt" : "2020-06-16T22:06:28Z",
        "updatedAt" : "2020-06-17T03:42:08Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      },
      {
        "id" : "2aed8eaa-cfd8-4bb0-acc9-72887d418fdc",
        "parentId" : "02f8f7f3-ac11-4599-b28e-d2d0803f7d52",
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "This will probably need to get refactored when you do the second PR.",
        "createdAt" : "2020-06-16T22:10:30Z",
        "updatedAt" : "2020-06-17T03:42:08Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      },
      {
        "id" : "d4d1a5e5-851a-462f-bf4c-c5f4c83ba7fd",
        "parentId" : "02f8f7f3-ac11-4599-b28e-d2d0803f7d52",
        "authorId" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "body" : "Yeah. I'm just not 100% sure we all agreed it was alright to get the actual system time even for the task-level metrics ... so we should probably stick with the cached time for now",
        "createdAt" : "2020-06-16T22:13:38Z",
        "updatedAt" : "2020-06-17T03:42:08Z",
        "lastEditedBy" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "tags" : [
        ]
      }
    ],
    "commit" : "ae1a3908bcaad82e30ad35a0e4462d7a4b7978b5",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +236,240 @@        child.process(key, value);\n        if (child.isTerminalNode()) {\n            streamTask.maybeRecordE2ELatency(timestamp(), currentSystemTimeMs(), child.name());\n        }\n    }"
  },
  {
    "id" : "1c40af58-1c48-4636-a3b7-9fbb238bd534",
    "prId" : 9083,
    "prUrl" : "https://github.com/apache/kafka/pull/9083#pullrequestreview-499694308",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2bddf099-0730-4bde-9f14-191b55d29b17",
        "parentId" : null,
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "@guozhangwang It's weird to remove the types above and add a cast here. Seems like a step backward with regard to type safety. Not sure if @vvcephei's changes would fix it?",
        "createdAt" : "2020-09-30T18:15:54Z",
        "updatedAt" : "2020-09-30T18:15:55Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      }
    ],
    "commit" : "e2ca04a7452c3aa18a4995e8a8c8a65d3a5354ed",
    "line" : 11,
    "diffHunk" : "@@ -1,1 +223,227 @@                        + \" either does not exist or is not connected to this processor.\");\n                }\n                forward((ProcessorNode<K, V, ?, ?>) child, key, value);\n            }\n        } finally {"
  },
  {
    "id" : "ea60f54e-e0a4-46af-9464-5c2083608eb9",
    "prId" : 9361,
    "prUrl" : "https://github.com/apache/kafka/pull/9361#pullrequestreview-501314687",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7ae51a32-c3a8-4a1a-9fdf-c4d4f8ad9166",
        "parentId" : null,
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "I was hoping that with the new strong typing API, during forwarding we do not need to cast to `(ProcessorNode<K, V, ?, ?>)` and not need this suppression any more.. Could we add the typing into `currentNode` (e.g. validate that the currentNode.children is indeed in `K, V`) instead of force casting?",
        "createdAt" : "2020-10-01T23:48:41Z",
        "updatedAt" : "2020-10-02T15:50:27Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "ad82c39b-440d-47b1-88ab-dce651c38dc0",
        "parentId" : "7ae51a32-c3a8-4a1a-9fdf-c4d4f8ad9166",
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "I'll have to think about this, but offhand, it doesn't seem like that would work.\r\n\r\nIn general, the type safety we're providing is on the user side of the PAPI (of course, the DSL internals is a user of the PAPI). On the internals side of the PAPI implementation, we generally can't get any more safety. For example, the ProcessorContextImpl is instantiated for the whole Task, which would handle a number of different record types and ProcessorNode types, so the internal implementation of the ProcessorContextImpl would have to be agnostic wrt the actual types of the nodes.\r\n\r\nI think that by the time I'm done with the full implementation of this KIP, you'll see most of the unchecked suppressions and casts gone from the DSL implementation, but there will still be some in classes like this one.",
        "createdAt" : "2020-10-02T03:35:17Z",
        "updatedAt" : "2020-10-02T15:50:27Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      },
      {
        "id" : "00fcaba6-b8f2-466d-b8fc-6baedad49137",
        "parentId" : "7ae51a32-c3a8-4a1a-9fdf-c4d4f8ad9166",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "What I'm wondering is that, within a processor node of `<KIn, VIn, KOut, VOut>`, if a `context.forward()` is called with `Record<KOut2, VOut2>`, would we only throw a casting exception at runtime, or we could capture this at compiler time. From this suppression it seems we still cannot achieve the former.. do you think this can be improved alongside with this KIP too?",
        "createdAt" : "2020-10-02T03:52:20Z",
        "updatedAt" : "2020-10-02T15:50:27Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "f3bfd36a-ad22-4f43-9f16-be8839fd4491",
        "parentId" : "7ae51a32-c3a8-4a1a-9fdf-c4d4f8ad9166",
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "I see.\r\n\r\nSo, _within_ the `Processor<KIn, Vin, KOut, VOut>`, the `ProcessorContext` is bounded to `<KOut, VOut>`, and therefore `forward` will only accept a `Record<KOut, VOut>`. The compiler will check the source code of the processor and enforce this at compile time. It sounds like this is one part of what you are thinking about.\r\n\r\nBut inside the `ProcessorContextImpl`, we're _outside_ of the `Processor`, and in the \"plumbing\" of Streams. In this context, we cannot have compile-time type safety, since we can't bound all of KafkaStreams to accept only one kind of record and processor.\r\n\r\nHowever, what we can check at compile time is that we only attach _compatible_ children to parents. This isn't a way to do this in `Topology` right now, and I didn't want to expand this KIP to that extent. My plan for getting the full benefit of this KIP in the DSL internals is to actually add an internal utility method for registering pairs of processors, like this:\r\n```java\r\n    void addGraphNode(final StreamsGraphNode<KIn, VIn, KIntermediate, VIntermediate> parent,\r\n                      final StreamsGraphNode<KIntermediate, VIntermediate, KOut, VOut> child);\r\n```\r\nThen, in addition to a compile-time guarantee that a processor can only forward its declared output type, we also get a guarantee that the builder can only attach compatible parent-child pairs. Assuming you don't do any casting in \"user space\",\r\nwe don't need any further compiler checking to render cast exceptions impossible. The \"plumbing code\" like in this `ProcessorContextImpl` is akin to the JVM runtime after type erasure... the \"compiler\" has already done its job on the \"source code\" (the user-facing side of the PAPI), so we don't need the types anymore at \"run time\".",
        "createdAt" : "2020-10-02T16:06:35Z",
        "updatedAt" : "2020-10-02T16:06:35Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      },
      {
        "id" : "b7be8b8c-e665-48e6-b932-9f421b616253",
        "parentId" : "7ae51a32-c3a8-4a1a-9fdf-c4d4f8ad9166",
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "I think it would have been nice to get some kind of public-facing API into `Topology` like what I quoted above, but at this point, I think we can just cut scope on KIP-478 and implement it for 2.7 as-is. Then, we can follow up with a new KIP to add some kind of `Topology#attachChildToParent` API in a later KIP).\r\n\r\nAside from cutting scope, I wanted to do it as an internal API while migrating the DSL internals so I could be sure the \"attach\" method is really the best approach.",
        "createdAt" : "2020-10-02T16:09:36Z",
        "updatedAt" : "2020-10-02T16:09:37Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      },
      {
        "id" : "aa5011ee-c731-4187-be41-1d7426dc6879",
        "parentId" : "7ae51a32-c3a8-4a1a-9fdf-c4d4f8ad9166",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "Thanks for your thoughts, and I agree it is too stretch for KIP-478 to extend to that. Let's just keep it as is now.",
        "createdAt" : "2020-10-02T17:21:54Z",
        "updatedAt" : "2020-10-02T17:21:55Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      }
    ],
    "commit" : "a8de75f6f16cf8bdcccbcb1bc1fc0a11dd40c1d1",
    "line" : 133,
    "diffHunk" : "@@ -1,1 +220,224 @@    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public <K, V> void forward(final Record<K, V> record, final String childName) {"
  },
  {
    "id" : "e21577ff-a910-48ca-86b6-0d0437745f2f",
    "prId" : 9361,
    "prUrl" : "https://github.com/apache/kafka/pull/9361#pullrequestreview-500843018",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ec443f9d-5250-4fd2-94e3-df55b150bfc2",
        "parentId" : null,
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "Why we'd need to add this suppression?",
        "createdAt" : "2020-10-01T23:49:02Z",
        "updatedAt" : "2020-10-02T15:50:27Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "6ecfebba-e0dd-4347-9938-728aebae42f8",
        "parentId" : "ec443f9d-5250-4fd2-94e3-df55b150bfc2",
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "It's because we're returning a subtype of StateStore now, but the stores are still internally not typed, so someone still has to cast it.\r\n\r\nFor example, here's what the old API was like:\r\n```java\r\nKeyValueStore<String, Integer> store = (KeyValueStore<String, Integer>) context.getStateStore(\"asdf\");\r\n```\r\nThe cast is in the user's code.\r\n\r\nNow, it will be like this:\r\n```java\r\nKeyValueStore<String, Integer> store = context.getStateStore(\"asdf\");\r\n```\r\nThe return type is resolved by the type system, and the cast moves into our code.\r\n\r\nJust to clarify, there's no extra safety here, it's a cast either way. It's just more convenient for callers not to have to cast on their end.",
        "createdAt" : "2020-10-02T03:27:32Z",
        "updatedAt" : "2020-10-02T15:50:27Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      },
      {
        "id" : "90df5cd1-1c61-430a-bf44-f41f6eff12a2",
        "parentId" : "ec443f9d-5250-4fd2-94e3-df55b150bfc2",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "Got it, thanks!",
        "createdAt" : "2020-10-02T03:32:16Z",
        "updatedAt" : "2020-10-02T15:50:27Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      }
    ],
    "commit" : "a8de75f6f16cf8bdcccbcb1bc1fc0a11dd40c1d1",
    "line" : 42,
    "diffHunk" : "@@ -1,1 +133,137 @@     * @throws UnsupportedOperationException if the current streamTask type is standby\n     */\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public <S extends StateStore> S  getStateStore(final String name) {"
  }
]
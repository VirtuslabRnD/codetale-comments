[
  {
    "id" : "2e3f3e6d-1df1-4ba3-98cb-ca35a889128c",
    "prId" : 5954,
    "prUrl" : "https://github.com/apache/kafka/pull/5954#pullrequestreview-179480273",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a08a796e-8896-4dae-871f-a7b5b0b9a892",
        "parentId" : null,
        "authorId" : "d8c7cf80-a55a-474c-a4f4-f60a9efda52c",
        "body" : "Again, why are we adding calls to deprecated code?",
        "createdAt" : "2018-11-28T08:59:52Z",
        "updatedAt" : "2018-12-11T09:51:36Z",
        "lastEditedBy" : "d8c7cf80-a55a-474c-a4f4-f60a9efda52c",
        "tags" : [
        ]
      },
      {
        "id" : "99ec811d-9aed-4bfa-b11b-0486fea727fa",
        "parentId" : "a08a796e-8896-4dae-871f-a7b5b0b9a892",
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "We don't add calls -- this call was always there and we need to keep it for backward compatibility until we remove those methods (by making them private).",
        "createdAt" : "2018-11-28T19:37:56Z",
        "updatedAt" : "2018-12-11T09:51:36Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      }
    ],
    "commit" : "c9c692fa9804850c0cdd372d825db005bf3851f8",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +179,183 @@    }\n\n    @SuppressWarnings(\"deprecation\")\n    @Override\n    public Cancellable schedule(final Duration interval,"
  },
  {
    "id" : "855f67f5-f884-4c80-b7f2-f5fbab21cc1b",
    "prId" : 6016,
    "prUrl" : "https://github.com/apache/kafka/pull/6016#pullrequestreview-183196921",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1ebddb57-717c-4ac4-bc25-80115bb8d609",
        "parentId" : null,
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "Good catch!",
        "createdAt" : "2018-12-10T14:16:45Z",
        "updatedAt" : "2018-12-10T16:11:13Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      }
    ],
    "commit" : "6e2ba437831d97e39916c5e6f99380ccde4a2168",
    "line" : 195,
    "diffHunk" : "@@ -1,1 +357,361 @@\n        @Override\n        public KeyValueIterator<Windowed<K>, AGG> fetch(final K from, final K to) {\n            return getInner().fetch(from, to);\n        }"
  },
  {
    "id" : "8853ef77-0bf4-499d-bf71-a6350124baf8",
    "prId" : 6173,
    "prUrl" : "https://github.com/apache/kafka/pull/6173#pullrequestreview-197971519",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "85c34186-b8b3-4885-96b6-e218894ee514",
        "parentId" : null,
        "authorId" : "4c968502-bb3d-46ee-8719-0c0bdbc6242f",
        "body" : "Since the new classes are static maybe they could go in their own package along with the other pre-existing `decorators`? Probably not on this PR but in a follow-up.",
        "createdAt" : "2019-01-30T07:42:37Z",
        "updatedAt" : "2019-03-07T22:13:34Z",
        "lastEditedBy" : "4c968502-bb3d-46ee-8719-0c0bdbc6242f",
        "tags" : [
        ]
      },
      {
        "id" : "1495c0fd-0ae4-43de-97eb-2141b49353f4",
        "parentId" : "85c34186-b8b3-4885-96b6-e218894ee514",
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "I am open to add new packages -- @vvcephei was suggestion this too (for example for RocksDB classes). I would prefer to do this a follow up PRs (it's internal anyway).",
        "createdAt" : "2019-01-30T09:20:43Z",
        "updatedAt" : "2019-03-07T22:13:34Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      }
    ],
    "commit" : "5a3613b4a03c0e0caa683f19026aca726248d191",
    "line" : 31,
    "diffHunk" : "@@ -1,1 +346,350 @@    }\n\n    private static class TimestampedWindowStoreReadOnlyDecorator<K, V>\n        extends WindowStoreReadOnlyDecorator<K, ValueAndTimestamp<V>>\n        implements TimestampedWindowStore<K, V> {"
  },
  {
    "id" : "6c800f17-244e-4a5b-a068-40fbff80eb46",
    "prId" : 6255,
    "prUrl" : "https://github.com/apache/kafka/pull/6255#pullrequestreview-203043571",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0a0d15dd-a607-4b7e-80ba-2d76dcec555d",
        "parentId" : null,
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "This is a meta thought orthogonal to this PR, but I'd leave it here and then create a JIRA ticket later: The `StateStore` interface is really designed to be \"implemented by users, and called by library\" -- maybe one can argue that users may want to explicitly call `flush` as well, but I'd say it is okay to NOT allow users do so. And the extended interface, like `KeyValueStore` are designed to be \"implemented by library or user-customizable, and called by user\".\r\n\r\nGiven this thought, we should probably consider refactoring the hierarchy of state stores more as:\r\n\r\n1) `interface StateStore`\r\n2) `interface ReadOnlyKeyValueStore`\r\n3) `interface KeyValueStateStore extends StateStore, ReadOnlyKeyValueStore` (note the name difference)\r\n4) `interface KeyValueStore extends ReadOnlyKeyValueStore`.\r\n\r\nAnd 3) would be the one used in `Stores` factory, i.e. required for either built-in or user-customization, while 4) would be the one returned from `ProcessorContext.getStateStore`. The returned object would, in fact, always be extending `StateStore` as well but only library will care to cast and call its inner functions.\r\n\r\nI'm not sure if there's a better way to do this in order to get rid of all such decorators, @vvcephei wdyt?",
        "createdAt" : "2019-02-12T01:48:03Z",
        "updatedAt" : "2019-02-13T14:39:33Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "cd93cfec-31f9-4eb4-b799-8b1371e8eb3a",
        "parentId" : "0a0d15dd-a607-4b7e-80ba-2d76dcec555d",
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "While I completely agree (all the \"decorators\" are only necessary because we got the API wrong, leaking \"internal\" API like `flush()`, `close()` etc into PAPI).\r\n\r\nHowever, I this possible to refactor without breaking the public API?",
        "createdAt" : "2019-02-12T19:46:24Z",
        "updatedAt" : "2019-02-13T14:39:33Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "4c3a3c7e-b76f-4196-8bb5-ebc99de21a8b",
        "parentId" : "0a0d15dd-a607-4b7e-80ba-2d76dcec555d",
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "I agree 100%, and would very much like to see something like this. It would also help us to avoid leaking other administrative methods if we add them (besides just `init`, `flush`, `close`).\r\n\r\nI think cleanest the way to do it backwards compatibly is to introduce a new store hierarchy and deprecate the old one.",
        "createdAt" : "2019-02-12T23:19:57Z",
        "updatedAt" : "2019-02-13T14:39:33Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      },
      {
        "id" : "57ec7d8e-29dd-4bc6-ad09-46c3e0faf181",
        "parentId" : "0a0d15dd-a607-4b7e-80ba-2d76dcec555d",
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "> I think cleanest the way to do it backwards compatibly is to introduce a new store hierarchy and deprecate the old one.\r\n\r\nI am afraid that might be the only way to do it -- deprecation hell -- users won't be happy -- thus we should think hard if it's worth to do or not...",
        "createdAt" : "2019-02-13T00:33:58Z",
        "updatedAt" : "2019-02-13T14:39:33Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "a563f42c-e126-44ae-a960-e3582cc8e73d",
        "parentId" : "0a0d15dd-a607-4b7e-80ba-2d76dcec555d",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "Cool, I will create a JIRA ticket for now to keep track of it.",
        "createdAt" : "2019-02-13T06:15:42Z",
        "updatedAt" : "2019-02-13T14:39:33Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      }
    ],
    "commit" : "1e871f2a26bed0701a074e91e41c4e47f48f6b9e",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +215,219 @@    }\n\n    private abstract static class StateStoreReadOnlyDecorator<T extends StateStore> extends WrappedStateStore<T> {\n        static final String ERROR_MESSAGE = \"Global store is read only\";\n"
  },
  {
    "id" : "f46be6ae-1198-4c5c-8936-2c5f9540a91d",
    "prId" : 6393,
    "prUrl" : "https://github.com/apache/kafka/pull/6393#pullrequestreview-212510179",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "279d995f-a0a5-460c-96c4-2f2acecfa064",
        "parentId" : null,
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "Should we consider saving/restoring the whole record context, just in case downstream processors have changed other parts of the context, not just the timestamp?",
        "createdAt" : "2019-03-08T22:18:52Z",
        "updatedAt" : "2019-03-08T22:18:52Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      },
      {
        "id" : "49f86c2c-598f-41b8-911a-e9b08863d3ae",
        "parentId" : "279d995f-a0a5-460c-96c4-2f2acecfa064",
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "Headers work differently. Users would mutate the input record header so they understand that the header changes.\r\n\r\nWe can still address it (I agree that the current header API is not great) but I would exclude it from this PR. Feel free to create a ticket for it.",
        "createdAt" : "2019-03-08T22:31:46Z",
        "updatedAt" : "2019-03-08T22:31:46Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "0a51f382-772e-4e02-8217-323850d7eb3a",
        "parentId" : "279d995f-a0a5-460c-96c4-2f2acecfa064",
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "Ah, this is a good point. I was thinking that downstream processors were directly manipulating the record context, but if they do that, it's clearly their responsibility to restore it when they're done.\r\n\r\nI think I won't bother with a ticket right now, it seems like the mutable-headers thing is actually just part of the key and value also being mutable. Plus, there's a bunch of other stuff that's not well defined about header handling in Streams. It seems like altogether too much to scope in a ticket without investing some serious design work up front.\r\n\r\nI think the current change is fine as-is. Thanks!",
        "createdAt" : "2019-03-08T22:40:09Z",
        "updatedAt" : "2019-03-08T22:40:09Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      }
    ],
    "commit" : "b3cfc1ac9a0bcf35d5346461bd070315f89a1c7f",
    "line" : 24,
    "diffHunk" : "@@ -1,1 +171,175 @@            }\n        } finally {\n            recordContext.timestamp = currentTimestamp;\n            setCurrentNode(previousNode);\n        }"
  }
]
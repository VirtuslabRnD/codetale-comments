[
  {
    "id" : "8ebeda93-cc5a-442d-9645-3a60987d8396",
    "prId" : 5450,
    "prUrl" : "https://github.com/apache/kafka/pull/5450#pullrequestreview-142958657",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "28799ed9-7610-4093-bdb4-e246996ee357",
        "parentId" : null,
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "These lines are a little long, but they're also very uniform. Should I split them?",
        "createdAt" : "2018-08-02T18:40:26Z",
        "updatedAt" : "2018-08-03T22:17:02Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      },
      {
        "id" : "808de374-032b-47e0-84a9-0b22db4ae805",
        "parentId" : "28799ed9-7610-4093-bdb4-e246996ee357",
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "I am fine both ways.",
        "createdAt" : "2018-08-02T20:22:58Z",
        "updatedAt" : "2018-08-03T22:17:02Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      }
    ],
    "commit" : "b590af4726d2e4fc3bf1186676f6f9015388cd3e",
    "line" : 110,
    "diffHunk" : "@@ -1,1 +103,107 @@        flushTime = createTaskAndStoreLatencyAndThroughputSensors(DEBUG, \"flush\", metrics, metricsGroup, taskName, name(), taskTags, storeTags);\n        deleteTime = createTaskAndStoreLatencyAndThroughputSensors(DEBUG, \"delete\", metrics, metricsGroup, taskName, name(), taskTags, storeTags);\n        final Sensor restoreTime = createTaskAndStoreLatencyAndThroughputSensors(DEBUG, \"restore\", metrics, metricsGroup, taskName, name(), taskTags, storeTags);\n\n        // register and possibly restore the state from the logs"
  },
  {
    "id" : "8225c8dc-0022-4210-9dca-199cc378ad5d",
    "prId" : 6053,
    "prUrl" : "https://github.com/apache/kafka/pull/6053#pullrequestreview-187016230",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2afabe25-2424-4c7a-abaa-392a189f0c93",
        "parentId" : null,
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "Extracted into it's own method, to align with code of other stores.",
        "createdAt" : "2018-12-20T14:20:25Z",
        "updatedAt" : "2019-01-03T21:56:29Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      }
    ],
    "commit" : "42219c87c9f0e295d5fc80e69a1576bb2a69d078",
    "line" : 22,
    "diffHunk" : "@@ -1,1 +133,137 @@        try {\n            if (getTime.shouldRecord()) {\n                return measureLatency(() -> outerValue(inner.get(keyBytes(key))), getTime);\n            } else {\n                return outerValue(inner.get(keyBytes(key)));"
  },
  {
    "id" : "680c43f0-f6e0-43a4-855f-0af5801c3f93",
    "prId" : 6152,
    "prUrl" : "https://github.com/apache/kafka/pull/6152#pullrequestreview-205818238",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "98b08602-607e-41a4-b2bb-b7e6d4243bbb",
        "parentId" : null,
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "Need to make package private, because it's set in child class (cf `#initStoreSerde()`)",
        "createdAt" : "2019-01-29T22:35:30Z",
        "updatedAt" : "2019-03-01T08:31:04Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "898972a3-7820-4b5a-b7c9-35354ff79696",
        "parentId" : "98b08602-607e-41a4-b2bb-b7e6d4243bbb",
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : ":+1: Thanks for the explanation.",
        "createdAt" : "2019-02-20T15:51:12Z",
        "updatedAt" : "2019-03-01T08:31:04Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      }
    ],
    "commit" : "32105c2d2a50fa9b3e10e1bacfd544ee1f143433",
    "line" : 9,
    "diffHunk" : "@@ -1,1 +52,56 @@    final Serde<K> keySerde;\n    final Serde<V> valueSerde;\n    StateSerdes<K, V> serdes;\n\n    private final String metricScope;"
  },
  {
    "id" : "eeb54664-665b-4673-8a75-cf19d0739e45",
    "prId" : 6152,
    "prUrl" : "https://github.com/apache/kafka/pull/6152#pullrequestreview-207546769",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ac0f2848-da71-4bb7-923b-2ae812006470",
        "parentId" : null,
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "Nice cleanup!",
        "createdAt" : "2019-02-25T18:29:49Z",
        "updatedAt" : "2019-03-01T08:31:04Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      }
    ],
    "commit" : "32105c2d2a50fa9b3e10e1bacfd544ee1f143433",
    "line" : 77,
    "diffHunk" : "@@ -1,1 +303,307 @@            return KeyValue.pair(\n                serdes.keyFrom(keyValue.key.get()),\n                outerValue(keyValue.value));\n        }\n"
  },
  {
    "id" : "5e978ed7-5000-403b-b51a-df816e849cc4",
    "prId" : 6331,
    "prUrl" : "https://github.com/apache/kafka/pull/6331#pullrequestreview-208843548",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a0f2b212-8044-42ab-aa13-6e2805d1729c",
        "parentId" : null,
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "We know the wrapping order, thus, this is safe. Intercepting the callback below to deserialize.",
        "createdAt" : "2019-02-27T02:23:33Z",
        "updatedAt" : "2019-02-28T00:49:23Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "e4f52f66-5184-49ce-bac1-4b55e969a696",
        "parentId" : "a0f2b212-8044-42ab-aa13-6e2805d1729c",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "Meta: I like this approach slightly more than the previous one, and wondering if we can sort-of combine these two to make the logic more readable (and also the metered store lost the topic name info when calling serde which may not be acceptable):\r\n\r\n1) Metered store do not need to inherited CachedStateStore, instead inherit a SerdeStateStore interface which just expose the getter of the serdes (note we cannot use `serdes` since it is only constructed at initialization, we have to use `keySerde` and `valueSerde` instead`).\r\n2) In TupleForwarder we get both the SerdeStateStore, and check if its wrapped store is a CachedStateStore, if yes call `cachedStore.setFlushListener(... listener.apply(serdeStore.keySerde().deser ...))` -- i.e. basically the code below.\r\n\r\nWDYT?",
        "createdAt" : "2019-02-27T17:35:48Z",
        "updatedAt" : "2019-02-28T00:49:23Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "4aba2d4d-6234-4af9-b5ef-3a50dcb96471",
        "parentId" : "a0f2b212-8044-42ab-aa13-6e2805d1729c",
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "> and also the metered store lost the topic name info when calling serde which may not be acceptable\r\n\r\nFixed this part. Compare my other comments.\r\n\r\nAbout your proposal: that is certainly possible, it's similar (or even the same?) to the original PR introducing `TypedStore` (your suggested `SerdeStateStore` is the same thing). So I am wondering what the difference to the original proposal would be -- seems you suggest to go back to the original one.",
        "createdAt" : "2019-02-27T17:56:31Z",
        "updatedAt" : "2019-02-28T00:49:23Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "b4a506f2-5458-4a18-a8d2-203800069538",
        "parentId" : "a0f2b212-8044-42ab-aa13-6e2805d1729c",
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "At a high level, our store ecosystem looks like an onion. On the outside, we have a <K,V> store, and on the inside, we have a <bytes,bytes> store. All the layers in between have different responsibilities, like changelogging, caching, add metrics, etc.\r\n\r\nThe nice thing about this PR is that it gives us one clean layer that's responsible for the transition `<K,V> <=> <bytes, bytes>`. When we need to look at the de/serialization into/out-of the stores, we have exactly one place to look.\r\n\r\nThe prior code did mostly this, but to accommodate cache flushing in conjunction with the fact that the cache layer is below the transition from objects to bytes, we had to poke a hole in the onion and tell the caching layer (a bytes layer) how to deserialize. So, then there were two layers that independently know how to de/serialize, and the onion had a hole in it.\r\n\r\nThis idea to move the serialization out to the TupleForwarder is basically the same, but in the opposite direction. Again, there are two components that need to perform serialization (the serialization layer and the tuple forwarder), and again, we need to poke a hole in the onion so that the tuple forwarder can communicate directly with an inner layer.\r\n\r\nIt's not always practical to go for a \"pure\" design, but if readability is the goal, then it seems like we should try to avoid mixing layers, unwrapping layers, etc. as much as possible. To be fair, this is just my take on the situation.",
        "createdAt" : "2019-02-27T20:57:02Z",
        "updatedAt" : "2019-02-28T00:49:23Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      },
      {
        "id" : "3e29ad0e-f139-4c27-ba2f-23cf297bd4ea",
        "parentId" : "a0f2b212-8044-42ab-aa13-6e2805d1729c",
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "I also think that using two nested `CacheFlushListener` is better instead of \"drilling\" whole into the APIs. So I prefer to stay with the current design.",
        "createdAt" : "2019-02-28T00:48:39Z",
        "updatedAt" : "2019-02-28T00:49:23Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      }
    ],
    "commit" : "5d95689529bd3b0aa046c37df59896930b9226bb",
    "line" : 28,
    "diffHunk" : "@@ -1,1 +123,127 @@                                    final boolean sendOldValues) {\n        final KeyValueStore<Bytes, byte[]> wrapped = wrapped();\n        if (wrapped instanceof CachedStateStore) {\n            return ((CachedStateStore<byte[], byte[]>) wrapped).setFlushListener(\n                (key, newValue, oldValue, timestamp) -> listener.apply("
  },
  {
    "id" : "460e8358-7710-40e7-9717-24ac19ab135a",
    "prId" : 7416,
    "prUrl" : "https://github.com/apache/kafka/pull/7416#pullrequestreview-297022729",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5e90977c-15be-401b-8ced-7b713c2f31cb",
        "parentId" : null,
        "authorId" : "4c968502-bb3d-46ee-8719-0c0bdbc6242f",
        "body" : "nit: same here for string literals and below, I won't repeat this comment anymore.",
        "createdAt" : "2019-10-01T16:48:25Z",
        "updatedAt" : "2019-10-04T08:23:54Z",
        "lastEditedBy" : "4c968502-bb3d-46ee-8719-0c0bdbc6242f",
        "tags" : [
        ]
      },
      {
        "id" : "79dcf3b8-5baa-41de-8532-a4093d504f14",
        "parentId" : "5e90977c-15be-401b-8ced-7b713c2f31cb",
        "authorId" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "body" : "I will tackle this in the PR for the store-level metrics.",
        "createdAt" : "2019-10-02T09:59:22Z",
        "updatedAt" : "2019-10-04T08:23:54Z",
        "lastEditedBy" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "tags" : [
        ]
      },
      {
        "id" : "2878e6e2-d3db-4154-85f8-98b0f999c49d",
        "parentId" : "5e90977c-15be-401b-8ced-7b713c2f31cb",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "Is multi-line here for checkstyle to be happy? Honestly I like the previous one as it is easier to compare multi-lines in case there's any parameter mis-set, would be great if we can get back to oneliner.",
        "createdAt" : "2019-10-02T22:12:32Z",
        "updatedAt" : "2019-10-04T08:23:54Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "b85569ee-25a1-45df-b305-787c30939a89",
        "parentId" : "5e90977c-15be-401b-8ced-7b713c2f31cb",
        "authorId" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "body" : "It is not checkstyle, but our coding style guidelines. I see what you mean. I guess we should refactor this anyways to hide most of those parameters behind a method. Looking at the other refactorings, this should become something along the lines of `putLatencySensor(threadId, taskId, metricsScope, storeName)` which would fit again on one line.",
        "createdAt" : "2019-10-03T17:23:39Z",
        "updatedAt" : "2019-10-04T08:23:54Z",
        "lastEditedBy" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "tags" : [
        ]
      }
    ],
    "commit" : "ab3c0436cf659dd6f76b2b6b5360d327bad385bb",
    "line" : 41,
    "diffHunk" : "@@ -1,1 +97,101 @@        initStoreSerde(context);\n\n        putTime = createTaskAndStoreLatencyAndThroughputSensors(\n            DEBUG,\n            \"put\","
  },
  {
    "id" : "e4f32c87-d557-488d-8819-d6237c222a6b",
    "prId" : 7584,
    "prUrl" : "https://github.com/apache/kafka/pull/7584#pullrequestreview-305842352",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4dbbce0d-c94a-4a2d-8882-b7209b5a8e48",
        "parentId" : null,
        "authorId" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "body" : "Metrics for state stores are fetched in this way now.",
        "createdAt" : "2019-10-23T12:21:46Z",
        "updatedAt" : "2019-10-29T13:41:57Z",
        "lastEditedBy" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "tags" : [
        ]
      }
    ],
    "commit" : "e5cd569c4b66c0af071eaf7b914f5e1413c34ca8",
    "line" : 172,
    "diffHunk" : "@@ -1,1 +96,100 @@        deleteSensor = StateStoreMetrics.deleteSensor(threadId, taskId, metricsScope, name(), streamsMetrics);\n        final Sensor restoreSensor =\n            StateStoreMetrics.restoreSensor(threadId, taskId, metricsScope, name(), streamsMetrics);\n\n        // register and possibly restore the state from the logs"
  },
  {
    "id" : "f2509743-3d42-40d3-8880-214be5ebf12d",
    "prId" : 7762,
    "prUrl" : "https://github.com/apache/kafka/pull/7762#pullrequestreview-324363699",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ee635791-f12d-43f6-8166-34ae80d4d28d",
        "parentId" : null,
        "authorId" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "body" : "Remove use of deprecated method.",
        "createdAt" : "2019-11-28T15:46:08Z",
        "updatedAt" : "2019-12-06T10:22:29Z",
        "lastEditedBy" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "tags" : [
        ]
      }
    ],
    "commit" : "af018280b32232ffe9137b5cc13082792e84f969",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +251,255 @@                iter.close();\n            } finally {\n                sensor.record(time.nanoseconds() - startNs);\n            }\n        }"
  },
  {
    "id" : "2e8ccbc9-f388-43b9-b56b-113a458b697e",
    "prId" : 8368,
    "prUrl" : "https://github.com/apache/kafka/pull/8368#pullrequestreview-383238288",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c1332eb0-abcb-4a5d-9f18-9eade70b8185",
        "parentId" : null,
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "This is a related bug I fixed. It's basically the same thing, but for Metered store. There's no need to use the new util when we're just dealing with one potentially-throwing operation.",
        "createdAt" : "2020-03-27T22:49:32Z",
        "updatedAt" : "2020-03-28T01:19:57Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      }
    ],
    "commit" : "9d67f1a9b39ab41874c2c702eb4cce011afc2560",
    "line" : 10,
    "diffHunk" : "@@ -1,1 +204,208 @@        } finally {\n            streamsMetrics.removeAllStoreLevelSensors(threadId, taskId, name());\n        }\n    }\n"
  },
  {
    "id" : "ad68e18e-57a0-4402-896a-529dd7f3c1f5",
    "prId" : 8902,
    "prUrl" : "https://github.com/apache/kafka/pull/8902#pullrequestreview-445874034",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ef057dfc-7b5d-45f1-b951-e5d7cf7ed2c0",
        "parentId" : null,
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "It seems we don't need this if-then-else any longer as it's already taken care of within `ProcessorContextUtils.changelogFor`? (Similar for other classes.)",
        "createdAt" : "2020-07-09T00:56:41Z",
        "updatedAt" : "2020-07-09T12:00:58Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "ed36e081-b7fc-467e-84d4-c28f045221e8",
        "parentId" : "ef057dfc-7b5d-45f1-b951-e5d7cf7ed2c0",
        "authorId" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "body" : "I think we still need the if-then-else. `ProcessorContextUtils.changelogFor()` checks that the processor context is of type `InternalProcessorContext` to be able to call `changelogFor()` on it. It does not consider the case where no changelog exists (i.e., `changelogFor()` returns `null`). The `null` check is done here. Fallback is in both cases `ProcessorStateManager.storeChangelogTopic()`.  ",
        "createdAt" : "2020-07-09T11:26:51Z",
        "updatedAt" : "2020-07-09T12:00:58Z",
        "lastEditedBy" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "tags" : [
        ]
      },
      {
        "id" : "c9d5e576-abed-4c39-a939-dffb24fee27a",
        "parentId" : "ef057dfc-7b5d-45f1-b951-e5d7cf7ed2c0",
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "Ah thanks. I missed this case.\r\n\r\nHowever, should we move both `null` checks into `ProcessorContextUtils.changelogFor()` for this case? It seem, we do the same \"outer\" `null`-check each time we call the method, so why not do it at a single place in the code?",
        "createdAt" : "2020-07-09T17:59:41Z",
        "updatedAt" : "2020-07-09T17:59:42Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "13c99376-b354-46cf-bde1-237172bc2461",
        "parentId" : "ef057dfc-7b5d-45f1-b951-e5d7cf7ed2c0",
        "authorId" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "body" : "I would not put any code that is not related to casts of `ProcessorContext` into `ProessorContextUtils`. I think the goal of `ProessorContextUtils` is to contain all code of which we want to get rid of in the future once the casts are fixed.\r\n\r\nWe could move the `null` check into the constructor of `StateSerde` since we do also there a `null` check. ",
        "createdAt" : "2020-07-09T18:38:53Z",
        "updatedAt" : "2020-07-09T18:38:53Z",
        "lastEditedBy" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "tags" : [
        ]
      }
    ],
    "commit" : "bfacb69b8895b4c72874942d37faa9a36ca357e9",
    "line" : 18,
    "diffHunk" : "@@ -1,1 +110,114 @@             changelogTopic != null ?\n                changelogTopic :\n                ProcessorStateManager.storeChangelogTopic(context.applicationId(), storeName),\n            keySerde == null ? (Serde<K>) context.keySerde() : keySerde,\n            valueSerde == null ? (Serde<V>) context.valueSerde() : valueSerde);"
  },
  {
    "id" : "f050603d-e096-4087-83e2-d88b281b4ec8",
    "prId" : 9388,
    "prUrl" : "https://github.com/apache/kafka/pull/9388#pullrequestreview-504159206",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8b91a867-a601-41cc-9641-944ac1264b2c",
        "parentId" : null,
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "I wasn't able to extract out quite as much common code in the Metered implementations because they need to work regardless of whether the context is an InternalProcessorContext or whether it's a straight mock (for unit tests).",
        "createdAt" : "2020-10-07T03:40:11Z",
        "updatedAt" : "2020-10-07T03:47:44Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      },
      {
        "id" : "2530cfd3-b8b6-406d-beb6-4ab79b55d209",
        "parentId" : "8b91a867-a601-41cc-9641-944ac1264b2c",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "`this.context` seems only used in the e2e latency as\r\n\r\n```\r\nfinal long e2eLatency =  currentTime - context.timestamp();\r\n```\r\n\r\nAnd in that case we may throw a NPE. Should we augment the condition as \r\n\r\n```\r\nif (e2eLatencySensor.shouldRecord() && context != null)\r\n```",
        "createdAt" : "2020-10-07T22:25:17Z",
        "updatedAt" : "2020-10-07T22:44:44Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "850d2d7b-ca0b-4358-a4a1-7b8bd402a986",
        "parentId" : "8b91a867-a601-41cc-9641-944ac1264b2c",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "NVM, I saw you already did this :)",
        "createdAt" : "2020-10-07T22:35:53Z",
        "updatedAt" : "2020-10-07T22:44:44Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      }
    ],
    "commit" : "ab093bc0610dfee1ccfa7199de59e1b2c417a3d0",
    "line" : 32,
    "diffHunk" : "@@ -1,1 +95,99 @@        streamsMetrics = (StreamsMetricsImpl) context.metrics();\n\n        registerMetrics();\n        final Sensor restoreSensor =\n            StateStoreMetrics.restoreSensor(threadId, taskId, metricsScope, name(), streamsMetrics);"
  },
  {
    "id" : "0bf2543a-dd1a-480c-a27d-57decb1ee31d",
    "prId" : 9388,
    "prUrl" : "https://github.com/apache/kafka/pull/9388#pullrequestreview-504411828",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "31a3af4e-34f4-4e12-9a8d-f0fbd35a473d",
        "parentId" : null,
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "Actually I think we should remove the `restoreSensor` since we no longer restore the state upon init any more? In KIP-444 we no longer have it as a state-store level metric.",
        "createdAt" : "2020-10-07T22:32:16Z",
        "updatedAt" : "2020-10-07T22:44:44Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "70f8b178-9465-4c45-a72b-eae994fbedc6",
        "parentId" : "31a3af4e-34f4-4e12-9a8d-f0fbd35a473d",
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "huh. I'll double-check and take it out.",
        "createdAt" : "2020-10-08T03:52:24Z",
        "updatedAt" : "2020-10-08T03:52:24Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      },
      {
        "id" : "639a8d04-a72d-463b-94b6-df07919a4e24",
        "parentId" : "31a3af4e-34f4-4e12-9a8d-f0fbd35a473d",
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "Actually, I'll do that in a quick follow-up PR, so I can go ahead and merge this.",
        "createdAt" : "2020-10-08T03:56:42Z",
        "updatedAt" : "2020-10-08T03:56:42Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      }
    ],
    "commit" : "ab093bc0610dfee1ccfa7199de59e1b2c417a3d0",
    "line" : 49,
    "diffHunk" : "@@ -1,1 +112,116 @@\n        registerMetrics();\n        final Sensor restoreSensor =\n            StateStoreMetrics.restoreSensor(threadId, taskId, metricsScope, name(), streamsMetrics);\n"
  },
  {
    "id" : "7eae0389-ea86-4c4c-9bd2-6eec78c2a82c",
    "prId" : 9508,
    "prUrl" : "https://github.com/apache/kafka/pull/9508#pullrequestreview-525057969",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "34f10f92-911f-45bc-812a-a64092526656",
        "parentId" : null,
        "authorId" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "body" : "This method needs unit testing.",
        "createdAt" : "2020-11-06T12:53:10Z",
        "updatedAt" : "2021-02-03T10:49:03Z",
        "lastEditedBy" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "tags" : [
        ]
      }
    ],
    "commit" : "8eca3c9c2852172896001178f8e7a115fd392aeb",
    "line" : 29,
    "diffHunk" : "@@ -1,1 +234,238 @@\n    @Override\n    public <PS extends Serializer<P>, P> KeyValueIterator<K, V> prefixScan(final P prefix, final PS prefixKeySerializer) {\n\n        return new MeteredKeyValueIterator(wrapped().prefixScan(prefix, prefixKeySerializer), prefixScanSensor);"
  },
  {
    "id" : "736c34e7-9f0e-49c2-bee6-aea20664c4a4",
    "prId" : 10548,
    "prUrl" : "https://github.com/apache/kafka/pull/10548#pullrequestreview-645672681",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d3e9a813-2fea-42b3-a78c-20e70b1ba62e",
        "parentId" : null,
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "As mentioned by @cadonna the wrapped stores, also check `prefixKeySerializer` for null -- thus might be good to move both check here.\r\n\r\nI think we can also remove both checks in `RocksDBStore` and `InMemoryKeyValueStore` -- they seems to be redundant now? ",
        "createdAt" : "2021-04-22T21:50:39Z",
        "updatedAt" : "2021-04-27T10:04:42Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "eac13a59-11a0-45a0-b92d-85dcd4bce583",
        "parentId" : "d3e9a813-2fea-42b3-a78c-20e70b1ba62e",
        "authorId" : "7c1538d7-69dd-4323-a552-628699aa0b78",
        "body" : ">I think we can also remove both checks in RocksDBStore and InMemoryKeyValueStore -- they seem to be redundant now?\r\n\r\nthey are both different implementations, aren't they?\r\n![image](https://user-images.githubusercontent.com/44339288/115792580-35255c80-a3d3-11eb-99ea-4e5686dd8556.png)\r\nI don't understand how they will be checked if we only leave it in `MeteredKeyValueStore.`",
        "createdAt" : "2021-04-22T22:33:02Z",
        "updatedAt" : "2021-04-27T10:04:42Z",
        "lastEditedBy" : "7c1538d7-69dd-4323-a552-628699aa0b78",
        "tags" : [
        ]
      },
      {
        "id" : "aef52e01-013a-4bea-bdda-8d318099b16c",
        "parentId" : "d3e9a813-2fea-42b3-a78c-20e70b1ba62e",
        "authorId" : "7c1538d7-69dd-4323-a552-628699aa0b78",
        "body" : "\r\n![image](https://user-images.githubusercontent.com/44339288/115794170-3441fa00-a3d6-11eb-8fd6-ba9a90af3005.png)\r\nI wrote a quick test to see if it still throws NPE in `InMemoryKeyValueStore` without the check - it did, I am confused, but they are, indeed, redundant.\r\nI'll leave the tests in both `RocksDBStoreTest` and `InMemoryKeyValueStore` bc why not.",
        "createdAt" : "2021-04-22T22:50:41Z",
        "updatedAt" : "2021-04-27T10:04:42Z",
        "lastEditedBy" : "7c1538d7-69dd-4323-a552-628699aa0b78",
        "tags" : [
        ]
      },
      {
        "id" : "e09c99af-13c5-4152-ae60-1384caee74bc",
        "parentId" : "d3e9a813-2fea-42b3-a78c-20e70b1ba62e",
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "KafkaStreams runtime _always_ \"wraps\" any store with a corresponding `MeteredXxxStore` (cf https://github.com/apache/kafka/blob/trunk/streams/src/main/java/org/apache/kafka/streams/state/internals/KeyValueStoreBuilder.java#L42-L49) -- those `MeteredXxxStores` do the transaction from objects to bytes (ie they use the serdes) and also track state store metrics. (Note that stores provided to the runtime always have type `<Bytes, byte[]>` while they are exposed to `Processors` as `<K,V>` types.)\r\n\r\nThus, when you call `context.stateStore(...)` you always get a `MeteredXxxStore` object -- of course, those details are hidden behind the interface type.\r\n\r\nThis architecture allows us to unify code and separate concerns. In fact, it also allows us to add/remove more \"layers\": we can insert a \"caching layer\" (cf. https://kafka.apache.org/28/documentation/streams/developer-guide/memory-mgmt.html) and a \"change logging layer\" (both are inserted by default).",
        "createdAt" : "2021-04-25T23:44:10Z",
        "updatedAt" : "2021-04-27T10:04:42Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "79beac2b-bf6c-4775-97a6-0b2d6b0d21bb",
        "parentId" : "d3e9a813-2fea-42b3-a78c-20e70b1ba62e",
        "authorId" : "7c1538d7-69dd-4323-a552-628699aa0b78",
        "body" : "Oooooh, I see.",
        "createdAt" : "2021-04-27T10:03:09Z",
        "updatedAt" : "2021-04-27T10:04:42Z",
        "lastEditedBy" : "7c1538d7-69dd-4323-a552-628699aa0b78",
        "tags" : [
        ]
      }
    ],
    "commit" : "12038c0fed47c280c9a19a11e54f2714ab1913fc",
    "line" : 51,
    "diffHunk" : "@@ -1,1 +241,245 @@    @Override\n    public <PS extends Serializer<P>, P> KeyValueIterator<K, V> prefixScan(final P prefix, final PS prefixKeySerializer) {\n        Objects.requireNonNull(prefix, \"key cannot be null\");\n        Objects.requireNonNull(prefixKeySerializer, \"prefixKeySerializer cannot be null\");\n        return new MeteredKeyValueIterator(wrapped().prefixScan(prefix, prefixKeySerializer), prefixScanSensor);"
  },
  {
    "id" : "f56d5baa-b1db-4db0-b753-b94332d3ac26",
    "prId" : 10744,
    "prUrl" : "https://github.com/apache/kafka/pull/10744#pullrequestreview-665887821",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "21dc72ff-f065-46ca-a971-3dac26d174a3",
        "parentId" : null,
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "Since the interface has two methods, it can't be a lambda anymore.",
        "createdAt" : "2021-05-21T21:26:19Z",
        "updatedAt" : "2021-05-21T21:30:06Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      }
    ],
    "commit" : "599f185421aa01afe9f55c0d9a1127f3224dd0e4",
    "line" : 23,
    "diffHunk" : "@@ -1,1 +176,180 @@        if (wrapped instanceof CachedStateStore) {\n            return ((CachedStateStore<byte[], byte[]>) wrapped).setFlushListener(\n                new CacheFlushListener<byte[], byte[]>() {\n                    @Override\n                    public void apply(final byte[] rawKey, final byte[] rawNewValue, final byte[] rawOldValue, final long timestamp) {"
  }
]
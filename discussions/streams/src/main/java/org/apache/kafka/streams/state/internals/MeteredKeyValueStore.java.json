[
  {
    "id" : "8ebeda93-cc5a-442d-9645-3a60987d8396",
    "prId" : 5450,
    "prUrl" : "https://github.com/apache/kafka/pull/5450#pullrequestreview-142958657",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "28799ed9-7610-4093-bdb4-e246996ee357",
        "parentId" : null,
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "These lines are a little long, but they're also very uniform. Should I split them?",
        "createdAt" : "2018-08-02T18:40:26Z",
        "updatedAt" : "2018-08-03T22:17:02Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      },
      {
        "id" : "808de374-032b-47e0-84a9-0b22db4ae805",
        "parentId" : "28799ed9-7610-4093-bdb4-e246996ee357",
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "I am fine both ways.",
        "createdAt" : "2018-08-02T20:22:58Z",
        "updatedAt" : "2018-08-03T22:17:02Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      }
    ],
    "commit" : "b590af4726d2e4fc3bf1186676f6f9015388cd3e",
    "line" : 110,
    "diffHunk" : "@@ -1,1 +103,107 @@        flushTime = createTaskAndStoreLatencyAndThroughputSensors(DEBUG, \"flush\", metrics, metricsGroup, taskName, name(), taskTags, storeTags);\n        deleteTime = createTaskAndStoreLatencyAndThroughputSensors(DEBUG, \"delete\", metrics, metricsGroup, taskName, name(), taskTags, storeTags);\n        final Sensor restoreTime = createTaskAndStoreLatencyAndThroughputSensors(DEBUG, \"restore\", metrics, metricsGroup, taskName, name(), taskTags, storeTags);\n\n        // register and possibly restore the state from the logs"
  },
  {
    "id" : "8225c8dc-0022-4210-9dca-199cc378ad5d",
    "prId" : 6053,
    "prUrl" : "https://github.com/apache/kafka/pull/6053#pullrequestreview-187016230",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2afabe25-2424-4c7a-abaa-392a189f0c93",
        "parentId" : null,
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "Extracted into it's own method, to align with code of other stores.",
        "createdAt" : "2018-12-20T14:20:25Z",
        "updatedAt" : "2019-01-03T21:56:29Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      }
    ],
    "commit" : "42219c87c9f0e295d5fc80e69a1576bb2a69d078",
    "line" : 22,
    "diffHunk" : "@@ -1,1 +133,137 @@        try {\n            if (getTime.shouldRecord()) {\n                return measureLatency(() -> outerValue(inner.get(keyBytes(key))), getTime);\n            } else {\n                return outerValue(inner.get(keyBytes(key)));"
  },
  {
    "id" : "680c43f0-f6e0-43a4-855f-0af5801c3f93",
    "prId" : 6152,
    "prUrl" : "https://github.com/apache/kafka/pull/6152#pullrequestreview-205818238",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "98b08602-607e-41a4-b2bb-b7e6d4243bbb",
        "parentId" : null,
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "Need to make package private, because it's set in child class (cf `#initStoreSerde()`)",
        "createdAt" : "2019-01-29T22:35:30Z",
        "updatedAt" : "2019-03-01T08:31:04Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "898972a3-7820-4b5a-b7c9-35354ff79696",
        "parentId" : "98b08602-607e-41a4-b2bb-b7e6d4243bbb",
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : ":+1: Thanks for the explanation.",
        "createdAt" : "2019-02-20T15:51:12Z",
        "updatedAt" : "2019-03-01T08:31:04Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      }
    ],
    "commit" : "32105c2d2a50fa9b3e10e1bacfd544ee1f143433",
    "line" : 9,
    "diffHunk" : "@@ -1,1 +52,56 @@    final Serde<K> keySerde;\n    final Serde<V> valueSerde;\n    StateSerdes<K, V> serdes;\n\n    private final String metricScope;"
  },
  {
    "id" : "eeb54664-665b-4673-8a75-cf19d0739e45",
    "prId" : 6152,
    "prUrl" : "https://github.com/apache/kafka/pull/6152#pullrequestreview-207546769",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ac0f2848-da71-4bb7-923b-2ae812006470",
        "parentId" : null,
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "Nice cleanup!",
        "createdAt" : "2019-02-25T18:29:49Z",
        "updatedAt" : "2019-03-01T08:31:04Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      }
    ],
    "commit" : "32105c2d2a50fa9b3e10e1bacfd544ee1f143433",
    "line" : 77,
    "diffHunk" : "@@ -1,1 +303,307 @@            return KeyValue.pair(\n                serdes.keyFrom(keyValue.key.get()),\n                outerValue(keyValue.value));\n        }\n"
  },
  {
    "id" : "5e978ed7-5000-403b-b51a-df816e849cc4",
    "prId" : 6331,
    "prUrl" : "https://github.com/apache/kafka/pull/6331#pullrequestreview-208843548",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a0f2b212-8044-42ab-aa13-6e2805d1729c",
        "parentId" : null,
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "We know the wrapping order, thus, this is safe. Intercepting the callback below to deserialize.",
        "createdAt" : "2019-02-27T02:23:33Z",
        "updatedAt" : "2019-02-28T00:49:23Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "e4f52f66-5184-49ce-bac1-4b55e969a696",
        "parentId" : "a0f2b212-8044-42ab-aa13-6e2805d1729c",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "Meta: I like this approach slightly more than the previous one, and wondering if we can sort-of combine these two to make the logic more readable (and also the metered store lost the topic name info when calling serde which may not be acceptable):\r\n\r\n1) Metered store do not need to inherited CachedStateStore, instead inherit a SerdeStateStore interface which just expose the getter of the serdes (note we cannot use `serdes` since it is only constructed at initialization, we have to use `keySerde` and `valueSerde` instead`).\r\n2) In TupleForwarder we get both the SerdeStateStore, and check if its wrapped store is a CachedStateStore, if yes call `cachedStore.setFlushListener(... listener.apply(serdeStore.keySerde().deser ...))` -- i.e. basically the code below.\r\n\r\nWDYT?",
        "createdAt" : "2019-02-27T17:35:48Z",
        "updatedAt" : "2019-02-28T00:49:23Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "4aba2d4d-6234-4af9-b5ef-3a50dcb96471",
        "parentId" : "a0f2b212-8044-42ab-aa13-6e2805d1729c",
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "> and also the metered store lost the topic name info when calling serde which may not be acceptable\r\n\r\nFixed this part. Compare my other comments.\r\n\r\nAbout your proposal: that is certainly possible, it's similar (or even the same?) to the original PR introducing `TypedStore` (your suggested `SerdeStateStore` is the same thing). So I am wondering what the difference to the original proposal would be -- seems you suggest to go back to the original one.",
        "createdAt" : "2019-02-27T17:56:31Z",
        "updatedAt" : "2019-02-28T00:49:23Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "b4a506f2-5458-4a18-a8d2-203800069538",
        "parentId" : "a0f2b212-8044-42ab-aa13-6e2805d1729c",
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "At a high level, our store ecosystem looks like an onion. On the outside, we have a <K,V> store, and on the inside, we have a <bytes,bytes> store. All the layers in between have different responsibilities, like changelogging, caching, add metrics, etc.\r\n\r\nThe nice thing about this PR is that it gives us one clean layer that's responsible for the transition `<K,V> <=> <bytes, bytes>`. When we need to look at the de/serialization into/out-of the stores, we have exactly one place to look.\r\n\r\nThe prior code did mostly this, but to accommodate cache flushing in conjunction with the fact that the cache layer is below the transition from objects to bytes, we had to poke a hole in the onion and tell the caching layer (a bytes layer) how to deserialize. So, then there were two layers that independently know how to de/serialize, and the onion had a hole in it.\r\n\r\nThis idea to move the serialization out to the TupleForwarder is basically the same, but in the opposite direction. Again, there are two components that need to perform serialization (the serialization layer and the tuple forwarder), and again, we need to poke a hole in the onion so that the tuple forwarder can communicate directly with an inner layer.\r\n\r\nIt's not always practical to go for a \"pure\" design, but if readability is the goal, then it seems like we should try to avoid mixing layers, unwrapping layers, etc. as much as possible. To be fair, this is just my take on the situation.",
        "createdAt" : "2019-02-27T20:57:02Z",
        "updatedAt" : "2019-02-28T00:49:23Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      },
      {
        "id" : "3e29ad0e-f139-4c27-ba2f-23cf297bd4ea",
        "parentId" : "a0f2b212-8044-42ab-aa13-6e2805d1729c",
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "I also think that using two nested `CacheFlushListener` is better instead of \"drilling\" whole into the APIs. So I prefer to stay with the current design.",
        "createdAt" : "2019-02-28T00:48:39Z",
        "updatedAt" : "2019-02-28T00:49:23Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      }
    ],
    "commit" : "5d95689529bd3b0aa046c37df59896930b9226bb",
    "line" : 28,
    "diffHunk" : "@@ -1,1 +123,127 @@                                    final boolean sendOldValues) {\n        final KeyValueStore<Bytes, byte[]> wrapped = wrapped();\n        if (wrapped instanceof CachedStateStore) {\n            return ((CachedStateStore<byte[], byte[]>) wrapped).setFlushListener(\n                (key, newValue, oldValue, timestamp) -> listener.apply("
  },
  {
    "id" : "460e8358-7710-40e7-9717-24ac19ab135a",
    "prId" : 7416,
    "prUrl" : "https://github.com/apache/kafka/pull/7416#pullrequestreview-297022729",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5e90977c-15be-401b-8ced-7b713c2f31cb",
        "parentId" : null,
        "authorId" : "4c968502-bb3d-46ee-8719-0c0bdbc6242f",
        "body" : "nit: same here for string literals and below, I won't repeat this comment anymore.",
        "createdAt" : "2019-10-01T16:48:25Z",
        "updatedAt" : "2019-10-04T08:23:54Z",
        "lastEditedBy" : "4c968502-bb3d-46ee-8719-0c0bdbc6242f",
        "tags" : [
        ]
      },
      {
        "id" : "79dcf3b8-5baa-41de-8532-a4093d504f14",
        "parentId" : "5e90977c-15be-401b-8ced-7b713c2f31cb",
        "authorId" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "body" : "I will tackle this in the PR for the store-level metrics.",
        "createdAt" : "2019-10-02T09:59:22Z",
        "updatedAt" : "2019-10-04T08:23:54Z",
        "lastEditedBy" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "tags" : [
        ]
      },
      {
        "id" : "2878e6e2-d3db-4154-85f8-98b0f999c49d",
        "parentId" : "5e90977c-15be-401b-8ced-7b713c2f31cb",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "Is multi-line here for checkstyle to be happy? Honestly I like the previous one as it is easier to compare multi-lines in case there's any parameter mis-set, would be great if we can get back to oneliner.",
        "createdAt" : "2019-10-02T22:12:32Z",
        "updatedAt" : "2019-10-04T08:23:54Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "b85569ee-25a1-45df-b305-787c30939a89",
        "parentId" : "5e90977c-15be-401b-8ced-7b713c2f31cb",
        "authorId" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "body" : "It is not checkstyle, but our coding style guidelines. I see what you mean. I guess we should refactor this anyways to hide most of those parameters behind a method. Looking at the other refactorings, this should become something along the lines of `putLatencySensor(threadId, taskId, metricsScope, storeName)` which would fit again on one line.",
        "createdAt" : "2019-10-03T17:23:39Z",
        "updatedAt" : "2019-10-04T08:23:54Z",
        "lastEditedBy" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "tags" : [
        ]
      }
    ],
    "commit" : "ab3c0436cf659dd6f76b2b6b5360d327bad385bb",
    "line" : 41,
    "diffHunk" : "@@ -1,1 +97,101 @@        initStoreSerde(context);\n\n        putTime = createTaskAndStoreLatencyAndThroughputSensors(\n            DEBUG,\n            \"put\","
  },
  {
    "id" : "e4f32c87-d557-488d-8819-d6237c222a6b",
    "prId" : 7584,
    "prUrl" : "https://github.com/apache/kafka/pull/7584#pullrequestreview-305842352",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4dbbce0d-c94a-4a2d-8882-b7209b5a8e48",
        "parentId" : null,
        "authorId" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "body" : "Metrics for state stores are fetched in this way now.",
        "createdAt" : "2019-10-23T12:21:46Z",
        "updatedAt" : "2019-10-29T13:41:57Z",
        "lastEditedBy" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "tags" : [
        ]
      }
    ],
    "commit" : "e5cd569c4b66c0af071eaf7b914f5e1413c34ca8",
    "line" : 172,
    "diffHunk" : "@@ -1,1 +96,100 @@        deleteSensor = StateStoreMetrics.deleteSensor(threadId, taskId, metricsScope, name(), streamsMetrics);\n        final Sensor restoreSensor =\n            StateStoreMetrics.restoreSensor(threadId, taskId, metricsScope, name(), streamsMetrics);\n\n        // register and possibly restore the state from the logs"
  },
  {
    "id" : "f2509743-3d42-40d3-8880-214be5ebf12d",
    "prId" : 7762,
    "prUrl" : "https://github.com/apache/kafka/pull/7762#pullrequestreview-324363699",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ee635791-f12d-43f6-8166-34ae80d4d28d",
        "parentId" : null,
        "authorId" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "body" : "Remove use of deprecated method.",
        "createdAt" : "2019-11-28T15:46:08Z",
        "updatedAt" : "2019-12-06T10:22:29Z",
        "lastEditedBy" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "tags" : [
        ]
      }
    ],
    "commit" : "af018280b32232ffe9137b5cc13082792e84f969",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +251,255 @@                iter.close();\n            } finally {\n                sensor.record(time.nanoseconds() - startNs);\n            }\n        }"
  },
  {
    "id" : "2e8ccbc9-f388-43b9-b56b-113a458b697e",
    "prId" : 8368,
    "prUrl" : "https://github.com/apache/kafka/pull/8368#pullrequestreview-383238288",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c1332eb0-abcb-4a5d-9f18-9eade70b8185",
        "parentId" : null,
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "This is a related bug I fixed. It's basically the same thing, but for Metered store. There's no need to use the new util when we're just dealing with one potentially-throwing operation.",
        "createdAt" : "2020-03-27T22:49:32Z",
        "updatedAt" : "2020-03-28T01:19:57Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      }
    ],
    "commit" : "9d67f1a9b39ab41874c2c702eb4cce011afc2560",
    "line" : 10,
    "diffHunk" : "@@ -1,1 +204,208 @@        } finally {\n            streamsMetrics.removeAllStoreLevelSensors(threadId, taskId, name());\n        }\n    }\n"
  },
  {
    "id" : "ad68e18e-57a0-4402-896a-529dd7f3c1f5",
    "prId" : 8902,
    "prUrl" : "https://github.com/apache/kafka/pull/8902#pullrequestreview-445874034",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ef057dfc-7b5d-45f1-b951-e5d7cf7ed2c0",
        "parentId" : null,
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "It seems we don't need this if-then-else any longer as it's already taken care of within `ProcessorContextUtils.changelogFor`? (Similar for other classes.)",
        "createdAt" : "2020-07-09T00:56:41Z",
        "updatedAt" : "2020-07-09T12:00:58Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "ed36e081-b7fc-467e-84d4-c28f045221e8",
        "parentId" : "ef057dfc-7b5d-45f1-b951-e5d7cf7ed2c0",
        "authorId" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "body" : "I think we still need the if-then-else. `ProcessorContextUtils.changelogFor()` checks that the processor context is of type `InternalProcessorContext` to be able to call `changelogFor()` on it. It does not consider the case where no changelog exists (i.e., `changelogFor()` returns `null`). The `null` check is done here. Fallback is in both cases `ProcessorStateManager.storeChangelogTopic()`.  ",
        "createdAt" : "2020-07-09T11:26:51Z",
        "updatedAt" : "2020-07-09T12:00:58Z",
        "lastEditedBy" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "tags" : [
        ]
      },
      {
        "id" : "c9d5e576-abed-4c39-a939-dffb24fee27a",
        "parentId" : "ef057dfc-7b5d-45f1-b951-e5d7cf7ed2c0",
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "Ah thanks. I missed this case.\r\n\r\nHowever, should we move both `null` checks into `ProcessorContextUtils.changelogFor()` for this case? It seem, we do the same \"outer\" `null`-check each time we call the method, so why not do it at a single place in the code?",
        "createdAt" : "2020-07-09T17:59:41Z",
        "updatedAt" : "2020-07-09T17:59:42Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "13c99376-b354-46cf-bde1-237172bc2461",
        "parentId" : "ef057dfc-7b5d-45f1-b951-e5d7cf7ed2c0",
        "authorId" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "body" : "I would not put any code that is not related to casts of `ProcessorContext` into `ProessorContextUtils`. I think the goal of `ProessorContextUtils` is to contain all code of which we want to get rid of in the future once the casts are fixed.\r\n\r\nWe could move the `null` check into the constructor of `StateSerde` since we do also there a `null` check. ",
        "createdAt" : "2020-07-09T18:38:53Z",
        "updatedAt" : "2020-07-09T18:38:53Z",
        "lastEditedBy" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "tags" : [
        ]
      }
    ],
    "commit" : "bfacb69b8895b4c72874942d37faa9a36ca357e9",
    "line" : 18,
    "diffHunk" : "@@ -1,1 +110,114 @@             changelogTopic != null ?\n                changelogTopic :\n                ProcessorStateManager.storeChangelogTopic(context.applicationId(), storeName),\n            keySerde == null ? (Serde<K>) context.keySerde() : keySerde,\n            valueSerde == null ? (Serde<V>) context.valueSerde() : valueSerde);"
  }
]
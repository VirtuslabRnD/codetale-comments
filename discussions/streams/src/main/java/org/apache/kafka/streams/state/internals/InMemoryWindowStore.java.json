[
  {
    "id" : "2d71f56c-3e30-454c-b671-c5900540c1dc",
    "prId" : 6239,
    "prUrl" : "https://github.com/apache/kafka/pull/6239#pullrequestreview-201735787",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "dd8ef272-a3a8-49dd-a9eb-cf351e44653d",
        "parentId" : null,
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "`new TreeMap<K, V>()` is unsafe in general, because `K` is not known to be Comparable.\r\n\r\nYou can fix it by bounding the type in the class definition:\r\n```\r\npublic class InMemoryWindowStore<K extends Comparable<K>, V> implements WindowStore<K, V>\r\n```\r\n\r\nBut, if you like my earlier suggestion to just inline the desired types (`Bytes` and `byte[]`), this problem is also resolved, as `Bytes` is `Comparable`.",
        "createdAt" : "2019-02-08T20:39:10Z",
        "updatedAt" : "2019-02-21T03:08:16Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      }
    ],
    "commit" : "8284985337551c636fdd761939ef675ee5c84ce2",
    "line" : 145,
    "diffHunk" : "@@ -1,1 +143,147 @@        } else {\n            if (value != null) {\n                this.segmentMap.computeIfAbsent(windowStartTimestamp, t -> new TreeMap<>());\n                this.segmentMap.get(windowStartTimestamp).put(new WrappedK<>(key, seqnum), value);\n            } else {"
  },
  {
    "id" : "155954fd-1016-4f99-ad30-5c89dbf538b5",
    "prId" : 6239,
    "prUrl" : "https://github.com/apache/kafka/pull/6239#pullrequestreview-202788721",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ed95a873-f0c9-4e96-886f-8b36955d2d60",
        "parentId" : null,
        "authorId" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "body" : "Temporary fix, will likely make the switch from generics to <Bytes, byte[]> in separate PR",
        "createdAt" : "2019-02-12T00:11:28Z",
        "updatedAt" : "2019-02-21T03:08:16Z",
        "lastEditedBy" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "tags" : [
        ]
      },
      {
        "id" : "b52f757c-db34-4dde-b2b8-aacab4dd66d0",
        "parentId" : "ed95a873-f0c9-4e96-886f-8b36955d2d60",
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : ":+1: Maybe we should just consider that to be within the scope of https://issues.apache.org/jira/browse/KAFKA-7918 . (If you agree, can you leave a comment on the ticket to that effect?)",
        "createdAt" : "2019-02-12T16:59:07Z",
        "updatedAt" : "2019-02-21T03:08:16Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      }
    ],
    "commit" : "8284985337551c636fdd761939ef675ee5c84ce2",
    "line" : 50,
    "diffHunk" : "@@ -1,1 +48,52 @@import static org.apache.kafka.streams.state.internals.WindowKeySchema.extractStoreTimestamp;\n\npublic class InMemoryWindowStore<K extends Comparable<K>, V> implements WindowStore<K, V> {\n\n    private static final Logger LOG = LoggerFactory.getLogger(InMemoryWindowStore.class);"
  },
  {
    "id" : "dbd6fc8b-a0e8-4c23-8d82-b0806a464ac6",
    "prId" : 6239,
    "prUrl" : "https://github.com/apache/kafka/pull/6239#pullrequestreview-202919655",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "57226168-69fe-4261-9c5c-70ee4ceb493c",
        "parentId" : null,
        "authorId" : "4c968502-bb3d-46ee-8719-0c0bdbc6242f",
        "body" : "minor - `peekNextKey` not covered in the unit test",
        "createdAt" : "2019-02-12T22:00:39Z",
        "updatedAt" : "2019-02-21T03:08:16Z",
        "lastEditedBy" : "4c968502-bb3d-46ee-8719-0c0bdbc6242f",
        "tags" : [
        ]
      }
    ],
    "commit" : "8284985337551c636fdd761939ef675ee5c84ce2",
    "line" : 340,
    "diffHunk" : "@@ -1,1 +338,342 @@\n        @Override\n        public Long peekNextKey() {\n            if (!hasNext()) {\n                throw new NoSuchElementException();"
  },
  {
    "id" : "c5de33ab-fa8e-46c0-99bd-3f6f4eb02fbb",
    "prId" : 6239,
    "prUrl" : "https://github.com/apache/kafka/pull/6239#pullrequestreview-205865736",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "20ed8614-050a-46f5-83af-abb0a418b03e",
        "parentId" : null,
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "Could we consider having a follow-up PR to make these string constants that are hard-coded in multiple classes in a centralized place, e.g. `static final String EXPIRED_WINDOW_RECORD_DROP_OPERATION = \"expired-window-record-drop\";` in `StreamsMetricsImpl`.",
        "createdAt" : "2019-02-14T06:53:33Z",
        "updatedAt" : "2019-02-21T03:08:16Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "35ae971f-3dd0-45d8-8eb7-e5ee275f6fd1",
        "parentId" : "20ed8614-050a-46f5-83af-abb0a418b03e",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "Ditto for other string constants like \"late-record-drop\".",
        "createdAt" : "2019-02-14T06:54:18Z",
        "updatedAt" : "2019-02-21T03:08:16Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "7bdb954d-8564-4e8c-bf6c-70325ab1a2ca",
        "parentId" : "20ed8614-050a-46f5-83af-abb0a418b03e",
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : ":+1: I agree. We've seen some profiling results that suggest the widespread string literals from these metrics actually do cause memory pressure.",
        "createdAt" : "2019-02-20T16:34:49Z",
        "updatedAt" : "2019-02-21T03:08:16Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      }
    ],
    "commit" : "8284985337551c636fdd761939ef675ee5c84ce2",
    "line" : 114,
    "diffHunk" : "@@ -1,1 +112,116 @@            Sensor.RecordingLevel.INFO\n        );\n        addInvocationRateAndCount(\n            expiredRecordSensor,\n            \"stream-\" + metricScope + \"-metrics\","
  },
  {
    "id" : "1eea8d21-dc6a-4096-9000-acd9bd5ac164",
    "prId" : 6239,
    "prUrl" : "https://github.com/apache/kafka/pull/6239#pullrequestreview-204024080",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a676f10f-b72f-4ab7-9e3f-359aac419807",
        "parentId" : null,
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "If retainDuplicates is false, could we not storing the sequence suffix at all to save 4 bytes per record?",
        "createdAt" : "2019-02-14T07:15:25Z",
        "updatedAt" : "2019-02-21T03:08:16Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "36d78cc7-197d-4192-b12d-974b091fdbc4",
        "parentId" : "a676f10f-b72f-4ab7-9e3f-359aac419807",
        "authorId" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "body" : "I think this will be more straightforward after we remove the generics since we can just tack on the seqnum Bytes or not ",
        "createdAt" : "2019-02-14T23:09:09Z",
        "updatedAt" : "2019-02-21T03:08:16Z",
        "lastEditedBy" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "tags" : [
        ]
      },
      {
        "id" : "129e989d-fd62-4d76-8ed0-900d233a011d",
        "parentId" : "a676f10f-b72f-4ab7-9e3f-359aac419807",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "Sounds good.",
        "createdAt" : "2019-02-14T23:31:55Z",
        "updatedAt" : "2019-02-21T03:08:16Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      }
    ],
    "commit" : "8284985337551c636fdd761939ef675ee5c84ce2",
    "line" : 146,
    "diffHunk" : "@@ -1,1 +144,148 @@            if (value != null) {\n                this.segmentMap.computeIfAbsent(windowStartTimestamp, t -> new TreeMap<>());\n                this.segmentMap.get(windowStartTimestamp).put(new WrappedK<>(key, seqnum), value);\n            } else {\n                this.segmentMap.computeIfPresent(windowStartTimestamp, (t, kvMap) -> {"
  },
  {
    "id" : "88dd1917-552c-425c-b254-4cbbf868dc90",
    "prId" : 6239,
    "prUrl" : "https://github.com/apache/kafka/pull/6239#pullrequestreview-203586229",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "602cb49c-aa66-4d33-917f-75959e576467",
        "parentId" : null,
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "Not a comment for this PR: when we remove the generics, this function can be replaced with `WindowStoreIteratorWrapper` since the inner iterator would always be bytes.",
        "createdAt" : "2019-02-14T07:22:48Z",
        "updatedAt" : "2019-02-21T03:08:16Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      }
    ],
    "commit" : "8284985337551c636fdd761939ef675ee5c84ce2",
    "line" : 287,
    "diffHunk" : "@@ -1,1 +285,289 @@    }\n\n    private KeyValue<Windowed<K>, V> getWindowedKeyValue(final K key, final long startTimestamp, final V value) {\n        final Windowed<K> windowedK = new Windowed<>(key, new TimeWindow(startTimestamp, startTimestamp + windowSize));\n        return new KeyValue<>(windowedK, value);"
  },
  {
    "id" : "9b2488e1-53ff-4956-9521-046ed5fce034",
    "prId" : 6239,
    "prUrl" : "https://github.com/apache/kafka/pull/6239#pullrequestreview-205895226",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2e927c51-3cb8-4aa1-a3e0-411096f0aa6a",
        "parentId" : null,
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "I think we can consolidate these two iterators and the `InMemoryKeyValueStore#InMemoryKeyValueIterator` as a single wrapper iterator (note `WindowStoreIterator<V>` is just a `KeyValueStoreIterator<Long, V>.), that takes an `iterator` as inner. Then for supporting \"peekNextKey\" we do not really need to rely on list iterator's `previous` but just need to maintain the next element, and update it whenever `next()` is called and this element on-hold is returned.\r\n\r\nAnd when we removed the generics we can even consolidate all of them in `WindowStoreIteratorWrapper` as well.",
        "createdAt" : "2019-02-14T07:30:23Z",
        "updatedAt" : "2019-02-21T03:08:16Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "e6bfa352-f884-4d6e-b772-abe2a2371f41",
        "parentId" : "2e927c51-3cb8-4aa1-a3e0-411096f0aa6a",
        "authorId" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "body" : "The problem with using the WindowStoreIteratorWrapper here is that expects the key Bytes to actually be a windowed key ie to contain the timestamp, however with the in-memory version we want to avoid having to wrap the timestamp with the key as well so the iterator cant just extract it from the Bytes",
        "createdAt" : "2019-02-14T23:42:06Z",
        "updatedAt" : "2019-02-21T03:08:16Z",
        "lastEditedBy" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "tags" : [
        ]
      },
      {
        "id" : "266b035d-9a22-4237-8732-737f3e33bcd9",
        "parentId" : "2e927c51-3cb8-4aa1-a3e0-411096f0aa6a",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "When we removed the generics and allow have bytes in `InMemoryWindowStore`, when we return the inner ListIterator aren't we going to have each key be concatenated with key-bytes followed with timestamp-bytes anyways?",
        "createdAt" : "2019-02-15T02:01:28Z",
        "updatedAt" : "2019-02-21T03:08:16Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "31532793-cbd8-47d1-b91d-4dfca8af6574",
        "parentId" : "2e927c51-3cb8-4aa1-a3e0-411096f0aa6a",
        "authorId" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "body" : "Currently the key Bytes are wrapped up with timestamp into a windowed<key> type directly in the fetch call, whereas the WindowStoreIteratorWrapper is given an iterator over Bytes and it does the extraction of key+timestamp -> windowed<key> when accessed. We could rewrite the in-memory store as a single map with key+timestamp bytes as the key, but with the current implementation wrapping the key with the timestamp is a waste of space as we already map from each timestamp to a kv store",
        "createdAt" : "2019-02-15T18:18:06Z",
        "updatedAt" : "2019-02-21T03:08:16Z",
        "lastEditedBy" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "tags" : [
        ]
      },
      {
        "id" : "25d4563d-05ef-4a22-a3da-1bf0a2378433",
        "parentId" : "2e927c51-3cb8-4aa1-a3e0-411096f0aa6a",
        "authorId" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "body" : "John actually raised that as a possibility to improve clarity. I wasn't entirely convinced that it would make things easier to read but if you both agree, I can be. Certainly I agree it would be good to share the iterator code",
        "createdAt" : "2019-02-15T18:25:41Z",
        "updatedAt" : "2019-02-21T03:08:16Z",
        "lastEditedBy" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "tags" : [
        ]
      },
      {
        "id" : "8a155a2b-caf9-4b88-a44c-d1917a1f2ed0",
        "parentId" : "2e927c51-3cb8-4aa1-a3e0-411096f0aa6a",
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "In retrospect, I'm not sure I'm convinced either ;)\r\n\r\nOne nice aspect of your current design is that when we need to drop a window, we can do it in one operation.",
        "createdAt" : "2019-02-16T03:55:16Z",
        "updatedAt" : "2019-02-21T03:08:16Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      },
      {
        "id" : "5c413053-387b-4797-bb01-a933c40b9c1f",
        "parentId" : "2e927c51-3cb8-4aa1-a3e0-411096f0aa6a",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "Okay, I think I'm convinced. We should just leave it as is in this PR at least, and after it is merged I will think about it twice when reviewing the other PR for inlining the byte stores.",
        "createdAt" : "2019-02-20T17:26:03Z",
        "updatedAt" : "2019-02-21T03:08:16Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      }
    ],
    "commit" : "8284985337551c636fdd761939ef675ee5c84ce2",
    "line" : 321,
    "diffHunk" : "@@ -1,1 +319,323 @@    }\n\n    private static class InMemoryWindowStoreIterator<V> implements WindowStoreIterator<V> {\n\n        private ListIterator<KeyValue<Long, V>> iterator;"
  },
  {
    "id" : "7fe542e3-c1c7-4a2b-b83e-9678f5304529",
    "prId" : 6335,
    "prUrl" : "https://github.com/apache/kafka/pull/6335#pullrequestreview-209737771",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "27ae5f8d-6a46-42ae-a11e-1e5930341dc5",
        "parentId" : null,
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "Nice catch!",
        "createdAt" : "2019-03-01T19:04:46Z",
        "updatedAt" : "2019-03-01T19:25:32Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      }
    ],
    "commit" : "1d1dce3b33668d3dcfa848d14f2679d9f2d12294",
    "line" : 218,
    "diffHunk" : "@@ -1,1 +245,249 @@    private void removeExpiredSegments() {\n        long minLiveTime = Math.max(0L, this.observedStreamTime - this.retentionPeriod + 1);\n        for (final InMemoryWindowStoreIteratorWrapper it : openIterators) {\n            minLiveTime = Math.min(minLiveTime, it.minTime());\n        }"
  },
  {
    "id" : "62956506-6258-4b91-84d8-ae8afe7faf70",
    "prId" : 6595,
    "prUrl" : "https://github.com/apache/kafka/pull/6595#pullrequestreview-228551421",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3c33bcb0-5ffa-4edc-94b2-84f6f4b59dc6",
        "parentId" : null,
        "authorId" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "body" : "If the object is created with the no-argument constructor, this will throw an NPE.",
        "createdAt" : "2019-04-18T18:23:09Z",
        "updatedAt" : "2019-04-19T00:24:48Z",
        "lastEditedBy" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "tags" : [
        ]
      },
      {
        "id" : "f503ff92-fa96-47ca-9ed8-0250cecbcf21",
        "parentId" : "3c33bcb0-5ffa-4edc-94b2-84f6f4b59dc6",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "What's the benefits of using a callback here than calling `openIterators` directly? I think adding to `openIterators` outside of the constructor makes sense, but cannot think of the rationale of doing this upon closure.",
        "createdAt" : "2019-04-18T20:53:20Z",
        "updatedAt" : "2019-04-19T00:24:48Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "b140b73c-5a00-4528-a5f8-f11da30294d5",
        "parentId" : "3c33bcb0-5ffa-4edc-94b2-84f6f4b59dc6",
        "authorId" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "body" : "I felt it was appropriate to make the iterator class(es) static, in which case we need a way to remove from openIterators on closure. Will fix NPE when I add emptyIterator() method",
        "createdAt" : "2019-04-18T21:06:09Z",
        "updatedAt" : "2019-04-19T00:24:48Z",
        "lastEditedBy" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "tags" : [
        ]
      },
      {
        "id" : "cfacdad1-3bda-4756-8ff5-9ecc635f8c80",
        "parentId" : "3c33bcb0-5ffa-4edc-94b2-84f6f4b59dc6",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "Ack, thanks for the explanation.",
        "createdAt" : "2019-04-18T23:55:12Z",
        "updatedAt" : "2019-04-19T00:24:48Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      }
    ],
    "commit" : "fcd32003705334c5ed43a92b206f9df2f355de64",
    "line" : 269,
    "diffHunk" : "@@ -1,1 +353,357 @@\n        public void close() {\n            callback.deregisterIterator(this);\n        }\n"
  }
]
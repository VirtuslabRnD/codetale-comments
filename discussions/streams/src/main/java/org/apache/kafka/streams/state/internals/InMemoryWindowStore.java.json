[
  {
    "id" : "2d71f56c-3e30-454c-b671-c5900540c1dc",
    "prId" : 6239,
    "prUrl" : "https://github.com/apache/kafka/pull/6239#pullrequestreview-201735787",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "dd8ef272-a3a8-49dd-a9eb-cf351e44653d",
        "parentId" : null,
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "`new TreeMap<K, V>()` is unsafe in general, because `K` is not known to be Comparable.\r\n\r\nYou can fix it by bounding the type in the class definition:\r\n```\r\npublic class InMemoryWindowStore<K extends Comparable<K>, V> implements WindowStore<K, V>\r\n```\r\n\r\nBut, if you like my earlier suggestion to just inline the desired types (`Bytes` and `byte[]`), this problem is also resolved, as `Bytes` is `Comparable`.",
        "createdAt" : "2019-02-08T20:39:10Z",
        "updatedAt" : "2019-02-21T03:08:16Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      }
    ],
    "commit" : "8284985337551c636fdd761939ef675ee5c84ce2",
    "line" : 145,
    "diffHunk" : "@@ -1,1 +143,147 @@        } else {\n            if (value != null) {\n                this.segmentMap.computeIfAbsent(windowStartTimestamp, t -> new TreeMap<>());\n                this.segmentMap.get(windowStartTimestamp).put(new WrappedK<>(key, seqnum), value);\n            } else {"
  },
  {
    "id" : "155954fd-1016-4f99-ad30-5c89dbf538b5",
    "prId" : 6239,
    "prUrl" : "https://github.com/apache/kafka/pull/6239#pullrequestreview-202788721",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ed95a873-f0c9-4e96-886f-8b36955d2d60",
        "parentId" : null,
        "authorId" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "body" : "Temporary fix, will likely make the switch from generics to <Bytes, byte[]> in separate PR",
        "createdAt" : "2019-02-12T00:11:28Z",
        "updatedAt" : "2019-02-21T03:08:16Z",
        "lastEditedBy" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "tags" : [
        ]
      },
      {
        "id" : "b52f757c-db34-4dde-b2b8-aacab4dd66d0",
        "parentId" : "ed95a873-f0c9-4e96-886f-8b36955d2d60",
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : ":+1: Maybe we should just consider that to be within the scope of https://issues.apache.org/jira/browse/KAFKA-7918 . (If you agree, can you leave a comment on the ticket to that effect?)",
        "createdAt" : "2019-02-12T16:59:07Z",
        "updatedAt" : "2019-02-21T03:08:16Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      }
    ],
    "commit" : "8284985337551c636fdd761939ef675ee5c84ce2",
    "line" : 50,
    "diffHunk" : "@@ -1,1 +48,52 @@import static org.apache.kafka.streams.state.internals.WindowKeySchema.extractStoreTimestamp;\n\npublic class InMemoryWindowStore<K extends Comparable<K>, V> implements WindowStore<K, V> {\n\n    private static final Logger LOG = LoggerFactory.getLogger(InMemoryWindowStore.class);"
  },
  {
    "id" : "dbd6fc8b-a0e8-4c23-8d82-b0806a464ac6",
    "prId" : 6239,
    "prUrl" : "https://github.com/apache/kafka/pull/6239#pullrequestreview-202919655",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "57226168-69fe-4261-9c5c-70ee4ceb493c",
        "parentId" : null,
        "authorId" : "4c968502-bb3d-46ee-8719-0c0bdbc6242f",
        "body" : "minor - `peekNextKey` not covered in the unit test",
        "createdAt" : "2019-02-12T22:00:39Z",
        "updatedAt" : "2019-02-21T03:08:16Z",
        "lastEditedBy" : "4c968502-bb3d-46ee-8719-0c0bdbc6242f",
        "tags" : [
        ]
      }
    ],
    "commit" : "8284985337551c636fdd761939ef675ee5c84ce2",
    "line" : 340,
    "diffHunk" : "@@ -1,1 +338,342 @@\n        @Override\n        public Long peekNextKey() {\n            if (!hasNext()) {\n                throw new NoSuchElementException();"
  },
  {
    "id" : "c5de33ab-fa8e-46c0-99bd-3f6f4eb02fbb",
    "prId" : 6239,
    "prUrl" : "https://github.com/apache/kafka/pull/6239#pullrequestreview-205865736",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "20ed8614-050a-46f5-83af-abb0a418b03e",
        "parentId" : null,
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "Could we consider having a follow-up PR to make these string constants that are hard-coded in multiple classes in a centralized place, e.g. `static final String EXPIRED_WINDOW_RECORD_DROP_OPERATION = \"expired-window-record-drop\";` in `StreamsMetricsImpl`.",
        "createdAt" : "2019-02-14T06:53:33Z",
        "updatedAt" : "2019-02-21T03:08:16Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "35ae971f-3dd0-45d8-8eb7-e5ee275f6fd1",
        "parentId" : "20ed8614-050a-46f5-83af-abb0a418b03e",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "Ditto for other string constants like \"late-record-drop\".",
        "createdAt" : "2019-02-14T06:54:18Z",
        "updatedAt" : "2019-02-21T03:08:16Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "7bdb954d-8564-4e8c-bf6c-70325ab1a2ca",
        "parentId" : "20ed8614-050a-46f5-83af-abb0a418b03e",
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : ":+1: I agree. We've seen some profiling results that suggest the widespread string literals from these metrics actually do cause memory pressure.",
        "createdAt" : "2019-02-20T16:34:49Z",
        "updatedAt" : "2019-02-21T03:08:16Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      }
    ],
    "commit" : "8284985337551c636fdd761939ef675ee5c84ce2",
    "line" : 114,
    "diffHunk" : "@@ -1,1 +112,116 @@            Sensor.RecordingLevel.INFO\n        );\n        addInvocationRateAndCount(\n            expiredRecordSensor,\n            \"stream-\" + metricScope + \"-metrics\","
  },
  {
    "id" : "1eea8d21-dc6a-4096-9000-acd9bd5ac164",
    "prId" : 6239,
    "prUrl" : "https://github.com/apache/kafka/pull/6239#pullrequestreview-204024080",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a676f10f-b72f-4ab7-9e3f-359aac419807",
        "parentId" : null,
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "If retainDuplicates is false, could we not storing the sequence suffix at all to save 4 bytes per record?",
        "createdAt" : "2019-02-14T07:15:25Z",
        "updatedAt" : "2019-02-21T03:08:16Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "36d78cc7-197d-4192-b12d-974b091fdbc4",
        "parentId" : "a676f10f-b72f-4ab7-9e3f-359aac419807",
        "authorId" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "body" : "I think this will be more straightforward after we remove the generics since we can just tack on the seqnum Bytes or not ",
        "createdAt" : "2019-02-14T23:09:09Z",
        "updatedAt" : "2019-02-21T03:08:16Z",
        "lastEditedBy" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "tags" : [
        ]
      },
      {
        "id" : "129e989d-fd62-4d76-8ed0-900d233a011d",
        "parentId" : "a676f10f-b72f-4ab7-9e3f-359aac419807",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "Sounds good.",
        "createdAt" : "2019-02-14T23:31:55Z",
        "updatedAt" : "2019-02-21T03:08:16Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      }
    ],
    "commit" : "8284985337551c636fdd761939ef675ee5c84ce2",
    "line" : 146,
    "diffHunk" : "@@ -1,1 +144,148 @@            if (value != null) {\n                this.segmentMap.computeIfAbsent(windowStartTimestamp, t -> new TreeMap<>());\n                this.segmentMap.get(windowStartTimestamp).put(new WrappedK<>(key, seqnum), value);\n            } else {\n                this.segmentMap.computeIfPresent(windowStartTimestamp, (t, kvMap) -> {"
  },
  {
    "id" : "88dd1917-552c-425c-b254-4cbbf868dc90",
    "prId" : 6239,
    "prUrl" : "https://github.com/apache/kafka/pull/6239#pullrequestreview-203586229",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "602cb49c-aa66-4d33-917f-75959e576467",
        "parentId" : null,
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "Not a comment for this PR: when we remove the generics, this function can be replaced with `WindowStoreIteratorWrapper` since the inner iterator would always be bytes.",
        "createdAt" : "2019-02-14T07:22:48Z",
        "updatedAt" : "2019-02-21T03:08:16Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      }
    ],
    "commit" : "8284985337551c636fdd761939ef675ee5c84ce2",
    "line" : 287,
    "diffHunk" : "@@ -1,1 +285,289 @@    }\n\n    private KeyValue<Windowed<K>, V> getWindowedKeyValue(final K key, final long startTimestamp, final V value) {\n        final Windowed<K> windowedK = new Windowed<>(key, new TimeWindow(startTimestamp, startTimestamp + windowSize));\n        return new KeyValue<>(windowedK, value);"
  },
  {
    "id" : "9b2488e1-53ff-4956-9521-046ed5fce034",
    "prId" : 6239,
    "prUrl" : "https://github.com/apache/kafka/pull/6239#pullrequestreview-205895226",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2e927c51-3cb8-4aa1-a3e0-411096f0aa6a",
        "parentId" : null,
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "I think we can consolidate these two iterators and the `InMemoryKeyValueStore#InMemoryKeyValueIterator` as a single wrapper iterator (note `WindowStoreIterator<V>` is just a `KeyValueStoreIterator<Long, V>.), that takes an `iterator` as inner. Then for supporting \"peekNextKey\" we do not really need to rely on list iterator's `previous` but just need to maintain the next element, and update it whenever `next()` is called and this element on-hold is returned.\r\n\r\nAnd when we removed the generics we can even consolidate all of them in `WindowStoreIteratorWrapper` as well.",
        "createdAt" : "2019-02-14T07:30:23Z",
        "updatedAt" : "2019-02-21T03:08:16Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "e6bfa352-f884-4d6e-b772-abe2a2371f41",
        "parentId" : "2e927c51-3cb8-4aa1-a3e0-411096f0aa6a",
        "authorId" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "body" : "The problem with using the WindowStoreIteratorWrapper here is that expects the key Bytes to actually be a windowed key ie to contain the timestamp, however with the in-memory version we want to avoid having to wrap the timestamp with the key as well so the iterator cant just extract it from the Bytes",
        "createdAt" : "2019-02-14T23:42:06Z",
        "updatedAt" : "2019-02-21T03:08:16Z",
        "lastEditedBy" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "tags" : [
        ]
      },
      {
        "id" : "266b035d-9a22-4237-8732-737f3e33bcd9",
        "parentId" : "2e927c51-3cb8-4aa1-a3e0-411096f0aa6a",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "When we removed the generics and allow have bytes in `InMemoryWindowStore`, when we return the inner ListIterator aren't we going to have each key be concatenated with key-bytes followed with timestamp-bytes anyways?",
        "createdAt" : "2019-02-15T02:01:28Z",
        "updatedAt" : "2019-02-21T03:08:16Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "31532793-cbd8-47d1-b91d-4dfca8af6574",
        "parentId" : "2e927c51-3cb8-4aa1-a3e0-411096f0aa6a",
        "authorId" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "body" : "Currently the key Bytes are wrapped up with timestamp into a windowed<key> type directly in the fetch call, whereas the WindowStoreIteratorWrapper is given an iterator over Bytes and it does the extraction of key+timestamp -> windowed<key> when accessed. We could rewrite the in-memory store as a single map with key+timestamp bytes as the key, but with the current implementation wrapping the key with the timestamp is a waste of space as we already map from each timestamp to a kv store",
        "createdAt" : "2019-02-15T18:18:06Z",
        "updatedAt" : "2019-02-21T03:08:16Z",
        "lastEditedBy" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "tags" : [
        ]
      },
      {
        "id" : "25d4563d-05ef-4a22-a3da-1bf0a2378433",
        "parentId" : "2e927c51-3cb8-4aa1-a3e0-411096f0aa6a",
        "authorId" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "body" : "John actually raised that as a possibility to improve clarity. I wasn't entirely convinced that it would make things easier to read but if you both agree, I can be. Certainly I agree it would be good to share the iterator code",
        "createdAt" : "2019-02-15T18:25:41Z",
        "updatedAt" : "2019-02-21T03:08:16Z",
        "lastEditedBy" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "tags" : [
        ]
      },
      {
        "id" : "8a155a2b-caf9-4b88-a44c-d1917a1f2ed0",
        "parentId" : "2e927c51-3cb8-4aa1-a3e0-411096f0aa6a",
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "In retrospect, I'm not sure I'm convinced either ;)\r\n\r\nOne nice aspect of your current design is that when we need to drop a window, we can do it in one operation.",
        "createdAt" : "2019-02-16T03:55:16Z",
        "updatedAt" : "2019-02-21T03:08:16Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      },
      {
        "id" : "5c413053-387b-4797-bb01-a933c40b9c1f",
        "parentId" : "2e927c51-3cb8-4aa1-a3e0-411096f0aa6a",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "Okay, I think I'm convinced. We should just leave it as is in this PR at least, and after it is merged I will think about it twice when reviewing the other PR for inlining the byte stores.",
        "createdAt" : "2019-02-20T17:26:03Z",
        "updatedAt" : "2019-02-21T03:08:16Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      }
    ],
    "commit" : "8284985337551c636fdd761939ef675ee5c84ce2",
    "line" : 321,
    "diffHunk" : "@@ -1,1 +319,323 @@    }\n\n    private static class InMemoryWindowStoreIterator<V> implements WindowStoreIterator<V> {\n\n        private ListIterator<KeyValue<Long, V>> iterator;"
  }
]
[
  {
    "id" : "d0794f99-2770-4b9a-8437-b7503f85e304",
    "prId" : 5107,
    "prUrl" : "https://github.com/apache/kafka/pull/5107#pullrequestreview-126543939",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7b129d1e-ae33-408e-8490-ec85f82851dc",
        "parentId" : null,
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "This will return the value for `\"poll.ms\"` -- Should we check for `\"global.consumer.poll.ms\"` and user this value if present instead?",
        "createdAt" : "2018-06-05T20:07:14Z",
        "updatedAt" : "2018-06-08T15:17:39Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "c72d7126-c2e3-4995-89d5-710537122ff2",
        "parentId" : "7b129d1e-ae33-408e-8490-ec85f82851dc",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "Hmm.. `poll.ms` is not a ConsumerConfig, but a StreamsConfig, so users are not expected to prefix it with the consumer.",
        "createdAt" : "2018-06-05T21:18:36Z",
        "updatedAt" : "2018-06-08T15:17:39Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "1c931c0a-a18e-4415-b896-a9847af390ca",
        "parentId" : "7b129d1e-ae33-408e-8490-ec85f82851dc",
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "I see what you mean. Still I am wondering if a single config for all consumers is smart. Also, the config is only used to pass into `Consumer#poll()` -- so even if it's not a config *parameter*, it's effectively still very similar to a \"consumer config\". I agree that it would required explicit documentation.",
        "createdAt" : "2018-06-06T18:38:48Z",
        "updatedAt" : "2018-06-08T15:17:39Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "f2578846-fd8d-4a5b-9de5-ed50239407c9",
        "parentId" : "7b129d1e-ae33-408e-8490-ec85f82851dc",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "I agree it is generally better to allow different values for this; on the other hand, I felt it is too much of a lower-level details for people to really figure it out right. For example, today global consumers have two callers of `poll()`, restore consumer has two as well, and normal consumer has one. We can argue further that all these five calls may prefer different values for the reason we discussed in this PR, like whether it is call in the main loop or not.\r\n\r\nBesides, if want to allow prefix for this config we can rush it into 2.0, but it may be considered a public API change as well.",
        "createdAt" : "2018-06-06T19:05:20Z",
        "updatedAt" : "2018-06-08T15:17:39Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "bc1562d9-c1cb-4def-9354-f7529af064a0",
        "parentId" : "7b129d1e-ae33-408e-8490-ec85f82851dc",
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "Ack. I just convinced myself that it makes sense what you say. As you pointed out, we call poll() on different consumers with different purpose:\r\n\r\nnormale processing:\r\n - main-consumer\r\n - global-consumer (regular g-table update)\r\n\r\nupdating standby tasks:\r\n - restore-consumer\r\n\r\nrestoring:\r\n - main-consumer (that is still doing regular work)\r\n - restore-consumer\r\n - global-consumer\r\n\r\nApplying the same value `poll.ms` to main and global consumer in normal processing case makes sense to me. For updating standby-tasks, we hard-code \"zero\" already. Same for the main-consumer during restore phase, to speed up restoring. Both are reasonable choices. The last case, is the restore case for restore-consumer and global-consumer -- it might make sense to apply a different poll-time for thiscase, but I also think that using the same as for the normal processing case is fine.\r\n\r\nThus, long story short, iff we ever introduce a prefix for `poll.ms` parameters, it should be for \"normal processing phase\" and \"restore phase\" but should not be tied to the actual used consumer-instance. Thus, using the consumer prefix does not make sense.\r\n",
        "createdAt" : "2018-06-06T20:34:17Z",
        "updatedAt" : "2018-06-08T15:17:39Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      }
    ],
    "commit" : "b829d558490d21cf4350eb54a4f18880243744ba",
    "line" : 20,
    "diffHunk" : "@@ -1,1 +79,83 @@        this.retries = config.getInt(StreamsConfig.RETRIES_CONFIG);\n        this.retryBackoffMs = config.getLong(StreamsConfig.RETRY_BACKOFF_MS_CONFIG);\n        this.pollTime = Duration.ofMillis(config.getLong(StreamsConfig.POLL_MS_CONFIG));\n    }\n"
  },
  {
    "id" : "8cb8c45c-581f-47e8-acbf-512fc98bd259",
    "prId" : 5710,
    "prUrl" : "https://github.com/apache/kafka/pull/5710#pullrequestreview-159719713",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "17ca17ea-b057-47cc-b97b-5de1dbc6a0ef",
        "parentId" : null,
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "The way it works is that now, we just go ahead and send the full consumer records, and the adapter will take care of converting it to `KeyValue`s if that's what the callback needs.",
        "createdAt" : "2018-09-28T05:00:25Z",
        "updatedAt" : "2018-09-29T02:36:52Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      }
    ],
    "commit" : "bb44b1306c0fb643cc1df100c6fbea5427706d28",
    "line" : 42,
    "diffHunk" : "@@ -1,1 +278,282 @@                    }\n                    offset = globalConsumer.position(topicPartition);\n                    stateRestoreAdapter.restoreBatch(restoreRecords);\n                    stateRestoreListener.onBatchRestored(topicPartition, storeName, offset, restoreRecords.size());\n                    restoreCount += restoreRecords.size();"
  },
  {
    "id" : "066eaac4-c856-43dc-a528-31b2e70ffd03",
    "prId" : 5710,
    "prUrl" : "https://github.com/apache/kafka/pull/5710#pullrequestreview-160081853",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8b5cfa1b-b3bb-4a5a-9da1-8769fa58e873",
        "parentId" : null,
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "We can just use `ConsumerRecords#records(TopicPartition partition)` since it should only contain one topic-partition's records.",
        "createdAt" : "2018-09-28T22:57:32Z",
        "updatedAt" : "2018-09-29T02:36:52Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "9d897630-56e7-45a2-89e4-b335146c3b40",
        "parentId" : "8b5cfa1b-b3bb-4a5a-9da1-8769fa58e873",
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "I'm sorry; I didn't follow this. \r\n\r\nAre you suggesting to do `final List<ConsumerRecord<byte[], byte[]>> restoreRecords = records.records(topicPartition)`? \r\n\r\nThis would return the right type, but `restoreRecords`  is a filtered list of only records with non-null keys. It doesn't look like `ConsumerRecords#records` applies this filter.",
        "createdAt" : "2018-09-28T23:52:27Z",
        "updatedAt" : "2018-09-29T02:36:52Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      },
      {
        "id" : "b1e8d804-c778-4b6a-a565-38296497669f",
        "parentId" : "8b5cfa1b-b3bb-4a5a-9da1-8769fa58e873",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "I need to be specific with my comments :)\r\n\r\nI'm suggesting sth like `records.records(topicPartition).stream().filter().collect()`, the main point is that `ConsumerRecords#iterate` which is used as `final ConsumerRecord<byte[], byte[]> record : records` is a pretty complex operator and is unnecessary here since we know it will only contain one topic-partition.\r\n\r\n",
        "createdAt" : "2018-09-28T23:58:01Z",
        "updatedAt" : "2018-09-29T02:36:52Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "363ad374-bda6-401a-a41a-24cc9392b749",
        "parentId" : "8b5cfa1b-b3bb-4a5a-9da1-8769fa58e873",
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "aaah. Now I understand.",
        "createdAt" : "2018-09-29T01:18:05Z",
        "updatedAt" : "2018-09-29T02:36:52Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      },
      {
        "id" : "1408c0f7-95bb-446b-add2-651d39914cdc",
        "parentId" : "8b5cfa1b-b3bb-4a5a-9da1-8769fa58e873",
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "I've done this, but I stuck with the foreach loop (and also went back to it in the adapter), as this code path is hot, and I'm not sure of the overhead of `stream()`.",
        "createdAt" : "2018-09-29T01:53:15Z",
        "updatedAt" : "2018-09-29T02:36:52Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      },
      {
        "id" : "96d40d3a-cd9e-4d06-86c3-fda58ec779d1",
        "parentId" : "8b5cfa1b-b3bb-4a5a-9da1-8769fa58e873",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "In that case could we just use the foreach loop after `ConsumerRecords#records` to get the filter list from the returned list? I just felt leveraging on `ConsumerRecords#iterator` is unnecessarily costly.",
        "createdAt" : "2018-09-29T04:11:13Z",
        "updatedAt" : "2018-09-29T04:11:13Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "5ef6fd46-c025-40a6-a12f-282f935882d0",
        "parentId" : "8b5cfa1b-b3bb-4a5a-9da1-8769fa58e873",
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "I think this is what I've done in the most recent version of the code: https://github.com/apache/kafka/pull/5710/files#diff-e870eab2dedeee93442ba87dc12609a4R277\r\n```\r\nfor (final ConsumerRecord<byte[], byte[]> record : records.records(topicPartition)) {\r\n  if (record.key() != null) {\r\n    restoreRecords.add(record);\r\n  }\r\n}\r\n```\r\nIs that what you're thinking?",
        "createdAt" : "2018-09-29T14:04:42Z",
        "updatedAt" : "2018-09-29T14:04:42Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      }
    ],
    "commit" : "bb44b1306c0fb643cc1df100c6fbea5427706d28",
    "line" : 33,
    "diffHunk" : "@@ -1,1 +271,275 @@                try {\n                    final ConsumerRecords<byte[], byte[]> records = globalConsumer.poll(pollTime);\n                    final List<ConsumerRecord<byte[], byte[]>> restoreRecords = new ArrayList<>();\n                    for (final ConsumerRecord<byte[], byte[]> record : records.records(topicPartition)) {\n                        if (record.key() != null) {"
  }
]
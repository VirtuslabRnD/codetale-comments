[
  {
    "id" : "d0794f99-2770-4b9a-8437-b7503f85e304",
    "prId" : 5107,
    "prUrl" : "https://github.com/apache/kafka/pull/5107#pullrequestreview-126543939",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7b129d1e-ae33-408e-8490-ec85f82851dc",
        "parentId" : null,
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "This will return the value for `\"poll.ms\"` -- Should we check for `\"global.consumer.poll.ms\"` and user this value if present instead?",
        "createdAt" : "2018-06-05T20:07:14Z",
        "updatedAt" : "2018-06-08T15:17:39Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "c72d7126-c2e3-4995-89d5-710537122ff2",
        "parentId" : "7b129d1e-ae33-408e-8490-ec85f82851dc",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "Hmm.. `poll.ms` is not a ConsumerConfig, but a StreamsConfig, so users are not expected to prefix it with the consumer.",
        "createdAt" : "2018-06-05T21:18:36Z",
        "updatedAt" : "2018-06-08T15:17:39Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "1c931c0a-a18e-4415-b896-a9847af390ca",
        "parentId" : "7b129d1e-ae33-408e-8490-ec85f82851dc",
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "I see what you mean. Still I am wondering if a single config for all consumers is smart. Also, the config is only used to pass into `Consumer#poll()` -- so even if it's not a config *parameter*, it's effectively still very similar to a \"consumer config\". I agree that it would required explicit documentation.",
        "createdAt" : "2018-06-06T18:38:48Z",
        "updatedAt" : "2018-06-08T15:17:39Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "f2578846-fd8d-4a5b-9de5-ed50239407c9",
        "parentId" : "7b129d1e-ae33-408e-8490-ec85f82851dc",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "I agree it is generally better to allow different values for this; on the other hand, I felt it is too much of a lower-level details for people to really figure it out right. For example, today global consumers have two callers of `poll()`, restore consumer has two as well, and normal consumer has one. We can argue further that all these five calls may prefer different values for the reason we discussed in this PR, like whether it is call in the main loop or not.\r\n\r\nBesides, if want to allow prefix for this config we can rush it into 2.0, but it may be considered a public API change as well.",
        "createdAt" : "2018-06-06T19:05:20Z",
        "updatedAt" : "2018-06-08T15:17:39Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "bc1562d9-c1cb-4def-9354-f7529af064a0",
        "parentId" : "7b129d1e-ae33-408e-8490-ec85f82851dc",
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "Ack. I just convinced myself that it makes sense what you say. As you pointed out, we call poll() on different consumers with different purpose:\r\n\r\nnormale processing:\r\n - main-consumer\r\n - global-consumer (regular g-table update)\r\n\r\nupdating standby tasks:\r\n - restore-consumer\r\n\r\nrestoring:\r\n - main-consumer (that is still doing regular work)\r\n - restore-consumer\r\n - global-consumer\r\n\r\nApplying the same value `poll.ms` to main and global consumer in normal processing case makes sense to me. For updating standby-tasks, we hard-code \"zero\" already. Same for the main-consumer during restore phase, to speed up restoring. Both are reasonable choices. The last case, is the restore case for restore-consumer and global-consumer -- it might make sense to apply a different poll-time for thiscase, but I also think that using the same as for the normal processing case is fine.\r\n\r\nThus, long story short, iff we ever introduce a prefix for `poll.ms` parameters, it should be for \"normal processing phase\" and \"restore phase\" but should not be tied to the actual used consumer-instance. Thus, using the consumer prefix does not make sense.\r\n",
        "createdAt" : "2018-06-06T20:34:17Z",
        "updatedAt" : "2018-06-08T15:17:39Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      }
    ],
    "commit" : "b829d558490d21cf4350eb54a4f18880243744ba",
    "line" : 20,
    "diffHunk" : "@@ -1,1 +79,83 @@        this.retries = config.getInt(StreamsConfig.RETRIES_CONFIG);\n        this.retryBackoffMs = config.getLong(StreamsConfig.RETRY_BACKOFF_MS_CONFIG);\n        this.pollTime = Duration.ofMillis(config.getLong(StreamsConfig.POLL_MS_CONFIG));\n    }\n"
  },
  {
    "id" : "8cb8c45c-581f-47e8-acbf-512fc98bd259",
    "prId" : 5710,
    "prUrl" : "https://github.com/apache/kafka/pull/5710#pullrequestreview-159719713",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "17ca17ea-b057-47cc-b97b-5de1dbc6a0ef",
        "parentId" : null,
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "The way it works is that now, we just go ahead and send the full consumer records, and the adapter will take care of converting it to `KeyValue`s if that's what the callback needs.",
        "createdAt" : "2018-09-28T05:00:25Z",
        "updatedAt" : "2018-09-29T02:36:52Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      }
    ],
    "commit" : "bb44b1306c0fb643cc1df100c6fbea5427706d28",
    "line" : 42,
    "diffHunk" : "@@ -1,1 +278,282 @@                    }\n                    offset = globalConsumer.position(topicPartition);\n                    stateRestoreAdapter.restoreBatch(restoreRecords);\n                    stateRestoreListener.onBatchRestored(topicPartition, storeName, offset, restoreRecords.size());\n                    restoreCount += restoreRecords.size();"
  },
  {
    "id" : "066eaac4-c856-43dc-a528-31b2e70ffd03",
    "prId" : 5710,
    "prUrl" : "https://github.com/apache/kafka/pull/5710#pullrequestreview-160081853",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8b5cfa1b-b3bb-4a5a-9da1-8769fa58e873",
        "parentId" : null,
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "We can just use `ConsumerRecords#records(TopicPartition partition)` since it should only contain one topic-partition's records.",
        "createdAt" : "2018-09-28T22:57:32Z",
        "updatedAt" : "2018-09-29T02:36:52Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "9d897630-56e7-45a2-89e4-b335146c3b40",
        "parentId" : "8b5cfa1b-b3bb-4a5a-9da1-8769fa58e873",
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "I'm sorry; I didn't follow this. \r\n\r\nAre you suggesting to do `final List<ConsumerRecord<byte[], byte[]>> restoreRecords = records.records(topicPartition)`? \r\n\r\nThis would return the right type, but `restoreRecords`  is a filtered list of only records with non-null keys. It doesn't look like `ConsumerRecords#records` applies this filter.",
        "createdAt" : "2018-09-28T23:52:27Z",
        "updatedAt" : "2018-09-29T02:36:52Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      },
      {
        "id" : "b1e8d804-c778-4b6a-a565-38296497669f",
        "parentId" : "8b5cfa1b-b3bb-4a5a-9da1-8769fa58e873",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "I need to be specific with my comments :)\r\n\r\nI'm suggesting sth like `records.records(topicPartition).stream().filter().collect()`, the main point is that `ConsumerRecords#iterate` which is used as `final ConsumerRecord<byte[], byte[]> record : records` is a pretty complex operator and is unnecessary here since we know it will only contain one topic-partition.\r\n\r\n",
        "createdAt" : "2018-09-28T23:58:01Z",
        "updatedAt" : "2018-09-29T02:36:52Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "363ad374-bda6-401a-a41a-24cc9392b749",
        "parentId" : "8b5cfa1b-b3bb-4a5a-9da1-8769fa58e873",
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "aaah. Now I understand.",
        "createdAt" : "2018-09-29T01:18:05Z",
        "updatedAt" : "2018-09-29T02:36:52Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      },
      {
        "id" : "1408c0f7-95bb-446b-add2-651d39914cdc",
        "parentId" : "8b5cfa1b-b3bb-4a5a-9da1-8769fa58e873",
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "I've done this, but I stuck with the foreach loop (and also went back to it in the adapter), as this code path is hot, and I'm not sure of the overhead of `stream()`.",
        "createdAt" : "2018-09-29T01:53:15Z",
        "updatedAt" : "2018-09-29T02:36:52Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      },
      {
        "id" : "96d40d3a-cd9e-4d06-86c3-fda58ec779d1",
        "parentId" : "8b5cfa1b-b3bb-4a5a-9da1-8769fa58e873",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "In that case could we just use the foreach loop after `ConsumerRecords#records` to get the filter list from the returned list? I just felt leveraging on `ConsumerRecords#iterator` is unnecessarily costly.",
        "createdAt" : "2018-09-29T04:11:13Z",
        "updatedAt" : "2018-09-29T04:11:13Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "5ef6fd46-c025-40a6-a12f-282f935882d0",
        "parentId" : "8b5cfa1b-b3bb-4a5a-9da1-8769fa58e873",
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "I think this is what I've done in the most recent version of the code: https://github.com/apache/kafka/pull/5710/files#diff-e870eab2dedeee93442ba87dc12609a4R277\r\n```\r\nfor (final ConsumerRecord<byte[], byte[]> record : records.records(topicPartition)) {\r\n  if (record.key() != null) {\r\n    restoreRecords.add(record);\r\n  }\r\n}\r\n```\r\nIs that what you're thinking?",
        "createdAt" : "2018-09-29T14:04:42Z",
        "updatedAt" : "2018-09-29T14:04:42Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      }
    ],
    "commit" : "bb44b1306c0fb643cc1df100c6fbea5427706d28",
    "line" : 33,
    "diffHunk" : "@@ -1,1 +271,275 @@                try {\n                    final ConsumerRecords<byte[], byte[]> records = globalConsumer.poll(pollTime);\n                    final List<ConsumerRecord<byte[], byte[]>> restoreRecords = new ArrayList<>();\n                    for (final ConsumerRecord<byte[], byte[]> record : records.records(topicPartition)) {\n                        if (record.key() != null) {"
  },
  {
    "id" : "4a28f15d-3a58-49e0-b8f5-cae8aa13d516",
    "prId" : 6150,
    "prUrl" : "https://github.com/apache/kafka/pull/6150#pullrequestreview-192911047",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "12e07bab-01c5-4939-8c72-45317bcf0557",
        "parentId" : null,
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "Stores can implement the `RecordConverter` interface -- if they don't do, we use default no-op converter that maps from key-value to key-value.",
        "createdAt" : "2019-01-15T23:16:07Z",
        "updatedAt" : "2019-01-19T05:57:33Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      }
    ],
    "commit" : "f2435661add504b15e5da5d76445cb268a8e7e80",
    "line" : 17,
    "diffHunk" : "@@ -1,1 +201,205 @@                store instanceof WrappedStateStore ? ((WrappedStateStore) store).inner() : store;\n            final RecordConverter recordConverter =\n                stateStore instanceof RecordConverter ? (RecordConverter) stateStore : new DefaultRecordConverter();\n\n            restoreState("
  },
  {
    "id" : "9dd65292-299d-41d9-bee5-0765678456da",
    "prId" : 7030,
    "prUrl" : "https://github.com/apache/kafka/pull/7030#pullrequestreview-257624022",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "55d79984-ed74-49e4-af48-ee72650e5873",
        "parentId" : null,
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "Stop sharing mutable state between a superclass and subclass. The only reason to do it was to support the re-initialization logic, but the checkpoint map can just as easily be passed in as a parameter.",
        "createdAt" : "2019-07-03T17:03:47Z",
        "updatedAt" : "2019-07-09T23:16:30Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      }
    ],
    "commit" : "7b33b85c4fa71ed08802599697404720a66d88ef",
    "line" : 28,
    "diffHunk" : "@@ -1,1 +58,62 @@ * of Global State Stores. There is only ever 1 instance of this class per Application Instance.\n */\npublic class GlobalStateManagerImpl implements GlobalStateManager {\n    private final Logger log;\n    private final boolean eosEnabled;"
  },
  {
    "id" : "5a4fed34-6e02-44fa-8e59-1ee961117c84",
    "prId" : 7030,
    "prUrl" : "https://github.com/apache/kafka/pull/7030#pullrequestreview-257624022",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "71a02fd0-deaf-4d1c-ab73-fc06c814eb6f",
        "parentId" : null,
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "It took me a _really_ long time to decipher the actual purposes of \"checkpoint\" and \"checkpointableOffsets\". I've renamed them to \"checkpointFile\" and \"checkpointFileCache\" to be more self-documenting.",
        "createdAt" : "2019-07-03T17:06:01Z",
        "updatedAt" : "2019-07-09T23:16:30Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      }
    ],
    "commit" : "7b33b85c4fa71ed08802599697404720a66d88ef",
    "line" : 57,
    "diffHunk" : "@@ -1,1 +85,89 @@        baseDir = stateDirectory.globalStateDir();\n        checkpointFile = new OffsetCheckpoint(new File(baseDir, CHECKPOINT_FILE_NAME));\n        checkpointFileCache = new HashMap<>();\n\n        // Find non persistent store's topics"
  },
  {
    "id" : "0cf32eb1-319f-478b-bb50-a1fd08d81706",
    "prId" : 7030,
    "prUrl" : "https://github.com/apache/kafka/pull/7030#pullrequestreview-257624022",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f1609caf-d048-489a-9de5-fb51669b14e4",
        "parentId" : null,
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "Since this PR is to clean up difficult-to-maintain code, I also included other cleanups, like dropping unnecessary `this` modifiers, restricting too-broad catch blocks, etc.",
        "createdAt" : "2019-07-03T17:08:36Z",
        "updatedAt" : "2019-07-09T23:16:30Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      }
    ],
    "commit" : "7b33b85c4fa71ed08802599697404720a66d88ef",
    "line" : 170,
    "diffHunk" : "@@ -1,1 +357,361 @@                    try {\n                        entry.getValue().get().close();\n                    } catch (final RuntimeException e) {\n                        log.error(\"Failed to close global state store {}\", entry.getKey(), e);\n                        closeFailed.append(\"Failed to close global state store:\")"
  },
  {
    "id" : "c436f55f-5c2a-4bbd-924d-7cd22dcc145b",
    "prId" : 7030,
    "prUrl" : "https://github.com/apache/kafka/pull/7030#pullrequestreview-257624022",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "063c9f0a-e924-42ef-aca2-8cc72c783f9d",
        "parentId" : null,
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "unnecessary `toString`",
        "createdAt" : "2019-07-03T17:08:47Z",
        "updatedAt" : "2019-07-09T23:16:30Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      }
    ],
    "commit" : "7b33b85c4fa71ed08802599697404720a66d88ef",
    "line" : 176,
    "diffHunk" : "@@ -1,1 +362,366 @@                                   .append(entry.getKey())\n                                   .append(\". Reason: \")\n                                   .append(e)\n                                   .append(\"\\n\");\n                    }"
  },
  {
    "id" : "7c879577-5775-4fdd-b27a-646a0ad0ac82",
    "prId" : 7997,
    "prUrl" : "https://github.com/apache/kafka/pull/7997#pullrequestreview-352566083",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b2aa7c56-5837-4a9c-bbde-b1d5147f14bc",
        "parentId" : null,
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "There's still a TODO here that hasn't been handled.",
        "createdAt" : "2020-01-31T21:02:11Z",
        "updatedAt" : "2020-02-05T05:05:33Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      },
      {
        "id" : "c1992a55-e8ff-4e85-acfc-5aac1cf915d7",
        "parentId" : "b2aa7c56-5837-4a9c-bbde-b1d5147f14bc",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "Yes it is to be handled in a follow-up PR.",
        "createdAt" : "2020-02-03T21:13:02Z",
        "updatedAt" : "2020-02-05T05:05:33Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      }
    ],
    "commit" : "196e7c0210b659ec81335d5624ae0cf5127fdf21",
    "line" : 70,
    "diffHunk" : "@@ -1,1 +309,313 @@                        recoverableException.toString());\n\n                    // TODO K9113: we remove the re-init logic and push it to be handled by the thread directly\n\n                    restoreCount = 0L;"
  },
  {
    "id" : "531c01c1-2b39-4db1-983f-3baef678ea5c",
    "prId" : 8864,
    "prUrl" : "https://github.com/apache/kafka/pull/8864#pullrequestreview-452776511",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "43938fa8-4ab7-4567-a136-77bb8817e1a3",
        "parentId" : null,
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "Thanks for adding the comment!",
        "createdAt" : "2020-07-06T23:47:37Z",
        "updatedAt" : "2020-07-21T00:12:06Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      },
      {
        "id" : "0be98714-d7f4-4d63-b1f3-f957a2999131",
        "parentId" : "43938fa8-4ab7-4567-a136-77bb8817e1a3",
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "Yes :) Added it as a reminder only first. Was expecting to get review comment anyway.",
        "createdAt" : "2020-07-07T19:54:24Z",
        "updatedAt" : "2020-07-21T00:12:06Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "9dac7437-b726-40e1-889f-926d7c1b6aa8",
        "parentId" : "43938fa8-4ab7-4567-a136-77bb8817e1a3",
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "Addressed via #9047",
        "createdAt" : "2020-07-21T19:46:36Z",
        "updatedAt" : "2020-07-21T19:46:36Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      }
    ],
    "commit" : "e6c10d88f9c6fa9d89cc500112255898e2f24845",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +76,80 @@    private final List<StateStore> globalStateStores;\n\n    @SuppressWarnings(\"deprecation\") // TODO: remove in follow up PR when `RETRIES` is removed\n    public GlobalStateManagerImpl(final LogContext logContext,\n                                  final ProcessorTopology topology,"
  },
  {
    "id" : "9009a289-1a02-4249-a870-e49605f9572a",
    "prId" : 8902,
    "prUrl" : "https://github.com/apache/kafka/pull/8902#pullrequestreview-445547727",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1f49f99b-b89c-4097-a3cc-0e74e6b7d0dd",
        "parentId" : null,
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "Wondering if we should pass `storeToChangelogTopic()` and `.globalStateStores()` into the constructor instead of `ProcessorTopology` ?",
        "createdAt" : "2020-07-09T01:00:51Z",
        "updatedAt" : "2020-07-09T12:00:58Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "fef3b4b9-f4eb-4a27-b348-6118aefc88c5",
        "parentId" : "1f49f99b-b89c-4097-a3cc-0e74e6b7d0dd",
        "authorId" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "body" : "I would still pass `ProcessorTopology` into the constructor because it might make the signature of the constructor more stable. I removed the field for the topology and now we store only `globalStateStores` and `storeChangelogTopics` in `GlobalStateManagerImpl`.",
        "createdAt" : "2020-07-09T12:00:09Z",
        "updatedAt" : "2020-07-09T12:00:58Z",
        "lastEditedBy" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "tags" : [
        ]
      }
    ],
    "commit" : "bfacb69b8895b4c72874942d37faa9a36ca357e9",
    "line" : 21,
    "diffHunk" : "@@ -1,1 +82,86 @@                                  final StateRestoreListener stateRestoreListener,\n                                  final StreamsConfig config) {\n        storeToChangelogTopic = topology.storeToChangelogTopic();\n        globalStateStores = topology.globalStateStores();\n        baseDir = stateDirectory.globalStateDir();"
  },
  {
    "id" : "d1593d18-4cf9-4849-8969-22c3d66ed9eb",
    "prId" : 9047,
    "prUrl" : "https://github.com/apache/kafka/pull/9047#pullrequestreview-454680852",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8aa77034-5b35-4ef9-a5c4-c38b387fc773",
        "parentId" : null,
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "Some side improvement: if we `seek` base on the checkpoint, there is no reason to call `position()` because we know what our offset is. -- Only if we `seekToBeginning()` we need to get the current offset from the consumer itself (instead of `position()` we could also call `beginningOffsets` but `position` it the easer to use API.",
        "createdAt" : "2020-07-24T07:25:18Z",
        "updatedAt" : "2020-08-04T02:12:59Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      }
    ],
    "commit" : "cf6ee1e774a3a635cb8ac9c134ff3269edaa7357",
    "line" : 195,
    "diffHunk" : "@@ -1,1 +257,261 @@            if (checkpoint != null) {\n                globalConsumer.seek(topicPartition, checkpoint);\n                offset = checkpoint;\n            } else {\n                globalConsumer.seekToBeginning(Collections.singletonList(topicPartition));"
  },
  {
    "id" : "7dc42559-5523-4f2e-8bb3-6cf037a1a3f2",
    "prId" : 9047,
    "prUrl" : "https://github.com/apache/kafka/pull/9047#pullrequestreview-460448270",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "02d4dc40-ff09-4545-b3a7-321bc8e3effb",
        "parentId" : null,
        "authorId" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "body" : "Could we just throw here?",
        "createdAt" : "2020-07-29T05:28:49Z",
        "updatedAt" : "2020-08-04T02:13:00Z",
        "lastEditedBy" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "tags" : [
        ]
      },
      {
        "id" : "7b6f4e1f-28c9-4636-a60c-b32cf3a4e4d9",
        "parentId" : "02d4dc40-ff09-4545-b3a7-321bc8e3effb",
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "We could, but this implies redundant code to \"assemble\" the error message, and I prefer to reuse the existing code for it.",
        "createdAt" : "2020-08-04T02:07:10Z",
        "updatedAt" : "2020-08-04T02:13:00Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      }
    ],
    "commit" : "cf6ee1e774a3a635cb8ac9c134ff3269edaa7357",
    "line" : 244,
    "diffHunk" : "@@ -1,1 +303,307 @@                if (records.isEmpty()) {\n                    // this will always throw\n                    maybeUpdateDeadlineOrThrow(time.milliseconds());\n                }\n"
  },
  {
    "id" : "e487ae98-b492-4cd8-b6bd-20c9ce5c8a31",
    "prId" : 9361,
    "prUrl" : "https://github.com/apache/kafka/pull/9361#pullrequestreview-500554881",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "24a90c89-9380-4871-9349-035c4e2d0c7b",
        "parentId" : null,
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "These are scattered throughout this PR. It's just selecting the init method we want to invoke. It's only necessary because the `globalProcessorContext` here actually implements both `ProcessorContext` and `StateStoreContext`. This is only true of our internal contexts, so users will not face a similar need to change code.",
        "createdAt" : "2020-10-01T17:33:00Z",
        "updatedAt" : "2020-10-02T15:50:27Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      }
    ],
    "commit" : "a8de75f6f16cf8bdcccbcb1bc1fc0a11dd40c1d1",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +149,153 @@            final String sourceTopic = storeToChangelogTopic.get(stateStore.name());\n            changelogTopics.add(sourceTopic);\n            stateStore.init((StateStoreContext) globalProcessorContext, stateStore);\n        }\n"
  },
  {
    "id" : "d7583390-ff45-4329-b19c-307f8f6e3a9c",
    "prId" : 10568,
    "prUrl" : "https://github.com/apache/kafka/pull/10568#pullrequestreview-651752338",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2554ca0b-316c-4b06-9764-6f138003c1a8",
        "parentId" : null,
        "authorId" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "body" : "We have two data structures that contain state stores but we check only one when we close the state stores. In the error case it can happen that one contains an open store that the other data structure does not contain. This is a quick fix for it, but we should consider whether it is possible to consolidate these two data structures.  ",
        "createdAt" : "2021-05-04T19:03:35Z",
        "updatedAt" : "2021-05-06T10:43:27Z",
        "lastEditedBy" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "tags" : [
        ]
      },
      {
        "id" : "18106fcc-3c75-4869-bd71-2cfaefeb4f7b",
        "parentId" : "2554ca0b-316c-4b06-9764-6f138003c1a8",
        "authorId" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "body" : "Yikes, so it actually was a (possible) leak in production code? I'm almost glad rocksdb had a bug, otherwise we might have never caught it ðŸ˜… \r\n\r\nDefinite +1 on consolidating these, can you file a quick ticket for this? It almost sounds like a bug in itself that one might contain stores that the other does not, but I suppose as long as they all get closed it's probably ok. \r\n\r\nI'd bet you could find a community member to pick it up by labeling as `newbie` or `newbie++`",
        "createdAt" : "2021-05-04T19:31:13Z",
        "updatedAt" : "2021-05-06T10:43:27Z",
        "lastEditedBy" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "tags" : [
        ]
      },
      {
        "id" : "752bc58d-c99c-4c84-8a19-9c0ca5f2057f",
        "parentId" : "2554ca0b-316c-4b06-9764-6f138003c1a8",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "Surprised to see we actually have two as well. Did a quick look at them, and I think they can be consolidated indeed. Some more details:\r\n\r\n1) The `mgr.initialize` would try to register all stores within `globalStateStores`, which would put them into the other `globalStores` map one by one via the `registerStateStore` call. So after the `initialize` call, the two stores should contain the same piece of metadata.\r\n\r\n2) But note that, before `initialize` call, no stores should be opened yet. So if a failure happens before that call, then all stores should be in `closed` form, and this logic would never be triggered.\r\n\r\n3) Within `initialize` we call `restoreState`, and only after that we would add the stores to the `globalStores` here. So if a failure happens during `restoreState`, the `globalStores` would not contain it while we have to rely on `globalStateStores`.\r\n\r\nBased on that, I can file a quick follow-up fix after your PR to consolidate these two.",
        "createdAt" : "2021-05-04T22:55:54Z",
        "updatedAt" : "2021-05-06T10:43:27Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "88d0bc09-4ebb-4837-a75d-8e4939dd69ed",
        "parentId" : "2554ca0b-316c-4b06-9764-6f138003c1a8",
        "authorId" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "body" : "Looking through the code in this class,  this feels a bit weird. Seems like the only way we could have (open) stores in `globalStateStores` but not in `globalStores` is when we hit an exception while trying to close the store in `globalStores`. I'm all for retrying in theory (though I'm willing to bet 99% of the time it's either permanent/fatal) but if that's what we intend to do, we should just retry it right after we hit that exception so it's clear what we're doing. Looping through this other structure like this feels very odd, as it implies these are distinct sets of StateStores instead of two data structures which should reflect the same set of underlying StateStores",
        "createdAt" : "2021-05-04T23:23:47Z",
        "updatedAt" : "2021-05-06T10:43:27Z",
        "lastEditedBy" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "tags" : [
        ]
      },
      {
        "id" : "8ceb9488-1a46-441e-87e2-0b1eff0271c1",
        "parentId" : "2554ca0b-316c-4b06-9764-6f138003c1a8",
        "authorId" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "body" : "Heh, @guozhangwang and I reviewed at the same time. I didn't notice that `globalStores` would not be populated until restoration, whereas `globalStateStores` is populated in the constructor. Imo we should just populate `globalStores` in the constructor as well, but I guess that won't be necessary if @guozhangwang does a quick followup to consolidate them",
        "createdAt" : "2021-05-04T23:37:40Z",
        "updatedAt" : "2021-05-06T10:43:27Z",
        "lastEditedBy" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "tags" : [
        ]
      }
    ],
    "commit" : "9e258ebfbaa270e178fe8a39f107a36e0738008b",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +397,401 @@            }\n        }\n        for (final StateStore store : globalStateStores) {\n            if (store.isOpen()) {\n                try {"
  },
  {
    "id" : "e82dd0db-3f00-4a38-a46f-64134958f822",
    "prId" : 10568,
    "prUrl" : "https://github.com/apache/kafka/pull/10568#pullrequestreview-651584022",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ee442e43-956a-4c32-a940-047d62af48c2",
        "parentId" : null,
        "authorId" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "body" : "What even is the difference between `globalStateStores` and `globalStores`? I'm not surprised we had a leak, I'm pretty sure if I was looking at this code I wouldn't remember that these were actually two different variables. Maybe we can give them slightly more descriptive names in the meantime?",
        "createdAt" : "2021-05-04T23:18:57Z",
        "updatedAt" : "2021-05-06T10:43:27Z",
        "lastEditedBy" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "tags" : [
        ]
      }
    ],
    "commit" : "9e258ebfbaa270e178fe8a39f107a36e0738008b",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +375,379 @@    @Override\n    public void close() {\n        if (globalStateStores.isEmpty() && globalStores.isEmpty()) {\n            return;\n        }"
  },
  {
    "id" : "8324937e-b86b-44ad-b71d-1c5185975187",
    "prId" : 10646,
    "prUrl" : "https://github.com/apache/kafka/pull/10646#pullrequestreview-662910094",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "efcf5ae1-2d72-4430-b17d-c4c9d94230a7",
        "parentId" : null,
        "authorId" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "body" : "Not really related to this line. Could you verify that the state store is closed in the unit test that tests line 148? The name of the test is `shouldThrowStreamsExceptionForOldTopicPartitions()`.",
        "createdAt" : "2021-05-11T08:41:26Z",
        "updatedAt" : "2021-05-11T08:50:44Z",
        "lastEditedBy" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "tags" : [
        ]
      },
      {
        "id" : "604d9ff8-bb7a-40d3-bcfc-607ae779a309",
        "parentId" : "efcf5ae1-2d72-4430-b17d-c4c9d94230a7",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "Actually I just observed that in this case, the mock context does not actually use the `stateManager` at all, but created its own `StateManagerStub`, and hence would not call `stateManager.registerStore`, therefore the stores set would always be empty.. I think this is okay since in unit test we are only checking each single function's behavior (in this case, `initialize`) anyways.\r\n\r\nAlso as I browse through the code (see other comment below), in this unit test when the exception is thrown the store would not be closed yet, and in practice we would rely on the `thread.shutdown` itself to shutdown the global state manager, and hence close all state stores.",
        "createdAt" : "2021-05-17T02:11:33Z",
        "updatedAt" : "2021-05-17T03:31:12Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "abc28ab3-fa4b-4d8c-bf29-c75469ee81ab",
        "parentId" : "efcf5ae1-2d72-4430-b17d-c4c9d94230a7",
        "authorId" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "body" : "If I put \r\n```\r\n        assertThat(store1.isOpen(), is(false));\r\n        assertThat(store2.isOpen(), is(false));\r\n        assertThat(store3.isOpen(), is(false));\r\n        assertThat(store4.isOpen(), is(false));\r\n```\r\non line 202 in `shouldThrowStreamsExceptionForOldTopicPartitions()` the test fails. Hence, we leak a state store.",
        "createdAt" : "2021-05-17T13:30:09Z",
        "updatedAt" : "2021-05-17T13:30:55Z",
        "lastEditedBy" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "tags" : [
        ]
      },
      {
        "id" : "4cf7ceb6-9d7d-409e-9498-281e157f1717",
        "parentId" : "efcf5ae1-2d72-4430-b17d-c4c9d94230a7",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "Yes, but the reason is that, in the unit test we do not really follow the trace of `stateMgr.initialize() -> store.init() -> context.registerStore() -> stateMgr.registerStore()`. That's because the `context` is a mock, which does not use the `stateMgr` at all, and hence the `stores` set is always empty.\r\n\r\nIf we do want to test this call trace, then we need to make the mock context to get the actual stateMgr.",
        "createdAt" : "2021-05-17T20:36:11Z",
        "updatedAt" : "2021-05-17T20:36:11Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "27750b7f-651d-4f43-8a4f-033cf8023ba4",
        "parentId" : "efcf5ae1-2d72-4430-b17d-c4c9d94230a7",
        "authorId" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "body" : "Now, I see what you mean. However, I am not sure it is a good idea to rely on the code in `GlobalStreamThread` that catches the fatal exception to clean up state stores (and all the rest). If we know, we throw a fatal exception, then we should clean up immediately before we throw. That makes the `GlobalStateManagerImpl` less error-prone, because it does not need to rely on a different class for its clean up , IMO. ",
        "createdAt" : "2021-05-19T08:29:26Z",
        "updatedAt" : "2021-05-19T08:29:26Z",
        "lastEditedBy" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "tags" : [
        ]
      }
    ],
    "commit" : "85d28192174125f7c8c641eeb22d4015711473a7",
    "line" : 67,
    "diffHunk" : "@@ -1,1 +130,134 @@\n        final Set<String> changelogTopics = new HashSet<>();\n        for (final StateStore stateStore : topology.globalStateStores()) {\n            final String sourceTopic = storeToChangelogTopic.get(stateStore.name());\n            changelogTopics.add(sourceTopic);"
  },
  {
    "id" : "ac50fdbc-696f-493e-b00c-50bce6c358cc",
    "prId" : 10646,
    "prUrl" : "https://github.com/apache/kafka/pull/10646#pullrequestreview-661407385",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7676f5d0-e129-4cc1-b0be-a7e1f6d47678",
        "parentId" : null,
        "authorId" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "body" : "There are a a `IllegalStateException` and a couple of `IllegalArgumentException`s on the path from opening the state store within `stateStore.init()` to line 182 in `this.registerStore()`. We do not close the state stores before we throw. I do not think this is relevant for production code, but we could leak state stores in unit tests if we do not explicitly close the state stores in the unit tests.  ",
        "createdAt" : "2021-05-11T08:48:23Z",
        "updatedAt" : "2021-05-11T08:50:44Z",
        "lastEditedBy" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "tags" : [
        ]
      },
      {
        "id" : "0023b608-17fb-490b-87d8-2cd6b879a71a",
        "parentId" : "7676f5d0-e129-4cc1-b0be-a7e1f6d47678",
        "authorId" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "body" : "On a second thought, it might also be relevant for production code since we now can restart the stream thread after a fatal error. This is not yet possible for a global stream thread, but it might be possible in future.",
        "createdAt" : "2021-05-14T08:29:37Z",
        "updatedAt" : "2021-05-14T08:29:37Z",
        "lastEditedBy" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "tags" : [
        ]
      },
      {
        "id" : "5b7e3e62-9af2-42dc-bc97-be789436b4c6",
        "parentId" : "7676f5d0-e129-4cc1-b0be-a7e1f6d47678",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "Hmm, for production, do we ever restart a thread even for illegal-state or illegal-argument?\r\n\r\nAnyways, I think your concern is still valid, that at least for testing code, there's a risk. Since `store.init()` call is implemented at the state store impl customization, we cannot really enforce closing there. And today, for both global state and local state manager, we would throw the exception from `initialize state stores` all the way up to the `thread.run` and to user's exceptional handler. Though we call `thread.shutdown` eventually we would close all tasks anyways, but in the case you raised, the state store would not be in `stateManager.stores` set yet and hence would be leaked.\r\n\r\nWhat we can do is, e.g. in both local and global state manager, moving the `globalStores.put` / `stores.put` call at the beginning, before making any checks, so that when we throw and eventually `thread.shutdown`, the stores would already be in the set and would be closed.",
        "createdAt" : "2021-05-17T02:57:41Z",
        "updatedAt" : "2021-05-17T03:31:12Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "7f1d4acc-bf32-4486-84a9-3f4051099ca8",
        "parentId" : "7676f5d0-e129-4cc1-b0be-a7e1f6d47678",
        "authorId" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "body" : "> Hmm, for production, do we ever restart a thread even for illegal-state or illegal-argument?\r\n\r\nIf the user decides to restart a stream thread in its exception handler it is possible.",
        "createdAt" : "2021-05-17T13:14:11Z",
        "updatedAt" : "2021-05-17T13:30:55Z",
        "lastEditedBy" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "tags" : [
        ]
      },
      {
        "id" : "43409e76-f048-4d6f-b331-dc5fae6bbc9c",
        "parentId" : "7676f5d0-e129-4cc1-b0be-a7e1f6d47678",
        "authorId" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "body" : "Yeah, our attitude towards IllegalStateException has been pretty cavalier thus far, and it's one of the main things I'm concerned about with the REPLACE thread functionality. We should definitely be on the lookout for possible IllegalStateException occurrences in the codebase and try to triage them so things aren't just completely screwed up if Streams is allowed to continue after hitting one",
        "createdAt" : "2021-05-17T20:40:55Z",
        "updatedAt" : "2021-05-17T20:40:55Z",
        "lastEditedBy" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "tags" : [
        ]
      }
    ],
    "commit" : "85d28192174125f7c8c641eeb22d4015711473a7",
    "line" : 70,
    "diffHunk" : "@@ -1,1 +133,137 @@            final String sourceTopic = storeToChangelogTopic.get(stateStore.name());\n            changelogTopics.add(sourceTopic);\n            stateStore.init((StateStoreContext) globalProcessorContext, stateStore);\n        }\n"
  },
  {
    "id" : "117d5e3e-0c6d-451c-a0ef-e64a6bbc16ff",
    "prId" : 10646,
    "prUrl" : "https://github.com/apache/kafka/pull/10646#pullrequestreview-662560454",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d389ea39-5328-422f-9e67-81d44e62dfab",
        "parentId" : null,
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "I add the store after the store names check, since if there's already a state store created, then we would not be able to book-keep both of them anyways.",
        "createdAt" : "2021-05-17T03:30:51Z",
        "updatedAt" : "2021-05-17T03:31:12Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "6af6c43d-2ff0-4328-8238-dc7782a17567",
        "parentId" : "d389ea39-5328-422f-9e67-81d44e62dfab",
        "authorId" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "body" : "I agree that we would not be able to book-keep both, but the state store in `store` that we just opened is still open in line 172. So we need to close the state store in `store` before throwing the exception otherwise we will leak it. The same applies to line 176.",
        "createdAt" : "2021-05-17T13:09:16Z",
        "updatedAt" : "2021-05-17T13:30:55Z",
        "lastEditedBy" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "tags" : [
        ]
      },
      {
        "id" : "bb560b09-2d51-4766-a082-12632ab873e9",
        "parentId" : "d389ea39-5328-422f-9e67-81d44e62dfab",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "Okay, I think I got what we were discussing now. Originally I'm thinking that since these conditions should never happen --- because in the topology when we `add state stores` we already check if the store names have existed or not, and hence we should never add two stores with the same name --- if it ever happens we would always treat it as fatal and crash stop immediately.\r\n\r\nOn the higher level, I think we should NOT allow users to handle illegal-s/a themselves and hence ever possibly to treat them not as fatal, but obviously today we do not enforce that.\r\n\r\nSo I think we can have two options here: 1) in the lower level hierarchy like state manager here, try to stop the stores when hitting an illegal-s/a; 2) on the higher level hierarchy as in stream thread, we enforce \"stop app\" on illegal-s/a. I'm a bit leaning towards 2) here but would love to hear other opinions.",
        "createdAt" : "2021-05-17T20:46:43Z",
        "updatedAt" : "2021-05-17T20:46:44Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "0e93dc3c-f140-48ea-ac42-7d5178bd4447",
        "parentId" : "d389ea39-5328-422f-9e67-81d44e62dfab",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "cc @ableegoldman @wcarlson5 @rodesai too.",
        "createdAt" : "2021-05-17T20:47:17Z",
        "updatedAt" : "2021-05-17T20:47:17Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "328f027d-b19c-483a-b6a4-c309f2515d0c",
        "parentId" : "d389ea39-5328-422f-9e67-81d44e62dfab",
        "authorId" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "body" : "+1 on disallowing the app to continue after an illegal exception. We need to reserve _some_ kind of exception for actual critical, fatal system errors that a user can't just ignore to spin up a new thread. And that has essentially been the meaning of these illegal exceptions in Streams thus far. As I mentioned in another thread, I've been very concerned about this in the new handler since we haven't been strict in properly cleaning up after an illegal exception",
        "createdAt" : "2021-05-17T21:02:08Z",
        "updatedAt" : "2021-05-17T21:02:08Z",
        "lastEditedBy" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "tags" : [
        ]
      },
      {
        "id" : "671ce466-c719-460e-a889-58c79c67d81d",
        "parentId" : "d389ea39-5328-422f-9e67-81d44e62dfab",
        "authorId" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "body" : "+1 on stopping the app after a deterministic illegal * exception. I am not sure if all illegal * exception we throw are deterministic, though. I guess most of them are. For now, we could just shutdown the app for all illegal * exception and then consider to use a different exception if we discover that a illegal * exception is transient.",
        "createdAt" : "2021-05-18T07:19:16Z",
        "updatedAt" : "2021-05-18T07:19:16Z",
        "lastEditedBy" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "tags" : [
        ]
      },
      {
        "id" : "9f3ef58b-25d4-4da3-9bfe-b9e64191cc48",
        "parentId" : "d389ea39-5328-422f-9e67-81d44e62dfab",
        "authorId" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "body" : "I definitely think we need to triage and maybe clean up the existing Illegal-type exceptions today. Some may not be deterministic, but we still just drop everything and shut down without any further attempts at cleaning up. In those cases it's probably down to the specific situation whether it's appropriate to continue doing so and disallow recovery from this, or just fix the handling so it does clean all resources",
        "createdAt" : "2021-05-18T20:48:02Z",
        "updatedAt" : "2021-05-18T20:48:03Z",
        "lastEditedBy" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "tags" : [
        ]
      }
    ],
    "commit" : "85d28192174125f7c8c641eeb22d4015711473a7",
    "line" : 89,
    "diffHunk" : "@@ -1,1 +181,185 @@        }\n\n        // register the store first, so that if later an exception is thrown then eventually while we call `close`\n        // on the state manager this state store would be closed as well\n        globalStores.put(store.name(), Optional.of(store));"
  }
]
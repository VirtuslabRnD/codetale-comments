[
  {
    "id" : "60d69fe8-d561-413e-bc95-02c8999a3934",
    "prId" : 5740,
    "prUrl" : "https://github.com/apache/kafka/pull/5740#pullrequestreview-161728682",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "989ab345-2bf2-430a-804a-84fc69ab0a45",
        "parentId" : null,
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "Having a separate method for `getStatefulProcessorNode` was unnecessary, so I've just inlined it to call the constructor directly instead. Perhaps that method did extra work in the past.",
        "createdAt" : "2018-10-04T17:36:24Z",
        "updatedAt" : "2018-10-05T14:21:44Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      }
    ],
    "commit" : "7e22de672c264ede614fa46d33bf55a4b80c7fca",
    "line" : 12,
    "diffHunk" : "@@ -1,1 +85,89 @@            new KeyValueStoreMaterializer<>(materialized).materialize(),\n            false\n        );\n\n        // now the repartition node must be the parent of the StateProcessorNode"
  },
  {
    "id" : "23afa9eb-0c32-4b6f-90e3-c5616efc4120",
    "prId" : 5741,
    "prUrl" : "https://github.com/apache/kafka/pull/5741#pullrequestreview-161735640",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "57f4c216-3f1e-477a-8bc2-1c9ef9732856",
        "parentId" : null,
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "This is an internal class, and the field is never referenced outside of this class. I think it can be private.",
        "createdAt" : "2018-10-04T17:53:30Z",
        "updatedAt" : "2018-10-04T21:38:59Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      }
    ],
    "commit" : "79ded18384601459c38b700fc2d157e1f92704af",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +48,52 @@    private static final String REDUCE_NAME = \"KTABLE-REDUCE-\";\n\n    private final String userSpecifiedName;\n\n    private final Initializer<Long> countInitializer = () -> 0L;"
  },
  {
    "id" : "1281bfea-4867-483e-831f-b8182c6f6c7e",
    "prId" : 5741,
    "prUrl" : "https://github.com/apache/kafka/pull/5741#pullrequestreview-161735640",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1d47decf-7285-4855-9a67-fcd40be06205",
        "parentId" : null,
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "This chunk is just adding the missing type and reformatting.",
        "createdAt" : "2018-10-04T17:53:59Z",
        "updatedAt" : "2018-10-04T21:38:59Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      }
    ],
    "commit" : "79ded18384601459c38b700fc2d157e1f92704af",
    "line" : 38,
    "diffHunk" : "@@ -1,1 +110,114 @@            .withProcessorParameters(aggregateFunctionProcessorParams)\n            .withStoreBuilder(new KeyValueStoreMaterializer<>(materialized).materialize())\n            .build();\n    }\n"
  },
  {
    "id" : "55c915c2-b8f3-4eef-8253-e6d678f4b6f8",
    "prId" : 5741,
    "prUrl" : "https://github.com/apache/kafka/pull/5741#pullrequestreview-161735640",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "301f45c2-d8cd-4e62-9545-b007a7db3386",
        "parentId" : null,
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "reformatting",
        "createdAt" : "2018-10-04T17:54:07Z",
        "updatedAt" : "2018-10-04T21:38:59Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      }
    ],
    "commit" : "79ded18384601459c38b700fc2d157e1f92704af",
    "line" : 51,
    "diffHunk" : "@@ -1,1 +169,173 @@                                                                                        countInitializer,\n                                                                                        countAdder,\n                                                                                        countSubtractor);\n\n        return doAggregate(aggregateSupplier, AGGREGATE_NAME, materializedInternal);"
  },
  {
    "id" : "6d3a457a-4f28-493d-989a-887a0617cdee",
    "prId" : 6265,
    "prUrl" : "https://github.com/apache/kafka/pull/6265#pullrequestreview-203453614",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "31946a6f-eb40-4463-82a3-7472a641d2f5",
        "parentId" : null,
        "authorId" : "4c968502-bb3d-46ee-8719-0c0bdbc6242f",
        "body" : "On the first invocation, the `repartitionNode` is always null, so we'll build the repartition node and set the variable. But on subsequent calls, only if the user has provided a name for the repartition topic will we re-use the repartition graph node.\r\n\r\nThis maintains compatibility as users not naming the repartition topic will get the same topology and re-using the `KGroupedTable` results in an `InvalidToplogyException` when building the topology",
        "createdAt" : "2019-02-13T21:25:21Z",
        "updatedAt" : "2019-02-15T21:40:03Z",
        "lastEditedBy" : "4c968502-bb3d-46ee-8719-0c0bdbc6242f",
        "tags" : [
        ]
      }
    ],
    "commit" : "8271bb21f388cef4cb46d384d9bfef8491b63a19",
    "line" : 38,
    "diffHunk" : "@@ -1,1 +78,82 @@            + KStreamImpl.REPARTITION_TOPIC_SUFFIX;\n\n        if (repartitionGraphNode == null || userProvidedRepartitionTopicName == null) {\n            repartitionGraphNode = createRepartitionNode(sinkName, sourceName, repartitionTopic);\n        }"
  }
]
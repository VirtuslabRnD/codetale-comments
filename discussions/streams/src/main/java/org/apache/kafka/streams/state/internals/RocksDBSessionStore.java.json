[
  {
    "id" : "6ad8fd38-a449-4ce4-b955-bebe6c3bf44c",
    "prId" : 6134,
    "prUrl" : "https://github.com/apache/kafka/pull/6134#pullrequestreview-192350264",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "398d7d31-b098-41e7-bd6b-afcbd1d1600c",
        "parentId" : null,
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "This is the fix for 1).",
        "createdAt" : "2019-01-12T00:38:54Z",
        "updatedAt" : "2019-01-18T20:03:25Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "cd21e4fd-f643-419e-99b3-b294b0ab2662",
        "parentId" : "398d7d31-b098-41e7-bd6b-afcbd1d1600c",
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "Maybe saving someone else from having to dig down and figure out why it's different...\r\n\r\nBecause of the way the keys are formatted, when we know we're looking for this exact key, we can search essentially from the key `[my-key , start time]` through `[my-key , end time]`, whereas the other method we were delegating to has  to scan from `[start-key]` to `[end-key]`, which (because of the way the keys are structured) can't also bound the start and end time, but has to iterate over all the rocks keys and filter out the ones that fall outside the desired time bound.\r\n\r\nTherefore, this change can significantly tighten the range that actually gets scanned in Rocks.",
        "createdAt" : "2019-01-14T20:35:37Z",
        "updatedAt" : "2019-01-18T20:03:25Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      }
    ],
    "commit" : "42006bdeb3e5a33c41f7e9e583ad72efb4b086e8",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +62,66 @@    @Override\n    public KeyValueIterator<Windowed<K>, AGG> findSessions(final K key, final long earliestSessionEndTime, final long latestSessionStartTime) {\n        final KeyValueIterator<Bytes, byte[]> bytesIterator = bytesStore.fetch(\n            Bytes.wrap(serdes.rawKey(key)),\n            earliestSessionEndTime,"
  },
  {
    "id" : "fa457be6-838a-4267-bcfa-1cdd930c65a8",
    "prId" : 6255,
    "prUrl" : "https://github.com/apache/kafka/pull/6255#pullrequestreview-202970954",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "75632566-dd51-4663-88bc-b88e7a713ed7",
        "parentId" : null,
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "Why not `wrappedStore().name()` of ofter getting access to the variable, just `wrapped.name()` ? ",
        "createdAt" : "2019-02-12T19:34:23Z",
        "updatedAt" : "2019-02-13T14:39:33Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "a42d4370-237f-42f9-bc5f-d9e474cb9a0d",
        "parentId" : "75632566-dd51-4663-88bc-b88e7a713ed7",
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "`name()` is provided by the super class, since it is a `StateStore` method. I'd consider `super.name()`, but it seemed better to elide the unnecessary `super.` the same way we do for `this.`.\r\n\r\nAs with the prior discussion about `super.init()`, it would be wrong to circumvent the superclass's method and make assumptions about its implementation.",
        "createdAt" : "2019-02-12T23:58:50Z",
        "updatedAt" : "2019-02-13T14:39:33Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      }
    ],
    "commit" : "1e871f2a26bed0701a074e91e41c4e47f48f6b9e",
    "line" : 25,
    "diffHunk" : "@@ -1,1 +47,51 @@    @SuppressWarnings(\"unchecked\")\n    public void init(final ProcessorContext context, final StateStore root) {\n        final String storeName = name();\n        topic = ProcessorStateManager.storeChangelogTopic(context.applicationId(), storeName);\n"
  }
]
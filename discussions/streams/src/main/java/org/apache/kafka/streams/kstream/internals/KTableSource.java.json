[
  {
    "id" : "d5b44c82-7d74-496b-9e6a-1bf15c7f21a3",
    "prId" : 5779,
    "prUrl" : "https://github.com/apache/kafka/pull/5779#pullrequestreview-182492069",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4fde7798-dc31-4b64-8f20-4c203bcbdab1",
        "parentId" : null,
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "This is the key change.",
        "createdAt" : "2018-10-11T02:08:30Z",
        "updatedAt" : "2018-12-09T06:42:30Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "8364f0fa-3639-42f5-9980-f20bd90e49a4",
        "parentId" : "4fde7798-dc31-4b64-8f20-4c203bcbdab1",
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "nit: remove `this`",
        "createdAt" : "2018-12-06T23:29:22Z",
        "updatedAt" : "2018-12-09T06:42:30Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      }
    ],
    "commit" : "7d02ad5bab3f2cf4ae2c11457e8dfe099d3a4b12",
    "line" : 37,
    "diffHunk" : "@@ -1,1 +55,59 @@    // need to set the queryable name as the store name to enforce materialization\n    public void enableSendingOldValues() {\n        this.sendOldValues = true;\n        this.queryableName = storeName;\n    }"
  },
  {
    "id" : "13439fae-d38b-410f-ae97-b25ee4f4097f",
    "prId" : 5779,
    "prUrl" : "https://github.com/apache/kafka/pull/5779#pullrequestreview-182492069",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9940b3ec-30b9-4399-874b-6c9fb2ac7bda",
        "parentId" : null,
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "nit: remove `this`",
        "createdAt" : "2018-12-06T23:29:44Z",
        "updatedAt" : "2018-12-09T06:42:30Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      }
    ],
    "commit" : "7d02ad5bab3f2cf4ae2c11457e8dfe099d3a4b12",
    "line" : 44,
    "diffHunk" : "@@ -1,1 +62,66 @@    // need to set the queryable name as the store name to enforce materialization\n    public void materialize() {\n        this.queryableName = storeName;\n    }\n"
  },
  {
    "id" : "9e5a351f-d433-456f-8b02-a1db8fa77eab",
    "prId" : 5779,
    "prUrl" : "https://github.com/apache/kafka/pull/5779#pullrequestreview-182832977",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a8f3038a-59b6-4db2-a3ca-6649b712e204",
        "parentId" : null,
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "It seems there are two cases here: \r\n(1) the table is queryable, for this case `storeName == queryableName`\r\n(2) the table is not queryable, for this case `queryableName == null`\r\n\r\nThus, it seems cleaner at this level, to keep `storeName` and `isQueryable` flag to avoid potential bugs that `storeName != queryableName` ?\r\n\r\nAt outer layers, we can still do it differently. Thoughts?",
        "createdAt" : "2018-12-06T23:32:09Z",
        "updatedAt" : "2018-12-09T06:42:30Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "4bb906ec-31ce-4bcf-9c49-4138a4cbb312",
        "parentId" : "a8f3038a-59b6-4db2-a3ca-6649b712e204",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "I personally like the distinguishment of queryableName and storeName for both this class and MaterializedInternal :) Let me try to see if I can persuade you:\r\n\r\n1. storeName is the name for underlying store no matter if the store does exist or not (i.e. it may not be materialized), as long as the store is materialized the storeName would never be null.\r\n\r\n2. queryableName is the name to query the store, it is set once and done. Logically it represents the logic of `isQueryable ? return storeName : return null` in a single place (otherwise there are a bunch of those places where this logic are needed and hence more error prone).\r\n\r\nFor KTableSource as an example, by the time we create this node we cannot tell yet whether we will materialize it at the end (e.g. if the downstream operators require this ancestor to send old values or materialize, we will then do it). So we need to generate the storeName as always but keep the queryableName as null.\r\n\r\nI think the concern that `queryableName != storeName` is valid, for which case I would like to put `generateStoreNameIfNeeded` as part of the MaterializedInternal constructor, and hope that would cleanup a little bit.",
        "createdAt" : "2018-12-07T01:54:38Z",
        "updatedAt" : "2018-12-09T06:42:30Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "b3f8a3ac-b7a3-43d5-bd14-c437479b7d07",
        "parentId" : "a8f3038a-59b6-4db2-a3ca-6649b712e204",
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "Ack.",
        "createdAt" : "2018-12-07T19:11:36Z",
        "updatedAt" : "2018-12-09T06:42:30Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      }
    ],
    "commit" : "7d02ad5bab3f2cf4ae2c11457e8dfe099d3a4b12",
    "line" : 15,
    "diffHunk" : "@@ -1,1 +35,39 @@    private boolean sendOldValues;\n\n    public KTableSource(final String storeName, final String queryableName) {\n        Objects.requireNonNull(storeName, \"storeName can't be null\");\n"
  },
  {
    "id" : "113aa45f-e5c4-4f0b-9bf9-8f7048c7fcf4",
    "prId" : 6725,
    "prUrl" : "https://github.com/apache/kafka/pull/6725#pullrequestreview-239206647",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0bc22c05-68d4-4450-818b-cb805a82e22a",
        "parentId" : null,
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "I know I suggested this, but just clarifying: in the task's record queue, we already detect lateness like this and also record in the `record-lateness` metric already, so here we just log it for KTable source specifically in addition to the general metrics.",
        "createdAt" : "2019-05-17T23:20:53Z",
        "updatedAt" : "2019-05-17T23:21:26Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "30d091f3-822a-486a-bae6-3c2f96d2c6d9",
        "parentId" : "0bc22c05-68d4-4450-818b-cb805a82e22a",
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "Well. We record `record-lateness` in `PartitionGroup`. Here we don't record any metric but only issue a WARN log. In general, out-of-order data are ok, but for this case it's a correctness concern, and hence the warning.\r\n\r\nI would actually like to take this one step further (in a follow up KIP), to allow people to opt-in and drop those records.",
        "createdAt" : "2019-05-18T17:38:58Z",
        "updatedAt" : "2019-05-18T17:38:58Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      }
    ],
    "commit" : "83c943c3a45322e9a5b5d05557227dbb86fcbc2f",
    "line" : 20,
    "diffHunk" : "@@ -1,1 +105,109 @@                    oldValue = oldValueAndTimestamp.value();\n                    if (context().timestamp() < oldValueAndTimestamp.timestamp()) {\n                        LOG.warn(\"Detected out-of-order KTable update for {} at offset {}, partition {}.\",\n                            store.name(), context().offset(), context().partition());\n                    }"
  }
]
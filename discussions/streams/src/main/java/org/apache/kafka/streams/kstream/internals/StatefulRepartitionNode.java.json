[
  {
    "id" : "0e257cb7-0da3-4c91-aaf2-24fc9caf6e17",
    "prId" : 4923,
    "prUrl" : "https://github.com/apache/kafka/pull/4923#pullrequestreview-115699800",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "929e798c-0ff9-4ee7-9ee4-bf0537ec59a1",
        "parentId" : null,
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "The name of this function is a bit weird (ditto below for value deserializer): are we expect that type `V` is `Change<V1>`? If no, why not just call `valueSerde().serializer()` directly?  ",
        "createdAt" : "2018-04-26T21:31:46Z",
        "updatedAt" : "2018-05-04T15:25:06Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      }
    ],
    "commit" : "4f05b759f69d61379d9eec057d336adb3dd3e765",
    "line" : 65,
    "diffHunk" : "@@ -1,1 +63,67 @@    }\n\n    ChangedSerializer<? extends V> changedValueSerializer() {\n        final Serializer<? extends V> valueSerializer = valueSerde() == null ? null : valueSerde().serializer();\n        return new ChangedSerializer<>(valueSerializer);"
  },
  {
    "id" : "5914786a-4e1a-46b4-9dec-a1c19c402fad",
    "prId" : 4923,
    "prUrl" : "https://github.com/apache/kafka/pull/4923#pullrequestreview-117332700",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f1fd5b63-f803-4e2b-983e-30930fe3a625",
        "parentId" : null,
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "There's some inconsistency among the stateful nodes here:\r\n\r\n1. In `StatefulRepartitionNode` we use `MaterializedInternal`.\r\n2. In `StatefulProcessorNode` we use `StoreBuilder` plus `String[] storeNames`.\r\n3. In `StatefulSourceNode` we use a `StoreBuilder` plus  a `KTableSource`.\r\n\r\nIs this intentional? If not, I'd suggest we make it consistent: it seems the `MaterializedInternal` should be sufficient.",
        "createdAt" : "2018-04-26T21:34:28Z",
        "updatedAt" : "2018-05-04T15:25:06Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "3ce733d8-7780-4129-acd6-6cb83e18eab4",
        "parentId" : "f1fd5b63-f803-4e2b-983e-30930fe3a625",
        "authorId" : "4c968502-bb3d-46ee-8719-0c0bdbc6242f",
        "body" : "Yes, this is intentional, as these are the types used for the `InternalTopologyBuilder`. ",
        "createdAt" : "2018-05-01T18:52:12Z",
        "updatedAt" : "2018-05-04T15:25:06Z",
        "lastEditedBy" : "4c968502-bb3d-46ee-8719-0c0bdbc6242f",
        "tags" : [
        ]
      },
      {
        "id" : "46b2c868-fbec-4da9-a764-1a183a6628e9",
        "parentId" : "f1fd5b63-f803-4e2b-983e-30930fe3a625",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "Specifically, for 3), why do we need a `KTableSource`, as it is for physical plan building? It feels a bit leaky into the logical plan.",
        "createdAt" : "2018-05-02T23:24:33Z",
        "updatedAt" : "2018-05-04T15:25:06Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "5e039e5b-df93-4f78-9b59-85c0ca4b23b8",
        "parentId" : "f1fd5b63-f803-4e2b-983e-30930fe3a625",
        "authorId" : "4c968502-bb3d-46ee-8719-0c0bdbc6242f",
        "body" : "ack, should just be a `ProcessorSupplier`",
        "createdAt" : "2018-05-03T16:16:59Z",
        "updatedAt" : "2018-05-04T15:25:06Z",
        "lastEditedBy" : "4c968502-bb3d-46ee-8719-0c0bdbc6242f",
        "tags" : [
        ]
      }
    ],
    "commit" : "4f05b759f69d61379d9eec057d336adb3dd3e765",
    "line" : 31,
    "diffHunk" : "@@ -1,1 +29,33 @@\n    private final ProcessorSupplier<K, Change<V>> statefulProcessorSupplier;\n    private final MaterializedInternal<K, T, KeyValueStore<Bytes, byte[]>> materialized;\n\n    StatefulRepartitionNode(final String parentProcessorNodeName,"
  }
]
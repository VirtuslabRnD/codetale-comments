[
  {
    "id" : "b7a2c768-f502-4c65-b086-41e78ed31d31",
    "prId" : 7177,
    "prUrl" : "https://github.com/apache/kafka/pull/7177#pullrequestreview-272846082",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a7af6e7a-8292-48f1-90fb-ca0d3123a232",
        "parentId" : null,
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "The reason why `ConcurrentSkipListMap` did not implement it in this way is because it is designed to be async, and we need it that way to support IQ / stream thread concurrency.\r\n\r\nBut since only stream thread would put / delete into the map (assuming we forbid iterator.remove from the other PR so it is not allowed from IQ), then it is okay to have this field as non-volatile.",
        "createdAt" : "2019-08-08T21:12:33Z",
        "updatedAt" : "2019-08-09T20:29:01Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "9ba72bc5-6683-48fa-a258-4041934d7253",
        "parentId" : "a7af6e7a-8292-48f1-90fb-ca0d3123a232",
        "authorId" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "body" : "Yep, that was the reasoning ðŸ˜„ ",
        "createdAt" : "2019-08-08T21:24:20Z",
        "updatedAt" : "2019-08-09T20:29:01Z",
        "lastEditedBy" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "tags" : [
        ]
      }
    ],
    "commit" : "71ceb47c4414e656a1d6897f61f6303c2837b889",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +36,40 @@    private final ConcurrentNavigableMap<Bytes, byte[]> map = new ConcurrentSkipListMap<>();\n    private volatile boolean open = false;\n    private long size = 0L; // SkipListMap#size is O(N) so we just do our best to track it\n\n    private static final Logger LOG = LoggerFactory.getLogger(InMemoryKeyValueStore.class);"
  },
  {
    "id" : "dcf2c4fc-da31-4af5-9053-cec9c66a1005",
    "prId" : 9508,
    "prUrl" : "https://github.com/apache/kafka/pull/9508#pullrequestreview-535288265",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b889944e-ae79-44e1-a317-ec5cd768689c",
        "parentId" : null,
        "authorId" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "body" : "This method needs unit testing.",
        "createdAt" : "2020-11-06T11:46:26Z",
        "updatedAt" : "2021-02-03T10:49:03Z",
        "lastEditedBy" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "tags" : [
        ]
      },
      {
        "id" : "a7bccbc0-756f-47fe-a0c4-1c71a30d74f4",
        "parentId" : "b889944e-ae79-44e1-a317-ec5cd768689c",
        "authorId" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "body" : "This method still needs unit testing.",
        "createdAt" : "2020-11-20T10:04:19Z",
        "updatedAt" : "2021-02-03T10:49:03Z",
        "lastEditedBy" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "tags" : [
        ]
      }
    ],
    "commit" : "8eca3c9c2852172896001178f8e7a115fd392aeb",
    "line" : 21,
    "diffHunk" : "@@ -1,1 +107,111 @@\n    @Override\n    public <PS extends Serializer<P>, P> KeyValueIterator<Bytes, byte[]> prefixScan(final P prefix, final PS prefixKeySerializer) {\n        Objects.requireNonNull(prefix, \"prefix cannot be null\");\n        Objects.requireNonNull(prefixKeySerializer, \"prefixKeySerializer cannot be null\");"
  },
  {
    "id" : "350260c8-7dc8-4bff-9e63-ba2d97b0abae",
    "prId" : 9508,
    "prUrl" : "https://github.com/apache/kafka/pull/9508#pullrequestreview-583298923",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "063e8bdd-c37a-4211-b8a6-c9850ae9b7bd",
        "parentId" : null,
        "authorId" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "body" : "@vamossagar12 I can still not find the unit test for this method.",
        "createdAt" : "2021-01-26T10:35:35Z",
        "updatedAt" : "2021-02-03T10:49:03Z",
        "lastEditedBy" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "tags" : [
        ]
      },
      {
        "id" : "4648ba6c-a0ab-4822-a6b9-386f7b062de6",
        "parentId" : "063e8bdd-c37a-4211-b8a6-c9850ae9b7bd",
        "authorId" : "dec739d0-c763-471c-b738-6b6f5b82e58e",
        "body" : "For this, do you want me to add the test cases here?https://github.com/apache/kafka/blob/17be91a37214bf77430c65d9300a5120e4348df9/streams/src/test/java/org/apache/kafka/streams/state/internals/InMemoryKeyValueStoreTest.java\r\n\r\nThere are tests in CachingInMemoryKeyValueStoreTest, which is where the tests for other methods like range etc have been added. ",
        "createdAt" : "2021-01-28T16:30:25Z",
        "updatedAt" : "2021-02-03T10:49:03Z",
        "lastEditedBy" : "dec739d0-c763-471c-b738-6b6f5b82e58e",
        "tags" : [
        ]
      },
      {
        "id" : "6f617bda-21ca-40ef-801d-6f815b727641",
        "parentId" : "063e8bdd-c37a-4211-b8a6-c9850ae9b7bd",
        "authorId" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "body" : "I think those tests never call the `prefixScan()` on the underlying in-memory state store because all entries fit into the cache. You would need to add another test that flushes the cache before you call `prefixScan()`. I would prefer a test that directly tests the in-memory store without any cache in between. ",
        "createdAt" : "2021-01-31T20:27:05Z",
        "updatedAt" : "2021-02-03T10:49:03Z",
        "lastEditedBy" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "tags" : [
        ]
      },
      {
        "id" : "0ce762a5-593e-47e9-b879-b24885a51ab8",
        "parentId" : "063e8bdd-c37a-4211-b8a6-c9850ae9b7bd",
        "authorId" : "dec739d0-c763-471c-b738-6b6f5b82e58e",
        "body" : "Here is the new ticket: https://issues.apache.org/jira/browse/KAFKA-12289 and the PR for the ticket:\r\nhttps://github.com/apache/kafka/pull/10052",
        "createdAt" : "2021-02-04T11:33:33Z",
        "updatedAt" : "2021-02-04T11:33:33Z",
        "lastEditedBy" : "dec739d0-c763-471c-b738-6b6f5b82e58e",
        "tags" : [
        ]
      }
    ],
    "commit" : "8eca3c9c2852172896001178f8e7a115fd392aeb",
    "line" : 21,
    "diffHunk" : "@@ -1,1 +107,111 @@\n    @Override\n    public <PS extends Serializer<P>, P> KeyValueIterator<Bytes, byte[]> prefixScan(final P prefix, final PS prefixKeySerializer) {\n        Objects.requireNonNull(prefix, \"prefix cannot be null\");\n        Objects.requireNonNull(prefixKeySerializer, \"prefixKeySerializer cannot be null\");"
  }
]
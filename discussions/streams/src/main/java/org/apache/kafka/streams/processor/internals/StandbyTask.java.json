[
  {
    "id" : "f68f3ea9-299a-48e3-b61f-6bd078c73045",
    "prId" : 4544,
    "prUrl" : "https://github.com/apache/kafka/pull/4544#pullrequestreview-99500042",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "58f6d2c2-4722-4105-b5f0-3cdbb91e1841",
        "parentId" : null,
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "I am not sure why we need this? Should the unsubscribe/subscribe change not fix the issue? What is the scenario that is not covered by unsubscribe/subscribe that is fixed with `taskClosed` flag?",
        "createdAt" : "2018-02-26T18:31:44Z",
        "updatedAt" : "2018-02-26T22:53:32Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "97ac9805-c2e4-4a6a-b4c2-b3e1a78867c2",
        "parentId" : "58f6d2c2-4722-4105-b5f0-3cdbb91e1841",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "Strictly speaking this change is not required for this particular fix itself, but I just want to add some more safety net on the code in case there are other unknown issues. After second thought, what I can do is to change the thrown exception to `IllegalStateException` to let it fail immediately than trying to cover any unknown issues. WDYT?",
        "createdAt" : "2018-02-26T22:41:48Z",
        "updatedAt" : "2018-02-26T22:53:32Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "69b10f34-87ba-4ca8-b497-32cb590b89b2",
        "parentId" : "58f6d2c2-4722-4105-b5f0-3cdbb91e1841",
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "Not sure. Both approaches have advantages and disadvantages.\r\n\r\nThe proposed change make the code more robust and thus might result in better user experience. However, we might not learn about issues as user might never recognize this log entry and thus never report. (Maybe we should log this as an ERROR and explain in the message that Streams will auto-recover from this, but people should please report that this happened? -- This would at least increase the likelihood to get a report.)\r\n\r\nFor `IllegalStateException` it would be the other way round... Guess it depends on the likelihood of a bug hitting this? If it's rare, failing might be better?\r\n\r\nBut not sure. \\cc @bbejeck @dguy ",
        "createdAt" : "2018-02-26T22:52:13Z",
        "updatedAt" : "2018-02-26T22:53:32Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "6066f434-dde9-4ed6-8c50-3077c6c3a0d0",
        "parentId" : "58f6d2c2-4722-4105-b5f0-3cdbb91e1841",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "I kept the migration exception while bumping the log to WARN indicating this is not expected to happen in the new commit.",
        "createdAt" : "2018-02-26T22:54:11Z",
        "updatedAt" : "2018-02-26T22:54:12Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      }
    ],
    "commit" : "c08097b3c0a5a569bf05b1872460a6f282786a12",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +146,150 @@        }\n\n        taskClosed = true;\n    }\n"
  },
  {
    "id" : "658efbee-e64f-448e-ab44-fc06ca8e2e77",
    "prId" : 5428,
    "prUrl" : "https://github.com/apache/kafka/pull/5428#pullrequestreview-153565808",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "46bc9003-5efb-46a8-953d-7c8bf86782c8",
        "parentId" : null,
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "Not sure if I understand this. Why is a commit only required if we did not restore all records that were passed in? Don't we need to commit if we did a restore and updated `lastOffset` ?",
        "createdAt" : "2018-09-06T17:52:03Z",
        "updatedAt" : "2018-09-11T21:32:12Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "1015fa72-e448-42a9-a382-bd79255f347b",
        "parentId" : "46bc9003-5efb-46a8-953d-7c8bf86782c8",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "`!restoreRecords.isEmpty()` means we have non-empty records that are applied inside `stateMgr.updateStandbyStates` call, note it does not remove records that are applied after the call.",
        "createdAt" : "2018-09-07T17:54:27Z",
        "updatedAt" : "2018-09-11T21:32:12Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "ac1b69ee-49a6-4765-8545-c83ad0232e6d",
        "parentId" : "46bc9003-5efb-46a8-953d-7c8bf86782c8",
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "Ack. I confused it with `remainingRecords`. All good :)",
        "createdAt" : "2018-09-08T21:53:28Z",
        "updatedAt" : "2018-09-11T21:32:12Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      }
    ],
    "commit" : "71b2b16d0b0f37a05af3df60ae9b5ff88649a7a4",
    "line" : 16,
    "diffHunk" : "@@ -1,1 +191,195 @@        if (!restoreRecords.isEmpty()) {\n            commitNeeded = true;\n        }\n\n        return remainingRecords;"
  },
  {
    "id" : "fc4eda21-c659-4c22-9b1b-3484cc924f29",
    "prId" : 7238,
    "prUrl" : "https://github.com/apache/kafka/pull/7238#pullrequestreview-284928001",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3765866c-0c0a-4ec5-9c32-c048348ca0dd",
        "parentId" : null,
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "Nice catch.",
        "createdAt" : "2019-09-05T22:56:19Z",
        "updatedAt" : "2019-09-11T16:35:57Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "1305c550-da81-4d04-8bd0-c1af82966f7e",
        "parentId" : "3765866c-0c0a-4ec5-9c32-c048348ca0dd",
        "authorId" : "12543f19-3885-429e-8f77-e0f748c56d1f",
        "body" : "Thanks! That one was nasty. It caused us to checkpoint at offset 0, so when the standby became active we had to start from scratch.",
        "createdAt" : "2019-09-06T15:11:45Z",
        "updatedAt" : "2019-09-11T16:35:57Z",
        "lastEditedBy" : "12543f19-3885-429e-8f77-e0f748c56d1f",
        "tags" : [
        ]
      }
    ],
    "commit" : "0b14fbdce1f31b17070923325715f68c0238d43d",
    "line" : 107,
    "diffHunk" : "@@ -1,1 +202,206 @@\n        if (!restoreRecords.isEmpty()) {\n            stateMgr.updateStandbyStates(partition, restoreRecords, lastOffset);\n            commitNeeded = true;\n        }"
  },
  {
    "id" : "62a16fd4-7500-4f5f-bb40-0e01866ea7dd",
    "prId" : 7238,
    "prUrl" : "https://github.com/apache/kafka/pull/7238#pullrequestreview-284929193",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "46378470-6469-4f77-9d3f-6f068038c57d",
        "parentId" : null,
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "Since we do not initialize the offsetLimits, we would always get Long.MAX_VALUE for the first time right?",
        "createdAt" : "2019-09-05T23:19:08Z",
        "updatedAt" : "2019-09-11T16:35:57Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "defdc144-435c-4b7f-b204-a6d0a7cba6c1",
        "parentId" : "46378470-6469-4f77-9d3f-6f068038c57d",
        "authorId" : "12543f19-3885-429e-8f77-e0f748c56d1f",
        "body" : "We initialize the offset to 0 for changelog / source partitions in the constructor, here:\r\n\r\nhttps://github.com/apache/kafka/pull/7238/files#diff-7012e86d489a291404d83f961ad40217R73",
        "createdAt" : "2019-09-06T15:13:42Z",
        "updatedAt" : "2019-09-11T16:35:57Z",
        "lastEditedBy" : "12543f19-3885-429e-8f77-e0f748c56d1f",
        "tags" : [
        ]
      }
    ],
    "commit" : "0b14fbdce1f31b17070923325715f68c0238d43d",
    "line" : 83,
    "diffHunk" : "@@ -1,1 +179,183 @@\n        log.trace(\"Updating standby replicas of its state store for partition [{}]\", partition);\n        long limit = offsetLimits.getOrDefault(partition, Long.MAX_VALUE);\n\n        long lastOffset = -1L;"
  },
  {
    "id" : "6abf68af-8dac-4297-a1c7-2cec4e6227a2",
    "prId" : 7238,
    "prUrl" : "https://github.com/apache/kafka/pull/7238#pullrequestreview-285049057",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "86bfffd6-e3dc-45ad-8961-7780821559ed",
        "parentId" : null,
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "Should we move `updateableOffsetLimits.remove(partition);` into `updateOffsetLimits()` ?",
        "createdAt" : "2019-09-06T18:12:45Z",
        "updatedAt" : "2019-09-11T16:35:57Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "de9f534e-0642-4e8c-8198-0d1745c1b8c9",
        "parentId" : "86bfffd6-e3dc-45ad-8961-7780821559ed",
        "authorId" : "12543f19-3885-429e-8f77-e0f748c56d1f",
        "body" : "Yes, that makes more sense now that we're not removing it in the if stmt.",
        "createdAt" : "2019-09-06T19:08:51Z",
        "updatedAt" : "2019-09-11T16:35:57Z",
        "lastEditedBy" : "12543f19-3885-429e-8f77-e0f748c56d1f",
        "tags" : [
        ]
      }
    ],
    "commit" : "0b14fbdce1f31b17070923325715f68c0238d43d",
    "line" : 94,
    "diffHunk" : "@@ -1,1 +190,194 @@            // the offset limit if possible.\n            if (record.offset() >= limit && updateableOffsetLimits.contains(partition)) {\n                limit = updateOffsetLimits(partition);\n            }\n"
  },
  {
    "id" : "3dca4e69-d297-4ca9-a0cd-c563deee0266",
    "prId" : 7238,
    "prUrl" : "https://github.com/apache/kafka/pull/7238#pullrequestreview-285058829",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "553efb48-f695-40d1-a304-9faf103eb67c",
        "parentId" : null,
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "Do we need to update/extend `StandbyTasktTest` ?",
        "createdAt" : "2019-09-06T19:03:12Z",
        "updatedAt" : "2019-09-11T16:35:57Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "db3aee84-15de-4c18-a13b-ea5993467e1b",
        "parentId" : "553efb48-f695-40d1-a304-9faf103eb67c",
        "authorId" : "12543f19-3885-429e-8f77-e0f748c56d1f",
        "body" : "+1. I think I had some tests for this that I neglected to move over. I'll get those in the next patch.",
        "createdAt" : "2019-09-06T19:31:39Z",
        "updatedAt" : "2019-09-11T16:35:57Z",
        "lastEditedBy" : "12543f19-3885-429e-8f77-e0f748c56d1f",
        "tags" : [
        ]
      }
    ],
    "commit" : "0b14fbdce1f31b17070923325715f68c0238d43d",
    "line" : 29,
    "diffHunk" : "@@ -1,1 +37,41 @@ * A StandbyTask\n */\npublic class StandbyTask extends AbstractTask {\n    private Map<TopicPartition, Long> checkpointedOffsets = new HashMap<>();\n    private final Sensor closeTaskSensor;"
  },
  {
    "id" : "f378f5a1-669f-4691-aefe-1c343dbe4f73",
    "prId" : 7463,
    "prUrl" : "https://github.com/apache/kafka/pull/7463#pullrequestreview-299237945",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "369f93e3-b8b3-4b0a-8cda-282222490833",
        "parentId" : null,
        "authorId" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "body" : "Could we also move this only to the `StreamTask`? Doesn't have to be in this PR. ",
        "createdAt" : "2019-10-08T11:01:08Z",
        "updatedAt" : "2019-10-10T01:02:23Z",
        "lastEditedBy" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "tags" : [
        ]
      },
      {
        "id" : "53a349aa-7857-4226-9bd4-c5e5bc74f4a4",
        "parentId" : "369f93e3-b8b3-4b0a-8cda-282222490833",
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "Not really, because we call `initializeTopology()` within `AssignedTasks#transitToRunning(T task)` that does not know the type (it generic `T extends Tasks`) -- hence, we would need to do an `instanceof` call within that method what is undesired.",
        "createdAt" : "2019-10-08T22:41:10Z",
        "updatedAt" : "2019-10-10T01:02:23Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "11cdd3d7-ea81-467f-a4d5-4f9008085585",
        "parentId" : "369f93e3-b8b3-4b0a-8cda-282222490833",
        "authorId" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "body" : "Oh, I see. I did not think about that dependency. Nevertheless I think somehow it would be possible to move `initializeTopology()` to `StreamsTask` without an `instanceof` but that needs a bit more thoughts and refactoring and it is out-of-scope for this PR.  ",
        "createdAt" : "2019-10-09T08:14:01Z",
        "updatedAt" : "2019-10-10T01:02:23Z",
        "lastEditedBy" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "tags" : [
        ]
      }
    ],
    "commit" : "c47dfc79b0b4a8238e7bdc8707ee9ca32ff324ea",
    "line" : 68,
    "diffHunk" : "@@ -1,1 +94,98 @@\n    @Override\n    public void initializeTopology() {}\n\n    /**"
  },
  {
    "id" : "db0fcce5-c03e-41b0-a626-fc936e63a318",
    "prId" : 7463,
    "prUrl" : "https://github.com/apache/kafka/pull/7463#pullrequestreview-299773986",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6e50d156-5954-4515-94ad-90915bc3abfd",
        "parentId" : null,
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "new method",
        "createdAt" : "2019-10-10T01:05:41Z",
        "updatedAt" : "2019-10-10T01:05:42Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      }
    ],
    "commit" : "c47dfc79b0b4a8238e7bdc8707ee9ca32ff324ea",
    "line" : 51,
    "diffHunk" : "@@ -1,1 +81,85 @@\n    @Override\n    public void initializeMetadata() {}\n\n    @Override"
  },
  {
    "id" : "2666a278-f58d-4072-89ff-249d044ca81f",
    "prId" : 7632,
    "prUrl" : "https://github.com/apache/kafka/pull/7632#pullrequestreview-310635553",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a15c000f-56ee-4e28-bb13-76c6c725e09e",
        "parentId" : null,
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "Could you update the title / description of the PR to make a more clarifying commit message?",
        "createdAt" : "2019-11-01T18:52:39Z",
        "updatedAt" : "2019-11-01T18:52:50Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      }
    ],
    "commit" : "6b95ed4d4040f92a054fbbc4c9e42d3fff67349b",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +70,74 @@        super(id, partitions, topology, consumer, changelogReader, true, stateDirectory, config);\n\n        closeTaskSensor = ThreadMetrics.closeTaskSensor(Thread.currentThread().getName(), metrics);\n        processorContext = new StandbyContextImpl(id, config, stateMgr, metrics);\n"
  },
  {
    "id" : "94a04c71-0da3-4836-aef8-a04dcc972dfb",
    "prId" : 7681,
    "prUrl" : "https://github.com/apache/kafka/pull/7681#pullrequestreview-316029454",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a6b58d7e-46b0-434d-831c-fdd11c5264a5",
        "parentId" : null,
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "The main fix for this PR. Report the _current_ `checkpointedOffsets`, not the ones from when the standby task was first created.",
        "createdAt" : "2019-11-13T06:50:48Z",
        "updatedAt" : "2019-11-13T21:20:04Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      }
    ],
    "commit" : "741306599487c10a3d5f753920f1f1c2e0e0ec73",
    "line" : 21,
    "diffHunk" : "@@ -1,1 +194,198 @@\n    Map<TopicPartition, Long> checkpointedOffsets() {\n        return Collections.unmodifiableMap(stateMgr.checkpointed());\n    }\n"
  },
  {
    "id" : "0bd6e643-b5c1-4ad1-b1f8-4777ce2e8b94",
    "prId" : 8218,
    "prUrl" : "https://github.com/apache/kafka/pull/8218#pullrequestreview-373205186",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "56a2368b-37c3-4f34-b989-1c3023278bce",
        "parentId" : null,
        "authorId" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "body" : "Comment here for no better place: Standby task always returns an empty `committableOffsetsAndMetadata`, then why do we still need to check `commitNeeded` for it? Shouldn't it always set to false?",
        "createdAt" : "2020-03-11T20:50:44Z",
        "updatedAt" : "2020-03-19T08:49:21Z",
        "lastEditedBy" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "tags" : [
        ]
      },
      {
        "id" : "9c94ef2e-a50b-4736-9adc-d9c5b1a1b7e5",
        "parentId" : "56a2368b-37c3-4f34-b989-1c3023278bce",
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "Not sure if I can follow. We don't check `commitNeeded` in `postCommit()`? Can you elaborate?",
        "createdAt" : "2020-03-12T00:09:08Z",
        "updatedAt" : "2020-03-19T08:49:21Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      }
    ],
    "commit" : "4b03a487a518756f7c9acd1f3177b12b407867d5",
    "line" : 66,
    "diffHunk" : "@@ -1,1 +134,138 @@    }\n\n    @Override\n    public void postCommit() {\n        if (state() == State.RUNNING) {"
  },
  {
    "id" : "ed25cc51-7695-43bc-80b8-29d007dc5e3c",
    "prId" : 8218,
    "prUrl" : "https://github.com/apache/kafka/pull/8218#pullrequestreview-375614304",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8d1d90e1-d10a-4ccd-8247-4df4ea4a5fc6",
        "parentId" : null,
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "This is a meta comment: I think we can consolidate `prepareCommit` and `prepareClose` and `prepareSuspend` here by introducing the clean parameters to the function, since their logic are very similar (for the part that they diffs a bit, it can be pushed to post logic), and on task-manager during commit:\r\n\r\n1) for each task -> task.prepareCommit(true)\r\n2) commit\r\n3) for each task -> task.postCommit(true)\r\n\r\nDuring close:\r\n\r\nif (clean)\r\n    1) for each task -> task.prepareCommit(true)\r\n    2) commit()\r\n    3) for each task -> task.postCommit(true)\r\nelse\r\n    1) for each task -> task.prepareCommit(false)\r\n     // do not commit\r\n    3) for each task -> task.postCommit(false)\r\n4) tasks.close(flag)\r\n\r\nAnd the same for suspension.",
        "createdAt" : "2020-03-12T19:16:48Z",
        "updatedAt" : "2020-03-19T08:49:21Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "314c25c4-7adc-45cc-861c-86992c68d5f8",
        "parentId" : "8d1d90e1-d10a-4ccd-8247-4df4ea4a5fc6",
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "Will do this in a follow up PR.",
        "createdAt" : "2020-03-16T04:59:42Z",
        "updatedAt" : "2020-03-19T08:49:21Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "a2a566a3-4d68-47ea-974f-1ddc880510e8",
        "parentId" : "8d1d90e1-d10a-4ccd-8247-4df4ea4a5fc6",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "SG.\r\n\r\nI think in this PR we still can do the change to let `prepareXX` to return the map of partitions -> partition-timestamp to indicate whether this task should be included in committing.",
        "createdAt" : "2020-03-16T22:15:23Z",
        "updatedAt" : "2020-03-19T08:49:21Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      }
    ],
    "commit" : "4b03a487a518756f7c9acd1f3177b12b407867d5",
    "line" : 57,
    "diffHunk" : "@@ -1,1 +125,129 @@     */\n    @Override\n    public void prepareCommit() {\n        if (state() == State.RUNNING) {\n            stateMgr.flush();"
  },
  {
    "id" : "4b4f1402-9e1e-40cc-8468-d4bb052f2ed1",
    "prId" : 8218,
    "prUrl" : "https://github.com/apache/kafka/pull/8218#pullrequestreview-376300554",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "711109df-b0e4-424c-96eb-0e182d2d2571",
        "parentId" : null,
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "nit: we can do `if / else if / else` here still and move the `closeTaskSensor.record(); / transitionTo(State.CLOSED);` to avoid duplication.",
        "createdAt" : "2020-03-16T22:28:40Z",
        "updatedAt" : "2020-03-19T08:49:21Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "5bd91478-7287-4fb0-a331-ff4b648e6e2a",
        "parentId" : "711109df-b0e4-424c-96eb-0e182d2d2571",
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "Well, we can, but we get an empty \"than block\" what is weird:\r\n```\r\nif (state() == State.CREATED) {\r\n  // empty\r\n} else if {\r\n...\r\n}\r\n```",
        "createdAt" : "2020-03-17T01:12:55Z",
        "updatedAt" : "2020-03-19T08:49:21Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "3a464098-42df-4374-b885-dd9e5df2a881",
        "parentId" : "711109df-b0e4-424c-96eb-0e182d2d2571",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "I'd say we can always log a debug there saying \"doing nothing in this function since we are in this state\" :) The main concern I had, is that if in the future we want to add more steps in addition to `recording sensor` etc, we may forget adding it in one place or the other. Removing duplicated code helps us to be less vulnerable.",
        "createdAt" : "2020-03-17T18:30:28Z",
        "updatedAt" : "2020-03-19T08:49:21Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      }
    ],
    "commit" : "4b03a487a518756f7c9acd1f3177b12b407867d5",
    "line" : 153,
    "diffHunk" : "@@ -1,1 +204,208 @@        if (state() == State.CREATED) {\n            // the task is created and not initialized, do nothing\n            closeTaskSensor.record();\n            transitionTo(State.CLOSED);\n            return;"
  },
  {
    "id" : "cc8b2da9-717d-4bed-9edf-49ce06b776a9",
    "prId" : 8218,
    "prUrl" : "https://github.com/apache/kafka/pull/8218#pullrequestreview-375614304",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5d239d88-9805-430f-8272-d2abcd1dfc67",
        "parentId" : null,
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "Ditto here, I think if / else if / else is more readable.",
        "createdAt" : "2020-03-16T22:29:26Z",
        "updatedAt" : "2020-03-19T08:49:21Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      }
    ],
    "commit" : "4b03a487a518756f7c9acd1f3177b12b407867d5",
    "line" : 117,
    "diffHunk" : "@@ -1,1 +174,178 @@            // the task is created and not initialized, do nothing\n            return;\n        }\n\n        if (state() == State.RUNNING) {"
  },
  {
    "id" : "2f6e8047-3f4c-4061-9d85-edd13f59e96e",
    "prId" : 8307,
    "prUrl" : "https://github.com/apache/kafka/pull/8307#pullrequestreview-378738583",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "56ee3b65-14c1-479c-8b27-2a9b007533f4",
        "parentId" : null,
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "Not for this PR: we can clean up the task-manager code to not pass in the checkpoint at all.",
        "createdAt" : "2020-03-20T18:56:23Z",
        "updatedAt" : "2020-03-20T19:02:03Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      }
    ],
    "commit" : "3f4cfd7503c0959ed2453e88ee9f1c98d280ca71",
    "line" : 21,
    "diffHunk" : "@@ -1,1 +190,194 @@    public void closeClean(final Map<TopicPartition, Long> checkpoint) {\n        Objects.requireNonNull(checkpoint);\n        close(true);\n\n        log.info(\"Closed clean\");"
  },
  {
    "id" : "c2dea525-ed1b-4e9b-8f9b-ce4ac9e211ae",
    "prId" : 8440,
    "prUrl" : "https://github.com/apache/kafka/pull/8440#pullrequestreview-389482820",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "855d89de-e106-4ae0-a8b0-687206398a3a",
        "parentId" : null,
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "This is an actually bug-fix. StandbyTasks did not set the eos flag to true for eos-beta and thus did not wipe out their stores in case of failure.",
        "createdAt" : "2020-04-07T20:54:43Z",
        "updatedAt" : "2020-04-14T23:37:49Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      }
    ],
    "commit" : "15e0b98ef384c15022ee76e6ca88b325567e31cb",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +73,77 @@        processorContext = new StandbyContextImpl(id, config, stateMgr, metrics);\n        closeTaskSensor = ThreadMetrics.closeTaskSensor(Thread.currentThread().getName(), metrics);\n        eosEnabled = StreamThread.eosEnabled(config);\n    }\n"
  },
  {
    "id" : "8ebe74ab-a9a5-4fe9-aeec-e36595bb7262",
    "prId" : 8833,
    "prUrl" : "https://github.com/apache/kafka/pull/8833#pullrequestreview-428496484",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3c591d37-8db6-4e16-90ed-13a1af91daa0",
        "parentId" : null,
        "authorId" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "body" : "Do we want to throw here if the current state is `CLOSED`?",
        "createdAt" : "2020-06-08T22:03:53Z",
        "updatedAt" : "2020-06-10T22:33:10Z",
        "lastEditedBy" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "tags" : [
        ]
      },
      {
        "id" : "3b7e8d7f-2afd-4b1b-8bf5-e8de150d6167",
        "parentId" : "3c591d37-8db6-4e16-90ed-13a1af91daa0",
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "My proposal is, to keep the methods idempotent.",
        "createdAt" : "2020-06-09T00:49:59Z",
        "updatedAt" : "2020-06-10T22:33:10Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "83f96193-e749-40dd-88e0-ce0ef185f626",
        "parentId" : "3c591d37-8db6-4e16-90ed-13a1af91daa0",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "nit: we can throw illegal-state if the state() == RESTORING since it should never happen.",
        "createdAt" : "2020-06-09T22:34:11Z",
        "updatedAt" : "2020-06-10T22:33:10Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "03c9d9ee-77ce-4978-9ccd-e8ce449b8c7a",
        "parentId" : "3c591d37-8db6-4e16-90ed-13a1af91daa0",
        "authorId" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "body" : "Why not just make `suspend` a no-op if the task is RESTORING? That seems more in line with how we handle things elsewhere",
        "createdAt" : "2020-06-10T21:49:52Z",
        "updatedAt" : "2020-06-10T22:33:10Z",
        "lastEditedBy" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "tags" : [
        ]
      },
      {
        "id" : "5a20d7bb-262e-4770-a3c1-8fb2315457b4",
        "parentId" : "3c591d37-8db6-4e16-90ed-13a1af91daa0",
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "For `StandbyTasks`, we never restore. When we do the state transition, we away make two transitions directly after each other from `CREATE -> RESTORING -> RUNNING` -- thus, state `RESTORING` is an invalid state for standby tasks.",
        "createdAt" : "2020-06-10T21:57:11Z",
        "updatedAt" : "2020-06-10T22:33:10Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "4c56bfed-ba21-43bc-9146-6441effb3688",
        "parentId" : "3c591d37-8db6-4e16-90ed-13a1af91daa0",
        "authorId" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "body" : "Oh duh, I thought this was StreamTask. In that case, why would we check for RESTORING at all? We don't check for RESTORING state anywhere else in StandbyTask AFAICT (maybe Guozhang thought this was StreamTask like I did? 😛 )",
        "createdAt" : "2020-06-10T22:00:48Z",
        "updatedAt" : "2020-06-10T22:33:10Z",
        "lastEditedBy" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "tags" : [
        ]
      },
      {
        "id" : "20fb7d7f-6c38-4cc8-8c21-2fc0ce559d58",
        "parentId" : "3c591d37-8db6-4e16-90ed-13a1af91daa0",
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "> why would we check for RESTORING at all? \r\n\r\nWell, we don't. (and if we do, only to raise an exception)",
        "createdAt" : "2020-06-10T22:05:47Z",
        "updatedAt" : "2020-06-10T22:33:10Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "4ef68542-5b03-46f6-89ce-002e7878821b",
        "parentId" : "3c591d37-8db6-4e16-90ed-13a1af91daa0",
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "Before this PR, we did not throw if state was RESTORING for this case. Now we do.",
        "createdAt" : "2020-06-10T22:06:32Z",
        "updatedAt" : "2020-06-10T22:33:10Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "a74167c0-59f4-4897-8401-516e5f86f4a1",
        "parentId" : "3c591d37-8db6-4e16-90ed-13a1af91daa0",
        "authorId" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "body" : "Right, by \"check for RESTORING\" I meant \"throw an exception if state is restoring\". It seems odd to check for RESTORING during `suspend` but not in any other StandbyTask method. Either it can never be in RESTORING and we are completely sure of that, and shouldn't check for RESTORING, or we should always check whether it's RESTORING and not just during `suspend` (eg also in `postCommit`)",
        "createdAt" : "2020-06-10T22:18:52Z",
        "updatedAt" : "2020-06-10T22:33:10Z",
        "lastEditedBy" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "tags" : [
        ]
      },
      {
        "id" : "d0955b78-74d2-4a09-b187-6437aeb3879a",
        "parentId" : "3c591d37-8db6-4e16-90ed-13a1af91daa0",
        "authorId" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "body" : "Just to clarify, I would support doing the former, ie don't check whether it's RESTORING here at all. But we should at least be consistent",
        "createdAt" : "2020-06-10T22:19:59Z",
        "updatedAt" : "2020-06-10T22:33:10Z",
        "lastEditedBy" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "tags" : [
        ]
      },
      {
        "id" : "5e595a36-ede5-4eeb-bedc-f433a3f47c35",
        "parentId" : "3c591d37-8db6-4e16-90ed-13a1af91daa0",
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "Ah, I see. I guess we check it in almost all method though. (we just missed `initializeIfNeeded` and `resume()` -- will add it there).",
        "createdAt" : "2020-06-10T22:23:54Z",
        "updatedAt" : "2020-06-10T22:33:10Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "17f0b764-7a0f-469f-9d69-a640d6ffc676",
        "parentId" : "3c591d37-8db6-4e16-90ed-13a1af91daa0",
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "We do this check implicitly for some case already, ie:\r\n```\r\nif (RUNNING) {\r\n} else {\r\n  throw\r\n}\r\n```\r\nie, only `RUNNING` is a valid state, and all others are invalid. Thus, it seems to be consistent if we add those checks elsewhere (or, what would be odd, exclude `RESTORING` from those implicit checks).",
        "createdAt" : "2020-06-10T22:36:11Z",
        "updatedAt" : "2020-06-10T22:36:12Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "29116904-9729-4315-8e1d-9fc820eae646",
        "parentId" : "3c591d37-8db6-4e16-90ed-13a1af91daa0",
        "authorId" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "body" : "Cool 👍 ",
        "createdAt" : "2020-06-10T23:31:30Z",
        "updatedAt" : "2020-06-10T23:31:31Z",
        "lastEditedBy" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "tags" : [
        ]
      }
    ],
    "commit" : "329e187a9187c4ea532ce88e0202402cb6f78b86",
    "line" : 36,
    "diffHunk" : "@@ -1,1 +113,117 @@    public void suspend() {\n        log.trace(\"No-op suspend with state {}\", state());\n        if (state() == State.RUNNING) {\n            transitionTo(State.SUSPENDED);\n        } else if (state() == State.RESTORING) {"
  },
  {
    "id" : "dc78b889-3c52-4bcf-9ea1-51d804866212",
    "prId" : 8833,
    "prUrl" : "https://github.com/apache/kafka/pull/8833#pullrequestreview-427591550",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "dfadd2a4-c498-4fbf-a1b4-542aab472591",
        "parentId" : null,
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "The comment below is not accurate anymore: we do not write checkpoint during recycle actually.\r\n\r\nEDIT: actually, the updated offsetSnapshotSinceLastCommit seems not used since after this function we would create a new StreamTask and in between we do not check if commitNeeded at all. Could we remove line 175 then?",
        "createdAt" : "2020-06-09T22:39:06Z",
        "updatedAt" : "2020-06-10T22:33:10Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      }
    ],
    "commit" : "329e187a9187c4ea532ce88e0202402cb6f78b86",
    "line" : 148,
    "diffHunk" : "@@ -1,1 +176,180 @@        prepareCommit();\n\n        if (state() == State.CREATED || state() == State.SUSPENDED) {\n            stateMgr.recycle();\n        } else {"
  },
  {
    "id" : "0395fa88-4ec1-4f74-af42-031e92439d15",
    "prId" : 8833,
    "prUrl" : "https://github.com/apache/kafka/pull/8833#pullrequestreview-427591550",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4044a3be-2144-4f90-b519-62f351ed6e58",
        "parentId" : null,
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "Ditto for line 195: we do not need to update the snapshot since we are closing the task already.",
        "createdAt" : "2020-06-09T22:43:22Z",
        "updatedAt" : "2020-06-10T22:33:10Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      }
    ],
    "commit" : "329e187a9187c4ea532ce88e0202402cb6f78b86",
    "line" : 163,
    "diffHunk" : "@@ -1,1 +191,195 @@        switch (state()) {\n            case CREATED:\n            case SUSPENDED:\n                executeAndMaybeSwallow(\n                    clean,"
  },
  {
    "id" : "6609b196-e95d-453e-bd41-bbb618976a60",
    "prId" : 8833,
    "prUrl" : "https://github.com/apache/kafka/pull/8833#pullrequestreview-428512137",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "60ef5ef1-7d14-4e70-8b33-037ff714fb10",
        "parentId" : null,
        "authorId" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "body" : "Why call `prepareCommit` (or `suspend` for that matter)?",
        "createdAt" : "2020-06-10T23:33:09Z",
        "updatedAt" : "2020-06-10T23:33:09Z",
        "lastEditedBy" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "tags" : [
        ]
      },
      {
        "id" : "0e3633b9-7669-4863-91c5-4b5da40760b0",
        "parentId" : "60ef5ef1-7d14-4e70-8b33-037ff714fb10",
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "Both now do what `prepareClose()` did before.",
        "createdAt" : "2020-06-11T00:02:28Z",
        "updatedAt" : "2020-06-11T00:02:28Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "838c8ead-0c80-4e3c-baed-70fdb76e060a",
        "parentId" : "60ef5ef1-7d14-4e70-8b33-037ff714fb10",
        "authorId" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "body" : "I just mean, why not inline that? I'm just imagining coming back to this code in a few months and wondering why we need to suspend a task before recycling, or why we call `prepareCommit` but don't then actually commit, etc",
        "createdAt" : "2020-06-11T00:06:31Z",
        "updatedAt" : "2020-06-11T00:06:32Z",
        "lastEditedBy" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "tags" : [
        ]
      },
      {
        "id" : "73ff3943-e9bd-4f88-8849-c41fc38cd1fe",
        "parentId" : "60ef5ef1-7d14-4e70-8b33-037ff714fb10",
        "authorId" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "body" : "Nevermind, I see that's the pattern we follow everywhere else",
        "createdAt" : "2020-06-11T00:19:21Z",
        "updatedAt" : "2020-06-11T00:26:16Z",
        "lastEditedBy" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "tags" : [
        ]
      }
    ],
    "commit" : "329e187a9187c4ea532ce88e0202402cb6f78b86",
    "line" : 141,
    "diffHunk" : "@@ -1,1 +174,178 @@    public void closeAndRecycleState() {\n        suspend();\n        prepareCommit();\n\n        if (state() == State.CREATED || state() == State.SUSPENDED) {"
  },
  {
    "id" : "86fc1148-9062-410a-9d48-52aa01e4ebb6",
    "prId" : 8849,
    "prUrl" : "https://github.com/apache/kafka/pull/8849#pullrequestreview-428570954",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "29f2935d-8f06-4e01-aeae-78c09fcca1f4",
        "parentId" : null,
        "authorId" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "body" : "Just tried to consolidate the log messages between active/standby tasks (and demoted these to debug)",
        "createdAt" : "2020-06-11T03:38:42Z",
        "updatedAt" : "2020-06-12T00:46:58Z",
        "lastEditedBy" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "tags" : [
        ]
      }
    ],
    "commit" : "9d93b48995dc740648689d0d90e939c9ddc018d2",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +138,142 @@        if (state() == State.RUNNING || state() == State.SUSPENDED) {\n            stateMgr.flush();\n            log.debug(\"Prepared task for committing\");\n        } else {\n            throw new IllegalStateException(\"Illegal state \" + state() + \" while preparing standby task \" + id + \" for committing \");"
  },
  {
    "id" : "86ab446f-25ab-4647-b08d-397b03812047",
    "prId" : 8856,
    "prUrl" : "https://github.com/apache/kafka/pull/8856#pullrequestreview-429962944",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5374b07a-4ccd-410b-9fa8-b705c31353d1",
        "parentId" : null,
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "I get that standbys should never really be in RESTORING state, but it still doesn't seem like it's philosophically any more illegal to suspend from RESTORING than it is from RUNNING. I'd vote to legalize RESTORING here. It does seem like a useful sanity check for CLOSED to be illegal, though.",
        "createdAt" : "2020-06-12T16:48:29Z",
        "updatedAt" : "2020-06-16T20:13:14Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      },
      {
        "id" : "bac1c57e-b680-4ca3-becf-5281bd35f2da",
        "parentId" : "5374b07a-4ccd-410b-9fa8-b705c31353d1",
        "authorId" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "body" : "I agree 100%, but at some point in the past we started checking for `RESTORING` and throwing IllegalStateException all over StandbyTask. I wanted to keep the changes here to a minimum and figured we should at least be consistent with the current pattern elsewhere",
        "createdAt" : "2020-06-12T18:42:55Z",
        "updatedAt" : "2020-06-16T20:13:14Z",
        "lastEditedBy" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "tags" : [
        ]
      }
    ],
    "commit" : "2529fb91b156a520ceb4178665ab313051f68cfd",
    "line" : 22,
    "diffHunk" : "@@ -1,1 +125,129 @@                break;\n\n            case RESTORING:\n            case CLOSED:\n                throw new IllegalStateException(\"Illegal state \" + state() + \" while suspending standby task \" + id);"
  },
  {
    "id" : "1d1776bb-95c3-496f-8990-68a3650240a3",
    "prId" : 8882,
    "prUrl" : "https://github.com/apache/kafka/pull/8882#pullrequestreview-431929494",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a0a8c207-0bbc-4d8a-8dd6-b7e66b04544e",
        "parentId" : null,
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "Standby tasks don't currently register any sensors, but I personally rather to be defensive and idempotently ensure we remove any sensors while closing.",
        "createdAt" : "2020-06-16T20:16:53Z",
        "updatedAt" : "2020-06-17T03:42:08Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      },
      {
        "id" : "c4367c7a-d06b-4675-8866-c1e0e2f4c572",
        "parentId" : "a0a8c207-0bbc-4d8a-8dd6-b7e66b04544e",
        "authorId" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "body" : "Sounds good. But why do it both here and in `closeDirty` vs doing so in `close(clean)`?",
        "createdAt" : "2020-06-16T21:35:26Z",
        "updatedAt" : "2020-06-17T03:42:08Z",
        "lastEditedBy" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "tags" : [
        ]
      },
      {
        "id" : "69d825c3-ecf0-4f79-ae26-bb614b8f9c31",
        "parentId" : "a0a8c207-0bbc-4d8a-8dd6-b7e66b04544e",
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "I'd like to inline `close(boolean)`, but am resisting the urge... This is a compromise ;) ",
        "createdAt" : "2020-06-16T22:07:15Z",
        "updatedAt" : "2020-06-17T03:42:08Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      },
      {
        "id" : "e6fa0104-cd40-4fa7-b510-ed3c8d91fccf",
        "parentId" : "a0a8c207-0bbc-4d8a-8dd6-b7e66b04544e",
        "authorId" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "body" : "Fair enough. I thought the answer might be something like that...",
        "createdAt" : "2020-06-16T22:14:18Z",
        "updatedAt" : "2020-06-17T03:42:08Z",
        "lastEditedBy" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "tags" : [
        ]
      }
    ],
    "commit" : "ae1a3908bcaad82e30ad35a0e4462d7a4b7978b5",
    "line" : 46,
    "diffHunk" : "@@ -1,1 +177,181 @@    @Override\n    public void closeClean() {\n        streamsMetrics.removeAllTaskLevelSensors(Thread.currentThread().getName(), id.toString());\n        close(true);\n        log.info(\"Closed clean\");"
  },
  {
    "id" : "f5021ee3-2d4a-4243-b1e0-d9d11f5540f4",
    "prId" : 8886,
    "prUrl" : "https://github.com/apache/kafka/pull/8886#pullrequestreview-432882221",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9429901f-890b-46c2-8e62-2f2786dfff69",
        "parentId" : null,
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "I'm sure this works, but something seems odd about listing _checkpointed_ partitions to find ones that are _not checkpointed_. Maybe we need to encapsulate this search, or provide a more semantically appropriate \"list all changelog partitions\" method?",
        "createdAt" : "2020-06-17T15:26:14Z",
        "updatedAt" : "2020-06-18T01:53:01Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      },
      {
        "id" : "dce9bd99-167c-46e1-8e24-bfa39ef51986",
        "parentId" : "9429901f-890b-46c2-8e62-2f2786dfff69",
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "Yeah, the fix is mainly for illustrating purpose atm. The problem is really, that the checkpoint file get's deleted for EOS before we reach this point in the code and thus we need to \"hack\" around it -- it would be cleaner if we could just check if a checkpoint exists of not...",
        "createdAt" : "2020-06-17T20:28:19Z",
        "updatedAt" : "2020-06-18T01:53:01Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "546fe55d-1f8b-43c8-9961-0bfacdce4aed",
        "parentId" : "9429901f-890b-46c2-8e62-2f2786dfff69",
        "authorId" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "body" : "I think `checkpointed` is just misleadingly named -- it's really more like checkpoint-_able_ offsets IIUC",
        "createdAt" : "2020-06-17T22:52:22Z",
        "updatedAt" : "2020-06-18T01:53:01Z",
        "lastEditedBy" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "tags" : [
        ]
      },
      {
        "id" : "755402f9-bb78-4ce6-94fe-74f38e7d6f86",
        "parentId" : "9429901f-890b-46c2-8e62-2f2786dfff69",
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "Not sure how to proceed? The naming issue might be a general problem, that we might want to fix in trunk/2.6? Is is worth to fix in 2.5?",
        "createdAt" : "2020-06-18T01:25:45Z",
        "updatedAt" : "2020-06-18T01:53:01Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "5a235ba9-3ae9-46a8-9b99-1e64b7d2a47e",
        "parentId" : "9429901f-890b-46c2-8e62-2f2786dfff69",
        "authorId" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "body" : "I'm fine with leaving the poorly-named method as is, since it's fixed in trunk. But maybe you could leave a comment explaining why this seemingly contradictory set of logic actually makes sense (it took me more than a second to understand this at least)",
        "createdAt" : "2020-06-18T01:36:27Z",
        "updatedAt" : "2020-06-18T01:53:01Z",
        "lastEditedBy" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "tags" : [
        ]
      }
    ],
    "commit" : "67974712873ebf4f20705043d3221a9545bb47be",
    "line" : 8,
    "diffHunk" : "@@ -1,1 +90,94 @@            final Set<TopicPartition> partitionsToReinitialize = new HashSet<>();\n            // the state manager actually returns the next checkpoint to be written\n            for (final TopicPartition partition : stateMgr.checkpointed().keySet()) {\n                if (!stateMgr.hadCheckpoint(partition)) {\n                    partitionsToReinitialize.add(partition);"
  },
  {
    "id" : "7a567b6f-7145-465a-affd-24f5f1c5b1dd",
    "prId" : 8886,
    "prUrl" : "https://github.com/apache/kafka/pull/8886#pullrequestreview-432748079",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4d31eed7-1fed-4e3a-a776-6eeb2f5e9e6d",
        "parentId" : null,
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "I have always been, and continue to be, mystified about why we're 100% a-ok with having corrupted state stores in ALOS mode. I understand that there are some kinds of corruption that are unavoidable without some extra work in the stores, but this check is just explicitly ignoring detectable corruption, which seems a bit extreme. Can we remove this conditional? The rest of these checks seem to apply equally well under all execution semantic modes.",
        "createdAt" : "2020-06-17T15:33:22Z",
        "updatedAt" : "2020-06-18T01:53:01Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      },
      {
        "id" : "69cfe7d2-3e85-4259-9f35-73493fd955fe",
        "parentId" : "4d31eed7-1fed-4e3a-a776-6eeb2f5e9e6d",
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "That is the tradeoff people buy in when using at-least-once. As long as state store recovery is expensive, it's not worth to change it IMHO. Also note, even if we wipe out the store for non-eos, the corrupted record might have been written into the changelog topic already, and thus, we would recover the corrupted state again, not gaining anything.",
        "createdAt" : "2020-06-17T20:26:17Z",
        "updatedAt" : "2020-06-18T01:53:01Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      }
    ],
    "commit" : "67974712873ebf4f20705043d3221a9545bb47be",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +87,91 @@        registerStateStores();\n\n        if (eosEnabled) {\n            final Set<TopicPartition> partitionsToReinitialize = new HashSet<>();\n            // the state manager actually returns the next checkpoint to be written"
  }
]
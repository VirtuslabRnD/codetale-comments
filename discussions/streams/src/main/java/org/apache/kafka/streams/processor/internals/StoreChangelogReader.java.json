[
  {
    "id" : "a8c0dc49-a822-4bcb-af72-0cab466224da",
    "prId" : 4300,
    "prUrl" : "https://github.com/apache/kafka/pull/4300#pullrequestreview-83592281",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7a9126e8-33c3-4fae-a017-460923f162d8",
        "parentId" : null,
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "At this point, we hit a race condition for the restore case of a regular changelog topic: `restorer.hasCompleted(pos, endOffset)` might return `true` even if some record got appended to the changelog iff (by chance), the last `poll()` batch of records ends at \"endOffsets - 1\".\r\n\r\nWe should add an additional check here, and get the `endOffset` of the partition again, and check if `restorer.hasCompleted(pos, newEndOffset) == true` -- if it's false, we should also throw `TaskMigratedException`.",
        "createdAt" : "2017-12-12T21:28:39Z",
        "updatedAt" : "2017-12-27T17:53:21Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "6eaa4d50-01d2-4509-ae6e-b877598920fd",
        "parentId" : "7a9126e8-33c3-4fae-a017-460923f162d8",
        "authorId" : "4c968502-bb3d-46ee-8719-0c0bdbc6242f",
        "body" : "Maybe I don't recall all the details of the offline conversation, or I'm missing something else, but by fetching the `endOffset` again and doing another `restorer.hasCompleted(pos, newEndOffset)` call won't this cause issues for `KTable` with a source topic?\r\n\r\nEDIT: unless we indicate this for this is a source log topic vs regular changelog topic, In which case I think that should go into a separate Jira/PR so as not to hold this one up.",
        "createdAt" : "2017-12-14T17:07:08Z",
        "updatedAt" : "2017-12-27T17:53:21Z",
        "lastEditedBy" : "4c968502-bb3d-46ee-8719-0c0bdbc6242f",
        "tags" : [
        ]
      },
      {
        "id" : "0570f955-9f90-4b9e-a5eb-b9b2cc58526e",
        "parentId" : "7a9126e8-33c3-4fae-a017-460923f162d8",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "I think @mjsax 's comment was that we can add another `endOffset` call and check if the returned value is still the same, this will help reduce the likelihood of race condition but not eliminate it: however, we need to distinguish the case for source KTable such that in the case when `offset limit ` is specified, we do not need this additional check.",
        "createdAt" : "2017-12-14T17:45:01Z",
        "updatedAt" : "2017-12-27T17:53:21Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "d533dd2d-84f3-4690-96cc-5752cd79e14f",
        "parentId" : "7a9126e8-33c3-4fae-a017-460923f162d8",
        "authorId" : "4c968502-bb3d-46ee-8719-0c0bdbc6242f",
        "body" : "ack",
        "createdAt" : "2017-12-14T17:59:58Z",
        "updatedAt" : "2017-12-27T17:53:21Z",
        "lastEditedBy" : "4c968502-bb3d-46ee-8719-0c0bdbc6242f",
        "tags" : [
        ]
      }
    ],
    "commit" : "85444fb99e659aeee7638f0183f608115e98a212",
    "line" : 35,
    "diffHunk" : "@@ -1,1 +252,256 @@        restorer.setRestoredOffset(pos);\n        if (restorer.hasCompleted(pos, endOffset)) {\n            if (pos > endOffset) {\n                throw new TaskMigratedException(task, topicPartition, endOffset, pos);\n            }"
  },
  {
    "id" : "8de51519-7b8a-4a00-a6f5-0f5f43acdc0f",
    "prId" : 4300,
    "prUrl" : "https://github.com/apache/kafka/pull/4300#pullrequestreview-83328117",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e1bd9850-2ba1-48b4-9f95-34561858edff",
        "parentId" : null,
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "Good catch！",
        "createdAt" : "2017-12-13T21:39:05Z",
        "updatedAt" : "2017-12-27T17:53:21Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      }
    ],
    "commit" : "85444fb99e659aeee7638f0183f608115e98a212",
    "line" : 35,
    "diffHunk" : "@@ -1,1 +252,256 @@        restorer.setRestoredOffset(pos);\n        if (restorer.hasCompleted(pos, endOffset)) {\n            if (pos > endOffset) {\n                throw new TaskMigratedException(task, topicPartition, endOffset, pos);\n            }"
  },
  {
    "id" : "d6a4df80-73bf-4659-8097-94d77cd7b8fb",
    "prId" : 4300,
    "prUrl" : "https://github.com/apache/kafka/pull/4300#pullrequestreview-83668920",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bbe18135-c5e2-4778-b99f-032d1ec8f593",
        "parentId" : null,
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "nit: remove empty line\r\n\r\nAs discussed with @guozhangwang offline, I think passing in `nextPosition` is not correct. We should pass in the offset of the latest restored offset, but `nextPosition` is the offset of the first not restored offset.\r\n\r\nQuestion is, if a `nextPosition - 1` would be desirable or not because this might be a commit marker position and not an actual record position. ",
        "createdAt" : "2017-12-14T18:34:57Z",
        "updatedAt" : "2017-12-27T17:53:21Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "55fc85da-a7eb-429f-8223-8a94166d8c3a",
        "parentId" : "bbe18135-c5e2-4778-b99f-032d1ec8f593",
        "authorId" : "4c968502-bb3d-46ee-8719-0c0bdbc6242f",
        "body" : "Correct, this will be handled in a follow-up PR.  I synced off-line with @guozhangwang last night about this.",
        "createdAt" : "2017-12-14T19:11:01Z",
        "updatedAt" : "2017-12-27T17:53:21Z",
        "lastEditedBy" : "4c968502-bb3d-46ee-8719-0c0bdbc6242f",
        "tags" : [
        ]
      },
      {
        "id" : "c44556ea-18cc-4ee9-9f58-051afc38b248",
        "parentId" : "bbe18135-c5e2-4778-b99f-032d1ec8f593",
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "Ack. Can you create a JIRA for it?",
        "createdAt" : "2017-12-14T21:40:31Z",
        "updatedAt" : "2017-12-27T17:53:21Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "7135b4ba-3efc-4fa9-9f1a-741ea70c2102",
        "parentId" : "bbe18135-c5e2-4778-b99f-032d1ec8f593",
        "authorId" : "4c968502-bb3d-46ee-8719-0c0bdbc6242f",
        "body" : "Done - https://issues.apache.org/jira/browse/KAFKA-6367",
        "createdAt" : "2017-12-14T22:41:17Z",
        "updatedAt" : "2017-12-27T17:53:21Z",
        "lastEditedBy" : "4c968502-bb3d-46ee-8719-0c0bdbc6242f",
        "tags" : [
        ]
      }
    ],
    "commit" : "85444fb99e659aeee7638f0183f608115e98a212",
    "line" : 75,
    "diffHunk" : "@@ -1,1 +297,301 @@            restorer.restore(restoreRecords);\n            restorer.restoreBatchCompleted(nextPosition, records.size());\n\n        }\n"
  },
  {
    "id" : "08297b25-d609-468d-92c3-f35070a71e5c",
    "prId" : 4300,
    "prUrl" : "https://github.com/apache/kafka/pull/4300#pullrequestreview-84911333",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2751300b-8d99-4ab5-9457-62ef68e7e516",
        "parentId" : null,
        "authorId" : "4c968502-bb3d-46ee-8719-0c0bdbc6242f",
        "body" : "I've thought about this some more, and given the previous comments (https://github.com/apache/kafka/pull/4300#discussion_r156816065) that `processNext` was correct but susceptible to a race condition where we don't restore all records, IMHO we just need to add an additional check we did not restore all records in the list.   If you insist I can put in the `Math.min(restorer.OffestLimit(),restoreConsumer...)`",
        "createdAt" : "2017-12-19T18:32:19Z",
        "updatedAt" : "2017-12-27T17:53:21Z",
        "lastEditedBy" : "4c968502-bb3d-46ee-8719-0c0bdbc6242f",
        "tags" : [
        ]
      },
      {
        "id" : "31f7954c-cfc3-42bf-9df1-462180b3600f",
        "parentId" : "2751300b-8d99-4ab5-9457-62ef68e7e516",
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "I think this logic is correct now.`Math.min(...)` should do the exact same computation if I got it write. Both approaches have advantages: yours is more descriptive and thus explains itself better. The other one is more concise code allowing us to remove some local vars (`numberRecrods`, `numberRestored`), but harder to understand whats going if if you are not familiar with the code. Not sure which one is better.\r\n\r\n@guozhangwang @dguy WDYT? ",
        "createdAt" : "2017-12-20T22:01:00Z",
        "updatedAt" : "2017-12-27T17:53:21Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      }
    ],
    "commit" : "85444fb99e659aeee7638f0183f608115e98a212",
    "line" : 67,
    "diffHunk" : "@@ -1,1 +290,294 @@        // otherwise if we did not fully restore to that point we need to set nextPosition\n        // to the position of the restoreConsumer and we'll cause a TaskMigratedException exception\n        if (nextPosition == -1 || (restorer.offsetLimit() == Long.MAX_VALUE && numberRecords != numberRestored)) {\n            nextPosition = restoreConsumer.position(restorer.partition());\n        }"
  },
  {
    "id" : "f2842725-492d-4ae9-8f65-63502596ef60",
    "prId" : 5013,
    "prUrl" : "https://github.com/apache/kafka/pull/5013#pullrequestreview-121996537",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "37e40195-134d-4f2b-abba-6dad93a28dc2",
        "parentId" : null,
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "we can also remove the entry in `updatedEndOffsets` if this is true.",
        "createdAt" : "2018-05-22T01:35:00Z",
        "updatedAt" : "2018-06-04T21:37:31Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      }
    ],
    "commit" : "e742d310817ba306c0a217666b983755418549e1",
    "line" : 48,
    "diffHunk" : "@@ -1,1 +88,92 @@                final long pos = processNext(records.records(partition), restorer, updatedEndOffsets.get(partition));\n                restorer.setRestoredOffset(pos);\n                if (restorer.hasCompleted(pos, updatedEndOffsets.get(partition))) {\n                    restorer.restoreDone();\n                    updatedEndOffsets.remove(partition);"
  }
]
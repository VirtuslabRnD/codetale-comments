[
  {
    "id" : "ddb556d6-4789-4634-8f10-ffeebd883960",
    "prId" : 10609,
    "prUrl" : "https://github.com/apache/kafka/pull/10609#pullrequestreview-665070894",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a5375b43-b154-4f72-9296-3d17626618b7",
        "parentId" : null,
        "authorId" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "body" : "Just wanted to lay out my test plan somewhere, so it doesn't seem like I'm merging all this code with no intention to ever test it. Once the final pieces are in (should be by Pt. 2) these are the things I think are important to touch on with integration tests. Leave a comment if you have any more suggestions or feedback ðŸ™‚ ",
        "createdAt" : "2021-05-21T04:02:55Z",
        "updatedAt" : "2021-05-21T04:02:56Z",
        "lastEditedBy" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "tags" : [
        ]
      }
    ],
    "commit" : "7175e27c77ffbf92bf1d9cda14c019ba6dd14f0f",
    "line" : 20,
    "diffHunk" : "@@ -1,1 +18,22 @@\npublic class NamedTopologyIntegrationTest {\n    //TODO KAFKA-12648\n    /**\n     * Things to test in Pt. 2 -  Introduce TopologyMetadata to wrap InternalTopologyBuilders of named topologies:"
  },
  {
    "id" : "5d6af7ec-b0ed-4961-a461-7612e74728a6",
    "prId" : 10683,
    "prUrl" : "https://github.com/apache/kafka/pull/10683#pullrequestreview-718645216",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0efe590d-f4a5-41df-8a3c-fd913e90ac8b",
        "parentId" : null,
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "Just curious, what if we just pass in `buildNamedTopologies(builder1, builder1, builder1)` here?",
        "createdAt" : "2021-07-27T23:21:02Z",
        "updatedAt" : "2021-07-27T23:24:11Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "a774a8ed-a930-4c95-98a8-476860f0d56a",
        "parentId" : "0efe590d-f4a5-41df-8a3c-fd913e90ac8b",
        "authorId" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "body" : "If you pass in the same builder object it will end up throwing the `IllegalStateException: Tried to set topologyName but the name was already set` since it's using the same underlying InternalTopologyBuilder. Actually the same thing would have happened before named topologies but for `applicationId` instead of `topologyName` , except that we don't do this check in `setApplicationId` \r\n\r\nPersonally I would argue that we should also do this check in `setApplicationId`, but it would probably break hundreds of tests which happen to reuse the same builder across different KafkaStreams. Imo the real issue is that the StreamsBuilder class (or technically the InternalStreamsBuilder) has its own InternalTopologyBuilder that it creates during instantiation and then actively updates as the DSL topology is built, even though it should just be a basic builder class that simply specifies the DSL and the InternalTopologyBuilder is only created when calling StreamsBuilder#build.\r\n\r\nIt seems like some awkwardness in the logical vs physical topology plan: the StreamsBuilder feels like it should only cover the logical DSL topology, and the StreamsBuilder alone, but in reality this leeches into the InternalTopologyBuilder. Whereas the InternalTopologyBuilder feels like it should just be responsible for the physical plan generated by the logical plan in StreamsBuilder#build, yet in fact this class contains pretty much everything -- it's the logical plan, the physical plan, and all the metadata that Streams needs to access.\r\n\r\nAnyways that's my long rant on the InternalTopologyBuilder, I think you actually filed a ticket for cleaning up this logical vs physical plan logic so maybe that will cover it ðŸ™‚ ",
        "createdAt" : "2021-07-30T01:13:01Z",
        "updatedAt" : "2021-07-30T01:13:01Z",
        "lastEditedBy" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "tags" : [
        ]
      }
    ],
    "commit" : "ba4a0da87422fc24bbf190022ddd6b80f784e941",
    "line" : 173,
    "diffHunk" : "@@ -1,1 +174,178 @@        builder2.stream(inputStream2).selectKey((k, v) -> k).groupByKey().count(Materialized.as(Stores.persistentKeyValueStore(\"store\"))).toStream().to(outputStream2);\n        builder3.stream(inputStream3).selectKey((k, v) -> k).groupByKey().count(Materialized.as(Stores.persistentKeyValueStore(\"store\"))).toStream().to(outputStream3);\n        streams = new KafkaStreamsNamedTopologyWrapper(buildNamedTopologies(builder1, builder2, builder3), props, clientSupplier);\n        IntegrationTestUtils.startApplicationAndWaitUntilRunning(singletonList(streams), Duration.ofSeconds(15));\n"
  },
  {
    "id" : "b1d5f75a-1592-42f2-a22a-c11dca8720b7",
    "prId" : 10683,
    "prUrl" : "https://github.com/apache/kafka/pull/10683#pullrequestreview-718636710",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bce991a7-7551-4c05-825f-da45b158e17d",
        "parentId" : null,
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "nit: setting up and creating a cluster/topics are time consuming for ITs, could we consider make it Before/AfterClass so that we only do it once? I feel all these tests can share the same topics anyways.",
        "createdAt" : "2021-07-27T23:22:20Z",
        "updatedAt" : "2021-07-27T23:24:11Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "612eab02-89ae-4322-aa6b-b2b2fd2b97c4",
        "parentId" : "bce991a7-7551-4c05-825f-da45b158e17d",
        "authorId" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "body" : "Good point, most of them can share the same topics/input data and can save this repeated setup/teardown. A few do need their own topics so they can control when input data appears on which topic, but we can just handle those few separately -- I'll move most of this to a @Before/AfterClass",
        "createdAt" : "2021-07-30T00:46:21Z",
        "updatedAt" : "2021-07-30T00:46:21Z",
        "lastEditedBy" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "tags" : [
        ]
      },
      {
        "id" : "1c4e0338-c4ca-44be-a981-01281141b58e",
        "parentId" : "bce991a7-7551-4c05-825f-da45b158e17d",
        "authorId" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "body" : "Actually the ones that need separate handling aren't even added until Pt. 3 anyways I'm just realizing",
        "createdAt" : "2021-07-30T00:47:39Z",
        "updatedAt" : "2021-07-30T00:47:39Z",
        "lastEditedBy" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "tags" : [
        ]
      }
    ],
    "commit" : "ba4a0da87422fc24bbf190022ddd6b80f784e941",
    "line" : 117,
    "diffHunk" : "@@ -1,1 +118,122 @@    }\n\n    @Before\n    public void setup() throws InterruptedException {\n        appId = safeUniqueTestName(NamedTopologyIntegrationTest.class, testName);"
  },
  {
    "id" : "ff164ef5-274d-4f87-91bc-26e390f59705",
    "prId" : 10788,
    "prUrl" : "https://github.com/apache/kafka/pull/10788#pullrequestreview-723971414",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8d66e6b7-c969-42e6-96e0-66b178b0682d",
        "parentId" : null,
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "This is meta question: do we have coverage on scenarios where the leader/member's bookkept named-topologies set are different? I.e. 1) the leader would not try to create any tasks that it's own topology-metadata is not aware of even if other subscriptions contain more topics, 2) vice verse, the other members would not try to create tasks for assignment that its topology metadata does not recognize, while later when they get added the tasks gets created then?",
        "createdAt" : "2021-08-03T23:38:36Z",
        "updatedAt" : "2021-08-03T23:38:45Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "e0af7ee2-150b-46fc-8818-9359f7d8eba4",
        "parentId" : "8d66e6b7-c969-42e6-96e0-66b178b0682d",
        "authorId" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "body" : "I'm still filling out the integration test suite, especially the multi-node testing, but I'll make sure this scenario has coverage. This will probably have to be in the followup Pt. 4 which expands `add/removeNamedTopology` to return a `Future`, since being able to block on this helps a lot with the testing.",
        "createdAt" : "2021-08-05T03:12:02Z",
        "updatedAt" : "2021-08-05T03:12:02Z",
        "lastEditedBy" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "tags" : [
        ]
      },
      {
        "id" : "997cfd1c-3039-4e7c-aa26-321b34a55f29",
        "parentId" : "8d66e6b7-c969-42e6-96e0-66b178b0682d",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "SG.",
        "createdAt" : "2021-08-06T04:30:00Z",
        "updatedAt" : "2021-08-06T04:30:00Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      }
    ],
    "commit" : "623e7d3514516f355b468e4b23e45d33b8ecab22",
    "line" : 48,
    "diffHunk" : "@@ -1,1 +74,78 @@    public static final EmbeddedKafkaCluster CLUSTER = new EmbeddedKafkaCluster(1);\n\n    // TODO KAFKA-12648:\n    //  1) full test coverage for add/removeNamedTopology, covering:\n    //      - the \"last topology removed\" case"
  }
]
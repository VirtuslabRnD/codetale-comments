[
  {
    "id" : "ce29eaf9-81f6-4547-8c46-80e7bea78188",
    "prId" : 5451,
    "prUrl" : "https://github.com/apache/kafka/pull/5451#pullrequestreview-145722954",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f06527f1-1dc1-4ef6-9cf2-e75fa4963f2e",
        "parentId" : null,
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "Meta comment: how can we merge repartition topics if there are value changing after key changing, in this case the value serdes may not be the same right?",
        "createdAt" : "2018-08-11T00:02:58Z",
        "updatedAt" : "2018-08-14T00:17:00Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "dd9527e4-fac3-49d2-aaea-4855f0d0ac14",
        "parentId" : "f06527f1-1dc1-4ef6-9cf2-e75fa4963f2e",
        "authorId" : "4c968502-bb3d-46ee-8719-0c0bdbc6242f",
        "body" : "We can't and don't.  \r\n\r\nThis topology is created for the test `shouldNotOptimizeWithValueOrKeyChangingOperatorsAfterInitialKeyChange` to verify that when we have such a  situation, no optimizations take place.\r\n\r\nThe test proves that a `Topology` resulting from calling `build` with optimization configured is the same as the `Topology` resulting from a non-optimized `build` call. Hence no optimizations have been performed. ",
        "createdAt" : "2018-08-13T14:19:39Z",
        "updatedAt" : "2018-08-14T00:17:00Z",
        "lastEditedBy" : "4c968502-bb3d-46ee-8719-0c0bdbc6242f",
        "tags" : [
        ]
      },
      {
        "id" : "1ead05d8-64e8-4cf8-ac5b-a86a7f6e3335",
        "parentId" : "f06527f1-1dc1-4ef6-9cf2-e75fa4963f2e",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "Ack. Thanks!",
        "createdAt" : "2018-08-13T16:01:49Z",
        "updatedAt" : "2018-08-14T00:17:00Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      }
    ],
    "commit" : "9faa4975e48126bc019e77e03e8ec8ce2f75826d",
    "line" : 87,
    "diffHunk" : "@@ -1,1 +102,106 @@        final KStream<String, String> mappedKeyStream = inputStream.selectKey((k, v) -> k + v);\n\n        mappedKeyStream.mapValues(v -> v.toUpperCase(Locale.getDefault())).groupByKey().count().toStream().to(\"output\");\n        mappedKeyStream.flatMapValues(v -> Arrays.asList(v.split(\"\\\\s\"))).groupByKey().windowedBy(TimeWindows.of(5000)).count().toStream().to(\"windowed-output\");\n"
  },
  {
    "id" : "8ce9e782-9b4f-4a9e-a5c3-d2da29a90e67",
    "prId" : 7117,
    "prUrl" : "https://github.com/apache/kafka/pull/7117#pullrequestreview-305544451",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "eda49980-c01b-472a-96ae-a2cc27ca6a16",
        "parentId" : null,
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "Seems I don't understand the root cause of the bug. Don't we need to add a \"key dependent\" operation (like aggregation) to trigger a repartition and to merge the nodes to only create one repartition topic?",
        "createdAt" : "2019-07-30T20:44:29Z",
        "updatedAt" : "2019-07-30T20:44:29Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "36ad0932-aaf6-4996-b516-a01f2690c9cb",
        "parentId" : "eda49980-c01b-472a-96ae-a2cc27ca6a16",
        "authorId" : "4c968502-bb3d-46ee-8719-0c0bdbc6242f",
        "body" : "Going back to my comment above, when users specify `OPTIMIZE` the code eagerly makes changes for adjusting the graph for any merge nodes that may require repartitioning.  But in this case, we should do nothing as there is nothing to trigger a repartition.  I'll look to fix this, but I don't see this being a quick fix, so my preference is to do this in a follow-up PR.",
        "createdAt" : "2019-07-31T19:05:58Z",
        "updatedAt" : "2019-07-31T19:09:07Z",
        "lastEditedBy" : "4c968502-bb3d-46ee-8719-0c0bdbc6242f",
        "tags" : [
        ]
      },
      {
        "id" : "6e8b9671-68bf-4411-b57c-de12b5808e97",
        "parentId" : "eda49980-c01b-472a-96ae-a2cc27ca6a16",
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "I think we can remove the `to()` operator to verify if we don't fail with a NPE.",
        "createdAt" : "2019-10-22T22:28:25Z",
        "updatedAt" : "2019-10-22T22:28:25Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      }
    ],
    "commit" : "4d0e23f78780db4d337797326237807e760ba429",
    "line" : 25,
    "diffHunk" : "@@ -1,1 +139,143 @@            .merge(childStream2)\n            .merge(childStream3)\n            .to(\"output_topic\");\n\n        final Properties properties = new Properties();"
  },
  {
    "id" : "3d301789-e95e-402d-bbd9-b4f8b6ba6b22",
    "prId" : 7117,
    "prUrl" : "https://github.com/apache/kafka/pull/7117#pullrequestreview-305544255",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1842add6-2e6f-433c-b90c-e13246c4929b",
        "parentId" : null,
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "While this is the example from the ticket, the issue is not related to branching out as done here. Should we rewrite/simplify the test and just create 3 `KStream sX = streams.builder()` and later add one single key-changing operation? -> `s1.selectKey().merge(s2).merge(s3).`",
        "createdAt" : "2019-10-22T22:27:48Z",
        "updatedAt" : "2019-10-22T22:27:48Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      }
    ],
    "commit" : "4d0e23f78780db4d337797326237807e760ba429",
    "line" : 20,
    "diffHunk" : "@@ -1,1 +134,138 @@        final KStream<Integer, Integer> childStream1 = parentStream.mapValues(v -> v + 1);\n        final KStream<Integer, Integer> childStream2 = parentStream.mapValues(v -> v + 2);\n        final KStream<Integer, Integer> childStream3 = parentStream.mapValues(v -> v + 3);\n\n        childStream1"
  }
]
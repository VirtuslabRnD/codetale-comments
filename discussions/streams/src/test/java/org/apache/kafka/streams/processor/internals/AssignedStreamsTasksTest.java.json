[
  {
    "id" : "2fc2d336-e296-45bd-b77f-c28fb617c06f",
    "prId" : 4684,
    "prUrl" : "https://github.com/apache/kafka/pull/4684#pullrequestreview-103221912",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c3769020-1eed-476e-bf20-61b6cb93457f",
        "parentId" : null,
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "`t1.resume()` doesn't do anything. Should we remove it and rename the test? `shouldCloseTaskOnInitializeTopologyIfTaskMigratedException` ?",
        "createdAt" : "2018-03-12T20:12:03Z",
        "updatedAt" : "2018-03-13T07:10:52Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "086da054-9d22-4ca2-8925-0c7cfa077adb",
        "parentId" : "c3769020-1eed-476e-bf20-61b6cb93457f",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "In `assignedTasks.maybeResumeSuspendedTask` we still call both functions, so to make it more general in case we would have some logic inside resume in the future, I still keep it here and leave the title not changed in order to reflect the more general case.",
        "createdAt" : "2018-03-12T20:46:47Z",
        "updatedAt" : "2018-03-13T07:10:52Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "f0d843b6-cdb7-480d-b678-ed0f31cf471b",
        "parentId" : "c3769020-1eed-476e-bf20-61b6cb93457f",
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "Ack. Fine with me.",
        "createdAt" : "2018-03-12T21:13:33Z",
        "updatedAt" : "2018-03-13T07:10:52Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      }
    ],
    "commit" : "ab06625e33c890022ba5b9d292cdc83b7029173f",
    "line" : 8,
    "diffHunk" : "@@ -1,1 +260,264 @@        mockRunningTaskSuspension();\n        t1.resume();\n        t1.initializeTopology();\n        EasyMock.expectLastCall().andThrow(new TaskMigratedException(t1));\n        t1.close(false, true);"
  },
  {
    "id" : "9af25dc2-54c4-46c5-8c6f-f83cb4442297",
    "prId" : 6694,
    "prUrl" : "https://github.com/apache/kafka/pull/6694#pullrequestreview-274849969",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a930335b-7f3a-4670-8504-3590c384b386",
        "parentId" : null,
        "authorId" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "body" : "Please remove empty line before this line.",
        "createdAt" : "2019-08-15T09:28:24Z",
        "updatedAt" : "2019-09-16T23:28:41Z",
        "lastEditedBy" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "tags" : [
        ]
      }
    ],
    "commit" : "b42a883a14bc3a48a28624e3964be81e4f75d8f5",
    "line" : 16,
    "diffHunk" : "@@ -1,1 +97,101 @@        EasyMock.expect(t2.partitions()).andReturn(t2partitions);\n        EasyMock.expect(t2.changelogPartitions()).andReturn(Collections.emptyList());\n        t1.initializeTaskTime();\n        t2.initializeTaskTime();\n"
  },
  {
    "id" : "9613f686-b8ad-418d-89bc-913cb4832d33",
    "prId" : 7608,
    "prUrl" : "https://github.com/apache/kafka/pull/7608#pullrequestreview-308895935",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "aed84e74-cf1e-4e5d-9da3-fd772ea09dfd",
        "parentId" : null,
        "authorId" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "body" : "nit: empty line",
        "createdAt" : "2019-10-29T23:34:11Z",
        "updatedAt" : "2019-10-29T23:41:43Z",
        "lastEditedBy" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "tags" : [
        ]
      },
      {
        "id" : "8969d22f-c4a8-4262-a357-6bd819816d07",
        "parentId" : "aed84e74-cf1e-4e5d-9da3-fd772ea09dfd",
        "authorId" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "body" : "You mean right before the end of the file? A lot of them seem to have that, not sure if intentional or not though",
        "createdAt" : "2019-10-29T23:38:00Z",
        "updatedAt" : "2019-10-29T23:41:43Z",
        "lastEditedBy" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "tags" : [
        ]
      }
    ],
    "commit" : "01a2aedaf962ef937687f97786c637ed6821efd5",
    "line" : 194,
    "diffHunk" : "@@ -1,1 +552,556 @@    }\n\n}"
  },
  {
    "id" : "e2bcfb22-3a96-49cc-b0a2-7af71d260575",
    "prId" : 7617,
    "prUrl" : "https://github.com/apache/kafka/pull/7617#pullrequestreview-310242521",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2317b8ee-d5fb-4c56-b12c-7b6a0d92702e",
        "parentId" : null,
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "Hmm this is interesting: for created the running tasks we call its `task.close` function whereas for `restoring` we only call `task.closeStateManager`, is it intentional? If yes why? cc @ableegoldman ",
        "createdAt" : "2019-10-31T20:24:44Z",
        "updatedAt" : "2019-10-31T20:28:09Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "d5c29097-cf52-438a-b9be-eadc2853444e",
        "parentId" : "2317b8ee-d5fb-4c56-b12c-7b6a0d92702e",
        "authorId" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "body" : "I asked you exactly that a few months ago :) You referenced some old PR but basically the takeaway was, a restoring task hasn't initialized anything but its state, therefore needs to close only the state manager",
        "createdAt" : "2019-10-31T22:06:06Z",
        "updatedAt" : "2019-10-31T22:06:06Z",
        "lastEditedBy" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "tags" : [
        ]
      },
      {
        "id" : "e8bd8370-2919-45b2-b7c7-a69e16850805",
        "parentId" : "2317b8ee-d5fb-4c56-b12c-7b6a0d92702e",
        "authorId" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "body" : "It's a little awkward, @abbccdda maybe we should at least put in a comment explaining this for now so we don't have to keep asking each other ",
        "createdAt" : "2019-10-31T22:07:39Z",
        "updatedAt" : "2019-10-31T22:07:39Z",
        "lastEditedBy" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "tags" : [
        ]
      },
      {
        "id" : "2922a99a-f287-405e-9f78-feb0f1091ded",
        "parentId" : "2317b8ee-d5fb-4c56-b12c-7b6a0d92702e",
        "authorId" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "body" : "Ultimately I've been thinking all these different task types should literally be different types, so that we can just call `task.close` and have it close whatever is needed for a restoring task, or suspended, etc. We could probably do some further cleanup, for example on close all tasks call `suspend` then `closeSuspended` but only active & running tasks are ever just suspended -- and we could probably also drop the double checkpointing (see[ KAFKA-9113](https://issues.apache.org/jira/browse/KAFKA-9113), and please feel free to dump any of your own thoughts around safer task management on there)",
        "createdAt" : "2019-10-31T22:22:50Z",
        "updatedAt" : "2019-10-31T22:25:08Z",
        "lastEditedBy" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "tags" : [
        ]
      },
      {
        "id" : "52ce90f4-2132-4cf9-af7b-f167f9da9128",
        "parentId" : "2317b8ee-d5fb-4c56-b12c-7b6a0d92702e",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "I think I agree, but my confusion is that why we call close on created tasks? Basically the weird thing I noticed is that for closing as zombies:\r\n\r\n1. created : call `close`\r\n2. restoring : call `closeStateMgr`\r\n3. running : call `close`\r\n4. suspended : call `closeSuspended`\r\n\r\n3 and 4 makes sense to me, but 1/2 are a bit weird: for created tasks, we do not initialize topology nor state managers, but still we call `close`, whereas restoring ones (where we initialized state manager but not topology) we call `closeStateMgr`.\r\n\r\nDid a closer look at the code base, I think the reason is that in `closeNonRunningTasks` (which is triggered in `onPartitionsRevoked`) we actually trigger the following:\r\n\r\n```\r\ntask.close(false /* clean */, false /* isZombie */)\r\n```\r\n\r\nI.e. we treat it as an \"unclean\" close, and hence we won't write checkpoint, and most importantly, when `closeTopology` throws (which would be the case since it is not initialized at all) we would just ignore it. So \"accidentally\" this becomes correct.\r\n\r\nThis is not a great pattern, and I like @ableegoldman 's suggestion that we should consider making \"close\" call to be more robust in a follow-up PR, for now let's stay with what it is then.",
        "createdAt" : "2019-10-31T23:22:12Z",
        "updatedAt" : "2019-10-31T23:22:13Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "ecd1f716-1dbd-41b1-9124-5e9821d4bde3",
        "parentId" : "2317b8ee-d5fb-4c56-b12c-7b6a0d92702e",
        "authorId" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "body" : "It's good to reveal these error-prone close call setups here. My take is that each function starting with `close` should be distinguished clearly in function comment what it tries to do. And we should avoid including > 1 boolean variables, as it's hard to reason about. What about cleanClose() and uncleanClose()? Also should we be more specific about word `zombie`? This seems to be a really vague term too.",
        "createdAt" : "2019-10-31T23:33:18Z",
        "updatedAt" : "2019-10-31T23:33:18Z",
        "lastEditedBy" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "tags" : [
        ]
      },
      {
        "id" : "1a9b5aab-7156-49cd-ab5f-3da6887b340f",
        "parentId" : "2317b8ee-d5fb-4c56-b12c-7b6a0d92702e",
        "authorId" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "body" : "I think (and hope) the term `zombie` is not used in an unclear way -- but there might be some confusion in the translation from \"clients-speak\" to \"streams-speak\" since what the clients simply call \"lost\" we call \"zombie task\". Some other examples along that line are the confusion about what revoked means -- sometimes its the partitions given up temporarily, sometimes only the partitions that are being reassigned and permanently given up.\r\n\r\nBut clear code can always help with unclear terminology: as an example of some progress, we used to have both \"suspended\" and \"zombie\" standbys, neither of which **really** makes sense for a standby. We cleaned up that code in some recent PRs so that, I feel, is now quite clear\r\n\r\n@abbccdda I also like the idea of `cleanClose`, `unCleanClose`, where each specific task can make it clear what it needs to do in each case. A nice side-effect there is we can clearly comment what clean (or unclean) means at the top of each method, rather than try to interpret every brief parameter description",
        "createdAt" : "2019-11-01T00:13:11Z",
        "updatedAt" : "2019-11-01T00:13:11Z",
        "lastEditedBy" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "tags" : [
        ]
      }
    ],
    "commit" : "9ab8b46b3b73552b03e3553d9185005448a313b2",
    "line" : 51,
    "diffHunk" : "@@ -1,1 +551,555 @@            public void additionalSetup(final StreamTask task) {\n                EasyMock.expect(task.partitions()).andReturn(Collections.emptySet()).anyTimes();\n                task.closeStateManager(false);\n            }\n"
  }
]
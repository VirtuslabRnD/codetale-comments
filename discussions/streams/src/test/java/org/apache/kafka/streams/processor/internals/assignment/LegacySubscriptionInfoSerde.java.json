[
  {
    "id" : "486113c3-a64c-4bfe-add6-794923099580",
    "prId" : 7248,
    "prUrl" : "https://github.com/apache/kafka/pull/7248#pullrequestreview-308645130",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7265b1db-e904-40d7-954a-3db7e957f4a6",
        "parentId" : null,
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "This class is a copy of the old `SubscriptionInfoSerde`, moved to the `test` artifact, so that we can verify that the new generated code and the old hand-coded serialization logic are mutually intelligible (i.e., they produce the same binary format). I _feel_ like this is necessary, since any change to the code generator could break message compatibility in the rolling-upgrade case. But maybe the system tests are sufficient to catch such a regression, in which case, we can ditch these 300 LOC.\r\n\r\nWDYT?",
        "createdAt" : "2019-08-23T23:53:29Z",
        "updatedAt" : "2019-10-29T21:04:35Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      },
      {
        "id" : "e5ec8b58-0d3f-4841-892a-7f7193ff2e4f",
        "parentId" : "7265b1db-e904-40d7-954a-3db7e957f4a6",
        "authorId" : "4c968502-bb3d-46ee-8719-0c0bdbc6242f",
        "body" : "Seems ok to me. plus an the additional check is a good idea. ",
        "createdAt" : "2019-10-24T17:30:46Z",
        "updatedAt" : "2019-10-29T21:04:35Z",
        "lastEditedBy" : "4c968502-bb3d-46ee-8719-0c0bdbc6242f",
        "tags" : [
        ]
      },
      {
        "id" : "e642ec3d-11c7-40ff-ad32-c2d32e984b40",
        "parentId" : "7265b1db-e904-40d7-954a-3db7e957f4a6",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "Hmm, for message protocol refactoring we do not keep old code to make sure it is consistent with hand-written code, instead we have the coverage in `RequestResponseTest` and `MessageTest`. I felt that keeping the old code (if forever) sort of defeat the purpose of this this refactoring right?",
        "createdAt" : "2019-10-29T02:24:28Z",
        "updatedAt" : "2019-10-29T21:04:35Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "a80de089-2140-41d0-8125-cc08230dc833",
        "parentId" : "7265b1db-e904-40d7-954a-3db7e957f4a6",
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "I took a look at those tests. It looks like they are verifying that they can round-trip the serialization and deserialization of the request/response/message classes, but this would not ensure that the binary format is unchanged from the hand-written code.\r\n\r\nI was most concerned that the auto-generated code would serialize the data slightly differently than we previously did, but I think I'm satisfied now. I've gone over the binary serialization logic several times, and it looks like it would produce the same result. Also, the fact that the system tests pass is a strong indicator that the binary format is compatible with prior versions.\r\n\r\nPlus, having written and run the unit tests against this Legacy serde once is probably sufficient. If we leave it here, we would basically never again touch this class or any of the tests that use it. If nothing changes in the codegen, then this test should never fail.\r\n\r\nI guess my dilemma is that this cuts both ways: I don't think this test defeats the purpose of the refactoring, since after version 5, all future modifications to the protocol would be via the json file only, never touching this class again. It would just sit here, making sure no one gets the crazy idea to change the order of the fields in our message spec, or change the way the codegen serializes data. A safety net. On the other hand, this verification is almost certainly not necessary, and we could just shed the mental weight of having this code and remembering what it's for.\r\n\r\nWhere does this net out for you?",
        "createdAt" : "2019-10-29T16:14:59Z",
        "updatedAt" : "2019-10-29T21:04:35Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      }
    ],
    "commit" : "e4d6ae101dee1bb04c4a267771e3f9ac6ec347eb",
    "line" : 31,
    "diffHunk" : "@@ -1,1 +29,33 @@import java.util.UUID;\n\npublic class LegacySubscriptionInfoSerde {\n\n    private static final Logger log = LoggerFactory.getLogger(LegacySubscriptionInfoSerde.class);"
  },
  {
    "id" : "00291821-ad76-4000-873f-3349bed155d5",
    "prId" : 7248,
    "prUrl" : "https://github.com/apache/kafka/pull/7248#pullrequestreview-310115132",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a833fee9-72f9-4f2d-b518-8035f9fbe116",
        "parentId" : null,
        "authorId" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "body" : "nit: format should align with L125",
        "createdAt" : "2019-10-31T18:08:04Z",
        "updatedAt" : "2019-10-31T18:09:37Z",
        "lastEditedBy" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "tags" : [
        ]
      },
      {
        "id" : "2f95f105-2526-4d1a-b757-34eb91e43d22",
        "parentId" : "a833fee9-72f9-4f2d-b518-8035f9fbe116",
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "This is the way IDEA formats multiline mathematical expressions.",
        "createdAt" : "2019-10-31T18:59:50Z",
        "updatedAt" : "2019-10-31T18:59:50Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      }
    ],
    "commit" : "e4d6ae101dee1bb04c4a267771e3f9ac6ec347eb",
    "line" : 124,
    "diffHunk" : "@@ -1,1 +122,126 @@\n            final ByteBuffer buf = ByteBuffer.allocate(\n                4 + // version\n                    16 + // client ID\n                    4 + prevTasks.size() * 8 + // length + prev tasks"
  },
  {
    "id" : "03cb7aaf-b63c-4e5b-9f46-3893c662b626",
    "prId" : 7248,
    "prUrl" : "https://github.com/apache/kafka/pull/7248#pullrequestreview-310116777",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "dc730cbd-30e1-47f5-8121-b263979b7c8a",
        "parentId" : null,
        "authorId" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "body" : "Do you think a switch block is easier to interpret?",
        "createdAt" : "2019-10-31T18:09:32Z",
        "updatedAt" : "2019-10-31T18:09:37Z",
        "lastEditedBy" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "tags" : [
        ]
      },
      {
        "id" : "0d2273b5-a9e7-49c5-a23a-02c62ccf4165",
        "parentId" : "dc730cbd-30e1-47f5-8121-b263979b7c8a",
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "Maybe? I don't know how to determine an answer to this question.\r\n\r\nIf you like, I can change it to a switch block in a later PR, but I'm reluctant to roll the dice _again_ on the integration tests if there is no other feedback requiring changes.",
        "createdAt" : "2019-10-31T19:02:39Z",
        "updatedAt" : "2019-10-31T19:02:39Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      }
    ],
    "commit" : "e4d6ae101dee1bb04c4a267771e3f9ac6ec347eb",
    "line" : 198,
    "diffHunk" : "@@ -1,1 +196,200 @@\n        final int usedVersion = data.getInt();\n        if (usedVersion == 4 || usedVersion == 3) {\n            final int latestSupportedVersion = data.getInt();\n            final UUID processId = decodeProcessId(data);"
  }
]
[
  {
    "id" : "47e3f99d-f1fb-4e3d-8cef-2e5e50331ed0",
    "prId" : 4832,
    "prUrl" : "https://github.com/apache/kafka/pull/4832#pullrequestreview-110578982",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "42bacfbd-cddb-44b0-be76-e21eb0878843",
        "parentId" : null,
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "Might be simpler to call `recordFactory.advanceTimeMs()` and not specify the timestamp for each record explicitly? We also leave it as is.",
        "createdAt" : "2018-04-08T01:44:17Z",
        "updatedAt" : "2018-04-26T11:00:17Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "cac41a99-7b59-4a60-83f5-271a32e1974c",
        "parentId" : "42bacfbd-cddb-44b0-be76-e21eb0878843",
        "authorId" : "796fe0a1-c8b6-4b8f-a416-408b76bf799e",
        "body" : "Because in the remaining tests in this class we are also passing the timestamp, I'd like to keep it coherent and use the same here. But I can change it if you see advantages in calling `recordFactory.advanceTimeMs()`",
        "createdAt" : "2018-04-09T14:52:53Z",
        "updatedAt" : "2018-04-26T11:00:17Z",
        "lastEditedBy" : "796fe0a1-c8b6-4b8f-a416-408b76bf799e",
        "tags" : [
        ]
      },
      {
        "id" : "e40aa00c-1009-4432-91cf-630040e5e138",
        "parentId" : "42bacfbd-cddb-44b0-be76-e21eb0878843",
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "Ack. Fine to leave as is -- was just a thought.",
        "createdAt" : "2018-04-09T19:06:52Z",
        "updatedAt" : "2018-04-26T11:00:18Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      }
    ],
    "commit" : "bc5df4c3ba297c3fe2933b2adcb7ee623da698b3",
    "line" : 248,
    "diffHunk" : "@@ -1,1 +673,677 @@        driver.pipeInput(recordFactory.create(TOPIC, \"2\", \"B\", 0));\n        driver.pipeInput(recordFactory.create(TOPIC, \"3\", \"C\", 0));\n        driver.pipeInput(recordFactory.create(TOPIC, \"1\", \"A\", 500));\n        driver.pipeInput(recordFactory.create(TOPIC, \"1\", \"A\", 500));\n        driver.pipeInput(recordFactory.create(TOPIC, \"2\", \"B\", 500));"
  },
  {
    "id" : "28472d43-0c05-4d04-8225-87ab0abcc498",
    "prId" : 4832,
    "prUrl" : "https://github.com/apache/kafka/pull/4832#pullrequestreview-115690115",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5c137c05-653e-40cc-9c0d-83cd7c988384",
        "parentId" : null,
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "Please see my earlier comment about `mkProperties`",
        "createdAt" : "2018-04-26T18:27:19Z",
        "updatedAt" : "2018-04-26T19:12:58Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      }
    ],
    "commit" : "bc5df4c3ba297c3fe2933b2adcb7ee623da698b3",
    "line" : 58,
    "diffHunk" : "@@ -1,1 +91,95 @@        props.setProperty(StreamsConfig.STATE_DIR_CONFIG, TestUtils.tempDirectory().getAbsolutePath());\n        props.setProperty(StreamsConfig.DEFAULT_KEY_SERDE_CLASS_CONFIG, Serdes.String().getClass().getName());\n        props.setProperty(StreamsConfig.DEFAULT_VALUE_SERDE_CLASS_CONFIG, Serdes.String().getClass().getName());\n    }\n"
  },
  {
    "id" : "63de7a71-1781-4d9c-9a46-9e7687bc0a1e",
    "prId" : 4832,
    "prUrl" : "https://github.com/apache/kafka/pull/4832#pullrequestreview-115690115",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "578f0372-0030-4be8-8e21-51474714a956",
        "parentId" : null,
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "Please see my earlier comment about making driver local.\r\n\r\nAlso, it seems a bit silly to set all the same properties before every test and remove them all after every test, only to set them again.\r\n\r\nYou could really simplify the test logic by getting rid of both `Before` and `After` and moving all the logic to the field declaration or to local variables as appropriate.",
        "createdAt" : "2018-04-26T18:30:45Z",
        "updatedAt" : "2018-04-26T19:12:58Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      }
    ],
    "commit" : "bc5df4c3ba297c3fe2933b2adcb7ee623da698b3",
    "line" : 67,
    "diffHunk" : "@@ -1,1 +100,104 @@            driver.close();\n        }\n        driver = null;\n    }\n"
  },
  {
    "id" : "79748890-3f28-40e5-b397-75ab76e04e31",
    "prId" : 4832,
    "prUrl" : "https://github.com/apache/kafka/pull/4832#pullrequestreview-115895562",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a6b31e76-e05e-4e86-9448-fb38e02fc117",
        "parentId" : null,
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "I love how much tidier this is now. Thanks for doing this!",
        "createdAt" : "2018-04-26T18:32:38Z",
        "updatedAt" : "2018-04-26T19:12:58Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      },
      {
        "id" : "aa4fe23a-30fa-407d-81ec-78e6eda03a1d",
        "parentId" : "a6b31e76-e05e-4e86-9448-fb38e02fc117",
        "authorId" : "796fe0a1-c8b6-4b8f-a416-408b76bf799e",
        "body" : "Yep, the new TopologyTestDriver is really slick!",
        "createdAt" : "2018-04-27T10:49:17Z",
        "updatedAt" : "2018-04-27T10:49:17Z",
        "lastEditedBy" : "796fe0a1-c8b6-4b8f-a416-408b76bf799e",
        "tags" : [
        ]
      }
    ],
    "commit" : "bc5df4c3ba297c3fe2933b2adcb7ee623da698b3",
    "line" : 161,
    "diffHunk" : "@@ -1,1 +557,561 @@        processData();\n\n        final KeyValueStore<String, Long> count = driver.getKeyValueStore(\"count\");\n\n        assertThat(count.get(\"1\"), equalTo(3L));"
  },
  {
    "id" : "46a9ecca-5089-4dbb-abba-89a7eddc0644",
    "prId" : 6645,
    "prUrl" : "https://github.com/apache/kafka/pull/6645#pullrequestreview-236376474",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2f571bf4-f103-42b7-bc93-70ded64b9c26",
        "parentId" : null,
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "Some test cleanup to get rid or `ResultCollector` processor but reuse `MockProcessor` instead",
        "createdAt" : "2019-05-11T13:00:52Z",
        "updatedAt" : "2019-05-12T13:26:58Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      }
    ],
    "commit" : "43873294c59da42142246aa9c261e0f903f0f3d4",
    "line" : 17,
    "diffHunk" : "@@ -1,1 +156,160 @@    }\n\n    private void doAggregateSessionWindows(final MockProcessorSupplier<Windowed<String>, Integer> supplier) {\n        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n            driver.pipeInput(recordFactory.create(TOPIC, \"1\", \"1\", 10));"
  },
  {
    "id" : "621ff6b8-44d9-4ee7-affe-ae0c96c932c5",
    "prId" : 9239,
    "prUrl" : "https://github.com/apache/kafka/pull/9239#pullrequestreview-486447426",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d91fc723-6661-43bb-952e-c341730ce885",
        "parentId" : null,
        "authorId" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "body" : "Why this change?",
        "createdAt" : "2020-09-09T00:20:49Z",
        "updatedAt" : "2020-09-11T18:08:57Z",
        "lastEditedBy" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "tags" : [
        ]
      },
      {
        "id" : "985082ad-e644-4b9c-98e0-e6ecb477eaf8",
        "parentId" : "d91fc723-6661-43bb-952e-c341730ce885",
        "authorId" : "114424ac-2f76-47ba-b653-f85692b08607",
        "body" : "Because we're outputting all the intermediate data, the order of the internal windows aren't the same when you use the reverse iterator versus the in-order iterator. This is mainly an issue for large tests, but when there are a lot of windows to update as a new record comes in, the reverse iterator looks at them from largest start time to smallest start time, and the in-order iterator looks at them from smallest start time to largest start time. I suppose we could alter the algorithm to output results differently, but getting a different order didn't seem too harmful for users. WDYT?",
        "createdAt" : "2020-09-09T13:45:51Z",
        "updatedAt" : "2020-09-11T18:08:57Z",
        "lastEditedBy" : "114424ac-2f76-47ba-b653-f85692b08607",
        "tags" : [
        ]
      },
      {
        "id" : "f205d03e-a378-4632-8dc8-972853a14280",
        "parentId" : "d91fc723-6661-43bb-952e-c341730ce885",
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "FWIW, I agree. The result of this aggregation is a KTable, i.e., a changelog stream. The semantics of the changelog stream only state that each record represents the latest state for that record's key. Just like the caches are free to drop arbitrary intermediate updates and KIP-557 is free to drop arbitrary idempotent updates, a processor that forwards updates for multiple different keys should be free to do it in any order.\r\n\r\nIn fact, I might go so far as to suggest that a proper behavioral test would load all the results into a map so that the test isn't sensitive to meaningless changes like this. But I won't go quite that far because it seems good to to have the opportunity to ask questions like @ableegoldman's. Just to be sure nothing unexpected is happening when we change things later.\r\n\r\nI also think it's better for performance not to try and buffer the window results and emit them in \"forward\" order, since it might be an arbitrarily large number of updates for us to keep in memory.",
        "createdAt" : "2020-09-11T02:36:52Z",
        "updatedAt" : "2020-09-11T18:08:57Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      },
      {
        "id" : "83c6f067-4362-4085-ad7e-c9f113df1ef4",
        "parentId" : "d91fc723-6661-43bb-952e-c341730ce885",
        "authorId" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "body" : "Sorry, I realize I never replied to your reply. I definitely agree, no need to force a particular inter-key ordering. The only ordering that would change is the updates to windows of different start times, which was arbitrary to begin with. The ordering that does matter -- intra-key ordering, ie updates with the same key and window start time -- isn't affected. Final results still come last, which is the important thing",
        "createdAt" : "2020-09-11T03:22:47Z",
        "updatedAt" : "2020-09-11T18:08:57Z",
        "lastEditedBy" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "tags" : [
        ]
      }
    ],
    "commit" : "12a2c7aeed1bbe9f7d2ba51206f85f22c3587c7a",
    "line" : 60,
    "diffHunk" : "@@ -1,1 +243,247 @@        }\n\n        final Comparator<KeyValueTimestamp<Windowed<String>, Long>> comparator =\n            Comparator.comparing((KeyValueTimestamp<Windowed<String>, Long> o) -> o.key().key())\n                .thenComparing((KeyValueTimestamp<Windowed<String>, Long> o) -> o.key().window().start());"
  }
]
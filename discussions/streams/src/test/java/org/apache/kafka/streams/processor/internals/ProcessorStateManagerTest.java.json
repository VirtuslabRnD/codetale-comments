[
  {
    "id" : "ec275f85-69b8-44a3-8d72-8ef1847322d3",
    "prId" : 6555,
    "prUrl" : "https://github.com/apache/kafka/pull/6555#pullrequestreview-224612009",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "feaf3ffd-81eb-4c47-b0ce-642f9e40d1c0",
        "parentId" : null,
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "Here's the regression test for my code change. Previously, we would flush the stores in registration order, but now we do it in topological order (defined on L346).",
        "createdAt" : "2019-04-09T19:44:43Z",
        "updatedAt" : "2019-04-22T19:13:13Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      }
    ],
    "commit" : "c9567b1ef225409db812fc48a6c64574a5f16f11",
    "line" : 123,
    "diffHunk" : "@@ -1,1 +362,366 @@\n        // make sure that flush is called in the proper order\n        assertThat(persistentStore.getLastFlushCount(), Matchers.lessThan(nonPersistentStore.getLastFlushCount()));\n\n        // the checkpoint file should contain an offset from the persistent store only."
  },
  {
    "id" : "2a53b54f-b0b1-4ec7-a799-8a9266c582d2",
    "prId" : 6555,
    "prUrl" : "https://github.com/apache/kafka/pull/6555#pullrequestreview-224612009",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "97948c74-0092-491f-a4c6-3f0f3569e349",
        "parentId" : null,
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "I had to move a couple of these so that I could list the store names in the topological order (I.e., I have to generate the names before I can list them).",
        "createdAt" : "2019-04-09T19:46:36Z",
        "updatedAt" : "2019-04-22T19:13:13Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      }
    ],
    "commit" : "c9567b1ef225409db812fc48a6c64574a5f16f11",
    "line" : 363,
    "diffHunk" : "@@ -1,1 +695,699 @@            false,\n            logContext);\n\n        stateManager.register(stateStore1, stateStore1.stateRestoreCallback);\n        stateManager.register(stateStore2, stateStore2.stateRestoreCallback);"
  }
]
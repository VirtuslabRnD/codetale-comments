[
  {
    "id" : "ec275f85-69b8-44a3-8d72-8ef1847322d3",
    "prId" : 6555,
    "prUrl" : "https://github.com/apache/kafka/pull/6555#pullrequestreview-224612009",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "feaf3ffd-81eb-4c47-b0ce-642f9e40d1c0",
        "parentId" : null,
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "Here's the regression test for my code change. Previously, we would flush the stores in registration order, but now we do it in topological order (defined on L346).",
        "createdAt" : "2019-04-09T19:44:43Z",
        "updatedAt" : "2019-04-22T19:13:13Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      }
    ],
    "commit" : "c9567b1ef225409db812fc48a6c64574a5f16f11",
    "line" : 123,
    "diffHunk" : "@@ -1,1 +362,366 @@\n        // make sure that flush is called in the proper order\n        assertThat(persistentStore.getLastFlushCount(), Matchers.lessThan(nonPersistentStore.getLastFlushCount()));\n\n        // the checkpoint file should contain an offset from the persistent store only."
  },
  {
    "id" : "2a53b54f-b0b1-4ec7-a799-8a9266c582d2",
    "prId" : 6555,
    "prUrl" : "https://github.com/apache/kafka/pull/6555#pullrequestreview-224612009",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "97948c74-0092-491f-a4c6-3f0f3569e349",
        "parentId" : null,
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "I had to move a couple of these so that I could list the store names in the topological order (I.e., I have to generate the names before I can list them).",
        "createdAt" : "2019-04-09T19:46:36Z",
        "updatedAt" : "2019-04-22T19:13:13Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      }
    ],
    "commit" : "c9567b1ef225409db812fc48a6c64574a5f16f11",
    "line" : 363,
    "diffHunk" : "@@ -1,1 +695,699 @@            false,\n            logContext);\n\n        stateManager.register(stateStore1, stateStore1.stateRestoreCallback);\n        stateManager.register(stateStore2, stateStore2.stateRestoreCallback);"
  },
  {
    "id" : "3a1d5bf3-b0f0-4ebf-904b-622f5686c7ea",
    "prId" : 7030,
    "prUrl" : "https://github.com/apache/kafka/pull/7030#pullrequestreview-257732570",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1e59ac75-53fa-4931-96ef-c92febf4446a",
        "parentId" : null,
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "renamed for clarity.",
        "createdAt" : "2019-07-03T22:10:07Z",
        "updatedAt" : "2019-07-09T23:16:30Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      }
    ],
    "commit" : "7b33b85c4fa71ed08802599697404720a66d88ef",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +241,245 @@    public void testChangeLogOffsets() throws IOException {\n        final TaskId taskId = new TaskId(0, 0);\n        final long storeTopic1LoadedCheckpoint = 10L;\n        final String storeName1 = \"store1\";\n        final String storeName2 = \"store2\";"
  },
  {
    "id" : "9d69fe4e-6b40-4f62-90fd-30bc2e896dea",
    "prId" : 7030,
    "prUrl" : "https://github.com/apache/kafka/pull/7030#pullrequestreview-257732570",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9152649c-1506-4a11-950c-5dc1da4211b5",
        "parentId" : null,
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "Note: this particular test verifies that the bug is fixed.",
        "createdAt" : "2019-07-03T22:12:34Z",
        "updatedAt" : "2019-07-09T23:16:30Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      }
    ],
    "commit" : "7b33b85c4fa71ed08802599697404720a66d88ef",
    "line" : 108,
    "diffHunk" : "@@ -1,1 +497,501 @@\n    @Test\n    public void shouldIgnoreIrrelevantRestoredCheckpoints() throws IOException {\n        final Map<TopicPartition, Long> offsets = singletonMap(persistentStorePartition, 99L);\n        checkpoint.write(offsets);"
  },
  {
    "id" : "3d3e05b4-8968-4f15-a09e-e5a20429cbc9",
    "prId" : 8964,
    "prUrl" : "https://github.com/apache/kafka/pull/8964#pullrequestreview-463655384",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4ba5f2c9-9eab-4b82-a2ad-ef0d3b610fdf",
        "parentId" : null,
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "Should we add a test for EOS, that the checkpoint file is deleted?",
        "createdAt" : "2020-08-07T21:51:06Z",
        "updatedAt" : "2020-08-11T21:25:16Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      }
    ],
    "commit" : "a4f2272986357de9c48032d1fd0d9b1482d5a974",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +413,417 @@            stateMgr.initializeStoreOffsetsFromCheckpoint(true);\n\n            assertTrue(checkpointFile.exists());\n            assertEquals(mkSet(\n                persistentStorePartition,"
  },
  {
    "id" : "71a94210-0647-4215-a124-0f96c0d28175",
    "prId" : 8996,
    "prUrl" : "https://github.com/apache/kafka/pull/8996#pullrequestreview-445818246",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "71da685d-d976-43b0-818d-ae79cbe9b4bb",
        "parentId" : null,
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "Not sure if I understand the test: don't we write a checkpoint in L795 for the persistent store?",
        "createdAt" : "2020-07-09T00:47:55Z",
        "updatedAt" : "2020-07-09T17:32:39Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "a4b16f7e-d703-4db9-a3ea-85e7e16e3c1a",
        "parentId" : "71da685d-d976-43b0-818d-ae79cbe9b4bb",
        "authorId" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "body" : "Yeah, I think that's the point of the test: we wrote a checkpoint but it was missing the offset for one of the persistent stores, thus, we should throw a TaskCorruptedException  in `initializeStoreOffsetsFromCheckpoint`",
        "createdAt" : "2020-07-09T02:05:51Z",
        "updatedAt" : "2020-07-09T17:32:39Z",
        "lastEditedBy" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "tags" : [
        ]
      },
      {
        "id" : "f25b9c17-613f-4236-baf0-a50a460358e4",
        "parentId" : "71da685d-d976-43b0-818d-ae79cbe9b4bb",
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "Not clear from the context of the code snipped (maybe need to go back to IntelliJ and read the full test setup) that there are multiple partitions. Also wondering why we include `nonPersistentStorePartition` and `irrelevantPartition`? How do we ensure that those don't case the `TaskCorruptedException`?",
        "createdAt" : "2020-07-09T02:27:59Z",
        "updatedAt" : "2020-07-09T17:32:39Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "482d2d1c-6b77-487e-8c8e-29b21c67b4ca",
        "parentId" : "71da685d-d976-43b0-818d-ae79cbe9b4bb",
        "authorId" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "body" : "Sorry yeah the relevant part doesn't show up on github. Basically we register\r\n```  \r\nstateMgr.registerStore(persistentStore, persistentStore.stateRestoreCallback);\t            \r\nstateMgr.registerStore(persistentStoreTwo, persistentStoreTwo.stateRestoreCallback);\t            \r\nstateMgr.registerStore(nonPersistentStore, nonPersistentStore.stateRestoreCallback);\r\n```\r\n\r\nbut only write the checkpoint for the `persistentStorePartition`, `nonPersistentStorePartition` and `irrelevantPartition` . I think the point of the `irrelevantPartition` is to make sure that we detect that the `persistentStoreTwoPartition` offset is missing even though the checkpoint technically has the correct number of offsets in total. ie, that we actually map the offsets to a registered changelog",
        "createdAt" : "2020-07-09T17:19:14Z",
        "updatedAt" : "2020-07-09T17:42:19Z",
        "lastEditedBy" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "tags" : [
        ]
      }
    ],
    "commit" : "6f6db6d6dea1a2164ee59895e46ccc268e6a477d",
    "line" : 34,
    "diffHunk" : "@@ -1,1 +788,792 @@        final long checkpointOffset = 10L;\n\n        final Map<TopicPartition, Long> offsets = mkMap(\n            mkEntry(persistentStorePartition, checkpointOffset),\n            mkEntry(nonPersistentStorePartition, checkpointOffset),"
  }
]
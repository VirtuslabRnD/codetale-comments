[
  {
    "id" : "ec275f85-69b8-44a3-8d72-8ef1847322d3",
    "prId" : 6555,
    "prUrl" : "https://github.com/apache/kafka/pull/6555#pullrequestreview-224612009",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "feaf3ffd-81eb-4c47-b0ce-642f9e40d1c0",
        "parentId" : null,
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "Here's the regression test for my code change. Previously, we would flush the stores in registration order, but now we do it in topological order (defined on L346).",
        "createdAt" : "2019-04-09T19:44:43Z",
        "updatedAt" : "2019-04-22T19:13:13Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      }
    ],
    "commit" : "c9567b1ef225409db812fc48a6c64574a5f16f11",
    "line" : 123,
    "diffHunk" : "@@ -1,1 +362,366 @@\n        // make sure that flush is called in the proper order\n        assertThat(persistentStore.getLastFlushCount(), Matchers.lessThan(nonPersistentStore.getLastFlushCount()));\n\n        // the checkpoint file should contain an offset from the persistent store only."
  },
  {
    "id" : "2a53b54f-b0b1-4ec7-a799-8a9266c582d2",
    "prId" : 6555,
    "prUrl" : "https://github.com/apache/kafka/pull/6555#pullrequestreview-224612009",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "97948c74-0092-491f-a4c6-3f0f3569e349",
        "parentId" : null,
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "I had to move a couple of these so that I could list the store names in the topological order (I.e., I have to generate the names before I can list them).",
        "createdAt" : "2019-04-09T19:46:36Z",
        "updatedAt" : "2019-04-22T19:13:13Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      }
    ],
    "commit" : "c9567b1ef225409db812fc48a6c64574a5f16f11",
    "line" : 363,
    "diffHunk" : "@@ -1,1 +695,699 @@            false,\n            logContext);\n\n        stateManager.register(stateStore1, stateStore1.stateRestoreCallback);\n        stateManager.register(stateStore2, stateStore2.stateRestoreCallback);"
  },
  {
    "id" : "3a1d5bf3-b0f0-4ebf-904b-622f5686c7ea",
    "prId" : 7030,
    "prUrl" : "https://github.com/apache/kafka/pull/7030#pullrequestreview-257732570",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1e59ac75-53fa-4931-96ef-c92febf4446a",
        "parentId" : null,
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "renamed for clarity.",
        "createdAt" : "2019-07-03T22:10:07Z",
        "updatedAt" : "2019-07-09T23:16:30Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      }
    ],
    "commit" : "7b33b85c4fa71ed08802599697404720a66d88ef",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +241,245 @@    public void testChangeLogOffsets() throws IOException {\n        final TaskId taskId = new TaskId(0, 0);\n        final long storeTopic1LoadedCheckpoint = 10L;\n        final String storeName1 = \"store1\";\n        final String storeName2 = \"store2\";"
  },
  {
    "id" : "9d69fe4e-6b40-4f62-90fd-30bc2e896dea",
    "prId" : 7030,
    "prUrl" : "https://github.com/apache/kafka/pull/7030#pullrequestreview-257732570",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9152649c-1506-4a11-950c-5dc1da4211b5",
        "parentId" : null,
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "Note: this particular test verifies that the bug is fixed.",
        "createdAt" : "2019-07-03T22:12:34Z",
        "updatedAt" : "2019-07-09T23:16:30Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      }
    ],
    "commit" : "7b33b85c4fa71ed08802599697404720a66d88ef",
    "line" : 108,
    "diffHunk" : "@@ -1,1 +497,501 @@\n    @Test\n    public void shouldIgnoreIrrelevantRestoredCheckpoints() throws IOException {\n        final Map<TopicPartition, Long> offsets = singletonMap(persistentStorePartition, 99L);\n        checkpoint.write(offsets);"
  }
]
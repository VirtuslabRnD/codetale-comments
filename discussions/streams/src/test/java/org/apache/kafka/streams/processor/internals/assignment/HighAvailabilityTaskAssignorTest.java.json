[
  {
    "id" : "70c39865-b827-452d-a299-1a291bb73289",
    "prId" : 8337,
    "prUrl" : "https://github.com/apache/kafka/pull/8337#pullrequestreview-384588987",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "42c9fe54-8e65-4219-86b1-52f302a1eefb",
        "parentId" : null,
        "authorId" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "body" : "req: Could you add a test for `buildClientRankingsByTask()` with an empty set of `statefulTasks`?",
        "createdAt" : "2020-03-31T15:10:31Z",
        "updatedAt" : "2020-04-01T19:33:13Z",
        "lastEditedBy" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "tags" : [
        ]
      }
    ],
    "commit" : "f473f60b99f3b3b2f549b5ae48b2be01fc5cf461",
    "line" : 230,
    "diffHunk" : "@@ -1,1 +228,232 @@        assertTrue(buildClientRankingsByTask(EMPTY_TASKS, states, acceptableRecoveryLag).isEmpty());\n    }\n\n    @Test\n    public void shouldGetMovementsFromStateConstrainedToBalancedAssignment() {"
  },
  {
    "id" : "e10060c2-333f-4bfb-b8db-7bb244f2c5fa",
    "prId" : 8337,
    "prUrl" : "https://github.com/apache/kafka/pull/8337#pullrequestreview-384588987",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b90a472a-5c78-4a5e-a840-a462fb734530",
        "parentId" : null,
        "authorId" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "body" : "req: Could you please add a test that passes two empty assignments to `getMovements()`.",
        "createdAt" : "2020-03-31T15:18:22Z",
        "updatedAt" : "2020-04-01T19:33:13Z",
        "lastEditedBy" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "tags" : [
        ]
      }
    ],
    "commit" : "f473f60b99f3b3b2f549b5ae48b2be01fc5cf461",
    "line" : 308,
    "diffHunk" : "@@ -1,1 +306,310 @@        assertThrows(IllegalStateException.class, () -> getMovements(stateConstrainedAssignment, balancedAssignment, maxWarmupReplicas));\n    }\n\n    @Test\n    public void shouldDecidePreviousAssignmentIsInvalidIfThereAreUnassignedActiveTasks() {"
  },
  {
    "id" : "dbe6d74e-2e8f-4747-afb4-7acef085cef6",
    "prId" : 8541,
    "prUrl" : "https://github.com/apache/kafka/pull/8541#pullrequestreview-399543456",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "40eff4ea-a636-459f-989e-c64fe796d90c",
        "parentId" : null,
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "I made a bunch of changes to this test, because it was pretty brittle with respect to changes in the HighAvailabilityTaskAssignor. For context, this is the second time I've touched the assignment code since we introduced the HATA, and it's the second time I've had to deal with irrelevant test failures in this class.\r\n\r\nFirst, I replaced the ClientState mocks with \"real\" ClientStates, constructed to represent the desired scenario for each test. Mocks are really more appropriate for isolating a component from _external_ components (like mocking a remote service). Mocking data types leads to verifying that a specific set of queries happens against the data type, which is likely to break any time the logic under test changes in any way. Another problem with data-type mocks is that they can violate the invariants of the data type itself. For example, you can mock a list that both `isEmpty` and contains items. In our case, we threw NPEs in the assignor that could never happen in production when the mocked assigned/standby tasks didn't agree with the assigned tasks or the stateful assigned tasks weren't mocked to agree with the lags. Now, we just construct a ClientState for each client, representing the desired scenario and make assertions on the resulting assignment.\r\n\r\nSecond, the tests as written rely heavily on shared mutable fields inserted into shared mutable collections to build the assignor. This can be a good way to minimize the text inside the test method, which lets readers focus on the proper logic of the test itself. However, it makes it harder to understand the full context of a test, and it also raises the possibility of tests polluting each others' environments. Since in this particular case, localizing all the setup code is about as compact as factoring it out, I went ahead and minimized the shared fields, and eliminated the mutability, the tests are self-contained.\r\n",
        "createdAt" : "2020-04-24T00:18:44Z",
        "updatedAt" : "2020-04-28T03:20:48Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      }
    ],
    "commit" : "d58f62dc73dc3f4832cb89b5be6a8c8ce2f32e60",
    "line" : 40,
    "diffHunk" : "@@ -1,1 +59,63 @@import static org.hamcrest.Matchers.not;\n\npublic class HighAvailabilityTaskAssignorTest {\n    private final AssignmentConfigs configWithoutStandbys = new AssignmentConfigs(\n        /*acceptableRecoveryLag*/ 100L,"
  },
  {
    "id" : "fe59934e-bad9-4abd-9052-7a088df05389",
    "prId" : 8541,
    "prUrl" : "https://github.com/apache/kafka/pull/8541#pullrequestreview-399543456",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6b656ec5-5d3c-4529-9fed-8620a4b6c633",
        "parentId" : null,
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "These first tests are really the only ones to change. They're still asserting the same basic fact, but `previousAssignmentIsValid` is now an internal method, so we instead make assertions about the black-box semantics of the assignor, instead of a specific \"visible for testing\" method.",
        "createdAt" : "2020-04-24T00:24:04Z",
        "updatedAt" : "2020-04-28T03:20:48Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      }
    ],
    "commit" : "d58f62dc73dc3f4832cb89b5be6a8c8ce2f32e60",
    "line" : 99,
    "diffHunk" : "@@ -1,1 +78,82 @@\n    @Test\n    public void shouldComputeNewAssignmentIfThereAreUnassignedActiveTasks() {\n        final Set<TaskId> allTasks = mkSet(TASK_0_0, TASK_0_1);\n        final ClientState client1 = new ClientState(singleton(TASK_0_0), emptySet(), singletonMap(TASK_0_0, 0L), 1);"
  },
  {
    "id" : "f2842551-da97-456f-bd04-aaa32205ef6d",
    "prId" : 8588,
    "prUrl" : "https://github.com/apache/kafka/pull/8588#pullrequestreview-408512587",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6f69c431-a246-41d9-b6c3-2d30f6f029f3",
        "parentId" : null,
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "And here they are! I adjusted the assertions to generally be less sensitive to the specific assignment, since my changes to the balance function had some trivial effects on the assignment, IIRC.",
        "createdAt" : "2020-05-08T22:59:18Z",
        "updatedAt" : "2020-05-14T01:51:44Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      }
    ],
    "commit" : "9cf8316444c205ea04f6fa0874619451f5b94d92",
    "line" : 41,
    "diffHunk" : "@@ -1,1 +79,83 @@\n    @Test\n    public void shouldAssignActiveStatefulTasksEvenlyOverClientsWhereNumberOfClientsIntegralDivisorOfNumberOfTasks() {\n        final Set<TaskId> allTaskIds = mkSet(TASK_0_0, TASK_0_1, TASK_0_2, TASK_1_0, TASK_1_1, TASK_1_2, TASK_2_0, TASK_2_1, TASK_2_2);\n        final Map<TaskId, Long> lags = allTaskIds.stream().collect(Collectors.toMap(k -> k, k -> 10L));"
  },
  {
    "id" : "2a13a55a-7b17-4710-a85d-7bae6541927d",
    "prId" : 8689,
    "prUrl" : "https://github.com/apache/kafka/pull/8689#pullrequestreview-414529204",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8869d217-2986-4e2f-9032-114de48429f4",
        "parentId" : null,
        "authorId" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "body" : "This name seemed not correct.",
        "createdAt" : "2020-05-18T22:23:32Z",
        "updatedAt" : "2020-05-19T15:53:01Z",
        "lastEditedBy" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "tags" : [
        ]
      },
      {
        "id" : "b60d5567-0a3e-4081-8526-1af95c05af8a",
        "parentId" : "8869d217-2986-4e2f-9032-114de48429f4",
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "Huh, good catch!",
        "createdAt" : "2020-05-19T14:51:55Z",
        "updatedAt" : "2020-05-19T15:53:01Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      }
    ],
    "commit" : "13557fd371589b97ee40f8f957f5192054559671",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +172,176 @@\n    @Test\n    public void shouldAssignActiveStatefulTasksEvenlyOverClientsWithMoreClientsThanTasks() {\n        final Set<TaskId> allTaskIds = mkSet(TASK_0_0, TASK_0_1);\n        final Map<TaskId, Long> lags = allTaskIds.stream().collect(Collectors.toMap(k -> k, k -> 10L));"
  },
  {
    "id" : "69e25f8f-3bdf-4217-b905-e9341832c21e",
    "prId" : 8696,
    "prUrl" : "https://github.com/apache/kafka/pull/8696#pullrequestreview-414836508",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8c3f7fd0-b9a7-4afa-974e-74058dd831ed",
        "parentId" : null,
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "First test for stickiness: we should be 100% sticky and also not schedule a probing rebalance when we are configured for no warmups.",
        "createdAt" : "2020-05-19T21:37:56Z",
        "updatedAt" : "2020-05-19T21:40:20Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      }
    ],
    "commit" : "d85c12b3089132a8952c8c4cbebaf44e1836fd3f",
    "line" : 21,
    "diffHunk" : "@@ -1,1 +82,86 @@\n    @Test\n    public void shouldBeStickyForActiveAndStandbyTasksEvenIfNoWarmups() {\n        final Set<TaskId> allTaskIds = mkSet(TASK_0_0, TASK_0_1, TASK_0_2, TASK_1_0, TASK_1_1, TASK_1_2, TASK_2_0, TASK_2_1, TASK_2_2);\n        final ClientState clientState1 = new ClientState(allTaskIds, emptySet(), allTaskIds.stream().collect(Collectors.toMap(k -> k, k -> 0L)), 1);"
  },
  {
    "id" : "3fa22ab7-c1c0-4c1d-b237-76b65959baf3",
    "prId" : 8696,
    "prUrl" : "https://github.com/apache/kafka/pull/8696#pullrequestreview-414836508",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d006f569-ca1d-41ca-ae13-5dd566cbfd31",
        "parentId" : null,
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "Main test case for stickiness: we should be sticky for standbys, and also schedule warmups.",
        "createdAt" : "2020-05-19T21:38:43Z",
        "updatedAt" : "2020-05-19T21:40:20Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      }
    ],
    "commit" : "d85c12b3089132a8952c8c4cbebaf44e1836fd3f",
    "line" : 50,
    "diffHunk" : "@@ -1,1 +111,115 @@\n    @Test\n    public void shouldBeStickyForActiveAndStandbyTasksWhileWarmingUp() {\n        final Set<TaskId> allTaskIds = mkSet(TASK_0_0, TASK_0_1, TASK_0_2, TASK_1_0, TASK_1_1, TASK_1_2, TASK_2_0, TASK_2_1, TASK_2_2);\n        final ClientState clientState1 = new ClientState(allTaskIds, emptySet(), allTaskIds.stream().collect(Collectors.toMap(k -> k, k -> 0L)), 1);"
  }
]
[
  {
    "id" : "c33594b3-ff42-4565-b0f2-296630340349",
    "prId" : 5710,
    "prUrl" : "https://github.com/apache/kafka/pull/5710#pullrequestreview-160066113",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8560cfc9-18de-4b9c-85bc-5d098fa208ca",
        "parentId" : null,
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "I'm not sure what this test was previously checking for. It looks like it wanted to try updating without previously initializing the task.\r\n\r\nThis was previously throwing an NPE wrapped in a ProcessorStateException when the adapted callback actually tried to dereference the (null) wrapped callback.\r\n\r\nNow, the NPE is surfaced a little earlier, not guarded by the ProcessorStateException try/catch.\r\n\r\nI think this is still ok, so I've just refined the test to be more specific.",
        "createdAt" : "2018-09-29T01:50:08Z",
        "updatedAt" : "2018-09-29T02:36:52Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      },
      {
        "id" : "ff0cb6b0-aeff-4616-8223-403ef3b0641b",
        "parentId" : "8560cfc9-18de-4b9c-85bc-5d098fa208ca",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "This test case is added in the first commit of this test file, and after reading it I agree with you that the original name `testUpdateNonPersistentStore` seems make less sense, and rather `testUpdateNonInitializedStore` is better.",
        "createdAt" : "2018-09-29T04:22:10Z",
        "updatedAt" : "2018-09-29T04:22:11Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      }
    ],
    "commit" : "bb44b1306c0fb643cc1df100c6fbea5427706d28",
    "line" : 31,
    "diffHunk" : "@@ -1,1 +192,196 @@        } catch (final NullPointerException npe) {\n            assertThat(npe.getMessage(), containsString(\"stateRestoreCallback must not be null\"));\n        }\n\n    }"
  },
  {
    "id" : "ee792180-7a2b-43b5-a16a-45c2fb51c1fd",
    "prId" : 6667,
    "prUrl" : "https://github.com/apache/kafka/pull/6667#pullrequestreview-235110217",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f555ec50-e557-4aad-a2d9-97e98c43f750",
        "parentId" : null,
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "\"exposed\" after rebase -- for time-windows, we want to use the end-timestamp (even if this change is not implemented yet, I added it here, to avoid touching this class later on again).",
        "createdAt" : "2019-05-08T14:59:57Z",
        "updatedAt" : "2019-05-11T12:26:17Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      }
    ],
    "commit" : "21e5dee3c8c50f5d8d88ce0f1b78b351e30768ba",
    "line" : 48,
    "diffHunk" : "@@ -1,1 +391,395 @@            1,\n            offset,\n            end,\n            TimestampType.CREATE_TIME,\n            0L,"
  },
  {
    "id" : "04dc9279-f0d2-408e-bb8e-e2a8b7e798d2",
    "prId" : 7238,
    "prUrl" : "https://github.com/apache/kafka/pull/7238#pullrequestreview-279607055",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "eb50c247-2053-4715-9978-1088c9492ac0",
        "parentId" : null,
        "authorId" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "body" : "The following two tests have rather much code in common. Please try to extract common parts to methods.",
        "createdAt" : "2019-08-26T20:55:16Z",
        "updatedAt" : "2019-09-11T16:35:57Z",
        "lastEditedBy" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "tags" : [
        ]
      }
    ],
    "commit" : "0b14fbdce1f31b17070923325715f68c0238d43d",
    "line" : 12,
    "diffHunk" : "@@ -1,1 +556,560 @@        );\n    }\n\n    @Test\n    public void shouldNotGetConsumerCommittedOffsetIfThereAreNoRecordUpdates() throws IOException {"
  },
  {
    "id" : "d80b7066-6a16-478f-b731-70bedf2a27f8",
    "prId" : 7238,
    "prUrl" : "https://github.com/apache/kafka/pull/7238#pullrequestreview-279847919",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7e6035c3-4baf-4c4a-9d3f-2733c9d1ef53",
        "parentId" : null,
        "authorId" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "body" : "Why `AtomicInteger`?",
        "createdAt" : "2019-08-26T20:58:29Z",
        "updatedAt" : "2019-09-11T16:35:57Z",
        "lastEditedBy" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "tags" : [
        ]
      },
      {
        "id" : "eca1d410-3e24-4e4b-87b4-a21349260b59",
        "parentId" : "7e6035c3-4baf-4c4a-9d3f-2733c9d1ef53",
        "authorId" : "12543f19-3885-429e-8f77-e0f748c56d1f",
        "body" : "Is the question:\r\n\r\n1. Why AtomicInteger instead of a larger type? I'm not too worried about rollover here, but happy to make it long if you prefer.\r\n2. Why AtomicInteger instead of AtomicBoolean? I want to make sure we don't make a second consumer.committed() call.\r\n3. Why AtomticInteger instead a primitive type? I want to be able to set the value from a closure. I haven't done a lot of Java coding in the last year or two, so if you know a way to do it let me know and I will be happy to adopt it.",
        "createdAt" : "2019-08-26T21:27:09Z",
        "updatedAt" : "2019-09-11T16:35:57Z",
        "lastEditedBy" : "12543f19-3885-429e-8f77-e0f748c56d1f",
        "tags" : [
        ]
      }
    ],
    "commit" : "0b14fbdce1f31b17070923325715f68c0238d43d",
    "line" : 15,
    "diffHunk" : "@@ -1,1 +559,563 @@    @Test\n    public void shouldNotGetConsumerCommittedOffsetIfThereAreNoRecordUpdates() throws IOException {\n        final AtomicInteger committedCallCount = new AtomicInteger();\n\n        final Consumer<byte[], byte[]> consumer = new MockConsumer<byte[], byte[]>(OffsetResetStrategy.EARLIEST) {"
  },
  {
    "id" : "4be58551-8ab4-4c8c-bd7e-0e773f4bcd5b",
    "prId" : 8218,
    "prUrl" : "https://github.com/apache/kafka/pull/8218#pullrequestreview-373214281",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "35153b95-a5ed-403d-8432-cd2a35e09875",
        "parentId" : null,
        "authorId" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "body" : "nit; 228 - 229 could be merged.",
        "createdAt" : "2020-03-11T21:54:04Z",
        "updatedAt" : "2020-03-19T08:49:21Z",
        "lastEditedBy" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "tags" : [
        ]
      },
      {
        "id" : "d4ea1a51-c541-4fc0-8f17-2df341c6714e",
        "parentId" : "35153b95-a5ed-403d-8432-cd2a35e09875",
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "I think it's easier to read if it's split.",
        "createdAt" : "2020-03-12T00:41:22Z",
        "updatedAt" : "2020-03-19T08:49:21Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      }
    ],
    "commit" : "4b03a487a518756f7c9acd1f3177b12b407867d5",
    "line" : 40,
    "diffHunk" : "@@ -1,1 +226,230 @@\n        task = createStandbyTask();\n        final Map<TopicPartition, Long> checkpoint = task.prepareCloseClean();\n        task.closeClean(checkpoint);\n"
  }
]
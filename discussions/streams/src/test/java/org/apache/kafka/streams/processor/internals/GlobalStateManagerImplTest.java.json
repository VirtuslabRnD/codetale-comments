[
  {
    "id" : "6dae414e-c748-4fd6-bca8-39dbf8d95922",
    "prId" : 6150,
    "prUrl" : "https://github.com/apache/kafka/pull/6150#pullrequestreview-193933041",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a7ae8de8-ad03-4e28-8426-4ada684848d6",
        "parentId" : null,
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "This is \"fix\" on the side -- `initializeConsumer` did some weird stuff.",
        "createdAt" : "2019-01-18T02:59:00Z",
        "updatedAt" : "2019-01-19T05:57:33Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      }
    ],
    "commit" : "f2435661add504b15e5da5d76445cb268a8e7e80",
    "line" : 36,
    "diffHunk" : "@@ -1,1 +203,207 @@    public void shouldThrowIllegalArgumentExceptionIfAttemptingToRegisterStoreTwice() {\n        stateManager.initialize();\n        initializeConsumer(2, 0, t1);\n        stateManager.register(store1, stateRestoreCallback);\n        try {"
  },
  {
    "id" : "72f35818-3deb-4b4f-a6e1-17bc86f73671",
    "prId" : 8864,
    "prUrl" : "https://github.com/apache/kafka/pull/8864#pullrequestreview-452776699",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "10860ba3-797d-4e6c-9bca-3dc01b906f6d",
        "parentId" : null,
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "Addressed via #9047",
        "createdAt" : "2020-07-21T19:46:54Z",
        "updatedAt" : "2020-07-21T19:46:54Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      }
    ],
    "commit" : "e6c10d88f9c6fa9d89cc500112255898e2f24845",
    "line" : 40,
    "diffHunk" : "@@ -1,1 +613,617 @@    }\n\n    @SuppressWarnings(\"deprecation\") // TODO revisit in follow up PR\n    @Test\n    public void shouldRetryWhenEndOffsetsThrowsTimeoutException() {"
  },
  {
    "id" : "33476916-525d-4c18-a6fd-10b2c7fdd684",
    "prId" : 8864,
    "prUrl" : "https://github.com/apache/kafka/pull/8864#pullrequestreview-452776762",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8c0f4fe5-1bd1-4d38-b4bb-44dcfba1f9aa",
        "parentId" : null,
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "Addressed via #9047",
        "createdAt" : "2020-07-21T19:47:02Z",
        "updatedAt" : "2020-07-21T19:47:02Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      }
    ],
    "commit" : "e6c10d88f9c6fa9d89cc500112255898e2f24845",
    "line" : 48,
    "diffHunk" : "@@ -1,1 +647,651 @@    }\n\n    @SuppressWarnings(\"deprecation\") // TODO revisit in follow up PR\n    @Test\n    public void shouldRetryWhenPartitionsForThrowsTimeoutException() {"
  },
  {
    "id" : "0d7ce5a1-7d57-4b44-a0d8-a003d0604732",
    "prId" : 9047,
    "prUrl" : "https://github.com/apache/kafka/pull/9047#pullrequestreview-452937058",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "071afcea-965f-44fc-9ceb-0018977d2e7f",
        "parentId" : null,
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "This test is new (also added it for `partitionFor()` case).",
        "createdAt" : "2020-07-22T01:37:46Z",
        "updatedAt" : "2020-08-04T02:12:59Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      }
    ],
    "commit" : "cf6ee1e774a3a635cb8ac9c134ff3269edaa7357",
    "line" : 229,
    "diffHunk" : "@@ -1,1 +732,736 @@\n    @Test\n    public void shouldNotFailOnSlowProgressWhenEndOffsetsThrowsTimeoutException() {\n        final AtomicInteger numberOfCalls = new AtomicInteger(0);\n        consumer = new MockConsumer<byte[], byte[]>(OffsetResetStrategy.EARLIEST) {"
  },
  {
    "id" : "9b95d302-af73-4599-bc69-4fb7e7bf1237",
    "prId" : 9047,
    "prUrl" : "https://github.com/apache/kafka/pull/9047#pullrequestreview-452937365",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "39a300a4-f8b9-4aa7-9850-c0a16f0064dd",
        "parentId" : null,
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "Replicated the tests from above (`endOffset` and `partitionFor`) for the `position` call.",
        "createdAt" : "2020-07-22T01:38:42Z",
        "updatedAt" : "2020-08-04T02:12:59Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      }
    ],
    "commit" : "cf6ee1e774a3a635cb8ac9c134ff3269edaa7357",
    "line" : 449,
    "diffHunk" : "@@ -1,1 +940,944 @@\n    @Test\n    public void shouldNotRetryWhenPositionThrowsTimeoutExceptionAndTaskTimeoutIsZero() {\n        final AtomicInteger numberOfCalls = new AtomicInteger(0);\n        consumer = new MockConsumer<byte[], byte[]>(OffsetResetStrategy.EARLIEST) {"
  },
  {
    "id" : "57814c89-c39a-46b4-b896-2506552cc3a6",
    "prId" : 9047,
    "prUrl" : "https://github.com/apache/kafka/pull/9047#pullrequestreview-456899096",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b66130fb-c7cf-40d8-9ccb-c5a60d2f61c4",
        "parentId" : null,
        "authorId" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "body" : "nit: we could just use `Map` for `startOffsets` and `endOffsets`",
        "createdAt" : "2020-07-29T05:35:04Z",
        "updatedAt" : "2020-08-04T02:13:00Z",
        "lastEditedBy" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "tags" : [
        ]
      }
    ],
    "commit" : "cf6ee1e774a3a635cb8ac9c134ff3269edaa7357",
    "line" : 731,
    "diffHunk" : "@@ -1,1 +1217,1221 @@        final Map<TopicPartition, Long> startOffsets = new HashMap<>();\n        final Map<TopicPartition, Long> endOffsets = new HashMap<>();\n        for (final TopicPartition topicPartition : topicPartitions) {\n            startOffsets.put(topicPartition, startOffset);\n            endOffsets.put(topicPartition, startOffset + numRecords);"
  },
  {
    "id" : "0eaf0f4f-61c2-450c-9078-cae246ce6586",
    "prId" : 9121,
    "prUrl" : "https://github.com/apache/kafka/pull/9121#pullrequestreview-475879983",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1a18cfbb-ecbc-4ffa-be62-d3fb516f55d9",
        "parentId" : null,
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "Subjective: Might be \"better\" to do the assertion after the try-block.",
        "createdAt" : "2020-08-21T19:08:29Z",
        "updatedAt" : "2020-09-03T08:40:16Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "00bd3d34-49d9-4eab-a00e-0e4da347f700",
        "parentId" : "1a18cfbb-ecbc-4ffa-be62-d3fb516f55d9",
        "authorId" : "d520dc4e-6bae-4b0b-90d6-4c0a1cabb518",
        "body" : "I agree it'll be better to do the assertion after the try-block. But no, we can't move the assert out of the try-block because the `appender` is declared within try block. We can move the assert out of try-block if we don't use the try resource auto-close pattern, but I don't think it would be better. \r\nAlso, we assert within try-block for the `appender` tests in other places. I think they are all for the same reason as I mentioned above. \r\nThanks.",
        "createdAt" : "2020-08-24T06:09:57Z",
        "updatedAt" : "2020-09-03T08:40:16Z",
        "lastEditedBy" : "d520dc4e-6bae-4b0b-90d6-4c0a1cabb518",
        "tags" : [
        ]
      },
      {
        "id" : "7cdbe03b-b4e7-4e8b-9df6-b99b7023da4b",
        "parentId" : "1a18cfbb-ecbc-4ffa-be62-d3fb516f55d9",
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "Ah. Good point. We can leave as-is.",
        "createdAt" : "2020-08-26T21:42:29Z",
        "updatedAt" : "2020-09-03T08:40:16Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      }
    ],
    "commit" : "252cc9124c3ec76fb678a5d01755bd9c71e640ae",
    "line" : 36,
    "diffHunk" : "@@ -1,1 +199,203 @@            stateManager.checkpoint();\n            assertThat(appender.getMessages(), hasItem(containsString(\n                \"Failed to write offset checkpoint file to \" + checkpointFile.getPath() + \" for global stores\")));\n        }\n    }"
  },
  {
    "id" : "a8f0afde-b0ec-4b15-a0dd-8e836c66a90e",
    "prId" : 9121,
    "prUrl" : "https://github.com/apache/kafka/pull/9121#pullrequestreview-475905446",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5f0e82d7-0d85-4117-8d71-f60903c8012c",
        "parentId" : null,
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "Why do we need to add `.tmp` ?",
        "createdAt" : "2020-08-21T19:09:36Z",
        "updatedAt" : "2020-09-03T08:40:16Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "e4c7c20c-e0f8-46aa-a63b-75537b20c1c8",
        "parentId" : "5f0e82d7-0d85-4117-8d71-f60903c8012c",
        "authorId" : "d520dc4e-6bae-4b0b-90d6-4c0a1cabb518",
        "body" : "It's because we we will write data to the .tmp file first and then swap to the CHECKPOINT_FILE. And in the swap action, we use `Files.move` with `ATOMIC_MOVE` option, which will try to replace the target file if exists. I cannot create `IOException` with this case. I added comments for this line to explain the reason. Thank you.\r\nref: https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#move-java.nio.file.Path-java.nio.file.Path-java.nio.file.CopyOption...-",
        "createdAt" : "2020-08-24T07:28:28Z",
        "updatedAt" : "2020-09-03T08:40:16Z",
        "lastEditedBy" : "d520dc4e-6bae-4b0b-90d6-4c0a1cabb518",
        "tags" : [
        ]
      },
      {
        "id" : "8177d4c1-d82e-45c6-bbf8-97d006a3629b",
        "parentId" : "5f0e82d7-0d85-4117-8d71-f60903c8012c",
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "Interesting... Thanks for clarification.",
        "createdAt" : "2020-08-26T22:06:44Z",
        "updatedAt" : "2020-09-03T08:40:16Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      }
    ],
    "commit" : "252cc9124c3ec76fb678a5d01755bd9c71e640ae",
    "line" : 29,
    "diffHunk" : "@@ -1,1 +192,196 @@        // set readonly to the CHECKPOINT_FILE_NAME.tmp file because we will write data to the .tmp file first\n        // and then swap to CHECKPOINT_FILE_NAME by replacing it\n        final File file = new File(stateDirectory.globalStateDir(), StateManagerUtil.CHECKPOINT_FILE_NAME + \".tmp\");\n        file.createNewFile();\n        file.setWritable(false);"
  }
]
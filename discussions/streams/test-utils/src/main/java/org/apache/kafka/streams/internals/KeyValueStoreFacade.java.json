[
  {
    "id" : "c03cbbd8-e975-40e8-b94b-d4e3a46a1aa0",
    "prId" : 6175,
    "prUrl" : "https://github.com/apache/kafka/pull/6175#pullrequestreview-195330583",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ae5e43ee-321a-4027-b96a-bf514888215a",
        "parentId" : null,
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "Should we prepare a new list of key-valuetimstamp and call the inner.putAll here?",
        "createdAt" : "2019-01-23T01:50:13Z",
        "updatedAt" : "2019-03-06T01:00:17Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "f3ae6dac-4051-4d2f-951d-a4956f9a9834",
        "parentId" : "ae5e43ee-321a-4027-b96a-bf514888215a",
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "This is more efficient. If we prepare a new list, we iterator over the list effectively twice (once here, and a second time in `inner.putAll()`). And this code is simple/straight forward, so I don't think we gain reduced code complexity / code reuse that justifies this overhead.",
        "createdAt" : "2019-01-23T03:08:04Z",
        "updatedAt" : "2019-03-06T01:00:17Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      }
    ],
    "commit" : "e90fea067d3825ac22d63bb7f878748858c6ee79",
    "line" : 57,
    "diffHunk" : "@@ -1,1 +55,59 @@    @Override\n    public void putAll(final List<KeyValue<K, V>> entries) {\n        for (final KeyValue<K, V> entry : entries) {\n            inner.put(entry.key, ValueAndTimestamp.make(entry.value, ConsumerRecord.NO_TIMESTAMP));\n        }"
  },
  {
    "id" : "18b178a0-1d93-4548-98cf-e0948429a2fc",
    "prId" : 6175,
    "prUrl" : "https://github.com/apache/kafka/pull/6175#pullrequestreview-195331105",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1958d095-a737-4135-949c-18647a21bdbb",
        "parentId" : null,
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "QQ: why these three classes only need to be in test-utils but not in streams internals? Are they not going to be needed for upgrade at all?",
        "createdAt" : "2019-01-23T01:50:52Z",
        "updatedAt" : "2019-03-06T01:00:17Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "59119690-bfbf-40a7-802f-3c6b6adb5749",
        "parentId" : "1958d095-a737-4135-949c-18647a21bdbb",
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "We don't need them for upgrading. It's just for `test-utils` backwards compatibility.\r\n\r\nThe upgrade at runtime happens within `RockDBTimestampedStore` and for this case, we only need the `get()` compatibility that returns `-1` if no timestamp is available yet. We don't need any write path backwards compatibility.",
        "createdAt" : "2019-01-23T03:11:03Z",
        "updatedAt" : "2019-03-06T01:00:17Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      }
    ],
    "commit" : "e90fea067d3825ac22d63bb7f878748858c6ee79",
    "line" : 30,
    "diffHunk" : "@@ -1,1 +28,32 @@import java.util.List;\n\npublic class KeyValueStoreFacade<K, V> extends ReadOnlyKeyValueStoreFacade<K, V> implements KeyValueStore<K, V> {\n\n    public KeyValueStoreFacade(final TimestampedKeyValueStore<K, V> inner) {"
  }
]
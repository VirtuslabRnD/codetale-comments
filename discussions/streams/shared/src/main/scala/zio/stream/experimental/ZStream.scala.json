[
  {
    "id" : "73058934-e18e-466f-b7df-7cd8df77b8f9",
    "prId" : 5007,
    "prUrl" : "https://github.com/zio/zio/pull/5007#pullrequestreview-649988434",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "37e3a8e2-144a-49c1-9fff-e126b93e5430",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "Doing this with laziness is really nice and will avoid repeated allocations. üëç ",
        "createdAt" : "2021-05-02T23:01:12Z",
        "updatedAt" : "2021-05-02T23:01:12Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      }
    ],
    "commit" : "9771baaf2dd87279de488f4daa54dbf19108f787",
    "line" : 20,
    "diffHunk" : "@@ -1,1 +2394,2398 @@        val upstreamDone: AtomicBoolean                  = new AtomicBoolean(false)\n\n        lazy val buffer: ZChannel[Any, E, Chunk[A1], Any, E, Chunk[A1], Any] =\n          ZChannel.effectSuspendTotal {\n            val l = leftovers.get"
  },
  {
    "id" : "71fdb885-9cca-4e55-8bf1-84e67859bf42",
    "prId" : 4974,
    "prUrl" : "https://github.com/zio/zio/pull/4974#pullrequestreview-638774016",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6fa2041f-31d7-4a3a-9c61-f0f7751f76a9",
        "parentId" : null,
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "Hmm this was previously implemented using `combine`. If we still need to use `toPull` here, could we keep the previous implementation? That means that when (if) we find a way to implement combine/combineChunks without toPull, this implementation would be solved as well.",
        "createdAt" : "2021-04-19T11:48:14Z",
        "updatedAt" : "2021-05-11T11:59:41Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      },
      {
        "id" : "4ba83eaa-b317-43d8-b90e-6d41667990ae",
        "parentId" : "6fa2041f-31d7-4a3a-9c61-f0f7751f76a9",
        "authorId" : "02debe6b-f37b-49a5-a03c-ce2417750ed1",
        "body" : "Makes sense, @iravid. I will update.",
        "createdAt" : "2021-04-19T11:49:42Z",
        "updatedAt" : "2021-05-11T11:59:41Z",
        "lastEditedBy" : "02debe6b-f37b-49a5-a03c-ce2417750ed1",
        "tags" : [
        ]
      }
    ],
    "commit" : "ed308a9f97c404ec50c865c6147973c201da6e1b",
    "line" : 15,
    "diffHunk" : "@@ -1,1 +1334,1338 @@\n    new ZStream(\n      ZChannel.managed {\n        for {\n          left  <- ZStream.Handoff.make[Take[E1, A1]].toManaged_"
  },
  {
    "id" : "1a1215d6-4cbc-4286-96b2-8c8571bcd1c2",
    "prId" : 4967,
    "prUrl" : "https://github.com/zio/zio/pull/4967#pullrequestreview-638910799",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "045fdd5a-3ca8-4054-9b28-8ada3b694e21",
        "parentId" : null,
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "Can you add another note that this combinator destroys the chunking structure and it is recommended to add a call to `chunkN` afterwards?",
        "createdAt" : "2021-04-19T11:36:36Z",
        "updatedAt" : "2021-04-19T14:09:12Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      },
      {
        "id" : "c89fa97e-4d2b-4a9f-a740-519d354af8d2",
        "parentId" : "045fdd5a-3ca8-4054-9b28-8ada3b694e21",
        "authorId" : "02debe6b-f37b-49a5-a03c-ce2417750ed1",
        "body" : "Done",
        "createdAt" : "2021-04-19T14:05:42Z",
        "updatedAt" : "2021-04-19T14:09:12Z",
        "lastEditedBy" : "02debe6b-f37b-49a5-a03c-ce2417750ed1",
        "tags" : [
        ]
      }
    ],
    "commit" : "ef1d65bff056724db4742a4d853dfbc572c7a2cc",
    "line" : 8,
    "diffHunk" : "@@ -1,1 +307,311 @@   *\n   * @note This combinator destroys the chunking structure. It's recommended to use chunkN afterwards.\n   * @note Prefer capacities that are powers of 2 for better performance.\n   */\n  final def buffer(capacity: Int): ZStream[R, E, A] = {"
  },
  {
    "id" : "b27d62a7-90e1-4d3b-8349-aab8c05c7b5b",
    "prId" : 4939,
    "prUrl" : "https://github.com/zio/zio/pull/4939#pullrequestreview-632973528",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "589a6394-596c-49b2-bd6f-74bf5d43ce69",
        "parentId" : null,
        "authorId" : "6cd8861a-3e0b-4a5b-9f5e-a53e2718db6e",
        "body" : "Glad to know that I'm not the only one who has done this üò∫ ",
        "createdAt" : "2021-04-11T05:21:17Z",
        "updatedAt" : "2021-04-11T05:21:17Z",
        "lastEditedBy" : "6cd8861a-3e0b-4a5b-9f5e-a53e2718db6e",
        "tags" : [
        ]
      }
    ],
    "commit" : "89e4ea74407c4cc0dcb3dbabf11422b751314d31",
    "line" : 24,
    "diffHunk" : "@@ -1,1 +817,821 @@          (in: Chunk[A]) => {\n            val dropped  = in.drop(r)\n            val leftover = (r - in.length).max(0)\n            val more     = in.isEmpty || leftover > 0\n"
  },
  {
    "id" : "60a7c283-8a78-42ee-8f4f-91a9a4619617",
    "prId" : 4904,
    "prUrl" : "https://github.com/zio/zio/pull/4904#pullrequestreview-630361649",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c88d0e4b-d2cc-442f-a41f-fa26af6d9dc3",
        "parentId" : null,
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "Much nicer üëç ",
        "createdAt" : "2021-04-07T18:20:19Z",
        "updatedAt" : "2021-04-07T18:20:19Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      }
    ],
    "commit" : "face0e3c1e8dbd8de91262f641f4f416f89cc726",
    "line" : 37,
    "diffHunk" : "@@ -1,1 +2906,2910 @@    def loop(s: S): ZChannel[R, Any, Any, Any, E, Chunk[A], Any] =\n      ZChannel.unwrap {\n        f(s).map {\n          case (as, Some(s)) => ZChannel.write(as) *> loop(s)\n          case (as, None)    => ZChannel.write(as) *> ZChannel.end(())"
  },
  {
    "id" : "485e69c9-bde1-4219-8666-2bf68b189c3d",
    "prId" : 4901,
    "prUrl" : "https://github.com/zio/zio/pull/4901#pullrequestreview-631261288",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c598ef00-a843-44ab-9b5c-07ee83d06b74",
        "parentId" : null,
        "authorId" : "6cd8861a-3e0b-4a5b-9f5e-a53e2718db6e",
        "body" : "Added `scanReduceM` because it could be implemented in terms of `mapAccumM`",
        "createdAt" : "2021-04-08T11:05:44Z",
        "updatedAt" : "2021-04-08T11:11:47Z",
        "lastEditedBy" : "6cd8861a-3e0b-4a5b-9f5e-a53e2718db6e",
        "tags" : [
        ]
      }
    ],
    "commit" : "9ea0416319dd7c5260b29566b915c3a02fdac316",
    "line" : 60,
    "diffHunk" : "@@ -1,1 +1916,1920 @@      case (Some(a1), a) => f(a1, a).map(a2 => Some(a2) -> a2)\n      case (None, a) => ZIO.succeedNow(Some(a) -> a)\n    }\n\n  /**"
  },
  {
    "id" : "03747acd-c61c-47ed-93b1-fe358f0fc5a8",
    "prId" : 3302,
    "prUrl" : "https://github.com/zio/zio/pull/3302#pullrequestreview-391870028",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9c60d9f3-5384-42d7-9fd7-9b328a567977",
        "parentId" : null,
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "All of the methods will always end with `true`, so this will never stop. Should we do `as(false)` after enqueueing `Take.End`?",
        "createdAt" : "2020-04-12T15:45:01Z",
        "updatedAt" : "2020-04-12T17:52:45Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      }
    ],
    "commit" : "8194b8e1132c67930c0ffa108ebcb5c56f521b90",
    "line" : 49,
    "diffHunk" : "@@ -1,1 +156,160 @@            }\n\n          go.repeat(Schedule.doWhile(identity))\n        }.forkManaged\n"
  },
  {
    "id" : "490e1f7c-72e6-45e2-bc46-6aff4a0bf823",
    "prId" : 3281,
    "prUrl" : "https://github.com/zio/zio/pull/3281#pullrequestreview-387715387",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "dee69d63-ab62-4eed-986f-28d1fbc3af31",
        "parentId" : null,
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "Maybe just `foldCauseM(Cause.sequenceCauseOption(...), ...)` here instead of `foldM.catchAllCause`?",
        "createdAt" : "2020-04-04T16:25:24Z",
        "updatedAt" : "2020-04-10T13:03:06Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      },
      {
        "id" : "55c3126b-f423-4e4c-b2b0-0a9ea2b61f94",
        "parentId" : "dee69d63-ab62-4eed-986f-28d1fbc3af31",
        "authorId" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "body" : "Hmm, I don't think you can remove the `catchAllCause` as it is necessary to handle the \"next\" signal from the transducer and pull again, right? I switched to `foldM` to avoid the redundancy in case of a defect.",
        "createdAt" : "2020-04-04T16:31:27Z",
        "updatedAt" : "2020-04-10T13:03:06Z",
        "lastEditedBy" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "tags" : [
        ]
      },
      {
        "id" : "4ab2dce1-3bce-4b62-8aae-c752452bcc22",
        "parentId" : "dee69d63-ab62-4eed-986f-28d1fbc3af31",
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "Right! Good point. It does look like you can replace `catchAllCause` with `catchAll` though, because you're just forwarding the cause with `Pull.halt` on the non-typed-failure case.",
        "createdAt" : "2020-04-04T16:49:33Z",
        "updatedAt" : "2020-04-10T13:03:06Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      }
    ],
    "commit" : "c30aa3d640ac1993956ca1e6d5d509c63e9289f7",
    "line" : 20,
    "diffHunk" : "@@ -1,1 +99,103 @@            else\n              pull\n                .foldM(\n                  _.fold(done.set(true) *> push(None))(Pull.fail(_)),\n                  os => push(Some(os))"
  },
  {
    "id" : "d952bfcd-cc44-4dfb-8983-24e0fbe9c226",
    "prId" : 3281,
    "prUrl" : "https://github.com/zio/zio/pull/3281#pullrequestreview-387952044",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8bd13385-1f87-4a5a-87f1-96f4ec4ae574",
        "parentId" : null,
        "authorId" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "body" : "What do you think of this @iravid ?",
        "createdAt" : "2020-04-05T08:45:19Z",
        "updatedAt" : "2020-04-10T13:03:06Z",
        "lastEditedBy" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "tags" : [
        ]
      },
      {
        "id" : "7f0e9160-3118-4aeb-b525-9c852c15e302",
        "parentId" : "8bd13385-1f87-4a5a-87f1-96f4ec4ae574",
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "It‚Äôs fine. A direct loop would be more performant but this should probably be an uncommon code path.",
        "createdAt" : "2020-04-06T06:03:04Z",
        "updatedAt" : "2020-04-10T13:03:06Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      }
    ],
    "commit" : "c30aa3d640ac1993956ca1e6d5d509c63e9289f7",
    "line" : 17,
    "diffHunk" : "@@ -1,1 +96,100 @@          def go: ZIO[R1, Option[E1], Chunk[P]] = done.get.flatMap {\n            if (_)\n              push(None).repeat(Schedule.doWhile(_.isEmpty))\n            else\n              pull"
  },
  {
    "id" : "51d295dd-8582-4ce9-86d2-ffb01789d737",
    "prId" : 3281,
    "prUrl" : "https://github.com/zio/zio/pull/3281#pullrequestreview-391741989",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d5aba251-6092-43ab-8bdf-d2f65a061bee",
        "parentId" : null,
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "The `fold(go)` here looks suspicious, because we can get here both from `push(Some(os))` and from `push(None)`.\r\n\r\n- From `push(Some(os))` - this looks like a protocol violation, right? Do we allow transducers to end on their own accord? I'm not clear on this üßê\r\n- From `push(None)` - this will recurse again if the transducer ended in response to the stream ending. Ah, it'll end on the next iteration because of `done set true`. Ok, I'd prefer to `ZIO.fail(None)` directly here but not critical üëç \r\n\r\nSo let's just clarify the first point. What do you think?",
        "createdAt" : "2020-04-10T13:48:17Z",
        "updatedAt" : "2020-04-10T13:48:17Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      },
      {
        "id" : "ffd4d4eb-ea6a-489f-97f1-8e43407fe4ef",
        "parentId" : "d5aba251-6092-43ab-8bdf-d2f65a061bee",
        "authorId" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "body" : "I think this also happens with sinks, the way they signal end is by failing which, thanks to ZIO being well-typed, you have to account for everywhere. That's another instance of what we were trying to fix with `SignalFunction`. Not sure there is a solution other than writing laws and throwing all the transducers at them.",
        "createdAt" : "2020-04-10T18:55:37Z",
        "updatedAt" : "2020-04-10T18:55:37Z",
        "lastEditedBy" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "tags" : [
        ]
      },
      {
        "id" : "f41e2598-981f-43d3-bbe3-e58d05607e47",
        "parentId" : "d5aba251-6092-43ab-8bdf-d2f65a061bee",
        "authorId" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "body" : "I could refactor so that we die in case of a protocol error, but somehow that feels imperative. Note that having two different paths for the `None` and `Some` cases won't change the fact that the transducer may fail.",
        "createdAt" : "2020-04-10T19:04:20Z",
        "updatedAt" : "2020-04-10T19:04:20Z",
        "lastEditedBy" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "tags" : [
        ]
      },
      {
        "id" : "1a98bf2e-4a8e-4682-a2ae-1ac869fb9a1d",
        "parentId" : "d5aba251-6092-43ab-8bdf-d2f65a061bee",
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "So I was thinking about this for a bit and perhaps it‚Äôs useful to allow transducers to signal end? E.g. that allows to create transducers that can short-circuit a stream when a predicate is violated.",
        "createdAt" : "2020-04-10T19:45:10Z",
        "updatedAt" : "2020-04-10T19:45:11Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      },
      {
        "id" : "fdabae88-b1a3-48b8-8cd9-9b3ef49b5abb",
        "parentId" : "d5aba251-6092-43ab-8bdf-d2f65a061bee",
        "authorId" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "body" : "Can you give an example? With `collectAllWhile`, I took the position that the transducer would just drop all elements violating the predicate, but still keep on accepting the rest of the stream. Is there another class of transducers where that wouldn't be possible?",
        "createdAt" : "2020-04-11T06:45:03Z",
        "updatedAt" : "2020-04-11T06:45:03Z",
        "lastEditedBy" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "tags" : [
        ]
      }
    ],
    "commit" : "c30aa3d640ac1993956ca1e6d5d509c63e9289f7",
    "line" : 25,
    "diffHunk" : "@@ -1,1 +104,108 @@                )\n                .foldCauseM(\n                  Cause.sequenceCauseOption(_).fold(go)(Pull.halt(_)),\n                  ps => if (ps.isEmpty) go else IO.succeedNow(ps)\n                )"
  },
  {
    "id" : "16bf938e-7707-41ee-b230-3e2b37dce7c7",
    "prId" : 3144,
    "prUrl" : "https://github.com/zio/zio/pull/3144#pullrequestreview-375643630",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "01137868-6c4e-40bb-a640-c4fb7400f331",
        "parentId" : null,
        "authorId" : "05793de5-8cbe-49ba-90b1-8ef51f2dd854",
        "body" : "drop the newest or the oldest should be an option",
        "createdAt" : "2020-03-16T23:13:32Z",
        "updatedAt" : "2020-03-22T13:44:52Z",
        "lastEditedBy" : "05793de5-8cbe-49ba-90b1-8ef51f2dd854",
        "tags" : [
        ]
      }
    ],
    "commit" : "bfe3d3e040f9576e0f7e3afbd86187def6d9d914",
    "line" : 64,
    "diffHunk" : "@@ -1,1 +235,239 @@   * @note Prefer capacities that are powers of 2 for better performance.\n   */\n  final def bufferDropping(capacity: Int): ZStream[R, E, O] =\n    ZStream {\n      for {"
  },
  {
    "id" : "77afeb6c-1037-4491-b270-a65b249cda01",
    "prId" : 3144,
    "prUrl" : "https://github.com/zio/zio/pull/3144#pullrequestreview-378994775",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "31108672-cc0b-4fdd-b563-e119e06e6c79",
        "parentId" : null,
        "authorId" : "6bab7be3-690b-49f9-9a0d-a8415f4c0c8e",
        "body" : "Sorry, @regiskuckaertz, but how does this code deal with resuming after error? I believe you have removed the mechanism for that. Doesn't this just stop after it encounters the first error?",
        "createdAt" : "2020-03-22T11:09:44Z",
        "updatedAt" : "2020-03-22T13:44:52Z",
        "lastEditedBy" : "6bab7be3-690b-49f9-9a0d-a8415f4c0c8e",
        "tags" : [
        ]
      },
      {
        "id" : "6b08e6dc-cebe-4362-a4b8-c93e6aab1db5",
        "parentId" : "31108672-cc0b-4fdd-b563-e119e06e6c79",
        "authorId" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "body" : "I was looking at `upstream` and it cannot fail from the inside, whereas in downstream, the `pull` intercepts any error and set the flag `done` to true. After that, `pull` will always yield `Pull.End`. Is my reasoning correct? I'll add safety tests to make sure of it! But this was a test to figure out why bufferSliding is behaving differently, and it seems that downstream is pulling the end signal which blows up the test with an error of `None` as it should. But I wonder why it is pulling that end signal in the first place ü§î ",
        "createdAt" : "2020-03-22T11:15:59Z",
        "updatedAt" : "2020-03-22T13:44:52Z",
        "lastEditedBy" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "tags" : [
        ]
      },
      {
        "id" : "c7551364-8534-480c-b446-fda8f49e8bf2",
        "parentId" : "31108672-cc0b-4fdd-b563-e119e06e6c79",
        "authorId" : "6bab7be3-690b-49f9-9a0d-a8415f4c0c8e",
        "body" : "I'm talking about the `Promise` for each element that paused the pipeline until the error has been handled downstream.",
        "createdAt" : "2020-03-22T11:18:49Z",
        "updatedAt" : "2020-03-22T13:44:52Z",
        "lastEditedBy" : "6bab7be3-690b-49f9-9a0d-a8415f4c0c8e",
        "tags" : [
        ]
      },
      {
        "id" : "537c900f-030a-4dd5-94bd-98b14de79e77",
        "parentId" : "31108672-cc0b-4fdd-b563-e119e06e6c79",
        "authorId" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "body" : "Ha, yes that's the thing I missed. Thanks : üôè ",
        "createdAt" : "2020-03-22T11:21:08Z",
        "updatedAt" : "2020-03-22T13:44:52Z",
        "lastEditedBy" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "tags" : [
        ]
      }
    ],
    "commit" : "bfe3d3e040f9576e0f7e3afbd86187def6d9d914",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +184,188 @@    }\n\n  private final def bufferSignal[E1 >: E, O1 >: O](\n    queue: Queue[(Take[E1, O1], Promise[Nothing, Unit])]\n  ): ZManaged[R, Nothing, ZIO[R, Option[E1], Chunk[O1]]] ="
  },
  {
    "id" : "2e69e09d-7216-45ec-9045-4f5e717d7391",
    "prId" : 3128,
    "prUrl" : "https://github.com/zio/zio/pull/3128#pullrequestreview-374717016",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "eb9d6281-2dc1-45f3-819d-d3bee4b633c2",
        "parentId" : null,
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "Good catch! We should also add that on the `reservation.acquire`.",
        "createdAt" : "2020-03-14T11:52:30Z",
        "updatedAt" : "2020-03-14T11:52:30Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      }
    ],
    "commit" : "906b3219ee143161ddba3d90a6ca69633082d409",
    "line" : 132,
    "diffHunk" : "@@ -1,1 +2207,2211 @@            else\n              (for {\n                reservation <- managed.reserve.onError(_ => doneRef.set(true))\n                _           <- finalizer.add(reservation.release)\n                _           <- doneRef.set(true)"
  },
  {
    "id" : "753ce3fe-5a91-41ba-bcac-c6872d5c0f0e",
    "prId" : 3128,
    "prUrl" : "https://github.com/zio/zio/pull/3128#pullrequestreview-374717062",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d17e8bf5-1c88-4c25-94a3-051dbc4a661b",
        "parentId" : null,
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "Can you port the tests for `fromInputStream` as well?",
        "createdAt" : "2020-03-14T11:53:32Z",
        "updatedAt" : "2020-03-14T11:53:33Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      }
    ],
    "commit" : "906b3219ee143161ddba3d90a6ca69633082d409",
    "line" : 46,
    "diffHunk" : "@@ -1,1 +2050,2054 @@   * Creates a stream from a [[java.io.InputStream]]\n   */\n  def fromInputStream(\n    is: => InputStream,\n    chunkSize: Int = ZStream.DefaultChunkSize"
  },
  {
    "id" : "c0a6d0e5-53b7-41fb-8653-bd71d36c6120",
    "prId" : 3128,
    "prUrl" : "https://github.com/zio/zio/pull/3128#pullrequestreview-374717095",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "84e3572b-0b68-4143-8232-bb1f6ea36417",
        "parentId" : null,
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "```suggestion\r\n                bytesRead <- blocking.effectBlockingInterruptible(capturedIs.read(bufArray)).refineToOrDie[IOException].mapError(Some(_))\r\n```",
        "createdAt" : "2020-03-14T11:54:03Z",
        "updatedAt" : "2020-03-14T11:54:04Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      }
    ],
    "commit" : "906b3219ee143161ddba3d90a6ca69633082d409",
    "line" : 61,
    "diffHunk" : "@@ -1,1 +2065,2069 @@              for {\n                bufArray  <- buf.get\n                bytesRead <- IO.effect(capturedIs.read(bufArray)).refineToOrDie[IOException].mapError(Some(_))\n                bytes <- if (bytesRead < 0)\n                          done.set(true) *> Pull.end"
  },
  {
    "id" : "a9991518-e573-408f-b703-9cf6f7b871e9",
    "prId" : 2899,
    "prUrl" : "https://github.com/zio/zio/pull/2899#pullrequestreview-359113046",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "92dab008-df8c-48de-af47-8f8ac7fc95d7",
        "parentId" : null,
        "authorId" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "body" : "The question is do we want the marker to be permanently `Some(b)` in the event the stream is smaller than n elements and downstream keep pulling ad infinitum, or is it fine to eventually switch to `None`?",
        "createdAt" : "2020-02-14T17:47:28Z",
        "updatedAt" : "2020-02-14T17:47:28Z",
        "lastEditedBy" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "tags" : [
        ]
      },
      {
        "id" : "07360ed8-7a8e-4478-a98c-d9e36a0e8a67",
        "parentId" : "92dab008-df8c-48de-af47-8f8ac7fc95d7",
        "authorId" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "body" : "Ha scratch that, the update will only happen if the pull is successful ü§¶‚Äç‚ôÇ ",
        "createdAt" : "2020-02-14T17:48:17Z",
        "updatedAt" : "2020-02-14T17:48:18Z",
        "lastEditedBy" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "tags" : [
        ]
      }
    ],
    "commit" : "bf11d0f042c9c55e9709d83a57b2d214ec0b9cfa",
    "line" : 97,
    "diffHunk" : "@@ -1,1 +278,282 @@        counter <- Ref.make(0L).toManaged_\n        pull = counter.get.flatMap { c =>\n          if (c >= n) Pull.end(None)\n          else as.pull.mapError(_.map(Some(_))) <* counter.set(c + 1)\n        }"
  },
  {
    "id" : "cc61c995-5e21-4d97-8706-878381606081",
    "prId" : 2896,
    "prUrl" : "https://github.com/zio/zio/pull/2896#pullrequestreview-358979092",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9e6327f1-84dc-4465-93d2-fb4a7fc7e6c9",
        "parentId" : null,
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "The previous implementation defaults to `Pull.end` here to avoid the `Option`. Would that work here?",
        "createdAt" : "2020-02-14T12:43:02Z",
        "updatedAt" : "2020-02-14T15:49:08Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      },
      {
        "id" : "8285f39d-92a6-4232-92f8-0fbce847ed06",
        "parentId" : "9e6327f1-84dc-4465-93d2-fb4a7fc7e6c9",
        "authorId" : "6bab7be3-690b-49f9-9a0d-a8415f4c0c8e",
        "body" : "Not sure, and this is a pain point of returning a value at the end, we don't have the value to return. :/",
        "createdAt" : "2020-02-14T13:17:50Z",
        "updatedAt" : "2020-02-14T15:49:08Z",
        "lastEditedBy" : "6bab7be3-690b-49f9-9a0d-a8415f4c0c8e",
        "tags" : [
        ]
      },
      {
        "id" : "8eda7569-136b-4221-97da-f00e393453bb",
        "parentId" : "9e6327f1-84dc-4465-93d2-fb4a7fc7e6c9",
        "authorId" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "body" : "You can't because there is no `B` to put into `Pull.end`.",
        "createdAt" : "2020-02-14T14:30:47Z",
        "updatedAt" : "2020-02-14T15:49:08Z",
        "lastEditedBy" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "tags" : [
        ]
      }
    ],
    "commit" : "737dd9b3af6a5b13fd2e63f10e070b5dedd80806",
    "line" : 59,
    "diffHunk" : "@@ -1,1 +91,95 @@    ZStream {\n      for {\n        currPull  <- Ref.make[Option[ZIO[R1, Either[E1, B1], C]]](None).toManaged_\n        currCmd   <- Ref.make[Option[M1 => ZIO[R1, E1, Any]]](None).toManaged_\n        control   <- self.process"
  },
  {
    "id" : "3ab123c5-2b9b-4457-b329-566a52e8122e",
    "prId" : 2896,
    "prUrl" : "https://github.com/zio/zio/pull/2896#pullrequestreview-358979262",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7ff0ce1b-2826-4887-a4a4-80ab6b602dc7",
        "parentId" : null,
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "Love this implementation. The new encoding looks to be paying off so far!",
        "createdAt" : "2020-02-14T12:46:02Z",
        "updatedAt" : "2020-02-14T15:49:08Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      },
      {
        "id" : "b7e94c76-dbf1-4de3-85b9-0854bc9563e4",
        "parentId" : "7ff0ce1b-2826-4887-a4a4-80ab6b602dc7",
        "authorId" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "body" : "Yes, so clear!",
        "createdAt" : "2020-02-14T14:31:01Z",
        "updatedAt" : "2020-02-14T15:49:08Z",
        "lastEditedBy" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "tags" : [
        ]
      }
    ],
    "commit" : "737dd9b3af6a5b13fd2e63f10e070b5dedd80806",
    "line" : 99,
    "diffHunk" : "@@ -1,1 +204,208 @@      go = {\n        def pull: ZIO[R1, E1, B] =\n          command.pull.foldM(\n            _.fold(ZIO.failNow, _ => control.query),\n            control.push(_).catchAll(_.fold(ZIO.failNow, _ => ZIO.unit)) *> pull"
  },
  {
    "id" : "2959d9d1-41e3-4ff2-967c-da8d33f57b8c",
    "prId" : 2726,
    "prUrl" : "https://github.com/zio/zio/pull/2726#pullrequestreview-348589610",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "af3f8a97-5ae3-4819-a022-e0f99999efcd",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "The implementation of `fromEffect` in terms of `managed` is too complicated IMO. The `zio` effect has no finalizers.\r\n\r\nI think you should add: `ZIO#once(e: E): UIO[ZIO[R, E, A]]`, which returns a ZIO effect that will execute a single time, and if you call it again, you get the specified error. You could do the same for `ZManaged`.\r\n\r\nThen you can implement these two methods simply.",
        "createdAt" : "2020-01-27T11:18:12Z",
        "updatedAt" : "2020-01-27T13:22:49Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      }
    ],
    "commit" : "467a45f4ce14acb0253924feee7b0d7ccde49cf6",
    "line" : 80,
    "diffHunk" : "@@ -1,1 +62,66 @@        doneRef   <- Ref.make(false).toManaged_\n        finalizer <- ZManaged.finalizerRef[R](_ => UIO.unit)\n        pull = ZIO.uninterruptibleMask { restore =>\n          doneRef.get.flatMap { done =>\n            if (done) IO.fail(Right(()))"
  },
  {
    "id" : "605940a8-f915-45c8-8876-e4176ec6a492",
    "prId" : 2726,
    "prUrl" : "https://github.com/zio/zio/pull/2726#pullrequestreview-348657980",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "36021f05-969c-450b-b498-8135163dd85e",
        "parentId" : null,
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "Cool. We can extract the technique here to a combinator on `ZIO` in a follow-up.",
        "createdAt" : "2020-01-27T13:25:34Z",
        "updatedAt" : "2020-01-27T13:25:34Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      }
    ],
    "commit" : "467a45f4ce14acb0253924feee7b0d7ccde49cf6",
    "line" : 48,
    "diffHunk" : "@@ -1,1 +40,44 @@\n  def fromEffect[R, E, A](zio: ZIO[R, E, A]): ZStream[R, E, Any, Unit, A] =\n    ZStream {\n      for {\n        done <- Ref.make(false).toManaged_"
  }
]
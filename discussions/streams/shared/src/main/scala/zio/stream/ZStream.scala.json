[
  {
    "id" : "3f16feea-776e-4cd9-960b-be9592e1190d",
    "prId" : 5330,
    "prUrl" : "https://github.com/zio/zio/pull/5330#pullrequestreview-716246297",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2ed9b6c7-6860-4a41-8e43-19f896c494dc",
        "parentId" : null,
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "Probably good clarification here.",
        "createdAt" : "2021-07-27T18:31:09Z",
        "updatedAt" : "2021-07-27T18:31:09Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      }
    ],
    "commit" : "5ce66c0463dc349abd2cd3f9f624c800e788be0b",
    "line" : 21,
    "diffHunk" : "@@ -1,1 +1964,1968 @@   */\n  @deprecated(\"use intoQueue\", \"2.0.0\")\n  final def into[R1 <: R, E1 >: E](\n    queue: ZQueue[R1, Nothing, Nothing, Any, Take[E1, O], Any]\n  ): ZIO[R1, E1, Unit] ="
  },
  {
    "id" : "9011fa99-9558-4603-aed4-c426ef4ac60d",
    "prId" : 5068,
    "prUrl" : "https://github.com/zio/zio/pull/5068#pullrequestreview-660753011",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4eaa31d2-3caa-475c-bc70-1ce875b12e0d",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "Shouldn't we use some type of bracket here so in case there are failures, we shift back?",
        "createdAt" : "2021-05-17T00:14:05Z",
        "updatedAt" : "2021-05-17T00:14:05Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      },
      {
        "id" : "cc1b3bb4-4fd6-46c1-9c9d-be52353ebcbe",
        "parentId" : "4eaa31d2-3caa-475c-bc70-1ce875b12e0d",
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "The `ZManaged.lock` is already going to shift back if there is a failure, since that is a managed resource that describes shifting onto the specified executor and shifting back. What we need the `ZIO.shift` for is to make sure that if this stream is successful any continuation is shifted back to the original executor.",
        "createdAt" : "2021-05-17T03:24:07Z",
        "updatedAt" : "2021-05-17T03:24:07Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      },
      {
        "id" : "bc3c1db3-ddc1-4f68-ac5a-0957b77688b0",
        "parentId" : "4eaa31d2-3caa-475c-bc70-1ce875b12e0d",
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "All right, makes sense!",
        "createdAt" : "2021-05-17T09:24:31Z",
        "updatedAt" : "2021-05-17T09:24:31Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      }
    ],
    "commit" : "c2b36346c074aeefdff48234dd016db2ed65c0d1",
    "line" : 21,
    "diffHunk" : "@@ -1,1 +1955,1959 @@    ZStream.fromEffect(ZIO.descriptor).flatMap { descriptor =>\n      ZStream.managed(ZManaged.lock(executor)) *>\n        self <* ZStream.fromEffect(ZIO.shift(descriptor.executor))\n    }\n"
  },
  {
    "id" : "e8b0f28a-069f-4dca-9bf0-048087958e05",
    "prId" : 5048,
    "prUrl" : "https://github.com/zio/zio/pull/5048#pullrequestreview-668031160",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ef84d55f-602d-48b5-a373-fb5834f4b974",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "I am onboard with keeping this one the same, and introducing `fromHubManaged` for what is (now) this one here (the one that returns the stream in a managed).",
        "createdAt" : "2021-05-24T20:39:40Z",
        "updatedAt" : "2021-05-24T20:39:40Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      },
      {
        "id" : "596dd838-e102-4f55-a198-eefa6351123d",
        "parentId" : "ef84d55f-602d-48b5-a373-fb5834f4b974",
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "Done.",
        "createdAt" : "2021-05-25T16:02:09Z",
        "updatedAt" : "2021-05-25T16:02:09Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      }
    ],
    "commit" : "1e5f1347f8a9f403284eade93e49d91b601db01b",
    "line" : 150,
    "diffHunk" : "@@ -1,1 +3705,3709 @@   * Creates a stream from a subscription to a [[zio.ZHub]].\n   */\n  def fromHub[R, E, A](\n    hub: ZHub[Nothing, R, Any, E, Nothing, A],\n    maxChunkSize: Int = DefaultChunkSize"
  },
  {
    "id" : "2e5cedd7-f358-4862-a4d8-a8fbed4fdda8",
    "prId" : 4834,
    "prUrl" : "https://github.com/zio/zio/pull/4834#pullrequestreview-628807465",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "92b8c834-6ae3-4f30-ac5c-2c35ed416c01",
        "parentId" : null,
        "authorId" : "4bb412c7-1df7-4af3-848b-0dae636c2a24",
        "body" : "Just a heads up that adding a default parameter breaks backwards compatibility, like [here](https://github.com/zio/zio/pull/4205).",
        "createdAt" : "2021-03-23T17:06:02Z",
        "updatedAt" : "2021-04-11T13:18:36Z",
        "lastEditedBy" : "4bb412c7-1df7-4af3-848b-0dae636c2a24",
        "tags" : [
        ]
      },
      {
        "id" : "c13861ee-5598-4bb3-b52b-23992a57bcf0",
        "parentId" : "92b8c834-6ae3-4f30-ac5c-2c35ed416c01",
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "Yes. I think since we are not guaranteeing binary compatibility at this point that is okay. I think this is the right API and it should be a very easy change, but open to other perspectives.",
        "createdAt" : "2021-03-24T02:49:16Z",
        "updatedAt" : "2021-04-11T13:18:36Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      },
      {
        "id" : "f9a16b19-2f1d-49ce-8b63-c70149c361aa",
        "parentId" : "92b8c834-6ae3-4f30-ac5c-2c35ed416c01",
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "You could also add another method with 2 parameters, and the 1 parameter one can delegate to this one.",
        "createdAt" : "2021-04-06T10:20:50Z",
        "updatedAt" : "2021-04-11T13:18:36Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      }
    ],
    "commit" : "2c0d4342199de83dd498a76972d5d7159165e1a1",
    "line" : 32,
    "diffHunk" : "@@ -1,1 +3620,3624 @@   * Creates a stream from an iterator that may throw exceptions.\n   */\n  def fromIterator[A](iterator: => Iterator[A], maxChunkSize: Int = 1): ZStream[Any, Throwable, A] =\n    ZStream {\n      ZManaged"
  },
  {
    "id" : "7e14a9b7-81f0-4db1-b6e5-c9e9e49b1d03",
    "prId" : 4834,
    "prUrl" : "https://github.com/zio/zio/pull/4834#pullrequestreview-629455076",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "cbeac38e-f5c0-4380-974b-9eb4148a3f8f",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "Since you know the chunk size, it's probably more efficient to pre-allocate an array, fill it, convert to `Chunk`, and `take` the number of elements actually read (which is `<=` the chunk size).",
        "createdAt" : "2021-04-06T10:21:47Z",
        "updatedAt" : "2021-04-11T13:18:36Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      },
      {
        "id" : "96e20458-dd2b-4006-b9e1-7e499a8dff82",
        "parentId" : "cbeac38e-f5c0-4380-974b-9eb4148a3f8f",
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "Hinting the chunk builder with the desired size will have the same effect and avoid dealing with the array directly",
        "createdAt" : "2021-04-06T11:23:40Z",
        "updatedAt" : "2021-04-11T13:18:36Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      },
      {
        "id" : "b99c2f4b-7ab5-4cbb-ab06-886f08757f6c",
        "parentId" : "cbeac38e-f5c0-4380-974b-9eb4148a3f8f",
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "So the one watch out here is if the user uses an extremely large `maxChunkSize`. For example, if I say \"I'm not sure how many elements I have, but just read them all as one Chunk\" and do `fromIterator(iterator, Int.MaxValue)` I am going to blow up with an `OutOfMemoryError` because it is going to try to actually allocate an `Array` with `Int.MaxValue` size.",
        "createdAt" : "2021-04-06T12:11:55Z",
        "updatedAt" : "2021-04-11T13:18:36Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      },
      {
        "id" : "21284e36-6fd4-4882-8837-572b7f59b6b4",
        "parentId" : "cbeac38e-f5c0-4380-974b-9eb4148a3f8f",
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "My POV on this is that if it says \"chunk\" on the label, it's eager and must fit in memory. So I kinda think it's a fair tradeoff.",
        "createdAt" : "2021-04-06T19:41:19Z",
        "updatedAt" : "2021-04-11T13:18:36Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      },
      {
        "id" : "2628b460-3170-46eb-a74a-c94d5c393012",
        "parentId" : "cbeac38e-f5c0-4380-974b-9eb4148a3f8f",
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "I think that is right but just to push on this that means that `ZStream.fromIterator(Iterator(1, 2, 3, 4, 5), Int.MaxValue)` will blow up. I think definitely if the `Iterator` is actually too large to fit in memory it has to fail, but failing when the `Iterator` is small is a little counterintuitive.",
        "createdAt" : "2021-04-06T19:49:24Z",
        "updatedAt" : "2021-04-11T13:18:36Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      },
      {
        "id" : "e86a6aa3-918c-4784-ba37-ce9f8bccec70",
        "parentId" : "cbeac38e-f5c0-4380-974b-9eb4148a3f8f",
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "True. Maybe we could call it a `chunkHint` and that way we would be free to limit it to some reasonable value (our default chunk size, e.g.).",
        "createdAt" : "2021-04-06T22:22:14Z",
        "updatedAt" : "2021-04-11T13:18:36Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      }
    ],
    "commit" : "2c0d4342199de83dd498a76972d5d7159165e1a1",
    "line" : 39,
    "diffHunk" : "@@ -1,1 +3627,3631 @@          Pull.fail,\n          iterator =>\n            ZIO.effect {\n              if (maxChunkSize <= 1) {\n                if (iterator.isEmpty) Pull.end else Pull.emit(iterator.next())"
  },
  {
    "id" : "5d2ba4ae-9c3f-4ca3-9cee-88666f9c5108",
    "prId" : 4697,
    "prUrl" : "https://github.com/zio/zio/pull/4697#pullrequestreview-613892786",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6f77691e-cdca-4618-ab46-51daad2717db",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "Would `dedup` be a better name? (Not sure about that.)",
        "createdAt" : "2021-03-16T14:58:27Z",
        "updatedAt" : "2021-03-16T14:58:28Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      },
      {
        "id" : "a648717b-a457-4415-9252-d0e265d18388",
        "parentId" : "6f77691e-cdca-4618-ab46-51daad2717db",
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "Yes I wondered about that too. This is `distinctUntilChanged` in reactive streams and `removeDuplicates` in some other frameworks so `deduplicate` is definitely reasonable. The slightly tricky thing is it doesn't necessary remove all duplicates in the sense that if the stream emits `A, A, B, A` the resulting stream will be `A, B, A` so you will still have two `A` values just not two consecutive ones.",
        "createdAt" : "2021-03-16T18:51:16Z",
        "updatedAt" : "2021-03-17T06:52:56Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      },
      {
        "id" : "e97d9732-fa0d-40f3-9d53-c4ad4af10b2f",
        "parentId" : "6f77691e-cdca-4618-ab46-51daad2717db",
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "I'm ok with `changes` especially if there is no clear pattern.",
        "createdAt" : "2021-03-17T03:29:57Z",
        "updatedAt" : "2021-03-17T03:29:57Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      }
    ],
    "commit" : "9808e60abc15338ee3f20046b2a6382d0c0fd997",
    "line" : 9,
    "diffHunk" : "@@ -1,1 +560,564 @@   * elements are equal.\n   */\n  def changes: ZStream[R, E, O] =\n    changesWith(_ == _)\n"
  },
  {
    "id" : "3cc3652f-eaca-4403-b556-deb0eae01053",
    "prId" : 4458,
    "prUrl" : "https://github.com/zio/zio/pull/4458#pullrequestreview-539309346",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1930bee6-719d-4bf5-a65c-1bc6502ea8b2",
        "parentId" : null,
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "In `refineOrDieWith` wouldn't it be better to use `catchAll` and `die` instead of throwing?",
        "createdAt" : "2020-11-26T13:12:18Z",
        "updatedAt" : "2020-11-26T13:21:17Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      },
      {
        "id" : "b19100ee-cf2f-43c5-94a1-0f5c2f4d8b2b",
        "parentId" : "1930bee6-719d-4bf5-a65c-1bc6502ea8b2",
        "authorId" : "6080cd8f-e671-4d49-a54c-b6159456ac0e",
        "body" : "Actually, yes, one sec.",
        "createdAt" : "2020-11-26T13:14:28Z",
        "updatedAt" : "2020-11-26T13:21:17Z",
        "lastEditedBy" : "6080cd8f-e671-4d49-a54c-b6159456ac0e",
        "tags" : [
        ]
      },
      {
        "id" : "76d152f5-2db2-49cd-a30c-48938926f54f",
        "parentId" : "1930bee6-719d-4bf5-a65c-1bc6502ea8b2",
        "authorId" : "6080cd8f-e671-4d49-a54c-b6159456ac0e",
        "body" : "Done in ae53e0504e6fc06fc6407b9aa6b5f0d498496c92",
        "createdAt" : "2020-11-26T13:21:23Z",
        "updatedAt" : "2020-11-26T13:21:24Z",
        "lastEditedBy" : "6080cd8f-e671-4d49-a54c-b6159456ac0e",
        "tags" : [
        ]
      }
    ],
    "commit" : "ae53e0504e6fc06fc6407b9aa6b5f0d498496c92",
    "line" : 8,
    "diffHunk" : "@@ -1,1 +2277,2281 @@    pf: PartialFunction[E, E1]\n  )(implicit ev1: E <:< Throwable, ev2: CanFail[E]): ZStream[R, E1, O] =\n    refineOrDieWith(pf)(ev1)\n\n  /**"
  },
  {
    "id" : "d7005b62-5ef7-40a0-9ef9-e90f260b7eef",
    "prId" : 4166,
    "prUrl" : "https://github.com/zio/zio/pull/4166#pullrequestreview-486047799",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "59f3bed2-7d72-4478-ad16-468e3d5d9338",
        "parentId" : null,
        "authorId" : "4bb412c7-1df7-4af3-848b-0dae636c2a24",
        "body" : "Interesting. I compared with my [suggestion here](https://github.com/zio/zio/pull/2442/files#r355213169) and that one got #4119 right, but would also experience #4118 ",
        "createdAt" : "2020-09-10T13:05:09Z",
        "updatedAt" : "2020-09-10T13:05:09Z",
        "lastEditedBy" : "4bb412c7-1df7-4af3-848b-0dae636c2a24",
        "tags" : [
        ]
      },
      {
        "id" : "ef1ea6a6-af89-4b4b-86e1-1c2077268435",
        "parentId" : "59f3bed2-7d72-4478-ad16-468e3d5d9338",
        "authorId" : "02debe6b-f37b-49a5-a03c-ce2417750ed1",
        "body" : "@svroonland are you sure? it checks on every pull whether the promise is done and there's a unit test for that case.",
        "createdAt" : "2020-09-10T13:21:10Z",
        "updatedAt" : "2020-09-10T13:21:11Z",
        "lastEditedBy" : "02debe6b-f37b-49a5-a03c-ce2417750ed1",
        "tags" : [
        ]
      },
      {
        "id" : "32c2bf37-cf69-484d-a1d4-5f3b6a302ef4",
        "parentId" : "59f3bed2-7d72-4478-ad16-468e3d5d9338",
        "authorId" : "4bb412c7-1df7-4af3-848b-0dae636c2a24",
        "body" : "@luis3m Ah yes on closer look, you are right. So they would appear to be equivalent then..? (just for learning purposes, you can disregard this comment thread when it comes to this PR)",
        "createdAt" : "2020-09-10T13:27:07Z",
        "updatedAt" : "2020-09-10T13:27:07Z",
        "lastEditedBy" : "4bb412c7-1df7-4af3-848b-0dae636c2a24",
        "tags" : [
        ]
      },
      {
        "id" : "2223dc4e-16a4-4603-aec2-4a8dbc419554",
        "parentId" : "59f3bed2-7d72-4478-ad16-468e3d5d9338",
        "authorId" : "02debe6b-f37b-49a5-a03c-ce2417750ed1",
        "body" : "@svroonland no worries. Yes, they are.",
        "createdAt" : "2020-09-10T15:19:32Z",
        "updatedAt" : "2020-09-10T15:19:32Z",
        "lastEditedBy" : "02debe6b-f37b-49a5-a03c-ce2417750ed1",
        "tags" : [
        ]
      }
    ],
    "commit" : "e77470d69bc5e60d624d0a83b376352f7a1a60b4",
    "line" : 19,
    "diffHunk" : "@@ -1,1 +1764,1768 @@        as    <- self.process\n        done  <- Ref.makeManaged(false)\n        asPull = p.await.asSomeError *> done.set(true) *> Pull.end\n        pull = (done.get <*> p.isDone) flatMap {\n                 case (true, _) => Pull.end"
  },
  {
    "id" : "f50f7d7f-b8ab-4694-810c-8539dc54e68b",
    "prId" : 4141,
    "prUrl" : "https://github.com/zio/zio/pull/4141#pullrequestreview-478102312",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0b6ee8ee-cf98-4d94-97a0-6edba728c8de",
        "parentId" : null,
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "Great fix 👍 ",
        "createdAt" : "2020-08-29T06:15:17Z",
        "updatedAt" : "2020-08-29T20:13:36Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      }
    ],
    "commit" : "7a8967d5b992d1769851bcf7974b53a7f7f4c556",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +231,235 @@        sdriver   <- schedule.driver.toManaged_\n        lastChunk <- ZRef.makeManaged[Chunk[P]](Chunk.empty)\n        producer   = Take.fromPull(pull).repeatWhileM(take => handoff.offer(take).as(take.isSuccess))\n        consumer = {\n          // Advances the state of the schedule, which may or may not terminate"
  },
  {
    "id" : "1c3298d6-4b5c-4113-8a6d-2896068b5cff",
    "prId" : 4097,
    "prUrl" : "https://github.com/zio/zio/pull/4097#pullrequestreview-467949712",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "89014bbf-8366-40ed-b6a9-5607945e274d",
        "parentId" : null,
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "The corresponding method on `ZIO` guarantees the execution of `cleanup` even in the face of interruption, and also executes it uninterruptibly.\r\n\r\nI don't think it's critical to replicate those same semantics here, but let's add a note on the scaladoc about this difference.",
        "createdAt" : "2020-08-14T20:31:45Z",
        "updatedAt" : "2020-08-15T05:33:25Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      },
      {
        "id" : "1d8f56f0-394a-4237-abe3-2fd772ce28c3",
        "parentId" : "89014bbf-8366-40ed-b6a9-5607945e274d",
        "authorId" : "61888220-cb99-4f2d-91c3-d7576394bf23",
        "body" : "Yeah I'm not sure if it's possible to provide the same semantics.\r\nI added a note to the scaladoc.",
        "createdAt" : "2020-08-15T05:36:12Z",
        "updatedAt" : "2020-08-15T05:36:12Z",
        "lastEditedBy" : "61888220-cb99-4f2d-91c3-d7576394bf23",
        "tags" : [
        ]
      }
    ],
    "commit" : "caff4b20c959a66d478f911128865903fafa1d29",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +2064,2068 @@\n  /**\n   * Runs the specified effect if this stream fails, providing the error to the effect if it exists.\n   *\n   * Note: Unlike [[ZIO.onError]], there is no guarantee that the provided effect will not be interrupted."
  },
  {
    "id" : "e5b1900e-77a4-49de-9fd0-7bcaab5e95d1",
    "prId" : 3983,
    "prUrl" : "https://github.com/zio/zio/pull/3983#pullrequestreview-451964812",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "16ad877a-96c7-4070-9fac-0b1fcd7de242",
        "parentId" : null,
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "Same - can we keep it on the class?",
        "createdAt" : "2020-07-20T21:15:42Z",
        "updatedAt" : "2020-07-20T21:15:46Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      }
    ],
    "commit" : "5ffc085f7b7a2c2944b28e9ee89c9075b414074a",
    "line" : 19,
    "diffHunk" : "@@ -1,1 +4055,4059 @@     * Keeps some of the errors, and terminates the fiber with the rest.\n     */\n    def refineToOrDie[E1 <: E: ClassTag](implicit ev: CanFail[E]): ZStream[R, E1, A] =\n      self.refineOrDie { case e: E1 => e }\n  }"
  },
  {
    "id" : "14ccd185-81d2-4af4-9777-9f3b6168f04d",
    "prId" : 3691,
    "prUrl" : "https://github.com/zio/zio/pull/3691#pullrequestreview-417287682",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3e6ab52c-f6aa-45d8-9a30-330d813d3f3d",
        "parentId" : null,
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "This is actually an interesting approach we could take for all concurrent combinators. It's easier to reason about because it doesn't introduce any implicit buffers. If the user wants a buffer, they can easily add one with `.buffer`.\r\n\r\n@regiskuckaertz ",
        "createdAt" : "2020-05-23T14:35:25Z",
        "updatedAt" : "2020-05-24T18:18:39Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      },
      {
        "id" : "0619f6ba-511f-44af-bb41-88c15090f6c5",
        "parentId" : "3e6ab52c-f6aa-45d8-9a30-330d813d3f3d",
        "authorId" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "body" : "Yes! and Handoff is quite nice as it acts as a semaphore between the two fibers as well.",
        "createdAt" : "2020-05-23T15:38:33Z",
        "updatedAt" : "2020-05-24T18:18:39Z",
        "lastEditedBy" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "tags" : [
        ]
      }
    ],
    "commit" : "0da3442894d7f1c0f85fb99246aecd40e7a86fc7",
    "line" : 30,
    "diffHunk" : "@@ -1,1 +1992,1996 @@\n      for {\n        handoff <- ZStream.Handoff.make[Take[E1, O3]].toManaged_\n        done    <- RefM.makeManaged[Option[Boolean]](None)\n        chunksL <- self.process"
  },
  {
    "id" : "9d77fd65-cae7-4f3c-9080-c29cc2eb3006",
    "prId" : 3669,
    "prUrl" : "https://github.com/zio/zio/pull/3669#pullrequestreview-417284622",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9d399298-d255-41e1-b674-6683779ca5d4",
        "parentId" : null,
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "Let's deprecate the `Take.End` in here too.",
        "createdAt" : "2020-05-23T09:10:20Z",
        "updatedAt" : "2020-05-23T14:51:00Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      },
      {
        "id" : "2a72bb9a-9c8c-4536-a214-a16f471ac585",
        "parentId" : "9d399298-d255-41e1-b674-6683779ca5d4",
        "authorId" : "02debe6b-f37b-49a5-a03c-ce2417750ed1",
        "body" : "@iravid done",
        "createdAt" : "2020-05-23T14:51:43Z",
        "updatedAt" : "2020-05-23T14:51:43Z",
        "lastEditedBy" : "02debe6b-f37b-49a5-a03c-ce2417750ed1",
        "tags" : [
        ]
      }
    ],
    "commit" : "abccf77017b6a16b8c68f199aa5ff03161973f58",
    "line" : 313,
    "diffHunk" : "@@ -1,1 +3729,3733 @@  type Take[+E, +A] = Exit[Option[E], Chunk[A]]\n\n  object Take {\n    @deprecated(\"use zio.stream.Take.end instead\", \"1.0.0\")\n    val End: Exit[Option[Nothing], Nothing] = Exit.fail(None)"
  },
  {
    "id" : "6cba7e7c-938c-4d64-9329-160d7f5f833a",
    "prId" : 3569,
    "prUrl" : "https://github.com/zio/zio/pull/3569#pullrequestreview-409461467",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0cee7ffc-673a-4491-b476-b3fc58a2365e",
        "parentId" : null,
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "Wow this is *really* nice. Great work @simpadjo and @luis3m.",
        "createdAt" : "2020-05-11T19:22:12Z",
        "updatedAt" : "2020-05-11T19:22:12Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      }
    ],
    "commit" : "a24359db18cede713bebdb5dd228fd9410740e8a",
    "line" : 27,
    "diffHunk" : "@@ -1,1 +2539,2543 @@      pull    <- process\n    } yield {\n      def unfoldPull: Iterator[Either[E, O]] =\n        runtime.unsafeRunSync(pull) match {\n          case Exit.Success(chunk) => chunk.iterator.map(Right(_)) ++ unfoldPull"
  },
  {
    "id" : "618f0f07-eb32-4a39-a277-46eac94205a7",
    "prId" : 3562,
    "prUrl" : "https://github.com/zio/zio/pull/3562#pullrequestreview-411884172",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2beb9042-33a5-42d9-b55e-4f235290c4a7",
        "parentId" : null,
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "Is it possible to use catchAllCause for this combinator? Implementation looks fairly similar.",
        "createdAt" : "2020-05-09T21:13:02Z",
        "updatedAt" : "2020-05-14T14:47:19Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      },
      {
        "id" : "1859181b-99e0-42f9-a090-8565104fce14",
        "parentId" : "2beb9042-33a5-42d9-b55e-4f235290c4a7",
        "authorId" : "02debe6b-f37b-49a5-a03c-ce2417750ed1",
        "body" : "I will take a look",
        "createdAt" : "2020-05-09T21:23:55Z",
        "updatedAt" : "2020-05-14T14:47:19Z",
        "lastEditedBy" : "02debe6b-f37b-49a5-a03c-ce2417750ed1",
        "tags" : [
        ]
      },
      {
        "id" : "7a69a89a-a701-4860-b5f1-ac498935e314",
        "parentId" : "2beb9042-33a5-42d9-b55e-4f235290c4a7",
        "authorId" : "02debe6b-f37b-49a5-a03c-ce2417750ed1",
        "body" : "Given that `timeoutErrorCause` has been implemented as you suggested, the following implementation comes to mind:\r\n\r\n```scala\r\nfinal def timeoutTo[R1 <: R, E1 >: E, O2 >: O](\r\n    d: Duration\r\n)(that: ZStream[R1, E1, O2]): ZStream[R1 with Clock, E1, O2] = {\r\n  object StreamTimeout extends Throwable\r\n  self.timeoutErrorCause(Cause.die(StreamTimeout))(d).catchSomeCause { case Cause.Die(StreamTimeout) => that }\r\n}\r\n```\r\n\r\nIt requires implementing `catchSomeCause` though which I can add (maybe in a separate PR). @iravid what do you think?",
        "createdAt" : "2020-05-09T22:25:46Z",
        "updatedAt" : "2020-05-14T14:47:19Z",
        "lastEditedBy" : "02debe6b-f37b-49a5-a03c-ce2417750ed1",
        "tags" : [
        ]
      },
      {
        "id" : "bc7646a5-4292-4a3d-8323-90f7385dc7d5",
        "parentId" : "2beb9042-33a5-42d9-b55e-4f235290c4a7",
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "Sounds good for a follow up if you have the cycles later on. The current implementation looks good for this PR! Thanks!",
        "createdAt" : "2020-05-14T05:53:56Z",
        "updatedAt" : "2020-05-14T14:47:19Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      },
      {
        "id" : "db97334d-7f08-441c-9878-e385397c060f",
        "parentId" : "2beb9042-33a5-42d9-b55e-4f235290c4a7",
        "authorId" : "02debe6b-f37b-49a5-a03c-ce2417750ed1",
        "body" : "Cool, I will submit a separate PR later with `catchSomeCause` and the refactor of `timeoutTo`",
        "createdAt" : "2020-05-14T14:50:26Z",
        "updatedAt" : "2020-05-14T14:50:26Z",
        "lastEditedBy" : "02debe6b-f37b-49a5-a03c-ce2417750ed1",
        "tags" : [
        ]
      }
    ],
    "commit" : "cd576db4137a4ca11aebe1e44ae8fa6561cb0eec",
    "line" : 52,
    "diffHunk" : "@@ -1,1 +2574,2578 @@    ZStream[R1 with Clock, E1, O2] {\n      for {\n        currStream   <- Ref.make[ZIO[R1, Option[E1], Chunk[O2]]](Pull.end).toManaged_\n        switchStream <- ZManaged.switchable[R1, Nothing, ZIO[R1, Option[E1], Chunk[O2]]]\n        switched     <- Ref.make(false).toManaged_"
  },
  {
    "id" : "9492c135-f4a0-481f-9afc-2a7ddd1da2cb",
    "prId" : 3514,
    "prUrl" : "https://github.com/zio/zio/pull/3514#pullrequestreview-407396599",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c7317306-b971-414b-b57b-6b8f08b3e5ed",
        "parentId" : null,
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "@fagossa Could we add a variant that also adds start/end markers? This could simply be `ZStream(start) ++ intersperse(middle) ++ ZStream(end)`.",
        "createdAt" : "2020-05-07T11:12:36Z",
        "updatedAt" : "2020-05-07T11:51:07Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      },
      {
        "id" : "f6f00f6d-9e49-405e-b3a0-532652885be4",
        "parentId" : "c7317306-b971-414b-b57b-6b8f08b3e5ed",
        "authorId" : "d0fd50f4-2db6-438e-b980-367d69a753a5",
        "body" : "done!",
        "createdAt" : "2020-05-07T11:51:34Z",
        "updatedAt" : "2020-05-07T11:51:34Z",
        "lastEditedBy" : "d0fd50f4-2db6-438e-b980-367d69a753a5",
        "tags" : [
        ]
      }
    ],
    "commit" : "df2363938b2cb790e21ee876f06a76d962dcb599",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +1530,1534 @@   * Intersperse stream with provided element similar to <code>List.mkString</code>.\n   */\n  final def intersperse[O1 >: O](middle: O1): ZStream[R, E, O1] =\n    ZStream {\n      for {"
  },
  {
    "id" : "085bd687-daeb-4960-b9f9-7785e1c0ecf5",
    "prId" : 3458,
    "prUrl" : "https://github.com/zio/zio/pull/3458#pullrequestreview-401247458",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9f455410-07da-4df0-a4b9-6475d998ba3c",
        "parentId" : null,
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "Nice!!!! We can probably apply this in a bunch of other places throughout the package :-)",
        "createdAt" : "2020-04-27T19:10:37Z",
        "updatedAt" : "2020-04-27T19:10:37Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      }
    ],
    "commit" : "d904e580f56ea1896296db7c7e65579473091375",
    "line" : 19,
    "diffHunk" : "@@ -1,1 +643,647 @@        right <- that.process.mapM(BufferedPull.make[R1, E1, O2](_))\n        pull <- ZStream\n                 .unfoldM(s)(s => f(s, left.pullElement, right.pullElement).flatMap(ZIO.done(_).optional))\n                 .process\n      } yield pull"
  },
  {
    "id" : "2cde70a1-fe94-417f-ae17-0aba2c6b81a5",
    "prId" : 2891,
    "prUrl" : "https://github.com/zio/zio/pull/2891#pullrequestreview-358347554",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a9dad05f-ea48-4b50-bbf6-de3337dfb95b",
        "parentId" : null,
        "authorId" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "body" : "what if offer returns false in this case?",
        "createdAt" : "2020-02-13T16:02:13Z",
        "updatedAt" : "2020-02-13T16:05:14Z",
        "lastEditedBy" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "tags" : [
        ]
      },
      {
        "id" : "97d1c06c-4ee4-412e-b66a-450f71a133f6",
        "parentId" : "a9dad05f-ea48-4b50-bbf6-de3337dfb95b",
        "authorId" : "6bab7be3-690b-49f9-9a0d-a8415f4c0c8e",
        "body" : "Good question. It will not happen, because this code is blocked until the queue is drained (it is always waiting on the last enqueued promise, and the taker always unblocks promises as it encounters them), so there will always be space in the queue for this offer, no matter its type.",
        "createdAt" : "2020-02-13T16:09:03Z",
        "updatedAt" : "2020-02-13T16:09:03Z",
        "lastEditedBy" : "6bab7be3-690b-49f9-9a0d-a8415f4c0c8e",
        "tags" : [
        ]
      }
    ],
    "commit" : "05f00b9b1cbe6e2ac8ceb20daf2aa67958360768",
    "line" : 28,
    "diffHunk" : "@@ -1,1 +789,793 @@              p     <- Promise.make[Nothing, Unit]\n              _     <- queue.offer((take, p))\n              _     <- ref.set(p)\n              _     <- p.await\n            } yield ()"
  },
  {
    "id" : "98353baf-5291-414c-80a2-6d5a3cbe58c7",
    "prId" : 2891,
    "prUrl" : "https://github.com/zio/zio/pull/2891#pullrequestreview-358356885",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "61df2117-b18a-4b7f-b941-2bdce644f018",
        "parentId" : null,
        "authorId" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "body" : "just curious: why is it necessary to wait on error/failure?",
        "createdAt" : "2020-02-13T16:04:34Z",
        "updatedAt" : "2020-02-13T16:05:14Z",
        "lastEditedBy" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "tags" : [
        ]
      },
      {
        "id" : "176b19fe-bb1f-463f-b61e-5a9c5d8f58b8",
        "parentId" : "61df2117-b18a-4b7f-b941-2bdce644f018",
        "authorId" : "6bab7be3-690b-49f9-9a0d-a8415f4c0c8e",
        "body" : "Continuing my comment from above, we are forcing a complete pause of the pipeline, so that no error is dropped. This way we wait until the whole queue is drained, enqueue the error, and wait until it is dequeued.",
        "createdAt" : "2020-02-13T16:09:55Z",
        "updatedAt" : "2020-02-13T16:09:55Z",
        "lastEditedBy" : "6bab7be3-690b-49f9-9a0d-a8415f4c0c8e",
        "tags" : [
        ]
      },
      {
        "id" : "7494ed4c-3186-4dc1-97e2-db7a0eab97db",
        "parentId" : "61df2117-b18a-4b7f-b941-2bdce644f018",
        "authorId" : "6bab7be3-690b-49f9-9a0d-a8415f4c0c8e",
        "body" : "It is undesirable to silently swallow errors.",
        "createdAt" : "2020-02-13T16:10:15Z",
        "updatedAt" : "2020-02-13T16:10:15Z",
        "lastEditedBy" : "6bab7be3-690b-49f9-9a0d-a8415f4c0c8e",
        "tags" : [
        ]
      },
      {
        "id" : "95be8460-1771-4f8d-88f3-961ba1b2739c",
        "parentId" : "61df2117-b18a-4b7f-b941-2bdce644f018",
        "authorId" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "body" : "aaaah yeah I see, in case the queue is dropping when full, you may lose errors indeed. Great 👍 ",
        "createdAt" : "2020-02-13T16:20:27Z",
        "updatedAt" : "2020-02-13T16:20:28Z",
        "lastEditedBy" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "tags" : [
        ]
      }
    ],
    "commit" : "05f00b9b1cbe6e2ac8ceb20daf2aa67958360768",
    "line" : 24,
    "diffHunk" : "@@ -1,1 +785,789 @@          case _ =>\n            for {\n              latch <- ref.get\n              _     <- latch.await\n              p     <- Promise.make[Nothing, Unit]"
  },
  {
    "id" : "4c90b8ec-78a1-45dc-8849-e08a92388b14",
    "prId" : 2752,
    "prUrl" : "https://github.com/zio/zio/pull/2752#pullrequestreview-350273855",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e147f844-7c0e-49ef-babc-10c66f4ae1d5",
        "parentId" : null,
        "authorId" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "body" : "I looked through code and it seems we don't do it often enough, but I wonder if there should be `Promise.succeed[Now]` and `Promise.fail[Now]` constructors.",
        "createdAt" : "2020-01-29T17:04:55Z",
        "updatedAt" : "2020-01-29T17:04:56Z",
        "lastEditedBy" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "tags" : [
        ]
      }
    ],
    "commit" : "cdd8b449057ce61aee0aa0d42344154b295a9d53",
    "line" : 65,
    "diffHunk" : "@@ -1,1 +832,836 @@        queue <- Queue.sliding[(Take[E, A], Promise[Nothing, Unit])](capacity).toManaged(_.shutdown)\n        start <- Promise.make[Nothing, Unit].toManaged_\n        _     <- start.succeed(()).toManaged_\n        ref   <- Ref.make(start).toManaged_\n        done  <- Ref.make(false).toManaged_"
  },
  {
    "id" : "e355ec5c-b47e-4401-83a4-1b83fe725bcb",
    "prId" : 2674,
    "prUrl" : "https://github.com/zio/zio/pull/2674#pullrequestreview-346181903",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "de99f456-adcb-4022-b92f-317b43f93c17",
        "parentId" : null,
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "Hmm why did we eagerly execute the finalizer here?",
        "createdAt" : "2020-01-21T20:21:13Z",
        "updatedAt" : "2020-01-21T21:27:13Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      },
      {
        "id" : "b4a097ec-d119-4a54-9878-c9b27cf11792",
        "parentId" : "de99f456-adcb-4022-b92f-317b43f93c17",
        "authorId" : "6bab7be3-690b-49f9-9a0d-a8415f4c0c8e",
        "body" : "The only thing I didn't think completely through in this PR because I was too eager to put it out is the fact that we lose the error signal through the `Exit`. What do you think we should do?",
        "createdAt" : "2020-01-21T20:25:30Z",
        "updatedAt" : "2020-01-21T21:27:13Z",
        "lastEditedBy" : "6bab7be3-690b-49f9-9a0d-a8415f4c0c8e",
        "tags" : [
        ]
      },
      {
        "id" : "8adf1185-783f-4e3f-b478-eed2f9949602",
        "parentId" : "de99f456-adcb-4022-b92f-317b43f93c17",
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "Ok, convinvced myself it wasn't needed 👍 ",
        "createdAt" : "2020-01-21T20:26:36Z",
        "updatedAt" : "2020-01-21T21:27:13Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      },
      {
        "id" : "07ea1ed4-2a62-4dde-a1f2-c52420ce51a5",
        "parentId" : "de99f456-adcb-4022-b92f-317b43f93c17",
        "authorId" : "6bab7be3-690b-49f9-9a0d-a8415f4c0c8e",
        "body" : "`finalizerRef` for the win!",
        "createdAt" : "2020-01-21T20:29:42Z",
        "updatedAt" : "2020-01-21T21:27:13Z",
        "lastEditedBy" : "6bab7be3-690b-49f9-9a0d-a8415f4c0c8e",
        "tags" : [
        ]
      },
      {
        "id" : "45caaee4-4b6b-473a-bbf6-9fa8232c4821",
        "parentId" : "de99f456-adcb-4022-b92f-317b43f93c17",
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "Good point regarding the error. Let's add another Ref[Option[Cause[E]]] that is set on error and used in the finalizer?",
        "createdAt" : "2020-01-21T20:32:28Z",
        "updatedAt" : "2020-01-21T21:27:13Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      },
      {
        "id" : "cae24aa8-35fd-44cd-b023-9097f7b61a44",
        "parentId" : "de99f456-adcb-4022-b92f-317b43f93c17",
        "authorId" : "6bab7be3-690b-49f9-9a0d-a8415f4c0c8e",
        "body" : "No need, `finalizerRef` takes care of it.",
        "createdAt" : "2020-01-21T20:33:26Z",
        "updatedAt" : "2020-01-21T21:27:13Z",
        "lastEditedBy" : "6bab7be3-690b-49f9-9a0d-a8415f4c0c8e",
        "tags" : [
        ]
      },
      {
        "id" : "5a9f3ae1-f85a-4cb7-8584-e603364cdeff",
        "parentId" : "de99f456-adcb-4022-b92f-317b43f93c17",
        "authorId" : "6bab7be3-690b-49f9-9a0d-a8415f4c0c8e",
        "body" : "How can we craft a test that confirms this?",
        "createdAt" : "2020-01-21T20:35:36Z",
        "updatedAt" : "2020-01-21T21:27:13Z",
        "lastEditedBy" : "6bab7be3-690b-49f9-9a0d-a8415f4c0c8e",
        "tags" : [
        ]
      },
      {
        "id" : "5dcfe101-86df-4200-ad34-20561a8a5d35",
        "parentId" : "de99f456-adcb-4022-b92f-317b43f93c17",
        "authorId" : "6bab7be3-690b-49f9-9a0d-a8415f4c0c8e",
        "body" : "> Good point regarding the error. Let's add another Ref[Option[Cause[E]]] that is set on error and used in the finalizer?\r\n\r\nAlso on which error? What if there is more than one?\r\n",
        "createdAt" : "2020-01-21T20:37:58Z",
        "updatedAt" : "2020-01-21T21:27:13Z",
        "lastEditedBy" : "6bab7be3-690b-49f9-9a0d-a8415f4c0c8e",
        "tags" : [
        ]
      },
      {
        "id" : "fe595c90-7d37-48e9-88dd-360916a9fcb8",
        "parentId" : "de99f456-adcb-4022-b92f-317b43f93c17",
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "The `Exit[Any, Any]` required in the finalizer is the one that results from the `ZManaged#use` block. It's a bit hard to see it here, but this should result from the terminal operation consuming the stream (`run`/`foreach` etc).\r\n\r\nSo the Exit value here really depends if the error was allowed to fail the use block or not. Which is to say - if there were no recovery operators downstream, we should see the error propagate back to the `finalizerRef`.\r\n\r\nYou can test this by flatMapping elements in a stream to a stream that differentiates between success/failure in its finalizer.",
        "createdAt" : "2020-01-21T20:48:05Z",
        "updatedAt" : "2020-01-21T21:27:13Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      },
      {
        "id" : "5a164ab0-657c-4e93-a105-f940d05ad70e",
        "parentId" : "de99f456-adcb-4022-b92f-317b43f93c17",
        "authorId" : "6bab7be3-690b-49f9-9a0d-a8415f4c0c8e",
        "body" : "Exactly, this was my intuition too. I'll add the test.",
        "createdAt" : "2020-01-21T20:50:20Z",
        "updatedAt" : "2020-01-21T21:27:13Z",
        "lastEditedBy" : "6bab7be3-690b-49f9-9a0d-a8415f4c0c8e",
        "tags" : [
        ]
      }
    ],
    "commit" : "319339866b914cee0ca9e59952a0862d49f1ac40",
    "line" : 25,
    "diffHunk" : "@@ -1,1 +1304,1308 @@      currPull.get.flatten.catchAllCause { c =>\n        Cause.sequenceCauseOption(c) match {\n          case Some(e) => Pull.halt(e)\n          case None =>\n            (finalizer.get.flatMap(_(Exit.succeed(()))) *>"
  },
  {
    "id" : "cefbea68-f1a2-4da2-b47d-627206fa6440",
    "prId" : 2580,
    "prUrl" : "https://github.com/zio/zio/pull/2580#pullrequestreview-355525548",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7536286a-f8a9-4431-909a-5df9bb141b97",
        "parentId" : null,
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "This is looking really good now. I think the only thing left is the internal state machine feels a little heavy, especially when we aren't managing concurrent state. Could we just implement the iterator as something like this?\r\n\r\n```scala\r\nnew Iterator[Either[E, A]] {\r\n  var nextTake: Take[E, A] = null\r\n  def unsafeTake(): Unit =\r\n    nextTake = runtime.unsafeRun(Take.fromPull(pull))\r\n  def hasNext: Boolean = {\r\n    if (nextTake == null) {\r\n      unsafeTake()\r\n    }\r\n    !nextTake.isEnd\r\n  }\r\n  def next(): Either[E, A] = {\r\n    if (nextTake == null) {\r\n      unsafeTake()\r\n    }\r\n    val take = nextTake match {\r\n      case Take.End      => throw new NoSuchElementException(\"next on empty iterator\")\r\n      case Take.Fail(e)  => Left(e.failureOrCause.fold(identity, c => throw FiberFailure(c)))\r\n      case Take.Value(a) => Right(a)\r\n    }\r\n    nextTake = null\r\n    take\r\n  }\r\n}\r\n```",
        "createdAt" : "2020-02-07T22:17:59Z",
        "updatedAt" : "2020-02-08T02:58:03Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      },
      {
        "id" : "d87b836c-e7b3-4dca-a9d4-ee2cea6f140c",
        "parentId" : "7536286a-f8a9-4431-909a-5df9bb141b97",
        "authorId" : "1724c5b2-b76c-4a84-8962-52e808e74b8a",
        "body" : "Indeed, so much better !",
        "createdAt" : "2020-02-08T02:58:32Z",
        "updatedAt" : "2020-02-08T02:58:33Z",
        "lastEditedBy" : "1724c5b2-b76c-4a84-8962-52e808e74b8a",
        "tags" : [
        ]
      }
    ],
    "commit" : "abc8c7e772cb1ce488f0b3129dee681045241c86",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +2484,2488 @@      runtime <- ZIO.runtime[R].toManaged_\n    } yield {\n      new Iterator[Either[E, A]] {\n\n        var nextTake: Take[E, A] = null"
  },
  {
    "id" : "e8ba2b19-758e-42a7-848d-bfd96c90c31d",
    "prId" : 2524,
    "prUrl" : "https://github.com/zio/zio/pull/2524#pullrequestreview-336643589",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a4939da1-ccaa-4265-9458-0ca9d5c7dc79",
        "parentId" : null,
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "Was it necessary to change the formulation here?",
        "createdAt" : "2019-12-26T05:09:58Z",
        "updatedAt" : "2020-01-01T10:44:53Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      },
      {
        "id" : "9f932b00-263b-46e2-8469-210af50a92e6",
        "parentId" : "a4939da1-ccaa-4265-9458-0ca9d5c7dc79",
        "authorId" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "body" : "I think it does if we adopt the stance that failed elements are not counted in, but there needs to be a fallback for when an element fails.\r\n```scala\r\nfor {\r\n  as <- self.process\r\n  counter <- Ref.make(n).toManaged_\r\n  pull = ref.get.flatMap {\r\n    case 0 => Pull.end\r\n    case n => as.foldM({\r\n      case None => Pull.end\r\n      case _ => pull\r\n    },\r\n    a => counter.update(_ - 1) *> Pull.emit(a)\r\n  }\r\nyield pull\r\n```",
        "createdAt" : "2019-12-26T14:07:30Z",
        "updatedAt" : "2020-01-01T10:44:53Z",
        "lastEditedBy" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "tags" : [
        ]
      },
      {
        "id" : "bc2a4b09-71f3-4a55-b889-7b0d23c150be",
        "parentId" : "a4939da1-ccaa-4265-9458-0ca9d5c7dc79",
        "authorId" : "6bab7be3-690b-49f9-9a0d-a8415f4c0c8e",
        "body" : "This here swallows the error right? I think we do need to propagate it downstream, the user will have enough power to deal with it in the future.",
        "createdAt" : "2019-12-26T14:11:35Z",
        "updatedAt" : "2020-01-01T10:44:53Z",
        "lastEditedBy" : "6bab7be3-690b-49f9-9a0d-a8415f4c0c8e",
        "tags" : [
        ]
      },
      {
        "id" : "ee943b5a-5d1f-45de-94e6-0ad046ce293c",
        "parentId" : "a4939da1-ccaa-4265-9458-0ca9d5c7dc79",
        "authorId" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "body" : "or in the past 🤗 with `stream.either.take(n).absolve`. I also think it's more intuitive that \"take the first n\" implies the first n _successful_ elements in this context, as errors are only first-class when they are inside the value channel.",
        "createdAt" : "2019-12-26T17:53:15Z",
        "updatedAt" : "2020-01-01T10:44:53Z",
        "lastEditedBy" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "tags" : [
        ]
      },
      {
        "id" : "640390e6-7b46-4466-8e94-5fcecfdca12d",
        "parentId" : "a4939da1-ccaa-4265-9458-0ca9d5c7dc79",
        "authorId" : "6bab7be3-690b-49f9-9a0d-a8415f4c0c8e",
        "body" : "So how does this translate to the \"counts (or doesn't) towards the `n` budget\" debate?",
        "createdAt" : "2019-12-26T17:55:54Z",
        "updatedAt" : "2020-01-01T10:44:53Z",
        "lastEditedBy" : "6bab7be3-690b-49f9-9a0d-a8415f4c0c8e",
        "tags" : [
        ]
      },
      {
        "id" : "177fac46-f812-4372-8c9a-eb3715cba641",
        "parentId" : "a4939da1-ccaa-4265-9458-0ca9d5c7dc79",
        "authorId" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "body" : "The version above doesn't count errors in the budget.",
        "createdAt" : "2019-12-26T21:10:11Z",
        "updatedAt" : "2020-01-01T10:44:53Z",
        "lastEditedBy" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "tags" : [
        ]
      },
      {
        "id" : "26c0589b-4da0-4977-9b06-45733d668519",
        "parentId" : "a4939da1-ccaa-4265-9458-0ca9d5c7dc79",
        "authorId" : "2a2f79ba-933f-43cd-9d45-5d769ab0f54d",
        "body" : "That version would also run into issues if the user provided n is negative.\r\nI agree with the only considering successful elements though.\r\nExcited to see where this is going",
        "createdAt" : "2019-12-27T01:20:24Z",
        "updatedAt" : "2020-01-01T10:44:53Z",
        "lastEditedBy" : "2a2f79ba-933f-43cd-9d45-5d769ab0f54d",
        "tags" : [
        ]
      }
    ],
    "commit" : "f7e2f7b45a301cae31590462cc1fedf246bf3fc9",
    "line" : 23,
    "diffHunk" : "@@ -1,1 +2284,2288 @@      for {\n        as      <- self.process\n        counter <- Ref.make(0L).toManaged_\n        pull = counter.get.flatMap { c =>\n          if (c >= n) Pull.end"
  },
  {
    "id" : "ab11661e-26a6-4679-94a0-e10afd23c26e",
    "prId" : 2477,
    "prUrl" : "https://github.com/zio/zio/pull/2477#pullrequestreview-333002465",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4a0c5990-4a78-4d0c-9cd4-a48647eaf566",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "Inserting side-effects in pure code is notoriously difficult to reason about. In this case it should be ok (it's in the middle of a flat map and only needs non-determinism).\r\n\r\nI don't consider this a good practice in ZIO but of course if there's a good reason for it (performance, lower code volume, etc.), then I'm all for it.",
        "createdAt" : "2019-12-17T02:02:40Z",
        "updatedAt" : "2019-12-17T02:02:40Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      },
      {
        "id" : "d6c84ad4-6b08-4435-98a4-5806e2a4ca91",
        "parentId" : "4a0c5990-4a78-4d0c-9cd4-a48647eaf566",
        "authorId" : "2a2f79ba-933f-43cd-9d45-5d769ab0f54d",
        "body" : "This is not a side effect in that sense. The motivation behind UniqueKey is that we at some points want to keep track of an undefined number of fibers/iterations/etc. This was done before by arbitrarily selecting int/long as the key and rolling with it. The problem with that approach is that it is every time an adhoc decision and would lead to very subtle bugs when it actually overflows.\r\n\r\nA better key for these purposes is just an arbitrary object that does not override hashcode / equals and therefore uses its memory location as its identity. This allows us to create infinitely many distinct keys (up to the limits of ram) without any additional overhead.\r\n\r\nI wouldn't consider it a side effect in that sense, though you are right that this is not deterministic. Do you have a better solution for this problem? Even outside of the determinism issue this feels a little hacky to me  \r\n",
        "createdAt" : "2019-12-17T03:04:04Z",
        "updatedAt" : "2019-12-17T03:09:25Z",
        "lastEditedBy" : "2a2f79ba-933f-43cd-9d45-5d769ab0f54d",
        "tags" : [
        ]
      }
    ],
    "commit" : "e6fa50d5c2c32d49553c40feb4bf2f467bb755cd",
    "line" : 93,
    "diffHunk" : "@@ -1,1 +1070,1074 @@                        queue <- Queue.bounded[Take[E1, A1]](1)\n                        _     <- queue.offer(endTake)\n                        id    = UniqueKey()\n                        _     <- queuesRef.update(_ + (id -> queue))\n                      } yield (id, queue)"
  },
  {
    "id" : "29d41c0a-a059-4c9c-ba38-b7ca9566b479",
    "prId" : 2477,
    "prUrl" : "https://github.com/zio/zio/pull/2477#pullrequestreview-332987556",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1d425e00-1baf-464b-b826-0c7c586f1ee9",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "This looks like more code, not less? But hard to tell with the reformat...",
        "createdAt" : "2019-12-17T02:03:34Z",
        "updatedAt" : "2019-12-17T02:03:35Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      }
    ],
    "commit" : "e6fa50d5c2c32d49553c40feb4bf2f467bb755cd",
    "line" : 37,
    "diffHunk" : "@@ -1,1 +1000,1004 @@          Range(0, n).map(id => next.map { case (key, queue) => ((key -> id), queue) })\n        }.flatMap { entries =>\n          val (mappings, queues) = entries.foldRight((Map.empty[UniqueKey, Int], List.empty[Queue[Take[E1, A1]]])) {\n            case ((mapping, queue), (mappings, queues)) =>\n              (mappings + mapping, queue :: queues)"
  },
  {
    "id" : "eeef4145-4cae-4397-9fc2-8ec9d35c795e",
    "prId" : 2467,
    "prUrl" : "https://github.com/zio/zio/pull/2467#pullrequestreview-332136529",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b7d2523b-cceb-4daf-8773-70c041e3f850",
        "parentId" : null,
        "authorId" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "body" : "Hmm, should you set `done` to `true` if `as` completes successfully?",
        "createdAt" : "2019-12-13T21:48:00Z",
        "updatedAt" : "2019-12-13T21:48:01Z",
        "lastEditedBy" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "tags" : [
        ]
      },
      {
        "id" : "f27926d8-92b0-4829-84a2-ab9909840904",
        "parentId" : "b7d2523b-cceb-4daf-8773-70c041e3f850",
        "authorId" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "body" : "Ah, I misread the bracketing. Looks great!",
        "createdAt" : "2019-12-13T21:48:24Z",
        "updatedAt" : "2019-12-13T21:48:24Z",
        "lastEditedBy" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "tags" : [
        ]
      },
      {
        "id" : "3eabf45c-10d3-4a05-a23a-51891f0640b3",
        "parentId" : "b7d2523b-cceb-4daf-8773-70c041e3f850",
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "Yeah we only toggle done if the interrupting promise resolves. Thanks for looking!",
        "createdAt" : "2019-12-13T21:53:29Z",
        "updatedAt" : "2019-12-13T21:53:29Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      }
    ],
    "commit" : "008d88a8f5484c773b3226d4fec4bfeb0985efdc",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +1694,1698 @@          if (_) Pull.end\n          else\n            as.raceAttempt(\n              p.await\n                .mapError(Some(_))"
  },
  {
    "id" : "5de882c7-448a-4613-bad2-26db14a13833",
    "prId" : 2467,
    "prUrl" : "https://github.com/zio/zio/pull/2467#pullrequestreview-332206345",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "55c1382f-4bb0-4abb-be67-0e79126e54f3",
        "parentId" : null,
        "authorId" : "6bab7be3-690b-49f9-9a0d-a8415f4c0c8e",
        "body" : "`Pull.halt`",
        "createdAt" : "2019-12-14T10:06:31Z",
        "updatedAt" : "2019-12-14T10:06:38Z",
        "lastEditedBy" : "6bab7be3-690b-49f9-9a0d-a8415f4c0c8e",
        "tags" : [
        ]
      }
    ],
    "commit" : "008d88a8f5484c773b3226d4fec4bfeb0985efdc",
    "line" : 10,
    "diffHunk" : "@@ -1,1 +1698,1702 @@                .mapError(Some(_))\n                .foldCauseM(\n                  c => done.set(true) *> ZIO.halt(c),\n                  _ => done.set(true) *> Pull.end\n                )"
  },
  {
    "id" : "2499c20d-c6dc-47a1-b2cb-d929f78f4619",
    "prId" : 2442,
    "prUrl" : "https://github.com/zio/zio/pull/2442#pullrequestreview-331973876",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f9136614-cc59-465e-b8d1-a18d230da5db",
        "parentId" : null,
        "authorId" : "4bb412c7-1df7-4af3-848b-0dae636c2a24",
        "body" : "Could this be simplified to:\r\n\r\n```scala\r\n      ZStream {\r\n        for {\r\n          as <- self.process\r\n          pull = p.isDone.flatMap {\r\n            if (_) Pull.end\r\n            else as.raceAttempt(p.await.mapError(Some(_)) *> Pull.end)\r\n          }\r\n        } yield pull\r\n      }\r\n```\r\n?",
        "createdAt" : "2019-12-08T20:42:32Z",
        "updatedAt" : "2019-12-13T16:07:05Z",
        "lastEditedBy" : "4bb412c7-1df7-4af3-848b-0dae636c2a24",
        "tags" : [
        ]
      },
      {
        "id" : "a355e744-89f5-4ed8-80a9-f0528ab0e776",
        "parentId" : "f9136614-cc59-465e-b8d1-a18d230da5db",
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "Possibly! But that formulation seems wrong according to my tests. I'll look into that simplification in a follow up.",
        "createdAt" : "2019-12-13T16:21:18Z",
        "updatedAt" : "2019-12-13T16:21:19Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      }
    ],
    "commit" : "3589d563400c63a8a56ee6eade593062b06fba04",
    "line" : 65,
    "diffHunk" : "@@ -1,1 +1691,1695 @@        done <- Ref.make(false).toManaged_\n        pull = done.get flatMap {\n          if (_) Pull.end\n          else as.raceAttempt(p.await.mapError(Some(_)).ensuring(done set true) *> Pull.end)\n        }"
  },
  {
    "id" : "74d0fac8-0f41-4eef-95e0-8f75e62b76d8",
    "prId" : 2337,
    "prUrl" : "https://github.com/zio/zio/pull/2337#pullrequestreview-324295651",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e1945d51-1110-44fd-8267-32d4fb445946",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "I think we have to decide what `M` means. If we mean `M` as the \"host monad\", it makes sense to lock this to `ZStream`\", but if we intend it to be \"ZIO monad\", then it makes more sense to change to `ZIO` as in this pull request.\r\n\r\nIn any case, the generalization on the error channel is very useful! Probably an oversight in the preceding version.\r\n\r\nIf all the `mapM` etc. functions on` ZStream` are expecting `ZIO`, then maybe we should change this one to `ZIO`. We could always add `accessStream` for the stream variant, if we decided it was too cumbersome to use the combinators.",
        "createdAt" : "2019-11-28T10:32:49Z",
        "updatedAt" : "2019-11-28T13:28:17Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      },
      {
        "id" : "7a9b0ac0-6762-41fd-90ee-9930cd07a7ec",
        "parentId" : "e1945d51-1110-44fd-8267-32d4fb445946",
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "I think that makes sense. I updated accordingly.",
        "createdAt" : "2019-11-28T13:45:35Z",
        "updatedAt" : "2019-11-28T13:45:35Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      }
    ],
    "commit" : "f9a78f1c4953dd6d8f322ada770c1ed152dc24a0",
    "line" : 50,
    "diffHunk" : "@@ -1,1 +3154,3158 @@\n  final class AccessMPartiallyApplied[R](private val dummy: Boolean = true) extends AnyVal {\n    def apply[E, A](f: R => ZIO[R, E, A]): ZStream[R, E, A] =\n      ZStream.environment[R].mapM(f)\n  }"
  },
  {
    "id" : "72c4e6d0-853f-4935-879d-f98e0c60dfc8",
    "prId" : 2199,
    "prUrl" : "https://github.com/zio/zio/pull/2199#pullrequestreview-314597839",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bab69305-59e2-44d6-a713-db22f3da3e14",
        "parentId" : null,
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "So we can use `Pull.memoizeEnd` here right?\r\n\r\n```\r\nPull.memoizeEnd {\r\n  Ref.make(s).toManaged_.map {\r\n    // previous code here\r\n  }\r\n}\r\n```",
        "createdAt" : "2019-11-10T08:53:43Z",
        "updatedAt" : "2019-11-10T11:44:03Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      }
    ],
    "commit" : "097d233f27a16a174025b7b6b41ae24b6396d36e",
    "line" : 45,
    "diffHunk" : "@@ -1,1 +3049,3053 @@    ZStream {\n      for {\n        done <- Ref.make(false).toManaged_\n        ref  <- Ref.make(s).toManaged_\n      } yield done.get.flatMap {"
  },
  {
    "id" : "1a99d0f3-fc64-46a9-8994-06c356a2cdf7",
    "prId" : 2169,
    "prUrl" : "https://github.com/zio/zio/pull/2169#pullrequestreview-313120236",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4f1a36d2-dc09-4a14-934b-8702184cf125",
        "parentId" : null,
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "Scaladoc can be rolled back?",
        "createdAt" : "2019-11-07T07:47:12Z",
        "updatedAt" : "2019-11-12T02:32:19Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      }
    ],
    "commit" : "e597a3f9ff4c9895deccd1a7dc9ed0e94e93be52",
    "line" : 23,
    "diffHunk" : "@@ -1,1 +773,777 @@   * Switches over to the stream produced by the provided function in case this one\n   * fails. Allows recovery from all causes of failure, including interruption of the\n   * stream is uninterruptible.\n   */\n  final def catchAllCause[R1 <: R, E2, A1 >: A](f: Cause[E] => ZStream[R1, E2, A1]): ZStream[R1, E2, A1] = {"
  },
  {
    "id" : "13fb4f87-443f-43d5-9005-5bc047fdc5fe",
    "prId" : 2113,
    "prUrl" : "https://github.com/zio/zio/pull/2113#pullrequestreview-310819838",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c888f5cd-5b2f-4af2-a442-e781ced8e0a1",
        "parentId" : null,
        "authorId" : "b07fe5ec-3ba6-4df5-b718-27aef96bd2ea",
        "body" : "This implementation collects entire stream into a list. It can run out of memory. \r\nShould it be `ZSink.foldLeft(None){ case (a, _) => a }` ?",
        "createdAt" : "2019-11-03T14:22:15Z",
        "updatedAt" : "2019-11-03T14:22:15Z",
        "lastEditedBy" : "b07fe5ec-3ba6-4df5-b718-27aef96bd2ea",
        "tags" : [
        ]
      },
      {
        "id" : "97bfc39c-8b10-4028-b155-4bbd2effe144",
        "parentId" : "c888f5cd-5b2f-4af2-a442-e781ced8e0a1",
        "authorId" : "e7a4fe44-40b3-44db-b4fe-df2c1f28a177",
        "body" : "The entire stream is at most 1 element after `take(1)` so this cannot run out of memory and does work infinite streams",
        "createdAt" : "2019-11-03T14:27:40Z",
        "updatedAt" : "2019-11-03T14:27:40Z",
        "lastEditedBy" : "e7a4fe44-40b3-44db-b4fe-df2c1f28a177",
        "tags" : [
        ]
      }
    ],
    "commit" : "3992ca6874a968aadb2fd1acb06d799fae9d3512",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +1913,1917 @@   * Runs the stream returning the first element of the stream. Later elements will not be consumed / have effects run\n   */\n  def runHead: ZIO[R, E, Option[A]] = take(1).runCollect.map(_.headOption)\n\n  /**"
  },
  {
    "id" : "513169da-1e29-4d1c-af49-0f953d4e6cc8",
    "prId" : 2101,
    "prUrl" : "https://github.com/zio/zio/pull/2101#pullrequestreview-310808817",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d03fb257-07cf-4e59-8101-120fd6aafefe",
        "parentId" : null,
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "this signature would be nicer,  I think:\r\n```scala\r\ndef mapMPartitioned(keyBy: A => K, buffer: Int = 16)(f: A => ZIO[...])\r\n```",
        "createdAt" : "2019-11-03T09:20:03Z",
        "updatedAt" : "2019-11-10T12:40:36Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      },
      {
        "id" : "255bee1f-191b-404f-bb8d-d2aa1029b4f9",
        "parentId" : "d03fb257-07cf-4e59-8101-120fd6aafefe",
        "authorId" : "e7a4fe44-40b3-44db-b4fe-df2c1f28a177",
        "body" : "Sure, have updated it",
        "createdAt" : "2019-11-03T10:15:18Z",
        "updatedAt" : "2019-11-10T12:40:36Z",
        "lastEditedBy" : "e7a4fe44-40b3-44db-b4fe-df2c1f28a177",
        "tags" : [
        ]
      }
    ],
    "commit" : "60d57477d98b62be0e739caf1b88066dc0999668",
    "line" : 11,
    "diffHunk" : "@@ -1,1 +1649,1653 @@   * Transformed elements may be reordered but the order within a partition is maintained.\n   */\n  final def mapMPartitioned[R1 <: R, E1 >: E, B, K](\n    keyBy: A => K,\n    buffer: Int = 16"
  },
  {
    "id" : "561a02f8-e81f-498c-b705-d68aef0ef927",
    "prId" : 1952,
    "prUrl" : "https://github.com/zio/zio/pull/1952#pullrequestreview-301005149",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "be421284-4775-47ba-b9e7-4963c217a413",
        "parentId" : null,
        "authorId" : "2a2f79ba-933f-43cd-9d45-5d769ab0f54d",
        "body" : "What exactly ended up being the issue with the implementation of concat based on ZManaged#switchable that you posted in discord? I though it was a bit nicer than introducing structure",
        "createdAt" : "2019-10-11T23:53:34Z",
        "updatedAt" : "2019-10-14T08:15:06Z",
        "lastEditedBy" : "2a2f79ba-933f-43cd-9d45-5d769ab0f54d",
        "tags" : [
        ]
      },
      {
        "id" : "eb6877f6-1141-4b74-b864-21df56915557",
        "parentId" : "be421284-4775-47ba-b9e7-4963c217a413",
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "Good question and good to have it written in this PR for posterity.\r\n\r\nThe previous `++` would do something like this (written minimally on purpose):\r\n```scala\r\ndef ++(other: => ZStream) = \r\n  ZStream {\r\n    for {\r\n      switched <- Ref.make(false).toManaged_\r\n      currPull <- Ref.make(...)\r\n      pull = {\r\n        // get the current pull from the Ref, and pull it\r\n        // if it ended and !switched, switch over to `other`\r\n        // otherwise end\r\n      }\r\n    } yield pull\r\n  }\r\n```\r\n\r\nAs you can see, it allocates a bunch of resources that are retained for the existence of the stream `(self ++ other)`.\r\n\r\nNow, let's consider what happens in `self.forever` (defined as `forever = self ++ forever`) - or any stream that concatenates recursively. When we evaluate `++`, it allocates these refs and starts pulling `self`. Once `self` is done, the ZManaged for `other` is opened and that one starts being pulled.\r\n\r\nBut, `other` is actually another `++`, so more `Ref` instances are allocated! This happens on every switch to the RHS, so every recursion allocates more `Ref`. That would be fine if we could somehow stop retaining the current `Ref`, but we can't \"exit\" the scope of the current ZManaged. This is the root of the problem. Once we're inside a scope, we can't exit it.\r\n\r\nSo this formulation is heap-unsafe. I tried pretty hard, but I couldn't work around it properly. I think that the way to solve it is to interpret the recursive structure \"from outside\", before entering the scope that is recursive.\r\n\r\nI hope this makes sense!",
        "createdAt" : "2019-10-12T11:01:46Z",
        "updatedAt" : "2019-10-14T08:15:06Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      },
      {
        "id" : "20e4da28-35ca-42bf-be31-972c65367168",
        "parentId" : "be421284-4775-47ba-b9e7-4963c217a413",
        "authorId" : "2a2f79ba-933f-43cd-9d45-5d769ab0f54d",
        "body" : "Ah, I think I understand. But this is a very subtle issue O.o\r\n\r\nThanks for the explanation and nice fix!",
        "createdAt" : "2019-10-12T13:21:32Z",
        "updatedAt" : "2019-10-14T08:15:06Z",
        "lastEditedBy" : "2a2f79ba-933f-43cd-9d45-5d769ab0f54d",
        "tags" : [
        ]
      }
    ],
    "commit" : "cf66cc3cdeb8caae5ab18b041abda8157af12dda",
    "line" : 51,
    "diffHunk" : "@@ -1,1 +851,855 @@   * elements of this stream, and then emit the elements of the `other` stream.\n   */\n  final def concat[R1 <: R, E1 >: E, A1 >: A](other: => ZStream[R1, E1, A1]): ZStream[R1, E1, A1] =\n    new ZStream(ZStream.Structure.Concat(structure, () => other.structure))\n"
  },
  {
    "id" : "9d81b798-d336-48d7-b62f-edee68c79422",
    "prId" : 1952,
    "prUrl" : "https://github.com/zio/zio/pull/1952#pullrequestreview-300992228",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f0d649c5-5d51-452c-b1f0-05dd02fe8d46",
        "parentId" : null,
        "authorId" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "body" : "```suggestion\r\n          def go: Pull[R1 with Clock, E, C] =\r\n```",
        "createdAt" : "2019-10-12T08:17:53Z",
        "updatedAt" : "2019-10-14T08:15:06Z",
        "lastEditedBy" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "tags" : [
        ]
      }
    ],
    "commit" : "cf66cc3cdeb8caae5ab18b041abda8157af12dda",
    "line" : 163,
    "diffHunk" : "@@ -1,1 +1832,1836 @@        doneRef       <- Ref.make(false).toManaged_\n        pull = {\n          def go: ZIO[R1 with Clock, Option[E], C] =\n            doneRef.get.flatMap { done =>\n              if (done) Pull.end"
  },
  {
    "id" : "e17d0a1a-5482-4645-adcb-d0b3506f0977",
    "prId" : 1952,
    "prUrl" : "https://github.com/zio/zio/pull/1952#pullrequestreview-300992228",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0df42dcc-9d74-46e6-b419-c5e77cc35759",
        "parentId" : null,
        "authorId" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "body" : "Same, just in case:\r\n```suggestion\r\n                    case Some(e) => Pull.fail(e)\r\n```",
        "createdAt" : "2019-10-12T08:18:31Z",
        "updatedAt" : "2019-10-14T08:15:06Z",
        "lastEditedBy" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "tags" : [
        ]
      }
    ],
    "commit" : "cf66cc3cdeb8caae5ab18b041abda8157af12dda",
    "line" : 173,
    "diffHunk" : "@@ -1,1 +1838,1842 @@                currPull.get.flatten.foldM(\n                  {\n                    case e @ Some(_) => ZIO.fail(e)\n                    case None =>\n                      schedStateRef.get"
  },
  {
    "id" : "cffddcdb-cfb0-449c-bb5f-c4cf43d7eb5b",
    "prId" : 1952,
    "prUrl" : "https://github.com/zio/zio/pull/1952#pullrequestreview-301000904",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0229f992-619a-42c1-81f2-664d45ad4420",
        "parentId" : null,
        "authorId" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "body" : "Have you noticed that pattern is coming up all the time with `switchable`? I wonder if we could refactor without having to keep `currPull` and `nextPull` refs around.",
        "createdAt" : "2019-10-12T08:23:36Z",
        "updatedAt" : "2019-10-14T08:15:06Z",
        "lastEditedBy" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "tags" : [
        ]
      },
      {
        "id" : "71b7521f-f522-46fd-abf2-3fae5d6f9fe3",
        "parentId" : "0229f992-619a-42c1-81f2-664d45ad4420",
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "Yeah, there's some convenience to be had here: we could have the `switchable` constructor return something like:\r\n```\r\ntrait Switchable[R, E, A] {\r\n  def switch(m: ZManaged[R, E, A]): ZIO[R, E, A]\r\n  def get: ZIO[R, E, A]\r\n}\r\n```\r\n\r\nSo the `Ref` is embedded in that.",
        "createdAt" : "2019-10-12T10:52:42Z",
        "updatedAt" : "2019-10-14T08:15:06Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      },
      {
        "id" : "d234a142-c95d-4f56-988d-9a56d673ece3",
        "parentId" : "0229f992-619a-42c1-81f2-664d45ad4420",
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "Ah it's actually not that simple. We would have to start requiring an initial resource, or `get` becomes `UIO[Option[A]]`. Beyond that, we need to think what happens if `switch` fails to acquire the resource. What would `get` return afterwards? That also pushes us towards `UIO[Option[A]]`. The problem is that sticking an `Option` in there can be a real pain for calling code.",
        "createdAt" : "2019-10-12T11:18:23Z",
        "updatedAt" : "2019-10-14T08:15:06Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      }
    ],
    "commit" : "cf66cc3cdeb8caae5ab18b041abda8157af12dda",
    "line" : 184,
    "diffHunk" : "@@ -1,1 +1849,1853 @@                                self.map(f) ++ Stream.succeed(g(decision.finish()))).process\n\n                            switchPull(nextPull).mapError(Some(_)).tap(currPull.set(_)) *>\n                              schedStateRef.set(decision.state) *> go\n                          }"
  },
  {
    "id" : "e3a039b4-ff0a-4e29-9042-2ad102080250",
    "prId" : 1952,
    "prUrl" : "https://github.com/zio/zio/pull/1952#pullrequestreview-300992228",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "598a8318-4601-4f1a-ab00-768d721fbc39",
        "parentId" : null,
        "authorId" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "body" : "```suggestion\r\n          (finalizer.get.flatMap(_(Exit.fail(e1))) *> finalizer.set(_ => UIO.unit)).uninterruptible *> Pull.fail(e1)\r\n```",
        "createdAt" : "2019-10-12T08:26:16Z",
        "updatedAt" : "2019-10-14T08:15:06Z",
        "lastEditedBy" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "tags" : [
        ]
      }
    ],
    "commit" : "cf66cc3cdeb8caae5ab18b041abda8157af12dda",
    "line" : 81,
    "diffHunk" : "@@ -1,1 +1069,1073 @@      currPull.get.flatten.catchAll {\n        case e @ Some(e1) =>\n          (finalizer.get.flatMap(_(Exit.fail(e1))) *> finalizer.set(_ => UIO.unit)).uninterruptible *> ZIO.fail(\n            e\n          )"
  },
  {
    "id" : "c1291ca3-6ddc-4a55-8863-ed4cdf711482",
    "prId" : 1952,
    "prUrl" : "https://github.com/zio/zio/pull/1952#pullrequestreview-301012521",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8ba35607-af32-4c3f-92c4-1f68108aff83",
        "parentId" : null,
        "authorId" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "body" : "```suggestion\r\n    ): Pull[R1, E1, B] = {\r\n```",
        "createdAt" : "2019-10-12T16:27:38Z",
        "updatedAt" : "2019-10-14T08:15:06Z",
        "lastEditedBy" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "tags" : [
        ]
      }
    ],
    "commit" : "cf66cc3cdeb8caae5ab18b041abda8157af12dda",
    "line" : 67,
    "diffHunk" : "@@ -1,1 +1055,1059 @@      finalizer: Ref[Exit[_, _] => URIO[R1, _]],\n      currPull: Ref[Pull[R1, E1, B]]\n    ): ZIO[R1, Option[E1], B] = {\n      val pullOuter = ZIO.uninterruptibleMask { restore =>\n        restore(as).flatMap { a =>"
  },
  {
    "id" : "f8bb2591-a719-4d93-9ded-53507f65704f",
    "prId" : 1952,
    "prUrl" : "https://github.com/zio/zio/pull/1952#pullrequestreview-301059486",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bf251abb-5586-4386-a563-7f077f8d6abf",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "Good idea to keep all the guts private so we can experiment throughout `1.x`.",
        "createdAt" : "2019-10-13T18:09:47Z",
        "updatedAt" : "2019-10-14T08:15:06Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      }
    ],
    "commit" : "cf66cc3cdeb8caae5ab18b041abda8157af12dda",
    "line" : 247,
    "diffHunk" : "@@ -1,1 +2453,2457 @@  }\n\n  private[stream] sealed abstract class Structure[-R, +E, +A] {\n    def process: ZManaged[R, E, Pull[R, E, A]]\n  }"
  },
  {
    "id" : "e6aff9f2-54fc-46cf-a6eb-8c2b32ed6115",
    "prId" : 1881,
    "prUrl" : "https://github.com/zio/zio/pull/1881#pullrequestreview-297116025",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d4404197-a266-4b87-b835-344dbad07a26",
        "parentId" : null,
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "Ah that's clever! Nicely done",
        "createdAt" : "2019-10-03T20:00:59Z",
        "updatedAt" : "2019-10-03T20:00:59Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      }
    ],
    "commit" : "d1fcbbda4b515e85d506010a8083c9f9618ecdd6",
    "line" : 27,
    "diffHunk" : "@@ -1,1 +691,695 @@                  Pull.emit(Chunk.single(a))\n                } else {\n                  val acc = Array.ofDim(chunkSize)(Chunk.Tags.fromValue(a))\n                  acc(0) = a\n                  loop(acc, 1)"
  },
  {
    "id" : "2b840fc4-bbd4-4ef1-aea5-21aefe69ad5a",
    "prId" : 1848,
    "prUrl" : "https://github.com/zio/zio/pull/1848#pullrequestreview-294655488",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fbbab629-433c-4e08-9ba4-4f045ae32a8b",
        "parentId" : null,
        "authorId" : "6bab7be3-690b-49f9-9a0d-a8415f4c0c8e",
        "body" : "Finally we get to reason about `flatMap` on a higher level. Love it.",
        "createdAt" : "2019-09-28T22:06:34Z",
        "updatedAt" : "2019-09-28T22:06:41Z",
        "lastEditedBy" : "6bab7be3-690b-49f9-9a0d-a8415f4c0c8e",
        "tags" : [
        ]
      }
    ],
    "commit" : "5dad0d8e6762f8f34f65321bcc7d5d7b1d790a49",
    "line" : 1,
    "diffHunk" : "@@ -1,1 +930,934 @@   * produced by passing each element of this stream to `f0`\n   */\n  final def flatMap[R1 <: R, E1 >: E, B](f0: A => ZStream[R1, E1, B]): ZStream[R1, E1, B] =\n    ZStream[R1, E1, B] {\n      for {"
  },
  {
    "id" : "77bf9dc8-40a6-426d-869b-dcb841edd997",
    "prId" : 1798,
    "prUrl" : "https://github.com/zio/zio/pull/1798#pullrequestreview-306178624",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d0be75c1-662a-461b-ba8a-affafe7fdf63",
        "parentId" : null,
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "Would be great if you could comment here on each case who won the race",
        "createdAt" : "2019-10-23T20:44:00Z",
        "updatedAt" : "2019-10-27T21:13:24Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      }
    ],
    "commit" : "85723fa5b39983f7ca4e00175970147787e755db",
    "line" : 175,
    "diffHunk" : "@@ -1,1 +461,465 @@          // When the schedule signals completion, we emit its result into the\n          // stream and restart with the schedule's initial state\n          case Left(None) =>\n            schedule.initial.map(\n              init =>"
  },
  {
    "id" : "a2408e59-29a9-4876-8e2d-949b93322686",
    "prId" : 1767,
    "prUrl" : "https://github.com/zio/zio/pull/1767#pullrequestreview-291497703",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2088fd4f-f820-4be1-bcec-92a7a22380c3",
        "parentId" : null,
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "This means that we don't emit the schedule's final value if the stream ended before the schedule ended. Is that intentional?",
        "createdAt" : "2019-09-22T09:06:11Z",
        "updatedAt" : "2019-09-22T09:06:11Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      },
      {
        "id" : "73cc3c0c-ef6e-4a79-b55f-703e97cc6dd8",
        "parentId" : "2088fd4f-f820-4be1-bcec-92a7a22380c3",
        "authorId" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "body" : "Yes. If for instance the stream is completely empty, there never was a value of type `a` to update the schedule.",
        "createdAt" : "2019-09-22T09:15:11Z",
        "updatedAt" : "2019-09-22T09:15:11Z",
        "lastEditedBy" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "tags" : [
        ]
      },
      {
        "id" : "1e8ec7b5-05f1-4bd8-a697-ead9789d71c3",
        "parentId" : "2088fd4f-f820-4be1-bcec-92a7a22380c3",
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "Ok, I'm good with that 👍🏻",
        "createdAt" : "2019-09-22T09:15:42Z",
        "updatedAt" : "2019-09-22T09:15:43Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      }
    ],
    "commit" : "e3c9ec9a2d4b72deb289ba665d21121258f742d0",
    "line" : 47,
    "diffHunk" : "@@ -1,1 +1835,1839 @@                        // The stream ends when both the underlying stream ends and the final\n                        // schedule value has been emitted\n                        case None => Pull.end\n                      }\n                } yield c"
  },
  {
    "id" : "221f7130-1612-4ba4-add4-3e5570274d94",
    "prId" : 1725,
    "prUrl" : "https://github.com/zio/zio/pull/1725#pullrequestreview-291457304",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f28d8853-4f8d-457f-8e10-3c505d332875",
        "parentId" : null,
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "Cool. Add a note that the resulting stream will emit the failure that occured, then end?",
        "createdAt" : "2019-09-21T08:32:46Z",
        "updatedAt" : "2019-09-21T14:32:16Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      },
      {
        "id" : "b22d3e6a-1efd-4ad7-a990-c55032b445e7",
        "parentId" : "f28d8853-4f8d-457f-8e10-3c505d332875",
        "authorId" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "body" : "Ha, right. Is that the correct behaviour? or instead we keep pulling even after error?",
        "createdAt" : "2019-09-21T08:41:10Z",
        "updatedAt" : "2019-09-21T14:32:16Z",
        "lastEditedBy" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "tags" : [
        ]
      },
      {
        "id" : "3a0a265a-99e8-45ae-81d4-502edfa8a8f2",
        "parentId" : "f28d8853-4f8d-457f-8e10-3c505d332875",
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "Yes, that's what we do right now because the contract of `Pull` (currently!) doesn't allow for pulling after a failure.",
        "createdAt" : "2019-09-21T08:46:00Z",
        "updatedAt" : "2019-09-21T14:32:16Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      }
    ],
    "commit" : "c9af89d9e3653b31d73863e5d3d25421a195e6f7",
    "line" : 25,
    "diffHunk" : "@@ -1,1 +854,858 @@   * Returns a stream whose failures and successes have been lifted into an\n   * `Either`. The resulting stream cannot fail, because the failures have\n   * been exposed as part of the `Either` success case.\n   *\n   * @note the stream will end as soon as the first error occurs."
  },
  {
    "id" : "448051d3-a62f-4853-86e5-e73475af8d11",
    "prId" : 1725,
    "prUrl" : "https://github.com/zio/zio/pull/1725#pullrequestreview-291467300",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0c131a4c-5b77-48e2-b132-f4dc5673f83c",
        "parentId" : null,
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "nice",
        "createdAt" : "2019-09-21T14:29:37Z",
        "updatedAt" : "2019-09-21T14:32:16Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      }
    ],
    "commit" : "c9af89d9e3653b31d73863e5d3d25421a195e6f7",
    "line" : 92,
    "diffHunk" : "@@ -1,1 +2284,2288 @@   * stream is consumed\n   */\n  final def bracketExit[R, E, A](\n    acquire: ZIO[R, E, A]\n  )(release: (A, Exit[_, _]) => ZIO[R, Nothing, _]): ZStream[R, E, A] ="
  },
  {
    "id" : "417bc6f1-2696-4f1d-9789-cec730298301",
    "prId" : 1717,
    "prUrl" : "https://github.com/zio/zio/pull/1717#pullrequestreview-291241604",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "78628443-21de-4ea8-a692-bfd304f0908c",
        "parentId" : null,
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "Scaladoc please? :-)",
        "createdAt" : "2019-09-20T15:35:33Z",
        "updatedAt" : "2019-09-20T16:31:15Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      }
    ],
    "commit" : "7d57b9718f43f389b8c1dda2dbf991d6b6394558",
    "line" : 9,
    "diffHunk" : "@@ -1,1 +2522,2526 @@   * hence the name.\n   */\n  final def paginate[R, E, A, S](s: S)(f: S => ZIO[R, E, (A, Option[S])]): ZStream[R, E, A] =\n    ZStream[R, E, A] {\n      for {"
  },
  {
    "id" : "01bd25cf-ac8d-4583-9b12-74825de349e8",
    "prId" : 1700,
    "prUrl" : "https://github.com/zio/zio/pull/1700#pullrequestreview-289925631",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b70ff6ba-633e-4cb6-844b-b7aa5d7f883e",
        "parentId" : null,
        "authorId" : "6bab7be3-690b-49f9-9a0d-a8415f4c0c8e",
        "body" : "We will need to add some more documentation to this method, to highlight the difference compared to the new `aggregateWithin` which currently doesn't have a scaladoc.",
        "createdAt" : "2019-09-18T12:49:31Z",
        "updatedAt" : "2019-09-18T13:28:18Z",
        "lastEditedBy" : "6bab7be3-690b-49f9-9a0d-a8415f4c0c8e",
        "tags" : [
        ]
      },
      {
        "id" : "06e55086-3ec1-451f-a542-2cafd66678ab",
        "parentId" : "b70ff6ba-633e-4cb6-844b-b7aa5d7f883e",
        "authorId" : "47594f3f-c52b-41a1-8891-46622229b416",
        "body" : "I appreciate your feedback! I've added ScalaDoc for both methods in https://github.com/zio/zio/pull/1700/commits/a4b8851cafcfc94722a5f88180fec3d56bad1abe.",
        "createdAt" : "2019-09-18T13:31:19Z",
        "updatedAt" : "2019-09-18T13:31:19Z",
        "lastEditedBy" : "47594f3f-c52b-41a1-8891-46622229b416",
        "tags" : [
        ]
      },
      {
        "id" : "31fb995f-0caf-40e4-a520-25e1aa4c979e",
        "parentId" : "b70ff6ba-633e-4cb6-844b-b7aa5d7f883e",
        "authorId" : "6bab7be3-690b-49f9-9a0d-a8415f4c0c8e",
        "body" : "@iravid Should we open an issue maybe for the hackathon, to add annotated documentation like this?",
        "createdAt" : "2019-09-18T13:37:07Z",
        "updatedAt" : "2019-09-18T13:37:07Z",
        "lastEditedBy" : "6bab7be3-690b-49f9-9a0d-a8415f4c0c8e",
        "tags" : [
        ]
      },
      {
        "id" : "dc90c2df-1316-4d03-9665-2a111325d79c",
        "parentId" : "b70ff6ba-633e-4cb6-844b-b7aa5d7f883e",
        "authorId" : "47594f3f-c52b-41a1-8891-46622229b416",
        "body" : "See https://github.com/zio/zio/issues/413 where I started adding ScalaDoc to some files. It's a good first issue for a hackathon.",
        "createdAt" : "2019-09-18T13:39:15Z",
        "updatedAt" : "2019-09-18T13:39:15Z",
        "lastEditedBy" : "47594f3f-c52b-41a1-8891-46622229b416",
        "tags" : [
        ]
      }
    ],
    "commit" : "a4b8851cafcfc94722a5f88180fec3d56bad1abe",
    "line" : 16,
    "diffHunk" : "@@ -1,1 +260,264 @@   * @return `ZStream[R1 with Clock, E1, Either[C, B]]`\n   */\n  final def aggregateWithinEither[R1 <: R, E1 >: E, A1 >: A, B, C](\n    sink: ZSink[R1, E1, A1, A1, B],\n    schedule: ZSchedule[R1, Option[B], C]"
  },
  {
    "id" : "6dee8b47-fcf9-46a4-b78e-1c60a2dd1e6c",
    "prId" : 1675,
    "prUrl" : "https://github.com/zio/zio/pull/1675#pullrequestreview-288329048",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "cfc65d5e-1718-486e-b4d2-f7a3ae5db677",
        "parentId" : null,
        "authorId" : "6bab7be3-690b-49f9-9a0d-a8415f4c0c8e",
        "body" : "Nice.",
        "createdAt" : "2019-09-14T17:23:00Z",
        "updatedAt" : "2019-09-14T19:04:14Z",
        "lastEditedBy" : "6bab7be3-690b-49f9-9a0d-a8415f4c0c8e",
        "tags" : [
        ]
      }
    ],
    "commit" : "265ab4bf2bd5b6c364b8769070def2ae94406448",
    "line" : 8,
    "diffHunk" : "@@ -1,1 +1818,1822 @@      for {\n        as           <- self.process\n        sink         <- managedSink.map(_.mapError(Some(_)))\n        doneRef      <- Ref.make(false).toManaged_\n        leftoversRef <- Ref.make[Chunk[A1]](Chunk.empty).toManaged_"
  },
  {
    "id" : "4c36fcb0-1b6b-4489-9499-76a71b6cf8df",
    "prId" : 1628,
    "prUrl" : "https://github.com/zio/zio/pull/1628#pullrequestreview-285742392",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5b900416-e42d-4b64-9f76-a4fef3eb631a",
        "parentId" : null,
        "authorId" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "body" : "does this action need to be atomic? if yes then it might be useful to use `modify` instead",
        "createdAt" : "2019-09-09T18:47:57Z",
        "updatedAt" : "2019-09-09T19:55:03Z",
        "lastEditedBy" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "tags" : [
        ]
      },
      {
        "id" : "8289aa82-5b79-4510-a4a6-bcb7b0f0bf22",
        "parentId" : "5b900416-e42d-4b64-9f76-a4fef3eb631a",
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "I thought we were okay because we were inside the managed from `process`  but I'm not 100% sure. @iravid or @vasilmkd?",
        "createdAt" : "2019-09-09T19:06:34Z",
        "updatedAt" : "2019-09-09T19:55:03Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      },
      {
        "id" : "c2f7ffa9-b773-4b1a-86a4-956c49b5b412",
        "parentId" : "5b900416-e42d-4b64-9f76-a4fef3eb631a",
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "All bets are off with regard to interruption of a `Pull`.\r\n\r\nIf you can do things atomically that's better, but basically everything breaks if you interrupt a `Pull`.",
        "createdAt" : "2019-09-09T19:10:32Z",
        "updatedAt" : "2019-09-09T19:55:03Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      },
      {
        "id" : "b5335678-f2d1-44e7-b6fb-0866471eb905",
        "parentId" : "5b900416-e42d-4b64-9f76-a4fef3eb631a",
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "Okay. It looks like we use the same `get` and `set` pattern in the existing implementation of `dropWhile`.",
        "createdAt" : "2019-09-09T19:17:03Z",
        "updatedAt" : "2019-09-09T19:55:03Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      },
      {
        "id" : "bf7d882e-f191-437f-a113-969a216a2d67",
        "parentId" : "5b900416-e42d-4b64-9f76-a4fef3eb631a",
        "authorId" : "6bab7be3-690b-49f9-9a0d-a8415f4c0c8e",
        "body" : "We could, rewrite all cases where we can do things atomically. But yes, it's as grim as @iravid puts it. And at that point, I'm not sure if the extra work is worth it.",
        "createdAt" : "2019-09-09T19:50:08Z",
        "updatedAt" : "2019-09-09T19:55:03Z",
        "lastEditedBy" : "6bab7be3-690b-49f9-9a0d-a8415f4c0c8e",
        "tags" : [
        ]
      }
    ],
    "commit" : "ec52cd75a36c16c9c717057506c33590929d6af9",
    "line" : 27,
    "diffHunk" : "@@ -1,1 +1698,1702 @@        as            <- self.process\n        keepTakingRef <- Ref.make(true).toManaged_\n        pull = keepTakingRef.get.flatMap { p =>\n          if (!p) UIO.succeed(Pull.end)\n          else"
  },
  {
    "id" : "63dc89ca-ca4e-431c-97e0-9b3d995a0f87",
    "prId" : 1560,
    "prUrl" : "https://github.com/zio/zio/pull/1560#pullrequestreview-287363173",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "60b4521f-d17e-4213-9526-6c09ad3f1fa0",
        "parentId" : null,
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "Ouch, this isn't nice. We're now extracting twice which could be potentially expensive with some sinks.\r\n\r\nCan you please open a ticket so we can follow up on this? We'll need to change the state machine, because the extraction is done on the consumer side but the iteration of the leftover is done on the producer side.",
        "createdAt" : "2019-09-12T08:11:11Z",
        "updatedAt" : "2019-09-13T13:06:40Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      },
      {
        "id" : "0e3296ac-f29e-4a5f-92e9-0d2feb4d43e9",
        "parentId" : "60b4521f-d17e-4213-9526-6c09ad3f1fa0",
        "authorId" : "6bab7be3-690b-49f9-9a0d-a8415f4c0c8e",
        "body" : "Opened a follow up ticket #1649.",
        "createdAt" : "2019-09-12T11:32:19Z",
        "updatedAt" : "2019-09-13T13:06:40Z",
        "lastEditedBy" : "6bab7be3-690b-49f9-9a0d-a8415f4c0c8e",
        "tags" : [
        ]
      }
    ],
    "commit" : "54fad72660f1bef8b53592431aad630b6c4ba92d",
    "line" : 30,
    "diffHunk" : "@@ -1,1 +117,121 @@                       )\n                     else\n                       sink.extract(step).flatMap {\n                         case (_, leftover) =>\n                           UIO.succeed("
  },
  {
    "id" : "cbe51fe8-3934-448d-8234-323762686e34",
    "prId" : 1510,
    "prUrl" : "https://github.com/zio/zio/pull/1510#pullrequestreview-282389990",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a87ad325-fed1-4b8d-a2b3-f7b40eb72683",
        "parentId" : null,
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "```suggestion\r\n   * Composes this stream with the specified stream to create a cartesian product of elements, and keeps only\r\n     the elements from the `this` stream. \r\n     \r\n     The `that` stream would be run multiple times, for every element in the `this` stream.\r\n     \r\n     See also [[ZStream#zipWith]] and [[ZStream#<&>]] for the more common point-wise variant.\r\n```",
        "createdAt" : "2019-08-30T14:30:47Z",
        "updatedAt" : "2019-09-04T06:11:31Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      },
      {
        "id" : "cc1431ee-6a8e-4bcd-871f-82254f085393",
        "parentId" : "a87ad325-fed1-4b8d-a2b3-f7b40eb72683",
        "authorId" : "7e3942e8-574e-4098-a8e1-89fffa0c877d",
        "body" : "Fixed",
        "createdAt" : "2019-09-02T03:30:32Z",
        "updatedAt" : "2019-09-04T06:11:31Z",
        "lastEditedBy" : "7e3942e8-574e-4098-a8e1-89fffa0c877d",
        "tags" : [
        ]
      }
    ],
    "commit" : "9dc6960d778e3476c93b5b1a88e6fd39dae173d4",
    "line" : 40,
    "diffHunk" : "@@ -1,1 +1941,1945 @@   * See also [[ZStream#zipWith]] and [[ZStream#<&>]] for the more common point-wise variant.\n   */\n  final def <*[R1 <: R, E1 >: E, B](that: ZStream[R1, E1, B]): ZStream[R1, E1, A] =\n    (self <*> that).map(_._1)\n"
  },
  {
    "id" : "d1289267-5cc9-4ac3-985e-ea8e98a9858e",
    "prId" : 1482,
    "prUrl" : "https://github.com/zio/zio/pull/1482#pullrequestreview-279346024",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fc27ba30-c5fe-476b-8d8c-4b636487c45e",
        "parentId" : null,
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "Scaladoc? Pretty please? :-)",
        "createdAt" : "2019-08-25T17:37:15Z",
        "updatedAt" : "2019-08-31T06:22:47Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      }
    ],
    "commit" : "2db075de3b605a42e9ce334e929e074a3e56a4a7",
    "line" : 243,
    "diffHunk" : "@@ -1,1 +2241,2245 @@   * The infinite stream of iterative function application: a, f(a), f(f(a)), f(f(f(a))), ...\n   */\n  final def iterate[A](a: A)(f: A => A): ZStream[Any, Nothing, A] = ZStream.unfold(a)(a => Some(a -> f(a)))\n\n  /**"
  },
  {
    "id" : "c4614239-ed1c-4a31-ad75-3339a3afbaec",
    "prId" : 1482,
    "prUrl" : "https://github.com/zio/zio/pull/1482#pullrequestreview-279350319",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fe964e1b-c906-4fbc-9981-fa781b95df28",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "Nice. 👍 ",
        "createdAt" : "2019-08-25T19:44:00Z",
        "updatedAt" : "2019-08-31T06:22:47Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      }
    ],
    "commit" : "2db075de3b605a42e9ce334e929e074a3e56a4a7",
    "line" : 187,
    "diffHunk" : "@@ -1,1 +1873,1877 @@   * it is combined with the latest value from the other stream to produce a result.\n   */\n  final def zipWithLatest[R1 <: R, E1 >: E, B, C](that: ZStream[R1, E1, B])(f0: (A, B) => C): ZStream[R1, E1, C] =\n    ZStream[R1, E1, C] {\n      for {"
  },
  {
    "id" : "24861c85-b643-49fc-ab80-1612500fe8db",
    "prId" : 1482,
    "prUrl" : "https://github.com/zio/zio/pull/1482#pullrequestreview-281311951",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e03d2dde-1c32-4b14-8cdb-b6ac8f00ba3b",
        "parentId" : null,
        "authorId" : "d658ecdb-5876-4c2e-b729-b795b39dd4e8",
        "body" : "Nit: you could just put the `pull` expression directly in the `yield`.",
        "createdAt" : "2019-08-29T07:30:53Z",
        "updatedAt" : "2019-08-31T06:22:47Z",
        "lastEditedBy" : "d658ecdb-5876-4c2e-b729-b795b39dd4e8",
        "tags" : [
        ]
      },
      {
        "id" : "66ade948-e1a3-4c1d-9c60-5d6424ecf46f",
        "parentId" : "e03d2dde-1c32-4b14-8cdb-b6ac8f00ba3b",
        "authorId" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "body" : "It's kind of a pattern in the `ZStream` class, I think it's a little easier to read.",
        "createdAt" : "2019-08-29T08:55:16Z",
        "updatedAt" : "2019-08-31T06:22:47Z",
        "lastEditedBy" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "tags" : [
        ]
      }
    ],
    "commit" : "2db075de3b605a42e9ce334e929e074a3e56a4a7",
    "line" : 192,
    "diffHunk" : "@@ -1,1 +1878,1882 @@        is    <- self.mergeEither(that).process\n        state <- Ref.make[(Option[A], Option[B])]((None, None)).toManaged_\n        pull: Pull[R1, E1, C] = {\n          def go: Pull[R1, E1, C] = is.flatMap { i =>\n            state"
  },
  {
    "id" : "f760b054-a12f-446f-86a7-74d2b1410462",
    "prId" : 1482,
    "prUrl" : "https://github.com/zio/zio/pull/1482#pullrequestreview-282295420",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5212a190-d538-443b-af76-97fa1820d0b0",
        "parentId" : null,
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "Hmm didn't we say that the schedule should not stop the stream?",
        "createdAt" : "2019-08-31T06:24:41Z",
        "updatedAt" : "2019-08-31T06:24:41Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      },
      {
        "id" : "9d528090-eb21-4775-9e88-aaca312a21b1",
        "parentId" : "5212a190-d538-443b-af76-97fa1820d0b0",
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "Ah I see that my example was unclear. In this formulation, I meant that the schedule should restart between the elements. So for a stream `\"A B C A B C\"`, this should be result:\r\n```\r\nA |-2ms-| B |-4ms-| C |-8ms-| \"Done\" A |-2ms-| B |-4ms-| C |-8ms-| \"Done\"\r\n```",
        "createdAt" : "2019-08-31T06:27:55Z",
        "updatedAt" : "2019-08-31T06:27:55Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      },
      {
        "id" : "6e2ee7eb-d9ca-4428-9d4d-1a44516b2d1e",
        "parentId" : "5212a190-d538-443b-af76-97fa1820d0b0",
        "authorId" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "body" : "Nope, this is implement for point 2 above:\r\n\r\n> 2. As long as the schedule wants to continue, emit the stream's next element after a delay",
        "createdAt" : "2019-08-31T06:29:14Z",
        "updatedAt" : "2019-08-31T06:29:15Z",
        "lastEditedBy" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "tags" : [
        ]
      },
      {
        "id" : "fe075c55-3ce6-4c36-8c42-b78d072fc569",
        "parentId" : "5212a190-d538-443b-af76-97fa1820d0b0",
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "And the short circuiting can be attained by `collectWhile { case Right(v) => v }`, which would stop on the first `Left`.",
        "createdAt" : "2019-08-31T06:29:46Z",
        "updatedAt" : "2019-08-31T06:29:46Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      },
      {
        "id" : "51c171c4-ab54-4e04-813a-346a8f6ecce5",
        "parentId" : "5212a190-d538-443b-af76-97fa1820d0b0",
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "(sorry for dragging this!)",
        "createdAt" : "2019-08-31T06:31:23Z",
        "updatedAt" : "2019-08-31T06:31:24Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      },
      {
        "id" : "cee157dc-8f64-4297-ae08-731f787e64ae",
        "parentId" : "5212a190-d538-443b-af76-97fa1820d0b0",
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "Actually, let's merge this and address in a follow-up.",
        "createdAt" : "2019-08-31T06:37:59Z",
        "updatedAt" : "2019-08-31T06:37:59Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      },
      {
        "id" : "c7f52351-c132-446f-882b-7d937fed5518",
        "parentId" : "5212a190-d538-443b-af76-97fa1820d0b0",
        "authorId" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "body" : "That is the semantics of `scheduleElements`, isn't it? 🤔 I could add a test to prove that.",
        "createdAt" : "2019-08-31T06:44:14Z",
        "updatedAt" : "2019-08-31T06:44:14Z",
        "lastEditedBy" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "tags" : [
        ]
      },
      {
        "id" : "8fb0bfb5-5d4a-4e35-baf5-62510cf72f00",
        "parentId" : "5212a190-d538-443b-af76-97fa1820d0b0",
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "Ah not quite. `scheduleElements` repeats every element and restarts",
        "createdAt" : "2019-08-31T06:45:30Z",
        "updatedAt" : "2019-08-31T06:45:30Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      }
    ],
    "commit" : "2db075de3b605a42e9ce334e929e074a3e56a4a7",
    "line" : 152,
    "diffHunk" : "@@ -1,1 +1636,1640 @@                          decision <- schedule.update(a, sched)\n                          _        <- clock.sleep(decision.delay)\n                          _        <- state.set((!decision.cont, decision.state, Some(decision.finish)))\n                        } yield if (decision.cont) f(a) else g(decision.finish())\n"
  },
  {
    "id" : "b2ecc8a5-60ed-4c3e-954c-4a10a54d727a",
    "prId" : 1434,
    "prUrl" : "https://github.com/zio/zio/pull/1434#pullrequestreview-276283729",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0c9bce22-3e01-4e87-abd9-7451daca5988",
        "parentId" : null,
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "I think we could probably get rid of `Take` entirely here, but we can do that in a followup.",
        "createdAt" : "2019-08-18T15:25:25Z",
        "updatedAt" : "2019-08-19T00:33:35Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      }
    ],
    "commit" : "2e5e5d20720bab5dd51f9d52b5b09cb0e95f84ed",
    "line" : 85,
    "diffHunk" : "@@ -1,1 +1073,1077 @@    type Loser = Either[Fiber[Nothing, Take[E, A]], Fiber[Nothing, Take[E1, B]]]\n\n    def race(\n      left: ZIO[R, Nothing, Take[E, A]],\n      right: ZIO[R1, Nothing, Take[E1, B]]"
  },
  {
    "id" : "9e9fe05f-d22c-4033-ad43-3e188fac55eb",
    "prId" : 1434,
    "prUrl" : "https://github.com/zio/zio/pull/1434#pullrequestreview-276283729",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bae10bb9-9e56-4970-a2bd-33836981cfae",
        "parentId" : null,
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "`optional` is a nice touch here!",
        "createdAt" : "2019-08-18T15:25:54Z",
        "updatedAt" : "2019-08-19T00:33:35Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      }
    ],
    "commit" : "2e5e5d20720bab5dd51f9d52b5b09cb0e95f84ed",
    "line" : 142,
    "diffHunk" : "@@ -1,1 +1429,1433 @@      right: InputStream[R1, E1, B]\n    ): ZIO[R1, E1, ((Boolean, Boolean), Take[E1, C])] = {\n      val takeLeft: ZIO[R, E, Option[A]]    = if (leftDone) IO.succeed(None) else left.optional\n      val takeRight: ZIO[R1, E1, Option[B]] = if (rightDone) IO.succeed(None) else right.optional\n"
  },
  {
    "id" : "47ce0ac1-16a3-4a47-84fb-9a0a26563254",
    "prId" : 1432,
    "prUrl" : "https://github.com/zio/zio/pull/1432#pullrequestreview-279079645",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6a824b28-9c97-4c44-8b5a-938136bfd309",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "At some point, for stack safety, we should switch over to `class ZStream(val process: ZManaged[...])`.",
        "createdAt" : "2019-08-22T09:24:39Z",
        "updatedAt" : "2019-08-23T19:35:35Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      },
      {
        "id" : "a9f56ac9-9ed4-4133-b8ec-1e21982a8a3a",
        "parentId" : "6a824b28-9c97-4c44-8b5a-938136bfd309",
        "authorId" : "6bab7be3-690b-49f9-9a0d-a8415f4c0c8e",
        "body" : "Out of curiosity, would just changing the def to val be enough? Or is the trait to class change necessary as well?",
        "createdAt" : "2019-08-22T09:36:10Z",
        "updatedAt" : "2019-08-23T19:35:35Z",
        "lastEditedBy" : "6bab7be3-690b-49f9-9a0d-a8415f4c0c8e",
        "tags" : [
        ]
      },
      {
        "id" : "15e39c39-4e89-48ec-b9bd-4f2abdf6840e",
        "parentId" : "6a824b28-9c97-4c44-8b5a-938136bfd309",
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "Well, you need a way to \"unwrap\" and then \"rewrap\", rather than add one new stack frame.\r\n\r\nRight now, the outer `process` delegates to the inner `process`, so you end up adding a stack frame for every operation. Eventually you run out of stack.\r\n\r\nWhen you store it as a field that you can extract, map over, and stuff back it, it pushes 100% of the transformation to the ZIO effect type, which is already stack safe.",
        "createdAt" : "2019-08-22T09:39:30Z",
        "updatedAt" : "2019-08-23T19:35:35Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      },
      {
        "id" : "ef13a3f8-a4ce-4c29-b214-aae794745456",
        "parentId" : "6a824b28-9c97-4c44-8b5a-938136bfd309",
        "authorId" : "6bab7be3-690b-49f9-9a0d-a8415f4c0c8e",
        "body" : "I get that completely. My question was wether this is the same.\r\n\r\n`trait Stream { val process: ZManaged[...] }` and `class Stream(val process: ZManaged[...])`.\r\n\r\nI always thought the fields in class constructors are only sugar, there is no actual difference.",
        "createdAt" : "2019-08-22T11:04:48Z",
        "updatedAt" : "2019-08-23T19:35:35Z",
        "lastEditedBy" : "6bab7be3-690b-49f9-9a0d-a8415f4c0c8e",
        "tags" : [
        ]
      },
      {
        "id" : "0b2fc46c-7ab6-4fd0-a061-be7df12edc71",
        "parentId" : "6a824b28-9c97-4c44-8b5a-938136bfd309",
        "authorId" : "6bab7be3-690b-49f9-9a0d-a8415f4c0c8e",
        "body" : "I will address this in a follow up PR.",
        "createdAt" : "2019-08-22T14:02:58Z",
        "updatedAt" : "2019-08-23T19:35:35Z",
        "lastEditedBy" : "6bab7be3-690b-49f9-9a0d-a8415f4c0c8e",
        "tags" : [
        ]
      },
      {
        "id" : "6060ba0a-79aa-4c69-9c77-e051758973f0",
        "parentId" : "6a824b28-9c97-4c44-8b5a-938136bfd309",
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "Ah, I see. No, there is no difference, so long as you are using `val` there (the initialization will happen eagerly and will not contribute to stack depth).",
        "createdAt" : "2019-08-23T14:59:22Z",
        "updatedAt" : "2019-08-23T19:35:35Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      },
      {
        "id" : "200d4fed-88a7-4878-ba1c-9fe5892de12c",
        "parentId" : "6a824b28-9c97-4c44-8b5a-938136bfd309",
        "authorId" : "6bab7be3-690b-49f9-9a0d-a8415f4c0c8e",
        "body" : "As per @iravid's request I will address this in another PR and change to class Stream.",
        "createdAt" : "2019-08-23T15:44:22Z",
        "updatedAt" : "2019-08-23T19:35:35Z",
        "lastEditedBy" : "6bab7be3-690b-49f9-9a0d-a8415f4c0c8e",
        "tags" : [
        ]
      }
    ],
    "commit" : "e28a4b408a233b5686be0523493dcc4de2715124",
    "line" : 71,
    "diffHunk" : "@@ -1,1 +773,777 @@  final def ensuring[R1 <: R](fin: ZIO[R1, Nothing, _]): ZStream[R1, E, A] =\n    new ZStream[R1, E, A] {\n      def process = self.process.ensuring(fin)\n    }\n"
  },
  {
    "id" : "861ff832-953c-422a-838e-3effcbbafb9c",
    "prId" : 1427,
    "prUrl" : "https://github.com/zio/zio/pull/1427#pullrequestreview-278042326",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a7874cff-545b-47e1-b707-ef0425cd20c9",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "This pattern occurs so pervasively I think we should write a combinator to handle it (`finalizer`?). Basically creating a `Ref`, with some default action, then running some code, updating the default, and finally ensuring the finalizer is run at the end. Could be reasonably nice to use with `ZManaged`, I think.",
        "createdAt" : "2019-08-18T10:06:53Z",
        "updatedAt" : "2019-08-22T04:19:41Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      },
      {
        "id" : "8e3c14f0-9982-49c6-a83f-8ee397a05e81",
        "parentId" : "a7874cff-545b-47e1-b707-ef0425cd20c9",
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "Good idea. This looked like a combinator for `ZManaged` - `ZManaged.finalizerRef`.",
        "createdAt" : "2019-08-21T20:06:52Z",
        "updatedAt" : "2019-08-22T04:19:41Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      }
    ],
    "commit" : "79f9daa63961ade3e1f4cb706c242c192b3cdac6",
    "line" : 45,
    "diffHunk" : "@@ -1,1 +533,537 @@      for {\n        finalizer        <- ZManaged.finalizerRef[R1](_ => UIO.unit)\n        selfInputStream  <- Ref.make[InputStream[R, E, A]](InputStream.end).toManaged_\n        otherInputStream <- Ref.make[InputStream[R1, E2, A1]](InputStream.end).toManaged_\n        stateRef         <- Ref.make[State](State.NotStarted).toManaged_"
  },
  {
    "id" : "dc63bb82-55da-4a49-9c55-ad88075c0d91",
    "prId" : 1427,
    "prUrl" : "https://github.com/zio/zio/pull/1427#pullrequestreview-276270602",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "eda081a4-f3d2-41f4-a184-4051c5399684",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "Wonderful to see all these!",
        "createdAt" : "2019-08-18T10:07:30Z",
        "updatedAt" : "2019-08-22T04:19:41Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      }
    ],
    "commit" : "79f9daa63961ade3e1f4cb706c242c192b3cdac6",
    "line" : 186,
    "diffHunk" : "@@ -1,1 +1437,1441 @@   * its dependency on `R`.\n   */\n  final def provide(r: R): Stream[E, A] =\n    ZStream.fromInputStreamManaged(self.process.provide(r).map(_.provide(r)))\n"
  },
  {
    "id" : "c78eae2f-dea6-4f64-8672-d303e2fbc75d",
    "prId" : 1427,
    "prUrl" : "https://github.com/zio/zio/pull/1427#pullrequestreview-276270606",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e942ecca-2185-4a3f-8a04-fd8464320f41",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "Love it!",
        "createdAt" : "2019-08-18T10:07:36Z",
        "updatedAt" : "2019-08-22T04:19:41Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      }
    ],
    "commit" : "79f9daa63961ade3e1f4cb706c242c192b3cdac6",
    "line" : 172,
    "diffHunk" : "@@ -1,1 +1366,1370 @@   * See also [[ZStream#catchAll]].\n   */\n  final def orElse[R1 <: R, E2, A1 >: A](that: => ZStream[R1, E2, A1]): ZStream[R1, E2, A1] =\n    self.catchAll(_ => that)\n"
  },
  {
    "id" : "8a6efab8-5428-44dc-aed8-4662ee4c2e54",
    "prId" : 1413,
    "prUrl" : "https://github.com/zio/zio/pull/1413#pullrequestreview-276104449",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ddb3ed5b-4689-4229-ad40-209a087e919a",
        "parentId" : null,
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "@jdegoes is there another combinator constellation we could use to make this nicer? e.g. a lazy constructor like `construct(head: A, rest: => List[A])`",
        "createdAt" : "2019-08-16T18:11:21Z",
        "updatedAt" : "2019-08-16T18:11:21Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      },
      {
        "id" : "d57ca28e-d38b-4eec-bec6-229c9c8012ba",
        "parentId" : "ddb3ed5b-4689-4229-ad40-209a087e919a",
        "authorId" : "6bab7be3-690b-49f9-9a0d-a8415f4c0c8e",
        "body" : "Awesome trick.",
        "createdAt" : "2019-08-16T18:30:02Z",
        "updatedAt" : "2019-08-16T18:30:02Z",
        "lastEditedBy" : "6bab7be3-690b-49f9-9a0d-a8415f4c0c8e",
        "tags" : [
        ]
      }
    ],
    "commit" : "01ee3ada316a87dfb4b449c9039efafd310aef9d",
    "line" : 117,
    "diffHunk" : "@@ -1,1 +560,564 @@   */\n  final def concat[R1 <: R, E1 >: E, A1 >: A](other: => ZStream[R1, E1, A1]): ZStream[R1, E1, A1] =\n    ZStream(UIO.succeed(self), UIO(other)).flatMap(ZStream.unwrap)\n\n  /**"
  },
  {
    "id" : "f2cbdd9a-da8b-4e6c-bac6-3d099960c202",
    "prId" : 1413,
    "prUrl" : "https://github.com/zio/zio/pull/1413#pullrequestreview-276104668",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "158fcfe6-1f12-4f82-a9f4-08b3a740910b",
        "parentId" : null,
        "authorId" : "6bab7be3-690b-49f9-9a0d-a8415f4c0c8e",
        "body" : "And it's logical conclusion.",
        "createdAt" : "2019-08-16T18:30:30Z",
        "updatedAt" : "2019-08-16T18:30:31Z",
        "lastEditedBy" : "6bab7be3-690b-49f9-9a0d-a8415f4c0c8e",
        "tags" : [
        ]
      }
    ],
    "commit" : "01ee3ada316a87dfb4b449c9039efafd310aef9d",
    "line" : 136,
    "diffHunk" : "@@ -1,1 +910,914 @@   */\n  def forever: ZStream[R, E, A] =\n    self ++ forever\n\n  /**"
  },
  {
    "id" : "1bc44494-7df5-43c6-a915-9a8fb0aa6d63",
    "prId" : 1410,
    "prUrl" : "https://github.com/zio/zio/pull/1410#pullrequestreview-275910390",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "302ec4c4-16ac-41ab-9ebc-d76808b58c75",
        "parentId" : null,
        "authorId" : "6bab7be3-690b-49f9-9a0d-a8415f4c0c8e",
        "body" : "Why not implement in terms of `fromInputStreamManaged`?",
        "createdAt" : "2019-08-16T11:47:25Z",
        "updatedAt" : "2019-08-16T12:13:19Z",
        "lastEditedBy" : "6bab7be3-690b-49f9-9a0d-a8415f4c0c8e",
        "tags" : [
        ]
      },
      {
        "id" : "feba58c7-1c70-407c-8d93-fe59bfafda4f",
        "parentId" : "302ec4c4-16ac-41ab-9ebc-d76808b58c75",
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "Yes, good idea!",
        "createdAt" : "2019-08-16T11:56:49Z",
        "updatedAt" : "2019-08-16T12:13:19Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      }
    ],
    "commit" : "e2998db3cdf961e1936aaefeeb22b06572ab10be",
    "line" : 125,
    "diffHunk" : "@@ -1,1 +1786,1790 @@   * Creates a stream from an [[InputStream]].\n   */\n  final def fromInputStream[R, E, A](is: InputStream[R, E, A]): ZStream[R, E, A] =\n    fromInputStreamManaged(ZManaged.succeed(is))\n"
  },
  {
    "id" : "961fd967-58fc-4b91-8e9a-f57d9f1acd88",
    "prId" : 1401,
    "prUrl" : "https://github.com/zio/zio/pull/1401#pullrequestreview-275338740",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "024e0888-07a5-4c2b-a64f-319415d02773",
        "parentId" : null,
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "@jdegoes could you review this?",
        "createdAt" : "2019-08-15T07:39:57Z",
        "updatedAt" : "2019-08-16T04:21:35Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      },
      {
        "id" : "dce9d720-b6df-4827-be70-3074a32d0f2b",
        "parentId" : "024e0888-07a5-4c2b-a64f-319415d02773",
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "About as terrible as I suspected `flatMap` would be... 😆  not all of course will increase, on average I expect we'll come out with much less code.",
        "createdAt" : "2019-08-15T09:30:09Z",
        "updatedAt" : "2019-08-16T04:21:35Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      }
    ],
    "commit" : "e0352f76e9da7493f7852a4ab6522e87cf10e998",
    "line" : 179,
    "diffHunk" : "@@ -1,1 +688,692 @@        foldDefault\n\n      override def process: ZManaged[R1, E1, ZStream.InputStream[R1, E1, B]] =\n        for {\n          ref <- Ref.make[Option[(InputStream[R1, E1, B], Exit[_, _] => ZIO[R1, Nothing, Any])]](None).toManaged_"
  },
  {
    "id" : "21ade22a-e2bb-4cca-ae2d-016fa19a5a4d",
    "prId" : 1401,
    "prUrl" : "https://github.com/zio/zio/pull/1401#pullrequestreview-275296717",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "130b140f-dab0-4122-8d18-d974e6723b5e",
        "parentId" : null,
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "@jdegoes and this",
        "createdAt" : "2019-08-15T07:40:08Z",
        "updatedAt" : "2019-08-16T04:21:35Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      }
    ],
    "commit" : "e0352f76e9da7493f7852a4ab6522e87cf10e998",
    "line" : 380,
    "diffHunk" : "@@ -1,1 +1918,1922 @@      override def process: ZManaged[R, E, InputStream[R, E, A]] =\n        for {\n          doneRef      <- Ref.make(false).toManaged_\n          finalizerRef <- Ref.make[Exit[_, _] => ZIO[R, Nothing, Any]](_ => UIO.unit).toManaged_\n          _            <- ZManaged.finalizerExit(e => finalizerRef.get.flatMap(_.apply(e)))"
  },
  {
    "id" : "d5e241b5-f12c-456c-b960-7a4e23041377",
    "prId" : 1401,
    "prUrl" : "https://github.com/zio/zio/pull/1401#pullrequestreview-275351362",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "cd0347cd-d4c3-430e-b09e-417e8bddbd39",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "Do we really need to put the pull of `a` inside `uninterruptible`?",
        "createdAt" : "2019-08-15T09:29:35Z",
        "updatedAt" : "2019-08-16T04:21:35Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      },
      {
        "id" : "d30927a7-a8f3-482f-8605-dc829db4b3a4",
        "parentId" : "cd0347cd-d4c3-430e-b09e-417e8bddbd39",
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "The pull of `a` is restored, so it it'll run interruptibly. The rest has some regions that have to run uninterruptibly (e.g. storing the finalizer)",
        "createdAt" : "2019-08-15T09:33:49Z",
        "updatedAt" : "2019-08-16T04:21:35Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      },
      {
        "id" : "aa032c19-532d-48f1-a897-169528d8d552",
        "parentId" : "cd0347cd-d4c3-430e-b09e-417e8bddbd39",
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "Ok, sounds good.",
        "createdAt" : "2019-08-15T10:02:56Z",
        "updatedAt" : "2019-08-16T04:21:35Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      }
    ],
    "commit" : "e0352f76e9da7493f7852a4ab6522e87cf10e998",
    "line" : 184,
    "diffHunk" : "@@ -1,1 +693,697 @@          as  <- self.process\n          _   <- ZManaged.finalizerExit(e => ref.get.flatMap(_.map(_._2).getOrElse((_: Exit[_, _]) => UIO.unit).apply(e)))\n          pullOuter = ZIO.uninterruptibleMask { restore =>\n            restore(as).flatMap { a =>\n              (for {"
  },
  {
    "id" : "bd073cc1-76b2-4584-9b44-f5626b1ee1bb",
    "prId" : 1401,
    "prUrl" : "https://github.com/zio/zio/pull/1401#pullrequestreview-275345547",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6de97dc3-8a86-482a-a1b0-952929ecc27d",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "Ensuring the `finalizer` is not interrupted is one thing, we also really need to ensure the `finalizer` will be run in all cases, i.e. that `go` will not be interrupted right before it even begins execution of the finalizer.",
        "createdAt" : "2019-08-15T09:32:24Z",
        "updatedAt" : "2019-08-16T04:21:35Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      },
      {
        "id" : "60a2fc54-b496-4cd5-99ad-fd77ef862e52",
        "parentId" : "6de97dc3-8a86-482a-a1b0-952929ecc27d",
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "Ouch, good point. Will use `uninterruptibleMask` here too.",
        "createdAt" : "2019-08-15T09:34:43Z",
        "updatedAt" : "2019-08-16T04:21:35Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      },
      {
        "id" : "d1343762-727c-4767-8935-a0d7c4f6104c",
        "parentId" : "6de97dc3-8a86-482a-a1b0-952929ecc27d",
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "@jdegoes Oh, I actually handled this. If `go` gets interrupted before running the finalizer, the `ZManaged` will execute the stored finalizer (line 697).",
        "createdAt" : "2019-08-15T09:47:18Z",
        "updatedAt" : "2019-08-16T04:21:35Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      }
    ],
    "commit" : "e0352f76e9da7493f7852a4ab6522e87cf10e998",
    "line" : 199,
    "diffHunk" : "@@ -1,1 +708,712 @@                isB.catchAll {\n                  case e @ Some(e1) => (finalizer(Exit.fail(e1)) *> ref.set(None)).uninterruptible *> ZIO.fail(e)\n                  case None         => (finalizer(Exit.succeed(())) *> ref.set(None)).uninterruptible *> pullOuter *> go\n                }\n            }"
  },
  {
    "id" : "74b07528-c77c-4986-b427-e6b6577c63f9",
    "prId" : 1401,
    "prUrl" : "https://github.com/zio/zio/pull/1401#pullrequestreview-275366457",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f0fe0a71-6a2a-41ac-a640-7546182f73bb",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "If we had a helper:\r\n\r\n```scala\r\nobject InputStream {\r\n  def singleton(a: A): UIO[InputStream[Any, Nothing, A]] = \r\n    Ref.make[Option[A]](Some(a)).map(ref =>\r\n      ref.modify {\r\n        case None => ZIO.fail(()) -> None\r\n        case Some(a) => ZIO.succeed(a) -> None\r\n      }.flatten)\r\n```\r\n\r\nThen it might make this one easier to verify.\r\n\r\nThinking what you want to do is map the `A` inside the managed into the input stream. The current version seems quite aggressive about uninterruptibility...",
        "createdAt" : "2019-08-15T10:01:59Z",
        "updatedAt" : "2019-08-16T04:21:35Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      },
      {
        "id" : "13f141a1-ec88-483f-8bc6-069e1ebe943e",
        "parentId" : "f0fe0a71-6a2a-41ac-a640-7546182f73bb",
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "That helper looks useful!\r\n\r\nThe logic for this constructor is almost what you wrote; I want the managed to allocate the `A` only when the InputStream is pulled. Does that make sense?",
        "createdAt" : "2019-08-15T10:04:41Z",
        "updatedAt" : "2019-08-16T04:21:35Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      },
      {
        "id" : "4da62c57-f439-4e2c-a3bb-26fe547e8dda",
        "parentId" : "f0fe0a71-6a2a-41ac-a640-7546182f73bb",
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "It does, but I can't convince myself there's a difference because of the contract on the original `ZManaged[..., A]` that is being lifted.",
        "createdAt" : "2019-08-15T10:38:41Z",
        "updatedAt" : "2019-08-16T04:21:35Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      },
      {
        "id" : "fad0645d-6a70-4423-8a30-38abad4daf7d",
        "parentId" : "f0fe0a71-6a2a-41ac-a640-7546182f73bb",
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "I *think* (not sure yet!) it matters when composing streams together. You're lifting a managed resource to a single-element stream and then flatMap it to create a multiple-element stream. So it should only allocate when you pull the composed stream; not when you enter the scope of the composed stream.",
        "createdAt" : "2019-08-15T10:47:14Z",
        "updatedAt" : "2019-08-16T04:21:35Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      }
    ],
    "commit" : "e0352f76e9da7493f7852a4ab6522e87cf10e998",
    "line" : 383,
    "diffHunk" : "@@ -1,1 +1921,1925 @@          finalizerRef <- Ref.make[Exit[_, _] => ZIO[R, Nothing, Any]](_ => UIO.unit).toManaged_\n          _            <- ZManaged.finalizerExit(e => finalizerRef.get.flatMap(_.apply(e)))\n          pull = ZIO.uninterruptibleMask { restore =>\n            doneRef.get.flatMap { done =>\n              if (done) InputStream.end"
  },
  {
    "id" : "c7a45c86-ec6b-403e-b497-37ef48a3986e",
    "prId" : 1401,
    "prUrl" : "https://github.com/zio/zio/pull/1401#pullrequestreview-275693029",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6cfa4f18-de81-4de8-bdc0-66455de14e96",
        "parentId" : null,
        "authorId" : "6bab7be3-690b-49f9-9a0d-a8415f4c0c8e",
        "body" : "Should have been like this from the start. Nice.",
        "createdAt" : "2019-08-15T22:03:04Z",
        "updatedAt" : "2019-08-16T04:21:35Z",
        "lastEditedBy" : "6bab7be3-690b-49f9-9a0d-a8415f4c0c8e",
        "tags" : [
        ]
      }
    ],
    "commit" : "e0352f76e9da7493f7852a4ab6522e87cf10e998",
    "line" : 38,
    "diffHunk" : "@@ -1,1 +556,560 @@   */\n  final def concat[R1 <: R, E1 >: E, A1 >: A](other: ZStream[R1, E1, A1]): ZStream[R1, E1, A1] =\n    Stream(self, other).flatMap(identity)\n\n  /**"
  },
  {
    "id" : "9738cdb2-055f-46a5-b4dd-0b8cddb331c1",
    "prId" : 1391,
    "prUrl" : "https://github.com/zio/zio/pull/1391#pullrequestreview-274067884",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "392dd35d-2299-4634-86dc-9bdbf9d943ed",
        "parentId" : null,
        "authorId" : "2a2f79ba-933f-43cd-9d45-5d769ab0f54d",
        "body" : "The way I understood @iravid was that we keep this abstract and put process = processDefault on all anonymous subclasses that we create here.",
        "createdAt" : "2019-08-12T23:54:52Z",
        "updatedAt" : "2019-08-13T07:56:57Z",
        "lastEditedBy" : "2a2f79ba-933f-43cd-9d45-5d769ab0f54d",
        "tags" : [
        ]
      },
      {
        "id" : "ef523e2f-5504-4e86-affa-e1a93b2c7083",
        "parentId" : "392dd35d-2299-4634-86dc-9bdbf9d943ed",
        "authorId" : "6bab7be3-690b-49f9-9a0d-a8415f4c0c8e",
        "body" : "Yes, it'll have to be done sooner or later.",
        "createdAt" : "2019-08-13T05:33:33Z",
        "updatedAt" : "2019-08-13T07:56:57Z",
        "lastEditedBy" : "6bab7be3-690b-49f9-9a0d-a8415f4c0c8e",
        "tags" : [
        ]
      }
    ],
    "commit" : "492049b372770e5bd4a49145b9c9d5887ce44db5",
    "line" : 12,
    "diffHunk" : "@@ -1,1 +45,49 @@   * is valid only inside the scope of the managed resource.\n   */\n  def process: ZManaged[R, E, InputStream[E, A]] = processDefault\n\n  /**"
  },
  {
    "id" : "62c0d5d0-4674-4610-83ae-7a18eeab7dfe",
    "prId" : 1387,
    "prUrl" : "https://github.com/zio/zio/pull/1387#pullrequestreview-273540356",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ecbbc6de-7377-48e3-9824-a622cf7263b0",
        "parentId" : null,
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "Good catch",
        "createdAt" : "2019-08-12T07:36:43Z",
        "updatedAt" : "2019-08-17T21:07:16Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      }
    ],
    "commit" : "a4585e4a9d128a025aa44b2188cd2187559cfd32",
    "line" : 124,
    "diffHunk" : "@@ -1,1 +938,942 @@   * Consumes all elements of the stream, passing them to the specified callback.\n   */\n  final def foreach[R1 <: R, E1 >: E](f: A => ZIO[R1, E1, _]): ZIO[R1, E1, Unit] =\n    foreachWhile(f.andThen(_.as(true)))\n"
  },
  {
    "id" : "4f3703ca-c46b-44c2-a5c1-a386f87cf248",
    "prId" : 1387,
    "prUrl" : "https://github.com/zio/zio/pull/1387#pullrequestreview-274091261",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "47f98acc-b2b0-48bf-909b-411712578d9f",
        "parentId" : null,
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "Very nice!",
        "createdAt" : "2019-08-12T07:38:19Z",
        "updatedAt" : "2019-08-17T21:07:16Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      },
      {
        "id" : "e6b580de-e175-49f7-96e0-d87ba238f001",
        "parentId" : "47f98acc-b2b0-48bf-909b-411712578d9f",
        "authorId" : "73db9f28-01ba-4a29-946b-7a2ae5ac5350",
        "body" : "👍",
        "createdAt" : "2019-08-13T07:13:54Z",
        "updatedAt" : "2019-08-17T21:07:16Z",
        "lastEditedBy" : "73db9f28-01ba-4a29-946b-7a2ae5ac5350",
        "tags" : [
        ]
      }
    ],
    "commit" : "a4585e4a9d128a025aa44b2188cd2187559cfd32",
    "line" : 242,
    "diffHunk" : "@@ -1,1 +1522,1526 @@   * Interrupts the stream if it does not produce a value after d duration.\n   */\n  final def timeout(d: Duration): ZStream[R with Clock, E, A] =\n    new ZStream[R with Clock, E, A] {\n      def process ="
  },
  {
    "id" : "0857c84e-6ef4-4fca-8ccc-7649e2483918",
    "prId" : 1387,
    "prUrl" : "https://github.com/zio/zio/pull/1387#pullrequestreview-276250347",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1791c1fb-4923-48ad-a03b-1af258476116",
        "parentId" : null,
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "This API is very clever! Nice work :-)",
        "createdAt" : "2019-08-17T18:09:45Z",
        "updatedAt" : "2019-08-17T21:07:16Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      },
      {
        "id" : "ce10683e-10d5-4232-b000-bec534879902",
        "parentId" : "1791c1fb-4923-48ad-a03b-1af258476116",
        "authorId" : "2a2f79ba-933f-43cd-9d45-5d769ab0f54d",
        "body" : "Thanks! :)",
        "createdAt" : "2019-08-17T20:27:52Z",
        "updatedAt" : "2019-08-17T21:07:16Z",
        "lastEditedBy" : "2a2f79ba-933f-43cd-9d45-5d769ab0f54d",
        "tags" : [
        ]
      }
    ],
    "commit" : "a4585e4a9d128a025aa44b2188cd2187559cfd32",
    "line" : 304,
    "diffHunk" : "@@ -1,1 +1717,1721 @@     * Run the function across all groups, collecting the results in an arbitrary order.\n     */\n    def apply[R1 <: R, E1 >: E, A](f: (K, Stream[E, V]) => ZStream[R1, E1, A]): ZStream[R1, E1, A] =\n      grouped.flatMapPar[R1, E1, A](Int.MaxValue, buffer) {\n        case (k, q) =>"
  },
  {
    "id" : "dd57b9be-9e16-4f30-9114-449f8e1be219",
    "prId" : 1387,
    "prUrl" : "https://github.com/zio/zio/pull/1387#pullrequestreview-277507057",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "862b8411-10d9-4bb4-b687-ab97358f2d71",
        "parentId" : null,
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "scaladoc needs adjusting here",
        "createdAt" : "2019-08-20T19:07:38Z",
        "updatedAt" : "2019-08-20T19:08:12Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      },
      {
        "id" : "78bc6110-2e75-4b5e-b0ac-49bcd19a532a",
        "parentId" : "862b8411-10d9-4bb4-b687-ab97358f2d71",
        "authorId" : "2a2f79ba-933f-43cd-9d45-5d769ab0f54d",
        "body" : "Sure. Will try to do it tomorrow :) ",
        "createdAt" : "2019-08-21T00:30:45Z",
        "updatedAt" : "2019-08-21T00:30:46Z",
        "lastEditedBy" : "2a2f79ba-933f-43cd-9d45-5d769ab0f54d",
        "tags" : [
        ]
      }
    ],
    "commit" : "a4585e4a9d128a025aa44b2188cd2187559cfd32",
    "line" : 48,
    "diffHunk" : "@@ -1,1 +571,575 @@\n  /**\n   * More powerful version of `ZStream#toQueues`. Allows to provide a function that determines what\n   * queues should receive which elements.\n   */"
  },
  {
    "id" : "fa09bdfc-c3a5-4834-a635-41d0bbc1aaf7",
    "prId" : 1387,
    "prUrl" : "https://github.com/zio/zio/pull/1387#pullrequestreview-277379687",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e75bf8c4-d045-47d3-9f6d-3f45e6256b5d",
        "parentId" : null,
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "and here",
        "createdAt" : "2019-08-20T19:07:44Z",
        "updatedAt" : "2019-08-20T19:08:12Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      }
    ],
    "commit" : "a4585e4a9d128a025aa44b2188cd2187559cfd32",
    "line" : 63,
    "diffHunk" : "@@ -1,1 +586,590 @@\n  /**\n   * More powerful version of `ZStream#toQueuesBalanced`. This returns a function that will produce\n   * new queues and corresponding indices.\n   * You can also provide a function that will be executed after the final events are enqueued in all queues"
  },
  {
    "id" : "b6c3dee1-b196-49d3-88d7-88925a96d47c",
    "prId" : 1355,
    "prUrl" : "https://github.com/zio/zio/pull/1355#pullrequestreview-272770646",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1227a366-2632-4fec-a916-c1f876e0eccb",
        "parentId" : null,
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "Nice code removal here!",
        "createdAt" : "2019-08-08T20:11:17Z",
        "updatedAt" : "2019-08-09T11:00:32Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      }
    ],
    "commit" : "07f174de0c753d18d26d378bb19108f26cd8e36b",
    "line" : 247,
    "diffHunk" : "@@ -1,1 +1467,1471 @@  final def zipWith[R1 <: R, E1 >: E, B, C](that: ZStream[R1, E1, B], lc: Int = 2, rc: Int = 2)(\n    f0: (Option[A], Option[B]) => Option[C]\n  ): ZStream[R1, E1, C] = {\n    def loop(\n      leftDone: Boolean,"
  },
  {
    "id" : "91067be5-5193-43f4-8130-aa3618d3e881",
    "prId" : 1355,
    "prUrl" : "https://github.com/zio/zio/pull/1355#pullrequestreview-273091207",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "788d7ef3-36e4-4296-bad9-596085fe5b8f",
        "parentId" : null,
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "This is so nice!",
        "createdAt" : "2019-08-09T11:45:58Z",
        "updatedAt" : "2019-08-09T11:50:35Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      }
    ],
    "commit" : "07f174de0c753d18d26d378bb19108f26cd8e36b",
    "line" : 192,
    "diffHunk" : "@@ -1,1 +1091,1095 @@      )\n\n    self.combine(that)((false, false, Option.empty[Loser])) {\n      case ((leftDone, rightDone, loser), left, right) =>\n        if (leftDone) {"
  },
  {
    "id" : "6aa76cce-ffe0-4597-a31b-877673e7302c",
    "prId" : 1265,
    "prUrl" : "https://github.com/zio/zio/pull/1265#pullrequestreview-268414096",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "491b698d-a7d6-4db7-9b1b-97d7cf20944f",
        "parentId" : null,
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "I liked `cancelersGuard` but simpler is of course better :-) Are there any race conditions that could happen here with the handlers in the `foldCauseM` or the finalizer on the outer stream below?",
        "createdAt" : "2019-07-30T13:31:23Z",
        "updatedAt" : "2019-07-31T08:06:23Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      },
      {
        "id" : "795bafc6-a672-4a22-9059-dd5b70300d9b",
        "parentId" : "491b698d-a7d6-4db7-9b1b-97d7cf20944f",
        "authorId" : "6bab7be3-690b-49f9-9a0d-a8415f4c0c8e",
        "body" : "Technically, and I realized this when developing this PR, the `cancelers` queue is protected by the `permits` semaphore, if we block the continutaion of the `foreachManaged`, which we have `Managed` to do here. Sorry for the bad joke.",
        "createdAt" : "2019-07-30T13:58:56Z",
        "updatedAt" : "2019-07-31T08:06:23Z",
        "lastEditedBy" : "6bab7be3-690b-49f9-9a0d-a8415f4c0c8e",
        "tags" : [
        ]
      },
      {
        "id" : "b86ea982-4424-4af7-99d2-564a97370bf2",
        "parentId" : "491b698d-a7d6-4db7-9b1b-97d7cf20944f",
        "authorId" : "6bab7be3-690b-49f9-9a0d-a8415f4c0c8e",
        "body" : "Again, the `latch` makes sure that an inner stream gets at least a chance to run its `bracket` operation, which means that the finalizer on the outer stream has to compete with the last `n` inner streams for the `permits`, at which point this becomes semantically the same with `flatMapPar`, so I'd think that we are pretty safe from any race conditions.",
        "createdAt" : "2019-07-30T14:01:38Z",
        "updatedAt" : "2019-07-31T08:06:23Z",
        "lastEditedBy" : "6bab7be3-690b-49f9-9a0d-a8415f4c0c8e",
        "tags" : [
        ]
      }
    ],
    "commit" : "b865812f4ae636b39776118e4b656d1c8319bc31",
    "line" : 36,
    "diffHunk" : "@@ -1,1 +748,752 @@                    canceler <- Promise.make[Nothing, Unit]\n                    latch    <- Promise.make[Nothing, Unit]\n                    size     <- cancelers.size\n                    _ <- if (size < n) UIO.unit\n                        else cancelers.take.flatMap(_.succeed(())).unit"
  },
  {
    "id" : "633e6e15-1d86-40c3-932b-fa0972ee94f8",
    "prId" : 1207,
    "prUrl" : "https://github.com/zio/zio/pull/1207#pullrequestreview-264531538",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9b1126a8-8dc1-4eec-a857-afe7b4a02064",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "Ouch.",
        "createdAt" : "2019-07-21T11:13:06Z",
        "updatedAt" : "2019-07-21T11:13:06Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      }
    ],
    "commit" : "e5044777d946bf37071837a1302e4b025ae8533d",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +1537,1541 @@            output  <- Queue.bounded[Take[E1, A1]](outputBuffer).toManaged(_.shutdown)\n            runtime <- ZIO.runtime[R].toManaged_\n            eitherStream <- UIO {\n                             register(\n                               k =>"
  },
  {
    "id" : "7782b56e-415a-4da7-b1af-9f1b13e33de8",
    "prId" : 1118,
    "prUrl" : "https://github.com/zio/zio/pull/1118#pullrequestreview-256356158",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "443d0496-ed57-4247-8269-3ec14061b242",
        "parentId" : null,
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "Wow this is really cool.",
        "createdAt" : "2019-07-01T14:05:33Z",
        "updatedAt" : "2019-07-19T09:07:23Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      }
    ],
    "commit" : "f871377a82bcaaebcb2cda93c43923e3c118220b",
    "line" : 22,
    "diffHunk" : "@@ -1,1 +1041,1045 @@   */\n  final def effectAsyncMaybe[R, E, A](\n    register: (ZIO[R, E, A] => Unit) => Option[ZStream[R, E, A]],\n    outputBuffer: Int = 16\n  ): ZStream[R, E, A] ="
  },
  {
    "id" : "9f0a6973-14cd-4fc3-b619-b5f9fe8c7c68",
    "prId" : 1020,
    "prUrl" : "https://github.com/zio/zio/pull/1020#pullrequestreview-250224053",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1b85ce3b-f3b7-4f89-bc23-50817d7b8916",
        "parentId" : null,
        "authorId" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "body" : "isn't there a chance here that `interruptInners.await` wins the race before `innerStream` has had the chance to eval `latch.succeed`?",
        "createdAt" : "2019-06-16T09:42:51Z",
        "updatedAt" : "2019-06-16T09:42:51Z",
        "lastEditedBy" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "tags" : [
        ]
      },
      {
        "id" : "ca2f6608-32d4-4a49-8428-8781ed1fe0de",
        "parentId" : "1b85ce3b-f3b7-4f89-bc23-50817d7b8916",
        "authorId" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "body" : "Erm, no.",
        "createdAt" : "2019-06-16T09:44:14Z",
        "updatedAt" : "2019-06-16T09:44:14Z",
        "lastEditedBy" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "tags" : [
        ]
      },
      {
        "id" : "e94cf568-86b8-4b66-8612-0041df7dde9b",
        "parentId" : "1b85ce3b-f3b7-4f89-bc23-50817d7b8916",
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "I think that's ok because only the short-circuiting/interruption finalizer would be the one triggering `interruptInners` in that case.",
        "createdAt" : "2019-06-16T09:45:19Z",
        "updatedAt" : "2019-06-16T09:45:19Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      }
    ],
    "commit" : "59f73dfad6bf4cf7f8ce5deffda7a45504634bfc",
    "line" : 77,
    "diffHunk" : "@@ -1,1 +267,271 @@                             _ => ZIO.unit\n                           )\n                         _ <- (innerStream race interruptInners.await).fork\n                         // Make sure that the current inner stream has actually succeeded in acquiring\n                         // a permit before continuing. Otherwise, two bad things happen:"
  },
  {
    "id" : "4eaf1579-cb56-478e-9523-e94d348d6201",
    "prId" : 1015,
    "prUrl" : "https://github.com/zio/zio/pull/1015#pullrequestreview-249895873",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0173c657-0af6-4610-813f-8cb4b7df4c75",
        "parentId" : null,
        "authorId" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "body" : "🤯 this is nice.",
        "createdAt" : "2019-06-14T13:16:34Z",
        "updatedAt" : "2019-06-14T13:58:39Z",
        "lastEditedBy" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "tags" : [
        ]
      }
    ],
    "commit" : "fbca0cdf4c8b8226b8dfe940cd8de86fe51b5b07",
    "line" : 87,
    "diffHunk" : "@@ -1,1 +284,288 @@                }.foldCauseM(\n                    cause =>\n                      (interruptInners.succeed(()) *> permits.acquireN(n) *> out\n                        .offer(Take.Fail(cause))).unit.toManaged_,\n                    _ =>"
  }
]
[
  {
    "id" : "245b303e-4ff5-49a2-b1c7-9b84d98ad035",
    "prId" : 4959,
    "prUrl" : "https://github.com/apache/kafka/pull/4959#pullrequestreview-121254697",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "72ead43d-dc45-489e-9011-210004eede6e",
        "parentId" : null,
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "Why this renaming?",
        "createdAt" : "2018-05-14T18:54:39Z",
        "updatedAt" : "2018-05-18T21:57:57Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "9ff28ddb-635f-4c65-a508-fd4aebec03f8",
        "parentId" : "72ead43d-dc45-489e-9011-210004eede6e",
        "authorId" : "e431deb4-a19e-4e78-a775-12af049c9089",
        "body" : "Intellij madness that I missed. Fixing...",
        "createdAt" : "2018-05-14T22:58:48Z",
        "updatedAt" : "2018-05-18T21:57:57Z",
        "lastEditedBy" : "e431deb4-a19e-4e78-a775-12af049c9089",
        "tags" : [
        ]
      },
      {
        "id" : "905a4a20-3033-4765-b63f-54b976b610f1",
        "parentId" : "72ead43d-dc45-489e-9011-210004eede6e",
        "authorId" : "e431deb4-a19e-4e78-a775-12af049c9089",
        "body" : "Ah, no, not madness - I changed it to match the scala doc parameter name. ",
        "createdAt" : "2018-05-14T22:59:49Z",
        "updatedAt" : "2018-05-18T21:57:57Z",
        "lastEditedBy" : "e431deb4-a19e-4e78-a775-12af049c9089",
        "tags" : [
        ]
      },
      {
        "id" : "460e8b17-ea09-413a-8c86-67a29db8ca5a",
        "parentId" : "72ead43d-dc45-489e-9011-210004eede6e",
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "Maybe we should update the doc parameter name instead?",
        "createdAt" : "2018-05-15T22:31:04Z",
        "updatedAt" : "2018-05-18T21:57:57Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "af33c393-6c69-4e86-b11a-d21e2b330c35",
        "parentId" : "72ead43d-dc45-489e-9011-210004eede6e",
        "authorId" : "e431deb4-a19e-4e78-a775-12af049c9089",
        "body" : "Sure, I just prefer short param names.",
        "createdAt" : "2018-05-17T23:58:34Z",
        "updatedAt" : "2018-05-18T21:57:57Z",
        "lastEditedBy" : "e431deb4-a19e-4e78-a775-12af049c9089",
        "tags" : [
        ]
      }
    ],
    "commit" : "33adaa715c6b8d930bb8a901a7406d9f0904e81a",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +321,325 @@   * @see `org.apache.kafka.streams.kstream.KStream#transformValues`\n   */ \n  def transformValues[VR](valueTransformerSupplier: ValueTransformerWithKeySupplier[K, V, VR],\n                          stateStoreNames: String*): KStream[K, VR] = {\n    inner.transformValues[VR](valueTransformerSupplier, stateStoreNames: _*)"
  },
  {
    "id" : "e79d53a2-3cde-449f-8521-50e538b8d13e",
    "prId" : 4971,
    "prUrl" : "https://github.com/apache/kafka/pull/4971#pullrequestreview-118052823",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1bbc37f7-e17c-437b-a1e3-1cdfdc30d2d2",
        "parentId" : null,
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "nit: align idention",
        "createdAt" : "2018-05-07T16:06:00Z",
        "updatedAt" : "2018-05-07T16:06:10Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      }
    ],
    "commit" : "f7ae64684224e1ddb9b41ee4ae040b36907fc1f7",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +267,271 @@   *\n   * @param transformer the `Transformer` instance\n   * @param stateStoreNames     the names of the state stores used by the processor\n   * @return a [[KStream]] that contains more or less records with new key and value (possibly of different type)\n   * @see `org.apache.kafka.streams.kstream.KStream#transform`"
  },
  {
    "id" : "c959dd3d-55ab-4395-8851-9edc3dbc8459",
    "prId" : 5019,
    "prUrl" : "https://github.com/apache/kafka/pull/5019#pullrequestreview-121109972",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "17fd4c38-de0f-48e1-8bb5-f611f2c602af",
        "parentId" : null,
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "Similarly, not sure what's the rationale of the refactoring here.",
        "createdAt" : "2018-05-17T15:49:57Z",
        "updatedAt" : "2018-05-18T17:20:41Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "b4359fb1-86b2-49c0-a59c-40ad5d66705f",
        "parentId" : "17fd4c38-de0f-48e1-8bb5-f611f2c602af",
        "authorId" : "7b2b0b66-666b-4e5c-beda-94b652bf1309",
        "body" : "Same as my last comment ..",
        "createdAt" : "2018-05-17T16:02:27Z",
        "updatedAt" : "2018-05-18T17:20:41Z",
        "lastEditedBy" : "7b2b0b66-666b-4e5c-beda-94b652bf1309",
        "tags" : [
        ]
      }
    ],
    "commit" : "0d55f3bf6aeeec244c9b2f96a032e00636020ff7",
    "line" : 147,
    "diffHunk" : "@@ -1,1 +435,439 @@   * @see `org.apache.kafka.streams.kstream.KStream#join`\n   */\n  def join[VT, VR](table: KTable[K, VT])(joiner: (V, VT) => VR)(implicit joined: Joined[K, V, VT]): KStream[K, VR] =\n    inner.join[VT, VR](table.inner, joiner.asValueJoiner, joined)\n"
  },
  {
    "id" : "33280dd9-90ad-4472-9099-cb5bc96b59f5",
    "prId" : 5481,
    "prUrl" : "https://github.com/apache/kafka/pull/5481#pullrequestreview-144636522",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2c59bd7a-44a6-4e61-98f3-c638f3f06d95",
        "parentId" : null,
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "Question: should we reform the process method to also expect a `ProcessorSupplier`? It shouldn't break anyone on 2.12+ due to SAM conversion.",
        "createdAt" : "2018-08-08T18:13:07Z",
        "updatedAt" : "2018-08-09T14:42:06Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      },
      {
        "id" : "4851003c-47a9-47f6-9108-ed8b5edee3b0",
        "parentId" : "2c59bd7a-44a6-4e61-98f3-c638f3f06d95",
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "I don't think we should change `process` because it would require a KIP. We should rather fix the bug only. Maybe be can create a Jira for it though.",
        "createdAt" : "2018-08-08T22:44:07Z",
        "updatedAt" : "2018-08-09T14:42:06Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      }
    ],
    "commit" : "1aee2f257ef30db4902789058e2dcba7faff678c",
    "line" : 79,
    "diffHunk" : "@@ -1,1 +297,301 @@   * @see `org.apache.kafka.streams.kstream.KStream#transform`\n   */\n  def transform[K1, V1](transformerSupplier: TransformerSupplier[K, V, KeyValue[K1, V1]],\n                        stateStoreNames: String*): KStream[K1, V1] =\n    inner.transform(transformerSupplier, stateStoreNames: _*)"
  },
  {
    "id" : "25bcf384-c795-4cfe-a698-4da7de825e31",
    "prId" : 5793,
    "prUrl" : "https://github.com/apache/kafka/pull/5793#pullrequestreview-164481804",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8eac71fd-c8a6-4b24-b8e9-42f871abde4c",
        "parentId" : null,
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "hmm :/ I guess we can't deprecate the old variant without creating ambiguities in the implicits?",
        "createdAt" : "2018-10-12T18:29:10Z",
        "updatedAt" : "2018-10-16T04:26:05Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      },
      {
        "id" : "66e6d8fe-a938-454b-b60d-1748613bd5eb",
        "parentId" : "8eac71fd-c8a6-4b24-b8e9-42f871abde4c",
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "This is my only semi-major concern.",
        "createdAt" : "2018-10-12T19:02:15Z",
        "updatedAt" : "2018-10-16T04:26:05Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      },
      {
        "id" : "1d3a5989-969e-48f4-9cb0-e263fcdf1a70",
        "parentId" : "8eac71fd-c8a6-4b24-b8e9-42f871abde4c",
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "tl;dr: we can't do this in a way that breaks no one. We have to choose between two populations of users to break.\r\n\r\nAfter actually trying this, we face the following dilemma:\r\n\r\n1. **if our users are importing the implicit conversions with a wildcard** (`import org.apache.kafka.streams.scala.ImplicitConversions._`), **then having both overloads in `KStream` will break them.**\r\nThis is because the compiler says \"I have some serdes. I need either a `Grouped` or a `Serialized`. I know how to make both `Grouped` and `Serialized` from the serdes I have. Therefore, I need the programmer to resolve this ambiguity.\"\r\n**On the other hand, if we just drop the Serialized overload, their code will continue to work**, since the compiler will just use the implicit conversion to produce a Grouped instead of a Serialized.\r\n\r\n2. **if they are only importing the implicit conversions they need** (`import org.apache.kafka.streams.scala.ImplicitConversions.serializedFromSerde`), **then dropping the Serialized overload will break them**.\r\nThis is because the compiler only knows how to implicitly produce a Serialized, not a Grouped.\r\nOn the other hand, **if we keep both overloads, their code will continue to work**, and in fact, they'll get a deprecation warning to switch to grouped, which they could do by just omitting `serializedFromSerde` and importing `groupedFromSerde` instead.\r\n\r\nJust to preach for a second, this is why it's dangerous to use wildcard imports with implicit conversions... you have no idea what is actually happening. Implicits are nice for saving boilerplate, not for saving you from knowing what your program is doing.\r\n\r\nSo my opinionated preference is that our users should be going with the specific imports (2), and therefore we should do the same thing with the scala API as we do with the java one: deprecate old methods.\r\n\r\nBut pragmatically, I think the fact that the original contributors used the wildcard pattern (1) suggests that our scala users in general are more likely to also be using pattern 1. In turn, this suggests we should just go ahead and replace the Serialized method with the Grouped one.",
        "createdAt" : "2018-10-12T21:12:45Z",
        "updatedAt" : "2018-10-16T04:26:05Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      },
      {
        "id" : "20eba14a-6a4b-418d-beb2-09bf7eb943ff",
        "parentId" : "8eac71fd-c8a6-4b24-b8e9-42f871abde4c",
        "authorId" : "4c968502-bb3d-46ee-8719-0c0bdbc6242f",
        "body" : "I've been thinking about this and just yanking out `Serialized` with no prior warning doesn't feel like it's the correct thing to do, so I have an another proposal\r\n\r\n1. I'll submit another minor PR where we deprecate `Serialized` in the Scala API.  This PR should get merged to trunk and cherry-picked to 2.1 and go with the 2.1 release. Also, update the docs stating we'll remove `Serialized` (from the Scala API) in the next release.\r\n\r\n2. Update this PR to remove `Serialized` (per @vvcephei comments above) and associated methods and tests. Then merge it after the code freeze, so that it ships with 2.2.  Then we will have provided one release \"warning\" so to speak.\r\n\r\nIMHO it's import to take these steps now, as it's too easy to let the Scala API \"drift\" some.\r\n\r\nWDYT?\r\n\r\n\\cc @guozhangwang @mjsax @vvcephei ",
        "createdAt" : "2018-10-13T15:49:37Z",
        "updatedAt" : "2018-10-16T04:26:05Z",
        "lastEditedBy" : "4c968502-bb3d-46ee-8719-0c0bdbc6242f",
        "tags" : [
        ]
      },
      {
        "id" : "17e6bc42-a601-4bed-a0e7-c1f8c05e76de",
        "parentId" : "8eac71fd-c8a6-4b24-b8e9-42f871abde4c",
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "I agree. Scala API is public API same as Java. Deprecating `Serialized` in Scala should be part of the KIP (Bill, can you update it?) -- I think, we need to be more careful in the future and include Scala API impact in all KIP discussions (guess, Scala API is still too new, so we tend to let it slip, what we should do better in the future).\r\n\r\nI am just not sure, if we can/should remove the `Serialized` in 2.2 already. In the past, we used only mayor releases to remove deprecate APIs, so for this, it might be 3.0 (I say 'might' because, we should keep deprecates API for a year, too, so only remove if both conditions are met).\r\n\r\nThoughts?",
        "createdAt" : "2018-10-13T19:00:18Z",
        "updatedAt" : "2018-10-16T04:26:05Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "6da3b7c3-ed9b-4439-9176-3d1fd2604510",
        "parentId" : "8eac71fd-c8a6-4b24-b8e9-42f871abde4c",
        "authorId" : "4c968502-bb3d-46ee-8719-0c0bdbc6242f",
        "body" : "@mjsax - I agree with your thoughts on keeping the deprecated API until  3.0. And yes I can update the KIP to mention Scala API deprecation.\r\n\r\nBut as I look at the bigger picture, the driving factor behind adding `Grouped` is that users can name repartition topics and then not break the ability to do a rolling upgrade when adding or removing operations from their topology.\r\n\r\nIMHO by not putting in `Grouped` we are unnecessarily penalizing Scala API users (and I realize it was my suggestion just to deprecate `Serialized` and leave out `Grouped` in this release).\r\n\r\nSo I'm going to amend my proposal to this:\r\n\r\n1. Deprecate `Serialized` as planned\r\n2. Add the `Grouped` updates to the Scala API.\r\n3. Per @vvcephei original suggestions we explicitly list imports concerning implicit converters which will resolve the ambiguous method reference errors.  And to preserve compatibility, we'd include `serializedFromSerde` and not import `groupedFromSerde`.\r\n\r\nI _think_ this approach will work because if a user wants to name a repartition topic, she will have to provide a `Grouped.as(\"name\")` argument (the name can 't be provided implicitly).\r\n\r\nAt that point importing both implicit converters should not cause any ambiguity as `Serialized` is chosen for no args and `Grouped` is used due to the multiple parameter lists of the function  `Grouped.with[K, V](name: String)(implicit keySerde: Serde[K], valueSerde: Serde[V])`.\r\n\r\nI'll verify this approach with some updated tests; then we can include everything in this PR for 2.1 and remove `Serialized` in a future release when deeming necessary.  Also, I can update the documentation to explain this situation to users and not to\r\n\r\nThoughts?",
        "createdAt" : "2018-10-13T20:11:53Z",
        "updatedAt" : "2018-10-16T04:26:05Z",
        "lastEditedBy" : "4c968502-bb3d-46ee-8719-0c0bdbc6242f",
        "tags" : [
        ]
      },
      {
        "id" : "800282c0-e374-45d8-80c7-c55d41c4fd44",
        "parentId" : "8eac71fd-c8a6-4b24-b8e9-42f871abde4c",
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "> Add the Grouped updates to the Scala API.\r\n\r\nAbsolutely.\r\n\r\n(Don't now enough about Scala to comment on the rest. Leave this part to @guozhangwang and @vvcephei.)",
        "createdAt" : "2018-10-13T21:01:20Z",
        "updatedAt" : "2018-10-16T04:26:05Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "af65f311-2733-47f4-a639-3e5c23254e5a",
        "parentId" : "8eac71fd-c8a6-4b24-b8e9-42f871abde4c",
        "authorId" : "4c968502-bb3d-46ee-8719-0c0bdbc6242f",
        "body" : "Update I've got something working that will work for everyone I believe, and I'll post a PR tomorrow",
        "createdAt" : "2018-10-14T02:02:52Z",
        "updatedAt" : "2018-10-16T04:26:05Z",
        "lastEditedBy" : "4c968502-bb3d-46ee-8719-0c0bdbc6242f",
        "tags" : [
        ]
      }
    ],
    "commit" : "34689d1b46eae10b205ca8666d0b530924b2ae6c",
    "line" : 43,
    "diffHunk" : "@@ -1,1 +379,383 @@   * @see `org.apache.kafka.streams.kstream.KStream#groupByKey`\n   */\n  def groupByKey(implicit grouped: Grouped[K, V]): KGroupedStream[K, V] =\n    inner.groupByKey(grouped)\n"
  },
  {
    "id" : "395e43da-8764-4204-805c-7f5c0215f4f8",
    "prId" : 8679,
    "prUrl" : "https://github.com/apache/kafka/pull/8679#pullrequestreview-414745406",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "67bff86a-98e4-41db-9fcf-0798f84fa667",
        "parentId" : null,
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "There is no `KTable#through()` method.",
        "createdAt" : "2020-05-17T03:08:50Z",
        "updatedAt" : "2020-05-21T21:48:53Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "98f20c42-c542-4ad8-bc43-a30f8193fc4f",
        "parentId" : "67bff86a-98e4-41db-9fcf-0798f84fa667",
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "Oops...",
        "createdAt" : "2020-05-19T19:32:38Z",
        "updatedAt" : "2020-05-21T21:48:54Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      }
    ],
    "commit" : "dfcb6a3dce9ea006c43ddc1d502eccb07f879c10",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +219,223 @@   *\n   * //..\n   * val clicksPerRegion: KStream[String, Long] = //..\n   *\n   * // Implicit serdes in scope will generate an implicit Produced instance, which"
  },
  {
    "id" : "fd8241bf-45af-49c7-8f8c-84f9a7b8148f",
    "prId" : 8679,
    "prUrl" : "https://github.com/apache/kafka/pull/8679#pullrequestreview-415391978",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8e11bfff-6069-45fd-8058-df105f41749c",
        "parentId" : null,
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "I just noticed that we have no test for this operator (or for through). Should we add one?",
        "createdAt" : "2020-05-19T21:57:25Z",
        "updatedAt" : "2020-05-21T21:48:54Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      },
      {
        "id" : "6398ac1c-2180-4a3b-b088-6365a1c48aa7",
        "parentId" : "8e11bfff-6069-45fd-8058-df105f41749c",
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "Not sure what we can/should test? ",
        "createdAt" : "2020-05-20T00:27:46Z",
        "updatedAt" : "2020-05-21T21:48:54Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "0ee0262a-77a7-4efd-bc26-1126d7197e95",
        "parentId" : "8e11bfff-6069-45fd-8058-df105f41749c",
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "We have previously had embarrassing bugs like, \"It's not possible to write code that compiles using the Scala DSL\". If we had had even the most trivial test written for those DSL methods, we would never have released those bugs. So, I'd just recommend creating _any_ topology that contains this operator and maybe using TTD to pipe a single record through it to ensure that it doesn't throw any runtime exceptions when you use it. ",
        "createdAt" : "2020-05-20T14:25:00Z",
        "updatedAt" : "2020-05-21T21:48:54Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      }
    ],
    "commit" : "dfcb6a3dce9ea006c43ddc1d502eccb07f879c10",
    "line" : 57,
    "diffHunk" : "@@ -1,1 +277,281 @@   * @see `org.apache.kafka.streams.kstream.KStream#repartition`\n   */\n  def repartition(implicit repartitioned: Repartitioned[K, V]): KStream[K, V] =\n    new KStream(inner.repartition(repartitioned))\n"
  }
]
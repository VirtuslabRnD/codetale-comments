[
  {
    "id" : "57fd30da-9145-4ed9-93b1-592939b53f9d",
    "prId" : 5019,
    "prUrl" : "https://github.com/apache/kafka/pull/5019#pullrequestreview-121111469",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3c9a0b1e-9149-4f22-b2f8-4c6a1628d823",
        "parentId" : null,
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "This is a meta comment: why we want to separate initializer with other parameters in all the places?",
        "createdAt" : "2018-05-17T15:48:09Z",
        "updatedAt" : "2018-05-18T17:20:41Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "04cf5991-3eb6-46fa-9f64-b9717c7c4eaf",
        "parentId" : "3c9a0b1e-9149-4f22-b2f8-4c6a1628d823",
        "authorId" : "7b2b0b66-666b-4e5c-beda-94b652bf1309",
        "body" : "@guozhangwang - As I mentioned in my comment https://github.com/apache/kafka/pull/5019#issuecomment-389225551, this has been done to aid the Scala compiler do better type inferencing. Scala compiler does type inferencing from left to right in groups. So if you place the `initializer` in a separate group, then u get better type inferencing when specifying the `initializer` in the usage. There are a few areas where we can do this for better type inference. I have some reservations on this as I mentioned in the comment I linked earlier. May be you or @ijuma can take a call on this.",
        "createdAt" : "2018-05-17T16:01:54Z",
        "updatedAt" : "2018-05-18T17:20:41Z",
        "lastEditedBy" : "7b2b0b66-666b-4e5c-beda-94b652bf1309",
        "tags" : [
        ]
      },
      {
        "id" : "30b9452b-6ca9-40d6-81d7-51210b08fb3d",
        "parentId" : "3c9a0b1e-9149-4f22-b2f8-4c6a1628d823",
        "authorId" : "785455e8-efbf-4a4b-bb81-b194d48f204f",
        "body" : "Look at the signature of `foldLeft` in Scala:\r\n```\r\ndef foldLeft[B](z: B)(op: (B, A) => B): B\r\n```\r\nThe zero (initializer) is curried away from the aggregator function.\r\n\r\nMany think this is a style choice but it's not. If we wanted to implement that in one group of parameter as:\r\n```\r\ndef foldLeft[B](z: B, op: (B, A) => B): B\r\n```\r\nThe type parameter `B` would not be \"fixed\" by the type inference before we get into the aggregator function.\r\nWith currying you actually apply the first group of parameter so that we know what `B` are we talking about and then we apply the function.\r\n\r\nHere exactly the same happens with `aggregate`, the type inference is not able to tell you from the initializer what the types of the function will be and therefore ask you to write all the types explicitly. Forcing such a thing in Scala APIs is not very common.",
        "createdAt" : "2018-05-17T16:06:11Z",
        "updatedAt" : "2018-05-18T17:20:41Z",
        "lastEditedBy" : "785455e8-efbf-4a4b-bb81-b194d48f204f",
        "tags" : [
        ]
      }
    ],
    "commit" : "0d55f3bf6aeeec244c9b2f96a032e00636020ff7",
    "line" : 30,
    "diffHunk" : "@@ -1,1 +114,118 @@   * @see `org.apache.kafka.streams.kstream.KGroupedStream#aggregate`\n   */ \n  def aggregate[VR](initializer: => VR)(aggregator: (K, V, VR) => VR,\n                                        materialized: Materialized[K, VR, ByteArrayKeyValueStore]): KTable[K, VR] =\n    inner.aggregate((() => initializer).asInitializer, aggregator.asAggregator, materialized)"
  }
]
[
  {
    "id" : "2486953b-e934-41e0-b6cc-4ecce1ceee51",
    "prId" : 661,
    "prUrl" : "https://github.com/zio/zio/pull/661#pullrequestreview-217634561",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2d676919-e9c7-407f-ae21-d069b77a4a61",
        "parentId" : null,
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "General note: we're not interruption safe. We need to make sure that when the fold starts running, it cancels the subscription and shuts down the queue if interrupted.\r\n\r\nProbably best to move all the subscription cancellations to one place; e.g. `loop(s, capacity).ensuring(UIO(s.cancel()))` and also make sure that if `onSubscribe` happens after the stream is interrupted, that gets handled properly too.",
        "createdAt" : "2019-03-22T08:49:53Z",
        "updatedAt" : "2019-03-23T07:22:43Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      }
    ],
    "commit" : "b2f01156d382b1cb1a40ca14c0824954b47bd78f",
    "line" : 57,
    "diffHunk" : "@@ -1,1 +25,29 @@  @volatile private[this] var failed: Option[Throwable] = None\n\n  override def fold[R1 <: Any, E1 >: Throwable, A1 >: A, S]: Fold[R1, E1, A1, S] =\n    subscriptionP.await.map { subscription => (s: S, cont: S => Boolean, f: (S, A1) => ZIO[R1, E1, S]) =>\n      def loop(s: S, demand: Long): ZIO[R1, E1, S] ="
  },
  {
    "id" : "36301231-c657-4fb2-a98f-232a47cea3c3",
    "prId" : 661,
    "prUrl" : "https://github.com/zio/zio/pull/661#pullrequestreview-217634561",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "44113849-296b-4306-a920-b7bd6493e0b4",
        "parentId" : null,
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "This should cancel the subscription too. See the note about interruption.",
        "createdAt" : "2019-03-22T08:58:00Z",
        "updatedAt" : "2019-03-23T07:22:43Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      }
    ],
    "commit" : "b2f01156d382b1cb1a40ca14c0824954b47bd78f",
    "line" : 68,
    "diffHunk" : "@@ -1,1 +36,40 @@            else if (empty && (demand < q.capacity)) UIO(subscription.request(capacity - demand)) *> loop(s, capacity)\n            else q.take.flatMap(f(s, _)).flatMap(loop(_, demand - 1))\n          } <> failed.fold[Task[S]](UIO.succeed(s))(Task.fail)\n      loop(s, 0).ensuring(q.shutdown)\n    }.onInterrupt(q.shutdown)"
  }
]
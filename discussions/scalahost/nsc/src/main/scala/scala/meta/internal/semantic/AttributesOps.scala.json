[
  {
    "id" : "ed8df7b5-e2fc-41b6-b72b-b79db8dd1ac2",
    "prId" : 988,
    "prUrl" : "https://github.com/scalameta/scalameta/pull/988#pullrequestreview-48263504",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0f52d25b-aec1-4177-8e1e-32295ceba704",
        "parentId" : null,
        "authorId" : "56d6821a-439f-4d87-aba8-a6368926dbc5",
        "body" : "What's the difference between `toString` and `showCode` here? I'm very wary of `showCode`, because it's known to sometimes swallow snippets of code that it considers irrelevant.",
        "createdAt" : "2017-07-06T01:39:44Z",
        "updatedAt" : "2017-07-06T09:54:43Z",
        "lastEditedBy" : "56d6821a-439f-4d87-aba8-a6368926dbc5",
        "tags" : [
        ]
      },
      {
        "id" : "3a2b38f9-554f-47af-92b9-4a95a5bfb616",
        "parentId" : "0f52d25b-aec1-4177-8e1e-32295ceba704",
        "authorId" : "bd90d0d4-3cfe-485f-b03d-29764e6b2eae",
        "body" : "Here's an example failing test from rebase on master\r\n\r\n```\r\n[info]   -[273..275) h.X.cvt[Int](*)(h.C.int)\r\n[info]   +[273..275) h.this.X.cvt[Int](*)(h.this.C.int)\r\n```\r\nThe second one (.toString) would not compile if inserted into a source file while the first one (showCode) would compile.\r\n",
        "createdAt" : "2017-07-06T08:17:50Z",
        "updatedAt" : "2017-07-06T09:54:43Z",
        "lastEditedBy" : "bd90d0d4-3cfe-485f-b03d-29764e6b2eae",
        "tags" : [
        ]
      }
    ],
    "commit" : "488ac646810a094fdfc3a6ffa580539a7c79780a",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +308,312 @@                case gview: g.ApplyImplicitView =>\n                  val pos = gtree.pos.toMeta\n                  val syntax = g.showCode(gview.fun) + \"(*)\"\n                  success(pos, syntax)\n                  inferredImplicitConv += gview.fun"
  },
  {
    "id" : "79e4bd3d-f80f-4e3e-9ef1-5a9c258c6c0d",
    "prId" : 988,
    "prUrl" : "https://github.com/scalameta/scalameta/pull/988#pullrequestreview-48788420",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1d8a9f9f-fa4c-4d0b-8297-1d1511cb7661",
        "parentId" : null,
        "authorId" : "56d6821a-439f-4d87-aba8-a6368926dbc5",
        "body" : "Why do we need `decoded` here?",
        "createdAt" : "2017-07-07T03:25:11Z",
        "updatedAt" : "2017-07-07T03:42:02Z",
        "lastEditedBy" : "56d6821a-439f-4d87-aba8-a6368926dbc5",
        "tags" : [
        ]
      },
      {
        "id" : "2284567d-b8f9-4a7b-a6bf-2bca114f4676",
        "parentId" : "1d8a9f9f-fa4c-4d0b-8297-1d1511cb7661",
        "authorId" : "bd90d0d4-3cfe-485f-b03d-29764e6b2eae",
        "body" : "I thought that was the way to get the name of a symbol, is there a better method?",
        "createdAt" : "2017-07-07T07:36:05Z",
        "updatedAt" : "2017-07-07T07:36:05Z",
        "lastEditedBy" : "bd90d0d4-3cfe-485f-b03d-29764e6b2eae",
        "tags" : [
        ]
      },
      {
        "id" : "2beabd82-edb1-431b-bcac-0f9854be16c6",
        "parentId" : "1d8a9f9f-fa4c-4d0b-8297-1d1511cb7661",
        "authorId" : "56d6821a-439f-4d87-aba8-a6368926dbc5",
        "body" : "I mixed this up with the macro API, where you have to do `decodedName.toString`.",
        "createdAt" : "2017-07-09T22:12:53Z",
        "updatedAt" : "2017-07-09T22:12:53Z",
        "lastEditedBy" : "56d6821a-439f-4d87-aba8-a6368926dbc5",
        "tags" : [
        ]
      }
    ],
    "commit" : "488ac646810a094fdfc3a6ffa580539a7c79780a",
    "line" : 32,
    "diffHunk" : "@@ -1,1 +331,335 @@                case g.Apply(select @ g.Select(qual, nme), _) if isSyntheticName(select) =>\n                  val pos = qual.pos.withStart(qual.pos.end).toMeta\n                  success(pos, s\".${nme.decoded}\")\n                case _ =>\n                // do nothing"
  }
]
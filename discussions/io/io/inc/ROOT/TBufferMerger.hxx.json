[
  {
    "id" : "320e7907-9135-477d-a914-efa2d6626ab0",
    "prId" : 533,
    "prUrl" : "https://github.com/root-project/root/pull/533#pullrequestreview-37147341",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9daafbbf-3cc2-4899-b6e8-488e0ff7b8f5",
        "parentId" : null,
        "authorId" : "335eabbd-4b70-43fb-a046-bf82995f5dd3",
        "body" : "This probably can probably be replaced by a TBits (more compact).",
        "createdAt" : "2017-05-09T20:05:34Z",
        "updatedAt" : "2017-05-10T06:49:41Z",
        "lastEditedBy" : "335eabbd-4b70-43fb-a046-bf82995f5dd3",
        "tags" : [
        ]
      },
      {
        "id" : "139828ec-ec28-49d8-9f35-c2f92c508c5c",
        "parentId" : "9daafbbf-3cc2-4899-b6e8-488e0ff7b8f5",
        "authorId" : "a66b5f61-1206-4ddd-b280-befb0005276f",
        "body" : "I didn't want to touch the imported code, because I wasn't sure what exactly was stored in it, but an array of characters seems wierd as replacement for a vector of bools, if that's what it really is for here. I would prefer using std::bitset if that's ok in that case. What do you think?",
        "createdAt" : "2017-05-09T20:13:36Z",
        "updatedAt" : "2017-05-10T06:49:41Z",
        "lastEditedBy" : "a66b5f61-1206-4ddd-b280-befb0005276f",
        "tags" : [
        ]
      },
      {
        "id" : "f9751faa-266c-4232-a465-0d9ad1f410f5",
        "parentId" : "9daafbbf-3cc2-4899-b6e8-488e0ff7b8f5",
        "authorId" : "335eabbd-4b70-43fb-a046-bf82995f5dd3",
        "body" : "This does not need to be addressed before merging.\r\n\r\nThe main difference between std::bitset and TBits is that bitset has a fixed size at compile time while TBits is expandable (and some operation in TBits are (or at least used to be) faster).  Here you can not predict the maximum number of TStreamerInfo involved in storing data in this file.\r\n\r\nThe reason it is a TArrayC is that at the time the original version of this code was written (circa 2000), TBits did not exist yet ... i.e. this code is copy/paste per se from TFile::WriteStreamerInfo.\r\n\r\nThe purpose is solely to keep track of whether a StreamerInfo, refer to by its index has been sent over ...\r\n\r\n... right but that does not make any sense when the client and the  server are in the same process ....\r\n\r\nSo actually WriteStreamerInfo and any use of fClassSent can go away ....\r\n",
        "createdAt" : "2017-05-09T20:25:41Z",
        "updatedAt" : "2017-05-10T06:49:41Z",
        "lastEditedBy" : "335eabbd-4b70-43fb-a046-bf82995f5dd3",
        "tags" : [
        ]
      },
      {
        "id" : "a16b19e1-7566-4a51-9a7f-0aee0822a967",
        "parentId" : "9daafbbf-3cc2-4899-b6e8-488e0ff7b8f5",
        "authorId" : "a66b5f61-1206-4ddd-b280-befb0005276f",
        "body" : "Well, I'm not acquainted yet with the internals of the I/O system, so I cannot make such judgments. If it is indeed unnecessary, then we should remove it.",
        "createdAt" : "2017-05-09T20:34:32Z",
        "updatedAt" : "2017-05-10T06:49:41Z",
        "lastEditedBy" : "a66b5f61-1206-4ddd-b280-befb0005276f",
        "tags" : [
        ]
      }
    ],
    "commit" : "ed8dc20b25f5a18d6c8441abe7d91179858ebbfb",
    "line" : 101,
    "diffHunk" : "@@ -1,1 +99,103 @@private:\n   TBufferMerger &fMerger;              //< TBufferMerger this file is attached to\n   std::unique_ptr<TArrayC> fClassSent; //< StreamerInfo this file has already written\n\n   /** Constructor. Can only be called by TBufferMerger."
  },
  {
    "id" : "71541419-6a67-476b-a328-1461a32bfa22",
    "prId" : 577,
    "prUrl" : "https://github.com/root-project/root/pull/577#pullrequestreview-38440374",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "75a8ac0a-095f-4a08-9f87-f5a4985619c5",
        "parentId" : null,
        "authorId" : "6f6f52c8-bace-4788-98aa-f12fb2560025",
        "body" : "Is there a particular reason to mark the members only `const`?",
        "createdAt" : "2017-05-16T16:06:55Z",
        "updatedAt" : "2017-05-16T16:09:38Z",
        "lastEditedBy" : "6f6f52c8-bace-4788-98aa-f12fb2560025",
        "tags" : [
        ]
      },
      {
        "id" : "76881b29-e5c4-4463-aaa6-e600b8aabe56",
        "parentId" : "75a8ac0a-095f-4a08-9f87-f5a4985619c5",
        "authorId" : "a66b5f61-1206-4ddd-b280-befb0005276f",
        "body" : "As opposed to what?",
        "createdAt" : "2017-05-16T16:10:29Z",
        "updatedAt" : "2017-05-16T16:10:29Z",
        "lastEditedBy" : "a66b5f61-1206-4ddd-b280-befb0005276f",
        "tags" : [
        ]
      },
      {
        "id" : "e625b9e2-2737-4735-9d5a-ff347826bc3b",
        "parentId" : "75a8ac0a-095f-4a08-9f87-f5a4985619c5",
        "authorId" : "6f6f52c8-bace-4788-98aa-f12fb2560025",
        "body" : "As opposed to not being `const`. What's the meaning of const int/string? The compiler can deduce this based on the fact that those are allocated on the stack so if it is there for optimization I think it is redundant. If you are telling the reader that you only touch this in the constructors, could be good to know. I don't think this is a common practice in ROOT, however.",
        "createdAt" : "2017-05-16T16:14:04Z",
        "updatedAt" : "2017-05-16T16:14:04Z",
        "lastEditedBy" : "6f6f52c8-bace-4788-98aa-f12fb2560025",
        "tags" : [
        ]
      },
      {
        "id" : "8364c9fb-234f-46f4-998e-3258b10f798e",
        "parentId" : "75a8ac0a-095f-4a08-9f87-f5a4985619c5",
        "authorId" : "335eabbd-4b70-43fb-a046-bf82995f5dd3",
        "body" : "> Is there a particular reason to mark the members only const?\r\n\r\nIt insures that the invariant of the class (not-allowed to change output file after the class) are guaranteed.  It also allows/indicates-that-you-are-allowed to use those from multiple thread without risk of race condition.",
        "createdAt" : "2017-05-16T16:14:11Z",
        "updatedAt" : "2017-05-16T16:16:55Z",
        "lastEditedBy" : "335eabbd-4b70-43fb-a046-bf82995f5dd3",
        "tags" : [
        ]
      },
      {
        "id" : "ff5c2454-2af6-4413-a5e9-23483558ded5",
        "parentId" : "75a8ac0a-095f-4a08-9f87-f5a4985619c5",
        "authorId" : "a66b5f61-1206-4ddd-b280-befb0005276f",
        "body" : "Yes, what @pcanal said, and it makes it easy to catch bugs if these members are ever modified by mistake.",
        "createdAt" : "2017-05-16T16:16:43Z",
        "updatedAt" : "2017-05-16T16:16:43Z",
        "lastEditedBy" : "a66b5f61-1206-4ddd-b280-befb0005276f",
        "tags" : [
        ]
      },
      {
        "id" : "de765b2b-200c-4df7-b636-15ba4abaa022",
        "parentId" : "75a8ac0a-095f-4a08-9f87-f5a4985619c5",
        "authorId" : "6f6f52c8-bace-4788-98aa-f12fb2560025",
        "body" : "Ok, make sense. I see their semantics is readonly.",
        "createdAt" : "2017-05-16T16:23:41Z",
        "updatedAt" : "2017-05-16T16:23:41Z",
        "lastEditedBy" : "6f6f52c8-bace-4788-98aa-f12fb2560025",
        "tags" : [
        ]
      }
    ],
    "commit" : "bf9be1f866a1d1c9bf6eed206f7a7c82b1cea5d2",
    "line" : 35,
    "diffHunk" : "@@ -1,1 +84,88 @@   const std::string fName;\n   const std::string fOption;\n   const Int_t fCompress;\n   std::mutex fQueueMutex;                                       //< Mutex used to lock fQueue\n   std::mutex fWriteMutex;                                       //< Mutex used for the condition variable"
  },
  {
    "id" : "60ebdc1f-1e69-4b59-8df3-a8da56292be1",
    "prId" : 1073,
    "prUrl" : "https://github.com/root-project/root/pull/1073#pullrequestreview-67356281",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0bd7dfa3-a08b-4f7d-a0c9-f76cce2c1af0",
        "parentId" : null,
        "authorId" : "a66b5f61-1206-4ddd-b280-befb0005276f",
        "body" : "Why change this? This only matters for classes that are streamed. This should have remained as 0.",
        "createdAt" : "2017-10-05T08:41:30Z",
        "updatedAt" : "2017-10-05T08:41:30Z",
        "lastEditedBy" : "a66b5f61-1206-4ddd-b280-befb0005276f",
        "tags" : [
        ]
      },
      {
        "id" : "b1f3359b-e238-4700-b59e-904981cf8b88",
        "parentId" : "0bd7dfa3-a08b-4f7d-a0c9-f76cce2c1af0",
        "authorId" : "6f6f52c8-bace-4788-98aa-f12fb2560025",
        "body" : "IIRC, when you have a ClassDef and you change data members you also should bump the ClassDef version.",
        "createdAt" : "2017-10-05T08:43:24Z",
        "updatedAt" : "2017-10-05T08:43:24Z",
        "lastEditedBy" : "6f6f52c8-bace-4788-98aa-f12fb2560025",
        "tags" : [
        ]
      },
      {
        "id" : "e8a2ad27-42b4-4830-bc55-a01dd8e1bca8",
        "parentId" : "0bd7dfa3-a08b-4f7d-a0c9-f76cce2c1af0",
        "authorId" : "335eabbd-4b70-43fb-a046-bf82995f5dd3",
        "body" : "> IIRC, when you have a ClassDef and you change data members you also should bump the ClassDef version.\r\n\r\nonly when you change a persistent member :) ... and version == 0 means that all data members are implicitly marked transient.",
        "createdAt" : "2017-10-05T11:24:37Z",
        "updatedAt" : "2017-10-05T11:24:38Z",
        "lastEditedBy" : "335eabbd-4b70-43fb-a046-bf82995f5dd3",
        "tags" : [
        ]
      },
      {
        "id" : "7436df96-8b8b-4860-980b-513f2300da6c",
        "parentId" : "0bd7dfa3-a08b-4f7d-a0c9-f76cce2c1af0",
        "authorId" : "6f6f52c8-bace-4788-98aa-f12fb2560025",
        "body" : "Shall I revert it back to 0?",
        "createdAt" : "2017-10-05T12:24:17Z",
        "updatedAt" : "2017-10-05T12:24:17Z",
        "lastEditedBy" : "6f6f52c8-bace-4788-98aa-f12fb2560025",
        "tags" : [
        ]
      },
      {
        "id" : "2fd3df47-e3dd-42dd-a583-53c5734aba66",
        "parentId" : "0bd7dfa3-a08b-4f7d-a0c9-f76cce2c1af0",
        "authorId" : "335eabbd-4b70-43fb-a046-bf82995f5dd3",
        "body" : "yes.",
        "createdAt" : "2017-10-05T12:25:16Z",
        "updatedAt" : "2017-10-05T12:25:16Z",
        "lastEditedBy" : "335eabbd-4b70-43fb-a046-bf82995f5dd3",
        "tags" : [
        ]
      },
      {
        "id" : "ef8fa64d-da88-4be1-a71c-353c3bc4ce5f",
        "parentId" : "0bd7dfa3-a08b-4f7d-a0c9-f76cce2c1af0",
        "authorId" : "6f6f52c8-bace-4788-98aa-f12fb2560025",
        "body" : "Ok, done. I don't understand how is that a non persistent data member but you are the expert.",
        "createdAt" : "2017-10-05T12:29:10Z",
        "updatedAt" : "2017-10-05T12:29:10Z",
        "lastEditedBy" : "6f6f52c8-bace-4788-98aa-f12fb2560025",
        "tags" : [
        ]
      }
    ],
    "commit" : "e8a02a791930468b123b658d389b427d69140d10",
    "line" : 41,
    "diffHunk" : "@@ -1,1 +121,125 @@   std::function<void(void)> fCallback;                          //< Callback for when data is removed from queue\n\n   ClassDef(TBufferMerger, 1);\n};\n"
  },
  {
    "id" : "282b97d5-6b9d-412a-b44a-7d62d53b2315",
    "prId" : 7286,
    "prUrl" : "https://github.com/root-project/root/pull/7286#pullrequestreview-599744104",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5dbb11e9-3629-438f-9abc-7fc2319978ab",
        "parentId" : null,
        "authorId" : "09b7e073-cbeb-42e8-aa22-8b1468de56ae",
        "body" : "In old ROOT style this should be `SetNoTrees`",
        "createdAt" : "2021-02-26T14:06:33Z",
        "updatedAt" : "2021-03-02T22:50:27Z",
        "lastEditedBy" : "09b7e073-cbeb-42e8-aa22-8b1468de56ae",
        "tags" : [
        ]
      },
      {
        "id" : "9b4836e9-1850-4788-bb18-6420d46245d6",
        "parentId" : "5dbb11e9-3629-438f-9abc-7fc2319978ab",
        "authorId" : "335eabbd-4b70-43fb-a046-bf82995f5dd3",
        "body" : "Actually this is a copy/paste of the function name it forward to.  I.e. we made a typo in 2007 in TFileMerger and for backward compatibility I choose to keep it that way in TFileMerger and since this is (essentially) a forwarding function, to use the same spelling here.",
        "createdAt" : "2021-02-26T16:34:35Z",
        "updatedAt" : "2021-03-02T22:50:28Z",
        "lastEditedBy" : "335eabbd-4b70-43fb-a046-bf82995f5dd3",
        "tags" : [
        ]
      }
    ],
    "commit" : "42f6af2ad3d5063d76a91b41221663a6f815ac92",
    "line" : 19,
    "diffHunk" : "@@ -1,1 +102,106 @@   /** Indicates that any TTree objects in the file should be skipped\n    * and thus that steps that are specific to TTree can be skipped */\n   void SetNotrees(Bool_t notrees=kFALSE)\n   {\n      fMerger.SetNotrees(notrees);"
  },
  {
    "id" : "374d5abd-711a-4821-9da4-245072e1a28f",
    "prId" : 7286,
    "prUrl" : "https://github.com/root-project/root/pull/7286#pullrequestreview-603031451",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "83e4c2ef-dbd8-40c0-b27c-5925a117e111",
        "parentId" : null,
        "authorId" : "a66b5f61-1206-4ddd-b280-befb0005276f",
        "body" : "Why does this need to be atomic? The `fBuffered` member should only be modified while the queue lock is acquired.",
        "createdAt" : "2021-03-01T12:37:42Z",
        "updatedAt" : "2021-03-02T22:50:28Z",
        "lastEditedBy" : "a66b5f61-1206-4ddd-b280-befb0005276f",
        "tags" : [
        ]
      },
      {
        "id" : "fc325209-4d15-4a5e-98a9-838e621f5720",
        "parentId" : "83e4c2ef-dbd8-40c0-b27c-5925a117e111",
        "authorId" : "335eabbd-4b70-43fb-a046-bf82995f5dd3",
        "body" : "Yes, but it needs to be read by the user (of course out of the loop) to get an indication that the queue is \"full\".  Checking this value is currently the way for user to avoid the queue from becoming so large that the process run of out memory ... i.e. the user needs to stop producing data :) and wait or doing something else.",
        "createdAt" : "2021-03-01T16:45:20Z",
        "updatedAt" : "2021-03-02T22:50:28Z",
        "lastEditedBy" : "335eabbd-4b70-43fb-a046-bf82995f5dd3",
        "tags" : [
        ]
      },
      {
        "id" : "1f58ad8f-a656-4163-a24e-219fe12d3854",
        "parentId" : "83e4c2ef-dbd8-40c0-b27c-5925a117e111",
        "authorId" : "a66b5f61-1206-4ddd-b280-befb0005276f",
        "body" : "What I don't understand is why making this atomic changes things for the user, as it's probably still possible to read the value right before modification in any case. Maybe enforcing a maximum limit on buffering internally in `TBufferMerger` rather than exposing this to the user is a better option.",
        "createdAt" : "2021-03-02T09:17:36Z",
        "updatedAt" : "2021-03-02T22:50:28Z",
        "lastEditedBy" : "a66b5f61-1206-4ddd-b280-befb0005276f",
        "tags" : [
        ]
      },
      {
        "id" : "43ffe214-42e2-4e3e-829c-b28bc4945456",
        "parentId" : "83e4c2ef-dbd8-40c0-b27c-5925a117e111",
        "authorId" : "335eabbd-4b70-43fb-a046-bf82995f5dd3",
        "body" : "The atomic allow the value to be consistent instead of a partial written value.  Whether the value is + or - 1 is likely not essential.\r\n\r\n>  Maybe enforcing a maximum limit on buffering internally in TBufferMerger rather than exposing this to the user is a better option.\r\n\r\nThe problem is what to do once TBufferMerger noticed the exceptional condition.  Rather than \"just\" blocking, it needs to return/callback to the user so that they can use the resource (the thread that is about to post a TMemFile but can't because the queue is full).  If I understood correctly (eg. from Daniel Riley), this mechanism (checking the queue length) is the mechanism you had negotiated with CMS for CMSSW to use. \r\n\r\n\r\n",
        "createdAt" : "2021-03-02T21:42:29Z",
        "updatedAt" : "2021-03-02T22:50:28Z",
        "lastEditedBy" : "335eabbd-4b70-43fb-a046-bf82995f5dd3",
        "tags" : [
        ]
      },
      {
        "id" : "f19ffe49-c51a-4ca1-85a4-cc5ac44dae47",
        "parentId" : "83e4c2ef-dbd8-40c0-b27c-5925a117e111",
        "authorId" : "a66b5f61-1206-4ddd-b280-befb0005276f",
        "body" : "Yes, indeed, this is the mechanism that was agreed on with CMS. However, let me try to put this another way. In one of your commits, you moved from locking the queue mutex (which I believe is what you probably should keep) to using this atomic. This is more or less equivalent to just removing the lock, as the atomic by itself won't prevent other threads to start pushing more data onto the queue as you read `fBuffered`, so you will read a smaller value than what you should. If you hold the lock, then if some data is already being pushed, you get the buffered size after it's already pushed, not before, and can make a better decision if you push more data or not. If you don't use the lock, several threads can read a small value and push a lot of data at once rather than each deciding on pushing or not based on the real latest value of how much is buffered. I guess this is the reason you added the lock to get the queue size, so either both `GetQueueSize()` and `GetBuffered()` should have the lock, or neither of them should. The way it is now does not make sense to me.",
        "createdAt" : "2021-03-03T08:46:42Z",
        "updatedAt" : "2021-03-03T08:46:43Z",
        "lastEditedBy" : "a66b5f61-1206-4ddd-b280-befb0005276f",
        "tags" : [
        ]
      },
      {
        "id" : "ad11f42a-47b3-4570-aea2-426a28eb1180",
        "parentId" : "83e4c2ef-dbd8-40c0-b27c-5925a117e111",
        "authorId" : "335eabbd-4b70-43fb-a046-bf82995f5dd3",
        "body" : "I need to review this and change it and add a comment on the reason of the choice .If I remember correctly it was for local efficiency reason and to avoid having to take the lock twice per push to the queue ... but without an in depth look at the usage.\r\n\r\nThe user code could be either \r\n(a)\r\n```\r\nif (bufferMerger.GetBuffered() < threshold_in_bytes) // or (bufferMerger.GetQueueSize() < threshold_in_items)\r\n{\r\n     // push to the queue\r\n} else {\r\n     // hold on to the TMemFile and do something else than producing data\r\n     // (alternatively,  continue using the TMemFile and grow it further\r\n}\r\n```\r\nor (b)\r\n```\r\n// push to the queue\r\nif (bufferMerger.GetBuffered() >= threshold_in_bytes) // or (bufferMerger.GetQueueSize() >= threshold_in_items)\r\n{\r\n     // do something else than producing data\r\n}\r\n```\r\nFor (b) whether we use the atomic or the lock, since a lot can happen between the push and the if, there would not be a behavior difference.  In all cases the queue can be NumberOfThreads*MemFileSize larger than the threshold as conceivably all N threads could push at the same time on queue that has already N-1 items.\r\n\r\nFor (a) several threads could reach the `if` statement at the same time and all could then receive the same answer (eg the queue as N-1 items) whether the getter is atomic or use a lock but would then proceed to push to the queue and thus result to the same over-usage ( N items over the threshold ).  [And here in addition the threads that find the queue full needs to hold on to the TMemFile themselves leading to an effective potential over-usage of 2*N items)\r\n\r\nWhat scenario am I missing?\r\n\r\n[Note that because the `push to the queue` is indirect, I don't see a way to combine the test and the push.]",
        "createdAt" : "2021-03-03T15:37:46Z",
        "updatedAt" : "2021-03-03T15:37:46Z",
        "lastEditedBy" : "335eabbd-4b70-43fb-a046-bf82995f5dd3",
        "tags" : [
        ]
      }
    ],
    "commit" : "42f6af2ad3d5063d76a91b41221663a6f815ac92",
    "line" : 71,
    "diffHunk" : "@@ -1,1 +160,164 @@   bool fCompressTemporaryKeys{false};                           //< Enable compression of the TKeys in the TMemFile (save memory at the expense of time, end result is unchanged)\n   size_t fAutoSave{0};                                          //< AutoSave only every fAutoSave bytes\n   std::atomic<size_t> fBuffered{0};                             //< Number of bytes currently buffered\n   TFileMerger fMerger{false, false};                            //< TFileMerger used to merge all buffers\n   std::mutex fMergeMutex;                                       //< Mutex used to lock fMerger"
  },
  {
    "id" : "a4201a4e-61b3-4594-9e27-9c17ba776807",
    "prId" : 8449,
    "prUrl" : "https://github.com/root-project/root/pull/8449#pullrequestreview-685362881",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f682b2fa-25af-4bbb-a034-1e4a5bcbba28",
        "parentId" : null,
        "authorId" : "a66b5f61-1206-4ddd-b280-befb0005276f",
        "body" : "Is this really enough to ensure all current code still compiles without problems? I'd ask CMS to test first.",
        "createdAt" : "2021-06-16T15:49:32Z",
        "updatedAt" : "2021-06-16T15:49:32Z",
        "lastEditedBy" : "a66b5f61-1206-4ddd-b280-befb0005276f",
        "tags" : [
        ]
      },
      {
        "id" : "f628e39a-102d-4e50-92e6-d7ec5b836f8b",
        "parentId" : "f682b2fa-25af-4bbb-a034-1e4a5bcbba28",
        "authorId" : "f2c15ca6-f995-45d3-a26d-40d002e52d07",
        "body" : "how do I ask CMS to test a PR? but also, why shouldn't this be enough (they'll have deprecation warnings, but ROOT::Experimental::TBufferMerger is there)?",
        "createdAt" : "2021-06-16T15:55:40Z",
        "updatedAt" : "2021-06-16T15:55:40Z",
        "lastEditedBy" : "f2c15ca6-f995-45d3-a26d-40d002e52d07",
        "tags" : [
        ]
      }
    ],
    "commit" : "dcafd76fb5a0b8709f6e0553f23b2ad15c23757a",
    "line" : 37,
    "diffHunk" : "@@ -1,1 +222,226 @@      ::ROOT::TBufferMergerFile;\n} // namespace Experimental\n\n} // namespace ROOT\n"
  }
]
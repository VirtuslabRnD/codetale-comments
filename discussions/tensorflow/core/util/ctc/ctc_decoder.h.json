[
  {
    "id" : "1c4eca64-23c4-4557-a112-eba7c7f250c9",
    "prId" : 31164,
    "prUrl" : "https://github.com/tensorflow/tensorflow/pull/31164#pullrequestreview-274858109",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bfa823c8-f2d7-4196-b0a2-711ead81c06b",
        "parentId" : null,
        "authorId" : "47966c70-ca9e-4f42-9f8b-165f9cd3ebaa",
        "body" : "why?",
        "createdAt" : "2019-08-08T15:19:14Z",
        "updatedAt" : "2019-08-14T12:36:42Z",
        "lastEditedBy" : "47966c70-ca9e-4f42-9f8b-165f9cd3ebaa",
        "tags" : [
        ]
      },
      {
        "id" : "1b68801a-1871-40ce-a79e-82fe61c3976c",
        "parentId" : "bfa823c8-f2d7-4196-b0a2-711ead81c06b",
        "authorId" : "ae95bce3-b78b-4815-b036-d8db9b536683",
        "body" : "same as in https://github.com/tensorflow/tensorflow/pull/31164#discussion_r312368512",
        "createdAt" : "2019-08-14T12:42:05Z",
        "updatedAt" : "2019-08-14T12:42:06Z",
        "lastEditedBy" : "ae95bce3-b78b-4815-b036-d8db9b536683",
        "tags" : [
        ]
      }
    ],
    "commit" : "51cd5877412f9d67f2ec180c8087ae8d7a059da1",
    "line" : 43,
    "diffHunk" : "@@ -1,1 +86,90 @@          \"output needs to be of size at least (1, batch_size).\");\n    }\n    if (scores->rows() < Decoder::batch_size_ || scores->cols() == 0) {\n      return errors::InvalidArgument(\n          \"scores needs to be of size at least (batch_size, 1).\");"
  },
  {
    "id" : "d56ec976-1b2d-4754-90f9-40ac747e49d7",
    "prId" : 31164,
    "prUrl" : "https://github.com/tensorflow/tensorflow/pull/31164#pullrequestreview-274858148",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bdca90fc-2807-402e-9a02-0bdfa61a758a",
        "parentId" : null,
        "authorId" : "47966c70-ca9e-4f42-9f8b-165f9cd3ebaa",
        "body" : "ditto; undo",
        "createdAt" : "2019-08-08T15:19:24Z",
        "updatedAt" : "2019-08-14T12:36:42Z",
        "lastEditedBy" : "47966c70-ca9e-4f42-9f8b-165f9cd3ebaa",
        "tags" : [
        ]
      },
      {
        "id" : "53599768-0c72-4172-a2d6-f26c3afeb5ae",
        "parentId" : "bdca90fc-2807-402e-9a02-0bdfa61a758a",
        "authorId" : "ae95bce3-b78b-4815-b036-d8db9b536683",
        "body" : "same as in https://github.com/tensorflow/tensorflow/pull/31164#discussion_r312368512",
        "createdAt" : "2019-08-14T12:42:09Z",
        "updatedAt" : "2019-08-14T12:42:10Z",
        "lastEditedBy" : "ae95bce3-b78b-4815-b036-d8db9b536683",
        "tags" : [
        ]
      }
    ],
    "commit" : "51cd5877412f9d67f2ec180c8087ae8d7a059da1",
    "line" : 49,
    "diffHunk" : "@@ -1,1 +91,95 @@    }\n    // For each batch entry, identify the transitions\n    for (int b = 0; b < Decoder::batch_size_; ++b) {\n      int seq_len_b = seq_len[b];\n      // Only writing to beam 0"
  },
  {
    "id" : "c21acd53-942f-4d79-bda3-b43c668e5b60",
    "prId" : 31164,
    "prUrl" : "https://github.com/tensorflow/tensorflow/pull/31164#pullrequestreview-274858184",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4275f3c4-49fd-4726-9aff-d176b2034f9e",
        "parentId" : null,
        "authorId" : "47966c70-ca9e-4f42-9f8b-165f9cd3ebaa",
        "body" : "ditto; undo",
        "createdAt" : "2019-08-08T15:19:35Z",
        "updatedAt" : "2019-08-14T12:36:42Z",
        "lastEditedBy" : "47966c70-ca9e-4f42-9f8b-165f9cd3ebaa",
        "tags" : [
        ]
      },
      {
        "id" : "e62e4c8f-72c4-4100-8358-1cef14f8b6ba",
        "parentId" : "4275f3c4-49fd-4726-9aff-d176b2034f9e",
        "authorId" : "ae95bce3-b78b-4815-b036-d8db9b536683",
        "body" : "same as in https://github.com/tensorflow/tensorflow/pull/31164#discussion_r312368512",
        "createdAt" : "2019-08-14T12:42:15Z",
        "updatedAt" : "2019-08-14T12:42:15Z",
        "lastEditedBy" : "ae95bce3-b78b-4815-b036-d8db9b536683",
        "tags" : [
        ]
      }
    ],
    "commit" : "51cd5877412f9d67f2ec180c8087ae8d7a059da1",
    "line" : 59,
    "diffHunk" : "@@ -1,1 +102,106 @@        int max_class_ix;\n        (*scores)(b, 0) += -row.maxCoeff(&max_class_ix);\n        if (max_class_ix != Decoder::blank_index_ &&\n            !(Decoder::merge_repeated_ && max_class_ix == prev_class_ix)) {\n          output_b.push_back(max_class_ix);"
  }
]
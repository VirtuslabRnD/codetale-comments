[
  {
    "id" : "04163d66-66b4-4838-8b52-faabb30e45be",
    "prId" : 38259,
    "prUrl" : "https://github.com/tensorflow/tensorflow/pull/38259#pullrequestreview-389597314",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8182addd-6411-42c2-b46b-eff9300daffc",
        "parentId" : null,
        "authorId" : "72acf7f0-6473-4b57-a71f-2a44410818c5",
        "body" : "Nit: Could you please put this line before `#define EIGEN_USE_THREADS`?",
        "createdAt" : "2020-04-08T01:38:16Z",
        "updatedAt" : "2020-04-22T01:47:56Z",
        "lastEditedBy" : "72acf7f0-6473-4b57-a71f-2a44410818c5",
        "tags" : [
        ]
      }
    ],
    "commit" : "f7d394a062a7880815cffb56b8041b3c9ef1a851",
    "line" : 29,
    "diffHunk" : "@@ -1,1 +27,31 @@#include \"mkldnn.hpp\"\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/platform/threadpool.h\"\n#define EIGEN_USE_THREADS\n#ifdef ENABLE_MKLDNN_THREADPOOL"
  },
  {
    "id" : "6602d46a-3f97-474c-b12c-73a47bb572fa",
    "prId" : 38259,
    "prUrl" : "https://github.com/tensorflow/tensorflow/pull/38259#pullrequestreview-392391578",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "12151333-f765-42b2-92b9-45a2d842b56b",
        "parentId" : null,
        "authorId" : "72acf7f0-6473-4b57-a71f-2a44410818c5",
        "body" : "I'm skeptical of how this will perform. In practice, other ops will be sharing the thread pool and it might not be optimal to try to pin chunks of work to threads. For example, if there are 4 threads in the intra-op thread pool, and thread 0 is already occupied with some long task, `MklDnnThreadPool` will try to use thread 0 anyway (even if we request 3 threads for the current MKL op -- it will try to use threads 0, 1, and 2). Could you please add a TODO for us to revisit later when this is ready for benchmarking?",
        "createdAt" : "2020-04-10T04:46:54Z",
        "updatedAt" : "2020-04-22T01:47:56Z",
        "lastEditedBy" : "72acf7f0-6473-4b57-a71f-2a44410818c5",
        "tags" : [
        ]
      },
      {
        "id" : "19f0f5ac-359b-4aab-a3b0-55de4fe54465",
        "parentId" : "12151333-f765-42b2-92b9-45a2d842b56b",
        "authorId" : "dc01c536-f8d1-421c-86af-6ae72825c430",
        "body" : "In one sense you are right that framework should not interfere with the dynamic load balancing the threadpool does. But in the case of mkl, we know the jobs are more or less balanced and compute heavy. Also atleast for BS=1 cache locality plays a role. On the other hand, even though I want to pin it, the current eigen threadpool still steals :-) and prevents imbalance.  \r\n\r\nAlso is there anything special about 4 threads :-). ",
        "createdAt" : "2020-04-10T23:51:26Z",
        "updatedAt" : "2020-04-22T01:47:56Z",
        "lastEditedBy" : "dc01c536-f8d1-421c-86af-6ae72825c430",
        "tags" : [
        ]
      },
      {
        "id" : "5c897ac3-3939-4fc6-b6e4-638597534539",
        "parentId" : "12151333-f765-42b2-92b9-45a2d842b56b",
        "authorId" : "72acf7f0-6473-4b57-a71f-2a44410818c5",
        "body" : "I was thinking more of MKL ops vs non-MKL ops running at the same time. Job stealing would have some overhead, but you're right, it should help nonetheless. Let's see.\r\n\r\nNothing in particular about 4 threads. I just felt like using a concrete example. :)",
        "createdAt" : "2020-04-13T19:51:33Z",
        "updatedAt" : "2020-04-22T01:47:56Z",
        "lastEditedBy" : "72acf7f0-6473-4b57-a71f-2a44410818c5",
        "tags" : [
        ]
      }
    ],
    "commit" : "f7d394a062a7880815cffb56b8041b3c9ef1a851",
    "line" : 89,
    "diffHunk" : "@@ -1,1 +87,91 @@    int njobs = std::min(n, nthr);\n    for (int i = 0; i < njobs; i++) {\n      eigen_interface_->ScheduleWithHint(\n          [i, n, njobs, fn]() {\n            int start, end;"
  }
]
[
  {
    "id" : "1ab7c599-ccab-4d74-9b24-136fe6469093",
    "prId" : 11878,
    "prUrl" : "https://github.com/tensorflow/tensorflow/pull/11878#pullrequestreview-54487469",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d8c0ad1b-4d4a-434f-9b53-c10b9233756a",
        "parentId" : null,
        "authorId" : "0ba8fb18-637a-4ab3-a7c8-cd971823fe45",
        "body" : "Can you add support for complex types, while we're at it?",
        "createdAt" : "2017-08-01T23:34:45Z",
        "updatedAt" : "2017-09-06T05:32:18Z",
        "lastEditedBy" : "0ba8fb18-637a-4ab3-a7c8-cd971823fe45",
        "tags" : [
        ]
      },
      {
        "id" : "b10f2148-6d4f-4df5-a392-50f7aeb202a1",
        "parentId" : "d8c0ad1b-4d4a-434f-9b53-c10b9233756a",
        "authorId" : "33efffa3-ad55-43e4-8843-27cdee08db32",
        "body" : "That's actually a bit tricky: The SVD of a complex matrix gives real singular values. The implementation of cuSolver also provides the singular values in a real vector. The tensorflow operation, however, requires the singular values to be complex values as well. So I would need to store the singular values in a temporal array and convert them to complex values for the output (I can use CastFunctor defined in cast_op.h for that).\r\nWhat is the reason that Tensorflow requires the singular values to be stored in a complex tensor?",
        "createdAt" : "2017-08-03T11:21:22Z",
        "updatedAt" : "2017-09-06T05:32:18Z",
        "lastEditedBy" : "33efffa3-ad55-43e4-8843-27cdee08db32",
        "tags" : [
        ]
      },
      {
        "id" : "885d60b1-55ac-4383-8bec-06c1807e8e29",
        "parentId" : "d8c0ad1b-4d4a-434f-9b53-c10b9233756a",
        "authorId" : "0ba8fb18-637a-4ab3-a7c8-cd971823fe45",
        "body" : "There is no good reason. It was done this way because it made the code slight simpler when using Eigen. But you'll notice that the Python wrapper immediately casts it back to real again:\r\n\r\nhttps://github.com/tensorflow/tensorflow/blob/master/tensorflow/python/ops/linalg_ops.py#L281\r\n\r\nWe should probably fix the kernels to return real singular values in both cases. But since it requires changing the signature of the kernel, we would have to introduce a new SvdOpV2 to avoid backwards compatibility problems. Then we could get rid of the wasteful casting in the Python wrapper. I'll leave it up to you whether you are up for it in this PR. We can also do that and add complex support in a follow up.",
        "createdAt" : "2017-08-04T22:04:05Z",
        "updatedAt" : "2017-09-06T05:32:18Z",
        "lastEditedBy" : "0ba8fb18-637a-4ab3-a7c8-cd971823fe45",
        "tags" : [
        ]
      }
    ],
    "commit" : "bfda71b1104c7d1d0210439c22cded14c87c7db7",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +189,193 @@#define TF_CALL_LAPACK_TYPES(m) \\\n  m(float, S) m(double, D) m(std::complex<float>, C) m(std::complex<double>, Z)\n#define TF_CALL_LAPACK_TYPES_NO_COMPLEX(m) m(float, S) m(double, D)\n\n// Macros to construct cusolverDn method names."
  }
]
[
  {
    "id" : "7e18e458-112d-44b6-9662-2c2e659b428d",
    "prId" : 32471,
    "prUrl" : "https://github.com/tensorflow/tensorflow/pull/32471#pullrequestreview-288966904",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "54fcdc27-2d58-4b9a-9b3d-db0872ba1ff7",
        "parentId" : null,
        "authorId" : "2a8db88d-c925-4270-871e-79c6b27c2fdb",
        "body" : "`cache_filename_ ` is used to store the input cache file name, so we can delete the cache files in the destructor after each test task finishes. \r\n\r\nAlthough `dataset_ctx_` stores the pointer to the input tensor of `filename`, the `filename` tensor is held by the input dataset params, which has been deallocated before the destructor runs. That means, the input tensors for the op can not be accessed in the destructor.",
        "createdAt" : "2019-09-17T00:31:21Z",
        "updatedAt" : "2019-09-17T18:32:17Z",
        "lastEditedBy" : "2a8db88d-c925-4270-871e-79c6b27c2fdb",
        "tags" : [
        ]
      }
    ],
    "commit" : "ffd433aab68f485ae1fc64e115eca38becf31a14",
    "line" : 139,
    "diffHunk" : "@@ -1,1 +103,107 @@\n protected:\n  tstring cache_filename_;\n};\n"
  },
  {
    "id" : "d767415b-99c2-47a5-8b24-4e09430f7e7e",
    "prId" : 30825,
    "prUrl" : "https://github.com/tensorflow/tensorflow/pull/30825#pullrequestreview-263953569",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "953539bb-7d9f-4d9c-8c4b-fefa4dadc32d",
        "parentId" : null,
        "authorId" : "565becc7-24cd-4159-ad62-3351ae56bcaf",
        "body" : "why do we need this destructor now but we didn't need it before?",
        "createdAt" : "2019-07-18T22:54:40Z",
        "updatedAt" : "2019-07-19T19:28:49Z",
        "lastEditedBy" : "565becc7-24cd-4159-ad62-3351ae56bcaf",
        "tags" : [
        ]
      },
      {
        "id" : "73a09334-1fe5-4de7-8bca-e471c41e7fbd",
        "parentId" : "953539bb-7d9f-4d9c-8c4b-fefa4dadc32d",
        "authorId" : "2a8db88d-c925-4270-871e-79c6b27c2fdb",
        "body" : "I did not realize the potential issue before. If we do not delete the cache files for each `TEST_P`, the next `TEST_P` will use the cache files generated by the previous `TEST_P` and then the iterator will be in the `Read` mode. For example, without deleting the cache files, `TEST_P(ParameterizedCacheDatasetOpTest, Roundtrip)` will always run in the `Read` mode as the cache files have already been generated by previous tests. ",
        "createdAt" : "2019-07-18T23:23:24Z",
        "updatedAt" : "2019-07-19T19:28:49Z",
        "lastEditedBy" : "2a8db88d-c925-4270-871e-79c6b27c2fdb",
        "tags" : [
        ]
      }
    ],
    "commit" : "2c7437a5be1c7a28c45a7691eebef3423425a85f",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +25,29 @@class CacheDatasetOpTest : public DatasetOpsTestBase {\n public:\n  ~CacheDatasetOpTest() {\n    if (!filename_.empty()) {\n      std::vector<string> cache_files;"
  }
]
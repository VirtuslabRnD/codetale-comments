[
  {
    "id" : "49f1ef71-89c9-4e2c-9341-8e130b8e5e1f",
    "prId" : 37101,
    "prUrl" : "https://github.com/tensorflow/tensorflow/pull/37101#pullrequestreview-366253558",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "20be41ec-ae04-4cd1-ae4d-03d93c50167e",
        "parentId" : null,
        "authorId" : "05c2b6c1-8a55-4dc9-ae76-02172416ea90",
        "body" : "@rmlarsen do you know of a better way to tell if an op is a source or sink?",
        "createdAt" : "2020-02-27T02:35:31Z",
        "updatedAt" : "2020-02-28T23:05:00Z",
        "lastEditedBy" : "05c2b6c1-8a55-4dc9-ae76-02172416ea90",
        "tags" : [
        ]
      },
      {
        "id" : "ea0ae568-23a9-4af2-bc10-9b10268f511f",
        "parentId" : "20be41ec-ae04-4cd1-ae4d-03d93c50167e",
        "authorId" : "05c2b6c1-8a55-4dc9-ae76-02172416ea90",
        "body" : "Talked to @rmlarsen offline. We don't think there's a great way of checking this. It might be possible to have some heuristics, e.g. an op that takes a DT_VARIANT as input and has no outputs, or vice versa. But I'm not sure if it's worth implementing this.\r\n\r\nHaving Python tests to catch this, in addition to the C++ tests, would be nice in case we change which op is used on the Python side. But this doesn't need to be done in this PR.",
        "createdAt" : "2020-02-27T20:48:58Z",
        "updatedAt" : "2020-02-28T23:05:00Z",
        "lastEditedBy" : "05c2b6c1-8a55-4dc9-ae76-02172416ea90",
        "tags" : [
        ]
      },
      {
        "id" : "6ee9a96c-61ff-45ec-a5ee-da2eecc100da",
        "parentId" : "20be41ec-ae04-4cd1-ae4d-03d93c50167e",
        "authorId" : "fe150b7b-80e3-40ce-88bd-077c51873903",
        "body" : "Added a TODO to the Python tests.",
        "createdAt" : "2020-02-28T09:17:02Z",
        "updatedAt" : "2020-02-28T23:05:00Z",
        "lastEditedBy" : "fe150b7b-80e3-40ce-88bd-077c51873903",
        "tags" : [
        ]
      }
    ],
    "commit" : "a4101ddc03ae5dc14a282861d866c9c5e9e690cb",
    "line" : 413,
    "diffHunk" : "@@ -1,1 +1364,1368 @@}\n\nbool AutoMixedPrecisionImpl::IsSourceOrSinkOp(const string& op) const {\n  const gtl::FlatSet<string> source_and_sink_ops = {\n      \"_Arg\","
  },
  {
    "id" : "dd387413-0707-4cf2-ba7a-781a4e261892",
    "prId" : 37101,
    "prUrl" : "https://github.com/tensorflow/tensorflow/pull/37101#pullrequestreview-366253729",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ee6ebc5d-f39a-4e42-b680-767b317dfc9e",
        "parentId" : null,
        "authorId" : "05c2b6c1-8a55-4dc9-ae76-02172416ea90",
        "body" : "This is fairly contrived, but I think if you have a TensorList of TensorList handles, the TensorList itself also acts as a sink and the grappler pass will break.\r\n\r\nNot worth addressing IMO, since I cannot think of a simple way of dealing with this case.",
        "createdAt" : "2020-02-27T02:40:28Z",
        "updatedAt" : "2020-02-28T23:05:00Z",
        "lastEditedBy" : "05c2b6c1-8a55-4dc9-ae76-02172416ea90",
        "tags" : [
        ]
      },
      {
        "id" : "3edac696-7981-487a-9870-db399a68bbed",
        "parentId" : "ee6ebc5d-f39a-4e42-b680-767b317dfc9e",
        "authorId" : "fe150b7b-80e3-40ce-88bd-077c51873903",
        "body" : "Added a TODO.",
        "createdAt" : "2020-02-28T09:17:20Z",
        "updatedAt" : "2020-02-28T23:05:00Z",
        "lastEditedBy" : "fe150b7b-80e3-40ce-88bd-077c51873903",
        "tags" : [
        ]
      }
    ],
    "commit" : "a4101ddc03ae5dc14a282861d866c9c5e9e690cb",
    "line" : 472,
    "diffHunk" : "@@ -1,1 +1423,1427 @@                         // Tensor List itself would need to be treated as a\n                         // sink.\n                       } else if (IsSourceOrSinkOp(node->op())) {\n                         // The cluster crosses an untraversable boundary.\n                         black_set->insert(root_fp32_idx);"
  },
  {
    "id" : "c9dbc6f4-1c38-4579-a011-3fa64f5eadbb",
    "prId" : 37101,
    "prUrl" : "https://github.com/tensorflow/tensorflow/pull/37101#pullrequestreview-366253846",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a5cc940c-a57f-470a-a052-875fe9cb41cf",
        "parentId" : null,
        "authorId" : "05c2b6c1-8a55-4dc9-ae76-02172416ea90",
        "body" : "We're in trouble if a TensorList op assumes the tensor list is fp32 and hardcodes a DT_FLOAT output\r\n\r\nI highly doubt a TensorList op will ever do that, but can you comment that we make this assumption? The condition `node_type->type_attr.fixed_type == DT_INVALID` confused me at first.\r\n\r\nYou should also comment this assumes that the type attribute represents the dtype of the tensor list.",
        "createdAt" : "2020-02-27T03:07:59Z",
        "updatedAt" : "2020-02-28T23:05:00Z",
        "lastEditedBy" : "05c2b6c1-8a55-4dc9-ae76-02172416ea90",
        "tags" : [
        ]
      },
      {
        "id" : "883ec937-6fa3-4e7f-86df-82eea2f767b4",
        "parentId" : "a5cc940c-a57f-470a-a052-875fe9cb41cf",
        "authorId" : "fe150b7b-80e3-40ce-88bd-077c51873903",
        "body" : "Added a comment and a TODO.",
        "createdAt" : "2020-02-28T09:17:31Z",
        "updatedAt" : "2020-02-28T23:05:00Z",
        "lastEditedBy" : "fe150b7b-80e3-40ce-88bd-077c51873903",
        "tags" : [
        ]
      }
    ],
    "commit" : "a4101ddc03ae5dc14a282861d866c9c5e9e690cb",
    "line" : 403,
    "diffHunk" : "@@ -1,1 +1355,1359 @@    // TODO(benbarsdell): A new Tensor List op could theoretically break these\n    // assumptions.\n    if (node_type && node_type->type_attr.fixed_type == DT_INVALID &&\n        node_type->type_attr.type_index == TypeAttrId::kSingleType &&\n        IsFloat32(*node_type)) {"
  },
  {
    "id" : "7b3e22a3-0fd6-4b83-b8e8-b469bb293e3a",
    "prId" : 31809,
    "prUrl" : "https://github.com/tensorflow/tensorflow/pull/31809#pullrequestreview-285903328",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "56628ec6-0b3c-4ea2-aaad-77e42e9c29eb",
        "parentId" : null,
        "authorId" : "05c2b6c1-8a55-4dc9-ae76-02172416ea90",
        "body" : "I think I asked before, but to clarify: These ephermal edges aren't to ensure all the ops for a tensor list have the same dtype, right? It only determines whether the tensor list and all its edges will be changed to fp16 or not?",
        "createdAt" : "2019-08-20T21:53:41Z",
        "updatedAt" : "2019-09-24T00:31:09Z",
        "lastEditedBy" : "05c2b6c1-8a55-4dc9-ae76-02172416ea90",
        "tags" : [
        ]
      },
      {
        "id" : "9173c4b5-3fe9-4523-8a3b-8274bd6b55a2",
        "parentId" : "56628ec6-0b3c-4ea2-aaad-77e42e9c29eb",
        "authorId" : "fe150b7b-80e3-40ce-88bd-077c51873903",
        "body" : "That's right. The forcing of ops to have the same dtype is handled independently of the ephemeral edges.",
        "createdAt" : "2019-09-10T04:47:55Z",
        "updatedAt" : "2019-09-24T00:31:09Z",
        "lastEditedBy" : "fe150b7b-80e3-40ce-88bd-077c51873903",
        "tags" : [
        ]
      }
    ],
    "commit" : "58af3ec6996f5a83eff9b6ccbfbda33272bfec78",
    "line" : 98,
    "diffHunk" : "@@ -1,1 +1270,1274 @@  }\n\n  // Create ephemeral edges between writers and readers of data structure ops.\n  std::vector<NodeTypeIdEdge> ephemeral_edges;\n  for (const auto& object_clients : object_clients_map) {"
  },
  {
    "id" : "73b49bed-3378-4b74-a857-d0568060e363",
    "prId" : 31809,
    "prUrl" : "https://github.com/tensorflow/tensorflow/pull/31809#pullrequestreview-286359524",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a8984231-2f64-4891-bb47-9d74d2ae9b71",
        "parentId" : null,
        "authorId" : "05c2b6c1-8a55-4dc9-ae76-02172416ea90",
        "body" : "If a new TensorList op is added without being added to this file, I think it will cause issues. In particular, if a read or write op is added, it's dtype will not change, causing a crash when the graph is run. If an op that creates a TensorList is added, it will cause this grappler pass to return an error.\r\n\r\nMaybe if an op starts with \"TensorList\" and is not in a hardcoded list of acceptable ops, then do not change any tensor list ops, similar to how TensorListPushBackBatch and TensorListConcatLists is treated. Also you'd probably want to issue a warning in that case. If someone tries to introduce a new TensorListPushBackV2 or similar, it would still fail the Python unit test which checks dtypes, so I'm not too worried about someone accidentally making less things in fp16 by adding a new op.\r\n\r\nIf you go with this approach, add a comment stating if something is added to the hardcoded list, it should be added to the AddDataStructureOpsToMap below if it has a \"dtype\" attribute, and to the clearlist.",
        "createdAt" : "2019-09-10T18:44:59Z",
        "updatedAt" : "2019-09-24T00:31:09Z",
        "lastEditedBy" : "05c2b6c1-8a55-4dc9-ae76-02172416ea90",
        "tags" : [
        ]
      }
    ],
    "commit" : "58af3ec6996f5a83eff9b6ccbfbda33272bfec78",
    "line" : 76,
    "diffHunk" : "@@ -1,1 +1248,1252 @@  if (can_change_tensor_list_ops) {\n    VLOG(2) << \"Identifying TensorList* nodes\";\n    TF_RETURN_IF_ERROR(AddDataStructureOpsToMap(\n        {\"EmptyTensorList\", \"TensorListSplit\", \"TensorListFromTensor\",\n         \"TensorListReserve\", \"TensorListScatter\", \"TensorListScatterV2\"},"
  },
  {
    "id" : "5fff626d-cd17-4834-9278-be33d5cc24c3",
    "prId" : 26342,
    "prUrl" : "https://github.com/tensorflow/tensorflow/pull/26342#pullrequestreview-214309145",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "12617d3a-4e1c-4dea-b4b1-27a1a9025313",
        "parentId" : null,
        "authorId" : "05c2b6c1-8a55-4dc9-ae76-02172416ea90",
        "body" : "Document `type_index`. E.g., \"If `attr_name` is a list(type) attribute, index into the list. Otherwise if `attr_name` is a type attribute, this is kSingleType\".",
        "createdAt" : "2019-03-14T19:23:48Z",
        "updatedAt" : "2019-04-09T01:59:39Z",
        "lastEditedBy" : "05c2b6c1-8a55-4dc9-ae76-02172416ea90",
        "tags" : [
        ]
      }
    ],
    "commit" : "cdb7db55568626e215700bb365065d53d1d7fff8",
    "line" : 98,
    "diffHunk" : "@@ -1,1 +96,100 @@  // If attr_name is a list(type), this is the index into the list. Otherwise\n  // this is kSingleType.\n  int type_index;\n  DataType fixed_type;\n};"
  },
  {
    "id" : "191d5d47-a65e-40ac-8a83-1d75e94b1c79",
    "prId" : 26342,
    "prUrl" : "https://github.com/tensorflow/tensorflow/pull/26342#pullrequestreview-218673823",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "914fd627-c78b-4364-8b1d-75c21e9e01c8",
        "parentId" : null,
        "authorId" : "05c2b6c1-8a55-4dc9-ae76-02172416ea90",
        "body" : "I think this line will fail if `node.op()` is a function. Add a TODO?",
        "createdAt" : "2019-03-14T20:38:24Z",
        "updatedAt" : "2019-04-09T01:59:39Z",
        "lastEditedBy" : "05c2b6c1-8a55-4dc9-ae76-02172416ea90",
        "tags" : [
        ]
      },
      {
        "id" : "64053c8c-a61a-4835-8c9a-85cdec3b9151",
        "parentId" : "914fd627-c78b-4364-8b1d-75c21e9e01c8",
        "authorId" : "fe150b7b-80e3-40ce-88bd-077c51873903",
        "body" : "I've added a TODO (and also fixed the call to LookUpOpDef() inside SupportsFloat16()).",
        "createdAt" : "2019-03-26T02:59:48Z",
        "updatedAt" : "2019-04-09T01:59:39Z",
        "lastEditedBy" : "fe150b7b-80e3-40ce-88bd-077c51873903",
        "tags" : [
        ]
      }
    ],
    "commit" : "cdb7db55568626e215700bb365065d53d1d7fff8",
    "line" : 279,
    "diffHunk" : "@@ -1,1 +277,281 @@    // need to be addressed when we add support for functions.\n    TF_RETURN_IF_ERROR(\n        OpRegistry::Global()->LookUpOpDef(node.op(), &op_def_ptr));\n    const OpDef& op_def = *op_def_ptr;\n    auto& type2io_entry = type2io_[&node];"
  },
  {
    "id" : "d7e6223c-5279-4860-969a-50ee2a7c35db",
    "prId" : 26342,
    "prUrl" : "https://github.com/tensorflow/tensorflow/pull/26342#pullrequestreview-215991916",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ee26c15b-0a15-4179-b679-016f514fdc43",
        "parentId" : null,
        "authorId" : "05c2b6c1-8a55-4dc9-ae76-02172416ea90",
        "body" : "if `skip_invalid_edges_` is True, we will invalidly access `it2->second`. I'm pretty sure this case cannot happen anyway, so maybe just throw the error even if `skip_invalid_edges_` is true",
        "createdAt" : "2019-03-15T00:29:48Z",
        "updatedAt" : "2019-04-09T01:59:39Z",
        "lastEditedBy" : "05c2b6c1-8a55-4dc9-ae76-02172416ea90",
        "tags" : [
        ]
      },
      {
        "id" : "e43562ec-b0f3-455e-b20b-7a5682e056ab",
        "parentId" : "ee26c15b-0a15-4179-b679-016f514fdc43",
        "authorId" : "fe150b7b-80e3-40ce-88bd-077c51873903",
        "body" : "Fixed.",
        "createdAt" : "2019-03-19T07:25:56Z",
        "updatedAt" : "2019-04-09T01:59:39Z",
        "lastEditedBy" : "fe150b7b-80e3-40ce-88bd-077c51873903",
        "tags" : [
        ]
      }
    ],
    "commit" : "cdb7db55568626e215700bb365065d53d1d7fff8",
    "line" : 576,
    "diffHunk" : "@@ -1,1 +574,578 @@            NodeTypeKey(input_node.name(), input_type_attr));\n        if (it2 == node_type_name_to_index_.end()) {\n          if (!skip_invalid_edges_) {\n            return errors::InvalidArgument(\"Did not find type attr \",\n                                           input_type_attr.DebugString(),"
  },
  {
    "id" : "c4e21c60-e5e3-4ceb-99d5-3285fb078b8c",
    "prId" : 26342,
    "prUrl" : "https://github.com/tensorflow/tensorflow/pull/26342#pullrequestreview-214309145",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "cd01468b-0b5e-4f1f-a85a-cb7a25eb4bd6",
        "parentId" : null,
        "authorId" : "05c2b6c1-8a55-4dc9-ae76-02172416ea90",
        "body" : "To clarify this comment, maybe add a comment like \r\n\r\n\"For example, if node A has output A:0 with TypeAttrId 'x', and node B has input B:0 with TypeAttrId 'y', and input B:0 connects to output A:0, there will be an edge from (A, x) to (B, y)\"",
        "createdAt" : "2019-03-15T00:37:18Z",
        "updatedAt" : "2019-04-09T01:59:39Z",
        "lastEditedBy" : "05c2b6c1-8a55-4dc9-ae76-02172416ea90",
        "tags" : [
        ]
      }
    ],
    "commit" : "cdb7db55568626e215700bb365065d53d1d7fff8",
    "line" : 387,
    "diffHunk" : "@@ -1,1 +385,389 @@// used instead of this modified version.\n// This is just like GraphTopologyView but with (NodeDef, TypeAttrId) pairs as\n// the vertices instead of just NodeDef.\n// For example, if node A has output A:0 with TypeAttrId 'T', and node B has\n// input B:0 with TypeAttrId 'U', and input B:0 connects to output A:0, there"
  },
  {
    "id" : "8fc8b6ca-091d-4053-91f6-4548bb5218bf",
    "prId" : 26342,
    "prUrl" : "https://github.com/tensorflow/tensorflow/pull/26342#pullrequestreview-219820792",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1b22a973-9d53-4894-ab8e-0f30e4d3ec58",
        "parentId" : null,
        "authorId" : "05c2b6c1-8a55-4dc9-ae76-02172416ea90",
        "body" : "I believe the node name could not be empty but still be placed on the GPU, e.g. if the device is '/replica:0'. Add a TODO or just call `get_canonical_device_name` unconditionally",
        "createdAt" : "2019-03-15T03:03:12Z",
        "updatedAt" : "2019-04-09T01:59:39Z",
        "lastEditedBy" : "05c2b6c1-8a55-4dc9-ae76-02172416ea90",
        "tags" : [
        ]
      },
      {
        "id" : "54b449ce-2457-4970-b6fe-ba589c184059",
        "parentId" : "1b22a973-9d53-4894-ab8e-0f30e4d3ec58",
        "authorId" : "fe150b7b-80e3-40ce-88bd-077c51873903",
        "body" : "I'm not sure I understand this one, could you clarify? The identical code is used in layout_optimizer.cc.",
        "createdAt" : "2019-03-19T07:26:56Z",
        "updatedAt" : "2019-04-09T01:59:39Z",
        "lastEditedBy" : "fe150b7b-80e3-40ce-88bd-077c51873903",
        "tags" : [
        ]
      },
      {
        "id" : "dcda5b7d-b67e-425d-a51d-8646e2420862",
        "parentId" : "1b22a973-9d53-4894-ab8e-0f30e4d3ec58",
        "authorId" : "05c2b6c1-8a55-4dc9-ae76-02172416ea90",
        "body" : "If layout_optimizer.cc does this as well, it is fine.\r\n\r\nThe point I was getting at was a user could do something like:\r\n\r\n```\r\nwith tf.device('/replica:0'):\r\n  x = <white-list op>\r\n```\r\n\r\nThe optimizer would not touch `x`, despite it being on the GPU, because the string \"GPU\" does not appear in the device, and the device is not empty.",
        "createdAt" : "2019-03-28T03:39:08Z",
        "updatedAt" : "2019-04-09T01:59:39Z",
        "lastEditedBy" : "05c2b6c1-8a55-4dc9-ae76-02172416ea90",
        "tags" : [
        ]
      }
    ],
    "commit" : "cdb7db55568626e215700bb365065d53d1d7fff8",
    "line" : 1051,
    "diffHunk" : "@@ -1,1 +1049,1053 @@bool AutoMixedPrecisionImpl::IsOnGPU(const NodeDef& node) const {\n  string device_name;\n  if (node.device().empty()) {\n    device_name = virtual_placer_.get_canonical_device_name(node);\n  } else {"
  },
  {
    "id" : "0ac8d5ad-7928-4593-8a4c-a3484654dff9",
    "prId" : 26342,
    "prUrl" : "https://github.com/tensorflow/tensorflow/pull/26342#pullrequestreview-218673884",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "72ff77cd-d48f-47d2-aa7e-d2d675d82193",
        "parentId" : null,
        "authorId" : "05c2b6c1-8a55-4dc9-ae76-02172416ea90",
        "body" : "Add a comment what this function does. As I mentioned before, my impression is the following:\r\n\r\nA node is put in the black set iff it is black or if there is a forward path from a black node to a black/gray node consisting solely of clear nodes (the node at the end of the path is also put in the black set)",
        "createdAt" : "2019-03-15T04:39:29Z",
        "updatedAt" : "2019-04-09T01:59:39Z",
        "lastEditedBy" : "05c2b6c1-8a55-4dc9-ae76-02172416ea90",
        "tags" : [
        ]
      },
      {
        "id" : "ee16a364-bdee-4565-941a-c599c493bc7b",
        "parentId" : "72ff77cd-d48f-47d2-aa7e-d2d675d82193",
        "authorId" : "fe150b7b-80e3-40ce-88bd-077c51873903",
        "body" : "I've added a comment with the new description. I also removed the unused white_set argument.",
        "createdAt" : "2019-03-26T03:00:07Z",
        "updatedAt" : "2019-04-09T01:59:39Z",
        "lastEditedBy" : "fe150b7b-80e3-40ce-88bd-077c51873903",
        "tags" : [
        ]
      }
    ],
    "commit" : "cdb7db55568626e215700bb365065d53d1d7fff8",
    "line" : 1341,
    "diffHunk" : "@@ -1,1 +1339,1343 @@// E.g., black -> gray -> clear -> gray -> clear -> white -> gray\n// becomes: black -> black -> black -> black -> clear -> white -> gray.\nvoid AutoMixedPrecisionImpl::PropagateBlackFwdThroughClearAndGray(\n    absl::flat_hash_set<int>* black_set) const {\n  if (force_all_fp16_) return;"
  },
  {
    "id" : "521efcc3-8746-453f-9916-f0b3dd6fbab2",
    "prId" : 26342,
    "prUrl" : "https://github.com/tensorflow/tensorflow/pull/26342#pullrequestreview-218673918",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9cee166c-4365-42ab-82f3-01ab534f2f12",
        "parentId" : null,
        "authorId" : "05c2b6c1-8a55-4dc9-ae76-02172416ea90",
        "body" : "This logic seems to prevent, e.g., a StackPushV2 from being black and a StackPopV2 from being white, right? I have two questions\r\n1. What if some other ops not listed here has the same issue. Would things break if, say, a QueueEnqueueV2 op is white and a QueueDequeueV2 is black?\r\n2. How can such ops ever be colored white or black? They do not have both inputs and outputs.",
        "createdAt" : "2019-03-15T05:32:25Z",
        "updatedAt" : "2019-04-09T01:59:39Z",
        "lastEditedBy" : "05c2b6c1-8a55-4dc9-ae76-02172416ea90",
        "tags" : [
        ]
      },
      {
        "id" : "dcb2cf62-cd13-42ab-b168-c984eb33b1a3",
        "parentId" : "9cee166c-4365-42ab-82f3-01ab534f2f12",
        "authorId" : "fe150b7b-80e3-40ce-88bd-077c51873903",
        "body" : "1. Yes the same logic would need to be applied to Queue*V2 ops if they were added to the clearlist. Currently they are unlisted and so are never painted white.\r\n\r\n2. These ops are on the clearlist, so they can be painted white without being between white nodes. In addition, ephemeral edges are added between writers and readers of the same data structure, so in this sense they do have both inputs and outputs.",
        "createdAt" : "2019-03-26T03:00:18Z",
        "updatedAt" : "2019-04-09T01:59:39Z",
        "lastEditedBy" : "fe150b7b-80e3-40ce-88bd-077c51873903",
        "tags" : [
        ]
      }
    ],
    "commit" : "cdb7db55568626e215700bb365065d53d1d7fff8",
    "line" : 1183,
    "diffHunk" : "@@ -1,1 +1181,1185 @@  VLOG(2) << \"Identifying Stack*V2 nodes\";\n  TF_RETURN_IF_ERROR(AddDataStructureOpsToMap(\n      \"StackV2\", TypeAttrId(\"elem_type\"), {{\"StackPushV2\", TypeAttrId(\"T\")}},\n      {{\"StackPopV2\", TypeAttrId(\"elem_type\")}}, &object_clients_map));\n  VLOG(2) << \"Identifying TensorArray*V3 nodes\";"
  },
  {
    "id" : "80fc0ef8-71a2-485c-ba9e-9245c8e3ff17",
    "prId" : 26342,
    "prUrl" : "https://github.com/tensorflow/tensorflow/pull/26342#pullrequestreview-218673938",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e5105ef9-9775-444a-9719-f62026551749",
        "parentId" : null,
        "authorId" : "05c2b6c1-8a55-4dc9-ae76-02172416ea90",
        "body" : "Instead of `IsFloat32(item)`, should we check if it's float32 or float16? Having a node that's already float16 instead of float32 should not prevent more nodes from being float16 IMO.\r\n\r\nFeel free to not implement this for now if it would take a lot of time.",
        "createdAt" : "2019-03-15T05:38:55Z",
        "updatedAt" : "2019-04-09T01:59:39Z",
        "lastEditedBy" : "05c2b6c1-8a55-4dc9-ae76-02172416ea90",
        "tags" : [
        ]
      },
      {
        "id" : "38737ed4-3264-4bd3-ad09-2a8de766f268",
        "parentId" : "e5105ef9-9775-444a-9719-f62026551749",
        "authorId" : "fe150b7b-80e3-40ce-88bd-077c51873903",
        "body" : "I've added a TODO.",
        "createdAt" : "2019-03-26T03:00:24Z",
        "updatedAt" : "2019-04-09T01:59:39Z",
        "lastEditedBy" : "fe150b7b-80e3-40ce-88bd-077c51873903",
        "tags" : [
        ]
      }
    ],
    "commit" : "cdb7db55568626e215700bb365065d53d1d7fff8",
    "line" : 1411,
    "diffHunk" : "@@ -1,1 +1409,1413 @@                  // ops that are already float16 in order to reduce the number\n                  // of casts.\n                  IsFloat32(item) && SupportsFloat16(item) &&\n                  (fp16_clearlist_.count(item.node->op()) ||\n                   fp16_graylist_.count(item.node->op())));"
  },
  {
    "id" : "af2dff6a-1bc5-48a3-b5c5-386b5fd8a4fc",
    "prId" : 26342,
    "prUrl" : "https://github.com/tensorflow/tensorflow/pull/26342#pullrequestreview-215992688",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "98790912-96b7-4ab1-92f5-65f3851f828d",
        "parentId" : null,
        "authorId" : "05c2b6c1-8a55-4dc9-ae76-02172416ea90",
        "body" : "Do we have the IsIdentityAfterVariable check so we don't mark such an identity white and cause a black node to use it? Whatever the reason, please comment it.",
        "createdAt" : "2019-03-15T20:17:03Z",
        "updatedAt" : "2019-04-09T01:59:39Z",
        "lastEditedBy" : "05c2b6c1-8a55-4dc9-ae76-02172416ea90",
        "tags" : [
        ]
      },
      {
        "id" : "7a1b24cc-9d2f-4fc9-b402-ddfdca0418ae",
        "parentId" : "98790912-96b7-4ab1-92f5-65f3851f828d",
        "authorId" : "fe150b7b-80e3-40ce-88bd-077c51873903",
        "body" : "Done.",
        "createdAt" : "2019-03-19T07:28:41Z",
        "updatedAt" : "2019-04-09T01:59:39Z",
        "lastEditedBy" : "fe150b7b-80e3-40ce-88bd-077c51873903",
        "tags" : [
        ]
      }
    ],
    "commit" : "cdb7db55568626e215700bb365065d53d1d7fff8",
    "line" : 1470,
    "diffHunk" : "@@ -1,1 +1468,1472 @@                  // they immediately follow Variable nodes because otherwise it\n                  // breaks TensorBoard visualization.\n                  !IsIdentityAfterVariable(*item.node));\n        }),\n        DfsTypeCallbacks::PreOrder([&](int idx) {"
  },
  {
    "id" : "2d7ff970-5fe8-4e21-a16a-d9f086b0b49b",
    "prId" : 26342,
    "prUrl" : "https://github.com/tensorflow/tensorflow/pull/26342#pullrequestreview-214309145",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "254e4ff7-b6a9-48de-90c0-d3e0a75526b8",
        "parentId" : null,
        "authorId" : "05c2b6c1-8a55-4dc9-ae76-02172416ea90",
        "body" : "What if `t_attr_id.attr_name` is not set, and `t_attr_id.fixed_type` is set instead?",
        "createdAt" : "2019-03-15T21:57:40Z",
        "updatedAt" : "2019-04-09T01:59:39Z",
        "lastEditedBy" : "05c2b6c1-8a55-4dc9-ae76-02172416ea90",
        "tags" : [
        ]
      }
    ],
    "commit" : "cdb7db55568626e215700bb365065d53d1d7fff8",
    "line" : 832,
    "diffHunk" : "@@ -1,1 +830,834 @@    return ToSet(t_attr_id.fixed_type);\n  }\n  const OpDef::AttrDef* attr_def = FindAttr(t_attr_id.attr_name, op_def);\n  CHECK(attr_def);\n  return AllowedDataTypes(*attr_def);"
  },
  {
    "id" : "b60d033e-1668-4e78-9646-d3e53ddfd8de",
    "prId" : 26342,
    "prUrl" : "https://github.com/tensorflow/tensorflow/pull/26342#pullrequestreview-224698751",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "37fadc46-1ba6-4822-b275-1880a6e72bcf",
        "parentId" : null,
        "authorId" : "05c2b6c1-8a55-4dc9-ae76-02172416ea90",
        "body" : "I think using a GraphTopologyView would suffice. I think including the types in the graph could hide certain relevant connections.\r\n\r\nE.g., if we have an op with two inputs of type T and U respectively, and two outputs of type T and U. With GraphTypeTopologyView, the op would be represented by two unconnected nodes. But, U could affect the numerical stability of the T output, so there perhaps should be a connection.\r\n\r\nIn practice, there is no such op. But in practice, I also think a GraphTopologyView would behave similarly to a GraphTypeTopologyView and not impact correctness or performance. Duplicating code for a GraphTypeTopologyView is not great.\r\n\r\nFor now, the current approach is fine, bu we can discuss about changing this after this PR is submitted.",
        "createdAt" : "2019-03-16T19:32:22Z",
        "updatedAt" : "2019-04-09T01:59:39Z",
        "lastEditedBy" : "05c2b6c1-8a55-4dc9-ae76-02172416ea90",
        "tags" : [
        ]
      },
      {
        "id" : "338da76f-d4b6-4c55-af15-b67458eeaf4e",
        "parentId" : "37fadc46-1ba6-4822-b275-1880a6e72bcf",
        "authorId" : "fe150b7b-80e3-40ce-88bd-077c51873903",
        "body" : "I've added a TODO.",
        "createdAt" : "2019-03-26T03:00:49Z",
        "updatedAt" : "2019-04-09T01:59:39Z",
        "lastEditedBy" : "fe150b7b-80e3-40ce-88bd-077c51873903",
        "tags" : [
        ]
      },
      {
        "id" : "548d145b-0871-45b5-b225-7bb8c536177f",
        "parentId" : "37fadc46-1ba6-4822-b275-1880a6e72bcf",
        "authorId" : "0ba8fb18-637a-4ab3-a7c8-cd971823fe45",
        "body" : "I would prefer that we do not check all this duplicated code that is to some extent copy-and-pasted from existing Grappler code.",
        "createdAt" : "2019-04-04T00:37:21Z",
        "updatedAt" : "2019-04-09T01:59:39Z",
        "lastEditedBy" : "0ba8fb18-637a-4ab3-a7c8-cd971823fe45",
        "tags" : [
        ]
      },
      {
        "id" : "2a258e35-2f5a-49e0-9a9e-d0b2d31dfd39",
        "parentId" : "37fadc46-1ba6-4822-b275-1880a6e72bcf",
        "authorId" : "05c2b6c1-8a55-4dc9-ae76-02172416ea90",
        "body" : "While I agree the duplicated code is not great, I think we should leave it as a TODO and try changing this in a future PR. Reducing this duplication will result in fundamentally changing the algorithm used to color nodes and insert casts, and this new hypothetical algorithm is currently untested and may not work. Also, we are trying to get this PR in for the TF 1.14 branch, so that users can start using mixed precision as soon as possible.",
        "createdAt" : "2019-04-04T18:24:36Z",
        "updatedAt" : "2019-04-09T01:59:39Z",
        "lastEditedBy" : "05c2b6c1-8a55-4dc9-ae76-02172416ea90",
        "tags" : [
        ]
      },
      {
        "id" : "89d2653d-cbba-4140-9ee7-2a0d3f5b1acd",
        "parentId" : "37fadc46-1ba6-4822-b275-1880a6e72bcf",
        "authorId" : "0ba8fb18-637a-4ab3-a7c8-cd971823fe45",
        "body" : "Sounds good to me.\r\n",
        "createdAt" : "2019-04-09T23:18:33Z",
        "updatedAt" : "2019-04-09T23:18:33Z",
        "lastEditedBy" : "0ba8fb18-637a-4ab3-a7c8-cd971823fe45",
        "tags" : [
        ]
      }
    ],
    "commit" : "cdb7db55568626e215700bb365065d53d1d7fff8",
    "line" : 391,
    "diffHunk" : "@@ -1,1 +389,393 @@// input B:0 with TypeAttrId 'U', and input B:0 connects to output A:0, there\n// will be an edge from (A, T) to (B, U).\nclass GraphTypeTopologyView {\n public:\n  GraphTypeTopologyView() = default;"
  }
]
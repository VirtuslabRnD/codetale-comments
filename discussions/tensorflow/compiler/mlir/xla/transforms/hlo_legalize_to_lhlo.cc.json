[
  {
    "id" : "4a8a2f5b-b742-4ed7-beb6-baba7dc3027e",
    "prId" : 36335,
    "prUrl" : "https://github.com/tensorflow/tensorflow/pull/36335#pullrequestreview-363475589",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "eb71e5ce-6696-4fa7-9086-c17676133157",
        "parentId" : null,
        "authorId" : "45da85e7-c0a9-47f8-a110-526ee93f4528",
        "body" : "(transmitting @joker-eph): Does this has much to reuse with the rest of this file? Otherwise can you please extract this into its own file?",
        "createdAt" : "2020-02-19T09:11:20Z",
        "updatedAt" : "2020-02-19T09:16:22Z",
        "lastEditedBy" : "45da85e7-c0a9-47f8-a110-526ee93f4528",
        "tags" : [
        ]
      },
      {
        "id" : "247c1486-7dc2-49be-86a3-4b354e77c8c3",
        "parentId" : "eb71e5ce-6696-4fa7-9086-c17676133157",
        "authorId" : "ad86eff8-8611-4bb4-bc44-4c1c8609b334",
        "body" : "Done.",
        "createdAt" : "2020-02-24T15:29:27Z",
        "updatedAt" : "2020-02-24T15:29:27Z",
        "lastEditedBy" : "ad86eff8-8611-4bb4-bc44-4c1c8609b334",
        "tags" : [
        ]
      }
    ],
    "commit" : "aa2d06d55f6d81cdbe721aa5938b4d815bced015",
    "line" : 95,
    "diffHunk" : "@@ -1,1 +390,394 @@/// Removes Lhlo.CopyOp that copies from an allocated buffer to the block\n/// argument. All uses of the buffer are replaced with the block argument.\nstruct RedundantCopiesRemoval : mlir::FunctionPass<RedundantCopiesRemoval> {\n  void runOnFunction() override {\n    llvm::SmallVector<mlir::Operation*, 2> eraseList;"
  },
  {
    "id" : "e576cdad-f8e2-4cab-9f11-028256f9f3b7",
    "prId" : 36335,
    "prUrl" : "https://github.com/tensorflow/tensorflow/pull/36335#pullrequestreview-363475940",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "16bcf766-b637-4c07-85b5-57d605b2132e",
        "parentId" : null,
        "authorId" : "45da85e7-c0a9-47f8-a110-526ee93f4528",
        "body" : "(transmitting @joker-eph): This assumes that the operation won't be in a block with implicit capture, I don't think we should have such assumption in passes.",
        "createdAt" : "2020-02-19T09:11:40Z",
        "updatedAt" : "2020-02-19T09:16:22Z",
        "lastEditedBy" : "45da85e7-c0a9-47f8-a110-526ee93f4528",
        "tags" : [
        ]
      },
      {
        "id" : "7c621fe5-9063-442d-a99b-f19c031ff6b6",
        "parentId" : "16bcf766-b637-4c07-85b5-57d605b2132e",
        "authorId" : "ad86eff8-8611-4bb4-bc44-4c1c8609b334",
        "body" : "This is no longer required.",
        "createdAt" : "2020-02-24T15:29:53Z",
        "updatedAt" : "2020-02-24T15:29:54Z",
        "lastEditedBy" : "ad86eff8-8611-4bb4-bc44-4c1c8609b334",
        "tags" : [
        ]
      }
    ],
    "commit" : "aa2d06d55f6d81cdbe721aa5938b4d815bced015",
    "line" : 99,
    "diffHunk" : "@@ -1,1 +394,398 @@    llvm::SmallVector<mlir::Operation*, 2> eraseList;\n    getFunction().walk([&](mlir::xla_lhlo::CopyOp copyOp) {\n      auto arguments = copyOp.getOperation()->getBlock()->getArguments();\n      if (std::any_of(arguments.begin(), arguments.end(),\n                      [&](mlir::BlockArgument arg) {"
  },
  {
    "id" : "3c4a632b-aec1-4efc-a74c-dd95a25c0da3",
    "prId" : 36335,
    "prUrl" : "https://github.com/tensorflow/tensorflow/pull/36335#pullrequestreview-363476040",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4d9f52c7-008c-41c1-af3d-5c498219149e",
        "parentId" : null,
        "authorId" : "45da85e7-c0a9-47f8-a110-526ee93f4528",
        "body" : "(transmitting @joker-eph): Nit: `llvm::any_of(arguments, [&](mlir::BlockArgument arg) {`\r\n\r\n(and below as well)",
        "createdAt" : "2020-02-19T09:12:23Z",
        "updatedAt" : "2020-02-19T09:16:22Z",
        "lastEditedBy" : "45da85e7-c0a9-47f8-a110-526ee93f4528",
        "tags" : [
        ]
      },
      {
        "id" : "bfbae675-aff8-4b05-92d1-9d2d425cb2e1",
        "parentId" : "4d9f52c7-008c-41c1-af3d-5c498219149e",
        "authorId" : "ad86eff8-8611-4bb4-bc44-4c1c8609b334",
        "body" : "This is no longer required.",
        "createdAt" : "2020-02-24T15:30:02Z",
        "updatedAt" : "2020-02-24T15:30:02Z",
        "lastEditedBy" : "ad86eff8-8611-4bb4-bc44-4c1c8609b334",
        "tags" : [
        ]
      }
    ],
    "commit" : "aa2d06d55f6d81cdbe721aa5938b4d815bced015",
    "line" : 100,
    "diffHunk" : "@@ -1,1 +395,399 @@    getFunction().walk([&](mlir::xla_lhlo::CopyOp copyOp) {\n      auto arguments = copyOp.getOperation()->getBlock()->getArguments();\n      if (std::any_of(arguments.begin(), arguments.end(),\n                      [&](mlir::BlockArgument arg) {\n                        return copyOp.output() == arg;"
  },
  {
    "id" : "a0abc4fc-9084-47aa-a293-d8d70d01a0c1",
    "prId" : 36335,
    "prUrl" : "https://github.com/tensorflow/tensorflow/pull/36335#pullrequestreview-363476170",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1e939ad0-e94a-4a6b-beec-066919fc8d68",
        "parentId" : null,
        "authorId" : "45da85e7-c0a9-47f8-a110-526ee93f4528",
        "body" : "(transmitting @joker-eph): Just a nit, but these accessors aren't \"free\" I believe, it is better to materialize a local value outside of the loop when possible.\r\n\r\n(In particular you *are* materializing them right after)",
        "createdAt" : "2020-02-19T09:13:17Z",
        "updatedAt" : "2020-02-19T09:16:22Z",
        "lastEditedBy" : "45da85e7-c0a9-47f8-a110-526ee93f4528",
        "tags" : [
        ]
      },
      {
        "id" : "ed85a59b-681b-48ee-b849-8c7bec4fec26",
        "parentId" : "1e939ad0-e94a-4a6b-beec-066919fc8d68",
        "authorId" : "ad86eff8-8611-4bb4-bc44-4c1c8609b334",
        "body" : "This is no longer required.",
        "createdAt" : "2020-02-24T15:30:12Z",
        "updatedAt" : "2020-02-24T15:30:12Z",
        "lastEditedBy" : "ad86eff8-8611-4bb4-bc44-4c1c8609b334",
        "tags" : [
        ]
      }
    ],
    "commit" : "aa2d06d55f6d81cdbe721aa5938b4d815bced015",
    "line" : 102,
    "diffHunk" : "@@ -1,1 +397,401 @@      if (std::any_of(arguments.begin(), arguments.end(),\n                      [&](mlir::BlockArgument arg) {\n                        return copyOp.output() == arg;\n                      }) &&\n          std::none_of(arguments.begin(), arguments.end(),"
  },
  {
    "id" : "a80a3b6b-9042-4d0d-be32-0993181aca2d",
    "prId" : 36335,
    "prUrl" : "https://github.com/tensorflow/tensorflow/pull/36335#pullrequestreview-360937988",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d61d1afd-3acb-4d95-b49f-e17267e24545",
        "parentId" : null,
        "authorId" : "45da85e7-c0a9-47f8-a110-526ee93f4528",
        "body" : "(transmitting @joker-eph): (Super nit: early return)",
        "createdAt" : "2020-02-19T09:13:54Z",
        "updatedAt" : "2020-02-19T09:16:22Z",
        "lastEditedBy" : "45da85e7-c0a9-47f8-a110-526ee93f4528",
        "tags" : [
        ]
      }
    ],
    "commit" : "aa2d06d55f6d81cdbe721aa5938b4d815bced015",
    "line" : 107,
    "diffHunk" : "@@ -1,1 +402,406 @@                       [&](mlir::BlockArgument arg) {\n                         return copyOp.operand() == arg;\n                       })) {\n        mlir::Value operand = copyOp.operand();\n        mlir::Value output = copyOp.output();"
  },
  {
    "id" : "55d4d317-638d-4b03-905f-37746511e20a",
    "prId" : 36335,
    "prUrl" : "https://github.com/tensorflow/tensorflow/pull/36335#pullrequestreview-363477561",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c4151580-86f7-4e53-be84-b4da41325cf7",
        "parentId" : null,
        "authorId" : "45da85e7-c0a9-47f8-a110-526ee93f4528",
        "body" : "(transmitting @joker-eph): Actually I wonder if you need to do all this, I think you could just replace the loop with:\r\n\r\nif ( // output is a block argument\r\n     !copyOp.output().getDefiningOp()\r\n      // operand is not a block argument\r\n     &&  copyOp.operand().getDefiningOp()) {",
        "createdAt" : "2020-02-19T09:14:23Z",
        "updatedAt" : "2020-02-19T09:16:22Z",
        "lastEditedBy" : "45da85e7-c0a9-47f8-a110-526ee93f4528",
        "tags" : [
        ]
      },
      {
        "id" : "436e6051-f0ac-4c55-bc52-ad5dd1bb476d",
        "parentId" : "c4151580-86f7-4e53-be84-b4da41325cf7",
        "authorId" : "ad86eff8-8611-4bb4-bc44-4c1c8609b334",
        "body" : "Done.",
        "createdAt" : "2020-02-24T15:31:49Z",
        "updatedAt" : "2020-02-24T15:31:49Z",
        "lastEditedBy" : "ad86eff8-8611-4bb4-bc44-4c1c8609b334",
        "tags" : [
        ]
      }
    ],
    "commit" : "aa2d06d55f6d81cdbe721aa5938b4d815bced015",
    "line" : 107,
    "diffHunk" : "@@ -1,1 +402,406 @@                       [&](mlir::BlockArgument arg) {\n                         return copyOp.operand() == arg;\n                       })) {\n        mlir::Value operand = copyOp.operand();\n        mlir::Value output = copyOp.output();"
  },
  {
    "id" : "31c58f70-4a39-4519-a0c4-543861c4d1d6",
    "prId" : 36335,
    "prUrl" : "https://github.com/tensorflow/tensorflow/pull/36335#pullrequestreview-363493984",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "34210320-6a01-457c-8a61-e8e58364b4f8",
        "parentId" : null,
        "authorId" : "45da85e7-c0a9-47f8-a110-526ee93f4528",
        "body" : "(transmitting @joker-eph): You are dereferencing the user of the allocOp while you already deleted the copyOp, which mean there might be no user left.\r\n\r\nHere is a minimal reproducer that will show it:\r\n\r\nfunc @fusion(%arg0: memref<2x2xf32>) -> memref<2x2xf32> {\r\n  %0 = alloc() {temp = true} : memref<2x2xf32>\r\n  \"xla_lhlo.copy\"(%0, %arg0) : (memref<2x2xf32>, memref<2x2xf32>) -> ()\r\n  return %0 : memref<2x2xf32>\r\n}\r\n\r\nThis comes back to my other point about testing: with dedicated testing for this pass, I would have expected this IR to be the first basic test to validate the pass.",
        "createdAt" : "2020-02-19T09:14:46Z",
        "updatedAt" : "2020-02-19T09:16:22Z",
        "lastEditedBy" : "45da85e7-c0a9-47f8-a110-526ee93f4528",
        "tags" : [
        ]
      },
      {
        "id" : "a023e0b1-b020-4cee-ada2-f3066a55d8ec",
        "parentId" : "34210320-6a01-457c-8a61-e8e58364b4f8",
        "authorId" : "ad86eff8-8611-4bb4-bc44-4c1c8609b334",
        "body" : "Thanks for the hint. You are right that this code snippet would break our current version. Although this code could exist from a theoretical point of view as an input program, the current implementation of the `HLO-to-LHLO-Legalization` pass ensures that there will always be a dealloc. Furthermore, it is even worse: currently, the `Std.Return-to-LHLO` converter expects a final dealloc operation to place a proper `CopyOp`. The following code snippet is taken from the `hlo_legalize_to_lhlo.cc` file (starting in line 425):\r\n```c++\r\nif (dealloc == nullptr) {\r\n    returnOp.emitOpError()\r\n        << \"Missing dealloc for operand \" << operand.index();\r\n    return matchFailure();\r\n}\r\n```\r\nThis code snippet also fails in the following tiny test case:\r\n```\r\nfunc @TestFunc(%arg0: tensor<2xf32>) -> tensor<2xf32> {\r\n   return %arg0 : tensor<2xf32>\r\n}\r\n```",
        "createdAt" : "2020-02-24T15:51:50Z",
        "updatedAt" : "2020-02-24T15:51:50Z",
        "lastEditedBy" : "ad86eff8-8611-4bb4-bc44-4c1c8609b334",
        "tags" : [
        ]
      }
    ],
    "commit" : "aa2d06d55f6d81cdbe721aa5938b4d815bced015",
    "line" : 118,
    "diffHunk" : "@@ -1,1 +413,417 @@        auto allocOp = operand.getDefiningOp();\n        if (auto deallocOp =\n                mlir::dyn_cast<mlir::DeallocOp>(*allocOp->getUsers().begin())) {\n          eraseList.push_back(deallocOp);\n          eraseList.push_back(allocOp);"
  },
  {
    "id" : "d745b75e-789f-44df-859e-90c2a7043765",
    "prId" : 36335,
    "prUrl" : "https://github.com/tensorflow/tensorflow/pull/36335#pullrequestreview-360937988",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "271b3402-0946-4d6c-b812-2797b8297f6d",
        "parentId" : null,
        "authorId" : "45da85e7-c0a9-47f8-a110-526ee93f4528",
        "body" : "(transmitting @joker-eph): Style: do not use `auto` when the type is not obvious from the context (like dyn_cast, etc.). Auto is supposed to be for improving readability only.",
        "createdAt" : "2020-02-19T09:15:17Z",
        "updatedAt" : "2020-02-19T09:16:22Z",
        "lastEditedBy" : "45da85e7-c0a9-47f8-a110-526ee93f4528",
        "tags" : [
        ]
      }
    ],
    "commit" : "aa2d06d55f6d81cdbe721aa5938b4d815bced015",
    "line" : 128,
    "diffHunk" : "@@ -1,1 +423,427 @@    }\n  };\n};\n\nstd::unique_ptr<OpPassBase<ModuleOp>> createLegalizeToLhloPass() {"
  },
  {
    "id" : "857b618f-b651-405f-93a6-3d007d613631",
    "prId" : 36242,
    "prUrl" : "https://github.com/tensorflow/tensorflow/pull/36242#pullrequestreview-349248733",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e9116574-324a-4fdf-8ec1-cd8095b0f428",
        "parentId" : null,
        "authorId" : "23268ae6-07df-4999-9478-4a39951fd87f",
        "body" : "Why is this legal? Or is the assumption that there is a single block?",
        "createdAt" : "2020-01-27T15:33:41Z",
        "updatedAt" : "2020-01-29T12:58:17Z",
        "lastEditedBy" : "23268ae6-07df-4999-9478-4a39951fd87f",
        "tags" : [
        ]
      },
      {
        "id" : "89385039-168c-412c-84ae-546c21756e4b",
        "parentId" : "e9116574-324a-4fdf-8ec1-cd8095b0f428",
        "authorId" : "ad86eff8-8611-4bb4-bc44-4c1c8609b334",
        "body" : "Yes, it is assumed for this PR.",
        "createdAt" : "2020-01-28T09:58:29Z",
        "updatedAt" : "2020-01-29T12:58:17Z",
        "lastEditedBy" : "ad86eff8-8611-4bb4-bc44-4c1c8609b334",
        "tags" : [
        ]
      }
    ],
    "commit" : "a97d62e64274d492460e7c863e74cb7aee2fcdc2",
    "line" : 68,
    "diffHunk" : "@@ -1,1 +80,84 @@\n  allocBuilder.setInsertionPoint(block, std::prev(block->end()));\n  allocBuilder.create<DeallocOp>(loc, alloc);\n\n  return alloc;"
  },
  {
    "id" : "ac25c1f2-14cf-4055-856c-26209596ba6f",
    "prId" : 36242,
    "prUrl" : "https://github.com/tensorflow/tensorflow/pull/36242#pullrequestreview-348716656",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0953d297-0b94-4f88-825c-e06f80d90c8f",
        "parentId" : null,
        "authorId" : "23268ae6-07df-4999-9478-4a39951fd87f",
        "body" : "Could you add a comment describing the transformation?",
        "createdAt" : "2020-01-27T15:45:00Z",
        "updatedAt" : "2020-01-29T12:58:17Z",
        "lastEditedBy" : "23268ae6-07df-4999-9478-4a39951fd87f",
        "tags" : [
        ]
      }
    ],
    "commit" : "a97d62e64274d492460e7c863e74cb7aee2fcdc2",
    "line" : 272,
    "diffHunk" : "@@ -1,1 +340,344 @@/// Transforms ReturnOp to LhloTerminator. CopyOp is inserted to copy each\n/// result to the corresponding buffer argument.\nclass StdToLhloReturnOpConverter : public OpConversionPattern<mlir::ReturnOp> {\n public:\n  using OpConversionPattern::OpConversionPattern;"
  },
  {
    "id" : "746c9504-f0ed-4318-9096-e5c18ab487f8",
    "prId" : 36242,
    "prUrl" : "https://github.com/tensorflow/tensorflow/pull/36242#pullrequestreview-348716656",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "88db462f-cea7-47f5-a147-8dda8359dadb",
        "parentId" : null,
        "authorId" : "23268ae6-07df-4999-9478-4a39951fd87f",
        "body" : "Comment?",
        "createdAt" : "2020-01-27T15:45:44Z",
        "updatedAt" : "2020-01-29T12:58:17Z",
        "lastEditedBy" : "23268ae6-07df-4999-9478-4a39951fd87f",
        "tags" : [
        ]
      }
    ],
    "commit" : "a97d62e64274d492460e7c863e74cb7aee2fcdc2",
    "line" : 239,
    "diffHunk" : "@@ -1,1 +307,311 @@/// Transforms FuncOp arguments and results from tensors to buffers. Tensor\n/// results are converted to memrefs and appended to the argument list.\nclass HloToLhloFuncOpConverter : public OpConversionPattern<FuncOp> {\n public:\n  using OpConversionPattern::OpConversionPattern;"
  },
  {
    "id" : "adecc954-8d94-4140-94f5-8e1c39187708",
    "prId" : 36242,
    "prUrl" : "https://github.com/tensorflow/tensorflow/pull/36242#pullrequestreview-349992538",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7b45884a-bda9-4e15-ba7b-b1d858032a73",
        "parentId" : null,
        "authorId" : "23268ae6-07df-4999-9478-4a39951fd87f",
        "body" : "This is not needed. The code outside this scope does not rely on a specific insertion point anyway.",
        "createdAt" : "2020-01-28T12:58:21Z",
        "updatedAt" : "2020-01-29T12:58:17Z",
        "lastEditedBy" : "23268ae6-07df-4999-9478-4a39951fd87f",
        "tags" : [
        ]
      },
      {
        "id" : "c5833736-b1f8-49e2-bb80-d2546f0203ae",
        "parentId" : "7b45884a-bda9-4e15-ba7b-b1d858032a73",
        "authorId" : "23268ae6-07df-4999-9478-4a39951fd87f",
        "body" : "Never mind, I just realized there is a `replaceOpWithNewOp` at the end.",
        "createdAt" : "2020-01-29T10:12:40Z",
        "updatedAt" : "2020-01-29T12:58:17Z",
        "lastEditedBy" : "23268ae6-07df-4999-9478-4a39951fd87f",
        "tags" : [
        ]
      }
    ],
    "commit" : "a97d62e64274d492460e7c863e74cb7aee2fcdc2",
    "line" : 297,
    "diffHunk" : "@@ -1,1 +365,369 @@        return matchFailure();\n      }      \n      OpBuilder::InsertionGuard guard(rewriter);\n      rewriter.setInsertionPoint(dealloc);\n      rewriter.create<xla_lhlo::CopyOp>(loc, llvm::None, operand.value(),"
  },
  {
    "id" : "aa0461dc-de54-44d8-bc74-7da34cefdb60",
    "prId" : 36242,
    "prUrl" : "https://github.com/tensorflow/tensorflow/pull/36242#pullrequestreview-350079947",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "df452ab3-e923-4679-9bca-0eab88ed5439",
        "parentId" : null,
        "authorId" : "23268ae6-07df-4999-9478-4a39951fd87f",
        "body" : "It would be more consistent to replace TensorStore operations with copy and always allocate the result. Not necessarily in this PR but once we have a pass that optimizes redundant alloc/copy/dealloc operations away.",
        "createdAt" : "2020-01-28T13:02:29Z",
        "updatedAt" : "2020-01-29T12:58:17Z",
        "lastEditedBy" : "23268ae6-07df-4999-9478-4a39951fd87f",
        "tags" : [
        ]
      },
      {
        "id" : "4757da2d-f01f-4c5c-be47-ffcbb8830540",
        "parentId" : "df452ab3-e923-4679-9bca-0eab88ed5439",
        "authorId" : "ad86eff8-8611-4bb4-bc44-4c1c8609b334",
        "body" : "Sure, I will address this in the next PR.",
        "createdAt" : "2020-01-29T12:48:40Z",
        "updatedAt" : "2020-01-29T12:58:17Z",
        "lastEditedBy" : "ad86eff8-8611-4bb4-bc44-4c1c8609b334",
        "tags" : [
        ]
      }
    ],
    "commit" : "a97d62e64274d492460e7c863e74cb7aee2fcdc2",
    "line" : 78,
    "diffHunk" : "@@ -1,1 +90,94 @@Value GetBufferForResultValue(Location loc, Value result,\n                              ConversionPatternRewriter* rewriter) {\n  if (auto existing_memref = GetTensorStore(result)) {\n    return existing_memref;\n  }"
  },
  {
    "id" : "6a959994-eb9d-4b5b-881b-318c44baf513",
    "prId" : 36242,
    "prUrl" : "https://github.com/tensorflow/tensorflow/pull/36242#pullrequestreview-349352564",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0815d9f2-1c18-44fd-b950-ce79adeba72f",
        "parentId" : null,
        "authorId" : "23268ae6-07df-4999-9478-4a39951fd87f",
        "body" : "It would be nice if this also had an example for what happens with functions.",
        "createdAt" : "2020-01-28T13:04:17Z",
        "updatedAt" : "2020-01-29T12:58:17Z",
        "lastEditedBy" : "23268ae6-07df-4999-9478-4a39951fd87f",
        "tags" : [
        ]
      }
    ],
    "commit" : "a97d62e64274d492460e7c863e74cb7aee2fcdc2",
    "line" : 159,
    "diffHunk" : "@@ -1,1 +201,205 @@};\n\n// Lowers from HLO dialect to LHLO dialect allocating/deallocating temporary\n// buffers if necessary.\n//"
  }
]
[
  {
    "id" : "bb558ab0-fb41-4bef-afc2-b7de043c5cbb",
    "prId" : 47332,
    "prUrl" : "https://github.com/tensorflow/tensorflow/pull/47332#pullrequestreview-599961805",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "95979a77-d832-48d8-8170-b13ea7bdea09",
        "parentId" : null,
        "authorId" : "dc2d2e0c-b690-4812-96e8-4d9e58f7d2e1",
        "body" : "```{i}``` -> ```{static_cast<uint64_t>(i)}```",
        "createdAt" : "2021-02-26T11:38:27Z",
        "updatedAt" : "2021-02-26T21:43:17Z",
        "lastEditedBy" : "dc2d2e0c-b690-4812-96e8-4d9e58f7d2e1",
        "tags" : [
        ]
      },
      {
        "id" : "fb6425a8-7431-400f-a633-8a1f20a5c766",
        "parentId" : "95979a77-d832-48d8-8170-b13ea7bdea09",
        "authorId" : "46ee1aa2-6cc0-4d18-ba46-b2b3ce5fd5a6",
        "body" : "How about `for (uint64_t i = 0....)`?",
        "createdAt" : "2021-02-26T21:39:52Z",
        "updatedAt" : "2021-02-26T21:43:17Z",
        "lastEditedBy" : "46ee1aa2-6cc0-4d18-ba46-b2b3ce5fd5a6",
        "tags" : [
        ]
      },
      {
        "id" : "6b3f3c26-221b-4e26-a3c8-b23d20b7eb9f",
        "parentId" : "95979a77-d832-48d8-8170-b13ea7bdea09",
        "authorId" : "dc2d2e0c-b690-4812-96e8-4d9e58f7d2e1",
        "body" : "SG",
        "createdAt" : "2021-02-26T21:40:54Z",
        "updatedAt" : "2021-02-26T21:43:17Z",
        "lastEditedBy" : "dc2d2e0c-b690-4812-96e8-4d9e58f7d2e1",
        "tags" : [
        ]
      }
    ],
    "commit" : "cdd824979847682341d575842f79b786cf9a9b02",
    "line" : 41,
    "diffHunk" : "@@ -1,1 +248,252 @@  for (uint64_t i = 0; i < rank; ++i) {\n    if (begin_attr.getValue<APInt>({i}).getSExtValue() != 0) return false;\n    int64_t si = size_attr.getValue<APInt>({i}).getSExtValue();\n    if (si != -1 && si != input_ty.getDimSize(i)) return false;\n  }"
  },
  {
    "id" : "7afda5f6-e4e0-459d-a5f5-337dd31f26c5",
    "prId" : 47332,
    "prUrl" : "https://github.com/tensorflow/tensorflow/pull/47332#pullrequestreview-599494870",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0f980c21-91c0-4b3e-8d2f-3cd05695f54c",
        "parentId" : null,
        "authorId" : "dc2d2e0c-b690-4812-96e8-4d9e58f7d2e1",
        "body" : "```{i}``` -> ```{static_cast<uint64_t>(i)}```",
        "createdAt" : "2021-02-26T11:38:39Z",
        "updatedAt" : "2021-02-26T21:43:17Z",
        "lastEditedBy" : "dc2d2e0c-b690-4812-96e8-4d9e58f7d2e1",
        "tags" : [
        ]
      }
    ],
    "commit" : "cdd824979847682341d575842f79b786cf9a9b02",
    "line" : 40,
    "diffHunk" : "@@ -1,1 +247,251 @@  // `input.shape[i]`.\n  for (uint64_t i = 0; i < rank; ++i) {\n    if (begin_attr.getValue<APInt>({i}).getSExtValue() != 0) return false;\n    int64_t si = size_attr.getValue<APInt>({i}).getSExtValue();\n    if (si != -1 && si != input_ty.getDimSize(i)) return false;"
  },
  {
    "id" : "4f097233-284f-4b53-b935-b16cb044f408",
    "prId" : 39031,
    "prUrl" : "https://github.com/tensorflow/tensorflow/pull/39031#pullrequestreview-405325791",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "81144d7c-5fc9-43d7-a2d7-2d0ceb0a6156",
        "parentId" : null,
        "authorId" : "155f35ce-79aa-4b33-8dc9-776496a43ed3",
        "body" : "remove the extra space. ",
        "createdAt" : "2020-05-01T17:08:07Z",
        "updatedAt" : "2020-05-27T15:32:07Z",
        "lastEditedBy" : "155f35ce-79aa-4b33-8dc9-776496a43ed3",
        "tags" : [
        ]
      },
      {
        "id" : "0de9d8cc-5b79-4e2d-8aef-8359ad5995d0",
        "parentId" : "81144d7c-5fc9-43d7-a2d7-2d0ceb0a6156",
        "authorId" : "155f35ce-79aa-4b33-8dc9-776496a43ed3",
        "body" : "Tensorflow's C++ style requires `NotFromQuantOpDifferentQuanteUse`",
        "createdAt" : "2020-05-01T17:08:48Z",
        "updatedAt" : "2020-05-27T15:32:07Z",
        "lastEditedBy" : "155f35ce-79aa-4b33-8dc9-776496a43ed3",
        "tags" : [
        ]
      },
      {
        "id" : "9618a889-b6a8-4b66-bb5e-227fab550656",
        "parentId" : "81144d7c-5fc9-43d7-a2d7-2d0ceb0a6156",
        "authorId" : "155f35ce-79aa-4b33-8dc9-776496a43ed3",
        "body" : "I think this check is too restrict...we just need to check the quantization parameters are the same:\r\n```\r\nreturn val.getType().cast<ShapedType>().getElementalType() == qtype.getValue();\r\n```\r\n",
        "createdAt" : "2020-05-01T17:12:49Z",
        "updatedAt" : "2020-05-27T15:32:07Z",
        "lastEditedBy" : "155f35ce-79aa-4b33-8dc9-776496a43ed3",
        "tags" : [
        ]
      },
      {
        "id" : "183c1dc1-6c47-40d9-bdac-075b78bc7fbc",
        "parentId" : "81144d7c-5fc9-43d7-a2d7-2d0ceb0a6156",
        "authorId" : "6f64fc9d-f87f-4832-a865-94bcaa5d8c2a",
        "body" : "Hmm... to ignore shape when checking for identical quantization we presumably need to compare with ElementType of qtype attr value.  \r\n\r\nExplanation: quant::GetQuantizedTypeAttr appears to constructs TFL::QuantizeOp qtype attr as a ShapedType if (as would typically be the case) the output of the original fake_quant op(s) was shaped (vector, tensor ...).  \r\n\r\nAlso can we exclude   fake_quant input being a non ShapedType type?   The construction of qtype attr type seems to go to a lot of trouble to handle non-ShapedType cases.... \r\nSafer to handle the non-ShapedType cases.\r\n\r\nI'll push a corresponding change for review.",
        "createdAt" : "2020-05-04T20:33:52Z",
        "updatedAt" : "2020-05-27T15:32:07Z",
        "lastEditedBy" : "6f64fc9d-f87f-4832-a865-94bcaa5d8c2a",
        "tags" : [
        ]
      }
    ],
    "commit" : "b6e69da1f90f059d23a72d51af37346ffa109b9f",
    "line" : 15,
    "diffHunk" : "@@ -1,1 +218,222 @@\nbool NotFromQuantOpDifferentQuant(Value val, TypeAttr qtype_attr) {\n  auto val_defn_op = val.getDefiningOp();\n  TFL::QuantizeOp q_op = llvm::dyn_cast_or_null<TFL::QuantizeOp>(val_defn_op);\n  if (!q_op)"
  }
]
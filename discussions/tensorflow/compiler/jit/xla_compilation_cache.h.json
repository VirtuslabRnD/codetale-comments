[
  {
    "id" : "b5c50ded-e4f6-4e04-8148-453d14da02ce",
    "prId" : 43034,
    "prUrl" : "https://github.com/tensorflow/tensorflow/pull/43034#pullrequestreview-505031529",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a36d55d6-8365-4a8b-b914-77787c8c569c",
        "parentId" : null,
        "authorId" : "2861a495-42d5-4ac3-b543-23cf14c0a980",
        "body" : "Have you looked into making `CompileAsynchronous` a separate method / class that lives outside `XlaCompilationCache` and interacts with it only via its public interface (suitably refactored)?  That might simplify the change a bit.",
        "createdAt" : "2020-09-24T05:02:53Z",
        "updatedAt" : "2021-02-27T00:51:14Z",
        "lastEditedBy" : "2861a495-42d5-4ac3-b543-23cf14c0a980",
        "tags" : [
        ]
      },
      {
        "id" : "52209f1a-cb4a-44c5-be8a-2565c4074b92",
        "parentId" : "a36d55d6-8365-4a8b-b914-77787c8c569c",
        "authorId" : "ce170c1c-de15-4dea-9405-50e61baf5684",
        "body" : "I did not.\r\nLooking at it, I'm not sure it fits, unless the refactoring is substantial.\r\nCurrently CompileImpl and ComplieStrict are both XlaCompilationCache members, as is Entry. CompileAsynchronus sits in between these two functions, and operates on the Entry Type.  ",
        "createdAt" : "2020-10-08T17:57:21Z",
        "updatedAt" : "2021-02-27T00:51:14Z",
        "lastEditedBy" : "ce170c1c-de15-4dea-9405-50e61baf5684",
        "tags" : [
        ]
      }
    ],
    "commit" : "597499a8fef673b413b9ceb5610a0c65f8a1440e",
    "line" : 85,
    "diffHunk" : "@@ -1,1 +187,191 @@    const std::function<Status(XlaCompiler* compiler,\n                               const std::vector<XlaCompiler::Argument>& args,\n                               XlaCompiler::CompilationResult*)>& compile_fn);\n\n  mutex compile_cache_mu_;"
  },
  {
    "id" : "fee176a0-5db3-4f0e-a565-a29c943d4e53",
    "prId" : 43034,
    "prUrl" : "https://github.com/tensorflow/tensorflow/pull/43034#pullrequestreview-567855918",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bd452c9e-d3b8-4771-8b12-f71e4699211f",
        "parentId" : null,
        "authorId" : "2861a495-42d5-4ac3-b543-23cf14c0a980",
        "body" : "This doesn't really solve the problem right; if someone adds more stuff after `async_compilation_` then those things will still get destroyed before the thread pool right?\r\n\r\nI meant doing:\r\n\r\n```\r\n private:\r\n  std::unique_ptr<AsyncCompilation> async_compilation_;\r\n\r\n...\r\n  ~ XlaCompilationCache() {\r\n    async_compilation_.reset();\r\n  }\r\n```\r\n\r\nThen `async_compilation_` will be destroyed before other fields, even if more fields are added after it.",
        "createdAt" : "2021-01-13T23:31:43Z",
        "updatedAt" : "2021-02-27T00:51:15Z",
        "lastEditedBy" : "2861a495-42d5-4ac3-b543-23cf14c0a980",
        "tags" : [
        ]
      },
      {
        "id" : "90d3036c-cf18-4930-8716-8820132c4321",
        "parentId" : "bd452c9e-d3b8-4771-8b12-f71e4699211f",
        "authorId" : "ce170c1c-de15-4dea-9405-50e61baf5684",
        "body" : "it does solve the problem. Destructors get called in reverse order, and  ~ XlaCompilationCache() gets called first before any member destructor.",
        "createdAt" : "2021-01-14T05:12:48Z",
        "updatedAt" : "2021-02-27T00:51:15Z",
        "lastEditedBy" : "ce170c1c-de15-4dea-9405-50e61baf5684",
        "tags" : [
        ]
      }
    ],
    "commit" : "597499a8fef673b413b9ceb5610a0c65f8a1440e",
    "line" : 107,
    "diffHunk" : "@@ -1,1 +228,232 @@\n    // Pool of threads for asynchronous compilations.\n    std::unique_ptr<thread::ThreadPool> compiler_threads;\n\n    AsyncCompilationState()"
  }
]
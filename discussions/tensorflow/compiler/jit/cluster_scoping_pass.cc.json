[
  {
    "id" : "cdc3871f-15b6-4466-886c-7974c435b9a1",
    "prId" : 31594,
    "prUrl" : "https://github.com/tensorflow/tensorflow/pull/31594#pullrequestreview-276658403",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "be79bcaa-73f2-4da5-8aa0-966c78486812",
        "parentId" : null,
        "authorId" : "2861a495-42d5-4ac3-b543-23cf14c0a980",
        "body" : "Why do we not need an edge filter here?  We can have backwards cycles too right?",
        "createdAt" : "2019-08-16T21:16:15Z",
        "updatedAt" : "2019-08-19T18:06:50Z",
        "lastEditedBy" : "2861a495-42d5-4ac3-b543-23cf14c0a980",
        "tags" : [
        ]
      },
      {
        "id" : "1f60494c-c68e-4567-bf28-79852f43715c",
        "parentId" : "be79bcaa-73f2-4da5-8aa0-966c78486812",
        "authorId" : "04e5d7bd-a136-4f0a-9cb0-0e56fd16cec3",
        "body" : "Yes, there can be backward cycles. The only reason there is no edge filter is because `ReverseDFSFromHelper` does not accept an edge filter as input argument (for reasons unclear to me). I should have brought up this for discussions but I somehow completely forgot this asymmetry. (Excuse me for this.)\r\n\r\nOn a second thought on the traversal, I am now towards traversing along backedges (i.e., do not exclude backedge). In the current _stage_ example, it is hard to imagine that we have both `stage` and `unstage` in the same loop. If they are not in the same loop, we should optimize towards having larger clusters and we should not break the loop into multiple clusters.\r\n\r\nHence, traversing along backedges should make more sense for the current case and we can re-visit this in the future when we see more cases. If this makes sense to you, I will update the code to remove edge filters (with some notes). Please feel free to let me know what you think?\r\n\r\n",
        "createdAt" : "2019-08-16T22:14:52Z",
        "updatedAt" : "2019-08-19T18:06:50Z",
        "lastEditedBy" : "04e5d7bd-a136-4f0a-9cb0-0e56fd16cec3",
        "tags" : [
        ]
      },
      {
        "id" : "4739957c-34ae-492a-bcec-7b7bb02ef079",
        "parentId" : "be79bcaa-73f2-4da5-8aa0-966c78486812",
        "authorId" : "04e5d7bd-a136-4f0a-9cb0-0e56fd16cec3",
        "body" : "Updated the codes as I convinced myself that DFS without filtering backedges is a more desirable behavior. Still, let me know what you think. Thanks.",
        "createdAt" : "2019-08-18T16:52:20Z",
        "updatedAt" : "2019-08-19T18:06:50Z",
        "lastEditedBy" : "04e5d7bd-a136-4f0a-9cb0-0e56fd16cec3",
        "tags" : [
        ]
      },
      {
        "id" : "03bb8276-96c2-4ec7-aea1-af72f55d966f",
        "parentId" : "be79bcaa-73f2-4da5-8aa0-966c78486812",
        "authorId" : "2861a495-42d5-4ac3-b543-23cf14c0a980",
        "body" : "No filter SGTM.",
        "createdAt" : "2019-08-19T16:03:05Z",
        "updatedAt" : "2019-08-19T18:06:50Z",
        "lastEditedBy" : "2861a495-42d5-4ac3-b543-23cf14c0a980",
        "tags" : [
        ]
      }
    ],
    "commit" : "21992fc549048852ba0cdbe935d6180169007440",
    "line" : 105,
    "diffHunk" : "@@ -1,1 +103,107 @@  starts.push_back(start);\n  auto enter = [&](Node* n) { AddOrAppendXlaInternalScope(n, unique_suffix); };\n  ReverseDFSFrom(*graph_, starts, enter, /*leave=*/nullptr,\n                 /*stable_comparator=*/NodeComparatorName());\n}"
  },
  {
    "id" : "9c1e0c42-dd7d-4943-aabb-b451f21ee1f4",
    "prId" : 31594,
    "prUrl" : "https://github.com/tensorflow/tensorflow/pull/31594#pullrequestreview-276729550",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8ece54c6-af1d-4cda-b87b-8c02787504cf",
        "parentId" : null,
        "authorId" : "2861a495-42d5-4ac3-b543-23cf14c0a980",
        "body" : "Pedantically this is bit odd.  If we have `Unstage` -> `X` -> `Stage`; `Y` -> `Stage` then we'd be fine putting `X` and `Y` in the same cluster.  However, we won't do that in this scheme.\r\n\r\nI think that's fine though (the situation above should be rare), but it would be nice to add a comment, if my understanding above is correct.",
        "createdAt" : "2019-08-19T16:02:30Z",
        "updatedAt" : "2019-08-19T18:06:50Z",
        "lastEditedBy" : "2861a495-42d5-4ac3-b543-23cf14c0a980",
        "tags" : [
        ]
      },
      {
        "id" : "192f4cdb-199b-4e21-8e95-85839169dfd8",
        "parentId" : "8ece54c6-af1d-4cda-b87b-8c02787504cf",
        "authorId" : "04e5d7bd-a136-4f0a-9cb0-0e56fd16cec3",
        "body" : "See the above comment for the response.",
        "createdAt" : "2019-08-19T18:29:16Z",
        "updatedAt" : "2019-08-19T18:31:34Z",
        "lastEditedBy" : "04e5d7bd-a136-4f0a-9cb0-0e56fd16cec3",
        "tags" : [
        ]
      }
    ],
    "commit" : "21992fc549048852ba0cdbe935d6180169007440",
    "line" : 94,
    "diffHunk" : "@@ -1,1 +92,96 @@    updated_scope = std::string(suffix);\n  } else {\n    updated_scope = absl::StrCat(cur_scope.value(), \"&\", suffix);\n  }\n  SetXlaInternalScope(node, updated_scope);"
  }
]
[
  {
    "id" : "a833d2ea-30a0-41b1-a67a-d625c83f2dd1",
    "prId" : 19769,
    "prUrl" : "https://github.com/tensorflow/tensorflow/pull/19769#pullrequestreview-126983660",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "12e3f831-5b11-420a-a831-c9458b91bc35",
        "parentId" : null,
        "authorId" : "845afb08-ba85-462c-92e8-305877b05a5d",
        "body" : "No need to change it, how you have it here is totally fine, but FYI most of us enjoy writing tests using the textual format.  (Update your tree and grep for `ParseHloString`.)",
        "createdAt" : "2018-06-07T16:28:47Z",
        "updatedAt" : "2018-06-07T20:04:21Z",
        "lastEditedBy" : "845afb08-ba85-462c-92e8-305877b05a5d",
        "tags" : [
        ]
      },
      {
        "id" : "35236071-7ca5-45ee-a1b2-c6b44d694de2",
        "parentId" : "12e3f831-5b11-420a-a831-c9458b91bc35",
        "authorId" : "8b6d0937-a9aa-4efc-8d2e-f3224f679760",
        "body" : "i have some tests which use that text string processing thing, but I'm not sure how you can refer to the pre-optimized instructions at post-optimization check time.   \r\n\r\ni suppose you could walk up the tree from the root and check the opcode or metadata.\r\n",
        "createdAt" : "2018-06-07T19:58:49Z",
        "updatedAt" : "2018-06-07T20:04:21Z",
        "lastEditedBy" : "8b6d0937-a9aa-4efc-8d2e-f3224f679760",
        "tags" : [
        ]
      },
      {
        "id" : "54539f67-4c42-42fb-8e76-19c11d2f144c",
        "parentId" : "12e3f831-5b11-420a-a831-c9458b91bc35",
        "authorId" : "845afb08-ba85-462c-92e8-305877b05a5d",
        "body" : "> i suppose you could walk up the tree from the root and check the opcode or metadata.\r\n\r\nYes, see hlo_matchers.h.",
        "createdAt" : "2018-06-07T22:50:09Z",
        "updatedAt" : "2018-06-07T22:53:28Z",
        "lastEditedBy" : "845afb08-ba85-462c-92e8-305877b05a5d",
        "tags" : [
        ]
      }
    ],
    "commit" : "76b5f2093f53d30e1a623309891c1e38f9ea8d9a",
    "line" : 17,
    "diffHunk" : "@@ -1,1 +218,222 @@}\n\nTEST_F(TupleSimplifierTest, CanExcludeEntryComputation) {\n  //  Verify that the root computation can be excluded\n  auto module = CreateNewModule();"
  },
  {
    "id" : "4052cc73-1626-40fe-a00c-240abdf89dd0",
    "prId" : 19769,
    "prUrl" : "https://github.com/tensorflow/tensorflow/pull/19769#pullrequestreview-126935171",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "079c1e06-e5b1-44d5-9287-a5d472c98b24",
        "parentId" : null,
        "authorId" : "845afb08-ba85-462c-92e8-305877b05a5d",
        "body" : "Nit, move this comment up one line?",
        "createdAt" : "2018-06-07T16:29:01Z",
        "updatedAt" : "2018-06-07T20:04:21Z",
        "lastEditedBy" : "845afb08-ba85-462c-92e8-305877b05a5d",
        "tags" : [
        ]
      },
      {
        "id" : "a7af1858-cc37-429f-bd41-0ac123ed7e70",
        "parentId" : "079c1e06-e5b1-44d5-9287-a5d472c98b24",
        "authorId" : "8b6d0937-a9aa-4efc-8d2e-f3224f679760",
        "body" : "the other tests in the file seem to have their comments following the test declaration.  i think it is best to leave it here.",
        "createdAt" : "2018-06-07T20:01:08Z",
        "updatedAt" : "2018-06-07T20:04:21Z",
        "lastEditedBy" : "8b6d0937-a9aa-4efc-8d2e-f3224f679760",
        "tags" : [
        ]
      }
    ],
    "commit" : "76b5f2093f53d30e1a623309891c1e38f9ea8d9a",
    "line" : 18,
    "diffHunk" : "@@ -1,1 +219,223 @@\nTEST_F(TupleSimplifierTest, CanExcludeEntryComputation) {\n  //  Verify that the root computation can be excluded\n  auto module = CreateNewModule();\n"
  },
  {
    "id" : "13025d55-686a-4043-8329-930766a40732",
    "prId" : 19769,
    "prUrl" : "https://github.com/tensorflow/tensorflow/pull/19769#pullrequestreview-126983660",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "280eec6c-1166-45ff-9121-612e07269e42",
        "parentId" : null,
        "authorId" : "845afb08-ba85-462c-92e8-305877b05a5d",
        "body" : "Our style is no space between end of the comment and `true`.\r\n\r\n(Sorry...  :-/  I believe clang-format will catch this, and it looks like we have open-sourced a `.clang-format` file for XLA.  If you use clang-format it's very important to configure it only to format the lines you actually changed.  Otherwise you'll have tons of spurious whitespace changes to the file -- its format is not stable.  The git-clang-format script in LLVM is one way to do this.  https://github.com/llvm-mirror/clang/blob/master/tools/clang-format/git-clang-format)",
        "createdAt" : "2018-06-07T22:52:44Z",
        "updatedAt" : "2018-06-07T22:53:28Z",
        "lastEditedBy" : "845afb08-ba85-462c-92e8-305877b05a5d",
        "tags" : [
        ]
      }
    ],
    "commit" : "76b5f2093f53d30e1a623309891c1e38f9ea8d9a",
    "line" : 81,
    "diffHunk" : "@@ -1,1 +282,286 @@  }\n\n  Run(module.get(), /*change_expected=*/true, /*exclude_entry=*/ true);\n\n  EXPECT_THAT(c0->root_instruction(), p0);"
  }
]
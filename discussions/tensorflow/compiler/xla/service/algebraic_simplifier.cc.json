[
  {
    "id" : "ddea41ab-647f-4011-85bd-4be8d966cdec",
    "prId" : 34284,
    "prUrl" : "https://github.com/tensorflow/tensorflow/pull/34284#pullrequestreview-320191927",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6ea61f93-8965-4a45-b552-ea1838004a56",
        "parentId" : null,
        "authorId" : "90c49754-7917-45e3-8dd2-8e09527f3d4c",
        "body" : "NIT: calling it IsNonNegative is more proper, because x*x could be 0 or NAN. ",
        "createdAt" : "2019-11-20T18:46:29Z",
        "updatedAt" : "2019-12-12T04:54:38Z",
        "lastEditedBy" : "90c49754-7917-45e3-8dd2-8e09527f3d4c",
        "tags" : [
        ]
      }
    ],
    "commit" : "a26afaa73334e0b2cb0f324ae2f11b575fec22ce",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +90,94 @@}\n\nbool IsPositive(const HloInstruction* hlo,\n                const AlgebraicSimplifierOptions& options) {\n  // Utility only handles real types."
  },
  {
    "id" : "be3ba278-994c-4898-a60f-9e0f317f1e7e",
    "prId" : 34284,
    "prUrl" : "https://github.com/tensorflow/tensorflow/pull/34284#pullrequestreview-320191927",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b4c98c10-a053-449e-90c7-3eb622ddc622",
        "parentId" : null,
        "authorId" : "90c49754-7917-45e3-8dd2-8e09527f3d4c",
        "body" : "When A is negative, rsqrt(A) is NAN but 1/A is not. For this reason, you need to check that A is non-negative.",
        "createdAt" : "2019-11-20T19:04:24Z",
        "updatedAt" : "2019-12-12T04:54:38Z",
        "lastEditedBy" : "90c49754-7917-45e3-8dd2-8e09527f3d4c",
        "tags" : [
        ]
      }
    ],
    "commit" : "a26afaa73334e0b2cb0f324ae2f11b575fec22ce",
    "line" : 165,
    "diffHunk" : "@@ -1,1 +2228,2232 @@        multiply,\n        HloInstruction::CreateBinary(multiply->shape(), HloOpcode::kDivide,\n                                     MakeScalarLike(b, 1), b));\n  }\n"
  },
  {
    "id" : "a08cecfb-7d42-4e05-8cc7-d41940f51905",
    "prId" : 34284,
    "prUrl" : "https://github.com/tensorflow/tensorflow/pull/34284#pullrequestreview-320191927",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "544818ae-9960-4576-a2fb-8d5631f780d7",
        "parentId" : null,
        "authorId" : "90c49754-7917-45e3-8dd2-8e09527f3d4c",
        "body" : "In tensorflow, 1/0 = NAN, see https://www.tensorflow.org/api_docs/python/tf/math/divide_no_nan\r\nAs such, when A is 0,  the result for the original expression is NAN, but 0 for the transformed expression.",
        "createdAt" : "2019-11-20T19:20:12Z",
        "updatedAt" : "2019-12-12T04:54:38Z",
        "lastEditedBy" : "90c49754-7917-45e3-8dd2-8e09527f3d4c",
        "tags" : [
        ]
      }
    ],
    "commit" : "a26afaa73334e0b2cb0f324ae2f11b575fec22ce",
    "line" : 194,
    "diffHunk" : "@@ -1,1 +3397,3401 @@    return ReplaceWithNewInstruction(\n        rsqrt, HloInstruction::CreateUnary(rsqrt->shape(), HloOpcode::kSqrt,\n                                           rsqrt_operand->mutable_operand(1)));\n  }\n"
  },
  {
    "id" : "899720e3-ca6f-41ab-9e46-99a737e1d24c",
    "prId" : 34284,
    "prUrl" : "https://github.com/tensorflow/tensorflow/pull/34284#pullrequestreview-323131184",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "00abb421-b331-4380-85cb-2493dd9f67a0",
        "parentId" : null,
        "authorId" : "90c49754-7917-45e3-8dd2-8e09527f3d4c",
        "body" : "The log message uses A but the code uses b. It would be nice if you can fix this to make the code matches the log message and the comment, for here and other places in routine HandleMultiply. See an example in the same routine, the code for \"trying transform [(A * C1) * C2 => A * (C1 * C2)]\" matches the log message.",
        "createdAt" : "2019-11-26T16:46:26Z",
        "updatedAt" : "2019-12-12T04:54:38Z",
        "lastEditedBy" : "90c49754-7917-45e3-8dd2-8e09527f3d4c",
        "tags" : [
        ]
      }
    ],
    "commit" : "a26afaa73334e0b2cb0f324ae2f11b575fec22ce",
    "line" : 159,
    "diffHunk" : "@@ -1,1 +2222,2226 @@  VLOG(10) << \"trying transform [rsqrt(B) * rsqrt(B) => 1/B] \"\n           << multiply->ToString();\n  HloInstruction* b;\n  if (Match(multiply, m::Multiply(m::Rsqrt(m::Op(&b)), m::Rsqrt(m::Op(&b)))) &&\n      IsPositive(b, options_)) {"
  },
  {
    "id" : "824de453-f313-4698-b4ad-e65bd45eab02",
    "prId" : 34284,
    "prUrl" : "https://github.com/tensorflow/tensorflow/pull/34284#pullrequestreview-323933291",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ee7aeafe-c5be-4948-85bc-4417b9a0f34c",
        "parentId" : null,
        "authorId" : "90c49754-7917-45e3-8dd2-8e09527f3d4c",
        "body" : "Shall we rename rsqrt_operand to a to match the message?",
        "createdAt" : "2019-11-26T16:53:24Z",
        "updatedAt" : "2019-12-12T04:54:38Z",
        "lastEditedBy" : "90c49754-7917-45e3-8dd2-8e09527f3d4c",
        "tags" : [
        ]
      },
      {
        "id" : "a03eb00d-6eb1-44b7-874d-ce8bf99d7ccd",
        "parentId" : "ee7aeafe-c5be-4948-85bc-4417b9a0f34c",
        "authorId" : "f5ab3aa4-6485-4b22-bd3b-5e0b0fefe39b",
        "body" : "`rsqrt_operand` here is not `A` but `Pow`. Do you want me to change `rsqrt_operand` to something like `pow`? But in that case, it might be misleading since `rsqrt`'s operand may or may not be `Pow`. Sorry if I misunderstood your comment.",
        "createdAt" : "2019-11-27T19:13:43Z",
        "updatedAt" : "2019-12-12T04:54:38Z",
        "lastEditedBy" : "f5ab3aa4-6485-4b22-bd3b-5e0b0fefe39b",
        "tags" : [
        ]
      },
      {
        "id" : "8a529cf9-36cf-4f69-a577-d9c85c97d006",
        "parentId" : "ee7aeafe-c5be-4948-85bc-4417b9a0f34c",
        "authorId" : "90c49754-7917-45e3-8dd2-8e09527f3d4c",
        "body" : "I mis-read the code, rsqrt_operand is fine.",
        "createdAt" : "2019-11-27T20:37:08Z",
        "updatedAt" : "2019-12-12T04:54:38Z",
        "lastEditedBy" : "90c49754-7917-45e3-8dd2-8e09527f3d4c",
        "tags" : [
        ]
      }
    ],
    "commit" : "a26afaa73334e0b2cb0f324ae2f11b575fec22ce",
    "line" : 178,
    "diffHunk" : "@@ -1,1 +3381,3385 @@  VLOG(10) << \"trying transform [rsqrt(Pow(A, -2)) => |A|] \"\n           << rsqrt->ToString();\n  HloInstruction* rsqrt_operand = rsqrt->mutable_operand(0);\n  if (rsqrt_operand->opcode() == HloOpcode::kPower &&\n      IsAll(rsqrt_operand->operand(1), -2) &&"
  },
  {
    "id" : "85df7f20-73bc-43b5-9335-377dc6f25eec",
    "prId" : 34284,
    "prUrl" : "https://github.com/tensorflow/tensorflow/pull/34284#pullrequestreview-323131184",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e02ebdaa-3604-4637-8512-1b0099573264",
        "parentId" : null,
        "authorId" : "90c49754-7917-45e3-8dd2-8e09527f3d4c",
        "body" : "Similar to the above, rename sqrt_operand to a.",
        "createdAt" : "2019-11-26T16:54:23Z",
        "updatedAt" : "2019-12-12T04:54:38Z",
        "lastEditedBy" : "90c49754-7917-45e3-8dd2-8e09527f3d4c",
        "tags" : [
        ]
      }
    ],
    "commit" : "a26afaa73334e0b2cb0f324ae2f11b575fec22ce",
    "line" : 209,
    "diffHunk" : "@@ -1,1 +3889,3893 @@Status AlgebraicSimplifierVisitor::HandleSqrt(HloInstruction* sqrt) {\n  VLOG(10) << \"trying transform [sqrt(A*A) => |A|] \" << sqrt->ToString();\n  HloInstruction* sqrt_operand = sqrt->mutable_operand(0);\n  if (sqrt_operand->opcode() == HloOpcode::kMultiply &&\n      sqrt_operand->operand(0) == sqrt_operand->operand(1)) {"
  },
  {
    "id" : "81862b59-314c-4e8e-bbd5-40e9dba324a7",
    "prId" : 34284,
    "prUrl" : "https://github.com/tensorflow/tensorflow/pull/34284#pullrequestreview-329971255",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4a60c45f-da89-4ee5-8a53-851c67c249fe",
        "parentId" : null,
        "authorId" : "90c49754-7917-45e3-8dd2-8e09527f3d4c",
        "body" : "For kMultiply, we need to make sure that the operand is not a complex number.",
        "createdAt" : "2019-12-09T03:49:04Z",
        "updatedAt" : "2019-12-12T04:54:38Z",
        "lastEditedBy" : "90c49754-7917-45e3-8dd2-8e09527f3d4c",
        "tags" : [
        ]
      },
      {
        "id" : "a7b00e4c-e2f9-439f-a2d4-96d9d51d6e5e",
        "parentId" : "4a60c45f-da89-4ee5-8a53-851c67c249fe",
        "authorId" : "f5ab3aa4-6485-4b22-bd3b-5e0b0fefe39b",
        "body" : "Infact, in that this case we should handle all cases when the operands are complex i.e, have an assertion that none of the operands can be complex type since `IsPositive` or `IsNonNegative` is not designed to used of Complex dtypes. IMO it would be better to have assertions to not allow complex.",
        "createdAt" : "2019-12-10T02:24:34Z",
        "updatedAt" : "2019-12-12T04:54:38Z",
        "lastEditedBy" : "f5ab3aa4-6485-4b22-bd3b-5e0b0fefe39b",
        "tags" : [
        ]
      },
      {
        "id" : "1ddeca9c-18a0-4f47-b87c-709527d024bd",
        "parentId" : "4a60c45f-da89-4ee5-8a53-851c67c249fe",
        "authorId" : "f5ab3aa4-6485-4b22-bd3b-5e0b0fefe39b",
        "body" : "Just to clarify, would you prefer an assertion when `IsPositive` or `IsNonNegative` is called with complex args or return false?",
        "createdAt" : "2019-12-10T14:16:58Z",
        "updatedAt" : "2019-12-12T04:54:38Z",
        "lastEditedBy" : "f5ab3aa4-6485-4b22-bd3b-5e0b0fefe39b",
        "tags" : [
        ]
      },
      {
        "id" : "4fde0e0b-613e-4f2d-9992-b0c3a8716163",
        "parentId" : "4a60c45f-da89-4ee5-8a53-851c67c249fe",
        "authorId" : "90c49754-7917-45e3-8dd2-8e09527f3d4c",
        "body" : "It can just return false.",
        "createdAt" : "2019-12-10T16:28:23Z",
        "updatedAt" : "2019-12-12T04:54:38Z",
        "lastEditedBy" : "90c49754-7917-45e3-8dd2-8e09527f3d4c",
        "tags" : [
        ]
      }
    ],
    "commit" : "a26afaa73334e0b2cb0f324ae2f11b575fec22ce",
    "line" : 56,
    "diffHunk" : "@@ -1,1 +133,137 @@  switch (hlo->opcode()) {\n    case HloOpcode::kMultiply: {\n      return hlo->operand(0) == hlo->operand(1);\n    }\n    case HloOpcode::kAbs: {"
  },
  {
    "id" : "cdbba3b7-c528-48d6-b39f-4ebad444d2bc",
    "prId" : 34284,
    "prUrl" : "https://github.com/tensorflow/tensorflow/pull/34284#pullrequestreview-329556038",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f97a48b5-c52b-4ab7-9498-e6a4ceeca13e",
        "parentId" : null,
        "authorId" : "90c49754-7917-45e3-8dd2-8e09527f3d4c",
        "body" : "For kPower, we need to make sure that the second operand is not a complex number, right?",
        "createdAt" : "2019-12-09T03:56:34Z",
        "updatedAt" : "2019-12-12T04:54:38Z",
        "lastEditedBy" : "90c49754-7917-45e3-8dd2-8e09527f3d4c",
        "tags" : [
        ]
      },
      {
        "id" : "b22b7b6c-2f86-4f1a-a7fc-eed5d4dabb91",
        "parentId" : "f97a48b5-c52b-4ab7-9498-e6a4ceeca13e",
        "authorId" : "f5ab3aa4-6485-4b22-bd3b-5e0b0fefe39b",
        "body" : "yea...looks like TF 2.0 allows complex for both operands. Not sure abt the semantics of TF 1.0 though. Anyway, I'll mk the change. ",
        "createdAt" : "2019-12-10T02:06:28Z",
        "updatedAt" : "2019-12-12T04:54:38Z",
        "lastEditedBy" : "f5ab3aa4-6485-4b22-bd3b-5e0b0fefe39b",
        "tags" : [
        ]
      },
      {
        "id" : "11a7b59a-3bd3-46e1-995a-d07898c5f3e8",
        "parentId" : "f97a48b5-c52b-4ab7-9498-e6a4ceeca13e",
        "authorId" : "f5ab3aa4-6485-4b22-bd3b-5e0b0fefe39b",
        "body" : "Even operand(0) should not be complex. Only a pure imaginary number can generate a real number (that too negative). So it doesn't make sense to allow any operand to be complex. ",
        "createdAt" : "2019-12-10T02:26:45Z",
        "updatedAt" : "2019-12-12T04:54:38Z",
        "lastEditedBy" : "f5ab3aa4-6485-4b22-bd3b-5e0b0fefe39b",
        "tags" : [
        ]
      }
    ],
    "commit" : "a26afaa73334e0b2cb0f324ae2f11b575fec22ce",
    "line" : 33,
    "diffHunk" : "@@ -1,1 +110,114 @@      }\n    }\n    case HloOpcode::kPower:\n    case HloOpcode::kAbs:\n    case HloOpcode::kRsqrt:"
  },
  {
    "id" : "43d33c33-85d1-4753-bb4e-3cd553f2fad7",
    "prId" : 34284,
    "prUrl" : "https://github.com/tensorflow/tensorflow/pull/34284#pullrequestreview-332552065",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "057c47fb-f9cd-4b02-9a79-3b52e824763f",
        "parentId" : null,
        "authorId" : "90c49754-7917-45e3-8dd2-8e09527f3d4c",
        "body" : " abs(x) is always NonNegative, right?",
        "createdAt" : "2019-12-14T22:31:53Z",
        "updatedAt" : "2019-12-14T22:35:57Z",
        "lastEditedBy" : "90c49754-7917-45e3-8dd2-8e09527f3d4c",
        "tags" : [
        ]
      },
      {
        "id" : "4607fbf1-89b7-4b14-b5c4-caed4b2d5f2f",
        "parentId" : "057c47fb-f9cd-4b02-9a79-3b52e824763f",
        "authorId" : "f5ab3aa4-6485-4b22-bd3b-5e0b0fefe39b",
        "body" : "Does abs(x) functionally produce a modulus value in TF? How is abs of cmplx handled in xla? I wasn’t sure so stuck to handling real values only.",
        "createdAt" : "2019-12-15T02:35:34Z",
        "updatedAt" : "2019-12-15T02:35:34Z",
        "lastEditedBy" : "f5ab3aa4-6485-4b22-bd3b-5e0b0fefe39b",
        "tags" : [
        ]
      },
      {
        "id" : "561da39f-be36-4b44-a537-62bbce5a720a",
        "parentId" : "057c47fb-f9cd-4b02-9a79-3b52e824763f",
        "authorId" : "90c49754-7917-45e3-8dd2-8e09527f3d4c",
        "body" : "I think so. You can check the implementation of  ElementalIrEmitter::EmitComplexAbs.",
        "createdAt" : "2019-12-16T13:06:00Z",
        "updatedAt" : "2019-12-16T13:06:10Z",
        "lastEditedBy" : "90c49754-7917-45e3-8dd2-8e09527f3d4c",
        "tags" : [
        ]
      }
    ],
    "commit" : "a26afaa73334e0b2cb0f324ae2f11b575fec22ce",
    "line" : 51,
    "diffHunk" : "@@ -1,1 +128,132 @@                   const AlgebraicSimplifierOptions& options) {\n  // Utility only handles real types.\n  if (IsAnyOperandComplex(hlo)) {\n    return false;\n  }"
  },
  {
    "id" : "4f22f294-9ac0-4a1c-a5bd-3aec9014ec19",
    "prId" : 32435,
    "prUrl" : "https://github.com/tensorflow/tensorflow/pull/32435#pullrequestreview-287617602",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3c8172bf-9f53-4eef-ba79-02e69468e294",
        "parentId" : null,
        "authorId" : "2861a495-42d5-4ac3-b543-23cf14c0a980",
        "body" : "I'd be a bit paranoid here and add `CHECK` that the inner instruction is also a `kConvert`.",
        "createdAt" : "2019-09-11T21:44:25Z",
        "updatedAt" : "2019-09-12T22:49:59Z",
        "lastEditedBy" : "2861a495-42d5-4ac3-b543-23cf14c0a980",
        "tags" : [
        ]
      },
      {
        "id" : "083f3b0d-1ab8-4be2-82cc-b8ae7b4aa754",
        "parentId" : "3c8172bf-9f53-4eef-ba79-02e69468e294",
        "authorId" : "f5ab3aa4-6485-4b22-bd3b-5e0b0fefe39b",
        "body" : "Done",
        "createdAt" : "2019-09-12T18:19:42Z",
        "updatedAt" : "2019-09-12T22:49:59Z",
        "lastEditedBy" : "f5ab3aa4-6485-4b22-bd3b-5e0b0fefe39b",
        "tags" : [
        ]
      }
    ],
    "commit" : "7c35032a8b08973355da67ec7b224bfbe074ae38",
    "line" : 8,
    "diffHunk" : "@@ -1,1 +171,175 @@  //    [operand_convert]         [convert]\n  // (src)->convert-(intermediate)->convert-(dest)\n  const HloInstruction* operand_convert = convert->operand(0);\n  CHECK_EQ(operand_convert->opcode(), HloOpcode::kConvert);\n  const Shape& src_shape = operand_convert->operand(0)->shape();"
  },
  {
    "id" : "d5e0365e-b7da-43f7-bcf8-20ed89893743",
    "prId" : 28583,
    "prUrl" : "https://github.com/tensorflow/tensorflow/pull/28583#pullrequestreview-236166193",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c5c2f4cc-6579-4a6a-b822-e95b7959573a",
        "parentId" : null,
        "authorId" : "845afb08-ba85-462c-92e8-305877b05a5d",
        "body" : "I believe this is `IsIdentityPermutation` in util.cc",
        "createdAt" : "2019-05-10T13:18:43Z",
        "updatedAt" : "2019-05-10T13:19:14Z",
        "lastEditedBy" : "845afb08-ba85-462c-92e8-305877b05a5d",
        "tags" : [
        ]
      },
      {
        "id" : "7d676d7c-b423-4ca4-a40c-e7173f82253b",
        "parentId" : "c5c2f4cc-6579-4a6a-b822-e95b7959573a",
        "authorId" : "5932f8f3-3e0d-4c91-8a75-577172a665f7",
        "body" : "They are not exactly the same though. IsIdentityPermutation is is_iota plus the first element is 0. But we don't require the first element to be 0 here.",
        "createdAt" : "2019-05-10T14:57:18Z",
        "updatedAt" : "2019-05-10T14:57:18Z",
        "lastEditedBy" : "5932f8f3-3e0d-4c91-8a75-577172a665f7",
        "tags" : [
        ]
      },
      {
        "id" : "98e632b0-263b-4801-b82e-93ef2c699649",
        "parentId" : "c5c2f4cc-6579-4a6a-b822-e95b7959573a",
        "authorId" : "5932f8f3-3e0d-4c91-8a75-577172a665f7",
        "body" : "Or I can do something like this\r\n```\r\nstd::vector<int64> temp_lhs_contracting_dims;\r\nfor (auto dim : lhs_contracting_dims) {\r\n  temp_lhs_contracting_dims.push_bakc(dim - lhs_contracting_dims[0])\r\n}\r\nif (!IsIdentityPermutation(temp_lhs_contracting_dims) {\r\n  return nullptr;\r\n}\r\n```",
        "createdAt" : "2019-05-10T15:15:43Z",
        "updatedAt" : "2019-05-10T15:16:00Z",
        "lastEditedBy" : "5932f8f3-3e0d-4c91-8a75-577172a665f7",
        "tags" : [
        ]
      },
      {
        "id" : "2c8a74aa-95aa-4320-af2d-77e5ccc9efa3",
        "parentId" : "c5c2f4cc-6579-4a6a-b822-e95b7959573a",
        "authorId" : "845afb08-ba85-462c-92e8-305877b05a5d",
        "body" : "Oh, my bad!  This is fine.",
        "createdAt" : "2019-05-10T15:21:23Z",
        "updatedAt" : "2019-05-10T15:21:23Z",
        "lastEditedBy" : "845afb08-ba85-462c-92e8-305877b05a5d",
        "tags" : [
        ]
      }
    ],
    "commit" : "a4778b013809219ac44f755a6fabfe746c734cbc",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +1583,1587 @@  }\n  // We require the \"unsquished\" lhs contracting dims to be consecutive.\n  auto is_iota = [](absl::Span<const int64> dims) {\n    return absl::c_adjacent_find(dims, [](const int64 a, const int64 b) {\n             return (b != a + 1);"
  },
  {
    "id" : "bd97ae12-ba23-44bf-ac3e-20df5c3d7023",
    "prId" : 28170,
    "prUrl" : "https://github.com/tensorflow/tensorflow/pull/28170#pullrequestreview-231234441",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b3b2d9c3-6569-42c6-9a0d-7b66934d6d53",
        "parentId" : null,
        "authorId" : "845afb08-ba85-462c-92e8-305877b05a5d",
        "body" : "If we pull the vectors `lhs_contracting_dims` and `rhs_contracting_dims` below this if statement, then we can simply do\r\n\r\n```\r\n// Comment explaining why we're pulling these into vectors, I am still not sure what is the problem this solves, it seems to be more complex to have two copies of one piece of data?\r\nstd::vector<int64> lhs_contracting_dims = {dnums.lhs_contracting_dims[0]};\r\n```",
        "createdAt" : "2019-04-26T18:44:30Z",
        "updatedAt" : "2019-04-26T23:01:29Z",
        "lastEditedBy" : "845afb08-ba85-462c-92e8-305877b05a5d",
        "tags" : [
        ]
      }
    ],
    "commit" : "e7f555ded70ed0c6a2bb8adbc85c7e2c21abc31c",
    "line" : 45,
    "diffHunk" : "@@ -1,1 +1534,1538 @@  // Require single contracting dim to make the implementation easier to\n  // track contracting dims.\n  if (dnums.lhs_contracting_dimensions_size() != 1) {\n    return nullptr;\n  }"
  }
]
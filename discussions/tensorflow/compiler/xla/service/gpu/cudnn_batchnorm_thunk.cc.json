[
  {
    "id" : "c2582e76-155c-4c85-aaeb-94fae54bae02",
    "prId" : 32887,
    "prUrl" : "https://github.com/tensorflow/tensorflow/pull/32887#pullrequestreview-299768247",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "da012517-11fc-45e3-a1fb-d8b63311a2fd",
        "parentId" : null,
        "authorId" : "2861a495-42d5-4ac3-b543-23cf14c0a980",
        "body" : "It might be more readable (although also more verbose) to just switch on the various kinds of batchnorms to make the check more obvious.  E.g. we want to easily read out the supported configs for  forward inference batchnorm.",
        "createdAt" : "2019-10-08T20:32:52Z",
        "updatedAt" : "2019-10-10T18:08:48Z",
        "lastEditedBy" : "2861a495-42d5-4ac3-b543-23cf14c0a980",
        "tags" : [
        ]
      },
      {
        "id" : "20704900-894a-471c-b1c5-df5bc32d8347",
        "parentId" : "da012517-11fc-45e3-a1fb-d8b63311a2fd",
        "authorId" : "f5ab3aa4-6485-4b22-bd3b-5e0b0fefe39b",
        "body" : "I can do that but do think that is absolutely necessary? Using `Switch-Case` would make it quite verbose and require replication of similar conditions in each case. Also I would still need to carry around the `operand(0)` primitive type anyway to compare within each case. I can add more comments if you think that can help. Please let me know. I can convert this to `Switch-Case` if you that would be helpful.",
        "createdAt" : "2019-10-09T18:20:56Z",
        "updatedAt" : "2019-10-10T18:08:48Z",
        "lastEditedBy" : "f5ab3aa4-6485-4b22-bd3b-5e0b0fefe39b",
        "tags" : [
        ]
      },
      {
        "id" : "4f1ceaac-266e-42c3-8433-932cbc65050a",
        "parentId" : "da012517-11fc-45e3-a1fb-d8b63311a2fd",
        "authorId" : "2861a495-42d5-4ac3-b543-23cf14c0a980",
        "body" : "> do think that is absolutely necessary?\r\n\r\nNo. :) I'm happy to trust your judgement here.\r\n\r\n> I can add more comments if you think that can help.\r\n\r\nThe main readability concern I have is that it isn't obvious from reading the code (for instance) what types we allow for a backward batchnorm op.  If you can refactor the code or add comments to make this obvious some other way that's fine by me.",
        "createdAt" : "2019-10-09T20:32:35Z",
        "updatedAt" : "2019-10-10T18:08:48Z",
        "lastEditedBy" : "2861a495-42d5-4ac3-b543-23cf14c0a980",
        "tags" : [
        ]
      },
      {
        "id" : "fe069885-ee98-4aa3-ac68-c452dfc01741",
        "parentId" : "da012517-11fc-45e3-a1fb-d8b63311a2fd",
        "authorId" : "f5ab3aa4-6485-4b22-bd3b-5e0b0fefe39b",
        "body" : "Does this look OK for a description comment in `CheckInputOutputPrimitivetypeIsValid`\r\n\r\n```\r\n  // All input and output statistics variables must be F32. Also, the last\r\n  // operand for CudnnBatchNormForwardInference, CudnnBatchNormForwardTraining,\r\n  // and CudnnBatchNormBackward is the feature_index which must be S64. Apart\r\n  // from this, the type constraints are as follows:\r\n  // CudnnBatchNormForwardInference:\r\n  //            operand[0]: (U: {half, float})\r\n  //                out[0]: (U: {half, float})\r\n  // CudnnBatchNormForwardTraining:\r\n  //            operand[0]: (U: {half, float})\r\n  //                out[0]: (U: {half, float})\r\n  // CudnnBatchNormBackward:\r\n  //            operand[0]: (U: {half, float})\r\n  //            operand[4]: (U: {half, float})\r\n  //                out[0]: (U: {half, float})\r\n  // Note that each type 'U' should be the same for each type of batchnorm\r\n  // thunk.\r\n```",
        "createdAt" : "2019-10-09T21:29:54Z",
        "updatedAt" : "2019-10-10T18:08:48Z",
        "lastEditedBy" : "f5ab3aa4-6485-4b22-bd3b-5e0b0fefe39b",
        "tags" : [
        ]
      },
      {
        "id" : "383de9b4-e381-44c8-b832-f16fe8105e8c",
        "parentId" : "da012517-11fc-45e3-a1fb-d8b63311a2fd",
        "authorId" : "f5ab3aa4-6485-4b22-bd3b-5e0b0fefe39b",
        "body" : "I pushed a modified version of the above comment block. Hopefully this works. Please take a look.",
        "createdAt" : "2019-10-10T00:37:46Z",
        "updatedAt" : "2019-10-10T18:08:48Z",
        "lastEditedBy" : "f5ab3aa4-6485-4b22-bd3b-5e0b0fefe39b",
        "tags" : [
        ]
      }
    ],
    "commit" : "213f36984b105105e359cb3822d4118c2c1dbba6",
    "line" : 60,
    "diffHunk" : "@@ -1,1 +58,62 @@      << \"Not yet implemented\";\n\n  for (int i = 1; i < num_operands - 2; i++) {\n    if (hlo->custom_call_target() == kCudnnBatchNormBackwardCallTarget &&\n        i == 4) {"
  }
]
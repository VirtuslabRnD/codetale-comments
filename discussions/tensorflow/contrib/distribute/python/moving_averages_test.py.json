[
  {
    "id" : "eb689eb0-bf30-4132-a50e-b3b44be8aefc",
    "prId" : 23396,
    "prUrl" : "https://github.com/tensorflow/tensorflow/pull/23396#pullrequestreview-170774910",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1bdc8e89-a082-4039-9e8a-0a7fff5ea802",
        "parentId" : null,
        "authorId" : "b6846163-3059-4fef-a4dd-13d374440a66",
        "body" : "Is this case common in your use cases? The update value to moving average is usually different across different replicas. If it is a MirroredVariable, then their components are always in sync and it is not necessary run all-reduce.",
        "createdAt" : "2018-11-01T02:39:40Z",
        "updatedAt" : "2018-11-29T14:24:54Z",
        "lastEditedBy" : "b6846163-3059-4fef-a4dd-13d374440a66",
        "tags" : [
        ]
      },
      {
        "id" : "0a6e3055-365b-45ad-a58f-f4ded3ca589b",
        "parentId" : "1bdc8e89-a082-4039-9e8a-0a7fff5ea802",
        "authorId" : "e245094f-d7be-4c83-a431-fa2de6b8274b",
        "body" : "You are right, here we exactly consider the case when the input value is MirroredVariable, while the original codebase cannot accept `Mirrored` type as it will trigger MirroredStrategy._reduce's [assert error](https://github.com/tensorflow/tensorflow/blob/master/tensorflow/contrib/distribute/python/mirrored_strategy.py#L618). So this PR kindly fix this bug by adding a convert before calling into `_reduce`. ",
        "createdAt" : "2018-11-01T02:53:52Z",
        "updatedAt" : "2018-11-29T14:24:54Z",
        "lastEditedBy" : "e245094f-d7be-4c83-a431-fa2de6b8274b",
        "tags" : [
        ]
      },
      {
        "id" : "0644a9ce-92fe-40ed-891b-7b70552aa10e",
        "parentId" : "1bdc8e89-a082-4039-9e8a-0a7fff5ea802",
        "authorId" : "abc0dd3d-b45b-4ef4-bce0-f25e45b62885",
        "body" : "Yuefeng is saying this is not the right fix; it avoids triggering the assert without fixing the underlying issue it was trying to prevent. It is possible we should make \"reduce mean\" into a no-op for mirrored values, which would fix this issue.",
        "createdAt" : "2018-11-01T15:54:23Z",
        "updatedAt" : "2018-11-29T14:24:54Z",
        "lastEditedBy" : "abc0dd3d-b45b-4ef4-bce0-f25e45b62885",
        "tags" : [
        ]
      },
      {
        "id" : "8e5ab11c-bf4c-4937-955b-53d92dd41408",
        "parentId" : "1bdc8e89-a082-4039-9e8a-0a7fff5ea802",
        "authorId" : "e245094f-d7be-4c83-a431-fa2de6b8274b",
        "body" : "@josh11b Thanks for your explanation, it makes sense. The code has been modified accordingly.",
        "createdAt" : "2018-11-01T16:47:02Z",
        "updatedAt" : "2018-11-29T14:24:54Z",
        "lastEditedBy" : "e245094f-d7be-4c83-a431-fa2de6b8274b",
        "tags" : [
        ]
      }
    ],
    "commit" : "d00013e72cd3a1a4805395eb8e66748dcf387295",
    "line" : 9,
    "diffHunk" : "@@ -1,1 +145,149 @@      var = variables.Variable([10.0, 11.0])\n      # Here we expect to check the case when input value are variable.\n      val = variables.Variable([1., 2.])\n      decay = 0.25\n      assign = moving_averages.assign_moving_average("
  }
]
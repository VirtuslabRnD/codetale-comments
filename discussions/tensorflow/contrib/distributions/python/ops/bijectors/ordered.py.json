[
  {
    "id" : "0df1006c-aba5-45f3-b3b2-636510113dc7",
    "prId" : 18647,
    "prUrl" : "https://github.com/tensorflow/tensorflow/pull/18647#pullrequestreview-114026498",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "dac66768-1b7c-4ffd-a168-31a95b2f7369",
        "parentId" : null,
        "authorId" : "bd2885c6-4102-477a-8e00-825f8cb18e6d",
        "body" : "Is it possible to write the explicit domain and codomain (might make it easier for a user to see when to apply this)? This is also useful since in the future we might be annotation distributions / bijectors with supports and it would be easier to do this from looking at the doc string.",
        "createdAt" : "2018-04-20T14:31:28Z",
        "updatedAt" : "2018-04-25T17:01:45Z",
        "lastEditedBy" : "bd2885c6-4102-477a-8e00-825f8cb18e6d",
        "tags" : [
        ]
      },
      {
        "id" : "ddd7dca6-7886-46d9-8f39-2be5574edc4a",
        "parentId" : "dac66768-1b7c-4ffd-a168-31a95b2f7369",
        "authorId" : "93a2def4-6366-45b9-a0d0-e587da4c7ff3",
        "body" : "Both the domain and codomain is R_k, however, in practice, the inverse mapping usually apply on y~Normal(0, 1), as y_k too large will cause overflow in exp(y_k).\r\n\r\nShould I add the above to the description? ",
        "createdAt" : "2018-04-20T15:31:50Z",
        "updatedAt" : "2018-04-25T17:01:45Z",
        "lastEditedBy" : "93a2def4-6366-45b9-a0d0-e587da4c7ff3",
        "tags" : [
        ]
      },
      {
        "id" : "f815c9fb-37fa-430c-b8a1-f37ff4bca2f9",
        "parentId" : "dac66768-1b7c-4ffd-a168-31a95b2f7369",
        "authorId" : "bd2885c6-4102-477a-8e00-825f8cb18e6d",
        "body" : "Right, but the domain is a little bit more restrictive (which is what the assert below captures). Just want to explicitly codify the assert here.",
        "createdAt" : "2018-04-20T15:35:49Z",
        "updatedAt" : "2018-04-25T17:01:45Z",
        "lastEditedBy" : "bd2885c6-4102-477a-8e00-825f8cb18e6d",
        "tags" : [
        ]
      }
    ],
    "commit" : "63f4618fbdd653fd19a3663a64da89c476aeb0cd",
    "line" : 36,
    "diffHunk" : "@@ -1,1 +34,38 @@\nclass Ordered(bijector.Bijector):\n  \"\"\"Bijector which maps a tensor x_k that has increasing elements in the last\n  dimension to an unconstrained tensor y_k.\n"
  },
  {
    "id" : "28b79161-3be8-40ac-a27a-e93c74aeae8f",
    "prId" : 18647,
    "prUrl" : "https://github.com/tensorflow/tensorflow/pull/18647#pullrequestreview-114090138",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ecfbfd0f-0d30-4a97-a5e0-f5c7c00f6286",
        "parentId" : null,
        "authorId" : "bd2885c6-4102-477a-8e00-825f8cb18e6d",
        "body" : "Is there a more specific name we can use here? One worry I have is that Order statistics are also a valid bijector (and might be a thing in the future), and so the names can be confused.",
        "createdAt" : "2018-04-20T14:31:29Z",
        "updatedAt" : "2018-04-25T17:01:45Z",
        "lastEditedBy" : "bd2885c6-4102-477a-8e00-825f8cb18e6d",
        "tags" : [
        ]
      },
      {
        "id" : "c440aedc-5de9-4446-b84e-b48c201f89bd",
        "parentId" : "ecfbfd0f-0d30-4a97-a5e0-f5c7c00f6286",
        "authorId" : "93a2def4-6366-45b9-a0d0-e587da4c7ff3",
        "body" : "I would suggest call this the `Ordered` bijector as it is used similarly in Stan and PyMC3. The other variation of ordered statistics maybe better to call it a `Sorted` bijector?",
        "createdAt" : "2018-04-20T15:27:24Z",
        "updatedAt" : "2018-04-25T17:01:45Z",
        "lastEditedBy" : "93a2def4-6366-45b9-a0d0-e587da4c7ff3",
        "tags" : [
        ]
      },
      {
        "id" : "a2fab7be-dab1-4b48-bc16-c9ea804bc8da",
        "parentId" : "ecfbfd0f-0d30-4a97-a5e0-f5c7c00f6286",
        "authorId" : "bd2885c6-4102-477a-8e00-825f8cb18e6d",
        "body" : "Yeah I guess that is my worry, which is Sorted and Ordered sound very similar (and I wouldn't trust myself to know which one to use :p). If we can make those sound different enough, make it easy for someone new to this stuff understand this bijector, and also make it easy for those using Stan / PyMC3 to know what this is, I'd be happy (I admit  this is an unfair question, in that I haven't provided any suggestions, but am currently thinking about a name, and will post back).",
        "createdAt" : "2018-04-20T15:38:34Z",
        "updatedAt" : "2018-04-25T17:01:45Z",
        "lastEditedBy" : "bd2885c6-4102-477a-8e00-825f8cb18e6d",
        "tags" : [
        ]
      },
      {
        "id" : "50bd7b74-1c15-44da-92e7-5d274387d60c",
        "parentId" : "ecfbfd0f-0d30-4a97-a5e0-f5c7c00f6286",
        "authorId" : "bd2885c6-4102-477a-8e00-825f8cb18e6d",
        "body" : "Actually I was thinking, how about just OrderedLogistic? It's different enough from Order statistics / Logistic, that someone would look up what it contains, and at the same time should be familiar to Stan / PyMC3?",
        "createdAt" : "2018-04-20T18:22:53Z",
        "updatedAt" : "2018-04-25T17:01:45Z",
        "lastEditedBy" : "bd2885c6-4102-477a-8e00-825f8cb18e6d",
        "tags" : [
        ]
      },
      {
        "id" : "e8ca5779-4f7e-4d61-b1e6-2800a4b96a41",
        "parentId" : "ecfbfd0f-0d30-4a97-a5e0-f5c7c00f6286",
        "authorId" : "93a2def4-6366-45b9-a0d0-e587da4c7ff3",
        "body" : "It is not exactly the same thing as Ordered logistic (as in ordered logistic distribution ordered logistic regression) though - The ordered vector returned from this bijector is used to generate ordered logistic regression and ordered probit regression, so I think naming it Ordered bijector shouldnt be too confusing.",
        "createdAt" : "2018-04-20T18:56:51Z",
        "updatedAt" : "2018-04-25T17:01:45Z",
        "lastEditedBy" : "93a2def4-6366-45b9-a0d0-e587da4c7ff3",
        "tags" : [
        ]
      }
    ],
    "commit" : "63f4618fbdd653fd19a3663a64da89c476aeb0cd",
    "line" : 35,
    "diffHunk" : "@@ -1,1 +33,37 @@\n\nclass Ordered(bijector.Bijector):\n  \"\"\"Bijector which maps a tensor x_k that has increasing elements in the last\n  dimension to an unconstrained tensor y_k."
  },
  {
    "id" : "c49fdff8-b2c6-4a7f-bace-851622271f8e",
    "prId" : 18647,
    "prUrl" : "https://github.com/tensorflow/tensorflow/pull/18647#pullrequestreview-113999448",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "12f15f4c-13e0-4512-a818-e64f27b3d0ec",
        "parentId" : null,
        "authorId" : "bd2885c6-4102-477a-8e00-825f8cb18e6d",
        "body" : "Can you add as  comments here and below a proof / summary of a proof of these results?\r\n\r\nIt would be helpful for debugging purposes / if someone wants to go back to see the implementation (in this case, the jacobian matrix is lower triangular, which is why you only get a sum of the log of the diagonal entries).",
        "createdAt" : "2018-04-20T14:32:55Z",
        "updatedAt" : "2018-04-25T17:01:45Z",
        "lastEditedBy" : "bd2885c6-4102-477a-8e00-825f8cb18e6d",
        "tags" : [
        ]
      }
    ],
    "commit" : "63f4618fbdd653fd19a3663a64da89c476aeb0cd",
    "line" : 102,
    "diffHunk" : "@@ -1,1 +100,104 @@    return math_ops.cumsum(x, axis=-1)\n\n  def _inverse_log_det_jacobian(self, y):\n    # The Jacobian of the inverse mapping is lower\n    # triangular, with the diagonal elements being:"
  }
]
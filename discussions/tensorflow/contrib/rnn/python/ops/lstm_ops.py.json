[
  {
    "id" : "f3327bab-0b7c-41da-aba3-0dadb0eda032",
    "prId" : 16484,
    "prUrl" : "https://github.com/tensorflow/tensorflow/pull/16484#pullrequestreview-96715269",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "06dbde24-46d5-4d61-bd1f-94580bf7ebeb",
        "parentId" : null,
        "authorId" : "c8f2b008-60f4-4709-b654-47bc9a7795a2",
        "body" : "What's the motivation for this?",
        "createdAt" : "2018-02-12T04:00:00Z",
        "updatedAt" : "2018-02-15T05:56:59Z",
        "lastEditedBy" : "c8f2b008-60f4-4709-b654-47bc9a7795a2",
        "tags" : [
        ]
      },
      {
        "id" : "e7d5f53c-862b-4e89-a1fe-cf7dd80ced0c",
        "parentId" : "06dbde24-46d5-4d61-bd1f-94580bf7ebeb",
        "authorId" : "79c01974-a10d-4e79-8d77-1cb4ecc0f7e8",
        "body" : "Because _gather_states find out(i, j) = data(indices(i), i, j) when indices is a [batch_size] tensor . The origin method  reshape the 'data' to a 2-dim tensor and calculate the indices in the reshaped array . Use gather_nd can locate the 'indices' in the 3-dim tensor 'data' so no need for reshape . And in my experiment , gather may lead to a warning when data is a sparse tensor but use gather_nd with no warning . And use gather_nd can speed up a little .",
        "createdAt" : "2018-02-12T05:53:37Z",
        "updatedAt" : "2018-02-15T05:56:59Z",
        "lastEditedBy" : "79c01974-a10d-4e79-8d77-1cb4ecc0f7e8",
        "tags" : [
        ]
      },
      {
        "id" : "6ae80385-faa1-4cb2-8524-a3e5912c4516",
        "parentId" : "06dbde24-46d5-4d61-bd1f-94580bf7ebeb",
        "authorId" : "c8f2b008-60f4-4709-b654-47bc9a7795a2",
        "body" : "OK, makes sense.",
        "createdAt" : "2018-02-15T01:40:57Z",
        "updatedAt" : "2018-02-15T05:56:59Z",
        "lastEditedBy" : "c8f2b008-60f4-4709-b654-47bc9a7795a2",
        "tags" : [
        ]
      }
    ],
    "commit" : "111e3b6c2ce3083bcc932fd04505805de552df6c",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +573,577 @@  def _gather_states(self, data, indices, batch_size):\n    \"\"\"Produce `out`, s.t. out(i, j) = data(indices(i), i, j).\"\"\"\n    return array_ops.gather_nd(\n        data, array_ops.stack([indices, math_ops.range(batch_size)], axis=1))\n"
  }
]
[
  {
    "id" : "061e1f3c-6250-470a-bf23-1fe3f7b51a28",
    "prId" : 48840,
    "prUrl" : "https://github.com/tensorflow/tensorflow/pull/48840#pullrequestreview-649407477",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c063c64d-3df5-412d-9ebc-dfaeabbeb315",
        "parentId" : null,
        "authorId" : "188e576a-21d3-4c6f-bf41-5747a83bdb5b",
        "body" : "Since tmp is already being cast to int32_t below, shouldn't we just do\r\n\r\nconst int32_t tmp = static_cast<int32_t>(TfLiteRound(f / scale));\r\n\r\nI think that's safer than casting INT_MAX to float, as I don't think that is a lossless cast.",
        "createdAt" : "2021-04-30T16:53:25Z",
        "updatedAt" : "2021-04-30T16:53:26Z",
        "lastEditedBy" : "188e576a-21d3-4c6f-bf41-5747a83bdb5b",
        "tags" : [
        ]
      },
      {
        "id" : "0fb8d129-cd35-4614-aeea-bde0dbf5aab3",
        "parentId" : "c063c64d-3df5-412d-9ebc-dfaeabbeb315",
        "authorId" : "188e576a-21d3-4c6f-bf41-5747a83bdb5b",
        "body" : "Ignore this, I just noticed we're doing this specifically to check overflow :)",
        "createdAt" : "2021-04-30T16:54:33Z",
        "updatedAt" : "2021-04-30T16:54:33Z",
        "lastEditedBy" : "188e576a-21d3-4c6f-bf41-5747a83bdb5b",
        "tags" : [
        ]
      }
    ],
    "commit" : "c1cd542ac63d4c132327e26b21d26ab17df0a16b",
    "line" : 2,
    "diffHunk" : "@@ -1,1 +337,341 @@inline TfLiteStatus Quantize(TfLiteContext* context, float scale,\n                             int32_t zero_point, float f, int32_t& q) {\n  const float tmp = TfLiteRound(f / scale);\n  const bool no_integer_overflow_from_quantization =\n      (tmp >= static_cast<float>(std::numeric_limits<int32_t>::min()) &&"
  }
]
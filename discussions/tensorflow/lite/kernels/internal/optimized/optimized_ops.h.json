[
  {
    "id" : "d4d60e18-f916-4fba-8f75-c83e2b400cd0",
    "prId" : 47580,
    "prUrl" : "https://github.com/tensorflow/tensorflow/pull/47580#pullrequestreview-604787882",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f2ada870-5b25-4462-8564-498dae4de80f",
        "parentId" : null,
        "authorId" : "dc2d2e0c-b690-4812-96e8-4d9e58f7d2e1",
        "body" : "can we make additional improvement by turning this into Neon instructions?",
        "createdAt" : "2021-03-05T04:00:57Z",
        "updatedAt" : "2021-03-05T23:52:55Z",
        "lastEditedBy" : "dc2d2e0c-b690-4812-96e8-4d9e58f7d2e1",
        "tags" : [
        ]
      }
    ],
    "commit" : "23603971dfe0c90d8e77d907e3069929f9f5e51e",
    "line" : 21,
    "diffHunk" : "@@ -1,1 +7737,7741 @@  for (int i = 1; i < size; ++i) {\n    const T curr_value = input_data[i];\n    if (curr_value < min_value) {\n      min_value = curr_value;\n      min_index = i;"
  },
  {
    "id" : "62e0a838-9951-40f6-8ecf-90a4a15d9919",
    "prId" : 47580,
    "prUrl" : "https://github.com/tensorflow/tensorflow/pull/47580#pullrequestreview-604820809",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d10c854d-157a-4eda-919c-2b2d5c5bb953",
        "parentId" : null,
        "authorId" : "dc2d2e0c-b690-4812-96e8-4d9e58f7d2e1",
        "body" : "The size of loading values at once can affect the performance. Could you experiment loading 8 indices and 16 indices at once? since the parallel loading/storing invocations can hide the calculation times.",
        "createdAt" : "2021-03-05T04:05:49Z",
        "updatedAt" : "2021-03-05T23:52:55Z",
        "lastEditedBy" : "dc2d2e0c-b690-4812-96e8-4d9e58f7d2e1",
        "tags" : [
        ]
      },
      {
        "id" : "70220f2b-b111-44e9-8e5c-e14315ed9b3c",
        "parentId" : "d10c854d-157a-4eda-919c-2b2d5c5bb953",
        "authorId" : "46ee1aa2-6cc0-4d18-ba46-b2b3ce5fd5a6",
        "body" : "Sure, I'll do some experiments.",
        "createdAt" : "2021-03-05T05:20:33Z",
        "updatedAt" : "2021-03-05T23:52:55Z",
        "lastEditedBy" : "46ee1aa2-6cc0-4d18-ba46-b2b3ce5fd5a6",
        "tags" : [
        ]
      },
      {
        "id" : "b82526e3-e15f-4c66-99bb-e02253af4c1d",
        "parentId" : "d10c854d-157a-4eda-919c-2b2d5c5bb953",
        "authorId" : "46ee1aa2-6cc0-4d18-ba46-b2b3ce5fd5a6",
        "body" : "Unfortunately, unrolling the loop does not gain the performance. I think it's because this is a reduction task, there are many true dependencies on registers (for example, `max_value_f32x4`), which make instructions hard to interleave",
        "createdAt" : "2021-03-05T05:40:16Z",
        "updatedAt" : "2021-03-05T23:52:55Z",
        "lastEditedBy" : "46ee1aa2-6cc0-4d18-ba46-b2b3ce5fd5a6",
        "tags" : [
        ]
      }
    ],
    "commit" : "23603971dfe0c90d8e77d907e3069929f9f5e51e",
    "line" : 114,
    "diffHunk" : "@@ -1,1 +7830,7834 @@    int32x4_t inc = vdupq_n_s32(4);\n    for (i = 4; i <= size - 4; i += 4) {\n      // Increase indices by 4.\n      index_s32x4 = vaddq_s32(index_s32x4, inc);\n      float32x4_t v = vld1q_f32(&input_data[i]);"
  },
  {
    "id" : "c537ef8c-0838-4307-bb46-3a250cfb6209",
    "prId" : 47580,
    "prUrl" : "https://github.com/tensorflow/tensorflow/pull/47580#pullrequestreview-604814304",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c9e5012b-c6dd-41dd-9680-d6e2a3681baf",
        "parentId" : null,
        "authorId" : "dc2d2e0c-b690-4812-96e8-4d9e58f7d2e1",
        "body" : "can we have two for-loop to remove the unnecessary if condition every time?",
        "createdAt" : "2021-03-05T04:09:14Z",
        "updatedAt" : "2021-03-05T23:52:55Z",
        "lastEditedBy" : "dc2d2e0c-b690-4812-96e8-4d9e58f7d2e1",
        "tags" : [
        ]
      },
      {
        "id" : "fe218fa9-186d-452a-af8f-1d0392d318f1",
        "parentId" : "c9e5012b-c6dd-41dd-9680-d6e2a3681baf",
        "authorId" : "46ee1aa2-6cc0-4d18-ba46-b2b3ce5fd5a6",
        "body" : "`is_arg_max` here is a template argument. Compiler should be able to avoid the condition at compilation time?",
        "createdAt" : "2021-03-05T05:21:18Z",
        "updatedAt" : "2021-03-05T23:52:55Z",
        "lastEditedBy" : "46ee1aa2-6cc0-4d18-ba46-b2b3ce5fd5a6",
        "tags" : [
        ]
      }
    ],
    "commit" : "23603971dfe0c90d8e77d907e3069929f9f5e51e",
    "line" : 172,
    "diffHunk" : "@@ -1,1 +7888,7892 @@  for (int outer = 0; outer < outer_size; ++outer) {\n    if (is_arg_max) {\n      output_data[outer] = static_cast<T2>(\n          ArgMaxVector<T1>(input_data + outer * axis_size, axis_size));\n    } else {"
  },
  {
    "id" : "e1825cba-5f17-497b-9042-231d54087ec6",
    "prId" : 47580,
    "prUrl" : "https://github.com/tensorflow/tensorflow/pull/47580#pullrequestreview-604894649",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4a3cb425-b0d0-4ce7-a381-ccff0a97d65e",
        "parentId" : null,
        "authorId" : "0a35de17-09bf-47a1-9bfa-84c0a8c63acb",
        "body" : "does int32x4_t min_index_s32x4 = {0, 1, 2, 3} work?",
        "createdAt" : "2021-03-05T07:09:09Z",
        "updatedAt" : "2021-03-05T23:52:55Z",
        "lastEditedBy" : "0a35de17-09bf-47a1-9bfa-84c0a8c63acb",
        "tags" : [
        ]
      },
      {
        "id" : "bb9a0d94-10c1-4ee2-876e-ad962fa2fbee",
        "parentId" : "4a3cb425-b0d0-4ce7-a381-ccff0a97d65e",
        "authorId" : "46ee1aa2-6cc0-4d18-ba46-b2b3ce5fd5a6",
        "body" : "It does not work unfortunately. Looks like compiler used in build tools has not supported this yet. It will complain\r\n\r\n```\r\nerror: too many initializers for 'int32x4_t' {aka '__vector(2) long long int'}\r\n```",
        "createdAt" : "2021-03-05T08:14:17Z",
        "updatedAt" : "2021-03-05T23:52:55Z",
        "lastEditedBy" : "46ee1aa2-6cc0-4d18-ba46-b2b3ce5fd5a6",
        "tags" : [
        ]
      }
    ],
    "commit" : "23603971dfe0c90d8e77d907e3069929f9f5e51e",
    "line" : 54,
    "diffHunk" : "@@ -1,1 +7770,7774 @@    float32x4_t min_value_f32x4 = vld1q_f32(input_data);\n    const int32_t index_init[4] = {0, 1, 2, 3};\n    int32x4_t min_index_s32x4 = vld1q_s32(index_init);\n    int32x4_t index_s32x4 = min_index_s32x4;\n    int32x4_t inc = vdupq_n_s32(4);"
  },
  {
    "id" : "707e522b-2cce-4937-9f1f-72a38a27bbce",
    "prId" : 47580,
    "prUrl" : "https://github.com/tensorflow/tensorflow/pull/47580#pullrequestreview-605097999",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f7d2dd50-f5e2-4a60-9f30-e9b5287b7ebd",
        "parentId" : null,
        "authorId" : "dc2d2e0c-b690-4812-96e8-4d9e58f7d2e1",
        "body" : "Choose the only one keyword among the `n` or `size` keywords for the template functions consistently.",
        "createdAt" : "2021-03-05T12:24:26Z",
        "updatedAt" : "2021-03-05T23:52:55Z",
        "lastEditedBy" : "dc2d2e0c-b690-4812-96e8-4d9e58f7d2e1",
        "tags" : [
        ]
      },
      {
        "id" : "728ce5cf-686a-4add-9b8f-ebbe0169c5fe",
        "parentId" : "f7d2dd50-f5e2-4a60-9f30-e9b5287b7ebd",
        "authorId" : "dc2d2e0c-b690-4812-96e8-4d9e58f7d2e1",
        "body" : "My recommendation is using the `size` keyword.",
        "createdAt" : "2021-03-05T12:39:40Z",
        "updatedAt" : "2021-03-05T23:52:55Z",
        "lastEditedBy" : "dc2d2e0c-b690-4812-96e8-4d9e58f7d2e1",
        "tags" : [
        ]
      }
    ],
    "commit" : "23603971dfe0c90d8e77d907e3069929f9f5e51e",
    "line" : 46,
    "diffHunk" : "@@ -1,1 +7762,7766 @@\ntemplate <>\ninline int ArgMinVector(const float* input_data, int size) {\n  int32_t min_index = 0;\n  float min_value = input_data[0];"
  },
  {
    "id" : "762d1d34-7526-43fc-9434-df820e86c4b0",
    "prId" : 47580,
    "prUrl" : "https://github.com/tensorflow/tensorflow/pull/47580#pullrequestreview-605737542",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c426ab07-77e7-4c0a-a23c-7f9138918f7f",
        "parentId" : null,
        "authorId" : "46ee1aa2-6cc0-4d18-ba46-b2b3ce5fd5a6",
        "body" : "Here is an error: `uint32x2_t` -> `int32x2_t`.",
        "createdAt" : "2021-03-06T07:41:48Z",
        "updatedAt" : "2021-03-06T07:42:11Z",
        "lastEditedBy" : "46ee1aa2-6cc0-4d18-ba46-b2b3ce5fd5a6",
        "tags" : [
        ]
      }
    ],
    "commit" : "23603971dfe0c90d8e77d907e3069929f9f5e51e",
    "line" : 83,
    "diffHunk" : "@@ -1,1 +7799,7803 @@    min_index = vminvq_s32(min_index_s32x4);\n#else\n    uint32x2_t min_index_s32x2 = vpmin_s32(vget_low_s32(min_index_s32x4),\n                                           vget_high_s32(min_index_s32x4));\n    min_index_s32x2 = vpmin_s32(min_index_s32x2, min_index_s32x2);"
  },
  {
    "id" : "8a0b8543-2d0f-47d8-a260-577f4bbbfbfb",
    "prId" : 47580,
    "prUrl" : "https://github.com/tensorflow/tensorflow/pull/47580#pullrequestreview-605737542",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0f564f1d-28fc-498b-8207-48934864553d",
        "parentId" : null,
        "authorId" : "46ee1aa2-6cc0-4d18-ba46-b2b3ce5fd5a6",
        "body" : "ditto",
        "createdAt" : "2021-03-06T07:42:05Z",
        "updatedAt" : "2021-03-06T07:42:11Z",
        "lastEditedBy" : "46ee1aa2-6cc0-4d18-ba46-b2b3ce5fd5a6",
        "tags" : [
        ]
      }
    ],
    "commit" : "23603971dfe0c90d8e77d907e3069929f9f5e51e",
    "line" : 139,
    "diffHunk" : "@@ -1,1 +7855,7859 @@    max_index = vminvq_s32(max_index_s32x4);\n#else\n    uint32x2_t max_index_s32x2 = vpmin_s32(vget_low_s32(max_index_s32x4),\n                                           vget_high_s32(max_index_s32x4));\n    max_index_s32x2 = vpmin_s32(max_index_s32x2, max_index_s32x2);"
  },
  {
    "id" : "71687445-493f-4da5-8485-0e3ee0acdeee",
    "prId" : 27825,
    "prUrl" : "https://github.com/tensorflow/tensorflow/pull/27825#pullrequestreview-323637307",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a9c2834b-7a32-41cb-bbb1-13ae9e6f5fdd",
        "parentId" : null,
        "authorId" : "c14be44a-1748-4d93-a075-2bb17587c151",
        "body" : "Could you please add a comment on this parameter? How is it used and what is the accuracy implication if kNewtonStep is 2?",
        "createdAt" : "2019-11-14T18:44:38Z",
        "updatedAt" : "2019-11-27T12:27:14Z",
        "lastEditedBy" : "c14be44a-1748-4d93-a075-2bb17587c151",
        "tags" : [
        ]
      },
      {
        "id" : "ca02bd85-21eb-4cf9-838c-7670ae2459ed",
        "parentId" : "a9c2834b-7a32-41cb-bbb1-13ae9e6f5fdd",
        "authorId" : "d2c09941-7b2f-4fb9-9288-cfa32a6bf56a",
        "body" : "Added a comment.\r\n\r\n`kNewtonSteps` stands for a number of Newton-Raphson iterations used to refine the initial estimate of the reciprocal given by `vrecpeq_f32` instruction.\r\n\r\nThe list below shows the effect of this parameter on the maximum and average relative errors between the results of NEON multiplication by the reciprocal and the actual result of floating point division, where both operands are random numbers in the range (2^-16, 2^16).\r\n\r\n- kNewtonStep=0: max=2.76e-03 avg=9.70e-04\r\n- kNewtonStep=1: max=7.57e-06 avg=1.39e-06\r\n- kNewtonStep=2: max=1.52e-07 avg=3.49e-08\r\n- kNewtonStep=3: max=1.19e-07 avg=2.52e-08",
        "createdAt" : "2019-11-27T12:29:40Z",
        "updatedAt" : "2019-11-27T18:37:55Z",
        "lastEditedBy" : "d2c09941-7b2f-4fb9-9288-cfa32a6bf56a",
        "tags" : [
        ]
      }
    ],
    "commit" : "4d9297306254d2584c79b08fb43a2eaf705e9771",
    "line" : 20,
    "diffHunk" : "@@ -1,1 +2646,2650 @@  // vrecpeq_f32 instruction. Typically, two iterations are enough to match\n  // the float division accuracy closely.\n  static constexpr int kNewtonSteps = 2;\n  static const auto TWO_F32 = vdupq_n_f32(2.f);\n  const auto activation_min = vdupq_n_f32(output_activation_min);"
  },
  {
    "id" : "9efbcd95-b5f3-4810-bb1a-6afe5f89e094",
    "prId" : 51066,
    "prUrl" : "https://github.com/tensorflow/tensorflow/pull/51066#pullrequestreview-719726174",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e67c3755-b3f4-40c6-a437-5e3fdba1991e",
        "parentId" : null,
        "authorId" : "dc2d2e0c-b690-4812-96e8-4d9e58f7d2e1",
        "body" : "Instead of adding nullptr checks here, how about adding the null pointer checking just after the input1_data_ptr declarations.\r\n\r\nFor example,\r\n\r\n```\r\nconst T* input1_data_ptr = input1_data;\r\nTFLITE_DCHECK(input1_data_ptr != nullptr);\r\nconst T* input2_data_reset = input2_data;\r\n```",
        "createdAt" : "2021-08-02T01:18:11Z",
        "updatedAt" : "2021-08-02T01:18:11Z",
        "lastEditedBy" : "dc2d2e0c-b690-4812-96e8-4d9e58f7d2e1",
        "tags" : [
        ]
      },
      {
        "id" : "cefacd51-e09b-42f8-b876-fc6a792e47ca",
        "parentId" : "e67c3755-b3f4-40c6-a437-5e3fdba1991e",
        "authorId" : "dc2d2e0c-b690-4812-96e8-4d9e58f7d2e1",
        "body" : "please ignore the above comment.",
        "createdAt" : "2021-08-02T01:22:20Z",
        "updatedAt" : "2021-08-02T01:22:20Z",
        "lastEditedBy" : "dc2d2e0c-b690-4812-96e8-4d9e58f7d2e1",
        "tags" : [
        ]
      }
    ],
    "commit" : "66664775f1c1f7616ecf00e593c7d880f98a1734",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +266,270 @@      input2_data_reset = input2_data_ptr;\n    }\n  } else if (input1_data_ptr != nullptr) {\n    // Special case of y4 == 1, in which the innermost loop is a single\n    // element and can be combined with the next (y3) as an inner broadcast."
  }
]
[
  {
    "id" : "531b7f09-a6f6-46c1-bad8-ab44e95d5eef",
    "prId" : 9876,
    "prUrl" : "https://github.com/tensorflow/tensorflow/pull/9876#pullrequestreview-39651157",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e3a96299-b2cc-4c85-8429-f2cf3e1166e5",
        "parentId" : null,
        "authorId" : "0ba8fb18-637a-4ab3-a7c8-cd971823fe45",
        "body" : "Won't this depend on the endianness of the machine where this test is run? You can test the endianness of the machine here using the Python sys module, e.g.,\r\n```\r\n>>> import sys\r\n>>> sys.byteorder\r\n'little'\r\n```\r\n",
        "createdAt" : "2017-05-22T16:39:31Z",
        "updatedAt" : "2017-05-22T16:40:07Z",
        "lastEditedBy" : "0ba8fb18-637a-4ab3-a7c8-cd971823fe45",
        "tags" : [
        ]
      },
      {
        "id" : "35dbeb5b-790a-4130-8653-9e17dfad028e",
        "parentId" : "e3a96299-b2cc-4c85-8429-f2cf3e1166e5",
        "authorId" : "5995f6f4-0c4b-4283-ae51-e917b5deecc3",
        "body" : "It won't. This decode op gets same result on machines with different endianness, just like the way these machines receive data from the network. In fact, platform endianness is considered in the C++ code (`if (port::kLittleEndian == little_endian_)`) to ensure consistency. As I said before, the old platform-dependent behavior in this test is contradictionary with the documentation.",
        "createdAt" : "2017-05-23T06:23:23Z",
        "updatedAt" : "2017-05-23T06:23:24Z",
        "lastEditedBy" : "5995f6f4-0c4b-4283-ae51-e917b5deecc3",
        "tags" : [
        ]
      }
    ],
    "commit" : "d7c9b9b78591ec14994be5512071d8461894e5cd",
    "line" : 25,
    "diffHunk" : "@@ -1,1 +70,74 @@      decode_be = parsing_ops.decode_raw(\n          in_bytes, out_type=dtypes.int32, little_endian=False)\n      result = decode_le.eval(feed_dict={in_bytes: [\"\\x01\\x02\\x03\\x04\"]})\n      self.assertAllEqual([[0x04030201]], result)\n      result = decode_be.eval(feed_dict={in_bytes: [\"\\x01\\x02\\x03\\x04\"]})"
  }
]
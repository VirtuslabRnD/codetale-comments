[
  {
    "id" : "d483f231-e500-45b4-9839-490067bfc9d1",
    "prId" : 48610,
    "prUrl" : "https://github.com/tensorflow/tensorflow/pull/48610#pullrequestreview-649446076",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b322774a-2b4c-48ea-95b5-374d980b9e36",
        "parentId" : null,
        "authorId" : "4e4f52a9-b30a-4f86-b12b-9e2c6085b427",
        "body" : "Could you explain why we need to skip checks on the channel axis? Also please consider putting a comment before the if check.",
        "createdAt" : "2021-04-30T17:17:41Z",
        "updatedAt" : "2021-05-11T17:34:54Z",
        "lastEditedBy" : "4e4f52a9-b30a-4f86-b12b-9e2c6085b427",
        "tags" : [
        ]
      },
      {
        "id" : "7d7ce8c8-c742-49f1-b53b-ff21f60fdc32",
        "parentId" : "b322774a-2b4c-48ea-95b5-374d980b9e36",
        "authorId" : "f189c14e-b0da-49c6-9138-92616ee2cf63",
        "body" : "@chenmoneygithub \r\nThe channel axis is dependent on no. of filters, which are checked by the additions made in #48566 . ",
        "createdAt" : "2021-04-30T17:26:26Z",
        "updatedAt" : "2021-05-11T17:34:54Z",
        "lastEditedBy" : "f189c14e-b0da-49c6-9138-92616ee2cf63",
        "tags" : [
        ]
      },
      {
        "id" : "3fc25810-effa-42be-87b4-57cabf5bf021",
        "parentId" : "b322774a-2b4c-48ea-95b5-374d980b9e36",
        "authorId" : "f189c14e-b0da-49c6-9138-92616ee2cf63",
        "body" : "Also the rest of the arguments for `conv_utils.conv_output_length` don't consider channels and batch size.",
        "createdAt" : "2021-04-30T17:44:15Z",
        "updatedAt" : "2021-05-11T17:34:54Z",
        "lastEditedBy" : "f189c14e-b0da-49c6-9138-92616ee2cf63",
        "tags" : [
        ]
      }
    ],
    "commit" : "d4378122b15c1d5c072ab127b90c76a19cefb492",
    "line" : 18,
    "diffHunk" : "@@ -1,1 +235,239 @@    # They must not have 0 entries along any dimension\n    # Check dimensions other than batch and channel, must be greater than 0\n    if self._channels_first:\n      for idx, dimension in enumerate(input_shape.as_list()[-self.rank:]):\n        self._check_invalid_dimension(dimension, idx, input_shape)"
  },
  {
    "id" : "4bfe6a0a-2edf-476d-b0ff-8651bdbb57de",
    "prId" : 40512,
    "prUrl" : "https://github.com/tensorflow/tensorflow/pull/40512#pullrequestreview-434548163",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6e324986-d463-460a-a23d-da625fb29469",
        "parentId" : null,
        "authorId" : "39b43209-9150-4c84-b6c9-dce35aa24dd0",
        "body" : "you might want to replicate the `causal` part for the rest of the PR",
        "createdAt" : "2020-06-18T16:13:29Z",
        "updatedAt" : "2020-06-22T00:28:34Z",
        "lastEditedBy" : "39b43209-9150-4c84-b6c9-dce35aa24dd0",
        "tags" : [
        ]
      },
      {
        "id" : "462cff68-e3d8-4724-93b4-c36d236375ea",
        "parentId" : "6e324986-d463-460a-a23d-da625fb29469",
        "authorId" : "aaede271-d237-49c1-ab5f-da6f4cb02fb6",
        "body" : "I'm not sure if we have `\"causal\"` for Conv2D and Conv3D. We should instead use the `dilation_rate` parameter.",
        "createdAt" : "2020-06-19T03:52:07Z",
        "updatedAt" : "2020-06-22T00:28:34Z",
        "lastEditedBy" : "aaede271-d237-49c1-ab5f-da6f4cb02fb6",
        "tags" : [
        ]
      },
      {
        "id" : "931f490e-3137-4ffa-baa5-c0b053434b06",
        "parentId" : "6e324986-d463-460a-a23d-da625fb29469",
        "authorId" : "4722dc3c-4675-40c8-a464-031f977a5f81",
        "body" : "We can't get the same causal dilations with only the `dilation_rate` parameter, unless the `causal` padding variant is implemented for that layer. Therefore we can resolve this thread",
        "createdAt" : "2020-06-22T00:31:44Z",
        "updatedAt" : "2020-06-22T00:31:44Z",
        "lastEditedBy" : "4722dc3c-4675-40c8-a464-031f977a5f81",
        "tags" : [
        ]
      }
    ],
    "commit" : "a1f9c4d80b68c47deddfbfb4ee5ccc093d347d48",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +76,80 @@      the left/right or up/down of the input such that output has the same \n      height/width dimension as the input. `\"causal\"` results in causal \n      (dilated) convolutions, e.g. `output[t]` does not depend on `input[t+1:]`.\n    data_format: A string, one of `channels_last` (default) or `channels_first`.\n      The ordering of the dimensions in the inputs."
  },
  {
    "id" : "405c9576-f14f-43f1-b46b-564028c85efb",
    "prId" : 36773,
    "prUrl" : "https://github.com/tensorflow/tensorflow/pull/36773#pullrequestreview-388409349",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "523d9c3c-013f-4f9b-8a06-692fc87a602e",
        "parentId" : null,
        "authorId" : "39b43209-9150-4c84-b6c9-dce35aa24dd0",
        "body" : "what if `self.groups = None`? Should we allow that and make None == 1?",
        "createdAt" : "2020-04-06T15:46:50Z",
        "updatedAt" : "2020-04-25T16:46:31Z",
        "lastEditedBy" : "39b43209-9150-4c84-b6c9-dce35aa24dd0",
        "tags" : [
        ]
      },
      {
        "id" : "2dfa7909-3acd-4379-bac3-c834bc8a3a6a",
        "parentId" : "523d9c3c-013f-4f9b-8a06-692fc87a602e",
        "authorId" : "c0e6af67-982a-4e5a-980e-4580b05253a0",
        "body" : "I don't think this case will come up very much in practice, but it is very easy to support. I added a quick check in d74951f42d8ae8b7c29fb428c3745c90196f95bc.",
        "createdAt" : "2020-04-06T16:17:37Z",
        "updatedAt" : "2020-04-25T16:46:31Z",
        "lastEditedBy" : "c0e6af67-982a-4e5a-980e-4580b05253a0",
        "tags" : [
        ]
      }
    ],
    "commit" : "389fba4b3c9337ae2930b605f8cae3891c8b60d7",
    "line" : 25,
    "diffHunk" : "@@ -1,1 +135,139 @@    self.filters = filters\n    self.groups = groups or 1\n    if filters is not None and filters % self.groups != 0:\n      raise ValueError(\n          'The number of filters must be evenly divisible by the number of '"
  },
  {
    "id" : "395e6b13-dad8-4042-92bf-8004580a7195",
    "prId" : 36773,
    "prUrl" : "https://github.com/tensorflow/tensorflow/pull/36773#pullrequestreview-388533268",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7bed8dd1-73c1-45b2-b240-784fa3ef3ea1",
        "parentId" : null,
        "authorId" : "39b43209-9150-4c84-b6c9-dce35aa24dd0",
        "body" : "I'm a little confused here, dont we need `self.groups` # of kernels each of shape `(kernel_size,) + (input_channel // self.groups, self.filters)`?",
        "createdAt" : "2020-04-06T15:56:28Z",
        "updatedAt" : "2020-04-25T16:46:31Z",
        "lastEditedBy" : "39b43209-9150-4c84-b6c9-dce35aa24dd0",
        "tags" : [
        ]
      },
      {
        "id" : "1e68e6b5-c7b9-4552-9a84-4366a5e97c72",
        "parentId" : "7bed8dd1-73c1-45b2-b240-784fa3ef3ea1",
        "authorId" : "c0e6af67-982a-4e5a-980e-4580b05253a0",
        "body" : "As far as I know most frameworks follow the convention that the shape of the weights is `(*kernel_size, input_channel // groups, output_channels)` so that `filters==output_channels` regardless of the number of groups used. E.g. PyTorch does the same [here](https://github.com/pytorch/pytorch/blob/82d58ed484eb04f894475de0551055f7e070f481/torch/nn/modules/conv.py#L47-L48).\r\nI personally think of `filters` as the number of output channels of a convolution, so adopting the convention that `filters` are the number of channels per group doesn't seem natural to me, but please correct me if I am wrong, this seems to be more a question of definition.\r\nFor me figure 3 in https://arxiv.org/pdf/1611.05431.pdf suggests to prefer `filters==output_channels` as well.\r\n",
        "createdAt" : "2020-04-06T16:56:14Z",
        "updatedAt" : "2020-04-25T16:46:31Z",
        "lastEditedBy" : "c0e6af67-982a-4e5a-980e-4580b05253a0",
        "tags" : [
        ]
      },
      {
        "id" : "76742154-20f3-4dc5-8aad-21c4d6aad326",
        "parentId" : "7bed8dd1-73c1-45b2-b240-784fa3ef3ea1",
        "authorId" : "39b43209-9150-4c84-b6c9-dce35aa24dd0",
        "body" : "Right, so `filters==output_channels`.\r\nWhat I don't understand here is, let's say we want to map a (55, 55, 32) conv input to (27, 27, 64) conv output, with `groups=2`. So apparently we need 2 different kernels, both are with shape (3, 3, 16, 64). The first kernel will map the first half (55, 55, 16) to (27, 27, 64), and the second kernel will map the second half (55, 55, 16) to (27, 27, 64). And the final result would be the sum of the two.\r\nSo either we need 2 kernels in 1 conv layer, or we need 2 conv layers. Am I missing something here? (Feel free to point out where I'm wrong)",
        "createdAt" : "2020-04-06T17:26:53Z",
        "updatedAt" : "2020-04-25T16:46:31Z",
        "lastEditedBy" : "39b43209-9150-4c84-b6c9-dce35aa24dd0",
        "tags" : [
        ]
      },
      {
        "id" : "9af09e7e-44f9-4a22-ab44-cf63de77c863",
        "parentId" : "7bed8dd1-73c1-45b2-b240-784fa3ef3ea1",
        "authorId" : "4ce8ced6-2fea-4ea0-b6be-6910bb6166c8",
        "body" : "`filters` gets split into `groups` by the convolutional algorithm. If you would have multiple convolutions mapping to 64d, what would be the end result? 128d instead of 64d for `groups==2`? As far as I know this is handled by the convolution `tf.nn.conv*` or cudnn. ",
        "createdAt" : "2020-04-06T17:39:27Z",
        "updatedAt" : "2020-04-25T16:46:31Z",
        "lastEditedBy" : "4ce8ced6-2fea-4ea0-b6be-6910bb6166c8",
        "tags" : [
        ]
      },
      {
        "id" : "9095ba26-f0fd-40c2-9920-b84da0af338d",
        "parentId" : "7bed8dd1-73c1-45b2-b240-784fa3ef3ea1",
        "authorId" : "c0e6af67-982a-4e5a-980e-4580b05253a0",
        "body" : "@tanzhenyu The grouped convolution computes splits  in the output channel dimension which are then concatenated to combine the result. Your example above would change to:\r\n\r\nThe first kernel will map the first half (55, 55, 16) to (27, 27, ~~64~~**32**), and the second kernel will map the second half (55, 55, 16) to (27, 27, ~~64~~**32**). And the final result would be the ~~sum~~**concatenation** of the two.\r\n\r\nThe implementation of `tf.nn.conv2d` handles this computation either using XLA or CUDNN (see #25818 for reference). This is the reason why adding grouped convolution support to Keras only requires a few additional lines that change the kernel shape. To be fair the fact that `tf.nn.conv2d` computes a grouped convolution depending on the shapes of the inputs and weights is a bit confusing in my opinion.\r\n\r\nConsider the following low level TensorFlow implementation of your example that showcases the computation in relation to a simple loop based implementation and the relation of a grouped convolution to a depthwise:\r\n\r\n```python\r\nimport numpy as np\r\nimport tensorflow as tf\r\n\r\n\r\n@tf.function(experimental_compile=True)  # Needed for grouped conv CPU support\r\ndef conv_2d(inputs, weights, strides=[1, 1, 1, 1], padding=\"VALID\"):\r\n    return tf.nn.conv2d(inputs, weights, strides=strides, padding=padding)\r\n\r\n\r\n# loop based convolution\r\n\r\ngroups = 2\r\ninputs = tf.random.normal(shape=[1, 55, 55, 32], dtype=tf.float64)\r\nweights = tf.random.normal(shape=[3, 3, 32 // groups, 64], dtype=tf.float64)\r\n\r\noutputs = conv_2d(inputs, weights, strides=[1, 2, 2, 1])\r\n\r\ngrouped_inputs = tf.split(inputs, groups, axis=-1)\r\ngrouped_weights = tf.split(weights, groups, axis=-1)\r\noutputs_ref = tf.concat(\r\n    [\r\n        conv_2d(inputs, weights, strides=[1, 2, 2, 1])\r\n        for inputs, weights in zip(grouped_inputs, grouped_weights)\r\n    ],\r\n    axis=-1,\r\n)\r\n\r\nnp.testing.assert_allclose(outputs.numpy(), outputs_ref.numpy())\r\n\r\n# depthwise\r\n\r\ninputs_dw = tf.random.normal(shape=[1, 55, 55, 64], dtype=tf.float64)\r\nweights_dw = tf.random.normal(shape=[3, 3, 64, 1], dtype=tf.float64)\r\nweights_grouped_dw = tf.reshape(weights_dw, [3, 3, 1, 64])\r\n\r\noutputs_dw = conv_2d(inputs_dw, weights_grouped_dw, strides=[1, 2, 2, 1])\r\noutputs_dw_ref = tf.nn.depthwise_conv2d(\r\n    inputs_dw, weights_dw, strides=[1, 2, 2, 1], padding=\"VALID\"\r\n)\r\n\r\nnp.testing.assert_allclose(outputs_dw.numpy(), outputs_dw_ref.numpy())\r\n```",
        "createdAt" : "2020-04-06T18:18:08Z",
        "updatedAt" : "2020-04-25T16:46:31Z",
        "lastEditedBy" : "c0e6af67-982a-4e5a-980e-4580b05253a0",
        "tags" : [
        ]
      },
      {
        "id" : "20a866cf-6c1c-4869-bec3-c3b132f619b7",
        "parentId" : "7bed8dd1-73c1-45b2-b240-784fa3ef3ea1",
        "authorId" : "39b43209-9150-4c84-b6c9-dce35aa24dd0",
        "body" : "Ok I'm assuming this will end up calling tf.nn.conv2d with `inputs=(H,W, IN_CHANNEL)` and `filters=(IN_CHANNEL/GROUP, K, K, OUT_CHANNEL)` and under the hood (at kernel level) it will infer the group and get multiple OUT_CHANNEL/GROUP conv outputs and concatenate before returning.",
        "createdAt" : "2020-04-06T18:30:56Z",
        "updatedAt" : "2020-04-25T16:46:31Z",
        "lastEditedBy" : "39b43209-9150-4c84-b6c9-dce35aa24dd0",
        "tags" : [
        ]
      },
      {
        "id" : "885d363b-2baf-41c9-9994-595cecac4d05",
        "parentId" : "7bed8dd1-73c1-45b2-b240-784fa3ef3ea1",
        "authorId" : "39b43209-9150-4c84-b6c9-dce35aa24dd0",
        "body" : "Oh I refreshed the page before your comment. Yeah this seems legit.",
        "createdAt" : "2020-04-06T18:40:31Z",
        "updatedAt" : "2020-04-25T16:46:31Z",
        "lastEditedBy" : "39b43209-9150-4c84-b6c9-dce35aa24dd0",
        "tags" : [
        ]
      },
      {
        "id" : "5467483c-4dab-4e83-83e0-6a37226e6882",
        "parentId" : "7bed8dd1-73c1-45b2-b240-784fa3ef3ea1",
        "authorId" : "39b43209-9150-4c84-b6c9-dce35aa24dd0",
        "body" : "@lgeiger Though to be more concise, I think when we call `tf.nn.conv2d`, the inputs don't need to be splitted, because we need to infer groups from input channel and kernel size?\r\n(The docstring of that op needs to be updated as well)",
        "createdAt" : "2020-04-06T18:55:02Z",
        "updatedAt" : "2020-04-25T16:46:31Z",
        "lastEditedBy" : "39b43209-9150-4c84-b6c9-dce35aa24dd0",
        "tags" : [
        ]
      },
      {
        "id" : "a1c6019c-b67a-4e0c-8d42-3320af9a2091",
        "parentId" : "7bed8dd1-73c1-45b2-b240-784fa3ef3ea1",
        "authorId" : "c0e6af67-982a-4e5a-980e-4580b05253a0",
        "body" : "> Though to be more concise, I think when we call `tf.nn.conv2d`, the inputs don't need to be splitted, because we need to infer groups from input channel and kernel size?\r\n\r\nThat's correct and that's what this PR should do as well, since we don't actually change `Layer.call`.",
        "createdAt" : "2020-04-06T19:00:23Z",
        "updatedAt" : "2020-04-25T16:46:31Z",
        "lastEditedBy" : "c0e6af67-982a-4e5a-980e-4580b05253a0",
        "tags" : [
        ]
      }
    ],
    "commit" : "389fba4b3c9337ae2930b605f8cae3891c8b60d7",
    "line" : 46,
    "diffHunk" : "@@ -1,1 +175,179 @@                                       self.filters)\n\n    self.kernel = self.add_weight(\n        name='kernel',\n        shape=kernel_shape,"
  },
  {
    "id" : "aa14b3d6-f967-4507-8c4b-6326759f7990",
    "prId" : 29538,
    "prUrl" : "https://github.com/tensorflow/tensorflow/pull/29538#pullrequestreview-250176806",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ac97e8b1-9e9b-458f-becc-048b69e98053",
        "parentId" : null,
        "authorId" : "39b43209-9150-4c84-b6c9-dce35aa24dd0",
        "body" : "I would wish to be consistent with the example like this:\r\nhttps://github.com/tensorflow/tensorflow/blob/master/tensorflow/python/keras/layers/core.py#L553-L563\r\nspecifically, let user know what input shape and output shape is expected from the layer.",
        "createdAt" : "2019-06-11T16:50:24Z",
        "updatedAt" : "2019-06-15T03:35:31Z",
        "lastEditedBy" : "39b43209-9150-4c84-b6c9-dce35aa24dd0",
        "tags" : [
        ]
      },
      {
        "id" : "b7d1bfce-3c89-4129-b702-6e9dc833aa35",
        "parentId" : "ac97e8b1-9e9b-458f-becc-048b69e98053",
        "authorId" : "5ce2bca1-7e22-47af-9be5-986b6b43aa8e",
        "body" : "Thank you. Adjusted the code accordingly.\r\n\r\nShould there be an example for \"variable timesteps\", where input is `(None, 128)`?\r\nWould be easy to add and probably help many users.",
        "createdAt" : "2019-06-15T03:39:19Z",
        "updatedAt" : "2019-06-15T03:39:20Z",
        "lastEditedBy" : "5ce2bca1-7e22-47af-9be5-986b6b43aa8e",
        "tags" : [
        ]
      }
    ],
    "commit" : "59cb4c8c6ca3a3cbbb7cbf6cb0332c66831d2ccd",
    "line" : 9,
    "diffHunk" : "@@ -1,1 +329,333 @@    # model.input_shape == (None, 6, 128)\n    \n    model = Sequential()\n    model.add(Conv1D(32, 3, \n              activation='relu', "
  }
]
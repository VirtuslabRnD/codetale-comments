[
  {
    "id" : "95b24824-7e0b-42c8-9489-060f74ce1bd4",
    "prId" : 18917,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a2768e8d-ec3e-4f5e-a77e-33ae835b81f9",
        "parentId" : null,
        "authorId" : "3c437914-616b-4cfb-88a0-28dc812ff2b2",
        "body" : "I'm not familiar with this code, but IIUC we're not waiting for client to actually close here. By closing the channel we just notify it that it should, but I don't see how it would prevent the race.\n",
        "createdAt" : "2015-12-23T08:52:38Z",
        "updatedAt" : "2015-12-23T09:26:32Z",
        "lastEditedBy" : "3c437914-616b-4cfb-88a0-28dc812ff2b2",
        "tags" : [
        ]
      },
      {
        "id" : "5490e6f9-10e8-4dda-96ae-866d671ee630",
        "parentId" : "a2768e8d-ec3e-4f5e-a77e-33ae835b81f9",
        "authorId" : "227eb550-8b08-4420-9a78-279f840bd8de",
        "body" : "@gmarek You are right. Let me replace the close with sending struct{}{}, as the channel is an unbuffered channel, sending to that channel happens after the channel is received, in which case it should guarantee there is not flying requests then.\n",
        "createdAt" : "2015-12-23T09:19:27Z",
        "updatedAt" : "2015-12-23T09:26:32Z",
        "lastEditedBy" : "227eb550-8b08-4420-9a78-279f840bd8de",
        "tags" : [
        ]
      },
      {
        "id" : "5f4d0ddc-97cc-48a8-a9a6-2471bc7ef16b",
        "parentId" : "a2768e8d-ec3e-4f5e-a77e-33ae835b81f9",
        "authorId" : "227eb550-8b08-4420-9a78-279f840bd8de",
        "body" : "Updated\n",
        "createdAt" : "2015-12-23T09:26:46Z",
        "updatedAt" : "2015-12-23T09:26:46Z",
        "lastEditedBy" : "227eb550-8b08-4420-9a78-279f840bd8de",
        "tags" : [
        ]
      }
    ],
    "commit" : "04db432fb4752514dc7eeb298a421d05306b05e4",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +392,396 @@\t\t\tt.Errorf(\"#%d: Expecting: %v, but got: %v\", i, tt.userInfo, user)\n\t\t}\n\t\tclient.Close()\n\t}\n}"
  }
]
[
  {
    "id" : "2554ab80-526a-458c-ac34-09b622c11de0",
    "prId" : 83568,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/83568#pullrequestreview-315004524",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b6ec70e8-27be-4e03-9c11-758e67a66082",
        "parentId" : null,
        "authorId" : "255dd885-bee4-4c1f-baef-ba11f903dc5c",
        "body" : "I'm removing **both** _CSINodeInfo_ and _AttachVolumeLimits_ checks because since _AttachVolumeLimits_ is always true now, this rules needs to exist.",
        "createdAt" : "2019-11-11T16:20:08Z",
        "updatedAt" : "2019-11-12T08:44:17Z",
        "lastEditedBy" : "255dd885-bee4-4c1f-baef-ba11f903dc5c",
        "tags" : [
        ]
      }
    ],
    "commit" : "a59abc3cc381f563743d60ac54ddc922b4e007b3",
    "line" : 9,
    "diffHunk" : "@@ -1,1 +500,504 @@\t\trbacv1helpers.NewRule(\"create\").Groups(authorizationGroup).Resources(\"subjectaccessreviews\").RuleOrDie(),\n\t\t// Needed for volume limits\n\t\trbacv1helpers.NewRule(Read...).Groups(storageGroup).Resources(\"csinodes\").RuleOrDie(),\n\t}\n\troles = append(roles, rbacv1.ClusterRole{"
  },
  {
    "id" : "0a433c45-e222-4410-b3b0-73e675af9ca4",
    "prId" : 72046,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/72046#pullrequestreview-317243090",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7a0ef84f-5536-4ede-971d-1d3385dc98a7",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "I don't think this needs \"get\" any more",
        "createdAt" : "2019-11-12T20:36:02Z",
        "updatedAt" : "2019-11-15T06:38:02Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "8580f589-fc9a-4b51-ae62-b8f23b5317ab",
        "parentId" : "7a0ef84f-5536-4ede-971d-1d3385dc98a7",
        "authorId" : "6dd71efb-88b1-4bb0-b30a-0df658362f14",
        "body" : "I'm not sure this is the case anymore but I was under the impression that we generally only make additive changes to bootstrap policies since removing rules can complicate downgrade.  ",
        "createdAt" : "2019-11-12T23:19:27Z",
        "updatedAt" : "2019-11-15T06:38:02Z",
        "lastEditedBy" : "6dd71efb-88b1-4bb0-b30a-0df658362f14",
        "tags" : [
        ]
      },
      {
        "id" : "862b4ac8-418c-42ec-98e2-5cb6789ccb2d",
        "parentId" : "7a0ef84f-5536-4ede-971d-1d3385dc98a7",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "I don't think it has needed \"get\" for a long time :)",
        "createdAt" : "2019-11-14T20:35:38Z",
        "updatedAt" : "2019-11-15T06:38:02Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "31d623b4d74ceadfad101d36a4710d4406fcf144",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +462,466 @@\tnodeProxierRules := []rbacv1.PolicyRule{\n\t\trbacv1helpers.NewRule(\"list\", \"watch\").Groups(legacyGroup).Resources(\"services\", \"endpoints\").RuleOrDie(),\n\t\trbacv1helpers.NewRule(\"get\", \"list\", \"watch\").Groups(legacyGroup).Resources(\"nodes\").RuleOrDie(),\n\n\t\teventsRule(),"
  },
  {
    "id" : "7612be18-4af7-43a7-9911-972479e953c3",
    "prId" : 71021,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/71021#pullrequestreview-174877764",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "cf3ecd06-9281-4181-82e2-ccf54f570fcc",
        "parentId" : null,
        "authorId" : "224e1088-78fe-4bdd-99d1-31be3e464996",
        "body" : "what binary is this code part of ?",
        "createdAt" : "2018-11-14T08:31:13Z",
        "updatedAt" : "2018-11-14T08:31:13Z",
        "lastEditedBy" : "224e1088-78fe-4bdd-99d1-31be3e464996",
        "tags" : [
        ]
      },
      {
        "id" : "8c882c3b-7413-431d-92e0-fd58a047a70d",
        "parentId" : "cf3ecd06-9281-4181-82e2-ccf54f570fcc",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "the kube-apiserver, which uses it in the node authorizer and to populate the default `system:node` cluster role",
        "createdAt" : "2018-11-14T14:09:48Z",
        "updatedAt" : "2018-11-14T14:10:31Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "8d7cc3903180c96f297022c70785967591f3b3bc",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +108,112 @@\t\trbacv1helpers.NewRule(\"create\", \"get\", \"list\", \"watch\").Groups(legacyGroup).Resources(\"nodes\").RuleOrDie(),\n\t\trbacv1helpers.NewRule(\"update\", \"patch\").Groups(legacyGroup).Resources(\"nodes/status\").RuleOrDie(),\n\t\trbacv1helpers.NewRule(\"update\", \"patch\").Groups(legacyGroup).Resources(\"nodes\").RuleOrDie(),\n\n\t\t// TODO: restrict to the bound node as creator in the NodeRestrictions admission plugin"
  },
  {
    "id" : "34040819-48b3-462d-b041-72365739b998",
    "prId" : 69062,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/69062#pullrequestreview-159028020",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d85c2d26-0970-4bfb-aff0-bef18df54e64",
        "parentId" : null,
        "authorId" : "2d9afee7-a404-4340-8fd9-d3187ed4f1da",
        "body" : "The existing entries appear to be in alphabetical order, likely deliberately. Can we preserve that rather than adding the new resource at the end?",
        "createdAt" : "2018-09-26T12:42:43Z",
        "updatedAt" : "2018-09-26T20:04:19Z",
        "lastEditedBy" : "2d9afee7-a404-4340-8fd9-d3187ed4f1da",
        "tags" : [
        ]
      },
      {
        "id" : "3455d741-5764-4686-81a5-b8971739b41a",
        "parentId" : "d85c2d26-0970-4bfb-aff0-bef18df54e64",
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "> The existing entries appear to be in alphabetical order, likely deliberately. Can we preserve that rather than adding the new resource at the end?\r\n\r\nOriginal author here.  That was a complete coincidence.  Most in this file aren't alphabetical.  I don't really care one way or the other.",
        "createdAt" : "2018-09-26T14:30:48Z",
        "updatedAt" : "2018-09-26T20:04:19Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      }
    ],
    "commit" : "dfc3c83e64172e0e56c02ec4c0c3004779111709",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +403,407 @@\t\t\t\trbacv1helpers.NewRule(\"create\").Groups(legacyGroup).Resources(\"endpoints\", \"secrets\", \"serviceaccounts\").RuleOrDie(),\n\t\t\t\trbacv1helpers.NewRule(\"delete\").Groups(legacyGroup).Resources(\"secrets\").RuleOrDie(),\n\t\t\t\trbacv1helpers.NewRule(\"get\").Groups(legacyGroup).Resources(\"endpoints\", \"namespaces\", \"secrets\", \"serviceaccounts\", \"configmaps\").RuleOrDie(),\n\t\t\t\trbacv1helpers.NewRule(\"update\").Groups(legacyGroup).Resources(\"endpoints\", \"secrets\", \"serviceaccounts\").RuleOrDie(),\n\t\t\t\t// Needed to check API access.  These creates are non-mutating"
  },
  {
    "id" : "8aa988e4-80c6-4a46-91b2-47a447c83a08",
    "prId" : 59293,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/59293#pullrequestreview-94184603",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "21656638-5559-4cc0-96ee-e35912f6cf20",
        "parentId" : null,
        "authorId" : "695b6860-569c-4e63-a215-7342e2279a94",
        "body" : "Saving the place for `/openapi/v3` in future. Also, we will add `/openapi` (which returns list of supported versions) as a followup. ",
        "createdAt" : "2018-02-05T23:49:46Z",
        "updatedAt" : "2018-02-22T23:06:40Z",
        "lastEditedBy" : "695b6860-569c-4e63-a215-7342e2279a94",
        "tags" : [
        ]
      }
    ],
    "commit" : "17917940b5dfc516834980f0493cc241bcac4ab2",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +176,180 @@\t\t\t\t\t// move to a single openapi endpoint that takes accept/accept-encoding headers\n\t\t\t\t\t\"/swagger.json\", \"/swagger-2.0.0.pb-v1\",\n\t\t\t\t\t\"/openapi\", \"/openapi/*\",\n\t\t\t\t\t\"/api\", \"/api/*\",\n\t\t\t\t\t\"/apis\", \"/apis/*\","
  },
  {
    "id" : "5ec194ab-0b34-466b-aa7d-8823f271fd63",
    "prId" : 56533,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/56533#pullrequestreview-79901109",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3b056353-aa71-4ea0-8657-a175fcbab97c",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "will eventually (before exiting alpha) need a corresponding update in the node authorizer (similar to how the node authorizer only allows kubelets to access PV objects related to the node).\r\n\r\nHow does the kubelet know the name of the VolumeAttachment object to look up?",
        "createdAt" : "2017-11-29T03:26:23Z",
        "updatedAt" : "2017-12-02T10:55:19Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "ac5986b9-976f-4d15-9ccb-255e1306c5af",
        "parentId" : "3b056353-aa71-4ea0-8657-a175fcbab97c",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "csiMountMgr#SetUpAt appears to do a list:\r\n```go\r\n//TODO (vladimirvivien) consider using VolumesAttachments().Get() to retrieve\r\n//the object directly. This requires the ability to reconstruct the ID using volumeName+nodeName (nodename may not be avilable)\r\nattachList, err := c.k8s.StorageV1alpha1().VolumeAttachments().List(meta.ListOptions{})\r\n```\r\n\r\nlisting all storage objects isn't something nodes can do today. to get a particular VolumeAttachment, it looks like both the kubelet and the node authorizer would need to re-derive the VolumeAttachment name, presumably using this approach:\r\n```go\r\nfunc getAttachmentName(volName, nodeName string) string {\r\n\t// TODO consider using a different prefix for attachment\r\n\treturn fmt.Sprintf(\"pv-%s\", hashAttachmentName(volName, nodeName))\r\n}\r\n```\r\n\r\nis that name generation finalized and stable? once we have existent VolumeAttachment objects, we won't be able to easily change the naming scheme.",
        "createdAt" : "2017-11-29T03:41:33Z",
        "updatedAt" : "2017-12-02T10:55:19Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "cd0e84ff-181e-4878-b8b2-e0b37938fa34",
        "parentId" : "3b056353-aa71-4ea0-8657-a175fcbab97c",
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "> will eventually (before exiting alpha) need a corresponding update in the node authorizer (similar to how the node authorizer only allows kubelets to access PV objects related to the node).\r\n\r\nYep, have this on our list for beta.\r\n\r\n> How does the kubelet know the name of the VolumeAttachment object to look up?\r\n\r\nKubelet generates the name from the node and volume names (see https://github.com/kubernetes/kubernetes/blob/master/pkg/volume/csi/csi_attacher.go#L261).",
        "createdAt" : "2017-11-29T03:51:50Z",
        "updatedAt" : "2017-12-02T10:55:19Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      },
      {
        "id" : "4d78ba0c-6b2f-48e2-b114-e0e5e8b7c568",
        "parentId" : "3b056353-aa71-4ea0-8657-a175fcbab97c",
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "> csiMountMgr#SetUpAt appears to do a list:\r\n\r\nGood catch!\r\n\r\n> listing all storage objects isn't something nodes can do today. to get a particular VolumeAttachment, it looks like both the kubelet and the node authorizer would need to re-derive the VolumeAttachment name, presumably using this approach:\r\n\r\n@liggitt Would it be ok to give node permissions to List all `VolumeAttachment` objects for this alpha? We'll take it as a requirement to generate the `VolumeAttachment` name and do only Gets for beta.",
        "createdAt" : "2017-11-29T07:09:50Z",
        "updatedAt" : "2017-12-02T10:55:19Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      },
      {
        "id" : "e986931f-347a-45d2-bc45-443f2a1c7440",
        "parentId" : "3b056353-aa71-4ea0-8657-a175fcbab97c",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "> @liggitt Would it be ok to give node permissions to List all VolumeAttachment objects for this alpha?\r\n\r\nIf it's gated, off by default, and has a TODO in the policy file to switch to a get and enable the specific gets in the node authorizer, sure.\r\n\r\ncc me on the issue tracking the authorizer bits, I can help with that as well",
        "createdAt" : "2017-11-29T14:23:43Z",
        "updatedAt" : "2017-12-02T10:55:19Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "d99b82d8-7b1a-49d7-a9bc-2b36b85b03da",
        "parentId" : "3b056353-aa71-4ea0-8657-a175fcbab97c",
        "authorId" : "54b8eb75-28dd-421d-a52b-63bf897147a9",
        "body" : "@liggitt it will be feature-gated.  Will reach out for authorizer as well.",
        "createdAt" : "2017-11-29T16:06:52Z",
        "updatedAt" : "2017-12-02T10:55:19Z",
        "lastEditedBy" : "54b8eb75-28dd-421d-a52b-63bf897147a9",
        "tags" : [
        ]
      }
    ],
    "commit" : "179d8e108e81ff189727659b4fd72b01f501d6f0",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +147,151 @@\t// CSI\n\tif utilfeature.DefaultFeatureGate.Enabled(features.CSIPersistentVolume) {\n\t\tvolAttachRule := rbac.NewRule(\"get\").Groups(storageGroup).Resources(\"volumeattachments\").RuleOrDie()\n\t\tnodePolicyRules = append(nodePolicyRules, volAttachRule)\n\t}"
  },
  {
    "id" : "5fcdd006-c220-475d-a51b-f46f7643fede",
    "prId" : 55019,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/55019#pullrequestreview-99088713",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9fa7714d-8005-46d6-9c4b-af44e85a9a2e",
        "parentId" : null,
        "authorId" : "9f030d50-62db-4b00-a28c-847709b74d97",
        "body" : "Is this just for legacy nodes?",
        "createdAt" : "2018-02-23T23:40:23Z",
        "updatedAt" : "2018-02-26T21:46:28Z",
        "lastEditedBy" : "9f030d50-62db-4b00-a28c-847709b74d97",
        "tags" : [
        ]
      },
      {
        "id" : "74a61d12-e2a4-4a70-a7fe-282afbd5d153",
        "parentId" : "9fa7714d-8005-46d6-9c4b-af44e85a9a2e",
        "authorId" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "body" : "This is for people who haven't started using the node authorizer yet.",
        "createdAt" : "2018-02-24T00:14:56Z",
        "updatedAt" : "2018-02-26T21:46:28Z",
        "lastEditedBy" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "tags" : [
        ]
      }
    ],
    "commit" : "363e861aeb19b362e0ef0fa7fcd8f034d0dce17c",
    "line" : 8,
    "diffHunk" : "@@ -1,1 +151,155 @@\t\t// Use the NodeRestriction admission plugin to limit a node to create tokens bound to pods on that node\n\t\ttokenRequestRule := rbac.NewRule(\"create\").Groups(legacyGroup).Resources(\"serviceaccounts/token\").RuleOrDie()\n\t\tnodePolicyRules = append(nodePolicyRules, tokenRequestRule)\n\t}\n"
  },
  {
    "id" : "5b505681-5e61-4474-a4eb-22cdfe3f6297",
    "prId" : 54005,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/54005#pullrequestreview-73766032",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "54c3b608-bf8a-443b-8d62-6a4bc08da425",
        "parentId" : null,
        "authorId" : "e58080d6-2177-419f-a546-b51075d7bcb8",
        "body" : "Doesn't aggregation now allow us to define:\r\n\r\nadmin = `<new admin stuff>` + edit + view\r\nedit = `<new edit stuff>` + view\r\nview = `<new view stuff>`\r\n\r\nI know we have tests that make sure that admin covers edit and so on.  The counter argument would be \"I do not want to piece together 3 thing to understand what admin means\" - granted the YAML files should cover that case (but reading the union of a bunch of rules is probably harder).\r\n\r\n(This is mostly a thought, not really a suggestion).",
        "createdAt" : "2017-10-30T18:39:44Z",
        "updatedAt" : "2017-11-13T13:18:10Z",
        "lastEditedBy" : "e58080d6-2177-419f-a546-b51075d7bcb8",
        "tags" : [
        ]
      },
      {
        "id" : "2ffc5f5c-b17a-48fd-94d6-8147b2174d5a",
        "parentId" : "54c3b608-bf8a-443b-8d62-6a4bc08da425",
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "> I know we have tests that make sure that admin covers edit and so on. The counter argument would be \"I do not want to piece together 3 thing to understand what admin means\" - granted the YAML files should cover that case (but reading the union of a bunch of rules is probably harder).\r\n\r\nJordan and I debated how far to decompose this.  The two of us did not reach consensus, so we're pausing here for now.  Even if you want to do that, you can do it two way: admin can gather admins, edits, view or the constituent roles and tag themselves multiple ways.",
        "createdAt" : "2017-11-02T12:10:30Z",
        "updatedAt" : "2017-11-13T13:18:10Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      }
    ],
    "commit" : "f34fb9b0ab37daf71d2d246db7e13a88a41ff359",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +177,181 @@\t\t\t// a role for a namespace level admin.  It is `edit` plus the power to grant permissions to other users.\n\t\t\tObjectMeta: metav1.ObjectMeta{Name: \"admin\"},\n\t\t\tAggregationRule: &rbac.AggregationRule{\n\t\t\t\tClusterRoleSelectors: []metav1.LabelSelector{{MatchLabels: map[string]string{\"rbac.authorization.k8s.io/aggregate-to-admin\": \"true\"}}},\n\t\t\t},"
  },
  {
    "id" : "5d7aaa1a-63dd-4e8c-870d-86d24e0071b1",
    "prId" : 46076,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/46076#pullrequestreview-40442824",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e0d2465d-5492-4ad8-90ed-f4c66b8411f1",
        "parentId" : null,
        "authorId" : "0adf587c-aaa2-4e47-be0f-a26d4fde14ac",
        "body" : "github is terrible at handling moves - did anything change here?",
        "createdAt" : "2017-05-24T19:50:34Z",
        "updatedAt" : "2017-05-30T20:52:51Z",
        "lastEditedBy" : "0adf587c-aaa2-4e47-be0f-a26d4fde14ac",
        "tags" : [
        ]
      },
      {
        "id" : "56f60a0b-aaea-4ac9-bf04-d470fbcb3f18",
        "parentId" : "e0d2465d-5492-4ad8-90ed-f4c66b8411f1",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "no changes, straight move (verified by the [bootstrap role yaml serialization](https://github.com/kubernetes/kubernetes/blob/master/plugin/pkg/auth/authorizer/rbac/bootstrappolicy/testdata/cluster-roles.yaml#L597-L710) not changing)",
        "createdAt" : "2017-05-26T04:22:04Z",
        "updatedAt" : "2017-05-30T20:52:51Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "fc8e915a4bcfdd224d1ff625569a7af1a2766690",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +88,92 @@\nfunc NodeRules() []rbac.PolicyRule {\n\treturn []rbac.PolicyRule{\n\t\t// Needed to check API access.  These creates are non-mutating\n\t\trbac.NewRule(\"create\").Groups(authenticationGroup).Resources(\"tokenreviews\").RuleOrDie(),"
  },
  {
    "id" : "72a0172a-5c7e-41c7-9d1f-acc0ab219c5c",
    "prId" : 45427,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/45427#pullrequestreview-38748630",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4b1fbb71-00ba-403b-89c4-87f08718767c",
        "parentId" : null,
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "This is kind of scary.  It means the core controllers can see anything in the entire system, whereas before it had to be enumerated.  Not terribly different from the loopback controller, but means we don't have a resource that you can't add to garbage collector (like can you use this to fish for token names by doing timing channel attacks on the gc controller?).",
        "createdAt" : "2017-05-05T18:17:32Z",
        "updatedAt" : "2017-05-22T16:51:54Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "316e8c96-11b4-47dd-9a06-6d7b0537d065",
        "parentId" : "4b1fbb71-00ba-403b-89c4-87f08718767c",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "* Loopback client",
        "createdAt" : "2017-05-05T18:17:45Z",
        "updatedAt" : "2017-05-22T16:51:54Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "1772b3f4-5b3f-482f-a397-c0b9e2a5895c",
        "parentId" : "4b1fbb71-00ba-403b-89c4-87f08718767c",
        "authorId" : "b15d5707-82a8-4448-b49d-a2d6502b10f9",
        "body" : "I debated doing this vs enumerating. The problem with enumerating is that as new types are added, people likely will forget to add them to the policy, and then you'll see RBAC denials in the logs that may or may not be meaningful (depending on whether or not the new types need to participate in GC).\r\n\r\nAlso the current GC controller rule is exactly this, but it's scoped to the GC controller and not the controller-manager's client. So this does expand what the controller-manager client can list/watch, but it doesn't broaden the GC controller's powers, as they're already this broad.\r\n\r\nWe don't need to rush this PR in, so let's discuss how we want to proceed and I'll make the changes once we reach a consensus.",
        "createdAt" : "2017-05-05T18:21:06Z",
        "updatedAt" : "2017-05-22T16:51:54Z",
        "lastEditedBy" : "b15d5707-82a8-4448-b49d-a2d6502b10f9",
        "tags" : [
        ]
      },
      {
        "id" : "90330eb9-9b46-49d5-a49e-fe3873aad3de",
        "parentId" : "4b1fbb71-00ba-403b-89c4-87f08718767c",
        "authorId" : "b15d5707-82a8-4448-b49d-a2d6502b10f9",
        "body" : "@smarterclayton have you had any more time to think about this?",
        "createdAt" : "2017-05-16T15:11:33Z",
        "updatedAt" : "2017-05-22T16:51:54Z",
        "lastEditedBy" : "b15d5707-82a8-4448-b49d-a2d6502b10f9",
        "tags" : [
        ]
      },
      {
        "id" : "40070b21-caf0-42ae-a333-b22a2126ef5d",
        "parentId" : "4b1fbb71-00ba-403b-89c4-87f08718767c",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Game theory:\r\n\r\n1. We add a new resource which is super powerful and the garbage collection controller shouldn't have.\r\n2. We close the hole where garbage collector seeing secrets means it's root on the cluster anyway\r\n3. Would everyone have to migrate from `*` to a maintained list because 1 now shouldn't be given to GC?\r\n\r\nIs there anything more powerful than the GC controller already is (can delete everything in the cluster)?  Should the GC controller not control PodSecurityPolicy by default?  Should the GC controller control RBAC by default?",
        "createdAt" : "2017-05-16T22:05:45Z",
        "updatedAt" : "2017-05-22T16:51:54Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "6fa6fef3-9ef3-472e-8ffd-40881dd80d60",
        "parentId" : "4b1fbb71-00ba-403b-89c4-87f08718767c",
        "authorId" : "11efe503-096f-46dd-a8c8-28ba38a0157a",
        "body" : "@smarterclayton I would expect 1. the encryption in the storage to be configurable so I can encrypt more than secrets and 2. I could see the etcd write key being stored in its own TPR that I would probably not want the GC to have access to.",
        "createdAt" : "2017-05-17T07:46:36Z",
        "updatedAt" : "2017-05-22T16:51:54Z",
        "lastEditedBy" : "11efe503-096f-46dd-a8c8-28ba38a0157a",
        "tags" : [
        ]
      },
      {
        "id" : "c4535558-3b5e-4547-a110-f358197a1033",
        "parentId" : "4b1fbb71-00ba-403b-89c4-87f08718767c",
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "> Would everyone have to migrate from * to a maintained list because 1 now shouldn't be given to GC?\r\n\r\nSo we would expect anyone contributing an aggregated API server or a customresource will create another role and bind the garbage collector to it?  It could be done, but we should set the expectation now so we can start working through examples.",
        "createdAt" : "2017-05-17T11:26:45Z",
        "updatedAt" : "2017-05-22T16:51:54Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      },
      {
        "id" : "3dc11a1d-6f6a-47bd-9717-c73fea2b9578",
        "parentId" : "4b1fbb71-00ba-403b-89c4-87f08718767c",
        "authorId" : "b15d5707-82a8-4448-b49d-a2d6502b10f9",
        "body" : "> We add a new resource which is super powerful and the garbage collection controller shouldn't have.\r\n\r\nAdd it where - to the core? As a TPR? Via an extension apiserver? Or maybe it doesn't matter and the answer is just \"yes\" 😄.\r\n\r\nTo recap where we are today, in the master branch, without my PR:\r\n\r\n1. The GC controller client is allowed to get, list, watch, patch, update, and delete */* (https://github.com/kubernetes/kubernetes/blob/7b43f922aa059abfbbd9be1840499080cb7d6f54/plugin/pkg/auth/authorizer/rbac/bootstrappolicy/controller_policy.go#L129)\r\n1. The GC controller only sets up monitoring resources when it is constructed, and it doesn't refresh (e.g. to pick up new TPRs) unless I'm missing seeing it (https://github.com/kubernetes/kubernetes/blob/7b43f922aa059abfbbd9be1840499080cb7d6f54/pkg/controller/garbagecollector/garbagecollector.go#L98)\r\n\r\nMy PR grants the controller-manager the ability to list/watch */*, so all current and future shared informers can function without having to remember to modify the policy.\r\n\r\nMaybe we need to consider looking into a way to restrict which portions of the code (controllers) are allowed to use specific shared informers? Otherwise I don't have a good idea for how to use shared informers in the GC controller without granting list/watch of */* to the controller-manager client.",
        "createdAt" : "2017-05-17T18:17:22Z",
        "updatedAt" : "2017-05-22T16:51:54Z",
        "lastEditedBy" : "b15d5707-82a8-4448-b49d-a2d6502b10f9",
        "tags" : [
        ]
      }
    ],
    "commit" : "2480f2ceb669365a1991cceda890a836d405cd93",
    "line" : 32,
    "diffHunk" : "@@ -1,1 +306,310 @@\t\t\t\trbac.NewRule(\"create\").Groups(authenticationGroup).Resources(\"tokenreviews\").RuleOrDie(),\n\t\t\t\t// Needed for all shared informers\n\t\t\t\trbac.NewRule(\"list\", \"watch\").Groups(\"*\").Resources(\"*\").RuleOrDie(),\n\t\t\t},\n\t\t},"
  },
  {
    "id" : "bb0896fc-0fdd-4169-919c-85f1e106f679",
    "prId" : 40308,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/40308#pullrequestreview-19868819",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "cdde3990-a280-4b24-b6f0-8cb8903c3303",
        "parentId" : null,
        "authorId" : "2d9afee7-a404-4340-8fd9-d3187ed4f1da",
        "body" : "I see here that we're allowing the \"system:persistent-volume-provisioner\" _ClusterRole_ to read \"storageclass\" resources. The _ClusterRole_ \"edit\" allows subjects to create PVCs, which _mention_ these classes.\r\n\r\nShould we allow the \"edit\" _ClusterRole_ to also (get|list|watch) \"storageclass\" resources, so that they know which classes are available from which to choose? I asked the same question in [the \"sig-auth\" Slack channel](https://kubernetes.slack.com/archives/sig-auth/p1486050296002262).",
        "createdAt" : "2017-02-02T16:05:14Z",
        "updatedAt" : "2017-02-02T16:06:43Z",
        "lastEditedBy" : "2d9afee7-a404-4340-8fd9-d3187ed4f1da",
        "tags" : [
        ]
      },
      {
        "id" : "cea534f9-0bdf-4082-b7ec-b08e48ce00cf",
        "parentId" : "cdde3990-a280-4b24-b6f0-8cb8903c3303",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "the `edit` cluster role is intended to be granted within a particular namespace, so allowing access to `storageclasses` in it would not be effective. Read access to `storageclasses` would need to be in a clusterrole bound to users with a clusterrolebinding, similar to the `system:discovery` role.",
        "createdAt" : "2017-02-02T16:09:57Z",
        "updatedAt" : "2017-02-02T16:09:57Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "8986f530-7ecb-4be5-b098-bae1fdf181c4",
        "parentId" : "cdde3990-a280-4b24-b6f0-8cb8903c3303",
        "authorId" : "2d9afee7-a404-4340-8fd9-d3187ed4f1da",
        "body" : "Oh, right; I missed that point about the intended scope for the \"edit\" role.\r\n\r\nIs there a reason why we'd want to preclude users from reading these classes?\r\nIs there an existing _ClusterRole_ to which we could add this resource (\"view\" comes to mind), or does it warrant a new role?",
        "createdAt" : "2017-02-02T16:12:20Z",
        "updatedAt" : "2017-02-02T16:13:59Z",
        "lastEditedBy" : "2d9afee7-a404-4340-8fd9-d3187ed4f1da",
        "tags" : [
        ]
      },
      {
        "id" : "0a9ecacc-8698-436e-a4e8-aef21f290ee6",
        "parentId" : "cdde3990-a280-4b24-b6f0-8cb8903c3303",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "> \"view\" comes to mind\r\n\r\n\"view\" is also intended to be granted within a namespace. I'm not sure whether I'd consider this fundamental enough to be part of discovery or not. @deads2k, what do you think?",
        "createdAt" : "2017-02-02T16:20:47Z",
        "updatedAt" : "2017-02-02T16:20:47Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "01933c93-3d58-4b9e-9d13-0df172ebfbcc",
        "parentId" : "cdde3990-a280-4b24-b6f0-8cb8903c3303",
        "authorId" : "241ab19e-f85a-4d22-92e2-88f2b6287d14",
        "body" : "Correct me if I'm wrong, I think the best place for read access to storage classes to go would be `system:basicuser`, that's how it is in openshift & I assume this basicuser and that one are meant to be roughly equivalent. But in openshift they deliberately only allow `list`ing storage classes not, `get` nor `watch`, not sure if the same decision would be made here.",
        "createdAt" : "2017-02-02T16:24:35Z",
        "updatedAt" : "2017-02-02T16:24:35Z",
        "lastEditedBy" : "241ab19e-f85a-4d22-92e2-88f2b6287d14",
        "tags" : [
        ]
      },
      {
        "id" : "101936b3-1b05-4c81-9997-0480088c39a0",
        "parentId" : "cdde3990-a280-4b24-b6f0-8cb8903c3303",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "yeah, that's probably the right role, they don't change frequently enough for an end user to need to watch them. `list`+`get` wouldn't bother me",
        "createdAt" : "2017-02-02T16:25:48Z",
        "updatedAt" : "2017-02-02T16:26:18Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "f5007565-7ccb-46b2-ae7b-e8ea0e768602",
        "parentId" : "cdde3990-a280-4b24-b6f0-8cb8903c3303",
        "authorId" : "2d9afee7-a404-4340-8fd9-d3187ed4f1da",
        "body" : "In my cluster, we've bound \"view\" via _ClusterRoleBinding_ to a few namespace-related service accounts to allow them to see everything across the cluster. I didn't realize that was counter to its intention. We are perhaps a more promiscuous lot here, as we're still figuring out which namespaces are going to need to see which others.",
        "createdAt" : "2017-02-02T16:26:20Z",
        "updatedAt" : "2017-02-02T16:26:20Z",
        "lastEditedBy" : "2d9afee7-a404-4340-8fd9-d3187ed4f1da",
        "tags" : [
        ]
      },
      {
        "id" : "9b77df1a-1129-49e7-be89-732a7dce136a",
        "parentId" : "cdde3990-a280-4b24-b6f0-8cb8903c3303",
        "authorId" : "2d9afee7-a404-4340-8fd9-d3187ed4f1da",
        "body" : "[The nascent documentation for \"system:basic-user\" ](https://github.com/liggitt/kubernetes.github.io/blob/1d14da9c42266801c9ac13cb9608b9f8010dda49/docs/admin/authorization/rbac.md#default-clusterroles-and-clusterrolebindings)reads as follows:\r\n> A role that allows a user read-only access to basic information about themselves.\r\n\r\nIncluding \"storagclass\" resources would go beyond \"themselves.\" Does that concern you?",
        "createdAt" : "2017-02-02T16:30:53Z",
        "updatedAt" : "2017-02-02T16:30:53Z",
        "lastEditedBy" : "2d9afee7-a404-4340-8fd9-d3187ed4f1da",
        "tags" : [
        ]
      },
      {
        "id" : "c0e2d515-1fbc-48f9-9fb2-7b07fdc5c668",
        "parentId" : "cdde3990-a280-4b24-b6f0-8cb8903c3303",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "a little. balance between granularity of roles and usability of many roles is tough.",
        "createdAt" : "2017-02-02T16:32:44Z",
        "updatedAt" : "2017-02-02T16:32:44Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "d7c819c2-21cd-4063-9a79-b38823031938",
        "parentId" : "cdde3990-a280-4b24-b6f0-8cb8903c3303",
        "authorId" : "2d9afee7-a404-4340-8fd9-d3187ed4f1da",
        "body" : "Thank you for the discussion.\r\nI'll prepare a proposal later this afternoon and reference it from here.",
        "createdAt" : "2017-02-02T17:05:27Z",
        "updatedAt" : "2017-02-02T17:05:28Z",
        "lastEditedBy" : "2d9afee7-a404-4340-8fd9-d3187ed4f1da",
        "tags" : [
        ]
      },
      {
        "id" : "5a1b25b5-4c2a-4163-869b-700820d4434f",
        "parentId" : "cdde3990-a280-4b24-b6f0-8cb8903c3303",
        "authorId" : "2d9afee7-a404-4340-8fd9-d3187ed4f1da",
        "body" : "See #40881.",
        "createdAt" : "2017-02-02T19:24:31Z",
        "updatedAt" : "2017-02-02T19:24:31Z",
        "lastEditedBy" : "2d9afee7-a404-4340-8fd9-d3187ed4f1da",
        "tags" : [
        ]
      }
    ],
    "commit" : "caefe1a9ed14cec79778dcf9ccc07fb843b3b44c",
    "line" : 11,
    "diffHunk" : "@@ -1,1 +292,296 @@\t\t\t\t// update is needed in addition to read access for setting lock annotations on PVCs\n\t\t\t\trbac.NewRule(\"get\", \"list\", \"watch\", \"update\").Groups(legacyGroup).Resources(\"persistentvolumeclaims\").RuleOrDie(),\n\t\t\t\trbac.NewRule(Read...).Groups(storageGroup).Resources(\"storageclasses\").RuleOrDie(),\n\n\t\t\t\t// Needed for watching provisioning success and failure events"
  },
  {
    "id" : "c5b050f9-6c52-4eb0-a720-764bec1a9305",
    "prId" : 39683,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/39683#pullrequestreview-23792157",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d1660624-1662-4ea2-80e0-51bfcac159fe",
        "parentId" : null,
        "authorId" : "11efe503-096f-46dd-a8c8-28ba38a0157a",
        "body" : "So the admin seems to be able to update status for other resources (eg. replicationcontrollers)",
        "createdAt" : "2017-02-24T16:45:00Z",
        "updatedAt" : "2017-03-01T14:14:54Z",
        "lastEditedBy" : "11efe503-096f-46dd-a8c8-28ba38a0157a",
        "tags" : [
        ]
      },
      {
        "id" : "0a511042-2578-4d77-a4b6-1875ca100a51",
        "parentId" : "d1660624-1662-4ea2-80e0-51bfcac159fe",
        "authorId" : "11efe503-096f-46dd-a8c8-28ba38a0157a",
        "body" : "Sorry, only read",
        "createdAt" : "2017-02-24T16:46:13Z",
        "updatedAt" : "2017-03-01T14:14:54Z",
        "lastEditedBy" : "11efe503-096f-46dd-a8c8-28ba38a0157a",
        "tags" : [
        ]
      },
      {
        "id" : "e314f020-7f1d-411c-a25a-f4b4b85071c5",
        "parentId" : "d1660624-1662-4ea2-80e0-51bfcac159fe",
        "authorId" : "11efe503-096f-46dd-a8c8-28ba38a0157a",
        "body" : "edit and view also need to be able to read /status",
        "createdAt" : "2017-02-24T16:47:34Z",
        "updatedAt" : "2017-03-01T14:14:54Z",
        "lastEditedBy" : "11efe503-096f-46dd-a8c8-28ba38a0157a",
        "tags" : [
        ]
      },
      {
        "id" : "429a4ecb-db67-4270-8415-dcfac5ce5127",
        "parentId" : "d1660624-1662-4ea2-80e0-51bfcac159fe",
        "authorId" : "b7d2a698-a6e1-4031-bb69-8b45505badb5",
        "body" : "Double-checked with @deads2k and it's not necessary. Since they can get that information by getting the entire object. If it's needed we can always add afterwards.",
        "createdAt" : "2017-02-24T19:24:59Z",
        "updatedAt" : "2017-03-01T14:14:54Z",
        "lastEditedBy" : "b7d2a698-a6e1-4031-bb69-8b45505badb5",
        "tags" : [
        ]
      }
    ],
    "commit" : "18f756cea83aed50839e9684a40466d6d56ed5bb",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +129,133 @@\n\t\t\t\trbac.NewRule(ReadWrite...).Groups(appsGroup).Resources(\"statefulsets\",\n\t\t\t\t\t\"deployments\", \"deployments/scale\", \"deployments/rollback\").RuleOrDie(),\n\n\t\t\t\trbac.NewRule(ReadWrite...).Groups(autoscalingGroup).Resources(\"horizontalpodautoscalers\").RuleOrDie(),"
  },
  {
    "id" : "38218146-bcfc-453d-906d-7be2f793583e",
    "prId" : 36568,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/36568#pullrequestreview-9450991",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f9a94fb6-c497-45da-9623-fbbbbc452595",
        "parentId" : null,
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "Same label on the rolebindings.  Your previous argument stands.",
        "createdAt" : "2016-11-21T13:30:42Z",
        "updatedAt" : "2016-12-07T01:10:39Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      }
    ],
    "commit" : "1d475edd1c8d53e080273b9d1d405075e44208dd",
    "line" : null,
    "diffHunk" : "@@ -1,1 +235,239 @@}\n\n// ClusterRoleBindings return default rolebindings to the default roles\nfunc ClusterRoleBindings() []rbac.ClusterRoleBinding {\n\trolebindings := []rbac.ClusterRoleBinding{"
  },
  {
    "id" : "90fc7ea0-3a9c-47ed-a830-fda863c40dc8",
    "prId" : 34729,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/34729#pullrequestreview-4335642",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "90f1db16-b90b-437c-95d1-871a8e8f8833",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "comment to explain why we're not using the package constants for these or someone will refactor later to add them\n",
        "createdAt" : "2016-10-14T20:05:31Z",
        "updatedAt" : "2016-10-17T13:04:20Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "9ee0276b-970c-4a24-bfe7-f779172ed517",
        "parentId" : "90f1db16-b90b-437c-95d1-871a8e8f8833",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "make these consts\n",
        "createdAt" : "2016-10-14T20:05:59Z",
        "updatedAt" : "2016-10-17T13:04:20Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "d56a27f130efe3b841cf2358c7ccbd2c03d932c8",
    "line" : null,
    "diffHunk" : "@@ -1,1 +29,33 @@\nconst (\n\tlegacyGroup         = \"\"\n\tappsGroup           = \"apps\"\n\tauthenticationGroup = \"authentication.k8s.io\""
  },
  {
    "id" : "dce6fbce-790a-4a51-96c5-406f44a3b44f",
    "prId" : 34729,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/34729#pullrequestreview-4335642",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f92d587a-b2e9-41a3-b492-685ac0950c86",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "read access to the `namespaces` resource is worth separating and explaining\n",
        "createdAt" : "2016-10-14T20:12:23Z",
        "updatedAt" : "2016-10-17T13:04:20Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "d56a27f130efe3b841cf2358c7ccbd2c03d932c8",
    "line" : 46,
    "diffHunk" : "@@ -1,1 +106,110 @@\t\t\t\trbac.NewRule(ReadWrite...).Groups(legacyGroup).Resources(\"replicationcontrollers\", \"replicationcontrollers/scale\", \"serviceaccounts\",\n\t\t\t\t\t\"services\", \"services/proxy\", \"endpoints\", \"persistentvolumeclaims\", \"configmaps\", \"secrets\").RuleOrDie(),\n\t\t\t\trbac.NewRule(Read...).Groups(legacyGroup).Resources(\"limitranges\", \"resourcequotas\", \"bindings\", \"events\",\n\t\t\t\t\t\"pods/status\", \"resourcequotas/status\", \"namespaces/status\", \"replicationcontrollers/status\", \"pods/log\").RuleOrDie(),\n\t\t\t\t// read access to namespaces at the namespace scope means you can read *this* namespace.  This can be used as an"
  },
  {
    "id" : "22b41921-0fc2-4ac5-a442-fa1e08c63bab",
    "prId" : 34729,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/34729#pullrequestreview-4335642",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "31c3efc4-3f9a-48a0-9846-777621dc05df",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "same separation/comment on `namespaces`\n",
        "createdAt" : "2016-10-14T20:55:28Z",
        "updatedAt" : "2016-10-17T13:04:20Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "d56a27f130efe3b841cf2358c7ccbd2c03d932c8",
    "line" : 100,
    "diffHunk" : "@@ -1,1 +130,134 @@\t\t\t\trbac.NewRule(Read...).Groups(legacyGroup).Resources(\"pods\", \"replicationcontrollers\", \"replicationcontrollers/scale\", \"serviceaccounts\",\n\t\t\t\t\t\"services\", \"endpoints\", \"persistentvolumeclaims\", \"configmaps\").RuleOrDie(),\n\t\t\t\trbac.NewRule(Read...).Groups(legacyGroup).Resources(\"limitranges\", \"resourcequotas\", \"bindings\", \"events\",\n\t\t\t\t\t\"pods/status\", \"resourcequotas/status\", \"namespaces/status\", \"replicationcontrollers/status\", \"pods/log\").RuleOrDie(),\n\t\t\t\t// read access to namespaces at the namespace scope means you can read *this* namespace.  This can be used as an"
  },
  {
    "id" : "0f0ee50f-b228-482d-a7db-b354935c2131",
    "prId" : 34729,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/34729#pullrequestreview-4335642",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "05879277-fc03-401a-bd8d-2024a0611769",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "same separation/comment on `namespaces`\n",
        "createdAt" : "2016-10-14T21:07:26Z",
        "updatedAt" : "2016-10-17T13:04:20Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "d56a27f130efe3b841cf2358c7ccbd2c03d932c8",
    "line" : 46,
    "diffHunk" : "@@ -1,1 +106,110 @@\t\t\t\trbac.NewRule(ReadWrite...).Groups(legacyGroup).Resources(\"replicationcontrollers\", \"replicationcontrollers/scale\", \"serviceaccounts\",\n\t\t\t\t\t\"services\", \"services/proxy\", \"endpoints\", \"persistentvolumeclaims\", \"configmaps\", \"secrets\").RuleOrDie(),\n\t\t\t\trbac.NewRule(Read...).Groups(legacyGroup).Resources(\"limitranges\", \"resourcequotas\", \"bindings\", \"events\",\n\t\t\t\t\t\"pods/status\", \"resourcequotas/status\", \"namespaces/status\", \"replicationcontrollers/status\", \"pods/log\").RuleOrDie(),\n\t\t\t\t// read access to namespaces at the namespace scope means you can read *this* namespace.  This can be used as an"
  },
  {
    "id" : "489ba913-d43c-41d4-94ae-0643c38e52f4",
    "prId" : 33296,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/33296#pullrequestreview-1250980",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3126c176-51cd-4312-9444-e5d699da61fa",
        "parentId" : null,
        "authorId" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "body" : "Why do you use the `system:` prefix?  It is not like usernames or groupnames, where there is no collision control.  For objects like ClusterRoles, the apiserver provides collision control based on names.\n",
        "createdAt" : "2016-09-22T23:30:45Z",
        "updatedAt" : "2016-09-26T15:27:30Z",
        "lastEditedBy" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "tags" : [
        ]
      }
    ],
    "commit" : "4e2f8196958acbdf36fcd18cee3fa65526d877e1",
    "line" : null,
    "diffHunk" : "@@ -1,1 +42,46 @@\t\t{\n\t\t\t// a role which provides just enough power to discovery API versions for negotiation\n\t\t\tObjectMeta: api.ObjectMeta{Name: \"system:discovery\"},\n\t\t\tRules: []rbac.PolicyRule{\n\t\t\t\trbac.NewRule(\"get\").URLs(\"/version\", \"/api\", \"/api/*\", \"/apis\", \"/apis/*\").RuleOrDie(),"
  }
]
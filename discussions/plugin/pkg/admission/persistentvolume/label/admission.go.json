[
  {
    "id" : "ca1e6db6-33f1-4f6d-bb37-0a7710ff19d8",
    "prId" : 40537,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/40537#pullrequestreview-24140679",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "98f202ce-bd5c-458c-b03f-8f6ea78e8311",
        "parentId" : null,
        "authorId" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "body" : "Is it possible to process the config file outside of the plugin, and pass in the cloudProvider object instead?  I'm not sure if there's a function to get the current cloud provider?",
        "createdAt" : "2017-02-28T00:58:58Z",
        "updatedAt" : "2017-02-28T17:24:24Z",
        "lastEditedBy" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "tags" : [
        ]
      },
      {
        "id" : "59d5b6e7-c230-4bb3-99cd-2a0c6f48805c",
        "parentId" : "98f202ce-bd5c-458c-b03f-8f6ea78e8311",
        "authorId" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "body" : "It is possible at least for kube-apiserver, since we already have a cloud object initialized there. It wouldn't work for federation api server though. \r\n\r\nWhat are we looking to gain by passing cloudprovider object instead of configuration bytes?",
        "createdAt" : "2017-02-28T01:05:36Z",
        "updatedAt" : "2017-02-28T17:24:24Z",
        "lastEditedBy" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "tags" : [
        ]
      },
      {
        "id" : "c8f613df-1bc4-40e7-94b2-b779f914ffb6",
        "parentId" : "98f202ce-bd5c-458c-b03f-8f6ea78e8311",
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "Ideally the mechanism by which to read/write the config file should be in a single place (`cloudprovider` lib makes the most sense) instead of duplicated and sprinkled throughout the code.",
        "createdAt" : "2017-02-28T01:22:31Z",
        "updatedAt" : "2017-02-28T17:24:24Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      },
      {
        "id" : "e3f7afae-3541-4b76-98a8-e3708fc8e90c",
        "parentId" : "98f202ce-bd5c-458c-b03f-8f6ea78e8311",
        "authorId" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "body" : "okay, that sounds fair. However, federation api sever is in this weird place where it accepts same set of arguments as api server but sometimes doesn't do anything with them. \r\n\r\nI do not want to initialize cloudprovider in federation server as part of this change because I don't know what their expectations are. If we are going to directly pass cloudprovider then I will pass `nil` from federation apiserver until they decide to initialize cloudprovider in their code and  it becomes available. Does it sound good?",
        "createdAt" : "2017-02-28T01:29:29Z",
        "updatedAt" : "2017-02-28T17:24:24Z",
        "lastEditedBy" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "tags" : [
        ]
      },
      {
        "id" : "87c28d56-c23e-4eeb-981f-dc0d0beb5d26",
        "parentId" : "98f202ce-bd5c-458c-b03f-8f6ea78e8311",
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "SGTM",
        "createdAt" : "2017-02-28T01:31:47Z",
        "updatedAt" : "2017-02-28T17:24:24Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      }
    ],
    "commit" : "b0581d688dc7da52eea2be8ba62b3ca26f4f270d",
    "line" : 49,
    "diffHunk" : "@@ -1,1 +145,149 @@\t\t\tcloudConfigReader = bytes.NewReader(l.cloudConfig)\n\t\t}\n\t\tcloudProvider, err := cloudprovider.GetCloudProvider(\"aws\", cloudConfigReader)\n\t\tif err != nil || cloudProvider == nil {\n\t\t\treturn nil, err"
  },
  {
    "id" : "f8c4d027-e6c6-46bb-984c-df6ef49164c0",
    "prId" : 40537,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/40537#pullrequestreview-24138014",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e6f8efd8-1b86-4e7c-8407-efa3d18b5e03",
        "parentId" : null,
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "Add a compile time interface compliance check:\r\n\r\n ```GO\r\nvar _ WantsCloudConfig = &persistentVolumeLabel{}\r\n```",
        "createdAt" : "2017-02-28T01:01:48Z",
        "updatedAt" : "2017-02-28T17:24:24Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      },
      {
        "id" : "1f096edb-369f-4534-a1a5-9d0f25ebe9d0",
        "parentId" : "e6f8efd8-1b86-4e7c-8407-efa3d18b5e03",
        "authorId" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "body" : "ack",
        "createdAt" : "2017-02-28T01:11:45Z",
        "updatedAt" : "2017-02-28T17:24:24Z",
        "lastEditedBy" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "tags" : [
        ]
      }
    ],
    "commit" : "b0581d688dc7da52eea2be8ba62b3ca26f4f270d",
    "line" : 33,
    "diffHunk" : "@@ -1,1 +63,67 @@}\n\nfunc (l *persistentVolumeLabel) SetCloudConfig(cloudConfig []byte) {\n\tl.cloudConfig = cloudConfig\n}"
  },
  {
    "id" : "96240037-1154-4fff-8b48-bf93aff8b977",
    "prId" : 19995,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "444bec1a-bf23-4545-8be7-6db829e95fda",
        "parentId" : null,
        "authorId" : null,
        "body" : "Can we avoid putting provider-specific fields in this provider-independent library?\n",
        "createdAt" : "2016-01-22T19:13:36Z",
        "updatedAt" : "2016-01-22T22:16:46Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "270434f0-dc26-4f23-b5fe-bab3435c42b8",
        "parentId" : "444bec1a-bf23-4545-8be7-6db829e95fda",
        "authorId" : "8fc8f958-3c0e-47dd-a0fb-b8cc483b4efb",
        "body" : "I don't see how - suggestions welcome.\n\nI wanted to implement a Volumes interface, and you can see from the AWS implementation that I did.  It was originally intended to be cross-cloud provider, but there were a number of objections raised so I moved Volumes into the aws package.  The primary objection was (I believe) that a cloud could implement different types of volumes (e.g. even AWS has NFS & EBS now).\n\nAnd volume.Spec isn't provider independent either.\n\nOne option would be to define aws.Volumes in cloudprovider, but have it take a PersistentVolumeSource.  But that isn't quite right either, and would be a fairly large refactor.\n\nIn short, I'd love to, but I don't see how to do it in an acceptable way.\n",
        "createdAt" : "2016-01-22T20:32:20Z",
        "updatedAt" : "2016-01-22T22:16:46Z",
        "lastEditedBy" : "8fc8f958-3c0e-47dd-a0fb-b8cc483b4efb",
        "tags" : [
        ]
      },
      {
        "id" : "6b8f6186-6991-4526-82a2-a525cc0df4ac",
        "parentId" : "444bec1a-bf23-4545-8be7-6db829e95fda",
        "authorId" : null,
        "body" : "Fair enough.  I'm happy for us to perhaps try to take on a refactor in a separate PR, after v 1.2.\n",
        "createdAt" : "2016-01-22T21:11:50Z",
        "updatedAt" : "2016-01-22T22:16:46Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "f5386d2c-c0ad-4314-81f4-02f548e5f59d",
        "parentId" : "444bec1a-bf23-4545-8be7-6db829e95fda",
        "authorId" : "727fc82d-d969-41a4-a614-7fefce94f9a6",
        "body" : "If volumes are plugins and Kubelet (and others) don't know what plugins exist, anything that escapes those packages is leaky.\n\nWould we instead want to give the same list of plugins to the API server that we give to Kubelet and ControllerManager?\n\nThe API server would do the same iteration and CanSupport on each plugin, find the appropriate one, and call Validate(pv) and Admit(pv).\n\nEach volume would know how to validate itself in the API.  Missing plugins would cause a real API error.  Any business logic regarding labelling and so forth is also internalized to the plugin.\n\n@thockin thoughts?\n",
        "createdAt" : "2016-02-11T13:23:41Z",
        "updatedAt" : "2016-02-11T13:23:41Z",
        "lastEditedBy" : "727fc82d-d969-41a4-a614-7fefce94f9a6",
        "tags" : [
        ]
      }
    ],
    "commit" : "88eeec4f13579c3c80be1ee59143c66af7e50d91",
    "line" : 16,
    "diffHunk" : "@@ -1,1 +44,48 @@\tmutex            sync.Mutex\n\tebsVolumes       aws.Volumes\n\tgceCloudProvider *gce.GCECloud\n}\n"
  },
  {
    "id" : "da2f3052-9f81-4937-b23d-ffe6123dbc16",
    "prId" : 19995,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "04b645ee-9fad-41e9-9c1d-3f10e35f8b44",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "@markturansky @saad-ali This should be part of volume plugins, I think.  It should NOT be an open-coded list of cases.  I'll file a new issue.\n",
        "createdAt" : "2016-02-11T08:07:28Z",
        "updatedAt" : "2016-02-11T08:07:28Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "9fbc5962-5ff4-47c1-af61-1efc83322424",
        "parentId" : "04b645ee-9fad-41e9-9c1d-3f10e35f8b44",
        "authorId" : "8fc8f958-3c0e-47dd-a0fb-b8cc483b4efb",
        "body" : "Yes - this came up in review a few lines up ^^^.  I agree with the criticism, but it isn't clear to me how best to fix it.\n",
        "createdAt" : "2016-02-11T13:56:04Z",
        "updatedAt" : "2016-02-11T13:56:04Z",
        "lastEditedBy" : "8fc8f958-3c0e-47dd-a0fb-b8cc483b4efb",
        "tags" : [
        ]
      }
    ],
    "commit" : "88eeec4f13579c3c80be1ee59143c66af7e50d91",
    "line" : 24,
    "diffHunk" : "@@ -1,1 +78,82 @@\t\tvolumeLabels = labels\n\t}\n\tif volume.Spec.GCEPersistentDisk != nil {\n\t\tlabels, err := l.findGCEPDLabels(volume)\n\t\tif err != nil {"
  },
  {
    "id" : "1260cd14-8a81-401a-8f0b-c1c1f516c152",
    "prId" : 19995,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "82ba7683-d420-4baf-abfd-45b8b463346b",
        "parentId" : null,
        "authorId" : "727fc82d-d969-41a4-a614-7fefce94f9a6",
        "body" : "This broke provisioning (because we don't have an e2e test that would have prevented this change).\n\nThe provisioner creates a dummy PV in response to a claim that requires provisioning.  The \"dummy\" ID on the struct was required to pass validation. A controller reconciles this PV with the infrastructure and creates a resource asynchronously.\n\nThere is no \"dummy\" PD in the provider yet, so we can't look it up for labels.  This admission controller makes it required that the PD exist.  It could be, too, that making a placeholder PV is wrong.  I am open to suggestions.\n",
        "createdAt" : "2016-02-11T13:27:53Z",
        "updatedAt" : "2016-02-11T13:27:53Z",
        "lastEditedBy" : "727fc82d-d969-41a4-a614-7fefce94f9a6",
        "tags" : [
        ]
      },
      {
        "id" : "2ddc4c6b-b1eb-4180-ab57-8e6246a2df7a",
        "parentId" : "82ba7683-d420-4baf-abfd-45b8b463346b",
        "authorId" : "8fc8f958-3c0e-47dd-a0fb-b8cc483b4efb",
        "body" : "I opened #20564 to track the lack of e2e coverage and #20955 to track the AWS problem, but I didn't realize this had broken it on GCE also.  Sorry!\n\nFor AWS, I was thinking of creating a volume with a well-known dummy name, which would then be ignored.  But that is pretty evil...\n",
        "createdAt" : "2016-02-11T13:56:45Z",
        "updatedAt" : "2016-02-11T13:56:45Z",
        "lastEditedBy" : "8fc8f958-3c0e-47dd-a0fb-b8cc483b4efb",
        "tags" : [
        ]
      },
      {
        "id" : "bc06cb33-1dc4-436a-921c-9ca72ece3985",
        "parentId" : "82ba7683-d420-4baf-abfd-45b8b463346b",
        "authorId" : "727fc82d-d969-41a4-a614-7fefce94f9a6",
        "body" : "we can put the \"dummy\" constant in pkg/volume (as opposed to a plugin) and use that in admission and the plugins themselves.\n\nit is leaky as hell but is far less work than adding plugins and a framework to the API server.  Should we consider it as a short term fix until we come up with a better way?\n",
        "createdAt" : "2016-02-11T14:13:59Z",
        "updatedAt" : "2016-02-11T14:13:59Z",
        "lastEditedBy" : "727fc82d-d969-41a4-a614-7fefce94f9a6",
        "tags" : [
        ]
      }
    ],
    "commit" : "88eeec4f13579c3c80be1ee59143c66af7e50d91",
    "line" : 27,
    "diffHunk" : "@@ -1,1 +81,85 @@\t\tlabels, err := l.findGCEPDLabels(volume)\n\t\tif err != nil {\n\t\t\treturn admission.NewForbidden(a, fmt.Errorf(\"error querying GCE PD volume %s: %v\", volume.Spec.GCEPersistentDisk.PDName, err))\n\t\t}\n\t\tvolumeLabels = labels"
  }
]
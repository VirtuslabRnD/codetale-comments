[
  {
    "id" : "d8bb38bf-ad6c-4afe-a6e9-33c9d014f715",
    "prId" : 38167,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/38167#pullrequestreview-14075304",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "876fe463-58eb-450a-a820-ea958ebac017",
        "parentId" : null,
        "authorId" : "227eb550-8b08-4420-9a78-279f840bd8de",
        "body" : "@ericchiang why we need to deepcopy header here?\r\nhttps://play.golang.org/p/rxM2ogR1GS",
        "createdAt" : "2016-12-21T19:57:16Z",
        "updatedAt" : "2016-12-22T22:19:26Z",
        "lastEditedBy" : "227eb550-8b08-4420-9a78-279f840bd8de",
        "tags" : [
        ]
      },
      {
        "id" : "89acc53b-ad50-4301-81dc-0b27bbce62f5",
        "parentId" : "876fe463-58eb-450a-a820-ea958ebac017",
        "authorId" : "0af48e59-4be9-46ce-9275-aa218813b6fd",
        "body" : "To comply with the RoundTripper interface\r\n\r\n> RoundTrip should not modify the request...\r\n\r\nhttps://golang.org/pkg/net/http/#RoundTripper\r\n\r\nIf we don't copy deepcopy the header then we're adding a bearer toke to the original header, modifying the original request.\r\n",
        "createdAt" : "2016-12-21T23:26:45Z",
        "updatedAt" : "2016-12-22T22:19:26Z",
        "lastEditedBy" : "0af48e59-4be9-46ce-9275-aa218813b6fd",
        "tags" : [
        ]
      },
      {
        "id" : "b9648ede-3c0d-4ea2-acde-88c1d74c4306",
        "parentId" : "876fe463-58eb-450a-a820-ea958ebac017",
        "authorId" : "0af48e59-4be9-46ce-9275-aa218813b6fd",
        "body" : "Same logic as the oauth2 package https://github.com/golang/oauth2/blob/314dd2c0bf3ebd592ec0d20847d27e79d0dbe8dd/transport.go#L94-L106",
        "createdAt" : "2016-12-21T23:27:44Z",
        "updatedAt" : "2016-12-22T22:19:26Z",
        "lastEditedBy" : "0af48e59-4be9-46ce-9275-aa218813b6fd",
        "tags" : [
        ]
      },
      {
        "id" : "ae767261-76fd-43cd-ac29-a7d391a5492e",
        "parentId" : "876fe463-58eb-450a-a820-ea958ebac017",
        "authorId" : "227eb550-8b08-4420-9a78-279f840bd8de",
        "body" : "@ericchiang Gotcha.",
        "createdAt" : "2016-12-22T00:06:24Z",
        "updatedAt" : "2016-12-22T22:19:26Z",
        "lastEditedBy" : "227eb550-8b08-4420-9a78-279f840bd8de",
        "tags" : [
        ]
      }
    ],
    "commit" : "13e6318cb0088a849fc1990e7c62dd339ea64378",
    "line" : 253,
    "diffHunk" : "@@ -1,1 +231,235 @@\t\tr2.Header[k] = s\n\t}\n\tr2.Header.Set(\"Authorization\", fmt.Sprintf(\"Bearer %s\", token))\n\n\treturn r.wrapped.RoundTrip(r2)"
  },
  {
    "id" : "fab88735-ff09-451f-82e7-ec05a8d5e2f3",
    "prId" : 38167,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/38167#pullrequestreview-14075800",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "cc3980ea-7d25-44fd-8c74-783ad8e44cba",
        "parentId" : null,
        "authorId" : "227eb550-8b08-4420-9a78-279f840bd8de",
        "body" : "why we want to return the old client?\r\nif we want to use the old client when it's there we can always do getClient() first.\r\n\r\nIn fact, the newOIDCAuthProvider() function below, the setClient() is always returning the latest client.",
        "createdAt" : "2016-12-21T20:03:55Z",
        "updatedAt" : "2016-12-22T22:19:26Z",
        "lastEditedBy" : "227eb550-8b08-4420-9a78-279f840bd8de",
        "tags" : [
        ]
      },
      {
        "id" : "366d7dac-1815-41e2-af03-d9b20837dd45",
        "parentId" : "cc3980ea-7d25-44fd-8c74-783ad8e44cba",
        "authorId" : "0af48e59-4be9-46ce-9275-aa218813b6fd",
        "body" : "If both routine A and B try to initialize at the same time, and A success and puts it in the cache, we want B to use A's client rather than the one it managed to create. We have the cache to always return the same client for each provider so it can guard the kubeconfig with the same mutex.",
        "createdAt" : "2016-12-21T23:24:44Z",
        "updatedAt" : "2016-12-22T22:19:26Z",
        "lastEditedBy" : "0af48e59-4be9-46ce-9275-aa218813b6fd",
        "tags" : [
        ]
      },
      {
        "id" : "35f5caeb-886d-4a0c-8f20-7c851d8e3680",
        "parentId" : "cc3980ea-7d25-44fd-8c74-783ad8e44cba",
        "authorId" : "0af48e59-4be9-46ce-9275-aa218813b6fd",
        "body" : "Let me add a comment.",
        "createdAt" : "2016-12-21T23:25:31Z",
        "updatedAt" : "2016-12-22T22:19:26Z",
        "lastEditedBy" : "0af48e59-4be9-46ce-9275-aa218813b6fd",
        "tags" : [
        ]
      },
      {
        "id" : "e83f2211-6f0f-4335-be46-f72e686cb5f5",
        "parentId" : "cc3980ea-7d25-44fd-8c74-783ad8e44cba",
        "authorId" : "227eb550-8b08-4420-9a78-279f840bd8de",
        "body" : "@ericchiang I see, it's a testAndSet operation, maybe rename the func, or leave it as is with some comments, ok with either. Thanks 👍 ",
        "createdAt" : "2016-12-22T00:11:27Z",
        "updatedAt" : "2016-12-22T22:19:26Z",
        "lastEditedBy" : "227eb550-8b08-4420-9a78-279f840bd8de",
        "tags" : [
        ]
      }
    ],
    "commit" : "13e6318cb0088a849fc1990e7c62dd339ea64378",
    "line" : null,
    "diffHunk" : "@@ -1,1 +99,103 @@\t// share a client and can coordinate around the same mutex when refreshing and writing\n\t// to the kubeconfig.\n\tif oldClient, ok := c.cache[key]; ok {\n\t\treturn oldClient\n\t}"
  },
  {
    "id" : "e7285b44-9b2d-42cc-a8fb-6fcd5ab32ae5",
    "prId" : 25270,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b347544d-3c33-45bf-aa6a-7c8b0a6ffd34",
        "parentId" : null,
        "authorId" : "e5975294-c47f-41e1-b753-2d15be8ac5bb",
        "body" : "@bobbyrullo This seems to create the same issues as https://github.com/kubernetes/kubernetes/issues/29749\n",
        "createdAt" : "2016-08-15T13:30:37Z",
        "updatedAt" : "2016-08-15T13:30:37Z",
        "lastEditedBy" : "e5975294-c47f-41e1-b753-2d15be8ac5bb",
        "tags" : [
        ]
      },
      {
        "id" : "a1ada0e1-bbe3-42ce-b4bf-c46271b82880",
        "parentId" : "b347544d-3c33-45bf-aa6a-7c8b0a6ffd34",
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "> @bobbyrullo This seems to create the same issues as #29749\n\n@ericchiang not sure if there's something you need to do here.\n",
        "createdAt" : "2016-08-15T15:03:09Z",
        "updatedAt" : "2016-08-15T15:03:09Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      },
      {
        "id" : "02754e33-fc5d-4c78-b034-b7404622ccc1",
        "parentId" : "b347544d-3c33-45bf-aa6a-7c8b0a6ffd34",
        "authorId" : "0af48e59-4be9-46ce-9275-aa218813b6fd",
        "body" : "Sorry, I haven't looked at this code for a second. Will send a PR to not trim the trailing slash.\n",
        "createdAt" : "2016-08-15T16:53:14Z",
        "updatedAt" : "2016-08-15T16:53:14Z",
        "lastEditedBy" : "0af48e59-4be9-46ce-9275-aa218813b6fd",
        "tags" : [
        ]
      }
    ],
    "commit" : "f575f89cd7eb2ef13dce8c32a8ade79752c0be18",
    "line" : null,
    "diffHunk" : "@@ -1,1 +98,102 @@\thc := &http.Client{Transport: trans}\n\n\tproviderCfg, err := oidc.FetchProviderConfig(hc, strings.TrimSuffix(issuer, \"/\"))\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error fetching provider config: %v\", err)"
  }
]
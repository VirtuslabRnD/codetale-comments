[
  {
    "id" : "4af35c7f-986d-4151-8c67-935228117f27",
    "prId" : 44152,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/44152#pullrequestreview-31715177",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "744d1a8d-f8c2-476b-8996-3d15a5af5de5",
        "parentId" : null,
        "authorId" : "72156db3-c40b-4455-9838-c12c0c606019",
        "body" : "I'm OK with this code improvement, although did not get time for this case/logic :).",
        "createdAt" : "2017-04-09T03:07:32Z",
        "updatedAt" : "2017-04-09T03:07:32Z",
        "lastEditedBy" : "72156db3-c40b-4455-9838-c12c0c606019",
        "tags" : [
        ]
      },
      {
        "id" : "a936b29e-9a4b-4adf-922a-54bdfd4e0752",
        "parentId" : "744d1a8d-f8c2-476b-8996-3d15a5af5de5",
        "authorId" : "cf088828-7f69-4b6e-8956-1842c94daa02",
        "body" : "Thanks",
        "createdAt" : "2017-04-09T03:43:51Z",
        "updatedAt" : "2017-04-09T03:43:51Z",
        "lastEditedBy" : "cf088828-7f69-4b6e-8956-1842c94daa02",
        "tags" : [
        ]
      }
    ],
    "commit" : "26482e3cfcd864d5f472beac1b82c0a2db418db4",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +162,166 @@\n\tcurrState, ok := cache.podStates[key]\n\tif ok && currState.pod.Spec.NodeName != pod.Spec.NodeName {\n\t\treturn fmt.Errorf(\"pod %v state was assumed on a different node\", key)\n\t}"
  },
  {
    "id" : "bec6486b-be70-46f9-9c06-1ccce1906c63",
    "prId" : 38503,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/38503#pullrequestreview-12710017",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "87866fc6-4993-40f9-8510-a1108b0f6ee3",
        "parentId" : null,
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "I completely don't understand this logic. Finished binding is not the signal for expiring pod - if the binding succeeded, then we want this to be assumed until we observe it via watch, otherwise, it will be forget anyway.\r\n\r\nSo this PR is incorrect.",
        "createdAt" : "2016-12-13T10:59:30Z",
        "updatedAt" : "2017-01-03T10:45:30Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      },
      {
        "id" : "1e1c1f48-85fd-469a-89f4-610a3526bbff",
        "parentId" : "87866fc6-4993-40f9-8510-a1108b0f6ee3",
        "authorId" : "7ab0c2e3-7a16-47e0-9ccf-0e1bbb697d37",
        "body" : "i am not expiring assumed pods when binding is finished, i am locking them from being expired until it will be finished. so this kinda affects maximum time of expiry, but not minimum.\r\n\r\nwe had a case when cache was expired in the middle of binding, and two pods with same anti-affinity were scheduled onto the same node",
        "createdAt" : "2016-12-13T11:59:42Z",
        "updatedAt" : "2017-01-03T10:45:30Z",
        "lastEditedBy" : "7ab0c2e3-7a16-47e0-9ccf-0e1bbb697d37",
        "tags" : [
        ]
      },
      {
        "id" : "4864744a-9dd7-4a26-9875-29d541ffb7ae",
        "parentId" : "87866fc6-4993-40f9-8510-a1108b0f6ee3",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "OK - sorry. I'm doing few things at the same time and misread the condition.\r\n\r\nAnyway - this doesn't solve the problem. If the cache will expire just after binding is finished (but not year read via watch), the same can happen. So introduce this logic doesn't make much sense, as the probability of it is not significantly lower, i think.",
        "createdAt" : "2016-12-13T12:13:32Z",
        "updatedAt" : "2017-01-03T10:45:30Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      },
      {
        "id" : "b04d2edd-5e0c-4204-9695-5d4c1a8fe781",
        "parentId" : "87866fc6-4993-40f9-8510-a1108b0f6ee3",
        "authorId" : "7ab0c2e3-7a16-47e0-9ccf-0e1bbb697d37",
        "body" : "yes, it is still possible, maybe it makes sense to renew ttl after binding?",
        "createdAt" : "2016-12-13T13:18:40Z",
        "updatedAt" : "2017-01-03T10:45:30Z",
        "lastEditedBy" : "7ab0c2e3-7a16-47e0-9ccf-0e1bbb697d37",
        "tags" : [
        ]
      },
      {
        "id" : "5a319afe-7d19-491e-8409-e7051707696c",
        "parentId" : "87866fc6-4993-40f9-8510-a1108b0f6ee3",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "yeah - that might make sense (it's still not 100% protection, but at least better)",
        "createdAt" : "2016-12-13T15:58:03Z",
        "updatedAt" : "2017-01-03T10:45:30Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "530ee716e33c9b918d4efd999c799faef9dd9c62",
    "line" : null,
    "diffHunk" : "@@ -1,1 +367,371 @@\t\t\t\tps.pod.Namespace, ps.pod.Name)\n\t\t\tcontinue\n\t\t}\n\t\tif now.After(*ps.deadline) {\n\t\t\tglog.Warningf(\"Pod %s/%s expired\", ps.pod.Namespace, ps.pod.Name)"
  },
  {
    "id" : "d94223d5-cd60-468c-8d73-71eb411bc2ef",
    "prId" : 28886,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d57c284c-a8f6-4dfa-9462-2188f191f9bd",
        "parentId" : null,
        "authorId" : "bd04f755-e62f-45fb-8771-4cc2b5db49d4",
        "body" : "So the only difference between ForgetPod and RemovePod is whether `cache.assumedPods[key]` is true or false. right?\n",
        "createdAt" : "2016-07-13T10:51:19Z",
        "updatedAt" : "2016-07-13T14:30:18Z",
        "lastEditedBy" : "bd04f755-e62f-45fb-8771-4cc2b5db49d4",
        "tags" : [
        ]
      },
      {
        "id" : "e6ee6a25-b48f-4e7f-8b5e-281d7b46fc78",
        "parentId" : "d57c284c-a8f6-4dfa-9462-2188f191f9bd",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "yes\n",
        "createdAt" : "2016-07-13T12:35:05Z",
        "updatedAt" : "2016-07-13T14:30:18Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "974587877854f5f285bf85b30a0da1b6ed4bb10b",
    "line" : 16,
    "diffHunk" : "@@ -1,1 +145,149 @@\tswitch {\n\t// Only assumed pod can be forgotten.\n\tcase ok && cache.assumedPods[key]:\n\t\terr := cache.removePod(pod)\n\t\tif err != nil {"
  },
  {
    "id" : "69baabfe-db4e-42e0-b248-65a7bbf92f1a",
    "prId" : 28680,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "cfa07bbe-b65a-43ab-b5ec-8929eefadaeb",
        "parentId" : null,
        "authorId" : "55c0e4a8-86f8-4426-a163-752ee421c57e",
        "body" : "Another idea I have was to keep the nodeInfoMap \"immutable\". so that we can access the info map without locking/copying or versioning. but it might be overkill.\n",
        "createdAt" : "2016-07-08T13:36:28Z",
        "updatedAt" : "2016-07-08T16:10:49Z",
        "lastEditedBy" : "55c0e4a8-86f8-4426-a163-752ee421c57e",
        "tags" : [
        ]
      },
      {
        "id" : "fac6a943-4412-4b33-a07e-f80003c177fe",
        "parentId" : "cfa07bbe-b65a-43ab-b5ec-8929eefadaeb",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "This optimization seem to be enough. After this change, this no longer pops in profiles, so I would add more complications to this code (at least in the near term future)\n",
        "createdAt" : "2016-07-08T13:39:23Z",
        "updatedAt" : "2016-07-08T16:10:49Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "49934c05c087c52c538c3df7b439007154da0f1c",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +75,79 @@}\n\nfunc (cache *schedulerCache) UpdateNodeNameToInfoMap(nodeNameToInfo map[string]*NodeInfo) error {\n\tcache.mu.Lock()\n\tdefer cache.mu.Unlock()"
  },
  {
    "id" : "3f3cf6c1-484d-4f16-a67a-e3afb803d504",
    "prId" : 24598,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6c6880a0-1ec1-47f4-b8df-6f8ecc517634",
        "parentId" : null,
        "authorId" : "55c0e4a8-86f8-4426-a163-752ee421c57e",
        "body" : "what is the difference between this function and AddNode? Just naming? I would rather keep this simple for now. Adding the fast zero-allocation update path later when needed.\n",
        "createdAt" : "2016-04-21T14:26:37Z",
        "updatedAt" : "2016-04-25T08:08:12Z",
        "lastEditedBy" : "55c0e4a8-86f8-4426-a163-752ee421c57e",
        "tags" : [
        ]
      },
      {
        "id" : "7bd9efda-6780-4449-ae9a-37f00019bece",
        "parentId" : "6c6880a0-1ec1-47f4-b8df-6f8ecc517634",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "Yes - there is basically no difference now.\n\n> Adding the fast zero-allocation update path later when needed.\n\nSorry - I don't understand. Can you please clarify.\n",
        "createdAt" : "2016-04-22T07:38:38Z",
        "updatedAt" : "2016-04-25T08:08:12Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      },
      {
        "id" : "e90cdb93-a896-48f1-ba9c-30aadbf6afa7",
        "parentId" : "6c6880a0-1ec1-47f4-b8df-6f8ecc517634",
        "authorId" : "55c0e4a8-86f8-4426-a163-752ee421c57e",
        "body" : "> Sorry - I don't understand. Can you please clarify.\n\nI would add a update function to avoid allocation by explicitly reusing the previous allocated object. I thought this update function is here to prepare for this purpose.\n",
        "createdAt" : "2016-04-22T14:35:32Z",
        "updatedAt" : "2016-04-25T08:08:12Z",
        "lastEditedBy" : "55c0e4a8-86f8-4426-a163-752ee421c57e",
        "tags" : [
        ]
      },
      {
        "id" : "86a652d9-9725-460e-b9c2-7ca6d9734725",
        "parentId" : "6c6880a0-1ec1-47f4-b8df-6f8ecc517634",
        "authorId" : "bb4cf218-381a-40ad-ac0c-0c2c66685cd4",
        "body" : "The Update seems to accomodate the controller model of Add, Update, Delete funcs.\nIf a node's fields was changed, e.g. status, resources, then it should be called.\nNot quite useful in current use cases, I guess.\n",
        "createdAt" : "2016-04-22T14:51:50Z",
        "updatedAt" : "2016-04-25T08:08:12Z",
        "lastEditedBy" : "bb4cf218-381a-40ad-ac0c-0c2c66685cd4",
        "tags" : [
        ]
      },
      {
        "id" : "cb32e959-0fc9-42fe-ae56-5a19200c37c1",
        "parentId" : "6c6880a0-1ec1-47f4-b8df-6f8ecc517634",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "We may want to optimize it at some point, but even with that it's significantly better. \n",
        "createdAt" : "2016-04-22T16:25:50Z",
        "updatedAt" : "2016-04-25T08:08:12Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "1835c8528d784816b9555931392831840082d333",
    "line" : 49,
    "diffHunk" : "@@ -1,1 +242,246 @@}\n\nfunc (cache *schedulerCache) UpdateNode(oldNode, newNode *api.Node) error {\n\tcache.mu.Lock()\n\tdefer cache.mu.Unlock()"
  },
  {
    "id" : "d85abc52-1d0d-4b17-a70b-08beebbd12aa",
    "prId" : 21016,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fe0353a7-0bad-4b24-97bc-178462158ef7",
        "parentId" : null,
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "nit:\nif err := cache.updatePod(oldPod, newPod); err != nil {\n  return err\n}\n",
        "createdAt" : "2016-02-12T10:57:23Z",
        "updatedAt" : "2016-02-16T16:10:26Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "5c3d303ba9260ffc66f43dd4b2111dcf295f2980",
    "line" : null,
    "diffHunk" : "@@ -1,1 +168,172 @@\t\tif err := cache.updatePod(oldPod, newPod); err != nil {\n\t\t\treturn err\n\t\t}\n\tdefault:\n\t\treturn fmt.Errorf(\"pod state wasn't added but get updated. Pod key: %v\", key)"
  },
  {
    "id" : "ac4c636e-0dce-4ec7-ac49-04e6385e742f",
    "prId" : 21016,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "34e47d47-71f9-44f9-a7cb-5e6d7a1a7051",
        "parentId" : null,
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "if err := cache.deletePod(oldPod); err != nil {\n  return err\n}\n",
        "createdAt" : "2016-02-12T10:58:04Z",
        "updatedAt" : "2016-02-16T16:10:26Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "5c3d303ba9260ffc66f43dd4b2111dcf295f2980",
    "line" : null,
    "diffHunk" : "@@ -1,1 +178,182 @@\tif err := cache.deletePod(oldPod); err != nil {\n\t\treturn err\n\t}\n\tcache.addPod(newPod)\n\treturn nil"
  },
  {
    "id" : "5a3cd7c1-3af0-4396-8368-96098be670ab",
    "prId" : 21016,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8dc3b615-3964-4096-814a-b7cb75817e26",
        "parentId" : null,
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "Is this correct? If the pod is assumed, its resources are also added to the cache. Shouldn't we remove them here?\n",
        "createdAt" : "2016-02-12T11:00:37Z",
        "updatedAt" : "2016-02-16T16:10:26Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      },
      {
        "id" : "04779e94-1d63-43ed-9b75-ff7f898e0aed",
        "parentId" : "8dc3b615-3964-4096-814a-b7cb75817e26",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "ahh - looking into your state machine it seems that I'm wrong.\nSo the pattern you would like to have is that in case of assumed pod, we simply ignore the Remove event, and wait for its expiration?\nCan you please add a comment about it (so that noone will think that it's a bug in the future)?\n",
        "createdAt" : "2016-02-12T11:02:40Z",
        "updatedAt" : "2016-02-16T16:10:26Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      },
      {
        "id" : "4e4c6c2e-d90d-4c93-8302-8886a4c692a4",
        "parentId" : "8dc3b615-3964-4096-814a-b7cb75817e26",
        "authorId" : "bb4cf218-381a-40ad-ac0c-0c2c66685cd4",
        "body" : "An assumed pod won't have Update/Remove event. It needs to have Add event before Remove event, in which case the state would change from Assumed to Added.\n",
        "createdAt" : "2016-02-12T18:11:13Z",
        "updatedAt" : "2016-02-16T16:10:26Z",
        "lastEditedBy" : "bb4cf218-381a-40ad-ac0c-0c2c66685cd4",
        "tags" : [
        ]
      },
      {
        "id" : "9b0bd08d-360a-421c-b51e-f530144ede4a",
        "parentId" : "8dc3b615-3964-4096-814a-b7cb75817e26",
        "authorId" : "bb4cf218-381a-40ad-ac0c-0c2c66685cd4",
        "body" : "Will add a comment.\n",
        "createdAt" : "2016-02-12T18:11:25Z",
        "updatedAt" : "2016-02-16T16:10:26Z",
        "lastEditedBy" : "bb4cf218-381a-40ad-ac0c-0c2c66685cd4",
        "tags" : [
        ]
      }
    ],
    "commit" : "5c3d303ba9260ffc66f43dd4b2111dcf295f2980",
    "line" : null,
    "diffHunk" : "@@ -1,1 +216,220 @@\t// An assumed pod won't have Delete/Remove event. It needs to have Add event\n\t// before Remove event, in which case the state would change from Assumed to Added.\n\tcase ok && !cache.assumedPods[key]:\n\t\terr := cache.deletePod(pod)\n\t\tif err != nil {"
  },
  {
    "id" : "b1040475-429f-4ff1-a940-ebcd0dcd7f81",
    "prId" : 20669,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "398aabb4-f74f-4dfc-968e-e2179b55f1f1",
        "parentId" : null,
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "What do you think about renaming this package to just \"cache\"?\nI think that duplication \"scheduler\" here (since we already have it in \"plugin/pkg/scheduler\" is unnecessary.\n\nThis should be similar to \"pkg/client/cache\" (not \"pkg/client/clientcache\").\n",
        "createdAt" : "2016-02-08T08:47:40Z",
        "updatedAt" : "2016-02-26T17:23:34Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      },
      {
        "id" : "4a04ba4f-535d-4a6d-8771-33d87b526118",
        "parentId" : "398aabb4-f74f-4dfc-968e-e2179b55f1f1",
        "authorId" : "bb4cf218-381a-40ad-ac0c-0c2c66685cd4",
        "body" : "\"cache\" is a very generic name used across the project.\nAdding a prefix could help break generic names.\nIt's just our Go convention of import paths. What do you think about the tradeoff?\n",
        "createdAt" : "2016-02-08T17:22:26Z",
        "updatedAt" : "2016-02-26T17:23:34Z",
        "lastEditedBy" : "bb4cf218-381a-40ad-ac0c-0c2c66685cd4",
        "tags" : [
        ]
      },
      {
        "id" : "533dc547-cd42-4b65-9bb2-6527850b4daf",
        "parentId" : "398aabb4-f74f-4dfc-968e-e2179b55f1f1",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "This was my first thought. Personally I would prefer \"cache\" then \"schedulercache\", given that you probably will not export anything outside scheduler. But if you feel very strongly about it, I'm not going to block this PR on it :)\n",
        "createdAt" : "2016-02-08T19:43:12Z",
        "updatedAt" : "2016-02-26T17:23:34Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "f29a1d6c5c63661d259f7119670ac1f6245bf481",
    "line" : null,
    "diffHunk" : "@@ -1,1 +15,19 @@*/\n\npackage schedulercache\n\nimport ("
  },
  {
    "id" : "6019ff88-0ea1-4f08-a290-9d86862d6578",
    "prId" : 20669,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "504041e2-cac8-43c2-9896-3f507ab54e65",
        "parentId" : null,
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "nit: maybe:\n\"ttl\" is how long it takes an assumed pod to get expired\ninstead?\n",
        "createdAt" : "2016-02-10T10:08:20Z",
        "updatedAt" : "2016-02-26T17:23:34Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "f29a1d6c5c63661d259f7119670ac1f6245bf481",
    "line" : null,
    "diffHunk" : "@@ -1,1 +34,38 @@// New returns a Cache implementation.\n// It automatically starts a go routine that manages expiration of assumed pods.\n// \"ttl\" is how long the assumed pod will get expired.\n// \"stop\" is the channel that would close the background goroutine.\nfunc New(ttl time.Duration, stop chan struct{}) Cache {"
  },
  {
    "id" : "89a27cdb-2a3f-405f-9b19-0f3b62e6d4e6",
    "prId" : 20669,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0647cfd1-74c8-42df-ac4d-72a230ddf06f",
        "parentId" : null,
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "Personally, I think that separating it into Run() method (potentially taking stop channel as an argument) would be much cleaner. WDYT?\n",
        "createdAt" : "2016-02-10T10:13:32Z",
        "updatedAt" : "2016-02-26T17:23:34Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      },
      {
        "id" : "bf7d55a5-e5c7-41f7-a18e-fc52859f6852",
        "parentId" : "0647cfd1-74c8-42df-ac4d-72a230ddf06f",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "Note that this is the relatively common pattern in k8s, e.g. Reflector does this.\n",
        "createdAt" : "2016-02-10T10:14:33Z",
        "updatedAt" : "2016-02-26T17:23:34Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "f29a1d6c5c63661d259f7119670ac1f6245bf481",
    "line" : null,
    "diffHunk" : "@@ -1,1 +38,42 @@func New(ttl time.Duration, stop chan struct{}) Cache {\n\tcache := newSchedulerCache(ttl, cleanAssumedPeriod, stop)\n\tcache.run()\n\treturn cache\n}"
  },
  {
    "id" : "c315fd97-6c89-470a-9e79-0c2b0f014368",
    "prId" : 20669,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e1ba64c3-1ee6-460f-9fa2-5e967d0ee718",
        "parentId" : null,
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "please merge AssumePodIfBindSucceed and assumePodIfBindSucceed methods (there is no point in having both).\n",
        "createdAt" : "2016-02-10T10:23:06Z",
        "updatedAt" : "2016-02-26T17:23:34Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      },
      {
        "id" : "f67590bd-87ae-403e-8aa1-641f2796c741",
        "parentId" : "e1ba64c3-1ee6-460f-9fa2-5e967d0ee718",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "Never mind - I didn't see the difference in signature and it seems you are using it for testing purposes. So it's fine to leave both.\n",
        "createdAt" : "2016-02-10T10:24:23Z",
        "updatedAt" : "2016-02-26T17:23:34Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "f29a1d6c5c63661d259f7119670ac1f6245bf481",
    "line" : null,
    "diffHunk" : "@@ -1,1 +100,104 @@\nfunc (cache *schedulerCache) AssumePodIfBindSucceed(pod *api.Pod, bind func() bool) error {\n\treturn cache.assumePodIfBindSucceed(pod, bind, time.Now())\n}\n"
  }
]
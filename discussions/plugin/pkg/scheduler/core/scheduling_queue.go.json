[
  {
    "id" : "930fd7d2-fcd7-4186-818b-d91d2bde9511",
    "prId" : 55109,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/55109#pullrequestreview-74614428",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "102a7a2e-0756-436a-b180-b256220f9871",
        "parentId" : null,
        "authorId" : "fa37bbb4-59dd-42f0-8202-52d5717aff5e",
        "body" : "a little confused by this `heapData` and `Heap`. it looks like `heapData` is a pure heap, but `Heap` is a lot more than a heap. maybe it could have another name. ",
        "createdAt" : "2017-11-06T23:29:23Z",
        "updatedAt" : "2017-11-19T19:32:37Z",
        "lastEditedBy" : "fa37bbb4-59dd-42f0-8202-52d5717aff5e",
        "tags" : [
        ]
      },
      {
        "id" : "1b6897c4-015e-480c-ad92-8182dd5975f3",
        "parentId" : "102a7a2e-0756-436a-b180-b256220f9871",
        "authorId" : "15fb535e-c5be-47ce-a304-1cb5da5aca90",
        "body" : "As I mentioned in the comments, this is pretty much the same code that I [implemented in `cache` package](https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/client-go/tools/cache/heap.go) last quarter. `headData` has the data that `Heap` needs. It also implements golang `heap` interface.\r\nI could have used the same package, but we need to have our own synchronization at `PriorityQueue` level. So, using the package would have done double synchronization and would have imposed extra overhead. That's why I decided to bring the code and modify it as little as possible.\r\nThe `Heap` has nothing more than `heapData`. So, I would say `Heap` is still a good name for the struct.",
        "createdAt" : "2017-11-07T01:07:11Z",
        "updatedAt" : "2017-11-19T19:32:37Z",
        "lastEditedBy" : "15fb535e-c5be-47ce-a304-1cb5da5aca90",
        "tags" : [
        ]
      }
    ],
    "commit" : "79ac37d8b30a77929f9cc8b5aa346bbeb1ca7ca7",
    "line" : 600,
    "diffHunk" : "@@ -1,1 +595,599 @@// Heap is a thread-safe producer/consumer queue that implements a heap data structure.\n// It can be used to implement priority queues and similar data structures.\ntype Heap struct {\n\t// data stores objects and has a queue that keeps their ordering according\n\t// to the heap invariant."
  },
  {
    "id" : "97cab581-c97f-4fd1-9d0d-cf88a79e8579",
    "prId" : 55109,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/55109#pullrequestreview-74614899",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "13915bc2-a514-448b-a2dd-067a28ddf9bb",
        "parentId" : null,
        "authorId" : "fa37bbb4-59dd-42f0-8202-52d5717aff5e",
        "body" : "looks like this is owned by `Heap`. `heapData` isn't using it. ",
        "createdAt" : "2017-11-06T23:33:32Z",
        "updatedAt" : "2017-11-19T19:32:37Z",
        "lastEditedBy" : "fa37bbb4-59dd-42f0-8202-52d5717aff5e",
        "tags" : [
        ]
      },
      {
        "id" : "97f7764f-38da-43dd-990d-569a1ba1570e",
        "parentId" : "13915bc2-a514-448b-a2dd-067a28ddf9bb",
        "authorId" : "15fb535e-c5be-47ce-a304-1cb5da5aca90",
        "body" : "That's a valid point; `headData` does not use `keyFunc`. This is in `heapData` because `heapData` holds all the data that `Heap` needs.",
        "createdAt" : "2017-11-07T01:10:27Z",
        "updatedAt" : "2017-11-19T19:32:37Z",
        "lastEditedBy" : "15fb535e-c5be-47ce-a304-1cb5da5aca90",
        "tags" : [
        ]
      }
    ],
    "commit" : "79ac37d8b30a77929f9cc8b5aa346bbeb1ca7ca7",
    "line" : 538,
    "diffHunk" : "@@ -1,1 +533,537 @@\t// keyFunc is used to make the key used for queued item insertion and retrieval, and\n\t// should be deterministic.\n\tkeyFunc KeyFunc\n\t// lessFunc is used to compare two objects in the heap.\n\tlessFunc LessFunc"
  },
  {
    "id" : "65723a9e-c77c-4314-9187-22d3e3d5f5b5",
    "prId" : 55109,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/55109#pullrequestreview-77392718",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "415af537-cc2b-47b2-b4f8-04495fe65092",
        "parentId" : null,
        "authorId" : "82da2b23-9f40-4abd-8af5-56ba07c1fc0a",
        "body" : "Is this trying to say \"AssignedPodAdded is called when a pod is bound to a node. Scheduling the pod may make pending pods with matching pod affinity terms schedulable\"\r\n\r\nIf so, that would be clearer.\r\n",
        "createdAt" : "2017-11-17T01:53:42Z",
        "updatedAt" : "2017-11-19T19:32:37Z",
        "lastEditedBy" : "82da2b23-9f40-4abd-8af5-56ba07c1fc0a",
        "tags" : [
        ]
      },
      {
        "id" : "03317776-4162-444e-8d2b-530d5f1cef98",
        "parentId" : "415af537-cc2b-47b2-b4f8-04495fe65092",
        "authorId" : "15fb535e-c5be-47ce-a304-1cb5da5aca90",
        "body" : "What you said is a more probable scenario, but this event is also triggered when a pod whose node name is set is created.",
        "createdAt" : "2017-11-17T10:27:44Z",
        "updatedAt" : "2017-11-19T19:32:37Z",
        "lastEditedBy" : "15fb535e-c5be-47ce-a304-1cb5da5aca90",
        "tags" : [
        ]
      }
    ],
    "commit" : "79ac37d8b30a77929f9cc8b5aa346bbeb1ca7ca7",
    "line" : 319,
    "diffHunk" : "@@ -1,1 +314,318 @@}\n\n// AssignedPodAdded is called when a bound pod is added. Creation of this pod\n// may make pending pods with matching affinity terms schedulable.\nfunc (p *PriorityQueue) AssignedPodAdded(pod *v1.Pod) {"
  },
  {
    "id" : "a72a3bb7-193e-4028-85f3-792fbf45ced1",
    "prId" : 55109,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/55109#pullrequestreview-77590598",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c432c772-f0b3-465f-8f3d-1ff89e70c389",
        "parentId" : null,
        "authorId" : "82da2b23-9f40-4abd-8af5-56ba07c1fc0a",
        "body" : "Technically only one of the queues inside PriorityQueue is a priority queue, but I wouldn't bother to rename it.",
        "createdAt" : "2017-11-17T20:30:52Z",
        "updatedAt" : "2017-11-19T19:32:37Z",
        "lastEditedBy" : "82da2b23-9f40-4abd-8af5-56ba07c1fc0a",
        "tags" : [
        ]
      },
      {
        "id" : "daf5f156-5cd0-491d-b592-7a02c9efd303",
        "parentId" : "c432c772-f0b3-465f-8f3d-1ff89e70c389",
        "authorId" : "15fb535e-c5be-47ce-a304-1cb5da5aca90",
        "body" : "Yes. The main queue that scheduler uses to pick up pods is a priority queue.",
        "createdAt" : "2017-11-17T23:37:26Z",
        "updatedAt" : "2017-11-19T19:32:37Z",
        "lastEditedBy" : "15fb535e-c5be-47ce-a304-1cb5da5aca90",
        "tags" : [
        ]
      }
    ],
    "commit" : "79ac37d8b30a77929f9cc8b5aa346bbeb1ca7ca7",
    "line" : 156,
    "diffHunk" : "@@ -1,1 +151,155 @@// Heap is already thread safe, but we need to acquire another lock here to ensure\n// atomicity of operations on the two data structures..\ntype PriorityQueue struct {\n\tlock sync.RWMutex\n\tcond sync.Cond"
  },
  {
    "id" : "6ba33452-0d80-4fcd-8d84-4845492fac54",
    "prId" : 55109,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/55109#pullrequestreview-77592824",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "04213b55-e953-4606-9b2c-5b506e4af1b7",
        "parentId" : null,
        "authorId" : "82da2b23-9f40-4abd-8af5-56ba07c1fc0a",
        "body" : "Why is this part of unschedulable pods map? I would think nominated pods would not be in either unschedulable pods or active pods, since they have already been scheduled (it is as if they are running).\r\n",
        "createdAt" : "2017-11-17T22:28:20Z",
        "updatedAt" : "2017-11-19T19:32:37Z",
        "lastEditedBy" : "82da2b23-9f40-4abd-8af5-56ba07c1fc0a",
        "tags" : [
        ]
      },
      {
        "id" : "e5e8083e-0b22-4331-929d-d7faf36a9427",
        "parentId" : "04213b55-e953-4606-9b2c-5b506e4af1b7",
        "authorId" : "15fb535e-c5be-47ce-a304-1cb5da5aca90",
        "body" : "When a pod is nominated, it is marked unschedulable. This is scheduler's default behavior to mark such pods as unschedulable since they cannot be scheduled right away. These pods are added to unschedulableQ and may be moved to the activeQ from time to time when we receive a move request. Scheduler tries to schedule them as soon as possible and does not wait to put them only on the same node as their nominated node.\r\nIn my second PR, there is a logic in checking whether a node can fit a pod that picks up the nominated pods from the queue and makes sure that the being tried pods fits in presence of these nominated pods.",
        "createdAt" : "2017-11-17T23:54:09Z",
        "updatedAt" : "2017-11-19T19:32:37Z",
        "lastEditedBy" : "15fb535e-c5be-47ce-a304-1cb5da5aca90",
        "tags" : [
        ]
      }
    ],
    "commit" : "79ac37d8b30a77929f9cc8b5aa346bbeb1ca7ca7",
    "line" : 401,
    "diffHunk" : "@@ -1,1 +396,400 @@\tpods map[string]*v1.Pod\n\t// nominatedPods is a map keyed by a node name and the value is a list of\n\t// pods' full-names which are nominated to run on the node.\n\tnominatedPods map[string][]string\n\tkeyFunc       func(*v1.Pod) string"
  }
]
[
  {
    "id" : "64463c68-970f-43ab-a71c-94b55c90a819",
    "prId" : 56966,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/56966#pullrequestreview-82728062",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e0966a25-8821-4fcf-8ff0-6a80996b08ff",
        "parentId" : null,
        "authorId" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "body" : "You also need to invalidate the NoVolumeNodeConflict predicate under the LocalPersistentVolumes feature gate for PVC delete.",
        "createdAt" : "2017-12-11T16:48:18Z",
        "updatedAt" : "2017-12-12T06:23:07Z",
        "lastEditedBy" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "tags" : [
        ]
      },
      {
        "id" : "c6bcd043-a6fb-4a3a-a6b8-2445bc738b38",
        "parentId" : "e0966a25-8821-4fcf-8ff0-6a80996b08ff",
        "authorId" : "7dd504ec-7e63-45b3-98f8-6eb1c683e9c2",
        "body" : "Thanks, just fixed.",
        "createdAt" : "2017-12-12T06:12:36Z",
        "updatedAt" : "2017-12-12T06:23:07Z",
        "lastEditedBy" : "7dd504ec-7e63-45b3-98f8-6eb1c683e9c2",
        "tags" : [
        ]
      }
    ],
    "commit" : "80b84fa9221905faa3a206b13ac000eb1a979db9",
    "line" : 80,
    "diffHunk" : "@@ -1,1 +366,370 @@\n\t// The bound volume's label may change\n\tinvalidPredicates.Insert(\"NoVolumeZoneConflict\")\n\n\t// The bound volume's node affinity may change"
  },
  {
    "id" : "1da40e32-a334-49ed-a118-9e7decc960d0",
    "prId" : 56577,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/56577#pullrequestreview-81239060",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0909891c-f97b-404a-bdff-c6302233fe2e",
        "parentId" : null,
        "authorId" : "15fb535e-c5be-47ce-a304-1cb5da5aca90",
        "body" : "I thought I had asked this question before, but looks like I haven't:\r\nwhy do we need to break `MaxPDVolumeCountPredicate` to three keys? Is it only for optimization purposes? If so, I doubt if it has a major effect on performance. It will probably be rare to have more than one of these volume types on a single node.",
        "createdAt" : "2017-12-04T21:42:40Z",
        "updatedAt" : "2017-12-04T21:44:58Z",
        "lastEditedBy" : "15fb535e-c5be-47ce-a304-1cb5da5aca90",
        "tags" : [
        ]
      },
      {
        "id" : "dd1dd184-8ea0-4743-9e4c-795da5313d7f",
        "parentId" : "0909891c-f97b-404a-bdff-c6302233fe2e",
        "authorId" : "7dd504ec-7e63-45b3-98f8-6eb1c683e9c2",
        "body" : "Actually the [registered predicates](https://github.com/kubernetes/kubernetes/blob/master/plugin/pkg/scheduler/algorithmprovider/defaults/defaults.go#L124-L144) are three separated names instead of \"MaxPDVolumeCount\".\r\n\r\nOtherwise we may need to check the type of volume before invalidating, while just as you pointed out, it's rare to have more than one of them as PV, so I chose to invalidate them all in most cases unless we can check the PV type very easily.",
        "createdAt" : "2017-12-05T05:20:44Z",
        "updatedAt" : "2017-12-05T05:20:44Z",
        "lastEditedBy" : "7dd504ec-7e63-45b3-98f8-6eb1c683e9c2",
        "tags" : [
        ]
      },
      {
        "id" : "9e987ed0-ed0b-433e-814d-a2ac8ef5c2bf",
        "parentId" : "0909891c-f97b-404a-bdff-c6302233fe2e",
        "authorId" : "15fb535e-c5be-47ce-a304-1cb5da5aca90",
        "body" : "I see. Thanks for pointing it out.",
        "createdAt" : "2017-12-05T16:07:09Z",
        "updatedAt" : "2017-12-05T16:07:10Z",
        "lastEditedBy" : "15fb535e-c5be-47ce-a304-1cb5da5aca90",
        "tags" : [
        ]
      }
    ],
    "commit" : "b3bb74e3a324bd492b3639e4069187c2eb96a82a",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +76,80 @@\tgeneralPredicatesSets         = sets.NewString(\"GeneralPredicates\")\n\tnoDiskConflictSet             = sets.NewString(\"NoDiskConflict\")\n\tmaxPDVolumeCountPredicateKeys = []string{\"MaxGCEPDVolumeCount\", \"MaxAzureDiskVolumeCount\", \"MaxEBSVolumeCount\"}\n)\n"
  },
  {
    "id" : "9c8af1e1-70cf-48f5-959c-0e0f37e7762f",
    "prId" : 55933,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/55933#pullrequestreview-78006196",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "812c12cc-671d-4919-b894-da45714034f8",
        "parentId" : null,
        "authorId" : "82da2b23-9f40-4abd-8af5-56ba07c1fc0a",
        "body" : "Why do you add this to unschedulable instead of active q?",
        "createdAt" : "2017-11-19T03:56:44Z",
        "updatedAt" : "2017-11-21T06:17:25Z",
        "lastEditedBy" : "82da2b23-9f40-4abd-8af5-56ba07c1fc0a",
        "tags" : [
        ]
      },
      {
        "id" : "aaac448a-7118-4dd0-9e81-a033d549a036",
        "parentId" : "812c12cc-671d-4919-b894-da45714034f8",
        "authorId" : "15fb535e-c5be-47ce-a304-1cb5da5aca90",
        "body" : "This function is called when scheduler fails to schedule the pod. So, we place it in unschedulable queue, but unschedulable queue has more logic to decide whether it should go there or should go to active queue. It checks pod's status and whether a move request is received to decide between the two queues.",
        "createdAt" : "2017-11-19T19:56:35Z",
        "updatedAt" : "2017-11-21T06:17:25Z",
        "lastEditedBy" : "15fb535e-c5be-47ce-a304-1cb5da5aca90",
        "tags" : [
        ]
      },
      {
        "id" : "0ee04dbd-6ee8-486b-b2dd-a92b65af1e3d",
        "parentId" : "812c12cc-671d-4919-b894-da45714034f8",
        "authorId" : "82da2b23-9f40-4abd-8af5-56ba07c1fc0a",
        "body" : "OK, it seems probably safer to put it in the active queue, but if you're confident about this then it's fine with me.",
        "createdAt" : "2017-11-21T02:49:08Z",
        "updatedAt" : "2017-11-21T06:17:25Z",
        "lastEditedBy" : "82da2b23-9f40-4abd-8af5-56ba07c1fc0a",
        "tags" : [
        ]
      },
      {
        "id" : "87050564-9672-451c-bd45-810d1239f40e",
        "parentId" : "812c12cc-671d-4919-b894-da45714034f8",
        "authorId" : "15fb535e-c5be-47ce-a304-1cb5da5aca90",
        "body" : "This is fine. If we put pods in the active queue here, then no pod will go to unschedulable queue.",
        "createdAt" : "2017-11-21T05:51:45Z",
        "updatedAt" : "2017-11-21T06:17:25Z",
        "lastEditedBy" : "15fb535e-c5be-47ce-a304-1cb5da5aca90",
        "tags" : [
        ]
      },
      {
        "id" : "5e9bf265-1dd1-4598-aa96-8c39b1130461",
        "parentId" : "812c12cc-671d-4919-b894-da45714034f8",
        "authorId" : "15fb535e-c5be-47ce-a304-1cb5da5aca90",
        "body" : "And in fact, putting the pod in active queue would cause a problem, because a very high priority pod which was not schedulable would block the scheduling queue (as it is now a priority queue).",
        "createdAt" : "2017-11-21T05:53:52Z",
        "updatedAt" : "2017-11-21T06:17:25Z",
        "lastEditedBy" : "15fb535e-c5be-47ce-a304-1cb5da5aca90",
        "tags" : [
        ]
      }
    ],
    "commit" : "eda3df87325f82b8dfa6817c1373d17414982a13",
    "line" : 51,
    "diffHunk" : "@@ -1,1 +1066,1070 @@\t\t\t\tif err == nil {\n\t\t\t\t\tif len(pod.Spec.NodeName) == 0 {\n\t\t\t\t\t\tpodQueue.AddUnschedulableIfNotPresent(pod)\n\t\t\t\t\t}\n\t\t\t\t\tbreak"
  },
  {
    "id" : "998e14db-8cce-42ac-8ad0-37423f9f1afc",
    "prId" : 55039,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/55039#pullrequestreview-77942500",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6ef84abd-3288-4b9f-b61e-e498199f3871",
        "parentId" : null,
        "authorId" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "body" : "Also need to invalidate predicate on PVC update when volumeName changes.",
        "createdAt" : "2017-11-20T17:39:49Z",
        "updatedAt" : "2017-11-22T07:20:19Z",
        "lastEditedBy" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "tags" : [
        ]
      },
      {
        "id" : "14cbf552-c58e-4e28-acf8-a62e11d44204",
        "parentId" : "6ef84abd-3288-4b9f-b61e-e498199f3871",
        "authorId" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "body" : "done",
        "createdAt" : "2017-11-20T22:21:20Z",
        "updatedAt" : "2017-11-22T07:20:19Z",
        "lastEditedBy" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "tags" : [
        ]
      }
    ],
    "commit" : "6540850fa2b710060fa94a22e03ff7c39ba652e6",
    "line" : 121,
    "diffHunk" : "@@ -1,1 +398,402 @@\tif utilfeature.DefaultFeatureGate.Enabled(features.VolumeScheduling) {\n\t\t// Add/delete impacts the available PVs to choose from\n\t\tinvalidPredicates.Insert(predicates.CheckVolumeBinding)\n\t}\n"
  },
  {
    "id" : "649b8cd3-e74b-46ab-bfae-e2a9ab22da05",
    "prId" : 55039,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/55039#pullrequestreview-77961845",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1143ea26-8e73-413d-93de-d5470bdcac1c",
        "parentId" : null,
        "authorId" : "15fb535e-c5be-47ce-a304-1cb5da5aca90",
        "body" : "Ideally, we would like to have integration tests for these changes, but given that this PR is already too large and we are close to the code freeze, you may want to add the tests in a separate PR.",
        "createdAt" : "2017-11-20T23:33:58Z",
        "updatedAt" : "2017-11-22T07:20:19Z",
        "lastEditedBy" : "15fb535e-c5be-47ce-a304-1cb5da5aca90",
        "tags" : [
        ]
      },
      {
        "id" : "5dab1512-a22b-434b-b052-27509dba1e6e",
        "parentId" : "1143ea26-8e73-413d-93de-d5470bdcac1c",
        "authorId" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "body" : "Will open a bug to add integration tests for predicate invalidation.",
        "createdAt" : "2017-11-20T23:53:03Z",
        "updatedAt" : "2017-11-22T07:20:19Z",
        "lastEditedBy" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "tags" : [
        ]
      }
    ],
    "commit" : "6540850fa2b710060fa94a22e03ff7c39ba652e6",
    "line" : 159,
    "diffHunk" : "@@ -1,1 +464,468 @@}\n\nfunc (c *configFactory) invalidatePredicatesForPvcUpdate(old, new *v1.PersistentVolumeClaim) {\n\tinvalidPredicates := sets.NewString()\n"
  },
  {
    "id" : "bf22fe04-ed58-46cc-b936-3faca81009ef",
    "prId" : 55039,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/55039#pullrequestreview-78543886",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "734e1df4-c409-4db1-9e6d-b23379a9c29e",
        "parentId" : null,
        "authorId" : "15fb535e-c5be-47ce-a304-1cb5da5aca90",
        "body" : "Please remove this one too.",
        "createdAt" : "2017-11-22T06:02:53Z",
        "updatedAt" : "2017-11-22T07:20:19Z",
        "lastEditedBy" : "15fb535e-c5be-47ce-a304-1cb5da5aca90",
        "tags" : [
        ]
      },
      {
        "id" : "77928e2c-f462-4877-b601-6cc20734439a",
        "parentId" : "734e1df4-c409-4db1-9e6d-b23379a9c29e",
        "authorId" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "body" : "What about the scenario where the pod is updated/deleted while it is being processed in `scheduleOne`?  The two checks here were supposed to be for that case.",
        "createdAt" : "2017-11-22T06:22:33Z",
        "updatedAt" : "2017-11-22T07:20:19Z",
        "lastEditedBy" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "tags" : [
        ]
      },
      {
        "id" : "6f42d90d-6a19-46cb-a069-a0dca3772809",
        "parentId" : "734e1df4-c409-4db1-9e6d-b23379a9c29e",
        "authorId" : "15fb535e-c5be-47ce-a304-1cb5da5aca90",
        "body" : "The pod is unassinged while it is being processed in `scheduleOne`. So, if it is updated or deleted, we will get the corresponding event for the unassigned pod.",
        "createdAt" : "2017-11-22T06:43:37Z",
        "updatedAt" : "2017-11-22T07:20:19Z",
        "lastEditedBy" : "15fb535e-c5be-47ce-a304-1cb5da5aca90",
        "tags" : [
        ]
      },
      {
        "id" : "67d21f87-1654-44b3-8937-4ea9953bf8c1",
        "parentId" : "734e1df4-c409-4db1-9e6d-b23379a9c29e",
        "authorId" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "body" : "What if:\r\n1. Start processing pod in scheduleOne\r\n2. Pod gets deleted, unassigned event comes and clears cache\r\n3. The processing in scheduleOne updates the cache with the pod\r\n4. Assume/bind fails because pod doesn't exist anymore\r\n5. Cache needs to be cleaned up somehow\r\n\r\n",
        "createdAt" : "2017-11-22T06:48:27Z",
        "updatedAt" : "2017-11-22T07:20:19Z",
        "lastEditedBy" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "tags" : [
        ]
      },
      {
        "id" : "a620c47a-be95-472b-aef9-b31a947d9649",
        "parentId" : "734e1df4-c409-4db1-9e6d-b23379a9c29e",
        "authorId" : "15fb535e-c5be-47ce-a304-1cb5da5aca90",
        "body" : "The scenario is valid, but in that case pod will not be assigned (len(pod.Spec.NodeName) == 0) and in fact, the pod will not be found, so err != nil. So, the check you have added below to `if errors.IsNotFound(err) {` should suffice.",
        "createdAt" : "2017-11-22T07:03:49Z",
        "updatedAt" : "2017-11-22T07:20:19Z",
        "lastEditedBy" : "15fb535e-c5be-47ce-a304-1cb5da5aca90",
        "tags" : [
        ]
      },
      {
        "id" : "14b5031f-e08b-428b-ba35-9b97e4856c8d",
        "parentId" : "734e1df4-c409-4db1-9e6d-b23379a9c29e",
        "authorId" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "body" : "What if it was an update event that caused the pod to be assigned?",
        "createdAt" : "2017-11-22T07:08:31Z",
        "updatedAt" : "2017-11-22T07:20:19Z",
        "lastEditedBy" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "tags" : [
        ]
      },
      {
        "id" : "e58c74c0-2b79-4349-a3e6-394094301388",
        "parentId" : "734e1df4-c409-4db1-9e6d-b23379a9c29e",
        "authorId" : "15fb535e-c5be-47ce-a304-1cb5da5aca90",
        "body" : "The way our event handlers are set up is that they have a filter that check for assignment of pods. So, whenever a pod is assigned, we received one \"delete\" event for the unassigned pod followed by an \"add\" event for the assigned pod. In other words, an unassigned pod won't become assigned in an update.",
        "createdAt" : "2017-11-22T17:55:48Z",
        "updatedAt" : "2017-11-22T17:55:48Z",
        "lastEditedBy" : "15fb535e-c5be-47ce-a304-1cb5da5aca90",
        "tags" : [
        ]
      },
      {
        "id" : "014f15a2-21b9-4693-ad90-d1b45a76c8e2",
        "parentId" : "734e1df4-c409-4db1-9e6d-b23379a9c29e",
        "authorId" : "15fb535e-c5be-47ce-a304-1cb5da5aca90",
        "body" : "Had an offline discussion with @msau42. This is correct.",
        "createdAt" : "2017-11-22T18:40:26Z",
        "updatedAt" : "2017-11-22T18:40:26Z",
        "lastEditedBy" : "15fb535e-c5be-47ce-a304-1cb5da5aca90",
        "tags" : [
        ]
      }
    ],
    "commit" : "6540850fa2b710060fa94a22e03ff7c39ba652e6",
    "line" : 242,
    "diffHunk" : "@@ -1,1 +1144,1148 @@\t\t\t\t\tif len(pod.Spec.NodeName) == 0 {\n\t\t\t\t\t\tpodQueue.AddUnschedulableIfNotPresent(pod)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif factory.volumeBinder != nil {\n\t\t\t\t\t\t\t// Volume binder only wants to keep unassigned pods"
  },
  {
    "id" : "8e0f303f-70ef-43d0-a202-84a0419057c2",
    "prId" : 50949,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/50949#pullrequestreview-60997369",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "926d1962-f0b3-4d96-a19b-c3ff2a58cac8",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "this should probably be patching pod status to avoid stomping on any other status fields",
        "createdAt" : "2017-09-01T02:42:08Z",
        "updatedAt" : "2017-09-07T22:32:06Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "e788231f-4a86-4e30-8be0-de1a0aaa11c3",
        "parentId" : "926d1962-f0b3-4d96-a19b-c3ff2a58cac8",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "+1\r\n\r\nAt least add a TODO",
        "createdAt" : "2017-09-06T11:17:00Z",
        "updatedAt" : "2017-09-07T22:32:06Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      },
      {
        "id" : "a66b64c3-9ad8-4b27-9289-7808dc83113b",
        "parentId" : "926d1962-f0b3-4d96-a19b-c3ff2a58cac8",
        "authorId" : "15fb535e-c5be-47ce-a304-1cb5da5aca90",
        "body" : "Added a todo.",
        "createdAt" : "2017-09-06T18:42:58Z",
        "updatedAt" : "2017-09-07T22:32:06Z",
        "lastEditedBy" : "15fb535e-c5be-47ce-a304-1cb5da5aca90",
        "tags" : [
        ]
      }
    ],
    "commit" : "c0b718373befb2168befc0c4579fd9a02155d5bc",
    "line" : 43,
    "diffHunk" : "@@ -1,1 +1015,1019 @@\t\tpodCopy.Annotations[k] = v\n\t}\n\t_, err := p.Client.CoreV1().Pods(podCopy.Namespace).UpdateStatus(podCopy)\n\treturn err\n}"
  },
  {
    "id" : "dde1eb12-81ee-4bdd-b7fc-c2e7f9969ed7",
    "prId" : 46223,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/46223#pullrequestreview-39725553",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4b974d7c-63d0-4051-a3b3-3b51a0f63b4a",
        "parentId" : null,
        "authorId" : "72156db3-c40b-4455-9838-c12c0c606019",
        "body" : "Will the informer cache all Pods in local (scheduler) and filter? or handled in apiserver?",
        "createdAt" : "2017-05-23T00:59:55Z",
        "updatedAt" : "2017-05-23T00:59:55Z",
        "lastEditedBy" : "72156db3-c40b-4455-9838-c12c0c606019",
        "tags" : [
        ]
      },
      {
        "id" : "11b1d5e3-e78a-4dbb-bd53-9a251aff4376",
        "parentId" : "4b974d7c-63d0-4051-a3b3-3b51a0f63b4a",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "That's the informer's job.  The informer in this package is filtered to non-terminal pods, and then split in half into the pod cache (assigned) and queue (unassigned).  The global informer in the controller manager (which this PR does not use, but an extension scheduler or hyper kube could use) would be global, and this filters down to that set.",
        "createdAt" : "2017-05-23T12:28:53Z",
        "updatedAt" : "2017-05-23T12:28:54Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      }
    ],
    "commit" : "e9e69356e4907fa4d0f45ea7e7768357ba71aba9",
    "line" : 46,
    "diffHunk" : "@@ -1,1 +139,143 @@\t// scheduled pod cache\n\tpodInformer.Informer().AddEventHandler(\n\t\tcache.FilteringResourceEventHandler{\n\t\t\tFilterFunc: func(obj interface{}) bool {\n\t\t\t\tswitch t := obj.(type) {"
  },
  {
    "id" : "e9c653d9-115b-4ee4-bf76-6cdfaab4ba9e",
    "prId" : 45933,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/45933#pullrequestreview-38796764",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4b2998f1-da2a-482e-93fd-ececeb8e40e5",
        "parentId" : null,
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "marker for how far I got",
        "createdAt" : "2017-05-17T21:44:58Z",
        "updatedAt" : "2017-05-21T01:58:47Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      }
    ],
    "commit" : "ad720cc651916aedd1d3aca665eff901c3445a88",
    "line" : 134,
    "diffHunk" : "@@ -1,1 +530,534 @@}\n\n// unassignedNonTerminatedPod selects pods that are unassigned and non-terminal.\nfunc unassignedNonTerminatedPod(pod *v1.Pod) bool {\n\tif len(pod.Spec.NodeName) != 0 {"
  },
  {
    "id" : "c4ec70e2-f1e6-42b9-b9b4-6e6a67377f8e",
    "prId" : 44115,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/44115#pullrequestreview-31422870",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "dc388520-4c47-497e-9eef-a34a72aa3871",
        "parentId" : null,
        "authorId" : "6252ac4b-6b9e-4dee-8931-ca3b934d52fc",
        "body" : "how about just glog.Infof?",
        "createdAt" : "2017-04-06T00:55:34Z",
        "updatedAt" : "2017-04-06T00:55:34Z",
        "lastEditedBy" : "6252ac4b-6b9e-4dee-8931-ca3b934d52fc",
        "tags" : [
        ]
      },
      {
        "id" : "b06c5df3-705e-4ef4-aa81-7e6a4a826150",
        "parentId" : "dc388520-4c47-497e-9eef-a34a72aa3871",
        "authorId" : "f81960f6-a033-4403-bebf-c8ebb484e444",
        "body" : "too noisy.. \r\n",
        "createdAt" : "2017-04-06T15:47:48Z",
        "updatedAt" : "2017-04-06T15:47:48Z",
        "lastEditedBy" : "f81960f6-a033-4403-bebf-c8ebb484e444",
        "tags" : [
        ]
      },
      {
        "id" : "350bfca9-967a-4f9e-81d5-edcd5cec0bac",
        "parentId" : "dc388520-4c47-497e-9eef-a34a72aa3871",
        "authorId" : "6252ac4b-6b9e-4dee-8931-ca3b934d52fc",
        "body" : "well, my suggestion was to keep it as noisy as glog.Errorf (to keep it same from output perspective), with the advantage that it wont be printed to stderr by default what glog does. perhaps just to address the comment by @davidopp. \r\n\r\nThat said, I completely agree with this current change too and comments by others.",
        "createdAt" : "2017-04-06T15:56:25Z",
        "updatedAt" : "2017-04-06T15:56:25Z",
        "lastEditedBy" : "6252ac4b-6b9e-4dee-8931-ca3b934d52fc",
        "tags" : [
        ]
      },
      {
        "id" : "4cc9702c-5cf8-4adb-914c-73f198c9e4c5",
        "parentId" : "dc388520-4c47-497e-9eef-a34a72aa3871",
        "authorId" : "a5be0b3b-3db2-4c99-a598-55f8708db5df",
        "body" : "honestly i trust developer intuition on this one.  log levels are always debatable but this isn't an extreme case where it makes a huge difference, lets move forward so we can avoid the error spam, thats the high-order-bit here.",
        "createdAt" : "2017-04-06T16:19:34Z",
        "updatedAt" : "2017-04-06T16:20:05Z",
        "lastEditedBy" : "a5be0b3b-3db2-4c99-a598-55f8708db5df",
        "tags" : [
        ]
      },
      {
        "id" : "01b5283d-3fa3-4732-b0bf-26cdc135d332",
        "parentId" : "dc388520-4c47-497e-9eef-a34a72aa3871",
        "authorId" : "82da2b23-9f40-4abd-8af5-56ba07c1fc0a",
        "body" : "IMO the best balance of the concerns here is to do glog.Infof() but only log when the pod becomes pending initially, not every time the scheduler re-discovers that it is pending. This is more work but I think it's better than hiding this information behind V(4).\r\n",
        "createdAt" : "2017-04-06T16:36:12Z",
        "updatedAt" : "2017-04-06T16:36:12Z",
        "lastEditedBy" : "82da2b23-9f40-4abd-8af5-56ba07c1fc0a",
        "tags" : [
        ]
      },
      {
        "id" : "0db0fb20-e83e-4553-8f17-5756da12303f",
        "parentId" : "dc388520-4c47-497e-9eef-a34a72aa3871",
        "authorId" : "a5be0b3b-3db2-4c99-a598-55f8708db5df",
        "body" : "but thats the whole point of pod conditions, though, right?  ",
        "createdAt" : "2017-04-06T16:48:17Z",
        "updatedAt" : "2017-04-06T16:48:17Z",
        "lastEditedBy" : "a5be0b3b-3db2-4c99-a598-55f8708db5df",
        "tags" : [
        ]
      },
      {
        "id" : "8f994bc5-4c2f-4386-9c80-5bc5bc79fd89",
        "parentId" : "dc388520-4c47-497e-9eef-a34a72aa3871",
        "authorId" : "82da2b23-9f40-4abd-8af5-56ba07c1fc0a",
        "body" : "Events and conditions are useful for seeing what's going on in a cluster now. Logging is useful for seeing what happened in the past (even possibly the recent past). ",
        "createdAt" : "2017-04-06T17:09:17Z",
        "updatedAt" : "2017-04-06T17:09:17Z",
        "lastEditedBy" : "82da2b23-9f40-4abd-8af5-56ba07c1fc0a",
        "tags" : [
        ]
      },
      {
        "id" : "300e180c-d564-4494-9954-5d9325fd56c9",
        "parentId" : "dc388520-4c47-497e-9eef-a34a72aa3871",
        "authorId" : "a5be0b3b-3db2-4c99-a598-55f8708db5df",
        "body" : "sure it is, but - do we want/need to couple this logging to the specific needs around scheduling forensics which probably exceed what is available from this data - If we care alot about forensics data (which i agree we should), why not simply have a struct that models this data and publish it periodically in the logs, or publish metrics that tell this story or something ?  \r\n\r\nI guess my concern is that if the logs start depending on state of things, they are harder to maintain and it won't be easy to enforce that forensics policy in the long term, so its just a short term bandaid .",
        "createdAt" : "2017-04-06T20:32:57Z",
        "updatedAt" : "2017-04-06T20:45:44Z",
        "lastEditedBy" : "a5be0b3b-3db2-4c99-a598-55f8708db5df",
        "tags" : [
        ]
      }
    ],
    "commit" : "25564b404c85885c5f18009d241e5b979bcda1d4",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +519,523 @@\t\t} else {\n\t\t\tif _, ok := err.(*core.FitError); ok {\n\t\t\t\tglog.V(4).Infof(\"Unable to schedule %v %v: no fit: %v; waiting\", pod.Namespace, pod.Name, err)\n\t\t\t} else {\n\t\t\t\tglog.Errorf(\"Error scheduling %v %v: %v; retrying\", pod.Namespace, pod.Name, err)"
  },
  {
    "id" : "4be5563b-8071-4a9a-9b2a-7f1a2ecc5449",
    "prId" : 44115,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/44115#pullrequestreview-31214759",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fd1ff24e-6d5a-46a8-80a4-90fa97f42eeb",
        "parentId" : null,
        "authorId" : "72156db3-c40b-4455-9838-c12c0c606019",
        "body" : "I'd like to merge this log to the following.",
        "createdAt" : "2017-04-06T02:47:19Z",
        "updatedAt" : "2017-04-06T02:47:19Z",
        "lastEditedBy" : "72156db3-c40b-4455-9838-c12c0c606019",
        "tags" : [
        ]
      }
    ],
    "commit" : "25564b404c85885c5f18009d241e5b979bcda1d4",
    "line" : 2,
    "diffHunk" : "@@ -1,1 +516,520 @@\treturn func(pod *v1.Pod, err error) {\n\t\tif err == core.ErrNoNodesAvailable {\n\t\t\tglog.V(4).Infof(\"Unable to schedule %v %v: no nodes are registered to the cluster; waiting\", pod.Namespace, pod.Name)\n\t\t} else {\n\t\t\tif _, ok := err.(*core.FitError); ok {"
  },
  {
    "id" : "d080c7ec-7957-4da5-8cea-125537e50477",
    "prId" : 36238,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/36238#pullrequestreview-40788073",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1692d6ee-852a-4948-86bf-816600912bfb",
        "parentId" : null,
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "Why we don't register UpdateFunc?\r\n\r\nSame for pvc.",
        "createdAt" : "2017-05-25T09:29:47Z",
        "updatedAt" : "2017-07-18T15:58:33Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      },
      {
        "id" : "8ec8037c-a5e3-42b5-86cd-27ba169616c8",
        "parentId" : "1692d6ee-852a-4948-86bf-816600912bfb",
        "authorId" : "7dd504ec-7e63-45b3-98f8-6eb1c683e9c2",
        "body" : "predicates related to PV/PVC are all about \"counts\", so I assume update is not related to this.",
        "createdAt" : "2017-05-29T14:42:27Z",
        "updatedAt" : "2017-07-18T15:58:33Z",
        "lastEditedBy" : "7dd504ec-7e63-45b3-98f8-6eb1c683e9c2",
        "tags" : [
        ]
      }
    ],
    "commit" : "f817b8a6f668f38968414d121cbd32e823629eb9",
    "line" : 69,
    "diffHunk" : "@@ -1,1 +223,227 @@\t\tcache.ResourceEventHandlerFuncs{\n\t\t\t// MaxPDVolumeCountPredicate: since it relies on the counts of PV.\n\t\t\tAddFunc:    c.onPvAdd,\n\t\t\tDeleteFunc: c.onPvDelete,\n\t\t},"
  },
  {
    "id" : "f2c551c5-6030-4cb0-be58-ded3fd061118",
    "prId" : 36238,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/36238#pullrequestreview-41493584",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "74cfab43-fc4d-4380-811d-927a507e74a4",
        "parentId" : null,
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "and here and everywhere below",
        "createdAt" : "2017-06-01T11:40:35Z",
        "updatedAt" : "2017-07-18T15:58:33Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      },
      {
        "id" : "057d7d50-16fd-4106-9d4b-e86936b4bc76",
        "parentId" : "74cfab43-fc4d-4380-811d-927a507e74a4",
        "authorId" : "7dd504ec-7e63-45b3-98f8-6eb1c683e9c2",
        "body" : "Fixed!",
        "createdAt" : "2017-06-01T12:29:35Z",
        "updatedAt" : "2017-07-18T15:58:33Z",
        "lastEditedBy" : "7dd504ec-7e63-45b3-98f8-6eb1c683e9c2",
        "tags" : [
        ]
      }
    ],
    "commit" : "f817b8a6f668f38968414d121cbd32e823629eb9",
    "line" : 207,
    "diffHunk" : "@@ -1,1 +361,365 @@\nfunc (c *ConfigFactory) onServiceDelete(obj interface{}) {\n\tif c.enableEquivalenceClassCache {\n\t\tc.equivalencePodCache.InvalidateCachedPredicateItemOfAllNodes(serviceAffinitySet)\n\t}"
  },
  {
    "id" : "1178a511-0615-4c33-b04c-50b78856cdf3",
    "prId" : 36238,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/36238#pullrequestreview-41528826",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e13061a0-46a1-4991-bf68-b51764758e68",
        "parentId" : null,
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "Can you do the same you did with \"serviceAffinitySet\" ?",
        "createdAt" : "2017-06-01T14:37:49Z",
        "updatedAt" : "2017-07-18T15:58:33Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "f817b8a6f668f38968414d121cbd32e823629eb9",
    "line" : 254,
    "diffHunk" : "@@ -1,1 +436,440 @@\t\t\tif !reflect.DeepEqual(predicates.GetResourceRequest(newPod),\n\t\t\t\tpredicates.GetResourceRequest(oldPod)) {\n\t\t\t\tc.equivalencePodCache.InvalidateCachedPredicateItem(\n\t\t\t\t\tnewPod.Spec.NodeName, generalPredicatesSets)\n\t\t\t}"
  },
  {
    "id" : "308cf66e-6fca-40a4-8b52-4ee114e92605",
    "prId" : 36238,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/36238#pullrequestreview-41542285",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "96034685-f4a3-4f6e-be2a-36e49a4cc9f3",
        "parentId" : null,
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "Can you do the same you did with \"serviceAffinitySet\" ?",
        "createdAt" : "2017-06-01T14:38:01Z",
        "updatedAt" : "2017-07-18T15:58:33Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      },
      {
        "id" : "bd4933ca-2680-4a28-bf49-ef62e4ffb344",
        "parentId" : "96034685-f4a3-4f6e-be2a-36e49a4cc9f3",
        "authorId" : "7dd504ec-7e63-45b3-98f8-6eb1c683e9c2",
        "body" : "Yes!",
        "createdAt" : "2017-06-01T15:17:19Z",
        "updatedAt" : "2017-07-18T15:58:33Z",
        "lastEditedBy" : "7dd504ec-7e63-45b3-98f8-6eb1c683e9c2",
        "tags" : [
        ]
      }
    ],
    "commit" : "f817b8a6f668f38968414d121cbd32e823629eb9",
    "line" : 284,
    "diffHunk" : "@@ -1,1 +480,484 @@\t\t\tif volume.GCEPersistentDisk != nil || volume.AWSElasticBlockStore != nil ||\n\t\t\t\tvolume.RBD != nil || volume.ISCSI != nil {\n\t\t\t\tc.equivalencePodCache.InvalidateCachedPredicateItem(\n\t\t\t\t\tpod.Spec.NodeName, noDiskConflictSet)\n\t\t\t}"
  },
  {
    "id" : "18f93ce5-8e48-4815-96dc-718e6a81ec25",
    "prId" : 36210,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/36210#pullrequestreview-9476805",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e548a3ce-1484-4aea-9c03-a4a82c04956b",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "this seems like a bad idea... it seems like it is requiring all future conditions to have a value of `False` to be schedulable, or require code changes here? I'd expect a generic scheduler predicate that lets you specify a condition and required value(s) in order to schedule",
        "createdAt" : "2016-11-21T15:40:51Z",
        "updatedAt" : "2016-11-21T15:42:10Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "511b2ecaa8025364e8ef43427ff08709b056f0cb",
    "line" : 24,
    "diffHunk" : "@@ -1,1 +519,523 @@\n\t\t\tdefault:\n\t\t\t\t// We assume everything else is blocking if the condition is True or Unknown\n\t\t\t\tif cond.Status != api.ConditionFalse {\n\t\t\t\t\tglog.V(4).Infof(\"Ignoring node %v with %v condition status %v\", node.Name, cond.Type, cond.Status)"
  },
  {
    "id" : "52de7c3f-b302-42f5-981a-3e12b9cc484e",
    "prId" : 34845,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/34845#pullrequestreview-4726306",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5895d7eb-0e5d-40c0-b145-329c7e5e73fe",
        "parentId" : null,
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "I'm not seeing where this factory is started.\n",
        "createdAt" : "2016-10-18T17:59:15Z",
        "updatedAt" : "2016-10-18T18:37:01Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      },
      {
        "id" : "b9640640-3b3e-4741-a712-745a13509e8c",
        "parentId" : "5895d7eb-0e5d-40c0-b145-329c7e5e73fe",
        "authorId" : "6eca0ade-9879-4dd7-ad14-547e16f5c041",
        "body" : "good catch\n",
        "createdAt" : "2016-10-18T18:02:00Z",
        "updatedAt" : "2016-10-18T18:37:01Z",
        "lastEditedBy" : "6eca0ade-9879-4dd7-ad14-547e16f5c041",
        "tags" : [
        ]
      },
      {
        "id" : "da29c663-75e7-4ac6-8ac5-1e5fa09887ba",
        "parentId" : "5895d7eb-0e5d-40c0-b145-329c7e5e73fe",
        "authorId" : "6eca0ade-9879-4dd7-ad14-547e16f5c041",
        "body" : "curious if the tests will fail ;-)\n",
        "createdAt" : "2016-10-18T18:02:08Z",
        "updatedAt" : "2016-10-18T18:37:01Z",
        "lastEditedBy" : "6eca0ade-9879-4dd7-ad14-547e16f5c041",
        "tags" : [
        ]
      }
    ],
    "commit" : "555231fad7dd5577d9847388bd9849459fae90a7",
    "line" : 35,
    "diffHunk" : "@@ -1,1 +111,115 @@\n\t// TODO: pass this in as an argument...\n\tinformerFactory := informers.NewSharedInformerFactory(client, 0)\n\tpvcInformer := informerFactory.PersistentVolumeClaims()\n"
  },
  {
    "id" : "86d68473-dec7-4698-bf3a-2f53334a9518",
    "prId" : 34685,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/34685#pullrequestreview-4368745",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3b2ad028-7fde-4318-bf98-64a02d77c4e0",
        "parentId" : null,
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "This PR is already quite huge, and is far from being trivial. Could you please split the more obvious parts to a separate PR.\nI would like to see a PR only with:\n- above changes to predicates.go\n- adding these Populators here (but just with empty handler functions).\n\nThis PR will be definite not controversial and we would be able to merge that one fast, and continue working on this one.\n",
        "createdAt" : "2016-10-14T11:57:55Z",
        "updatedAt" : "2016-10-17T15:42:33Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      },
      {
        "id" : "88a5d256-18d7-465f-871e-8151310214c9",
        "parentId" : "3b2ad028-7fde-4318-bf98-64a02d77c4e0",
        "authorId" : "7dd504ec-7e63-45b3-98f8-6eb1c683e9c2",
        "body" : "Yes, good idea, that makes scope much clear\n",
        "createdAt" : "2016-10-15T07:54:55Z",
        "updatedAt" : "2016-10-17T15:42:33Z",
        "lastEditedBy" : "7dd504ec-7e63-45b3-98f8-6eb1c683e9c2",
        "tags" : [
        ]
      }
    ],
    "commit" : "50eaeaa7bd179381e28283e14fa0b68768ae98d2",
    "line" : null,
    "diffHunk" : "@@ -1,1 +185,189 @@\t\tcache.Indexers{cache.NamespaceIndex: cache.MetaNamespaceIndexFunc},\n\t)\n\n\treturn c\n}"
  },
  {
    "id" : "ba82eee1-8d25-4435-ac34-43cca9edc512",
    "prId" : 34084,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/34084#pullrequestreview-3880780",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f2e1b5cb-3ad7-41ec-ab3d-c0d1252d61ed",
        "parentId" : null,
        "authorId" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "body" : "Why not just build ListWatch function with `factory.Client.Core().Pod(api.NamespaceAll).List(selecor)` and `factory.Client.Core().Pod(api.NamespaceAll).Watch(selecor)`? Building ListWatch func atop of RESTClient extracted from a client that's already able to list and watch looks wrong to me.\n",
        "createdAt" : "2016-10-05T23:18:42Z",
        "updatedAt" : "2016-10-14T12:45:01Z",
        "lastEditedBy" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "tags" : [
        ]
      },
      {
        "id" : "dbc6bb90-934a-4b83-8fbb-4f77e5cadfab",
        "parentId" : "f2e1b5cb-3ad7-41ec-ab3d-c0d1252d61ed",
        "authorId" : "c63e1ceb-64bd-4726-b8ef-e647d73dae0c",
        "body" : "I agree with that. Though, scheduler is not the only occurrence of the phenomenon. There are other places in kubelet, apiserver, proxy, etc. that are subjects to the replacement. I would suggest to open separate PR for it.\n",
        "createdAt" : "2016-10-06T09:04:56Z",
        "updatedAt" : "2016-10-14T12:45:01Z",
        "lastEditedBy" : "c63e1ceb-64bd-4726-b8ef-e647d73dae0c",
        "tags" : [
        ]
      },
      {
        "id" : "a24dca70-3d6a-4a98-8779-b8dde1ccee6a",
        "parentId" : "f2e1b5cb-3ad7-41ec-ab3d-c0d1252d61ed",
        "authorId" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "body" : "Ok. That's fair. Could you open an issue to track it?\n",
        "createdAt" : "2016-10-06T18:04:05Z",
        "updatedAt" : "2016-10-14T12:45:01Z",
        "lastEditedBy" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "tags" : [
        ]
      },
      {
        "id" : "9e2d4b9b-85e6-406e-9f15-4ebdfc926162",
        "parentId" : "f2e1b5cb-3ad7-41ec-ab3d-c0d1252d61ed",
        "authorId" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "body" : "I see you are calling `GetRESTClient()` in your other PRs as well. The clientset really shouldn't expose the RESTClient. It was a hack to get the rate limiter. I don't want to encourage more uses of `GetRESTClient()`. Could you fix the `NewListWatchFromClient` in this PR?\n",
        "createdAt" : "2016-10-06T18:35:05Z",
        "updatedAt" : "2016-10-14T12:45:01Z",
        "lastEditedBy" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "tags" : [
        ]
      },
      {
        "id" : "276ffe46-6551-4163-b6ac-29df0af61cf5",
        "parentId" : "f2e1b5cb-3ad7-41ec-ab3d-c0d1252d61ed",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "The reason why not build a function like that is the go type system makes it impossible to make a general interface, since the specific X/XList types are different for each object. :(\n",
        "createdAt" : "2016-10-06T22:36:14Z",
        "updatedAt" : "2016-10-14T12:45:01Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "ef78524c-3c64-4707-8cff-dbfaeff1f7fc",
        "parentId" : "f2e1b5cb-3ad7-41ec-ab3d-c0d1252d61ed",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "@caesarxuchao I think the best option, if you don't want people to break the glass, is to add a NewListWatch function to each client.\n",
        "createdAt" : "2016-10-06T22:37:23Z",
        "updatedAt" : "2016-10-14T12:45:01Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "3bd79089-96d9-498f-a67b-8da7d368ef98",
        "parentId" : "f2e1b5cb-3ad7-41ec-ab3d-c0d1252d61ed",
        "authorId" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "body" : "> The reason why not build a function like that is the go type system makes it impossible to make a general interface\n\nRight. I missed it.\n\n@ingvagabund mostly looks good. I left a comment regarding the `Event` methods. Let me know if you need more help.\n",
        "createdAt" : "2016-10-11T22:42:44Z",
        "updatedAt" : "2016-10-14T12:45:01Z",
        "lastEditedBy" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "tags" : [
        ]
      },
      {
        "id" : "4cfd2374-88b7-402f-8cec-96042c4a5f58",
        "parentId" : "f2e1b5cb-3ad7-41ec-ab3d-c0d1252d61ed",
        "authorId" : "c63e1ceb-64bd-4726-b8ef-e647d73dae0c",
        "body" : "> @caesarxuchao I think the best option, if you don't want people to break the glass, is to add a NewListWatch function to each client.\n\nI like this approach. That could be done as another PR on top or as a part of #34138.\n",
        "createdAt" : "2016-10-12T14:10:27Z",
        "updatedAt" : "2016-10-14T12:45:01Z",
        "lastEditedBy" : "c63e1ceb-64bd-4726-b8ef-e647d73dae0c",
        "tags" : [
        ]
      }
    ],
    "commit" : "19ab3c614049da8094534c87b188efa8cb270031",
    "line" : 32,
    "diffHunk" : "@@ -1,1 +479,483 @@func (factory *ConfigFactory) createUnassignedNonTerminatedPodLW() *cache.ListWatch {\n\tselector := fields.ParseSelectorOrDie(\"spec.nodeName==\" + \"\" + \",status.phase!=\" + string(api.PodSucceeded) + \",status.phase!=\" + string(api.PodFailed))\n\treturn cache.NewListWatchFromClient(factory.Client.Core().GetRESTClient(), \"pods\", api.NamespaceAll, selector)\n}\n"
  },
  {
    "id" : "4e2c8a10-dd1f-4a19-bf03-79f9f52d51ae",
    "prId" : 29100,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "09896a12-ad39-45a3-84bc-08d10286706c",
        "parentId" : null,
        "authorId" : "63ae7701-0f8c-4ae2-9295-07a4434026ce",
        "body" : "This may be an infinite loop\n",
        "createdAt" : "2016-07-18T12:23:18Z",
        "updatedAt" : "2016-07-19T06:18:13Z",
        "lastEditedBy" : "63ae7701-0f8c-4ae2-9295-07a4434026ce",
        "tags" : [
        ]
      },
      {
        "id" : "bc789494-b0c5-4e42-a281-d863d85c76f4",
        "parentId" : "09896a12-ad39-45a3-84bc-08d10286706c",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "Yes - it may be - otherwise we will loose the pod and it will never be scheduled. This is on purpose.\n",
        "createdAt" : "2016-07-18T12:26:28Z",
        "updatedAt" : "2016-07-19T06:18:13Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "66009877bc929684da0683ad0cd6916f279b126a",
    "line" : null,
    "diffHunk" : "@@ -1,1 +535,539 @@\t\t\tpod = &api.Pod{}\n\t\t\tgetBackoff := initialGetBackoff\n\t\t\tfor {\n\t\t\t\tif err := factory.Client.Get().Namespace(podID.Namespace).Resource(\"pods\").Name(podID.Name).Do().Into(pod); err == nil {\n\t\t\t\t\tbreak"
  },
  {
    "id" : "8baabe36-aee8-49c6-ba27-9b6f626e56d9",
    "prId" : 26069,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "19de3d84-ed46-4301-8327-3b11f2e54341",
        "parentId" : null,
        "authorId" : "bb4cf218-381a-40ad-ac0c-0c2c66685cd4",
        "body" : "We are not using random generator anymore. Just set nil in the argument.\n",
        "createdAt" : "2016-05-23T16:22:25Z",
        "updatedAt" : "2016-05-24T07:04:38Z",
        "lastEditedBy" : "bb4cf218-381a-40ad-ac0c-0c2c66685cd4",
        "tags" : [
        ]
      },
      {
        "id" : "f2bb6d8f-c863-4c6d-b436-50e9b4213e3b",
        "parentId" : "19de3d84-ed46-4301-8327-3b11f2e54341",
        "authorId" : "df06b0d6-fd6c-44d1-8008-efeaccd16cd5",
        "body" : "This is the current code :) See line 367 on the left.\n",
        "createdAt" : "2016-05-23T16:27:53Z",
        "updatedAt" : "2016-05-24T07:04:38Z",
        "lastEditedBy" : "df06b0d6-fd6c-44d1-8008-efeaccd16cd5",
        "tags" : [
        ]
      },
      {
        "id" : "dc2feed9-77e0-4426-b29e-c0dc4c384aa4",
        "parentId" : "19de3d84-ed46-4301-8327-3b11f2e54341",
        "authorId" : "bb4cf218-381a-40ad-ac0c-0c2c66685cd4",
        "body" : "Gotcha. A problem of \"Unified\" view.\n",
        "createdAt" : "2016-05-23T16:33:02Z",
        "updatedAt" : "2016-05-24T07:04:38Z",
        "lastEditedBy" : "bb4cf218-381a-40ad-ac0c-0c2c66685cd4",
        "tags" : [
        ]
      }
    ],
    "commit" : "55a1c826bbd71388672aa543586d1f8431daf1c0",
    "line" : 16,
    "diffHunk" : "@@ -1,1 +318,322 @@\tf.Run()\n\n\tr := rand.New(rand.NewSource(time.Now().UnixNano()))\n\n\talgo := scheduler.NewGenericScheduler(f.schedulerCache, predicateFuncs, priorityConfigs, extenders, r)"
  },
  {
    "id" : "f24d62d2-cc41-4e30-8783-04d16aa620e9",
    "prId" : 26069,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d43996c1-a62a-479f-a4fe-e2e01c515e4f",
        "parentId" : null,
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "nit: can you please create pluginArgs first, and simply pass them here and to getPriorityFunctionConfigs?\nCurrently you are duplicating some code, unnecessary.\n",
        "createdAt" : "2016-05-24T05:11:29Z",
        "updatedAt" : "2016-05-24T07:04:38Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      },
      {
        "id" : "34e3f3bf-26fa-4232-9fb7-491cffdce3f5",
        "parentId" : "d43996c1-a62a-479f-a4fe-e2e01c515e4f",
        "authorId" : "df06b0d6-fd6c-44d1-8008-efeaccd16cd5",
        "body" : "Done. Slightly different than what you're proposing, but should meet your criteria :)\n",
        "createdAt" : "2016-05-24T07:10:58Z",
        "updatedAt" : "2016-05-24T07:10:58Z",
        "lastEditedBy" : "df06b0d6-fd6c-44d1-8008-efeaccd16cd5",
        "tags" : [
        ]
      }
    ],
    "commit" : "55a1c826bbd71388672aa543586d1f8431daf1c0",
    "line" : null,
    "diffHunk" : "@@ -1,1 +306,310 @@\t}\n\n\tpredicateFuncs, err := f.GetPredicates(predicateKeys)\n\tif err != nil {\n\t\treturn nil, err"
  },
  {
    "id" : "771df728-614c-4d02-9888-d3c6abfe3670",
    "prId" : 24459,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "267129a5-033c-4b66-8a8f-2f01c5f7bda0",
        "parentId" : null,
        "authorId" : "bb4cf218-381a-40ad-ac0c-0c2c66685cd4",
        "body" : "AFAIK, the client is doing some retries:\nhttps://github.com/kubernetes/kubernetes/blob/8472cfa214369f69f2dc680962be63ba34199bd2/pkg/client/restclient/request.go#L785-L785\n\nI'm inclined to make it async. But not super worried about it because of error path. I will let @davidopp make the decision.\n",
        "createdAt" : "2016-04-20T23:04:06Z",
        "updatedAt" : "2016-05-12T08:21:28Z",
        "lastEditedBy" : "bb4cf218-381a-40ad-ac0c-0c2c66685cd4",
        "tags" : [
        ]
      }
    ],
    "commit" : "a80b1798c45f88e6b38261a1657c0dfa787de136",
    "line" : 25,
    "diffHunk" : "@@ -1,1 +457,461 @@\tglog.V(2).Infof(\"Updating pod condition for %s/%s to (%s==%s)\", pod.Namespace, pod.Name, condition.Type, condition.Status)\n\tif api.UpdatePodCondition(&pod.Status, condition) {\n\t\t_, err := p.Pods(pod.Namespace).UpdateStatus(pod)\n\t\treturn err\n\t}"
  },
  {
    "id" : "4710be0f-3818-40ac-b1bb-1be6951a3960",
    "prId" : 17865,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9f83233c-90cd-4385-b106-542b5d539f31",
        "parentId" : null,
        "authorId" : "bb4cf218-381a-40ad-ac0c-0c2c66685cd4",
        "body" : "just use the function as the value of `NextPod`\n",
        "createdAt" : "2015-11-28T06:54:16Z",
        "updatedAt" : "2015-12-22T03:07:07Z",
        "lastEditedBy" : "bb4cf218-381a-40ad-ac0c-0c2c66685cd4",
        "tags" : [
        ]
      },
      {
        "id" : "42be7229-235d-4100-b155-3ebadad3ba85",
        "parentId" : "9f83233c-90cd-4385-b106-542b5d539f31",
        "authorId" : "82da2b23-9f40-4abd-8af5-56ba07c1fc0a",
        "body" : "good point -- I assume you mean this line and the previous and next can collapse to just\nNextPod: f.getNextPod(),\n",
        "createdAt" : "2015-11-28T07:04:58Z",
        "updatedAt" : "2015-12-22T03:07:07Z",
        "lastEditedBy" : "82da2b23-9f40-4abd-8af5-56ba07c1fc0a",
        "tags" : [
        ]
      },
      {
        "id" : "16bab988-7078-44c4-afcf-345b151bf839",
        "parentId" : "9f83233c-90cd-4385-b106-542b5d539f31",
        "authorId" : "367ad63e-2fc8-4db1-949a-10424aaf7469",
        "body" : "agreed.\n",
        "createdAt" : "2015-11-28T07:06:57Z",
        "updatedAt" : "2015-12-22T03:07:07Z",
        "lastEditedBy" : "367ad63e-2fc8-4db1-949a-10424aaf7469",
        "tags" : [
        ]
      },
      {
        "id" : "3c8acffa-a3e8-469b-aa0e-ae35bcf7870a",
        "parentId" : "9f83233c-90cd-4385-b106-542b5d539f31",
        "authorId" : "367ad63e-2fc8-4db1-949a-10424aaf7469",
        "body" : "Changing to NextPod: f.getNextPod() would require many follow-up changes which I think is not necessary. It is not as easy as I thought. Other than that, all comments are respected in the updated PR, including an integration test.\n",
        "createdAt" : "2015-12-04T03:04:44Z",
        "updatedAt" : "2015-12-22T03:07:07Z",
        "lastEditedBy" : "367ad63e-2fc8-4db1-949a-10424aaf7469",
        "tags" : [
        ]
      }
    ],
    "commit" : "d9f3607292a244125145b14b57f11622817ad66c",
    "line" : 43,
    "diffHunk" : "@@ -1,1 +239,243 @@\t\tBinder:     &binder{f.Client},\n\t\tNextPod: func() *api.Pod {\n\t\t\treturn f.getNextPod()\n\t\t},\n\t\tError:               f.makeDefaultErrorFunc(&podBackoff, f.PodQueue),"
  },
  {
    "id" : "1b3e0e12-2763-422f-ae52-568a08838102",
    "prId" : 14451,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2294e291-3305-417e-a239-604c0465d62a",
        "parentId" : null,
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "might be worth adding \"not safe to copy\"\n",
        "createdAt" : "2015-09-24T17:03:24Z",
        "updatedAt" : "2015-09-24T22:43:43Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "190ed965-dd9a-41ad-8bdc-0efe26ca1d32",
        "parentId" : "2294e291-3305-417e-a239-604c0465d62a",
        "authorId" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "body" : "done.\n",
        "createdAt" : "2015-09-24T22:28:23Z",
        "updatedAt" : "2015-09-24T22:43:43Z",
        "lastEditedBy" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "tags" : [
        ]
      }
    ],
    "commit" : "40247acb0f812a16f4e5950b0f55c91ca9958c55",
    "line" : 66,
    "diffHunk" : "@@ -1,1 +346,350 @@\n// backoffEntry is single threaded.  in particular, it only allows a single action to be waiting on backoff at a time.\n// It is expected that all users will only use the public TryWait(...) method\n// It is also not safe to copy this object.\ntype backoffEntry struct {"
  },
  {
    "id" : "da9dbd60-92af-483e-b43a-dfb996f70e48",
    "prId" : 10667,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "98185421-c908-4389-94ff-f3fa3d1e3a22",
        "parentId" : null,
        "authorId" : "82da2b23-9f40-4abd-8af5-56ba07c1fc0a",
        "body" : "I think the second sentence of this comment is no longer accurate after you changed the way the algorithm works. \n",
        "createdAt" : "2015-07-25T05:55:19Z",
        "updatedAt" : "2015-07-31T14:29:15Z",
        "lastEditedBy" : "82da2b23-9f40-4abd-8af5-56ba07c1fc0a",
        "tags" : [
        ]
      },
      {
        "id" : "7c251457-15ac-4f59-9f1e-ffef2597a3f6",
        "parentId" : "98185421-c908-4389-94ff-f3fa3d1e3a22",
        "authorId" : "3c437914-616b-4cfb-88a0-28dc812ff2b2",
        "body" : "Done.\n",
        "createdAt" : "2015-07-27T14:21:41Z",
        "updatedAt" : "2015-07-31T14:29:15Z",
        "lastEditedBy" : "3c437914-616b-4cfb-88a0-28dc812ff2b2",
        "tags" : [
        ]
      }
    ],
    "commit" : "94eb52de33d513958bcdb70cc7595d71ecfa1fe3",
    "line" : 44,
    "diffHunk" : "@@ -1,1 +196,200 @@\tcache.NewReflector(f.createServiceLW(), &api.Service{}, f.ServiceLister.Store, 0).RunUntil(f.StopEverything)\n\n\t// Watch and cache all ReplicationController objects. Scheduler needs to find all pods\n\t// created by the same services or ReplicationControllers, so that it can spread them correctly.\n\t// Cache this locally."
  },
  {
    "id" : "b5007318-2a40-41c9-8e9e-d93dd990b40a",
    "prId" : 6546,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a0e2cf87-523e-422b-90d9-b44c0bb7cf1b",
        "parentId" : null,
        "authorId" : "82da2b23-9f40-4abd-8af5-56ba07c1fc0a",
        "body" : "In a followup CL can you make the 10*time.Second a flag?\n",
        "createdAt" : "2015-04-10T01:23:04Z",
        "updatedAt" : "2015-04-10T23:03:07Z",
        "lastEditedBy" : "82da2b23-9f40-4abd-8af5-56ba07c1fc0a",
        "tags" : [
        ]
      }
    ],
    "commit" : "395d69641ebcbd0fb466629d6aa461a45e57d854",
    "line" : 117,
    "diffHunk" : "@@ -1,1 +172,176 @@\t\t// Disable this code until minions support watches. Note when this code is enabled,\n\t\t// we need to make sure minion ListWatcher has proper FieldSelector.\n\t\tcache.NewReflector(f.createMinionLW(), &api.Node{}, f.NodeLister.Store, 10*time.Second).RunUntil(f.StopEverything)\n\t} else {\n\t\tcache.NewPoller(f.pollMinions, 10*time.Second, f.NodeLister.Store).RunUntil(f.StopEverything)"
  },
  {
    "id" : "0834ad4a-8866-4381-9a37-5474a8925163",
    "prId" : 3389,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "50318cf0-53ae-48b5-9f51-deec808e1349",
        "parentId" : null,
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "Do minions support watches now? Can we enable this and remove the poller?\n",
        "createdAt" : "2015-01-12T18:52:49Z",
        "updatedAt" : "2015-01-13T22:09:20Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "c5b21789-f584-4e5c-a4c8-889186853247",
        "parentId" : "50318cf0-53ae-48b5-9f51-deec808e1349",
        "authorId" : "7116d1ae-39f7-4e5d-81a9-1bcb75ebd909",
        "body" : "Yes and no.  Basic node watch is implemented in #2662, but it only enables watch by label (no watch by status).\n\nWe can either:\n1. Watch all nodes, and filter out unhealthy nodes in some custom watch handler.  Not sure if the listwatch pkg support it.\nor\n2. Do not enable watch, wait until node status is fully understood by the system.\n",
        "createdAt" : "2015-01-12T22:31:28Z",
        "updatedAt" : "2015-01-13T22:09:20Z",
        "lastEditedBy" : "7116d1ae-39f7-4e5d-81a9-1bcb75ebd909",
        "tags" : [
        ]
      }
    ],
    "commit" : "153dbd30a3a376247422cc11470adf40b24d6ead",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +101,105 @@\tif false {\n\t\t// Disable this code until minions support watches. Note when this code is enabled,\n\t\t// we need to make sure minion ListWatcher has proper FieldSelector.\n\t\tcache.NewReflector(f.createMinionLW(), &api.Node{}, f.MinionLister.Store).Run()\n\t} else {"
  },
  {
    "id" : "bdd39b29-8613-4aa0-8948-baa8aea32192",
    "prId" : 1613,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "cbb0d79d-0d43-4059-9d13-4589896b0f75",
        "parentId" : null,
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "This is a bug in the scheduler-- @brendandburns did you add this call to List? It should NOT be listing at setup time, only at run time. Nodes can change at runtime!!\n",
        "createdAt" : "2014-10-07T19:52:03Z",
        "updatedAt" : "2014-10-07T19:52:03Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      }
    ],
    "commit" : "16641757ef5e8c245e2765ecbf0a5f19ea8da54f",
    "line" : 11,
    "diffHunk" : "@@ -1,1 +65,69 @@\tr := rand.New(rand.NewSource(time.Now().UnixNano()))\n\n\tnodes, err := factory.Client.ListMinions()\n\tif err != nil {\n\t\treturn nil, err"
  },
  {
    "id" : "621e4b90-b97e-4c92-847b-465bd1a665c3",
    "prId" : 1449,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5dbab01e-993b-4b7a-9871-6036ad07ccc4",
        "parentId" : null,
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "I think some comment describing the semantic intent of these construction parameters would be in order.\n",
        "createdAt" : "2014-09-26T17:16:49Z",
        "updatedAt" : "2014-09-26T17:26:36Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "4f3df02c-9bd5-48f4-992b-f44eb5768c17",
        "parentId" : "5dbab01e-993b-4b7a-9871-6036ad07ccc4",
        "authorId" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "body" : "done.\n",
        "createdAt" : "2014-09-26T17:26:42Z",
        "updatedAt" : "2014-09-26T17:26:42Z",
        "lastEditedBy" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "tags" : [
        ]
      }
    ],
    "commit" : "1bb962961c929d7cdd88c36c57498109bf9f8737",
    "line" : null,
    "diffHunk" : "@@ -1,1 +63,67 @@\n\tr := rand.New(rand.NewSource(time.Now().UnixNano()))\n\talgo := algorithm.NewGenericScheduler(\n\t\t// Fit is defined based on the absence of port conflicts.\n\t\t[]algorithm.FitPredicate{algorithm.PodFitsPorts},"
  },
  {
    "id" : "20fc9678-84df-4366-823e-09b89b84491b",
    "prId" : 961,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "de8ef75b-60be-450e-a231-f3d990766235",
        "parentId" : null,
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Verbosity should probably be above the default (unless this is only temporary to aid debugging, in which case add a todo)\n",
        "createdAt" : "2014-08-22T22:58:48Z",
        "updatedAt" : "2014-08-25T18:59:14Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      }
    ],
    "commit" : "98ef76c164c2553e984da7e05bc82c4697d8b4ac",
    "line" : null,
    "diffHunk" : "@@ -1,1 +74,78 @@\t\t\t// make it easy to find scheduling problems.\n\t\t\tglog.Infof(\"About to try and schedule pod %v\\n\"+\n\t\t\t\t\"\\tknown minions: %v\\n\"+\n\t\t\t\t\"\\tknown scheduled pods: %v\\n\",\n\t\t\t\tpod.ID, minionCache.Contains(), podCache.Contains())"
  },
  {
    "id" : "d8afd3de-bab8-4e83-8bbe-b684ee30fbad",
    "prId" : 961,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9f0a25e3-6855-4989-91ac-4fbd8689cb44",
        "parentId" : null,
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Same about verbosity\n",
        "createdAt" : "2014-08-22T23:11:05Z",
        "updatedAt" : "2014-08-25T18:59:14Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      }
    ],
    "commit" : "98ef76c164c2553e984da7e05bc82c4697d8b4ac",
    "line" : null,
    "diffHunk" : "@@ -1,1 +203,207 @@\t// TODO: Remove or reduce verbosity by sep 6th, 2014. Leave until then to\n\t// make it easy to find scheduling problems.\n\tglog.Infof(\"Attempting to bind %v to %v\", binding.PodID, binding.Host)\n\treturn b.Post().Path(\"bindings\").Body(binding).Do().Error()\n}"
  }
]
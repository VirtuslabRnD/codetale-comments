[
  {
    "id" : "b56e1a31-9499-43ed-8899-81f03d1f2399",
    "prId" : 53793,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/53793#pullrequestreview-68898326",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "89514cf8-6afb-4853-87ef-094a807828cf",
        "parentId" : null,
        "authorId" : "57a5e7e7-e6d7-467b-96ab-41e4ca978eee",
        "body" : "Use `NewForConfigOrDie` here too?",
        "createdAt" : "2017-10-12T11:31:22Z",
        "updatedAt" : "2017-10-12T11:44:55Z",
        "lastEditedBy" : "57a5e7e7-e6d7-467b-96ab-41e4ca978eee",
        "tags" : [
        ]
      },
      {
        "id" : "0fe25fe9-827a-4f3b-99c5-7f5584d9733d",
        "parentId" : "89514cf8-6afb-4853-87ef-094a807828cf",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "No - this is by design.\r\nWith the first call here, I want to catch an error if any.\r\nWith the second call, I already validated the config (via the first call). So it's safe to call ...OrDie, because something really bad need to happen so that it will actually die.",
        "createdAt" : "2017-10-12T11:44:05Z",
        "updatedAt" : "2017-10-12T11:44:55Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      },
      {
        "id" : "aed50122-435d-415b-993d-7de3c3c89c01",
        "parentId" : "89514cf8-6afb-4853-87ef-094a807828cf",
        "authorId" : "57a5e7e7-e6d7-467b-96ab-41e4ca978eee",
        "body" : "Interesting.. Thanks for the explanation.",
        "createdAt" : "2017-10-12T11:55:22Z",
        "updatedAt" : "2017-10-12T11:55:22Z",
        "lastEditedBy" : "57a5e7e7-e6d7-467b-96ab-41e4ca978eee",
        "tags" : [
        ]
      }
    ],
    "commit" : "234e20b620e66489e3d5b6af1a2e560a2b2c2725",
    "line" : 18,
    "diffHunk" : "@@ -1,1 +67,71 @@\tkubeconfig.QPS = s.KubeAPIQPS\n\tkubeconfig.Burst = int(s.KubeAPIBurst)\n\tkubeClient, err := clientset.NewForConfig(restclient.AddUserAgent(kubeconfig, \"scheduler\"))\n\tif err != nil {\n\t\tglog.Fatalf(\"Invalid API configuration: %v\", err)"
  },
  {
    "id" : "a96ea175-e8bf-44c5-a954-5db93574290f",
    "prId" : 43892,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/43892#pullrequestreview-32451639",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f3a4750f-1be3-4772-8da6-3bc3ec6e6152",
        "parentId" : null,
        "authorId" : "f81960f6-a033-4403-bebf-c8ebb484e444",
        "body" : "seems brittle.  ",
        "createdAt" : "2017-04-06T15:20:32Z",
        "updatedAt" : "2017-04-08T00:32:22Z",
        "lastEditedBy" : "f81960f6-a033-4403-bebf-c8ebb484e444",
        "tags" : [
        ]
      },
      {
        "id" : "21e2e1a3-a564-4877-9fcb-28d7916795cb",
        "parentId" : "f3a4750f-1be3-4772-8da6-3bc3ec6e6152",
        "authorId" : "15fb535e-c5be-47ce-a304-1cb5da5aca90",
        "body" : "Why do you think it is brittle? When one imports an existing policy from a config file to a ConfigMap, the `Data` section of the map will get only one element. If there are more than one elements in the map, we won't know which one to use.",
        "createdAt" : "2017-04-06T16:55:51Z",
        "updatedAt" : "2017-04-08T00:32:22Z",
        "lastEditedBy" : "15fb535e-c5be-47ce-a304-1cb5da5aca90",
        "tags" : [
        ]
      },
      {
        "id" : "5b189df3-6267-4ec6-a159-548d9daae4d4",
        "parentId" : "f3a4750f-1be3-4772-8da6-3bc3ec6e6152",
        "authorId" : "f81960f6-a033-4403-bebf-c8ebb484e444",
        "body" : "If a person makes a honest mistake it doesn't make a best effort to interpret and log a warning.  I won't block on this, but it's worth noting.  ",
        "createdAt" : "2017-04-06T18:12:36Z",
        "updatedAt" : "2017-04-08T00:32:22Z",
        "lastEditedBy" : "f81960f6-a033-4403-bebf-c8ebb484e444",
        "tags" : [
        ]
      },
      {
        "id" : "8132390c-9ae7-47ff-b459-96a5693af2be",
        "parentId" : "f3a4750f-1be3-4772-8da6-3bc3ec6e6152",
        "authorId" : "15fb535e-c5be-47ce-a304-1cb5da5aca90",
        "body" : "The fact that we don't make a best effort is intentional. IMO it is better to fail to initialize the scheduler and let the user know that their config has errors than to initialize with an unintended config and surprise the user with the behavior. The latter would be harder to debug. You know how many warnings are thrown in each module and how effective they are in helping debug large systems.",
        "createdAt" : "2017-04-06T19:26:40Z",
        "updatedAt" : "2017-04-08T00:32:22Z",
        "lastEditedBy" : "15fb535e-c5be-47ce-a304-1cb5da5aca90",
        "tags" : [
        ]
      },
      {
        "id" : "f5fd2eb5-2531-4aff-8854-5af1929201fe",
        "parentId" : "f3a4750f-1be3-4772-8da6-3bc3ec6e6152",
        "authorId" : "f81960f6-a033-4403-bebf-c8ebb484e444",
        "body" : "I kind of wrote my second comment in haste, I completely agree with failing fast.  \r\n\r\nI think my initial aversion here is that this almost seems like a logic portion of a obj.deserialization f(n), which should have it's own checks in place.  ",
        "createdAt" : "2017-04-06T19:50:59Z",
        "updatedAt" : "2017-04-08T00:32:22Z",
        "lastEditedBy" : "f81960f6-a033-4403-bebf-c8ebb484e444",
        "tags" : [
        ]
      },
      {
        "id" : "c49fd33b-a2ac-4ad5-8560-dddc3f9e8563",
        "parentId" : "f3a4750f-1be3-4772-8da6-3bc3ec6e6152",
        "authorId" : "15fb535e-c5be-47ce-a304-1cb5da5aca90",
        "body" : "We are using an existing mechanism for deserializing both the contents of a ConfigMap entry and a legacy config file. Before calling deserialization we need to make this quick sanity check. I agree that the sanity check belongs to deserialization code, but since we are sharing the deserialization with config file, I thought it would be fine to perform the check here.",
        "createdAt" : "2017-04-06T20:59:09Z",
        "updatedAt" : "2017-04-08T00:32:22Z",
        "lastEditedBy" : "15fb535e-c5be-47ce-a304-1cb5da5aca90",
        "tags" : [
        ]
      },
      {
        "id" : "e0b51722-08e3-4b92-aa63-ae58594ddf75",
        "parentId" : "f3a4750f-1be3-4772-8da6-3bc3ec6e6152",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "the brittle part is that we are not looking for a specific key. this blocks our ability to add anything to this config map in a compatible way.",
        "createdAt" : "2017-04-12T02:22:16Z",
        "updatedAt" : "2017-04-12T02:22:16Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "1a2ca856-f878-4488-aece-d9f55bb4cbb9",
        "parentId" : "f3a4750f-1be3-4772-8da6-3bc3ec6e6152",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "the scheduler should either look for a fixed key or be able to be told which key to use",
        "createdAt" : "2017-04-12T02:40:55Z",
        "updatedAt" : "2017-04-12T02:40:55Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "dab86f5f-9256-4738-b1db-b53c404c92bf",
        "parentId" : "f3a4750f-1be3-4772-8da6-3bc3ec6e6152",
        "authorId" : "15fb535e-c5be-47ce-a304-1cb5da5aca90",
        "body" : "@liggitt When an existing policy file is imported by `kubectl`, the key will be the name of the file and the content of the file will go in the value. I wanted to make it easy for customers to import their existing configs and use it. If more keys are needed in the config, they can be added to the content which is the \"value\" of the first element.",
        "createdAt" : "2017-04-12T17:57:15Z",
        "updatedAt" : "2017-04-12T17:57:15Z",
        "lastEditedBy" : "15fb535e-c5be-47ce-a304-1cb5da5aca90",
        "tags" : [
        ]
      },
      {
        "id" : "79fcae2c-a589-4af9-ad88-48f2740a502a",
        "parentId" : "f3a4750f-1be3-4772-8da6-3bc3ec6e6152",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "accepting a single arbitrary key is confusing... kubectl can set the key when importing an existing config file (`--from-file=config.json=/path/to/my-scheduler-config.yaml`), and we should direct the user to do that.",
        "createdAt" : "2017-04-12T18:00:02Z",
        "updatedAt" : "2017-04-12T18:00:02Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "4bfdb97f-050f-4301-851b-2da0de3addd3",
        "parentId" : "f3a4750f-1be3-4772-8da6-3bc3ec6e6152",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "for example, if I have a working scheduler pointing at a config map, I would *not* expect adding a second key to break the scheduler",
        "createdAt" : "2017-04-12T18:01:10Z",
        "updatedAt" : "2017-04-12T18:01:10Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "1e585d0b-b17e-4dec-998c-560c2edda234",
        "parentId" : "f3a4750f-1be3-4772-8da6-3bc3ec6e6152",
        "authorId" : "15fb535e-c5be-47ce-a304-1cb5da5aca90",
        "body" : "I see. I didn't know that kubectl can set the key. I will send a PR to remove the restriction on having only one element in the map and will add the logic to look for a specific key.",
        "createdAt" : "2017-04-12T18:06:59Z",
        "updatedAt" : "2017-04-12T18:06:59Z",
        "lastEditedBy" : "15fb535e-c5be-47ce-a304-1cb5da5aca90",
        "tags" : [
        ]
      }
    ],
    "commit" : "f9d1333144f145c215d10b67fd6fd1d59e2254c7",
    "line" : 72,
    "diffHunk" : "@@ -1,1 +142,146 @@\t\t\t// We expect the first element in the Data member of the ConfigMap to\n\t\t\t// contain the policy config.\n\t\t\tif len(policyConfigMap.Data) != 1 {\n\t\t\t\treturn nil, fmt.Errorf(\"ConfigMap %v has %v entries in its 'Data'. It must have only one.\", sc.policyConfigMap, len(policyConfigMap.Data))\n\t\t\t}"
  },
  {
    "id" : "5c05dbbd-f12f-4db8-ba5c-d404680b3c4b",
    "prId" : 40696,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/40696#pullrequestreview-19458983",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a2428fd2-21d2-44f4-8b61-8f68558c7b80",
        "parentId" : null,
        "authorId" : "f81960f6-a033-4403-bebf-c8ebb484e444",
        "body" : "It seems slightly odd to have a non-exported struct but an exported f(n).",
        "createdAt" : "2017-01-30T20:50:42Z",
        "updatedAt" : "2017-02-02T20:39:40Z",
        "lastEditedBy" : "f81960f6-a033-4403-bebf-c8ebb484e444",
        "tags" : [
        ]
      },
      {
        "id" : "d49ec15a-0bc8-4dfd-a610-6aa64d6c4ec0",
        "parentId" : "a2428fd2-21d2-44f4-8b61-8f68558c7b80",
        "authorId" : "a5be0b3b-3db2-4c99-a598-55f8708db5df",
        "body" : "Agree its weird.  I added a comment on the method so its clear why we export it.",
        "createdAt" : "2017-01-30T21:32:19Z",
        "updatedAt" : "2017-02-02T20:39:40Z",
        "lastEditedBy" : "a5be0b3b-3db2-4c99-a598-55f8708db5df",
        "tags" : [
        ]
      },
      {
        "id" : "5aa65c78-8a2b-4ac0-97a8-617d386d5b9e",
        "parentId" : "a2428fd2-21d2-44f4-8b61-8f68558c7b80",
        "authorId" : "f81960f6-a033-4403-bebf-c8ebb484e444",
        "body" : "Does the Create() f(n) need to be exported then? isn't it only used locally?  ",
        "createdAt" : "2017-01-31T20:50:10Z",
        "updatedAt" : "2017-02-02T20:39:40Z",
        "lastEditedBy" : "f81960f6-a033-4403-bebf-c8ebb484e444",
        "tags" : [
        ]
      },
      {
        "id" : "08b424f9-4669-45b4-bdab-b49f59653444",
        "parentId" : "a2428fd2-21d2-44f4-8b61-8f68558c7b80",
        "authorId" : "a5be0b3b-3db2-4c99-a598-55f8708db5df",
        "body" : "Yeah, just to match the interface definition signature.  It is specificallly overriding one and only one function in the struct used to initialize it. using that golang-ish style of dynamic inheritance ... makes sense ?",
        "createdAt" : "2017-02-01T00:23:48Z",
        "updatedAt" : "2017-02-02T20:39:40Z",
        "lastEditedBy" : "a5be0b3b-3db2-4c99-a598-55f8708db5df",
        "tags" : [
        ]
      }
    ],
    "commit" : "1590f9e70f822694b203ab372d3358435d16d5dd",
    "line" : 88,
    "diffHunk" : "@@ -1,1 +86,90 @@// schedulerConfigurator is an interface wrapper that provides default Configuration creation based on user\n// provided config file.\ntype schedulerConfigurator struct {\n\tscheduler.Configurator\n\tpolicyFile        string"
  }
]
[
  {
    "id" : "765d9a3d-d375-4c63-b98a-4056db198902",
    "prId" : 891,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a1ee462b-9529-4ae6-bb31-94d95fc0e8cd",
        "parentId" : null,
        "authorId" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "body" : "What about resource usage?  In many cases the resources CPU/etc are valuable and being paid for by the end user.  We should likely protect those as well.\n",
        "createdAt" : "2014-08-14T19:42:59Z",
        "updatedAt" : "2014-09-05T21:28:06Z",
        "lastEditedBy" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "tags" : [
        ]
      },
      {
        "id" : "16dfa606-7e5c-400c-9270-735ba8dff852",
        "parentId" : "a1ee462b-9529-4ae6-bb31-94d95fc0e8cd",
        "authorId" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "body" : "Covered two lines down.  Also, in my terminology, they are paid for by the k8s user, not the end user.  Maybe I need better terms?\n",
        "createdAt" : "2014-08-14T21:08:31Z",
        "updatedAt" : "2014-09-05T21:28:06Z",
        "lastEditedBy" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "tags" : [
        ]
      }
    ],
    "commit" : "224c29e51d3c60fda4e793ed0f38c844f635f00a",
    "line" : 44,
    "diffHunk" : "@@ -1,1 +42,46 @@    - proprietary data and code\n\nK8s Cluster assets:\n  - Assets of each K8s User\n  - Machine Certificates or secrets."
  },
  {
    "id" : "2800d84c-4ceb-45f5-b368-96f20237a7b1",
    "prId" : 891,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9b5ac7ec-0631-4c32-a1d5-ecb37685eaa0",
        "parentId" : null,
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Suggest that there are three concepts at play:\n1. a unique user identifier and a scope for that resource (name and namespace) for users - this is typically an Identity or an UserMapping\n2. a unique uuid that corresponds to an instantiation of a user that is unique across space and time and is the value that is associated when attributing creation/deletion/actions on a resource - might call this a User\n3. a party identified by a name or uuid that is associated with the limits or resource controls, usage, and billing for a set of resources - this is usually thought of as an Account.\n\nIn many simple systems, an Identity maps to a User which is also an Account.  In systems which have federated authentication, or over time, multiple Identities may resolve to the same User.  In many enterprise systems, Users do not own Accounts - instead, Users are given access to Accounts that have been pre-allocated with resources.\n\nThe following scenarios must be handled correctly in enterprise environments\n- Integrators must be able to map an authentication account (an Identity) to a unique, unchanging identifier representing an User.  \n  - Because Identity values can change over time, it is usually dangerous to assume that the unique user identifier (on the Identity) can be used as the user unique identifier on the User.  \n  - It is better to explicitly separate those, and instead assume each User has at least one Identity.\n  - Using email as a unique user identifier (without separating Identity) will end in tears :)\n- Identity providers (sources of authentication) evolve over the course of the lifetime of deployments, and a significant fraction of deployments will see N > 1 user to unique identifier mappings.\n",
        "createdAt" : "2014-08-14T21:03:45Z",
        "updatedAt" : "2014-09-05T21:28:06Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "41e80989-159a-4908-b549-147ea15d6331",
        "parentId" : "9b5ac7ec-0631-4c32-a1d5-ecb37685eaa0",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "@smarterclayton The difference between user identifier and uuid is that an identifier might be reused over time?\n",
        "createdAt" : "2014-08-15T00:00:16Z",
        "updatedAt" : "2014-09-05T21:28:06Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "5d84b816-d8f6-4ce3-ac61-cf400b82d0c7",
        "parentId" : "9b5ac7ec-0631-4c32-a1d5-ecb37685eaa0",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Correct.  It's not common, but when it does it hurts.  Also, individuals user identifiers can change over time (some organizations have to create new ldap profiles when an employee leaves the company and returns, or gets hired as a contractor, or changes their legal name).  So even a proper ldap uid field can change for legal/HR reasons.  Other reasons are when companies are acquired lots of churn can happen - having that decoupling saves a lot of migration.  Also, you can retire /deactivate old identities but still be able to attribute an action in an audit log to the user who changed the build by their uuid.\n",
        "createdAt" : "2014-08-15T22:02:40Z",
        "updatedAt" : "2014-09-05T21:28:06Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "e7e9c722-d4a3-470c-9b6b-f98d903c08f5",
        "parentId" : "9b5ac7ec-0631-4c32-a1d5-ecb37685eaa0",
        "authorId" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "body" : "@smarterclayton PTAL. I've modified the userAccount section in the latest commit.  I've added a UID to track users over account changes, and I've left room for a layer of indirection between the userAccount object and the one or more sources of authorization that might be used for that userAccount.  \n",
        "createdAt" : "2014-08-25T21:59:25Z",
        "updatedAt" : "2014-09-05T21:28:06Z",
        "lastEditedBy" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "tags" : [
        ]
      }
    ],
    "commit" : "224c29e51d3c60fda4e793ed0f38c844f635f00a",
    "line" : null,
    "diffHunk" : "@@ -1,1 +99,103 @@- `userAccount` has a name which is a string and human readable and unique among userAccounts.  It is used to refer to users in Policies, to ensure that the Policies are human readable.  It can be changed only when there are no Policy objects or other objects which refer to that name.  An email address is a suggested format for this field.\n- `userAccount` is not related to the unix username of processes in Pods created by that userAccount.\n- `userAccount` API objects can have labels\n\nThe system may associate one or more Authentication Methods with a"
  },
  {
    "id" : "3819778f-9852-44e2-8c74-ce5e55498405",
    "prId" : 891,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7e0f7532-ef11-43b2-983c-ea8ee7563832",
        "parentId" : null,
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Human users often end up with multiple accounts - probably in 5-30% of deployments.  Breaking User and Identity up typically simplifies this problem.\n",
        "createdAt" : "2014-08-14T21:08:10Z",
        "updatedAt" : "2014-09-05T21:28:06Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "b80b42ae-5740-44f4-93f2-3a7494c8773d",
        "parentId" : "7e0f7532-ef11-43b2-983c-ea8ee7563832",
        "authorId" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "body" : "I think I did this in the latest commit.\n",
        "createdAt" : "2014-08-25T22:12:21Z",
        "updatedAt" : "2014-09-05T21:28:06Z",
        "lastEditedBy" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "tags" : [
        ]
      }
    ],
    "commit" : "224c29e51d3c60fda4e793ed0f38c844f635f00a",
    "line" : null,
    "diffHunk" : "@@ -1,1 +122,126 @@\nEnterprise Profile:\n   - every human user has own `userAccount`. \n   - `userAccount`s have labels that indicate both membership in groups, and ability to act in certain roles.\n   - each service using the API has own `userAccount` too. (e.g. `scheduler`, `repcontroller`)"
  },
  {
    "id" : "64996732-5766-4ce1-8e86-ad0076e6c8a9",
    "prId" : 891,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9a8d8ba9-e3b5-4a57-b866-bd0a16c740a2",
        "parentId" : null,
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Can you enumerate what you imagine here?\n",
        "createdAt" : "2014-08-14T21:08:37Z",
        "updatedAt" : "2014-09-05T21:28:06Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "64f15f18-e1a5-4897-beeb-4c4eb0396241",
        "parentId" : "9a8d8ba9-e3b5-4a57-b866-bd0a16c740a2",
        "authorId" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "body" : "Labels could be used to create groups of userAccounts to make Policies more succinct.\n\nFor example:\nuserAccounts \"alice\" and \"bob\" have label \"employee_type=fulltime-engineers\" and \"chuck\" has label \"employee_type=intern\".\nthen have policy that \"employee_type=intern\" can GET /pods but not PUT, POST or DELETE /pods (assuming that was somehow useful)\n\nI thought that k8s would not dictate special meanings for any particular labels.\n\nI haven't worked out exactly how to use labels for roles.  Some mechanism is needed for the user to assert the role when taking an action, but not assert it otherwise.  \n",
        "createdAt" : "2014-08-14T21:45:07Z",
        "updatedAt" : "2014-09-05T21:28:06Z",
        "lastEditedBy" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "tags" : [
        ]
      },
      {
        "id" : "cbecea7b-6436-4eab-b51f-09fdf3aaa960",
        "parentId" : "9a8d8ba9-e3b5-4a57-b866-bd0a16c740a2",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Interesting - yeah, I could see groups and other types of role things mapping in here.  Helps simplify the general user -> mapping rules.  With policy I could see value.\n",
        "createdAt" : "2014-08-14T21:49:52Z",
        "updatedAt" : "2014-09-05T21:28:06Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "dad3bfcd-5533-4215-a6a1-57033d4c6d6a",
        "parentId" : "9a8d8ba9-e3b5-4a57-b866-bd0a16c740a2",
        "authorId" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "body" : "I'm reconsidering the use of labels in place of groups and roles.  Lots of other similar systems have groups and not having them may be confusing for users. \n",
        "createdAt" : "2014-08-25T22:21:44Z",
        "updatedAt" : "2014-09-05T21:28:06Z",
        "lastEditedBy" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "tags" : [
        ]
      },
      {
        "id" : "c99f5fe8-7c88-41c3-ace9-b7e4ab1a430f",
        "parentId" : "9a8d8ba9-e3b5-4a57-b866-bd0a16c740a2",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "> On Aug 25, 2014, at 6:21 PM, erictune notifications@github.com wrote:\n> \n> In docs/access.md:\n> \n> > +- `userAccount` object is immutable\n> > +- there is no superuser `userAccount`\n> > +- `userAccount` objects are statically populated in the k8s API store by reading a config file.  Only a k8s admin can do this.\n> > +- `userAccount` can have a default `project`.  If API call does not specify a `project`, the default `project` for that caller is assumed.\n> > +- `userAccount` may access multiple projects.\n> > +\n> > +Improvements:\n> > +- Have API calls to create and delete `userAccount`s.\n> > +- Make `userAccount` part of a separate API group from core k8s objects like `pod`.  Facilitates plugging in alternate Access Management.\n> > +\n> > +Simple Profile:\n> > -   - single `userAccount`, used by all users.\n> >   +\n> >   +Enterprise Profile:\n> > -   - every human user has own `userAccount`. \n> > -   - `userAccount`s have labels that indicate both membership in groups, and ability to act in certain roles.\n> >   I'm reconsidering the use of labels in place of groups and roles. Lots of other similar systems have groups and not having them may be confusing for users.\n\nI like the ubiquity of labels and their ability to be defined on everything.  I do feel like a user's role _on_ a resource seems difficult to describe with labels and more like a relation.\n\n> â€”\n> Reply to this email directly or view it on GitHub.\n",
        "createdAt" : "2014-08-25T22:49:58Z",
        "updatedAt" : "2014-09-05T21:28:06Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      }
    ],
    "commit" : "224c29e51d3c60fda4e793ed0f38c844f635f00a",
    "line" : null,
    "diffHunk" : "@@ -1,1 +123,127 @@Enterprise Profile:\n   - every human user has own `userAccount`. \n   - `userAccount`s have labels that indicate both membership in groups, and ability to act in certain roles.\n   - each service using the API has own `userAccount` too. (e.g. `scheduler`, `repcontroller`)\n   - automated jobs to denormalize the ldap group info into the local system list of users into the K8s userAccount file."
  },
  {
    "id" : "a7a50f75-5628-4a78-97f7-bceda1293ebf",
    "prId" : 891,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fb696e7c-125b-4d74-8eea-7e8723400148",
        "parentId" : null,
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Thinking through the things we've said for authz, namespaces, and projects, I'm starting to think that users is a concept (like projects) that sits above or alongside Kubernetes, but not in it.  In a simple example, I have three layers:\n- Authentication proxy\n- Authorization proxy\n- API Server\n\nThe authentication proxy loads data about a user, and passes it along.  The authorization proxy takes that user information and checks a policy, and then applies or denies the request.  The API server is completely ignorant of both policy, users, or authentication mechanisms, and simply processes the request.\n\nIn this model projects, ACL, authn, and authz, users, and membership all occur outside of the core system.  So there would be no need for K8s to know about user accounts.  That seems like something that benefits from being in \"Initial Features\".\n\nThe one gap would be audit - associating a created / modified API resource with an identity.  We could state that a K8s apiserver could take as input on any request an opaque identity string that would be recorded as the initiator of the action - it would be the responsibility of the auth(n) proxy to set that data on the incoming request in a way that the apiserver will assign it, but otherwise the apiserver has no notion of identity.\n",
        "createdAt" : "2014-09-04T22:11:20Z",
        "updatedAt" : "2014-09-05T21:28:06Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "bb9955c7-7108-42b3-a696-d44aa66ccf1a",
        "parentId" : "fb696e7c-125b-4d74-8eea-7e8723400148",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "If we did this - could we then encourage a set of open source and closed source implementations of auth(n)/(z) with limited integration into apiserver that offer various options, but are _not_ required to be part of the core?\n",
        "createdAt" : "2014-09-04T22:12:58Z",
        "updatedAt" : "2014-09-05T21:28:06Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "8f7ac507-3ed7-4002-867d-c422933ec3a1",
        "parentId" : "fb696e7c-125b-4d74-8eea-7e8723400148",
        "authorId" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "body" : "My thinking has reached a point near what you just said.\n\nThe apiserver may cache Authz server responses for speed.  Cache lookup would be keyed on user, as well as other context.  So, APIserver needs to see user.\n\nYes, pluggable auth(n) and auth(z) would have a lot of benefits.  It would allow groups to chose between RBAC and ABAC, or even use one or the other on a per-project basis.\n\nThe one drawback I see is that if we want config to grow to include creation of not only objects but also policy (as Amazon cloudformation allows) then you'd like a single type of auth(z).  But, I think the immediate benefits of decoupling outweigh the minor drawback of config+policy portability.\n",
        "createdAt" : "2014-09-05T21:15:47Z",
        "updatedAt" : "2014-09-05T21:28:06Z",
        "lastEditedBy" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "tags" : [
        ]
      },
      {
        "id" : "54df4800-3774-4232-abb7-8424d9eac45b",
        "parentId" : "fb696e7c-125b-4d74-8eea-7e8723400148",
        "authorId" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "body" : "What I had been trying to wrap my head around is what Oauth flows and profiles could be used for auth(n) and, separately, I think, for auth(z).\n",
        "createdAt" : "2014-09-05T21:21:53Z",
        "updatedAt" : "2014-09-05T21:28:06Z",
        "lastEditedBy" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "tags" : [
        ]
      },
      {
        "id" : "88a0602d-c5df-4f6a-b2c9-02f8ddf16cde",
        "parentId" : "fb696e7c-125b-4d74-8eea-7e8723400148",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "I think pluggable auth(z) could be defined as two types - a completely separate system for authz, OR a policy based system that has different ways of being bundled with the apiserver (pure proxy vs being able to sit between storage and registry, for example).  I would prefer to have a common policy definition, object, and impl, but I'm hoping that some prototyping of RBAC -> ABAC mapping would help clear up that issue.  \n\nI'd like to be able to prototype the core policy, a simple proxy, and an integrating system that maps identity to policy to check the policy fairly soon, once we think we've sucked the marrow out of this MD file.\n",
        "createdAt" : "2014-09-05T21:22:03Z",
        "updatedAt" : "2014-09-05T21:28:06Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "432a4c45-8df6-4689-8236-15c5ccfc7be0",
        "parentId" : "fb696e7c-125b-4d74-8eea-7e8723400148",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Yeah, that's something I want to try to spin up as well.  I have a fairly clear idea in my head about how I'd build the old system we have using some of these new ideas, and I think it'd be productive to glue them together (as I see them) so they could be intelligently discussed in contrast to the perspective you guys bring.\n",
        "createdAt" : "2014-09-05T21:27:53Z",
        "updatedAt" : "2014-09-05T21:28:07Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "2e0440ac-2946-4cf9-820d-5755d23ea6ad",
        "parentId" : "fb696e7c-125b-4d74-8eea-7e8723400148",
        "authorId" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "body" : "I'm fine with you building something.  \nI didn't understand what you meant when you said authz could sit between storage and registry. \n\nI agree that authz could be fully contained in the apiserver binary or it could call out to another service.\n\nI envision APIserver calling an Authorize() function once for every API call, at a point early in the HTTP request handling.\n\nAuthorize() takes the username, an identifier for the API method called, the resource path, and, in the future, more contextual information.\n",
        "createdAt" : "2014-09-05T21:39:26Z",
        "updatedAt" : "2014-09-05T21:39:49Z",
        "lastEditedBy" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "tags" : [
        ]
      },
      {
        "id" : "d739a21b-dda3-4f4b-a347-ad1a83c7e021",
        "parentId" : "fb696e7c-125b-4d74-8eea-7e8723400148",
        "authorId" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "body" : "http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/iam-policies-for-amazon-ec2.html\n\nhas some ideas to consider when thinking about how to describe policy.\n",
        "createdAt" : "2014-09-05T21:41:41Z",
        "updatedAt" : "2014-09-05T21:41:41Z",
        "lastEditedBy" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "tags" : [
        ]
      },
      {
        "id" : "3ff3fc36-934a-47ee-bed6-ee84a46801b2",
        "parentId" : "fb696e7c-125b-4d74-8eea-7e8723400148",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "> I didn't understand what you meant when you said authz could sit between storage and registry.\n\nJumping ahead too much and thinking about impl - let's move into policy and then talk about next steps.\n",
        "createdAt" : "2014-09-05T22:00:46Z",
        "updatedAt" : "2014-09-05T22:00:46Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      }
    ],
    "commit" : "224c29e51d3c60fda4e793ed0f38c844f635f00a",
    "line" : null,
    "diffHunk" : "@@ -1,1 +116,120 @@\nImprovements:\n- Make `userAccount` part of a separate API group from core K8s objects like `pod`.  Facilitates plugging in alternate Access Management.\n\nSimple Profile:"
  }
]
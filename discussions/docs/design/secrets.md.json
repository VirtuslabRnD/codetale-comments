[
  {
    "id" : "bff12c64-05bb-4d30-9a26-445d1df73dbf",
    "prId" : 36123,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/36123#pullrequestreview-7134045",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9bddb343-a420-4517-a892-569eaea70aa9",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "where is this used?\n",
        "createdAt" : "2016-11-03T14:47:14Z",
        "updatedAt" : "2016-11-03T14:47:14Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "215438f5-4749-406b-a2bf-2897c3990188",
        "parentId" : "9bddb343-a420-4517-a892-569eaea70aa9",
        "authorId" : "c09bfaa0-c459-4cac-bc30-9a4dd3d651d3",
        "body" : "@liggitt \ndefinition at : https://github.com/kubernetes/kubernetes/blob/master/pkg/api/types.go#L3267\nused at: https://github.com/kubernetes/kubernetes/blob/master/pkg/api/validation/validation.go#L3144\nhttps://github.com/kubernetes/kubernetes/blob/master/pkg/credentialprovider/keyring.go#L312\nhttps://github.com/kubernetes/kubernetes/blob/master/test/e2e_node/runtime_conformance_test.go#L186\nhttps://github.com/kubernetes/kubernetes/blob/master/pkg/api/validation/validation_test.go#L7913\n",
        "createdAt" : "2016-11-04T01:25:59Z",
        "updatedAt" : "2016-11-04T01:25:59Z",
        "lastEditedBy" : "c09bfaa0-c459-4cac-bc30-9a4dd3d651d3",
        "tags" : [
        ]
      }
    ],
    "commit" : "ecc44d63cde590f615b773bcd734656421d547fd",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +325,329 @@    SecretTypeServiceAccountToken SecretType = \"kubernetes.io/service-account-token\"    // Kubernetes auth token\n    SecretTypeDockercfg           SecretType = \"kubernetes.io/dockercfg\"                // Docker registry auth\n    SecretTypeDockerConfigJson    SecretType = \"kubernetes.io/dockerconfigjson\"         // Latest Docker registry auth\n    // FUTURE: other type values\n)"
  },
  {
    "id" : "9097e8ba-d3d8-40a1-99f6-67a643d9092a",
    "prId" : 4600,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c6ba9319-7e5b-46e8-be69-19ca816a7fd6",
        "parentId" : null,
        "authorId" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "body" : "possible future improvement: optional AsciiArmor.\n\nhttps://gist.github.com/jyap808/8250067\n",
        "createdAt" : "2015-02-19T17:08:50Z",
        "updatedAt" : "2015-02-19T17:08:50Z",
        "lastEditedBy" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "tags" : [
        ]
      }
    ],
    "commit" : "777b464de530a8f66a3dd1581f4b480f6f813d76",
    "line" : 62,
    "diffHunk" : "@@ -1,1 +400,404 @@\n**Note:** The values of secret data are encoded as base64-encoded strings.  Newlines are not\nvalid within these strings and must be omitted.\n\nNow we can create a pod which references the secret with the ssh key and consumes it in a volume:"
  },
  {
    "id" : "4e643bbb-25f1-4485-90f6-b930b18483fd",
    "prId" : 4126,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8c450055-4f1c-4d88-9fd7-ef80e25acce4",
        "parentId" : null,
        "authorId" : "727fc82d-d969-41a4-a614-7fefce94f9a6",
        "body" : "Are operator secrets global?  Meaning, is that one .dockercfg for all pods or do you intend to allow each pod to have their own .dockercfg?\n\nIf global, would would you schedule that resource onto all hosts exactly once?  If on a pod basis, how would you inject that operator secret volume into the pods?\n",
        "createdAt" : "2015-02-06T15:23:58Z",
        "updatedAt" : "2015-02-18T01:30:10Z",
        "lastEditedBy" : "727fc82d-d969-41a4-a614-7fefce94f9a6",
        "tags" : [
        ]
      },
      {
        "id" : "310f74f5-2247-4fe5-9904-882bb768d82c",
        "parentId" : "8c450055-4f1c-4d88-9fd7-ef80e25acce4",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "> On Feb 6, 2015, at 10:24 AM, Mark Turansky notifications@github.com wrote:\n> \n> In docs/design/secrets.md:\n> \n> > +\n> > +## Use Cases\n> > +\n> > +1.  As a user, I want to store secret artifacts for my applications and consume them securely in\n> > -    containers, so that I can keep the configuration for my applications separate from the images\n> > -    that use them:\n> > -    1.  As a cluster operator, I want to allow a pod to access the Kubernetes master using a custom\n> > -        `.kubeconfig` file, so that I can securely reach the master\n> > -    2.  As a cluster operator, I want to allow a pod to access a Docker registry using credentials\n> > -        from a `.dockercfg` file, so that containers can push images\n> > -    3.  As a cluster operator, I want to allow a pod to access a git repository using SSH keys,\n> > -        so that I can push and fetch to and from the repository\n> >   +2.  As a user, I want to allow containers to consume supplemental information about services such\n> > -    as username and password which should be kept secret, so that I can share secrets about a\n> > -    service amongst the containers in my application securely\n> >   +\n> >   Are operator secrets global? Meaning, is that one .dockercfg for all pods or do you intend to allow each pod to have their own .dockercfg?\n> \n> Both.  Pods carry with them authorization info about the ability to pull images.\n> If global, would would you schedule that resource onto all hosts exactly once? If on a pod basis, how would you inject that operator secret volume into the pods?\n> \n> —\n> Reply to this email directly or view it on GitHub.\n",
        "createdAt" : "2015-02-06T15:59:05Z",
        "updatedAt" : "2015-02-18T01:30:10Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "00d17634-7a64-4ccc-af73-4e187983b60c",
        "parentId" : "8c450055-4f1c-4d88-9fd7-ef80e25acce4",
        "authorId" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "body" : "IIUC, this Proposal doesn't yet say how you would use this for a .dockercfg.  Kubelet would need to:\n1. pull the secret with the per-pod dockercfg\n2. merge that into the actual system dockercfg\n3. pull the pod's images\n4. somehow make sure that other pods that should not have access to that secret do use it for their images via some sort of race condition.\n",
        "createdAt" : "2015-02-11T18:16:28Z",
        "updatedAt" : "2015-02-18T01:30:10Z",
        "lastEditedBy" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "tags" : [
        ]
      },
      {
        "id" : "8509e70c-4936-46b0-a1ea-fa6b46c516a8",
        "parentId" : "8c450055-4f1c-4d88-9fd7-ef80e25acce4",
        "authorId" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "body" : "> somehow make sure that other pods that should not have access to that secret do use it for their images via some sort of race condition.\n\n@erictune confirm that you meant \"don't\" instead of \"do\" here?\n",
        "createdAt" : "2015-02-12T18:20:26Z",
        "updatedAt" : "2015-02-18T01:30:10Z",
        "lastEditedBy" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "tags" : [
        ]
      },
      {
        "id" : "a1c45d58-051c-43b5-bfd8-003667091aea",
        "parentId" : "8c450055-4f1c-4d88-9fd7-ef80e25acce4",
        "authorId" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "body" : "i meant _don't_\n",
        "createdAt" : "2015-02-13T00:41:01Z",
        "updatedAt" : "2015-02-18T01:30:10Z",
        "lastEditedBy" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "tags" : [
        ]
      },
      {
        "id" : "e789c0d9-d0d0-40f4-a6b7-aad8dc7490c8",
        "parentId" : "8c450055-4f1c-4d88-9fd7-ef80e25acce4",
        "authorId" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "body" : "@erictune Reading over this again and discussing it with @ncdc, I wonder if there's some stream-crossing in the document.  In this case I'm referring to a use-case in OpenShift of wanting to push to a docker registry, rather than authorizing the kubelet to use a `.dockercfg` contained in a secret to docker pull an image to run in a pod.\n\nI did a quick look for the use case I described above (kubelet uses a secret as credential for docker pull) and couldn't find anything which I felt already captured it, though it's hinted at in:\n\n#2209 \n#499\n\nDo we need to call this out as a use-case to solve with secrets @erictune @smarterclayton ?\n",
        "createdAt" : "2015-02-13T01:15:24Z",
        "updatedAt" : "2015-02-18T01:30:10Z",
        "lastEditedBy" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "tags" : [
        ]
      },
      {
        "id" : "75d26264-d1e0-4bb0-9d8d-1b6768e8cda4",
        "parentId" : "8c450055-4f1c-4d88-9fd7-ef80e25acce4",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "> On Feb 12, 2015, at 8:15 PM, Paul Morie notifications@github.com wrote:\n> \n> In docs/design/secrets.md:\n> \n> > +\n> > +## Use Cases\n> > +\n> > +1.  As a user, I want to store secret artifacts for my applications and consume them securely in\n> > -    containers, so that I can keep the configuration for my applications separate from the images\n> > -    that use them:\n> > -    1.  As a cluster operator, I want to allow a pod to access the Kubernetes master using a custom\n> > -        `.kubeconfig` file, so that I can securely reach the master\n> > -    2.  As a cluster operator, I want to allow a pod to access a Docker registry using credentials\n> > -        from a `.dockercfg` file, so that containers can push images\n> > -    3.  As a cluster operator, I want to allow a pod to access a git repository using SSH keys,\n> > -        so that I can push and fetch to and from the repository\n> >   +2.  As a user, I want to allow containers to consume supplemental information about services such\n> > -    as username and password which should be kept secret, so that I can share secrets about a\n> > -    service amongst the containers in my application securely\n> >   +\n> >   @erictune Reading over this again and discussing it with @ncdc, I wonder if there's some stream-crossing in the document. In this case I'm referring to a use-case in OpenShift of wanting to push to a docker registry, rather than authorizing the kubelet to use a .dockercfg contained in a secret to docker pull an image to run in a pod.\n> \n> I did a quick look for the use case I described above (kubelet uses a secret as credential for docker pull) and couldn't find anything which I felt already captured it, though it's hinted at in:\n> \n> #2209 \n> #499\n> \n> Do we need to call this out as a use-case to solve with secrets @erictune @smarterclayton ?\n> \n> Yes, we discussed this today.  It's two different use cases, pull from an integrated registry is an Openshift and CoreOS problem, and it's generally useful to the community.\n> —\n> Reply to this email directly or view it on GitHub.\n",
        "createdAt" : "2015-02-13T17:08:20Z",
        "updatedAt" : "2015-02-18T01:30:10Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      }
    ],
    "commit" : "ea18e6698dbd651338c6028c37ab788ca372f32c",
    "line" : null,
    "diffHunk" : "@@ -1,1 +53,57 @@4.  As a user, I want to be able to indicate that a secret expires and for that secret's value to\n    be rotated once it expires, so that the system can help me follow good practices\n\n### Use-Case: Configuration artifacts\n"
  },
  {
    "id" : "105d791a-1bf7-4891-92e6-a0779ccbf33b",
    "prId" : 4126,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a58d4949-67c4-4193-904a-7d95c5406964",
        "parentId" : null,
        "authorId" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "body" : "Should secret data be unencrypted at rest on the node?   Multiple choice:\n1.  No.  (Needs discussion around threats and what types of secrets are appropriate to store this way)\n2.  Yes.  (how to do this?  make an encrypted loop device?)\n3. Not applicable.  The data never is at rest.  Always put in a tmpfs.  (Is size limitation on secrets okay?)\n",
        "createdAt" : "2015-02-11T17:49:22Z",
        "updatedAt" : "2015-02-18T01:30:10Z",
        "lastEditedBy" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "tags" : [
        ]
      },
      {
        "id" : "25ac8521-9eda-4182-8981-1ae4ec3e33f8",
        "parentId" : "a58d4949-67c4-4193-904a-7d95c5406964",
        "authorId" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "body" : "@erictune Ack, I will think about this.\n",
        "createdAt" : "2015-02-12T02:23:49Z",
        "updatedAt" : "2015-02-18T01:30:10Z",
        "lastEditedBy" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "tags" : [
        ]
      }
    ],
    "commit" : "ea18e6698dbd651338c6028c37ab788ca372f32c",
    "line" : null,
    "diffHunk" : "@@ -1,1 +190,194 @@    the kubelet's node\n2.  Kubelets should have read-only access to secret data\n3.  Secret data should not be transmitted over the wire insecurely\n4.  Kubelets must ensure pods do not have access to each other's secrets\n"
  },
  {
    "id" : "29a8a233-d32f-4709-8577-eadd20c23338",
    "prId" : 4126,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "33beaa8a-4266-454a-a863-f06d909895ba",
        "parentId" : null,
        "authorId" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "body" : "conventions for maximum length of Data and comparision to any known large \"secrets\" that people may want to use.\n",
        "createdAt" : "2015-02-11T18:01:50Z",
        "updatedAt" : "2015-02-18T01:30:10Z",
        "lastEditedBy" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "tags" : [
        ]
      }
    ],
    "commit" : "ea18e6698dbd651338c6028c37ab788ca372f32c",
    "line" : null,
    "diffHunk" : "@@ -1,1 +287,291 @@\nconst MaxSecretSize = 1 * 1024 * 1024\n```\n\nA Secret can declare a type in order to provide type information to system components that work"
  },
  {
    "id" : "ff8d1f29-966b-482e-be68-e66dec9a4f86",
    "prId" : 4126,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ff099515-2eed-40bb-8bf1-c5c558d229a5",
        "parentId" : null,
        "authorId" : "dd951a24-fd88-4645-b330-073d936d0501",
        "body" : "Do we want a limit the total number of secrets too? e.g. per namespace?\n",
        "createdAt" : "2015-02-17T10:17:56Z",
        "updatedAt" : "2015-02-18T01:30:10Z",
        "lastEditedBy" : "dd951a24-fd88-4645-b330-073d936d0501",
        "tags" : [
        ]
      },
      {
        "id" : "fc79489a-dbe6-43a0-acea-e8389e40d3a7",
        "parentId" : "ff099515-2eed-40bb-8bf1-c5c558d229a5",
        "authorId" : "dd951a24-fd88-4645-b330-073d936d0501",
        "body" : "Do we have examples of \"large\" secrets to get an idea of whether this is reasonable or not?  All secrets I can think of are a few kb max (ssh keys typically).\n",
        "createdAt" : "2015-02-17T10:52:17Z",
        "updatedAt" : "2015-02-18T01:30:10Z",
        "lastEditedBy" : "dd951a24-fd88-4645-b330-073d936d0501",
        "tags" : [
        ]
      },
      {
        "id" : "3549cf64-f238-4784-99a7-37e5add6fffa",
        "parentId" : "ff099515-2eed-40bb-8bf1-c5c558d229a5",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "The largest i can think of is a PEM chain or a kerb key tab.  I do however thing folks will sign and encrypt json blobs for this.  The naive secret implementation uses etcd so that imposes one upper bound.\n\n----- Original Message -----\n\n> > +3.  An external datastore such as an external etcd, RDBMS, etc.\n> > +\n> > +#### Size limit for secrets\n> > +\n> > +There should be a size limit for secrets in order to:\n> > +\n> > +1.  Prevent DOS attacks against the API server\n> > +2.  Allow kubelet implementations that prevent secret data from touching\n> > the node's filesystem\n> > +\n> > +The size limit should satisfy the following conditions:\n> > +\n> > +1.  Large enough to store common artifact types (encryption keypairs,\n> > certificates, small\n> > -    configuration files)\n> >   +2.  Small enough to avoid large impact on node resource consumption\n> >   (storage, RAM for tmpfs, etc)\n> >   +\n> >   +To begin discussion, we propose an initial value for this size limit of\n> >   **1MB**.\n> \n> Do we have examples of \"large\" secrets to get an idea of whether this is\n> reasonable or not?  All secrets I can think of are a few kb max (ssh keys\n> typically).\n> \n> ---\n> \n> Reply to this email directly or view it on GitHub:\n> https://github.com/GoogleCloudPlatform/kubernetes/pull/4126/files#r24807159\n",
        "createdAt" : "2015-02-17T18:47:51Z",
        "updatedAt" : "2015-02-18T01:30:10Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "860d9fb5-1da5-4539-882a-c635e6a4c947",
        "parentId" : "ff099515-2eed-40bb-8bf1-c5c558d229a5",
        "authorId" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "body" : "I also think people will put encrypted blobs of json, properties, etc into secrets.\n",
        "createdAt" : "2015-02-17T19:48:49Z",
        "updatedAt" : "2015-02-18T01:30:10Z",
        "lastEditedBy" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "tags" : [
        ]
      }
    ],
    "commit" : "ea18e6698dbd651338c6028c37ab788ca372f32c",
    "line" : 164,
    "diffHunk" : "@@ -1,1 +162,166 @@2.  Small enough to avoid large impact on node resource consumption (storage, RAM for tmpfs, etc)\n\nTo begin discussion, we propose an initial value for this size limit of **1MB**.\n\n#### Other limitations on secrets"
  },
  {
    "id" : "5307206e-8a24-4c3c-8c2b-4f5224decb30",
    "prId" : 4126,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5578ee70-c491-4eae-b2fb-52458f0c5cbb",
        "parentId" : null,
        "authorId" : "dd951a24-fd88-4645-b330-073d936d0501",
        "body" : "If the tmpfs is node-level, then we need to ensure we allocate it sufficiently big from the start to host all the secrets belonging to all the pods the node will host at a given time, however this is not known in advance.  Conversely, we want to use as little RAM as possible.  Should we consider per-pod tmpfs?  e.g. as a possible future enhancement.\n",
        "createdAt" : "2015-02-17T10:26:58Z",
        "updatedAt" : "2015-02-18T01:30:10Z",
        "lastEditedBy" : "dd951a24-fd88-4645-b330-073d936d0501",
        "tags" : [
        ]
      },
      {
        "id" : "d1255bf8-fdcb-4570-9ea3-95dbbb57cfbb",
        "parentId" : "5578ee70-c491-4eae-b2fb-52458f0c5cbb",
        "authorId" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "body" : "There are two separate issues here I think.\n1.  What is the `-o size` of the tmpfs when it is created.  \n   - The tmpfs only uses as much RAM as the pages that back it.  If you put no secrets in it, it uses almost no memory.  So, there is no harm in making the maximum size big enough for a \"worst case\". \n2. What amount of memory should be subtracted from the node's reported capacity to ensure that memory is not overcommitted when scheduling to the node.\n   - there are going to be a bunch of sources of memory consumption which is correlated with the number of containers on the machine but also has considerable variance.  It is better to lump together all these sources of variance rather than trying to partition them.\n",
        "createdAt" : "2015-02-17T19:22:05Z",
        "updatedAt" : "2015-02-18T01:30:10Z",
        "lastEditedBy" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "tags" : [
        ]
      },
      {
        "id" : "9d98fbb6-748e-4cf1-a31e-e87a71b0f16a",
        "parentId" : "5578ee70-c491-4eae-b2fb-52458f0c5cbb",
        "authorId" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "body" : "tl;dr I don't think we need separate tmpfs\n",
        "createdAt" : "2015-02-17T19:23:18Z",
        "updatedAt" : "2015-02-18T01:30:10Z",
        "lastEditedBy" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "tags" : [
        ]
      },
      {
        "id" : "1aec0213-0024-455b-ac18-30fd57a3a9c1",
        "parentId" : "5578ee70-c491-4eae-b2fb-52458f0c5cbb",
        "authorId" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "body" : "@erictune I added a comment to address effect on advertised RAM\n",
        "createdAt" : "2015-02-17T21:41:10Z",
        "updatedAt" : "2015-02-18T01:30:10Z",
        "lastEditedBy" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "tags" : [
        ]
      }
    ],
    "commit" : "ea18e6698dbd651338c6028c37ab788ca372f32c",
    "line" : 212,
    "diffHunk" : "@@ -1,1 +210,214 @@\nFor the sake of limiting complexity, we propose that initially secret data should not be allowed\nto be at rest on a node; secret data should be stored on a node-level tmpfs filesystem.  This\nfilesystem can be subdivided into directories for use by the kubelet and by the volume plugin.\n"
  },
  {
    "id" : "97b3628a-7d9a-4a61-b7d7-fc512e8c6345",
    "prId" : 4126,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2d319db9-d344-4914-9ac7-d3461d32a2d9",
        "parentId" : null,
        "authorId" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "body" : "The other option is for kubelet to add up the size of all the secrets files as it writes them to tmpfs, and then to subtract this total from the memory limit that it writes for the container.  This makes most or all of the limits mentioned above go away.\n",
        "createdAt" : "2015-02-18T00:11:52Z",
        "updatedAt" : "2015-02-18T01:30:10Z",
        "lastEditedBy" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "tags" : [
        ]
      },
      {
        "id" : "0c89162e-fdb0-4cee-94fe-7782265f7886",
        "parentId" : "2d319db9-d344-4914-9ac7-d3461d32a2d9",
        "authorId" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "body" : "However, IIRC we only have per-container memory limits and not per-pod memory limits, at present.  So, either you have to decide how to apportion the shortfall across the various containers (proportional?), or else charge it to the pod as a whole, which means the scheduler can't see the charge at scheduling time.\n",
        "createdAt" : "2015-02-18T00:18:08Z",
        "updatedAt" : "2015-02-18T01:30:10Z",
        "lastEditedBy" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "tags" : [
        ]
      }
    ],
    "commit" : "ea18e6698dbd651338c6028c37ab788ca372f32c",
    "line" : 183,
    "diffHunk" : "@@ -1,1 +181,185 @@For now, we will not implement validations around these limits.  Cluster operators will decide how\nmuch node storage is allocated to secrets. It will be the operator's responsibility to ensure that\nthe allocated storage is sufficient for the workload scheduled onto a node.\n\n### Use-Case: Kubelet read of secrets for node"
  },
  {
    "id" : "a4b31c31-3de8-4820-a180-30e18977b3ab",
    "prId" : 4126,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "605e7772-f7bb-4c4f-8ecc-b550e8e11006",
        "parentId" : null,
        "authorId" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "body" : "Should the Volume plugin be responsible for making the tmpfs?\n",
        "createdAt" : "2015-02-18T00:32:30Z",
        "updatedAt" : "2015-02-18T01:30:10Z",
        "lastEditedBy" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "tags" : [
        ]
      }
    ],
    "commit" : "ea18e6698dbd651338c6028c37ab788ca372f32c",
    "line" : 360,
    "diffHunk" : "@@ -1,1 +358,362 @@2.  `NewMainKubelet` should accept a value for secret storage size\n3.  The Kubelet server should have a new flag added for secret storage size\n4.  The Kubelet's `setupDataDirs` method should be changed to create the secret storage\n\n### Kubelet: New behaviors for secrets associated with service accounts"
  }
]
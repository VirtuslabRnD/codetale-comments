[
  {
    "id" : "b2c26acf-9e81-4bdc-a276-299339e3d54c",
    "prId" : 12209,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3275b6ee-1a76-4b22-a41f-289eba04ff14",
        "parentId" : null,
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Maybe split this into a second interface which is optionally provided.\n",
        "createdAt" : "2015-08-05T00:11:47Z",
        "updatedAt" : "2015-12-03T18:54:52Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "97ee61dd-cb63-4f7b-8c97-e462a93c4d24",
        "parentId" : "3275b6ee-1a76-4b22-a41f-289eba04ff14",
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "> Maybe split this into a second interface which is optionally provided.\n\n`GetAllowedSubjects` is a pretty fundamental operation.  Without the ability to know who can perform an operation, proper auditing of authorization policy is an impossibility.  Why would we ever want to allow someone to create an authorizer that couldn't be audited? \n",
        "createdAt" : "2015-08-06T13:30:27Z",
        "updatedAt" : "2015-12-03T18:54:52Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      },
      {
        "id" : "ffa81ec3-c935-4a2a-8e12-ea52710f9fb6",
        "parentId" : "3275b6ee-1a76-4b22-a41f-289eba04ff14",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Because you don't need audit?  Unless every call site needs both methods\n(and they don't) I would organize these so that there are two fundamental\ninterfaces, and if at the highest level you require both, require both.\n\nOn Thu, Aug 6, 2015 at 9:30 AM, David Eads notifications@github.com wrote:\n\n> In docs/design/enhance-pluggable-policy.md\n> https://github.com/GoogleCloudPlatform/kubernetes/pull/12209#discussion_r36413537\n> :\n> \n> > +// OLD\n> > +type Authorizer interface {\n> > -  Authorize(a Attributes) error\n> >   +}\n> >   +`\n> >   +\n> >   +`\n> >   +// NEW\n> >   +type Authorizer interface {\n> > -  // Authorize takes a Context (for namespace, user, and traceability) and Attributes to make a policy determination.\n> > -  // reason is an optional return value that can describe why a policy decision was made.\n> > -  Authorize(ctx api.Context, a Attributes) (allowed bool, reason string, evaluationError error)\n> >   +\n> > -  // GetAllowedSubjects takes a Context (for namespace and traceability) and Attributes to determine which users and\n> > -  // groups are allowed to perform the described action in the namespace.    This API enables the ResourceBasedReview requests below\n> > -  GetAllowedSubjects(ctx api.Context, a Attributes) (users util.StringSet, groups util.StringSet, evaluationError error)\n> \n> Maybe split this into a second interface which is optionally provided.\n> \n> GetAllowedSubjects is a pretty fundamental operation. Without the ability\n> to know who can perform an operation, proper auditing of authorization\n> policy is an impossibility. Why would we ever want to allow someone to\n> create an authorizer that couldn't be audited?\n> \n> —\n> Reply to this email directly or view it on GitHub\n> https://github.com/GoogleCloudPlatform/kubernetes/pull/12209/files#r36413537\n> .\n\n## \n\nClayton Coleman | Lead Engineer, OpenShift\n",
        "createdAt" : "2015-08-06T14:36:12Z",
        "updatedAt" : "2015-12-03T18:54:52Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "1630b04c-52f0-4c53-86a0-a001db4c8c59",
        "parentId" : "3275b6ee-1a76-4b22-a41f-289eba04ff14",
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "> Because you don't need audit?  Unless every call site needs both methods\n> (and they don't) I would organize these so that there are two fundamental\n> interfaces, and if at the highest level you require both, require both.\n\nSo would we make `ResourceAccessReview` optional?  It's essential for doing things like \"which namespaces/projects can I see\".\n",
        "createdAt" : "2015-08-07T15:37:58Z",
        "updatedAt" : "2015-12-03T18:54:52Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      },
      {
        "id" : "07402e57-9dc3-45ec-aa64-af75f95ab8ae",
        "parentId" : "3275b6ee-1a76-4b22-a41f-289eba04ff14",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "I don't think ResourceAccessReview is required for all deployments or\nauthorizers.  It is definitely useful, but not all consumers may choose to\ninvert the model (or even support inverting the model).\n\nOn Fri, Aug 7, 2015 at 11:38 AM, David Eads notifications@github.com\nwrote:\n\n> In docs/design/enhance-pluggable-policy.md\n> https://github.com/GoogleCloudPlatform/kubernetes/pull/12209#discussion_r36531053\n> :\n> \n> > +// OLD\n> > +type Authorizer interface {\n> > -  Authorize(a Attributes) error\n> >   +}\n> >   +`\n> >   +\n> >   +`\n> >   +// NEW\n> >   +type Authorizer interface {\n> > -  // Authorize takes a Context (for namespace, user, and traceability) and Attributes to make a policy determination.\n> > -  // reason is an optional return value that can describe why a policy decision was made.\n> > -  Authorize(ctx api.Context, a Attributes) (allowed bool, reason string, evaluationError error)\n> >   +\n> > -  // GetAllowedSubjects takes a Context (for namespace and traceability) and Attributes to determine which users and\n> > -  // groups are allowed to perform the described action in the namespace.    This API enables the ResourceBasedReview requests below\n> > -  GetAllowedSubjects(ctx api.Context, a Attributes) (users util.StringSet, groups util.StringSet, evaluationError error)\n> \n> Because you don't need audit? Unless every call site needs both methods\n> (and they don't) I would organize these so that there are two fundamental\n> interfaces, and if at the highest level you require both, require both.\n> \n> So would we make ResourceAccessReview optional? It's essential for doing\n> things like \"which namespaces/projects can I see\".\n> \n> —\n> Reply to this email directly or view it on GitHub\n> https://github.com/GoogleCloudPlatform/kubernetes/pull/12209/files#r36531053\n> .\n\n## \n\nClayton Coleman | Lead Engineer, OpenShift\n",
        "createdAt" : "2015-08-07T17:49:58Z",
        "updatedAt" : "2015-12-03T18:54:52Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      }
    ],
    "commit" : "17d3db1cb3407c4aaecb674f94d8620962c1f711",
    "line" : null,
    "diffHunk" : "@@ -1,1 +95,99 @@  // GetAllowedSubjects takes a Context (for namespace and traceability) and Attributes to determine which users and \n  // groups are allowed to perform the described action in the namespace.    This API enables the ResourceBasedReview requests below\n  GetAllowedSubjects(ctx api.Context, a Attributes) (users util.StringSet, groups util.StringSet, evaluationError error)\n}\n```"
  },
  {
    "id" : "424bc7dc-0c86-4128-9ac8-ea1580c2e01b",
    "prId" : 12209,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b5339b16-03b3-45dd-ae06-84713a135e8a",
        "parentId" : null,
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "We may want to make this a SubjectAccessResponse or unify the struct between request and response - action being one nested struct and response being the other (or just use status).\n",
        "createdAt" : "2015-08-05T00:16:23Z",
        "updatedAt" : "2015-12-03T18:54:52Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "dfc34930-78ee-4f54-88a8-288112bf7bb1",
        "parentId" : "b5339b16-03b3-45dd-ae06-84713a135e8a",
        "authorId" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "body" : "@ncdc @pweil-\n\nOn Tuesday, August 4, 2015, Clayton Coleman notifications@github.com\nwrote:\n\n> In docs/design/enhance-pluggable-policy.md\n> https://github.com/GoogleCloudPlatform/kubernetes/pull/12209#discussion_r36258015\n> :\n> \n> > +// NEW\n> > +type Authorizer interface {\n> > -  // Authorize takes a Context (for namespace, user, and traceability) and Attributes to make a policy determination.\n> > -  // reason is an optional return value that can describe why a policy decision was made.\n> > -  Authorize(ctx api.Context, a Attributes) (allowed bool, reason string, evaluationError error)\n> >   +\n> > -  // GetAllowedSubjects takes a Context (for namespace and traceability) and Attributes to determine which users and\n> > -  // groups are allowed to perform the described action in the namespace.    This API enables the ResourceBasedReview requests below\n> > -  GetAllowedSubjects(ctx api.Context, a Attributes) (users util.StringSet, groups util.StringSet, evaluationError error)\n> >   +}\n> >   +```\n> >   +\n> >   +### SubjectAccessReview\n> >   +`/api/{version}/ns/{namespace}/subjectAccessReview` - This API answers the question: can a user or group (use authenticated user if none is specified) perform a given action.  Given the Authorizer interface (proposed or existing), this endpoint can be implemented generically against any Authorizer by creating the correct Attributes and making an .Authorize() call.\n> >   +\n> >   +SubjectAccessReview is runtime.Object with associated RESTStorage that only accepts creates.  The caller POSTs a SubjectAccessReview to this URL and he gets a SubjectAccessReviewResponse back.  Here is an example of a call and its corresponding return.\n> \n> We may want to make this a SubjectAccessResponse or unify the struct\n> between request and response - action being one nested struct and response\n> being the other (or just use status).\n> \n> —\n> Reply to this email directly or view it on GitHub\n> https://github.com/GoogleCloudPlatform/kubernetes/pull/12209/files#r36258015\n> .\n",
        "createdAt" : "2015-08-05T01:07:26Z",
        "updatedAt" : "2015-12-03T18:54:52Z",
        "lastEditedBy" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "tags" : [
        ]
      }
    ],
    "commit" : "17d3db1cb3407c4aaecb674f94d8620962c1f711",
    "line" : null,
    "diffHunk" : "@@ -1,1 +115,119 @@\n\nSubjectAccessReview is runtime.Object with associated RESTStorage that only accepts creates.  The caller POSTs a SubjectAccessReview to this URL and he gets a SubjectAccessReviewResponse back.  Here is an example of a call and its corresponding return.\n\n```"
  },
  {
    "id" : "4e730e83-5a7b-46ff-b4fd-6d0b38978b1a",
    "prId" : 12209,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "34598e3a-488b-4124-b783-fe042563086d",
        "parentId" : null,
        "authorId" : "6eca0ade-9879-4dd7-ad14-547e16f5c041",
        "body" : "You did not make a goal explaining why `reason` is needed or what value it provides.\n\nMaybe include some information on why the `reason` is useful, if it should be made visible to the end-user or logged only, etc?\n",
        "createdAt" : "2015-08-05T20:43:09Z",
        "updatedAt" : "2015-12-03T18:54:52Z",
        "lastEditedBy" : "6eca0ade-9879-4dd7-ad14-547e16f5c041",
        "tags" : [
        ]
      },
      {
        "id" : "926509ce-cb08-4345-9117-70e8d0219d1b",
        "parentId" : "34598e3a-488b-4124-b783-fe042563086d",
        "authorId" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "body" : "@derekwaynecarr Isn't this addressed in the passage that describes UIs that want to display reason information?\n",
        "createdAt" : "2015-08-05T22:54:31Z",
        "updatedAt" : "2015-12-03T18:54:52Z",
        "lastEditedBy" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "tags" : [
        ]
      }
    ],
    "commit" : "17d3db1cb3407c4aaecb674f94d8620962c1f711",
    "line" : null,
    "diffHunk" : "@@ -1,1 +86,90 @@  // reason is an optional return value that can describe why a policy decision was made.  Reasons are useful during \n  // debugging when trying to figure out why a user or group has access to perform a particular action.\n  Authorize(ctx api.Context, a Attributes) (allowed bool, reason string, evaluationError error)\n}\n"
  },
  {
    "id" : "1179af07-c581-43b5-bca9-925847a69431",
    "prId" : 12209,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "00d78ce2-15d1-4690-908c-d2f807d0844d",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "need to update with apiGroup and subresource (or clarify if subresource is included in resource as `resource/subresource`)\n",
        "createdAt" : "2015-09-29T01:48:30Z",
        "updatedAt" : "2015-12-03T18:54:52Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "17d3db1cb3407c4aaecb674f94d8620962c1f711",
    "line" : null,
    "diffHunk" : "@@ -1,1 +60,64 @@    - applies only to the API endpoints, such as\n        `/api/v1beta1/pods`.  For miscelaneous endpoints, like `/version`, the kind is the empty string.\n  - resourceName - the name of the resource during a get, update, or delete action.\n  - subresource - which subresource is being accessed\n"
  }
]
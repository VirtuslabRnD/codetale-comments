[
  {
    "id" : "0e896ef0-f597-4abb-b5c9-fb47eabfca93",
    "prId" : 24051,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "93e48f07-4f8b-4add-8cad-e22d9ed19e1b",
        "parentId" : null,
        "authorId" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "body" : "Partial paths are not going to work for volume plugins; suggest dropping this section.\n",
        "createdAt" : "2016-04-08T20:27:59Z",
        "updatedAt" : "2016-05-20T02:57:38Z",
        "lastEditedBy" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "tags" : [
        ]
      }
    ],
    "commit" : "0f3a8bd061f52b82cba57f99454a9cf7f789d069",
    "line" : null,
    "diffHunk" : "@@ -1,1 +310,314 @@to expose variables from other containers.\n\n#### Volume plugin\n\nThis table shows volume paths and partial selectors used for resources cpu and memory."
  },
  {
    "id" : "f4514fac-cb7d-41a4-bf13-94142275c767",
    "prId" : 24051,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2b34d5e3-fa18-4e6c-8216-cda7a8e97d18",
        "parentId" : null,
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "Examples of how to use these to set the Java heap size and GOMAXPROCS would be helpful.\n",
        "createdAt" : "2016-04-15T07:02:19Z",
        "updatedAt" : "2016-05-20T02:57:38Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      }
    ],
    "commit" : "0f3a8bd061f52b82cba57f99454a9cf7f789d069",
    "line" : null,
    "diffHunk" : "@@ -1,1 +151,155 @@| CPU_REQUEST | spec.containers[?(@.name==\"container-name\")].resources.requests.cpu|\n| MEMORY_REQUEST | spec.containers[?(@.name==\"container-name\")].resources.requests.memory |\n\n#### Volume plugin\n"
  },
  {
    "id" : "f2ada658-b36d-415a-bf03-4b14f6c497ec",
    "prId" : 24051,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ce87f27d-be63-4b2e-b44d-d29a7f434540",
        "parentId" : null,
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "@lavalamp May be interested in this part about conversion of jsonpath field selectors.\n",
        "createdAt" : "2016-04-22T14:10:23Z",
        "updatedAt" : "2016-05-20T02:57:39Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      }
    ],
    "commit" : "0f3a8bd061f52b82cba57f99454a9cf7f789d069",
    "line" : 87,
    "diffHunk" : "@@ -1,1 +85,89 @@to their use.\n\n#### JSONpath selectors\n\nVersioned objects in kubernetes have json tags as part of their golang fields."
  },
  {
    "id" : "c700e3d1-6910-469a-88b6-b96553790ca7",
    "prId" : 24051,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7e72b748-a6eb-486e-a434-c6ab39883916",
        "parentId" : null,
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "kubelet should start using external versions and not internal versions.\n",
        "createdAt" : "2016-04-22T23:47:13Z",
        "updatedAt" : "2016-05-20T02:57:39Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "c51eb94e-451d-40cc-8895-628360e0c708",
        "parentId" : "7e72b748-a6eb-486e-a434-c6ab39883916",
        "authorId" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "body" : "@lavalamp is that likely to happen before 1.3?  That seems like it would be a pretty huge refactor.\n",
        "createdAt" : "2016-04-26T15:03:31Z",
        "updatedAt" : "2016-05-20T02:57:39Z",
        "lastEditedBy" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "tags" : [
        ]
      },
      {
        "id" : "3bb6228b-0656-4c9b-92ce-0dc28b065dce",
        "parentId" : "7e72b748-a6eb-486e-a434-c6ab39883916",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "@pmorie, @caesarxuchao is flipping components over as he has time. But\nstarting with controllers, so I wouldn't expect it for 1.3. OTOH, if it's\nblocking something, maybe we can expedite.\n\nOn Tue, Apr 26, 2016 at 8:03 AM, Paul Morie notifications@github.com\nwrote:\n\n> In docs/design/downward_api_resources_limits_requests.md\n> https://github.com/kubernetes/kubernetes/pull/24051#discussion_r61102455\n> :\n> \n> > +to their use.\n> > +\n> > +#### JSONpath selectors\n> > +\n> > +Versioned objects in kubernetes have json tags as part of their golang fields. Although currently internal objects\n> > +in kubernetes also have json tags but these tags should be removed in\n> > +future (see [3933](https://github.com/kubernetes/kubernetes/issues/3933)\n> > +for discussion). So for discussion in this proposal, we assume that\n> > +internal objects do not have json tags. In the first two approaches\n> > +(full and partial json selectors), when a user creates a pod and its\n> > +containers, the user specifies a json path selector in the pod's\n> > +spec to retrieve values of its limits and requests. The selector\n> > +is composed of json tags similar to json paths used with kubectl\n> > +([json](http://kubernetes.io/docs/user-guide/jsonpath/)). This proposal\n> > +uses kubernetes' json path library to process the selectors to retrieve\n> > +the values. As kubelet operates on internal objects (without json tags),\n> \n> @lavalamp https://github.com/lavalamp is that likely to happen before\n> 1.3? That seems like it would be a pretty huge refactor.\n> \n> â€”\n> You are receiving this because you were mentioned.\n> Reply to this email directly or view it on GitHub\n> https://github.com/kubernetes/kubernetes/pull/24051/files/54f11d6e55a30483482e968d7cdfda47ab1d0908#r61102455\n",
        "createdAt" : "2016-04-26T19:29:28Z",
        "updatedAt" : "2016-05-20T02:57:39Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "fa21e5eb-1b3b-4552-82db-2fa23c1a3b89",
        "parentId" : "7e72b748-a6eb-486e-a434-c6ab39883916",
        "authorId" : "6252ac4b-6b9e-4dee-8931-ca3b934d52fc",
        "body" : "@lavalamp, for this work (targeted for 1.3), if we use json path selectors for accessing resource values in kubelet, we would need to convert internal objects to versioned objects unless kubelet starts using external versions. If we are ok with that then not a blocker. Also not a blocker, if we just go with no selectors (or magic keys) approach. \n",
        "createdAt" : "2016-04-26T20:29:17Z",
        "updatedAt" : "2016-05-20T02:57:39Z",
        "lastEditedBy" : "6252ac4b-6b9e-4dee-8931-ca3b934d52fc",
        "tags" : [
        ]
      },
      {
        "id" : "a2c84ac2-741c-4632-a68d-d4b3b6349c4c",
        "parentId" : "7e72b748-a6eb-486e-a434-c6ab39883916",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "No arguments.\n",
        "createdAt" : "2016-04-26T22:35:20Z",
        "updatedAt" : "2016-05-20T02:57:39Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      }
    ],
    "commit" : "0f3a8bd061f52b82cba57f99454a9cf7f789d069",
    "line" : 100,
    "diffHunk" : "@@ -1,1 +98,102 @@([json](http://kubernetes.io/docs/user-guide/jsonpath/)). This proposal\nuses kubernetes' json path library to process the selectors to retrieve\nthe values. As kubelet operates on internal objects (without json tags),\nand the selectors are part of versioned objects, retrieving values of\nthe limits and requests can be handled using these two solutions:"
  },
  {
    "id" : "f1dbcd5b-213b-48fb-aa1f-082db4b8d6fe",
    "prId" : 24051,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f9803211-c9fc-4ef4-94a1-391c27e3a8be",
        "parentId" : null,
        "authorId" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "body" : "Does the proposal really use the library, or is it that some of the approaches discussed could use the library?\n",
        "createdAt" : "2016-04-26T14:56:42Z",
        "updatedAt" : "2016-05-20T02:57:39Z",
        "lastEditedBy" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "tags" : [
        ]
      },
      {
        "id" : "6ae2091a-074d-426e-b129-78e4e102e4f6",
        "parentId" : "f9803211-c9fc-4ef4-94a1-391c27e3a8be",
        "authorId" : "6252ac4b-6b9e-4dee-8931-ca3b934d52fc",
        "body" : "Full and partial selector approaches use json path library.\n",
        "createdAt" : "2016-04-26T15:01:16Z",
        "updatedAt" : "2016-05-20T02:57:39Z",
        "lastEditedBy" : "6252ac4b-6b9e-4dee-8931-ca3b934d52fc",
        "tags" : [
        ]
      }
    ],
    "commit" : "0f3a8bd061f52b82cba57f99454a9cf7f789d069",
    "line" : 98,
    "diffHunk" : "@@ -1,1 +96,100 @@spec to retrieve values of its limits and requests. The selector\nis composed of json tags similar to json paths used with kubectl\n([json](http://kubernetes.io/docs/user-guide/jsonpath/)). This proposal\nuses kubernetes' json path library to process the selectors to retrieve\nthe values. As kubelet operates on internal objects (without json tags),"
  },
  {
    "id" : "f8f0d0cb-9b2a-4a4f-b3b3-78bc1a5bb8d1",
    "prId" : 24051,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e4eb8546-a30e-4561-b3ba-69c858430edb",
        "parentId" : null,
        "authorId" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "body" : "I wouldn't call it one time, exactly.  It's once per API version conversion.\n",
        "createdAt" : "2016-04-26T15:07:46Z",
        "updatedAt" : "2016-05-20T02:57:39Z",
        "lastEditedBy" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "tags" : [
        ]
      },
      {
        "id" : "f61a71c7-4334-4add-9c03-4b9a2ffcd22d",
        "parentId" : "e4eb8546-a30e-4561-b3ba-69c858430edb",
        "authorId" : "6252ac4b-6b9e-4dee-8931-ca3b934d52fc",
        "body" : "@pmorie, I meant one time as in between a pod is created and terminated. Could you elaborate on \"once per API version conversion\"?\n",
        "createdAt" : "2016-04-29T19:55:20Z",
        "updatedAt" : "2016-05-20T02:57:39Z",
        "lastEditedBy" : "6252ac4b-6b9e-4dee-8931-ca3b934d52fc",
        "tags" : [
        ]
      }
    ],
    "commit" : "0f3a8bd061f52b82cba57f99454a9cf7f789d069",
    "line" : 116,
    "diffHunk" : "@@ -1,1 +114,118 @@unless there is another way without requiring the versioned object.\n\nSo there is a one time conversion cost associated with the first (full\npath) and second (partial path) approaches, whereas the third approach\n(magic keys) does not require any such conversion and can directly"
  },
  {
    "id" : "795e9d1c-a306-4e4c-8987-60f43584ca31",
    "prId" : 24051,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "568a7b97-affd-43c5-a781-185b2c177b39",
        "parentId" : null,
        "authorId" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "body" : "Same thing here - this table is really just describing how to address different information with a selector rather than dictating a path.\n",
        "createdAt" : "2016-04-26T15:09:48Z",
        "updatedAt" : "2016-05-20T02:57:39Z",
        "lastEditedBy" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "tags" : [
        ]
      }
    ],
    "commit" : "0f3a8bd061f52b82cba57f99454a9cf7f789d069",
    "line" : null,
    "diffHunk" : "@@ -1,1 +159,163 @@\n\n| Path | Selector |\n| ---- | ------------------- |\n| cpu_limit | spec.containers[?(@.name==\"container-name\")].resources.limits.cpu|"
  },
  {
    "id" : "1feda992-0fb5-46d5-84a3-bbb7da093757",
    "prId" : 24051,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bb0c241c-aa5c-41f7-98c3-d11404f64db6",
        "parentId" : null,
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "I didn't notice this before. What is the rationale for using the cgroup format? It's not going to match the actual number of shares in the case of, for instance, BestEffort containers. \ncc @vishh \n",
        "createdAt" : "2016-05-12T16:49:47Z",
        "updatedAt" : "2016-05-20T02:57:39Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "651d4a7d-ffc1-4a68-a1ce-d5aeb707de60",
        "parentId" : "bb0c241c-aa5c-41f7-98c3-d11404f64db6",
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "It also seems like shares will be harder to use, such as to set thread-pool sizes.\n",
        "createdAt" : "2016-05-12T16:54:41Z",
        "updatedAt" : "2016-05-20T02:57:39Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "94e3c9a1-c067-4717-b618-de939cbdaca9",
        "parentId" : "bb0c241c-aa5c-41f7-98c3-d11404f64db6",
        "authorId" : "6252ac4b-6b9e-4dee-8931-ca3b934d52fc",
        "body" : "I think the main reason to have similar format as cgroup was to provide similar experience (in terms of format) for applications if they have been using cgroup limits available inside containers.\n\n@derekwaynecarr Would you like to add something here?\n",
        "createdAt" : "2016-05-12T18:24:36Z",
        "updatedAt" : "2016-05-20T02:57:39Z",
        "lastEditedBy" : "6252ac4b-6b9e-4dee-8931-ca3b934d52fc",
        "tags" : [
        ]
      },
      {
        "id" : "bc2ca997-5640-48a2-8eae-ca5eaeb3f09c",
        "parentId" : "bb0c241c-aa5c-41f7-98c3-d11404f64db6",
        "authorId" : "6252ac4b-6b9e-4dee-8931-ca3b934d52fc",
        "body" : "As per this document: http://kubernetes.io/docs/user-guide/compute-resources/\n\n```\nThe spec.container[].resources.limits.cpu is multiplied by 1024, converted to an integer, and used as the value of the --cpu-shares flag to the docker run command.\nThe spec.container[].resources.limits.memory is converted to an integer, and used as the value of the --memory flag to the docker run command.\n```\n\nSo the value of cpu-share and memory (passed to docker) is output as memory and cpu limits. The resource requests are also computed similar ways and output in the similar format.\n",
        "createdAt" : "2016-05-12T19:50:03Z",
        "updatedAt" : "2016-05-20T02:57:39Z",
        "lastEditedBy" : "6252ac4b-6b9e-4dee-8931-ca3b934d52fc",
        "tags" : [
        ]
      },
      {
        "id" : "5bf3419d-b2de-47db-9e06-14e3d664344c",
        "parentId" : "bb0c241c-aa5c-41f7-98c3-d11404f64db6",
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "I do not expect that document to remain true as resource QoS evolves:\nhttps://github.com/kubernetes/kubernetes/blob/master/docs/proposals/resource-qos.md\n\nFor instance, we know that the cgroup hierarchy will get more complex.\n\nShares are an implementation detail. Most legacy applications, which run outside containers as well, don't look at shares, and I think it's a bad idea for them to start looking at it. \n\nManaging CPU is complex: QoS, normalization across heterogeneous architectures, shares, quota, cpusets, core masks, nice, scheduling policies, ... \n\nWhat applications need is an abstraction that tells them:\n- how much computing power is available, by some useful measure\n- how many physical threads are available (e.g., to decide whether spinlocks will work, the min. number of OS threads needed)\n",
        "createdAt" : "2016-05-15T19:31:08Z",
        "updatedAt" : "2016-05-20T02:57:39Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      }
    ],
    "commit" : "0f3a8bd061f52b82cba57f99454a9cf7f789d069",
    "line" : null,
    "diffHunk" : "@@ -1,1 +585,589 @@\nThe output format for resources limits and requests will be same as\ncgroups output format, i.e. cpu in cpu shares (cores multiplied by 1024\nand rounded to integer) and memory in bytes. For example, memory request\nor limit of `64Mi` in the container spec will be output as `67108864`"
  },
  {
    "id" : "08abf5e2-ee4d-4a8a-a0d7-234573dd2b20",
    "prId" : 24051,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "86bdedea-2f90-4483-a7a0-f0d8df430e51",
        "parentId" : null,
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "resourceFieldRef\n",
        "createdAt" : "2016-05-20T06:25:06Z",
        "updatedAt" : "2016-05-20T06:25:06Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      }
    ],
    "commit" : "0f3a8bd061f52b82cba57f99454a9cf7f789d069",
    "line" : 488,
    "diffHunk" : "@@ -1,1 +486,490 @@\nVolumes are pod scoped, the container name must be specified as part of\n`containerSpecFieldRef` with them.\n\n#### Examples"
  }
]
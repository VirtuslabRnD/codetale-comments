[
  {
    "id" : "7e28ee40-dee1-4a3f-a567-fd6dbd7543d5",
    "prId" : 1280,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f9fd06cd-c5f8-42db-8bdf-177d2de8396d",
        "parentId" : null,
        "authorId" : "4aafd631-794d-4704-aeda-a6c56ce667d1",
        "body" : "We should probably write a note somewhere for these tuts why we also have `tailRecM` on monad instances. I've added this ticket https://github.com/typelevel/cats/issues/1284 to track it\n",
        "createdAt" : "2016-08-12T16:59:01Z",
        "updatedAt" : "2016-08-12T17:34:40Z",
        "lastEditedBy" : "4aafd631-794d-4704-aeda-a6c56ce667d1",
        "tags" : [
        ]
      }
    ],
    "commit" : "61de99514cdc8491fac8bd2e2b172e1ba50d4db8",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +140,144 @@\n    def tailRecM[A, B](a: A)(f: A => Kleisli[F, Z, A Xor B]) =\n      Kleisli[F, Z, B]({ z => FlatMap[F].tailRecM(a) { f(_).run(z) } })\n  }\n```"
  },
  {
    "id" : "58d24a71-b5e0-4a37-8242-2a4588e53abe",
    "prId" : 440,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "76566449-b422-4deb-9e93-e0413dfdd915",
        "parentId" : null,
        "authorId" : "89a3e0e3-e301-4aa8-b150-74070eb5a619",
        "body" : "I could imagine providing a table after this paragraph, which shows the requirement and then the methods it provides. Do you think that idea makes sense?\n",
        "createdAt" : "2015-08-11T16:43:40Z",
        "updatedAt" : "2015-08-14T19:50:48Z",
        "lastEditedBy" : "89a3e0e3-e301-4aa8-b150-74070eb5a619",
        "tags" : [
        ]
      }
    ],
    "commit" : "d038acebff9f69b49872720ca528f337ac6f9b22",
    "line" : 90,
    "diffHunk" : "@@ -1,1 +88,92 @@\nIt is important to note that the `F[_]` having a `FlatMap` (or a `Monad`) instance is not a hard requirement -\nwe can do useful things with weaker requirements. Such an example would be `Kleisli#map`, which only requires\nthat `F[_]` have a `Functor` instance (e.g. is equipped with `map: F[A] => (A => B) => F[B]`).\n"
  },
  {
    "id" : "84eb9934-5086-4b7d-9050-92806d251841",
    "prId" : 440,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f99afcba-34cc-440a-b192-efa698ec86ae",
        "parentId" : null,
        "authorId" : "89a3e0e3-e301-4aa8-b150-74070eb5a619",
        "body" : "Similarly to the previous question, do you think it would be worth providing a table here too?\n",
        "createdAt" : "2015-08-11T16:44:16Z",
        "updatedAt" : "2015-08-14T19:50:48Z",
        "lastEditedBy" : "89a3e0e3-e301-4aa8-b150-74070eb5a619",
        "tags" : [
        ]
      }
    ],
    "commit" : "d038acebff9f69b49872720ca528f337ac6f9b22",
    "line" : 119,
    "diffHunk" : "@@ -1,1 +117,121 @@instance, `Kleisli[F, A, B]` has a `Functor` instance so long as the chosen `F[_]` does. It has a `Monad`\ninstance so long as the chosen `F[_]` does. The instances in Cats are laid out in a way such that implicit\nresolution will pick up the most specific instance it can (depending on the `F[_]`).\n\nAn example of a `Monad` instance for `Kleisli` would be:"
  },
  {
    "id" : "54c3c9cb-4453-4cdd-ac6b-168c6be125ae",
    "prId" : 440,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "be155173-2f07-478b-9e38-f191dd88d316",
        "parentId" : null,
        "authorId" : null,
        "body" : "I think it would be nice if the introduction had a bit more \"meat\" in it, before diving into the detail. Eg something like:\n\n> Kleisli is a data type that will come in handy often, especially if you are working with monadic functions.\n> \n> Recall that a Monad is a structure that represents computations and defines how they can be chained together and used to control the flow of the computations.\n> \n> But rather than monads, what if we wanted to work with functions with different return types and chain them together? The normal scala compose method cannot be used, so the Kleisli just adds the extra plumbing for us so the functions can work together. For example, we may want to read in different environment configurations and use them in a more general context.\"\n\nAn example introduction from another tutorial is the [freemonad \"what is it\"](https://github.com/non/cats/blob/master/docs/src/main/tut/freemonad.md#what-is-it).\n",
        "createdAt" : "2015-08-11T18:39:28Z",
        "updatedAt" : "2015-08-14T19:50:48Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "0a960aee-c5ba-4f91-af84-dfc780e3d44c",
        "parentId" : "be155173-2f07-478b-9e38-f191dd88d316",
        "authorId" : "4aafd631-794d-4704-aeda-a6c56ce667d1",
        "body" : "Hm I think this is covered by the next section under \"Functions\" - or did you have something different in mind?\n",
        "createdAt" : "2015-08-11T22:57:11Z",
        "updatedAt" : "2015-08-14T19:50:48Z",
        "lastEditedBy" : "4aafd631-794d-4704-aeda-a6c56ce667d1",
        "tags" : [
        ]
      },
      {
        "id" : "50278062-e9ac-4d6c-99af-9d0672a130b5",
        "parentId" : "be155173-2f07-478b-9e38-f191dd88d316",
        "authorId" : null,
        "body" : "Most importantly... just some thoughts that you can discard as you wish; this _is_ a good tutorial.\n\nThe idea, that I concede I may have failed to correctly portray, is that everything in the introduction _is_ covered in later sections (or rather, _must_ be covered), but in a simpler tone; nothing more, nothing less\n",
        "createdAt" : "2015-08-11T23:07:00Z",
        "updatedAt" : "2015-08-14T19:50:48Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "3f7b1321-314a-4966-a91a-1503210c6068",
        "parentId" : "be155173-2f07-478b-9e38-f191dd88d316",
        "authorId" : "4aafd631-794d-4704-aeda-a6c56ce667d1",
        "body" : "Ah gotcha, patch incoming\n",
        "createdAt" : "2015-08-11T23:22:04Z",
        "updatedAt" : "2015-08-14T19:50:48Z",
        "lastEditedBy" : "4aafd631-794d-4704-aeda-a6c56ce667d1",
        "tags" : [
        ]
      }
    ],
    "commit" : "d038acebff9f69b49872720ca528f337ac6f9b22",
    "line" : 9,
    "diffHunk" : "@@ -1,1 +7,11 @@---\n# Kleisli\nKleisli is a data type that will come in handy often, especially if you are working with monadic functions.\nMonadic functions are functions that return a monadic value - for instance, a function may return an\n`Option[Int]` or an `Xor[String, List[Double]]`."
  },
  {
    "id" : "f9daae10-1e03-446a-a399-3e89f210fb93",
    "prId" : 440,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5164e5f8-5021-4491-9e62-e5e89b02126a",
        "parentId" : null,
        "authorId" : "8106957f-b999-418b-b22b-14067e9a3932",
        "body" : "Might be nice to put the signatures in a column, if there's room ... `lower` and `traverse` are likely to be unfamiliar.\n",
        "createdAt" : "2015-08-11T23:22:17Z",
        "updatedAt" : "2015-08-14T19:50:48Z",
        "lastEditedBy" : "8106957f-b999-418b-b22b-14067e9a3932",
        "tags" : [
        ]
      },
      {
        "id" : "a45b9c4e-04b9-406e-809f-c3a29dad0806",
        "parentId" : "5164e5f8-5021-4491-9e62-e5e89b02126a",
        "authorId" : "4aafd631-794d-4704-aeda-a6c56ce667d1",
        "body" : "There's probably room, do you have any ideas on how to show the type signature? Perhaps the fully curried form `map: Kleisli[F, A, B] => (B => C) => Kleisli[F, A, C]` ? Or maybe smush the type signature with the method name, like `def map[C](f: B => C): Kleisli[F, A, C]` ?\n\nOne small concern is the type signature of `traverse` may make it.. even more foreign?\n",
        "createdAt" : "2015-08-11T23:40:13Z",
        "updatedAt" : "2015-08-14T19:50:48Z",
        "lastEditedBy" : "4aafd631-794d-4704-aeda-a6c56ce667d1",
        "tags" : [
        ]
      },
      {
        "id" : "f213133d-1f3e-4262-9e6f-3b3dd7eab4e9",
        "parentId" : "5164e5f8-5021-4491-9e62-e5e89b02126a",
        "authorId" : "8106957f-b999-418b-b22b-14067e9a3932",
        "body" : "Yeah I kind of like the \"abstract\" curried signatures but in my experience they're baffling to beginners. So something like the Scala method sig might work better. But yeah it might end up being terrible. Pls ignore in that case.\n",
        "createdAt" : "2015-08-11T23:45:16Z",
        "updatedAt" : "2015-08-14T19:50:48Z",
        "lastEditedBy" : "8106957f-b999-418b-b22b-14067e9a3932",
        "tags" : [
        ]
      }
    ],
    "commit" : "d038acebff9f69b49872720ca528f337ac6f9b22",
    "line" : 113,
    "diffHunk" : "@@ -1,1 +111,115 @@map       | Functor\ntraverse  | Applicative\n\n### Type class instances\nThe type class instances for `Kleisli`, like that for functions, fix the input type (and the `F[_]`) and leave"
  },
  {
    "id" : "4e35d0f3-7ffe-43ad-9e54-3d71484c4a63",
    "prId" : 440,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "25c4f346-e7e8-4176-b6ce-f79430b068d9",
        "parentId" : null,
        "authorId" : "89a3e0e3-e301-4aa8-b150-74070eb5a619",
        "body" : "I think it would be useful to provide an example of composing functions here, just to be clear how that works:\n\n``` scala\nval twice: Int => Int =\n  x => x * 2\n\nval countCats: Int => String =\n  x => if (x == 1) \"1 cat\" else s\"$x cats\"\n\nval twiceAsManyCats: Int => String =\n  twice andThen countCats\n  // equivalent to: countCats compose twice\n\ntwiceAsManyCats(3) // prints \"6 cats\"\n```\n",
        "createdAt" : "2015-08-12T00:26:50Z",
        "updatedAt" : "2015-08-14T19:50:48Z",
        "lastEditedBy" : "89a3e0e3-e301-4aa8-b150-74070eb5a619",
        "tags" : [
        ]
      }
    ],
    "commit" : "d038acebff9f69b49872720ca528f337ac6f9b22",
    "line" : 28,
    "diffHunk" : "@@ -1,1 +26,30 @@this compositional property that we are able to write many small functions and compose them together\nto create a larger one that suits our needs.\n\n```tut\nval twice: Int => Int ="
  },
  {
    "id" : "1991f579-f0ff-4dcc-a199-1badfd68cefe",
    "prId" : 440,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b918f569-3fa3-4fa3-b3dc-a0a7ecf9c960",
        "parentId" : null,
        "authorId" : "89a3e0e3-e301-4aa8-b150-74070eb5a619",
        "body" : "I suggest using `import cats.implicits._` here and then using syntax, rather than referring to `F`.flatMap`, e.g.\n\n``` scala\nKleisli[F, Z, B](z => k.run(z).flatMap(run))\n```\n",
        "createdAt" : "2015-08-12T00:29:14Z",
        "updatedAt" : "2015-08-14T19:50:48Z",
        "lastEditedBy" : "89a3e0e3-e301-4aa8-b150-74070eb5a619",
        "tags" : [
        ]
      }
    ],
    "commit" : "d038acebff9f69b49872720ca528f337ac6f9b22",
    "line" : null,
    "diffHunk" : "@@ -1,1 +69,73 @@  def compose[Z](k: Kleisli[F, Z, A])(implicit F: FlatMap[F]): Kleisli[F, Z, B] =\n    Kleisli[F, Z, B](z => k.run(z).flatMap(run))\n}\n```\n"
  },
  {
    "id" : "94b868d2-ad56-4cf7-946b-6be1cfdb1503",
    "prId" : 440,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3426cc80-19a9-472f-b46e-16e9b24041ee",
        "parentId" : null,
        "authorId" : "89a3e0e3-e301-4aa8-b150-74070eb5a619",
        "body" : "You could use `cats.implicits._` here too.\n",
        "createdAt" : "2015-08-12T00:32:04Z",
        "updatedAt" : "2015-08-14T19:50:48Z",
        "lastEditedBy" : "89a3e0e3-e301-4aa8-b150-74070eb5a619",
        "tags" : [
        ]
      }
    ],
    "commit" : "d038acebff9f69b49872720ca528f337ac6f9b22",
    "line" : null,
    "diffHunk" : "@@ -1,1 +136,140 @@    def map[A, B](fa: Kleisli[F, Z, A])(f: A => B): Kleisli[F, Z, B] =\n      Kleisli(z => fa.run(z).map(f))\n  }\n```\n"
  }
]
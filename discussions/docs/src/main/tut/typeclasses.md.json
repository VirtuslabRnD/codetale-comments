[
  {
    "id" : "dceb0ec5-1ac7-4aae-909a-2170697399d0",
    "prId" : 822,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b4a4a120-c24a-4248-b43a-b6ea20b0cc26",
        "parentId" : null,
        "authorId" : "f94caf4c-b5e8-4029-84ca-0fca5b9efcd8",
        "body" : "`size`?\n",
        "createdAt" : "2016-02-09T20:51:55Z",
        "updatedAt" : "2016-02-09T20:51:55Z",
        "lastEditedBy" : "f94caf4c-b5e8-4029-84ca-0fca5b9efcd8",
        "tags" : [
        ]
      }
    ],
    "commit" : "e2490898c2da7f680369cd05b2e34ad69b8625f8",
    "line" : 11,
    "diffHunk" : "@@ -1,1 +93,97 @@![Typeclass hierarchy](http://g.gravizo.com/g?\n  digraph G {\n    aize =\"4,4\";\n    edge [dir=back]\n    node [shape=box,style=\"rounded\"]"
  },
  {
    "id" : "ca379dc5-3b40-4d19-8a7c-6e46dddc9be2",
    "prId" : 245,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "200da933-e973-44ea-827f-b377f4ba23e8",
        "parentId" : null,
        "authorId" : "b714495a-5740-47d4-aaaa-98f354f5c0a7",
        "body" : "There isn't really a restriction to a single type variable is there? What about something like Arrow?\n",
        "createdAt" : "2015-03-02T10:40:09Z",
        "updatedAt" : "2015-03-02T10:40:09Z",
        "lastEditedBy" : "b714495a-5740-47d4-aaaa-98f354f5c0a7",
        "tags" : [
        ]
      },
      {
        "id" : "6c2c1ebb-8a2b-444f-8f29-ba43f509fab6",
        "parentId" : "200da933-e973-44ea-827f-b377f4ba23e8",
        "authorId" : "66a3e1fe-d02b-4e16-badc-4e9980e148af",
        "body" : "Arrow has only one type parameter but of kind `F[A,B]` (`trait Arrow[F[_, _]]`)\n",
        "createdAt" : "2015-03-02T14:47:44Z",
        "updatedAt" : "2015-03-02T14:47:44Z",
        "lastEditedBy" : "66a3e1fe-d02b-4e16-badc-4e9980e148af",
        "tags" : [
        ]
      },
      {
        "id" : "70fe7540-4d21-445d-991b-08c3c23d609b",
        "parentId" : "200da933-e973-44ea-827f-b377f4ba23e8",
        "authorId" : "66a3e1fe-d02b-4e16-badc-4e9980e148af",
        "body" : "Could you uppercase Haskell, Java, and Scala here?\n",
        "createdAt" : "2015-03-02T14:49:22Z",
        "updatedAt" : "2015-03-02T14:49:22Z",
        "lastEditedBy" : "66a3e1fe-d02b-4e16-badc-4e9980e148af",
        "tags" : [
        ]
      },
      {
        "id" : "f38fea8c-cd9a-498c-9780-8c600f43446f",
        "parentId" : "200da933-e973-44ea-827f-b377f4ba23e8",
        "authorId" : "b714495a-5740-47d4-aaaa-98f354f5c0a7",
        "body" : "Err right. Arrow was a poor example. What about something like [Shapeless's Prepend](https://github.com/milessabin/shapeless/blob/7832d1b2429907548f32b04264215456b5009d63/core/src/main/scala/shapeless/ops/hlists.scala#L1491)? Is that not a true type class?\n",
        "createdAt" : "2015-03-02T16:50:18Z",
        "updatedAt" : "2015-03-02T16:50:18Z",
        "lastEditedBy" : "b714495a-5740-47d4-aaaa-98f354f5c0a7",
        "tags" : [
        ]
      },
      {
        "id" : "ada5e5f5-6026-43e6-866f-0149e2f83c2a",
        "parentId" : "200da933-e973-44ea-827f-b377f4ba23e8",
        "authorId" : "6943dbfe-856b-4f1b-bd04-dca0091e8291",
        "body" : "Multi-parameter type classes are a language extension in Haskell, and I can't think of too many Scala projects that use them (only Shapeless and Banana come to mind at the moment), but I agree that it makes sense to change the language here to be less categorical and more a description of typical practice.\n",
        "createdAt" : "2015-03-02T17:07:42Z",
        "updatedAt" : "2015-03-02T17:07:42Z",
        "lastEditedBy" : "6943dbfe-856b-4f1b-bd04-dca0091e8291",
        "tags" : [
        ]
      },
      {
        "id" : "07bad435-c9de-4f06-b100-b14b70f770c4",
        "parentId" : "200da933-e973-44ea-827f-b377f4ba23e8",
        "authorId" : "89a3e0e3-e301-4aa8-b150-74070eb5a619",
        "body" : "Spire also has used (and probably will continue to use) multi-parameter type classes.\n",
        "createdAt" : "2015-03-04T21:43:36Z",
        "updatedAt" : "2015-03-04T21:43:36Z",
        "lastEditedBy" : "89a3e0e3-e301-4aa8-b150-74070eb5a619",
        "tags" : [
        ]
      },
      {
        "id" : "c36b650b-d0f8-4660-8650-c3d99643a11d",
        "parentId" : "200da933-e973-44ea-827f-b377f4ba23e8",
        "authorId" : "b3959098-dd79-469e-9fce-aff8d8e90465",
        "body" : "I also use multi-parameter type classes, for encoding some relationship between types.  (I think I played with 6 different kinds before settling on my 3-parameter TC.). Of course, then you can't use context bounds, unfortunately.\n\nP.S. I also winced at the phrase \"universally quantified\" even though it's accurate.  How noob friendly would we like these docs to be?\n",
        "createdAt" : "2015-03-05T15:35:29Z",
        "updatedAt" : "2015-03-05T15:35:29Z",
        "lastEditedBy" : "b3959098-dd79-469e-9fce-aff8d8e90465",
        "tags" : [
        ]
      },
      {
        "id" : "a636b8be-9913-42f3-be73-f295481b5d32",
        "parentId" : "200da933-e973-44ea-827f-b377f4ba23e8",
        "authorId" : "89a3e0e3-e301-4aa8-b150-74070eb5a619",
        "body" : "My feeling is that it's fine to introduce readers to phrases like _universally-quantified_ as long as we also provide an intuition or an informal definition as well.\n\nIn this particular case, I think something like this might work:\n\n> You can think of it as an \"interface\" in the java sense, but implemented without using inheritance. In Scala, these are implemented using a trait with a type parameter (i.e. the trait is _univerally-quantified_ over a type).\n\nI'm not proposing this exact language, just sort of thinking out loud. I think it's fine to take a very iterative approach towards writing (and improving) our documentation.\n",
        "createdAt" : "2015-03-05T15:53:29Z",
        "updatedAt" : "2015-03-05T15:53:29Z",
        "lastEditedBy" : "89a3e0e3-e301-4aa8-b150-74070eb5a619",
        "tags" : [
        ]
      },
      {
        "id" : "db8ce688-265f-477f-a0d6-c80ef0485c01",
        "parentId" : "200da933-e973-44ea-827f-b377f4ba23e8",
        "authorId" : "b3959098-dd79-469e-9fce-aff8d8e90465",
        "body" : ":+1: \n",
        "createdAt" : "2015-03-05T16:53:51Z",
        "updatedAt" : "2015-03-05T16:53:51Z",
        "lastEditedBy" : "b3959098-dd79-469e-9fce-aff8d8e90465",
        "tags" : [
        ]
      },
      {
        "id" : "246b3c8d-84cf-425a-ad7d-1a0fb5409809",
        "parentId" : "200da933-e973-44ea-827f-b377f4ba23e8",
        "authorId" : "1b80f00c-b2ed-49b7-8651-8be183b8980a",
        "body" : "Nit pick -- it might be better to avoid comparisons to Haskell until later in the docs. Rather, let the concepts stand on their own at this point.\n",
        "createdAt" : "2015-03-05T16:58:25Z",
        "updatedAt" : "2015-03-05T16:58:25Z",
        "lastEditedBy" : "1b80f00c-b2ed-49b7-8651-8be183b8980a",
        "tags" : [
        ]
      }
    ],
    "commit" : "e0e1e930e1e123723f531a4c49367f28d307094c",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +2,6 @@think of it as an \"interface\" in the java sense, but universally\nquantified over some type. In scala they are encoded as a trait that\nhas one type variable, such as:\n\n```tut"
  }
]
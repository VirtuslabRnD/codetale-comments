[
  {
    "id" : "13ecd12e-1419-4e31-b0c4-c446ac1346ca",
    "prId" : 1859,
    "prUrl" : "https://github.com/scala-native/scala-native/pull/1859#pullrequestreview-452893499",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b5caa31c-6bed-44f7-91a8-099d7dba9c36",
        "parentId" : null,
        "authorId" : "ae189121-dea4-445f-87d0-303740ceff41",
        "body" : "I'm a bit confused by this change. This is probably my lack of knowledge about the .rst format. Would you mind explaining what is going here, or point me to relevant documentation?",
        "createdAt" : "2020-07-21T20:45:46Z",
        "updatedAt" : "2020-07-21T23:14:49Z",
        "lastEditedBy" : "ae189121-dea4-445f-87d0-303740ceff41",
        "tags" : [
        ]
      },
      {
        "id" : "0c647b48-6b98-449f-b9d8-3ebb5e62060f",
        "parentId" : "b5caa31c-6bed-44f7-91a8-099d7dba9c36",
        "authorId" : "8268d89a-1c52-467c-9a13-921d930413d7",
        "body" : "Thank you for the timely review.  Yes, there is a bit of wizardry going on there. I could find no good way\r\nto document it inline (but may have just now. I will try that after this)\r\n\r\nThe primary documentation is (sphinx)[ https://www.sphinx-doc.org/en/master/usage/restructuredtext/directives.html?highlight=code-block#showing-code-examples ]. Follow the \r\n(Pygments)[https://pygments.org/docs/lexers/] link to show that a scala parser is available.\r\n\r\nI found the (tutorial) [https://thomas-cokelaer.info/tutorials/sphinx/rest_syntax.html#inserting-code-and-literal-blocks]\r\nmore useful.\r\n\r\nBasically, there is no visible change in the output.  Prior to this PR, Sphinx warned that it could not \r\nparse those two blocks as Scala, so it was not doing any Scala highlighting for them.   I took Sphinx\r\nat its word and dropped the Scala specification.   I did not try to figure out why Sphinx could not parse\r\nthe contained code because I could not economically change Sphinx.    I suspect that it has something\r\nto do with the leading underbars, especially when the rest looks like a number.\r\n\r\nTurns out that Sphinx can parse & highlight the first changed block (as the default python).\r\n I believe the highlighting is proper but can check again. So that is actually a step to make that block\r\n consistent with the rest of the file.\r\n\r\nThe second block did not have highlighting before this PR and does not after it.  \r\n\r\nI have been told that if one leads a good life, one never gets this deep into Rich Structured Text details.\r\n\r\nDoes this address your concerns?   I'll see about adding a comment so that it is not visible in the end\r\nproduct but briefly explains the wizardry in the file: reduced astonishment.",
        "createdAt" : "2020-07-21T22:50:03Z",
        "updatedAt" : "2020-07-21T23:14:49Z",
        "lastEditedBy" : "8268d89a-1c52-467c-9a13-921d930413d7",
        "tags" : [
        ]
      },
      {
        "id" : "b9d74674-e1c0-47a5-8efa-39a75f6130e8",
        "parentId" : "b5caa31c-6bed-44f7-91a8-099d7dba9c36",
        "authorId" : "8268d89a-1c52-467c-9a13-921d930413d7",
        "body" : "While chasing down the documentation to explain this change, I discovered a way to enter comments\r\nin the source file.  I believe it is far better to not have surprises in the file but where they are unavoidable\r\na brief comment helps the next person understand.    ",
        "createdAt" : "2020-07-21T23:18:17Z",
        "updatedAt" : "2020-07-21T23:18:17Z",
        "lastEditedBy" : "8268d89a-1c52-467c-9a13-921d930413d7",
        "tags" : [
        ]
      }
    ],
    "commit" : "545056a0fcc152c08b32da3cd4903cf1d7835875",
    "line" : 59,
    "diffHunk" : "@@ -1,1 +332,336 @@  base naturals ``Nat._0, ... Nat._9`` and an additional ``Nat.DigitN``\n  constructors, where ``N`` refers to number of digits in the given number. \n  So for example number ``1024`` is going to be encoded as following::\n\n      import scalanative.unsafe._, Nat._"
  },
  {
    "id" : "c7a069a5-fd9c-4bfa-9997-e57bfabb72b1",
    "prId" : 1855,
    "prUrl" : "https://github.com/scala-native/scala-native/pull/1855#pullrequestreview-450709477",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9327cd8f-8383-4679-ac6e-1070fbc4910b",
        "parentId" : null,
        "authorId" : "8268d89a-1c52-467c-9a13-921d930413d7",
        "body" : "Well said!  I like the examples, they clarify.\r\n\r\nI hope that you are not getting frustrated by the review cycles.\r\n\r\nWhack a mole time!    I can create an independent issue for the concern below\r\nso that the current PR can proceed. \r\n\r\nI think this section exposes a weakness in the section which follows it. \r\n\r\nAbsent any documentation, it is reasonable to believe that the c interpolator\r\nand toCString() have the same results.  One knows that _someone_ is going\r\nto do toCString() and report that it allows escapes which the quote-equivalent-unquote\r\ninterpolator does not.\r\n```\r\nAdditionally, we also expose two helper functions unsafe.toCString and unsafe.fromCString to convert between C-style and Java-style strings.\r\n```\r\nI think that creating some test cases to figure out what toCString() is actually\r\ndoing with regards to escapes and documenting it in this .rst is worthwhile.\r\nI _think_ it is converting from Java strings to bytes and then copying those bytes to allocated memory.  The creation of the Java string would have done escape\r\nprocessing but toCString() would not. Thus one would need a Java \"\\\\a\" to pass\r\n the two bytes '\\' & 'a' to C.  \r\n\r\nThe same consideration and need for explicit test cases applies to fromCString().\r\nFor the sake of this discussion, consider a byte array read in from user input.\r\nI believe that each byte gets visited one by one and converted to a Java 16 bit Character without escape processing.  Thus a CString holding the two bytes\r\n'\\' and 'n' become two Java Characters, not one newline.  \r\n\r\nI propose that one or more test cases be created and the behavior documented\r\nin this section of the .rst.",
        "createdAt" : "2020-07-17T12:22:47Z",
        "updatedAt" : "2020-08-18T14:00:13Z",
        "lastEditedBy" : "8268d89a-1c52-467c-9a13-921d930413d7",
        "tags" : [
        ]
      },
      {
        "id" : "d7e4008b-6f11-42d5-a640-7806edbc5f6b",
        "parentId" : "9327cd8f-8383-4679-ac6e-1070fbc4910b",
        "authorId" : "ae189121-dea4-445f-87d0-303740ceff41",
        "body" : "The key insight is that:\r\n\r\n* A `String` is a UCS string, i.e., a sequence of 2-byte Chars. It is *usually* interpreted as UTF-16.\r\n* A `CString` is a *byte string*, i.e., a sequence of Bytes. It is *usually* interpreted as UTF-8, but it can also be ASCII or latin1 or whatever.\r\n* The `c\"...\"` interpolator describes a *byte string*, without any specific encoding. Because the source code is text, *some* encoding needs to be chosen when encoding the text *at compile-time* into a byte string. The natural choice is latin1 aka ISO-8859-1, because it uses 1-byte code points, and its valid code point range (0-255) corresponds to the same range in UTF-16 `Char`s and in abstract Unicode code point.\r\n* `fromCString` and `toCString` are charset-aware. They will always assume that the `String` is UTF-16 (as do the `java.nio.charset` APIs) and take an `Charset` parameter to know what encoding to assume for the byte string. If not specified, it is UTF-8. They are very similar to `String.getBytes` and `new String(Array[Byte])`, except that they work with a `CString` instead of an `Array[Byte]`.\r\n\r\n`fromCString` and `toCString` don't care about escapes; escapes are a source-level programming language concern, not a run-time concern. They don't copy byte-by-byte because that would not respect the charset-aware decoding and encoding.",
        "createdAt" : "2020-07-17T14:33:36Z",
        "updatedAt" : "2020-08-18T14:00:13Z",
        "lastEditedBy" : "ae189121-dea4-445f-87d0-303740ceff41",
        "tags" : [
        ]
      }
    ],
    "commit" : "e45b3fc51712c139de63bd281eeaba4398b1ce15",
    "line" : 8,
    "diffHunk" : "@@ -1,1 +360,364 @@It does not allow any octal values or escape characters not supported by Scala compiler, like ``\\a`` or ``\\?``, but also unicode escapes.\nIt is possible to use C-style hex values up to value 0xFF, eg. ``c\"Hello \\x61\\x62\\x63\"``\n\nAdditionally, we also expose two helper functions ``unsafe.fromCString`` and ``unsafe.toCString``\nto convert between C-style `CString` (sequence of Bytes, usually interpreted as UTF-8 or ASCII)"
  },
  {
    "id" : "cc36e847-6e6c-4bd7-9678-14bae1e92b4a",
    "prId" : 472,
    "prUrl" : "https://github.com/scala-native/scala-native/pull/472#pullrequestreview-14951837",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "81def7a8-6ec2-4d80-8bcc-906a5bf27227",
        "parentId" : null,
        "authorId" : "b8dcddd3-fce5-46c9-9dd6-30e86bf19c03",
        "body" : "Shouldn't this be `CUnsignedChar`?",
        "createdAt" : "2017-01-03T15:26:28Z",
        "updatedAt" : "2017-01-03T15:26:28Z",
        "lastEditedBy" : "b8dcddd3-fce5-46c9-9dd6-30e86bf19c03",
        "tags" : [
        ]
      },
      {
        "id" : "a3731bec-887e-4703-92d3-fd55b8f82ef2",
        "parentId" : "81def7a8-6ec2-4d80-8bcc-906a5bf27227",
        "authorId" : "0f96d83b-618e-4d06-9aeb-e1d46fa92077",
        "body" : "Nice catch! I'm going to address this in #473",
        "createdAt" : "2017-01-03T15:39:05Z",
        "updatedAt" : "2017-01-03T15:39:56Z",
        "lastEditedBy" : "0f96d83b-618e-4d06-9aeb-e1d46fa92077",
        "tags" : [
        ]
      }
    ],
    "commit" : "5d496e43db5dcf1f5857b659ea76d2f4fb620e56",
    "line" : 55,
    "diffHunk" : "@@ -1,1 +55,59 @@bool                  CBool\nchar, signed char     CChar\nunsigned char         CUnsignedShort (1)\nshort                 CShort\nunsigned short        CUnsignedShort (1)"
  }
]
[
  {
    "id" : "ed760408-2154-4628-9920-86d8dcb6798c",
    "prId" : 1372,
    "prUrl" : "https://github.com/scala-native/scala-native/pull/1372#pullrequestreview-167890908",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "942ac5c8-d075-47b6-a1b1-27601dfc3593",
        "parentId" : null,
        "authorId" : "d1cbb5a4-1605-48d2-8efe-eeb6295c931f",
        "body" : "It's not clear to me how `exact class type-name` is different from the non-exact version.",
        "createdAt" : "2018-10-23T21:09:15Z",
        "updatedAt" : "2018-10-29T09:48:08Z",
        "lastEditedBy" : "d1cbb5a4-1605-48d2-8efe-eeb6295c931f",
        "tags" : [
        ]
      },
      {
        "id" : "3ea77157-9ab8-4d0c-a761-3f7931303ddf",
        "parentId" : "942ac5c8-d075-47b6-a1b1-27601dfc3593",
        "authorId" : "0f96d83b-618e-4d06-9aeb-e1d46fa92077",
        "body" : "Given a pseudo-Scala syntax with exact types:\r\n```\r\nclass A { def foo = 'A' }\r\nclass B extends A { override def foo = 'B' }\r\n\r\nval x: exact A = new A\r\nx.foo // can *only* call A.foo\r\n\r\nval y: A = x\r\nx.foo // can call either A.foo or B.foo\r\n```\r\nFrom the Scala point of view all reference types are non-exact and nullable. Interflow will infer exactness and nullability. Exactness is primiraly useful for devirtualization. Nullability for partial evaluation of is/as instance of. ",
        "createdAt" : "2018-10-24T12:56:09Z",
        "updatedAt" : "2018-10-29T09:48:08Z",
        "lastEditedBy" : "0f96d83b-618e-4d06-9aeb-e1d46fa92077",
        "tags" : [
        ]
      }
    ],
    "commit" : "dfad1486a8fbc86bf304215f73fa5cd2c25df52d",
    "line" : 44,
    "diffHunk" : "@@ -1,1 +42,46 @@        L <nullable-type-name>         // nullable type-name\n        A <type-name> _                // nonnull array type-name\n        X <name>                       // nonnull exact class type-name\n        <name>                         // nonnull class type-name\n"
  },
  {
    "id" : "d6afa930-865c-4e8e-bca9-174a0e656831",
    "prId" : 1372,
    "prUrl" : "https://github.com/scala-native/scala-native/pull/1372#pullrequestreview-167891609",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6cf87745-31c3-4dd0-a47c-0b5b857791f8",
        "parentId" : null,
        "authorId" : "d1cbb5a4-1605-48d2-8efe-eeb6295c931f",
        "body" : "`Type.Null` which is represented as `l` is not listed.",
        "createdAt" : "2018-10-23T21:24:51Z",
        "updatedAt" : "2018-10-29T09:48:08Z",
        "lastEditedBy" : "d1cbb5a4-1605-48d2-8efe-eeb6295c931f",
        "tags" : [
        ]
      },
      {
        "id" : "b588f248-4d32-44bb-b974-d687a45de5a7",
        "parentId" : "6cf87745-31c3-4dd0-a47c-0b5b857791f8",
        "authorId" : "0f96d83b-618e-4d06-9aeb-e1d46fa92077",
        "body" : "üëç",
        "createdAt" : "2018-10-24T12:57:37Z",
        "updatedAt" : "2018-10-29T09:48:08Z",
        "lastEditedBy" : "0f96d83b-618e-4d06-9aeb-e1d46fa92077",
        "tags" : [
        ]
      }
    ],
    "commit" : "dfad1486a8fbc86bf304215f73fa5cd2c25df52d",
    "line" : 45,
    "diffHunk" : "@@ -1,1 +43,47 @@        A <type-name> _                // nonnull array type-name\n        X <name>                       // nonnull exact class type-name\n        <name>                         // nonnull class type-name\n\n    <nullable-type-name> ::="
  },
  {
    "id" : "57f63411-6caf-4374-a18b-47d4f3b549cd",
    "prId" : 1372,
    "prUrl" : "https://github.com/scala-native/scala-native/pull/1372#pullrequestreview-167892329",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a9e2c740-ed4a-49d8-8c68-054f2ec6123c",
        "parentId" : null,
        "authorId" : "d1cbb5a4-1605-48d2-8efe-eeb6295c931f",
        "body" : "This should be `A <type-name> <number> E` according to the code.",
        "createdAt" : "2018-10-23T21:26:33Z",
        "updatedAt" : "2018-10-29T09:48:08Z",
        "lastEditedBy" : "d1cbb5a4-1605-48d2-8efe-eeb6295c931f",
        "tags" : [
        ]
      },
      {
        "id" : "23486bee-75b5-427c-a038-adc9a3a96ab1",
        "parentId" : "a9e2c740-ed4a-49d8-8c68-054f2ec6123c",
        "authorId" : "0f96d83b-618e-4d06-9aeb-e1d46fa92077",
        "body" : "Actually, we should rather fix the code. We've used `E` only after the variable-length number of elements as end terminator so far. It should probably stay this way.",
        "createdAt" : "2018-10-24T12:59:11Z",
        "updatedAt" : "2018-10-29T09:48:08Z",
        "lastEditedBy" : "0f96d83b-618e-4d06-9aeb-e1d46fa92077",
        "tags" : [
        ]
      }
    ],
    "commit" : "dfad1486a8fbc86bf304215f73fa5cd2c25df52d",
    "line" : 32,
    "diffHunk" : "@@ -1,1 +30,34 @@        R <type-name>+ E               // c function type-name\n        S <type-name>+ E               // c anonymous struct type-name\n        A <type-name> <number> _       // c array type-name\n        U <integer-type-name>          // unsigned integer type-name\n        <integer-type-name>            // signed integer type-name"
  }
]
[
  {
    "id" : "5c0f7149-8bd4-4679-b14f-ca8f81334438",
    "prId" : 54340,
    "prUrl" : "https://github.com/ansible/ansible/pull/54340#pullrequestreview-226675978",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f11ed889-35a5-4cf2-8490-959a8aa9164f",
        "parentId" : null,
        "authorId" : "a592774c-8568-4229-8c0e-31fbe6d00e14",
        "body" : "This particular example uses a `POST` method so it will contain body, probably represented by data. What happens with a `GET` request?",
        "createdAt" : "2019-04-06T17:26:00Z",
        "updatedAt" : "2019-04-22T15:24:14Z",
        "lastEditedBy" : "a592774c-8568-4229-8c0e-31fbe6d00e14",
        "tags" : [
        ]
      },
      {
        "id" : "340f0057-b0db-476f-8b6a-5a47f9be0af0",
        "parentId" : "f11ed889-35a5-4cf2-8490-959a8aa9164f",
        "authorId" : "fc84e3a8-7a8a-45ea-ba68-7e6e0b604075",
        "body" : "This example defaults to `POST`, but could just as easily be called with `GET` (or `PATCH`, or `PUT`, or `DELETE`), The point is that this method should take whatever information it needs from a module or module_utils and turns that into a valid request for the API it follows. That could involve packing `data` into a JSON payload, or ignoring it if it sees that `method` is `'GET'`, or even just passing it through as shown and trusting whatever calls it to give it the right format. What happens in any case is up to the needs of your plugin, which is why it isn't implemented in the base class.",
        "createdAt" : "2019-04-15T13:41:39Z",
        "updatedAt" : "2019-04-22T15:24:14Z",
        "lastEditedBy" : "fc84e3a8-7a8a-45ea-ba68-7e6e0b604075",
        "tags" : [
        ]
      },
      {
        "id" : "0e1e055e-b4f1-4ece-b95d-b1e99429930d",
        "parentId" : "f11ed889-35a5-4cf2-8490-959a8aa9164f",
        "authorId" : "a592774c-8568-4229-8c0e-31fbe6d00e14",
        "body" : "So this could be a valid implementation? I'm just swagging it, not sure it works...\r\n```\r\ndef send_request(self, data, path, method='POST'):\r\n    if method == 'POST':\r\n        response, response_content = self.connection.send(path, data, method=method, headers=headers)\r\n    elif method == 'GET':\r\n        response, response_content = self.connection.send(path, None, method=method, headers=headers)\r\n```",
        "createdAt" : "2019-04-15T14:13:29Z",
        "updatedAt" : "2019-04-22T15:24:14Z",
        "lastEditedBy" : "a592774c-8568-4229-8c0e-31fbe6d00e14",
        "tags" : [
        ]
      },
      {
        "id" : "c5a1acdf-2bf4-4eca-89e7-f97f2f2e131f",
        "parentId" : "f11ed889-35a5-4cf2-8490-959a8aa9164f",
        "authorId" : "fc84e3a8-7a8a-45ea-ba68-7e6e0b604075",
        "body" : "I would probably do\r\n\r\n```\r\nif method == 'GET':\r\n    data = None\r\nresponse, response_content = self.connection.send(path, data, method=method, headers=headers)\r\n```\r\n\r\nUnless you had some other reason to separate the `send()` calls, but that would work as well.",
        "createdAt" : "2019-04-15T14:21:16Z",
        "updatedAt" : "2019-04-22T15:24:14Z",
        "lastEditedBy" : "fc84e3a8-7a8a-45ea-ba68-7e6e0b604075",
        "tags" : [
        ]
      }
    ],
    "commit" : "d687ad37bed8bd85e40642f3b2007c9159fc51ca",
    "line" : 57,
    "diffHunk" : "@@ -1,1 +55,59 @@       headers = {'Content-Type': 'application/json'}\n       try:\n           response, response_content = self.connection.send(path, data, method=method, headers=headers)\n       except HTTPError as exc:\n           return exc.code, exc.read()"
  },
  {
    "id" : "0a6b8b0a-4fc0-4fa5-861c-cab729af06bf",
    "prId" : 54340,
    "prUrl" : "https://github.com/ansible/ansible/pull/54340#pullrequestreview-226672342",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b1fde5e2-8388-43b6-b0f3-b6e32c1c396a",
        "parentId" : null,
        "authorId" : "a592774c-8568-4229-8c0e-31fbe6d00e14",
        "body" : "Based solely on this paragraph, it's not clear to me how to structure calls which use a static header token and don't need any login or logout calls. The paragraph opens with \"By default...\" so by just reading this paragraph, I'm concerned I will need to disable that.",
        "createdAt" : "2019-04-06T17:29:57Z",
        "updatedAt" : "2019-04-22T15:24:14Z",
        "lastEditedBy" : "a592774c-8568-4229-8c0e-31fbe6d00e14",
        "tags" : [
        ]
      },
      {
        "id" : "818b8399-b4e0-4257-ae4c-e1a395444b5d",
        "parentId" : "b1fde5e2-8388-43b6-b0f3-b6e32c1c396a",
        "authorId" : "fc84e3a8-7a8a-45ea-ba68-7e6e0b604075",
        "body" : "I'm not entirely following your question. This is the section that deals with not having login or logout calls. If your header token is already known beforehand and there is no other authentication, then you would have to take some other approach not listed here (probably adding the token as a plugin option, and setting `self.connection._auth` to use the value of that option in `__init__` similar to how the `login()` example does it below)",
        "createdAt" : "2019-04-15T13:52:08Z",
        "updatedAt" : "2019-04-22T15:24:14Z",
        "lastEditedBy" : "fc84e3a8-7a8a-45ea-ba68-7e6e0b604075",
        "tags" : [
        ]
      },
      {
        "id" : "20bf1ecd-075b-4e92-b4ad-039119b4551a",
        "parentId" : "b1fde5e2-8388-43b6-b0f3-b6e32c1c396a",
        "authorId" : "a592774c-8568-4229-8c0e-31fbe6d00e14",
        "body" : "I think that makes sense. I'll need to test my implementation out a little more thoroughly to be sure, but it does mostly answer my question. I wouldn't mind seeing a note stating this as such though.",
        "createdAt" : "2019-04-15T14:15:30Z",
        "updatedAt" : "2019-04-22T15:24:14Z",
        "lastEditedBy" : "a592774c-8568-4229-8c0e-31fbe6d00e14",
        "tags" : [
        ]
      }
    ],
    "commit" : "d687ad37bed8bd85e40642f3b2007c9159fc51ca",
    "line" : 69,
    "diffHunk" : "@@ -1,1 +67,71 @@--------------\n\nBy default, all requests will authenticate with HTTP Basic authentication. If a request can return some kind of token to stand in place of HTTP Basic, the ``update_auth(self, response, response_text)`` method should be implemented to inspect responses for such tokens. If the token is meant to be included with the headers of each request, it is sufficient to return a dictionary which will be merged with the computed headers for each request. The default implementation of this method does exactly this for cookies. If the token is used in another way, say in a query string, you should instead save that token to an instance variable, where the ``send_request()`` method (above) can add it to each request\n\n.. code-block:: python"
  },
  {
    "id" : "32c7f19d-e508-4284-bcb5-e9ff1ac66f2b",
    "prId" : 54340,
    "prUrl" : "https://github.com/ansible/ansible/pull/54340#pullrequestreview-223563433",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d946f4da-6c70-42bb-bdef-19ea99b76016",
        "parentId" : null,
        "authorId" : "a592774c-8568-4229-8c0e-31fbe6d00e14",
        "body" : "Documentation isn't showing where `HTTPError` is imported from.",
        "createdAt" : "2019-04-07T02:59:34Z",
        "updatedAt" : "2019-04-22T15:24:14Z",
        "lastEditedBy" : "a592774c-8568-4229-8c0e-31fbe6d00e14",
        "tags" : [
        ]
      }
    ],
    "commit" : "d687ad37bed8bd85e40642f3b2007c9159fc51ca",
    "line" : 58,
    "diffHunk" : "@@ -1,1 +56,60 @@       try:\n           response, response_content = self.connection.send(path, data, method=method, headers=headers)\n       except HTTPError as exc:\n           return exc.code, exc.read()\n"
  },
  {
    "id" : "cd032326-675b-431c-8b9e-8332e6b6c011",
    "prId" : 54340,
    "prUrl" : "https://github.com/ansible/ansible/pull/54340#pullrequestreview-223945389",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "95e40223-e8bf-4601-81a8-401301f21ac1",
        "parentId" : null,
        "authorId" : "a592774c-8568-4229-8c0e-31fbe6d00e14",
        "body" : "A paragraph explaining how `Connection` knows about the proper plugin could be helpful to someone newer to the framework. I'll include a proposal.",
        "createdAt" : "2019-04-08T16:13:30Z",
        "updatedAt" : "2019-04-22T15:24:14Z",
        "lastEditedBy" : "a592774c-8568-4229-8c0e-31fbe6d00e14",
        "tags" : [
        ]
      }
    ],
    "commit" : "d687ad37bed8bd85e40642f3b2007c9159fc51ca",
    "line" : 19,
    "diffHunk" : "@@ -1,1 +17,21 @@proxy object just as other connection methods can. The following is a very simple example of using\nsuch a call in a module_utils file so it may be shared with other modules.\n\n.. code-block:: python\n"
  },
  {
    "id" : "15d84ae0-2fe9-4964-b20d-ed645194b327",
    "prId" : 54340,
    "prUrl" : "https://github.com/ansible/ansible/pull/54340#pullrequestreview-226690212",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bc49427a-a7a8-4418-91b8-18c2666e346b",
        "parentId" : null,
        "authorId" : "a592774c-8568-4229-8c0e-31fbe6d00e14",
        "body" : "```suggestion\r\nBecause the httpapi architecture uses plugins, modules do not refer directly to their httpapi implemention for requests. Instead, they reference `Connection`, as shown below. `Connection` uses the host's `ansible_network_os` value to determine which plugin implementation to execute for a host.\r\n```",
        "createdAt" : "2019-04-08T16:15:20Z",
        "updatedAt" : "2019-04-22T15:24:14Z",
        "lastEditedBy" : "a592774c-8568-4229-8c0e-31fbe6d00e14",
        "tags" : [
        ]
      },
      {
        "id" : "357f838e-8cd4-4388-8475-8c3e7d709092",
        "parentId" : "bc49427a-a7a8-4418-91b8-18c2666e346b",
        "authorId" : "fc84e3a8-7a8a-45ea-ba68-7e6e0b604075",
        "body" : "I've gone a slight;y different direction, first to hopefully make clearer that this section does is about _module_ code, and not plugins, and second because this document is not specifically about `httpapi`, though that is where we are focusing the most attention right now.",
        "createdAt" : "2019-04-15T14:27:54Z",
        "updatedAt" : "2019-04-22T15:24:14Z",
        "lastEditedBy" : "fc84e3a8-7a8a-45ea-ba68-7e6e0b604075",
        "tags" : [
        ]
      },
      {
        "id" : "a6666ff5-d311-4f68-95eb-5f658b9473cf",
        "parentId" : "bc49427a-a7a8-4418-91b8-18c2666e346b",
        "authorId" : "a592774c-8568-4229-8c0e-31fbe6d00e14",
        "body" : "I saw the commit you pushed and it was clear. Thank you!",
        "createdAt" : "2019-04-15T14:42:35Z",
        "updatedAt" : "2019-04-22T15:24:14Z",
        "lastEditedBy" : "a592774c-8568-4229-8c0e-31fbe6d00e14",
        "tags" : [
        ]
      }
    ],
    "commit" : "d687ad37bed8bd85e40642f3b2007c9159fc51ca",
    "line" : 19,
    "diffHunk" : "@@ -1,1 +17,21 @@proxy object just as other connection methods can. The following is a very simple example of using\nsuch a call in a module_utils file so it may be shared with other modules.\n\n.. code-block:: python\n"
  },
  {
    "id" : "cae0c49d-9334-4925-954d-92d38186030a",
    "prId" : 54340,
    "prUrl" : "https://github.com/ansible/ansible/pull/54340#pullrequestreview-223945389",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "37c6a625-edcc-4351-a059-7026739783f0",
        "parentId" : null,
        "authorId" : "a592774c-8568-4229-8c0e-31fbe6d00e14",
        "body" : "Would it make sense to include a reference example implementation that is bare bones and can be used a good start? The examples here are good, but it doesn't demonstrate everything end-to-end.",
        "createdAt" : "2019-04-08T16:16:48Z",
        "updatedAt" : "2019-04-22T15:24:14Z",
        "lastEditedBy" : "a592774c-8568-4229-8c0e-31fbe6d00e14",
        "tags" : [
        ]
      }
    ],
    "commit" : "d687ad37bed8bd85e40642f3b2007c9159fc51ca",
    "line" : 1,
    "diffHunk" : "@@ -1,1 +-1,3 @@\n.. _developing_modules_network:\n.. _developing_plugins_network:"
  }
]
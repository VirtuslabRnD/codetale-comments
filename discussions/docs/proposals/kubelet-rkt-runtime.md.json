[
  {
    "id" : "d3620ac7-6494-454b-b720-fec5ccba94a4",
    "prId" : 33704,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/33704#pullrequestreview-2059426",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "07429099-8ad8-4330-95a5-57c42598f238",
        "parentId" : null,
        "authorId" : "a6409368-42e0-44a9-bf79-9d3042ac3b65",
        "body" : "I buy this reason. Also I am ok with keeping rkt in-process with kubelet. But at least we should integrate with kubelet through gRPC client, not through kuberuntime directly. \n",
        "createdAt" : "2016-09-29T01:26:06Z",
        "updatedAt" : "2016-10-11T02:09:21Z",
        "lastEditedBy" : "a6409368-42e0-44a9-bf79-9d3042ac3b65",
        "tags" : [
        ]
      }
    ],
    "commit" : "f8682ac1bb9302775f24a1bb1929e02b0ee33cd7",
    "line" : 74,
    "diffHunk" : "@@ -1,1 +72,76 @@### Remain in-process with Kubelet\n\nThe current rkt container runtime integration is able to be deployed simply by deploying the kubelet binary.\n\nThis is, in no small part, to make it *Easy to Deploy*."
  },
  {
    "id" : "c99db2a9-31fa-4b43-8a27-61d8da6fb35b",
    "prId" : 33704,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/33704#pullrequestreview-2197821",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "07271513-f2cf-406b-8683-67669667029f",
        "parentId" : null,
        "authorId" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "body" : "A shim can be run in-process with kubelet, but still communicate with the rest of the components over grpc. It seems like these are two different topics being bundled together here.\n\nFor _not going over grpc_, I'm interested in seeing a measurement on the performance overhead and see whether it's acceptable or not. It'd also be good to know what the basis for performance comparison is in this context -- is it the existing rktnetes integration, or the default docker integration?\n\n/cc @thockin \n",
        "createdAt" : "2016-09-29T01:50:58Z",
        "updatedAt" : "2016-10-11T02:09:21Z",
        "lastEditedBy" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "tags" : [
        ]
      },
      {
        "id" : "7c4c1c77-cb85-445e-82f1-ec01feb80b19",
        "parentId" : "07271513-f2cf-406b-8683-67669667029f",
        "authorId" : "2fa5a4c6-e0a7-4dbe-a80e-7770a5dc92a1",
        "body" : "I don't think `not grpc` is mentioned anywhere, and so long as there's a reasonable way to do in-process grpc, I think that's a good path. The current rktlet implementation is designed with that expectation already.\n\nMy bigger concerns related to in/out-of-process are memory / io overhead for having two processes, two go runtimes, two logging setups, and more failure modes.\n\nThe basis is the existing integration, but we're also going to be comparing against other implementations as well naturally.\nUnfortunately, we don't have data to backup any performance concerns.\n",
        "createdAt" : "2016-09-29T18:12:09Z",
        "updatedAt" : "2016-10-11T02:09:21Z",
        "lastEditedBy" : "2fa5a4c6-e0a7-4dbe-a80e-7770a5dc92a1",
        "tags" : [
        ]
      }
    ],
    "commit" : "f8682ac1bb9302775f24a1bb1929e02b0ee33cd7",
    "line" : null,
    "diffHunk" : "@@ -1,1 +76,80 @@This is, in no small part, to make it *Easy to Deploy*.\n\nRemaining in-process also helps this integration not regress on performance, one axis of being *Full-Featured*.\n\n### Communicate through gRPC"
  }
]
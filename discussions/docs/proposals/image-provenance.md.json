[
  {
    "id" : "b940ee7d-ace2-4085-9966-8125b906abeb",
    "prId" : 27129,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "01597227-927c-4010-87da-1ede8943d91d",
        "parentId" : null,
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Do we need to know the authenticated user / service account that is attempting to perform this action?  Who can matter as much as what in this case.\n",
        "createdAt" : "2016-06-09T18:08:12Z",
        "updatedAt" : "2016-08-05T19:50:55Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "1ecf1bd4-5bc9-4f09-8825-329a4035b9e4",
        "parentId" : "01597227-927c-4010-87da-1ede8943d91d",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Nm, saw the comment below.  Commented there.\n",
        "createdAt" : "2016-06-09T19:16:21Z",
        "updatedAt" : "2016-08-05T19:50:55Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      }
    ],
    "commit" : "9d59ae547fdfdf8b09cc30898ac9762fb02f833b",
    "line" : null,
    "diffHunk" : "@@ -1,1 +122,126 @@ \n// ImageReviewSpec is a description of the pod creation request.\ntype ImageReviewSpec struct {\n\t// Containers is a list of a subset of the information in each container of the Pod being created.\n\tContainers []ImageReviewContainerSpec"
  },
  {
    "id" : "68907daa-9c7b-4f9e-a137-d85e18645b2a",
    "prId" : 27129,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "707464d3-a9d5-445b-bba1-d9646735c7fa",
        "parentId" : null,
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "I'm starting to feel like we're not doing enough to actually solve the usability problem here - the approach you describe is correct (RS needs to surface that info) but we're doing a terrible job of it.  For instance... should RS have a condition \"CreationForbidden\": \"true\" with a reason \"ImageRejected\"?  Should the deployment also have a condition surfaced?\n\nRight now, we see this all the time in OpenShift (by virtue of security policy) and end users really suffer without this info being surfaced (in quota, in policy, and in crash looping pods).\n",
        "createdAt" : "2016-06-09T18:11:14Z",
        "updatedAt" : "2016-08-05T19:50:55Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "bd36eae5-83b3-45e4-8fbd-6eca0ee1c0b5",
        "parentId" : "707464d3-a9d5-445b-bba1-d9646735c7fa",
        "authorId" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "body" : "Yes.  https://github.com/kubernetes/kubernetes/issues/22298\n",
        "createdAt" : "2016-06-09T22:44:43Z",
        "updatedAt" : "2016-08-05T19:50:55Z",
        "lastEditedBy" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "tags" : [
        ]
      },
      {
        "id" : "b1730868-efd0-4325-8bdc-f5b61217a96e",
        "parentId" : "707464d3-a9d5-445b-bba1-d9646735c7fa",
        "authorId" : "11efe503-096f-46dd-a8c8-28ba38a0157a",
        "body" : "> I'm starting to feel like we're not doing enough to actually solve the usability problem here - the approach you describe is correct (RS needs to surface that info) but we're doing a terrible job of it. For instance... should RS have a condition \"CreationForbidden\": \"true\" with a reason \"ImageRejected\"? Should the deployment also have a condition surfaced?\n> \n> Right now, we see this all the time in OpenShift (by virtue of security policy) and end users really suffer without this info being surfaced (in quota, in policy, and in crash looping pods).\n\nConditions are one thing that may or may not help here but I believe we already have a mechanism for reporting failures, albeit we are doing a bad job with it: events. Events are nice but fetching exactly those you are interested in is impossible currently. It feels like we should have events as a subresource to all objects or something. https://github.com/kubernetes/kubernetes/issues/11994 is related.\n",
        "createdAt" : "2016-06-09T23:56:14Z",
        "updatedAt" : "2016-08-05T19:50:55Z",
        "lastEditedBy" : "11efe503-096f-46dd-a8c8-28ba38a0157a",
        "tags" : [
        ]
      },
      {
        "id" : "14c5b78c-35fd-4dcf-8091-f757477f048b",
        "parentId" : "707464d3-a9d5-445b-bba1-d9646735c7fa",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Found your answer later in the issue.  I'm forgetting which proposals I've commented on at this point.\n",
        "createdAt" : "2016-06-10T04:36:04Z",
        "updatedAt" : "2016-08-05T19:50:55Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "508735f3-3f1a-43b2-a07e-54a73720ca13",
        "parentId" : "707464d3-a9d5-445b-bba1-d9646735c7fa",
        "authorId" : "b7d2a698-a6e1-4031-bb69-8b45505badb5",
        "body" : "I'd like to generalize this paragraph to be applicable to all controllers. Deplyments and ReplicaSets are not the only ones currently. But I agree with Clayton and Michalis here that we need to make it more obvious and Conditions are one of the possibilities here.\n",
        "createdAt" : "2016-07-20T16:37:37Z",
        "updatedAt" : "2016-08-05T19:50:55Z",
        "lastEditedBy" : "b7d2a698-a6e1-4031-bb69-8b45505badb5",
        "tags" : [
        ]
      },
      {
        "id" : "7d2f9e25-0839-4520-a317-2208d7eb62ac",
        "parentId" : "707464d3-a9d5-445b-bba1-d9646735c7fa",
        "authorId" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "body" : "Linked this discussion from #22298\n",
        "createdAt" : "2016-07-22T22:29:48Z",
        "updatedAt" : "2016-08-05T19:50:55Z",
        "lastEditedBy" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "tags" : [
        ]
      }
    ],
    "commit" : "9d59ae547fdfdf8b09cc30898ac9762fb02f833b",
    "line" : 181,
    "diffHunk" : "@@ -1,1 +179,183 @@The ReplicaSet, or other controller, is responsible for recognizing when a 403 has happened\n(whether due to user not having permission due to bad image, or some other permission reason)\nand throttling itself and surfacing the error in a way that CLIs and UIs can show to the user.\n\nIssue [22298](https://github.com/kubernetes/kubernetes/issues/22298) needs to be resolved to"
  },
  {
    "id" : "28e75624-f89f-4821-9fd1-6ddb52d6eaae",
    "prId" : 27129,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "411b2ecf-251b-4857-8f19-7b7f6b421f44",
        "parentId" : null,
        "authorId" : "dabe34ec-22c8-4948-a579-d661cdc42761",
        "body" : "Is the intent to synchronize the admission caches in the federated/ubernetes cases?\n",
        "createdAt" : "2016-06-09T20:40:38Z",
        "updatedAt" : "2016-08-05T19:50:55Z",
        "lastEditedBy" : "dabe34ec-22c8-4948-a579-d661cdc42761",
        "tags" : [
        ]
      },
      {
        "id" : "4fb1958a-2676-4ca9-b25f-04713d57cd60",
        "parentId" : "411b2ecf-251b-4857-8f19-7b7f6b421f44",
        "authorId" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "body" : "no.\n",
        "createdAt" : "2016-06-09T22:57:16Z",
        "updatedAt" : "2016-08-05T19:50:55Z",
        "lastEditedBy" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "tags" : [
        ]
      }
    ],
    "commit" : "9d59ae547fdfdf8b09cc30898ac9762fb02f833b",
    "line" : 213,
    "diffHunk" : "@@ -1,1 +211,215 @@## Ubernetes\n\nIf two clusters share an image policy backend, then they will have the same policies.\n\nThe clusters can pass different tokens to the backend, and the backend can use this to distinguish"
  },
  {
    "id" : "3dfd0a51-50d1-4fed-adbd-409e3156cce3",
    "prId" : 27129,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "cd982be7-e31f-4885-a20c-18f8ef561d81",
        "parentId" : null,
        "authorId" : "dabe34ec-22c8-4948-a579-d661cdc42761",
        "body" : "Always forcing users to resolve IDs would allow backends to interact more effectively with content trust measures. With just the tag, there's no binding between what was actually deployed and what the backend sees. cc @ecordell\n",
        "createdAt" : "2016-06-09T20:53:14Z",
        "updatedAt" : "2016-08-05T19:50:55Z",
        "lastEditedBy" : "dabe34ec-22c8-4948-a579-d661cdc42761",
        "tags" : [
        ]
      },
      {
        "id" : "f1f6dd1e-620d-42c0-83b5-2d614cad57f1",
        "parentId" : "cd982be7-e31f-4885-a20c-18f8ef561d81",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Resolving IDs before they are put into pods / deployments / rcs is the best\noutcome.  Doing that resolution in the admission control is fraught (there\nshould be another admission controller that does the transformation, if you\nreally want that)\n\nOn Thu, Jun 9, 2016 at 4:53 PM, George Tankersley notifications@github.com\nwrote:\n\n> In docs/proposals/image-provenance.md\n> https://github.com/kubernetes/kubernetes/pull/27129#discussion_r66519606\n> :\n> \n> > +## Image tags and IDs\n> > +\n> > +Image tags are like: `myrepo/myimage:v1`.\n> > +\n> > +Image IDs are like: `myrepo/myimage@sha256:beb6bd6a68f114c1dc2ea4b28db81bdf91de202a9014972bec5e4d9171d90ed`.\n> > +You can see image IDs with `docker images --no-trunc`.\n> > +\n> > +The Backend needs to be able to resolve tags to IDs (by talking to the images repo).\n> > +If the Backend resolves tags to IDs, there is some risk that the tag-to-ID mapping will be\n> > +modified after approval by the Backend, but before Kubelet pulls the image.  We will not address this\n> > +race condition at this time.\n> > +\n> > +We will wait and see how much demand there is for closing this hole. If the community demands a solution,\n> > +we may suggest one of these:\n> > +\n> > +1.  Use a backend that refuses to accept images that are specified with tags, and require users to resolve to IDs\n> \n> Forcing users to resolve IDs would allow a backend to interact more\n> effectively with content trust measures. With just the tag, there's no\n> binding between what was actually deployed and what the backend sees. You\n> need to somehow supply an account of the data. cc @ecordell\n> https://github.com/ecordell\n> \n> â€”\n> You are receiving this because you commented.\n> Reply to this email directly, view it on GitHub\n> https://github.com/kubernetes/kubernetes/pull/27129/files/790ab4954039f8d601b925896c01962face3765f#r66519606,\n> or mute the thread\n> https://github.com/notifications/unsubscribe/ABG_pykCE46gTf8z3jGttIEODyKkW9UPks5qKH1LgaJpZM4IyI6J\n> .\n",
        "createdAt" : "2016-06-09T20:59:41Z",
        "updatedAt" : "2016-08-05T19:50:55Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "57889bff-799c-42c9-80c6-4c42a7613f73",
        "parentId" : "cd982be7-e31f-4885-a20c-18f8ef561d81",
        "authorId" : "8a10a1b5-308d-4339-9079-66fe95555a6b",
        "body" : "Agreed; any signature verification doesn't mean much if you don't verify that the image id matches the content\n",
        "createdAt" : "2016-06-09T21:06:37Z",
        "updatedAt" : "2016-08-05T19:50:55Z",
        "lastEditedBy" : "8a10a1b5-308d-4339-9079-66fe95555a6b",
        "tags" : [
        ]
      },
      {
        "id" : "b18c2c86-81a7-4090-bfe0-45f32f576824",
        "parentId" : "cd982be7-e31f-4885-a20c-18f8ef561d81",
        "authorId" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "body" : "I just commented on this in https://github.com/kubernetes/kubernetes/pull/27129/files/4a60be831efce93d7e210df47d79e7c18d5d13c2#r71607506\n\nI think it makes sense to either map tag to SHA in kubectl, in CICD, or after the fact in Kubelet.  I agree the admission controller is a bad place to map tag to SHA.  I think admission is a fine place to require image names that use SHAs.\n",
        "createdAt" : "2016-07-20T21:13:31Z",
        "updatedAt" : "2016-08-05T19:50:55Z",
        "lastEditedBy" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "tags" : [
        ]
      }
    ],
    "commit" : "9d59ae547fdfdf8b09cc30898ac9762fb02f833b",
    "line" : 233,
    "diffHunk" : "@@ -1,1 +231,235 @@we may suggest one of these:\n\n1.  Use a backend that refuses to accept images that are specified with tags, and require users to resolve to IDs\n    prior to creating a pod template.\n   - [kubectl could be modified to automate this process](https://github.com/kubernetes/kubernetes/issues/1697)"
  },
  {
    "id" : "30646f70-4260-4bcb-931b-b0eb8fafce69",
    "prId" : 27129,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a169db55-be7d-4581-b127-d291f05eb40f",
        "parentId" : null,
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "Is the webhook going to be tried until success? How would it distinguish retryable failure from permanent failure?\n",
        "createdAt" : "2016-06-22T19:44:36Z",
        "updatedAt" : "2016-08-05T19:50:55Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "659ada53-8fdd-4e6c-b6e5-e3fb4fd8060c",
        "parentId" : "a169db55-be7d-4581-b127-d291f05eb40f",
        "authorId" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "body" : "The admission controller will admit if the webhook times out.\n",
        "createdAt" : "2016-07-23T00:23:02Z",
        "updatedAt" : "2016-08-05T19:50:55Z",
        "lastEditedBy" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "tags" : [
        ]
      },
      {
        "id" : "c93f30a7-a552-4222-bb88-010f00a535b9",
        "parentId" : "a169db55-be7d-4581-b127-d291f05eb40f",
        "authorId" : "6c7e5fb3-9a32-484a-be21-c70b4d00de52",
        "body" : "Will the admin be able to set a policy for a namespace (e.g., fail-open/fail-closed)?\n",
        "createdAt" : "2016-07-23T01:34:30Z",
        "updatedAt" : "2016-08-05T19:50:55Z",
        "lastEditedBy" : "6c7e5fb3-9a32-484a-be21-c70b4d00de52",
        "tags" : [
        ]
      },
      {
        "id" : "7646167d-b9ae-42af-9060-4bd0cb6faf02",
        "parentId" : "a169db55-be7d-4581-b127-d291f05eb40f",
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "Will this be a generic webhook for any admission plugin?  I'd like to see a generic one and it seems like the work here would be about the same.\n",
        "createdAt" : "2016-07-25T18:26:48Z",
        "updatedAt" : "2016-08-05T19:50:55Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      },
      {
        "id" : "8788e132-36b1-4fd3-976b-015eafd2c236",
        "parentId" : "a169db55-be7d-4581-b127-d291f05eb40f",
        "authorId" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "body" : "It will not be a generic webhook.  A generic webhook would need a lot more discussion:\n- a generic webhook needs to touch all objects, not just pods.  So it won't have a fixed schema\n- a generic webhook client needs to ignore kinds it doesn't care about, or the apiserver needs to know which backends care about which kinds\n- it exposes our whole API to a webhook without giving us (the project) any chance to review or understand how it is being used.\n- because we don't know which fields of an object are inspected by the backend, caching is not effective.  Sending fewer fields allows caching.\n- sending fewer fields makes it possible to rev the version of the webhook request slower than the version of our internal obejcts (e.g. pod v2 could still use imageReview v1.)\n- probably lots more reasons.\n",
        "createdAt" : "2016-07-25T22:29:24Z",
        "updatedAt" : "2016-08-05T19:50:55Z",
        "lastEditedBy" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "tags" : [
        ]
      },
      {
        "id" : "a555d8d2-c828-4f71-a6a9-dac7a667966a",
        "parentId" : "a169db55-be7d-4581-b127-d291f05eb40f",
        "authorId" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "body" : "Added section about this in Alternatives section.\n",
        "createdAt" : "2016-07-25T23:15:11Z",
        "updatedAt" : "2016-08-05T19:50:55Z",
        "lastEditedBy" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "tags" : [
        ]
      }
    ],
    "commit" : "9d59ae547fdfdf8b09cc30898ac9762fb02f833b",
    "line" : 76,
    "diffHunk" : "@@ -1,1 +74,78 @@## Admission controller\n\nAn `ImagePolicyWebhook` admission controller will be written.  The admission controller examines all pod objects which are\ncreated or updated.  It can either admit the pod, or reject it.  If it is rejected, the request sees a `403 FORBIDDEN`\n"
  },
  {
    "id" : "343e9a38-eded-41ea-a85d-f8eb23ff1bda",
    "prId" : 27129,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7aa5cf3c-17c6-4154-965b-25046852d464",
        "parentId" : null,
        "authorId" : "b7d2a698-a6e1-4031-bb69-8b45505badb5",
        "body" : "A good example here would be to ask the backend pick only a certain scanners, as well. \n",
        "createdAt" : "2016-07-20T16:28:10Z",
        "updatedAt" : "2016-08-05T19:50:55Z",
        "lastEditedBy" : "b7d2a698-a6e1-4031-bb69-8b45505badb5",
        "tags" : [
        ]
      },
      {
        "id" : "33b21068-c9c8-4b88-857e-de5321aa6474",
        "parentId" : "7aa5cf3c-17c6-4154-965b-25046852d464",
        "authorId" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "body" : "Can you elaborate on this?  \n",
        "createdAt" : "2016-07-25T22:30:15Z",
        "updatedAt" : "2016-08-05T19:50:55Z",
        "lastEditedBy" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "tags" : [
        ]
      }
    ],
    "commit" : "9d59ae547fdfdf8b09cc30898ac9762fb02f833b",
    "line" : 163,
    "diffHunk" : "@@ -1,1 +161,165 @@- request to \"break glass\" to override a policy, in case of emergency.\n- a ticket number from a ticket system that documents the break-glass request\n- provide a hint to the policy server as to the imageID of the image being provided, to save it a lookup\n\nIn any case, the annotations are provided by the user and are not validated by Kubernetes in any way.  In the future, if an annotation is determined to be widely"
  },
  {
    "id" : "837b12a0-60d4-4ca6-96fb-22303bccefa9",
    "prId" : 27129,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5148cf4d-1338-48e6-bff8-1a3f4213ee31",
        "parentId" : null,
        "authorId" : "b7d2a698-a6e1-4031-bb69-8b45505badb5",
        "body" : "I've noticed the formatting in go structs is not consistent, have a look at gh preview of this doc.\n",
        "createdAt" : "2016-07-20T16:29:11Z",
        "updatedAt" : "2016-08-05T19:50:55Z",
        "lastEditedBy" : "b7d2a698-a6e1-4031-bb69-8b45505badb5",
        "tags" : [
        ]
      }
    ],
    "commit" : "9d59ae547fdfdf8b09cc30898ac9762fb02f833b",
    "line" : null,
    "diffHunk" : "@@ -1,1 +147,151 @@\t// may truncate excessively long errors when displaying to the user.\n\tReason string\n}\n```\n"
  },
  {
    "id" : "93fd1302-48dc-48bd-8b25-9072d0a995b1",
    "prId" : 27129,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a4c2ec89-c348-4033-9093-8d30d5b75a36",
        "parentId" : null,
        "authorId" : "b7d2a698-a6e1-4031-bb69-8b45505badb5",
        "body" : "With changing policy there's also the question of what to do with currently running images? Should the cluster administrator be equipped with a tool to verify which are \"in danger\".\n",
        "createdAt" : "2016-07-20T16:44:14Z",
        "updatedAt" : "2016-08-05T19:50:55Z",
        "lastEditedBy" : "b7d2a698-a6e1-4031-bb69-8b45505badb5",
        "tags" : [
        ]
      },
      {
        "id" : "08885858-97ac-40a4-8e1b-eed5981b6711",
        "parentId" : "a4c2ec89-c348-4033-9093-8d30d5b75a36",
        "authorId" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "body" : "Good point.  The cluster admin can already list all the pods that are currently running.\n\nWhat the cluster admin can't easily do is map an image name with a tag to a SHA.\n\nTwo options:\n1. image provenance (or some simpler admission controller) always rejects non-SHA image names, and CI/CD is responsible for only using SHAs.  (Can use annotations or labels to store human-readable version tags, though this is sort of gross since it has to be a map from container name to tag).\n2. Kubelet could post the SHA to the status of the pod after pulling it.  Seems generally useful.  Want to file that as a separate issue?  \n\nOnce there is a list of \"active SHAs\" in the cluster, the the cluster admin or security team or security dashboard  can then join the active SHA list with the list of SHAs that are known to have vulnerabilities.  \n",
        "createdAt" : "2016-07-20T21:11:11Z",
        "updatedAt" : "2016-08-05T19:50:55Z",
        "lastEditedBy" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "tags" : [
        ]
      },
      {
        "id" : "01a62e98-9e26-4913-8f94-4fd07d8260c4",
        "parentId" : "a4c2ec89-c348-4033-9093-8d30d5b75a36",
        "authorId" : "b7d2a698-a6e1-4031-bb69-8b45505badb5",
        "body" : "Created https://github.com/kubernetes/kubernetes/issues/29448,\n",
        "createdAt" : "2016-07-22T11:56:57Z",
        "updatedAt" : "2016-08-05T19:50:55Z",
        "lastEditedBy" : "b7d2a698-a6e1-4031-bb69-8b45505badb5",
        "tags" : [
        ]
      },
      {
        "id" : "c3522064-2f9c-47af-ba8a-1b51cd3ae885",
        "parentId" : "a4c2ec89-c348-4033-9093-8d30d5b75a36",
        "authorId" : "b7d2a698-a6e1-4031-bb69-8b45505badb5",
        "body" : "Generally, I'd prefer not to force user to use image SHA, it's quite cumbersome from a user POF, he should be able to do it (and can these days) but should not be forced. Let's face it, everybody are lazy :wink: we prefer automation wherever that is possible.\n",
        "createdAt" : "2016-07-22T11:59:44Z",
        "updatedAt" : "2016-08-05T19:50:55Z",
        "lastEditedBy" : "b7d2a698-a6e1-4031-bb69-8b45505badb5",
        "tags" : [
        ]
      },
      {
        "id" : "99c720b4-108d-497b-8b1c-fdd04182fbb7",
        "parentId" : "a4c2ec89-c348-4033-9093-8d30d5b75a36",
        "authorId" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "body" : "Are you suggesting the apiserver map the tag to a SHA?\n",
        "createdAt" : "2016-07-25T22:31:37Z",
        "updatedAt" : "2016-08-05T19:50:55Z",
        "lastEditedBy" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "tags" : [
        ]
      }
    ],
    "commit" : "9d59ae547fdfdf8b09cc30898ac9762fb02f833b",
    "line" : 209,
    "diffHunk" : "@@ -1,1 +207,211 @@- never change a policy, unless some external process has ensured no active objects depend on the to-be-forbidden\n  images.\n- change a policy and assume that transition to new image happens faster than the existing pods decay.\n\n## Ubernetes"
  },
  {
    "id" : "143fba93-179b-4b9b-89b9-fade1d4338dd",
    "prId" : 27129,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f5dc4db4-b400-4365-b499-f97e56dbc5d0",
        "parentId" : null,
        "authorId" : "b7d2a698-a6e1-4031-bb69-8b45505badb5",
        "body" : "This definitely deserves a separate issue. I've started wondering if it would make sense to implement here OpenShift's ImageStreams but in a limited way, iow. in such a way that you could have a one-to-one mapping image to a specific image:tag which would then allow a user to specify if I care about this being a hard reference to a particular imageid at the point when that ImageStream got created or rather a following tag, iow. such that would be refreshed on every usage, which would mean it might be different each time. @smarterclayton wdyt?\n",
        "createdAt" : "2016-07-20T19:34:08Z",
        "updatedAt" : "2016-08-05T19:50:55Z",
        "lastEditedBy" : "b7d2a698-a6e1-4031-bb69-8b45505badb5",
        "tags" : [
        ]
      },
      {
        "id" : "313c292b-4054-4fa0-a842-1a657caaadaa",
        "parentId" : "f5dc4db4-b400-4365-b499-f97e56dbc5d0",
        "authorId" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "body" : "If you want to have a repo and build system that ensures immutability of the tags, then your image provenance backend can accept image specifiers that use tags.  \n",
        "createdAt" : "2016-07-23T00:27:10Z",
        "updatedAt" : "2016-08-05T19:50:55Z",
        "lastEditedBy" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "tags" : [
        ]
      }
    ],
    "commit" : "9d59ae547fdfdf8b09cc30898ac9762fb02f833b",
    "line" : 245,
    "diffHunk" : "@@ -1,1 +243,247 @@  and kubelet will enforce that both the imageID and image match the image pulled.\n\nSince this adds complexity and interacts with imagePullPolicy, we avoid adding the above feature initially.\n\n### Caching"
  },
  {
    "id" : "356b20f9-bd5c-4a96-8bc9-96c1ad4d6845",
    "prId" : 27129,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4bd33e45-3c18-4e40-ab14-706a1a4629a2",
        "parentId" : null,
        "authorId" : "b7d2a698-a6e1-4031-bb69-8b45505badb5",
        "body" : "Warning event accompanying such situation would be nice. \n",
        "createdAt" : "2016-07-20T19:35:17Z",
        "updatedAt" : "2016-08-05T19:50:55Z",
        "lastEditedBy" : "b7d2a698-a6e1-4031-bb69-8b45505badb5",
        "tags" : [
        ]
      }
    ],
    "commit" : "9d59ae547fdfdf8b09cc30898ac9762fb02f833b",
    "line" : 256,
    "diffHunk" : "@@ -1,1 +254,258 @@The ImageReviewSpec is used as the key to the cache.\n\nIn the case of a cache miss and timeout talking to the backend, the default is to allow Pod creation.\nKeeping services running is more important than a hypothetical threat from an un-verified image.\n"
  },
  {
    "id" : "b2eed16d-d373-4241-9d1a-59bbe72bc2aa",
    "prId" : 27129,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b3d38802-22d4-442d-bf20-6dd296f5a199",
        "parentId" : null,
        "authorId" : "b56795d9-0816-4d28-b233-275e1ee4baf1",
        "body" : "@erictune isn't the other obvious example images that are signed by a public key in a key list?\n",
        "createdAt" : "2016-07-23T02:04:20Z",
        "updatedAt" : "2016-08-05T19:50:55Z",
        "lastEditedBy" : "b56795d9-0816-4d28-b233-275e1ee4baf1",
        "tags" : [
        ]
      },
      {
        "id" : "0c4ed1fe-5f3a-4400-ac6a-e58514e9ee89",
        "parentId" : "b3d38802-22d4-442d-bf20-6dd296f5a199",
        "authorId" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "body" : "Yes.  I would do that in conjunction with other controls.  I might want to also enforce the whitelist of signing keys at the node level, at which point the check in the apiserver is more a nice-to-have.  But you could do it that way.\n",
        "createdAt" : "2016-07-25T22:07:49Z",
        "updatedAt" : "2016-08-05T19:50:55Z",
        "lastEditedBy" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "tags" : [
        ]
      },
      {
        "id" : "ef27e0cf-d695-4993-acdb-6f4cf0ba8af2",
        "parentId" : "b3d38802-22d4-442d-bf20-6dd296f5a199",
        "authorId" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "body" : "Adding your suggestion to the doc.\n",
        "createdAt" : "2016-07-25T22:34:04Z",
        "updatedAt" : "2016-08-05T19:50:55Z",
        "lastEditedBy" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "tags" : [
        ]
      }
    ],
    "commit" : "9d59ae547fdfdf8b09cc30898ac9762fb02f833b",
    "line" : null,
    "diffHunk" : "@@ -1,1 +38,42 @@ - only run images that use a \"required\" base image\n - only run images that contain binaries which were built from peer reviewed, checked-in source\n   by a trusted compiler toolchain.\n - only allow images signed by certain public keys.\n"
  },
  {
    "id" : "c3db6ee1-cea0-43d2-9c4f-b2242b728920",
    "prId" : 27129,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8441ede2-24d0-4418-b9e4-aa2ebeab7319",
        "parentId" : null,
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "I would like for the admission controller to take an interface for \"check decision\" rather than embedding all the client logic in it.  That would allow alternate admission controller implementations to be more easily implemented.  As an example, we're trying to build composable chunks of admission logic for policy like this that can be reused in other contexts.  Things like authorizer and authentication have succeeded pretty well at this (@liggitt has done some crazy authenticator wrappers that work cleanly).  I would like to generally have our policy decision steps behind clean interfaces (in this case, an interface that answers the question about an image and it being accepted and mirrors the ImageReview object) that can be composed later on.\n",
        "createdAt" : "2016-07-25T19:03:23Z",
        "updatedAt" : "2016-08-05T19:50:55Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "be221c83-8d3e-4824-b21b-9f7539436132",
        "parentId" : "8441ede2-24d0-4418-b9e4-aa2ebeab7319",
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "> I would like for the admission controller to take an interface for \"check decision\" rather than embedding all the client logic in it.\n\nYou're saying you don't like the webhook mechanism suggested, that you want a generic webhook like I asked above above, or that you want the reference webhook impl to accept what amounts to an admission.Interface?\n",
        "createdAt" : "2016-07-25T19:21:41Z",
        "updatedAt" : "2016-08-05T19:50:55Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      },
      {
        "id" : "cc49734a-928a-4891-8d1f-902c1e67c4d1",
        "parentId" : "8441ede2-24d0-4418-b9e4-aa2ebeab7319",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "On Jul 25, 2016, at 3:21 PM, David Eads notifications@github.com wrote:\n\nIn docs/proposals/image-provenance.md\nhttps://github.com/kubernetes/kubernetes/pull/27129#discussion_r72127227:\n\n> -    reduces latency and allows short outages of the backend to be tolerated.\n>   +\n>   +\n>   +Detailed discussion in [Ensuring only images are from approved sources are run](+https://github.com/kubernetes/kubernetes/issues/22888).\n>   +\n>   +# Implementation\n>   +\n>   +A new admission controller will be added.  That will be the only change.\n>   +\n>   +## Admission controller\n>   +\n>   +An `ImagePolicyWebhook` admission controller will be written.  The admission controller examines all pod objects which are\n>   +created or updated.  It can either admit the pod, or reject it.  If it is rejected, the request sees a `403 FORBIDDEN`\n>   +\n>   +The admission controller code will go in `plugin/pkg/admission/imagepolicy`.\n\nI would like for the admission controller to take an interface for \"check\ndecision\" rather than embedding all the client logic in it.\n\nYou're saying you don't like the webhook mechanism suggested, that you want\na generic webhook like I asked above above, or that you want the reference\nwebhook impl to accept what amounts to and admission.Interface?\n\nThe latter.  Authorizer and Admission interfaces are very successful.\nWould like to try to define the equivalents for other policy equally well.\n",
        "createdAt" : "2016-07-25T22:53:21Z",
        "updatedAt" : "2016-08-05T19:50:55Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      }
    ],
    "commit" : "9d59ae547fdfdf8b09cc30898ac9762fb02f833b",
    "line" : 79,
    "diffHunk" : "@@ -1,1 +77,81 @@created or updated.  It can either admit the pod, or reject it.  If it is rejected, the request sees a `403 FORBIDDEN`\n\nThe admission controller code will go in `plugin/pkg/admission/imagepolicy`.\n\nThere will be a cache of decisions in the admission controller."
  },
  {
    "id" : "031a7013-dd0d-4a56-b366-87ba36bb8af1",
    "prId" : 27129,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0f15ba1f-1cc9-4596-bf41-3df97c50439f",
        "parentId" : null,
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Unfortunately you also need to accept init containers.  I would recommend creating a nested struct that is similar to pod template that has the subset of info in it, and make that hierarchal rather than flattened, i.e.:\n\n```\ntype ImageReviewPodTemplate struct {\n  Metadata ImageReviewObjectMeta\n  Spec ImageReviewPodSpec\n}\n```\n\nIf we can preserve the same hierarchy as a `PodTemplate`, that makes automated tools easier in the future (we might take the pod object as unstructured and whitelist the things that are included in a generic fashion).\n",
        "createdAt" : "2016-07-25T19:05:12Z",
        "updatedAt" : "2016-08-05T19:50:55Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "f647b3d5-4dba-48e6-805b-c68bc24bb75d",
        "parentId" : "0f15ba1f-1cc9-4596-bf41-3df97c50439f",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "It also establishes a pattern for future examples of this where subsets of data are returned.\n",
        "createdAt" : "2016-07-25T19:06:02Z",
        "updatedAt" : "2016-08-05T19:50:55Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "5199d3b3-8ebf-4be0-8a49-cb1a989d1592",
        "parentId" : "0f15ba1f-1cc9-4596-bf41-3df97c50439f",
        "authorId" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "body" : "Is it settled where in the PodSpec that init containers will live? \n",
        "createdAt" : "2016-07-25T23:08:11Z",
        "updatedAt" : "2016-08-05T19:50:55Z",
        "lastEditedBy" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "tags" : [
        ]
      },
      {
        "id" : "3d6b5fa7-6b41-4bf0-b3cb-5a7d8966cb8f",
        "parentId" : "0f15ba1f-1cc9-4596-bf41-3df97c50439f",
        "authorId" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "body" : "Also, if we do what you said, it couples the versioning of Pods to the versioning of the ImageReview api.  Is that desirable?\n",
        "createdAt" : "2016-07-25T23:09:38Z",
        "updatedAt" : "2016-08-05T19:50:55Z",
        "lastEditedBy" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "tags" : [
        ]
      },
      {
        "id" : "ea1f5c65-bdcc-4cd8-8c06-b18634d87f09",
        "parentId" : "0f15ba1f-1cc9-4596-bf41-3df97c50439f",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "If is extremely likely init containers will be a peer to containers,\nbarring any sudden revelations.\n",
        "createdAt" : "2016-07-26T00:54:21Z",
        "updatedAt" : "2016-08-05T19:50:55Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "03a9c778-2c53-4ac0-85e9-b7847350d29d",
        "parentId" : "0f15ba1f-1cc9-4596-bf41-3df97c50439f",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Possibly not, although creating a new structure to learn _is_ causing\nAPI drift.  I would expect this API to evolve to be consistent with\npods in the long term (v1 pods to vX ImagePolicyReview)\n",
        "createdAt" : "2016-07-26T00:55:37Z",
        "updatedAt" : "2016-08-05T19:50:55Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "6c8620ee-217e-47c8-b0fb-96b61e6ffb98",
        "parentId" : "0f15ba1f-1cc9-4596-bf41-3df97c50439f",
        "authorId" : "6c7e5fb3-9a32-484a-be21-c70b4d00de52",
        "body" : "I'm of the opinion that instead of mimicking pod layout, we should eliminate the container list altogether. The goal here is to establish a chain of trust for containers, and not to enforce pod-level policies. If you create a pod with 5 containers, then you make 5 requests to the backend.\n",
        "createdAt" : "2016-08-04T01:21:16Z",
        "updatedAt" : "2016-08-05T19:50:55Z",
        "lastEditedBy" : "6c7e5fb3-9a32-484a-be21-c70b4d00de52",
        "tags" : [
        ]
      },
      {
        "id" : "e53a6e80-da19-414f-9120-8af496897567",
        "parentId" : "0f15ba1f-1cc9-4596-bf41-3df97c50439f",
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "> I'm of the opinion that instead of mimicking pod layout, we should eliminate the container list altogether. The goal here is to establish a chain of trust for containers, and not to enforce pod-level policies. If you create a pod with 5 containers, then you make 5 requests to the backend.\n\nI think that it's likely we'll end up doing both.  Given the current power of PSP and it's ability to describe who can request which powers for a pod/container, it seems likely that the decision about whether a particular image is allowed may be affected by the same or a similar policy.\n\nI'm not suggesting that we add that level of complication now, but designing the structure for future expansion seems like a reasonable thing to do and this would be a way to do it.\n\nAlso, remote callouts are expensive and if we already have all the data ready, validating it all at once seems pretty reasonable.\n",
        "createdAt" : "2016-08-04T12:34:24Z",
        "updatedAt" : "2016-08-05T19:50:55Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      },
      {
        "id" : "abf429e1-4a8a-4ff9-a9ea-402229d8e794",
        "parentId" : "0f15ba1f-1cc9-4596-bf41-3df97c50439f",
        "authorId" : "6c7e5fb3-9a32-484a-be21-c70b4d00de52",
        "body" : "Exactly, we have PSP for pod level control. The purpose here is to establish a chain of trust from source code to deployment.\n\nA small scaling factor from pods to containers is nothing to bat an eye at.\n",
        "createdAt" : "2016-08-04T19:03:10Z",
        "updatedAt" : "2016-08-05T19:50:55Z",
        "lastEditedBy" : "6c7e5fb3-9a32-484a-be21-c70b4d00de52",
        "tags" : [
        ]
      }
    ],
    "commit" : "9d59ae547fdfdf8b09cc30898ac9762fb02f833b",
    "line" : 126,
    "diffHunk" : "@@ -1,1 +124,128 @@type ImageReviewSpec struct {\n\t// Containers is a list of a subset of the information in each container of the Pod being created.\n\tContainers []ImageReviewContainerSpec\n\t// Annotations is a list of key-value pairs extracted from the Pod's annotations.\n\t// It only includes keys which match the pattern `*.image-policy.k8s.io/*`."
  },
  {
    "id" : "d2464e68-986d-40d8-94dc-8afafc3c2b10",
    "prId" : 27129,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bf5bdb50-bd3a-4587-bfcd-6be2deb4940a",
        "parentId" : null,
        "authorId" : "b7d2a698-a6e1-4031-bb69-8b45505badb5",
        "body" : "Is the override be available to all users? Or this will be tied to specific authz?\n",
        "createdAt" : "2016-07-25T20:32:10Z",
        "updatedAt" : "2016-08-05T19:50:55Z",
        "lastEditedBy" : "b7d2a698-a6e1-4031-bb69-8b45505badb5",
        "tags" : [
        ]
      },
      {
        "id" : "c9f0cfa4-95cf-4f6b-8e3c-16531401b65f",
        "parentId" : "bf5bdb50-bd3a-4587-bfcd-6be2deb4940a",
        "authorId" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "body" : "In one possible implementation, the override is available to all users, but a user who requests the override would be expected to answer to an auditor, sometime after the fact, if she requests the override. \n",
        "createdAt" : "2016-07-25T23:12:28Z",
        "updatedAt" : "2016-08-05T19:50:55Z",
        "lastEditedBy" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "tags" : [
        ]
      }
    ],
    "commit" : "9d59ae547fdfdf8b09cc30898ac9762fb02f833b",
    "line" : 49,
    "diffHunk" : "@@ -1,1 +47,51 @@* Make it easy for users or partners to build \"image provenance checkers\" which check whether images are \"approved\".\n  *  We expect there will be multiple implementations.\n* Allow users to request an \"override\" of the policy in a convenient way (subject to the override being allowed).\n  * \"overrides\" are needed to allow \"emergency changes\", but need to not happen accidentally, since they may\n    require tedious after-the-fact justification and affect audit controls."
  },
  {
    "id" : "e3d442c7-b9e6-454f-bb2f-d0a60625d992",
    "prId" : 27129,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0062f677-1231-4071-9086-8dc91e386833",
        "parentId" : null,
        "authorId" : "58e25445-d670-440c-ba77-62f40ba86883",
        "body" : "This description is a little vague in the plurality sense. I think this should work over a set of webhooks rather than one. For example, this Pull Request on GitHub has multiple webhooks that must validate it before it is merged.\n",
        "createdAt" : "2016-07-27T00:46:02Z",
        "updatedAt" : "2016-08-05T19:50:55Z",
        "lastEditedBy" : "58e25445-d670-440c-ba77-62f40ba86883",
        "tags" : [
        ]
      },
      {
        "id" : "b21e2d73-1d9d-42e0-8655-ae8c9ceb7edf",
        "parentId" : "0062f677-1231-4071-9086-8dc91e386833",
        "authorId" : "b7d2a698-a6e1-4031-bb69-8b45505badb5",
        "body" : "I kinda understood this as being able to setup multiple, but having it explicit in the proposal is a good idea.\n",
        "createdAt" : "2016-07-28T11:34:42Z",
        "updatedAt" : "2016-08-05T19:50:55Z",
        "lastEditedBy" : "b7d2a698-a6e1-4031-bb69-8b45505badb5",
        "tags" : [
        ]
      },
      {
        "id" : "a004c363-204e-4f08-82db-df91e594fb75",
        "parentId" : "0062f677-1231-4071-9086-8dc91e386833",
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "> This description is a little vague in the plurality sense. I think this should work over a set of webhooks rather than one. For example, this Pull Request on GitHub has multiple webhooks that must validate it before it is merged.\n\nSeems like we could support a single callout and if someone wanted a union, they could write the union in their particular handler.  That keeps our core code out of the business of deciding between the ands, ors, and trumps, which inevitably follow the \"give me more than one\".\n\nI don't see an issue with making a reference impl for the webhook that can provide a simple union, but I don't think we want to bake multiples into our admission plugin.\n",
        "createdAt" : "2016-07-28T12:44:46Z",
        "updatedAt" : "2016-08-05T19:50:55Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      },
      {
        "id" : "cc144283-ea3e-42fd-af02-b955f28e41b3",
        "parentId" : "0062f677-1231-4071-9086-8dc91e386833",
        "authorId" : "b7d2a698-a6e1-4031-bb69-8b45505badb5",
        "body" : "I feel convinced.\n",
        "createdAt" : "2016-07-28T12:56:42Z",
        "updatedAt" : "2016-08-05T19:50:55Z",
        "lastEditedBy" : "b7d2a698-a6e1-4031-bb69-8b45505badb5",
        "tags" : [
        ]
      },
      {
        "id" : "71f05979-f64b-422e-9c74-2c15685c16d4",
        "parentId" : "0062f677-1231-4071-9086-8dc91e386833",
        "authorId" : "58e25445-d670-440c-ba77-62f40ba86883",
        "body" : "@deads2k It seems there's precedent in other parts of k8s for doing it the way you have described, so I agree.\n",
        "createdAt" : "2016-07-31T12:34:46Z",
        "updatedAt" : "2016-08-05T19:50:55Z",
        "lastEditedBy" : "58e25445-d670-440c-ba77-62f40ba86883",
        "tags" : [
        ]
      }
    ],
    "commit" : "9d59ae547fdfdf8b09cc30898ac9762fb02f833b",
    "line" : 77,
    "diffHunk" : "@@ -1,1 +75,79 @@\nAn `ImagePolicyWebhook` admission controller will be written.  The admission controller examines all pod objects which are\ncreated or updated.  It can either admit the pod, or reject it.  If it is rejected, the request sees a `403 FORBIDDEN`\n\nThe admission controller code will go in `plugin/pkg/admission/imagepolicy`."
  },
  {
    "id" : "d40a49ff-996e-4f7b-b468-3004b38c953e",
    "prId" : 27129,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3dc11621-f7e0-4c84-9685-8997f63b64e4",
        "parentId" : null,
        "authorId" : "6c7e5fb3-9a32-484a-be21-c70b4d00de52",
        "body" : "Shouldn't this be Image, ImageHash string?\n",
        "createdAt" : "2016-08-03T23:55:01Z",
        "updatedAt" : "2016-08-05T19:50:55Z",
        "lastEditedBy" : "6c7e5fb3-9a32-484a-be21-c70b4d00de52",
        "tags" : [
        ]
      },
      {
        "id" : "62ac52be-7184-4b7e-8e74-0dfee99d9bbb",
        "parentId" : "3dc11621-f7e0-4c84-9685-8997f63b64e4",
        "authorId" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "body" : "Images can be specified to docker, and in `pod.spec.container[].image` as either `image:tag` or `image@SHA:012345679abcdef`.  So, this field also accepts either format.\n\nIt is up to the backend to decide if it accepts `image:tag` or only accepts `image@SHA:012345679abcdef` format.   There are reasons you might chose to do either way, so this API doesn't have an opinion.\n",
        "createdAt" : "2016-08-04T00:29:41Z",
        "updatedAt" : "2016-08-05T19:50:55Z",
        "lastEditedBy" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "tags" : [
        ]
      }
    ],
    "commit" : "9d59ae547fdfdf8b09cc30898ac9762fb02f833b",
    "line" : 137,
    "diffHunk" : "@@ -1,1 +135,139 @@// ImageReviewContainerSpec is a description of a container within the pod creation request.\ntype ImageReviewContainerSpec struct {\n\tImage string\n\t// In future, we may add command line overrides, exec health check command lines, and so on.\n}"
  }
]
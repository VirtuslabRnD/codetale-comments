[
  {
    "id" : "c02cdd2b-0710-401a-85d1-f202c98815cf",
    "prId" : 15488,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f08e61ac-048a-4193-8a9f-c62e43ff480e",
        "parentId" : null,
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "This seems like a wrong change?\n",
        "createdAt" : "2015-10-13T20:17:09Z",
        "updatedAt" : "2015-10-13T20:23:11Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "64aa56a4-b9e9-4327-957c-f8e3f83f27f0",
        "parentId" : "f08e61ac-048a-4193-8a9f-c62e43ff480e",
        "authorId" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "body" : "I just removed the code reference because the code is being rapidly changed.\n",
        "createdAt" : "2015-10-13T20:20:36Z",
        "updatedAt" : "2015-10-13T20:23:11Z",
        "lastEditedBy" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "tags" : [
        ]
      },
      {
        "id" : "490b6d91-30c5-4a1f-97a5-5d663891ff59",
        "parentId" : "f08e61ac-048a-4193-8a9f-c62e43ff480e",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "OK\n",
        "createdAt" : "2015-10-13T20:46:30Z",
        "updatedAt" : "2015-10-13T20:46:30Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      }
    ],
    "commit" : "a5f42698b3c1464cf28e8fa765f5bf1ead2faa5a",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +123,127 @@2. Spelling the URL:\n\n  The URL is in the form of prefix/group/version/. The prefix is hard-coded in the client/unversioned.Config. The client should be able to figure out `group` and `version` using the RESTMapper. For a third-party client which does not have access to the RESTMapper, it should discover the mapping of `group`, `version` and `kind` by querying the server as described in point 2 of #server-side-implementation.\n\n3. kubectl:"
  },
  {
    "id" : "933d6e21-3ed7-4595-948a-6fb529d7a7f6",
    "prId" : 12951,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7e220db8-0ea4-428a-9234-233c6f0ebf75",
        "parentId" : null,
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "I'd like to include in this how an actual third party API would include it, and what we (OpenShift) would do as well.  @deads2k and @liggitt should jump in here as well.\n\nOpenShift also needs to break its monolithic v1 api to modular groups - we're closer to it, but we have about 10 API groups (depending on how you cut it).\n\nAnother goal I don't see described here but I think has to be solved before we move forward with this is how does a client _discover_ the set of groups.  I don't think a proposal that doesn't take that into account can be implemented.\n",
        "createdAt" : "2015-08-20T15:45:48Z",
        "updatedAt" : "2015-09-09T22:55:43Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "f8f940c5-8ac6-4c85-871e-7287735ec4ae",
        "parentId" : "7e220db8-0ea4-428a-9234-233c6f0ebf75",
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "We should finish the work on the discovery APIs #2057\n",
        "createdAt" : "2015-08-20T17:53:34Z",
        "updatedAt" : "2015-09-09T22:55:43Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "ab98b20b-264a-4ae7-95c9-3bc51705b85f",
        "parentId" : "7e220db8-0ea4-428a-9234-233c6f0ebf75",
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "We also want to use groups for component configuration  #12245. kubeconfig and the scheduler config are existing configuration \"APIs\" that have no explicit groups.\n",
        "createdAt" : "2015-08-20T17:55:58Z",
        "updatedAt" : "2015-09-09T22:55:43Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "0b0e0088-9007-4e97-a587-3878470245c4",
        "parentId" : "7e220db8-0ea4-428a-9234-233c6f0ebf75",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Is there a reason that configuration has to be in the same scheme?\nConfiguration seems very specific to each thing being configured, having\nseparate schemes there doesn't seem like an issue.\n\nOn Thu, Aug 20, 2015 at 1:56 PM, Brian Grant notifications@github.com\nwrote:\n\n> In docs/proposals/api-group.md\n> https://github.com/kubernetes/kubernetes/pull/12951#discussion_r37560164\n> :\n> \n> > +# Supporting multiple API groups\n> > +\n> > +## Goal\n> > +\n> > +1. Breaking the monolithic v1 API to modular groups\n> > +\n> > +2. Supporting different versions in different groups\n> > +\n> > +3. Supporting identically named kinds to exist in different groups\n> > +\n> > +4. Enabling/disabling groups individually\n> > +\n> > +5. Laying the basis for [API Plugin](../../docs/design/extending-api.md)\n> > +\n> > +6. Allowing users to omit group name when using kubectl\n> > +\n> \n> We also want to use groups for component configuration #12245\n> https://github.com/kubernetes/kubernetes/issues/12245. kubeconfig and\n> the scheduler config are existing configuration \"APIs\" that have no\n> explicit groups.\n> \n> â€”\n> Reply to this email directly or view it on GitHub\n> https://github.com/kubernetes/kubernetes/pull/12951/files#r37560164.\n\n## \n\nClayton Coleman | Lead Engineer, OpenShift\n",
        "createdAt" : "2015-08-20T18:44:43Z",
        "updatedAt" : "2015-09-09T22:55:43Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "303b6376-d057-4500-929b-cac94424a021",
        "parentId" : "7e220db8-0ea4-428a-9234-233c6f0ebf75",
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "They don't need to be part of the same set of groups. We could introduce a \"provider\" concept, which we discussed in #7111. But I'd rather not go there.\n\nThis came up in conversations about [nulecule](https://github.com/projectatomic/nulecule). If the configuration format isn't sufficiently self-describing to figure out what to do with it, then some other directory/map needs to be maintained.\n\nAt minimum, if we switch all the APIs to explicitly name groups in the apiVersion fields, we should do the same for config files that use the API versioning machinery.\n",
        "createdAt" : "2015-08-20T22:32:31Z",
        "updatedAt" : "2015-09-09T22:55:43Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      }
    ],
    "commit" : "73df8f30a3871970ffaf33fa08e4efd8c08b14e4",
    "line" : null,
    "diffHunk" : "@@ -1,1 +47,51 @@\n6. Keeping the user interaction easy. For example, we should allow users to omit group name when using kubectl if there is no ambiguity.\n\n\n## Bookkeeping for groups"
  },
  {
    "id" : "824a9473-f636-4aae-9467-aff39d1244c5",
    "prId" : 12951,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b1fe2cc1-d482-45b4-8819-0e5bc0ac5ffd",
        "parentId" : null,
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "Is the prefix necessary?\n",
        "createdAt" : "2015-08-25T16:48:04Z",
        "updatedAt" : "2015-09-09T22:55:43Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "849aab4a-ad82-4079-9661-cf07a7b8235e",
        "parentId" : "b1fe2cc1-d482-45b4-8819-0e5bc0ac5ffd",
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "Yes, so that GET /prefix can return the set of groups.\n",
        "createdAt" : "2015-08-28T20:40:50Z",
        "updatedAt" : "2015-09-09T22:55:43Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "b0cdeefd-6be2-4959-8344-ceefbaa977dc",
        "parentId" : "b1fe2cc1-d482-45b4-8819-0e5bc0ac5ffd",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Prefix is essentially arbitrary, right?  We define it here, but we make no requirement that other API implementors have a consistent prefix?  If so, we should clarify that here.\n",
        "createdAt" : "2015-09-02T23:13:25Z",
        "updatedAt" : "2015-09-09T22:55:43Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "955e39fa-ad2e-4c30-a118-45e71b66d2d1",
        "parentId" : "b1fe2cc1-d482-45b4-8819-0e5bc0ac5ffd",
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "I think we discussed making the prefix not configurable, since the client and server must agree -- the proposed discovery mechanism wouldn't even help. `/apis` is fine by me.\n",
        "createdAt" : "2015-09-02T23:18:09Z",
        "updatedAt" : "2015-09-09T22:55:43Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "531bcb06-f6d8-4726-9465-915e288f3012",
        "parentId" : "b1fe2cc1-d482-45b4-8819-0e5bc0ac5ffd",
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "@caesarxuchao reminded me we also have the legacy /api and /oapi prefixes.\n",
        "createdAt" : "2015-09-02T23:24:18Z",
        "updatedAt" : "2015-09-09T22:55:43Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "01018ad0-2fcc-4add-9fe0-79996b7a3fac",
        "parentId" : "b1fe2cc1-d482-45b4-8819-0e5bc0ac5ffd",
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "And the prefix isn't explicit in the API schema.\n\nOther than for the legacy APIs, do we need to support arbitrary prefixes?\n",
        "createdAt" : "2015-09-02T23:25:43Z",
        "updatedAt" : "2015-09-09T22:55:43Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "b02e2d41-1823-442d-973b-39ec936aaf29",
        "parentId" : "b1fe2cc1-d482-45b4-8819-0e5bc0ac5ffd",
        "authorId" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "body" : "The proposal states in the next sentence:\n\n```\nPrefix is used to differentiate API paths from other paths like /healthz. All groups will use the same prefix=\"apis\", except when backward compatibility requires otherwise.\n```\n\nIs that clear enough or do I need to emphasis it more? Thanks.\n",
        "createdAt" : "2015-09-02T23:26:40Z",
        "updatedAt" : "2015-09-09T22:55:43Z",
        "lastEditedBy" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "tags" : [
        ]
      },
      {
        "id" : "a8b12c1d-6a70-4f3b-9b25-e94e103e141f",
        "parentId" : "b1fe2cc1-d482-45b4-8819-0e5bc0ac5ffd",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "We get asked all the time to support hosting urls under someone else's\nproxy at a non root path.  So practically I'd like to make apis the\nconvention and not force clients into assuming the base URL has no path.\nIt's just something we spend a little extra time to stay flexible in what\nwe accept from clients.\n\nOn Sep 2, 2015, at 7:26 PM, Brian Grant notifications@github.com wrote:\n\nIn docs/proposals/api-group.md\nhttps://github.com/kubernetes/kubernetes/pull/12951#discussion_r38597860:\n\n> +\n> +2. conversion.Scheme:\n> +\n> -  The key of conversion.Scheme.versionMap will be \"group/version\". The internal version of objects of all groups will be registered to versionMap[\"\"].\n>   +\n>   +3. meta.RESTMapper:\n>   +\n> -  Each group will have its own RESTMapper, and these mappers will be registered to api.RESTMapper.\n>   +\n> -  To support identically named kinds in different groups, We need to expand the input of RESTMapper.VersionAndKindForResource from (resource string) to (group, resource string). If group is not specified and there is ambiguity (i.e., the resource exists in multiple groups), an error should be returned to force the user to specify the group.\n>   +\n>   +## Server-side implementation\n>   +\n>   +1. resource handlers' URL:\n>   +\n> -  We will force the URL to be in the form of prefix/group/version/...\n\nAnd the prefix isn't explicit in the API schema.\n\nOther than for the legacy APIs, do we need to support arbitrary prefixes?\n\nâ€”\nReply to this email directly or view it on GitHub\nhttps://github.com/kubernetes/kubernetes/pull/12951/files#r38597860.\n",
        "createdAt" : "2015-09-02T23:31:35Z",
        "updatedAt" : "2015-09-09T22:55:43Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "9b55b770-df68-4b1b-a5da-8d31622b6588",
        "parentId" : "b1fe2cc1-d482-45b4-8819-0e5bc0ac5ffd",
        "authorId" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "body" : "> We get asked all the time to support hosting urls under someone else's\n> proxy at a non root path.  So practically I'd like to make apis the\n> convention and not force clients into assuming the base URL has no path.\n\n@smarterclayton , could you explain this in other words? I found it hard to follow. Thank you.\n",
        "createdAt" : "2015-09-03T01:45:51Z",
        "updatedAt" : "2015-09-09T22:55:43Z",
        "lastEditedBy" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "tags" : [
        ]
      },
      {
        "id" : "7f2ea4de-6652-404d-a977-7cac81a7f057",
        "parentId" : "b1fe2cc1-d482-45b4-8819-0e5bc0ac5ffd",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Customers have a standard proxy somewhere (an authenticating reverse http\nproxy) at mycompany.com.  When they deploy, they prefer to front Kube with\ntheir proxy - but because it's shared, the root namespace can't be\nclaimed.  So they might want to host at www.mycompany.com/kube/*.  To\nlogin, a client might specify www.mycompany.com/kube instead of just\nwww.mycompany.com\n\nIt's less common these days, but it comes up in large companies\noccasionally.  When we design logins and clients we just try not to assume\nthat we get to dictate the API space.  So /apis as a convention is fine,\nbut the client library and config today supports passing a URL to the\ninitial host which might provide the prefix.  There should be very little\ncode after that initial point that requires knowing the prefix - that's why\nwould do API discovery.\n\nOn Sep 2, 2015, at 9:46 PM, Chao Xu notifications@github.com wrote:\n\nIn docs/proposals/api-group.md\nhttps://github.com/kubernetes/kubernetes/pull/12951#discussion_r38606105:\n\n> +\n> +2. conversion.Scheme:\n> +\n> -  The key of conversion.Scheme.versionMap will be \"group/version\". The internal version of objects of all groups will be registered to versionMap[\"\"].\n>   +\n>   +3. meta.RESTMapper:\n>   +\n> -  Each group will have its own RESTMapper, and these mappers will be registered to api.RESTMapper.\n>   +\n> -  To support identically named kinds in different groups, We need to expand the input of RESTMapper.VersionAndKindForResource from (resource string) to (group, resource string). If group is not specified and there is ambiguity (i.e., the resource exists in multiple groups), an error should be returned to force the user to specify the group.\n>   +\n>   +## Server-side implementation\n>   +\n>   +1. resource handlers' URL:\n>   +\n> -  We will force the URL to be in the form of prefix/group/version/...\n\nWe get asked all the time to support hosting urls under someone else's\nproxy at a non root path. So practically I'd like to make apis the\nconvention and not force clients into assuming the base URL has no path.\n\n@smarterclayton https://github.com/smarterclayton , could you explain\nthis in other words? I found it hard to follow. Thank you.\n\nâ€”\nReply to this email directly or view it on GitHub\nhttps://github.com/kubernetes/kubernetes/pull/12951/files#r38606105.\n",
        "createdAt" : "2015-09-03T03:13:19Z",
        "updatedAt" : "2015-09-09T22:55:43Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "e089a27b-17a2-4d39-9e8d-5e438b7642a5",
        "parentId" : "b1fe2cc1-d482-45b4-8819-0e5bc0ac5ffd",
        "authorId" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "body" : "Thank you for the explanation. It's reasonable. I will reword the proposal and make prefix=\"/apis\" a convention rather a rule.\n\ncc @bgrant0607 @lavalamp \n",
        "createdAt" : "2015-09-03T03:32:33Z",
        "updatedAt" : "2015-09-09T22:55:43Z",
        "lastEditedBy" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "tags" : [
        ]
      },
      {
        "id" : "265a1541-b37f-4c23-beac-dcbe4c9508ca",
        "parentId" : "b1fe2cc1-d482-45b4-8819-0e5bc0ac5ffd",
        "authorId" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "body" : "@smarterclayton, I just realized we are talking about server-side in the proposal. `prefix` should be `/apis` at server side, exceptions can be made for backward compatibility purposes. Clients can change the prefix as they wish.\n",
        "createdAt" : "2015-09-03T06:45:30Z",
        "updatedAt" : "2015-09-09T22:55:43Z",
        "lastEditedBy" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "tags" : [
        ]
      }
    ],
    "commit" : "73df8f30a3871970ffaf33fa08e4efd8c08b14e4",
    "line" : 75,
    "diffHunk" : "@@ -1,1 +73,77 @@1. resource handlers' URL:\n\n  We will force the URL to be in the form of prefix/group/version/...\n\n  Prefix is used to differentiate API paths from other paths like /healthz. All groups will use the same prefix=\"apis\", except when backward compatibility requires otherwise. No \"/\" is allowed in prefix, group, or version. Specifically,"
  },
  {
    "id" : "17077436-b194-49a6-acc7-c88110058e51",
    "prId" : 12951,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "61ab38fd-2423-4508-a080-957296016ed5",
        "parentId" : null,
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "Ref #13471\n",
        "createdAt" : "2015-09-02T23:52:37Z",
        "updatedAt" : "2015-09-09T22:55:43Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      }
    ],
    "commit" : "73df8f30a3871970ffaf33fa08e4efd8c08b14e4",
    "line" : null,
    "diffHunk" : "@@ -1,1 +99,103 @@3. handling common API objects:\n\n  * top-level common API objects:\n\n    To handle the top-level API objects that are used by all groups, we either have to register them to all schemes, or we can choose not to encode them to a version. We plan to take the latter approach and place such types in a new package called `unversioned`, because many of the common top-level objects, such as APIVersions, VersionList, and APIResourceList, which are used in the API discovery, and pkg/api#Status, are part of the protocol between client and server, and do not belong to the domain-specific parts of the API, which will evolve independently over time."
  },
  {
    "id" : "096ccacc-e7ea-4b86-b529-3c5d248fc2fd",
    "prId" : 12951,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7754b7f6-a321-47c2-a43a-7deee1aa81e3",
        "parentId" : null,
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "I'd like to move the unstructured client from kubectl to pkg/client.\n",
        "createdAt" : "2015-09-03T00:16:58Z",
        "updatedAt" : "2015-09-09T22:55:43Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "6d990019-4306-4f48-82d8-a91d05ad9a6d",
        "parentId" : "7754b7f6-a321-47c2-a43a-7deee1aa81e3",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "Yeah, this would be great.\n",
        "createdAt" : "2015-09-03T00:24:44Z",
        "updatedAt" : "2015-09-09T22:55:43Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      }
    ],
    "commit" : "73df8f30a3871970ffaf33fa08e4efd8c08b14e4",
    "line" : 119,
    "diffHunk" : "@@ -1,1 +117,121 @@1. clients:\n\n  Currently we have structured (pkg/client/unversioned#ExperimentalClient, pkg/client/unversioned#Client) and unstructured (pkg/kubectl/resource#Helper) clients. The structured clients are not scalable because each of them implements specific interface, e.g., [here](../../pkg/client/unversioned/client.go#L32). Only the unstructured clients are scalable. We should either auto-generate the code for structured clients or migrate to use the unstructured clients as much as possible.\n\n  We should also move the unstructured client to pkg/client/."
  },
  {
    "id" : "3ca8679a-4ada-4ac6-85c8-7824499323c3",
    "prId" : 12951,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4216f5dc-5064-4a58-9be0-7d901e8bf545",
        "parentId" : null,
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "We should have a \"group registry\" somewhere. It could be a section of api-conventions.md.\n",
        "createdAt" : "2015-09-03T00:43:14Z",
        "updatedAt" : "2015-09-09T22:55:43Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "2c11285e-656c-4301-bfb1-5677489a477d",
        "parentId" : "4216f5dc-5064-4a58-9be0-7d901e8bf545",
        "authorId" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "body" : "added to my TODO list [here](https://github.com/kubernetes/kubernetes/issues/12413#issuecomment-130188046)\n",
        "createdAt" : "2015-09-03T07:26:13Z",
        "updatedAt" : "2015-09-09T22:55:43Z",
        "lastEditedBy" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "tags" : [
        ]
      }
    ],
    "commit" : "73df8f30a3871970ffaf33fa08e4efd8c08b14e4",
    "line" : 141,
    "diffHunk" : "@@ -1,1 +139,143 @@For the v1 objects in OpenShift, they should keep doing what they do now: they should remain registered to Scheme.versionMap[\"v1\"] scheme, they should keep being added to originMapper.\n\nFor new OpenShift groups, they should do the same as native Kubernetes groups would do: each group should register to Scheme.versionMap[\"group/version\"], each should has separate RESTMapper and the register the MultiRESTMapper.\n\nTo expose a list of the supported Openshift groups to clients, OpenShift just has to call to pkg/cmd/server/origin#call initAPIVersionRoute() as it does now, passing in the supported \"group/versions\" instead of \"versions\"."
  },
  {
    "id" : "f8d7822f-f14e-43c4-b006-7e5e972d2fa4",
    "prId" : 12951,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8a796cb1-9eda-4ed4-85e4-735543c98bac",
        "parentId" : null,
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "I imagine it would be between specific groups/versions, like experimental/v1alpha1 would depend on api/v1, such as for Pods. But, yes, we should punt for now. :-)\n",
        "createdAt" : "2015-09-03T00:44:51Z",
        "updatedAt" : "2015-09-09T22:55:43Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "2e8f02e4-e9d8-485b-832a-f860ef935cc3",
        "parentId" : "8a796cb1-9eda-4ed4-85e4-735543c98bac",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "the most immediate practical issue I can think of is ObjectReferences... since `kind` alone could be ambiguous, do these now have to include the API group as well?\n",
        "createdAt" : "2015-09-03T04:03:26Z",
        "updatedAt" : "2015-09-09T22:55:43Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "031dc44f-0d81-4eee-bc84-a299cac68fb2",
        "parentId" : "8a796cb1-9eda-4ed4-85e4-735543c98bac",
        "authorId" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "body" : "It has the [APIVersion field](https://github.com/kubernetes/kubernetes/blob/master/pkg/api/v1/types.go#L2208), which will contain \"group/version\" according to this proposal. \n",
        "createdAt" : "2015-09-03T04:06:47Z",
        "updatedAt" : "2015-09-09T22:55:43Z",
        "lastEditedBy" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "tags" : [
        ]
      },
      {
        "id" : "c4375cf2-f7ca-45e5-ad3a-26e282b56ebb",
        "parentId" : "8a796cb1-9eda-4ed4-85e4-735543c98bac",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "To the best of my knowledge, no one sets that field on object references... I'm not even sure what it means to reference a particular API version of an object in the current system. If I set an ObjectReference of `{kind:Pod,apiVersion:v1}`, would you envision that getting automatically converted to `{kind:Pod,apiVersion:experimental/v1}` if I accessed the containing object via the experimentalv1 API version?\n",
        "createdAt" : "2015-09-03T04:30:43Z",
        "updatedAt" : "2015-09-09T22:55:43Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "ab6f1c1b-8d88-47e9-9353-8c3486be5fb1",
        "parentId" : "8a796cb1-9eda-4ed4-85e4-735543c98bac",
        "authorId" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "body" : "I'm not familiar with how ObjectReference is used today.\n\nRegarding your example, experimental/v1/pod and v1/pod are not convertible, they are backed up by different storage, similar to [this](https://github.com/kubernetes/kubernetes/blob/master/pkg/master/master.go#L822).\n\nSo I think a better example is if we should convert ObjectReference of {kind:Pod,apiVersion:v1} to {kind:Pod,apiVersion:`compute/v2`} if I accessed the containing object via the `compute/v2` API version. I think we should handle this case in the same way as how we handle v1beta3 with v1 in the old days, though I don't know how the current system would handle that either..\n",
        "createdAt" : "2015-09-03T05:55:02Z",
        "updatedAt" : "2015-09-09T22:55:43Z",
        "lastEditedBy" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "tags" : [
        ]
      },
      {
        "id" : "34e38e8e-262b-4a46-a346-210323aeeae5",
        "parentId" : "8a796cb1-9eda-4ed4-85e4-735543c98bac",
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "ObjectReference is contextual. Any fields that are identical to the context of the referring resource don't need to be specified.\n",
        "createdAt" : "2015-09-04T22:24:02Z",
        "updatedAt" : "2015-09-09T22:55:43Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "bd344a02-1c71-4287-ba70-8f5608b593e1",
        "parentId" : "8a796cb1-9eda-4ed4-85e4-735543c98bac",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "As API groups get more granular, cross-group references seem very likely. I think it would be worthwhile to think though how we would define/migrate (and keep valid as servers eventually disable older API versions) those \"fully qualified\" stored references.\n",
        "createdAt" : "2015-09-04T22:31:44Z",
        "updatedAt" : "2015-09-09T22:55:43Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "f2327305-1cd3-4139-b45e-90e84f1b9132",
        "parentId" : "8a796cb1-9eda-4ed4-85e4-735543c98bac",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "Maybe that's part of what bothers me about combining API version and API group into a single field. If I have a reference to a Pod object in the Infra group, I don't care what version it is, but if combined, now I suddenly care, and the reference can become invalid if that particular version becomes old and eventually disabled. \n",
        "createdAt" : "2015-09-04T22:36:47Z",
        "updatedAt" : "2015-09-09T22:55:43Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "65b40fb8-ffed-4c63-bd94-0f5b034abe9d",
        "parentId" : "8a796cb1-9eda-4ed4-85e4-735543c98bac",
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "I agree that cross-group references will happen. See my hypothetical resource breakdown in #8190.\n\nSplitting group and version into separate fields does not help. And you do care about the version.\n\nExample: v1beta1 had Minion, whereas v1beta3 had Node. How would an ObjectReference to Minion (say, in an Event) appear in v1beta3? Or an ObjectReference to a Node in v1beta1?\n\nThe Kind must be interpreted in the context of a specific group and version.\n\nNow, in the example above, the obviously right thing to do would be to convert the ObjectReference to the API version requested by the client -- which we don't do right now, AFAICT -- we convert the schema of ObjectReference, but not its contents. selfLink has a similar problem.\n\nSuch conversion is made harder by groups because we don't have a way for the client to specify which API version is expected for each group. (That would be ugly, anyway.)\n\nFor now, I'd convert cross-group references to the default (storage) version for each group, but I'll think about this more. Pinning to specific versions in other groups has the significant disadvantage that it wouldn't work well for APIs evolving at different rates, since that would be as if they were all in the same monolithic group.\n",
        "createdAt" : "2015-09-05T00:31:10Z",
        "updatedAt" : "2015-09-09T22:55:43Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "92d1d355-2db1-4fea-8ea5-439cefb946ad",
        "parentId" : "8a796cb1-9eda-4ed4-85e4-735543c98bac",
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "This is where fine-grain versioning would help. See: https://github.com/kubernetes/kubernetes/issues/4855#issuecomment-99565465\n\nIf we had a notion of \"minor versions\", we could both filter additive API changes and change pinned cross-group versions.\n",
        "createdAt" : "2015-09-05T01:09:01Z",
        "updatedAt" : "2015-09-09T22:55:43Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      }
    ],
    "commit" : "73df8f30a3871970ffaf33fa08e4efd8c08b14e4",
    "line" : 148,
    "diffHunk" : "@@ -1,1 +146,150 @@## Future work\n\n1. Dependencies between groups: we need an interface to register the dependencies between groups. It is not our priority now as the use cases are not clear yet.\n\n<!-- BEGIN MUNGE: GENERATED_ANALYTICS -->"
  },
  {
    "id" : "ee839e1c-24a5-4d51-a37c-a40543f2a3dd",
    "prId" : 12951,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5051e04e-3852-4d03-b691-c873e013c845",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "this seems like training people to script things in a way that will break as soon as an experimental API group introduces ambiguity where there wasn't any previously\n",
        "createdAt" : "2015-09-03T04:20:44Z",
        "updatedAt" : "2015-09-09T22:55:43Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "2d6d3062-ae69-43a4-995c-330d7bac7a68",
        "parentId" : "5051e04e-3852-4d03-b691-c873e013c845",
        "authorId" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "body" : "Fair point. I think this depends on how likely we will have conflicting resources in groups. \n\nAnd we can hard code some preferences to alleviate the ambiguity:\n1. experimental is less preferable than all other groups;\n2. monolithic v1 group is less preferable than modularized groups (e.g. v1/pod < compute/v2/pod)\n",
        "createdAt" : "2015-09-03T05:21:19Z",
        "updatedAt" : "2015-09-09T22:55:43Z",
        "lastEditedBy" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "tags" : [
        ]
      }
    ],
    "commit" : "73df8f30a3871970ffaf33fa08e4efd8c08b14e4",
    "line" : null,
    "diffHunk" : "@@ -1,1 +46,50 @@5. Laying the basis for [API Plugin](../../docs/design/extending-api.md).\n\n6. Keeping the user interaction easy. For example, we should allow users to omit group name when using kubectl if there is no ambiguity.\n\n"
  },
  {
    "id" : "3887d595-1541-46e0-8903-185aa8243d52",
    "prId" : 12951,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f9f3f858-5d5f-4ba0-89db-d75379e282a0",
        "parentId" : null,
        "authorId" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "body" : "@bgrant0607 @lavalamp , do you agree with this?\n",
        "createdAt" : "2015-09-03T07:32:50Z",
        "updatedAt" : "2015-09-09T22:55:43Z",
        "lastEditedBy" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "tags" : [
        ]
      }
    ],
    "commit" : "73df8f30a3871970ffaf33fa08e4efd8c08b14e4",
    "line" : null,
    "diffHunk" : "@@ -1,1 +103,107 @@    To handle the top-level API objects that are used by all groups, we either have to register them to all schemes, or we can choose not to encode them to a version. We plan to take the latter approach and place such types in a new package called `unversioned`, because many of the common top-level objects, such as APIVersions, VersionList, and APIResourceList, which are used in the API discovery, and pkg/api#Status, are part of the protocol between client and server, and do not belong to the domain-specific parts of the API, which will evolve independently over time.\n\n    Types in the unversioned package will not have the APIVersion field, but may retain the Kind field.\n\n    For backward compatibility, when hanlding the Status, the server will encode it to v1 if the client expects the Status to be encoded in v1, otherwise the server will send the unversioned#Status. If an error occurs before the version can be determined, the server will send the unversioned#Status."
  }
]
[
  {
    "id" : "c2286402-9117-4ebf-8f9d-b3d3f6b4fdc1",
    "prId" : 32628,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/32628#pullrequestreview-1897554",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fdaa0405-a307-4bed-8c19-af918b12ee8a",
        "parentId" : null,
        "authorId" : "3c437914-616b-4cfb-88a0-28dc812ff2b2",
        "body" : "Deleting Pods without Nodes will be moved to PodGC #32495\n",
        "createdAt" : "2016-09-27T09:37:11Z",
        "updatedAt" : "2016-10-12T23:20:02Z",
        "lastEditedBy" : "3c437914-616b-4cfb-88a0-28dc812ff2b2",
        "tags" : [
        ]
      },
      {
        "id" : "55a465c9-0180-4d68-9f45-840c2109a900",
        "parentId" : "fdaa0405-a307-4bed-8c19-af918b12ee8a",
        "authorId" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "body" : "Thanks. I quickly skimmed the PR it seems the same argument applies to the logic in the PodGC.\n",
        "createdAt" : "2016-09-27T17:40:43Z",
        "updatedAt" : "2016-10-12T23:20:02Z",
        "lastEditedBy" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "tags" : [
        ]
      },
      {
        "id" : "6dc4c904-0361-4d73-b2cc-474ac8f04dfc",
        "parentId" : "fdaa0405-a307-4bed-8c19-af918b12ee8a",
        "authorId" : "3c437914-616b-4cfb-88a0-28dc812ff2b2",
        "body" : "Yup - it was a minor nit.\n",
        "createdAt" : "2016-09-28T09:29:21Z",
        "updatedAt" : "2016-10-12T23:20:02Z",
        "lastEditedBy" : "3c437914-616b-4cfb-88a0-28dc812ff2b2",
        "tags" : [
        ]
      }
    ],
    "commit" : "fb81c1e5730d7e39f1f826140e2c215d372293fd",
    "line" : null,
    "diffHunk" : "@@ -1,1 +180,184 @@**kubelet** deletes the pod from the key-value store after all its containers are terminated ([code](../../pkg/kubelet/status/status_manager.go#L441-L443)). It also assumes that if the API server does not return an error, the pod is removed from the key-value store. Breaking the assumption will not break `kubelet` though, because the `pod` must have already been in the terminated phase, `kubelet` will not care to manage it.\n\n**Node controller** forcefully deletes pod if the pod is scheduled to a node that does not exist ([code](../../pkg/controller/node/nodecontroller.go#L474)). The pod will continue to exist if it has pending finalizers. The node controller will futilely retry the deletion. Also, the `node controller` forcefully deletes pods before deleting the node ([code](../../pkg/controller/node/nodecontroller.go#L592)). If the pods have pending finalizers, the `node controller` will go ahead deleting the node, leaving those pods behind. These pods will be deleted from the key-value store when the pending finalizers are removed.\n\n**Podgc** deletes terminated pods if there are too many of them in the cluster. We need to make sure finalizers on Pods are taken off quickly enough so that the progress of `Podgc` is not affected."
  },
  {
    "id" : "4f29d253-ce25-4602-ad26-977289b83b47",
    "prId" : 32628,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/32628#pullrequestreview-1847891",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f10685bc-411f-4bd0-97f8-d7727dfa4592",
        "parentId" : null,
        "authorId" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "body" : "@lavalamp updated. This is a little hand-waving. I'll figure out the details when converting kubectl to use synchronous GC.\n",
        "createdAt" : "2016-09-27T23:49:23Z",
        "updatedAt" : "2016-10-12T23:20:02Z",
        "lastEditedBy" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "tags" : [
        ]
      }
    ],
    "commit" : "fb81c1e5730d7e39f1f826140e2c215d372293fd",
    "line" : null,
    "diffHunk" : "@@ -1,1 +193,197 @@\nNote that this **changes the behavior** of `kubectl delete`. The command will be blocked until all pods are deleted from the key-value store, instead of being blocked until pods are in the terminating state. This means `kubectl delete` blocks for longer time, but it has the benefit that the resources used by the pods are released when the `kubectl delete` returns. To allow kubectl user not waiting for the cleanup, we will add a `--wait` flag. It defaults to true; if it's set to `false`, `kubectl delete` will send the delete request with `PropagationPolicy=DeletePropagationBackground` and return immediately.\n\nTo make the new kubectl compatible with the 1.4 and earlier masters, kubectl needs to switch to use the old reaper logic if it finds synchronous GC is not supported by the master.\n"
  },
  {
    "id" : "8b50c633-75c9-4571-b803-22cf85a687ec",
    "prId" : 32628,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/32628#pullrequestreview-1847891",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b6fceaba-12b5-4a75-a611-fcddf9f65b7d",
        "parentId" : null,
        "authorId" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "body" : "@lavalamp updated to use one queue.\n",
        "createdAt" : "2016-09-27T23:49:35Z",
        "updatedAt" : "2016-10-12T23:20:02Z",
        "lastEditedBy" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "tags" : [
        ]
      }
    ],
    "commit" : "fb81c1e5730d7e39f1f826140e2c215d372293fd",
    "line" : null,
    "diffHunk" : "@@ -1,1 +149,153 @@* if an object has multiple owners, some owners still exist while other owners are in the synchronous GC stage, then according to the existing logic of GC, the object wouldn't be deleted. To unblock the synchronous GC of owners, `processItem()` has to remove the ownerReferences pointing to them.\n\nIn addition, if an object popped from `dirtyQueue` is marked as \"GC in progress\", `processItem()` treats it specially:\n\n* To avoid racing with another controller, it requeues the object if `observedGeneration < Generation`. This is best-effort, see [unhandled cases](#unhandled-cases)."
  },
  {
    "id" : "bbadcaea-874f-4124-a4af-2edf674040ff",
    "prId" : 32628,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/32628#pullrequestreview-1847891",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4969017c-421c-4c0a-97a6-4be57cd1379f",
        "parentId" : null,
        "authorId" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "body" : "@lavalamp updated to use one queue.\n",
        "createdAt" : "2016-09-27T23:49:37Z",
        "updatedAt" : "2016-10-12T23:20:02Z",
        "lastEditedBy" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "tags" : [
        ]
      }
    ],
    "commit" : "fb81c1e5730d7e39f1f826140e2c215d372293fd",
    "line" : 141,
    "diffHunk" : "@@ -1,1 +139,143 @@\n* handle Add or Update events where `obj.Finalizers.Has(GCFinalizer) && obj.DeletionTimestamp != nil`. The object will be added into the `dirtyQueue`. The object will be marked as “GC in progress” in `uidToNode`.\n* Upon receiving the deletion event of an object, put its owner into the `dirtyQueue` if the owner node is marked as \"GC in progress\". This is to force the `processItem()` (described next) to re-check if all dependents of the owner is deleted.\n\n**Modifications to processItem()**"
  },
  {
    "id" : "9a0fd3e2-0bf0-4398-adff-f30284ff85b3",
    "prId" : 32628,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/32628#pullrequestreview-3585305",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7eab3694-b6a3-4e0d-86f9-504f96fc1696",
        "parentId" : null,
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "Even if we don't make it more rigorous, can we be sure that the implementation yields so that the controller doesn't get stuck?\n",
        "createdAt" : "2016-10-10T17:30:30Z",
        "updatedAt" : "2016-10-12T23:20:02Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      },
      {
        "id" : "9a1c0ef9-5535-4f49-8b02-a58f96ede67f",
        "parentId" : "7eab3694-b6a3-4e0d-86f9-504f96fc1696",
        "authorId" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "body" : "The approach only has false positives, meaning the garbage collector breaks the links even if there is no circle, so there won't be a deadlock.\n",
        "createdAt" : "2016-10-10T22:34:20Z",
        "updatedAt" : "2016-10-12T23:20:02Z",
        "lastEditedBy" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "tags" : [
        ]
      }
    ],
    "commit" : "fb81c1e5730d7e39f1f826140e2c215d372293fd",
    "line" : null,
    "diffHunk" : "@@ -1,1 +164,168 @@SynchronousGC will enter a deadlock in the presence of circular dependencies. The garbage collector can break the circle by lazily breaking circular dependencies: when `processItem()` processes an object, if it finds the object and all of its owners have the `GCFinalizer`, it removes the `GCFinalizer` from the object.\n\nNote that the approach is not rigorous and thus having false positives. For example, if a user first sends a SynchronousGC delete request for an object, then sends the delete request for its owner, then `processItem()` will be fooled to believe there is a circle. We expect user not to do this. We can make the circle detection more rigorous if needed.\n\nCircular dependencies are regarded as user error. If needed, we can add more guarantees to handle such cases later."
  },
  {
    "id" : "b726c0b8-0fcc-43cc-a829-8352f483720c",
    "prId" : 32628,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/32628#pullrequestreview-3621975",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c12cb05a-0c54-4db4-8a1b-5207b121f440",
        "parentId" : null,
        "authorId" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "body" : "Redesigned the DeleteOptions to make it easier to understand.\n",
        "createdAt" : "2016-10-11T07:23:45Z",
        "updatedAt" : "2016-10-12T23:20:02Z",
        "lastEditedBy" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "tags" : [
        ]
      }
    ],
    "commit" : "fb81c1e5730d7e39f1f826140e2c215d372293fd",
    "line" : 89,
    "diffHunk" : "@@ -1,1 +87,91 @@\n```go\nDeleteOptions {\n  …\n  // Whether and how garbage collection will be performed."
  },
  {
    "id" : "c7f7f63d-e109-4fe0-894a-ca84b09d8998",
    "prId" : 32628,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/32628#pullrequestreview-3987142",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "62d736a2-d3c0-4fb6-ac3f-4c1265063bbc",
        "parentId" : null,
        "authorId" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "body" : "> In the comment, note explicitly that the default depends on the object type and the controller for the object. (If the controller pre-adds the sync finalizer label, then you'll get foreground behavior as the default unless you specifically request something else).\n\n@lavalamp Is the current comment clear? I think saying the default depends on the \"existing finalizers\" is more general than saying it depends on \"the controller for the object\".\n",
        "createdAt" : "2016-10-12T23:22:39Z",
        "updatedAt" : "2016-10-12T23:23:15Z",
        "lastEditedBy" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "tags" : [
        ]
      },
      {
        "id" : "5666e5a1-654c-4d5e-a581-aab3ae90bc31",
        "parentId" : "62d736a2-d3c0-4fb6-ac3f-4c1265063bbc",
        "authorId" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "body" : "Also, do we need a `DeletePropagationDefault`? Can we use nil to mean default?\n",
        "createdAt" : "2016-10-12T23:23:11Z",
        "updatedAt" : "2016-10-12T23:23:15Z",
        "lastEditedBy" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "tags" : [
        ]
      },
      {
        "id" : "bf60729b-46c3-4dd7-a303-842ebbab3438",
        "parentId" : "62d736a2-d3c0-4fb6-ac3f-4c1265063bbc",
        "authorId" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "body" : "Ok, I'll keep the default for now. We can move the comment to `DeleteOptions.PropagationPolicy` if we later decide `DeletePropagationDefault` is redundent.\n",
        "createdAt" : "2016-10-13T00:22:45Z",
        "updatedAt" : "2016-10-13T00:22:46Z",
        "lastEditedBy" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "tags" : [
        ]
      }
    ],
    "commit" : "fb81c1e5730d7e39f1f826140e2c215d372293fd",
    "line" : 100,
    "diffHunk" : "@@ -1,1 +98,102 @@\nconst (\n    // The default depends on the existing finalizers on the object and the type of the object.\n    DeletePropagationDefault DeletePropagationPolicy = \"DeletePropagationDefault\"\n    // Orphans the dependents"
  }
]
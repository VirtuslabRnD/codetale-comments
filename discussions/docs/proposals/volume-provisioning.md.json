[
  {
    "id" : "41c31163-038b-4c01-91b4-c97cf34d42ef",
    "prId" : 30285,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f736f3aa-90d4-4408-b4f1-6a7ee6794ae8",
        "parentId" : null,
        "authorId" : "727fc82d-d969-41a4-a614-7fefce94f9a6",
        "body" : "opaque to the user or to the system?  The user (admin?) would know what 'gp2' is but the system wouldn't.\n",
        "createdAt" : "2016-08-09T15:33:04Z",
        "updatedAt" : "2016-10-27T08:28:33Z",
        "lastEditedBy" : "727fc82d-d969-41a4-a614-7fefce94f9a6",
        "tags" : [
        ]
      },
      {
        "id" : "05b09a1b-f87b-4235-aa10-8b91ed557274",
        "parentId" : "f736f3aa-90d4-4408-b4f1-6a7ee6794ae8",
        "authorId" : "8d7e3035-146d-4d3c-86b9-e61987a0f17b",
        "body" : "user as in the user creating the PVC. \n",
        "createdAt" : "2016-08-09T23:59:08Z",
        "updatedAt" : "2016-10-27T08:28:33Z",
        "lastEditedBy" : "8d7e3035-146d-4d3c-86b9-e61987a0f17b",
        "tags" : [
        ]
      }
    ],
    "commit" : "95197536fc5be791e474b952aa939ac7a2299d7e",
    "line" : null,
    "diffHunk" : "@@ -1,1 +93,97 @@\n3.  An api object will be incubated in storage.k8s.io/v1beta1 to hold the a `StorageClass`\n    API resource. Each StorageClass object contains parameters required by the provisioner to provision volumes of that class.  These parameters are opaque to the user.\n\n4.  `PersistentVolume.Spec.Class` attribute is added to volumes. This attribute"
  },
  {
    "id" : "ec9f141a-06bc-44ca-83a1-f9a40992530a",
    "prId" : 30285,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fa87cb28-63dd-4daa-89f6-d917f1b0850d",
        "parentId" : null,
        "authorId" : "727fc82d-d969-41a4-a614-7fefce94f9a6",
        "body" : "Should this potentially be expanded to something like `Params`?\n\nAssume that StorageClass is the correct place to configure whether or not a volume is encrypted.  We need a way to pass an encryption key to the provisioner.\n\nA new `SecretType` can be added to manage these keys for the user.  The PVC would therefore need both `claim.Spec.Class` and `claim.Spec.Secret` as params to the provisioner.\n\nAll GCE volumes are encrypted by default, so an empty Secret means GCE creates its own keypair.  AWS is _optionally_ encrypted, so an empty key might mean \"no encryption\" or it might mean \"generate a keypair\".\n",
        "createdAt" : "2016-08-09T15:45:52Z",
        "updatedAt" : "2016-10-27T08:28:33Z",
        "lastEditedBy" : "727fc82d-d969-41a4-a614-7fefce94f9a6",
        "tags" : [
        ]
      },
      {
        "id" : "f5b9e227-1c31-452c-9bc1-e7392db8ca36",
        "parentId" : "fa87cb28-63dd-4daa-89f6-d917f1b0850d",
        "authorId" : "8d7e3035-146d-4d3c-86b9-e61987a0f17b",
        "body" : "the use case for secret is along the lines of control API credentials used during the creation of the asset (cloud credentials, admin RBD secret, login to fibre channel provisioning API etc..)  a secret as a parameter to provisioner used to encrypt the volume or similar would result in every volume created by that provisioner using the same secret. \n\na better use case is the provisioner creating a unique secret for every provisioned asset.\n",
        "createdAt" : "2016-08-10T00:06:01Z",
        "updatedAt" : "2016-10-27T08:28:33Z",
        "lastEditedBy" : "8d7e3035-146d-4d3c-86b9-e61987a0f17b",
        "tags" : [
        ]
      },
      {
        "id" : "018856b2-e6a8-47ad-a010-0c7e91a148ff",
        "parentId" : "fa87cb28-63dd-4daa-89f6-d917f1b0850d",
        "authorId" : "727fc82d-d969-41a4-a614-7fefce94f9a6",
        "body" : "In my suggestion above, I was saying each PVC would supply a Secret so that each volume is encrypted with a specific key the user controls.\n\nFor OpenShift Online, it would be desirable for each user to supply the keys they want to use and we'd use that key to encrypt the volume. Storing the keys in a Secret makes sense, though we need to work out how that key gets into AWS/GCE (keys are referenced by name in the EBS API).\n",
        "createdAt" : "2016-08-10T01:17:04Z",
        "updatedAt" : "2016-10-27T08:28:33Z",
        "lastEditedBy" : "727fc82d-d969-41a4-a614-7fefce94f9a6",
        "tags" : [
        ]
      },
      {
        "id" : "de4e34f2-5219-4fc7-af29-fdd7d0729cd4",
        "parentId" : "fa87cb28-63dd-4daa-89f6-d917f1b0850d",
        "authorId" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "body" : "Original docs/proposals/volume-provisioning.md specifies that the provisioned PV can be configured by PVC labels. Concrete implementation is not written yet, but I expect something like\n`claim.Labels['kubernetes.io/aws-ebs/zone\"] = \"us-east-1d\"`. The provisioner then evaluates both `claim.Class` and `claim.Labels`. It would work the same for hypothetical encryption key ID or anything that the provisioner implements.\n",
        "createdAt" : "2016-08-10T08:42:10Z",
        "updatedAt" : "2016-10-27T08:28:33Z",
        "lastEditedBy" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "tags" : [
        ]
      },
      {
        "id" : "da906c06-05ca-4abd-a6c7-7a0f1a26b5a7",
        "parentId" : "fa87cb28-63dd-4daa-89f6-d917f1b0850d",
        "authorId" : "727fc82d-d969-41a4-a614-7fefce94f9a6",
        "body" : "I talked with our Ops team and they said a key per namespace was not necessary. End user supplied keys was too much.\n\nInstead, 1 key per StorageClass where admins manually create the keys is sufficient. \n",
        "createdAt" : "2016-08-17T18:17:07Z",
        "updatedAt" : "2016-10-27T08:28:33Z",
        "lastEditedBy" : "727fc82d-d969-41a4-a614-7fefce94f9a6",
        "tags" : [
        ]
      }
    ],
    "commit" : "95197536fc5be791e474b952aa939ac7a2299d7e",
    "line" : 76,
    "diffHunk" : "@@ -1,1 +124,128 @@   StorageClass instance is then used when user requests a dynamically\n   provisioned volume, but does not specify a StorageClass. In other words,\n   `claim.Spec.Class == \"\"`\n   (or annotation `volume.beta.kubernetes.io/storage-class == \"\"`).\n"
  },
  {
    "id" : "4c28a884-a382-4c71-b939-a5d0026d6bfd",
    "prId" : 30285,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "22f8bc31-3b2c-4e32-8a5c-5b204e5ad905",
        "parentId" : null,
        "authorId" : "241ab19e-f85a-4d22-92e2-88f2b6287d14",
        "body" : "I thought the new annotation was the only change needed to implement this proposal, this is another one since right now kubernetes sets PV to failed if it can't find a deleter. \n\nJust noting because I know I said annotation's the only change a couple times\n",
        "createdAt" : "2016-09-09T19:23:54Z",
        "updatedAt" : "2016-10-27T08:28:33Z",
        "lastEditedBy" : "241ab19e-f85a-4d22-92e2-88f2b6287d14",
        "tags" : [
        ]
      },
      {
        "id" : "a64c629c-6ca0-4783-a119-971e4667ce48",
        "parentId" : "22f8bc31-3b2c-4e32-8a5c-5b204e5ad905",
        "authorId" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "body" : "@wongma7, good chatch. I filled pr #32565 not to report any error when external deleter is requested.\n",
        "createdAt" : "2016-09-13T10:14:18Z",
        "updatedAt" : "2016-10-27T08:28:33Z",
        "lastEditedBy" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "tags" : [
        ]
      }
    ],
    "commit" : "95197536fc5be791e474b952aa939ac7a2299d7e",
    "line" : null,
    "diffHunk" : "@@ -1,1 +378,382 @@   the storage asset together with the PV that represents it.\n\n5. If the deleter is not known to Kubernetes, it does not do anything.\n\n6. External deleters MUST watch for PV changes. When"
  },
  {
    "id" : "98371183-c363-4d3a-8697-d97e4ae4096a",
    "prId" : 30285,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/30285#pullrequestreview-1527553",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "06be0a00-1592-4944-ab9e-a1d69b77ef35",
        "parentId" : null,
        "authorId" : "a7f673a6-4b23-4df6-aa10-f123fa9dcd5f",
        "body" : "is the numbering here and blow correct?\n",
        "createdAt" : "2016-09-22T15:41:39Z",
        "updatedAt" : "2016-10-27T08:28:33Z",
        "lastEditedBy" : "a7f673a6-4b23-4df6-aa10-f123fa9dcd5f",
        "tags" : [
        ]
      },
      {
        "id" : "5553a0ed-0a88-482c-abe9-a29c03ef9665",
        "parentId" : "06be0a00-1592-4944-ab9e-a1d69b77ef35",
        "authorId" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "body" : "markdown expands it to different levels, i.e. this \"1.\" is rendered as \"a.\", see \"rich diff\" at https://github.com/kubernetes/kubernetes/pull/30285/files?short_path=3cb6e02#diff-3cb6e02c12e0f637a83317ce28eb2c8c\n\nPlease report any problems with wrong cross-references, I might have missed some.. And yes, it's hard to review from looking at the .md file, better review rendered markdown or rich diff.\n",
        "createdAt" : "2016-09-26T12:49:25Z",
        "updatedAt" : "2016-10-27T08:28:33Z",
        "lastEditedBy" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "tags" : [
        ]
      }
    ],
    "commit" : "95197536fc5be791e474b952aa939ac7a2299d7e",
    "line" : 110,
    "diffHunk" : "@@ -1,1 +168,172 @@      and makes it already bound to the claim\n\n    1.  If the create operation for the `api.PersistentVolume` fails, it is\n        retried\n"
  },
  {
    "id" : "35a95e1d-02b5-48c4-8398-c9ff9ea55cc4",
    "prId" : 30285,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/30285#pullrequestreview-4837628",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3d90b16a-4424-4c99-849d-d756bed649fa",
        "parentId" : null,
        "authorId" : "5f5dd29a-d526-4711-8114-fae834f17efb",
        "body" : "There are a couple of other race conditions here, I think, as hinted at by the paragraph below.  Specifically,\n1. The claim can be changed to point to a storage class that uses a different provisioner.\n2. The claim can be resized to request more storage than it originally did.\n3. The claim can be resized to request less storage than it originally did.\n\nItem 3 is a non-issue (the claim will bind to the PVC), but items 1 and 2 will likely cause problems.  I'm unsure what the desired semantics for item 1 should be, as there'll be nothing to stop the binding from occurring, even though the user no longer wants to use the external provisioner.  In the case of item 2, the binding won't happen, and the incorrectly-sized volume should probably be deleted and the binding retried.\n",
        "createdAt" : "2016-10-14T14:34:15Z",
        "updatedAt" : "2016-10-27T08:28:33Z",
        "lastEditedBy" : "5f5dd29a-d526-4711-8114-fae834f17efb",
        "tags" : [
        ]
      },
      {
        "id" : "b3b1acbf-1479-44c2-858b-c13852ed9c04",
        "parentId" : "3d90b16a-4424-4c99-849d-d756bed649fa",
        "authorId" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "body" : "1) this is indeed possible in rare cases, however if two provisioners create a PV for one PVC, the PV controller will bind the PVC to one of them and it will mark the \"loosing\" one for deletion.\n\n2-3) we do not support PVC resizing (yet), PVC are be immutable after creation.\n",
        "createdAt" : "2016-10-19T09:58:45Z",
        "updatedAt" : "2016-10-27T08:28:33Z",
        "lastEditedBy" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "tags" : [
        ]
      }
    ],
    "commit" : "95197536fc5be791e474b952aa939ac7a2299d7e",
    "line" : 312,
    "diffHunk" : "@@ -1,1 +355,359 @@  either bound the claim to another PV that was created by user or even the\n  claim may have been deleted by the user. In both cases, Kubernetes will mark\n  the PV to be delete using the protocol below.\n\n  The external provisioner MAY save any annotations to the claim that is"
  },
  {
    "id" : "ce6680a8-2305-4cd6-9765-3e187c605cb6",
    "prId" : 30285,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/30285#pullrequestreview-4837712",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "abe8c011-4caf-4749-b7af-02aeef9910f1",
        "parentId" : null,
        "authorId" : "5f5dd29a-d526-4711-8114-fae834f17efb",
        "body" : "Should there be an explicit mechanism for doing this that all external provisioners should support, like an annotation in the PVC?  Should this also apply to internal provisioners?\n",
        "createdAt" : "2016-10-14T14:46:01Z",
        "updatedAt" : "2016-10-27T08:28:33Z",
        "lastEditedBy" : "5f5dd29a-d526-4711-8114-fae834f17efb",
        "tags" : [
        ]
      },
      {
        "id" : "7c422e82-dd05-449c-95c0-4ab10a3c2eec",
        "parentId" : "abe8c011-4caf-4749-b7af-02aeef9910f1",
        "authorId" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "body" : "We're not there yet, maybe in the future.\n",
        "createdAt" : "2016-10-19T09:59:14Z",
        "updatedAt" : "2016-10-27T08:28:33Z",
        "lastEditedBy" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "tags" : [
        ]
      }
    ],
    "commit" : "95197536fc5be791e474b952aa939ac7a2299d7e",
    "line" : 245,
    "diffHunk" : "@@ -1,1 +288,292 @@     * `pv.Spec.PersistentVolumeReclaimPolicy` SHOULD be set to `Delete` unless\n       user manually configures other reclaim policy.\n\n     * `pv.Name` MUST be unique. Internal provisioners use name based on\n       `claim.UID` to produce conflicts when two provisioners accidentally"
  },
  {
    "id" : "a57d89ac-3dd3-40b4-894f-3a88bd18a4d9",
    "prId" : 30285,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/30285#pullrequestreview-6090894",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ffd9b506-115b-441f-868b-8bfafe37cd9e",
        "parentId" : null,
        "authorId" : "3eb39df2-c27a-40ed-9fab-cabae1c6353d",
        "body" : "@jsafrane if its running as a pod, do we need to make sure the pod has certain privileges to serve the claims ? I mean, the access to the controller or the api server or something of that sort?  \n",
        "createdAt" : "2016-10-21T09:48:05Z",
        "updatedAt" : "2016-10-27T08:28:33Z",
        "lastEditedBy" : "3eb39df2-c27a-40ed-9fab-cabae1c6353d",
        "tags" : [
        ]
      },
      {
        "id" : "e1517ed7-c5aa-4bce-a7eb-75c962b017f8",
        "parentId" : "ffd9b506-115b-441f-868b-8bfafe37cd9e",
        "authorId" : "8d7e3035-146d-4d3c-86b9-e61987a0f17b",
        "body" : "The pod's privileges are up to the storage admin & external provisioner author and shouldn't need accounting for in the binding controller.\n",
        "createdAt" : "2016-10-24T23:56:58Z",
        "updatedAt" : "2016-10-27T08:28:33Z",
        "lastEditedBy" : "8d7e3035-146d-4d3c-86b9-e61987a0f17b",
        "tags" : [
        ]
      },
      {
        "id" : "3076fab9-20d3-4caa-b14e-b32cd8990407",
        "parentId" : "ffd9b506-115b-441f-868b-8bfafe37cd9e",
        "authorId" : "3eb39df2-c27a-40ed-9fab-cabae1c6353d",
        "body" : "Thanks @childsb .\n",
        "createdAt" : "2016-10-27T16:00:05Z",
        "updatedAt" : "2016-10-27T16:00:05Z",
        "lastEditedBy" : "3eb39df2-c27a-40ed-9fab-cabae1c6353d",
        "tags" : [
        ]
      }
    ],
    "commit" : "95197536fc5be791e474b952aa939ac7a2299d7e",
    "line" : null,
    "diffHunk" : "@@ -1,1 +203,207 @@  The external provisioner runs in a separate process which watches claims, be\n  it an external storage appliance, a daemon or a Kubernetes pod. For every\n  claim creation or update, it implements these steps:\n\n  1. The provisioner inspects if"
  },
  {
    "id" : "ca228ba3-d664-49b9-b096-3d51f93b0985",
    "prId" : 30285,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/30285#pullrequestreview-6080344",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4e5e9871-e4f5-485f-a198-e683b8997797",
        "parentId" : null,
        "authorId" : "6b4e4e58-009a-4611-a4dc-eb5fba70d614",
        "body" : "The specification says \"for in-tree provisioners a PVC with labelSelectors is ignored for provisioning\" and \"claim.Spec.Selector and claim.Spec.Class are mutually exclusive. User can either match existing volumes with Selector XOR match existing volumes with Class and get dynamic provisioning by using Class.\" However, external provisioners \"MUST parse arguments in the StorageClass and claim.Spec.Selector and provisions appropriate storage asset that matches both the parameters and the selector.\" Why is there a distinction between in-tree and external provisioners? Can external provisioners ignore PVCs with labelSelectors?\n",
        "createdAt" : "2016-10-26T19:50:51Z",
        "updatedAt" : "2016-10-27T08:28:33Z",
        "lastEditedBy" : "6b4e4e58-009a-4611-a4dc-eb5fba70d614",
        "tags" : [
        ]
      },
      {
        "id" : "5670afaa-8277-4086-87f9-11859375528a",
        "parentId" : "4e5e9871-e4f5-485f-a198-e683b8997797",
        "authorId" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "body" : "You are right, the text is different for internal and external provisioners, however the result is the same: if there is a selector in a PVC, the provisioner must provision something that matches both the class and the selector. In-tree provisioners are stupid and don't parse selectors right now (this will change in future, 1.6?) and therefore refuse to provision anything with any selector. I would advise external provisoners do the same - either refuse to provision a claim with _any_ selector or explicitly select few labels that are allowed in a PVC selector and document those as additional way how to configure a volume. Therefore \"MUST parse claim.Spec.Selector\" may be just `if pvc.Spec.Selector != nil { return Error(\"can't parse selector!\") }`\n\nI'll try to capture this idea in the proposal...\n",
        "createdAt" : "2016-10-27T07:59:36Z",
        "updatedAt" : "2016-10-27T08:28:33Z",
        "lastEditedBy" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "tags" : [
        ]
      },
      {
        "id" : "f2bc192b-3fb8-4c8d-87bb-f10992385dd6",
        "parentId" : "4e5e9871-e4f5-485f-a198-e683b8997797",
        "authorId" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "body" : "I added a new item here: https://github.com/kubernetes/kubernetes/pull/30285/files#diff-3cb6e02c12e0f637a83317ce28eb2c8cR80\n",
        "createdAt" : "2016-10-27T08:29:21Z",
        "updatedAt" : "2016-10-27T08:29:21Z",
        "lastEditedBy" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "tags" : [
        ]
      },
      {
        "id" : "3b872b9d-4ea1-48b3-94ac-acf5da7c3140",
        "parentId" : "4e5e9871-e4f5-485f-a198-e683b8997797",
        "authorId" : "6b4e4e58-009a-4611-a4dc-eb5fba70d614",
        "body" : "Thanks for the clarification! Is using selector as a means to passing arguments to provisioners an interim capability (say to  support dynamic provisioning for releases before 1.4 where StorageClass abstraction didn't exist) or a capability planned for the long term? \n",
        "createdAt" : "2016-10-27T15:06:10Z",
        "updatedAt" : "2016-10-27T15:06:10Z",
        "lastEditedBy" : "6b4e4e58-009a-4611-a4dc-eb5fba70d614",
        "tags" : [
        ]
      },
      {
        "id" : "5b9b734b-5115-404f-b332-4c3c21605d85",
        "parentId" : "4e5e9871-e4f5-485f-a198-e683b8997797",
        "authorId" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "body" : "For internal provisioners (GCE/AWS/Cinder) it's a feature we'd like introduce eventually, maybe in 1.6 (patches welcome!), external provisioner can go wild and parse selectors as they want, Kubernetes will not prevent them in doing so in any release.\n",
        "createdAt" : "2016-10-27T15:13:21Z",
        "updatedAt" : "2016-10-27T15:13:21Z",
        "lastEditedBy" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "tags" : [
        ]
      }
    ],
    "commit" : "95197536fc5be791e474b952aa939ac7a2299d7e",
    "line" : 186,
    "diffHunk" : "@@ -1,1 +229,233 @@     All errors found during parsing or provisioning SHOULD be send as events\n     on the claim and the provisioner SHOULD retry periodically with step i.\n\n     As parsing (and understanding) claim selectors is hard, the sentence\n     \"MUST parse ... `claim.Spec.Selector`\"  will in typical case lead to simple"
  },
  {
    "id" : "c1c7168e-7b6a-462d-976e-74c3ecfe7b2e",
    "prId" : 26908,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9a5f539b-8da7-4a52-8ef0-716eb778fc35",
        "parentId" : null,
        "authorId" : "766f642e-1622-4803-803b-05ce306fc30e",
        "body" : "Is there any problem with an api name that stutters?  `kind: storage/storageClass` ?\n",
        "createdAt" : "2016-06-06T21:12:09Z",
        "updatedAt" : "2016-07-14T08:14:55Z",
        "lastEditedBy" : "766f642e-1622-4803-803b-05ce306fc30e",
        "tags" : [
        ]
      },
      {
        "id" : "323b1bd8-6c93-4d91-8dd3-cb469b75462a",
        "parentId" : "9a5f539b-8da7-4a52-8ef0-716eb778fc35",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "No, I think it's better than storage.Class because there are things that key off the Kind, and I don't want to risk a too-generic name colliding.\n\nAs an aside, we've been saying \"class\" but many other systems say \"Profile\" for this wrt storage...\n",
        "createdAt" : "2016-07-08T06:27:08Z",
        "updatedAt" : "2016-07-14T08:14:55Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "7aa61dd0ff3908784acb4fa300713f02e62119af",
    "line" : null,
    "diffHunk" : "@@ -1,1 +153,157 @@should call this new API group `storage` and incubate in extensions/v1beta1.\n\nStorage classes will be represented by an API object called `StorageClass`:\n\n```go"
  },
  {
    "id" : "0870aa97-542e-4458-bd24-3fbf6cf73bc8",
    "prId" : 26908,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "31405ff7-f864-4f18-ad9c-547adb77cabe",
        "parentId" : null,
        "authorId" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "body" : "1. Change the behavior from \"always provision\" to \"try to find a matching volume first and provision a new one only if there isn't any available\".\n\nI'm not against, however it's quite big change and IMO it should be explicitly written and agreed.\n",
        "createdAt" : "2016-06-07T14:14:44Z",
        "updatedAt" : "2016-07-14T08:14:55Z",
        "lastEditedBy" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "tags" : [
        ]
      },
      {
        "id" : "e3c20003-0ca4-451c-bf97-a496ee717e15",
        "parentId" : "31405ff7-f864-4f18-ad9c-547adb77cabe",
        "authorId" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "body" : "Note added to the proposal.\n",
        "createdAt" : "2016-06-28T13:11:24Z",
        "updatedAt" : "2016-07-14T08:14:55Z",
        "lastEditedBy" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "tags" : [
        ]
      }
    ],
    "commit" : "7aa61dd0ff3908784acb4fa300713f02e62119af",
    "line" : null,
    "diffHunk" : "@@ -1,1 +146,150 @@\nExisting behavior is un-changed for claims that do not specify `claim.Spec.Class`.\n\n### `StorageClass` API\n"
  },
  {
    "id" : "0d541b32-62b2-422d-8bd0-a9dc68d8226d",
    "prId" : 26908,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "89558e69-b143-4884-b8b6-ec1aaf5f1d55",
        "parentId" : null,
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Talked offline but this won't be a sufficient experience for client tools to build off of (end users will need access to which storage classes they can access).  That's likely a separate virtual resource exposed by policy - if we keep it out of scope of this proposal and it's something built on top (I.e. in OpenShift or as an extension) that's fine.\n",
        "createdAt" : "2016-06-17T16:12:58Z",
        "updatedAt" : "2016-07-14T08:14:55Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "cb1046f5-9dfb-4810-9e42-c59ead8c2df4",
        "parentId" : "89558e69-b143-4884-b8b6-ec1aaf5f1d55",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "That can be a follow up section in here, which is \"how are storage classes identified / consumed by end users\" and \"how does someone who doesn't know about storage classes get the right behavior\".\n",
        "createdAt" : "2016-06-17T16:17:08Z",
        "updatedAt" : "2016-07-14T08:14:55Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "8d21db07-bbd3-4296-ad6d-dcc4c257a843",
        "parentId" : "89558e69-b143-4884-b8b6-ec1aaf5f1d55",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "We had previously discussed context-dependent class definitions.  Specifically \"fast\" could mean something different depending on whether you were coming from an \"tier1\" namespace vs a \"tier2\" namespace.  Lack of nested namespacing makes that hard, so I guess we punt on that for now.  We can revisit that later, and maybe do something clever with labels.\n",
        "createdAt" : "2016-07-08T06:49:36Z",
        "updatedAt" : "2016-07-14T08:14:55Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "7aa61dd0ff3908784acb4fa300713f02e62119af",
    "line" : 201,
    "diffHunk" : "@@ -1,1 +199,203 @@\n1.  Align with PersistentVolumes, which are a global resource\n2.  Are administrator controlled\n\n### Provisioning configuration"
  },
  {
    "id" : "0acfb2f6-b109-4c1a-aaf9-db398c07b475",
    "prId" : 26908,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f9e58ff6-485e-4bd6-9945-6b0d0137d21b",
        "parentId" : null,
        "authorId" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "body" : "Are we clear about what parameters might be used here? Is a string type sufficient to represent those parameters?\n",
        "createdAt" : "2016-07-08T06:30:38Z",
        "updatedAt" : "2016-07-14T08:14:55Z",
        "lastEditedBy" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "tags" : [
        ]
      },
      {
        "id" : "18cacf1c-ecbf-4c15-9655-187ecbc35f2e",
        "parentId" : "f9e58ff6-485e-4bd6-9945-6b0d0137d21b",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "This is my least favoritest part.  Static validation is my main grumble about pulling storage drivers out of process.  This is not validatable, but there's no really viable way to get that, so I'll just have to suck it up.  We should define some bounds for this, at least.  Keys <=256 chars, values <=256 chars, max 256 keys, total size of keys+values <=64KB something like that.\n",
        "createdAt" : "2016-07-08T06:45:49Z",
        "updatedAt" : "2016-07-14T08:14:55Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "d7a3d426-13d6-400e-92f8-e66b90af629d",
        "parentId" : "f9e58ff6-485e-4bd6-9945-6b0d0137d21b",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "In January we discussed a second dimension of parameters which was parameters that could be exposed by the class and passed in through a claim.  I appreciate that you left that out, I just wanted to make sure it was on purpose.\n",
        "createdAt" : "2016-07-08T06:47:12Z",
        "updatedAt" : "2016-07-14T08:14:55Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "91034ec7-30d2-45c3-b0b8-0128f604d129",
        "parentId" : "f9e58ff6-485e-4bd6-9945-6b0d0137d21b",
        "authorId" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "body" : "@thockin It was intentional -- I don't think it's necessary for the MVP of dynamic provisioning, and it's far easier to add from an API than it is to subtract.  Under YAGNI, I avoided them.\n",
        "createdAt" : "2016-07-08T16:18:41Z",
        "updatedAt" : "2016-07-14T08:14:55Z",
        "lastEditedBy" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "tags" : [
        ]
      },
      {
        "id" : "93e7d5b3-ab09-4068-ad46-311c596349db",
        "parentId" : "f9e58ff6-485e-4bd6-9945-6b0d0137d21b",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "cribbing from the above discussion on selectors, isn't \"zone\" a parameter that users can ask for that modulates how a provisioner acts?\n",
        "createdAt" : "2016-07-08T16:53:34Z",
        "updatedAt" : "2016-07-14T08:14:55Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "7aa61dd0ff3908784acb4fa300713f02e62119af",
    "line" : null,
    "diffHunk" : "@@ -1,1 +171,175 @@\n  // Parameters for dynamic volume provisioner.\n  ProvisionerParameters map[string]string `json:\"provisionerParameters,omitempty\"`\n}\n"
  },
  {
    "id" : "fd7bea0e-3518-4997-b577-c7d2752d40cb",
    "prId" : 26908,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "eebbc879-8cf1-41d0-9e48-c9bfa13c4ac5",
        "parentId" : null,
        "authorId" : "cb578771-ab57-49a0-afd6-27da11c87c6d",
        "body" : "IIUC provisioner will create a PersistentVolume object. Will it inherit any labels from provisioner? We might need it if we want to distinguish between static persistent volume explicitly created by user and dynamic volumes provisioned by provisioner.\n",
        "createdAt" : "2016-07-08T15:54:11Z",
        "updatedAt" : "2016-07-14T08:14:55Z",
        "lastEditedBy" : "cb578771-ab57-49a0-afd6-27da11c87c6d",
        "tags" : [
        ]
      },
      {
        "id" : "d4980a56-fc3c-4346-94f6-9bc50fd4767b",
        "parentId" : "eebbc879-8cf1-41d0-9e48-c9bfa13c4ac5",
        "authorId" : "766f642e-1622-4803-803b-05ce306fc30e",
        "body" : "I content that a PV which is dynamically generated must have, at a minimum, the same labels as those present on the StorageClass object which generated the PV.\n",
        "createdAt" : "2016-07-08T17:09:51Z",
        "updatedAt" : "2016-07-14T08:14:55Z",
        "lastEditedBy" : "766f642e-1622-4803-803b-05ce306fc30e",
        "tags" : [
        ]
      },
      {
        "id" : "722f7bf0-c485-4e06-b355-dcf05e997288",
        "parentId" : "eebbc879-8cf1-41d0-9e48-c9bfa13c4ac5",
        "authorId" : "cb578771-ab57-49a0-afd6-27da11c87c6d",
        "body" : "ACK\n",
        "createdAt" : "2016-07-08T18:03:37Z",
        "updatedAt" : "2016-07-14T08:14:55Z",
        "lastEditedBy" : "cb578771-ab57-49a0-afd6-27da11c87c6d",
        "tags" : [
        ]
      },
      {
        "id" : "154a0a9d-17a0-431e-9969-6d6893bd27b8",
        "parentId" : "eebbc879-8cf1-41d0-9e48-c9bfa13c4ac5",
        "authorId" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "body" : "Agree with @eparis.\n",
        "createdAt" : "2016-07-08T18:14:00Z",
        "updatedAt" : "2016-07-14T08:14:55Z",
        "lastEditedBy" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "tags" : [
        ]
      }
    ],
    "commit" : "7aa61dd0ff3908784acb4fa300713f02e62119af",
    "line" : 200,
    "diffHunk" : "@@ -1,1 +198,202 @@Storage classes are natural to think of as a global resource, since they:\n\n1.  Align with PersistentVolumes, which are a global resource\n2.  Are administrator controlled\n"
  },
  {
    "id" : "df1e6b9f-fb0a-4017-a03a-f7fc4e68df3c",
    "prId" : 26908,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "354582ec-5960-4e2e-b8bd-6ccca9f15f97",
        "parentId" : null,
        "authorId" : "766f642e-1622-4803-803b-05ce306fc30e",
        "body" : "Hmmmm. I cant decide here. Should it be `all` or `none`...\n",
        "createdAt" : "2016-07-13T13:41:09Z",
        "updatedAt" : "2016-07-14T08:14:55Z",
        "lastEditedBy" : "766f642e-1622-4803-803b-05ce306fc30e",
        "tags" : [
        ]
      },
      {
        "id" : "3d5dfc3c-8d9a-4700-8bc0-118754f6d9d6",
        "parentId" : "354582ec-5960-4e2e-b8bd-6ccca9f15f97",
        "authorId" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "body" : "One point to add here, with empty `claim.Spec.Class`, we match _all_ PVs, while we provision PVs of the _default_ class (if set). Empty `Class` should be probably interpreted as the default one. Either implicitly in the controller or explicitly in an admission controller.\n",
        "createdAt" : "2016-07-13T15:45:16Z",
        "updatedAt" : "2016-07-14T08:14:55Z",
        "lastEditedBy" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "tags" : [
        ]
      },
      {
        "id" : "9d6e9162-be41-46ab-b941-244c53df1866",
        "parentId" : "354582ec-5960-4e2e-b8bd-6ccca9f15f97",
        "authorId" : "766f642e-1622-4803-803b-05ce306fc30e",
        "body" : "Follow the LabelSelector pattern?\n\nunset means any\nset to \"\" means only \"\"\n\nAnd in an admission controller we explicitly set a default if we so choose if unset? I'd rather do the defaulting in an admission controller than in the binder, but that's just me/implementation.\n",
        "createdAt" : "2016-07-13T19:28:15Z",
        "updatedAt" : "2016-07-14T08:14:55Z",
        "lastEditedBy" : "766f642e-1622-4803-803b-05ce306fc30e",
        "tags" : [
        ]
      },
      {
        "id" : "3bfee946-edf7-49e1-b6a9-b74c086775d1",
        "parentId" : "354582ec-5960-4e2e-b8bd-6ccca9f15f97",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "This is for initial selection, not provisioning.  I think we have to be back-compatible and say that non-specified == \"\" == any.\n",
        "createdAt" : "2016-07-13T23:01:13Z",
        "updatedAt" : "2016-07-14T08:14:55Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "969d8a66-f4a8-4220-9509-8107249d28d0",
        "parentId" : "354582ec-5960-4e2e-b8bd-6ccca9f15f97",
        "authorId" : "766f642e-1622-4803-803b-05ce306fc30e",
        "body" : "We all agree `non-specified == any`, which is the backwards compat issue.\nIsn't `\"\" == any` an uncommon kube pattern? You explicitly picked a `StorgeClass`. You picked `\"\"`\n",
        "createdAt" : "2016-07-14T13:16:38Z",
        "updatedAt" : "2016-07-14T13:16:38Z",
        "lastEditedBy" : "766f642e-1622-4803-803b-05ce306fc30e",
        "tags" : [
        ]
      },
      {
        "id" : "784f02c4-c313-481f-b87b-ee02eefeabb2",
        "parentId" : "354582ec-5960-4e2e-b8bd-6ccca9f15f97",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "to differentiate non-specified from empty, it needs to be a pointer field\nin Go.  Maybe we should do that anyway, but is \"\" meaning \"none\" really\nuseful?\n\nOn Thu, Jul 14, 2016 at 6:17 AM, Eric Paris notifications@github.com\nwrote:\n\n> In docs/proposals/volume-provisioning.md\n> https://github.com/kubernetes/kubernetes/pull/26908#discussion_r70802471\n> :\n> \n> > +8.  The existing provisioner plugin implementations be modified to allow\n> > -    parameterization as appropriate via storage classes and claim selectors.\n> >   +\n> >   +9.  The existing alpha dynamic provisioning feature be phased out in the\n> > -    next release.\n> >   +\n> >   +### Controller workflow for provisioning volumes\n> >   +\n> >   +1.  When a new claim is submitted, the controller attempts to find an existing\n> > -    volume that will fulfill the claim.\n> >   +\n> > -    1. If the claim has non-empty `claim.Spec.Class`, only PVs with the same\n> > -        `pv.Spec.Class` are considered.\n> >   +\n> > -    2. If the claim has empty `claim.Spec.Class`, all existing PVs are\n> > -        considered.\n> \n> We all agree non-specified == any, which is the backwards compat issue.\n> Isn't \"\" == any an uncommon kube pattern? You explicitly picked a\n> StorgeClass. You picked \"\"\n> \n> â€”\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> https://github.com/kubernetes/kubernetes/pull/26908/files/4e02b557bae620b6df6acdf85308d5cdc2998b25#r70802471,\n> or mute the thread\n> https://github.com/notifications/unsubscribe/AFVgVOFuZEqFRoWxMpAlDR3m0qsSsSVhks5qVjblgaJpZM4IvTmn\n> .\n",
        "createdAt" : "2016-07-14T15:13:29Z",
        "updatedAt" : "2016-07-14T15:13:29Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "7aa61dd0ff3908784acb4fa300713f02e62119af",
    "line" : 111,
    "diffHunk" : "@@ -1,1 +109,113 @@\n    2. If the claim has empty `claim.Spec.Class`, all existing PVs are\n        considered.\n\n    All \"considered\" volumes are evaluated and the"
  },
  {
    "id" : "edc59015-fed9-478f-bbc7-dfbb7e6942cb",
    "prId" : 26908,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "27e8c30b-be23-4917-bd4b-5649a287d202",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "How will external provisioners (out of process) know when they should try to do a provision action?  If there is an existing volume that could match, they are better to not try...\n",
        "createdAt" : "2016-07-13T23:13:21Z",
        "updatedAt" : "2016-07-14T08:14:55Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "7aa61dd0ff3908784acb4fa300713f02e62119af",
    "line" : null,
    "diffHunk" : "@@ -1,1 +114,118 @@    smallest matching volume is bound to the claim.\n\n2.  If no volume is found for the claim and `claim.Spec.Class` is not set or is\n    empty string dynamic provisioning is disabled.\n"
  },
  {
    "id" : "f7f7a045-07db-43e8-9d30-599c6d745123",
    "prId" : 26908,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3f08a1ca-bab4-40e8-ad6c-6024768770aa",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "words nit: the Kind will be StorageClass.  It will be incubated in extensions/v1beta1 until it is ready for GA, at which time it will move to a new apigroup, probably called 'storage'\n",
        "createdAt" : "2016-07-14T02:49:53Z",
        "updatedAt" : "2016-07-14T08:14:55Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "7aa61dd0ff3908784acb4fa300713f02e62119af",
    "line" : 75,
    "diffHunk" : "@@ -1,1 +73,77 @@1.  For the base impelementation storage class and volume selectors are mutually exclusive.\n\n2.  An api object will be incubated in extensions/v1beta1 named `storage` to hold the a `StorageClass`\n    API resource. Each StorageClass object contains parameters required by the provisioner to provision volumes of that class.  These parameters are opaque to the user.\n"
  },
  {
    "id" : "bfbdd604-6bce-4ca5-9642-57e2b08241a5",
    "prId" : 26908,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ce597a79-2452-4430-86e1-46744b0fe4ce",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "You left off the selector evaluation if class == \"\"\n",
        "createdAt" : "2016-07-14T02:55:03Z",
        "updatedAt" : "2016-07-14T08:14:55Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "7aa61dd0ff3908784acb4fa300713f02e62119af",
    "line" : 114,
    "diffHunk" : "@@ -1,1 +112,116 @@\n    All \"considered\" volumes are evaluated and the\n    smallest matching volume is bound to the claim.\n\n2.  If no volume is found for the claim and `claim.Spec.Class` is not set or is"
  },
  {
    "id" : "10a00f8a-621c-4191-85f8-c847bba85b5c",
    "prId" : 26908,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "db3dbaf8-79ea-4f20-ad70-22de808908ce",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "We can argue over names with the code\n",
        "createdAt" : "2016-07-14T02:57:22Z",
        "updatedAt" : "2016-07-14T08:14:55Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "7aa61dd0ff3908784acb4fa300713f02e62119af",
    "line" : 170,
    "diffHunk" : "@@ -1,1 +168,172 @@\n  // ProvisionerType indicates the type of the provisioner.\n  ProvisionerType string `json:\"provisionerType,omitempty\"`\n\n  // Parameters for dynamic volume provisioner."
  },
  {
    "id" : "791338a4-7028-421f-8ce6-56c57683ec32",
    "prId" : 26908,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "53982753-9114-4871-a35b-69e77e323b63",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "we can argue over names in code.\n",
        "createdAt" : "2016-07-14T02:57:50Z",
        "updatedAt" : "2016-07-14T08:14:55Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "7aa61dd0ff3908784acb4fa300713f02e62119af",
    "line" : 187,
    "diffHunk" : "@@ -1,1 +185,189 @@    // available, StorageClass with this name will be used to dynamically\n    // provision the volume.\n    Class string\n...\n}"
  },
  {
    "id" : "00551f61-b8c9-4f3f-9536-c70bffc61c95",
    "prId" : 26908,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1737e6e9-54bc-4f89-a7da-b9a62fda1efa",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "We should add a \"future work\" section:\n- default provisioner\n- selectors and classes together\n- self-describing parameters to provisioners\n- out-of-tree provisioners\n",
        "createdAt" : "2016-07-14T03:00:45Z",
        "updatedAt" : "2016-07-14T08:14:55Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "7aa61dd0ff3908784acb4fa300713f02e62119af",
    "line" : null,
    "diffHunk" : "@@ -1,1 +255,259 @@\nSince the `volume.alpha.kubernetes.io/storage-class` is in use a `StorageClass` must be defined to support provisioning.  No default is assumed as before.\n\n<!-- BEGIN MUNGE: GENERATED_ANALYTICS -->\n[![Analytics](https://kubernetes-site.appspot.com/UA-36037335-10/GitHub/docs/proposals/volume-provisioning.md?pixel)]()"
  },
  {
    "id" : "04ab3764-52e4-4bf6-8daa-595fc92d8bec",
    "prId" : 26908,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b402d333-6849-4cda-9e22-71a62c449058",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "To think about: is StorageClass updatable?  What does it mean if admin redefines \"Purple\" while volumes that claim to be purple exist?\n",
        "createdAt" : "2016-07-14T03:01:29Z",
        "updatedAt" : "2016-07-14T08:14:55Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "7aa61dd0ff3908784acb4fa300713f02e62119af",
    "line" : 165,
    "diffHunk" : "@@ -1,1 +163,167 @@// StorageClasses are non-namespaced; the name of the storage class\n// according to etcd is in ObjectMeta.Name.\ntype StorageClass struct {\n  unversioned.TypeMeta `json:\",inline\"`\n  ObjectMeta           `json:\"metadata,omitempty\"`"
  }
]
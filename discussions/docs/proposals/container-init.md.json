[
  {
    "id" : "460f72de-09c1-41f2-863d-7c9d60f32c5b",
    "prId" : 23666,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4c870e01-6c32-4507-a116-80f402a74cc1",
        "parentId" : null,
        "authorId" : "f81960f6-a033-4403-bebf-c8ebb484e444",
        "body" : "This is a base case of DAG/workflow + pre&post-hook mechanics, except this proposal is missing the post bit.  \n\n@bgrant0607, @davidopp  - Instead of speculating, I'll just ask ;-) Do you have a long term DAG/workflow model & hooks that you are planning?  \n",
        "createdAt" : "2016-03-31T13:54:44Z",
        "updatedAt" : "2016-06-17T21:38:08Z",
        "lastEditedBy" : "f81960f6-a033-4403-bebf-c8ebb484e444",
        "tags" : [
        ]
      },
      {
        "id" : "1742d23a-6036-4876-b83e-308c683eea98",
        "parentId" : "4c870e01-6c32-4507-a116-80f402a74cc1",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "If we want to do DAG, then we'd probably have data preconditions on\ncontainers (the volume type container as proposed), and we'd need control\nconditions.  I may have missed that in Brian's comment about doing volume\ntype container (which form the edges) as the implication of the change.\n\nIf we implement the DAG, init containers are technically still useful and\neasier to reason about total resources for.  I believe in a future DAG\nmodel you could convert init containers to a DAG defined solely in the\ncontainers slice transparently, so one does not block the other.\n\nOn Thu, Mar 31, 2016 at 9:55 AM, Timothy St. Clair <notifications@github.com\n\n> wrote:\n> \n> In docs/proposals/container-init.md\n> https://github.com/kubernetes/kubernetes/pull/23666#discussion_r58056775\n> :\n> \n> > +\n> > +March 2016\n> > +\n> > +## Proposal and Motivation\n> > +\n> > +Within a pod there is a need to initialize local data or adapt to the current\n> > +cluster environment that is not easily achieved in the current container model.\n> > +Containers start in parallel after volumes are mounted, leaving no opportunity\n> > +for coordination between containers without specialization of the image. If\n> > +two containers need to share common initialization data, both images must\n> > +be altered to cooperate using filesystem or network semantics, which introduces\n> > +coupling between images. Likewise, if an image requires configuration in order\n> > +to start and that configuration is environment dependent, the image must be\n> > +altered to add the necessary templating or retrieval.\n> > +\n> > +This proposal introduces the concept of an **init container**, one or more\n> \n> This is a base case of DAG/workflow + pre&post-hook mechanics, except this\n> proposal is missing the post bit.\n> \n> @bgrant0607 https://github.com/bgrant0607, @davidopp\n> https://github.com/davidopp - Instead of speculating, I'll just ask ;-)\n> Do you have a long term DAG/workflow model & hooks that you are planning?\n> \n> â€”\n> You are receiving this because you authored the thread.\n> Reply to this email directly or view it on GitHub\n> https://github.com/kubernetes/kubernetes/pull/23666/files/7efdc3d36197f1ca452339d49abbc87163fb0e75#r58056775\n",
        "createdAt" : "2016-03-31T14:44:54Z",
        "updatedAt" : "2016-06-17T21:38:08Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "b67dc150-3918-4ec1-b584-2d8d69508ba8",
        "parentId" : "4c870e01-6c32-4507-a116-80f402a74cc1",
        "authorId" : "f81960f6-a033-4403-bebf-c8ebb484e444",
        "body" : "This really looks more like ~job/task/container-hooks despite the larger question.  In other systems they are tied to life-cycle events: \n- fetch (which we may or may not care about) \n- pre/init (this proposal/setup) \n- update (which we don't really do, but useful in batching/restart) \n- evict (sometimes treated separately, billing and what not) \n- exit (we probably want/tear-down) \n\ndunno if you want to address here or explicitly defer?\n",
        "createdAt" : "2016-03-31T20:04:20Z",
        "updatedAt" : "2016-06-17T21:38:08Z",
        "lastEditedBy" : "f81960f6-a033-4403-bebf-c8ebb484e444",
        "tags" : [
        ]
      },
      {
        "id" : "850ea10a-65c2-4073-a3d0-2335c0ec8c64",
        "parentId" : "4c870e01-6c32-4507-a116-80f402a74cc1",
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "I am strongly opposed to DAG.\n",
        "createdAt" : "2016-04-01T06:10:32Z",
        "updatedAt" : "2016-06-17T21:38:08Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "b4e32994-2d56-4c7b-9281-666f347d5c4f",
        "parentId" : "4c870e01-6c32-4507-a116-80f402a74cc1",
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "Other proposed hooks include preStart and postStop, at the container level: #140\n",
        "createdAt" : "2016-04-01T06:12:57Z",
        "updatedAt" : "2016-06-17T21:38:08Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "ded3b043-2426-4887-a4c0-27cf04a35dfd",
        "parentId" : "4c870e01-6c32-4507-a116-80f402a74cc1",
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "The container volume type @smarterclayton mentioned is covered by #831.\n\nSome considerations:\n- failure modes and failure handling\n- idempotence requirements of hooks\n- resource requirements\n- update semantics\n- composability\n",
        "createdAt" : "2016-04-01T06:16:55Z",
        "updatedAt" : "2016-06-17T21:38:08Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "ea59962f-dd21-464f-ba49-22744a008133",
        "parentId" : "4c870e01-6c32-4507-a116-80f402a74cc1",
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "Rough lifecycle sketch:\n- Fetch container images and images for image volumes\n- Mount volumes on host, as necessary\n- Create empty dirs, gitRepo, etc. and run containers for container-based volume initialization\n- Create main pod containers and mount volumes into mount ns\n- Run container preStart hooks\n- Run containers\n- Run container postStart hooks\n  ...\n",
        "createdAt" : "2016-04-01T06:22:35Z",
        "updatedAt" : "2016-06-17T21:38:08Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "a8c7dca9-b8a8-43e1-9b04-1552c3939dff",
        "parentId" : "4c870e01-6c32-4507-a116-80f402a74cc1",
        "authorId" : "f81960f6-a033-4403-bebf-c8ebb484e444",
        "body" : "> I am strongly opposed to DAG.\n\nhahaha - b/c its a sarlacc pit, but good to hear. \n",
        "createdAt" : "2016-04-01T13:09:46Z",
        "updatedAt" : "2016-06-17T21:38:08Z",
        "lastEditedBy" : "f81960f6-a033-4403-bebf-c8ebb484e444",
        "tags" : [
        ]
      },
      {
        "id" : "1a6638b2-0549-4cf8-ac3b-fb61ac786111",
        "parentId" : "4c870e01-6c32-4507-a116-80f402a74cc1",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Container volumes (which I would add details to this proposal for regardless), if we need that volume to be served by a process (vs merely initialized), that process has to be restartable and other containers have to block on that container being started (as long as we model that process in a pod container).  \n\nThat would imply an implicit DAG via container volumes.  Are we concerned with users abusing that to emulate general purpose DAG?  What affordances do we make there?\n",
        "createdAt" : "2016-04-02T21:51:16Z",
        "updatedAt" : "2016-06-17T21:38:08Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "cc9a9064-56ae-4dd1-b218-0125e63ecd2c",
        "parentId" : "4c870e01-6c32-4507-a116-80f402a74cc1",
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "#831 has evolved to cover 2 features:\n1. Image volumes: pull an image and mount it in. Would fill similar role as volumes-from in Docker and most uses of MPM within Google. Would enable file systems that are dynamically composed from multiple images. https://www.youtube.com/watch?v=_uJlTllziPI\n2. Container volumes: Execute an image to populate a volume. Maybe could subsume (1). I want to use this approach rather than create more volume sources similar to gitRepo. I could imagine using it to pull from private git repos, GCS, S3, etc.\n\nIf we wanted to support in-place updates, and I'm not sure we do, behavior should be identical to updates for downward API, configmap, and secret volumes. If attached to a volume, we could support atomic data updates.\n\nIf a container populating an emptyDir fails, it can be retried, by flushing the contents of the dir and creating a new one. That's more complicated with init containers, which presumably wouldn't be required to have a 1-to-1 relationship between container and volume.\n\nThis factoring also makes it more straightforward in the API to add an initialization container to a pod together with its corresponding volume.\n\nThat's not to say that I think init containers have no utility, but for the purpose of initializing volumes, they impair the system's ability to manage the process.\n",
        "createdAt" : "2016-04-08T20:05:30Z",
        "updatedAt" : "2016-06-17T21:38:08Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "f08207f0-6a4c-4b35-9892-9a8bf50b30e9",
        "parentId" : "4c870e01-6c32-4507-a116-80f402a74cc1",
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "Container volumes could also be initialized in parallel, if desired -- they would be independent, not a DAG.\n",
        "createdAt" : "2016-04-08T20:08:15Z",
        "updatedAt" : "2016-06-17T21:38:08Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "94d164b4-7908-4883-9e7f-f5865fb3c192",
        "parentId" : "4c870e01-6c32-4507-a116-80f402a74cc1",
        "authorId" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "body" : "+1 for https://github.com/kubernetes/kubernetes/pull/23666/files#r58118580\n\nShould we refer to this concept as pod level hooks instead, specifically pre-start hook instead?\n",
        "createdAt" : "2016-04-12T21:24:45Z",
        "updatedAt" : "2016-06-17T21:38:08Z",
        "lastEditedBy" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "tags" : [
        ]
      },
      {
        "id" : "84a10d39-55d5-42c3-8ebe-672458f3918a",
        "parentId" : "4c870e01-6c32-4507-a116-80f402a74cc1",
        "authorId" : "395f4f9a-98be-4485-b436-51f0897d7c9f",
        "body" : "The main problem with hooks is I must give the main container all the things required to run the initialization. The dig example below, requires me to install dig. I'd also like to keep the option open of using init containers to, eg: assign IPs to network interfaces. For that the \"system\" init container would need elvated privs. I think containers give us composability and a separation of concers at a level hooks don't. \n",
        "createdAt" : "2016-04-12T21:48:21Z",
        "updatedAt" : "2016-06-17T21:38:08Z",
        "lastEditedBy" : "395f4f9a-98be-4485-b436-51f0897d7c9f",
        "tags" : [
        ]
      },
      {
        "id" : "7657429b-8b38-4777-8720-4de7dce5c5a3",
        "parentId" : "4c870e01-6c32-4507-a116-80f402a74cc1",
        "authorId" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "body" : "Sorry if I was not clear. I was referring to hooks that run containers essentially. `s/init container/pod pre-start hook/g`\n",
        "createdAt" : "2016-04-12T23:50:41Z",
        "updatedAt" : "2016-06-17T21:38:08Z",
        "lastEditedBy" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "tags" : [
        ]
      },
      {
        "id" : "7ad594e9-30da-4625-89e2-4565ffed78ae",
        "parentId" : "4c870e01-6c32-4507-a116-80f402a74cc1",
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "Exec hooks could execute scripts or statically compiled binaries from any volume, which is another use case for image and container volumes.\n",
        "createdAt" : "2016-04-14T06:40:42Z",
        "updatedAt" : "2016-06-17T21:38:08Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "78bb32af-4b20-490d-9b2b-8e63891e1a3a",
        "parentId" : "4c870e01-6c32-4507-a116-80f402a74cc1",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Statically compiled binaries are still a vanishingly small percentage\nof workloads for all but a few languages.  The vast majority of hooks\nwill be dynamically linked.\n",
        "createdAt" : "2016-04-14T11:39:29Z",
        "updatedAt" : "2016-06-17T21:38:08Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "a5e0e6f0-1699-408a-ba77-2fd7add2f3ce",
        "parentId" : "4c870e01-6c32-4507-a116-80f402a74cc1",
        "authorId" : "f81960f6-a033-4403-bebf-c8ebb484e444",
        "body" : "@vishh  +1 for pre-start hook naming, it's consistent with other systems. \n",
        "createdAt" : "2016-04-15T15:54:56Z",
        "updatedAt" : "2016-06-17T21:38:08Z",
        "lastEditedBy" : "f81960f6-a033-4403-bebf-c8ebb484e444",
        "tags" : [
        ]
      },
      {
        "id" : "e75a4b3f-2b84-4154-bd98-323fc082a939",
        "parentId" : "4c870e01-6c32-4507-a116-80f402a74cc1",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Overall, would it be fair to say the following:\n1. Init containers can do what volume containers can do (today), but not as cleanly\n2. Init containers can do things that volume containers cannot or should not (order sequence and dependencies)\n3. We can add volume containers later without having to change init containers (other than to define that volume containers start before init containers)\n4. Some of the implementation details of volume containers are more complex than init containers, so strictly speaking it is probably easier to start with init containers\n5. People already approximate volume containers today in app containers, so an init container is strictly better than app containers for decoupling app decisions.\n\n?  If so, is there disagreement with doing init containers now, adding some details to this proposal that clarify where volume containers should go, and saying we'll do init containers first?\n",
        "createdAt" : "2016-04-15T16:21:58Z",
        "updatedAt" : "2016-06-17T21:38:08Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "097b357f-d50b-4ef1-83ea-1729df81eb88",
        "parentId" : "4c870e01-6c32-4507-a116-80f402a74cc1",
        "authorId" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "body" : "@smarterclayton +1 for your rationale. What is your thought on renaming \"init\" containers to be pod level \"pre-start\" hooks?\n",
        "createdAt" : "2016-04-18T22:12:30Z",
        "updatedAt" : "2016-06-17T21:38:08Z",
        "lastEditedBy" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "tags" : [
        ]
      },
      {
        "id" : "87ef86cb-1160-4d09-b18b-6dfab5fc0d71",
        "parentId" : "4c870e01-6c32-4507-a116-80f402a74cc1",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Thinking about this - hooks are (today) running in a container.  In\nOpenShift, we have deployment level hooks that create a pod.  We could\nimagine hooks that make TCP or HTTP requests in other contexts.\nPreStartContainers?  I think \"PreStart' is more consistent with existing\nAPI terminology than \"Init\".  On the other hand, would we add \"PostStop\"\ncontainers?  Is \"PreStart\" container hooks the same as a pre-start pod hook?\n\nOn Mon, Apr 18, 2016 at 6:12 PM, Vish Kannan notifications@github.com\nwrote:\n\n> In docs/proposals/container-init.md\n> https://github.com/kubernetes/kubernetes/pull/23666#discussion_r60143604\n> :\n> \n> > +\n> > +March 2016\n> > +\n> > +## Proposal and Motivation\n> > +\n> > +Within a pod there is a need to initialize local data or adapt to the current\n> > +cluster environment that is not easily achieved in the current container model.\n> > +Containers start in parallel after volumes are mounted, leaving no opportunity\n> > +for coordination between containers without specialization of the image. If\n> > +two containers need to share common initialization data, both images must\n> > +be altered to cooperate using filesystem or network semantics, which introduces\n> > +coupling between images. Likewise, if an image requires configuration in order\n> > +to start and that configuration is environment dependent, the image must be\n> > +altered to add the necessary templating or retrieval.\n> > +\n> > +This proposal introduces the concept of an **init container**, one or more\n> \n> @smarterclayton https://github.com/smarterclayton +1 for your\n> rationale. What is your thought on renaming \"init\" containers to be pod\n> level \"pre-start\" hooks?\n> \n> â€”\n> You are receiving this because you were mentioned.\n> Reply to this email directly or view it on GitHub\n> https://github.com/kubernetes/kubernetes/pull/23666/files/7efdc3d36197f1ca452339d49abbc87163fb0e75#r60143604\n",
        "createdAt" : "2016-04-20T15:34:15Z",
        "updatedAt" : "2016-06-17T21:38:08Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "4141adcf-9e13-4a6b-ba43-f72525472ac1",
        "parentId" : "4c870e01-6c32-4507-a116-80f402a74cc1",
        "authorId" : "395f4f9a-98be-4485-b436-51f0897d7c9f",
        "body" : "> Is \"PreStart\" container hooks the same as a pre-start pod hook?\n\nA pre start container hook would just be some bash that executes a binary in the container right? If I need to insert the binary in my container, I might as well invoke it in an entrypoint script. How much value does it add? \n\nInstead of stacking init containers at the pod level, we could just attach them to the specific container they're initializaing and call them PreStart container hooks. This feels less useful in a pod context, I'd want to wait till all containers in my pod are initialized before starting any part of the app.\n",
        "createdAt" : "2016-04-20T15:57:07Z",
        "updatedAt" : "2016-06-17T21:38:08Z",
        "lastEditedBy" : "395f4f9a-98be-4485-b436-51f0897d7c9f",
        "tags" : [
        ]
      },
      {
        "id" : "18454bc0-8e2a-44b5-bcfa-c882a33b5a37",
        "parentId" : "4c870e01-6c32-4507-a116-80f402a74cc1",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "@bprashanth responding to vish i was addressing renaming.  You seem to be addressing functional gap?  I thought we seemed to be ok on init container as pre app-container start, merely naming.\n",
        "createdAt" : "2016-04-20T16:05:54Z",
        "updatedAt" : "2016-06-17T21:38:08Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "f6e0bf98-7175-421e-81ed-3135c80d0ffc",
        "parentId" : "4c870e01-6c32-4507-a116-80f402a74cc1",
        "authorId" : "395f4f9a-98be-4485-b436-51f0897d7c9f",
        "body" : "Ack. Pardon my confusion, I was just making sure we weren't doing a pre start container hook instead.\n",
        "createdAt" : "2016-04-20T16:12:47Z",
        "updatedAt" : "2016-06-17T21:38:08Z",
        "lastEditedBy" : "395f4f9a-98be-4485-b436-51f0897d7c9f",
        "tags" : [
        ]
      },
      {
        "id" : "fb8587ba-9fd7-4c94-ba06-fb0786e56e9c",
        "parentId" : "4c870e01-6c32-4507-a116-80f402a74cc1",
        "authorId" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "body" : "@smarterclayton So what is the final decision? Is it going to stay as `init` containers or be renamed to `pre-start` containers?\n",
        "createdAt" : "2016-04-21T23:43:06Z",
        "updatedAt" : "2016-06-17T21:38:08Z",
        "lastEditedBy" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "tags" : [
        ]
      },
      {
        "id" : "224580af-dcd3-4832-87b6-626a2b56e9f2",
        "parentId" : "4c870e01-6c32-4507-a116-80f402a74cc1",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "I'm open - was waiting to see if others had a preference.\n",
        "createdAt" : "2016-04-22T01:39:42Z",
        "updatedAt" : "2016-06-17T21:38:08Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      }
    ],
    "commit" : "bdde25cf4395bca2aa56c661f95d2eaabfabd494",
    "line" : 48,
    "diffHunk" : "@@ -1,1 +46,50 @@altered to add the necessary templating or retrieval.\n\nThis proposal introduces the concept of an **init container**, one or more\ncontainers started in sequence before the pod's normal containers are started.\nThese init containers may share volumes, perform network operations, and perform"
  },
  {
    "id" : "c4933d6b-7175-4d80-82d3-f5ddbcadd0d8",
    "prId" : 23666,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3c3226c0-9b07-4c4a-af75-0979bae1f166",
        "parentId" : null,
        "authorId" : "0adf587c-aaa2-4e47-be0f-a26d4fde14ac",
        "body" : "What about adding a `StartCondition`? The start condition could be things like, `Container A is ready`, `Container B is successful`, or `Container C is exited`. Pros: (maybe) fewer new concepts; can represent arbitrary dags. Cons: adds lifecycle complexity, specifically complicates the restart policy; startup order less predictable.\nIs this what @timothysc proposed above?\n",
        "createdAt" : "2016-03-31T21:17:26Z",
        "updatedAt" : "2016-06-17T21:38:08Z",
        "lastEditedBy" : "0adf587c-aaa2-4e47-be0f-a26d4fde14ac",
        "tags" : [
        ]
      },
      {
        "id" : "a640e319-0adb-446e-9f1e-6abd11fec8cf",
        "parentId" : "3c3226c0-9b07-4c4a-af75-0979bae1f166",
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "Example issue: We support image updates. What should happen if we update the image of a container that other containers depend on? For that matter, if a container fails and restarts, what should happen to dependent containers?\n",
        "createdAt" : "2016-04-08T20:30:06Z",
        "updatedAt" : "2016-06-17T21:38:08Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      }
    ],
    "commit" : "bdde25cf4395bca2aa56c661f95d2eaabfabd494",
    "line" : 119,
    "diffHunk" : "@@ -1,1 +117,121 @@* Running a \"pre-pod\" would defeat the purpose of the pod being an atomic\n  unit of scheduling.\n\n\n## Design"
  },
  {
    "id" : "456d240f-46e9-4551-bf29-71a4f7c7e574",
    "prId" : 23666,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1335437f-9766-4afb-abba-5de67723f1e1",
        "parentId" : null,
        "authorId" : "0adf587c-aaa2-4e47-be0f-a26d4fde14ac",
        "body" : "Init containers probably need a concept of a timeout (e.g. never exit). What to do in the case of a timeout (e.g. restart, treat it as a failure?) should be defined.\n",
        "createdAt" : "2016-03-31T21:17:28Z",
        "updatedAt" : "2016-06-17T21:38:08Z",
        "lastEditedBy" : "0adf587c-aaa2-4e47-be0f-a26d4fde14ac",
        "tags" : [
        ]
      },
      {
        "id" : "a20dd7cf-3e80-4812-ba0c-f39edbdf0a19",
        "parentId" : "1335437f-9766-4afb-abba-5de67723f1e1",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "For \"never exit init container\" I think that requires a full dag with a\nStartCondition.  Do we want the full dag now, sometime soon, or later?  Are\npods ready to be dag'd?\n\nOn Thu, Mar 31, 2016 at 5:17 PM, Tim St. Clair notifications@github.com\nwrote:\n\n> In docs/proposals/container-init.md\n> https://github.com/kubernetes/kubernetes/pull/23666#discussion_r58129239\n> :\n> \n> > -  should itself be a container and modeled as such - we explicitly reject\n> > -  creating new mechanisms for running user processes.\n> >   +\\* The container pre-start hook (not yet implemented) requires execution within\n> > -  the container's image and so cannot adapt existing images. It also cannot\n> > -  block startup of containers\n> >   +\\* Running a \"pre-pod\" would defeat the purpose of the pod being an atomic\n> > -  unit of scheduling.\n> >   +\n> >   +\n> >   +## Design\n> >   +\n> >   +Each pod may have 0..N init containers defined along with the existing\n> >   +1..N app containers.\n> >   +\n> >   +On startup of the pod, after the network and volumes are initialized, the\n> >   +init containers are started in order. Each container must exit successfully\n> \n> Init containers probably need a concept of a timeout (e.g. never exit).\n> What to do in the case of a timeout (e.g. restart, treat it as a failure?)\n> should be defined.\n> \n> â€”\n> You are receiving this because you authored the thread.\n> Reply to this email directly or view it on GitHub\n> https://github.com/kubernetes/kubernetes/pull/23666/files/7efdc3d36197f1ca452339d49abbc87163fb0e75#r58129239\n",
        "createdAt" : "2016-03-31T21:25:45Z",
        "updatedAt" : "2016-06-17T21:38:08Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "4244a218-2c03-4f73-80f5-dab8631d6902",
        "parentId" : "1335437f-9766-4afb-abba-5de67723f1e1",
        "authorId" : "0adf587c-aaa2-4e47-be0f-a26d4fde14ac",
        "body" : "I meant more the error case where the init container got stuck and didn't exit. I don't think that would require the start condition?\n",
        "createdAt" : "2016-03-31T21:56:43Z",
        "updatedAt" : "2016-06-17T21:38:08Z",
        "lastEditedBy" : "0adf587c-aaa2-4e47-be0f-a26d4fde14ac",
        "tags" : [
        ]
      },
      {
        "id" : "dfc08fdc-3d6d-4658-99d8-5e3318286a08",
        "parentId" : "1335437f-9766-4afb-abba-5de67723f1e1",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Yes, that would not require a start condition.\n\nAnother question about DAG - is it generally more useful to support a full\nDAG flow (with full conditionals) under a single bucket of containers, or\nto divide into two phases (before initialized and after initialized) with a\nclear distinction between them?  This proposal can be seen as a direct\nstepping stone to the latter.\n\nI had hoped to make a small step towards allowing containers to prepare\nvolumes before other containers start (the changes for init container are\nmore deliberate than the DAG).  If we think a DAG is better it's probably\nunrealistic to try for this in 1.3, but I would like to try and make small,\nincremental steps towards it if we can.\n\nOn Thu, Mar 31, 2016 at 5:57 PM, Tim St. Clair notifications@github.com\nwrote:\n\n> In docs/proposals/container-init.md\n> https://github.com/kubernetes/kubernetes/pull/23666#discussion_r58134681\n> :\n> \n> > -  should itself be a container and modeled as such - we explicitly reject\n> > -  creating new mechanisms for running user processes.\n> >   +\\* The container pre-start hook (not yet implemented) requires execution within\n> > -  the container's image and so cannot adapt existing images. It also cannot\n> > -  block startup of containers\n> >   +\\* Running a \"pre-pod\" would defeat the purpose of the pod being an atomic\n> > -  unit of scheduling.\n> >   +\n> >   +\n> >   +## Design\n> >   +\n> >   +Each pod may have 0..N init containers defined along with the existing\n> >   +1..N app containers.\n> >   +\n> >   +On startup of the pod, after the network and volumes are initialized, the\n> >   +init containers are started in order. Each container must exit successfully\n> \n> I meant more the error case where the init container got stuck and didn't\n> exit. I don't think that would require the start condition?\n> \n> â€”\n> You are receiving this because you authored the thread.\n> Reply to this email directly or view it on GitHub\n> https://github.com/kubernetes/kubernetes/pull/23666/files/7efdc3d36197f1ca452339d49abbc87163fb0e75#r58134681\n",
        "createdAt" : "2016-03-31T22:05:16Z",
        "updatedAt" : "2016-06-17T21:38:08Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "e34ac876-8277-4d67-bea3-dcc658ed7b75",
        "parentId" : "1335437f-9766-4afb-abba-5de67723f1e1",
        "authorId" : "0adf587c-aaa2-4e47-be0f-a26d4fde14ac",
        "body" : "I think we should think about what the ideal end state is. It's not clear to me that the implementation of this model is that much simpler than startup dependencies, and it might add an unnecessary maintenance burden. On the other hand, we may not want to accept the full burden of responsibility that comes with the graph model (e.g. loop detection? Or do we want to allow a turing-complete pod lifecycle :P )\n",
        "createdAt" : "2016-03-31T22:17:34Z",
        "updatedAt" : "2016-06-17T21:38:08Z",
        "lastEditedBy" : "0adf587c-aaa2-4e47-be0f-a26d4fde14ac",
        "tags" : [
        ]
      },
      {
        "id" : "8005cda0-3db2-49ea-9227-7dab3ad5c077",
        "parentId" : "1335437f-9766-4afb-abba-5de67723f1e1",
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "We don't want arbitrary DAGs.\n",
        "createdAt" : "2016-04-08T20:33:27Z",
        "updatedAt" : "2016-06-17T21:38:08Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "864d7cb3-7062-4ad7-b83a-4e9e0af61cf4",
        "parentId" : "1335437f-9766-4afb-abba-5de67723f1e1",
        "authorId" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "body" : "Is ordering necessary for init containers?\n",
        "createdAt" : "2016-04-12T21:37:00Z",
        "updatedAt" : "2016-06-17T21:38:08Z",
        "lastEditedBy" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "tags" : [
        ]
      },
      {
        "id" : "8638d89d-77ec-4da0-921c-ee23421a7ce4",
        "parentId" : "1335437f-9766-4afb-abba-5de67723f1e1",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "For usability I think ordering is valuable.  It allows you to chain two\nrelated but distinct actions in a predictable way.  Without DAG, and\nwithout a defined order, you can't perform useful composition of init\ncontainer actions.\n\nOn Tue, Apr 12, 2016 at 5:37 PM, Vish Kannan notifications@github.com\nwrote:\n\n> In docs/proposals/container-init.md\n> https://github.com/kubernetes/kubernetes/pull/23666#discussion_r59458583\n> :\n> \n> > -  should itself be a container and modeled as such - we explicitly reject\n> > -  creating new mechanisms for running user processes.\n> >   +\\* The container pre-start hook (not yet implemented) requires execution within\n> > -  the container's image and so cannot adapt existing images. It also cannot\n> > -  block startup of containers\n> >   +\\* Running a \"pre-pod\" would defeat the purpose of the pod being an atomic\n> > -  unit of scheduling.\n> >   +\n> >   +\n> >   +## Design\n> >   +\n> >   +Each pod may have 0..N init containers defined along with the existing\n> >   +1..N app containers.\n> >   +\n> >   +On startup of the pod, after the network and volumes are initialized, the\n> >   +init containers are started in order. Each container must exit successfully\n> \n> Is ordering necessary for init containers?\n> \n> â€”\n> You are receiving this because you were mentioned.\n> Reply to this email directly or view it on GitHub\n> https://github.com/kubernetes/kubernetes/pull/23666/files/7efdc3d36197f1ca452339d49abbc87163fb0e75#r59458583\n",
        "createdAt" : "2016-04-12T21:49:34Z",
        "updatedAt" : "2016-06-17T21:38:08Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "23256fa3-f564-457a-b75e-4ca1b026d832",
        "parentId" : "1335437f-9766-4afb-abba-5de67723f1e1",
        "authorId" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "body" : "Are there are use cases for multiple init containers today?\n",
        "createdAt" : "2016-04-12T23:51:23Z",
        "updatedAt" : "2016-06-17T21:38:08Z",
        "lastEditedBy" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "tags" : [
        ]
      },
      {
        "id" : "ea6b5f7f-69cb-47c2-9365-c1a20dc54d1b",
        "parentId" : "1335437f-9766-4afb-abba-5de67723f1e1",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "1. Download then wait\n2. Wait for dependencies then register (to get secret) then download with secret\n3. Access docker daemon as priviliged and then run as regular user to\n   complete setup\n\nNone truly require multiple, but most pod use cases only require one container.\n",
        "createdAt" : "2016-04-13T00:05:16Z",
        "updatedAt" : "2016-06-17T21:38:08Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "38e1f1e2-4590-4e67-a849-5a1a425a60d6",
        "parentId" : "1335437f-9766-4afb-abba-5de67723f1e1",
        "authorId" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "body" : "If we don't have a **need** for multiple containers, can we just punt on that for now?\n",
        "createdAt" : "2016-04-13T00:15:02Z",
        "updatedAt" : "2016-06-17T21:38:08Z",
        "lastEditedBy" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "tags" : [
        ]
      },
      {
        "id" : "d7d938cf-c555-40dc-9bf9-e7a37e942b13",
        "parentId" : "1335437f-9766-4afb-abba-5de67723f1e1",
        "authorId" : "395f4f9a-98be-4485-b436-51f0897d7c9f",
        "body" : "It would be nice to give people a \"last init container blocking on babysitter handshake\" type thing. That is only one implementation, I can imagin multiple ways to do this. I think the common case will be one, but it might also encourage a monolithic init (eg: shoving db init and webserver config into a single container makes it less composable). \n",
        "createdAt" : "2016-04-13T00:18:30Z",
        "updatedAt" : "2016-06-17T21:38:08Z",
        "lastEditedBy" : "395f4f9a-98be-4485-b436-51f0897d7c9f",
        "tags" : [
        ]
      },
      {
        "id" : "80efd1bc-bbfd-44ba-8cfb-3225d444fe1b",
        "parentId" : "1335437f-9766-4afb-abba-5de67723f1e1",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "I would prefer not to encourage monolithic init containers, and from\nan API perspective I'd rather have the option to separate execution by\nrole (privileged vs not), which a single init container will be poor\nat.  My build example very clearly wants to partition fetching\nbinaries from accessing the docker socket.\n\nI don't think multiple init containers is harder for users to\nunderstand, so if it comes down to slightly higher complexity to trade\noff for future flexibility I don't think a single init container is\nsufficiently easier to implement / reason about.\n",
        "createdAt" : "2016-04-13T00:22:46Z",
        "updatedAt" : "2016-06-17T21:38:08Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "7c9dde99-e407-4c3b-a0ea-7b3b6f63fb9f",
        "parentId" : "1335437f-9766-4afb-abba-5de67723f1e1",
        "authorId" : "a6409368-42e0-44a9-bf79-9d3042ac3b65",
        "body" : "I agreed with @smarterclayton not having a monolithic init containers, which makes the init containers hard to use and debug. But on another side, for the initial implementation before we iron out all issues, could we only support single init container?\n\n@bprashanth you mentioned that in your PetSet use case, you want to have two init containers, could you please share with us more details? \n",
        "createdAt" : "2016-04-14T21:25:30Z",
        "updatedAt" : "2016-06-17T21:38:08Z",
        "lastEditedBy" : "a6409368-42e0-44a9-bf79-9d3042ac3b65",
        "tags" : [
        ]
      },
      {
        "id" : "48c897a9-1289-41bf-a40c-f06bb36893e2",
        "parentId" : "1335437f-9766-4afb-abba-5de67723f1e1",
        "authorId" : "395f4f9a-98be-4485-b436-51f0897d7c9f",
        "body" : "That's what I described in my previous comment: https://github.com/kubernetes/kubernetes/pull/23666/files/7efdc3d36197f1ca452339d49abbc87163fb0e75#r59476265. \n\nOf course anything we can do with N we can do with 1 and a TODO. \n",
        "createdAt" : "2016-04-14T21:30:50Z",
        "updatedAt" : "2016-06-17T21:38:08Z",
        "lastEditedBy" : "395f4f9a-98be-4485-b436-51f0897d7c9f",
        "tags" : [
        ]
      },
      {
        "id" : "62b8a7fa-4b7e-4fbb-ba4d-5de7b36d47d3",
        "parentId" : "1335437f-9766-4afb-abba-5de67723f1e1",
        "authorId" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "body" : "@smarterclayton It will be better if we get dind to work instead of providing access to the docker daemon. But that's unrelated to this conversation.\n\n> I don't think multiple init containers is harder for users to\n> understand, so if it comes down to slightly higher complexity to trade\n> off for future flexibility I don't think a single init container is\n> sufficiently easier to implement / reason about.\n\nAs @dchen1107 said, the want is to start with slightly lesser complexity. We can always introduce support for multiple containers based on how this feature gets consumed.\n",
        "createdAt" : "2016-04-14T21:31:36Z",
        "updatedAt" : "2016-06-17T21:38:08Z",
        "lastEditedBy" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "tags" : [
        ]
      },
      {
        "id" : "a5c1734f-7f7f-4af1-a223-b69679fbfc07",
        "parentId" : "1335437f-9766-4afb-abba-5de67723f1e1",
        "authorId" : "395f4f9a-98be-4485-b436-51f0897d7c9f",
        "body" : "Can you elaborate on the complexity tradeoff here? \nHaving looked at the implementation, I don't get why we're pushing back on a list. If it's complexity, it doesn't look like much. \n",
        "createdAt" : "2016-04-14T23:00:20Z",
        "updatedAt" : "2016-06-17T21:38:08Z",
        "lastEditedBy" : "395f4f9a-98be-4485-b436-51f0897d7c9f",
        "tags" : [
        ]
      },
      {
        "id" : "da3f1831-03dd-4dc2-89fb-a893ac0c6ffc",
        "parentId" : "1335437f-9766-4afb-abba-5de67723f1e1",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Having done _an_ implementation, I don't think single container is less work than multiple container.  So purely user and definition complexity should be relevant.  I am in favor of multiple containers for flexibility for the same reason pods have multiple containers - 80% of the time one container is enough, but sometimes composition is superior to inheritance.\n",
        "createdAt" : "2016-04-15T16:36:49Z",
        "updatedAt" : "2016-06-17T21:38:08Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "e1e1141f-eaef-4f39-9e6f-91936ef7e21c",
        "parentId" : "1335437f-9766-4afb-abba-5de67723f1e1",
        "authorId" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "body" : "@smarterclayton If we have data that points out that multiple containers are necessary/ideal in real user scenarios, lets go for it. Let's just not add cognitive & technical complexity just because we can.\n",
        "createdAt" : "2016-04-18T22:15:54Z",
        "updatedAt" : "2016-06-17T21:38:08Z",
        "lastEditedBy" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "tags" : [
        ]
      }
    ],
    "commit" : "bdde25cf4395bca2aa56c661f95d2eaabfabd494",
    "line" : null,
    "diffHunk" : "@@ -1,1 +125,129 @@\nOn startup of the pod, after the network and volumes are initialized, the\ninit containers are started in order. Each container must exit successfully\nbefore the next is invoked. If a container fails to start (due to the runtime)\nor exits with failure, it is retried according to the pod RestartPolicy."
  },
  {
    "id" : "ed1c4c49-29c3-4b6b-98f8-ebd9a200fc7b",
    "prId" : 23666,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6931933f-ad81-48b4-9e29-f119bb2c5cee",
        "parentId" : null,
        "authorId" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "body" : "If kubelet restarted before starting the regular (non-init) containers, how would it know whether the init containers have run or not. Is it going to rely on checking the dead containers?\n",
        "createdAt" : "2016-03-31T22:20:34Z",
        "updatedAt" : "2016-06-17T21:38:08Z",
        "lastEditedBy" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "tags" : [
        ]
      },
      {
        "id" : "9aa95e18-2885-4731-be4e-a153848438a9",
        "parentId" : "6931933f-ad81-48b4-9e29-f119bb2c5cee",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "We could mark the infra container, but I started with leaving the init\ncontainer in place which allows logs to function.  The build use case\nmentioned desires to commit the init container.\n",
        "createdAt" : "2016-03-31T22:58:14Z",
        "updatedAt" : "2016-06-17T21:38:08Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "a1c4e119-bd6c-4d65-8799-caccae4381e3",
        "parentId" : "6931933f-ad81-48b4-9e29-f119bb2c5cee",
        "authorId" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "body" : "Essentially, unless the pod environment changes in the Spec, we don't have to re-run init containers right?\nEven for PodSpec updates, would we ever want to whitelist the changes to the Spec that will warrant re-running init containers, because of cost or latency for example?\n",
        "createdAt" : "2016-04-12T21:39:18Z",
        "updatedAt" : "2016-06-17T21:38:08Z",
        "lastEditedBy" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "tags" : [
        ]
      },
      {
        "id" : "9839f1c6-0368-4beb-8f13-4576b0c98fdd",
        "parentId" : "6931933f-ad81-48b4-9e29-f119bb2c5cee",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Yes, will clarify.\n\nOn Tue, Apr 12, 2016 at 5:39 PM, Vish Kannan notifications@github.com\nwrote:\n\n> In docs/proposals/container-init.md\n> https://github.com/kubernetes/kubernetes/pull/23666#discussion_r59458926\n> :\n> \n> > +\n> > +On startup of the pod, after the network and volumes are initialized, the\n> > +init containers are started in order. Each container must exit successfully\n> > +before the next is invoked. If a container fails to start, it is retried\n> > +according to the pod RestartPolicy. RestartPolicyNever pods will immediately\n> > +fail and exit. RestartPolicyAlways pods will retry the failing init container\n> > +with increasing backoff until it succeeds. Future revisions of this spec may\n> > +add the ability for an init container to define a limited container restart\n> > +policy distinct from the pod RestartPolicy.\n> > +\n> > +A pod cannot be ready until all init containers have succeeded. The ports\n> > +on an init container are not aggregated under a service. A pod that is\n> > +being initialized is in the `Pending` phase but should have a distinct\n> > +condition.\n> > +\n> > +If the pod is \"restarted\" all containers stopped and started due to\n> \n> Essentially, unless the pod environment changes in the Spec, we don't have\n> to re-run init containers right?\n> \n> â€”\n> You are receiving this because you were mentioned.\n> Reply to this email directly or view it on GitHub\n> https://github.com/kubernetes/kubernetes/pull/23666/files/7efdc3d36197f1ca452339d49abbc87163fb0e75#r59458926\n",
        "createdAt" : "2016-04-12T21:49:56Z",
        "updatedAt" : "2016-06-17T21:38:08Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "c17a474b-eaf5-45ca-b328-ccf778da5433",
        "parentId" : "6931933f-ad81-48b4-9e29-f119bb2c5cee",
        "authorId" : "a6409368-42e0-44a9-bf79-9d3042ac3b65",
        "body" : "Could we define a pod restarted here? When a pause container is restarted, should all init containers re-run again?\n",
        "createdAt" : "2016-04-14T00:25:26Z",
        "updatedAt" : "2016-06-17T21:38:08Z",
        "lastEditedBy" : "a6409368-42e0-44a9-bf79-9d3042ac3b65",
        "tags" : [
        ]
      },
      {
        "id" : "8e013159-ea6a-41f9-947a-f229959da5c3",
        "parentId" : "6931933f-ad81-48b4-9e29-f119bb2c5cee",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Will define.\n",
        "createdAt" : "2016-04-15T00:23:46Z",
        "updatedAt" : "2016-06-17T21:38:08Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      }
    ],
    "commit" : "bdde25cf4395bca2aa56c661f95d2eaabfabd494",
    "line" : null,
    "diffHunk" : "@@ -1,1 +142,146 @@If the pod is restarted, the `Initializing` condition should be set to `false.\n\nIf the pod is \"restarted\" all containers stopped and started due to\na node restart, change to the pod definition, or admin interaction, all\ninit containers must execute again. Restartable conditions are defined as:"
  },
  {
    "id" : "7328113f-e665-4c40-8a12-a05142c11c30",
    "prId" : 23666,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bb66d3f7-9b14-4af1-86fd-b08494577f97",
        "parentId" : null,
        "authorId" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "body" : "Does this mean kubelet should GC failed init containers differently? \n",
        "createdAt" : "2016-03-31T22:26:44Z",
        "updatedAt" : "2016-06-17T21:38:08Z",
        "lastEditedBy" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "tags" : [
        ]
      },
      {
        "id" : "912b4d58-9c57-49bd-97ba-d8b1c8f2a4d7",
        "parentId" : "bb66d3f7-9b14-4af1-86fd-b08494577f97",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "I think so - in my prototype I was explicitly managing that in SyncPod\nstartup, although GC could control it.\n",
        "createdAt" : "2016-03-31T22:59:05Z",
        "updatedAt" : "2016-06-17T21:38:08Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "b248ba97-c017-4710-9b08-a1c5c17f076f",
        "parentId" : "bb66d3f7-9b14-4af1-86fd-b08494577f97",
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "How do we expect users to debug failed init containers? It seems like we need to ensure the logs of the last failure are available.\n",
        "createdAt" : "2016-04-08T20:59:02Z",
        "updatedAt" : "2016-06-17T21:38:08Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "3d58d95d-c88c-468b-a9f7-1503a52c8479",
        "parentId" : "bb66d3f7-9b14-4af1-86fd-b08494577f97",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "That was my expectation, will adjust.\n\nOn Fri, Apr 8, 2016 at 4:59 PM, Brian Grant notifications@github.com\nwrote:\n\n> In docs/proposals/container-init.md\n> https://github.com/kubernetes/kubernetes/pull/23666#discussion_r59088389\n> :\n> \n> > +\n> > +Container runtimes should treat the set of init and app containers as one\n> > +large pool. An individual init container execution should be identical to\n> > +an app container.\n> > +\n> > +All app container operations are permitted on init containers. The\n> > +logs for an init container should be available for the duration of the pod\n> > +lifetime or until the pod is restarted.\n> > +\n> > +During initialization, app container status should be shown with the reason\n> > +PodInitializing if any init containers are present. Each init container\n> > +should show appropriate container status, and all init containers that are\n> > +waiting for earlier init containers to finish should have the `reason`\n> > +PendingInitialization.\n> > +\n> > +The container runtime should aggressively prune failed init containers.\n> \n> How do we expect users to debug failed init containers? It seems like we\n> need to ensure the logs of the last failure are available.\n> \n> â€”\n> You are receiving this because you were mentioned.\n> Reply to this email directly or view it on GitHub\n> https://github.com/kubernetes/kubernetes/pull/23666/files/7efdc3d36197f1ca452339d49abbc87163fb0e75#r59088389\n",
        "createdAt" : "2016-04-12T21:47:34Z",
        "updatedAt" : "2016-06-17T21:38:08Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "8e173c28-56f7-4b27-aed8-0c31fe45e444",
        "parentId" : "bb66d3f7-9b14-4af1-86fd-b08494577f97",
        "authorId" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "body" : "Yes, if you aggressively prune the failed containers yourself, accessing the logs will be difficult. I'd rather letting GC handle this and treat them as regular containers. This should also avoid adding more complexity in the code.\n",
        "createdAt" : "2016-04-12T21:48:50Z",
        "updatedAt" : "2016-06-17T21:38:08Z",
        "lastEditedBy" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "tags" : [
        ]
      },
      {
        "id" : "49821313-0a6b-45ec-a103-9a2bde1ad959",
        "parentId" : "bb66d3f7-9b14-4af1-86fd-b08494577f97",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "The assumption would be that we _must_ have the most recent failed/started\ncontainer available for end users until the pod is restarted, although you\ncould argue that after a period of time we could GC those init container\ninstances to reclaim space.\n\nOn Tue, Apr 12, 2016 at 5:49 PM, Yu-Ju Hong notifications@github.com\nwrote:\n\n> In docs/proposals/container-init.md\n> https://github.com/kubernetes/kubernetes/pull/23666#discussion_r59460345\n> :\n> \n> > +\n> > +Container runtimes should treat the set of init and app containers as one\n> > +large pool. An individual init container execution should be identical to\n> > +an app container.\n> > +\n> > +All app container operations are permitted on init containers. The\n> > +logs for an init container should be available for the duration of the pod\n> > +lifetime or until the pod is restarted.\n> > +\n> > +During initialization, app container status should be shown with the reason\n> > +PodInitializing if any init containers are present. Each init container\n> > +should show appropriate container status, and all init containers that are\n> > +waiting for earlier init containers to finish should have the `reason`\n> > +PendingInitialization.\n> > +\n> > +The container runtime should aggressively prune failed init containers.\n> \n> Yes, if you aggressively prune the failed containers yourself, accessing\n> the logs will be difficult. I'd rather letting GC handle this and treat\n> them as regular containers. This should also avoid adding more complexity\n> in the code.\n> \n> â€”\n> You are receiving this because you were mentioned.\n> Reply to this email directly or view it on GitHub\n> https://github.com/kubernetes/kubernetes/pull/23666/files/7efdc3d36197f1ca452339d49abbc87163fb0e75#r59460345\n",
        "createdAt" : "2016-04-12T21:53:22Z",
        "updatedAt" : "2016-06-17T21:38:08Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "ea155e9f-621b-4f98-abbb-339d71bbdd39",
        "parentId" : "bb66d3f7-9b14-4af1-86fd-b08494577f97",
        "authorId" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "body" : "Until we decouple logs from container instances, we might have to reap containers on a need basis. We can have the existing container GC policy prefer init containers.\n",
        "createdAt" : "2016-04-12T21:55:46Z",
        "updatedAt" : "2016-06-17T21:38:08Z",
        "lastEditedBy" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "tags" : [
        ]
      }
    ],
    "commit" : "bdde25cf4395bca2aa56c661f95d2eaabfabd494",
    "line" : 309,
    "diffHunk" : "@@ -1,1 +307,311 @@PendingInitialization.\n\nThe container runtime should aggressively prune failed init containers.\nThe container runtime should record whether all init containers have\nsucceeded internally, and only invoke new init containers if a pod"
  },
  {
    "id" : "8d6724ae-44cd-4ae4-8682-7f02a6cc8c72",
    "prId" : 23666,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1216f5f7-e272-4504-a439-c324e97269b6",
        "parentId" : null,
        "authorId" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "body" : "By recording, do you mean in-memory state that will not survive restarts?\n",
        "createdAt" : "2016-03-31T22:28:04Z",
        "updatedAt" : "2016-06-17T21:38:08Z",
        "lastEditedBy" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "tags" : [
        ]
      },
      {
        "id" : "f740e879-ed6a-49bc-9ac5-6655ca37f92b",
        "parentId" : "1216f5f7-e272-4504-a439-c324e97269b6",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Yeah, best effort like we have for containers. No guarantee we don't\nexecute the init container twice. V\n",
        "createdAt" : "2016-03-31T23:00:00Z",
        "updatedAt" : "2016-06-17T21:38:08Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "aa4df13a-9d3f-48e3-b45c-c42d41d805b8",
        "parentId" : "1216f5f7-e272-4504-a439-c324e97269b6",
        "authorId" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "body" : "@smarterclayton Should we mention the fact that init containers have to be idempotent explicitly?\n",
        "createdAt" : "2016-04-12T21:58:07Z",
        "updatedAt" : "2016-06-17T21:38:08Z",
        "lastEditedBy" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "tags" : [
        ]
      },
      {
        "id" : "fdf0ec95-f660-4a6c-bcbb-70070abbd0a6",
        "parentId" : "1216f5f7-e272-4504-a439-c324e97269b6",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Yes, to make it clear (there has been no disagreement so far that they can\nbe executed multiple times).\n\nOn Tue, Apr 12, 2016 at 5:58 PM, Vish Kannan notifications@github.com\nwrote:\n\n> In docs/proposals/container-init.md\n> https://github.com/kubernetes/kubernetes/pull/23666#discussion_r59461605\n> :\n> \n> > +large pool. An individual init container execution should be identical to\n> > +an app container.\n> > +\n> > +All app container operations are permitted on init containers. The\n> > +logs for an init container should be available for the duration of the pod\n> > +lifetime or until the pod is restarted.\n> > +\n> > +During initialization, app container status should be shown with the reason\n> > +PodInitializing if any init containers are present. Each init container\n> > +should show appropriate container status, and all init containers that are\n> > +waiting for earlier init containers to finish should have the `reason`\n> > +PendingInitialization.\n> > +\n> > +The container runtime should aggressively prune failed init containers.\n> > +The container runtime should record whether all init containers have\n> > +succeeded internally, and only invoke new init containers if a pod\n> \n> @smarterclayton https://github.com/smarterclayton Should we mention the\n> fact that init containers have to be idempotent explicitly?\n> \n> â€”\n> You are receiving this because you were mentioned.\n> Reply to this email directly or view it on GitHub\n> https://github.com/kubernetes/kubernetes/pull/23666/files/7efdc3d36197f1ca452339d49abbc87163fb0e75#r59461605\n",
        "createdAt" : "2016-04-12T22:03:34Z",
        "updatedAt" : "2016-06-17T21:38:08Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      }
    ],
    "commit" : "bdde25cf4395bca2aa56c661f95d2eaabfabd494",
    "line" : 311,
    "diffHunk" : "@@ -1,1 +309,313 @@The container runtime should aggressively prune failed init containers.\nThe container runtime should record whether all init containers have\nsucceeded internally, and only invoke new init containers if a pod\nrestart is needed (for Docker, if all containers terminate or if the pod\ninfra container terminates). Init containers should follow backoff rules"
  },
  {
    "id" : "b35f0860-110e-45dc-8df6-19633af9cf89",
    "prId" : 23666,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "03670722-21bc-410e-a9dc-bbad5e79b4c1",
        "parentId" : null,
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "I still think #831 is preferable for that.\n",
        "createdAt" : "2016-04-01T06:23:21Z",
        "updatedAt" : "2016-06-17T21:38:08Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "888764f4-0877-46ed-9fbb-dff69c4e7217",
        "parentId" : "03670722-21bc-410e-a9dc-bbad5e79b4c1",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "For shared volumes do are you concerned that this proposal would\nblock, limit, or complicate the efficacy / use of shared volumes?  I\nwould view the container volume as additive on top of this, but with\nsome orthogonal concerns this proposal does not require changes to\naddress (long running \"init\" container, implicit start order,\nprecondition order, may require chain restarts on docker if the\ncontainer provider is restarted, much more complex changes to the\nkubelet and volume code).\n\nContainer volumes (vs image volumes) require a virtual DAG\nimplementation for restart, except that users cannot set\npreconditions.  Would container volumes that run forever (fuse\nproviding volume) be considered an init container?  I'd argue it does\nnot sound like that, so if it was a regular container we would have a\nlimited DAG in the pod containers spec.  If we have a limited DAG,\nusers can then construct deeper dependencies and abuse the DAG.\n",
        "createdAt" : "2016-04-01T14:43:16Z",
        "updatedAt" : "2016-06-17T21:38:08Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "59801e8e-3ad4-4f87-abfc-0713348c13d0",
        "parentId" : "03670722-21bc-410e-a9dc-bbad5e79b4c1",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "I'll amend that to we would have a start / readiness precondition DAG if a fuse container was modeled with container volume defining the dependency.\n",
        "createdAt" : "2016-04-01T14:44:29Z",
        "updatedAt" : "2016-06-17T21:38:08Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "36de3eee-f204-4932-8401-dd0c20b9cda4",
        "parentId" : "03670722-21bc-410e-a9dc-bbad5e79b4c1",
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "If init containers execute after all volumes have been mounted and initialized, it shouldn't preclude implementation of #831, no.\n",
        "createdAt" : "2016-04-08T20:31:31Z",
        "updatedAt" : "2016-06-17T21:38:08Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      }
    ],
    "commit" : "bdde25cf4395bca2aa56c661f95d2eaabfabd494",
    "line" : 64,
    "diffHunk" : "@@ -1,1 +62,66 @@\n* Init containers should be able to:\n  * Perform initialization of shared volumes\n    * Download binaries that will be used in app containers as execution targets\n    * Inject configuration or extension capability to generic images at startup"
  },
  {
    "id" : "40fe7696-de3c-4929-a9ca-a5b67ff4ca3d",
    "prId" : 23666,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bcb7f32e-791c-4177-9dfc-eba48108b988",
        "parentId" : null,
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "I think there are (at least) 3 categories of \"init\" actions:\n1. Fetch data into volumes. Better served by #831 IMO, but if this is the only hammer we're building, it could also pound that screw.\n2. Perform context-specific transformations of volume data, likely out-of-place, and other one-time config generation (perhaps using downward-API data). I thik this is usually container-specific rather than volume-specific, and perhaps could be done with a preStart hook (maybe leveraging a script mounted from a volume), if we had preStart hooks. Again, could be done by an init container in lieu of preStart hooks, though the separation of the init container and consuming container in the spec could be awkward.\n3. Perform \"read-only\" pre-start actions, like registration and delaying startup. Ideal for a pod-level init container.\n",
        "createdAt" : "2016-04-08T20:26:18Z",
        "updatedAt" : "2016-06-17T21:38:08Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      }
    ],
    "commit" : "bdde25cf4395bca2aa56c661f95d2eaabfabd494",
    "line" : null,
    "diffHunk" : "@@ -1,1 +69,73 @@      schema info.\n  * Delay the startup of application containers until preconditions are met\n  * Register the pod with other components of the system\n* Reduce coupling:\n  * Between application images, eliminating the need to customize those images for"
  },
  {
    "id" : "85d9c0ff-0bdd-4dd0-adf0-d0e5aa4b6848",
    "prId" : 23666,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f5244ee0-1902-4268-ba27-9c56eaa77861",
        "parentId" : null,
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "It could, by executing code/scripts from volumes.\n",
        "createdAt" : "2016-04-08T20:28:35Z",
        "updatedAt" : "2016-06-17T21:38:08Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "af03cea3-87d3-4bcc-a295-3fcf9dc7623e",
        "parentId" : "f5244ee0-1902-4268-ba27-9c56eaa77861",
        "authorId" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "body" : "Is one of the implied goals, to enable use of containers instead of scripts stored in volumes?\n",
        "createdAt" : "2016-04-12T21:30:27Z",
        "updatedAt" : "2016-06-17T21:38:08Z",
        "lastEditedBy" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "tags" : [
        ]
      }
    ],
    "commit" : "bdde25cf4395bca2aa56c661f95d2eaabfabd494",
    "line" : 114,
    "diffHunk" : "@@ -1,1 +112,116 @@  should itself be a container and modeled as such - we explicitly reject\n  creating new mechanisms for running user processes.\n* The container pre-start hook (not yet implemented) requires execution within\n  the container's image and so cannot adapt existing images. It also cannot\n  block startup of containers"
  },
  {
    "id" : "402dbe45-6af9-4432-a60d-eed858ec0687",
    "prId" : 23666,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ed276a2e-70fa-42ba-8169-3a10b55f44d7",
        "parentId" : null,
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "Do these have to be the same N?\n",
        "createdAt" : "2016-04-08T20:32:10Z",
        "updatedAt" : "2016-06-17T21:38:08Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "df59c21a-9de6-404f-8c00-01ca6b3785e3",
        "parentId" : "ed276a2e-70fa-42ba-8169-3a10b55f44d7",
        "authorId" : "6eca0ade-9879-4dd7-ad14-547e16f5c041",
        "body" : "I think N should be different.\n",
        "createdAt" : "2016-04-12T18:10:30Z",
        "updatedAt" : "2016-06-17T21:38:08Z",
        "lastEditedBy" : "6eca0ade-9879-4dd7-ad14-547e16f5c041",
        "tags" : [
        ]
      }
    ],
    "commit" : "bdde25cf4395bca2aa56c661f95d2eaabfabd494",
    "line" : 123,
    "diffHunk" : "@@ -1,1 +121,125 @@## Design\n\nEach pod may have 0..N init containers defined along with the existing\n1..M app containers.\n"
  },
  {
    "id" : "ea594476-89ce-4bab-81df-eabba735c914",
    "prId" : 23666,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "18ea735c-897e-4fb4-8034-d34c91de2cdb",
        "parentId" : null,
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "and all the normal containers should be Waiting\n",
        "createdAt" : "2016-04-08T20:37:00Z",
        "updatedAt" : "2016-06-17T21:38:08Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      }
    ],
    "commit" : "bdde25cf4395bca2aa56c661f95d2eaabfabd494",
    "line" : null,
    "diffHunk" : "@@ -1,1 +136,140 @@A pod cannot be ready until all init containers have succeeded. The ports\non an init container are not aggregated under a service. A pod that is\nbeing initialized is in the `Pending` phase but should have a distinct\ncondition. Each app container and all future init containers should have\nthe reason `PodInitializing`. The pod should have a condition `Initializing`"
  },
  {
    "id" : "8b3b1b0a-f044-49dc-926c-669caf79a339",
    "prId" : 23666,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3c923442-0641-4d04-8432-c8926c60739e",
        "parentId" : null,
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "Image changes for regular containers should only affect the updated containers.\n\nWe should probably disallow updates to init containers initially.\n",
        "createdAt" : "2016-04-08T20:38:09Z",
        "updatedAt" : "2016-06-17T21:38:08Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "74769971-1e5e-4bf6-9c7c-501dde90c92d",
        "parentId" : "3c923442-0641-4d04-8432-c8926c60739e",
        "authorId" : "6eca0ade-9879-4dd7-ad14-547e16f5c041",
        "body" : "It seems to me that if you change the image name for a pod, you may also change the init container image.\n",
        "createdAt" : "2016-04-12T18:14:58Z",
        "updatedAt" : "2016-06-17T21:38:08Z",
        "lastEditedBy" : "6eca0ade-9879-4dd7-ad14-547e16f5c041",
        "tags" : [
        ]
      },
      {
        "id" : "b4f27f22-d8cc-4ee4-8d80-5b3c7e57c869",
        "parentId" : "3c923442-0641-4d04-8432-c8926c60739e",
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "Changing the image name on a regular container of a pod with a restart policy other than Never just causes that one container to restart. Changing the image name on an init container probably needs to tear down the whole pod, volumes and all, and start over. That's totally different.\n",
        "createdAt" : "2016-04-14T06:48:48Z",
        "updatedAt" : "2016-06-17T21:38:08Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "5debd368-ee35-4812-b4ec-32b8277c6d25",
        "parentId" : "3c923442-0641-4d04-8432-c8926c60739e",
        "authorId" : "47ec15eb-72b4-4618-9e01-e3b37b6bac00",
        "body" : "That is probably something we would want to handle carefully for PetSets\n",
        "createdAt" : "2016-04-18T21:34:22Z",
        "updatedAt" : "2016-06-17T21:38:08Z",
        "lastEditedBy" : "47ec15eb-72b4-4618-9e01-e3b37b6bac00",
        "tags" : [
        ]
      }
    ],
    "commit" : "bdde25cf4395bca2aa56c661f95d2eaabfabd494",
    "line" : null,
    "diffHunk" : "@@ -1,1 +143,147 @@\nIf the pod is \"restarted\" all containers stopped and started due to\na node restart, change to the pod definition, or admin interaction, all\ninit containers must execute again. Restartable conditions are defined as:\n"
  },
  {
    "id" : "ad17c3c0-f6d7-4f2a-b196-5ac697a6aaf1",
    "prId" : 23666,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2101a06f-d3db-4ce4-95a5-c0710cac38e8",
        "parentId" : null,
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "It doesn't have to be solved here, but we need to find a way to elide fields that aren't used in a particular context. \n",
        "createdAt" : "2016-04-08T20:39:14Z",
        "updatedAt" : "2016-06-17T21:38:08Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      }
    ],
    "commit" : "bdde25cf4395bca2aa56c661f95d2eaabfabd494",
    "line" : null,
    "diffHunk" : "@@ -1,1 +159,163 @@already contacted a remote system.\n\nEach init container has all of the fields of an app container. The following\nfields are prohibited from being used on init containers by validation:\n"
  },
  {
    "id" : "1fd932e0-beac-4fd3-985e-2cf9737643b3",
    "prId" : 23666,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "897c05ad-fa24-474e-b185-fb0d99cd5def",
        "parentId" : null,
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "I assume livenessProbe is intentionally allowed to address the \"getting stuck\" problem mentioned above?\n",
        "createdAt" : "2016-04-08T20:40:09Z",
        "updatedAt" : "2016-06-17T21:38:08Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "1d95bb2f-19da-47a5-bd66-5f5022bfdef5",
        "parentId" : "897c05ad-fa24-474e-b185-fb0d99cd5def",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Yes, activeDeadlineSeconds can manage some of that, but liveness is useful.\n",
        "createdAt" : "2016-04-15T16:46:49Z",
        "updatedAt" : "2016-06-17T21:38:08Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "985ce583-0b11-425d-96bf-6df3023545a7",
        "parentId" : "897c05ad-fa24-474e-b185-fb0d99cd5def",
        "authorId" : "47ec15eb-72b4-4618-9e01-e3b37b6bac00",
        "body" : "It isn't immediately obvious to me how one would generally do liveness checking, since init containers would be run to completion commands.  How do we check that git isn't hung?  Do Http and Tcp liveness checks make sense in this context?\n",
        "createdAt" : "2016-04-18T21:38:30Z",
        "updatedAt" : "2016-06-17T21:38:08Z",
        "lastEditedBy" : "47ec15eb-72b4-4618-9e01-e3b37b6bac00",
        "tags" : [
        ]
      },
      {
        "id" : "742b78eb-5acd-4775-b43d-2deffa17d192",
        "parentId" : "897c05ad-fa24-474e-b185-fb0d99cd5def",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "You could be starting a binary that runs an initialization process that has\na health check, or you could use an exec liveness probe to verify the last\ntouch date on the git repo is shorter than some interval, probably.\n\nOn Mon, Apr 18, 2016 at 5:38 PM, Phillip Wittrock notifications@github.com\nwrote:\n\n> In docs/proposals/container-init.md\n> https://github.com/kubernetes/kubernetes/pull/23666#discussion_r60138977\n> :\n> \n> > +add the ability for an init container to define a limited container restart\n> > +policy distinct from the pod RestartPolicy.\n> > +\n> > +A pod cannot be ready until all init containers have succeeded. The ports\n> > +on an init container are not aggregated under a service. A pod that is\n> > +being initialized is in the `Pending` phase but should have a distinct\n> > +condition.\n> > +\n> > +If the pod is \"restarted\" all containers stopped and started due to\n> > +a node restart, change to the pod definition, or admin interaction, all\n> > +init containers must execute again.\n> > +\n> > +Each init container has all of the fields of an app container. The following\n> > +fields are prohibited from being used on init containers by validation:\n> > +\n> > +\\* `readinessProbe` - init containers must exit for pod startup to continue,\n> \n> It isn't immediately obvious to me how one would generally do liveness\n> checking, since init containers would be run to completion commands. How do\n> we check that git isn't hung? Do Http and Tcp liveness checks make sense in\n> this context?\n> \n> â€”\n> You are receiving this because you were mentioned.\n> Reply to this email directly or view it on GitHub\n> https://github.com/kubernetes/kubernetes/pull/23666/files/7efdc3d36197f1ca452339d49abbc87163fb0e75#r60138977\n",
        "createdAt" : "2016-04-18T21:57:51Z",
        "updatedAt" : "2016-06-17T21:38:08Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "34d5e50e-3625-4577-a6ba-df5d547d8cc7",
        "parentId" : "897c05ad-fa24-474e-b185-fb0d99cd5def",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "> If I read this section correctly, when the (max(init reservation) >\n> sum(app reservation)) the pod will continue to reserve the init reservation\n> capacity for its lifetime. If this is the case, I agree with the suggestion\n> of requiring the app reservation to be > init reservation or coming up with\n> some other way to make it clear that the reservation is leaked / unused\n> after init is done.\n\nWould this be something that should show up in the pod metrics API?  If I'm\na client consumer, I'd really hate to have to do the same calculations\nkubectl describe does today to come up with effective QoS and effective\ncontainer quota (the pod cgroup).  If we could make this part of the APIs,\nI would argue it should be there.\n\nOn Mon, Apr 18, 2016 at 5:57 PM, Clayton Coleman ccoleman@redhat.com\nwrote:\n\n> You could be starting a binary that runs an initialization process that\n> has a health check, or you could use an exec liveness probe to verify the\n> last touch date on the git repo is shorter than some interval, probably.\n> \n> On Mon, Apr 18, 2016 at 5:38 PM, Phillip Wittrock <\n> notifications@github.com> wrote:\n> \n> > In docs/proposals/container-init.md\n> > https://github.com/kubernetes/kubernetes/pull/23666#discussion_r60138977\n> > :\n> > \n> > > +add the ability for an init container to define a limited container restart\n> > > +policy distinct from the pod RestartPolicy.\n> > > +\n> > > +A pod cannot be ready until all init containers have succeeded. The ports\n> > > +on an init container are not aggregated under a service. A pod that is\n> > > +being initialized is in the `Pending` phase but should have a distinct\n> > > +condition.\n> > > +\n> > > +If the pod is \"restarted\" all containers stopped and started due to\n> > > +a node restart, change to the pod definition, or admin interaction, all\n> > > +init containers must execute again.\n> > > +\n> > > +Each init container has all of the fields of an app container. The following\n> > > +fields are prohibited from being used on init containers by validation:\n> > > +\n> > > +\\* `readinessProbe` - init containers must exit for pod startup to continue,\n> > \n> > It isn't immediately obvious to me how one would generally do liveness\n> > checking, since init containers would be run to completion commands. How do\n> > we check that git isn't hung? Do Http and Tcp liveness checks make sense in\n> > this context?\n> > \n> > â€”\n> > You are receiving this because you were mentioned.\n> > Reply to this email directly or view it on GitHub\n> > https://github.com/kubernetes/kubernetes/pull/23666/files/7efdc3d36197f1ca452339d49abbc87163fb0e75#r60138977\n",
        "createdAt" : "2016-04-20T15:31:58Z",
        "updatedAt" : "2016-06-17T21:38:08Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "7237e935-190a-4981-8c94-2ddf7c5ee476",
        "parentId" : "897c05ad-fa24-474e-b185-fb0d99cd5def",
        "authorId" : "47ec15eb-72b4-4618-9e01-e3b37b6bac00",
        "body" : "Perhaps just a warning that the \"init resources > app resource\" would be sufficient.\n",
        "createdAt" : "2016-04-20T16:44:17Z",
        "updatedAt" : "2016-06-17T21:38:08Z",
        "lastEditedBy" : "47ec15eb-72b4-4618-9e01-e3b37b6bac00",
        "tags" : [
        ]
      }
    ],
    "commit" : "bdde25cf4395bca2aa56c661f95d2eaabfabd494",
    "line" : 164,
    "diffHunk" : "@@ -1,1 +162,166 @@fields are prohibited from being used on init containers by validation:\n\n* `readinessProbe` - init containers must exit for pod startup to continue,\n  are not included in rotation, and so cannot define readiness distinct from\n  completion."
  },
  {
    "id" : "4fbe46be-9042-4f52-bcdb-fb8754786cdc",
    "prId" : 23666,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8267d8d0-1b92-45f5-b98d-654f3b11becc",
        "parentId" : null,
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "Are init containers included in activeDeadlineSeconds? I think they should be.\n",
        "createdAt" : "2016-04-08T20:41:00Z",
        "updatedAt" : "2016-06-17T21:38:08Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "06b8c124-8e75-41da-88cc-20b4dae86c07",
        "parentId" : "8267d8d0-1b92-45f5-b98d-654f3b11becc",
        "authorId" : "6eca0ade-9879-4dd7-ad14-547e16f5c041",
        "body" : "activeDeadlineSeconds is defined as when the kubelet observed the pod as bound to the node.  Init container time must be included in activeDeadlineSeconds.\n",
        "createdAt" : "2016-04-12T18:12:36Z",
        "updatedAt" : "2016-06-17T21:38:08Z",
        "lastEditedBy" : "6eca0ade-9879-4dd7-ad14-547e16f5c041",
        "tags" : [
        ]
      },
      {
        "id" : "f41c8b26-38af-4b28-b8e9-c306f1589a69",
        "parentId" : "8267d8d0-1b92-45f5-b98d-654f3b11becc",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "They are, will call it out.\n\nOn Fri, Apr 8, 2016 at 4:41 PM, Brian Grant notifications@github.com\nwrote:\n\n> In docs/proposals/container-init.md\n> https://github.com/kubernetes/kubernetes/pull/23666#discussion_r59086210\n> :\n> \n> > +\n> > +## Design\n> > +\n> > +Each pod may have 0..N init containers defined along with the existing\n> > +1..N app containers.\n> > +\n> > +On startup of the pod, after the network and volumes are initialized, the\n> > +init containers are started in order. Each container must exit successfully\n> > +before the next is invoked. If a container fails to start, it is retried\n> > +according to the pod RestartPolicy. RestartPolicyNever pods will immediately\n> > +fail and exit. RestartPolicyAlways pods will retry the failing init container\n> > +with increasing backoff until it succeeds. Future revisions of this spec may\n> > +add the ability for an init container to define a limited container restart\n> > +policy distinct from the pod RestartPolicy.\n> > +\n> > +A pod cannot be ready until all init containers have succeeded. The ports\n> \n> Are init containers included in activeDeadlineSeconds? I think they should\n> be.\n> \n> â€”\n> You are receiving this because you were mentioned.\n> Reply to this email directly or view it on GitHub\n> https://github.com/kubernetes/kubernetes/pull/23666/files/7efdc3d36197f1ca452339d49abbc87163fb0e75#r59086210\n",
        "createdAt" : "2016-04-12T21:46:58Z",
        "updatedAt" : "2016-06-17T21:38:08Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      }
    ],
    "commit" : "bdde25cf4395bca2aa56c661f95d2eaabfabd494",
    "line" : null,
    "diffHunk" : "@@ -1,1 +134,138 @@(RestartPolicyNever).\n\nA pod cannot be ready until all init containers have succeeded. The ports\non an init container are not aggregated under a service. A pod that is\nbeing initialized is in the `Pending` phase but should have a distinct"
  },
  {
    "id" : "bec92116-a345-4a8b-a5e0-086de9f16a47",
    "prId" : 23666,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b432e984-d94a-4263-ab05-9e3b73f6c60e",
        "parentId" : null,
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "cc @vishh @derekwaynecarr \n",
        "createdAt" : "2016-04-08T20:44:16Z",
        "updatedAt" : "2016-06-17T21:38:08Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "ac7fd57a-9e88-4cf9-bba0-4b91db3a39d5",
        "parentId" : "b432e984-d94a-4263-ab05-9e3b73f6c60e",
        "authorId" : "a6409368-42e0-44a9-bf79-9d3042ac3b65",
        "body" : "The concept of effective pod request / init should work with both scheduler and node. Could you please add an example with different QoS tier too to make this more clear. :-) \n",
        "createdAt" : "2016-04-14T00:32:42Z",
        "updatedAt" : "2016-06-17T21:38:08Z",
        "lastEditedBy" : "a6409368-42e0-44a9-bf79-9d3042ac3b65",
        "tags" : [
        ]
      },
      {
        "id" : "92b06187-4b83-4295-9bca-1ac858c8a665",
        "parentId" : "b432e984-d94a-4263-ab05-9e3b73f6c60e",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Will do\n",
        "createdAt" : "2016-04-15T00:23:31Z",
        "updatedAt" : "2016-06-17T21:38:08Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      }
    ],
    "commit" : "bdde25cf4395bca2aa56c661f95d2eaabfabd494",
    "line" : null,
    "diffHunk" : "@@ -1,1 +205,209 @@\n\n### Resources\n\nGiven the ordering and execution for init containers, the following rules"
  },
  {
    "id" : "32e60bc2-e3d6-43da-b362-c34c96aa583b",
    "prId" : 23666,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3c694149-8934-4a08-85d5-2b9a842efd90",
        "parentId" : null,
        "authorId" : "6eca0ade-9879-4dd7-ad14-547e16f5c041",
        "body" : "I agree with this for scheduler and quota.  I am not sure how pod-level cgroups should be setup if the init container has higher resource requirements than non-init containers.\n",
        "createdAt" : "2016-04-12T18:23:25Z",
        "updatedAt" : "2016-06-17T21:38:08Z",
        "lastEditedBy" : "6eca0ade-9879-4dd7-ad14-547e16f5c041",
        "tags" : [
        ]
      },
      {
        "id" : "bda04d49-e801-4058-88d9-b902bcfe22ef",
        "parentId" : "3c694149-8934-4a08-85d5-2b9a842efd90",
        "authorId" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "body" : "We can set the pod-level cgroups limits to match this value. If the difference between init container's and app container's resource requests are high, then it will lead to poor utilization though. \n",
        "createdAt" : "2016-04-12T21:53:21Z",
        "updatedAt" : "2016-06-17T21:38:08Z",
        "lastEditedBy" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "tags" : [
        ]
      },
      {
        "id" : "4149f6e4-4d86-4cbc-80b2-a52e271623e9",
        "parentId" : "3c694149-8934-4a08-85d5-2b9a842efd90",
        "authorId" : "a6409368-42e0-44a9-bf79-9d3042ac3b65",
        "body" : "Agreed with Vish above, the pod-level cgroup could be configured as the max( max(init container requests), sum(app container requests) ). Also I don't think utilization is a big concern here since burstable and best-effort can fill the slack resource. \n",
        "createdAt" : "2016-04-14T17:14:03Z",
        "updatedAt" : "2016-06-17T21:38:08Z",
        "lastEditedBy" : "a6409368-42e0-44a9-bf79-9d3042ac3b65",
        "tags" : [
        ]
      },
      {
        "id" : "4e0335d1-52e9-41f3-97ea-1195d084250b",
        "parentId" : "3c694149-8934-4a08-85d5-2b9a842efd90",
        "authorId" : "6eca0ade-9879-4dd7-ad14-547e16f5c041",
        "body" : "SGTM\n",
        "createdAt" : "2016-04-21T20:07:18Z",
        "updatedAt" : "2016-06-17T21:38:08Z",
        "lastEditedBy" : "6eca0ade-9879-4dd7-ad14-547e16f5c041",
        "tags" : [
        ]
      }
    ],
    "commit" : "bdde25cf4395bca2aa56c661f95d2eaabfabd494",
    "line" : null,
    "diffHunk" : "@@ -1,1 +241,245 @@            memory: 1100MiB\n\nhas an effective pod limit of `cpu: 100m`, `memory: 2200MiB` (highest init\ncontainer cpu is larger than sum of all app containers, sum of container\nmemory is larger than the max of all init containers). The scheduler, node,"
  },
  {
    "id" : "c8fe226e-8f89-4fe1-be28-a82fd116a8df",
    "prId" : 23666,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ae51b652-6634-483c-9a03-456699e6ff27",
        "parentId" : null,
        "authorId" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "body" : "Will the init containers ever have to be restarted or re-run?\n",
        "createdAt" : "2016-04-12T21:32:19Z",
        "updatedAt" : "2016-06-17T21:38:08Z",
        "lastEditedBy" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "tags" : [
        ]
      }
    ],
    "commit" : "bdde25cf4395bca2aa56c661f95d2eaabfabd494",
    "line" : null,
    "diffHunk" : "@@ -1,1 +86,90 @@    Pods in general are not intended to support DAG workflows.\n* Both run-once and run-forever pods should be able to use init containers\n* As much as possible, an init container should behave like an app container\n  to reduce complexity for end users, for clients, and for divergent use cases.\n  An init container is a container with the minimum alterations to accomplish"
  },
  {
    "id" : "849365c4-81a6-4f3c-95a8-21456e7a33ed",
    "prId" : 23666,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c23d980e-ea80-42ac-a5a7-fcbb6b859138",
        "parentId" : null,
        "authorId" : "a6409368-42e0-44a9-bf79-9d3042ac3b65",
        "body" : "Can we make this as best-effort? When the disk usage of a node is reaching its high threshold percentage, we might want to remove some logs of terminated containers no matter it is init or app. \n",
        "createdAt" : "2016-04-14T00:37:44Z",
        "updatedAt" : "2016-06-17T21:38:08Z",
        "lastEditedBy" : "a6409368-42e0-44a9-bf79-9d3042ac3b65",
        "tags" : [
        ]
      },
      {
        "id" : "11e66bb7-1f77-4998-90ce-a5b6dda00666",
        "parentId" : "c23d980e-ea80-42ac-a5a7-fcbb6b859138",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "I agree, we want to prefer app containers, preserve a record of the\nmost recent init container when possible, but under pressure it's\nbetter to prune than run out of disk.\n",
        "createdAt" : "2016-04-15T00:22:56Z",
        "updatedAt" : "2016-06-17T21:38:08Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      }
    ],
    "commit" : "bdde25cf4395bca2aa56c661f95d2eaabfabd494",
    "line" : null,
    "diffHunk" : "@@ -1,1 +298,302 @@\nAll app container operations are permitted on init containers. The\nlogs for an init container should be available for the duration of the pod\nlifetime or until the pod is restarted.\n"
  },
  {
    "id" : "58155af9-39ac-47e1-be7d-e595b4643d66",
    "prId" : 23666,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5177ac31-1af8-4254-8c33-d004c488462d",
        "parentId" : null,
        "authorId" : "11efe503-096f-46dd-a8c8-28ba38a0157a",
        "body" : "Since pre-start hooks are not implemented yet, link to the issue: https://github.com/kubernetes/kubernetes/issues/140\n",
        "createdAt" : "2016-06-05T16:00:38Z",
        "updatedAt" : "2016-06-17T21:38:08Z",
        "lastEditedBy" : "11efe503-096f-46dd-a8c8-28ba38a0157a",
        "tags" : [
        ]
      }
    ],
    "commit" : "bdde25cf4395bca2aa56c661f95d2eaabfabd494",
    "line" : 100,
    "diffHunk" : "@@ -1,1 +98,102 @@    (in the absence of init containers) would be an abuse of the goal of volume\n    containers.\n* Container pre-start hooks are not sufficient for all initialization cases:\n  * They cannot easily coordinate complex conditions across containers\n  * They can only function with code in the image or code in a shared volume,"
  }
]
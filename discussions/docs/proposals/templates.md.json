[
  {
    "id" : "1c5c4101-c0c3-430a-b989-1734db70b917",
    "prId" : 18215,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "dbe72459-90db-4a81-bda7-d95381b409b5",
        "parentId" : null,
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "In general, bulk creation, as with List.\n",
        "createdAt" : "2015-12-05T01:41:35Z",
        "updatedAt" : "2016-02-09T13:51:03Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "b5720112-d00f-44e3-9a8b-f833755d9c60",
        "parentId" : "dbe72459-90db-4a81-bda7-d95381b409b5",
        "authorId" : "f841e73a-d2ba-4be1-9028-bec3b88e342d",
        "body" : "added bulk object creation as another bullet.\n",
        "createdAt" : "2015-12-18T18:00:31Z",
        "updatedAt" : "2016-02-09T13:51:03Z",
        "lastEditedBy" : "f841e73a-d2ba-4be1-9028-bec3b88e342d",
        "tags" : [
        ]
      },
      {
        "id" : "2a88bcdf-ad60-4475-b70f-d3ac7a288dd8",
        "parentId" : "dbe72459-90db-4a81-bda7-d95381b409b5",
        "authorId" : "8f7fe7a6-7bc9-4dfb-b9c0-a2f808baa9d1",
        "body" : "@bparees +1 because bulk creation is quite different from application specification, although the 2 use cases share some common requirements, such as parameterization and iterative expansion.\n",
        "createdAt" : "2016-01-13T20:40:37Z",
        "updatedAt" : "2016-02-09T13:51:03Z",
        "lastEditedBy" : "8f7fe7a6-7bc9-4dfb-b9c0-a2f808baa9d1",
        "tags" : [
        ]
      }
    ],
    "commit" : "89a656130da26d4c94b95defdeea7b3749945ea1",
    "line" : 71,
    "diffHunk" : "@@ -1,1 +69,73 @@### Use cases for templates in general\n\n* Providing a full baked application experience in a single portable object that can be repeatably deployed in different environments.\n  * eg Wordpress deployment with separate database pod/replica controller\n  * Complex service/replication controller/volume topologies"
  },
  {
    "id" : "17a414ca-3bb3-4aeb-9eea-c61ea5fd4113",
    "prId" : 18215,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "04fb619e-c753-4401-a8fa-d11c66d8ea67",
        "parentId" : null,
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "FWIW, List uses `Items` I think.\n",
        "createdAt" : "2015-12-05T01:48:45Z",
        "updatedAt" : "2016-02-09T13:51:03Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "71b96dcb-d08a-45bf-977a-6b9d63f656a3",
        "parentId" : "04fb619e-c753-4401-a8fa-d11c66d8ea67",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "These are objects specifically so that the objects aren't confused with lists.  Objects that have nested \"items\" are considered lists and decomposed by our client processing.  For a template, invoking create -f is more about creating an instance of the template on the server.  But creating a List or PodList is not.  Other ways to solve that but keeping lists semantically distinct has been helpful so far.\n",
        "createdAt" : "2015-12-05T03:57:40Z",
        "updatedAt" : "2016-02-09T13:51:03Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "fb0b4125-0f95-4aad-8b94-4b57da12ac78",
        "parentId" : "04fb619e-c753-4401-a8fa-d11c66d8ea67",
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "Ok\n",
        "createdAt" : "2016-01-13T00:36:43Z",
        "updatedAt" : "2016-02-09T13:51:03Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      }
    ],
    "commit" : "89a656130da26d4c94b95defdeea7b3749945ea1",
    "line" : 201,
    "diffHunk" : "@@ -1,1 +199,203 @@\n    // Required: A list of resources to create\n    Objects []runtime.Object\n\n    // Optional: ObjectLabels is a set of labels that are applied to every"
  },
  {
    "id" : "eb156067-c23a-4320-a3d4-b09e892240aa",
    "prId" : 18215,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "95a6dac9-676a-4985-9da9-d21c26579c1b",
        "parentId" : null,
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Except when the value does not validate - such as replacement in names ($( is not valid)\n",
        "createdAt" : "2015-12-05T04:03:38Z",
        "updatedAt" : "2016-02-09T13:51:03Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "4155e348-083e-40f2-a2ed-fb89a3497d07",
        "parentId" : "95a6dac9-676a-4985-9da9-d21c26579c1b",
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "We should be able to validate the template field names.\n\nAs for values, if we had jsonschema-like validation specifications for parameters and/or for the resource fields, we could validate the values to some degree.\n",
        "createdAt" : "2015-12-05T06:21:13Z",
        "updatedAt" : "2016-02-09T13:51:03Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "f6d43b33-d48e-4177-9865-004108645a29",
        "parentId" : "95a6dac9-676a-4985-9da9-d21c26579c1b",
        "authorId" : "f841e73a-d2ba-4be1-9028-bec3b88e342d",
        "body" : "> Except when the value does not validate - such as replacement in names ($( is not valid)\n\nwe don't validate the objects within the template definition, they are just runtime.Object, right?  i'm just saying the template api object is validated as such, not that the things it contains are validated as whatever type they are.  that does not happen (and as you note, really can't happen until after substitution happens.  This situation will be even worse once we add support for substitution into integer fields)\n",
        "createdAt" : "2015-12-06T01:21:05Z",
        "updatedAt" : "2016-02-09T13:51:03Z",
        "lastEditedBy" : "f841e73a-d2ba-4be1-9028-bec3b88e342d",
        "tags" : [
        ]
      }
    ],
    "commit" : "89a656130da26d4c94b95defdeea7b3749945ea1",
    "line" : 534,
    "diffHunk" : "@@ -1,1 +532,536 @@*It should be possible to validate templates and template parameters, both values and the schema.*\n\n* Template objects are subject to standard api validation.\n\n*It should also be possible to validate and view the output of the substitution process.*"
  },
  {
    "id" : "1238e9a9-714b-4baa-98d1-13ffba3d4a44",
    "prId" : 18215,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a561f2e5-00a2-4288-9cba-5f322a5930eb",
        "parentId" : null,
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Parameterize the replica count of a deployment or PetSet\nParameterize at least part of the labels and selector for a DaemonSet.\n",
        "createdAt" : "2015-12-05T04:05:20Z",
        "updatedAt" : "2016-02-09T13:51:03Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "f7f25191-0c46-4033-9447-b7e13d3bab75",
        "parentId" : "a561f2e5-00a2-4288-9cba-5f322a5930eb",
        "authorId" : "f841e73a-d2ba-4be1-9028-bec3b88e342d",
        "body" : "keeping in mind that parameterizing replica counts requires addressing the current \"string only substitution\" limitation.  I was trying to restrict the use cases to ones solved by the proposal.  if we agree on how we want to add generic type substitution to this proposal, we can certainly add other use cases that are solved with it.\n",
        "createdAt" : "2015-12-06T01:09:24Z",
        "updatedAt" : "2016-02-09T13:51:03Z",
        "lastEditedBy" : "f841e73a-d2ba-4be1-9028-bec3b88e342d",
        "tags" : [
        ]
      },
      {
        "id" : "e298a677-df09-4b55-9035-38bbe8d1a3c7",
        "parentId" : "a561f2e5-00a2-4288-9cba-5f322a5930eb",
        "authorId" : "b40ea59c-0e7d-405e-912c-9b93dd0a41cb",
        "body" : "It's definitely a valid use case and one that can be achieved with several of the options on the table so I think it should be included.\n",
        "createdAt" : "2015-12-16T04:17:06Z",
        "updatedAt" : "2016-02-09T13:51:03Z",
        "lastEditedBy" : "b40ea59c-0e7d-405e-912c-9b93dd0a41cb",
        "tags" : [
        ]
      },
      {
        "id" : "7fd4392b-e114-4cd5-b5d6-225b2d8d1b05",
        "parentId" : "a561f2e5-00a2-4288-9cba-5f322a5930eb",
        "authorId" : "f841e73a-d2ba-4be1-9028-bec3b88e342d",
        "body" : "parameter types other than string are now supported by this proposal.\n",
        "createdAt" : "2015-12-18T18:00:12Z",
        "updatedAt" : "2016-02-09T13:51:03Z",
        "lastEditedBy" : "f841e73a-d2ba-4be1-9028-bec3b88e342d",
        "tags" : [
        ]
      }
    ],
    "commit" : "89a656130da26d4c94b95defdeea7b3749945ea1",
    "line" : null,
    "diffHunk" : "@@ -1,1 +94,98 @@  a pod as a TLS cert).\n* Provide guidance to users for parameters such as default values, descriptions, and whether or not a particular parameter value\n  is required or can be left blank.\n* Parameterize the replica count of a deployment or [PetSet](https://github.com/kubernetes/kubernetes/pull/18016)\n* Parameterize part of the labels and selector for a DaemonSet"
  },
  {
    "id" : "969c49e8-331b-484d-8c42-242594a42af1",
    "prId" : 18215,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c1e820c3-3a26-4d9a-a92e-1f5a1f25f4ea",
        "parentId" : null,
        "authorId" : "8f7fe7a6-7bc9-4dfb-b9c0-a2f808baa9d1",
        "body" : "The preceding statements about DM are inaccurate. Please read the DM documentation at https://github.com/kubernetes/deployment-manager, including the contents of the docs folder, and correct these statements.\n",
        "createdAt" : "2015-12-08T22:56:20Z",
        "updatedAt" : "2016-02-09T13:51:03Z",
        "lastEditedBy" : "8f7fe7a6-7bc9-4dfb-b9c0-a2f808baa9d1",
        "tags" : [
        ]
      },
      {
        "id" : "0f95e9cf-1e93-4f60-85ae-22a2e232744a",
        "parentId" : "c1e820c3-3a26-4d9a-a92e-1f5a1f25f4ea",
        "authorId" : "f841e73a-d2ba-4be1-9028-bec3b88e342d",
        "body" : "> Utilizes multiple files with different syntax to define an application topology.\n\nthis example uses 4 files including both yaml and jinja formats: https://github.com/kubernetes/deployment-manager/tree/master/examples/wordpress\n\nthe docs also indicate templates can be written in python.  none of the examples/formats match k8s api objects/syntax.\n\n> Does not define a first class API object.\n\nsee above, what DM defines/consumes is not a first class k8s api object.  Perhaps there's some confusion in what i meant by api object, I did not mean that DM doesn't define an api for itself, I meant it does not define api objects that are consumed by k8s.  I can clarify this statement.\n\n> Does not appear to natively offer generation logic for producing parameter values.\n\nI understand DM has parameters, i don't see native logic for defining how a parameter value should be generated (eg generate a random password).  Presumably it's possible to make that happen via jinja or python, but I wouldn't consider that native support within DM, hence my statement.  Again, I can clarify this to indicate value generation is deferred to jinja/python.\n\nIf I am still not understanding the design of DM, I'm afraid I'm going to need you to be more explicit about what is inaccurate/what I have misunderstood.\n",
        "createdAt" : "2015-12-08T23:31:40Z",
        "updatedAt" : "2016-02-09T13:51:03Z",
        "lastEditedBy" : "f841e73a-d2ba-4be1-9028-bec3b88e342d",
        "tags" : [
        ]
      },
      {
        "id" : "3b2b9b98-d0ee-4909-898a-3781a5833701",
        "parentId" : "c1e820c3-3a26-4d9a-a92e-1f5a1f25f4ea",
        "authorId" : "8f7fe7a6-7bc9-4dfb-b9c0-a2f808baa9d1",
        "body" : "DM defines a single template usage format. It's a YAML based list of `resource`, each of which contains a `name`, `type` and `parameters`. True, the template definition can be written either in Jinja, which is simply marked up YAML, or Python, which produces YAML. A Jinja template for a k8s primitive is easily recognizable as a k8s configuration file with mustache markup.\n\nAlso, there's no requirement to use both languages in a single example, or to use multiple files, so both assertions are inaccurate.\n\nDM can also take vanilla k8s configuration files as input. And, when a template is expanded, the result is always a flat list of vanilla k8s configuration files, which is readily accessible via the API.\n\nDM doesn't define a k8s API object specifically because a native implementation baked into k8s has been discouraged by the preceding discussion. If that has somehow changed, we could easily make a DM template a native API object. However, we believe there are good reasons not to do that, not least of which is the well established precedent of publishing content in registries, rather than in runtimes. That said, when a configuration is deployed using DM, it is capture and stored in the cluster, providing a record of the deployment, including the parameters and expansion results.\n\nIf by native support for generation logic, you mean hard wired, as opposed to programmable, then no, DM doesn't have hard wired generators. We consider hard wired implementations to be an anti-pattern, in general.\n",
        "createdAt" : "2015-12-08T23:50:37Z",
        "updatedAt" : "2016-02-09T13:51:03Z",
        "lastEditedBy" : "8f7fe7a6-7bc9-4dfb-b9c0-a2f808baa9d1",
        "tags" : [
        ]
      },
      {
        "id" : "a7e99551-ee90-4c74-b07c-00363b7a46c7",
        "parentId" : "c1e820c3-3a26-4d9a-a92e-1f5a1f25f4ea",
        "authorId" : "f841e73a-d2ba-4be1-9028-bec3b88e342d",
        "body" : "> Also, there's no requirement to use both languages in a single example, or to use multiple files, so both assertions are inaccurate.\n\nis it possible to write a single file, in k8s-compatible json syntax, which provides parameterization?  That is what is achieved by the openshift template schema, and what I am trying to distinguish here as a desirable trait.  Whether an example can be created which doesn't need additional syntax or files isn't really my point, the question is whether the full power of DM can be realized without branching out into multiple files and multiple syntaxes (above and beyond the k8s syntax).  \n\nMy impression is that the answer is no.  Is it a desirable goal (single file, k8s syntax, api object)?  in my opinion, based on the user experience we have been able to deliver in openshift by integrating templates as a first class concept, is that it is, but I think we'll be hashing that out in the syntax/schema discussion once I update this PR per our discussion yesterday.\n\nRegarding parameter generation, I agree with the concerns about it being compiled into the runtime and it would be nice to make it more flexible.  On the other hand, by being a little opinionated here, we provided a generation function that covers probably 70% of the use cases for parameter generation (no one has come to us so far asking for additional generation functionality) in an extremely consumable format that minimizes complexity or requirements to learn new languages.\n",
        "createdAt" : "2015-12-10T23:14:13Z",
        "updatedAt" : "2016-02-09T13:51:03Z",
        "lastEditedBy" : "f841e73a-d2ba-4be1-9028-bec3b88e342d",
        "tags" : [
        ]
      }
    ],
    "commit" : "89a656130da26d4c94b95defdeea7b3749945ea1",
    "line" : null,
    "diffHunk" : "@@ -1,1 +582,586 @@\n### Storing templates in k8s\n\nOpenshift defines templates as a first class resource so they can be created/retrieved/etc via standard tools.  This allows client tools to list available templates (available in the openshift cluster), allows existing resource security controls to be applied to templates, and generally provides a more integrated feel to templates.  However there is no explicit requirement that for k8s to adopt templates, it must also adopt storing them in the cluster.\n"
  },
  {
    "id" : "69b7f7d4-d5b6-41ce-9e59-6a6344d912b2",
    "prId" : 18215,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b1e249b3-4b95-43ff-9c05-2238e516360f",
        "parentId" : null,
        "authorId" : "8f7fe7a6-7bc9-4dfb-b9c0-a2f808baa9d1",
        "body" : "Additional use case:\n- Capturing the topology of an application from template expansion as metadata within the cluster, so that\n  - visualizations can be provided that expose application structure, \n  - developers can inspect a cluster to determine what's running in it,\n  - tools can use the metadata to aggregate and analyze signals.\n",
        "createdAt" : "2015-12-08T23:14:41Z",
        "updatedAt" : "2016-02-09T13:51:03Z",
        "lastEditedBy" : "8f7fe7a6-7bc9-4dfb-b9c0-a2f808baa9d1",
        "tags" : [
        ]
      },
      {
        "id" : "d00e03d5-4899-46bb-a847-0d21021eb17a",
        "parentId" : "b1e249b3-4b95-43ff-9c05-2238e516360f",
        "authorId" : "f841e73a-d2ba-4be1-9028-bec3b88e342d",
        "body" : "is \n\"\\* Exporting a set of objects in a namespace as a template so the topology can be inspected/visualized or recreated in another environment\" \n\na fair summary of that?\n",
        "createdAt" : "2015-12-10T22:12:49Z",
        "updatedAt" : "2016-02-09T13:51:03Z",
        "lastEditedBy" : "f841e73a-d2ba-4be1-9028-bec3b88e342d",
        "tags" : [
        ]
      },
      {
        "id" : "fef7a100-26f0-489f-a5fb-7b586bdc0d87",
        "parentId" : "b1e249b3-4b95-43ff-9c05-2238e516360f",
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "Note that application topology could be captured by labels and/or annotations, as well, without templates. \n",
        "createdAt" : "2016-01-04T19:40:23Z",
        "updatedAt" : "2016-02-09T13:51:03Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      }
    ],
    "commit" : "89a656130da26d4c94b95defdeea7b3749945ea1",
    "line" : null,
    "diffHunk" : "@@ -1,1 +79,83 @@* Controllers that need to instantiate multiple instances of identical objects (eg PetSets).\n\n\n### Use cases for parameters within templates\n"
  },
  {
    "id" : "3f035abb-78f5-43e9-9a98-b312834b4b67",
    "prId" : 18215,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8028519d-8137-4b9f-91b7-f892420bae97",
        "parentId" : null,
        "authorId" : "8f7fe7a6-7bc9-4dfb-b9c0-a2f808baa9d1",
        "body" : "Template libraries are likely to evolve at a different rates and through different means than the Kubernetes code base. In addition, there are well established mechanisms and processes for evolving shared development artifacts, most notably Github. We should therefore not require the template libraries to reside within Kubernetes itself.\n\nWe can and should require templates to be addressable using a simple URL, and/or a shortened URL format similar to go lang imports (e.g., github.com/kubernetes/application-dm-templates/storage/redis:v1).\n",
        "createdAt" : "2015-12-08T23:18:31Z",
        "updatedAt" : "2016-02-09T13:51:03Z",
        "lastEditedBy" : "8f7fe7a6-7bc9-4dfb-b9c0-a2f808baa9d1",
        "tags" : [
        ]
      },
      {
        "id" : "6c31af93-5c4a-47e6-a71f-1dd4a8dc4f42",
        "parentId" : "8028519d-8137-4b9f-91b7-f892420bae97",
        "authorId" : "f841e73a-d2ba-4be1-9028-bec3b88e342d",
        "body" : "There's definitely no requirement they live there, we support instantiating templates from github as well (oc process -f https://raw.github.com/foo/bar/mytemplate.json), however it is a very convenient way for an administrator to make a DB service available to users, for example, or provide a common jenkins service.  You provide a template within the cluster and users can instantiate that template without leaving the confines of the cluster.\n",
        "createdAt" : "2015-12-10T22:15:05Z",
        "updatedAt" : "2016-02-09T13:51:03Z",
        "lastEditedBy" : "f841e73a-d2ba-4be1-9028-bec3b88e342d",
        "tags" : [
        ]
      },
      {
        "id" : "205269aa-6d6d-4a9b-8a91-0f44a945b990",
        "parentId" : "8028519d-8137-4b9f-91b7-f892420bae97",
        "authorId" : "b40ea59c-0e7d-405e-912c-9b93dd0a41cb",
        "body" : "Terraform has a centralized template library on github: https://github.com/terraform-community-modules\n",
        "createdAt" : "2015-12-16T04:23:18Z",
        "updatedAt" : "2016-02-09T13:51:03Z",
        "lastEditedBy" : "b40ea59c-0e7d-405e-912c-9b93dd0a41cb",
        "tags" : [
        ]
      }
    ],
    "commit" : "89a656130da26d4c94b95defdeea7b3749945ea1",
    "line" : null,
    "diffHunk" : "@@ -1,1 +109,113 @@* Allow application deployers to easily customize exposed values like object names while maintaining referential integrity\n  between dependent pieces (for example ensuring a pod's labels always match the corresponding selector definition of the service)\n* Support maintaining a library of templates within Kubernetes that can be accessed and instantiated by end users\n* Allow users to quickly and repeatedly deploy instances of well-defined application patterns produced by the community\n* Follow established Kubernetes API patterns by defining new template related APIs which consume+return first class Kubernetes"
  },
  {
    "id" : "0dee7112-1a6c-489c-b612-e0f2ecd1e758",
    "prId" : 18215,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "333cd943-813e-444c-aa48-5f933c266c78",
        "parentId" : null,
        "authorId" : "8f7fe7a6-7bc9-4dfb-b9c0-a2f808baa9d1",
        "body" : "Excluding template composition/embedding doesn't necessarily make things simpler. In fact, the [DRY](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself) (don't repeat yourself) principle codifies the widely shared industry experience that reuse by copy/paste rapidly leads to much greater complexity and much more difficult maintenance challenges than inclusion by reference. \n\nUnless we have compelling evidence to the contrary, we should strike this requirement from this document.\n",
        "createdAt" : "2015-12-08T23:21:50Z",
        "updatedAt" : "2016-02-09T13:51:03Z",
        "lastEditedBy" : "8f7fe7a6-7bc9-4dfb-b9c0-a2f808baa9d1",
        "tags" : [
        ]
      },
      {
        "id" : "1bb6f993-c411-40bd-8635-3ad4c2afddd5",
        "parentId" : "333cd943-813e-444c-aa48-5f933c266c78",
        "authorId" : "f841e73a-d2ba-4be1-9028-bec3b88e342d",
        "body" : "including things by reference leads to fragility as the things you reference bit rot or disappear or get changed underneath you.  Furthermore a consumer of something that includes 3 other things by reference, if they are diligent, is going to need to go track down those other 3 things to understand what they are going to do before blindly instantiating it.\n\nobviously i'm not saying there's no place for DRY, but in my experience writing templates so far, i think embedding them would have only made my life harder in trying to keep everything in sync when i changed something that other templates depended on, rather than making it simpler by allowing to me write something one time.  And that's in a scenario where i had total control over the entire hierarchy of template content.\n\nlastly the biggest challenge we've had with templates so far is getting people to understand how to write them (what's the valid syntax, what's the schema for the objects, etc), and i'm worried that adding additional semantics like includes is only going to raise the bar on understanding them.\n\nRegardless i'd like to see some other folks weigh in before we remove the restriction, it's a pretty clear decision point so hopefully we can get some consensus one way or another as we attempt to define the proposed syntax.\n",
        "createdAt" : "2015-12-10T22:24:26Z",
        "updatedAt" : "2016-02-09T13:51:03Z",
        "lastEditedBy" : "f841e73a-d2ba-4be1-9028-bec3b88e342d",
        "tags" : [
        ]
      },
      {
        "id" : "bddf35f5-37a9-4692-a92b-cc6a8c4b0c6a",
        "parentId" : "333cd943-813e-444c-aa48-5f933c266c78",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : " We need to fix the referential integrity problem in the API anyway.  I'd say that is a more urgent problem than templating, in general.\n",
        "createdAt" : "2015-12-12T01:09:41Z",
        "updatedAt" : "2016-02-09T13:51:03Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "35bf7a51-7421-4721-9d1e-1fff7f7d1503",
        "parentId" : "333cd943-813e-444c-aa48-5f933c266c78",
        "authorId" : "b40ea59c-0e7d-405e-912c-9b93dd0a41cb",
        "body" : "All templates need to be versioned.  Git allows this already, so it's not a big deal.  That avoids the problem of changing dependencies / bit rot.\n\nThe syntax for invoking a sub template has to be the same as invoking the first template, assuming multiple languages are supported (see DM).  So there is not a big cognitive burden.\n",
        "createdAt" : "2015-12-16T04:41:44Z",
        "updatedAt" : "2016-02-09T13:51:03Z",
        "lastEditedBy" : "b40ea59c-0e7d-405e-912c-9b93dd0a41cb",
        "tags" : [
        ]
      },
      {
        "id" : "2c75fd63-76e0-46b7-b779-11f79ec1fc59",
        "parentId" : "333cd943-813e-444c-aa48-5f933c266c78",
        "authorId" : "f841e73a-d2ba-4be1-9028-bec3b88e342d",
        "body" : "i've removed this explicit exclusion for now.  Whether the template api object itself allows the definition of compositions, or if we punt it into the template body and let the expansion plugin do what it wants, still needs to be decided.\n",
        "createdAt" : "2015-12-18T18:02:12Z",
        "updatedAt" : "2016-02-09T13:51:03Z",
        "lastEditedBy" : "f841e73a-d2ba-4be1-9028-bec3b88e342d",
        "tags" : [
        ]
      }
    ],
    "commit" : "89a656130da26d4c94b95defdeea7b3749945ea1",
    "line" : null,
    "diffHunk" : "@@ -1,1 +119,123 @@\nThis desire for simplicity also intentionally excludes template composability/embedding as a supported use case.\n\nAllowing templates to reference other templates presents versioning+consistency challenges along with making the template\nno longer a self-contained portable object.  Scenarios necessitating multiple templates can be handled in one of several"
  },
  {
    "id" : "88310bdd-9cc9-4f87-8b53-e094bba24452",
    "prId" : 18215,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2deb338c-6bc7-4d14-a617-2d590e6742ee",
        "parentId" : null,
        "authorId" : "8f7fe7a6-7bc9-4dfb-b9c0-a2f808baa9d1",
        "body" : "It's quite straightforward to version templates, and to include template version information in references. See [this document](https://github.com/kubernetes/deployment-manager/blob/master/docs/templates/registry.md#template-versions) for an example of a simple but effective versioning scheme.\n\nBeyond including template version information in references, a standardized reference format is essential, so that references can be unambiguously resolved against public registries. See [this document](https://github.com/kubernetes/deployment-manager/blob/master/docs/templates/registry.md#registry-based-template-references) for an example of Github based template references.\n\nWe should revise this document to require that templates be versioned and that templates residing in public registries be accessible through a standardized reference format.\n",
        "createdAt" : "2015-12-08T23:27:28Z",
        "updatedAt" : "2016-02-09T13:51:03Z",
        "lastEditedBy" : "8f7fe7a6-7bc9-4dfb-b9c0-a2f808baa9d1",
        "tags" : [
        ]
      },
      {
        "id" : "2261c5c2-c55c-4e04-a5c8-040cd27f0daa",
        "parentId" : "2deb338c-6bc7-4d14-a617-2d590e6742ee",
        "authorId" : "f841e73a-d2ba-4be1-9028-bec3b88e342d",
        "body" : "in the next iteration of the document i'm striking any concerns with tooling or storage of templates and focusing only on the syntax of the template definition, so the public registry issue will go away.\n\nWe can add a version field to the proposed template schema.\n",
        "createdAt" : "2015-12-10T22:31:47Z",
        "updatedAt" : "2016-02-09T13:51:03Z",
        "lastEditedBy" : "f841e73a-d2ba-4be1-9028-bec3b88e342d",
        "tags" : [
        ]
      },
      {
        "id" : "93cb29ad-ae74-44eb-ab15-3d5ed6acf156",
        "parentId" : "2deb338c-6bc7-4d14-a617-2d590e6742ee",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "Will it be possible, in general, to convert templates between API version?  If I have a template of a v1 Pod, and I want to upgrade to V2, it's possible the fields that were templated no longer exist in v2, or have been decompsed or semantically changed.  I think we need to call this out as a general problem of server-side templating, unless there's a great answer I don't see.\n",
        "createdAt" : "2015-12-12T01:13:20Z",
        "updatedAt" : "2016-02-09T13:51:03Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "4fd50fdb-d5cb-439a-88e1-ae1db24bcc90",
        "parentId" : "2deb338c-6bc7-4d14-a617-2d590e6742ee",
        "authorId" : "f841e73a-d2ba-4be1-9028-bec3b88e342d",
        "body" : "Today we take the approach that the content within the template (eg the v1 pod) is opaque, so migrating a template from v1 to v2 would not also migrate the content within the template, just the fields of the template itself (parameter definitions, etc).\n\nNot sure how the problem is specific to server-side templating.  A client processing a v1 template to submit to a v2 api endpoint would face the same problem.\n",
        "createdAt" : "2015-12-12T04:40:53Z",
        "updatedAt" : "2016-02-09T13:51:03Z",
        "lastEditedBy" : "f841e73a-d2ba-4be1-9028-bec3b88e342d",
        "tags" : [
        ]
      },
      {
        "id" : "c2fb9801-e453-4b4b-b53f-86f6aceb7049",
        "parentId" : "2deb338c-6bc7-4d14-a617-2d590e6742ee",
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "With respect to template versioning:\n\nI agree that templates need to be versioned, but I don't know that we need an explicit field for that.\n\nThe version could be included in the resource name, and labels could be used to find a collection of similar templates.\n",
        "createdAt" : "2016-01-04T19:46:50Z",
        "updatedAt" : "2016-02-09T13:51:03Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "31cfbd8a-00c7-43b3-bd7d-90d8e72f38ff",
        "parentId" : "2deb338c-6bc7-4d14-a617-2d590e6742ee",
        "authorId" : "8f7fe7a6-7bc9-4dfb-b9c0-a2f808baa9d1",
        "body" : "Placing the version in the resource name makes it easy to create versioned graphs. That's how template versioning works in DM. See [this document section](https://github.com/kubernetes/deployment-manager/blob/master/docs/templates/registry.md#template-versions).\n",
        "createdAt" : "2016-01-13T20:49:00Z",
        "updatedAt" : "2016-02-09T13:51:03Z",
        "lastEditedBy" : "8f7fe7a6-7bc9-4dfb-b9c0-a2f808baa9d1",
        "tags" : [
        ]
      }
    ],
    "commit" : "89a656130da26d4c94b95defdeea7b3749945ea1",
    "line" : null,
    "diffHunk" : "@@ -1,1 +122,126 @@Allowing templates to reference other templates presents versioning+consistency challenges along with making the template\nno longer a self-contained portable object.  Scenarios necessitating multiple templates can be handled in one of several\nalternate ways:\n\n* Explicitly constructing a new template that merges the existing templates (tooling can easily be constructed to perform this"
  },
  {
    "id" : "097c5aa8-15e8-43d1-b164-c2e9074ea0cd",
    "prId" : 18215,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "90a40298-6c15-4c9b-b81e-9837773d21dd",
        "parentId" : null,
        "authorId" : "8f7fe7a6-7bc9-4dfb-b9c0-a2f808baa9d1",
        "body" : "This benefit can be achieved through other means, such as storing template parameter values in the cluster using service specific storage. This is what DM does today.\n",
        "createdAt" : "2015-12-08T23:32:01Z",
        "updatedAt" : "2016-02-09T13:51:03Z",
        "lastEditedBy" : "8f7fe7a6-7bc9-4dfb-b9c0-a2f808baa9d1",
        "tags" : [
        ]
      },
      {
        "id" : "dc2a24d5-6a7d-42b0-adbb-04bb543f939e",
        "parentId" : "90a40298-6c15-4c9b-b81e-9837773d21dd",
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "I think the point is to simplify the creation of a related set of objects that are linked together in some way, taking into account that resource names, label selectors, and other values (e.g., an application cluster instance id, secrets) need to be substituted consistently across the set of objects.\n",
        "createdAt" : "2016-01-13T01:13:43Z",
        "updatedAt" : "2016-02-09T13:51:03Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      }
    ],
    "commit" : "89a656130da26d4c94b95defdeea7b3749945ea1",
    "line" : null,
    "diffHunk" : "@@ -1,1 +167,171 @@The primary capability provided is that parameter values can easily be shared between components, such as a database password\nthat is provided by the user once, but then attached as an environment variable to both a database pod and a web frontend pod.\n\nIn addition, the template can be repeatedly instantiated for a consistent application deployment experience in different\nnamespaces or Kubernetes clusters."
  },
  {
    "id" : "e0e6a59f-167a-413d-a4c1-2cfcd96085ac",
    "prId" : 18215,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a0b0abdd-37c3-415c-a3a9-6f5ad64427ba",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "Where can this expansion be done?  Any string field of any object in the Objects[] list?  How do we do that - reflection/code-gen (e.g. `func ExpandTemplates(obj, expansions)`) ?\n",
        "createdAt" : "2015-12-10T22:04:52Z",
        "updatedAt" : "2016-02-09T13:51:03Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "f8ca6b27-1ea4-479f-8d7b-a7ec414f6b34",
        "parentId" : "a0b0abdd-37c3-415c-a3a9-6f5ad64427ba",
        "authorId" : "f841e73a-d2ba-4be1-9028-bec3b88e342d",
        "body" : "Today yes, any string field gets checked for parameter substitution:\nhttps://github.com/openshift/origin/blob/master/pkg/template/template.go#L120-L139\n\nhowever as discussed below, i'd like to eliminate the string-only restriction as part of this proposal.  a few approaches to that are discussed toward the end of the document.\n",
        "createdAt" : "2015-12-10T22:09:02Z",
        "updatedAt" : "2016-02-09T13:51:03Z",
        "lastEditedBy" : "f841e73a-d2ba-4be1-9028-bec3b88e342d",
        "tags" : [
        ]
      }
    ],
    "commit" : "89a656130da26d4c94b95defdeea7b3749945ea1",
    "line" : 217,
    "diffHunk" : "@@ -1,1 +215,219 @@type Parameter struct {\n    // Required: Parameter name must be set and it can be referenced in Template\n    // Items using $(PARAMETER_NAME)\n    Name string\n"
  },
  {
    "id" : "53d5ca04-20da-496e-b2ae-7c7898c7f60c",
    "prId" : 18215,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ce9f96e3-d512-4308-b15f-0c250ac56bae",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "What about numeric or bool values?  Those don't seem unreasonable.  Struct values I can see being OOB.  Should this at least carry a 'Type' field for which \"String\" is the only value?\n",
        "createdAt" : "2015-12-10T22:06:23Z",
        "updatedAt" : "2016-02-09T13:51:03Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "0049f6e5-3ec2-4efc-a5d6-637099218e75",
        "parentId" : "ce9f96e3-d512-4308-b15f-0c250ac56bae",
        "authorId" : "f841e73a-d2ba-4be1-9028-bec3b88e342d",
        "body" : "Agree, again this restriction is discussed at the end of the doc and i'd love to eliminate it.  Adding a \"type\" field to the Parameter struct is one of the possible ways to address it, and it's the one i'm currently leaning towards.\n",
        "createdAt" : "2015-12-10T22:10:01Z",
        "updatedAt" : "2016-02-09T13:51:03Z",
        "lastEditedBy" : "f841e73a-d2ba-4be1-9028-bec3b88e342d",
        "tags" : [
        ]
      }
    ],
    "commit" : "89a656130da26d4c94b95defdeea7b3749945ea1",
    "line" : null,
    "diffHunk" : "@@ -1,1 +227,231 @@    // The value replaces all occurrences of the Parameter $(Name) or \n    // $((Name)) expression during the Template to Config transformation.\n    Value string\n\n    // Optional: Indicates the parameter must have a value.  Defaults to false."
  },
  {
    "id" : "fc2ae4f7-e93f-4737-9473-4c7822c47249",
    "prId" : 18215,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b986280b-5215-442b-8651-0f25424019c2",
        "parentId" : null,
        "authorId" : "b40ea59c-0e7d-405e-912c-9b93dd0a41cb",
        "body" : "I think it's important to have an example of invoking the template as well.\n",
        "createdAt" : "2015-12-18T05:22:47Z",
        "updatedAt" : "2016-02-09T13:51:03Z",
        "lastEditedBy" : "b40ea59c-0e7d-405e-912c-9b93dd0a41cb",
        "tags" : [
        ]
      },
      {
        "id" : "eb83d526-5cf9-4223-b7bb-7e310017e10b",
        "parentId" : "b986280b-5215-442b-8651-0f25424019c2",
        "authorId" : "f841e73a-d2ba-4be1-9028-bec3b88e342d",
        "body" : "I don't think we've reached a conclusion on what that looks like just yet...  in my vision, \"invoking\" the template just means passing it to the api endpoint.  If you want to customize parameter values, you(the client) do that before you pass the template object to the api endpoint (eg update the default_value with the value provided by the user.  should perhaps rename that field).\n\nI think you had another suggestion in which there was a sort of instantiation object which wrapped the template name to instantiate and the parameter values to use with the template.\n\nso i'd like to hash that out before trying to include it.\n",
        "createdAt" : "2015-12-18T17:39:20Z",
        "updatedAt" : "2016-02-09T13:51:03Z",
        "lastEditedBy" : "f841e73a-d2ba-4be1-9028-bec3b88e342d",
        "tags" : [
        ]
      },
      {
        "id" : "42857293-87e4-48cb-8298-04a539f8cbe9",
        "parentId" : "b986280b-5215-442b-8651-0f25424019c2",
        "authorId" : "b40ea59c-0e7d-405e-912c-9b93dd0a41cb",
        "body" : "Yeah that's two distinct choices.  The one I proposed is also the DM approach, and also closer to what Terraform does.  This choice also is linked to the choice of how nested templates are defined, since with your proposal I think you're limited to the following, but with the DM approach for invoking templates, one also has the design choice of returning invocation objects from the template body itself.\n\n```\nincludes:\n   - path: https://github.com/myorg/mytemplates/template1.yml\n   - path: https://github.com/myorg/mytemplates/template2.yml\n```\n\nI wonder, with your proposal, in order to specify arguments, will we not end up copy/pasting templates around with nothing changed except the defaults?\n",
        "createdAt" : "2015-12-22T04:13:50Z",
        "updatedAt" : "2016-02-09T13:51:03Z",
        "lastEditedBy" : "b40ea59c-0e7d-405e-912c-9b93dd0a41cb",
        "tags" : [
        ]
      },
      {
        "id" : "0578f409-df6e-4dc7-b1e0-644be6f3e61f",
        "parentId" : "b986280b-5215-442b-8651-0f25424019c2",
        "authorId" : "f841e73a-d2ba-4be1-9028-bec3b88e342d",
        "body" : "> I wonder, with your proposal, in order to specify arguments, will we not end up copy/pasting templates around with nothing changed except the defaults?\n\nthat hasn't been our experience so far.  Either a parameter has no useful default, in which case everyone picks a value at instantiation time, but would not make their own version of the template to set a default, or there's a sane default that most people are happy with and will use the template as is.\n\nIs it possible someone will create a template that, for example, specifies a locale default, and some people decide they want to copy that template so they can have a different default locale rather than setting the locale each time they instantiate it?  perhaps.  But it's far more common (in our experience so far) that someone needs to actually change something in the main template (eg add a new service or replication controller).\n",
        "createdAt" : "2016-01-04T19:51:09Z",
        "updatedAt" : "2016-02-09T13:51:03Z",
        "lastEditedBy" : "f841e73a-d2ba-4be1-9028-bec3b88e342d",
        "tags" : [
        ]
      }
    ],
    "commit" : "89a656130da26d4c94b95defdeea7b3749945ea1",
    "line" : null,
    "diffHunk" : "@@ -1,1 +390,394 @@}\n```\n\n### API Endpoints\n"
  },
  {
    "id" : "94ebcb0f-c6b9-4b2e-a661-2f7a7bdc33c0",
    "prId" : 18215,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "37263076-9931-44f0-bf3b-9b9af5e16834",
        "parentId" : null,
        "authorId" : "b40ea59c-0e7d-405e-912c-9b93dd0a41cb",
        "body" : "I was originally thinking we would also need to ability to call out to a file on the side.  But having read this, I now think there may be no need to allow the \"envelope\" to refer to a secondary file, because for all languages where this makes sense, the language has a way to import a second file itself.  So for the Python form:\n\n```\nbody: |\n  import foo\n```\n\nwould be equivalent to\n\n```\nbodyFile: \"foo.py\"\n```\n\nSimilarly Jinja has {% include %}, Jsonnet has import \"foo.jsonnet\", etc.  In all cases, one can just use a small snippet of the template language's own code to invoke the file.\n",
        "createdAt" : "2015-12-18T06:38:31Z",
        "updatedAt" : "2016-02-09T13:51:03Z",
        "lastEditedBy" : "b40ea59c-0e7d-405e-912c-9b93dd0a41cb",
        "tags" : [
        ]
      },
      {
        "id" : "d66a8fdb-aecb-4979-9b92-fa9431b99f9b",
        "parentId" : "37263076-9931-44f0-bf3b-9b9af5e16834",
        "authorId" : "f841e73a-d2ba-4be1-9028-bec3b88e342d",
        "body" : "yeah i debated this, but if you want total flexibility, you need to be able to have, say, a jinja-style template include content from an openshift-style template, which means you have to handle it at a higher level.\n\nThat said, I agree that it's a bit simpler to just punt on it and say \"if you want composition, handle it within the expansion plugin and the body-content\".  It also allows us to punt on problems like \"do we allow credentials for fetching includes? ssl certs? support protocols other than http?\" which I would prefer to do over trying to solve them here.\n\n@jackgr you've been the biggest advocate for template composition, what's your take?\n",
        "createdAt" : "2015-12-18T17:42:42Z",
        "updatedAt" : "2016-02-09T13:51:03Z",
        "lastEditedBy" : "f841e73a-d2ba-4be1-9028-bec3b88e342d",
        "tags" : [
        ]
      },
      {
        "id" : "03c35876-bff5-425f-a3d9-19f594eafd0d",
        "parentId" : "37263076-9931-44f0-bf3b-9b9af5e16834",
        "authorId" : "b40ea59c-0e7d-405e-912c-9b93dd0a41cb",
        "body" : "That's actually a different issue than what I was talking about, but it's a very interesting question and quite a lot more important to discuss.\n\nHere's how I would characterise the more interesting question:  Clearly we want a template in one language to use a template from another.  So we need a way to include templates from templates that is language-independent.  But languages also have existing importing mechanisms, that are typically limited to importing code from the same language.  Let's just consider Python, as other languages are pretty similar.  If a user wants to include a python template from another python template, they have a choice of 1) importing the python module, executing it to generate the k8s modules, then merging it in, or, 2) using a sub-template to have it merged in by k8s, in which case the two python files don't know about each other.  What is best practice?\n\nWhat we're looking at is really 2 levels of modularity / encapsulation.  This feels a bit like the choice of building everything into a single binary (thus having fewer visible moving parts) or built various parts of the application as dynamically linked libraries and then these parts are re-usable.  That \"fewer visilble moving parts\" property will also apply to k8s if we reify the structure of the template expansion at runtime, as DM does.  If you import within Python, it will appear as a single template to k8s.  So that fundamental UX difference probably should drive the decision of one or the other.  We haven't talked about this at all yet, but if we support live migration of services from one template spec to another, the granularity may be relevant there as well.\n\nI think if a collection of k8s objects can be considered an independent microservice that can be deployed and used by itself, it makes sense for it to be its own template.  But ultimately just like with programming, choosing how to break things up is a difficult problem that has to be handled on a case by case basis, takes a certain amount of intuition, experience and common sense.\n",
        "createdAt" : "2015-12-22T04:50:48Z",
        "updatedAt" : "2016-02-09T13:51:03Z",
        "lastEditedBy" : "b40ea59c-0e7d-405e-912c-9b93dd0a41cb",
        "tags" : [
        ]
      },
      {
        "id" : "189dc669-1367-44b6-b17c-42971b0c9f0c",
        "parentId" : "37263076-9931-44f0-bf3b-9b9af5e16834",
        "authorId" : "b40ea59c-0e7d-405e-912c-9b93dd0a41cb",
        "body" : "The problem you explicitly called out of how to refer to secondary templates is probably orthogonal to all of that -- and it appears even if we don't nest templates -- all that is needed is to have this template instantiation object.  The problem is really how to refer to a template -- how to give it a unique name -- and also how to get at it.  This is probably something where we would do something very rudimentary at first.  E.g. if we do client side expansion, we can just use filenames.  We probably want to prefix with file:// if we want to allow other things later.  On the server side, this is much harder.  Probably the simplest thing to do is have some sort of registry, but ultimately some sort of github integration will be expected by users.  Terraform has that, and people like it.  This, we probably need to actually discuss.\n\nFWIW I don't think punting the question is the right thing to do, although it's tempting.  This is a fundamental problem and we should try to answer it in the first pass.\n",
        "createdAt" : "2015-12-22T04:51:23Z",
        "updatedAt" : "2016-02-09T13:51:03Z",
        "lastEditedBy" : "b40ea59c-0e7d-405e-912c-9b93dd0a41cb",
        "tags" : [
        ]
      },
      {
        "id" : "f2dca974-61a6-46f3-b6a2-7d1ffb93e433",
        "parentId" : "37263076-9931-44f0-bf3b-9b9af5e16834",
        "authorId" : "8f7fe7a6-7bc9-4dfb-b9c0-a2f808baa9d1",
        "body" : "@bparees I think the composition mechanism can be left to the specific templating technology/language/format. See my top level proposal re: iterative expansion of API objects by the api server using registered templating engines.\n\nAnother point to be made here is that if the object being manipulated is just ordinary configuration, then by necessity, it's written as a standard API object. Any templates it references are stored elsewhere, either in the cluster or in a repository like Github. They can be written in any language appropriate to the expansion technology (e.g., jsonnet, python, javascript, Jinja, Ruby, etc.).\n\nIn general, a template written in one language will not invoke a template written in a different language directly. Instead, it will generate expansion results that contain additional template invocations. By definition, those expansion results are just standard k8s API objects, so any template nesting is intermediated by that format (i.e., it's just YAML/JSON).\n\nThis is how DM works today, and it allows a Jinja template to generate a YAML object that invokes a python template, which generates a YAML object that invokes a Jinja template, which generates...\n",
        "createdAt" : "2016-01-05T03:26:53Z",
        "updatedAt" : "2016-02-09T13:51:03Z",
        "lastEditedBy" : "8f7fe7a6-7bc9-4dfb-b9c0-a2f808baa9d1",
        "tags" : [
        ]
      },
      {
        "id" : "aa20c198-0da5-465e-b114-ad5ffc429bbe",
        "parentId" : "37263076-9931-44f0-bf3b-9b9af5e16834",
        "authorId" : "8f7fe7a6-7bc9-4dfb-b9c0-a2f808baa9d1",
        "body" : "@sparkprime re: unique template naming, please see the object processor proposal below. It lets users register object processors, which are just ordinary k8s services, as handlers for qualified API object Kinds (e.g., com.google.apis.SomeTemplate).\n\nThis approach lets every object processor define its own template format/language/technology, its own template repositories and its own template names.\n",
        "createdAt" : "2016-01-05T05:45:45Z",
        "updatedAt" : "2016-02-09T13:51:03Z",
        "lastEditedBy" : "8f7fe7a6-7bc9-4dfb-b9c0-a2f808baa9d1",
        "tags" : [
        ]
      }
    ],
    "commit" : "89a656130da26d4c94b95defdeea7b3749945ea1",
    "line" : 560,
    "diffHunk" : "@@ -1,1 +558,562 @@2. Within the Template itself\n\nThis proposal suggests including the parameter definitions within the Template, which provides a self-contained structure that\ncan be easily versioned, transported, and instantiated without risk of mismatching content.  In addition, a Template can easily\nbe validated to confirm that all parameter references are resolveable."
  },
  {
    "id" : "e459c027-8036-4681-a8ed-4675a0eff519",
    "prId" : 18215,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d8239de3-1684-4167-a8d6-91e18b2cbcea",
        "parentId" : null,
        "authorId" : "b40ea59c-0e7d-405e-912c-9b93dd0a41cb",
        "body" : "Validation is static analysis, and the viability of that depends entirely on the language in question.\n",
        "createdAt" : "2015-12-18T06:42:40Z",
        "updatedAt" : "2016-02-09T13:51:03Z",
        "lastEditedBy" : "b40ea59c-0e7d-405e-912c-9b93dd0a41cb",
        "tags" : [
        ]
      },
      {
        "id" : "6f80d3f0-81d2-4336-801c-24427999aa92",
        "parentId" : "d8239de3-1684-4167-a8d6-91e18b2cbcea",
        "authorId" : "f841e73a-d2ba-4be1-9028-bec3b88e342d",
        "body" : "yeah that sentence is no longer valid with this proposal, i'll remove it/clarify it.\n",
        "createdAt" : "2015-12-18T17:43:20Z",
        "updatedAt" : "2016-02-09T13:51:03Z",
        "lastEditedBy" : "f841e73a-d2ba-4be1-9028-bec3b88e342d",
        "tags" : [
        ]
      }
    ],
    "commit" : "89a656130da26d4c94b95defdeea7b3749945ea1",
    "line" : 562,
    "diffHunk" : "@@ -1,1 +560,564 @@This proposal suggests including the parameter definitions within the Template, which provides a self-contained structure that\ncan be easily versioned, transported, and instantiated without risk of mismatching content.  In addition, a Template can easily\nbe validated to confirm that all parameter references are resolveable.\n\nSeparating the parameter definitions makes for a more complex process with respect to"
  },
  {
    "id" : "940ef6d8-3d65-4cad-8b3f-2a8d7e0d0f82",
    "prId" : 18215,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "75304936-6ebd-42e3-91dc-e8876736b1d7",
        "parentId" : null,
        "authorId" : "b40ea59c-0e7d-405e-912c-9b93dd0a41cb",
        "body" : "Only marginally more complex -- if the file begins with --- then it's a yaml file -- parse it as such and interpret it according to the kind field.  If the file does not, then untar it, find the file at the root of the tarball called main.yaml, and assume that is yaml.\n",
        "createdAt" : "2015-12-18T06:48:23Z",
        "updatedAt" : "2016-02-09T13:51:03Z",
        "lastEditedBy" : "b40ea59c-0e7d-405e-912c-9b93dd0a41cb",
        "tags" : [
        ]
      },
      {
        "id" : "aca8098e-370c-4984-80f2-462b9fdccf32",
        "parentId" : "75304936-6ebd-42e3-91dc-e8876736b1d7",
        "authorId" : "f841e73a-d2ba-4be1-9028-bec3b88e342d",
        "body" : "that presumes that i am willing to store my template definition as a binary, which, if i'm storing them in git, isn't acceptable.  and if storing them in k8s itself, means doing something ugly like base64 encoding it which makes it totally opaque from an inspection perspective.\n",
        "createdAt" : "2015-12-18T17:46:59Z",
        "updatedAt" : "2016-02-09T13:51:03Z",
        "lastEditedBy" : "f841e73a-d2ba-4be1-9028-bec3b88e342d",
        "tags" : [
        ]
      }
    ],
    "commit" : "89a656130da26d4c94b95defdeea7b3749945ea1",
    "line" : 566,
    "diffHunk" : "@@ -1,1 +564,568 @@Separating the parameter definitions makes for a more complex process with respect to\n* Editing a template (if/when first class editing tools are created)\n* Storing/retrieving template objects with a central store\n\nNote that the `/templates/sometemplate/processed` subresource would accept a standalone set of parameters to be applied to `sometemplate`."
  },
  {
    "id" : "1faadcbd-ad1b-4fe6-9c14-e02b5a4ff4d9",
    "prId" : 18215,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "45758109-3f51-498a-b986-a779066f35ed",
        "parentId" : null,
        "authorId" : "8f7fe7a6-7bc9-4dfb-b9c0-a2f808baa9d1",
        "body" : "I don't believe the terms PetSet and DaemonSet are either widely known or documented in the k8s documentation. Suggest that we remove them from this document.\n",
        "createdAt" : "2016-01-05T03:00:07Z",
        "updatedAt" : "2016-02-09T13:51:03Z",
        "lastEditedBy" : "8f7fe7a6-7bc9-4dfb-b9c0-a2f808baa9d1",
        "tags" : [
        ]
      },
      {
        "id" : "8e13856d-8348-44a6-83d6-677fe2aeb006",
        "parentId" : "45758109-3f51-498a-b986-a779066f35ed",
        "authorId" : "f841e73a-d2ba-4be1-9028-bec3b88e342d",
        "body" : "this isn't user documentation, i don't see why we wouldn't refer to use cases+terminology understood by k8s developers here as we explore the problem we're trying to solve.\n",
        "createdAt" : "2016-01-05T03:49:28Z",
        "updatedAt" : "2016-02-09T13:51:03Z",
        "lastEditedBy" : "f841e73a-d2ba-4be1-9028-bec3b88e342d",
        "tags" : [
        ]
      },
      {
        "id" : "2590c991-3748-4518-92a2-dce0c7270687",
        "parentId" : "45758109-3f51-498a-b986-a779066f35ed",
        "authorId" : "8f7fe7a6-7bc9-4dfb-b9c0-a2f808baa9d1",
        "body" : "I'm not worried about ki8s developers. I'm worried about members of the SIG Config community who have an interest in this proposal. I don't know how many of them are familiar with these terms. I suspect not many. At a minimum, it would help to provide references to their definitions. Better yet, choose some other examples that are more commonly understood.\n",
        "createdAt" : "2016-01-05T03:58:50Z",
        "updatedAt" : "2016-02-09T13:51:03Z",
        "lastEditedBy" : "8f7fe7a6-7bc9-4dfb-b9c0-a2f808baa9d1",
        "tags" : [
        ]
      }
    ],
    "commit" : "89a656130da26d4c94b95defdeea7b3749945ea1",
    "line" : null,
    "diffHunk" : "@@ -1,1 +96,100 @@  is required or can be left blank.\n* Parameterize the replica count of a deployment or [PetSet](https://github.com/kubernetes/kubernetes/pull/18016)\n* Parameterize part of the labels and selector for a DaemonSet\n* Parameterize quota/limit values for a pod\n* Parameterize a secret value so a user can provide a custom password or other secret at deployment time"
  },
  {
    "id" : "c23ba9af-8030-4e81-a27c-1d135ef585d9",
    "prId" : 18215,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "594f5dc8-bc62-4e03-a2bb-1d07cfdc0bec",
        "parentId" : null,
        "authorId" : "8f7fe7a6-7bc9-4dfb-b9c0-a2f808baa9d1",
        "body" : "I don't believe this proposal should try to establish a specific schema, language or format for templates. There will be many candidates and we should not try to mandate one, since we are not likely to address everyone's needs effectively.\n",
        "createdAt" : "2016-01-05T03:08:15Z",
        "updatedAt" : "2016-02-09T13:51:03Z",
        "lastEditedBy" : "8f7fe7a6-7bc9-4dfb-b9c0-a2f808baa9d1",
        "tags" : [
        ]
      },
      {
        "id" : "66224a88-2431-4f18-a372-93882fae93e2",
        "parentId" : "594f5dc8-bc62-4e03-a2bb-1d07cfdc0bec",
        "authorId" : "f841e73a-d2ba-4be1-9028-bec3b88e342d",
        "body" : "I think we've definitely agreed to define a template object schema with a variable \"body\" that can support different template content along side common template metadata.\n",
        "createdAt" : "2016-01-05T03:55:19Z",
        "updatedAt" : "2016-02-09T13:51:03Z",
        "lastEditedBy" : "f841e73a-d2ba-4be1-9028-bec3b88e342d",
        "tags" : [
        ]
      },
      {
        "id" : "bdb5bf8d-c524-4c08-bb79-65b1399734d3",
        "parentId" : "594f5dc8-bc62-4e03-a2bb-1d07cfdc0bec",
        "authorId" : "8f7fe7a6-7bc9-4dfb-b9c0-a2f808baa9d1",
        "body" : "I'm not sure we've necessarily agreed on that. The mechanism I proposed, and which we discussed when the SIG last met, calls for using ordinary API objects that can be processed by registered object processors. It's a server side version of the stream processor proposal by @brendandburns. If we go that route, then there's no need to stipulate a specific template format.\n",
        "createdAt" : "2016-01-05T04:14:03Z",
        "updatedAt" : "2016-02-09T13:51:03Z",
        "lastEditedBy" : "8f7fe7a6-7bc9-4dfb-b9c0-a2f808baa9d1",
        "tags" : [
        ]
      }
    ],
    "commit" : "89a656130da26d4c94b95defdeea7b3749945ea1",
    "line" : 105,
    "diffHunk" : "@@ -1,1 +103,107 @@## Design Assumptions\n\nThe goal for this proposal is a simple schema which addresses a few basic challenges:\n\n* Allow application authors to expose configuration knobs for application deployers, with suggested defaults and"
  },
  {
    "id" : "6b67b26a-8d56-4a83-990b-a3da22aadb87",
    "prId" : 18215,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "86728233-99d8-48cc-a0a5-f6b463a9e70a",
        "parentId" : null,
        "authorId" : "8f7fe7a6-7bc9-4dfb-b9c0-a2f808baa9d1",
        "body" : "Instead of requiring the library to `reside within` Kubernetes, we should relax this requirement to stipulate that the library must be `accessible from within` Kubernetes. This more relaxed requirement admits libraries that reside within a cluster, as well as libraries that reside in some other readily accessible location, such as Github or cloud provider storage buckets, for example.\n",
        "createdAt" : "2016-01-05T03:11:20Z",
        "updatedAt" : "2016-02-09T13:51:03Z",
        "lastEditedBy" : "8f7fe7a6-7bc9-4dfb-b9c0-a2f808baa9d1",
        "tags" : [
        ]
      },
      {
        "id" : "2496154c-8123-48d1-a9dd-8c437d2d23a3",
        "parentId" : "86728233-99d8-48cc-a0a5-f6b463a9e70a",
        "authorId" : "f841e73a-d2ba-4be1-9028-bec3b88e342d",
        "body" : "it also introduces the requirement that we discuss how users provide credentials and authenticate to those external systems (and define/configure references to them)  I would suggest that could be done as a follow on enhancement to the template storage, rather than buying that complexity now.\n",
        "createdAt" : "2016-01-05T03:57:41Z",
        "updatedAt" : "2016-02-09T13:51:03Z",
        "lastEditedBy" : "f841e73a-d2ba-4be1-9028-bec3b88e342d",
        "tags" : [
        ]
      },
      {
        "id" : "8fe554dd-e0de-4021-954d-29cadbfeaa7f",
        "parentId" : "86728233-99d8-48cc-a0a5-f6b463a9e70a",
        "authorId" : "8f7fe7a6-7bc9-4dfb-b9c0-a2f808baa9d1",
        "body" : "Template repositories in Github are well established precedent. Storing templates in the k8s cluster is not a widely used practice, outside of OpenShift. I think the repository URL is a general enough requirement that we should include it in the first pass. In many cases, repositories will not require any credentials to read public content. That's certainly the case with DockerHub and Google Container Registry today. So, it's not clear that auth will necessarily be a significant issue out of the gate.\n",
        "createdAt" : "2016-01-05T04:17:28Z",
        "updatedAt" : "2016-02-09T13:51:03Z",
        "lastEditedBy" : "8f7fe7a6-7bc9-4dfb-b9c0-a2f808baa9d1",
        "tags" : [
        ]
      }
    ],
    "commit" : "89a656130da26d4c94b95defdeea7b3749945ea1",
    "line" : null,
    "diffHunk" : "@@ -1,1 +109,113 @@* Allow application deployers to easily customize exposed values like object names while maintaining referential integrity\n  between dependent pieces (for example ensuring a pod's labels always match the corresponding selector definition of the service)\n* Support maintaining a library of templates within Kubernetes that can be accessed and instantiated by end users\n* Allow users to quickly and repeatedly deploy instances of well-defined application patterns produced by the community\n* Follow established Kubernetes API patterns by defining new template related APIs which consume+return first class Kubernetes"
  },
  {
    "id" : "a8a84f04-d2fd-4c76-b0c4-5230a1f8b3f0",
    "prId" : 18215,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "058c0326-446a-4293-9df5-a29357390874",
        "parentId" : null,
        "authorId" : "8f7fe7a6-7bc9-4dfb-b9c0-a2f808baa9d1",
        "body" : "I think this point is the key to the proposal. See my top level comment.\n",
        "createdAt" : "2016-01-05T03:22:03Z",
        "updatedAt" : "2016-02-09T13:51:03Z",
        "lastEditedBy" : "8f7fe7a6-7bc9-4dfb-b9c0-a2f808baa9d1",
        "tags" : [
        ]
      }
    ],
    "commit" : "89a656130da26d4c94b95defdeea7b3749945ea1",
    "line" : null,
    "diffHunk" : "@@ -1,1 +112,116 @@* Allow users to quickly and repeatedly deploy instances of well-defined application patterns produced by the community\n* Follow established Kubernetes API patterns by defining new template related APIs which consume+return first class Kubernetes\n  API (and therefore json conformant) objects.\n\nWe do not wish to invent a new Turing-complete templating language.  There are good options available"
  },
  {
    "id" : "26c24860-a9ad-4c65-a49a-0de1125e16d6",
    "prId" : 18215,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bd400648-3d37-433b-aa75-cc33512aa50b",
        "parentId" : null,
        "authorId" : "8f7fe7a6-7bc9-4dfb-b9c0-a2f808baa9d1",
        "body" : "The web has established decades of precedent for object references that may or may not resolve, and society generally has a high level of comfort with it. Even the most primitive concept in k8s, a container, can't be specified without referring to an image that resides at some external location. What's the point in trying to hermetically seal templates, when the objects they create contain dependencies?\n",
        "createdAt" : "2016-01-05T04:21:08Z",
        "updatedAt" : "2016-02-09T13:51:03Z",
        "lastEditedBy" : "8f7fe7a6-7bc9-4dfb-b9c0-a2f808baa9d1",
        "tags" : [
        ]
      }
    ],
    "commit" : "89a656130da26d4c94b95defdeea7b3749945ea1",
    "line" : null,
    "diffHunk" : "@@ -1,1 +122,126 @@Allowing templates to reference other templates presents versioning+consistency challenges along with making the template\nno longer a self-contained portable object.  Scenarios necessitating multiple templates can be handled in one of several\nalternate ways:\n\n* Explicitly constructing a new template that merges the existing templates (tooling can easily be constructed to perform this"
  },
  {
    "id" : "fec40e9b-9421-49ad-80f8-903f8c101d81",
    "prId" : 18215,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "630ff7cd-7485-4481-ae14-594bd754ff1a",
        "parentId" : null,
        "authorId" : "8f7fe7a6-7bc9-4dfb-b9c0-a2f808baa9d1",
        "body" : "Another approach worth mentioning is recursive expansion.\n",
        "createdAt" : "2016-01-05T04:22:28Z",
        "updatedAt" : "2016-02-09T13:51:03Z",
        "lastEditedBy" : "8f7fe7a6-7bc9-4dfb-b9c0-a2f808baa9d1",
        "tags" : [
        ]
      }
    ],
    "commit" : "89a656130da26d4c94b95defdeea7b3749945ea1",
    "line" : null,
    "diffHunk" : "@@ -1,1 +127,131 @@  operation since the templates are first class api objects).\n* Manually instantiating each template and utilizing [service linking](https://github.com/kubernetes/kubernetes/pull/17543) to share\n  any necessary configuration data.\n\nThis document will also refrain from proposing server APIs or client implementations.  This has been a point of debate, and it makes"
  },
  {
    "id" : "52980a16-d13d-4d82-a5b7-536a0628a10c",
    "prId" : 18215,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3bc251d8-b9c2-486f-a512-c10f0ed37277",
        "parentId" : null,
        "authorId" : "8f7fe7a6-7bc9-4dfb-b9c0-a2f808baa9d1",
        "body" : "We discussed and agreed on a proposal to define a server side templating engine registration mechanism at the last SIG meeting. If I'm not mistaken, that invalidates this paragraph.\n",
        "createdAt" : "2016-01-05T04:23:58Z",
        "updatedAt" : "2016-02-09T13:51:03Z",
        "lastEditedBy" : "8f7fe7a6-7bc9-4dfb-b9c0-a2f808baa9d1",
        "tags" : [
        ]
      }
    ],
    "commit" : "89a656130da26d4c94b95defdeea7b3749945ea1",
    "line" : 134,
    "diffHunk" : "@@ -1,1 +132,136 @@more sense to focus on the template/parameter specification/syntax than to worry about the tooling that will process or manage the\ntemplate objects.  However since there is a desire to at least be able to support a server side implementation, this proposal\ndoes assume the specification will be k8s API friendly.\n\n## Desired characteristics"
  },
  {
    "id" : "d4f97cd9-94c2-4677-a19e-49cbf9db08da",
    "prId" : 18215,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "df21bb57-42f8-48aa-9f6e-1d39ede92e0d",
        "parentId" : null,
        "authorId" : "8f7fe7a6-7bc9-4dfb-b9c0-a2f808baa9d1",
        "body" : "I believe this requirement is important regardless of whether or not a server side template processing api is supplied an an ApiGroup. There are other ways to supply such an API (e.g., as an ordinary k8s service). Regardless of how such mechanisms are supplied, they should consume standard k8s API objects and produce standard k8s API objects as the result of the processing they perform.\n",
        "createdAt" : "2016-01-05T04:26:25Z",
        "updatedAt" : "2016-02-09T13:51:03Z",
        "lastEditedBy" : "8f7fe7a6-7bc9-4dfb-b9c0-a2f808baa9d1",
        "tags" : [
        ]
      }
    ],
    "commit" : "89a656130da26d4c94b95defdeea7b3749945ea1",
    "line" : null,
    "diffHunk" : "@@ -1,1 +140,144 @@  the existing k8s codec scheme rather than having to define/introduce a new syntax evolution mechanism.\n  * (Even if they are not part of the k8s core, it would still be good if a server side template processing+managing api supplied\n    as an ApiGroup consumed the same k8s object schema as the peer k8s apis rather than introducing a new one)\n* Self-contained parameter definitions.  This allows a template to be a portable object which includes metadata that describe\n  the inputs it expects, making it easy to wrapper a user interface around the parameterization flow."
  },
  {
    "id" : "cd9fb93f-7400-473c-8b1a-fed60ff224d3",
    "prId" : 18215,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3f3c6633-e2b6-4d09-800f-e2a4e276c599",
        "parentId" : null,
        "authorId" : "8f7fe7a6-7bc9-4dfb-b9c0-a2f808baa9d1",
        "body" : "Referring to the point above re: references, and given that much of the web relies on external schemas, it seems like external schemas are a more than acceptable alternative to the embedded schemas required by this paragraph in the text. Let's change the language to say that schemas can be embedded or external.\n\nMore important than where the schema lives is what type system it uses. Given that we're using standard k8s API objects, which are YAML/JSON, the type system for anything they contain, whether parameters or other values, must by definition by YAML/JSON compatible, and I'll go even so far as to say that it should be the same type system used by k8s for these objects, which is Swagger, a semi-official superset of JSON schema.\n",
        "createdAt" : "2016-01-05T04:31:47Z",
        "updatedAt" : "2016-02-09T13:51:03Z",
        "lastEditedBy" : "8f7fe7a6-7bc9-4dfb-b9c0-a2f808baa9d1",
        "tags" : [
        ]
      }
    ],
    "commit" : "89a656130da26d4c94b95defdeea7b3749945ea1",
    "line" : null,
    "diffHunk" : "@@ -1,1 +142,146 @@    as an ApiGroup consumed the same k8s object schema as the peer k8s apis rather than introducing a new one)\n* Self-contained parameter definitions.  This allows a template to be a portable object which includes metadata that describe\n  the inputs it expects, making it easy to wrapper a user interface around the parameterization flow.\n\n  scheme should support all of those types for substitution."
  },
  {
    "id" : "c6747ded-9c55-4771-aa77-5157b66664f6",
    "prId" : 18215,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4c260e67-e0f9-4618-9465-ebed83d1e0dc",
        "parentId" : null,
        "authorId" : "8f7fe7a6-7bc9-4dfb-b9c0-a2f808baa9d1",
        "body" : "This point follows from the requirement to use the k8s API object type system (i.e., Swagger).\n",
        "createdAt" : "2016-01-05T04:57:04Z",
        "updatedAt" : "2016-02-09T13:51:03Z",
        "lastEditedBy" : "8f7fe7a6-7bc9-4dfb-b9c0-a2f808baa9d1",
        "tags" : [
        ]
      }
    ],
    "commit" : "89a656130da26d4c94b95defdeea7b3749945ea1",
    "line" : null,
    "diffHunk" : "@@ -1,1 +146,150 @@  scheme should support all of those types for substitution.\n  * complex types (struct/map/list) can be defined in terms of the available primitives, so it's preferred to avoid the complexity\n    of allowing for full complex-type substitution.\n* Parameter metadata.  Parameters should include at a minimum, information describing the purpose of the parameter, whether it is\n  required/optional, and a default/suggested value.  Type information could also be required to enable more intelligent client interfaces."
  },
  {
    "id" : "29a51f52-626b-4075-a016-944d01cbf2f6",
    "prId" : 18215,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "912ea435-be51-4cd4-8ef2-acffa31c60c5",
        "parentId" : null,
        "authorId" : "8f7fe7a6-7bc9-4dfb-b9c0-a2f808baa9d1",
        "body" : "One thing we haven't made clear here is the distinction between:\n- a template, which by definition is an incomplete form that must be completed by supplying parameters, and \n- a template invocation, which is just an ordinary chunk of configuration that refers to a template (e.g., through its Kind).\n\nI believe the API we're talking about in this section is the API for expanding a template invocation. It manipulates configuration that invokes templates, not the templates themselves.\n",
        "createdAt" : "2016-01-05T05:11:28Z",
        "updatedAt" : "2016-02-09T13:51:03Z",
        "lastEditedBy" : "8f7fe7a6-7bc9-4dfb-b9c0-a2f808baa9d1",
        "tags" : [
        ]
      }
    ],
    "commit" : "89a656130da26d4c94b95defdeea7b3749945ea1",
    "line" : 558,
    "diffHunk" : "@@ -1,1 +556,560 @@\n1. In a separate standalone file\n2. Within the Template itself\n\nThis proposal suggests including the parameter definitions within the Template, which provides a self-contained structure that"
  },
  {
    "id" : "380785cb-320e-42f8-ad17-805ca8af5528",
    "prId" : 18215,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "22cdf39d-8b56-4175-91ae-75cc61b8e572",
        "parentId" : null,
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "I also want to use this to address fine-grain scoping #1698.\n\nAnd we need to be able to create multiple resources for cron/scheduled job cases: #11980.\n",
        "createdAt" : "2016-01-06T20:25:32Z",
        "updatedAt" : "2016-02-09T13:51:03Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      }
    ],
    "commit" : "89a656130da26d4c94b95defdeea7b3749945ea1",
    "line" : 34,
    "diffHunk" : "@@ -1,1 +32,36 @@## Motivation\n\nAddresses https://github.com/kubernetes/kubernetes/issues/11492\n\nThere are two main motivators for Template functionality in Kubernetes:  Controller Instantiation and Application Definition"
  },
  {
    "id" : "0db4adcb-e6f0-4991-9f68-822f1e7fe4d7",
    "prId" : 18215,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8de36779-0830-4c54-b948-e8b955652f8f",
        "parentId" : null,
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "How are the selectors identified? Just by the key name \"selector\"? NodeSelector, for instance, shouldn't be modified.\n",
        "createdAt" : "2016-01-13T01:17:11Z",
        "updatedAt" : "2016-02-09T13:51:03Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "53a5afee-b209-4000-9413-b3bbf0f3f506",
        "parentId" : "8de36779-0830-4c54-b948-e8b955652f8f",
        "authorId" : "f841e73a-d2ba-4be1-9028-bec3b88e342d",
        "body" : "this is the point/question I was trying to bring up during the in person discussion last week.  It seems to me that doing this requires a certain level of api/schema awareness on the part of the processor to understand \"the object i'm processing is a ReplicationController, therefore i need to apply this label to the selector field\" and whatever other very specific object types/fields where we'd want to do this.\n\nIn the existing implementation labels are only applied to the object's metadata, which is of course common across all objects, so it's a much simpler problem.\n\nThere's also the question of whether we'd really want all the labels applied to all the selectors.  Since all the pods created by the template are going to have the same labels (or at least a subset of matching labels) as defined by the Template, using those same labels for the selector is going to result in a selector that selects all the pods created by the template.  Likely that's not what is desired.\n\nPerhaps I don't fully grasp what you were intending when you proposed that labels be applied to selector definitions.  Can you give a quick example of how it would work for a template that defines multiple replication controllers/pod templates?  (eg an app pod and a db pod)\n",
        "createdAt" : "2016-01-13T02:27:52Z",
        "updatedAt" : "2016-02-09T13:51:03Z",
        "lastEditedBy" : "f841e73a-d2ba-4be1-9028-bec3b88e342d",
        "tags" : [
        ]
      },
      {
        "id" : "f7cf1189-babe-4bca-9928-b4fff1672fbf",
        "parentId" : "8de36779-0830-4c54-b948-e8b955652f8f",
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "Hmm. I was thinking along the lines of #1698 and #15390. I wasn't expecting all the labels to come from the template.\n\nHowever, maybe we can punt on modifying selectors for now, by assuming that we'll add support for unique label generation #12298.\n\nNote that pods created by controllers in the template would not carry the labels attached to the controller unless the substitution mechanism injected them into the pod template.\n",
        "createdAt" : "2016-01-14T04:49:21Z",
        "updatedAt" : "2016-02-09T13:51:03Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      }
    ],
    "commit" : "89a656130da26d4c94b95defdeea7b3749945ea1",
    "line" : 205,
    "diffHunk" : "@@ -1,1 +203,207 @@    // Optional: ObjectLabels is a set of labels that are applied to every\n    // object during the Template to Config transformation\n    // These labels are also be applied to selectors defined by objects in the template\n    ObjectLabels map[string]string\n}"
  },
  {
    "id" : "2c9a93cb-86f8-4797-86ac-365dab8e1bc6",
    "prId" : 18215,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "91201523-9d30-4d93-9b37-7825bca25205",
        "parentId" : null,
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "We should raise an error if there's ambiguity with our env expansion mechanism.\n",
        "createdAt" : "2016-01-13T01:40:28Z",
        "updatedAt" : "2016-02-09T13:51:03Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "d476fc1a-56e6-4ab0-83c6-14510e0ff443",
        "parentId" : "91201523-9d30-4d93-9b37-7825bca25205",
        "authorId" : "f841e73a-d2ba-4be1-9028-bec3b88e342d",
        "body" : "I would think a reasonable assumption is that template substitution occurs first and therefore takes precedence over env expansion, rather than being in conflict.\n\nChecking whether a given $(VAL) could also represent an env variable to be expanded is going to complicate the processing quite a bit, i'd think (though i'm not very familiar w/ the env expansion logic)\n",
        "createdAt" : "2016-01-13T02:32:58Z",
        "updatedAt" : "2016-02-09T13:51:03Z",
        "lastEditedBy" : "f841e73a-d2ba-4be1-9028-bec3b88e342d",
        "tags" : [
        ]
      },
      {
        "id" : "d44fbf76-103a-468d-87b5-0da927b7994c",
        "parentId" : "91201523-9d30-4d93-9b37-7825bca25205",
        "authorId" : "f841e73a-d2ba-4be1-9028-bec3b88e342d",
        "body" : "i'm still of mixed feelings on this, but i'm updating the proposal to indicate ambiguity will be an error.\n",
        "createdAt" : "2016-01-13T23:08:18Z",
        "updatedAt" : "2016-02-09T13:51:03Z",
        "lastEditedBy" : "f841e73a-d2ba-4be1-9028-bec3b88e342d",
        "tags" : [
        ]
      }
    ],
    "commit" : "89a656130da26d4c94b95defdeea7b3749945ea1",
    "line" : 436,
    "diffHunk" : "@@ -1,1 +434,438 @@3. Adding all labels defined in the templates ObjectLabels field.\n4. For each field, check if the value matches a parameter name and if so, set the value of the field to the value of the parameter.\n  * Partial substitutions are accepted, such as `SOME_$(PARAM)` which would be transformed into `SOME_XXXX` where `XXXX` is the value\n    of the `$(PARAM)` parameter.\n  * If a given $(VAL) could be resolved to either a parameter or an environment variable/downward api reference, an error will be"
  },
  {
    "id" : "c4a6ecff-fb5a-4dba-b886-f36904fc04f8",
    "prId" : 18215,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5f8e5387-ff66-4ef5-b23e-b0456e45d81b",
        "parentId" : null,
        "authorId" : "8f7fe7a6-7bc9-4dfb-b9c0-a2f808baa9d1",
        "body" : "This section should be split out as a separate PR, per discussion in the SIG, so that this PR deals only with requirements.\n",
        "createdAt" : "2016-01-13T20:52:22Z",
        "updatedAt" : "2016-02-09T13:51:03Z",
        "lastEditedBy" : "8f7fe7a6-7bc9-4dfb-b9c0-a2f808baa9d1",
        "tags" : [
        ]
      },
      {
        "id" : "0debd05e-3386-4923-908b-b23514895940",
        "parentId" : "5f8e5387-ff66-4ef5-b23e-b0456e45d81b",
        "authorId" : "f841e73a-d2ba-4be1-9028-bec3b88e342d",
        "body" : "We can discuss that in the sig-config hangout today, but based on the direction things went last time I did that, i'm not inclined to do it again.\n",
        "createdAt" : "2016-01-13T21:04:47Z",
        "updatedAt" : "2016-02-09T13:51:03Z",
        "lastEditedBy" : "f841e73a-d2ba-4be1-9028-bec3b88e342d",
        "tags" : [
        ]
      }
    ],
    "commit" : "89a656130da26d4c94b95defdeea7b3749945ea1",
    "line" : null,
    "diffHunk" : "@@ -1,1 +153,157 @@\n\n## Proposed Implementation\n\n### Overview"
  }
]
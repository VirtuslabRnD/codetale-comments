[
  {
    "id" : "4b94a4ee-bcba-4630-aeb3-4789b97594fc",
    "prId" : 24154,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fc294a76-fde3-41d9-93cc-53850a0e5379",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "I think we would do better to write this as Go structs.  It's more precise.\n",
        "createdAt" : "2016-04-14T22:54:22Z",
        "updatedAt" : "2016-05-18T17:14:38Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "efea8012-85ee-413c-88f9-793fc65e62e3",
        "parentId" : "fc294a76-fde3-41d9-93cc-53850a0e5379",
        "authorId" : "d168965e-f2a1-46dc-9041-18f8ba845ebe",
        "body" : "Yeah, I agree.  I have a section in Go structs below - should I remove this section entirely?\n",
        "createdAt" : "2016-04-14T23:08:53Z",
        "updatedAt" : "2016-05-18T17:14:38Z",
        "lastEditedBy" : "d168965e-f2a1-46dc-9041-18f8ba845ebe",
        "tags" : [
        ]
      },
      {
        "id" : "093a4e13-1719-4f93-b6a5-e78819b7c642",
        "parentId" : "fc294a76-fde3-41d9-93cc-53850a0e5379",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "I think we should make the Go struct + comments the most precise specification of structure.  I think some examples of policy YAML would be useful below.\n",
        "createdAt" : "2016-04-14T23:27:30Z",
        "updatedAt" : "2016-05-18T17:14:38Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "872d2b71c63431878e382e6e34c581c047f04791",
    "line" : null,
    "diffHunk" : "@@ -1,1 +105,109 @@The above structures will be represented in v1beta1 as a json encoded annotation like so:\n\n```yaml\nkind: Namespace\napiVersion: v1"
  },
  {
    "id" : "afd1c8a3-c443-4983-b70b-ba56b5f71aba",
    "prId" : 24154,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5ab24f38-a21f-4197-afee-bb1a8015e66a",
        "parentId" : null,
        "authorId" : "7a59a326-58b3-4590-b70a-297d2e27daa5",
        "body" : "Do we allow a network plugin to not be capable of fully implementing this spec?  I can think of a plausible motivation for that: if the operator chooses to use userspace proxies for k8s Services, that makes full implementation of this spec extra difficult --- but it poses no extra problem for NetworkPolicy objects that do not discriminate on client.  Do we allow an operator to use a network plugin that does not implement this spec at all?\n\nIf we allow less than full implementation of this spec, what happens to input that can not be fully implemented?  Is it rejected at validation?  Is there a way to merely issue a warning at input time?  Or should a warning appear in a status block?\n\nI assume we all came at this from a security and restriction point of view.  But if we contemplate less than full implementation then we need a more nuanced story.  I could imagine this point of view, which distinguishes between \"application\" (a program that uses the k8s API) and \"application deployer\" (a person that chooses to run an application on a cluster): an application creates NetworkPolicy objects to describe the connectivity it needs; the cluster's job is to provide at least that much connectivity; a good cluster will reject some unneeded traffic; a really good cluster will reject all unneeded traffic; the more concerned the application deployer is about security, the more he will care about the cluster rejecting all the traffic that the application does not need.\n",
        "createdAt" : "2016-04-16T04:00:52Z",
        "updatedAt" : "2016-05-18T17:14:38Z",
        "lastEditedBy" : "7a59a326-58b3-4590-b70a-297d2e27daa5",
        "tags" : [
        ]
      },
      {
        "id" : "8fd2565c-0581-4035-801b-49df446dd2db",
        "parentId" : "5ab24f38-a21f-4197-afee-bb1a8015e66a",
        "authorId" : "d168965e-f2a1-46dc-9041-18f8ba845ebe",
        "body" : "> Do we allow an operator to use a network plugin that does not implement this spec at all\n\nYes.  Not all solutions implement it yet, and some may never do so.  This shouldn't be a requirement for operating a cluster.\n\n> If we allow less than full implementation of this spec, what happens to input that can not be fully implemented? Is it rejected at validation? \n\nI don't think we intend to have any way to know whether a given implementation meets the spec or not, at least not for now.\n\nI think at this point I'd favor allowing implementations to do as much or as little of the spec as they see fit.  It's up to the implementation to make sure that by turning on policy they're not breaking anything.  As it is the API is written such that it should be easy to support none, some, or all of it in a meaningful way.\n",
        "createdAt" : "2016-04-18T15:38:55Z",
        "updatedAt" : "2016-05-18T17:14:38Z",
        "lastEditedBy" : "d168965e-f2a1-46dc-9041-18f8ba845ebe",
        "tags" : [
        ]
      },
      {
        "id" : "c0312ba5-532a-4c1e-9aad-61acd9ad4b09",
        "parentId" : "5ab24f38-a21f-4197-afee-bb1a8015e66a",
        "authorId" : "7a59a326-58b3-4590-b70a-297d2e27daa5",
        "body" : "I'm OK with that.  I would also be OK with allowing some feedback about this in the status block of relevent NetworkPolicy objects.\n",
        "createdAt" : "2016-04-20T15:01:32Z",
        "updatedAt" : "2016-05-18T17:14:38Z",
        "lastEditedBy" : "7a59a326-58b3-4590-b70a-297d2e27daa5",
        "tags" : [
        ]
      },
      {
        "id" : "b1a74a0c-7830-4d0f-9414-f16157e08f93",
        "parentId" : "5ab24f38-a21f-4197-afee-bb1a8015e66a",
        "authorId" : "d168965e-f2a1-46dc-9041-18f8ba845ebe",
        "body" : "Yeah, it might make sense to have some sort of status field which can indicate this.  I _really_ think that doesn't belong in this first proposal because we don't have a clear set of requirements that aren't implementation specific.\n\nFor now, implementations should report arbitrary status information using annotations - I think that will allow us to try things out and see which fields are commonly useful and which aren't.\n",
        "createdAt" : "2016-04-20T15:45:45Z",
        "updatedAt" : "2016-05-18T17:14:38Z",
        "lastEditedBy" : "d168965e-f2a1-46dc-9041-18f8ba845ebe",
        "tags" : [
        ]
      },
      {
        "id" : "85f1748d-614f-493d-981b-96e7849bf9fd",
        "parentId" : "5ab24f38-a21f-4197-afee-bb1a8015e66a",
        "authorId" : "7a59a326-58b3-4590-b70a-297d2e27daa5",
        "body" : "I agree, we are not really converging in the status field discussion, I have been trying to suggest leaving it up to implementations for now.  Doing that via annotations is OK with me.\n",
        "createdAt" : "2016-04-20T17:19:29Z",
        "updatedAt" : "2016-05-18T17:14:38Z",
        "lastEditedBy" : "7a59a326-58b3-4590-b70a-297d2e27daa5",
        "tags" : [
        ]
      }
    ],
    "commit" : "872d2b71c63431878e382e6e34c581c047f04791",
    "line" : null,
    "diffHunk" : "@@ -1,1 +126,130 @@objects (of which there can be multiple in a single namespace).  Pods selected by\none or more NetworkPolicy objects should allow any incoming connections that match any\ningress rule on those NetworkPolicy objects, per the network plugin’s capabilities.\n\nNetworkPolicy objects and the above namespace isolation both act on _connections_ rather than individual packets.  That is to say that if traffic from pod A to pod B is allowed by the configured"
  },
  {
    "id" : "041169f2-a374-4129-8dcb-b023266dc71f",
    "prId" : 24154,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "df0fe8e0-704a-4934-8730-b43d1367e5e6",
        "parentId" : null,
        "authorId" : "57f729dd-988a-4d1a-83bf-ee70bf637c64",
        "body" : "We need a closing } here, right?\n",
        "createdAt" : "2016-04-21T21:54:07Z",
        "updatedAt" : "2016-05-18T17:14:38Z",
        "lastEditedBy" : "57f729dd-988a-4d1a-83bf-ee70bf637c64",
        "tags" : [
        ]
      },
      {
        "id" : "041be8d9-705b-44cd-8526-7ba4dec1563d",
        "parentId" : "df0fe8e0-704a-4934-8730-b43d1367e5e6",
        "authorId" : "d168965e-f2a1-46dc-9041-18f8ba845ebe",
        "body" : "D'oh, I suppose we do :|\n",
        "createdAt" : "2016-04-21T22:01:06Z",
        "updatedAt" : "2016-05-18T17:14:38Z",
        "lastEditedBy" : "d168965e-f2a1-46dc-9041-18f8ba845ebe",
        "tags" : [
        ]
      }
    ],
    "commit" : "872d2b71c63431878e382e6e34c581c047f04791",
    "line" : null,
    "diffHunk" : "@@ -1,1 +165,169 @@\tIngress []NetworkPolicyIngressRule `json:\"ingress,omitempty\"`\n}\n\n// This NetworkPolicyIngressRule matches traffic if and only if the traffic matches both ports AND from. \ntype NetworkPolicyIngressRule struct {"
  },
  {
    "id" : "0fc327b6-c201-4e86-baf4-295769b38feb",
    "prId" : 24154,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "864e81af-596d-485f-ae15-39c3c030f4fd",
        "parentId" : null,
        "authorId" : "7a59a326-58b3-4590-b70a-297d2e27daa5",
        "body" : "For completeness, this document should exhibit the definition of the `matches` method.\n",
        "createdAt" : "2016-05-02T19:24:07Z",
        "updatedAt" : "2016-05-18T17:14:38Z",
        "lastEditedBy" : "7a59a326-58b3-4590-b70a-297d2e27daa5",
        "tags" : [
        ]
      },
      {
        "id" : "c3eb6e4f-2736-4317-8052-5b058b5787c6",
        "parentId" : "864e81af-596d-485f-ae15-39c3c030f4fd",
        "authorId" : "d168965e-f2a1-46dc-9041-18f8ba845ebe",
        "body" : "I don't think it should.  The Golang representation is meant to be the source of truth for how this API works.  This code is meant as an example to show how the API behaves at a high-level.\n\nIf a reader is interested in how matching for ingress rules work, then she should look to the Go structs and comments above.\n",
        "createdAt" : "2016-05-02T20:06:43Z",
        "updatedAt" : "2016-05-18T17:14:38Z",
        "lastEditedBy" : "d168965e-f2a1-46dc-9041-18f8ba845ebe",
        "tags" : [
        ]
      },
      {
        "id" : "8f012db5-3cd1-4e3a-a7a3-a6e368c6e993",
        "parentId" : "864e81af-596d-485f-ae15-39c3c030f4fd",
        "authorId" : "7a59a326-58b3-4590-b70a-297d2e27daa5",
        "body" : "I agree that those comments are precise enough now that we can rely solely on them.\n",
        "createdAt" : "2016-05-02T20:44:14Z",
        "updatedAt" : "2016-05-18T17:14:38Z",
        "lastEditedBy" : "7a59a326-58b3-4590-b70a-297d2e27daa5",
        "tags" : [
        ]
      }
    ],
    "commit" : "872d2b71c63431878e382e6e34c581c047f04791",
    "line" : null,
    "diffHunk" : "@@ -1,1 +243,247 @@      # If at least one does, then the traffic is allowed.\n      for ingress_rule in network_policy.Ingress or []:\n        if ingress_rule.matches(traffic): \n          return True \n"
  },
  {
    "id" : "c893c465-0076-4bf0-9b18-f3aa02684fba",
    "prId" : 24154,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f8364214-5548-47fd-8416-367a1a3dfc8c",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "For broader reviewers:\n\nAn alternative here could be a per-namespace \"deny all\" policy object that is then overridden by whitelist policies.  This means we would have to introduce \"deny\" rules, which means we also have to introduce precedence between policies (to define the stacking).\n\nAnother alternative could be that the default \"allow all\" policy applies to any pod UNTIL it is selected by a policy object, at which point it is switched to \"deny all\".  The previous option could then be implemented with a policy of \"select all, allow none\", which preserves additive semantics.\n\nWe chose this path in part because we thought that the control MIGHT be something administrative that users don't get to choose.  For example \"in my PCI cluster, all namespaces are DefaultDeny.  Period.\"\n\nI think this is a topic that could be revisited if needed.\n",
        "createdAt" : "2016-05-04T18:35:18Z",
        "updatedAt" : "2016-05-18T17:14:38Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "12d4ac5d-2535-428d-a973-8863be2f17b9",
        "parentId" : "f8364214-5548-47fd-8416-367a1a3dfc8c",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "We've begun discussing implementing group policy on namespaces via label selection (for things like bulk quota and bulk limit ranges).  Has that been discussed (how to define network policy for a large swath of the cluster)?  Or started as a concrete reference on the namespace because it's easy to reason about and doesn't require a more complex story?\n",
        "createdAt" : "2016-05-05T18:13:09Z",
        "updatedAt" : "2016-05-18T17:14:38Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "c2cefd6f-4d7a-4298-a4a4-063894e775f7",
        "parentId" : "f8364214-5548-47fd-8416-367a1a3dfc8c",
        "authorId" : "57f729dd-988a-4d1a-83bf-ee70bf637c64",
        "body" : "> Or started as a concrete reference on the namespace because it's easy to reason about and doesn't require a more complex story?\n\n@smarterclayton This.  Mostly to keep it simple so we can get something done, and then build off that later.\n",
        "createdAt" : "2016-05-05T20:22:31Z",
        "updatedAt" : "2016-05-18T17:14:38Z",
        "lastEditedBy" : "57f729dd-988a-4d1a-83bf-ee70bf637c64",
        "tags" : [
        ]
      },
      {
        "id" : "c423ce18-2ce7-450d-b882-acd9f7751b9b",
        "parentId" : "f8364214-5548-47fd-8416-367a1a3dfc8c",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "I have chewed on the idea of label-selecting namespaces for tenant IDs (applied by admission, not by users, obv.) and using that to apply a higher-level of network policy that bounds the user-defined.  It's not clear if that means a new global object Kind or an administrative namespace that uses the existing NetworkPolicy Kind (and the implications of that on this proposal).\n\nTL;DR I think it's doable, but we wanted, NEEDED to KISS here.\n",
        "createdAt" : "2016-05-06T05:51:10Z",
        "updatedAt" : "2016-05-18T17:14:38Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "38947d6b-0329-4962-b4bb-fe9a7c7959c9",
        "parentId" : "f8364214-5548-47fd-8416-367a1a3dfc8c",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "I'm fine with KISS - we're starting to see substantial use of namespaces\nand this is the inevitable fallout, nothing here precludes a different\nsolution.\n\nOn Fri, May 6, 2016 at 1:51 AM, Tim Hockin notifications@github.com wrote:\n\n> In docs/proposals/network-policy.md\n> https://github.com/kubernetes/kubernetes/pull/24154#discussion_r62290997\n> :\n> \n> > +The following objects will be defined on a Namespace Spec.\n> > +>NOTE: In v1beta1 these objects will be implemented as an annotation.\n> > +\n> > +```go\n> > +type IngressIsolationPolicy string\n> > +\n> > +const (\n> > -   // Deny all ingress traffic to pods in this namespace.\n> > -   DefaultDeny IngressIsolationPolicy = \"DefaultDeny\"\n> >   +)\n> >   +\n> >   +// Standard NamespaceSpec object, modified to include a new\n> >   +// NamespaceNetworkPolicy field.\n> >   +type NamespaceSpec struct {\n> > -   // This is a pointer so that it can be left undefined.\n> > -   NetworkPolicy *NamespaceNetworkPolicy `json:\"networkPolicy,omitempty\"`\n> \n> I have chewed on the idea of label-selecting namespaces for tenant IDs\n> (applied by admission, not by users, obv.) and using that to apply a\n> higher-level of network policy that bounds the user-defined. It's not clear\n> if that means a new global object Kind or an administrative namespace that\n> uses the existing NetworkPolicy Kind (and the implications of that on this\n> proposal).\n> \n> TL;DR I think it's doable, but we wanted, NEEDED to KISS here.\n> \n> —\n> You are receiving this because you were mentioned.\n> Reply to this email directly or view it on GitHub\n> https://github.com/kubernetes/kubernetes/pull/24154/files/bc3e88127e5c75e29781f70d5a1b8697cbc0702b#r62290997\n",
        "createdAt" : "2016-05-06T17:35:37Z",
        "updatedAt" : "2016-05-18T17:14:38Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "4ecd73e7-9193-4ddf-9e89-6fb508645f17",
        "parentId" : "f8364214-5548-47fd-8416-367a1a3dfc8c",
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "I agree with starting simple, but there is a question of whether we want to set a precedent for attaching policy to Namespace. ResourceQuota, LimitRange, and PodSecurityPolicy are separate resources. MetadataPolicy will be a separate resource. PodDisruptionBudget will be a separate resource.\n\nIn some cases, these are separate resources so that we don't need a monolithic resource with a list/map of policies. Originally there may have also been a desire to make some of the APIs optional. I don't think that's realistic at this point, but we do need to ensure that people kicking the tires don't have to know about these policies.\n\nAlso, though it started as the foundation for Openshift Projects, Namespace is useful as a name and label-selector scoping mechanism: a user downloads a package (e.g., using Helm) and wants to run it without modification, without conflicting with other applications they are running. The more policy we attach to namespaces, the less viable they are for that. It's like Github repos -- do we want to encourage small, focused repos or large monolithic ones? If we go with monolithic, we'll need another scoping mechanism, or we'll need to make namespaces hierarchical, or we'll need to redo these APIs in a multi-namespace-compatible manner in the future.\n",
        "createdAt" : "2016-05-11T23:09:23Z",
        "updatedAt" : "2016-05-18T17:14:38Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "285562f7-73f9-4fb5-ba32-6f9e019204e0",
        "parentId" : "f8364214-5548-47fd-8416-367a1a3dfc8c",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "I agree with all of that.  Namespaces not being hierarchical is a massive PITA now.  That said, this is policy that is largely describing the intended connectivity graph, so it really does feel like a per-namespace thing.\n",
        "createdAt" : "2016-05-12T22:26:32Z",
        "updatedAt" : "2016-05-18T17:14:38Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "872d2b71c63431878e382e6e34c581c047f04791",
    "line" : 73,
    "diffHunk" : "@@ -1,1 +71,75 @@type NamespaceSpec struct {\n\t// This is a pointer so that it can be left undefined.\n\tNetworkPolicy *NamespaceNetworkPolicy `json:\"networkPolicy,omitempty\"`\n}\n"
  },
  {
    "id" : "cebe0bd3-2dc5-40c5-be05-c389c4378fff",
    "prId" : 24154,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "45b134c3-fed0-43d6-8443-65828f793bca",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "For broader reviewers:\n\nNB the semantics here.  If you create a Namespace without an ingress policy, you (currently) get whatever the cluster defines as default.  HOWEVER this does not define the default (leaving room for global policies) and it does not snapshot the default at time of creation.  It implies that the cluster defaults could change and those would affect Namespaces in real time.  This may be worth discussion.\n\nAn alternative would be to snapshot the policy into a default value.  It's still not an API-version-defined default value, but it would a) be more obvious what policy applies (good) and b) not be subject to changes later (good and bad).  To do this, we would have to add a constant for `DefaultAllow`.\n\nDiscuss.\n",
        "createdAt" : "2016-05-04T18:39:12Z",
        "updatedAt" : "2016-05-18T17:14:38Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "fc11f8e3-25cb-418c-be3a-7aca92281a1c",
        "parentId" : "45b134c3-fed0-43d6-8443-65828f793bca",
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "If the field is not explicit set by the defaulting pass, do not use the term \"default\". Elsewhere, I've suggested \"inferred\" for implicit defaults. If another policy applies instead in the case that it's unspecified, just explain that.\n",
        "createdAt" : "2016-05-11T23:14:30Z",
        "updatedAt" : "2016-05-18T17:14:38Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "7ad2914f-37fd-4317-a475-b0b648c7e816",
        "parentId" : "45b134c3-fed0-43d6-8443-65828f793bca",
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "In the case of implicit or transitive policies, though, there needs to be a way to query what policy is in effect.\n",
        "createdAt" : "2016-05-11T23:15:03Z",
        "updatedAt" : "2016-05-18T17:14:38Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "26c78ef8-a1c3-4efa-a80e-f7cffd548384",
        "parentId" : "45b134c3-fed0-43d6-8443-65828f793bca",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "Currently there is only one inferred policy option.  If/when global polices are implemented to augment this local policy, we will need a way to get the effective policy.\n\nThe question I see is really: when policy is undefined, do we\n\na) snapshot the inferred policy into the namespace spec;\nb) leave the namespace spec undefined and allow the impl to define the behavior;\nc) leave the namespace spec undefined and snapshot the inferred policy into the namespace status\n\nWe have currentlydefined B, but I am open to A or C.  We can also move to A or C as we get some miles on this during Beta, which is partly why B is attractive right now.\n",
        "createdAt" : "2016-05-12T22:33:37Z",
        "updatedAt" : "2016-05-18T17:14:38Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "58336edf-0a72-44c0-9cf7-a083f22088ce",
        "parentId" : "45b134c3-fed0-43d6-8443-65828f793bca",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "This is still an open question, but I am OK to enter beta in this state.\n",
        "createdAt" : "2016-05-18T15:16:41Z",
        "updatedAt" : "2016-05-18T17:14:38Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "872d2b71c63431878e382e6e34c581c047f04791",
    "line" : 81,
    "diffHunk" : "@@ -1,1 +79,83 @@\t// ingress is supported.  This field is optional - if not \n\t// defined, then the cluster default for ingress is applied.\n\tIngress *NamespaceIngressPolicy `json:\"ingress,omitempty\"`\n}\n"
  },
  {
    "id" : "df6baae9-a2ab-433a-ba1f-7c24de118f13",
    "prId" : 24154,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "219cb2ad-6d7a-45b5-a6e8-9c3186f94210",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "For broader reviewers:\n\nThe \"isolation\" moniker was debated and it was deemed least-bad of \"policy\", \"isolation\", \"filter\" etc.\n\nCould be revisited.\n",
        "createdAt" : "2016-05-04T18:43:31Z",
        "updatedAt" : "2016-05-18T17:14:38Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "cf59d52a-e578-4324-ac85-59a8e09cc952",
        "parentId" : "219cb2ad-6d7a-45b5-a6e8-9c3186f94210",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "I like Isolation - the objective is to isolate a set of items from impact from others - filter is a \"how\", \"policy\" is a generic noun, \"isolation\" is the \"what\" and \"why\"\n",
        "createdAt" : "2016-05-06T14:15:08Z",
        "updatedAt" : "2016-05-18T17:14:38Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      }
    ],
    "commit" : "872d2b71c63431878e382e6e34c581c047f04791",
    "line" : null,
    "diffHunk" : "@@ -1,1 +90,94 @@\t// pods in this namespace are denied ingress traffic by default.  When not defined,\n\t// the cluster default ingress isolation policy is applied (currently allow all). \n\tIsolation *IngressIsolationPolicy `json:\"isolation,omitempty\"` \n}\n```"
  },
  {
    "id" : "16eb1487-23e6-4331-b1df-0306d39ab5f0",
    "prId" : 24154,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5a5fcffd-f9d4-40d5-8db9-a0ace74a0ab6",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "For reviewers: \n\nThis amounts to a one-of.  We historically modelled this as a set of nil-able pointer fields with documentation and validation.  ISTR a discussion that moving to an explicit `type` filed + pointer fields made clients happier.\n\nIs that a new precedent we should follow here?\n",
        "createdAt" : "2016-05-05T20:51:49Z",
        "updatedAt" : "2016-05-18T17:14:38Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "e360c83c-260a-40b6-8bbf-213bb191b5c1",
        "parentId" : "5a5fcffd-f9d4-40d5-8db9-a0ace74a0ab6",
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "I'd like a discriminator field, such as `type`.\n\nHowever, regardless whether we do that, Swagger doesn't support oneOf/union. :-(\n",
        "createdAt" : "2016-05-12T00:32:08Z",
        "updatedAt" : "2016-05-18T17:14:38Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "e6e434dc-d81a-4389-ad2a-b643fbb30711",
        "parentId" : "5a5fcffd-f9d4-40d5-8db9-a0ace74a0ab6",
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "Note that if these are mutable, getting `kubectl apply` to work will be tricky.\n",
        "createdAt" : "2016-05-12T00:33:29Z",
        "updatedAt" : "2016-05-18T17:14:38Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      }
    ],
    "commit" : "872d2b71c63431878e382e6e34c581c047f04791",
    "line" : null,
    "diffHunk" : "@@ -1,1 +198,202 @@}\n\ntype NetworkPolicyPeer struct {\n\t// Exactly one of the following must be specified.\n"
  },
  {
    "id" : "de132a5d-ca25-46bc-8b91-fe8f66e9a6a9",
    "prId" : 24154,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b552e541-daa9-4e24-85ce-44b69bf7a9a1",
        "parentId" : null,
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "Do we want to be able to differentiate policy based on the traffic source: from outside the cluster, from other namespaces, from selected pods, via a service?\n\nOr to different ports, more like regular firewall rules? If this is discussed somewhere else, feel free to point me at the issue/PR/email thread/whatever.\n",
        "createdAt" : "2016-05-11T23:18:18Z",
        "updatedAt" : "2016-05-18T17:14:38Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "ca2812c3-efd3-429f-bc02-3d336537fbbc",
        "parentId" : "b552e541-daa9-4e24-85ce-44b69bf7a9a1",
        "authorId" : "7a59a326-58b3-4590-b70a-297d2e27daa5",
        "body" : "Here we are still working up to using the value declared on line 64 (`DefaultDeny IngressIsolationPolicy = \"DefaultDeny\"`).  That is, we are approaching the point where the user says whether she wants to exert any control at all over incoming connections.  Our idea is that if the user takes control, then the NetworkPolicy objects are able to identify the source in various ways (shown later) and discriminate on the passive port (also shown later).\n\nThe \"via a Service\" part is a bit of a thorn in our side.  I am seeing different answers to whether services are transparent here or not.\n",
        "createdAt" : "2016-05-12T02:52:21Z",
        "updatedAt" : "2016-05-18T17:14:38Z",
        "lastEditedBy" : "7a59a326-58b3-4590-b70a-297d2e27daa5",
        "tags" : [
        ]
      },
      {
        "id" : "4023e856-dabc-42b7-b3dd-fc799169c3c8",
        "parentId" : "b552e541-daa9-4e24-85ce-44b69bf7a9a1",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "The goal with the namespace change was to have the most minimal footprint possible on Namespace.  This is effectively a boolean-with-room-to-grow\n",
        "createdAt" : "2016-05-12T22:35:31Z",
        "updatedAt" : "2016-05-18T17:14:38Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "872d2b71c63431878e382e6e34c581c047f04791",
    "line" : 87,
    "diffHunk" : "@@ -1,1 +85,89 @@// For now, this only supports specifying an isolation policy.\ntype NamespaceIngressPolicy struct {\n\t// The isolation policy to apply to pods in this namespace.\n\t// Currently this field only supports \"DefaultDeny\", but could \n\t// be extended to support other policies in the future.  When set to DefaultDeny,"
  },
  {
    "id" : "975be5b6-775e-439a-978c-19cc2acdab74",
    "prId" : 24154,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0c030f16-ffe9-4247-a326-71abfff62488",
        "parentId" : null,
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "Why is \"Default\" in the policy name rather than in the field name?\n",
        "createdAt" : "2016-05-11T23:19:21Z",
        "updatedAt" : "2016-05-18T17:14:38Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "bdf83cd3-95b5-4b0a-a6f2-c2ef7933a0ad",
        "parentId" : "0c030f16-ffe9-4247-a326-71abfff62488",
        "authorId" : "7a59a326-58b3-4590-b70a-297d2e27daa5",
        "body" : "It is not our intent here to declare a default policy.  Rather it is to identify the way filtering is controlled in the namespace.  There are two choices: (1) every connection to a pod in the namespace is allowed, and (2) the only allowed incoming connections are those explicitly permitted by NetworkPolicy objects, permitted by the cluster's default policy, or needed for health checking.  \"DefaultDeny\" is an attempt at a short string meaning (2).  It leaves a lot to be desired.  We are quite open to suggestions for how to better convey this.\n",
        "createdAt" : "2016-05-12T02:40:14Z",
        "updatedAt" : "2016-05-18T17:14:38Z",
        "lastEditedBy" : "7a59a326-58b3-4590-b70a-297d2e27daa5",
        "tags" : [
        ]
      },
      {
        "id" : "f5f2a000-f5d3-4399-ae9d-5679dafd18a4",
        "parentId" : "0c030f16-ffe9-4247-a326-71abfff62488",
        "authorId" : "d168965e-f2a1-46dc-9041-18f8ba845ebe",
        "body" : "Not so sure.. the things we want to express are:\n\n1) Not specified - leave it up to whatever the cluster default behavior is.\n2) Specified - this namespace has a different default from the cluster default.\n\n@MikeSpreitzer - It seems to me that we're specifying a namespace default, which could be better represented as `DefaultIsolation: Deny` rather than `Isolation: DefaultDeny`, or am I missing something?\n",
        "createdAt" : "2016-05-12T19:45:35Z",
        "updatedAt" : "2016-05-18T17:14:38Z",
        "lastEditedBy" : "d168965e-f2a1-46dc-9041-18f8ba845ebe",
        "tags" : [
        ]
      },
      {
        "id" : "b723d388-2148-4387-a5b0-58fc6c0e309c",
        "parentId" : "0c030f16-ffe9-4247-a326-71abfff62488",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "Part of this is leaving room for things we don't know yet.  Making the field `DefaultPolicy` and the value `Deny` implies that `Allow` is a valid policy, but it's not - the absence of policy means \"whatever the cluster defaults to\", which is currently only \"allow\", but could extend later.  I don't know that if a cluster policy was to default-deny, we would want users to be able to go looser than that.\n\nThis started as a boolean 'enable isolation' but I wanted to leave room for more options.  Maybe too undefined..\n",
        "createdAt" : "2016-05-12T22:19:55Z",
        "updatedAt" : "2016-05-18T17:14:38Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "e5f2af6b-ef15-4144-9de7-13e272d0d3cc",
        "parentId" : "0c030f16-ffe9-4247-a326-71abfff62488",
        "authorId" : "7a59a326-58b3-4590-b70a-297d2e27daa5",
        "body" : "It seems to me that if this were about a default then it would be processed at the end of the pseudo-code.  But it is not.\n\nBTW, I see I was temporarily confused about the role cluster default plays.  Here is the corrected version of my earlier comment.  The bit we are introducing on the namespace distinguishes between two choices: (1) the cluster's default ingress isolation policy determines which connections are allowed to the pods in the namespace or (2) the only allowed incoming connections to pods in the namespace are those explicitly permitted by NetworkPolicy objects or needed for health checking.  The term \"DefaultDeny\" is our attempt to identify (2).  Again, (2) is not a default policy --- rather it is an algorithm with a constant default at the end.  If the namespace bit were setting a default then it could be processed at the end of the pseudo-code, and you see that it is not (and moving it there would change the semantics).\n",
        "createdAt" : "2016-05-13T04:46:06Z",
        "updatedAt" : "2016-05-18T17:14:38Z",
        "lastEditedBy" : "7a59a326-58b3-4590-b70a-297d2e27daa5",
        "tags" : [
        ]
      },
      {
        "id" : "f0f8fc6b-7708-4126-b762-97221d22070d",
        "parentId" : "0c030f16-ffe9-4247-a326-71abfff62488",
        "authorId" : "d168965e-f2a1-46dc-9041-18f8ba845ebe",
        "body" : "@MikeSpreitzer I wouldn't rely on the order of events in the pseudo code to make judgements on the API semantics.  That said, I see what you mean re: a default behavior vs this namespace's \"algorithm\".  However, couldn't it just be interpreted as executing these steps in order?\n1. Check if any policies act on the traffic.\n2. Check if the namespace \"default algorithm\" acts.\n3. Check the cluster \"default algorithm\" acts.\n\nThen, `DefaultIsolation: Deny` just becomes a _really_ simply algorithm that denies everything, but is still the default behavior for the namespace.\n\n@thockin \n\n> Making the field DefaultPolicy and the value Deny implies that Allow is a valid policy, but it's not.\n\nSure, but doesn't `DefaultDeny` imply that `DefaultAllow` should be a valid option? I don't see the difference.  I understand that what we have written now is slightly more flexible in terms of what you can express and I'm fine with that.  I also like that `DefaultIsolation: Deny` seems a bit easier to reason about.\n",
        "createdAt" : "2016-05-13T15:49:43Z",
        "updatedAt" : "2016-05-18T17:14:38Z",
        "lastEditedBy" : "d168965e-f2a1-46dc-9041-18f8ba845ebe",
        "tags" : [
        ]
      },
      {
        "id" : "b12b8d7b-d775-493f-8ed2-e1e0c4eaf72d",
        "parentId" : "0c030f16-ffe9-4247-a326-71abfff62488",
        "authorId" : "7a59a326-58b3-4590-b70a-297d2e27daa5",
        "body" : "@caseydavenport the three-step algorithm you gave is different from what the pseudo-code here (when amended as I think we have agreed on line 221) does now, and produces different behavior.  Following is an example that shows the difference.  Suppose the cluster's default policy disallows traffic between namespaces.  Consider a namespace with no annotation.  Suppose there is a NetworkPolicy object allowing all traffic into that namespace's pods regardless of source.  The current pseudo-code disallows connections into the namespace's pods from other namespaces, and the three-step algorithm you cited allows those connections.\n",
        "createdAt" : "2016-05-13T18:23:45Z",
        "updatedAt" : "2016-05-18T17:14:38Z",
        "lastEditedBy" : "7a59a326-58b3-4590-b70a-297d2e27daa5",
        "tags" : [
        ]
      },
      {
        "id" : "88b4f2ec-8e67-4865-a452-05ad8dc06a89",
        "parentId" : "0c030f16-ffe9-4247-a326-71abfff62488",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "We have a week left to get this approved AND get the implementation in-queue.  I think the current design suffices for beta, and if there are still issues we can resolve in a beta2 or GA.  @bgrant0607 OK with that?\n",
        "createdAt" : "2016-05-14T03:30:40Z",
        "updatedAt" : "2016-05-18T17:14:38Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "872d2b71c63431878e382e6e34c581c047f04791",
    "line" : null,
    "diffHunk" : "@@ -1,1 +64,68 @@\t// any incoming traffic to pods, whether that be from other pods within this namespace\n\t// or any source outside of this namespace.\n\tDefaultDeny IngressIsolationPolicy = \"DefaultDeny\"\n) \n"
  },
  {
    "id" : "be154b48-b1c2-4290-aa6b-6c22b0edf038",
    "prId" : 24154,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "72ce5069-a15d-41e5-8387-b665980a5dd2",
        "parentId" : null,
        "authorId" : "8df86b94-1422-4b8e-9056-b18bfdecd2dd",
        "body" : "~~Duplicate?~~ Fixed\n",
        "createdAt" : "2016-05-18T01:31:15Z",
        "updatedAt" : "2016-05-18T17:14:38Z",
        "lastEditedBy" : "8df86b94-1422-4b8e-9056-b18bfdecd2dd",
        "tags" : [
        ]
      }
    ],
    "commit" : "872d2b71c63431878e382e6e34c581c047f04791",
    "line" : 299,
    "diffHunk" : "@@ -1,1 +297,301 @@kind: NetworkPolicy\napiVersion: extensions/v1beta1 \nmetadata:\n  name: allow-tcp-443\nspec:"
  },
  {
    "id" : "04939df6-b8f2-4c11-9ceb-50a70f5d1789",
    "prId" : 24154,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5c33f442-ccff-49f8-bbd9-f8535b3de9fd",
        "parentId" : null,
        "authorId" : "7a59a326-58b3-4590-b70a-297d2e27daa5",
        "body" : "The reader has not seen a definition of \"cluster policy\", and I thought we were calling it \"cluster default policy\".\nThe idea of a cluster [default] policy should be defined somewhere.  I think it should be introduced, even if not carefully defined, in the abstract.  I am still a little unclear on how this file becomes what users see, so am not sure exactly what to recommend about where this concept is carefully defined.  At least, it must be properly referenced from the pseudo-code.\nI think it really is a _default_ policy, because it does not apply if the user chooses to exert policy control.\n",
        "createdAt" : "2016-05-18T15:52:39Z",
        "updatedAt" : "2016-05-18T17:14:38Z",
        "lastEditedBy" : "7a59a326-58b3-4590-b70a-297d2e27daa5",
        "tags" : [
        ]
      },
      {
        "id" : "ac137895-b93b-4612-bdf6-e556268fd2b4",
        "parentId" : "5c33f442-ccff-49f8-bbd9-f8535b3de9fd",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "While I agree, this is a proposal, and is OK to be a little bit loose (especially up against a wall).  I want to get this in today and the impl soon after.  We can wordsmith after that\n",
        "createdAt" : "2016-05-18T17:20:20Z",
        "updatedAt" : "2016-05-18T17:20:20Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "872d2b71c63431878e382e6e34c581c047f04791",
    "line" : 158,
    "diffHunk" : "@@ -1,1 +156,160 @@\t\n\t// List of ingress rules to be applied to the selected pods.\n\t// Traffic is allowed to a pod if namespace.networkPolicy.ingress.isolation is undefined and cluster policy allows it, \n\t// OR if the traffic source is the pod's local node, \n\t// OR if the traffic matches at least one ingress rule across all of the NetworkPolicy "
  },
  {
    "id" : "43049248-0747-4e3a-bf6d-0a26bdcf6de7",
    "prId" : 24154,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8d79d59f-0bb2-489a-93f4-68279071eec2",
        "parentId" : null,
        "authorId" : "7a59a326-58b3-4590-b70a-297d2e27daa5",
        "body" : "or lifecycle probes, I presume\n",
        "createdAt" : "2016-05-18T16:00:38Z",
        "updatedAt" : "2016-05-18T17:14:38Z",
        "lastEditedBy" : "7a59a326-58b3-4590-b70a-297d2e27daa5",
        "tags" : [
        ]
      }
    ],
    "commit" : "872d2b71c63431878e382e6e34c581c047f04791",
    "line" : null,
    "diffHunk" : "@@ -1,1 +229,233 @@    return clusterDefault(traffic, pod)\n  elif traffic.source == pod.node.kubelet:\n    # Traffic is from kubelet health checks.\n    return True\n  else:"
  }
]
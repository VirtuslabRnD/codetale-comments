[
  {
    "id" : "485a4909-785e-4535-a81b-e490371d8e40",
    "prId" : 1775,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/1775#pullrequestreview-12011359",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1d193655-6f31-4e4c-a647-b21fadf1bdbb",
        "parentId" : null,
        "authorId" : "5d637332-899b-40ac-b935-84e0c4c368a3",
        "body" : "I can only see a very weak relationship between comonads and implicit functions. At best, implicit functions can replace coreader comonad stacks. Other than that, comonads are completely irrelevant.",
        "createdAt" : "2016-12-05T21:18:39Z",
        "updatedAt" : "2016-12-17T20:50:40Z",
        "lastEditedBy" : "5d637332-899b-40ac-b935-84e0c4c368a3",
        "tags" : [
        ]
      },
      {
        "id" : "47edb2eb-95d3-4ce6-a3ec-7f8d0e07dbef",
        "parentId" : "1d193655-6f31-4e4c-a647-b21fadf1bdbb",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "I meant to refer to the original paper \"Implicit parameters: dynamic scoping with static types\" (POPL2000) which speculated that the best fitting foundation of implicit parameters are comonads. But thinking about it I run into troubles to nail it down. ",
        "createdAt" : "2016-12-06T00:42:39Z",
        "updatedAt" : "2016-12-17T20:50:40Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "0e3b7730-b755-46c8-9a74-b47b907ba93f",
        "parentId" : "1d193655-6f31-4e4c-a647-b21fadf1bdbb",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "I think I have worked it out now: implicit functions are both monads and comonads, with\r\n\r\n    M[A]        =  implicit X => A\r\n    unit a      =  implicit (_: X) => a\r\n    counit m    =  m (implicitly[X])\r\n    map m f     =  implicit (_: X) => f (m (implicitly[X]))\r\n                =  unit (f (counit m))\r\n\r\n    join m      =  counit m \r\n    duplicate m =  unit m\r\n\r\n  WDYT?",
        "createdAt" : "2016-12-06T13:50:45Z",
        "updatedAt" : "2016-12-17T20:50:40Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "ffa35570-0274-422b-a056-04c08bc1bec8",
        "parentId" : "1d193655-6f31-4e4c-a647-b21fadf1bdbb",
        "authorId" : "5d637332-899b-40ac-b935-84e0c4c368a3",
        "body" : "You aren't just using the implicit function there, you're also using the `implicitly[X]` value in counit. The comonad you present is the Store comonad `(a, a -> b)`, and the monad is the reader monad. I believe *coeffects*, which are a calculus of dependencies (http://tomasp.net/academic/papers/structural/), might provide a better theoretical underpinning. ",
        "createdAt" : "2016-12-06T20:03:04Z",
        "updatedAt" : "2016-12-17T20:50:40Z",
        "lastEditedBy" : "5d637332-899b-40ac-b935-84e0c4c368a3",
        "tags" : [
        ]
      },
      {
        "id" : "c1e79f6e-543e-4b1a-a334-3352c9022814",
        "parentId" : "1d193655-6f31-4e4c-a647-b21fadf1bdbb",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "The monad is indeed close to the reader monad, but I fail to see that it's the Store comonad. Where is the tupling?",
        "createdAt" : "2016-12-06T20:52:22Z",
        "updatedAt" : "2016-12-17T20:50:40Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "eb38e672-324e-43da-8ce3-290388835115",
        "parentId" : "1d193655-6f31-4e4c-a647-b21fadf1bdbb",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Regarding co-efffects I think that's more involved and there is something else going on. Note that implicit functions themselves can model capabilities, but for effects we need a notion of capture prevention as well.\r\n",
        "createdAt" : "2016-12-06T21:04:08Z",
        "updatedAt" : "2016-12-17T20:50:40Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "2e8bdcb0-6197-4515-902a-913af00f89eb",
        "parentId" : "1d193655-6f31-4e4c-a647-b21fadf1bdbb",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "I don't know category theory all that well, so I am not sure. But it seems admissible to have a structure that is both a monad and a comonad with different operators for unit and counit. Googling yielded Moore machines as an example here: \r\n\r\nhttp://stackoverflow.com/questions/16551734/can-a-monad-be-a-comonad\r\n\r\nSo how would that not apply to implicit functions?\r\n",
        "createdAt" : "2016-12-06T21:13:02Z",
        "updatedAt" : "2016-12-17T20:50:40Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "6dcb8b75-e321-43e3-8189-0c67cfc7a57a",
        "parentId" : "1d193655-6f31-4e4c-a647-b21fadf1bdbb",
        "authorId" : "5d637332-899b-40ac-b935-84e0c4c368a3",
        "body" : "Monads and comonads exist for the purpose of *composition*. The *first* thing you need to have either of them is a unary type constructor `F[_]`. You chose a different type constructor for the monad and comonad. To illustrate this, I will fix `F[_]` to `ImplicitFunction1[I, ?]` (for fixed `I`).\r\nNow, the comonad instance:\r\n```scala\r\ndef extract[A](function: ImplicitFunction1[I, A]): A\r\n```\r\nWe're already stuck. We don't have an `I`. You get around this by assuming implicitly one exists in scope, so actually your type constructor is more like:\r\n```scala\r\ntype FunctionAndParam[I, A] = (implicit I, ImplicitFunction[I, A])\r\n```\r\nWhich explains where the `Store` is coming from. So `ImplicitFunction1[I, ?] is not a comonad. Now, let's see if it's a monad:\r\n```scala\r\ndef pure[A](a: A): ImplicitFunction[I, A] = implicit I => a\r\ndef flatMap[A](fa: ImplicitFunction[I, A])(\r\n               f: A => ImplicitFunction[I, B]): ImplicitFunction1[I, B]\r\n = (implicit i: I) => f(fa(i)).apply(i)\r\n```\r\nRemove the `implicit` parts, and this is just the Reader monad. Implicits do not really need much from the type system or foundations, because from another angle they are just the Reader monad with better syntax and no bind method provided (you can add your own, as you can see there, and that won't magically destroy performance). Then, this *is* monadic code and there can be no performance difference between Reader and implicits - assuming the same *usage*, that is. If both uses are closure-heavy there's nothing the compiler can do, and monadic code *does* tend to be heavily abstracted out as well just because of the demographics involved.\r\n\r\nEssentially, my objection to that bimonad is that it's just a comonad and monad which already exist with \"implicit\" pasted at the start, so the monad will not actually teach us anything about the underlying dependency calculus that implicit params capture. All it teaches us is that implicit functions with the same param type compose, like ordinary functions.\r\n\r\nCoeffects also *include a model of implicit parameters*, as you can see on the website, which *may* be useful as theoretical underpinnings, but I agree that otherwise the concept is very large (and I'm very excited to see capture-free closures or affine types if you're hinting that we're going that direction :D).",
        "createdAt" : "2016-12-07T00:30:04Z",
        "updatedAt" : "2016-12-17T20:50:40Z",
        "lastEditedBy" : "5d637332-899b-40ac-b935-84e0c4c368a3",
        "tags" : [
        ]
      },
      {
        "id" : "6b800df9-9cac-4f7f-a6d4-0555dd4f8bb7",
        "parentId" : "1d193655-6f31-4e4c-a647-b21fadf1bdbb",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "I think we are talking in different contexts (forgive the pun). I am arguing that, for given X, the type `implicit X => A` is a bimonad with unit being lambda abstraction and counit being implicit application. You were showing that I cannot turn this into an instance of the `Monad` and `Comonad` class at the same time, because I have to represent an instance of `X` somehow in the type. But that's exactly the point: `X` is assumed to be in scope (and the types guarantee that one will be in scope), so I do not want nor need to represent it in the type.\r\n\r\nPut in other words: If implicit functions were representable *as code* in the standard monad/comonad class hierarchy, there would be no point making them a *language construct*.\r\n\r\n",
        "createdAt" : "2016-12-07T07:57:27Z",
        "updatedAt" : "2016-12-17T20:50:40Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "85505a47-d126-4fd1-ab81-315d28646ac1",
        "parentId" : "1d193655-6f31-4e4c-a647-b21fadf1bdbb",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "There's something else at play here, and I am trying to wrap my head around it. If we drop the implicitness and just talk about function abstraction and application we also get a bimonad in some sense:\r\n\r\n    M[A]        =  X => A\r\n    unit a      =  (x: X) => a\r\n    counit m    =  m x\r\n    map m f     =  (x: X) => f (m x)\r\n                =  unit (f (counit m))\r\n\r\n    join m      =  counit m \r\n    duplicate m =  unit m\r\n\r\nBut this feels a little bit weirder because now we are dealing with open terms, with `counit` operations introducing free variables that are captured by `unit` operations. And the names of both free variables and lambda binders are fixed to be always the same name `x`.  \r\n\r\nBy contrast, all terms in the implicit function bimonad representation are closed. I am not sure what difference it makes, though.\r\n",
        "createdAt" : "2016-12-07T08:05:52Z",
        "updatedAt" : "2016-12-17T20:50:40Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "ed3e9489-c302-4741-b546-0a63b639f06a",
        "parentId" : "1d193655-6f31-4e4c-a647-b21fadf1bdbb",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Regarding composition, I believe one can explain the composability of implicit functions from the principle that they are a bimonad. Let's say you have two function types `F` and `G`, which take implicit parameters of types `X` and `Y`, but in different orders:\r\n\r\n    type F =  implicit X => implicit Y => A\r\n    type G =  implicit Y => implicit X => A\r\n\r\nI can turn a value `f: F` into a value of type `G` like this:\r\n\r\n    implicit Y => implicit X => f(implicitly[X])(implicitly[Y])\r\n\r\nMoreover that conversion is completely automatic. I just have to write\r\n\r\n    val x: G  = f\r\n\r\nand the rest is produced automatically. I believe that gets us to the essence why implicit functions are better composable than general monads. Even if we disregard the aspect of implicit code insertion, what happens here is that we strip all (co)monads in the applications to the two `implicitly` arguments and then reapply the (co)monads in the outer lambda abstractions. The fact that this is a bimonad is essential here, because it means we can always get out of an entangled structure with counit operations, reorder at the outermost level, and get back with unit operations.\r\n\r\n\r\n\r\n",
        "createdAt" : "2016-12-07T08:32:47Z",
        "updatedAt" : "2016-12-17T20:50:40Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "50230a01-cfa8-4230-b806-c0b2a7cc458f",
        "parentId" : "1d193655-6f31-4e4c-a647-b21fadf1bdbb",
        "authorId" : "5d637332-899b-40ac-b935-84e0c4c368a3",
        "body" : "I think that your insight that the regular function bimonad requires the ability to introduce terms into the environment shows that the implicit function comonad also requires that ability. But yes, I agree that being able to implicitly reorder implicit arguments decreases their syntactic overhead below reader.",
        "createdAt" : "2016-12-07T19:18:52Z",
        "updatedAt" : "2016-12-17T20:50:40Z",
        "lastEditedBy" : "5d637332-899b-40ac-b935-84e0c4c368a3",
        "tags" : [
        ]
      },
      {
        "id" : "c03a0881-53fb-40f3-aa72-e6b7e020474b",
        "parentId" : "1d193655-6f31-4e4c-a647-b21fadf1bdbb",
        "authorId" : "348fab8e-49e2-442e-884d-850c7f41fdde",
        "body" : "I agree with @edmundnoble: in particular what you get with implicits isn't closed terms, because they assume something in the context. I haven't read the paper, but maybe they had some other category in mind? (Warning: dense and unchecked ideas ahead). Beyond the category of functions you're using, you could probably have (equivalent I think) categories of expressions with x in scope and of expressions with some implicit in scope, and there your comonad might work. I haven't checked any of the details though. Whether that's insightful or useful, beyond making precise the two things are equivalent, is not clear.",
        "createdAt" : "2016-12-07T21:01:35Z",
        "updatedAt" : "2016-12-17T20:50:40Z",
        "lastEditedBy" : "348fab8e-49e2-442e-884d-850c7f41fdde",
        "tags" : [
        ]
      },
      {
        "id" : "2bdda26b-4f77-46b4-a36d-e049ae429746",
        "parentId" : "1d193655-6f31-4e4c-a647-b21fadf1bdbb",
        "authorId" : "eab49b9a-ce3c-4964-a5f2-3cbb85f68dee",
        "body" : "I see a mention of my work on coeffects in the thread already, so I thought I'll add my perspective. I'm not all that familiar with Scala, so I'll stick to my Haskell/ML-style notation, but I hope that will be understandable.\r\n\r\n**What are coeffects**\r\nFirst of all, coeffects are, indeed, closely related to comonads (they are modelled using \"indexed comonads\", which is a generalisation of ordinary comonads). What coeffects add, is that they track more precisely what context is needed. The comonadic (or monadic) type `C a` or `M a` tells you that there is _some_ context-requirement or _some_ effect, but it does not tell you _what_ precisely. Coeffects add an annotation so that you have types such as `C {?p:int, ?q:int} a` where the annotation `{?p:int, ?q:int}` says you need two implicit parameters `?p` and `?q`. So you can see coeffects as more precise comonads.\r\n\r\n**Are implicit parameters monads, comonads or coeffects**\r\nImplicit parameters are one of the motivating examples in the work on coeffects, but they are just one (coeffects capture other interesting contextual properties). The interesting thing about implicit parameters is that they can *almost* be modelled by both Reader monad and Product comonad. With monads, you use functions `a -> M b` for some monad and with comonads, you use functions `C a -> b` for some comonad.\r\n\r\nWith Reader monad, we have `M a = State -> a` and so:\r\n\r\n    a -> M b = a -> (State -> b)\r\n\r\nWith Product comonad, we have `C a = a * State` and so:\r\n\r\n    C a -> b = a * State -> b\r\n\r\nNow you can see that the two functions, `a * State -> b` and `a -> State -> b` are related (via currying)! 🎉 \r\n\r\nThere is one thing that reader monad does not let you do. It does not let you model the facts that implicit parameters (in GHC) support both lexical and dynamic scoping. Take for example this:\r\n\r\n    let ?x = 1\r\n    let f = (fun n ->?x + ?y)\r\n\r\nIf we model this using Reader monad and `?x` and `?y` mean \"read implicit parameter from the monad\", then the type of `f` will be a function that needs `?x` and `?y`. However, if we do this using comonads, the context available in the function body can combine context provided by the caller with the context provided by the declaration site - and so we can use `?x` from the declaration site and end up with a function that needs just `?y` (I'd be quite curious to see what Scala is doing here - are implicits just dynamically scoped or mix of both? \r\n\r\n**Links with more information**\r\nThere is a lot more about this than I can fit in a comment, so for those interested:\r\n\r\n * I wrote an [Interactive, reader-friendly online essay about coeffects](http://tomasp.net/coeffects/)\r\n * All the glorious details are in [my PhD thesis](https://github.com/coeffects/coeffects-thesis/blob/master/main.pdf) - relevant sections for the discussion above are 2.2, 3.2.1 and 5.6.\r\n * Someone already mentioned our [ICFP paper](http://tomasp.net/academic/papers/structural/), but the older [ICALP paper](http://tomasp.net/academic/papers/coeffects/) might be easier to read if you care only about implicit parameters.",
        "createdAt" : "2016-12-08T12:21:09Z",
        "updatedAt" : "2016-12-17T20:50:40Z",
        "lastEditedBy" : "eab49b9a-ce3c-4964-a5f2-3cbb85f68dee",
        "tags" : [
        ]
      }
    ],
    "commit" : "2e99511840915e2805e7a2c07571d3859a3db698",
    "line" : 26,
    "diffHunk" : "@@ -1,1 +24,28 @@ - wiring components up with dependency injection,\n - defining the meanings of operations with type classes,\n - more generally, passing any sort of context to a computation.\n\nImplicit function types are a surprisingly simple and general way to"
  },
  {
    "id" : "0e30bcb0-64ba-4ca5-bb14-0aa254da0e1d",
    "prId" : 1775,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/1775#pullrequestreview-12045366",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f95ff022-08da-428c-9fd7-1cc001d67740",
        "parentId" : null,
        "authorId" : "5d637332-899b-40ac-b935-84e0c4c368a3",
        "body" : "Just editorializing: in my opinion, the main downside of implicit parameters is that they make code harder to refactor by making the *place* where your code exists change the *semantics* of the code. The verbosity is definitely an issue on its own, though.",
        "createdAt" : "2016-12-05T21:22:11Z",
        "updatedAt" : "2016-12-17T20:50:40Z",
        "lastEditedBy" : "5d637332-899b-40ac-b935-84e0c4c368a3",
        "tags" : [
        ]
      },
      {
        "id" : "31c37633-7b4a-4269-82b9-970a0557e839",
        "parentId" : "f95ff022-08da-428c-9fd7-1cc001d67740",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "But that's nothing new. All free bindings of a piece of code affect its semantics. So the semantics of any expression that's not closed depends on its location (?)\r\n",
        "createdAt" : "2016-12-06T00:50:17Z",
        "updatedAt" : "2016-12-17T20:50:40Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "d4e619ca-4ea6-4c42-ad9e-0faa4c4c7b39",
        "parentId" : "f95ff022-08da-428c-9fd7-1cc001d67740",
        "authorId" : "5d637332-899b-40ac-b935-84e0c4c368a3",
        "body" : "Fair point, free bindings impede refactoring whether they're implicit or not. My mistake.",
        "createdAt" : "2016-12-06T20:04:16Z",
        "updatedAt" : "2016-12-17T20:50:40Z",
        "lastEditedBy" : "5d637332-899b-40ac-b935-84e0c4c368a3",
        "tags" : [
        ]
      },
      {
        "id" : "cf8aa18f-13a0-4fc5-8a64-5640135e6549",
        "parentId" : "f95ff022-08da-428c-9fd7-1cc001d67740",
        "authorId" : "348fab8e-49e2-442e-884d-850c7f41fdde",
        "body" : "> But that's nothing new. All free bindings of a piece of code affect its semantics. So the semantics of any expression that's not closed depends on its location (?)\r\n\r\nImplicits simply hide the free variables in use, so that figuring out the context requires typechecking rather than just parsing. So, after you look up `implicitly`'s type, you discover that `implicitly[Foo]` is an open term (which is sugar for open term `implicitly[Foo](theImplicitDefinition)`). This is confusing enough it was (indirectly) discussed above: https://github.com/lampepfl/dotty/pull/1775#discussion_r91242465",
        "createdAt" : "2016-12-08T15:27:34Z",
        "updatedAt" : "2016-12-17T20:50:40Z",
        "lastEditedBy" : "348fab8e-49e2-442e-884d-850c7f41fdde",
        "tags" : [
        ]
      }
    ],
    "commit" : "2e99511840915e2805e7a2c07571d3859a3db698",
    "line" : 62,
    "diffHunk" : "@@ -1,1 +60,64 @@purely functional way.\n\nThe main downside of implicit parameters is the verbosity of their\ndeclaration syntax. It's hard to illustrate this with a smallish example,\nbecause it really only becomes a problem at scale, but let's try anyway."
  }
]
[
  {
    "id" : "01d6e3a2-eef4-47e7-a610-fddf9a44aafb",
    "prId" : 8538,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/8538#pullrequestreview-374398084",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fc525211-b230-4f61-a3e7-3038fe7ecf5c",
        "parentId" : null,
        "authorId" : "3a3c9c08-5985-41f6-a86b-7fc5a427f51a",
        "body" : "/cc @liufengyun ",
        "createdAt" : "2020-03-13T15:33:18Z",
        "updatedAt" : "2020-03-18T18:06:04Z",
        "lastEditedBy" : "3a3c9c08-5985-41f6-a86b-7fc5a427f51a",
        "tags" : [
        ]
      }
    ],
    "commit" : "bd1a31102b9f348763f7e2af2542f75391d0247b",
    "line" : 19,
    "diffHunk" : "@@ -1,1 +17,21 @@<!--more-->\n# Cool new features\n## Safe initialization checks\nWhen a class is instantiated, the fields in the class body are initialized by field initializers, which could be any Scala code. Such a versatile language feature gives the programmer flexibility in defining how objects are initialized. However, such flexibility also brings complexity to ensure that we never accidentally use a field before it's initialized. Initialization errors can be difficult to spot in the presence of complex language features, such as inheritance, traits, inner classes, and aliasing. Such errors, sometimes simple sometimes subtle, require programmer efforts to debug and fix, which has been a [pain point for Scala programmers](https://contributors.scala-lang.org/t/improve-forward-reference-handling/3616) for a long time.\n"
  },
  {
    "id" : "99768898-75e7-4dbc-bd26-3d17fcb8ccf2",
    "prId" : 8538,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/8538#pullrequestreview-374398084",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "223859c3-1b9d-4266-a3a3-76bf183a9f91",
        "parentId" : null,
        "authorId" : "3a3c9c08-5985-41f6-a86b-7fc5a427f51a",
        "body" : "/cc @bishabosha ",
        "createdAt" : "2020-03-13T15:33:30Z",
        "updatedAt" : "2020-03-18T18:06:04Z",
        "lastEditedBy" : "3a3c9c08-5985-41f6-a86b-7fc5a427f51a",
        "tags" : [
        ]
      }
    ],
    "commit" : "bd1a31102b9f348763f7e2af2542f75391d0247b",
    "line" : 57,
    "diffHunk" : "@@ -1,1 +55,59 @@You can learn more about the feature from the [documentation](https://dotty.epfl.ch/0.23.0-RC1/docs/reference/other-new-features/safe-initialization.html). For the discussion, see PR [#7789](https://github.com/lampepfl/dotty/pull/7789).\n\n## Bitwise Int compiletime operations\nIn the previous release, Dotty has [received](https://dotty.epfl.ch/blog/2020/02/05/22nd-dotty-milestone-release.html#primitive-compiletime-operations-on-singleton-types) a support for type-level arithmetic operations on integers. In this release, we are extending this support by adding bitwise operations. For example:\n"
  },
  {
    "id" : "dced5b23-da74-4540-907b-e91c7e4a8947",
    "prId" : 8538,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/8538#pullrequestreview-374398084",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5399a104-d38f-485d-8d1d-9a59d01905c9",
        "parentId" : null,
        "authorId" : "3a3c9c08-5985-41f6-a86b-7fc5a427f51a",
        "body" : "/cc @odersky ",
        "createdAt" : "2020-03-13T15:33:39Z",
        "updatedAt" : "2020-03-18T18:06:04Z",
        "lastEditedBy" : "3a3c9c08-5985-41f6-a86b-7fc5a427f51a",
        "tags" : [
        ]
      }
    ],
    "commit" : "bd1a31102b9f348763f7e2af2542f75391d0247b",
    "line" : 80,
    "diffHunk" : "@@ -1,1 +78,82 @@You can find the list of all the supported operations in the `scala.compiletime.ops` [package](https://github.com/bishabosha/dotty/blob/e2b0de0bf70bbde5a9a92dc7fa91b36537b02a87/library/src/scala/compiletime/ops/package.scala)\n\n# Syntactic Changes\n## Context functions syntax improved\nIn this release, we have done some work to improve the syntax of context functions. Now, their syntax is closer to the syntax for context parameters of methods."
  },
  {
    "id" : "b63cc927-a668-4c70-a1d1-1edd8dda80ba",
    "prId" : 8538,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/8538#pullrequestreview-374398084",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e6471012-e614-4d1f-9349-a8ceda14ff7a",
        "parentId" : null,
        "authorId" : "3a3c9c08-5985-41f6-a86b-7fc5a427f51a",
        "body" : "/cc @nicolasstucki ",
        "createdAt" : "2020-03-13T15:33:48Z",
        "updatedAt" : "2020-03-18T18:06:04Z",
        "lastEditedBy" : "3a3c9c08-5985-41f6-a86b-7fc5a427f51a",
        "tags" : [
        ]
      }
    ],
    "commit" : "bd1a31102b9f348763f7e2af2542f75391d0247b",
    "line" : 117,
    "diffHunk" : "@@ -1,1 +115,119 @@However, both syntaxes were supported for that release for experimental purposes. Now, we are dropping the support of the old syntax in favor of the new one as we see it as a clear win over the old one.\n\n# Metaprogramming\n## Inline version of `summon`\nInside an inline method, we often want to summon a value without declaring it as a context parameter of the method:"
  },
  {
    "id" : "4897d330-3d7e-4edc-ad7d-fb0a6a51339d",
    "prId" : 8538,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/8538#pullrequestreview-375096740",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6a3748c4-4760-4946-adb2-a4eea6522da0",
        "parentId" : null,
        "authorId" : "128563de-a925-4397-af34-450c7978a8d2",
        "body" : "Maybe there should be a reference to the changes to implicit scope rules that allow this to happen",
        "createdAt" : "2020-03-16T10:52:55Z",
        "updatedAt" : "2020-03-18T18:06:04Z",
        "lastEditedBy" : "128563de-a925-4397-af34-450c7978a8d2",
        "tags" : [
        ]
      }
    ],
    "commit" : "bd1a31102b9f348763f7e2af2542f75391d0247b",
    "line" : 205,
    "diffHunk" : "@@ -1,1 +203,207 @@\n## TASTy Reflect imports simplified\nPreviously, to access TASTy Reflect features of Dotty, you had to include an import as follows:\n\n```scala"
  }
]
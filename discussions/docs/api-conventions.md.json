[
  {
    "id" : "b9cbc31f-ff8c-44a4-9bcb-291e7110f055",
    "prId" : 6933,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "867108b8-a0eb-4f09-be23-77e540889edc",
        "parentId" : null,
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "\"allows alternative content types\"-- is that true? Or are you referring to the proxying or something?\n",
        "createdAt" : "2015-04-16T23:43:19Z",
        "updatedAt" : "2015-04-16T23:43:19Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "34c9bc32-a873-44db-a30b-3b2638c2d7eb",
        "parentId" : "867108b8-a0eb-4f09-be23-77e540889edc",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "> On Apr 16, 2015, at 7:43 PM, Daniel Smith notifications@github.com wrote:\n> \n> In docs/api-conventions.md:\n> \n> >  The conventions of the [Kubernetes API](api.md) (and related APIs in the ecosystem) are intended to ease client development and ensure that configuration mechanisms can be implemented that work across a diverse set of use cases consistently.\n> > \n> > -The general style of the Kubernetes API is RESTful - clients create, update, delete, or retrieve a description of an object via the standard HTTP verbs (POST, PUT, DELETE, and GET) - and those APIs preferentially accept and return JSON. Kubernetes also exposes additional endpoints for non-standard verbs and allows alternative content types. All of the JSON accepted and returned by the server has a schema, identified by the \"kind\" and \"apiVersion\" fields.\n> > +The general style of the Kubernetes API is RESTful - clients create, update, delete, or retrieve a description of an object via the standard HTTP verbs (POST, PUT, DELETE, and GET) - and those APIs preferentially accept and return JSON. Kubernetes also exposes additional endpoints for non-standard verbs and allows alternative content types. All of the JSON accepted and returned by the server has a schema, identified by the \"kind\" and \"apiVersion\" fields. Where relevant HTTP header fields exist, they should mirror the content of JSON fields, but the information should not be represented only in the HTTP header.\n> > \"allows alternative content types\"-- is that true? Or are you referring to the proxying or something?\n> \n> Yeah, we have pod logs (text/plain)\n> —\n> Reply to this email directly or view it on GitHub.\n",
        "createdAt" : "2015-04-16T23:44:57Z",
        "updatedAt" : "2015-04-16T23:44:57Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "bdd6a122-30f0-4188-bfaa-2f1740867960",
        "parentId" : "867108b8-a0eb-4f09-be23-77e540889edc",
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "PATCH also has other content types.\n",
        "createdAt" : "2015-04-16T23:55:21Z",
        "updatedAt" : "2015-04-16T23:55:21Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      }
    ],
    "commit" : "f1cea092df1d6765ba5576401ddb0bc8d1d9c36d",
    "line" : 10,
    "diffHunk" : "@@ -1,1 +6,10 @@The conventions of the [Kubernetes API](api.md) (and related APIs in the ecosystem) are intended to ease client development and ensure that configuration mechanisms can be implemented that work across a diverse set of use cases consistently.\n\nThe general style of the Kubernetes API is RESTful - clients create, update, delete, or retrieve a description of an object via the standard HTTP verbs (POST, PUT, DELETE, and GET) - and those APIs preferentially accept and return JSON. Kubernetes also exposes additional endpoints for non-standard verbs and allows alternative content types. All of the JSON accepted and returned by the server has a schema, identified by the \"kind\" and \"apiVersion\" fields. Where relevant HTTP header fields exist, they should mirror the content of JSON fields, but the information should not be represented only in the HTTP header.\n\nThe following terms are defined:"
  },
  {
    "id" : "6bd9a749-ea4f-4536-947f-064bb3571a2f",
    "prId" : 5350,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7e4dc9de-d0ad-4b5b-8d9f-0849851f9c58",
        "parentId" : null,
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "typo: received\n",
        "createdAt" : "2015-03-12T22:46:08Z",
        "updatedAt" : "2015-03-12T22:46:08Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      }
    ],
    "commit" : "024460e147a31da43753dbf40ae6f32cd58c8740",
    "line" : 79,
    "diffHunk" : "@@ -1,1 +279,283 @@    * Do not retry. Fix the request.\n* `429 StatusTooManyRequests`\n  * Indicates that the either the client rate limit has been exceeded or the server has recieved more requests then it can process.\n  * Suggested client recovery behavior:\n    * Read the ```Retry-After``` HTTP header from the response, and wait at least that long before retrying."
  },
  {
    "id" : "6601ea98-db8e-4940-bef8-65d4c312b780",
    "prId" : 5058,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d09d4d77-11e9-466f-8f91-f1651cf342d3",
        "parentId" : null,
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "Changes to api-conventions.md LGTM. Thanks.\n",
        "createdAt" : "2015-03-05T20:46:18Z",
        "updatedAt" : "2015-03-06T04:58:45Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      }
    ],
    "commit" : "1ed3f7ffcd9bd7357b9961e691078bf5a0567b78",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +194,198 @@-----------------------------------\n\nKubernetes leverages the concept of *resource versions* to achieve optimistic concurrency. All kubernetes resources have a \"resourceVersion\" field as part of their metadata. This resourceVersion is a string that identifies the internal version of an object that can be used by clients to determine when objects have changed. When a record is about to be updated, it's version is checked against a pre-saved value, and if it doesn't match, the update fails with a StatusConflict (HTTP status code 409).\n\nThe resourceVersion is changed by the server every time an object is modified. If resourceVersion is included with the PUT operation the system will verify that there have not been other successful mutations to the resource during a read/modify/write cycle, by verifying that the current value of resourceVersion matches the specified value."
  },
  {
    "id" : "d5318b65-6b2c-45e3-b752-4bc2f0f8d940",
    "prId" : 4375,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0c686337-07b0-47f6-93ab-7ac98b70e537",
        "parentId" : null,
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "Are we actually going to use ListMeta, or just populate a subset of ObjectMeta, or will it depend on whether the schema of an object is reused (as in status) or not (as in binding)?\n",
        "createdAt" : "2015-02-13T22:29:06Z",
        "updatedAt" : "2015-02-20T20:46:39Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "abcccf5a-f5b4-4b68-be8a-53226c73c54b",
        "parentId" : "0c686337-07b0-47f6-93ab-7ac98b70e537",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "ListMeta (poorly named though it is), seems appropriate.  Status doesn't really have a name or namespace or labels or annotations, so I think our initial call on ListMeta vs Object was accurate.  Maybe we rename ListMeta to SimpleMeta eventually.\n",
        "createdAt" : "2015-02-17T15:54:13Z",
        "updatedAt" : "2015-02-20T20:46:39Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "9b012c46-a8f1-4ad2-adf5-10ad33188269",
        "parentId" : "0c686337-07b0-47f6-93ab-7ac98b70e537",
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "Agreed. SimpleMeta, BasicMeta, SchemaMeta, KindMeta ...\n",
        "createdAt" : "2015-02-20T00:10:50Z",
        "updatedAt" : "2015-02-20T20:46:39Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      }
    ],
    "commit" : "8c7a8b434727074ce5f72b2bf56dc5145e23e489",
    "line" : 52,
    "diffHunk" : "@@ -1,1 +43,47 @@3. **Simple** kinds are used for specific actions on objects and for non-persistent entities.\n\n   Given their limited scope, they have the same set of limited common metadata as lists.\n\n   The \"size\" action may accept a simple resource that has only a single field as input (the number of things). The \"status\" kind is returned when errors occur and is not persisted in the system."
  },
  {
    "id" : "1f5d0029-f487-42f3-ba78-58a5c94b50ad",
    "prId" : 4375,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "657e868f-d00f-4b44-a85f-169dc6869aec",
        "parentId" : null,
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "One thing I would like to add re. status, since it has come up a couple times recently: Even if persisted, status MUST be reconstructable from other sources.\n",
        "createdAt" : "2015-02-20T00:14:47Z",
        "updatedAt" : "2015-02-20T20:46:39Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      }
    ],
    "commit" : "8c7a8b434727074ce5f72b2bf56dc5145e23e489",
    "line" : 82,
    "diffHunk" : "@@ -1,1 +81,85 @@#### Spec and Status\n\nBy convention, the Kubernetes API makes a distinction between the specification of the desired state of an object (a nested object field called \"spec\") and the status of the object at the current time (a nested object field called \"status\"). The specification is persisted in stable storage with the API object and reflects user input. The status is summarizes the current state of the object in the system, and is usually persisted with the object by an automated processes (but may be created on the fly).\n\nFor example, a pod object has a \"spec\" object field that defines how the pod should be run. The pod also has a \"status\" object field that shows details about what is happening on the host that is running the containers in the pod (if available) and a summarized \"phase\" string that indicates where the pod is in its lifecycle."
  },
  {
    "id" : "fcbcc1fc-9ffc-4d59-9602-6fc9ca5301b5",
    "prId" : 1225,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e25b01fb-da36-4b27-88f7-2f14f7b6dfb7",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "curious why we track ctime and not mtime?\n",
        "createdAt" : "2014-09-24T21:05:19Z",
        "updatedAt" : "2014-09-29T16:10:45Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "c7222d80-cf0f-4f9a-84a7-1aa2357e0de6",
        "parentId" : "e25b01fb-da36-4b27-88f7-2f14f7b6dfb7",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Lazy\n",
        "createdAt" : "2014-09-25T19:30:40Z",
        "updatedAt" : "2014-09-29T16:10:45Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "e5f053ba-0bfb-4937-be39-e15efebe8bd0",
        "parentId" : "e25b01fb-da36-4b27-88f7-2f14f7b6dfb7",
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "Metadata modification time, desired state modification time, current state modification time, time of any modification?\n\nCreation time is helpful for the user to understand the object's identity. Modification time can also be useful, but events will be more useful to people and both events and resourceVersion would be more useful programmatically.\n",
        "createdAt" : "2014-09-25T20:37:04Z",
        "updatedAt" : "2014-09-29T16:10:45Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      }
    ],
    "commit" : "c0247d92ce4ed4daba77eecf207cbc14178ad61e",
    "line" : null,
    "diffHunk" : "@@ -1,1 +48,52 @@\n* resourceVersion: a string that identifies the internal version of this object that can be used by clients to determine when objects have changed. This value MUST be treated as opaque by clients and passed unmodified back to the server. Clients should not assume that the resource version has meaning across namespaces, different kinds of resources, or different servers.\n* creationTimestamp: a string representing an RFC 3339 date of the date and time an object was created\n* labels: a map of string keys and values that can be used to organize and categorize objects (see [labels.md](labels.md))\n* annotations: a map of string keys and values that can be used by external tooling to store and retrieve arbitrary metadata about this object (see [annotations.md](annotations.md))"
  },
  {
    "id" : "795a4524-cc82-4bcd-b055-86bcffd9ec3f",
    "prId" : 1225,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f9859924-1ffd-4534-a8f9-ba73254b63ea",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "See previous comment - now I am even more confused.\n",
        "createdAt" : "2014-09-24T21:08:32Z",
        "updatedAt" : "2014-09-29T16:10:45Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "c0247d92ce4ed4daba77eecf207cbc14178ad61e",
    "line" : 65,
    "diffHunk" : "@@ -1,1 +63,67 @@Every list SHOULD have the following metadata in a nested object field called \"metadata\":\n\n* resourceVersion: a string that identifies the common version of the objects returned by in a list. This value MUST be treated as opaque by clients and passed unmodified back to the server. A resource version is only valid within a single namespace on a single kind of resource.\n\n"
  },
  {
    "id" : "8e5df82b-19d1-476b-a484-f8be991dc36e",
    "prId" : 1225,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bded5a29-465a-4465-8405-a7342ed6ae4a",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "To be clear - we intend to support create by either POST to collection or PUT to named (non-existing) resource?\n",
        "createdAt" : "2014-09-24T21:13:49Z",
        "updatedAt" : "2014-09-29T16:10:45Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "97a679b7-b532-47f2-a425-2891b9a37c48",
        "parentId" : "bded5a29-465a-4465-8405-a7342ed6ae4a",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "> The PUT method requests that the enclosed entity be stored under the supplied Request-URI. If the Request-URI refers to an already existing resource, the enclosed entity SHOULD be considered as a modified version of the one residing on the origin server. If the Request-URI does not point to an existing resource, and that URI is capable of being defined as a new resource by the requesting user agent, the origin server can create the resource with that URI. If a new resource is created, the origin server MUST inform the user agent via the 201 (Created) response\n\nDo we have a reason to support or not support?  I like GetOrCreate personally.\n",
        "createdAt" : "2014-09-25T19:27:56Z",
        "updatedAt" : "2014-09-29T16:10:45Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "a9a817b7-38ef-469b-9f34-43e09ce4799c",
        "parentId" : "bded5a29-465a-4465-8405-a7342ed6ae4a",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "No, I guess I am fine with it, I just wanted to be clear that this was the intent.  And it's more like CreateOrUpdate() :)\n",
        "createdAt" : "2014-09-25T20:33:18Z",
        "updatedAt" : "2014-09-29T16:10:45Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "c0247d92ce4ed4daba77eecf207cbc14178ad61e",
    "line" : 95,
    "diffHunk" : "@@ -1,1 +93,97 @@* GET /<resourceNamePlural>/<name> - Retrieves a single resource with the given name, e.g. GET /pods/first returns a Pod named 'first'\n* DELETE /<resourceNamePlural>/<name>  - Delete the single resource with the given name\n* PUT /<resourceNamePlural>/<name> - Update or create the resource with the given name with the JSON object provided by the client\n\nKubernetes by convention exposes additional verbs as new endpoints with singular names. Examples:"
  },
  {
    "id" : "aae54e11-95fd-4bf4-ab8e-1419e21d8f0d",
    "prId" : 1225,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "687964dc-707b-42cc-8260-2c369edc115f",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "Do you want to talk about the Spec/Status/Bound/whatever pattern for  types?  Or Is that too low-level?\n",
        "createdAt" : "2014-09-24T21:16:34Z",
        "updatedAt" : "2014-09-29T16:10:45Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "c0247d92ce4ed4daba77eecf207cbc14178ad61e",
    "line" : null,
    "diffHunk" : "@@ -1,1 +133,137 @@* Find the field \"current\" in the object \"state\" in the second item in the array \"fields\": `fields[0].state.current`\n\nTODO: Plugins, extensions, nested kinds, headers"
  },
  {
    "id" : "642c98ec-5f76-4533-8495-419225f07a1b",
    "prId" : 1225,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ebbdf6ac-c665-44c8-b0ba-009d2ce2419c",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "Can you remind me why we want this in a sub-object rather than embedded?\n",
        "createdAt" : "2014-09-24T21:48:57Z",
        "updatedAt" : "2014-09-29T16:10:45Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "2a19a835-dc5c-49a6-8b84-f7fc3e5d09af",
        "parentId" : "ebbdf6ac-c665-44c8-b0ba-009d2ce2419c",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "----- Original Message -----\n\n> > -   Lists have a limited set of common metadata. All lists use the \"items\"\n> >   field to contain the array of objects they return. Each resource kind\n> >   should have an endpoint that returns the full set of resources, as well as\n> >   zero or more endpoints that return subsets of the full list.\n> >   +\n> >   +The standard REST verbs (defined below) MUST return singular JSON objects.\n> >   Some API endpoints may deviate from the strict REST pattern and return\n> >   resources that are not singular JSON objects, such as streams of JSON\n> >   objects or unstructured text log data.\n> >   +\n> >   +\n> >   +### Resources\n> >   +\n> >   +All singular JSON resources returned by an API MUST have the following\n> >   fields:\n> >   +\n> >   +\\* kind: a string that identifies the schema this object should have\n> >   +\\* apiVersion: a string that identifiers the version of the schema the\n> >   object should have\n> >   +\n> >   +\n> >   +### Objects\n> >   +\n> >   +Every object MUST have the following metadata in a nested object field\n> >   called \"metadata\":\n> \n> Can you remind me why we want this in a sub-object rather than embedded?\n\nTo prevent it colliding from other resources or to allow it to grow larger over time without breaking end user names for fields.  It's also easier to ignore and blank out when copying resources. I'm halfway in between wanting it embedded (because that's what the vast majority of APIs do and is simpler to parse for many clients) and wanting it to be cleanly isolated.  Do we expect namespace collisions as we add metadata in the future?  If so, sub object.  Otherwise it's probably easier to inline.\n",
        "createdAt" : "2014-09-24T22:15:14Z",
        "updatedAt" : "2014-09-29T16:10:45Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "309fddeb-b1b8-444f-9436-2d25e6d07ad5",
        "parentId" : "ebbdf6ac-c665-44c8-b0ba-009d2ce2419c",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "Devil's advocate: embedding it gives us a disincentive to change this very often - that's probably a GOOD thing\n",
        "createdAt" : "2014-09-24T22:31:02Z",
        "updatedAt" : "2014-09-29T16:10:45Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "743a3064-ac34-4f7d-86fd-bc527a5fb429",
        "parentId" : "ebbdf6ac-c665-44c8-b0ba-009d2ce2419c",
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "PodTemplate is an example where we may need 2 copies of the metadata, in which case it would be less confusing for both copies to not be inline.\n\nFiltering by field for config would also likely be easier if the metadata weren't inline, since I expect most filtering to be by category: metadata, desired, current.\n",
        "createdAt" : "2014-09-25T04:38:30Z",
        "updatedAt" : "2014-09-29T16:10:45Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "3d59f9d6-1916-4f2f-8607-da8118383cff",
        "parentId" : "ebbdf6ac-c665-44c8-b0ba-009d2ce2419c",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "I'm fine either way.\n",
        "createdAt" : "2014-09-25T20:34:07Z",
        "updatedAt" : "2014-09-29T16:10:45Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "e5dc7641-afc9-44dc-876f-7498b6db2c27",
        "parentId" : "ebbdf6ac-c665-44c8-b0ba-009d2ce2419c",
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "Somewhere I thought I replied about making it easier to select out this group of fields in queries (GET ...?field=metadata), but I can't find that comment now.\n\nAlso, while Go appears to support inlining reasonably well even without Generics, I imagine that dealing with the metadata fields generically across object types without a common subobject may be challenging in some client languages.\n\nHowever, it's probably not super-critical either way, and I don't want to bikeshed about this forever. If we do inline these fields, then I'm going to insist that we inline nothing else -- all other fields must be in subobjects.\n",
        "createdAt" : "2014-09-25T21:45:45Z",
        "updatedAt" : "2014-09-29T16:10:45Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "aca5a61e-ddc4-48fa-8cba-9b94ee8c33f9",
        "parentId" : "ebbdf6ac-c665-44c8-b0ba-009d2ce2419c",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "I think the argument about being able to easily (from a client) map the \"metadata\" field to a specific object type won the argument for me at least.  If someone can articulate a new counter argument to \"metadata\" as a sub object (will regard it as the current argument) please do so in the next few days.\n\n----- Original Message -----\n\n> > -   Lists have a limited set of common metadata. All lists use the \"items\"\n> >   field to contain the array of objects they return. Each resource kind\n> >   should have an endpoint that returns the full set of resources, as well as\n> >   zero or more endpoints that return subsets of the full list.\n> >   +\n> >   +The standard REST verbs (defined below) MUST return singular JSON objects.\n> >   Some API endpoints may deviate from the strict REST pattern and return\n> >   resources that are not singular JSON objects, such as streams of JSON\n> >   objects or unstructured text log data.\n> >   +\n> >   +\n> >   +### Resources\n> >   +\n> >   +All singular JSON resources returned by an API MUST have the following\n> >   fields:\n> >   +\n> >   +\\* kind: a string that identifies the schema this object should have\n> >   +\\* apiVersion: a string that identifiers the version of the schema the\n> >   object should have\n> >   +\n> >   +\n> >   +### Objects\n> >   +\n> >   +Every object MUST have the following metadata in a nested object field\n> >   called \"metadata\":\n> \n> Somewhere I thought I replied about making it easier to select out this group\n> of fields in queries (GET ...?field=metadata), but I can't find that comment\n> now.\n> \n> Also, while Go appears to support inlining reasonably well even without\n> Generics, I imagine that dealing with the metadata fields generically across\n> object types without a common subobject may be challenging in some client\n> languages.\n> \n> However, it's probably not super-critical either way, and I don't want to\n> bikeshed about this forever. If we do inline these fields, then I'm going to\n> insist that we inline nothing else -- all other fields must be in\n> subobjects.\n> \n> ---\n> \n> Reply to this email directly or view it on GitHub:\n> https://github.com/GoogleCloudPlatform/kubernetes/pull/1225/files#r18062382\n",
        "createdAt" : "2014-09-26T15:48:53Z",
        "updatedAt" : "2014-09-29T16:10:45Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      }
    ],
    "commit" : "c0247d92ce4ed4daba77eecf207cbc14178ad61e",
    "line" : 41,
    "diffHunk" : "@@ -1,1 +39,43 @@### Objects\n\nEvery object MUST have the following metadata in a nested object field called \"metadata\":\n\n* namespace: a namespace is a DNS compatible subdomain that objects are subdivided into. The default namespace is 'default'.  See [namespaces.md](namespaces.md) for more."
  },
  {
    "id" : "7120db56-ad2c-4a68-9b1b-09aed23657ed",
    "prId" : 1225,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b125df74-1c1a-451e-ba8b-f36e3360bc7b",
        "parentId" : null,
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "This would be a good place to mention filtering by labels and fields, though labels are also discussed below.\n\n/cc @lavalamp \n",
        "createdAt" : "2014-09-25T21:30:40Z",
        "updatedAt" : "2014-09-29T16:10:45Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      }
    ],
    "commit" : "c0247d92ce4ed4daba77eecf207cbc14178ad61e",
    "line" : 22,
    "diffHunk" : "@@ -1,1 +20,24 @@   An API object resource is a record of intent - once created, the system will work to ensure that resource exists. All API objects have common metadata intended for client use.\n2. **Lists** are collections of **objects** of one or more types\n   Lists have a limited set of common metadata. All lists use the \"items\" field to contain the array of objects they return. Each resource kind should have an endpoint that returns the full set of resources, as well as zero or more endpoints that return subsets of the full list.\n\n   In addition, all lists that return objects with labels should support label filtering (see [labels.md](labels.md), and most lists should support filtering by fields."
  },
  {
    "id" : "a391c958-c9e3-471b-be38-abbf2f73450d",
    "prId" : 1225,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5a4e60e2-81fb-45b4-ab32-bce03751258d",
        "parentId" : null,
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "Which approach do we support now?\n",
        "createdAt" : "2014-09-26T21:23:11Z",
        "updatedAt" : "2014-09-29T16:10:45Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "92d43561-7e6b-41e7-9585-0bc8923a37eb",
        "parentId" : "5a4e60e2-81fb-45b4-ab32-bce03751258d",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Neither.  I can vague this up (or we could spawn an issue to implement it and clarify).\n\n> On Sep 26, 2014, at 5:23 PM, bgrant0607 notifications@github.com wrote:\n> \n> In docs/api-conventions.md:\n> \n> > +\n> > +\\* GET /watch/<resourceNamePlural> - Receive a stream of JSON objects corresponding to changes made to any resource of the given kind over time.\n> > +\\* GET /watch/<resourceNamePlural>/<name> - Receive a stream of JSON objects corresponding to changes made to the named resource of the given kind over time\n> > +\\* GET /redirect/<resourceNamePlural>/<name> - If the named resource can be described by a URL, return an HTTP redirect to that URL instead of a JSON response. For example, a service exposes a port and IP address and a client could invoke the redirect verb to receive an HTTP 307 redirection to that port and IP.\n> > +\n> > +Support of additional verbs is not required for all object types.\n> > +\n> > +\n> > +Idempotency\n> > +-----------\n> > +\n> > +All compatible Kubernetes APIs MUST support \"name idempotency\" and respond with an HTTP status code 409 when a request is made to POST an object that has the same name as an existing object in the system. See [identifiers.md](identifiers.md) for details.\n> > +\n> > +TODO: name generation\n> > +\n> > +APIs SHOULD set resourceVersion on retrieved resources, and support PUT idempotency by rejecting HTTP requests with a 409 HTTP status code where an HTTP header `If-Match: resourceVersion=` or `?resourceVersion=` query parameter are set and do not match the currently stored version of the resource.\n> > Which approach do we support now?\n> \n> —\n> Reply to this email directly or view it on GitHub.\n",
        "createdAt" : "2014-09-26T21:27:53Z",
        "updatedAt" : "2014-09-29T16:10:45Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "c01f62ce-3706-4942-bfd4-4cc63e409d76",
        "parentId" : "5a4e60e2-81fb-45b4-ab32-bce03751258d",
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "I'm fine with the text as-is for now, but please spawn an issue if this is entirely unimplemented. \n",
        "createdAt" : "2014-09-26T22:47:59Z",
        "updatedAt" : "2014-09-29T16:10:45Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "d94f35c2-570a-48b0-a0da-e8fc6357bdd5",
        "parentId" : "5a4e60e2-81fb-45b4-ab32-bce03751258d",
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "@lavalamp can correct me if I'm wrong, but my understanding is that we use resourceVersion from the object that is PUT as the precondition. It's a little tricky to track down, because I think we rely upon etcd for enforcement: pkg/tools/etcd_tools.go#L240.\n\nI guess that is a little awkward, since we're (presumably) not actually setting the field to that value.\n",
        "createdAt" : "2014-09-27T06:48:11Z",
        "updatedAt" : "2014-09-29T16:10:45Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "3027c112-906c-43d5-8706-26dfc10f742d",
        "parentId" : "5a4e60e2-81fb-45b4-ab32-bce03751258d",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "> > +APIs SHOULD set resourceVersion on retrieved resources, and support PUT\n> > idempotency by rejecting HTTP requests with a 409 HTTP status code where\n> > an HTTP header `If-Match: resourceVersion=` or `?resourceVersion=` query\n> > parameter are set and do not match the currently stored version of the\n> > resource.\n> \n> @lavalamp can correct me if I'm wrong, but my understanding is that we use\n> resourceVersion from the object that is PUT as the precondition. It's a\n> little tricky to track down, because I think we rely upon etcd for\n> enforcement: pkg/tools/etcd_tools.go#L240.\n> \n> I guess that is a little awkward, since we're (presumably) not actually\n> setting the field to that value.\n\nI think anywhere we use AtomicUpdate which calls into bodyExtractObj (most updates) we don't explicitly bail out if the value isn't the same.\n\nWe should probably open an issue to track codifying this - both the \"only continue if my version exactly matches\" and the \"ensure we're both working from the same original value\".\n",
        "createdAt" : "2014-09-29T15:59:30Z",
        "updatedAt" : "2014-09-29T16:10:45Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "5f796f65-2ffc-48ce-b031-0fb1545c9193",
        "parentId" : "5a4e60e2-81fb-45b4-ab32-bce03751258d",
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "I think this is #656 .\n",
        "createdAt" : "2014-09-30T00:07:15Z",
        "updatedAt" : "2014-09-30T00:07:15Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      }
    ],
    "commit" : "c0247d92ce4ed4daba77eecf207cbc14178ad61e",
    "line" : 113,
    "diffHunk" : "@@ -1,1 +111,115 @@TODO: name generation\n\nAPIs SHOULD set resourceVersion on retrieved resources, and support PUT idempotency by rejecting HTTP requests with a 409 HTTP status code where an HTTP header `If-Match: resourceVersion=` or `?resourceVersion=` query parameter are set and do not match the currently stored version of the resource.\n\nTODO: better syntax?"
  }
]
[
  {
    "id" : "dfc59599-1c69-4763-9cb2-49204d319996",
    "prId" : 3814,
    "prUrl" : "https://github.com/zio/zio/pull/3814#pullrequestreview-431368331",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f561b27b-35c8-4de7-af47-c00cd75b68ba",
        "parentId" : null,
        "authorId" : "ade9c4cf-e4cb-41af-a70b-b2af2be5fd37",
        "body" : "```suggestion\r\nNotice that a `TPriorityQueue` is created with an implicit `Ordering`. By default, `take` will return the value that is first in the specified ordering. For example, in a queue of events ordered by time the **last** event would be taken first. If you want a different behavior you can use a custom `Ordering`.\r\n```",
        "createdAt" : "2020-06-15T17:43:33Z",
        "updatedAt" : "2020-06-15T17:48:31Z",
        "lastEditedBy" : "ade9c4cf-e4cb-41af-a70b-b2af2be5fd37",
        "tags" : [
        ]
      },
      {
        "id" : "8182af8e-d1f0-4171-9385-6534f6dcb99d",
        "parentId" : "f561b27b-35c8-4de7-af47-c00cd75b68ba",
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "This isn't correct. The earliest duration event will be taken first.",
        "createdAt" : "2020-06-15T17:45:50Z",
        "updatedAt" : "2020-06-15T17:48:31Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      },
      {
        "id" : "195e61bb-0aac-4558-a550-5ebac5cf23a7",
        "parentId" : "f561b27b-35c8-4de7-af47-c00cd75b68ba",
        "authorId" : "ade9c4cf-e4cb-41af-a70b-b2af2be5fd37",
        "body" : "I swear I tried this out. Does not a Priority Queue on Longs take highest numbers first and thus, epochs with highest numbers (latest) taken first?",
        "createdAt" : "2020-06-15T17:50:20Z",
        "updatedAt" : "2020-06-15T17:50:20Z",
        "lastEditedBy" : "ade9c4cf-e4cb-41af-a70b-b2af2be5fd37",
        "tags" : [
        ]
      },
      {
        "id" : "04de3ff6-4780-4bc4-a3f5-0e732a9ff072",
        "parentId" : "f561b27b-35c8-4de7-af47-c00cd75b68ba",
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "`scala.collection.mutable.PriorityQueue` takes the \"last\" element in the ordering first, so if you put in `List(2, 4, 6, 3, 5, 6)` and then took all the values you would get `List(6, 6, 5, 4, 3, 2)`. `TPriorityQueue` as currently implemented takes the \"first\" element in the ordering first, so It would return `List(2, 3, 4, 5, 6, 6)`. I think that is the more intuitive behavior but admittedly it is somewhat arbitrary and the difference is less than ideal so we could certainly change.",
        "createdAt" : "2020-06-15T17:54:56Z",
        "updatedAt" : "2020-06-15T17:54:56Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      },
      {
        "id" : "beefe565-7589-4cd5-ad76-0fbc67672dbe",
        "parentId" : "f561b27b-35c8-4de7-af47-c00cd75b68ba",
        "authorId" : "ade9c4cf-e4cb-41af-a70b-b2af2be5fd37",
        "body" : "https://scastie.scala-lang.org/GXNM6EUOTTKHXRejowPHig",
        "createdAt" : "2020-06-15T18:06:28Z",
        "updatedAt" : "2020-06-15T18:06:28Z",
        "lastEditedBy" : "ade9c4cf-e4cb-41af-a70b-b2af2be5fd37",
        "tags" : [
        ]
      },
      {
        "id" : "4792ddb5-57c6-4c7d-bf0d-3244037c77fb",
        "parentId" : "f561b27b-35c8-4de7-af47-c00cd75b68ba",
        "authorId" : "ade9c4cf-e4cb-41af-a70b-b2af2be5fd37",
        "body" : "but when people think of a priority queue, they think of servicing elements with **highest** (largest) priority value first. So I am suggesting that the ZIO semantics on ordering are reversed of what it should be.",
        "createdAt" : "2020-06-15T18:07:59Z",
        "updatedAt" : "2020-06-15T18:08:41Z",
        "lastEditedBy" : "ade9c4cf-e4cb-41af-a70b-b2af2be5fd37",
        "tags" : [
        ]
      },
      {
        "id" : "5d01abc4-e3f9-4ae6-85df-b03356e0e78a",
        "parentId" : "f561b27b-35c8-4de7-af47-c00cd75b68ba",
        "authorId" : "ade9c4cf-e4cb-41af-a70b-b2af2be5fd37",
        "body" : "wikipedia: In computer science, a priority queue is an abstract data type similar to regular queue or stack data structure in which each element additionally has a \"priority\" associated with it. In a priority queue, an element with **high** priority is served before an element with low **priority**",
        "createdAt" : "2020-06-15T18:10:04Z",
        "updatedAt" : "2020-06-15T18:10:15Z",
        "lastEditedBy" : "ade9c4cf-e4cb-41af-a70b-b2af2be5fd37",
        "tags" : [
        ]
      },
      {
        "id" : "7fe3884a-a976-4035-840c-45e658611a73",
        "parentId" : "f561b27b-35c8-4de7-af47-c00cd75b68ba",
        "authorId" : "ade9c4cf-e4cb-41af-a70b-b2af2be5fd37",
        "body" : "I admit the standard understanding of priority or ordering forces users to do something different for a typical arrival time view of things.",
        "createdAt" : "2020-06-15T18:11:42Z",
        "updatedAt" : "2020-06-15T18:11:42Z",
        "lastEditedBy" : "ade9c4cf-e4cb-41af-a70b-b2af2be5fd37",
        "tags" : [
        ]
      },
      {
        "id" : "2a07cce0-79ff-472c-914b-fa89b6a39bab",
        "parentId" : "f561b27b-35c8-4de7-af47-c00cd75b68ba",
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "Yeah, I think the question is which element should have the highest \"priority\". For example the Haskell implementation [here](https://hackage.haskell.org/package/stm-data-collection-0.1.0.0/candidate/docs/Data-STM-PriorityQueue-Class.html) also returns the lowest value with the \"smallest\" key when you take an element. So I think both choices are equally valid it is just which one you want to use. Taking the \"smallest\" value first seems to be more useful for some applications like events and is consistent with sorting, but the \"largest value first\" is maybe more consistent with \"highest priority equals highest value\" and with `scala.collection.mutable.Queue`.\r\n\r\n@mijicd Do you have an opinion?",
        "createdAt" : "2020-06-15T18:44:40Z",
        "updatedAt" : "2020-06-15T18:44:40Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      },
      {
        "id" : "b13c41b2-fa34-4fcb-9a3c-9678e5f41913",
        "parentId" : "f561b27b-35c8-4de7-af47-c00cd75b68ba",
        "authorId" : "6080cd8f-e671-4d49-a54c-b6159456ac0e",
        "body" : "I would stay aligned with haskell's API, even though I understand what Phil's saying above. We should be able to pick an ordering on creation if I'm not mistaken.",
        "createdAt" : "2020-06-16T10:27:54Z",
        "updatedAt" : "2020-06-16T10:27:54Z",
        "lastEditedBy" : "6080cd8f-e671-4d49-a54c-b6159456ac0e",
        "tags" : [
        ]
      }
    ],
    "commit" : "9fd503209e2dcb2cf0ef8a5ee61bd584ef61204c",
    "line" : 20,
    "diffHunk" : "@@ -1,1 +18,22 @@```\n\nNotice that a `TPriorityQueue` is created with an implicit `Ordering`. By default, `take` will return the value that is first in the specified ordering. For example, in a queue of events ordered by time the earliest event would be taken first. If you want a different behavior you can use a custom `Ordering`.\n\n```scala mdoc:silent"
  }
]
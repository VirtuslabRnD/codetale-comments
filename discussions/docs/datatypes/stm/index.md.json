[
  {
    "id" : "34a5d817-a708-4c4c-95c0-2e5583aafe46",
    "prId" : 4957,
    "prUrl" : "https://github.com/zio/zio/pull/4957#pullrequestreview-637180843",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "09e1cdf6-4284-4a09-a2ae-1cc470185704",
        "parentId" : null,
        "authorId" : "6080cd8f-e671-4d49-a54c-b6159456ac0e",
        "body" : "I would emphasize \"the obvious\" here, i. e. read rather than writes, \"short\" transactions rather than the \"long\" ones. Perhaps it also makes sense stating that we will try to prevent retry storms with a bit crude heuristic - after a certain number of retries is reached, lock & complete.",
        "createdAt" : "2021-04-15T22:36:14Z",
        "updatedAt" : "2021-04-15T22:39:09Z",
        "lastEditedBy" : "6080cd8f-e671-4d49-a54c-b6159456ac0e",
        "tags" : [
        ]
      }
    ],
    "commit" : "864e7374db0202ba712c5f89e0c59dee1ba3b226",
    "line" : 187,
    "diffHunk" : "@@ -1,1 +183,187 @@2. **Virtual Execution** — The runtime starts speculating the execution of transactions on every read and write operation. It has two internal logs;  the read and the write log. On the read log, it saves the version of all variables it reads during the intermediate steps, and on the write log, it saves the intermediate result of the transaction. It doesn't change the shared state on the main memory. Anything that is inside an atomic block is not executed immediately, it's executed in the virtual world, just by putting stuff in the internal log, not in the main memory. In this particular model, we guarantee that all computations are isolated from one another.\n\n3. **Commit Phase (Real Execution)** — When it came to the end of the transaction the runtime system should check everything it has read. It should make sure that it saw a consistent state of the universe and if it had, then it atomically commits. As the STM is optimistic, it assumes that in the middle of a transaction the chance of interfering with the shared state by other fibers is very rare. But it must ready itself for the worst cases. It should validate its assumption in the final stage. It checks whether the transactional variables involved were modified by any other threads or not. If its assumption got invalidated in the meanwhile of the transaction, it should abandon the transaction and retry it again. It jumps to the start of the transaction with the original and default values and tries again until it succeeds; This is necessary to resolve conflicts. Otherwise, if there was no conflict, it commits the final value atomically to the memory and succeeds. From point of view of other fibers, all values in memory exchanging in one blink of an eye. It's all atomic.\n\nEverything done within a transaction to other transactions looks like it happens at once or not at all. So no matter how many pieces of memory it touches during the transaction. From the other transaction perspective, all of these changes happen at once."
  }
]
[
  {
    "id" : "4638c58c-1593-4491-ac6b-d0c10943696b",
    "prId" : 10431,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b755d23a-2411-4a9a-b23f-d0ccec50eed0",
        "parentId" : null,
        "authorId" : "e7e1d709-e9c3-47a5-91f2-ed86958679e2",
        "body" : "Would it be worth putting this in a `**Note for GKE:**` block at the top of this section as well? I'm not sure whether this would lead people to ask 'why don't they put \"Note for AWS,\" \"Note for XYZ,\" etc.', but if I'm thinking purely about document consistency, it would be great to have, under each section, a note about whether I can use this for my provider. You've done this for the negatives, so I'm just wondering whether the positives would also be helpful.\n",
        "createdAt" : "2015-06-29T17:56:13Z",
        "updatedAt" : "2015-07-01T23:47:00Z",
        "lastEditedBy" : "e7e1d709-e9c3-47a5-91f2-ed86958679e2",
        "tags" : [
        ]
      },
      {
        "id" : "23f978ff-2f0d-4dcb-8182-86c666e79ee6",
        "parentId" : "b755d23a-2411-4a9a-b23f-d0ccec50eed0",
        "authorId" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "body" : "Testing on all the other providers is impractical and so I'm reluctant to put an explicit positive in for them.  \n",
        "createdAt" : "2015-06-29T19:25:33Z",
        "updatedAt" : "2015-07-01T23:47:00Z",
        "lastEditedBy" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "tags" : [
        ]
      },
      {
        "id" : "e0302d5b-d907-4d1b-92a4-00d1df4efb60",
        "parentId" : "b755d23a-2411-4a9a-b23f-d0ccec50eed0",
        "authorId" : "e7e1d709-e9c3-47a5-91f2-ed86958679e2",
        "body" : "I agree. I'm wondering whether you think it might be worth it for just GKE (as we already put what won't work for GKE).\n",
        "createdAt" : "2015-06-29T20:23:47Z",
        "updatedAt" : "2015-07-01T23:47:00Z",
        "lastEditedBy" : "e7e1d709-e9c3-47a5-91f2-ed86958679e2",
        "tags" : [
        ]
      }
    ],
    "commit" : "ed2d42e54c142251b39bb06f004fb4430564727f",
    "line" : 119,
    "diffHunk" : "@@ -1,1 +192,196 @@is to fix that.\n\nYou can use this in conjunction with a per-node `.dockerfile`.  The credentials\nwill be merged.  This approach will work on Google Container Engine (GKE).\n"
  },
  {
    "id" : "a3a8b7da-8cdd-4b0e-b634-a066870c5546",
    "prId" : 10431,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "dc22c4d9-dc07-4c9f-ab2c-a75ee0edf104",
        "parentId" : null,
        "authorId" : "c2b5c827-efcd-438f-8db5-52d917b1cde9",
        "body" : "You might make a note that for GCE this is only going to work temporarily. If a node gets replaced by the MIG or you scale up your cluster to add a new node then you need to manually repeat this step. \n",
        "createdAt" : "2015-06-30T16:53:01Z",
        "updatedAt" : "2015-07-01T23:47:00Z",
        "lastEditedBy" : "c2b5c827-efcd-438f-8db5-52d917b1cde9",
        "tags" : [
        ]
      }
    ],
    "commit" : "ed2d42e54c142251b39bb06f004fb4430564727f",
    "line" : 48,
    "diffHunk" : "@@ -1,1 +65,69 @@      - for example: `nodes=$(kubectl get nodes -o template --template='{{range.items}}{{.metadata.name}} {{end}}')`\n   1. copy your local `.dockercfg` to the home directory of roon on each node.\n      - for example: `for n in $nodes; do scp ~/.dockercfg root@$n:/root/.dockercfg`\n\nVerify by creating a pod that uses a private image, e.g.:"
  },
  {
    "id" : "eed34de9-aefb-4ff0-b71d-e9fda0f77b82",
    "prId" : 10316,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "97527c38-0b76-46f7-9832-c84b5f36ddee",
        "parentId" : null,
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "So that's a private registry on dockerhub, I presume? You didn't want to show an example of using a privately run registry? It would be nice to be able to resolve #499.\n",
        "createdAt" : "2015-06-25T00:12:44Z",
        "updatedAt" : "2015-06-29T19:22:29Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "8d827bac-0998-49c5-b1d8-2cbf904bf974",
        "parentId" : "97527c38-0b76-46f7-9832-c84b5f36ddee",
        "authorId" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "body" : "I've tested these examples.  It took a good chunk of a day to get it all working.  I'd like to check in this improvement.  \n",
        "createdAt" : "2015-06-25T20:34:14Z",
        "updatedAt" : "2015-06-29T19:22:29Z",
        "lastEditedBy" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "tags" : [
        ]
      },
      {
        "id" : "287a0792-da88-4126-bb9c-c5af689efb81",
        "parentId" : "97527c38-0b76-46f7-9832-c84b5f36ddee",
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "Understandable.\n",
        "createdAt" : "2015-06-26T04:15:31Z",
        "updatedAt" : "2015-06-29T19:22:29Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      }
    ],
    "commit" : "7e6f1bd852207416068513fd00b139cc1298346b",
    "line" : 89,
    "diffHunk" : "@@ -1,1 +119,123 @@  containers:\n    - name: foo\n      image: janedoe/awesomeapp:v1\n  imagePullSecrets:\n    - name: myregistrykey"
  },
  {
    "id" : "d1800449-fe68-4267-bd2c-7c9271bbd8e2",
    "prId" : 10316,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7e175517-29ac-48c0-810b-0d6f203d6720",
        "parentId" : null,
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "Could you please fix the title of the subsection -- ImagePullSecrets?\n",
        "createdAt" : "2015-06-26T04:15:11Z",
        "updatedAt" : "2015-06-29T19:22:29Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "27afa1d7-30ff-4b57-968a-644db934b719",
        "parentId" : "7e175517-29ac-48c0-810b-0d6f203d6720",
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "ping\n",
        "createdAt" : "2015-06-26T23:38:09Z",
        "updatedAt" : "2015-06-29T19:22:29Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "c33b9dc0-fa61-456c-a8b3-ae5b6d5bb117",
        "parentId" : "7e175517-29ac-48c0-810b-0d6f203d6720",
        "authorId" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "body" : "fixed.\n",
        "createdAt" : "2015-06-29T19:14:28Z",
        "updatedAt" : "2015-06-29T19:22:29Z",
        "lastEditedBy" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "tags" : [
        ]
      }
    ],
    "commit" : "7e6f1bd852207416068513fd00b139cc1298346b",
    "line" : 19,
    "diffHunk" : "@@ -1,1 +73,77 @@\nFirst, create a `.dockercfg`, such as running `docker login <registry.domain>`.\nThen put the resulting `.dockercfg` file into a [secret resource](../docs/secrets.md).  For example:\n```\n$ docker login"
  },
  {
    "id" : "f48237b8-c649-4d01-97ae-d6de9cb88e7c",
    "prId" : 9495,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "eb09eed8-6189-4a97-a5fd-a41cdbbd8f6a",
        "parentId" : null,
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "`PullIfNotPresent` for consistency with above?\n",
        "createdAt" : "2015-06-09T18:34:53Z",
        "updatedAt" : "2015-06-10T22:19:15Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      }
    ],
    "commit" : "7658071ef8b023ddc04236884d8121fbfeb7e338",
    "line" : null,
    "diffHunk" : "@@ -1,1 +59,63 @@\nBe default, the kubelet will try to pull each image from the specified registry.\nHowever, if the `imagePullPolicy` property of the container is set to `IfNotPresent` or `Never`,\nthen a local image is used (preferentially or exclusively, respectively).\n"
  },
  {
    "id" : "3e7ebe2c-693a-4f51-9391-308eb97b76ec",
    "prId" : 9495,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0051e0b5-72a1-44d6-a975-cb129da2ba1c",
        "parentId" : null,
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "Expand on this to make it clear that even though a user may expect his images to be protected, with `PullIfNotPresent` a clever person can go fishing for access to images that another pod has pulled.\n",
        "createdAt" : "2015-06-09T18:35:55Z",
        "updatedAt" : "2015-06-10T22:19:15Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      },
      {
        "id" : "c8047999-8c96-4621-8231-8514b2e88b15",
        "parentId" : "0051e0b5-72a1-44d6-a975-cb129da2ba1c",
        "authorId" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "body" : "Are you saying that if a container uses PullIfNotPresent, that it potentially has access to all images ever pulled on the machine, including those pulled with `imagePullSecret`?\n",
        "createdAt" : "2015-06-10T20:52:20Z",
        "updatedAt" : "2015-06-10T22:19:15Z",
        "lastEditedBy" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "tags" : [
        ]
      },
      {
        "id" : "830beb62-9e09-4eec-8b12-d9e2cc238af2",
        "parentId" : "0051e0b5-72a1-44d6-a975-cb129da2ba1c",
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "> Are you saying that if a container uses PullIfNotPresent, that it potentially has access to all images ever pulled on the machine, including those pulled with imagePullSecret?\n\nYes, this is a side-effect of not having the equivalent of the Docker registry not having a SubjectAccessReview (MotherMayI) API.  It will work for the same reason that pre-pulling images will work.\n\n@smarterclayton Suggested a couple workarounds, but they all behaved unexpectedly when access to the Docker registry was down, but not denied.  Things like \"try to pull the image and make sure you start getting a layer back\".\n",
        "createdAt" : "2015-06-11T11:41:43Z",
        "updatedAt" : "2015-06-11T11:41:43Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      },
      {
        "id" : "00afce62-ad2a-433e-848c-ec9284c467c9",
        "parentId" : "0051e0b5-72a1-44d6-a975-cb129da2ba1c",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "> On Jun 11, 2015, at 7:41 AM, David Eads notifications@github.com wrote:\n> \n> In docs/images.md:\n> \n> >  This can be used to preload certain images for speed or as an alternative to authenticating to a private registry.\n> > \n> > -Pull Policy is per-container, but any user of the cluster will have access to all local images.\n> > +All pods will have read access to any pre-pulled images.\n> > Are you saying that if a container uses PullIfNotPresent, that it potentially has access to all images ever pulled on the machine, including those pulled with imagePullSecret?\n> \n> Yes, this is a side-effect of not having the equivalent of the Docker registry not having a SubjectAccessReview (MotherMayI) API. It will work for the same reason that pre-pulling images will work.\n> \n> @smarterclayton Suggested a couple workarounds, but they all behaved unexpectedly when access to the Docker registry was down, but not denied. Things like \"try to pull the image and make sure you start getting a layer back\".\n> \n> We should probably work with upstream to get a HEAD check for is the current client authorized to pull a given image\n> —\n> Reply to this email directly or view it on GitHub.\n",
        "createdAt" : "2015-06-11T13:35:37Z",
        "updatedAt" : "2015-06-11T13:35:37Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "bc6dab03-6520-4d2a-8623-2815956e1b72",
        "parentId" : "0051e0b5-72a1-44d6-a975-cb129da2ba1c",
        "authorId" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "body" : "+1 @smarterclayton\nOn Thu, Jun 11, 2015 at 9:35 AM Clayton Coleman notifications@github.com\nwrote:\n\n> In docs/images.md\n> https://github.com/GoogleCloudPlatform/kubernetes/pull/9495#discussion_r32220285\n> :\n> \n> >  This can be used to preload certain images for speed or as an alternative to authenticating to a private registry.\n> > \n> > -Pull Policy is per-container, but any user of the cluster will have access to all local images.\n> > +All pods will have read access to any pre-pulled images.\n> \n>  On Jun 11, 2015, at 7:41 AM, David Eads notifications@github.com\n> wrote: In docs/images.md: > This can be used to preload certain images\n> for speed or as an alternative to authenticating to a private registry. > >\n> -Pull Policy is per-container, but any user of the cluster will have access\n> to all local images. > +All pods will have read access to any pre-pulled\n> images. Are you saying that if a container uses PullIfNotPresent, that it\n> potentially has access to all images ever pulled on the machine, including\n> those pulled with imagePullSecret? Yes, this is a side-effect of not having\n> the equivalent of the Docker registry not having a SubjectAccessReview\n> (MotherMayI) API. It will work for the same reason that pre-pulling images\n> will work. @smarterclayton https://github.com/smarterclayton Suggested\n> a couple workarounds, but they all behaved unexpectedly when access to the\n> Docker registry was down, but not denied. Things like \"try to pull the\n> image and make sure you start getting a layer back\".\n> We should probably work with upstream to get a HEAD check for is the\n> current client authorized to pull a given image\n> … <#msg-f:1503689175645998986_>\n>  — Reply to this email directly or view it on GitHub.\n> \n> —\n> Reply to this email directly or view it on GitHub\n> https://github.com/GoogleCloudPlatform/kubernetes/pull/9495/files#r32220285\n> .\n",
        "createdAt" : "2015-06-11T14:20:58Z",
        "updatedAt" : "2015-06-11T14:20:58Z",
        "lastEditedBy" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "tags" : [
        ]
      },
      {
        "id" : "28406394-e265-4cc6-9795-1caedbb5a860",
        "parentId" : "0051e0b5-72a1-44d6-a975-cb129da2ba1c",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "----- Original Message -----\n\n> >  This can be used to preload certain images for speed or as an alternative\n> >  to authenticating to a private registry.\n> > \n> > -Pull Policy is per-container, but any user of the cluster will have access\n> > to all local images.\n> > +All pods will have read access to any pre-pulled images.\n> > \n> > Are you saying that if a container uses PullIfNotPresent, that it\n> > potentially has access to all images ever pulled on the machine, including\n> > those pulled with imagePullSecret?\n> \n> Yes, this is a side-effect of not having the equivalent of the Docker\n> registry not having a SubjectAccessReview (MotherMayI) API.  It will work\n> for the same reason that pre-pulling images will work.\n> \n> @smarterclayton Suggested a couple workarounds, but they all behaved\n> unexpectedly when access to the Docker registry was down, but not denied.\n> Things like \"try to pull the image and make sure you start getting a layer\n> back\".\n\nAlso, this fits in with something we've been discussing with @ncdc with regards to push - the daemon essentially has to do proof of work to the registry when pushing images (prove that it has the lower level layers) otherwise you'd be able to lie about what images you have access to and push/pull your own.  That proof of work today is \"push the whole binary to the server\", but there are ongoing discussions about it being cryptographic \"I ran a crypto-secure transformation on something locally and it proves I have the binary\" or even more simply, passing authorization on push that proves access to the other image \"here is the token I used to fetch the image\".  \n\nThe latter is a lot like the pullIfNotPresent problem - the Kubelet needs to avoid being a confused deputy (I pulled A for Alice, but Bob shouldn't be able to leverage that to get A) by checking Bob's credentials against the registry for A first.\n\n> ---\n> \n> Reply to this email directly or view it on GitHub:\n> https://github.com/GoogleCloudPlatform/kubernetes/pull/9495/files#r32212336\n",
        "createdAt" : "2015-06-11T14:24:48Z",
        "updatedAt" : "2015-06-11T14:24:48Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      }
    ],
    "commit" : "7658071ef8b023ddc04236884d8121fbfeb7e338",
    "line" : 74,
    "diffHunk" : "@@ -1,1 +67,71 @@This can be used to preload certain images for speed or as an alternative to authenticating to a private registry.\n\nAll pods will have read access to any pre-pulled images.\n\n### Specifying ImagePullKeys on a Pod"
  },
  {
    "id" : "90a28e9d-b272-4551-86e4-a0a82d58de3f",
    "prId" : 1690,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "375b2e02-695a-4db6-9429-3a7d584ac0a4",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "kubelet has a root dir flag - shouldn't we use that rather than \"it depends\" ?  Writing files in / is horrible.\n",
        "createdAt" : "2014-10-10T04:53:12Z",
        "updatedAt" : "2014-10-10T04:53:12Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "2aa9dae5d1b8b515f47436e0e19c44f92351b390",
    "line" : 9,
    "diffHunk" : "@@ -1,1 +7,11 @@\n## Using a Private Registry\nKeys for private registries are stored in a `.dockercfg` file.  Create a config file by running `docker login <registry>.<domain>` and then copying the resulting `.dockercfg` file to the kubelet working dir.\nThe kubelet working dir varies by cloud provider.  It is `/` on GCE and `/home/core` on CoreOS.  You can determine the working dir by running this command:\n`sudo ls -ld /proc/$(pidof kubelet)/cwd` on a kNode."
  }
]
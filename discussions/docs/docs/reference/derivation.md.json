[
  {
    "id" : "a27f13ff-c142-47af-9588-de907212d0b2",
    "prId" : 5540,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/5540#pullrequestreview-184154762",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "dcdf3fd2-0489-47c3-83c2-1714b80cb97b",
        "parentId" : null,
        "authorId" : "4107dafe-4e7b-4e85-8d5b-63e06e0e6318",
        "body" : "Can they also have sealed classes as children?",
        "createdAt" : "2018-12-11T13:52:58Z",
        "updatedAt" : "2019-01-19T16:40:59Z",
        "lastEditedBy" : "4107dafe-4e7b-4e85-8d5b-63e06e0e6318",
        "tags" : [
        ]
      },
      {
        "id" : "04eaddb7-9c2d-4531-85c2-4152828626d2",
        "parentId" : "dcdf3fd2-0489-47c3-83c2-1714b80cb97b",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "if they are not case classes, no.\r\n",
        "createdAt" : "2018-12-12T12:33:38Z",
        "updatedAt" : "2019-01-19T16:40:59Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "5e4fa24b6ef68b20f91541da8b6a779426a5cd03",
    "line" : 25,
    "diffHunk" : "@@ -1,1 +23,27 @@\n - individual case classes or case objects\n - sealed classes or traits that have only case classes and case objects as children.\n\n Examples:"
  },
  {
    "id" : "d820e150-d25d-444c-954a-0d80c58657f3",
    "prId" : 5540,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/5540#pullrequestreview-184156261",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d8e2ae56-f8aa-4850-a32a-f21e3024c549",
        "parentId" : null,
        "authorId" : "4107dafe-4e7b-4e85-8d5b-63e06e0e6318",
        "body" : "Is there any restriction on the kind of that type parameter? For instance, is it possible to write `derives Functor` (assuming a `trait Functor[F[_]]` definition)?",
        "createdAt" : "2018-12-11T13:57:02Z",
        "updatedAt" : "2019-01-19T16:40:59Z",
        "lastEditedBy" : "4107dafe-4e7b-4e85-8d5b-63e06e0e6318",
        "tags" : [
        ]
      },
      {
        "id" : "e1a9170e-920b-48dd-acce-a18a07d63176",
        "parentId" : "d8e2ae56-f8aa-4850-a32a-f21e3024c549",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "There is no such restriction. But there's a caveat: The `Shape` type is always first-kinded. If you want to derive a higher-kinded type class instance from that you have to do some lifting of the Shape type to the type constructor level. That's possible using the type match machinery. @OlivierBlanvillain has done a PoC.",
        "createdAt" : "2018-12-12T12:37:41Z",
        "updatedAt" : "2019-01-19T16:40:59Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "5e4fa24b6ef68b20f91541da8b6a779426a5cd03",
    "line" : 43,
    "diffHunk" : "@@ -1,1 +41,45 @@A trait or class can appear in a `derives` clause if\n\n - it has a single type parameter, and\n - its companion object defines a method named `derived`.\n"
  },
  {
    "id" : "eb04235d-851c-4c49-b6e6-e9ea052d013c",
    "prId" : 5540,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/5540#pullrequestreview-184155233",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d868ef8f-d4c9-44b0-a1d8-f33814a7cc6d",
        "parentId" : null,
        "authorId" : "4107dafe-4e7b-4e85-8d5b-63e06e0e6318",
        "body" : "Could the synthesis of `Generic` be kept as an implementation detail? Do we need to be aware of where it comes from, if anyway we can always get a `Generic[A]` when we ask one?",
        "createdAt" : "2018-12-11T14:09:55Z",
        "updatedAt" : "2019-01-19T16:40:59Z",
        "lastEditedBy" : "4107dafe-4e7b-4e85-8d5b-63e06e0e6318",
        "tags" : [
        ]
      },
      {
        "id" : "fc6be430-9dd7-40dc-abe3-d9b4ee422d9c",
        "parentId" : "d868ef8f-d4c9-44b0-a1d8-f33814a7cc6d",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Yes, we could keep it as a detail. It's just that the synthesis does generate a significant amount of code, so it's good to know that this will be done only once per class with a derives clause instead of once per usage.",
        "createdAt" : "2018-12-12T12:34:53Z",
        "updatedAt" : "2019-01-19T16:40:59Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "5e4fa24b6ef68b20f91541da8b6a779426a5cd03",
    "line" : 360,
    "diffHunk" : "@@ -1,1 +358,362 @@would still be synthesized by the compiler at the point where `derived` is called.\nThis is similar to the situation with type tags or class tags: If no implicit instance\nis found, the compiler will synthesize one.\n\n### Syntax"
  }
]
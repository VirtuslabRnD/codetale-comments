[
  {
    "id" : "86d2fbf1-06fc-49dc-9b29-7aabc471934d",
    "prId" : 10949,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/10949#pullrequestreview-563515743",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "820f859b-63aa-455f-b69a-35889d619db2",
        "parentId" : null,
        "authorId" : "128563de-a925-4397-af34-450c7978a8d2",
        "body" : "this change comes from observation that implicit forwarders are only generated from wildcard selectors and not given selectors",
        "createdAt" : "2021-01-07T14:12:29Z",
        "updatedAt" : "2021-01-12T17:34:31Z",
        "lastEditedBy" : "128563de-a925-4397-af34-450c7978a8d2",
        "tags" : [
        ]
      }
    ],
    "commit" : "7ebdc1c0a1d738faf1656bca7f088052c484f43f",
    "line" : 24,
    "diffHunk" : "@@ -1,1 +69,73 @@ - it is accessible at the export clause,\n - it is not a constructor, nor the (synthetic) class part of an object,\n - it is a given instance (declared with `given`) if and only if the export is from a _given selector_.\n\nIt is a compile-time error if a simple or renaming selector does not identify any eligible"
  },
  {
    "id" : "c0c96e32-9805-4e5f-b1fe-39e04aa3d26f",
    "prId" : 6169,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/6169#pullrequestreview-221691687",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "55f8e4b1-9bc4-4e27-9fe0-f66d9957df03",
        "parentId" : null,
        "authorId" : "6d71bb21-e402-4464-b2b1-8bdd8e068461",
        "body" : "What about annotations, access modifiers, and the inline modifier?",
        "createdAt" : "2019-04-02T10:01:03Z",
        "updatedAt" : "2019-04-03T09:44:49Z",
        "lastEditedBy" : "6d71bb21-e402-4464-b2b1-8bdd8e068461",
        "tags" : [
        ]
      },
      {
        "id" : "74240910-e943-4610-9cea-848c61cfd7ef",
        "parentId" : "55f8e4b1-9bc4-4e27-9fe0-f66d9957df03",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "None of them are copied (I believe that's implied by the text).",
        "createdAt" : "2019-04-02T14:23:17Z",
        "updatedAt" : "2019-04-03T09:44:49Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "1731ba770156c0ba6e1128f2e9cded9aa224f472",
    "line" : 70,
    "diffHunk" : "@@ -1,1 +68,72 @@members.\n\nType members are aliased by type definitions, and term members are aliased by method definitions. Export aliases copy the type and value parameters of the members they refer to.\nExport aliases are always `final`. Aliases of implied instances are again `implied` (and aliases of old-style implicits are `implicit`). There are no other modifiers that can be given to an alias. This has the following consequences for overriding:\n"
  },
  {
    "id" : "a42190de-4f58-4328-a8b0-7c00207fc297",
    "prId" : 6169,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/6169#pullrequestreview-221692134",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "20e323ed-ca49-42b5-9929-6dd33581b434",
        "parentId" : null,
        "authorId" : "6d71bb21-e402-4464-b2b1-8bdd8e068461",
        "body" : "From this it's not very clear if definitions in classes can use exported aliases...",
        "createdAt" : "2019-04-02T11:35:11Z",
        "updatedAt" : "2019-04-03T09:44:49Z",
        "lastEditedBy" : "6d71bb21-e402-4464-b2b1-8bdd8e068461",
        "tags" : [
        ]
      },
      {
        "id" : "73da1e82-47b4-441e-8d76-9e8c4773640a",
        "parentId" : "20e323ed-ca49-42b5-9929-6dd33581b434",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "They can, but paths to exported aliases cannot refer to other exported aliases.",
        "createdAt" : "2019-04-02T14:23:57Z",
        "updatedAt" : "2019-04-03T09:44:49Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "1731ba770156c0ba6e1128f2e9cded9aa224f472",
    "line" : 135,
    "diffHunk" : "@@ -1,1 +133,137 @@ 2. Elaborate the parameters of the class.\n 3. Elaborate the self type of the class, if one is given.\n 4. Enter all definitions of the class as class members, with types to be completed\n    on demand.\n 5. Determine the types of all parents of the class."
  }
]
[
  {
    "id" : "d2ee82af-aed3-4a84-a0dd-eebe23984343",
    "prId" : 5754,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/5754#pullrequestreview-196541390",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "98d99d2e-320e-472e-856e-81ef5702fbee",
        "parentId" : null,
        "authorId" : "3c8c722c-1058-44e8-b516-65ba116b23db",
        "body" : "Another limitation worth mentioning is that you now cannot have multiple source files with the same name containing top-level definitions under separate compilation.\r\n\r\nThis is the same limitation as package objects currently have, so to me it's no big deal, but worth mentioning explicitly I think.",
        "createdAt" : "2019-01-25T14:53:58Z",
        "updatedAt" : "2019-02-04T15:48:01Z",
        "lastEditedBy" : "3c8c722c-1058-44e8-b516-65ba116b23db",
        "tags" : [
        ]
      }
    ],
    "commit" : "537f80d90d7822a33b3f62d01d24b67c6906efe9",
    "line" : 38,
    "diffHunk" : "@@ -1,1 +36,40 @@If a source file `src.scala` contains such toplevel definitions, they will be put in a synthetic object named `src$package`. The wrapping is transparent, however. The definitions in `src` can still be accessed as members of the enclosing package.\n\n**Note 1:** This means that the name of a source file containing wrapped toplevel definitions is relevant for binary compatibility. If the name changes, so does the name of the generated object and its class.\n\n**Note 2:** A toplevel main method `def main(args: Array[String]): Unit = ...` is wrapped as any other method. If it appears"
  },
  {
    "id" : "fafe4357-aa4a-4636-a9d6-cddc6679887f",
    "prId" : 5754,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/5754#pullrequestreview-196773337",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c5dbec8f-582d-4870-89e4-b6b28cdb9578",
        "parentId" : null,
        "authorId" : "3c8c722c-1058-44e8-b516-65ba116b23db",
        "body" : "What about side-effecting expressions like `println(\"Hello\")`? Those should work too right, since wrapping them in `val _ = println(\"Hello\")` is trivial ",
        "createdAt" : "2019-01-25T14:55:34Z",
        "updatedAt" : "2019-02-04T15:48:01Z",
        "lastEditedBy" : "3c8c722c-1058-44e8-b516-65ba116b23db",
        "tags" : [
        ]
      },
      {
        "id" : "8d30b478-7285-46bd-bdba-cb22cde3ce0d",
        "parentId" : "c5dbec8f-582d-4870-89e4-b6b28cdb9578",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Yes, but the changes in parser do not support them. I am not sure we want to do this.",
        "createdAt" : "2019-01-25T16:46:50Z",
        "updatedAt" : "2019-02-04T15:48:01Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "fcb31f35-9026-44e5-ad75-760d25c2738b",
        "parentId" : "c5dbec8f-582d-4870-89e4-b6b28cdb9578",
        "authorId" : "3c8c722c-1058-44e8-b516-65ba116b23db",
        "body" : "If the goal is to try and normalize the various Scala source file syntaxes as @smarter wants, we would need to do this since all the various Scala scripting syntaxes (Ammonite's `amm`, `scala` command, Mill, SBT, worksheets, ...) all support top-level expressions like this.\r\n\r\nThis would also potentially make getting started with Scala much simpler: you could write code in a file, and run the file (this would require straightforward changes in the launcher script). Hello world could literally be `println(\"Hello World\")` in a `Hello.scala`. That would move Scala closer to the Python getting started experience `print(\"Hello World\")`, I think in a good way.",
        "createdAt" : "2019-01-25T16:56:31Z",
        "updatedAt" : "2019-02-04T15:48:01Z",
        "lastEditedBy" : "3c8c722c-1058-44e8-b516-65ba116b23db",
        "tags" : [
        ]
      },
      {
        "id" : "8b6ab88d-0af7-403c-87ea-abb7bb66ce42",
        "parentId" : "c5dbec8f-582d-4870-89e4-b6b28cdb9578",
        "authorId" : "04cdd3c6-dc1a-4ad4-93ba-222a24a5ebdb",
        "body" : "I agree with @lihaoyi-databricks about the benefits. I remember my first scala experience where I could do stuff in REPL that are impossible when I write a scala file and compile it (and I don't mean redeclaring defs and vals, of course).",
        "createdAt" : "2019-01-25T17:48:52Z",
        "updatedAt" : "2019-02-04T15:48:01Z",
        "lastEditedBy" : "04cdd3c6-dc1a-4ad4-93ba-222a24a5ebdb",
        "tags" : [
        ]
      },
      {
        "id" : "40d654b8-3161-4352-8c65-e7ff80bc42d0",
        "parentId" : "c5dbec8f-582d-4870-89e4-b6b28cdb9578",
        "authorId" : "04cdd3c6-dc1a-4ad4-93ba-222a24a5ebdb",
        "body" : "Maybe we should somehow separate the concept between an application and a library. Indeed a library shouldn't have side-effecting values, but an application, why not? Why to write an application we need to extend `App` instead of just writing the main code in the file? ",
        "createdAt" : "2019-01-25T17:51:56Z",
        "updatedAt" : "2019-02-04T15:48:01Z",
        "lastEditedBy" : "04cdd3c6-dc1a-4ad4-93ba-222a24a5ebdb",
        "tags" : [
        ]
      },
      {
        "id" : "331f6234-5e8f-474f-ab0d-2f2d8c246b0a",
        "parentId" : "c5dbec8f-582d-4870-89e4-b6b28cdb9578",
        "authorId" : "844b9a74-cf0e-4a85-9eec-48f8379ca6de",
        "body" : "@soronpo one neat way to disambiguate \"applications\" or \"entrypoints\" with top-level code and \"libraries\" without top-level code would be the file extension: `.sc` files are entrypoints, `.scala` files are library files. `.sc` is already supported by a lot of tools, editors such as IntelliJ, etc. which understand those files to allow top-level expressions.",
        "createdAt" : "2019-01-26T03:01:26Z",
        "updatedAt" : "2019-02-04T15:48:01Z",
        "lastEditedBy" : "844b9a74-cf0e-4a85-9eec-48f8379ca6de",
        "tags" : [
        ]
      }
    ],
    "commit" : "537f80d90d7822a33b3f62d01d24b67c6906efe9",
    "line" : 34,
    "diffHunk" : "@@ -1,1 +32,36 @@ - all pattern, value, method, and type definitions,\n - implicit classes and objects,\n - companion objects of opaque types.\n\nIf a source file `src.scala` contains such toplevel definitions, they will be put in a synthetic object named `src$package`. The wrapping is transparent, however. The definitions in `src` can still be accessed as members of the enclosing package."
  },
  {
    "id" : "4ec89d9b-e838-41d5-83ed-8f99031bfd90",
    "prId" : 5754,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/5754#pullrequestreview-196556524",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "19e25211-9c0c-470b-b3f7-cc41a7eb7aa0",
        "parentId" : null,
        "authorId" : "3c8c722c-1058-44e8-b516-65ba116b23db",
        "body" : "One thing that package objects have over top-level definitions is that they can inherit traits and classes. I use this in e.g. Requests-Scala in order for the package-level API to expose a \"default\" configuration, while still having a trait that the user over the library can inherit from the create their own custom configurations of the API. ",
        "createdAt" : "2019-01-25T15:18:50Z",
        "updatedAt" : "2019-02-04T15:48:01Z",
        "lastEditedBy" : "3c8c722c-1058-44e8-b516-65ba116b23db",
        "tags" : [
        ]
      },
      {
        "id" : "6df87b5e-cfe8-4362-897c-9ec716183d37",
        "parentId" : "19e25211-9c0c-470b-b3f7-cc41a7eb7aa0",
        "authorId" : "04cdd3c6-dc1a-4ad4-93ba-222a24a5ebdb",
        "body" : "@lihaoyi-databricks There is already a PR in place deprecating this ability.\r\nhttps://github.com/scala/scala/pull/7662",
        "createdAt" : "2019-01-25T15:25:28Z",
        "updatedAt" : "2019-02-04T15:48:01Z",
        "lastEditedBy" : "04cdd3c6-dc1a-4ad4-93ba-222a24a5ebdb",
        "tags" : [
        ]
      }
    ],
    "commit" : "537f80d90d7822a33b3f62d01d24b67c6906efe9",
    "line" : 15,
    "diffHunk" : "@@ -1,1 +13,17 @@will be dropped. They are still available in Scala 3.0, but will be deprecated and removed afterwards.\n\nPackage objects are no longer needed since all kinds of definitions can now be written at the top-level. E.g.\n```scala\n    package p"
  },
  {
    "id" : "33772054-8711-4146-9058-2d017c27f834",
    "prId" : 5754,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/5754#pullrequestreview-198965172",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8f2a1df2-0647-4608-8765-891150e72a3c",
        "parentId" : null,
        "authorId" : "2a804d41-bef3-4841-887a-0df1ce452fe9",
        "body" : "Is this intentional forever? It seems like it could add a lot of value to have a simpler way of writing programs without the need for the excess baggage of a wrapper object. Similar to @lihaoyi-databricks's suggestion of script files, but supporting programs with arguments.",
        "createdAt" : "2019-01-31T19:59:36Z",
        "updatedAt" : "2019-02-04T15:48:01Z",
        "lastEditedBy" : "2a804d41-bef3-4841-887a-0df1ce452fe9",
        "tags" : [
        ]
      },
      {
        "id" : "2074dc98-7518-4238-95d9-1a7734cfc6cf",
        "parentId" : "8f2a1df2-0647-4608-8765-891150e72a3c",
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Agreed, but we'd need to come up with a way to do that which fits with everything else, suggestions welcome.",
        "createdAt" : "2019-01-31T20:10:10Z",
        "updatedAt" : "2019-02-04T15:48:01Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "1f639b9c-e210-4883-a7a1-351b38d82a2a",
        "parentId" : "8f2a1df2-0647-4608-8765-891150e72a3c",
        "authorId" : "3c8c722c-1058-44e8-b516-65ba116b23db",
        "body" : "> supporting programs with arguments.\r\n\r\nThe way it's done in Python is just making the program command-line arguments a global variable. Not that unusual when you consider how most other inputs to a program (filesystem, network access, system call interface, ...) are similarly global even in Java/Scala programs\r\n\r\nIf you want to be fancy, Ammonite and Mill have `@main` methods with auto deserialization of flags into method params, `--help`-text generation, nice error messages, handling of default arguments, etc.. But I suspect that's too much to embed into the core language runtime.",
        "createdAt" : "2019-01-31T21:52:21Z",
        "updatedAt" : "2019-02-04T15:48:01Z",
        "lastEditedBy" : "3c8c722c-1058-44e8-b516-65ba116b23db",
        "tags" : [
        ]
      },
      {
        "id" : "1a192d2f-2137-470f-beec-a603d9cb73e3",
        "parentId" : "8f2a1df2-0647-4608-8765-891150e72a3c",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "There's another problem, independent of command line arguments. The synthetic name of the wrapper is mangled, i.e. `src$package`. The reason for doing this is that before accessing a member of a package the first time, we need to scan all wrappers for their contents. But we certainly do not want to scan all class files in the package. The naming convention tells us which files to scan. There might be another way to do it, but this one seemed to be the most straightforward.",
        "createdAt" : "2019-01-31T22:04:05Z",
        "updatedAt" : "2019-02-04T15:48:01Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "e1f8e51d-f1b8-47e6-a2ac-4c40c6d93c10",
        "parentId" : "8f2a1df2-0647-4608-8765-891150e72a3c",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "I don't think toplevel definitions are the right way to write main programs anyway. The problem is, you still have to write a `main` method with an array parameter, which is bulky. I prefer our current way of expressing this:\r\n```\r\nobject Prog extends App {\r\n  ...\r\n}\r\n```\r\n",
        "createdAt" : "2019-02-01T08:22:23Z",
        "updatedAt" : "2019-02-04T15:48:01Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "537f80d90d7822a33b3f62d01d24b67c6906efe9",
    "line" : 42,
    "diffHunk" : "@@ -1,1 +40,44 @@**Note 2:** A toplevel main method `def main(args: Array[String]): Unit = ...` is wrapped as any other method. If it appears\nin a source file `src.scala`, it could be invoked from the command line using a command like `scala src$package`. Since the\n\"program name\" is mangled it is recommended to always put `main` methods in explicitly named objects.\n\n**Note 3:** The notion of `private` is independent of whether a definition is wrapped or not. A `private` toplevel definition is always visible from everywhere in the enclosing package."
  }
]
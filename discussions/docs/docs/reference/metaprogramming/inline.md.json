[
  {
    "id" : "61281c80-143e-4281-aeaf-71ec4ccd037f",
    "prId" : 11787,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/11787#pullrequestreview-614164288",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fd7757e5-39e8-4ca3-8fa1-9d9187007474",
        "parentId" : null,
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "```suggestion\r\nFor more information about the semantics of `inline`, see the [Semantics-preserving inlining for metaprogramming](https://dl.acm.org/doi/10.1145/3426426.3428486) paper.\r\n```",
        "createdAt" : "2021-03-17T10:52:19Z",
        "updatedAt" : "2021-03-17T10:52:27Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      }
    ],
    "commit" : "ab1ef7430188d3d6386b801aba27fa57638248d5",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +640,644 @@### Reference\n\nFor more information about the semantics of `inline`, see the [Scala 2020: Semantics-preserving inlining for metaprogramming](https://dl.acm.org/doi/10.1145/3426426.3428486) paper.\n\nFor more information about compiletime operation, see [PR #4768](https://github.com/lampepfl/dotty/pull/4768),"
  },
  {
    "id" : "299bcb0f-a88f-479f-a5ef-9f24e441c4d7",
    "prId" : 10538,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/10538#pullrequestreview-542100710",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4673bff0-0dd5-4647-98df-38c1209bc510",
        "parentId" : null,
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "`infix` is accidentally removed?",
        "createdAt" : "2020-12-01T08:37:49Z",
        "updatedAt" : "2020-12-01T19:11:04Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "a3e0b814-b96d-4110-a4eb-cf24ec9c5cd3",
        "parentId" : "4673bff0-0dd5-4647-98df-38c1209bc510",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "No, it's not needed for symbolic identifiers. \r\n",
        "createdAt" : "2020-12-01T16:08:19Z",
        "updatedAt" : "2020-12-01T19:11:04Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "e4d91c0b-eb27-45b3-ac0a-64de315527df",
        "parentId" : "4673bff0-0dd5-4647-98df-38c1209bc510",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "Then we need to remove `import scala.annotation.infix`.",
        "createdAt" : "2020-12-01T16:52:00Z",
        "updatedAt" : "2020-12-01T19:11:04Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      }
    ],
    "commit" : "7fde702224490007a304f94f15787b307f59a89b",
    "line" : 17,
    "diffHunk" : "@@ -1,1 +521,525 @@import scala.annotation.infix\n\ntype +[X <: Int | String, Y <: Int | String] = (X, Y) match {\n  case (Int, Int) => int.+[X, Y]\n  case (String, String) => string.+[X, Y]"
  },
  {
    "id" : "6124766f-4662-4fa9-93a9-18eea171811e",
    "prId" : 8543,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/8543#pullrequestreview-380400654",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e99594ad-2241-41dc-b059-054445d36a83",
        "parentId" : null,
        "authorId" : "5a9cd756-9120-4d5e-ac88-e9c636084f0e",
        "body" : "Hum, I don't think we should allow *concrete* inline methods to be overridden, even by other inline methods. This can break the semantics of polymorphic dispatch, because we might not flag a call to a method of the superclass on an instance that, at runtime, will be of a subclass.\r\n\r\nIt works with abstract inline methods because attempts at calling those will be flagged if they cannot be resolved to an overriding concrete inline method.",
        "createdAt" : "2020-03-15T17:59:30Z",
        "updatedAt" : "2020-03-19T09:37:36Z",
        "lastEditedBy" : "5a9cd756-9120-4d5e-ac88-e9c636084f0e",
        "tags" : [
        ]
      },
      {
        "id" : "7735a390-00bd-484a-9689-2e3bddaf7aa1",
        "parentId" : "e99594ad-2241-41dc-b059-054445d36a83",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "I tried with the last commit but it breaks scalatest. We have two inline versions of `assert`; one in Assertions the other in Diagrams. What scalatest does does not look unreasonable. It's a pity that this means we get static behavior which is not backed by runtime behavior. But it does not look easy to find workarounds in existing software. \r\n\r\nSo I think we will have to revert this.\r\n",
        "createdAt" : "2020-03-17T20:36:56Z",
        "updatedAt" : "2020-03-19T09:37:36Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "7b0a1ecd-9bed-4dc0-a21f-8e95dc83d3d4",
        "parentId" : "e99594ad-2241-41dc-b059-054445d36a83",
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "(for reference the definitions in scalatest are https://github.com/scalatest/scalatest/blob/4e1e38e2372ddada9037d442aa7efed1418119d9/scalatest.dotty/src/main/scala/org/scalatest/Assertions.scala#L470 and https://github.com/scalatest/scalatest/blob/4e1e38e2372ddada9037d442aa7efed1418119d9/scalatest.dotty/src/main/scala/org/scalatest/diagrams/Diagrams.scala#L180).\r\n\r\nI'm still strongly in favor of disallowing this. As @sjrd said, it just has the wrong semantics. Scalatest will have to be slightly refactored to avoid the override: put the code for the regular assert and diagram assert in the same macro, and pass a boolean to the macro to decide which branch to use, this boolean could come from a def in the trait that can be overridden in Diagrams to preserve the current API. This does not allow users to overrides assert themselves like the previous version could, but we can't do that without breaking semantics so that's not a bad thing.",
        "createdAt" : "2020-03-17T21:07:36Z",
        "updatedAt" : "2020-03-19T09:37:36Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "544a1a57-5fd4-4cc6-a701-0eaef03e1b8d",
        "parentId" : "e99594ad-2241-41dc-b059-054445d36a83",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "I am not sure. What you propose is a breach of modularity. Assertions now has to know that there is an override in Diagrams. This might work in this concrete example, but I am not sure where else this pattern is used.\r\n\r\nSo, in the abstract it's better to disallow but in the concrete I personally do not want to deal with the breakage this causes. I'll revert for now and open an issue. If someone wants to take this up, fine. ",
        "createdAt" : "2020-03-17T21:18:30Z",
        "updatedAt" : "2020-03-19T09:37:36Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "04d5e3ca-8474-4a3c-b572-9a1cef59ad55",
        "parentId" : "e99594ad-2241-41dc-b059-054445d36a83",
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "> What you propose is a breach of modularity.\r\n\r\ninline defs inherently break modularity, better make that obvious than have surprising semantics IMO. But we can indeed discuss this separately.",
        "createdAt" : "2020-03-17T21:39:34Z",
        "updatedAt" : "2020-03-19T09:37:36Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "97ed8453-13e9-4833-8f8e-810d51985755",
        "parentId" : "e99594ad-2241-41dc-b059-054445d36a83",
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Thinking about it, an abstract inline def assert in a base trait would probably suite scalacheck well, but it might require a bigger refactoring.",
        "createdAt" : "2020-03-17T21:44:05Z",
        "updatedAt" : "2020-03-19T09:37:36Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "1ee4784d-b5a6-4930-9245-aec54084cd68",
        "parentId" : "e99594ad-2241-41dc-b059-054445d36a83",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "For scalatest the refactoring seems simple. We can have a single macro in `Assertions` that takes `this` as an argument. If `this` is statically known to be `Diagrams` we call `DiagrammedAssertionsMacro.assert` otherwise we call `AssertionsMacro.assert`. I will try it out.",
        "createdAt" : "2020-03-24T14:06:48Z",
        "updatedAt" : "2020-03-24T14:06:49Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      },
      {
        "id" : "ebfe9390-61e6-4e88-9082-f576258f9f56",
        "parentId" : "e99594ad-2241-41dc-b059-054445d36a83",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "Indeed it was simple #8601",
        "createdAt" : "2020-03-24T15:04:39Z",
        "updatedAt" : "2020-03-24T15:04:39Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      }
    ],
    "commit" : "453319bb133c74f49dfa2ec5752f0ac783a5dcb6",
    "line" : 29,
    "diffHunk" : "@@ -1,1 +168,172 @@The inlined invocations and the dynamically dispatched invocations give the same results.\n\n2. Inline methods can override or implement normal methods, as the previous example shows. Inline methods can be overridden only by other inline methods.\n\n3. Inline methods can also be abstract. An abstract inline method can be implemented only by other inline methods. It cannot be invoked directly:"
  },
  {
    "id" : "3c68d2f1-59c0-40d4-bb6d-68dbf6bd5449",
    "prId" : 8543,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/8543#pullrequestreview-380435115",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a1a3865c-b05b-4d8d-8b24-c3879b8e7c4a",
        "parentId" : null,
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "What are the use cases of this one?",
        "createdAt" : "2020-03-24T14:12:05Z",
        "updatedAt" : "2020-03-24T14:18:27Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      },
      {
        "id" : "e66fb780-a85b-44a0-9780-43e6aec4ff53",
        "parentId" : "a1a3865c-b05b-4d8d-8b24-c3879b8e7c4a",
        "authorId" : "5a9cd756-9120-4d5e-ac88-e9c636084f0e",
        "body" : "`typeclass-derivation2b.scala` seems to be the canonical example.",
        "createdAt" : "2020-03-24T15:39:08Z",
        "updatedAt" : "2020-03-24T15:39:08Z",
        "lastEditedBy" : "5a9cd756-9120-4d5e-ac88-e9c636084f0e",
        "tags" : [
        ]
      }
    ],
    "commit" : "453319bb133c74f49dfa2ec5752f0ac783a5dcb6",
    "line" : 31,
    "diffHunk" : "@@ -1,1 +170,174 @@2. Inline methods can override or implement normal methods, as the previous example shows. Inline methods can be overridden only by other inline methods.\n\n3. Inline methods can also be abstract. An abstract inline method can be implemented only by other inline methods. It cannot be invoked directly:\n```scala\nabstract class A {"
  },
  {
    "id" : "3395664d-1b1a-475f-9f25-d40112ad04e9",
    "prId" : 6261,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/6261#pullrequestreview-228718514",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "654bac26-8ed3-4fa4-bfd9-166711fcfab7",
        "parentId" : null,
        "authorId" : "98bdc06d-7937-462c-9d62-1f850e7819aa",
        "body" : "Maybe use the safer `val result = try op finally indent -= 1` idiom here.",
        "createdAt" : "2019-04-19T10:15:46Z",
        "updatedAt" : "2019-06-05T11:36:20Z",
        "lastEditedBy" : "98bdc06d-7937-462c-9d62-1f850e7819aa",
        "tags" : [
        ]
      },
      {
        "id" : "91ac0e85-0781-4f32-9f0c-7a3ba64e0780",
        "parentId" : "654bac26-8ed3-4fa4-bfd9-166711fcfab7",
        "authorId" : "37519144-0f9f-4b2b-85f7-34dde9be2e11",
        "body" : "I think it is sufficient for the exposition of inlining. I will keep this PR as a draft until the documentation starts shaping. For now it is a big TODO scratchpad.",
        "createdAt" : "2019-04-19T14:54:50Z",
        "updatedAt" : "2019-06-05T11:36:20Z",
        "lastEditedBy" : "37519144-0f9f-4b2b-85f7-34dde9be2e11",
        "tags" : [
        ]
      }
    ],
    "commit" : "c37dde7f264001c94485b9ddbe587af0ecbaf308",
    "line" : 24,
    "diffHunk" : "@@ -1,1 +22,26 @@      println(s\"${\"  \" * indent}start $msg\")\n      indent += 1\n      val result = op\n      indent -= 1\n      println(s\"${\"  \" * indent}$msg = $result\")"
  },
  {
    "id" : "10b7ae47-6667-4529-b1f3-0d7e8e342e01",
    "prId" : 6261,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/6261#pullrequestreview-244821889",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fb541580-b71c-491c-8196-1f0718920af2",
        "parentId" : null,
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "Add a small description",
        "createdAt" : "2019-06-03T12:10:47Z",
        "updatedAt" : "2019-06-05T11:36:20Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      }
    ],
    "commit" : "c37dde7f264001c94485b9ddbe587af0ecbaf308",
    "line" : 243,
    "diffHunk" : "@@ -1,1 +241,245 @@type `1`.\n\n```scala\ninline def zero() <: Int = 0\n"
  },
  {
    "id" : "6f14a6fb-2af6-47e4-9379-ca48c048a6e6",
    "prId" : 6261,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/6261#pullrequestreview-244821889",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3de8a477-792f-4df6-908b-56536d6e402f",
        "parentId" : null,
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "Add a sentence describing what is contained in `scala.compiletime`.",
        "createdAt" : "2019-06-03T12:18:02Z",
        "updatedAt" : "2019-06-05T11:36:20Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      }
    ],
    "commit" : "c37dde7f264001c94485b9ddbe587af0ecbaf308",
    "line" : 291,
    "diffHunk" : "@@ -1,1 +289,293 @@\n#### scala.compiletime._\n\nThis package contains helper definitions providing support for compile time\noperations over values."
  },
  {
    "id" : "8f911ba8-014e-4d9c-bc24-52d058392c6b",
    "prId" : 6261,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/6261#pullrequestreview-245398258",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d04eac38-295b-444d-9438-e8691bd93e4d",
        "parentId" : null,
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "Put `defaultValue` in another section before `erasedValue`. Describe what it does but do not show the implementation. You can keep this code as an example of how to use `erasedValue` to define `defaultValue`",
        "createdAt" : "2019-06-03T12:27:29Z",
        "updatedAt" : "2019-06-05T11:36:20Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      },
      {
        "id" : "6b79a410-7b71-4dcf-99fe-ad1a83374641",
        "parentId" : "d04eac38-295b-444d-9438-e8691bd93e4d",
        "authorId" : "37519144-0f9f-4b2b-85f7-34dde9be2e11",
        "body" : "`defaultValue` is merely an example, not part of the `compiletime` package. Does it deserve a section?",
        "createdAt" : "2019-06-04T11:59:28Z",
        "updatedAt" : "2019-06-05T11:36:20Z",
        "lastEditedBy" : "37519144-0f9f-4b2b-85f7-34dde9be2e11",
        "tags" : [
        ]
      }
    ],
    "commit" : "c37dde7f264001c94485b9ddbe587af0ecbaf308",
    "line" : 338,
    "diffHunk" : "@@ -1,1 +336,340 @@\n```scala\ninline def defaultValue[T] = inline erasedValue[T] match {\n  case _: Byte => Some(0: Byte)\n  case _: Char => Some(0: Char)"
  },
  {
    "id" : "62ca0388-6c2f-4adb-a6eb-c7270ab36bb6",
    "prId" : 6261,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/6261#pullrequestreview-244846708",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ffd19262-6e97-4c9a-bc74-2fe35c4c3392",
        "parentId" : null,
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "We should also mention `scala.compiletime.error`",
        "createdAt" : "2019-06-03T12:29:10Z",
        "updatedAt" : "2019-06-05T11:36:20Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      }
    ],
    "commit" : "c37dde7f264001c94485b9ddbe587af0ecbaf308",
    "line" : 290,
    "diffHunk" : "@@ -1,1 +288,292 @@`natTwo` is inferred to have the singleton type 2.\n\n#### scala.compiletime._\n\nThis package contains helper definitions providing support for compile time"
  }
]
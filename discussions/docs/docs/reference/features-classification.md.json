[
  {
    "id" : "dd04fe57-f5af-4506-b40d-76f7ff11c73e",
    "prId" : 10953,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/10953#pullrequestreview-560178165",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ff024539-5eb3-4af2-bcbd-4de950e334f2",
        "parentId" : null,
        "authorId" : "aac96502-7134-484b-914a-5f21bcc44a90",
        "body" : "Using Clauses --> Using clauses",
        "createdAt" : "2020-12-30T19:05:15Z",
        "updatedAt" : "2021-01-01T12:36:06Z",
        "lastEditedBy" : "aac96502-7134-484b-914a-5f21bcc44a90",
        "tags" : [
        ]
      },
      {
        "id" : "051744ec-9968-48ca-b19c-109506c9901f",
        "parentId" : "ff024539-5eb3-4af2-bcbd-4de950e334f2",
        "authorId" : "7f4dd8e1-6dc3-48f1-ac69-2bad57c15767",
        "body" : "> \r\n> \r\n> Using Clauses --> Using clauses\r\n\r\nDone ([6bc9dd0](https://github.com/lampepfl/dotty/pull/10953/commits/6bc9dd0)).",
        "createdAt" : "2020-12-30T19:40:34Z",
        "updatedAt" : "2021-01-01T12:36:06Z",
        "lastEditedBy" : "7f4dd8e1-6dc3-48f1-ac69-2bad57c15767",
        "tags" : [
        ]
      }
    ],
    "commit" : "d96b2a2a5567448e57eb3fa2e595694aac9d8af8",
    "line" : 9,
    "diffHunk" : "@@ -1,1 +38,42 @@ - [Given instances](contextual/givens.md)\n   replace implicit objects and defs, focussing on intent over mechanism.\n - [Using Clauses](contextual/using-clauses.md) replace implicit parameters, avoiding their ambiguities.\n - [Extension methods](contextual/extension-methods.md) replace implicit classes with a clearer and simpler mechanism.\n - [Opaque type aliases](other-new-features/opaques.md) replace most uses"
  },
  {
    "id" : "4cc19897-d52e-4448-bce1-7b7e768b0da0",
    "prId" : 6010,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/6010#pullrequestreview-209951249",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5e1ca6ce-349a-44ea-bc40-57b972966ea3",
        "parentId" : null,
        "authorId" : "d770f0e4-0c6d-4b32-b80c-37a9cabee830",
        "body" : "Maybe one approach to this would be:\r\n\r\n1. As stated, a tool that rewrites all inferred types to explicitly annotated types, but for both scala 2 and scala 3\r\n2. Use your VCS to record the result of running this both on Scala 2 and 3, and compare the results. Perhaps a merge tool with the right inputs would be a good way to streamline the process of reverting all identical added types, and highlighting the cases where they were not identical. For instance if you would have two branches where the first commit has the respective types and the next commit does not, it might find a conflict between a change A->C vs. B->C (where C is no explicit type, and A and B are the respective generated explicit type). On the other hand, wherever the generated types are the same, there would be no conflict and it would successfully apply the diff reverting to non-explicit types. Ideally this step would also be scripted, but it's probably just a few git commands.\r\n\r\nOf course, you would have to ensure that there aren't red herrings. For instance you might need to output dotty type intersections using `with`, and use the same logic for when to output types in infix format.\r\n\r\nI'm not sure enough of the mechanics of git merge conflicts, but this might simplify things a lot, at least for implementers.\r\n",
        "createdAt" : "2019-03-03T22:23:52Z",
        "updatedAt" : "2019-03-03T22:24:31Z",
        "lastEditedBy" : "d770f0e4-0c6d-4b32-b80c-37a9cabee830",
        "tags" : [
        ]
      },
      {
        "id" : "7b9b371a-2e94-46c2-9a7c-3db45cb9de80",
        "parentId" : "5e1ca6ce-349a-44ea-bc40-57b972966ea3",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "That's an interesting technique. I had not thought of using a merge conflicts to pinpoint problems.\r\n\r\nBtw I set out to write this document to have some data as a basis for replying to your post on Scala Contributors. I am now too tired to write a coherent reply, but will do so tomorrow.\r\n\r\n",
        "createdAt" : "2019-03-03T23:28:50Z",
        "updatedAt" : "2019-03-03T23:28:50Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "d160c224-236b-49b5-8dfd-2106f5ca588d",
        "parentId" : "5e1ca6ce-349a-44ea-bc40-57b972966ea3",
        "authorId" : "d770f0e4-0c6d-4b32-b80c-37a9cabee830",
        "body" : "Yeah I figured :grinning: \r\n\r\nIt's definitely appreciated!",
        "createdAt" : "2019-03-04T02:07:27Z",
        "updatedAt" : "2019-03-04T02:07:27Z",
        "lastEditedBy" : "d770f0e4-0c6d-4b32-b80c-37a9cabee830",
        "tags" : [
        ]
      }
    ],
    "commit" : "a9c49915e709a7790ce845e564c1ec1ec37627af",
    "line" : 202,
    "diffHunk" : "@@ -1,1 +200,204 @@In our experience, macros and changes in type and implicit argument inference together cause the large majority of problems encountered when porting existing code to Scala 3. The latter source of problems could be addressed systematically by a tool that added all inferred types and implicit arguments to a Scala 2 source code file. Most likely such a tool would be implemented as a Scala 2 compiler plugin. The resulting code would have a greatly increased likelihood to compile under Scala 3, but would often be bulky to the point of being unreadable. A second part of the rewriting tool should then selectively and iteratively remove type and implicit annotations that were synthesized by the first part as long as they compile under Scala 3. This second part could be implemented as a program that invokes the Scala 3 compiler `dotc` programmatically.\n\nSeveral people have proposed such a tool for some time now. I believe it is time we find the will and the resources to actually implement it."
  },
  {
    "id" : "da4917e2-de1b-4cc2-b185-721d1cd66cb8",
    "prId" : 6010,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/6010#pullrequestreview-209932272",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "604e4f17-fe8c-4479-8a7d-e36b7949d6a2",
        "parentId" : null,
        "authorId" : "6afe87c6-578a-428e-9a08-5dcb1f0353d7",
        "body" : "It looks like it's now eight feature groups, not seven since \"Changes to Type Checking and Inference\" is included.",
        "createdAt" : "2019-03-03T22:37:51Z",
        "updatedAt" : "2019-03-03T22:44:20Z",
        "lastEditedBy" : "6afe87c6-578a-428e-9a08-5dcb1f0353d7",
        "tags" : [
        ]
      }
    ],
    "commit" : "a9c49915e709a7790ce845e564c1ec1ec37627af",
    "line" : 8,
    "diffHunk" : "@@ -1,1 +6,10 @@---\n\nThis document provides an overview of the features proposed for Scala 3 with the aim to facilitate the discussion what to include and when to include it. It classifies features into seven groups: Essential foundations, simplifications, restrictions, dropped features, changed features, new features, and features oriented towards meta-programming with the aim to replace existing macros.\n\nEach feature group contains sections classifying the status (i.e. relative importance to be a part of Scala 3, and relative urgency when to decide this) and the migration cost"
  }
]
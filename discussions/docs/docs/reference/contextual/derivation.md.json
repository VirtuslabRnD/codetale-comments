[
  {
    "id" : "ab860362-5308-440f-b80f-48b582ad4b28",
    "prId" : 10878,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/10878#pullrequestreview-557252212",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "00f61b6d-b58c-46e2-b2b4-855e4c30b1c1",
        "parentId" : null,
        "authorId" : "6998ebc0-40b8-4e52-b4f8-721fd5d8c0a9",
        "body" : "I am confused. Didn't you use `with` for the refinement of `new Vehicle with ...` above?",
        "createdAt" : "2020-12-22T09:48:04Z",
        "updatedAt" : "2020-12-23T10:05:58Z",
        "lastEditedBy" : "6998ebc0-40b8-4e52-b4f8-721fd5d8c0a9",
        "tags" : [
        ]
      },
      {
        "id" : "52bf1df7-e73e-44ab-82d9-d6465643872f",
        "parentId" : "00f61b6d-b58c-46e2-b2b4-855e4c30b1c1",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "That was an error. I used `with` first and then added a commit to change to `:` which is the currently supported syntax (and it might stay that way, we have not decided yet). But the `new Vehicle` line escaped by regex search since the `with` was followed by a comment.\r\n",
        "createdAt" : "2020-12-22T17:41:59Z",
        "updatedAt" : "2020-12-23T10:05:58Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "d313f17e197421e5fd05911744b68d9580863e80",
    "line" : 299,
    "diffHunk" : "@@ -1,1 +256,260 @@   def eqSum[T](s: Mirror.SumOf[T], elems: => List[Eq[_]]): Eq[T] =\n      new Eq[T]:\n         def eqv(x: T, y: T): Boolean =\n            val ordx = s.ordinal(x)\n            (s.ordinal(y) == ordx) && check(elems(ordx))(x, y)"
  },
  {
    "id" : "7abe66f1-f6ff-4f51-a5b6-444a4887e3ce",
    "prId" : 10635,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/10635#pullrequestreview-544917755",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f9e4fddc-e83d-4f08-aaa7-90cbfd7c19a9",
        "parentId" : null,
        "authorId" : "6998ebc0-40b8-4e52-b4f8-721fd5d8c0a9",
        "body" : "Will the `with` form be deprecated? Should we say something about which form is recommended?",
        "createdAt" : "2020-12-04T12:31:18Z",
        "updatedAt" : "2020-12-04T12:31:18Z",
        "lastEditedBy" : "6998ebc0-40b8-4e52-b4f8-721fd5d8c0a9",
        "tags" : [
        ]
      }
    ],
    "commit" : "b6a1a3d71f923d5f31b74efeeb44bfbd8c8e11d6",
    "line" : 12,
    "diffHunk" : "@@ -1,1 +380,384 @@```\nclass A extends B with C { ... }\n```\n\n### Discussion"
  },
  {
    "id" : "83150868-878c-4156-a778-554f330eeb4c",
    "prId" : 8483,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/8483#pullrequestreview-372073285",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7db2d892-687e-4c8b-81a5-7762b4918e59",
        "parentId" : null,
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "I think the first `summonAll` should be deleted, since otherwise we would get a double definition error. The second `summonAll` alone is fine.\r\n",
        "createdAt" : "2020-03-10T09:51:17Z",
        "updatedAt" : "2020-03-10T10:27:25Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "72197d45-4ce3-488b-80f0-45fac1c4bc86",
        "parentId" : "7db2d892-687e-4c8b-81a5-7762b4918e59",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "Done",
        "createdAt" : "2020-03-10T15:39:26Z",
        "updatedAt" : "2020-03-10T15:39:26Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      }
    ],
    "commit" : "e5e0f9ba39dfd2f8e69bef2252f1b5825de2a8ed",
    "line" : 25,
    "diffHunk" : "@@ -1,1 +202,206 @@inline def summonAll[T <: Tuple]: List[Eq[_]] = inline erasedValue[T] match {\n  case _: Unit => Nil\n  case _: (t *: ts) => summonInline[Eq[t]] :: summonAll[ts]\n}\n```"
  },
  {
    "id" : "239ee7c0-4081-4fde-989d-45f76a202873",
    "prId" : 7063,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/7063#pullrequestreview-276422414",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "708feb03-bea4-4cd0-ac19-503f02497529",
        "parentId" : null,
        "authorId" : "6d71bb21-e402-4464-b2b1-8bdd8e068461",
        "body" : "`}`",
        "createdAt" : "2019-08-19T08:58:25Z",
        "updatedAt" : "2019-08-20T10:50:45Z",
        "lastEditedBy" : "6d71bb21-e402-4464-b2b1-8bdd8e068461",
        "tags" : [
        ]
      }
    ],
    "commit" : "0dda15c955ebce031176d84d45abb1dc3d2056ee",
    "line" : 173,
    "diffHunk" : "@@ -1,1 +116,120 @@\n  def fromProduct(p: Product): MirroredMonoType =\n    new Leaf(...)\n}\n```"
  },
  {
    "id" : "7f126fb1-c875-47c6-97bb-c1f8f24b4e4e",
    "prId" : 7063,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/7063#pullrequestreview-276422414",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4d268cb6-dd66-48f0-9b83-73011819bc74",
        "parentId" : null,
        "authorId" : "6d71bb21-e402-4464-b2b1-8bdd8e068461",
        "body" : "`}`",
        "createdAt" : "2019-08-19T08:58:35Z",
        "updatedAt" : "2019-08-20T10:50:45Z",
        "lastEditedBy" : "6d71bb21-e402-4464-b2b1-8bdd8e068461",
        "tags" : [
        ]
      }
    ],
    "commit" : "0dda15c955ebce031176d84d45abb1dc3d2056ee",
    "line" : 159,
    "diffHunk" : "@@ -1,1 +104,108 @@\n  def fromProduct(p: Product): MirroredMonoType =\n    new Branch(...)\n}\n"
  },
  {
    "id" : "a8dc3029-824d-470c-b9e5-c394755c1c98",
    "prId" : 7063,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/7063#pullrequestreview-276526351",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d3f9d5ae-9e57-4c31-9431-16ab38e4e054",
        "parentId" : null,
        "authorId" : "6d71bb21-e402-4464-b2b1-8bdd8e068461",
        "body" : "What about `Mirror.Singleton`?",
        "createdAt" : "2019-08-19T08:59:18Z",
        "updatedAt" : "2019-08-20T10:50:45Z",
        "lastEditedBy" : "6d71bb21-e402-4464-b2b1-8bdd8e068461",
        "tags" : [
        ]
      },
      {
        "id" : "4dffbc9a-24d1-41eb-aa96-aec1cd215aae",
        "parentId" : "d3f9d5ae-9e57-4c31-9431-16ab38e4e054",
        "authorId" : "2c02aea2-3019-42f4-9678-8a2da637c660",
        "body" : "It's a subtype of `Mirror.Product` and largely an implementation detail. I'm not saying it shouldn't be documented, but I don't think I'd want to highlight it either.",
        "createdAt" : "2019-08-19T12:35:04Z",
        "updatedAt" : "2019-08-20T10:50:45Z",
        "lastEditedBy" : "2c02aea2-3019-42f4-9678-8a2da637c660",
        "tags" : [
        ]
      }
    ],
    "commit" : "0dda15c955ebce031176d84d45abb1dc3d2056ee",
    "line" : 124,
    "diffHunk" : "@@ -1,1 +75,79 @@```\n\nProduct types (ie. case classes and objects, and enum cases) have mirrors which are subtypes of `Mirror.Product`. Sum\ntypes (ie. sealed class or traits with product children, and enums) have mirrors which are subtypes of `Mirror.Sum`.\n"
  },
  {
    "id" : "1ebce059-f6ca-46d5-8891-74a22f5d8412",
    "prId" : 7063,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/7063#pullrequestreview-276785432",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b6330730-3bac-4c95-9626-d3c9f476c7f3",
        "parentId" : null,
        "authorId" : "6d71bb21-e402-4464-b2b1-8bdd8e068461",
        "body" : "Is it \"typeclass\" or \"type class\"? The spelling is inconsistent in this file, starting from the title.",
        "createdAt" : "2019-08-19T09:07:12Z",
        "updatedAt" : "2019-08-20T10:50:45Z",
        "lastEditedBy" : "6d71bb21-e402-4464-b2b1-8bdd8e068461",
        "tags" : [
        ]
      },
      {
        "id" : "67cd9733-013f-4024-9013-be8dad4e8940",
        "parentId" : "b6330730-3bac-4c95-9626-d3c9f476c7f3",
        "authorId" : "2c02aea2-3019-42f4-9678-8a2da637c660",
        "body" : "It's \"type class\". I'll check for misspellings and correct.",
        "createdAt" : "2019-08-19T12:33:08Z",
        "updatedAt" : "2019-08-20T10:50:45Z",
        "lastEditedBy" : "2c02aea2-3019-42f4-9678-8a2da637c660",
        "tags" : [
        ]
      },
      {
        "id" : "387bfe03-8542-4508-b98c-db7be3c9313c",
        "parentId" : "b6330730-3bac-4c95-9626-d3c9f476c7f3",
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "I don't want to start a debate but I'm curious, why \"type class\" and not \"typeclass\" ? :) I like the latter because it makes it slightly less likely that beginners would confuse them with the notion of class in Scala.",
        "createdAt" : "2019-08-19T12:50:27Z",
        "updatedAt" : "2019-08-20T10:50:45Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "e601a3aa-cf4a-4034-a710-32b25a553b53",
        "parentId" : "b6330730-3bac-4c95-9626-d3c9f476c7f3",
        "authorId" : "2c02aea2-3019-42f4-9678-8a2da637c660",
        "body" : "The canonical references all use \"type class\": https://homepages.inf.ed.ac.uk/wadler/topics/type-classes.html. It's conventional, rather than something which is either right or wrong. I prefer to go with Wadler, but reasonable people might disagree.",
        "createdAt" : "2019-08-19T13:00:01Z",
        "updatedAt" : "2019-08-20T10:50:45Z",
        "lastEditedBy" : "2c02aea2-3019-42f4-9678-8a2da637c660",
        "tags" : [
        ]
      },
      {
        "id" : "23b3ece8-6e19-4b7b-bea1-8d197ad2b607",
        "parentId" : "b6330730-3bac-4c95-9626-d3c9f476c7f3",
        "authorId" : "f7c6b5d4-6d93-4f3d-b583-a110d7a49c7d",
        "body" : "Whichever you choose the title should be updated to match.",
        "createdAt" : "2019-08-19T13:04:33Z",
        "updatedAt" : "2019-08-20T10:50:45Z",
        "lastEditedBy" : "f7c6b5d4-6d93-4f3d-b583-a110d7a49c7d",
        "tags" : [
        ]
      },
      {
        "id" : "940a52d9-0781-4888-8764-f302d6d43c1b",
        "parentId" : "b6330730-3bac-4c95-9626-d3c9f476c7f3",
        "authorId" : "53485215-03aa-4d74-ba31-aed86ff672b3",
        "body" : "Opinion from the peanut gallery: I tend to see \"typeclass\" more often nowadays (and use it that way myself).\r\n\r\nIMO, the single-word form is gradually becoming fairly standard jargon.  But as you say, there's plenty of room for reasonable disagreement.",
        "createdAt" : "2019-08-19T20:07:09Z",
        "updatedAt" : "2019-08-20T10:50:45Z",
        "lastEditedBy" : "53485215-03aa-4d74-ba31-aed86ff672b3",
        "tags" : [
        ]
      }
    ],
    "commit" : "0dda15c955ebce031176d84d45abb1dc3d2056ee",
    "line" : 8,
    "diffHunk" : "@@ -1,1 +4,8 @@---\n\nType class derivation is a way to automatically generate given instances for type classes which satisfy some simple\nconditions. A type class in this sense is any trait or class with a type parameter determining the type being operated\non. Common examples are `Eq`, `Ordering`, or `Show`. For example, given the following `Tree` algebraic data type"
  },
  {
    "id" : "ef6e4adc-1e69-4351-adc3-1df2d000f011",
    "prId" : 7063,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/7063#pullrequestreview-277133146",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "49abc149-ebec-46e6-80ef-78de8b9a3fcc",
        "parentId" : null,
        "authorId" : "4107dafe-4e7b-4e85-8d5b-63e06e0e6318",
        "body" : "~~~suggestion\r\n    type MirroredElemTypes\r\n~~~",
        "createdAt" : "2019-08-20T12:37:45Z",
        "updatedAt" : "2019-08-20T12:37:45Z",
        "lastEditedBy" : "4107dafe-4e7b-4e85-8d5b-63e06e0e6318",
        "tags" : [
        ]
      }
    ],
    "commit" : "0dda15c955ebce031176d84d45abb1dc3d2056ee",
    "line" : 83,
    "diffHunk" : "@@ -1,1 +48,52 @@ \n    /** the type of the elements of the mirrored type */\n    type MirroedElemTypes\n\n    /** The mirrored *-type */"
  },
  {
    "id" : "6acfbeba-dc84-4c47-a366-71c01948ff0e",
    "prId" : 7063,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/7063#pullrequestreview-277134469",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9a9956b8-6266-4309-8dc8-db746f8de0a7",
        "parentId" : null,
        "authorId" : "4107dafe-4e7b-4e85-8d5b-63e06e0e6318",
        "body" : "~~~ suggestion\r\n    trait Sum extends Mirror {\r\n~~~",
        "createdAt" : "2019-08-20T12:40:09Z",
        "updatedAt" : "2019-08-20T12:40:09Z",
        "lastEditedBy" : "4107dafe-4e7b-4e85-8d5b-63e06e0e6318",
        "tags" : [
        ]
      }
    ],
    "commit" : "0dda15c955ebce031176d84d45abb1dc3d2056ee",
    "line" : 114,
    "diffHunk" : "@@ -1,1 +68,72 @@    }\n\n    trait Sum extends Mirror { self =>\n      /** The ordinal number of the case class of `x`. For enums, `ordinal(x) == x.ordinal` */\n      def ordinal(x: MirroredMonoType): Int"
  },
  {
    "id" : "43d153e3-fc5b-4510-8e91-06f7b2140f04",
    "prId" : 7063,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/7063#pullrequestreview-277191425",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "26512ec2-b864-4d1f-8c3c-5eb2690a56e3",
        "parentId" : null,
        "authorId" : "4107dafe-4e7b-4e85-8d5b-63e06e0e6318",
        "body" : "I’m confused that `MirroredElemTypes` now takes a type parameter, even though in the definition of `Mirror` it is *-kinded. Is this valid?",
        "createdAt" : "2019-08-20T12:51:50Z",
        "updatedAt" : "2019-08-20T12:52:12Z",
        "lastEditedBy" : "4107dafe-4e7b-4e85-8d5b-63e06e0e6318",
        "tags" : [
        ]
      },
      {
        "id" : "2e33d232-cf7d-48d4-aafb-f492a3889a01",
        "parentId" : "26512ec2-b864-4d1f-8c3c-5eb2690a56e3",
        "authorId" : "2c02aea2-3019-42f4-9678-8a2da637c660",
        "body" : "`MirroredElemTypes` is defined in subtypes of `Mirror` where the appropriate kind is known. The definition I showed as a member of `Mirror` is illustrative rather than actual ... I guess I should at least mention this at that point, but I didn't want to complicate things. One option would be to define these types in `Mirror` with an `AnyKind` bound ... do you think that would be preferable to deferring the definitions?",
        "createdAt" : "2019-08-20T13:42:37Z",
        "updatedAt" : "2019-08-20T13:42:37Z",
        "lastEditedBy" : "2c02aea2-3019-42f4-9678-8a2da637c660",
        "tags" : [
        ]
      },
      {
        "id" : "989a7b03-2a13-4102-a43c-f1bd8e78fd20",
        "parentId" : "26512ec2-b864-4d1f-8c3c-5eb2690a56e3",
        "authorId" : "4107dafe-4e7b-4e85-8d5b-63e06e0e6318",
        "body" : "> One option would be to define these types in `Mirror` with an `AnyKind` bound ... do you think that would be preferable to deferring the definitions?\r\n\r\nMaybe it’s not needed. Your explanation made it clear. We can probably just add somewhere that the shown `Mirror` definition is not the actual one, but a simplified version.",
        "createdAt" : "2019-08-20T14:05:30Z",
        "updatedAt" : "2019-08-20T14:05:30Z",
        "lastEditedBy" : "4107dafe-4e7b-4e85-8d5b-63e06e0e6318",
        "tags" : [
        ]
      }
    ],
    "commit" : "0dda15c955ebce031176d84d45abb1dc3d2056ee",
    "line" : 136,
    "diffHunk" : "@@ -1,1 +84,88 @@Mirror.Sum {\n  type MirroredType = Tree\n  type MirroredElemTypes[T] = (Branch[T], Leaf[T])\n  type MirroredMonoType = Tree[_]\n  type MirroredLabels = \"Tree\""
  },
  {
    "id" : "fe76c3fb-4c94-4e72-9885-3e14aa6226fd",
    "prId" : 7063,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/7063#pullrequestreview-277195362",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c93a334f-df1f-45b4-81d6-20a3c5e8eacf",
        "parentId" : null,
        "authorId" : "4107dafe-4e7b-4e85-8d5b-63e06e0e6318",
        "body" : "~~~ suggestion\r\nresolved at compile-time and only the right-hand side of the matching case will be inlined into the generated code with\r\n~~~",
        "createdAt" : "2019-08-20T14:10:59Z",
        "updatedAt" : "2019-08-20T14:10:59Z",
        "lastEditedBy" : "4107dafe-4e7b-4e85-8d5b-63e06e0e6318",
        "tags" : [
        ]
      }
    ],
    "commit" : "0dda15c955ebce031176d84d45abb1dc3d2056ee",
    "line" : 317,
    "diffHunk" : "@@ -1,1 +207,211 @@with the instances for children in hand the `derived` method uses an `inline match` to dispatch to methods which can\nconstruct instances for either sums or products (2). Note that because `derived` is `inline` the match will be\nresolved at compile-time and only the left-hand side of the matching case will be inlined into the generated code with\ntypes refined as revealed by the match.\n"
  }
]
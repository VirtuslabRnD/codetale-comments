[
  {
    "id" : "ed55f689-b0b6-447f-bb8b-327cf70da2a8",
    "prId" : 8147,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/8147#pullrequestreview-365657335",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1d7572b4-e6a5-440b-b89d-b0deb55f05cd",
        "parentId" : null,
        "authorId" : "128563de-a925-4397-af34-450c7978a8d2",
        "body" : "I think this part about comparing to OOP could be moved to the start",
        "createdAt" : "2020-02-27T12:56:49Z",
        "updatedAt" : "2020-03-30T16:14:21Z",
        "lastEditedBy" : "128563de-a925-4397-af34-450c7978a8d2",
        "tags" : [
        ]
      }
    ],
    "commit" : "219bc3c3058f5ded0e5f5c64d4f6f6fd8eb7a307",
    "line" : 289,
    "diffHunk" : "@@ -1,1 +274,278 @@The definition of a _typeclass_ is expressed via a parameterised type with abstract members, such as a `trait`.\nThe main difference between object oriented polymorphism, and ad-hoc polymorphism with _typeclasses_, is how the definition of the _typeclass_ is implemented, in relation to the type it acts upon.\nIn the case of a _typeclass_, its implementation for a concrete type is expressed through a `given` term definition, which is supplied as an implicit argument alongside the value it acts upon. With object oriented polymorphism, the implementation is mixed into the parents of a class, and only a single term is required to perform a polymorphic operation.\n\nTo conclude, in addition to given instances, other constructs like extension methods, context bounds and type lambdas allow a concise and natural expression of _typeclasses_."
  }
]
[
  {
    "id" : "0e93461b-1e48-4d0e-ad54-ef7a7263c1cb",
    "prId" : 5371,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/5371#pullrequestreview-173051408",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d82a8911-693e-44d2-87b2-fb9d9f4b2baf",
        "parentId" : null,
        "authorId" : "5a9cd756-9120-4d5e-ac88-e9c636084f0e",
        "body" : "Why was this changed back from `AnyVal` to `Char`? Didn't we agree that `Char`s should never be considered as numeric types for the purpose of harmonization?",
        "createdAt" : "2018-11-05T10:07:31Z",
        "updatedAt" : "2018-11-09T16:19:07Z",
        "lastEditedBy" : "5a9cd756-9120-4d5e-ac88-e9c636084f0e",
        "tags" : [
        ]
      },
      {
        "id" : "4f541da0-f2db-40e9-99de-a47983b479d0",
        "parentId" : "d82a8911-693e-44d2-87b2-fb9d9f4b2baf",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "I thought we agreed that a Char literal should not be converted to another numeric type, same as a Float or a Double is not converted. \r\n\r\nBut this case is different: It's an Int constant that is converted to a Char type. Same as it could be converted to a Short or Byte type. I agree that Char feels strange, but the fact is it is a member of Java's numeric hierarchy, so I believe it's better to be consistent.\r\n\r\nWe do allow:\r\n```\r\nscala> val c: Char = 65\r\nc: Char = A\r\n```\r\nSo it's inconsistent to not also allow this in harmonization.",
        "createdAt" : "2018-11-08T14:45:24Z",
        "updatedAt" : "2018-11-09T16:19:07Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "bad5222e-3086-438d-b18a-0c44208dbe1b",
        "parentId" : "d82a8911-693e-44d2-87b2-fb9d9f4b2baf",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "I see now that `Char` is not in the spec. \r\n\r\n> if all the other expressions have the same numeric type `T` (which can be one of `Byte`, `Short`, `Int`, `Long`, `Float`, `Double`)\r\n\r\nSomehow I overlooked this before. So we'd either have to put `Char` back in the spec, or change the implementation to not convert to `Char`. At this stage it's all the same for me. Consistency with assignment is nice to have but if people feel strongly agaist I won't argue any longer.",
        "createdAt" : "2018-11-08T16:27:26Z",
        "updatedAt" : "2018-11-09T16:19:07Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "c13aa580943c0cfd4ddebfdb66809d702344dcbb",
    "line" : 41,
    "diffHunk" : "@@ -1,1 +43,47 @@    Array(1.0f, 2)         : Array[Float]\n    Array(1.0f, 1234567890): Array[AnyVal] // loss of precision\n    Array(b, 33, 'a')      : Array[Char]\n    Array(5.toByte, 11)    : Array[Byte]"
  },
  {
    "id" : "bfc26e24-2a0a-4b43-9334-975e152793f4",
    "prId" : 5358,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/5358#pullrequestreview-172966783",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b46ed9c7-1ba2-4b0d-8dac-9875cacb9b43",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "I just realized that in the spec, the definition of numeric widening depends on the definition of weak conformance, from https://www.scala-lang.org/files/archive/spec/2.12/06-expressions.html:\r\n> If e has a primitive number type which weakly conforms to the expected type, it is widened to the expected type using one of the numeric conversion methods toShort, toChar, toInt, toLong, toFloat, toDouble defined here.\r\n\r\nSo we'll need to rewrite that definition (relatedly, I'm also trying to restrict what numeric widening can do in https://github.com/scala/scala/pull/7405)",
        "createdAt" : "2018-11-08T13:37:19Z",
        "updatedAt" : "2018-11-08T13:37:19Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "663caff6-5eeb-4e86-a513-99202ff2657b",
        "parentId" : "b46ed9c7-1ba2-4b0d-8dac-9875cacb9b43",
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Actually it seems that we simply don't have any notion of numeric widening in Dotty, we just rely on the implicit conversions defined in Int.scala/Float.scala/etc",
        "createdAt" : "2018-11-08T13:56:51Z",
        "updatedAt" : "2018-11-08T13:56:51Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      }
    ],
    "commit" : "ca413d3cfa6918663bb7c6efa2f47042f952bc5e",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +5,9 @@\nTo simplify the underlying type theory, Dotty drops the notion of weak\nconformance altogether. Instead, it provides more flexibility when\nassigning a type to a constant expression. The new rule is:\n"
  },
  {
    "id" : "63481798-ff10-43c5-8a37-fa23eacc4d76",
    "prId" : 5358,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/5358#pullrequestreview-197490376",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7ba07557-313a-49c9-b186-4b3e251b1ac9",
        "parentId" : null,
        "authorId" : "5f907c64-1898-4d74-945b-1f630a7406b9",
        "body" : "I think it would be good if this rule declared its name, which I think is \"harmonize\" (and also known as \"new weak conformance\").",
        "createdAt" : "2019-01-29T10:55:55Z",
        "updatedAt" : "2019-01-29T10:55:56Z",
        "lastEditedBy" : "5f907c64-1898-4d74-945b-1f630a7406b9",
        "tags" : [
        ]
      }
    ],
    "commit" : "ca413d3cfa6918663bb7c6efa2f47042f952bc5e",
    "line" : 8,
    "diffHunk" : "@@ -1,1 +6,10 @@To simplify the underlying type theory, Dotty drops the notion of weak\nconformance altogether. Instead, it provides more flexibility when\nassigning a type to a constant expression. The new rule is:\n\n - If a list of expressions `Es` appears as one of"
  }
]
[
  {
    "id" : "74687606-7019-49e9-afdf-ae42ea8bc8dc",
    "prId" : 8024,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/8024#pullrequestreview-345207321",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d11446c2-4523-4a79-b204-23f049a58d9f",
        "parentId" : null,
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "This is hard to review since so much information got dropped. I realize that the current exposition is too detailed and dense for an intro. I suggest we split the page into two, one with an intro and the other with more details. But it's important to not simply drop a detail that's given unless that detail is no longer correct. I'd also add a commit message for anything that was dropped with the reason why it was dropped.",
        "createdAt" : "2020-01-20T10:39:54Z",
        "updatedAt" : "2020-04-09T15:00:57Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "60cfa2dc34016cd0b11f432d7add5b96cf532cbe",
    "line" : 1,
    "diffHunk" : "@@ -1,1 +1,5 @@---\nlayout: doc-page\ntitle: \"Match Types\"\n---\n"
  },
  {
    "id" : "f0185e87-2c0b-4759-b561-449d5a921d71",
    "prId" : 8024,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/8024#pullrequestreview-391019799",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f04c9f37-a5a2-4442-a91e-4e8d36967fd2",
        "parentId" : null,
        "authorId" : "98bdc06d-7937-462c-9d62-1f850e7819aa",
        "body" : "@OlivierBlanvillain this formulation does not make any sense to me.\r\n\r\nI think you wanted to say something along the lines of:\r\n\r\n> The type `S` and each type `Ci` occur positively in match type `Match(S, Cs) <: B` â€” i.e., the match type is covariant in `S` and `Ci`.\r\n\r\nFurthermore, I imagine that the match type is _contravariant_ in `B` , right?",
        "createdAt" : "2020-04-06T15:35:11Z",
        "updatedAt" : "2020-04-09T15:00:57Z",
        "lastEditedBy" : "98bdc06d-7937-462c-9d62-1f850e7819aa",
        "tags" : [
        ]
      },
      {
        "id" : "e2c45e65-b546-418d-990a-0147990f8614",
        "parentId" : "f04c9f37-a5a2-4442-a91e-4e8d36967fd2",
        "authorId" : "6d71bb21-e402-4464-b2b1-8bdd8e068461",
        "body" : "This paragraph was not modified by PR, not sure why it shows up in the overall diff... But it appears to be outdated, so thanks for pointing it out!\r\n\r\n> Furthermore, I imagine that the match type is contravariant in B , right?\r\n\r\nThe bound isn't used when doing subtyping between two match types, so `Match(S, Cs) <: B1` is `=:=` to `Match(S, Cs) <: B2` forall `B1`, `B2`",
        "createdAt" : "2020-04-07T13:10:49Z",
        "updatedAt" : "2020-04-09T15:00:57Z",
        "lastEditedBy" : "6d71bb21-e402-4464-b2b1-8bdd8e068461",
        "tags" : [
        ]
      },
      {
        "id" : "ff8101bc-3241-44a0-813f-b92764622142",
        "parentId" : "f04c9f37-a5a2-4442-a91e-4e8d36967fd2",
        "authorId" : "98bdc06d-7937-462c-9d62-1f850e7819aa",
        "body" : "Sure!\r\n\r\n> The bound isn't used when doing subtyping between two match types\r\n\r\nIt still needs to be considered during variance checks, no? Otherwise I think it could lead to unsoundness.",
        "createdAt" : "2020-04-07T17:06:38Z",
        "updatedAt" : "2020-04-09T15:00:57Z",
        "lastEditedBy" : "98bdc06d-7937-462c-9d62-1f850e7819aa",
        "tags" : [
        ]
      },
      {
        "id" : "19d585e9-ad33-4a0a-b811-bfd32cf77491",
        "parentId" : "f04c9f37-a5a2-4442-a91e-4e8d36967fd2",
        "authorId" : "6d71bb21-e402-4464-b2b1-8bdd8e068461",
        "body" : "I don't see how, do you have an example?",
        "createdAt" : "2020-04-09T15:00:43Z",
        "updatedAt" : "2020-04-09T15:00:57Z",
        "lastEditedBy" : "6d71bb21-e402-4464-b2b1-8bdd8e068461",
        "tags" : [
        ]
      },
      {
        "id" : "b46d3533-078f-4ebe-ad56-2f5ccc92acb0",
        "parentId" : "f04c9f37-a5a2-4442-a91e-4e8d36967fd2",
        "authorId" : "98bdc06d-7937-462c-9d62-1f850e7819aa",
        "body" : "I think I could come up with examples, but there does not seem to be an easy way to get a type with mismatched variance into the bound of a match type, at least from user code:\r\n\r\n```scala\r\nscala> class C[+T] { type A[X] <: T = X match { case Int => Nothing } }\r\n1 |class C[+T] { type A[X] <: T = X match { case Int => Nothing } }\r\n  |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  |              covariant type T occurs in invariant position in type [X] =\r\n  |                X match {\r\n  |                  case Int => Nothing\r\n  |                } <: T of type A\r\n```\r\n\r\nIs there any other way for match type bounds to get picked up, other than by using and upper bound on an abstract type? If not, then I guess there is no soundness problem. But I'd be wary of corner cases.\r\n\r\nPS: weirdly, this one works:\r\n\r\n```scala\r\nclass C[+T] { type A[X] <: T = X match { case _ => Nothing } }\r\n```",
        "createdAt" : "2020-04-09T18:03:14Z",
        "updatedAt" : "2020-04-09T18:04:32Z",
        "lastEditedBy" : "98bdc06d-7937-462c-9d62-1f850e7819aa",
        "tags" : [
        ]
      },
      {
        "id" : "ae42d402-7e0f-4a35-8732-04a09bfc6f64",
        "parentId" : "f04c9f37-a5a2-4442-a91e-4e8d36967fd2",
        "authorId" : "6d71bb21-e402-4464-b2b1-8bdd8e068461",
        "body" : "> Is there any other way for match type bounds to get picked up, other than by using and upper bound on an abstract type?\r\n\r\nNo, that's the only syntax we have (which is kind of limiting, for example there is no way to specify bounds of nested match types).",
        "createdAt" : "2020-04-09T18:08:01Z",
        "updatedAt" : "2020-04-09T18:08:02Z",
        "lastEditedBy" : "6d71bb21-e402-4464-b2b1-8bdd8e068461",
        "tags" : [
        ]
      },
      {
        "id" : "d6bbd6a8-6d89-4a88-bf39-136c5d9c6674",
        "parentId" : "f04c9f37-a5a2-4442-a91e-4e8d36967fd2",
        "authorId" : "98bdc06d-7937-462c-9d62-1f850e7819aa",
        "body" : "Well, of you ever add a first-class syntax for match type bounds, you should remember to check their variance too :^P",
        "createdAt" : "2020-04-09T18:10:20Z",
        "updatedAt" : "2020-04-09T18:10:20Z",
        "lastEditedBy" : "98bdc06d-7937-462c-9d62-1f850e7819aa",
        "tags" : [
        ]
      }
    ],
    "commit" : "60cfa2dc34016cd0b11f432d7add5b96cf532cbe",
    "line" : 306,
    "diffHunk" : "@@ -1,1 +184,188 @@## Variance Laws for Match Types\n\nWithin a match type `Match(S, Cs) <: B`, all occurrences of type variables count as covariant. By the nature of the cases `Ci` this means that occurrences in pattern position are contravarant (since patterns are represented as function type arguments).\n\n## Related Work"
  }
]
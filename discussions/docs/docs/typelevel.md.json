[
  {
    "id" : "16c7df26-06c5-4adc-aab0-ede5298756fe",
    "prId" : 4616,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/4616#pullrequestreview-134945600",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1ad4110e-ed51-43a4-9059-6c8f21ae488b",
        "parentId" : null,
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "The restriction on `top-level` constructs in reduction seems to be ad-hoc. Why we have need the restriction? Why not for constructs that are nested in an anonymous class, blocks or anonymous functions?",
        "createdAt" : "2018-07-05T13:48:33Z",
        "updatedAt" : "2018-07-26T14:54:44Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "2f3045ff-94cd-4ba7-b196-f876b88ea517",
        "parentId" : "1ad4110e-ed51-43a4-9059-6c8f21ae488b",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "The restriction is there to prevent infinite recursion in inlining. If we cannot simplify a toplevel match of a recursive transparent function, we will inline the recursive call again _ad infinitum_.",
        "createdAt" : "2018-07-06T09:26:00Z",
        "updatedAt" : "2018-07-26T14:54:44Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "88e7d180574eda8a71037d1735ac6a3ff76a1c08",
    "line" : 88,
    "diffHunk" : "@@ -1,1 +86,90 @@locally { ... }\n```\nblock, which de-classifies it as a top-level expression. (`locally` is a function in `Predef` which simply returns its argument.)\n\nAs another example, consider the following two functions over tuples:"
  },
  {
    "id" : "214823a6-5ad0-44ae-8a04-136eebfa1ed2",
    "prId" : 4616,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/4616#pullrequestreview-134946046",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c283be3f-dffa-4666-a476-c7bc3603a25c",
        "parentId" : null,
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "`erased` here seems to suggest that we need something like __transparent types__ as experimented in #4727 , which can express computations on types.\r\n",
        "createdAt" : "2018-07-05T16:23:56Z",
        "updatedAt" : "2018-07-26T14:54:44Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "a4102283-2be6-47bf-b0b3-589f09ae4edf",
        "parentId" : "c283be3f-dffa-4666-a476-c7bc3603a25c",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "No transparent types are needed for this example. In fact, transparent types are considerably harder than transparent methods, since their rewritings must be stable under substitutions, which is not easy to achieve. ",
        "createdAt" : "2018-07-06T09:27:23Z",
        "updatedAt" : "2018-07-26T14:54:44Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "88e7d180574eda8a71037d1735ac6a3ff76a1c08",
    "line" : 330,
    "diffHunk" : "@@ -1,1 +328,332 @@  erased val r = concatTyped(xs, ys)\n  concatImpl(xs, ys).asInstanceOf[r.Type]\n}\n```\nThe transparent `concat` method makes use of two helper functions, `concatTyped` (described in the last section) and `concatImpl`. `concatTyped` is called as the right hand side of an `erased` value `r`. Since `r` is `erased`, no code is generated for its definition."
  },
  {
    "id" : "b0ca7de5-fa21-4e12-be4b-7a1a2b3bc407",
    "prId" : 4616,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/4616#pullrequestreview-139255036",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "30af683d-c8f8-44df-a34f-11cf0701fe8c",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Putting the keyword override here is misleading given the semantics described below. I would vote for calling this \"shadow transparent\" to clearly distinguish this from a regular override.",
        "createdAt" : "2018-07-20T23:38:27Z",
        "updatedAt" : "2018-07-26T14:54:44Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "59065f35-5a1d-476e-b7f5-0e25ec056c6e",
        "parentId" : "30af683d-c8f8-44df-a34f-11cf0701fe8c",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "I would be cleaner, I agree. But it means a new modifier.",
        "createdAt" : "2018-07-21T10:33:22Z",
        "updatedAt" : "2018-07-26T14:54:44Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "88e7d180574eda8a71037d1735ac6a3ff76a1c08",
    "line" : 249,
    "diffHunk" : "@@ -1,1 +247,251 @@}\nclass List[T] extends Iterable[T] {\n  override transparent def foreach(f: T => Unit): Unit = ...\n}\nval xs: Iterable[T] = ..."
  },
  {
    "id" : "f49f23af-d0e6-4a36-850e-74c212b0f05e",
    "prId" : 4616,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/4616#pullrequestreview-139267001",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a3da11f9-cfad-4325-8648-3157f0c4423d",
        "parentId" : null,
        "authorId" : "961d633f-82c9-4ca7-aaab-12ef4c45a8d2",
        "body" : "I think it would be much simpler to allow pattern matching on types, just like :\r\n\r\n```scala\r\ntransparent def defaultValue[T] = T match {\r\n  case Byte => Some(0: Byte)\r\n  ...\r\n}\r\n```\r\n\r\nWhen defaultValue called is called at compile time, it might be called before type erasure, so I think it might be possible to allow this for typelevel transparent methods.",
        "createdAt" : "2018-07-21T14:25:16Z",
        "updatedAt" : "2018-07-26T14:54:44Z",
        "lastEditedBy" : "961d633f-82c9-4ca7-aaab-12ef4c45a8d2",
        "tags" : [
        ]
      },
      {
        "id" : "565e0286-bac4-49f9-9942-6e7af595f7f7",
        "parentId" : "a3da11f9-cfad-4325-8648-3157f0c4423d",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "That would not work, because `T` would be resolved as a term, not as a type. I once had syntax like\r\n\r\n    transparent def defaultValue[T] = type T match {\r\n      case Byte => ...\r\n      ...\r\n    }\r\n\r\nand so on. But then I dropped it because it makes the language more complicated and the use cases less clear. When matching on types you have to clarify on what you match. Do aliases match? Does `T & U` match `U & T`? Does `T & U` match `U`? You can give answers to all these questions but the issue is that you need to work out these answers and write them up and teach them.",
        "createdAt" : "2018-07-21T15:25:55Z",
        "updatedAt" : "2018-07-26T14:54:44Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "93261a21-f5e3-4a72-a587-df821c66394e",
        "parentId" : "a3da11f9-cfad-4325-8648-3157f0c4423d",
        "authorId" : "961d633f-82c9-4ca7-aaab-12ef4c45a8d2",
        "body" : "Ok, thanks for the explanation!",
        "createdAt" : "2018-07-21T19:31:12Z",
        "updatedAt" : "2018-07-26T14:54:44Z",
        "lastEditedBy" : "961d633f-82c9-4ca7-aaab-12ef4c45a8d2",
        "tags" : [
        ]
      }
    ],
    "commit" : "88e7d180574eda8a71037d1735ac6a3ff76a1c08",
    "line" : 286,
    "diffHunk" : "@@ -1,1 +284,288 @@  case _ => None\n}\n```\nThen:\n```scala"
  },
  {
    "id" : "872200a0-6c73-4544-82d0-539b463fbd3e",
    "prId" : 4616,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/4616#pullrequestreview-139872961",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "57151e5d-9b76-4ed9-8d82-1e911a763c40",
        "parentId" : null,
        "authorId" : "348fab8e-49e2-442e-884d-850c7f41fdde",
        "body" : "I guess this is final val, since we don’t want widening here, right?",
        "createdAt" : "2018-07-24T12:50:38Z",
        "updatedAt" : "2018-07-26T14:54:44Z",
        "lastEditedBy" : "348fab8e-49e2-442e-884d-850c7f41fdde",
        "tags" : [
        ]
      }
    ],
    "commit" : "88e7d180574eda8a71037d1735ac6a3ff76a1c08",
    "line" : 171,
    "diffHunk" : "@@ -1,1 +169,173 @@                         pattern that is statically known to match is chosen. A pattern match `E match { Case_1 ... Case_n }` is translated as follows:\n\n   - We first create a binding `val $scrutinee_n = E` for the scrutinee of the match.\n   - Matching a pattern `P` takes as additional input the current scrutinee reference `S` (this is `$scrutinee_n` for toplevel patterns). It either returns with a sequence of additional bindings or fails. The rules depend on the form of the pattern `P`.\n"
  },
  {
    "id" : "31136a22-6182-461c-b451-00ac1c696ecc",
    "prId" : 4616,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/4616#pullrequestreview-139903406",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "69e73b5c-5723-4d3c-b73e-92b1f1d82d40",
        "parentId" : null,
        "authorId" : "348fab8e-49e2-442e-884d-850c7f41fdde",
        "body" : "That’s currently violated in the examples by the overrides of `toInt`, since they don't throw exceptions.",
        "createdAt" : "2018-07-24T12:52:44Z",
        "updatedAt" : "2018-07-26T14:54:44Z",
        "lastEditedBy" : "348fab8e-49e2-442e-884d-850c7f41fdde",
        "tags" : [
        ]
      },
      {
        "id" : "4097d2f1-c9e5-4e51-9b66-b8e284f0a488",
        "parentId" : "69e73b5c-5723-4d3c-b73e-92b1f1d82d40",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "But these are tests, not code. You can do whatever in a test. I just adapted what we had before to make it work under the new rules.",
        "createdAt" : "2018-07-24T13:59:05Z",
        "updatedAt" : "2018-07-26T14:54:44Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "88e7d180574eda8a71037d1735ac6a3ff76a1c08",
    "line" : 259,
    "diffHunk" : "@@ -1,1 +257,261 @@```\nIt follows that an overriding typelevel method should implement exactly the same semantics as the\nmethod it overrides (but possibly more efficiently).\n\n## Matching on Types"
  }
]
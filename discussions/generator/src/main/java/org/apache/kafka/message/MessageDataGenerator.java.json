[
  {
    "id" : "c3a2df5b-cff7-4d58-8d06-2475281f3a08",
    "prId" : 7291,
    "prUrl" : "https://github.com/apache/kafka/pull/7291#pullrequestreview-285139974",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c608d8b8-2a45-4877-9cb1-56af9fd1251e",
        "parentId" : null,
        "authorId" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "body" : "UUIDs can never be null.  Therefore, it doesn't make sense to use null as a default.  Even if it did, we don't choose null as a default for anything unless the user selects it specifically by writing `\"default\": \"null\"`.\r\n\r\nThe default value you should use should be something like the all zeroes pattern.  You can create a single (public, static, final) instance of one of those in MessageUtil or somewhere, to avoid creating new ones each time we instantiate a Message class with UUIDs.",
        "createdAt" : "2019-09-06T23:42:02Z",
        "updatedAt" : "2019-09-11T17:25:50Z",
        "lastEditedBy" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "tags" : [
        ]
      }
    ],
    "commit" : "df17ec3c32c1a4186e897cdb6adf70f9e0ebe67a",
    "line" : 105,
    "diffHunk" : "@@ -1,1 +1241,1245 @@        } else if (field.type() instanceof FieldType.UUIDFieldType) {\n            headerGenerator.addImport(MessageGenerator.UUID_CLASS);\n            if (field.defaultString().isEmpty()) {\n                return \"org.apache.kafka.common.protocol.MessageUtil.ZERO_UUID\";\n            } else {"
  },
  {
    "id" : "db7a2b82-437f-461c-b7b5-b52a37ce5572",
    "prId" : 7291,
    "prUrl" : "https://github.com/apache/kafka/pull/7291#pullrequestreview-287130072",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d69b45e5-bff6-4f02-8b5f-0da538fa22de",
        "parentId" : null,
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "@cmccabe Maybe I missed the point; I thought this would set it to a \"zero UUID\" (previously, this was setting it to `null`).",
        "createdAt" : "2019-09-11T23:43:19Z",
        "updatedAt" : "2019-09-11T23:46:09Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      }
    ],
    "commit" : "df17ec3c32c1a4186e897cdb6adf70f9e0ebe67a",
    "line" : 106,
    "diffHunk" : "@@ -1,1 +1242,1246 @@            headerGenerator.addImport(MessageGenerator.UUID_CLASS);\n            if (field.defaultString().isEmpty()) {\n                return \"org.apache.kafka.common.protocol.MessageUtil.ZERO_UUID\";\n            } else {\n                try {"
  },
  {
    "id" : "540b6b68-2b6d-4ec0-8886-2377c4337fe9",
    "prId" : 7325,
    "prUrl" : "https://github.com/apache/kafka/pull/7325#pullrequestreview-297595787",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b1083536-39cc-4105-a55c-b85e8311cac8",
        "parentId" : null,
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "Could probably use `Collections.emptyList()` here",
        "createdAt" : "2019-10-04T05:53:54Z",
        "updatedAt" : "2019-10-06T18:59:30Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      },
      {
        "id" : "aa18a749-8c04-43bf-a9cf-c28bcda7ff4b",
        "parentId" : "b1083536-39cc-4105-a55c-b85e8311cac8",
        "authorId" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "body" : "the problem is that this field is mutable, and Collections.emptyList returns something immutable",
        "createdAt" : "2019-10-04T16:50:30Z",
        "updatedAt" : "2019-10-06T18:59:30Z",
        "lastEditedBy" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "tags" : [
        ]
      }
    ],
    "commit" : "5bdfa27b38efacb5368ee3ce926f13c38a19be26",
    "line" : 64,
    "diffHunk" : "@@ -1,1 +303,307 @@        buffer.incrementIndent();\n        headerGenerator.addImport(MessageGenerator.ARRAYLIST_CLASS);\n        buffer.printf(\"_unknownTaggedFields = new ArrayList<>(0);%n\");\n        buffer.decrementIndent();\n        buffer.printf(\"}%n\");"
  },
  {
    "id" : "b8fbdb9a-635b-45d3-b909-f72ee2ed4e57",
    "prId" : 7325,
    "prUrl" : "https://github.com/apache/kafka/pull/7325#pullrequestreview-297222840",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3f6fd656-c53a-4bd8-a88f-b468f192c269",
        "parentId" : null,
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "This is nifty",
        "createdAt" : "2019-10-04T05:58:39Z",
        "updatedAt" : "2019-10-06T18:59:30Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      }
    ],
    "commit" : "5bdfa27b38efacb5368ee3ce926f13c38a19be26",
    "line" : 952,
    "diffHunk" : "@@ -1,1 +1100,1104 @@    }\n\n    private void generateNonDefaultValueCheck(FieldSpec field) {\n        if (field.type().isArray()) {\n            if (fieldDefault(field).equals(\"null\")) {"
  },
  {
    "id" : "7c8855c4-4f49-445a-bdfa-c91f838781fb",
    "prId" : 7325,
    "prUrl" : "https://github.com/apache/kafka/pull/7325#pullrequestreview-297596513",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "47db7931-6a1c-4e64-ae58-d08ae96b2a12",
        "parentId" : null,
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "I wonder if you have given any thought to limiting allocations like this. For example, in the case of the byte array, we may be able to validate the size using the available bytes in the request",
        "createdAt" : "2019-10-04T06:11:34Z",
        "updatedAt" : "2019-10-06T18:59:30Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      },
      {
        "id" : "fa0066a3-ea82-4fce-a7ba-9498410ac87b",
        "parentId" : "47db7931-6a1c-4e64-ae58-d08ae96b2a12",
        "authorId" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "body" : "I do think we're kind of goofy to allow arrays with 2**31 elements.  There must be a reasonable maximum we could set lower than that.  But there will probably be some compatibility implications to this, so it will take time to impose a reasonable limit now....",
        "createdAt" : "2019-10-04T16:51:57Z",
        "updatedAt" : "2019-10-06T18:59:30Z",
        "lastEditedBy" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "tags" : [
        ]
      }
    ],
    "commit" : "5bdfa27b38efacb5368ee3ce926f13c38a19be26",
    "line" : 409,
    "diffHunk" : "@@ -1,1 +620,624 @@            } else {\n                headerGenerator.addImport(MessageGenerator.ARRAYLIST_CLASS);\n                buffer.printf(\"ArrayList<%s> newCollection = new ArrayList<%s>(%s);%n\",\n                    getBoxedJavaType(arrayType.elementType()),\n                        getBoxedJavaType(arrayType.elementType()), lengthVar);"
  },
  {
    "id" : "a54cbc57-b73e-4dc9-b98f-dcbd402ac88d",
    "prId" : 7325,
    "prUrl" : "https://github.com/apache/kafka/pull/7325#pullrequestreview-297598473",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "185751c9-428e-4c65-a2e6-b5f2c575562e",
        "parentId" : null,
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "Not a big deal, but there are a few cases where we could use a null check of `_taggedField` instead of a version check. Might make the generated code a little more readable.",
        "createdAt" : "2019-10-04T06:21:55Z",
        "updatedAt" : "2019-10-06T18:59:30Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      },
      {
        "id" : "5dfdd754-84b9-44b1-af7e-246a6650263b",
        "parentId" : "185751c9-428e-4c65-a2e6-b5f2c575562e",
        "authorId" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "body" : "It would be a bit complex to change now since we're also filtering versions that aren't present at all and so on",
        "createdAt" : "2019-10-04T16:55:50Z",
        "updatedAt" : "2019-10-06T18:59:30Z",
        "lastEditedBy" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "tags" : [
        ]
      }
    ],
    "commit" : "5bdfa27b38efacb5368ee3ce926f13c38a19be26",
    "line" : 479,
    "diffHunk" : "@@ -1,1 +686,690 @@                }).\n                ifMember(presentVersions -> {\n                    VersionConditional.forVersions(field.taggedVersions(), presentVersions).\n                        ifNotMember(presentAndUntaggedVersions -> {\n                            if (field.type().isArray()) {"
  },
  {
    "id" : "e77ea73e-86df-41af-9566-5741011c503c",
    "prId" : 7325,
    "prUrl" : "https://github.com/apache/kafka/pull/7325#pullrequestreview-297731677",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b1388df8-14ed-42fd-b072-5fd4c3451b55",
        "parentId" : null,
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "I think there's a bug in the handling of nullable arrays when the default is not null. For example, consider the following field:\r\n\r\n```json\r\n    { \"name\": \"field2\", \"type\": \"[]BlahType\",\r\n      \"versions\": \"1+\", \"taggedVersions\": \"1+\", \"tag\": 1,\r\n      \"nullableVersions\": \"1+\",\r\n      \"fields\": [\r\n          { \"name\": \"wootId\", \"versions\": \"1+\", \"type\": \"int32\" },\r\n      ]\r\n    }\r\n```\r\nThis results in the following code:\r\n\r\n```java\r\n        if (_version >= 1) {\r\n            if (!field2.isEmpty()) {\r\n                if (field2 == null) {\r\n                    _taggedFields.put(1, null);\r\n                } else {\r\n                    Struct[] _nestedObjects = new Struct[field2.size()];\r\n                    int i = 0;\r\n                    for (BlahType element : this.field2) {\r\n                        _nestedObjects[i++] = element.toStruct(_version);\r\n                    }\r\n                    _taggedFields.put(1, _nestedObjects);\r\n                }\r\n            }\r\n        }\r\n```\r\nThe null check should come first. Seems like the default value optimization needs to take into account nullable values. The same bug affects `size`.\r\n\r\nIn general, we probably need more testing, especially for default value handling.",
        "createdAt" : "2019-10-04T06:33:36Z",
        "updatedAt" : "2019-10-06T18:59:30Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      },
      {
        "id" : "2ffb4159-c49e-4410-9b93-0949eb971186",
        "parentId" : "b1388df8-14ed-42fd-b072-5fd4c3451b55",
        "authorId" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "body" : "Thanks for finding this.  It might be better to address it in a follow on, since the fix could get complicated.  I'll push what I have for now.",
        "createdAt" : "2019-10-04T21:44:18Z",
        "updatedAt" : "2019-10-06T18:59:30Z",
        "lastEditedBy" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "tags" : [
        ]
      }
    ],
    "commit" : "5bdfa27b38efacb5368ee3ce926f13c38a19be26",
    "line" : 1061,
    "diffHunk" : "@@ -1,1 +1160,1164 @@                        }).\n                        ifMember(presentAndTaggedVersions -> {\n                            generateNonDefaultValueCheck(field);\n                            buffer.incrementIndent();\n                            generateTaggedFieldToMap(field, presentAndTaggedVersions);"
  },
  {
    "id" : "ff3d69ea-fdcb-44c5-be57-6c45b3cf3ecd",
    "prId" : 7585,
    "prUrl" : "https://github.com/apache/kafka/pull/7585#pullrequestreview-320166887",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "92a78fdf-2862-4160-b32d-9f382437e9c9",
        "parentId" : null,
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "So the reason we have to write the size twice here is because we treat all tagged fields as structs. Is that right? So we could convert \"myNullableString\" into a struct which has a nullable string as its first field and then is followed by additional fields. Assuming that is right, I'm wondering how it works in terms of versioning. Do tagged fields have prefix rules? \r\n\r\nBy the way, what is the reason for the '+ 1'?",
        "createdAt" : "2019-11-19T05:21:34Z",
        "updatedAt" : "2019-11-20T18:43:08Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      },
      {
        "id" : "56c0cdd8-0b12-4fb9-83b3-345669635283",
        "parentId" : "92a78fdf-2862-4160-b32d-9f382437e9c9",
        "authorId" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "body" : "It's not really that they're all treated as structs, but just that they all have to be treated as opaque length-delimited blobs so that clients that don't know the type of the tagged field can skip over it.  The length field is ignored by clients that know the field type (for example, if you know that you're looking for an int, you can just read 4 bytes).  But if you don't know about the field, you also don't know about the field's type.\r\n\r\nI guess in theory we could support inline tagged structs if we wanted to later on.  Since everything is just length-prefixed, we can add arbitrary types that nobody has thought of yet in a backwards-compatible fashion.  Right now, they're not supported, though.\r\n\r\nThe way compatibility works is basically \"you can never change the type of a tagged field.\"  The constraint isn't as bad as it sounds, since you can always create a new tagged field if you really need something of a different type.",
        "createdAt" : "2019-11-20T17:48:56Z",
        "updatedAt" : "2019-11-20T18:43:08Z",
        "lastEditedBy" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "tags" : [
        ]
      },
      {
        "id" : "926e455a-1199-4325-9153-079f3b64fc2f",
        "parentId" : "92a78fdf-2862-4160-b32d-9f382437e9c9",
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "Yes, I understand the need to have a length at the tagged field level. Mainly I was thinking about the redundancy when the type of the tagged field is known. It's a little annoying to serialize the string length twice, for example. Anyway, thanks for explaining.",
        "createdAt" : "2019-11-20T18:04:53Z",
        "updatedAt" : "2019-11-20T18:43:08Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      }
    ],
    "commit" : "3292a7cbf6ae923829b86dab1891c925f24fa553",
    "line" : 78,
    "diffHunk" : "@@ -1,1 +955,959 @@                                            field.camelCaseName());\n                                        headerGenerator.addImport(MessageGenerator.BYTE_UTILS_CLASS);\n                                        buffer.printf(\"_writable.writeUnsignedVarint(_stringBytes.length + \" +\n                                            \"ByteUtils.sizeOfUnsignedVarint(_stringBytes.length + 1));%n\");\n                                        buffer.printf(\"_writable.writeUnsignedVarint(_stringBytes.length + 1);%n\");"
  }
]
[
  {
    "id" : "aa846542-6068-40b0-840d-d496c0551343",
    "prId" : 1847,
    "prUrl" : "https://github.com/mlflow/mlflow/pull/1847#pullrequestreview-289618283",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "34c0b47a-4fd2-4d7b-b6a0-0246279908c0",
        "parentId" : null,
        "authorId" : "bd3067fd-855b-4bd1-898d-ca29199fd092",
        "body" : "Had to add this to fix a linter error, even though the return doesn't do anything.",
        "createdAt" : "2019-09-17T01:28:08Z",
        "updatedAt" : "2019-09-17T01:30:14Z",
        "lastEditedBy" : "bd3067fd-855b-4bd1-898d-ca29199fd092",
        "tags" : [
        ]
      },
      {
        "id" : "b5db8891-27db-474d-957b-4889dabeb7d1",
        "parentId" : "34c0b47a-4fd2-4d7b-b6a0-0246279908c0",
        "authorId" : "4f64c319-81b2-4dc8-af79-8a96e80dacf8",
        "body" : "Which linter error? This code has been there for some time.",
        "createdAt" : "2019-09-17T20:10:45Z",
        "updatedAt" : "2019-09-17T20:45:49Z",
        "lastEditedBy" : "4f64c319-81b2-4dc8-af79-8a96e80dacf8",
        "tags" : [
        ]
      },
      {
        "id" : "7a6fba37-79ec-46b8-ba23-5b8ce95068fa",
        "parentId" : "34c0b47a-4fd2-4d7b-b6a0-0246279908c0",
        "authorId" : "bd3067fd-855b-4bd1-898d-ca29199fd092",
        "body" : "True, it's probably because I have a different linter version than travis...",
        "createdAt" : "2019-09-18T00:43:22Z",
        "updatedAt" : "2019-09-18T00:43:23Z",
        "lastEditedBy" : "bd3067fd-855b-4bd1-898d-ca29199fd092",
        "tags" : [
        ]
      }
    ],
    "commit" : "19b2ad7799e98313441fc1aeffc3b327af366175",
    "line" : 37,
    "diffHunk" : "@@ -1,1 +215,219 @@        // We can't throw the XHR itself because it looks like a promise to the\n        // redux-promise-middleware.\n        return reject(new ErrorWrapper(xhr));\n      }\n    });"
  },
  {
    "id" : "85835689-c418-4c13-8ce8-3fbad0127a98",
    "prId" : 1847,
    "prUrl" : "https://github.com/mlflow/mlflow/pull/1847#pullrequestreview-289508461",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "73de5acb-a254-4a20-a8ad-897dfc450037",
        "parentId" : null,
        "authorId" : "d79ebb0f-0833-4329-8a37-7ae540003587",
        "body" : "I don't really know js that well. Why do you need the second Promise? Can you not just directly return the results of the recursive call?",
        "createdAt" : "2019-09-17T17:23:25Z",
        "updatedAt" : "2019-09-17T17:23:26Z",
        "lastEditedBy" : "d79ebb0f-0833-4329-8a37-7ae540003587",
        "tags" : [
        ]
      },
      {
        "id" : "6c4f8ef9-47e8-4875-a8b8-710138f77839",
        "parentId" : "73de5acb-a254-4a20-a8ad-897dfc450037",
        "authorId" : "bd3067fd-855b-4bd1-898d-ca29199fd092",
        "body" : "Ah the second promise (the `new Promise()` here) is effectively a means of implementing a `Thread.sleep` in Javascript - JS has no way to block the currently running thread, so we instead create a promise that resolves itself after a timeout using `setTimeout`, and then chain the recursive call to run afterwards. Note that `return`ing from the AJAX error callback on this line isn't actually necessary - the completion of the outer Promise happens when we call `resolve` or `reject` on lines 209 or 210.\r\n\r\nIf we didn't have the need to sleep, we'd still need to condition the resolution of our outer promise (i.e. the calls to `resolve` and `reject`) on the result of the recursive call, e.g. via\r\n\r\n```\r\nreturn wrapDeferred(deferred, data, newTimeLeft, newSleepMs).then(\r\n                (successResponse) => resolve(successResponse),\r\n                (failureResponse) => reject(failureResponse)\r\n            );\r\n```",
        "createdAt" : "2019-09-17T19:43:43Z",
        "updatedAt" : "2019-09-17T19:43:44Z",
        "lastEditedBy" : "bd3067fd-855b-4bd1-898d-ca29199fd092",
        "tags" : [
        ]
      },
      {
        "id" : "703782ec-ee9b-48c7-b172-aeb3eaad8312",
        "parentId" : "73de5acb-a254-4a20-a8ad-897dfc450037",
        "authorId" : "bd3067fd-855b-4bd1-898d-ca29199fd092",
        "body" : "BTW, the explanation for how returning a `Promise` from `then` works is in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then#Return_value):\r\n\r\n> [If a handler function passed to then] returns another pending promise object, the resolution/rejection of the promise returned by then will be subsequent to the resolution/rejection of the promise returned by the handler. Also, the value of the promise returned by then will be the same as the value of the promise returned by the handler.\r\n\r\n",
        "createdAt" : "2019-09-17T19:54:35Z",
        "updatedAt" : "2019-09-17T19:55:08Z",
        "lastEditedBy" : "bd3067fd-855b-4bd1-898d-ca29199fd092",
        "tags" : [
        ]
      }
    ],
    "commit" : "19b2ad7799e98313441fc1aeffc3b327af366175",
    "line" : 25,
    "diffHunk" : "@@ -1,1 +204,208 @@            const newTimeLeft = timeLeftMs - sleepMs;\n            const newSleepMs = Math.min(newTimeLeft, sleepMs * 2);\n            return new Promise(resolveRetry => setTimeout(resolveRetry, sleepMs)).then(() => {\n              return wrapDeferred(deferred, data, newTimeLeft, newSleepMs);\n            }).then("
  },
  {
    "id" : "bf1c2189-a7cf-4b90-be22-f1bbd4391f9e",
    "prId" : 1847,
    "prUrl" : "https://github.com/mlflow/mlflow/pull/1847#pullrequestreview-289426232",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e4e1d086-b6b5-4958-8717-4af01d5ee614",
        "parentId" : null,
        "authorId" : "4f64c319-81b2-4dc8-af79-8a96e80dacf8",
        "body" : "It's not obvious to me what timeLeftMs means and how it interacts with sleepMs when I'm looking at this function signature. Could we have some comment for those parameter similar to the explanation the console warning message below?",
        "createdAt" : "2019-09-17T17:27:34Z",
        "updatedAt" : "2019-09-17T20:45:49Z",
        "lastEditedBy" : "4f64c319-81b2-4dc8-af79-8a96e80dacf8",
        "tags" : [
        ]
      }
    ],
    "commit" : "19b2ad7799e98313441fc1aeffc3b327af366175",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +186,190 @@ * rejects using the ajax callbacks `success` and `error`.\n */\nexport const wrapDeferred = (deferred, data, timeLeftMs = 60000, sleepMs = 1000) => {\n  return new Promise((resolve, reject) => {\n    deferred({"
  },
  {
    "id" : "758e12f8-6c38-416a-b571-f99c682cf6fe",
    "prId" : 1847,
    "prUrl" : "https://github.com/mlflow/mlflow/pull/1847#pullrequestreview-289426232",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "69f42c0d-380e-41b2-8c52-5f46cce1ede3",
        "parentId" : null,
        "authorId" : "4f64c319-81b2-4dc8-af79-8a96e80dacf8",
        "body" : "This is essentially a recursive call which for each recursion allocates a LexicalEnvironment object to the heap retaining free variables used in the two closures inside `new Promise(...)` .  It's great to see that we stop retrying after 1 minute, otherwise it's going to cause memory leak after user user leaving the browser open for a long time.",
        "createdAt" : "2019-09-17T20:04:52Z",
        "updatedAt" : "2019-09-17T20:45:49Z",
        "lastEditedBy" : "4f64c319-81b2-4dc8-af79-8a96e80dacf8",
        "tags" : [
        ]
      }
    ],
    "commit" : "19b2ad7799e98313441fc1aeffc3b327af366175",
    "line" : 26,
    "diffHunk" : "@@ -1,1 +205,209 @@            const newSleepMs = Math.min(newTimeLeft, sleepMs * 2);\n            return new Promise(resolveRetry => setTimeout(resolveRetry, sleepMs)).then(() => {\n              return wrapDeferred(deferred, data, newTimeLeft, newSleepMs);\n            }).then(\n                (successResponse) => resolve(successResponse),"
  },
  {
    "id" : "fdb24a8b-7a9e-4414-a8a7-0916fbd55b1a",
    "prId" : 1564,
    "prUrl" : "https://github.com/mlflow/mlflow/pull/1564#pullrequestreview-260262047",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b8c58680-1889-4680-a293-6cf0339b9206",
        "parentId" : null,
        "authorId" : "4f64c319-81b2-4dc8-af79-8a96e80dacf8",
        "body" : "Same as search runs except this `page_token` field",
        "createdAt" : "2019-07-10T17:58:04Z",
        "updatedAt" : "2019-07-12T16:33:49Z",
        "lastEditedBy" : "4f64c319-81b2-4dc8-af79-8a96e80dacf8",
        "tags" : [
        ]
      }
    ],
    "commit" : "1337fe0bd9e68c2e2ef39dc553aa314551adb7b4",
    "line" : 37,
    "diffHunk" : "@@ -1,1 +110,114 @@    max_results: SEARCH_MAX_RESULTS,\n    order_by: orderBy,\n    page_token: pageToken,\n  }),\n  meta: { id },"
  },
  {
    "id" : "e8c7ad15-3998-412f-bc97-7001c6680975",
    "prId" : 1564,
    "prUrl" : "https://github.com/mlflow/mlflow/pull/1564#pullrequestreview-260328228",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "22e56273-c29e-4f35-a180-eb799b1960a7",
        "parentId" : null,
        "authorId" : "585a7aa0-77e3-46ce-95a0-4a8de00c6c4a",
        "body" : "👍 ",
        "createdAt" : "2019-07-10T20:09:14Z",
        "updatedAt" : "2019-07-12T16:33:49Z",
        "lastEditedBy" : "585a7aa0-77e3-46ce-95a0-4a8de00c6c4a",
        "tags" : [
        ]
      }
    ],
    "commit" : "1337fe0bd9e68c2e2ef39dc553aa314551adb7b4",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +2,6 @@import ErrorCodes from './sdk/ErrorCodes';\n\nexport const SEARCH_MAX_RESULTS = 100;\n\nexport const isPendingApi = (action) => {"
  },
  {
    "id" : "0d8c0b28-f320-4d0f-a26e-dc1ac09c1a7b",
    "prId" : 1025,
    "prUrl" : "https://github.com/mlflow/mlflow/pull/1025#pullrequestreview-220671791",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "43975798-2e63-4b16-a95a-5a49938aafd1",
        "parentId" : null,
        "authorId" : "3f60ced2-d2f0-4cc5-9898-5aefe16e0be8",
        "body" : "Nitty question: Why do we check that `error_code` has a truthy value here and on line 191? The error code is never referenced again. Further, if the error code is absent, does that mean that the responseText does not correspond to an error? If so, why do we construct an `ErrorWrapper` for it?",
        "createdAt" : "2019-03-22T22:41:38Z",
        "updatedAt" : "2019-03-29T17:34:29Z",
        "lastEditedBy" : "3f60ced2-d2f0-4cc5-9898-5aefe16e0be8",
        "tags" : [
        ]
      },
      {
        "id" : "21fafebf-6a06-42d1-ba39-f92c951477b6",
        "parentId" : "43975798-2e63-4b16-a95a-5a49938aafd1",
        "authorId" : "91d7919c-02c4-40e4-8f30-7f297efebb01",
        "body" : "It means that the response came from our OSS server in the way we expect it to (it should always have an `error_code` field and a `message` field.",
        "createdAt" : "2019-03-29T17:32:57Z",
        "updatedAt" : "2019-03-29T17:34:29Z",
        "lastEditedBy" : "91d7919c-02c4-40e4-8f30-7f297efebb01",
        "tags" : [
        ]
      }
    ],
    "commit" : "39a0e1fca496e97d9e9177ad7292dd0bbf467573",
    "line" : 24,
    "diffHunk" : "@@ -1,1 +204,208 @@      try {\n        const parsed = JSON.parse(responseText);\n        if (parsed.error_code && parsed.message) {\n          return parsed.message;\n        }"
  },
  {
    "id" : "fe7b5bb2-3a5d-43d0-8497-568b6d8fd1e3",
    "prId" : 526,
    "prUrl" : "https://github.com/mlflow/mlflow/pull/526#pullrequestreview-158333047",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "61377baf-0df6-4586-9fe2-07268aaef505",
        "parentId" : null,
        "authorId" : "bd3067fd-855b-4bd1-898d-ca29199fd092",
        "body" : "Maybe it'd make sense to use Mike Lin's modal wrapper code for this? One nice thing about it is that it ensures we only show one modal at a time (currently for example, if a DeleteRun request fails, there'll be a brief moment where we show both a ConfirmModal and an ErrorModal). It's not a huge deal, so we could defer it till later.",
        "createdAt" : "2018-09-23T18:12:57Z",
        "updatedAt" : "2018-09-25T01:01:09Z",
        "lastEditedBy" : "bd3067fd-855b-4bd1-898d-ca29199fd092",
        "tags" : [
        ]
      },
      {
        "id" : "c6ae27a2-b2de-4e6a-bbf5-e3d505a249dc",
        "parentId" : "61377baf-0df6-4586-9fe2-07268aaef505",
        "authorId" : "91d7919c-02c4-40e4-8f30-7f297efebb01",
        "body" : "Nice catch, I hadn't seen that before. My preference is to have a follow up PR which converts all modals to use that infra.",
        "createdAt" : "2018-09-24T23:31:36Z",
        "updatedAt" : "2018-09-25T01:01:09Z",
        "lastEditedBy" : "91d7919c-02c4-40e4-8f30-7f297efebb01",
        "tags" : [
        ]
      }
    ],
    "commit" : "6962e2ab3422f5ab97ba5578e9cb997d01c3a49f",
    "line" : 43,
    "diffHunk" : "@@ -1,1 +121,125 @@};\n\nexport const CLOSE_ERROR_MODAL = 'CLOSE_ERROR_MODAL';\nexport const closeErrorModal = () => {\n  return {"
  },
  {
    "id" : "c9475e5f-bf63-41fa-ade9-b023d3a78bc3",
    "prId" : 298,
    "prUrl" : "https://github.com/mlflow/mlflow/pull/298#pullrequestreview-146174928",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a297cd5a-5b1b-4c82-8dce-59343f28acd5",
        "parentId" : null,
        "authorId" : "b2c1789f-eaaf-4ce0-9ad7-695c9467c3cc",
        "body" : "Just added an Error here as suggested by ESLint because I think this might allow downstream tools (such as the React dev environment) to display a stack trace correctly",
        "createdAt" : "2018-08-14T17:40:04Z",
        "updatedAt" : "2018-08-14T17:40:04Z",
        "lastEditedBy" : "b2c1789f-eaaf-4ce0-9ad7-695c9467c3cc",
        "tags" : [
        ]
      }
    ],
    "commit" : "69b0be5bbecd8468f0b2e7224ed1c1a259793acd",
    "line" : 87,
    "diffHunk" : "@@ -1,1 +103,107 @@      error: xhr => {\n        console.error(\"XHR failed\", xhr);\n        reject(new Error(\"XHR failed\"));\n      }\n    });"
  }
]
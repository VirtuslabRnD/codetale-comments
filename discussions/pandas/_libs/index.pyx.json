[
  {
    "id" : "6b9adc6d-ee60-4289-9cf1-80a7cc684802",
    "prId" : 18371,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/18371#pullrequestreview-77750737",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2d00e675-511f-4bf7-be2b-ee4a795fbfd4",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "if you can add a doc string at some point",
        "createdAt" : "2017-11-20T11:14:49Z",
        "updatedAt" : "2017-11-20T11:14:49Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "38e29d1d987176dd981032ac356aa9b70d241dfc",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +49,53 @@\ncpdef object get_value_box(ndarray arr, object loc):\n    cdef:\n        Py_ssize_t i, sz\n"
  },
  {
    "id" : "f2be8677-5381-4650-899e-ee2e47e41420",
    "prId" : 19074,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/19074#pullrequestreview-88447861",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "aa4a48ef-a305-4a89-abb5-fa0231aeb523",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "pls run/show asv results for reindinxing with methods",
        "createdAt" : "2018-01-12T11:29:14Z",
        "updatedAt" : "2018-01-27T18:16:25Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "468bb08cb14ce265b78babbcbbb066adc1d08d51",
    "line" : 129,
    "diffHunk" : "@@ -1,1 +672,676 @@        if method is not None:\n            # but underlying backfill and pad methods require index and keys\n            # to be sorted. The index already is (checked in\n            # Index._get_fill_indexer), sort (integer representations of) keys:\n            order = np.argsort(lab_ints)"
  },
  {
    "id" : "ed0e39fd-ddbc-4d18-ae8a-4a5a090dd46d",
    "prId" : 19074,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/19074#pullrequestreview-91826601",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "49291d2f-2fcc-4988-abbd-126e37328aad",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "doc-string would be nice here",
        "createdAt" : "2018-01-26T03:14:14Z",
        "updatedAt" : "2018-01-27T18:16:25Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "3629661c-d97d-42f0-a757-94320856b181",
        "parentId" : "49291d2f-2fcc-4988-abbd-126e37328aad",
        "authorId" : "69a015bc-2b58-45dd-83cb-2c2f6d80b128",
        "body" : "[Already replied](https://github.com/pandas-dev/pandas/pull/19074#discussion_r159793102) (not in this PR)",
        "createdAt" : "2018-01-26T11:32:56Z",
        "updatedAt" : "2018-01-27T18:16:25Z",
        "lastEditedBy" : "69a015bc-2b58-45dd-83cb-2c2f6d80b128",
        "tags" : [
        ]
      },
      {
        "id" : "8f0b329d-c0c9-4f66-95da-1cd59c8ad248",
        "parentId" : "49291d2f-2fcc-4988-abbd-126e37328aad",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "and since its being re-written let's take this opportunity to fix these.",
        "createdAt" : "2018-01-26T11:57:43Z",
        "updatedAt" : "2018-01-27T18:16:25Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "e3041bc3-80df-4011-b5e2-d4ab2eb195d5",
        "parentId" : "49291d2f-2fcc-4988-abbd-126e37328aad",
        "authorId" : "69a015bc-2b58-45dd-83cb-2c2f6d80b128",
        "body" : "Nope. They clearly must be inherited/set generally.",
        "createdAt" : "2018-01-26T12:47:49Z",
        "updatedAt" : "2018-01-27T18:16:25Z",
        "lastEditedBy" : "69a015bc-2b58-45dd-83cb-2c2f6d80b128",
        "tags" : [
        ]
      }
    ],
    "commit" : "468bb08cb14ce265b78babbcbbb066adc1d08d51",
    "line" : 123,
    "diffHunk" : "@@ -1,1 +666,670 @@    def get_indexer(self, object target, object method=None,\n                    object limit=None):\n        lab_ints = self._extract_level_codes(target)\n\n        # All methods (exact, backfill, pad) directly map to the respective"
  },
  {
    "id" : "a7f27115-1a8d-4be5-bd8e-d0cf3f6363a0",
    "prId" : 19418,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/19418#pullrequestreview-92029255",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4bac55a4-db7c-4220-b950-ae8b0948785b",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "should prob put array dtype introspection in a single place and expose via``is_timedelta64_array`` (new) somewhere maybe util.pxd",
        "createdAt" : "2018-01-27T16:32:54Z",
        "updatedAt" : "2018-01-27T16:32:54Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "90e75166149b2915b484b22ea24bd854eac3faf1",
    "line" : 10,
    "diffHunk" : "@@ -1,1 +13,17 @@\ncdef extern from \"numpy/arrayobject.h\":\n    # These can be cimported directly from numpy in cython>=0.27.3\n    cdef enum NPY_TYPES:\n        NPY_DATETIME"
  },
  {
    "id" : "2427f4d5-9a5b-4f81-a0e4-9a16fbf49c54",
    "prId" : 21878,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/21878#pullrequestreview-137239696",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c2033db2-e754-4a4a-bc20-4a88fbce2629",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "prob can remove this comment (future PR ok)",
        "createdAt" : "2018-07-14T14:33:51Z",
        "updatedAt" : "2018-07-14T14:35:58Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "003babfa4ea299f4e46d380a2e1bf16948b44fca",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +11,15 @@from numpy cimport (ndarray, float64_t, int32_t,\n                    int64_t, uint8_t, uint64_t, intp_t,\n                    # Note: NPY_DATETIME, NPY_TIMEDELTA are only available\n                    # for cimport in cython>=0.27.3\n                    NPY_DATETIME, NPY_TIMEDELTA)"
  },
  {
    "id" : "d4e82db2-f49b-43da-8d35-d7facc1124f1",
    "prId" : 22826,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/22826#pullrequestreview-160057998",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d41ea464-bbbc-45ca-ba3f-7fe9eca85e5b",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "what if you drop the ``len(stargets) < 5`` and just use it if its monotonic_increasing? does the small case actually make any difference here?",
        "createdAt" : "2018-09-25T12:06:26Z",
        "updatedAt" : "2018-09-26T20:23:42Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "255ede05-86a2-48ba-a2ec-734aa2004281",
        "parentId" : "d41ea464-bbbc-45ca-ba3f-7fe9eca85e5b",
        "authorId" : "c029ae91-41d9-4044-92c3-e06a2617bdf1",
        "body" : "If you drop the `len(stargets) < 5`, then we'd be running a binary search against the index for each item in a potentially large set of targets -- runtime should be `O(m log n)` where `m` is the number of items in the set and `n` is the length of the index. Presumably, this would be slower when `m` is large enough compared to the current behavior which is to run through each item in the index and check if it is in the set of targets, which should be `O(n)` assuming constant time checks for whether an item is in the set of targets. Thoughts?",
        "createdAt" : "2018-09-26T20:40:49Z",
        "updatedAt" : "2018-09-26T20:40:49Z",
        "lastEditedBy" : "c029ae91-41d9-4044-92c3-e06a2617bdf1",
        "tags" : [
        ]
      },
      {
        "id" : "f50fb707-7205-4ee3-bb40-8193ed590669",
        "parentId" : "d41ea464-bbbc-45ca-ba3f-7fe9eca85e5b",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "can you add a case where this is true in the asv's and compare?",
        "createdAt" : "2018-09-28T11:34:36Z",
        "updatedAt" : "2018-09-28T11:34:36Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "c36221c4-2c1b-4991-8f3b-1bac542b2f68",
        "parentId" : "d41ea464-bbbc-45ca-ba3f-7fe9eca85e5b",
        "authorId" : "c029ae91-41d9-4044-92c3-e06a2617bdf1",
        "body" : "yes, in each of the following asv's `stargets` is either length one or length two\r\n\r\n> ```\r\n>      [ab9dbd64]       [b704c5bb]\r\n>      <master>         <loc-enhancements>\r\n> -         383±4ms          211±3ms     0.55  indexing.NonNumericSeriesIndexing.time_getitem_list_like('datetime', 'nonunique_monotonic_inc')\r\n> -        59.0±2ms         11.9±1ms     0.20  indexing.CategoricalIndexIndexing.time_get_indexer_list('monotonic_incr')\r\n> -      69.4±0.6ms          445±3μs     0.01  indexing.NumericSeriesIndexing.time_getitem_list_like(<class 'pandas.core.indexes.numeric.Int64Index'>, 'nonunique_monotonic_inc')\r\n> -      66.3±0.3ms          423±1μs     0.01  indexing.NumericSeriesIndexing.time_getitem_list_like(<class 'pandas.core.indexes.numeric.Float64Index'>, 'nonunique_monotonic_inc')\r\n> -      66.1±0.6ms          320±2μs     0.00  indexing.NumericSeriesIndexing.time_ix_list_like(<class 'pandas.core.indexes.numeric.Float64Index'>, 'nonunique_monotonic_inc')\r\n> -      69.2±0.4ms          330±3μs     0.00  indexing.NumericSeriesIndexing.time_ix_list_like(<class 'pandas.core.indexes.numeric.Int64Index'>, 'nonunique_monotonic_inc')\r\n> -      65.7±0.3ms          286±3μs     0.00  indexing.NumericSeriesIndexing.time_loc_list_like(<class 'pandas.core.indexes.numeric.Float64Index'>, 'nonunique_monotonic_inc')\r\n> -      69.3±0.5ms          295±2μs     0.00  indexing.NumericSeriesIndexing.time_loc_list_like(<class 'pandas.core.indexes.numeric.Int64Index'>, 'nonunique_monotonic_inc')\r\n> \r\n> SOME BENCHMARKS HAVE CHANGED SIGNIFICANTLY.\r\n> ```\r\n\r\n",
        "createdAt" : "2018-09-29T00:40:17Z",
        "updatedAt" : "2018-09-29T00:40:17Z",
        "lastEditedBy" : "c029ae91-41d9-4044-92c3-e06a2617bdf1",
        "tags" : [
        ]
      }
    ],
    "commit" : "4ad3006b7fa6b41a0c4d32c05272bb8cde786597",
    "line" : 12,
    "diffHunk" : "@@ -1,1 +295,299 @@        missing = np.empty(n_t, dtype=np.int64)\n\n        # map each starget to its position in the index\n        if stargets and len(stargets) < 5 and self.is_monotonic_increasing:\n            # if there are few enough stargets and the index is monotonically"
  },
  {
    "id" : "aa994dc0-abde-4bae-92a3-e00bca7ecef2",
    "prId" : 23235,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/23235#pullrequestreview-166741230",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f34e717f-8873-4f47-8b75-85392bb11529",
        "parentId" : null,
        "authorId" : "adf621f1-4745-479a-a1fc-dc14046a3f4b",
        "body" : "Pointer type used?",
        "createdAt" : "2018-10-19T21:33:48Z",
        "updatedAt" : "2018-10-23T09:57:02Z",
        "lastEditedBy" : "adf621f1-4745-479a-a1fc-dc14046a3f4b",
        "tags" : [
        ]
      },
      {
        "id" : "0c6ab4ee-134f-4a18-a5d0-36bcf5417c7a",
        "parentId" : "f34e717f-8873-4f47-8b75-85392bb11529",
        "authorId" : "c2e7df75-d1fb-42be-9205-186b46cef3d7",
        "body" : "Yes, in the ``cdef _maybe_get_bool_indexer`` part.",
        "createdAt" : "2018-10-20T07:21:08Z",
        "updatedAt" : "2018-10-23T09:57:02Z",
        "lastEditedBy" : "c2e7df75-d1fb-42be-9205-186b46cef3d7",
        "tags" : [
        ]
      }
    ],
    "commit" : "a519cc4380470f5e3a67c28a84a47e8f33f77855",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +6,10 @@import numpy as np\ncimport numpy as cnp\nfrom numpy cimport (ndarray, intp_t,\n                    float64_t, float32_t,\n                    int64_t, int32_t, int16_t, int8_t,"
  },
  {
    "id" : "8260f3c5-c352-4e1a-9542-1dd5cb09077a",
    "prId" : 27157,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/27157#pullrequestreview-256582306",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "38f65e19-bd7d-4794-a547-dd529ff9019a",
        "parentId" : null,
        "authorId" : null,
        "body" : "This is a real bug I think. `mid` is referenced in the return value if `len(values)=1` so that the main loop immediately falls through.",
        "createdAt" : "2019-07-01T15:47:55Z",
        "updatedAt" : "2019-07-01T22:05:19Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "fcf2422b-6a61-42a3-8dd9-9bc1c52f010c",
        "parentId" : "38f65e19-bd7d-4794-a547-dd529ff9019a",
        "authorId" : "5e8c5ef2-940b-436e-9c5f-98ae5460128c",
        "body" : "So this would fail if `len(values) == 0` right? Do you see a code sample to actually trigger that? ",
        "createdAt" : "2019-07-01T16:36:32Z",
        "updatedAt" : "2019-07-01T22:05:19Z",
        "lastEditedBy" : "5e8c5ef2-940b-436e-9c5f-98ae5460128c",
        "tags" : [
        ]
      },
      {
        "id" : "a11a7cc4-f46d-430c-9152-bed8904f6342",
        "parentId" : "38f65e19-bd7d-4794-a547-dd529ff9019a",
        "authorId" : null,
        "body" : "quite possibly this is meant to be \"caller checks\". But that's out of the compiler's view.",
        "createdAt" : "2019-07-01T16:54:05Z",
        "updatedAt" : "2019-07-01T22:05:19Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "da6de74f-bf74-4e92-998e-68b9e68f8c4d",
        "parentId" : "38f65e19-bd7d-4794-a547-dd529ff9019a",
        "authorId" : "5e8c5ef2-940b-436e-9c5f-98ae5460128c",
        "body" : "Yea sure. Similar comment though - good to suppress compiler warning but if there's an actual error here (which I think would still happen without the warning) would be good to address",
        "createdAt" : "2019-07-01T17:18:47Z",
        "updatedAt" : "2019-07-01T22:05:19Z",
        "lastEditedBy" : "5e8c5ef2-940b-436e-9c5f-98ae5460128c",
        "tags" : [
        ]
      },
      {
        "id" : "8b6ba6cf-6ff3-4ff3-ba66-cfa2315c4d63",
        "parentId" : "38f65e19-bd7d-4794-a547-dd529ff9019a",
        "authorId" : null,
        "body" : "if `values` is empty, the loop falls through, `util.get_value_at(values, mid)` gets called, which calls `validate_indexer` which raises. I think it's ok.",
        "createdAt" : "2019-07-01T18:30:27Z",
        "updatedAt" : "2019-07-01T22:05:19Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "59de4a2d-d4c7-458e-8f6f-34fa7fb91f6e",
        "parentId" : "38f65e19-bd7d-4794-a547-dd529ff9019a",
        "authorId" : "adf621f1-4745-479a-a1fc-dc14046a3f4b",
        "body" : "> which raises\r\n\r\ncython code can have weird corner cases where exceptions get ignored.  Adding a test for this case seems worthwhile.",
        "createdAt" : "2019-07-01T20:03:32Z",
        "updatedAt" : "2019-07-01T22:05:19Z",
        "lastEditedBy" : "adf621f1-4745-479a-a1fc-dc14046a3f4b",
        "tags" : [
        ]
      },
      {
        "id" : "8e83c506-6b80-4517-a491-f8c0d8985bf9",
        "parentId" : "38f65e19-bd7d-4794-a547-dd529ff9019a",
        "authorId" : null,
        "body" : "interesting. example?",
        "createdAt" : "2019-07-01T21:13:48Z",
        "updatedAt" : "2019-07-01T22:05:19Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "386b28a0-882b-4e61-9431-b0a2b1fd5d78",
        "parentId" : "38f65e19-bd7d-4794-a547-dd529ff9019a",
        "authorId" : null,
        "body" : "huh. I think you've nailed something here. So it's not exactly weird corner  cases, but cdef functions which return exception as if they were python functions.\r\nhttps://cython.readthedocs.io/en/latest/src/userguide/language_basics.html#error-return-values\r\n\r\n`validate_indexer` and `get_value_at` are both cdef. validate_indexer is tagged `except -1`, so any exception translates into a -1 retval. But the caller `get_value_at` doesn't check that and uses -1 to reference into the the array. in this case an empty one. but it doesn't have an except return value defines. So, I'm not sure what happens. \r\n\r\n```\r\nIf an exception is detected in such a function, a warning message is \r\nprinted and the exception is ignored.\r\n```\r\n\r\nOTOH, the index constructor refuses to create empty indexes, so an end-to-end test does not seem possible. and  `get_value_at`  is used all over the place.\r\n\r\nHmm. will have to think about this.\r\n\r\n",
        "createdAt" : "2019-07-01T21:55:12Z",
        "updatedAt" : "2019-07-01T22:05:19Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "4c176c32-d78c-4100-8dcb-1359ec947a21",
        "parentId" : "38f65e19-bd7d-4794-a547-dd529ff9019a",
        "authorId" : null,
        "body" : "```python\r\nIn [18]: %%cython\r\n    ...: \r\n    ...: cdef int foo() except -1:\r\n    ...:     1/0\r\n    ...:     cdef:\r\n    ...:         int mid = 42\r\n    ...:     return mid\r\n    ...:     \r\n    ...: cdef int bar():\r\n    ...:     res = foo()\r\n    ...:     return res\r\n    ...:     \r\n    ...: def baz():\r\n    ...:     return bar()\r\n\r\nIn [19]: baz()\r\n---------------------------------------------------------------------------\r\nZeroDivisionError                         Traceback (most recent call last)\r\n_cython_magic_a591cd36cd8e49116d6e370949ee24c2.pyx in _cython_magic_a591cd36cd8e49116d6e370949ee24c2.foo()\r\n\r\nZeroDivisionError: float division\r\nException ignored in: '_cython_magic_a591cd36cd8e49116d6e370949ee24c2.bar'\r\nTraceback (most recent call last):\r\n  File \"_cython_magic_a591cd36cd8e49116d6e370949ee24c2.pyx\", line 3, in _cython_magic_a591cd36cd8e49116d6e370949ee24c2.foo\r\nZeroDivisionError: float division\r\nOut[19]: 0\r\n```\r\n\r\nvery interesting bug.",
        "createdAt" : "2019-07-01T22:01:47Z",
        "updatedAt" : "2019-07-01T22:05:19Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "d8f3fa5b997ea78ff33e93a7f711cc5759cd0ce3",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +353,357 @@cdef Py_ssize_t _bin_search(ndarray values, object val) except -1:\n    cdef:\n        Py_ssize_t mid = 0, lo = 0, hi = len(values) - 1\n        object pval\n"
  },
  {
    "id" : "f2840f4b-8411-4679-b6cc-a42b8534fc7b",
    "prId" : 27157,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/27157#pullrequestreview-256614268",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1b2d97d0-e25a-4265-9439-28a5afda6eb8",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "is there any user code that hits this? e.g. is there some example that failed before and now works? or just an untested corner case?",
        "createdAt" : "2019-07-01T22:26:59Z",
        "updatedAt" : "2019-07-01T22:27:00Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "b2b0b446-afa9-4cf4-91f2-bed3ea0b8c49",
        "parentId" : "1b2d97d0-e25a-4265-9439-28a5afda6eb8",
        "authorId" : null,
        "body" : "the only caller is `IndexEngine.get_loc`, and `Index`'s constructor (I imagine other Indexes similarly) will refuse to create an empty index. So, this cannot be triggered. Reviewers pressed, so I responded.",
        "createdAt" : "2019-07-02T00:10:43Z",
        "updatedAt" : "2019-07-02T00:12:05Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "d8f3fa5b997ea78ff33e93a7f711cc5759cd0ce3",
    "line" : 9,
    "diffHunk" : "@@ -1,1 +356,360 @@        object pval\n\n    if hi == 0 or (hi > 0 and val > util.get_value_at(values, hi)):\n        return len(values)\n"
  },
  {
    "id" : "8da37a70-ba59-4dde-b6e8-4e7e4335de7e",
    "prId" : 27323,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/27323#pullrequestreview-260398700",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c798ff37-d290-4029-8bc3-171bbeadd206",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "how does this not hit the if at line 531?",
        "createdAt" : "2019-07-10T21:16:52Z",
        "updatedAt" : "2019-07-15T22:47:34Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "0524a03f-9bc9-4f98-ab22-3fd1e1ce1fa0",
        "parentId" : "c798ff37-d290-4029-8bc3-171bbeadd206",
        "authorId" : "adf621f1-4745-479a-a1fc-dc14046a3f4b",
        "body" : "531 is a check on the `arr` variable.  This is a check on `value`.",
        "createdAt" : "2019-07-10T23:03:05Z",
        "updatedAt" : "2019-07-15T22:47:34Z",
        "lastEditedBy" : "adf621f1-4745-479a-a1fc-dc14046a3f4b",
        "tags" : [
        ]
      }
    ],
    "commit" : "bebcedb5cbe5d3943f51bc9ee37b0ca29ba10b79",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +545,549 @@        elif isinstance(value, timedelta):\n            return Timedelta(value).value\n        elif util.is_datetime64_object(value):\n            # exclude np.datetime64(\"NaT\") which would otherwise be picked up\n            #  by the `value != value check below"
  },
  {
    "id" : "635e393c-358f-438e-8da9-454ed7bb9afb",
    "prId" : 27323,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/27323#pullrequestreview-261515243",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5792dd4b-e51a-47d8-9210-eddee8a20859",
        "parentId" : null,
        "authorId" : "adf621f1-4745-479a-a1fc-dc14046a3f4b",
        "body" : "really everything from 531 down to 555 should be ripped out and this handled by the DatetimeArray/TimedeltaArray `__setitem__` implementation",
        "createdAt" : "2019-07-13T00:10:21Z",
        "updatedAt" : "2019-07-15T22:47:34Z",
        "lastEditedBy" : "adf621f1-4745-479a-a1fc-dc14046a3f4b",
        "tags" : [
        ]
      }
    ],
    "commit" : "bebcedb5cbe5d3943f51bc9ee37b0ca29ba10b79",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +548,552 @@            # exclude np.datetime64(\"NaT\") which would otherwise be picked up\n            #  by the `value != value check below\n            pass\n        elif value is None or value != value:\n            return NPY_NAT"
  },
  {
    "id" : "b0402a00-0e82-4adf-be74-63ed99894256",
    "prId" : 28257,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/28257#pullrequestreview-283566329",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "98db27e7-7603-4419-a1ed-5f56083f6dfb",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "can you add this to the cdef above",
        "createdAt" : "2019-09-04T12:06:55Z",
        "updatedAt" : "2019-10-11T09:47:13Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "c1d2b66abc18a835c073932a91ef1783c8602814",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +305,309 @@            # if there are few enough stargets and the index is monotonically\n            # increasing, then use binary search for each starget\n            remaining_stargets = set()\n            for starget in stargets:\n                try:"
  },
  {
    "id" : "3c7b74c8-b3c6-485b-a661-7591faeaa23b",
    "prId" : 29700,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/29700#pullrequestreview-319038850",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "eb81f47c-7424-4592-95e3-bff690a4b5a9",
        "parentId" : null,
        "authorId" : "5e8c5ef2-940b-436e-9c5f-98ae5460128c",
        "body" : "Hmm what do you think about just catching the TypeError in groupby? Seems a little strange to catch and re-raise as a KeyError",
        "createdAt" : "2019-11-19T03:52:35Z",
        "updatedAt" : "2019-11-21T19:34:50Z",
        "lastEditedBy" : "5e8c5ef2-940b-436e-9c5f-98ae5460128c",
        "tags" : [
        ]
      },
      {
        "id" : "a1af9df5-7e0f-4587-b6bf-99adf71fa87a",
        "parentId" : "eb81f47c-7424-4592-95e3-bff690a4b5a9",
        "authorId" : "adf621f1-4745-479a-a1fc-dc14046a3f4b",
        "body" : "> Hmm what do you think about just catching the TypeError in groupby\r\n\r\nMy knee-jerk reaction is that this works against the direction we've been working on for a few weeks in groupby.  But if there's a compelling case that we can't catch at a lower level, it definitely beats not-catching\r\n\r\n> Seems a little strange to catch and re-raise as a KeyError\r\n\r\nI guess that depends on the official/desired signature/purpose of get_loc (the docstring doesnt say anything about what it raises), but I think the behavior below is probably not what we want:\r\n\r\n```\r\nser = pd.Series([2, 5, 6, 8], index=[2.0, 4.0, 4.0, 5.0])\r\nser2 = ser.set_axis(ser.index.astype(\"int64\"))\r\n\r\n>>> ser[None]   # <-- TypeError\r\n>>> ser2[None]   # <-- IndexError\r\n\r\n# if we slice so as to not have duplicates...\r\n>>> ser[::2][None]  # <-- KeyError\r\n>>> ser2[::2][None]  # <-- KeyError\r\n\r\n# if we slice so as to not be monotonic increasing...\r\n>>> ser[::-1][None]  # <-- KeyError\r\n>>> ser2[::-1][None]  # <-- KeyError\r\n```\r\n\r\n\r\n\r\n\r\n",
        "createdAt" : "2019-11-19T04:43:14Z",
        "updatedAt" : "2019-11-21T19:34:50Z",
        "lastEditedBy" : "adf621f1-4745-479a-a1fc-dc14046a3f4b",
        "tags" : [
        ]
      },
      {
        "id" : "bf6c37c8-1d29-48e6-8483-2123b193800a",
        "parentId" : "eb81f47c-7424-4592-95e3-bff690a4b5a9",
        "authorId" : "5e8c5ef2-940b-436e-9c5f-98ae5460128c",
        "body" : "I'm not super familiar with those aspects of indexing but would have expected all to raise a TypeError when the type of the object being passed in is incompatible with the dtype and a KeyError when valid type but simply not present. probably more of a @jreback question",
        "createdAt" : "2019-11-19T04:51:53Z",
        "updatedAt" : "2019-11-21T19:34:50Z",
        "lastEditedBy" : "5e8c5ef2-940b-436e-9c5f-98ae5460128c",
        "tags" : [
        ]
      },
      {
        "id" : "5cdc4a94-fb01-4d43-a2d5-bf3fe58452bf",
        "parentId" : "eb81f47c-7424-4592-95e3-bff690a4b5a9",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "no, we specificially catch *everything* in ``.get_loc``, which to enable it to *always* return an indexer (might be -1).",
        "createdAt" : "2019-11-19T13:37:38Z",
        "updatedAt" : "2019-11-21T19:34:50Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "edcf81869c8a080b34e598f47b5729e244197c93",
    "line" : 11,
    "diffHunk" : "@@ -1,1 +147,151 @@            except TypeError:\n                # e.g. GH#29189 get_loc(None) with a Float64Index\n                raise KeyError(val)\n\n            diff = right - left"
  },
  {
    "id" : "e2b4c9e5-a93e-4052-b684-6551abf0a8ff",
    "prId" : 30156,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/30156#pullrequestreview-329060190",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "393999ae-16dc-4ea8-ba0e-9fc429bc9be7",
        "parentId" : null,
        "authorId" : "5e8c5ef2-940b-436e-9c5f-98ae5460128c",
        "body" : "I would be OK with this in other places as well if you have a way to easily identify; more readable for sure",
        "createdAt" : "2019-12-09T16:43:07Z",
        "updatedAt" : "2019-12-09T16:43:11Z",
        "lastEditedBy" : "5e8c5ef2-940b-436e-9c5f-98ae5460128c",
        "tags" : [
        ]
      }
    ],
    "commit" : "74b6ee907a09d9e77024bb0a1ab68bb3e1a0c624",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +53,57 @@\n# Don't populate hash tables in monotonic indexes larger than this\n_SIZE_CUTOFF = 1_000_000\n\n"
  },
  {
    "id" : "ee17b776-dc1b-4ac2-832a-0797ed521411",
    "prId" : 30766,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/30766#pullrequestreview-360840351",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f1bcdc5b-99cb-49fe-9c22-27da140ec39a",
        "parentId" : null,
        "authorId" : "6abd9a80-6299-4d68-abce-f7c35c958f83",
        "body" : "example of how this code works:\r\n\r\nif `values` is\r\n```\r\n[\r\n    (1, 1),\r\n    (1, 3),\r\n    (2, 1),\r\n    (2, 3),\r\n]\r\n```\r\n\r\nand `target_values` (i.e. `target.values`, sorted) is:\r\n```\r\n[\r\n   (0, 1),\r\n   (1, 0),\r\n   (1, 3),\r\n   (2, 2),\r\n   (2, 5),\r\n]\r\n```\r\n\r\nthen, if you merged these into a sorted list of (unique) values, you would get (including index values here, and an X indicates membership):\r\n```\r\n          values  target_values\r\n\r\n0: (0, 1)               X\r\n1: (1, 0)               X\r\n2: (1, 1)    X\r\n3: (1, 3)    X          X\r\n4: (2, 1)    X\r\n5: (2, 2)               X\r\n6: (2, 3)    X\r\n7: (2, 5)               X\r\n```\r\nand so we can think of this as a factorization of the merged and sorted list of tuples.  the (ordered) subset of this belonging to `values`, which becomes `new_codes`, is:\r\n```\r\n[2, 3, 4, 6]\r\n```\r\nand the equivalent value for `target_values`, which becomes `new_target_codes`, is:\r\n```\r\n[0, 1, 3, 5, 7]\r\n```\r\n\r\nthus, if we are getting a backfilled indexer of `target_values` into `values`, we can simply backfill `new_target_codes` into `new_codes`, ge\r\ntting us:\r\n```\r\n[0, 0, 1, 3, -1]\r\n```\r\nsimilarly, for padding, we can simply call `algos.pad(new_codes, new_target_codes)`, getting us:\r\n```\r\n[-1, -1, 1, 2, 3]\r\n```\r\nwhich can be seen to be correct",
        "createdAt" : "2020-02-19T04:48:10Z",
        "updatedAt" : "2020-04-08T05:16:56Z",
        "lastEditedBy" : "6abd9a80-6299-4d68-abce-f7c35c958f83",
        "tags" : [
        ]
      }
    ],
    "commit" : "7836cc90767ba0f652065b65a5d6d26440f2d384",
    "line" : 98,
    "diffHunk" : "@@ -1,1 +691,695 @@        # merger of the index values, where `new_codes` and `new_target_codes`\n        # are the subset of the factors which appear in `values` and `target`,\n        # respectively\n        i, j, next_code = 0, 0, 0\n        while i < num_values and j < num_target_values:"
  },
  {
    "id" : "fb40d5ce-2b5e-4f26-9bc0-65f509167f75",
    "prId" : 30766,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/30766#pullrequestreview-365382989",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b43570e7-b9f3-4fb9-9159-b3fd5f7b4e4e",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "why are you changing this api? can't you rather just call a helper function if you see method / limit?",
        "createdAt" : "2020-02-26T02:23:46Z",
        "updatedAt" : "2020-04-08T05:16:56Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "57a751bb-52d7-4575-b95c-af699ee0a413",
        "parentId" : "b43570e7-b9f3-4fb9-9159-b3fd5f7b4e4e",
        "authorId" : "6abd9a80-6299-4d68-abce-f7c35c958f83",
        "body" : "rationale is that in order to do reindexing with filling (not necessary when not filling though), without using \"carrying\" logic, it's necessary to know the full set of tuples, meaning we have a few options, as far as I can tell:\r\n\r\n(1) pass the tuples in from the `MultiIndex` class.  The current implementation uses this; but I separated it for w/ and w/o filling to avoid adding new arguments to `get_indexer()`.\r\n\r\n(2) since the MultiIndex's `_engine` knows only of the levels and the int representation of the codes, we could reconstruct the tuples from this, after doing appropriate place-value logic (i.e. inverting `self._codes_to_ints()`, which is possible but a bit non-trivial), and then proceed with the algorithm in `get_indexer_and_fill()`\r\n\r\n(3) have the MultiIndex's engine store a reference to the tuples as well, but I thought a change like that might be inappropriate for this PR.  Happy to do whatever you prefer here!\r\n\r\nUpdate:\r\nsome tinkering suggests (2) can be accomplished with something like\r\n```\r\nnp.array([\r\n    [\r\n        (int_code if i == 0 else (int_code % (np.uint64(1) << self.offsets[i - 1]))) >> offset\r\n        for i, offset in enumerate(offsets)\r\n    ]\r\n    for int_code in self.vgetter()\r\n]) - 1\r\n```\r\nwhich, if used, would remove the need to pass in the tuples and thus change the interface of `get_indexer()` here in some way",
        "createdAt" : "2020-02-27T02:46:26Z",
        "updatedAt" : "2020-04-08T05:16:56Z",
        "lastEditedBy" : "6abd9a80-6299-4d68-abce-f7c35c958f83",
        "tags" : [
        ]
      }
    ],
    "commit" : "7836cc90767ba0f652065b65a5d6d26440f2d384",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +614,618 @@\n    def get_indexer_no_fill(self, object target) -> np.ndarray:\n        \"\"\"\n        Returns an array giving the positions of each value of `target` in\n        `self.values`, where -1 represents a value in `target` which does not"
  },
  {
    "id" : "0506a63e-ec58-4b13-afdd-9607a2013610",
    "prId" : 30766,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/30766#pullrequestreview-364584568",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5e60422a-5b64-493c-ba37-032c489369a3",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "can you put a blank line before comments",
        "createdAt" : "2020-02-26T02:25:15Z",
        "updatedAt" : "2020-04-08T05:16:56Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "7836cc90767ba0f652065b65a5d6d26440f2d384",
    "line" : 110,
    "diffHunk" : "@@ -1,1 +703,707 @@            next_code += 1\n\n        # at this point, at least one should have reached the end\n        # the remaining values of the other should be added to the end\n        assert i == num_values or j == num_target_values"
  },
  {
    "id" : "147e128b-4aa8-4009-95b1-83d9483f2e13",
    "prId" : 30766,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/30766#pullrequestreview-366830676",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2106b7b8-70ac-4cce-a0b9-d1fc3881f229",
        "parentId" : null,
        "authorId" : "adf621f1-4745-479a-a1fc-dc14046a3f4b",
        "body" : "in python-space a while loop is slower than a for loop.  no idea if it matters in cython",
        "createdAt" : "2020-02-28T02:39:14Z",
        "updatedAt" : "2020-04-08T05:16:56Z",
        "lastEditedBy" : "adf621f1-4745-479a-a1fc-dc14046a3f4b",
        "tags" : [
        ]
      },
      {
        "id" : "1979b7d5-19a9-4fb5-adf8-0223b6da15fb",
        "parentId" : "2106b7b8-70ac-4cce-a0b9-d1fc3881f229",
        "authorId" : "6abd9a80-6299-4d68-abce-f7c35c958f83",
        "body" : "As far as I can tell, it's just a question of how it compiles.  I'd guess that a for-loop with `break` statements would compile similarly, and that the only difference here would be the location of the `jne` statements.  If you'd like, though, I can either profile it and/or send you a diff of the relevant `objdump` snippets?",
        "createdAt" : "2020-03-01T02:17:53Z",
        "updatedAt" : "2020-04-08T05:16:56Z",
        "lastEditedBy" : "6abd9a80-6299-4d68-abce-f7c35c958f83",
        "tags" : [
        ]
      }
    ],
    "commit" : "7836cc90767ba0f652065b65a5d6d26440f2d384",
    "line" : 100,
    "diffHunk" : "@@ -1,1 +693,697 @@        # respectively\n        i, j, next_code = 0, 0, 0\n        while i < num_values and j < num_target_values:\n            val, target_val = values[i], target_values[j]\n            if val <= target_val:"
  },
  {
    "id" : "8bd59f77-7fd6-4cee-93b4-fc7e4c1ff3ab",
    "prId" : 30766,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/30766#pullrequestreview-366810476",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f26267a2-8561-4cdb-a026-f9d314b15ca0",
        "parentId" : null,
        "authorId" : "adf621f1-4745-479a-a1fc-dc14046a3f4b",
        "body" : "is there a compelling reason to do the algos call here rather than in the calling function?  theres no real perf benefit, and it looks like we could avoid needing method/limit kwargs here",
        "createdAt" : "2020-02-28T02:43:58Z",
        "updatedAt" : "2020-04-08T05:16:56Z",
        "lastEditedBy" : "adf621f1-4745-479a-a1fc-dc14046a3f4b",
        "tags" : [
        ]
      },
      {
        "id" : "c72dc5f4-751c-4987-a626-a8d30cb6ed8d",
        "parentId" : "f26267a2-8561-4cdb-a026-f9d314b15ca0",
        "authorId" : "6abd9a80-6299-4d68-abce-f7c35c958f83",
        "body" : "I did this to preserve the existing abstractions (i.e. MultiIndex defers to its engine on the implementation for `get_indexer()`), but if you'd prefer, I can definitely just change this to return the codes which will be the inputs to `algos.(pad|backfill)`",
        "createdAt" : "2020-02-28T18:42:03Z",
        "updatedAt" : "2020-04-08T05:16:56Z",
        "lastEditedBy" : "6abd9a80-6299-4d68-abce-f7c35c958f83",
        "tags" : [
        ]
      },
      {
        "id" : "9c35d3c9-65d9-4745-819e-9c63578d98a7",
        "parentId" : "f26267a2-8561-4cdb-a026-f9d314b15ca0",
        "authorId" : "adf621f1-4745-479a-a1fc-dc14046a3f4b",
        "body" : "not a strong preference",
        "createdAt" : "2020-02-29T17:49:29Z",
        "updatedAt" : "2020-04-08T05:16:56Z",
        "lastEditedBy" : "adf621f1-4745-479a-a1fc-dc14046a3f4b",
        "tags" : [
        ]
      }
    ],
    "commit" : "7836cc90767ba0f652065b65a5d6d26440f2d384",
    "line" : 125,
    "diffHunk" : "@@ -1,1 +718,722 @@        sorted_indexer = (\n            algos.backfill if method == \"backfill\" else algos.pad\n        )(new_codes, new_target_codes, limit=limit).astype('int64')\n        return sorted_indexer[np.argsort(target_order)]\n"
  },
  {
    "id" : "18689860-aa55-4f84-90b3-6e14f77809c7",
    "prId" : 30902,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/30902#pullrequestreview-344949939",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "69a1c04f-13bb-485a-ad75-25b560fb7c3f",
        "parentId" : null,
        "authorId" : "554ba0f6-6e6a-40c3-98e0-1a6cc4a8e1c6",
        "body" : "can val be typed as Hashable, (comment then not needed?)",
        "createdAt" : "2020-01-11T10:03:15Z",
        "updatedAt" : "2020-01-19T21:48:55Z",
        "lastEditedBy" : "554ba0f6-6e6a-40c3-98e0-1a6cc4a8e1c6",
        "tags" : [
        ]
      },
      {
        "id" : "f6083ebb-f8ef-4256-bb2e-49b4cbf054bf",
        "parentId" : "69a1c04f-13bb-485a-ad75-25b560fb7c3f",
        "authorId" : "adf621f1-4745-479a-a1fc-dc14046a3f4b",
        "body" : "im planning to add more assumptions to the comment in future PRs",
        "createdAt" : "2020-01-11T17:13:06Z",
        "updatedAt" : "2020-01-19T21:48:55Z",
        "lastEditedBy" : "adf621f1-4745-479a-a1fc-dc14046a3f4b",
        "tags" : [
        ]
      },
      {
        "id" : "46c4778d-486a-4056-b1d7-1838b1d447e6",
        "parentId" : "69a1c04f-13bb-485a-ad75-25b560fb7c3f",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "you *could* add an assert",
        "createdAt" : "2020-01-18T16:05:58Z",
        "updatedAt" : "2020-01-19T21:48:55Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "892c9c2a512fa9ae76fc9f3a7a2b2b553421990b",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +74,78 @@\n    def __contains__(self, val: object) -> bool:\n        # We assume before we get here:\n        #  - val is hashable\n        self._ensure_mapping_populated()"
  },
  {
    "id" : "d2ff6342-8a5a-492f-9ace-bacedeeee60f",
    "prId" : 30902,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/30902#pullrequestreview-341515014",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "873c3325-832f-4ccd-ba5d-8254d6287a28",
        "parentId" : null,
        "authorId" : "554ba0f6-6e6a-40c3-98e0-1a6cc4a8e1c6",
        "body" : "same",
        "createdAt" : "2020-01-11T10:04:03Z",
        "updatedAt" : "2020-01-19T21:48:55Z",
        "lastEditedBy" : "554ba0f6-6e6a-40c3-98e0-1a6cc4a8e1c6",
        "tags" : [
        ]
      }
    ],
    "commit" : "892c9c2a512fa9ae76fc9f3a7a2b2b553421990b",
    "line" : 18,
    "diffHunk" : "@@ -1,1 +417,421 @@        return scalar.value\n\n    def __contains__(self, val: object) -> bool:\n        # We assume before we get here:\n        #  - val is hashable"
  },
  {
    "id" : "5e5ed796-72ef-49e4-b045-11077d621154",
    "prId" : 30902,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/30902#pullrequestreview-341515014",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a49af114-b442-4582-85ac-1e8350c9a296",
        "parentId" : null,
        "authorId" : "554ba0f6-6e6a-40c3-98e0-1a6cc4a8e1c6",
        "body" : "same",
        "createdAt" : "2020-01-11T10:04:10Z",
        "updatedAt" : "2020-01-19T21:48:55Z",
        "lastEditedBy" : "554ba0f6-6e6a-40c3-98e0-1a6cc4a8e1c6",
        "tags" : [
        ]
      }
    ],
    "commit" : "892c9c2a512fa9ae76fc9f3a7a2b2b553421990b",
    "line" : 29,
    "diffHunk" : "@@ -1,1 +716,720 @@        return indexer\n\n    def __contains__(self, val: object) -> bool:\n        # We assume before we get here:\n        #  - val is hashable"
  },
  {
    "id" : "fdcc883c-60f6-46f5-922b-85e6bb819d5c",
    "prId" : 31510,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/31510#pullrequestreview-351964675",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0a125960-ab0c-431d-997e-a340afac622b",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "can you not just do \r\n\r\nelsif (.....) as by-definition they are not bools at this point.",
        "createdAt" : "2020-02-02T19:42:09Z",
        "updatedAt" : "2020-02-02T19:42:20Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "6218f442-b2cc-40b2-9bb9-18f165fc9dd0",
        "parentId" : "0a125960-ab0c-431d-997e-a340afac622b",
        "authorId" : "adf621f1-4745-479a-a1fc-dc14046a3f4b",
        "body" : "the case where issubclass(dtype.type, np.integer) will pass through in both cases i think",
        "createdAt" : "2020-02-02T20:20:56Z",
        "updatedAt" : "2020-02-02T20:20:57Z",
        "lastEditedBy" : "adf621f1-4745-479a-a1fc-dc14046a3f4b",
        "tags" : [
        ]
      }
    ],
    "commit" : "88b7340bf34be55a74caa65e857a4a43c05cbd75",
    "line" : 44,
    "diffHunk" : "@@ -1,1 +585,589 @@            raise ValueError(\"Cannot assign nan to integer series\")\n\n    if (issubclass(dtype.type, (np.integer, np.floating, np.complex)) and\n            not issubclass(dtype.type, np.bool_)):\n        if util.is_bool_object(value):"
  }
]
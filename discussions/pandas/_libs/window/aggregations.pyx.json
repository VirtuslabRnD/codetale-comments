[
  {
    "id" : "4eeae559-7423-4a8d-84c5-39ebaf667e8b",
    "prId" : 29878,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/29878#pullrequestreview-326883692",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "86a46d35-0220-439d-ad06-ea988cbbb9d9",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "could we do a simple calculcate in start/end to determine if is_monotonic is true here? it likely is quite performant.",
        "createdAt" : "2019-12-04T14:25:38Z",
        "updatedAt" : "2019-12-04T21:56:53Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "7ce1967bf6298e53c5cb1483774aaa1e138d7d30",
    "line" : 15,
    "diffHunk" : "@@ -1,1 +200,204 @@            e = end[i]\n\n            if i == 0 or not is_monotonic_bounds:\n\n                # setup"
  },
  {
    "id" : "ac02527a-a956-4b07-9c42-ba91874c050d",
    "prId" : 31935,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/31935#pullrequestreview-359421894",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "14b10862-092f-4d9e-85ed-765ee676cb7a",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "hmm, why can't this *also* be in-line?",
        "createdAt" : "2020-02-15T01:07:47Z",
        "updatedAt" : "2020-02-15T01:07:47Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "2f998390-9535-42ba-b06a-4cbda08e3508",
        "parentId" : "14b10862-092f-4d9e-85ed-765ee676cb7a",
        "authorId" : "5e8c5ef2-940b-436e-9c5f-98ae5460128c",
        "body" : "This was the cause of the `warning: pandas/_libs/window/aggregations.pyx:60:4: Buffer unpacking not optimized away.` warning. @mroeschke suggested a potential inline approach that got rid of the warning and used memory views but caused test failures. Could still adjust a few things to make that work but I think without a larger effort this is the best option for now",
        "createdAt" : "2020-02-16T18:43:19Z",
        "updatedAt" : "2020-02-16T18:43:19Z",
        "lastEditedBy" : "5e8c5ef2-940b-436e-9c5f-98ae5460128c",
        "tags" : [
        ]
      },
      {
        "id" : "bcaa9914-9f2c-43fc-be53-11b4f248325a",
        "parentId" : "14b10862-092f-4d9e-85ed-765ee676cb7a",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "this is a highly optimized path\r\n\r\nif u can show this doesnâ€™t have any perf regressions then ok",
        "createdAt" : "2020-02-16T18:53:09Z",
        "updatedAt" : "2020-02-16T18:53:09Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "644055bb5adeca32f95a94cd36d4f9785c0f358d",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +57,61 @@cdef inline int int_min(int a, int b): return a if a <= b else b\n\ncdef bint is_monotonic_start_end_bounds(\n    ndarray[int64_t, ndim=1] start, ndarray[int64_t, ndim=1] end\n):"
  }
]
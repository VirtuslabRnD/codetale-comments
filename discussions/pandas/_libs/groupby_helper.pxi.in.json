[
  {
    "id" : "d95e0508-84cb-4b0b-ba86-4c4106b966d2",
    "prId" : 18876,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/18876#pullrequestreview-85150061",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ff566bf3-1a86-4dee-bdc5-4bf7ce4c3e92",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "does this work for ``min_count==0``?",
        "createdAt" : "2017-12-21T18:38:27Z",
        "updatedAt" : "2017-12-28T12:36:26Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "6f6b0c99-5a86-40e3-84b5-7bc86755e34d",
        "parentId" : "ff566bf3-1a86-4dee-bdc5-4bf7ce4c3e92",
        "authorId" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "body" : "Yeah, `sumx`  starts out as `zeros`, so we just have to avoid setting it to NaN. Same for `prod`, but with ones.",
        "createdAt" : "2017-12-21T18:49:41Z",
        "updatedAt" : "2017-12-28T12:36:26Z",
        "lastEditedBy" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "tags" : [
        ]
      }
    ],
    "commit" : "0e954f84d5e5b2eae643472031c7890da3d98814",
    "line" : 15,
    "diffHunk" : "@@ -1,1 +90,94 @@        for i in range(ncounts):\n            for j in range(K):\n                if nobs[i, j] < min_count:\n                    out[i, j] = NAN\n                else:"
  },
  {
    "id" : "b49c3865-da88-4fa7-b931-f669b8685eef",
    "prId" : 19481,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/19481#pullrequestreview-95401920",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "42f6daf2-d00f-4d31-862b-e0299f1253c2",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "any comments on the impl would be helpful (to future readers)",
        "createdAt" : "2018-02-08T01:23:31Z",
        "updatedAt" : "2018-02-09T18:37:11Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "d01bfa0a-4dd0-463c-bed3-7362ce0bf27f",
        "parentId" : "42f6daf2-d00f-4d31-862b-e0299f1253c2",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "nice comments!",
        "createdAt" : "2018-02-09T12:19:20Z",
        "updatedAt" : "2018-02-09T18:37:11Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "aa4578d78e5d4feaf6a8a3caac51acf7d2ebc112",
    "line" : 132,
    "diffHunk" : "@@ -1,1 +573,577 @@                        if ascending:\n                            out[_as[j], 0] = j + 1 - grp_start\n                        else:\n                            out[_as[j], 0] = 2 * i - j - dups + 2 - grp_start\n                elif tiebreak == TIEBREAK_DENSE:"
  },
  {
    "id" : "f9d5631c-3b20-434b-95c2-34d5eaf073ef",
    "prId" : 19610,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/19610#pullrequestreview-95294678",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7939ee53-b4f1-458c-baea-c31ef2f2a0f4",
        "parentId" : null,
        "authorId" : "5e8c5ef2-940b-436e-9c5f-98ae5460128c",
        "body" : "Was really hoping to not even have this conditional, but when trying `resx = np.empty_like(out)` and even `resx = np.empty_like(out, dtype='object')` it kept SegFaulting on objects",
        "createdAt" : "2018-02-09T01:44:42Z",
        "updatedAt" : "2018-02-09T03:29:45Z",
        "lastEditedBy" : "5e8c5ef2-940b-436e-9c5f-98ae5460128c",
        "tags" : [
        ]
      }
    ],
    "commit" : "fa63b47595546d4583b0fa7dbfd9e9bff393c76e",
    "line" : 24,
    "diffHunk" : "@@ -1,1 +363,367 @@    nobs = np.zeros((<object> out).shape, dtype=np.int64)\n    {{if name=='object'}}\n    resx = np.empty((<object> out).shape, dtype=object)\n    {{else}}\n    resx = np.empty_like(out)"
  },
  {
    "id" : "c9b2d826-4aee-44cc-9868-53696f3c0f0d",
    "prId" : 19679,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/19679#pullrequestreview-96268733",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c904b93b-51d4-4b8a-8ca1-4c911009dc30",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "yeah this prob returns a platform int. this is ok",
        "createdAt" : "2018-02-13T19:26:33Z",
        "updatedAt" : "2018-02-13T19:26:33Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "fe5245b28c150943713b40ab3bbf6953b23363f4",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +532,536 @@    # the mask helps you differentiate missing values before\n    # performing sort on the actual values\n    _as = np.lexsort(order).view(dtype=np.int64)\n\n    if not ascending:"
  },
  {
    "id" : "c30c0520-16b2-49dc-bbf2-fabc5913cb17",
    "prId" : 20681,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/20681#pullrequestreview-112236635",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fe8990a5-d064-4b89-a20f-427f67229443",
        "parentId" : null,
        "authorId" : "5e8c5ef2-940b-436e-9c5f-98ae5460128c",
        "body" : "This is tough to describe in one line so I'm not sure of the best way but I think it can be improved by simply changing \"groups\" to \"values\"",
        "createdAt" : "2018-04-14T15:33:05Z",
        "updatedAt" : "2018-04-21T18:23:09Z",
        "lastEditedBy" : "5e8c5ef2-940b-436e-9c5f-98ae5460128c",
        "tags" : [
        ]
      },
      {
        "id" : "163aa06f-7d3c-4641-9166-57300253ba4e",
        "parentId" : "fe8990a5-d064-4b89-a20f-427f67229443",
        "authorId" : "4cd6c97a-353d-414a-949a-1e0cfc3a0c8a",
        "body" : "https://github.com/pandas-dev/pandas/blob/5edc5c4acde1f0d05b598825ab5c6a86fe551484/pandas/core/groupby/groupby.py#L1848-L1857\r\n\r\nYes, I agree. It is hard to describe those methods. So I copied from there to save some time. Btw, there are some typos there too. I've raise another issue #20694. I think we should come up with something consistent for both places.",
        "createdAt" : "2018-04-15T12:46:48Z",
        "updatedAt" : "2018-04-21T18:23:09Z",
        "lastEditedBy" : "4cd6c97a-353d-414a-949a-1e0cfc3a0c8a",
        "tags" : [
        ]
      }
    ],
    "commit" : "6eb1d8fbfa094d2b9ed2edd789d76e9345eb3cbe",
    "line" : 24,
    "diffHunk" : "@@ -1,1 +435,439 @@        * max: highest rank in group\n        * first: ranks assigned in order they appear in the array\n        * dense: like 'min', but rank always increases by 1 between groups\n    ascending : boolean, default True\n        False for ranks by high (1) to low (N)"
  },
  {
    "id" : "dfd3c385-717a-4e1d-bb64-8ddeec7f2b6f",
    "prId" : 21285,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/21285#pullrequestreview-127618462",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "82043385-98bb-483a-b1a7-f8af19de2060",
        "parentId" : null,
        "authorId" : "5e8c5ef2-940b-436e-9c5f-98ae5460128c",
        "body" : "Can this be simplified to just:\r\n\r\n```python\r\nif labels[_as[i]] == labels[_as[i+1]]:\r\n```\r\n\r\nSince all of the other conditions are already accounted for higher up in the scope?",
        "createdAt" : "2018-06-11T15:25:08Z",
        "updatedAt" : "2018-06-13T04:02:28Z",
        "lastEditedBy" : "5e8c5ef2-940b-436e-9c5f-98ae5460128c",
        "tags" : [
        ]
      }
    ],
    "commit" : "fbb05d40ff6435922110b3382f975af61f95d666",
    "line" : 94,
    "diffHunk" : "@@ -1,1 +555,559 @@                # coming up. the conditional also needs to handle nan equality\n                # and the end of iteration\n                if (i == N - 1 or\n                        (masked_vals[_as[i]] != masked_vals[_as[i+1]]) or\n                        (mask[_as[i]] ^ mask[_as[i+1]])):"
  },
  {
    "id" : "adb5c3cf-efed-439e-b16f-08d70aac178e",
    "prId" : 21285,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/21285#pullrequestreview-128028769",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0f41189e-0fa2-4409-90f9-c2d67338753d",
        "parentId" : null,
        "authorId" : "5e8c5ef2-940b-436e-9c5f-98ae5460128c",
        "body" : "If the above is true could maybe use else more effective here to reduce code",
        "createdAt" : "2018-06-11T15:27:21Z",
        "updatedAt" : "2018-06-13T04:02:28Z",
        "lastEditedBy" : "5e8c5ef2-940b-436e-9c5f-98ae5460128c",
        "tags" : [
        ]
      },
      {
        "id" : "6f6863ce-d498-4236-b277-32210bb6a9c1",
        "parentId" : "0f41189e-0fa2-4409-90f9-c2d67338753d",
        "authorId" : "4cd6c97a-353d-414a-949a-1e0cfc3a0c8a",
        "body" : "How about i == N -1 scenario ? I can rewrite it to the following\r\n``` \r\nIf labels[_as[i]] == labels[_as[i+1]]:  (_increment temp values_) \r\n else: (_setting grp_size_)\r\n```\r\nThis is not equivalent to my current fix.\r\nThose two clauses are mutually exclusive. Then I have to do,\r\n```\r\nlabels[_as[i]] == labels[_as[i+1]] and i != N -1: ( _increment temp values_) \r\nelif i==N-1: (_increment temp values and set grp_size_)\r\nelse: (_set grp_size_)\r\n```\r\nIt is less readable",
        "createdAt" : "2018-06-12T05:03:59Z",
        "updatedAt" : "2018-06-13T04:02:28Z",
        "lastEditedBy" : "4cd6c97a-353d-414a-949a-1e0cfc3a0c8a",
        "tags" : [
        ]
      },
      {
        "id" : "d974ac76-f6c7-4b48-850c-f9d3e94cbb80",
        "parentId" : "0f41189e-0fa2-4409-90f9-c2d67338753d",
        "authorId" : "5e8c5ef2-940b-436e-9c5f-98ae5460128c",
        "body" : "Hmm OK thanks for talking me through - I think you are right that that wouldn't improve readability. ",
        "createdAt" : "2018-06-12T15:45:10Z",
        "updatedAt" : "2018-06-13T04:02:28Z",
        "lastEditedBy" : "5e8c5ef2-940b-436e-9c5f-98ae5460128c",
        "tags" : [
        ]
      }
    ],
    "commit" : "fbb05d40ff6435922110b3382f975af61f95d666",
    "line" : 107,
    "diffHunk" : "@@ -1,1 +568,572 @@                # group encountered (used by pct calculations later). also be\n                # sure to reset any of the items helping to calculate dups\n                if i == N - 1 or labels[_as[i]] != labels[_as[i+1]]:\n                    if tiebreak != TIEBREAK_DENSE:\n                        for j in range(grp_start, i + 1):"
  }
]
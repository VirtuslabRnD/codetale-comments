[
  {
    "id" : "099e0c45-04a5-4e78-8162-3b326a4398ed",
    "prId" : 10370,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9246a6d0-75b6-4f37-8ccb-29a53be36bd4",
        "parentId" : null,
        "authorId" : "40104112-cdcf-4812-8f95-b502b40e346d",
        "body" : "So the downside here is that if you install from master without using git and without installing from a directory with the version number in it, you end up with an unknown version?\n\nIn contrast, the current code _does_ have a known version in that case.\n",
        "createdAt" : "2015-06-17T22:15:46Z",
        "updatedAt" : "2015-07-06T15:25:41Z",
        "lastEditedBy" : "40104112-cdcf-4812-8f95-b502b40e346d",
        "tags" : [
        ]
      },
      {
        "id" : "5017e0ea-745d-41c9-aa5e-8fcfd886de5b",
        "parentId" : "9246a6d0-75b6-4f37-8ccb-29a53be36bd4",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "no I believe it will always have a version. Either its a release (e.g. with sdist), where versioneer embeds the actual version number in the output tar/gzip. or develop / clone where it picks up the latest tag. I am not sure how you would 'install from master without using git'. What you are looking at is a code path when its installing that CAN be hit but only if you don't have tags (or invalid ones or whatever)\n",
        "createdAt" : "2015-06-17T23:17:10Z",
        "updatedAt" : "2015-07-06T15:25:41Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "d13cdcbc-6377-40df-9cb9-6750efc08040",
        "parentId" : "9246a6d0-75b6-4f37-8ccb-29a53be36bd4",
        "authorId" : "40104112-cdcf-4812-8f95-b502b40e346d",
        "body" : "I agree that this is pretty unlikely, probably not worth worrying about. But it is theoretically possible, e.g., if I blindly copying the pandas source directory to a machine without git installed.\n",
        "createdAt" : "2015-06-18T00:03:02Z",
        "updatedAt" : "2015-07-06T15:25:41Z",
        "lastEditedBy" : "40104112-cdcf-4812-8f95-b502b40e346d",
        "tags" : [
        ]
      },
      {
        "id" : "66e4bc78-44ae-4b08-9001-ce56671031c5",
        "parentId" : "9246a6d0-75b6-4f37-8ccb-29a53be36bd4",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "should try it. see what happens. I wonder what it would do with currrent master.\n",
        "createdAt" : "2015-06-18T00:03:59Z",
        "updatedAt" : "2015-07-06T15:25:41Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "c4a0147c9e46c6b43501e126609c6d16c3eff2ba",
    "line" : 458,
    "diffHunk" : "@@ -1,1 +456,460 @@        pass\n\n    return {\"version\": \"0+unknown\", \"full-revisionid\": None,\n            \"dirty\": None,\n            \"error\": \"unable to compute version\"}"
  },
  {
    "id" : "de6b2677-ba21-49e0-a319-fe30488ae85b",
    "prId" : 25949,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/25949#pullrequestreview-221754834",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2ca3dc8e-8f5c-4ac6-9177-e0f06bce1ad1",
        "parentId" : null,
        "authorId" : "5e8c5ef2-940b-436e-9c5f-98ae5460128c",
        "body" : "Glancing at existing code it looks like we could still be more strict about the type here. Any reason to not specify the ReturnType of the callable here? Looks to always be a dict",
        "createdAt" : "2019-04-02T15:09:07Z",
        "updatedAt" : "2019-04-02T15:09:07Z",
        "lastEditedBy" : "5e8c5ef2-940b-436e-9c5f-98ae5460128c",
        "tags" : [
        ]
      },
      {
        "id" : "ab7a48a2-5d08-46b6-8ce9-ad2ed1897636",
        "parentId" : "2ca3dc8e-8f5c-4ac6-9177-e0f06bce1ad1",
        "authorId" : "da5e950e-9d1c-4a15-b601-82b67f80b78f",
        "body" : "ok, can do that.",
        "createdAt" : "2019-04-02T15:48:54Z",
        "updatedAt" : "2019-04-02T15:48:54Z",
        "lastEditedBy" : "da5e950e-9d1c-4a15-b601-82b67f80b78f",
        "tags" : [
        ]
      },
      {
        "id" : "37cc95a9-ad01-488f-baca-f0355f022245",
        "parentId" : "2ca3dc8e-8f5c-4ac6-9177-e0f06bce1ad1",
        "authorId" : "da5e950e-9d1c-4a15-b601-82b67f80b78f",
        "body" : "@WillAyd on a closer look, isn't the method `register_vcs_handler` returning a method(callable) `decorate` which returns another method `f` which is the method which is decorated. And the method `f` is returning `dict` I think.\r\nSo I think it will be something like this:\r\n\r\n    def register_vcs_handler(vcs: str, method: str) -> Callable[[Callable], Callable[[], Dict[str, str]]]:\r\n\r\nAnd what to do about the args the method `f`(the method which is getting decorated) as it's args might vary. Usually we would do `*args, **kwargs` in these situations but there is no such option in mypy.",
        "createdAt" : "2019-04-02T16:01:16Z",
        "updatedAt" : "2019-04-02T16:01:17Z",
        "lastEditedBy" : "da5e950e-9d1c-4a15-b601-82b67f80b78f",
        "tags" : [
        ]
      }
    ],
    "commit" : "3ed8317251e1137f8fc7fe47583e9a91209922c6",
    "line" : 19,
    "diffHunk" : "@@ -1,1 +53,57 @@\n\ndef register_vcs_handler(vcs: str, method: str) -> Callable:  # decorator\n    def decorate(f: Callable) -> Callable:\n        if vcs not in HANDLERS:"
  }
]
[
  {
    "id" : "e71956e2-b303-4cca-adf2-87057f961920",
    "prId" : 4108,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f0e4ff17-747e-4b52-886c-cd9a80e79d15",
        "parentId" : null,
        "authorId" : "6f890fbc-4bdf-4397-95eb-a8225d4af04f",
        "body" : "@jreback FYI: this format isn't Python 3 compatible, better to use `except Exception as detail` and frankly you could collapse all of these lines into:\n\n``` python\nassertRaisesRegexp(TypeError, \"incompatible index of inserted column with frame index\", df.__setitem__, 'gr', df.groupby(['b', 'c']).count())\n```\n\nor \n\n``` python\ndef testit(): df['gr'] = df.groupby(['b', 'c']).count()\nassertRaisesRegexp(TypeError, \"incompatible index of inserted column with frame index\", testit)\n```\n",
        "createdAt" : "2013-07-03T01:55:58Z",
        "updatedAt" : "2013-07-03T01:55:58Z",
        "lastEditedBy" : "6f890fbc-4bdf-4397-95eb-a8225d4af04f",
        "tags" : [
        ]
      },
      {
        "id" : "ae4494c9-9359-4040-94cd-b50f898b3ac3",
        "parentId" : "f0e4ff17-747e-4b52-886c-cd9a80e79d15",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "I think 2to3 changes in any event\n\nthis test (and one above about constructor error msgs) should prob be changed then\n",
        "createdAt" : "2013-07-03T01:58:23Z",
        "updatedAt" : "2013-07-03T01:58:23Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "67c10cc2177581888b7ed323abb01b29280b7c3a",
    "line" : 12,
    "diffHunk" : "@@ -1,1 +2259,2263 @@        try:\n            df['gr'] = df.groupby(['b', 'c']).count()\n        except (Exception), detail:\n            msg = 'incompatible index of inserted column with frame index'\n            self.assert_(type(detail) == TypeError)"
  },
  {
    "id" : "e3a9c63f-65e3-4c33-831d-f2b4e6365bb6",
    "prId" : 4953,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8f12bcf5-66cd-4f20-afbd-69ec585d3c78",
        "parentId" : null,
        "authorId" : "aeb7e171-52e2-4faa-8a7c-32d6a9d2c2be",
        "body" : "Maybe I've been confused by this statement (that bool comparisons always return bool?) This isn't #4947.... :s\n",
        "createdAt" : "2013-10-01T03:54:58Z",
        "updatedAt" : "2013-10-01T13:13:33Z",
        "lastEditedBy" : "aeb7e171-52e2-4faa-8a7c-32d6a9d2c2be",
        "tags" : [
        ]
      }
    ],
    "commit" : "0de04598a0b6cd2bae447b8d0c920c5588c77baf",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +4525,4529 @@\n        # GH4947\n        # bool comparisons should return bool\n        result = d['a'] | d['b']\n        expected = Series([False, True])"
  },
  {
    "id" : "3e9f7583-1279-43d4-a216-9104c9b07be2",
    "prId" : 5740,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5f7c8dcd-28ec-4125-bef6-6489a3460b0b",
        "parentId" : null,
        "authorId" : "6f890fbc-4bdf-4397-95eb-a8225d4af04f",
        "body" : "why is this test case here?\n",
        "createdAt" : "2013-12-19T06:02:42Z",
        "updatedAt" : "2014-02-17T07:56:29Z",
        "lastEditedBy" : "6f890fbc-4bdf-4397-95eb-a8225d4af04f",
        "tags" : [
        ]
      },
      {
        "id" : "9a7509bf-a632-421a-951f-d8533ebdf5b8",
        "parentId" : "5f7c8dcd-28ec-4125-bef6-6489a3460b0b",
        "authorId" : "413be534-cedb-4df7-abda-cde26db33acd",
        "body" : "there's a case below that tests an empty slice of dataframe with columns having different dtypes, I couldn't resist adding two more asserts just to be sure that the result matches that of non-empty slice.\n",
        "createdAt" : "2013-12-19T06:55:03Z",
        "updatedAt" : "2014-02-17T07:56:29Z",
        "lastEditedBy" : "413be534-cedb-4df7-abda-cde26db33acd",
        "tags" : [
        ]
      },
      {
        "id" : "de94b13b-6db4-4fcb-94e3-283ed6378865",
        "parentId" : "5f7c8dcd-28ec-4125-bef6-6489a3460b0b",
        "authorId" : "413be534-cedb-4df7-abda-cde26db33acd",
        "body" : "Revisiting this comment after an hour I think I might have misattributed the question to the beginning of `df` case, so just in case: tests concerning `nocols_df`, `norows_df` and `norows_int_df` are about empty dataframes (empty in a sense that they contain no actual data cells) and all returned garbage before patching `dtype`/`ftype` funcs. \n",
        "createdAt" : "2013-12-19T08:02:34Z",
        "updatedAt" : "2014-02-17T07:56:29Z",
        "lastEditedBy" : "413be534-cedb-4df7-abda-cde26db33acd",
        "tags" : [
        ]
      }
    ],
    "commit" : "dfa8ec01c919e52785f9840fd3913aadf8521ff3",
    "line" : 22,
    "diffHunk" : "@@ -1,1 +12183,12187 @@\n        odict = OrderedDict\n        df = pd.DataFrame(odict([('a', 1), ('b', True), ('c', 1.0)]), index=[1, 2, 3])\n        assert_series_equal(df.dtypes, pd.Series(odict([('a', np.int64),\n                                                        ('b', np.bool),"
  },
  {
    "id" : "0ebf4f92-f548-4f1e-ab34-d9187228aaa6",
    "prId" : 5740,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "188e212c-ab1d-4d01-aa84-e0f3cea5ec46",
        "parentId" : null,
        "authorId" : "6f890fbc-4bdf-4397-95eb-a8225d4af04f",
        "body" : "@jreback does this make sense? dtype's just going to change once you assign something anyways, no?\n",
        "createdAt" : "2013-12-19T12:53:10Z",
        "updatedAt" : "2014-02-17T07:56:29Z",
        "lastEditedBy" : "6f890fbc-4bdf-4397-95eb-a8225d4af04f",
        "tags" : [
        ]
      },
      {
        "id" : "2f13668a-a355-4021-bddb-121cb37fb6b8",
        "parentId" : "188e212c-ab1d-4d01-aa84-e0f3cea5ec46",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "this is fine; yes dtype will change once you assign something\n",
        "createdAt" : "2013-12-19T13:26:47Z",
        "updatedAt" : "2014-02-17T07:56:29Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "dfa8ec01c919e52785f9840fd3913aadf8521ff3",
    "line" : 18,
    "diffHunk" : "@@ -1,1 +12179,12183 @@\n        norows_int_df = pd.DataFrame(columns=list(\"abc\")).astype(np.int32)\n        assert_series_equal(norows_int_df.dtypes, pd.Series(np.dtype('int32'), index=list(\"abc\")))\n        assert_series_equal(norows_int_df.ftypes, pd.Series('int32:dense', index=list(\"abc\")))\n"
  },
  {
    "id" : "095d9d8b-a35c-4dd9-a40b-2aa64bf79d6c",
    "prId" : 6646,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "29c4d643-ca35-4523-a7ff-8e17dab57e28",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "should this be `elif`?\n",
        "createdAt" : "2014-06-17T11:20:39Z",
        "updatedAt" : "2014-06-17T11:20:39Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "95e002a8-abf2-4175-b7a9-da27a37fafac",
        "parentId" : "29c4d643-ca35-4523-a7ff-8e17dab57e28",
        "authorId" : "81a3548e-1c7e-4995-a387-963251f3eee9",
        "body" : "I think so -- otherwise won't the `else` always be taken if r_dtype=='u'? And the parallel `if c_dtype:` version has `elif:`.\n",
        "createdAt" : "2014-06-17T12:10:54Z",
        "updatedAt" : "2014-06-17T12:10:54Z",
        "lastEditedBy" : "81a3548e-1c7e-4995-a387-963251f3eee9",
        "tags" : [
        ]
      },
      {
        "id" : "c290e70d-cbbd-4197-833f-f51b4b2664e2",
        "parentId" : "29c4d643-ca35-4523-a7ff-8e17dab57e28",
        "authorId" : "81a3548e-1c7e-4995-a387-963251f3eee9",
        "body" : "If we want to fix that, I can make a separate one-line PR.\n",
        "createdAt" : "2014-06-17T20:38:39Z",
        "updatedAt" : "2014-06-17T20:38:39Z",
        "lastEditedBy" : "81a3548e-1c7e-4995-a387-963251f3eee9",
        "tags" : [
        ]
      }
    ],
    "commit" : "80fc82eb56d8bf789f908dc1d45b83e33b5bd456",
    "line" : 236,
    "diffHunk" : "@@ -1,1 +5749,5753 @@                                            dtype=r_dtype)\n                    df.index = np.array(lmap(_to_uni,df.index),dtype=r_dtype)\n                if r_dtype == 'dt': # unicode\n                    r_dtype='O'\n                    recons.index = np.array(lmap(Timestamp,recons.index),"
  },
  {
    "id" : "a93a017d-7d95-4c41-a926-9dbb25d23b67",
    "prId" : 6736,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "64907f72-8447-4b8c-bce0-9ef4e120101a",
        "parentId" : null,
        "authorId" : "6f890fbc-4bdf-4397-95eb-a8225d4af04f",
        "body" : "let's give at least one of these an `errors='raise'` argument (and add it to an existing test that doesn't raise) just for completeness.\n",
        "createdAt" : "2014-03-30T05:22:22Z",
        "updatedAt" : "2015-04-04T21:49:30Z",
        "lastEditedBy" : "6f890fbc-4bdf-4397-95eb-a8225d4af04f",
        "tags" : [
        ]
      }
    ],
    "commit" : "a2620d7ab9cfa6ffda0665c72290aa7a85371757",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +7411,7415 @@\n        self.assertRaises(ValueError, df.drop, ['g'])\n        self.assertRaises(ValueError, df.drop, ['g'], 1)\n\n        # errors = 'ignore'"
  },
  {
    "id" : "ce74ec96-6aaa-49a0-b32d-43b8724a7b72",
    "prId" : 8041,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a52b894b-e924-4ee8-9b2c-458810b37df6",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "put the issue number here in a comment\n",
        "createdAt" : "2014-08-15T17:18:09Z",
        "updatedAt" : "2014-08-18T14:19:55Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "86319723b4ab74dfd2f6bc0f99977e1eaff5c832",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +9611,9615 @@        assert_frame_equal(rs, xp)\n\n    def test_shift_empty(self):\n        # Regression test for #8019\n        df = DataFrame({'foo': []})"
  },
  {
    "id" : "7a5eab84-aa74-4054-b98b-ae130c934a0b",
    "prId" : 8119,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "abcd8cc0-daf2-4f40-a98f-7da0bf9e475b",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "can u test with series as well (in test_series) - IF their is not a test already\n",
        "createdAt" : "2014-08-29T14:16:04Z",
        "updatedAt" : "2014-08-29T14:16:04Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "17c4d4cc-10d3-4727-8a74-683a4c12952d",
        "parentId" : "abcd8cc0-daf2-4f40-a98f-7da0bf9e475b",
        "authorId" : "93252f0a-20fd-4fff-a21f-b220eed58210",
        "body" : "for series it goes through a different [code path](https://github.com/pydata/pandas/blob/master/pandas/core/ops.py#L510) and it is already doing fine. \n",
        "createdAt" : "2014-08-29T16:17:34Z",
        "updatedAt" : "2014-08-29T16:17:34Z",
        "lastEditedBy" : "93252f0a-20fd-4fff-a21f-b220eed58210",
        "tags" : [
        ]
      }
    ],
    "commit" : "b3412b38ecc3d07dbe451e666edec5bb3512bd8b",
    "line" : 12,
    "diffHunk" : "@@ -1,1 +4721,4725 @@\n        for x in xs:\n            assert_frame_equal(df / np.array(x), f(vals / x))\n            assert_frame_equal(np.array(x) * df, f(vals * x))\n            assert_frame_equal(df + np.array(x), f(vals + x))"
  },
  {
    "id" : "cdd5b323-e15b-4416-9e70-1f8bfed94795",
    "prId" : 9061,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7b3bd335-ab8e-47b7-9e50-1a40746338f4",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "pls give a tests for multiple nans in a single level and a single nan but in multiple levels. (which you prob just raise a ValueError as it cannot be computed).\n",
        "createdAt" : "2014-12-20T19:58:59Z",
        "updatedAt" : "2014-12-22T00:16:08Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "b0c8aa43-0397-41a9-b02a-10a1095007da",
        "parentId" : "7b3bd335-ab8e-47b7-9e50-1a40746338f4",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "actually I see you do handle this. BUT, the problem is the resulting index are full of nan levels. Hmm. This should be a warning or maybe an option to unstack/pivot. You get a useful result, but then indexing will blow up.\n",
        "createdAt" : "2014-12-20T20:01:00Z",
        "updatedAt" : "2014-12-22T00:16:08Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "2e21b821-6c74-40dc-aecf-2ee8c08370ad",
        "parentId" : "7b3bd335-ab8e-47b7-9e50-1a40746338f4",
        "authorId" : "93252f0a-20fd-4fff-a21f-b220eed58210",
        "body" : "> the problem is the resulting index are full of nan levels\n\n@jreback  no! there will be no nan in the levels and there is no nan level. see the last lines in the very first comment, or check `df.unstack().index.levels`. nan's are handled by labels. also, the point of running benchmarks is that this way of handling nan's does not impact performance.\n",
        "createdAt" : "2014-12-20T20:14:54Z",
        "updatedAt" : "2014-12-22T00:16:08Z",
        "lastEditedBy" : "93252f0a-20fd-4fff-a21f-b220eed58210",
        "tags" : [
        ]
      },
      {
        "id" : "c526d1c9-0470-407b-bb58-4773edf475e9",
        "parentId" : "7b3bd335-ab8e-47b7-9e50-1a40746338f4",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "it is not a question of performance but of subsequent indexing. Having nan in the levels is currently restricted to a single nan for indexing. They make the indexes non-unique by definition and when you try to look up the locations they will fail. You can only do positional type indexing. So you leave the user with an odd structure that only partially works.\n",
        "createdAt" : "2014-12-20T20:40:40Z",
        "updatedAt" : "2014-12-22T00:16:08Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "cddd0599-9d48-4061-911f-3d1637cd6cbd",
        "parentId" : "7b3bd335-ab8e-47b7-9e50-1a40746338f4",
        "authorId" : "93252f0a-20fd-4fff-a21f-b220eed58210",
        "body" : "my point was that this is handling nan without polluting the levels or impacting performance.\n\ncomments addressed, and all came green.\n",
        "createdAt" : "2014-12-21T13:40:23Z",
        "updatedAt" : "2014-12-22T00:16:08Z",
        "lastEditedBy" : "93252f0a-20fd-4fff-a21f-b220eed58210",
        "tags" : [
        ]
      }
    ],
    "commit" : "e3afd5b7b948f1438553a2194937d3b094ef262a",
    "line" : 28,
    "diffHunk" : "@@ -1,1 +12350,12354 @@        df = DataFrame({'jim':['a', 'b', nan, 'd'],\n                        'joe':['w', 'x', 'y', 'z'],\n                        'jolie':['a.w', 'b.x', ' .y', 'd.z']})\n\n        left  = df.set_index(['jim', 'joe']).unstack()['jolie']"
  },
  {
    "id" : "d7aa5acf-3458-4b00-9033-89b392325aa2",
    "prId" : 9292,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "88467638-ca70-46d5-803c-31171a8a35db",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "can you specify dtypes to the `np.zeros` constructor? (otherwise you have a platform comparison issue)\n",
        "createdAt" : "2015-01-19T00:27:34Z",
        "updatedAt" : "2015-01-26T00:10:15Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "480ab1da-afb4-492c-8eda-1f9169e83b61",
        "parentId" : "88467638-ca70-46d5-803c-31171a8a35db",
        "authorId" : "93252f0a-20fd-4fff-a21f-b220eed58210",
        "body" : "i do not think `np.zeros` requires dtypes here, because `left` and `right` frame are both defined off the `df` frame here. i would rather keep this replicate of https://github.com/pydata/pandas/issues/7405. also, in the 2nd iteration of for loop there is `np.arange` with explicit data type.\n",
        "createdAt" : "2015-01-19T02:00:05Z",
        "updatedAt" : "2015-01-26T00:10:15Z",
        "lastEditedBy" : "93252f0a-20fd-4fff-a21f-b220eed58210",
        "tags" : [
        ]
      }
    ],
    "commit" : "e513486e6c101ef91d0726428b2dcdb208a82475",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +12330,12334 @@\n        # GH7405\n        for c, d in (np.zeros(5), np.zeros(5)), \\\n                    (np.arange(5, dtype='f8'), np.arange(5, 10, dtype='f8')):\n"
  },
  {
    "id" : "562ebfee-48b8-47ce-b5c9-1ee8f4730ea4",
    "prId" : 9292,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3461e22b-8907-41cb-98fb-3713855c7f87",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "can you add addtl test that has a `tz` and `freq` attached? (or 2 addtl tests)\n",
        "createdAt" : "2015-01-19T00:29:28Z",
        "updatedAt" : "2015-01-26T00:10:15Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "b68a77b8-e07a-4398-84bb-62ae25415a45",
        "parentId" : "3461e22b-8907-41cb-98fb-3713855c7f87",
        "authorId" : "93252f0a-20fd-4fff-a21f-b220eed58210",
        "body" : "it is tested in [`test_pivot_with_tz`](https://github.com/pydata/pandas/blob/fda50121453f76142b00ff57b017b8a3ef692f69/pandas/tools/tests/test_pivot.py#L187)\n",
        "createdAt" : "2015-01-19T01:31:14Z",
        "updatedAt" : "2015-01-26T00:10:15Z",
        "lastEditedBy" : "93252f0a-20fd-4fff-a21f-b220eed58210",
        "tags" : [
        ]
      }
    ],
    "commit" : "e513486e6c101ef91d0726428b2dcdb208a82475",
    "line" : 74,
    "diffHunk" : "@@ -1,1 +12449,12453 @@        # GH7401\n        df = pd.DataFrame({'A': list('aaaaabbbbb'), 'C':np.arange(10),\n            'B':date_range('2012-01-01', periods=5).tolist()*2 })\n\n        df.iloc[3,1] = np.NaN"
  },
  {
    "id" : "1784961c-54d6-4314-902d-d5b5ff1082be",
    "prId" : 9292,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0d170810-dad8-4fe0-bf0e-d9158a7bc5c5",
        "parentId" : null,
        "authorId" : "8b404822-a597-42dd-b567-818788cb72c8",
        "body" : "It may not be obvious (at least it wasn't to me), but `idx = Index([nan, 0, 1, 2, 4, 5, 6, 7], name='B')` results in `Float64Index([nan, 0.0, 1.0, 2.0, 4.0, 5.0, 6.0, 7.0], dtype='float64')` -- i.e. the integer _levels_ (i.e. what the user sees) get converted to floats. Thus you are testing that when unstacking a MultiIndex that leaves a single level with integer labels and `NaN`s, the result is a `Float64Index`. This is pretty much unavoidable -- unless you explicitly cast the integers to `object`s rather than `float64` -- as MultIndex doesn't seem to support a single level. (Note that an integer  MultiIndex level can have missing values, since they are represented by `-1` in the labels and not `NaN` in the labels.) I think either (a) MultIndex should support a single level (and not convert to an Index), or (b) the unstacking code should convert such an integer-with-NaN index to `object` rather than `float64`. [I encountered this issue while trying to make the `stack()` code handle `NaN` labels propertly.]\n",
        "createdAt" : "2015-02-12T02:34:32Z",
        "updatedAt" : "2015-02-12T02:37:40Z",
        "lastEditedBy" : "8b404822-a597-42dd-b567-818788cb72c8",
        "tags" : [
        ]
      },
      {
        "id" : "0f0540c1-e8a9-4b75-afa9-409b15581946",
        "parentId" : "0d170810-dad8-4fe0-bf0e-d9158a7bc5c5",
        "authorId" : "93252f0a-20fd-4fff-a21f-b220eed58210",
        "body" : "> unless you explicitly cast the integers to objects rather than float64\n\nI actually explicitly [cast to objects](https://github.com/pydata/pandas/blob/726e892e22ef85883b135472102ae435388a6196/pandas/core/reshape.py#L238) not float64. the index comes out as float because of type inference in [`Index.__new__`](https://github.com/pydata/pandas/blob/726e892e22ef85883b135472102ae435388a6196/pandas/core/index.py#L195), not in unstacking code.\n\n```\n>>> i\narray([nan, 1, 2], dtype=object)\n>>> type(i[1])\n<class 'int'>\n>>> Index(i)\nFloat64Index([nan, 1.0, 2.0], dtype='float64')\n```\n",
        "createdAt" : "2015-02-12T11:47:39Z",
        "updatedAt" : "2015-02-12T11:47:39Z",
        "lastEditedBy" : "93252f0a-20fd-4fff-a21f-b220eed58210",
        "tags" : [
        ]
      },
      {
        "id" : "e2a0defb-360b-4f15-8201-29a95aa42330",
        "parentId" : "0d170810-dad8-4fe0-bf0e-d9158a7bc5c5",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "you have to specify a dtype=object when constructing an index to not have it coerce (if u want it to explicitly preserve it)\nthough can't think of a reason you would ever actually want to do this\n\nif u really mean integer then we use -1 as a sentinel in the indexers and they are left as ints\n",
        "createdAt" : "2015-02-12T12:23:08Z",
        "updatedAt" : "2015-02-12T12:23:08Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "9a9abaf3-d28c-4378-9f42-ae6b013b5e08",
        "parentId" : "0d170810-dad8-4fe0-bf0e-d9158a7bc5c5",
        "authorId" : "8b404822-a597-42dd-b567-818788cb72c8",
        "body" : "@behzadnouri, yes, precisely, _here_ the conversion of ints to foats is done by `Index.__new__`. However since this is being compared to the results of `left = df.set_index(['A', 'B']).unstack(0)`, clearly the `unstack()` code is also doing such a conversion.\n\n@jreback, understood. Two points:\n\nFirst, other than specifying `dtype='object'`, there doesn't seem to be a way to construct a (single-level) index of _int_s with `NaN`s. In a `MultiIndex` with more than one level, a level can be `int` with `NaN`s, but a `MultiIndex` with a single level gets converted automatically to an `Index`, and in the case of an `int` level with `NaN`s, a `Float64Index`.\n\n```\nIn [27]: pd.Index([nan, 1, 2])  # note automatic conversion to Float64Index\nOut[27]: Float64Index([nan, 1.0, 2.0], dtype='float64')\n\nIn [29]: pd.MultiIndex.from_tuples([(nan,), (1,), (2,)])  # note automatic conversion to Float64Index\nOut[29]: Float64Index([nan, 1.0, 2.0], dtype='float64')\n\nIn [30]: pd.MultiIndex.from_tuples([(nan, 'a'), (1, 'a'), (2, 'a')])\nOut[30]:\nMultiIndex(levels=[[1, 2], ['a']],\n           labels=[[-1, 0, 1], [0, 0, 0]])\n\nIn [31]: pd.MultiIndex.from_tuples([(nan, 'a'), (1, 'a'), (2, 'a')]).levels[0]\nOut[31]: Int64Index([1, 2], dtype='int64')  # note first level is Int64Index\n```\n\nSecond, my point is that in the course of stacking and/or unstacking (and perhaps other operations), a single level in a multi-level `MultiIndex` can be \"promoted\" to be an `Index` unto itself, and in that case seems (at least currently in the case of `stack()` and `unstack()`) to be changed from ints to floats, which I don't think is a good thing to do to index values.\n",
        "createdAt" : "2015-02-12T17:17:16Z",
        "updatedAt" : "2015-02-12T17:17:16Z",
        "lastEditedBy" : "8b404822-a597-42dd-b567-818788cb72c8",
        "tags" : [
        ]
      },
      {
        "id" : "74b08edb-de6e-418c-8e47-355de1491c6e",
        "parentId" : "0d170810-dad8-4fe0-bf0e-d9158a7bc5c5",
        "authorId" : "8b404822-a597-42dd-b567-818788cb72c8",
        "body" : "@behzadnouri, just to clarify, I don't doubt that within the unstacking code the conversion from ints to floats happens in `Index.__init__()`, but that doesn't change the fact that in such cases `unstack()` has the effect of converting ints to floats.\n\nThe reason I think this is a potential problem (which predates you, I'm sure, and is also present in `stack()`), is that if someone then wants to compare the values in the `Index` of the stacked/unstacked object to the values in the corresponding level of `MultiIndex` of the original `DataFrame`, they won't match.\n",
        "createdAt" : "2015-02-12T17:21:46Z",
        "updatedAt" : "2015-02-12T17:21:46Z",
        "lastEditedBy" : "8b404822-a597-42dd-b567-818788cb72c8",
        "tags" : [
        ]
      },
      {
        "id" : "dc4fbdae-8313-43e7-9937-e6e0f4a64c2a",
        "parentId" : "0d170810-dad8-4fe0-bf0e-d9158a7bc5c5",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "@seth-p I think the unstack/stack code need to explicity pass the dtype into when the Index is constructed.\n\nCurrently you cannot have nans in an Int64Index, so unless you mark it as object it will by definition be coerced. A multi-index can represent this, but single level multi-indexes are not supported as that is just added complexity.\n",
        "createdAt" : "2015-02-12T21:34:22Z",
        "updatedAt" : "2015-02-12T21:34:22Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "019f1958-4ccb-4059-9c15-49a93a5dbd68",
        "parentId" : "0d170810-dad8-4fe0-bf0e-d9158a7bc5c5",
        "authorId" : "8b404822-a597-42dd-b567-818788cb72c8",
        "body" : "The question is what you want the behavior to be. Suppose `df.index` is a 2-level `MultiIndex`, the first level of which is (effectively) an `Int64Index` with missing values (i.e. `-1` in `labels`), and that you then unstack the second level (i.e. `df.unstack(1)`). What should the result `index` be? There are two options: (a) `Float64Index`, and (b) `Index(..., dtype='object')`. With this PR, the result is (a). Personally I think (b) is preferable.\n\n```\nIn : df = pd.DataFrame([[11,22],[33,44]], index=pd.MultiIndex.from_tuples([(1, 'a'), (None, 'b')], names=['ints', 'letters']))\nIn : df.index.levels[0]\nOut: Int64Index([1], dtype='int64')\nIn : df.index.labels[0]\nOut: FrozenNDArray([0, -1], dtype='int8')\n\nIn : result = df.unstack(1)\nIn : result.index\nOut: Float64Index([nan, 1.0], dtype='float64')\n```\n",
        "createdAt" : "2015-02-12T22:08:04Z",
        "updatedAt" : "2015-02-12T22:10:46Z",
        "lastEditedBy" : "8b404822-a597-42dd-b567-818788cb72c8",
        "tags" : [
        ]
      },
      {
        "id" : "6997fd8e-2dff-4601-bf99-a66419ef968a",
        "parentId" : "0d170810-dad8-4fe0-bf0e-d9158a7bc5c5",
        "authorId" : "8b404822-a597-42dd-b567-818788cb72c8",
        "body" : "On a related note, to see in general how messed up things are when have `NaN`s in indices, consider the following:\n\n```\nIn [698]: idx = MultiIndex.from_tuples([(1, 'a'), (np.nan, 'b')])\n\nIn [699]: idx.levels[0]\nOut[699]: Int64Index([1], dtype='int64')\n\nIn [700]: idx.get_values()\nOut[700]: array([(1.0, 'a'), (nan, 'b')], dtype=object)\n\nIn [701]: idx[:1].get_values()\nOut[701]: array([(1, 'a')], dtype=object)\n```\n\nWhy does `idx.get_values()` convert the int `1` to a float `1.0` just because there's a `NaN` somewhere else? (I can guess what the implementation is that would lead to this...) Is this a bug?\n",
        "createdAt" : "2015-02-12T22:31:53Z",
        "updatedAt" : "2015-02-12T22:31:53Z",
        "lastEditedBy" : "8b404822-a597-42dd-b567-818788cb72c8",
        "tags" : [
        ]
      }
    ],
    "commit" : "e513486e6c101ef91d0726428b2dcdb208a82475",
    "line" : 38,
    "diffHunk" : "@@ -1,1 +12413,12417 @@                [nan, nan, nan, nan, 4, 5, 6, 7]]\n        vals = list(map(list, zip(*vals)))\n        idx = Index([nan, 0, 1, 2, 4, 5, 6, 7], name='B')\n        cols = MultiIndex(levels=[['C'], ['a', 'b']],\n                          labels=[[0, 0], [0, 1]],"
  },
  {
    "id" : "b9087305-edd5-4971-aa20-0dccbc719397",
    "prId" : 9292,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "73cede63-52dd-4c29-a01e-918bf7104726",
        "parentId" : null,
        "authorId" : "8b404822-a597-42dd-b567-818788cb72c8",
        "body" : "Here both `left` and `right` have `dtypes = [float64]*6`. But since `df.set_index(['A', 'B'])` has `dtypes = [int32]`, I would expect only the resulting columns with `NaN` to be changed to `float64`,i.e. I would expect `dtypes = [float64, int32, int32, int32, float64, int32]`.\n\nI noticed this because when testing my code in https://github.com/pydata/pandas/pull/9023/files, when I change the implementation of `DataFrame.unstack()` to be based on `DataFrame.stack()`, my code \"corrects\" the columns back to `int32` where possible, whereas this test expects all columns to be `float64`.\n",
        "createdAt" : "2015-02-13T01:58:14Z",
        "updatedAt" : "2015-02-13T01:59:02Z",
        "lastEditedBy" : "8b404822-a597-42dd-b567-818788cb72c8",
        "tags" : [
        ]
      }
    ],
    "commit" : "e513486e6c101ef91d0726428b2dcdb208a82475",
    "line" : 86,
    "diffHunk" : "@@ -1,1 +12461,12465 @@\n        right = DataFrame(vals, columns=cols, index=idx)\n        assert_frame_equal(left, right)\n\n        # GH4862"
  }
]
[
  {
    "id" : "c2c18c34-30b8-49c2-9e01-3fdc4ea16e17",
    "prId" : 23832,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/23832#pullrequestreview-177374083",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8f8470e2-43d2-4dea-91e9-fc3e8f5acd40",
        "parentId" : null,
        "authorId" : "51189123-86a2-400a-9762-6816882b6f12",
        "body" : "So this is an inconsistency in how we process columns that are aggregated to create one date column and are not dropped because `keep_date_col=True`.\r\n\r\nThe C engine does not continue to parse them and infer dtype, whereas the Python does parse and infer dtypes on these columns as if they were regular (standalone) data columns, even though they were used to really construct a single data column.\r\n\r\nWhich engine do you guys think is more correct?",
        "createdAt" : "2018-11-21T07:38:48Z",
        "updatedAt" : "2018-11-21T17:59:25Z",
        "lastEditedBy" : "51189123-86a2-400a-9762-6816882b6f12",
        "tags" : [
        ]
      },
      {
        "id" : "c5c0d4d7-4a26-4529-8877-72d866e4eabe",
        "parentId" : "8f8470e2-43d2-4dea-91e9-fc3e8f5acd40",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "can you open an issue here for followup",
        "createdAt" : "2018-11-21T12:32:16Z",
        "updatedAt" : "2018-11-21T17:59:25Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "93b8c6eb-86ab-4ab5-98ab-bab6e8cf77a7",
        "parentId" : "8f8470e2-43d2-4dea-91e9-fc3e8f5acd40",
        "authorId" : "51189123-86a2-400a-9762-6816882b6f12",
        "body" : "Opened #23845",
        "createdAt" : "2018-11-21T18:18:13Z",
        "updatedAt" : "2018-11-21T18:18:13Z",
        "lastEditedBy" : "51189123-86a2-400a-9762-6816882b6f12",
        "tags" : [
        ]
      }
    ],
    "commit" : "218037929f3dcb72d3573591b961506a5c4a0ed3",
    "line" : 100,
    "diffHunk" : "@@ -1,1 +98,102 @@        expected = expected.drop([\"X1\", \"X2\", \"X3\"], axis=1)\n    elif parser.engine == \"python\":\n        expected[\"X1\"] = expected[\"X1\"].astype(np.int64)\n\n    # Python can sometimes be flaky about how"
  },
  {
    "id" : "b31ff280-e7b5-49ee-bd4d-59fa92b9979c",
    "prId" : 25922,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/25922#pullrequestreview-224367408",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3c3361b0-5f41-4df7-8034-24a1c45a6423",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "blank line",
        "createdAt" : "2019-04-09T11:35:17Z",
        "updatedAt" : "2019-04-19T06:17:49Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "0a900cfd-7171-4f65-9c15-90b55d5d6a39",
        "parentId" : "3c3361b0-5f41-4df7-8034-24a1c45a6423",
        "authorId" : "ac925cd1-7327-4d2a-a9fc-55fc5f720f67",
        "body" : "Fixed",
        "createdAt" : "2019-04-09T12:24:09Z",
        "updatedAt" : "2019-04-19T06:17:49Z",
        "lastEditedBy" : "ac925cd1-7327-4d2a-a9fc-55fc5f720f67",
        "tags" : [
        ]
      }
    ],
    "commit" : "2cd971af704fe952fc221bb1d254524c2acd795a",
    "line" : 26,
    "diffHunk" : "@@ -1,1 +32,36 @@_DEFAULT_DATETIME = datetime(1, 1, 1)\n\n# Strategy for hypothesis\nif is_platform_windows():\n    date_strategy = st.datetimes(min_value=datetime(1900, 1, 1))"
  },
  {
    "id" : "4fe204fd-dd20-4030-ba53-7c5617ed2c89",
    "prId" : 25922,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/25922#pullrequestreview-224591036",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ee06f5f3-e9c4-4ad3-b8e6-9126b78e803b",
        "parentId" : null,
        "authorId" : "df13c963-1a7e-400d-8549-3b407a6b437e",
        "body" : "Given that this is just a test that says, \"Does this do what dateutil does\", why does it matter whether it can reliably tell whether it's a float or a date? It just has to do the same thing that dateutil does.\r\n\r\nOr is it that both of these throw an error in this case?",
        "createdAt" : "2019-04-09T14:47:19Z",
        "updatedAt" : "2019-04-19T06:17:49Z",
        "lastEditedBy" : "df13c963-1a7e-400d-8549-3b407a6b437e",
        "tags" : [
        ]
      },
      {
        "id" : "08037559-7363-48bb-a889-968cb8cf1fe2",
        "parentId" : "ee06f5f3-e9c4-4ad3-b8e6-9126b78e803b",
        "authorId" : "ac925cd1-7327-4d2a-a9fc-55fc5f720f67",
        "body" : "Answer is there: https://github.com/pandas-dev/pandas/pull/25922#discussion_r273645345 I think",
        "createdAt" : "2019-04-09T18:49:12Z",
        "updatedAt" : "2019-04-19T06:17:49Z",
        "lastEditedBy" : "ac925cd1-7327-4d2a-a9fc-55fc5f720f67",
        "tags" : [
        ]
      }
    ],
    "commit" : "2cd971af704fe952fc221bb1d254524c2acd795a",
    "line" : 120,
    "diffHunk" : "@@ -1,1 +924,928 @@                                   delimiter, test_datetime):\n    if date_format == \"%m %Y\" and delimiter == \".\":\n        pytest.skip(\"parse_datetime_string cannot reliably tell whether \\\n        e.g. %m.%Y is a float or a date, thus we skip it\")\n    result, expected = None, None"
  },
  {
    "id" : "9aa585ef-ebfd-4d4c-af33-5a3d94c65315",
    "prId" : 25922,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/25922#pullrequestreview-226785557",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4e9dd157-3a4f-4538-8e0a-306a58a7e36a",
        "parentId" : null,
        "authorId" : "df13c963-1a7e-400d-8549-3b407a6b437e",
        "body" : "It seems that you are directly testing a private function that you wrote in this PR, which at least partially misses the point of doing these tests. No users will be calling `parse_datetime_string`, and some of the failures may come about because the functions users *do* call will be sent to `parse_datetime_string` when they normally would hit some pandas-specific function.\r\n\r\nGiven that this PR is supposed to be performance-only, I think the tests you write for it should also be able to pass *before* the PR is merged. The purpose of the test is to say that end users shouldn't notice *any difference* before and after the PR, except an improvement to the speed of the library.",
        "createdAt" : "2019-04-09T14:51:15Z",
        "updatedAt" : "2019-04-19T06:17:49Z",
        "lastEditedBy" : "df13c963-1a7e-400d-8549-3b407a6b437e",
        "tags" : [
        ]
      },
      {
        "id" : "0a20f2a1-affa-44c8-b201-cebd3e5df4bc",
        "parentId" : "4e9dd157-3a4f-4538-8e0a-306a58a7e36a",
        "authorId" : "ac925cd1-7327-4d2a-a9fc-55fc5f720f67",
        "body" : "Not quite right. We call the `parse_datetime_string` (not written by us), which in turn calls our `_parse_delimited_date`. Therefore, this test must pass before our changes.\r\n\r\nAs for hitting the module specific code, in the situation described by this expression: `if date_format == \"%m %Y\" and delimiter == \".\"` we hit the function inside the `parse_datetime_string`, which makes it's behavior different from the `du_parse` behavior. But for now this is the best solution we found.",
        "createdAt" : "2019-04-09T18:38:49Z",
        "updatedAt" : "2019-04-19T06:17:49Z",
        "lastEditedBy" : "ac925cd1-7327-4d2a-a9fc-55fc5f720f67",
        "tags" : [
        ]
      },
      {
        "id" : "c090ba8e-1bae-475a-a7ff-0912090d97e9",
        "parentId" : "4e9dd157-3a4f-4538-8e0a-306a58a7e36a",
        "authorId" : "adf621f1-4745-479a-a1fc-dc14046a3f4b",
        "body" : "@anmyachev @pganssle has a (totally reasonable) habit/policy in dateutil of avoiding testing internal functions, but that is not shared in pandas.  We definitely do need to test the user-facing parsing functions (`to_datetime`, `Timestamp`), but it is also very much OK to directly test the lower-level implementations.  That way if the high-level test starts breaking, it is easier to track down the problem.",
        "createdAt" : "2019-04-10T01:20:04Z",
        "updatedAt" : "2019-04-19T06:17:49Z",
        "lastEditedBy" : "adf621f1-4745-479a-a1fc-dc14046a3f4b",
        "tags" : [
        ]
      },
      {
        "id" : "fabc04df-22aa-4136-87a3-3fa7e00e8e35",
        "parentId" : "4e9dd157-3a4f-4538-8e0a-306a58a7e36a",
        "authorId" : "ac925cd1-7327-4d2a-a9fc-55fc5f720f67",
        "body" : "@jbrockmendel glad to hear it! Then did I understand correctly that there are enough tests?",
        "createdAt" : "2019-04-10T08:38:45Z",
        "updatedAt" : "2019-04-19T06:17:49Z",
        "lastEditedBy" : "ac925cd1-7327-4d2a-a9fc-55fc5f720f67",
        "tags" : [
        ]
      },
      {
        "id" : "72288827-902c-4b8f-aa9c-962e08147d0b",
        "parentId" : "4e9dd157-3a4f-4538-8e0a-306a58a7e36a",
        "authorId" : "df13c963-1a7e-400d-8549-3b407a6b437e",
        "body" : "To clarify, while I do think that is a wise *general* policy, this is not a matter of policy but about what precisely is being tested. In this case, you have a performance-only fix, so the ideal situation is to show that the automated tests explore enough of the test space that you can be somewhat confident that it will not introduce regressions.\r\n\r\nThe best way to do this is to put regression tests in place that will pass both *before* and *after* the changes (thus making it fairly easy to show that no new behavior was introduced), and to test it at the level of the public interface - which is the part that might actually introduce regressions. I don't know enough about the code to know that your tests are adequately showing that this new function won't cause any performance differences in the higher level code, and that's part of the problem - by testing the lower-level stuff you may be testing it in an entirely \"unnatural\" context that gets you good coverage metrics, but doesn't mimic real-world usage.\r\n\r\nThat said, my objection was mainly around the *first* case because when I searched for `parse_datetime_string` it seemed like that was a function you added. If @jbrockmendel and the other maintainers feel that this is the right level for the tests (and \"we used to call dateutil here, now we call `_parse_delimited_date`, therefore as long as `_parse_delimited_date` does whatever dateutil did, it's fine\" is a very reasonable test strategy), I don't need to press the point.",
        "createdAt" : "2019-04-10T16:08:24Z",
        "updatedAt" : "2019-04-19T06:17:49Z",
        "lastEditedBy" : "df13c963-1a7e-400d-8549-3b407a6b437e",
        "tags" : [
        ]
      },
      {
        "id" : "e4e2fd9d-c3bd-4966-9b4b-acc83bbfa8d9",
        "parentId" : "4e9dd157-3a4f-4538-8e0a-306a58a7e36a",
        "authorId" : "ac925cd1-7327-4d2a-a9fc-55fc5f720f67",
        "body" : "@jbrockmendel @jreback what do you think about https://github.com/pandas-dev/pandas/pull/25922#discussion_r274042241?\r\n\r\nWhat our next step?",
        "createdAt" : "2019-04-10T18:22:44Z",
        "updatedAt" : "2019-04-19T06:17:49Z",
        "lastEditedBy" : "ac925cd1-7327-4d2a-a9fc-55fc5f720f67",
        "tags" : [
        ]
      },
      {
        "id" : "cc886f37-9de5-460d-81b4-a13d5ca35cfc",
        "parentId" : "4e9dd157-3a4f-4538-8e0a-306a58a7e36a",
        "authorId" : "be492700-7f0c-4e3f-b2b1-1392960f38a9",
        "body" : "ping? what else you guys feel we need to do to make this acceptable?",
        "createdAt" : "2019-04-15T17:37:52Z",
        "updatedAt" : "2019-04-19T06:17:49Z",
        "lastEditedBy" : "be492700-7f0c-4e3f-b2b1-1392960f38a9",
        "tags" : [
        ]
      }
    ],
    "commit" : "2cd971af704fe952fc221bb1d254524c2acd795a",
    "line" : 127,
    "diffHunk" : "@@ -1,1 +931,935 @@\n    except_out_dateutil, result = _helper_hypothesis_delimited_date(\n        parse_datetime_string, date_string,\n        dayfirst=dayfirst)\n    except_in_dateutil, expected = _helper_hypothesis_delimited_date("
  }
]
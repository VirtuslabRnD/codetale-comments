[
  {
    "id" : "50ab7886-d5e6-40ec-b8e6-a53187bd07e1",
    "prId" : 19231,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/19231#pullrequestreview-88694944",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ba5e6d41-9e18-4a6c-81b5-7e0a75bc3bcc",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "numpy actually allows things like this (IOW truncation of floats). Are you failing this directly?\r\n\r\nI agree that it *should* fail though, its just a can of worms.",
        "createdAt" : "2018-01-13T21:53:23Z",
        "updatedAt" : "2018-01-13T21:54:47Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "915b2a88-6530-4ab9-8e40-e55234ca725e",
        "parentId" : "ba5e6d41-9e18-4a6c-81b5-7e0a75bc3bcc",
        "authorId" : "7545b4d7-157f-47c4-b7f8-18bf358d429c",
        "body" : "This is test is being xfailed with `@pytest.mark.xfail(reason='GH 15832')`.  I _think_ fixing #15832 should resolve this, since the changes should flow through to `IntervalIndex` as well, since it's relying on `Float64Index` to hold the endpoints.\r\n\r\nThe current behavior within this PR is truncation of floats, identical to the existing `Float64Index` behavior:\r\n```python\r\nIn [2]: ii = pd.interval_range(0.25, 1.5, freq=0.25)\r\n\r\nIn [3]: ii\r\nOut[3]:\r\nIntervalIndex([(0.25, 0.5], (0.5, 0.75], (0.75, 1.0], (1.0, 1.25], (1.25, 1.5]]\r\n              closed='right',\r\n              dtype='interval[float64]')\r\n\r\nIn [4]: ii.astype('interval[int64]')\r\nOut[4]:\r\nIntervalIndex([(0, 0], (0, 0], (0, 1], (1, 1], (1, 1]]\r\n              closed='right',\r\n              dtype='interval[int64]')\r\n\r\nIn [5]: pd.Float64Index([1.1, 2.2, 3.3]).astype('int64')\r\nOut[5]: Int64Index([1, 2, 3], dtype='int64')\r\n```",
        "createdAt" : "2018-01-14T19:34:31Z",
        "updatedAt" : "2018-01-14T19:34:31Z",
        "lastEditedBy" : "7545b4d7-157f-47c4-b7f8-18bf358d429c",
        "tags" : [
        ]
      },
      {
        "id" : "e9310346-f708-4b43-837f-41e78b7ba1c4",
        "parentId" : "ba5e6d41-9e18-4a6c-81b5-7e0a75bc3bcc",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "ok that's fine",
        "createdAt" : "2018-01-14T21:25:33Z",
        "updatedAt" : "2018-01-14T21:25:33Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "8caf9f2e1e87327941920c1d676e3ef3fe3c31f9",
    "line" : 145,
    "diffHunk" : "@@ -1,1 +143,147 @@\n        # float64 -> integer-like fails with non-integer valued floats\n        index = interval_range(0.0, 10.0, freq=0.25)\n        dtype = IntervalDtype('int64')\n        with pytest.raises(ValueError):"
  },
  {
    "id" : "7d738674-7af9-49f5-b50a-11d7919bfca7",
    "prId" : 19231,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/19231#pullrequestreview-88694933",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "17536ba4-b84c-4a3f-a2fc-b5509ae549c8",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "can you add some tests where we fail on int/unit sub-types that we don't support e.g. (int8,16,32)",
        "createdAt" : "2018-01-13T21:54:28Z",
        "updatedAt" : "2018-01-13T21:54:47Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "92808f07-8e07-471e-817b-9310d5d39501",
        "parentId" : "17536ba4-b84c-4a3f-a2fc-b5509ae549c8",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "do we have these for construction as well (tests I mean)?",
        "createdAt" : "2018-01-13T21:54:38Z",
        "updatedAt" : "2018-01-13T21:54:47Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "3d82d0ea-d288-4bd1-8ab4-3590ee75414f",
        "parentId" : "17536ba4-b84c-4a3f-a2fc-b5509ae549c8",
        "authorId" : "7545b4d7-157f-47c4-b7f8-18bf358d429c",
        "body" : "There aren't any construction related tests for unsupported int/uint.  This also doesn't fail with how I've implemented `IntervalIndex.astype` in this PR, since it relies on the behavior of the underlying endpoint indexes.  I can't find a way in which those raise when passed an unsupported int/uint, as they always appear to upcast to `int64`:\r\n\r\n```python\r\nIn [2]: pd.Index([1, 2, 3], dtype='int16')\r\nOut[2]: Int64Index([1, 2, 3], dtype='int64')\r\n\r\nIn [3]: pd.Int64Index([1, 2, 3]).astype('int8')\r\nOut[3]: Int64Index([1, 2, 3], dtype='int64')\r\n\r\nIn [4]: pd.Index(np.arange(5, dtype='int16'))\r\nOut[4]: Int64Index([0, 1, 2, 3, 4], dtype='int64')\r\n\r\nIn [5]: pd.Int64Index([1, 2, 3]).astype('uint8')\r\nOut[5]: UInt64Index([1, 2, 3], dtype='uint64')\r\n```\r\n\r\nSeems like this would need to fail at the level shown above for it to fail on `IntervalIndex`?  If so, probably best done in a separate PR, since my initial guess is that it'd require a bit of work/changes.  I could write xfailing tests here though.  Or am I misinterpreting what you mean? ",
        "createdAt" : "2018-01-14T19:33:45Z",
        "updatedAt" : "2018-01-14T19:33:45Z",
        "lastEditedBy" : "7545b4d7-157f-47c4-b7f8-18bf358d429c",
        "tags" : [
        ]
      },
      {
        "id" : "0a13b9c7-baae-4ebb-85d1-1ee771bdf749",
        "parentId" : "17536ba4-b84c-4a3f-a2fc-b5509ae549c8",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "right these are all valid (as these are how indexes are constructed), maybe just add some tests to confirm for II",
        "createdAt" : "2018-01-14T21:25:10Z",
        "updatedAt" : "2018-01-14T21:25:11Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "8caf9f2e1e87327941920c1d676e3ef3fe3c31f9",
    "line" : 87,
    "diffHunk" : "@@ -1,1 +85,89 @@        tm.assert_index_equal(result, expected)\n\n    @pytest.mark.parametrize('subtype_start, subtype_end', [\n        ('int64', 'uint64'), ('uint64', 'int64')])\n    def test_subtype_integer(self, subtype_start, subtype_end):"
  },
  {
    "id" : "96c65c17-b17a-4a3b-b5c7-229b0cf6ab1f",
    "prId" : 28387,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/28387#pullrequestreview-287776399",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b404fb3d-bb75-4bf6-9752-2e6519cd7abf",
        "parentId" : null,
        "authorId" : "5e8c5ef2-940b-436e-9c5f-98ae5460128c",
        "body" : "Do we need to change the quoting here? I'm actually surprised this doesn't cause failures since the exception message shown in diff uses single quotes around the bad dtype",
        "createdAt" : "2019-09-13T00:59:21Z",
        "updatedAt" : "2019-09-13T00:59:28Z",
        "lastEditedBy" : "5e8c5ef2-940b-436e-9c5f-98ae5460128c",
        "tags" : [
        ]
      },
      {
        "id" : "fad71135-95f7-4666-918e-183b31273267",
        "parentId" : "b404fb3d-bb75-4bf6-9752-2e6519cd7abf",
        "authorId" : "adf621f1-4745-479a-a1fc-dc14046a3f4b",
        "body" : "this is now passing through an exception raised by numpy",
        "createdAt" : "2019-09-13T01:14:54Z",
        "updatedAt" : "2019-09-13T01:14:54Z",
        "lastEditedBy" : "adf621f1-4745-479a-a1fc-dc14046a3f4b",
        "tags" : [
        ]
      }
    ],
    "commit" : "662c4363a69bb21e1c9d68bb6caf1b9cadae42c6",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +68,72 @@\n    def test_astype_invalid_dtype(self, index):\n        msg = 'data type \"fake_dtype\" not understood'\n        with pytest.raises(TypeError, match=msg):\n            index.astype(\"fake_dtype\")"
  }
]
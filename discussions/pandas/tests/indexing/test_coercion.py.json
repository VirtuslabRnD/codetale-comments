[
  {
    "id" : "58109bed-595d-4c23-a0d6-942ec3afb129",
    "prId" : 18721,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/18721#pullrequestreview-88301768",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4ea8e3fb-38f7-4bfc-8ae2-dac5b6909731",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "where is this used?",
        "createdAt" : "2017-12-13T01:55:48Z",
        "updatedAt" : "2017-12-13T01:55:48Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "25c9be3d-0df5-471e-91ba-389d44a7e6d9",
        "parentId" : "4ea8e3fb-38f7-4bfc-8ae2-dac5b6909731",
        "authorId" : "5e8c5ef2-940b-436e-9c5f-98ae5460128c",
        "body" : "The ``autouse`` and ``scope`` args make it so that it is used by every class within the module",
        "createdAt" : "2017-12-13T01:58:33Z",
        "updatedAt" : "2017-12-13T01:58:33Z",
        "lastEditedBy" : "5e8c5ef2-940b-436e-9c5f-98ae5460128c",
        "tags" : [
        ]
      },
      {
        "id" : "d330db17-3eb2-46b4-90b9-ccab241baef5",
        "parentId" : "4ea8e3fb-38f7-4bfc-8ae2-dac5b6909731",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "oh, ok, cool. thanks for this patch. Nice work!",
        "createdAt" : "2017-12-13T02:02:29Z",
        "updatedAt" : "2017-12-13T02:02:29Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "f58585a2-e837-48d5-abd4-414c35159848",
        "parentId" : "4ea8e3fb-38f7-4bfc-8ae2-dac5b6909731",
        "authorId" : "adf621f1-4745-479a-a1fc-dc14046a3f4b",
        "body" : "@WillAyd This is neat.  I'm wondering: what would it take to put something like this together to check for permutations of arithmetic operations and operands?  I don't quite grok pytest's namespacing, in particular where `cls.klasses, cls.dtypes, cls.method` come from and what `request.node.session.items` corresponds to.\r\n\r\n<b>Update</b> the klasses/dtypes/method are a bit more clear now that I look at the whole file and not just the diff.",
        "createdAt" : "2018-01-11T02:09:32Z",
        "updatedAt" : "2018-01-11T02:10:55Z",
        "lastEditedBy" : "adf621f1-4745-479a-a1fc-dc14046a3f4b",
        "tags" : [
        ]
      },
      {
        "id" : "21b78b4d-6387-46f5-832c-747ce13791a2",
        "parentId" : "4ea8e3fb-38f7-4bfc-8ae2-dac5b6909731",
        "authorId" : "5e8c5ef2-940b-436e-9c5f-98ae5460128c",
        "body" : "`cls.klasses`, `cls.dtypes` and `cls.method` don't have anything to do with `pytest` - they are all class variables built into the tests in this module. I was inspired by [this link](https://docs.pytest.org/en/latest/example/special.html) on how to initially set this up, but had to tweak slightly given that link has a `session`-scoped fixture whereas here we are working with a class-level scope.\r\n\r\nBasically `request.node.session.items` traverses from the fixture to the [node](https://docs.pytest.org/en/features/_modules/_pytest/nodes.html) (`pandas.tests.io.indexing.test_coercion::TestFoo`) and then goes from the node to the session. The session contains all of the test items, so iterating over them this code checks if all of the `klasses`, `dtypes` and `method` combinations set in the \"in-scope\" class are defined somewhere in the suite.\r\n\r\nI don't entirely understand what you are trying to do with operations and operands but assuming you wanted to set up those combinations within a parametrization fixture I believe you could access that metadata by looking at `.callspec.params` on each object in `request.node.session.items`. ",
        "createdAt" : "2018-01-11T06:27:55Z",
        "updatedAt" : "2018-01-11T06:27:55Z",
        "lastEditedBy" : "5e8c5ef2-940b-436e-9c5f-98ae5460128c",
        "tags" : [
        ]
      },
      {
        "id" : "22421559-1aa7-4263-9dcb-003d2d868506",
        "parentId" : "4ea8e3fb-38f7-4bfc-8ae2-dac5b6909731",
        "authorId" : "adf621f1-4745-479a-a1fc-dc14046a3f4b",
        "body" : "> I don't entirely understand what you are trying to do with operations and operands\r\n\r\nI going through #18824 I'm finding lots of cases that are not tested, saw this bit of code and thought it might be possible to enumerate e.g. `op = [__add__, __sub__, ...]`, `vec_classes = [Series, DatetimeIndex, np.ndarray, ...]`, `scalar_types = [...]`, `null_types=[...]`, `right = [...]` and check that all the cases are tested.  \r\n\r\nThat would also be helpful because there are a _ton_ of cases where tests are duplicated because `test_foo` and `test_bar` both test `foo+bar`, `bar+foo`. Not that this is a big problem, but it'd be nice to be systematic about it.\r\n",
        "createdAt" : "2018-01-11T20:50:22Z",
        "updatedAt" : "2018-01-11T20:50:22Z",
        "lastEditedBy" : "adf621f1-4745-479a-a1fc-dc14046a3f4b",
        "tags" : [
        ]
      }
    ],
    "commit" : "7a072acaeb94771735edeb9626860af01b1e293d",
    "line" : 12,
    "diffHunk" : "@@ -1,1 +16,20 @@\n@pytest.fixture(autouse=True, scope='class')\ndef check_comprehensiveness(request):\n    # Iterate over combination of dtype, method and klass\n    # and ensure that each are contained within a collected test"
  }
]
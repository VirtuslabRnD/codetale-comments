[
  {
    "id" : "4ff73479-a53e-41a9-8a1e-720644e4c5ef",
    "prId" : 14762,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/14762#pullrequestreview-11011827",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d2f7558c-c5ab-4e5f-b829-300d729c9d5b",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "hmm only these 2 occurences of the original KeyError.....?",
        "createdAt" : "2016-12-01T15:27:20Z",
        "updatedAt" : "2016-12-09T14:58:32Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "2a35608a-e0bc-447d-a47a-260cef9f47bd",
        "parentId" : "d2f7558c-c5ab-4e5f-b829-300d729c9d5b",
        "authorId" : "d9d08f2d-b33c-4c2c-9969-32795418a9da",
        "body" : "Via my methodology described above, that's all I found. ",
        "createdAt" : "2016-12-01T17:12:57Z",
        "updatedAt" : "2016-12-09T14:58:32Z",
        "lastEditedBy" : "d9d08f2d-b33c-4c2c-9969-32795418a9da",
        "tags" : [
        ]
      }
    ],
    "commit" : "76b6434e0fd60a60a0536f2e207f5d03d6552349",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +2231,2235 @@        self.assertEqual(df.index.lexsort_depth, 0)\n        with tm.assertRaisesRegexp(\n                UnsortedIndexError,\n                'MultiIndex Slicing requires the index to be fully '\n                r'lexsorted tuple len \\(2\\), lexsort depth \\(0\\)'):"
  },
  {
    "id" : "d2b694a5-500c-4101-9451-28dab4508865",
    "prId" : 17956,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/17956#pullrequestreview-72208854",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d184fc29-8a02-4ec2-a4cc-94f11bf337c1",
        "parentId" : null,
        "authorId" : "a6699474-cbaa-4730-8ac4-f757df226d77",
        "body" : "Would it make sense to do a `sys.getrefcount(df)` before and after and assert that it doesn't change? Or is this assertion too strong?",
        "createdAt" : "2017-10-25T12:00:57Z",
        "updatedAt" : "2017-10-27T11:09:20Z",
        "lastEditedBy" : "a6699474-cbaa-4730-8ac4-f757df226d77",
        "tags" : [
        ]
      },
      {
        "id" : "271e68c0-b583-498e-86aa-ed2d62d3422c",
        "parentId" : "d184fc29-8a02-4ec2-a4cc-94f11bf337c1",
        "authorId" : "7c84fc55-a848-4ca2-a014-28c856c6d6e2",
        "body" : "There is no need for that, the `weakref`-based test below already tests that no leak happens.",
        "createdAt" : "2017-10-25T12:02:21Z",
        "updatedAt" : "2017-10-27T11:09:20Z",
        "lastEditedBy" : "7c84fc55-a848-4ca2-a014-28c856c6d6e2",
        "tags" : [
        ]
      },
      {
        "id" : "f88fc72e-ccaa-4aa6-998f-a68e12f964fa",
        "parentId" : "d184fc29-8a02-4ec2-a4cc-94f11bf337c1",
        "authorId" : "a6699474-cbaa-4730-8ac4-f757df226d77",
        "body" : "I was only wondering if the `weakref` can become `None` \"by chance\" if the garbage collector happens to run exactly between the `del` and the assertion. This is of course highly unlikely, but my understanding was that the `None` result does not directly imply that there wasn't a cyclic reference. But I could be wrong about that.",
        "createdAt" : "2017-10-25T12:30:25Z",
        "updatedAt" : "2017-10-27T11:09:20Z",
        "lastEditedBy" : "a6699474-cbaa-4730-8ac4-f757df226d77",
        "tags" : [
        ]
      },
      {
        "id" : "3b4203e2-8097-409f-bed5-7090bbaeb1b3",
        "parentId" : "d184fc29-8a02-4ec2-a4cc-94f11bf337c1",
        "authorId" : "7c84fc55-a848-4ca2-a014-28c856c6d6e2",
        "body" : "Well, In that case the test would fail most of the time.",
        "createdAt" : "2017-10-25T12:35:27Z",
        "updatedAt" : "2017-10-27T11:09:20Z",
        "lastEditedBy" : "7c84fc55-a848-4ca2-a014-28c856c6d6e2",
        "tags" : [
        ]
      },
      {
        "id" : "f9337c9b-af2f-4b59-9b04-cb9f58531b0e",
        "parentId" : "d184fc29-8a02-4ec2-a4cc-94f11bf337c1",
        "authorId" : "a6699474-cbaa-4730-8ac4-f757df226d77",
        "body" : "Why most of the time? It is very unlikely, so it would fail rarely, right?\r\n\r\nYou can check that this assertion erroneously passes with pandas 0.20.3 where there are definitely cyclic references by forcing an \"accidental\" GC:\r\n\r\n```\r\nIn [8]:     def test_no_reference_cycle(happens_to_run_gc):\r\n   ...:         import weakref, gc, sys, pandas as pd\r\n   ...:         df = pd.DataFrame({'a': [0, 1], 'b': [2, 3]})\r\n   ...:         refcount_before = sys.getrefcount(df)\r\n   ...:         for name in ('loc', 'iloc', 'ix', 'at', 'iat'):\r\n   ...:             getattr(df, name)\r\n   ...:         refcount_after = sys.getrefcount(df)\r\n   ...:         print(\"ref counts {} -> {}\".format(refcount_before, refcount_after))\r\n   ...:         wr = weakref.ref(df)\r\n   ...:         del df\r\n   ...:         if happens_to_run_gc:\r\n   ...:             gc.collect()\r\n   ...:         assert wr() is None\r\n   ...:\r\n```",
        "createdAt" : "2017-10-26T11:45:53Z",
        "updatedAt" : "2017-10-27T11:09:20Z",
        "lastEditedBy" : "a6699474-cbaa-4730-8ac4-f757df226d77",
        "tags" : [
        ]
      },
      {
        "id" : "678f05b2-273f-4651-8f71-e9c7aedad4c9",
        "parentId" : "d184fc29-8a02-4ec2-a4cc-94f11bf337c1",
        "authorId" : "7c84fc55-a848-4ca2-a014-28c856c6d6e2",
        "body" : "You said « the weakref can become None \"by chance\" ». If that's the only reason the test succeeds, then it would fail most of the time, since the chance of a GC happening between two consecutive opcodes is slim.\r\n\r\nI'm not sure what your code snippet is supposed to prove.",
        "createdAt" : "2017-10-26T11:53:02Z",
        "updatedAt" : "2017-10-27T11:09:20Z",
        "lastEditedBy" : "7c84fc55-a848-4ca2-a014-28c856c6d6e2",
        "tags" : [
        ]
      },
      {
        "id" : "7b4e0a77-bd00-42e7-aa36-ec3ae4c5f37c",
        "parentId" : "d184fc29-8a02-4ec2-a4cc-94f11bf337c1",
        "authorId" : "a6699474-cbaa-4730-8ac4-f757df226d77",
        "body" : "What I'm trying to say: Checking for `wr() is None` does not guarantee that the operations are ref-cycle-free, which I though was the purpose of the test. That's why I would have preferred `refcount_before == refcount_after` but due to the low probability of an accidental success it doesn't really matter.",
        "createdAt" : "2017-10-26T14:17:32Z",
        "updatedAt" : "2017-10-27T11:09:20Z",
        "lastEditedBy" : "a6699474-cbaa-4730-8ac4-f757df226d77",
        "tags" : [
        ]
      }
    ],
    "commit" : "efe021daebcca3d706aa8ced3eb90c2e12c41fb4",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +885,889 @@    def test_no_reference_cycle(self):\n        df = pd.DataFrame({'a': [0, 1], 'b': [2, 3]})\n        for name in ('loc', 'iloc', 'ix', 'at', 'iat'):\n            getattr(df, name)\n        wr = weakref.ref(df)"
  },
  {
    "id" : "32fbb8b9-18c0-4081-ae71-da443debc5e7",
    "prId" : 19881,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/19881#pullrequestreview-188149181",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a2658fdf-1006-4f15-9f1e-2e8461f62d0f",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "can you add the issue number here",
        "createdAt" : "2018-12-27T18:22:44Z",
        "updatedAt" : "2019-01-02T00:28:45Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "a00dd9e37339a0741a5d9ebc60420d7fb6a04542",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +815,819 @@    def test_non_reducing_slice_on_multiindex(self):\n        # GH 19861\n        dic = {\n            ('a', 'd'): [1, 4],\n            ('a', 'c'): [2, 3],"
  },
  {
    "id" : "7e180a4a-dd07-43a6-8471-4b07c1cb4661",
    "prId" : 20770,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/20770#pullrequestreview-114242790",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f1816450-8473-4174-bc42-5f458459aade",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "can you a comment here on what you are testing (maybe separate test)?",
        "createdAt" : "2018-04-21T17:02:30Z",
        "updatedAt" : "2018-05-01T11:03:09Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "62e27176-af88-4f79-b760-a02b19b62a50",
        "parentId" : "f1816450-8473-4174-bc42-5f458459aade",
        "authorId" : "69a015bc-2b58-45dd-83cb-2c2f6d80b128",
        "body" : "(done)",
        "createdAt" : "2018-04-23T04:51:47Z",
        "updatedAt" : "2018-05-01T11:03:09Z",
        "lastEditedBy" : "69a015bc-2b58-45dd-83cb-2c2f6d80b128",
        "tags" : [
        ]
      }
    ],
    "commit" : "c62973b28b29f2884f27d335b0b93c0440928b82",
    "line" : 22,
    "diffHunk" : "@@ -1,1 +196,200 @@        # List containing only missing label\n        dfnu = DataFrame(np.random.randn(5, 3), index=list('AABCD'))\n        with pytest.raises(KeyError):\n            dfnu.ix[['E']]\n"
  }
]
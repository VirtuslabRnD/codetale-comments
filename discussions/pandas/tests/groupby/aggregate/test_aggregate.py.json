[
  {
    "id" : "572a2f24-0d55-4c64-a25c-724ab42fbdd1",
    "prId" : 25693,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/25693#pullrequestreview-214864926",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "222ef2dd-69ba-4ec2-b969-9484d3af8ca2",
        "parentId" : null,
        "authorId" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "body" : "For my curiosity, what was the old order for various python versions?",
        "createdAt" : "2019-03-14T21:29:59Z",
        "updatedAt" : "2019-03-18T17:16:55Z",
        "lastEditedBy" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "tags" : [
        ]
      },
      {
        "id" : "b151fbfb-e2ef-45a4-94f2-f92ab793f631",
        "parentId" : "222ef2dd-69ba-4ec2-b969-9484d3af8ca2",
        "authorId" : "851a6d4e-e0c5-475a-a532-fd33a2a93062",
        "body" : "Index(['max', 'mean', 'min', 'ohlc', 'sum'], dtype='object'). This would have been the result in all python versions previous to the changes I made in concat (#25224). After the changes, this would have been the return for the versions below Python 3.6, and the order observed in this PR for 3.6 and above. This is why we converted dicts to OrderedDicts in the aggregation functions, to ensure that result would be consistent in all versions.",
        "createdAt" : "2019-03-15T04:44:56Z",
        "updatedAt" : "2019-03-18T17:16:55Z",
        "lastEditedBy" : "851a6d4e-e0c5-475a-a532-fd33a2a93062",
        "tags" : [
        ]
      }
    ],
    "commit" : "6690b00ae6d7c1111d716419bdfbb8d505f1e563",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +313,317 @@    result = res.columns.levels[1]\n\n    expected = pd.Index(['sum', 'max', 'mean', 'ohlc', 'min'])\n\n    tm.assert_index_equal(result, expected)"
  },
  {
    "id" : "deb31b72-303c-493c-89b6-06c9a2fe92a8",
    "prId" : 26359,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/26359#pullrequestreview-238129405",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "efd8e2d8-bd41-4405-beef-0503692f4871",
        "parentId" : null,
        "authorId" : "5e8c5ef2-940b-436e-9c5f-98ae5460128c",
        "body" : "Can we add test coverage for a value that exceeds the upper limit of an int64?",
        "createdAt" : "2019-05-13T20:02:29Z",
        "updatedAt" : "2019-05-16T18:40:21Z",
        "lastEditedBy" : "5e8c5ef2-940b-436e-9c5f-98ae5460128c",
        "tags" : [
        ]
      },
      {
        "id" : "8a8166ab-5e9d-42a7-9857-01e7b53d0c60",
        "parentId" : "efd8e2d8-bd41-4405-beef-0503692f4871",
        "authorId" : "093d4877-be84-4d27-a655-b3adee9eed25",
        "body" : "It's not immediately clear to me what we would be testing for in that case. Issue #26310 is basically that there is some method `f` such that `f(x) != f(y)`, even though `x == y`, when `x` is of type `np.int64` and `y` is of type `np.uint64`.\r\n\r\nIf the value of `y` would exceed the upper limit of `np.int64` you couldn't represent it as an `np.int64` (?) and I'm not sure how you could pick `x` in that case to produce the above situation.\r\n\r\nIf I have misunderstood, please elaborate.",
        "createdAt" : "2019-05-14T17:58:52Z",
        "updatedAt" : "2019-05-16T18:40:21Z",
        "lastEditedBy" : "093d4877-be84-4d27-a655-b3adee9eed25",
        "tags" : [
        ]
      },
      {
        "id" : "5ee1d3c1-6a60-42ec-9db3-dce3504bd1ec",
        "parentId" : "efd8e2d8-bd41-4405-beef-0503692f4871",
        "authorId" : "5e8c5ef2-940b-436e-9c5f-98ae5460128c",
        "body" : "The problem here is going to be with unsigned integers in the range of 2**63 through 2**64-1 (range where uint64 exceeds int64). I'm not sure if that would even work with these agg functions and don't want to open up a Pandora's box here but if that doesn't work we might just need to reword the whatsnew",
        "createdAt" : "2019-05-14T19:19:27Z",
        "updatedAt" : "2019-05-16T18:40:21Z",
        "lastEditedBy" : "5e8c5ef2-940b-436e-9c5f-98ae5460128c",
        "tags" : [
        ]
      },
      {
        "id" : "10f5c7b4-1774-43e2-b792-9b9f9a024061",
        "parentId" : "efd8e2d8-bd41-4405-beef-0503692f4871",
        "authorId" : "093d4877-be84-4d27-a655-b3adee9eed25",
        "body" : "I suggest rewording whatsnew here and dealing with that in another pull request. What do you think @WillAyd? How would you like the whatsnew to be worded?",
        "createdAt" : "2019-05-15T05:15:56Z",
        "updatedAt" : "2019-05-16T18:40:21Z",
        "lastEditedBy" : "093d4877-be84-4d27-a655-b3adee9eed25",
        "tags" : [
        ]
      },
      {
        "id" : "1ea20616-a696-42f4-b3e7-99570602f858",
        "parentId" : "efd8e2d8-bd41-4405-beef-0503692f4871",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "hmm, input uint64's *should* work with your code change, but @mahepe ok to make an issue about this.",
        "createdAt" : "2019-05-16T00:20:49Z",
        "updatedAt" : "2019-05-16T18:40:21Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "ce22d54829b18d1fd6496c97083909b98783de81",
    "line" : 15,
    "diffHunk" : "@@ -1,1 +325,329 @@    df.x = df.x.astype(dtype)\n    result = df.groupby('y').agg({'x': how})\n    result.x = result.x.astype(np.int64)\n    tm.assert_frame_equal(result, expected, check_exact=True)"
  },
  {
    "id" : "2b237137-2527-4129-a2e4-ee5f5fd97dc9",
    "prId" : 26359,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/26359#pullrequestreview-237402360",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3eecea77-af7d-4d1b-92cd-936110d14f13",
        "parentId" : null,
        "authorId" : "5e8c5ef2-940b-436e-9c5f-98ae5460128c",
        "body" : "Just out of curiosity how did you select these methods? The issue would cover more than just these right?\r\n\r\nJust asking as at some point we should probably add a shared fixture for the different aggregation / transformation methods. Probably a separate PR but just curious if this subset is intentional",
        "createdAt" : "2019-05-13T20:05:54Z",
        "updatedAt" : "2019-05-16T18:40:21Z",
        "lastEditedBy" : "5e8c5ef2-940b-436e-9c5f-98ae5460128c",
        "tags" : [
        ]
      },
      {
        "id" : "7e941d51-6494-4f1f-bf3e-28ae7bb23194",
        "parentId" : "3eecea77-af7d-4d1b-92cd-936110d14f13",
        "authorId" : "093d4877-be84-4d27-a655-b3adee9eed25",
        "body" : "This subset is not intentional.\r\n\r\nI tried to select a set that would satisfy the requests by the other reviewer. Since this PR alters a pretty generic method, I'm sure you could test for a way larger set of methods. It's just that I don't know the codebase well enough to design such tests.",
        "createdAt" : "2019-05-14T17:44:28Z",
        "updatedAt" : "2019-05-16T18:40:21Z",
        "lastEditedBy" : "093d4877-be84-4d27-a655-b3adee9eed25",
        "tags" : [
        ]
      }
    ],
    "commit" : "ce22d54829b18d1fd6496c97083909b98783de81",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +317,321 @@\n@pytest.mark.parametrize('dtype', [np.int64, np.uint64])\n@pytest.mark.parametrize('how', ['first', 'last', 'min',\n                                 'max', 'mean', 'median'])\ndef test_uint64_type_handling(dtype, how):"
  }
]
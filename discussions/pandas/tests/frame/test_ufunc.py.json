[
  {
    "id" : "f337b626-6d21-4e64-856b-070c042aaf09",
    "prId" : 39260,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/39260#pullrequestreview-571508546",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a2ad607f-9847-47ee-8ef4-2b022c0a0564",
        "parentId" : null,
        "authorId" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "body" : "Mmm, I'd like this to be more than \"in theory\". I'd consider this a buggy test, since things should be done blockwise for axis=0.\r\n\r\nCan you you change the test case to have just floats or just ints (even if you have to manually split it for test coverage?).",
        "createdAt" : "2021-01-18T21:43:25Z",
        "updatedAt" : "2021-01-19T15:12:47Z",
        "lastEditedBy" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "tags" : [
        ]
      },
      {
        "id" : "bb37ca52-8b6b-4132-bf6c-bf817faadd4c",
        "parentId" : "a2ad607f-9847-47ee-8ef4-2b022c0a0564",
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "I specifically used two dtypes to have two blocks to ensure we handle this case correctly for axis=1 (which can never be done clockwise)\r\n\r\nJust above there is already a case with only ints that preserves the int dtype.",
        "createdAt" : "2021-01-18T21:46:27Z",
        "updatedAt" : "2021-01-19T15:12:47Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      },
      {
        "id" : "06f545fa-b177-48da-9432-4e5506dd724b",
        "parentId" : "a2ad607f-9847-47ee-8ef4-2b022c0a0564",
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "Note that before pandas 1.2.0, this also didn't preserve the dtypes per column, and 1.2.0 itself didn't calculate a proper result (so I would call this PR a strict improvement ;))",
        "createdAt" : "2021-01-18T21:48:24Z",
        "updatedAt" : "2021-01-19T15:12:47Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      },
      {
        "id" : "691dd702-cbcc-4caf-94ef-fa2f7b845e35",
        "parentId" : "a2ad607f-9847-47ee-8ef4-2b022c0a0564",
        "authorId" : "adf621f1-4745-479a-a1fc-dc14046a3f4b",
        "body" : "agreed re preserving for axis=0.  couldn't we still use mgr.apply in that case?",
        "createdAt" : "2021-01-18T22:55:05Z",
        "updatedAt" : "2021-01-19T15:12:47Z",
        "lastEditedBy" : "adf621f1-4745-479a-a1fc-dc14046a3f4b",
        "tags" : [
        ]
      },
      {
        "id" : "b88a13b2-6238-4eb2-99b6-9156f1606164",
        "parentId" : "a2ad607f-9847-47ee-8ef4-2b022c0a0564",
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "To be clear, I *could* certainly detect the special case of accumulate with axis=0, and then pass axis=1 to the blocks, but:\r\n\r\n1\\) that requires special case code like this in array_ufunc:\r\n\r\n```python\r\nelse:\r\n    # the ufunc(dataframe) case\r\n    ...\r\n    elif method == \"accumulate\" and (\"axis\" not in kwargs or (\"axis\" in kwargs and kwargs[\"axis\"] == 0)):\r\n        # swap axis for the transposed Block values\r\n        kwargs[\"axis\"] = 1\r\n        result = mgr.apply(getattr(ufunc, method), **kwargs)\r\n```\r\n\r\n2\\) that requires `Block.apply` to be \"aware\" of `axis`. Currently it simply passes through keywords, but in this case it would need to interpret `axis` differently depending on whether its values are stored as 2D or 1D (and I know we already need to take this axis swapping into account in many places, eg with `NDFrame._get_block_manager_axis(axis)`, and in the internals as well, but that's typically when axis is a keyword of our own, and not a user-specified kwarg of a generic applied function). So I certainly could add an ExtensionBlock.apply override to take this into account. But we could also decide to leave this as is for now.",
        "createdAt" : "2021-01-19T07:47:58Z",
        "updatedAt" : "2021-01-19T15:12:47Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      },
      {
        "id" : "61e795ea-b42e-4c4c-a016-e7b1a29858ef",
        "parentId" : "a2ad607f-9847-47ee-8ef4-2b022c0a0564",
        "authorId" : "adf621f1-4745-479a-a1fc-dc14046a3f4b",
        "body" : "> but in this case it would need to interpret axis differently depending on whether its values are stored as 2D or 1D \r\n\r\nOnce more with feeling: this wouldn't be an issue with 2D EAs.",
        "createdAt" : "2021-01-19T16:35:25Z",
        "updatedAt" : "2021-01-19T16:35:26Z",
        "lastEditedBy" : "adf621f1-4745-479a-a1fc-dc14046a3f4b",
        "tags" : [
        ]
      },
      {
        "id" : "37ae71c2-19b6-447f-bbb7-bc93e849b4d1",
        "parentId" : "a2ad607f-9847-47ee-8ef4-2b022c0a0564",
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "> Once more with feeling: this wouldn't be an issue with 2D EAs.\r\n\r\nAnd I can also say: this wouldn't be an issue with only 1D arrays ..",
        "createdAt" : "2021-01-19T17:54:39Z",
        "updatedAt" : "2021-01-19T17:54:39Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      },
      {
        "id" : "cf4c6fb9-baa3-435b-b7ea-92c32b5651ec",
        "parentId" : "a2ad607f-9847-47ee-8ef4-2b022c0a0564",
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "@TomAugspurger @jbrockmendel I opened https://github.com/pandas-dev/pandas/issues/39275 to keep track of the fact that this can be improved to preserve dtypes",
        "createdAt" : "2021-01-19T18:00:19Z",
        "updatedAt" : "2021-01-19T18:00:19Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      }
    ],
    "commit" : "13dcd5c89af0941057aabe00db157b202cc840ad",
    "line" : 15,
    "diffHunk" : "@@ -1,1 +129,133 @@    # in theory could preserve int dtype for default axis=0\n    expected = pd.DataFrame({\"a\": [1.0, 3.0, 3.0, 4.0], \"b\": [0.1, 4.0, 4.0, 4.0]})\n    tm.assert_frame_equal(result, expected)\n\n    result = np.maximum.accumulate(df, axis=0)"
  }
]
[
  {
    "id" : "81816e60-0a61-40cb-9efd-d768b9145231",
    "prId" : 25884,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/25884#pullrequestreview-220833727",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7e73ef11-a2a0-4ee7-b76f-cb084fc69b6c",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "can you add a test that asserts this in pandas/tests/types/test_api.py",
        "createdAt" : "2019-03-30T18:56:27Z",
        "updatedAt" : "2019-03-30T18:56:42Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "363b220f-3aa3-472b-b2ff-311adf39adca",
        "parentId" : "7e73ef11-a2a0-4ee7-b76f-cb084fc69b6c",
        "authorId" : "5e8c5ef2-940b-436e-9c5f-98ae5460128c",
        "body" : "Yea no problem. So the existing test(s) exclude any privately named modules:\r\n\r\nhttps://github.com/pandas-dev/pandas/blob/27927056b368fa8c9501c4ec8729546dbe98068c/pandas/tests/api/test_api.py#L14\r\n\r\nAre you asking to revisit that logic or simply add a test with this as an exception to make sure it lives there?",
        "createdAt" : "2019-03-30T19:10:45Z",
        "updatedAt" : "2019-03-30T19:10:45Z",
        "lastEditedBy" : "5e8c5ef2-940b-436e-9c5f-98ae5460128c",
        "tags" : [
        ]
      },
      {
        "id" : "4d1914b8-14de-4c1c-9748-2f30530aca7f",
        "parentId" : "7e73ef11-a2a0-4ee7-b76f-cb084fc69b6c",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "oh i c. nvm then. though I think we should actually check and lock down all modules (so add back the private ones). in a new PR / issue though.",
        "createdAt" : "2019-03-30T19:12:20Z",
        "updatedAt" : "2019-03-30T19:12:21Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "7e31345eb573f51718047d131e820370b7a54355",
    "line" : 1,
    "diffHunk" : "@@ -1,1 +-1,3 @@from pathlib import Path\nfrom typing import IO, AnyStr, Union\n"
  },
  {
    "id" : "b8259535-1af4-462c-b995-fcc032aacd8a",
    "prId" : 26588,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/26588#pullrequestreview-246726141",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3af55e43-87d6-454d-8ed0-178cffb3cf1a",
        "parentId" : null,
        "authorId" : "5e8c5ef2-940b-436e-9c5f-98ae5460128c",
        "body" : "Have to think through impact of this some more. After looking at this my thought was we might need to mark this as covariant, but it doesn't look like that is supported in generic functions (which was one of the motivations here):\r\n\r\nhttps://www.python.org/dev/peps/pep-0484/#covariance-and-contravariance\r\n\r\nIf you have any thoughts yourself please let me know!",
        "createdAt" : "2019-05-31T13:11:06Z",
        "updatedAt" : "2019-06-06T18:39:31Z",
        "lastEditedBy" : "5e8c5ef2-940b-436e-9c5f-98ae5460128c",
        "tags" : [
        ]
      },
      {
        "id" : "d83daeb4-4e61-432a-82db-d4dbfe69de9e",
        "parentId" : "3af55e43-87d6-454d-8ed0-178cffb3cf1a",
        "authorId" : "da5e950e-9d1c-4a15-b601-82b67f80b78f",
        "body" : "It's quite a read, I will look at it later today.",
        "createdAt" : "2019-06-03T05:16:39Z",
        "updatedAt" : "2019-06-06T18:39:31Z",
        "lastEditedBy" : "da5e950e-9d1c-4a15-b601-82b67f80b78f",
        "tags" : [
        ]
      },
      {
        "id" : "d265223d-b038-46f3-8b19-b0b93d7033ed",
        "parentId" : "3af55e43-87d6-454d-8ed0-178cffb3cf1a",
        "authorId" : "da5e950e-9d1c-4a15-b601-82b67f80b78f",
        "body" : "I don't think we need convariants here. Even after reading it a couple times I still don't get it very well, but it looks like it has something to do with sub/super class, which doesn't looks like the case here.\r\n",
        "createdAt" : "2019-06-06T09:32:55Z",
        "updatedAt" : "2019-06-06T18:39:31Z",
        "lastEditedBy" : "da5e950e-9d1c-4a15-b601-82b67f80b78f",
        "tags" : [
        ]
      },
      {
        "id" : "27ad4f03-1f5a-45c7-99c4-78e5a7045626",
        "parentId" : "3af55e43-87d6-454d-8ed0-178cffb3cf1a",
        "authorId" : "5e8c5ef2-940b-436e-9c5f-98ae5460128c",
        "body" : "OK. I think this is passing without covariant because we might only be using in generic functions for now. I think it would be a problem when parametrizing containers since these by default are invariant (i.e. we could parametrize a container with ABCIndexClass but not Index) but can deal with that when that happens\r\n\r\nQuoting relevant part of PEP 484:\r\n\r\n> By default generic types are considered invariant in all type variables, which means that values for variables annotated with types like List[Employee] must exactly match the type annotation -- no subclasses or superclasses of the type parameter (in this example Employee) are allowed.",
        "createdAt" : "2019-06-06T17:49:21Z",
        "updatedAt" : "2019-06-06T18:39:31Z",
        "lastEditedBy" : "5e8c5ef2-940b-436e-9c5f-98ae5460128c",
        "tags" : [
        ]
      },
      {
        "id" : "f579410f-85fd-4543-8d85-2006cd6af63b",
        "parentId" : "3af55e43-87d6-454d-8ed0-178cffb3cf1a",
        "authorId" : "5e8c5ef2-940b-436e-9c5f-98ae5460128c",
        "body" : "The end solution for parametrization may be to add a `AnyArrayLike_co` since that's a convention suggested by the PEP anyway",
        "createdAt" : "2019-06-06T17:50:42Z",
        "updatedAt" : "2019-06-06T18:39:31Z",
        "lastEditedBy" : "5e8c5ef2-940b-436e-9c5f-98ae5460128c",
        "tags" : [
        ]
      },
      {
        "id" : "173ac504-1c64-443b-8d0c-c67d87f18381",
        "parentId" : "3af55e43-87d6-454d-8ed0-178cffb3cf1a",
        "authorId" : "da5e950e-9d1c-4a15-b601-82b67f80b78f",
        "body" : "OK, Remaining types are:\r\n\r\n    DatetimeLikeScalar = Type[Union[Period, Timestamp, Timedelta]]\r\n    Dtype = Union[str, np.dtype, ExtensionDtype]\r\n    FilePathOrBuffer = Union[str, Path, IO[AnyStr]]\r\n\r\n- Union in `DatetimeLikeScalar` is nested don't know if it should be converted to `TypeVar`\r\n- Converting `Dtype` to TypeVar starts giving errors.",
        "createdAt" : "2019-06-06T17:58:36Z",
        "updatedAt" : "2019-06-06T18:39:31Z",
        "lastEditedBy" : "da5e950e-9d1c-4a15-b601-82b67f80b78f",
        "tags" : [
        ]
      }
    ],
    "commit" : "2d3376a07abc1dd443863d25109cf41c3923398b",
    "line" : 18,
    "diffHunk" : "@@ -1,1 +12,16 @@    ABCExtensionArray, ABCIndexClass, ABCSeries, ABCSparseSeries)\n\nAnyArrayLike = TypeVar('AnyArrayLike',\n                       ABCExtensionArray,\n                       ABCIndexClass,"
  },
  {
    "id" : "ed80a018-d482-4148-8e8d-e725ab0f1a60",
    "prId" : 26819,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/26819#pullrequestreview-249884513",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "64eef41f-8819-466d-84e7-7006c032944e",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "@WillAyd we should put a line comment on when to use these / what these are if not completely obvious (and then maybe even so).\r\n\r\nfuture PR of course",
        "createdAt" : "2019-06-14T12:35:09Z",
        "updatedAt" : "2019-06-14T12:35:09Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "749758ad-95aa-4df7-bc8a-802ad6eb0167",
        "parentId" : "64eef41f-8819-466d-84e7-7006c032944e",
        "authorId" : "5e8c5ef2-940b-436e-9c5f-98ae5460128c",
        "body" : "Yea I'm going to take another look at this module soon to see if there's a better way of doing things. Also wondering if we should use `if TYPE_CHECKING` imports in that module instead of the ABCs. Will check it out and post separately",
        "createdAt" : "2019-06-14T12:38:03Z",
        "updatedAt" : "2019-06-14T12:38:04Z",
        "lastEditedBy" : "5e8c5ef2-940b-436e-9c5f-98ae5460128c",
        "tags" : [
        ]
      },
      {
        "id" : "163b0e34-bb2c-4dde-97aa-87cde8defe9f",
        "parentId" : "64eef41f-8819-466d-84e7-7006c032944e",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "> Yea I'm going to take another look at this module soon to see if there's a better way of doing things. Also wondering if we should use `if TYPE_CHECKING` imports in that module instead of the ABCs. Will check it out and post separately\r\n\r\n-1 on using TYPE_CHECCKING. I think the way you have it setup is very nice actually, unless I am missing something big.",
        "createdAt" : "2019-06-14T12:40:00Z",
        "updatedAt" : "2019-06-14T12:40:14Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "53ba676b-6d78-4e4e-ada9-d2d835cb369d",
        "parentId" : "64eef41f-8819-466d-84e7-7006c032944e",
        "authorId" : "5e8c5ef2-940b-436e-9c5f-98ae5460128c",
        "body" : "My concern is that the ABC* classes aren't getting type checked correctly. Adding `reveal_type(klass)` to this PR where the TypeVar is used yields the following:\r\n\r\n```sh\r\n$ mypy pandas/core/groupby/generic.py\r\npandas/core/groupby/generic.py:83: error: Revealed type is 'Type[Any]'\r\n```\r\n\r\nThat coupled with @topper-123 's comment around code completion makes me think the ABCs might all be `Type[Any]` since they are generated by `create_pandas_abc_type`, a function without any annotations itself (so implicitly `Type[Any]`)\r\n\r\nGoing to investigate and open a separate issue accordingly",
        "createdAt" : "2019-06-14T12:45:48Z",
        "updatedAt" : "2019-06-14T12:45:48Z",
        "lastEditedBy" : "5e8c5ef2-940b-436e-9c5f-98ae5460128c",
        "tags" : [
        ]
      },
      {
        "id" : "294e6e6c-5f51-4525-89bf-7859805d72c3",
        "parentId" : "64eef41f-8819-466d-84e7-7006c032944e",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "ok fair. I just don't want to introduce overhead for contributors, which typing especially with 'non-standard' things (e.g. ``cast``) can do; we really want to minimize what people have to do (nothwithstanding maybe we have magic that makes things easy).",
        "createdAt" : "2019-06-14T12:53:16Z",
        "updatedAt" : "2019-06-14T12:53:16Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "bf07b51e459aa596022041c6acba62e75e865576",
    "line" : 12,
    "diffHunk" : "@@ -1,1 +22,26 @@                             Timedelta)\nDtype = Union[str, np.dtype, ExtensionDtype]\nFilePathOrBuffer = Union[str, Path, IO[AnyStr]]\n\nFrameOrSeries = TypeVar('FrameOrSeries', ABCSeries, ABCDataFrame)"
  },
  {
    "id" : "de6c4ed8-64af-48e6-89ba-6d747914be9d",
    "prId" : 27424,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/27424#pullrequestreview-265706726",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b2a5067b-6052-46c3-aa66-5b3cc8478907",
        "parentId" : null,
        "authorId" : "554ba0f6-6e6a-40c3-98e0-1a6cc4a8e1c6",
        "body" : "```suggestion\r\nFrameOrSeries = Union[\"Series\", \"DataFrame\"]\r\n```\r\n\r\nquote from https://mypy.readthedocs.io/en/latest/generics.html...\r\n\"User-defined generics are a moderately advanced feature and you can get far without ever using them...\"",
        "createdAt" : "2019-07-22T13:50:30Z",
        "updatedAt" : "2019-07-24T15:11:05Z",
        "lastEditedBy" : "554ba0f6-6e6a-40c3-98e0-1a6cc4a8e1c6",
        "tags" : [
        ]
      },
      {
        "id" : "2c2f37a6-0169-4584-bb92-f54730d02d65",
        "parentId" : "b2a5067b-6052-46c3-aa66-5b3cc8478907",
        "authorId" : "5e8c5ef2-940b-436e-9c5f-98ae5460128c",
        "body" : "Thanks but this just loosens the type system rather than actually fixing anything. TypeVar is going to be generally more useful for checking functions that can be fully generic in nature.\r\n\r\nMight just change the return of this one and see how many others require Union in the future",
        "createdAt" : "2019-07-22T16:25:35Z",
        "updatedAt" : "2019-07-24T15:11:05Z",
        "lastEditedBy" : "5e8c5ef2-940b-436e-9c5f-98ae5460128c",
        "tags" : [
        ]
      },
      {
        "id" : "d663e763-9313-40b7-ba2a-264d3bdbe238",
        "parentId" : "b2a5067b-6052-46c3-aa66-5b3cc8478907",
        "authorId" : "554ba0f6-6e6a-40c3-98e0-1a6cc4a8e1c6",
        "body" : "makes sense. Union[Series, DataFrame] _might_ be better written as NDFrame anyway?",
        "createdAt" : "2019-07-22T16:31:16Z",
        "updatedAt" : "2019-07-24T15:11:05Z",
        "lastEditedBy" : "554ba0f6-6e6a-40c3-98e0-1a6cc4a8e1c6",
        "tags" : [
        ]
      },
      {
        "id" : "cba3b76a-bd17-47c0-ae14-3d692e54899e",
        "parentId" : "b2a5067b-6052-46c3-aa66-5b3cc8478907",
        "authorId" : "5e8c5ef2-940b-436e-9c5f-98ae5460128c",
        "body" : "Also the \"user-defined generics\" you are referring to are more applicable to containers not TypeVars. Right now we just use a blanket `Series` as a return object, though in the future we could do something like `Series[int]` and `Series[str]`, etc...; the `Series` would be the user-defined generic in that case\r\n\r\nThe TypeVar in the docs you linked is just a way of parametrizing that user-defined generic, so that a `Series[int]` would have to stay as a `Series[int]` through it's lifecycle; without that parametrization we allow `Series[int]` to become `Series[str]` without any complaints from mypy today\r\n\r\nWe are probably a ways off of doing user-defined generics but this is great that you looked into it. Certainly open to ideas on that front if you think of a good way to implement as we get more familiar with these annotations",
        "createdAt" : "2019-07-22T16:33:17Z",
        "updatedAt" : "2019-07-24T15:11:05Z",
        "lastEditedBy" : "5e8c5ef2-940b-436e-9c5f-98ae5460128c",
        "tags" : [
        ]
      },
      {
        "id" : "42a066f6-75b7-4810-af20-b9b2dc313973",
        "parentId" : "b2a5067b-6052-46c3-aa66-5b3cc8478907",
        "authorId" : "5e8c5ef2-940b-436e-9c5f-98ae5460128c",
        "body" : "> makes sense. Union[Series, DataFrame] _might_ be better written as NDFrame anyway?\r\n\r\nHmm that would work though we don't typically import NDFrame anywhere so I don't think want to start here",
        "createdAt" : "2019-07-22T16:34:39Z",
        "updatedAt" : "2019-07-24T15:11:05Z",
        "lastEditedBy" : "5e8c5ef2-940b-436e-9c5f-98ae5460128c",
        "tags" : [
        ]
      },
      {
        "id" : "a8fda2b3-3a7e-42f6-9209-5f4e6533b8b9",
        "parentId" : "b2a5067b-6052-46c3-aa66-5b3cc8478907",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "I would leave as FrameOrSeries as its more descriptive",
        "createdAt" : "2019-07-23T22:17:12Z",
        "updatedAt" : "2019-07-24T15:11:06Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "5e77b75ccc82c64cadb97a357661150ca4ef1e1f",
    "line" : 49,
    "diffHunk" : "@@ -1,1 +25,29 @@FilePathOrBuffer = Union[str, Path, IO[AnyStr]]\n\nFrameOrSeries = TypeVar(\"FrameOrSeries\", \"Series\", \"DataFrame\")\nScalar = Union[str, int, float]\nAxis = Union[str, int]"
  },
  {
    "id" : "b4f9a501-8489-4612-ae06-f9f6308f8a44",
    "prId" : 28173,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/28173#pullrequestreview-280313410",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "62f1f4e2-1c42-4826-b04f-3fbdbcf229d2",
        "parentId" : null,
        "authorId" : "5e8c5ef2-940b-436e-9c5f-98ae5460128c",
        "body" : "Can you just add a quick inline comment for the purpose of this one? May be useful for those who haven't invested a lot of time in annotations yet",
        "createdAt" : "2019-08-27T13:16:43Z",
        "updatedAt" : "2019-08-27T20:07:49Z",
        "lastEditedBy" : "5e8c5ef2-940b-436e-9c5f-98ae5460128c",
        "tags" : [
        ]
      },
      {
        "id" : "5ba93ec4-1c90-448a-bd8e-21795f56a274",
        "parentId" : "62f1f4e2-1c42-4826-b04f-3fbdbcf229d2",
        "authorId" : "554ba0f6-6e6a-40c3-98e0-1a6cc4a8e1c6",
        "body" : "something like\r\n\r\n```\r\n# Unconstrained type variable for generic functions and user-defined generic types.\r\n# see https://docs.python.org/3/library/typing.html#generics and\r\n# https://docs.python.org/3/library/typing.html#typing.TypeVar for more info.\r\n```",
        "createdAt" : "2019-08-27T13:26:52Z",
        "updatedAt" : "2019-08-27T20:07:49Z",
        "lastEditedBy" : "554ba0f6-6e6a-40c3-98e0-1a6cc4a8e1c6",
        "tags" : [
        ]
      },
      {
        "id" : "cf0f43d4-27a9-48ac-80f3-9ad9b8b47a00",
        "parentId" : "62f1f4e2-1c42-4826-b04f-3fbdbcf229d2",
        "authorId" : "5e8c5ef2-940b-436e-9c5f-98ae5460128c",
        "body" : "Ideally less technical. Maybe something like `# to maintain type information across generic functions and parametrization` or even slightly less technical if possible",
        "createdAt" : "2019-08-27T16:15:43Z",
        "updatedAt" : "2019-08-27T20:07:49Z",
        "lastEditedBy" : "5e8c5ef2-940b-436e-9c5f-98ae5460128c",
        "tags" : [
        ]
      }
    ],
    "commit" : "c46de9786acd86710f21257deb166e3781da5822",
    "line" : 22,
    "diffHunk" : "@@ -1,1 +31,35 @@\n# to maintain type information across generic functions and parametrization\n_T = TypeVar(\"_T\")"
  },
  {
    "id" : "2622d9c9-952d-41e4-8188-5a8b47d94da0",
    "prId" : 30541,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/30541#pullrequestreview-337197640",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e58e321a-8be3-488e-b5bf-e004ec28a6cc",
        "parentId" : null,
        "authorId" : "5e8c5ef2-940b-436e-9c5f-98ae5460128c",
        "body" : "Does it matter that this is a Union of a Union and a TypeVar? Maybe DatetimeLikeScalar should just be a Union?",
        "createdAt" : "2019-12-30T17:04:35Z",
        "updatedAt" : "2019-12-30T18:56:46Z",
        "lastEditedBy" : "5e8c5ef2-940b-436e-9c5f-98ae5460128c",
        "tags" : [
        ]
      },
      {
        "id" : "f42379c2-7263-4605-b68d-5024d9396165",
        "parentId" : "e58e321a-8be3-488e-b5bf-e004ec28a6cc",
        "authorId" : "554ba0f6-6e6a-40c3-98e0-1a6cc4a8e1c6",
        "body" : "yes, we have the same issue as with FilePathOrBuffer, where IO is unbound in the Union and requires the addition of type parameters when using the alias.\r\n\r\nand we don't really want that for Scalar. but we had Scalar as a union (for JSONSerializable)  and DatetimeLikeScalar as a TypeVar.\r\n\r\n> Maybe DatetimeLikeScalar should just be a Union?\r\n\r\nrather than change this, maybe should define `PandasScalar = Union[\"Period\", \"Timestamp\", \"Timedelta\", \"Interval\"]` for now\r\n\r\n",
        "createdAt" : "2019-12-30T17:40:02Z",
        "updatedAt" : "2019-12-30T18:56:46Z",
        "lastEditedBy" : "554ba0f6-6e6a-40c3-98e0-1a6cc4a8e1c6",
        "tags" : [
        ]
      },
      {
        "id" : "dc86ad88-d85a-4c62-b2e4-a4f87d0f0c58",
        "parentId" : "e58e321a-8be3-488e-b5bf-e004ec28a6cc",
        "authorId" : "5e8c5ef2-940b-436e-9c5f-98ae5460128c",
        "body" : "Yea makes sense",
        "createdAt" : "2019-12-30T18:29:48Z",
        "updatedAt" : "2019-12-30T18:56:46Z",
        "lastEditedBy" : "5e8c5ef2-940b-436e-9c5f-98ae5460128c",
        "tags" : [
        ]
      }
    ],
    "commit" : "7d0d865c9647e3dc37124299fdebe7795d491fce",
    "line" : 16,
    "diffHunk" : "@@ -1,1 +36,40 @@DatetimeLikeScalar = TypeVar(\"DatetimeLikeScalar\", \"Period\", \"Timestamp\", \"Timedelta\")\nPandasScalar = Union[\"Period\", \"Timestamp\", \"Timedelta\", \"Interval\"]\nScalar = Union[PythonScalar, PandasScalar]\n\n# other"
  },
  {
    "id" : "1b3e023d-42fd-46fe-a3d3-327e520b4940",
    "prId" : 31426,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/31426#pullrequestreview-351285587",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8d9f0d93-a876-4a7e-931a-56ae51966239",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "shouldn't we call this DtypeType?",
        "createdAt" : "2020-01-31T03:17:42Z",
        "updatedAt" : "2020-01-31T03:17:42Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "06df8831-79e6-4938-bf85-fc86c3c7bf2b",
        "parentId" : "8d9f0d93-a876-4a7e-931a-56ae51966239",
        "authorId" : "adf621f1-4745-479a-a1fc-dc14046a3f4b",
        "body" : "DtypeType seems easy to confuse with dtype.type, like it would be the type for CategoricalDtypeType",
        "createdAt" : "2020-01-31T04:09:22Z",
        "updatedAt" : "2020-01-31T04:09:23Z",
        "lastEditedBy" : "adf621f1-4745-479a-a1fc-dc14046a3f4b",
        "tags" : [
        ]
      },
      {
        "id" : "c9484ecc-0dd3-4c64-a5d3-139970404aae",
        "parentId" : "8d9f0d93-a876-4a7e-931a-56ae51966239",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "ahh i c, so this is not a type, just a non-string Dtype. ok then.",
        "createdAt" : "2020-01-31T04:16:09Z",
        "updatedAt" : "2020-01-31T04:16:10Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "ed0b79e22ebc81cd41c58cc4ee9810c11cf36292",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +46,50 @@\nDtype = Union[str, np.dtype, \"ExtensionDtype\"]\nDtypeObj = Union[np.dtype, \"ExtensionDtype\"]\nFilePathOrBuffer = Union[str, Path, IO[AnyStr]]\n"
  },
  {
    "id" : "4ce5f502-09de-4bfb-9107-58c8a06f3fb6",
    "prId" : 32042,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/32042#pullrequestreview-359416195",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8b64db5c-9526-45b9-ae85-bc6ca2cbaedc",
        "parentId" : null,
        "authorId" : "554ba0f6-6e6a-40c3-98e0-1a6cc4a8e1c6",
        "body" : "None is serializable",
        "createdAt" : "2020-02-16T17:02:31Z",
        "updatedAt" : "2020-02-27T12:35:21Z",
        "lastEditedBy" : "554ba0f6-6e6a-40c3-98e0-1a6cc4a8e1c6",
        "tags" : [
        ]
      }
    ],
    "commit" : "099e57dbc6a3f8c7c84140cdc381a38753d071c0",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +65,69 @@Level = Union[Label, int]\nOrdered = Optional[bool]\nJSONSerializable = Optional[Union[PythonScalar, List, Dict]]\nAxes = Collection\n"
  },
  {
    "id" : "1d447ffd-a7fe-4a6c-ae14-eab920c034e1",
    "prId" : 35220,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/35220#pullrequestreview-446680724",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "deef4f5b-dc75-4c2e-9c16-cd40bf3150f3",
        "parentId" : null,
        "authorId" : "5e8c5ef2-940b-436e-9c5f-98ae5460128c",
        "body" : "If there is a more generic name you can think of than `AggFuncTypeBase` I think would be useful in other areas that aren't aggregations; i.e. in groupby a lot we accept a callable / str and resolve the latter to a builtin or NumPy func if we can, which could use this same type",
        "createdAt" : "2020-07-10T20:24:54Z",
        "updatedAt" : "2020-07-10T20:24:54Z",
        "lastEditedBy" : "5e8c5ef2-940b-436e-9c5f-98ae5460128c",
        "tags" : [
        ]
      }
    ],
    "commit" : "e1a7812278ee8ba53c99d6176c14afe88ec78a1f",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +99,103 @@\n# types of `func` kwarg for DataFrame.aggregate and Series.aggregate\nAggFuncTypeBase = Union[Callable, str]\nAggFuncType = Union[\n    AggFuncTypeBase,"
  },
  {
    "id" : "2a8516d0-d963-44fe-a2bc-0ea513bab510",
    "prId" : 36046,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/36046#pullrequestreview-485558768",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "63166db8-8c5b-4ea7-b936-73d5ed655283",
        "parentId" : null,
        "authorId" : "554ba0f6-6e6a-40c3-98e0-1a6cc4a8e1c6",
        "body" : "the Optional in Label above is to include None in Label. (On hindsight, I think this could have been Union[Hashable, None] for clarity but we don't use the Union[..., None] pattern)\r\n\r\nAnd also I'm not sure how we got the Ordered alias below.\r\n\r\nIn pandas._typing, I would generally prefer that we don't include the Optional, and just add it when needed in the annotations. I think this in generally allows more use of the aliases (i.e. after setting a default since we don't always set defaults in the signatures) \r\n\r\nso in the code, you would have \r\n\r\n```\r\nindex_label: Optional[IndexLabel] = None\r\n```\r\ninstead of\r\n```\r\nindex_label: IndexLabel = None\r\n```\r\n\r\nof course Label includes None anyway so the Optional isn't needed anyway. it's just a stylistic preference.",
        "createdAt" : "2020-09-09T10:35:00Z",
        "updatedAt" : "2020-09-09T10:38:26Z",
        "lastEditedBy" : "554ba0f6-6e6a-40c3-98e0-1a6cc4a8e1c6",
        "tags" : [
        ]
      },
      {
        "id" : "fce8f750-ca5d-4295-b476-2d01ac2fa2a3",
        "parentId" : "63166db8-8c5b-4ea7-b936-73d5ed655283",
        "authorId" : "6401b20f-26b1-4a7c-8433-dc789c15b9e1",
        "body" : "@simonjayhawkins, I agree that it is more reasonable to define Label and IndexLabel without Optional. I will take a look at this in a separate PR.",
        "createdAt" : "2020-09-10T04:34:36Z",
        "updatedAt" : "2020-09-10T04:34:36Z",
        "lastEditedBy" : "6401b20f-26b1-4a7c-8433-dc789c15b9e1",
        "tags" : [
        ]
      }
    ],
    "commit" : "e08f6564070807c1608911a6343104def57e5393",
    "line" : 12,
    "diffHunk" : "@@ -1,1 +84,88 @@Axis = Union[str, int]\nLabel = Optional[Hashable]\nIndexLabel = Optional[Union[Label, Sequence[Label]]]\nLevel = Union[Label, int]\nOrdered = Optional[bool]"
  },
  {
    "id" : "dfd4bc7c-4f04-4e9c-bda7-a28f4a37bc84",
    "prId" : 36098,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/36098#pullrequestreview-482839363",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "737db7eb-3378-438d-ba61-a8b8941d912c",
        "parentId" : null,
        "authorId" : "adf621f1-4745-479a-a1fc-dc14046a3f4b",
        "body" : "object here is for when we use `object` as a shorthand for `np.dtype(object)`?",
        "createdAt" : "2020-09-04T15:58:59Z",
        "updatedAt" : "2020-09-04T15:59:00Z",
        "lastEditedBy" : "adf621f1-4745-479a-a1fc-dc14046a3f4b",
        "tags" : [
        ]
      },
      {
        "id" : "9434a9f8-fcf2-48d0-9f1e-cb41237d4c5d",
        "parentId" : "737db7eb-3378-438d-ba61-a8b8941d912c",
        "authorId" : "554ba0f6-6e6a-40c3-98e0-1a6cc4a8e1c6",
        "body" : "yep, but Dtype is also used to type the public facing api. ideally we don't want object here, but we don't want users to have false positives either. saying that we have not yet come to an agreement on how we will make the types public. see #28142",
        "createdAt" : "2020-09-04T17:38:13Z",
        "updatedAt" : "2020-09-04T17:38:14Z",
        "lastEditedBy" : "554ba0f6-6e6a-40c3-98e0-1a6cc4a8e1c6",
        "tags" : [
        ]
      }
    ],
    "commit" : "db640fa2537ff18bf4d9da6cf7443b05cdae053e",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +63,67 @@\nDtype = Union[\n    \"ExtensionDtype\", str, np.dtype, Type[Union[str, float, int, complex, bool, object]]\n]\nDtypeObj = Union[np.dtype, \"ExtensionDtype\"]"
  }
]
[
  {
    "id" : "3bc2e49a-46a6-4585-8abe-4155ffc0def4",
    "prId" : 4991,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d11c668d-bd73-49ec-ba0a-39530f626567",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "don't convert to np.str, leave as np.object. But I think this might need be a tad more restrictive. If all types are numeric (and none of np.datetime64 or np.timedelta64), then use the common. else with mixed typed use np.object. User can then deal with it. You _could_ do a UserWarning in the 2nd case (e.g more than 1 type and its going to be object). See if it triggers at all currently (and need a test for triggering it), you can use tm.assert_raises_warning.\n",
        "createdAt" : "2013-09-26T10:59:37Z",
        "updatedAt" : "2013-09-29T18:05:20Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "c1836fab25bca5f93363cc7f7d637e5f4ec0af4d",
    "line" : 29,
    "diffHunk" : "@@ -1,1 +1750,1754 @@        if len(dtypes) > 1:\n            common_type = np.find_common_type(dtypes, [])\n            if common_type == np.object:\n                warning_columns.append(str(name))\n        result[name] = np.concatenate(arrs)"
  }
]
[
  {
    "id" : "ca9d61ef-b501-418d-a1fc-862cbeea99da",
    "prId" : 7217,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3667ca01-c807-4be3-afa5-5882f8eb1c1c",
        "parentId" : null,
        "authorId" : "95fe324c-e973-4cca-9b8d-19248c6f5e92",
        "body" : "Is that intended that this call does _NOT_ include `skipna`? Quick fix would be to remove the keyword arg in the `_reduce(...)` definition.\n",
        "createdAt" : "2014-06-24T13:03:17Z",
        "updatedAt" : "2014-07-14T21:17:33Z",
        "lastEditedBy" : "95fe324c-e973-4cca-9b8d-19248c6f5e92",
        "tags" : [
        ]
      },
      {
        "id" : "60f4b49c-f092-461d-aa5b-11301486f626",
        "parentId" : "3667ca01-c807-4be3-afa5-5882f8eb1c1c",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "that's a 'standard' call, so its passed as an option (e.g. you can do `s.sum(skipna=False)` if you wanted to (for a regular series). We _could_ pass it to the supported reducers (e.g. min/max). \n\nShould we?\n",
        "createdAt" : "2014-06-24T13:10:34Z",
        "updatedAt" : "2014-07-14T21:17:33Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "a092ac13-a0d5-4c34-960b-817bfc34f910",
        "parentId" : "3667ca01-c807-4be3-afa5-5882f8eb1c1c",
        "authorId" : "95fe324c-e973-4cca-9b8d-19248c6f5e92",
        "body" : "I think this is the same as https://github.com/pydata/pandas/issues/4147\n-> If that gets fixed this part should also get fixed...\n\nIMO it should get fixed, as I expected not to get a `inf` from `min()/max` \n",
        "createdAt" : "2014-06-24T13:53:12Z",
        "updatedAt" : "2014-07-14T21:17:33Z",
        "lastEditedBy" : "95fe324c-e973-4cca-9b8d-19248c6f5e92",
        "tags" : [
        ]
      }
    ],
    "commit" : "ea0a13c172761348d08285a19ebf731cdabb2db3",
    "line" : 842,
    "diffHunk" : "@@ -1,1 +803,807 @@        if func is None:\n            raise TypeError(\"Categorical cannot perform the operation {op}\".format(op=name))\n        return func(numeric_only=numeric_only, **kwds)\n\n    def min(self, numeric_only=None, **kwargs):"
  },
  {
    "id" : "039a3548-44b9-423f-b161-151056f98619",
    "prId" : 8153,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5a84891c-746f-46ee-af06-be639cad0f25",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "don't you have to prefix with the class? @jorisvandenbossche ?\n",
        "createdAt" : "2014-09-23T15:03:35Z",
        "updatedAt" : "2014-09-25T17:45:48Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "a708b5d0-4f37-46c8-a2df-1710c78e0dc0",
        "parentId" : "5a84891c-746f-46ee-af06-be639cad0f25",
        "authorId" : "95fe324c-e973-4cca-9b8d-19248c6f5e92",
        "body" : "The links are generated. Not sure what is the best way to link to the cat accessor vs to the categorical (`doc=func.__doc__.replace(...)`?)\n",
        "createdAt" : "2014-09-23T15:19:36Z",
        "updatedAt" : "2014-09-25T17:45:48Z",
        "lastEditedBy" : "95fe324c-e973-4cca-9b8d-19248c6f5e92",
        "tags" : [
        ]
      }
    ],
    "commit" : "3f282da6aac82fabf0749933fe8259a8bd6f33a6",
    "line" : 82,
    "diffHunk" : "@@ -1,1 +98,102 @@rename_categories\nreorder_categories\nadd_categories\nremove_categories\nremove_unused_categories"
  },
  {
    "id" : "556ce246-f833-43dd-b878-f0cd67c42d24",
    "prId" : 8153,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "dbae9a35-f42c-48a6-b5f7-505a96730d90",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "pls create an issue for this deprecation (and i'll link to the deprecation page)\n",
        "createdAt" : "2014-09-23T15:04:27Z",
        "updatedAt" : "2014-09-25T17:45:48Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "64e4393f-f243-42a6-8e79-3aee95385df7",
        "parentId" : "dbae9a35-f42c-48a6-b5f7-505a96730d90",
        "authorId" : "95fe324c-e973-4cca-9b8d-19248c6f5e92",
        "body" : "done\n",
        "createdAt" : "2014-09-23T21:55:07Z",
        "updatedAt" : "2014-09-25T17:45:48Z",
        "lastEditedBy" : "95fe324c-e973-4cca-9b8d-19248c6f5e92",
        "tags" : [
        ]
      }
    ],
    "commit" : "3f282da6aac82fabf0749933fe8259a8bd6f33a6",
    "line" : 208,
    "diffHunk" : "@@ -1,1 +204,208 @@            name = getattr(values, 'name', None)\n\n        # TODO: Remove after deprecation period in 2017/ after 0.18\n        if not levels is None:\n            warn(\"Creating a 'Categorical' with 'levels' is deprecated, use 'categories' instead\","
  },
  {
    "id" : "5eeac30b-d064-4bb4-91cf-11f33565a219",
    "prId" : 9331,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f40361c1-98a5-405a-b487-5e8ae0fa2500",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "still need the nan insertion otherwise the -1 code would have meaning \n",
        "createdAt" : "2015-01-23T07:04:35Z",
        "updatedAt" : "2015-02-12T03:33:11Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "88efca84-680d-439a-ac58-f44cec0d4038",
        "parentId" : "f40361c1-98a5-405a-b487-5e8ae0fa2500",
        "authorId" : "40104112-cdcf-4812-8f95-b502b40e346d",
        "body" : "@jreback This is fed into `take_1d` which fills -1 with `fill_value`... which is happily exactly what we want here to handle NaN. That behavior is unchanged from before (and still tested). So I think this is OK?\n",
        "createdAt" : "2015-01-23T07:09:38Z",
        "updatedAt" : "2015-02-12T03:33:11Z",
        "lastEditedBy" : "40104112-cdcf-4812-8f95-b502b40e346d",
        "tags" : [
        ]
      },
      {
        "id" : "1569696c-1543-4c80-ae60-12b8e27d1799",
        "parentId" : "f40361c1-98a5-405a-b487-5e8ae0fa2500",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "ahh yes that's right\nok then \n",
        "createdAt" : "2015-01-23T07:11:40Z",
        "updatedAt" : "2015-02-12T03:33:11Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "1ef12ff5-4435-44d5-b065-9973254d19dc",
        "parentId" : "f40361c1-98a5-405a-b487-5e8ae0fa2500",
        "authorId" : "95fe324c-e973-4cca-9b8d-19248c6f5e92",
        "body" : "Afaik unique sorts nan last...\n",
        "createdAt" : "2015-01-23T07:12:53Z",
        "updatedAt" : "2015-02-12T03:33:11Z",
        "lastEditedBy" : "95fe324c-e973-4cca-9b8d-19248c6f5e92",
        "tags" : [
        ]
      },
      {
        "id" : "26f9ce6f-b93a-4f84-870d-0562f9b52e85",
        "parentId" : "f40361c1-98a5-405a-b487-5e8ae0fa2500",
        "authorId" : "40104112-cdcf-4812-8f95-b502b40e346d",
        "body" : "@JanSchulz Nope, unique1d does not sort NaN last. I modified the test involving NaNs to make sure.\n",
        "createdAt" : "2015-01-23T08:10:03Z",
        "updatedAt" : "2015-02-12T03:33:11Z",
        "lastEditedBy" : "40104112-cdcf-4812-8f95-b502b40e346d",
        "tags" : [
        ]
      },
      {
        "id" : "f233412d-f005-4af1-8583-bf60d5061515",
        "parentId" : "f40361c1-98a5-405a-b487-5e8ae0fa2500",
        "authorId" : "95fe324c-e973-4cca-9b8d-19248c6f5e92",
        "body" : "ok, `s.unique()` also not. Seems that sorting an nan handling is only done in numpy...\n\n```\ns = pd.Series([1,2,3,4,5,np.nan,6,1,2,3,4])\ns.unique()\narray([  1.,   2.,   3.,   4.,   5.,  nan,   6.])\n```\n\nSorry for the noise...\n",
        "createdAt" : "2015-01-23T08:25:16Z",
        "updatedAt" : "2015-02-12T03:33:11Z",
        "lastEditedBy" : "95fe324c-e973-4cca-9b8d-19248c6f5e92",
        "tags" : [
        ]
      }
    ],
    "commit" : "b787bf87906d6bac5cd3f13151e583302f44f85d",
    "line" : 17,
    "diffHunk" : "@@ -1,1 +1394,1398 @@        unique values : array\n        \"\"\"\n        from pandas.core.nanops import unique1d\n        # unlike np.unique, unique1d does not sort\n        unique_codes = unique1d(self.codes)"
  },
  {
    "id" : "688d6788-449c-4eef-b413-df82c19cdd7b",
    "prId" : 10597,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c16cd9f9-71d2-4ed2-b80e-c5a138c8d4db",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "I don't think you can ever hit the else. The cats have to be exactly the same by definition (otherwise you are raising). So the path where you cast everything to object (then regular concat) should be there.\n",
        "createdAt" : "2015-07-16T22:27:41Z",
        "updatedAt" : "2015-07-16T23:11:18Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "0477d32a-036d-469c-bb13-8b30b4bdcdf6",
        "parentId" : "c16cd9f9-71d2-4ed2-b80e-c5a138c8d4db",
        "authorId" : "5c239b83-5a68-467b-a3f8-113a0fc494dc",
        "body" : "you can definitely hit the `else`, eg `to_concat[0]` is a categorical and `to_concat[1]` is an object array\n",
        "createdAt" : "2015-07-16T22:31:19Z",
        "updatedAt" : "2015-07-16T23:11:18Z",
        "lastEditedBy" : "5c239b83-5a68-467b-a3f8-113a0fc494dc",
        "tags" : [
        ]
      },
      {
        "id" : "f9b631f9-d554-4f10-badf-2537b3be9f2b",
        "parentId" : "c16cd9f9-71d2-4ed2-b80e-c5a138c8d4db",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "that would be hit above (2 different dtypes)\n",
        "createdAt" : "2015-07-16T22:32:49Z",
        "updatedAt" : "2015-07-16T23:11:18Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "c8712d6e-b692-4468-8170-c435b5acf031",
        "parentId" : "c16cd9f9-71d2-4ed2-b80e-c5a138c8d4db",
        "authorId" : "5c239b83-5a68-467b-a3f8-113a0fc494dc",
        "body" : "how so? if `get_dtype_kinds(to_concat) == set(['object', 'category'])` then it _isn't_ handled above because the set will be empty\n",
        "createdAt" : "2015-07-16T22:34:22Z",
        "updatedAt" : "2015-07-16T23:11:18Z",
        "lastEditedBy" : "5c239b83-5a68-467b-a3f8-113a0fc494dc",
        "tags" : [
        ]
      },
      {
        "id" : "18667dc9-bef6-4db2-ac46-7c38742b9ab6",
        "parentId" : "c16cd9f9-71d2-4ed2-b80e-c5a138c8d4db",
        "authorId" : "5c239b83-5a68-467b-a3f8-113a0fc494dc",
        "body" : "that logic only handle the case of having other dtypes _besides_ object and category\n",
        "createdAt" : "2015-07-16T22:35:10Z",
        "updatedAt" : "2015-07-16T23:11:18Z",
        "lastEditedBy" : "5c239b83-5a68-467b-a3f8-113a0fc494dc",
        "tags" : [
        ]
      },
      {
        "id" : "cbda8ff3-019c-47bd-af10-689719bba54b",
        "parentId" : "c16cd9f9-71d2-4ed2-b80e-c5a138c8d4db",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "the check on len bothers me that make sense if everything is a categorical and identical\n\nbut by definition that would be true as u just checked dtypes \n",
        "createdAt" : "2015-07-16T22:40:12Z",
        "updatedAt" : "2015-07-16T23:11:18Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "1659dd98-fc28-4fd5-be82-2a7ec8d092a4",
        "parentId" : "c16cd9f9-71d2-4ed2-b80e-c5a138c8d4db",
        "authorId" : "5c239b83-5a68-467b-a3f8-113a0fc494dc",
        "body" : "not if you're concatenating an object dtype with a categorical dtype\n",
        "createdAt" : "2015-07-16T22:42:08Z",
        "updatedAt" : "2015-07-16T23:11:18Z",
        "lastEditedBy" : "5c239b83-5a68-467b-a3f8-113a0fc494dc",
        "tags" : [
        ]
      }
    ],
    "commit" : "6213fb37e38228c681ef99e7a86f3dec4a58a408",
    "line" : 71,
    "diffHunk" : "@@ -1,1 +1759,1763 @@    # length is equal to the input then we have all the same categories\n    if len(categoricals) == len(to_concat):\n        # concating numeric types is much faster than concating object types\n        # and fastpath takes a shorter path through the constructor\n        return Categorical(np.concatenate([x.codes for x in to_concat], axis=0),"
  },
  {
    "id" : "35aaa6a6-f8af-4415-95e9-9cc7de155737",
    "prId" : 10597,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "52ce049b-8655-4bec-8091-cb886d9eaaba",
        "parentId" : null,
        "authorId" : "40104112-cdcf-4812-8f95-b502b40e346d",
        "body" : "maybe add `assert axis == 0`?\n",
        "createdAt" : "2015-07-16T22:27:53Z",
        "updatedAt" : "2015-07-16T23:11:18Z",
        "lastEditedBy" : "40104112-cdcf-4812-8f95-b502b40e346d",
        "tags" : [
        ]
      }
    ],
    "commit" : "6213fb37e38228c681ef99e7a86f3dec4a58a408",
    "line" : 24,
    "diffHunk" : "@@ -1,1 +1731,1735 @@        A single array, preserving the combined dtypes\n    \"\"\"\n\n    def convert_categorical(x):\n        # coerce to object dtype"
  },
  {
    "id" : "30e8793f-9090-4ccb-a30f-3a545911f754",
    "prId" : 10597,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "dc9951e9-41d0-4c2a-a93d-532ffb5d32e4",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "here\n",
        "createdAt" : "2015-07-16T22:34:47Z",
        "updatedAt" : "2015-07-16T23:11:18Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "30efd3dd-48c0-4a1a-9d1a-02be1c671751",
        "parentId" : "dc9951e9-41d0-4c2a-a93d-532ffb5d32e4",
        "authorId" : "5c239b83-5a68-467b-a3f8-113a0fc494dc",
        "body" : "that's only if there's stuff besides object and category ... i have only object and category then the else can definitely be hit\n",
        "createdAt" : "2015-07-16T22:36:31Z",
        "updatedAt" : "2015-07-16T23:11:18Z",
        "lastEditedBy" : "5c239b83-5a68-467b-a3f8-113a0fc494dc",
        "tags" : [
        ]
      },
      {
        "id" : "f9bc8cff-2c61-4e39-831c-6c2ad3267c17",
        "parentId" : "dc9951e9-41d0-4c2a-a93d-532ffb5d32e4",
        "authorId" : "5c239b83-5a68-467b-a3f8-113a0fc494dc",
        "body" : "your comment just below that says\n\n> we could have object blocks and categoricals here\n",
        "createdAt" : "2015-07-16T22:37:55Z",
        "updatedAt" : "2015-07-16T23:11:18Z",
        "lastEditedBy" : "5c239b83-5a68-467b-a3f8-113a0fc494dc",
        "tags" : [
        ]
      },
      {
        "id" : "842c794b-b98a-4675-ae29-3d16f554f11b",
        "parentId" : "dc9951e9-41d0-4c2a-a93d-532ffb5d32e4",
        "authorId" : "5c239b83-5a68-467b-a3f8-113a0fc494dc",
        "body" : "@jreback  here's an example of how to hit that code path\n\n``` python\nIn [1]: s = pd.Series(list('aabbcd')*1000000)\n\nIn [2]: s2 = pd.Series(list('aabbcd')*1000000).astype('category')\n\nIn [3]: pd.concat([s,s2])\n```\n",
        "createdAt" : "2015-07-16T22:40:58Z",
        "updatedAt" : "2015-07-16T23:11:18Z",
        "lastEditedBy" : "5c239b83-5a68-467b-a3f8-113a0fc494dc",
        "tags" : [
        ]
      },
      {
        "id" : "fd97186f-0832-4606-bb5b-6f2fa4d7f3d1",
        "parentId" : "dc9951e9-41d0-4c2a-a93d-532ffb5d32e4",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "no I get that\nmy point is the len check is not good enough\n",
        "createdAt" : "2015-07-16T22:42:43Z",
        "updatedAt" : "2015-07-16T23:11:18Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "1484402d-a874-43cc-98fa-9f65eb8366bd",
        "parentId" : "dc9951e9-41d0-4c2a-a93d-532ffb5d32e4",
        "authorId" : "5c239b83-5a68-467b-a3f8-113a0fc494dc",
        "body" : "why not? we have\n1. everything is a categorical because the filtering above when building up `categoricals`\n2. all the categories are equivalent via `categories.is_dtype_equal(first_set_of_categories)`\n\nwhat else is there to check?\n",
        "createdAt" : "2015-07-16T22:44:43Z",
        "updatedAt" : "2015-07-16T23:11:18Z",
        "lastEditedBy" : "5c239b83-5a68-467b-a3f8-113a0fc494dc",
        "tags" : [
        ]
      },
      {
        "id" : "5693e485-39b2-4add-8ca8-953308359486",
        "parentId" : "dc9951e9-41d0-4c2a-a93d-532ffb5d32e4",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "ok, back at computer.\n\nI think the issue is what do do with an `object` that has same or < categories (then ok), but what if it has more categories (uniques).\n\nSo I would do this.\n\nhave all matching categories (exactly), with no object in a single path\nelse just push everything to object.\n",
        "createdAt" : "2015-07-16T22:50:34Z",
        "updatedAt" : "2015-07-16T23:11:18Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "29a363d9-d1d0-41e1-85ad-dc12c7d448dd",
        "parentId" : "dc9951e9-41d0-4c2a-a93d-532ffb5d32e4",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "nvm. I was relalized that you are doing exactly what I was saying :) duh.\n\ngo ahead.\n",
        "createdAt" : "2015-07-16T22:51:46Z",
        "updatedAt" : "2015-07-16T23:11:18Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "73b6efc8-a446-46ec-8116-203b17a5be38",
        "parentId" : "dc9951e9-41d0-4c2a-a93d-532ffb5d32e4",
        "authorId" : "5c239b83-5a68-467b-a3f8-113a0fc494dc",
        "body" : "so i think you're pointing out something that i'm not addressing:\n\n``` python\nIn [4]: s = pd.Series(list('aabbcd'))\n\nIn [5]: s2 = pd.Series(list('aabb')).astype('category')\n\nIn [6]: pd.concat([s,s2])\nOut[6]:\n0      a\n1      a\n2      b\n3      b\n4    NaN\n5    NaN\n0      a\n1      a\n2      b\n3      b\ndtype: category\nCategories (2, object): [a, b]\n```\n\n_However_, that was run on current master and is a separate issue from the performance of concatenation.\n",
        "createdAt" : "2015-07-16T22:55:48Z",
        "updatedAt" : "2015-07-16T23:11:18Z",
        "lastEditedBy" : "5c239b83-5a68-467b-a3f8-113a0fc494dc",
        "tags" : [
        ]
      },
      {
        "id" : "ee353cc6-c11a-4381-915a-88b20d1e4cda",
        "parentId" : "dc9951e9-41d0-4c2a-a93d-532ffb5d32e4",
        "authorId" : "5c239b83-5a68-467b-a3f8-113a0fc494dc",
        "body" : "I think I can fix this by simply not passing the second argument to the else branch\n",
        "createdAt" : "2015-07-16T23:00:58Z",
        "updatedAt" : "2015-07-16T23:11:18Z",
        "lastEditedBy" : "5c239b83-5a68-467b-a3f8-113a0fc494dc",
        "tags" : [
        ]
      }
    ],
    "commit" : "6213fb37e38228c681ef99e7a86f3dec4a58a408",
    "line" : 38,
    "diffHunk" : "@@ -1,1 +1738,1742 @@        return x.ravel()\n\n    if get_dtype_kinds(to_concat) - set(['object', 'category']):\n        # convert to object type and perform a regular concat\n        from pandas.core.common import _concat_compat"
  },
  {
    "id" : "3d6e18f4-8eb6-4fde-a7c7-82f66a92536a",
    "prId" : 16015,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/16015#pullrequestreview-64087002",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f49e95f7-1825-4f02-814b-8a08e3646346",
        "parentId" : null,
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "Can't this use the `__eq__` method of the dtype ?",
        "createdAt" : "2017-09-15T14:48:45Z",
        "updatedAt" : "2017-09-23T16:33:31Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      },
      {
        "id" : "fdaeda6d-0d27-4a52-a92e-33398a63afc9",
        "parentId" : "f49e95f7-1825-4f02-814b-8a08e3646346",
        "authorId" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "body" : "This would run into the strangeness of `CategoricalDtype(None) == CategoricalDtype(['a', 'b'], True)` being true, which we don't want here.",
        "createdAt" : "2017-09-15T20:36:48Z",
        "updatedAt" : "2017-09-23T16:33:31Z",
        "lastEditedBy" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "tags" : [
        ]
      },
      {
        "id" : "28d58e0c-31ab-458b-b120-2b67ecba04a3",
        "parentId" : "f49e95f7-1825-4f02-814b-8a08e3646346",
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "Ah, that's a good point. But is there then a way for a user to do this, apart from this hash checking?",
        "createdAt" : "2017-09-18T07:57:56Z",
        "updatedAt" : "2017-09-23T16:33:32Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      },
      {
        "id" : "38ad644a-c47e-4582-8fab-0188ab957340",
        "parentId" : "f49e95f7-1825-4f02-814b-8a08e3646346",
        "authorId" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "body" : ">   But is there then a way for a user to do this, apart from this hash checking?\r\n\r\nWhat does \"this\" mean? Checking if two `CategoricalDtypes` are the same?",
        "createdAt" : "2017-09-19T21:21:58Z",
        "updatedAt" : "2017-09-23T16:33:32Z",
        "lastEditedBy" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "tags" : [
        ]
      },
      {
        "id" : "89ae23a4-5536-4a0b-ba70-573657fe17e4",
        "parentId" : "f49e95f7-1825-4f02-814b-8a08e3646346",
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "yes, that is what I meant: checking if two CategoricalDtypes are the same, without falling in the trap of categories=None is equal to anything -> although not sure if that would be common problem",
        "createdAt" : "2017-09-20T19:08:04Z",
        "updatedAt" : "2017-09-23T16:33:32Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      },
      {
        "id" : "7411e043-ba42-4a19-868e-fc722c271075",
        "parentId" : "f49e95f7-1825-4f02-814b-8a08e3646346",
        "authorId" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "body" : "Yeah, in that case they would have to use the same \"trick\" of checking that the hashes are equal.\r\n\r\nI expect comparing two instances `CategoricalDtype` to be relatively rare / for advanced users. In almost all of these cases, I expect users to be doing `a.dtype == b.dtype`, where `a` and `b` are `Categorical`, in which case they *won't* hit this gotcha, since a `Categorical().dtype` will never have unknown categories. It's just \"free-standing\" `CategoricalDtype`, not attached to a `Categorical`, that can have unknown categories.",
        "createdAt" : "2017-09-20T19:16:20Z",
        "updatedAt" : "2017-09-23T16:33:32Z",
        "lastEditedBy" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "tags" : [
        ]
      },
      {
        "id" : "a00f0d54-4a10-444b-b1a2-e52745e5fc2e",
        "parentId" : "f49e95f7-1825-4f02-814b-8a08e3646346",
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "Indeed. And as an advanced user you can always make sure to avoid having dtype objects without categories",
        "createdAt" : "2017-09-20T19:20:00Z",
        "updatedAt" : "2017-09-23T16:33:32Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      }
    ],
    "commit" : "43f90cc13786b57b89709cdb7dd8d2c023adaee6",
    "line" : 594,
    "diffHunk" : "@@ -1,1 +2020,2024 @@\n        try:\n            return hash(self.dtype) == hash(other.dtype)\n        except (AttributeError, TypeError):\n            return False"
  },
  {
    "id" : "081cee23-0f61-41a4-9278-1b85432a65f0",
    "prId" : 16015,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/16015#pullrequestreview-63228393",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "326c0beb-add3-48c1-a846-187b91a83a87",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "versionadded",
        "createdAt" : "2017-09-17T14:31:53Z",
        "updatedAt" : "2017-09-23T16:33:31Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "43f90cc13786b57b89709cdb7dd8d2c023adaee6",
    "line" : 58,
    "diffHunk" : "@@ -1,1 +180,184 @@    ordered : boolean\n        Whether or not this Categorical is ordered.\n    dtype : CategoricalDtype\n        The instance of ``CategoricalDtype`` storing the ``categories``\n        and ``ordered``."
  },
  {
    "id" : "2f6352c4-c611-4ba1-89c8-07e23d311383",
    "prId" : 16015,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/16015#pullrequestreview-63228393",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d0aa71e1-3d2f-46ef-9bec-964b507f1dd1",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "lets deprecate ``fastpath`` (and convert fastpath -> dtype construction, and instead allow ``dtype`` to be passed ",
        "createdAt" : "2017-09-17T14:36:17Z",
        "updatedAt" : "2017-09-23T16:33:31Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "43f90cc13786b57b89709cdb7dd8d2c023adaee6",
    "line" : 379,
    "diffHunk" : "@@ -1,1 +622,626 @@        \"\"\"\n\n        if fastpath:\n            new_dtype = CategoricalDtype._from_fastpath(categories,\n                                                        self.ordered)"
  },
  {
    "id" : "4def9fe2-3556-4724-b547-586833d114b0",
    "prId" : 16339,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/16339#pullrequestreview-38549958",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f100e657-7895-40b0-a5f3-232f666e021b",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "I think you are including the origninal message here, but it its a little awkward",
        "createdAt" : "2017-05-15T23:55:53Z",
        "updatedAt" : "2017-05-18T11:27:46Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "280aa171-7908-48a8-88bb-40a2011381a2",
        "parentId" : "f100e657-7895-40b0-a5f3-232f666e021b",
        "authorId" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "body" : "What did you have in mind? I like how it's currently \"Categoricals can only be compared if 'categories' are the same. Categories are different lengths.\" Since it's the general problem (different categories) and a specific hint \r\nas to what's wrong (different lengths)",
        "createdAt" : "2017-05-16T23:23:24Z",
        "updatedAt" : "2017-05-18T11:27:46Z",
        "lastEditedBy" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "tags" : [
        ]
      },
      {
        "id" : "f9347c12-fcb7-4f25-98c1-247aee7bd3f2",
        "parentId" : "f100e657-7895-40b0-a5f3-232f666e021b",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "actually this is fine.",
        "createdAt" : "2017-05-17T01:05:30Z",
        "updatedAt" : "2017-05-18T11:27:46Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "4ec26d44c75482c4740d679cd6078503e86d53c7",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +61,65 @@                   \"'categories' are the same.\")\n            if len(self.categories) != len(other.categories):\n                raise TypeError(msg + \" Categories are different lengths\")\n            elif (self.ordered and not (self.categories ==\n                                        other.categories).all()):"
  },
  {
    "id" : "c55c801e-815e-4fa0-9932-eccd94682d18",
    "prId" : 17515,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/17515#pullrequestreview-62804049",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0011a513-1176-4fae-ab58-1ae8afcb4da4",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "isn't this just a special case of ``union_categoricals``?",
        "createdAt" : "2017-09-13T23:24:41Z",
        "updatedAt" : "2017-09-14T10:55:44Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "9b39e79d-f440-4acb-9369-6903c1845c6a",
        "parentId" : "0011a513-1176-4fae-ab58-1ae8afcb4da4",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "these both remap codes; seems like they've should share",
        "createdAt" : "2017-09-14T10:41:47Z",
        "updatedAt" : "2017-09-14T10:55:44Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "6201b256-2ef2-4f03-8e73-d8804be24473",
        "parentId" : "0011a513-1176-4fae-ab58-1ae8afcb4da4",
        "authorId" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "body" : "I see. There was a little bit I could extract from union_categorical. Simplified things a bit too by using take_1d. See my latest commit.",
        "createdAt" : "2017-09-14T10:56:18Z",
        "updatedAt" : "2017-09-14T10:56:18Z",
        "lastEditedBy" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "tags" : [
        ]
      },
      {
        "id" : "60acaaed-4706-48d4-9b8a-ee77a4e8ce5a",
        "parentId" : "0011a513-1176-4fae-ab58-1ae8afcb4da4",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "looks nice.",
        "createdAt" : "2017-09-14T16:09:18Z",
        "updatedAt" : "2017-09-14T16:09:18Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "d238e3e82ec4cd2869e4f2e0ebb250865362a7ed",
    "line" : 31,
    "diffHunk" : "@@ -1,1 +2130,2134 @@    Examples\n    --------\n    >>> old_cat = pd.Index(['b', 'a', 'c'])\n    >>> new_cat = pd.Index(['a', 'b'])\n    >>> codes = np.array([0, 1, 1, 2])"
  },
  {
    "id" : "8d75c170-64a5-4685-9944-8f4209899e51",
    "prId" : 17517,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/17517#pullrequestreview-62603843",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "951179a8-cad3-42f2-bb73-8968fcfcdaf0",
        "parentId" : null,
        "authorId" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "body" : "Ah, I misread the earlier. `self` is the instance of `CategoricalAccessor`, not the `Series` like I expected. So this approach won't work.",
        "createdAt" : "2017-09-13T19:29:47Z",
        "updatedAt" : "2017-09-18T11:36:19Z",
        "lastEditedBy" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "tags" : [
        ]
      },
      {
        "id" : "bc739fd5-605a-49b3-a261-32b3a917a333",
        "parentId" : "951179a8-cad3-42f2-bb73-8968fcfcdaf0",
        "authorId" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "body" : "I think if you modify https://github.com/pandas-dev/pandas/blob/f11bbf2f505d81900cc83ce387a6a1b1d2a2f866/pandas/core/categorical.py#L2078 to get `data.name`. and then modify `CategoricalAccessor.__init__` to accept a name. `data` may not have a name, so maybe `getattr(data, 'name', None)`. Make sense?",
        "createdAt" : "2017-09-13T19:39:08Z",
        "updatedAt" : "2017-09-18T11:36:19Z",
        "lastEditedBy" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "tags" : [
        ]
      },
      {
        "id" : "7b95715b-3821-472c-b781-7f834353fb93",
        "parentId" : "951179a8-cad3-42f2-bb73-8968fcfcdaf0",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "so the signature should follow like we do in ``pandas.core.indexes.accessors``, e.g. ``(data, index, name=None)``",
        "createdAt" : "2017-09-13T23:17:26Z",
        "updatedAt" : "2017-09-18T11:36:19Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "ce78e6c98b6f5dd18bfaaf111cbd921ebf37cfc3",
    "line" : 17,
    "diffHunk" : "@@ -1,1 +2077,2081 @@        res = method(*args, **kwargs)\n        if res is not None:\n            return Series(res, index=self.index, name=self.name)\n\n    @classmethod"
  },
  {
    "id" : "c94ff946-ce93-4330-965b-d11586c252ce",
    "prId" : 17586,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/17586#pullrequestreview-64284863",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0050b80b-86ff-4f8f-9cb7-45bc84a60b9b",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "actually make sure the doc string is updated here as well (maybe add a versionchanged tag)",
        "createdAt" : "2017-09-21T13:34:24Z",
        "updatedAt" : "2017-09-21T20:52:17Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "886340889219cdf4ff781411e5a40ff10d736365",
    "line" : 44,
    "diffHunk" : "@@ -1,1 +829,833 @@\n        if is_dict_like(new_categories):\n            cat.categories = [new_categories.get(item, item)\n                              for item in cat.categories]\n        else:"
  },
  {
    "id" : "57692f57-1c9d-4606-bc7e-3f574871af45",
    "prId" : 17643,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/17643#pullrequestreview-65859039",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5c73361c-f727-44dc-b342-b2e188169fe2",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "much nicer",
        "createdAt" : "2017-09-28T13:31:54Z",
        "updatedAt" : "2017-10-02T11:45:08Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "9325a9345f3a4495ff81eb692121c194d8d7c040",
    "line" : 63,
    "diffHunk" : "@@ -1,1 +563,567 @@            codes = inferred_codes\n\n        return cls(codes, dtype=dtype, fastpath=True)\n\n    @classmethod"
  }
]
[
  {
    "id" : "e90a46a9-872f-4eea-89b3-7637804d1554",
    "prId" : 4850,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "44273d8a-04cd-4354-ada6-3b48e7b80350",
        "parentId" : null,
        "authorId" : "5362e572-ef9a-4b5d-8aa4-ca6f8ee7f944",
        "body" : "Why does this take a dtype argument?\n",
        "createdAt" : "2013-09-19T20:36:25Z",
        "updatedAt" : "2013-09-25T16:21:17Z",
        "lastEditedBy" : "5362e572-ef9a-4b5d-8aa4-ca6f8ee7f944",
        "tags" : [
        ]
      },
      {
        "id" : "a17192ac-e594-4fc1-817b-9b2e772a4faf",
        "parentId" : "44273d8a-04cd-4354-ada6-3b48e7b80350",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "all of the **new** take the dtype argument (as well as the same argument set), could be kwargs, but its consistent with other. Its not used, nor do we care about it. This matters because sometimes internally you don't  know what class you are constructing, but want to be explicit (and so ppass in args)\n",
        "createdAt" : "2013-09-19T20:46:37Z",
        "updatedAt" : "2013-09-25T16:21:17Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "60efe85bc2ce9578e8f5e0c88907c5cc6b6b7b31",
    "line" : 298,
    "diffHunk" : "@@ -1,1 +1755,1759 @@    #_engine_type = _index.Float64Engine\n\n    def __new__(cls, data, dtype=None, copy=False, name=None, fastpath=False):\n\n        if fastpath:"
  },
  {
    "id" : "69617981-bb27-4cd0-baad-e810ce21baa9",
    "prId" : 7891,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "156b4cd3-ab5c-4069-b482-952bb49e8e08",
        "parentId" : null,
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "docstring (maybe append from Index.repeat?)\n",
        "createdAt" : "2014-08-06T08:40:05Z",
        "updatedAt" : "2014-08-06T18:45:59Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      }
    ],
    "commit" : "8d3cb3f36e2f7b415531e3b910f490c01657ecca",
    "line" : 1039,
    "diffHunk" : "@@ -1,1 +3339,3343 @@\n    def repeat(self, n):\n        return MultiIndex(levels=self.levels,\n                          labels=[label.view(np.ndarray).repeat(n) for label in self.labels],\n                          names=self.names,"
  },
  {
    "id" : "5f985b86-8d7d-40f3-8310-41d634a8a701",
    "prId" : 7891,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4caadd22-57d1-4d7d-ac86-0ea12a292992",
        "parentId" : null,
        "authorId" : "413be534-cedb-4df7-abda-cde26db33acd",
        "body" : "I wonder if `_add_numeric_methods_disabled` and `_add_numeric_methods` could be put into `pandas.core.ops` module to reuse/be reused from such methods implemented for other containers.\n",
        "createdAt" : "2014-08-06T09:32:46Z",
        "updatedAt" : "2014-08-06T18:45:59Z",
        "lastEditedBy" : "413be534-cedb-4df7-abda-cde26db33acd",
        "tags" : [
        ]
      },
      {
        "id" : "36c25dbb-f2cf-4ea7-b2a2-d9d535e78314",
        "parentId" : "4caadd22-57d1-4d7d-ac86-0ea12a292992",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "I started doing this, but the `ops.py` was a bit too specific. It could/should be fixed I think. but would require some dedicated effort. Feel free!\n",
        "createdAt" : "2014-08-06T12:10:59Z",
        "updatedAt" : "2014-08-06T18:45:59Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "8d3cb3f36e2f7b415531e3b910f490c01657ecca",
    "line" : 580,
    "diffHunk" : "@@ -1,1 +2012,2016 @@\n    @classmethod\n    def _add_numeric_methods_disabled(cls):\n        \"\"\" add in numeric methods to disable \"\"\"\n"
  },
  {
    "id" : "70a061dc-bee8-43a5-a066-6ff6fbbcfe78",
    "prId" : 7891,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "95c359c5-a308-4caf-9624-9dc9f55294e0",
        "parentId" : null,
        "authorId" : "413be534-cedb-4df7-abda-cde26db33acd",
        "body" : "Will sortorder survive `repeat`-ing?\n",
        "createdAt" : "2014-08-06T09:51:12Z",
        "updatedAt" : "2014-08-06T18:45:59Z",
        "lastEditedBy" : "413be534-cedb-4df7-abda-cde26db33acd",
        "tags" : [
        ]
      },
      {
        "id" : "2dd78ce3-f3a2-48ab-a825-48f39d08ea9b",
        "parentId" : "95c359c5-a308-4caf-9624-9dc9f55294e0",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "`sortorder` is a bug in itself. not sure how/when its used at all. So I have no idea. will add to the todo to figure out. (or if you want to take a stab go ahead!)\n",
        "createdAt" : "2014-08-06T12:17:45Z",
        "updatedAt" : "2014-08-06T18:45:59Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "8d3cb3f36e2f7b415531e3b910f490c01657ecca",
    "line" : 1042,
    "diffHunk" : "@@ -1,1 +3342,3346 @@                          labels=[label.view(np.ndarray).repeat(n) for label in self.labels],\n                          names=self.names,\n                          sortorder=self.sortorder,\n                          verify_integrity=False)\n"
  },
  {
    "id" : "639287b6-5621-4a5a-9c4e-d4b1a4e3bb7f",
    "prId" : 7892,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "20a94e19-dff6-449e-9884-d52eb736048b",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "his already exists as _get_level_number (oh I see you are extending it), ok then\n",
        "createdAt" : "2014-07-31T20:14:10Z",
        "updatedAt" : "2014-08-04T08:18:22Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "770859012996b91e182fd22013c4d12b7268adfd",
    "line" : 15,
    "diffHunk" : "@@ -1,1 +690,694 @@    def _validate_index_level(self, level):\n        \"\"\"\n        Validate index level.\n\n        For single-level Index getting level number is a no-op, but some"
  },
  {
    "id" : "33c533c0-9890-4f38-8488-53fe74f3358e",
    "prId" : 8512,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "dd9a2278-3da3-4272-9ce1-4e152635c0be",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "perfect\n",
        "createdAt" : "2014-10-10T00:04:42Z",
        "updatedAt" : "2014-10-10T00:04:42Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "8a662c6ea4700420c4af0d6b3992f57d172ee9e4",
    "line" : 25,
    "diffHunk" : "@@ -1,1 +4178,4182 @@            return array_equivalent(self.values,\n                                    _values_from_object(_ensure_index(other)))\n\n        if self.nlevels != other.nlevels:\n            return False"
  },
  {
    "id" : "eabea82c-c94e-4a48-9227-1bf2cf27e10e",
    "prId" : 8526,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ca4930d1-5294-4f6c-a75e-078010c82f7c",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "I seem to recall something almost excatly like this maybe in core/indexing?\n",
        "createdAt" : "2014-10-25T00:21:12Z",
        "updatedAt" : "2014-11-21T01:06:17Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "d0861e8e7f6b2630f8dc441700d7ff7827ff8725",
    "line" : 41,
    "diffHunk" : "@@ -1,1 +4041,4045 @@        loc : int, slice object or boolean mask\n        \"\"\"\n        def _maybe_to_slice(loc):\n            '''convert integer indexer to boolean mask or slice if possible'''\n            if not isinstance(loc, np.ndarray) or loc.dtype != 'int64':"
  },
  {
    "id" : "00f63e38-82f9-4f67-9d74-09913565471f",
    "prId" : 8550,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "daee26b5-fb9b-4477-9096-63d4e4c3a550",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "much better!\n",
        "createdAt" : "2014-10-20T22:16:54Z",
        "updatedAt" : "2014-11-10T16:46:58Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "14a9ec87-9bb3-42d9-9f6d-5e5a6b14144b",
        "parentId" : "daee26b5-fb9b-4477-9096-63d4e4c3a550",
        "authorId" : "a365f24b-52e0-4fdf-915f-0b9118bb4bb6",
        "body" : "Thanks!\n",
        "createdAt" : "2014-10-20T22:42:38Z",
        "updatedAt" : "2014-11-10T16:46:58Z",
        "lastEditedBy" : "a365f24b-52e0-4fdf-915f-0b9118bb4bb6",
        "tags" : [
        ]
      }
    ],
    "commit" : "518a62c4afc020c4b64e6a053cfe5efea5ce9cfc",
    "line" : 67,
    "diffHunk" : "@@ -1,1 +2215,2219 @@        cls.all = _make_logical_function(\n            'all', 'Return whether all elements are True', np.all)\n        cls.any = _make_logical_function(\n            'any', 'Return whether any element is True', np.any)\n"
  },
  {
    "id" : "960bf7f7-ecd6-4da1-8204-03c03249008f",
    "prId" : 8676,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e6b20a32-dc08-42fc-b4d4-067ce1de232c",
        "parentId" : null,
        "authorId" : "40104112-cdcf-4812-8f95-b502b40e346d",
        "body" : "note: nested `(` is also unnecessary here, but harmless :).\n",
        "createdAt" : "2014-10-30T00:06:12Z",
        "updatedAt" : "2014-10-30T00:06:12Z",
        "lastEditedBy" : "40104112-cdcf-4812-8f95-b502b40e346d",
        "tags" : [
        ]
      },
      {
        "id" : "907fc42f-3ed9-40a0-92b8-0439b96595b3",
        "parentId" : "e6b20a32-dc08-42fc-b4d4-067ce1de232c",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "this IS necessary, each level is an array.\n",
        "createdAt" : "2014-10-30T00:08:40Z",
        "updatedAt" : "2014-10-30T00:08:40Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "81ab6626-7330-4c23-b230-ca4c321c6bc5",
        "parentId" : "e6b20a32-dc08-42fc-b4d4-067ce1de232c",
        "authorId" : "40104112-cdcf-4812-8f95-b502b40e346d",
        "body" : "Test it out: `sum(x for x in [1, 2, 3])`\n\n`sum(i.nbytes for i in self.levels)` implicitly does the generator compression: http://legacy.python.org/dev/peps/pep-0289/\n\nIf you have a single argument to a function the parentheses around generator comprehensions are optional.\n",
        "createdAt" : "2014-10-30T00:12:11Z",
        "updatedAt" : "2014-10-30T00:12:18Z",
        "lastEditedBy" : "40104112-cdcf-4812-8f95-b502b40e346d",
        "tags" : [
        ]
      },
      {
        "id" : "32c3f23f-e388-4b9b-b076-8517dcef558c",
        "parentId" : "e6b20a32-dc08-42fc-b4d4-067ce1de232c",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "That would be true, but each element is a level, which is an ndarray iteself\n\n```\nIn [1]: i = pd.MultiIndex.from_product([list('ab'),range(3)])\n\nIn [2]: i.levels\nOut[2]: FrozenList([[u'a', u'b'], [0, 1, 2]])\n\nIn [4]: sum([ x.nbytes for x in i.levels ])    \nOut[4]: 40\n\nIn [7]: i.levels[0]\nOut[7]: Index([u'a', u'b'], dtype='object')\n```\n",
        "createdAt" : "2014-10-30T00:15:11Z",
        "updatedAt" : "2014-10-30T00:15:11Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "072c6150-5420-486e-a4a6-a8baae0e20e5",
        "parentId" : "e6b20a32-dc08-42fc-b4d4-067ce1de232c",
        "authorId" : "40104112-cdcf-4812-8f95-b502b40e346d",
        "body" : "not sure I understand your point from this example? I get the same thing without the nested brackets:\n\n```\nIn [6]: sum(x.nbytes for x in i.levels)\nOut[6]: 40\n```\n\nThis is really a matter of Python syntax, which is independent of the nature of the arguments\n",
        "createdAt" : "2014-10-30T00:18:37Z",
        "updatedAt" : "2014-10-30T00:18:37Z",
        "lastEditedBy" : "40104112-cdcf-4812-8f95-b502b40e346d",
        "tags" : [
        ]
      },
      {
        "id" : "1f457f69-8eb3-4059-8b25-94f1eab618f9",
        "parentId" : "e6b20a32-dc08-42fc-b4d4-067ce1de232c",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "I see, yeh...I always have used the `[ ]`, doesn't make a difference in this case\n",
        "createdAt" : "2014-10-30T01:46:30Z",
        "updatedAt" : "2014-10-30T01:46:30Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "c11e75c8178fa21288140c83a3aac30caa0fa304",
    "line" : 42,
    "diffHunk" : "@@ -1,1 +2829,2833 @@    def nbytes(self):\n        \"\"\" return the number of bytes in the underlying data \"\"\"\n        level_nbytes = sum(( i.nbytes for i in self.levels ))\n        label_nbytes = sum(( i.nbytes for i in self.labels ))\n        names_nbytes = sum(( getsizeof(i) for i in self.names ))"
  },
  {
    "id" : "1e6360a7-3c49-43a5-aa2a-f5d90e82e847",
    "prId" : 8753,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e642e8f3-fa5a-450a-b193-d620ec4f5d1e",
        "parentId" : null,
        "authorId" : "40104112-cdcf-4812-8f95-b502b40e346d",
        "body" : "This is a nice addition.\n",
        "createdAt" : "2014-11-08T07:48:48Z",
        "updatedAt" : "2014-11-19T11:08:51Z",
        "lastEditedBy" : "40104112-cdcf-4812-8f95-b502b40e346d",
        "tags" : [
        ]
      },
      {
        "id" : "4f6dbfcb-4869-401b-b235-da509cb7edff",
        "parentId" : "e642e8f3-fa5a-450a-b193-d620ec4f5d1e",
        "authorId" : "40104112-cdcf-4812-8f95-b502b40e346d",
        "body" : "Looks like it needs tests?\n",
        "createdAt" : "2014-11-08T08:06:08Z",
        "updatedAt" : "2014-11-19T11:08:51Z",
        "lastEditedBy" : "40104112-cdcf-4812-8f95-b502b40e346d",
        "tags" : [
        ]
      }
    ],
    "commit" : "b735ffc75e4cea35b14866ada4c58a42551fb9dc",
    "line" : 82,
    "diffHunk" : "@@ -1,1 +2028,2032 @@\n        if isinstance(slc, np.ndarray):\n            # get_loc may return a boolean array or an array of indices, which\n            # is OK as long as they are representable by a slice.\n            if com.is_bool_dtype(slc):"
  },
  {
    "id" : "0c526bfe-7389-4d80-ad76-7e5128bd9200",
    "prId" : 8753,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4bbead37-2f3b-4736-ac6c-00963794e582",
        "parentId" : null,
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "Is this not what we are discussing in #8613? (so it seems this is explicitly and intentionally implemented?)\n",
        "createdAt" : "2014-11-10T23:47:24Z",
        "updatedAt" : "2014-11-19T11:08:51Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      },
      {
        "id" : "dd8a2c53-06d9-41ee-a0dd-a33e1d31b018",
        "parentId" : "4bbead37-2f3b-4736-ac6c-00963794e582",
        "authorId" : "40104112-cdcf-4812-8f95-b502b40e346d",
        "body" : "The blocking out of bounds indexing is actually done in `pandas.core.indexing._LocIndexer`. So the functionality here is unchanged (though I agree the checks do make more sense here than in the indexing module)\n",
        "createdAt" : "2014-11-10T23:50:32Z",
        "updatedAt" : "2014-11-19T11:08:51Z",
        "lastEditedBy" : "40104112-cdcf-4812-8f95-b502b40e346d",
        "tags" : [
        ]
      },
      {
        "id" : "9530968c-e60b-4d46-b397-91116a73e091",
        "parentId" : "4bbead37-2f3b-4736-ac6c-00963794e582",
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "Yes, I see, and the `IXIndexer` does not implement those checks, so `ix` can hit this codepath.\n",
        "createdAt" : "2014-11-11T00:11:24Z",
        "updatedAt" : "2014-11-19T11:08:51Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      },
      {
        "id" : "40aa1412-1eb9-48ae-970e-8a511e706916",
        "parentId" : "4bbead37-2f3b-4736-ac6c-00963794e582",
        "authorId" : "413be534-cedb-4df7-abda-cde26db33acd",
        "body" : "Moving the checks here should be trivial with adding the third `side=='exact'` or `side='strict'` that disables this branch of execution (and probably renaming the function and parameter to make more sense with that third value).\n",
        "createdAt" : "2014-11-11T05:44:53Z",
        "updatedAt" : "2014-11-19T11:08:51Z",
        "lastEditedBy" : "413be534-cedb-4df7-abda-cde26db33acd",
        "tags" : [
        ]
      },
      {
        "id" : "227a9832-6794-41b1-8c86-8c118dc60e46",
        "parentId" : "4bbead37-2f3b-4736-ac6c-00963794e582",
        "authorId" : "413be534-cedb-4df7-abda-cde26db33acd",
        "body" : "But I was really hoping that we'll come to dropping those checks altogether.\n",
        "createdAt" : "2014-11-11T05:45:24Z",
        "updatedAt" : "2014-11-19T11:08:51Z",
        "lastEditedBy" : "413be534-cedb-4df7-abda-cde26db33acd",
        "tags" : [
        ]
      },
      {
        "id" : "028eeeac-6835-40e3-a424-b75f03939197",
        "parentId" : "4bbead37-2f3b-4736-ac6c-00963794e582",
        "authorId" : "40104112-cdcf-4812-8f95-b502b40e346d",
        "body" : "@immerrr agreed, but I do think we'll want at least a type check (not in this PR), e.g., to ensure `pd.Index([1, 2, 3]).slice_indexer('a')` raises on Python 2.\n",
        "createdAt" : "2014-11-11T05:58:06Z",
        "updatedAt" : "2014-11-19T11:08:51Z",
        "lastEditedBy" : "40104112-cdcf-4812-8f95-b502b40e346d",
        "tags" : [
        ]
      },
      {
        "id" : "6f5df37f-919a-4d54-86ee-d15969ec12bb",
        "parentId" : "4bbead37-2f3b-4736-ac6c-00963794e582",
        "authorId" : "413be534-cedb-4df7-abda-cde26db33acd",
        "body" : "This one is easy: you just need to add something that throws on invalid type into `_maybe_cast_slice_bound`.  The inverse is tricky (e.g. `pd.Index(list('abc')).slice_indexer(1)`), but should be doable once `StringIndex` lands (either by adding another index type or by adding a string-object numpy dtype).\n",
        "createdAt" : "2014-11-11T06:09:35Z",
        "updatedAt" : "2014-11-19T11:08:51Z",
        "lastEditedBy" : "413be534-cedb-4df7-abda-cde26db33acd",
        "tags" : [
        ]
      }
    ],
    "commit" : "b735ffc75e4cea35b14866ada4c58a42551fb9dc",
    "line" : 69,
    "diffHunk" : "@@ -1,1 +2015,2019 @@        except KeyError:\n            if self.is_monotonic_increasing:\n                return self.searchsorted(label, side=side)\n            elif self.is_monotonic_decreasing:\n                # np.searchsorted expects ascending sort order, have to reverse"
  }
]
[
  {
    "id" : "e90a46a9-872f-4eea-89b3-7637804d1554",
    "prId" : 4850,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "44273d8a-04cd-4354-ada6-3b48e7b80350",
        "parentId" : null,
        "authorId" : "5362e572-ef9a-4b5d-8aa4-ca6f8ee7f944",
        "body" : "Why does this take a dtype argument?\n",
        "createdAt" : "2013-09-19T20:36:25Z",
        "updatedAt" : "2013-09-25T16:21:17Z",
        "lastEditedBy" : "5362e572-ef9a-4b5d-8aa4-ca6f8ee7f944",
        "tags" : [
        ]
      },
      {
        "id" : "a17192ac-e594-4fc1-817b-9b2e772a4faf",
        "parentId" : "44273d8a-04cd-4354-ada6-3b48e7b80350",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "all of the **new** take the dtype argument (as well as the same argument set), could be kwargs, but its consistent with other. Its not used, nor do we care about it. This matters because sometimes internally you don't  know what class you are constructing, but want to be explicit (and so ppass in args)\n",
        "createdAt" : "2013-09-19T20:46:37Z",
        "updatedAt" : "2013-09-25T16:21:17Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "60efe85bc2ce9578e8f5e0c88907c5cc6b6b7b31",
    "line" : 298,
    "diffHunk" : "@@ -1,1 +1755,1759 @@    #_engine_type = _index.Float64Engine\n\n    def __new__(cls, data, dtype=None, copy=False, name=None, fastpath=False):\n\n        if fastpath:"
  },
  {
    "id" : "69617981-bb27-4cd0-baad-e810ce21baa9",
    "prId" : 7891,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "156b4cd3-ab5c-4069-b482-952bb49e8e08",
        "parentId" : null,
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "docstring (maybe append from Index.repeat?)\n",
        "createdAt" : "2014-08-06T08:40:05Z",
        "updatedAt" : "2014-08-06T18:45:59Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      }
    ],
    "commit" : "8d3cb3f36e2f7b415531e3b910f490c01657ecca",
    "line" : 1039,
    "diffHunk" : "@@ -1,1 +3339,3343 @@\n    def repeat(self, n):\n        return MultiIndex(levels=self.levels,\n                          labels=[label.view(np.ndarray).repeat(n) for label in self.labels],\n                          names=self.names,"
  },
  {
    "id" : "5f985b86-8d7d-40f3-8310-41d634a8a701",
    "prId" : 7891,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4caadd22-57d1-4d7d-ac86-0ea12a292992",
        "parentId" : null,
        "authorId" : "413be534-cedb-4df7-abda-cde26db33acd",
        "body" : "I wonder if `_add_numeric_methods_disabled` and `_add_numeric_methods` could be put into `pandas.core.ops` module to reuse/be reused from such methods implemented for other containers.\n",
        "createdAt" : "2014-08-06T09:32:46Z",
        "updatedAt" : "2014-08-06T18:45:59Z",
        "lastEditedBy" : "413be534-cedb-4df7-abda-cde26db33acd",
        "tags" : [
        ]
      },
      {
        "id" : "36c25dbb-f2cf-4ea7-b2a2-d9d535e78314",
        "parentId" : "4caadd22-57d1-4d7d-ac86-0ea12a292992",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "I started doing this, but the `ops.py` was a bit too specific. It could/should be fixed I think. but would require some dedicated effort. Feel free!\n",
        "createdAt" : "2014-08-06T12:10:59Z",
        "updatedAt" : "2014-08-06T18:45:59Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "8d3cb3f36e2f7b415531e3b910f490c01657ecca",
    "line" : 580,
    "diffHunk" : "@@ -1,1 +2012,2016 @@\n    @classmethod\n    def _add_numeric_methods_disabled(cls):\n        \"\"\" add in numeric methods to disable \"\"\"\n"
  },
  {
    "id" : "70a061dc-bee8-43a5-a066-6ff6fbbcfe78",
    "prId" : 7891,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "95c359c5-a308-4caf-9624-9dc9f55294e0",
        "parentId" : null,
        "authorId" : "413be534-cedb-4df7-abda-cde26db33acd",
        "body" : "Will sortorder survive `repeat`-ing?\n",
        "createdAt" : "2014-08-06T09:51:12Z",
        "updatedAt" : "2014-08-06T18:45:59Z",
        "lastEditedBy" : "413be534-cedb-4df7-abda-cde26db33acd",
        "tags" : [
        ]
      },
      {
        "id" : "2dd78ce3-f3a2-48ab-a825-48f39d08ea9b",
        "parentId" : "95c359c5-a308-4caf-9624-9dc9f55294e0",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "`sortorder` is a bug in itself. not sure how/when its used at all. So I have no idea. will add to the todo to figure out. (or if you want to take a stab go ahead!)\n",
        "createdAt" : "2014-08-06T12:17:45Z",
        "updatedAt" : "2014-08-06T18:45:59Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "8d3cb3f36e2f7b415531e3b910f490c01657ecca",
    "line" : 1042,
    "diffHunk" : "@@ -1,1 +3342,3346 @@                          labels=[label.view(np.ndarray).repeat(n) for label in self.labels],\n                          names=self.names,\n                          sortorder=self.sortorder,\n                          verify_integrity=False)\n"
  },
  {
    "id" : "639287b6-5621-4a5a-9c4e-d4b1a4e3bb7f",
    "prId" : 7892,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "20a94e19-dff6-449e-9884-d52eb736048b",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "his already exists as _get_level_number (oh I see you are extending it), ok then\n",
        "createdAt" : "2014-07-31T20:14:10Z",
        "updatedAt" : "2014-08-04T08:18:22Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "770859012996b91e182fd22013c4d12b7268adfd",
    "line" : 15,
    "diffHunk" : "@@ -1,1 +690,694 @@    def _validate_index_level(self, level):\n        \"\"\"\n        Validate index level.\n\n        For single-level Index getting level number is a no-op, but some"
  },
  {
    "id" : "33c533c0-9890-4f38-8488-53fe74f3358e",
    "prId" : 8512,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "dd9a2278-3da3-4272-9ce1-4e152635c0be",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "perfect\n",
        "createdAt" : "2014-10-10T00:04:42Z",
        "updatedAt" : "2014-10-10T00:04:42Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "8a662c6ea4700420c4af0d6b3992f57d172ee9e4",
    "line" : 25,
    "diffHunk" : "@@ -1,1 +4178,4182 @@            return array_equivalent(self.values,\n                                    _values_from_object(_ensure_index(other)))\n\n        if self.nlevels != other.nlevels:\n            return False"
  },
  {
    "id" : "eabea82c-c94e-4a48-9227-1bf2cf27e10e",
    "prId" : 8526,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ca4930d1-5294-4f6c-a75e-078010c82f7c",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "I seem to recall something almost excatly like this maybe in core/indexing?\n",
        "createdAt" : "2014-10-25T00:21:12Z",
        "updatedAt" : "2014-11-21T01:06:17Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "d0861e8e7f6b2630f8dc441700d7ff7827ff8725",
    "line" : 41,
    "diffHunk" : "@@ -1,1 +4041,4045 @@        loc : int, slice object or boolean mask\n        \"\"\"\n        def _maybe_to_slice(loc):\n            '''convert integer indexer to boolean mask or slice if possible'''\n            if not isinstance(loc, np.ndarray) or loc.dtype != 'int64':"
  },
  {
    "id" : "00f63e38-82f9-4f67-9d74-09913565471f",
    "prId" : 8550,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "daee26b5-fb9b-4477-9096-63d4e4c3a550",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "much better!\n",
        "createdAt" : "2014-10-20T22:16:54Z",
        "updatedAt" : "2014-11-10T16:46:58Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "14a9ec87-9bb3-42d9-9f6d-5e5a6b14144b",
        "parentId" : "daee26b5-fb9b-4477-9096-63d4e4c3a550",
        "authorId" : "a365f24b-52e0-4fdf-915f-0b9118bb4bb6",
        "body" : "Thanks!\n",
        "createdAt" : "2014-10-20T22:42:38Z",
        "updatedAt" : "2014-11-10T16:46:58Z",
        "lastEditedBy" : "a365f24b-52e0-4fdf-915f-0b9118bb4bb6",
        "tags" : [
        ]
      }
    ],
    "commit" : "518a62c4afc020c4b64e6a053cfe5efea5ce9cfc",
    "line" : 67,
    "diffHunk" : "@@ -1,1 +2215,2219 @@        cls.all = _make_logical_function(\n            'all', 'Return whether all elements are True', np.all)\n        cls.any = _make_logical_function(\n            'any', 'Return whether any element is True', np.any)\n"
  },
  {
    "id" : "960bf7f7-ecd6-4da1-8204-03c03249008f",
    "prId" : 8676,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e6b20a32-dc08-42fc-b4d4-067ce1de232c",
        "parentId" : null,
        "authorId" : "40104112-cdcf-4812-8f95-b502b40e346d",
        "body" : "note: nested `(` is also unnecessary here, but harmless :).\n",
        "createdAt" : "2014-10-30T00:06:12Z",
        "updatedAt" : "2014-10-30T00:06:12Z",
        "lastEditedBy" : "40104112-cdcf-4812-8f95-b502b40e346d",
        "tags" : [
        ]
      },
      {
        "id" : "907fc42f-3ed9-40a0-92b8-0439b96595b3",
        "parentId" : "e6b20a32-dc08-42fc-b4d4-067ce1de232c",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "this IS necessary, each level is an array.\n",
        "createdAt" : "2014-10-30T00:08:40Z",
        "updatedAt" : "2014-10-30T00:08:40Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "81ab6626-7330-4c23-b230-ca4c321c6bc5",
        "parentId" : "e6b20a32-dc08-42fc-b4d4-067ce1de232c",
        "authorId" : "40104112-cdcf-4812-8f95-b502b40e346d",
        "body" : "Test it out: `sum(x for x in [1, 2, 3])`\n\n`sum(i.nbytes for i in self.levels)` implicitly does the generator compression: http://legacy.python.org/dev/peps/pep-0289/\n\nIf you have a single argument to a function the parentheses around generator comprehensions are optional.\n",
        "createdAt" : "2014-10-30T00:12:11Z",
        "updatedAt" : "2014-10-30T00:12:18Z",
        "lastEditedBy" : "40104112-cdcf-4812-8f95-b502b40e346d",
        "tags" : [
        ]
      },
      {
        "id" : "32c3f23f-e388-4b9b-b076-8517dcef558c",
        "parentId" : "e6b20a32-dc08-42fc-b4d4-067ce1de232c",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "That would be true, but each element is a level, which is an ndarray iteself\n\n```\nIn [1]: i = pd.MultiIndex.from_product([list('ab'),range(3)])\n\nIn [2]: i.levels\nOut[2]: FrozenList([[u'a', u'b'], [0, 1, 2]])\n\nIn [4]: sum([ x.nbytes for x in i.levels ])    \nOut[4]: 40\n\nIn [7]: i.levels[0]\nOut[7]: Index([u'a', u'b'], dtype='object')\n```\n",
        "createdAt" : "2014-10-30T00:15:11Z",
        "updatedAt" : "2014-10-30T00:15:11Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "072c6150-5420-486e-a4a6-a8baae0e20e5",
        "parentId" : "e6b20a32-dc08-42fc-b4d4-067ce1de232c",
        "authorId" : "40104112-cdcf-4812-8f95-b502b40e346d",
        "body" : "not sure I understand your point from this example? I get the same thing without the nested brackets:\n\n```\nIn [6]: sum(x.nbytes for x in i.levels)\nOut[6]: 40\n```\n\nThis is really a matter of Python syntax, which is independent of the nature of the arguments\n",
        "createdAt" : "2014-10-30T00:18:37Z",
        "updatedAt" : "2014-10-30T00:18:37Z",
        "lastEditedBy" : "40104112-cdcf-4812-8f95-b502b40e346d",
        "tags" : [
        ]
      },
      {
        "id" : "1f457f69-8eb3-4059-8b25-94f1eab618f9",
        "parentId" : "e6b20a32-dc08-42fc-b4d4-067ce1de232c",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "I see, yeh...I always have used the `[ ]`, doesn't make a difference in this case\n",
        "createdAt" : "2014-10-30T01:46:30Z",
        "updatedAt" : "2014-10-30T01:46:30Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "c11e75c8178fa21288140c83a3aac30caa0fa304",
    "line" : 42,
    "diffHunk" : "@@ -1,1 +2829,2833 @@    def nbytes(self):\n        \"\"\" return the number of bytes in the underlying data \"\"\"\n        level_nbytes = sum(( i.nbytes for i in self.levels ))\n        label_nbytes = sum(( i.nbytes for i in self.labels ))\n        names_nbytes = sum(( getsizeof(i) for i in self.names ))"
  },
  {
    "id" : "1e6360a7-3c49-43a5-aa2a-f5d90e82e847",
    "prId" : 8753,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e642e8f3-fa5a-450a-b193-d620ec4f5d1e",
        "parentId" : null,
        "authorId" : "40104112-cdcf-4812-8f95-b502b40e346d",
        "body" : "This is a nice addition.\n",
        "createdAt" : "2014-11-08T07:48:48Z",
        "updatedAt" : "2014-11-19T11:08:51Z",
        "lastEditedBy" : "40104112-cdcf-4812-8f95-b502b40e346d",
        "tags" : [
        ]
      },
      {
        "id" : "4f6dbfcb-4869-401b-b235-da509cb7edff",
        "parentId" : "e642e8f3-fa5a-450a-b193-d620ec4f5d1e",
        "authorId" : "40104112-cdcf-4812-8f95-b502b40e346d",
        "body" : "Looks like it needs tests?\n",
        "createdAt" : "2014-11-08T08:06:08Z",
        "updatedAt" : "2014-11-19T11:08:51Z",
        "lastEditedBy" : "40104112-cdcf-4812-8f95-b502b40e346d",
        "tags" : [
        ]
      }
    ],
    "commit" : "b735ffc75e4cea35b14866ada4c58a42551fb9dc",
    "line" : 82,
    "diffHunk" : "@@ -1,1 +2028,2032 @@\n        if isinstance(slc, np.ndarray):\n            # get_loc may return a boolean array or an array of indices, which\n            # is OK as long as they are representable by a slice.\n            if com.is_bool_dtype(slc):"
  },
  {
    "id" : "0c526bfe-7389-4d80-ad76-7e5128bd9200",
    "prId" : 8753,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4bbead37-2f3b-4736-ac6c-00963794e582",
        "parentId" : null,
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "Is this not what we are discussing in #8613? (so it seems this is explicitly and intentionally implemented?)\n",
        "createdAt" : "2014-11-10T23:47:24Z",
        "updatedAt" : "2014-11-19T11:08:51Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      },
      {
        "id" : "dd8a2c53-06d9-41ee-a0dd-a33e1d31b018",
        "parentId" : "4bbead37-2f3b-4736-ac6c-00963794e582",
        "authorId" : "40104112-cdcf-4812-8f95-b502b40e346d",
        "body" : "The blocking out of bounds indexing is actually done in `pandas.core.indexing._LocIndexer`. So the functionality here is unchanged (though I agree the checks do make more sense here than in the indexing module)\n",
        "createdAt" : "2014-11-10T23:50:32Z",
        "updatedAt" : "2014-11-19T11:08:51Z",
        "lastEditedBy" : "40104112-cdcf-4812-8f95-b502b40e346d",
        "tags" : [
        ]
      },
      {
        "id" : "9530968c-e60b-4d46-b397-91116a73e091",
        "parentId" : "4bbead37-2f3b-4736-ac6c-00963794e582",
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "Yes, I see, and the `IXIndexer` does not implement those checks, so `ix` can hit this codepath.\n",
        "createdAt" : "2014-11-11T00:11:24Z",
        "updatedAt" : "2014-11-19T11:08:51Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      },
      {
        "id" : "40aa1412-1eb9-48ae-970e-8a511e706916",
        "parentId" : "4bbead37-2f3b-4736-ac6c-00963794e582",
        "authorId" : "413be534-cedb-4df7-abda-cde26db33acd",
        "body" : "Moving the checks here should be trivial with adding the third `side=='exact'` or `side='strict'` that disables this branch of execution (and probably renaming the function and parameter to make more sense with that third value).\n",
        "createdAt" : "2014-11-11T05:44:53Z",
        "updatedAt" : "2014-11-19T11:08:51Z",
        "lastEditedBy" : "413be534-cedb-4df7-abda-cde26db33acd",
        "tags" : [
        ]
      },
      {
        "id" : "227a9832-6794-41b1-8c86-8c118dc60e46",
        "parentId" : "4bbead37-2f3b-4736-ac6c-00963794e582",
        "authorId" : "413be534-cedb-4df7-abda-cde26db33acd",
        "body" : "But I was really hoping that we'll come to dropping those checks altogether.\n",
        "createdAt" : "2014-11-11T05:45:24Z",
        "updatedAt" : "2014-11-19T11:08:51Z",
        "lastEditedBy" : "413be534-cedb-4df7-abda-cde26db33acd",
        "tags" : [
        ]
      },
      {
        "id" : "028eeeac-6835-40e3-a424-b75f03939197",
        "parentId" : "4bbead37-2f3b-4736-ac6c-00963794e582",
        "authorId" : "40104112-cdcf-4812-8f95-b502b40e346d",
        "body" : "@immerrr agreed, but I do think we'll want at least a type check (not in this PR), e.g., to ensure `pd.Index([1, 2, 3]).slice_indexer('a')` raises on Python 2.\n",
        "createdAt" : "2014-11-11T05:58:06Z",
        "updatedAt" : "2014-11-19T11:08:51Z",
        "lastEditedBy" : "40104112-cdcf-4812-8f95-b502b40e346d",
        "tags" : [
        ]
      },
      {
        "id" : "6f5df37f-919a-4d54-86ee-d15969ec12bb",
        "parentId" : "4bbead37-2f3b-4736-ac6c-00963794e582",
        "authorId" : "413be534-cedb-4df7-abda-cde26db33acd",
        "body" : "This one is easy: you just need to add something that throws on invalid type into `_maybe_cast_slice_bound`.  The inverse is tricky (e.g. `pd.Index(list('abc')).slice_indexer(1)`), but should be doable once `StringIndex` lands (either by adding another index type or by adding a string-object numpy dtype).\n",
        "createdAt" : "2014-11-11T06:09:35Z",
        "updatedAt" : "2014-11-19T11:08:51Z",
        "lastEditedBy" : "413be534-cedb-4df7-abda-cde26db33acd",
        "tags" : [
        ]
      }
    ],
    "commit" : "b735ffc75e4cea35b14866ada4c58a42551fb9dc",
    "line" : 69,
    "diffHunk" : "@@ -1,1 +2015,2019 @@        except KeyError:\n            if self.is_monotonic_increasing:\n                return self.searchsorted(label, side=side)\n            elif self.is_monotonic_decreasing:\n                # np.searchsorted expects ascending sort order, have to reverse"
  },
  {
    "id" : "3a6344dd-78cb-40db-b7c9-d88cd5307083",
    "prId" : 9258,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "43f4c74c-141a-4db8-b98b-0c1ef29de588",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "I think you have a test for this, right?\n",
        "createdAt" : "2015-02-13T19:57:37Z",
        "updatedAt" : "2015-02-18T03:00:42Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "be7a062f-c7ab-4390-89de-51c7f7746f2b",
        "parentId" : "43f4c74c-141a-4db8-b98b-0c1ef29de588",
        "authorId" : "40104112-cdcf-4812-8f95-b502b40e346d",
        "body" : "Yes, and for `MultiIndex.get_loc`, too\n",
        "createdAt" : "2015-02-13T20:00:05Z",
        "updatedAt" : "2015-02-18T03:00:42Z",
        "lastEditedBy" : "40104112-cdcf-4812-8f95-b502b40e346d",
        "tags" : [
        ]
      }
    ],
    "commit" : "f1164210248e6be262cfbf08bf899f1d1781c0fc",
    "line" : 312,
    "diffHunk" : "@@ -1,1 +4022,4026 @@            indexer = self_index._get_fill_indexer(target, method, limit)\n        elif method == 'nearest':\n            raise NotImplementedError(\"method='nearest' not implemented yet \"\n                                      'for MultiIndex; see GitHub issue 9365')\n        else:"
  },
  {
    "id" : "3b5c23e7-69aa-4fe8-8551-8b0616749b3d",
    "prId" : 9741,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b5d4e3f4-27a6-4251-ab98-7b6669809673",
        "parentId" : null,
        "authorId" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "body" : "Does `CategoricalIndex(['a', 'b'], categories=['a', 'b']) == CategoricalIndex(['a', 'b'], categories=['a', 'b', 'c'])` return True? i.e. the values are the same but the categories (possible values) differ.\n\nI just checked on Categoricals and we raise a `TypeError` if the categories aren't identical.\n\n``` python\nIn [1]: c1 = pd.Categorical(['a', 'b'], categories=['a', 'b'])\n\nIn [2]: c2 = pd.Categorical(['a', 'b'], categories=['a', 'b', 'c'])\n\nIn [5]: c1 == c2\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\n<ipython-input-5-d8d43a43a02a> in <module>()\n----> 1 c1 == c2\n\n/Users/tom.augspurger/Envs/py3/lib/python3.4/site-packages/pandas-0.16.0_19_g8d2818e-py3.4-macosx-10.10-x86_64.egg/pandas/core/categorical.py in f(self, other)\n     38             if (len(self.categories) != len(other.categories)) or \\\n     39                     not ((self.categories == other.categories).all()):\n---> 40                 raise TypeError(\"Categoricals can only be compared if 'categories' are the same\")\n     41             if not (self.ordered == other.ordered):\n     42                 raise TypeError(\"Categoricals can only be compared if 'ordered' is the same\")\n\nTypeError: Categoricals can only be compared if 'categories' are the same\n```\n\nWe should probably raise here too. Ohh, and maybe that's handled in `self._data == other._data`?\n",
        "createdAt" : "2015-03-28T16:42:46Z",
        "updatedAt" : "2015-04-20T11:19:36Z",
        "lastEditedBy" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "tags" : [
        ]
      }
    ],
    "commit" : "ecf8514cf14a12511368abf0e61373775cc65c6d",
    "line" : null,
    "diffHunk" : "@@ -1,1 +2764,2768 @@        return other\n\n    def equals(self, other):\n        \"\"\"\n        Determines if two CategorialIndex objects contain the same elements."
  },
  {
    "id" : "68ec2806-17f8-4f21-a480-bab6d93b4a15",
    "prId" : 9741,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fcf60456-c8b6-4e5c-947c-226615dedc9e",
        "parentId" : null,
        "authorId" : "40104112-cdcf-4812-8f95-b502b40e346d",
        "body" : "are you intentionally using `np.array` (the copying version) instead of `np.asarray` in this method? if not, you probably want to use the later....\n",
        "createdAt" : "2015-04-09T00:47:33Z",
        "updatedAt" : "2015-04-20T11:19:36Z",
        "lastEditedBy" : "40104112-cdcf-4812-8f95-b502b40e346d",
        "tags" : [
        ]
      },
      {
        "id" : "792c5d73-f47b-4868-a0f7-8a02067600d8",
        "parentId" : "fcf60456-c8b6-4e5c-947c-226615dedc9e",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "nah should be asarray\n\nwish array didn't copy by default it's annoying \n",
        "createdAt" : "2015-04-09T00:50:11Z",
        "updatedAt" : "2015-04-20T11:19:36Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "ecf8514cf14a12511368abf0e61373775cc65c6d",
    "line" : null,
    "diffHunk" : "@@ -1,1 +2905,2909 @@            raise ValueError(\"cannot reindex with a non-unique indexer\")\n\n        indexer, missing = self.get_indexer_non_unique(np.array(target))\n        new_target = self.take(indexer)\n"
  },
  {
    "id" : "c32ee55f-eb72-4fce-889e-90ba4d7e2e66",
    "prId" : 10042,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c055f648-624a-4d33-9dbd-12965500e33b",
        "parentId" : null,
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "this is not correct I think, as now a list will show the warning, but not perform a set (union) operation (as a list is not an index)?\n\nShould it not be like:\n\n```\nif com.is_list_like(other):\n    warnings.warn(...)\n    return self.union(other)\n```\n",
        "createdAt" : "2015-05-01T22:53:49Z",
        "updatedAt" : "2015-05-04T12:00:24Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      },
      {
        "id" : "096f51d6-60c0-42e7-be90-ba0ede73efe4",
        "parentId" : "c055f648-624a-4d33-9dbd-12965500e33b",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "fixed\n",
        "createdAt" : "2015-05-04T11:43:06Z",
        "updatedAt" : "2015-05-04T12:00:24Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "a86e8972-e716-4564-9db5-31487651dce3",
        "parentId" : "c055f648-624a-4d33-9dbd-12965500e33b",
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "@jreback I don't really see how this is fixed? It is still\n\n```\nif com.is_list_like(other):\n    warnings.warn(...)\nif isinstance(other, Index):\n    return self.union(other)\n```\n\nSo a list will trigger the warning, but not do the union set operation.\n",
        "createdAt" : "2015-05-04T19:39:10Z",
        "updatedAt" : "2015-05-04T19:39:10Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      }
    ],
    "commit" : "7b6d23d6e7ed05a34ae8a4324d5023a3e5e93b79",
    "line" : 8,
    "diffHunk" : "@@ -1,1 +1183,1187 @@            warnings.warn(\"using '+' to provide set union with Indexes is deprecated, \"\n                          \"use '|' or .union()\",FutureWarning)\n        if isinstance(other, Index):\n            return self.union(other)\n        return Index(np.array(self) + other)"
  },
  {
    "id" : "dfd5414a-e47e-4011-909b-361c242d4129",
    "prId" : 10411,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5d02066a-afd2-47da-8a58-c6c0abbfda39",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "I think you need to call `_convert_tolerance` here (you do this in `tseries/base/get_loc` ) so not sure which is the correct convention\n",
        "createdAt" : "2015-07-23T19:59:43Z",
        "updatedAt" : "2015-08-18T23:04:32Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "0b466857-924d-4faa-8d78-3d4a4f1764ff",
        "parentId" : "5d02066a-afd2-47da-8a58-c6c0abbfda39",
        "authorId" : "40104112-cdcf-4812-8f95-b502b40e346d",
        "body" : "Nope -- this is only called from inside `get_indexer`, which already calls `_convert_tolerance` at the top. The extra call to `_convert_tolerance` in `DatetimeIndex.get_loc` and `TimedeltaIndex.get_loc` is to ensure that an appropriate error gets raised for a bad tolerance argument that cannot be coerced to a timedelta.\n",
        "createdAt" : "2015-08-02T05:33:06Z",
        "updatedAt" : "2015-08-18T23:04:32Z",
        "lastEditedBy" : "40104112-cdcf-4812-8f95-b502b40e346d",
        "tags" : [
        ]
      }
    ],
    "commit" : "0468cadc7f3a225fc04f7ef6b93c1a7bb0cc5c00",
    "line" : 156,
    "diffHunk" : "@@ -1,1 +1845,1849 @@\n    def _filter_indexer_tolerance(self, target, indexer, tolerance):\n        distance = abs(self.values[indexer] - target)\n        indexer = np.where(distance <= tolerance, indexer, -1)\n        return indexer"
  },
  {
    "id" : "aa632949-4a70-4794-bbcc-a3e5fdc4731f",
    "prId" : 11343,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d1b3bd7f-b366-4604-a688-3a9421200a89",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "this is override `core/base.py`, but do we use that anylonger? (I don't think `Series` uses this)\n",
        "createdAt" : "2015-10-25T20:01:00Z",
        "updatedAt" : "2015-11-01T11:50:18Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "f43cf725-df90-4b48-ba11-2cbab7258195",
        "parentId" : "d1b3bd7f-b366-4604-a688-3a9421200a89",
        "authorId" : "2bab095f-50fb-401e-ab9e-c09e00e2b00c",
        "body" : "I haven't notice `base.py`. Should remove it from `base.py` because `Series` can be changed inplace?  \n",
        "createdAt" : "2015-10-31T22:54:33Z",
        "updatedAt" : "2015-11-01T11:50:18Z",
        "lastEditedBy" : "2bab095f-50fb-401e-ab9e-c09e00e2b00c",
        "tags" : [
        ]
      }
    ],
    "commit" : "bcdb3e9bcf402ee729be151fcff1c73558cad192",
    "line" : 59,
    "diffHunk" : "@@ -1,1 +1258,1262 @@\n    @cache_readonly\n    def hasnans(self):\n        \"\"\" return if I have any nans; enables various perf speedups \"\"\"\n        if self._can_hold_na:"
  },
  {
    "id" : "b99d9e96-5167-4647-a9de-6e4a8058dad3",
    "prId" : 11681,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a419f4ce-6a57-46cc-bf7d-b4a25b08e076",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "since this is basically identical to `core/internals/FloatBlock/to_native_types`.  let's pull both those out and put it in a function in `core/format.py/FloatArrayFormatter` and call it `.get_formatted_data()`. See how that works out. These are the routines for screen printing (which are necessarily different from to_csv / index formatting). \n",
        "createdAt" : "2015-11-29T17:55:21Z",
        "updatedAt" : "2015-12-27T08:32:04Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "9302811ef1ef13d55fdc00be5fc0229fd52f20a0",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +3928,3932 @@\n    def _format_native_types(self, na_rep='', float_format=None,\n                             decimal='.', quoting=None, **kwargs):\n        from pandas.core.format import FloatArrayFormatter\n        formatter = FloatArrayFormatter(self.values, na_rep=na_rep,"
  },
  {
    "id" : "ddc9014b-187b-4f9f-827b-a32452429494",
    "prId" : 11892,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "cf218cca-f13d-4b23-ad02-5440da3786dc",
        "parentId" : null,
        "authorId" : "40104112-cdcf-4812-8f95-b502b40e346d",
        "body" : "let's allow `from_range` to also handle `RangeIndex` objects (in contrast to the `RangeIndex` constructor, which should not....)\n",
        "createdAt" : "2016-01-08T22:12:38Z",
        "updatedAt" : "2016-01-16T15:42:38Z",
        "lastEditedBy" : "40104112-cdcf-4812-8f95-b502b40e346d",
        "tags" : [
        ]
      },
      {
        "id" : "810980fa-ca23-472f-a200-ecf29eebaed1",
        "parentId" : "cf218cca-f13d-4b23-ad02-5440da3786dc",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "why? idempotency is preservered on all other index types.\n\n```\nIn [2]: pd.Int64Index(pd.Int64Index(np.arange(0,5)))\nOut[2]: Int64Index([0, 1, 2, 3, 4], dtype='int64')\n```\n",
        "createdAt" : "2016-01-08T22:33:02Z",
        "updatedAt" : "2016-01-16T15:42:38Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "fab291b306ebf8b89d094379c99bd1b2a2b601b9",
    "line" : 457,
    "diffHunk" : "@@ -1,1 +3985,3989 @@    @classmethod\n    def from_range(cls, data, name=None, dtype=None, **kwargs):\n        \"\"\" create RangeIndex from a range (py3), or xrange (py2) object \"\"\"\n        if not isinstance(data, range):\n            raise TypeError("
  },
  {
    "id" : "7c36bcc9-f9c1-49f8-b896-5ab7ec52a703",
    "prId" : 26097,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/26097#pullrequestreview-248969365",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "881fb4fa-f155-491b-8bab-e18e8c93a8c5",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "is there a reason . you changed this here?",
        "createdAt" : "2019-06-12T18:30:57Z",
        "updatedAt" : "2019-07-03T11:44:36Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "060a88e1-b99e-40ce-8917-f0a906e246da",
        "parentId" : "881fb4fa-f155-491b-8bab-e18e8c93a8c5",
        "authorId" : "ac925cd1-7327-4d2a-a9fc-55fc5f720f67",
        "body" : "If this line will remain the same, the following errors will occur:\r\n```\r\nmypy.exe pandas\\core\\tools\\datetimes.py\r\npandas\\core\\tools\\datetimes.py:101: error: Module 'pandas' has no attribute 'DatetimeIndex'\r\npandas\\core\\tools\\datetimes.py:101: error: Module 'pandas' has no attribute 'Index'\r\n```",
        "createdAt" : "2019-06-12T19:24:17Z",
        "updatedAt" : "2019-07-03T11:44:36Z",
        "lastEditedBy" : "ac925cd1-7327-4d2a-a9fc-55fc5f720f67",
        "tags" : [
        ]
      }
    ],
    "commit" : "2d8921bb61cdfdd71f93a3a185ebb476cbc95179",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +0,4 @@from pandas.core.indexes.api import (  # noqa:F401\n    CategoricalIndex, DatetimeIndex, Float64Index, Index, Int64Index,\n    IntervalIndex, InvalidIndexError, MultiIndex, NaT, NumericIndex,\n    PeriodIndex, RangeIndex, TimedeltaIndex, UInt64Index, _all_indexes_same,"
  },
  {
    "id" : "136a7a03-6dd2-405e-9945-571dd4f892e2",
    "prId" : 30193,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/30193#pullrequestreview-332202158",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4ac9d1fa-31d6-4384-81d6-471135cb5467",
        "parentId" : null,
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "Let's start with a DeprecationWarning?",
        "createdAt" : "2019-12-11T09:08:04Z",
        "updatedAt" : "2019-12-12T23:51:48Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      },
      {
        "id" : "e8178341-2563-4e7b-9923-535ac62c68bd",
        "parentId" : "4ac9d1fa-31d6-4384-81d6-471135cb5467",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "this  has been around forever \r\nlet’s just be loud about it (and it had been deprecation via documentation. forever)",
        "createdAt" : "2019-12-11T11:12:35Z",
        "updatedAt" : "2019-12-12T23:51:48Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "caf0ce0a-6f8c-487f-b900-588052c9cb9c",
        "parentId" : "4ac9d1fa-31d6-4384-81d6-471135cb5467",
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "OK, opened an issue about it at fastparquet: https://github.com/dask/fastparquet/issues/470",
        "createdAt" : "2019-12-14T08:06:49Z",
        "updatedAt" : "2019-12-14T08:06:49Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      }
    ],
    "commit" : "ab0dd27d95fc2b7460091db2b80c5aca52011845",
    "line" : 15,
    "diffHunk" : "@@ -1,1 +27,31 @@    \"pandas.core.index is deprecated and will be removed in a future version.  \"\n    \"The public classes are available in the top-level namespace.\",\n    FutureWarning,\n)"
  },
  {
    "id" : "92f30f42-903f-405b-8f3d-4a28db49a4b0",
    "prId" : 36178,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/36178#pullrequestreview-484551628",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e6148a95-a030-4a3b-85d1-089e3d5dab0e",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "actually i think you can just remove this line entirely (its not used inside)",
        "createdAt" : "2020-09-08T00:14:26Z",
        "updatedAt" : "2020-09-08T00:14:50Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "779ce28b-1623-456c-aa93-3a971ec1b699",
        "parentId" : "e6148a95-a030-4a3b-85d1-089e3d5dab0e",
        "authorId" : "adf621f1-4745-479a-a1fc-dc14046a3f4b",
        "body" : "i mean, nothing is used in this file",
        "createdAt" : "2020-09-08T00:45:07Z",
        "updatedAt" : "2020-09-08T00:45:08Z",
        "lastEditedBy" : "adf621f1-4745-479a-a1fc-dc14046a3f4b",
        "tags" : [
        ]
      },
      {
        "id" : "5b8f843f-f75f-41f6-89e2-27f8c003f755",
        "parentId" : "e6148a95-a030-4a3b-85d1-089e3d5dab0e",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "ok, then wonder if we need this *at* all here (and maybe even re-evaluate *all* of these exports); but let's do later.",
        "createdAt" : "2020-09-08T22:41:20Z",
        "updatedAt" : "2020-09-08T22:41:20Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "729441cd-c90e-4248-9b1a-3a9871959dc9",
        "parentId" : "e6148a95-a030-4a3b-85d1-089e3d5dab0e",
        "authorId" : "adf621f1-4745-479a-a1fc-dc14046a3f4b",
        "body" : "i think the idea is to remove the file in 2.0",
        "createdAt" : "2020-09-08T23:04:15Z",
        "updatedAt" : "2020-09-08T23:04:15Z",
        "lastEditedBy" : "adf621f1-4745-479a-a1fc-dc14046a3f4b",
        "tags" : [
        ]
      }
    ],
    "commit" : "fd5d08df8c450f2ad3284cd32b749601cc2d680b",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +20,24 @@    get_objs_combined_axis,\n)\nfrom pandas.core.indexes.multi import sparsify_labels  # noqa:F401\n\n# GH#30193"
  }
]
[
  {
    "id" : "69cbe633-3b10-4080-8210-35361f6aa20a",
    "prId" : 19268,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/19268#pullrequestreview-90190408",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d47dbe6a-3156-468d-9bd7-8b52ca9212f1",
        "parentId" : null,
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "By having our internal arrays inherit from `PandasObject`, they also get a `_constructor` method. So we should either make sure this is never used (apart from in methods inside the array itself), or add this to the interface (my preference would be the first)",
        "createdAt" : "2018-01-19T09:47:02Z",
        "updatedAt" : "2018-02-01T20:55:34Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      },
      {
        "id" : "98c9a0c7-475b-4bf0-839d-2271c4265c01",
        "parentId" : "d47dbe6a-3156-468d-9bd7-8b52ca9212f1",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "yeah, the methods in PandasObject needs to be ABC in the ExtensionArray ",
        "createdAt" : "2018-01-19T11:20:19Z",
        "updatedAt" : "2018-02-01T20:55:34Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "f38f40d7-e3ac-4ae0-9d0d-0b86a882f2b2",
        "parentId" : "d47dbe6a-3156-468d-9bd7-8b52ca9212f1",
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "On the other hand, I don't think all methods/attributes of PandasObject should be added to the public ExtensionArray (to keep those internal + to not clutter the ExtensionArray API)",
        "createdAt" : "2018-01-19T12:35:02Z",
        "updatedAt" : "2018-02-01T20:55:34Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      },
      {
        "id" : "fb8eea74-3b61-4947-8435-6fd51c08b189",
        "parentId" : "d47dbe6a-3156-468d-9bd7-8b52ca9212f1",
        "authorId" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "body" : "FYI, I'm consistently testing these changes against\r\n\r\n1. An implementation of `IntervalArary`: https://github.com/TomAugspurger/pandas/compare/pandas-array-interface-3...TomAugspurger:pandas-array-upstream+interval?expand=1\r\n2. A branch on pandas-ip: https://github.com/ContinuumIO/pandas-ip/tree/pandas-array-upstream-compat\r\n\r\nNeither inherit from `PandasObject` at the moment, so we're OK.",
        "createdAt" : "2018-01-19T17:45:13Z",
        "updatedAt" : "2018-02-01T20:55:34Z",
        "lastEditedBy" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "tags" : [
        ]
      }
    ],
    "commit" : "34134f2f9633cca26b4efd382475927c1eb3fe5a",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +151,155 @@\n\nclass Categorical(ExtensionArray, PandasObject):\n    \"\"\"\n    Represents a categorical variable in classic R / S-plus fashion"
  },
  {
    "id" : "d17b4313-81b6-443d-8098-35316e6e5316",
    "prId" : 19269,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/19269#pullrequestreview-89188073",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "10261b04-23a5-4f80-95ee-4aa681a0214e",
        "parentId" : null,
        "authorId" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "body" : "Note: I changed this from `except Exception` for the linter.",
        "createdAt" : "2018-01-16T16:07:34Z",
        "updatedAt" : "2018-01-18T11:54:47Z",
        "lastEditedBy" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "tags" : [
        ]
      },
      {
        "id" : "b0812060-0063-45c3-9e78-bfdd3fd04db9",
        "parentId" : "10261b04-23a5-4f80-95ee-4aa681a0214e",
        "authorId" : "adf621f1-4745-479a-a1fc-dc14046a3f4b",
        "body" : "+1",
        "createdAt" : "2018-01-16T17:51:21Z",
        "updatedAt" : "2018-01-18T11:54:47Z",
        "lastEditedBy" : "adf621f1-4745-479a-a1fc-dc14046a3f4b",
        "tags" : [
        ]
      }
    ],
    "commit" : "70da106b38afefe9d31824f870017ab1d9e8aa20",
    "line" : 558,
    "diffHunk" : "@@ -1,1 +556,560 @@        try:\n            codes = np.asarray(codes, np.int64)\n        except (ValueError, TypeError):\n            raise ValueError(\n                \"codes need to be convertible to an arrays of integers\")"
  },
  {
    "id" : "7312ef5d-d905-4b90-abaf-18773a7359a3",
    "prId" : 19684,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/19684#pullrequestreview-97192117",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b9d9348b-ee72-45c7-91e5-22094d6e5f36",
        "parentId" : null,
        "authorId" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "body" : "Note, I added this keyword since it's *possible* have a tuple / list for a `category`.",
        "createdAt" : "2018-02-13T20:40:59Z",
        "updatedAt" : "2018-02-21T12:52:48Z",
        "lastEditedBy" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "tags" : [
        ]
      },
      {
        "id" : "3c2a1808-9646-42b7-ab05-303971a1e2da",
        "parentId" : "b9d9348b-ee72-45c7-91e5-22094d6e5f36",
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "Do we need to add a test for this? (I mean filling a categorical with such categories, so the purpose of `validate_scalar_dict_value=False` is exercised)",
        "createdAt" : "2018-02-16T14:22:10Z",
        "updatedAt" : "2018-02-21T12:52:48Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      }
    ],
    "commit" : "dc1f9606204e126723867024fbf35f953dcf31c7",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +1611,1615 @@        filled : Categorical with NA/NaN filled\n        \"\"\"\n        value, method = validate_fillna_kwargs(\n            value, method, validate_scalar_dict_value=False\n        )"
  },
  {
    "id" : "ad787adf-51f4-429f-92cd-e96bc4051240",
    "prId" : 19909,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/19909#pullrequestreview-103059812",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "990333a4-b5da-4fbc-9aab-3d9c25e542b0",
        "parentId" : null,
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "Is there a reason this does `self.get_values().tolist()` instead of directly `self.tolist()` ?",
        "createdAt" : "2018-03-01T22:59:27Z",
        "updatedAt" : "2018-03-15T11:33:25Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      },
      {
        "id" : "cf1b60ce-879b-4209-b8ba-154b198e5f52",
        "parentId" : "990333a4-b5da-4fbc-9aab-3d9c25e542b0",
        "authorId" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "body" : "I think to avoid an infinite loop.\r\n\r\n`Categorical.tolist` calls `tolist` which calls `Categorical.__iter__`.\r\n\r\nNeed to do `get_values` break that cycle / extract the python scalar types.",
        "createdAt" : "2018-03-02T12:45:27Z",
        "updatedAt" : "2018-03-15T11:33:25Z",
        "lastEditedBy" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "tags" : [
        ]
      },
      {
        "id" : "349ab491-f2c9-443d-9aa5-72ed745bd510",
        "parentId" : "990333a4-b5da-4fbc-9aab-3d9c25e542b0",
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "It just feels that we are doing to much work. To iterate, we first create an array, iterate through it to create a list, and then iterate through the list ..",
        "createdAt" : "2018-03-02T12:48:04Z",
        "updatedAt" : "2018-03-15T11:33:25Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      },
      {
        "id" : "762f317c-6bce-4d50-b1e2-64ac8120e360",
        "parentId" : "990333a4-b5da-4fbc-9aab-3d9c25e542b0",
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "So get_values either returns a array or a Datetime(like)Index. For the array we can just iterate over it, but for the Datetime(like)Index I think as well . The tolist implementation there is `list(self.astype(object))`",
        "createdAt" : "2018-03-02T12:52:08Z",
        "updatedAt" : "2018-03-15T11:33:25Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      },
      {
        "id" : "82464f09-d0ce-424b-a0a5-3c08248d7ef6",
        "parentId" : "990333a4-b5da-4fbc-9aab-3d9c25e542b0",
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "Sorry, that previous comment was of course wrong, as that is exactly checking the `get_values().tolist()`",
        "createdAt" : "2018-03-02T12:55:02Z",
        "updatedAt" : "2018-03-15T11:33:25Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      },
      {
        "id" : "ca02595b-2867-4610-839b-cae778c2e12d",
        "parentId" : "990333a4-b5da-4fbc-9aab-3d9c25e542b0",
        "authorId" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "body" : "I'm not sure if there's a strictly better way. If we want iter(Categorical) to not immediately do any work, then we do something like\r\n\r\n```python\r\n    def iter2(self):\r\n        for i in range(len(self)):\r\n            yield asscalar(self[i])\r\n```\r\n\r\nSo while `cat.iter2()` is instant, actually consuming the iterator is slow. 22 seconds for a length-2,000,000 array, vs. 11 ms for the same array with the current implementation.\r\n\r\nAm I missing another way, that doesn't rely on many calls to __getitem__?",
        "createdAt" : "2018-03-02T13:05:47Z",
        "updatedAt" : "2018-03-15T11:33:25Z",
        "lastEditedBy" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "tags" : [
        ]
      },
      {
        "id" : "c3efb0d5-3aa4-4ecb-879c-0c52e68204ad",
        "parentId" : "990333a4-b5da-4fbc-9aab-3d9c25e542b0",
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "More correct comment: I think we can leave out the `tolist`, and do `iter(self.get_values()`\r\n\r\nOr alternatively move the logic to `__iter__` (using `get_values`) and let `tolist` just call `list(iter)`?",
        "createdAt" : "2018-03-02T13:07:11Z",
        "updatedAt" : "2018-03-15T11:33:25Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      },
      {
        "id" : "af3bc6fa-7521-43ec-b608-a0bcef2e7948",
        "parentId" : "990333a4-b5da-4fbc-9aab-3d9c25e542b0",
        "authorId" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "body" : "We need to call `tolist()` on the NumPy array from `.get_values()` so that the scalars are converted to Python types.\r\n\r\nBut yes, moving the logic sounds fine.",
        "createdAt" : "2018-03-02T13:09:32Z",
        "updatedAt" : "2018-03-15T11:33:25Z",
        "lastEditedBy" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "tags" : [
        ]
      },
      {
        "id" : "573b5df7-102d-4f9b-ac1f-26192bb79ba9",
        "parentId" : "990333a4-b5da-4fbc-9aab-3d9c25e542b0",
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "Ah, yes, therefore we need the tolist. \r\nBut then moving the logic is maybe not best, as then `tolist` would consume an iterator coming from a list .. \r\n\r\nIt's all just complex with the different unboxing depending on the type :-)",
        "createdAt" : "2018-03-02T13:25:16Z",
        "updatedAt" : "2018-03-15T11:33:25Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      },
      {
        "id" : "9836bf21-6712-411b-8905-9533db866802",
        "parentId" : "990333a4-b5da-4fbc-9aab-3d9c25e542b0",
        "authorId" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "body" : "Simplified slightly if you want to take one last look. Basically, we didn't have to worry about the different unboxing for different types, since `Categorical.get_values()` with datetimes returns a DatetimeIndex, and when we `.tolist()` on that we get the right unboxing.",
        "createdAt" : "2018-03-02T14:22:59Z",
        "updatedAt" : "2018-03-15T11:33:25Z",
        "lastEditedBy" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "tags" : [
        ]
      },
      {
        "id" : "2dedc515-0964-45c3-b694-6485a009b0cf",
        "parentId" : "990333a4-b5da-4fbc-9aab-3d9c25e542b0",
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "Looks good!",
        "createdAt" : "2018-03-02T14:34:31Z",
        "updatedAt" : "2018-03-15T11:33:25Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      },
      {
        "id" : "ce033a34-d782-4cb1-8850-6f2407b2daa8",
        "parentId" : "990333a4-b5da-4fbc-9aab-3d9c25e542b0",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "this is the whole ``.get_values()`` fiasco (which I created a while back :). I think should be addressed sooner rather than later.",
        "createdAt" : "2018-03-07T13:49:47Z",
        "updatedAt" : "2018-03-15T11:33:25Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "9278037d-5af4-4d83-8191-771bf24863e5",
        "parentId" : "990333a4-b5da-4fbc-9aab-3d9c25e542b0",
        "authorId" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "body" : "Any issues with the current implementation? Currently there's a tradeoff between how expensive `it = iter(Categorical)` is vs. `next(it)`.\r\n\r\nSomewhere, we have to go from numpy scalars to Python scalars. The fastest way to do that is with `tolist()`, but that has upfront memory overhead. We could avoid that by doing it in the `next`, but that has time overhead for\r\n\r\n1. converting to Python scalars elementwise\r\n2. An extra call to CategoricalIndex.categories.__getitem__ per element\r\n\r\nso that `next(it)` becomes *much* slower. I don't think there's much more to be done right now.\r\n",
        "createdAt" : "2018-03-12T14:15:36Z",
        "updatedAt" : "2018-03-15T11:33:25Z",
        "lastEditedBy" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "tags" : [
        ]
      }
    ],
    "commit" : "05fced650bac03f122689ce6f8fd423f89bea3d6",
    "line" : 37,
    "diffHunk" : "@@ -1,1 +1716,1720 @@    def __iter__(self):\n        \"\"\"Returns an Iterator over the values of this Categorical.\"\"\"\n        return iter(self.get_values().tolist())\n\n    def _tidy_repr(self, max_vals=10, footer=True):"
  },
  {
    "id" : "23efcb34-e5ee-4701-9409-55fac197f4b7",
    "prId" : 19938,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/19938#pullrequestreview-103670438",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7c1888d1-31f0-4f68-aa80-29104e31ea98",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "The interface we have to ``hashtable.get_labels()`` is very odd right now, IOW we have a ``check_null`` flag which then makes the caller *know* to substitute values to iNaT (for int64) and know which are the sentinels. This is breaking the abstrastion. Rather would either like to be able to pass in the actual sentinel (not the *output* sentinel, but that's another confusion). e.g . you would simply pass -1 here.\r\n\r\nI think its worth re-factoring this (maybe before this PR), though I suppose could be after. ",
        "createdAt" : "2018-03-13T12:14:26Z",
        "updatedAt" : "2018-03-14T11:29:35Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "c2fd8ce5-36c4-4cf7-adf8-22e2450a7951",
        "parentId" : "7c1888d1-31f0-4f68-aa80-29104e31ea98",
        "authorId" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "body" : "https://github.com/pandas-dev/pandas/issues/20328\r\n\r\nYes, that'd be nicer.",
        "createdAt" : "2018-03-13T12:25:35Z",
        "updatedAt" : "2018-03-14T11:29:35Z",
        "lastEditedBy" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "tags" : [
        ]
      },
      {
        "id" : "f1c70545-5e98-48cb-84cf-b96aac749977",
        "parentId" : "7c1888d1-31f0-4f68-aa80-29104e31ea98",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "do we actually want this to be public?",
        "createdAt" : "2018-03-13T23:16:29Z",
        "updatedAt" : "2018-03-14T11:29:35Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "190764a1-a287-4027-bd0b-5770a24eda2d",
        "parentId" : "7c1888d1-31f0-4f68-aa80-29104e31ea98",
        "authorId" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "body" : "factorize in general? I don’t see why not. It’s present on series and index. ",
        "createdAt" : "2018-03-13T23:36:00Z",
        "updatedAt" : "2018-03-14T11:29:35Z",
        "lastEditedBy" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "tags" : [
        ]
      },
      {
        "id" : "a8966675-1c3e-4ce1-86a3-67a10e62df1e",
        "parentId" : "7c1888d1-31f0-4f68-aa80-29104e31ea98",
        "authorId" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "body" : "https://github.com/pandas-dev/pandas/pull/19938#issuecomment-372648259 was in reference to the API docs. We whitelist the methods on Categorical that are included in the API docs (just `__array__` and `from_codes` for now).",
        "createdAt" : "2018-03-14T01:47:36Z",
        "updatedAt" : "2018-03-14T11:29:35Z",
        "lastEditedBy" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "tags" : [
        ]
      }
    ],
    "commit" : "1e006d1a187b35941da3a548415f097160e5bb92",
    "line" : 78,
    "diffHunk" : "@@ -1,1 +2118,2122 @@\n        codes = self.codes.astype('int64')\n        codes[codes == -1] = iNaT\n        # We set missing codes, normally -1, to iNaT so that the\n        # Int64HashTable treats them as missing values."
  },
  {
    "id" : "56911269-dfb0-4672-aa94-2c2c5cc9757c",
    "prId" : 19957,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/19957#pullrequestreview-100935057",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b5f4569b-9e5a-478f-b743-c4cc2c4c9b14",
        "parentId" : null,
        "authorId" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "body" : "Not sure if this changes our opinion on `_values_for_argsort`, but the apparently Python2 has issues with passing through the arguments correctly to the `super()` call.\r\n\r\n```\r\n____________________ TestCategoricalSort.test_numpy_argsort ____________________\r\n\r\nself = <pandas.tests.categorical.test_sorting.TestCategoricalSort object at 0x7efcb391f950>\r\n\r\n    def test_numpy_argsort(self):\r\n        c = Categorical([5, 3, 1, 4, 2], ordered=True)\r\n    \r\n        expected = np.array([2, 4, 1, 3, 0])\r\n>       tm.assert_numpy_array_equal(np.argsort(c), expected,\r\n                                    check_dtype=False)\r\n\r\npandas/tests/categorical/test_sorting.py:26: \r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n../miniconda3/envs/pandas/lib/python2.7/site-packages/numpy/core/fromnumeric.py:886: in argsort\r\n    return argsort(axis, kind, order)\r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n\r\nself = [5, 3, 1, 4, 2]\r\nCategories (5, int64): [1 < 2 < 3 < 4 < 5]\r\nascending = -1, kind = 'quicksort', args = (None,), kwargs = {}\r\n\r\n    def argsort(self, ascending=True, kind='quicksort', *args, **kwargs):\r\n        \"\"\"\r\n            Returns the indices that would sort the Categorical instance if\r\n            'sort_values' was called. This function is implemented to provide\r\n            compatibility with numpy ndarray objects.\r\n    \r\n            While an ordering is applied to the category values, arg-sorting\r\n            in this context refers more to organizing and grouping together\r\n            based on matching category values. Thus, this function can be\r\n            called on an unordered Categorical instance unlike the functions\r\n            'Categorical.min' and 'Categorical.max'.\r\n    \r\n            Returns\r\n            -------\r\n            argsorted : numpy array\r\n    \r\n            See also\r\n            --------\r\n            numpy.ndarray.argsort\r\n            \"\"\"\r\n        # Keep the implementation here just for the docstring.\r\n        return super(Categorical, self).argsort(ascending=ascending, kind=kind,\r\n>                                               *args, **kwargs)\r\nE       TypeError: argsort() got multiple values for keyword argument 'ascending'\r\n```\r\n\r\nChanging the Categorical.argsort to accept just `*args, **kwargs` fixes things, since `ExtensionArray` does the argument validation, but it's a bit unfortunate.",
        "createdAt" : "2018-03-02T22:33:37Z",
        "updatedAt" : "2018-03-20T19:49:48Z",
        "lastEditedBy" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "tags" : [
        ]
      }
    ],
    "commit" : "48852457373eff62847ff976bbdcced12923cc94",
    "line" : 17,
    "diffHunk" : "@@ -1,1 +1382,1386 @@        return self._codes.copy()\n\n    def argsort(self, *args, **kwargs):\n        # TODO(PY2): use correct signature\n        # We have to do *args, **kwargs to avoid a a py2-only signature"
  },
  {
    "id" : "5093cb23-28b3-4e29-ad9b-bfa6bdbfe565",
    "prId" : 19957,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/19957#pullrequestreview-103674145",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "10029666-1b5b-4a31-beb5-eb77ed0bbe17",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "do these doc-strings meet the new standards? ",
        "createdAt" : "2018-03-13T23:14:59Z",
        "updatedAt" : "2018-03-20T19:49:48Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "ac436b75-6d5b-4ba9-b87d-d570c5cac0fc",
        "parentId" : "10029666-1b5b-4a31-beb5-eb77ed0bbe17",
        "authorId" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "body" : "7bbe796 does, aside from examples which isn't really possible.",
        "createdAt" : "2018-03-14T02:19:00Z",
        "updatedAt" : "2018-03-20T19:49:48Z",
        "lastEditedBy" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "tags" : [
        ]
      }
    ],
    "commit" : "48852457373eff62847ff976bbdcced12923cc94",
    "line" : 24,
    "diffHunk" : "@@ -1,1 +1389,1393 @@\n        Parameters\n        ----------\n        ascending : bool, default True\n            Whether the indices should result in an ascending"
  },
  {
    "id" : "9c998479-4492-49eb-8322-e6e3fa9de17a",
    "prId" : 20286,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/20286#pullrequestreview-105610695",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2c902503-dcc1-47ce-b598-d66483f7591d",
        "parentId" : null,
        "authorId" : "5e8c5ef2-940b-436e-9c5f-98ae5460128c",
        "body" : "This is simplified to the point that I think you can now just say \"If the mapping correspondence is one-to-one the result is a ...\" in the second sentence",
        "createdAt" : "2018-03-21T05:39:27Z",
        "updatedAt" : "2018-03-21T21:27:02Z",
        "lastEditedBy" : "5e8c5ef2-940b-436e-9c5f-98ae5460128c",
        "tags" : [
        ]
      }
    ],
    "commit" : "ecbaca0dbdd2d2d743c10c523b72ea9935f6ad26",
    "line" : 8,
    "diffHunk" : "@@ -1,1 +1084,1088 @@        Map categories using input correspondence (dict, Series, or function).\n\n        Maps the categories to new categories. If the mapping correspondence is\n        one-to-one the result is a :class:`~pandas.Categorical` which has the\n        same order property as the original, otherwise a :class:`~pandas.Index`"
  },
  {
    "id" : "0d928110-b3a0-472e-bde2-af5bb202ad87",
    "prId" : 20583,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/20583#pullrequestreview-115906488",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b9da4ad8-ba04-44f5-8f6b-97d66d991f68",
        "parentId" : null,
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "Can you update this docstring?",
        "createdAt" : "2018-04-28T10:37:26Z",
        "updatedAt" : "2018-05-01T10:07:16Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      }
    ],
    "commit" : "bdf7525812ca670f9406ab8df333030d36d30947",
    "line" : 25,
    "diffHunk" : "@@ -1,1 +676,680 @@            appearance in codes (unless ordered=True, in which case the\n            original order is preserved), followed by any unrepresented\n            categories in the original order.\n        \"\"\"\n"
  },
  {
    "id" : "74b35af3-5c9e-4fd2-84d5-31cdd521a6e9",
    "prId" : 20583,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/20583#pullrequestreview-117202155",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c960b80f-4824-4ef5-b35b-ffa1fe4d6641",
        "parentId" : null,
        "authorId" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "body" : "Haven't thought this through, but can this `if` block be replaced with `self.remove_unused_cateogories()._codes_for_groupby(sort=sort, observed=False)`?",
        "createdAt" : "2018-05-01T11:14:19Z",
        "updatedAt" : "2018-05-01T11:16:48Z",
        "lastEditedBy" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "tags" : [
        ]
      },
      {
        "id" : "8ea3bbea-0e87-4d3a-92a6-2a2ff0f6d5b5",
        "parentId" : "c960b80f-4824-4ef5-b35b-ffa1fe4d6641",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "no, you actually need the uniques",
        "createdAt" : "2018-05-03T10:10:50Z",
        "updatedAt" : "2018-05-03T10:10:50Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "bdf7525812ca670f9406ab8df333030d36d30947",
    "line" : 30,
    "diffHunk" : "@@ -1,1 +681,685 @@        # we only care about observed values\n        if observed:\n            unique_codes = unique1d(self.codes)\n            cat = self.copy()\n"
  },
  {
    "id" : "b0fa0f8e-59ad-4326-8fc6-f74b59623943",
    "prId" : 20611,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/20611#pullrequestreview-135245141",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "84053ac7-acf8-4685-a2db-2b03a9655a35",
        "parentId" : null,
        "authorId" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "body" : "`__array__` has to return an ndarray. Without this, Categorical[ExtensionArray]` would fail, as `take_1d(...)` would be an ExtensionArray.",
        "createdAt" : "2018-04-04T16:51:38Z",
        "updatedAt" : "2018-07-13T01:00:53Z",
        "lastEditedBy" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "tags" : [
        ]
      },
      {
        "id" : "72c1a869-54d6-4931-9139-4afb6601aa8b",
        "parentId" : "84053ac7-acf8-4685-a2db-2b03a9655a35",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "comment this.",
        "createdAt" : "2018-04-05T15:47:17Z",
        "updatedAt" : "2018-07-13T01:00:53Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "4c732b81-2d09-42e4-b492-2a7fc76b5a0e",
        "parentId" : "84053ac7-acf8-4685-a2db-2b03a9655a35",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "I have an update on this section already in intna",
        "createdAt" : "2018-07-08T20:54:31Z",
        "updatedAt" : "2018-07-13T01:00:53Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "385ce59f79ff1921a44f3bbaa17044032e3ed4d3",
    "line" : 12,
    "diffHunk" : "@@ -1,1 +1245,1249 @@        if dtype and not is_dtype_equal(dtype, self.categories.dtype):\n            return np.asarray(ret, dtype)\n        if is_extension_array_dtype(ret):\n            # When we're a Categorical[ExtensionArray], like Interval,\n            # we need to ensure __array__ get's all the way to an"
  },
  {
    "id" : "3e824e68-54d8-4405-8fbc-57b42eabb619",
    "prId" : 20779,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/20779#pullrequestreview-114184161",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "656cb1c0-6f76-4db3-af5a-47b9c2d2a426",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "add versionadded (anytime you add the param)",
        "createdAt" : "2018-04-21T21:53:55Z",
        "updatedAt" : "2018-05-31T10:39:24Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "6f14357f74eced232ee23f5f659b64cae7bbaae1",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +2127,2131 @@        Parameters\n        ----------\n        dropna : boolean, default True\n            Don't consider counts of NaN/NaT.\n"
  },
  {
    "id" : "d514ada9-7bf6-45e4-bf43-8a517218c88c",
    "prId" : 20826,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/20826#pullrequestreview-115910738",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a3d2f3fc-e9b7-459f-be23-c91f82111ea5",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "this does NOT belong here at all, you are mixing up parsing with setting the categories. you can do this via a separate function *inside* parser.pyx",
        "createdAt" : "2018-04-27T10:34:16Z",
        "updatedAt" : "2018-11-23T10:39:57Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "9ee08f44-9f04-4114-b515-d113039140ae",
        "parentId" : "a3d2f3fc-e9b7-459f-be23-c91f82111ea5",
        "authorId" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "body" : "I think there were issues with that (either nogil, or having to share code with the Python parser).",
        "createdAt" : "2018-04-27T11:33:12Z",
        "updatedAt" : "2018-11-23T10:39:57Z",
        "lastEditedBy" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "tags" : [
        ]
      },
      {
        "id" : "fe922887-a68e-4288-b169-b291c6bd08a7",
        "parentId" : "a3d2f3fc-e9b7-459f-be23-c91f82111ea5",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "well it certainly doesn’t belong here\r\nthis is conflating parsing with categories",
        "createdAt" : "2018-04-27T11:36:20Z",
        "updatedAt" : "2018-11-23T10:39:57Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "4e234b12-36f1-4d41-b7c9-ce566d1fd328",
        "parentId" : "a3d2f3fc-e9b7-459f-be23-c91f82111ea5",
        "authorId" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "body" : "I see now that this is called outside a nogil block, so a standalone method for that should be fine. If you want to open an issue though, because I don't think it should hold up the release.",
        "createdAt" : "2018-04-27T11:37:38Z",
        "updatedAt" : "2018-11-23T10:39:57Z",
        "lastEditedBy" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "tags" : [
        ]
      },
      {
        "id" : "cc16486e-58fc-401e-af05-c110bceb5d00",
        "parentId" : "a3d2f3fc-e9b7-459f-be23-c91f82111ea5",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "this isn't necessary for the RC. this needs to be fixed in this PR.",
        "createdAt" : "2018-04-27T11:56:22Z",
        "updatedAt" : "2018-11-23T10:39:57Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "f96a854203c57cb40cdc0ebfa89173d62a50b8f2",
    "line" : 46,
    "diffHunk" : "@@ -1,1 +582,586 @@            elif is_timedelta64_dtype(dtype.categories):\n                cats = to_timedelta(inferred_categories, errors=\"coerce\")\n            elif dtype.categories.is_boolean():\n                if true_values is None:\n                    true_values = [\"True\", \"TRUE\", \"true\"]"
  },
  {
    "id" : "2a11ef48-02f2-45bf-a36f-13959d85734b",
    "prId" : 20841,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/20841#pullrequestreview-116145913",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4e04760c-2013-4ccf-8c9e-b8e9d6dff7b2",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "maybe just put the warning inline here?",
        "createdAt" : "2018-04-28T13:41:57Z",
        "updatedAt" : "2018-04-30T11:17:47Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "9ae9ca64-8076-47e9-a090-b787da17be52",
        "parentId" : "4e04760c-2013-4ccf-8c9e-b8e9d6dff7b2",
        "authorId" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "body" : "That messes with the formatting.",
        "createdAt" : "2018-04-28T18:51:00Z",
        "updatedAt" : "2018-04-30T11:17:47Z",
        "lastEditedBy" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "tags" : [
        ]
      }
    ],
    "commit" : "12485c525cd18f967c473ccb5f99c887e4f972b2",
    "line" : 80,
    "diffHunk" : "@@ -1,1 +1778,1782 @@        if allow_fill is None:\n            if (indexer < 0).any():\n                warn(_take_msg, FutureWarning, stacklevel=2)\n                allow_fill = True\n"
  },
  {
    "id" : "b652444a-fb2f-42f6-8b4e-1efa9ce81416",
    "prId" : 20841,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/20841#pullrequestreview-116145986",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8b605f95-3bd3-4a6c-a8dd-330a595b29e9",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "is this condition tested?",
        "createdAt" : "2018-04-28T13:42:27Z",
        "updatedAt" : "2018-04-30T11:17:47Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "71df7665-014a-4383-8f56-1eabb374ff77",
        "parentId" : "8b605f95-3bd3-4a6c-a8dd-330a595b29e9",
        "authorId" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "body" : "Yep.",
        "createdAt" : "2018-04-28T18:54:22Z",
        "updatedAt" : "2018-04-30T11:17:47Z",
        "lastEditedBy" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "tags" : [
        ]
      }
    ],
    "commit" : "12485c525cd18f967c473ccb5f99c887e4f972b2",
    "line" : 84,
    "diffHunk" : "@@ -1,1 +1782,1786 @@\n        if isna(fill_value):\n            # For categorical, any NA value is considered a user-facing\n            # NA value. Our storage NA value is -1.\n            fill_value = -1"
  },
  {
    "id" : "2bd45a47-62e1-4b90-89f3-c3560096d648",
    "prId" : 22072,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/22072#pullrequestreview-141316560",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2dcf709c-da42-401d-8f46-a30b4cf9a036",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "can you add the issue reference",
        "createdAt" : "2018-07-28T13:00:40Z",
        "updatedAt" : "2018-08-11T12:07:19Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "213c4ea42f2aaaa4f8c8ed359297b2b864c0f7ca",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +2539,2543 @@        codes = values.codes\n    else:\n        # The value of ordered is irrelevant since we don't use cat as such,\n        # but only the resulting categories, the order of which is independent\n        # from ordered. Set ordered to False as default. See GH #15457"
  },
  {
    "id" : "d632aa83-2380-4e33-a390-8238186d1f16",
    "prId" : 22762,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/22762#pullrequestreview-161998208",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e69d1199-ab5e-4835-b210-37d4af9e7bdc",
        "parentId" : null,
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "The `skipna` is ignored here (which is actually a missing feature in the current implementation I suppose?)",
        "createdAt" : "2018-10-01T14:43:17Z",
        "updatedAt" : "2018-10-12T11:40:31Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      },
      {
        "id" : "4e9d21f5-2438-4239-9fb7-b077cb12f051",
        "parentId" : "e69d1199-ab5e-4835-b210-37d4af9e7bdc",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "yes i think that's right",
        "createdAt" : "2018-10-05T11:46:53Z",
        "updatedAt" : "2018-10-12T11:40:31Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "aeaf5f32c0939d6bedc99240b47dd54252dda96a",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +2075,2079 @@            msg = 'Categorical cannot perform the operation {op}'\n            raise TypeError(msg.format(op=name))\n        return func(**kwargs)\n\n    def min(self, numeric_only=None, **kwargs):"
  },
  {
    "id" : "9b346b24-f92f-4eb0-ae6d-26e2b9485704",
    "prId" : 23293,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/23293#pullrequestreview-167936832",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ca1cb2b9-e215-44de-8e17-ef5664506d3d",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "shouldn't this be in the super class? e.g. this is a pretty general condition",
        "createdAt" : "2018-10-24T13:08:15Z",
        "updatedAt" : "2019-07-01T18:47:58Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "731e34b0-1444-4d2a-9d79-db7e6b77383d",
        "parentId" : "ca1cb2b9-e215-44de-8e17-ef5664506d3d",
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "The super class of Categorical is ExtensionArray, and I don't want to put it in there (it's not necessarily that should be done in general for all EAs). ",
        "createdAt" : "2018-10-24T14:23:59Z",
        "updatedAt" : "2019-07-01T18:47:58Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      }
    ],
    "commit" : "7486d260178176f9e9674c8036bc3063a067b24a",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +1296,1300 @@    def __array_ufunc__(self, ufunc, method, *inputs, **kwargs):\n        # for binary ops, use our custom dunder methods\n        result = ops.maybe_dispatch_ufunc_to_dunder_op(\n            self, ufunc, method, *inputs, **kwargs)\n        if result is not NotImplemented:"
  },
  {
    "id" : "586e6dd3-9056-48dc-ad29-57d002bbc080",
    "prId" : 23293,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/23293#pullrequestreview-168635695",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6edbaeb4-23c8-4096-b6d2-82cc3e19abce",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "blank line here",
        "createdAt" : "2018-10-26T00:23:56Z",
        "updatedAt" : "2019-07-01T18:47:58Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "7486d260178176f9e9674c8036bc3063a067b24a",
    "line" : 19,
    "diffHunk" : "@@ -1,1 +1301,1305 @@            return result\n\n        # for all other cases, raise for now (similarly as what happens in\n        # Series.__array_prepare__)\n        raise TypeError(\"Object with dtype {dtype} cannot perform \""
  }
]
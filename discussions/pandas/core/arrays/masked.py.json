[
  {
    "id" : "f98a7c34-9509-42ab-a1d3-00de130bbfde",
    "prId" : 30789,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/30789#pullrequestreview-339394992",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "34b04ffc-7916-46ee-9ba2-5650b2b4637c",
        "parentId" : null,
        "authorId" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "body" : "I suspect IntegerArray has some `isna().any()` that can be updated to use this property.",
        "createdAt" : "2020-01-07T17:39:48Z",
        "updatedAt" : "2020-01-08T07:20:16Z",
        "lastEditedBy" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "tags" : [
        ]
      }
    ],
    "commit" : "e86a6f11f4b5e2d64533c44bd23a5ea082f08bd4",
    "line" : 155,
    "diffHunk" : "@@ -1,1 +153,157 @@\n    @property\n    def _hasna(self) -> bool:\n        # Note: this is expensive right now! The hope is that we can\n        # make this faster by having an optional mask, but not have to change"
  },
  {
    "id" : "abbe9926-8d2f-4508-84b2-c5fe27c72c2a",
    "prId" : 30789,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/30789#pullrequestreview-339402854",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e35f5781-d369-4727-b81f-21f2a96d8b59",
        "parentId" : null,
        "authorId" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "body" : "Possibly out of scope, but I see the same optimization issue we had with Categorical. Can you convert `item` to an ndarray before doing this `elif`? Or do you want to keep this as a straight refactor, and do that as a followup?",
        "createdAt" : "2020-01-07T17:41:19Z",
        "updatedAt" : "2020-01-08T07:20:16Z",
        "lastEditedBy" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "tags" : [
        ]
      },
      {
        "id" : "4e5a5898-6ebe-493a-8a96-0260e66e2352",
        "parentId" : "e35f5781-d369-4727-b81f-21f2a96d8b59",
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "Yes, I also noted that on the PR (https://github.com/pandas-dev/pandas/pull/30747#issuecomment-571278131), I think it is still worth thinking this through if we need a more general \"check\" function (https://github.com/pandas-dev/pandas/issues/30744#issuecomment-571276333, #30738)",
        "createdAt" : "2020-01-07T17:54:21Z",
        "updatedAt" : "2020-01-08T07:20:16Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      }
    ],
    "commit" : "e86a6f11f4b5e2d64533c44bd23a5ea082f08bd4",
    "line" : 38,
    "diffHunk" : "@@ -1,1 +36,40 @@            return self._data[item]\n\n        elif com.is_bool_indexer(item):\n            item = check_bool_array_indexer(self, item)\n"
  },
  {
    "id" : "0780ffb3-f740-467d-88b1-05e7431603bb",
    "prId" : 30789,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/30789#pullrequestreview-339399953",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "80cb61b9-db5c-4d58-9b25-ffc7e5f2a7c0",
        "parentId" : null,
        "authorId" : "adf621f1-4745-479a-a1fc-dc14046a3f4b",
        "body" : "could do _validate_fill_value like DTA/TDA/PA to avoid allowing e.g. NaT here",
        "createdAt" : "2020-01-07T17:48:53Z",
        "updatedAt" : "2020-01-08T07:20:16Z",
        "lastEditedBy" : "adf621f1-4745-479a-a1fc-dc14046a3f4b",
        "tags" : [
        ]
      }
    ],
    "commit" : "e86a6f11f4b5e2d64533c44bd23a5ea082f08bd4",
    "line" : 181,
    "diffHunk" : "@@ -1,1 +179,183 @@        # we always fill with 1 internally\n        # to avoid upcasting\n        data_fill_value = self._internal_fill_value if isna(fill_value) else fill_value\n        result = take(\n            self._data, indexer, fill_value=data_fill_value, allow_fill=allow_fill"
  },
  {
    "id" : "060baf64-a828-4a9e-95aa-ba099c5d20d8",
    "prId" : 30789,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/30789#pullrequestreview-339864005",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "87a81ca2-812c-46c0-8058-843a0a68fcda",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "would remove / modify these comments",
        "createdAt" : "2020-01-08T13:34:10Z",
        "updatedAt" : "2020-01-08T13:34:36Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "e86a6f11f4b5e2d64533c44bd23a5ea082f08bd4",
    "line" : 179,
    "diffHunk" : "@@ -1,1 +177,181 @@\n    def take(self, indexer, allow_fill=False, fill_value=None):\n        # we always fill with 1 internally\n        # to avoid upcasting\n        data_fill_value = self._internal_fill_value if isna(fill_value) else fill_value"
  },
  {
    "id" : "db5d1cba-9c7f-474a-9bb9-53680b63c66c",
    "prId" : 31728,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/31728#pullrequestreview-354904719",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ecfa7a3e-a69e-4bec-b792-7843bc0955bb",
        "parentId" : null,
        "authorId" : "554ba0f6-6e6a-40c3-98e0-1a6cc4a8e1c6",
        "body" : "we need to add the typevar to avoid...\r\n\r\npandas\\core\\arrays\\integer.py:117: error: Incompatible return value type (got \"BaseMaskedArray\", expected \"IntegerArray\")\r\npandas\\core\\arrays\\boolean.py:122: error: Incompatible return value type (got \"BaseMaskedArray\", expected \"BooleanArray\")\r\n\r\nwe can't use the unbound typevar from pandas._typing here otherwise we get...\r\n\r\npandas\\core\\arrays\\masked.py:183: error: Too many arguments for \"object\"\r\n\r\nsince the typevar is needed here, it is also used for the other methods that return type(self)",
        "createdAt" : "2020-02-06T00:44:41Z",
        "updatedAt" : "2020-02-06T01:58:06Z",
        "lastEditedBy" : "554ba0f6-6e6a-40c3-98e0-1a6cc4a8e1c6",
        "tags" : [
        ]
      },
      {
        "id" : "18420433-c82c-4879-ad00-e742bd55d7aa",
        "parentId" : "ecfa7a3e-a69e-4bec-b792-7843bc0955bb",
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "As I said in another issue, I don't have problems with it if there is no way around it, but it needs to be documented then",
        "createdAt" : "2020-02-06T08:34:42Z",
        "updatedAt" : "2020-02-06T08:35:53Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      },
      {
        "id" : "b09a80de-06f8-4a0f-a1d4-7d474046b1da",
        "parentId" : "ecfa7a3e-a69e-4bec-b792-7843bc0955bb",
        "authorId" : "5e8c5ef2-940b-436e-9c5f-98ae5460128c",
        "body" : "I don't think this is a problem; it's documented in PEP 484\r\n\r\nhttps://www.python.org/dev/peps/pep-0484/#annotating-instance-and-class-methods",
        "createdAt" : "2020-02-07T02:51:46Z",
        "updatedAt" : "2020-02-07T02:51:46Z",
        "lastEditedBy" : "5e8c5ef2-940b-436e-9c5f-98ae5460128c",
        "tags" : [
        ]
      }
    ],
    "commit" : "554ddc0f2de492d41ec2cdec09d413a1420245c8",
    "line" : 79,
    "diffHunk" : "@@ -1,1 +181,185 @@\n    @classmethod\n    def _concat_same_type(cls: Type[BaseMaskedArrayT], to_concat) -> BaseMaskedArrayT:\n        data = np.concatenate([x._data for x in to_concat])\n        mask = np.concatenate([x._mask for x in to_concat])"
  },
  {
    "id" : "f994ba61-5816-40ce-bc4c-68a6a0a33ab6",
    "prId" : 31728,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/31728#pullrequestreview-354143037",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5df26efb-e960-4e91-9e58-af8817ebd261",
        "parentId" : null,
        "authorId" : "554ba0f6-6e6a-40c3-98e0-1a6cc4a8e1c6",
        "body" : "\\_\\_init__ needs to be declared in the base class...\r\n\r\npandas\\core\\arrays\\masked.py:56: error: Too many arguments for \"BaseMaskedArray\"\r\npandas\\core\\arrays\\masked.py:181: error: Too many arguments for \"BaseMaskedArray\"\r\npandas\\core\\arrays\\masked.py:207: error: Too many arguments for \"BaseMaskedArray\"\r\npandas\\core\\arrays\\masked.py:207: error: Unexpected keyword argument \"copy\" for \"BaseMaskedArray\"\r\npandas\\core\\arrays\\masked.py:213: error: Too many arguments for \"BaseMaskedArray\"\r\npandas\\core\\arrays\\masked.py:213: error: Unexpected keyword argument \"copy\" for \"BaseMaskedArray\"\r\n\r\nalso creating this ensures that the subclasses have the correct signature for the constructor to work with `__invert__`, ` _concat_same_type`, `take` and `copy` from the base class.\r\n\r\nwe could just use a AbstractMethodError but I think it makes sense to put the shared functionality here.\r\n\r\nBooleanArray has checking for values.ndim and mask.ndim. IntegerArray does not. It may make sense to have that check here also if applicable to IntegerArray.",
        "createdAt" : "2020-02-06T00:57:39Z",
        "updatedAt" : "2020-02-06T01:58:06Z",
        "lastEditedBy" : "554ba0f6-6e6a-40c3-98e0-1a6cc4a8e1c6",
        "tags" : [
        ]
      }
    ],
    "commit" : "554ddc0f2de492d41ec2cdec09d413a1420245c8",
    "line" : 34,
    "diffHunk" : "@@ -1,1 +30,34 @@    _internal_fill_value: Scalar\n\n    def __init__(self, values: np.ndarray, mask: np.ndarray, copy: bool = False):\n        if copy:\n            values = values.copy()"
  },
  {
    "id" : "bf89e66e-5c46-4a45-bc04-601b99b32c0b",
    "prId" : 31728,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/31728#pullrequestreview-354270488",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b5bef1e8-4e27-44a2-b5f6-ecec1c00a205",
        "parentId" : null,
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "We otherwise don't type self, or do we? \r\n(self is always the type of the class, no?)",
        "createdAt" : "2020-02-06T08:35:17Z",
        "updatedAt" : "2020-02-06T08:35:53Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      }
    ],
    "commit" : "554ddc0f2de492d41ec2cdec09d413a1420245c8",
    "line" : 86,
    "diffHunk" : "@@ -1,1 +187,191 @@\n    def take(\n        self: BaseMaskedArrayT,\n        indexer,\n        allow_fill: bool = False,"
  },
  {
    "id" : "ec342c60-0511-426e-ab44-a3742044d6aa",
    "prId" : 33064,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/33064#pullrequestreview-387578493",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8265d08d-e95a-46cf-a3ab-aceb2814f757",
        "parentId" : null,
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "I get a \"pandas/core/arrays/masked.py:229: error: \"ExtensionDtype\" has no attribute \"numpy_dtype\"\" mypy failure\r\n\r\ncc @simonjayhawkins @WillAyd how can I solve / silence this? The `numpy_dtype` attribute is commong for Int/BoolDtype (so I can safely use it), but not for general ExtensionDtype.",
        "createdAt" : "2020-04-03T19:46:05Z",
        "updatedAt" : "2020-05-09T10:54:51Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      },
      {
        "id" : "0b7f04ca-7830-4ab9-be2b-8981a7c9a724",
        "parentId" : "8265d08d-e95a-46cf-a3ab-aceb2814f757",
        "authorId" : "5e8c5ef2-940b-436e-9c5f-98ae5460128c",
        "body" : "Hmm yea so I guess complaining because as far as this class is defined, the return type of `self.dtype` is an ExtensionDtype (as defined in `ExtensionArray`)\r\n\r\nI guess it comes back to the class design; if we have something else that inherits from BaseMaskedArray it could fail at runtime without if it isn't constructed to return a dtype from `self.dtype` that has a `numpy_dtype` attribute, which is a little hefty on the implicitness I guess",
        "createdAt" : "2020-04-03T20:14:33Z",
        "updatedAt" : "2020-05-09T10:54:51Z",
        "lastEditedBy" : "5e8c5ef2-940b-436e-9c5f-98ae5460128c",
        "tags" : [
        ]
      },
      {
        "id" : "256e011b-90dc-4739-a827-615fdd720385",
        "parentId" : "8265d08d-e95a-46cf-a3ab-aceb2814f757",
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "So the subclasses IntegerArray and BooleanArray have a correctly typed `dtype` property. But this method above is defined in their parent class ..\r\n\r\nIn principle I could add a `dtype` property\r\n\r\n```\r\n@property\r\ndef dtype(self) -> Union[\"IntegerDtype\", \"BooleanDtype\"]:\r\n    pass\r\n ```\r\n\r\nin the BaseMaskedArray class to solve this, I suppose? \r\nBut that is also kind of ugly, as the parent class shouldn't really know about its subclasses ..\r\n\r\n",
        "createdAt" : "2020-04-03T20:27:17Z",
        "updatedAt" : "2020-05-09T10:54:51Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      },
      {
        "id" : "37869774-51e0-4ed4-8465-5eb373c68ea4",
        "parentId" : "8265d08d-e95a-46cf-a3ab-aceb2814f757",
        "authorId" : "5e8c5ef2-940b-436e-9c5f-98ae5460128c",
        "body" : "Right; I think it's going to be tough to make this work with mypy if we implicitly enforce that subclasses make `dtype.numpy_dtype` available\r\n\r\nWhat does the comment directly preceding it refer to? Perhaps there is a way to do this without breaking the currently implied subclass requirements?",
        "createdAt" : "2020-04-03T20:31:15Z",
        "updatedAt" : "2020-05-09T10:54:51Z",
        "lastEditedBy" : "5e8c5ef2-940b-436e-9c5f-98ae5460128c",
        "tags" : [
        ]
      },
      {
        "id" : "23af2a4f-8826-4e8b-bfe1-a9946848d121",
        "parentId" : "8265d08d-e95a-46cf-a3ab-aceb2814f757",
        "authorId" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "body" : "Can you override the type signature of IntegerArray.dtype to be `IntegerDtype` and BolleanArray.dtype to be BooleanDtype?",
        "createdAt" : "2020-04-03T20:34:39Z",
        "updatedAt" : "2020-05-09T10:54:51Z",
        "lastEditedBy" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "tags" : [
        ]
      },
      {
        "id" : "eef1e435-51b4-4b4f-beba-2b2c2a779edb",
        "parentId" : "8265d08d-e95a-46cf-a3ab-aceb2814f757",
        "authorId" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "body" : "Oh that's already the case... How about a `MaskedArrayDtype` that subclasses ExtensionDtype but has a `numpy_dtype` property?\r\n\r\nand then BooleanDtype and IntegerDtype inherit from that rather than ExtensionDtype.",
        "createdAt" : "2020-04-03T20:36:07Z",
        "updatedAt" : "2020-05-09T10:54:51Z",
        "lastEditedBy" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "tags" : [
        ]
      },
      {
        "id" : "89771669-896b-44e5-a1c3-a94b5c309ee4",
        "parentId" : "8265d08d-e95a-46cf-a3ab-aceb2814f757",
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "Is there a way to just disable mypy on this line?\r\n\r\n> What does the comment directly preceding it refer to? Perhaps there is a way to do this without breaking the currently implied subclass requirements?\r\n\r\nThe hashtable is only implemented for int64. So if you have an int32 array, the unique values coming out of `_factorize_array` are int64, and need to be casted back to int32 (as the uniques returned from this method should be using the original dtype). So for this casting, I need to have access to the dtype's equivalent numpy dtype, which is avalaible as the `numpy_dtype` attribute. \r\n\r\nI could do this differently by eg building up a mapping of EADtypes -> numpy dtypes and looking it up from there instead of using the attribute, but that would just be introducing more complex workarounds to just to satisfy mypy. ",
        "createdAt" : "2020-04-03T20:38:30Z",
        "updatedAt" : "2020-05-09T10:54:51Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      },
      {
        "id" : "96cdc487-3f52-4f76-96af-6e0309a4ae87",
        "parentId" : "8265d08d-e95a-46cf-a3ab-aceb2814f757",
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "> How about a MaskedArrayDtype that subclasses ExtensionDtype but has a numpy_dtype property?\r\n\r\nYes, that's probably the cleanest solution architecturally",
        "createdAt" : "2020-04-03T20:39:33Z",
        "updatedAt" : "2020-05-09T10:54:51Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      },
      {
        "id" : "36a55349-92f2-4650-96a5-a239b42b2210",
        "parentId" : "8265d08d-e95a-46cf-a3ab-aceb2814f757",
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "> How about a MaskedArrayDtype that subclasses ExtensionDtype but has a numpy_dtype property?\r\n\r\nYes, that's probably the cleanest solution architecturally. \r\nBut the `dtype` attribute on BaseMaskedArray would still only be a dummy property just to provide typing, since it is overwritten in both subclasses.",
        "createdAt" : "2020-04-03T20:41:05Z",
        "updatedAt" : "2020-05-09T10:54:51Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      },
      {
        "id" : "939781d4-5002-4761-a650-805bdb3ca9d6",
        "parentId" : "8265d08d-e95a-46cf-a3ab-aceb2814f757",
        "authorId" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "body" : "> But the dtype attribute on BaseMaskedArray would still only be a dummy property just to provide typing\r\n\r\nI don't think you'll need to change anything on the array side. The dtypes will inherit from MaskedExtensionDtype, so mypy should know that `integer_array.dtype.numpy_type` is valid.\r\n\r\nOr we add `numpy_dtype` to the `ExtensionDtype` API :)",
        "createdAt" : "2020-04-03T20:56:45Z",
        "updatedAt" : "2020-05-09T10:54:51Z",
        "lastEditedBy" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "tags" : [
        ]
      },
      {
        "id" : "bebda484-4248-4083-83a9-08e5b57a8108",
        "parentId" : "8265d08d-e95a-46cf-a3ab-aceb2814f757",
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "> I don't think you'll need to change anything on the array side. The dtypes will inherit from MaskedExtensionDtype, so mypy should know that integer_array.dtype.numpy_type is valid.\r\n\r\nNo, since mypy thinks `self.dtype` is an ExtensionDtype, so having IntegerDtype/BooleanDtype inherit from a MaskedDtype that defines this attribute will no help.\r\n\r\nSo either we would indeed need to add `numpy_dtype` to the ExtensionDtype API, or I need to add a dummy `dtype` property on BaseMaskedArray to be able to type it as MaskedDtype.",
        "createdAt" : "2020-04-03T21:02:31Z",
        "updatedAt" : "2020-05-09T10:54:51Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      }
    ],
    "commit" : "1f7e99419bfddf060f6ffa4c70dc7a7607408026",
    "line" : 62,
    "diffHunk" : "@@ -1,1 +256,260 @@\n        # the hashtables don't handle all different types of bits\n        uniques = uniques.astype(self.dtype.numpy_dtype, copy=False)\n        uniques = type(self)(uniques, np.zeros(len(uniques), dtype=bool))\n        return codes, uniques"
  },
  {
    "id" : "b5ceb2e1-aa2f-4466-b15c-45a01653cf46",
    "prId" : 33064,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/33064#pullrequestreview-388824721",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bad80231-4c1c-4197-904c-02680077f7e6",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "is there a reason you want to call a private routine like this directly? shouldn't factorize just handle this directly? (isn't that the point of _values_for_factorize).",
        "createdAt" : "2020-04-05T20:26:44Z",
        "updatedAt" : "2020-05-09T10:54:51Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "34ee53bf-e361-414f-95ed-ec818b930b86",
        "parentId" : "bad80231-4c1c-4197-904c-02680077f7e6",
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "This is the way we also do it in the base EA `factorize` method. \r\nThe reason we are using this, and not `pd.factorize` directly, is because the public factorize does not support the additional `na_value` and `mask` keywords. \r\n\r\nThe point of `_values_for_factorize` is indeed to avoid that EA authors have to call this private `_factorize_array` method themselves (and to make it easier to implement `EA.factorize`), but here, I explicitly do not use the general `_values_for_factorize` path to be able to customize/optimize the `IntegerArray/BooleaArray.factorize()` method specifically for those dtypes.",
        "createdAt" : "2020-04-06T07:53:39Z",
        "updatedAt" : "2020-05-09T10:54:51Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      },
      {
        "id" : "033cdcba-26ec-429b-af74-8553ae4e9a1b",
        "parentId" : "bad80231-4c1c-4197-904c-02680077f7e6",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "this is really polluting the interface, I would much rather just add they keywords. It seems we are special casing EA to no end. This needs to stop.\r\n\r\n> The reason we are using this, and not pd.factorize directly, is because the public factorize does not support the additional na_value and mask keywords.",
        "createdAt" : "2020-04-06T22:21:35Z",
        "updatedAt" : "2020-05-09T10:54:51Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "b65fe32a-4e01-475b-b769-e7b8e53a2a29",
        "parentId" : "bad80231-4c1c-4197-904c-02680077f7e6",
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "Expanding the public interface of `factorize` is out of scope for this PR, IMO. The implementation I put here above is *exactly* how we already do it for 2 years (we *are already* using `_factorize_array` in our other EAs) . If you want to do a proposal to change this, please open an issue to discuss.",
        "createdAt" : "2020-04-07T06:43:57Z",
        "updatedAt" : "2020-05-09T10:54:51Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      }
    ],
    "commit" : "1f7e99419bfddf060f6ffa4c70dc7a7607408026",
    "line" : 59,
    "diffHunk" : "@@ -1,1 +253,257 @@        mask = self._mask\n\n        codes, uniques = _factorize_array(arr, na_sentinel=na_sentinel, mask=mask)\n\n        # the hashtables don't handle all different types of bits"
  },
  {
    "id" : "51931bad-d37a-4a47-b5c8-e2d07565396a",
    "prId" : 34187,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/34187#pullrequestreview-415025761",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7e87598f-b345-41d7-ba08-c9c9ea3abf61",
        "parentId" : null,
        "authorId" : "5e8c5ef2-940b-436e-9c5f-98ae5460128c",
        "body" : "orthogranal to this PR but wondering if we even need this any more or could just use abc.abstractmethod decorator",
        "createdAt" : "2020-05-20T03:31:01Z",
        "updatedAt" : "2020-05-20T03:32:09Z",
        "lastEditedBy" : "5e8c5ef2-940b-436e-9c5f-98ae5460128c",
        "tags" : [
        ]
      },
      {
        "id" : "e3a112eb-0145-4381-a0f8-a9a047f0cc05",
        "parentId" : "7e87598f-b345-41d7-ba08-c9c9ea3abf61",
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "We generally use this instead of the decorator in the EA base class, because the decorator requires it to actually be an abstract base class. \r\n\r\nSee \r\n\r\nhttps://github.com/pandas-dev/pandas/blob/45fee3278680e8da2724236cc93227bcb28585b1/pandas/core/arrays/base.py#L128-L131",
        "createdAt" : "2020-05-20T06:27:35Z",
        "updatedAt" : "2020-05-20T06:27:35Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      }
    ],
    "commit" : "2590dc7669fcf855386bfd0f71f4e1131ef1d33e",
    "line" : 24,
    "diffHunk" : "@@ -1,1 +86,90 @@\n    def _coerce_to_array(self, values) -> Tuple[np.ndarray, np.ndarray]:\n        raise AbstractMethodError(self)\n\n    def __setitem__(self, key, value) -> None:"
  },
  {
    "id" : "877444ba-6370-4f15-93a3-99b7374ba8ca",
    "prId" : 34187,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/34187#pullrequestreview-416170974",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "45a12456-68d5-48c4-aaac-0c8a7bf21cad",
        "parentId" : null,
        "authorId" : "554ba0f6-6e6a-40c3-98e0-1a6cc4a8e1c6",
        "body" : "as a follow up, should this be self.dtype.na_value instead of hardcoded in the base class. ",
        "createdAt" : "2020-05-21T09:25:52Z",
        "updatedAt" : "2020-05-21T09:25:52Z",
        "lastEditedBy" : "554ba0f6-6e6a-40c3-98e0-1a6cc4a8e1c6",
        "tags" : [
        ]
      },
      {
        "id" : "4ad90e92-33c5-468d-be88-381c05989713",
        "parentId" : "45a12456-68d5-48c4-aaac-0c8a7bf21cad",
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "I personally like having it explicit as well (all subclasses use `NA` as missing value indicator, this method is not shared with ones where `dtype.na_value` is something different), but can go either way",
        "createdAt" : "2020-05-21T13:37:26Z",
        "updatedAt" : "2020-05-21T13:37:26Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      },
      {
        "id" : "cf3ad732-5ed9-4e14-a4b4-aff8e0557f8c",
        "parentId" : "45a12456-68d5-48c4-aaac-0c8a7bf21cad",
        "authorId" : "554ba0f6-6e6a-40c3-98e0-1a6cc4a8e1c6",
        "body" : "hmm,\r\n\r\nwe have \r\n```\r\n    @property\r\n    def _na_value(self):\r\n        return self.dtype.na_value\r\n```\r\n\r\nso this is not consistent. ",
        "createdAt" : "2020-05-21T13:47:15Z",
        "updatedAt" : "2020-05-21T13:47:15Z",
        "lastEditedBy" : "554ba0f6-6e6a-40c3-98e0-1a6cc4a8e1c6",
        "tags" : [
        ]
      },
      {
        "id" : "236b7c61-e38e-404c-a63a-f5b8b9998fb3",
        "parentId" : "45a12456-68d5-48c4-aaac-0c8a7bf21cad",
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "We could also remove that property, from a quick search, that is only used once in the arrays code",
        "createdAt" : "2020-05-21T13:57:52Z",
        "updatedAt" : "2020-05-21T13:57:53Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      },
      {
        "id" : "4af13b9a-0f33-427f-bee9-e8c887b1a3da",
        "parentId" : "45a12456-68d5-48c4-aaac-0c8a7bf21cad",
        "authorId" : "554ba0f6-6e6a-40c3-98e0-1a6cc4a8e1c6",
        "body" : "I agree, if not generally on an array class, I think self.dtype.na_value is generally clearer.\r\n\r\nThis is not the only case where libmissing.NA is used, so we should use one ore the other. I accept your argument about being explicit but also prefer the the case of allowing the class to be extensible. YAGNI favours your proposal.",
        "createdAt" : "2020-05-21T14:02:29Z",
        "updatedAt" : "2020-05-21T14:02:29Z",
        "lastEditedBy" : "554ba0f6-6e6a-40c3-98e0-1a6cc4a8e1c6",
        "tags" : [
        ]
      }
    ],
    "commit" : "2590dc7669fcf855386bfd0f71f4e1131ef1d33e",
    "line" : 65,
    "diffHunk" : "@@ -1,1 +348,352 @@\n        if np.isnan(result):\n            return libmissing.NA\n\n        return result"
  }
]
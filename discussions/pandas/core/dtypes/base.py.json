[
  {
    "id" : "bfbf1b1a-3fb4-4950-b407-b5c9bfc0449d",
    "prId" : 19268,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/19268#pullrequestreview-93130434",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d4a11dea-07d3-4b3e-81b9-33f687fe9225",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "add an example here (or maybe more expl)",
        "createdAt" : "2018-02-01T00:13:19Z",
        "updatedAt" : "2018-02-01T20:55:34Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "34134f2f9633cca26b4efd382475927c1eb3fe5a",
    "line" : 63,
    "diffHunk" : "@@ -1,1 +61,65 @@    @property\n    def names(self):\n        # type: () -> Optional[List[str]]\n        \"\"\"Ordered list of field names, or None if there are no fields.\n"
  },
  {
    "id" : "0923cb0a-4ad4-4f50-898b-bd56cf522d0a",
    "prId" : 21185,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/21185#pullrequestreview-125490428",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a37a6b32-b70d-48b0-a37f-3204310ee0db",
        "parentId" : null,
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "I would give some additional explanation of what the Registry is, because now this is not explained here?",
        "createdAt" : "2018-06-04T10:17:31Z",
        "updatedAt" : "2018-07-02T23:20:38Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      }
    ],
    "commit" : "d2c91d706510b16a8a9f82dbeafa7d35396697d1",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +111,115 @@\n    Optionally one can override construct_array_type for construction\n    with the name of this dtype via the Registry\n\n    * construct_array_type"
  },
  {
    "id" : "e2330aa8-358d-49bf-b6f4-4ac8521df919",
    "prId" : 22996,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/22996#pullrequestreview-161810929",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4c037242-e2ce-4f59-89fa-b0688dff5560",
        "parentId" : null,
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "shouldn't this contain something more than only the attributes? \r\nBecause this would mean that two classes with the same attributes can give the same hash? (eg a fictional DatetimeDtype and PeriodDtype in case both have a `freq` (and only a freq))\r\n\r\nAlso, the consequence is that each attribute needs to be hashable, and eg cannot be a list?\r\n",
        "createdAt" : "2018-10-04T20:57:04Z",
        "updatedAt" : "2018-10-04T21:44:35Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      },
      {
        "id" : "faf47b26-4e2a-4e98-ab91-e56ea3849f9b",
        "parentId" : "4c037242-e2ce-4f59-89fa-b0688dff5560",
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "> Also, the consequence is that each attribute needs to be hashable, and eg cannot be a list?\r\n\r\nAh, I see your note about that in the docs",
        "createdAt" : "2018-10-04T20:58:57Z",
        "updatedAt" : "2018-10-04T21:44:35Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      },
      {
        "id" : "72d8a45f-636b-49d7-88dd-8de6ced53b9b",
        "parentId" : "4c037242-e2ce-4f59-89fa-b0688dff5560",
        "authorId" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "body" : "> Because this would mean that two classes with the same attributes can give the same hash? \r\n\r\nYes, but I don't think that's a problem in practice. As I understand it, python expects that if two classes are equal, then they have the same hash. The reverse is not true. I *think* it's OK for two objects to have the same hash, but not be equal.\r\n\r\n\r\nWith the following\r\n\r\n\r\n```python\r\nclass A(ExtensionDtype):\r\n    _freq = ('foo',)\r\n    name = \"A\"\r\n    def __init__(self, foo):\r\n        self.foo = foo\r\n\r\n\r\nclass B(ExtensionDtype):\r\n    _freq = ('foo',)\r\n    name = 'B'\r\n\r\n    def __init__(self, foo):\r\n        self.foo = foo\r\n```\r\n\r\n\r\nWe get\r\n\r\n```python\r\nIn [2]: a = A('foo')\r\n\r\nIn [3]: b = B('foo')\r\n\r\nIn [4]: hash(a) == hash(b)\r\nOut[4]: True\r\n\r\nIn [5]: d = {a: 'a', b: 'b'}\r\n\r\nIn [6]: d\r\nOut[6]:\r\n{<pandas.core.dtypes.dtypes.A at 0x11e824080>: 'a',\r\n <pandas.core.dtypes.dtypes.B at 0x11e80a828>: 'b'}\r\n\r\nIn [7]: d[a]\r\nOut[7]: 'a'\r\n\r\nIn [8]: len({a, b})\r\nOut[8]: 2\r\n```\r\n\r\n\r\n> Also, the consequence is that each attribute needs to be hashable, and eg cannot be a list?\r\n\r\nYes, that's correct. I think that's OK. If people have non-hashable things that characterize their class, they'll need to implement their own `__hash__`",
        "createdAt" : "2018-10-04T21:07:53Z",
        "updatedAt" : "2018-10-04T21:44:35Z",
        "lastEditedBy" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "tags" : [
        ]
      }
    ],
    "commit" : "b7242f64a7f91ef9a0f81bdf050cb2998123ed47",
    "line" : 41,
    "diffHunk" : "@@ -1,1 +56,60 @@\n    def __hash__(self):\n        return hash(tuple(getattr(self, attr) for attr in self._metadata))\n\n    def __ne__(self, other):"
  },
  {
    "id" : "6404279e-e715-4f17-9f2b-1fb1286a253a",
    "prId" : 29503,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/29503#pullrequestreview-314584068",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b1905f69-7ce6-47c5-9152-f1f1924e9fb9",
        "parentId" : null,
        "authorId" : "554ba0f6-6e6a-40c3-98e0-1a6cc4a8e1c6",
        "body" : "if changing .format could now use f-strings?",
        "createdAt" : "2019-11-09T11:04:51Z",
        "updatedAt" : "2019-11-11T15:20:59Z",
        "lastEditedBy" : "554ba0f6-6e6a-40c3-98e0-1a6cc4a8e1c6",
        "tags" : [
        ]
      },
      {
        "id" : "7fc44160-51d7-49a1-85fc-8d6be4b071d7",
        "parentId" : "b1905f69-7ce6-47c5-9152-f1f1924e9fb9",
        "authorId" : "adf621f1-4745-479a-a1fc-dc14046a3f4b",
        "body" : "oh golly, im still tracking down %-based usage",
        "createdAt" : "2019-11-09T15:21:22Z",
        "updatedAt" : "2019-11-11T15:20:59Z",
        "lastEditedBy" : "adf621f1-4745-479a-a1fc-dc14046a3f4b",
        "tags" : [
        ]
      },
      {
        "id" : "7e263648-3f51-4321-9bdd-94160624410c",
        "parentId" : "b1905f69-7ce6-47c5-9152-f1f1924e9fb9",
        "authorId" : "ebd948a0-48ff-4dbe-a0c8-476953d697fa",
        "body" : "I've had a go at upgrading some of our % usage - hopefully there isn't too much more!\r\n\r\nhttps://github.com/pandas-dev/pandas/pull/29518/files",
        "createdAt" : "2019-11-10T00:35:22Z",
        "updatedAt" : "2019-11-11T15:20:59Z",
        "lastEditedBy" : "ebd948a0-48ff-4dbe-a0c8-476953d697fa",
        "tags" : [
        ]
      }
    ],
    "commit" : "35fe7cabc79c857dacbe9771f64f87beb6ed6b3f",
    "line" : 34,
    "diffHunk" : "@@ -1,1 +236,240 @@        \"\"\"\n        if not isinstance(string, str):\n            raise TypeError(\"Expects a string, got {typ}\".format(typ=type(string)))\n        if string != cls.name:\n            raise TypeError("
  },
  {
    "id" : "92b45db3-2915-4b0e-9f92-4d5e7bf656af",
    "prId" : 29503,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/29503#pullrequestreview-314553000",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "dddf3845-e285-4cfa-875e-71aa657f9f18",
        "parentId" : null,
        "authorId" : "554ba0f6-6e6a-40c3-98e0-1a6cc4a8e1c6",
        "body" : "same",
        "createdAt" : "2019-11-09T11:05:13Z",
        "updatedAt" : "2019-11-11T15:20:59Z",
        "lastEditedBy" : "554ba0f6-6e6a-40c3-98e0-1a6cc4a8e1c6",
        "tags" : [
        ]
      }
    ],
    "commit" : "35fe7cabc79c857dacbe9771f64f87beb6ed6b3f",
    "line" : 38,
    "diffHunk" : "@@ -1,1 +239,243 @@        if string != cls.name:\n            raise TypeError(\n                \"Cannot construct a '{cls}' from '{string}'\".format(\n                    cls=cls.__name__, string=string\n                )"
  },
  {
    "id" : "6ef7dc1f-5265-452b-a533-3c6166ae465f",
    "prId" : 30571,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/30571#pullrequestreview-337362128",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "59d871e5-8943-494f-affa-79049cdd34fa",
        "parentId" : null,
        "authorId" : "adf621f1-4745-479a-a1fc-dc14046a3f4b",
        "body" : "is it still possible to get a TypeError here?  if so, should it be?",
        "createdAt" : "2019-12-31T03:05:51Z",
        "updatedAt" : "2019-12-31T03:05:51Z",
        "lastEditedBy" : "adf621f1-4745-479a-a1fc-dc14046a3f4b",
        "tags" : [
        ]
      },
      {
        "id" : "d477a98f-064b-4d42-adca-d7dc6b5e7be9",
        "parentId" : "59d871e5-8943-494f-affa-79049cdd34fa",
        "authorId" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "body" : "I think so. A 3rd-party EA may have overridden `construct_from_string`, and we document that it should raise a TypeError if you can't construct it from that string.",
        "createdAt" : "2019-12-31T12:05:28Z",
        "updatedAt" : "2019-12-31T12:05:28Z",
        "lastEditedBy" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "tags" : [
        ]
      }
    ],
    "commit" : "2ed1745f8319c545cfb2b2649960308a8a7c2f87",
    "line" : 12,
    "diffHunk" : "@@ -1,1 +281,285 @@                return cls.construct_from_string(dtype) is not None\n            except TypeError:\n                return False\n        return False\n"
  },
  {
    "id" : "e6e0d94d-98c7-42c1-943b-1254fe58265a",
    "prId" : 30619,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/30619#pullrequestreview-337755362",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8984178a-65cb-4885-b258-146b51a45732",
        "parentId" : null,
        "authorId" : "554ba0f6-6e6a-40c3-98e0-1a6cc4a8e1c6",
        "body" : "assertion needed for mypy.\r\n\r\nbase class uses `@property` for abstract class attribute `name`, however, PeriodDType and DatetimeTZDtype do not override this with class attribute for name, but instead create a name using instance properties. These ExtensionDtype subclass cannot use this method and must override it.",
        "createdAt" : "2020-01-02T15:57:19Z",
        "updatedAt" : "2020-01-02T16:11:33Z",
        "lastEditedBy" : "554ba0f6-6e6a-40c3-98e0-1a6cc4a8e1c6",
        "tags" : [
        ]
      },
      {
        "id" : "9ba8eb9d-3a4d-4ec1-bddf-70bbfcd7867d",
        "parentId" : "8984178a-65cb-4885-b258-146b51a45732",
        "authorId" : "5e8c5ef2-940b-436e-9c5f-98ae5460128c",
        "body" : "Is the second expression supposed to be `isinstance` as well?",
        "createdAt" : "2020-01-02T16:45:51Z",
        "updatedAt" : "2020-01-02T16:46:52Z",
        "lastEditedBy" : "5e8c5ef2-940b-436e-9c5f-98ae5460128c",
        "tags" : [
        ]
      },
      {
        "id" : "3245069d-80f4-44a0-9f6b-88ba8ca14068",
        "parentId" : "8984178a-65cb-4885-b258-146b51a45732",
        "authorId" : "554ba0f6-6e6a-40c3-98e0-1a6cc4a8e1c6",
        "body" : "On master BooleanDtype.construct_from_string and StringDtype.construct_from_string both call super. `string != cls.name` is always True since cls.name is a property object. without the changes here would need an ignore.\r\n\r\n\r\n> Is the second expression\r\n\r\ni assume you mean `(cls, type(cls.name))`. that's the error message to identify the classes that call this method when cls.name is not a string",
        "createdAt" : "2020-01-02T17:01:13Z",
        "updatedAt" : "2020-01-02T17:01:13Z",
        "lastEditedBy" : "554ba0f6-6e6a-40c3-98e0-1a6cc4a8e1c6",
        "tags" : [
        ]
      }
    ],
    "commit" : "264256e1d61ddd9fc9309388b821a60450af2b5e",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +240,244 @@        # error: Non-overlapping equality check (left operand type: \"str\", right\n        #  operand type: \"Callable[[ExtensionDtype], str]\")  [comparison-overlap]\n        assert isinstance(cls.name, str), (cls, type(cls.name))\n        if string != cls.name:\n            raise TypeError(f\"Cannot construct a '{cls.__name__}' from '{string}'\")"
  },
  {
    "id" : "bfa1c1bf-6497-46f8-a6a9-f91b31e3938f",
    "prId" : 30619,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/30619#pullrequestreview-338002452",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "13bcf074-456c-40ac-afcb-9a64c32743b8",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "can this use the self._ensure_type ?",
        "createdAt" : "2020-01-03T01:22:37Z",
        "updatedAt" : "2020-01-03T01:23:31Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "8c727c5f-5b31-4a5e-86fd-ceceef0c0553",
        "parentId" : "13bcf074-456c-40ac-afcb-9a64c32743b8",
        "authorId" : "554ba0f6-6e6a-40c3-98e0-1a6cc4a8e1c6",
        "body" : "i don't think that's applicable here.\r\n\r\nthe assert is to avoid an ignore on the following line (the comparison).\r\n\r\nthe comparison would still fail strict_equality even if all subclasses override this method/override name attribute. This is because the type checker is checking this method using the name attribute in the base class. i.e. checking the base class isolation.\r\n\r\nI think this is related to \"Python language's lack of notation for abstract class attributes\" see https://github.com/python/mypy/issues/7760\r\n\r\nso without the assert an ignore would be required here.\r\n\r\nHowever, the assert prevents creating subclasses that call this method when not using a class attribute for name. \r\n\r\nThis could instead be enforced by mypy instead of the assert and i believe the implementation of name in the base class should be...\r\n```diff\r\ndiff --git a/pandas/core/dtypes/base.py b/pandas/core/dtypes/base.py\r\nindex 1b4e7062b..5235aac91 100644\r\n--- a/pandas/core/dtypes/base.py\r\n+++ b/pandas/core/dtypes/base.py\r\n@@ -1,6 +1,6 @@\r\n \"\"\"Extend pandas with custom array types\"\"\"\r\n from typing import Any, List, Optional, Tuple, Type\r\n-\r\n+import abc\r\n import numpy as np\r\n \r\n from pandas.errors import AbstractMethodError\r\n@@ -8,7 +8,7 @@ from pandas.errors import AbstractMethodError\r\n from pandas.core.dtypes.generic import ABCDataFrame, ABCIndexClass, ABCSeries\r\n \r\n \r\n-class ExtensionDtype:\r\n+class ExtensionDtype(metaclass=abc.ABCMeta):\r\n     \"\"\"\r\n     A custom data type, to be paired with an ExtensionArray.\r\n \r\n@@ -162,13 +162,15 @@ class ExtensionDtype:\r\n         return \"O\"\r\n \r\n     @property\r\n-    def name(self) -> str:\r\n+    @classmethod\r\n+    @abc.abstractmethod\r\n+    def name(cls) -> str:\r\n         \"\"\"\r\n         A string identifying the data type.\r\n \r\n         Will be used for display in, e.g. ``Series.dtype``\r\n         \"\"\"\r\n-        raise AbstractMethodError(self)\r\n+        pass\r\n \r\n     @property\r\n     def names(self) -> Optional[List[str]]:\r\n``` \r\n\r\nHowever, mypy would give the following errors...\r\n\r\npandas\\core\\dtypes\\base.py:241: error: Non-overlapping equality check (left operand type: \"str\", right operand type: \"Callable[[], str]\")\r\npandas\\core\\dtypes\\dtypes.py:754: error: Signature of \"name\" incompatible with supertype \"ExtensionDtype\"\r\npandas\\core\\dtypes\\dtypes.py:895: error: Signature of \"name\" incompatible with supertype \"ExtensionDtype\"\r\npandas\\tests\\extension\\test_common.py:44: error: Cannot instantiate abstract class 'DummyDtype' with abstract attribute 'name'\r\n\r\nthe first is due to https://github.com/python/mypy/issues/7760, the next two are because PeriodDType.name and DatetimeTZDtype.name are not implemented using class attributes",
        "createdAt" : "2020-01-03T09:34:02Z",
        "updatedAt" : "2020-01-03T09:34:03Z",
        "lastEditedBy" : "554ba0f6-6e6a-40c3-98e0-1a6cc4a8e1c6",
        "tags" : [
        ]
      }
    ],
    "commit" : "264256e1d61ddd9fc9309388b821a60450af2b5e",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +239,243 @@\n        # error: Non-overlapping equality check (left operand type: \"str\", right\n        #  operand type: \"Callable[[ExtensionDtype], str]\")  [comparison-overlap]\n        assert isinstance(cls.name, str), (cls, type(cls.name))\n        if string != cls.name:"
  }
]
[
  {
    "id" : "bfbf1b1a-3fb4-4950-b407-b5c9bfc0449d",
    "prId" : 19268,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/19268#pullrequestreview-93130434",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d4a11dea-07d3-4b3e-81b9-33f687fe9225",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "add an example here (or maybe more expl)",
        "createdAt" : "2018-02-01T00:13:19Z",
        "updatedAt" : "2018-02-01T20:55:34Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "34134f2f9633cca26b4efd382475927c1eb3fe5a",
    "line" : 63,
    "diffHunk" : "@@ -1,1 +61,65 @@    @property\n    def names(self):\n        # type: () -> Optional[List[str]]\n        \"\"\"Ordered list of field names, or None if there are no fields.\n"
  },
  {
    "id" : "0923cb0a-4ad4-4f50-898b-bd56cf522d0a",
    "prId" : 21185,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/21185#pullrequestreview-125490428",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a37a6b32-b70d-48b0-a37f-3204310ee0db",
        "parentId" : null,
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "I would give some additional explanation of what the Registry is, because now this is not explained here?",
        "createdAt" : "2018-06-04T10:17:31Z",
        "updatedAt" : "2018-07-02T23:20:38Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      }
    ],
    "commit" : "d2c91d706510b16a8a9f82dbeafa7d35396697d1",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +111,115 @@\n    Optionally one can override construct_array_type for construction\n    with the name of this dtype via the Registry\n\n    * construct_array_type"
  },
  {
    "id" : "e2330aa8-358d-49bf-b6f4-4ac8521df919",
    "prId" : 22996,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/22996#pullrequestreview-161810929",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4c037242-e2ce-4f59-89fa-b0688dff5560",
        "parentId" : null,
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "shouldn't this contain something more than only the attributes? \r\nBecause this would mean that two classes with the same attributes can give the same hash? (eg a fictional DatetimeDtype and PeriodDtype in case both have a `freq` (and only a freq))\r\n\r\nAlso, the consequence is that each attribute needs to be hashable, and eg cannot be a list?\r\n",
        "createdAt" : "2018-10-04T20:57:04Z",
        "updatedAt" : "2018-10-04T21:44:35Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      },
      {
        "id" : "faf47b26-4e2a-4e98-ab91-e56ea3849f9b",
        "parentId" : "4c037242-e2ce-4f59-89fa-b0688dff5560",
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "> Also, the consequence is that each attribute needs to be hashable, and eg cannot be a list?\r\n\r\nAh, I see your note about that in the docs",
        "createdAt" : "2018-10-04T20:58:57Z",
        "updatedAt" : "2018-10-04T21:44:35Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      },
      {
        "id" : "72d8a45f-636b-49d7-88dd-8de6ced53b9b",
        "parentId" : "4c037242-e2ce-4f59-89fa-b0688dff5560",
        "authorId" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "body" : "> Because this would mean that two classes with the same attributes can give the same hash? \r\n\r\nYes, but I don't think that's a problem in practice. As I understand it, python expects that if two classes are equal, then they have the same hash. The reverse is not true. I *think* it's OK for two objects to have the same hash, but not be equal.\r\n\r\n\r\nWith the following\r\n\r\n\r\n```python\r\nclass A(ExtensionDtype):\r\n    _freq = ('foo',)\r\n    name = \"A\"\r\n    def __init__(self, foo):\r\n        self.foo = foo\r\n\r\n\r\nclass B(ExtensionDtype):\r\n    _freq = ('foo',)\r\n    name = 'B'\r\n\r\n    def __init__(self, foo):\r\n        self.foo = foo\r\n```\r\n\r\n\r\nWe get\r\n\r\n```python\r\nIn [2]: a = A('foo')\r\n\r\nIn [3]: b = B('foo')\r\n\r\nIn [4]: hash(a) == hash(b)\r\nOut[4]: True\r\n\r\nIn [5]: d = {a: 'a', b: 'b'}\r\n\r\nIn [6]: d\r\nOut[6]:\r\n{<pandas.core.dtypes.dtypes.A at 0x11e824080>: 'a',\r\n <pandas.core.dtypes.dtypes.B at 0x11e80a828>: 'b'}\r\n\r\nIn [7]: d[a]\r\nOut[7]: 'a'\r\n\r\nIn [8]: len({a, b})\r\nOut[8]: 2\r\n```\r\n\r\n\r\n> Also, the consequence is that each attribute needs to be hashable, and eg cannot be a list?\r\n\r\nYes, that's correct. I think that's OK. If people have non-hashable things that characterize their class, they'll need to implement their own `__hash__`",
        "createdAt" : "2018-10-04T21:07:53Z",
        "updatedAt" : "2018-10-04T21:44:35Z",
        "lastEditedBy" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "tags" : [
        ]
      }
    ],
    "commit" : "b7242f64a7f91ef9a0f81bdf050cb2998123ed47",
    "line" : 41,
    "diffHunk" : "@@ -1,1 +56,60 @@\n    def __hash__(self):\n        return hash(tuple(getattr(self, attr) for attr in self._metadata))\n\n    def __ne__(self, other):"
  }
]
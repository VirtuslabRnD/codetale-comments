[
  {
    "id" : "ab266977-bba0-4295-8510-f6b3af91bab9",
    "prId" : 16236,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/16236#pullrequestreview-57472458",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "41d2373e-5ef5-4ea8-a74d-7fc7ece750e6",
        "parentId" : null,
        "authorId" : "69a015bc-2b58-45dd-83cb-2c2f6d80b128",
        "body" : "This is ugly... but the only alternative I see (an import inside the function) is uglier.",
        "createdAt" : "2017-08-10T14:43:33Z",
        "updatedAt" : "2017-08-21T15:24:01Z",
        "lastEditedBy" : "69a015bc-2b58-45dd-83cb-2c2f6d80b128",
        "tags" : [
        ]
      },
      {
        "id" : "d67fe9fc-5340-42d2-a11d-f150d4467f6a",
        "parentId" : "41d2373e-5ef5-4ea8-a74d-7fc7ece750e6",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "its ok here",
        "createdAt" : "2017-08-16T10:13:31Z",
        "updatedAt" : "2017-08-21T15:24:01Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "d817689b-4b0f-4b00-9031-648dcb6d849c",
        "parentId" : "41d2373e-5ef5-4ea8-a74d-7fc7ece750e6",
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "~~One alternative would be is to return the (start, stop, step) and do the construction in `RangeIndex._append_same_dtype` (then also the rename there is not needed)~~\r\n\r\nAh no, this wouldn't play nice with the case when no range index is returned, ignore this",
        "createdAt" : "2017-08-21T11:37:08Z",
        "updatedAt" : "2017-08-21T15:24:01Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      }
    ],
    "commit" : "554ee79709cbb5fdd3e8ef8e3e6553e6fa499cf9",
    "line" : 65,
    "diffHunk" : "@@ -1,1 +605,609 @@        step = obj._step\n    stop = obj._stop if next is None else next\n    return indexes[0].__class__(start, stop, step)"
  },
  {
    "id" : "4ada9338-d643-44e2-850b-7a714d6f9cff",
    "prId" : 16236,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/16236#pullrequestreview-57697491",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ed8c5cf0-ed3d-42bf-a2e9-80a5321b014a",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "can you explain this",
        "createdAt" : "2017-08-21T23:57:42Z",
        "updatedAt" : "2017-08-21T23:57:42Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "6f48c551-3940-4883-8865-41b3413c8539",
        "parentId" : "ed8c5cf0-ed3d-42bf-a2e9-80a5321b014a",
        "authorId" : "69a015bc-2b58-45dd-83cb-2c2f6d80b128",
        "body" : "See #17307",
        "createdAt" : "2017-08-22T07:50:36Z",
        "updatedAt" : "2017-08-22T07:50:36Z",
        "lastEditedBy" : "69a015bc-2b58-45dd-83cb-2c2f6d80b128",
        "tags" : [
        ]
      },
      {
        "id" : "5dca5242-9510-4467-b21c-9b14c674f467",
        "parentId" : "ed8c5cf0-ed3d-42bf-a2e9-80a5321b014a",
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "Merged this, you can update this line in the other PR if we merge that",
        "createdAt" : "2017-08-22T08:11:35Z",
        "updatedAt" : "2017-08-22T08:11:35Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      }
    ],
    "commit" : "554ee79709cbb5fdd3e8ef8e3e6553e6fa499cf9",
    "line" : 53,
    "diffHunk" : "@@ -1,1 +593,597 @@                           (next is not None and obj._start != next))\n        if non_consecutive:\n            # Int64Index._append_same_dtype([ix.astype(int) for ix in indexes])\n            # would be preferred... but it currently resorts to\n            # _concat_index_asobject anyway."
  },
  {
    "id" : "fe7a3720-b90e-44ad-8692-faed7a324e9a",
    "prId" : 16397,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/16397#pullrequestreview-39336976",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f9a48708-10d7-48b2-a6bb-955e4223e96e",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "@TomAugspurger @jorisvandenbossche do we quote like this in a doc-string?",
        "createdAt" : "2017-05-20T15:00:59Z",
        "updatedAt" : "2017-05-22T06:43:47Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "f8d12959-6146-46a2-ab98-f95140165f2b",
        "parentId" : "f9a48708-10d7-48b2-a6bb-955e4223e96e",
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "I think this is OK (I don't think we consistently follow strict guidelines, but the numpydoc docstring explanation says to use single backticks to refer the keyword arguments or functions)",
        "createdAt" : "2017-05-20T15:17:24Z",
        "updatedAt" : "2017-05-22T06:43:47Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      }
    ],
    "commit" : "925a1ce8d576ecefaaaef2595f14a343b6f99deb",
    "line" : 35,
    "diffHunk" : "@@ -1,1 +274,278 @@    Categories (3, object): [a, b, c]\n\n    `union_categoricals` also works with the case of combining two\n    categoricals of the same categories and order information (e.g. what\n    you could also `append` for)."
  },
  {
    "id" : "51cbc2a0-bd56-4ede-b91c-b49274da2041",
    "prId" : 16397,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/16397#pullrequestreview-39336976",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d09ecd7a-6424-4e29-98f7-2f52698ab803",
        "parentId" : null,
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "can you add a `from pandas.api.types import union_categorical`  at the beginning?",
        "createdAt" : "2017-05-20T15:10:05Z",
        "updatedAt" : "2017-05-22T06:43:47Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      }
    ],
    "commit" : "925a1ce8d576ecefaaaef2595f14a343b6f99deb",
    "line" : 21,
    "diffHunk" : "@@ -1,1 +260,264 @@    categories being combined.\n\n    >>> a = pd.Categorical([\"b\", \"c\"])\n    >>> b = pd.Categorical([\"a\", \"b\"])\n    >>> union_categoricals([a, b])"
  },
  {
    "id" : "6e1c37a1-2cdf-4f4b-94cc-c2e748ac71a7",
    "prId" : 19893,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/19893#pullrequestreview-99156036",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4b28b860-7105-4f63-9753-254f8e8aa89f",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "add a full doc-string",
        "createdAt" : "2018-02-25T21:03:37Z",
        "updatedAt" : "2018-02-26T14:55:16Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "e4ec9874071998b1d013af0ed31ffd33574ad549",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +103,107 @@\ndef _get_sliced_frame_result_type(data, obj):\n    \"\"\"\n    return appropriate class of Series. When data is sparse\n    it will return a SparseSeries, otherwise it will return"
  },
  {
    "id" : "0537766c-544e-427b-916e-12403b10bc25",
    "prId" : 19893,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/19893#pullrequestreview-99296664",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5547826c-24eb-4fb2-b9ba-e68f304602e1",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "from pandas import SparseSeries",
        "createdAt" : "2018-02-26T13:26:54Z",
        "updatedAt" : "2018-02-26T14:55:16Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "e4ec9874071998b1d013af0ed31ffd33574ad549",
    "line" : 20,
    "diffHunk" : "@@ -1,1 +118,122 @@    \"\"\"\n    if is_sparse(data):\n        from pandas.core.sparse.api import SparseSeries\n        return SparseSeries\n    return obj._constructor_sliced"
  },
  {
    "id" : "85894e16-fef7-4b20-9062-14b1cae8459b",
    "prId" : 20799,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/20799#pullrequestreview-114687655",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1d45faa8-a582-4897-b8e2-e38cbb9f0d3b",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "hmm this is not correct \r\n\r\nwhat about categorical? which is EA\r\nwhat about DTI which is not?\r\ndo they hit this path ?\r\n\r\nyou need much more comprehensive tests here\r\nI donâ€™t think you need to convert to object for internal EA types (only external ones)",
        "createdAt" : "2018-04-24T08:19:13Z",
        "updatedAt" : "2018-04-24T08:19:23Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "02477e48-fdb6-4e22-87b9-b7a4aff4dc47",
        "parentId" : "1d45faa8-a582-4897-b8e2-e38cbb9f0d3b",
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "both categorical and datetimes cases are already filtered out before (couple of lines above) and use the `_concat_categorical` and `_concat_datetime` special cased functions. So the only case that is left here are actual external EAs, for which the only option is converting to object.",
        "createdAt" : "2018-04-24T08:33:06Z",
        "updatedAt" : "2018-04-24T08:33:06Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      },
      {
        "id" : "e2598aef-0cc4-4953-8aa7-436fec06ee92",
        "parentId" : "1d45faa8-a582-4897-b8e2-e38cbb9f0d3b",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "ahh ok\r\n\r\nsome extra comments would be helpful\r\nalso test when u have those plus extension types in a frame would be nice\r\n ",
        "createdAt" : "2018-04-24T08:50:22Z",
        "updatedAt" : "2018-04-24T08:50:22Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "615399c037e529395db641bf325f5706eab9f94d",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +177,181 @@    extensions = [is_extension_array_dtype(x) for x in to_concat]\n    if any(extensions):\n        to_concat = [np.atleast_2d(x.astype('object')) for x in to_concat]\n\n    if not nonempty:"
  },
  {
    "id" : "adbae6e1-cfb3-4b8d-9617-70bd31bd2d68",
    "prId" : 20840,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/20840#pullrequestreview-116261484",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "19527cb5-7a9a-40a9-aa6c-68746e4a7e5f",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "I find this very strange that you need to add axis=1 here, I don't think this routine should be call at all if axis=1. This seems like it should be handled at a higher level",
        "createdAt" : "2018-04-28T13:47:12Z",
        "updatedAt" : "2018-04-28T13:47:21Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "fc7821d2-4ddb-4e82-b9ba-1114c3d29fb8",
        "parentId" : "19527cb5-7a9a-40a9-aa6c-68746e4a7e5f",
        "authorId" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "body" : ">  I find this very strange that you need to add axis=1 here, I don't think this routine should be call at all if axis=1\r\n\r\n`axis=1` is used all over `_concat_compat`.  Why do you think it's strange?\r\n\r\nFor the specific case from #20832 it is `axis=0`, but we don't want to reshape to 2d.",
        "createdAt" : "2018-04-28T20:03:33Z",
        "updatedAt" : "2018-04-28T20:03:33Z",
        "lastEditedBy" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "tags" : [
        ]
      },
      {
        "id" : "2d3b0f7c-ea39-409d-8d0d-0413ef3cbd93",
        "parentId" : "19527cb5-7a9a-40a9-aa6c-68746e4a7e5f",
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "Yes, the special casing non-consolidateble blocks with `axis=1` is indeed an existing pattern. \r\n\r\nFor categoricals:\r\n\r\nhttps://github.com/pandas-dev/pandas/blob/563a6ad108a79b0192a25d51d743812a18e21b15/pandas/core/dtypes/concat.py#L220-L221\r\n\r\nfor datetimetz:\r\n\r\nhttps://github.com/pandas-dev/pandas/blob/563a6ad108a79b0192a25d51d743812a18e21b15/pandas/core/dtypes/concat.py#L453-L454\r\n\r\nNote that this is all rather confusing, as `axis=1` in the \"concatting code\" actually means `axis=0` in user facing code (because we store the 1D data in 2D objects):\r\n\r\nhttps://github.com/pandas-dev/pandas/blob/563a6ad108a79b0192a25d51d743812a18e21b15/pandas/core/reshape/concat.py#L312-L315",
        "createdAt" : "2018-04-29T11:13:49Z",
        "updatedAt" : "2018-04-29T11:13:49Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      },
      {
        "id" : "cc8fc22d-92ec-4b8d-bc6a-c93decd77607",
        "parentId" : "19527cb5-7a9a-40a9-aa6c-68746e4a7e5f",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "right this should be changed to use ``_get_block_manager_axis`` FYI (but can be in future).\r\n",
        "createdAt" : "2018-04-29T21:05:32Z",
        "updatedAt" : "2018-04-29T21:05:32Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "1224f3f9-e6e9-4043-8c60-e4eba887c95e",
        "parentId" : "19527cb5-7a9a-40a9-aa6c-68746e4a7e5f",
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "> right this should be changed to use _get_block_manager_axis FYI (but can be in future).\r\n\r\nI don't think so, `_get_block_manager_axis` is for a full Series/DataFrame, the logic here is dtype-dependent\r\n\r\n",
        "createdAt" : "2018-04-30T07:30:39Z",
        "updatedAt" : "2018-04-30T07:30:39Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      },
      {
        "id" : "dcc484aa-9132-4617-adfc-fe0b0eb561c0",
        "parentId" : "19527cb5-7a9a-40a9-aa6c-68746e4a7e5f",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "what does your respsone have to do with my comment? this is exactly what _get_block_managed_axis does",
        "createdAt" : "2018-04-30T07:34:30Z",
        "updatedAt" : "2018-04-30T07:34:30Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "d587a8eb-7bc6-4a64-a8c6-4f72592a29ff",
        "parentId" : "19527cb5-7a9a-40a9-aa6c-68746e4a7e5f",
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "OK, my response was not very well phrased, but still, then you will have to explain your comment better :-) \r\n\r\nI understood your comment as: \"we should use `_get_block_manager_axis` here \", and AFAIK, `_get_block_manager_axis` lets you convert an axis of 0/1 to the appropriate number for blocks (so for DataFrame it switches 0 and 1). But here, I don't convert any `axis` argument, I reshape data depending on the `axis` value (and depending on the dtype). \r\nSo I don't fully understand where in the above code lines I would use ``_get_block_manager_axis``",
        "createdAt" : "2018-04-30T07:42:16Z",
        "updatedAt" : "2018-04-30T07:42:16Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      },
      {
        "id" : "1acfad0b-e5a0-4f63-988c-16ee0e30ecdb",
        "parentId" : "19527cb5-7a9a-40a9-aa6c-68746e4a7e5f",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "```\r\ndiff --git a/pandas/core/reshape/concat.py b/pandas/core/reshape/concat.py\r\nindex 6e564975f..6570e7a83 100644\r\n--- a/pandas/core/reshape/concat.py\r\n+++ b/pandas/core/reshape/concat.py\r\n@@ -312,7 +312,7 @@ class _Concatenator(object):\r\n         # Need to flip BlockManager axis in the DataFrame special case\r\n         self._is_frame = isinstance(sample, DataFrame)\r\n         if self._is_frame:\r\n-            axis = 1 if axis == 0 else 0\r\n+            axis = sample._get_block_manager_axis(axis)\r\n \r\n         self._is_series = isinstance(sample, Series)\r\n         if not 0 <= axis <= sample.ndim:\r\n```\r\n\r\nis a more correct usage, though prob doesn't simplify code much. this is spagetti anyhow.",
        "createdAt" : "2018-04-30T10:00:01Z",
        "updatedAt" : "2018-04-30T10:00:01Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "6444cdf8-90ae-42a4-ba26-85754307091e",
        "parentId" : "19527cb5-7a9a-40a9-aa6c-68746e4a7e5f",
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "> this is spagetti anyhow.\r\n\r\nOn that we certainly agree! :-)",
        "createdAt" : "2018-04-30T11:46:55Z",
        "updatedAt" : "2018-04-30T11:46:55Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      }
    ],
    "commit" : "964a5ffecf7e5df68ea951896ef809ffcd5b22c7",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +177,181 @@    extensions = [is_extension_array_dtype(x) for x in to_concat]\n    if any(extensions) and axis == 1:\n        to_concat = [np.atleast_2d(x.astype('object')) for x in to_concat]\n\n    if not nonempty:"
  },
  {
    "id" : "defa371a-8f58-4326-a193-5cd75015c21e",
    "prId" : 22325,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/22325#pullrequestreview-162594646",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d147f7a1-ec93-44bd-bb8c-28505d4b461d",
        "parentId" : null,
        "authorId" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "body" : "ATM, I only allow concatenating sparse arrays with the same fill value. It's not clear to me how we should handle sparse arrays with differing fill values, since by definition only one fill value can stay dense, the rest will have to become sparse.",
        "createdAt" : "2018-08-13T20:10:33Z",
        "updatedAt" : "2018-10-13T08:12:19Z",
        "lastEditedBy" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "tags" : [
        ]
      },
      {
        "id" : "d98a935b-4db4-4567-85fa-795b129baf98",
        "parentId" : "d147f7a1-ec93-44bd-bb8c-28505d4b461d",
        "authorId" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "body" : "When concating Series[sparse] with a mix of fill values, we issue a performance warning, pick the first `fill_value` and convert the rest to that fill_value.",
        "createdAt" : "2018-10-08T18:42:19Z",
        "updatedAt" : "2018-10-13T08:12:20Z",
        "lastEditedBy" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "tags" : [
        ]
      }
    ],
    "commit" : "4aad8e1976bcbfb694d3591a5f9143ab7316f5bd",
    "line" : 21,
    "diffHunk" : "@@ -1,1 +557,561 @@    \"\"\"\n\n    from pandas.core.sparse.array import SparseArray\n\n    fill_values = [x.fill_value for x in to_concat"
  },
  {
    "id" : "f44e9986-0e42-4700-9d6f-12d64c503636",
    "prId" : 22325,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/22325#pullrequestreview-162593121",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e2450472-a1f5-4d74-b63b-1d5ff8ea4431",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "related to my comment above. cannot is_sparse not simply check if its an EA and if it has a Sparse Dtype? \r\n\r\nthen you simply need to pass the ``b.values`` here, yes? ",
        "createdAt" : "2018-08-31T10:38:10Z",
        "updatedAt" : "2018-10-13T08:12:19Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "a2e04528-c51a-4934-a0e9-391e87406d65",
        "parentId" : "e2450472-a1f5-4d74-b63b-1d5ff8ea4431",
        "authorId" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "body" : "I'll give that a shot.",
        "createdAt" : "2018-08-31T12:56:53Z",
        "updatedAt" : "2018-10-13T08:12:19Z",
        "lastEditedBy" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "tags" : [
        ]
      },
      {
        "id" : "4cd7ed26-e311-483e-b3bd-9895ee6c250a",
        "parentId" : "e2450472-a1f5-4d74-b63b-1d5ff8ea4431",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "can you add a comment here, its not obvious what you are doing",
        "createdAt" : "2018-10-05T11:12:56Z",
        "updatedAt" : "2018-10-13T08:12:19Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "41f070c1-3a1a-477e-b355-8c7ede89d0c8",
        "parentId" : "e2450472-a1f5-4d74-b63b-1d5ff8ea4431",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "how can obj be a SparseFrame here? is this tested?",
        "createdAt" : "2018-10-05T11:13:16Z",
        "updatedAt" : "2018-10-13T08:12:19Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "103c3ee4-7c26-4ac5-8504-75c5e9e397fa",
        "parentId" : "e2450472-a1f5-4d74-b63b-1d5ff8ea4431",
        "authorId" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "body" : "I think a comment of mine may have been lost.\r\n\r\nThis is hit in several places (e.g. `pandas/tests/sparse/test_combine_concat.py::TestSparseDataFrameConcat::test_concat`).\r\n\r\nWhat part can I clarify here?",
        "createdAt" : "2018-10-08T18:37:31Z",
        "updatedAt" : "2018-10-13T08:12:20Z",
        "lastEditedBy" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "tags" : [
        ]
      }
    ],
    "commit" : "4aad8e1976bcbfb694d3591a5f9143ab7316f5bd",
    "line" : 11,
    "diffHunk" : "@@ -1,1 +99,103 @@\n    if (result.blocks and (\n            all(is_sparse(b) for b in result.blocks) or\n            all(isinstance(obj, ABCSparseDataFrame) for obj in objs))):\n        from pandas.core.sparse.api import SparseDataFrame"
  },
  {
    "id" : "ce1824c9-af77-47bb-9d6e-0e670b4f52da",
    "prId" : 22325,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/22325#pullrequestreview-163884661",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ea7a861b-81f8-413c-92ff-9e603e7d6f7c",
        "parentId" : null,
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "I thought sparse arrays with different fill values give a warning?",
        "createdAt" : "2018-10-11T09:41:05Z",
        "updatedAt" : "2018-10-13T08:12:20Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      },
      {
        "id" : "adc568bd-79df-4ee6-b784-dd55da6e727b",
        "parentId" : "ea7a861b-81f8-413c-92ff-9e603e7d6f7c",
        "authorId" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "body" : "That's done somewhere in `pd.concat`, since it already has to look at all the types.\r\n\r\nWhen multiple fill values are found, we astype to the first (with a warning) so that the time we get here there's only one.\r\n\r\nThat seemed simpler than having to walk through the types again here, and maybe astype to the new one.",
        "createdAt" : "2018-10-11T15:42:53Z",
        "updatedAt" : "2018-10-13T08:12:20Z",
        "lastEditedBy" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "tags" : [
        ]
      }
    ],
    "commit" : "4aad8e1976bcbfb694d3591a5f9143ab7316f5bd",
    "line" : 40,
    "diffHunk" : "@@ -1,1 +564,568 @@    if len(set(fill_values)) > 1:\n        raise ValueError(\"Cannot concatenate SparseArrays with different \"\n                         \"fill values\")\n\n    fill_value = fill_values[0]"
  },
  {
    "id" : "2391ad88-4a6f-4ddd-83b4-ad333abbd9db",
    "prId" : 24024,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/24024#pullrequestreview-180477574",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2c6d4545-3847-4763-91cb-5a1db503f46f",
        "parentId" : null,
        "authorId" : "adf621f1-4745-479a-a1fc-dc14046a3f4b",
        "body" : "darn, i was hoping we could get rid of concat_datetimetz",
        "createdAt" : "2018-11-30T22:38:48Z",
        "updatedAt" : "2019-01-02T16:41:44Z",
        "lastEditedBy" : "adf621f1-4745-479a-a1fc-dc14046a3f4b",
        "tags" : [
        ]
      }
    ],
    "commit" : "2436214219fc116239640889715c9bc6575f571b",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +471,475 @@    all inputs must be DatetimeIndex\n    it is used in DatetimeIndex.append also\n    \"\"\"\n    # Right now, internals will pass a List[DatetimeArray] here\n    # for reductions like quantile. I would like to disentangle"
  }
]
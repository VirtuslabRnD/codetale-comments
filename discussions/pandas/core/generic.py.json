[
  {
    "id" : "36e8a32d-93e6-4517-83b5-2912eee391f8",
    "prId" : 2410,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "780cf460-81bf-4203-814f-7cacd81b665a",
        "parentId" : null,
        "authorId" : "55206695-bb42-4d72-886f-f5370a77363e",
        "body" : "will need to add some docs here for sure\n",
        "createdAt" : "2012-12-07T15:42:28Z",
        "updatedAt" : "2012-12-07T15:42:28Z",
        "lastEditedBy" : "55206695-bb42-4d72-886f-f5370a77363e",
        "tags" : [
        ]
      }
    ],
    "commit" : "ce604af36df2a89603411e24fc60946e69f58e6f",
    "line" : 17,
    "diffHunk" : "@@ -1,1 +219,223 @@        closed : {'right', 'left'}, default None\n            Which side of bin interval is closed\n        label : {'right', 'left'}, default None\n            Which bin edge label to label bucket with\n        convention : {'start', 'end', 's', 'e'}"
  },
  {
    "id" : "547f4bc4-853e-4e44-938d-c1c277c2078f",
    "prId" : 5848,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9fd36e63-74b5-466c-84da-dd5f347a4ba9",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "you need similar logic on head, no?\n",
        "createdAt" : "2014-01-04T18:56:10Z",
        "updatedAt" : "2014-01-14T21:07:22Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "f046eab4-1e4a-4368-8652-63c12b0224a2",
        "parentId" : "9fd36e63-74b5-466c-84da-dd5f347a4ba9",
        "authorId" : "af9488ab-761a-4bd1-8bd9-c8fdbeae13b0",
        "body" : "I added similar logic on head now.  The question is this changes how df.head(0) works.  It now returns self.  before it returned the same as df.head(1)  \n",
        "createdAt" : "2014-01-05T00:12:20Z",
        "updatedAt" : "2014-01-14T21:07:22Z",
        "lastEditedBy" : "af9488ab-761a-4bd1-8bd9-c8fdbeae13b0",
        "tags" : [
        ]
      }
    ],
    "commit" : "66b9e8ce53e0cbc204f4aa9336f6014876f3ad25",
    "line" : 23,
    "diffHunk" : "@@ -1,1 +1586,1590 @@        if l == 0 or n == 0:\n            return self\n        if n > l:\n            n = l\n        elif n < -l:"
  },
  {
    "id" : "51b25cf3-5157-4407-9746-d856f6c366b1",
    "prId" : 6745,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ebed5f59-94d2-42b2-a74c-1b857be35855",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "Is copy handled in BlockManager.reindex_indexers ?\n\nI don't think this is well tested and most of the time it should prob copy unless identical indexes \n",
        "createdAt" : "2014-04-18T23:31:45Z",
        "updatedAt" : "2014-04-25T13:50:55Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "c16e4cab-434f-46ea-a426-8411c7152309",
        "parentId" : "ebed5f59-94d2-42b2-a74c-1b857be35855",
        "authorId" : "413be534-cedb-4df7-abda-cde26db33acd",
        "body" : "A rule of thumb I try to follow is, yeah, that reindex should copy, unless there's \"inplace=True\" kwarg somewhere.\n\nBut point taken, need to double check that.\n",
        "createdAt" : "2014-04-19T08:15:59Z",
        "updatedAt" : "2014-04-25T13:50:55Z",
        "lastEditedBy" : "413be534-cedb-4df7-abda-cde26db33acd",
        "tags" : [
        ]
      }
    ],
    "commit" : "f51235aef9bbb50632b569d9e0c104816e5e31a0",
    "line" : 73,
    "diffHunk" : "@@ -1,1 +1709,1713 @@            if indexer is not None:\n                indexer = com._ensure_int64(indexer)\n\n            # TODO: speed up on homogeneous DataFrame objects\n            new_data = new_data.reindex_indexer(index, indexer, axis=baxis,"
  },
  {
    "id" : "6220f58a-16f8-41e4-b58f-20b4ee7165cd",
    "prId" : 6748,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "cf2c9e97-e297-498a-812e-8585bce382fb",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "had meant to move the guts of this to internals anyhow; e.g. maybe `get_as_blocks` can return the dict of str(dtype) to block manager (already combined), so in generic needs to just iterate and _constructor....finalize...\n\nif it works better to refactor this later (in your internal changes checklist), ok 2\n\nlmk\n",
        "createdAt" : "2014-03-31T10:59:53Z",
        "updatedAt" : "2014-03-31T11:00:50Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "f81f1abe-d370-4378-84d7-ffabdd920c62",
        "parentId" : "cf2c9e97-e297-498a-812e-8585bce382fb",
        "authorId" : "413be534-cedb-4df7-abda-cde26db33acd",
        "body" : "This will most likely get overwritten during refactoring.\n\nAnd it did occur to me that this is very much like \"group blocks by ftype\" operation that happens during merging/concatenation. And the implementation does look rather trivial:\n\n``` python\ndef mapreduce_blocks(mgr, keyfunc, reducer):\n    return dict((key, reducer(val_iter))\n                for key, val_iter in itertools.groupby(mgr.blocks, keyfunc=keyfunc))\n\ndef group_blocks_by_ftype(mgr):\n    return mapreduce_blocks(mgr, keyfunc=lambda b: str(b.ftype),\n                            reducer=list)\n\ndef combine_blocks_by_dtype(mgr):\n    return mapreduce_blocks(mgr, keyfunc=lambda b: str(b.dtype),\n                            reducer=mgr.combine)\n```\n\nSuch one-liner functions are indeed a natural extension of blockmanager external API, but I'm not sure if they deserve to be part of it.\n",
        "createdAt" : "2014-03-31T13:22:34Z",
        "updatedAt" : "2014-03-31T13:22:34Z",
        "lastEditedBy" : "413be534-cedb-4df7-abda-cde26db33acd",
        "tags" : [
        ]
      },
      {
        "id" : "9356d515-1945-47f0-94f4-2ef47339ec10",
        "parentId" : "cf2c9e97-e297-498a-812e-8585bce382fb",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "ok....maybe just reference this issue then in your refactoring...\n\nwill merge then\n",
        "createdAt" : "2014-03-31T13:28:40Z",
        "updatedAt" : "2014-03-31T13:28:40Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "668d6b82-a9b0-4db8-9833-f9edfd9f361f",
        "parentId" : "cf2c9e97-e297-498a-812e-8585bce382fb",
        "authorId" : "413be534-cedb-4df7-abda-cde26db33acd",
        "body" : "_I've decided to separate this into a separate comment._\n\nWhich brings me to another topic, minimalism in API design. I mean, I tend to share the opinion that an API is perfect not when you can't add anything else but rather when you can't take anything from it. It happens quite often that an interface gets overburdened with those small details, e.g. it just hurts my eyes to wade through `numpy.ndarray` attrs/methods when I forget the exact spelling of the thing I want to use and I know is there:\n\n```\nIn [1]: np.arange(10)\nOut[1]: array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n\nIn [2]: _1.\n_1.T             _1.choose        _1.data          _1.flatten       _1.nbytes        _1.repeat        _1.sort          _1.tostring\n_1.all           _1.clip          _1.diagonal      _1.getfield      _1.ndim          _1.reshape       _1.squeeze       _1.trace\n_1.any           _1.compress      _1.dot           _1.imag          _1.newbyteorder  _1.resize        _1.std           _1.transpose\n_1.argmax        _1.conj          _1.dtype         _1.item          _1.nonzero       _1.round         _1.strides       _1.var\n_1.argmin        _1.conjugate     _1.dump          _1.itemset       _1.prod          _1.searchsorted  _1.sum           _1.view\n_1.argsort       _1.copy          _1.dumps         _1.itemsize      _1.ptp           _1.setfield      _1.swapaxes      \n_1.astype        _1.ctypes        _1.fill          _1.max           _1.put           _1.setflags      _1.take          \n_1.base          _1.cumprod       _1.flags         _1.mean          _1.ravel         _1.shape         _1.tofile        \n_1.byteswap      _1.cumsum        _1.flat          _1.min           _1.real          _1.size          _1.tolist        \n```\n\nAnd, unfortunately, pandas containers add more on top of that:\n\n```\nIn [1]: pd.Series()\nOut[1]: Series([], dtype: float64)\n\nIn [2]: _1.\nDisplay all 225 possibilities? (y or n)\n```\n\nThe desire to have a bit of everything at your fingertip is tempting indeed, but 225 (two hundred!!) methods and properties is a bit too many for my liking. And it is a lot to wrap your head around when you're only starting.\n",
        "createdAt" : "2014-03-31T13:30:32Z",
        "updatedAt" : "2014-03-31T13:30:32Z",
        "lastEditedBy" : "413be534-cedb-4df7-abda-cde26db33acd",
        "tags" : [
        ]
      },
      {
        "id" : "0f8919b2-68dd-4439-af07-140b4416a6ff",
        "parentId" : "cf2c9e97-e297-498a-812e-8585bce382fb",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "that's a valid point, except that you have search in the docs, lots of docs, and you can always start the possibilities with a letter (to narrow down the search).\n\npandas provides a lot of functionaility (as does numpy). not sure that this is a problem per se.\n\nthe alternative is cryptic functions that do too much with too much overloading. which IMHO is a bigger/worse problem.\n",
        "createdAt" : "2014-03-31T13:34:35Z",
        "updatedAt" : "2014-03-31T13:34:35Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "84ba181d-ae92-433b-a6fa-2ddabe3c4041",
        "parentId" : "cf2c9e97-e297-498a-812e-8585bce382fb",
        "authorId" : "413be534-cedb-4df7-abda-cde26db33acd",
        "body" : "> the alternative is cryptic functions that do too much with too much overloading. which IMHO is a bigger/worse problem.\n\nI like how overloading is handled in BLAS interfaces: you have a convention about prefixes/suffixes that correspond to certain variation of the core algorithm, so you as a programmer should make an educated guess about what the data is going to look like or just use the generic implementation.\n\nAs for the naming, I've gone through the reference a bit and found out a \"light of hope\": string functions that obviously form a cluster of functionality available for series containers are conveniently put under `.str` attribute, that's a very nice application of namespacing and that's a very viable approach to the API cluttering problem. Following the Zen, I'd suggest that _Namespaces are one honking great idea -- let's do more of those!_\n",
        "createdAt" : "2014-03-31T14:03:32Z",
        "updatedAt" : "2014-03-31T14:03:32Z",
        "lastEditedBy" : "413be534-cedb-4df7-abda-cde26db33acd",
        "tags" : [
        ]
      },
      {
        "id" : "c7a49d2b-e98a-4ec5-9bcb-7171537a67da",
        "parentId" : "cf2c9e97-e297-498a-812e-8585bce382fb",
        "authorId" : "53ceba57-9272-4f73-b91f-1e647a7d2ce3",
        "body" : "Whenever I monkey patch new functionality I try to create namespaces. Since we control the ipython autocomplete, we could always move methods from the root to namespaces. The original methods would still work, they just wouldn't autocomplete in the root. I do this for subclasses of pandas objects. If I created a subclass like `OHLC`, I'd rather only see the custom methods I made. \n",
        "createdAt" : "2014-03-31T14:31:25Z",
        "updatedAt" : "2014-03-31T14:31:25Z",
        "lastEditedBy" : "53ceba57-9272-4f73-b91f-1e647a7d2ce3",
        "tags" : [
        ]
      }
    ],
    "commit" : "1a6244453537e0c1b07ec63324a9e263b4efd3f2",
    "line" : 21,
    "diffHunk" : "@@ -1,1 +2029,2033 @@        for b in self._data.blocks:\n            bd.setdefault(str(b.dtype), []).append(b)\n\n        result = {}\n        for dtype, blocks in bd.items():"
  },
  {
    "id" : "c8a9beb6-0783-4bf3-a99b-f4d17d8e83b3",
    "prId" : 6974,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a95fc5b0-0edd-4f5d-ba3b-db36dfc311ab",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "not 100% happy with this (I like your soln better), but perf is odd. can we do this inside of Block instead? (e.g. just automatically do it if ndim >= 3), a bit cleaner that way and all the code in the same place\n",
        "createdAt" : "2014-04-27T17:52:18Z",
        "updatedAt" : "2014-04-27T17:52:18Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "81675b651bc9aa04c1edaf1307aa72168f01abbb",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +3228,3232 @@        return self._constructor(new_data).__finalize__(self)\n\n    def slice_shift(self, periods=1, axis=0, **kwds):\n        \"\"\"\n        Equivalent to `shift` without copying data. The shifted data will"
  },
  {
    "id" : "b5ba31a0-c0d6-43be-a16d-14b312e5d899",
    "prId" : 7133,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c071038f-fd34-44f9-bb23-2ab3bad71ddf",
        "parentId" : null,
        "authorId" : "7541636a-d24d-4ee9-9027-3d80fc972781",
        "body" : "I wasn't exactly sure what the rules regarding \"outname\" are.  Can they have spaces?  What about underscores?  How long should they be?  So this may not be the best name.\n",
        "createdAt" : "2014-05-16T13:32:37Z",
        "updatedAt" : "2014-06-05T10:21:19Z",
        "lastEditedBy" : "7541636a-d24d-4ee9-9027-3d80fc972781",
        "tags" : [
        ]
      },
      {
        "id" : "1b59fa87-233c-4bac-b65d-3c72b01b22b9",
        "parentId" : "c071038f-fd34-44f9-bb23-2ab3bad71ddf",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "outname is just a 'descriptive' name used to autogenerate the doc strings, so that is fine\n",
        "createdAt" : "2014-05-16T13:57:52Z",
        "updatedAt" : "2014-06-05T10:21:19Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "2121b22ebfb539db62e248be0f99815e2931ac90",
    "line" : 24,
    "diffHunk" : "@@ -1,1 +3830,3834 @@        cls.std = std\n\n        @Substitution(outname='standarderror',\n                      desc=\"Return unbiased standard error of the mean over \"\n                           \"requested axis.\\n\\nNormalized by N-1 by default. \""
  }
]
[
  {
    "id" : "36e8a32d-93e6-4517-83b5-2912eee391f8",
    "prId" : 2410,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "780cf460-81bf-4203-814f-7cacd81b665a",
        "parentId" : null,
        "authorId" : "55206695-bb42-4d72-886f-f5370a77363e",
        "body" : "will need to add some docs here for sure\n",
        "createdAt" : "2012-12-07T15:42:28Z",
        "updatedAt" : "2012-12-07T15:42:28Z",
        "lastEditedBy" : "55206695-bb42-4d72-886f-f5370a77363e",
        "tags" : [
        ]
      }
    ],
    "commit" : "ce604af36df2a89603411e24fc60946e69f58e6f",
    "line" : 17,
    "diffHunk" : "@@ -1,1 +219,223 @@        closed : {'right', 'left'}, default None\n            Which side of bin interval is closed\n        label : {'right', 'left'}, default None\n            Which bin edge label to label bucket with\n        convention : {'start', 'end', 's', 'e'}"
  },
  {
    "id" : "547f4bc4-853e-4e44-938d-c1c277c2078f",
    "prId" : 5848,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9fd36e63-74b5-466c-84da-dd5f347a4ba9",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "you need similar logic on head, no?\n",
        "createdAt" : "2014-01-04T18:56:10Z",
        "updatedAt" : "2014-01-14T21:07:22Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "f046eab4-1e4a-4368-8652-63c12b0224a2",
        "parentId" : "9fd36e63-74b5-466c-84da-dd5f347a4ba9",
        "authorId" : "af9488ab-761a-4bd1-8bd9-c8fdbeae13b0",
        "body" : "I added similar logic on head now.  The question is this changes how df.head(0) works.  It now returns self.  before it returned the same as df.head(1)  \n",
        "createdAt" : "2014-01-05T00:12:20Z",
        "updatedAt" : "2014-01-14T21:07:22Z",
        "lastEditedBy" : "af9488ab-761a-4bd1-8bd9-c8fdbeae13b0",
        "tags" : [
        ]
      }
    ],
    "commit" : "66b9e8ce53e0cbc204f4aa9336f6014876f3ad25",
    "line" : 23,
    "diffHunk" : "@@ -1,1 +1586,1590 @@        if l == 0 or n == 0:\n            return self\n        if n > l:\n            n = l\n        elif n < -l:"
  },
  {
    "id" : "51b25cf3-5157-4407-9746-d856f6c366b1",
    "prId" : 6745,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ebed5f59-94d2-42b2-a74c-1b857be35855",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "Is copy handled in BlockManager.reindex_indexers ?\n\nI don't think this is well tested and most of the time it should prob copy unless identical indexes \n",
        "createdAt" : "2014-04-18T23:31:45Z",
        "updatedAt" : "2014-04-25T13:50:55Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "c16e4cab-434f-46ea-a426-8411c7152309",
        "parentId" : "ebed5f59-94d2-42b2-a74c-1b857be35855",
        "authorId" : "413be534-cedb-4df7-abda-cde26db33acd",
        "body" : "A rule of thumb I try to follow is, yeah, that reindex should copy, unless there's \"inplace=True\" kwarg somewhere.\n\nBut point taken, need to double check that.\n",
        "createdAt" : "2014-04-19T08:15:59Z",
        "updatedAt" : "2014-04-25T13:50:55Z",
        "lastEditedBy" : "413be534-cedb-4df7-abda-cde26db33acd",
        "tags" : [
        ]
      }
    ],
    "commit" : "f51235aef9bbb50632b569d9e0c104816e5e31a0",
    "line" : 73,
    "diffHunk" : "@@ -1,1 +1709,1713 @@            if indexer is not None:\n                indexer = com._ensure_int64(indexer)\n\n            # TODO: speed up on homogeneous DataFrame objects\n            new_data = new_data.reindex_indexer(index, indexer, axis=baxis,"
  },
  {
    "id" : "6220f58a-16f8-41e4-b58f-20b4ee7165cd",
    "prId" : 6748,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "cf2c9e97-e297-498a-812e-8585bce382fb",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "had meant to move the guts of this to internals anyhow; e.g. maybe `get_as_blocks` can return the dict of str(dtype) to block manager (already combined), so in generic needs to just iterate and _constructor....finalize...\n\nif it works better to refactor this later (in your internal changes checklist), ok 2\n\nlmk\n",
        "createdAt" : "2014-03-31T10:59:53Z",
        "updatedAt" : "2014-03-31T11:00:50Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "f81f1abe-d370-4378-84d7-ffabdd920c62",
        "parentId" : "cf2c9e97-e297-498a-812e-8585bce382fb",
        "authorId" : "413be534-cedb-4df7-abda-cde26db33acd",
        "body" : "This will most likely get overwritten during refactoring.\n\nAnd it did occur to me that this is very much like \"group blocks by ftype\" operation that happens during merging/concatenation. And the implementation does look rather trivial:\n\n``` python\ndef mapreduce_blocks(mgr, keyfunc, reducer):\n    return dict((key, reducer(val_iter))\n                for key, val_iter in itertools.groupby(mgr.blocks, keyfunc=keyfunc))\n\ndef group_blocks_by_ftype(mgr):\n    return mapreduce_blocks(mgr, keyfunc=lambda b: str(b.ftype),\n                            reducer=list)\n\ndef combine_blocks_by_dtype(mgr):\n    return mapreduce_blocks(mgr, keyfunc=lambda b: str(b.dtype),\n                            reducer=mgr.combine)\n```\n\nSuch one-liner functions are indeed a natural extension of blockmanager external API, but I'm not sure if they deserve to be part of it.\n",
        "createdAt" : "2014-03-31T13:22:34Z",
        "updatedAt" : "2014-03-31T13:22:34Z",
        "lastEditedBy" : "413be534-cedb-4df7-abda-cde26db33acd",
        "tags" : [
        ]
      },
      {
        "id" : "9356d515-1945-47f0-94f4-2ef47339ec10",
        "parentId" : "cf2c9e97-e297-498a-812e-8585bce382fb",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "ok....maybe just reference this issue then in your refactoring...\n\nwill merge then\n",
        "createdAt" : "2014-03-31T13:28:40Z",
        "updatedAt" : "2014-03-31T13:28:40Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "668d6b82-a9b0-4db8-9833-f9edfd9f361f",
        "parentId" : "cf2c9e97-e297-498a-812e-8585bce382fb",
        "authorId" : "413be534-cedb-4df7-abda-cde26db33acd",
        "body" : "_I've decided to separate this into a separate comment._\n\nWhich brings me to another topic, minimalism in API design. I mean, I tend to share the opinion that an API is perfect not when you can't add anything else but rather when you can't take anything from it. It happens quite often that an interface gets overburdened with those small details, e.g. it just hurts my eyes to wade through `numpy.ndarray` attrs/methods when I forget the exact spelling of the thing I want to use and I know is there:\n\n```\nIn [1]: np.arange(10)\nOut[1]: array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n\nIn [2]: _1.\n_1.T             _1.choose        _1.data          _1.flatten       _1.nbytes        _1.repeat        _1.sort          _1.tostring\n_1.all           _1.clip          _1.diagonal      _1.getfield      _1.ndim          _1.reshape       _1.squeeze       _1.trace\n_1.any           _1.compress      _1.dot           _1.imag          _1.newbyteorder  _1.resize        _1.std           _1.transpose\n_1.argmax        _1.conj          _1.dtype         _1.item          _1.nonzero       _1.round         _1.strides       _1.var\n_1.argmin        _1.conjugate     _1.dump          _1.itemset       _1.prod          _1.searchsorted  _1.sum           _1.view\n_1.argsort       _1.copy          _1.dumps         _1.itemsize      _1.ptp           _1.setfield      _1.swapaxes      \n_1.astype        _1.ctypes        _1.fill          _1.max           _1.put           _1.setflags      _1.take          \n_1.base          _1.cumprod       _1.flags         _1.mean          _1.ravel         _1.shape         _1.tofile        \n_1.byteswap      _1.cumsum        _1.flat          _1.min           _1.real          _1.size          _1.tolist        \n```\n\nAnd, unfortunately, pandas containers add more on top of that:\n\n```\nIn [1]: pd.Series()\nOut[1]: Series([], dtype: float64)\n\nIn [2]: _1.\nDisplay all 225 possibilities? (y or n)\n```\n\nThe desire to have a bit of everything at your fingertip is tempting indeed, but 225 (two hundred!!) methods and properties is a bit too many for my liking. And it is a lot to wrap your head around when you're only starting.\n",
        "createdAt" : "2014-03-31T13:30:32Z",
        "updatedAt" : "2014-03-31T13:30:32Z",
        "lastEditedBy" : "413be534-cedb-4df7-abda-cde26db33acd",
        "tags" : [
        ]
      },
      {
        "id" : "0f8919b2-68dd-4439-af07-140b4416a6ff",
        "parentId" : "cf2c9e97-e297-498a-812e-8585bce382fb",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "that's a valid point, except that you have search in the docs, lots of docs, and you can always start the possibilities with a letter (to narrow down the search).\n\npandas provides a lot of functionaility (as does numpy). not sure that this is a problem per se.\n\nthe alternative is cryptic functions that do too much with too much overloading. which IMHO is a bigger/worse problem.\n",
        "createdAt" : "2014-03-31T13:34:35Z",
        "updatedAt" : "2014-03-31T13:34:35Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "84ba181d-ae92-433b-a6fa-2ddabe3c4041",
        "parentId" : "cf2c9e97-e297-498a-812e-8585bce382fb",
        "authorId" : "413be534-cedb-4df7-abda-cde26db33acd",
        "body" : "> the alternative is cryptic functions that do too much with too much overloading. which IMHO is a bigger/worse problem.\n\nI like how overloading is handled in BLAS interfaces: you have a convention about prefixes/suffixes that correspond to certain variation of the core algorithm, so you as a programmer should make an educated guess about what the data is going to look like or just use the generic implementation.\n\nAs for the naming, I've gone through the reference a bit and found out a \"light of hope\": string functions that obviously form a cluster of functionality available for series containers are conveniently put under `.str` attribute, that's a very nice application of namespacing and that's a very viable approach to the API cluttering problem. Following the Zen, I'd suggest that _Namespaces are one honking great idea -- let's do more of those!_\n",
        "createdAt" : "2014-03-31T14:03:32Z",
        "updatedAt" : "2014-03-31T14:03:32Z",
        "lastEditedBy" : "413be534-cedb-4df7-abda-cde26db33acd",
        "tags" : [
        ]
      },
      {
        "id" : "c7a49d2b-e98a-4ec5-9bcb-7171537a67da",
        "parentId" : "cf2c9e97-e297-498a-812e-8585bce382fb",
        "authorId" : "53ceba57-9272-4f73-b91f-1e647a7d2ce3",
        "body" : "Whenever I monkey patch new functionality I try to create namespaces. Since we control the ipython autocomplete, we could always move methods from the root to namespaces. The original methods would still work, they just wouldn't autocomplete in the root. I do this for subclasses of pandas objects. If I created a subclass like `OHLC`, I'd rather only see the custom methods I made. \n",
        "createdAt" : "2014-03-31T14:31:25Z",
        "updatedAt" : "2014-03-31T14:31:25Z",
        "lastEditedBy" : "53ceba57-9272-4f73-b91f-1e647a7d2ce3",
        "tags" : [
        ]
      }
    ],
    "commit" : "1a6244453537e0c1b07ec63324a9e263b4efd3f2",
    "line" : 21,
    "diffHunk" : "@@ -1,1 +2029,2033 @@        for b in self._data.blocks:\n            bd.setdefault(str(b.dtype), []).append(b)\n\n        result = {}\n        for dtype, blocks in bd.items():"
  },
  {
    "id" : "c8a9beb6-0783-4bf3-a99b-f4d17d8e83b3",
    "prId" : 6974,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a95fc5b0-0edd-4f5d-ba3b-db36dfc311ab",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "not 100% happy with this (I like your soln better), but perf is odd. can we do this inside of Block instead? (e.g. just automatically do it if ndim >= 3), a bit cleaner that way and all the code in the same place\n",
        "createdAt" : "2014-04-27T17:52:18Z",
        "updatedAt" : "2014-04-27T17:52:18Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "81675b651bc9aa04c1edaf1307aa72168f01abbb",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +3228,3232 @@        return self._constructor(new_data).__finalize__(self)\n\n    def slice_shift(self, periods=1, axis=0, **kwds):\n        \"\"\"\n        Equivalent to `shift` without copying data. The shifted data will"
  },
  {
    "id" : "b5ba31a0-c0d6-43be-a16d-14b312e5d899",
    "prId" : 7133,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c071038f-fd34-44f9-bb23-2ab3bad71ddf",
        "parentId" : null,
        "authorId" : "7541636a-d24d-4ee9-9027-3d80fc972781",
        "body" : "I wasn't exactly sure what the rules regarding \"outname\" are.  Can they have spaces?  What about underscores?  How long should they be?  So this may not be the best name.\n",
        "createdAt" : "2014-05-16T13:32:37Z",
        "updatedAt" : "2014-06-05T10:21:19Z",
        "lastEditedBy" : "7541636a-d24d-4ee9-9027-3d80fc972781",
        "tags" : [
        ]
      },
      {
        "id" : "1b59fa87-233c-4bac-b65d-3c72b01b22b9",
        "parentId" : "c071038f-fd34-44f9-bb23-2ab3bad71ddf",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "outname is just a 'descriptive' name used to autogenerate the doc strings, so that is fine\n",
        "createdAt" : "2014-05-16T13:57:52Z",
        "updatedAt" : "2014-06-05T10:21:19Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "2121b22ebfb539db62e248be0f99815e2931ac90",
    "line" : 24,
    "diffHunk" : "@@ -1,1 +3830,3834 @@        cls.std = std\n\n        @Substitution(outname='standarderror',\n                      desc=\"Return unbiased standard error of the mean over \"\n                           \"requested axis.\\n\\nNormalized by N-1 by default. \""
  },
  {
    "id" : "66f086c7-f913-4a5e-be91-8ce880f42f65",
    "prId" : 8550,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6af16e34-4476-4efa-a316-98c903e9da8f",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "why is this necessary?\n",
        "createdAt" : "2014-10-20T01:03:10Z",
        "updatedAt" : "2014-11-10T16:46:58Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "6a87cfb5-f77d-4296-b741-b19076458190",
        "parentId" : "6af16e34-4476-4efa-a316-98c903e9da8f",
        "authorId" : "a365f24b-52e0-4fdf-915f-0b9118bb4bb6",
        "body" : "These logical functions have slightly different documentation: a 'bool_only' field instead of a 'numeric_only' field, and potentially a message about supporting additional numpy arguments via the bool_extended_args variable.\n",
        "createdAt" : "2014-10-20T21:38:35Z",
        "updatedAt" : "2014-11-10T16:46:58Z",
        "lastEditedBy" : "a365f24b-52e0-4fdf-915f-0b9118bb4bb6",
        "tags" : [
        ]
      },
      {
        "id" : "85a32880-58ca-4030-80b3-19a25a8ef810",
        "parentId" : "6af16e34-4476-4efa-a316-98c903e9da8f",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "I don't think this is necessary (nor is any other 'bool_extended_args' variable), its just not needed. That said If you have a use case pls show it.\n",
        "createdAt" : "2014-10-20T22:16:14Z",
        "updatedAt" : "2014-11-10T16:46:58Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "eab72319-35d7-41c4-9578-4184186717db",
        "parentId" : "6af16e34-4476-4efa-a316-98c903e9da8f",
        "authorId" : "a365f24b-52e0-4fdf-915f-0b9118bb4bb6",
        "body" : "I'd like to better understand your comment. I mentioned two special cases in the documentation here, the bool_only argument name and the documentation message about supporting additional numpy arguments, which are currently supported in master's Series.any/all, which forwards to numpy's any/all.\n1) bool_only is the preexisting argument name for DataFrame's any and all, in master. Are you suggesting I should change it to numeric_only?\n2) You had suggested earlier that I should continue to support the ndarray.any/all arguments that are supported by Series.any/all in master (these are the 'out' and 'keepdims' parameters). Are you saying that I should not support these, or that I should not document that they are supported?\n",
        "createdAt" : "2014-10-20T22:32:47Z",
        "updatedAt" : "2014-11-10T16:46:58Z",
        "lastEditedBy" : "a365f24b-52e0-4fdf-915f-0b9118bb4bb6",
        "tags" : [
        ]
      },
      {
        "id" : "6d33dd5c-137c-4b0c-9045-8c123fc42603",
        "parentId" : "6af16e34-4476-4efa-a316-98c903e9da8f",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "1) maybe I wasn't clear. The signature should be something like: `any(laxis, skipna, level, **kwargs)`; we _accept_ but don't deal explicity with the numpy args (e.g. `out`) and such. Its not useful, nor is it consistent with how pandas works.\n\n2) I realized I was confusing about `bool_only`, yes that is a good idea (just not `bool_extended_args`\n",
        "createdAt" : "2014-10-20T23:04:53Z",
        "updatedAt" : "2014-11-10T16:46:58Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "224f5166-71c2-4b16-8959-9036741e31f5",
        "parentId" : "6af16e34-4476-4efa-a316-98c903e9da8f",
        "authorId" : "a365f24b-52e0-4fdf-915f-0b9118bb4bb6",
        "body" : "Hi, just to make sure I understand your point 1, by \"accept but do not deal explicitly with numpy args\" do you mean we ignore the args or we attempt to pass them through if numpy.any is eventually called (the arguments are forwarded opaquely as kwargs)?\n\nIf the former, is there anything I need to do to deprecate these arguments, which are supported in master and, at least for the out argument, currently documented: http://pandas.pydata.org/pandas-docs/stable/generated/pandas.Series.any.html\n",
        "createdAt" : "2014-10-21T02:29:00Z",
        "updatedAt" : "2014-11-10T16:46:58Z",
        "lastEditedBy" : "a365f24b-52e0-4fdf-915f-0b9118bb4bb6",
        "tags" : [
        ]
      },
      {
        "id" : "2602129a-2d55-4570-9176-853f3d86b9d8",
        "parentId" : "6af16e34-4476-4efa-a316-98c903e9da8f",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "no just accept **kwargs and u r done\n",
        "createdAt" : "2014-10-21T02:32:03Z",
        "updatedAt" : "2014-11-10T16:46:58Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "287055cf-aa13-4f79-9eaa-0bdd0dca3af9",
        "parentId" : "6af16e34-4476-4efa-a316-98c903e9da8f",
        "authorId" : "a365f24b-52e0-4fdf-915f-0b9118bb4bb6",
        "body" : "Thanks, got it.\n",
        "createdAt" : "2014-10-21T02:35:28Z",
        "updatedAt" : "2014-11-10T16:46:58Z",
        "lastEditedBy" : "a365f24b-52e0-4fdf-915f-0b9118bb4bb6",
        "tags" : [
        ]
      },
      {
        "id" : "6fde79b6-748a-465b-b453-74cce166deb7",
        "parentId" : "6af16e34-4476-4efa-a316-98c903e9da8f",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "shouldn't `bool_only=True` be the default? \n",
        "createdAt" : "2014-10-25T00:16:31Z",
        "updatedAt" : "2014-11-10T16:46:58Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "de211e40-e9e7-46f7-99ef-9eff1f5ca598",
        "parentId" : "6af16e34-4476-4efa-a316-98c903e9da8f",
        "authorId" : "a365f24b-52e0-4fdf-915f-0b9118bb4bb6",
        "body" : "I made bool_only default to None (False) here because:\n- The default is None in DataFrame’s current implementation of any/all in master\n- The corresponding numeric_only argument to sum, mean, etc defaults to None\n- bool_only is not currently implemented in Series._reduce or Panel._reduce. Once we add not implemented errors, they would be thrown in the case of all default arguments, were bool_only to be True by default.\n",
        "createdAt" : "2014-10-26T23:34:53Z",
        "updatedAt" : "2014-11-10T16:46:58Z",
        "lastEditedBy" : "a365f24b-52e0-4fdf-915f-0b9118bb4bb6",
        "tags" : [
        ]
      },
      {
        "id" : "6848eaca-0b83-43a2-8273-d36b30788efa",
        "parentId" : "6af16e34-4476-4efa-a316-98c903e9da8f",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "ok, though I find its a little odd (e.g. I can't think of a reason to use `any/all` on non-boolean data), but I am sure people will try it!.\n",
        "createdAt" : "2014-10-27T00:02:11Z",
        "updatedAt" : "2014-11-10T16:46:58Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "2b79db26-5c34-41c4-9d0a-9709cc9d8884",
        "parentId" : "6af16e34-4476-4efa-a316-98c903e9da8f",
        "authorId" : "a365f24b-52e0-4fdf-915f-0b9118bb4bb6",
        "body" : "I guess, also, if they're calling any/all on Series in master, they are using the numpy version which does not offer a bool_only option.\n\nWould it make sense for me to create a new issue for implementing bool_only (numeric_only) in Series an Panel, and look into whether it should be enabled by default for any/all?\n",
        "createdAt" : "2014-10-27T00:07:08Z",
        "updatedAt" : "2014-11-10T16:46:58Z",
        "lastEditedBy" : "a365f24b-52e0-4fdf-915f-0b9118bb4bb6",
        "tags" : [
        ]
      }
    ],
    "commit" : "518a62c4afc020c4b64e6a053cfe5efea5ce9cfc",
    "line" : 25,
    "diffHunk" : "@@ -1,1 +3924,3928 @@        If the axis is a MultiIndex (hierarchical), count along a\n        particular level, collapsing into a \"\"\" + name + \"\"\"\nbool_only : boolean, default None\n    Include only boolean data. If None, will attempt to use everything,\n    then use only boolean data"
  },
  {
    "id" : "1a1ea1ab-0125-4ad6-b068-293ad2c6f641",
    "prId" : 8680,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "db77785a-7d7e-4445-b5c8-cde7af07a684",
        "parentId" : null,
        "authorId" : "40104112-cdcf-4812-8f95-b502b40e346d",
        "body" : "This was surprising to encounter (needed to change it to fix some tests), but maybe it was there for a reason? I don't think there is any reason for `loc` here to do label based rather than integer indexing?\n",
        "createdAt" : "2014-10-31T01:21:24Z",
        "updatedAt" : "2014-11-02T20:12:45Z",
        "lastEditedBy" : "40104112-cdcf-4812-8f95-b502b40e346d",
        "tags" : [
        ]
      },
      {
        "id" : "41559f91-70e1-481c-986f-e61dbf87e700",
        "parentId" : "db77785a-7d7e-4445-b5c8-cde7af07a684",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "could be\nI have tried to not touch xs recently. it seems s but fragile and multi slicing obviates the need for it anyhow \n",
        "createdAt" : "2014-10-31T01:33:13Z",
        "updatedAt" : "2014-11-02T20:12:45Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "db6f8fd94aca599f0c89d645d9c815fd33ee2196",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +1462,1466 @@\n        else:\n            result = self.iloc[loc]\n            result.index = new_index\n"
  },
  {
    "id" : "45d75905-b982-4826-a133-f37f3cb9ea21",
    "prId" : 8966,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e7a065ac-97ab-457f-aece-a40db28a7a9a",
        "parentId" : null,
        "authorId" : "49cb7e4b-934a-4329-961e-4089057c4185",
        "body" : "I think calling `accum_func` with `NaT`s present is okay because the NaTs are neither greater than nor less than any other datetime64:\n\n```\nIn [6]: pd.NaT < np.datetime64(('2010-01-01'))\nOut[6]: False\n\nIn [7]: np.datetime64(('2010-01-01')) < pd.NaT \nOut[7]: False\n```\n",
        "createdAt" : "2014-12-03T13:09:17Z",
        "updatedAt" : "2014-12-03T13:09:17Z",
        "lastEditedBy" : "49cb7e4b-934a-4329-961e-4089057c4185",
        "tags" : [
        ]
      }
    ],
    "commit" : "010741f3eb4ec6f05edc4168549ea8b05cb018fc",
    "line" : 8,
    "diffHunk" : "@@ -1,1 +4116,4120 @@                if skipna and issubclass(y.dtype.type, \n                                         (np.datetime64, np.timedelta64)):\n                    result = accum_func(y, axis)\n                    mask = isnull(self)\n                    np.putmask(result, mask, pd.tslib.iNaT)"
  }
]
[
  {
    "id" : "865d591c-09e1-4007-b5df-ced6019218fb",
    "prId" : 4092,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "40c484f3-8755-4320-b563-73eb1b4fff78",
        "parentId" : null,
        "authorId" : "5c239b83-5a68-467b-a3f8-113a0fc494dc",
        "body" : "would love this, maybe an issue?\n",
        "createdAt" : "2013-07-01T03:07:34Z",
        "updatedAt" : "2013-07-01T22:09:33Z",
        "lastEditedBy" : "5c239b83-5a68-467b-a3f8-113a0fc494dc",
        "tags" : [
        ]
      },
      {
        "id" : "a393908f-28fb-48e1-8053-d53fcc011726",
        "parentId" : "40c484f3-8755-4320-b563-73eb1b4fff78",
        "authorId" : "6f890fbc-4bdf-4397-95eb-a8225d4af04f",
        "body" : "What would you want it to show? calculates values on the fly right - so probably just keys?\n",
        "createdAt" : "2013-07-01T03:13:47Z",
        "updatedAt" : "2013-07-01T22:09:33Z",
        "lastEditedBy" : "6f890fbc-4bdf-4397-95eb-a8225d4af04f",
        "tags" : [
        ]
      },
      {
        "id" : "d85a76ce-8d4d-42b1-a1f4-6d0ef5864b6e",
        "parentId" : "40c484f3-8755-4320-b563-73eb1b4fff78",
        "authorId" : "5c239b83-5a68-467b-a3f8-113a0fc494dc",
        "body" : "yeah gb is lazy so yeah keys i guess. just something more informative than the object repr\n",
        "createdAt" : "2013-07-01T03:24:45Z",
        "updatedAt" : "2013-07-01T22:09:33Z",
        "lastEditedBy" : "5c239b83-5a68-467b-a3f8-113a0fc494dc",
        "tags" : [
        ]
      }
    ],
    "commit" : "a5583141404ddf91516e70dade7942c315cb3646",
    "line" : 22,
    "diffHunk" : "@@ -1,1 +204,208 @@\n    def __unicode__(self):\n        # TODO: Better unicode/repr for GroupBy object\n        return object.__repr__(self)\n"
  },
  {
    "id" : "b7782fef-f59f-4774-8f23-b3074057db9e",
    "prId" : 4670,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "01c731f8-90cb-4acc-9cc0-75872883b956",
        "parentId" : null,
        "authorId" : "aeb7e171-52e2-4faa-8a7c-32d6a9d2c2be",
        "body" : "@cpcloud this seemed to do it!\n",
        "createdAt" : "2013-08-25T22:28:11Z",
        "updatedAt" : "2013-08-25T22:28:11Z",
        "lastEditedBy" : "aeb7e171-52e2-4faa-8a7c-32d6a9d2c2be",
        "tags" : [
        ]
      }
    ],
    "commit" : "e8530dfbe30a493e351dca57e9afd9c7c97d5805",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +517,521 @@            else:\n                result = result.reindex_axis(ax, axis=self.axis)\n        elif self.group_keys and self.as_index:\n            group_keys = keys\n            group_levels = self.grouper.levels"
  },
  {
    "id" : "eadd2821-3ac3-473c-9f36-f739d19e9086",
    "prId" : 5096,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "46b72e56-1bb4-4d4a-a70b-15103aa7808f",
        "parentId" : null,
        "authorId" : "5c239b83-5a68-467b-a3f8-113a0fc494dc",
        "body" : "should this `and` be `&`? can `b` be an array/frame/series?\n",
        "createdAt" : "2013-10-10T04:49:42Z",
        "updatedAt" : "2013-10-13T15:03:27Z",
        "lastEditedBy" : "5c239b83-5a68-467b-a3f8-113a0fc494dc",
        "tags" : [
        ]
      },
      {
        "id" : "73955b23-d630-4c1e-8fed-23ee1777feb1",
        "parentId" : "46b72e56-1bb4-4d4a-a70b-15103aa7808f",
        "authorId" : "69bb3c84-e6a9-46c9-8328-ad025ce4150d",
        "body" : "I think it has to be `and` in order to handle `NaN`, which we want to interpret as False. Thoughts, @cpcloud?\n\n```\nIn [59]: np.nan & pd.notnull(np.nan)\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\n<ipython-input-59-47e0df96d143> in <module>()\n----> 1 np.nan & pd.notnull(np.nan)\n\nTypeError: unsupported operand type(s) for &: 'float' and 'bool'\n\nIn [60]: np.nan and pd.notnull(np.nan)\nOut[60]: False\n```\n",
        "createdAt" : "2013-10-13T14:36:06Z",
        "updatedAt" : "2013-10-13T15:03:27Z",
        "lastEditedBy" : "69bb3c84-e6a9-46c9-8328-ad025ce4150d",
        "tags" : [
        ]
      }
    ],
    "commit" : "889b9f2447137a32857613a95d2b363020216c41",
    "line" : 18,
    "diffHunk" : "@@ -1,1 +1609,1613 @@        def true_and_notnull(x, *args, **kwargs):\n            b = wrapper(x, *args, **kwargs)\n            return b and notnull(b)\n\n        try:"
  },
  {
    "id" : "5b2bcea7-b4bf-4c28-b556-7d7d997fdd5a",
    "prId" : 5231,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e6fc2aca-c9d0-4ed3-b09b-8f4ae3c2489e",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "not sure why `_lexsort_indexer` is even in groupby.py only uses in series/frame. can you move to `algos.py`?\n",
        "createdAt" : "2014-03-11T02:01:17Z",
        "updatedAt" : "2014-03-27T20:57:49Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "3230ed4bd75ff5f2f016ac1e07def7ebbb432885",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +3146,3150 @@\n\ndef _lexsort_indexer(keys, orders=None, na_position='last'):\n    labels = []\n    shape = []"
  },
  {
    "id" : "346f85f1-634f-4e09-898b-f95024db399c",
    "prId" : 5231,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e63358e2-f04a-4ae5-8992-fa2814dba357",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "move to `algos.py` as well\n",
        "createdAt" : "2014-03-11T02:01:29Z",
        "updatedAt" : "2014-03-27T20:57:49Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "47d02957-9d4a-483d-aef7-fe6b306735c9",
        "parentId" : "e63358e2-f04a-4ae5-8992-fa2814dba357",
        "authorId" : "49cb7e4b-934a-4329-961e-4089057c4185",
        "body" : "Do you mean core/algorithms.py? or algos.pyx?\n",
        "createdAt" : "2014-03-11T02:05:13Z",
        "updatedAt" : "2014-03-27T20:57:49Z",
        "lastEditedBy" : "49cb7e4b-934a-4329-961e-4089057c4185",
        "tags" : [
        ]
      },
      {
        "id" : "1520485a-e705-41a8-bf71-93f31f978d8e",
        "parentId" : "e63358e2-f04a-4ae5-8992-fa2814dba357",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "yes...that's what I meant!\n",
        "createdAt" : "2014-03-11T02:06:38Z",
        "updatedAt" : "2014-03-27T20:57:49Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "956f5912-b8a2-4612-b171-6c5ee49260ca",
        "parentId" : "e63358e2-f04a-4ae5-8992-fa2814dba357",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "wait...nvm....I realize this is being called internall in groupby.py\n",
        "createdAt" : "2014-03-11T02:08:39Z",
        "updatedAt" : "2014-03-27T20:57:49Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "3230ed4bd75ff5f2f016ac1e07def7ebbb432885",
    "line" : 51,
    "diffHunk" : "@@ -1,1 +3185,3189 @@    return _indexer_from_factorized(labels, shape)\n\ndef _nargsort(items, kind='quicksort', ascending=True, na_position='last'):\n    \"\"\"\n    This is intended to be a drop-in replacement for np.argsort which handles NaNs"
  },
  {
    "id" : "a7b226af-df0b-4fc8-b7de-5bcb5728c8fd",
    "prId" : 5510,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "542ca5da-0f77-445e-b802-2b2a7e61f63b",
        "parentId" : null,
        "authorId" : "6f890fbc-4bdf-4397-95eb-a8225d4af04f",
        "body" : "mind removing this blank line if you're editing this?\n",
        "createdAt" : "2013-11-14T00:18:26Z",
        "updatedAt" : "2013-11-14T19:18:52Z",
        "lastEditedBy" : "6f890fbc-4bdf-4397-95eb-a8225d4af04f",
        "tags" : [
        ]
      },
      {
        "id" : "74b5c5c2-cb67-4976-a0ad-50b2ae27c030",
        "parentId" : "542ca5da-0f77-445e-b802-2b2a7e61f63b",
        "authorId" : "aeb7e171-52e2-4faa-8a7c-32d6a9d2c2be",
        "body" : "I added it in specifically, pep8 says it should be there, right?\n",
        "createdAt" : "2013-11-14T00:18:46Z",
        "updatedAt" : "2013-11-14T19:18:52Z",
        "lastEditedBy" : "aeb7e171-52e2-4faa-8a7c-32d6a9d2c2be",
        "tags" : [
        ]
      },
      {
        "id" : "dc0cb7af-042f-4093-a26d-bd3733d75229",
        "parentId" : "542ca5da-0f77-445e-b802-2b2a7e61f63b",
        "authorId" : "6f890fbc-4bdf-4397-95eb-a8225d4af04f",
        "body" : "okay, no idea.\n",
        "createdAt" : "2013-11-14T00:24:59Z",
        "updatedAt" : "2013-11-14T19:18:52Z",
        "lastEditedBy" : "6f890fbc-4bdf-4397-95eb-a8225d4af04f",
        "tags" : [
        ]
      }
    ],
    "commit" : "b56479879bb4e0fccdb23497e2073c201481aad7",
    "line" : 55,
    "diffHunk" : "@@ -1,1 +523,527 @@        try to cast the result to our obj original type,\n        we may have roundtripped thru object in the mean-time\n\n        \"\"\"\n        if obj.ndim > 1:"
  },
  {
    "id" : "96a44882-e2f7-41ce-a4a4-9e03ce0c1dea",
    "prId" : 6516,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f76d21f7-1a43-465c-a6a4-2e00d1eec8ab",
        "parentId" : null,
        "authorId" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "body" : "@jreback is this `elif` supposed to be shifted left to be under the `if` at line 226?\n",
        "createdAt" : "2014-03-16T15:07:01Z",
        "updatedAt" : "2014-03-16T15:07:01Z",
        "lastEditedBy" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "tags" : [
        ]
      }
    ],
    "commit" : "5e965e956b2c420bfbd1b424967b46cd29e00459",
    "line" : 99,
    "diffHunk" : "@@ -1,1 +235,239 @@                            raise ValueError('level name %s is not the name of the '\n                                             'index' % level)\n                    elif level > 0:\n                        raise ValueError('level > 0 only valid with MultiIndex')\n                    ax = Index(ax.get_level_values(level), name=level)"
  },
  {
    "id" : "b0a13c94-c947-44c9-9f7f-7be746b27c25",
    "prId" : 6516,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2b083f3b-0de9-4821-b784-10c6cadb0f29",
        "parentId" : null,
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "Group -> Grouper\n",
        "createdAt" : "2014-03-17T12:42:29Z",
        "updatedAt" : "2014-03-17T12:42:29Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      }
    ],
    "commit" : "5e965e956b2c420bfbd1b424967b46cd29e00459",
    "line" : 21,
    "diffHunk" : "@@ -1,1 +157,161 @@    Examples\n    --------\n    df.groupby(Group(key='A')) : syntatic sugar for df.groupby('A')\n    df.groupby(Group(key='date',freq='60s')) : specify a resample on the column 'date'\n    df.groupby(Group(level='date',freq='60s',axis=1)) :"
  },
  {
    "id" : "d7d7f057-e5a0-45cb-9881-968e1a4590dd",
    "prId" : 6516,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ff1cf8a7-fc0d-4b6f-94c9-88a472621f70",
        "parentId" : null,
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "`axis` arg is missing\n",
        "createdAt" : "2014-03-17T12:43:06Z",
        "updatedAt" : "2014-03-17T12:43:06Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      }
    ],
    "commit" : "5e965e956b2c420bfbd1b424967b46cd29e00459",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +149,153 @@    level : name, int level number, default None\n    freq : string / freqency object, default None\n    sort : boolean, whether to sort the resulting labels, default True\n\n    Returns"
  },
  {
    "id" : "eb5e2eb0-aa5f-4227-93f4-dbe3764fb5b8",
    "prId" : 6578,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "31fa45fe-cf13-477b-ba0d-07cd516c5573",
        "parentId" : null,
        "authorId" : "aeb7e171-52e2-4faa-8a7c-32d6a9d2c2be",
        "body" : "@jreback Thinking about this, do you know if there is a helper function in loc already that might be better than this hack?\n",
        "createdAt" : "2014-03-09T19:16:34Z",
        "updatedAt" : "2014-03-09T20:33:00Z",
        "lastEditedBy" : "aeb7e171-52e2-4faa-8a7c-32d6a9d2c2be",
        "tags" : [
        ]
      }
    ],
    "commit" : "6968da80b29dea7a5226d5737b8836d032e330a3",
    "line" : 8,
    "diffHunk" : "@@ -1,1 +2571,2575 @@        if isinstance(key, (list, tuple, Series, np.ndarray)):\n            if len(self.obj.columns.intersection(key)) != len(key):\n                bad_keys = list(set(key).difference(self.obj.columns))\n                raise KeyError(\"Columns not found: %s\"\n                               % str(bad_keys)[1:-1])"
  },
  {
    "id" : "0ec004a3-1c86-491b-86ec-7c3cfbb2f465",
    "prId" : 6914,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c5988d1d-218c-41e3-9457-37163ef158f2",
        "parentId" : null,
        "authorId" : "aeb7e171-52e2-4faa-8a7c-32d6a9d2c2be",
        "body" : "Does this assume each group is contiguous / sorted?\n\nI have a feeling there is a more efficient way to do this get this out, @jreback ?\n",
        "createdAt" : "2014-04-21T06:03:02Z",
        "updatedAt" : "2014-04-24T10:27:13Z",
        "lastEditedBy" : "aeb7e171-52e2-4faa-8a7c-32d6a9d2c2be",
        "tags" : [
        ]
      },
      {
        "id" : "9db8d1c3-1210-422c-b5ba-8458f783c656",
        "parentId" : "c5988d1d-218c-41e3-9457-37163ef158f2",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "I think this is what `_groupby_indices` does (a cython routine). also make an example that has an unsorted bins for testing as well.\n",
        "createdAt" : "2014-04-21T12:21:07Z",
        "updatedAt" : "2014-04-24T10:27:13Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "7613e401-ad5d-4384-8c64-bfb9686dfad9",
        "parentId" : "c5988d1d-218c-41e3-9457-37163ef158f2",
        "authorId" : "2bab095f-50fb-401e-ab9e-c09e00e2b00c",
        "body" : "I understand that `binlabels` and `bins` are always sorted before passed to `BinGrouper`. Is it incorrect?\n",
        "createdAt" : "2014-04-22T13:11:11Z",
        "updatedAt" : "2014-04-24T10:27:13Z",
        "lastEditedBy" : "2bab095f-50fb-401e-ab9e-c09e00e2b00c",
        "tags" : [
        ]
      },
      {
        "id" : "383fb5c6-1868-4b5c-99f6-4c6fbcbc7b8b",
        "parentId" : "c5988d1d-218c-41e3-9457-37163ef158f2",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "I _think_ so. in any event, does not `_groupby_indices` work?\n",
        "createdAt" : "2014-04-22T13:14:41Z",
        "updatedAt" : "2014-04-24T10:27:13Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "e2fb2791-5b49-46e8-b2da-f027c3d08d65",
        "parentId" : "c5988d1d-218c-41e3-9457-37163ef158f2",
        "authorId" : "2bab095f-50fb-401e-ab9e-c09e00e2b00c",
        "body" : "Following is the `_groupby_indices` result. It returns correct index even if the input is not sorted?\n\n```\n>>> import pandas.algos as _algos\n>>> import pandas.core.common as com\n>>> values = ['A', 'A', 'A', 'A', 'A', 'B', 'B', 'C']\n>>> _algos.groupby_indices(com._ensure_object(values))\n{'A': array([0, 1, 2, 3, 4]), 'C': array([7]), 'B': array([5, 6])}\n\n>>> values = ['B', 'B', 'C', 'A', 'A', 'A', 'A', 'A']\n>>> _algos.groupby_indices(com._ensure_object(values))\n{'A': array([3, 4, 5, 6, 7]), 'C': array([2]), 'B': array([0, 1])}\n```\n\nBut `BinGrouper` doesn't know actual data index by itself, so I'm not sure what results are actually correct. Should it return the same indices regardless of `bins` order?\n",
        "createdAt" : "2014-04-22T14:05:53Z",
        "updatedAt" : "2014-04-24T10:27:13Z",
        "lastEditedBy" : "2bab095f-50fb-401e-ab9e-c09e00e2b00c",
        "tags" : [
        ]
      },
      {
        "id" : "9e04543f-a5ba-4f5e-b8b5-2bdc83049ef0",
        "parentId" : "c5988d1d-218c-41e3-9457-37163ef158f2",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "you can just put in an assert in the code, run the test suite and see if the bins are never not monotnic\n\ne.g.\n\n`assertIsTrue(Index(bins).is_monotonic)`\n(we don't want this is production code, but ok to figure it out)\n",
        "createdAt" : "2014-04-22T14:09:37Z",
        "updatedAt" : "2014-04-24T10:27:13Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "f6dfa4d8-b9dd-4adc-b40b-d85971cc632c",
        "parentId" : "c5988d1d-218c-41e3-9457-37163ef158f2",
        "authorId" : "2bab095f-50fb-401e-ab9e-c09e00e2b00c",
        "body" : "OK. Bins are never be non-monotonic during current tests. For future precaution, `BinGrouper.__init__` should raise an error when non-monotonic bins are passed?\n\nOtherwise, I think my update has been done.\n",
        "createdAt" : "2014-04-24T10:52:40Z",
        "updatedAt" : "2014-04-24T10:52:40Z",
        "lastEditedBy" : "2bab095f-50fb-401e-ab9e-c09e00e2b00c",
        "tags" : [
        ]
      },
      {
        "id" : "41f0bdab-1b9f-4d1e-b5dc-625d386cab87",
        "parentId" : "c5988d1d-218c-41e3-9457-37163ef158f2",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "just make a comment to that effect. I don't think its necessary to check (as its a bit expensive to check monotonicity)\n\ndid you get `_groupby_indicies` to work?\n",
        "createdAt" : "2014-04-24T11:58:06Z",
        "updatedAt" : "2014-04-24T11:58:06Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "db9c0cce-cb9d-4adf-89c6-51fb3bd6856c",
        "parentId" : "c5988d1d-218c-41e3-9457-37163ef158f2",
        "authorId" : "2bab095f-50fb-401e-ab9e-c09e00e2b00c",
        "body" : "I'm not sure what should be confirmed. `groupby._groupby_indices` looks called from `Grouping`, but `Grouping` is not used during `TimeGrouper` process? \n\nIf I call the function directly, I get following results.\n\n```\nimport pandas as pd\nidx = pd.DatetimeIndex(start='2013-01-31', freq='M', periods=12)\nb = pd.core.groupby.BinGrouper([2, 2, 2, 2, 2, 2, 2, 2, 2, 6, 6, 8], idx)\n\npd.core.groupby._groupby_indices(b)\nTypeError: len() of unsized object\n\npd.core.groupby._groupby_indices(b.bins)\n{8: array([11]), 2: array([0, 1, 2, 3, 4, 5, 6, 7, 8]), 6: array([ 9, 10])}\n```\n\nCould you show me your expectation?\n",
        "createdAt" : "2014-04-25T18:14:47Z",
        "updatedAt" : "2014-04-25T18:14:47Z",
        "lastEditedBy" : "2bab095f-50fb-401e-ab9e-c09e00e2b00c",
        "tags" : [
        ]
      },
      {
        "id" : "996fe3e3-4315-4cb9-bc21-7a6202db8854",
        "parentId" : "c5988d1d-218c-41e3-9457-37163ef158f2",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "and isn't result what your routine does?\n",
        "createdAt" : "2014-04-25T19:06:57Z",
        "updatedAt" : "2014-04-25T19:06:57Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "e5021dc8-798d-470e-bab5-162702c87638",
        "parentId" : "c5988d1d-218c-41e3-9457-37163ef158f2",
        "authorId" : "2bab095f-50fb-401e-ab9e-c09e00e2b00c",
        "body" : "Yes, different. `BinGrouper.indices` must be a dict which key is timestamp. The logic cannot be replaced with `_groupby_indices`.\n\n```\n>>> b.indices\ndefaultdict(<type 'list'>, {Timestamp('2013-12-31 00:00:00', offset='M'): [6, 7], Timestamp('2013-10-31 00:00:00', offset='M'): [2, 3, 4, 5], Timestamp('2013-01-31 00:00:00', offset='M'): [0, 1]})\n```\n",
        "createdAt" : "2014-04-25T23:09:43Z",
        "updatedAt" : "2014-04-25T23:09:43Z",
        "lastEditedBy" : "2bab095f-50fb-401e-ab9e-c09e00e2b00c",
        "tags" : [
        ]
      },
      {
        "id" : "dae4ac34-b9c2-4ab4-96cf-4153916bc850",
        "parentId" : "c5988d1d-218c-41e3-9457-37163ef158f2",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "use `_get_indicies_dict`; don't reinvent the wheel here\n",
        "createdAt" : "2014-04-27T15:20:12Z",
        "updatedAt" : "2014-04-27T15:20:12Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "b28784e8-a08c-4c5d-b02a-c4f50dde4dc0",
        "parentId" : "c5988d1d-218c-41e3-9457-37163ef158f2",
        "authorId" : "2bab095f-50fb-401e-ab9e-c09e00e2b00c",
        "body" : "I think using `_get_indices_dict` is not easy, because `BinGrouper` doesn't have information which can be passed to the function as it is.\n\n```\n>>> import pandas as pd\n>>> import datetime\n>>> from pandas.core.groupby import GroupBy, _get_indices_dict\n\n>>> df = pd.DataFrame({'Branch' : 'A A A A A A A B'.split(),\n                   'Buyer': 'Carl Mark Carl Carl Joe Joe Joe Carl'.split(),\n                   'Quantity': [1,3,5,1,8,1,9,3],\n                   'Date' : [\n                    datetime.datetime(2013,1,1,13,0), datetime.datetime(2013,1,1,13,5),\n                    datetime.datetime(2013,10,1,20,0), datetime.datetime(2013,10,2,10,0),\n                    datetime.datetime(2013,10,1,20,0), datetime.datetime(2013,10,2,10,0),\n                    datetime.datetime(2013,12,2,12,0), datetime.datetime(2013,12,2,14,0),]})\n\n>>> grouped = df.groupby(pd.Grouper(freq='1M',key='Date'))\n>>> grouped.grouper.bins\n[2 2 2 2 2 2 2 2 2 6 6 8]\n>>> grouped.grouper.binlabels\n<class 'pandas.tseries.index.DatetimeIndex'>\n[2013-01-31, ..., 2013-12-31]\nLength: 12, Freq: M, Timezone: None\n```\n\nThus, I have to convert it using the similar logic as current implementation.\n\n```\n>>> indices = []\n>>> i = 0\n>>> for j, bin in enumerate(grouped.grouper.bins):\n>>>     if i < bin:\n>>>         indices.extend([j] * (bin - i))\n>>>         i = bin\n>>> indices = np.array(indices)\n>>> indices\n[ 0  0  9  9  9  9 11 11]\n```\n\nAnd `_get_indices_dict` returns keys as tuple, further conversion required.\n\n```\n>>> _get_indices_dict([indices], [grouped.grouper.binlabels])\n{(numpy.datetime64('2013-10-31T09:00:00.000000000+0900'),): array([2, 3, 4, 5]), (numpy.datetime64('2013-12-31T09:00:00.000000000+0900'),): array([6, 7]), (numpy.datetime64('2013-01-31T09:00:00.000000000+0900'),): array([0, 1])}\n```\n\nDo you have better logic?\n",
        "createdAt" : "2014-04-28T13:46:34Z",
        "updatedAt" : "2014-04-28T13:46:34Z",
        "lastEditedBy" : "2bab095f-50fb-401e-ab9e-c09e00e2b00c",
        "tags" : [
        ]
      },
      {
        "id" : "cfe9daf1-af4b-462a-ba48-4a2094593117",
        "parentId" : "c5988d1d-218c-41e3-9457-37163ef158f2",
        "authorId" : "aeb7e171-52e2-4faa-8a7c-32d6a9d2c2be",
        "body" : "Can we not do something like (?):\n\n```\n{g.grouper.levels[k] for k, v in pd.core.groupby._groupby_indices(b.bins).iteritems()}\n```\n\n_may_ be faster...\n",
        "createdAt" : "2014-04-29T00:34:39Z",
        "updatedAt" : "2014-04-29T00:34:39Z",
        "lastEditedBy" : "aeb7e171-52e2-4faa-8a7c-32d6a9d2c2be",
        "tags" : [
        ]
      },
      {
        "id" : "22ce0a39-4a7f-4c39-9890-3d91acb6138d",
        "parentId" : "c5988d1d-218c-41e3-9457-37163ef158f2",
        "authorId" : "2bab095f-50fb-401e-ab9e-c09e00e2b00c",
        "body" : "Thanks, but failed in test. I think simply passing `bins` to existing method shouldn't work, because `bins` are corresponding to frequencies to be split, not index. Thus its length can differ from index.\n\nUsing dataframe in above example, returnes values are different from expected.\n\n```\n>>> list(pd.core.groupby._groupby_indices(grouped.grouper.bins).iteritems())\n[(8, array([11])), (2, array([0, 1, 2, 3, 4, 5, 6, 7, 8])), (6, array([ 9, 10]))]\n```\n\n```\n```\n",
        "createdAt" : "2014-04-30T14:58:52Z",
        "updatedAt" : "2014-04-30T14:58:52Z",
        "lastEditedBy" : "2bab095f-50fb-401e-ab9e-c09e00e2b00c",
        "tags" : [
        ]
      }
    ],
    "commit" : "85157f0076f0b41f8c1a667b79a0e1220922a270",
    "line" : 19,
    "diffHunk" : "@@ -1,1 +1566,1570 @@            if i < bin:\n                indices[label] = list(range(i, bin))\n                i = bin\n        return indices\n"
  },
  {
    "id" : "c81cbca8-a75f-4b87-8b77-711542cb7172",
    "prId" : 7000,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e1ef1749-ba0f-4dd0-ab89-e8c053968020",
        "parentId" : null,
        "authorId" : "aeb7e171-52e2-4faa-8a7c-32d6a9d2c2be",
        "body" : "a much simpler way to solve the upcasting!\n",
        "createdAt" : "2014-04-29T17:15:12Z",
        "updatedAt" : "2014-04-29T18:47:12Z",
        "lastEditedBy" : "aeb7e171-52e2-4faa-8a7c-32d6a9d2c2be",
        "tags" : [
        ]
      }
    ],
    "commit" : "134dd1f7cc1a521a1da84ea666c5a62da2e1d30a",
    "line" : 110,
    "diffHunk" : "@@ -1,1 +721,725 @@        \"\"\"\n        self._set_selection_from_grouper()\n        return self._python_agg_general(lambda x: notnull(x).sum(axis=axis)).astype('int64')\n\n    sum = _groupby_function('sum', 'add', np.sum)"
  },
  {
    "id" : "f8f2843d-9acd-420e-9f3a-011f6162196a",
    "prId" : 7600,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "62d1f9e3-6448-4813-a4a2-2d8278eb123b",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "why are you not using `value_counts`? this should be very similar (if not call irectly), BaseGrouper.size\n",
        "createdAt" : "2014-06-28T14:11:08Z",
        "updatedAt" : "2014-06-30T10:44:28Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "af49a2f9-b558-4922-a476-be93a1adf0f0",
        "parentId" : "62d1f9e3-6448-4813-a4a2-2d8278eb123b",
        "authorId" : "2bab095f-50fb-401e-ab9e-c09e00e2b00c",
        "body" : "There are 2 reasons.\n- `value_counts` cannot fulfill intermediate timestamps which is not included in the group key. For example, if the `TimeGrouper` categorize `[2011-01-01, 2011-01-02, 2011-01-04]` with daily frequency, the resulted group keys must be `[2011-01-01, 2011-01-02, 2011-01-03, 2011-01-04]`\n- `BinGrouper` doesn't retain original `Index` to be directly passed to `value_counts`. To use `value_counts`, it must be created using similar logic.\n\n```\nindices = self.indices\nlabels = []\nfor k, v in compat.iteritems(indices):\n            labels.extend([k] * len(v))\nvalue_counts(labels)\n```\n",
        "createdAt" : "2014-06-28T14:44:02Z",
        "updatedAt" : "2014-06-30T10:44:28Z",
        "lastEditedBy" : "2bab095f-50fb-401e-ab9e-c09e00e2b00c",
        "tags" : [
        ]
      }
    ],
    "commit" : "eb2cd0459a348e813648b05612c71e42b95b139c",
    "line" : 16,
    "diffHunk" : "@@ -1,1 +1667,1671 @@        return [self.binlabels.name]\n\n    def size(self):\n        \"\"\"\n        Compute group sizes"
  },
  {
    "id" : "1a8f9567-332e-4ce6-8c70-058f4e84f223",
    "prId" : 8171,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4c96f1a6-64cf-4efb-a8f1-cec09c2f819b",
        "parentId" : null,
        "authorId" : "aeb7e171-52e2-4faa-8a7c-32d6a9d2c2be",
        "body" : "it seems strange that this used to try size first (I thought I commented earlier but guess not), how did this work before??\n",
        "createdAt" : "2014-09-04T01:41:14Z",
        "updatedAt" : "2014-09-06T17:57:47Z",
        "lastEditedBy" : "aeb7e171-52e2-4faa-8a7c-32d6a9d2c2be",
        "tags" : [
        ]
      },
      {
        "id" : "3e4fa123-2c98-4ac5-b812-4c352f1c03ab",
        "parentId" : "4c96f1a6-64cf-4efb-a8f1-cec09c2f819b",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "I think this only gets hit (the compat) if we don't have the cython defined (eg it's not object/int64/float64) - so rarely gets hit (maybe just should always upcast) instead?\n",
        "createdAt" : "2014-09-04T01:54:48Z",
        "updatedAt" : "2014-09-06T17:57:47Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "719e8837-2ef6-4c65-9ce2-f579d38b70fb",
        "parentId" : "4c96f1a6-64cf-4efb-a8f1-cec09c2f819b",
        "authorId" : "aeb7e171-52e2-4faa-8a7c-32d6a9d2c2be",
        "body" : "yeah, have a feeling this exception would never raise (if it did wouldn't there be inf. recursion?? as count calls _count_compat...), I don't follow this code at all (need tests + coverage!).\n",
        "createdAt" : "2014-09-04T05:00:42Z",
        "updatedAt" : "2014-09-06T17:57:47Z",
        "lastEditedBy" : "aeb7e171-52e2-4faa-8a7c-32d6a9d2c2be",
        "tags" : [
        ]
      },
      {
        "id" : "42fd5e84-2b1c-4b06-9c28-fec5558530f4",
        "parentId" : "4c96f1a6-64cf-4efb-a8f1-cec09c2f819b",
        "authorId" : "93252f0a-20fd-4fff-a21f-b220eed58210",
        "body" : "What happens is that [this](https://github.com/pydata/pandas/blob/59c175f9e582c5b2466e46b2842d5929fdf7db19/pandas/core/groupby.py#L1528) line produces completely valid result, but with `float32` type, which causes type error in [this](https://github.com/pydata/pandas/blob/59c175f9e582c5b2466e46b2842d5929fdf7db19/pandas/core/groupby.py#L1533) line which expects `float64`, but the catch phrase also throws because `float32` array is not of type `object` either. i.e. neither of `lib.row_bool_subset` and `lib.row_bool_subset_object` can handle an array of type `float32`, and even though the `result` array is already correct, there will be an exception here.\n\nThis ultimately falls back on `_count_compat` which  produces the wrong result. \n",
        "createdAt" : "2014-09-04T15:22:33Z",
        "updatedAt" : "2014-09-06T17:57:47Z",
        "lastEditedBy" : "93252f0a-20fd-4fff-a21f-b220eed58210",
        "tags" : [
        ]
      },
      {
        "id" : "506e3d68-d886-40dd-8f40-49136bb8ecc9",
        "parentId" : "4c96f1a6-64cf-4efb-a8f1-cec09c2f819b",
        "authorId" : "aeb7e171-52e2-4faa-8a7c-32d6a9d2c2be",
        "body" : "@behzadnouri  just for completeness: I was asking if you had _just_ changed this line what would happen? (I'll just try it - I have a few pandas PRs to do anyway!)\n",
        "createdAt" : "2014-09-04T19:37:53Z",
        "updatedAt" : "2014-09-06T17:57:47Z",
        "lastEditedBy" : "aeb7e171-52e2-4faa-8a7c-32d6a9d2c2be",
        "tags" : [
        ]
      },
      {
        "id" : "fc5ec429-cbe6-409c-8ba8-1a9aee45eccf",
        "parentId" : "4c96f1a6-64cf-4efb-a8f1-cec09c2f819b",
        "authorId" : "93252f0a-20fd-4fff-a21f-b220eed58210",
        "body" : "@hayd if i had just changed that line, the result would be correct, but recalculated twice, once in [here](https://github.com/pydata/pandas/blob/59c175f9e582c5b2466e46b2842d5929fdf7db19/pandas/core/groupby.py#L1528) and once in `_count_compat`\n",
        "createdAt" : "2014-09-04T20:18:22Z",
        "updatedAt" : "2014-09-06T17:57:47Z",
        "lastEditedBy" : "93252f0a-20fd-4fff-a21f-b220eed58210",
        "tags" : [
        ]
      }
    ],
    "commit" : "70ec9211cc089f7102a7cefcaa1722290dc388bc",
    "line" : 8,
    "diffHunk" : "@@ -1,1 +148,152 @@\ndef _count_compat(x, axis=0):\n    return x.count()  # .size != .count(); count excludes nan\n\nclass Grouper(object):"
  }
]
[
  {
    "id" : "865d591c-09e1-4007-b5df-ced6019218fb",
    "prId" : 4092,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "40c484f3-8755-4320-b563-73eb1b4fff78",
        "parentId" : null,
        "authorId" : "5c239b83-5a68-467b-a3f8-113a0fc494dc",
        "body" : "would love this, maybe an issue?\n",
        "createdAt" : "2013-07-01T03:07:34Z",
        "updatedAt" : "2013-07-01T22:09:33Z",
        "lastEditedBy" : "5c239b83-5a68-467b-a3f8-113a0fc494dc",
        "tags" : [
        ]
      },
      {
        "id" : "a393908f-28fb-48e1-8053-d53fcc011726",
        "parentId" : "40c484f3-8755-4320-b563-73eb1b4fff78",
        "authorId" : "6f890fbc-4bdf-4397-95eb-a8225d4af04f",
        "body" : "What would you want it to show? calculates values on the fly right - so probably just keys?\n",
        "createdAt" : "2013-07-01T03:13:47Z",
        "updatedAt" : "2013-07-01T22:09:33Z",
        "lastEditedBy" : "6f890fbc-4bdf-4397-95eb-a8225d4af04f",
        "tags" : [
        ]
      },
      {
        "id" : "d85a76ce-8d4d-42b1-a1f4-6d0ef5864b6e",
        "parentId" : "40c484f3-8755-4320-b563-73eb1b4fff78",
        "authorId" : "5c239b83-5a68-467b-a3f8-113a0fc494dc",
        "body" : "yeah gb is lazy so yeah keys i guess. just something more informative than the object repr\n",
        "createdAt" : "2013-07-01T03:24:45Z",
        "updatedAt" : "2013-07-01T22:09:33Z",
        "lastEditedBy" : "5c239b83-5a68-467b-a3f8-113a0fc494dc",
        "tags" : [
        ]
      }
    ],
    "commit" : "a5583141404ddf91516e70dade7942c315cb3646",
    "line" : 22,
    "diffHunk" : "@@ -1,1 +204,208 @@\n    def __unicode__(self):\n        # TODO: Better unicode/repr for GroupBy object\n        return object.__repr__(self)\n"
  },
  {
    "id" : "b7782fef-f59f-4774-8f23-b3074057db9e",
    "prId" : 4670,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "01c731f8-90cb-4acc-9cc0-75872883b956",
        "parentId" : null,
        "authorId" : "aeb7e171-52e2-4faa-8a7c-32d6a9d2c2be",
        "body" : "@cpcloud this seemed to do it!\n",
        "createdAt" : "2013-08-25T22:28:11Z",
        "updatedAt" : "2013-08-25T22:28:11Z",
        "lastEditedBy" : "aeb7e171-52e2-4faa-8a7c-32d6a9d2c2be",
        "tags" : [
        ]
      }
    ],
    "commit" : "e8530dfbe30a493e351dca57e9afd9c7c97d5805",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +517,521 @@            else:\n                result = result.reindex_axis(ax, axis=self.axis)\n        elif self.group_keys and self.as_index:\n            group_keys = keys\n            group_levels = self.grouper.levels"
  },
  {
    "id" : "eadd2821-3ac3-473c-9f36-f739d19e9086",
    "prId" : 5096,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "46b72e56-1bb4-4d4a-a70b-15103aa7808f",
        "parentId" : null,
        "authorId" : "5c239b83-5a68-467b-a3f8-113a0fc494dc",
        "body" : "should this `and` be `&`? can `b` be an array/frame/series?\n",
        "createdAt" : "2013-10-10T04:49:42Z",
        "updatedAt" : "2013-10-13T15:03:27Z",
        "lastEditedBy" : "5c239b83-5a68-467b-a3f8-113a0fc494dc",
        "tags" : [
        ]
      },
      {
        "id" : "73955b23-d630-4c1e-8fed-23ee1777feb1",
        "parentId" : "46b72e56-1bb4-4d4a-a70b-15103aa7808f",
        "authorId" : "69bb3c84-e6a9-46c9-8328-ad025ce4150d",
        "body" : "I think it has to be `and` in order to handle `NaN`, which we want to interpret as False. Thoughts, @cpcloud?\n\n```\nIn [59]: np.nan & pd.notnull(np.nan)\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\n<ipython-input-59-47e0df96d143> in <module>()\n----> 1 np.nan & pd.notnull(np.nan)\n\nTypeError: unsupported operand type(s) for &: 'float' and 'bool'\n\nIn [60]: np.nan and pd.notnull(np.nan)\nOut[60]: False\n```\n",
        "createdAt" : "2013-10-13T14:36:06Z",
        "updatedAt" : "2013-10-13T15:03:27Z",
        "lastEditedBy" : "69bb3c84-e6a9-46c9-8328-ad025ce4150d",
        "tags" : [
        ]
      }
    ],
    "commit" : "889b9f2447137a32857613a95d2b363020216c41",
    "line" : 18,
    "diffHunk" : "@@ -1,1 +1609,1613 @@        def true_and_notnull(x, *args, **kwargs):\n            b = wrapper(x, *args, **kwargs)\n            return b and notnull(b)\n\n        try:"
  },
  {
    "id" : "5b2bcea7-b4bf-4c28-b556-7d7d997fdd5a",
    "prId" : 5231,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e6fc2aca-c9d0-4ed3-b09b-8f4ae3c2489e",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "not sure why `_lexsort_indexer` is even in groupby.py only uses in series/frame. can you move to `algos.py`?\n",
        "createdAt" : "2014-03-11T02:01:17Z",
        "updatedAt" : "2014-03-27T20:57:49Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "3230ed4bd75ff5f2f016ac1e07def7ebbb432885",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +3146,3150 @@\n\ndef _lexsort_indexer(keys, orders=None, na_position='last'):\n    labels = []\n    shape = []"
  },
  {
    "id" : "346f85f1-634f-4e09-898b-f95024db399c",
    "prId" : 5231,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e63358e2-f04a-4ae5-8992-fa2814dba357",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "move to `algos.py` as well\n",
        "createdAt" : "2014-03-11T02:01:29Z",
        "updatedAt" : "2014-03-27T20:57:49Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "47d02957-9d4a-483d-aef7-fe6b306735c9",
        "parentId" : "e63358e2-f04a-4ae5-8992-fa2814dba357",
        "authorId" : "49cb7e4b-934a-4329-961e-4089057c4185",
        "body" : "Do you mean core/algorithms.py? or algos.pyx?\n",
        "createdAt" : "2014-03-11T02:05:13Z",
        "updatedAt" : "2014-03-27T20:57:49Z",
        "lastEditedBy" : "49cb7e4b-934a-4329-961e-4089057c4185",
        "tags" : [
        ]
      },
      {
        "id" : "1520485a-e705-41a8-bf71-93f31f978d8e",
        "parentId" : "e63358e2-f04a-4ae5-8992-fa2814dba357",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "yes...that's what I meant!\n",
        "createdAt" : "2014-03-11T02:06:38Z",
        "updatedAt" : "2014-03-27T20:57:49Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "956f5912-b8a2-4612-b171-6c5ee49260ca",
        "parentId" : "e63358e2-f04a-4ae5-8992-fa2814dba357",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "wait...nvm....I realize this is being called internall in groupby.py\n",
        "createdAt" : "2014-03-11T02:08:39Z",
        "updatedAt" : "2014-03-27T20:57:49Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "3230ed4bd75ff5f2f016ac1e07def7ebbb432885",
    "line" : 51,
    "diffHunk" : "@@ -1,1 +3185,3189 @@    return _indexer_from_factorized(labels, shape)\n\ndef _nargsort(items, kind='quicksort', ascending=True, na_position='last'):\n    \"\"\"\n    This is intended to be a drop-in replacement for np.argsort which handles NaNs"
  },
  {
    "id" : "a7b226af-df0b-4fc8-b7de-5bcb5728c8fd",
    "prId" : 5510,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "542ca5da-0f77-445e-b802-2b2a7e61f63b",
        "parentId" : null,
        "authorId" : "6f890fbc-4bdf-4397-95eb-a8225d4af04f",
        "body" : "mind removing this blank line if you're editing this?\n",
        "createdAt" : "2013-11-14T00:18:26Z",
        "updatedAt" : "2013-11-14T19:18:52Z",
        "lastEditedBy" : "6f890fbc-4bdf-4397-95eb-a8225d4af04f",
        "tags" : [
        ]
      },
      {
        "id" : "74b5c5c2-cb67-4976-a0ad-50b2ae27c030",
        "parentId" : "542ca5da-0f77-445e-b802-2b2a7e61f63b",
        "authorId" : "aeb7e171-52e2-4faa-8a7c-32d6a9d2c2be",
        "body" : "I added it in specifically, pep8 says it should be there, right?\n",
        "createdAt" : "2013-11-14T00:18:46Z",
        "updatedAt" : "2013-11-14T19:18:52Z",
        "lastEditedBy" : "aeb7e171-52e2-4faa-8a7c-32d6a9d2c2be",
        "tags" : [
        ]
      },
      {
        "id" : "dc0cb7af-042f-4093-a26d-bd3733d75229",
        "parentId" : "542ca5da-0f77-445e-b802-2b2a7e61f63b",
        "authorId" : "6f890fbc-4bdf-4397-95eb-a8225d4af04f",
        "body" : "okay, no idea.\n",
        "createdAt" : "2013-11-14T00:24:59Z",
        "updatedAt" : "2013-11-14T19:18:52Z",
        "lastEditedBy" : "6f890fbc-4bdf-4397-95eb-a8225d4af04f",
        "tags" : [
        ]
      }
    ],
    "commit" : "b56479879bb4e0fccdb23497e2073c201481aad7",
    "line" : 55,
    "diffHunk" : "@@ -1,1 +523,527 @@        try to cast the result to our obj original type,\n        we may have roundtripped thru object in the mean-time\n\n        \"\"\"\n        if obj.ndim > 1:"
  },
  {
    "id" : "96a44882-e2f7-41ce-a4a4-9e03ce0c1dea",
    "prId" : 6516,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f76d21f7-1a43-465c-a6a4-2e00d1eec8ab",
        "parentId" : null,
        "authorId" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "body" : "@jreback is this `elif` supposed to be shifted left to be under the `if` at line 226?\n",
        "createdAt" : "2014-03-16T15:07:01Z",
        "updatedAt" : "2014-03-16T15:07:01Z",
        "lastEditedBy" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "tags" : [
        ]
      }
    ],
    "commit" : "5e965e956b2c420bfbd1b424967b46cd29e00459",
    "line" : 99,
    "diffHunk" : "@@ -1,1 +235,239 @@                            raise ValueError('level name %s is not the name of the '\n                                             'index' % level)\n                    elif level > 0:\n                        raise ValueError('level > 0 only valid with MultiIndex')\n                    ax = Index(ax.get_level_values(level), name=level)"
  },
  {
    "id" : "b0a13c94-c947-44c9-9f7f-7be746b27c25",
    "prId" : 6516,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2b083f3b-0de9-4821-b784-10c6cadb0f29",
        "parentId" : null,
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "Group -> Grouper\n",
        "createdAt" : "2014-03-17T12:42:29Z",
        "updatedAt" : "2014-03-17T12:42:29Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      }
    ],
    "commit" : "5e965e956b2c420bfbd1b424967b46cd29e00459",
    "line" : 21,
    "diffHunk" : "@@ -1,1 +157,161 @@    Examples\n    --------\n    df.groupby(Group(key='A')) : syntatic sugar for df.groupby('A')\n    df.groupby(Group(key='date',freq='60s')) : specify a resample on the column 'date'\n    df.groupby(Group(level='date',freq='60s',axis=1)) :"
  },
  {
    "id" : "d7d7f057-e5a0-45cb-9881-968e1a4590dd",
    "prId" : 6516,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ff1cf8a7-fc0d-4b6f-94c9-88a472621f70",
        "parentId" : null,
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "`axis` arg is missing\n",
        "createdAt" : "2014-03-17T12:43:06Z",
        "updatedAt" : "2014-03-17T12:43:06Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      }
    ],
    "commit" : "5e965e956b2c420bfbd1b424967b46cd29e00459",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +149,153 @@    level : name, int level number, default None\n    freq : string / freqency object, default None\n    sort : boolean, whether to sort the resulting labels, default True\n\n    Returns"
  },
  {
    "id" : "eb5e2eb0-aa5f-4227-93f4-dbe3764fb5b8",
    "prId" : 6578,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "31fa45fe-cf13-477b-ba0d-07cd516c5573",
        "parentId" : null,
        "authorId" : "aeb7e171-52e2-4faa-8a7c-32d6a9d2c2be",
        "body" : "@jreback Thinking about this, do you know if there is a helper function in loc already that might be better than this hack?\n",
        "createdAt" : "2014-03-09T19:16:34Z",
        "updatedAt" : "2014-03-09T20:33:00Z",
        "lastEditedBy" : "aeb7e171-52e2-4faa-8a7c-32d6a9d2c2be",
        "tags" : [
        ]
      }
    ],
    "commit" : "6968da80b29dea7a5226d5737b8836d032e330a3",
    "line" : 8,
    "diffHunk" : "@@ -1,1 +2571,2575 @@        if isinstance(key, (list, tuple, Series, np.ndarray)):\n            if len(self.obj.columns.intersection(key)) != len(key):\n                bad_keys = list(set(key).difference(self.obj.columns))\n                raise KeyError(\"Columns not found: %s\"\n                               % str(bad_keys)[1:-1])"
  },
  {
    "id" : "0ec004a3-1c86-491b-86ec-7c3cfbb2f465",
    "prId" : 6914,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c5988d1d-218c-41e3-9457-37163ef158f2",
        "parentId" : null,
        "authorId" : "aeb7e171-52e2-4faa-8a7c-32d6a9d2c2be",
        "body" : "Does this assume each group is contiguous / sorted?\n\nI have a feeling there is a more efficient way to do this get this out, @jreback ?\n",
        "createdAt" : "2014-04-21T06:03:02Z",
        "updatedAt" : "2014-04-24T10:27:13Z",
        "lastEditedBy" : "aeb7e171-52e2-4faa-8a7c-32d6a9d2c2be",
        "tags" : [
        ]
      },
      {
        "id" : "9db8d1c3-1210-422c-b5ba-8458f783c656",
        "parentId" : "c5988d1d-218c-41e3-9457-37163ef158f2",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "I think this is what `_groupby_indices` does (a cython routine). also make an example that has an unsorted bins for testing as well.\n",
        "createdAt" : "2014-04-21T12:21:07Z",
        "updatedAt" : "2014-04-24T10:27:13Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "7613e401-ad5d-4384-8c64-bfb9686dfad9",
        "parentId" : "c5988d1d-218c-41e3-9457-37163ef158f2",
        "authorId" : "2bab095f-50fb-401e-ab9e-c09e00e2b00c",
        "body" : "I understand that `binlabels` and `bins` are always sorted before passed to `BinGrouper`. Is it incorrect?\n",
        "createdAt" : "2014-04-22T13:11:11Z",
        "updatedAt" : "2014-04-24T10:27:13Z",
        "lastEditedBy" : "2bab095f-50fb-401e-ab9e-c09e00e2b00c",
        "tags" : [
        ]
      },
      {
        "id" : "383fb5c6-1868-4b5c-99f6-4c6fbcbc7b8b",
        "parentId" : "c5988d1d-218c-41e3-9457-37163ef158f2",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "I _think_ so. in any event, does not `_groupby_indices` work?\n",
        "createdAt" : "2014-04-22T13:14:41Z",
        "updatedAt" : "2014-04-24T10:27:13Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "e2fb2791-5b49-46e8-b2da-f027c3d08d65",
        "parentId" : "c5988d1d-218c-41e3-9457-37163ef158f2",
        "authorId" : "2bab095f-50fb-401e-ab9e-c09e00e2b00c",
        "body" : "Following is the `_groupby_indices` result. It returns correct index even if the input is not sorted?\n\n```\n>>> import pandas.algos as _algos\n>>> import pandas.core.common as com\n>>> values = ['A', 'A', 'A', 'A', 'A', 'B', 'B', 'C']\n>>> _algos.groupby_indices(com._ensure_object(values))\n{'A': array([0, 1, 2, 3, 4]), 'C': array([7]), 'B': array([5, 6])}\n\n>>> values = ['B', 'B', 'C', 'A', 'A', 'A', 'A', 'A']\n>>> _algos.groupby_indices(com._ensure_object(values))\n{'A': array([3, 4, 5, 6, 7]), 'C': array([2]), 'B': array([0, 1])}\n```\n\nBut `BinGrouper` doesn't know actual data index by itself, so I'm not sure what results are actually correct. Should it return the same indices regardless of `bins` order?\n",
        "createdAt" : "2014-04-22T14:05:53Z",
        "updatedAt" : "2014-04-24T10:27:13Z",
        "lastEditedBy" : "2bab095f-50fb-401e-ab9e-c09e00e2b00c",
        "tags" : [
        ]
      },
      {
        "id" : "9e04543f-a5ba-4f5e-b8b5-2bdc83049ef0",
        "parentId" : "c5988d1d-218c-41e3-9457-37163ef158f2",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "you can just put in an assert in the code, run the test suite and see if the bins are never not monotnic\n\ne.g.\n\n`assertIsTrue(Index(bins).is_monotonic)`\n(we don't want this is production code, but ok to figure it out)\n",
        "createdAt" : "2014-04-22T14:09:37Z",
        "updatedAt" : "2014-04-24T10:27:13Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "f6dfa4d8-b9dd-4adc-b40b-d85971cc632c",
        "parentId" : "c5988d1d-218c-41e3-9457-37163ef158f2",
        "authorId" : "2bab095f-50fb-401e-ab9e-c09e00e2b00c",
        "body" : "OK. Bins are never be non-monotonic during current tests. For future precaution, `BinGrouper.__init__` should raise an error when non-monotonic bins are passed?\n\nOtherwise, I think my update has been done.\n",
        "createdAt" : "2014-04-24T10:52:40Z",
        "updatedAt" : "2014-04-24T10:52:40Z",
        "lastEditedBy" : "2bab095f-50fb-401e-ab9e-c09e00e2b00c",
        "tags" : [
        ]
      },
      {
        "id" : "41f0bdab-1b9f-4d1e-b5dc-625d386cab87",
        "parentId" : "c5988d1d-218c-41e3-9457-37163ef158f2",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "just make a comment to that effect. I don't think its necessary to check (as its a bit expensive to check monotonicity)\n\ndid you get `_groupby_indicies` to work?\n",
        "createdAt" : "2014-04-24T11:58:06Z",
        "updatedAt" : "2014-04-24T11:58:06Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "db9c0cce-cb9d-4adf-89c6-51fb3bd6856c",
        "parentId" : "c5988d1d-218c-41e3-9457-37163ef158f2",
        "authorId" : "2bab095f-50fb-401e-ab9e-c09e00e2b00c",
        "body" : "I'm not sure what should be confirmed. `groupby._groupby_indices` looks called from `Grouping`, but `Grouping` is not used during `TimeGrouper` process? \n\nIf I call the function directly, I get following results.\n\n```\nimport pandas as pd\nidx = pd.DatetimeIndex(start='2013-01-31', freq='M', periods=12)\nb = pd.core.groupby.BinGrouper([2, 2, 2, 2, 2, 2, 2, 2, 2, 6, 6, 8], idx)\n\npd.core.groupby._groupby_indices(b)\nTypeError: len() of unsized object\n\npd.core.groupby._groupby_indices(b.bins)\n{8: array([11]), 2: array([0, 1, 2, 3, 4, 5, 6, 7, 8]), 6: array([ 9, 10])}\n```\n\nCould you show me your expectation?\n",
        "createdAt" : "2014-04-25T18:14:47Z",
        "updatedAt" : "2014-04-25T18:14:47Z",
        "lastEditedBy" : "2bab095f-50fb-401e-ab9e-c09e00e2b00c",
        "tags" : [
        ]
      },
      {
        "id" : "996fe3e3-4315-4cb9-bc21-7a6202db8854",
        "parentId" : "c5988d1d-218c-41e3-9457-37163ef158f2",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "and isn't result what your routine does?\n",
        "createdAt" : "2014-04-25T19:06:57Z",
        "updatedAt" : "2014-04-25T19:06:57Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "e5021dc8-798d-470e-bab5-162702c87638",
        "parentId" : "c5988d1d-218c-41e3-9457-37163ef158f2",
        "authorId" : "2bab095f-50fb-401e-ab9e-c09e00e2b00c",
        "body" : "Yes, different. `BinGrouper.indices` must be a dict which key is timestamp. The logic cannot be replaced with `_groupby_indices`.\n\n```\n>>> b.indices\ndefaultdict(<type 'list'>, {Timestamp('2013-12-31 00:00:00', offset='M'): [6, 7], Timestamp('2013-10-31 00:00:00', offset='M'): [2, 3, 4, 5], Timestamp('2013-01-31 00:00:00', offset='M'): [0, 1]})\n```\n",
        "createdAt" : "2014-04-25T23:09:43Z",
        "updatedAt" : "2014-04-25T23:09:43Z",
        "lastEditedBy" : "2bab095f-50fb-401e-ab9e-c09e00e2b00c",
        "tags" : [
        ]
      },
      {
        "id" : "dae4ac34-b9c2-4ab4-96cf-4153916bc850",
        "parentId" : "c5988d1d-218c-41e3-9457-37163ef158f2",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "use `_get_indicies_dict`; don't reinvent the wheel here\n",
        "createdAt" : "2014-04-27T15:20:12Z",
        "updatedAt" : "2014-04-27T15:20:12Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "b28784e8-a08c-4c5d-b02a-c4f50dde4dc0",
        "parentId" : "c5988d1d-218c-41e3-9457-37163ef158f2",
        "authorId" : "2bab095f-50fb-401e-ab9e-c09e00e2b00c",
        "body" : "I think using `_get_indices_dict` is not easy, because `BinGrouper` doesn't have information which can be passed to the function as it is.\n\n```\n>>> import pandas as pd\n>>> import datetime\n>>> from pandas.core.groupby import GroupBy, _get_indices_dict\n\n>>> df = pd.DataFrame({'Branch' : 'A A A A A A A B'.split(),\n                   'Buyer': 'Carl Mark Carl Carl Joe Joe Joe Carl'.split(),\n                   'Quantity': [1,3,5,1,8,1,9,3],\n                   'Date' : [\n                    datetime.datetime(2013,1,1,13,0), datetime.datetime(2013,1,1,13,5),\n                    datetime.datetime(2013,10,1,20,0), datetime.datetime(2013,10,2,10,0),\n                    datetime.datetime(2013,10,1,20,0), datetime.datetime(2013,10,2,10,0),\n                    datetime.datetime(2013,12,2,12,0), datetime.datetime(2013,12,2,14,0),]})\n\n>>> grouped = df.groupby(pd.Grouper(freq='1M',key='Date'))\n>>> grouped.grouper.bins\n[2 2 2 2 2 2 2 2 2 6 6 8]\n>>> grouped.grouper.binlabels\n<class 'pandas.tseries.index.DatetimeIndex'>\n[2013-01-31, ..., 2013-12-31]\nLength: 12, Freq: M, Timezone: None\n```\n\nThus, I have to convert it using the similar logic as current implementation.\n\n```\n>>> indices = []\n>>> i = 0\n>>> for j, bin in enumerate(grouped.grouper.bins):\n>>>     if i < bin:\n>>>         indices.extend([j] * (bin - i))\n>>>         i = bin\n>>> indices = np.array(indices)\n>>> indices\n[ 0  0  9  9  9  9 11 11]\n```\n\nAnd `_get_indices_dict` returns keys as tuple, further conversion required.\n\n```\n>>> _get_indices_dict([indices], [grouped.grouper.binlabels])\n{(numpy.datetime64('2013-10-31T09:00:00.000000000+0900'),): array([2, 3, 4, 5]), (numpy.datetime64('2013-12-31T09:00:00.000000000+0900'),): array([6, 7]), (numpy.datetime64('2013-01-31T09:00:00.000000000+0900'),): array([0, 1])}\n```\n\nDo you have better logic?\n",
        "createdAt" : "2014-04-28T13:46:34Z",
        "updatedAt" : "2014-04-28T13:46:34Z",
        "lastEditedBy" : "2bab095f-50fb-401e-ab9e-c09e00e2b00c",
        "tags" : [
        ]
      },
      {
        "id" : "cfe9daf1-af4b-462a-ba48-4a2094593117",
        "parentId" : "c5988d1d-218c-41e3-9457-37163ef158f2",
        "authorId" : "aeb7e171-52e2-4faa-8a7c-32d6a9d2c2be",
        "body" : "Can we not do something like (?):\n\n```\n{g.grouper.levels[k] for k, v in pd.core.groupby._groupby_indices(b.bins).iteritems()}\n```\n\n_may_ be faster...\n",
        "createdAt" : "2014-04-29T00:34:39Z",
        "updatedAt" : "2014-04-29T00:34:39Z",
        "lastEditedBy" : "aeb7e171-52e2-4faa-8a7c-32d6a9d2c2be",
        "tags" : [
        ]
      },
      {
        "id" : "22ce0a39-4a7f-4c39-9890-3d91acb6138d",
        "parentId" : "c5988d1d-218c-41e3-9457-37163ef158f2",
        "authorId" : "2bab095f-50fb-401e-ab9e-c09e00e2b00c",
        "body" : "Thanks, but failed in test. I think simply passing `bins` to existing method shouldn't work, because `bins` are corresponding to frequencies to be split, not index. Thus its length can differ from index.\n\nUsing dataframe in above example, returnes values are different from expected.\n\n```\n>>> list(pd.core.groupby._groupby_indices(grouped.grouper.bins).iteritems())\n[(8, array([11])), (2, array([0, 1, 2, 3, 4, 5, 6, 7, 8])), (6, array([ 9, 10]))]\n```\n\n```\n```\n",
        "createdAt" : "2014-04-30T14:58:52Z",
        "updatedAt" : "2014-04-30T14:58:52Z",
        "lastEditedBy" : "2bab095f-50fb-401e-ab9e-c09e00e2b00c",
        "tags" : [
        ]
      }
    ],
    "commit" : "85157f0076f0b41f8c1a667b79a0e1220922a270",
    "line" : 19,
    "diffHunk" : "@@ -1,1 +1566,1570 @@            if i < bin:\n                indices[label] = list(range(i, bin))\n                i = bin\n        return indices\n"
  },
  {
    "id" : "c81cbca8-a75f-4b87-8b77-711542cb7172",
    "prId" : 7000,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e1ef1749-ba0f-4dd0-ab89-e8c053968020",
        "parentId" : null,
        "authorId" : "aeb7e171-52e2-4faa-8a7c-32d6a9d2c2be",
        "body" : "a much simpler way to solve the upcasting!\n",
        "createdAt" : "2014-04-29T17:15:12Z",
        "updatedAt" : "2014-04-29T18:47:12Z",
        "lastEditedBy" : "aeb7e171-52e2-4faa-8a7c-32d6a9d2c2be",
        "tags" : [
        ]
      }
    ],
    "commit" : "134dd1f7cc1a521a1da84ea666c5a62da2e1d30a",
    "line" : 110,
    "diffHunk" : "@@ -1,1 +721,725 @@        \"\"\"\n        self._set_selection_from_grouper()\n        return self._python_agg_general(lambda x: notnull(x).sum(axis=axis)).astype('int64')\n\n    sum = _groupby_function('sum', 'add', np.sum)"
  },
  {
    "id" : "f8f2843d-9acd-420e-9f3a-011f6162196a",
    "prId" : 7600,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "62d1f9e3-6448-4813-a4a2-2d8278eb123b",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "why are you not using `value_counts`? this should be very similar (if not call irectly), BaseGrouper.size\n",
        "createdAt" : "2014-06-28T14:11:08Z",
        "updatedAt" : "2014-06-30T10:44:28Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "af49a2f9-b558-4922-a476-be93a1adf0f0",
        "parentId" : "62d1f9e3-6448-4813-a4a2-2d8278eb123b",
        "authorId" : "2bab095f-50fb-401e-ab9e-c09e00e2b00c",
        "body" : "There are 2 reasons.\n- `value_counts` cannot fulfill intermediate timestamps which is not included in the group key. For example, if the `TimeGrouper` categorize `[2011-01-01, 2011-01-02, 2011-01-04]` with daily frequency, the resulted group keys must be `[2011-01-01, 2011-01-02, 2011-01-03, 2011-01-04]`\n- `BinGrouper` doesn't retain original `Index` to be directly passed to `value_counts`. To use `value_counts`, it must be created using similar logic.\n\n```\nindices = self.indices\nlabels = []\nfor k, v in compat.iteritems(indices):\n            labels.extend([k] * len(v))\nvalue_counts(labels)\n```\n",
        "createdAt" : "2014-06-28T14:44:02Z",
        "updatedAt" : "2014-06-30T10:44:28Z",
        "lastEditedBy" : "2bab095f-50fb-401e-ab9e-c09e00e2b00c",
        "tags" : [
        ]
      }
    ],
    "commit" : "eb2cd0459a348e813648b05612c71e42b95b139c",
    "line" : 16,
    "diffHunk" : "@@ -1,1 +1667,1671 @@        return [self.binlabels.name]\n\n    def size(self):\n        \"\"\"\n        Compute group sizes"
  },
  {
    "id" : "1a8f9567-332e-4ce6-8c70-058f4e84f223",
    "prId" : 8171,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4c96f1a6-64cf-4efb-a8f1-cec09c2f819b",
        "parentId" : null,
        "authorId" : "aeb7e171-52e2-4faa-8a7c-32d6a9d2c2be",
        "body" : "it seems strange that this used to try size first (I thought I commented earlier but guess not), how did this work before??\n",
        "createdAt" : "2014-09-04T01:41:14Z",
        "updatedAt" : "2014-09-06T17:57:47Z",
        "lastEditedBy" : "aeb7e171-52e2-4faa-8a7c-32d6a9d2c2be",
        "tags" : [
        ]
      },
      {
        "id" : "3e4fa123-2c98-4ac5-b812-4c352f1c03ab",
        "parentId" : "4c96f1a6-64cf-4efb-a8f1-cec09c2f819b",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "I think this only gets hit (the compat) if we don't have the cython defined (eg it's not object/int64/float64) - so rarely gets hit (maybe just should always upcast) instead?\n",
        "createdAt" : "2014-09-04T01:54:48Z",
        "updatedAt" : "2014-09-06T17:57:47Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "719e8837-2ef6-4c65-9ce2-f579d38b70fb",
        "parentId" : "4c96f1a6-64cf-4efb-a8f1-cec09c2f819b",
        "authorId" : "aeb7e171-52e2-4faa-8a7c-32d6a9d2c2be",
        "body" : "yeah, have a feeling this exception would never raise (if it did wouldn't there be inf. recursion?? as count calls _count_compat...), I don't follow this code at all (need tests + coverage!).\n",
        "createdAt" : "2014-09-04T05:00:42Z",
        "updatedAt" : "2014-09-06T17:57:47Z",
        "lastEditedBy" : "aeb7e171-52e2-4faa-8a7c-32d6a9d2c2be",
        "tags" : [
        ]
      },
      {
        "id" : "42fd5e84-2b1c-4b06-9c28-fec5558530f4",
        "parentId" : "4c96f1a6-64cf-4efb-a8f1-cec09c2f819b",
        "authorId" : "93252f0a-20fd-4fff-a21f-b220eed58210",
        "body" : "What happens is that [this](https://github.com/pydata/pandas/blob/59c175f9e582c5b2466e46b2842d5929fdf7db19/pandas/core/groupby.py#L1528) line produces completely valid result, but with `float32` type, which causes type error in [this](https://github.com/pydata/pandas/blob/59c175f9e582c5b2466e46b2842d5929fdf7db19/pandas/core/groupby.py#L1533) line which expects `float64`, but the catch phrase also throws because `float32` array is not of type `object` either. i.e. neither of `lib.row_bool_subset` and `lib.row_bool_subset_object` can handle an array of type `float32`, and even though the `result` array is already correct, there will be an exception here.\n\nThis ultimately falls back on `_count_compat` which  produces the wrong result. \n",
        "createdAt" : "2014-09-04T15:22:33Z",
        "updatedAt" : "2014-09-06T17:57:47Z",
        "lastEditedBy" : "93252f0a-20fd-4fff-a21f-b220eed58210",
        "tags" : [
        ]
      },
      {
        "id" : "506e3d68-d886-40dd-8f40-49136bb8ecc9",
        "parentId" : "4c96f1a6-64cf-4efb-a8f1-cec09c2f819b",
        "authorId" : "aeb7e171-52e2-4faa-8a7c-32d6a9d2c2be",
        "body" : "@behzadnouri  just for completeness: I was asking if you had _just_ changed this line what would happen? (I'll just try it - I have a few pandas PRs to do anyway!)\n",
        "createdAt" : "2014-09-04T19:37:53Z",
        "updatedAt" : "2014-09-06T17:57:47Z",
        "lastEditedBy" : "aeb7e171-52e2-4faa-8a7c-32d6a9d2c2be",
        "tags" : [
        ]
      },
      {
        "id" : "fc5ec429-cbe6-409c-8ba8-1a9aee45eccf",
        "parentId" : "4c96f1a6-64cf-4efb-a8f1-cec09c2f819b",
        "authorId" : "93252f0a-20fd-4fff-a21f-b220eed58210",
        "body" : "@hayd if i had just changed that line, the result would be correct, but recalculated twice, once in [here](https://github.com/pydata/pandas/blob/59c175f9e582c5b2466e46b2842d5929fdf7db19/pandas/core/groupby.py#L1528) and once in `_count_compat`\n",
        "createdAt" : "2014-09-04T20:18:22Z",
        "updatedAt" : "2014-09-06T17:57:47Z",
        "lastEditedBy" : "93252f0a-20fd-4fff-a21f-b220eed58210",
        "tags" : [
        ]
      }
    ],
    "commit" : "70ec9211cc089f7102a7cefcaa1722290dc388bc",
    "line" : 8,
    "diffHunk" : "@@ -1,1 +148,152 @@\ndef _count_compat(x, axis=0):\n    return x.count()  # .size != .count(); count excludes nan\n\nclass Grouper(object):"
  },
  {
    "id" : "d2468fb0-5a8e-41b4-84fe-d265bbc5f7d1",
    "prId" : 9061,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1086bded-e916-412c-ba63-55f0a0e5eed6",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "can you add a `Parameters/Returns` block\n",
        "createdAt" : "2014-12-20T19:53:02Z",
        "updatedAt" : "2014-12-22T00:16:08Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "e3afd5b7b948f1438553a2194937d3b094ef262a",
    "line" : 18,
    "diffHunk" : "@@ -1,1 +3516,3520 @@    Given a list of labels at each level, returns a flat array of int64 ids\n    corresponding to unique tuples across the labels. If `retain_lex_rank`,\n    rank of returned ids preserve lexical ranks of labels.\n\n    Parameters"
  },
  {
    "id" : "fc656e7b-a72f-49de-adca-0406722fc25d",
    "prId" : 9345,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ce098208-4a0e-4b74-8048-c3f5c8e4f2be",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "would move this to line 1498 (e.g. combine with the is_numeric flag which doesn't seem to do anything else)\n",
        "createdAt" : "2015-02-13T14:23:55Z",
        "updatedAt" : "2015-02-13T20:53:22Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "9b0afe59-37de-4cd1-ac11-72b17d2f70c3",
        "parentId" : "ce098208-4a0e-4b74-8048-c3f5c8e4f2be",
        "authorId" : "dd0d55bf-2e2d-4452-92fd-89f769527517",
        "body" : "I need to set the outdtype after the possible float conversion on 1504, but I can yank the flag and just use it in the if statements.\n",
        "createdAt" : "2015-02-13T16:32:46Z",
        "updatedAt" : "2015-02-13T20:53:22Z",
        "lastEditedBy" : "dd0d55bf-2e2d-4452-92fd-89f769527517",
        "tags" : [
        ]
      },
      {
        "id" : "8028059a-3529-4fe5-ade8-b97a45e06c9a",
        "parentId" : "ce098208-4a0e-4b74-8048-c3f5c8e4f2be",
        "authorId" : "dd0d55bf-2e2d-4452-92fd-89f769527517",
        "body" : "On second thought. Since you have to pass is_numeric into `self._aggregate` I think this needs to stay given the comment above.\n",
        "createdAt" : "2015-02-13T17:11:31Z",
        "updatedAt" : "2015-02-13T20:53:22Z",
        "lastEditedBy" : "dd0d55bf-2e2d-4452-92fd-89f769527517",
        "tags" : [
        ]
      }
    ],
    "commit" : "5f6cbf88d47e7e777b8be855bb950c4ed722cd53",
    "line" : 65,
    "diffHunk" : "@@ -1,1 +1512,1516 @@                raise\n\n        if is_numeric:\n            out_dtype = '%s%d' % (values.dtype.kind, values.dtype.itemsize)\n        else:"
  },
  {
    "id" : "3780d945-2ad4-4d06-8c56-babb6b948c13",
    "prId" : 9445,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "cd677576-e128-496c-90ea-156af2ce14dd",
        "parentId" : null,
        "authorId" : "40104112-cdcf-4812-8f95-b502b40e346d",
        "body" : "Both `idx.size` and `ids.max()` are integers, yes?\n\nI find using `and` for integers rather confusing. Perhaps this could be: `(idx.max() if ids.size else 0) + 1`\n",
        "createdAt" : "2015-02-10T00:25:17Z",
        "updatedAt" : "2015-02-10T00:25:17Z",
        "lastEditedBy" : "40104112-cdcf-4812-8f95-b502b40e346d",
        "tags" : [
        ]
      },
      {
        "id" : "a0686c02-c91d-4811-905c-6d07bc48509c",
        "parentId" : "cd677576-e128-496c-90ea-156af2ce14dd",
        "authorId" : "93252f0a-20fd-4fff-a21f-b220eed58210",
        "body" : "[boolean-operations](https://docs.python.org/3/reference/expressions.html#boolean-operations):\n\n> The expression `x and y` first evaluates x; if x is false, its value is returned; otherwise, y is evaluated and the resulting value is returned.\n\nnote that the documentation follows with an example of `s or 'foo'`, i.e. `or`ing two strings, as a use-case of boolean operations.\n",
        "createdAt" : "2015-02-10T12:13:58Z",
        "updatedAt" : "2015-02-10T12:13:58Z",
        "lastEditedBy" : "93252f0a-20fd-4fff-a21f-b220eed58210",
        "tags" : [
        ]
      },
      {
        "id" : "a2cccd8a-c7c3-40b3-95c3-a6140fee8a21",
        "parentId" : "cd677576-e128-496c-90ea-156af2ce14dd",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "@behzadnouri I agree with @shoyer here. We get the idiom, but I don't think a casual glance is intuitve here. Pls change to what @shoyer suggests.\n",
        "createdAt" : "2015-02-10T14:12:24Z",
        "updatedAt" : "2015-02-10T14:12:24Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "b9749840-81e0-4f18-b2e6-91c8e30cc566",
        "parentId" : "cd677576-e128-496c-90ea-156af2ce14dd",
        "authorId" : "93252f0a-20fd-4fff-a21f-b220eed58210",
        "body" : "i gave an example from [_python's documentation_](https://docs.python.org/3/reference/expressions.html#boolean-operations) that this is an actual use-case for boolean operations:\n\n> This is sometimes useful, e.g., if `s` is a string that should be replaced by a default value if it is empty, the expression `s or 'foo'` yields the desired value.\n\nthis is right off from python's documentation, and i have seen it used a lot.\n\nthat said, if you like to change it, please do.\n",
        "createdAt" : "2015-02-10T14:30:36Z",
        "updatedAt" : "2015-02-10T14:30:36Z",
        "lastEditedBy" : "93252f0a-20fd-4fff-a21f-b220eed58210",
        "tags" : [
        ]
      },
      {
        "id" : "290bb979-7d23-48f2-ae1d-1b946739dec6",
        "parentId" : "cd677576-e128-496c-90ea-156af2ce14dd",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "I get that it is from python docs\nbut not all of that idioms are useful\nin the context of assignment with a value that could be None I would agree with you\nbut these are integers and it's not obvious at all\n\npls make the change\n",
        "createdAt" : "2015-02-10T14:34:23Z",
        "updatedAt" : "2015-02-10T14:34:23Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "66308320ec2f173c22cf12f6fa40c7a674cea8b3",
    "line" : 15,
    "diffHunk" : "@@ -1,1 +3588,3592 @@\n    if not compress:\n        ngroups = (ids.size and ids.max()) + 1\n    else:\n        ids, obs = _compress_group_index(ids, sort=True)"
  },
  {
    "id" : "890fe786-9ee2-47b1-a9e5-89a0cc4d2e9d",
    "prId" : 10142,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c869c092-66a2-48a6-952a-8aa7e2eb4202",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "are there other paths that this could hit in `_wrap_applied_output`?\n",
        "createdAt" : "2015-05-18T12:26:45Z",
        "updatedAt" : "2015-06-02T21:54:32Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "77d1fe69-8971-4df2-ab73-c91f4d191721",
        "parentId" : "c869c092-66a2-48a6-952a-8aa7e2eb4202",
        "authorId" : "ad641c5e-8c19-4350-a77b-ef5d980aedc8",
        "body" : "hmmm.... I can't think of how the other return paths could be hit with `Categorical` data\n",
        "createdAt" : "2015-05-21T17:26:11Z",
        "updatedAt" : "2015-06-02T21:54:32Z",
        "lastEditedBy" : "ad641c5e-8c19-4350-a77b-ef5d980aedc8",
        "tags" : [
        ]
      }
    ],
    "commit" : "c8bf1c4694014eb23fc4e0c03b7d468be60b65e6",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +2946,2950 @@                    cd = True\n                result = result.convert_objects(convert_dates=cd)\n                return self._reindex_output(result)\n\n            else:"
  },
  {
    "id" : "91e8aff6-8b7a-448a-9320-3aa494c9593a",
    "prId" : 11013,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c8a0955a-3f3c-465c-b4f4-1cd2e5f8e8cf",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "this needs to take the `axis` kw to be back-compat. (I see that you changed a test to fix this, pls change back).\n",
        "createdAt" : "2015-09-07T00:16:03Z",
        "updatedAt" : "2015-09-07T00:16:03Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "b3d72cbf-ae9f-4a56-839b-edf8e038dacf",
        "parentId" : "c8a0955a-3f3c-465c-b4f4-1cd2e5f8e8cf",
        "authorId" : "93252f0a-20fd-4fff-a21f-b220eed58210",
        "body" : "Having an axis argument there is a bug when [current master simply ignores the axis arg; `groupby.py:L807`](https://github.com/pydata/pandas/blob/81b647f4e623446d7b584e216382e79c2ed2e720/pandas/core/groupby.py#L807)\n\nalso, when doing a groupby, counting on `axis=1` has no meaning because u may get a different values for each row regardless of keys being the same or different. \n",
        "createdAt" : "2015-09-07T13:03:55Z",
        "updatedAt" : "2015-09-07T13:03:55Z",
        "lastEditedBy" : "93252f0a-20fd-4fff-a21f-b220eed58210",
        "tags" : [
        ]
      }
    ],
    "commit" : "d968aab3da13f68fabbb05f8eba12927d8bc5836",
    "line" : 43,
    "diffHunk" : "@@ -1,1 +3460,3464 @@            keys=self._selected_obj.columns, axis=1)\n\n    def count(self):\n        from functools import partial\n        from pandas.lib import count_level_2d"
  },
  {
    "id" : "a556b115-0198-4c32-81a9-8e491bc97ee7",
    "prId" : 14026,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "844572d2-b6e8-454b-909f-970997411bc7",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "versionadded tag\n",
        "createdAt" : "2016-08-18T01:47:56Z",
        "updatedAt" : "2017-06-01T12:01:54Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "14d941b8222edbeaae66b2f7b2e6e99bc5710846",
    "line" : 18,
    "diffHunk" : "@@ -1,1 +1445,1449 @@\n        This is the enumerative complement of cumcount.  Note that the\n        numbers given to the groups match the order in which the groups\n        would be seen when iterating over the groupby object, not the\n        order they are first observed."
  },
  {
    "id" : "b1c57104-0621-41db-b1d9-4059a035559f",
    "prId" : 14026,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/14026#pullrequestreview-28381492",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2eabbcb6-e00c-4d8a-af9a-417760ed51e6",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "this comment is good, add something like this to the docs (in groupy.rst) where you show an example",
        "createdAt" : "2017-03-22T13:32:15Z",
        "updatedAt" : "2017-06-01T12:01:54Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "14d941b8222edbeaae66b2f7b2e6e99bc5710846",
    "line" : 20,
    "diffHunk" : "@@ -1,1 +1447,1451 @@        numbers given to the groups match the order in which the groups\n        would be seen when iterating over the groupby object, not the\n        order they are first observed.\n\n        .. versionadded:: 0.20.2"
  },
  {
    "id" : "e670e103-0d84-4937-91a8-1ee235f53c37",
    "prId" : 17587,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/17587#pullrequestreview-63856710",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "55600d1d-dc0b-4286-83f5-3283912f999f",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "can you add a doc-string explaining params (I know you just added 1 but good time)",
        "createdAt" : "2017-09-19T10:11:22Z",
        "updatedAt" : "2017-10-01T15:43:27Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "4c51dd31-e5a7-4fb2-b21c-9ec80001a3fe",
        "parentId" : "55600d1d-dc0b-4286-83f5-3283912f999f",
        "authorId" : "44cdd628-3730-472b-8d1e-8ff92f91a4c7",
        "body" : "I'm sorry I don't really understand all parameters, I've added those I knowðŸ˜‚",
        "createdAt" : "2017-09-20T03:02:18Z",
        "updatedAt" : "2017-10-01T15:43:27Z",
        "lastEditedBy" : "44cdd628-3730-472b-8d1e-8ff92f91a4c7",
        "tags" : [
        ]
      }
    ],
    "commit" : "950de2031bad7a88c29bac9e86a73e1e7b2a495d",
    "line" : 64,
    "diffHunk" : "@@ -1,1 +1752,1756 @@    def __init__(self, axis, groupings, sort=True, group_keys=True,\n                 mutated=False, indexer=None):\n        self._filter_empty_groups = self.compressed = len(groupings) != 1\n        self.axis = axis\n        self.groupings = groupings"
  },
  {
    "id" : "b433768f-a77f-4d03-bc05-377a8ac4cac4",
    "prId" : 17843,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/17843#pullrequestreview-69194840",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4b53fee6-3998-431f-ad70-ee4432408ed4",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "note that I had to add this flag to 'fix' this warning issue elsewhere, I don't really like it, but would require more refactoring to make this cleaner.",
        "createdAt" : "2017-10-13T11:12:13Z",
        "updatedAt" : "2017-10-13T14:04:17Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "39451075320b18d7d06ff1da3b687cfc57d59dde",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +2705,2709 @@    # a passed-in Grouper, directly convert\n    if isinstance(key, Grouper):\n        binner, grouper, obj = key._get_grouper(obj, validate=False)\n        if key.key is None:\n            return grouper, [], obj"
  },
  {
    "id" : "0a5391f4-180a-4c03-8117-9db62ec6d757",
    "prId" : 19481,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/19481#pullrequestreview-94930816",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bf1cd8f0-fea3-4580-b3da-5d86f31f2e0a",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "we should prob have a better way of doing this :<",
        "createdAt" : "2018-02-07T12:39:25Z",
        "updatedAt" : "2018-02-09T18:37:11Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "66031b72-e2ae-46d9-8930-b9460b6d22f0",
        "parentId" : "bf1cd8f0-fea3-4580-b3da-5d86f31f2e0a",
        "authorId" : "5e8c5ef2-940b-436e-9c5f-98ae5460128c",
        "body" : "The catch I see here is that unlike other groupby transformations (where the dtype of the `result` object typically matches the dtype of the groups' values and gets cast as necessary after transformation) the dtype of the result object for rank needs to be a float prior to calling any `group_rank` operation. Otherwise, things like TIEBREAK_AVERAGE will not work when ranking say a group full of ints.\r\n\r\nThe generic calls to `algos` have it a little bit easier because they don't pass an object in to be modified, using instead the return value which `algos` builds internally as a like-sized array of floats. Unless there's something basic I don't understand with Cython, I don't think there's a way to upcast the dtype of the `return` object that gets passed into `group_rank` from say an int to a float, so the only option I can think of there would be to break out `group_rank` from other transformations and have `group_rank` return a new `result` object instead of modifying the provided one in place.\r\n\r\nI'd argue the effort and maintainability of doing that would far outweigh any benefit from cleaning up this conditional, but curious if you have other thoughts",
        "createdAt" : "2018-02-07T18:52:34Z",
        "updatedAt" : "2018-02-09T18:37:11Z",
        "lastEditedBy" : "5e8c5ef2-940b-436e-9c5f-98ae5460128c",
        "tags" : [
        ]
      },
      {
        "id" : "890941b4-51ae-4953-8989-3b70784fdb97",
        "parentId" : "bf1cd8f0-fea3-4580-b3da-5d86f31f2e0a",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "this is similar in a way to the pre-transformations we do for datetimelikes. What I meant is that the registry of _cython_functions should have this logic itself (which is already based on the function name). \r\n\r\ne.g. maybe in _cython_functions you get back a tuple rather than a scalar / lamba function, which includes the required dtype (or None).  Or _cython_functions actually should be a class which is dispatched to, to call the functions themselves. IOW something like\r\n\r\n```\r\nclass CythonTransformFunction:\r\n    def __init__(self, obj):\r\n        self.obj = obj\r\n\r\n    def cummax(self):\r\n         return group_cummax(self.obj.values)\r\n\r\n    def rank(self):\r\n        return group_cummax(self.obj.values.astype('floatt64'))\r\n```\r\n\r\n(and really should have more logic pushed to this class, e.g. pre-and post-convert dtype things. And should have a Transformation and an Aggregation version. This would all of the specific logic to be pushed here, rather than lookup in dicts and such. Further we could prob move this code out of the main groupby.py class into a sub-module.\r\n\r\ndon't have to do this here, but groupby for sure needs cleanup like this.",
        "createdAt" : "2018-02-08T01:25:32Z",
        "updatedAt" : "2018-02-09T18:37:11Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "aa4578d78e5d4feaf6a8a3caac51acf7d2ebc112",
    "line" : 99,
    "diffHunk" : "@@ -1,1 +2361,2365 @@                raise\n\n        if how == 'rank':\n            out_dtype = 'float'\n        else:"
  }
]
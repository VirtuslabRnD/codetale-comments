[
  {
    "id" : "353f0e7b-8c51-4089-b3f3-da652216d41b",
    "prId" : 4073,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "21e38615-683a-4ac3-924d-44f466159f54",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "boy - guess was not thinking when I originally wrote that\n",
        "createdAt" : "2013-06-28T14:57:00Z",
        "updatedAt" : "2013-06-28T16:00:01Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "ec43b1ed-aad0-431e-aa37-ebf4d6ceca23",
        "parentId" : "21e38615-683a-4ac3-924d-44f466159f54",
        "authorId" : "5c239b83-5a68-467b-a3f8-113a0fc494dc",
        "body" : "still worked tho...strange since enumerate composed with range should yield a tuple thus accessing the diagonal of the mask (in this case)...seems like that would have broken things (in a more general way)\n",
        "createdAt" : "2013-06-28T15:01:20Z",
        "updatedAt" : "2013-06-28T16:00:01Z",
        "lastEditedBy" : "5c239b83-5a68-467b-a3f8-113a0fc494dc",
        "tags" : [
        ]
      },
      {
        "id" : "594c1684-257b-4836-859b-009362392cc3",
        "parentId" : "21e38615-683a-4ac3-924d-44f466159f54",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "ok if your fix worked grrat\n",
        "createdAt" : "2013-06-28T15:06:41Z",
        "updatedAt" : "2013-06-28T16:00:01Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "3bac1816bac4be72ef2be7ab305eaea081604c2f",
    "line" : 9,
    "diffHunk" : "@@ -1,1 +578,582 @@        axis = cond.ndim - 1\n        cond = cond.swapaxes(axis, 0)\n        mask = np.array([cond[i].all() for i in xrange(cond.shape[0])],\n                        dtype=bool)\n"
  },
  {
    "id" : "8fbd2cfb-8de0-46c3-8878-469f4114cdb5",
    "prId" : 4313,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9aca9b9b-d313-4dee-af2a-294815501cb3",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "use a date_formatter function (like above); you don't need to handle nulls here as that is already handled in the imask (eg you will get NO nulls in the list comprehension)\n",
        "createdAt" : "2013-10-09T12:05:35Z",
        "updatedAt" : "2013-10-12T05:11:18Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "ce669d6f295f7ece6223535c75c5012cb3c553c1",
    "line" : 24,
    "diffHunk" : "@@ -1,1 +1410,1414 @@        rvalues[mask] = na_rep\n        imask = (-mask).ravel()\n\n        if date_format is None:\n            date_formatter = lambda x: Timestamp(x)._repr_base"
  },
  {
    "id" : "7c96ed60-01e0-4f32-9c4f-002739ab6235",
    "prId" : 4756,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "040aeb6b-3d5c-4bae-90f6-fc7a3c675d8f",
        "parentId" : null,
        "authorId" : "5c239b83-5a68-467b-a3f8-113a0fc494dc",
        "body" : "Should there be tests for negative slices? Or are those somewhere else?\n",
        "createdAt" : "2013-09-05T20:16:34Z",
        "updatedAt" : "2013-09-06T01:16:11Z",
        "lastEditedBy" : "5c239b83-5a68-467b-a3f8-113a0fc494dc",
        "tags" : [
        ]
      }
    ],
    "commit" : "caa370374b1c495e4d998ae1e11c1561fcbac511",
    "line" : 24,
    "diffHunk" : "@@ -1,1 +568,572 @@                if start is None:\n                    start = 0\n                elif start < 0:\n                    start += l\n                if stop is None or stop > l:"
  },
  {
    "id" : "afa83aa1-3d4e-4497-af81-7c8a67918c68",
    "prId" : 5270,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8380833d-0a99-4261-9828-7600995fc64a",
        "parentId" : null,
        "authorId" : "6f890fbc-4bdf-4397-95eb-a8225d4af04f",
        "body" : "What do you think of: `Length mismatch: Existing axis has %d elements, new values have %d elements`? Might be clearer.\n",
        "createdAt" : "2013-10-20T20:23:18Z",
        "updatedAt" : "2013-10-20T20:23:18Z",
        "lastEditedBy" : "6f890fbc-4bdf-4397-95eb-a8225d4af04f",
        "tags" : [
        ]
      }
    ],
    "commit" : "8c502a2faf8a8fd2200f2ad076b5b3f76d8c38e9",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +1882,1886 @@\n        if check_axis and len(value) != len(cur_axis):\n            raise ValueError('Length mismatch: Expected %d elements, got %d elements'\n                            % (len(cur_axis), len(value)))\n"
  },
  {
    "id" : "d768dcdb-0889-4092-a3fd-8af466f44b3e",
    "prId" : 5283,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5a84f10c-5d51-4d58-b7de-8892c718d417",
        "parentId" : null,
        "authorId" : "49cb7e4b-934a-4329-961e-4089057c4185",
        "body" : "I just want to record this here, since my thoughts on this matter have been so muddled:\n\n`np.array_equal` treats NaNs in object arrays as equal:\n\n```\n>>> np.array_equal(np.array([np.nan], dtype='O'), np.array([np.nan], dtype='O'))\nTrue\n```\n\nso object arrays do not need to be special-cased, `ObjectBlock.equals` does not need to be defined, and `ObjectBlock.equals` can defer to `Block.equals`. Only `FloatBlocks` and `ComplexBlocks` need to define their own `equals` method, since, for example,\n\n```\n>>> np.array_equal(np.array([np.nan], dtype='<f4'), np.array([np.nan], dtype='<f4'))\nFalse\n>>> np.array_equal(np.array([np.nan], dtype='complex128'), np.array([np.nan], dtype='complex128'))\nFalse\n```\n\nThankfully, `np.array_equal` also treats `NaT`s as equal:\n\n```\n>>> np.array_equal(np.array([np.datetime64('nat')]), np.array([np.datetime64('nat')]))\nTrue\n```\n\n`NaNs` can not exist in `bool` arrays:\n\n```\n>>> np.array([np.nan], dtype='bool')\narray([ True], dtype=bool)\n```\n\nor can `NaN`s exist in timedeltas:\n\n```\n>>> np.timedelta64(np.nan,'D')\nValueError: Could not convert object to NumPy timedelta\n```\n\nso `np.array_equal` should work as usual for these kinds of values.\n",
        "createdAt" : "2014-01-21T22:02:12Z",
        "updatedAt" : "2014-01-24T21:01:32Z",
        "lastEditedBy" : "49cb7e4b-934a-4329-961e-4089057c4185",
        "tags" : [
        ]
      }
    ],
    "commit" : "9f26fbc915e2759e0bcadaa93cb00610297e6a7e",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +1124,1128 @@    def equals(self, other):\n        if self.dtype != other.dtype or self.shape != other.shape: return False\n        return np.array_equal(self.values, other.values)\n\n"
  },
  {
    "id" : "bd67c065-e868-4c03-a042-063933d964af",
    "prId" : 5283,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1aa2b2f8-6b2d-4449-8753-d2e4f979c9cd",
        "parentId" : null,
        "authorId" : "49cb7e4b-934a-4329-961e-4089057c4185",
        "body" : "The example you gave did indeed break the code. I've added your example to test_internals.py and am handling this case by sorting the blocks according to their `ref_locs`.\n",
        "createdAt" : "2014-01-23T04:18:45Z",
        "updatedAt" : "2014-01-24T21:01:32Z",
        "lastEditedBy" : "49cb7e4b-934a-4329-961e-4089057c4185",
        "tags" : [
        ]
      }
    ],
    "commit" : "9f26fbc915e2759e0bcadaa93cb00610297e6a7e",
    "line" : 66,
    "diffHunk" : "@@ -1,1 +4025,4029 @@            dtype = blocks[0].dtype\n\n        if not items.is_unique:\n            blocks = sorted(blocks, key=lambda b: b.ref_locs.tolist())\n"
  },
  {
    "id" : "8ea2a7f4-3200-4a36-bbd5-74b2f4e11ed7",
    "prId" : 6745,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/6745#pullrequestreview-404356698",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "98f9361b-96ab-4b99-a908-22099cbb6816",
        "parentId" : null,
        "authorId" : "adf621f1-4745-479a-a1fc-dc14046a3f4b",
        "body" : "@jreback long-shot any idea if this FIXME is still needed or what it would take to address?",
        "createdAt" : "2020-05-01T14:04:27Z",
        "updatedAt" : "2020-05-01T14:04:27Z",
        "lastEditedBy" : "adf621f1-4745-479a-a1fc-dc14046a3f4b",
        "tags" : [
        ]
      },
      {
        "id" : "54540c7c-936b-4796-aa8a-a9376cfbdf9f",
        "parentId" : "98f9361b-96ab-4b99-a908-22099cbb6816",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "no idea\nsorry ",
        "createdAt" : "2020-05-01T16:33:12Z",
        "updatedAt" : "2020-05-01T16:33:12Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "6992041c-ba75-4719-8781-81d335c1cb01",
        "parentId" : "98f9361b-96ab-4b99-a908-22099cbb6816",
        "authorId" : "413be534-cedb-4df7-abda-cde26db33acd",
        "body" : "This PR is sure quite a trip down the memory lane :) \r\n\r\nUnfortunately, I don't quite remember what was the problem with pytables serialisation here, but looks like mgr_locs are returned in ascending order from `lib.get_blkno_indexers` anyway, so it's likely that the FIXME is not needed anymore.",
        "createdAt" : "2020-05-01T19:33:53Z",
        "updatedAt" : "2020-05-01T19:33:54Z",
        "lastEditedBy" : "413be534-cedb-4df7-abda-cde26db33acd",
        "tags" : [
        ]
      }
    ],
    "commit" : "f51235aef9bbb50632b569d9e0c104816e5e31a0",
    "line" : 2950,
    "diffHunk" : "@@ -1,1 +2863,2867 @@        #\n        # FIXME: mgr_groupby_blknos must return mgr_locs in ascending order,\n        # pytables serialization will break otherwise.\n        blocks = []\n        for blkno, mgr_locs in _get_blkno_placements(blknos, len(self.blocks),"
  },
  {
    "id" : "ba7a2f2c-5a26-489b-8419-2f1f085ea0d9",
    "prId" : 7370,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0813edea-72c8-4933-898c-8f51cc79fde3",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "why don't you add a version tag instead, this seems kind of odd to do it this way\n",
        "createdAt" : "2014-06-18T20:54:48Z",
        "updatedAt" : "2014-07-01T04:31:26Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "4e7b5f80-76ab-490e-9ba0-25506fcd0ff0",
        "parentId" : "0813edea-72c8-4933-898c-8f51cc79fde3",
        "authorId" : "413be534-cedb-4df7-abda-cde26db33acd",
        "body" : "There's an \"upcoming\" version tag, as in the first stable version having this serialization format, serving as a key into this dictionary. Or do you mean something else?\n",
        "createdAt" : "2014-06-18T21:12:29Z",
        "updatedAt" : "2014-07-01T04:31:26Z",
        "lastEditedBy" : "413be534-cedb-4df7-abda-cde26db33acd",
        "tags" : [
        ]
      },
      {
        "id" : "feb160dd-8242-4934-a4ec-77dc73c83e69",
        "parentId" : "0813edea-72c8-4933-898c-8f51cc79fde3",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "no I meant having the version as the _key_ was odd, why not just as a key-value in the dict, e.g. `version : '0.14.1'`\n",
        "createdAt" : "2014-06-18T21:13:51Z",
        "updatedAt" : "2014-07-01T04:31:26Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "65bbf9ec-cdef-498f-a272-59839b22b041",
        "parentId" : "0813edea-72c8-4933-898c-8f51cc79fde3",
        "authorId" : "413be534-cedb-4df7-abda-cde26db33acd",
        "body" : "I figured, something like this:\n\n``` python\nfor ver in list(supported_versions):\n    if ver in state:\n        setstate_ver(state[ver])\n```\n\nwould be easier on the eye than:\n\n``` python\nfor ver in list(supported_versions):\n     for d in state.values():\n        if d['version'] == ver:\n            setstate(d)\n            break\n```\n\nBut it's not a strong opinion, rather a gut feeling. If you insist, I'll make the version a dictionary element again.\n",
        "createdAt" : "2014-06-18T21:25:04Z",
        "updatedAt" : "2014-07-01T04:31:26Z",
        "lastEditedBy" : "413be534-cedb-4df7-abda-cde26db33acd",
        "tags" : [
        ]
      },
      {
        "id" : "dd19d504-efff-42aa-b59b-973873e9068b",
        "parentId" : "0813edea-72c8-4933-898c-8f51cc79fde3",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "ok, either way is fine. Just trying to make it easy on future versions.\n",
        "createdAt" : "2014-06-18T21:32:55Z",
        "updatedAt" : "2014-07-01T04:31:26Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "a9761d1331694620de13afdd7c70315203ef510a",
    "line" : 33,
    "diffHunk" : "@@ -1,1 +2055,2059 @@        axes_array = [ax for ax in self.axes]\n\n        extra_state = {\n            '0.14.1': {\n                'axes': axes_array,"
  },
  {
    "id" : "103b9bbd-703c-452e-b919-fa77c4e8bd36",
    "prId" : 10179,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c0f94c83-5a97-44d0-81ef-106ee3dc6bb0",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "Instead of this, I think change line 4129 (`get_empty_dtype_na`) to have it return `np.dtype(np.object_)` for 'category' (this is ONLY for the empty dtype). Then remove the 'is_categorical' check above. This may break other things though, which will need attention. \n",
        "createdAt" : "2015-05-21T13:24:16Z",
        "updatedAt" : "2015-06-27T15:27:46Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "023fc371cc900e28cffaf7b8c436b23f80e22f40",
    "line" : null,
    "diffHunk" : "@@ -1,1 +4405,4409 @@            fill_value = upcasted_na\n\n            if self.is_null and not getattr(self.block,'is_categorical',None):\n                missing_arr = np.empty(self.shape, dtype=empty_dtype)\n                if np.prod(self.shape):"
  },
  {
    "id" : "0472a093-c7c7-46bd-bfca-858423c9931e",
    "prId" : 11153,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "62aecf51-6ac8-4843-8a97-c51f3cbfb4fa",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "you don't need to test this because you know `inplace`, e.g. just use an if?\n",
        "createdAt" : "2015-09-20T00:26:26Z",
        "updatedAt" : "2015-09-20T00:26:26Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "6e73e502-d39c-4497-a965-570ed60baa80",
        "parentId" : "62aecf51-6ac8-4843-8a97-c51f3cbfb4fa",
        "authorId" : "2bab095f-50fb-401e-ab9e-c09e00e2b00c",
        "body" : "I added `mask.any()` condition to handle the case when the block contains no `Nan`. In this case:\n- We can return the block as it is. \n- Don't want to coerce data to `object` even if the fill value is `object`.\n- `DatetimeTZBlock` can perform inplace op in this case. Otherwise can't because it's internal value is `DatetimeIndex`.\n\nLet me do a follow-up if I do something wrong.\n",
        "createdAt" : "2015-09-20T21:07:23Z",
        "updatedAt" : "2015-09-20T21:07:23Z",
        "lastEditedBy" : "2bab095f-50fb-401e-ab9e-c09e00e2b00c",
        "tags" : [
        ]
      },
      {
        "id" : "45ac8689-495d-4e5d-85b3-2e105f226cb2",
        "parentId" : "62aecf51-6ac8-4843-8a97-c51f3cbfb4fa",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "hah...i already merged. the code looked reasonable.\n\nhave a look and see if anything needs cleaning (or not ok too).\n\nthanks!\n",
        "createdAt" : "2015-09-20T21:18:34Z",
        "updatedAt" : "2015-09-20T21:18:34Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "a7c705a99a634c69bc5e7a1af09e2445ea73300b",
    "line" : 22,
    "diffHunk" : "@@ -1,1 +1960,1964 @@            try:\n                return self._fillna_mask(mask, value, inplace=inplace)\n            except TypeError:\n                pass\n            # _fillna_mask raises TypeError when it fails"
  },
  {
    "id" : "ff2b25c7-2556-4e4a-a4b9-a9f8895af83d",
    "prId" : 13766,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/13766#pullrequestreview-32447102",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5bf318d9-d46c-4ed8-8b3b-cbb7775ef9ed",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "this shoukd be in a rename method in Index\nMI should also just iterate in the levels and call rename on that Index\n\nshould not be in internals \n",
        "createdAt" : "2016-07-23T16:39:10Z",
        "updatedAt" : "2017-04-18T08:01:30Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "3aea4274-7af3-417b-8629-27e04cacddd2",
        "parentId" : "5bf318d9-d46c-4ed8-8b3b-cbb7775ef9ed",
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "Well, that's how rename is implemented at the moment .. \nAnd AFAIK there is not a rename method on Index itself? (there is, but that is to change the name attribute, so something else)\n",
        "createdAt" : "2016-07-24T18:25:04Z",
        "updatedAt" : "2017-04-18T08:01:30Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      },
      {
        "id" : "4f967ae0-2c6f-49c7-b297-060085884751",
        "parentId" : "5bf318d9-d46c-4ed8-8b3b-cbb7775ef9ed",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "no I mean move it there \nmuch cleaner to do it\n",
        "createdAt" : "2016-07-24T18:30:28Z",
        "updatedAt" : "2017-04-18T08:01:30Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "c57d2388-a9dd-42bd-b00d-4bb35e42b677",
        "parentId" : "5bf318d9-d46c-4ed8-8b3b-cbb7775ef9ed",
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "So I mean this comment. Do you mean it would be cleaner to have a method on Index/MultiIndex itself that does this renaming? \r\nI can agree with that, but the problem is that there already is a 'rename' method which renames the `names` of a multi index (it could of course also be a private method)\r\n\r\nBut my preference is to leave the existing implementation intact in this PR (I just expanded the existing method a bit).",
        "createdAt" : "2017-04-12T16:49:04Z",
        "updatedAt" : "2017-04-18T08:01:30Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      },
      {
        "id" : "3edc3c99-62e6-432f-8065-f1964ae0b479",
        "parentId" : "5bf318d9-d46c-4ed8-8b3b-cbb7775ef9ed",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "yes I mean move this to ``MultiIndex``, and create a corresponding (private is fine) one for ``Index``. ideally it *would* be ``rename``, but I guess has to be a private method.",
        "createdAt" : "2017-04-12T17:49:33Z",
        "updatedAt" : "2017-04-18T08:01:30Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "1915696904aeb661c3d6b3a4f5350a02f13a03fb",
    "line" : 38,
    "diffHunk" : "@@ -1,1 +4747,4751 @@    if isinstance(index, MultiIndex):\n        if level is not None:\n            items = [tuple(func(y) if i == level else y\n                           for i, y in enumerate(x)) for x in index]\n        else:"
  },
  {
    "id" : "8bc4452f-c882-41ab-b5b4-1d62780b289d",
    "prId" : 14536,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/14536#pullrequestreview-6364158",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0fdbcc4f-aed8-4f5d-8273-4ad18c132ee0",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "from pandas.types.common import is_scalar\n",
        "createdAt" : "2016-10-30T13:54:45Z",
        "updatedAt" : "2016-11-01T10:40:28Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "cdd247b49d5a99f148f2b9cd45af270d17d21c7f",
    "line" : 23,
    "diffHunk" : "@@ -1,1 +1317,1321 @@\n        def _nanpercentile1D(values, mask, q, **kw):\n            values = values[~mask]\n\n            if len(values) == 0:"
  },
  {
    "id" : "71473bc4-5088-490f-91d5-72f14924a801",
    "prId" : 14536,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/14536#pullrequestreview-6807018",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "446d3af6-0fcf-475d-9622-7bac8a6e202a",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "I might move some of this to  to `pandas.core.nanops` (though  you might have to move slightly more as that takes axis arg). Its esentially what you are doing here, but in a slightly more general framework. call it `nanquantile` (or `nanpercentile`)\n",
        "createdAt" : "2016-10-30T13:57:27Z",
        "updatedAt" : "2016-11-01T10:40:28Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "2c692712-6841-4617-9ee7-b0abd405b8a8",
        "parentId" : "446d3af6-0fcf-475d-9622-7bac8a6e202a",
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "The reason I did not put it there initially, was because this is less general as the current functions in the `nanops` module. For example, I pass here the `mask` alongside the values because datetimelike values are already converted to integers at this point (where the NaTs are filled) because `np.percentile` cannot deal with datetime-like values\n",
        "createdAt" : "2016-10-30T17:52:35Z",
        "updatedAt" : "2016-11-01T10:40:28Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      },
      {
        "id" : "20ee1786-9f18-42dd-8965-d8c7b2aaa7e4",
        "parentId" : "446d3af6-0fcf-475d-9622-7bac8a6e202a",
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "@jreback Opinion about this?\n",
        "createdAt" : "2016-11-02T11:28:22Z",
        "updatedAt" : "2016-11-02T11:28:22Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      },
      {
        "id" : "a22496d5-a12c-4895-b6b2-464d9452582b",
        "parentId" : "446d3af6-0fcf-475d-9622-7bac8a6e202a",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "I meant move ALL of this; the nanops do everything (based on dtype), are basically ufuncs per-dtype. Its ok for now if you want to merge (to fix the bug). But let's open a new issue to move this code. All of the rest of it is there (for other ops). We don't _do_ very much inside the block managers, mainly just assemble blocks, actual calculations are pushed to other routines (numpy or pandas)\n",
        "createdAt" : "2016-11-02T11:35:50Z",
        "updatedAt" : "2016-11-02T11:35:51Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "69f22349-08f5-48de-81f7-e84d8605a817",
        "parentId" : "446d3af6-0fcf-475d-9622-7bac8a6e202a",
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "sounds good, will open a new issue (and one for the failing empty ones as well)\n",
        "createdAt" : "2016-11-02T12:59:17Z",
        "updatedAt" : "2016-11-02T12:59:17Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      }
    ],
    "commit" : "cdd247b49d5a99f148f2b9cd45af270d17d21c7f",
    "line" : 31,
    "diffHunk" : "@@ -1,1 +1325,1329 @@                    return np.array([self._na_value] * len(q),\n                                    dtype=values.dtype)\n\n            return np.percentile(values, q, **kw)\n"
  },
  {
    "id" : "2ad2ecd0-9de8-482f-97ed-54bf6164d6f7",
    "prId" : 14967,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/14967#pullrequestreview-14293303",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a2337b90-fdea-45e1-a39e-ced094de9cea",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "can you check the errors in ['raise', 'ignore'] at the beginning of the function and raise a ValueError otherwise (and add a test for this)",
        "createdAt" : "2016-12-23T00:09:59Z",
        "updatedAt" : "2017-01-03T20:52:56Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "ff9a2334-84b8-4bc3-8e9e-2efcdd325616",
        "parentId" : "a2337b90-fdea-45e1-a39e-ced094de9cea",
        "authorId" : "7fd30c76-727b-4746-bf1c-c9571ce401e1",
        "body" : "Sure, there are two 'public' `astype(...)` methods: \r\n\r\n- `NDFrame.astype(...)` in `pandas/core/generic.py`\r\n- `Block.astype(...)` in `pandas/core/internals.py`\r\n\r\nIn addition there is a 'protected' `Block._astype(...)` method in  \r\n`pandas/core/internals.py`. Should I only put the checks in the 'public' \r\nmethods?\r\n\r\nBearing in mind that the `raise_on_error` kwarg is going to be deprecated for\r\n`DataFrame.where()` and replaced with the `errors` kwarg it would make sense to\r\nput the code that checks the validity of the arguments in one place. Do we have \r\nany existing code where we put such validity checking functions/methods?\r\n\r\nI notice that both `NDFrame` & `Block` inherit from `PandasObject` but, I'm not \r\nsure that this is the correct thing to do. Should I put a function in \r\n`pandas/core/base.py`?  ",
        "createdAt" : "2016-12-23T11:34:13Z",
        "updatedAt" : "2017-01-03T20:52:56Z",
        "lastEditedBy" : "7fd30c76-727b-4746-bf1c-c9571ce401e1",
        "tags" : [
        ]
      },
      {
        "id" : "d20e6285-cd14-42aa-8ed5-a59fd0d5ed25",
        "parentId" : "a2337b90-fdea-45e1-a39e-ced094de9cea",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "Block is completely internal\r\nu can put the check there\r\n\r\nwe have centralized checks but no need in this case \r\n\r\nout in _astype as that's where it's actually used \r\nparameter validation is best down where it's actually ",
        "createdAt" : "2016-12-23T12:06:01Z",
        "updatedAt" : "2017-01-03T20:52:56Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "b174e6f4dec2faa3eaf9124dc694c3fd92e1a890",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +461,465 @@\n    def _astype(self, dtype, copy=False, errors='raise', values=None,\n                klass=None, mgr=None, **kwargs):\n        \"\"\"\n        Coerce to the new type (if copy=True, return a new copy)"
  },
  {
    "id" : "f1ec96c3-cf41-4a2f-8dd1-da94e724734a",
    "prId" : 16015,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/16015#pullrequestreview-63811512",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c6d1e3fa-11a5-4f97-8bfd-5c54ee8663f5",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "hmm, this seems to contract the\r\n\r\n``elif is_categorical_dtype(dtype)``\r\n\r\nIOW we DO allow ``CategoricalDtype``, just not ``Categorical/CategoricalIndex`` here\r\n\r\nyou can just use ``pandas_dtype`` I think",
        "createdAt" : "2017-09-09T17:41:58Z",
        "updatedAt" : "2017-09-23T16:33:31Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "fa80926d-1d39-4893-86e1-9f519dc824ae",
        "parentId" : "c6d1e3fa-11a5-4f97-8bfd-5c54ee8663f5",
        "authorId" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "body" : "Some test was failing without this earlier. I'll see if I can revert it and figure out what was going on.",
        "createdAt" : "2017-09-09T23:04:16Z",
        "updatedAt" : "2017-09-23T16:33:31Z",
        "lastEditedBy" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "tags" : [
        ]
      },
      {
        "id" : "24572d99-e830-45a7-b287-bd7cb3175e8c",
        "parentId" : "c6d1e3fa-11a5-4f97-8bfd-5c54ee8663f5",
        "authorId" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "body" : "Ah, this is to disallow passing in the class `CategoricalDtype`, instead of an instance. Without the check, you get an object dtype when (incorrectly) passing `CategoricalDtype` (not an instance)\r\n\r\n```python\r\nIn [17]: pd.Series([1, 2]).astype(CategoricalDtype)\r\nOut[17]:\r\n0    1\r\n1    2\r\ndtype: object\r\n```\r\n",
        "createdAt" : "2017-09-19T21:37:33Z",
        "updatedAt" : "2017-09-23T16:33:32Z",
        "lastEditedBy" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "tags" : [
        ]
      }
    ],
    "commit" : "43f90cc13786b57b89709cdb7dd8d2c023adaee6",
    "line" : 8,
    "diffHunk" : "@@ -1,1 +140,144 @@        returns a boolean if we are a categorical\n        \"\"\"\n        if dtype is Categorical or dtype is CategoricalDtype:\n            # this is a pd.Categorical, but is not\n            # a valid type for astypeing"
  },
  {
    "id" : "7601171f-c54b-4e21-9f0a-35e116469822",
    "prId" : 16015,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/16015#pullrequestreview-63811628",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "12b07130-651c-4c45-9c88-76f89c6a9d2d",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "I think let's deprecate this",
        "createdAt" : "2017-09-09T17:42:27Z",
        "updatedAt" : "2017-09-23T16:33:31Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "ce4110b9-ba4a-4bd9-a86a-bf5b4523892b",
        "parentId" : "12b07130-651c-4c45-9c88-76f89c6a9d2d",
        "authorId" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "body" : "Will raise a followup issue.",
        "createdAt" : "2017-09-19T21:37:55Z",
        "updatedAt" : "2017-09-23T16:33:32Z",
        "lastEditedBy" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "tags" : [
        ]
      }
    ],
    "commit" : "43f90cc13786b57b89709cdb7dd8d2c023adaee6",
    "line" : 29,
    "diffHunk" : "@@ -1,1 +555,559 @@                                \"`dtype=CategoricalDtype(categories, ordered)`\"\n                                \" instead.\")\n            kwargs = kwargs.copy()\n            categories = getattr(dtype, 'categories', None)\n            ordered = getattr(dtype, 'ordered', False)"
  },
  {
    "id" : "0cc20eb7-daf0-41f3-bfa1-5e9f728d8083",
    "prId" : 17728,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/17728#pullrequestreview-67675466",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5d8f93fa-63c1-4879-884d-bb96def3b83b",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "a mouthful!\r\n\r\ncan you put blank lines in between statements",
        "createdAt" : "2017-10-06T13:58:28Z",
        "updatedAt" : "2017-10-10T23:27:16Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "bb5a100b314d7f19dda19bfb5ef0889ac3dd5e36",
    "line" : 160,
    "diffHunk" : "@@ -1,1 +5203,5207 @@    \"\"\"\n    return (\n        # all blocks need to have the same type\n        all([type(ju.block) is type(join_units[0].block) for ju in join_units]) and  # noqa\n        # no blocks that would get missing values (can lead to type upcasts)"
  },
  {
    "id" : "4813a52e-7d91-4407-a604-b42d27fe36d7",
    "prId" : 17728,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/17728#pullrequestreview-68705284",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5a1f39e8-e0f8-4d44-86c0-72cd698b597e",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "actually you could combine all of these ``concat_same_type`` into a single routine  if you did this\r\n\r\n```\r\ndef concat_same_type(self, to_concat, placement=None)\r\n       \"\"\"\r\n       Concatenate list of single blocks of the same type.\r\n       \"\"\"\r\n        values = self._concatenator([blk.values for blk in to_concat], axis=self.ndim - 1)\r\n        return self.make_block_same_class(\r\n            values, placement=placement or slice(0, len(values), 1))\r\n```\r\n\r\nThen add to Block\r\n```\r\n_concatenator = np.concatenate\r\n```\r\nCategorical\r\n```\r\n_concatnator = _concat._concat_categorical\r\n```\r\n\r\netc",
        "createdAt" : "2017-10-10T03:38:19Z",
        "updatedAt" : "2017-10-10T23:27:16Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "cf443fe4-c5f6-4f96-92e7-5f0f373c9388",
        "parentId" : "5a1f39e8-e0f8-4d44-86c0-72cd698b597e",
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "Ah, that would actually be nice. The only problem with this is that (for the reasons that I had the if/else statements originally) `self.make_block_same_class` will not always work. Eg ``_concat_categorical`` can return both categorical values as object values, and depending on that should return a CategoricalBlock or another type of Block. ",
        "createdAt" : "2017-10-10T07:25:52Z",
        "updatedAt" : "2017-10-10T23:27:16Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      },
      {
        "id" : "4237039d-d796-4ea9-a70b-b0da492c480a",
        "parentId" : "5a1f39e8-e0f8-4d44-86c0-72cd698b597e",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "so for categorical block override; otherwise u end up repeating lots of code",
        "createdAt" : "2017-10-10T18:33:20Z",
        "updatedAt" : "2017-10-10T23:27:16Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "a3f3c10a-70cb-402e-91be-a4d4f0d7b264",
        "parentId" : "5a1f39e8-e0f8-4d44-86c0-72cd698b597e",
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "but need to overwrite for Datetimetz as well, so then end up with almost as many overridden ones as now (only for Sparse it would not be needed then). ",
        "createdAt" : "2017-10-10T22:23:50Z",
        "updatedAt" : "2017-10-10T23:27:16Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      },
      {
        "id" : "2d2eade4-3801-405e-b222-e2b4cb0b2b47",
        "parentId" : "5a1f39e8-e0f8-4d44-86c0-72cd698b597e",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "this is still repeatting way too much code. you can just do it this way\r\n\r\nin Block\r\n```\r\ndef concat_same_type(self, to_concat, constructor=None, placement=None):\r\n     values = self._concatenator(......)\r\n    if constructor is None:\r\n        constructor = make_block\r\n      return constructor(....)\r\n```\r\n\r\nthen where needed\r\n\r\n```\r\ndef concat_same_type(.......):\r\n      return super(Categorical, self).concat_same_type(....., constructor=self.make_block_same_class)\r\n```\r\n\r\nthat way for an overriden class you are not repeating evertyhing.",
        "createdAt" : "2017-10-11T18:25:03Z",
        "updatedAt" : "2017-10-11T18:25:03Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "bb5a100b314d7f19dda19bfb5ef0889ac3dd5e36",
    "line" : 12,
    "diffHunk" : "@@ -1,1 +316,320 @@        return _merge_blocks([self, other])\n\n    def concat_same_type(self, to_concat, placement=None):\n        \"\"\"\n        Concatenate list of single blocks of the same type."
  },
  {
    "id" : "a0ab421d-ce27-4405-a72b-a3046112363f",
    "prId" : 17728,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/17728#pullrequestreview-68549530",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "cc220429-1305-4252-be25-e62bfb8bde79",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "could some of this logic be moreve to concaty_same_type?",
        "createdAt" : "2017-10-10T23:54:47Z",
        "updatedAt" : "2017-10-10T23:54:47Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "3a2ba184-e871-4212-81c6-15d146fc1ca1",
        "parentId" : "cc220429-1305-4252-be25-e62bfb8bde79",
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "Which logic do you mean exactly? \r\nFor now, I coded `concat_same_type` such that is assumes only blocks of the same type are passed (so I don't do the checking there, but before the method is called)",
        "createdAt" : "2017-10-11T09:53:02Z",
        "updatedAt" : "2017-10-11T09:53:02Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      }
    ],
    "commit" : "bb5a100b314d7f19dda19bfb5ef0889ac3dd5e36",
    "line" : 110,
    "diffHunk" : "@@ -1,1 +4575,4579 @@            blocks = [obj.blocks[0] for obj in non_empties]\n\n            if all([type(b) is type(blocks[0]) for b in blocks[1:]]):  # noqa\n                new_block = blocks[0].concat_same_type(blocks)\n            else:"
  },
  {
    "id" : "de766c1d-ed66-49ec-8264-b9117a85df87",
    "prId" : 18458,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/18458#pullrequestreview-79013811",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f6625efb-779f-4484-b21b-4eee1f3e24bf",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "change this to ``transpose`` instead. should be straightforward from here.",
        "createdAt" : "2017-11-25T23:09:28Z",
        "updatedAt" : "2017-11-26T12:02:14Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "16bcc1c9-0fb3-4bf4-85f1-c2a07f3cad44",
        "parentId" : "f6625efb-779f-4484-b21b-4eee1f3e24bf",
        "authorId" : "c2e7df75-d1fb-42be-9205-186b46cef3d7",
        "body" : "Thanks a lot, ``transpose`` is of course much better than ``axis``.\r\n\r\nThe issue was actually in the ``if len(self.blocks) == 0:`` block, as the empty array also must be transposed. \r\n\r\nEverything is green now locally and I've pushed that upstream.",
        "createdAt" : "2017-11-26T00:04:24Z",
        "updatedAt" : "2017-11-26T12:02:14Z",
        "lastEditedBy" : "c2e7df75-d1fb-42be-9205-186b46cef3d7",
        "tags" : [
        ]
      }
    ],
    "commit" : "48e1fc84811aba2831c38f2db20102bdf8ed8c4e",
    "line" : 42,
    "diffHunk" : "@@ -1,1 +3697,3701 @@        if self._is_single_block or not self.is_mixed_type:\n            arr = mgr.blocks[0].get_values()\n        else:\n            arr = mgr._interleave()\n"
  },
  {
    "id" : "6ea81ec8-9c2d-4e52-9955-be6110b23be4",
    "prId" : 18710,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/18710#pullrequestreview-82696842",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d2ef9a6d-fdc1-4a4e-9e38-a68f182d067f",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "I don't think you need all of this logic, wouldn't\r\n\r\n```\r\nvalues = self.values.astype(dtype, copy=copy)\r\n\r\nreturn self.make_block(values, dtype=dtype)\r\n```\r\nbe enough (if values is a Categorical already or dtype is a CDT, it will infer correctly, and if its not it will as well).",
        "createdAt" : "2017-12-10T14:54:46Z",
        "updatedAt" : "2017-12-13T03:37:26Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "eb0358fe-b4cc-4b8d-9968-238fac489300",
        "parentId" : "d2ef9a6d-fdc1-4a4e-9e38-a68f182d067f",
        "authorId" : "7545b4d7-157f-47c4-b7f8-18bf358d429c",
        "body" : "I don't think that quite works, since `self.values` can be a different object depending on what `self` is: if `self` is already categorical, then `self.values` is a `Categorical`, otherwise `self.values` is a numpy array.\r\n\r\nIn the numpy case, `self.values.astype` raises `TypeError: data type not understood` when a `CDT` is passed as the dtype.\r\n\r\nLikewise, `self.make_block(Categorical(self.values, dtype=dtype))` also doesn't work by itself.  In the `Categorical` case, the constructor ignores the `dtype` parameter when the input data is already `Categorical`, so no update occurs.\r\n\r\nSeems like the two paths are necessary?  Or am I overlooking something?",
        "createdAt" : "2017-12-11T22:36:30Z",
        "updatedAt" : "2017-12-13T03:37:26Z",
        "lastEditedBy" : "7545b4d7-157f-47c4-b7f8-18bf358d429c",
        "tags" : [
        ]
      },
      {
        "id" : "4cc804b4-607d-4c63-8168-bb54795f5733",
        "parentId" : "d2ef9a6d-fdc1-4a4e-9e38-a68f182d067f",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "ok seems reasonable then",
        "createdAt" : "2017-12-12T01:31:17Z",
        "updatedAt" : "2017-12-13T03:37:26Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "6702f909d2843cf6c0923c9392af59eaf43981d2",
    "line" : 32,
    "diffHunk" : "@@ -1,1 +594,598 @@                dtype = CategoricalDtype(categories, ordered)\n\n            if is_categorical_dtype(self.values):\n                # GH 10696/18593: update an existing categorical efficiently\n                return self.make_block(self.values.astype(dtype, copy=copy))"
  },
  {
    "id" : "036b2e89-4e26-478b-8006-699a3c0c86bf",
    "prId" : 19265,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/19265#pullrequestreview-89639167",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c67a1b8f-2a35-4c76-b941-7766d5a50698",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "this needs a test",
        "createdAt" : "2018-01-18T00:26:33Z",
        "updatedAt" : "2018-01-19T16:50:19Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "1ee79409d2e6843fdcf1971c0ffebb00b7466c44",
    "line" : 269,
    "diffHunk" : "@@ -1,1 +2957,2961 @@    if fastpath is not None:\n        # GH#19265 pyarrow is passing this\n        warnings.warn(\"fastpath argument is deprecated, will be removed \"\n                      \"in a future release.\", DeprecationWarning)\n    if klass is None:"
  },
  {
    "id" : "b26dc6b8-22df-4a99-96b6-c79649cf962f",
    "prId" : 19268,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/19268#pullrequestreview-90098318",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8b5fdf04-9d55-41a7-91dd-2c432a2e492a",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "this should NOT be in this file, make a dedicated namespace. pandas.core.internals.block or something",
        "createdAt" : "2018-01-18T23:34:02Z",
        "updatedAt" : "2018-02-01T20:55:34Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "1dd14c67-fc89-4bef-9e80-8897eabb3f73",
        "parentId" : "8b5fdf04-9d55-41a7-91dd-2c432a2e492a",
        "authorId" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "body" : "Why would it not be in this file? All the other blocks are. Note that `ExtensionBlock` is not ever going to be public, only `ExtensionArray` and `ExtensionDtype`.",
        "createdAt" : "2018-01-19T02:52:55Z",
        "updatedAt" : "2018-02-01T20:55:34Z",
        "lastEditedBy" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "tags" : [
        ]
      },
      {
        "id" : "269a4dfc-db81-4819-b759-b8adc9c7826c",
        "parentId" : "8b5fdf04-9d55-41a7-91dd-2c432a2e492a",
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "I agree this should be in this file (if we find `internals.py` too long we can split it in multiple files, but let's do that in a separate PR to make reviewing here not harder). \r\n@jreback `ExtensionBlock` will just the Block internally used for our own extension types (a bit like `NonConsolidatableBlock` is not the base class for those)",
        "createdAt" : "2018-01-19T09:57:24Z",
        "updatedAt" : "2018-02-01T20:55:34Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      },
      {
        "id" : "8848e881-a3aa-4b57-b9f7-fc26682aa611",
        "parentId" : "8b5fdf04-9d55-41a7-91dd-2c432a2e492a",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "this is exactly the point, this diff is already way too big. let's do a pre-cursor PR to split Block and manger (IOW internals into 2 files). ",
        "createdAt" : "2018-01-19T11:25:24Z",
        "updatedAt" : "2018-02-01T20:55:34Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "68aa8ff0-8484-4789-9f4a-559617debe0f",
        "parentId" : "8b5fdf04-9d55-41a7-91dd-2c432a2e492a",
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "By splitting the file first, the diff here will not be smaller",
        "createdAt" : "2018-01-19T12:36:46Z",
        "updatedAt" : "2018-02-01T20:55:34Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      }
    ],
    "commit" : "34134f2f9633cca26b4efd382475927c1eb3fe5a",
    "line" : 172,
    "diffHunk" : "@@ -1,1 +1842,1846 @@\n\nclass ExtensionBlock(NonConsolidatableMixIn, Block):\n    \"\"\"Block for holding extension types.\n"
  },
  {
    "id" : "5e684510-a713-4897-9d20-e672f401538f",
    "prId" : 19268,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/19268#pullrequestreview-90081765",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a893645b-4fa6-4e2a-b92d-9e68ad615b76",
        "parentId" : null,
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "Is this needed? I know it currently like that in `NonConsolidatableBlock`, but do we ever expect the result to be a 2D array if this is holded in an DataFrame. \r\nEg datetimetz block returns here a DatetimeIndex for both `.values` and `.get_values()`. On the other hand, a categorical block does this reshaping and returns Categorical vs 2d object numpy array.\r\n\r\nFurther, do we need to do something with `dtype` arg?",
        "createdAt" : "2018-01-19T10:09:11Z",
        "updatedAt" : "2018-02-01T20:55:34Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      },
      {
        "id" : "a9f87350-a79c-44d4-81a5-7a85f55454c9",
        "parentId" : "a893645b-4fa6-4e2a-b92d-9e68ad615b76",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "this is for sparse. which is a step-child ATM. has to be dealt with",
        "createdAt" : "2018-01-19T11:26:25Z",
        "updatedAt" : "2018-02-01T20:55:34Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "34134f2f9633cca26b4efd382475927c1eb3fe5a",
    "line" : 196,
    "diffHunk" : "@@ -1,1 +1866,1870 @@        values = np.asarray(self.values)\n        if values.ndim == self.ndim - 1:\n            values = values.reshape((1,) + values.shape)\n        return values\n"
  },
  {
    "id" : "139f46c9-6f93-4175-be64-374a8d7b3c96",
    "prId" : 19268,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/19268#pullrequestreview-93261964",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "90c2565a-832b-4f2b-8261-2ad672559fff",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "huh?",
        "createdAt" : "2018-01-28T21:11:46Z",
        "updatedAt" : "2018-02-01T20:55:34Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "e1898bf2-fc98-4c42-88be-e3b0b9b9b340",
        "parentId" : "90c2565a-832b-4f2b-8261-2ad672559fff",
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "this is copy pasted from existing code, and is explaining why the `axis` argument is ignored",
        "createdAt" : "2018-01-28T22:02:16Z",
        "updatedAt" : "2018-02-01T20:55:34Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      },
      {
        "id" : "7ed82f64-ab30-4ad5-bec6-cd077e929233",
        "parentId" : "90c2565a-832b-4f2b-8261-2ad672559fff",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "a doc-string would help here",
        "createdAt" : "2018-02-01T12:24:34Z",
        "updatedAt" : "2018-02-01T20:55:34Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "34134f2f9633cca26b4efd382475927c1eb3fe5a",
    "line" : 211,
    "diffHunk" : "@@ -1,1 +1881,1885 @@            fill_value = fill_tuple[0]\n\n        # axis doesn't matter; we are really a single-dim object\n        # but are passed the axis depending on the calling routing\n        # if its REALLY axis 0, then this will be a reindex and not a take"
  },
  {
    "id" : "78f3d176-3c32-421a-b804-7f8b36140a86",
    "prId" : 19268,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/19268#pullrequestreview-93130434",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "934518fa-9d18-4b8a-8579-86b6c3b74ed2",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "can you add some doc-strings",
        "createdAt" : "2018-02-01T00:15:57Z",
        "updatedAt" : "2018-02-01T20:55:34Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "34134f2f9633cca26b4efd382475927c1eb3fe5a",
    "line" : 226,
    "diffHunk" : "@@ -1,1 +1896,1900 @@\n    def _can_hold_element(self, element):\n        # XXX: We may need to think about pushing this onto the array.\n        # We're doing the same as CategoricalBlock here.\n        return True"
  },
  {
    "id" : "7da47309-a77a-4471-9a3a-74289ea3e603",
    "prId" : 19434,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/19434#pullrequestreview-92069328",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "227a8382-dbd5-4515-8569-46eaac0967d5",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "deprecate dtype here (add as a FutureWarning)",
        "createdAt" : "2018-01-28T22:28:21Z",
        "updatedAt" : "2018-01-29T11:35:36Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "7ec1b073-b7b0-4ffe-a6fe-6b2e4caf6bbb",
        "parentId" : "227a8382-dbd5-4515-8569-46eaac0967d5",
        "authorId" : "34a86a6a-3d79-42bc-a1d1-8da4b8916a25",
        "body" : "done.",
        "createdAt" : "2018-01-28T22:56:56Z",
        "updatedAt" : "2018-01-29T11:35:36Z",
        "lastEditedBy" : "34a86a6a-3d79-42bc-a1d1-8da4b8916a25",
        "tags" : [
        ]
      }
    ],
    "commit" : "77422ba2bdee149b092e39acff1077875a9e9790",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +226,230 @@\n    def make_block_same_class(self, values, placement=None, ndim=None,\n                              dtype=None):\n        \"\"\" Wrap given values in a block of same type as self. \"\"\"\n        if dtype is not None:"
  },
  {
    "id" : "dd6099be-9ca7-4645-9afc-1a0d7877a642",
    "prId" : 19434,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/19434#pullrequestreview-92165538",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f8546865-5e8a-4e82-a454-b76d759eb897",
        "parentId" : null,
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "Let's make this a DeprecationWarning instead of FutureWarning, as it is typically only something developers need to see, not users.",
        "createdAt" : "2018-01-29T10:13:00Z",
        "updatedAt" : "2018-01-29T11:35:36Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      },
      {
        "id" : "018df495-5a53-4386-b3e6-5ad9ba2780e2",
        "parentId" : "f8546865-5e8a-4e82-a454-b76d759eb897",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "post an issue on fastparquet to fix this as well\r\n",
        "createdAt" : "2018-01-29T10:18:52Z",
        "updatedAt" : "2018-01-29T11:35:36Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "bb134f4a-4f2e-4bea-a841-89451ab14076",
        "parentId" : "f8546865-5e8a-4e82-a454-b76d759eb897",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "let’s leave this as a FutureWarning\r\nit will encourage fp to fix this as it will be visible",
        "createdAt" : "2018-01-29T10:21:00Z",
        "updatedAt" : "2018-01-29T11:35:36Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "0d889c42-5c7c-491e-8013-96917d07b196",
        "parentId" : "f8546865-5e8a-4e82-a454-b76d759eb897",
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "We can use the issue I opened yesterday: https://github.com/dask/fastparquet/issues/297 \r\n\r\nFutureWarning will just be annoying for users in this case, and I am confident fastparquet will change that",
        "createdAt" : "2018-01-29T10:22:51Z",
        "updatedAt" : "2018-01-29T11:35:36Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      },
      {
        "id" : "18d85440-9592-4815-908a-88ce3bc4bd55",
        "parentId" : "f8546865-5e8a-4e82-a454-b76d759eb897",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "if it’s changed then we can simply move the bar on fp min version and this is no problem",
        "createdAt" : "2018-01-29T10:24:16Z",
        "updatedAt" : "2018-01-29T11:35:36Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "3708df45-49c2-4812-96de-8b01dca08a15",
        "parentId" : "f8546865-5e8a-4e82-a454-b76d759eb897",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "we are not keeping private API around for external packages\r\nthis is way too much work",
        "createdAt" : "2018-01-29T10:25:11Z",
        "updatedAt" : "2018-01-29T11:35:36Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "64e80e09-272b-4bc4-9e2b-f7bc17f59a1d",
        "parentId" : "f8546865-5e8a-4e82-a454-b76d759eb897",
        "authorId" : "34a86a6a-3d79-42bc-a1d1-8da4b8916a25",
        "body" : "gents, which is it? FutureWarning or DeprecationWarning? it seems to me that DeprecationWarning is meant to be used here.",
        "createdAt" : "2018-01-29T10:59:13Z",
        "updatedAt" : "2018-01-29T11:35:36Z",
        "lastEditedBy" : "34a86a6a-3d79-42bc-a1d1-8da4b8916a25",
        "tags" : [
        ]
      },
      {
        "id" : "b1386b79-7543-46b4-bc2a-f932d8fe1be9",
        "parentId" : "f8546865-5e8a-4e82-a454-b76d759eb897",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "pls leave it as FutureWarning ",
        "createdAt" : "2018-01-29T11:02:56Z",
        "updatedAt" : "2018-01-29T11:35:36Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "2eaa1eec-f57b-4200-b1b5-050703a61f0c",
        "parentId" : "f8546865-5e8a-4e82-a454-b76d759eb897",
        "authorId" : "34a86a6a-3d79-42bc-a1d1-8da4b8916a25",
        "body" : "ok",
        "createdAt" : "2018-01-29T11:14:47Z",
        "updatedAt" : "2018-01-29T11:35:36Z",
        "lastEditedBy" : "34a86a6a-3d79-42bc-a1d1-8da4b8916a25",
        "tags" : [
        ]
      }
    ],
    "commit" : "77422ba2bdee149b092e39acff1077875a9e9790",
    "line" : 11,
    "diffHunk" : "@@ -1,1 +231,235 @@            # issue 19431 fastparquet is passing this\n            warnings.warn(\"dtype argument is deprecated, will be removed \"\n                          \"in a future release.\", FutureWarning)\n        if placement is None:\n            placement = self.mgr_locs"
  },
  {
    "id" : "cc5b519a-f991-41d6-abbb-4d94d11273fa",
    "prId" : 19520,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/19520#pullrequestreview-97309940",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f8fc0aef-465f-4fb3-a1aa-73b4165c88a8",
        "parentId" : null,
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "possible nitpick, but is `any_extension_type` (without s) grammatically more correct?",
        "createdAt" : "2018-02-16T14:02:15Z",
        "updatedAt" : "2018-02-22T16:31:34Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      },
      {
        "id" : "ea5cda23-4eb1-4fa5-8f28-e0de1fb300a2",
        "parentId" : "f8fc0aef-465f-4fb3-a1aa-73b4165c88a8",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "hmm, we should not actually care about this, what is the reason?",
        "createdAt" : "2018-02-16T17:43:53Z",
        "updatedAt" : "2018-02-22T16:31:34Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "60c2ccb2-7497-4608-ab51-e47907991554",
        "parentId" : "f8fc0aef-465f-4fb3-a1aa-73b4165c88a8",
        "authorId" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "body" : "See the change to `NDFrame.count`. Without it there's an edge case for single-block DataFrames, since we do\r\n\r\n```python\r\n            if frame._is_mixed_type or frame._data.any_extension_types:\r\n                result = notna(frame).sum(axis=axis)\r\n            else:\r\n                counts = notna(frame.values).sum(axis=axis)  # This .values is bad for EA\r\n                result = Series(counts, index=frame._get_agg_axis(axis))\r\n```\r\n\r\nTaking the `self.values` coerces to objects, which will have incorrect `isna` behavior.",
        "createdAt" : "2018-02-16T20:35:23Z",
        "updatedAt" : "2018-02-22T16:31:34Z",
        "lastEditedBy" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "tags" : [
        ]
      },
      {
        "id" : "2eddb2b0-a64e-491e-9323-99b637189711",
        "parentId" : "f8fc0aef-465f-4fb3-a1aa-73b4165c88a8",
        "authorId" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "body" : "@jorisvandenbossche I with with `types` since you could have multiple kinds of extension array types in a DataFrame :)",
        "createdAt" : "2018-02-16T20:39:58Z",
        "updatedAt" : "2018-02-22T16:31:34Z",
        "lastEditedBy" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "tags" : [
        ]
      }
    ],
    "commit" : "ea5562b99d55062b2bb0a5b359bd5375adb3a46e",
    "line" : 76,
    "diffHunk" : "@@ -1,1 +3734,3738 @@\n    @property\n    def any_extension_types(self):\n        \"\"\"Whether any of the blocks in this manager are extension blocks\"\"\"\n        return any(block.is_extension for block in self.blocks)"
  },
  {
    "id" : "3c71a460-10b1-4cee-8143-532f69f6033c",
    "prId" : 19520,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/19520#pullrequestreview-97376515",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f39f91d8-7e9c-410e-a490-5464006b931e",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "so you should add a ``.ravel()`` method to EABlock (maybe Array), which just returns self.",
        "createdAt" : "2018-02-16T17:44:36Z",
        "updatedAt" : "2018-02-22T16:31:34Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "7f6a8b09-67ad-4f77-b478-76d18eaf5dad",
        "parentId" : "f39f91d8-7e9c-410e-a490-5464006b931e",
        "authorId" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "body" : "Yeah, I thought about that. Seems inelegant, but reasonable.",
        "createdAt" : "2018-02-16T20:41:14Z",
        "updatedAt" : "2018-02-22T16:31:34Z",
        "lastEditedBy" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "tags" : [
        ]
      },
      {
        "id" : "ef4463e3-45ba-44df-9ab7-a85fadabd730",
        "parentId" : "f39f91d8-7e9c-410e-a490-5464006b931e",
        "authorId" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "body" : "Ahh, hmm. Categorical.ravel actually casts to an ndarray. I don't think we want that though... And we don't want to be inconsistent between Catgorical and other EAs.\r\n",
        "createdAt" : "2018-02-16T20:43:57Z",
        "updatedAt" : "2018-02-22T16:31:34Z",
        "lastEditedBy" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "tags" : [
        ]
      },
      {
        "id" : "8c02d5d0-4c6a-4888-a1b5-c58c33d006bc",
        "parentId" : "f39f91d8-7e9c-410e-a490-5464006b931e",
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "If possible, I rather prefer to avoid adding `.ravel()` to the ExtensionArray interface (it's not useful as long as they are limited to 1D, and it would indeed be unclear what the expected return value would be (and EA or ndarray))",
        "createdAt" : "2018-02-17T15:28:24Z",
        "updatedAt" : "2018-02-22T16:31:34Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      }
    ],
    "commit" : "ea5562b99d55062b2bb0a5b359bd5375adb3a46e",
    "line" : 129,
    "diffHunk" : "@@ -1,1 +5714,5718 @@                return False\n            values_flat = values.ravel(order='K')\n        elif isinstance(self.block, ExtensionBlock):\n            values_flat = values\n        else:"
  },
  {
    "id" : "1cbd1e2c-6956-432b-90af-00cf8f9d3c34",
    "prId" : 19520,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/19520#pullrequestreview-98596750",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c3815693-832a-4ebd-b35a-0b6260aa8e4b",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "is this called anywhere else? (e.g. IOW I *think* can eliminate some code if maybe this was defined in the superclass)",
        "createdAt" : "2018-02-22T01:26:51Z",
        "updatedAt" : "2018-02-22T16:31:34Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "eeb61978-bac8-43d3-86a3-a7491eea53d6",
        "parentId" : "c3815693-832a-4ebd-b35a-0b6260aa8e4b",
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "No, this is only called in `__init__`, and was made into a separate method on your question. It's not defined in a superclass, so cannot be removed.",
        "createdAt" : "2018-02-22T13:39:22Z",
        "updatedAt" : "2018-02-22T16:31:34Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      },
      {
        "id" : "d1a804a5-eb22-4e28-b74e-01d55f790398",
        "parentId" : "c3815693-832a-4ebd-b35a-0b6260aa8e4b",
        "authorId" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "body" : "https://github.com/pandas-dev/pandas/issues/19492\r\n\r\nEventually Block.__init__ will call `self._maybe_coerce_values` and we can remove every subclasses's __init__. But there's some other work to be done first.",
        "createdAt" : "2018-02-22T14:30:10Z",
        "updatedAt" : "2018-02-22T16:31:34Z",
        "lastEditedBy" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "tags" : [
        ]
      },
      {
        "id" : "21f0c685-09f5-41c2-92e3-1f3eb8e9a4cf",
        "parentId" : "c3815693-832a-4ebd-b35a-0b6260aa8e4b",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "ok",
        "createdAt" : "2018-02-22T15:04:59Z",
        "updatedAt" : "2018-02-22T16:31:34Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "ea5562b99d55062b2bb0a5b359bd5375adb3a46e",
    "line" : 31,
    "diffHunk" : "@@ -1,1 +1866,1870 @@        super(ExtensionBlock, self).__init__(values, placement, ndim)\n\n    def _maybe_coerce_values(self, values):\n        \"\"\"Unbox to an extension array.\n"
  },
  {
    "id" : "86e8dbb7-a3b3-4ec7-82e8-19af5501e36c",
    "prId" : 19773,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/19773#pullrequestreview-100623689",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "763ebcc3-7fe7-4553-922d-94349ca17301",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "this should be in DatetimeBlock, puzzled why this works",
        "createdAt" : "2018-02-28T11:33:42Z",
        "updatedAt" : "2018-03-01T02:29:15Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "e8e4ce42-c93e-4ce6-94b5-bb9df301bb45",
        "parentId" : "763ebcc3-7fe7-4553-922d-94349ca17301",
        "authorId" : "eb0b5a98-1084-4e61-8414-5fb19728b91f",
        "body" : "You had mentioned, https://github.com/pandas-dev/pandas/pull/19773#discussion_r169189270, that this should belong in DatetimeTZBlock. \r\n\r\nAdditionally, DatetimeBlock can handle 2D data which can use the `algos.diff` method (dispatched via `Block.apply('diff', **kwargs)`) since that data can be converted to np.datetime64 cleanly. \r\n\r\n`DatetimeTZBlock` here overwrites the Block diff method that calls `algos.diff` but mimics the signature so everything is happy. \r\n",
        "createdAt" : "2018-02-28T19:01:18Z",
        "updatedAt" : "2018-03-01T02:29:15Z",
        "lastEditedBy" : "eb0b5a98-1084-4e61-8414-5fb19728b91f",
        "tags" : [
        ]
      },
      {
        "id" : "2bb39dfe-f119-4792-9b97-7ef0e1859410",
        "parentId" : "763ebcc3-7fe7-4553-922d-94349ca17301",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "yeah, ok for now. this whole diff bizness needs to be completely refactored.",
        "createdAt" : "2018-03-01T22:49:54Z",
        "updatedAt" : "2018-03-01T22:49:54Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "c77f5aa4338d87a4ed9df77752ecf8cbb8b1a82c",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +2906,2910 @@                                           placement=self.mgr_locs)]\n\n    def diff(self, n, axis=0, mgr=None):\n        \"\"\"1st discrete difference\n"
  },
  {
    "id" : "73d26f1d-4069-48ce-acad-ceb5fa2b4288",
    "prId" : 19907,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/19907#pullrequestreview-107526792",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "15ad06ce-fc9c-4583-95b2-417d85b42bb4",
        "parentId" : null,
        "authorId" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "body" : "If an ExtensionArray chooses to store it's data as `.values`, `setitem` would be broken without this extra check.",
        "createdAt" : "2018-02-26T16:07:02Z",
        "updatedAt" : "2018-04-15T19:02:15Z",
        "lastEditedBy" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "tags" : [
        ]
      },
      {
        "id" : "01ff7944-996e-4aa0-a27a-e9c9c3eec258",
        "parentId" : "15ad06ce-fc9c-4583-95b2-417d85b42bb4",
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "Should we make a test for this? (eg call the underlying data `.values` in of the example test arrays?",
        "createdAt" : "2018-02-27T12:18:53Z",
        "updatedAt" : "2018-04-15T19:02:15Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      },
      {
        "id" : "fb4f51ce-092d-49e3-9623-871f52106eef",
        "parentId" : "15ad06ce-fc9c-4583-95b2-417d85b42bb4",
        "authorId" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "body" : "DecimalArray calls it's underlying data `.values`. I'm going to alias a few other attributes to that (`.data`, `._data`, `.items`). Any others?",
        "createdAt" : "2018-02-27T13:21:50Z",
        "updatedAt" : "2018-04-15T19:02:15Z",
        "lastEditedBy" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "tags" : [
        ]
      },
      {
        "id" : "1ae414bc-c3ec-4253-bdeb-2ca7913e9f80",
        "parentId" : "15ad06ce-fc9c-4583-95b2-417d85b42bb4",
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "`_values`",
        "createdAt" : "2018-02-27T14:44:56Z",
        "updatedAt" : "2018-04-15T19:02:15Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      },
      {
        "id" : "145b0e63-caa5-47db-9c90-4bd7d42d50f5",
        "parentId" : "15ad06ce-fc9c-4583-95b2-417d85b42bb4",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "this is pretty special casey here. shouldn't this check for ``._values``?",
        "createdAt" : "2018-03-25T14:16:00Z",
        "updatedAt" : "2018-04-15T19:02:15Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "0b149429-37ec-4b94-a8ef-e344a87379f8",
        "parentId" : "15ad06ce-fc9c-4583-95b2-417d85b42bb4",
        "authorId" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "body" : "I'm not sure. I don't really know what could be in kwargs. You think it's only ever Index or Series? Or could it be a dataframe or block?",
        "createdAt" : "2018-03-28T02:16:57Z",
        "updatedAt" : "2018-04-15T19:02:15Z",
        "lastEditedBy" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "tags" : [
        ]
      }
    ],
    "commit" : "3cbe078f3675c293d934530dccc81cfb2904c9b3",
    "line" : 106,
    "diffHunk" : "@@ -1,1 +3550,3554 @@                            for k in align_keys\n                            if hasattr(kwargs[k], 'values') and\n                            not isinstance(kwargs[k], ABCExtensionArray))\n\n        for b in self.blocks:"
  },
  {
    "id" : "6837df9c-e15d-4a2d-9251-788a677cb038",
    "prId" : 19909,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/19909#pullrequestreview-99368049",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "06fc791e-fdce-451f-a8eb-7ae281c6e560",
        "parentId" : null,
        "authorId" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "body" : "This was moved from Categorical.fillna with changes\r\n\r\n1.) Removed check for limit, since that's done in `values.fillna`\r\n2.) Removed `_try_coerce_result`\r\n    For CategoricalBlock, this was unnecessary since\r\n    `Categorical.fillna` always returns a Categorical\r\n3.) Used `make_block_same_class`\r\n    This limits `ExtensionArray.fillna` to not change the type\r\n    of the array / block, which I think is a good thing.",
        "createdAt" : "2018-02-26T16:28:10Z",
        "updatedAt" : "2018-03-15T11:33:25Z",
        "lastEditedBy" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "tags" : [
        ]
      }
    ],
    "commit" : "05fced650bac03f122689ce6f8fd423f89bea3d6",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +1964,1968 @@                                          placement=placement)\n\n    def fillna(self, value, limit=None, inplace=False, downcast=None,\n               mgr=None):\n        values = self.values if inplace else self.values.copy()"
  },
  {
    "id" : "8c186d58-0e15-40c5-9f9c-08208833cc53",
    "prId" : 19909,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/19909#pullrequestreview-99368049",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1c91736f-1e50-4eb1-b111-edc5c700746e",
        "parentId" : null,
        "authorId" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "body" : "This was just a move from `CategoricalBlock` to `ExtensionBlock`, no changes.",
        "createdAt" : "2018-02-26T16:28:26Z",
        "updatedAt" : "2018-03-15T11:33:25Z",
        "lastEditedBy" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "tags" : [
        ]
      }
    ],
    "commit" : "05fced650bac03f122689ce6f8fd423f89bea3d6",
    "line" : 12,
    "diffHunk" : "@@ -1,1 +1972,1976 @@                                           ndim=self.ndim)]\n\n    def interpolate(self, method='pad', axis=0, inplace=False, limit=None,\n                    fill_value=None, **kwargs):\n"
  },
  {
    "id" : "94ab3dac-5909-497c-a70c-20172dcf8f98",
    "prId" : 20814,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/20814#pullrequestreview-115690242",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "80ae787d-4ecf-4340-b164-8ac1efb83057",
        "parentId" : null,
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "Can you add a docstring to indicate what you mean with \"uniform reindex\"\r\n\r\nI understand it as \"this are uniform blocks that will keep being uniform after reindexing\", correct? \r\nI am only wondering, does that not depend on the `fill_value` used? Or is this code path only taken in case of default filling (I don't think you can specify the filling with things like concat and merge, as opposed to reindex itself)",
        "createdAt" : "2018-04-26T15:22:31Z",
        "updatedAt" : "2018-04-27T11:02:56Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      },
      {
        "id" : "02f9f99d-4dd2-4334-99af-40305519398b",
        "parentId" : "80ae787d-4ecf-4340-b164-8ac1efb83057",
        "authorId" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "body" : "> this are uniform blocks that will keep being uniform after reindexing\r\n\r\nExactly. That's the intent anyway...\r\n\r\nIt probably does depend on the `fill_value`. I need to better understand `get_empty_dtype_and_na`",
        "createdAt" : "2018-04-26T18:10:36Z",
        "updatedAt" : "2018-04-27T11:02:56Z",
        "lastEditedBy" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "tags" : [
        ]
      }
    ],
    "commit" : "ec0cecd292947aa4d8416991e9f8920a4cd9a831",
    "line" : 27,
    "diffHunk" : "@@ -1,1 +5448,5452 @@\ndef is_uniform_reindex(join_units):\n    return (\n        # TODO: should this be ju.block._can_hold_na?\n        all(ju.block and ju.block.is_extension for ju in join_units) and"
  },
  {
    "id" : "8b4331b8-9ecf-4c66-8731-fae3123733ba",
    "prId" : 20814,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/20814#pullrequestreview-115694734",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e6e11ac9-22e0-4c13-b129-2aaf91c86345",
        "parentId" : null,
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "Did you check this for the Categorical case? (I think I asked about it before) It's fine to disallow the categorical case in this check for now (we still need to fix Categorical.take in general in a follow-up PR anyhow), but I think categoricals now pass this check? \r\n(and now with the current code, they would return object dtype I think)\r\n",
        "createdAt" : "2018-04-26T15:25:39Z",
        "updatedAt" : "2018-04-27T11:02:56Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      },
      {
        "id" : "203ed172-02a9-44c6-a161-278c57b32ae5",
        "parentId" : "e6e11ac9-22e0-4c13-b129-2aaf91c86345",
        "authorId" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "body" : "Categorical hits this, but `empty_dtype` ends up being ignored for several reasons. Primarily, `JoinUnit[CategoricalBlock].is_na` is always false (https://github.com/pandas-dev/pandas/issues/20833) and `empty_dtype` is only used in an `is_na` block.\r\n\r\nAnd `upcated_na` is `np.nan` for categorical, just like before.",
        "createdAt" : "2018-04-26T18:23:24Z",
        "updatedAt" : "2018-04-27T11:02:56Z",
        "lastEditedBy" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "tags" : [
        ]
      }
    ],
    "commit" : "ec0cecd292947aa4d8416991e9f8920a4cd9a831",
    "line" : 30,
    "diffHunk" : "@@ -1,1 +5451,5455 @@        # TODO: should this be ju.block._can_hold_na?\n        all(ju.block and ju.block.is_extension for ju in join_units) and\n        len(set(ju.block.dtype.name for ju in join_units)) == 1\n    )\n"
  },
  {
    "id" : "0e6c0e0f-6823-468f-bef8-64fad97f7279",
    "prId" : 20814,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/20814#pullrequestreview-404981947",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "faacc982-5217-4edb-b39a-7689a405fce7",
        "parentId" : null,
        "authorId" : "adf621f1-4745-479a-a1fc-dc14046a3f4b",
        "body" : "@TomAugspurger long shot any recollection what this comment is asking for?",
        "createdAt" : "2020-05-01T23:44:47Z",
        "updatedAt" : "2020-05-01T23:44:47Z",
        "lastEditedBy" : "adf621f1-4745-479a-a1fc-dc14046a3f4b",
        "tags" : [
        ]
      },
      {
        "id" : "811e9424-427c-4996-81a7-2a43c32a01f1",
        "parentId" : "faacc982-5217-4edb-b39a-7689a405fce7",
        "authorId" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "body" : "Removing the need for that `is_uniform_reindex` check by including that case in the main `if / elif` block (which may be done on master now?)",
        "createdAt" : "2020-05-04T13:23:53Z",
        "updatedAt" : "2020-05-04T13:23:54Z",
        "lastEditedBy" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "tags" : [
        ]
      }
    ],
    "commit" : "ec0cecd292947aa4d8416991e9f8920a4cd9a831",
    "line" : 42,
    "diffHunk" : "@@ -1,1 +5473,5477 @@\n    if is_uniform_reindex(join_units):\n        # XXX: integrate property\n        empty_dtype = join_units[0].block.dtype\n        upcasted_na = join_units[0].block.fill_value"
  },
  {
    "id" : "217df286-4ce5-4edb-88e4-2efbea2aa459",
    "prId" : 21660,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/21660#pullrequestreview-133388034",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "20f11f24-3491-4772-9e5f-27cebc61f114",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "we really need this?",
        "createdAt" : "2018-06-29T00:32:55Z",
        "updatedAt" : "2018-07-02T23:53:42Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "ac7abc08-9e84-4a36-a884-86a5f8358611",
        "parentId" : "20f11f24-3491-4772-9e5f-27cebc61f114",
        "authorId" : "566dc560-80aa-4568-8fca-9708238ffbe9",
        "body" : "Without lines 1487-1488 `cond` and `values` have opposite dimension, which is the root cause of (the DataFrame part of) #21544. \r\n\r\nThe issue is DatetimeTZBlock._try_coerce_args returns `values` as a 2-D array. I've updated _try_coerce_args so that `other` also is a 2-D array for consistency, which fixes part of the issue.\r\n\r\nHowever, we don't run _try_coerce_args until the interior of func at 1499. Thus lines 1476-1477 (`values = values.T`) is a no-op given a DatetimeTZBlock (since at that point `values` is 1-D). `other._values` is also a 1-D DatetimeIndex. So to make `cond` consistent with the `values` and `other` we get out of _try_coerce_args it needs to be transposed.\r\n\r\nAn alternative would be changing `DatetimeTZBlock._try_coerce_args to return 1-D arrays for values and values_mask (changing 2875-2877). But if I do that it breaks setitem.",
        "createdAt" : "2018-06-29T21:51:47Z",
        "updatedAt" : "2018-07-02T23:53:42Z",
        "lastEditedBy" : "566dc560-80aa-4568-8fca-9708238ffbe9",
        "tags" : [
        ]
      }
    ],
    "commit" : "c97b951f434e02cc98d986ac7c1a8016fb7ca37f",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +1485,1489 @@            if values.ndim - 1 == other.ndim and axis == 1:\n                other = other.reshape(tuple(other.shape + (1, )))\n            elif transpose and values.ndim == self.ndim - 1:\n                cond = cond.T\n"
  }
]
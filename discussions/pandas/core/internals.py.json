[
  {
    "id" : "353f0e7b-8c51-4089-b3f3-da652216d41b",
    "prId" : 4073,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "21e38615-683a-4ac3-924d-44f466159f54",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "boy - guess was not thinking when I originally wrote that\n",
        "createdAt" : "2013-06-28T14:57:00Z",
        "updatedAt" : "2013-06-28T16:00:01Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "ec43b1ed-aad0-431e-aa37-ebf4d6ceca23",
        "parentId" : "21e38615-683a-4ac3-924d-44f466159f54",
        "authorId" : "5c239b83-5a68-467b-a3f8-113a0fc494dc",
        "body" : "still worked tho...strange since enumerate composed with range should yield a tuple thus accessing the diagonal of the mask (in this case)...seems like that would have broken things (in a more general way)\n",
        "createdAt" : "2013-06-28T15:01:20Z",
        "updatedAt" : "2013-06-28T16:00:01Z",
        "lastEditedBy" : "5c239b83-5a68-467b-a3f8-113a0fc494dc",
        "tags" : [
        ]
      },
      {
        "id" : "594c1684-257b-4836-859b-009362392cc3",
        "parentId" : "21e38615-683a-4ac3-924d-44f466159f54",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "ok if your fix worked grrat\n",
        "createdAt" : "2013-06-28T15:06:41Z",
        "updatedAt" : "2013-06-28T16:00:01Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "3bac1816bac4be72ef2be7ab305eaea081604c2f",
    "line" : 9,
    "diffHunk" : "@@ -1,1 +578,582 @@        axis = cond.ndim - 1\n        cond = cond.swapaxes(axis, 0)\n        mask = np.array([cond[i].all() for i in xrange(cond.shape[0])],\n                        dtype=bool)\n"
  },
  {
    "id" : "8fbd2cfb-8de0-46c3-8878-469f4114cdb5",
    "prId" : 4313,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9aca9b9b-d313-4dee-af2a-294815501cb3",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "use a date_formatter function (like above); you don't need to handle nulls here as that is already handled in the imask (eg you will get NO nulls in the list comprehension)\n",
        "createdAt" : "2013-10-09T12:05:35Z",
        "updatedAt" : "2013-10-12T05:11:18Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "ce669d6f295f7ece6223535c75c5012cb3c553c1",
    "line" : 24,
    "diffHunk" : "@@ -1,1 +1410,1414 @@        rvalues[mask] = na_rep\n        imask = (-mask).ravel()\n\n        if date_format is None:\n            date_formatter = lambda x: Timestamp(x)._repr_base"
  },
  {
    "id" : "7c96ed60-01e0-4f32-9c4f-002739ab6235",
    "prId" : 4756,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "040aeb6b-3d5c-4bae-90f6-fc7a3c675d8f",
        "parentId" : null,
        "authorId" : "5c239b83-5a68-467b-a3f8-113a0fc494dc",
        "body" : "Should there be tests for negative slices? Or are those somewhere else?\n",
        "createdAt" : "2013-09-05T20:16:34Z",
        "updatedAt" : "2013-09-06T01:16:11Z",
        "lastEditedBy" : "5c239b83-5a68-467b-a3f8-113a0fc494dc",
        "tags" : [
        ]
      }
    ],
    "commit" : "caa370374b1c495e4d998ae1e11c1561fcbac511",
    "line" : 24,
    "diffHunk" : "@@ -1,1 +568,572 @@                if start is None:\n                    start = 0\n                elif start < 0:\n                    start += l\n                if stop is None or stop > l:"
  },
  {
    "id" : "afa83aa1-3d4e-4497-af81-7c8a67918c68",
    "prId" : 5270,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8380833d-0a99-4261-9828-7600995fc64a",
        "parentId" : null,
        "authorId" : "6f890fbc-4bdf-4397-95eb-a8225d4af04f",
        "body" : "What do you think of: `Length mismatch: Existing axis has %d elements, new values have %d elements`? Might be clearer.\n",
        "createdAt" : "2013-10-20T20:23:18Z",
        "updatedAt" : "2013-10-20T20:23:18Z",
        "lastEditedBy" : "6f890fbc-4bdf-4397-95eb-a8225d4af04f",
        "tags" : [
        ]
      }
    ],
    "commit" : "8c502a2faf8a8fd2200f2ad076b5b3f76d8c38e9",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +1882,1886 @@\n        if check_axis and len(value) != len(cur_axis):\n            raise ValueError('Length mismatch: Expected %d elements, got %d elements'\n                            % (len(cur_axis), len(value)))\n"
  },
  {
    "id" : "d768dcdb-0889-4092-a3fd-8af466f44b3e",
    "prId" : 5283,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5a84f10c-5d51-4d58-b7de-8892c718d417",
        "parentId" : null,
        "authorId" : "49cb7e4b-934a-4329-961e-4089057c4185",
        "body" : "I just want to record this here, since my thoughts on this matter have been so muddled:\n\n`np.array_equal` treats NaNs in object arrays as equal:\n\n```\n>>> np.array_equal(np.array([np.nan], dtype='O'), np.array([np.nan], dtype='O'))\nTrue\n```\n\nso object arrays do not need to be special-cased, `ObjectBlock.equals` does not need to be defined, and `ObjectBlock.equals` can defer to `Block.equals`. Only `FloatBlocks` and `ComplexBlocks` need to define their own `equals` method, since, for example,\n\n```\n>>> np.array_equal(np.array([np.nan], dtype='<f4'), np.array([np.nan], dtype='<f4'))\nFalse\n>>> np.array_equal(np.array([np.nan], dtype='complex128'), np.array([np.nan], dtype='complex128'))\nFalse\n```\n\nThankfully, `np.array_equal` also treats `NaT`s as equal:\n\n```\n>>> np.array_equal(np.array([np.datetime64('nat')]), np.array([np.datetime64('nat')]))\nTrue\n```\n\n`NaNs` can not exist in `bool` arrays:\n\n```\n>>> np.array([np.nan], dtype='bool')\narray([ True], dtype=bool)\n```\n\nor can `NaN`s exist in timedeltas:\n\n```\n>>> np.timedelta64(np.nan,'D')\nValueError: Could not convert object to NumPy timedelta\n```\n\nso `np.array_equal` should work as usual for these kinds of values.\n",
        "createdAt" : "2014-01-21T22:02:12Z",
        "updatedAt" : "2014-01-24T21:01:32Z",
        "lastEditedBy" : "49cb7e4b-934a-4329-961e-4089057c4185",
        "tags" : [
        ]
      }
    ],
    "commit" : "9f26fbc915e2759e0bcadaa93cb00610297e6a7e",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +1124,1128 @@    def equals(self, other):\n        if self.dtype != other.dtype or self.shape != other.shape: return False\n        return np.array_equal(self.values, other.values)\n\n"
  },
  {
    "id" : "bd67c065-e868-4c03-a042-063933d964af",
    "prId" : 5283,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1aa2b2f8-6b2d-4449-8753-d2e4f979c9cd",
        "parentId" : null,
        "authorId" : "49cb7e4b-934a-4329-961e-4089057c4185",
        "body" : "The example you gave did indeed break the code. I've added your example to test_internals.py and am handling this case by sorting the blocks according to their `ref_locs`.\n",
        "createdAt" : "2014-01-23T04:18:45Z",
        "updatedAt" : "2014-01-24T21:01:32Z",
        "lastEditedBy" : "49cb7e4b-934a-4329-961e-4089057c4185",
        "tags" : [
        ]
      }
    ],
    "commit" : "9f26fbc915e2759e0bcadaa93cb00610297e6a7e",
    "line" : 66,
    "diffHunk" : "@@ -1,1 +4025,4029 @@            dtype = blocks[0].dtype\n\n        if not items.is_unique:\n            blocks = sorted(blocks, key=lambda b: b.ref_locs.tolist())\n"
  }
]
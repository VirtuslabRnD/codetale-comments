[
  {
    "id" : "353f0e7b-8c51-4089-b3f3-da652216d41b",
    "prId" : 4073,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "21e38615-683a-4ac3-924d-44f466159f54",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "boy - guess was not thinking when I originally wrote that\n",
        "createdAt" : "2013-06-28T14:57:00Z",
        "updatedAt" : "2013-06-28T16:00:01Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "ec43b1ed-aad0-431e-aa37-ebf4d6ceca23",
        "parentId" : "21e38615-683a-4ac3-924d-44f466159f54",
        "authorId" : "5c239b83-5a68-467b-a3f8-113a0fc494dc",
        "body" : "still worked tho...strange since enumerate composed with range should yield a tuple thus accessing the diagonal of the mask (in this case)...seems like that would have broken things (in a more general way)\n",
        "createdAt" : "2013-06-28T15:01:20Z",
        "updatedAt" : "2013-06-28T16:00:01Z",
        "lastEditedBy" : "5c239b83-5a68-467b-a3f8-113a0fc494dc",
        "tags" : [
        ]
      },
      {
        "id" : "594c1684-257b-4836-859b-009362392cc3",
        "parentId" : "21e38615-683a-4ac3-924d-44f466159f54",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "ok if your fix worked grrat\n",
        "createdAt" : "2013-06-28T15:06:41Z",
        "updatedAt" : "2013-06-28T16:00:01Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "3bac1816bac4be72ef2be7ab305eaea081604c2f",
    "line" : 9,
    "diffHunk" : "@@ -1,1 +578,582 @@        axis = cond.ndim - 1\n        cond = cond.swapaxes(axis, 0)\n        mask = np.array([cond[i].all() for i in xrange(cond.shape[0])],\n                        dtype=bool)\n"
  },
  {
    "id" : "8fbd2cfb-8de0-46c3-8878-469f4114cdb5",
    "prId" : 4313,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9aca9b9b-d313-4dee-af2a-294815501cb3",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "use a date_formatter function (like above); you don't need to handle nulls here as that is already handled in the imask (eg you will get NO nulls in the list comprehension)\n",
        "createdAt" : "2013-10-09T12:05:35Z",
        "updatedAt" : "2013-10-12T05:11:18Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "ce669d6f295f7ece6223535c75c5012cb3c553c1",
    "line" : 24,
    "diffHunk" : "@@ -1,1 +1410,1414 @@        rvalues[mask] = na_rep\n        imask = (-mask).ravel()\n\n        if date_format is None:\n            date_formatter = lambda x: Timestamp(x)._repr_base"
  },
  {
    "id" : "7c96ed60-01e0-4f32-9c4f-002739ab6235",
    "prId" : 4756,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "040aeb6b-3d5c-4bae-90f6-fc7a3c675d8f",
        "parentId" : null,
        "authorId" : "5c239b83-5a68-467b-a3f8-113a0fc494dc",
        "body" : "Should there be tests for negative slices? Or are those somewhere else?\n",
        "createdAt" : "2013-09-05T20:16:34Z",
        "updatedAt" : "2013-09-06T01:16:11Z",
        "lastEditedBy" : "5c239b83-5a68-467b-a3f8-113a0fc494dc",
        "tags" : [
        ]
      }
    ],
    "commit" : "caa370374b1c495e4d998ae1e11c1561fcbac511",
    "line" : 24,
    "diffHunk" : "@@ -1,1 +568,572 @@                if start is None:\n                    start = 0\n                elif start < 0:\n                    start += l\n                if stop is None or stop > l:"
  },
  {
    "id" : "afa83aa1-3d4e-4497-af81-7c8a67918c68",
    "prId" : 5270,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8380833d-0a99-4261-9828-7600995fc64a",
        "parentId" : null,
        "authorId" : "6f890fbc-4bdf-4397-95eb-a8225d4af04f",
        "body" : "What do you think of: `Length mismatch: Existing axis has %d elements, new values have %d elements`? Might be clearer.\n",
        "createdAt" : "2013-10-20T20:23:18Z",
        "updatedAt" : "2013-10-20T20:23:18Z",
        "lastEditedBy" : "6f890fbc-4bdf-4397-95eb-a8225d4af04f",
        "tags" : [
        ]
      }
    ],
    "commit" : "8c502a2faf8a8fd2200f2ad076b5b3f76d8c38e9",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +1882,1886 @@\n        if check_axis and len(value) != len(cur_axis):\n            raise ValueError('Length mismatch: Expected %d elements, got %d elements'\n                            % (len(cur_axis), len(value)))\n"
  },
  {
    "id" : "d768dcdb-0889-4092-a3fd-8af466f44b3e",
    "prId" : 5283,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5a84f10c-5d51-4d58-b7de-8892c718d417",
        "parentId" : null,
        "authorId" : "49cb7e4b-934a-4329-961e-4089057c4185",
        "body" : "I just want to record this here, since my thoughts on this matter have been so muddled:\n\n`np.array_equal` treats NaNs in object arrays as equal:\n\n```\n>>> np.array_equal(np.array([np.nan], dtype='O'), np.array([np.nan], dtype='O'))\nTrue\n```\n\nso object arrays do not need to be special-cased, `ObjectBlock.equals` does not need to be defined, and `ObjectBlock.equals` can defer to `Block.equals`. Only `FloatBlocks` and `ComplexBlocks` need to define their own `equals` method, since, for example,\n\n```\n>>> np.array_equal(np.array([np.nan], dtype='<f4'), np.array([np.nan], dtype='<f4'))\nFalse\n>>> np.array_equal(np.array([np.nan], dtype='complex128'), np.array([np.nan], dtype='complex128'))\nFalse\n```\n\nThankfully, `np.array_equal` also treats `NaT`s as equal:\n\n```\n>>> np.array_equal(np.array([np.datetime64('nat')]), np.array([np.datetime64('nat')]))\nTrue\n```\n\n`NaNs` can not exist in `bool` arrays:\n\n```\n>>> np.array([np.nan], dtype='bool')\narray([ True], dtype=bool)\n```\n\nor can `NaN`s exist in timedeltas:\n\n```\n>>> np.timedelta64(np.nan,'D')\nValueError: Could not convert object to NumPy timedelta\n```\n\nso `np.array_equal` should work as usual for these kinds of values.\n",
        "createdAt" : "2014-01-21T22:02:12Z",
        "updatedAt" : "2014-01-24T21:01:32Z",
        "lastEditedBy" : "49cb7e4b-934a-4329-961e-4089057c4185",
        "tags" : [
        ]
      }
    ],
    "commit" : "9f26fbc915e2759e0bcadaa93cb00610297e6a7e",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +1124,1128 @@    def equals(self, other):\n        if self.dtype != other.dtype or self.shape != other.shape: return False\n        return np.array_equal(self.values, other.values)\n\n"
  },
  {
    "id" : "bd67c065-e868-4c03-a042-063933d964af",
    "prId" : 5283,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1aa2b2f8-6b2d-4449-8753-d2e4f979c9cd",
        "parentId" : null,
        "authorId" : "49cb7e4b-934a-4329-961e-4089057c4185",
        "body" : "The example you gave did indeed break the code. I've added your example to test_internals.py and am handling this case by sorting the blocks according to their `ref_locs`.\n",
        "createdAt" : "2014-01-23T04:18:45Z",
        "updatedAt" : "2014-01-24T21:01:32Z",
        "lastEditedBy" : "49cb7e4b-934a-4329-961e-4089057c4185",
        "tags" : [
        ]
      }
    ],
    "commit" : "9f26fbc915e2759e0bcadaa93cb00610297e6a7e",
    "line" : 66,
    "diffHunk" : "@@ -1,1 +4025,4029 @@            dtype = blocks[0].dtype\n\n        if not items.is_unique:\n            blocks = sorted(blocks, key=lambda b: b.ref_locs.tolist())\n"
  },
  {
    "id" : "8ea2a7f4-3200-4a36-bbd5-74b2f4e11ed7",
    "prId" : 6745,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/6745#pullrequestreview-404356698",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "98f9361b-96ab-4b99-a908-22099cbb6816",
        "parentId" : null,
        "authorId" : "adf621f1-4745-479a-a1fc-dc14046a3f4b",
        "body" : "@jreback long-shot any idea if this FIXME is still needed or what it would take to address?",
        "createdAt" : "2020-05-01T14:04:27Z",
        "updatedAt" : "2020-05-01T14:04:27Z",
        "lastEditedBy" : "adf621f1-4745-479a-a1fc-dc14046a3f4b",
        "tags" : [
        ]
      },
      {
        "id" : "54540c7c-936b-4796-aa8a-a9376cfbdf9f",
        "parentId" : "98f9361b-96ab-4b99-a908-22099cbb6816",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "no idea\nsorry ",
        "createdAt" : "2020-05-01T16:33:12Z",
        "updatedAt" : "2020-05-01T16:33:12Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "6992041c-ba75-4719-8781-81d335c1cb01",
        "parentId" : "98f9361b-96ab-4b99-a908-22099cbb6816",
        "authorId" : "413be534-cedb-4df7-abda-cde26db33acd",
        "body" : "This PR is sure quite a trip down the memory lane :) \r\n\r\nUnfortunately, I don't quite remember what was the problem with pytables serialisation here, but looks like mgr_locs are returned in ascending order from `lib.get_blkno_indexers` anyway, so it's likely that the FIXME is not needed anymore.",
        "createdAt" : "2020-05-01T19:33:53Z",
        "updatedAt" : "2020-05-01T19:33:54Z",
        "lastEditedBy" : "413be534-cedb-4df7-abda-cde26db33acd",
        "tags" : [
        ]
      }
    ],
    "commit" : "f51235aef9bbb50632b569d9e0c104816e5e31a0",
    "line" : 2950,
    "diffHunk" : "@@ -1,1 +2863,2867 @@        #\n        # FIXME: mgr_groupby_blknos must return mgr_locs in ascending order,\n        # pytables serialization will break otherwise.\n        blocks = []\n        for blkno, mgr_locs in _get_blkno_placements(blknos, len(self.blocks),"
  },
  {
    "id" : "ba7a2f2c-5a26-489b-8419-2f1f085ea0d9",
    "prId" : 7370,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0813edea-72c8-4933-898c-8f51cc79fde3",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "why don't you add a version tag instead, this seems kind of odd to do it this way\n",
        "createdAt" : "2014-06-18T20:54:48Z",
        "updatedAt" : "2014-07-01T04:31:26Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "4e7b5f80-76ab-490e-9ba0-25506fcd0ff0",
        "parentId" : "0813edea-72c8-4933-898c-8f51cc79fde3",
        "authorId" : "413be534-cedb-4df7-abda-cde26db33acd",
        "body" : "There's an \"upcoming\" version tag, as in the first stable version having this serialization format, serving as a key into this dictionary. Or do you mean something else?\n",
        "createdAt" : "2014-06-18T21:12:29Z",
        "updatedAt" : "2014-07-01T04:31:26Z",
        "lastEditedBy" : "413be534-cedb-4df7-abda-cde26db33acd",
        "tags" : [
        ]
      },
      {
        "id" : "feb160dd-8242-4934-a4ec-77dc73c83e69",
        "parentId" : "0813edea-72c8-4933-898c-8f51cc79fde3",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "no I meant having the version as the _key_ was odd, why not just as a key-value in the dict, e.g. `version : '0.14.1'`\n",
        "createdAt" : "2014-06-18T21:13:51Z",
        "updatedAt" : "2014-07-01T04:31:26Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "65bbf9ec-cdef-498f-a272-59839b22b041",
        "parentId" : "0813edea-72c8-4933-898c-8f51cc79fde3",
        "authorId" : "413be534-cedb-4df7-abda-cde26db33acd",
        "body" : "I figured, something like this:\n\n``` python\nfor ver in list(supported_versions):\n    if ver in state:\n        setstate_ver(state[ver])\n```\n\nwould be easier on the eye than:\n\n``` python\nfor ver in list(supported_versions):\n     for d in state.values():\n        if d['version'] == ver:\n            setstate(d)\n            break\n```\n\nBut it's not a strong opinion, rather a gut feeling. If you insist, I'll make the version a dictionary element again.\n",
        "createdAt" : "2014-06-18T21:25:04Z",
        "updatedAt" : "2014-07-01T04:31:26Z",
        "lastEditedBy" : "413be534-cedb-4df7-abda-cde26db33acd",
        "tags" : [
        ]
      },
      {
        "id" : "dd19d504-efff-42aa-b59b-973873e9068b",
        "parentId" : "0813edea-72c8-4933-898c-8f51cc79fde3",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "ok, either way is fine. Just trying to make it easy on future versions.\n",
        "createdAt" : "2014-06-18T21:32:55Z",
        "updatedAt" : "2014-07-01T04:31:26Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "a9761d1331694620de13afdd7c70315203ef510a",
    "line" : 33,
    "diffHunk" : "@@ -1,1 +2055,2059 @@        axes_array = [ax for ax in self.axes]\n\n        extra_state = {\n            '0.14.1': {\n                'axes': axes_array,"
  }
]
[
  {
    "id" : "b803c5f1-c0fb-4688-848e-ab8a15ca67a0",
    "prId" : 22318,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/22318#pullrequestreview-148462777",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "218e2d79-0cd4-4c88-8086-fb7d459c1409",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "write this as \r\n```\r\nconcatenated = concat(....)\r\nconcatenated = concatenated.reindex(...)\r\n```\r\nuse copy=False",
        "createdAt" : "2018-08-22T12:47:08Z",
        "updatedAt" : "2019-07-03T02:21:43Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "cc9c79b03dc9897a436a1cff8cbc26e4d10f2f59",
    "line" : 10,
    "diffHunk" : "@@ -1,1 +567,571 @@        concatenated = concatenated.reindex(concat_index, axis=other_axis,\n                                            copy=False)\n        return self._set_result_index_ordered(concatenated)\n\n    @Substitution(klass='DataFrame', selected='')"
  },
  {
    "id" : "bfc64e04-ce45-4956-abc8-4ae1ef37b80e",
    "prId" : 22699,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/22699#pullrequestreview-156353721",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "37b344ca-c855-4c61-ad9b-b9c53c7861da",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "in theory we could add a lint rule to avoid using ``collection.Iterable``, and instead just use our compat",
        "createdAt" : "2018-09-18T11:40:34Z",
        "updatedAt" : "2018-09-18T15:03:10Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "f15e3ef1-3bea-4fdc-830e-a68ebb1641b7",
        "parentId" : "37b344ca-c855-4c61-ad9b-b9c53c7861da",
        "authorId" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "body" : "I think we're close enough to py3-only that we'll be OK. Writing that regex would be a bit fiddly since we'd need to enumerate all the ABCs.",
        "createdAt" : "2018-09-18T12:50:19Z",
        "updatedAt" : "2018-09-18T15:03:10Z",
        "lastEditedBy" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "tags" : [
        ]
      },
      {
        "id" : "77a6f8d3-1dae-402c-9f73-816b3eab6e6c",
        "parentId" : "37b344ca-c855-4c61-ad9b-b9c53c7861da",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "true, certainly a follow up issue is ok",
        "createdAt" : "2018-09-18T13:03:00Z",
        "updatedAt" : "2018-09-18T15:03:10Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "4990fc2d984b536e5c7c97ad55d4f550ae661867",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +759,763 @@            return getattr(self, func_or_funcs)(*args, **kwargs)\n\n        if isinstance(func_or_funcs, compat.Iterable):\n            # Catch instances of lists / tuples\n            # but not the class list / tuple itself."
  }
]
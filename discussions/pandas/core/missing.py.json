[
  {
    "id" : "8ba9a152-e69d-4cb7-a92d-32c4df42feea",
    "prId" : 16429,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/16429#pullrequestreview-41897937",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7e3c685d-99f6-4065-ac4a-ac6179db6c43",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "@TomAugspurger not sure if this is where the perf issue is (maybe because not this IS hit in all code).\r\n\r\nthese can be done via Index set ops\r\n\r\nIOW\r\n\r\n```\r\nstart_nans = Index(range(.....))\r\n\r\nviolate_limit = start_nans.union(Index(_interp_limit(invalid, limit, 0))).sort_values()\r\n```\r\nfor example",
        "createdAt" : "2017-06-02T22:38:05Z",
        "updatedAt" : "2017-06-02T22:38:05Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "d3d9cb38f0d9297a568d33f5a2759eeb9bb06850",
    "line" : 59,
    "diffHunk" : "@@ -1,1 +189,193 @@    # each possible limit_direction\n    if limit_direction == 'forward':\n        violate_limit = sorted(start_nans |\n                               set(_interp_limit(invalid, limit, 0)))\n    elif limit_direction == 'backward':"
  },
  {
    "id" : "4fa5fdb5-9027-49dc-a854-f46ca99b55b7",
    "prId" : 24536,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/24536#pullrequestreview-188567659",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d005b3ec-4f7c-4f7e-8197-94653036dcc9",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "is something failing? i agree this is probably the soln. but likely these are converted prior to calling this (to i8)",
        "createdAt" : "2019-01-01T20:12:14Z",
        "updatedAt" : "2019-01-01T21:08:36Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "39c073db-752d-414f-ad80-dc0ecb316046",
        "parentId" : "d005b3ec-4f7c-4f7e-8197-94653036dcc9",
        "authorId" : "adf621f1-4745-479a-a1fc-dc14046a3f4b",
        "body" : "Presumably; I haven’t looked at the series code to see how it handles this.  Enough core.missing mysteries have popped up today I’ll be giving them a close look after the RC",
        "createdAt" : "2019-01-01T21:03:28Z",
        "updatedAt" : "2019-01-01T21:08:36Z",
        "lastEditedBy" : "adf621f1-4745-479a-a1fc-dc14046a3f4b",
        "tags" : [
        ]
      },
      {
        "id" : "fdf0e77c-335c-422b-9b1d-bf43a8da03a5",
        "parentId" : "d005b3ec-4f7c-4f7e-8197-94653036dcc9",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "sure",
        "createdAt" : "2019-01-01T21:05:15Z",
        "updatedAt" : "2019-01-01T21:08:36Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "52e01ae3cfa3f92fa75bd66a7bc7d4fb85f280ff",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +483,487 @@        _method = algos.pad_inplace_object\n    elif is_timedelta64_dtype(values):\n        # NaTs are treated identically to datetime64, so we can dispatch\n        #  to that implementation\n        _method = _pad_1d_datetime"
  },
  {
    "id" : "bfdbecb7-2b1f-40f8-97ca-00eee2b2531c",
    "prId" : 24652,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/24652#pullrequestreview-189636085",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7b023aee-3d29-46f8-85e8-12bd304453db",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "no idea why this would be. Would really try to be consistent. I think copy is more sematically correct for these types of routines, as we can't always guaranteee inplace behavior (meaning we *may* have to copy sometimes). So this may have some uncessary copying going on, but willing to trade that for better semantics.",
        "createdAt" : "2019-01-06T16:13:49Z",
        "updatedAt" : "2019-01-06T16:13:54Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "2da3861e-089f-4a48-9be9-7438e3d8d897",
        "parentId" : "7b023aee-3d29-46f8-85e8-12bd304453db",
        "authorId" : "adf621f1-4745-479a-a1fc-dc14046a3f4b",
        "body" : "Yah, this came up when testing fillna from #24024.  In at least a few of the places where this is used, we make a copy before calling, so we can trim some overhead by being a bit more careful.\r\n\r\nI'm going to try to handle this more systematically at the same time I take a look at #24537.  Would like to keep the comment there for the time being; I think this was just not noticed previously.",
        "createdAt" : "2019-01-06T16:27:14Z",
        "updatedAt" : "2019-01-06T16:27:14Z",
        "lastEditedBy" : "adf621f1-4745-479a-a1fc-dc14046a3f4b",
        "tags" : [
        ]
      },
      {
        "id" : "66fd04fc-1342-4edb-b6a6-4233e47d38f2",
        "parentId" : "7b023aee-3d29-46f8-85e8-12bd304453db",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "absolutely. I am ok with inplace too. Its just then the guarantee to the caller will have to be stronger. We probably don't have enough tests in place to make a strong statement either way, but go for it. This looks like a nice re-factor, so could address the inplace/copy question later (as long as we are pretty sure its not actualy mutating things in the caller, unless its specifically allowed).",
        "createdAt" : "2019-01-06T16:32:21Z",
        "updatedAt" : "2019-01-06T16:32:21Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "e42bc27ba9a43ef15cb50b64e81c48a1099739ae",
    "line" : 21,
    "diffHunk" : "@@ -1,1 +457,461 @@    Cast values to a dtype that algos.pad and algos.backfill can handle.\n    \"\"\"\n    # TODO: for int-dtypes we make a copy, but for everything else this\n    #  alters the values in-place.  Is this intentional?\n"
  }
]
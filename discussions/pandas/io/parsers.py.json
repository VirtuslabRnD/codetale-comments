[
  {
    "id" : "d8ff93ac-17fa-4434-9a7f-82e04e1229d8",
    "prId" : 952,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4b44d367-d464-4ade-980e-84b95ffa3ea2",
        "parentId" : null,
        "authorId" : "c1e22f62-b6a4-49af-9e65-1ac7ae69e3bb",
        "body" : "I'd be less strict with this first check - there might be situations where you want to pass a generator rather than a list. I'd do `self.colspecs = list(colspecs)`, and let it handle anything that can be turned into a list.\n",
        "createdAt" : "2012-03-22T15:20:30Z",
        "updatedAt" : "2012-03-24T22:50:19Z",
        "lastEditedBy" : "c1e22f62-b6a4-49af-9e65-1ac7ae69e3bb",
        "tags" : [
        ]
      },
      {
        "id" : "e750171b-737f-463a-a536-d761bdddfbc7",
        "parentId" : "4b44d367-d464-4ade-980e-84b95ffa3ea2",
        "authorId" : "b74e9201-b200-4bc3-b475-a572ab0ad62b",
        "body" : "Good idea. WIll do.\n",
        "createdAt" : "2012-03-22T16:07:00Z",
        "updatedAt" : "2012-03-24T22:50:19Z",
        "lastEditedBy" : "b74e9201-b200-4bc3-b475-a572ab0ad62b",
        "tags" : [
        ]
      },
      {
        "id" : "14d4ce79-4580-4613-984b-993fb7185b14",
        "parentId" : "4b44d367-d464-4ade-980e-84b95ffa3ea2",
        "authorId" : "b74e9201-b200-4bc3-b475-a572ab0ad62b",
        "body" : "Done.\n",
        "createdAt" : "2012-03-24T16:03:14Z",
        "updatedAt" : "2012-03-24T22:50:20Z",
        "lastEditedBy" : "b74e9201-b200-4bc3-b475-a572ab0ad62b",
        "tags" : [
        ]
      }
    ],
    "commit" : "b2e08b52e4eedba54b7c19f6078ac6ed1e0393a7",
    "line" : null,
    "diffHunk" : "@@ -1,1 +672,676 @@        self.filler = filler # Empty characters between fields.\n\n        assert isinstance(colspecs, (tuple, list))\n        for colspec in colspecs:\n            assert isinstance(colspec, (tuple, list))"
  },
  {
    "id" : "072cfbb8-2e7c-4a72-850e-cd84b7efe9dc",
    "prId" : 952,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "472d26a6-7fef-4a45-a758-45725f1615e1",
        "parentId" : null,
        "authorId" : "c1e22f62-b6a4-49af-9e65-1ac7ae69e3bb",
        "body" : "I'm not wild on the use of `locals()` for these, it seems like unnecessary magic.  But maybe I'm being overly picky.\n",
        "createdAt" : "2012-03-24T21:19:37Z",
        "updatedAt" : "2012-03-24T22:50:20Z",
        "lastEditedBy" : "c1e22f62-b6a4-49af-9e65-1ac7ae69e3bb",
        "tags" : [
        ]
      },
      {
        "id" : "50e1e589-a825-432c-b193-b6e7667a59c0",
        "parentId" : "472d26a6-7fef-4a45-a758-45725f1615e1",
        "authorId" : "55206695-bb42-4d72-886f-f5370a77363e",
        "body" : "Well, the alternative here is to either write out `kw=kw` for each keyword argument or to have `**kwds` which makes the signature in IPython less attractive. Not sure what's the best solution-- using locals doesn't strike me as so bad\n",
        "createdAt" : "2012-03-24T21:41:35Z",
        "updatedAt" : "2012-03-24T22:50:20Z",
        "lastEditedBy" : "55206695-bb42-4d72-886f-f5370a77363e",
        "tags" : [
        ]
      },
      {
        "id" : "2da9b9ad-fd5f-453c-9567-39ce3d75c4c7",
        "parentId" : "472d26a6-7fef-4a45-a758-45725f1615e1",
        "authorId" : "b74e9201-b200-4bc3-b475-a572ab0ad62b",
        "body" : "Having to enumerate all the paramters is both error-prone, makes it difficult to extend the other functions, and it hides the differences between the calls to _read(). I wish there was a method to get just the args, but there isn't. \n",
        "createdAt" : "2012-03-24T22:04:31Z",
        "updatedAt" : "2012-03-24T22:50:20Z",
        "lastEditedBy" : "b74e9201-b200-4bc3-b475-a572ab0ad62b",
        "tags" : [
        ]
      },
      {
        "id" : "c1b5ddfd-e95c-4c44-a656-e851e4ec39a9",
        "parentId" : "472d26a6-7fef-4a45-a758-45725f1615e1",
        "authorId" : "c1e22f62-b6a4-49af-9e65-1ac7ae69e3bb",
        "body" : "Indeed. I think PEP 362 is aimed at this sort of thing - you'd use `**kwargs`, and construct a more meaningful function signature for introspection - but that's still a work in progress.\n",
        "createdAt" : "2012-03-24T22:45:30Z",
        "updatedAt" : "2012-03-24T22:50:20Z",
        "lastEditedBy" : "c1e22f62-b6a4-49af-9e65-1ac7ae69e3bb",
        "tags" : [
        ]
      },
      {
        "id" : "871b25ec-37e0-4371-b768-8e95fd29bf3b",
        "parentId" : "472d26a6-7fef-4a45-a758-45725f1615e1",
        "authorId" : "b74e9201-b200-4bc3-b475-a572ab0ad62b",
        "body" : "Ideally it would be like LISP and a :as variable could be assigned to the set of kwargs. But it's Python. Whatever. We'll eventually end up with LISP again.\n",
        "createdAt" : "2012-03-24T22:53:28Z",
        "updatedAt" : "2012-03-24T22:53:28Z",
        "lastEditedBy" : "b74e9201-b200-4bc3-b475-a572ab0ad62b",
        "tags" : [
        ]
      }
    ],
    "commit" : "b2e08b52e4eedba54b7c19f6078ac6ed1e0393a7",
    "line" : 104,
    "diffHunk" : "@@ -1,1 +149,153 @@             delimiter=None,\n             encoding=None):\n    kwds = locals()\n\n    # Alias sep -> delimiter."
  },
  {
    "id" : "6205e421-f862-42cc-9788-15cbc44fe4d4",
    "prId" : 2005,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8611afb5-1f94-4fcf-8ac4-be53205c7785",
        "parentId" : null,
        "authorId" : "55206695-bb42-4d72-886f-f5370a77363e",
        "body" : "This is the only slightly concerning thing I see as I don't know the impact should these unicode strings get passed to the relevant Cython parsing code (which expects byte strings currently)-- I guess that will just need to be fixed independently if it's a problem.\n",
        "createdAt" : "2012-10-10T15:13:15Z",
        "updatedAt" : "2012-10-11T20:48:01Z",
        "lastEditedBy" : "55206695-bb42-4d72-886f-f5370a77363e",
        "tags" : [
        ]
      },
      {
        "id" : "313849f2-192f-4ad5-8208-17dc1dd3819d",
        "parentId" : "8611afb5-1f94-4fcf-8ac4-be53205c7785",
        "authorId" : null,
        "body" : "[Cython docs](http://docs.cython.org/src/tutorial/strings.html) - you're right.\nbut if date_cols[0] is unicode with non-ascii codepoints then str() will blow up, \nso something needs to change.\n\nif you work with bytes. you are inevitably assuming an encoding, utf-8 most likely.\ncalling c should probably be considered an \"I/O point\" where encoding/decoding \ntakes place. of course that might hurt the performance benefits of using cython \nto begin with. but unless it's unconscionably terrible, I think that's the way to go.\n\nanother (not \"correct\") option is storing everything internally as utf-8, which can \nbe made consistent. but then you would get things like #1292 happening again,\nand I would guess Py3 support would become (even more) hellish.\n\nis the c_parser branch stable enough to look at from a unicode perspective?\n",
        "createdAt" : "2012-10-10T16:47:56Z",
        "updatedAt" : "2012-10-11T20:48:01Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "27f2e4dc-4dff-4414-9cfe-baaffc1d4ab7",
        "parentId" : "8611afb5-1f94-4fcf-8ac4-be53205c7785",
        "authorId" : null,
        "body" : "Cython docs - [Decoding bytes to text](http://docs.cython.org/src/tutorial/strings.html#decoding-bytes-to-text)\n\nThe initially presented way of passing and receiving C strings is sufficient if your code only deals with binary data in the strings. When we deal with encoded text, however, **it is best practice to decode the C byte strings to Python Unicode strings on reception, and to encode Python Unicode strings to C byte strings on the way out**.\n",
        "createdAt" : "2012-10-10T20:09:07Z",
        "updatedAt" : "2012-10-11T20:48:01Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "5fa2ae439f4e02e0d97ff05fbba16337685297f8",
    "line" : 19,
    "diffHunk" : "@@ -1,1 +1191,1195 @@    # stripped = [map(str.strip, x) for x in date_cols]\n    rs = np.array([' '.join([unicode(y) for y in x])\n                   for x in zip(*date_cols)], dtype=object)\n    return rs\n"
  },
  {
    "id" : "149dfbf0-b8fa-45c1-bbae-b802b7a784ac",
    "prId" : 7029,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "98ec909d-0924-48a1-8d6b-f1f186216f37",
        "parentId" : null,
        "authorId" : "5bae3054-6bb1-4934-9daf-b10d33ef28ab",
        "body" : "This duplicates the previous behavior of ignoring the columns returned by _clean_index_names, except now we are not ignoring the columns returned by _get_index_name which may contain index columns (see \"case 0\")\n",
        "createdAt" : "2014-05-03T20:09:50Z",
        "updatedAt" : "2014-05-06T17:30:26Z",
        "lastEditedBy" : "5bae3054-6bb1-4934-9daf-b10d33ef28ab",
        "tags" : [
        ]
      }
    ],
    "commit" : "8651a438d898f5e94b52f451e52039a721649acb",
    "line" : 26,
    "diffHunk" : "@@ -1,1 +1826,1830 @@        else:\n            # Case 2\n            (index_name, columns_,\n             self.index_col) = _clean_index_names(columns, self.index_col)\n"
  }
]
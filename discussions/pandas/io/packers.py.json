[
  {
    "id" : "78091a25-a1af-4f26-b869-49f71ba246c7",
    "prId" : 6745,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f1f2ff93-5f87-4ba9-a77f-25eaddd54167",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "In theory this would fail if duplicate items (prob not tested nor likely though)\n",
        "createdAt" : "2014-04-18T23:34:44Z",
        "updatedAt" : "2014-04-25T13:50:55Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "1da304a3-fb5c-4b86-88c9-886d96aa32e3",
        "parentId" : "f1f2ff93-5f87-4ba9-a77f-25eaddd54167",
        "authorId" : "413be534-cedb-4df7-abda-cde26db33acd",
        "body" : "There were several places like this, all of which were refactored to be functionally equivalent, whenever old code would fail, new code should fail too. I figured that fixing non-trivial duplicate columns issues is better done in separate PRs, this one is already huge.\n",
        "createdAt" : "2014-04-19T07:47:24Z",
        "updatedAt" : "2014-04-25T13:50:55Z",
        "lastEditedBy" : "413be534-cedb-4df7-abda-cde26db33acd",
        "tags" : [
        ]
      },
      {
        "id" : "3a4b192d-41af-4b96-9b09-80b72f326709",
        "parentId" : "f1f2ff93-5f87-4ba9-a77f-25eaddd54167",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "agreed\n",
        "createdAt" : "2014-04-19T08:22:27Z",
        "updatedAt" : "2014-04-25T13:50:55Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "f51235aef9bbb50632b569d9e0c104816e5e31a0",
    "line" : 21,
    "diffHunk" : "@@ -1,1 +486,490 @@            return make_block(values=values,\n                              klass=getattr(internals, b['klass']),\n                              placement=axes[0].get_indexer(b['items']))\n\n        blocks = [create_block(b) for b in obj['blocks']]"
  },
  {
    "id" : "18a83647-d8b7-4ae7-a0fe-f33b22f8c283",
    "prId" : 9783,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "21644c48-e3f2-4a80-a9f6-0737616093d4",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "hmm, no longer need to encode? (honestly I don't remember why I did that in the first place).\n",
        "createdAt" : "2015-04-02T20:44:03Z",
        "updatedAt" : "2015-04-02T20:44:03Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "9092ebcf-b762-4e60-bef9-ecc1eb6cfdf2",
        "parentId" : "21644c48-e3f2-4a80-a9f6-0737616093d4",
        "authorId" : "756724d5-7da1-49b1-b97c-5caab0c27186",
        "body" : "Actually, I moved the encode higher up to line 237.  For some reason, type(values) was unicode.  Both zlib.decompress and blosc.decompress do not take unicode and only accept encoded strings.\n",
        "createdAt" : "2015-04-03T01:37:41Z",
        "updatedAt" : "2015-04-03T01:37:41Z",
        "lastEditedBy" : "756724d5-7da1-49b1-b97c-5caab0c27186",
        "tags" : [
        ]
      }
    ],
    "commit" : "702be31ec71b2fe4ec40b72b9bc06804fd1a7373",
    "line" : 88,
    "diffHunk" : "@@ -1,1 +248,252 @@\n    # from a string\n    return np.fromstring(values, dtype=dtype)\n\n"
  },
  {
    "id" : "71925dae-8f0e-4ce3-9a10-665b6db11b7f",
    "prId" : 10527,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7805fac0-fa1d-41f9-89f1-a833c3fcf050",
        "parentId" : null,
        "authorId" : "e2c9166e-93f5-4095-86da-e3b563dcaa2b",
        "body" : "@jreback Is it better to add `locs` (like it is right now) so that new `msgpack` can be decoded in older versions, or replace `items` with `locs` in `encode()` so that the encoded `msgpack` is smaller?\n",
        "createdAt" : "2015-07-17T13:22:17Z",
        "updatedAt" : "2015-07-18T05:02:49Z",
        "lastEditedBy" : "e2c9166e-93f5-4095-86da-e3b563dcaa2b",
        "tags" : [
        ]
      },
      {
        "id" : "b617099a-a273-4251-a79a-7bf55c9891f4",
        "parentId" : "7805fac0-fa1d-41f9-89f1-a833c3fcf050",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "no, like you have it now is ok. for back-compat we can only add attributes (and can't change the meaning at all). So this is how I wanted it. The new code will decode using `.locs` as that avoids the duplicates problem, and can read the older msgpacks. This actually also is forward-compat in that a current version can be read by an older version (so this is the best case scenario). We don't have a tests for forward-compat, but you can manually verify (as would need the older code to run in the tests which is 'odd').\n",
        "createdAt" : "2015-07-17T13:33:22Z",
        "updatedAt" : "2015-07-18T05:02:49Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "d4ad028d-01a7-457c-8cba-833ff9cc8545",
        "parentId" : "7805fac0-fa1d-41f9-89f1-a833c3fcf050",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "ok, you were looking at size. Well that is a trivial addition to size (this is one array per block, almost negligble). All that said I think we should remove this in the future (e.g. remove the forward compat, e.g. just use `.items` and just use `.locs`). So pls create an issue and I'll it for the future to do this.\n",
        "createdAt" : "2015-07-17T13:35:10Z",
        "updatedAt" : "2015-07-18T05:02:49Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "ed775bc5dd6771c492bf0b3c918a768f60835cf9",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +358,362 @@                    'axes': data.axes,\n                    'blocks': [{'items': data.items.take(b.mgr_locs),\n                                'locs': b.mgr_locs.as_array,\n                                'values': convert(b.values),\n                                'shape': b.values.shape,"
  },
  {
    "id" : "512f1baa-dee1-48a4-9a35-f0851db6dba9",
    "prId" : 10686,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1435a622-f60e-417b-bf40-92e930b30ee3",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "why is `use_bin_type=1` here but 0 below?\n",
        "createdAt" : "2015-07-29T12:30:00Z",
        "updatedAt" : "2015-08-18T00:41:06Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "4804f53e-ffe0-44ff-82c5-4494745a322c",
        "parentId" : "1435a622-f60e-417b-bf40-92e930b30ee3",
        "authorId" : "e2c9166e-93f5-4095-86da-e3b563dcaa2b",
        "body" : "Good catch.  I will change the other one to 1.\n",
        "createdAt" : "2015-07-30T03:28:44Z",
        "updatedAt" : "2015-08-18T00:41:06Z",
        "lastEditedBy" : "e2c9166e-93f5-4095-86da-e3b563dcaa2b",
        "tags" : [
        ]
      },
      {
        "id" : "969a5bd7-798c-4766-b55e-0492da2b4d75",
        "parentId" : "1435a622-f60e-417b-bf40-92e930b30ee3",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "what do these new args mean anyhow?\n",
        "createdAt" : "2015-07-30T15:15:32Z",
        "updatedAt" : "2015-08-18T00:41:06Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "c055aeb1-ef5e-426f-8d79-7baa26dcf73e",
        "parentId" : "1435a622-f60e-417b-bf40-92e930b30ee3",
        "authorId" : "e2c9166e-93f5-4095-86da-e3b563dcaa2b",
        "body" : "`use_bin_type` is for a [new binary format](https://github.com/msgpack/msgpack/blob/master/spec.md#formats-bin); [str 8](https://github.com/msgpack/msgpack/blob/master/spec.md#formats-str) was introduced at the same time, so that arg enables both, though they needn't be linked.  I think it's good to differentiate binary and strings, since in python there is a distinction.  In PY2 you wouldn't be able to round-trip `str`--which is really bytes--using utf 16 or utf 32 encoding without that enabled.  `autoreset` is not new.  I don't know if the omission from `packers` was intentional or not.\n",
        "createdAt" : "2015-07-30T15:45:27Z",
        "updatedAt" : "2015-08-18T00:41:06Z",
        "lastEditedBy" : "e2c9166e-93f5-4095-86da-e3b563dcaa2b",
        "tags" : [
        ]
      }
    ],
    "commit" : "6c3da7f0dc67727590b9bdccd40a56e10fc58341",
    "line" : 61,
    "diffHunk" : "@@ -1,1 +566,570 @@def pack(o, default=encode,\n         encoding='latin1', unicode_errors='strict', use_single_float=False,\n         autoreset=1, use_bin_type=1):\n    \"\"\"\n    Pack an object and return the packed bytes."
  },
  {
    "id" : "96df2483-553f-4c83-87cb-244d5eeacba9",
    "prId" : 16523,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/16523#pullrequestreview-44447437",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b93b467f-efca-4593-a83a-7f5b3579dc43",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "you can simply check ``os.path.exists(path_or_buf)`` (see how this is done in ``pandas.io.json.json.read_json``",
        "createdAt" : "2017-05-29T16:18:21Z",
        "updatedAt" : "2017-10-28T09:14:21Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "c4912a34-2683-421e-869b-18dae209ff5a",
        "parentId" : "b93b467f-efca-4593-a83a-7f5b3579dc43",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "I saw your expl. But if ``os.path.exists(path_or_buf)`` fails then you know for sure its NOT a path. Then you can try to read. I agree you can't then distinguish between an invalid path and an invalid byte stream, but so what.",
        "createdAt" : "2017-06-14T23:15:28Z",
        "updatedAt" : "2017-10-28T09:14:21Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "cc827218-94ed-4b4e-b5d1-dc33fe3e0c66",
        "parentId" : "b93b467f-efca-4593-a83a-7f5b3579dc43",
        "authorId" : "2a12100c-c2cf-4277-bc86-d4c017b5fe95",
        "body" : "The benefit is when an incorrect path is accidentally used. As it stands the code can continue running with invalid data until it crashes mysteriously elsewhere or silently produces an incorrect result (the latter motivated me to make this PR).",
        "createdAt" : "2017-06-15T23:53:48Z",
        "updatedAt" : "2017-10-28T09:14:21Z",
        "lastEditedBy" : "2a12100c-c2cf-4277-bc86-d4c017b5fe95",
        "tags" : [
        ]
      }
    ],
    "commit" : "9d0f3b67228fc1c76f7a6c3a92a0d2a1692ce7be",
    "line" : 20,
    "diffHunk" : "@@ -1,1 +207,211 @@        try:\n            # We can't distinguish between a path and a buffer of bytes in\n            # Python 2 so instead assume the first byte of a valid path is\n            # less than 0x80.\n            if compat.PY3 or ord(path_or_buf[0]) >= 0x80:"
  },
  {
    "id" : "35231643-aab4-4fba-9e31-8f0df01a42a8",
    "prId" : 16523,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/16523#pullrequestreview-50886413",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ae918d5b-999a-458f-9c88-b46d6182f6c9",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "this would fail for a 0-len buffer. what does the ``0x80`` compare against? is this platform dependent?",
        "createdAt" : "2017-06-19T22:53:14Z",
        "updatedAt" : "2017-10-28T09:14:21Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "502e1a63-b39f-49aa-8f3a-c38922866e85",
        "parentId" : "ae918d5b-999a-458f-9c88-b46d6182f6c9",
        "authorId" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "body" : "These seems fragile. IIUC, it's possible to have filenames that, according to Python, start with characters above 0x80, even if the filesystem does some encoding on the filename before reading on writing.",
        "createdAt" : "2017-07-19T11:53:27Z",
        "updatedAt" : "2017-10-28T09:14:21Z",
        "lastEditedBy" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "tags" : [
        ]
      },
      {
        "id" : "65755c38-6859-4db2-b70d-a5cbbba9abfe",
        "parentId" : "ae918d5b-999a-458f-9c88-b46d6182f6c9",
        "authorId" : "2a12100c-c2cf-4277-bc86-d4c017b5fe95",
        "body" : "Unfortunately I don't see a way to make this avoid the edge cases like this for Python 2 with the current API. I think this way minimised the number of affected users and if it does affect someone the check can be bypassed using `./filename`.",
        "createdAt" : "2017-07-19T12:06:37Z",
        "updatedAt" : "2017-10-28T09:14:21Z",
        "lastEditedBy" : "2a12100c-c2cf-4277-bc86-d4c017b5fe95",
        "tags" : [
        ]
      },
      {
        "id" : "caa37102-3f0c-448b-be84-a474c79e9f13",
        "parentId" : "ae918d5b-999a-458f-9c88-b46d6182f6c9",
        "authorId" : "2a12100c-c2cf-4277-bc86-d4c017b5fe95",
        "body" : "> this would fail for a 0-len buffer. what does the 0x80 compare against? is this platform dependent?\r\n\r\nAccording to the [msgpack spec](https://github.com/msgpack/msgpack/blob/master/spec.md) \"Applications can assign 0 to 127 to store application-specific type information.\". I believe pandas doesn't currently use this so this assumes if the first byte is below `0x80` it was supposed to be a filename rather than a collection of bytes to decode.\r\n\r\nI'm not sure what the correct behaviour should be for passing `read_msgpack(\"\")`.",
        "createdAt" : "2017-07-19T12:13:45Z",
        "updatedAt" : "2017-10-28T09:14:21Z",
        "lastEditedBy" : "2a12100c-c2cf-4277-bc86-d4c017b5fe95",
        "tags" : [
        ]
      }
    ],
    "commit" : "9d0f3b67228fc1c76f7a6c3a92a0d2a1692ce7be",
    "line" : 22,
    "diffHunk" : "@@ -1,1 +209,213 @@            # Python 2 so instead assume the first byte of a valid path is\n            # less than 0x80.\n            if compat.PY3 or ord(path_or_buf[0]) >= 0x80:\n                fh = compat.BytesIO(path_or_buf)\n                return read(fh)"
  },
  {
    "id" : "85172235-8c29-499e-b2a4-ee077b8bb14c",
    "prId" : 17987,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/17987#pullrequestreview-72153105",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2a077470-958b-47b5-90c2-28d5d6e01ec1",
        "parentId" : null,
        "authorId" : "aa76ca2b-2c97-45f3-bb6a-3e0ee670395b",
        "body" : "I _think_ it's safe to not copy here, IIRC `values` is pile of bytes read from a msgpack file, so no risk in mutating?",
        "createdAt" : "2017-10-25T21:40:17Z",
        "updatedAt" : "2017-10-25T21:40:17Z",
        "lastEditedBy" : "aa76ca2b-2c97-45f3-bb6a-3e0ee670395b",
        "tags" : [
        ]
      },
      {
        "id" : "19c1746a-c33d-4e76-9232-9a97c0fa3557",
        "parentId" : "2a077470-958b-47b5-90c2-28d5d6e01ec1",
        "authorId" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "body" : "Without the copy the test failed:\r\n\r\n```\r\n        for buf, control_buf in zip(not_garbage, control):\r\n            # make sure none of our mutations above affected the\r\n            # original buffers\r\n>           assert buf == control_buf\r\nE           AssertionError: assert b'\\x00\\x00\\x0...x00\\x00@\\x8f@' == bytearray(b'\\x...00\\x008\\x8f@')\r\nE             At index 6 diff: 240 != 0\r\nE             Use -v to get the full diff\r\n\r\npandas/tests/io/test_packers.py:690: AssertionError\r\n```\r\n\r\nI didn't look closely to see if that's a legitimate problem or not.",
        "createdAt" : "2017-10-25T21:42:59Z",
        "updatedAt" : "2017-10-25T21:42:59Z",
        "lastEditedBy" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "tags" : [
        ]
      },
      {
        "id" : "2337ee33-749e-4403-8669-3b8875244365",
        "parentId" : "2a077470-958b-47b5-90c2-28d5d6e01ec1",
        "authorId" : "aa76ca2b-2c97-45f3-bb6a-3e0ee670395b",
        "body" : "Ah, in that case I would trust the test.",
        "createdAt" : "2017-10-25T22:15:36Z",
        "updatedAt" : "2017-10-25T22:15:36Z",
        "lastEditedBy" : "aa76ca2b-2c97-45f3-bb6a-3e0ee670395b",
        "tags" : [
        ]
      },
      {
        "id" : "388f927c-f2c8-4c84-97fc-f815957f8143",
        "parentId" : "2a077470-958b-47b5-90c2-28d5d6e01ec1",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "you need to do this conditionally for numpy > 1.13 I think\r\n",
        "createdAt" : "2017-10-25T22:18:55Z",
        "updatedAt" : "2017-10-25T22:18:56Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "1b7579e8-d482-45f5-ad2d-b4a953209a93",
        "parentId" : "2a077470-958b-47b5-90c2-28d5d6e01ec1",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "cc @llllllllll ",
        "createdAt" : "2017-10-25T22:19:04Z",
        "updatedAt" : "2017-10-25T22:19:04Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "c3f05cec-b7dd-4631-a78a-bdde8a0e17cf",
        "parentId" : "2a077470-958b-47b5-90c2-28d5d6e01ec1",
        "authorId" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "body" : "The tests on the older NumPy passed, let me make sure zlib is installed and that they weren't skipped.",
        "createdAt" : "2017-10-26T10:55:15Z",
        "updatedAt" : "2017-10-26T10:55:15Z",
        "lastEditedBy" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "tags" : [
        ]
      },
      {
        "id" : "29c0e69b-ffcb-4040-9a63-9beb8ca62893",
        "parentId" : "2a077470-958b-47b5-90c2-28d5d6e01ec1",
        "authorId" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "body" : "Pretty sure that https://travis-ci.org/pandas-dev/pandas/jobs/292845756 hit it, so I think we're OK.",
        "createdAt" : "2017-10-26T11:02:27Z",
        "updatedAt" : "2017-10-26T11:02:28Z",
        "lastEditedBy" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "tags" : [
        ]
      }
    ],
    "commit" : "cb0101b8a8733900cae63e279c20286d73cdb440",
    "line" : 8,
    "diffHunk" : "@@ -1,1 +353,357 @@    # Copy the bytes into a numpy array.\n    buf = np.frombuffer(values, dtype=dtype)\n    buf = buf.copy()  # required to not mutate the original data\n    buf.flags.writeable = True\n    return buf"
  },
  {
    "id" : "6245f077-4166-41c0-aa1a-2206cfee2d45",
    "prId" : 20611,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/20611#pullrequestreview-135671961",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3d5c4cd8-d134-464f-a23a-a04457ff6e8f",
        "parentId" : null,
        "authorId" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "body" : "Should talk about this more generally in https://github.com/pandas-dev/pandas/issues/20612",
        "createdAt" : "2018-04-04T16:55:13Z",
        "updatedAt" : "2018-07-13T01:00:53Z",
        "lastEditedBy" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "tags" : [
        ]
      },
      {
        "id" : "80e71c30-07bd-4186-ae93-2b832ed2f8ec",
        "parentId" : "3d5c4cd8-d134-464f-a23a-a04457ff6e8f",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "this is very very tricky from a back-compat perspective.",
        "createdAt" : "2018-04-05T15:53:42Z",
        "updatedAt" : "2018-07-13T01:00:53Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "580a85a5-d69b-4a15-8ea3-ef0fe534eb94",
        "parentId" : "3d5c4cd8-d134-464f-a23a-a04457ff6e8f",
        "authorId" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "body" : "Mmm, that doesn't sound fun. I'll see what I can do to avoid that.",
        "createdAt" : "2018-04-05T20:29:54Z",
        "updatedAt" : "2018-07-13T01:00:53Z",
        "lastEditedBy" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "tags" : [
        ]
      },
      {
        "id" : "c558a32a-3973-41c1-b18d-cc903802d83f",
        "parentId" : "3d5c4cd8-d134-464f-a23a-a04457ff6e8f",
        "authorId" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "body" : "I wonder, should this be reverted? Do any msgpack tests fail if it is?",
        "createdAt" : "2018-07-10T03:00:18Z",
        "updatedAt" : "2018-07-13T01:00:54Z",
        "lastEditedBy" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "tags" : [
        ]
      },
      {
        "id" : "34887a5c-0fef-4306-8f51-2cfe223403dd",
        "parentId" : "3d5c4cd8-d134-464f-a23a-a04457ff6e8f",
        "authorId" : "7545b4d7-157f-47c4-b7f8-18bf358d429c",
        "body" : "The test below fails on the last copied line for `Interval` data if reverted:\r\n\r\nhttps://github.com/pandas-dev/pandas/blob/da6e26db079cd4050c1693939db6a52afb2978e1/pandas/tests/io/test_packers.py#L357-L360",
        "createdAt" : "2018-07-10T04:39:39Z",
        "updatedAt" : "2018-07-13T01:00:54Z",
        "lastEditedBy" : "7545b4d7-157f-47c4-b7f8-18bf358d429c",
        "tags" : [
        ]
      }
    ],
    "commit" : "385ce59f79ff1921a44f3bbaa17044032e3ed4d3",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +404,408 @@                    u'tz': tz,\n                    u'compress': compressor}\n        elif isinstance(obj, (IntervalIndex, IntervalArray)):\n            if isinstance(obj, IntervalIndex):\n                typ = u'interval_index'"
  },
  {
    "id" : "a5516a7a-90a8-43dd-9566-e6452222ac0d",
    "prId" : 23796,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/23796#pullrequestreview-176519062",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "369a1ce0-078e-46ed-a2ef-3637908c8c38",
        "parentId" : null,
        "authorId" : "5f34c5f9-b309-4032-bd6e-1f14b864aae4",
        "body" : "This is not just numpy compat (hence the removed comment) - including `'complex256': np.float128` into `c2f_dict` does not work on my windows machine, for example",
        "createdAt" : "2018-11-19T21:37:21Z",
        "updatedAt" : "2018-11-25T13:01:37Z",
        "lastEditedBy" : "5f34c5f9-b309-4032-bd6e-1f14b864aae4",
        "tags" : [
        ]
      },
      {
        "id" : "8d70b3e2-c84a-4df2-82f5-a16db847b3d7",
        "parentId" : "369a1ce0-078e-46ed-a2ef-3637908c8c38",
        "authorId" : "adf621f1-4745-479a-a1fc-dc14046a3f4b",
        "body" : "maybe a comment to that effect?  \"windows compat\"or \"windows 32 bit compat\" or \"[whatever would be accurate] compat\"?",
        "createdAt" : "2018-11-19T21:53:17Z",
        "updatedAt" : "2018-11-25T13:01:37Z",
        "lastEditedBy" : "adf621f1-4745-479a-a1fc-dc14046a3f4b",
        "tags" : [
        ]
      },
      {
        "id" : "19b31739-25b2-4a7b-81a0-d7a8ad644b72",
        "parentId" : "369a1ce0-078e-46ed-a2ef-3637908c8c38",
        "authorId" : "5f34c5f9-b309-4032-bd6e-1f14b864aae4",
        "body" : "ok",
        "createdAt" : "2018-11-19T22:05:31Z",
        "updatedAt" : "2018-11-25T13:01:37Z",
        "lastEditedBy" : "5f34c5f9-b309-4032-bd6e-1f14b864aae4",
        "tags" : [
        ]
      }
    ],
    "commit" : "ce5bd94125310571c6ca9cfa3ab4aed31b49dcde",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +253,257 @@# windows (32 bit) compat\nif hasattr(np, 'float128'):\n    c2f_dict['complex256'] = np.float128\n\n"
  }
]
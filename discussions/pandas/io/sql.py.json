[
  {
    "id" : "1d4917cf-fd3c-4a86-8278-337e4e2c5ec0",
    "prId" : 6902,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b3dbb8b6-34a5-4390-bb00-1f799193e292",
        "parentId" : null,
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "A space after `changed.` is missing\n",
        "createdAt" : "2014-04-17T14:29:46Z",
        "updatedAt" : "2014-04-22T13:41:07Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      }
    ],
    "commit" : "09f377e367a0f0f1d4cf1934e4efad761c4b9a60",
    "line" : 38,
    "diffHunk" : "@@ -1,1 +833,837 @@\n\n_SAFE_NAMES_WARNING = (\"The spaces in these column names will not be changed.\"\n                       \"In pandas versions < 0.14, spaces were converted to \"\n                       \"underscores.\")"
  },
  {
    "id" : "4d32f9c9-9239-4ea5-adf6-f6602c076dae",
    "prId" : 6987,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ea558b56-fecc-4d5b-b847-f1f26f83a51b",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "shouldn't this raise? (and not print)\n",
        "createdAt" : "2014-05-05T11:43:28Z",
        "updatedAt" : "2014-05-08T12:03:20Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "2544bb30-7dc1-4e4f-bcfd-8c8298a99651",
        "parentId" : "ea558b56-fecc-4d5b-b847-f1f26f83a51b",
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "It should not raise I think, as it has to be able to 'retry' a couple of lines lower.\n\nNow I don't fully grasp this code, I just copied it from 0.13.1 version to retain backwards compatibility (Wes put this in 2 years ago), so I thought: no real need to clean this up, as we will remove it anyway after a deprecation cycle.\n",
        "createdAt" : "2014-05-05T12:00:54Z",
        "updatedAt" : "2014-05-08T12:03:20Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      },
      {
        "id" : "e2591720-7ca9-43e1-957c-04804c5cd361",
        "parentId" : "ea558b56-fecc-4d5b-b847-f1f26f83a51b",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "ok....that's fine...just checking, prob right not to touch it!\n",
        "createdAt" : "2014-05-05T12:01:33Z",
        "updatedAt" : "2014-05-08T12:03:20Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "ba86e3fa-e79b-4b25-b8fa-3c7183ca89c1",
        "parentId" : "ea558b56-fecc-4d5b-b847-f1f26f83a51b",
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "But I can make a warning of it instead of a print statement\n",
        "createdAt" : "2014-05-05T12:01:49Z",
        "updatedAt" : "2014-05-08T12:03:20Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      }
    ],
    "commit" : "ff95ac33c8a551ac0f20eb15c0fcac7288b53392",
    "line" : 90,
    "diffHunk" : "@@ -1,1 +159,163 @@            excName = e.__class__.__name__\n            if excName == 'OperationalError': # pragma: no cover\n                print('Failed to commit, may need to restart interpreter')\n            else:\n                raise"
  },
  {
    "id" : "342defd0-2430-4cd2-bdab-25cec0138dc1",
    "prId" : 6987,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e90e6a04-f4bf-409a-b1ae-949b813c33b1",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "maybe a warning instead of printing (I know it used to do this)...but\n",
        "createdAt" : "2014-05-05T11:43:55Z",
        "updatedAt" : "2014-05-08T12:03:20Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "ff95ac33c8a551ac0f20eb15c0fcac7288b53392",
    "line" : 162,
    "diffHunk" : "@@ -1,1 +216,220 @@        traceback.print_exc()\n        if retry:\n            print('Looks like your connection failed, reconnecting...')\n            return uquery(sql, con, retry=False)\n    return result"
  },
  {
    "id" : "d76df100-3753-48d2-88a6-a4c5c8b87131",
    "prId" : 8062,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fe1d2ace-cc3d-4c97-920c-da24ef49d657",
        "parentId" : null,
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "Do you know if there is a difference between (what you did now):\n\n```\ncon = self.pd_sql.engine.connect()\nwith con.begin() as trans:\n    for i in range(chunks):\n        ...\n        con.execute(ins, data_list)\n```\n\nand \n\n```\nwith self.pd_sql.engine.begin() as con:\n    for i in range(chunks):\n        ...\n        con.execute(ins, data_list)\n```\n\nWhere the latter is a bit simpler (as we don't directly need to use the `trans` object). Doing the executes in one transaction should make this atomic? \nBut from http://docs.sqlalchemy.org/en/rel_0_9/core/connections.html#using-transactions I would understand that both should be equivalent?\n",
        "createdAt" : "2014-08-21T19:12:23Z",
        "updatedAt" : "2014-08-21T21:42:29Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      },
      {
        "id" : "1f2500b8-2d9c-45a4-b400-c0f604436481",
        "parentId" : "fe1d2ace-cc3d-4c97-920c-da24ef49d657",
        "authorId" : "002fe2e0-eafa-49d2-9208-6fd30f14d6b0",
        "body" : "I agree the later is better but it is not supported by sqlalchemy 0.7 (nor 0.7.4) --- I get a`AttributeError: 'Engine' object has no attribute 'begin'` error.  On 0.8 it works.  Let me know if its better to change the version requirements or leave the code as it.\n",
        "createdAt" : "2014-08-21T21:14:44Z",
        "updatedAt" : "2014-08-21T21:42:29Z",
        "lastEditedBy" : "002fe2e0-eafa-49d2-9208-6fd30f14d6b0",
        "tags" : [
        ]
      },
      {
        "id" : "fedc8180-33ed-4fce-82fa-f1f13025dcde",
        "parentId" : "fe1d2ace-cc3d-4c97-920c-da24ef49d657",
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "OK, then we can just leave it like this (it's only one line longer, and for the rest equivalent). If we raise the required version, we can always clean it up\n",
        "createdAt" : "2014-08-21T21:33:51Z",
        "updatedAt" : "2014-08-21T21:42:29Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      }
    ],
    "commit" : "3c43c95e8d8faefb110bc06aba733e342dc02c31",
    "line" : 63,
    "diffHunk" : "@@ -1,1 +624,628 @@                                for k, v in zip(keys, t[1:]))\n                    data_list.append(data)\n                con.execute(ins, data_list)\n\n    def read(self, coerce_float=True, parse_dates=None, columns=None):"
  },
  {
    "id" : "e0d7e09a-b472-44ac-90ca-6d55101a79a2",
    "prId" : 8090,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fc2a4ea8-fd57-4d0d-ad43-8cfbe0108701",
        "parentId" : null,
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "@jreback The `com.is_..._dtype(arr_or_dtype)` functions, they are also meant to work with a Series? (despite the argument name).\n",
        "createdAt" : "2014-08-22T12:55:45Z",
        "updatedAt" : "2014-08-22T12:55:45Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      },
      {
        "id" : "32b669c5-766a-47cd-a683-4956ce8cf03c",
        "parentId" : "fc2a4ea8-fd57-4d0d-ad43-8cfbe0108701",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "yep, you _may_ need however to use `lib.infer_dtype` here (returns a string-like describe what the actual data is, beware though it often has to scan all the data, but will fastpath if its already has a dtype, this is really for an `object` dtype, that say holds `datetime.date`)\n",
        "createdAt" : "2014-08-22T12:59:25Z",
        "updatedAt" : "2014-08-22T12:59:25Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "33845645-873c-44ca-a4bc-8c6e9b0a0a55",
        "parentId" : "fc2a4ea8-fd57-4d0d-ad43-8cfbe0108701",
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "yes, I used it a couple of lines lower specificly for `datetime.date` and `datetime.time`\n",
        "createdAt" : "2014-08-22T13:02:51Z",
        "updatedAt" : "2014-08-22T13:02:51Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      },
      {
        "id" : "36c16d4e-4fd9-499a-a015-6d0e168afacb",
        "parentId" : "fc2a4ea8-fd57-4d0d-ad43-8cfbe0108701",
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "That is the reason I changed the function from passing the `dtype` to passing the column (series), because I needed also the values of the column for `infer_dtype`\n",
        "createdAt" : "2014-08-22T13:03:41Z",
        "updatedAt" : "2014-08-22T13:03:41Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      },
      {
        "id" : "0ea98ad1-f92f-46d7-ba35-6456b42e27c6",
        "parentId" : "fc2a4ea8-fd57-4d0d-ad43-8cfbe0108701",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "yep you can certainly test for the datetime64 first . not sure exactly what you need. take a look at `core/index.py/Index.__new__`, which goes thru a bunch of steps to figure out what is what. You  have an advantage, you already know its a Series, and already have it coerced (if its possible), so for example if it is `datetime64[ns]` you are done. (as you are already doing).\n",
        "createdAt" : "2014-08-22T13:06:29Z",
        "updatedAt" : "2014-08-22T13:06:29Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "a0cedf80359bd200b705763e59661abd82936dcc",
    "line" : 41,
    "diffHunk" : "@@ -1,1 +763,767 @@            DateTime, Date, Time, Interval)\n\n        if com.is_datetime64_dtype(col):\n            try:\n                tz = col.tzinfo"
  },
  {
    "id" : "4c3409f5-eabd-4338-aad1-c11a44dafe48",
    "prId" : 8208,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "96becce5-04d4-4e64-ac72-d6f9cdb1c436",
        "parentId" : null,
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "@jreback making a copy to reset the index to be able to also insert the index in the SQL table seems a bit stupid. \nIt seems more logical if I could add these seperately to the `data_list`. Eg I could do something like:\n\n```\nif self.index:\n    b_index = self.frame.index.to_series()._data.blocks[0]\n    blocks = b_index + blocks\n```\n\n(and then of course taking possibly different levels into account, but you get the idea)\n\nBut is there a better way to get the index values into a block? (what is needed to have the datetime and nan handling, as these both can also occur in the index)\n",
        "createdAt" : "2014-09-12T12:58:36Z",
        "updatedAt" : "2014-09-13T21:09:07Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      },
      {
        "id" : "53f846b4-d016-4eb3-a6c9-6d53655c230f",
        "parentId" : "96becce5-04d4-4e64-ac72-d6f9cdb1c436",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "I don't think making a copy is a big deal its quite cheap to do it. (and much more time doing the conversions to tuples anyhow) You can make only reset if the `self.index` is True I guess. Too complicated otherwise.\n",
        "createdAt" : "2014-09-12T13:14:11Z",
        "updatedAt" : "2014-09-13T21:09:07Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "6bbd9803-da7f-4c08-9ffb-046098370e78",
        "parentId" : "96becce5-04d4-4e64-ac72-d6f9cdb1c436",
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "yes, that is what happens now, only if `index=True`\n",
        "createdAt" : "2014-09-12T13:55:02Z",
        "updatedAt" : "2014-09-13T21:09:07Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      }
    ],
    "commit" : "638fb5b3e4199dfdb9a89c6e535300f55446c8fb",
    "line" : 20,
    "diffHunk" : "@@ -1,1 +602,606 @@    def insert_data(self):\n        if self.index is not None:\n            temp = self.frame.copy()\n            temp.index.names = self.index\n            try:"
  },
  {
    "id" : "769fab68-3e6d-4c1c-9ac2-a2a4fc0b49c2",
    "prId" : 8232,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "aedbb695-47b1-49d9-b52c-70c6ef33d5e8",
        "parentId" : null,
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "for what is this needed? The meta object is already constructed in PandasSQLEngine (or passed by the user) and should not be recreated here.\n",
        "createdAt" : "2014-09-12T13:57:54Z",
        "updatedAt" : "2014-09-15T08:33:08Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      },
      {
        "id" : "5f76847e-75b0-48ce-b1af-946e241d7704",
        "parentId" : "aedbb695-47b1-49d9-b52c-70c6ef33d5e8",
        "authorId" : "002fe2e0-eafa-49d2-9208-6fd30f14d6b0",
        "body" : "See my comments above. I create a blank `MetaData` object to avoid conflicts with the table already existing in `self.pd_sql.meta`.  Only when `create()` is called to I move it over to `self.pd_sql.meta`.\n",
        "createdAt" : "2014-09-12T19:33:35Z",
        "updatedAt" : "2014-09-15T08:33:08Z",
        "lastEditedBy" : "002fe2e0-eafa-49d2-9208-6fd30f14d6b0",
        "tags" : [
        ]
      }
    ],
    "commit" : "5065232e16b88558a891d72e35796a6f60ba6264",
    "line" : 131,
    "diffHunk" : "@@ -1,1 +754,758 @@        # once table is created.\n        from sqlalchemy.schema import MetaData\n        meta = MetaData(self.pd_sql, schema=schema)\n\n        return Table(self.name, meta, *columns, schema=schema)"
  },
  {
    "id" : "546371a8-2381-4761-9261-c89e76da7f6f",
    "prId" : 8232,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "277dc18d-08c0-405e-b43a-a14b21f5bbd7",
        "parentId" : null,
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "I know in the fallback version of `get_schema` you could specify keys, and I think this functionality is useful, but I don't yet know what would be the best interface for that \n",
        "createdAt" : "2014-09-12T14:18:31Z",
        "updatedAt" : "2014-09-15T08:33:08Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      },
      {
        "id" : "a57001a0-7ec8-44d6-87b3-e58e775cd6a6",
        "parentId" : "277dc18d-08c0-405e-b43a-a14b21f5bbd7",
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "Can you maybe pass this `keys` kwarg directly to the `_create_table_setup` method? Then we can more easily change it later if we figured out how to handle this.\n",
        "createdAt" : "2014-09-13T11:40:11Z",
        "updatedAt" : "2014-09-15T08:33:08Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      },
      {
        "id" : "c7b152f8-2dd9-4b32-92ff-8dfe6b3829e1",
        "parentId" : "277dc18d-08c0-405e-b43a-a14b21f5bbd7",
        "authorId" : "002fe2e0-eafa-49d2-9208-6fd30f14d6b0",
        "body" : "I can definitely do that but I'm not sure what the advantage would be.  Since `_create_table_setup` is getting called by the constructor, that constructor will still have a `keys` kwarg, right?\n",
        "createdAt" : "2014-09-14T00:59:03Z",
        "updatedAt" : "2014-09-15T08:33:08Z",
        "lastEditedBy" : "002fe2e0-eafa-49d2-9208-6fd30f14d6b0",
        "tags" : [
        ]
      },
      {
        "id" : "fa276be1-82ee-4d1b-82a5-0abb68b82d7d",
        "parentId" : "277dc18d-08c0-405e-b43a-a14b21f5bbd7",
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "Ah, no, I thought you were calling `_create_table_setup` directly, but this is used in the Table constructor. OK, then leave it.\n",
        "createdAt" : "2014-09-14T10:34:59Z",
        "updatedAt" : "2014-09-15T08:33:08Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      }
    ],
    "commit" : "5065232e16b88558a891d72e35796a6f60ba6264",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +553,557 @@    def __init__(self, name, pandas_sql_engine, frame=None, index=True,\n                 if_exists='fail', prefix='pandas', index_label=None,\n                 schema=None, keys=None):\n        self.name = name\n        self.pd_sql = pandas_sql_engine"
  },
  {
    "id" : "593dc7dc-5c81-4574-adff-63775f9ff6a2",
    "prId" : 8232,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ef98366e-dd15-4107-b3de-0204268bc642",
        "parentId" : null,
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "you can also return the connection in `get_session` with `engine.begin()`, then you don't need to get back the connection from trans (see http://docs.sqlalchemy.org/en/rel_0_9/core/connections.html#using-transactions)\n",
        "createdAt" : "2014-09-15T06:56:56Z",
        "updatedAt" : "2014-09-15T08:33:08Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      },
      {
        "id" : "fed40671-a4a0-4ca3-8d56-480c8c1ad335",
        "parentId" : "ef98366e-dd15-4107-b3de-0204268bc642",
        "authorId" : "002fe2e0-eafa-49d2-9208-6fd30f14d6b0",
        "body" : "I would still need to pass in the transaction for the legacy `_execute_insert`.  What is the advantage of not getting connection from `trans`?\n",
        "createdAt" : "2014-09-15T08:30:53Z",
        "updatedAt" : "2014-09-15T08:33:08Z",
        "lastEditedBy" : "002fe2e0-eafa-49d2-9208-6fd30f14d6b0",
        "tags" : [
        ]
      },
      {
        "id" : "77248538-2d10-436a-8b98-5a2c49a9bb67",
        "parentId" : "ef98366e-dd15-4107-b3de-0204268bc642",
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "I don't know if there is an advantage, apart from shorter code while being equivalent. But you are using a connection with the legacy `get_session` and `_execute_insert`, no?\n",
        "createdAt" : "2014-09-15T08:44:05Z",
        "updatedAt" : "2014-09-15T08:44:05Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      },
      {
        "id" : "cddbe39d-afe1-4f7f-b82b-b42d1ae9006b",
        "parentId" : "ef98366e-dd15-4107-b3de-0204268bc642",
        "authorId" : "002fe2e0-eafa-49d2-9208-6fd30f14d6b0",
        "body" : "Legacy `_execute_insert` uses `trans`, not the connection.\n",
        "createdAt" : "2014-09-15T20:37:03Z",
        "updatedAt" : "2014-09-15T20:37:03Z",
        "lastEditedBy" : "002fe2e0-eafa-49d2-9208-6fd30f14d6b0",
        "tags" : [
        ]
      },
      {
        "id" : "f63b1028-8c6f-4ae5-9cc4-2025c72fd9d0",
        "parentId" : "ef98366e-dd15-4107-b3de-0204268bc642",
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "you call it `trans` (and it is 'to run a transaction'), but the actual object you pass is a connection (in case of sqlite) or a cursor (in case of pymysql/MySQLdb)\n",
        "createdAt" : "2014-09-15T20:43:46Z",
        "updatedAt" : "2014-09-15T20:43:46Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      }
    ],
    "commit" : "5065232e16b88558a891d72e35796a6f60ba6264",
    "line" : 79,
    "diffHunk" : "@@ -1,1 +644,648 @@    def _execute_insert(self, trans, keys, data_iter):\n        data = [dict( (k, v) for k, v in zip(keys, row) ) for row in data_iter]\n        trans.connection.execute(self.insert_statement(), data)\n\n    def insert(self, chunksize=None):"
  },
  {
    "id" : "1d123c6b-7158-4391-a62d-433bb1455468",
    "prId" : 8232,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bbb98a0f-1b22-4420-a767-dcb6b0a7b757",
        "parentId" : null,
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "I think this can also be an iterator, see https://docs.python.org/2/library/sqlite3.html#sqlite3.Cursor.executemany, so the `list(..)` is not needed\n",
        "createdAt" : "2014-09-15T07:01:40Z",
        "updatedAt" : "2014-09-15T08:33:08Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      },
      {
        "id" : "ee11b283-681e-415f-87db-76e541225be0",
        "parentId" : "bbb98a0f-1b22-4420-a767-dcb6b0a7b757",
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "But that is only for sqlite of course, and for now we also have to support the mysql drivers, thus ignore my comment.\n",
        "createdAt" : "2014-09-15T07:02:51Z",
        "updatedAt" : "2014-09-15T08:33:08Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      }
    ],
    "commit" : "5065232e16b88558a891d72e35796a6f60ba6264",
    "line" : 206,
    "diffHunk" : "@@ -1,1 +1044,1048 @@    def _execute_insert(self, trans, keys, data_iter):\n        data_list = list(data_iter)\n        trans.executemany(self.insert_statement(), data_list)\n\n    def _create_table_setup(self):"
  },
  {
    "id" : "691945e9-2b85-4f1e-acff-43bdc983dcbc",
    "prId" : 8330,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "55a5b5d9-96a9-4885-8694-941d26947c38",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "is their a reason this is a static_method? can u share this code with the other usage of this?\n",
        "createdAt" : "2014-10-01T13:01:52Z",
        "updatedAt" : "2014-10-06T23:17:48Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "4d4f4bfd-e7d6-4811-a0cf-ed3937118510",
        "parentId" : "55a5b5d9-96a9-4885-8694-941d26947c38",
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "the reason is that it didn't use `self`, so I made it explicitely static. Problem is that the version _is_ different for the two classes, so that's why I put it in the class instead of just a general helper function like `_wrap_result`\n",
        "createdAt" : "2014-10-01T13:04:30Z",
        "updatedAt" : "2014-10-06T23:17:48Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      },
      {
        "id" : "1081a32a-a069-453a-836e-b8d9a728b56e",
        "parentId" : "55a5b5d9-96a9-4885-8694-941d26947c38",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "maybe make it a module level function then? (and _wrap results as well); or an use a TableIterator class and make these methods (see Pytables.py and read_csv does this too)\n",
        "createdAt" : "2014-10-01T13:06:34Z",
        "updatedAt" : "2014-10-06T23:17:48Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "f044fda1-1057-42d4-bb3d-4ad8bf87d4d9",
        "parentId" : "55a5b5d9-96a9-4885-8694-941d26947c38",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "https://github.com/pydata/pandas/blob/master/pandas/io/pytables.py#L1291\n",
        "createdAt" : "2014-10-01T13:08:17Z",
        "updatedAt" : "2014-10-06T23:17:48Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "4be181eb-7ace-4a51-8aa5-5fae08aafd4f",
        "parentId" : "55a5b5d9-96a9-4885-8694-941d26947c38",
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "`_wrap_results` is already a module level function (if I understand correctly what you mean)\n\nProblem with making it a module level function, is that I would have to make two versions of the function (see the two `_query_iterator` methods now), one for each class that uses it (PandasSQLALchemy and PandasSQLLegacy). So for that it seemed more logical to put it in the class itself. \n\nOn implementing an Iterator class, I had seen the implementation in pytables, but it seemed a lot more complex than what I needed here. The simple `_query_iterator` functions seems to do all I need. Is there an advantage in making it a class?\n",
        "createdAt" : "2014-10-01T13:16:40Z",
        "updatedAt" : "2014-10-06T23:17:48Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      },
      {
        "id" : "ab87cf36-874d-4529-b9bb-5e0b7ad5c80f",
        "parentId" : "55a5b5d9-96a9-4885-8694-941d26947c38",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "I think your class would be simpler (and u could inherit methods)\nand bundle wrap_results - really just preference - up 2 u\n",
        "createdAt" : "2014-10-01T13:23:04Z",
        "updatedAt" : "2014-10-06T23:17:48Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "8bbe08a6-2fca-487a-8a4b-aeae8394ad03",
        "parentId" : "55a5b5d9-96a9-4885-8694-941d26947c38",
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "OK, I am going to leave it now as is, can always later look at implementing it as a class, but like to get this in\n",
        "createdAt" : "2014-10-06T21:07:17Z",
        "updatedAt" : "2014-10-06T23:17:48Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      }
    ],
    "commit" : "feb5d4c7e91755016842b40f4bcc5d6f0241c614",
    "line" : 322,
    "diffHunk" : "@@ -1,1 +1384,1388 @@    @staticmethod\n    def _query_iterator(cursor, chunksize, columns, index_col=None,\n                        coerce_float=True, parse_dates=None):\n        \"\"\"Return generator through chunked result set\"\"\"\n"
  },
  {
    "id" : "18f402f9-43b2-4819-9c59-570e595663af",
    "prId" : 9041,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "24936cec-4f77-42bc-be3e-a84d76359282",
        "parentId" : null,
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "Certainly fine to add this! But can you also add a test for it? (just a test for the API usage, so it won't get removed accidentally, so it can go in `TestSQLApi` (no need to test it for each flavor separately)\n",
        "createdAt" : "2014-12-23T10:14:00Z",
        "updatedAt" : "2015-01-24T18:51:50Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      }
    ],
    "commit" : "bb0c2e8da22ecb63036ddd3407569468716e9b1a",
    "line" : 82,
    "diffHunk" : "@@ -1,1 +1541,1545 @@\n\ndef get_schema(frame, name, flavor='sqlite', keys=None, con=None, dtype=None):\n    \"\"\"\n    Get the SQL db table schema for the given frame."
  },
  {
    "id" : "a15a890a-a6ec-41c6-8dbb-764e72a9305a",
    "prId" : 19664,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/19664#pullrequestreview-99935001",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2d9dba68-3bbe-4138-adce-56f6297a6ffd",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "can you add a doc-string here",
        "createdAt" : "2018-02-18T17:58:35Z",
        "updatedAt" : "2018-03-07T21:54:32Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "a0ade5b4-4154-4ceb-8b75-68a48f4774c8",
        "parentId" : "2d9dba68-3bbe-4138-adce-56f6297a6ffd",
        "authorId" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "body" : "Could you add a parameters and returns section as well. http://numpydoc.readthedocs.io/en/latest/format.html",
        "createdAt" : "2018-02-28T03:33:48Z",
        "updatedAt" : "2018-03-07T21:54:32Z",
        "lastEditedBy" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "tags" : [
        ]
      }
    ],
    "commit" : "f298de101762a97e2f3f856679e58f8b9c392942",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +573,577 @@            self._execute_create()\n\n    def insert_statement(self, data, conn):\n        \"\"\"\n        Generate tuple of SQLAlchemy insert statement and any arguments"
  },
  {
    "id" : "4dc6781c-989f-4a3c-b30c-0e6eb9541801",
    "prId" : 20004,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/20004#pullrequestreview-101947235",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "95573be8-0999-4ad3-9e83-ec04d348e55e",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "@jorisvandenbossche is this right? should we deprecate / rename this parameter?",
        "createdAt" : "2018-03-07T14:05:44Z",
        "updatedAt" : "2018-03-07T14:05:48Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "a8b00623-a53e-43f5-944b-47f64fb47df6",
        "parentId" : "95573be8-0999-4ad3-9e83-ec04d348e55e",
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "yes, this seems right, as a few lines below it does:\r\n\r\n```\r\n    if isinstance(frame, Series):\r\n        frame = frame.to_frame()\r\n```\r\n\r\nbut since this is mostly an internal method (most people will directly use DataFrame/Series.to_sql), I don't think we should bother with deprecating or renaming it",
        "createdAt" : "2018-03-07T14:30:12Z",
        "updatedAt" : "2018-03-07T14:30:12Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      }
    ],
    "commit" : "0215116e5dfa8b83c01d0fe7944575c32965933c",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +405,409 @@    Parameters\n    ----------\n    frame : DataFrame, Series\n    name : string\n        Name of SQL table."
  },
  {
    "id" : "e83bc965-54d0-46d2-bf7c-c9b59aac7910",
    "prId" : 21401,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/21401#pullrequestreview-188195913",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "28292900-ec4b-454f-8502-f2511c446db4",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "seems to be lots of repetitive doc-strings here, can think about this for later",
        "createdAt" : "2018-12-27T23:42:40Z",
        "updatedAt" : "2018-12-27T23:51:12Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "54b74606-7fd0-481b-a4fa-cdc00688f850",
        "parentId" : "28292900-ec4b-454f-8502-f2511c446db4",
        "authorId" : "eb0b5a98-1084-4e61-8414-5fb19728b91f",
        "body" : "Sure, we can probably template this a later PR.",
        "createdAt" : "2018-12-27T23:51:41Z",
        "updatedAt" : "2018-12-27T23:51:41Z",
        "lastEditedBy" : "eb0b5a98-1084-4e61-8414-5fb19728b91f",
        "tags" : [
        ]
      }
    ],
    "commit" : "19ce379e83e4eba68d24d194083b512557ffad1d",
    "line" : 126,
    "diffHunk" : "@@ -1,1 +1161,1165 @@\n            * None : Uses standard SQL ``INSERT`` clause (one per row).\n            * 'multi': Pass multiple values in a single ``INSERT`` clause.\n            * callable with signature ``(pd_table, conn, keys, data_iter)``.\n"
  },
  {
    "id" : "73d2c9d8-aa82-4852-abb5-b297d0ff992a",
    "prId" : 22654,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/22654#pullrequestreview-172996131",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "27ed7382-a51a-4e54-a110-4c76ed71d5d6",
        "parentId" : null,
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "just for my understanding: where was this attribute error catched before? ",
        "createdAt" : "2018-11-08T14:48:22Z",
        "updatedAt" : "2018-11-08T14:50:24Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      },
      {
        "id" : "dc24b589-fb69-4ba2-aa3c-b6c697a1024b",
        "parentId" : "27ed7382-a51a-4e54-a110-4c76ed71d5d6",
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "Whoop, sorry, again misunderstanding from not looking at the full diff :-)",
        "createdAt" : "2018-11-08T14:53:44Z",
        "updatedAt" : "2018-11-08T14:53:45Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      }
    ],
    "commit" : "ef3b20fcb1640986278aa8a774eb70e677b06e34",
    "line" : 61,
    "diffHunk" : "@@ -1,1 +857,861 @@                    return TIMESTAMP(timezone=True)\n            except AttributeError:\n                # The column is actually a DatetimeIndex\n                if col.tz is not None:\n                    return TIMESTAMP(timezone=True)"
  }
]
[
  {
    "id" : "1d4917cf-fd3c-4a86-8278-337e4e2c5ec0",
    "prId" : 6902,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b3dbb8b6-34a5-4390-bb00-1f799193e292",
        "parentId" : null,
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "A space after `changed.` is missing\n",
        "createdAt" : "2014-04-17T14:29:46Z",
        "updatedAt" : "2014-04-22T13:41:07Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      }
    ],
    "commit" : "09f377e367a0f0f1d4cf1934e4efad761c4b9a60",
    "line" : 38,
    "diffHunk" : "@@ -1,1 +833,837 @@\n\n_SAFE_NAMES_WARNING = (\"The spaces in these column names will not be changed.\"\n                       \"In pandas versions < 0.14, spaces were converted to \"\n                       \"underscores.\")"
  },
  {
    "id" : "4d32f9c9-9239-4ea5-adf6-f6602c076dae",
    "prId" : 6987,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ea558b56-fecc-4d5b-b847-f1f26f83a51b",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "shouldn't this raise? (and not print)\n",
        "createdAt" : "2014-05-05T11:43:28Z",
        "updatedAt" : "2014-05-08T12:03:20Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "2544bb30-7dc1-4e4f-bcfd-8c8298a99651",
        "parentId" : "ea558b56-fecc-4d5b-b847-f1f26f83a51b",
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "It should not raise I think, as it has to be able to 'retry' a couple of lines lower.\n\nNow I don't fully grasp this code, I just copied it from 0.13.1 version to retain backwards compatibility (Wes put this in 2 years ago), so I thought: no real need to clean this up, as we will remove it anyway after a deprecation cycle.\n",
        "createdAt" : "2014-05-05T12:00:54Z",
        "updatedAt" : "2014-05-08T12:03:20Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      },
      {
        "id" : "e2591720-7ca9-43e1-957c-04804c5cd361",
        "parentId" : "ea558b56-fecc-4d5b-b847-f1f26f83a51b",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "ok....that's fine...just checking, prob right not to touch it!\n",
        "createdAt" : "2014-05-05T12:01:33Z",
        "updatedAt" : "2014-05-08T12:03:20Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "ba86e3fa-e79b-4b25-b8fa-3c7183ca89c1",
        "parentId" : "ea558b56-fecc-4d5b-b847-f1f26f83a51b",
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "But I can make a warning of it instead of a print statement\n",
        "createdAt" : "2014-05-05T12:01:49Z",
        "updatedAt" : "2014-05-08T12:03:20Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      }
    ],
    "commit" : "ff95ac33c8a551ac0f20eb15c0fcac7288b53392",
    "line" : 90,
    "diffHunk" : "@@ -1,1 +159,163 @@            excName = e.__class__.__name__\n            if excName == 'OperationalError': # pragma: no cover\n                print('Failed to commit, may need to restart interpreter')\n            else:\n                raise"
  },
  {
    "id" : "342defd0-2430-4cd2-bdab-25cec0138dc1",
    "prId" : 6987,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e90e6a04-f4bf-409a-b1ae-949b813c33b1",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "maybe a warning instead of printing (I know it used to do this)...but\n",
        "createdAt" : "2014-05-05T11:43:55Z",
        "updatedAt" : "2014-05-08T12:03:20Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "ff95ac33c8a551ac0f20eb15c0fcac7288b53392",
    "line" : 162,
    "diffHunk" : "@@ -1,1 +216,220 @@        traceback.print_exc()\n        if retry:\n            print('Looks like your connection failed, reconnecting...')\n            return uquery(sql, con, retry=False)\n    return result"
  },
  {
    "id" : "d76df100-3753-48d2-88a6-a4c5c8b87131",
    "prId" : 8062,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fe1d2ace-cc3d-4c97-920c-da24ef49d657",
        "parentId" : null,
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "Do you know if there is a difference between (what you did now):\n\n```\ncon = self.pd_sql.engine.connect()\nwith con.begin() as trans:\n    for i in range(chunks):\n        ...\n        con.execute(ins, data_list)\n```\n\nand \n\n```\nwith self.pd_sql.engine.begin() as con:\n    for i in range(chunks):\n        ...\n        con.execute(ins, data_list)\n```\n\nWhere the latter is a bit simpler (as we don't directly need to use the `trans` object). Doing the executes in one transaction should make this atomic? \nBut from http://docs.sqlalchemy.org/en/rel_0_9/core/connections.html#using-transactions I would understand that both should be equivalent?\n",
        "createdAt" : "2014-08-21T19:12:23Z",
        "updatedAt" : "2014-08-21T21:42:29Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      },
      {
        "id" : "1f2500b8-2d9c-45a4-b400-c0f604436481",
        "parentId" : "fe1d2ace-cc3d-4c97-920c-da24ef49d657",
        "authorId" : "002fe2e0-eafa-49d2-9208-6fd30f14d6b0",
        "body" : "I agree the later is better but it is not supported by sqlalchemy 0.7 (nor 0.7.4) --- I get a`AttributeError: 'Engine' object has no attribute 'begin'` error.  On 0.8 it works.  Let me know if its better to change the version requirements or leave the code as it.\n",
        "createdAt" : "2014-08-21T21:14:44Z",
        "updatedAt" : "2014-08-21T21:42:29Z",
        "lastEditedBy" : "002fe2e0-eafa-49d2-9208-6fd30f14d6b0",
        "tags" : [
        ]
      },
      {
        "id" : "fedc8180-33ed-4fce-82fa-f1f13025dcde",
        "parentId" : "fe1d2ace-cc3d-4c97-920c-da24ef49d657",
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "OK, then we can just leave it like this (it's only one line longer, and for the rest equivalent). If we raise the required version, we can always clean it up\n",
        "createdAt" : "2014-08-21T21:33:51Z",
        "updatedAt" : "2014-08-21T21:42:29Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      }
    ],
    "commit" : "3c43c95e8d8faefb110bc06aba733e342dc02c31",
    "line" : 63,
    "diffHunk" : "@@ -1,1 +624,628 @@                                for k, v in zip(keys, t[1:]))\n                    data_list.append(data)\n                con.execute(ins, data_list)\n\n    def read(self, coerce_float=True, parse_dates=None, columns=None):"
  },
  {
    "id" : "e0d7e09a-b472-44ac-90ca-6d55101a79a2",
    "prId" : 8090,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fc2a4ea8-fd57-4d0d-ad43-8cfbe0108701",
        "parentId" : null,
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "@jreback The `com.is_..._dtype(arr_or_dtype)` functions, they are also meant to work with a Series? (despite the argument name).\n",
        "createdAt" : "2014-08-22T12:55:45Z",
        "updatedAt" : "2014-08-22T12:55:45Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      },
      {
        "id" : "32b669c5-766a-47cd-a683-4956ce8cf03c",
        "parentId" : "fc2a4ea8-fd57-4d0d-ad43-8cfbe0108701",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "yep, you _may_ need however to use `lib.infer_dtype` here (returns a string-like describe what the actual data is, beware though it often has to scan all the data, but will fastpath if its already has a dtype, this is really for an `object` dtype, that say holds `datetime.date`)\n",
        "createdAt" : "2014-08-22T12:59:25Z",
        "updatedAt" : "2014-08-22T12:59:25Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "33845645-873c-44ca-a4bc-8c6e9b0a0a55",
        "parentId" : "fc2a4ea8-fd57-4d0d-ad43-8cfbe0108701",
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "yes, I used it a couple of lines lower specificly for `datetime.date` and `datetime.time`\n",
        "createdAt" : "2014-08-22T13:02:51Z",
        "updatedAt" : "2014-08-22T13:02:51Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      },
      {
        "id" : "36c16d4e-4fd9-499a-a015-6d0e168afacb",
        "parentId" : "fc2a4ea8-fd57-4d0d-ad43-8cfbe0108701",
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "That is the reason I changed the function from passing the `dtype` to passing the column (series), because I needed also the values of the column for `infer_dtype`\n",
        "createdAt" : "2014-08-22T13:03:41Z",
        "updatedAt" : "2014-08-22T13:03:41Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      },
      {
        "id" : "0ea98ad1-f92f-46d7-ba35-6456b42e27c6",
        "parentId" : "fc2a4ea8-fd57-4d0d-ad43-8cfbe0108701",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "yep you can certainly test for the datetime64 first . not sure exactly what you need. take a look at `core/index.py/Index.__new__`, which goes thru a bunch of steps to figure out what is what. You  have an advantage, you already know its a Series, and already have it coerced (if its possible), so for example if it is `datetime64[ns]` you are done. (as you are already doing).\n",
        "createdAt" : "2014-08-22T13:06:29Z",
        "updatedAt" : "2014-08-22T13:06:29Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "a0cedf80359bd200b705763e59661abd82936dcc",
    "line" : 41,
    "diffHunk" : "@@ -1,1 +763,767 @@            DateTime, Date, Time, Interval)\n\n        if com.is_datetime64_dtype(col):\n            try:\n                tz = col.tzinfo"
  },
  {
    "id" : "4c3409f5-eabd-4338-aad1-c11a44dafe48",
    "prId" : 8208,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "96becce5-04d4-4e64-ac72-d6f9cdb1c436",
        "parentId" : null,
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "@jreback making a copy to reset the index to be able to also insert the index in the SQL table seems a bit stupid. \nIt seems more logical if I could add these seperately to the `data_list`. Eg I could do something like:\n\n```\nif self.index:\n    b_index = self.frame.index.to_series()._data.blocks[0]\n    blocks = b_index + blocks\n```\n\n(and then of course taking possibly different levels into account, but you get the idea)\n\nBut is there a better way to get the index values into a block? (what is needed to have the datetime and nan handling, as these both can also occur in the index)\n",
        "createdAt" : "2014-09-12T12:58:36Z",
        "updatedAt" : "2014-09-13T21:09:07Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      },
      {
        "id" : "53f846b4-d016-4eb3-a6c9-6d53655c230f",
        "parentId" : "96becce5-04d4-4e64-ac72-d6f9cdb1c436",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "I don't think making a copy is a big deal its quite cheap to do it. (and much more time doing the conversions to tuples anyhow) You can make only reset if the `self.index` is True I guess. Too complicated otherwise.\n",
        "createdAt" : "2014-09-12T13:14:11Z",
        "updatedAt" : "2014-09-13T21:09:07Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "6bbd9803-da7f-4c08-9ffb-046098370e78",
        "parentId" : "96becce5-04d4-4e64-ac72-d6f9cdb1c436",
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "yes, that is what happens now, only if `index=True`\n",
        "createdAt" : "2014-09-12T13:55:02Z",
        "updatedAt" : "2014-09-13T21:09:07Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      }
    ],
    "commit" : "638fb5b3e4199dfdb9a89c6e535300f55446c8fb",
    "line" : 20,
    "diffHunk" : "@@ -1,1 +602,606 @@    def insert_data(self):\n        if self.index is not None:\n            temp = self.frame.copy()\n            temp.index.names = self.index\n            try:"
  },
  {
    "id" : "769fab68-3e6d-4c1c-9ac2-a2a4fc0b49c2",
    "prId" : 8232,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "aedbb695-47b1-49d9-b52c-70c6ef33d5e8",
        "parentId" : null,
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "for what is this needed? The meta object is already constructed in PandasSQLEngine (or passed by the user) and should not be recreated here.\n",
        "createdAt" : "2014-09-12T13:57:54Z",
        "updatedAt" : "2014-09-15T08:33:08Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      },
      {
        "id" : "5f76847e-75b0-48ce-b1af-946e241d7704",
        "parentId" : "aedbb695-47b1-49d9-b52c-70c6ef33d5e8",
        "authorId" : "002fe2e0-eafa-49d2-9208-6fd30f14d6b0",
        "body" : "See my comments above. I create a blank `MetaData` object to avoid conflicts with the table already existing in `self.pd_sql.meta`.  Only when `create()` is called to I move it over to `self.pd_sql.meta`.\n",
        "createdAt" : "2014-09-12T19:33:35Z",
        "updatedAt" : "2014-09-15T08:33:08Z",
        "lastEditedBy" : "002fe2e0-eafa-49d2-9208-6fd30f14d6b0",
        "tags" : [
        ]
      }
    ],
    "commit" : "5065232e16b88558a891d72e35796a6f60ba6264",
    "line" : 131,
    "diffHunk" : "@@ -1,1 +754,758 @@        # once table is created.\n        from sqlalchemy.schema import MetaData\n        meta = MetaData(self.pd_sql, schema=schema)\n\n        return Table(self.name, meta, *columns, schema=schema)"
  },
  {
    "id" : "546371a8-2381-4761-9261-c89e76da7f6f",
    "prId" : 8232,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "277dc18d-08c0-405e-b43a-a14b21f5bbd7",
        "parentId" : null,
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "I know in the fallback version of `get_schema` you could specify keys, and I think this functionality is useful, but I don't yet know what would be the best interface for that \n",
        "createdAt" : "2014-09-12T14:18:31Z",
        "updatedAt" : "2014-09-15T08:33:08Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      },
      {
        "id" : "a57001a0-7ec8-44d6-87b3-e58e775cd6a6",
        "parentId" : "277dc18d-08c0-405e-b43a-a14b21f5bbd7",
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "Can you maybe pass this `keys` kwarg directly to the `_create_table_setup` method? Then we can more easily change it later if we figured out how to handle this.\n",
        "createdAt" : "2014-09-13T11:40:11Z",
        "updatedAt" : "2014-09-15T08:33:08Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      },
      {
        "id" : "c7b152f8-2dd9-4b32-92ff-8dfe6b3829e1",
        "parentId" : "277dc18d-08c0-405e-b43a-a14b21f5bbd7",
        "authorId" : "002fe2e0-eafa-49d2-9208-6fd30f14d6b0",
        "body" : "I can definitely do that but I'm not sure what the advantage would be.  Since `_create_table_setup` is getting called by the constructor, that constructor will still have a `keys` kwarg, right?\n",
        "createdAt" : "2014-09-14T00:59:03Z",
        "updatedAt" : "2014-09-15T08:33:08Z",
        "lastEditedBy" : "002fe2e0-eafa-49d2-9208-6fd30f14d6b0",
        "tags" : [
        ]
      },
      {
        "id" : "fa276be1-82ee-4d1b-82a5-0abb68b82d7d",
        "parentId" : "277dc18d-08c0-405e-b43a-a14b21f5bbd7",
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "Ah, no, I thought you were calling `_create_table_setup` directly, but this is used in the Table constructor. OK, then leave it.\n",
        "createdAt" : "2014-09-14T10:34:59Z",
        "updatedAt" : "2014-09-15T08:33:08Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      }
    ],
    "commit" : "5065232e16b88558a891d72e35796a6f60ba6264",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +553,557 @@    def __init__(self, name, pandas_sql_engine, frame=None, index=True,\n                 if_exists='fail', prefix='pandas', index_label=None,\n                 schema=None, keys=None):\n        self.name = name\n        self.pd_sql = pandas_sql_engine"
  },
  {
    "id" : "593dc7dc-5c81-4574-adff-63775f9ff6a2",
    "prId" : 8232,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ef98366e-dd15-4107-b3de-0204268bc642",
        "parentId" : null,
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "you can also return the connection in `get_session` with `engine.begin()`, then you don't need to get back the connection from trans (see http://docs.sqlalchemy.org/en/rel_0_9/core/connections.html#using-transactions)\n",
        "createdAt" : "2014-09-15T06:56:56Z",
        "updatedAt" : "2014-09-15T08:33:08Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      },
      {
        "id" : "fed40671-a4a0-4ca3-8d56-480c8c1ad335",
        "parentId" : "ef98366e-dd15-4107-b3de-0204268bc642",
        "authorId" : "002fe2e0-eafa-49d2-9208-6fd30f14d6b0",
        "body" : "I would still need to pass in the transaction for the legacy `_execute_insert`.  What is the advantage of not getting connection from `trans`?\n",
        "createdAt" : "2014-09-15T08:30:53Z",
        "updatedAt" : "2014-09-15T08:33:08Z",
        "lastEditedBy" : "002fe2e0-eafa-49d2-9208-6fd30f14d6b0",
        "tags" : [
        ]
      },
      {
        "id" : "77248538-2d10-436a-8b98-5a2c49a9bb67",
        "parentId" : "ef98366e-dd15-4107-b3de-0204268bc642",
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "I don't know if there is an advantage, apart from shorter code while being equivalent. But you are using a connection with the legacy `get_session` and `_execute_insert`, no?\n",
        "createdAt" : "2014-09-15T08:44:05Z",
        "updatedAt" : "2014-09-15T08:44:05Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      },
      {
        "id" : "cddbe39d-afe1-4f7f-b82b-b42d1ae9006b",
        "parentId" : "ef98366e-dd15-4107-b3de-0204268bc642",
        "authorId" : "002fe2e0-eafa-49d2-9208-6fd30f14d6b0",
        "body" : "Legacy `_execute_insert` uses `trans`, not the connection.\n",
        "createdAt" : "2014-09-15T20:37:03Z",
        "updatedAt" : "2014-09-15T20:37:03Z",
        "lastEditedBy" : "002fe2e0-eafa-49d2-9208-6fd30f14d6b0",
        "tags" : [
        ]
      },
      {
        "id" : "f63b1028-8c6f-4ae5-9cc4-2025c72fd9d0",
        "parentId" : "ef98366e-dd15-4107-b3de-0204268bc642",
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "you call it `trans` (and it is 'to run a transaction'), but the actual object you pass is a connection (in case of sqlite) or a cursor (in case of pymysql/MySQLdb)\n",
        "createdAt" : "2014-09-15T20:43:46Z",
        "updatedAt" : "2014-09-15T20:43:46Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      }
    ],
    "commit" : "5065232e16b88558a891d72e35796a6f60ba6264",
    "line" : 79,
    "diffHunk" : "@@ -1,1 +644,648 @@    def _execute_insert(self, trans, keys, data_iter):\n        data = [dict( (k, v) for k, v in zip(keys, row) ) for row in data_iter]\n        trans.connection.execute(self.insert_statement(), data)\n\n    def insert(self, chunksize=None):"
  },
  {
    "id" : "1d123c6b-7158-4391-a62d-433bb1455468",
    "prId" : 8232,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bbb98a0f-1b22-4420-a767-dcb6b0a7b757",
        "parentId" : null,
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "I think this can also be an iterator, see https://docs.python.org/2/library/sqlite3.html#sqlite3.Cursor.executemany, so the `list(..)` is not needed\n",
        "createdAt" : "2014-09-15T07:01:40Z",
        "updatedAt" : "2014-09-15T08:33:08Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      },
      {
        "id" : "ee11b283-681e-415f-87db-76e541225be0",
        "parentId" : "bbb98a0f-1b22-4420-a767-dcb6b0a7b757",
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "But that is only for sqlite of course, and for now we also have to support the mysql drivers, thus ignore my comment.\n",
        "createdAt" : "2014-09-15T07:02:51Z",
        "updatedAt" : "2014-09-15T08:33:08Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      }
    ],
    "commit" : "5065232e16b88558a891d72e35796a6f60ba6264",
    "line" : 206,
    "diffHunk" : "@@ -1,1 +1044,1048 @@    def _execute_insert(self, trans, keys, data_iter):\n        data_list = list(data_iter)\n        trans.executemany(self.insert_statement(), data_list)\n\n    def _create_table_setup(self):"
  },
  {
    "id" : "691945e9-2b85-4f1e-acff-43bdc983dcbc",
    "prId" : 8330,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "55a5b5d9-96a9-4885-8694-941d26947c38",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "is their a reason this is a static_method? can u share this code with the other usage of this?\n",
        "createdAt" : "2014-10-01T13:01:52Z",
        "updatedAt" : "2014-10-06T23:17:48Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "4d4f4bfd-e7d6-4811-a0cf-ed3937118510",
        "parentId" : "55a5b5d9-96a9-4885-8694-941d26947c38",
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "the reason is that it didn't use `self`, so I made it explicitely static. Problem is that the version _is_ different for the two classes, so that's why I put it in the class instead of just a general helper function like `_wrap_result`\n",
        "createdAt" : "2014-10-01T13:04:30Z",
        "updatedAt" : "2014-10-06T23:17:48Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      },
      {
        "id" : "1081a32a-a069-453a-836e-b8d9a728b56e",
        "parentId" : "55a5b5d9-96a9-4885-8694-941d26947c38",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "maybe make it a module level function then? (and _wrap results as well); or an use a TableIterator class and make these methods (see Pytables.py and read_csv does this too)\n",
        "createdAt" : "2014-10-01T13:06:34Z",
        "updatedAt" : "2014-10-06T23:17:48Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "f044fda1-1057-42d4-bb3d-4ad8bf87d4d9",
        "parentId" : "55a5b5d9-96a9-4885-8694-941d26947c38",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "https://github.com/pydata/pandas/blob/master/pandas/io/pytables.py#L1291\n",
        "createdAt" : "2014-10-01T13:08:17Z",
        "updatedAt" : "2014-10-06T23:17:48Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "4be181eb-7ace-4a51-8aa5-5fae08aafd4f",
        "parentId" : "55a5b5d9-96a9-4885-8694-941d26947c38",
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "`_wrap_results` is already a module level function (if I understand correctly what you mean)\n\nProblem with making it a module level function, is that I would have to make two versions of the function (see the two `_query_iterator` methods now), one for each class that uses it (PandasSQLALchemy and PandasSQLLegacy). So for that it seemed more logical to put it in the class itself. \n\nOn implementing an Iterator class, I had seen the implementation in pytables, but it seemed a lot more complex than what I needed here. The simple `_query_iterator` functions seems to do all I need. Is there an advantage in making it a class?\n",
        "createdAt" : "2014-10-01T13:16:40Z",
        "updatedAt" : "2014-10-06T23:17:48Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      },
      {
        "id" : "ab87cf36-874d-4529-b9bb-5e0b7ad5c80f",
        "parentId" : "55a5b5d9-96a9-4885-8694-941d26947c38",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "I think your class would be simpler (and u could inherit methods)\nand bundle wrap_results - really just preference - up 2 u\n",
        "createdAt" : "2014-10-01T13:23:04Z",
        "updatedAt" : "2014-10-06T23:17:48Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "8bbe08a6-2fca-487a-8a4b-aeae8394ad03",
        "parentId" : "55a5b5d9-96a9-4885-8694-941d26947c38",
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "OK, I am going to leave it now as is, can always later look at implementing it as a class, but like to get this in\n",
        "createdAt" : "2014-10-06T21:07:17Z",
        "updatedAt" : "2014-10-06T23:17:48Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      }
    ],
    "commit" : "feb5d4c7e91755016842b40f4bcc5d6f0241c614",
    "line" : 322,
    "diffHunk" : "@@ -1,1 +1384,1388 @@    @staticmethod\n    def _query_iterator(cursor, chunksize, columns, index_col=None,\n                        coerce_float=True, parse_dates=None):\n        \"\"\"Return generator through chunked result set\"\"\"\n"
  },
  {
    "id" : "18f402f9-43b2-4819-9c59-570e595663af",
    "prId" : 9041,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "24936cec-4f77-42bc-be3e-a84d76359282",
        "parentId" : null,
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "Certainly fine to add this! But can you also add a test for it? (just a test for the API usage, so it won't get removed accidentally, so it can go in `TestSQLApi` (no need to test it for each flavor separately)\n",
        "createdAt" : "2014-12-23T10:14:00Z",
        "updatedAt" : "2015-01-24T18:51:50Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      }
    ],
    "commit" : "bb0c2e8da22ecb63036ddd3407569468716e9b1a",
    "line" : 82,
    "diffHunk" : "@@ -1,1 +1541,1545 @@\n\ndef get_schema(frame, name, flavor='sqlite', keys=None, con=None, dtype=None):\n    \"\"\"\n    Get the SQL db table schema for the given frame."
  },
  {
    "id" : "a15a890a-a6ec-41c6-8dbb-764e72a9305a",
    "prId" : 19664,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/19664#pullrequestreview-99935001",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2d9dba68-3bbe-4138-adce-56f6297a6ffd",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "can you add a doc-string here",
        "createdAt" : "2018-02-18T17:58:35Z",
        "updatedAt" : "2018-03-07T21:54:32Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "a0ade5b4-4154-4ceb-8b75-68a48f4774c8",
        "parentId" : "2d9dba68-3bbe-4138-adce-56f6297a6ffd",
        "authorId" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "body" : "Could you add a parameters and returns section as well. http://numpydoc.readthedocs.io/en/latest/format.html",
        "createdAt" : "2018-02-28T03:33:48Z",
        "updatedAt" : "2018-03-07T21:54:32Z",
        "lastEditedBy" : "21b82015-4bfc-4f74-bfca-586973dad2cd",
        "tags" : [
        ]
      }
    ],
    "commit" : "f298de101762a97e2f3f856679e58f8b9c392942",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +573,577 @@            self._execute_create()\n\n    def insert_statement(self, data, conn):\n        \"\"\"\n        Generate tuple of SQLAlchemy insert statement and any arguments"
  },
  {
    "id" : "4dc6781c-989f-4a3c-b30c-0e6eb9541801",
    "prId" : 20004,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/20004#pullrequestreview-101947235",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "95573be8-0999-4ad3-9e83-ec04d348e55e",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "@jorisvandenbossche is this right? should we deprecate / rename this parameter?",
        "createdAt" : "2018-03-07T14:05:44Z",
        "updatedAt" : "2018-03-07T14:05:48Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "a8b00623-a53e-43f5-944b-47f64fb47df6",
        "parentId" : "95573be8-0999-4ad3-9e83-ec04d348e55e",
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "yes, this seems right, as a few lines below it does:\r\n\r\n```\r\n    if isinstance(frame, Series):\r\n        frame = frame.to_frame()\r\n```\r\n\r\nbut since this is mostly an internal method (most people will directly use DataFrame/Series.to_sql), I don't think we should bother with deprecating or renaming it",
        "createdAt" : "2018-03-07T14:30:12Z",
        "updatedAt" : "2018-03-07T14:30:12Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      }
    ],
    "commit" : "0215116e5dfa8b83c01d0fe7944575c32965933c",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +405,409 @@    Parameters\n    ----------\n    frame : DataFrame, Series\n    name : string\n        Name of SQL table."
  },
  {
    "id" : "e83bc965-54d0-46d2-bf7c-c9b59aac7910",
    "prId" : 21401,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/21401#pullrequestreview-188195913",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "28292900-ec4b-454f-8502-f2511c446db4",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "seems to be lots of repetitive doc-strings here, can think about this for later",
        "createdAt" : "2018-12-27T23:42:40Z",
        "updatedAt" : "2018-12-27T23:51:12Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "54b74606-7fd0-481b-a4fa-cdc00688f850",
        "parentId" : "28292900-ec4b-454f-8502-f2511c446db4",
        "authorId" : "eb0b5a98-1084-4e61-8414-5fb19728b91f",
        "body" : "Sure, we can probably template this a later PR.",
        "createdAt" : "2018-12-27T23:51:41Z",
        "updatedAt" : "2018-12-27T23:51:41Z",
        "lastEditedBy" : "eb0b5a98-1084-4e61-8414-5fb19728b91f",
        "tags" : [
        ]
      }
    ],
    "commit" : "19ce379e83e4eba68d24d194083b512557ffad1d",
    "line" : 126,
    "diffHunk" : "@@ -1,1 +1161,1165 @@\n            * None : Uses standard SQL ``INSERT`` clause (one per row).\n            * 'multi': Pass multiple values in a single ``INSERT`` clause.\n            * callable with signature ``(pd_table, conn, keys, data_iter)``.\n"
  },
  {
    "id" : "73d2c9d8-aa82-4852-abb5-b297d0ff992a",
    "prId" : 22654,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/22654#pullrequestreview-172996131",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "27ed7382-a51a-4e54-a110-4c76ed71d5d6",
        "parentId" : null,
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "just for my understanding: where was this attribute error catched before? ",
        "createdAt" : "2018-11-08T14:48:22Z",
        "updatedAt" : "2018-11-08T14:50:24Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      },
      {
        "id" : "dc24b589-fb69-4ba2-aa3c-b6c697a1024b",
        "parentId" : "27ed7382-a51a-4e54-a110-4c76ed71d5d6",
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "Whoop, sorry, again misunderstanding from not looking at the full diff :-)",
        "createdAt" : "2018-11-08T14:53:44Z",
        "updatedAt" : "2018-11-08T14:53:45Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      }
    ],
    "commit" : "ef3b20fcb1640986278aa8a774eb70e677b06e34",
    "line" : 61,
    "diffHunk" : "@@ -1,1 +857,861 @@                    return TIMESTAMP(timezone=True)\n            except AttributeError:\n                # The column is actually a DatetimeIndex\n                if col.tz is not None:\n                    return TIMESTAMP(timezone=True)"
  },
  {
    "id" : "067fdb68-6657-47a0-a45c-96c2d957214b",
    "prId" : 25024,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/25024#pullrequestreview-198067390",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9a5e1c2a-b1f4-4415-8844-21c08d519c85",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "is there a test for this? I see your comment, but still would be nice to have one.",
        "createdAt" : "2019-01-30T12:50:49Z",
        "updatedAt" : "2019-01-30T12:51:37Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "bd8d685b-5c1c-4d9c-abd3-0b8c3a9d1983",
        "parentId" : "9a5e1c2a-b1f4-4415-8844-21c08d519c85",
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "As I said above, see the issue #24988. I can't get a reproducible case on travis for now",
        "createdAt" : "2019-01-30T13:06:34Z",
        "updatedAt" : "2019-01-30T13:06:34Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      },
      {
        "id" : "8c0d80cb-2e6f-42fa-8e3e-e95bb8ec60d2",
        "parentId" : "9a5e1c2a-b1f4-4415-8844-21c08d519c85",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "ok, if one of the OP can provide a test before release would be good. otherwise ok.",
        "createdAt" : "2019-01-30T13:10:47Z",
        "updatedAt" : "2019-01-30T13:10:47Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "94b9dd6ce87344b958601659d63a4c3e72ac5226",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +382,386 @@    try:\n        _is_table_name = pandas_sql.has_table(sql)\n    except Exception:\n        # using generic exception to catch errors from sql drivers (GH24988)\n        _is_table_name = False"
  },
  {
    "id" : "e032587c-b615-4a81-985a-9f075bac67c9",
    "prId" : 26795,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/26795#pullrequestreview-249726426",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "90da9a3b-7c0a-400e-b802-ff7c98339ef1",
        "parentId" : null,
        "authorId" : "53c53fa0-b50f-475c-8d1c-5232b3ab5a4b",
        "body" : "@jorisvandenbossche FYI this introduces a bit of an incoherent style. If it's agreed that the style in generic is preferred, I can mirror the rest as well.",
        "createdAt" : "2019-06-13T20:21:45Z",
        "updatedAt" : "2019-08-29T10:01:54Z",
        "lastEditedBy" : "53c53fa0-b50f-475c-8d1c-5232b3ab5a4b",
        "tags" : [
        ]
      },
      {
        "id" : "1002e9de-2bf6-4f28-94b7-587375604d0b",
        "parentId" : "90da9a3b-7c0a-400e-b802-ff7c98339ef1",
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "What do you mean exactly with the incoherent style? (the change on the above line looks good)",
        "createdAt" : "2019-06-13T22:23:21Z",
        "updatedAt" : "2019-08-29T10:01:54Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      },
      {
        "id" : "137439c6-45cf-41bc-b9fc-f010028995d9",
        "parentId" : "90da9a3b-7c0a-400e-b802-ff7c98339ef1",
        "authorId" : "53c53fa0-b50f-475c-8d1c-5232b3ab5a4b",
        "body" : "Should've been more explicit... I was referring to `, default None` -> `, optional`.",
        "createdAt" : "2019-06-14T06:15:24Z",
        "updatedAt" : "2019-08-29T10:01:54Z",
        "lastEditedBy" : "53c53fa0-b50f-475c-8d1c-5232b3ab5a4b",
        "tags" : [
        ]
      },
      {
        "id" : "206d5f26-a92f-4204-8e77-653fb34d1357",
        "parentId" : "90da9a3b-7c0a-400e-b802-ff7c98339ef1",
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "A, that's perfect! (in line with what we wrote down in our docstring guide: http://dev.pandas.io/development/contributing_docstring.html#section-3-parameters)",
        "createdAt" : "2019-06-14T06:26:37Z",
        "updatedAt" : "2019-08-29T10:01:54Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      }
    ],
    "commit" : "efa97be404f754c9bf038a271b845e63c4b0cd9d",
    "line" : 37,
    "diffHunk" : "@@ -1,1 +480,484 @@        Specify the number of rows in each batch to be written at a time.\n        By default, all rows will be written at once.\n    dtype : dict or scalar, optional\n        Specifying the datatype for columns. If a dictionary is used, the\n        keys should be the column names and the values should be the"
  },
  {
    "id" : "2d5e9ddf-b0f4-4b02-9a83-094303ceeb97",
    "prId" : 33229,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/33229#pullrequestreview-388629526",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "abffaad6-a018-4413-8ed8-56583beac756",
        "parentId" : null,
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "I think we start with not using iloc for this pattern (that gives a lot of overhead). \r\nNot that it will matter very much in this case, though, I suppose, since we are converting to object dtype below which will be more costly. \r\n\r\nSee eg the helper function you asked me to remove in https://github.com/pandas-dev/pandas/pull/32867/commits/07372e38b63fe0c3bca6a771d82ef521833119d6 ",
        "createdAt" : "2020-04-02T13:54:23Z",
        "updatedAt" : "2020-04-06T23:27:50Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      },
      {
        "id" : "b4f348ad-5c28-4d57-822d-a71cc25ebf84",
        "parentId" : "abffaad6-a018-4413-8ed8-56583beac756",
        "authorId" : "adf621f1-4745-479a-a1fc-dc14046a3f4b",
        "body" : "sure, _ixs works here",
        "createdAt" : "2020-04-02T21:39:06Z",
        "updatedAt" : "2020-04-06T23:27:50Z",
        "lastEditedBy" : "adf621f1-4745-479a-a1fc-dc14046a3f4b",
        "tags" : [
        ]
      },
      {
        "id" : "86ca9faf-11f3-46ce-939e-bda5fbad6fe4",
        "parentId" : "abffaad6-a018-4413-8ed8-56583beac756",
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "Although _ixs helps, the big win actually comes from avoiding creating a series if all you need are the values (as I did in the linked snippet)",
        "createdAt" : "2020-04-03T06:12:39Z",
        "updatedAt" : "2020-04-06T23:27:50Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      },
      {
        "id" : "c2d3aa62-a17a-4d93-9854-8f08a63be57b",
        "parentId" : "abffaad6-a018-4413-8ed8-56583beac756",
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "https://github.com/pandas-dev/pandas/pull/33252",
        "createdAt" : "2020-04-03T07:59:07Z",
        "updatedAt" : "2020-04-06T23:27:50Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      },
      {
        "id" : "b4368fac-b157-40f4-bae3-175bdcceb406",
        "parentId" : "abffaad6-a018-4413-8ed8-56583beac756",
        "authorId" : "adf621f1-4745-479a-a1fc-dc14046a3f4b",
        "body" : "OK.  Until #33252 goes through, any objection to _ixs here?",
        "createdAt" : "2020-04-03T16:52:54Z",
        "updatedAt" : "2020-04-06T23:27:50Z",
        "lastEditedBy" : "adf621f1-4745-479a-a1fc-dc14046a3f4b",
        "tags" : [
        ]
      },
      {
        "id" : "441195f0-d734-4bfc-a40f-974cc1daae59",
        "parentId" : "abffaad6-a018-4413-8ed8-56583beac756",
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "Yes, whichever gets merged second can be update to use it here",
        "createdAt" : "2020-04-03T17:36:31Z",
        "updatedAt" : "2020-04-06T23:27:50Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      },
      {
        "id" : "917fde80-614e-4d43-85b6-c87dcf58e8a3",
        "parentId" : "abffaad6-a018-4413-8ed8-56583beac756",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "I really don't like using private methods like this, what is wrong with .iloc here?",
        "createdAt" : "2020-04-03T17:44:54Z",
        "updatedAt" : "2020-04-06T23:27:50Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "19ec7cdb-d1f4-44b0-a4bd-7dfa0f60dc1e",
        "parentId" : "abffaad6-a018-4413-8ed8-56583beac756",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "Using methods *internally* in frame.py is one thing; however this should be using a public API (and likely this makes almost no difference here).",
        "createdAt" : "2020-04-03T17:48:28Z",
        "updatedAt" : "2020-04-06T23:27:50Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "fd7cc8a2-12e7-4866-a705-258349721a3a",
        "parentId" : "abffaad6-a018-4413-8ed8-56583beac756",
        "authorId" : "adf621f1-4745-479a-a1fc-dc14046a3f4b",
        "body" : "i agree with jeff on this one",
        "createdAt" : "2020-04-03T17:53:12Z",
        "updatedAt" : "2020-04-06T23:27:50Z",
        "lastEditedBy" : "adf621f1-4745-479a-a1fc-dc14046a3f4b",
        "tags" : [
        ]
      },
      {
        "id" : "11226f05-f878-4a23-92f2-83c4e9c766e4",
        "parentId" : "abffaad6-a018-4413-8ed8-56583beac756",
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "It's exactly the goal of the helper function I am adding in https://github.com/pandas-dev/pandas/pull/33252 to be used in situations where only the array values are needed, like here is the case.\r\n\r\nSo if we are adding such helper method, why not use it? (the reason I did the PR is because I want to see it used in several places, and many of those places will be *outside* of frame.py, eg in the ops code)\r\n\r\nIf the privateness of the method is a problem, let's discuss making it public. Although I personally think that is not needed right now (and we are using plenty of semi-private methods on DataFrame/Series outside of `frame.py` already)",
        "createdAt" : "2020-04-06T08:26:01Z",
        "updatedAt" : "2020-04-06T23:27:50Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      },
      {
        "id" : "27ee23e0-bafb-4208-865b-e0d489170548",
        "parentId" : "abffaad6-a018-4413-8ed8-56583beac756",
        "authorId" : "adf621f1-4745-479a-a1fc-dc14046a3f4b",
        "body" : "lets revisit that once #33252 is merged",
        "createdAt" : "2020-04-06T17:21:30Z",
        "updatedAt" : "2020-04-06T23:27:50Z",
        "lastEditedBy" : "adf621f1-4745-479a-a1fc-dc14046a3f4b",
        "tags" : [
        ]
      },
      {
        "id" : "1bccb359-2185-45e8-b268-800f5e959521",
        "parentId" : "abffaad6-a018-4413-8ed8-56583beac756",
        "authorId" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "body" : "This PR certainly does not need to wait on #33252 being merged, but I still first want to have the discussion whether we find this an appropriate place to use that function here, once it exists.",
        "createdAt" : "2020-04-06T17:44:43Z",
        "updatedAt" : "2020-04-06T23:27:50Z",
        "lastEditedBy" : "cc7022b2-2831-4c63-a4da-d18b0d342508",
        "tags" : [
        ]
      },
      {
        "id" : "58500648-151d-4b34-8c4e-3ba74074ad7d",
        "parentId" : "abffaad6-a018-4413-8ed8-56583beac756",
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "I don't think we should be using internal functions *except* in the internals. This is not internal by any stretch (would say that pandas.io is offlimits entirely)",
        "createdAt" : "2020-04-06T21:26:07Z",
        "updatedAt" : "2020-04-06T23:27:50Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      }
    ],
    "commit" : "eae5b1ee0e1dcb57f1414d8612f82c249eea28b0",
    "line" : 24,
    "diffHunk" : "@@ -1,1 +695,699 @@\n        for i, (_, ser) in enumerate(temp.items()):\n            vals = ser._values\n            if vals.dtype.kind == \"M\":\n                d = vals.to_pydatetime()"
  },
  {
    "id" : "05c6f2db-2d55-43e6-be8f-01ddf0d74903",
    "prId" : 34207,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/34207#pullrequestreview-415741278",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "340512bb-6564-4261-a734-9c2c1f86632b",
        "parentId" : null,
        "authorId" : "554ba0f6-6e6a-40c3-98e0-1a6cc4a8e1c6",
        "body" : "are the return types of the two overloads switched? or have a misread the docstring?",
        "createdAt" : "2020-05-20T11:58:07Z",
        "updatedAt" : "2020-05-21T08:04:45Z",
        "lastEditedBy" : "554ba0f6-6e6a-40c3-98e0-1a6cc4a8e1c6",
        "tags" : [
        ]
      },
      {
        "id" : "1d4e6054-ee41-4221-bfb4-8ca307a3eb81",
        "parentId" : "340512bb-6564-4261-a734-9c2c1f86632b",
        "authorId" : "5e8c5ef2-940b-436e-9c5f-98ae5460128c",
        "body" : "Yea looks like a copy / paste error? The other two funcs look correct.\r\n\r\nlgtm outside of this issue",
        "createdAt" : "2020-05-20T21:52:58Z",
        "updatedAt" : "2020-05-21T08:04:45Z",
        "lastEditedBy" : "5e8c5ef2-940b-436e-9c5f-98ae5460128c",
        "tags" : [
        ]
      }
    ],
    "commit" : "c2c710707de2220346e79993659bccbcafadb1fc",
    "line" : 91,
    "diffHunk" : "@@ -1,1 +309,313 @@    parse_dates=None,\n    chunksize: int = 1,\n) -> Iterator[DataFrame]:\n    ...\n"
  },
  {
    "id" : "baac7c6d-9d5a-4de7-95e8-9b989a844efa",
    "prId" : 34429,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/34429#pullrequestreview-420302448",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b2b0e86e-adcd-4177-a8ee-6e3bea887886",
        "parentId" : null,
        "authorId" : "c450dd54-d24d-43a8-b896-c2c9af46ca18",
        "body" : "What happens if you just yield an empty DataFrame here without keeping track of having read data?",
        "createdAt" : "2020-05-28T15:09:11Z",
        "updatedAt" : "2021-01-14T17:55:41Z",
        "lastEditedBy" : "c450dd54-d24d-43a8-b896-c2c9af46ca18",
        "tags" : [
        ]
      },
      {
        "id" : "ef2a49b6-4bc7-4a73-a5ba-e35b98fdd13e",
        "parentId" : "b2b0e86e-adcd-4177-a8ee-6e3bea887886",
        "authorId" : "fe4a8bd7-743d-4861-b771-478b31f36393",
        "body" : "If the query does return rows, the resulting generator will have an empty dangling dataframe. Say the chunksize is set to 5, and the result set has 13 rows, the generator will contain:\r\n```\r\n(\r\n   a DataFrame with 5 rows,\r\n   a DataFrame with 5 rows,\r\n   a DataFrame with 3 rows,\r\n   an empty DataFrame\r\n)\r\n```\r\n\r\nThis is probably not desirable. I agree, keeping track of if we read data isn't very elegant, but I it's the best solution I can come up with.",
        "createdAt" : "2020-05-28T16:45:28Z",
        "updatedAt" : "2021-01-14T17:55:41Z",
        "lastEditedBy" : "fe4a8bd7-743d-4861-b771-478b31f36393",
        "tags" : [
        ]
      }
    ],
    "commit" : "de5f395692bc1006a19e28ececb4ffd9e3b1b038",
    "line" : 11,
    "diffHunk" : "@@ -1,1 +934,938 @@                    yield DataFrame.from_records(\n                        [], columns=columns, coerce_float=coerce_float\n                    )\n                break\n            else:"
  },
  {
    "id" : "000e040a-6ae8-4762-be2f-0ea4a200aef2",
    "prId" : 34429,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/34429#pullrequestreview-426304498",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e0154393-2c6c-444e-b7e3-482c13979d13",
        "parentId" : null,
        "authorId" : "5e8c5ef2-940b-436e-9c5f-98ae5460128c",
        "body" : "Is this `break` statement still being hit?",
        "createdAt" : "2020-06-05T23:02:34Z",
        "updatedAt" : "2021-01-14T17:55:41Z",
        "lastEditedBy" : "5e8c5ef2-940b-436e-9c5f-98ae5460128c",
        "tags" : [
        ]
      },
      {
        "id" : "d67b12de-463e-4d6a-8d82-e1ba556cfe66",
        "parentId" : "e0154393-2c6c-444e-b7e3-482c13979d13",
        "authorId" : "fe4a8bd7-743d-4861-b771-478b31f36393",
        "body" : "Yes, if `has_read_data` an empty dataframe is yielded, then the `break` statement breaks out of the `while True` loop, ending the generator.\r\n\r\nYou can verify that this statement is hit by running for example\r\n\r\n```\r\n> pytest --cov=pandas/io/ --cov-report html pandas/tests/io/test_sql.py::TestSQLApi::test_read_sql_with_chunksize_no_result\r\n```  ",
        "createdAt" : "2020-06-08T14:33:59Z",
        "updatedAt" : "2021-01-14T17:55:41Z",
        "lastEditedBy" : "fe4a8bd7-743d-4861-b771-478b31f36393",
        "tags" : [
        ]
      }
    ],
    "commit" : "de5f395692bc1006a19e28ececb4ffd9e3b1b038",
    "line" : 12,
    "diffHunk" : "@@ -1,1 +935,939 @@                        [], columns=columns, coerce_float=coerce_float\n                    )\n                break\n            else:\n                has_read_data = True"
  },
  {
    "id" : "7c16b37c-eccb-4988-98d9-bcd2e349026f",
    "prId" : 34429,
    "prUrl" : "https://github.com/pandas-dev/pandas/pull/34429#pullrequestreview-437927091",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8a5b2f66-c998-433d-b3c1-576df3873d63",
        "parentId" : null,
        "authorId" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "body" : "you could try defining data in an out scope e.g.\r\n```\r\ndata: List\r\n```\r\n\r\nthen you can test that after the break",
        "createdAt" : "2020-06-24T16:06:41Z",
        "updatedAt" : "2021-01-14T17:55:41Z",
        "lastEditedBy" : "7086d5c0-382b-4c41-b70d-144a07643f71",
        "tags" : [
        ]
      },
      {
        "id" : "c2a614d2-2b2f-4a45-998b-ed2ff58527ce",
        "parentId" : "8a5b2f66-c998-433d-b3c1-576df3873d63",
        "authorId" : "fe4a8bd7-743d-4861-b771-478b31f36393",
        "body" : "Thank you Jeff.\r\n\r\nIf I understand what you're proposing correctly (i.e. defining `data` outside the while loop then checking it's status after exiting the loop), then that unfortunately doesn't work. The break clause is triggered when `not data` is True (i.e. `data` is an empty list), so regardless of how many results are returned (and how many times the loop is executed) when you exit the loop `data` will be an empty list. Line 1705 `data = cursor.fetchmany(chunksize)` is always executed at least once, so setting `data` to `None` (or anything else) outside the while loop doesn't achieve anything.",
        "createdAt" : "2020-06-25T23:35:02Z",
        "updatedAt" : "2021-01-14T17:55:41Z",
        "lastEditedBy" : "fe4a8bd7-743d-4861-b771-478b31f36393",
        "tags" : [
        ]
      }
    ],
    "commit" : "de5f395692bc1006a19e28ececb4ffd9e3b1b038",
    "line" : 44,
    "diffHunk" : "@@ -1,1 +1866,1870 @@    ):\n        \"\"\"Return generator through chunked result set\"\"\"\n        has_read_data = False\n        while True:\n            data = cursor.fetchmany(chunksize)"
  }
]
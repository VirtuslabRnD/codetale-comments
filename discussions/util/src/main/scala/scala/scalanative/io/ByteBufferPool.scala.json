[
  {
    "id" : "f51d342c-83b4-4a7a-bf7b-0e4d92d28372",
    "prId" : 633,
    "prUrl" : "https://github.com/scala-native/scala-native/pull/633#pullrequestreview-34115444",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "69f05f33-7700-448d-be34-3deb97e7b646",
        "parentId" : null,
        "authorId" : "19142ef5-3d34-49b4-a25f-6b361a41847d",
        "body" : "test this with a large file",
        "createdAt" : "2017-04-11T20:01:57Z",
        "updatedAt" : "2017-04-21T14:08:59Z",
        "lastEditedBy" : "19142ef5-3d34-49b4-a25f-6b361a41847d",
        "tags" : [
        ]
      },
      {
        "id" : "7351b502-1f93-4042-9e98-1637f3804973",
        "parentId" : "69f05f33-7700-448d-be34-3deb97e7b646",
        "authorId" : "d1cbb5a4-1605-48d2-8efe-eeb6295c931f",
        "body" : "I tested it with `;rebuild;tests/run`. The problem with large files is in `CodeGen` which I changed to not use `ByteBufferPool`",
        "createdAt" : "2017-04-11T20:08:22Z",
        "updatedAt" : "2017-04-21T14:08:59Z",
        "lastEditedBy" : "d1cbb5a4-1605-48d2-8efe-eeb6295c931f",
        "tags" : [
        ]
      },
      {
        "id" : "50cd2bc6-0a66-4321-aa46-26a7229cf47c",
        "parentId" : "69f05f33-7700-448d-be34-3deb97e7b646",
        "authorId" : "d1cbb5a4-1605-48d2-8efe-eeb6295c931f",
        "body" : "The largest `.nir` file I could find in the repo is 2M so yes this is somewhat of a stopgap measure, but fixing the NIR code generation is a much larger effort to refactor.\r\n\r\n```\r\n> find . -name \"*.nir\" | xargs stat -f \"%z %N\" | sort -n | tail -5\r\n    546211 ./scalalib/target/scala-2.11/classes/scala/collection/immutable/StreamViewLike$$anon$13.nir\r\n    580412 ./scalalib/target/scala-2.11/classes/scala/collection/mutable/IndexedSeqLike$$anon$1.nir\r\n    612962 ./javalib/target/scala-2.11/classes/java/math/BigDecimal.nir\r\n    699387 ./javalib/target/scala-2.11/classes/java/util/Arrays$.nir\r\n    2301253 ./javalib/target/scala-2.11/classes/java/lang/Character$.nir\r\n```",
        "createdAt" : "2017-04-11T20:11:01Z",
        "updatedAt" : "2017-04-21T14:08:59Z",
        "lastEditedBy" : "d1cbb5a4-1605-48d2-8efe-eeb6295c931f",
        "tags" : [
        ]
      },
      {
        "id" : "deb96335-c43c-42e1-8ba2-7cea6968b149",
        "parentId" : "69f05f33-7700-448d-be34-3deb97e7b646",
        "authorId" : "0f96d83b-618e-4d06-9aeb-e1d46fa92077",
        "body" : "Solution proposed here is a bit of bandaid, we'll probably rework this more fundamentally later on. There is quite a bit of cruft that has been accumulated around here and quite a few things that can be improved, but that would require drastic changes which are out of scope for this pr. ",
        "createdAt" : "2017-04-21T14:05:46Z",
        "updatedAt" : "2017-04-21T14:08:59Z",
        "lastEditedBy" : "0f96d83b-618e-4d06-9aeb-e1d46fa92077",
        "tags" : [
        ]
      },
      {
        "id" : "03a97eac-00f4-4c5c-aa60-73c79b9053c0",
        "parentId" : "69f05f33-7700-448d-be34-3deb97e7b646",
        "authorId" : "d1cbb5a4-1605-48d2-8efe-eeb6295c931f",
        "body" : "Yes, should we create a new more focused ticket to refactor buffering in NIR and code gen?",
        "createdAt" : "2017-04-21T14:10:12Z",
        "updatedAt" : "2017-04-21T14:10:12Z",
        "lastEditedBy" : "d1cbb5a4-1605-48d2-8efe-eeb6295c931f",
        "tags" : [
        ]
      },
      {
        "id" : "a82af575-ee19-4e3a-873a-105ddc9d4e0c",
        "parentId" : "69f05f33-7700-448d-be34-3deb97e7b646",
        "authorId" : "0f96d83b-618e-4d06-9aeb-e1d46fa92077",
        "body" : "This should probably go in hand with binary format revamp I've planned for a while in #132. I've added buffer size concern to the list on that issue.",
        "createdAt" : "2017-04-21T19:59:21Z",
        "updatedAt" : "2017-04-21T19:59:21Z",
        "lastEditedBy" : "0f96d83b-618e-4d06-9aeb-e1d46fa92077",
        "tags" : [
        ]
      },
      {
        "id" : "26feab94-6bb2-4866-8aed-1531592623b6",
        "parentId" : "69f05f33-7700-448d-be34-3deb97e7b646",
        "authorId" : "d1cbb5a4-1605-48d2-8efe-eeb6295c931f",
        "body" : "There's also the codegen side, where we could investigate whether we can generate in one pass by reordering instructions to be aware of dependencies and whether we can render directly into a `CharBuffer` to not pay the `StringBuffer` => `byte[]` => `ByteBuffer` tax",
        "createdAt" : "2017-04-21T20:14:20Z",
        "updatedAt" : "2017-04-21T20:14:20Z",
        "lastEditedBy" : "d1cbb5a4-1605-48d2-8efe-eeb6295c931f",
        "tags" : [
        ]
      },
      {
        "id" : "5fd48438-47d3-48ee-b506-2176172df8bc",
        "parentId" : "69f05f33-7700-448d-be34-3deb97e7b646",
        "authorId" : "0f96d83b-618e-4d06-9aeb-e1d46fa92077",
        "body" : "That one probably deserves its own ticket, feel free to file a new one with possible ideas for the solution. üëç ",
        "createdAt" : "2017-04-21T20:23:54Z",
        "updatedAt" : "2017-04-21T20:23:54Z",
        "lastEditedBy" : "0f96d83b-618e-4d06-9aeb-e1d46fa92077",
        "tags" : [
        ]
      }
    ],
    "commit" : "25071d656114591f269b08f69cbd90ca27e426e6",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +8,12 @@\n  private def alloc(): ByteBuffer = {\n    ByteBuffer.allocateDirect(8 * 1024 * 1024)\n  }\n"
  },
  {
    "id" : "9716625a-063a-4659-87ce-8da1be0fd1b5",
    "prId" : 588,
    "prUrl" : "https://github.com/scala-native/scala-native/pull/588#pullrequestreview-31896040",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "32b6d2d1-b4fa-4d6c-bf28-ee2bfb416216",
        "parentId" : null,
        "authorId" : "0f96d83b-618e-4d06-9aeb-e1d46fa92077",
        "body" : "This is not a real fix for the problem, but I'm going to have a look at the real solution for the problem after this PR.",
        "createdAt" : "2017-04-10T12:49:57Z",
        "updatedAt" : "2017-04-10T19:25:45Z",
        "lastEditedBy" : "0f96d83b-618e-4d06-9aeb-e1d46fa92077",
        "tags" : [
        ]
      },
      {
        "id" : "a48dce57-3bb4-4aa0-ab49-49668154a33e",
        "parentId" : "32b6d2d1-b4fa-4d6c-bf28-ee2bfb416216",
        "authorId" : "19142ef5-3d34-49b4-a25f-6b361a41847d",
        "body" : "Ok I leave this as is ?",
        "createdAt" : "2017-04-10T15:00:33Z",
        "updatedAt" : "2017-04-10T19:25:45Z",
        "lastEditedBy" : "19142ef5-3d34-49b4-a25f-6b361a41847d",
        "tags" : [
        ]
      },
      {
        "id" : "bf4f8c9c-a6e0-49ae-9b6a-4be7cdba912d",
        "parentId" : "32b6d2d1-b4fa-4d6c-bf28-ee2bfb416216",
        "authorId" : "0f96d83b-618e-4d06-9aeb-e1d46fa92077",
        "body" : "Yep, lets have `64M`-sized buffers for now. ",
        "createdAt" : "2017-04-10T16:52:11Z",
        "updatedAt" : "2017-04-10T19:25:45Z",
        "lastEditedBy" : "0f96d83b-618e-4d06-9aeb-e1d46fa92077",
        "tags" : [
        ]
      }
    ],
    "commit" : "9caf539c0c1bdd8069a9390cdef87fdd4a4a17b8",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +8,12 @@\n  private def alloc(): ByteBuffer = {\n    ByteBuffer.allocateDirect(64 * 1024 * 1024)\n  }\n"
  }
]
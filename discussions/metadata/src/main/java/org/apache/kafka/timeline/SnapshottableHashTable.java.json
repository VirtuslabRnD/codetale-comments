[
  {
    "id" : "1beaa63b-7ccb-402e-97d1-62d73aeae36d",
    "prId" : 9901,
    "prUrl" : "https://github.com/apache/kafka/pull/9901#pullrequestreview-580621483",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6d69c15d-009c-471c-84be-0e32e3911f75",
        "parentId" : null,
        "authorId" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "body" : "It seems that we don't need to do the while loop. Perhaps we could just assert `hasNext() `here.",
        "createdAt" : "2021-01-30T02:08:08Z",
        "updatedAt" : "2021-02-02T05:06:53Z",
        "lastEditedBy" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "tags" : [
        ]
      },
      {
        "id" : "320bb4c9-ada2-4234-9b8f-13ffb2c05dc1",
        "parentId" : "6d69c15d-009c-471c-84be-0e32e3911f75",
        "authorId" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "body" : "The while loop is needed because we need to search forward in the snapshot list.\r\n\r\nBasically this is an optimization for PUT.  When creating a new delta entry, rather than adding that delta entry to every previous snapshot, we only add it to the most recent snapshot.  Then, when reading from an older snapshot, we need to search forward from there to make sure we're seeing everything.",
        "createdAt" : "2021-02-01T18:00:27Z",
        "updatedAt" : "2021-02-02T05:06:53Z",
        "lastEditedBy" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "tags" : [
        ]
      }
    ],
    "commit" : "42a34b3b008bc3b65b17d79c8e2c4dd4de9b4f95",
    "line" : 310,
    "diffHunk" : "@@ -1,1 +308,312 @@        }\n        Iterator<Snapshot> iterator = snapshotRegistry.iterator(epoch);\n        while (iterator.hasNext()) {\n            Snapshot snapshot = iterator.next();\n            HashTier<T> tier = snapshot.getDelta(SnapshottableHashTable.this);"
  },
  {
    "id" : "4fca32d0-f155-46ae-990c-cd9bd9935bf5",
    "prId" : 9901,
    "prUrl" : "https://github.com/apache/kafka/pull/9901#pullrequestreview-580621694",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f2a20743-6fdf-43f1-9079-f9be2e40f851",
        "parentId" : null,
        "authorId" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "body" : "It seems that we don't need to do the while loop. ",
        "createdAt" : "2021-01-30T02:10:54Z",
        "updatedAt" : "2021-02-02T05:06:53Z",
        "lastEditedBy" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "tags" : [
        ]
      },
      {
        "id" : "e460fea9-436d-4c05-8b41-9611e41340fe",
        "parentId" : "f2a20743-6fdf-43f1-9079-f9be2e40f851",
        "authorId" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "body" : "The while loop is needed (see above)",
        "createdAt" : "2021-02-01T18:00:41Z",
        "updatedAt" : "2021-02-02T05:06:53Z",
        "lastEditedBy" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "tags" : [
        ]
      }
    ],
    "commit" : "42a34b3b008bc3b65b17d79c8e2c4dd4de9b4f95",
    "line" : 247,
    "diffHunk" : "@@ -1,1 +245,249 @@                 */\n                Iterator<Snapshot> iterator = snapshotRegistry.iterator(snapshot);\n                while (iterator.hasNext()) {\n                    Snapshot curSnapshot = iterator.next();\n                    HashTier<T> tier = curSnapshot.getDelta(SnapshottableHashTable.this);"
  },
  {
    "id" : "b3fd07dc-6eb0-4654-85b2-d155eea7fb86",
    "prId" : 9901,
    "prUrl" : "https://github.com/apache/kafka/pull/9901#pullrequestreview-580621793",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "761386ec-3311-4a53-a2d4-a7ff743ad47e",
        "parentId" : null,
        "authorId" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "body" : "It seems that we don't need to do the while loop. ",
        "createdAt" : "2021-01-30T02:11:52Z",
        "updatedAt" : "2021-02-02T05:06:53Z",
        "lastEditedBy" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "tags" : [
        ]
      },
      {
        "id" : "1bbb9428-3709-446f-8b84-437f775fb5d3",
        "parentId" : "761386ec-3311-4a53-a2d4-a7ff743ad47e",
        "authorId" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "body" : "same",
        "createdAt" : "2021-02-01T18:00:50Z",
        "updatedAt" : "2021-02-02T05:06:53Z",
        "lastEditedBy" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "tags" : [
        ]
      }
    ],
    "commit" : "42a34b3b008bc3b65b17d79c8e2c4dd4de9b4f95",
    "line" : 290,
    "diffHunk" : "@@ -1,1 +288,292 @@        } else {\n            Iterator<Snapshot> iterator = snapshotRegistry.iterator(epoch);\n            while (iterator.hasNext()) {\n                Snapshot snapshot = iterator.next();\n                HashTier<T> tier = snapshot.getDelta(SnapshottableHashTable.this);"
  },
  {
    "id" : "3b86b645-9a7a-4ec6-98b2-39003a3430b1",
    "prId" : 9901,
    "prUrl" : "https://github.com/apache/kafka/pull/9901#pullrequestreview-580622305",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1253751d-9371-4dfe-9eb5-75eb9e91c369",
        "parentId" : null,
        "authorId" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "body" : "Perhaps we could have a reverseIterator taking a starting snapshot similar to the forward iterator.",
        "createdAt" : "2021-01-30T02:18:08Z",
        "updatedAt" : "2021-02-02T05:06:53Z",
        "lastEditedBy" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "tags" : [
        ]
      },
      {
        "id" : "f28c30c5-a4af-4d72-80e8-be20b47a66fc",
        "parentId" : "1253751d-9371-4dfe-9eb5-75eb9e91c369",
        "authorId" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "body" : "In this case we actually just want the very latest snapshot, so we don't need a starting position",
        "createdAt" : "2021-02-01T18:01:29Z",
        "updatedAt" : "2021-02-02T05:06:53Z",
        "lastEditedBy" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "tags" : [
        ]
      }
    ],
    "commit" : "42a34b3b008bc3b65b17d79c8e2c4dd4de9b4f95",
    "line" : 374,
    "diffHunk" : "@@ -1,1 +372,376 @@\n    private void updateTierData(T prev, int prevSize) {\n        Iterator<Snapshot> iterator = snapshotRegistry.reverseIterator();\n        if (iterator.hasNext()) {\n            Snapshot snapshot = iterator.next();"
  },
  {
    "id" : "7cf6a824-4bf0-4546-8989-e4248148ff39",
    "prId" : 9901,
    "prUrl" : "https://github.com/apache/kafka/pull/9901#pullrequestreview-580623270",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "458c97b2-c514-4ad9-b247-829a43d5d3a6",
        "parentId" : null,
        "authorId" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "body" : "Thinking about this a bit more. It seems that if there is no new update on the hashTable since a snapshot is created, we can't get the size of the snapshot. Is that expected?",
        "createdAt" : "2021-01-30T02:23:02Z",
        "updatedAt" : "2021-02-02T05:06:53Z",
        "lastEditedBy" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "tags" : [
        ]
      },
      {
        "id" : "5003f227-16e0-454a-8c0d-0c799b9360aa",
        "parentId" : "458c97b2-c514-4ad9-b247-829a43d5d3a6",
        "authorId" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "body" : "if there have been no updates, we will just take the size of the current tier as the size of the snapshot\r\n\r\n```\r\n    int snapshottableSize(long epoch) {\r\n        if (epoch == LATEST_EPOCH) {\r\n            return baseSize();\r\n        } else {\r\n            Iterator<Snapshot> iterator = snapshotRegistry.iterator(epoch);\r\n            while (iterator.hasNext()) {\r\n                Snapshot snapshot = iterator.next();\r\n                HashTier<T> tier = snapshot.getDelta(SnapshottableHashTable.this);\r\n                if (tier != null) {\r\n                    return tier.size;\r\n                }\r\n            }\r\n            return baseSize(); <==== \r\n        }\r\n    }\r\n```",
        "createdAt" : "2021-02-01T18:02:41Z",
        "updatedAt" : "2021-02-02T05:06:53Z",
        "lastEditedBy" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "tags" : [
        ]
      }
    ],
    "commit" : "42a34b3b008bc3b65b17d79c8e2c4dd4de9b4f95",
    "line" : 367,
    "diffHunk" : "@@ -1,1 +365,369 @@            HashTier<T> tier = snapshot.getDelta(SnapshottableHashTable.this);\n            if (tier == null) {\n                tier = new HashTier<>(prevSize);\n                snapshot.setDelta(SnapshottableHashTable.this, tier);\n            }"
  },
  {
    "id" : "258b5fd4-bfe2-4819-b028-a564db85699e",
    "prId" : 9901,
    "prUrl" : "https://github.com/apache/kafka/pull/9901#pullrequestreview-580807915",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6462cac6-2f05-4ce6-84d9-bb6f111a9c37",
        "parentId" : null,
        "authorId" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "body" : "It seems that this condition should always be true. Perhaps we could add an assertion?",
        "createdAt" : "2021-02-01T18:23:07Z",
        "updatedAt" : "2021-02-02T05:06:53Z",
        "lastEditedBy" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "tags" : [
        ]
      },
      {
        "id" : "3f011f77-0f75-4ae7-a909-15b85a10cd33",
        "parentId" : "6462cac6-2f05-4ce6-84d9-bb6f111a9c37",
        "authorId" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "body" : "This may not be true.  One example of when this may happen is if we delete something that was created in epoch 50.  A snapshot in epoch 25 will not contain this item, since its start epoch was \"later in time.\"",
        "createdAt" : "2021-02-01T20:57:38Z",
        "updatedAt" : "2021-02-02T05:06:53Z",
        "lastEditedBy" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "tags" : [
        ]
      },
      {
        "id" : "2b45f016-d093-4c1f-b315-88024a71d409",
        "parentId" : "6462cac6-2f05-4ce6-84d9-bb6f111a9c37",
        "authorId" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "body" : "Good point. Perhaps we could add this as a comment?",
        "createdAt" : "2021-02-01T22:08:16Z",
        "updatedAt" : "2021-02-02T05:06:53Z",
        "lastEditedBy" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "tags" : [
        ]
      }
    ],
    "commit" : "42a34b3b008bc3b65b17d79c8e2c4dd4de9b4f95",
    "line" : 379,
    "diffHunk" : "@@ -1,1 +377,381 @@            // If the previous element was present in the most recent snapshot, add it to\n            // that snapshot's hash tier.\n            if (prev.startEpoch() <= snapshot.epoch()) {\n                HashTier<T> tier = snapshot.getDelta(SnapshottableHashTable.this);\n                if (tier == null) {"
  },
  {
    "id" : "7d1ecc8f-fb56-42c7-bc15-827f94a2e1f0",
    "prId" : 9901,
    "prUrl" : "https://github.com/apache/kafka/pull/9901#pullrequestreview-580845087",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "cdd017a8-07d2-46b6-be95-a39520d904a6",
        "parentId" : null,
        "authorId" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "body" : "It should be that the snapshot 10 tier will be null, right?",
        "createdAt" : "2021-02-01T22:06:31Z",
        "updatedAt" : "2021-02-02T05:06:53Z",
        "lastEditedBy" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "tags" : [
        ]
      },
      {
        "id" : "c1cbeae4-0622-42e4-bf89-c86111a0a3d4",
        "parentId" : "cdd017a8-07d2-46b6-be95-a39520d904a6",
        "authorId" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "body" : "oh, the assumption here was that 20 came after 10, but was a no-op for this data structure in particular (so was null)",
        "createdAt" : "2021-02-01T22:59:01Z",
        "updatedAt" : "2021-02-02T05:06:53Z",
        "lastEditedBy" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "tags" : [
        ]
      }
    ],
    "commit" : "42a34b3b008bc3b65b17d79c8e2c4dd4de9b4f95",
    "line" : 40,
    "diffHunk" : "@@ -1,1 +38,42 @@ * the time the snapshot was taken.  Note that, as an optimization, snapshot tiers will\n * be null if they don't contain anything.  So for example, if snapshot 20 of Object O\n * contains the same entries as snapshot 10 of that object, the snapshot 20 tier for\n * object O will be null.\n *"
  },
  {
    "id" : "e06ae7ed-f111-4470-9e93-26f19ff9aa88",
    "prId" : 9901,
    "prUrl" : "https://github.com/apache/kafka/pull/9901#pullrequestreview-580903101",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3b1cbeb1-b374-4d50-ae56-b753caae492d",
        "parentId" : null,
        "authorId" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "body" : "To be more precise, it's the snapshot tier's hashtable will be null, right?",
        "createdAt" : "2021-02-01T23:28:42Z",
        "updatedAt" : "2021-02-02T05:06:53Z",
        "lastEditedBy" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "tags" : [
        ]
      },
      {
        "id" : "11297484-e327-49f0-a521-b29a98a94fa8",
        "parentId" : "3b1cbeb1-b374-4d50-ae56-b753caae492d",
        "authorId" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "body" : "1. The HashTier could be null\r\n2. or the HashTier could be non-null but the deltaTable could be null\r\n3. or the HashTier could be non-null with a non-null delta table\r\n\r\nYou would end up in situation #2 if you deleted something but it was still present in a snapshot.  The HashTier would record the old size but not have any delta entries.",
        "createdAt" : "2021-02-02T01:04:19Z",
        "updatedAt" : "2021-02-02T05:06:53Z",
        "lastEditedBy" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "tags" : [
        ]
      }
    ],
    "commit" : "42a34b3b008bc3b65b17d79c8e2c4dd4de9b4f95",
    "line" : 39,
    "diffHunk" : "@@ -1,1 +37,41 @@ * Each snapshot tier contains a size and a hash table.  The size reflects the size at\n * the time the snapshot was taken.  Note that, as an optimization, snapshot tiers will\n * be null if they don't contain anything.  So for example, if snapshot 20 of Object O\n * contains the same entries as snapshot 10 of that object, the snapshot 20 tier for\n * object O will be null."
  }
]
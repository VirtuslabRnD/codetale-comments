[
  {
    "id" : "243a95d4-12d6-49cb-bc46-3eeb75cb9b2d",
    "prId" : 10030,
    "prUrl" : "https://github.com/apache/kafka/pull/10030#pullrequestreview-582862762",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2d591037-aa6d-4e72-a73f-6141e33d689e",
        "parentId" : null,
        "authorId" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "body" : "Do we need the lock here again since the caller already locks?",
        "createdAt" : "2021-02-03T18:59:40Z",
        "updatedAt" : "2021-02-04T22:44:14Z",
        "lastEditedBy" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "tags" : [
        ]
      },
      {
        "id" : "b806d08b-5a70-4ee0-a347-5008dc6dff6c",
        "parentId" : "2d591037-aa6d-4e72-a73f-6141e33d689e",
        "authorId" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "body" : "good point... we don't need to lock here, since the caller already does.",
        "createdAt" : "2021-02-03T22:30:43Z",
        "updatedAt" : "2021-02-04T22:44:14Z",
        "lastEditedBy" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "tags" : [
        ]
      }
    ],
    "commit" : "809725cd0214ebf9cc400db54750ca56177c15a3",
    "line" : 263,
    "diffHunk" : "@@ -1,1 +261,265 @@        Exception enqueue(EventContext eventContext,\n                          Function<OptionalLong, OptionalLong> deadlineNsCalculator) {\n            lock.lock();\n            try {\n                if (closingTimeNs != Long.MAX_VALUE) {"
  },
  {
    "id" : "0abbdc46-dd27-44dd-8ccb-ab45d8c27fcf",
    "prId" : 10030,
    "prUrl" : "https://github.com/apache/kafka/pull/10030#pullrequestreview-582868707",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e914e5b1-f7fb-4dfc-ae21-e01661a83f8d",
        "parentId" : null,
        "authorId" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "body" : "Is this necessary since we already have an info logging in beginShutdown().",
        "createdAt" : "2021-02-03T19:59:38Z",
        "updatedAt" : "2021-02-04T22:44:14Z",
        "lastEditedBy" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "tags" : [
        ]
      },
      {
        "id" : "7e547d09-950b-4fcb-a14f-634beb3d53ab",
        "parentId" : "e914e5b1-f7fb-4dfc-ae21-e01661a83f8d",
        "authorId" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "body" : "I think it's useful since events can still be executed after beginShutdown is called.  joining the thread is an important milestone (and won't happen if a buggy event hangs) so good to log.",
        "createdAt" : "2021-02-03T22:40:13Z",
        "updatedAt" : "2021-02-04T22:44:14Z",
        "lastEditedBy" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "tags" : [
        ]
      }
    ],
    "commit" : "809725cd0214ebf9cc400db54750ca56177c15a3",
    "line" : 424,
    "diffHunk" : "@@ -1,1 +422,426 @@        beginShutdown(\"KafkaEventQueue#close\");\n        eventHandlerThread.join();\n        log.info(\"closed event queue.\");\n    }\n}"
  },
  {
    "id" : "35ba478d-edce-4730-823b-c1df703cde41",
    "prId" : 10030,
    "prUrl" : "https://github.com/apache/kafka/pull/10030#pullrequestreview-582891776",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3ba30ec2-e8e3-4ffa-ace9-012c00f7076c",
        "parentId" : null,
        "authorId" : "4a7c311c-0954-4671-a0d2-266cb67437ad",
        "body" : "We can use `Optional<String>`.",
        "createdAt" : "2021-02-03T20:32:16Z",
        "updatedAt" : "2021-02-04T22:44:14Z",
        "lastEditedBy" : "4a7c311c-0954-4671-a0d2-266cb67437ad",
        "tags" : [
        ]
      },
      {
        "id" : "a15df7b0-96b8-4998-bc33-d42d3e3a2341",
        "parentId" : "3ba30ec2-e8e3-4ffa-ace9-012c00f7076c",
        "authorId" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "body" : "I'd rather not here.\r\n\r\nChecking strings for null seems like idiomatic Java.  Strings have always been nullable reference types.  This is different than the OptionalLong case above, where it always felt awkward checking if a numeric type was null.  At least that's my feeling.",
        "createdAt" : "2021-02-03T23:21:29Z",
        "updatedAt" : "2021-02-04T22:44:14Z",
        "lastEditedBy" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "tags" : [
        ]
      }
    ],
    "commit" : "809725cd0214ebf9cc400db54750ca56177c15a3",
    "line" : 71,
    "diffHunk" : "@@ -1,1 +69,73 @@         * The tag associated with this event.\n         */\n        private String tag;\n\n        EventContext(Event event, EventInsertionType insertionType, String tag) {"
  },
  {
    "id" : "2242b264-c9e9-4d08-a85e-02a37b794bf9",
    "prId" : 10030,
    "prUrl" : "https://github.com/apache/kafka/pull/10030#pullrequestreview-582895299",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a4e16837-4f61-4172-ae99-d55d2f535623",
        "parentId" : null,
        "authorId" : "4a7c311c-0954-4671-a0d2-266cb67437ad",
        "body" : "Hmm. Does this mean that `DEFERRED` events cannot timeout? How about making the two threshold described independently when the event is enqueued?",
        "createdAt" : "2021-02-03T21:14:57Z",
        "updatedAt" : "2021-02-04T22:44:14Z",
        "lastEditedBy" : "4a7c311c-0954-4671-a0d2-266cb67437ad",
        "tags" : [
        ]
      },
      {
        "id" : "0f7e927b-855f-45b1-b44f-cd9c237b7907",
        "parentId" : "a4e16837-4f61-4172-ae99-d55d2f535623",
        "authorId" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "body" : "> Hmm. Does this mean that DEFERRED events cannot timeout? \r\n\r\nyes\r\n\r\n> How about making the two threshold described independently when the event is enqueued?\r\n\r\nthere's no use-case for timing out deferred events.  they go to the head of the queue when their time arrives in any case.",
        "createdAt" : "2021-02-03T23:28:38Z",
        "updatedAt" : "2021-02-04T22:44:14Z",
        "lastEditedBy" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "tags" : [
        ]
      }
    ],
    "commit" : "809725cd0214ebf9cc400db54750ca56177c15a3",
    "line" : 214,
    "diffHunk" : "@@ -1,1 +212,216 @@                        EventContext eventContext = entry.getValue();\n                        if (timeoutNs <= now) {\n                            if (eventContext.insertionType == EventInsertionType.DEFERRED) {\n                                // The deferred event is ready to run.  Prepend it to the\n                                // queue.  (The value for deferred events is a schedule time"
  },
  {
    "id" : "cfaf70aa-f1b9-44e6-8686-43d4fdfab179",
    "prId" : 10030,
    "prUrl" : "https://github.com/apache/kafka/pull/10030#pullrequestreview-582904871",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ca5d49f1-f1be-495e-9b71-47f2bf064512",
        "parentId" : null,
        "authorId" : "4a7c311c-0954-4671-a0d2-266cb67437ad",
        "body" : "Hmm. This can cause an event with delay X to be schedule after an event with delay Y even if X < Y.",
        "createdAt" : "2021-02-03T21:52:54Z",
        "updatedAt" : "2021-02-04T22:44:14Z",
        "lastEditedBy" : "4a7c311c-0954-4671-a0d2-266cb67437ad",
        "tags" : [
        ]
      },
      {
        "id" : "24c6e5d4-06bf-4d5e-8dbb-26fa31650249",
        "parentId" : "ca5d49f1-f1be-495e-9b71-47f2bf064512",
        "authorId" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "body" : "I will add a line to the JavaDoc stating \"Events whose deadlines are only a few nanoseconds apart may be executed in any order\"",
        "createdAt" : "2021-02-03T23:49:36Z",
        "updatedAt" : "2021-02-04T22:44:14Z",
        "lastEditedBy" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "tags" : [
        ]
      }
    ],
    "commit" : "809725cd0214ebf9cc400db54750ca56177c15a3",
    "line" : 306,
    "diffHunk" : "@@ -1,1 +304,308 @@                    while (deadlineMap.putIfAbsent(insertNs, eventContext) != null) {\n                        insertNs++;\n                    }\n                    eventContext.deadlineNs = OptionalLong.of(insertNs);\n                    // If the new timeout is before all the existing ones, wake up the"
  },
  {
    "id" : "3b84eb42-e91c-4cd6-98c8-ff05fb74f6f9",
    "prId" : 10030,
    "prUrl" : "https://github.com/apache/kafka/pull/10030#pullrequestreview-582761314",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "226549b1-3759-4ef5-ac49-6cfa0d4c29e2",
        "parentId" : null,
        "authorId" : "4a7c311c-0954-4671-a0d2-266cb67437ad",
        "body" : "How about moving this concurrency complexity to `EventHandler` by adding a method called `EventHandler::wakeup`?",
        "createdAt" : "2021-02-03T22:25:24Z",
        "updatedAt" : "2021-02-04T22:44:14Z",
        "lastEditedBy" : "4a7c311c-0954-4671-a0d2-266cb67437ad",
        "tags" : [
        ]
      }
    ],
    "commit" : "809725cd0214ebf9cc400db54750ca56177c15a3",
    "line" : 418,
    "diffHunk" : "@@ -1,1 +416,420 @@    public void wakeup() {\n        eventHandler.wakeUp();\n    }\n\n    @Override"
  },
  {
    "id" : "0f33a76d-c5ee-48c0-8a3d-0bd60e90d2b3",
    "prId" : 10030,
    "prUrl" : "https://github.com/apache/kafka/pull/10030#pullrequestreview-583707639",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ac720e61-1f77-46ec-89be-a15057abc048",
        "parentId" : null,
        "authorId" : "4a7c311c-0954-4671-a0d2-266cb67437ad",
        "body" : "@cmccabe What do you think about splitting this functionality into two types? For example:\r\n\r\n1. `EventQueue` is a type which is responsible for ordering events given the the insertion type and deadline. This type is thread-safe but doesn't instantiate thread(s). This type exposes methods for enqueuing and dequeuing events. The dequeuing method(s) can take in a \"time\" parameter and polls to see if there is an event ready. The dequeue method(s) would need to return the difference between \"time\" and the next closest event in the queue.\r\n2. `SingleThreadEventExecutor` is a type which spawns a thread to dequeue events from the `EventQueue`, executes the `run` or `handleException` methods of the event and it is `AutoCloseable`.",
        "createdAt" : "2021-02-04T16:33:17Z",
        "updatedAt" : "2021-02-04T22:44:14Z",
        "lastEditedBy" : "4a7c311c-0954-4671-a0d2-266cb67437ad",
        "tags" : [
        ]
      },
      {
        "id" : "fea65caa-8395-41a5-90ff-24cfad9d3e08",
        "parentId" : "ac720e61-1f77-46ec-89be-a15057abc048",
        "authorId" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "body" : "That's an interesting idea, but I'm not sure I see an advantage for this use-case.  We only want a single thread here-- otherwise we would have to have locking in the controller and in the parts of the broker which use this queue.  So the potential benefit that I can see from your proposal (allowing multiple executors) doesn't really apply here.",
        "createdAt" : "2021-02-04T18:15:45Z",
        "updatedAt" : "2021-02-04T22:44:14Z",
        "lastEditedBy" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "tags" : [
        ]
      },
      {
        "id" : "3c5637fa-f490-408c-85cf-b0a8afd05779",
        "parentId" : "ac720e61-1f77-46ec-89be-a15057abc048",
        "authorId" : "4a7c311c-0954-4671-a0d2-266cb67437ad",
        "body" : "Okay. I suggested it because maybe unittests would be easier to write since the tests would have to deal with concurrency.",
        "createdAt" : "2021-02-04T18:47:09Z",
        "updatedAt" : "2021-02-04T22:44:14Z",
        "lastEditedBy" : "4a7c311c-0954-4671-a0d2-266cb67437ad",
        "tags" : [
        ]
      }
    ],
    "commit" : "809725cd0214ebf9cc400db54750ca56177c15a3",
    "line" : 37,
    "diffHunk" : "@@ -1,1 +35,39 @@\n\npublic final class KafkaEventQueue implements EventQueue {\n    /**\n     * A context object that wraps events."
  }
]
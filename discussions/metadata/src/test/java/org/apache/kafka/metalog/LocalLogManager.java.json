[
  {
    "id" : "4ac99e6d-b698-42ff-a49a-e2d117b0220e",
    "prId" : 10253,
    "prUrl" : "https://github.com/apache/kafka/pull/10253#pullrequestreview-603377088",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "94ee1259-51bb-4e84-ad62-a08f6ff9f720",
        "parentId" : null,
        "authorId" : "083f2f03-ca7e-48a1-9781-482564dfdf53",
        "body" : "Same comment for the other LocalLogManager. Hmm ðŸ¤” why do we have two of these?",
        "createdAt" : "2021-03-03T20:31:33Z",
        "updatedAt" : "2021-03-04T17:19:57Z",
        "lastEditedBy" : "083f2f03-ca7e-48a1-9781-482564dfdf53",
        "tags" : [
        ]
      },
      {
        "id" : "732d4025-4b11-46da-8ad5-19ff1deaf793",
        "parentId" : "94ee1259-51bb-4e84-ad62-a08f6ff9f720",
        "authorId" : "4a7c311c-0954-4671-a0d2-266cb67437ad",
        "body" : "Yeah. I noticed this too. Not clear if this was on purpose. I say we fix this in a future PR.",
        "createdAt" : "2021-03-03T21:40:41Z",
        "updatedAt" : "2021-03-04T17:19:57Z",
        "lastEditedBy" : "4a7c311c-0954-4671-a0d2-266cb67437ad",
        "tags" : [
        ]
      }
    ],
    "commit" : "9f5940e3a5992b7c205e84b0b74930ca24057096",
    "line" : 10,
    "diffHunk" : "@@ -1,1 +376,380 @@\n    @Override\n    public long scheduleAtomicWrite(long epoch, List<ApiMessageAndVersion> batch) {\n        return shared.tryAppend(\n            nodeId,"
  },
  {
    "id" : "0dea58ec-8017-4519-8a26-85862860ece2",
    "prId" : 10705,
    "prUrl" : "https://github.com/apache/kafka/pull/10705#pullrequestreview-661482062",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "310034d0-3ecd-4f74-a7c9-57fefa85c267",
        "parentId" : null,
        "authorId" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "body" : "It seems like the intention behind this `shutdown` API is to be non-blocking, but this implementation is not non-blocking. Maybe it would be good to add a comment about this?\r\n\r\nIn general it is not possible to do a non-blocking thread join unless you have a third thread (not the calling thread, not the thread being shut down) which can wait for the blocking thread join operation to complete and then complete a future (or whatever).\r\n\r\nThat's why there are two shutdown APIs in LocalLogManager: a non-blocking beginShutdown and a blocking close which does all that, plus the thread join. This is a pattern that I use in other places as well. I think it's more useful than returning a future from close, due to the problem I mentioned above. It could be worth considering for RaftClient in the future.",
        "createdAt" : "2021-05-17T22:45:38Z",
        "updatedAt" : "2021-05-17T22:45:38Z",
        "lastEditedBy" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "tags" : [
        ]
      }
    ],
    "commit" : "2dc57d09cb99c67a452902f07cdcec3b615a88b7",
    "line" : 263,
    "diffHunk" : "@@ -1,1 +415,419 @@     */\n    @Override\n    public CompletableFuture<Void> shutdown(int timeoutMs) {\n        CompletableFuture<Void> shutdownFuture = new CompletableFuture<>();\n        try {"
  }
]
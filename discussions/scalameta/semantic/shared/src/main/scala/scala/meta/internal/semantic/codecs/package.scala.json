[
  {
    "id" : "deb673da-82eb-4de8-ac18-3cb159a317c5",
    "prId" : 808,
    "prUrl" : "https://github.com/scalameta/scalameta/pull/808#pullrequestreview-35246207",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b94662a7-f628-4366-b847-f7884a9a7812",
        "parentId" : null,
        "authorId" : "bd90d0d4-3cfe-485f-b03d-29764e6b2eae",
        "body" : "I'm not convinced we should hardcode protobuf serialization into the `codecs` package. It's not unimaginable to think that we would want to use alternative serialization formats in the future, and that would mean that we have to move this code again. What do you think about moving this into a `protobuf` package?",
        "createdAt" : "2017-04-21T08:25:05Z",
        "updatedAt" : "2017-04-30T04:14:02Z",
        "lastEditedBy" : "bd90d0d4-3cfe-485f-b03d-29764e6b2eae",
        "tags" : [
        ]
      },
      {
        "id" : "8663a276-414e-40c3-8e28-8f6d97b3f99c",
        "parentId" : "b94662a7-f628-4366-b847-f7884a9a7812",
        "authorId" : "56d6821a-439f-4d87-aba8-a6368926dbc5",
        "body" : "Will do.",
        "createdAt" : "2017-04-27T23:14:59Z",
        "updatedAt" : "2017-04-30T04:14:02Z",
        "lastEditedBy" : "56d6821a-439f-4d87-aba8-a6368926dbc5",
        "tags" : [
        ]
      },
      {
        "id" : "9dfe2e61-1013-461b-9dc1-579801f25370",
        "parentId" : "b94662a7-f628-4366-b847-f7884a9a7812",
        "authorId" : "56d6821a-439f-4d87-aba8-a6368926dbc5",
        "body" : "We'll have to discuss #799 separately and come up with a fix in a different PR. In this pull request, I only plan to rename the package, nothing beyond that.",
        "createdAt" : "2017-04-27T23:18:02Z",
        "updatedAt" : "2017-04-30T04:14:02Z",
        "lastEditedBy" : "56d6821a-439f-4d87-aba8-a6368926dbc5",
        "tags" : [
        ]
      }
    ],
    "commit" : "ac448f5c9b3250ede75f1d0a84fb0a036943da36",
    "line" : 8,
    "diffHunk" : "@@ -1,1 +6,10 @@import scala.meta.internal.semantic.{proto => p}\n\npackage object codecs {\n  implicit class XtensionProtoSerializable[A](val a: A) extends AnyVal {\n    def toMeta[B](implicit ev: ProtoDecoder[B, A]): B = ev.fromProto(a)"
  },
  {
    "id" : "30e32b6f-868d-4a8b-9e4b-6472e6a95ff3",
    "prId" : 808,
    "prUrl" : "https://github.com/scalameta/scalameta/pull/808#pullrequestreview-35496581",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "259b01d9-a5e5-4968-a3d2-11d9c22c4436",
        "parentId" : null,
        "authorId" : "bd90d0d4-3cfe-485f-b03d-29764e6b2eae",
        "body" : "Can we move all of these nested encoders into the top-level? It's a bit difficult to follow the code for AttributedSourceCodec because there are 4 encoders defined the case body. We should try to keep each encoder/decoder as small as possible.",
        "createdAt" : "2017-04-27T08:07:08Z",
        "updatedAt" : "2017-04-30T04:14:02Z",
        "lastEditedBy" : "bd90d0d4-3cfe-485f-b03d-29764e6b2eae",
        "tags" : [
        ]
      },
      {
        "id" : "bd0024f4-4293-4a37-a123-63c755722aeb",
        "parentId" : "259b01d9-a5e5-4968-a3d2-11d9c22c4436",
        "authorId" : "56d6821a-439f-4d87-aba8-a6368926dbc5",
        "body" : "I don't think we can, because they require `path` from `m.AttributedSource` to be in scope. I learned this the hard way by implementing them at the top level first :)",
        "createdAt" : "2017-04-28T00:31:41Z",
        "updatedAt" : "2017-04-30T04:14:02Z",
        "lastEditedBy" : "56d6821a-439f-4d87-aba8-a6368926dbc5",
        "tags" : [
        ]
      },
      {
        "id" : "17417841-9168-4dc1-bb8f-a40294edb2b8",
        "parentId" : "259b01d9-a5e5-4968-a3d2-11d9c22c4436",
        "authorId" : "bd90d0d4-3cfe-485f-b03d-29764e6b2eae",
        "body" : "I don't see which one needs `path`.\r\n\r\nIf they all need a path, how about making them `def resolvedNameEncoder(path: ...): ProtoEncoder`? That would make this dependency clearer.\r\n\r\nThis is just nitpick. In general, I'm not a fan of\r\n\r\n```scala\r\ndef foo(a: A) = {\r\n  def bar ...\r\n  def kaz = ... bar ...\r\n  def banan(a: A) = ... // many more lines\r\n  banan(a)\r\n}\r\n```\r\nWhen the internal helper methods span multiple lines it gets hard to track that `foo` is implemented as a one-liner.",
        "createdAt" : "2017-04-29T10:50:29Z",
        "updatedAt" : "2017-04-30T04:14:02Z",
        "lastEditedBy" : "bd90d0d4-3cfe-485f-b03d-29764e6b2eae",
        "tags" : [
        ]
      },
      {
        "id" : "7e54ba30-0c12-4f9d-a3aa-f31a0e6ffe4d",
        "parentId" : "259b01d9-a5e5-4968-a3d2-11d9c22c4436",
        "authorId" : "bd90d0d4-3cfe-485f-b03d-29764e6b2eae",
        "body" : "Let's put this discussion on hold. I'm happy to open a followup PR showing what reorganization I'd like to make.",
        "createdAt" : "2017-04-29T11:23:47Z",
        "updatedAt" : "2017-04-30T04:14:02Z",
        "lastEditedBy" : "bd90d0d4-3cfe-485f-b03d-29764e6b2eae",
        "tags" : [
        ]
      },
      {
        "id" : "cd5c7afb-1d78-4dc2-9b0e-b7f9e8e3e4b2",
        "parentId" : "259b01d9-a5e5-4968-a3d2-11d9c22c4436",
        "authorId" : "56d6821a-439f-4d87-aba8-a6368926dbc5",
        "body" : "Allright. Thanks a lot for the input here and in general in the review!",
        "createdAt" : "2017-04-29T13:31:07Z",
        "updatedAt" : "2017-04-30T04:14:02Z",
        "lastEditedBy" : "56d6821a-439f-4d87-aba8-a6368926dbc5",
        "tags" : [
        ]
      }
    ],
    "commit" : "ac448f5c9b3250ede75f1d0a84fb0a036943da36",
    "line" : 19,
    "diffHunk" : "@@ -1,1 +17,21 @@      override def toProto(e: m.AttributedSource): p.AttributedSource = e match {\n        case m.AttributedSource(path, names, messages, denotations, sugars) =>\n          implicit val resolvedNameEncoder = new ProtoEncoder[(m.Anchor, m.Symbol), p.ResolvedName] {\n            override def toProto(e: (m.Anchor, m.Symbol)): p.ResolvedName = e match {\n              case (m.Anchor(_, start, end), symbol) =>"
  },
  {
    "id" : "e713b725-6449-45b0-8f0a-37167acda7fd",
    "prId" : 808,
    "prUrl" : "https://github.com/scalameta/scalameta/pull/808#pullrequestreview-35041260",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e6eb4211-6cca-4d53-aa70-15fa4d131bce",
        "parentId" : null,
        "authorId" : "bd90d0d4-3cfe-485f-b03d-29764e6b2eae",
        "body" : "Following discussions in https://github.com/scalameta/scalameta/issues/777 \r\n\r\nWe will need to have a a `sourceRoot: AbsolutePath` available in scope in order to turn `p.AttributedSource.path/relative_path: String` to construct an AbsolutePath.",
        "createdAt" : "2017-04-27T08:16:58Z",
        "updatedAt" : "2017-04-30T04:14:02Z",
        "lastEditedBy" : "bd90d0d4-3cfe-485f-b03d-29764e6b2eae",
        "tags" : [
        ]
      }
    ],
    "commit" : "ac448f5c9b3250ede75f1d0a84fb0a036943da36",
    "line" : 15,
    "diffHunk" : "@@ -1,1 +13,17 @@  }\n\n  implicit val AttributedSourceCodec: ProtoCodec[m.AttributedSource, p.AttributedSource] =\n    new ProtoCodec[m.AttributedSource, p.AttributedSource] {\n      override def toProto(e: m.AttributedSource): p.AttributedSource = e match {"
  },
  {
    "id" : "81a03227-1954-48bb-ae15-03f2ab2693ca",
    "prId" : 808,
    "prUrl" : "https://github.com/scalameta/scalameta/pull/808#pullrequestreview-35496625",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9b23a4cf-6674-4472-a149-507e6b07960b",
        "parentId" : null,
        "authorId" : "bd90d0d4-3cfe-485f-b03d-29764e6b2eae",
        "body" : "I think this needs to become a \r\n\r\n```scala\r\ndef DatabaseCodec(sourceRoot: AbsolutePath): ProtoCodec[m.Database, p.Database]\r\n```\r\n",
        "createdAt" : "2017-04-27T08:19:07Z",
        "updatedAt" : "2017-04-30T04:14:02Z",
        "lastEditedBy" : "bd90d0d4-3cfe-485f-b03d-29764e6b2eae",
        "tags" : [
        ]
      },
      {
        "id" : "0e2a1a1d-74c2-40fa-baaf-15299a6626ee",
        "parentId" : "9b23a4cf-6674-4472-a149-507e6b07960b",
        "authorId" : "bd90d0d4-3cfe-485f-b03d-29764e6b2eae",
        "body" : "It doesn't have to be implicit, we can construct it manually by hand since it's only used in two places.",
        "createdAt" : "2017-04-27T08:19:32Z",
        "updatedAt" : "2017-04-30T04:14:02Z",
        "lastEditedBy" : "bd90d0d4-3cfe-485f-b03d-29764e6b2eae",
        "tags" : [
        ]
      },
      {
        "id" : "e1841e2d-5bf1-4099-93bf-def80799a61f",
        "parentId" : "9b23a4cf-6674-4472-a149-507e6b07960b",
        "authorId" : "bd90d0d4-3cfe-485f-b03d-29764e6b2eae",
        "body" : "Alternatively, we could wrap all of the encoders/decoders into a class\r\n\r\n```scala\r\nclass DatabaseCodecs(sourceRoot: AbsolutePath) {\r\n  implicit val DatabaseCodec: ProtoCodec[m.Database, p.Database]\r\n}\r\n```\r\n\r\nThis would avoid having to pass around the sourceRoot between codecs. ",
        "createdAt" : "2017-04-27T08:21:00Z",
        "updatedAt" : "2017-04-30T04:14:02Z",
        "lastEditedBy" : "bd90d0d4-3cfe-485f-b03d-29764e6b2eae",
        "tags" : [
        ]
      },
      {
        "id" : "33388acf-8dad-4d33-a629-768374407710",
        "parentId" : "9b23a4cf-6674-4472-a149-507e6b07960b",
        "authorId" : "56d6821a-439f-4d87-aba8-a6368926dbc5",
        "body" : "Probably not `AbsolutePath` but `Multipath`, i.e. a sourcepath.",
        "createdAt" : "2017-04-28T00:32:24Z",
        "updatedAt" : "2017-04-30T04:14:02Z",
        "lastEditedBy" : "56d6821a-439f-4d87-aba8-a6368926dbc5",
        "tags" : [
        ]
      },
      {
        "id" : "75ec5707-8591-4e6d-afd0-b188b04dd2d4",
        "parentId" : "9b23a4cf-6674-4472-a149-507e6b07960b",
        "authorId" : "bd90d0d4-3cfe-485f-b03d-29764e6b2eae",
        "body" : "Why a multipath? The database contains relative paths\r\n\r\n```\r\nfoo/Bar.scala\r\nNames:\r\naa => _root_.a.\r\n```\r\nHow do absolutize `foo/Bar.scala` if source root can be multiple directories?\r\n\r\nBtw, what do you think about creating a `@data class Multipath(files: Seq[URI])`? I think `String.split(File.pathSeparator)/.mkstring(File.pathSeparator)` is a poor interface for something that has a clear type.",
        "createdAt" : "2017-04-29T10:54:58Z",
        "updatedAt" : "2017-04-30T04:14:02Z",
        "lastEditedBy" : "bd90d0d4-3cfe-485f-b03d-29764e6b2eae",
        "tags" : [
        ]
      },
      {
        "id" : "1919d6bc-f380-46cc-a3fc-30cf6a7b0f04",
        "parentId" : "9b23a4cf-6674-4472-a149-507e6b07960b",
        "authorId" : "56d6821a-439f-4d87-aba8-a6368926dbc5",
        "body" : "Agreed and agreed. As discussed via hangouts, I'll soon submit a follow-up commit that fixes #777 and features some additional good stuff.",
        "createdAt" : "2017-04-29T13:34:03Z",
        "updatedAt" : "2017-04-30T04:14:02Z",
        "lastEditedBy" : "56d6821a-439f-4d87-aba8-a6368926dbc5",
        "tags" : [
        ]
      }
    ],
    "commit" : "ac448f5c9b3250ede75f1d0a84fb0a036943da36",
    "line" : 91,
    "diffHunk" : "@@ -1,1 +89,93 @@    }\n\n  implicit val DatabaseCodec: ProtoCodec[m.Database, p.Database] =\n    new ProtoCodec[m.Database, p.Database] {\n      override def toProto(e: m.Database): p.Database = e match {"
  }
]
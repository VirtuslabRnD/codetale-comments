[
  {
    "id" : "457e14b2-15c9-420a-b111-68e80d74f699",
    "prId" : 1240,
    "prUrl" : "https://github.com/resilience4j/resilience4j/pull/1240#pullrequestreview-530760247",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "916ca432-b0e7-48bb-b1ff-9778d58e67bd",
        "parentId" : null,
        "authorId" : "fa4c37db-2cfa-4971-a871-52021f5b5067",
        "body" : "Please don't change state directly, but use the same approach as in `updateStateWithBackOff` https://github.com/resilience4j/resilience4j/blob/a2534c515eeb9361b755bbaab2210990f99ac123/resilience4j-ratelimiter/src/main/java/io/github/resilience4j/ratelimiter/internal/AtomicRateLimiter.java#L157",
        "createdAt" : "2020-11-14T19:48:40Z",
        "updatedAt" : "2020-11-20T21:34:23Z",
        "lastEditedBy" : "fa4c37db-2cfa-4971-a871-52021f5b5067",
        "tags" : [
        ]
      },
      {
        "id" : "d6e9cbb7-a440-4c8e-aba5-65403716b0bf",
        "parentId" : "916ca432-b0e7-48bb-b1ff-9778d58e67bd",
        "authorId" : "8e1d6d71-c760-4e24-9f7a-4e396bcda1aa",
        "body" : "I don't think that is a good idea\r\n\r\nto drain the number of permits to zero precisely in a thread safe manner I have to read the number of permits left and subtract that amount in one atomic operation\r\n\r\n`updateStateWithBackOff` doesn't do that - explain why using it would be better?",
        "createdAt" : "2020-11-14T21:46:13Z",
        "updatedAt" : "2020-11-20T21:34:23Z",
        "lastEditedBy" : "8e1d6d71-c760-4e24-9f7a-4e396bcda1aa",
        "tags" : [
        ]
      },
      {
        "id" : "9d92c0d6-f5e3-4ff1-8c57-9c5823197d58",
        "parentId" : "916ca432-b0e7-48bb-b1ff-9778d58e67bd",
        "authorId" : "fa4c37db-2cfa-4971-a871-52021f5b5067",
        "body" : "`updateStateWithBackOff` uses `compareAndSwap` operation, so it is atomic, consistent and will do completely fine.\r\n`getAndUpdate` is also fine with one exception that it will reduce throughput of contended operations on `state` for Java 8 (starting from Java 9 it is fine), for additional details, please read the doc comment on `updateStateWithBackOff` method.",
        "createdAt" : "2020-11-14T22:06:47Z",
        "updatedAt" : "2020-11-20T21:34:23Z",
        "lastEditedBy" : "fa4c37db-2cfa-4971-a871-52021f5b5067",
        "tags" : [
        ]
      },
      {
        "id" : "272da85d-37e2-4c96-8c26-ad0ab8201aba",
        "parentId" : "916ca432-b0e7-48bb-b1ff-9778d58e67bd",
        "authorId" : "8e1d6d71-c760-4e24-9f7a-4e396bcda1aa",
        "body" : "reimplemented drain using compareAndSet\r\n\r\nplease check if this impl is ok for you\r\n\r\nI also added a unit test for an drain edge case",
        "createdAt" : "2020-11-15T01:44:15Z",
        "updatedAt" : "2020-11-20T21:34:23Z",
        "lastEditedBy" : "8e1d6d71-c760-4e24-9f7a-4e396bcda1aa",
        "tags" : [
        ]
      }
    ],
    "commit" : "7d5d2c529394fa7c210b11becf74042a24841cdf",
    "line" : 40,
    "diffHunk" : "@@ -1,1 +150,154 @@\n    @Override\n    public void drainPermissions() {\n        AtomicRateLimiter.State prev;\n        AtomicRateLimiter.State next;"
  }
]
[
  {
    "id" : "a04a1ff0-1b87-423b-ab87-a01f34621859",
    "prId" : 10618,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/10618#pullrequestreview-543984971",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5ce086f5-fbca-4fe8-befc-03524db85eb9",
        "parentId" : null,
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "If we want to keep this general extractor, a more informative name like `Value` might be better.",
        "createdAt" : "2020-12-03T12:52:31Z",
        "updatedAt" : "2020-12-04T10:43:03Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "0e08e759-9cf7-4243-a89c-46800ec06073",
        "parentId" : "5ce086f5-fbca-4fe8-befc-03524db85eb9",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "I thought about that one. The issue is that it would either fragment concepts into `Expr.apply`/`Value.unapply` or we would need to duplicate some logic between `Expr` and `Value` which might lead to confusion.",
        "createdAt" : "2020-12-03T14:06:06Z",
        "updatedAt" : "2020-12-04T10:43:03Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      }
    ],
    "commit" : "664f7a4109b2bde8a14e467dd1e3063de1c06c1b",
    "line" : 25,
    "diffHunk" : "@@ -1,1 +46,50 @@   */\n  def unapply[T](x: Expr[T])(using FromExpr[T])(using Quotes): Option[T] =\n    scala.Predef.summon[FromExpr[T]].unapply(x)\n\n  /** Creates an expression that will construct a copy of this sequence"
  },
  {
    "id" : "18b786f4-0c5e-44c4-8302-72d1c133fd29",
    "prId" : 10618,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/10618#pullrequestreview-545052128",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "089a8dbd-04ff-4fcf-b62e-02e62cf6a44d",
        "parentId" : null,
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "Now we have `@targetName` feature, may be we can rename `Expr.ofSeq` to `Expr.apply`? Just to open the discussion, honestly I find `Expr.ofSeq` is more informative and easy to find.",
        "createdAt" : "2020-12-03T12:55:08Z",
        "updatedAt" : "2020-12-04T10:43:03Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "21ef4123-7f06-42ec-a241-05c9d3ecb4d1",
        "parentId" : "089a8dbd-04ff-4fcf-b62e-02e62cf6a44d",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "That won't work, the name of the method is not to distinguish the arguments but the target type. `Expr(seq)` should this return a `Expr[Seq[T]]` or a `Expr[List[T]]`? Also, `Exprs` might be a better place for it.\r\n\r\nLet's keep this for a follow-up PR.",
        "createdAt" : "2020-12-03T14:10:43Z",
        "updatedAt" : "2020-12-04T10:43:03Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      },
      {
        "id" : "7474070b-2106-434c-9392-9390c8b9e850",
        "parentId" : "089a8dbd-04ff-4fcf-b62e-02e62cf6a44d",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "Maybe we can only have `Value.apply` and `Value.unapply`. This would imply that `Expr(v)` will not work anymore.",
        "createdAt" : "2020-12-03T14:19:27Z",
        "updatedAt" : "2020-12-04T10:43:03Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      },
      {
        "id" : "6a5ead9e-888d-4007-b5dc-339c8977c865",
        "parentId" : "089a8dbd-04ff-4fcf-b62e-02e62cf6a44d",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "This part of the API clearly needs a deeper analysis. I will try it in a separate PR and we can keep this one only to remove the `Liftable`/`Unliftable`.",
        "createdAt" : "2020-12-03T14:21:22Z",
        "updatedAt" : "2020-12-04T10:43:03Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      },
      {
        "id" : "01ed10bb-0ea1-4014-a819-e981d9448822",
        "parentId" : "089a8dbd-04ff-4fcf-b62e-02e62cf6a44d",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "`Values` seems to be a much better name as it captures much better the semantics of the operation in the names. The only downside is that it would affect 99% of the macros.",
        "createdAt" : "2020-12-03T14:25:13Z",
        "updatedAt" : "2020-12-04T10:43:03Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      },
      {
        "id" : "f369d1be-8973-4e8b-b84a-45b2bbdb2c12",
        "parentId" : "089a8dbd-04ff-4fcf-b62e-02e62cf6a44d",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "> Maybe we can only have `Value.apply` and `Value.unapply`. This would imply that `Expr(v)` will not work anymore.\r\n\r\nIt seems to be `Expr(v)` is better than `Value.apply`, as we are constructing a value of `Expr[T]`. Could you please elaborate?",
        "createdAt" : "2020-12-04T11:23:10Z",
        "updatedAt" : "2020-12-04T11:23:10Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "cfae3718-c1fe-4a7c-b804-67556d86832c",
        "parentId" : "089a8dbd-04ff-4fcf-b62e-02e62cf6a44d",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "To avoid confusions we need to have `Expr.apply`/`Expr.unapply` or `Value.apply`/`Value.unapply`.\r\n\r\nWould you understand if you relate the `Some` concept if your code would be like the following?\r\n```scala\r\nSome(2) match\r\n  case Just(n) =>\r\n// or\r\nJust(2) match\r\n  case Some(n) =>\r\n```\r\n\r\nI would find it extremely confusing and would probably assume they are different concepts. Even though logically they are the dual of each other.",
        "createdAt" : "2020-12-04T12:23:48Z",
        "updatedAt" : "2020-12-04T12:23:57Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      },
      {
        "id" : "e7f55f67-da29-47d5-a9ed-1a080af44c24",
        "parentId" : "089a8dbd-04ff-4fcf-b62e-02e62cf6a44d",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "There is a difference here: for `Tree`s, we expect there are different cases correspond to different syntactic forms, but for `Option` we don't have the expectation.",
        "createdAt" : "2020-12-04T12:31:34Z",
        "updatedAt" : "2020-12-04T12:31:34Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "52ba2e9b-7719-49d7-9ab9-6013741fbb30",
        "parentId" : "089a8dbd-04ff-4fcf-b62e-02e62cf6a44d",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "That would be true for trees but here we are on the `Expr` abstraction which hides those details. In the expression world you don't distinguish `'{1}`, '{{1}}`, '{{{1}}}`, ... . Those are only differences that can be seen on `Tree`s.",
        "createdAt" : "2020-12-04T15:21:34Z",
        "updatedAt" : "2020-12-04T15:21:34Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      }
    ],
    "commit" : "664f7a4109b2bde8a14e467dd1e3063de1c06c1b",
    "line" : 33,
    "diffHunk" : "@@ -1,1 +57,61 @@   */\n  def ofSeq[T](xs: Seq[Expr[T]])(using Type[T])(using Quotes): Expr[Seq[T]] =\n    Varargs(xs)\n\n  /** Creates an expression that will construct a copy of this list"
  },
  {
    "id" : "30cb4925-304b-45e4-a6dd-f400a0890245",
    "prId" : 10442,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/10442#pullrequestreview-536447578",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c78bcca0-9533-4cb4-b9ae-5b903d87e4bd",
        "parentId" : null,
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "Rename `qctx: Quotes` to `quotes: Quotes`?  There are many such instances below.\r\n",
        "createdAt" : "2020-11-22T14:29:27Z",
        "updatedAt" : "2020-11-24T09:25:12Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "0a0f18a9-ace9-4077-9124-a52f8c1b0a74",
        "parentId" : "c78bcca0-9533-4cb4-b9ae-5b903d87e4bd",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "removed name",
        "createdAt" : "2020-11-23T12:57:43Z",
        "updatedAt" : "2020-11-24T09:25:12Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      }
    ],
    "commit" : "a12771905fc420dca01342953b737bbd4ca0230e",
    "line" : 36,
    "diffHunk" : "@@ -1,1 +211,215 @@   */\n  def summon[T](using Type[T])(using Quotes): Option[Expr[T]] = {\n    import quotes.reflect._\n    Implicits.search(TypeRepr.of[T]) match {\n      case iss: ImplicitSearchSuccess => Some(iss.tree.asExpr.asInstanceOf[Expr[T]])"
  },
  {
    "id" : "9461fa85-9c10-4c6d-9826-18495d4d4ff1",
    "prId" : 10246,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/10246#pullrequestreview-526458258",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1d05f75c-45ec-446a-987e-552d9a208f76",
        "parentId" : null,
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "From the usage, it seems to me `ExprMatch` and `TypeMatch` does not make it simpler. Do we have places where they are used as extractors?",
        "createdAt" : "2020-11-09T16:51:10Z",
        "updatedAt" : "2020-11-09T16:51:20Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "bcd779a1-e931-4528-83b7-a18bbd0682dc",
        "parentId" : "1d05f75c-45ec-446a-987e-552d9a208f76",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "This is the only place in the library where it is needed. But I plan to move this implementation out of the library and then I might not even need to have this call and could call the tree pattern matcher directly.\r\n\r\nThis is another method that should only be called from code generated by the compiler.",
        "createdAt" : "2020-11-09T16:55:11Z",
        "updatedAt" : "2020-11-09T16:55:11Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      }
    ],
    "commit" : "330cc0b7843c285177aea356130cd43cfdbb50fe",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +20,24 @@  final def matches(that: Expr[Any])(using qctx: QuoteContext): Boolean =\n    val ExprMatch = qctx.asInstanceOf[scala.internal.quoted.QuoteContextInternal].ExprMatch\n    ExprMatch.unapply[EmptyTuple, EmptyTuple](this)(using that).nonEmpty\n\n  /** Checked cast to a `quoted.Expr[U]` */"
  }
]
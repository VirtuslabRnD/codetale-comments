[
  {
    "id" : "0f239563-5d14-4df5-b8c6-0dc6f878710e",
    "prId" : 7961,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/7961#pullrequestreview-344240482",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4c107d09-7d2d-4b52-99f4-4a53ae8b8aa9",
        "parentId" : null,
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "This is too hacky. In the future, we won't have access to the `classOf[MatchCase[_, _]]`. This should probably be in the `scala.internal` interface (`CompilerInterface`).",
        "createdAt" : "2020-01-14T07:45:05Z",
        "updatedAt" : "2020-01-16T21:47:24Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      },
      {
        "id" : "e51a1ed9-079f-4b91-89a6-ef2f8cda0671",
        "parentId" : "4c107d09-7d2d-4b52-99f4-4a53ae8b8aa9",
        "authorId" : "458c389d-bdc4-40dd-8a41-33a82a521583",
        "body" : "This is interesting. Even in the tests, I had to use `Type(classOf[List[_]])` in order to get the type of `List`.\r\n\r\nActually writing `typeOf[List]` gives me `missing type parameter(s) for List`. Writing `typeOf[List[_]]` satisfies Dotty but gives me `AppliedType(List, TypeBounds(Nothing,Any))`, which is not helpful.\r\n\r\nIs this a bug or am I doing it wrong?",
        "createdAt" : "2020-01-16T21:35:15Z",
        "updatedAt" : "2020-01-16T21:47:24Z",
        "lastEditedBy" : "458c389d-bdc4-40dd-8a41-33a82a521583",
        "tags" : [
        ]
      },
      {
        "id" : "f9aadcde-75fc-4854-9e86-598b4608ed39",
        "parentId" : "4c107d09-7d2d-4b52-99f4-4a53ae8b8aa9",
        "authorId" : "458c389d-bdc4-40dd-8a41-33a82a521583",
        "body" : "(leaving is as-is for now since it makes more sense to change this and the tests at the same time once we figure out the above question)",
        "createdAt" : "2020-01-16T21:50:30Z",
        "updatedAt" : "2020-01-16T21:50:30Z",
        "lastEditedBy" : "458c389d-bdc4-40dd-8a41-33a82a521583",
        "tags" : [
        ]
      }
    ],
    "commit" : "5b75df9434a1a8a0b771279b47888cd59cceb23b",
    "line" : 52,
    "diffHunk" : "@@ -1,1 +277,281 @@  def MatchCaseType(given Context): Type = {\n    import scala.internal.MatchCase\n    Type(classOf[MatchCase[_,_]])\n  }\n"
  },
  {
    "id" : "efea006f-e680-44fd-8426-d0005c7703a7",
    "prId" : 7001,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/7001#pullrequestreview-272563325",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "33ddafb1-2f6f-4b97-a4da-28525d8f76cb",
        "parentId" : null,
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "Maybe return `Symbol` instead of `Name` --- programmers can easily get `name` from symbol.",
        "createdAt" : "2019-08-08T12:55:16Z",
        "updatedAt" : "2019-08-08T13:15:27Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "f918155f-7d0d-4feb-bab9-9c1181d79acb",
        "parentId" : "33ddafb1-2f6f-4b97-a4da-28525d8f76cb",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "The symbol is not part of the type structure. It is also more efficient to get the symbol directly with `termSymbol` rather than boxing it with the qualifier.",
        "createdAt" : "2019-08-08T13:18:17Z",
        "updatedAt" : "2019-08-08T13:18:17Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      }
    ],
    "commit" : "ddae49fe608a19d3a4fd98840017d0201f58d1ca",
    "line" : 17,
    "diffHunk" : "@@ -1,1 +89,93 @@        internal.TermRef_apply(qual, name)\n      def unapply(typeOrBounds: TypeOrBounds) given (ctx: Context): Option[(TypeOrBounds /* Type | NoPrefix */, String)] =\n        internal.matchTermRef(typeOrBounds).map(x => (x.qualifier, x.name))\n    }\n"
  },
  {
    "id" : "d818286a-7d13-4d56-a218-d8d8b01d8207",
    "prId" : 6793,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/6793#pullrequestreview-257965710",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c1440491-0d76-4984-95be-ac6a2b99424e",
        "parentId" : null,
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "Why the two neg-with-compiler tests are disabled?",
        "createdAt" : "2019-07-04T10:16:30Z",
        "updatedAt" : "2019-07-04T10:17:47Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "7f131f5e-da2f-4bdc-a2d6-4e43d68b3e9c",
        "parentId" : "c1440491-0d76-4984-95be-ac6a2b99424e",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "Those tests where testing scope extrusion detection through an euristic which happens to no work anymore. I will work on more reliable mechanism for scope extrusion detection later.",
        "createdAt" : "2019-07-04T10:33:34Z",
        "updatedAt" : "2019-07-04T10:33:34Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      }
    ],
    "commit" : "65901c5d9eee7c17f0ea4f0d2d997abcd03e9bd5",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +67,71 @@    def apply(clazz: Class[_])(implicit ctx: Context): Type = kernel.Type_apply(clazz)\n\n    object IsConstantType {\n      /** Matches any ConstantType and returns it */\n      def unapply(tpe: TypeOrBounds)(implicit ctx: Context): Option[ConstantType] ="
  }
]
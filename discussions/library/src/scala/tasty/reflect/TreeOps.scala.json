[
  {
    "id" : "9c187df7-4187-4683-a7d8-3ceed72f1b3e",
    "prId" : 7528,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/7528#pullrequestreview-318010562",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5cc5c788-a4f4-4fb1-a7dc-47a0cda16eeb",
        "parentId" : null,
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "`ImpliedMatch` needs to sync with the latest renaming.",
        "createdAt" : "2019-11-18T19:41:28Z",
        "updatedAt" : "2019-11-18T20:26:19Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      }
    ],
    "commit" : "3798b6ff97f64be290d46310128fcc630508146d",
    "line" : 706,
    "diffHunk" : "@@ -1,1 +696,700 @@  given GivenMatchOps: (self: GivenMatch) {\n    def cases(given ctx: Context): List[CaseDef] = internal.GivenMatch_cases(self)\n  }\n\n  given (given Context): IsInstanceOf[Try] = internal.isInstanceOfTry"
  },
  {
    "id" : "efb1ddf6-d073-438d-8bf4-6387697d44da",
    "prId" : 7506,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/7506#pullrequestreview-312365825",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "298249f3-3d50-45fc-8916-fd59bae57ee5",
        "parentId" : null,
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "Same question about consistency.",
        "createdAt" : "2019-11-06T11:17:23Z",
        "updatedAt" : "2019-11-06T15:55:05Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "fda421ea-4b3d-4595-a966-bba0bb0ad077",
        "parentId" : "298249f3-3d50-45fc-8916-fd59bae57ee5",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "Same answer",
        "createdAt" : "2019-11-06T11:34:13Z",
        "updatedAt" : "2019-11-06T15:55:05Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      }
    ],
    "commit" : "845fe936a7dff6a93499c47e75102f766d23874f",
    "line" : 32,
    "diffHunk" : "@@ -1,1 +98,102 @@    def apply(symbol: Symbol, rhsFn: List[Type] => List[List[Term]] => Option[Term])(given ctx: Context): DefDef =\n      internal.DefDef_apply(symbol, rhsFn)\n    def copy(original: Tree)(name: String, typeParams: List[TypeDef], paramss: List[List[ValDef]], tpt: TypeTree, rhs: Option[Term])(given ctx: Context): DefDef =\n      internal.DefDef_copy(original)(name, typeParams, paramss, tpt, rhs)\n    def unapply(tree: Tree)(given ctx: Context): Option[(String, List[TypeDef], List[List[ValDef]], TypeTree, Option[Term])] ="
  },
  {
    "id" : "622005c1-e52a-43f6-ad4f-de72508d3f1c",
    "prId" : 5796,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/5796#pullrequestreview-205633500",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "37643eeb-ea71-41f6-b662-3d81457d684f",
        "parentId" : null,
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "Add some documentation with the precondition that the method is not overloaded.",
        "createdAt" : "2019-02-20T08:46:28Z",
        "updatedAt" : "2019-02-20T09:17:46Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      }
    ],
    "commit" : "3b9306bd9f5fbab4f8353289bdcae090ceda3b34",
    "line" : 12,
    "diffHunk" : "@@ -1,1 +279,283 @@       *        in that case.\n       */\n      def unique(qualifier: Term, name: String)(implicit ctx: Context): Select\n\n      /** Call an overloaded method with the given type and term parameters */"
  },
  {
    "id" : "95fedee7-d76c-4430-9c71-e8187c33be11",
    "prId" : 5796,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/5796#pullrequestreview-205649511",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "99fbde3a-4f42-4066-a420-833f363a55fa",
        "parentId" : null,
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "This should probably be the `apply` as it is the default constructor.",
        "createdAt" : "2019-02-20T08:48:12Z",
        "updatedAt" : "2019-02-20T09:17:46Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      },
      {
        "id" : "1dc1eb82-d55f-4f20-8bcd-88f50629749b",
        "parentId" : "99fbde3a-4f42-4066-a420-833f363a55fa",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "Indeed, `apply` will make the syntax shorter in usage. Here, I think there is one advantage of using `overloaded`: remind meta-programmers there is always possibility of overloading, thus the arguments should be provided for overloading resolution. That saves us from documenting the method and justifying the API design.",
        "createdAt" : "2019-02-20T09:03:09Z",
        "updatedAt" : "2019-02-20T09:17:46Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "c16db387-37a4-4b9f-ad42-eb7aedbfadc5",
        "parentId" : "99fbde3a-4f42-4066-a420-833f363a55fa",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "Another thought is that we may reserve `apply` for selection with a symbol.",
        "createdAt" : "2019-02-20T09:22:54Z",
        "updatedAt" : "2019-02-20T09:23:04Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      }
    ],
    "commit" : "3b9306bd9f5fbab4f8353289bdcae090ceda3b34",
    "line" : 15,
    "diffHunk" : "@@ -1,1 +282,286 @@\n      /** Call an overloaded method with the given type and term parameters */\n      def overloaded(qualifier: Term, name: String, targs: List[Type], args: List[Term])(implicit ctx: Context): Apply\n\n      def copy(original: Tree)(qualifier: Term, name: String)(implicit ctx: Context): Select"
  },
  {
    "id" : "814ae2ed-ca68-4ecb-980e-579f59949083",
    "prId" : 5438,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/5438#pullrequestreview-185990613",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "38df01a6-d1ff-438a-869a-6f08f128e1db",
        "parentId" : null,
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "Do we have API to create symbols in order to use this constructor? The same for `ValDef`.",
        "createdAt" : "2018-12-18T08:57:22Z",
        "updatedAt" : "2018-12-18T09:09:49Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "bbdf2bd5-ba3e-4ab2-9b40-c45e6f726785",
        "parentId" : "38df01a6-d1ff-438a-869a-6f08f128e1db",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "No. Needs to be added.",
        "createdAt" : "2018-12-18T10:08:38Z",
        "updatedAt" : "2018-12-18T10:08:38Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      }
    ],
    "commit" : "5419a4c3914c08378e25dd46bcc692ed32566b64",
    "line" : 54,
    "diffHunk" : "@@ -1,1 +132,136 @@  val DefDef: DefDefModule\n  abstract class DefDefModule {\n    def apply(symbol: DefSymbol, rhsFn: List[Type] => List[List[Term]] => Option[Term])(implicit ctx: Context): DefDef\n    def copy(original: DefDef)(name: String, typeParams: List[TypeDef], paramss: List[List[ValDef]], tpt: TypeTree, rhs: Option[Term])(implicit ctx: Context): DefDef\n    def unapply(tree: Tree)(implicit ctx: Context): Option[(String, List[TypeDef],  List[List[ValDef]], TypeTree, Option[Term])]"
  },
  {
    "id" : "c551a073-f36d-4e9e-90d9-7b54f81c4a9a",
    "prId" : 5438,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/5438#pullrequestreview-185958100",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8f160ebc-21ad-4fc3-916a-43f08dde1ed7",
        "parentId" : null,
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "For later: some documentation is needed to specify what is going to happen if `name` is overloaded.",
        "createdAt" : "2018-12-18T08:59:03Z",
        "updatedAt" : "2018-12-18T09:09:49Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      }
    ],
    "commit" : "5419a4c3914c08378e25dd46bcc692ed32566b64",
    "line" : 110,
    "diffHunk" : "@@ -1,1 +274,278 @@      // TODO def apply(qualifier: Term, name: String, signature: Option[Signature])(implicit ctx: Context): Select\n\n      def copy(original: Tree)(qualifier: Term, name: String)(implicit ctx: Context): Select\n\n      /** Matches `<qual: Term>.<name: String>` */"
  },
  {
    "id" : "3d2c2964-4630-4822-8c70-b6c0e2198595",
    "prId" : 4968,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/4968#pullrequestreview-160698151",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6ba2f22b-5121-4308-bc77-0a308d836b52",
        "parentId" : null,
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "If I understand correctly, `Parent` is the type of the tree in the parent list. Using here, it's a little difficult to understand.",
        "createdAt" : "2018-10-02T12:25:25Z",
        "updatedAt" : "2018-10-02T12:25:35Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "df757e60-9699-4ddb-8734-5b0dc70705d3",
        "parentId" : "6ba2f22b-5121-4308-bc77-0a308d836b52",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "Yes, I will change `Parent` to `TermOrTypeTree` in another PR. When bootstrapped it will be `Term | TypeTree`.",
        "createdAt" : "2018-10-02T12:38:30Z",
        "updatedAt" : "2018-10-02T12:38:31Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      }
    ],
    "commit" : "0289c3111941f621c06c427cd541f816377c85bb",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +287,291 @@    val Inlined: InlinedExtractor\n    abstract class InlinedExtractor {\n      def unapply(tree: Tree)(implicit ctx: Context): Option[(Option[Parent], List[Definition], Term)]\n    }\n"
  }
]
[
  {
    "id" : "3c6f7e10-ca9b-45f2-8379-d79b742268d0",
    "prId" : 9948,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/9948#pullrequestreview-513804876",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bf8174d5-5297-46bb-a602-124c4f4c7957",
        "parentId" : null,
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "In the original design, the interface defines abstract methods such as `unpickle()`. Will it be more flexible to keep the original design without committing to a concrete representation in the interface?",
        "createdAt" : "2020-10-16T11:14:31Z",
        "updatedAt" : "2020-10-16T15:07:02Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "1b4f9733-443c-48ed-b3c4-4baff9d1d3ef",
        "parentId" : "bf8174d5-5297-46bb-a602-124c4f4c7957",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "We have the same flexibility with both designs. In this one we just need to add can add a `PickledQuote.unpickleV2` if we need to change the unpickling logic without breaking the old one. Though `make` is the one that will most likely evolve as it contains the byte representation logic and the hole logic.",
        "createdAt" : "2020-10-16T11:21:26Z",
        "updatedAt" : "2020-10-16T15:07:02Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      },
      {
        "id" : "46702c21-2718-42a6-9ca4-0204d67ef73e",
        "parentId" : "bf8174d5-5297-46bb-a602-124c4f4c7957",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "The old `PickledExpr` interface was guided by an attempt to have a user-facing interface for pickled quotes. But we could provide the same abstraction and internally use `PickledQuote` to achieve the same.",
        "createdAt" : "2020-10-16T11:23:35Z",
        "updatedAt" : "2020-10-16T15:07:02Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      },
      {
        "id" : "64ab2b36-dddb-4ffe-8cf9-c5db6d5912c3",
        "parentId" : "bf8174d5-5297-46bb-a602-124c4f4c7957",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "As we put the protocol methods in a single trait. What will happen if we put the methods in `CompilerInterface` similar to the original design before this PR? Will that have the same benefit?\r\n\r\n```Scala\r\ntrait CompilerInterface {\r\n  type PickledQuote\r\n  type PickledArgs\r\n  def unpickleExpr(repr: PickledQuote, args: PickledArgs): Term\r\n  def unpickleType(repr: PickledQuote, args: PickledArgs): TypeTree\r\n}\r\n```",
        "createdAt" : "2020-10-16T11:31:47Z",
        "updatedAt" : "2020-10-16T15:07:02Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "c2db02ef-30b4-4be7-bab7-e0db69a533de",
        "parentId" : "bf8174d5-5297-46bb-a602-124c4f4c7957",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "How would one create a `PickledQuote` in that design? We need to create it with some concrete class that exists in the library, but that design seems to indicate that it is not known in the library.",
        "createdAt" : "2020-10-16T11:56:06Z",
        "updatedAt" : "2020-10-16T15:07:02Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      },
      {
        "id" : "65d91888-7727-4fd0-8164-4db83b8a7c10",
        "parentId" : "bf8174d5-5297-46bb-a602-124c4f4c7957",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "An abstract constructor `pickleExpr` and `pickleType` can be defined if needed:\r\n\r\n```Scala\r\ntrait CompilerInterface {\r\n  type PickledQuote\r\n  type PickledArgs\r\n  def pickleExpr(tree: Term): PickledQuote\r\n  def pickleType(tree: TypeTree): PickledQuote\r\n  def unpickleExpr(repr: PickledQuote, args: PickledArgs): Term\r\n  def unpickleType(repr: PickledQuote, args: PickledArgs): TypeTree\r\n}\r\n```\r\n\r\nIt is just a reshuffling of the library code.",
        "createdAt" : "2020-10-16T12:15:48Z",
        "updatedAt" : "2020-10-16T15:07:02Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "292b7211-315f-4a6c-8216-83d60c02a240",
        "parentId" : "bf8174d5-5297-46bb-a602-124c4f4c7957",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "That does not help. You would need a `Term` to create a `PickledQuote` and a `PickledQuote` to create `Term`. \r\nWe need a way to create one from a serialized version that is encoded in the code of the app, which implies that one needs to use abstractions that are defined in the library.\r\n\r\nHaving a `pickleExpr` may be useful in other use-cases. For example, serializing a closed expression and sending it to another machine for it to execute. This should probably be implemented in staging only though.",
        "createdAt" : "2020-10-16T13:16:56Z",
        "updatedAt" : "2020-10-16T15:07:02Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      },
      {
        "id" : "87ef9cf9-73da-420e-bff9-e5557ece0b43",
        "parentId" : "bf8174d5-5297-46bb-a602-124c4f4c7957",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "> We need a way to create one from a serialized version that is encoded in the code of the app, which implies that one needs to use abstractions that are defined in the library.\r\n\r\nMaybe I miss something here. Isn't reflect interface already in the library? It's just a reshuffling of the library.\r\n",
        "createdAt" : "2020-10-16T13:22:33Z",
        "updatedAt" : "2020-10-16T15:07:02Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "ce7c3566-cb5c-4de7-9f35-61a294d7f879",
        "parentId" : "bf8174d5-5297-46bb-a602-124c4f4c7957",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "The thing is that the implementation of the contents of `PickledQuote` for reified quotes must be implemented in the app (or library). The compiler cannot implement them in the implementation of the `CompilerInterface` it must generate a new implementation for each quote in the source.",
        "createdAt" : "2020-10-16T13:30:43Z",
        "updatedAt" : "2020-10-16T15:07:02Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      },
      {
        "id" : "1079f0d2-ba29-4ec4-b8e1-04da52af502f",
        "parentId" : "bf8174d5-5297-46bb-a602-124c4f4c7957",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "It seems to me that it is not a problem. Because at the place where the user code plays with quotes, there is a `refl: CompilerInterface` instance in scope, which has all the functionality.",
        "createdAt" : "2020-10-16T14:01:04Z",
        "updatedAt" : "2020-10-16T15:07:02Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "0467f30e-2e63-4b0a-975e-4ae0165a6d2f",
        "parentId" : "bf8174d5-5297-46bb-a602-124c4f4c7957",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "That is not the issue. The question is what code is generated for the pickled quote",
        "createdAt" : "2020-10-16T14:03:04Z",
        "updatedAt" : "2020-10-16T15:07:02Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      },
      {
        "id" : "c05c7cef-2ea5-474c-aedc-c50abbd2bc39",
        "parentId" : "bf8174d5-5297-46bb-a602-124c4f4c7957",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "Can the generated code be something like the following:\r\n\r\n```Scala\r\n// assume `def qctx(using ctx: QuoteContext): ctx.type = ctx` in stdlib.\r\n\r\nqctx.reflect.unpickle(\"....\", args)\r\n```",
        "createdAt" : "2020-10-16T14:16:37Z",
        "updatedAt" : "2020-10-16T15:07:02Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "9832dbb6-1f2a-4a0d-87b9-6de21597a9c2",
        "parentId" : "bf8174d5-5297-46bb-a602-124c4f4c7957",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "But that goes back to having a single representation. That is basically the current version. ",
        "createdAt" : "2020-10-16T14:48:11Z",
        "updatedAt" : "2020-10-16T15:07:02Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      },
      {
        "id" : "24bab6aa-ebbd-4905-9394-735c5c81b00a",
        "parentId" : "bf8174d5-5297-46bb-a602-124c4f4c7957",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "How do you represent/create the args?",
        "createdAt" : "2020-10-16T14:48:15Z",
        "updatedAt" : "2020-10-16T15:07:02Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      },
      {
        "id" : "cd811816-c224-49cf-9c79-844e5b74bd10",
        "parentId" : "bf8174d5-5297-46bb-a602-124c4f4c7957",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "> But that goes back to having a single representation. That is basically the current version.\r\n\r\nIt does not have to be like this. If there is a need to abstract representation detail, it suffices to introduce an abstract type.  The code example is just a reshuffling of the library code -- they are just different ways to implement abstraction.\r\n",
        "createdAt" : "2020-10-16T15:13:12Z",
        "updatedAt" : "2020-10-16T15:13:12Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "a6980f56-a349-4f32-93b0-67e03dd204d4",
        "parentId" : "bf8174d5-5297-46bb-a602-124c4f4c7957",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "> How do you represent/create the args?\r\n\r\nI might not fully understand the requirement. Will something like the following work:\r\n\r\n```Scala\r\ntrait CompilerInterface {\r\n  type PickledQuote\r\n  def unpickleExpr(repr: PickledQuote): Term\r\n  def unpickleType(repr: PickledQuote): TypeTree\r\n  def pickleTasty(pickled: List[String], seq: Seq[Seq[Any] => Any]): PickledQuote\r\n}\r\n```\r\n\r\nThe design still provides the flexibility (1) for the compiler to have different implementations of `PickledQuote`; (2) to introduce new mechanism/API to serialize to the next stage.",
        "createdAt" : "2020-10-16T15:29:39Z",
        "updatedAt" : "2020-10-16T16:20:50Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "fc77c515-4c39-48a0-9777-8eb1ca45451f",
        "parentId" : "bf8174d5-5297-46bb-a602-124c4f4c7957",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "The point is not to rely on the representation that is stated in the arguments of `pickleTasty`. This would make it less flexible. We would not be able to avoid the allocations of the seq and the lambdas. We could also not change the representation of the pickled tasty in the string. \r\n\r\nThe whole point is to be able to change the implementation of the pickled quoted without having to change the interface.",
        "createdAt" : "2020-10-16T17:41:58Z",
        "updatedAt" : "2020-10-16T17:41:59Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      },
      {
        "id" : "cb18ab41-bdd7-49ea-8f61-87dfd13c1658",
        "parentId" : "bf8174d5-5297-46bb-a602-124c4f4c7957",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "> The point is not to rely on the representation that is stated in the arguments of `pickleTasty`. This would make it less flexible. We would not be able to avoid the allocations of the seq and the lambdas. We could also not change the representation of the pickled tasty in the string.\r\n> \r\n\r\nIt seems to me it is not different in essence from defining the following method in stdlib:\r\n\r\n```Scala\r\n  def make(pickled: List[String], seq: Seq[Seq[Any /* Expr[Any] | Type[?] */] => Any]): PickledQuote = ...\r\n```\r\n\r\nIt seems it's just doing the same thing, in a zig-zag way:\r\n\r\n- If it's possible to change implementation of `make` without change the interface, then the same can be done to the implementation of `pickleTasty`\r\n- If it's possible to change the signature of `make`, then make the same change to `pickleTasty`.\r\n- If it is intended to create another `make2`, it is possible to add `pickle2`, etc. ",
        "createdAt" : "2020-10-16T18:38:42Z",
        "updatedAt" : "2020-10-16T18:38:42Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "43a75126-988a-4916-bd6a-3a832f9c50b1",
        "parentId" : "bf8174d5-5297-46bb-a602-124c4f4c7957",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "It can be done but changes would be harder. And we still need an implementation for each one of those on the library side as is the current case.",
        "createdAt" : "2020-10-17T07:33:52Z",
        "updatedAt" : "2020-10-17T07:33:52Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      },
      {
        "id" : "ecac4591-0ad9-4801-bd46-ccd57bc090bf",
        "parentId" : "bf8174d5-5297-46bb-a602-124c4f4c7957",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "@liufengyun can I merge this one? I will start working on improvements of the code generation after this. That would work as a test to see how easy it is to evolve code with this interface. We can always change it later if it does not work.",
        "createdAt" : "2020-10-21T11:46:08Z",
        "updatedAt" : "2020-10-21T11:46:08Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      },
      {
        "id" : "22876c4b-e36c-4466-8303-7511e5eb749e",
        "parentId" : "bf8174d5-5297-46bb-a602-124c4f4c7957",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "Just repeat the message in the email, it seems I miss something about the following point:\r\n\r\n> And we still need an implementation for each one of those on the library side as is the current case.\r\n\r\nI think `qctx.reflect.pickTasty(...)` will remove the need to put concrete implementation in stdlib.",
        "createdAt" : "2020-10-21T11:48:37Z",
        "updatedAt" : "2020-10-21T11:48:37Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "61d237a4-1f9e-4c67-9c80-f7e45c17480d",
        "parentId" : "bf8174d5-5297-46bb-a602-124c4f4c7957",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "Indeed, it could all be implemented on the compiler. But that means that each improvement will be painfully complex in the compiler (i.e. the reason why we have not been able to improve it so far) and would have to add a new method on the interface on each change. I don't see how that would scale. The version I propose has the option of adding new static helper method if it is simpler or lets the code be generated without the CompilerInterface which is more flexible.\r\n\r\nIf we do it your way we also need to add the static helper methods as we do not have access to `pickTasty` method directly because we don't have access to the `qctx` where the transformation happens.",
        "createdAt" : "2020-10-21T12:20:10Z",
        "updatedAt" : "2020-10-21T12:20:10Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      },
      {
        "id" : "6dbbad42-03e6-49fa-bf48-1448803549c9",
        "parentId" : "bf8174d5-5297-46bb-a602-124c4f4c7957",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "> If we do it your way we also need to add the static helper methods as we do not have access to pickTasty method directly because we don't have access to the qctx where the transformation happens.\r\n\r\nThis seems to be an implementation detail, as a QuoteContext must be available in scope. Currently, in the implementation, it seems each quoted tree is associated with a `QuoteContext`, thus it's possible to get that in later compiler phases. It seems to me that polluting the API design with _accidental_ implementation details is not a good idea.\r\n\r\nBut there might be other aspects that I'm not aware of in the design. Therefore, feel free to choose whatever you think makes more sense technically.",
        "createdAt" : "2020-10-21T13:19:33Z",
        "updatedAt" : "2020-10-21T13:19:33Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "ad37e0a5-c3c5-48cd-914c-0f9382a47e7d",
        "parentId" : "bf8174d5-5297-46bb-a602-124c4f4c7957",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "This design also generated reduces the code size of each quote by putting common code in those static methods. We do not want to generate the following code (or equivalent) at each place a quote is load.\r\n\r\n```scala\r\nval qctx = quoteContextWithCompilerInterface(summon[QuoteContext])\r\nval tree = qctx.reflect.unpickleTerm(pickledQuote)\r\nnew scala.internal.quoted.Expr(tree, qctx.hashCode).asInstanceOf[Expr[T]]\r\n```",
        "createdAt" : "2020-10-21T15:08:55Z",
        "updatedAt" : "2020-10-21T15:08:56Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      },
      {
        "id" : "69195518-f622-43cf-9ea0-9e315127d5a6",
        "parentId" : "bf8174d5-5297-46bb-a602-124c4f4c7957",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "I would use this design as I can see some clear benefits for the optimization I have in mind. We can always evolve the API the way you said later if we need to do a major change.",
        "createdAt" : "2020-10-21T15:17:22Z",
        "updatedAt" : "2020-10-21T15:17:22Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      }
    ],
    "commit" : "b4c10e5b7b8abca94832f9048ce2fdf15d744bbe",
    "line" : 10,
    "diffHunk" : "@@ -1,1 +8,12 @@\n  /** Bytes of the TASTy containing the quoted expression or type */\n  def bytes(): Array[Byte]\n\n  /** Expression that will fill the hole `Hole(<idx> | <args>*)` */"
  }
]
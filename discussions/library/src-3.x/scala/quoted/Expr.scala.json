[
  {
    "id" : "8623cb73-d1e5-4939-82da-ff199d594142",
    "prId" : 6747,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/6747#pullrequestreview-254706686",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ffb4420b-aad9-4917-907b-224f43fbfa08",
        "parentId" : null,
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "It seems this can be done using `toExprList` and then use quote and splices?",
        "createdAt" : "2019-06-26T10:46:20Z",
        "updatedAt" : "2019-06-26T10:46:32Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "5a163eb8-a464-42e9-a05c-cf8f8af17fdf",
        "parentId" : "ffb4420b-aad9-4917-907b-224f43fbfa08",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "Functionally it can but it would not solve the recursion issue. But actually I could use this one to improve `toExprOfList`",
        "createdAt" : "2019-06-26T15:29:34Z",
        "updatedAt" : "2019-06-26T15:29:34Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      },
      {
        "id" : "cf699c66-ed1d-418b-a02d-a9535749b0ec",
        "parentId" : "ffb4420b-aad9-4917-907b-224f43fbfa08",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "By improve I mean not have a recursive implementation that nests all the trees creating an extremely deep tree.",
        "createdAt" : "2019-06-26T15:31:02Z",
        "updatedAt" : "2019-06-26T15:31:02Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      },
      {
        "id" : "99b8ccaa-a9cd-4e03-a69c-e65c58e75e63",
        "parentId" : "ffb4420b-aad9-4917-907b-224f43fbfa08",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "I hit a bug trying to implement it. I will leave it for another PR.",
        "createdAt" : "2019-06-26T15:43:13Z",
        "updatedAt" : "2019-06-26T15:43:13Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      }
    ],
    "commit" : "62f810bab5208410470335d76476da7677b3f8b4",
    "line" : 12,
    "diffHunk" : "@@ -1,1 +46,50 @@      Block(statements.map(_.unseal), expr.unseal).seal.asInstanceOf[Expr[T]]\n    }\n\n  }\n"
  },
  {
    "id" : "ecfd2836-171d-4333-9041-c176f1c3c163",
    "prId" : 6700,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/6700#pullrequestreview-253839103",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d2c7d640-b2d2-4acb-b6b2-f8c0c2dbbc52",
        "parentId" : null,
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "Thanks to the explanation by @nicolasstucki, now I understand `run` is double-meaning for a compiled language: it means to execute the expression, but also mean inside a specific compiler run --- `Expr[T]` may only be created for a specific compiler run.\r\n\r\nIf that is the case, it seems make sense to use path-dependent types to make `Expr[T]` depend on compiler run.",
        "createdAt" : "2019-06-25T08:15:25Z",
        "updatedAt" : "2019-06-27T15:31:10Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      }
    ],
    "commit" : "68387bbc820e260d8c136ed600d4269bdb9edecb",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +12,16 @@     */\n    @deprecated(\"Use scala.quoted.run\", \"\")\n    final def run(implicit toolbox: Toolbox): T = toolbox.run(_ => this)\n\n  }"
  },
  {
    "id" : "ca141094-976b-4e1b-a13e-509235af1fb9",
    "prId" : 6700,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/6700#pullrequestreview-254545890",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "32ce338a-8277-4415-9ac6-a4fd9c25ecf2",
        "parentId" : null,
        "authorId" : "37519144-0f9f-4b2b-85f7-34dde9be2e11",
        "body" : "Update comment",
        "createdAt" : "2019-06-26T11:22:02Z",
        "updatedAt" : "2019-06-27T15:31:10Z",
        "lastEditedBy" : "37519144-0f9f-4b2b-85f7-34dde9be2e11",
        "tags" : [
        ]
      }
    ],
    "commit" : "68387bbc820e260d8c136ed600d4269bdb9edecb",
    "line" : 26,
    "diffHunk" : "@@ -1,1 +25,29 @@      def show(implicit qctx: QuoteContext): String = qctx.show(expr, SyntaxHighlight.plain)\n\n      /** Show a source code like representation of this expression */\n      def show(syntaxHighlight: SyntaxHighlight)(implicit qctx: QuoteContext): String = qctx.show(expr, syntaxHighlight)\n"
  },
  {
    "id" : "0481fe87-ca44-461b-aaf9-fdad970c63d8",
    "prId" : 6477,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/6477#pullrequestreview-235530085",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "83977074-2e27-4179-982a-d496bb7da7ea",
        "parentId" : null,
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "IIRC `Expr[given (T1) => R]  <:< Expr[(T1) => R]`, then there is no need for this set of extension methods?",
        "createdAt" : "2019-05-09T10:00:32Z",
        "updatedAt" : "2019-05-09T10:01:17Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "5dc3c710-4f2d-4a47-85ab-02f84e9ef644",
        "parentId" : "83977074-2e27-4179-982a-d496bb7da7ea",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "Actually `given (T1) => R` is not a subtype of `(T1) => R`.\r\n\r\n`given (T1) => R` extends `Object` as documented in [Definitions.scala#L102](https://github.com/lampepfl/dotty/blob/master/compiler/src/dotty/tools/dotc/core/Definitions.scala#L102) and implemented in [Definitions.scala#L138](https://github.com/lampepfl/dotty/blob/master/compiler/src/dotty/tools/dotc/core/Definitions.scala#L138).",
        "createdAt" : "2019-05-09T11:11:07Z",
        "updatedAt" : "2019-05-09T11:11:07Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      }
    ],
    "commit" : "f6e0c312322335889d65f2821238199c208d548d",
    "line" : 168,
    "diffHunk" : "@@ -1,1 +166,170 @@     */\n    def (f: Expr[given (T1) => R]) apply[T1, R](x1: Expr[T1]): Expr[R] =\n      new Exprs.FunctionAppliedTo[R](f, Array(x1))\n\n    /** Beta-reduces the contextual function appication."
  }
]
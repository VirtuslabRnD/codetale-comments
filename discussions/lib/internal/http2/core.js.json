[
  {
    "id" : "cc7c448e-9035-4a5d-a37c-48f64b447358",
    "prId" : 36700,
    "prUrl" : "https://github.com/nodejs/node/pull/36700#pullrequestreview-561987665",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "275c6a6c-3244-43f7-af67-1ee801b10c23",
        "parentId" : null,
        "authorId" : "9a49d126-5eff-41ea-a485-76c2defdc3cc",
        "body" : "Isn't this also \"vulnerable\" to prototype pollution \"attacks,\" if we really want to consider that \"unsafe?\" I mean, one could define a getter on the `Array.prototype` that returns something \"malicious.\"\r\n\r\nI'm really not sure if all this complexity and illegibility are worth the minimal benefit.",
        "createdAt" : "2021-01-03T14:38:25Z",
        "updatedAt" : "2021-01-15T18:24:07Z",
        "lastEditedBy" : "9a49d126-5eff-41ea-a485-76c2defdc3cc",
        "tags" : [
        ]
      },
      {
        "id" : "822a5d3d-e420-48de-9c12-48d37d9ee624",
        "parentId" : "275c6a6c-3244-43f7-af67-1ee801b10c23",
        "authorId" : "df7fe02e-189e-45c5-a682-9b780fdce53e",
        "body" : "Defining a `0` property on the `Array.prototype` would have effect only on empty arrays, right? `args` here is created by the spread operator, so I think this code would actually be safe even in case of `Array.prototype` pollution.\r\n\r\n\r\n```js\r\nObject.defineProperty(Array.prototype, '0', {get(){return 9}, set(v){/* no op */}})\r\n((t, ...args)=>args[0])(1, 2, 3) === 2 // true\r\n```\r\n\r\nI don't think we are concerned about code being \"malicious\" anyway, what we are trying to achieve with the move to primordials is to allow users to monkey-patch the built-in objects (for debugging purposes, for tinkering, etc.) without having errors thrown by Node.js internals.",
        "createdAt" : "2021-01-03T15:18:02Z",
        "updatedAt" : "2021-01-15T18:24:07Z",
        "lastEditedBy" : "df7fe02e-189e-45c5-a682-9b780fdce53e",
        "tags" : [
        ]
      },
      {
        "id" : "3dd035ce-1140-4ee2-81ad-90c0075d3753",
        "parentId" : "275c6a6c-3244-43f7-af67-1ee801b10c23",
        "authorId" : "9a49d126-5eff-41ea-a485-76c2defdc3cc",
        "body" : "> so I think this code would actually be safe even in case of `Array.prototype` pollution.\r\n\r\nMight be, I am not sure.\r\n\r\n> without having errors thrown by Node.js internals.\r\n\r\nI understand the motivation, but I am not sure it's worth the cost to maintainability, readability etc.",
        "createdAt" : "2021-01-05T16:42:32Z",
        "updatedAt" : "2021-01-15T18:24:07Z",
        "lastEditedBy" : "9a49d126-5eff-41ea-a485-76c2defdc3cc",
        "tags" : [
        ]
      },
      {
        "id" : "ce00b427-2b8b-43b9-9e73-1a46be9a1f40",
        "parentId" : "275c6a6c-3244-43f7-af67-1ee801b10c23",
        "authorId" : "df7fe02e-189e-45c5-a682-9b780fdce53e",
        "body" : "To address the maintainability concern, would you prefer if we added a linter rule to forbid array destructuring assignment?",
        "createdAt" : "2021-01-05T17:29:43Z",
        "updatedAt" : "2021-01-15T18:24:07Z",
        "lastEditedBy" : "df7fe02e-189e-45c5-a682-9b780fdce53e",
        "tags" : [
        ]
      }
    ],
    "commit" : "0fd9bbbb2458c310d45e2d2b6e6c01c539d31f60",
    "line" : 86,
    "diffHunk" : "@@ -1,1 +3101,3105 @@      // TODO(mcollina): we might want to match this with what we do on\n      // the compat side.\n      const { 0: stream } = args;\n      if (stream.sentHeaders) {\n        stream.destroy(err);"
  }
]
[
  {
    "id" : "77d02ca9-504b-450f-8d33-fb8365a3fd77",
    "prId" : 1048,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "78f8532e-a32e-45c7-830b-4b6a7ffad5e9",
        "parentId" : null,
        "authorId" : "ec4d48db-e488-47ba-b17d-0da1c3b9df08",
        "body" : "why do a length check here just to check if encoding is a string in `fromString()`?\n",
        "createdAt" : "2015-03-04T02:56:07Z",
        "updatedAt" : "2015-03-05T18:45:11Z",
        "lastEditedBy" : "ec4d48db-e488-47ba-b17d-0da1c3b9df08",
        "tags" : [
        ]
      },
      {
        "id" : "22796349-428c-4f6a-bb8f-3b2bdcffbc47",
        "parentId" : "78f8532e-a32e-45c7-830b-4b6a7ffad5e9",
        "authorId" : "4224fcfe-ee22-4bd8-9ed5-4e8efd7a90bc",
        "body" : "Two reasons, one aesthetic, one technical.  Aesthetic: it matches the check at the top of the function.  Technical: an unguarded `arguments[1]` is megamorphic whereas the length check keeps the property/index lookups monomorphic.\n\nI didn't benchmark it to the death but I did look at the generated code and came to the conclusion that monomorphic is best, even with the additional property lookup.  I don't know if you have looked at the machine code for KeyedLoadIC_Megamorphic but it's pretty complex.\n",
        "createdAt" : "2015-03-04T10:38:42Z",
        "updatedAt" : "2015-03-05T18:45:11Z",
        "lastEditedBy" : "4224fcfe-ee22-4bd8-9ed5-4e8efd7a90bc",
        "tags" : [
        ]
      }
    ],
    "commit" : "4ddd6406ce1c474e1a54a5aa9b56f7554902fd10",
    "line" : 45,
    "diffHunk" : "@@ -1,1 +45,49 @@  // Slightly less common case.\n  if (typeof(arg) === 'string') {\n    fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8');\n    return;\n  }"
  },
  {
    "id" : "3800a714-941f-4533-a852-2ae067fd37b7",
    "prId" : 1048,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "526dc4f0-6717-4def-9f84-8e1872001827",
        "parentId" : null,
        "authorId" : "ec4d48db-e488-47ba-b17d-0da1c3b9df08",
        "body" : "future note, use `smalloc.hasExternal()` instead. that will allow creating Buffers from anything that has externally allocated array data.\n",
        "createdAt" : "2015-03-04T03:17:09Z",
        "updatedAt" : "2015-03-05T18:45:11Z",
        "lastEditedBy" : "ec4d48db-e488-47ba-b17d-0da1c3b9df08",
        "tags" : [
        ]
      },
      {
        "id" : "41eabe98-e411-4e13-8cfd-7752515a1cb2",
        "parentId" : "526dc4f0-6717-4def-9f84-8e1872001827",
        "authorId" : "4224fcfe-ee22-4bd8-9ed5-4e8efd7a90bc",
        "body" : "That would be an additional `if` guard, wouldn't it?  The idea here is to keep everything monomorphic (or as much as possible anyway.)\n",
        "createdAt" : "2015-03-04T10:45:29Z",
        "updatedAt" : "2015-03-05T18:45:11Z",
        "lastEditedBy" : "4224fcfe-ee22-4bd8-9ed5-4e8efd7a90bc",
        "tags" : [
        ]
      },
      {
        "id" : "2de12c07-8b15-494b-9773-fc2790e9063c",
        "parentId" : "526dc4f0-6717-4def-9f84-8e1872001827",
        "authorId" : "ec4d48db-e488-47ba-b17d-0da1c3b9df08",
        "body" : "once it reaches C++ buffers and smalloc allocations are essentially treated the same.\n",
        "createdAt" : "2015-03-04T16:59:43Z",
        "updatedAt" : "2015-03-05T18:45:11Z",
        "lastEditedBy" : "ec4d48db-e488-47ba-b17d-0da1c3b9df08",
        "tags" : [
        ]
      }
    ],
    "commit" : "4ddd6406ce1c474e1a54a5aa9b56f7554902fd10",
    "line" : 107,
    "diffHunk" : "@@ -1,1 +75,79 @@\nfunction fromObject(that, object) {\n  if (object instanceof Buffer)\n    return fromBuffer(that, object);\n"
  },
  {
    "id" : "0d7626df-cf04-4405-a1fd-24be9ac96b6f",
    "prId" : 1048,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8889ff44-dff9-468a-bd77-7dfea7b5ef0b",
        "parentId" : null,
        "authorId" : "ec4d48db-e488-47ba-b17d-0da1c3b9df08",
        "body" : "future note, it is possible to cheat for loop death and attempt a `GetIndexedPropertiesExternalArrayData()` on the array buffer, if it doesn't return `NULL` (`nullptr`?) then can use a `memcpy`.\n",
        "createdAt" : "2015-03-04T03:18:47Z",
        "updatedAt" : "2015-03-05T18:45:11Z",
        "lastEditedBy" : "ec4d48db-e488-47ba-b17d-0da1c3b9df08",
        "tags" : [
        ]
      },
      {
        "id" : "ff2ef59f-2477-4cda-bd71-497b29997b26",
        "parentId" : "8889ff44-dff9-468a-bd77-7dfea7b5ef0b",
        "authorId" : "4224fcfe-ee22-4bd8-9ed5-4e8efd7a90bc",
        "body" : "That would only work for Int8Array / Uint8Array, I think.  Other typed arrays need the `element & 255` masking for compatibility reasons (which I think is silly design mistake, but that aside.)\n\nIdle musing: the overhead of calling into C++ probably isn't worth it for small arrays.  I don't care enough about typed arrays yet to go find the crossover point, though.\n",
        "createdAt" : "2015-03-04T10:51:03Z",
        "updatedAt" : "2015-03-05T18:45:11Z",
        "lastEditedBy" : "4224fcfe-ee22-4bd8-9ed5-4e8efd7a90bc",
        "tags" : [
        ]
      }
    ],
    "commit" : "4ddd6406ce1c474e1a54a5aa9b56f7554902fd10",
    "line" : 124,
    "diffHunk" : "@@ -1,1 +85,89 @@\n  if (object.buffer instanceof ArrayBuffer)\n    return fromTypedArray(that, object);\n\n  if (object.length)"
  }
]
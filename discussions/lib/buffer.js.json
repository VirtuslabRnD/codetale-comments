[
  {
    "id" : "77d02ca9-504b-450f-8d33-fb8365a3fd77",
    "prId" : 1048,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "78f8532e-a32e-45c7-830b-4b6a7ffad5e9",
        "parentId" : null,
        "authorId" : "ec4d48db-e488-47ba-b17d-0da1c3b9df08",
        "body" : "why do a length check here just to check if encoding is a string in `fromString()`?\n",
        "createdAt" : "2015-03-04T02:56:07Z",
        "updatedAt" : "2015-03-05T18:45:11Z",
        "lastEditedBy" : "ec4d48db-e488-47ba-b17d-0da1c3b9df08",
        "tags" : [
        ]
      },
      {
        "id" : "22796349-428c-4f6a-bb8f-3b2bdcffbc47",
        "parentId" : "78f8532e-a32e-45c7-830b-4b6a7ffad5e9",
        "authorId" : "4224fcfe-ee22-4bd8-9ed5-4e8efd7a90bc",
        "body" : "Two reasons, one aesthetic, one technical.  Aesthetic: it matches the check at the top of the function.  Technical: an unguarded `arguments[1]` is megamorphic whereas the length check keeps the property/index lookups monomorphic.\n\nI didn't benchmark it to the death but I did look at the generated code and came to the conclusion that monomorphic is best, even with the additional property lookup.  I don't know if you have looked at the machine code for KeyedLoadIC_Megamorphic but it's pretty complex.\n",
        "createdAt" : "2015-03-04T10:38:42Z",
        "updatedAt" : "2015-03-05T18:45:11Z",
        "lastEditedBy" : "4224fcfe-ee22-4bd8-9ed5-4e8efd7a90bc",
        "tags" : [
        ]
      }
    ],
    "commit" : "4ddd6406ce1c474e1a54a5aa9b56f7554902fd10",
    "line" : 45,
    "diffHunk" : "@@ -1,1 +45,49 @@  // Slightly less common case.\n  if (typeof(arg) === 'string') {\n    fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8');\n    return;\n  }"
  },
  {
    "id" : "3800a714-941f-4533-a852-2ae067fd37b7",
    "prId" : 1048,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "526dc4f0-6717-4def-9f84-8e1872001827",
        "parentId" : null,
        "authorId" : "ec4d48db-e488-47ba-b17d-0da1c3b9df08",
        "body" : "future note, use `smalloc.hasExternal()` instead. that will allow creating Buffers from anything that has externally allocated array data.\n",
        "createdAt" : "2015-03-04T03:17:09Z",
        "updatedAt" : "2015-03-05T18:45:11Z",
        "lastEditedBy" : "ec4d48db-e488-47ba-b17d-0da1c3b9df08",
        "tags" : [
        ]
      },
      {
        "id" : "41eabe98-e411-4e13-8cfd-7752515a1cb2",
        "parentId" : "526dc4f0-6717-4def-9f84-8e1872001827",
        "authorId" : "4224fcfe-ee22-4bd8-9ed5-4e8efd7a90bc",
        "body" : "That would be an additional `if` guard, wouldn't it?  The idea here is to keep everything monomorphic (or as much as possible anyway.)\n",
        "createdAt" : "2015-03-04T10:45:29Z",
        "updatedAt" : "2015-03-05T18:45:11Z",
        "lastEditedBy" : "4224fcfe-ee22-4bd8-9ed5-4e8efd7a90bc",
        "tags" : [
        ]
      },
      {
        "id" : "2de12c07-8b15-494b-9773-fc2790e9063c",
        "parentId" : "526dc4f0-6717-4def-9f84-8e1872001827",
        "authorId" : "ec4d48db-e488-47ba-b17d-0da1c3b9df08",
        "body" : "once it reaches C++ buffers and smalloc allocations are essentially treated the same.\n",
        "createdAt" : "2015-03-04T16:59:43Z",
        "updatedAt" : "2015-03-05T18:45:11Z",
        "lastEditedBy" : "ec4d48db-e488-47ba-b17d-0da1c3b9df08",
        "tags" : [
        ]
      }
    ],
    "commit" : "4ddd6406ce1c474e1a54a5aa9b56f7554902fd10",
    "line" : 107,
    "diffHunk" : "@@ -1,1 +75,79 @@\nfunction fromObject(that, object) {\n  if (object instanceof Buffer)\n    return fromBuffer(that, object);\n"
  },
  {
    "id" : "0d7626df-cf04-4405-a1fd-24be9ac96b6f",
    "prId" : 1048,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8889ff44-dff9-468a-bd77-7dfea7b5ef0b",
        "parentId" : null,
        "authorId" : "ec4d48db-e488-47ba-b17d-0da1c3b9df08",
        "body" : "future note, it is possible to cheat for loop death and attempt a `GetIndexedPropertiesExternalArrayData()` on the array buffer, if it doesn't return `NULL` (`nullptr`?) then can use a `memcpy`.\n",
        "createdAt" : "2015-03-04T03:18:47Z",
        "updatedAt" : "2015-03-05T18:45:11Z",
        "lastEditedBy" : "ec4d48db-e488-47ba-b17d-0da1c3b9df08",
        "tags" : [
        ]
      },
      {
        "id" : "ff2ef59f-2477-4cda-bd71-497b29997b26",
        "parentId" : "8889ff44-dff9-468a-bd77-7dfea7b5ef0b",
        "authorId" : "4224fcfe-ee22-4bd8-9ed5-4e8efd7a90bc",
        "body" : "That would only work for Int8Array / Uint8Array, I think.  Other typed arrays need the `element & 255` masking for compatibility reasons (which I think is silly design mistake, but that aside.)\n\nIdle musing: the overhead of calling into C++ probably isn't worth it for small arrays.  I don't care enough about typed arrays yet to go find the crossover point, though.\n",
        "createdAt" : "2015-03-04T10:51:03Z",
        "updatedAt" : "2015-03-05T18:45:11Z",
        "lastEditedBy" : "4224fcfe-ee22-4bd8-9ed5-4e8efd7a90bc",
        "tags" : [
        ]
      }
    ],
    "commit" : "4ddd6406ce1c474e1a54a5aa9b56f7554902fd10",
    "line" : 124,
    "diffHunk" : "@@ -1,1 +85,89 @@\n  if (object.buffer instanceof ArrayBuffer)\n    return fromTypedArray(that, object);\n\n  if (object.length)"
  },
  {
    "id" : "47c62145-118f-4d7c-98cc-f55a92174482",
    "prId" : 2027,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1a884057-b2f9-43b3-9440-7dea4ff07511",
        "parentId" : null,
        "authorId" : "c5f34109-f61d-4540-9a67-e4a5494934e5",
        "body" : "Wouldn't it be faster to do `return slowToString.call(this, arguments[0], arguments[1], arguments[2]);`? Or maybe pass `this` as the first argument and avoid `.call()`/`.apply()` altogether?\n",
        "createdAt" : "2015-06-21T22:16:21Z",
        "updatedAt" : "2015-06-25T16:33:18Z",
        "lastEditedBy" : "c5f34109-f61d-4540-9a67-e4a5494934e5",
        "tags" : [
        ]
      },
      {
        "id" : "74ffefce-a607-4458-9334-844acc7dee68",
        "parentId" : "1a884057-b2f9-43b3-9440-7dea4ff07511",
        "authorId" : "4224fcfe-ee22-4bd8-9ed5-4e8efd7a90bc",
        "body" : "See [this comment](https://github.com/nodejs/io.js/pull/2027#discussion_r32898233).  The initial version called `slowToString(this, arguments[0], ...)` but when I ran more benchmarks, it turned out that `.apply()` is faster by about 25-30% once the optimizing compiler kicks in.\n",
        "createdAt" : "2015-06-21T22:37:52Z",
        "updatedAt" : "2015-06-25T16:33:18Z",
        "lastEditedBy" : "4224fcfe-ee22-4bd8-9ed5-4e8efd7a90bc",
        "tags" : [
        ]
      },
      {
        "id" : "0c33a7db-9835-4181-ae86-088dee964a83",
        "parentId" : "1a884057-b2f9-43b3-9440-7dea4ff07511",
        "authorId" : "4bb0c2a5-ae65-4a7c-b24b-faa4000cdc5b",
        "body" : "Won't `function(encoding, start, end) {` and `return slowToString.apply(this, [encoding, start, end]);` work here? There seems to be no reason to use `arguments`. Could you test that, please?\n",
        "createdAt" : "2015-06-22T02:06:12Z",
        "updatedAt" : "2015-06-25T16:33:18Z",
        "lastEditedBy" : "4bb0c2a5-ae65-4a7c-b24b-faa4000cdc5b",
        "tags" : [
        ]
      },
      {
        "id" : "2674baa9-8b17-4775-a824-3f20bfd8d758",
        "parentId" : "1a884057-b2f9-43b3-9440-7dea4ff07511",
        "authorId" : "c5f34109-f61d-4540-9a67-e4a5494934e5",
        "body" : "Why create a new array every time when there is already `arguments`?\n",
        "createdAt" : "2015-06-22T03:01:44Z",
        "updatedAt" : "2015-06-25T16:33:18Z",
        "lastEditedBy" : "c5f34109-f61d-4540-9a67-e4a5494934e5",
        "tags" : [
        ]
      },
      {
        "id" : "f4aa26f3-9c51-4527-ba6d-d7ce5bec83f1",
        "parentId" : "1a884057-b2f9-43b3-9440-7dea4ff07511",
        "authorId" : "4bb0c2a5-ae65-4a7c-b24b-faa4000cdc5b",
        "body" : "Ok, true, an array is slow.\n\nIn my local microbenchmark `function(encoding, start, end) {` and `return .call(this, encoding, start, end)` wins for all number of arguments (except three, where `.apply(this, arguments)` is as fast).\n\nThe problem with `return slowToString.call(this, arguments[0], arguments[1], arguments[2]);` is in `arguments`, not in `.call()`.\n",
        "createdAt" : "2015-06-22T04:11:50Z",
        "updatedAt" : "2015-06-25T16:33:18Z",
        "lastEditedBy" : "4bb0c2a5-ae65-4a7c-b24b-faa4000cdc5b",
        "tags" : [
        ]
      },
      {
        "id" : "35ddca39-b181-4a5c-bd46-d83d89acd8e8",
        "parentId" : "1a884057-b2f9-43b3-9440-7dea4ff07511",
        "authorId" : "ec4d48db-e488-47ba-b17d-0da1c3b9df08",
        "body" : "@mraleph gave a talk explaining that V8 optimizes when `arguments` is passed to `.apply()`. It won't materialize the `arguments` object in this case, and is the fastest of the alternatives.\n",
        "createdAt" : "2015-06-22T17:18:28Z",
        "updatedAt" : "2015-06-25T16:33:18Z",
        "lastEditedBy" : "ec4d48db-e488-47ba-b17d-0da1c3b9df08",
        "tags" : [
        ]
      },
      {
        "id" : "265d71e1-b228-417e-9f88-7da7860c121b",
        "parentId" : "1a884057-b2f9-43b3-9440-7dea4ff07511",
        "authorId" : "4bb0c2a5-ae65-4a7c-b24b-faa4000cdc5b",
        "body" : "Could you provide a testcase in which `.call(this, encoding, start, end)` is slower?\nAnd if it's not slower — it doesn't even have to be faster, as it's more readable — the function has a correct header that way.\n",
        "createdAt" : "2015-06-22T18:12:02Z",
        "updatedAt" : "2015-06-25T16:33:18Z",
        "lastEditedBy" : "4bb0c2a5-ae65-4a7c-b24b-faa4000cdc5b",
        "tags" : [
        ]
      },
      {
        "id" : "da3a39e0-3538-4c3e-8cb4-4d634fe4f42e",
        "parentId" : "1a884057-b2f9-43b3-9440-7dea4ff07511",
        "authorId" : "ec4d48db-e488-47ba-b17d-0da1c3b9df08",
        "body" : "Hm. Can't get my test to perform accurately. Seems the true performance hit is using undefined `arguments[N]` values. Welp, seems we have some cleaning up to do in places like: https://github.com/nodejs/io.js/blob/v2.3.0/src/node.js#L339-L350\n",
        "createdAt" : "2015-06-22T18:46:34Z",
        "updatedAt" : "2015-06-25T16:33:18Z",
        "lastEditedBy" : "ec4d48db-e488-47ba-b17d-0da1c3b9df08",
        "tags" : [
        ]
      },
      {
        "id" : "6affe81b-b08f-40f9-8df3-1152ae161523",
        "parentId" : "1a884057-b2f9-43b3-9440-7dea4ff07511",
        "authorId" : "c5f34109-f61d-4540-9a67-e4a5494934e5",
        "body" : "@trevnorris What do you mean cleaning up that particular section of code? That code is switching the arguments length and only passing that many arguments.\n\nFWIW I already benchmarked various alternative function calling methods for this patch on top of the next branch (v8 4.3):\n\nReplacing `apply()` with `.call(this, arguments[0], arguments[1], ...)` slows down the cases when there are arguments passed, and there is a slight performance hit in the zero argument case (with apply I saw ~510% increase, but call showed ~470%).\n\nReplacing `apply()` with a direct function call, passing in the context as an extra argument performs about the same as using `.call()`.\n\nReplacing `apply()` with a switch on `arguments.length` and using either `.call()` or passing the context in the < 3 cases (using `.apply()` as default), the zero argument case is a bit lower IIRC (~470% increase), but now the non-zero argument cases are no longer affected.\n\nSo just using `.apply()` instead of several-line switch is shorter and even a tad faster on the zero argument case. I haven't tested these scenarios on the master branch (v8 4.2) though.\n",
        "createdAt" : "2015-06-23T16:57:37Z",
        "updatedAt" : "2015-06-25T16:33:18Z",
        "lastEditedBy" : "c5f34109-f61d-4540-9a67-e4a5494934e5",
        "tags" : [
        ]
      },
      {
        "id" : "764f6566-2fd6-4b30-b740-1c0758845b03",
        "parentId" : "1a884057-b2f9-43b3-9440-7dea4ff07511",
        "authorId" : "ec4d48db-e488-47ba-b17d-0da1c3b9df08",
        "body" : "@mscdex Is `args` there an `arguments` object or an `Array`? I'm aware that referencing undefined values on an `arguments` object does have significant overhead, but my benchmarks show that that is not the case for a real array.\n",
        "createdAt" : "2015-06-23T20:19:50Z",
        "updatedAt" : "2015-06-25T16:33:18Z",
        "lastEditedBy" : "ec4d48db-e488-47ba-b17d-0da1c3b9df08",
        "tags" : [
        ]
      },
      {
        "id" : "b02290d5-21ac-4b8a-b30d-b6b4b4869a81",
        "parentId" : "1a884057-b2f9-43b3-9440-7dea4ff07511",
        "authorId" : "c5f34109-f61d-4540-9a67-e4a5494934e5",
        "body" : "@trevnorris I did not test with an array, just `arguments`.\n",
        "createdAt" : "2015-06-23T23:13:56Z",
        "updatedAt" : "2015-06-25T16:33:18Z",
        "lastEditedBy" : "c5f34109-f61d-4540-9a67-e4a5494934e5",
        "tags" : [
        ]
      },
      {
        "id" : "1c7fecd7-3829-44a4-8365-da71a19539f1",
        "parentId" : "1a884057-b2f9-43b3-9440-7dea4ff07511",
        "authorId" : "ec4d48db-e488-47ba-b17d-0da1c3b9df08",
        "body" : "@mscdex neither had I before this PR. Some testing showed that referencing undefined members in an array doesn't have any performance impact. Only side effect is the argument length being too long on the called function.\n",
        "createdAt" : "2015-06-25T15:56:53Z",
        "updatedAt" : "2015-06-25T16:33:18Z",
        "lastEditedBy" : "ec4d48db-e488-47ba-b17d-0da1c3b9df08",
        "tags" : [
        ]
      }
    ],
    "commit" : "8350f3a3a291fcd19df3261c3db3fe07c7590bb7",
    "line" : 23,
    "diffHunk" : "@@ -1,1 +385,389 @@  if (arguments.length === 0)\n    return this.utf8Slice(0, length);\n  return slowToString.apply(this, arguments);\n};\n"
  },
  {
    "id" : "7a9766ff-4c3f-428e-a305-ffe4fd070e34",
    "prId" : 2027,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6e67ac5e-2dbe-4b07-986a-5c0a653c28fb",
        "parentId" : null,
        "authorId" : "c5f34109-f61d-4540-9a67-e4a5494934e5",
        "body" : "Semicolon can be removed here\n",
        "createdAt" : "2015-06-21T22:34:47Z",
        "updatedAt" : "2015-06-25T16:33:18Z",
        "lastEditedBy" : "c5f34109-f61d-4540-9a67-e4a5494934e5",
        "tags" : [
        ]
      },
      {
        "id" : "525d2ddb-671f-4883-ab1e-06bf4c9f5494",
        "parentId" : "6e67ac5e-2dbe-4b07-986a-5c0a653c28fb",
        "authorId" : "18a0a2b7-cb40-4ae7-b110-7ab494225c65",
        "body" : "I'll look into enabling linter rules for these.\n",
        "createdAt" : "2015-06-25T10:46:15Z",
        "updatedAt" : "2015-06-25T16:33:18Z",
        "lastEditedBy" : "18a0a2b7-cb40-4ae7-b110-7ab494225c65",
        "tags" : [
        ]
      },
      {
        "id" : "32f44a91-854e-4e86-9199-597ec0bfeb9a",
        "parentId" : "6e67ac5e-2dbe-4b07-986a-5c0a653c28fb",
        "authorId" : "ec4d48db-e488-47ba-b17d-0da1c3b9df08",
        "body" : "Good catch, but not related to or being touched by this PR. Generally we just leave these alone. After the lint rules are enabled a cleanup commit even if it's just this one, would be preferable.\n",
        "createdAt" : "2015-06-25T15:59:01Z",
        "updatedAt" : "2015-06-25T16:33:18Z",
        "lastEditedBy" : "ec4d48db-e488-47ba-b17d-0da1c3b9df08",
        "tags" : [
        ]
      },
      {
        "id" : "f98c6430-c8c0-40bc-ad50-fa0353a7aa79",
        "parentId" : "6e67ac5e-2dbe-4b07-986a-5c0a653c28fb",
        "authorId" : "4224fcfe-ee22-4bd8-9ed5-4e8efd7a90bc",
        "body" : "FWIW, I included the style fix in the final commit.  It didn't make the diff any noisier.\n",
        "createdAt" : "2015-06-25T16:35:10Z",
        "updatedAt" : "2015-06-25T16:35:10Z",
        "lastEditedBy" : "4224fcfe-ee22-4bd8-9ed5-4e8efd7a90bc",
        "tags" : [
        ]
      }
    ],
    "commit" : "8350f3a3a291fcd19df3261c3db3fe07c7590bb7",
    "line" : 24,
    "diffHunk" : "@@ -1,1 +386,390 @@    return this.utf8Slice(0, length);\n  return slowToString.apply(this, arguments);\n};\n\n"
  }
]
[
  {
    "id" : "62f6bb41-a9f0-43cc-aa92-f475fafb5a05",
    "prId" : 27175,
    "prUrl" : "https://github.com/ansible/ansible/pull/27175#pullrequestreview-69336922",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b0527694-99e3-4fdd-8dcb-64d155ae29c6",
        "parentId" : null,
        "authorId" : "fa0144fc-7424-474a-9ab5-059de28814b7",
        "body" : "I suspect this might break more esoteric uses of callbacks (if something is relying on the original reference...).\r\nBut I think that is ok since that isnt really something we can (or should) guarantee. ",
        "createdAt" : "2017-10-13T19:42:44Z",
        "updatedAt" : "2017-10-13T20:06:56Z",
        "lastEditedBy" : "fa0144fc-7424-474a-9ab5-059de28814b7",
        "tags" : [
        ]
      },
      {
        "id" : "c6f60bc5-d1cc-4ce9-a77d-f5c1dad45867",
        "parentId" : "b0527694-99e3-4fdd-8dcb-64d155ae29c6",
        "authorId" : "30fc1801-f8f1-4cc4-9690-e31e203f4f6d",
        "body" : "callbacks should not be manipulating the 'live objects', it can create issues and alter play flow in 'magical' ways the user would not understand/see/be able to audit. \r\n\r\nIn any case we are moving this here to avoid doing it in the callback itself should not worry about security nor disclosures.",
        "createdAt" : "2017-10-13T20:06:07Z",
        "updatedAt" : "2017-10-13T20:06:56Z",
        "lastEditedBy" : "30fc1801-f8f1-4cc4-9690-e31e203f4f6d",
        "tags" : [
        ]
      }
    ],
    "commit" : "c3a27df958a5cb7ae74313b5cc6450bf1e49c38a",
    "line" : 17,
    "diffHunk" : "@@ -1,1 +378,382 @@                # FIXME: add play/task cleaners\n                if isinstance(arg, TaskResult):\n                    new_args.append(arg.clean_copy())\n                # elif isinstance(arg, Play):\n                # elif isinstance(arg, Task):"
  },
  {
    "id" : "1b60db10-c85c-424f-a522-d219136f97a3",
    "prId" : 59932,
    "prUrl" : "https://github.com/ansible/ansible/pull/59932#pullrequestreview-508315269",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d144f5d3-994d-47f0-ba92-03ba47bccff6",
        "parentId" : null,
        "authorId" : "311820dd-fcb9-46df-a201-9c0e7d6fac58",
        "body" : "Argh, I just realized the PluginLoader attribute stuffing (update_object) has been happening on `class_only` cases, which is broken for \"same name, different behavior\" cases (since subsequent loads will overwrite the class vars on the existing type object, not instance vars). It works here, since `all` is `yield`ing the plugin class immediately after calling `update_object` on it, but the whole pattern is busted for `class_only`, esp for things that might consult the class var during or after `__init__`. We've needed to rethink that for awhile, and this kinda sets it in a little more concrete. :(",
        "createdAt" : "2020-10-13T22:13:47Z",
        "updatedAt" : "2020-10-15T13:11:47Z",
        "lastEditedBy" : "311820dd-fcb9-46df-a201-9c0e7d6fac58",
        "tags" : [
        ]
      },
      {
        "id" : "0a9b75e3-abdd-49aa-bb5f-d11b7e68133a",
        "parentId" : "d144f5d3-994d-47f0-ba92-03ba47bccff6",
        "authorId" : "30fc1801-f8f1-4cc4-9690-e31e203f4f6d",
        "body" : "We do this for connection, shell, become, actions, callbacks, etc ... if this is a problem it affects most of our plugins. But this also was not introduced in this PR and is widespread, so i'm not going to hold off this patch based on it.",
        "createdAt" : "2020-10-14T12:57:10Z",
        "updatedAt" : "2020-10-15T13:11:47Z",
        "lastEditedBy" : "30fc1801-f8f1-4cc4-9690-e31e203f4f6d",
        "tags" : [
        ]
      }
    ],
    "commit" : "9accf8b128a427535793de094cf992e10b60df8c",
    "line" : 31,
    "diffHunk" : "@@ -1,1 +195,199 @@\n            # try to get colleciotn world name first\n            cnames = getattr(callback_plugin, '_redirected_names', [])\n            if cnames:\n                # store the name the plugin was loaded as, as that's what we'll need to compare to the configured callback list later"
  },
  {
    "id" : "38f50a4c-55b8-4a3c-915a-4069dbfcd98b",
    "prId" : 59932,
    "prUrl" : "https://github.com/ansible/ansible/pull/59932#pullrequestreview-508319919",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1d0bca1d-9daa-4e0c-96e7-ed58e27794d2",
        "parentId" : null,
        "authorId" : "311820dd-fcb9-46df-a201-9c0e7d6fac58",
        "body" : "This implies that constructing some callbacks doesn't result in an instance, but also doesn't raise an Exception? That doesn't sound right...",
        "createdAt" : "2020-10-13T22:28:00Z",
        "updatedAt" : "2020-10-15T13:11:47Z",
        "lastEditedBy" : "311820dd-fcb9-46df-a201-9c0e7d6fac58",
        "tags" : [
        ]
      },
      {
        "id" : "1e4d9f0a-0890-45b1-b356-3052d5ee4af6",
        "parentId" : "1d0bca1d-9daa-4e0c-96e7-ed58e27794d2",
        "authorId" : "30fc1801-f8f1-4cc4-9690-e31e203f4f6d",
        "body" : "IIRC this mostly affected v1 type callback plugins that could result in a `None` on load and also cases in which extraneous python files seemed to match plugins. All this I believe we already fixed in the loader, but have not confirmed. \r\n\r\nSince it is preexisting code, I didn't want to remove with this change, I suspect it is not needed anymore but I would postpone removing it to a subsequent PR.",
        "createdAt" : "2020-10-14T13:02:04Z",
        "updatedAt" : "2020-10-15T13:11:47Z",
        "lastEditedBy" : "30fc1801-f8f1-4cc4-9690-e31e203f4f6d",
        "tags" : [
        ]
      }
    ],
    "commit" : "9accf8b128a427535793de094cf992e10b60df8c",
    "line" : 73,
    "diffHunk" : "@@ -1,1 +223,227 @@                # avoid bad plugin not returning an object, only needed cause we do class_only load and bypass loader checks,\n                # really a bug in the plugin itself which we ignore as callback errors are not supposed to be fatal.\n                if callback_obj:\n                    # skip initializing if we already did the work for the same plugin (even with diff names)\n                    if callback_obj not in self._callback_plugins:"
  },
  {
    "id" : "8222fd73-f241-4bae-a510-69effff73c99",
    "prId" : 59932,
    "prUrl" : "https://github.com/ansible/ansible/pull/59932#pullrequestreview-508320660",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c614ffa7-e546-4361-9662-59573d8d78d7",
        "parentId" : null,
        "authorId" : "311820dd-fcb9-46df-a201-9c0e7d6fac58",
        "body" : "Are we doing singleton `__new__`/`__call__` magic internally on some of the callback plugin types? Seems like this would never be `False` otherwise...",
        "createdAt" : "2020-10-13T22:28:58Z",
        "updatedAt" : "2020-10-15T13:11:47Z",
        "lastEditedBy" : "311820dd-fcb9-46df-a201-9c0e7d6fac58",
        "tags" : [
        ]
      },
      {
        "id" : "0474c74a-2447-4f43-a315-fe69e869f9e4",
        "parentId" : "c614ffa7-e546-4361-9662-59573d8d78d7",
        "authorId" : "30fc1801-f8f1-4cc4-9690-e31e203f4f6d",
        "body" : "'we' are not, but several 3rd party ones are, this code was introduced to account for that (mostly just moved location in this patch).",
        "createdAt" : "2020-10-14T13:02:56Z",
        "updatedAt" : "2020-10-15T13:11:47Z",
        "lastEditedBy" : "30fc1801-f8f1-4cc4-9690-e31e203f4f6d",
        "tags" : [
        ]
      }
    ],
    "commit" : "9accf8b128a427535793de094cf992e10b60df8c",
    "line" : 82,
    "diffHunk" : "@@ -1,1 +225,229 @@                if callback_obj:\n                    # skip initializing if we already did the work for the same plugin (even with diff names)\n                    if callback_obj not in self._callback_plugins:\n                        callback_obj.set_options()\n                        self._callback_plugins.append(callback_obj)"
  }
]
[
  {
    "id" : "159f9b50-be58-46be-bacd-ba13fa43ae85",
    "prId" : 11719,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2d35e7ec-7cd0-4a33-be1b-93412d8ba08f",
        "parentId" : null,
        "authorId" : "311820dd-fcb9-46df-a201-9c0e7d6fac58",
        "body" : "Changing this to a new style module is awesome because it enables check mode on Windows modules... However, we don't yet have a corresponding Windows mechanism for modules that aren't check mode-aware to be opted-out of running in check mode. A quick n' dirty solution might be to add another comment directive like # CHECK_MODE_AWARE...\n",
        "createdAt" : "2015-07-30T16:03:35Z",
        "updatedAt" : "2015-07-30T19:55:06Z",
        "lastEditedBy" : "311820dd-fcb9-46df-a201-9c0e7d6fac58",
        "tags" : [
        ]
      },
      {
        "id" : "75ca22e8-2f7e-4d8e-9f36-5efe2f105d00",
        "parentId" : "2d35e7ec-7cd0-4a33-be1b-93412d8ba08f",
        "authorId" : "4afe6295-a052-4934-8973-b5a4ebcc7820",
        "body" : "How about the change I added [below](https://github.com/ansible/ansible/pull/11719/files#diff-9584222c646a5fc71bf7537da48741e6R141) that adds the ability for a Windows module to indicate if it supports check mode?  With this change, check mode would not be supported by any Windows modules initially (except `setup.ps1` because it doesn't call `Parse-Args`), but it would be easy to [add that flag to the modules that don't modify the remote system](https://github.com/cchurch/ansible-modules-core/commit/5544eace2be4c3e5192022a55c1dccdf70582c55).\n",
        "createdAt" : "2015-07-30T20:01:42Z",
        "updatedAt" : "2015-07-30T20:01:42Z",
        "lastEditedBy" : "4afe6295-a052-4934-8973-b5a4ebcc7820",
        "tags" : [
        ]
      },
      {
        "id" : "3e1836ce-3aa7-462e-a0ee-64ed6111b625",
        "parentId" : "2d35e7ec-7cd0-4a33-be1b-93412d8ba08f",
        "authorId" : "311820dd-fcb9-46df-a201-9c0e7d6fac58",
        "body" : "Sounds like a plan!\n",
        "createdAt" : "2015-07-30T21:46:38Z",
        "updatedAt" : "2015-07-30T21:46:38Z",
        "lastEditedBy" : "311820dd-fcb9-46df-a201-9c0e7d6fac58",
        "tags" : [
        ]
      }
    ],
    "commit" : "b07f8e7a7e113d2b55cca517aab26f6ee504e53f",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +68,72 @@        module_style = 'new'\n    elif REPLACER_WINDOWS in module_data:\n        module_style = 'new'\n    elif 'from ansible.module_utils.' in module_data:\n        module_style = 'new'"
  },
  {
    "id" : "f5c56959-fcb6-4868-a305-64667545ef81",
    "prId" : 15246,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a5f7e2a8-ace0-4c62-96d3-fc721a6149c0",
        "parentId" : null,
        "authorId" : "311820dd-fcb9-46df-a201-9c0e7d6fac58",
        "body" : "need to close the fd here (will using a 'with' on the fd break in 2.4 even if we don't execute this function?)\n",
        "createdAt" : "2016-04-02T03:48:31Z",
        "updatedAt" : "2016-04-04T21:38:37Z",
        "lastEditedBy" : "311820dd-fcb9-46df-a201-9c0e7d6fac58",
        "tags" : [
        ]
      },
      {
        "id" : "6f37993a-4017-47a4-99a7-3156775a9421",
        "parentId" : "a5f7e2a8-ace0-4c62-96d3-fc721a6149c0",
        "authorId" : "838eb58c-0fa8-4742-994f-a407c7183e57",
        "body" : "Now closed on the next line.\n",
        "createdAt" : "2016-04-02T04:47:42Z",
        "updatedAt" : "2016-04-04T21:38:37Z",
        "lastEditedBy" : "838eb58c-0fa8-4742-994f-a407c7183e57",
        "tags" : [
        ]
      },
      {
        "id" : "0caca27b-0b44-404a-b5d6-a8b8eba487fc",
        "parentId" : "a5f7e2a8-ace0-4c62-96d3-fc721a6149c0",
        "authorId" : "838eb58c-0fa8-4742-994f-a407c7183e57",
        "body" : "And yeah, with is a keyword being used in a way that couldn't be mistaken for a variable name so it will cause a syntaxerror on python-2.4.\n",
        "createdAt" : "2016-04-02T04:49:03Z",
        "updatedAt" : "2016-04-04T21:38:37Z",
        "lastEditedBy" : "838eb58c-0fa8-4742-994f-a407c7183e57",
        "tags" : [
        ]
      }
    ],
    "commit" : "586441b13e71ede57df96090b0f2a254b2396417",
    "line" : 74,
    "diffHunk" : "@@ -1,1 +90,94 @@                    os.makedirs(directory)\n                f = open(dest_filename, 'w')\n                f.write(z.read(filename))\n                f.close()\n        print('Module expanded into: %%s' %% os.path.join(basedir, 'ansible'))"
  },
  {
    "id" : "ea380e8a-5f3c-4ba1-857e-a03ba200442c",
    "prId" : 15246,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7187ea0b-d477-4c3c-8458-3fda0246d265",
        "parentId" : null,
        "authorId" : "3aa844d8-7198-43e9-9769-58058e45516c",
        "body" : "Should we be raising an Exception here, or returning some JSON/sys.exit(1) as a nice exit response?\n",
        "createdAt" : "2016-04-02T12:54:35Z",
        "updatedAt" : "2016-04-04T21:38:37Z",
        "lastEditedBy" : "3aa844d8-7198-43e9-9769-58058e45516c",
        "tags" : [
        ]
      },
      {
        "id" : "b07a2df6-4115-44e8-abfa-ac1122e475e7",
        "parentId" : "7187ea0b-d477-4c3c-8458-3fda0246d265",
        "authorId" : "838eb58c-0fa8-4742-994f-a407c7183e57",
        "body" : "We should be raising an Exception because this won't be sent back to ansible.\n\nThe debug() functionality is something I worked on with @nitzmahone last night.  We realized that it would be harder to debug modules via ANSIBLE_KEEP_REMOTE_FILES using ziploader because what you would end up keeping is this wrapper with the zipped payload in ZIPDATA.  So the debug() function contains two things to ameliorate that.  First: If you run the wrapper file with `explode` as a command line arg it will take the payload and extract it into the ansible temporary directory (where the module file was uploaded).  Second: If you run the wrapper file with `execute` as a command line arg it will run the module files that were exploded to disk rather than the zipped payload that's contained in the wrapper.\n\nThese two commands enable you to debug a module using the following steps:\n\n```\n$ ANSIBLE_KEEP_REMOTE_FILES=1 ansible localhost -m ping -a data=crash -vvv\nUsing /etc/ansible/ansible.cfg as config file\n<127.0.0.1> ESTABLISH LOCAL CONNECTION FOR USER: badger\n<127.0.0.1> EXEC /bin/sh -c '( umask 77 && mkdir -p \"` echo $HOME/.ansible/tmp/ansible-tmp-1459605113.37-203813258173\n480 `\" && echo \"` echo $HOME/.ansible/tmp/ansible-tmp-1459605113.37-203813258173480 `\" )'\n<127.0.0.1> PUT /var/tmp/tmpvdVWjY TO /home/badger/.ansible/tmp/ansible-tmp-1459605113.37-203813258173480/ping\n<127.0.0.1> EXEC /bin/sh -c 'LANG=en_US.UTF-8 LC_ALL=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 /usr/bin/python /home/badger\n/.ansible/tmp/ansible-tmp-1459605113.37-203813258173480/ping'\nAn exception occurred during task execution. The full traceback is:\n[...]\n# Log into remote machine\n$ /usr/bin/python /home/badger\n/.ansible/tmp/ansible-tmp-1459605113.37-203813258173480/ping explode\nModule expanded into: /home/badger/.ansible/tmp/ansible-tmp-1459605113.37-203813258173480/ansible\n# Edit the files in /home/badger/.ansible/tmp/ansible-tmp-1459605113.37-203813258173480/ansible to introspect what is happening as the module runs.   Change the code to see if it will still run, etc.\n$ /usr/bin/python /home/badger/.ansible/tmp/ansible-tmp-1459605113.37-203813258173480/ping execute\n# The execute command runs the exploded files instead of the zipped payload.  So it runs the module with all of the changes you made in the step above.\n```\n",
        "createdAt" : "2016-04-02T13:57:32Z",
        "updatedAt" : "2016-04-04T21:38:37Z",
        "lastEditedBy" : "838eb58c-0fa8-4742-994f-a407c7183e57",
        "tags" : [
        ]
      }
    ],
    "commit" : "586441b13e71ede57df96090b0f2a254b2396417",
    "line" : 65,
    "diffHunk" : "@@ -1,1 +81,85 @@        for filename in z.namelist():\n            if filename.startswith('/'):\n                raise Exception('Something wrong with this module zip file: should not contain absolute paths')\n            dest_filename = os.path.join(basedir, filename)\n            if dest_filename.endswith(os.path.sep) and not os.path.exists(dest_filename):"
  },
  {
    "id" : "c21033c2-061d-4e28-a7a9-9bd8e3e6a583",
    "prId" : 50163,
    "prUrl" : "https://github.com/ansible/ansible/pull/50163#pullrequestreview-190979023",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0ae2715a-5550-422a-b64f-9ccca946a55c",
        "parentId" : null,
        "authorId" : "838eb58c-0fa8-4742-994f-a407c7183e57",
        "body" : "It looks like this conditional is slightly off?  If ansible_python_interpreter is set, then it needs to use that.  But in this code, it looks like the value of DEFAULT_INTERPRETER_PYTHON causes that to be ignored.",
        "createdAt" : "2018-12-19T17:35:20Z",
        "updatedAt" : "2019-02-28T06:47:45Z",
        "lastEditedBy" : "838eb58c-0fa8-4742-994f-a407c7183e57",
        "tags" : [
        ]
      },
      {
        "id" : "30f88722-171a-4b3a-abb2-c8e8b43d1b85",
        "parentId" : "0ae2715a-5550-422a-b64f-9ccca946a55c",
        "authorId" : "4b69a0b5-ac6f-45e9-9507-dd1385182f29",
        "body" : "~I believe based on what I understand, that the later `get_config_value` in which we pass `task_vars` will sort this out.  I have not test that however.~\r\n\r\nI think I was misunderstanding.  We should prefer `ansible_python_interpreter` over the config, so we might need to use `get_config_value` as is used below instead of this more generic `get`",
        "createdAt" : "2018-12-19T17:39:57Z",
        "updatedAt" : "2019-02-28T06:47:45Z",
        "lastEditedBy" : "4b69a0b5-ac6f-45e9-9507-dd1385182f29",
        "tags" : [
        ]
      },
      {
        "id" : "21f42569-d7ad-425d-8a0b-d060e83ba1e9",
        "parentId" : "0ae2715a-5550-422a-b64f-9ccca946a55c",
        "authorId" : "311820dd-fcb9-46df-a201-9c0e7d6fac58",
        "body" : "This is to determine if the interpreter has config definitions present for discovery at all, not what their values are. For Python, this should always be true (which delegates the handling of the `ansible_python_interpreter` var value to the config system- see the config definition for `DEFAULT_INTERPRETER_PYTHON`), for anything else, it drops into the `else` that uses the old behavior of just consulting the task vars.",
        "createdAt" : "2019-01-09T22:55:49Z",
        "updatedAt" : "2019-02-28T06:47:45Z",
        "lastEditedBy" : "311820dd-fcb9-46df-a201-9c0e7d6fac58",
        "tags" : [
        ]
      }
    ],
    "commit" : "9ee7f2dcd7c9aed31a761fbbc7e911ffa4ecf502",
    "line" : 24,
    "diffHunk" : "@@ -1,1 +468,472 @@    interpreter_config_key = \"INTERPRETER_%s\" % interpreter_name.upper()\n\n    if C.config.get_configuration_definitions().get(interpreter_config_key):\n        # a config def exists for this interpreter type; consult config for the value\n        interpreter_out = C.config.get_config_value(interpreter_config_key, variables=task_vars)"
  }
]
[
  {
    "id" : "b7ad3a51-fad1-48f4-9a6d-0eb778a52e92",
    "prId" : 17813,
    "prUrl" : "https://github.com/ansible/ansible/pull/17813#pullrequestreview-2202630",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fd3587df-aab2-435f-a9c3-ac86025311e4",
        "parentId" : null,
        "authorId" : "30fc1801-f8f1-4cc4-9690-e31e203f4f6d",
        "body" : "i would move this into the 'else' below when it does not match 'smart', also probably should be .lower()\n",
        "createdAt" : "2016-09-29T18:34:08Z",
        "updatedAt" : "2016-09-29T19:19:06Z",
        "lastEditedBy" : "30fc1801-f8f1-4cc4-9690-e31e203f4f6d",
        "tags" : [
        ]
      },
      {
        "id" : "1621b7b7-8c1b-4f6a-8d89-af1fc1e6579b",
        "parentId" : "fd3587df-aab2-435f-a9c3-ac86025311e4",
        "authorId" : "30fc1801-f8f1-4cc4-9690-e31e203f4f6d",
        "body" : "also need to return AnsibleOptionsError if the value of the config is incorrect\n",
        "createdAt" : "2016-09-29T18:35:21Z",
        "updatedAt" : "2016-09-29T19:19:06Z",
        "lastEditedBy" : "30fc1801-f8f1-4cc4-9690-e31e203f4f6d",
        "tags" : [
        ]
      }
    ],
    "commit" : "5fcbd38bd959241f1828dc5b70db9712ec44d753",
    "line" : 50,
    "diffHunk" : "@@ -1,1 +647,651 @@\n        # since this can be a non-bool now, we need to handle it correctly\n        scp_if_ssh = C.DEFAULT_SCP_IF_SSH\n        if not isinstance(scp_if_ssh, bool):\n            scp_if_ssh = scp_if_ssh.lower()"
  },
  {
    "id" : "279b9ebd-ef50-4d96-b37d-e72dfe69251c",
    "prId" : 17813,
    "prUrl" : "https://github.com/ansible/ansible/pull/17813#pullrequestreview-2233731",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0acd718e-df3e-4c52-a3d7-da66db078381",
        "parentId" : null,
        "authorId" : "fa0144fc-7424-474a-9ab5-059de28814b7",
        "body" : "I'd move this block into it's own method since fetch_file will likely need it as well.\n",
        "createdAt" : "2016-09-29T21:23:56Z",
        "updatedAt" : "2016-09-29T21:44:30Z",
        "lastEditedBy" : "fa0144fc-7424-474a-9ab5-059de28814b7",
        "tags" : [
        ]
      }
    ],
    "commit" : "5fcbd38bd959241f1828dc5b70db9712ec44d753",
    "line" : 51,
    "diffHunk" : "@@ -1,1 +648,652 @@        # since this can be a non-bool now, we need to handle it correctly\n        scp_if_ssh = C.DEFAULT_SCP_IF_SSH\n        if not isinstance(scp_if_ssh, bool):\n            scp_if_ssh = scp_if_ssh.lower()\n            if scp_if_ssh in BOOLEANS:"
  },
  {
    "id" : "9e794fe5-e225-465e-bcfa-8f89299ae1df",
    "prId" : 17813,
    "prUrl" : "https://github.com/ansible/ansible/pull/17813#pullrequestreview-2233731",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d1f8e73f-2894-45e3-9635-1eb941e81a6b",
        "parentId" : null,
        "authorId" : "fa0144fc-7424-474a-9ab5-059de28814b7",
        "body" : "may be cleaner to build the list of methods, iterate on that list to build a list of (cmd,in_data,checkrc) for each method, then iterate over that list when invoking it. something like:\n\n``` python\nmethod_names =['sftp']\nif scp_if_ssh == 'smart':\n     method_names.append('scp')\nelif scp_if_ssh:\n     method_names = ['scp']\n\nmethods = []\nfor method_name in method_names:\n    if method_name == 'sftp':\n          methods.append(self._build_sftp_put_command(host, in_path, out_path))\n   if method_name == 'scp':\n         methods.append(self._build_scp_put_command(host, in_path, out_path))\n\nfor cmd, in_data, checkrc, method in methods:\n    (returncode, stdout, stderr) = self._run(cmd, in_data, checkrc)\n    if returncode == 0:\n         return\n   if scp_if_ssh == 'smart':\n         <the display warning/debug code here>\n\n# nothing succeeded and returned\nraise AnsibleError...\n```\n",
        "createdAt" : "2016-09-29T21:43:21Z",
        "updatedAt" : "2016-09-29T21:44:30Z",
        "lastEditedBy" : "fa0144fc-7424-474a-9ab5-059de28814b7",
        "tags" : [
        ]
      }
    ],
    "commit" : "5fcbd38bd959241f1828dc5b70db9712ec44d753",
    "line" : 74,
    "diffHunk" : "@@ -1,1 +671,675 @@                cmd = self._build_command('scp', in_path, u'{0}:{1}'.format(host, pipes.quote(out_path)))\n                in_data = None\n\n            in_data = to_bytes(in_data, nonstring='passthru')\n            (returncode, stdout, stderr) = self._run(cmd, in_data, checkrc=False)"
  },
  {
    "id" : "023c0099-e98d-4df6-a98e-662045112a16",
    "prId" : 18614,
    "prUrl" : "https://github.com/ansible/ansible/pull/18614#pullrequestreview-13475467",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "191d6655-7f85-4529-820a-3fb6052e83f0",
        "parentId" : null,
        "authorId" : "c22b39e3-76ad-47da-ad88-2bc087f3cdc1",
        "body" : "is this right? src= in fetch module is still the path for the file to be copied. eg:\r\n\r\nfetch: src=/etc/resolv.conf dest=/tmp\r\n\r\nwould become\r\n\r\nscp {{remote_hostname}}:/etc/resolv.conf /tmp\r\n\r\nSo the correct translation would be:\r\n\r\ncmd = self._build_command('scp', u'{0}:{1}'.format(host, shlex_quote(in_path)), out_path)\r\n\r\n// Anderson",
        "createdAt" : "2016-11-29T10:13:27Z",
        "updatedAt" : "2016-11-29T10:13:27Z",
        "lastEditedBy" : "c22b39e3-76ad-47da-ad88-2bc087f3cdc1",
        "tags" : [
        ]
      },
      {
        "id" : "d202121e-1b2e-4f1d-9f93-12ada3a673bf",
        "parentId" : "191d6655-7f85-4529-820a-3fb6052e83f0",
        "authorId" : "fe56cc8c-7148-4639-9b94-60459f7b5106",
        "body" : "I guess u are right. let me test",
        "createdAt" : "2016-11-29T17:04:10Z",
        "updatedAt" : "2016-11-29T17:04:10Z",
        "lastEditedBy" : "fe56cc8c-7148-4639-9b94-60459f7b5106",
        "tags" : [
        ]
      },
      {
        "id" : "20717caf-277a-49aa-a3f0-8412d3a51109",
        "parentId" : "191d6655-7f85-4529-820a-3fb6052e83f0",
        "authorId" : "c22b39e3-76ad-47da-ad88-2bc087f3cdc1",
        "body" : "@albertomurillo could you test it?",
        "createdAt" : "2016-12-18T23:42:11Z",
        "updatedAt" : "2016-12-18T23:42:12Z",
        "lastEditedBy" : "c22b39e3-76ad-47da-ad88-2bc087f3cdc1",
        "tags" : [
        ]
      }
    ],
    "commit" : "cfd8b6640874d2b22f99412c1d83c32150e70dfb",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +630,634 @@            elif method == 'scp':\n                if sftp_action == 'get':\n                    cmd = self._build_command('scp', u'{0}:{1}'.format(host, shlex_quote(out_path)), in_path)\n                else:\n                    cmd = self._build_command('scp', in_path, u'{0}:{1}'.format(host, shlex_quote(out_path)))"
  },
  {
    "id" : "8b9167cd-fd5c-4cbd-a5c9-b4ce8147744c",
    "prId" : 29099,
    "prUrl" : "https://github.com/ansible/ansible/pull/29099#pullrequestreview-61316410",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "71e3a150-1b17-49b7-82cf-118f08fe7e15",
        "parentId" : null,
        "authorId" : "30fc1801-f8f1-4cc4-9690-e31e203f4f6d",
        "body" : "wouldn't calling `self.reset` be simpler?",
        "createdAt" : "2017-09-07T17:27:33Z",
        "updatedAt" : "2017-09-07T17:27:39Z",
        "lastEditedBy" : "30fc1801-f8f1-4cc4-9690-e31e203f4f6d",
        "tags" : [
        ]
      },
      {
        "id" : "e5edbd2c-ebbf-40b8-bd81-81fc44f6a67e",
        "parentId" : "71e3a150-1b17-49b7-82cf-118f08fe7e15",
        "authorId" : "30fc1801-f8f1-4cc4-9690-e31e203f4f6d",
        "body" : "also .. no need to spawn another ssh client attached to socket for each attempt",
        "createdAt" : "2017-09-07T17:29:13Z",
        "updatedAt" : "2017-09-07T17:29:13Z",
        "lastEditedBy" : "30fc1801-f8f1-4cc4-9690-e31e203f4f6d",
        "tags" : [
        ]
      },
      {
        "id" : "17f15401-22c2-4443-ae82-1f7bd88d37b8",
        "parentId" : "71e3a150-1b17-49b7-82cf-118f08fe7e15",
        "authorId" : "4b69a0b5-ac6f-45e9-9507-dd1385182f29",
        "body" : "`self.reset` won't create a new fd/pipe for sshpass.  `self.sshpass_pipe` is only created in `_build_command`, and there is a possibility that the fd changes between creation of the pipe.\r\n\r\nI'm not sure what your comment about `also .. no need to spawn another ssh client attached to socket for each attempt` means.  Effectively all this does is open a new pipe that would have been closed, and updates the command to reference the new fd.\r\n\r\nOtherwise without this, the fd/pipe is closed, and without updating the command to reference the new fd, we may be referencing the wrong fd",
        "createdAt" : "2017-09-07T17:49:20Z",
        "updatedAt" : "2017-09-07T17:49:20Z",
        "lastEditedBy" : "4b69a0b5-ac6f-45e9-9507-dd1385182f29",
        "tags" : [
        ]
      },
      {
        "id" : "3a47d0c5-81d1-4eee-9c7c-d5841d6fb56d",
        "parentId" : "71e3a150-1b17-49b7-82cf-118f08fe7e15",
        "authorId" : "30fc1801-f8f1-4cc4-9690-e31e203f4f6d",
        "body" : "nmvd, was confusing the sshpass pipe with ssh one ... but we probably need to regen in reset also.",
        "createdAt" : "2017-09-07T18:31:30Z",
        "updatedAt" : "2017-09-07T18:31:31Z",
        "lastEditedBy" : "30fc1801-f8f1-4cc4-9690-e31e203f4f6d",
        "tags" : [
        ]
      },
      {
        "id" : "6fc2d4d3-78f6-4ce8-a934-2ba4834648d2",
        "parentId" : "71e3a150-1b17-49b7-82cf-118f08fe7e15",
        "authorId" : "4b69a0b5-ac6f-45e9-9507-dd1385182f29",
        "body" : "`reset` should not be impacted.  The next time that `_build_command` is used to create a command for a new task it should be ok.  retries is impacted, since we just re-use the already created command from `_build_command`, we don't re-build the command for each retry.",
        "createdAt" : "2017-09-07T18:45:26Z",
        "updatedAt" : "2017-09-07T18:45:26Z",
        "lastEditedBy" : "4b69a0b5-ac6f-45e9-9507-dd1385182f29",
        "tags" : [
        ]
      }
    ],
    "commit" : "cfa864f48dac9d0573fbe5df9f3edbcac1f3120c",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +200,204 @@        cmd_summary = \"%s...\" % args[0]\n        for attempt in range(remaining_tries):\n            cmd = args[0]\n            if attempt != 0 and self._play_context.password and isinstance(cmd, list):\n                # If this is a retry, the fd/pipe for sshpass is closed, and we need a new one"
  },
  {
    "id" : "2bfe80da-35a7-4bda-a535-9bbbfc12b62d",
    "prId" : 32829,
    "prUrl" : "https://github.com/ansible/ansible/pull/32829#pullrequestreview-142082068",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8ce78e3b-56c3-476c-b3e4-969eeaded728",
        "parentId" : null,
        "authorId" : "311820dd-fcb9-46df-a201-9c0e7d6fac58",
        "body" : "This should probably change in one of two ways to allow PKCS11 support to be enabled on a per-host basis:\r\na) add `vars: { name=ansible_ssh_pkcs11_provider }` to make the value settable in inventory at the host/group level \r\nb) add a second config value with vars/ini/env/yaml values like `pkcs11_enabled`\r\n\r\nWhile the actual provider configuration makes sense as a global config/env option (since the provider itself is unlikely to vary by host), there should probably be a separate config+env+var option to turn it on for a given host. Otherwise it's an all-or-none proposition for using it, where in complex environments, you may need both in the same Ansible run. Two options is a bit more hassle, but would allow the global configuration of the provider while hosts could still opt in/out individually (or by group). \r\n\r\nThis could also allow you to add a warning that the token PIN is required with PKCS11 (rather than silently failing to auth as it would now by bypassing the PKCS11 path entirely).",
        "createdAt" : "2018-07-27T23:38:02Z",
        "updatedAt" : "2021-03-14T02:51:31Z",
        "lastEditedBy" : "311820dd-fcb9-46df-a201-9c0e7d6fac58",
        "tags" : [
        ]
      },
      {
        "id" : "a6fd745f-638e-42ba-a531-176ea50c05cf",
        "parentId" : "8ce78e3b-56c3-476c-b3e4-969eeaded728",
        "authorId" : "3093fb3e-86a0-4b72-86de-78b905c3ee2b",
        "body" : "I went with option a (at least I think I did, as a first time contributor some of the Ansible internals are a little fuzzy).  If you specify the pkcs11 provider then pkcs11 is enabled, if you don't specify the provider then its disabled. I could detect if pkcs11 provider was used but no password was provided, I could print an error that a password/pin is required.  I am trying to avoid adding too many variables, it seems that if you specify a pkcs11_provider then its safe to assume your using pkcs11.  Let me know what you think.",
        "createdAt" : "2018-07-31T18:16:14Z",
        "updatedAt" : "2021-03-14T02:51:31Z",
        "lastEditedBy" : "3093fb3e-86a0-4b72-86de-78b905c3ee2b",
        "tags" : [
        ]
      }
    ],
    "commit" : "db00bd3cf982ddeac8aa601f8b3e51b1a99b740c",
    "line" : 15,
    "diffHunk" : "@@ -1,1 +325,329 @@          - name: timeout\n        type: integer\n      pkcs11_provider:\n        version_added: '2.12'\n        default: \"\""
  },
  {
    "id" : "96207e07-0301-4b11-9af7-af071a62d91c",
    "prId" : 39245,
    "prUrl" : "https://github.com/ansible/ansible/pull/39245#pullrequestreview-115968607",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a2c89afb-6656-4a42-ae7d-c74547662298",
        "parentId" : null,
        "authorId" : "4b69a0b5-ac6f-45e9-9507-dd1385182f29",
        "body" : "This looks like a good change, however, for consistency with the rest of the code, I think we should use `self._play_context.ssh_executable` until we decide to switch the connection plugin in full over to using `get_option`.",
        "createdAt" : "2018-04-27T14:49:18Z",
        "updatedAt" : "2018-04-27T14:49:19Z",
        "lastEditedBy" : "4b69a0b5-ac6f-45e9-9507-dd1385182f29",
        "tags" : [
        ]
      },
      {
        "id" : "af7cd31b-bb4d-40ab-956c-7c69d702dd1f",
        "parentId" : "a2c89afb-6656-4a42-ae7d-c74547662298",
        "authorId" : "30fc1801-f8f1-4cc4-9690-e31e203f4f6d",
        "body" : "in the process of doing so, play_context should not really be the main source of truth anymore ",
        "createdAt" : "2018-04-27T14:54:06Z",
        "updatedAt" : "2018-04-27T14:54:06Z",
        "lastEditedBy" : "30fc1801-f8f1-4cc4-9690-e31e203f4f6d",
        "tags" : [
        ]
      }
    ],
    "commit" : "2cc69e08be8af0ad3d075dfa67fd40f270709678",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +678,682 @@\n        state = states.index('ready_to_send')\n        if to_bytes(self.get_option('ssh_executable')) in cmd and sudoable:\n            if self._play_context.prompt:\n                # We're requesting escalation with a password, so we have to"
  }
]
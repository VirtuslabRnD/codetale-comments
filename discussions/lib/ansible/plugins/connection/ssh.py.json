[
  {
    "id" : "b7ad3a51-fad1-48f4-9a6d-0eb778a52e92",
    "prId" : 17813,
    "prUrl" : "https://github.com/ansible/ansible/pull/17813#pullrequestreview-2202630",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fd3587df-aab2-435f-a9c3-ac86025311e4",
        "parentId" : null,
        "authorId" : "30fc1801-f8f1-4cc4-9690-e31e203f4f6d",
        "body" : "i would move this into the 'else' below when it does not match 'smart', also probably should be .lower()\n",
        "createdAt" : "2016-09-29T18:34:08Z",
        "updatedAt" : "2016-09-29T19:19:06Z",
        "lastEditedBy" : "30fc1801-f8f1-4cc4-9690-e31e203f4f6d",
        "tags" : [
        ]
      },
      {
        "id" : "1621b7b7-8c1b-4f6a-8d89-af1fc1e6579b",
        "parentId" : "fd3587df-aab2-435f-a9c3-ac86025311e4",
        "authorId" : "30fc1801-f8f1-4cc4-9690-e31e203f4f6d",
        "body" : "also need to return AnsibleOptionsError if the value of the config is incorrect\n",
        "createdAt" : "2016-09-29T18:35:21Z",
        "updatedAt" : "2016-09-29T19:19:06Z",
        "lastEditedBy" : "30fc1801-f8f1-4cc4-9690-e31e203f4f6d",
        "tags" : [
        ]
      }
    ],
    "commit" : "5fcbd38bd959241f1828dc5b70db9712ec44d753",
    "line" : 50,
    "diffHunk" : "@@ -1,1 +647,651 @@\n        # since this can be a non-bool now, we need to handle it correctly\n        scp_if_ssh = C.DEFAULT_SCP_IF_SSH\n        if not isinstance(scp_if_ssh, bool):\n            scp_if_ssh = scp_if_ssh.lower()"
  },
  {
    "id" : "279b9ebd-ef50-4d96-b37d-e72dfe69251c",
    "prId" : 17813,
    "prUrl" : "https://github.com/ansible/ansible/pull/17813#pullrequestreview-2233731",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0acd718e-df3e-4c52-a3d7-da66db078381",
        "parentId" : null,
        "authorId" : "fa0144fc-7424-474a-9ab5-059de28814b7",
        "body" : "I'd move this block into it's own method since fetch_file will likely need it as well.\n",
        "createdAt" : "2016-09-29T21:23:56Z",
        "updatedAt" : "2016-09-29T21:44:30Z",
        "lastEditedBy" : "fa0144fc-7424-474a-9ab5-059de28814b7",
        "tags" : [
        ]
      }
    ],
    "commit" : "5fcbd38bd959241f1828dc5b70db9712ec44d753",
    "line" : 51,
    "diffHunk" : "@@ -1,1 +648,652 @@        # since this can be a non-bool now, we need to handle it correctly\n        scp_if_ssh = C.DEFAULT_SCP_IF_SSH\n        if not isinstance(scp_if_ssh, bool):\n            scp_if_ssh = scp_if_ssh.lower()\n            if scp_if_ssh in BOOLEANS:"
  },
  {
    "id" : "9e794fe5-e225-465e-bcfa-8f89299ae1df",
    "prId" : 17813,
    "prUrl" : "https://github.com/ansible/ansible/pull/17813#pullrequestreview-2233731",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d1f8e73f-2894-45e3-9635-1eb941e81a6b",
        "parentId" : null,
        "authorId" : "fa0144fc-7424-474a-9ab5-059de28814b7",
        "body" : "may be cleaner to build the list of methods, iterate on that list to build a list of (cmd,in_data,checkrc) for each method, then iterate over that list when invoking it. something like:\n\n``` python\nmethod_names =['sftp']\nif scp_if_ssh == 'smart':\n     method_names.append('scp')\nelif scp_if_ssh:\n     method_names = ['scp']\n\nmethods = []\nfor method_name in method_names:\n    if method_name == 'sftp':\n          methods.append(self._build_sftp_put_command(host, in_path, out_path))\n   if method_name == 'scp':\n         methods.append(self._build_scp_put_command(host, in_path, out_path))\n\nfor cmd, in_data, checkrc, method in methods:\n    (returncode, stdout, stderr) = self._run(cmd, in_data, checkrc)\n    if returncode == 0:\n         return\n   if scp_if_ssh == 'smart':\n         <the display warning/debug code here>\n\n# nothing succeeded and returned\nraise AnsibleError...\n```\n",
        "createdAt" : "2016-09-29T21:43:21Z",
        "updatedAt" : "2016-09-29T21:44:30Z",
        "lastEditedBy" : "fa0144fc-7424-474a-9ab5-059de28814b7",
        "tags" : [
        ]
      }
    ],
    "commit" : "5fcbd38bd959241f1828dc5b70db9712ec44d753",
    "line" : 74,
    "diffHunk" : "@@ -1,1 +671,675 @@                cmd = self._build_command('scp', in_path, u'{0}:{1}'.format(host, pipes.quote(out_path)))\n                in_data = None\n\n            in_data = to_bytes(in_data, nonstring='passthru')\n            (returncode, stdout, stderr) = self._run(cmd, in_data, checkrc=False)"
  },
  {
    "id" : "023c0099-e98d-4df6-a98e-662045112a16",
    "prId" : 18614,
    "prUrl" : "https://github.com/ansible/ansible/pull/18614#pullrequestreview-13475467",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "191d6655-7f85-4529-820a-3fb6052e83f0",
        "parentId" : null,
        "authorId" : "c22b39e3-76ad-47da-ad88-2bc087f3cdc1",
        "body" : "is this right? src= in fetch module is still the path for the file to be copied. eg:\r\n\r\nfetch: src=/etc/resolv.conf dest=/tmp\r\n\r\nwould become\r\n\r\nscp {{remote_hostname}}:/etc/resolv.conf /tmp\r\n\r\nSo the correct translation would be:\r\n\r\ncmd = self._build_command('scp', u'{0}:{1}'.format(host, shlex_quote(in_path)), out_path)\r\n\r\n// Anderson",
        "createdAt" : "2016-11-29T10:13:27Z",
        "updatedAt" : "2016-11-29T10:13:27Z",
        "lastEditedBy" : "c22b39e3-76ad-47da-ad88-2bc087f3cdc1",
        "tags" : [
        ]
      },
      {
        "id" : "d202121e-1b2e-4f1d-9f93-12ada3a673bf",
        "parentId" : "191d6655-7f85-4529-820a-3fb6052e83f0",
        "authorId" : "fe56cc8c-7148-4639-9b94-60459f7b5106",
        "body" : "I guess u are right. let me test",
        "createdAt" : "2016-11-29T17:04:10Z",
        "updatedAt" : "2016-11-29T17:04:10Z",
        "lastEditedBy" : "fe56cc8c-7148-4639-9b94-60459f7b5106",
        "tags" : [
        ]
      },
      {
        "id" : "20717caf-277a-49aa-a3f0-8412d3a51109",
        "parentId" : "191d6655-7f85-4529-820a-3fb6052e83f0",
        "authorId" : "c22b39e3-76ad-47da-ad88-2bc087f3cdc1",
        "body" : "@albertomurillo could you test it?",
        "createdAt" : "2016-12-18T23:42:11Z",
        "updatedAt" : "2016-12-18T23:42:12Z",
        "lastEditedBy" : "c22b39e3-76ad-47da-ad88-2bc087f3cdc1",
        "tags" : [
        ]
      }
    ],
    "commit" : "cfd8b6640874d2b22f99412c1d83c32150e70dfb",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +630,634 @@            elif method == 'scp':\n                if sftp_action == 'get':\n                    cmd = self._build_command('scp', u'{0}:{1}'.format(host, shlex_quote(out_path)), in_path)\n                else:\n                    cmd = self._build_command('scp', in_path, u'{0}:{1}'.format(host, shlex_quote(out_path)))"
  },
  {
    "id" : "8b9167cd-fd5c-4cbd-a5c9-b4ce8147744c",
    "prId" : 29099,
    "prUrl" : "https://github.com/ansible/ansible/pull/29099#pullrequestreview-61316410",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "71e3a150-1b17-49b7-82cf-118f08fe7e15",
        "parentId" : null,
        "authorId" : "30fc1801-f8f1-4cc4-9690-e31e203f4f6d",
        "body" : "wouldn't calling `self.reset` be simpler?",
        "createdAt" : "2017-09-07T17:27:33Z",
        "updatedAt" : "2017-09-07T17:27:39Z",
        "lastEditedBy" : "30fc1801-f8f1-4cc4-9690-e31e203f4f6d",
        "tags" : [
        ]
      },
      {
        "id" : "e5edbd2c-ebbf-40b8-bd81-81fc44f6a67e",
        "parentId" : "71e3a150-1b17-49b7-82cf-118f08fe7e15",
        "authorId" : "30fc1801-f8f1-4cc4-9690-e31e203f4f6d",
        "body" : "also .. no need to spawn another ssh client attached to socket for each attempt",
        "createdAt" : "2017-09-07T17:29:13Z",
        "updatedAt" : "2017-09-07T17:29:13Z",
        "lastEditedBy" : "30fc1801-f8f1-4cc4-9690-e31e203f4f6d",
        "tags" : [
        ]
      },
      {
        "id" : "17f15401-22c2-4443-ae82-1f7bd88d37b8",
        "parentId" : "71e3a150-1b17-49b7-82cf-118f08fe7e15",
        "authorId" : "4b69a0b5-ac6f-45e9-9507-dd1385182f29",
        "body" : "`self.reset` won't create a new fd/pipe for sshpass.  `self.sshpass_pipe` is only created in `_build_command`, and there is a possibility that the fd changes between creation of the pipe.\r\n\r\nI'm not sure what your comment about `also .. no need to spawn another ssh client attached to socket for each attempt` means.  Effectively all this does is open a new pipe that would have been closed, and updates the command to reference the new fd.\r\n\r\nOtherwise without this, the fd/pipe is closed, and without updating the command to reference the new fd, we may be referencing the wrong fd",
        "createdAt" : "2017-09-07T17:49:20Z",
        "updatedAt" : "2017-09-07T17:49:20Z",
        "lastEditedBy" : "4b69a0b5-ac6f-45e9-9507-dd1385182f29",
        "tags" : [
        ]
      },
      {
        "id" : "3a47d0c5-81d1-4eee-9c7c-d5841d6fb56d",
        "parentId" : "71e3a150-1b17-49b7-82cf-118f08fe7e15",
        "authorId" : "30fc1801-f8f1-4cc4-9690-e31e203f4f6d",
        "body" : "nmvd, was confusing the sshpass pipe with ssh one ... but we probably need to regen in reset also.",
        "createdAt" : "2017-09-07T18:31:30Z",
        "updatedAt" : "2017-09-07T18:31:31Z",
        "lastEditedBy" : "30fc1801-f8f1-4cc4-9690-e31e203f4f6d",
        "tags" : [
        ]
      },
      {
        "id" : "6fc2d4d3-78f6-4ce8-a934-2ba4834648d2",
        "parentId" : "71e3a150-1b17-49b7-82cf-118f08fe7e15",
        "authorId" : "4b69a0b5-ac6f-45e9-9507-dd1385182f29",
        "body" : "`reset` should not be impacted.  The next time that `_build_command` is used to create a command for a new task it should be ok.  retries is impacted, since we just re-use the already created command from `_build_command`, we don't re-build the command for each retry.",
        "createdAt" : "2017-09-07T18:45:26Z",
        "updatedAt" : "2017-09-07T18:45:26Z",
        "lastEditedBy" : "4b69a0b5-ac6f-45e9-9507-dd1385182f29",
        "tags" : [
        ]
      }
    ],
    "commit" : "cfa864f48dac9d0573fbe5df9f3edbcac1f3120c",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +200,204 @@        cmd_summary = \"%s...\" % args[0]\n        for attempt in range(remaining_tries):\n            cmd = args[0]\n            if attempt != 0 and self._play_context.password and isinstance(cmd, list):\n                # If this is a retry, the fd/pipe for sshpass is closed, and we need a new one"
  }
]
[
  {
    "id" : "af5a1593-7f4f-47f2-9537-2adbfaa3ded3",
    "prId" : 49921,
    "prUrl" : "https://github.com/ansible/ansible/pull/49921#pullrequestreview-185336022",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "92462785-91ca-4721-ac91-8c815efc4c4b",
        "parentId" : null,
        "authorId" : "30fc1801-f8f1-4cc4-9690-e31e203f4f6d",
        "body" : "I was testing this in my threading fact gathering branch,  the .get method won't help with 'blocked' processes and will inconsistently return or just hang forever (I'm still trying to get a reliable reproducer). I found this by 'simulating' bad NFS mounts by throttling the traffic to the nfs server the VMs are using.",
        "createdAt" : "2018-12-14T14:12:02Z",
        "updatedAt" : "2018-12-18T21:42:01Z",
        "lastEditedBy" : "30fc1801-f8f1-4cc4-9690-e31e203f4f6d",
        "tags" : [
        ]
      },
      {
        "id" : "d2f24524-34f6-4ae1-acdf-1da9d04dc316",
        "parentId" : "92462785-91ca-4721-ac91-8c815efc4c4b",
        "authorId" : "30fc1801-f8f1-4cc4-9690-e31e203f4f6d",
        "body" : "In py3 this is mitigated by the subproccess methods having a timeout, but this is not available on py2",
        "createdAt" : "2018-12-14T14:15:42Z",
        "updatedAt" : "2018-12-18T21:42:01Z",
        "lastEditedBy" : "30fc1801-f8f1-4cc4-9690-e31e203f4f6d",
        "tags" : [
        ]
      },
      {
        "id" : "e6788144-a80b-4ca3-bb79-6c3e84695a5d",
        "parentId" : "92462785-91ca-4721-ac91-8c815efc4c4b",
        "authorId" : "30fc1801-f8f1-4cc4-9690-e31e203f4f6d",
        "body" : "see my loop over waiting on threads here #49398 to get a py2/py3 compatible way",
        "createdAt" : "2018-12-14T14:35:27Z",
        "updatedAt" : "2018-12-18T21:42:01Z",
        "lastEditedBy" : "30fc1801-f8f1-4cc4-9690-e31e203f4f6d",
        "tags" : [
        ]
      },
      {
        "id" : "3131351c-ae0f-46e6-885c-1b7bcce84dd3",
        "parentId" : "92462785-91ca-4721-ac91-8c815efc4c4b",
        "authorId" : "838eb58c-0fa8-4742-994f-a407c7183e57",
        "body" : "We'll need a reproducer to be able to figure that out.  There's at least two other ways I can code this using threads but unless I can reproduce this I won't be able to work out what code is causing issues.\r\n\r\nI tested this by running it on:\r\n```\r\n@timeout.timeout(1)\r\ndef slow_function():\r\n    def run_command(['python', '-c', ' import time ; time.sleep(100)'])\r\n\r\ntry:\r\n    slow_function()\r\nexcept timeout.TimeoutError as e:\r\n   print('Success: %s' % to_native(e))\r\n```\r\n\r\nand didn't see any problems so I'll need more to go on than that.",
        "createdAt" : "2018-12-14T15:07:41Z",
        "updatedAt" : "2018-12-18T21:42:01Z",
        "lastEditedBy" : "838eb58c-0fa8-4742-994f-a407c7183e57",
        "tags" : [
        ]
      },
      {
        "id" : "d56626f5-5cd4-4fab-bb8b-9bf675d95832",
        "parentId" : "92462785-91ca-4721-ac91-8c815efc4c4b",
        "authorId" : "30fc1801-f8f1-4cc4-9690-e31e203f4f6d",
        "body" : "its not a question of slow, but 'blocking' i.e accessing a bad NFS mount, that puts the process in 'B' status for the kernel and does not allow interruption.",
        "createdAt" : "2018-12-14T15:50:20Z",
        "updatedAt" : "2018-12-18T21:42:01Z",
        "lastEditedBy" : "30fc1801-f8f1-4cc4-9690-e31e203f4f6d",
        "tags" : [
        ]
      },
      {
        "id" : "c67a5aea-317e-4cb7-bd33-3c661b751ed6",
        "parentId" : "92462785-91ca-4721-ac91-8c815efc4c4b",
        "authorId" : "838eb58c-0fa8-4742-994f-a407c7183e57",
        "body" : "I'm unable to reproduce with https://gist.github.com/abadger/41ddf282503b94e84512dbbb7e9f93e0 but that's uninterruptible sleep state which might be different than blocking state.  If you can write a driver.sh for blocking state we can test that instead.",
        "createdAt" : "2018-12-14T19:13:02Z",
        "updatedAt" : "2018-12-18T21:42:01Z",
        "lastEditedBy" : "838eb58c-0fa8-4742-994f-a407c7183e57",
        "tags" : [
        ]
      },
      {
        "id" : "f15c5984-67ed-48c0-b303-20536ce755e2",
        "parentId" : "92462785-91ca-4721-ac91-8c815efc4c4b",
        "authorId" : "30fc1801-f8f1-4cc4-9690-e31e203f4f6d",
        "body" : "Seems close enough, so I'll take that test as good as the 'unkillable' status is the main issue once the problem surfaces.\r\n\r\nI still have not been able to reproduce the problem i saw reliably,  it just has happens a few time across the many times I've tested the gathering threaded code. It seems to happen less with Py3 versions, but since I'm not sure about how to trigger it, that is just anecdotal data. I was thinking of downgrading to nfsv3 since that was a lot more prone to this kind of issue ... but its probably not worth it.",
        "createdAt" : "2018-12-15T01:34:53Z",
        "updatedAt" : "2018-12-18T21:42:01Z",
        "lastEditedBy" : "30fc1801-f8f1-4cc4-9690-e31e203f4f6d",
        "tags" : [
        ]
      }
    ],
    "commit" : "cb1c62cf572ac37cc6905b4f2a7bffd6e9530bb9",
    "line" : 43,
    "diffHunk" : "@@ -1,1 +47,51 @@            pool.close()\n            try:\n                return res.get(timeout_value)\n            except multiprocessing.TimeoutError:\n                # This is an ansible.module_utils.common.facts.timeout.TimeoutError"
  },
  {
    "id" : "91422491-7491-4eaf-aac6-0f1c52f14af7",
    "prId" : 50157,
    "prUrl" : "https://github.com/ansible/ansible/pull/50157#pullrequestreview-186753365",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9aad8aed-4e2c-4448-b6ae-4cd70b6f591a",
        "parentId" : null,
        "authorId" : "30fc1801-f8f1-4cc4-9690-e31e203f4f6d",
        "body" : "might want to use try/except AttributeError pass as the pool does not always have '.terminate' available (we had to do this in executor for the workers).",
        "createdAt" : "2018-12-19T15:40:16Z",
        "updatedAt" : "2018-12-19T15:40:43Z",
        "lastEditedBy" : "30fc1801-f8f1-4cc4-9690-e31e203f4f6d",
        "tags" : [
        ]
      },
      {
        "id" : "64aa30f9-c9ee-40a2-9fbf-0bb34f833d14",
        "parentId" : "9aad8aed-4e2c-4448-b6ae-4cd70b6f591a",
        "authorId" : "838eb58c-0fa8-4742-994f-a407c7183e57",
        "body" : "This should be fine.  In executor, we're using ```worker.terminate()```.  Here we're using ```pool.terminate()```.  ```pool.terminate()``` should always exist.  From reading the multiprocessing code it looks like ```worker.terminate()``` only exists for processes.  Not for threads.\r\n\r\nIn reading up about this issue and also the thread code, though, I wonder if terminate() might be the source of the problems you had in the parallel mount PR.  Threads in Python don't seem to have a clean way to terminate so if the code somehow causes a join() to be called, we'd then block on the thread exiting.  I'll run the terminate code through me test case before merging.  (Also, from my reading of the code, pool.terminate() might not guarantee thread termination...)  I'll experiment more before merging.",
        "createdAt" : "2018-12-19T21:02:05Z",
        "updatedAt" : "2018-12-19T21:02:05Z",
        "lastEditedBy" : "838eb58c-0fa8-4742-994f-a407c7183e57",
        "tags" : [
        ]
      },
      {
        "id" : "bcb1a1db-7165-47d9-8ab9-f9272e9edacf",
        "parentId" : "9aad8aed-4e2c-4448-b6ae-4cd70b6f591a",
        "authorId" : "30fc1801-f8f1-4cc4-9690-e31e203f4f6d",
        "body" : "For this case, signals might still be the answer, since its a single thread there isn't contention on which part of the code receives it, unlike mine which uses multiple threads.",
        "createdAt" : "2018-12-19T21:19:24Z",
        "updatedAt" : "2018-12-19T21:19:24Z",
        "lastEditedBy" : "30fc1801-f8f1-4cc4-9690-e31e203f4f6d",
        "tags" : [
        ]
      }
    ],
    "commit" : "a7d5b8f7ab44fc80e98e8347030d5d248c4c3878",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +52,56 @@                raise TimeoutError('Timer expired after %s seconds' % timeout_value)\n            finally:\n                pool.terminate()\n\n        return wrapper"
  }
]
[
  {
    "id" : "770e3b15-697c-425f-955d-a288418e9d29",
    "prId" : 27907,
    "prUrl" : "https://github.com/ansible/ansible/pull/27907#pullrequestreview-55304116",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "78bc9bbf-73c7-4730-aadd-054139185e09",
        "parentId" : null,
        "authorId" : "91c63cfe-0504-4f72-afa0-80b301c25eca",
        "body" : "I'm not super-enthused with the need to wrap calls like this, it seems difficult to keep in sync when we add calls to various cloudformation verbs. Thoughts?",
        "createdAt" : "2017-08-09T15:27:12Z",
        "updatedAt" : "2017-08-09T15:27:21Z",
        "lastEditedBy" : "91c63cfe-0504-4f72-afa0-80b301c25eca",
        "tags" : [
        ]
      },
      {
        "id" : "95b122c0-2073-4c97-8d58-f54a1604b56a",
        "parentId" : "78bc9bbf-73c7-4730-aadd-054139185e09",
        "authorId" : "d8e2780d-212c-448c-b9b5-f32188ce565a",
        "body" : "I'm not a huge fan either but the alternative looks pretty nasty as well and requires a significant amount of refactoring. Any method that currently has a `try: catch Exception:` block will be \"immune\" to retry decorators as the throttling exception never gets the chance to bubble up.\r\n\r\nWe end up needing to be very explicit in how we write functions or end up creating wrapped functions for each call that we want to make retry-able.\r\n\r\n```python\r\n# We can't add retries via decorators to methods that handle exceptions like this\r\ndef some_method():\r\n    try:\r\n        cfn.describe_stack_events(args)\r\n    except Exception as e:\r\n        module_fail(...)\r\n``` \r\n\r\n```python\r\n# we could do something like this\r\n@AWSRetry.jittered_backoff(retries=10, delay=3, max_delay=30)\r\ndef describe_stacks(stack_name):\r\n    return cfn.describe_stacks(StackName=stack_name)\r\n```\r\n\r\n```python\r\n# potential solution that doesn't monkey patch anything and lets us retry requests\r\nbackoff_wrapper = AWSRetry.jittered_backoff(retries=10, delay=3, max_delay=30)\r\ndescribe_stacks = backoff_wrapper(cfn.describe_stacks)\r\n\r\ndef some_method():\r\n    try:\r\n        describe_stacks(StackName=stack_name)\r\n    except Exception as e:\r\n        module_fail(...)\r\n```",
        "createdAt" : "2017-08-09T16:53:15Z",
        "updatedAt" : "2017-08-09T16:55:18Z",
        "lastEditedBy" : "d8e2780d-212c-448c-b9b5-f32188ce565a",
        "tags" : [
        ]
      },
      {
        "id" : "2b63de99-0f38-4118-a3f9-08c153f0b993",
        "parentId" : "78bc9bbf-73c7-4730-aadd-054139185e09",
        "authorId" : "91c63cfe-0504-4f72-afa0-80b301c25eca",
        "body" : "Gotcha. I'm glad you've thought it through. There's a slight advantage to the last suggestion you gave- if the describe_stacks wrapper init was kept inside `some_method`, it's very clear what was wrapped and reduces the chance of \"hey, my Ansible module method doesn't retry even though other parts of the module do\".\r\n\r\nUp to you though, since it's a bigger issue than the few modules I try to own.",
        "createdAt" : "2017-08-09T16:59:45Z",
        "updatedAt" : "2017-08-09T16:59:45Z",
        "lastEditedBy" : "91c63cfe-0504-4f72-afa0-80b301c25eca",
        "tags" : [
        ]
      }
    ],
    "commit" : "76460f1bca0f1b655e6e035fbcd56514c581a207",
    "line" : 23,
    "diffHunk" : "@@ -1,1 +511,515 @@    backoff_wrapper = AWSRetry.jittered_backoff(retries=10, delay=3, max_delay=30)\n    cfn.describe_stack_events = backoff_wrapper(cfn.describe_stack_events)\n    cfn.create_stack = backoff_wrapper(cfn.create_stack)\n    cfn.list_change_sets = backoff_wrapper(cfn.list_change_sets)\n    cfn.create_change_set = backoff_wrapper(cfn.create_change_set)"
  },
  {
    "id" : "759afa5f-b62e-419c-b7ad-9c087da040d6",
    "prId" : 31775,
    "prUrl" : "https://github.com/ansible/ansible/pull/31775#pullrequestreview-103115335",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9e0ff3ff-d49b-4391-a858-b913f9735140",
        "parentId" : null,
        "authorId" : "06ab4cf8-4a18-478e-93ee-69929f4bffc6",
        "body" : "Nice, I like this pattern :+1: ",
        "createdAt" : "2018-03-12T16:20:27Z",
        "updatedAt" : "2018-03-12T16:47:17Z",
        "lastEditedBy" : "06ab4cf8-4a18-478e-93ee-69929f4bffc6",
        "tags" : [
        ]
      }
    ],
    "commit" : "3894bfe5e471deda05dd8fd6f2914443a975a349",
    "line" : 52,
    "diffHunk" : "@@ -1,1 +618,622 @@            if 'use_previous_value' in v and bool(v['use_previous_value']):\n                param['UsePreviousValue'] = True\n                param.pop('ParameterValue', None)\n\n            stack_params['Parameters'].append(param)"
  },
  {
    "id" : "d01a3eea-12e1-42fb-88c4-7e5a7750624e",
    "prId" : 41840,
    "prUrl" : "https://github.com/ansible/ansible/pull/41840#pullrequestreview-131668409",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3534ad99-a14e-4445-be29-8648a9b119a9",
        "parentId" : null,
        "authorId" : "06ab4cf8-4a18-478e-93ee-69929f4bffc6",
        "body" : "I think it makes sense to only limit the number of events when the `token_filter` isn't passed. That way, if an actual edit was made then all the events resulting from that edit would be returned. CloudFormation has a max number of resource per stack, so there's a natural cap on the number of events per operation. \r\n\r\nWhat do you think about only having the limit for non-single-op events? ",
        "createdAt" : "2018-06-22T14:23:42Z",
        "updatedAt" : "2018-06-25T16:03:13Z",
        "lastEditedBy" : "06ab4cf8-4a18-478e-93ee-69929f4bffc6",
        "tags" : [
        ]
      },
      {
        "id" : "d62a9f56-f02f-4ddb-856d-8e9a128cfa44",
        "parentId" : "3534ad99-a14e-4445-be29-8648a9b119a9",
        "authorId" : "c7c4abd3-5843-4b28-8d14-5ed7c8351fe2",
        "body" : "I digged a bit more in the code and I don't think that this could help us here.\r\n\r\nThe [DescribeStackEvents API call](https://docs.aws.amazon.com/AWSCloudFormation/latest/APIReference/API_DescribeStackEvents.html) does not allow any kind of server side filter which would allow for limiting the returned events to a specific stack action. Also the Boto Paginator will need to iterate over all pages first before filtering happens client side when using [JMESPath Filtering](https://boto3.readthedocs.io/en/latest/guide/paginators.html#filtering-results-with-jmespath).\r\n\r\nMoreover it seems like the `ClientRequestToken` is generated and passed downstream through all function invocations for every action that is not related to CFN Changesets. So I assume that we would actually end up with a set `token_filter` in the `get_stack_events` function every time.\r\n\r\nAm I right with my assumptions?\r\n\r\nFor us it would also be fine having to configure the limit manually and don't provide a default value. We know that our use case is actually a rare one. ðŸ˜„ ",
        "createdAt" : "2018-06-22T15:15:20Z",
        "updatedAt" : "2018-06-25T16:03:13Z",
        "lastEditedBy" : "c7c4abd3-5843-4b28-8d14-5ed7c8351fe2",
        "tags" : [
        ]
      },
      {
        "id" : "10ed492c-7cef-4ec0-a659-abbaac626251",
        "parentId" : "3534ad99-a14e-4445-be29-8648a9b119a9",
        "authorId" : "06ab4cf8-4a18-478e-93ee-69929f4bffc6",
        "body" : "Yup, that's sensible to have a default limit since we'll be (typically) filtering out most of the historical events with that ClientRequestToken setting. ",
        "createdAt" : "2018-06-25T15:44:47Z",
        "updatedAt" : "2018-06-25T16:03:13Z",
        "lastEditedBy" : "06ab4cf8-4a18-478e-93ee-69929f4bffc6",
        "tags" : [
        ]
      }
    ],
    "commit" : "dc46d5f2186b8abd068f0ef66ef8ec64d56374c6",
    "line" : 27,
    "diffHunk" : "@@ -1,1 +291,295 @@        ).paginate(\n            StackName=stack_name,\n            PaginationConfig={'MaxItems': events_limit}\n        )\n        if token_filter is not None:"
  }
]
[
  {
    "id" : "f4bdf0e8-c999-456e-b2ef-9e92b809315c",
    "prId" : 33195,
    "prUrl" : "https://github.com/ansible/ansible/pull/33195#pullrequestreview-79907161",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e50fa1e7-4791-4e0c-934a-17f9eec13311",
        "parentId" : null,
        "authorId" : "7c3d1362-6754-4b76-8c34-1156ef3d8a54",
        "body" : "It would be easier if RPM and DEB were to give the same structured reply, or having an agnostic module would not be very useful (in cases like \"if upstream version is greater than x.y\"). Comparing versions is a complex operation and there is no filter around `dpkg --compare-versions`.\r\n\r\nAlso having the full version (epoch+upstream+release, following the standard distro notation) along with the upstream version would be useful I think.\r\n",
        "createdAt" : "2017-11-24T04:46:17Z",
        "updatedAt" : "2017-12-14T14:22:04Z",
        "lastEditedBy" : "7c3d1362-6754-4b76-8c34-1156ef3d8a54",
        "tags" : [
        ]
      },
      {
        "id" : "0a9f1f20-7b9e-4ab6-8f0b-2926621bf968",
        "parentId" : "e50fa1e7-4791-4e0c-934a-17f9eec13311",
        "authorId" : "7c3d1362-6754-4b76-8c34-1156ef3d8a54",
        "body" : "So this was my comment from #32871 and as this part of the code did not change it seemed still appropriate. With package namespacing, which can be nice if we want to later support language-specific package manager (pip…), as long as the proposed structure makes it easy to use `ansible_pkg_mgr` to find the \"main\" package manager information, then this is still useful (version comparison and so on).",
        "createdAt" : "2017-11-24T04:55:21Z",
        "updatedAt" : "2017-12-14T14:22:04Z",
        "lastEditedBy" : "7c3d1362-6754-4b76-8c34-1156ef3d8a54",
        "tags" : [
        ]
      },
      {
        "id" : "e9f6e034-c941-4720-b05a-1ab2c8b3b2e9",
        "parentId" : "e50fa1e7-4791-4e0c-934a-17f9eec13311",
        "authorId" : "38f1a2ff-4f1a-4c3d-b78a-3bae3b91d930",
        "body" : "My main concern here with trying to comply with a standard reply structure is when this is eventually extended to all sorts of package managers such as pip, rubygems, maven, ant, npm, cpan, pecl, pear, homebrew, etc etc. What happens when one of those providers doesn't offer the fields we set in the standard response? And what do we do with the extra data outside the bounds of the standard?",
        "createdAt" : "2017-11-28T20:50:57Z",
        "updatedAt" : "2017-12-14T14:22:04Z",
        "lastEditedBy" : "38f1a2ff-4f1a-4c3d-b78a-3bae3b91d930",
        "tags" : [
        ]
      },
      {
        "id" : "ef68c795-e8fe-451e-98c9-4b8e3141bf48",
        "parentId" : "e50fa1e7-4791-4e0c-934a-17f9eec13311",
        "authorId" : "30fc1801-f8f1-4cc4-9690-e31e203f4f6d",
        "body" : "I would settle on the 'lowest common denominator' as the standard (document in return fields) and make notes about additional fields available depending on package  manager/distro",
        "createdAt" : "2017-11-28T21:17:02Z",
        "updatedAt" : "2017-12-14T14:22:04Z",
        "lastEditedBy" : "30fc1801-f8f1-4cc4-9690-e31e203f4f6d",
        "tags" : [
        ]
      },
      {
        "id" : "3196c8af-9786-48f2-8544-4ec948c9a8f4",
        "parentId" : "e50fa1e7-4791-4e0c-934a-17f9eec13311",
        "authorId" : "38f1a2ff-4f1a-4c3d-b78a-3bae3b91d930",
        "body" : "Lowest common denominator seems to be `name-version` if we include the language package managers but that's effectively useless when comparing distro packages so I'm not sure how useful it would be in the end.\r\n\r\nWe could have two classifications: `name-version-release` for all distro level packages and then `name-version` for all others.Thoughts?",
        "createdAt" : "2017-11-28T22:04:11Z",
        "updatedAt" : "2017-12-14T14:22:04Z",
        "lastEditedBy" : "38f1a2ff-4f1a-4c3d-b78a-3bae3b91d930",
        "tags" : [
        ]
      },
      {
        "id" : "872842be-8f13-4d42-9879-d1e2f9b1a3c4",
        "parentId" : "e50fa1e7-4791-4e0c-934a-17f9eec13311",
        "authorId" : "7c3d1362-6754-4b76-8c34-1156ef3d8a54",
        "body" : "It seems fine.\r\n\r\nIn this case I think the next step would be to provide a filter able to split this information according to the package manager name and `name-version-release`. This filter would only make sense if used with distro-level results because they have the same concepts of upstream version/distro release number/…. It could be reused outside the scope of this PR, which would be nice.\r\n\r\nThis could be done in a separate PR though.",
        "createdAt" : "2017-11-29T04:08:12Z",
        "updatedAt" : "2017-12-14T14:22:04Z",
        "lastEditedBy" : "7c3d1362-6754-4b76-8c34-1156ef3d8a54",
        "tags" : [
        ]
      },
      {
        "id" : "78f7dc95-5c59-4792-b3a1-593ccb8491ca",
        "parentId" : "e50fa1e7-4791-4e0c-934a-17f9eec13311",
        "authorId" : "38f1a2ff-4f1a-4c3d-b78a-3bae3b91d930",
        "body" : "@duck-rh I don't follow what you mean by a filter, why would we be filtering these here? Seems out of scope for a fact gathering module.",
        "createdAt" : "2017-11-29T14:37:54Z",
        "updatedAt" : "2017-12-14T14:22:04Z",
        "lastEditedBy" : "38f1a2ff-4f1a-4c3d-b78a-3bae3b91d930",
        "tags" : [
        ]
      },
      {
        "id" : "ab025f5b-f7c6-439a-a1fd-d0e8a4b3ef53",
        "parentId" : "e50fa1e7-4791-4e0c-934a-17f9eec13311",
        "authorId" : "38f1a2ff-4f1a-4c3d-b78a-3bae3b91d930",
        "body" : "@bcoca thoughts on the `name-version-release` format for distro packages and `name-version` for \"all others\"?",
        "createdAt" : "2017-11-29T14:38:28Z",
        "updatedAt" : "2017-12-14T14:22:04Z",
        "lastEditedBy" : "38f1a2ff-4f1a-4c3d-b78a-3bae3b91d930",
        "tags" : [
        ]
      },
      {
        "id" : "e75e3201-9fbf-4b0a-9995-d6196544201e",
        "parentId" : "e50fa1e7-4791-4e0c-934a-17f9eec13311",
        "authorId" : "fa0144fc-7424-474a-9ab5-059de28814b7",
        "body" : "Instead of include the 'source' in the package info dict, could the return data have the 'source' as the first level?\r\n\r\nThat way deb/rpm/gem/mypkgformat data schema dont have to match each other exactly, as long as the items inside those keys are the same. (The more consistent and similar they are the better of course, but...)\r\n\r\nie, instead of:\r\n\r\n``` json\r\n{\r\n          \"yum\": [\r\n            {\r\n                \"arch\": \"noarch\",\r\n                \"epoch\": null,\r\n                \"name\": \"yum\",\r\n                \"release\": \"513.fc27\",\r\n                \"source\": \"rpm\",\r\n                \"version\": \"3.4.3\"\r\n            }\r\n          ],\r\n          \"yum-utils\": [\r\n            {\r\n                \"arch\": \"noarch\",\r\n                \"epoch\": null,\r\n                \"name\": \"yum-utils\",\r\n                \"release\": \"513.fc27\",\r\n                \"source\": \"rpm\",\r\n                \"version\": \"1.1.31\"\r\n            }\r\n          ],\r\n        }\r\n```\r\n\r\nsomething like:\r\n\r\n``` json\r\n{\r\n    \"rpm\": {\r\n              \"yum\": [\r\n                {\r\n                    \"arch\": \"noarch\",\r\n                    \"epoch\": null,\r\n                    \"name\": \"yum\",\r\n                    \"release\": \"513.fc27\",\r\n                    \"version\": \"3.4.3\"\r\n                }\r\n              ],\r\n              \"yum-utils\": [\r\n                {\r\n                    \"arch\": \"noarch\",\r\n                    \"epoch\": null,\r\n                    \"name\": \"yum-utils\",\r\n                    \"release\": \"513.fc27\",\r\n                    \"version\": \"1.1.31\"\r\n                }\r\n              ],\r\n            },\r\n    \"deb\": {\r\n             \"somedeb\": [\r\n                 {\r\n                     \"name\": \"somedeb\",\r\n                     \"version\": \"1.1.1-1\",\r\n                     \"arch\": \"amd64\"\r\n                 }\r\n              ],\r\n             \"otherdeb\": [\r\n                 {\r\n                     \"name\": \"otherdeb\",\r\n                     \"version\": \"2.2.2-2\",\r\n                     \"arch\": \"amd64\"\r\n                 }\r\n             ]\r\n    }\r\n}\r\n```\r\n",
        "createdAt" : "2017-11-29T15:48:22Z",
        "updatedAt" : "2017-12-14T14:22:04Z",
        "lastEditedBy" : "fa0144fc-7424-474a-9ab5-059de28814b7",
        "tags" : [
        ]
      },
      {
        "id" : "69bd3678-90a1-406a-b869-f7b9e9d8f5b6",
        "parentId" : "e50fa1e7-4791-4e0c-934a-17f9eec13311",
        "authorId" : "38f1a2ff-4f1a-4c3d-b78a-3bae3b91d930",
        "body" : "We are effectively getting this structure as it stands now, we'll return the `ansible_facts.packages.rpm` or `ansible_facts.packages.deb` and the user will be presented with this namespaced structure as you describe within `ansible_facts.packages` ... if it is preferred to strip out the `source` from the `rpm` entries, that's fine but I think the end result will be the same since you can only gather information from a single package manager per task execution and they are aggregated under the `ansible_facts.packages` dict.",
        "createdAt" : "2017-11-29T16:04:27Z",
        "updatedAt" : "2017-12-14T14:22:04Z",
        "lastEditedBy" : "38f1a2ff-4f1a-4c3d-b78a-3bae3b91d930",
        "tags" : [
        ]
      },
      {
        "id" : "5b813ae3-1652-4878-973a-7439db7e0637",
        "parentId" : "e50fa1e7-4791-4e0c-934a-17f9eec13311",
        "authorId" : "fa0144fc-7424-474a-9ab5-059de28814b7",
        "body" : "@maxamillion Excellent. I missed that there was already a per 'manager' sub dict in the return, so it already does what I was suggesting so that comment can be ignored ;->",
        "createdAt" : "2017-11-29T16:22:25Z",
        "updatedAt" : "2017-12-14T14:22:04Z",
        "lastEditedBy" : "fa0144fc-7424-474a-9ab5-059de28814b7",
        "tags" : [
        ]
      }
    ],
    "commit" : "0d45335d0ac012cb0a34e06528269658539538af",
    "line" : 184,
    "diffHunk" : "@@ -1,1 +182,186 @@    for package in apt_installed_packages:\n        ac_pkg = apt_cache[package].installed\n        package_details = dict(name=package, version=ac_pkg.version, arch=ac_pkg.architecture, source='apt')\n        if package_details['name'] not in installed_packages:\n            installed_packages[package_details['name']] = [package_details]"
  }
]
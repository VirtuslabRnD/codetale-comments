[
  {
    "id" : "97ad9552-50c9-489d-a59d-d80bc302054a",
    "prId" : 12075,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1aee92bc-385d-4466-bbae-15f0ac77757a",
        "parentId" : null,
        "authorId" : "30fc1801-f8f1-4cc4-9690-e31e203f4f6d",
        "body" : "shouldn't we do this on password input? as this is an issue with all passwrods\n",
        "createdAt" : "2015-08-25T15:07:43Z",
        "updatedAt" : "2015-08-25T19:43:24Z",
        "lastEditedBy" : "30fc1801-f8f1-4cc4-9690-e31e203f4f6d",
        "tags" : [
        ]
      },
      {
        "id" : "56db22bf-2757-4681-8fb8-76977d31b6f1",
        "parentId" : "1aee92bc-385d-4466-bbae-15f0ac77757a",
        "authorId" : "838eb58c-0fa8-4742-994f-a407c7183e57",
        "body" : "Probably not, but passwords are a little special so a case could be made:   In general we want our strategy to be unicode type internally and bytes type when we actually use it.  That way if we manipulate the string in some way (measure its length, concatenate it, strip whitespace characters, etc) there's no problems with bytes doing the wrong thing or getting mixed with unicode.  By keeping everything unicode type internally there's no confusion of what type you're dealing with and it keeps unnecessary conversions to a minimum (to_bytes and to_unicode are pretty good about unnecessary conversions but we still have the function call overhead and a few conditionals everytime we call it.)\n\nFor passwords, we do very few of these things.  So it may make sense to carry the byte type all the way through from input to output.  However, that requires tracing a lot of code, finding all the places we input vault passwords and making sure that they maintain the proper type all the way through.\n\nSince the vault code that uses the password as a byte string is self-contained inside or behind VaultLib, I think it makes sense to do this transformation here and then check the rest of the code at our leisure later.\n",
        "createdAt" : "2015-08-25T19:12:01Z",
        "updatedAt" : "2015-08-25T19:43:24Z",
        "lastEditedBy" : "838eb58c-0fa8-4742-994f-a407c7183e57",
        "tags" : [
        ]
      }
    ],
    "commit" : "a3fd4817ef1c6251d2a39e29fff29320b4c22222",
    "line" : 38,
    "diffHunk" : "@@ -1,1 +108,112 @@\n    def __init__(self, password):\n        self.b_password = to_bytes(password, errors='strict', encoding='utf-8')\n        self.cipher_name = None\n        self.b_version = b'1.1'"
  },
  {
    "id" : "f3b509a2-1892-4579-a5ae-01cd3ffbbb4a",
    "prId" : 13700,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0e3e9fef-6e41-4b84-ac84-be54b771bc31",
        "parentId" : null,
        "authorId" : "838eb58c-0fa8-4742-994f-a407c7183e57",
        "body" : "- Slicing creates a copy so it might be better to avoid doing that inside of the inner loop\n- We can move some calculations outside the loop (although it probably won't make much difference with just 3 passes).\n- Instead of assert, we probably want to write a unittest to check that this does the right thing.  I'm okay with leaving the assert in until we  write a unittest, though.\n\nSo it would look something like this:\n\n``` python\n\nchunk_len = min(1024 * 1024 * 2, file_len)\nwith open(tmp_path, \"wb\") as fh:\n    for _ in range(passes):\n        fh.seek(0, 0)\n        # get a random chunk of data\n        data = os.urandom(chunk_len)\n        for _ in range(0, file_len // chunk_len):\n            fh.write(data)\n        fh.write(data[:file_len % chunk_len])\n\n        assert(fh.tell() == file_len)  # Remove this assert once we have unittests to check its accuracy\n        os.fsync(fh)\n```\n\nHopefully that's right and I'm not off by one byte :-)\n",
        "createdAt" : "2016-01-05T01:31:51Z",
        "updatedAt" : "2016-01-05T17:05:27Z",
        "lastEditedBy" : "838eb58c-0fa8-4742-994f-a407c7183e57",
        "tags" : [
        ]
      },
      {
        "id" : "ba1a9788-7a3d-47db-9751-fac031f45ca2",
        "parentId" : "0e3e9fef-6e41-4b84-ac84-be54b771bc31",
        "authorId" : "33113403-6626-4dbd-be41-90d915c8897f",
        "body" : "> Slicing creates a copy so it might be better to avoid doing that inside of the inner loop\n\nAre you sure? \n\nYour code works fine, and it is indeed more elegant. \n\nOnly thing is that the random chunk has the same size on each pass. I'm not sure about the recovery implications, but in crypto it'd be a weakness. Not sure if the same principles apply, but I could vary the chunk length. \n",
        "createdAt" : "2016-01-05T16:56:09Z",
        "updatedAt" : "2016-01-05T17:05:27Z",
        "lastEditedBy" : "33113403-6626-4dbd-be41-90d915c8897f",
        "tags" : [
        ]
      }
    ],
    "commit" : "11ce08b9dde32c7e4b51a6fffc22f301c81181be",
    "line" : null,
    "diffHunk" : "@@ -1,1 +253,257 @@                assert(fh.tell() == file_len) # FIXME remove this assert once we have unittests to check its accuracy\n                os.fsync(fh)\n        \n            \n    def _shred_file(self, tmp_path):"
  },
  {
    "id" : "14773aa3-2f21-42da-bdeb-722895ea3c2b",
    "prId" : 17590,
    "prUrl" : "https://github.com/ansible/ansible/pull/17590#pullrequestreview-249502",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7f279b17-f6c4-451d-ab75-94a35a3b9249",
        "parentId" : null,
        "authorId" : "fa0144fc-7424-474a-9ab5-059de28814b7",
        "body" : "I think these should stay regular methods. That way if VaultLib.is_encrypted() could be more\nspecific than the module scope version. The primary case I'm thinking of is checking if the data\nis encrypted by the key that the VaultLib instance knows about. ie, 'is this file something _I_ can decrypt'\n\n(granted at the moment, nothing uses that so it doesn't matter...)\n",
        "createdAt" : "2016-09-15T19:18:33Z",
        "updatedAt" : "2016-09-15T22:27:09Z",
        "lastEditedBy" : "fa0144fc-7424-474a-9ab5-059de28814b7",
        "tags" : [
        ]
      },
      {
        "id" : "87621ed5-1083-4f7f-8c28-605c53b40676",
        "parentId" : "7f279b17-f6c4-451d-ab75-94a35a3b9249",
        "authorId" : "fa0144fc-7424-474a-9ab5-059de28814b7",
        "body" : "They could likely also go away in favor of using the module versions everywhere. They were left in for compat, but that may not be needed.\n",
        "createdAt" : "2016-09-15T19:56:58Z",
        "updatedAt" : "2016-09-15T22:27:09Z",
        "lastEditedBy" : "fa0144fc-7424-474a-9ab5-059de28814b7",
        "tags" : [
        ]
      },
      {
        "id" : "8ec48546-cbd1-4f82-943c-7c9fee55743d",
        "parentId" : "7f279b17-f6c4-451d-ab75-94a35a3b9249",
        "authorId" : "838eb58c-0fa8-4742-994f-a407c7183e57",
        "body" : "<nod>  I already put deprecation messages in with the idea that they would go away in 2.4.  If we do code up a context-aware is_encrypted function, we'll then be able to bring them back with the new behaviour if we want.\n",
        "createdAt" : "2016-09-15T20:39:52Z",
        "updatedAt" : "2016-09-15T22:27:09Z",
        "lastEditedBy" : "838eb58c-0fa8-4742-994f-a407c7183e57",
        "tags" : [
        ]
      }
    ],
    "commit" : "e70066a6f72b2d786b2fb782aceedad2a9c3a12e",
    "line" : 117,
    "diffHunk" : "@@ -1,1 +171,175 @@\n    @staticmethod\n    def is_encrypted(data):\n        \"\"\" Test if this is vault encrypted data\n"
  },
  {
    "id" : "b36ab569-bc1d-4932-ba0c-574a8961e991",
    "prId" : 25560,
    "prUrl" : "https://github.com/ansible/ansible/pull/25560#pullrequestreview-43289683",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c82201ef-e63e-4339-8713-88802caef5fd",
        "parentId" : null,
        "authorId" : "17b892bb-a94e-4ec8-8b73-2d773dc12bae",
        "body" : "CTR mode doesn't actually require padding, so this is unnecessary. That said, I assume you're staying compatible with existing vault implementations which already do this. It's not a security thing, just a few wasted bytes/CPU cycles.",
        "createdAt" : "2017-06-10T01:33:19Z",
        "updatedAt" : "2017-06-12T20:18:34Z",
        "lastEditedBy" : "17b892bb-a94e-4ec8-8b73-2d773dc12bae",
        "tags" : [
        ]
      },
      {
        "id" : "48748e64-8e96-4203-8801-f084071e1d80",
        "parentId" : "c82201ef-e63e-4339-8713-88802caef5fd",
        "authorId" : "30fc1801-f8f1-4cc4-9690-e31e203f4f6d",
        "body" : "yes, we've been wanting to change that for a while but were waiting until we made the architecture more pluggable to allow for old/new formats to be used transparently.",
        "createdAt" : "2017-06-10T03:53:07Z",
        "updatedAt" : "2017-06-12T20:18:34Z",
        "lastEditedBy" : "30fc1801-f8f1-4cc4-9690-e31e203f4f6d",
        "tags" : [
        ]
      }
    ],
    "commit" : "1f1bd4cec3baf71af86bf9b442518a040716df99",
    "line" : 403,
    "diffHunk" : "@@ -1,1 +781,785 @@        cipher = C_Cipher(algorithms.AES(b_key1), modes.CTR(b_iv), CRYPTOGRAPHY_BACKEND)\n        encryptor = cipher.encryptor()\n        padder = padding.PKCS7(algorithms.AES.block_size).padder()\n        b_ciphertext = encryptor.update(padder.update(b_plaintext) + padder.finalize())\n        b_ciphertext += encryptor.finalize()"
  },
  {
    "id" : "f458b5cd-49d5-4a2e-9a1f-aaa54bfc5168",
    "prId" : 25560,
    "prUrl" : "https://github.com/ansible/ansible/pull/25560#pullrequestreview-43549019",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d7941d18-7a02-4d8f-b3f3-8ddd8dba94ba",
        "parentId" : null,
        "authorId" : "311820dd-fcb9-46df-a201-9c0e7d6fac58",
        "body" : "Do we know a minimum version we could specify?",
        "createdAt" : "2017-06-12T16:30:15Z",
        "updatedAt" : "2017-06-12T20:18:34Z",
        "lastEditedBy" : "311820dd-fcb9-46df-a201-9c0e7d6fac58",
        "tags" : [
        ]
      },
      {
        "id" : "d6a8a81c-a787-4eaa-9a32-4faa8ab147db",
        "parentId" : "d7941d18-7a02-4d8f-b3f3-8ddd8dba94ba",
        "authorId" : "838eb58c-0fa8-4742-994f-a407c7183e57",
        "body" : "It may be pycrypto 2.6 but I'm not sure.  2.6 is the minimum version that was specified in the requirements.txt file (in code in setup.py after this patch).  If you want to do some research and update the patch.... The message as written isn't a regression, though...",
        "createdAt" : "2017-06-12T20:12:11Z",
        "updatedAt" : "2017-06-12T20:18:34Z",
        "lastEditedBy" : "838eb58c-0fa8-4742-994f-a407c7183e57",
        "tags" : [
        ]
      }
    ],
    "commit" : "1f1bd4cec3baf71af86bf9b442518a040716df99",
    "line" : 128,
    "diffHunk" : "@@ -1,1 +92,96 @@NEED_CRYPTO_LIBRARY = \"ansible-vault requires either the cryptography library (preferred) or\"\nif HAS_SOME_PYCRYPTO:\n    NEED_CRYPTO_LIBRARY += \" a newer version of\"\nNEED_CRYPTO_LIBRARY += \" pycrypto in order to function.\"\n"
  }
]
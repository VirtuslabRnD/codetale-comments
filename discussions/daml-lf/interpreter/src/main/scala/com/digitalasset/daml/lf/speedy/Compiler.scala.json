[
  {
    "id" : "f924d683-df9f-4c10-b0cc-11d0060367c9",
    "prId" : 9871,
    "prUrl" : "https://github.com/digital-asset/daml/pull/9871",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4ccbd398-dfac-4dba-9cc3-5809d98445f4",
        "parentId" : null,
        "authorId" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "body" : "why do we crash here? Because all errors should be caught during preprocessing & validation? Maybe worth adding a comment",
        "createdAt" : "2021-06-02T06:52:20Z",
        "updatedAt" : "2021-06-02T07:52:30Z",
        "lastEditedBy" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "tags" : [
        ]
      },
      {
        "id" : "051159ac-a8b1-49ab-a2b7-7587988d49dc",
        "parentId" : "4ccbd398-dfac-4dba-9cc3-5809d98445f4",
        "authorId" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "body" : "20b2bb95da79a10d962f2fe57d22cb08f5825bc3",
        "createdAt" : "2021-06-02T10:19:20Z",
        "updatedAt" : "2021-06-02T10:22:15Z",
        "lastEditedBy" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "tags" : [
        ]
      }
    ],
    "commit" : "bdfe9d85e856787c99491635de227d6f487571ee",
    "line" : 41,
    "diffHunk" : "@@ -1,1 +132,136 @@  import Compiler._\n\n  private[this] def handleLookup[X](x: Either[LookupError, X]) =\n    x match {\n      case Right(value) => value"
  },
  {
    "id" : "7227e54c-7b6a-4de2-a4e7-b768c168a976",
    "prId" : 9528,
    "prUrl" : "https://github.com/digital-asset/daml/pull/9528",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4f38d63c-a05a-4fb6-8794-349ef503a067",
        "parentId" : null,
        "authorId" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "body" : "mostly to shut up the exhaustiveness checker. We really don’t want to write all those functions exhaustively.",
        "createdAt" : "2021-04-29T07:27:55Z",
        "updatedAt" : "2021-04-29T09:04:19Z",
        "lastEditedBy" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "tags" : [
        ]
      }
    ],
    "commit" : "94275008086af6fa6c1f971d095f7d2c1a71e9ac",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +237,241 @@      arity: Int,\n  )(\n      body: PartialFunction[List[Position], SExpr]\n  ): (SDefRef, SDefinition) =\n    ref ->"
  },
  {
    "id" : "d54c9cc3-28c3-4b07-9922-6b240473bf3a",
    "prId" : 9151,
    "prUrl" : "https://github.com/digital-asset/daml/pull/9151",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2d411472-37cd-4a58-a375-cd3ef4c99757",
        "parentId" : null,
        "authorId" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "body" : "This was just broken. We want the label around the closure. Otherwise, we get to https://github.com/digital-asset/daml/blob/98c2651998cce1fd1b8776e488d8f8cfbcf3023d/daml-lf/interpreter/src/main/scala/com/digitalasset/daml/lf/speedy/Speedy.scala#L1429 and we don’t have a closure and we don’t generate any entries. If you look at the original PR https://github.com/digital-asset/daml/commit/caedc7255111d564d872e70582c371086b30a679# that’s also what happened there afaict. Haven’t tracked down when exactly it broke. That’s why we should have tests for things :slightly_smiling_face: ",
        "createdAt" : "2021-03-16T14:49:20Z",
        "updatedAt" : "2021-03-16T18:36:31Z",
        "lastEditedBy" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "tags" : [
        ]
      },
      {
        "id" : "75c7e148-a887-441a-9d7a-66979e7305e8",
        "parentId" : "2d411472-37cd-4a58-a375-cd3ef4c99757",
        "authorId" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "body" : "Not sure I should review this PR as I am the culprit for the mess and I not sure I understand how this work.\r\n",
        "createdAt" : "2021-03-16T19:12:20Z",
        "updatedAt" : "2021-03-16T19:13:20Z",
        "lastEditedBy" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "tags" : [
        ]
      },
      {
        "id" : "b84edaea-8358-4a73-8502-331a76698c12",
        "parentId" : "2d411472-37cd-4a58-a375-cd3ef4c99757",
        "authorId" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "body" : "The culprit is not having tests not changing code :slightly_smiling_face: \r\n\r\nLet me try to provide some more context: First in terms of the tests you can easily see the difference. Without this change, we don’t get any of the create and exercise nodes. This is clearly wrong.\r\n\r\nNow how does profiling work?\r\n1. In the compiler we wrap `SELabelClosure` around some closures, e.g., this one (the fact that we didn’t wrap it around the closure anymore already indicates that it was probably broken).\r\n2. When executing `SELabelClosure` we push a `KLabelClosure`.\r\n3. When we execute `KLabelClosure`, the return value should now be a closure. We add the label stored in `KLabelClosure` to that closure.\r\n4. Now when we get to the `KFun` that applies this closure, we start the timer for the label of the closure and we push a `KLeaveClosure`.\r\n5. When executing `KLeaveClosure we stop the timer for the label.\r\n\r\nEverything here is centered around timing the application of a closure. Afaict, `KLabelClosure` should even just error out if it doesn’t get a closure but I’ll leave that for a separate PR.\r\n\r\nDoes that help?",
        "createdAt" : "2021-03-16T19:20:37Z",
        "updatedAt" : "2021-03-16T19:20:37Z",
        "lastEditedBy" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "tags" : [
        ]
      },
      {
        "id" : "f81a1dc6-c4a4-4b5d-b059-25169488d6c2",
        "parentId" : "2d411472-37cd-4a58-a375-cd3ef4c99757",
        "authorId" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "body" : "make sens.",
        "createdAt" : "2021-03-17T10:26:03Z",
        "updatedAt" : "2021-03-17T10:26:03Z",
        "lastEditedBy" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "tags" : [
        ]
      }
    ],
    "commit" : "67983713673813901d4331aa01769b1fb4059694",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +244,248 @@      SDefinition(\n        unsafeClosureConvert(\n          withLabel(ref, SEAbs(arity, body(List.fill(arity)(nextPosition()))))\n        )\n      )"
  },
  {
    "id" : "6e638da9-6c24-4fe5-9664-80ba5c2c1cd6",
    "prId" : 8878,
    "prUrl" : "https://github.com/digital-asset/daml/pull/8878",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bfe03df1-c6ef-496a-8291-171699143322",
        "parentId" : null,
        "authorId" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "body" : "Why do we need a separate `SEScopeExercise` can we just push the continuation in BeginExercise or alternatively push what we do in beginexercise in scopexercise?",
        "createdAt" : "2021-02-17T16:40:25Z",
        "updatedAt" : "2021-02-18T09:18:33Z",
        "lastEditedBy" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "tags" : [
        ]
      },
      {
        "id" : "98ddf603-2d56-458e-ad24-139e46d173e9",
        "parentId" : "bfe03df1-c6ef-496a-8291-171699143322",
        "authorId" : "43409235-97e4-48dc-9ec7-403ee0a7de54",
        "body" : "You can't push the continuation in `SBUBeginExercise` because the scope is compiled to encompass the _begin_ and the _update_.\r\n\r\nI considered moving/inlining the code of the existing `SBUBeginExercise` into the new `SEScopeExercise`, but this seemed quite disruptive (making the PR harder to review) with minimal benefit if any.\r\n",
        "createdAt" : "2021-02-18T09:01:28Z",
        "updatedAt" : "2021-02-18T09:18:33Z",
        "lastEditedBy" : "43409235-97e4-48dc-9ec7-403ee0a7de54",
        "tags" : [
        ]
      },
      {
        "id" : "d1352e16-5e69-4e4c-b517-c4f0491e65f3",
        "parentId" : "bfe03df1-c6ef-496a-8291-171699143322",
        "authorId" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "body" : "Makes sense :+1:",
        "createdAt" : "2021-02-18T09:26:48Z",
        "updatedAt" : "2021-02-18T09:26:48Z",
        "lastEditedBy" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "tags" : [
        ]
      }
    ],
    "commit" : "2bf5232f09563327b27fed9a4f50365b5e09174b",
    "line" : 28,
    "diffHunk" : "@@ -1,1 +944,948 @@    let(SBUFetch(tmplId)(svar(cidPos))) { tmplArgPos =>\n      addExprVar(tmpl.param, tmplArgPos)\n      SEScopeExercise(\n        let(\n          SBUBeginExercise(tmplId, choice.name, choice.consuming, byKey = mbKey.isDefined)("
  },
  {
    "id" : "b689dff8-f849-473a-8599-888db59b450d",
    "prId" : 8612,
    "prUrl" : "https://github.com/digital-asset/daml/pull/8612",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f5db0236-146f-43a6-98d3-ce45a6738234",
        "parentId" : null,
        "authorId" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "body" : "```suggestion\r\n  private def compileExceptionMessage(ty: Type): SExpr = {\r\n```",
        "createdAt" : "2021-02-11T08:24:09Z",
        "updatedAt" : "2021-02-15T09:27:14Z",
        "lastEditedBy" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "tags" : [
        ]
      }
    ],
    "commit" : "0a7c69fbff2aaee6c8500bf0826a79cf0cd9f356",
    "line" : 37,
    "diffHunk" : "@@ -1,1 +448,452 @@    }\n\n  private def compileExceptionType(ty: Type): SExpr = {\n    ty match {\n      case TGeneralError | TArithmeticError | TContractError =>"
  },
  {
    "id" : "680f0098-e352-4fc3-8786-565a7f0f1a16",
    "prId" : 8612,
    "prUrl" : "https://github.com/digital-asset/daml/pull/8612",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5ee935e7-f3a9-46bd-80fc-2a5af6e7258e",
        "parentId" : null,
        "authorId" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "body" : "Is there a fundamental reason why type parameters in exceptions are problematic? Of course, they have to be instantiated when throwing but apart from that, it doesn’t seem that odd to allow them. Then again, even in Haskell, I don’t think I’ve seen exception types with type parameters so I think it’s a perfectly sensible design decision. Just wondering if there’s a technical reason where they cause issues.",
        "createdAt" : "2021-02-11T08:28:20Z",
        "updatedAt" : "2021-02-15T09:27:14Z",
        "lastEditedBy" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "tags" : [
        ]
      },
      {
        "id" : "b752fe4a-5465-45a1-bbe7-a0c360e25c4a",
        "parentId" : "5ee935e7-f3a9-46bd-80fc-2a5af6e7258e",
        "authorId" : "43409235-97e4-48dc-9ec7-403ee0a7de54",
        "body" : "@sofiafaro-da ",
        "createdAt" : "2021-02-11T11:29:17Z",
        "updatedAt" : "2021-02-15T09:27:14Z",
        "lastEditedBy" : "43409235-97e4-48dc-9ec7-403ee0a7de54",
        "tags" : [
        ]
      },
      {
        "id" : "c8a99e67-eb31-4b8c-966a-b6cfc5fa4f39",
        "parentId" : "5ee935e7-f3a9-46bd-80fc-2a5af6e7258e",
        "authorId" : "f7ed27fc-83ac-401f-af8b-91c645eda7e9",
        "body" : "I think the idea was that this would be good enough for now, and we'll add type parameters if/when we figure out generic templates as well.",
        "createdAt" : "2021-02-11T11:48:37Z",
        "updatedAt" : "2021-02-15T09:27:14Z",
        "lastEditedBy" : "f7ed27fc-83ac-401f-af8b-91c645eda7e9",
        "tags" : [
        ]
      },
      {
        "id" : "57b23caf-9b13-4507-9d33-a2fece6c6a5b",
        "parentId" : "5ee935e7-f3a9-46bd-80fc-2a5af6e7258e",
        "authorId" : "f7ed27fc-83ac-401f-af8b-91c645eda7e9",
        "body" : "Also not sure how you'd expose the throwing of polymorphic exception types in DAML without allowing type parameters in `throw` or `toAnyException`, unless you had a similar instantiation mechanism to the one we had for generic templates.",
        "createdAt" : "2021-02-11T12:19:25Z",
        "updatedAt" : "2021-02-15T09:27:14Z",
        "lastEditedBy" : "f7ed27fc-83ac-401f-af8b-91c645eda7e9",
        "tags" : [
        ]
      },
      {
        "id" : "0181512d-67c5-4cb4-ac1b-4efedacd2c39",
        "parentId" : "5ee935e7-f3a9-46bd-80fc-2a5af6e7258e",
        "authorId" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "body" : "I’m not suggesting to throw polymorphic types. I’m asking (definitely not suggesting) if we could throw `E Int` where `E` is a polymorphic type but all type variables are instantiated so the type you pass to `throw` has no free type variables. I’m not sure the comparison to generic templates is apt here. It seems closer to serializability and that definitely is supported for such types (for example, choice parameters can actually be such a type, damlc just doesn’t generate them).",
        "createdAt" : "2021-02-11T12:22:10Z",
        "updatedAt" : "2021-02-15T09:27:14Z",
        "lastEditedBy" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "tags" : [
        ]
      },
      {
        "id" : "645da004-cc80-43d9-9683-468f3cbc2b4a",
        "parentId" : "5ee935e7-f3a9-46bd-80fc-2a5af6e7258e",
        "authorId" : "f7ed27fc-83ac-401f-af8b-91c645eda7e9",
        "body" : "I wasn't suggesting that you were suggesting that you can throw types with free type variables or anything like that. You'd only ever want to `throw @(E Int)` for example. The problem is how to lift that restriction up to DAML. The issue I'm talking about is how you'd implement the `HasThrow` and `HasToAnyException` instances for a polymorphic exception type (like your `E`) in DAML. You'd need separate exception instances at each type you want to throw, e.g. `instance HasThrow (E Int)` and `instance HasToAnyException (E Int)`, and, presumably, some mechanism for creating these special instances, like we used to have for generic templates. It's a big can of worms.",
        "createdAt" : "2021-02-11T14:00:48Z",
        "updatedAt" : "2021-02-15T09:27:14Z",
        "lastEditedBy" : "f7ed27fc-83ac-401f-af8b-91c645eda7e9",
        "tags" : [
        ]
      },
      {
        "id" : "2d652c20-e109-4eb3-9d81-fed17bcbafc3",
        "parentId" : "5ee935e7-f3a9-46bd-80fc-2a5af6e7258e",
        "authorId" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "body" : "Oh I see, that makes sense. Definitely not a can of worms, I want to open atm.",
        "createdAt" : "2021-02-11T14:02:41Z",
        "updatedAt" : "2021-02-15T09:27:14Z",
        "lastEditedBy" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "tags" : [
        ]
      }
    ],
    "commit" : "0a7c69fbff2aaee6c8500bf0826a79cf0cd9f356",
    "line" : 41,
    "diffHunk" : "@@ -1,1 +452,456 @@      case TGeneralError | TArithmeticError | TContractError =>\n        SEBuiltin(SBBuiltinErrorMessage)\n      case TTyCon(tyCon) =>\n        SEVal(ExceptionMessageDefRef(tyCon))\n      case _ =>"
  },
  {
    "id" : "278ec150-4af3-4bac-bd00-00d4f79e9619",
    "prId" : 8612,
    "prUrl" : "https://github.com/digital-asset/daml/pull/8612",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c59b6f3c-bf9b-4524-825e-4b7eb9ea6bcf",
        "parentId" : null,
        "authorId" : "f7ed27fc-83ac-401f-af8b-91c645eda7e9",
        "body" : "1. Can you take me through the decision to wrap up the exception in an `AnyException` value here, before throwing? This was definitely part of an earlier design of the LF (but as we discussed, Martin & I decided to restrict throws in LF to only known exception types).\r\n\r\n2. The message function is associated with the thrown value? Isn't this something you can get from the type `ty`?",
        "createdAt" : "2021-02-11T12:12:56Z",
        "updatedAt" : "2021-02-15T09:27:14Z",
        "lastEditedBy" : "f7ed27fc-83ac-401f-af8b-91c645eda7e9",
        "tags" : [
        ]
      },
      {
        "id" : "93d3de72-2f8c-46f5-91bd-3f9bd5e54a30",
        "parentId" : "c59b6f3c-bf9b-4524-825e-4b7eb9ea6bcf",
        "authorId" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "body" : "For 1, you need the type of the exception that is thrown so you can check it in the handler. I agree the current implementation is a bit confusing by reusing `AnyException` for this (and is perhaps missing unwrapping it in some places although I think I didn’t find any) but you need to tuple the type up with the exception somehow.\r\n\r\n2, yeah, see my question on merging it with `SAny`.",
        "createdAt" : "2021-02-11T12:17:32Z",
        "updatedAt" : "2021-02-15T09:27:14Z",
        "lastEditedBy" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "tags" : [
        ]
      },
      {
        "id" : "315814d5-172d-42be-9240-11dfe0dc4e32",
        "parentId" : "c59b6f3c-bf9b-4524-825e-4b7eb9ea6bcf",
        "authorId" : "f7ed27fc-83ac-401f-af8b-91c645eda7e9",
        "body" : "Ah, I agree you need to know the type when throwing it, just not sure it made sense to do it here instead of doing it in SBThrow (like the LF spec says).",
        "createdAt" : "2021-02-11T12:45:46Z",
        "updatedAt" : "2021-02-15T09:27:14Z",
        "lastEditedBy" : "f7ed27fc-83ac-401f-af8b-91c645eda7e9",
        "tags" : [
        ]
      },
      {
        "id" : "d6149cee-c3da-40e0-93b0-e2f39ee9c3d0",
        "parentId" : "c59b6f3c-bf9b-4524-825e-4b7eb9ea6bcf",
        "authorId" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "body" : "Oh I see, yeah agreed `SBThrow` is probably more sensible.",
        "createdAt" : "2021-02-11T12:47:02Z",
        "updatedAt" : "2021-02-15T09:27:14Z",
        "lastEditedBy" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "tags" : [
        ]
      },
      {
        "id" : "a435e46b-8000-410d-8ead-f67f80b027b5",
        "parentId" : "c59b6f3c-bf9b-4524-825e-4b7eb9ea6bcf",
        "authorId" : "43409235-97e4-48dc-9ec7-403ee0a7de54",
        "body" : "\r\nThere are two things a runtime value representing a value of type `AnyException` must be able to support: (1) `EFromAnyException(expect-ty)` and (2) `BAnyExceptionMessage`, so it seems natural for the runtime representation `SAnyException` to contain the triple of (payload-value,actual-ty,message-func)\r\n\r\nIt's possible, as Moritz suggests, that the message-func might be elided. However, this strikes me as slightly odd, as it requires the (new) speedy compiler function `compileExceptionType` to be called at speedy runtime.\r\n\r\nSince both `BAnyExceptionMessage` and `EFromAnyException` can be applied to arbitrary expressions, the `SAnyException` must be created independently of throwing.\r\n\r\nRegarding how `EThrow` is supported... the code in (speedy) Compiler make this clear:\r\n\r\n```\r\n      case EFromAnyException(ty, e) =>\r\n        SBFromAnyException(ty)(compile(e))\r\n      case EThrow(_, ty, e) =>\r\n        val messageFunction = compileExceptionType(ty)\r\n        SBThrow(SBToAnyException(ty, messageFunction)(compile(e)))\r\n```\r\n\r\nThe LF expression `EThrow` is compiled so the two stages are made explicit: `SBToAnyException` and `SBThrow`\r\n\r\nAlthough the LF semantics restricts throw to only known exception types, the speedy runtime version of throw (`SBThrow`) doesn't care. It can throw any value (which is excepted to have runtime representation `SAnyException`). This makes sense also when you consider the execution of selective handlers... if a handler refuses to handle (returns `None`) then the `AnyException` value being thrown has already been constructed and the re-throw has to handle whatever it is.\r\n",
        "createdAt" : "2021-02-11T13:49:37Z",
        "updatedAt" : "2021-02-15T09:27:14Z",
        "lastEditedBy" : "43409235-97e4-48dc-9ec7-403ee0a7de54",
        "tags" : [
        ]
      },
      {
        "id" : "68bfc79b-01df-41dd-ac7b-20e8d523cb13",
        "parentId" : "c59b6f3c-bf9b-4524-825e-4b7eb9ea6bcf",
        "authorId" : "f7ed27fc-83ac-401f-af8b-91c645eda7e9",
        "body" : "Ok, regarding `SBThrow` (i.e. question 1), I think this is fine. It's an implementation detail whether to wrap the exception up here, or inside SBThrow, so as long as it makes sense and respects the semantics, it shouldn't matter. \r\n\r\nHowever, regarding the message function (i.e. question 2), I think moving `compileExceptionType` out of the compiler and doing the type-based dispatch only in `anyExceptionMessage` makes more sense than precomputing the `messageFunction` here and above and then having to carry it all over the place.\r\n\r\nYou will presumably sometimes get exception values at run time (e.g. when communicating with the ledger ... or when running daml script and getting the result of an unhandled exception), and there you're only transmitting the type and fields. So computing the message function only when needed makes more sense to me.",
        "createdAt" : "2021-02-11T14:22:21Z",
        "updatedAt" : "2021-02-15T09:27:14Z",
        "lastEditedBy" : "f7ed27fc-83ac-401f-af8b-91c645eda7e9",
        "tags" : [
        ]
      },
      {
        "id" : "72bb0e4e-4967-4485-9e87-742d8e0a4755",
        "parentId" : "c59b6f3c-bf9b-4524-825e-4b7eb9ea6bcf",
        "authorId" : "f7ed27fc-83ac-401f-af8b-91c645eda7e9",
        "body" : "That said ... I think it's fine to leave it for now and maybe just keep in mind for future that it might be better to compute the message function only inside the `anyExceptionMessage` primitive.",
        "createdAt" : "2021-02-11T14:44:08Z",
        "updatedAt" : "2021-02-15T09:27:14Z",
        "lastEditedBy" : "f7ed27fc-83ac-401f-af8b-91c645eda7e9",
        "tags" : [
        ]
      },
      {
        "id" : "1853e245-d80c-4dfc-808c-e03613f72ff4",
        "parentId" : "c59b6f3c-bf9b-4524-825e-4b7eb9ea6bcf",
        "authorId" : "43409235-97e4-48dc-9ec7-403ee0a7de54",
        "body" : "Ok. I didn't change anything for the moment.",
        "createdAt" : "2021-02-12T13:36:25Z",
        "updatedAt" : "2021-02-15T09:27:14Z",
        "lastEditedBy" : "43409235-97e4-48dc-9ec7-403ee0a7de54",
        "tags" : [
        ]
      }
    ],
    "commit" : "0a7c69fbff2aaee6c8500bf0826a79cf0cd9f356",
    "line" : 34,
    "diffHunk" : "@@ -1,1 +445,449 @@      case EThrow(_, ty, e) =>\n        val messageFunction = compileExceptionType(ty)\n        SBThrow(SBToAnyException(ty, messageFunction)(compile(e)))\n    }\n"
  },
  {
    "id" : "6140d2c2-7a37-4115-9120-04c8af995929",
    "prId" : 7778,
    "prUrl" : "https://github.com/digital-asset/daml/pull/7778",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2f3bf817-9786-47c0-801e-55b6a9d4833f",
        "parentId" : null,
        "authorId" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "body" : "Why not something like: \r\n\r\n```scala\r\n   val builtin = structProj.fieldIndex.fold(SBStructProjByName(structProj.field))(SBStructProj)\r\n   builtin.apply(compile(structProj.struct))\r\n```",
        "createdAt" : "2020-10-22T12:08:32Z",
        "updatedAt" : "2020-10-23T11:11:16Z",
        "lastEditedBy" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "tags" : [
        ]
      },
      {
        "id" : "b683673e-c1ec-4524-a02e-22367a89f4b9",
        "parentId" : "2f3bf817-9786-47c0-801e-55b6a9d4833f",
        "authorId" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "body" : "I simply don't like `fold` on `Option`. Whenever I see `fold`, I need to stop for a moment and run a type inference in my head. I don't need to do this with pattern matching. Thus, I'm avoiding to produce code I _personally_ find harder to read, although I won't stop others from using `fold`.",
        "createdAt" : "2020-10-22T12:17:37Z",
        "updatedAt" : "2020-10-23T11:11:16Z",
        "lastEditedBy" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "tags" : [
        ]
      },
      {
        "id" : "c9a8e7b5-3593-436a-8b28-3793575af072",
        "parentId" : "2f3bf817-9786-47c0-801e-55b6a9d4833f",
        "authorId" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "body" : "No problem, it was just a suggestion. ",
        "createdAt" : "2020-10-22T12:19:37Z",
        "updatedAt" : "2020-10-23T11:11:16Z",
        "lastEditedBy" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "tags" : [
        ]
      },
      {
        "id" : "43406c42-deef-4ce5-9446-a403e50062a4",
        "parentId" : "2f3bf817-9786-47c0-801e-55b6a9d4833f",
        "authorId" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "body" : "I know. Apologies if I came across as aggressive!\r\n\r\nMy goal was to share my motivation for doing things the way I do them. 😃 ",
        "createdAt" : "2020-10-22T12:34:30Z",
        "updatedAt" : "2020-10-23T11:11:16Z",
        "lastEditedBy" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "tags" : [
        ]
      }
    ],
    "commit" : "6ef549582f052ca0d9abd09ff2f154d159b01849",
    "line" : 9,
    "diffHunk" : "@@ -1,1 +379,383 @@          case None => SBStructProjByName(structProj.field)(compile(structProj.struct))\n          case Some(index) => SBStructProj(index)(compile(structProj.struct))\n        }\n      case structUpd: EStructUpd =>\n        structUpd.fieldIndex match {"
  },
  {
    "id" : "ac2bb550-2634-4c23-a518-2f0515c4e235",
    "prId" : 7502,
    "prUrl" : "https://github.com/digital-asset/daml/pull/7502",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0920591a-0cf0-43e7-bfdc-be132d942361",
        "parentId" : null,
        "authorId" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "body" : "Is there a reason why we used a list here? A map seems like a much more natural choice and better in basically every regard so I wonder if I’m missing something here.",
        "createdAt" : "2020-09-29T09:34:55Z",
        "updatedAt" : "2020-09-29T11:21:22Z",
        "lastEditedBy" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "tags" : [
        ]
      },
      {
        "id" : "10f8fb52-453b-4ac2-a496-e26ce344bb3c",
        "parentId" : "0920591a-0cf0-43e7-bfdc-be132d942361",
        "authorId" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "body" : "I think the original idea was to represent a stack and to be able to \"pop\" the changes made to it. \r\nIn the current design this is not used, so better a `Map`.  ",
        "createdAt" : "2020-09-29T11:04:02Z",
        "updatedAt" : "2020-09-29T11:21:22Z",
        "lastEditedBy" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "tags" : [
        ]
      }
    ],
    "commit" : "b40b0bfe202a7aee4497efacd8666fa6d9ff2a47",
    "line" : 87,
    "diffHunk" : "@@ -1,1 +183,187 @@  private[this] case class Env(\n      position: Int = 0,\n      varIndices: Map[VarRef, Position] = Map.empty,\n  )\n"
  },
  {
    "id" : "c968df34-3425-42e1-9ecc-c0048c953630",
    "prId" : 7502,
    "prUrl" : "https://github.com/digital-asset/daml/pull/7502",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c5876d09-29f8-4a21-bb00-8e14672b0c76",
        "parentId" : null,
        "authorId" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "body" : "If we have an overload for `exprVar` should we also have an overload for typevar? (or a helper, as mentioned above, I’m not entirely convinced the overload is helpful).",
        "createdAt" : "2020-09-29T09:37:57Z",
        "updatedAt" : "2020-09-29T11:21:22Z",
        "lastEditedBy" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "tags" : [
        ]
      },
      {
        "id" : "7a77e861-f565-4baf-b121-bf44dba5c583",
        "parentId" : "c5876d09-29f8-4a21-bb00-8e14672b0c76",
        "authorId" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "body" : "no more overload.",
        "createdAt" : "2020-09-29T11:13:27Z",
        "updatedAt" : "2020-09-29T11:21:22Z",
        "lastEditedBy" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "tags" : [
        ]
      }
    ],
    "commit" : "b40b0bfe202a7aee4497efacd8666fa6d9ff2a47",
    "line" : 141,
    "diffHunk" : "@@ -1,1 +699,703 @@        compileAbss(body, arity + 1)\n      case ETyAbs((binder, KNat), body) =>\n        addTypeVar(binder, nextPosition())\n        compileAbss(body, arity + 1)\n      case ETyAbs((binder, _), body) =>"
  },
  {
    "id" : "89f78d61-d2fb-40a4-99ba-fedb362d12e0",
    "prId" : 7493,
    "prUrl" : "https://github.com/digital-asset/daml/pull/7493",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a9e33053-ca1b-4708-906e-d9ec0eb9eabd",
        "parentId" : null,
        "authorId" : "43409235-97e4-48dc-9ec7-403ee0a7de54",
        "body" : "Is it better to call `SELet1` ?",
        "createdAt" : "2020-09-30T13:43:27Z",
        "updatedAt" : "2020-09-30T14:33:52Z",
        "lastEditedBy" : "43409235-97e4-48dc-9ec7-403ee0a7de54",
        "tags" : [
        ]
      },
      {
        "id" : "497f764a-8e9f-4cc7-9c52-ed05d9cc9d89",
        "parentId" : "a9e33053-ca1b-4708-906e-d9ec0eb9eabd",
        "authorId" : null,
        "body" : "Do we now use `SELet` anywhere? Can we drop it?",
        "createdAt" : "2020-09-30T14:18:25Z",
        "updatedAt" : "2020-09-30T14:33:52Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "f593b4cc-d0a3-4b14-94da-5f64f2af358e",
        "parentId" : "a9e33053-ca1b-4708-906e-d9ec0eb9eabd",
        "authorId" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "body" : "Why not `SELet` ? in any case on another PR.  ",
        "createdAt" : "2020-09-30T14:21:05Z",
        "updatedAt" : "2020-09-30T14:33:52Z",
        "lastEditedBy" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "tags" : [
        ]
      },
      {
        "id" : "97514595-2386-46fa-b320-4908154f4a8e",
        "parentId" : "a9e33053-ca1b-4708-906e-d9ec0eb9eabd",
        "authorId" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "body" : "@dajmaki we will drop the SELet in another PR. \r\n",
        "createdAt" : "2020-09-30T14:28:34Z",
        "updatedAt" : "2020-09-30T14:33:52Z",
        "lastEditedBy" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "tags" : [
        ]
      }
    ],
    "commit" : "3b7b7df864922c41c0f30f2baaa1dc25eff5218e",
    "line" : 50,
    "diffHunk" : "@@ -1,1 +201,205 @@\n  private[this] def let(bound: SExpr)(body: Position => SExpr) =\n    SELet1General(bound, body(nextPosition()))\n\n  private[this] def unaryFunction(body: Position => SExpr): SExpr ="
  },
  {
    "id" : "d116aa8a-0a5a-4fe4-b7b1-06842f109aa5",
    "prId" : 7493,
    "prUrl" : "https://github.com/digital-asset/daml/pull/7493",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5c020e4e-48c1-4fca-832b-9532c59990f2",
        "parentId" : null,
        "authorId" : "43409235-97e4-48dc-9ec7-403ee0a7de54",
        "body" : "I really like the look of this! :+1: ",
        "createdAt" : "2020-09-30T13:51:50Z",
        "updatedAt" : "2020-09-30T14:33:52Z",
        "lastEditedBy" : "43409235-97e4-48dc-9ec7-403ee0a7de54",
        "tags" : [
        ]
      }
    ],
    "commit" : "3b7b7df864922c41c0f30f2baaa1dc25eff5218e",
    "line" : 218,
    "diffHunk" : "@@ -1,1 +761,765 @@            let(SBSBeginCommit(optLoc)(svar(partyPos), svar(tokenPos))) { _ =>\n              let(app(svar(updatePos), svar(tokenPos))) { resultPos =>\n                SBSEndCommit(mustFail = false)(svar(resultPos), svar(tokenPos))\n              }\n            }"
  },
  {
    "id" : "e8cf67b8-96c0-4662-a387-664a3bbe777b",
    "prId" : 7472,
    "prUrl" : "https://github.com/digital-asset/daml/pull/7472",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "53eca696-5d85-4cd1-ad29-fc856c41f7e4",
        "parentId" : null,
        "authorId" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "body" : "There seems to be a lot of duplication between the definition of `ChoiceDefRef` and `ChoiceByKeyDefRef`. I’m not entirely clear why we need `ChoiceByKeyDefRef` at all. What’s stopping us from compiling an `exerciseByKey` into `FetchByKeyDefRef` and `ChoiceDefRef` and removing `ChoiceByKeyDefRef`?",
        "createdAt" : "2020-09-24T06:45:16Z",
        "updatedAt" : "2020-09-28T17:01:45Z",
        "lastEditedBy" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "tags" : [
        ]
      },
      {
        "id" : "6ce9afd5-0ec5-4663-b142-762f84cf87e5",
        "parentId" : "53eca696-5d85-4cd1-ad29-fc856c41f7e4",
        "authorId" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "body" : "If it's possible to do what @cocreature described, I'd be in favor of that too.",
        "createdAt" : "2020-09-24T09:09:10Z",
        "updatedAt" : "2020-09-28T17:01:45Z",
        "lastEditedBy" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "tags" : [
        ]
      },
      {
        "id" : "c32d05b1-5f59-492d-973a-2fe50b65bedf",
        "parentId" : "53eca696-5d85-4cd1-ad29-fc856c41f7e4",
        "authorId" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "body" : "The issue is that the \"by cid\" operations (create, exercise, fetch) have to compute the contract key from the template argument (we need the key in the transaction even if the node was built by \"by cid\" ). On the other hand \"by key\" operation don't have to do, since it is given.\r\n\r\nI  do not see an easy way to factorize as @cocreature suggested without recompute the contract key for each \"by key\" operations.  Note that before my PR, contract key was recomputed for `ExerciseByKey`, but not for `FetchByKey`.\r\n\r\nWe can of course, make a bit of factorization in the Scala code (I would let that for the following PR), but I think it is tricky to do it at the LF level.",
        "createdAt" : "2020-09-24T12:13:51Z",
        "updatedAt" : "2020-09-28T17:01:45Z",
        "lastEditedBy" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "tags" : [
        ]
      },
      {
        "id" : "b696f73b-e4f0-4cf0-9522-6e36a3ee19d2",
        "parentId" : "53eca696-5d85-4cd1-ad29-fc856c41f7e4",
        "authorId" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "body" : "Makes sense, I’m fine with leaving it for a separate PR.",
        "createdAt" : "2020-09-24T13:27:52Z",
        "updatedAt" : "2020-09-28T17:01:45Z",
        "lastEditedBy" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "tags" : [
        ]
      }
    ],
    "commit" : "6f87982ebeaafdd21277c2bc4c42b1f7319643a1",
    "line" : 210,
    "diffHunk" : "@@ -1,1 +968,972 @@\n  /** Compile a choice into a top-level function for exercising that choice */\n  private[this] def compileChoiceByKey(\n      tmplId: TypeConName,\n      tmpl: Template,"
  },
  {
    "id" : "3607bd57-4f87-40b5-b1b7-8c00fe5a55f1",
    "prId" : 7472,
    "prUrl" : "https://github.com/digital-asset/daml/pull/7472",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "cce2a162-60bd-4ec1-8729-229f0aa59c01",
        "parentId" : null,
        "authorId" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "body" : "```suggestion\r\n    //       _ = $beginExercise[tmplId, chId, consuming, byKey = false] <choiceArg> <cid> <actors> sigs obs ctrls mbKey <token>\r\n```",
        "createdAt" : "2020-09-24T10:07:39Z",
        "updatedAt" : "2020-09-28T17:01:45Z",
        "lastEditedBy" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "tags" : [
        ]
      }
    ],
    "commit" : "6f87982ebeaafdd21277c2bc4c42b1f7319643a1",
    "line" : 83,
    "diffHunk" : "@@ -1,1 +899,903 @@    // ChoiceDefRef(SomeTemplate, SomeChoice) = \\<actors> <cid> <choiceArg> <token> ->\n    //   let targ = fetch <cid>\n    //       _ = $beginExercise[tmplId, chId] <choiceArg> <cid> <actors> <byKey flag> sigs obs ctrls mbKey <token>\n    //       result = <updateE>\n    //       _ = $endExercise[tmplId]"
  },
  {
    "id" : "574f734e-1aa8-4763-b76a-87804756d141",
    "prId" : 6440,
    "prUrl" : "https://github.com/digital-asset/daml/pull/6440",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e85b34a5-ff1f-4e0c-a35e-7808572ee166",
        "parentId" : null,
        "authorId" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "body" : "IIRC, this function was already occasionally hitting the limits of stack usage before this change. Linearizing the code using `ELet1*` makes the situation worse. I suggest we rewrite this function using some technique that does not blow up the stack _before_ we merge this change and rebase this change on top of the other one.\r\ncc @remyhaemmerle-da",
        "createdAt" : "2020-06-26T10:57:30Z",
        "updatedAt" : "2020-06-30T15:19:02Z",
        "lastEditedBy" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "tags" : [
        ]
      },
      {
        "id" : "da932a22-ed7d-4e63-8a5f-a4861e9d8e56",
        "parentId" : "e85b34a5-ff1f-4e0c-a35e-7808572ee166",
        "authorId" : "43409235-97e4-48dc-9ec7-403ee0a7de54",
        "body" : "The validate function is fixed now.",
        "createdAt" : "2020-06-30T14:58:39Z",
        "updatedAt" : "2020-06-30T15:19:02Z",
        "lastEditedBy" : "43409235-97e4-48dc-9ec7-403ee0a7de54",
        "tags" : [
        ]
      },
      {
        "id" : "10a7f689-466e-4ba4-ba22-7894a8fc00fd",
        "parentId" : "e85b34a5-ff1f-4e0c-a35e-7808572ee166",
        "authorId" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "body" : "Thank you.",
        "createdAt" : "2020-06-30T16:43:42Z",
        "updatedAt" : "2020-06-30T16:46:27Z",
        "lastEditedBy" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "tags" : [
        ]
      }
    ],
    "commit" : "f1ca0fa6575631a0602ea895e0155fae12fd986b",
    "line" : 177,
    "diffHunk" : "@@ -1,1 +1187,1191 @@  // valiate that we correctly captured all free-variables, and so reference to them is\n  // via the surrounding closure, instead of just finding them higher up on the stack\n  def validate(anf0: AExpr): AExpr = {\n\n    def goV(v: SValue): Unit = {"
  },
  {
    "id" : "16c71168-a898-48e6-9993-e261fb20f51c",
    "prId" : 6003,
    "prUrl" : "https://github.com/digital-asset/daml/pull/6003",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "08bdf258-20a6-4932-8b1a-329ab1e2384f",
        "parentId" : null,
        "authorId" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "body" : "Let me guess, `scalafmt` does that to us. 😦",
        "createdAt" : "2020-05-19T17:13:41Z",
        "updatedAt" : "2020-05-20T09:14:01Z",
        "lastEditedBy" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "tags" : [
        ]
      },
      {
        "id" : "dabed0fa-1d46-45dd-ab52-15af5cc89c60",
        "parentId" : "08bdf258-20a6-4932-8b1a-329ab1e2384f",
        "authorId" : "43409235-97e4-48dc-9ec7-403ee0a7de54",
        "body" : "I guess :man_shrugging: ",
        "createdAt" : "2020-05-20T07:04:09Z",
        "updatedAt" : "2020-05-20T09:14:01Z",
        "lastEditedBy" : "43409235-97e4-48dc-9ec7-403ee0a7de54",
        "tags" : [
        ]
      }
    ],
    "commit" : "ab369bff4b7cfcc541b5335c6c2996cbe061b74d",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +27,31 @@  */\nprivate[lf] object Compiler {\n\n  case class CompilationError(error: String) extends RuntimeException(error, null, true, false)\n  case class PackageNotFound(pkgId: PackageId)"
  },
  {
    "id" : "0e75f467-2530-4543-94ef-e2fcc6872128",
    "prId" : 6003,
    "prUrl" : "https://github.com/digital-asset/daml/pull/6003",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "16148911-7d0c-4e54-85bc-1ac095b2a67a",
        "parentId" : null,
        "authorId" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "body" : "```suggestion\r\n      remaps.get(i).getOrElse(throw CompilationError(s\"remap($i),remaps=$remaps\"))\r\n```",
        "createdAt" : "2020-05-19T17:17:08Z",
        "updatedAt" : "2020-05-20T09:14:01Z",
        "lastEditedBy" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "tags" : [
        ]
      }
    ],
    "commit" : "ab369bff4b7cfcc541b5335c6c2996cbe061b74d",
    "line" : 75,
    "diffHunk" : "@@ -1,1 +1004,1008 @@        case None => throw CompilationError(s\"remap($i),remaps=$remaps\")\n        case Some(loc) => loc\n      }\n    }\n    expr match {"
  },
  {
    "id" : "4519dd5c-e85c-43cd-910f-d4940fb110f7",
    "prId" : 6003,
    "prUrl" : "https://github.com/digital-asset/daml/pull/6003",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c5d344d8-99da-4f05-851d-5a0fc2a53167",
        "parentId" : null,
        "authorId" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "body" : "```suggestion\r\n          i => i -> SELocA(arity - i)\r\n```",
        "createdAt" : "2020-05-19T17:19:01Z",
        "updatedAt" : "2020-05-20T09:14:01Z",
        "lastEditedBy" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "tags" : [
        ]
      }
    ],
    "commit" : "ab369bff4b7cfcc541b5335c6c2996cbe061b74d",
    "line" : 110,
    "diffHunk" : "@@ -1,1 +1026,1030 @@        val newRemapsA = (1 to arity).map {\n          case i =>\n            i -> SELocA(arity - i)\n        }\n        // The keys in newRemapsF and newRemapsA are disjoint"
  },
  {
    "id" : "3f55c8ef-f3ab-459e-a958-51feca03b726",
    "prId" : 6003,
    "prUrl" : "https://github.com/digital-asset/daml/pull/6003",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c9f7d6c9-11bc-4599-b102-db1bd7c8f6aa",
        "parentId" : null,
        "authorId" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "body" : "I assume we didn't need this before because of the `bound` parameter of `closureConvert`. Is that correct?",
        "createdAt" : "2020-05-19T17:21:54Z",
        "updatedAt" : "2020-05-20T09:14:01Z",
        "lastEditedBy" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "tags" : [
        ]
      },
      {
        "id" : "720c3c60-0c91-455f-9bcd-7ecc31042a41",
        "parentId" : "c9f7d6c9-11bc-4599-b102-db1bd7c8f6aa",
        "authorId" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "body" : "?",
        "createdAt" : "2020-05-20T08:25:26Z",
        "updatedAt" : "2020-05-20T09:14:01Z",
        "lastEditedBy" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "tags" : [
        ]
      },
      {
        "id" : "70727643-7c50-40c8-ad0a-93eb6f7c710e",
        "parentId" : "c9f7d6c9-11bc-4599-b102-db1bd7c8f6aa",
        "authorId" : "43409235-97e4-48dc-9ec7-403ee0a7de54",
        "body" : "Yes. previously the re-mapping was performed in a context of absolute stack offsets.\r\nThis was *really really* hard to understand, although perhaps more efficient (at compile time).\r\n\r\nIt would be possible to do this still, at the cost of some confusion.\r\n\r\nBut a further problem is that the (SELocS) values of the map are also relative indexed.\r\nAnd so we either need a new type to represent SELoc-S(absolute)+A+F\r\nOr abuse the existing SELoc type.\r\nNeither choice seems very nice.\r\n\r\nActually, I would prefer if the SELocS could be actually be indexed absolutely.\r\nI think this would be slightly more efficient at runtime.\r\nI did have an experiment, but it runs in to issues regarding the way we handle the recursive builtins.\r\nSo I thought it best to leave this potential change to a later time.",
        "createdAt" : "2020-05-20T09:21:19Z",
        "updatedAt" : "2020-05-20T09:21:19Z",
        "lastEditedBy" : "43409235-97e4-48dc-9ec7-403ee0a7de54",
        "tags" : [
        ]
      }
    ],
    "commit" : "ab369bff4b7cfcc541b5335c6c2996cbe061b74d",
    "line" : 179,
    "diffHunk" : "@@ -1,1 +1086,1090 @@  // And any values in the map which are of the form SELocS must also be _shifted_\n  // because SELocS indexes are also relative to the end of the stack.\n  def shift(remaps: Map[Int, SELoc], n: Int): Map[Int, SELoc] = {\n\n    // We must update both the keys of the map (the relative-indexes from the original SEVar)"
  },
  {
    "id" : "67abcde4-0620-4c3c-bcc6-8828f8146fb9",
    "prId" : 5957,
    "prUrl" : "https://github.com/digital-asset/daml/pull/5957",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e76f2eda-a37a-454a-b6e9-1a2dfb81f41d",
        "parentId" : null,
        "authorId" : "4c501a40-3340-4f35-b66e-fcfb75e20f37",
        "body" : "`{}` are not really part of the function syntax, nor the `case` syntax, irrespective of IDEA's obsession with them. There are occasionally good reasons to use them with functions, but never with `case` per se.\r\n\r\n```suggestion\r\n      case NoProfile => (_, expr) => expr\r\n      case FullProfile => (label, expr) =>\r\n        expr match {\r\n          case SELabelClosure(_, expr1) => SELabelClosure(label, expr1)\r\n          case _ => SELabelClosure(label, expr)\r\n        }\r\n```",
        "createdAt" : "2020-05-15T20:18:22Z",
        "updatedAt" : "2020-05-18T16:23:38Z",
        "lastEditedBy" : "4c501a40-3340-4f35-b66e-fcfb75e20f37",
        "tags" : [
        ]
      },
      {
        "id" : "550a13e5-7ab8-4f7f-bfa5-55691fcb8a5b",
        "parentId" : "e76f2eda-a37a-454a-b6e9-1a2dfb81f41d",
        "authorId" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "body" : "I find the `case x => y => z` syntax quite confusing because the two occurrences of `=>` don't mean exactly the same thing. I was looking for some scoping construct to put in between them. Could I just use `(...)`?",
        "createdAt" : "2020-05-18T16:12:09Z",
        "updatedAt" : "2020-05-18T16:23:38Z",
        "lastEditedBy" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "tags" : [
        ]
      },
      {
        "id" : "f33b28fd-e592-4bea-bf08-3ca92794842c",
        "parentId" : "e76f2eda-a37a-454a-b6e9-1a2dfb81f41d",
        "authorId" : "4c501a40-3340-4f35-b66e-fcfb75e20f37",
        "body" : "> Could I just use `(...)`?\r\n\r\nYes.",
        "createdAt" : "2020-05-18T16:13:34Z",
        "updatedAt" : "2020-05-18T16:23:38Z",
        "lastEditedBy" : "4c501a40-3340-4f35-b66e-fcfb75e20f37",
        "tags" : [
        ]
      }
    ],
    "commit" : "9b07b9b6bb0bb079c6a380804dc18a83f562c379",
    "line" : 51,
    "diffHunk" : "@@ -1,1 +143,147 @@          case _ => SELabelClosure(label, expr)\n        }\n      }\n    }\n"
  },
  {
    "id" : "df0f34e1-4ac5-4a15-9a40-775d45c05562",
    "prId" : 5819,
    "prUrl" : "https://github.com/digital-asset/daml/pull/5819",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4291dac8-ee70-435e-a8ec-abb7e3fff65d",
        "parentId" : null,
        "authorId" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "body" : "I am not sure we should use \"Compile\" for the name of this function.",
        "createdAt" : "2020-05-05T12:06:33Z",
        "updatedAt" : "2020-05-11T08:59:50Z",
        "lastEditedBy" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "tags" : [
        ]
      }
    ],
    "commit" : "4d1734369ae2276cb8e1c399796673b4b2ffe9e3",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +136,140 @@  @throws[CompilationError]\n  def unsafeClosureConvert(sexpr: SExpr): SExpr =\n    validate(closureConvert(Map.empty, 0, sexpr))\n\n  @throws[PackageNotFound]"
  },
  {
    "id" : "b5dbd68e-f904-4546-8d0b-c00fd227e75f",
    "prId" : 5629,
    "prUrl" : "https://github.com/digital-asset/daml/pull/5629",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "32267319-b385-408f-a40c-2b38aed85440",
        "parentId" : null,
        "authorId" : "181bcece-33df-41af-887d-5d5f51beb543",
        "body" : "Might we worth explaining that we use `dependenciesInTopologicalOrder` because packages need to be compiled in order. Perhaps that's obvious to others though.",
        "createdAt" : "2020-04-20T13:15:56Z",
        "updatedAt" : "2020-04-20T14:48:19Z",
        "lastEditedBy" : "181bcece-33df-41af-887d-5d5f51beb543",
        "tags" : [
        ]
      },
      {
        "id" : "bb131f18-41a0-46b7-b9cc-70ca48cce405",
        "parentId" : "32267319-b385-408f-a40c-2b38aed85440",
        "authorId" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "body" : "done",
        "createdAt" : "2020-04-20T14:08:27Z",
        "updatedAt" : "2020-04-20T14:48:19Z",
        "lastEditedBy" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "tags" : [
        ]
      }
    ],
    "commit" : "3f58847316bfebf75c98029bd4ce800560e794f7",
    "line" : 43,
    "diffHunk" : "@@ -1,1 +158,162 @@  def compilePackages(toCompile: Iterable[PackageId]): Map[SDefinitionRef, SExpr] =\n    // Package needs to be compiled in order.\n    dependenciesInTopologicalOrder(toCompile.toList, packages)\n      .foldLeft(Map.empty[SDefinitionRef, SExpr])(\n        _ ++ compilePackage(_)"
  },
  {
    "id" : "7afa73ec-89ed-40fa-82d9-ba7f06750f94",
    "prId" : 4990,
    "prUrl" : "https://github.com/digital-asset/daml/pull/4990",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a53a927f-43b9-448e-9a1d-980c4fd916b5",
        "parentId" : null,
        "authorId" : "eb431011-3221-41ae-bf30-e72dde278004",
        "body" : "Is this to \"drop\" one of the parameters?",
        "createdAt" : "2020-03-16T11:11:54Z",
        "updatedAt" : "2020-03-16T12:18:41Z",
        "lastEditedBy" : "eb431011-3221-41ae-bf30-e72dde278004",
        "tags" : [
        ]
      },
      {
        "id" : "f9e7a07a-880d-4e6e-ba56-4a9a74dfb2b1",
        "parentId" : "a53a927f-43b9-448e-9a1d-980c4fd916b5",
        "authorId" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "body" : "This drop the type parameter `nat`, which is nor erase.   ",
        "createdAt" : "2020-03-16T12:11:51Z",
        "updatedAt" : "2020-03-16T12:18:41Z",
        "lastEditedBy" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "tags" : [
        ]
      }
    ],
    "commit" : "388d7c03ab7235b2099abd7694f5a70a401bfdd4",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +196,200 @@\n  private val SBLessNumeric =\n    SEAbs(3, SEApp(SEBuiltin(SBLess), Array(SEVar(2), SEVar(1))))\n  private val SBLessEqNumeric =\n    SEAbs(3, SEApp(SEBuiltin(SBLessEq), Array(SEVar(2), SEVar(1))))"
  },
  {
    "id" : "904bccf5-d363-40ac-953e-a928e040bd29",
    "prId" : 2860,
    "prUrl" : "https://github.com/digital-asset/daml/pull/2860",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a2191575-9936-4140-8a88-44bc412892e7",
        "parentId" : null,
        "authorId" : "1a7c6bd0-63e1-4deb-9695-6d6e9742f90b",
        "body" : "```suggestion\r\n  private[this] val logger = LoggerFactory.getLogger(this.getClass)\r\n```\r\nIn this case `private[this]` makes a lot of sense. :slightly_smiling_face: ",
        "createdAt" : "2019-09-10T13:29:09Z",
        "updatedAt" : "2019-09-13T09:55:56Z",
        "lastEditedBy" : "1a7c6bd0-63e1-4deb-9695-6d6e9742f90b",
        "tags" : [
        ]
      }
    ],
    "commit" : "66feacefba7b54019abe3376660df6e5301c989f",
    "line" : 21,
    "diffHunk" : "@@ -1,1 +40,44 @@\nfinal case class Compiler(packages: PackageId PartialFunction Package) {\n  private val logger = LoggerFactory.getLogger(this.getClass)\n\n  private abstract class VarRef { def name: Ref.Name }"
  },
  {
    "id" : "390a5098-6227-488f-b231-053cfed9a021",
    "prId" : 1346,
    "prUrl" : "https://github.com/digital-asset/daml/pull/1346",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "51f059b9-c6e1-4cbb-ad44-4bc2ba8a9168",
        "parentId" : null,
        "authorId" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "body" : "@neil-da That's the Scala implementation: `\\x -> x`.",
        "createdAt" : "2019-05-23T13:27:45Z",
        "updatedAt" : "2019-05-23T13:31:31Z",
        "lastEditedBy" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "tags" : [
        ]
      },
      {
        "id" : "6b0a0db5-7eec-4267-878d-ff953cbac284",
        "parentId" : "51f059b9-c6e1-4cbb-ad44-4bc2ba8a9168",
        "authorId" : "5364da9b-036b-4a1e-b26b-68138cc489f9",
        "body" : "So simples :)",
        "createdAt" : "2019-05-23T21:20:50Z",
        "updatedAt" : "2019-05-23T21:20:50Z",
        "lastEditedBy" : "5364da9b-036b-4a1e-b26b-68138cc489f9",
        "tags" : [
        ]
      }
    ],
    "commit" : "5e330f2532a8450673c29e65222e4e4d6688f6e5",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +145,149 @@          case BFoldr => SEBuiltinRecursiveDefinition.FoldR\n          case BEqualList => SEBuiltinRecursiveDefinition.EqualList\n          case BCoerceContractId => SEAbs(1, SEVar(1))\n          case _ =>\n            SEBuiltin(bf match {"
  }
]
[
  {
    "id" : "da399afc-98e3-4a20-b17a-6ce1b27a6311",
    "prId" : 10077,
    "prUrl" : "https://github.com/digital-asset/daml/pull/10077",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "04beefe1-0d5f-4c32-b99d-8d4d0fc2d782",
        "parentId" : null,
        "authorId" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "body" : "```suggestion\r\n     2021-06-04\r\n```",
        "createdAt" : "2021-06-24T07:19:49Z",
        "updatedAt" : "2021-06-24T07:19:50Z",
        "lastEditedBy" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "tags" : [
        ]
      }
    ],
    "commit" : "3570bc19caeb95f4e08b948b201482df21ad1c0c",
    "line" : 12,
    "diffHunk" : "@@ -1,1 +256,260 @@* Introduction date:\n\n     2021-06-22\n\n* Description:"
  },
  {
    "id" : "dddecf1c-6314-4446-847f-fa8d77815a4b",
    "prId" : 9784,
    "prUrl" : "https://github.com/digital-asset/daml/pull/9784",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e579e8a1-99e0-42a0-8d67-f982e6a4cc37",
        "parentId" : null,
        "authorId" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "body" : "I guess technically we need to insert normalization here or alternatively describe it as a postprocessing step somewhere.",
        "createdAt" : "2021-05-25T06:45:20Z",
        "updatedAt" : "2021-05-25T06:45:52Z",
        "lastEditedBy" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "tags" : [
        ]
      },
      {
        "id" : "3e65172d-3b93-4690-993d-725d15203ec8",
        "parentId" : "e579e8a1-99e0-42a0-8d67-f982e6a4cc37",
        "authorId" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "body" : "Similarly for the other cases below.",
        "createdAt" : "2021-05-25T06:45:40Z",
        "updatedAt" : "2021-05-25T06:45:52Z",
        "lastEditedBy" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "tags" : [
        ]
      },
      {
        "id" : "a352c895-0c4e-41c0-b27d-3712c6775334",
        "parentId" : "e579e8a1-99e0-42a0-8d67-f982e6a4cc37",
        "authorId" : "f7ed27fc-83ac-401f-af8b-91c645eda7e9",
        "body" : "I think we should add it as a separate postprocessing step, since that's closer to the implementation.",
        "createdAt" : "2021-05-25T09:20:39Z",
        "updatedAt" : "2021-05-25T09:20:54Z",
        "lastEditedBy" : "f7ed27fc-83ac-401f-af8b-91c645eda7e9",
        "tags" : [
        ]
      }
    ],
    "commit" : "bef37c22e7632d3dc1409d6d31c21438d28717b5",
    "line" : 1006,
    "diffHunk" : "@@ -1,1 +3227,3231 @@     'try' @τ e₁ 'catch' x. e₂ ‖ S₀\n       ⇓ᵤ\n     (Ok v₂, ('rollback' tr₁) ⋅ tr₂) ‖ S₂\n\n     e₁  ⇓  Err (Throw v₁)"
  },
  {
    "id" : "b0351497-d886-42da-a8b9-40bad12f9f9f",
    "prId" : 9705,
    "prUrl" : "https://github.com/digital-asset/daml/pull/9705",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "34e24b92-c919-4258-bce9-1163a432a4f3",
        "parentId" : null,
        "authorId" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "body" : "You might want to copy the changelog from 1.dev. `A BigNumeric` is a bit brief and also seems like a typo.",
        "createdAt" : "2021-05-18T08:04:24Z",
        "updatedAt" : "2021-05-18T08:05:41Z",
        "lastEditedBy" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "tags" : [
        ]
      }
    ],
    "commit" : "212a165359c7845024c7e62c69c5d89dde83097d",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +236,240 @@\n\nVersion: 1.13\n.............\n"
  },
  {
    "id" : "7408727e-b4de-4ac5-86e7-9511b34cdd97",
    "prId" : 8899,
    "prUrl" : "https://github.com/digital-asset/daml/pull/8899",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7c6a21a7-a51a-4b1c-89b2-36490390eb21",
        "parentId" : null,
        "authorId" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "body" : "```suggestion\r\n  + **Add** BigNumeric type.\r\n```",
        "createdAt" : "2021-03-22T15:22:42Z",
        "updatedAt" : "2021-04-06T11:18:56Z",
        "lastEditedBy" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "tags" : [
        ]
      }
    ],
    "commit" : "03dd5cbedcf264bfe9fe5e18e0a40963ce4f699b",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +240,244 @@\n  + **Add** exception handling.\n  + **Add** BigDecimal type.\n\n    - add `BigNumeric` primitive type"
  },
  {
    "id" : "06b0478e-b315-4715-bead-997f59d2a7ca",
    "prId" : 8899,
    "prUrl" : "https://github.com/digital-asset/daml/pull/8899",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8539b3d9-9a12-4f91-97c4-22417104b48f",
        "parentId" : null,
        "authorId" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "body" : "```suggestion\r\n* A decimal number is a signed number that can be represented as a\r\n```",
        "createdAt" : "2021-03-22T15:23:02Z",
        "updatedAt" : "2021-04-06T11:18:56Z",
        "lastEditedBy" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "tags" : [
        ]
      }
    ],
    "commit" : "03dd5cbedcf264bfe9fe5e18e0a40963ce4f699b",
    "line" : 38,
    "diffHunk" : "@@ -1,1 +505,509 @@* A ``LitInt64`` represents a standard signed 64-bit integer (integer\n  between ``−2⁶³`` to ``2⁶³−1``).\n* A decimal numbers is a signed number that can be represented as a\n  product `i * 10⁻ˢ` where `i` (the *unscaled value* of the number) is\n  a signed integer without trailing zeros and `s` (the *scale* of the"
  },
  {
    "id" : "1db3fc5b-5851-43dd-911e-99c9b5cfce33",
    "prId" : 8899,
    "prUrl" : "https://github.com/digital-asset/daml/pull/8899",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "82952cc3-8d85-4ca4-83fc-f0c1b3448c28",
        "parentId" : null,
        "authorId" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "body" : "This doesn’t seem right. If I have `replicate 38 '1' <> \".\" <> replicate 37 '1'`, that falls under the definition here but it’s definitely not a valid numeric.",
        "createdAt" : "2021-03-22T15:24:56Z",
        "updatedAt" : "2021-04-06T11:18:56Z",
        "lastEditedBy" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "tags" : [
        ]
      },
      {
        "id" : "2bbb407e-cf4a-446d-8972-2883345dec25",
        "parentId" : "82952cc3-8d85-4ca4-83fc-f0c1b3448c28",
        "authorId" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "body" : "let  `x`  be `(\"1\" * 38) + \".\" + (\"1\" * 37)`.\r\nWe have `x =  i * 10 ^-s`\r\nwhere `i = (\"1\" * 75)` and `s = 37`, so its precision is `75` which is bigger than `38`     ",
        "createdAt" : "2021-03-22T15:56:48Z",
        "updatedAt" : "2021-04-06T11:18:56Z",
        "lastEditedBy" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "tags" : [
        ]
      },
      {
        "id" : "612b0f5d-cffa-40bc-9ccf-7dda9796238a",
        "parentId" : "82952cc3-8d85-4ca4-83fc-f0c1b3448c28",
        "authorId" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "body" : "Oh I’m dumb nvm.",
        "createdAt" : "2021-03-22T16:04:13Z",
        "updatedAt" : "2021-04-06T11:18:56Z",
        "lastEditedBy" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "tags" : [
        ]
      }
    ],
    "commit" : "03dd5cbedcf264bfe9fe5e18e0a40963ce4f699b",
    "line" : 47,
    "diffHunk" : "@@ -1,1 +514,518 @@  + A ``LitNumeric`` represents those decimal numbers that have a\n    precision of at most 38 and a scale between ``0`` and ``37``\n    (bounds inclusive).\n  + A ``LitBigNumeric`` represents those decimal numbers that have at\n    most 2¹⁵ significant digits at the right and the left of the"
  },
  {
    "id" : "7cb1b4dd-8df9-464c-9e5f-7649e1717095",
    "prId" : 8899,
    "prUrl" : "https://github.com/digital-asset/daml/pull/8899",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "19b3a6b2-35cd-4674-bad9-39e20da08465",
        "parentId" : null,
        "authorId" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "body" : "Do we need ordering on rounding modes? I would have thought no",
        "createdAt" : "2021-03-22T15:26:32Z",
        "updatedAt" : "2021-04-06T11:18:56Z",
        "lastEditedBy" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "tags" : [
        ]
      },
      {
        "id" : "7ba484e5-c109-49ec-a0e5-51b860192d32",
        "parentId" : "19b3a6b2-35cd-4674-bad9-39e20da08465",
        "authorId" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "body" : "We do not really need it, it will just simpler to map `RoundingMode` to `SInt64` in speedy and avoid any dynamic check in the ordering/equality. ",
        "createdAt" : "2021-03-22T15:58:06Z",
        "updatedAt" : "2021-04-06T11:18:56Z",
        "lastEditedBy" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "tags" : [
        ]
      },
      {
        "id" : "4c9b9b40-5895-40c8-8503-bea527157789",
        "parentId" : "19b3a6b2-35cd-4674-bad9-39e20da08465",
        "authorId" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "body" : "Can’t we fail in the typechecker instead of adding a dynamic check?",
        "createdAt" : "2021-03-22T16:04:31Z",
        "updatedAt" : "2021-04-06T11:18:56Z",
        "lastEditedBy" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "tags" : [
        ]
      },
      {
        "id" : "7c00608e-fd78-4ebb-b5a3-4f44aceb8cb2",
        "parentId" : "19b3a6b2-35cd-4674-bad9-39e20da08465",
        "authorId" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "body" : "We cannot fail in the type checker, as ordering and equality are generic. \r\nThis is precisely why comparison of functions type checks. (btw, I was very :cry:  when we implemented  that ! ).\r\nSince comparison of rounding modes type checks, I think it is just simpler (for us and the users) to implement the compression properly.",
        "createdAt" : "2021-03-22T16:11:30Z",
        "updatedAt" : "2021-04-06T11:18:56Z",
        "lastEditedBy" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "tags" : [
        ]
      },
      {
        "id" : "aa3b63bf-3f00-44dc-a0b7-3643b7fd5f85",
        "parentId" : "19b3a6b2-35cd-4674-bad9-39e20da08465",
        "authorId" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "body" : "oh I remember now makes sense.",
        "createdAt" : "2021-03-22T17:28:51Z",
        "updatedAt" : "2021-04-06T11:18:56Z",
        "lastEditedBy" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "tags" : [
        ]
      }
    ],
    "commit" : "03dd5cbedcf264bfe9fe5e18e0a40963ce4f699b",
    "line" : 81,
    "diffHunk" : "@@ -1,1 +550,554 @@are ordered as they appear in the definition of ``LitRoundingMode``,\ne.g. ``ROUNDING_UP`` and ``ROUNDING_UNNECESSARY`` are the smallest and\ngreatest rounding mode.\n\nKinds, types, and expressions"
  },
  {
    "id" : "b4dd6c81-8923-4129-b5d9-f8b471294471",
    "prId" : 8899,
    "prUrl" : "https://github.com/digital-asset/daml/pull/8899",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e0516fb3-6cc5-4f54-9596-7ab93b79ccce",
        "parentId" : null,
        "authorId" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "body" : "add and sub call them decimals, here you call them numeric.",
        "createdAt" : "2021-03-22T15:37:16Z",
        "updatedAt" : "2021-04-06T11:18:56Z",
        "lastEditedBy" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "tags" : [
        ]
      }
    ],
    "commit" : "03dd5cbedcf264bfe9fe5e18e0a40963ce4f699b",
    "line" : 243,
    "diffHunk" : "@@ -1,1 +3779,3783 @@* ``MUL_BIGNUMERIC : 'BigNumeric' → 'BigNumeric' → 'BigNumeric'``\n\n  Multiplies the two numerics. Throws an ``ArithmeticError`` if the\n  output is not a valid BigNumeric.\n"
  },
  {
    "id" : "7483f0b0-2f7c-486b-8f6e-8f0a3d32f051",
    "prId" : 8899,
    "prUrl" : "https://github.com/digital-asset/daml/pull/8899",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8bce40ac-c6e0-4ec1-864d-88c4b6c56516",
        "parentId" : null,
        "authorId" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "body" : "```suggestion\r\n  Adds the two numerics. Throws an ``ArithmeticError`` if the output\r\n```",
        "createdAt" : "2021-03-22T15:59:23Z",
        "updatedAt" : "2021-04-06T11:18:56Z",
        "lastEditedBy" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "tags" : [
        ]
      }
    ],
    "commit" : "03dd5cbedcf264bfe9fe5e18e0a40963ce4f699b",
    "line" : 233,
    "diffHunk" : "@@ -1,1 +3769,3773 @@* ``ADD_BIGNUMERIC : 'BigNumeric' → 'BigNumeric'  → 'BigNumeric'``\n\n  Adds the two decimals. Throws an ``ArithmeticError`` if the output\n  is not a valid BigNumeric.\n"
  },
  {
    "id" : "9c5c3bd1-e2ba-4e90-a529-63d18e6b8949",
    "prId" : 8899,
    "prUrl" : "https://github.com/digital-asset/daml/pull/8899",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c23a3ff9-4117-4e29-b1b2-3b4a84f228d3",
        "parentId" : null,
        "authorId" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "body" : "```suggestion\r\n  Subtracts the two numerics. Throws an ``ArithmeticError`` if the\r\n```",
        "createdAt" : "2021-03-22T15:59:34Z",
        "updatedAt" : "2021-04-06T11:18:56Z",
        "lastEditedBy" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "tags" : [
        ]
      }
    ],
    "commit" : "03dd5cbedcf264bfe9fe5e18e0a40963ce4f699b",
    "line" : 238,
    "diffHunk" : "@@ -1,1 +3774,3778 @@* ``SUB_BIGNUMERIC : 'BigNumeric' → 'BigNumeric' → 'BigNumeric'``\n\n  Subtracts the two decimals. Throws an ``ArithmeticError`` if the\n  output is not a valid BigNumeric.\n"
  },
  {
    "id" : "7fc6b946-6f62-4a8e-84d6-73ee28acafd2",
    "prId" : 8899,
    "prUrl" : "https://github.com/digital-asset/daml/pull/8899",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "99a6c9f3-046e-4f7f-b412-b9ecb07beb9b",
        "parentId" : null,
        "authorId" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "body" : "```suggestion\r\n  Divides the first numeric by the second one and rounds the result\r\n```",
        "createdAt" : "2021-03-22T16:00:00Z",
        "updatedAt" : "2021-04-06T11:18:56Z",
        "lastEditedBy" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "tags" : [
        ]
      }
    ],
    "commit" : "03dd5cbedcf264bfe9fe5e18e0a40963ce4f699b",
    "line" : 248,
    "diffHunk" : "@@ -1,1 +3784,3788 @@* ``DIV_BIGNUMERIC : 'RoundingMode' → 'Int' → 'BigNumeric' → 'BigNumeric' → 'BigNumeric'``\n\n  Divides the first decimal by the second one and rounds the result\n  according the rounding mode.  The scale of the output is given by\n  the second argument.  If the result cannot be represented exactly at"
  },
  {
    "id" : "e2d6922a-713d-45c3-926b-b1e4f72316f8",
    "prId" : 8899,
    "prUrl" : "https://github.com/digital-asset/daml/pull/8899",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a77e7ad7-f437-4698-b8b3-f5a79b59c9a8",
        "parentId" : null,
        "authorId" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "body" : " Why? I want to be able to write `\\x -> x * 2.0` in Daml without going through a numeric conversion.",
        "createdAt" : "2021-03-22T17:30:42Z",
        "updatedAt" : "2021-04-06T11:18:56Z",
        "lastEditedBy" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "tags" : [
        ]
      },
      {
        "id" : "dd0652ca-222b-4b9e-9161-f9b04bb76883",
        "parentId" : "a77e7ad7-f437-4698-b8b3-f5a79b59c9a8",
        "authorId" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "body" : "This does not prevent you to have `BigNumeric` literals in Daml.\r\n - The simplest is to limit DAML `BigNumeric` literals to those `BitNumeric` that can be represented as `Numerics`, and wrapped those in a `TO_BIGNUMERIC_NUMERIC`  when generated the LF code. I think this make complete sens as Numeric are not serializable; `BigNumeric` should be use only for intermediary computation. \r\n - If you absolutely want that all valid `BigNumeric` have a valid DAML literals you can still internally construct them using `TO_BIGNUMERIC_NUMERIC`, `ADD_BIGNUMERIC` and `SHIFT_BIGNUMERIC` and cache the result in an LF  `val`. \r\n\r\n\r\n",
        "createdAt" : "2021-03-22T18:31:57Z",
        "updatedAt" : "2021-04-06T11:18:56Z",
        "lastEditedBy" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "tags" : [
        ]
      },
      {
        "id" : "908fab06-f2b6-484d-9add-4eb6d8191f32",
        "parentId" : "a77e7ad7-f437-4698-b8b3-f5a79b59c9a8",
        "authorId" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "body" : "What do we gain from disallowing `BigNumeric` literals? I disagree that this is related to serializability. We clearly need literals in intermediate computations. I think you’re probably right that the numeric wrapper is sufficient but it seems worse from a performance pov with relatively little benefit.",
        "createdAt" : "2021-03-23T09:18:10Z",
        "updatedAt" : "2021-04-06T11:18:56Z",
        "lastEditedBy" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "tags" : [
        ]
      },
      {
        "id" : "e5adce90-2b06-4957-b79c-9d9d3031dcf0",
        "parentId" : "a77e7ad7-f437-4698-b8b3-f5a79b59c9a8",
        "authorId" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "body" : "When I mean no literals, I mean there is not literal in the syntax i.e. in the archive, there is of course literal operationally. \r\nIt is a bit like GenMap, we do not have literals in the syntax, you can create Map only bu using the builtin.",
        "createdAt" : "2021-03-24T14:08:56Z",
        "updatedAt" : "2021-04-06T11:18:56Z",
        "lastEditedBy" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "tags" : [
        ]
      },
      {
        "id" : "69de9cd6-ba2a-491f-b198-8ebc7672f8bd",
        "parentId" : "a77e7ad7-f437-4698-b8b3-f5a79b59c9a8",
        "authorId" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "body" : "Will try to reformulate",
        "createdAt" : "2021-03-24T14:41:20Z",
        "updatedAt" : "2021-04-06T11:18:56Z",
        "lastEditedBy" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "tags" : [
        ]
      }
    ],
    "commit" : "03dd5cbedcf264bfe9fe5e18e0a40963ce4f699b",
    "line" : 113,
    "diffHunk" : "@@ -1,1 +714,718 @@\n.. note:: The explicit syntax for BigNumeric literal (case\n  ``ExpLitBigNumeric``) is forbidden in serialized programs. It is\n  specified here to ease the definition of `values`_, `operational\n  semantics`_ and `value comparison <Generic comparison"
  },
  {
    "id" : "0302b4e9-460a-4963-bb7c-635bd69e5f92",
    "prId" : 8530,
    "prUrl" : "https://github.com/digital-asset/daml/pull/8530",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "90af3a50-4048-4a71-a55c-e0e16a9187cd",
        "parentId" : null,
        "authorId" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "body" : "Just to confirm the `@t1` here is why we need the exception type in the error semantics?",
        "createdAt" : "2021-01-15T16:37:56Z",
        "updatedAt" : "2021-01-15T17:01:59Z",
        "lastEditedBy" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "tags" : [
        ]
      },
      {
        "id" : "7a0087cf-a8d0-48f9-b38c-e21f36822feb",
        "parentId" : "90af3a50-4048-4a71-a55c-e0e16a9187cd",
        "authorId" : "f7ed27fc-83ac-401f-af8b-91c645eda7e9",
        "body" : "Yes!",
        "createdAt" : "2021-01-15T22:04:21Z",
        "updatedAt" : "2021-01-15T22:04:21Z",
        "lastEditedBy" : "f7ed27fc-83ac-401f-af8b-91c645eda7e9",
        "tags" : [
        ]
      }
    ],
    "commit" : "454b5649fa29cb37c3789ae048c55e28cffdd89e",
    "line" : 968,
    "diffHunk" : "@@ -1,1 +3154,3158 @@\n     e₁  ⇓  Err @τ₁ v₁\n     e₂[x ↦ 'to_any_exception' @τ₁ v₁]  ⇓  Ok ('None' @σ)\n   —————————————————————————————————————————————————————————————————————— EvUpdTryCatchErr1_NoHandle\n     'try' @τ e₁ 'catch' x. e₂ ‖ S₀  ⇓ᵤ  (Err @τ₁ v₁, ε)"
  },
  {
    "id" : "994cb551-0f5f-4b98-af25-3c9fedd29513",
    "prId" : 8530,
    "prUrl" : "https://github.com/digital-asset/daml/pull/8530",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5298ce0b-269c-4f4b-b6e0-a2113d7baab1",
        "parentId" : null,
        "authorId" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "body" : "I don’t quite understand why this definition is setup the way it is. Rollback makes sense and that’s what I would expect. The part that I don’t understand is incomplete ledger transactions:\r\n\r\nThe only difference between `itr` and `tr` is that the former special cases incomplete exercises and allows those at the end (however, regular exercises are also still allowed at the end). I assume we get a regular transaction if we executed a choice body and we ran some successful actions and then failed outside of a create or exercise, e.g., a division by zero in the choice body. We get an `iexercise` if a choice called from the choice body fails. But why don’t we have an `icreate` for cases where we call create from the choice body and the precondition fails? It looks like we just treat this like the precondition failed in the choice body outside of the create? That seems somewhat unintuitive to me and I’d like to understand the motivation for this choice. Overall, I think we need some human-readable comments that explain how things are represented here. Doesn’t have to be in the spec but arguably the chances of keeping it updated here are higher than in a google doc.",
        "createdAt" : "2021-01-15T17:01:46Z",
        "updatedAt" : "2021-01-15T17:01:59Z",
        "lastEditedBy" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "tags" : [
        ]
      },
      {
        "id" : "235c4538-06ac-4b7d-ba05-f7c8fdcf0b46",
        "parentId" : "5298ce0b-269c-4f4b-b6e0-a2113d7baab1",
        "authorId" : "f7ed27fc-83ac-401f-af8b-91c645eda7e9",
        "body" : "That's right: In the execution of a \"try\" you can run into exceptions that aren't in the body of an exercise, so that all the ledger actions under a rollback node are \"complete\", even though they will be rolled back.  *You only get an incomplete ledger action when an exception propagates up from a choice body (`iexercise`).*\r\n\r\nWe could have an `icreate`. I don't have a strong opinion on this, but there's maybe some reasons not to: it's not needed for validation of rolled back transactions (unlike `exercise`/`iexercise` nodes), and the contract value you could attach to it isn't well formed (otherwise the create would have succeeded). Note that we only generate an `iexercise` node when we are evaluating or executing a choice body. An ill-formed exercise (e.g. exercise on inactive contract, see EvUpdExercInactive) does not result in an `iexercise` node, only in an exception.\r\n\r\nThe other thing we'll probably want at some point is `fetch` nodes in the spec (... and maybe `ifetch` nodes?) I'm going to talk with Rémy about this soon.",
        "createdAt" : "2021-01-15T22:37:05Z",
        "updatedAt" : "2021-01-15T22:37:05Z",
        "lastEditedBy" : "f7ed27fc-83ac-401f-af8b-91c645eda7e9",
        "tags" : [
        ]
      },
      {
        "id" : "ce0981d4-b2f8-46cb-9c75-a9c3334c455c",
        "parentId" : "5298ce0b-269c-4f4b-b6e0-a2113d7baab1",
        "authorId" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "body" : "I’m still struggling to understand what exactly makes exercise special here. What information is in `iexercise` that we need for validation that doesn’t apply to create? Is it the `contract` because it does not just contain the cid which we could get by reinterpretation but also the contract argument which we need to interpret the body of the choice whereas for a create, we have the contract argument directly in the DAML-LF call so we can interpret the `ensure` clause without having the `create` in the transaction? That would make sense to me but then it seems like `fetch` runs into exactly the same issue even without involving any exceptions so we definitely need to fix this. The current definition suffers from the same issue as the transaction tree you get on the ledger API which is not sufficient for validation exactly because it is missing fetch nodes (they’re not quite equivalent, the one on the ledger API is also missing the contract argument on exercises).\r\n\r\nAssuming it is about the contract argument, I have one last question: We cannot omit `iexercise` like we can for `create` since we need the contract argument but what happens if we just use an `exercise`? That loses the information of whether we failed within the body of the choice we called or within the caller but as far as I can tell that information is redundant and can be recovered during validation (reinterpret and see where it blows up). It seems perfectly sensible to encode this separately even if we could recover it, I’m just trying to figure out which info is strictly needed and which is “only” to make the spec clearer.",
        "createdAt" : "2021-01-16T02:09:53Z",
        "updatedAt" : "2021-01-16T02:09:53Z",
        "lastEditedBy" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "tags" : [
        ]
      },
      {
        "id" : "4194e00a-38f8-4c9c-a767-f03c9093f3c9",
        "parentId" : "5298ce0b-269c-4f4b-b6e0-a2113d7baab1",
        "authorId" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "body" : "After a brief chat with @remyhaemmerle-da, I think the current specification for transactions is neither very useful nor correct. I would suggest to not spend more time on this for now (we can merge this state or just omit it completely) and instead update the ledger model to include exceptions first to clarify what exactly we want and then we can later come back to the LF spec and see how we can fix the spec here and make it actually useful.",
        "createdAt" : "2021-01-18T09:18:41Z",
        "updatedAt" : "2021-01-18T09:18:41Z",
        "lastEditedBy" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "tags" : [
        ]
      },
      {
        "id" : "ebbebd71-cc7d-4bfc-ae36-708d2295b0e7",
        "parentId" : "5298ce0b-269c-4f4b-b6e0-a2113d7baab1",
        "authorId" : "f7ed27fc-83ac-401f-af8b-91c645eda7e9",
        "body" : "I think the difference between exercise and choice here is that the exercise body needs to be executed with a  different authorization context, so we need to track exercises carefully in the failed transaction, and the difference between exercise and iexercise is that the former returns a value from the exercise but the latter doesn't. Neither of these (authorization contexts, and values from exercises) are being tracked in the current model for the semantics, so it's definitely something to clarify/improve at some point ...",
        "createdAt" : "2021-01-19T10:13:51Z",
        "updatedAt" : "2021-01-19T10:14:20Z",
        "lastEditedBy" : "f7ed27fc-83ac-401f-af8b-91c645eda7e9",
        "tags" : [
        ]
      },
      {
        "id" : "d9e13363-d5fe-435e-a14e-4bf5de8f2d6c",
        "parentId" : "5298ce0b-269c-4f4b-b6e0-a2113d7baab1",
        "authorId" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "body" : "Yeah I think I get why we need the exercise and in a full transaction, I get that at the very least the choice result is a difference between a complete and an incomplete exercise (although I’m not quite clear if you couldn’t just recompute that during validation but that’s a separate discussion). What confused me was why we can omit some information (e.g., fetches, choice results, authorization contexts), but not other information. After this discussion, the conclusion seems to be that we probably cannot omit any of this and the current transaction spec is just plain wrong and neither describes the ledger API nor the transaction we use for validation.",
        "createdAt" : "2021-01-19T10:23:57Z",
        "updatedAt" : "2021-01-19T10:23:57Z",
        "lastEditedBy" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "tags" : [
        ]
      }
    ],
    "commit" : "454b5649fa29cb37c3789ae048c55e28cffdd89e",
    "line" : 585,
    "diffHunk" : "@@ -1,1 +2757,2761 @@      ::= tr\n       |  tr · iact\n\n  Contract states\n    ContractState"
  },
  {
    "id" : "93a6d595-e02a-48a1-a872-cbb876e0c550",
    "prId" : 8366,
    "prUrl" : "https://github.com/digital-asset/daml/pull/8366",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a17b9802-65c8-43f0-a357-ebf9c0de92e3",
        "parentId" : null,
        "authorId" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "body" : "Shouldn't this be something like\r\n```suggestion\r\n       | 'throw' @σ @τ e                            -- ExpThrow: throw exception\r\n```",
        "createdAt" : "2021-01-04T15:05:29Z",
        "updatedAt" : "2021-01-04T15:07:42Z",
        "lastEditedBy" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "tags" : [
        ]
      },
      {
        "id" : "49cf9714-de64-4b58-ab95-165109b3821f",
        "parentId" : "a17b9802-65c8-43f0-a357-ebf9c0de92e3",
        "authorId" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "body" : "Good catch. (fixed in #8376)",
        "createdAt" : "2021-01-04T15:30:10Z",
        "updatedAt" : "2021-01-04T15:31:15Z",
        "lastEditedBy" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "tags" : [
        ]
      }
    ],
    "commit" : "c97d089617ca4be016c1223e368c48d29084aa42",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +604,608 @@       |  u                                         -- ExpUpdate: Update expression\n       |  s                                         -- ExpScenario: Scenario expression\n       | 'throw'                                    -- ExpThrow: throw exception\n       | 'make_any_exception' @τ eₘ eₚ              -- ExpMakeAnyException: Turn a concrete exception into an 'AnyException' [DAML-LF ≥ 1.dev]\n       | 'from_any_exception' @τ e                  -- ExpFromAnyException: Extract a concrete exception from an 'AnyException' [DAML-LF ≥ 1.dev]"
  },
  {
    "id" : "c8e89b98-d951-4458-8dfc-321305390fec",
    "prId" : 8366,
    "prUrl" : "https://github.com/digital-asset/daml/pull/8366",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d8c8ef08-705b-4a38-8bcb-520f6a7bcfd4",
        "parentId" : null,
        "authorId" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "body" : "We need to add the `message` here as well, don't we?",
        "createdAt" : "2021-01-04T15:06:52Z",
        "updatedAt" : "2021-01-04T15:07:42Z",
        "lastEditedBy" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "tags" : [
        ]
      },
      {
        "id" : "cbec5665-8ffb-4355-9aa5-6431bb1c54b6",
        "parentId" : "d8c8ef08-705b-4a38-8bcb-520f6a7bcfd4",
        "authorId" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "body" : "Indeed. (fixed in #8376)",
        "createdAt" : "2021-01-04T15:29:58Z",
        "updatedAt" : "2021-01-04T15:31:05Z",
        "lastEditedBy" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "tags" : [
        ]
      }
    ],
    "commit" : "c97d089617ca4be016c1223e368c48d29084aa42",
    "line" : 22,
    "diffHunk" : "@@ -1,1 +704,708 @@            , KeyDef\n            }\n       |  'exception' T                             -- DefException [DAML-LF ≥ 1.dev]\n\n  Module (mnemonic: delta for definitions)"
  },
  {
    "id" : "3f593049-6675-4e03-8d3e-6bc694576431",
    "prId" : 8280,
    "prUrl" : "https://github.com/digital-asset/daml/pull/8280",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "83401dc2-d4e6-48f1-ab1e-5f2baa3a1f3f",
        "parentId" : null,
        "authorId" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "body" : "```suggestion\r\nAn optional ``observer`` expression may be attached to a flexible\r\n```",
        "createdAt" : "2020-12-14T17:24:37Z",
        "updatedAt" : "2020-12-18T15:01:12Z",
        "lastEditedBy" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "tags" : [
        ]
      }
    ],
    "commit" : "caacd4dbb05b8ba6b44281736fdc109dc5f5841a",
    "line" : 376,
    "diffHunk" : "@@ -1,1 +4567,4571 @@[*Available in versions >= 1.11*]\n\nAn optional `observer` expression may be attached to a flexible\nchoice. This allows the specification of additional parties to whom\nthe sub-transaction is disclosed."
  },
  {
    "id" : "48bf6ad1-66c5-40c5-b7ba-b8444be3ec3f",
    "prId" : 8108,
    "prUrl" : "https://github.com/digital-asset/daml/pull/8108",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1a87103e-9d20-45cf-a946-8aa77125fc58",
        "parentId" : null,
        "authorId" : "f7ed27fc-83ac-401f-af8b-91c645eda7e9",
        "body" : "I think these type-specific comparison functions were remove in 1.dev? Same with the party literals comparison functions. Because of generic comparison.\r\n\r\n```suggestion\r\n  [*Available in versions 1.7, 1.8*]\r\n```\r\n",
        "createdAt" : "2020-11-30T14:40:47Z",
        "updatedAt" : "2020-11-30T14:45:07Z",
        "lastEditedBy" : "f7ed27fc-83ac-401f-af8b-91c645eda7e9",
        "tags" : [
        ]
      },
      {
        "id" : "ca419106-901c-44b0-8edb-003e94e02901",
        "parentId" : "1a87103e-9d20-45cf-a946-8aa77125fc58",
        "authorId" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "body" : "good catch. I will fix that.",
        "createdAt" : "2020-11-30T16:34:54Z",
        "updatedAt" : "2020-11-30T16:34:54Z",
        "lastEditedBy" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "tags" : [
        ]
      }
    ],
    "commit" : "d5603468818f8e19b94de2f26520325be28f7fbb",
    "line" : 390,
    "diffHunk" : "@@ -1,1 +4086,4090 @@  the second one, ``'False'`` otherwise.\n\n  [*Available in versions >= 1.7*]\n\n"
  },
  {
    "id" : "1e033756-14ef-4f22-855d-5c9f524c6076",
    "prId" : 8068,
    "prUrl" : "https://github.com/digital-asset/daml/pull/8068",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "28e7c7a6-5317-4565-9201-c3c80fc06463",
        "parentId" : null,
        "authorId" : "f7ed27fc-83ac-401f-af8b-91c645eda7e9",
        "body" : "I don't feel strongly about this, but we could consider `AnyException` an exception type, and avoid rewrapping it at runtime when calling `to_any_exception` and `from_any_exception`. (E.g. speedy could just turn these into \"id\" if called with those types.)\r\n\r\nIt shouldn't make a big difference either way, if we change `throw` as I suggested.",
        "createdAt" : "2020-11-25T17:21:07Z",
        "updatedAt" : "2020-11-27T16:06:09Z",
        "lastEditedBy" : "f7ed27fc-83ac-401f-af8b-91c645eda7e9",
        "tags" : [
        ]
      },
      {
        "id" : "179460f7-04d5-419c-a923-45d1f32df5d5",
        "parentId" : "28e7c7a6-5317-4565-9201-c3c80fc06463",
        "authorId" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "body" : "I'm inclined to avoid the special case in the interpreter for now but would be willing to add it later if it turns out to be necessary.",
        "createdAt" : "2020-11-26T10:15:41Z",
        "updatedAt" : "2020-11-27T16:06:09Z",
        "lastEditedBy" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "tags" : [
        ]
      },
      {
        "id" : "f6ba5533-de24-4bef-b5a4-1e07137ea13f",
        "parentId" : "28e7c7a6-5317-4565-9201-c3c80fc06463",
        "authorId" : "f7ed27fc-83ac-401f-af8b-91c645eda7e9",
        "body" : "Good point. I think it really won't make a difference, damlc will only use the `to/from` primitives on user-defined and other primitive exceptions anyway.",
        "createdAt" : "2020-11-26T10:30:05Z",
        "updatedAt" : "2020-11-27T16:06:09Z",
        "lastEditedBy" : "f7ed27fc-83ac-401f-af8b-91c645eda7e9",
        "tags" : [
        ]
      }
    ],
    "commit" : "2dda381399ad219133415579aa6665a4affcfddd",
    "line" : 90,
    "diffHunk" : "@@ -1,1 +1065,1069 @@\nNote that ``'AnyException'`` is not an exception type in order to avoid having\n``'AnyException'`` wrapped into ``'AnyException'``.\n\n"
  },
  {
    "id" : "42f4f90f-879e-4d5f-9feb-908610aa50cc",
    "prId" : 8068,
    "prUrl" : "https://github.com/digital-asset/daml/pull/8068",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "608a49bb-a0b2-42f5-890c-342c9684b9cc",
        "parentId" : null,
        "authorId" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "body" : "I see you version the expression but not the type checking rule. \r\nI am fine with this approach, but coherence is more important for me. \r\nEither you follow the convention which are already in place (you do not version the expression but version the type checking rule as it is done for `Any` and `TypeRep`) or you change how think are version to your new convention.\r\n\r\nSecond point, I would be very please if you version each expression independently, i.e. something like that: \r\n```\r\n       |  'AnyException'                            -- BTyAnyException    [DAML-LF ≥ 1.dev]\r\n       |  'GeneralError'                            -- BTyGeneralError    [DAML-LF ≥ 1.dev]\r\n       |  'ArithmeticError'                         -- BTyArithmeticError [DAML-LF ≥ 1.dev]\r\n       |  'ContractError'                           -- BTyContractError   [DAML-LF ≥ 1.dev]\r\n```\r\nThis scheme is simpler (and safer) to update when we release the new version of LF.",
        "createdAt" : "2020-11-30T09:18:13Z",
        "updatedAt" : "2020-11-30T09:24:39Z",
        "lastEditedBy" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "tags" : [
        ]
      },
      {
        "id" : "47c55d22-d26f-4a18-aeeb-7d73d31ce700",
        "parentId" : "608a49bb-a0b2-42f5-890c-342c9684b9cc",
        "authorId" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "body" : "I couldn't fine any precendence for having type checking rules that depend on the DAML-LF version (the `Any` stuff doesn't do it) but I think it makes to have it there. I'm moving it over.",
        "createdAt" : "2020-11-30T13:52:39Z",
        "updatedAt" : "2020-11-30T13:52:39Z",
        "lastEditedBy" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "tags" : [
        ]
      },
      {
        "id" : "26239132-9cc4-4ac1-80c2-b847f68f1b2b",
        "parentId" : "608a49bb-a0b2-42f5-890c-342c9684b9cc",
        "authorId" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "body" : "You are right, there is no versioning for `Any` --it is an issue--, I have been to quick.\r\nThe original idea, was to not version anything in the definition and the inference rule but just add a paragraph in the `Serialization changes` section. See for instance `Generic Map`.",
        "createdAt" : "2020-11-30T14:00:32Z",
        "updatedAt" : "2020-11-30T14:00:32Z",
        "lastEditedBy" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "tags" : [
        ]
      }
    ],
    "commit" : "2dda381399ad219133415579aa6665a4affcfddd",
    "line" : 17,
    "diffHunk" : "@@ -1,1 +650,654 @@       |  'GeneralError'                            -- BTyGeneralError\n       |  'ArithmeticError'                         -- BTyArithmeticError\n       |  'ContractError'                           -- BTyContractError\n\n  Types (mnemonic: tau for type)"
  },
  {
    "id" : "10870696-d793-48c8-81bf-5cb7012124fe",
    "prId" : 8068,
    "prUrl" : "https://github.com/digital-asset/daml/pull/8068",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "741bcd94-7272-42e5-9765-2597ce44840b",
        "parentId" : null,
        "authorId" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "body" : "What is `@_` ? Is it a \"matcher' for any type. Again I prefer you follow the existing convention to use a singleton variable or to change the file to not use any-more singleton variable in inference rule.  ",
        "createdAt" : "2020-11-30T09:22:15Z",
        "updatedAt" : "2020-11-30T09:24:39Z",
        "lastEditedBy" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "tags" : [
        ]
      },
      {
        "id" : "0c8ddf1c-c653-42f6-8ed7-ce6326f8cb6c",
        "parentId" : "741bcd94-7272-42e5-9765-2597ce44840b",
        "authorId" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "body" : "Oops, that was a short-cut that made it into the final version. Changed it to `@σ`, where `σ` is an otherwise not mentioned type.",
        "createdAt" : "2020-11-30T13:54:40Z",
        "updatedAt" : "2020-11-30T13:54:41Z",
        "lastEditedBy" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "tags" : [
        ]
      }
    ],
    "commit" : "2dda381399ad219133415579aa6665a4affcfddd",
    "line" : 407,
    "diffHunk" : "@@ -1,1 +3232,3236 @@\n     e₁  ⇓  Err v₁\n     e₂[x ↦ v₁]  ⇓  Ok ('None' @_)\n   —————————————————————————————————————————————————————————————————————— EvUpdTryCatchErr2e\n     'try' @τ e₁ 'catch' x. e₂ ‖ S₀  ⇓ᵤ  (Err v₁, ε)"
  },
  {
    "id" : "a1b89835-7944-40ac-ac2c-13452edfa62d",
    "prId" : 8068,
    "prUrl" : "https://github.com/digital-asset/daml/pull/8068",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fc7fbb90-2236-489e-9b19-0a321ac45b7e",
        "parentId" : null,
        "authorId" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "body" : "`Well-formed packages` section needs to be updated to include `Exception coherence`\r\n\r\nFurthermore, I would move the extra condition as a separate bullet in the `Well-formed packages` as it is not directly related the Exception coherence\r\n",
        "createdAt" : "2020-11-30T09:58:50Z",
        "updatedAt" : "2020-11-30T09:58:50Z",
        "lastEditedBy" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "tags" : [
        ]
      },
      {
        "id" : "dbeade59-5b30-4b3b-b163-039fc7f36be7",
        "parentId" : "fc7fbb90-2236-489e-9b19-0a321ac45b7e",
        "authorId" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "body" : "I wasn't aware of this. Thanks for pointing me to it.",
        "createdAt" : "2020-11-30T13:56:06Z",
        "updatedAt" : "2020-11-30T13:56:06Z",
        "lastEditedBy" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "tags" : [
        ]
      }
    ],
    "commit" : "2dda381399ad219133415579aa6665a4affcfddd",
    "line" : 162,
    "diffHunk" : "@@ -1,1 +1698,1702 @@\n\nException coherence\n~~~~~~~~~~~~~~~~~~~\n"
  },
  {
    "id" : "b0838dc8-ceb3-4adc-a964-0454f07e62cd",
    "prId" : 8068,
    "prUrl" : "https://github.com/digital-asset/daml/pull/8068",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "470a929f-be21-49b1-b644-8cf5961a9597",
        "parentId" : null,
        "authorId" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "body" : "Those are primitive type, they should be bigger than any non primitive type. \r\nI think the good place is between `Update` and `Mod:T`  line 2092",
        "createdAt" : "2020-11-30T10:03:40Z",
        "updatedAt" : "2020-11-30T10:03:40Z",
        "lastEditedBy" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "tags" : [
        ]
      },
      {
        "id" : "f561b900-a786-468b-813f-6fea1ff4d27b",
        "parentId" : "470a929f-be21-49b1-b644-8cf5961a9597",
        "authorId" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "body" : "That makes sense.",
        "createdAt" : "2020-11-30T14:01:35Z",
        "updatedAt" : "2020-11-30T14:01:36Z",
        "lastEditedBy" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "tags" : [
        ]
      }
    ],
    "commit" : "2dda381399ad219133415579aa6665a4affcfddd",
    "line" : 222,
    "diffHunk" : "@@ -1,1 +2266,2270 @@  ——————————————————————————————————————————————————— TypeOrderArithmeticErrorContractError\n    'ArithmeticError' <ₜ 'ContractError'\n\n\nNote that ``<ₜ`` is undefined on types containing variables,"
  },
  {
    "id" : "e161b8f9-5bc8-4094-9cb9-a42ae005ac75",
    "prId" : 8068,
    "prUrl" : "https://github.com/digital-asset/daml/pull/8068",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "505e1fb3-9ee3-4696-a406-cb126330c632",
        "parentId" : null,
        "authorId" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "body" : "subsumed by `EvExpBuiltinErr`",
        "createdAt" : "2020-11-30T10:13:23Z",
        "updatedAt" : "2020-11-30T10:13:23Z",
        "lastEditedBy" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "tags" : [
        ]
      }
    ],
    "commit" : "2dda381399ad219133415579aa6665a4affcfddd",
    "line" : 251,
    "diffHunk" : "@@ -1,1 +2535,2539 @@      e  ⇓  Err v\n    —————————————————————————————————————————————————————————————————————— EvExpThrowErr\n      'THROW' @τ e  ⇓  Err v\n\n      e  ⇓  Ok v"
  },
  {
    "id" : "48466cab-49f2-477f-b657-3e8392ffe1da",
    "prId" : 8068,
    "prUrl" : "https://github.com/digital-asset/daml/pull/8068",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bcede87e-e95d-4086-94dd-3b0f05923069",
        "parentId" : null,
        "authorId" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "body" : "subsumed by `EvExpBuiltinErr`",
        "createdAt" : "2020-11-30T10:13:46Z",
        "updatedAt" : "2020-11-30T10:15:21Z",
        "lastEditedBy" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "tags" : [
        ]
      }
    ],
    "commit" : "2dda381399ad219133415579aa6665a4affcfddd",
    "line" : 241,
    "diffHunk" : "@@ -1,1 +2525,2529 @@      e  ⇓  Err v\n    —————————————————————————————————————————————————————————————————————— EvExpErrorErr\n      'ERROR' @τ e  ⇓  Err v\n\n      e  ⇓  Ok v"
  },
  {
    "id" : "9f083b1c-424e-4daf-bc5b-1a3bdddbf4e2",
    "prId" : 8068,
    "prUrl" : "https://github.com/digital-asset/daml/pull/8068",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "aa0263a2-3822-4e6b-b36f-f9026235e2e2",
        "parentId" : null,
        "authorId" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "body" : "I will drop this rule and add in the definition of 'ERROR' down that it is an alias for throw similarly we done for `GREATER_EQ`\r\n```'ERROR' ≡  Λ α : ⋆. λ x : 'Text'. THROW @t x (ToAnyException @GeneralError (MAKE_GENERAL_ERROR x)```",
        "createdAt" : "2020-11-30T10:40:46Z",
        "updatedAt" : "2020-11-30T10:40:47Z",
        "lastEditedBy" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "tags" : [
        ]
      },
      {
        "id" : "5bfe410c-0687-49bc-8db2-5b46805a5057",
        "parentId" : "aa0263a2-3822-4e6b-b36f-f9026235e2e2",
        "authorId" : "f7ed27fc-83ac-401f-af8b-91c645eda7e9",
        "body" : "should be\r\n\r\n`'ERROR' ≡ Λ α : ⋆. λ x : 'Text'. 'THROW' @α ('make_any_exception' @'GeneralError'  x ('MAKE_GENERAL_ERROR' x))`",
        "createdAt" : "2020-11-30T11:41:00Z",
        "updatedAt" : "2020-11-30T11:41:00Z",
        "lastEditedBy" : "f7ed27fc-83ac-401f-af8b-91c645eda7e9",
        "tags" : [
        ]
      },
      {
        "id" : "3c7369c1-a09f-4ace-9ccc-657592853e80",
        "parentId" : "aa0263a2-3822-4e6b-b36f-f9026235e2e2",
        "authorId" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "body" : "down meaning in the `Built-in functions` section.",
        "createdAt" : "2020-11-30T14:07:48Z",
        "updatedAt" : "2020-11-30T14:07:48Z",
        "lastEditedBy" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "tags" : [
        ]
      }
    ],
    "commit" : "2dda381399ad219133415579aa6665a4affcfddd",
    "line" : 247,
    "diffHunk" : "@@ -1,1 +2531,2535 @@      'ERROR' @τ e\n        ⇓\n      Err ('make_any_exception' @'GeneralError' v ('MAKE_GENERAL_ERROR' v))\n\n      e  ⇓  Err v"
  },
  {
    "id" : "cb2a759e-b267-4889-a056-17bebf38ebcd",
    "prId" : 8018,
    "prUrl" : "https://github.com/digital-asset/daml/pull/8018",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "565f55fe-7d1d-43d2-a0e4-241d5de7180c",
        "parentId" : null,
        "authorId" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "body" : "```suggestion\r\nIf you hate yourself and want to use Emacs' TeX input mode, , you can turn it on using ``M-x\r\n```\r\nsigned: an emacs user",
        "createdAt" : "2020-11-19T18:07:05Z",
        "updatedAt" : "2020-11-19T18:07:22Z",
        "lastEditedBy" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "tags" : [
        ]
      }
    ],
    "commit" : "32d6188cbcfafd71db24aec8e25bef687dcdb0b0",
    "line" : 18,
    "diffHunk" : "@@ -1,1 +47,51 @@further symbols that's where they could go.\n\nIf you want to use Emacs' TeX input mode, , you can turn it on using ``M-x\nset-input-method TeX``, and then you can input symbols as you would in\nTeX, mostly using ``\\symbol-name`` and ``_letter``. If you don't know"
  },
  {
    "id" : "515e592d-c355-463d-bf7f-7a43928973b4",
    "prId" : 7946,
    "prUrl" : "https://github.com/digital-asset/daml/pull/7946",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "641660d4-cddd-4a29-8c46-9475cad9775a",
        "parentId" : null,
        "authorId" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "body" : "```suggestion\r\n      Γ  ⊢  Mod:T τ₁ … τₙ  //  Mod:T:Vᵢ x  →  e : σ\r\n```\r\nor drop the `i` indices above, which probably makes it easier to read.",
        "createdAt" : "2020-11-12T10:06:38Z",
        "updatedAt" : "2020-11-12T10:39:30Z",
        "lastEditedBy" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "tags" : [
        ]
      },
      {
        "id" : "98bfa2c7-cb43-49d6-a2ff-f9ce63a108a0",
        "parentId" : "641660d4-cddd-4a29-8c46-9475cad9775a",
        "authorId" : "f7ed27fc-83ac-401f-af8b-91c645eda7e9",
        "body" : "Good point!",
        "createdAt" : "2020-11-12T10:30:26Z",
        "updatedAt" : "2020-11-12T10:39:30Z",
        "lastEditedBy" : "f7ed27fc-83ac-401f-af8b-91c645eda7e9",
        "tags" : [
        ]
      },
      {
        "id" : "97d32ae3-2121-4104-8f46-c8b33cbcadd9",
        "parentId" : "641660d4-cddd-4a29-8c46-9475cad9775a",
        "authorId" : "f7ed27fc-83ac-401f-af8b-91c645eda7e9",
        "body" : "I dropped the i indices and renamed σᵢ to τ and σᵢ' to τ', reserving σ only for the output type.",
        "createdAt" : "2020-11-12T10:40:01Z",
        "updatedAt" : "2020-11-12T10:40:01Z",
        "lastEditedBy" : "f7ed27fc-83ac-401f-af8b-91c645eda7e9",
        "tags" : [
        ]
      }
    ],
    "commit" : "6f203ba2b31c49c4f87095b6a2b08919c4794f31",
    "line" : 114,
    "diffHunk" : "@@ -1,1 +1300,1304 @@      x : τ'[α₁ ↦ τ₁, …, αₙ ↦ τₙ] · Γ  ⊢  e : σ\n    ——————————————————————————————————————————————————————————————— AltVariant\n      Γ  ⊢  Mod:T τ₁ … τₙ  //  Mod:T:V x  →  e : σ\n\n      'enum' T ↦ … | E | …  ∈  〚Ξ〛Mod"
  },
  {
    "id" : "6734f22e-4e55-4d8d-86c5-5bd7751f081d",
    "prId" : 7702,
    "prUrl" : "https://github.com/digital-asset/daml/pull/7702",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b9aa5c4a-c6b4-4579-adbb-f0263f17b8ca",
        "parentId" : null,
        "authorId" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "body" : "Unrelated to this PR, what do you think about renaming `exercise` into `exercise_with_actors` and `exercise_without_actors` into `exercise`? The only name existing in the protobuf is `exercise` and the with/without part is controlled via the optionality of the `actors` field. ",
        "createdAt" : "2020-10-15T16:47:24Z",
        "updatedAt" : "2020-10-19T07:48:55Z",
        "lastEditedBy" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "tags" : [
        ]
      },
      {
        "id" : "c826460f-4ef2-4ed9-aee7-33858bc9d1c2",
        "parentId" : "b9aa5c4a-c6b4-4579-adbb-f0263f17b8ca",
        "authorId" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "body" : "As 'exercise' is supported only by LF < 1.5, we should just kill `exercise` and rename `exercise_without_actors` into exercise. ",
        "createdAt" : "2020-10-15T17:48:04Z",
        "updatedAt" : "2020-10-19T07:48:55Z",
        "lastEditedBy" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "tags" : [
        ]
      },
      {
        "id" : "ef8a2d2b-dace-41bf-9867-3bbb7cdbd4cc",
        "parentId" : "b9aa5c4a-c6b4-4579-adbb-f0263f17b8ca",
        "authorId" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "body" : "I'm fine with that too.",
        "createdAt" : "2020-10-16T07:44:47Z",
        "updatedAt" : "2020-10-19T07:48:55Z",
        "lastEditedBy" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "tags" : [
        ]
      }
    ],
    "commit" : "6604ac53017e1398a66910a2038fbf56eb93d36c",
    "line" : 12,
    "diffHunk" : "@@ -1,1 +702,706 @@       |  'fetch' @Mod:T e                          -- UpdateFetch\n       |  'exercise' @Mod:T Ch e₁ e₂ e₃             -- UpdateExercise\n       |  'exercise_without_actors' @Mod:T Ch e₁ e₂ -- UpdateExerciseWithoutActors\n       |  'exercise_by_key' @Mod:T Ch e₁ e₂         -- UpdateExerciseByKey\n       |  'get_time'                                -- UpdateGetTime"
  },
  {
    "id" : "5ddcd9c4-a7ed-4540-b3d9-73214af415c0",
    "prId" : 7702,
    "prUrl" : "https://github.com/digital-asset/daml/pull/7702",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b2fc347a-1408-4d08-97ee-651f0870e09b",
        "parentId" : null,
        "authorId" : "f7ed27fc-83ac-401f-af8b-91c645eda7e9",
        "body" : "This is a nice approach, but the `ur` includes the ledger transaction, which means we aren't distinguishing between \"exercise\" and \"exercise by key\". Maybe the semantics needs to be reformulated anyway to track the transaction structure more closely, so I'm ok leaving it like this for now.",
        "createdAt" : "2020-10-16T12:09:51Z",
        "updatedAt" : "2020-10-19T07:48:55Z",
        "lastEditedBy" : "f7ed27fc-83ac-401f-af8b-91c645eda7e9",
        "tags" : [
        ]
      },
      {
        "id" : "a793e1fd-c4fd-4983-bf21-630d4830b0b2",
        "parentId" : "b2fc347a-1408-4d08-97ee-651f0870e09b",
        "authorId" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "body" : "You are right, this does not make the distinction between \"exercise\" and \"exercise by key\". But currently the implementation does not neither, so it is probably fine to let the semantics like that until we introduce a new transaction format. ",
        "createdAt" : "2020-10-19T07:48:47Z",
        "updatedAt" : "2020-10-19T07:54:26Z",
        "lastEditedBy" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "tags" : [
        ]
      },
      {
        "id" : "1951feb8-6d43-419a-bb9e-e37b47e428af",
        "parentId" : "b2fc347a-1408-4d08-97ee-651f0870e09b",
        "authorId" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "body" : "Let's leave it as is for now and fix it when we've introduced the new transaction format.",
        "createdAt" : "2020-10-19T08:17:11Z",
        "updatedAt" : "2020-10-19T08:17:12Z",
        "lastEditedBy" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "tags" : [
        ]
      }
    ],
    "commit" : "6604ac53017e1398a66910a2038fbf56eb93d36c",
    "line" : 97,
    "diffHunk" : "@@ -1,1 +2930,2934 @@     'exercise_without_actor' Mod:T.Ch cid v₁ ‖ (st'; keys')  ⇓ᵤ  ur\n   —————————————————————————————————————————————————————————————————————— EvUpdExercByKeyExercise\n     'exercise_by_key' Mod:T.Ch vₖ v₁ ‖ (st; keys)  ⇓ᵤ  ur\n\n     LitTimestamp is the current ledger time"
  },
  {
    "id" : "6ee9b7ff-41db-43ff-b30f-5a7fdbb79f66",
    "prId" : 7548,
    "prUrl" : "https://github.com/digital-asset/daml/pull/7548",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d13a244f-89e4-4f8d-acf5-96f6fd62465c",
        "parentId" : null,
        "authorId" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "body" : ":+1: \r\n",
        "createdAt" : "2020-10-21T07:30:21Z",
        "updatedAt" : "2020-10-21T08:55:23Z",
        "lastEditedBy" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "tags" : [
        ]
      }
    ],
    "commit" : "1968095863437d26708412e9478b8d076d85897c",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +4167,4171 @@................\n\n  FIXME: https://github.com/digital-asset/daml/issues/7709\n\n"
  },
  {
    "id" : "ff57dfb4-7a9a-4da0-b8cb-9fb131e9c50e",
    "prId" : 7323,
    "prUrl" : "https://github.com/digital-asset/daml/pull/7323",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "78ce14c1-7821-40fd-9dc9-142ab4a387ca",
        "parentId" : null,
        "authorId" : "f7ed27fc-83ac-401f-af8b-91c645eda7e9",
        "body" : "Nice catch!",
        "createdAt" : "2020-09-04T11:55:24Z",
        "updatedAt" : "2020-09-04T13:26:39Z",
        "lastEditedBy" : "f7ed27fc-83ac-401f-af8b-91c645eda7e9",
        "tags" : [
        ]
      }
    ],
    "commit" : "8676a95a356729b3e2ead7d36e9850236bcc1940",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +1151,1155 @@      Γ  ⊢  Mod:T:Eᵢ  :  Mod:T\n\n      ⟨ f₁: τ₁, …, fₘ: τₘ ⟩ ↠ σ\n      Γ  ⊢  σ  :  ⋆\n      Γ  ⊢  e₁  :  τ₁      ⋯      Γ  ⊢  eₘ  :  τₘ"
  },
  {
    "id" : "154227c4-9c85-40a4-8bdf-60ca4edd2d1a",
    "prId" : 6955,
    "prUrl" : "https://github.com/digital-asset/daml/pull/6955",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "916fc2cf-c76f-4f27-ae60-692dd759afb3",
        "parentId" : null,
        "authorId" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "body" : "Shouldn't that refer to `fetch` rather than `exercise`?\r\n```suggestion\r\n     Err \"Fetch of unknown contract\"\r\n```",
        "createdAt" : "2020-08-03T10:49:47Z",
        "updatedAt" : "2020-08-03T11:14:29Z",
        "lastEditedBy" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "tags" : [
        ]
      },
      {
        "id" : "b38bc4bd-5350-4755-b900-e48fc247e020",
        "parentId" : "916fc2cf-c76f-4f27-ae60-692dd759afb3",
        "authorId" : "f7ed27fc-83ac-401f-af8b-91c645eda7e9",
        "body" : "No, it's not a mistake. Fetch errors look like exercise errors (see the other fetch error case). I don't know if this is desirable, but it's closer to the implementation. My guess is that we'll have to redo all the errors at some point (looking at the future w/ exception handling) and we can fix this then.",
        "createdAt" : "2020-08-03T11:11:48Z",
        "updatedAt" : "2020-08-03T11:14:29Z",
        "lastEditedBy" : "f7ed27fc-83ac-401f-af8b-91c645eda7e9",
        "tags" : [
        ]
      }
    ],
    "commit" : "9aac3c3394fb6245884f63524ea6db94d04e8e05",
    "line" : 34,
    "diffHunk" : "@@ -1,1 +2802,2806 @@     'fetch' @Mod:T cid ‖ (st; keys)\n       ⇓ᵤ\n     Err \"Exercise on unknown contract\"\n\n     'tpl' (x : T) ↦ …  ∈  〚Ξ〛Mod"
  },
  {
    "id" : "68c86f23-e369-4091-ad67-14cf8bf749fe",
    "prId" : 6867,
    "prUrl" : "https://github.com/digital-asset/daml/pull/6867",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a02fa22a-f9a5-4957-882c-35c45b10ec13",
        "parentId" : null,
        "authorId" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "body" : "Maybe use more descriptive names than `v_1` and `v_2` here?, e.g., `actors` or `acts` for `v_1`.",
        "createdAt" : "2020-07-27T10:38:17Z",
        "updatedAt" : "2020-07-27T14:36:06Z",
        "lastEditedBy" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "tags" : [
        ]
      },
      {
        "id" : "9856fb85-d6fe-41f7-b068-096f2f8cc915",
        "parentId" : "a02fa22a-f9a5-4957-882c-35c45b10ec13",
        "authorId" : "f7ed27fc-83ac-401f-af8b-91c645eda7e9",
        "body" : "I like the idea but don't want to break the convention of using `v` for values, and `vₐ` is already taken here (see EvUpdExercConsum)... ",
        "createdAt" : "2020-07-27T12:19:30Z",
        "updatedAt" : "2020-07-27T14:36:06Z",
        "lastEditedBy" : "f7ed27fc-83ac-401f-af8b-91c645eda7e9",
        "tags" : [
        ]
      },
      {
        "id" : "f2762e01-a993-4b55-9316-a91588d0b658",
        "parentId" : "a02fa22a-f9a5-4957-882c-35c45b10ec13",
        "authorId" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "body" : "The pattern we use here of giving a grammar for `v` and then using indexed versions of `v` is very customary. Unfortunately, we can't have more complex indices like \"actor\" here unlike in LaTeX.",
        "createdAt" : "2020-07-27T13:35:59Z",
        "updatedAt" : "2020-07-27T14:36:06Z",
        "lastEditedBy" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "tags" : [
        ]
      }
    ],
    "commit" : "9d0c743f6386697c27bf1f9dad3dc5bd2def557e",
    "line" : 26,
    "diffHunk" : "@@ -1,1 +2694,2698 @@     cid ∈ dom(st₀)\n     st₀(cid) = (Mod:T, vₜ, 'active')\n     eₚ[x ↦ vₜ, z ↦ v₂]  ⇓  Ok vₚ\n     v₁ ≠ₛ vₚ\n   —————————————————————————————————————————————————————————————————————— EvUpdExercBadActors"
  },
  {
    "id" : "590e4096-0566-434d-9b8a-12b82086762c",
    "prId" : 6867,
    "prUrl" : "https://github.com/digital-asset/daml/pull/6867",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "74304bac-055b-4d86-8056-f458806e13a7",
        "parentId" : null,
        "authorId" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "body" : "```suggestion\r\n   —————————————————————————————————————————————————————————————————————— EvUpdExercChcBodyExec\r\n```",
        "createdAt" : "2020-07-27T10:45:06Z",
        "updatedAt" : "2020-07-27T14:36:06Z",
        "lastEditedBy" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "tags" : [
        ]
      },
      {
        "id" : "4ae862c1-8147-40d2-b052-a48c511ed6b1",
        "parentId" : "74304bac-055b-4d86-8056-f458806e13a7",
        "authorId" : "f7ed27fc-83ac-401f-af8b-91c645eda7e9",
        "body" : "The other rule name change are good -- I went ahead and used them (putting the `Err` at the end to make it more obvious that these are error cases).\r\n\r\nThis particular suggestion is less good, because the name `EvUpdExercConsumErr` doesn't have any ambiguity, and it draws parallels to the similar but different error that can arise out of a non-consuming choice. I'm going to leave this one as it is.",
        "createdAt" : "2020-07-27T12:27:55Z",
        "updatedAt" : "2020-07-27T14:36:06Z",
        "lastEditedBy" : "f7ed27fc-83ac-401f-af8b-91c645eda7e9",
        "tags" : [
        ]
      }
    ],
    "commit" : "9d0c743f6386697c27bf1f9dad3dc5bd2def557e",
    "line" : 56,
    "diffHunk" : "@@ -1,1 +2723,2727 @@     st₁ = st₀[cid ↦ (Mod:T, vₜ, 'inactive')]\n     uₐ ‖ (st₁, keys₁)  ⇓ᵤ  Err t\n   —————————————————————————————————————————————————————————————————————— EvUpdExercConsumErr\n     'exercise' Mod:T.Ch cid v₁ v₂ ‖ (st₀, keys₀)\n       ⇓ᵤ"
  },
  {
    "id" : "e417c148-4bdb-4f8d-920c-f38d380b18a5",
    "prId" : 6867,
    "prUrl" : "https://github.com/digital-asset/daml/pull/6867",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a8da57e3-ba9d-4c1f-89d1-2ff1ce495144",
        "parentId" : null,
        "authorId" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "body" : "```suggestion\r\n     Err \"Fetch of inactive contract\"\r\n```",
        "createdAt" : "2020-07-27T11:28:55Z",
        "updatedAt" : "2020-07-27T14:36:06Z",
        "lastEditedBy" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "tags" : [
        ]
      },
      {
        "id" : "fcbfe06c-4995-47a8-9b95-c09bbb80b829",
        "parentId" : "a8da57e3-ba9d-4c1f-89d1-2ff1ce495144",
        "authorId" : "f7ed27fc-83ac-401f-af8b-91c645eda7e9",
        "body" : "I disagree on the basis that the current error messages that you get don't distinguish between archives/fetches/exercises on inactive contracts, saying they are all \"exercise on inactive contract\"-type errors.",
        "createdAt" : "2020-07-27T12:07:03Z",
        "updatedAt" : "2020-07-27T14:36:06Z",
        "lastEditedBy" : "f7ed27fc-83ac-401f-af8b-91c645eda7e9",
        "tags" : [
        ]
      },
      {
        "id" : "09c4b9c2-0920-40e4-b84c-2fb5958d4a77",
        "parentId" : "a8da57e3-ba9d-4c1f-89d1-2ff1ce495144",
        "authorId" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "body" : "Makes sense :+1:",
        "createdAt" : "2020-07-27T12:12:20Z",
        "updatedAt" : "2020-07-27T14:36:06Z",
        "lastEditedBy" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "tags" : [
        ]
      }
    ],
    "commit" : "9d0c743f6386697c27bf1f9dad3dc5bd2def557e",
    "line" : 146,
    "diffHunk" : "@@ -1,1 +2792,2796 @@     'fetch' @Mod:T cid ‖ (st; keys)\n       ⇓ᵤ\n     Err \"Exercise on inactive contract\"\n\n     'tpl' (x : T) ↦ …  ∈  〚Ξ〛Mod"
  },
  {
    "id" : "be8b6471-8725-492b-b850-13ed9101dbcc",
    "prId" : 6867,
    "prUrl" : "https://github.com/digital-asset/daml/pull/6867",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "275f7462-b8b9-4acc-8ee6-5d9a15c7171f",
        "parentId" : null,
        "authorId" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "body" : "```suggestion\r\n     Err \"Fetch of inactive contract\"\r\n```",
        "createdAt" : "2020-07-27T11:33:50Z",
        "updatedAt" : "2020-07-27T14:36:06Z",
        "lastEditedBy" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "tags" : [
        ]
      }
    ],
    "commit" : "9d0c743f6386697c27bf1f9dad3dc5bd2def557e",
    "line" : 192,
    "diffHunk" : "@@ -1,1 +2824,2828 @@     'fetch_by_key' @Mod:T vₖ ‖ (st; keys)\n        ⇓ᵤ\n     Err \"Exercise on inactive contract\"\n\n     'tpl' (x : T) ↦ { …, 'key' @σ eₖ eₘ }  ∈  〚Ξ〛Mod"
  },
  {
    "id" : "f6eb011f-1c59-4b24-86f1-40044fd09dfa",
    "prId" : 6598,
    "prUrl" : "https://github.com/digital-asset/daml/pull/6598",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fe6a7684-53ce-421a-bae5-c111703f4bf5",
        "parentId" : null,
        "authorId" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "body" : "Isn't this is a breaking change because we removed the (uninhabited) kind `k -> nat`? This would be a problem since DAML Engine needs to be able to load DARs which contain type abstractions of this kind.\r\nI would suggest we keep the definition of kinds as is and add the notion of \"erasable kinds\" as defined above on top of that. Then one can prove that each kind `k` satisfies one of the following three:\r\n1. `k` is erasable.\r\n2. There are `k_1, ..., k_n` with `n >= 1` and `k = k_1 -> k2 -> ... -> k_n -> nat` and hence `k` is uninhabited and can hence be erased at runtime as well.\r\n3. `k = nat`. This is the case where we need to demote from the type to the value level.",
        "createdAt" : "2020-07-08T16:20:20Z",
        "updatedAt" : "2020-07-21T15:04:55Z",
        "lastEditedBy" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "tags" : [
        ]
      },
      {
        "id" : "59e70be2-f6c9-4fcf-811b-a85135d4299b",
        "parentId" : "fe6a7684-53ce-421a-bae5-c111703f4bf5",
        "authorId" : "f7ed27fc-83ac-401f-af8b-91c645eda7e9",
        "body" : "The problem is that the speedy compiler currently blows up if you try to apply `f` when it has kind `* -> nat`. You can introduce such variables with a forall or type lambda. This makes it an illegal kind in some ways but not others. It sounds like you want to do something else in these cases?\r\n\r\nFor example, the term `/\\(f : * -> nat). ADD_NUMERIC @(f Unit)` is perfectly valid under current LF spec, but speedy will balk before it even tries to run it. \r\n\r\nI feel like outlawing this kind construction outright is better than giving it any sort of semantics in Speedy.",
        "createdAt" : "2020-07-08T16:57:35Z",
        "updatedAt" : "2020-07-21T15:04:55Z",
        "lastEditedBy" : "f7ed27fc-83ac-401f-af8b-91c645eda7e9",
        "tags" : [
        ]
      },
      {
        "id" : "6a5e2c1a-eea4-4752-b6e9-b3fa4a928b40",
        "parentId" : "fe6a7684-53ce-421a-bae5-c111703f4bf5",
        "authorId" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "body" : "@sofiafaro-da I understand that the change to the spec you suggested would bring it in line with the implementation. The implementation would not stop accepting DARs it has accepted before. Is that correct? If so, then I'm on board.",
        "createdAt" : "2020-07-09T07:35:02Z",
        "updatedAt" : "2020-07-21T15:04:55Z",
        "lastEditedBy" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "tags" : [
        ]
      },
      {
        "id" : "4f2f314d-90a9-4ca3-a9ea-032a971eac16",
        "parentId" : "fe6a7684-53ce-421a-bae5-c111703f4bf5",
        "authorId" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "body" : "@sofiafaro-da The implementation will not blow up, because as stated  by @hurryabit the kind `⋆ →nat` is uninhabited. Speedy compiler will handle `/\\(f : * -> nat). ADD_NUMERIC @(f Unit)` (producing some garbage code), \r\nbut one cannot run this latter, because there exists no `f` of kind  `⋆ →nat`\r\n\r\nI add 3 tests in #6618 (could you merge it with the current PR):\r\n* One checks that `⋆ →nat` is a valid kind\r\n* One checks that `⋆ →nat` is inhabited. \r\n* `/\\(f : * -> nat). ADD_NUMERIC @(f Unit)` can be evaluated without blowing up.",
        "createdAt" : "2020-07-09T08:20:05Z",
        "updatedAt" : "2020-07-21T15:04:55Z",
        "lastEditedBy" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "tags" : [
        ]
      },
      {
        "id" : "56aca9f7-d1f6-4253-9102-bcf07114ca85",
        "parentId" : "fe6a7684-53ce-421a-bae5-c111703f4bf5",
        "authorId" : "f7ed27fc-83ac-401f-af8b-91c645eda7e9",
        "body" : "We discussed this extensively and came up with a counterexample, where keeping `* -> nat` causes problems in the engine (causes a runtime type error):\r\n\r\n```\r\nlet g: forall(n:nat). Int64 = /\\(n: nat). 1\r\nin /\\(f: * -> nat). ADD_INT64 10 (g @(f Unit))\r\n```\r\n\r\nBecause of the interaction between the erasable kind `* -> nat` and non-erasable kind `nat`. We definitely want to avoid this by outlawing `* -> nat` as I proposed here.",
        "createdAt" : "2020-07-20T15:29:00Z",
        "updatedAt" : "2020-07-21T15:04:55Z",
        "lastEditedBy" : "f7ed27fc-83ac-401f-af8b-91c645eda7e9",
        "tags" : [
        ]
      }
    ],
    "commit" : "0b5b8d6f9826b681bfc839a684099b92c822db82",
    "line" : 12,
    "diffHunk" : "@@ -1,1 +600,604 @@    ek\n      ::= ⋆                                         -- KindStar\n       | k → ek                                     -- KindArrow\n\n  Module references"
  },
  {
    "id" : "c6045416-25eb-4ef7-b557-5770cf65d082",
    "prId" : 6598,
    "prUrl" : "https://github.com/digital-asset/daml/pull/6598",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1498f511-a462-4135-8013-13e834e77687",
        "parentId" : null,
        "authorId" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "body" : "In the long run we probably need to distinguish different error classes, such as errors raised via `error`, arithmetic errors, pattern match failures, etc. I would suggest making that the subject of a separate PR though.",
        "createdAt" : "2020-07-08T16:30:36Z",
        "updatedAt" : "2020-07-21T15:04:55Z",
        "lastEditedBy" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "tags" : [
        ]
      },
      {
        "id" : "5ecede6c-443d-4f41-9658-9e6dc8fdb371",
        "parentId" : "1498f511-a462-4135-8013-13e834e77687",
        "authorId" : "f7ed27fc-83ac-401f-af8b-91c645eda7e9",
        "body" : "I think that can be done easily enough by giving `t` some structure, without really changing most of the semantics.",
        "createdAt" : "2020-07-08T17:01:31Z",
        "updatedAt" : "2020-07-21T15:04:55Z",
        "lastEditedBy" : "f7ed27fc-83ac-401f-af8b-91c645eda7e9",
        "tags" : [
        ]
      }
    ],
    "commit" : "0b5b8d6f9826b681bfc839a684099b92c822db82",
    "line" : 160,
    "diffHunk" : "@@ -1,1 +2060,2064 @@  Evaluation result\n    r ::= Ok v                                      -- ResOk\n       |  Err t                                     -- ResErr\n\n                           ┌──────────┐"
  },
  {
    "id" : "be9b8103-933a-4e56-8261-0420ee388c86",
    "prId" : 6598,
    "prUrl" : "https://github.com/digital-asset/daml/pull/6598",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a265a747-473a-46fd-99ac-cb96a2ab9b1c",
        "parentId" : null,
        "authorId" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "body" : "Should we make it clearer that `e_2, ..., e_{i-1}` need to succeed as well? The same occurs a few more times below.",
        "createdAt" : "2020-07-08T16:32:56Z",
        "updatedAt" : "2020-07-21T15:04:55Z",
        "lastEditedBy" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "tags" : [
        ]
      },
      {
        "id" : "646ce614-c63c-4adb-b783-78e31d77a852",
        "parentId" : "a265a747-473a-46fd-99ac-cb96a2ab9b1c",
        "authorId" : "f7ed27fc-83ac-401f-af8b-91c645eda7e9",
        "body" : "Would it be clear enough as:\r\n\r\n```\r\n      e₁  ⇓  Ok v₁\r\n        ⋮\r\n      eᵢ₋₁  ⇓  Ok ᵢ₋₁\r\n      eᵢ  ⇓  Err t\r\n```",
        "createdAt" : "2020-07-08T16:45:45Z",
        "updatedAt" : "2020-07-21T15:04:55Z",
        "lastEditedBy" : "f7ed27fc-83ac-401f-af8b-91c645eda7e9",
        "tags" : [
        ]
      },
      {
        "id" : "a7cc6395-2061-44d8-9f1e-751d6d9a1ca3",
        "parentId" : "a265a747-473a-46fd-99ac-cb96a2ab9b1c",
        "authorId" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "body" : "Yes, that should make it crystal clear. (There's a `v` missing in the penultimate line.)",
        "createdAt" : "2020-07-08T16:54:54Z",
        "updatedAt" : "2020-07-21T15:04:55Z",
        "lastEditedBy" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "tags" : [
        ]
      }
    ],
    "commit" : "0b5b8d6f9826b681bfc839a684099b92c822db82",
    "line" : 316,
    "diffHunk" : "@@ -1,1 +2178,2182 @@        ⋮\n      eᵢ₋₁  ⇓  Ok vᵢ₋₁\n      eᵢ  ⇓  Err t\n    —————————————————————————————————————————————————————————————————————— EvExpBuiltinErr\n      F @τ₁ … @τₘ e₁ … eₙ  ⇓  Err t"
  },
  {
    "id" : "84a0b69f-3ac1-4c2c-aff2-b1f22c1cb96b",
    "prId" : 6598,
    "prUrl" : "https://github.com/digital-asset/daml/pull/6598",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e7d15b9e-772a-49ab-81b3-1b5dcaeb77fa",
        "parentId" : null,
        "authorId" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "body" : "Our syntax for record projections looks really weird. 🤔 ",
        "createdAt" : "2020-07-08T16:34:25Z",
        "updatedAt" : "2020-07-21T15:04:55Z",
        "lastEditedBy" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "tags" : [
        ]
      },
      {
        "id" : "efa0846e-004c-4110-b3fa-01b60a2f940d",
        "parentId" : "e7d15b9e-772a-49ab-81b3-1b5dcaeb77fa",
        "authorId" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "body" : "@hurryabit please propose a syntax that we can easily add to the daml-lf parser. ",
        "createdAt" : "2020-07-09T08:22:34Z",
        "updatedAt" : "2020-07-21T15:04:55Z",
        "lastEditedBy" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "tags" : [
        ]
      }
    ],
    "commit" : "0b5b8d6f9826b681bfc839a684099b92c822db82",
    "line" : 364,
    "diffHunk" : "@@ -1,1 +2213,2217 @@      e  ⇓  Err t\n    —————————————————————————————————————————————————————————————————————— EvExpRecProjErr\n      Mod:T @τ₁ … @τₘ {fᵢ} e  ⇓  Err t\n\n      e  ⇓  Ok (Mod:T @τ₁ … @τₘ {f₁= v₁, …, fᵢ= vᵢ, …, fₙ= vₙ})"
  },
  {
    "id" : "dea7bd64-92a3-44fa-aa60-575f1d36b6d4",
    "prId" : 6598,
    "prUrl" : "https://github.com/digital-asset/daml/pull/6598",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "33474bbe-d8ef-4757-8c3f-e59561f1df43",
        "parentId" : null,
        "authorId" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "body" : "```suggestion\r\n```",
        "createdAt" : "2020-07-21T07:41:55Z",
        "updatedAt" : "2020-07-21T15:04:55Z",
        "lastEditedBy" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "tags" : [
        ]
      }
    ],
    "commit" : "0b5b8d6f9826b681bfc839a684099b92c822db82",
    "line" : 626,
    "diffHunk" : "@@ -1,1 +2429,2433 @@    —————————————————————————————————————————————————————————————————————— EvExpScenarioPass\n      'pass' e  ⇓  Ok ('pass' v)\n\n      e  ⇓  Err t\n    —————————————————————————————————————————————————————————————————————— EvExpScenarioGetPartyErr"
  },
  {
    "id" : "07c2d144-ef74-400b-a72b-dd3903ed9f42",
    "prId" : 6598,
    "prUrl" : "https://github.com/digital-asset/daml/pull/6598",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "586399db-c2ea-4e72-83b1-59eabbfa0432",
        "parentId" : null,
        "authorId" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "body" : "We should make clear that the update interpretation work only on update value (maybe explaining how are handle non value update statement), or add a rule like:\r\n\r\n```\r\nu not a value\r\nu ⇓  Ok v\r\nv ‖ E ; (st, keys)   ⇓ᵤ   ur  || S\r\n-----------------------------------------\r\nu ‖ E ; (st, keys)   ⇓ᵤ   ur  || S\r\n```\r\n\r\nIn the second case I think we could simplify some other rules.",
        "createdAt" : "2020-07-21T08:03:15Z",
        "updatedAt" : "2020-07-21T15:04:55Z",
        "lastEditedBy" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "tags" : [
        ]
      },
      {
        "id" : "4edbf146-f2d1-400c-bdb8-66d8e0cc83a6",
        "parentId" : "586399db-c2ea-4e72-83b1-59eabbfa0432",
        "authorId" : "f7ed27fc-83ac-401f-af8b-91c645eda7e9",
        "body" : "I think we should keep the expression evaluation and update interpretation separate, so I'll add something saying that this relation is only defined for update values `u`.",
        "createdAt" : "2020-07-21T09:57:50Z",
        "updatedAt" : "2020-07-21T15:04:55Z",
        "lastEditedBy" : "f7ed27fc-83ac-401f-af8b-91c645eda7e9",
        "tags" : [
        ]
      },
      {
        "id" : "3004eb90-7d92-451c-8253-de062033b76e",
        "parentId" : "586399db-c2ea-4e72-83b1-59eabbfa0432",
        "authorId" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "body" : ":+1: \r\n",
        "createdAt" : "2020-07-21T09:59:55Z",
        "updatedAt" : "2020-07-21T15:04:55Z",
        "lastEditedBy" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "tags" : [
        ]
      },
      {
        "id" : "fd3646b0-4b24-4c73-a821-cae2e6b6eaa2",
        "parentId" : "586399db-c2ea-4e72-83b1-59eabbfa0432",
        "authorId" : "f7ed27fc-83ac-401f-af8b-91c645eda7e9",
        "body" : "So, the comments before this section already mention this (every `u` in this section has to be a value). But I added a little reminder next to the \"box\".",
        "createdAt" : "2020-07-21T10:06:38Z",
        "updatedAt" : "2020-07-21T15:04:55Z",
        "lastEditedBy" : "f7ed27fc-83ac-401f-af8b-91c645eda7e9",
        "tags" : [
        ]
      }
    ],
    "commit" : "0b5b8d6f9826b681bfc839a684099b92c822db82",
    "line" : 695,
    "diffHunk" : "@@ -1,1 +2545,2549 @@                                    └──────────────┘\n\n   —————————————————————————————————————————————————————————————————————— EvUpdPure\n     'pure' v ‖ (st, keys)  ⇓ᵤ  Ok (v, ε) ‖ (st, keys)\n"
  },
  {
    "id" : "b899c40d-34ff-4033-8484-ab44f2fb4f7c",
    "prId" : 5344,
    "prUrl" : "https://github.com/digital-asset/daml/pull/5344",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4e0df528-2b22-406a-b108-fa98d1a07ac8",
        "parentId" : null,
        "authorId" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "body" : "So many unnecessary changes :slightly_frowning_face: ",
        "createdAt" : "2020-04-01T14:21:16Z",
        "updatedAt" : "2020-04-02T12:01:28Z",
        "lastEditedBy" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "tags" : [
        ]
      },
      {
        "id" : "f07cd66d-fc92-4562-a6b0-2a6dfef9327d",
        "parentId" : "4e0df528-2b22-406a-b108-fa98d1a07ac8",
        "authorId" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "body" : "github has a nice feature  \"Hide whitespace changes\"",
        "createdAt" : "2020-04-01T14:53:09Z",
        "updatedAt" : "2020-04-02T12:01:28Z",
        "lastEditedBy" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "tags" : [
        ]
      }
    ],
    "commit" : "f3e99fe570d6d6948c946adcee18b6f542f3c7ed",
    "line" : 59,
    "diffHunk" : "@@ -1,1 +898,902 @@                       └───────────────┘\n\n     α : k ∈ Γ\n   ————————————————————————————————————————————— TyVar\n     Γ  ⊢  α  :  k"
  },
  {
    "id" : "0e0cb725-89bd-4b5e-b6da-7767226af3f6",
    "prId" : 5321,
    "prUrl" : "https://github.com/digital-asset/daml/pull/5321",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "88d2a148-6766-4cea-b2f2-048f1c807716",
        "parentId" : null,
        "authorId" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "body" : "```suggestion\r\nStarting from DAML SDK 1.0, DAML-LF versions older than 1.6 are\r\n```",
        "createdAt" : "2020-03-31T18:02:04Z",
        "updatedAt" : "2020-03-31T18:22:25Z",
        "lastEditedBy" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "tags" : [
        ]
      }
    ],
    "commit" : "052763d581b46dda90478bba8fcdc3d4e7f49df3",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +67,71 @@1, including all its minor versions.\n\nStarting from DAML SDK 1.0 release, DAML-LF versions older than 1.6 are\ndeprecated. An engine compliant with the present specification must handle\nall versions newer than or equal to DAML-LF 1.6, no requirement is made on"
  },
  {
    "id" : "02e47982-571f-4127-bbe9-4f149d09be46",
    "prId" : 4981,
    "prUrl" : "https://github.com/digital-asset/daml/pull/4981",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "18b82696-8d6f-4a00-8865-784b5d51afd7",
        "parentId" : null,
        "authorId" : null,
        "body" : "One question that the spec should answer: does it raise a runtime error when inserting a value that is incomparable in an empty map? (I think it should raise an error, for the sake of consistency.)",
        "createdAt" : "2020-03-13T15:11:05Z",
        "updatedAt" : "2020-03-16T11:39:24Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "f4e6ed44-9a76-4d24-80f5-278d48f47aca",
        "parentId" : "18b82696-8d6f-4a00-8865-784b5d51afd7",
        "authorId" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "body" : "It does not. \r\nIt raise an exception exactly once `LESS` or `EQUAL` does. \r\n\r\nWe agreed with @hurryabit and @hurryabit that is the only semantics that is reasonable. Otherwise you will have to always traverse all the keys to ensure there is no function nested inside. \r\n\r\nImagine you have the type\r\n\r\n``` \r\ndata D = \r\n    FUN (Int -> Int) \r\n  | INT Int\r\n```\r\n\r\nYou can insert `(Fun (\\x -> x))` in any `GenMap` that does not content `Fun` variant.\r\nYou can also try to lookup the entry of key  `(Fun (\\x -> x))` without raising an exception in any `GenMap` that does not content `Fun` variant.\r\n\r\nHowever as soon you have an entry with a key `(Fun ...)` in your map you cannot do anymore any operation  that invole a other key of the form  `(Fun ...)` without raising an exception. \r\n\r\nThis choices is simpler and more efficient. Furthermore the compiler will never produce such case.\r\n\r\n\r\n",
        "createdAt" : "2020-03-13T16:25:54Z",
        "updatedAt" : "2020-03-16T11:39:24Z",
        "lastEditedBy" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "tags" : [
        ]
      },
      {
        "id" : "a38396f1-be53-4dae-bc05-699d67840fb0",
        "parentId" : "18b82696-8d6f-4a00-8865-784b5d51afd7",
        "authorId" : null,
        "body" : "Ok, if @hurryabit and @hurryabit can confirm ;-) \r\n\r\nThe reason I don't like this is that you are creating the potential for latent runtime errors when you perform inserts -- i.e. creating a runtime error that will only be found on a subsequent lookup, instead of when the real error occurs. This is particularly bad for e.g. people using genmaps during testing, or choice validation.\r\n\r\nWhen adding a new key to the map, It should be easy to compare a key to itself using EQUAL, to make sure it doesn't introduce latent runtime errors.",
        "createdAt" : "2020-03-13T16:34:08Z",
        "updatedAt" : "2020-03-16T11:39:24Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "97668def-3920-4dd7-9aca-a7728f9ddd71",
        "parentId" : "18b82696-8d6f-4a00-8865-784b5d51afd7",
        "authorId" : null,
        "body" : "In the proposed semantics, you are only saving 1 comparison, but you are introducing latent runtime errors, so I don't think it's worth it.",
        "createdAt" : "2020-03-13T16:37:51Z",
        "updatedAt" : "2020-03-16T11:39:24Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "a4468cd5-3218-444c-a4b9-f5e63ef418d4",
        "parentId" : "18b82696-8d6f-4a00-8865-784b5d51afd7",
        "authorId" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "body" : "It depends on what kind of values you have. If you have ADT-like trees, being able to short circuit on comparisons can make a pretty large difference. Given that we prevent this runtime error in DAML, I’m not sure that missing out on better performance here in favor of “nicer semantics” for DAML-LF is worth it. That said, I don’t feel particularly strongly about this.",
        "createdAt" : "2020-03-13T16:42:35Z",
        "updatedAt" : "2020-03-16T11:39:24Z",
        "lastEditedBy" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "tags" : [
        ]
      },
      {
        "id" : "0651b04f-e0a0-41c8-b548-d192e01f7a86",
        "parentId" : "18b82696-8d6f-4a00-8865-784b5d51afd7",
        "authorId" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "body" : "In fact, @associahedron I like your proposal.\r\nThe advantage I see, is that we can switch the implementation to hashmap, if we realize the implementation is too slow (we will sorted the map only for serialization). \r\n \r\nIn other words, in each case (insertion, deletion and lookup) we check the value is equal to itself. Hence we have a nice definition of \"comparable\" value.",
        "createdAt" : "2020-03-13T17:09:01Z",
        "updatedAt" : "2020-03-16T11:39:24Z",
        "lastEditedBy" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "tags" : [
        ]
      },
      {
        "id" : "32c330d9-437a-43a2-bac8-0df77b88d5fa",
        "parentId" : "18b82696-8d6f-4a00-8865-784b5d51afd7",
        "authorId" : null,
        "body" : "@cocreature If you use nested trees as keys, maps are going to be slow regardless. I'm also not confident that this case will never ever occur at runtime in DAML.\r\n\r\n@remyhaemmerle-da 👍",
        "createdAt" : "2020-03-13T17:41:05Z",
        "updatedAt" : "2020-03-16T11:39:24Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "309073ed-dfe5-45dc-9b72-81ceff12da19",
        "parentId" : "18b82696-8d6f-4a00-8865-784b5d51afd7",
        "authorId" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "body" : "Alright, then let’s error out for now.",
        "createdAt" : "2020-03-13T18:31:03Z",
        "updatedAt" : "2020-03-16T11:39:24Z",
        "lastEditedBy" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "tags" : [
        ]
      }
    ],
    "commit" : "f38d1e03c596ac36159ab0ba5c28c7b89ff02cd9",
    "line" : 51,
    "diffHunk" : "@@ -1,1 +3152,3156 @@  is inserted in order according to the builtin function ``LESS`` applied\n  on keys. This raises a runtime error if it tries to compare\n  incomparable values.\n\n  [*Available in versions >= 1.dev*]"
  },
  {
    "id" : "21d484c4-75ea-4a28-bc64-07b082a550fe",
    "prId" : 4981,
    "prUrl" : "https://github.com/digital-asset/daml/pull/4981",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4aad2f30-222c-4466-aebf-f30a31b767f9",
        "parentId" : null,
        "authorId" : null,
        "body" : "We are missing rules for insertion in empty maps.\r\n\r\nAgain, for the empty map, I think the rule should perform a comparison in order to verify that the key is a comparable value.",
        "createdAt" : "2020-03-13T15:14:00Z",
        "updatedAt" : "2020-03-16T11:39:24Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "93b61da0-1991-45d5-a2e3-a97b1103fb14",
        "parentId" : "4aad2f30-222c-4466-aebf-f30a31b767f9",
        "authorId" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "body" : "Good catch for the empty maps case",
        "createdAt" : "2020-03-13T16:29:46Z",
        "updatedAt" : "2020-03-16T11:39:24Z",
        "lastEditedBy" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "tags" : [
        ]
      }
    ],
    "commit" : "f38d1e03c596ac36159ab0ba5c28c7b89ff02cd9",
    "line" : 88,
    "diffHunk" : "@@ -1,1 +3187,3191 @@      𝕆('GENMAP_INSERT' @σ @τ 〚v₁ ↦ w₁; …; vₙ ↦ wₙ〛 v w) =\n        'Ok' 〚v₁ ↦ w₁; …; vₙ ↦ wₙ; v ↦ w〛\n\n\n* ``GENMAP_LOOKUP : ∀ α. ∀ β.  α → 'GenMap' α β → 'Optional' α``"
  },
  {
    "id" : "ec4f8f67-1ce7-441f-a05a-6a43bd044009",
    "prId" : 4981,
    "prUrl" : "https://github.com/digital-asset/daml/pull/4981",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "83cd8146-0adf-4f92-bedc-aaf7afb6fbc6",
        "parentId" : null,
        "authorId" : null,
        "body" : "Spec should say what happens in the case of empty map lookup of incomparable keys. (I favor more runtime errors.)",
        "createdAt" : "2020-03-13T15:14:55Z",
        "updatedAt" : "2020-03-16T11:39:24Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "1c72f957-66df-42cf-8122-32878e15021f",
        "parentId" : "83cd8146-0adf-4f92-bedc-aaf7afb6fbc6",
        "authorId" : null,
        "body" : "At lookup it is not super critical to check the key for self-equality, but I think that at insertion time it is more important.",
        "createdAt" : "2020-03-13T16:35:31Z",
        "updatedAt" : "2020-03-16T11:39:24Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "74cbda4a-bc6b-45e0-b888-46580200fcc9",
        "parentId" : "83cd8146-0adf-4f92-bedc-aaf7afb6fbc6",
        "authorId" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "body" : "no error ;)",
        "createdAt" : "2020-03-13T16:37:35Z",
        "updatedAt" : "2020-03-16T11:39:24Z",
        "lastEditedBy" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "tags" : [
        ]
      },
      {
        "id" : "c7af4480-41d6-49b8-8aa7-2c4e1cdb11e2",
        "parentId" : "83cd8146-0adf-4f92-bedc-aaf7afb6fbc6",
        "authorId" : null,
        "body" : "if you want to leave the possibility for hashtable-based implementation open, you should error on bad lookup keys",
        "createdAt" : "2020-03-13T17:45:53Z",
        "updatedAt" : "2020-03-16T11:39:24Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "64323251-fe45-49bc-ba89-8d233d640f4d",
        "parentId" : "83cd8146-0adf-4f92-bedc-aaf7afb6fbc6",
        "authorId" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "body" : "As agreed in previous thread, we raise an error",
        "createdAt" : "2020-03-16T11:36:12Z",
        "updatedAt" : "2020-03-16T11:39:24Z",
        "lastEditedBy" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "tags" : [
        ]
      }
    ],
    "commit" : "f38d1e03c596ac36159ab0ba5c28c7b89ff02cd9",
    "line" : 96,
    "diffHunk" : "@@ -1,1 +3193,3197 @@  Looks up the value at a key in the map using the builtin function\n  ``EQUAL`` to test key equality. This raises a runtime error if it\n  try to compare incomparable values.\n\n  [*Available in versions >= 1.dev*]"
  },
  {
    "id" : "69a459d6-0db3-4e96-8476-90ae1a2efc4a",
    "prId" : 4942,
    "prUrl" : "https://github.com/digital-asset/daml/pull/4942",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "653a56fa-8d1b-4fcb-b1a3-9f265ff95418",
        "parentId" : null,
        "authorId" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "body" : "Shouldn’t the types of the fields be the same, i.e, `t_i` everywhere?",
        "createdAt" : "2020-03-12T10:14:04Z",
        "updatedAt" : "2020-03-12T17:41:28Z",
        "lastEditedBy" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "tags" : [
        ]
      },
      {
        "id" : "51bf58ca-2276-4d2b-8b3f-75fb4f0c4bcf",
        "parentId" : "653a56fa-8d1b-4fcb-b1a3-9f265ff95418",
        "authorId" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "body" : "Struct may have different type for each field",
        "createdAt" : "2020-03-12T11:00:16Z",
        "updatedAt" : "2020-03-12T17:41:28Z",
        "lastEditedBy" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "tags" : [
        ]
      }
    ],
    "commit" : "c930223f08a9f9f104427ac4a4fe184ffe1450b4",
    "line" : 171,
    "diffHunk" : "@@ -1,1 +1876,1880 @@    fᵢ comes lexicographically before gᵢ\n  ——————————————————————————————————————————————————— TypeOrderStructFieldName\n    ⟨ f₁ : τ₁, …, fₘ : τₘ ⟩ <ₜ\n      ⟨ f₁ : σ₁, …, fᵢ₋1 : σᵢ₋₁, gᵢ : σᵢ, …, gₙ : σₙ ⟩\n"
  },
  {
    "id" : "684e104e-c67a-4d66-a72a-0aa50a594769",
    "prId" : 4942,
    "prUrl" : "https://github.com/digital-asset/daml/pull/4942",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "899e5613-c1e7-461b-9cce-8c8a961a8315",
        "parentId" : null,
        "authorId" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "body" : "I don’t understand this rule. Are you trying to say that adding extra fields makes it bigger? If so, I don’t understand why `f_n` is at the end in both cases and what the point of `f_m` is.",
        "createdAt" : "2020-03-12T10:15:26Z",
        "updatedAt" : "2020-03-12T17:41:28Z",
        "lastEditedBy" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "tags" : [
        ]
      },
      {
        "id" : "e35be20e-7a77-42e2-ad58-5c39cbee0f0b",
        "parentId" : "899e5613-c1e7-461b-9cce-8c8a961a8315",
        "authorId" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "body" : "It is better now ? ",
        "createdAt" : "2020-03-12T12:48:57Z",
        "updatedAt" : "2020-03-12T17:41:28Z",
        "lastEditedBy" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "tags" : [
        ]
      }
    ],
    "commit" : "c930223f08a9f9f104427ac4a4fe184ffe1450b4",
    "line" : 178,
    "diffHunk" : "@@ -1,1 +1880,1884 @@\n  ——————————————————————————————————————————————————— TypeOrderStructFieldNumber\n    ⟨ f₁ : τ₁, …, fₘ : τₘ ⟩ <ₜ\n      ⟨ f₁ : τ₁, …, fₘ : τₘ, fₘ₊₁ : τₘ₊₁ ⟩\n"
  },
  {
    "id" : "1f2b881f-79d4-4cbb-8d33-e8757b3aeacd",
    "prId" : 4942,
    "prUrl" : "https://github.com/digital-asset/daml/pull/4942",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3c7f9d0b-a154-46b4-bbdb-ff29507f22be",
        "parentId" : null,
        "authorId" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "body" : "Maybe I’m missing something but which rules allows me to deduce that `Int64 < Numeric 10`?",
        "createdAt" : "2020-03-12T10:19:46Z",
        "updatedAt" : "2020-03-12T17:41:28Z",
        "lastEditedBy" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "tags" : [
        ]
      },
      {
        "id" : "69aaaea1-93f1-4234-be3a-7a8324bde417",
        "parentId" : "3c7f9d0b-a154-46b4-bbdb-ff29507f22be",
        "authorId" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "body" : "By transitivity (stated in the text)  you have  ``Int64 <ₜ  τ σ``  for all ``τ`` and ``σ``.\r\n\r\nI replace the text by an explicit rule.",
        "createdAt" : "2020-03-12T11:09:37Z",
        "updatedAt" : "2020-03-12T17:41:28Z",
        "lastEditedBy" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "tags" : [
        ]
      },
      {
        "id" : "964dd860-fbe3-4e7f-82fb-8bab494de71c",
        "parentId" : "3c7f9d0b-a154-46b4-bbdb-ff29507f22be",
        "authorId" : null,
        "body" : "I don't see it @remyhaemmerle-da . There's no rule that lets you infer, for example, that ` τ₁ <ₜ τ₂ σ` whenever ` τ₁` is not a type application.",
        "createdAt" : "2020-03-12T13:28:38Z",
        "updatedAt" : "2020-03-12T17:41:28Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "58d48842-a58d-4a3d-bcdd-451fe9153542",
        "parentId" : "3c7f9d0b-a154-46b4-bbdb-ff29507f22be",
        "authorId" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "body" : "Yeah I also cannot find it in the text.",
        "createdAt" : "2020-03-12T13:32:00Z",
        "updatedAt" : "2020-03-12T17:41:28Z",
        "lastEditedBy" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "tags" : [
        ]
      },
      {
        "id" : "3229092e-6d2a-4318-9bd8-a854fbefef85",
        "parentId" : "3c7f9d0b-a154-46b4-bbdb-ff29507f22be",
        "authorId" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "body" : "@associahedron \r\n`TypeOrderStructTyApp` allows you to infer trivially `⟨  ⟩ <ₜ τ₂ σ`\r\n\r\n@moritzkiefer-da Here is how I infer `Int64 < Numeric 10`\r\n- Using `TypeOrderTransitivity`, `TypeOrderInt64Date`, and `TypeOrderDateTimestamp` you can infer that 'Int64' <ₜ 'Timestamp'.\r\n- Combining with  `TypeOrderTransitivity`, and  `TypeOrderTimestampText` you can infer that  `'Int64' <ₜ 'Text'`\r\n ...\r\n- Combining with  `TypeOrderTransitivity`, and  `TypeOrderNatStruct` you can infer that ` 'Int64' <ₜ ⟨  ⟩`\r\n- Combining with  `TypeOrderTransitivity` and `TypeOrderStructTyApp` you can infer that  `'Int64' <ₜ Numeric 10`\r\n",
        "createdAt" : "2020-03-12T13:52:48Z",
        "updatedAt" : "2020-03-12T17:41:28Z",
        "lastEditedBy" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "tags" : [
        ]
      },
      {
        "id" : "973b1a32-011f-406c-8e12-7778afb39989",
        "parentId" : "3c7f9d0b-a154-46b4-bbdb-ff29507f22be",
        "authorId" : null,
        "body" : "Oh, I see! That's very hard to see, but it checks out. \r\n\r\nMaybe it would be easier to understand if we used the type rank notion from the scala implementation? We could define a formal type rank function, and then have just one rule for comparing all the types with different type rank.",
        "createdAt" : "2020-03-12T14:05:32Z",
        "updatedAt" : "2020-03-12T17:41:28Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "095c1cbb-1185-46eb-8b06-636054736b33",
        "parentId" : "3c7f9d0b-a154-46b4-bbdb-ff29507f22be",
        "authorId" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "body" : "I do not like to define the rank explicitly (mapping types to integers)  ",
        "createdAt" : "2020-03-12T14:12:54Z",
        "updatedAt" : "2020-03-12T17:41:28Z",
        "lastEditedBy" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "tags" : [
        ]
      },
      {
        "id" : "58bc01f5-81bd-4e8f-9828-152b7816ea63",
        "parentId" : "3c7f9d0b-a154-46b4-bbdb-ff29507f22be",
        "authorId" : null,
        "body" : "I think it would make the spec match the code more closely, and be easier to understand, which are both better for maintenance, but if you are sure about this way then I'm not opposed.",
        "createdAt" : "2020-03-12T14:19:56Z",
        "updatedAt" : "2020-03-12T17:41:28Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "36434659-26ca-4010-8060-ef37cffe7a72",
        "parentId" : "3c7f9d0b-a154-46b4-bbdb-ff29507f22be",
        "authorId" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "body" : "I want to be able to introduce a new type between two already existing.  \r\nThis will oblige me to have different ranks between two specs.  ",
        "createdAt" : "2020-03-12T14:25:40Z",
        "updatedAt" : "2020-03-12T17:41:28Z",
        "lastEditedBy" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "tags" : [
        ]
      },
      {
        "id" : "701d0a8d-2e22-49de-a365-560cd1150735",
        "parentId" : "3c7f9d0b-a154-46b4-bbdb-ff29507f22be",
        "authorId" : null,
        "body" : "That's fine. The type rank function is entirely formal, and would only exist in the spec, not be exposed in DAML/DAML-LF. Alternatively, you can define a formal enumeration of type ranks (instead of an type rank integer) and use the order from the enumeration.\r\n\r\nAnyway, it is up to you.",
        "createdAt" : "2020-03-12T14:32:58Z",
        "updatedAt" : "2020-03-12T17:41:28Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "52a8ce36-03a5-4649-9a2a-d98c4d52532a",
        "parentId" : "3c7f9d0b-a154-46b4-bbdb-ff29507f22be",
        "authorId" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "body" : "I did not include the rank. ",
        "createdAt" : "2020-03-12T21:07:03Z",
        "updatedAt" : "2020-03-12T21:07:03Z",
        "lastEditedBy" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "tags" : [
        ]
      }
    ],
    "commit" : "c930223f08a9f9f104427ac4a4fe184ffe1450b4",
    "line" : 193,
    "diffHunk" : "@@ -1,1 +1891,1895 @@    ⟨ f₁ : τ₁, …, fₘ : τₘ ⟩ <ₜ τ σ\n\n    τ₁ <ₜ τ₂\n  ——————————————————————————————————————————————————— TypeOrderTyAppLeft\n    τ₁ σ₁ <ₜ τ₂ σ₂"
  },
  {
    "id" : "0e40eda5-03cf-4702-a483-b81d58bb61a4",
    "prId" : 4116,
    "prUrl" : "https://github.com/digital-asset/daml/pull/4116",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "cff32570-f88d-477b-95c0-3d4ec15e2402",
        "parentId" : null,
        "authorId" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "body" : "As for maps, given that we want to switch to ordered map, can we define the order of a map based on the order of the result of converting it to a list of key-value pairs (orderered by keys)?",
        "createdAt" : "2020-01-20T16:09:35Z",
        "updatedAt" : "2020-01-23T10:14:48Z",
        "lastEditedBy" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "tags" : [
        ]
      },
      {
        "id" : "d0cf00dc-e08d-4167-903e-acf55db11222",
        "parentId" : "cff32570-f88d-477b-95c0-3d4ec15e2402",
        "authorId" : null,
        "body" : "That sounds like the best option :)",
        "createdAt" : "2020-01-22T11:57:30Z",
        "updatedAt" : "2020-01-23T10:14:48Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "e3001d06-c108-465f-b6f2-49c09c6b2e37",
        "parentId" : "cff32570-f88d-477b-95c0-3d4ec15e2402",
        "authorId" : null,
        "body" : "I added rules for maps. I think cleaning up the spec to get rid of the dependency on insertion order in generic maps should happen in the next PR (if CI ever accepts this one).",
        "createdAt" : "2020-01-22T14:21:24Z",
        "updatedAt" : "2020-01-23T10:14:48Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "2181cbc0-2f93-4b78-9fcb-977d637f99be",
        "parentId" : "cff32570-f88d-477b-95c0-3d4ec15e2402",
        "authorId" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "body" : ":+1:",
        "createdAt" : "2020-01-23T10:21:53Z",
        "updatedAt" : "2020-01-23T10:21:53Z",
        "lastEditedBy" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "tags" : [
        ]
      }
    ],
    "commit" : "a17567d4d853f3eaa0100a84487c93323612db34",
    "line" : 168,
    "diffHunk" : "@@ -1,1 +2463,2467 @@behavior.\n\nGeneric equality and order functions\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  },
  {
    "id" : "f6f8bf43-a0ab-40ad-8fcd-17423475e468",
    "prId" : 4116,
    "prUrl" : "https://github.com/digital-asset/daml/pull/4116",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "812fd5e6-8bf1-4edc-bcbe-3adf98d796bb",
        "parentId" : null,
        "authorId" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "body" : "This is currently tricky to do in the engine as we do not have enough info at run time.\r\nI was thinking to go lexicographically, but this is definitively better. ",
        "createdAt" : "2020-01-20T16:10:25Z",
        "updatedAt" : "2020-01-23T10:14:48Z",
        "lastEditedBy" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "tags" : [
        ]
      },
      {
        "id" : "8bef8a2c-bdce-4075-9655-f28df8e1f259",
        "parentId" : "812fd5e6-8bf1-4edc-bcbe-3adf98d796bb",
        "authorId" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "body" : "I don’t think lexicographic ordering is a reasonable option. The default `Ord` instance in DAML works like the one that @associahedron has used in the spec here and diverging from that is going to cause a lot of confusion.",
        "createdAt" : "2020-01-20T16:13:49Z",
        "updatedAt" : "2020-01-23T10:14:48Z",
        "lastEditedBy" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "tags" : [
        ]
      },
      {
        "id" : "8480f8c3-e601-408f-b311-13003e500a2c",
        "parentId" : "812fd5e6-8bf1-4edc-bcbe-3adf98d796bb",
        "authorId" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "body" : "We probably add an index in the variant and the enum.",
        "createdAt" : "2020-01-20T16:19:51Z",
        "updatedAt" : "2020-01-23T10:14:48Z",
        "lastEditedBy" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "tags" : [
        ]
      }
    ],
    "commit" : "a17567d4d853f3eaa0100a84487c93323612db34",
    "line" : 96,
    "diffHunk" : "@@ -1,1 +1927,1931 @@\n   Mod:T:V₁ comes before Mod:T:V₂ in the list of\n   constructors for variant type Mod:T\n  ——————————————————————————————————————————————————— GenLtVariantCon1\n   Mod:T:V₁ @τ₁ … @τₙ v <ᵥ Mod:T:V₂ @σ₁ … @σₙ w"
  },
  {
    "id" : "02eeebbd-eca9-48bb-959a-b8f3441239f9",
    "prId" : 3817,
    "prUrl" : "https://github.com/digital-asset/daml/pull/3817",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "834493b4-6bca-4476-8676-1df871b2f76c",
        "parentId" : null,
        "authorId" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "body" : "I don’t think we ever discussed this and I still use this in DAML script and DAML triggers. Did you mean to change `EQUAL_CONTRACT_ID` instead of `COERCE_CONTRACT_ID`?",
        "createdAt" : "2019-12-11T12:25:09Z",
        "updatedAt" : "2019-12-11T12:30:12Z",
        "lastEditedBy" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "tags" : [
        ]
      },
      {
        "id" : "16cad523-d7ab-429f-ba78-3c5e6b1009f0",
        "parentId" : "834493b4-6bca-4476-8676-1df871b2f76c",
        "authorId" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "body" : "~~My mistake. Thanks to catch that~~\r\n",
        "createdAt" : "2019-12-11T12:31:27Z",
        "updatedAt" : "2019-12-11T12:42:13Z",
        "lastEditedBy" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "tags" : [
        ]
      },
      {
        "id" : "3e90535a-fa50-4579-89a2-9ea9cb72ca0d",
        "parentId" : "834493b4-6bca-4476-8676-1df871b2f76c",
        "authorId" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "body" : "The ``[*Available in version ...*]`` in the built-in section are always at the end of the description of the built. That is to say this annotation is about ``EQUAL_CONTRACT_ID`` not ``COERCE_CONTRACT_ID``",
        "createdAt" : "2019-12-11T12:43:50Z",
        "updatedAt" : "2019-12-11T12:44:06Z",
        "lastEditedBy" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "tags" : [
        ]
      },
      {
        "id" : "4f7e9800-b5c0-4985-9780-92c766496524",
        "parentId" : "834493b4-6bca-4476-8676-1df871b2f76c",
        "authorId" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "body" : "Oh I see, I got confused by the diff. LGTM  to me then :+1:",
        "createdAt" : "2019-12-11T12:44:52Z",
        "updatedAt" : "2019-12-11T12:44:52Z",
        "lastEditedBy" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "tags" : [
        ]
      }
    ],
    "commit" : "7211a4fb244cd3ddf7a3e698e6b86f78f4e02e2e",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +2712,2716 @@  ``'False'`` otherwise.\n\n  [*Available in versions < 1.dev*]\n\n* ``COERCE_CONTRACT_ID  : ∀ (α : ⋆) (β : ⋆) . 'ContractId' α → 'ContractId' β``"
  },
  {
    "id" : "94d28bb1-85e9-45d7-92ab-b3da8f9e1c1f",
    "prId" : 3782,
    "prUrl" : "https://github.com/digital-asset/daml/pull/3782",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "62863ecf-75a2-48a0-bc19-243d494aaa71",
        "parentId" : null,
        "authorId" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "body" : "Should this be `τ[α_1 -> σ_1, …] -> σ`? Does it make a difference?",
        "createdAt" : "2019-12-09T10:27:12Z",
        "updatedAt" : "2019-12-12T17:03:32Z",
        "lastEditedBy" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "tags" : [
        ]
      },
      {
        "id" : "73ecda86-9ce7-45ec-97fc-43ba1e877ba6",
        "parentId" : "62863ecf-75a2-48a0-bc19-243d494aaa71",
        "authorId" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "body" : "Does not make any difference. \r\nI prefer My notation, as it suggest we can resolve synonym in the body of definition independently of its usage. ",
        "createdAt" : "2019-12-09T12:21:41Z",
        "updatedAt" : "2019-12-12T17:03:32Z",
        "lastEditedBy" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "tags" : [
        ]
      },
      {
        "id" : "e21b65e0-2b8e-4e03-b101-7abe30fa6863",
        "parentId" : "62863ecf-75a2-48a0-bc19-243d494aaa71",
        "authorId" : null,
        "body" : "I don't think you can resolve the arguments and body independently. \r\n\r\nExample,\r\n\r\n```\r\nsynonym Foo t = t -> Int64\r\nsynonym Bar f = f Int64\r\n```\r\n\r\nThe rule above would give \r\n```\r\nBar Foo ↠ Foo Int64\r\n```\r\nBut the correct result (obtained from @cocreature's rule) is\r\n\r\n```\r\nBar Foo ↠ Int64 -> Int64 \r\n```\r\n",
        "createdAt" : "2019-12-10T11:18:48Z",
        "updatedAt" : "2019-12-12T17:03:32Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "b92b102b-ca63-4bf8-829c-2c977d508446",
        "parentId" : "62863ecf-75a2-48a0-bc19-243d494aaa71",
        "authorId" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "body" : "Nice example!",
        "createdAt" : "2019-12-10T12:08:55Z",
        "updatedAt" : "2019-12-12T17:03:32Z",
        "lastEditedBy" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "tags" : [
        ]
      },
      {
        "id" : "9d36aba7-481d-4301-b342-cd17671b847f",
        "parentId" : "62863ecf-75a2-48a0-bc19-243d494aaa71",
        "authorId" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "body" : "We agree with @cocreature that type synonyms are always fully applied. It is not in the ``Bar Foo`` .\r\n\r\n",
        "createdAt" : "2019-12-10T12:35:24Z",
        "updatedAt" : "2019-12-12T17:03:32Z",
        "lastEditedBy" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "tags" : [
        ]
      },
      {
        "id" : "df81c1f1-c60f-49f2-8b57-ed7f4a52f6b4",
        "parentId" : "62863ecf-75a2-48a0-bc19-243d494aaa71",
        "authorId" : null,
        "body" : "Always applied type synonyms should be enough for now, but I don't see a good reason to leave this rule susceptible to the above problems if, in future, we don't guarantee type synonyms are fully applied.\r\n\r\n(Also, is it in the spec that type synonyms must be fully applied?)",
        "createdAt" : "2019-12-10T12:41:55Z",
        "updatedAt" : "2019-12-12T17:03:32Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "148e9cc3-ad68-40fb-987b-f5415fa865ef",
        "parentId" : "62863ecf-75a2-48a0-bc19-243d494aaa71",
        "authorId" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "body" : "It should be in the spec but I might have screwed it up :slightly_smiling_face:",
        "createdAt" : "2019-12-10T12:43:05Z",
        "updatedAt" : "2019-12-12T17:03:32Z",
        "lastEditedBy" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "tags" : [
        ]
      },
      {
        "id" : "fd949b47-d353-4be6-8e12-5b3defc49c50",
        "parentId" : "62863ecf-75a2-48a0-bc19-243d494aaa71",
        "authorId" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "body" : "The rewriting approach does not really work if type synonym are not fully applied. \r\nThe crux of my spec is that once you applied ``↠`` there is no more type synonym (or if there is still some is that you use an undefined type synonym (or partially applied) in which case the type is not well-formed)\r\n   ",
        "createdAt" : "2019-12-10T12:47:40Z",
        "updatedAt" : "2019-12-12T17:03:32Z",
        "lastEditedBy" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "tags" : [
        ]
      },
      {
        "id" : "581e0f97-3e4a-4ed6-97c1-0a2eaf3e526b",
        "parentId" : "62863ecf-75a2-48a0-bc19-243d494aaa71",
        "authorId" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "body" : "in other terms, `Foo Int64 : *` does not kind check.",
        "createdAt" : "2019-12-10T12:48:48Z",
        "updatedAt" : "2019-12-12T17:03:32Z",
        "lastEditedBy" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "tags" : [
        ]
      },
      {
        "id" : "d4c7b398-4d9d-4c0e-aa65-878098cee135",
        "parentId" : "62863ecf-75a2-48a0-bc19-243d494aaa71",
        "authorId" : null,
        "body" : "I think if we're going down this route we should not be reusing `TApp` in defining type synonyms -- a type synonym application should be considered a separate primitive type operation.",
        "createdAt" : "2019-12-10T12:53:45Z",
        "updatedAt" : "2019-12-12T17:03:32Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "f89b6990-218e-4203-8005-97b0e273a7eb",
        "parentId" : "62863ecf-75a2-48a0-bc19-243d494aaa71",
        "authorId" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "body" : "OK. ",
        "createdAt" : "2019-12-10T12:55:06Z",
        "updatedAt" : "2019-12-12T17:03:32Z",
        "lastEditedBy" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "tags" : [
        ]
      }
    ],
    "commit" : "92ac13a29a297aa565d84f8bc700222e7b467019",
    "line" : 54,
    "diffHunk" : "@@ -1,1 +800,804 @@\n   'synonym' S (α₁:k₁) … (αₙ:kₙ) ↦ τ  ∈ 〚Ξ〛Mod\n   τ  ↠  σ      τ₁  ↠  σ₁  ⋯  τₙ  ↠  σₙ\n  ——————————————————————————————————————————————— RewriteSynonym\n   |Mod:S τ₁ … τₙ|   ↠   σ[α₁ ↦ σ₁, …, αₙ ↦ σₙ]"
  },
  {
    "id" : "e51339aa-a227-4ed8-9146-2bd751355537",
    "prId" : 3782,
    "prUrl" : "https://github.com/digital-asset/daml/pull/3782",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "afb408ec-fedd-4092-b0d4-97787064d558",
        "parentId" : null,
        "authorId" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "body" : "```suggestion\r\n  ———————————————————————————————————————————————— RewriteStruct\r\n```",
        "createdAt" : "2019-12-09T10:28:24Z",
        "updatedAt" : "2019-12-12T17:03:32Z",
        "lastEditedBy" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "tags" : [
        ]
      }
    ],
    "commit" : "92ac13a29a297aa565d84f8bc700222e7b467019",
    "line" : 59,
    "diffHunk" : "@@ -1,1 +805,809 @@\n   τ₁ ↠ σ₁  ⋯  τₙ  ↠  σₙ\n  ———————————————————————————————————————————————— RewriteText\n   ⟨ f₁: τ₁, …, fₘ: τₘ ⟩ ↠ ⟨ f₁: σ₁, …, fₘ: σₘ ⟩\n"
  },
  {
    "id" : "5f341a06-d459-4d19-85b6-84b375b66759",
    "prId" : 3782,
    "prUrl" : "https://github.com/digital-asset/daml/pull/3782",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "96d695f3-f854-4db4-99d9-6c7f57ecb5c9",
        "parentId" : null,
        "authorId" : null,
        "body" : "I think you need to split it out into two cases, in case `σ₁` happens to be a partially applied synonym.\r\n\r\n```\r\n τ₁  ↠  σ₁        τ₂  ↠  σ₂\r\nσ₁ σ₂ is not a fully saturated type synonym application\r\n———————————————————————————————————————————————— RewriteApp1\r\n    τ₁ τ₂  ↠  σ₁ σ₂\r\n\r\n\r\n τ₁  ↠  σ₁        τ₂  ↠  σ₂\r\nσ₁ σ₂ is a fully saturated type synonym application\r\nσ₁ σ₂ ↠ σ \r\n———————————————————————————————————————————————— RewriteApp2\r\n    τ₁ τ₂  ↠  σ\r\n```\r\n",
        "createdAt" : "2019-12-10T11:29:42Z",
        "updatedAt" : "2019-12-12T17:03:32Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "fe6324f7-ea9f-41a3-bba4-19345cb60cf1",
        "parentId" : "96d695f3-f854-4db4-99d9-6c7f57ecb5c9",
        "authorId" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "body" : "Won’t we already all in the `RewriteSynonym` case for `RewriteApp2` here?",
        "createdAt" : "2019-12-10T12:14:39Z",
        "updatedAt" : "2019-12-12T17:03:32Z",
        "lastEditedBy" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "tags" : [
        ]
      },
      {
        "id" : "e45fa649-7daf-4d88-8a2c-b94a191c2c4e",
        "parentId" : "96d695f3-f854-4db4-99d9-6c7f57ecb5c9",
        "authorId" : null,
        "body" : "Not if `σ₁` is a partially applied type synonym. Of course, that can't happen if type synonyms must be fully applied in every case.\r\n\r\nConcrete example:\r\n\r\n```\r\nsynonym Foo a b = a -> b \r\nsynonym Bar = Foo Int64\r\n```\r\n\r\nthen `Bar Int64 ` doesn't fall into either `RewriteSynonym` or `RewriteApp1`, you would need `RewriteApp2` to make progress with `Bar ↠ Foo Int64` before getting `Bar Int64 ↠ Int64 -> Int64`.",
        "createdAt" : "2019-12-10T12:49:49Z",
        "updatedAt" : "2019-12-12T17:03:32Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "92ac13a29a297aa565d84f8bc700222e7b467019",
    "line" : 64,
    "diffHunk" : "@@ -1,1 +810,814 @@   τ₁  ↠  σ₁        τ₂  ↠  σ₂\n  ———————————————————————————————————————————————— RewriteApp\n   τ₁ τ₂  ↠  σ₁ σ₂\n\n   τ  ↠  σ"
  },
  {
    "id" : "b1b6ccb7-ca7a-4cf1-819a-6d71074443bc",
    "prId" : 3782,
    "prUrl" : "https://github.com/digital-asset/daml/pull/3782",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "dd965b82-19d5-4a9f-9d27-238e40c01b89",
        "parentId" : null,
        "authorId" : null,
        "body" : "Why not?\r\n\r\n```suggestion\r\n      τ ↠ τ'      ε  ⊢  τ' : *     τ' contains no quantifiers nor type synonyms\r\n```",
        "createdAt" : "2019-12-10T11:37:18Z",
        "updatedAt" : "2019-12-12T17:03:32Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "92ac13a29a297aa565d84f8bc700222e7b467019",
    "line" : 200,
    "diffHunk" : "@@ -1,1 +1012,1016 @@      Γ  ⊢  'from_any' @τ e  :  'Optional' τ\n\n      ε  ⊢  τ : *     τ contains no quantifiers nor type synonyms\n    ——————————————————————————————————————————————————————————————— ExpTypeRep\n      Γ  ⊢  'type_rep' @τ  :  'TypeRep'"
  },
  {
    "id" : "cdffe3d9-645b-4413-bdf3-f737984aacfc",
    "prId" : 3782,
    "prUrl" : "https://github.com/digital-asset/daml/pull/3782",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6ea6e0d5-d3de-4053-a31f-cc218d429c37",
        "parentId" : null,
        "authorId" : null,
        "body" : "Why not?\r\n\r\n```suggestion\r\n      τ' contains no quantifiers nor type synonyms\r\n      τ ↠ τ'       ε  ⊢  τ' : *     Γ  ⊢  e  : Any\r\n```",
        "createdAt" : "2019-12-10T11:39:24Z",
        "updatedAt" : "2019-12-12T17:03:32Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "f6cf3167-f974-4e07-a840-fbf54eef532f",
        "parentId" : "6ea6e0d5-d3de-4053-a31f-cc218d429c37",
        "authorId" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "body" : "It’s a bit annoying to implement since you would need to expand it in the speedy compiler so given that we don’t need it, it seems reasonable to simply forbid it at least for now.",
        "createdAt" : "2019-12-10T11:52:46Z",
        "updatedAt" : "2019-12-12T17:03:32Z",
        "lastEditedBy" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "tags" : [
        ]
      },
      {
        "id" : "4a04e937-164e-4779-b727-f5fa3b3fc3da",
        "parentId" : "6ea6e0d5-d3de-4053-a31f-cc218d429c37",
        "authorId" : null,
        "body" : "I see, that seems reasonable. The idea is that any user-defined type synonyms DAML will be expanded already in DAML-LF, and any type synonym in DAML-LF will be from constraints/typeclasses in DAML, which we don't care to marshal in or out of `Any`.",
        "createdAt" : "2019-12-10T11:59:57Z",
        "updatedAt" : "2019-12-12T17:03:32Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "92ac13a29a297aa565d84f8bc700222e7b467019",
    "line" : 195,
    "diffHunk" : "@@ -1,1 +1008,1012 @@\n      τ contains no quantifiers nor type synonyms\n      ε  ⊢  τ : *     Γ  ⊢  e  : Any\n    ——————————————————————————————————————————————————————————————— ExpFromAny\n      Γ  ⊢  'from_any' @τ e  :  'Optional' τ"
  },
  {
    "id" : "c00d1cc8-73a8-4d13-b212-80d7bda3162a",
    "prId" : 3782,
    "prUrl" : "https://github.com/digital-asset/daml/pull/3782",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "55a8feba-5f20-4f8c-a3a1-0acd189555d2",
        "parentId" : null,
        "authorId" : null,
        "body" : "Similarly to `from_any` and `type_rep`, why not allow `τ ↠ τ'` and place the \"no quantifiers nor type synonym\" requirements on `τ'` instead.",
        "createdAt" : "2019-12-10T11:41:30Z",
        "updatedAt" : "2019-12-12T17:03:32Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "92ac13a29a297aa565d84f8bc700222e7b467019",
    "line" : 189,
    "diffHunk" : "@@ -1,1 +1003,1007 @@\n      τ contains no quantifiers nor type synonyms\n      ε  ⊢  τ : *     Γ  ⊢  e  : τ\n    ——————————————————————————————————————————————————————————————— ExpToAny\n      Γ  ⊢  'to_any' @τ e  :  'Any'"
  },
  {
    "id" : "e0f193f7-8b83-48af-81b2-e401a3118486",
    "prId" : 3740,
    "prUrl" : "https://github.com/digital-asset/daml/pull/3740",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d6b60ebc-6010-4737-98de-e2d727a9caab",
        "parentId" : null,
        "authorId" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "body" : "Why did this change? I don’t understand why text literals here are different from other literals.",
        "createdAt" : "2019-12-05T10:27:46Z",
        "updatedAt" : "2019-12-05T15:24:49Z",
        "lastEditedBy" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "tags" : [
        ]
      },
      {
        "id" : "56f44b90-5c5f-4a5c-bbdb-a3365a818274",
        "parentId" : "d6b60ebc-6010-4737-98de-e2d727a9caab",
        "authorId" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "body" : "See below.",
        "createdAt" : "2019-12-05T12:20:24Z",
        "updatedAt" : "2019-12-05T15:24:49Z",
        "lastEditedBy" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "tags" : [
        ]
      }
    ],
    "commit" : "9ae3afd6c9f06a2dbdbec412feeb5518d703dd1f",
    "line" : 65,
    "diffHunk" : "@@ -1,1 +596,600 @@       |  LitInt64                                  -- ExpLitInt64: 64-bit integer literal\n       |  LitNumeric                                -- ExpLitNumeric: Numeric literal\n       |  t                                         -- ExpLitText: UTF-8 string literal\n       |  LitDate                                   -- ExpLitDate: Date literal\n       |  LitTimestamp                              -- ExpLitTimestamp: UTC timestamp literal"
  },
  {
    "id" : "f7346336-8c5a-48ca-97a3-98851039a23d",
    "prId" : 3740,
    "prUrl" : "https://github.com/digital-asset/daml/pull/3740",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "41c0fc30-bf9a-48e2-aad6-140635557e5a",
        "parentId" : null,
        "authorId" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "body" : "I guess this is why we switched from `TextLit` to `t`?",
        "createdAt" : "2019-12-05T10:32:29Z",
        "updatedAt" : "2019-12-05T15:24:49Z",
        "lastEditedBy" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "tags" : [
        ]
      },
      {
        "id" : "7cec44c7-0470-4fe4-9d14-5f8c09d159eb",
        "parentId" : "41c0fc30-bf9a-48e2-aad6-140635557e5a",
        "authorId" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "body" : "Indeed.",
        "createdAt" : "2019-12-05T11:00:05Z",
        "updatedAt" : "2019-12-05T15:24:49Z",
        "lastEditedBy" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "tags" : [
        ]
      }
    ],
    "commit" : "9ae3afd6c9f06a2dbdbec412feeb5518d703dd1f",
    "line" : 164,
    "diffHunk" : "@@ -1,1 +1553,1557 @@     ⊢ᵥ  e₁    ⋯    ⊢ᵥ eₙ\n   ——————————————————————————————————————————————————— ValExpTextMap\n     ⊢ᵥ  [t₁ ↦ e₁; ⋯ ; tₙ ↦ eₙ]\n\n     ⊢ᵥ  e₁    ⋯    ⊢ᵥ eₙ"
  },
  {
    "id" : "5e8e2d31-698a-423f-9e2e-6cde00be2ade",
    "prId" : 3740,
    "prUrl" : "https://github.com/digital-asset/daml/pull/3740",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bd895a3b-def0-48e6-86e2-4c28c134a6bc",
        "parentId" : null,
        "authorId" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "body" : "Shouldn’t we also allow for `t1` and `t1'`? You can argue that it doesn’t matter since a text literal is only equal to itself but if you follow that argument the rule for text literals should probably also be\r\n```\r\n--------------- GenEqLitText\r\nt ~_v t\r\n```\r\ninstead of what you have right now.",
        "createdAt" : "2019-12-05T10:41:44Z",
        "updatedAt" : "2019-12-05T15:24:49Z",
        "lastEditedBy" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "tags" : [
        ]
      },
      {
        "id" : "e379d3b8-f1d3-43d8-b59c-9bf6fc8ac805",
        "parentId" : "bd895a3b-def0-48e6-86e2-4c28c134a6bc",
        "authorId" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "body" : "You are right. I change the `GenEq` rules",
        "createdAt" : "2019-12-05T12:23:35Z",
        "updatedAt" : "2019-12-05T15:24:49Z",
        "lastEditedBy" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "tags" : [
        ]
      }
    ],
    "commit" : "9ae3afd6c9f06a2dbdbec412feeb5518d703dd1f",
    "line" : 261,
    "diffHunk" : "@@ -1,1 +1767,1771 @@\n\n    v₁ ~ᵥ w₁     …       vₙ ~ᵥ wₙ\n  ——————————————————————————————————————————————————— GenEqTextMap\n   [ t₁ ↦ v₁, …, tₘ ↦ vₘ ]"
  },
  {
    "id" : "ea20871e-36c7-479f-ac4c-fff69be0dbc8",
    "prId" : 3740,
    "prUrl" : "https://github.com/digital-asset/daml/pull/3740",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "86f0e71f-710b-4d4e-8b03-0ae5835f752a",
        "parentId" : null,
        "authorId" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "body" : "This isn’t true is it? We only added this in 1.5 or 1.6 iirc",
        "createdAt" : "2019-12-05T10:45:15Z",
        "updatedAt" : "2019-12-05T15:24:49Z",
        "lastEditedBy" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "tags" : [
        ]
      },
      {
        "id" : "edb930be-2d39-46be-9242-d0a0a0546736",
        "parentId" : "86f0e71f-710b-4d4e-8b03-0ae5835f752a",
        "authorId" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "body" : "I seems it was there from the beginning. At least it is there since the open sourcing. \r\nalso in the proto it is mapped to 87 which is lower that `EQUAL_LIST` and `TRACE`.",
        "createdAt" : "2019-12-05T11:51:30Z",
        "updatedAt" : "2019-12-05T15:24:49Z",
        "lastEditedBy" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "tags" : [
        ]
      }
    ],
    "commit" : "9ae3afd6c9f06a2dbdbec412feeb5518d703dd1f",
    "line" : 383,
    "diffHunk" : "@@ -1,1 +2703,2707 @@  ``'False'`` otherwise.\n\n  [*Available in version < 1.dev*]\n\n* ``COERCE_CONTRACT_ID  : ∀ (α : ⋆) (β : ⋆) . 'ContractId' α → 'ContractId' β``"
  },
  {
    "id" : "b330c725-a2d9-4f36-a5a4-3fbf09e423e2",
    "prId" : 3660,
    "prUrl" : "https://github.com/digital-asset/daml/pull/3660",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "41e1f572-7842-49b5-b2fd-d1ff66114456",
        "parentId" : null,
        "authorId" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "body" : "We should explain somewhere that \"record\" means nominal record and \"struct\" means structural records.",
        "createdAt" : "2019-11-28T08:40:20Z",
        "updatedAt" : "2019-11-28T09:11:53Z",
        "lastEditedBy" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "tags" : [
        ]
      },
      {
        "id" : "0a99c3d1-13a2-4208-88ac-c47e7ea0be87",
        "parentId" : "41e1f572-7842-49b5-b2fd-d1ff66114456",
        "authorId" : "43409235-97e4-48dc-9ec7-403ee0a7de54",
        "body" : "done",
        "createdAt" : "2019-11-28T09:06:31Z",
        "updatedAt" : "2019-11-28T09:11:53Z",
        "lastEditedBy" : "43409235-97e4-48dc-9ec7-403ee0a7de54",
        "tags" : [
        ]
      }
    ],
    "commit" : "bd5134affa807d790e2d801c4393bb4684926d63",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +478,482 @@\nIn the following, we will use identifiers to represent *built-in\nfunctions*, term and type *variable names*, record and struct *field\nnames*, *variant constructors* and *template choices*. On the other\nhand, we will use names to represent *type constructors*, *type synonyms*, *value"
  },
  {
    "id" : "7b5d56db-c6e7-409a-a0d5-ecc1eec34f80",
    "prId" : 3635,
    "prUrl" : "https://github.com/digital-asset/daml/pull/3635",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "050acfd5-23ea-4e70-8217-28574ffe02a2",
        "parentId" : null,
        "authorId" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "body" : "```suggestion\r\n      Γ  ⊢  Mod:S τ₁ … τₙ  :  ⋆\r\n```",
        "createdAt" : "2019-11-26T14:29:25Z",
        "updatedAt" : "2019-11-26T14:40:24Z",
        "lastEditedBy" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "tags" : [
        ]
      },
      {
        "id" : "fc8e39b3-3776-4525-9472-45cffbe3aa3b",
        "parentId" : "050acfd5-23ea-4e70-8217-28574ffe02a2",
        "authorId" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "body" : "Apparently it was not fixed. ",
        "createdAt" : "2019-11-26T15:05:07Z",
        "updatedAt" : "2019-11-26T15:05:08Z",
        "lastEditedBy" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "tags" : [
        ]
      }
    ],
    "commit" : "dfc3adf4d1e94695c10c9e19497754dae883b65c",
    "line" : 45,
    "diffHunk" : "@@ -1,1 +856,860 @@      Γ  ⊢  τ₁ : k₁  …  Γ  ⊢  τₙ : kₙ\n    ————————————————————————————————————————————— TyTypeSynonym\n      Γ  ⊢  S τ₁ … τₙ  :  ⋆\n\n"
  },
  {
    "id" : "f4c0f2d5-9adc-4f3e-a2fe-87731548c2ac",
    "prId" : 3340,
    "prUrl" : "https://github.com/digital-asset/daml/pull/3340",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "33fab788-da25-4191-bd5d-05741b6865f3",
        "parentId" : null,
        "authorId" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "body" : "When did we decide to do this? I'm not convinced requiring the submitter of a `fetchByKey` to be a maintainer of the key is a good idea. This definitely hurts the compositionality of workflows. I also don't see the technical necessity of this change. Being a stakeholder of the contract should absolutely be enough. If you know a contract with the right key exists, then it must be the unique contract with this key. If you don't see a contract with such a key, you can't submit the transaction anyway. (I'm not talking about `lookupByKey` here!)\r\n\r\ncc @bame-da @gerolf-da ",
        "createdAt" : "2019-11-05T19:18:12Z",
        "updatedAt" : "2019-11-07T08:46:06Z",
        "lastEditedBy" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "tags" : [
        ]
      },
      {
        "id" : "458c66a8-c1b0-4b76-b81a-ebae52fc3286",
        "parentId" : "33fab788-da25-4191-bd5d-05741b6865f3",
        "authorId" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "body" : "In fact, this restriction is pretty much against the spirit of https://github.com/digital-asset/daml/issues/2311, which we all seem to have agreed on.",
        "createdAt" : "2019-11-05T19:24:46Z",
        "updatedAt" : "2019-11-07T08:46:06Z",
        "lastEditedBy" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "tags" : [
        ]
      },
      {
        "id" : "629ccd0c-30ab-45ab-b8ad-9039f3f9caa7",
        "parentId" : "33fab788-da25-4191-bd5d-05741b6865f3",
        "authorId" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "body" : "This is not recent. This was done by francesco. See #1866 already referenced in #2311. \r\n",
        "createdAt" : "2019-11-05T20:22:51Z",
        "updatedAt" : "2019-11-07T08:46:06Z",
        "lastEditedBy" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "tags" : [
        ]
      },
      {
        "id" : "4849bb1a-fb9a-4e5e-a835-56c6bf0125d0",
        "parentId" : "33fab788-da25-4191-bd5d-05741b6865f3",
        "authorId" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "body" : "I just moved the comment from line 227/232 to line 246/252",
        "createdAt" : "2019-11-05T20:24:36Z",
        "updatedAt" : "2019-11-07T08:46:06Z",
        "lastEditedBy" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "tags" : [
        ]
      }
    ],
    "commit" : "f0b37d7d468279b3d9d07dd3ddc2a48b8c618884",
    "line" : 49,
    "diffHunk" : "@@ -1,1 +260,264 @@..............\n\n  * **Change** Transaction submitter must be in the contract key\n    maintainers when performing lookup or fetches by key. See\n    `issue #1866 <https://github.com/digital-asset/daml/issues/1866>`_"
  },
  {
    "id" : "2a20f9b2-5e95-4a66-bacd-99e0ea5d3ae1",
    "prId" : 3296,
    "prUrl" : "https://github.com/digital-asset/daml/pull/3296",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2855f518-e1da-42d2-b4ff-5889ba03299a",
        "parentId" : null,
        "authorId" : "eb431011-3221-41ae-bf30-e72dde278004",
        "body" : "```suggestion\r\nthat does not comply with this restriction.\r\n```",
        "createdAt" : "2019-11-01T13:00:00Z",
        "updatedAt" : "2019-11-01T16:19:25Z",
        "lastEditedBy" : "eb431011-3221-41ae-bf30-e72dde278004",
        "tags" : [
        ]
      },
      {
        "id" : "f6860f16-3ee6-45a7-892e-ccd8db2ac9c1",
        "parentId" : "2855f518-e1da-42d2-b4ff-5889ba03299a",
        "authorId" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "body" : "fixed\r\n",
        "createdAt" : "2019-11-01T13:37:00Z",
        "updatedAt" : "2019-11-01T16:19:25Z",
        "lastEditedBy" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "tags" : [
        ]
      }
    ],
    "commit" : "e4b307bce38672100ce0d80a27efe67f1499f824",
    "line" : 125,
    "diffHunk" : "@@ -1,1 +2962,2966 @@[*Available in versions >= 1.dev*] must be used instead. The\ndeserialization process will reject any DAML-LF 1.dev (or later) that\nthat does not comply this restriction.\n\nNat kind and Nat types"
  },
  {
    "id" : "c8afdf1a-01b6-48dd-8493-f68cf2453b3c",
    "prId" : 3260,
    "prUrl" : "https://github.com/digital-asset/daml/pull/3260",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "01de422e-c310-4e7e-9eae-b7691c1e34d8",
        "parentId" : null,
        "authorId" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "body" : "Currently you are switching between `builtin` and `built-in`, it would probably be good to stick to one of those.",
        "createdAt" : "2019-10-28T17:08:05Z",
        "updatedAt" : "2019-11-11T14:57:16Z",
        "lastEditedBy" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "tags" : [
        ]
      }
    ],
    "commit" : "b9156096baacc799653b528944997e1f63b50031",
    "line" : 158,
    "diffHunk" : "@@ -1,1 +2671,2675 @@relation over valid keys.\n\nThis relation is not exposed as a builtin function, but it coincides\nwith the builtin equality for any given type, if that builtin is\ndefined. ::"
  },
  {
    "id" : "04361364-2b98-4a3c-bd58-53227ea67399",
    "prId" : 3260,
    "prUrl" : "https://github.com/digital-asset/daml/pull/3260",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f7196629-060c-4db0-a937-05185df7c022",
        "parentId" : null,
        "authorId" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "body" : "Do we want to allow contract ids? The absolute vs relative thing makes that a bit dangerous so at least on the DAML level I probably wouldn’t expose it.",
        "createdAt" : "2019-10-28T17:10:14Z",
        "updatedAt" : "2019-11-11T14:57:16Z",
        "lastEditedBy" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "tags" : [
        ]
      },
      {
        "id" : "8c68c659-eb40-456e-938a-4d0a61637bf3",
        "parentId" : "f7196629-060c-4db0-a937-05185df7c022",
        "authorId" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "body" : "Contract IDs are fine here as long as we stick to the following two assumptions:\r\n(1) the rewriting from relative to absolute IDs is injective and no relative ID is ever rewritten to an absolute ID that is in use already,\r\n(2) the rewriting of all contract IDs in a transaction happens in one go without any map operations performed in the middle.\r\nI wonder if we should document these assumptions (in better words than mine)?",
        "createdAt" : "2019-10-28T17:34:29Z",
        "updatedAt" : "2019-11-11T14:57:16Z",
        "lastEditedBy" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "tags" : [
        ]
      },
      {
        "id" : "fadb1ed2-66e2-4530-b30e-1498583467c6",
        "parentId" : "f7196629-060c-4db0-a937-05185df7c022",
        "authorId" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "body" : "Oh I see, I think I didn’t realize how the rewriting works until now. Makes sense now but yeah we should definitely document this imho.",
        "createdAt" : "2019-10-28T17:43:52Z",
        "updatedAt" : "2019-11-11T14:57:16Z",
        "lastEditedBy" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "tags" : [
        ]
      }
    ],
    "commit" : "b9156096baacc799653b528944997e1f63b50031",
    "line" : 186,
    "diffHunk" : "@@ -1,1 +2699,2703 @@  LitTimestamp₁ ~ᵥ LitTimestamp₂\n\n  cid₁ and cid₂ are the same\n  ——————————————————————————————————————————————————— GenEqLitContractId\n  cid₁ ~ᵥ cid₂"
  },
  {
    "id" : "10c95f05-cd4e-4baa-85f6-6b5330cdd3ec",
    "prId" : 3260,
    "prUrl" : "https://github.com/digital-asset/daml/pull/3260",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9012a129-91a4-4bf7-bd5f-fbc0c4d4b71b",
        "parentId" : null,
        "authorId" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "body" : "We should specify how this affects the \"order in which keys were inserted\" which is relevant for the conversion to lists, do we first-inserted-order or last-inserted-order? If we go with the former, the latter can be _efficiently_ expressed in terms of the former (and `GENMAP_DELETE`). I don't see how this would be possible _efficiently_ the other way around.",
        "createdAt" : "2019-10-28T17:17:27Z",
        "updatedAt" : "2019-11-11T14:57:16Z",
        "lastEditedBy" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "tags" : [
        ]
      },
      {
        "id" : "91d29ee2-85ce-466a-b67a-0f7704760a83",
        "parentId" : "9012a129-91a4-4bf7-bd5f-fbc0c4d4b71b",
        "authorId" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "body" : "I am inclined toward  `last-inserted-order`. ",
        "createdAt" : "2019-10-29T12:58:42Z",
        "updatedAt" : "2019-11-11T14:57:16Z",
        "lastEditedBy" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "tags" : [
        ]
      },
      {
        "id" : "ee1eb3f0-1afc-4ff2-9611-bcabfdf3e63c",
        "parentId" : "9012a129-91a4-4bf7-bd5f-fbc0c4d4b71b",
        "authorId" : null,
        "body" : "I think first inserted order makes more sense. It's certainly what I meant in the spec. It implies that if you insert the same (key, value) pair in a map that is already there, it will not modify the map, i.e. inserts are idempotent. That's nice.",
        "createdAt" : "2019-10-29T14:03:06Z",
        "updatedAt" : "2019-11-11T14:57:16Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "39062496-bbff-4ce6-84ea-867f92260ce7",
        "parentId" : "9012a129-91a4-4bf7-bd5f-fbc0c4d4b71b",
        "authorId" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "body" : "I don't know what you mean _exactly_ by \"inserts are idempotent\". I assume you mean\r\n```\r\ninsert k v . insert k v  ==  insert k v\r\n```\r\nfor all `k` and `v`. This is true for last-inserted order as well. I think what is more compelling about first-inserted order is that we get\r\n```\r\ninsert k (lookup k m) m  ==  m\r\n```\r\nfor all `m` and keys `k` of `m`.\r\n\r\nWe can also define\r\n```\r\ninsertLast k v = insertFirst k v . delete k\r\n```\r\nThus, insert-first order is at least as \"powerful\" as insert-last order.",
        "createdAt" : "2019-10-29T14:13:24Z",
        "updatedAt" : "2019-11-11T14:57:16Z",
        "lastEditedBy" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "tags" : [
        ]
      },
      {
        "id" : "3a3c0b1d-24d7-4b9d-a6aa-fe7706d1e312",
        "parentId" : "9012a129-91a4-4bf7-bd5f-fbc0c4d4b71b",
        "authorId" : null,
        "body" : "Ah, you're right. My sentence was better before the `i.e.`.",
        "createdAt" : "2019-10-29T14:20:01Z",
        "updatedAt" : "2019-11-11T14:57:16Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "b9156096baacc799653b528944997e1f63b50031",
    "line" : 92,
    "diffHunk" : "@@ -1,1 +2605,2609 @@  Inserts a new key and value in the map. If the key is already\n  present in the map, the associated value is replaced with the\n  supplied value.\n\n  This raises an error if the key is not a valid map key. Keys are"
  },
  {
    "id" : "38a8acec-94c5-47f3-8cc3-8d0eb7eae993",
    "prId" : 3260,
    "prUrl" : "https://github.com/digital-asset/daml/pull/3260",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9251aa94-031e-45f1-9128-fc407502e77a",
        "parentId" : null,
        "authorId" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "body" : "You are forgetting the \"nice\" case where keys are maps. \r\nOf course we can a first implementation without map keys. \r\n",
        "createdAt" : "2019-10-29T13:01:48Z",
        "updatedAt" : "2019-11-11T14:57:16Z",
        "lastEditedBy" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "tags" : [
        ]
      },
      {
        "id" : "a1362326-0503-4c06-bb28-4a6ab0d608c7",
        "parentId" : "9251aa94-031e-45f1-9128-fc407502e77a",
        "authorId" : null,
        "body" : "That's not nice! We probably will need to add them, but I'm worried the \"insertion order\" issue will mess people up.\r\n\r\nBut also I don't see map values under the values section (including `'Map'`). Probably should add them?",
        "createdAt" : "2019-11-01T16:35:00Z",
        "updatedAt" : "2019-11-11T14:57:16Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "a293c6c1-0e66-49cb-a03a-d2b0d92e3c45",
        "parentId" : "9251aa94-031e-45f1-9128-fc407502e77a",
        "authorId" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "body" : "We can postpone this problem for later. ",
        "createdAt" : "2019-11-04T10:41:44Z",
        "updatedAt" : "2019-11-11T14:57:16Z",
        "lastEditedBy" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "tags" : [
        ]
      },
      {
        "id" : "add2c69a-c85c-484b-809c-0ef3ac6da52e",
        "parentId" : "9251aa94-031e-45f1-9128-fc407502e77a",
        "authorId" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "body" : "TextMap (simply called 'Map' in the spec) are not concern with the insertion order.\r\nThey are sorted by key when converted to list or serialized in the ledger. ",
        "createdAt" : "2019-11-04T12:23:53Z",
        "updatedAt" : "2019-11-11T14:57:16Z",
        "lastEditedBy" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "tags" : [
        ]
      },
      {
        "id" : "dcd310ff-4d75-46de-8ae4-bb9940fe5c82",
        "parentId" : "9251aa94-031e-45f1-9128-fc407502e77a",
        "authorId" : null,
        "body" : "Right. I propose that two `'Map'` (i.e. TextMap) are considered equal if they have the same key-value pairs, and two `'GenMap'` are considered equal if they have the same key-value pairs *in the same insertion order*, so they result in the same output when using `GENMAP_KEYS` and `GENMAP_VALUES`.",
        "createdAt" : "2019-11-04T12:36:50Z",
        "updatedAt" : "2019-11-11T14:57:16Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "43f6e976-acb7-455c-baaa-0837e83063eb",
        "parentId" : "9251aa94-031e-45f1-9128-fc407502e77a",
        "authorId" : null,
        "body" : "(We could make the insertion order irrelevant for map key comparison, but then two \"equal keys\" could result in different outputs when passed through `GENMAP_KEYS`. Furthermore, the equality instance `(Eq a, Eq b) => Eq (GenMap a b)` that will be defined in DAML, in terms of `GENMAP_KEYS` and `GENMAP_VALUES`, is sensitive to insertion order, so it makes sense to make key comparison sensitive to that as well.)",
        "createdAt" : "2019-11-04T12:40:14Z",
        "updatedAt" : "2019-11-11T14:57:16Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "1d0c2be0-3b60-4101-b20f-4ddb957ca614",
        "parentId" : "9251aa94-031e-45f1-9128-fc407502e77a",
        "authorId" : null,
        "body" : "Following discussion with @bame-da, we decided that equality for GenMaps should not consider insertion order.",
        "createdAt" : "2019-11-04T13:46:18Z",
        "updatedAt" : "2019-11-11T14:57:16Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "7ce32e3a-ff2c-4eea-b2f4-4a2f3e0ad266",
        "parentId" : "9251aa94-031e-45f1-9128-fc407502e77a",
        "authorId" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "body" : "Are we planning to add a builtin `GENMAP_EQ : forall k v. (v -> v -> Bool) -> GenMap k v -> GenMap k v -> Bool`? (I assume we need to use the builtin equality for keys to make this work. I'm slowly starting to despise user-defined equality...)",
        "createdAt" : "2019-11-04T15:21:30Z",
        "updatedAt" : "2019-11-11T14:57:16Z",
        "lastEditedBy" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "tags" : [
        ]
      },
      {
        "id" : "be1acb45-3b14-47fb-b640-58a8f3b1b13e",
        "parentId" : "9251aa94-031e-45f1-9128-fc407502e77a",
        "authorId" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "body" : "We were not planning to add this function as it was not here for `TextMap`. \r\n\r\nBut I am planning to add a generic equality `EQUAL: forall v. v -> v -> Bool` using the builin equality. This will obviously work with `GenMap`. Is it not enough ?  ",
        "createdAt" : "2019-11-04T15:27:42Z",
        "updatedAt" : "2019-11-11T14:57:16Z",
        "lastEditedBy" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "tags" : [
        ]
      },
      {
        "id" : "c91329dc-7423-448d-a0de-c91f8f1b89b1",
        "parentId" : "9251aa94-031e-45f1-9128-fc407502e77a",
        "authorId" : null,
        "body" : "@remyhaemmerle-da The issue is that `Eq` (the DAML typeclass) does not necessarily match the built-in equality, so you may get unexpected results when using something like `EQUAL`. In any case we can define `GENMAP_EQ` in Daml without problem, it just won't be fast.\r\n",
        "createdAt" : "2019-11-04T16:44:42Z",
        "updatedAt" : "2019-11-11T14:57:16Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "cf57473a-e0ea-47cd-9ce5-d3deafaa3e34",
        "parentId" : "9251aa94-031e-45f1-9128-fc407502e77a",
        "authorId" : null,
        "body" : "@hurryabit Could we remove user-defined equality from DAML? Should we?",
        "createdAt" : "2019-11-04T16:47:44Z",
        "updatedAt" : "2019-11-11T14:57:16Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "0d4123bf-72c2-49bd-9c95-386c676b6d4c",
        "parentId" : "9251aa94-031e-45f1-9128-fc407502e77a",
        "authorId" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "body" : "OK. Let's start without it. We can still add it letter. ",
        "createdAt" : "2019-11-04T16:48:36Z",
        "updatedAt" : "2019-11-11T14:57:16Z",
        "lastEditedBy" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "tags" : [
        ]
      },
      {
        "id" : "c1f69faa-b9e8-4c35-bf75-a391e075065c",
        "parentId" : "9251aa94-031e-45f1-9128-fc407502e77a",
        "authorId" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "body" : "I'm not averse to removing user-defined equality from DAML. Particularly if we find a way to keep the `Eq` type class as a marker but have no (or at least no user-implementable) methods in it. I'm not sure if that feasible though since `Eq` is probably wired quite deep into GHC.\r\n@associahedron do you have some time at hand to investigate this a bit?\r\n@bame-da what do you think about this?",
        "createdAt" : "2019-11-04T21:53:53Z",
        "updatedAt" : "2019-11-11T14:57:16Z",
        "lastEditedBy" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "tags" : [
        ]
      },
      {
        "id" : "d05aef60-56e5-4210-8039-4290dc88cb08",
        "parentId" : "9251aa94-031e-45f1-9128-fc407502e77a",
        "authorId" : null,
        "body" : "@hurryabit I think we can outlaw custom `Eq` instances in the preprocessor, and tell users to use `deriving Eq` instead.",
        "createdAt" : "2019-11-05T09:46:39Z",
        "updatedAt" : "2019-11-11T14:57:16Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "ed34d91a-5038-4f6d-a3ac-d42be91230cf",
        "parentId" : "9251aa94-031e-45f1-9128-fc407502e77a",
        "authorId" : null,
        "body" : "We could make it a warning for a while, and turn it into an outright error later.",
        "createdAt" : "2019-11-05T12:54:33Z",
        "updatedAt" : "2019-11-11T14:57:16Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "0ff7bf8d-d616-46c4-bcad-151a79562396",
        "parentId" : "9251aa94-031e-45f1-9128-fc407502e77a",
        "authorId" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "body" : "That sounds reasonable to me. We should then also replace the derived `Eq` instances with calls to our DAML-LF primitive during our conversion to DAML-LF.",
        "createdAt" : "2019-11-05T16:47:29Z",
        "updatedAt" : "2019-11-11T14:57:16Z",
        "lastEditedBy" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "tags" : [
        ]
      }
    ],
    "commit" : "b9156096baacc799653b528944997e1f63b50031",
    "line" : 76,
    "diffHunk" : "@@ -1,1 +2589,2593 @@  Returns ``'True'`` if the first type representation is syntactically equal to\n  the second one, ``'False'`` otherwise.\n\n  [*Available in versions >= 1.7*]\n"
  },
  {
    "id" : "e8b85f97-9282-43f5-bf19-7e9cbaa9db0a",
    "prId" : 3196,
    "prUrl" : "https://github.com/digital-asset/daml/pull/3196",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "643fe2a4-6470-4d5e-9b55-7bd480eb02e4",
        "parentId" : null,
        "authorId" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "body" : "We should probably get the old preconditions back and add `τ does not contain quantifiers`.",
        "createdAt" : "2019-10-16T12:30:56Z",
        "updatedAt" : "2019-10-16T12:31:04Z",
        "lastEditedBy" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "tags" : [
        ]
      },
      {
        "id" : "2e4d5091-bf49-4eb7-b403-c22a68edb761",
        "parentId" : "643fe2a4-6470-4d5e-9b55-7bd480eb02e4",
        "authorId" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "body" : "I’ll change it together with changing the Haskell typechecker.",
        "createdAt" : "2019-10-16T12:32:33Z",
        "updatedAt" : "2019-10-16T12:32:33Z",
        "lastEditedBy" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "tags" : [
        ]
      },
      {
        "id" : "1df52ee9-d4b8-40b5-a995-56e5d85f779f",
        "parentId" : "643fe2a4-6470-4d5e-9b55-7bd480eb02e4",
        "authorId" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "body" : "(I forget the haskell typechecker. )\r\n\r\nThis is closer to what I implement in scala. \r\nFell free to change everything as you wish.",
        "createdAt" : "2019-10-16T12:42:56Z",
        "updatedAt" : "2019-10-16T12:43:06Z",
        "lastEditedBy" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "tags" : [
        ]
      }
    ],
    "commit" : "81d42fab427c6588a392d965600919058f32aa47",
    "line" : 12,
    "diffHunk" : "@@ -1,1 +897,901 @@\n      τ contains neither variables nor quantifiers\n      Γ  ⊢  τ : *     Γ  ⊢  e  : Any\n    ——————————————————————————————————————————————————————————————— ExpFromAny\n      Γ  ⊢  'from_any' @τ e  :  'Optional' τ"
  },
  {
    "id" : "0ba107cd-b07f-40a7-b6a6-13cd6a84ffec",
    "prId" : 3141,
    "prUrl" : "https://github.com/digital-asset/daml/pull/3141",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "793152b3-2094-4d5d-907e-fff797b1af62",
        "parentId" : null,
        "authorId" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "body" : "Naive question. \r\n Why not `'to_any' @τ : τ -> Any` instead of `'to_any' @τ e: Any`  ?  ",
        "createdAt" : "2019-10-09T15:45:39Z",
        "updatedAt" : "2019-10-10T04:59:02Z",
        "lastEditedBy" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "tags" : [
        ]
      },
      {
        "id" : "a2c287d3-6665-4a29-9b0f-c2f51e8102aa",
        "parentId" : "793152b3-2094-4d5d-907e-fff797b1af62",
        "authorId" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "body" : "Two reasons:\r\n1. For `to_any`, you would end up with applications sometimes being values if the function is `to_any τ` which is a bit awkward. This does not apply to `from_any`.\r\n2. Consistency: Changing only `from_any` while keeping `to_any` the way it is due to 1 feels weird and also doesn’t fit in with things like `Cons`, `create`, … that are all defined similarly.",
        "createdAt" : "2019-10-09T18:30:18Z",
        "updatedAt" : "2019-10-10T04:59:02Z",
        "lastEditedBy" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "tags" : [
        ]
      }
    ],
    "commit" : "9f33ac4e3d1ffe96883e634244b43469966c6fd2",
    "line" : 28,
    "diffHunk" : "@@ -1,1 +585,589 @@       |  ⟨ e₁ 'with' f = e₂ ⟩                      -- ExpTupleUpdate: Tuple update\n       |  u                                         -- ExpUpdate: Update expression\n       | 'to_any' @τ t                              -- ExpToAny: Wrap a value of the given type in Any\n       | 'from_any' @τ t                            -- ExpToAny: Extract a value of the given from Any or return None\n       | 'to_text_template_id' @Mod:T               -- ExpToTextTemplateId: Generate a unique textual representation of the given TypeConName"
  },
  {
    "id" : "35f2f6a5-86e3-40d9-9322-5234a02cb62b",
    "prId" : 2930,
    "prUrl" : "https://github.com/digital-asset/daml/pull/2930",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9339a67c-b2de-4a32-9f09-66b6b5b9b6a2",
        "parentId" : null,
        "authorId" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "body" : "```suggestion\r\n     ⊢ᵥ  e\r\n```",
        "createdAt" : "2019-09-23T14:34:59Z",
        "updatedAt" : "2019-09-23T15:58:01Z",
        "lastEditedBy" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "tags" : [
        ]
      }
    ],
    "commit" : "2d03fb1f1bef05c953d9b07d8f58b002ad7b9413",
    "line" : 58,
    "diffHunk" : "@@ -1,1 +1487,1491 @@\n\n     ⊢ᵥ e\n   ——————————————————————————————————————————————————— ValExpToAnyTemplate\n     ⊢ᵥ  'to_any_template' @Mod:T e"
  },
  {
    "id" : "65b1d5ed-185a-4b17-a65d-b18fc78dd81a",
    "prId" : 2930,
    "prUrl" : "https://github.com/digital-asset/daml/pull/2930",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2ee09f0c-cb23-4a2a-8275-c0bee9480402",
        "parentId" : null,
        "authorId" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "body" : "I suppose that's the value representation of a an `AnyTemplate`. Is that correct?",
        "createdAt" : "2019-09-23T14:35:27Z",
        "updatedAt" : "2019-09-23T15:58:01Z",
        "lastEditedBy" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "tags" : [
        ]
      }
    ],
    "commit" : "2d03fb1f1bef05c953d9b07d8f58b002ad7b9413",
    "line" : 60,
    "diffHunk" : "@@ -1,1 +1489,1493 @@     ⊢ᵥ e\n   ——————————————————————————————————————————————————— ValExpToAnyTemplate\n     ⊢ᵥ  'to_any_template' @Mod:T e\n\n     ⊢ᵥ  e"
  },
  {
    "id" : "30e24c22-c985-4632-88d6-fa0a20216ef9",
    "prId" : 2766,
    "prUrl" : "https://github.com/digital-asset/daml/pull/2766",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bf4c3561-9cfe-4c7d-baa4-ba6667c49b9c",
        "parentId" : null,
        "authorId" : "eb431011-3221-41ae-bf30-e72dde278004",
        "body" : "🤦‍♂ what a great format",
        "createdAt" : "2019-09-05T12:09:17Z",
        "updatedAt" : "2019-09-05T12:09:18Z",
        "lastEditedBy" : "eb431011-3221-41ae-bf30-e72dde278004",
        "tags" : [
        ]
      }
    ],
    "commit" : "00fd4274b0214e6d6d6284320c5a3714cea9975b",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +493,497 @@\nKinds, types, and expressions\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n.. TODO We might want to consider changing the syntax for ``Mod``,"
  },
  {
    "id" : "403f7230-cd12-4608-a176-25cd6eba486d",
    "prId" : 2298,
    "prUrl" : "https://github.com/digital-asset/daml/pull/2298",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a5f6bf0f-8404-45bc-a48c-db8ec82d6d75",
        "parentId" : null,
        "authorId" : "4c501a40-3340-4f35-b66e-fcfb75e20f37",
        "body" : "¯\\\\\\_(ツ)\\_/¯\r\n\r\n```suggestion\r\n          LitDate  ∈  \\d{4}-\\d{2}-\\d{2}               -- LitDate\r\n```",
        "createdAt" : "2019-07-29T18:30:06Z",
        "updatedAt" : "2019-07-29T18:42:16Z",
        "lastEditedBy" : "4c501a40-3340-4f35-b66e-fcfb75e20f37",
        "tags" : [
        ]
      }
    ],
    "commit" : "33e6b1950b738efc874e833e075c7c7044405865",
    "line" : 51,
    "diffHunk" : "@@ -1,1 +380,384 @@\n  Date literals:\n         LitDate  ∈  \\d{4}-\\d{4}-\\d{4}               -- LitDate\n\n  UTC timestamp literals:"
  },
  {
    "id" : "06a99327-2ff3-4610-83a1-d0c03932d3a4",
    "prId" : 2298,
    "prUrl" : "https://github.com/digital-asset/daml/pull/2298",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e9fbff4f-3b78-4eba-bfde-9ec57ee7f4e5",
        "parentId" : null,
        "authorId" : "4c501a40-3340-4f35-b66e-fcfb75e20f37",
        "body" : "Several other cases below as well.\r\n\r\n```suggestion\r\n  Adds the two decimals.  The scale of the inputs and the output is\r\n```",
        "createdAt" : "2019-07-29T18:33:29Z",
        "updatedAt" : "2019-07-29T18:42:16Z",
        "lastEditedBy" : "4c501a40-3340-4f35-b66e-fcfb75e20f37",
        "tags" : [
        ]
      }
    ],
    "commit" : "33e6b1950b738efc874e833e075c7c7044405865",
    "line" : 180,
    "diffHunk" : "@@ -1,1 +2114,2118 @@* ``ADD_NUMERIC : ∀ (α : nat) . 'Numeric' α → 'Numeric' α  → 'Numeric' α``\n\n  Adds the two decimals.  The scale of the inputs and the ouput is\n  given by the type parameter `α`.  Throws an error in case of\n  overflow."
  },
  {
    "id" : "c25017c0-ef71-49e8-a8c5-a1e656ab1f3f",
    "prId" : 2298,
    "prUrl" : "https://github.com/digital-asset/daml/pull/2298",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ee72c1af-2afa-457b-9970-b984560ad67d",
        "parentId" : null,
        "authorId" : "4c501a40-3340-4f35-b66e-fcfb75e20f37",
        "body" : "```suggestion\r\n1. Renaming the fields and the enum values containing \"``decimal``\" in\r\n```",
        "createdAt" : "2019-07-29T18:36:15Z",
        "updatedAt" : "2019-07-29T18:42:16Z",
        "lastEditedBy" : "4c501a40-3340-4f35-b66e-fcfb75e20f37",
        "tags" : [
        ]
      }
    ],
    "commit" : "33e6b1950b738efc874e833e075c7c7044405865",
    "line" : 397,
    "diffHunk" : "@@ -1,1 +2884,2888 @@is achieved by\n\n1. Renaming the fields and the emum values containing \"``decimal``\" in\n   the Protocol buffer definition with \"``numeric``\" instead,\n2. Unconditionally fixing the scale of Numeric literals to ``10`` when"
  },
  {
    "id" : "16b4b14c-8c91-4096-a4ef-c02905b8f81b",
    "prId" : 2298,
    "prUrl" : "https://github.com/digital-asset/daml/pull/2298",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c2a11036-50df-4bcd-ac95-a4e381642a08",
        "parentId" : null,
        "authorId" : "4c501a40-3340-4f35-b66e-fcfb75e20f37",
        "body" : "Is this a sufficient specification to include that the engine implementation of this primitive requires `α` to be reified? Consider\r\n\r\n```hs\r\nparseDecimal : Text -> Optional (Numeric n)\r\nparseDecimal = primitive @\"BEDecimalFromText\"\r\n\r\nparseDecimals : [Text] -> [Optional (Numeric n)]\r\nparseDecimals = fmap parseDecimal\r\n\r\nfives : [Optional (Numeric 3)]\r\nfives = parseDecimals [\"5\"]",
        "createdAt" : "2019-07-29T18:41:50Z",
        "updatedAt" : "2019-07-29T18:43:11Z",
        "lastEditedBy" : "4c501a40-3340-4f35-b66e-fcfb75e20f37",
        "tags" : [
        ]
      }
    ],
    "commit" : "33e6b1950b738efc874e833e075c7c7044405865",
    "line" : 290,
    "diffHunk" : "@@ -1,1 +2188,2192 @@  of the input is given by the type parameter `α`.\n\n* ``FROM_TEXT_NUMERIC : ∀ (α : nat) .'Text' → 'Optional' 'Numeric' α``\n\n  Given a string representation of a decimal returns the decimal"
  },
  {
    "id" : "166e3740-ae65-4c6e-aa13-09ca325600e6",
    "prId" : 2298,
    "prUrl" : "https://github.com/digital-asset/daml/pull/2298",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ee0021ff-6b18-49c3-838a-6d3594f6954a",
        "parentId" : null,
        "authorId" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "body" : "Is this actually true? Isn't it rounding to `i` digits after the dot?",
        "createdAt" : "2019-07-30T11:33:59Z",
        "updatedAt" : "2019-07-30T11:52:17Z",
        "lastEditedBy" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "tags" : [
        ]
      },
      {
        "id" : "939890cf-a07f-4922-b30d-b2ed0a9440f1",
        "parentId" : "ee0021ff-6b18-49c3-838a-6d3594f6954a",
        "authorId" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "body" : "you'r right it is the the closet multiple of ``10⁻ⁱ`` !",
        "createdAt" : "2019-07-30T12:13:04Z",
        "updatedAt" : "2019-07-30T12:13:05Z",
        "lastEditedBy" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "tags" : [
        ]
      }
    ],
    "commit" : "33e6b1950b738efc874e833e075c7c7044405865",
    "line" : 230,
    "diffHunk" : "@@ -1,1 +2143,2147 @@* ``ROUND_NUMERIC : ∀ (α : nat) . 'Int64' → 'Numeric' α → 'Numeric' α``\n\n  Rounds the decimal to the closest multiple of ``10ⁱ`` where ``i`` is\n  integer argument.  In case the value to be rounded is exactly\n  half-way between two multiples, rounds toward the even one,"
  },
  {
    "id" : "d4f2251c-111b-46fd-8f5a-b01c759d893f",
    "prId" : 2298,
    "prUrl" : "https://github.com/digital-asset/daml/pull/2298",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a05adc19-df77-4658-9b87-8fee29be47cc",
        "parentId" : null,
        "authorId" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "body" : "Do we actually enforce these bounds anywhere?",
        "createdAt" : "2019-07-30T11:40:41Z",
        "updatedAt" : "2019-07-30T11:52:17Z",
        "lastEditedBy" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "tags" : [
        ]
      },
      {
        "id" : "7ee9b3ec-60e5-4984-97bf-1b71f3332f28",
        "parentId" : "a05adc19-df77-4658-9b87-8fee29be47cc",
        "authorId" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "body" : "We will check during deserialization.\r\nSee https://github.com/digital-asset/daml/pull/2298/files/33e6b1950b738efc874e833e075c7c7044405865#diff-55b02b80bc6355ad225115dd9046ce2eR302\r\n\r\nWe could relax this in the future if needed. ",
        "createdAt" : "2019-07-30T12:10:14Z",
        "updatedAt" : "2019-07-30T12:10:24Z",
        "lastEditedBy" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "tags" : [
        ]
      }
    ],
    "commit" : "33e6b1950b738efc874e833e075c7c7044405865",
    "line" : 56,
    "diffHunk" : "@@ -1,1 +393,397 @@The literals represent actual DAML-LF values:\n\n* A ``LitNatType`` represents a natural number between ``0`` and\n  ``38``, bounds inclusive.\n* A ``LitInt64`` represents a standard signed 64-bit integer (integer"
  },
  {
    "id" : "18a124a1-d80b-494b-8b8d-8089f07da261",
    "prId" : 1408,
    "prUrl" : "https://github.com/digital-asset/daml/pull/1408",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7965ef64-0dcc-48c4-9184-ecdec537d9f0",
        "parentId" : null,
        "authorId" : "8e6a9b81-aba7-4206-84ba-06825f79e954",
        "body" : "what's the `(z)`?",
        "createdAt" : "2019-05-27T14:35:32Z",
        "updatedAt" : "2019-05-27T20:35:10Z",
        "lastEditedBy" : "8e6a9b81-aba7-4206-84ba-06825f79e954",
        "tags" : [
        ]
      },
      {
        "id" : "4cc1a4b3-e2ac-4984-9b59-41e024894f79",
        "parentId" : "7965ef64-0dcc-48c4-9184-ecdec537d9f0",
        "authorId" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "body" : "It's for the contract id of the contract the choice is exercised on, called `self` in the surface language. It's the same in the rule above.",
        "createdAt" : "2019-05-27T14:40:21Z",
        "updatedAt" : "2019-05-27T20:35:10Z",
        "lastEditedBy" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "tags" : [
        ]
      }
    ],
    "commit" : "e31c10751036e29879110fc543da4d1ea01cac35",
    "line" : 116,
    "diffHunk" : "@@ -1,1 +1858,1862 @@\n     'tpl' (x : T)\n         ↦ { 'choices' { …, 'choice' ChKind Ch (y : τ) (z) : σ  'by' eₚ ↦ eₐ, … }, … }  ∈  〚Ξ〛Mod\n     cid ∈ dom(st₀)\n     st₀(cid) = (Mod:T, vₜ, 'active')"
  },
  {
    "id" : "3537cc17-fc02-4b74-9de9-64ee8c5f59bc",
    "prId" : 709,
    "prUrl" : "https://github.com/digital-asset/daml/pull/709",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "75368c53-3571-4f98-9263-5f66aefdd7cc",
        "parentId" : null,
        "authorId" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "body" : "Maybe we can add a comment on what is `1.dev` version. ",
        "createdAt" : "2019-05-02T06:58:04Z",
        "updatedAt" : "2019-05-02T20:20:28Z",
        "lastEditedBy" : "7e495b20-db12-4c9f-84f9-0c729e38a0c9",
        "tags" : [
        ]
      },
      {
        "id" : "f731911a-e288-4cd4-8176-6b9de690e20e",
        "parentId" : "75368c53-3571-4f98-9263-5f66aefdd7cc",
        "authorId" : "4c501a40-3340-4f35-b66e-fcfb75e20f37",
        "body" : "10dd4a9fd10654ec8e9fc606ac9788c79eeba146",
        "createdAt" : "2019-05-02T16:26:48Z",
        "updatedAt" : "2019-05-02T20:20:28Z",
        "lastEditedBy" : "4c501a40-3340-4f35-b66e-fcfb75e20f37",
        "tags" : [
        ]
      }
    ],
    "commit" : "ac279d9f4f667d6203c27b5f0318762a261142ed",
    "line" : 33,
    "diffHunk" : "@@ -1,1 +92,96 @@`Serialization` section which is particularly concerned about versioning\nand backward compatibility.\n\n\nVersion 1.0"
  }
]
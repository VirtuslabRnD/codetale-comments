[
  {
    "id" : "680fd8bd-453b-409e-9664-36d3c805a92e",
    "prId" : 51900,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/51900#pullrequestreview-60571801",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e45fa184-f368-4b63-a39d-3c95900993b8",
        "parentId" : null,
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "This block indicates to me that this isn't something that most API servers care about setting for themselves.",
        "createdAt" : "2017-09-05T11:47:42Z",
        "updatedAt" : "2017-09-08T14:13:01Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      }
    ],
    "commit" : "fbd310dbc7312fcae4267dd64326a1e7b4a0a8ae",
    "line" : 21,
    "diffHunk" : "@@ -1,1 +191,195 @@\tsharedInformers := informers.NewSharedInformerFactory(client, 10*time.Minute)\n\n\tclientgoExternalClient, err := clientgoclientset.NewForConfig(genericConfig.LoopbackClientConfig)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to create real external clientset: %v\", err)"
  },
  {
    "id" : "90555c41-acff-4390-8d18-a0c16da6ecd7",
    "prId" : 42278,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/42278#pullrequestreview-25794080",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ea0442da-9cd4-4524-8ea8-4310c15e00f6",
        "parentId" : null,
        "authorId" : "e36c9d4f-8037-4359-bd9a-80d5b6c08379",
        "body" : "@sttts Is there any danger in starting the informers after the server can accept connections?",
        "createdAt" : "2017-03-07T16:55:01Z",
        "updatedAt" : "2017-03-08T14:59:07Z",
        "lastEditedBy" : "e36c9d4f-8037-4359-bd9a-80d5b6c08379",
        "tags" : [
        ]
      },
      {
        "id" : "1b7d751c-9afc-4b86-b55d-f2b276af81e5",
        "parentId" : "ea0442da-9cd4-4524-8ea8-4310c15e00f6",
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "Good question, I don't think it's harmful. /cc @ncdc ",
        "createdAt" : "2017-03-07T20:18:37Z",
        "updatedAt" : "2017-03-08T14:59:07Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      },
      {
        "id" : "7cfb9bff-3d7e-459c-a7b2-430189a7fd42",
        "parentId" : "ea0442da-9cd4-4524-8ea8-4310c15e00f6",
        "authorId" : "b15d5707-82a8-4448-b49d-a2d6502b10f9",
        "body" : "The typical flow that \"just works\" is like this:\r\n\r\n1. Set up anything that uses a shared informer, for example:\r\n    1. `sharedInformers.Core().V1().Pods().AddEventHandler(...)`\r\n1. If you're using a lister from a shared informer, make sure you wait for its informer to sync first, for example:\r\n    1. `if ! cache.WaitForCacheSync(stopCh, podListerSynced, ...)`\r\n1. Start the shared informer factory via `sharedInformers.Start(...)`\r\n\r\nStep 1 is required. Step 2 is optional but highly encouraged.\r\n\r\nIf the first time you reference a shared informer is after you've started the factory, you'll have to manually run that shared informer (we should probably fix that) cc @deads2k.",
        "createdAt" : "2017-03-08T15:10:30Z",
        "updatedAt" : "2017-03-08T15:10:30Z",
        "lastEditedBy" : "b15d5707-82a8-4448-b49d-a2d6502b10f9",
        "tags" : [
        ]
      }
    ],
    "commit" : "dd2a8127a554c0ec823c4966b18858cda73c0acf",
    "line" : 39,
    "diffHunk" : "@@ -1,1 +237,241 @@\terr = m.PrepareRun().NonBlockingRun(stopCh)\n\tif err == nil {\n\t\tsharedInformers.Start(stopCh)\n\t}\n\treturn err"
  },
  {
    "id" : "ab57939f-f2bb-4dc9-affc-b0eda169af3f",
    "prId" : 41093,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/41093#pullrequestreview-21018905",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "416a200a-6cf3-43fe-88ac-6df1d0f35e4c",
        "parentId" : null,
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "this feels strange that we have generic etcd options, pass it through the ApplyTo calls and then only use it here in each apiserver to create a non-generic rest options factory.",
        "createdAt" : "2017-02-09T07:51:51Z",
        "updatedAt" : "2017-02-09T07:51:51Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      },
      {
        "id" : "d3c4e1ad-aefd-44a6-a18b-abae0eacabca",
        "parentId" : "416a200a-6cf3-43fe-88ac-6df1d0f35e4c",
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "> this feels strange that we have generic etcd options, pass it through the ApplyTo calls and then only use it here in each apiserver to create a non-generic rest options factory.\r\n\r\nKube's impl (and probably ours too) is borked from a \"use generic RESTOptionsFactory\" perspective because of cohabitating resources, partial group enablement, and several other pretty insane things we do.  In a \"normal\" world, it falls out nicely.  See aggregator, wardle, and anyone else starting fresh.",
        "createdAt" : "2017-02-09T13:39:24Z",
        "updatedAt" : "2017-02-09T13:39:24Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      },
      {
        "id" : "bca2287d-218e-4d03-ac7d-b2a374430b15",
        "parentId" : "416a200a-6cf3-43fe-88ac-6df1d0f35e4c",
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "Got it, didn't even realize we have two. Makes sense then.",
        "createdAt" : "2017-02-09T14:25:24Z",
        "updatedAt" : "2017-02-09T14:25:25Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      }
    ],
    "commit" : "a463540d47f16f14899b2ec60779f420df9368f4",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +195,199 @@\t\tsets.NewString(\"attach\", \"exec\", \"proxy\", \"log\", \"portforward\"),\n\t)\n\tgenericConfig.RESTOptionsGetter = &kubeapiserver.RESTOptionsFactory{\n\t\tStorageFactory:          storageFactory,\n\t\tEnableWatchCache:        s.Etcd.EnableWatchCache,"
  },
  {
    "id" : "54c1e426-140c-4a93-b85a-d1404dfd215e",
    "prId" : 34047,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/34047#pullrequestreview-4090093",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d08f0f67-aa80-49b8-8243-f2c6bae32b90",
        "parentId" : null,
        "authorId" : "b15d5707-82a8-4448-b49d-a2d6502b10f9",
        "body" : "fatal?\n",
        "createdAt" : "2016-10-13T14:52:19Z",
        "updatedAt" : "2016-10-13T14:54:36Z",
        "lastEditedBy" : "b15d5707-82a8-4448-b49d-a2d6502b10f9",
        "tags" : [
        ]
      }
    ],
    "commit" : "e1638f11a3994db7e04a5e670e8bd929820c9d45",
    "line" : 48,
    "diffHunk" : "@@ -1,1 +134,138 @@\tclient, err := s.NewSelfClient(privilegedLoopbackToken)\n\tif err != nil {\n\t\tglog.Errorf(\"Failed to create clientset: %v\", err)\n\t}\n\tsharedInformers := informers.NewSharedInformerFactory(client, 10*time.Minute)"
  },
  {
    "id" : "d728b3da-a72b-46af-bff2-dfe69098c92b",
    "prId" : 34000,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/34000#pullrequestreview-2988459",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "cdec208f-b067-40b9-8286-f3bcd9b80855",
        "parentId" : null,
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "@quinton-hoole @nikhiljindal how much memory do you expect federation apiserver to consume?\n",
        "createdAt" : "2016-10-05T19:43:37Z",
        "updatedAt" : "2016-10-05T19:43:37Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      }
    ],
    "commit" : "2bfcb1a8500248be3993e080453c480bee99cc25",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +85,89 @@\tif s.StorageConfig.DeserializationCacheSize == 0 {\n\t\t// When size of cache is not explicitly set, set it to 50000\n\t\ts.StorageConfig.DeserializationCacheSize = 50000\n\t}\n\tstorageGroupsToEncodingVersion, err := s.StorageGroupsToEncodingVersion()"
  },
  {
    "id" : "f5dc9832-0deb-4624-8148-69460fdcb0d3",
    "prId" : 31491,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/31491#pullrequestreview-754799",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c47714f0-7a84-461e-937f-24f4c509e493",
        "parentId" : null,
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "Can you create an issue to DRY this out?  I'm thinking we might actually want this an option on the `GenericAPIServer`.  `EnableLoopbackToken` or some such.\n",
        "createdAt" : "2016-09-20T12:33:31Z",
        "updatedAt" : "2016-09-20T23:01:10Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      },
      {
        "id" : "33271417-7410-454e-b657-b22f1d933d18",
        "parentId" : "c47714f0-7a84-461e-937f-24f4c509e493",
        "authorId" : "bd04f755-e62f-45fb-8771-4cc2b5db49d4",
        "body" : "let me add a TODO in the code as well. will open an issue when we are close to wrapping this PR up (depending on what we end up deciding)\n",
        "createdAt" : "2016-09-20T14:10:35Z",
        "updatedAt" : "2016-09-20T23:01:10Z",
        "lastEditedBy" : "bd04f755-e62f-45fb-8771-4cc2b5db49d4",
        "tags" : [
        ]
      }
    ],
    "commit" : "364dd1a752855c6f647086299bebb0ec6d4fad08",
    "line" : null,
    "diffHunk" : "@@ -1,1 +176,180 @@\n\t// TODO(dims): We probably need to add an option \"EnableLoopbackToken\"\n\tif apiAuthenticator != nil {\n\t\tvar uid = uuid.NewRandom().String()\n\t\ttokens := make(map[string]*user.DefaultInfo)"
  },
  {
    "id" : "90303df0-174c-40a2-9dd7-20d0294c56bd",
    "prId" : 28860,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4e1566d8-fcf9-4c25-8960-8f5d44f485d1",
        "parentId" : null,
        "authorId" : "f2369046-26b1-4b8c-a8cd-5671ab22066c",
        "body" : "This `if` is duplicate\n",
        "createdAt" : "2016-07-19T09:16:46Z",
        "updatedAt" : "2016-08-18T20:02:05Z",
        "lastEditedBy" : "f2369046-26b1-4b8c-a8cd-5671ab22066c",
        "tags" : [
        ]
      }
    ],
    "commit" : "b4eaf625a05afc72963c71c4c37bb8a4fff1f9dd",
    "line" : null,
    "diffHunk" : "@@ -1,1 +158,162 @@\n\tauthorizer, err := authorizer.NewAuthorizerFromAuthorizationConfig(authorizationModeNames, authorizationConfig)\n\tif err != nil {\n\t\tglog.Fatalf(\"Invalid Authorization Config: %v\", err)\n\t}"
  },
  {
    "id" : "4ba75bde-bea0-423f-9bb1-a4d42c16c76b",
    "prId" : 26709,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4c576f0a-15bc-4d4d-b790-f7acc38c6875",
        "parentId" : null,
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "spawn an issue to make this somethign on struct that we can pass in.\n",
        "createdAt" : "2016-07-20T20:32:11Z",
        "updatedAt" : "2016-07-21T12:05:15Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      },
      {
        "id" : "00f872ca-3b5c-49f2-9f45-ddfe1aae2c55",
        "parentId" : "4c576f0a-15bc-4d4d-b790-f7acc38c6875",
        "authorId" : "b15d5707-82a8-4448-b49d-a2d6502b10f9",
        "body" : "You mean on ServerRunOptions?\n",
        "createdAt" : "2016-07-20T20:37:03Z",
        "updatedAt" : "2016-07-21T12:05:15Z",
        "lastEditedBy" : "b15d5707-82a8-4448-b49d-a2d6502b10f9",
        "tags" : [
        ]
      },
      {
        "id" : "75ae06d7-592f-423e-ae15-3815088db74d",
        "parentId" : "4c576f0a-15bc-4d4d-b790-f7acc38c6875",
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "> You mean on ServerRunOptions?\n\nHrm, now I remember why we're unable to use these paths to build the server downstream.  We have come in a layer deeper to provide a completely separate admission chain.\n",
        "createdAt" : "2016-07-21T11:41:30Z",
        "updatedAt" : "2016-07-21T12:05:15Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      }
    ],
    "commit" : "037d116add1f4a59db2767d21aa6189a4c9cabb0",
    "line" : 26,
    "diffHunk" : "@@ -1,1 +123,127 @@\t\tglog.Errorf(\"Failed to create clientset: %v\", err)\n\t}\n\tsharedInformers := informers.NewSharedInformerFactory(client, 10*time.Minute)\n\tpluginInitializer := admission.NewPluginInitializer(sharedInformers)\n"
  }
]
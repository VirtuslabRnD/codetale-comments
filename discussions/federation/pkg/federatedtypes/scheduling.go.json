[
  {
    "id" : "41f8d3d9-c647-4805-8702-3109b31a22c8",
    "prId" : 49950,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/49950#pullrequestreview-56356085",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0f167404-0475-42a3-96e3-7793090253cd",
        "parentId" : null,
        "authorId" : null,
        "body" : "Rather replace with a simple set inclusion operation?  That would be less code, and more efficient.  I think we have a function in the utils library to do that.  StringSet or similar.",
        "createdAt" : "2017-08-07T23:53:17Z",
        "updatedAt" : "2017-08-24T10:07:12Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "c498dcbe-4b7e-4ad4-a8f7-d98643c809eb",
        "parentId" : "0f167404-0475-42a3-96e3-7793090253cd",
        "authorId" : "cc7376b4-34cd-480b-ad10-0b4b879dde52",
        "body" : "If you are talking about [this](https://github.com/kubernetes/apimachinery/blob/master/pkg/util/sets/string.go#L19), I found it less efficient then using the simple slice like I have used here, simply by the fact that it uses maps (I have used it in hpa controller though, because of the need of set operations over there).\r\nI could have used this string set to store the cluster list in the first place to ensure, I don't introduce a function like the one, I got this comment on. But a slice suited the need better because of marshalling being super easy [as here](https://github.com/kubernetes/kubernetes/pull/49950/commits/41b6440a938c00b3b8b40881bed986b1304cdb71#diff-153c05d91ab301e028511701ea78219bR39).\r\nPlease let me know if you have a better suggestion.",
        "createdAt" : "2017-08-10T11:31:56Z",
        "updatedAt" : "2017-08-24T10:07:12Z",
        "lastEditedBy" : "cc7376b4-34cd-480b-ad10-0b4b879dde52",
        "tags" : [
        ]
      },
      {
        "id" : "ac22f880-b265-47c2-a060-9a3ce817ab50",
        "parentId" : "0f167404-0475-42a3-96e3-7793090253cd",
        "authorId" : null,
        "body" : "OK, fair enough.",
        "createdAt" : "2017-08-11T21:08:53Z",
        "updatedAt" : "2017-08-24T10:07:12Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "e7c7646f-6ff0-4f59-bec9-dd12d34ce295",
        "parentId" : "0f167404-0475-42a3-96e3-7793090253cd",
        "authorId" : "cc7376b4-34cd-480b-ad10-0b4b879dde52",
        "body" : "Ack.",
        "createdAt" : "2017-08-15T14:27:07Z",
        "updatedAt" : "2017-08-24T10:07:12Z",
        "lastEditedBy" : "cc7376b4-34cd-480b-ad10-0b4b879dde52",
        "tags" : [
        ]
      }
    ],
    "commit" : "da2db332f1552a7ddcba31d5f8c9811ccf2b87d1",
    "line" : 46,
    "diffHunk" : "@@ -1,1 +96,100 @@}\n\nfunc isSelected(names []string, name string) bool {\n\tfor _, val := range names {\n\t\tif val == name {"
  },
  {
    "id" : "77aea3bd-3b07-48e0-97bd-a26124e87a83",
    "prId" : 49950,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/49950#pullrequestreview-58537086",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "415d7d85-7f8e-4261-b5e0-9948a51aa9c6",
        "parentId" : null,
        "authorId" : null,
        "body" : "This seems to imply that if the federated HPA has no cluster selector ( and hence targets all clusters), and the target object has a cluster selector, then the two can get out of sync? Should the lack of a cluster selector on the HPA, not transfer to the target object?",
        "createdAt" : "2017-08-11T21:42:28Z",
        "updatedAt" : "2017-08-24T10:07:12Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "6716d7b5-ff3e-44c3-b39a-24c2669c46ee",
        "parentId" : "415d7d85-7f8e-4261-b5e0-9948a51aa9c6",
        "authorId" : "cc7376b4-34cd-480b-ad10-0b4b879dde52",
        "body" : "Please see my comment above.\r\nYes this is a choice, to implement (option 1 above). Please let me know if you think this is a better choice.",
        "createdAt" : "2017-08-15T15:24:43Z",
        "updatedAt" : "2017-08-24T10:07:12Z",
        "lastEditedBy" : "cc7376b4-34cd-480b-ad10-0b4b879dde52",
        "tags" : [
        ]
      },
      {
        "id" : "778211d9-2449-4d26-8566-084b1e75a62f",
        "parentId" : "415d7d85-7f8e-4261-b5e0-9948a51aa9c6",
        "authorId" : null,
        "body" : "I think you've done the right thing (option 2).",
        "createdAt" : "2017-08-24T23:24:48Z",
        "updatedAt" : "2017-08-24T23:24:48Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "da2db332f1552a7ddcba31d5f8c9811ccf2b87d1",
    "line" : 80,
    "diffHunk" : "@@ -1,1 +130,134 @@\t}\n\n\tif hpaSelectedClusters != nil {\n\t\thpaControlled = true\n\t}"
  },
  {
    "id" : "e9125200-d1c8-42bd-a4f8-22c99d4d231b",
    "prId" : 49950,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/49950#pullrequestreview-58537270",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5b4f9e91-5f95-459e-81f8-1c55161aa5a3",
        "parentId" : null,
        "authorId" : null,
        "body" : "It's not clear to me what the meaning of having replicas set to zero here is?  Or more generally, what the purpose of this field is.  To the uninformed (like me :-)  it could mean the number of replicas in the underlying target object (i.e. status) in which case it should current by undefined, rather than zero?  Or does it mean something else? ",
        "createdAt" : "2017-08-11T21:51:27Z",
        "updatedAt" : "2017-08-24T10:07:12Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "389af56a-e924-4d2c-bba3-13e318d196bc",
        "parentId" : "5b4f9e91-5f95-459e-81f8-1c55161aa5a3",
        "authorId" : "cc7376b4-34cd-480b-ad10-0b4b879dde52",
        "body" : "ReplicaScheduleState stores the result of schedule() function specific to adapter (which cluster gets how many replicas). 0 means the particular cluster does not get any replicas, and is the initialised state too. Thought better to use 0  as that marker to avoid null checks. I have used an additional bool field to indicate if this cluster is selected in this reconcile pass or not, because we use the same field(s) to map the selection percolated from hpa or actual schedule function of this adapter.",
        "createdAt" : "2017-08-15T15:40:58Z",
        "updatedAt" : "2017-08-24T10:07:12Z",
        "lastEditedBy" : "cc7376b4-34cd-480b-ad10-0b4b879dde52",
        "tags" : [
        ]
      },
      {
        "id" : "0960ecdf-cf2d-431f-9d5f-38e76a93e8f8",
        "parentId" : "5b4f9e91-5f95-459e-81f8-1c55161aa5a3",
        "authorId" : null,
        "body" : "OK, that makes sense.",
        "createdAt" : "2017-08-24T23:26:22Z",
        "updatedAt" : "2017-08-24T23:26:22Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "da2db332f1552a7ddcba31d5f8c9811ccf2b87d1",
    "line" : 90,
    "diffHunk" : "@@ -1,1 +140,144 @@\t\tif hpaControlled {\n\t\t\tif isSelected(hpaSelectedClusters.Names, clusterName) {\n\t\t\t\treplicaState.isSelected = true\n\t\t\t}\n\t\t}"
  }
]
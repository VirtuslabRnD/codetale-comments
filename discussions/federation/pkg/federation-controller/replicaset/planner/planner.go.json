[
  {
    "id" : "3880a055-ce41-4916-8650-390cfba3971a",
    "prId" : 33213,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/33213#pullrequestreview-1078764",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ea554609-67e2-4fdd-961d-eb83e8b21b81",
        "parentId" : null,
        "authorId" : "f2369046-26b1-4b8c-a8cd-5671ab22066c",
        "body" : "This comment is no longer valid.\nWe will keep on iterating as long as we did some modification (i.e we set modified = true).\n",
        "createdAt" : "2016-09-22T03:53:08Z",
        "updatedAt" : "2016-09-22T03:53:08Z",
        "lastEditedBy" : "f2369046-26b1-4b8c-a8cd-5671ab22066c",
        "tags" : [
        ]
      }
    ],
    "commit" : "8b720ffaeb249cd5cc767571b6838f12a7b31a22",
    "line" : 10,
    "diffHunk" : "@@ -1,1 +150,154 @@\t// we may need log(replicasAtStart) iterations.\n\t// TODO: Prove that clusterCount * log(replicas) iterations solves the problem or adjust the number.\n\t// TODO: This algorithm is O(clusterCount^2 * log(replicas)) which is good for up to 100 clusters.\n\t// Find something faster.\n\tfor trial := 0; modified && remainingReplicas > 0; trial++ {"
  },
  {
    "id" : "c7be81de-fa76-4a05-a79c-7262babc93ee",
    "prId" : 31814,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "dd39680c-3186-4f72-8143-80ed3719fb8c",
        "parentId" : null,
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "In all places in the codebases we are using adler32 hash, see e.g.:\nhttps://github.com/kubernetes/kubernetes/blob/master/pkg/util/pod/pod.go#L34\n\nI would like to be consistent and use the same hasing method here too.\n",
        "createdAt" : "2016-09-01T09:24:32Z",
        "updatedAt" : "2016-09-01T14:35:51Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      },
      {
        "id" : "93a8e4be-0fa1-414c-aa51-fbf60b7d39a2",
        "parentId" : "dd39680c-3186-4f72-8143-80ed3719fb8c",
        "authorId" : "ab8bc7c5-233d-47c1-b03a-767fb930c021",
        "body" : "I made some experiments and adler32 tends to preserve alphabetical order. \n",
        "createdAt" : "2016-09-01T13:27:54Z",
        "updatedAt" : "2016-09-01T14:35:51Z",
        "lastEditedBy" : "ab8bc7c5-233d-47c1-b03a-767fb930c021",
        "tags" : [
        ]
      },
      {
        "id" : "4939d1d4-1755-4e0f-9ef8-50728062f3a0",
        "parentId" : "dd39680c-3186-4f72-8143-80ed3719fb8c",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "I don't understand - alphabetical order of what?\nIf you are explicitly calling \"hasher.Write(...)\" on it, what alphabetical order are you talking about here?\n",
        "createdAt" : "2016-09-01T14:02:25Z",
        "updatedAt" : "2016-09-01T14:35:51Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      },
      {
        "id" : "0c0738cb-a6f5-43d5-b347-570761b40361",
        "parentId" : "dd39680c-3186-4f72-8143-80ed3719fb8c",
        "authorId" : "ab8bc7c5-233d-47c1-b03a-767fb930c021",
        "body" : "Added comment.\n",
        "createdAt" : "2016-09-01T14:36:03Z",
        "updatedAt" : "2016-09-01T14:36:03Z",
        "lastEditedBy" : "ab8bc7c5-233d-47c1-b03a-767fb930c021",
        "tags" : [
        ]
      }
    ],
    "commit" : "015a970ceb5bd05a70cb2cdb4aeb873b5005dffd",
    "line" : null,
    "diffHunk" : "@@ -1,1 +75,79 @@\tnamed := func(name string, pref fed_api.ClusterReplicaSetPreferences) *namedClusterReplicaSetPreferences {\n\t\t// Seems to work better than addler for our case.\n\t\thasher := fnv.New32()\n\t\thasher.Write([]byte(name))\n\t\thasher.Write([]byte(replicaSetKey))"
  },
  {
    "id" : "e9773629-82a4-420d-bd53-a3cad54c142e",
    "prId" : 31814,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "412fab89-87d1-456c-a3af-2f4f5244e239",
        "parentId" : null,
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "You may consider using this one:\nhttps://github.com/kubernetes/kubernetes/blob/master/pkg/util/hash/hash.go#L28\n",
        "createdAt" : "2016-09-01T09:26:14Z",
        "updatedAt" : "2016-09-01T14:35:51Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      },
      {
        "id" : "02c3ae65-727c-4d53-b7df-7f8c51943427",
        "parentId" : "412fab89-87d1-456c-a3af-2f4f5244e239",
        "authorId" : "ab8bc7c5-233d-47c1-b03a-767fb930c021",
        "body" : "I don't need a hash over a whole object. Just name+namespace.\n",
        "createdAt" : "2016-09-01T13:57:32Z",
        "updatedAt" : "2016-09-01T14:35:51Z",
        "lastEditedBy" : "ab8bc7c5-233d-47c1-b03a-767fb930c021",
        "tags" : [
        ]
      }
    ],
    "commit" : "015a970ceb5bd05a70cb2cdb4aeb873b5005dffd",
    "line" : null,
    "diffHunk" : "@@ -1,1 +76,80 @@\t\t// Seems to work better than addler for our case.\n\t\thasher := fnv.New32()\n\t\thasher.Write([]byte(name))\n\t\thasher.Write([]byte(replicaSetKey))\n"
  },
  {
    "id" : "b55e048a-f0e1-4754-862d-7c15cf4bd614",
    "prId" : 31814,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e1f7d45c-5865-47f4-b146-ecb6bf7d67ee",
        "parentId" : null,
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "it probably should be:\n\n```\nnamed := func(clusterName string, pref ...)\n```\n\n[the name is actually name of a cluster right? And it's completely not clear for here.]\n",
        "createdAt" : "2016-09-01T14:04:10Z",
        "updatedAt" : "2016-09-01T14:35:51Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "015a970ceb5bd05a70cb2cdb4aeb873b5005dffd",
    "line" : 48,
    "diffHunk" : "@@ -1,1 +73,77 @@\toverflow := make(map[string]int64, len(preferences))\n\n\tnamed := func(name string, pref fed_api.ClusterReplicaSetPreferences) *namedClusterReplicaSetPreferences {\n\t\t// Seems to work better than addler for our case.\n\t\thasher := fnv.New32()"
  },
  {
    "id" : "1c0f0c8d-582b-4f65-b877-6317e23fccf7",
    "prId" : 31814,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "cbcf6687-395d-4d90-b0c3-5b28e56e8a8c",
        "parentId" : null,
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "Actually - I thought that I understood this change initially, but now I no longer think I understand it.\n\nPlease add a comment, why you actually can't compare based on clusterName here.\n",
        "createdAt" : "2016-09-01T14:10:42Z",
        "updatedAt" : "2016-09-01T14:35:51Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      },
      {
        "id" : "d9004c93-4ff7-4124-9132-31f5ce129e0d",
        "parentId" : "cbcf6687-395d-4d90-b0c3-5b28e56e8a8c",
        "authorId" : "ab8bc7c5-233d-47c1-b03a-767fb930c021",
        "body" : "Added.\n",
        "createdAt" : "2016-09-01T14:36:19Z",
        "updatedAt" : "2016-09-01T14:36:19Z",
        "lastEditedBy" : "ab8bc7c5-233d-47c1-b03a-767fb930c021",
        "tags" : [
        ]
      }
    ],
    "commit" : "015a970ceb5bd05a70cb2cdb4aeb873b5005dffd",
    "line" : 21,
    "diffHunk" : "@@ -1,1 +42,46 @@func (a byWeight) Swap(i, j int) { a[i], a[j] = a[j], a[i] }\n\n// Preferences are sorted according by decreasing weight and increasing hash (built on top of cluster name and rs name).\n// Sorting is made by a hash to avoid assigning single-replica rs to the alphabetically smallest cluster.\nfunc (a byWeight) Less(i, j int) bool {"
  },
  {
    "id" : "9960f6c3-e63c-4cef-a5d5-4a08deb508fc",
    "prId" : 30983,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3217fae2-b5ea-4a51-9308-7c6d68cfbf88",
        "parentId" : null,
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "Can extra be negative here? [For me it seems it can]\n",
        "createdAt" : "2016-08-19T09:17:41Z",
        "updatedAt" : "2016-08-19T14:14:49Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      },
      {
        "id" : "9ae9d7e2-9036-493d-859a-0f1e65986b54",
        "parentId" : "3217fae2-b5ea-4a51-9308-7c6d68cfbf88",
        "authorId" : "ab8bc7c5-233d-47c1-b03a-767fb930c021",
        "body" : "Yes, it would be possible if min > capacity. Fixed and test added.\n",
        "createdAt" : "2016-08-19T09:44:59Z",
        "updatedAt" : "2016-08-19T14:14:49Z",
        "lastEditedBy" : "ab8bc7c5-233d-47c1-b03a-767fb930c021",
        "tags" : [
        ]
      }
    ],
    "commit" : "8dfdc5b612967fdf42b932440cc100accb259ead",
    "line" : 57,
    "diffHunk" : "@@ -1,1 +119,123 @@\t\t\t\t\ttarget = minInt64(capacity, target)\n\t\t\t\t}\n\t\t\t\textra := minInt64(target-planned, remainingReplicas)\n\t\t\t\tif extra < 0 {\n\t\t\t\t\textra = 0"
  },
  {
    "id" : "663149a9-17da-4cc3-9088-62116d9d47e4",
    "prId" : 29455,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d2df0e2d-f5e5-405b-ad8a-b85b9b4fa195",
        "parentId" : null,
        "authorId" : "a179bbc5-3a91-4905-bad9-4458ac257dba",
        "body" : "any plans for rescheduling (increasing, decreasing, moving replicas) by passing the current replicas on each cluster, e.g.:\nPlan(replicasToDistribute int64, replicaStatus map[string]int64) map[string]int64\n",
        "createdAt" : "2016-07-28T16:43:07Z",
        "updatedAt" : "2016-07-28T16:55:21Z",
        "lastEditedBy" : "a179bbc5-3a91-4905-bad9-4458ac257dba",
        "tags" : [
        ]
      }
    ],
    "commit" : "ed92579d2ed014d6ada9825503a0f38a261c6037",
    "line" : 57,
    "diffHunk" : "@@ -1,1 +55,59 @@// have all of the replicas assigned. In such case a cluster with higher weight has priority over\n// cluster with lower weight (or with lexicographically smaller name in case of draw).\nfunc (p *Planner) Plan(replicasToDistribute int64, availableClusters []string) map[string]int64 {\n\tpreferences := make([]*namedClusterReplicaSetPreferences, 0, len(availableClusters))\n\tplan := make(map[string]int64, len(preferences))"
  }
]
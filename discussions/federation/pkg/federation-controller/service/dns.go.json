[
  {
    "id" : "2396992b-fd38-4c64-8660-e44efc5c8b1f",
    "prId" : 27999,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a436e79d-1eaf-4abc-9c60-42bb0e3ca617",
        "parentId" : null,
        "authorId" : "f2369046-26b1-4b8c-a8cd-5671ab22066c",
        "body" : "Add `glog.V(4).Infof(\"Adding recordset %v\", newRrset)` as you do in the else block.\n",
        "createdAt" : "2016-06-24T07:21:07Z",
        "updatedAt" : "2016-06-24T07:21:07Z",
        "lastEditedBy" : "f2369046-26b1-4b8c-a8cd-5671ab22066c",
        "tags" : [
        ]
      },
      {
        "id" : "816ad9f7-1a0c-458d-98bb-536bd8c4e2ba",
        "parentId" : "a436e79d-1eaf-4abc-9c60-42bb0e3ca617",
        "authorId" : null,
        "body" : "Agreed, done. in followup PR.\n",
        "createdAt" : "2016-06-24T15:26:32Z",
        "updatedAt" : "2016-06-24T15:26:32Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "6b435a6415a348aad14d1be257d0fcd6e2652e16",
    "line" : 49,
    "diffHunk" : "@@ -1,1 +173,177 @@\t\t\t\tglog.V(4).Infof(\"Creating CNAME to %q for %q\", uplevelCname, dnsName)\n\t\t\t\tnewRrset := rrsets.New(dnsName, []string{uplevelCname}, minDnsTtl, rrstype.CNAME)\n\t\t\t\trrset, err = rrsets.Add(newRrset)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err"
  },
  {
    "id" : "97c67677-6eaf-4599-a5e6-3902f050f244",
    "prId" : 27999,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fb0d3f0e-5325-45b1-af13-485291684e3a",
        "parentId" : null,
        "authorId" : "f2369046-26b1-4b8c-a8cd-5671ab22066c",
        "body" : "Missing param for %v.\nI have had verify script failed on my PRs for such an error. Am not sure why its not failing on this PR.\nI think its verify/go-vet that fails.\n",
        "createdAt" : "2016-06-24T07:21:12Z",
        "updatedAt" : "2016-06-24T07:21:12Z",
        "lastEditedBy" : "f2369046-26b1-4b8c-a8cd-5671ab22066c",
        "tags" : [
        ]
      },
      {
        "id" : "259f0943-76b0-4a18-8153-1089c4f11891",
        "parentId" : "fb0d3f0e-5325-45b1-af13-485291684e3a",
        "authorId" : null,
        "body" : "Interesting.  I ran go vet on this manually, and it passed. Maybe I omitted some arguments that verify/go-vet does.  Either way, I'll fix this now.\n",
        "createdAt" : "2016-06-24T15:15:24Z",
        "updatedAt" : "2016-06-24T15:15:24Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "1ca618fa-6351-4aa9-8366-c28c7852cdca",
        "parentId" : "fb0d3f0e-5325-45b1-af13-485291684e3a",
        "authorId" : null,
        "body" : "Done in followup PR.\n",
        "createdAt" : "2016-06-24T15:27:50Z",
        "updatedAt" : "2016-06-24T15:27:50Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "6b435a6415a348aad14d1be257d0fcd6e2652e16",
    "line" : 76,
    "diffHunk" : "@@ -1,1 +200,204 @@\t} else {\n\t\t// the rrset already exists, so make it right.\n\t\tglog.V(4).Infof(\"Recordset %v already exists.  Ensuring that it is correct.\")\n\t\tif len(endpoints) < 1 {\n\t\t\t// Need an appropriate CNAME record.  Check that we have it."
  },
  {
    "id" : "c8bf74c1-eadc-4399-9b23-c004dbff55af",
    "prId" : 27999,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c0d18098-8ef4-4610-833a-e916b5c7f004",
        "parentId" : null,
        "authorId" : "f2369046-26b1-4b8c-a8cd-5671ab22066c",
        "body" : "What if len(resolvedEndpoints) == 0? Is it still fine to add?\n(In comparison, in the other if block, we check uplevelCname != \"\" before adding).\n",
        "createdAt" : "2016-06-24T07:22:29Z",
        "updatedAt" : "2016-06-24T07:22:29Z",
        "lastEditedBy" : "f2369046-26b1-4b8c-a8cd-5671ab22066c",
        "tags" : [
        ]
      },
      {
        "id" : "24022c30-09b4-4b32-b075-35e246fc40fa",
        "parentId" : "c0d18098-8ef4-4610-833a-e916b5c7f004",
        "authorId" : null,
        "body" : "In this else clause, len(endpoints) is by definition > 0.  And we're adding an A record, so the value of uplevelCname in this case is irrelevant, as we're not adding a CNAME record.  Make sense @nikhiljindal ?\n",
        "createdAt" : "2016-06-24T15:33:32Z",
        "updatedAt" : "2016-06-24T15:33:32Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "6b435a6415a348aad14d1be257d0fcd6e2652e16",
    "line" : 112,
    "diffHunk" : "@@ -1,1 +230,234 @@\t\t\t// And we have healthy endpoints.  Just replace what's there with the healthy endpoints, if it's not already correct.\n\t\t\tglog.V(4).Infof(\"%s: Healthy endpoints %v exist.  Recordset %v exists.  Reconciling.\", dnsName, endpoints, rrset)\n\t\t\tresolvedEndpoints, err := getResolvedEndpoints(endpoints)\n\t\t\tif err != nil { // Some invalid addresses or otherwise unresolvable DNS names.\n\t\t\t\treturn err // TODO: We could potentially add the ones we did get back, even if some of them failed to resolve."
  },
  {
    "id" : "c62a320c-3c1d-4947-91a4-8d75b9592636",
    "prId" : 26694,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ba22d460-0292-4af5-9ef4-9188ebecb17c",
        "parentId" : null,
        "authorId" : null,
        "body" : "I think we should return an error here, as the record sets are not sync'd?\n",
        "createdAt" : "2016-06-04T00:11:33Z",
        "updatedAt" : "2016-06-06T09:04:40Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "7c86b1aa-2a15-438d-b7c6-4375a0aeca30",
        "parentId" : "ba22d460-0292-4af5-9ef4-9188ebecb17c",
        "authorId" : "ee3c1908-4390-4e95-844f-fb1e0ab18e67",
        "body" : "dns equals nil means the nds provider initialization failed, right? Even I did not setup dnsprovider I can still run the service controller now. If we want to throw error, we should throw it in init phase. The reason I added this line is that with the change, I can still test the service controller without dns provider\n",
        "createdAt" : "2016-06-04T01:10:52Z",
        "updatedAt" : "2016-06-06T09:04:40Z",
        "lastEditedBy" : "ee3c1908-4390-4e95-844f-fb1e0ab18e67",
        "tags" : [
        ]
      },
      {
        "id" : "cb4970ed-2d22-4345-a3a3-0adf52833376",
        "parentId" : "ba22d460-0292-4af5-9ef4-9188ebecb17c",
        "authorId" : null,
        "body" : "I think that your code should not call ensureDnsRecords if the DNS provider is not initialized.  And if it does, ensureDnsRecords should return an error (as it originally did), not nil like this.  But again, I can fix this in a followup PR if you prefer.\n",
        "createdAt" : "2016-06-06T23:33:50Z",
        "updatedAt" : "2016-06-06T23:33:50Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "6dde087f69b2bdd5f9191edbd572985e00f8c808",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +256,260 @@\t//\n\tif s.dns == nil {\n\t\treturn nil\n\t}\n\tif s == nil {"
  },
  {
    "id" : "bfcfe443-b54c-4d0d-ae60-442c5b892cfe",
    "prId" : 26694,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0b802898-ec56-4b33-a43a-bf8276dc94d0",
        "parentId" : null,
        "authorId" : null,
        "body" : "This should not be necessary, as catching err immediately below should cover this.  If not, there's a bug in getClusterZoneNames, as it should not be able to return err == nil, as well as zoneNames = nil.\n",
        "createdAt" : "2016-06-04T00:13:37Z",
        "updatedAt" : "2016-06-06T09:04:40Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "2b0f2a4c-f85b-4b5d-8a92-11f1810fb880",
        "parentId" : "0b802898-ec56-4b33-a43a-bf8276dc94d0",
        "authorId" : "ee3c1908-4390-4e95-844f-fb1e0ab18e67",
        "body" : "When I test service controller with a cluster without zone labels configured, here I got a panic as the zoneNames is nil\n",
        "createdAt" : "2016-06-04T01:12:14Z",
        "updatedAt" : "2016-06-06T09:04:40Z",
        "lastEditedBy" : "ee3c1908-4390-4e95-844f-fb1e0ab18e67",
        "tags" : [
        ]
      },
      {
        "id" : "40f90d95-51ac-4b24-b9e8-a666b039fe74",
        "parentId" : "0b802898-ec56-4b33-a43a-bf8276dc94d0",
        "authorId" : null,
        "body" : "Fair enough.  That's a bug in getClusterZoneNames.  So as not to hold you up, lets merge as is, and I'll fix that in a followup PR.\n",
        "createdAt" : "2016-06-06T23:28:48Z",
        "updatedAt" : "2016-06-06T23:28:48Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "f30d0968-c8cd-477d-9a7c-6fa07ae21720",
        "parentId" : "0b802898-ec56-4b33-a43a-bf8276dc94d0",
        "authorId" : null,
        "body" : "Oh, and either way, the correct approach would be to check err before checking zoneName == nil.  The way the code is now, you will completely discard all errors returned by getClusterZoneNames (because whenever a non-nil error is returned, zoneNames will also be nil.\n",
        "createdAt" : "2016-06-06T23:38:19Z",
        "updatedAt" : "2016-06-06T23:38:19Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "6dde087f69b2bdd5f9191edbd572985e00f8c808",
    "line" : 15,
    "diffHunk" : "@@ -1,1 +268,272 @@\tzoneNames, regionName, err := s.getClusterZoneNames(clusterName)\n\tif zoneNames == nil {\n\t\treturn fmt.Errorf(\"fail to get cluster zone names\")\n\t}\n\tif err != nil {"
  },
  {
    "id" : "9d217327-c376-4cbe-b4a3-ffa41f0973fc",
    "prId" : 25991,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3d074e57-0519-4ce5-b7ad-01e7e8f98778",
        "parentId" : null,
        "authorId" : null,
        "body" : "Note: I'd prefer to fix this in a followup PR.  It needs to come out of federation config, which complicates e2e testing somewhat, and doesn't really impede other integration testing.\n",
        "createdAt" : "2016-05-29T17:13:24Z",
        "updatedAt" : "2016-06-01T23:24:23Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "34a7b6b7-aead-4632-b5b7-e05ba6eccb0f",
        "parentId" : "3d074e57-0519-4ce5-b7ad-01e7e8f98778",
        "authorId" : "f6905dc9-1980-4381-8220-a1c7ad8d5c82",
        "body" : "Ack.\n",
        "createdAt" : "2016-05-31T18:39:44Z",
        "updatedAt" : "2016-06-01T23:24:23Z",
        "lastEditedBy" : "f6905dc9-1980-4381-8220-a1c7ad8d5c82",
        "tags" : [
        ]
      }
    ],
    "commit" : "65e1fecab5dc8a1546207a95ef352e10c3a045d7",
    "line" : 83,
    "diffHunk" : "@@ -1,1 +86,90 @@// getFederationDNSZoneName returns the name of the managed DNS Zone configured for this federation\nfunc (s *ServiceController) getFederationDNSZoneName() (string, error) {\n\treturn \"example.com\", nil // TODO: quinton: Get this from the federation configuration.\n\t// Note: For unit testing this must match the domain populated in the test/stub dnsprovider.\n}"
  },
  {
    "id" : "0403948b-b9d2-4962-a54a-0f19c2b087f2",
    "prId" : 25991,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e3011358-5815-49f1-a958-e3bfba8ffa19",
        "parentId" : null,
        "authorId" : "f6905dc9-1980-4381-8220-a1c7ad8d5c82",
        "body" : "Remove `err` in `err error`. It is not necessary to use a named return. You are not using that feature in your method anyway.\n",
        "createdAt" : "2016-05-31T18:28:15Z",
        "updatedAt" : "2016-06-01T23:24:23Z",
        "lastEditedBy" : "f6905dc9-1980-4381-8220-a1c7ad8d5c82",
        "tags" : [
        ]
      },
      {
        "id" : "e8f0de43-2bef-4d01-8536-488929c5bf3e",
        "parentId" : "e3011358-5815-49f1-a958-e3bfba8ffa19",
        "authorId" : "f6905dc9-1980-4381-8220-a1c7ad8d5c82",
        "body" : "Same for `zoneEndpoints`, `regionEndpoints`, `globalEndpoints` as well.\n",
        "createdAt" : "2016-05-31T18:29:19Z",
        "updatedAt" : "2016-06-01T23:24:23Z",
        "lastEditedBy" : "f6905dc9-1980-4381-8220-a1c7ad8d5c82",
        "tags" : [
        ]
      },
      {
        "id" : "f10a06db-7de2-446e-9eb5-cef5f6a6df3f",
        "parentId" : "e3011358-5815-49f1-a958-e3bfba8ffa19",
        "authorId" : null,
        "body" : "I think I disagree with the last comment.  Naming the first three return values makes it clear what the return value ordering is (as they all have identical types).  Naming for the last (err) parameter is not really useful, but golang insists on it if the other return values are named.\n",
        "createdAt" : "2016-05-31T18:57:23Z",
        "updatedAt" : "2016-06-01T23:24:23Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "63d926cf-525c-42dd-8d3a-97696b769894",
        "parentId" : "e3011358-5815-49f1-a958-e3bfba8ffa19",
        "authorId" : "f6905dc9-1980-4381-8220-a1c7ad8d5c82",
        "body" : "Fair enough.\n\n> Naming for the last (err) parameter is not really useful, but golang insists on it if the other return values are named.\n\nGo does not allow mixing up named and non-named returns.\n",
        "createdAt" : "2016-06-01T05:46:37Z",
        "updatedAt" : "2016-06-01T23:24:23Z",
        "lastEditedBy" : "f6905dc9-1980-4381-8220-a1c7ad8d5c82",
        "tags" : [
        ]
      }
    ],
    "commit" : "65e1fecab5dc8a1546207a95ef352e10c3a045d7",
    "line" : 22,
    "diffHunk" : "@@ -1,1 +31,35 @@\n// getHealthyEndpoints returns the hostnames and/or IP addresses of healthy endpoints for the service, at a zone, region and global level (or an error)\nfunc (s *ServiceController) getHealthyEndpoints(clusterName string, cachedService *cachedService) (zoneEndpoints, regionEndpoints, globalEndpoints []string, err error) {\n\tvar (\n\t\tzoneNames  []string"
  },
  {
    "id" : "90e55658-65b6-4817-876a-b02fb47b3320",
    "prId" : 25991,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "06c98ccf-8e87-4a2c-8842-368c5e76b19e",
        "parentId" : null,
        "authorId" : "f6905dc9-1980-4381-8220-a1c7ad8d5c82",
        "body" : "```\nreturn rrset, nil\n```\n\nThen you can remove `var returnVal dnsprovider.ResourceRecordSet`\n",
        "createdAt" : "2016-06-01T08:15:23Z",
        "updatedAt" : "2016-06-01T23:24:23Z",
        "lastEditedBy" : "f6905dc9-1980-4381-8220-a1c7ad8d5c82",
        "tags" : [
        ]
      },
      {
        "id" : "acb938ad-d7dc-4969-8ea5-1eb1a47970d0",
        "parentId" : "06c98ccf-8e87-4a2c-8842-368c5e76b19e",
        "authorId" : null,
        "body" : "Yes, that makes sense.  I don't know what I was thinking there :-)\n",
        "createdAt" : "2016-06-01T14:22:41Z",
        "updatedAt" : "2016-06-01T23:24:23Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "284d8651-915a-4e31-b89a-5cb6ecdd55e4",
        "parentId" : "06c98ccf-8e87-4a2c-8842-368c5e76b19e",
        "authorId" : null,
        "body" : "Done.\n",
        "createdAt" : "2016-06-01T18:55:18Z",
        "updatedAt" : "2016-06-01T23:24:23Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "65e1fecab5dc8a1546207a95ef352e10c3a045d7",
    "line" : 112,
    "diffHunk" : "@@ -1,1 +115,119 @@\tfor _, rrset := range rrsets {\n\t\tif rrset.Name() == dnsName {\n\t\t\treturnVal = rrset\n\t\t\tbreak\n\t\t}"
  },
  {
    "id" : "5b76acab-3441-4a3a-a94c-3864f3028b7c",
    "prId" : 25991,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "df033430-9152-4d07-954f-95066fd90c89",
        "parentId" : null,
        "authorId" : "f6905dc9-1980-4381-8220-a1c7ad8d5c82",
        "body" : "> Done in a slightly different way than proposed. getRrset returns (nil, nil) if the record set does not exist (as opposed to if there was an error getting the rrset, in which case err != nil).\n> \n> When dnsprovider.ResourceRecordSets is extended to support Get(), we can decide whether to return different types of errors, or adopt the same approach as described above. There are pros and cons to both, but the above approach involves a lot less code now.\n\nWhat are the pros and cons?\n\nHonestly, defining an error var for NotFound is the same amount of code, if not less, as you have now.\n\n``` Go\nvar errNotExist = errors.New(\"entity does not exist\")\n\n...\n\nfunc getRrset(dnsName string, rrsetsInterface dnsprovider.ResourceRecordSets) (dnsprovider.ResourceRecordSet, error) {\n    rrsets, err := rrsetsInterface.List()\n    if err != nil {\n        return nil, err\n    }\n    for _, rrset := range rrsets {\n        if rrset.Name() == dnsName {\n            return rrset, nil\n        }\n    }\n    return nil, errNotExist\n}\n\nfunc (s *ServiceController) ensureDnsRrsets(dnsZoneName, dnsName string, endpoints []string, uplevelCname string) error {\n    ...\n    rrset, err := getRrset(dnsName, rrsets) // TODO: rrsets.Get(dnsName)\n    if err != nil && err != errNotExist {\n        return err\n    } else if err == errNotExist {\n        // Do what needs to be done when rrset doesn't exist\n    } else {\n        // Do what needs to be done when rrset exists.\n    }\n    ...\n}\n```\n\nThe problem with the current approach is that, there is no explicit contract between the caller and the callee. This proposed approach establishes that contract and makes it explicit. As a result the code becomes lot more clear to the reader. This logic is effectively a 3-state switch and should be represented that way for clarity. \n",
        "createdAt" : "2016-06-01T09:18:40Z",
        "updatedAt" : "2016-06-01T23:24:23Z",
        "lastEditedBy" : "f6905dc9-1980-4381-8220-a1c7ad8d5c82",
        "tags" : [
        ]
      },
      {
        "id" : "e9cfecd9-8652-4222-9e5b-1a4b9d126f82",
        "parentId" : "df033430-9152-4d07-954f-95066fd90c89",
        "authorId" : null,
        "body" : "Will do in a followup PR, as discussed offline.\n",
        "createdAt" : "2016-06-01T13:50:33Z",
        "updatedAt" : "2016-06-01T23:24:23Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "65e1fecab5dc8a1546207a95ef352e10c3a045d7",
    "line" : 159,
    "diffHunk" : "@@ -1,1 +161,165 @@\t\treturn err\n\t}\n\tif rrset == nil {\n\t\t// It doesn't exist yet, so create it, if we indeed have healthy endpoints\n\t\tif len(endpoints) < 1 {"
  },
  {
    "id" : "12d6172d-d325-4ae3-a92e-dd6d1dbf4a51",
    "prId" : 25991,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9045cf56-7827-45b8-aeea-b46506e393b7",
        "parentId" : null,
        "authorId" : "f6905dc9-1980-4381-8220-a1c7ad8d5c82",
        "body" : "I forgot to ask in the previous pass. Are we making an assumption that the endpoint IP addresses don't change?\n",
        "createdAt" : "2016-06-01T10:22:58Z",
        "updatedAt" : "2016-06-01T23:24:23Z",
        "lastEditedBy" : "f6905dc9-1980-4381-8220-a1c7ad8d5c82",
        "tags" : [
        ]
      },
      {
        "id" : "fb61f6e4-b804-4283-9af4-943419ec9544",
        "parentId" : "9045cf56-7827-45b8-aeea-b46506e393b7",
        "authorId" : null,
        "body" : "No, these change.  When they do, the watches against the status of the underlying kubernetes services trigger, and this code gets called, which updates the DNS records accordingly.  Make sense?\n",
        "createdAt" : "2016-06-01T13:57:06Z",
        "updatedAt" : "2016-06-01T23:24:23Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "a54d45ef-f2a8-4666-b1cf-62ef480bdf3c",
        "parentId" : "9045cf56-7827-45b8-aeea-b46506e393b7",
        "authorId" : "f6905dc9-1980-4381-8220-a1c7ad8d5c82",
        "body" : "So when the existing endpoints change, the code enters this `else` block right? And within the else block there is some reconciliation done when len(endpoints) < 1. What about the case when it is >= 1? Is that taken care of elsewhere?\n",
        "createdAt" : "2016-06-01T14:16:16Z",
        "updatedAt" : "2016-06-01T23:24:23Z",
        "lastEditedBy" : "f6905dc9-1980-4381-8220-a1c7ad8d5c82",
        "tags" : [
        ]
      },
      {
        "id" : "69beea11-98a2-450e-9d65-f29656ca56c5",
        "parentId" : "9045cf56-7827-45b8-aeea-b46506e393b7",
        "authorId" : null,
        "body" : "Oops!  You are so right.  That case requires an additional else clause, which I accidentally omitted here.  Will fix!\n",
        "createdAt" : "2016-06-01T17:27:35Z",
        "updatedAt" : "2016-06-01T23:24:23Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "5f26a838-2c40-47d4-a505-c71f1cc0800c",
        "parentId" : "9045cf56-7827-45b8-aeea-b46506e393b7",
        "authorId" : null,
        "body" : "Fixed.\n",
        "createdAt" : "2016-06-01T20:18:49Z",
        "updatedAt" : "2016-06-01T23:24:23Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "65e1fecab5dc8a1546207a95ef352e10c3a045d7",
    "line" : 186,
    "diffHunk" : "@@ -1,1 +188,192 @@\t\t}\n\t} else {\n\t\t// the rrset already exists, so make it right.\n\t\tif len(endpoints) < 1 {\n\t\t\t// Need an appropriate CNAME record.  Check that we have it."
  },
  {
    "id" : "9a7c4195-3210-4178-9423-84fb66a60ad3",
    "prId" : 25991,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "29a3d81f-3dce-405c-aad4-64a89f081ab7",
        "parentId" : null,
        "authorId" : "f6905dc9-1980-4381-8220-a1c7ad8d5c82",
        "body" : "Thanks for extracting this into a function!\n",
        "createdAt" : "2016-06-01T22:10:40Z",
        "updatedAt" : "2016-06-01T23:24:23Z",
        "lastEditedBy" : "f6905dc9-1980-4381-8220-a1c7ad8d5c82",
        "tags" : [
        ]
      }
    ],
    "commit" : "65e1fecab5dc8a1546207a95ef352e10c3a045d7",
    "line" : 123,
    "diffHunk" : "@@ -1,1 +126,130 @@   non-nil error is also returned (possibly along with a partially complete list of resolved endpoints.\n*/\nfunc getResolvedEndpoints(endpoints []string) ([]string, error) {\n\tresolvedEndpoints := make([]string, 0, len(endpoints))\n\tfor _, endpoint := range endpoints {"
  },
  {
    "id" : "ed5024dc-91cf-4af4-8928-1bc5c8d8b8b0",
    "prId" : 25991,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a423c64c-2109-4cfe-923a-131e7589aaf6",
        "parentId" : null,
        "authorId" : "f6905dc9-1980-4381-8220-a1c7ad8d5c82",
        "body" : "It looks like this has the same problem that we had during the Ubernetes hackathon. \n\n``` Go\nresolvedEndpoints := make([]string, len(endpoints))\n```\n\nCreates a slice of length len(endpoints). And then you append after that. So effectively you have a slice of `2 * len(endpoints)`\n\nSorry for not catching this earlier. \n",
        "createdAt" : "2016-06-01T22:14:02Z",
        "updatedAt" : "2016-06-01T23:24:23Z",
        "lastEditedBy" : "f6905dc9-1980-4381-8220-a1c7ad8d5c82",
        "tags" : [
        ]
      },
      {
        "id" : "257b5227-c41c-45b6-8b89-7a656bf87ab4",
        "parentId" : "a423c64c-2109-4cfe-923a-131e7589aaf6",
        "authorId" : null,
        "body" : "You are so right!  I must be a slow learner :-)\n",
        "createdAt" : "2016-06-01T23:01:34Z",
        "updatedAt" : "2016-06-01T23:24:23Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "65e1fecab5dc8a1546207a95ef352e10c3a045d7",
    "line" : 133,
    "diffHunk" : "@@ -1,1 +136,140 @@\t\t\t\treturn resolvedEndpoints, err\n\t\t\t}\n\t\t\tresolvedEndpoints = append(resolvedEndpoints, ipAddrs...)\n\n\t\t} else {"
  }
]
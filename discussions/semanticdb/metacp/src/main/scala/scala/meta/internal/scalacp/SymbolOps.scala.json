[
  {
    "id" : "06fa502e-b354-4274-8a8f-337d01fee9c1",
    "prId" : 1674,
    "prUrl" : "https://github.com/scalameta/scalameta/pull/1674#pullrequestreview-134598925",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "46a9a37f-0830-4724-bc82-cedd7f824b79",
        "parentId" : null,
        "authorId" : "bd90d0d4-3cfe-485f-b03d-29764e6b2eae",
        "body" : "Nitpick, when pattern matching on a sealed trait I move guards into the body of the case instead\r\n```scala\r\n// before\r\ncase A if guard1 =>\r\ncase A if guard2 =>\r\ncase A => sys.error\r\n\r\n// after\r\ncase A =>\r\n  if (guard1) ..\r\n  else if (guard2) ..\r\n  else sys.error\r\n```\r\n\r\nI find it both easier to read and you retain exhaustivity checks.",
        "createdAt" : "2018-07-05T10:54:57Z",
        "updatedAt" : "2018-07-05T12:19:58Z",
        "lastEditedBy" : "bd90d0d4-3cfe-485f-b03d-29764e6b2eae",
        "tags" : [
        ]
      }
    ],
    "commit" : "e3c012530b36d03419f3e882d24d6eeb3b34eb75",
    "line" : 77,
    "diffHunk" : "@@ -1,1 +98,102 @@            case PackageLookup => d.Package(name)\n            case JavaLookup => d.Type(name)\n            case ScalaLookup if sym.entry.entryType == 9 => d.Type(name)\n            case ScalaLookup if sym.entry.entryType == 10 => d.Term(name)\n            case ScalaLookup => sys.error(s\"unsupported symbol $sym\")"
  },
  {
    "id" : "5fecdd83-6882-42b2-8628-c0cc639a6e00",
    "prId" : 1580,
    "prUrl" : "https://github.com/scalameta/scalameta/pull/1580#pullrequestreview-126444782",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a4f71294-1e8e-489d-87e2-cbaf2b04408e",
        "parentId" : null,
        "authorId" : "bd90d0d4-3cfe-485f-b03d-29764e6b2eae",
        "body" : "I'm a concerned about producing local symbols from metacp since those can get mixed with local symbols in a text document. For example, scalafix symtab is per-source which means after this PR, it's not clear how to implement `info(\"local1\")` since `local1` may come from a hardlinked symbol from a dependency or from a local variable in the current text document.\r\n\r\nI've wondered if we should adopt a similar scheme as JVM signatures where the first character indicates the type\r\n\r\n* prefix global symbols with `G`\r\n* prefix local symbols with `L`\r\n* prefix hardlink symbols with `H`\r\n\r\nHardlinked symbols could additionally be suffixed by the enclosing owner symbol so that \r\n\r\n```diff\r\n- this PR\r\n+ proposal\r\n\r\nadvanced.Structural#s2(). => method s2: AnyRef { val def x: Int }\r\n  AnyRef => scala.AnyRef#\r\n-  x => local1\r\n+  x => Hadvanced.Structural#s2().1\r\n  Int => scala.Int#\r\n```\r\n\r\nThis would mean hardlinked symbols could remain globally unique. ",
        "createdAt" : "2018-06-06T13:14:16Z",
        "updatedAt" : "2018-06-06T16:26:32Z",
        "lastEditedBy" : "bd90d0d4-3cfe-485f-b03d-29764e6b2eae",
        "tags" : [
        ]
      },
      {
        "id" : "9601ce28-143f-45a4-9db2-e158be6173be",
        "parentId" : "a4f71294-1e8e-489d-87e2-cbaf2b04408e",
        "authorId" : "56d6821a-439f-4d87-aba8-a6368926dbc5",
        "body" : "https://github.com/scalameta/scalameta/issues/1592",
        "createdAt" : "2018-06-06T16:02:20Z",
        "updatedAt" : "2018-06-06T16:26:32Z",
        "lastEditedBy" : "56d6821a-439f-4d87-aba8-a6368926dbc5",
        "tags" : [
        ]
      }
    ],
    "commit" : "3c581e165334c532a8783b351597731da4ed18e8",
    "line" : 234,
    "diffHunk" : "@@ -1,1 +232,236 @@\n  private var nextId = 0\n  private def freshSymbol(): String = {\n    val result = Symbols.Local(nextId)\n    nextId += 1"
  }
]
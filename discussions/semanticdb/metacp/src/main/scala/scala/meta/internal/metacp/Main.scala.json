[
  {
    "id" : "b1385e1e-8adc-454a-9829-44dbafd672c3",
    "prId" : 1670,
    "prUrl" : "https://github.com/scalameta/scalameta/pull/1670#pullrequestreview-134442531",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3a435c8f-9efc-4720-a710-e04442fde59f",
        "parentId" : null,
        "authorId" : "56d6821a-439f-4d87-aba8-a6368926dbc5",
        "body" : "How about renaming this to `missingSymbols`?",
        "createdAt" : "2018-07-04T17:13:34Z",
        "updatedAt" : "2018-07-04T17:21:22Z",
        "lastEditedBy" : "56d6821a-439f-4d87-aba8-a6368926dbc5",
        "tags" : [
        ]
      }
    ],
    "commit" : "e183ff3feb4b555e8bae06f69dfeb80af68e4bbb",
    "line" : 9,
    "diffHunk" : "@@ -1,1 +21,25 @@\n  lazy val classpathIndex = ClasspathIndex(settings.fullClasspath)\n  private val isReportedMissingSymbol = mutable.Set.empty[String]\n\n  def process(): Option[Classpath] = {"
  },
  {
    "id" : "da1b9e72-36fc-4f8c-a9f2-06a236d6d675",
    "prId" : 1570,
    "prUrl" : "https://github.com/scalameta/scalameta/pull/1570#pullrequestreview-124063990",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "48234547-4c36-495f-8dfa-59aa0c0be9b5",
        "parentId" : null,
        "authorId" : "bd90d0d4-3cfe-485f-b03d-29764e6b2eae",
        "body" : "Why doesn't metacp use `Locator`?",
        "createdAt" : "2018-05-29T11:01:54Z",
        "updatedAt" : "2018-05-29T16:05:31Z",
        "lastEditedBy" : "bd90d0d4-3cfe-485f-b03d-29764e6b2eae",
        "tags" : [
        ]
      },
      {
        "id" : "08b76934-5f49-4b74-a99f-29a1daca173e",
        "parentId" : "48234547-4c36-495f-8dfa-59aa0c0be9b5",
        "authorId" : "56d6821a-439f-4d87-aba8-a6368926dbc5",
        "body" : "Metacp is going through .class files, as opposed to .semanticdb files. It also needs additional caching facilities as well as parallel processing, so I figured I wouldn't overabstract.",
        "createdAt" : "2018-05-29T16:08:26Z",
        "updatedAt" : "2018-05-29T16:08:26Z",
        "lastEditedBy" : "56d6821a-439f-4d87-aba8-a6368926dbc5",
        "tags" : [
        ]
      }
    ],
    "commit" : "79de6a1047866355c6ac1b46427e91840afcfc22",
    "line" : 11,
    "diffHunk" : "@@ -1,1 +65,69 @@    }\n\n    classpath.foreach { entry =>\n      if (entry.isDirectory) {\n        val out = AbsolutePath(Files.createTempDirectory(\"semanticdb\"))"
  },
  {
    "id" : "425f9f4f-4040-4136-a3dd-a012faedf2fe",
    "prId" : 1483,
    "prUrl" : "https://github.com/scalameta/scalameta/pull/1483#pullrequestreview-110503799",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e5d3993d-6f75-4223-a9b6-6ab306c8b07f",
        "parentId" : null,
        "authorId" : "56d6821a-439f-4d87-aba8-a6368926dbc5",
        "body" : "Shall we crash instead?",
        "createdAt" : "2018-04-09T15:25:35Z",
        "updatedAt" : "2018-04-09T15:25:38Z",
        "lastEditedBy" : "56d6821a-439f-4d87-aba8-a6368926dbc5",
        "tags" : [
        ]
      },
      {
        "id" : "906cc67a-222b-4ecf-b55c-066bd0687128",
        "parentId" : "e5d3993d-6f75-4223-a9b6-6ab306c8b07f",
        "authorId" : "bd90d0d4-3cfe-485f-b03d-29764e6b2eae",
        "body" : "We have no guarantee on which systems ATOMIC_MOVE is not supported, but I would prefer to run successfully on those systems instead of making it impossible to use metacp. Errors from reading half-complete symbols will still be reported.",
        "createdAt" : "2018-04-09T15:31:11Z",
        "updatedAt" : "2018-04-09T15:31:11Z",
        "lastEditedBy" : "bd90d0d4-3cfe-485f-b03d-29764e6b2eae",
        "tags" : [
        ]
      },
      {
        "id" : "599b4caa-127a-4687-9955-a77cb6545055",
        "parentId" : "e5d3993d-6f75-4223-a9b6-6ab306c8b07f",
        "authorId" : "bd90d0d4-3cfe-485f-b03d-29764e6b2eae",
        "body" : "btw, using `move` even without atomic significantly reduces the chances or reproducing the error compared to the previous behavior where we write directly to the target jar while processing.",
        "createdAt" : "2018-04-09T15:33:30Z",
        "updatedAt" : "2018-04-09T15:33:31Z",
        "lastEditedBy" : "bd90d0d4-3cfe-485f-b03d-29764e6b2eae",
        "tags" : [
        ]
      }
    ],
    "commit" : "ba352a87832f5b371579c48dc5bd78c9c907d2bb",
    "line" : 25,
    "diffHunk" : "@@ -1,1 +46,50 @@        )\n      } catch {\n        case _: AtomicMoveNotSupportedException =>\n          Files.move(\n            tmp,"
  },
  {
    "id" : "19941fa1-4d7f-4454-bd10-9080c01ebcbc",
    "prId" : 1367,
    "prUrl" : "https://github.com/scalameta/scalameta/pull/1367#pullrequestreview-99414593",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a77cebdc-e46b-475a-97c1-112ac2c869b5",
        "parentId" : null,
        "authorId" : "56d6821a-439f-4d87-aba8-a6368926dbc5",
        "body" : "Do we still need sorting? If not, let's go back to having all logic in `visitFile`.",
        "createdAt" : "2018-02-26T17:33:57Z",
        "updatedAt" : "2018-02-26T19:50:09Z",
        "lastEditedBy" : "56d6821a-439f-4d87-aba8-a6368926dbc5",
        "tags" : [
        ]
      },
      {
        "id" : "24799583-65a8-4ba8-b7a6-2a43ed50de4f",
        "parentId" : "a77cebdc-e46b-475a-97c1-112ac2c869b5",
        "authorId" : "bd90d0d4-3cfe-485f-b03d-29764e6b2eae",
        "body" : "We still need sorting in order to ensure we visit `Foo.class` before `Foo$Inner.class`. I propose we keep this unchanged for now.",
        "createdAt" : "2018-02-26T18:34:42Z",
        "updatedAt" : "2018-02-26T19:50:09Z",
        "lastEditedBy" : "bd90d0d4-3cfe-485f-b03d-29764e6b2eae",
        "tags" : [
        ]
      }
    ],
    "commit" : "f88c8927b5cfe762380655296e526691a5f27a47",
    "line" : 42,
    "diffHunk" : "@@ -1,1 +130,134 @@              !isVisited(f) &&\n              Files.isRegularFile(f)\n            }\n            .foreach(handleFile)\n          FileVisitResult.CONTINUE"
  },
  {
    "id" : "212f2716-583a-47fb-8d9f-9ccdca92fe92",
    "prId" : 1363,
    "prUrl" : "https://github.com/scalameta/scalameta/pull/1363#pullrequestreview-99475434",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "66242d67-9667-4c1d-a290-901962b59a8c",
        "parentId" : null,
        "authorId" : "bd90d0d4-3cfe-485f-b03d-29764e6b2eae",
        "body" : "What do you think about synthesizing these on the fly at runtime instead of re-generating scala/Any.class and friends for every entry in each classpath?",
        "createdAt" : "2018-02-26T11:46:54Z",
        "updatedAt" : "2018-02-26T12:01:16Z",
        "lastEditedBy" : "bd90d0d4-3cfe-485f-b03d-29764e6b2eae",
        "tags" : [
        ]
      },
      {
        "id" : "c5d17565-98eb-4911-911b-a15c23dd831f",
        "parentId" : "66242d67-9667-4c1d-a290-901962b59a8c",
        "authorId" : "56d6821a-439f-4d87-aba8-a6368926dbc5",
        "body" : "Let's continue the discussion at https://github.com/scalameta/scalameta/issues/1368.",
        "createdAt" : "2018-02-26T21:32:37Z",
        "updatedAt" : "2018-02-26T21:32:37Z",
        "lastEditedBy" : "56d6821a-439f-4d87-aba8-a6368926dbc5",
        "tags" : [
        ]
      }
    ],
    "commit" : "37bdfffae3069ae6dfb60f98e0fba3879587aa53",
    "line" : 61,
    "diffHunk" : "@@ -1,1 +146,150 @@    }\n    locally {\n      def synthesizeBuiltin(name: String): s.SymbolInformation = {\n        val parent = s.TypeRef(None, \"_root_.scala.Any#\", Nil)\n        val tpe = s.ClassInfoType(Nil, List(s.Type(tag = t.TYPE_REF, typeRef = Some(parent))), Nil)"
  },
  {
    "id" : "d6600ac3-049f-450a-bce3-69efc9bd0650",
    "prId" : 1363,
    "prUrl" : "https://github.com/scalameta/scalameta/pull/1363#pullrequestreview-99604706",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "cb894ab1-64d6-4506-819f-39d634852731",
        "parentId" : null,
        "authorId" : "bd90d0d4-3cfe-485f-b03d-29764e6b2eae",
        "body" : "Looks like the logic inside this try body can be extracted into a method. I like it best when the try body is as small as possible `try process(foo) catch ...`",
        "createdAt" : "2018-02-26T11:48:08Z",
        "updatedAt" : "2018-02-26T12:01:16Z",
        "lastEditedBy" : "bd90d0d4-3cfe-485f-b03d-29764e6b2eae",
        "tags" : [
        ]
      },
      {
        "id" : "f4ef1ee5-ea1a-48da-8e23-c08dc5da9cbf",
        "parentId" : "cb894ab1-64d6-4506-819f-39d634852731",
        "authorId" : "56d6821a-439f-4d87-aba8-a6368926dbc5",
        "body" : "Could you elaborate on the reasons? Is this a purely stylistic preference, or this also influences IDE support and/or runtime performance?",
        "createdAt" : "2018-02-26T22:02:51Z",
        "updatedAt" : "2018-02-26T22:02:51Z",
        "lastEditedBy" : "56d6821a-439f-4d87-aba8-a6368926dbc5",
        "tags" : [
        ]
      },
      {
        "id" : "5d58df29-d1a0-422d-8223-0fd0b4cd0508",
        "parentId" : "cb894ab1-64d6-4506-819f-39d634852731",
        "authorId" : "bd90d0d4-3cfe-485f-b03d-29764e6b2eae",
        "body" : "Stylistic reasons, I get uneasy with massive try/catch blocks",
        "createdAt" : "2018-02-27T09:13:32Z",
        "updatedAt" : "2018-02-27T09:13:33Z",
        "lastEditedBy" : "bd90d0d4-3cfe-485f-b03d-29764e6b2eae",
        "tags" : [
        ]
      }
    ],
    "commit" : "37bdfffae3069ae6dfb60f98e0fba3879587aa53",
    "line" : 140,
    "diffHunk" : "@@ -1,1 +528,532 @@\n    try {\n      if (sym.isAlias) {\n        def preprocess(info: Type): Type = {\n          info match {"
  },
  {
    "id" : "bae80b22-b910-45d0-90b9-07f2c2638cb9",
    "prId" : 1363,
    "prUrl" : "https://github.com/scalameta/scalameta/pull/1363#pullrequestreview-99266253",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b8a4e02c-38e4-4793-beb7-eb474464ebda",
        "parentId" : null,
        "authorId" : "bd90d0d4-3cfe-485f-b03d-29764e6b2eae",
        "body" : "Opened https://github.com/scalameta/scalameta/issues/1364 to track this.",
        "createdAt" : "2018-02-26T12:00:17Z",
        "updatedAt" : "2018-02-26T12:01:16Z",
        "lastEditedBy" : "bd90d0d4-3cfe-485f-b03d-29764e6b2eae",
        "tags" : [
        ]
      }
    ],
    "commit" : "37bdfffae3069ae6dfb60f98e0fba3879587aa53",
    "line" : 75,
    "diffHunk" : "@@ -1,1 +160,164 @@      def synthesizeAny(): List[s.SymbolInformation] = {\n        val decls = {\n          // TODO: Implement me.\n          // lazy val Any_==       = enterNewMethod(AnyClass, nme.EQ, AnyTpe :: Nil, BooleanTpe, FINAL)\n          // lazy val Any_!=       = enterNewMethod(AnyClass, nme.NE, AnyTpe :: Nil, BooleanTpe, FINAL)"
  },
  {
    "id" : "37fe7e8a-e17b-4205-91bd-87f216ec59ca",
    "prId" : 1326,
    "prUrl" : "https://github.com/scalameta/scalameta/pull/1326#pullrequestreview-97378346",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "921bb884-dc1f-46e5-89a8-3b8ed4f1b1c2",
        "parentId" : null,
        "authorId" : "bd90d0d4-3cfe-485f-b03d-29764e6b2eae",
        "body" : "Can we give magic variables names and store them in some object?",
        "createdAt" : "2018-02-17T10:20:13Z",
        "updatedAt" : "2018-02-17T13:07:45Z",
        "lastEditedBy" : "bd90d0d4-3cfe-485f-b03d-29764e6b2eae",
        "tags" : [
        ]
      },
      {
        "id" : "d52796e7-61b1-4549-a597-cfe72a88066e",
        "parentId" : "921bb884-dc1f-46e5-89a8-3b8ed4f1b1c2",
        "authorId" : "56d6821a-439f-4d87-aba8-a6368926dbc5",
        "body" : "Let's do this next time when we fork scalap / get rid of scalap. (We'll have to, because scalap doesn't support some language features).",
        "createdAt" : "2018-02-17T16:20:35Z",
        "updatedAt" : "2018-02-17T16:20:35Z",
        "lastEditedBy" : "56d6821a-439f-4d87-aba8-a6368926dbc5",
        "tags" : [
        ]
      }
    ],
    "commit" : "098e876247bdeb8c5b579978b237091752344f2d",
    "line" : 40,
    "diffHunk" : "@@ -1,1 +152,156 @@          if (sym.isAccessor && sym.name.endsWith(\"_$eq\")) k.SETTER\n          else if (sym.isAccessor) k.GETTER\n          else if (sym.hasFlag(0x00008000)) k.MACRO\n          else k.DEF\n        }"
  },
  {
    "id" : "e1c70c88-82b1-40d7-b1d8-4cdfe35ac7cb",
    "prId" : 1323,
    "prUrl" : "https://github.com/scalameta/scalameta/pull/1323#pullrequestreview-97258934",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fa26a5c0-2908-47f4-9411-30e786d63699",
        "parentId" : null,
        "authorId" : "bd90d0d4-3cfe-485f-b03d-29764e6b2eae",
        "body" : "Do we have any ordering guarantees on `Symbol.children`? What is the chance that `+1` and `+2` get mixed up?",
        "createdAt" : "2018-02-16T10:31:21Z",
        "updatedAt" : "2018-02-16T18:06:43Z",
        "lastEditedBy" : "bd90d0d4-3cfe-485f-b03d-29764e6b2eae",
        "tags" : [
        ]
      },
      {
        "id" : "5382b071-233d-45d0-834b-36cbcc10e157",
        "parentId" : "fa26a5c0-2908-47f4-9411-30e786d63699",
        "authorId" : "56d6821a-439f-4d87-aba8-a6368926dbc5",
        "body" : "To the best of my knowledge, pickling preserves the order of symbols in scopes. Scalac namer enters symbols in the order of their appearance in source code. Also see https://github.com/retronym/scalac-stability/issues/1.",
        "createdAt" : "2018-02-16T17:38:17Z",
        "updatedAt" : "2018-02-16T18:06:43Z",
        "lastEditedBy" : "56d6821a-439f-4d87-aba8-a6368926dbc5",
        "tags" : [
        ]
      }
    ],
    "commit" : "808c93b6dbfc05c054223b4278b4fb325e60c102",
    "line" : 161,
    "diffHunk" : "@@ -1,1 +439,443 @@      val kindred = sym.parent.get.children.filter(other => skind(other) == skind(sym))\n      val siblings = kindred.filter(_.name == sym.name)\n      val synonyms = siblings.filter(_.descriptor == sym.descriptor)\n      val suffix = {\n        if (synonyms.length == 1) \"\""
  },
  {
    "id" : "4fe6e893-3615-4872-873c-7224dfe1401c",
    "prId" : 1316,
    "prUrl" : "https://github.com/scalameta/scalameta/pull/1316#pullrequestreview-96792275",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e19f7a47-3650-4a06-9e88-25979b9519d3",
        "parentId" : null,
        "authorId" : "bd90d0d4-3cfe-485f-b03d-29764e6b2eae",
        "body" : "😭 seems we'll need to roll our own solution sooner or later",
        "createdAt" : "2018-02-15T10:12:59Z",
        "updatedAt" : "2018-02-15T19:38:58Z",
        "lastEditedBy" : "bd90d0d4-3cfe-485f-b03d-29764e6b2eae",
        "tags" : [
        ]
      }
    ],
    "commit" : "e38f5f1d7e7e09abb297f26cdb09e0a5e7d354a1",
    "line" : 355,
    "diffHunk" : "@@ -1,1 +403,407 @@\n  def sanns(sym: SymbolInfoSymbol): List[s.Annotation] = {\n    // TODO: Not supported by scalap.\n    Nil\n  }"
  },
  {
    "id" : "87669d46-5eff-421d-80d1-62b02c7b2217",
    "prId" : 1314,
    "prUrl" : "https://github.com/scalameta/scalameta/pull/1314#pullrequestreview-96596336",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "32fb25c3-f6c0-4bc4-b31e-a52fe32d973b",
        "parentId" : null,
        "authorId" : "56d6821a-439f-4d87-aba8-a6368926dbc5",
        "body" : "The prefix must be non-empty here as per the updated spec, but I'll take care of that myself when working on implementing the spec.",
        "createdAt" : "2018-02-14T17:55:00Z",
        "updatedAt" : "2018-02-14T17:55:04Z",
        "lastEditedBy" : "56d6821a-439f-4d87-aba8-a6368926dbc5",
        "tags" : [
        ]
      }
    ],
    "commit" : "2885ea2ac65917d7daa08730db7632fe5b750020",
    "line" : 10,
    "diffHunk" : "@@ -1,1 +256,260 @@            val sargs = sarg :: Nil\n            s.Type(tag = stag, typeRef = Some(s.TypeRef(None, ssym, sargs)))\n          }\n        case ConstantType(const) =>\n          def floatBits(x: Float) = java.lang.Float.floatToRawIntBits(x).toLong"
  },
  {
    "id" : "9f2138c8-41eb-4301-b324-80532ef8c86b",
    "prId" : 1304,
    "prUrl" : "https://github.com/scalameta/scalameta/pull/1304#pullrequestreview-96476109",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "be8d5b17-e4f5-4f96-be35-b01b75f5d507",
        "parentId" : null,
        "authorId" : "56d6821a-439f-4d87-aba8-a6368926dbc5",
        "body" : "When can this happen?",
        "createdAt" : "2018-02-14T02:15:36Z",
        "updatedAt" : "2018-02-14T13:45:53Z",
        "lastEditedBy" : "56d6821a-439f-4d87-aba8-a6368926dbc5",
        "tags" : [
        ]
      },
      {
        "id" : "1ac49fa8-9d70-4bb8-a267-9b365fec2f53",
        "parentId" : "be8d5b17-e4f5-4f96-be35-b01b75f5d507",
        "authorId" : "bd90d0d4-3cfe-485f-b03d-29764e6b2eae",
        "body" : "This was the most frequent error, you can uncomment the line and run metacp suite to investigate.",
        "createdAt" : "2018-02-14T12:16:50Z",
        "updatedAt" : "2018-02-14T13:45:53Z",
        "lastEditedBy" : "bd90d0d4-3cfe-485f-b03d-29764e6b2eae",
        "tags" : [
        ]
      }
    ],
    "commit" : "a0733f371e336cbe4d6533dd70b9ab034bd81f30",
    "line" : 33,
    "diffHunk" : "@@ -1,1 +70,74 @@\n  private def sinfo(sym: SymbolInfoSymbol): Option[s.SymbolInformation] = {\n    if (sym.parent.get == NoSymbol) return None\n    if (sym.isSynthetic) return None\n    if (sym.isModuleClass) return None"
  },
  {
    "id" : "08ad42f1-bddd-418a-9f9a-50b50dc71c98",
    "prId" : 1304,
    "prUrl" : "https://github.com/scalameta/scalameta/pull/1304#pullrequestreview-96476109",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "68412d6f-adbc-4dbe-9f79-9d04228832fa",
        "parentId" : null,
        "authorId" : "56d6821a-439f-4d87-aba8-a6368926dbc5",
        "body" : "Do you happen to have a reproduction?",
        "createdAt" : "2018-02-14T02:16:08Z",
        "updatedAt" : "2018-02-14T13:45:53Z",
        "lastEditedBy" : "56d6821a-439f-4d87-aba8-a6368926dbc5",
        "tags" : [
        ]
      },
      {
        "id" : "7455f1b3-1e69-4e51-8253-261e0218b111",
        "parentId" : "68412d6f-adbc-4dbe-9f79-9d04228832fa",
        "authorId" : "bd90d0d4-3cfe-485f-b03d-29764e6b2eae",
        "body" : "scala-library and scalameta jars reproduce it 100s of times, but I don't have a minimal reproduction. `scala.matching` was one case I remember. Once we have these tests + diff tests against metac we'll have plenty of opportunity to extract minimal reproductions. For now I think it's most important that new changes to metacp are tested against a large input to prevent further blatant crashes.",
        "createdAt" : "2018-02-14T12:15:34Z",
        "updatedAt" : "2018-02-14T13:45:53Z",
        "lastEditedBy" : "bd90d0d4-3cfe-485f-b03d-29764e6b2eae",
        "tags" : [
        ]
      }
    ],
    "commit" : "a0733f371e336cbe4d6533dd70b9ab034bd81f30",
    "line" : 49,
    "diffHunk" : "@@ -1,1 +176,180 @@            nameEntryType == 1\n          } else {\n            false\n          }\n        }"
  }
]
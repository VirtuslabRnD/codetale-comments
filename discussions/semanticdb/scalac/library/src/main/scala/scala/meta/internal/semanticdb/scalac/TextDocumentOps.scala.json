[
  {
    "id" : "09b35d0d-acd7-4ae9-9a42-9ab38299a080",
    "prId" : 2019,
    "prUrl" : "https://github.com/scalameta/scalameta/pull/2019#pullrequestreview-391423523",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "210688a9-24d4-4757-a064-ac5d89795ea6",
        "parentId" : null,
        "authorId" : "bd90d0d4-3cfe-485f-b03d-29764e6b2eae",
        "body" : "That was a small change! Nice catch",
        "createdAt" : "2020-04-10T12:45:40Z",
        "updatedAt" : "2020-04-10T12:45:45Z",
        "lastEditedBy" : "bd90d0d4-3cfe-485f-b03d-29764e6b2eae",
        "tags" : [
        ]
      }
    ],
    "commit" : "2d25cd2ed202cd4f2898a55b2b9fe3ea42a24e8f",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +633,637 @@              case SelectOf(original) =>\n                traverse(original)\n              case g.Function(params, body) if params.forall { param =>\n                    param.symbol.isSynthetic ||\n                    param.name.decoded.startsWith(\"x$\")"
  },
  {
    "id" : "eee8ada6-1601-4a16-a43d-9fe260c7d29a",
    "prId" : 1919,
    "prUrl" : "https://github.com/scalameta/scalameta/pull/1919#pullrequestreview-329859709",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ece52f8c-0302-48e8-8908-f654c1d61a5f",
        "parentId" : null,
        "authorId" : "e26c6789-3ff6-4411-9f32-f6ffcf911775",
        "body" : "isn't this a reworked `loop` function from below? You can remove it below if it's not needed.",
        "createdAt" : "2019-12-10T11:47:47Z",
        "updatedAt" : "2019-12-11T12:59:09Z",
        "lastEditedBy" : "e26c6789-3ff6-4411-9f32-f6ffcf911775",
        "tags" : [
        ]
      },
      {
        "id" : "ec5a5b44-4e7e-4cbe-bad5-4ff3a0e9caef",
        "parentId" : "ece52f8c-0302-48e8-8908-f654c1d61a5f",
        "authorId" : "e67eb550-454b-41a5-933d-875db3716c1c",
        "body" : "Removed.",
        "createdAt" : "2019-12-10T14:09:03Z",
        "updatedAt" : "2019-12-11T12:59:09Z",
        "lastEditedBy" : "e67eb550-454b-41a5-933d-875db3716c1c",
        "tags" : [
        ]
      }
    ],
    "commit" : "18567bb34ae5f9b318b454154fa81dd0c9c671a6",
    "line" : 15,
    "diffHunk" : "@@ -1,1 +90,94 @@            mends(mend1) = mname\n          }\n          private def indexArgNames(mapp: m.Tree): Unit = {\n            mapp match {\n              case m.Term.Apply(fun, args) =>"
  },
  {
    "id" : "e2854157-4677-43b9-9f8d-b532dda703bf",
    "prId" : 1822,
    "prUrl" : "https://github.com/scalameta/scalameta/pull/1822#pullrequestreview-197757896",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ba2a6a0a-6d3b-4959-a323-8373a0a19238",
        "parentId" : null,
        "authorId" : "56d6821a-439f-4d87-aba8-a6368926dbc5",
        "body" : "I'm already scared, and it's just the beginning of the diff :)",
        "createdAt" : "2019-01-29T20:08:42Z",
        "updatedAt" : "2019-01-30T08:06:17Z",
        "lastEditedBy" : "56d6821a-439f-4d87-aba8-a6368926dbc5",
        "tags" : [
        ]
      }
    ],
    "commit" : "80f7ad644ac37d3f71706bf89fdbae41694fbd0a",
    "line" : 17,
    "diffHunk" : "@@ -1,1 +68,72 @@      val mpatoccurrences = mutable.Map[m.Position, String]()\n      val mvalpatstart = mutable.Set.empty[Int] // start pos for Pat.Var names inside val patterns\n      val msinglevalpats = mutable.Map.empty[Int, m.Position] // start pos for vals with patterns -> last Pat.Var name\n\n      locally {"
  },
  {
    "id" : "67a00ead-13b0-4471-b74f-9950eba8e732",
    "prId" : 1822,
    "prUrl" : "https://github.com/scalameta/scalameta/pull/1822#pullrequestreview-197766079",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5c26e9e0-71de-40c9-a9c7-20c264967c0d",
        "parentId" : null,
        "authorId" : "56d6821a-439f-4d87-aba8-a6368926dbc5",
        "body" : "This reads like black magic, but that's because the entire TextDocumentOps is black magic. I'm extremely happy that we have a great test suite, because otherwise I don't see how we could be 100% sure that these changes do the right thing in all cases. Special thanks for finding the right incantation to fix the bug without breaking everything else.",
        "createdAt" : "2019-01-29T20:10:45Z",
        "updatedAt" : "2019-01-30T08:06:17Z",
        "lastEditedBy" : "56d6821a-439f-4d87-aba8-a6368926dbc5",
        "tags" : [
        ]
      },
      {
        "id" : "a42ea257-4730-41b0-a6d9-15295128f78a",
        "parentId" : "5c26e9e0-71de-40c9-a9c7-20c264967c0d",
        "authorId" : "bd90d0d4-3cfe-485f-b03d-29764e6b2eae",
        "body" : "The val pattern fix took was may 80% of the work for this PR! It took me 3 iterations to reach the design here. I couldn't find a way to handle the fix in a sane way without introducing `mpatoccurrences` that uses \"last wins\" instead of \"first wins\".",
        "createdAt" : "2019-01-29T20:24:44Z",
        "updatedAt" : "2019-01-30T08:06:17Z",
        "lastEditedBy" : "bd90d0d4-3cfe-485f-b03d-29764e6b2eae",
        "tags" : [
        ]
      }
    ],
    "commit" : "80f7ad644ac37d3f71706bf89fdbae41694fbd0a",
    "line" : 251,
    "diffHunk" : "@@ -1,1 +658,662 @@          s.SymbolOccurrence(Some(pos.toRange), flatSym, role)\n        }\n      }.toList\n\n      val diagnostics = unit.reportedDiagnostics(mstarts)"
  },
  {
    "id" : "646c3dd9-3527-43e9-bc5d-2b5e6a374357",
    "prId" : 1758,
    "prUrl" : "https://github.com/scalameta/scalameta/pull/1758#pullrequestreview-150452380",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "baf7eb15-09ed-4fef-887e-a81875e4dcb6",
        "parentId" : null,
        "authorId" : "bd90d0d4-3cfe-485f-b03d-29764e6b2eae",
        "body" : "Impressive you tracked this down 😍 ",
        "createdAt" : "2018-08-29T08:25:59Z",
        "updatedAt" : "2018-08-29T08:26:02Z",
        "lastEditedBy" : "bd90d0d4-3cfe-485f-b03d-29764e6b2eae",
        "tags" : [
        ]
      }
    ],
    "commit" : "5ba921fb71529ee624ca0539b9e0a509635ae618",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +461,465 @@                  gimpl.fun match {\n                    case gview: g.ApplyImplicitView =>\n                      isVisitedParent += gview\n                      val range = gtree.pos.toMeta.toRange\n                      synthetics += s.Synthetic("
  },
  {
    "id" : "af183d19-6d34-4171-be6b-a5e045dfc421",
    "prId" : 1709,
    "prUrl" : "https://github.com/scalameta/scalameta/pull/1709#pullrequestreview-139207555",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b0e56777-fa32-4514-82ee-c8ff45ce1d31",
        "parentId" : null,
        "authorId" : "56d6821a-439f-4d87-aba8-a6368926dbc5",
        "body" : "This looks plausible as far as my mental debugging goes. I can't guarantee that this is 100% correct, since the for loop desugaring in Scalac is way too involved, but we have tests for that.",
        "createdAt" : "2018-07-20T14:50:19Z",
        "updatedAt" : "2018-07-20T19:33:36Z",
        "lastEditedBy" : "56d6821a-439f-4d87-aba8-a6368926dbc5",
        "tags" : [
        ]
      },
      {
        "id" : "a2e1af12-31c2-4b07-a596-9110ad99073e",
        "parentId" : "b0e56777-fa32-4514-82ee-c8ff45ce1d31",
        "authorId" : "568faf75-3ec5-4518-8906-8fc1bb15b893",
        "body" : "It is not correct with `=` statements, but I decided that this was out of scope as it was not tested in current tests. For example:\r\n\r\n```scala\r\nfor {\r\n  x <- 1 to 10\r\n  y = x\r\n} yield x + y\r\n```\r\n\r\nThe following is produced:\r\n```scala\r\nfor (x <- 1 to 10; y = x) yield x + y =>\r\norig(1 to 10)\r\n.map[Tuple2[Int, Int], IndexedSeq[Tuple2[Int, Int]]]({ (x) =>\r\n    orig(y = x)\r\n})(canBuildFrom[Tuple2[Int, Int]])\r\n.map[Int, IndexedSeq[Int]]({ (local10) =>\r\n    orig(x + y)\r\n})(canBuildFrom[Int])\r\n```\r\n\r\nWhich is not terrible, but is different from expected:\r\n\r\n```scala\r\norig(1 to 10)\r\n.map[(Int, Int), scala.collection.immutable.IndexedSeq[(Int, Int)]](\r\n    ((x: Int) => {\r\n    val y = x;\r\n    scala.Tuple2.apply[Int, Int](x, y)\r\n    }))(scala.collection.immutable.IndexedSeq.canBuildFrom[(Int, Int)])\r\n.map[Int, Any](((x$1: (Int, Int)) =>\r\n    (x$1: @scala.unchecked) match {\r\n    case scala.Tuple2((x @ _), (y @ _)) => orig(x + y)\r\n    }))(scala.collection.immutable.IndexedSeq.canBuildFrom[Int])\r\n```\r\nAlthough to fully support this, we'd need to add a match ADT node or something to the synthetics tree..",
        "createdAt" : "2018-07-20T18:56:59Z",
        "updatedAt" : "2018-07-20T19:33:36Z",
        "lastEditedBy" : "568faf75-3ec5-4518-8906-8fc1bb15b893",
        "tags" : [
        ]
      },
      {
        "id" : "1cb093a1-0843-4c0e-8c8b-abe37f90a3be",
        "parentId" : "b0e56777-fa32-4514-82ee-c8ff45ce1d31",
        "authorId" : "56d6821a-439f-4d87-aba8-a6368926dbc5",
        "body" : "Please submit a ticket.",
        "createdAt" : "2018-07-20T19:17:29Z",
        "updatedAt" : "2018-07-20T19:33:36Z",
        "lastEditedBy" : "56d6821a-439f-4d87-aba8-a6368926dbc5",
        "tags" : [
        ]
      },
      {
        "id" : "3e91caa7-041b-49ed-a4a0-2d96683b47c0",
        "parentId" : "b0e56777-fa32-4514-82ee-c8ff45ce1d31",
        "authorId" : "568faf75-3ec5-4518-8906-8fc1bb15b893",
        "body" : "Created #1711",
        "createdAt" : "2018-07-20T20:52:45Z",
        "updatedAt" : "2018-07-20T20:52:45Z",
        "lastEditedBy" : "568faf75-3ec5-4518-8906-8fc1bb15b893",
        "tags" : [
        ]
      }
    ],
    "commit" : "83490885e2b7a475f3c13b29f0d0b094fbeb135a",
    "line" : 235,
    "diffHunk" : "@@ -1,1 +540,544 @@                case _ =>\n                // do nothing\n              }\n            }\n          }"
  },
  {
    "id" : "e1f43364-d16b-400b-a711-21cfdb5c2934",
    "prId" : 1641,
    "prUrl" : "https://github.com/scalameta/scalameta/pull/1641#pullrequestreview-133520705",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "504e393e-5655-4aac-b0ee-f567da47f5fd",
        "parentId" : null,
        "authorId" : "56d6821a-439f-4d87-aba8-a6368926dbc5",
        "body" : "If this method is used only once, let's inline it? That'll reduce the conceptual surface of SymbolOps and further highlight domain-specificity of this logic.",
        "createdAt" : "2018-07-02T02:52:34Z",
        "updatedAt" : "2018-07-02T09:26:35Z",
        "lastEditedBy" : "56d6821a-439f-4d87-aba8-a6368926dbc5",
        "tags" : [
        ]
      },
      {
        "id" : "00584386-9025-4351-acad-12c2a0d6e6e2",
        "parentId" : "504e393e-5655-4aac-b0ee-f567da47f5fd",
        "authorId" : "bd90d0d4-3cfe-485f-b03d-29764e6b2eae",
        "body" : "I made it a method since I found it helpful to have all the symbol filtering logic in one place instead of sprinkled all over like it used to be before your refactoring. For example, if we find another similar \"java inner modules are useless\" case then we update it in `def isUseless` and immediately question ourselves if that case is also a useless occurrence instead of waiting for unit tests to fail.",
        "createdAt" : "2018-07-02T07:53:52Z",
        "updatedAt" : "2018-07-02T09:26:35Z",
        "lastEditedBy" : "bd90d0d4-3cfe-485f-b03d-29764e6b2eae",
        "tags" : [
        ]
      }
    ],
    "commit" : "c4a27c360098279cf8cb20062b3532047568c613",
    "line" : 24,
    "diffHunk" : "@@ -1,1 +169,173 @@              // Instead of crashing with \"unsupported file\", we ignore these cases.\n              if (gsym0 == null) return\n              if (gsym0.isUselessOccurrence) return\n              if (mtree.pos == m.Position.None) return\n              if (occurrences.contains(mtree.pos)) return"
  }
]
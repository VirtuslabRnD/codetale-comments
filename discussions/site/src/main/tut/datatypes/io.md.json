[
  {
    "id" : "d780c97a-1eee-4d93-875b-3f5717ca9da8",
    "prId" : 338,
    "prUrl" : "https://github.com/typelevel/cats-effect/pull/338#pullrequestreview-151613111",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8afad7bb-67a3-446b-a957-983bce1b3c4f",
        "parentId" : null,
        "authorId" : "a680c99b-0d47-47f6-a175-cad1562111ac",
        "body" : "@alexandru I'm not sure if I understand difference between \"async boundary\" and \"light async boundary\" because IIRC it's not described anywhere.\r\n\r\nPlease clarify:\r\n- \"async boundary\" (which includes `IO.shift`) will go back to the scheduler and try doing logical fork\r\n- \"light async boundary\" (like `IO.cancelBoundary`) will also go back to the scheduler(?) and try to execute on the same logical thread as earlier. So if there are no other tasks to execute it will just check cancelation token and keep going?",
        "createdAt" : "2018-09-01T11:26:41Z",
        "updatedAt" : "2018-09-01T11:26:41Z",
        "lastEditedBy" : "a680c99b-0d47-47f6-a175-cad1562111ac",
        "tags" : [
        ]
      },
      {
        "id" : "7b05d165-5cd7-4c7d-9fdf-42042c1c729f",
        "parentId" : "8afad7bb-67a3-446b-a957-983bce1b3c4f",
        "authorId" : "efc45bfc-463c-4c9e-946d-ad472fabc9f0",
        "body" : "\"Light async boundary\" means that no thread forking will happen (or no `setImmediate` / `setTimeout` on JavaScript), but still has some of the benefits ...\r\n\r\n- can prevent stack overflow errors in some cases or in case of bugs, like we had in #316\r\n- introduces a \"cancel boundary\", which now works with `shift` too, but with `cancelBoundary` you avoid the fork\r\n\r\nI'm not sure if we should introduce this term to people. \"_Light async boundary_\" is something I made up in comments in Monix's source code to signal the usage of a \"trampolined\" `Runnable`, which are needed in async tasks in order to avoid stack overflow errors. But it's not something that necessarily makes sense to people.\r\n\r\n> \"light async boundary\" (like IO.cancelBoundary) will also go back to the scheduler(?) and try to execute on the same logical thread as earlier. So if there are no other tasks to execute it will just check cancelation token and keep going?\r\n\r\nIn Monix the \"light async boundaries\" are managed by the `Scheduler` implementation, however in Cats-Effect's `IO` we have an internal, global trampolined EC, in `internals.TrampolineEC.immediate`. You obviously cannot mention it in the docs.\r\n\r\nBut yes, execution is immediate, it's just that it is via our own trampoline instead of deferring to the thread-pool or to the underlying environment on JavaScript.\r\n\r\nCheckout the implementation of `TrampolineEC` if you want clarity. It's basically a trick also used in Rx.NET or in Scala's `Future`.",
        "createdAt" : "2018-09-02T08:23:14Z",
        "updatedAt" : "2018-09-02T08:24:04Z",
        "lastEditedBy" : "efc45bfc-463c-4c9e-946d-ad472fabc9f0",
        "tags" : [
        ]
      }
    ],
    "commit" : "c82bf79c7792c96dfc7d7b5da5975999a7eb355d",
    "line" : 60,
    "diffHunk" : "@@ -1,1 +694,698 @@#### Comparison to IO.shift\n\n`IO.cancelBoundary` is essentially lighter version of `IO.shift` without \nability to shift into different thread pool. It is lighter in the sense that\nit will avoid doing logical fork."
  },
  {
    "id" : "d448cb3d-acf6-4c78-a9be-d43a44e44c53",
    "prId" : 153,
    "prUrl" : "https://github.com/typelevel/cats-effect/pull/153#pullrequestreview-104492648",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5dddb3fa-c90d-4271-a069-24c2086989c2",
        "parentId" : null,
        "authorId" : "f03705f3-792d-4b36-bfdf-380cd6f2af9a",
        "body" : "I will ping @rossabaker since we have a disagreement over this point. I agree with you.",
        "createdAt" : "2018-03-15T17:24:21Z",
        "updatedAt" : "2018-03-16T11:08:28Z",
        "lastEditedBy" : "f03705f3-792d-4b36-bfdf-380cd6f2af9a",
        "tags" : [
        ]
      },
      {
        "id" : "1449084c-36d5-49e5-a170-2e2d078989ff",
        "parentId" : "5dddb3fa-c90d-4271-a069-24c2086989c2",
        "authorId" : "efc45bfc-463c-4c9e-946d-ad472fabc9f0",
        "body" : "That best practice was actually added by @gvolpe.\r\n\r\nI think it's a good best practice because you also have the same issue with big functions in general â€” it's better to split them for reusability to happen. \r\n\r\nBut like all best practices, there are instances where splitting a big function into smaller ones does nothing but to create noise â€” if the split for example uses the same *shared state*, then the smaller functions aren't really reusable. So for a split to be useful, it sometimes needs to be accompanied by more expensive refactoring, an expense that can't necessarily be justified, when we've got deadlines to meet, etc.\r\n\r\nSo I can agree that there are cases where a big `IO` task should simply be left as is, I'm flexible in that regard ðŸ™‚",
        "createdAt" : "2018-03-16T09:03:17Z",
        "updatedAt" : "2018-03-16T11:08:28Z",
        "lastEditedBy" : "efc45bfc-463c-4c9e-946d-ad472fabc9f0",
        "tags" : [
        ]
      }
    ],
    "commit" : "0d6d458befc730aa20c6dfeb9e2db76bb1947c6b",
    "line" : 889,
    "diffHunk" : "@@ -1,1 +1142,1146 @@### Keep Granularity\n\nIt's better to keep the granularity, so please don't do something like this:\n\n```scala"
  }
]
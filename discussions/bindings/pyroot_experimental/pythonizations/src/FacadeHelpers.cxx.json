[
  {
    "id" : "e17ca77d-441a-46ea-bd6d-37e0b3dde260",
    "prId" : 5429,
    "prUrl" : "https://github.com/root-project/root/pull/5429#pullrequestreview-399783107",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6f9c4079-534f-45f9-9f06-8db6f402adcf",
        "parentId" : null,
        "authorId" : "3fcf578f-7d83-494c-917c-61c04f4fb016",
        "body" : "There's doxygen markup for the return value, I think it's `\\return`?",
        "createdAt" : "2020-04-24T09:16:17Z",
        "updatedAt" : "2020-04-24T12:26:19Z",
        "lastEditedBy" : "3fcf578f-7d83-494c-917c-61c04f4fb016",
        "tags" : [
        ]
      },
      {
        "id" : "489a54c2-2bcf-4750-9ce9-570799fdf4b0",
        "parentId" : "6f9c4079-534f-45f9-9f06-8db6f402adcf",
        "authorId" : "4c541c6e-f658-422b-9f5a-7ae0b2a9a1f5",
        "body" : "True! Will do that!",
        "createdAt" : "2020-04-24T09:23:49Z",
        "updatedAt" : "2020-04-24T12:26:19Z",
        "lastEditedBy" : "4c541c6e-f658-422b-9f5a-7ae0b2a9a1f5",
        "tags" : [
        ]
      }
    ],
    "commit" : "186057abb33245c2bfb249816436f975a347bf97",
    "line" : 25,
    "diffHunk" : "@@ -1,1 +23,27 @@/// \\param[in] self Always null, since this is a module function.\n/// \\param[in] addr Address to create buffer from\n///\n/// \\return A cppyy LowLevelView object on the received address, i.e. an\n///         indexable buffer starting at that address."
  },
  {
    "id" : "9082c97f-feb6-42b7-8d2e-e3b17c08f9ec",
    "prId" : 5429,
    "prUrl" : "https://github.com/root-project/root/pull/5429#pullrequestreview-399805200",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "cdecbfd3-933b-4a67-9292-4c062386cbec",
        "parentId" : null,
        "authorId" : "3fcf578f-7d83-494c-917c-61c04f4fb016",
        "body" : "A `Long64_t` can also be `-1` without being wrong. I never understood this logic from `PyLong_AsLongLong`, you do?",
        "createdAt" : "2020-04-24T09:17:12Z",
        "updatedAt" : "2020-04-24T12:26:19Z",
        "lastEditedBy" : "3fcf578f-7d83-494c-917c-61c04f4fb016",
        "tags" : [
        ]
      },
      {
        "id" : "bf4d140d-9f2f-4c3a-851b-1b0d8638e9b7",
        "parentId" : "cdecbfd3-933b-4a67-9292-4c062386cbec",
        "authorId" : "3fcf578f-7d83-494c-917c-61c04f4fb016",
        "body" : "Or is the `PyErr_Occured` the actual test? Then we don't need to check the value of `-1`.",
        "createdAt" : "2020-04-24T09:17:45Z",
        "updatedAt" : "2020-04-24T12:26:19Z",
        "lastEditedBy" : "3fcf578f-7d83-494c-917c-61c04f4fb016",
        "tags" : [
        ]
      },
      {
        "id" : "5e2af8a6-54d7-4a44-84fc-f8f97c64b132",
        "parentId" : "cdecbfd3-933b-4a67-9292-4c062386cbec",
        "authorId" : "4c541c6e-f658-422b-9f5a-7ae0b2a9a1f5",
        "body" : "Yeah this point is actually mentioned in the docs:\r\n\r\nhttps://docs.python.org/3/c-api/long.html#c.PyLong_AsLongLong\r\n\r\n`Returns -1 on error. Use PyErr_Occurred() to disambiguate.`\r\n\r\nSo my rational here was: I do a quick check first for `-1` as return value, and only if that is true I check if `PyErr_Occurred`.\r\n",
        "createdAt" : "2020-04-24T09:31:27Z",
        "updatedAt" : "2020-04-24T12:26:19Z",
        "lastEditedBy" : "4c541c6e-f658-422b-9f5a-7ae0b2a9a1f5",
        "tags" : [
        ]
      },
      {
        "id" : "0c6aa443-3506-4888-9097-f34cd4fc136a",
        "parentId" : "cdecbfd3-933b-4a67-9292-4c062386cbec",
        "authorId" : "4c541c6e-f658-422b-9f5a-7ae0b2a9a1f5",
        "body" : "On most of the cases, I will just check for the -1.",
        "createdAt" : "2020-04-24T09:32:26Z",
        "updatedAt" : "2020-04-24T12:26:19Z",
        "lastEditedBy" : "4c541c6e-f658-422b-9f5a-7ae0b2a9a1f5",
        "tags" : [
        ]
      },
      {
        "id" : "0b0a6b1d-a69c-4cd1-91e2-7d6f06c57717",
        "parentId" : "cdecbfd3-933b-4a67-9292-4c062386cbec",
        "authorId" : "3fcf578f-7d83-494c-917c-61c04f4fb016",
        "body" : "Right, I always forget that the `&&` statements are executed in order -> https://stackoverflow.com/questions/5211961/how-does-c-handle-short-circuit-evaluation",
        "createdAt" : "2020-04-24T09:54:44Z",
        "updatedAt" : "2020-04-24T12:26:19Z",
        "lastEditedBy" : "3fcf578f-7d83-494c-917c-61c04f4fb016",
        "tags" : [
        ]
      },
      {
        "id" : "2d86f33e-2528-4a48-a6df-7356eaca9ffd",
        "parentId" : "cdecbfd3-933b-4a67-9292-4c062386cbec",
        "authorId" : "3fcf578f-7d83-494c-917c-61c04f4fb016",
        "body" : "Most likely your impl is the most efficient one.",
        "createdAt" : "2020-04-24T09:55:18Z",
        "updatedAt" : "2020-04-24T12:26:19Z",
        "lastEditedBy" : "3fcf578f-7d83-494c-917c-61c04f4fb016",
        "tags" : [
        ]
      }
    ],
    "commit" : "186057abb33245c2bfb249816436f975a347bf97",
    "line" : 36,
    "diffHunk" : "@@ -1,1 +34,38 @@\n   Long64_t cAddr = PyLong_AsLongLong(addr);\n   if (cAddr == -1 && PyErr_Occurred()) {\n      PyErr_SetString(PyExc_RuntimeError, \"Unable to create buffer: address is not a valid integer\");\n      return NULL;"
  },
  {
    "id" : "2782a070-81dc-4738-b2a4-a8d6ea6041c3",
    "prId" : 5429,
    "prUrl" : "https://github.com/root-project/root/pull/5429#pullrequestreview-399805918",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "efa7e530-2c66-40e5-9da3-1b1a054552f3",
        "parentId" : null,
        "authorId" : "3fcf578f-7d83-494c-917c-61c04f4fb016",
        "body" : "You don't really need the `Long64_t` here, you could just use a `long long`, which is always 64 bit, also on the 32 bit machines. But just a minor detail, doesn't hurt that way. You could get rid of the `RtypesCore.h` header that way.",
        "createdAt" : "2020-04-24T09:19:30Z",
        "updatedAt" : "2020-04-24T12:26:19Z",
        "lastEditedBy" : "3fcf578f-7d83-494c-917c-61c04f4fb016",
        "tags" : [
        ]
      },
      {
        "id" : "1c4262e6-814d-4195-a1f4-74b5621b0402",
        "parentId" : "efa7e530-2c66-40e5-9da3-1b1a054552f3",
        "authorId" : "4c541c6e-f658-422b-9f5a-7ae0b2a9a1f5",
        "body" : "Ok but, then in line 42 and 44, you would just use `long long` (64 bit) and `int` (32 bit) too, instead of the Rtypes? I need the header for those too.",
        "createdAt" : "2020-04-24T09:26:25Z",
        "updatedAt" : "2020-04-24T12:26:19Z",
        "lastEditedBy" : "4c541c6e-f658-422b-9f5a-7ae0b2a9a1f5",
        "tags" : [
        ]
      },
      {
        "id" : "a5cd0e71-73cf-4681-a0ea-f7a016fa5177",
        "parentId" : "efa7e530-2c66-40e5-9da3-1b1a054552f3",
        "authorId" : "3fcf578f-7d83-494c-917c-61c04f4fb016",
        "body" : "Would be possible, I guess. As you like!",
        "createdAt" : "2020-04-24T09:56:21Z",
        "updatedAt" : "2020-04-24T12:26:19Z",
        "lastEditedBy" : "3fcf578f-7d83-494c-917c-61c04f4fb016",
        "tags" : [
        ]
      }
    ],
    "commit" : "186057abb33245c2bfb249816436f975a347bf97",
    "line" : 35,
    "diffHunk" : "@@ -1,1 +33,37 @@   }\n\n   Long64_t cAddr = PyLong_AsLongLong(addr);\n   if (cAddr == -1 && PyErr_Occurred()) {\n      PyErr_SetString(PyExc_RuntimeError, \"Unable to create buffer: address is not a valid integer\");"
  }
]
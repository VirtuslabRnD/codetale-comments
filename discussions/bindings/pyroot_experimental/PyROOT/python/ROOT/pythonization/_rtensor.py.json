[
  {
    "id" : "6acce517-042d-4a75-ab9b-bb779356cc0d",
    "prId" : 4043,
    "prUrl" : "https://github.com/root-project/root/pull/4043#pullrequestreview-261166576",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d43a0de6-b228-4f21-a14c-fafb6ca54d3b",
        "parentId" : null,
        "authorId" : "4c541c6e-f658-422b-9f5a-7ae0b2a9a1f5",
        "body" : "Good stuff @stwunsch !\r\n\r\nCould you add a docstring to all the functions here explaining a bit what they do and what are their parameters (even if sometimes it is quite obvious).",
        "createdAt" : "2019-07-11T08:52:59Z",
        "updatedAt" : "2019-07-12T12:13:12Z",
        "lastEditedBy" : "4c541c6e-f658-422b-9f5a-7ae0b2a9a1f5",
        "tags" : [
        ]
      },
      {
        "id" : "600713f5-c6f9-44d5-80f2-8c6b62a0ac87",
        "parentId" : "d43a0de6-b228-4f21-a14c-fafb6ca54d3b",
        "authorId" : "3fcf578f-7d83-494c-917c-61c04f4fb016",
        "body" : "Done.",
        "createdAt" : "2019-07-12T09:55:11Z",
        "updatedAt" : "2019-07-12T12:13:12Z",
        "lastEditedBy" : "3fcf578f-7d83-494c-917c-61c04f4fb016",
        "tags" : [
        ]
      }
    ],
    "commit" : "1de32201f80bb3aab2fc67b313e40abf5ea5c0a3",
    "line" : 15,
    "diffHunk" : "@@ -1,1 +13,17 @@from ROOT.pythonization._rvec import _array_interface_dtype_map\nimport cppyy\n\n\ndef get_array_interface(self):"
  },
  {
    "id" : "d9b2a340-3b28-4f2e-ae73-42d278d1ccf8",
    "prId" : 4043,
    "prUrl" : "https://github.com/root-project/root/pull/4043#pullrequestreview-261167075",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "02fb310d-9144-4a74-809b-1891bd9ff128",
        "parentId" : null,
        "authorId" : "4c541c6e-f658-422b-9f5a-7ae0b2a9a1f5",
        "body" : "Can you add a comment here, something in the lines \"if the RTensor class was instantiated with one of the supported basic types, we add the array interface to it\"",
        "createdAt" : "2019-07-11T08:54:21Z",
        "updatedAt" : "2019-07-12T12:13:12Z",
        "lastEditedBy" : "4c541c6e-f658-422b-9f5a-7ae0b2a9a1f5",
        "tags" : [
        ]
      },
      {
        "id" : "0c953600-1510-4c0e-ad54-144f40159001",
        "parentId" : "02fb310d-9144-4a74-809b-1891bd9ff128",
        "authorId" : "3fcf578f-7d83-494c-917c-61c04f4fb016",
        "body" : "Done",
        "createdAt" : "2019-07-12T09:56:11Z",
        "updatedAt" : "2019-07-12T12:13:12Z",
        "lastEditedBy" : "3fcf578f-7d83-494c-917c-61c04f4fb016",
        "tags" : [
        ]
      }
    ],
    "commit" : "1de32201f80bb3aab2fc67b313e40abf5ea5c0a3",
    "line" : 58,
    "diffHunk" : "@@ -1,1 +56,60 @@        name: string containing the name of the class\n    \"\"\"\n    if True in [\n            not name.find(\"RTensor<{},\".format(dtype)) is -1 for dtype in _array_interface_dtype_map\n    ]:"
  },
  {
    "id" : "43fd5a00-46dc-4a2c-8d7e-4e547ea6a555",
    "prId" : 4043,
    "prUrl" : "https://github.com/root-project/root/pull/4043#pullrequestreview-261220931",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1baf970d-2a7b-47a4-b927-01c5aea529ee",
        "parentId" : null,
        "authorId" : "4c541c6e-f658-422b-9f5a-7ae0b2a9a1f5",
        "body" : "It is a pity the amount of code repetition we have in `add_array_interface_property` and `get_array_interface` with respect to what is defined in `_rvec.py`. Would it be possible to create two parameterized generic functions and use them both for `RVec` and `RTensor`?",
        "createdAt" : "2019-07-11T09:16:05Z",
        "updatedAt" : "2019-07-12T12:13:12Z",
        "lastEditedBy" : "4c541c6e-f658-422b-9f5a-7ae0b2a9a1f5",
        "tags" : [
        ]
      },
      {
        "id" : "f7c0962c-598b-4347-a253-a1dbf0f94d20",
        "parentId" : "1baf970d-2a7b-47a4-b927-01c5aea529ee",
        "authorId" : "3fcf578f-7d83-494c-917c-61c04f4fb016",
        "body" : "Hm I thought about deduplicating here, but the dicts are indeed filled differently (different way to get the pointer, the tensor has strides, ...). So either we reimplement or we have a rather complex if/else construct. I think that the version here is less confusing on the long term.",
        "createdAt" : "2019-07-12T07:21:59Z",
        "updatedAt" : "2019-07-12T12:13:12Z",
        "lastEditedBy" : "3fcf578f-7d83-494c-917c-61c04f4fb016",
        "tags" : [
        ]
      },
      {
        "id" : "ed3c4bc5-3487-4598-ade9-7335a2d5f4ce",
        "parentId" : "1baf970d-2a7b-47a4-b927-01c5aea529ee",
        "authorId" : "4c541c6e-f658-422b-9f5a-7ae0b2a9a1f5",
        "body" : "Mm I think this case is on the edge... What about a common helper function that partially fills the dictionary (typestr, version, data), which receives as parameter the function to get the pointer? Then RTensor and RVec would fill what is different in the dictionary (shape and strides).",
        "createdAt" : "2019-07-12T07:55:49Z",
        "updatedAt" : "2019-07-12T12:13:12Z",
        "lastEditedBy" : "4c541c6e-f658-422b-9f5a-7ae0b2a9a1f5",
        "tags" : [
        ]
      },
      {
        "id" : "13b62cc5-6be6-416f-bf14-27836337aab1",
        "parentId" : "1baf970d-2a7b-47a4-b927-01c5aea529ee",
        "authorId" : "4c541c6e-f658-422b-9f5a-7ae0b2a9a1f5",
        "body" : "What about this? :smile: ",
        "createdAt" : "2019-07-12T10:13:12Z",
        "updatedAt" : "2019-07-12T12:13:12Z",
        "lastEditedBy" : "4c541c6e-f658-422b-9f5a-7ae0b2a9a1f5",
        "tags" : [
        ]
      },
      {
        "id" : "a7d6134b-fabf-4ab9-9319-8aa280490512",
        "parentId" : "1baf970d-2a7b-47a4-b927-01c5aea529ee",
        "authorId" : "3fcf578f-7d83-494c-917c-61c04f4fb016",
        "body" : "Also the data is different :P I'm not really in favor of this.",
        "createdAt" : "2019-07-12T11:21:46Z",
        "updatedAt" : "2019-07-12T12:13:12Z",
        "lastEditedBy" : "3fcf578f-7d83-494c-917c-61c04f4fb016",
        "tags" : [
        ]
      },
      {
        "id" : "838cc80c-35b5-43c8-8a85-670449c50a0e",
        "parentId" : "1baf970d-2a7b-47a4-b927-01c5aea529ee",
        "authorId" : "4c541c6e-f658-422b-9f5a-7ae0b2a9a1f5",
        "body" : "Ok let's make a deal, we leave this one as it is but we refactor more in `PyROOT::AsRTensor` :smile: ",
        "createdAt" : "2019-07-12T11:37:57Z",
        "updatedAt" : "2019-07-12T12:13:12Z",
        "lastEditedBy" : "4c541c6e-f658-422b-9f5a-7ae0b2a9a1f5",
        "tags" : [
        ]
      },
      {
        "id" : "01494401-4ee0-4be7-824a-9e643933f05d",
        "parentId" : "1baf970d-2a7b-47a4-b927-01c5aea529ee",
        "authorId" : "3fcf578f-7d83-494c-917c-61c04f4fb016",
        "body" : "Deal!",
        "createdAt" : "2019-07-12T12:13:34Z",
        "updatedAt" : "2019-07-12T12:13:34Z",
        "lastEditedBy" : "3fcf578f-7d83-494c-917c-61c04f4fb016",
        "tags" : [
        ]
      }
    ],
    "commit" : "1de32201f80bb3aab2fc67b313e40abf5ea5c0a3",
    "line" : 60,
    "diffHunk" : "@@ -1,1 +58,62 @@    if True in [\n            not name.find(\"RTensor<{},\".format(dtype)) is -1 for dtype in _array_interface_dtype_map\n    ]:\n        klass.__array_interface__ = property(get_array_interface)\n"
  },
  {
    "id" : "428dbc10-25d2-44ab-a6d5-b08f919e6ccd",
    "prId" : 4043,
    "prUrl" : "https://github.com/root-project/root/pull/4043#pullrequestreview-261094118",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ed266826-ff62-4932-962d-64f5fed22240",
        "parentId" : null,
        "authorId" : "4c541c6e-f658-422b-9f5a-7ae0b2a9a1f5",
        "body" : "Is this to convert any iterable you might receive to a list? Just asking since you already converted a single item to a list above.",
        "createdAt" : "2019-07-11T09:45:06Z",
        "updatedAt" : "2019-07-12T12:13:12Z",
        "lastEditedBy" : "4c541c6e-f658-422b-9f5a-7ae0b2a9a1f5",
        "tags" : [
        ]
      },
      {
        "id" : "2e82d1f6-8e1b-45f7-8f48-37425b89ca25",
        "parentId" : "ed266826-ff62-4932-962d-64f5fed22240",
        "authorId" : "3fcf578f-7d83-494c-917c-61c04f4fb016",
        "body" : "The problem is that the indices you get are a tuple and therefore immutable. In addition, you get either a basic type or a tuple of basic types or a mixture of all of them (since we have multiple dimensions!). To streamline the processing of the indices later on, I convert everything to a list (even though the tensor might have only one dimension and it might be only a single index).",
        "createdAt" : "2019-07-12T07:17:15Z",
        "updatedAt" : "2019-07-12T12:13:12Z",
        "lastEditedBy" : "3fcf578f-7d83-494c-917c-61c04f4fb016",
        "tags" : [
        ]
      }
    ],
    "commit" : "1de32201f80bb3aab2fc67b313e40abf5ea5c0a3",
    "line" : 77,
    "diffHunk" : "@@ -1,1 +75,79 @@    if not hasattr(idx, \"__len__\"):\n        idx = [idx]\n    idx = list(idx)\n\n    # Check shape"
  },
  {
    "id" : "0cc68e56-a5f0-43e2-a6a0-6e0af8dafa1f",
    "prId" : 4043,
    "prUrl" : "https://github.com/root-project/root/pull/4043#pullrequestreview-261094906",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e6d79e67-77e6-4170-b181-3111e62e823a",
        "parentId" : null,
        "authorId" : "4c541c6e-f658-422b-9f5a-7ae0b2a9a1f5",
        "body" : "I am not sure if it would be useful here, but when I implemented slicing for `TSeqCollection` I used this:\r\n\r\nhttps://github.com/root-project/root/blob/master/bindings/pyroot_experimental/PyROOT/python/ROOT/pythonization/_tseqcollection.py#L63\r\n\r\nYou can ask for the indices that the slice syntax represents (returns a start,stop,step tuple). Could this simplify the logic you have here and potentially allow step size > 1?",
        "createdAt" : "2019-07-11T09:58:53Z",
        "updatedAt" : "2019-07-12T12:13:12Z",
        "lastEditedBy" : "4c541c6e-f658-422b-9f5a-7ae0b2a9a1f5",
        "tags" : [
        ]
      },
      {
        "id" : "d429ac05-eb69-4791-83a0-104bf359c703",
        "parentId" : "e6d79e67-77e6-4170-b181-3111e62e823a",
        "authorId" : "3fcf578f-7d83-494c-917c-61c04f4fb016",
        "body" : "The step size > 1 is not supported by the C++ implementation in the back and therefore it's excluded. Then, I have to convert the slice to the C++ representation of the slice (which is a `vector<vector<size_t>>`) taking into account the correct ranges.",
        "createdAt" : "2019-07-12T07:19:44Z",
        "updatedAt" : "2019-07-12T12:13:12Z",
        "lastEditedBy" : "3fcf578f-7d83-494c-917c-61c04f4fb016",
        "tags" : [
        ]
      }
    ],
    "commit" : "1de32201f80bb3aab2fc67b313e40abf5ea5c0a3",
    "line" : 88,
    "diffHunk" : "@@ -1,1 +86,90 @@    for i, x in enumerate(idx):\n        if type(x) == slice:\n            isSlice = True\n            start = 0 if x.start is None else x.start\n            stop = shape[i] if x.stop is None else x.stop"
  }
]
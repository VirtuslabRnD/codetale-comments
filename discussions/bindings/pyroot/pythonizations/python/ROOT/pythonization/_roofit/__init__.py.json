[
  {
    "id" : "ea443e87-db92-47e5-8cf1-0c906bb8d025",
    "prId" : 7753,
    "prUrl" : "https://github.com/root-project/root/pull/7753#pullrequestreview-650454151",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7f08199b-61ea-499a-9027-22fd0704d6ce",
        "parentId" : null,
        "authorId" : "4c541c6e-f658-422b-9f5a-7ae0b2a9a1f5",
        "body" : "Why is it necessary that you also take the methods of base classes? Shouldn't you just inject in the Python proxy class the methods that were defined in your mirror class (and strictly just those methods)?",
        "createdAt" : "2021-05-03T14:46:14Z",
        "updatedAt" : "2021-05-03T14:46:15Z",
        "lastEditedBy" : "4c541c6e-f658-422b-9f5a-7ae0b2a9a1f5",
        "tags" : [
        ]
      },
      {
        "id" : "04ad9640-3d2c-4570-8847-eb4610a776a4",
        "parentId" : "7f08199b-61ea-499a-9027-22fd0704d6ce",
        "authorId" : "080bddae-e637-45c8-b6c1-53aef7161d62",
        "body" : "I also want to get pythonizations from the base classes of the mirror class.\r\n\r\nThe point of mirroring also the inheritance hierachy was to inherit pythonizations even if the function gets redefined on the C++ side. In this case, cppyy doesn't pythonize the redefinition (which is correct in general), but often want to use the same pythoniztion by default (for example for `RooAbsReal::plotOn` and `RooAbsPdf::plotOn`).",
        "createdAt" : "2021-05-03T15:00:51Z",
        "updatedAt" : "2021-05-03T15:00:51Z",
        "lastEditedBy" : "080bddae-e637-45c8-b6c1-53aef7161d62",
        "tags" : [
        ]
      },
      {
        "id" : "2611fdde-52be-4ed2-ae99-dfb2fe55307d",
        "parentId" : "7f08199b-61ea-499a-9027-22fd0704d6ce",
        "authorId" : "4c541c6e-f658-422b-9f5a-7ae0b2a9a1f5",
        "body" : "I see. In that case, I would just redefine the pythonization too in the derived class mirror class (you can invoke some helper function that is shared for base and derived, to avoid code duplication). I think this is cleaner: pythonizations are automatically inherited if there is no redefinition of the C++ side; if there is a redefinition on the C++ side, the pythonization is redefined too, to explicitly state that this is your desire (otherwise you are implicitly taking the same decision for every case like this). Moreover, this will allow you to get rid of walking on the methods of the base classes.",
        "createdAt" : "2021-05-03T15:14:15Z",
        "updatedAt" : "2021-05-03T15:14:16Z",
        "lastEditedBy" : "4c541c6e-f658-422b-9f5a-7ae0b2a9a1f5",
        "tags" : [
        ]
      },
      {
        "id" : "0c991eeb-8532-4368-984e-a6eae4c4ce52",
        "parentId" : "7f08199b-61ea-499a-9027-22fd0704d6ce",
        "authorId" : "080bddae-e637-45c8-b6c1-53aef7161d62",
        "body" : "Okay, we can do it like this!",
        "createdAt" : "2021-05-03T15:22:04Z",
        "updatedAt" : "2021-05-03T15:22:04Z",
        "lastEditedBy" : "080bddae-e637-45c8-b6c1-53aef7161d62",
        "tags" : [
        ]
      }
    ],
    "commit" : "b92af7f251c4a87d3b1f88145d0e9032b70fd53e",
    "line" : 46,
    "diffHunk" : "@@ -1,1 +43,47 @@\n    # get a list of this class and all its base classes, excluding `object`\n    method_resolution_order = klass.mro()\n    if object in method_resolution_order:\n        method_resolution_order.remove(object)"
  },
  {
    "id" : "ef657c36-1598-4894-a7b5-e5769b59b203",
    "prId" : 7753,
    "prUrl" : "https://github.com/root-project/root/pull/7753#pullrequestreview-650450112",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "51dd769e-5372-4b64-9790-f475061022f0",
        "parentId" : null,
        "authorId" : "4c541c6e-f658-422b-9f5a-7ae0b2a9a1f5",
        "body" : "Perhaps if you just inspected the methods of the mirror class you wouldn't even need this blacklist?",
        "createdAt" : "2021-05-03T14:47:28Z",
        "updatedAt" : "2021-05-03T14:47:29Z",
        "lastEditedBy" : "4c541c6e-f658-422b-9f5a-7ae0b2a9a1f5",
        "tags" : [
        ]
      },
      {
        "id" : "ddf51993-8ee7-4ece-8ff0-48af011b6dba",
        "parentId" : "51dd769e-5372-4b64-9790-f475061022f0",
        "authorId" : "080bddae-e637-45c8-b6c1-53aef7161d62",
        "body" : "I tried that out, but these few attributes are always in `__dict__`, even if you get it from the class itself. I was trying out some other ways to avoid selecting these attributes, but I didn't find a simple solution that works for both Python 2 and Python 3.\r\n\r\nSo in the end I thought a short blacklist is more digestible. Or you absolutely want to avoid a hardcoded blacklist?",
        "createdAt" : "2021-05-03T14:56:02Z",
        "updatedAt" : "2021-05-03T14:56:02Z",
        "lastEditedBy" : "080bddae-e637-45c8-b6c1-53aef7161d62",
        "tags" : [
        ]
      },
      {
        "id" : "4e3fe70b-52db-4373-ae3b-3da81db45d4a",
        "parentId" : "51dd769e-5372-4b64-9790-f475061022f0",
        "authorId" : "4c541c6e-f658-422b-9f5a-7ae0b2a9a1f5",
        "body" : "It's not ideal, but if there is no way to tell them apart from your methods, I don't see any other way.",
        "createdAt" : "2021-05-03T15:17:42Z",
        "updatedAt" : "2021-05-03T15:17:42Z",
        "lastEditedBy" : "4c541c6e-f658-422b-9f5a-7ae0b2a9a1f5",
        "tags" : [
        ]
      }
    ],
    "commit" : "b92af7f251c4a87d3b1f88145d0e9032b70fd53e",
    "line" : 40,
    "diffHunk" : "@@ -1,1 +37,41 @@    \"\"\"\n\n    blacklist = [\"__dict__\", \"__doc__\", \"__hash__\", \"__module__\", \"__weakref__\"]\n\n    if not consider_base_classes:"
  }
]
[
  {
    "id" : "f00e6739-8e23-4e94-a4ad-166249a07703",
    "prId" : 4675,
    "prUrl" : "https://github.com/root-project/root/pull/4675#pullrequestreview-334683051",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e989b660-0e45-4e62-aa65-b43bfc8817e6",
        "parentId" : null,
        "authorId" : "335eabbd-4b70-43fb-a046-bf82995f5dd3",
        "body" : "Why are this needed/helpful?",
        "createdAt" : "2019-12-17T21:02:24Z",
        "updatedAt" : "2019-12-23T06:24:39Z",
        "lastEditedBy" : "335eabbd-4b70-43fb-a046-bf82995f5dd3",
        "tags" : [
        ]
      },
      {
        "id" : "de460083-0c09-4778-b7ea-1f308e2bb42b",
        "parentId" : "e989b660-0e45-4e62-aa65-b43bfc8817e6",
        "authorId" : "6f6f52c8-bace-4788-98aa-f12fb2560025",
        "body" : "Previously ROOT was initialized here: https://github.com/root-project/root/blob/master/bindings/pyroot/src/RootWrapper.cxx#L184-L196\r\n\r\nUnfortunately it has shorter lifetime of the `ApplicationStarter` which requires ROOT to be alive to shutdown. Eg. by the time `ApplicationStarter::~ApplicationStarter` is  called ROOT is destroyed.",
        "createdAt" : "2019-12-18T13:51:24Z",
        "updatedAt" : "2019-12-23T06:24:39Z",
        "lastEditedBy" : "6f6f52c8-bace-4788-98aa-f12fb2560025",
        "tags" : [
        ]
      },
      {
        "id" : "8f0e16fd-43d6-49ff-94a1-6ea7e1e75222",
        "parentId" : "e989b660-0e45-4e62-aa65-b43bfc8817e6",
        "authorId" : "335eabbd-4b70-43fb-a046-bf82995f5dd3",
        "body" : "How does calling TROOT::Initialize in the constructor makes gROOT still alive for ```ApplicationStarter::~ApplicationStarter```?   And is that really a 100% guaranteed or would you be better off testing for TROOT still being alive?",
        "createdAt" : "2019-12-18T16:44:33Z",
        "updatedAt" : "2019-12-23T06:24:39Z",
        "lastEditedBy" : "335eabbd-4b70-43fb-a046-bf82995f5dd3",
        "tags" : [
        ]
      },
      {
        "id" : "2a6a3032-24cf-401e-a25f-bafe7c2370d3",
        "parentId" : "e989b660-0e45-4e62-aa65-b43bfc8817e6",
        "authorId" : "6f6f52c8-bace-4788-98aa-f12fb2560025",
        "body" : "Without this change I get:\r\n```\r\n(gdb) bt\r\n#0  TCling::~TCling (this=0x555555c85fd0, __in_chrg=<optimized out>)\r\n    at /home/vvassilev/workspace/sources/root/core/metacling/src/TCling.cxx:1439\r\n#1  0x00007fffeb685ece in TCling::~TCling (this=0x555555c85fd0, __in_chrg=<optimized out>)\r\n    at /home/vvassilev/workspace/sources/root/core/metacling/src/TCling.cxx:1452\r\n#2  0x00007ffff45a3458 in TROOT::~TROOT (this=0x7ffff4bc86c0 <ROOT::Internal::GetROOT1()::alloc>, __in_chrg=<optimized out>)\r\n    at /home/vvassilev/workspace/sources/root/core/base/src/TROOT.cxx:1025\r\n#3  0x00007ffff45a0668 in at_exit_of_TROOT () at /home/vvassilev/workspace/sources/root/core/base/src/TROOT.cxx:297\r\n#4  0x00007ffff7a27041 in __run_exit_handlers (status=0, listp=0x7ffff7dcf718 <__exit_funcs>, \r\n    run_list_atexit=run_list_atexit@entry=true, run_dtors=run_dtors@entry=true) at exit.c:108\r\n#5  0x00007ffff7a2713a in __GI_exit (status=<optimized out>) at exit.c:139\r\n#6  0x00005555556a9a2f in Py_Exit ()\r\n#7  0x00005555556a7131 in ?? ()\r\n#8  0x00005555556a6a73 in PyErr_PrintEx ()\r\n#9  0x00005555555baf60 in ?? ()\r\n#10 0x0000555555620de4 in Py_Main ()\r\n#11 0x00007ffff7a05b97 in __libc_start_main (main=0x555555620780 <main>, argc=5, argv=0x7fffffffde38, init=<optimized out>, \r\n    fini=<optimized out>, rtld_fini=<optimized out>, stack_end=0x7fffffffde28) at ../csu/libc-start.c:310\r\n#12 0x000055555562069a in _start ()\r\n(gdb) c\r\nContinuing.\r\n\r\nProgram received signal SIGSEGV, Segmentation fault.\r\n0x0000555557c2e150 in ?? ()\r\n(gdb) bt\r\n#0  0x0000555557c2e150 in ?? ()\r\n#1  0x00007ffff60564e6 in (anonymous namespace)::ApplicationStarter::~ApplicationStarter (\r\n    this=0x7ffff62ff930 <(anonymous namespace)::_applicationStarter>, __in_chrg=<optimized out>)\r\n    at /home/vvassilev/workspace/sources/root/bindings/pyroot/src/Cppyy.cxx:91\r\n#2  0x00007ffff7a27041 in __run_exit_handlers (status=0, listp=0x7ffff7dcf718 <__exit_funcs>, \r\n    run_list_atexit=run_list_atexit@entry=true, run_dtors=run_dtors@entry=true) at exit.c:108\r\n#3  0x00007ffff7a2713a in __GI_exit (status=<optimized out>) at exit.c:139\r\n#4  0x00005555556a9a2f in Py_Exit ()\r\n#5  0x00005555556a7131 in ?? ()\r\n#6  0x00005555556a6a73 in PyErr_PrintEx ()\r\n#7  0x00005555555baf60 in ?? ()\r\n#8  0x0000555555620de4 in Py_Main ()\r\n#9  0x00007ffff7a05b97 in __libc_start_main (main=0x555555620780 <main>, argc=5, argv=0x7fffffffde38, init=<optimized out>, \r\n    fini=<optimized out>, rtld_fini=<optimized out>, stack_end=0x7fffffffde28) at ../csu/libc-start.c:310\r\n#10 0x000055555562069a in _start ()\r\n```\r\n\r\n`Py_Exit` is a callback from the python interpreter. It starts shutting down the system and run the atexit handlers. If we initialize ROOT outside of `ApplicationStarter`, the atexit handlers of ROOT are run before the ones from the `ApplicationStarter`. This causes a premature call to `TCling::~TCling`. Then we run the `ApplicationStarter` atexit handlers which depend on ROOT being alive and the rest is history :)\r\n\r\nI suspect that https://github.com/root-project/root/blob/master/core/base/src/TROOT.cxx#L2091 gets executed before some other (TApplication?) `atexit` function (https://paste.ubuntu.com/p/VbPWsyw7mw/) . According to https://paste.ubuntu.com/p/n2C7wDS6t2/ we call `atexit` on `TROOT::RegisterModule`.\r\n\r\nThe problem with the current design is that `TApplication` registers a ROOT-dependent atexit function. This in turn does not check if ROOT was initialized and depending on the order of static init it may register it *before* the `at_exit_of_TROOT`. I may make sense to add an assert there...",
        "createdAt" : "2019-12-19T07:09:26Z",
        "updatedAt" : "2019-12-23T06:24:39Z",
        "lastEditedBy" : "6f6f52c8-bace-4788-98aa-f12fb2560025",
        "tags" : [
        ]
      },
      {
        "id" : "db8fb8ab-70a0-4c56-90c5-561932e453c7",
        "parentId" : "e989b660-0e45-4e62-aa65-b43bfc8817e6",
        "authorId" : "335eabbd-4b70-43fb-a046-bf82995f5dd3",
        "body" : "Fair enough.  It makes sense.  The comment can be improved (maybe) by using:\r\n```\r\n      // Insure ROOT's atexit is executed *after* the atexit that calls ApplicationStarter's destructor,\r\n      // by forcing the ROOT's atexit registration now.\r\n      TROOT::Initialize();\r\n```",
        "createdAt" : "2019-12-19T14:50:41Z",
        "updatedAt" : "2019-12-23T06:24:39Z",
        "lastEditedBy" : "335eabbd-4b70-43fb-a046-bf82995f5dd3",
        "tags" : [
        ]
      }
    ],
    "commit" : "7a9b4c96ac9d450a916303b26f611d361e261b93",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +78,82 @@      // ApplicationStarter's destructor, by forcing the ROOT's atexit\n      // registration now.\n      TROOT::Initialize();\n      // setup dummy holders for global and std namespaces\n      assert( g_classrefs.size() == GLOBAL_HANDLE );"
  }
]
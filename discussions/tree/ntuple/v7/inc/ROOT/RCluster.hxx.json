[
  {
    "id" : "28c624aa-f4d8-4f7b-afe0-2698518e8016",
    "prId" : 5377,
    "prUrl" : "https://github.com/root-project/root/pull/5377#pullrequestreview-410426020",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d5c8f457-1edb-495c-8198-cdecf0bf7cd1",
        "parentId" : null,
        "authorId" : "335eabbd-4b70-43fb-a046-bf82995f5dd3",
        "body" : "Can you add text explaining why/if this is a good hash for the pair?",
        "createdAt" : "2020-05-11T22:13:04Z",
        "updatedAt" : "2020-06-29T15:55:03Z",
        "lastEditedBy" : "335eabbd-4b70-43fb-a046-bf82995f5dd3",
        "tags" : [
        ]
      },
      {
        "id" : "221dd12c-b37e-49cb-9e2b-941532cfcf7b",
        "parentId" : "d5c8f457-1edb-495c-8198-cdecf0bf7cd1",
        "authorId" : "6cd3c9bc-f261-444d-81ab-c00c917f2197",
        "body" : "Good point - I'm afraid I can't and probably it isn't very good.  We want something like `boost::hash_combine` or `llvm::hash_combine` in order to hash over multiple fields of a struct. @Axel-Naumann do you think it is worth adding `hash_combine` to the ROOT infrastructure code?",
        "createdAt" : "2020-05-12T12:50:27Z",
        "updatedAt" : "2020-06-29T15:55:03Z",
        "lastEditedBy" : "6cd3c9bc-f261-444d-81ab-c00c917f2197",
        "tags" : [
        ]
      },
      {
        "id" : "c7232bc2-b67d-4476-a980-27c0ef092d70",
        "parentId" : "d5c8f457-1edb-495c-8198-cdecf0bf7cd1",
        "authorId" : "335eabbd-4b70-43fb-a046-bf82995f5dd3",
        "body" : "For this round, this is fine as is.  The comment can be something like \"quick and dirty hash, likely very sub-optimal, to be revised later.\"",
        "createdAt" : "2020-05-12T21:12:28Z",
        "updatedAt" : "2020-06-29T15:55:03Z",
        "lastEditedBy" : "335eabbd-4b70-43fb-a046-bf82995f5dd3",
        "tags" : [
        ]
      }
    ],
    "commit" : "3c9e7c8ebfa10154ea784232e4e0490855cc14b0",
    "line" : 84,
    "diffHunk" : "@@ -1,1 +82,86 @@      size_t operator()(const ROOT::Experimental::Detail::ROnDiskPage::Key &key) const\n      {\n         return ((std::hash<ROOT::Experimental::DescriptorId_t>()(key.fColumnId) ^\n                 (hash<ROOT::Experimental::NTupleSize_t>()(key.fPageNo) << 1)) >> 1);\n      }"
  },
  {
    "id" : "71cf6945-0e00-47a9-847e-2ab00320fb82",
    "prId" : 5377,
    "prUrl" : "https://github.com/root-project/root/pull/5377#pullrequestreview-431341173",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8255560c-4e90-4894-a88f-09b11a4145f8",
        "parentId" : null,
        "authorId" : "09b7e073-cbeb-42e8-aa22-8b1468de56ae",
        "body" : "`DescriptorId_t` is very very generic. Maybe `ColumnId_t`?",
        "createdAt" : "2020-05-29T19:52:49Z",
        "updatedAt" : "2020-06-29T15:55:03Z",
        "lastEditedBy" : "09b7e073-cbeb-42e8-aa22-8b1468de56ae",
        "tags" : [
        ]
      },
      {
        "id" : "78d44829-2258-4064-aa95-fad716fbed25",
        "parentId" : "8255560c-4e90-4894-a88f-09b11a4145f8",
        "authorId" : "6cd3c9bc-f261-444d-81ab-c00c917f2197",
        "body" : "The `DescriptorId_t` (64bit integer) is used for all the things in an RNTuple descriptor that can be addressed by an id. Currently columns, fields, and clusters. I can add these three type aliases (at the expense of three more type names).",
        "createdAt" : "2020-06-05T13:05:22Z",
        "updatedAt" : "2020-06-29T15:55:03Z",
        "lastEditedBy" : "6cd3c9bc-f261-444d-81ab-c00c917f2197",
        "tags" : [
        ]
      },
      {
        "id" : "e5a08d46-6879-4772-8536-439a57a28171",
        "parentId" : "8255560c-4e90-4894-a88f-09b11a4145f8",
        "authorId" : "09b7e073-cbeb-42e8-aa22-8b1468de56ae",
        "body" : "The danger might be that one can have\r\n```\r\nDescriptorId_t id = GetColumn();\r\n...\r\nSelectCluster(id);\r\n```\r\n(function names made up.) I.e. adding type safety to IDs might be beneficial, because you'll never want to mix IDs of columns, fields, and clusters (I guess). For type-safety an *alias* won't be enough; you'd have to have dedicated types.",
        "createdAt" : "2020-06-05T14:11:49Z",
        "updatedAt" : "2020-06-29T15:55:03Z",
        "lastEditedBy" : "09b7e073-cbeb-42e8-aa22-8b1468de56ae",
        "tags" : [
        ]
      },
      {
        "id" : "b8a7b1d1-a74c-4f11-87d8-7635db152389",
        "parentId" : "8255560c-4e90-4894-a88f-09b11a4145f8",
        "authorId" : "6cd3c9bc-f261-444d-81ab-c00c917f2197",
        "body" : "We can create sub types of `RNTupleDescriptor`, e.g. `RNTupleDescriptor::RColumnId`, to not pollute the common name space.  I'd prefer to make this change in a separate PR.",
        "createdAt" : "2020-06-16T09:50:28Z",
        "updatedAt" : "2020-06-29T15:55:03Z",
        "lastEditedBy" : "6cd3c9bc-f261-444d-81ab-c00c917f2197",
        "tags" : [
        ]
      }
    ],
    "commit" : "3c9e7c8ebfa10154ea784232e4e0490855cc14b0",
    "line" : 54,
    "diffHunk" : "@@ -1,1 +52,56 @@   /// associative collections of on-disk pages.\n   struct Key {\n      DescriptorId_t fColumnId;\n      std::uint64_t fPageNo;\n      Key(DescriptorId_t columnId, std::uint64_t pageNo) : fColumnId(columnId), fPageNo(pageNo) {}"
  }
]
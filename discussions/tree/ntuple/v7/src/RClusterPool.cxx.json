[
  {
    "id" : "61c7d5af-8489-4d22-8a26-101d29723e3f",
    "prId" : 5377,
    "prUrl" : "https://github.com/root-project/root/pull/5377#pullrequestreview-411043203",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e4fc1024-afa1-4428-a2b0-49ae190423ef",
        "parentId" : null,
        "authorId" : "335eabbd-4b70-43fb-a046-bf82995f5dd3",
        "body" : "Is there exactly one or more than one of those in flight at a time?",
        "createdAt" : "2020-05-12T22:33:01Z",
        "updatedAt" : "2020-06-29T15:55:03Z",
        "lastEditedBy" : "335eabbd-4b70-43fb-a046-bf82995f5dd3",
        "tags" : [
        ]
      },
      {
        "id" : "3a4c3bcf-64e8-4dc5-9371-c61bb0d89385",
        "parentId" : "e4fc1024-afa1-4428-a2b0-49ae190423ef",
        "authorId" : "6cd3c9bc-f261-444d-81ab-c00c917f2197",
        "body" : "Yes, there is exactly one I/O thread for every RClusterPool object.  I added that information to the method documentation",
        "createdAt" : "2020-05-13T15:28:18Z",
        "updatedAt" : "2020-06-29T15:55:03Z",
        "lastEditedBy" : "6cd3c9bc-f261-444d-81ab-c00c917f2197",
        "tags" : [
        ]
      }
    ],
    "commit" : "3c9e7c8ebfa10154ea784232e4e0490855cc14b0",
    "line" : 77,
    "diffHunk" : "@@ -1,1 +75,79 @@\nvoid ROOT::Experimental::Detail::RClusterPool::ExecLoadClusters()\n{\n   while (true) {\n      std::vector<RWorkItem> workItems;"
  },
  {
    "id" : "1e872d78-76fe-4146-bf18-c7d7c94e79f7",
    "prId" : 5377,
    "prUrl" : "https://github.com/root-project/root/pull/5377#pullrequestreview-421395189",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e3ba24bc-677f-486d-aaf0-868f7256b5ae",
        "parentId" : null,
        "authorId" : "09b7e073-cbeb-42e8-aa22-8b1468de56ae",
        "body" : "You called it `operator <` in the header (space before '<'); maybe keep consistent? Or is this clang-format?",
        "createdAt" : "2020-05-30T10:44:05Z",
        "updatedAt" : "2020-06-29T15:55:03Z",
        "lastEditedBy" : "09b7e073-cbeb-42e8-aa22-8b1468de56ae",
        "tags" : [
        ]
      }
    ],
    "commit" : "3c9e7c8ebfa10154ea784232e4e0490855cc14b0",
    "line" : 33,
    "diffHunk" : "@@ -1,1 +31,35 @@#include <utility>\n\nbool ROOT::Experimental::Detail::RClusterPool::RInFlightCluster::operator <(const RInFlightCluster &other) const\n{\n   if (fClusterId == other.fClusterId) {"
  },
  {
    "id" : "0fcec011-25e7-48a9-a2e3-1113d84ce3b5",
    "prId" : 5377,
    "prUrl" : "https://github.com/root-project/root/pull/5377#pullrequestreview-438316375",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "28476690-4bd7-48de-8831-d589fe4474e5",
        "parentId" : null,
        "authorId" : "335eabbd-4b70-43fb-a046-bf82995f5dd3",
        "body" : "Are the cluster always guaranteed to be the same size?  (For example, they might not be in case of merging 2 RNtuple that were created differently).  If the clusters can not be guaranteed to be the same size then the memory cost of \"N\" clusters in memory (I assume that is the meaning of fWindowPost) can vary (possibly widely).  So it may (or may not) be easier for the user to configure in term of memory size.  \r\n\r\nAnother source of cluster size being different is when fetching just a sub-set of columns. (where the aggregate of all columns may have a consistent size for a cluster but not every sub-sets).",
        "createdAt" : "2020-06-24T18:13:01Z",
        "updatedAt" : "2020-06-29T15:55:03Z",
        "lastEditedBy" : "335eabbd-4b70-43fb-a046-bf82995f5dd3",
        "tags" : [
        ]
      },
      {
        "id" : "b26cf4fd-890f-4140-85cb-09fbad9ae5e4",
        "parentId" : "28476690-4bd7-48de-8831-d589fe4474e5",
        "authorId" : "6cd3c9bc-f261-444d-81ab-c00c917f2197",
        "body" : "I agree, clusters don't have the same size and we eventually want the memory consumption be the criterion. I added a TODO:\r\n\r\n    // TODO(jblomer): instead of a fixed-sized window, eventually we should determine the window size based on\r\n    // a user-defined memory limit.  The size of the preloaded data can be determined at the beginning of\r\n    // GetCluster from the descriptor and the current contents of fPool.",
        "createdAt" : "2020-06-26T13:55:48Z",
        "updatedAt" : "2020-06-29T15:55:03Z",
        "lastEditedBy" : "6cd3c9bc-f261-444d-81ab-c00c917f2197",
        "tags" : [
        ]
      }
    ],
    "commit" : "3c9e7c8ebfa10154ea784232e4e0490855cc14b0",
    "line" : 203,
    "diffHunk" : "@@ -1,1 +201,205 @@   // a user-defined memory limit.  The size of the preloaded data can be determined at the beginning of\n   // GetCluster from the descriptor and the current contents of fPool.\n   for (unsigned int i = 1; i < fWindowPost; ++i) {\n      next = desc.FindNextClusterId(next);\n      if (next == kInvalidDescriptorId)"
  },
  {
    "id" : "e9d99762-6476-46e0-947f-1a7051842959",
    "prId" : 5377,
    "prUrl" : "https://github.com/root-project/root/pull/5377#pullrequestreview-439284388",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "47166f36-d43e-49c6-a8cf-ff096ccbe9b9",
        "parentId" : null,
        "authorId" : "335eabbd-4b70-43fb-a046-bf82995f5dd3",
        "body" : "```itr``` is an iterator inside the collection.  Between line 310+ (setting/acquisition) and here (use), the lock is not held by this thread, consequently another thread might be updating the collection in between.  So questions:\r\n\r\na) could the iterator have been invalidated.\r\nb) is it still pointing to the intended element?\r\n\r\nSo should line 318 and 327 be inside the lock_guard line 309 (and line [319,324] still outside)?\r\n",
        "createdAt" : "2020-06-24T18:40:58Z",
        "updatedAt" : "2020-06-29T15:55:03Z",
        "lastEditedBy" : "335eabbd-4b70-43fb-a046-bf82995f5dd3",
        "tags" : [
        ]
      },
      {
        "id" : "e48ba454-b96a-451e-93e3-32fa6feb2e20",
        "parentId" : "47166f36-d43e-49c6-a8cf-ff096ccbe9b9",
        "authorId" : "6cd3c9bc-f261-444d-81ab-c00c917f2197",
        "body" : "It should be fine as the structure of the vector is not modified in the other thread.  I added a clarifying comment:\r\n\r\n    // Note that the fInFlightClusters is accessed concurrently only by the I/O thread.  The I/O thread\r\n    // never changes the structure of the in-flight clusters array (it does not add, remove, or swap elements).\r\n    // Therefore, it is safe to access the element pointed to by itr here even after fLockWorkQueue\r\n    // is released.",
        "createdAt" : "2020-06-26T13:59:00Z",
        "updatedAt" : "2020-06-29T15:55:03Z",
        "lastEditedBy" : "6cd3c9bc-f261-444d-81ab-c00c917f2197",
        "tags" : [
        ]
      },
      {
        "id" : "c0e3bdb1-a7f8-48bb-9a8e-a2e8e68f8ccb",
        "parentId" : "47166f36-d43e-49c6-a8cf-ff096ccbe9b9",
        "authorId" : "335eabbd-4b70-43fb-a046-bf82995f5dd3",
        "body" : "I see.  Conversely the I/O thread is holding the lock for a long time/number-of-lines as it should.\r\n\r\nMaybe we ought to comment here why releasing the lock and re-acquiring 'soon' afterward is a gain.",
        "createdAt" : "2020-06-26T15:42:56Z",
        "updatedAt" : "2020-06-29T15:55:03Z",
        "lastEditedBy" : "335eabbd-4b70-43fb-a046-bf82995f5dd3",
        "tags" : [
        ]
      },
      {
        "id" : "1bd6d1ec-55b7-41de-b915-a0fbe3e70d6a",
        "parentId" : "47166f36-d43e-49c6-a8cf-ff096ccbe9b9",
        "authorId" : "6cd3c9bc-f261-444d-81ab-c00c917f2197",
        "body" : "I added a clarifying sentence to the comment: `We need to release the lock before potentially blocking on the cluster future.`",
        "createdAt" : "2020-06-29T15:55:32Z",
        "updatedAt" : "2020-06-29T15:55:32Z",
        "lastEditedBy" : "6cd3c9bc-f261-444d-81ab-c00c917f2197",
        "tags" : [
        ]
      }
    ],
    "commit" : "3c9e7c8ebfa10154ea784232e4e0490855cc14b0",
    "line" : 338,
    "diffHunk" : "@@ -1,1 +336,340 @@      }\n\n      std::lock_guard<std::mutex> lockGuardInFlightClusters(fLockWorkQueue);\n      fInFlightClusters.erase(itr);\n   }"
  }
]
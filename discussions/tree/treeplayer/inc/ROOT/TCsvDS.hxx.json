[
  {
    "id" : "88a7b34f-42a5-4d08-aec5-0e65913dcf22",
    "prId" : 1160,
    "prUrl" : "https://github.com/root-project/root/pull/1160#pullrequestreview-68817564",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "abb8ddbf-b004-4bfe-9ad0-72fc3dd4bf53",
        "parentId" : null,
        "authorId" : "28bf1eea-b1ed-4971-b001-9f6e3a5ec44f",
        "body" : "I am not an expert of csvs. Is it true that the separator can be only a single character?",
        "createdAt" : "2017-10-10T08:34:03Z",
        "updatedAt" : "2017-10-12T14:41:26Z",
        "lastEditedBy" : "28bf1eea-b1ed-4971-b001-9f6e3a5ec44f",
        "tags" : [
        ]
      },
      {
        "id" : "b94eb8b4-7292-4034-b684-5084aed47895",
        "parentId" : "abb8ddbf-b004-4bfe-9ad0-72fc3dd4bf53",
        "authorId" : "f2c15ca6-f995-45d3-a26d-40d002e52d07",
        "body" : "well, [rules as written](https://tools.ietf.org/html/rfc4180) there is only one true delimiter: comma. It's a reasonable extension to allow arbitrary characters as delimiters (and any number of white spaces in between!) but at least as a first approximation I'm not sure we need more than that",
        "createdAt" : "2017-10-10T14:35:57Z",
        "updatedAt" : "2017-10-12T14:41:26Z",
        "lastEditedBy" : "f2c15ca6-f995-45d3-a26d-40d002e52d07",
        "tags" : [
        ]
      },
      {
        "id" : "dc6c1b4a-d074-40b3-af92-64d67a4bfe3d",
        "parentId" : "abb8ddbf-b004-4bfe-9ad0-72fc3dd4bf53",
        "authorId" : "4c541c6e-f658-422b-9f5a-7ae0b2a9a1f5",
        "body" : "I think you both have a point, it is just a matter of deciding what we would like to support. I believe comma plus eventually some other character is enough for now, although extending it would not be a problem.",
        "createdAt" : "2017-10-10T14:46:12Z",
        "updatedAt" : "2017-10-12T14:41:26Z",
        "lastEditedBy" : "4c541c6e-f658-422b-9f5a-7ae0b2a9a1f5",
        "tags" : [
        ]
      },
      {
        "id" : "086d25dd-05eb-4c98-845b-5f36fed9c017",
        "parentId" : "abb8ddbf-b004-4bfe-9ad0-72fc3dd4bf53",
        "authorId" : "28bf1eea-b1ed-4971-b001-9f6e3a5ec44f",
        "body" : "I support this pragmatic approach.",
        "createdAt" : "2017-10-12T05:11:13Z",
        "updatedAt" : "2017-10-12T14:41:26Z",
        "lastEditedBy" : "28bf1eea-b1ed-4971-b001-9f6e3a5ec44f",
        "tags" : [
        ]
      }
    ],
    "commit" : "5f10d6ee69ae0901280349e284c5c03fcfc59bd9",
    "line" : 22,
    "diffHunk" : "@@ -1,1 +20,24 @@   unsigned int fNSlots = 0U;\n   std::string fFileName;\n   char fDelimiter;\n   std::vector<std::string> fHeaders;\n   std::map<std::string, std::string> fColTypes;"
  },
  {
    "id" : "a2c04892-93b6-41d4-b2fd-2ad16ec0c4a2",
    "prId" : 1558,
    "prUrl" : "https://github.com/root-project/root/pull/1558#pullrequestreview-91871426",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fd7975e7-a8ea-492f-9f46-4c373d4ee0a1",
        "parentId" : null,
        "authorId" : "4c541c6e-f658-422b-9f5a-7ae0b2a9a1f5",
        "body" : "Curiosity: what is the advantage of one vs the other?",
        "createdAt" : "2018-01-26T15:23:20Z",
        "updatedAt" : "2018-01-26T15:23:20Z",
        "lastEditedBy" : "4c541c6e-f658-422b-9f5a-7ae0b2a9a1f5",
        "tags" : [
        ]
      },
      {
        "id" : "69337998-3c51-4db8-bd8c-8bd9bfe8c74e",
        "parentId" : "fd7975e7-a8ea-492f-9f46-4c373d4ee0a1",
        "authorId" : "28bf1eea-b1ed-4971-b001-9f6e3a5ec44f",
        "body" : "In TDF we decided to adopt only aliases rather than typedefs. There are a few advantages of using aliases, e.g. enhanced clarity in some cases. In this particular case, it's just consistency with the rest of the code, no real advantage :-)",
        "createdAt" : "2018-01-26T15:28:08Z",
        "updatedAt" : "2018-01-26T15:28:09Z",
        "lastEditedBy" : "28bf1eea-b1ed-4971-b001-9f6e3a5ec44f",
        "tags" : [
        ]
      }
    ],
    "commit" : "e2b32f69fc6142862bee64f4cc2dd1d1f77bc631",
    "line" : 17,
    "diffHunk" : "@@ -1,1 +19,23 @@\nprivate:\n   using Record = std::vector<void *>;\n   // Possible values are d, b, l, s. This is possible only because we treat double, bool, Long64_t and string\n   using ColType_t = char;"
  }
]
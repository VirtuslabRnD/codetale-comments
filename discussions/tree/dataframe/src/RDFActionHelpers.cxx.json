[
  {
    "id" : "7c7e54b2-ea80-4356-b25e-431909d49d5a",
    "prId" : 2269,
    "prUrl" : "https://github.com/root-project/root/pull/2269#pullrequestreview-133279703",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1e38a1f6-d842-4796-b34b-28918cfa1198",
        "parentId" : null,
        "authorId" : "28bf1eea-b1ed-4971-b001-9f6e3a5ec44f",
        "body" : "Are we sure of this algorithm? Is it numerically stable? Can we avoid the division? Can we make it incremental?",
        "createdAt" : "2018-06-29T08:18:15Z",
        "updatedAt" : "2018-07-02T13:06:21Z",
        "lastEditedBy" : "28bf1eea-b1ed-4971-b001-9f6e3a5ec44f",
        "tags" : [
        ]
      },
      {
        "id" : "8028f815-9c98-41c5-af6e-47c34944c6ce",
        "parentId" : "1e38a1f6-d842-4796-b34b-28918cfa1198",
        "authorId" : "9c5b50e9-7e3c-4cab-9d54-e46d6831dd3b",
        "body" : "It's the Welford's algorithm. I think it is already incremental, as at the end of each step you know the partial result for the samples up to that point, and by the end you merge everything. I am going to investigate about the division.\r\n\r\n>  John D. Cook found the accuracy of this method comparable to the accuracy of the two-pass method derived directly from the definition [cit.](http://jonisalonen.com/2013/deriving-welfords-method-for-computing-variance/)\r\n\r\n> This algorithm is much less prone to loss of precision due to catastrophic cancellation, but might not be as efficient because of the division operation inside the loop. [cit.](https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#Online_algorithm)",
        "createdAt" : "2018-06-29T08:44:44Z",
        "updatedAt" : "2018-07-02T13:06:21Z",
        "lastEditedBy" : "9c5b50e9-7e3c-4cab-9d54-e46d6831dd3b",
        "tags" : [
        ]
      },
      {
        "id" : "9fdeecea-23b7-4644-8c04-950d4fa756ff",
        "parentId" : "1e38a1f6-d842-4796-b34b-28918cfa1198",
        "authorId" : "9c5b50e9-7e3c-4cab-9d54-e46d6831dd3b",
        "body" : "I followed @stwunsch suggestion and tried to run the Welford's algorithm against the deviation evaluated using its definition. Even for few samples (that should be the most critical part) the difference is in the order of ^-16. I suppose the algorithm is good.",
        "createdAt" : "2018-06-29T14:57:02Z",
        "updatedAt" : "2018-07-02T13:06:21Z",
        "lastEditedBy" : "9c5b50e9-7e3c-4cab-9d54-e46d6831dd3b",
        "tags" : [
        ]
      },
      {
        "id" : "98a0f554-90b4-4bd9-9424-ff8c3b130e3c",
        "parentId" : "1e38a1f6-d842-4796-b34b-28918cfa1198",
        "authorId" : "f2c15ca6-f995-45d3-a26d-40d002e52d07",
        "body" : "@imaxoi that's great. few samples are not necessarily the critical case, many samples might cause problems due to numerical instabilities in the summations.\r\n\r\nin any case, since you already have the code, can you make it a gtest?",
        "createdAt" : "2018-06-29T15:05:00Z",
        "updatedAt" : "2018-07-02T13:06:21Z",
        "lastEditedBy" : "f2c15ca6-f995-45d3-a26d-40d002e52d07",
        "tags" : [
        ]
      },
      {
        "id" : "2328a5ed-1980-425a-ba35-2c78cefd8ad4",
        "parentId" : "1e38a1f6-d842-4796-b34b-28918cfa1198",
        "authorId" : "9c5b50e9-7e3c-4cab-9d54-e46d6831dd3b",
        "body" : "Ok 7e0b87e641eacb69695083fd90c52dd65cdd2b45. \r\nIt can be easily adapted to the samples we want to test.\r\n",
        "createdAt" : "2018-06-29T15:44:45Z",
        "updatedAt" : "2018-07-02T13:06:21Z",
        "lastEditedBy" : "9c5b50e9-7e3c-4cab-9d54-e46d6831dd3b",
        "tags" : [
        ]
      }
    ],
    "commit" : "caf8a9c352efc07d9bb4c0e66cf5afdbc07a5558",
    "line" : 21,
    "diffHunk" : "@@ -1,1 +181,185 @@   fMeans[slot] = mean;\n   fDistancesfromMean[slot] = distance;\n}\n\nvoid StdDevHelper::Finalize()"
  },
  {
    "id" : "bd1eb44c-d5bf-4b28-bc8d-cae05b1a1890",
    "prId" : 5193,
    "prUrl" : "https://github.com/root-project/root/pull/5193#pullrequestreview-382041856",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5047b163-40f4-49be-aa98-e146b542f8eb",
        "parentId" : null,
        "authorId" : "ec1903c5-44e7-4fb1-bee9-25de61836fba",
        "body" : "Is the error for file mode `read` handled somewhere else?",
        "createdAt" : "2020-03-26T08:22:26Z",
        "updatedAt" : "2020-03-26T14:28:30Z",
        "lastEditedBy" : "ec1903c5-44e7-4fb1-bee9-25de61836fba",
        "tags" : [
        ]
      },
      {
        "id" : "e25d98fb-ad1f-456a-bf8a-6915b359f236",
        "parentId" : "5047b163-40f4-49be-aa98-e146b542f8eb",
        "authorId" : "f2c15ca6-f995-45d3-a26d-40d002e52d07",
        "body" : "The _real_ opening of `fileName` (by default in `recreate` mode: it's the output file of the `Snapshot`) is in `SnapshotHelper::Initialize` and `SnapshotHelperMT::Initialize`. We actually do not check that the opening went fine at the moment, but that's outside of the scope of this PR and the bug it tries to fix. That's now https://sft.its.cern.ch/jira/browse/ROOT-10639",
        "createdAt" : "2020-03-26T14:06:16Z",
        "updatedAt" : "2020-03-26T14:28:30Z",
        "lastEditedBy" : "f2c15ca6-f995-45d3-a26d-40d002e52d07",
        "tags" : [
        ]
      }
    ],
    "commit" : "bc8a9e414dfd3f927a2fa4d13f307a369a6ebce8",
    "line" : 9,
    "diffHunk" : "@@ -1,1 +239,243 @@   fileMode.ToLower();\n   if (fileMode != \"update\")\n      return;\n\n   // output file opened in \"update\" mode: must check whether output TTree is already present in file"
  }
]
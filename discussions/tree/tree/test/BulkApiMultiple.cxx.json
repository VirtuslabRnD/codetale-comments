[
  {
    "id" : "3b219789-d698-4de6-9375-ed5f8891a3ee",
    "prId" : 8325,
    "prUrl" : "https://github.com/root-project/root/pull/8325#pullrequestreview-678644789",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "28a33f03-a0dc-40c6-bb2d-a7f56a14d92a",
        "parentId" : null,
        "authorId" : "09b7e073-cbeb-42e8-aa22-8b1468de56ae",
        "body" : "This leaves valgrind no chance, and might get valid looking values to users where in fact some I/O logic has failed. Consider leaving those uninitialized.",
        "createdAt" : "2021-06-08T15:04:23Z",
        "updatedAt" : "2021-06-08T15:04:23Z",
        "lastEditedBy" : "09b7e073-cbeb-42e8-aa22-8b1468de56ae",
        "tags" : [
        ]
      },
      {
        "id" : "72fd210c-2b7e-4278-88f7-d3664c2ffc6a",
        "parentId" : "28a33f03-a0dc-40c6-bb2d-a7f56a14d92a",
        "authorId" : "09b7e073-cbeb-42e8-aa22-8b1468de56ae",
        "body" : "Argh it's a test.",
        "createdAt" : "2021-06-08T15:04:57Z",
        "updatedAt" : "2021-06-08T15:04:58Z",
        "lastEditedBy" : "09b7e073-cbeb-42e8-aa22-8b1468de56ae",
        "tags" : [
        ]
      }
    ],
    "commit" : "ad849ee35ff6c44ab87c610ce082e38e18a291da",
    "line" : 29,
    "diffHunk" : "@@ -1,1 +37,41 @@      int i = 5;\n      Long64_t ll = (1<<20) + 1;\n      char c = 7;\n\n      TBranch *branch2 = tree->Branch(\"myFloat\", &f, 320000, 1);"
  },
  {
    "id" : "5022b4e0-d957-4f9d-93cb-211505d2473a",
    "prId" : 8325,
    "prUrl" : "https://github.com/root-project/root/pull/8325#pullrequestreview-679814591",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d071b394-0d33-4b10-a277-6e98d359c9e2",
        "parentId" : null,
        "authorId" : "09b7e073-cbeb-42e8-aa22-8b1468de56ae",
        "body" : "That can still fail the comparison `(ULong64_t)14.999998 == (ULong64_t)15.000001`. As you use the same increments for filling and testing (consecutive `++`) it might be okay...",
        "createdAt" : "2021-06-09T07:57:28Z",
        "updatedAt" : "2021-06-09T07:57:28Z",
        "lastEditedBy" : "09b7e073-cbeb-42e8-aa22-8b1468de56ae",
        "tags" : [
        ]
      },
      {
        "id" : "0d0ccb67-4ff4-48a1-9c13-65b6b1ed21e2",
        "parentId" : "d071b394-0d33-4b10-a277-6e98d359c9e2",
        "authorId" : "335eabbd-4b70-43fb-a046-bf82995f5dd3",
        "body" : "Yes, the same increment strategy is assumed/required.",
        "createdAt" : "2021-06-09T15:27:34Z",
        "updatedAt" : "2021-06-09T15:27:35Z",
        "lastEditedBy" : "335eabbd-4b70-43fb-a046-bf82995f5dd3",
        "tags" : [
        ]
      }
    ],
    "commit" : "ad849ee35ff6c44ab87c610ce082e38e18a291da",
    "line" : 112,
    "diffHunk" : "@@ -1,1 +119,123 @@bool compare(T value, T expected)\n{\n   return (ULong64_t)value == (ULong64_t)expected;\n}\n"
  },
  {
    "id" : "bac36965-4841-460b-bebe-925bcf27ab7a",
    "prId" : 8325,
    "prUrl" : "https://github.com/root-project/root/pull/8325#pullrequestreview-679335510",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ca464432-7314-4b21-91bc-54fd629d44db",
        "parentId" : null,
        "authorId" : "09b7e073-cbeb-42e8-aa22-8b1468de56ae",
        "body" : "Is there a reason not to check also for this interface\r\n```suggestion\r\n   sw.Stop();\r\n   EXPECT_EQ(BulkApiMultipleTest::fEventCount, evt_idx);\r\n```",
        "createdAt" : "2021-06-09T08:03:49Z",
        "updatedAt" : "2021-06-09T08:03:49Z",
        "lastEditedBy" : "09b7e073-cbeb-42e8-aa22-8b1468de56ae",
        "tags" : [
        ]
      }
    ],
    "commit" : "ad849ee35ff6c44ab87c610ce082e38e18a291da",
    "line" : 227,
    "diffHunk" : "@@ -1,1 +234,238 @@      evt_idx += count;\n   }\n   sw.Stop();\n   EXPECT_EQ(BulkApiMultipleTest::fEventCount, evt_idx);\n   printf(\"GetBulkEntries: Successful read of all events in %s.\\n\", treename);"
  },
  {
    "id" : "4be81192-8646-4bc0-8a66-0bee9c4518d0",
    "prId" : 8325,
    "prUrl" : "https://github.com/root-project/root/pull/8325#pullrequestreview-679817542",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "71dd8990-4946-484b-b56b-0892a4fdbf89",
        "parentId" : null,
        "authorId" : "09b7e073-cbeb-42e8-aa22-8b1468de56ae",
        "body" : "These should really all be `EXPECT_TRUE`: `ASSERT` ends the program right here if it fails, makes sense for `nullptr` checks of pointers used later, not so for these consistency checks where it's interesting to see whether a change causes tons of comparisons to fail or just one.",
        "createdAt" : "2021-06-09T08:05:39Z",
        "updatedAt" : "2021-06-09T08:05:39Z",
        "lastEditedBy" : "09b7e073-cbeb-42e8-aa22-8b1468de56ae",
        "tags" : [
        ]
      },
      {
        "id" : "5d68244e-fd21-40c5-9b96-f770a23a2e12",
        "parentId" : "71dd8990-4946-484b-b56b-0892a4fdbf89",
        "authorId" : "335eabbd-4b70-43fb-a046-bf82995f5dd3",
        "body" : "The original code had the assert.  The 'interesting' question is whether the ton of message is useful information.   Here, I expect that if the first comparison fails, every single ones will fail (i.e. 10e7 messages).\r\nNote that it seems that the `ASSERT_*` only quit the test and not the program.",
        "createdAt" : "2021-06-09T15:30:00Z",
        "updatedAt" : "2021-06-09T15:30:01Z",
        "lastEditedBy" : "335eabbd-4b70-43fb-a046-bf82995f5dd3",
        "tags" : [
        ]
      }
    ],
    "commit" : "ad849ee35ff6c44ab87c610ce082e38e18a291da",
    "line" : 295,
    "diffHunk" : "@@ -1,1 +295,299 @@   while (myReader.Next()) {\n      if (R__unlikely(idx == events)) {break;}\n      ASSERT_TRUE(compare(*myF, idx_f))\n         << \"Incorrect value on myFloat branch: \" << *myF << \", expected \" << idx_f  << \" (event \" << idx << \")\\n\";\n      ASSERT_TRUE(compare(*myG, idx_g))"
  }
]
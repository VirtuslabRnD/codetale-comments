[
  {
    "id" : "3c5f0baa-54b2-4c5f-a723-9364348dfbc8",
    "prId" : 14924,
    "prUrl" : "https://github.com/numpy/numpy/pull/14924#pullrequestreview-398658136",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c87e487a-869c-4e56-a3dc-ced164b7f2f8",
        "parentId" : null,
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "```suggestion\r\n            alpha_csum = np.cumsum(alpha[::-1])[::-1]\r\n            alpha_csum_arr = <np.ndarray>np.PyArray_FROM_OTF(alpha_csum,\r\n                np.NPY_DOUBLE, np.NPY_ALIGNED | np.NPY_ARRAY_C_CONTIGUOUS)\r\n            alpha_csum_data = <double*>np.PyArray_DATA(alpha_csum_arr)\r\n\r\n            with self.lock, nogil:\r\n```",
        "createdAt" : "2020-04-22T23:24:56Z",
        "updatedAt" : "2020-04-28T03:34:46Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      }
    ],
    "commit" : "6b181c8e607f35b0de1a6a12dd280ddf2bc439f5",
    "line" : 73,
    "diffHunk" : "@@ -1,1 +4196,4200 @@                alpha_csum_data[j] = csum\n\n            with self.lock, nogil:\n                while i < totsize:\n                    acc = 1."
  },
  {
    "id" : "4bbcb0a3-eabd-4cd1-a109-c53a7c25b21d",
    "prId" : 14924,
    "prUrl" : "https://github.com/numpy/numpy/pull/14924#pullrequestreview-401473994",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8aa069a6-340a-489e-a378-1de5ff65151f",
        "parentId" : null,
        "authorId" : "8de63a41-1bc1-4e93-a2df-4f2f940433cf",
        "body" : "```suggestion\r\n        cdef np.ndarray alpha_arr, val_arr, alpha_csum_arr\r\n        cdef double csum\r\n```",
        "createdAt" : "2020-04-28T03:33:40Z",
        "updatedAt" : "2020-04-28T03:34:46Z",
        "lastEditedBy" : "8de63a41-1bc1-4e93-a2df-4f2f940433cf",
        "tags" : [
        ]
      }
    ],
    "commit" : "6b181c8e607f35b0de1a6a12dd280ddf2bc439f5",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +4125,4129 @@\n        cdef np.npy_intp k, totsize, i, j\n        cdef np.ndarray alpha_arr, val_arr, alpha_csum_arr\n        cdef double csum\n        cdef double *alpha_data"
  },
  {
    "id" : "8dc54b4f-a9fa-4a28-904f-d2e6afa5846b",
    "prId" : 15121,
    "prUrl" : "https://github.com/numpy/numpy/pull/15121#pullrequestreview-467082661",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "749599c7-2517-4f92-93bf-46b24d5272ae",
        "parentId" : null,
        "authorId" : "b15cf1a1-ba9d-47aa-b157-e0c1f40c5c5c",
        "body" : "Should these support tuple[int] as well, e.g.,\r\n\r\n```\r\ngen = default_rng()\r\nx = gen.standard_normal(5,6,7)\r\ngen.randomly_permute(x, axis=(0,1)):\r\n```\r\n\r\nwhich would shuffle the element for each pair of the first 2 axes.\r\n\r\n",
        "createdAt" : "2019-12-21T00:24:09Z",
        "updatedAt" : "2020-08-21T04:18:30Z",
        "lastEditedBy" : "b15cf1a1-ba9d-47aa-b157-e0c1f40c5c5c",
        "tags" : [
        ]
      },
      {
        "id" : "904532bd-cfa9-41f6-8b70-025e197bf2de",
        "parentId" : "749599c7-2517-4f92-93bf-46b24d5272ae",
        "authorId" : "8de63a41-1bc1-4e93-a2df-4f2f940433cf",
        "body" : "That could be added (but I haven't looked into how hard it would be).  I'm not sure how to interpret \"which would shuffle the element for each pair of the first 2 axes.\"  I would expect that example to shuffle the elements within the 2-d slices. That is, after the call, `x[:, :, 0]` contains the same elements as before the call, but shuffled, and the shuffle is applied to the flattened slice (so any given element could end up anywhere in the 2-d slice). Likewise for `x[:,:,1]`, etc.",
        "createdAt" : "2020-07-02T03:18:57Z",
        "updatedAt" : "2020-08-21T04:18:30Z",
        "lastEditedBy" : "8de63a41-1bc1-4e93-a2df-4f2f940433cf",
        "tags" : [
        ]
      },
      {
        "id" : "2b686964-9591-468f-9756-ae2d2764392b",
        "parentId" : "749599c7-2517-4f92-93bf-46b24d5272ae",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "I agree that is the correct generalization, but am happy to only support `None` and a single int for now (with `None` effectively being the same as `range(ndim)` here).",
        "createdAt" : "2020-08-05T19:45:17Z",
        "updatedAt" : "2020-08-21T04:18:30Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "73e4ac92-1399-4827-906a-1bcbe8878e48",
        "parentId" : "749599c7-2517-4f92-93bf-46b24d5272ae",
        "authorId" : "8de63a41-1bc1-4e93-a2df-4f2f940433cf",
        "body" : "OK, for now I'll stick with None or a single integer, and leave handling of a tuple as a future enhancement.",
        "createdAt" : "2020-08-13T19:52:21Z",
        "updatedAt" : "2020-08-21T04:18:30Z",
        "lastEditedBy" : "8de63a41-1bc1-4e93-a2df-4f2f940433cf",
        "tags" : [
        ]
      }
    ],
    "commit" : "785e23901f5b84d677f04f4446449fabbc7575bf",
    "line" : 138,
    "diffHunk" : "@@ -1,1 +4207,4211 @@        x : array_like, at least one-dimensional\n            Array to be shuffled.\n        axis : int, optional\n            Slices of `x` in this axis are shuffled. Each slice\n            is shuffled independently of the others.  If `axis` is"
  },
  {
    "id" : "ed576e3d-6b04-47ba-9c01-7595ecce59b7",
    "prId" : 15121,
    "prUrl" : "https://github.com/numpy/numpy/pull/15121#pullrequestreview-449082734",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "202b2f63-d6a8-4382-805c-1f9eebcb23e8",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "What does passing `first=0` mean? It seems to me it's identical to `first = 1`.\r\n",
        "createdAt" : "2020-07-15T15:34:56Z",
        "updatedAt" : "2020-08-21T04:18:30Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "0722045c-99cf-4007-aa19-4b2eb4cd5e08",
        "parentId" : "202b2f63-d6a8-4382-805c-1f9eebcb23e8",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Given the only two callers pass either `0` or `1`, can this argument just be removed?",
        "createdAt" : "2020-07-15T15:39:16Z",
        "updatedAt" : "2020-08-21T04:18:30Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "b825bfe3-83ef-4bab-9517-e1cb0b6e463a",
        "parentId" : "202b2f63-d6a8-4382-805c-1f9eebcb23e8",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "nevermind, I see this function was just moved.",
        "createdAt" : "2020-07-15T15:41:09Z",
        "updatedAt" : "2020-08-21T04:18:30Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "785e23901f5b84d677f04f4446449fabbc7575bf",
    "line" : 53,
    "diffHunk" : "@@ -1,1 +84,88 @@        First observation to shuffle.  Shuffles n-1,\n        n-2, ..., first, so that when first=1 the entire\n        array is shuffled\n    itemsize\n        Size in bytes of item"
  },
  {
    "id" : "39e708d2-7118-4873-9e96-f341ca288dbe",
    "prId" : 15121,
    "prUrl" : "https://github.com/numpy/numpy/pull/15121#pullrequestreview-452759700",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4450be5f-aee4-4209-8f58-7cb94cd07440",
        "parentId" : null,
        "authorId" : "b15cf1a1-ba9d-47aa-b157-e0c1f40c5c5c",
        "body" : "Does x need to have any storage requirements? Contiguous or C contiguous?",
        "createdAt" : "2020-07-15T16:43:01Z",
        "updatedAt" : "2020-08-21T04:18:30Z",
        "lastEditedBy" : "b15cf1a1-ba9d-47aa-b157-e0c1f40c5c5c",
        "tags" : [
        ]
      },
      {
        "id" : "9f088c37-fcc8-47a3-b543-9b4915b07082",
        "parentId" : "4450be5f-aee4-4209-8f58-7cb94cd07440",
        "authorId" : "8de63a41-1bc1-4e93-a2df-4f2f940433cf",
        "body" : "The code should handle non-contiguous arrays.  I added a unit test that applies `permuted` to an array with nontrivial strides.",
        "createdAt" : "2020-07-21T19:21:15Z",
        "updatedAt" : "2020-08-21T04:18:30Z",
        "lastEditedBy" : "8de63a41-1bc1-4e93-a2df-4f2f940433cf",
        "tags" : [
        ]
      }
    ],
    "commit" : "785e23901f5b84d677f04f4446449fabbc7575bf",
    "line" : 211,
    "diffHunk" : "@@ -1,1 +4280,4284 @@        cdef int flags\n\n        x = np.asarray(x)\n\n        if out is None:"
  },
  {
    "id" : "f060f1af-6580-42a4-889e-e41659e43662",
    "prId" : 15121,
    "prUrl" : "https://github.com/numpy/numpy/pull/15121#pullrequestreview-467898360",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3c369c4b-b491-4716-8f70-7b3695deabcc",
        "parentId" : null,
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Hmmm, this is probably pretty slow, since it works by using the sequence-like flat-iterator. But I guess that is fine, it would be easy to change.  I am a bit curious whether we are OK with changes in the output if we adapt this to non C-order array. I.e. if we update this at some point, we are OK, if the result differs when `out` is not C-order, right?",
        "createdAt" : "2020-08-05T19:35:46Z",
        "updatedAt" : "2020-08-21T04:18:30Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "9292aeb6-8011-416e-a87e-467e524a835a",
        "parentId" : "3c369c4b-b491-4716-8f70-7b3695deabcc",
        "authorId" : "b15cf1a1-ba9d-47aa-b157-e0c1f40c5c5c",
        "body" : "Should you special case the common C-contiguous non-strided case with a reshape?",
        "createdAt" : "2020-08-06T12:57:18Z",
        "updatedAt" : "2020-08-21T04:18:30Z",
        "lastEditedBy" : "b15cf1a1-ba9d-47aa-b157-e0c1f40c5c5c",
        "tags" : [
        ]
      },
      {
        "id" : "0c63fc79-d0a2-49ea-987e-98dab1b2dd4f",
        "parentId" : "3c369c4b-b491-4716-8f70-7b3695deabcc",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Does this work at all? I'd worry that `shuffle(out.flat)` makes a copy of `out.flat`",
        "createdAt" : "2020-08-06T14:42:47Z",
        "updatedAt" : "2020-08-21T04:18:30Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "ecccd6cf-4d45-4ff4-81c1-253e864b1dfa",
        "parentId" : "3c369c4b-b491-4716-8f70-7b3695deabcc",
        "authorId" : "8de63a41-1bc1-4e93-a2df-4f2f940433cf",
        "body" : "@seberg, this is admittedly a \"quick and dirty\" implementation (where \"quick\" refers to implementation time, not execution time).  Is there an existing pattern in the NumPy API for treating an n-d array (with arbitrary strides) as a 1-d array that would better here?  I can implement *something*, but it would be great if there is already a nice way to do it.\r\n\r\n@bashtage, yes, with `axis=None`, a fast path for the contiguous case (either C- or F-, actually) should be pretty easy.\r\n\r\n@eric-wieser, I've tested it using arrays with various strides, and it has worked, but maybe I'm just blind to an obvious counter-example.  Are there specific tests you think would be good to check?",
        "createdAt" : "2020-08-13T22:10:59Z",
        "updatedAt" : "2020-08-21T04:18:30Z",
        "lastEditedBy" : "8de63a41-1bc1-4e93-a2df-4f2f940433cf",
        "tags" : [
        ]
      },
      {
        "id" : "8f0f8d0a-e3b3-4774-9622-661f93d0a3d6",
        "parentId" : "3c369c4b-b491-4716-8f70-7b3695deabcc",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "@WarrenWeckesser I think the easiest solution is probably to use some nitty-gritty C-API (I assume contiguity does not matter, only 1-D does), there are a few \"KeepOrder\" cases which this misses, I think `ravel()` may actually support \"K\", unlike `reshape`, so both have their advantages (and I don't care for which way)\r\n\r\n```\r\nto_shuffle = out.reshape(-1, order=\"A\")\r\nif to_shuffle.flags.owndata:\r\n    PyArray_SetWritebackIfCopyBase(to_shuffle, out)\r\n\r\nself.shuffle(to_shuffle)\r\n\r\nif to_shuffle.flags.writebackifcopy:\r\n    PyArray_ResolveWritebackIfCopy(to_shuffle) \r\n```\r\nI have not confirmed that this is the correct pattern, it certainly isn't correct code as-is.\r\n\r\nEDIT: To be clear with \"misses\" I just mean: `to_shuffle` does an *unnecessary* copy, the pattern always works.",
        "createdAt" : "2020-08-13T22:25:02Z",
        "updatedAt" : "2020-08-21T04:18:30Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "10b8e7d7-5386-4876-a291-c9f89b6474ed",
        "parentId" : "3c369c4b-b491-4716-8f70-7b3695deabcc",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "I am also not sure that checking for \"owndata\" is a great approach to find out whether the ravel/reshape was in-place, although I doubt it can fail here (since these are all plain `ndarray`s)",
        "createdAt" : "2020-08-13T22:30:01Z",
        "updatedAt" : "2020-08-21T04:18:30Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "14175f7f-5cdf-4534-a637-d3ec05acc872",
        "parentId" : "3c369c4b-b491-4716-8f70-7b3695deabcc",
        "authorId" : "8de63a41-1bc1-4e93-a2df-4f2f940433cf",
        "body" : "Thanks @seberg, I wouldn't have known to use those functions.\r\n\r\nThe `owndata` flag might not be the right way to check whether a copy was made.  In the following, `y` gets a copy of the data, but `y.flags.owndata` is False:\r\n\r\n```\r\nIn [286]: x = np.arange(24).reshape(3, 8)[:, ::-1]\r\n\r\nIn [287]: x\r\nOut[287]: \r\narray([[ 7,  6,  5,  4,  3,  2,  1,  0],\r\n       [15, 14, 13, 12, 11, 10,  9,  8],\r\n       [23, 22, 21, 20, 19, 18, 17, 16]])\r\n\r\nIn [288]: x.strides\r\nOut[288]: (64, -8)\r\n\r\nIn [289]: y = x.reshape(-1, order='A')\r\n\r\nIn [290]: y.flags.owndata\r\nOut[290]: False\r\n```",
        "createdAt" : "2020-08-13T23:18:05Z",
        "updatedAt" : "2020-08-21T04:18:30Z",
        "lastEditedBy" : "8de63a41-1bc1-4e93-a2df-4f2f940433cf",
        "tags" : [
        ]
      },
      {
        "id" : "e2c63036-9ccb-434a-8bb4-afdd72256079",
        "parentId" : "3c369c4b-b491-4716-8f70-7b3695deabcc",
        "authorId" : "8de63a41-1bc1-4e93-a2df-4f2f940433cf",
        "body" : "Is`PyArray_SetWritebackIfCopyBase` include in the Cython headers for the NumPy C API? I can't get the code to recognize it as a C function.  If I use `np.PyArray_SetWritebackIfCopyBase`, I get `AttributeError: module 'numpy' has no attribute 'PyArray_SetWritebackIfCopyBase'` when I run the code.  If I add `cimport numpy as cnp` (which I wish we did all the time!) and use `cnp.PyArray_SetWritebackIfCopyBase`, cython report this when building: `_generator.pyx:4277:28: cimported module has no attribute 'PyArray_SetWritebackIfCopyBase'` \r\n",
        "createdAt" : "2020-08-14T00:32:47Z",
        "updatedAt" : "2020-08-21T04:18:30Z",
        "lastEditedBy" : "8de63a41-1bc1-4e93-a2df-4f2f940433cf",
        "tags" : [
        ]
      },
      {
        "id" : "2968c5ab-9216-4514-8c17-90fa0ad31e49",
        "parentId" : "3c369c4b-b491-4716-8f70-7b3695deabcc",
        "authorId" : "8de63a41-1bc1-4e93-a2df-4f2f940433cf",
        "body" : "Answering my own question: `PyArray_SetWritebackIfCopyBase` and `PyArray_ResolveWritebackIfCopy` are not in the NumPy .pxd files provided by cython 0.29.21.",
        "createdAt" : "2020-08-14T00:42:05Z",
        "updatedAt" : "2020-08-21T04:18:30Z",
        "lastEditedBy" : "8de63a41-1bc1-4e93-a2df-4f2f940433cf",
        "tags" : [
        ]
      },
      {
        "id" : "b867e7ee-b865-433c-89c7-dc65cd10fcb5",
        "parentId" : "3c369c4b-b491-4716-8f70-7b3695deabcc",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Hmmm, would have expected those to exist, but if not, I guess we could either add them or define them just for this, @mattip we probably just forgot to add them to the `pyd` (or cython never add them?)\r\n\r\nOne thing: I guess you actually have to create a contigous copy (on which you set the writebackifcopy), and then pass the ravelled version (if the reshape/ravel fails).  I am also a bit unsure if the *if copy* logic there",
        "createdAt" : "2020-08-14T00:51:03Z",
        "updatedAt" : "2020-08-21T04:18:30Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "42eb276f-d3fa-44c2-b7c3-dddd6c98fb31",
        "parentId" : "3c369c4b-b491-4716-8f70-7b3695deabcc",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "In fact, for simplicity you do not need to use `np.PyArray_SetWritebackIfCopyBase` at all: Just use the normal `PyArray_FromArray` with the writeback-if-copy flag and call `PyArray_ResolveWritebackIfCopy` unconditionally.",
        "createdAt" : "2020-08-14T00:58:02Z",
        "updatedAt" : "2020-08-21T04:18:30Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "75161d8c-0ebb-43f2-a266-1d1d36731473",
        "parentId" : "3c369c4b-b491-4716-8f70-7b3695deabcc",
        "authorId" : "8de63a41-1bc1-4e93-a2df-4f2f940433cf",
        "body" : "For now, I've added this to `_generator.pyx`:\r\n```\r\ncdef extern from \"numpy/arrayobject.h\":\r\n    int PyArray_SetWritebackIfCopyBase(np.ndarray, np.ndarray)\r\n    int PyArray_ResolveWritebackIfCopy(np.ndarray)\r\n```",
        "createdAt" : "2020-08-14T00:58:12Z",
        "updatedAt" : "2020-08-21T04:18:30Z",
        "lastEditedBy" : "8de63a41-1bc1-4e93-a2df-4f2f940433cf",
        "tags" : [
        ]
      },
      {
        "id" : "d5fef17e-ef29-4d79-b57c-27bde8c03bba",
        "parentId" : "3c369c4b-b491-4716-8f70-7b3695deabcc",
        "authorId" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "body" : "I think the intention was to try to keep those as internal APIs as much as possible, so if they are needed putting them in `_generator.pyx` seems like a good solution. In general, shouldn't `nditer` be a better solution?",
        "createdAt" : "2020-08-14T08:37:17Z",
        "updatedAt" : "2020-08-21T04:18:30Z",
        "lastEditedBy" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "tags" : [
        ]
      },
      {
        "id" : "0d5515bb-f6e3-40e6-86a5-06498b61f4bc",
        "parentId" : "3c369c4b-b491-4716-8f70-7b3695deabcc",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "> @eric-wieser, I've tested it using arrays with various strides, and it has worked, but maybe I'm just blind to an obvious counter-example.\r\n\r\nI should have looked at the source code - `shuffle` has a special unoptimized code path for shuffling non-array sequences.",
        "createdAt" : "2020-08-14T08:55:54Z",
        "updatedAt" : "2020-08-21T04:18:30Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "1f27564d-ee3c-4f8e-8025-1fc7229b0bdf",
        "parentId" : "3c369c4b-b491-4716-8f70-7b3695deabcc",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "> In general, shouldn't `nditer` be a better solution?\r\n\r\nAgreed - it seems like we could have an nditer loop, and call `_shuffle_raw` inside it.\r\n\r\n",
        "createdAt" : "2020-08-14T08:56:47Z",
        "updatedAt" : "2020-08-21T04:18:30Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "ac095d7f-d6cb-41bf-88b9-b228cd97600f",
        "parentId" : "3c369c4b-b491-4716-8f70-7b3695deabcc",
        "authorId" : "8de63a41-1bc1-4e93-a2df-4f2f940433cf",
        "body" : "What are the advantages of an `nditer` loop over using `PyArray_IterAllButAxis`?  That's not a rhetorical question--I could use some education here.  Presumably `nditer` (or the corresponding C API) already includes the machinery for handling `axis` being a tuple (is that correct?), but are there other advantages?  Can anyone point to an example of using `nditer` (or the C API) that iterates over slices determined by an `axis` argument?  ",
        "createdAt" : "2020-08-14T14:07:23Z",
        "updatedAt" : "2020-08-21T04:18:30Z",
        "lastEditedBy" : "8de63a41-1bc1-4e93-a2df-4f2f940433cf",
        "tags" : [
        ]
      },
      {
        "id" : "33007892-fbb0-40b0-aab1-241fd4d1c0ad",
        "parentId" : "3c369c4b-b491-4716-8f70-7b3695deabcc",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "I don't see that works, you need to shuffle the *whole* array, I am not aware that it is possible to shuffle in chunks :).",
        "createdAt" : "2020-08-14T14:18:38Z",
        "updatedAt" : "2020-08-21T04:18:30Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "c5fe149d-be7c-491a-abba-0e6870e64079",
        "parentId" : "3c369c4b-b491-4716-8f70-7b3695deabcc",
        "authorId" : "8de63a41-1bc1-4e93-a2df-4f2f940433cf",
        "body" : "*\"I don't see that works,...\"*  What does *that* refer to?  The use of `nditer`?",
        "createdAt" : "2020-08-14T14:36:27Z",
        "updatedAt" : "2020-08-21T04:18:30Z",
        "lastEditedBy" : "8de63a41-1bc1-4e93-a2df-4f2f940433cf",
        "tags" : [
        ]
      },
      {
        "id" : "3de12f55-ddee-4e61-b071-009945f70682",
        "parentId" : "3c369c4b-b491-4716-8f70-7b3695deabcc",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Yes, sorry. nditer chunks iteration when it doesn't fit the 1-d slice layout.",
        "createdAt" : "2020-08-14T14:38:29Z",
        "updatedAt" : "2020-08-21T04:18:30Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "7f8ff77f-5d80-470e-aeba-4e0cefc7ecba",
        "parentId" : "3c369c4b-b491-4716-8f70-7b3695deabcc",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Sorry, need more coffee apparently, it is possible, since you can request a contiguous array. At that point you are using `NpyIter` for nothing else then the `writebackifcopy` logic, but it may be fair to do that anyway and accept the cost just to avoid `writebackifcopy` API.",
        "createdAt" : "2020-08-14T14:43:32Z",
        "updatedAt" : "2020-08-21T04:18:30Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "bea900b5-746b-4f4e-a3fc-9557967cfaa0",
        "parentId" : "3c369c4b-b491-4716-8f70-7b3695deabcc",
        "authorId" : "8de63a41-1bc1-4e93-a2df-4f2f940433cf",
        "body" : "Wait, are y'all talking about trying to use `nditer` in this special case where `axis=None`?  I assumed that suggestion applied to the main loop below.\r\n\r\nLocally (but not pushed yet), I've modified the code to not use the one-liner `self.shuffle(out.flat)` when `axis` is None.  I added special casing for contiguous arrays, so I only use the `writebackifcopy` machinery when `axis` is None, `ndim > 1`, and the array is not contiguous (that is not C-contiguous and not F-contiguous).",
        "createdAt" : "2020-08-14T14:56:32Z",
        "updatedAt" : "2020-08-21T04:18:30Z",
        "lastEditedBy" : "8de63a41-1bc1-4e93-a2df-4f2f940433cf",
        "tags" : [
        ]
      },
      {
        "id" : "b6547e51-6478-4d5b-a3fd-76cace61271d",
        "parentId" : "3c369c4b-b491-4716-8f70-7b3695deabcc",
        "authorId" : "8de63a41-1bc1-4e93-a2df-4f2f940433cf",
        "body" : "I pushed an update with new handling of the case `axis=None`.",
        "createdAt" : "2020-08-14T15:40:29Z",
        "updatedAt" : "2020-08-21T04:18:30Z",
        "lastEditedBy" : "8de63a41-1bc1-4e93-a2df-4f2f940433cf",
        "tags" : [
        ]
      },
      {
        "id" : "9ee1030c-72bb-4df5-87cf-61498447f4d5",
        "parentId" : "3c369c4b-b491-4716-8f70-7b3695deabcc",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Thanks, for me the current solution is fine, and the discussion can be resolved.",
        "createdAt" : "2020-08-14T22:04:32Z",
        "updatedAt" : "2020-08-21T04:18:30Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      }
    ],
    "commit" : "785e23901f5b84d677f04f4446449fabbc7575bf",
    "line" : 243,
    "diffHunk" : "@@ -1,1 +4312,4316 @@                # out is 1-d\n                self.shuffle(out)\n            return out\n\n        ax = normalize_axis_index(axis, np.ndim(out))"
  },
  {
    "id" : "0d242a46-b03b-4cd9-97b5-6a1b07a71c61",
    "prId" : 15121,
    "prUrl" : "https://github.com/numpy/numpy/pull/15121#pullrequestreview-461958531",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "68502a3d-a610-4188-ac95-7c37b33b0c3e",
        "parentId" : null,
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Do we typically support subclasses for `out`? I am happy with simply ignoring that for now though. It would be incorrect e.g. for masked arrays (but that is common).",
        "createdAt" : "2020-08-05T19:47:14Z",
        "updatedAt" : "2020-08-21T04:18:30Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      }
    ],
    "commit" : "785e23901f5b84d677f04f4446449fabbc7575bf",
    "line" : 216,
    "diffHunk" : "@@ -1,1 +4285,4289 @@            out = x.copy(order='K')\n        else:\n            if type(out) is not np.ndarray:\n                raise TypeError('out must be a numpy array')\n            if out.shape != x.shape:"
  },
  {
    "id" : "90474601-14d8-484f-a1e9-ea068e58f3aa",
    "prId" : 15121,
    "prUrl" : "https://github.com/numpy/numpy/pull/15121#pullrequestreview-478722036",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "03a43eb9-8904-4f51-b7ea-d1dccf328d02",
        "parentId" : null,
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "```suggestion\r\ncdef void _shuffle_raw_wrap(bitgen_t *bitgen, np.npy_intp n,\r\n```\r\nMight be worth timing, but I guess we don't actually have to specify `inline` here.  The important part is that `shuffle_raw` is inlined, the single call overhead is probably fairly insignificant, and will mean that `_shuffle_raw` will certainly not be pasted 4 times. (I am a bit curious if the compiler might even decide *not* to inline, and thus breaking the trick.)",
        "createdAt" : "2020-08-31T15:36:48Z",
        "updatedAt" : "2020-08-31T15:58:45Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "4ac3ffc1-32bf-4ab0-aaee-4b6e0e1af145",
        "parentId" : "03a43eb9-8904-4f51-b7ea-d1dccf328d02",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "But, `_shuffle_raw` is such a short function, that I guess it doesn't matter.",
        "createdAt" : "2020-08-31T15:37:38Z",
        "updatedAt" : "2020-08-31T15:58:45Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      }
    ],
    "commit" : "785e23901f5b84d677f04f4446449fabbc7575bf",
    "line" : 26,
    "diffHunk" : "@@ -1,1 +57,61 @@\n\ncdef inline void _shuffle_raw_wrap(bitgen_t *bitgen, np.npy_intp n,\n                                   np.npy_intp first, np.npy_intp itemsize,\n                                   np.npy_intp stride,"
  },
  {
    "id" : "cedc3f37-35fd-485d-b6be-e18c3b05ae19",
    "prId" : 15121,
    "prUrl" : "https://github.com/numpy/numpy/pull/15121#pullrequestreview-478722036",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b3c16dc7-5fdd-4e41-9931-e2eb0f5b259b",
        "parentId" : null,
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "```suggestion\r\n    int PyArray_ResolveWritebackIfCopy(np.ndarray) except -1\r\n```",
        "createdAt" : "2020-08-31T15:49:32Z",
        "updatedAt" : "2020-08-31T15:58:45Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      }
    ],
    "commit" : "785e23901f5b84d677f04f4446449fabbc7575bf",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +31,35 @@\ncdef extern from \"numpy/arrayobject.h\":\n    int PyArray_ResolveWritebackIfCopy(np.ndarray)\n    object PyArray_FromArray(np.PyArrayObject *, np.PyArray_Descr *, int)\n"
  },
  {
    "id" : "0d624a63-11b7-4766-9cad-0bff43a01133",
    "prId" : 15121,
    "prUrl" : "https://github.com/numpy/numpy/pull/15121#pullrequestreview-478722036",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2fc9c2f7-2b93-4244-91ad-44126239f9cc",
        "parentId" : null,
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "```suggestion\r\n        ax = normalize_axis_index(axis, out.ndim)\r\n```",
        "createdAt" : "2020-08-31T15:51:17Z",
        "updatedAt" : "2020-08-31T15:58:45Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      }
    ],
    "commit" : "785e23901f5b84d677f04f4446449fabbc7575bf",
    "line" : 245,
    "diffHunk" : "@@ -1,1 +4314,4318 @@            return out\n\n        ax = normalize_axis_index(axis, np.ndim(out))\n        itemsize = out.itemsize\n        axlen = out.shape[ax]"
  },
  {
    "id" : "71ccb804-0afb-4a90-a5c2-74bc27c2d9bb",
    "prId" : 15121,
    "prUrl" : "https://github.com/numpy/numpy/pull/15121#pullrequestreview-478722036",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "657de47f-9d98-4313-9723-969236d36001",
        "parentId" : null,
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "I guess we could hardcode itemsize, but doesn't really matter.",
        "createdAt" : "2020-08-31T15:54:44Z",
        "updatedAt" : "2020-08-31T15:58:45Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      }
    ],
    "commit" : "785e23901f5b84d677f04f4446449fabbc7575bf",
    "line" : 295,
    "diffHunk" : "@@ -1,1 +4411,4415 @@            if x.dtype.hasobject:\n                with self.lock:\n                    _shuffle_raw_wrap(&self._bitgen, n, 1, itemsize, stride,\n                                      x_ptr, buf_ptr)\n            else:"
  },
  {
    "id" : "abd0321a-28b7-40a4-b891-8624cf691ffd",
    "prId" : 15138,
    "prUrl" : "https://github.com/numpy/numpy/pull/15138#pullrequestreview-335792901",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1a874b16-b41b-4d56-a86c-8b5cdf63a317",
        "parentId" : null,
        "authorId" : "ed5564b3-30de-4cde-83d3-042942f7203d",
        "body" : "If using backticks for parameter names, donâ€™t forget them for _replace_.",
        "createdAt" : "2019-12-21T14:48:54Z",
        "updatedAt" : "2019-12-23T10:03:29Z",
        "lastEditedBy" : "ed5564b3-30de-4cde-83d3-042942f7203d",
        "tags" : [
        ]
      },
      {
        "id" : "d55a3f0e-9bbe-483e-a0db-f14e15f91880",
        "parentId" : "1a874b16-b41b-4d56-a86c-8b5cdf63a317",
        "authorId" : "b15cf1a1-ba9d-47aa-b157-e0c1f40c5c5c",
        "body" : "I removed all backticks since these appear to be non standard in this module (I couldn't find any other uses).",
        "createdAt" : "2019-12-23T10:04:30Z",
        "updatedAt" : "2019-12-23T10:04:31Z",
        "lastEditedBy" : "b15cf1a1-ba9d-47aa-b157-e0c1f40c5c5c",
        "tags" : [
        ]
      }
    ],
    "commit" : "0fd2e0b01031f2225a3faf3ca31355f3cfed37ef",
    "line" : 86,
    "diffHunk" : "@@ -1,1 +780,784 @@            if size > pop_size:\n                raise ValueError(\"Cannot take a larger sample than \"\n                                 \"population when replace is False\")\n            elif size < 0:\n                raise ValueError(\"negative dimensions are not allowed\")"
  },
  {
    "id" : "1e345e19-97cf-46aa-a648-e47ee6166086",
    "prId" : 15511,
    "prUrl" : "https://github.com/numpy/numpy/pull/15511#pullrequestreview-353823927",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0aaefc95-56b1-4365-b93e-55f55d5fd4fc",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "A lookup table might be faster here, as:\r\n```\r\n_rand_int_funcs = {\r\n    np.dtype(np.bool_): _rand_bool,\r\n    ...\r\n```\r\nthen\r\n```\r\ntry:\r\n    func = _rand_int_funcs[dt]\r\nexcept KeyError:\r\n    raise ValueError(...) from None\r\nelse:\r\n    return func(...)",
        "createdAt" : "2020-02-05T11:40:01Z",
        "updatedAt" : "2020-02-06T14:06:22Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "435aaceb-d9f2-4a87-aa94-19b523225a6d",
        "parentId" : "0aaefc95-56b1-4365-b93e-55f55d5fd4fc",
        "authorId" : "d8ad09b1-f881-44e4-8304-03a66fb1900f",
        "body" : "I tried your suggestion, but I have an error during compilation. I don't have much experience with Cython, could you take a look? \r\nhttps://gist.github.com/przemb/95d6782dada6f1cfb05ff53c810577d4\r\n\r\n\r\nbtw: I thought about [overlading](https://www.python.org/dev/peps/pep-3124/#overloading-generic-functions), but I guess that it is not possible? (in order to keep backward compatibility)\r\n\r\n",
        "createdAt" : "2020-02-05T13:41:44Z",
        "updatedAt" : "2020-02-06T14:06:22Z",
        "lastEditedBy" : "d8ad09b1-f881-44e4-8304-03a66fb1900f",
        "tags" : [
        ]
      },
      {
        "id" : "367fb171-1c85-45b2-a9f9-8d6f887a86a1",
        "parentId" : "0aaefc95-56b1-4365-b93e-55f55d5fd4fc",
        "authorId" : "85b881e8-d8a0-43d4-81d3-7e233dc5f1ae",
        "body" : "`_rand_bool` etc. are C functions (essentially) and cannot be used as dict values.",
        "createdAt" : "2020-02-05T15:29:37Z",
        "updatedAt" : "2020-02-06T14:06:22Z",
        "lastEditedBy" : "85b881e8-d8a0-43d4-81d3-7e233dc5f1ae",
        "tags" : [
        ]
      },
      {
        "id" : "ce0ba8bd-50a3-45b6-896f-433bbcbe8fba",
        "parentId" : "0aaefc95-56b1-4365-b93e-55f55d5fd4fc",
        "authorId" : "85b881e8-d8a0-43d4-81d3-7e233dc5f1ae",
        "body" : "The `if/elif` chain should be fine.",
        "createdAt" : "2020-02-05T15:31:12Z",
        "updatedAt" : "2020-02-06T14:06:22Z",
        "lastEditedBy" : "85b881e8-d8a0-43d4-81d3-7e233dc5f1ae",
        "tags" : [
        ]
      },
      {
        "id" : "e2ec7b3b-cf18-40e9-87e3-ab08ddff90dd",
        "parentId" : "0aaefc95-56b1-4365-b93e-55f55d5fd4fc",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "The advantage of the dict approach is that the `np.dtype` objects can be pre-computed, rather than `dt == np.float32` being expanded to `dt == np.dtype(np.float32)` on each call.\r\n\r\n@rkern's explanation of why this doesn't work is correct, and it looks like it's more trouble than it's worth to make something like that work - so I agree that what you have is fine.",
        "createdAt" : "2020-02-05T15:48:11Z",
        "updatedAt" : "2020-02-06T14:06:22Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "deb857157159400fbc74f2f4035ec78918429f1d",
    "line" : 162,
    "diffHunk" : "@@ -1,1 +579,583 @@            ret = _rand_uint8(low, high, size, _masked, endpoint, &self._bitgen, self.lock)\n        elif _dtype == np.bool_:\n            ret = _rand_bool(low, high, size, _masked, endpoint, &self._bitgen, self.lock)\n        elif not _dtype.isnative:\n            raise ValueError('Providing a dtype with a non-native byteorder '"
  },
  {
    "id" : "dba48951-007e-4713-b07e-8b28c22cae20",
    "prId" : 15511,
    "prUrl" : "https://github.com/numpy/numpy/pull/15511#pullrequestreview-353922995",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "107a97b5-043f-41cb-80e2-d2a9872b3ad1",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Would normally spell this\r\n```suggestion\r\n        dtype = np.dtype(dtype)\r\n```\r\nDoes cython not like that?\r\n\r\n(same throughout)",
        "createdAt" : "2020-02-05T15:49:05Z",
        "updatedAt" : "2020-02-06T14:06:22Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "f236b551-0cb0-47b5-b465-783de235ebb1",
        "parentId" : "107a97b5-043f-41cb-80e2-d2a9872b3ad1",
        "authorId" : "d8ad09b1-f881-44e4-8304-03a66fb1900f",
        "body" : "If I change it, test are failing... seems that it is not proper. ",
        "createdAt" : "2020-02-05T16:48:59Z",
        "updatedAt" : "2020-02-06T14:06:22Z",
        "lastEditedBy" : "d8ad09b1-f881-44e4-8304-03a66fb1900f",
        "tags" : [
        ]
      },
      {
        "id" : "f369f28d-e939-4734-a9ab-f50748b84b80",
        "parentId" : "107a97b5-043f-41cb-80e2-d2a9872b3ad1",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Do you have a link to the CI failure?\r\n\r\nEdit: caused diagnosed here: https://github.com/numpy/numpy/pull/15511#discussion_r375404297",
        "createdAt" : "2020-02-05T17:00:07Z",
        "updatedAt" : "2020-02-06T14:06:22Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "698379a7-8685-44cb-81a4-631054ab36b7",
        "parentId" : "107a97b5-043f-41cb-80e2-d2a9872b3ad1",
        "authorId" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "body" : "We need the original value so we can raise an error with it later. What about `descr` or `concrete_dtype`?",
        "createdAt" : "2020-02-05T17:58:37Z",
        "updatedAt" : "2020-02-06T14:06:22Z",
        "lastEditedBy" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "tags" : [
        ]
      }
    ],
    "commit" : "deb857157159400fbc74f2f4035ec78918429f1d",
    "line" : 37,
    "diffHunk" : "@@ -1,1 +311,315 @@        \"\"\"\n        cdef double temp\n        _dtype = np.dtype(dtype)\n        if _dtype == np.float64:\n            return double_fill(&random_standard_uniform_fill, &self._bitgen, size, self.lock, out)"
  },
  {
    "id" : "0bd65428-7a6e-4cec-8676-58d469d88e58",
    "prId" : 15511,
    "prUrl" : "https://github.com/numpy/numpy/pull/15511#pullrequestreview-353942894",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "79932c0d-8f9e-4d4c-bd61-a7b28129fc85",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "The line below this is is where the error is coming from. I suppose for now, leave the two functions containing`dtype in (bool, int, np.compat.long)` with the second variable `dtype_`",
        "createdAt" : "2020-02-05T17:37:27Z",
        "updatedAt" : "2020-02-06T14:06:22Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "9dbe867e-50d9-496a-b59b-8e7d1f57f465",
        "parentId" : "79932c0d-8f9e-4d4c-bd61-a7b28129fc85",
        "authorId" : "d8ad09b1-f881-44e4-8304-03a66fb1900f",
        "body" : "did you mean the below version?\r\n```\r\n        dtype_ = None\r\n        if size is None and dtype_ in (bool, int, np.compat.long):\r\n            if np.array(ret).shape == ():\r\n                return dtype_(ret)\r\n        return ret\r\n```",
        "createdAt" : "2020-02-05T18:08:34Z",
        "updatedAt" : "2020-02-06T14:06:22Z",
        "lastEditedBy" : "d8ad09b1-f881-44e4-8304-03a66fb1900f",
        "tags" : [
        ]
      },
      {
        "id" : "21d00d17-8b84-47c6-90a2-4132140fc7ac",
        "parentId" : "79932c0d-8f9e-4d4c-bd61-a7b28129fc85",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "No, I meant:\r\n\r\n* Change the functions that include these lines back to how they were in your previous commit, with the separate `dtype` and `dtype_` variables\r\n* Leave the other functions with the better `dtype` name",
        "createdAt" : "2020-02-05T18:10:10Z",
        "updatedAt" : "2020-02-06T14:06:22Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "fb96417c-b254-4dc1-b636-106d6b37369f",
        "parentId" : "79932c0d-8f9e-4d4c-bd61-a7b28129fc85",
        "authorId" : "d8ad09b1-f881-44e4-8304-03a66fb1900f",
        "body" : "Thanks for the clarification. ",
        "createdAt" : "2020-02-05T18:29:14Z",
        "updatedAt" : "2020-02-06T14:06:22Z",
        "lastEditedBy" : "d8ad09b1-f881-44e4-8304-03a66fb1900f",
        "tags" : [
        ]
      }
    ],
    "commit" : "deb857157159400fbc74f2f4035ec78918429f1d",
    "line" : 173,
    "diffHunk" : "@@ -1,1 +590,594 @@\n        if size is None and dtype in (bool, int, np.compat.long):\n            if np.array(ret).shape == ():\n                return dtype(ret)\n        return ret"
  },
  {
    "id" : "5435f0c8-b6f2-4e7a-8541-ec68576fdf27",
    "prId" : 15511,
    "prUrl" : "https://github.com/numpy/numpy/pull/15511#pullrequestreview-354334701",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9cdd3a70-c5e2-44d2-aeaf-4654db15faf6",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Documentation should be updated, perhaps something like:\r\n```diff\r\n- dtype : {str, dtype}, optional\r\n+ dtype : dtype, optional\r\n-           Desired dtype of the result. All dtypes are determined by their\r\n-           name, i.e., 'int64', 'int', etc, so byteorder is not available\r\n-           and a specific precision may have different C types depending\r\n+           Desired dtype of the result. Byteorder must be native, and the result\r\n+           dtype will be equivalent but may not be identical. The default value is `np.int_`.\r\n```\r\n\r\nApplies to:\r\n* https://github.com/numpy/numpy/pull/15511/files#diff-f166b929b9f07d28bd1582546a65c87bR500\r\n* https://github.com/numpy/numpy/pull/15511/files#diff-f166b929b9f07d28bd1582546a65c87bR992\r\n* https://github.com/numpy/numpy/pull/15511/files#diff-f166b929b9f07d28bd1582546a65c87bR1172",
        "createdAt" : "2020-02-05T17:43:45Z",
        "updatedAt" : "2020-02-06T14:06:22Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "4045a6a8-de9e-4aea-b992-4054af730f68",
        "parentId" : "9cdd3a70-c5e2-44d2-aeaf-4654db15faf6",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "This comment still applies, there are multiple pieces of documentation like this - likely one per function you touched",
        "createdAt" : "2020-02-05T18:28:43Z",
        "updatedAt" : "2020-02-06T14:06:22Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "b92ff677-2e5d-42a0-b0a6-c4ae3d1784ae",
        "parentId" : "9cdd3a70-c5e2-44d2-aeaf-4654db15faf6",
        "authorId" : "d8ad09b1-f881-44e4-8304-03a66fb1900f",
        "body" : "You are right, I updated it. \r\nWhat about repeating part: \"_All dtypes are determined by their name_\". All occurrences of _dtype.name_ were replaced... it should be rather: \"_All dtypes are determined by their types_\", right?",
        "createdAt" : "2020-02-05T19:44:13Z",
        "updatedAt" : "2020-02-06T14:06:22Z",
        "lastEditedBy" : "d8ad09b1-f881-44e4-8304-03a66fb1900f",
        "tags" : [
        ]
      },
      {
        "id" : "859d00ee-6466-4a06-bcaa-d3228168b1d8",
        "parentId" : "9cdd3a70-c5e2-44d2-aeaf-4654db15faf6",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "I don't think there's any replacement for that sentence. Your suggested replacement is not true, as it implies you're only looking at `dt.type` and ignoring `dt.is_native`.\r\n\r\nI tried to capture the behavior with _\"the result dtype will be equivalent but may not be identical\"_. To elaborate on that, what I mean is that we guarantee `func(dtype=dt).dtype == dt`, but not that `func(dtype=dt).dtype is dt`. I don't know if we want to mention that explicitly in the docs, I suspect it causes more confusion than it resolves.\r\n\r\nReally, what we're trying to cover here is (on linux) someone passing `np.longlong`, and being surprised when they get back `np.int_`, even though both are 64-bit.\r\n\r\nMaybe that's not interesting and we should just remove the remark entirely. Perhaps another maintainer can comment on whether we need it.",
        "createdAt" : "2020-02-05T19:47:41Z",
        "updatedAt" : "2020-02-06T14:06:22Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "fde48da7-83cd-4878-9ec1-8962aa686208",
        "parentId" : "9cdd3a70-c5e2-44d2-aeaf-4654db15faf6",
        "authorId" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "body" : "it is a bit confusing. I think we can remove \", and the result dtype will be equivalent but may not be identical\", no need to dive into the weeds here.",
        "createdAt" : "2020-02-05T20:31:09Z",
        "updatedAt" : "2020-02-06T14:06:22Z",
        "lastEditedBy" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "tags" : [
        ]
      },
      {
        "id" : "53e64d00-ecc8-475a-8ec4-bb3e029e6b19",
        "parentId" : "9cdd3a70-c5e2-44d2-aeaf-4654db15faf6",
        "authorId" : "d8ad09b1-f881-44e4-8304-03a66fb1900f",
        "body" : "Ok, updated. ",
        "createdAt" : "2020-02-06T10:14:07Z",
        "updatedAt" : "2020-02-06T14:06:22Z",
        "lastEditedBy" : "d8ad09b1-f881-44e4-8304-03a66fb1900f",
        "tags" : [
        ]
      }
    ],
    "commit" : "deb857157159400fbc74f2f4035ec78918429f1d",
    "line" : 117,
    "diffHunk" : "@@ -1,1 +552,556 @@        \"\"\"\n        if high is None:\n            high = low\n            low = 0\n"
  },
  {
    "id" : "5321661f-0db5-406f-984b-c6ba4593316f",
    "prId" : 15872,
    "prUrl" : "https://github.com/numpy/numpy/pull/15872#pullrequestreview-387760385",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f440e135-0975-4cc1-9056-b6372f526c5b",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "The problem here is that `u` is not necessarily `vh.T` for the `svd`, if there are negative eigenvalues from numerical error, there will be a sign change. Hmm... if the cov is valid and the negative eigenvalue is due to numerical error, i.e., it is really tiny, then it should have hardly any impact on the output, so this is probably OK. Might mention the possibility in the release note.",
        "createdAt" : "2020-04-04T20:45:59Z",
        "updatedAt" : "2020-04-05T01:27:48Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "6ef5cc76-8696-4a16-b435-0b3e165a70bc",
        "parentId" : "f440e135-0975-4cc1-9056-b6372f526c5b",
        "authorId" : "75fd9ffc-aedf-446c-8941-530d91a93ad1",
        "body" : "I mean the same is true for the previous formulation, right? ",
        "createdAt" : "2020-04-04T21:05:48Z",
        "updatedAt" : "2020-04-05T01:27:48Z",
        "lastEditedBy" : "75fd9ffc-aedf-446c-8941-530d91a93ad1",
        "tags" : [
        ]
      },
      {
        "id" : "070724f9-1e31-421b-acac-e51706822e1b",
        "parentId" : "f440e135-0975-4cc1-9056-b6372f526c5b",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Yep, it would give incorrect results in that case, but different incorrect results :)",
        "createdAt" : "2020-04-04T21:26:08Z",
        "updatedAt" : "2020-04-05T01:27:48Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "9fe4bdfe-8e2f-4c7b-9e7a-08ec0c0a9370",
        "parentId" : "f440e135-0975-4cc1-9056-b6372f526c5b",
        "authorId" : "75fd9ffc-aedf-446c-8941-530d91a93ad1",
        "body" : "ok let's make sure our errors are correct then",
        "createdAt" : "2020-04-04T21:26:57Z",
        "updatedAt" : "2020-04-05T01:27:48Z",
        "lastEditedBy" : "75fd9ffc-aedf-446c-8941-530d91a93ad1",
        "tags" : [
        ]
      }
    ],
    "commit" : "72457f01832d10c72a1839aafc178cf4f53449cb",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +3538,3542 @@            _factor = u * np.sqrt(abs(s))\n        else:\n            _factor = u * np.sqrt(s)\n\n        x = mean + x @ _factor.T"
  },
  {
    "id" : "ba72d50c-9756-47a4-8348-acdc45ed0393",
    "prId" : 15872,
    "prUrl" : "https://github.com/numpy/numpy/pull/15872#pullrequestreview-387760045",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fbe63d5f-24b8-4a46-bef6-4aa282c4c317",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "BLAS will be faster than einsum. `x` will always be 2D at this point due to previous reshape and transpose is cheap, so just `x @ _factor.T` should be fine and at least keeps all the transposes in one place while keeping the results the same for the 'svd' case. The output shape is what make things tricky. On could transpose `x` in the reshape and do `(_factor @ x).T` but that doesn't seem much of an improvement.",
        "createdAt" : "2020-04-04T21:11:46Z",
        "updatedAt" : "2020-04-05T01:27:48Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "04c10418-b3f1-4aa7-b848-507f1c4bb0c4",
        "parentId" : "fbe63d5f-24b8-4a46-bef6-4aa282c4c317",
        "authorId" : "75fd9ffc-aedf-446c-8941-530d91a93ad1",
        "body" : "Ah I see I thought `x` here could still have a bunch of leading dims. That makes things easier.",
        "createdAt" : "2020-04-04T21:21:09Z",
        "updatedAt" : "2020-04-05T01:27:48Z",
        "lastEditedBy" : "75fd9ffc-aedf-446c-8941-530d91a93ad1",
        "tags" : [
        ]
      }
    ],
    "commit" : "72457f01832d10c72a1839aafc178cf4f53449cb",
    "line" : 10,
    "diffHunk" : "@@ -1,1 +3541,3545 @@\n        x = mean + x @ _factor.T\n        x.shape = tuple(final_shape)\n        return x\n"
  },
  {
    "id" : "5936ed31-7acb-479b-a1ba-17baa569fc37",
    "prId" : 16504,
    "prUrl" : "https://github.com/numpy/numpy/pull/16504#pullrequestreview-425293435",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bf1cf146-a3cb-4af7-98d8-082af6dc0731",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Hmm. Does anyone know if it is OK to break a signature line like this? If not, we could make an exception to the 80 character limit.",
        "createdAt" : "2020-06-05T13:23:02Z",
        "updatedAt" : "2020-06-05T14:43:23Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "b5f873304f4457e33f92d3b3498ae5d8ebf00714",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +3347,3351 @@        \"\"\"\n        multivariate_normal(mean, cov, size=None, check_valid='warn',\n                            tol=1e-8, *, method='svd')\n\n        Draw random samples from a multivariate normal distribution."
  },
  {
    "id" : "bd7e372c-ad9d-4b92-b3c3-ee7691ec3b30",
    "prId" : 18211,
    "prUrl" : "https://github.com/numpy/numpy/pull/18211#pullrequestreview-574847322",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1da02d97-331d-48ba-b889-98675af6bb30",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Maybe needs `stacklevel=2` for a clear context message",
        "createdAt" : "2021-01-23T13:33:25Z",
        "updatedAt" : "2021-01-23T19:36:23Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "3e66aa25-ebdb-4913-aee4-2a30dd4f96b7",
        "parentId" : "1da02d97-331d-48ba-b889-98675af6bb30",
        "authorId" : "8ffdfffb-d8d9-40f6-9de3-dd0dee381149",
        "body" : "good catch, will update",
        "createdAt" : "2021-01-23T13:34:26Z",
        "updatedAt" : "2021-01-23T19:36:23Z",
        "lastEditedBy" : "8ffdfffb-d8d9-40f6-9de3-dd0dee381149",
        "tags" : [
        ]
      }
    ],
    "commit" : "5cbfefb4c69b130f8b01408615e9f7b42b707beb",
    "line" : 50,
    "diffHunk" : "@@ -1,1 +4441,4445 @@                    \"with view semantics may contain duplicates after shuffling.\",\n                    UserWarning, stacklevel=2\n                )\n\n            if axis != 0:"
  },
  {
    "id" : "6e3d5ab4-4efd-45a9-9b8b-d946b623a989",
    "prId" : 18223,
    "prUrl" : "https://github.com/numpy/numpy/pull/18223#pullrequestreview-576796703",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c41f72db-a837-4de7-9119-a435fe93760a",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "This example is raising a documentation error.\r\n```\r\nFile \"build/testenv/lib/python3.7/site-packages/numpy/random/_generator.cpython-37m-darwin.so\", line ?, in Generator.choice\r\nFailed example:\r\n    rng.choice([[0, 1, 2], [3, 4, 5], [6, 7, 8]], 2, replace=False)\r\nExpected:\r\n    array([[3, 4, 5],\r\n           [0, 1, 2]])\r\nGot:\r\n    array([[6, 7, 8],\r\n           [3, 4, 5]])\r\n```\r\nYou need to use a seed to make it repeatable, or add `# may vary` to the first output line. Grep to see examples.",
        "createdAt" : "2021-01-26T04:23:55Z",
        "updatedAt" : "2021-01-26T22:08:19Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "5090cdba-af9b-41ef-b5b6-894deda3d0dc",
        "parentId" : "c41f72db-a837-4de7-9119-a435fe93760a",
        "authorId" : "efbdd3be-ed6f-4bf0-8657-809cf9c6db96",
        "body" : "Ah, it had occurred to me, but I guess I missed the `# random` in the other examples and couldn't find anything about it in the developer documentation. Cheers!",
        "createdAt" : "2021-01-26T21:58:02Z",
        "updatedAt" : "2021-01-26T22:08:19Z",
        "lastEditedBy" : "efbdd3be-ed6f-4bf0-8657-809cf9c6db96",
        "tags" : [
        ]
      }
    ],
    "commit" : "f7d26c28190b430407e35c2169af88935353403c",
    "line" : 19,
    "diffHunk" : "@@ -1,1 +672,676 @@        array([[3, 4, 5], # random\n               [0, 1, 2]])\n\n        Generate a non-uniform random sample from np.arange(5) of size\n        3 without replacement:"
  }
]
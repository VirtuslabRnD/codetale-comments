[
  {
    "id" : "3c5f0baa-54b2-4c5f-a723-9364348dfbc8",
    "prId" : 14924,
    "prUrl" : "https://github.com/numpy/numpy/pull/14924#pullrequestreview-398658136",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c87e487a-869c-4e56-a3dc-ced164b7f2f8",
        "parentId" : null,
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "```suggestion\r\n            alpha_csum = np.cumsum(alpha[::-1])[::-1]\r\n            alpha_csum_arr = <np.ndarray>np.PyArray_FROM_OTF(alpha_csum,\r\n                np.NPY_DOUBLE, np.NPY_ALIGNED | np.NPY_ARRAY_C_CONTIGUOUS)\r\n            alpha_csum_data = <double*>np.PyArray_DATA(alpha_csum_arr)\r\n\r\n            with self.lock, nogil:\r\n```",
        "createdAt" : "2020-04-22T23:24:56Z",
        "updatedAt" : "2020-04-28T03:34:46Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      }
    ],
    "commit" : "6b181c8e607f35b0de1a6a12dd280ddf2bc439f5",
    "line" : 73,
    "diffHunk" : "@@ -1,1 +4196,4200 @@                alpha_csum_data[j] = csum\n\n            with self.lock, nogil:\n                while i < totsize:\n                    acc = 1."
  },
  {
    "id" : "4bbcb0a3-eabd-4cd1-a109-c53a7c25b21d",
    "prId" : 14924,
    "prUrl" : "https://github.com/numpy/numpy/pull/14924#pullrequestreview-401473994",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8aa069a6-340a-489e-a378-1de5ff65151f",
        "parentId" : null,
        "authorId" : "8de63a41-1bc1-4e93-a2df-4f2f940433cf",
        "body" : "```suggestion\r\n        cdef np.ndarray alpha_arr, val_arr, alpha_csum_arr\r\n        cdef double csum\r\n```",
        "createdAt" : "2020-04-28T03:33:40Z",
        "updatedAt" : "2020-04-28T03:34:46Z",
        "lastEditedBy" : "8de63a41-1bc1-4e93-a2df-4f2f940433cf",
        "tags" : [
        ]
      }
    ],
    "commit" : "6b181c8e607f35b0de1a6a12dd280ddf2bc439f5",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +4125,4129 @@\n        cdef np.npy_intp k, totsize, i, j\n        cdef np.ndarray alpha_arr, val_arr, alpha_csum_arr\n        cdef double csum\n        cdef double *alpha_data"
  },
  {
    "id" : "8dc54b4f-a9fa-4a28-904f-d2e6afa5846b",
    "prId" : 15121,
    "prUrl" : "https://github.com/numpy/numpy/pull/15121#pullrequestreview-467082661",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "749599c7-2517-4f92-93bf-46b24d5272ae",
        "parentId" : null,
        "authorId" : "b15cf1a1-ba9d-47aa-b157-e0c1f40c5c5c",
        "body" : "Should these support tuple[int] as well, e.g.,\r\n\r\n```\r\ngen = default_rng()\r\nx = gen.standard_normal(5,6,7)\r\ngen.randomly_permute(x, axis=(0,1)):\r\n```\r\n\r\nwhich would shuffle the element for each pair of the first 2 axes.\r\n\r\n",
        "createdAt" : "2019-12-21T00:24:09Z",
        "updatedAt" : "2020-08-21T04:18:30Z",
        "lastEditedBy" : "b15cf1a1-ba9d-47aa-b157-e0c1f40c5c5c",
        "tags" : [
        ]
      },
      {
        "id" : "904532bd-cfa9-41f6-8b70-025e197bf2de",
        "parentId" : "749599c7-2517-4f92-93bf-46b24d5272ae",
        "authorId" : "8de63a41-1bc1-4e93-a2df-4f2f940433cf",
        "body" : "That could be added (but I haven't looked into how hard it would be).  I'm not sure how to interpret \"which would shuffle the element for each pair of the first 2 axes.\"  I would expect that example to shuffle the elements within the 2-d slices. That is, after the call, `x[:, :, 0]` contains the same elements as before the call, but shuffled, and the shuffle is applied to the flattened slice (so any given element could end up anywhere in the 2-d slice). Likewise for `x[:,:,1]`, etc.",
        "createdAt" : "2020-07-02T03:18:57Z",
        "updatedAt" : "2020-08-21T04:18:30Z",
        "lastEditedBy" : "8de63a41-1bc1-4e93-a2df-4f2f940433cf",
        "tags" : [
        ]
      },
      {
        "id" : "2b686964-9591-468f-9756-ae2d2764392b",
        "parentId" : "749599c7-2517-4f92-93bf-46b24d5272ae",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "I agree that is the correct generalization, but am happy to only support `None` and a single int for now (with `None` effectively being the same as `range(ndim)` here).",
        "createdAt" : "2020-08-05T19:45:17Z",
        "updatedAt" : "2020-08-21T04:18:30Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "73e4ac92-1399-4827-906a-1bcbe8878e48",
        "parentId" : "749599c7-2517-4f92-93bf-46b24d5272ae",
        "authorId" : "8de63a41-1bc1-4e93-a2df-4f2f940433cf",
        "body" : "OK, for now I'll stick with None or a single integer, and leave handling of a tuple as a future enhancement.",
        "createdAt" : "2020-08-13T19:52:21Z",
        "updatedAt" : "2020-08-21T04:18:30Z",
        "lastEditedBy" : "8de63a41-1bc1-4e93-a2df-4f2f940433cf",
        "tags" : [
        ]
      }
    ],
    "commit" : "785e23901f5b84d677f04f4446449fabbc7575bf",
    "line" : 138,
    "diffHunk" : "@@ -1,1 +4207,4211 @@        x : array_like, at least one-dimensional\n            Array to be shuffled.\n        axis : int, optional\n            Slices of `x` in this axis are shuffled. Each slice\n            is shuffled independently of the others.  If `axis` is"
  },
  {
    "id" : "ed576e3d-6b04-47ba-9c01-7595ecce59b7",
    "prId" : 15121,
    "prUrl" : "https://github.com/numpy/numpy/pull/15121#pullrequestreview-449082734",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "202b2f63-d6a8-4382-805c-1f9eebcb23e8",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "What does passing `first=0` mean? It seems to me it's identical to `first = 1`.\r\n",
        "createdAt" : "2020-07-15T15:34:56Z",
        "updatedAt" : "2020-08-21T04:18:30Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "0722045c-99cf-4007-aa19-4b2eb4cd5e08",
        "parentId" : "202b2f63-d6a8-4382-805c-1f9eebcb23e8",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Given the only two callers pass either `0` or `1`, can this argument just be removed?",
        "createdAt" : "2020-07-15T15:39:16Z",
        "updatedAt" : "2020-08-21T04:18:30Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "b825bfe3-83ef-4bab-9517-e1cb0b6e463a",
        "parentId" : "202b2f63-d6a8-4382-805c-1f9eebcb23e8",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "nevermind, I see this function was just moved.",
        "createdAt" : "2020-07-15T15:41:09Z",
        "updatedAt" : "2020-08-21T04:18:30Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "785e23901f5b84d677f04f4446449fabbc7575bf",
    "line" : 53,
    "diffHunk" : "@@ -1,1 +84,88 @@        First observation to shuffle.  Shuffles n-1,\n        n-2, ..., first, so that when first=1 the entire\n        array is shuffled\n    itemsize\n        Size in bytes of item"
  },
  {
    "id" : "39e708d2-7118-4873-9e96-f341ca288dbe",
    "prId" : 15121,
    "prUrl" : "https://github.com/numpy/numpy/pull/15121#pullrequestreview-452759700",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4450be5f-aee4-4209-8f58-7cb94cd07440",
        "parentId" : null,
        "authorId" : "b15cf1a1-ba9d-47aa-b157-e0c1f40c5c5c",
        "body" : "Does x need to have any storage requirements? Contiguous or C contiguous?",
        "createdAt" : "2020-07-15T16:43:01Z",
        "updatedAt" : "2020-08-21T04:18:30Z",
        "lastEditedBy" : "b15cf1a1-ba9d-47aa-b157-e0c1f40c5c5c",
        "tags" : [
        ]
      },
      {
        "id" : "9f088c37-fcc8-47a3-b543-9b4915b07082",
        "parentId" : "4450be5f-aee4-4209-8f58-7cb94cd07440",
        "authorId" : "8de63a41-1bc1-4e93-a2df-4f2f940433cf",
        "body" : "The code should handle non-contiguous arrays.  I added a unit test that applies `permuted` to an array with nontrivial strides.",
        "createdAt" : "2020-07-21T19:21:15Z",
        "updatedAt" : "2020-08-21T04:18:30Z",
        "lastEditedBy" : "8de63a41-1bc1-4e93-a2df-4f2f940433cf",
        "tags" : [
        ]
      }
    ],
    "commit" : "785e23901f5b84d677f04f4446449fabbc7575bf",
    "line" : 211,
    "diffHunk" : "@@ -1,1 +4280,4284 @@        cdef int flags\n\n        x = np.asarray(x)\n\n        if out is None:"
  },
  {
    "id" : "f060f1af-6580-42a4-889e-e41659e43662",
    "prId" : 15121,
    "prUrl" : "https://github.com/numpy/numpy/pull/15121#pullrequestreview-467898360",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3c369c4b-b491-4716-8f70-7b3695deabcc",
        "parentId" : null,
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Hmmm, this is probably pretty slow, since it works by using the sequence-like flat-iterator. But I guess that is fine, it would be easy to change.  I am a bit curious whether we are OK with changes in the output if we adapt this to non C-order array. I.e. if we update this at some point, we are OK, if the result differs when `out` is not C-order, right?",
        "createdAt" : "2020-08-05T19:35:46Z",
        "updatedAt" : "2020-08-21T04:18:30Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "9292aeb6-8011-416e-a87e-467e524a835a",
        "parentId" : "3c369c4b-b491-4716-8f70-7b3695deabcc",
        "authorId" : "b15cf1a1-ba9d-47aa-b157-e0c1f40c5c5c",
        "body" : "Should you special case the common C-contiguous non-strided case with a reshape?",
        "createdAt" : "2020-08-06T12:57:18Z",
        "updatedAt" : "2020-08-21T04:18:30Z",
        "lastEditedBy" : "b15cf1a1-ba9d-47aa-b157-e0c1f40c5c5c",
        "tags" : [
        ]
      },
      {
        "id" : "0c63fc79-d0a2-49ea-987e-98dab1b2dd4f",
        "parentId" : "3c369c4b-b491-4716-8f70-7b3695deabcc",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Does this work at all? I'd worry that `shuffle(out.flat)` makes a copy of `out.flat`",
        "createdAt" : "2020-08-06T14:42:47Z",
        "updatedAt" : "2020-08-21T04:18:30Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "ecccd6cf-4d45-4ff4-81c1-253e864b1dfa",
        "parentId" : "3c369c4b-b491-4716-8f70-7b3695deabcc",
        "authorId" : "8de63a41-1bc1-4e93-a2df-4f2f940433cf",
        "body" : "@seberg, this is admittedly a \"quick and dirty\" implementation (where \"quick\" refers to implementation time, not execution time).  Is there an existing pattern in the NumPy API for treating an n-d array (with arbitrary strides) as a 1-d array that would better here?  I can implement *something*, but it would be great if there is already a nice way to do it.\r\n\r\n@bashtage, yes, with `axis=None`, a fast path for the contiguous case (either C- or F-, actually) should be pretty easy.\r\n\r\n@eric-wieser, I've tested it using arrays with various strides, and it has worked, but maybe I'm just blind to an obvious counter-example.  Are there specific tests you think would be good to check?",
        "createdAt" : "2020-08-13T22:10:59Z",
        "updatedAt" : "2020-08-21T04:18:30Z",
        "lastEditedBy" : "8de63a41-1bc1-4e93-a2df-4f2f940433cf",
        "tags" : [
        ]
      },
      {
        "id" : "8f0f8d0a-e3b3-4774-9622-661f93d0a3d6",
        "parentId" : "3c369c4b-b491-4716-8f70-7b3695deabcc",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "@WarrenWeckesser I think the easiest solution is probably to use some nitty-gritty C-API (I assume contiguity does not matter, only 1-D does), there are a few \"KeepOrder\" cases which this misses, I think `ravel()` may actually support \"K\", unlike `reshape`, so both have their advantages (and I don't care for which way)\r\n\r\n```\r\nto_shuffle = out.reshape(-1, order=\"A\")\r\nif to_shuffle.flags.owndata:\r\n    PyArray_SetWritebackIfCopyBase(to_shuffle, out)\r\n\r\nself.shuffle(to_shuffle)\r\n\r\nif to_shuffle.flags.writebackifcopy:\r\n    PyArray_ResolveWritebackIfCopy(to_shuffle) \r\n```\r\nI have not confirmed that this is the correct pattern, it certainly isn't correct code as-is.\r\n\r\nEDIT: To be clear with \"misses\" I just mean: `to_shuffle` does an *unnecessary* copy, the pattern always works.",
        "createdAt" : "2020-08-13T22:25:02Z",
        "updatedAt" : "2020-08-21T04:18:30Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "10b8e7d7-5386-4876-a291-c9f89b6474ed",
        "parentId" : "3c369c4b-b491-4716-8f70-7b3695deabcc",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "I am also not sure that checking for \"owndata\" is a great approach to find out whether the ravel/reshape was in-place, although I doubt it can fail here (since these are all plain `ndarray`s)",
        "createdAt" : "2020-08-13T22:30:01Z",
        "updatedAt" : "2020-08-21T04:18:30Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "14175f7f-5cdf-4534-a637-d3ec05acc872",
        "parentId" : "3c369c4b-b491-4716-8f70-7b3695deabcc",
        "authorId" : "8de63a41-1bc1-4e93-a2df-4f2f940433cf",
        "body" : "Thanks @seberg, I wouldn't have known to use those functions.\r\n\r\nThe `owndata` flag might not be the right way to check whether a copy was made.  In the following, `y` gets a copy of the data, but `y.flags.owndata` is False:\r\n\r\n```\r\nIn [286]: x = np.arange(24).reshape(3, 8)[:, ::-1]\r\n\r\nIn [287]: x\r\nOut[287]: \r\narray([[ 7,  6,  5,  4,  3,  2,  1,  0],\r\n       [15, 14, 13, 12, 11, 10,  9,  8],\r\n       [23, 22, 21, 20, 19, 18, 17, 16]])\r\n\r\nIn [288]: x.strides\r\nOut[288]: (64, -8)\r\n\r\nIn [289]: y = x.reshape(-1, order='A')\r\n\r\nIn [290]: y.flags.owndata\r\nOut[290]: False\r\n```",
        "createdAt" : "2020-08-13T23:18:05Z",
        "updatedAt" : "2020-08-21T04:18:30Z",
        "lastEditedBy" : "8de63a41-1bc1-4e93-a2df-4f2f940433cf",
        "tags" : [
        ]
      },
      {
        "id" : "e2c63036-9ccb-434a-8bb4-afdd72256079",
        "parentId" : "3c369c4b-b491-4716-8f70-7b3695deabcc",
        "authorId" : "8de63a41-1bc1-4e93-a2df-4f2f940433cf",
        "body" : "Is`PyArray_SetWritebackIfCopyBase` include in the Cython headers for the NumPy C API? I can't get the code to recognize it as a C function.  If I use `np.PyArray_SetWritebackIfCopyBase`, I get `AttributeError: module 'numpy' has no attribute 'PyArray_SetWritebackIfCopyBase'` when I run the code.  If I add `cimport numpy as cnp` (which I wish we did all the time!) and use `cnp.PyArray_SetWritebackIfCopyBase`, cython report this when building: `_generator.pyx:4277:28: cimported module has no attribute 'PyArray_SetWritebackIfCopyBase'` \r\n",
        "createdAt" : "2020-08-14T00:32:47Z",
        "updatedAt" : "2020-08-21T04:18:30Z",
        "lastEditedBy" : "8de63a41-1bc1-4e93-a2df-4f2f940433cf",
        "tags" : [
        ]
      },
      {
        "id" : "2968c5ab-9216-4514-8c17-90fa0ad31e49",
        "parentId" : "3c369c4b-b491-4716-8f70-7b3695deabcc",
        "authorId" : "8de63a41-1bc1-4e93-a2df-4f2f940433cf",
        "body" : "Answering my own question: `PyArray_SetWritebackIfCopyBase` and `PyArray_ResolveWritebackIfCopy` are not in the NumPy .pxd files provided by cython 0.29.21.",
        "createdAt" : "2020-08-14T00:42:05Z",
        "updatedAt" : "2020-08-21T04:18:30Z",
        "lastEditedBy" : "8de63a41-1bc1-4e93-a2df-4f2f940433cf",
        "tags" : [
        ]
      },
      {
        "id" : "b867e7ee-b865-433c-89c7-dc65cd10fcb5",
        "parentId" : "3c369c4b-b491-4716-8f70-7b3695deabcc",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Hmmm, would have expected those to exist, but if not, I guess we could either add them or define them just for this, @mattip we probably just forgot to add them to the `pyd` (or cython never add them?)\r\n\r\nOne thing: I guess you actually have to create a contigous copy (on which you set the writebackifcopy), and then pass the ravelled version (if the reshape/ravel fails).  I am also a bit unsure if the *if copy* logic there",
        "createdAt" : "2020-08-14T00:51:03Z",
        "updatedAt" : "2020-08-21T04:18:30Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "42eb276f-d3fa-44c2-b7c3-dddd6c98fb31",
        "parentId" : "3c369c4b-b491-4716-8f70-7b3695deabcc",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "In fact, for simplicity you do not need to use `np.PyArray_SetWritebackIfCopyBase` at all: Just use the normal `PyArray_FromArray` with the writeback-if-copy flag and call `PyArray_ResolveWritebackIfCopy` unconditionally.",
        "createdAt" : "2020-08-14T00:58:02Z",
        "updatedAt" : "2020-08-21T04:18:30Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "75161d8c-0ebb-43f2-a266-1d1d36731473",
        "parentId" : "3c369c4b-b491-4716-8f70-7b3695deabcc",
        "authorId" : "8de63a41-1bc1-4e93-a2df-4f2f940433cf",
        "body" : "For now, I've added this to `_generator.pyx`:\r\n```\r\ncdef extern from \"numpy/arrayobject.h\":\r\n    int PyArray_SetWritebackIfCopyBase(np.ndarray, np.ndarray)\r\n    int PyArray_ResolveWritebackIfCopy(np.ndarray)\r\n```",
        "createdAt" : "2020-08-14T00:58:12Z",
        "updatedAt" : "2020-08-21T04:18:30Z",
        "lastEditedBy" : "8de63a41-1bc1-4e93-a2df-4f2f940433cf",
        "tags" : [
        ]
      },
      {
        "id" : "d5fef17e-ef29-4d79-b57c-27bde8c03bba",
        "parentId" : "3c369c4b-b491-4716-8f70-7b3695deabcc",
        "authorId" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "body" : "I think the intention was to try to keep those as internal APIs as much as possible, so if they are needed putting them in `_generator.pyx` seems like a good solution. In general, shouldn't `nditer` be a better solution?",
        "createdAt" : "2020-08-14T08:37:17Z",
        "updatedAt" : "2020-08-21T04:18:30Z",
        "lastEditedBy" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "tags" : [
        ]
      },
      {
        "id" : "0d5515bb-f6e3-40e6-86a5-06498b61f4bc",
        "parentId" : "3c369c4b-b491-4716-8f70-7b3695deabcc",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "> @eric-wieser, I've tested it using arrays with various strides, and it has worked, but maybe I'm just blind to an obvious counter-example.\r\n\r\nI should have looked at the source code - `shuffle` has a special unoptimized code path for shuffling non-array sequences.",
        "createdAt" : "2020-08-14T08:55:54Z",
        "updatedAt" : "2020-08-21T04:18:30Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "1f27564d-ee3c-4f8e-8025-1fc7229b0bdf",
        "parentId" : "3c369c4b-b491-4716-8f70-7b3695deabcc",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "> In general, shouldn't `nditer` be a better solution?\r\n\r\nAgreed - it seems like we could have an nditer loop, and call `_shuffle_raw` inside it.\r\n\r\n",
        "createdAt" : "2020-08-14T08:56:47Z",
        "updatedAt" : "2020-08-21T04:18:30Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "ac095d7f-d6cb-41bf-88b9-b228cd97600f",
        "parentId" : "3c369c4b-b491-4716-8f70-7b3695deabcc",
        "authorId" : "8de63a41-1bc1-4e93-a2df-4f2f940433cf",
        "body" : "What are the advantages of an `nditer` loop over using `PyArray_IterAllButAxis`?  That's not a rhetorical question--I could use some education here.  Presumably `nditer` (or the corresponding C API) already includes the machinery for handling `axis` being a tuple (is that correct?), but are there other advantages?  Can anyone point to an example of using `nditer` (or the C API) that iterates over slices determined by an `axis` argument?  ",
        "createdAt" : "2020-08-14T14:07:23Z",
        "updatedAt" : "2020-08-21T04:18:30Z",
        "lastEditedBy" : "8de63a41-1bc1-4e93-a2df-4f2f940433cf",
        "tags" : [
        ]
      },
      {
        "id" : "33007892-fbb0-40b0-aab1-241fd4d1c0ad",
        "parentId" : "3c369c4b-b491-4716-8f70-7b3695deabcc",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "I don't see that works, you need to shuffle the *whole* array, I am not aware that it is possible to shuffle in chunks :).",
        "createdAt" : "2020-08-14T14:18:38Z",
        "updatedAt" : "2020-08-21T04:18:30Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "c5fe149d-be7c-491a-abba-0e6870e64079",
        "parentId" : "3c369c4b-b491-4716-8f70-7b3695deabcc",
        "authorId" : "8de63a41-1bc1-4e93-a2df-4f2f940433cf",
        "body" : "*\"I don't see that works,...\"*  What does *that* refer to?  The use of `nditer`?",
        "createdAt" : "2020-08-14T14:36:27Z",
        "updatedAt" : "2020-08-21T04:18:30Z",
        "lastEditedBy" : "8de63a41-1bc1-4e93-a2df-4f2f940433cf",
        "tags" : [
        ]
      },
      {
        "id" : "3de12f55-ddee-4e61-b071-009945f70682",
        "parentId" : "3c369c4b-b491-4716-8f70-7b3695deabcc",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Yes, sorry. nditer chunks iteration when it doesn't fit the 1-d slice layout.",
        "createdAt" : "2020-08-14T14:38:29Z",
        "updatedAt" : "2020-08-21T04:18:30Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "7f8ff77f-5d80-470e-aeba-4e0cefc7ecba",
        "parentId" : "3c369c4b-b491-4716-8f70-7b3695deabcc",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Sorry, need more coffee apparently, it is possible, since you can request a contiguous array. At that point you are using `NpyIter` for nothing else then the `writebackifcopy` logic, but it may be fair to do that anyway and accept the cost just to avoid `writebackifcopy` API.",
        "createdAt" : "2020-08-14T14:43:32Z",
        "updatedAt" : "2020-08-21T04:18:30Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "bea900b5-746b-4f4e-a3fc-9557967cfaa0",
        "parentId" : "3c369c4b-b491-4716-8f70-7b3695deabcc",
        "authorId" : "8de63a41-1bc1-4e93-a2df-4f2f940433cf",
        "body" : "Wait, are y'all talking about trying to use `nditer` in this special case where `axis=None`?  I assumed that suggestion applied to the main loop below.\r\n\r\nLocally (but not pushed yet), I've modified the code to not use the one-liner `self.shuffle(out.flat)` when `axis` is None.  I added special casing for contiguous arrays, so I only use the `writebackifcopy` machinery when `axis` is None, `ndim > 1`, and the array is not contiguous (that is not C-contiguous and not F-contiguous).",
        "createdAt" : "2020-08-14T14:56:32Z",
        "updatedAt" : "2020-08-21T04:18:30Z",
        "lastEditedBy" : "8de63a41-1bc1-4e93-a2df-4f2f940433cf",
        "tags" : [
        ]
      },
      {
        "id" : "b6547e51-6478-4d5b-a3fd-76cace61271d",
        "parentId" : "3c369c4b-b491-4716-8f70-7b3695deabcc",
        "authorId" : "8de63a41-1bc1-4e93-a2df-4f2f940433cf",
        "body" : "I pushed an update with new handling of the case `axis=None`.",
        "createdAt" : "2020-08-14T15:40:29Z",
        "updatedAt" : "2020-08-21T04:18:30Z",
        "lastEditedBy" : "8de63a41-1bc1-4e93-a2df-4f2f940433cf",
        "tags" : [
        ]
      },
      {
        "id" : "9ee1030c-72bb-4df5-87cf-61498447f4d5",
        "parentId" : "3c369c4b-b491-4716-8f70-7b3695deabcc",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Thanks, for me the current solution is fine, and the discussion can be resolved.",
        "createdAt" : "2020-08-14T22:04:32Z",
        "updatedAt" : "2020-08-21T04:18:30Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      }
    ],
    "commit" : "785e23901f5b84d677f04f4446449fabbc7575bf",
    "line" : 243,
    "diffHunk" : "@@ -1,1 +4312,4316 @@                # out is 1-d\n                self.shuffle(out)\n            return out\n\n        ax = normalize_axis_index(axis, np.ndim(out))"
  },
  {
    "id" : "0d242a46-b03b-4cd9-97b5-6a1b07a71c61",
    "prId" : 15121,
    "prUrl" : "https://github.com/numpy/numpy/pull/15121#pullrequestreview-461958531",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "68502a3d-a610-4188-ac95-7c37b33b0c3e",
        "parentId" : null,
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Do we typically support subclasses for `out`? I am happy with simply ignoring that for now though. It would be incorrect e.g. for masked arrays (but that is common).",
        "createdAt" : "2020-08-05T19:47:14Z",
        "updatedAt" : "2020-08-21T04:18:30Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      }
    ],
    "commit" : "785e23901f5b84d677f04f4446449fabbc7575bf",
    "line" : 216,
    "diffHunk" : "@@ -1,1 +4285,4289 @@            out = x.copy(order='K')\n        else:\n            if type(out) is not np.ndarray:\n                raise TypeError('out must be a numpy array')\n            if out.shape != x.shape:"
  },
  {
    "id" : "90474601-14d8-484f-a1e9-ea068e58f3aa",
    "prId" : 15121,
    "prUrl" : "https://github.com/numpy/numpy/pull/15121#pullrequestreview-478722036",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "03a43eb9-8904-4f51-b7ea-d1dccf328d02",
        "parentId" : null,
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "```suggestion\r\ncdef void _shuffle_raw_wrap(bitgen_t *bitgen, np.npy_intp n,\r\n```\r\nMight be worth timing, but I guess we don't actually have to specify `inline` here.  The important part is that `shuffle_raw` is inlined, the single call overhead is probably fairly insignificant, and will mean that `_shuffle_raw` will certainly not be pasted 4 times. (I am a bit curious if the compiler might even decide *not* to inline, and thus breaking the trick.)",
        "createdAt" : "2020-08-31T15:36:48Z",
        "updatedAt" : "2020-08-31T15:58:45Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "4ac3ffc1-32bf-4ab0-aaee-4b6e0e1af145",
        "parentId" : "03a43eb9-8904-4f51-b7ea-d1dccf328d02",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "But, `_shuffle_raw` is such a short function, that I guess it doesn't matter.",
        "createdAt" : "2020-08-31T15:37:38Z",
        "updatedAt" : "2020-08-31T15:58:45Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      }
    ],
    "commit" : "785e23901f5b84d677f04f4446449fabbc7575bf",
    "line" : 26,
    "diffHunk" : "@@ -1,1 +57,61 @@\n\ncdef inline void _shuffle_raw_wrap(bitgen_t *bitgen, np.npy_intp n,\n                                   np.npy_intp first, np.npy_intp itemsize,\n                                   np.npy_intp stride,"
  },
  {
    "id" : "cedc3f37-35fd-485d-b6be-e18c3b05ae19",
    "prId" : 15121,
    "prUrl" : "https://github.com/numpy/numpy/pull/15121#pullrequestreview-478722036",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b3c16dc7-5fdd-4e41-9931-e2eb0f5b259b",
        "parentId" : null,
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "```suggestion\r\n    int PyArray_ResolveWritebackIfCopy(np.ndarray) except -1\r\n```",
        "createdAt" : "2020-08-31T15:49:32Z",
        "updatedAt" : "2020-08-31T15:58:45Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      }
    ],
    "commit" : "785e23901f5b84d677f04f4446449fabbc7575bf",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +31,35 @@\ncdef extern from \"numpy/arrayobject.h\":\n    int PyArray_ResolveWritebackIfCopy(np.ndarray)\n    object PyArray_FromArray(np.PyArrayObject *, np.PyArray_Descr *, int)\n"
  },
  {
    "id" : "0d624a63-11b7-4766-9cad-0bff43a01133",
    "prId" : 15121,
    "prUrl" : "https://github.com/numpy/numpy/pull/15121#pullrequestreview-478722036",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2fc9c2f7-2b93-4244-91ad-44126239f9cc",
        "parentId" : null,
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "```suggestion\r\n        ax = normalize_axis_index(axis, out.ndim)\r\n```",
        "createdAt" : "2020-08-31T15:51:17Z",
        "updatedAt" : "2020-08-31T15:58:45Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      }
    ],
    "commit" : "785e23901f5b84d677f04f4446449fabbc7575bf",
    "line" : 245,
    "diffHunk" : "@@ -1,1 +4314,4318 @@            return out\n\n        ax = normalize_axis_index(axis, np.ndim(out))\n        itemsize = out.itemsize\n        axlen = out.shape[ax]"
  },
  {
    "id" : "71ccb804-0afb-4a90-a5c2-74bc27c2d9bb",
    "prId" : 15121,
    "prUrl" : "https://github.com/numpy/numpy/pull/15121#pullrequestreview-478722036",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "657de47f-9d98-4313-9723-969236d36001",
        "parentId" : null,
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "I guess we could hardcode itemsize, but doesn't really matter.",
        "createdAt" : "2020-08-31T15:54:44Z",
        "updatedAt" : "2020-08-31T15:58:45Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      }
    ],
    "commit" : "785e23901f5b84d677f04f4446449fabbc7575bf",
    "line" : 295,
    "diffHunk" : "@@ -1,1 +4411,4415 @@            if x.dtype.hasobject:\n                with self.lock:\n                    _shuffle_raw_wrap(&self._bitgen, n, 1, itemsize, stride,\n                                      x_ptr, buf_ptr)\n            else:"
  },
  {
    "id" : "abd0321a-28b7-40a4-b891-8624cf691ffd",
    "prId" : 15138,
    "prUrl" : "https://github.com/numpy/numpy/pull/15138#pullrequestreview-335792901",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1a874b16-b41b-4d56-a86c-8b5cdf63a317",
        "parentId" : null,
        "authorId" : "ed5564b3-30de-4cde-83d3-042942f7203d",
        "body" : "If using backticks for parameter names, don’t forget them for _replace_.",
        "createdAt" : "2019-12-21T14:48:54Z",
        "updatedAt" : "2019-12-23T10:03:29Z",
        "lastEditedBy" : "ed5564b3-30de-4cde-83d3-042942f7203d",
        "tags" : [
        ]
      },
      {
        "id" : "d55a3f0e-9bbe-483e-a0db-f14e15f91880",
        "parentId" : "1a874b16-b41b-4d56-a86c-8b5cdf63a317",
        "authorId" : "b15cf1a1-ba9d-47aa-b157-e0c1f40c5c5c",
        "body" : "I removed all backticks since these appear to be non standard in this module (I couldn't find any other uses).",
        "createdAt" : "2019-12-23T10:04:30Z",
        "updatedAt" : "2019-12-23T10:04:31Z",
        "lastEditedBy" : "b15cf1a1-ba9d-47aa-b157-e0c1f40c5c5c",
        "tags" : [
        ]
      }
    ],
    "commit" : "0fd2e0b01031f2225a3faf3ca31355f3cfed37ef",
    "line" : 86,
    "diffHunk" : "@@ -1,1 +780,784 @@            if size > pop_size:\n                raise ValueError(\"Cannot take a larger sample than \"\n                                 \"population when replace is False\")\n            elif size < 0:\n                raise ValueError(\"negative dimensions are not allowed\")"
  }
]
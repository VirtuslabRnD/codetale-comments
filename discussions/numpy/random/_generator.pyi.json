[
  {
    "id" : "38da75ea-ce31-4432-9455-a6618e4b9817",
    "prId" : 18395,
    "prUrl" : "https://github.com/numpy/numpy/pull/18395#pullrequestreview-589513523",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d749008c-6189-484e-8195-db63e823d9c4",
        "parentId" : null,
        "authorId" : "ebbd559e-4e98-4695-a417-e4a6bc303d63",
        "body" : "```suggestion\r\n    def shuffle(\r\n        self, x: Union[MutableSequence[Any], ndarray[Any, Any]], axis: int = ...\r\n    ) -> None: ...\r\n```\r\nTwo things:\r\n* `shuffle` performs inplace operations.\r\n* It's a bit more restrictive in its accepted input types, demanding a mutable sequence or actual `ndarray`.",
        "createdAt" : "2021-02-12T15:06:08Z",
        "updatedAt" : "2021-02-16T17:55:58Z",
        "lastEditedBy" : "ebbd559e-4e98-4695-a417-e4a6bc303d63",
        "tags" : [
        ]
      }
    ],
    "commit" : "0b46d6abe5e030b46d98c139b6fd858e6ef089c1",
    "line" : 532,
    "diffHunk" : "@@ -1,1 +530,534 @@        self, x: ArrayLike, *, axis: Optional[int] = ..., out: Optional[ndarray[Any, Any]] = ...\n    ) -> ndarray[Any, Any]: ...\n    def shuffle(self, x: ArrayLike, axis: int = ...) -> Sequence[Any]: ...\n\ndef default_rng(seed: Union[None, _ArrayLikeInt_co, SeedSequence] = ...) -> Generator: ..."
  },
  {
    "id" : "811bfa6e-5165-426d-8654-e2c2ccf6cbc7",
    "prId" : 18433,
    "prUrl" : "https://github.com/numpy/numpy/pull/18433#pullrequestreview-596913495",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1cf75b10-f3e9-4128-aa9b-4ef27dd021fc",
        "parentId" : null,
        "authorId" : "ebbd559e-4e98-4695-a417-e4a6bc303d63",
        "body" : "For in the future:\r\nThe `out` parameter is one of the rare few places where you can safelly use typevars (as it takes an array; not an array-like):\r\n\r\n``` python\r\nfrom typing import overload, TypeVar, Any\r\nimport numpy as np\r\n\r\n_ArrayType = TypeVar(\"_ArrayType\", bound=np.ndarray[Any, Any])\r\n\r\n@overload\r\ndef func(*args: Any, out: None = ..., **kwargs: Any) -> np.ndarray[Any, Any]: ...\r\n@overload\r\ndef func(*args: Any, out: _ArrayType, **kwargs: Any) -> _ArrayType: ...\r\n```",
        "createdAt" : "2021-02-23T15:56:17Z",
        "updatedAt" : "2021-02-24T10:41:33Z",
        "lastEditedBy" : "ebbd559e-4e98-4695-a417-e4a6bc303d63",
        "tags" : [
        ]
      },
      {
        "id" : "79cc288f-3ab7-427f-8d39-7d97f161e8ae",
        "parentId" : "1cf75b10-f3e9-4128-aa9b-4ef27dd021fc",
        "authorId" : "b15cf1a1-ba9d-47aa-b157-e0c1f40c5c5c",
        "body" : "Is that OK here since out has to be ` ndarray[Any, dtype[float64]]` and can't be any other type?\r\n",
        "createdAt" : "2021-02-23T17:00:27Z",
        "updatedAt" : "2021-02-24T10:41:33Z",
        "lastEditedBy" : "b15cf1a1-ba9d-47aa-b157-e0c1f40c5c5c",
        "tags" : [
        ]
      },
      {
        "id" : "fc91b04f-4a90-4bd4-b883-dc6842f3054a",
        "parentId" : "1cf75b10-f3e9-4128-aa9b-4ef27dd021fc",
        "authorId" : "b15cf1a1-ba9d-47aa-b157-e0c1f40c5c5c",
        "body" : "To be specific\r\n\r\nIn these 3:\r\n\r\n1. When using `out` and not type, `out` must be a `float64` array.\r\n2. When using `dtype=float32` out can be `None` or a `float32` array, but nothing else.\r\n3. When using `dtype=float64` out can be `None` or a `float64` array, but nothing else.\r\n\r\nCan I simplify these? Because of the `dtype` keyword argument that defaults to `np.float64`, it isn't a case of getting the type from `out` when `dtype` is missing.  Would have been a good design to do this, but I think that boat has sailed.\r\n\r\n```\r\n    @overload\r\n    def standard_normal(  # type: ignore[misc]\r\n        self,\r\n        *,\r\n        out: ndarray[Any, dtype[float64]] = ...,\r\n    ) -> ndarray[Any, dtype[float64]]: ...\r\n    @overload\r\n    def standard_normal(  # type: ignore[misc]\r\n        self,\r\n        size: _ShapeLike = ...,\r\n        dtype: _DTypeLikeFloat32 = ...,\r\n        out: Optional[ndarray[Any, dtype[float32]]] = ...,\r\n    ) -> ndarray[Any, dtype[float32]]: ...\r\n    @overload\r\n    def standard_normal(  # type: ignore[misc]\r\n        self,\r\n        size: _ShapeLike = ...,\r\n        dtype: _DTypeLikeFloat64 = ...,\r\n        out: Optional[ndarray[Any, dtype[float64]]] = ...,\r\n    ) -> ndarray[Any, dtype[float64]]: ...\r\n```",
        "createdAt" : "2021-02-23T17:17:27Z",
        "updatedAt" : "2021-02-24T10:41:33Z",
        "lastEditedBy" : "b15cf1a1-ba9d-47aa-b157-e0c1f40c5c5c",
        "tags" : [
        ]
      },
      {
        "id" : "52b2bb07-2501-4791-adec-b2946efc8996",
        "parentId" : "1cf75b10-f3e9-4128-aa9b-4ef27dd021fc",
        "authorId" : "ebbd559e-4e98-4695-a417-e4a6bc303d63",
        "body" : "Considering the limited set of accepted dtypes I don't think you can actually simplify this any further.\r\nLet's just keep things as they are.",
        "createdAt" : "2021-02-24T00:03:16Z",
        "updatedAt" : "2021-02-24T10:41:33Z",
        "lastEditedBy" : "ebbd559e-4e98-4695-a417-e4a6bc303d63",
        "tags" : [
        ]
      }
    ],
    "commit" : "d4c123657f08b43939a7b7e329f40015d38b2849",
    "line" : 70,
    "diffHunk" : "@@ -1,1 +96,100 @@        *,\n        out: ndarray[Any, dtype[float64]] = ...,\n    ) -> ndarray[Any, dtype[float64]]: ...\n    @overload\n    def standard_normal(  # type: ignore[misc]"
  }
]
[
  {
    "id" : "6464c286-0c4c-45f0-bf5d-b648fb0c9f48",
    "prId" : 16551,
    "prUrl" : "https://github.com/numpy/numpy/pull/16551#pullrequestreview-427430197",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "cfa8af7b-dc4c-4878-94ec-3cfe02d83feb",
        "parentId" : null,
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Should this test (also) spawn a single child?  Otherwise, does it actually test the trailing 0s, since the length would differ?",
        "createdAt" : "2020-06-09T17:17:46Z",
        "updatedAt" : "2020-06-10T16:40:56Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "6fc49e83-375c-4dac-aea4-8ff07326a5a5",
        "parentId" : "cfa8af7b-dc4c-4878-94ec-3cfe02d83feb",
        "authorId" : "85b881e8-d8a0-43d4-81d3-7e233dc5f1ae",
        "body" : "This one isn't related to #16539, just explicitly testing that we did design the conversion of large integers to `uint32` words correctly. There were two obvious ways to do it, and the other (perhaps more-obvious) way would have also caused a problem.",
        "createdAt" : "2020-06-09T18:06:41Z",
        "updatedAt" : "2020-06-10T16:40:56Z",
        "lastEditedBy" : "85b881e8-d8a0-43d4-81d3-7e233dc5f1ae",
        "tags" : [
        ]
      },
      {
        "id" : "a3b4c1df-a753-4405-983d-52a4628d8732",
        "parentId" : "cfa8af7b-dc4c-4878-94ec-3cfe02d83feb",
        "authorId" : "85b881e8-d8a0-43d4-81d3-7e233dc5f1ae",
        "body" : "The way we convert `42 << 32` into a `uint32` array for consumption by `SeedSequence` converts it to `[0, 42]`. The other way to do it (\"big-endian\") would have converted it to `[42, 0]`, which would mean that `42`, `42 << 32`, `42 << 64` and `42 << 96` all would generate the same states.",
        "createdAt" : "2020-06-09T18:09:06Z",
        "updatedAt" : "2020-06-10T16:40:56Z",
        "lastEditedBy" : "85b881e8-d8a0-43d4-81d3-7e233dc5f1ae",
        "tags" : [
        ]
      },
      {
        "id" : "102188df-58d9-44e6-918e-c12fadf97355",
        "parentId" : "cfa8af7b-dc4c-4878-94ec-3cfe02d83feb",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "I relalize, I figured that in one case (if this was the \"bad\" version) this would be `[42,]` and in the other `[42, 0]` and I assume that this would still give a different result due to the hashing procedure being sensitive to trailing 0s as well.\r\nBut with the 0 appending from the spawn key, it becomes `[42, ..., 0]` in both cases, where `...` is filled with 0s.\r\nIn any case, I don't mind, it is still a good test.",
        "createdAt" : "2020-06-09T18:19:37Z",
        "updatedAt" : "2020-06-10T16:40:56Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "4673595a-6900-4c1e-8614-89d34a7beaee",
        "parentId" : "cfa8af7b-dc4c-4878-94ec-3cfe02d83feb",
        "authorId" : "85b881e8-d8a0-43d4-81d3-7e233dc5f1ae",
        "body" : "The problem is that the concatenated words of entropy (`entropy` and `spawn_key`, as returned by `get_assembled_entropy()`) will still get 0-padded to `pool_size` if it's shorter. It just happens implicitly.\r\n\r\nhttps://github.com/numpy/numpy/blob/7a82f14075eaf8f59ea3bb2594b71639e938611e/numpy/random/bit_generator.pyx#L359-L361\r\n\r\nThe hashing algorithm is only sensitive to different number of trailing 0s for trailing 0s beyond the `pool_size`. This is testing for a potential design flaw (which I avoided) even without the `spawn_key`.",
        "createdAt" : "2020-06-09T18:26:30Z",
        "updatedAt" : "2020-06-10T16:40:56Z",
        "lastEditedBy" : "85b881e8-d8a0-43d4-81d3-7e233dc5f1ae",
        "tags" : [
        ]
      }
    ],
    "commit" : "e1db72c2c99d23982551def864b24d277b297aa6",
    "line" : 19,
    "diffHunk" : "@@ -1,1 +61,65 @@    # trailing 0s.\n    ss0 = SeedSequence(42)\n    ss1 = SeedSequence(42 << 32)\n    assert_array_compare(\n        np.not_equal,"
  }
]
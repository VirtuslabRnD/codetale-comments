[
  {
    "id" : "28a0d683-2703-4af5-993c-27fa9b95afb1",
    "prId" : 5796,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3d5e625c-e487-45e1-bded-c34b7a02507a",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : " There is the corner case where `labs(y - m)` is negative, so maybe the safer thing here is to cast `y - m` to float.\n",
        "createdAt" : "2015-04-24T15:55:44Z",
        "updatedAt" : "2015-04-24T15:55:44Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "bf584305-0a73-4831-b576-416f56b3f62d",
        "parentId" : "3d5e625c-e487-45e1-bded-c34b7a02507a",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Hmm, k is `long`, also gets squared further down (overflow?). I quess this is no worse than it was, but the whole routine might be less than perfect.\n",
        "createdAt" : "2015-04-24T16:12:41Z",
        "updatedAt" : "2015-04-24T16:12:41Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "9ec8e5c0af892abe25eee4f269bd225dac47414b",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +317,321 @@\n  Step50:\n    k = labs(y - m);\n    if ((k > 20) && (k < ((nrq)/2.0 - 1))) goto Step52;\n"
  },
  {
    "id" : "2020f367-dcf5-41a0-a13c-529cab8671e6",
    "prId" : 5858,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "27046cd4-37ce-485c-9330-fb898d0215e4",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "`{` on previous line.\n",
        "createdAt" : "2015-05-09T23:41:55Z",
        "updatedAt" : "2015-05-10T10:12:09Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "f50862ca-eea1-42ad-88ff-7039021099bf",
        "parentId" : "27046cd4-37ce-485c-9330-fb898d0215e4",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "OK, IIRC, this is random.c style ;)\n",
        "createdAt" : "2015-05-09T23:42:33Z",
        "updatedAt" : "2015-05-10T10:12:09Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "c7f121abb24e19c34246c8ad834dfdd5bd5ce8b2",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +201,205 @@            {\n                if (X +Y > 0)\n                {\n                    return X / (X + Y);\n                }"
  },
  {
    "id" : "965f9ec4-edb1-4e2a-b0bc-db901caf668b",
    "prId" : 7740,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e55ba8a1-696c-4758-b87b-caf3efc80a3c",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Google shows a more complete citation.\n\nW. Hörmann and G. Derflinger\nThe transformed rejection method for generating random variables, an alternative to the ratio of uniforms method\nCommunications in Statistics: Simulation and Computation 23(3), 847-860 (1994) \n",
        "createdAt" : "2016-06-13T16:42:12Z",
        "updatedAt" : "2016-06-13T17:41:15Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "27cb8656-06ed-4164-8e8a-0b5701e819c4",
        "parentId" : "e55ba8a1-696c-4758-b87b-caf3efc80a3c",
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "thats another paper by the same author, likely generalized\nthe exact algorithm was first published in W. Hörmann \nThe transformed rejection method for generating Poisson random variables Insurance: Mathematics and Economics 12, 39-45 (1993)\nI kept it short as you can find the thing by googling the numbers involved so I though the title ie enough ;)\n",
        "createdAt" : "2016-06-13T17:37:49Z",
        "updatedAt" : "2016-06-13T17:41:15Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      },
      {
        "id" : "3fd5dc4d-c414-4c69-ae65-5c654b20b25a",
        "parentId" : "e55ba8a1-696c-4758-b87b-caf3efc80a3c",
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "updated with a more complete citation\n",
        "createdAt" : "2016-06-13T17:41:40Z",
        "updatedAt" : "2016-06-13T17:41:40Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      }
    ],
    "commit" : "69fb4f160518ac347efc63dc17ebdf81285c1958",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +501,505 @@}\n\n/*\n * The transformed rejection method for generating Poisson random variables\n * W. Hoermann"
  },
  {
    "id" : "26b2b1bc-bfeb-4369-aac2-a744ce523ba1",
    "prId" : 9824,
    "prUrl" : "https://github.com/numpy/numpy/pull/9824#pullrequestreview-67698409",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "03512a3a-cf28-4ef8-88ac-ccaeb5de1ba1",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Does inverting this condition have any `nan`-related effect? What happens if `a == 1` before and after this patch?",
        "createdAt" : "2017-10-05T06:30:33Z",
        "updatedAt" : "2017-10-06T15:05:34Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "99f01038-53db-4af8-820c-f110ffea6574",
        "parentId" : "03512a3a-cf28-4ef8-88ac-ccaeb5de1ba1",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Or if you don't want to think about that, just leave it as before but replace the below `break` with `continue`, and `return (long) X` at the end of the loop.",
        "createdAt" : "2017-10-05T06:32:14Z",
        "updatedAt" : "2017-10-06T15:05:34Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "b08138f5-a14a-4e3b-a927-8edc4e9f8c3c",
        "parentId" : "03512a3a-cf28-4ef8-88ac-ccaeb5de1ba1",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Yes, it works better :) A nan will compare false and the loop will repeat. I don't think any of the distributions were coded with nans in mind, but I don't think we will get any nans here. In any case, theoretically b > 1, and the function computing b is well behaved when b is near 1, so I don't think it is a problem in practice either.\r\n\r\nOne could rewrite the condition without divisions, and I think that would be safe, but that is a bigger modification.",
        "createdAt" : "2017-10-05T15:31:31Z",
        "updatedAt" : "2017-10-06T15:05:34Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "2bcec9a2-f1d5-4f29-b252-2c0eed755d22",
        "parentId" : "03512a3a-cf28-4ef8-88ac-ccaeb5de1ba1",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Of course, the library functions could be buggy, and `(b - 1.0)` negative, in which case getting rid of the divisions would be an improvement, but rejection based algorithms are always uncertain to the degree that the functions used change between libraries and architectures.",
        "createdAt" : "2017-10-05T15:50:13Z",
        "updatedAt" : "2017-10-06T15:05:34Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "e768483e-82e9-4823-97bb-c4a347c5f111",
        "parentId" : "03512a3a-cf28-4ef8-88ac-ccaeb5de1ba1",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "> A nan will compare false and the loop will repeat\r\n\r\nMy concern here is trapping the algorithm in an infinite loop on `nan`, where previously it would return (admittedly a bad value).\r\n\r\nIn fact, `a == nan` would cause that behaviour, right?\r\n\r\nCan you just flip the condition to what it was before?\r\n\r\n```\r\nif (V*X*(T - 1.0)/(b - 1.0) > T/b) {\r\n    continue;\r\n}\r\nreturn (long) X;",
        "createdAt" : "2017-10-06T05:42:43Z",
        "updatedAt" : "2017-10-06T15:05:34Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "3ddb34b1-0c1c-4fde-8d76-70d5c395a555",
        "parentId" : "03512a3a-cf28-4ef8-88ac-ccaeb5de1ba1",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Hmm, seems it's already broken on `np.nan` in 1.12 anyway(#9829), so I guess this is out of scope",
        "createdAt" : "2017-10-06T05:46:24Z",
        "updatedAt" : "2017-10-06T15:05:34Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "28a6a381-111c-47ad-afd5-905bcf667944",
        "parentId" : "03512a3a-cf28-4ef8-88ac-ccaeb5de1ba1",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "The validation of `a` is in the calling routine, so that is where the `nan` check should be. I can fix that. I wouldn't be surprised if other routines can also fail with `nan`. Long loops for `a` slightly bigger than 1 indicates a faulty algorithm. Rejection should not happen that often in a good algorithm.",
        "createdAt" : "2017-10-06T15:06:02Z",
        "updatedAt" : "2017-10-06T15:06:03Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "45e00937723064f14752fc88c18e7146e62789a0",
    "line" : 45,
    "diffHunk" : "@@ -1,1 +742,746 @@\n        T = pow(1.0 + 1.0/X, am1);\n        if (V*X*(T - 1.0)/(b - 1.0) <= T/b) {\n            return (long)X;\n        }"
  }
]
[
  {
    "id" : "4c29a693-198f-4f6a-938e-649beea51284",
    "prId" : 16503,
    "prUrl" : "https://github.com/numpy/numpy/pull/16503#pullrequestreview-426275403",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "de50b8b2-3891-4099-9dd0-d6cd3675a1f4",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "@seberg, is this something that `PyArray_MultiIterNew2` ought to handle for output arrays? Or would we need to use a different type of iterator instead?",
        "createdAt" : "2020-06-05T12:27:23Z",
        "updatedAt" : "2020-06-05T12:27:23Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "8b890589-7583-48e5-92ef-31c64cd790b7",
        "parentId" : "de50b8b2-3891-4099-9dd0-d6cd3675a1f4",
        "authorId" : "b15cf1a1-ba9d-47aa-b157-e0c1f40c5c5c",
        "body" : "Not sure if this answers your question as to why this is here, but here goes.\r\n\r\nIt handles the case where they don't broadcast.  The issue here happens when the iterator is say (m,n) but randoms is (m,1). This results in the output (which is randoms) being repeatedly filled and only containing the last value where it came up from the iterator.  \r\n\r\nEssentially randoms has to be (a) broadcastable with the broadcast size of the broadcast value of all of the functions inputs and (b) weakly larger than the broadcast size all inputs. Say if there are 3 inputs, a,b,c, then we can define input_shape=(a+b+c).shape. If `n=len(input_shape)`, then it much be the case that\r\n\r\n```\r\nfor i_s, o_s in zip(input_shape, output_shape[-n:]):\r\n    assert i_s == o_s or (o_s > i_s and i_s==1)\r\n```\r\n\r\nThis was a manual check in the old RandomState.",
        "createdAt" : "2020-06-05T12:50:04Z",
        "updatedAt" : "2020-06-05T12:50:05Z",
        "lastEditedBy" : "b15cf1a1-ba9d-47aa-b157-e0c1f40c5c5c",
        "tags" : [
        ]
      },
      {
        "id" : "68e88544-7d90-4ab9-ae82-407155742b85",
        "parentId" : "de50b8b2-3891-4099-9dd0-d6cd3675a1f4",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "My claim is simply that I'm surprised our iteration constructors don't already have checks for such a case.",
        "createdAt" : "2020-06-05T12:58:33Z",
        "updatedAt" : "2020-06-05T12:58:33Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "ca6487e1-79bb-45d1-a2ee-6694251ef82d",
        "parentId" : "de50b8b2-3891-4099-9dd0-d6cd3675a1f4",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Well, to be fair `PyArray_MultiIterNew` which this uses is the old iterator API. The new iterator API will have larger overheads for small arrays, but otherwise be much faster (ufuncs have an \"all inputs contiguous or 1D\" special case because of that.\r\n\r\nSo yes, I think this is expected. The old style iterator does simple broadcasting. The new-style could be flagged to only allow `out` to be larger, but not smaller (at this time).",
        "createdAt" : "2020-06-05T13:50:09Z",
        "updatedAt" : "2020-06-05T13:50:09Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "72a67a49-9e0c-4056-8d5e-1c3f6db9203e",
        "parentId" : "de50b8b2-3891-4099-9dd0-d6cd3675a1f4",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Should we be converting all of the random stuff to use the new iterator?",
        "createdAt" : "2020-06-08T14:03:40Z",
        "updatedAt" : "2020-06-08T14:03:40Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "776189a168f12c8da385a48ab1c381133908fa73",
    "line" : 24,
    "diffHunk" : "@@ -1,1 +418,422 @@    n = np.PyArray_SIZE(randoms)\n    it = np.PyArray_MultiIterNew2(randoms, a_arr)\n    validate_output_shape(it.shape, randoms)\n\n    with lock, nogil:"
  }
]
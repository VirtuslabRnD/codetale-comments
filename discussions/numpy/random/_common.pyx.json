[
  {
    "id" : "4c29a693-198f-4f6a-938e-649beea51284",
    "prId" : 16503,
    "prUrl" : "https://github.com/numpy/numpy/pull/16503#pullrequestreview-426275403",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "de50b8b2-3891-4099-9dd0-d6cd3675a1f4",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "@seberg, is this something that `PyArray_MultiIterNew2` ought to handle for output arrays? Or would we need to use a different type of iterator instead?",
        "createdAt" : "2020-06-05T12:27:23Z",
        "updatedAt" : "2020-06-05T12:27:23Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "8b890589-7583-48e5-92ef-31c64cd790b7",
        "parentId" : "de50b8b2-3891-4099-9dd0-d6cd3675a1f4",
        "authorId" : "b15cf1a1-ba9d-47aa-b157-e0c1f40c5c5c",
        "body" : "Not sure if this answers your question as to why this is here, but here goes.\r\n\r\nIt handles the case where they don't broadcast.  The issue here happens when the iterator is say (m,n) but randoms is (m,1). This results in the output (which is randoms) being repeatedly filled and only containing the last value where it came up from the iterator.  \r\n\r\nEssentially randoms has to be (a) broadcastable with the broadcast size of the broadcast value of all of the functions inputs and (b) weakly larger than the broadcast size all inputs. Say if there are 3 inputs, a,b,c, then we can define input_shape=(a+b+c).shape. If `n=len(input_shape)`, then it much be the case that\r\n\r\n```\r\nfor i_s, o_s in zip(input_shape, output_shape[-n:]):\r\n    assert i_s == o_s or (o_s > i_s and i_s==1)\r\n```\r\n\r\nThis was a manual check in the old RandomState.",
        "createdAt" : "2020-06-05T12:50:04Z",
        "updatedAt" : "2020-06-05T12:50:05Z",
        "lastEditedBy" : "b15cf1a1-ba9d-47aa-b157-e0c1f40c5c5c",
        "tags" : [
        ]
      },
      {
        "id" : "68e88544-7d90-4ab9-ae82-407155742b85",
        "parentId" : "de50b8b2-3891-4099-9dd0-d6cd3675a1f4",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "My claim is simply that I'm surprised our iteration constructors don't already have checks for such a case.",
        "createdAt" : "2020-06-05T12:58:33Z",
        "updatedAt" : "2020-06-05T12:58:33Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "ca6487e1-79bb-45d1-a2ee-6694251ef82d",
        "parentId" : "de50b8b2-3891-4099-9dd0-d6cd3675a1f4",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Well, to be fair `PyArray_MultiIterNew` which this uses is the old iterator API. The new iterator API will have larger overheads for small arrays, but otherwise be much faster (ufuncs have an \"all inputs contiguous or 1D\" special case because of that.\r\n\r\nSo yes, I think this is expected. The old style iterator does simple broadcasting. The new-style could be flagged to only allow `out` to be larger, but not smaller (at this time).",
        "createdAt" : "2020-06-05T13:50:09Z",
        "updatedAt" : "2020-06-05T13:50:09Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "72a67a49-9e0c-4056-8d5e-1c3f6db9203e",
        "parentId" : "de50b8b2-3891-4099-9dd0-d6cd3675a1f4",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Should we be converting all of the random stuff to use the new iterator?",
        "createdAt" : "2020-06-08T14:03:40Z",
        "updatedAt" : "2020-06-08T14:03:40Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "776189a168f12c8da385a48ab1c381133908fa73",
    "line" : 24,
    "diffHunk" : "@@ -1,1 +418,422 @@    n = np.PyArray_SIZE(randoms)\n    it = np.PyArray_MultiIterNew2(randoms, a_arr)\n    validate_output_shape(it.shape, randoms)\n\n    with lock, nogil:"
  },
  {
    "id" : "a7c08348-b2be-449e-95c0-630a2d633113",
    "prId" : 18649,
    "prUrl" : "https://github.com/numpy/numpy/pull/18649#pullrequestreview-616725000",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e6a0d02a-141f-4f45-8e70-953bfbda873c",
        "parentId" : null,
        "authorId" : "85b881e8-d8a0-43d4-81d3-7e233dc5f1ae",
        "body" : "Since we're here, I guess this should be `shape` rather than `dims` (or else fix the `cdef`)",
        "createdAt" : "2021-03-19T13:51:15Z",
        "updatedAt" : "2021-03-19T15:52:47Z",
        "lastEditedBy" : "85b881e8-d8a0-43d4-81d3-7e233dc5f1ae",
        "tags" : [
        ]
      },
      {
        "id" : "7a514bcc-8fc4-4278-bce5-f31f8b8db005",
        "parentId" : "e6a0d02a-141f-4f45-8e70-953bfbda873c",
        "authorId" : "b15cf1a1-ba9d-47aa-b157-e0c1f40c5c5c",
        "body" : "Fixed\r\n",
        "createdAt" : "2021-03-19T19:19:10Z",
        "updatedAt" : "2021-03-19T19:19:10Z",
        "lastEditedBy" : "b15cf1a1-ba9d-47aa-b157-e0c1f40c5c5c",
        "tags" : [
        ]
      }
    ],
    "commit" : "9aacb3a2a736ed5e0ec885e3b7cae9629c683ef2",
    "line" : 9,
    "diffHunk" : "@@ -1,1 +223,227 @@    cdef np.npy_intp ndim, i\n    cdef bint error\n    dims = np.PyArray_DIMS(output)\n    ndim = np.PyArray_NDIM(output)\n    output_shape = tuple((dims[i] for i in range(ndim)))"
  },
  {
    "id" : "447109e4-11c4-4f4f-bd23-8c9eb03528dd",
    "prId" : 18731,
    "prUrl" : "https://github.com/numpy/numpy/pull/18731#pullrequestreview-629701036",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "14ee54de-ea13-41de-8586-0f6aca4caeab",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "I checked a bit more, the `PyArray_IS*` functions also require not swapped, which is in addition to the other requirements. Does that cause a problem?",
        "createdAt" : "2021-04-06T17:50:49Z",
        "updatedAt" : "2021-04-07T07:56:40Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "b83fab6b-0655-4c7b-94cc-643bde0d47c0",
        "parentId" : "14ee54de-ea13-41de-8586-0f6aca4caeab",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Looks like the random generator doesn't support swapped types anyway, but that was caught in the dtype check.",
        "createdAt" : "2021-04-06T18:38:46Z",
        "updatedAt" : "2021-04-07T07:56:40Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "64a4bde3-e7d7-42d9-a22a-566a5e91665e",
        "parentId" : "14ee54de-ea13-41de-8586-0f6aca4caeab",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "I think we can just add \"not swapped\" to the error message.",
        "createdAt" : "2021-04-07T01:47:39Z",
        "updatedAt" : "2021-04-07T07:56:40Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "24f2fd7a-d6c0-432a-a30d-e9c8f038c409",
        "parentId" : "14ee54de-ea13-41de-8586-0f6aca4caeab",
        "authorId" : "b15cf1a1-ba9d-47aa-b157-e0c1f40c5c5c",
        "body" : "I added in machine byte-order, which mirrors the docs for behaved.",
        "createdAt" : "2021-04-07T07:57:04Z",
        "updatedAt" : "2021-04-07T07:57:04Z",
        "lastEditedBy" : "b15cf1a1-ba9d-47aa-b157-e0c1f40c5c5c",
        "tags" : [
        ]
      }
    ],
    "commit" : "d2cbd17cba2132e8c02da394be5c3f93ddd76919",
    "line" : 29,
    "diffHunk" : "@@ -1,1 +254,258 @@        return\n    cdef np.ndarray out_array = <np.ndarray>out\n    if not (np.PyArray_ISCARRAY(out_array) or\n            (np.PyArray_ISFARRAY(out_array) and not require_c_array)):\n        req = \"C-\" if require_c_array else \"\""
  }
]
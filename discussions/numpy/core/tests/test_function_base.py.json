[
  {
    "id" : "cc0bb896-a666-44c2-9c9c-0c77818d23da",
    "prId" : 7268,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c681db2a-8121-4cad-a630-8b6f8277d193",
        "parentId" : null,
        "authorId" : "0d70c244-f732-4a44-9ae8-c3f6de7e9b40",
        "body" : "A couple of additional tests I would like to see:\n- `start` > `stop`\n- complex inputs\n- negative `start`, `stop`, both\n- zero `stop` should raise too\n",
        "createdAt" : "2016-02-18T02:19:36Z",
        "updatedAt" : "2016-06-21T23:19:11Z",
        "lastEditedBy" : "0d70c244-f732-4a44-9ae8-c3f6de7e9b40",
        "tags" : [
        ]
      },
      {
        "id" : "f492f091-e63d-450a-916c-96d6e199ce6f",
        "parentId" : "c681db2a-8121-4cad-a630-8b6f8277d193",
        "authorId" : "0d70c244-f732-4a44-9ae8-c3f6de7e9b40",
        "body" : "You may also want to add basically the same tests as `linspace`/`logspace` do, possibly including the ones for subclasses, etc. While currently the tests of `logspace` cover most of the functionality of your function, there is no guarantee that it will be implemented in terms of `logspace` in the future. For example, the `exp(linspace(...))` implementation given by @rkern [here](https://github.com/numpy/numpy/issues/7255#issuecomment-184586446). `numpy.percentile` used to be implemented in terms of `sort`. Then it got reimplemented in terms of `numpy.partition`. That is the sort of thing tests are really good for.\n",
        "createdAt" : "2016-02-18T02:44:44Z",
        "updatedAt" : "2016-06-21T23:19:11Z",
        "lastEditedBy" : "0d70c244-f732-4a44-9ae8-c3f6de7e9b40",
        "tags" : [
        ]
      },
      {
        "id" : "20e3e83d-5189-4df0-8c94-baf928129fda",
        "parentId" : "c681db2a-8121-4cad-a630-8b6f8277d193",
        "authorId" : "0d70c244-f732-4a44-9ae8-c3f6de7e9b40",
        "body" : "I am a bit of a fan of overkill testing. For every time a test has saved me from publicly showing my stupidity, there has always been that one test that I forgot to write.\n",
        "createdAt" : "2016-02-18T02:45:52Z",
        "updatedAt" : "2016-06-21T23:19:11Z",
        "lastEditedBy" : "0d70c244-f732-4a44-9ae8-c3f6de7e9b40",
        "tags" : [
        ]
      },
      {
        "id" : "2fe71486-0f87-4f7b-a470-e82e614a9d17",
        "parentId" : "c681db2a-8121-4cad-a630-8b6f8277d193",
        "authorId" : "773890ba-3450-4435-9153-0848dcaf7d8e",
        "body" : "How should complex or negative inputs behave?\n\n`geomspace(1+0j, 0-1j, 4)` produces\n\n```\n[1+0j, √3/2-0.5j, 0.5-√3/2j,   0-1j]  (each √3/2-0.5j times the previous)\n```\n\nbut\n\n```\n[1+0j,  0+1j, -1+0j,  0-1j]  (each 1j times the previous)\n```\n\nwould be equally valid, I think.\n\nNegative inputs fail, currently:\n\n```\ngeomspace(-100, -1, 3)\nOut[166]: array([ nan,  nan,  nan])\n```\n\nbut I could see the correct answer being `[-100, -10, -1]` like symlog in matplotlib.\n",
        "createdAt" : "2016-02-18T04:04:44Z",
        "updatedAt" : "2016-06-21T23:19:11Z",
        "lastEditedBy" : "773890ba-3450-4435-9153-0848dcaf7d8e",
        "tags" : [
        ]
      },
      {
        "id" : "b011018a-bd4e-4e59-8319-0ae8daf4c4f2",
        "parentId" : "c681db2a-8121-4cad-a630-8b6f8277d193",
        "authorId" : "0d70c244-f732-4a44-9ae8-c3f6de7e9b40",
        "body" : "At the moment, you are doing whatever `logspace` is doing, and that is fine. I do like the idea of supporting negative numbers though. Either way, you should define and document the behavior, then write a test for it.\n",
        "createdAt" : "2016-02-18T04:12:52Z",
        "updatedAt" : "2016-06-21T23:19:11Z",
        "lastEditedBy" : "0d70c244-f732-4a44-9ae8-c3f6de7e9b40",
        "tags" : [
        ]
      },
      {
        "id" : "6aa3945c-25dd-42d6-a557-fc2b516a2bfa",
        "parentId" : "c681db2a-8121-4cad-a630-8b6f8277d193",
        "authorId" : "0d70c244-f732-4a44-9ae8-c3f6de7e9b40",
        "body" : "You may want to ask for the opinion of someone who might use such a feature. I can see myself using this function, but only with real inputs, so I would be fine with complex and negative inputs raising an error, returning nan or connecting the endpoints via some meaningful curve. The last option is probably optimal. The point of documenting and writing tests would be that if you change the internals, the public API remains the same and there are tests to make sure that happens.\n",
        "createdAt" : "2016-02-18T04:17:25Z",
        "updatedAt" : "2016-06-21T23:19:11Z",
        "lastEditedBy" : "0d70c244-f732-4a44-9ae8-c3f6de7e9b40",
        "tags" : [
        ]
      }
    ],
    "commit" : "e53570dda20ba7863b1aa225a069a206b9d725e2",
    "line" : 140,
    "diffHunk" : "@@ -1,1 +148,152 @@        y = geomspace(1, 1e6, dtype='int32')\n        assert_equal(y.dtype, dtype('int32'))\n\n        # Native types\n        y = geomspace(1, 1e6, dtype=float)"
  }
]
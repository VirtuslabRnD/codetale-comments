[
  {
    "id" : "cc0bb896-a666-44c2-9c9c-0c77818d23da",
    "prId" : 7268,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c681db2a-8121-4cad-a630-8b6f8277d193",
        "parentId" : null,
        "authorId" : "0d70c244-f732-4a44-9ae8-c3f6de7e9b40",
        "body" : "A couple of additional tests I would like to see:\n- `start` > `stop`\n- complex inputs\n- negative `start`, `stop`, both\n- zero `stop` should raise too\n",
        "createdAt" : "2016-02-18T02:19:36Z",
        "updatedAt" : "2016-06-21T23:19:11Z",
        "lastEditedBy" : "0d70c244-f732-4a44-9ae8-c3f6de7e9b40",
        "tags" : [
        ]
      },
      {
        "id" : "f492f091-e63d-450a-916c-96d6e199ce6f",
        "parentId" : "c681db2a-8121-4cad-a630-8b6f8277d193",
        "authorId" : "0d70c244-f732-4a44-9ae8-c3f6de7e9b40",
        "body" : "You may also want to add basically the same tests as `linspace`/`logspace` do, possibly including the ones for subclasses, etc. While currently the tests of `logspace` cover most of the functionality of your function, there is no guarantee that it will be implemented in terms of `logspace` in the future. For example, the `exp(linspace(...))` implementation given by @rkern [here](https://github.com/numpy/numpy/issues/7255#issuecomment-184586446). `numpy.percentile` used to be implemented in terms of `sort`. Then it got reimplemented in terms of `numpy.partition`. That is the sort of thing tests are really good for.\n",
        "createdAt" : "2016-02-18T02:44:44Z",
        "updatedAt" : "2016-06-21T23:19:11Z",
        "lastEditedBy" : "0d70c244-f732-4a44-9ae8-c3f6de7e9b40",
        "tags" : [
        ]
      },
      {
        "id" : "20e3e83d-5189-4df0-8c94-baf928129fda",
        "parentId" : "c681db2a-8121-4cad-a630-8b6f8277d193",
        "authorId" : "0d70c244-f732-4a44-9ae8-c3f6de7e9b40",
        "body" : "I am a bit of a fan of overkill testing. For every time a test has saved me from publicly showing my stupidity, there has always been that one test that I forgot to write.\n",
        "createdAt" : "2016-02-18T02:45:52Z",
        "updatedAt" : "2016-06-21T23:19:11Z",
        "lastEditedBy" : "0d70c244-f732-4a44-9ae8-c3f6de7e9b40",
        "tags" : [
        ]
      },
      {
        "id" : "2fe71486-0f87-4f7b-a470-e82e614a9d17",
        "parentId" : "c681db2a-8121-4cad-a630-8b6f8277d193",
        "authorId" : "773890ba-3450-4435-9153-0848dcaf7d8e",
        "body" : "How should complex or negative inputs behave?\n\n`geomspace(1+0j, 0-1j, 4)` produces\n\n```\n[1+0j, √3/2-0.5j, 0.5-√3/2j,   0-1j]  (each √3/2-0.5j times the previous)\n```\n\nbut\n\n```\n[1+0j,  0+1j, -1+0j,  0-1j]  (each 1j times the previous)\n```\n\nwould be equally valid, I think.\n\nNegative inputs fail, currently:\n\n```\ngeomspace(-100, -1, 3)\nOut[166]: array([ nan,  nan,  nan])\n```\n\nbut I could see the correct answer being `[-100, -10, -1]` like symlog in matplotlib.\n",
        "createdAt" : "2016-02-18T04:04:44Z",
        "updatedAt" : "2016-06-21T23:19:11Z",
        "lastEditedBy" : "773890ba-3450-4435-9153-0848dcaf7d8e",
        "tags" : [
        ]
      },
      {
        "id" : "b011018a-bd4e-4e59-8319-0ae8daf4c4f2",
        "parentId" : "c681db2a-8121-4cad-a630-8b6f8277d193",
        "authorId" : "0d70c244-f732-4a44-9ae8-c3f6de7e9b40",
        "body" : "At the moment, you are doing whatever `logspace` is doing, and that is fine. I do like the idea of supporting negative numbers though. Either way, you should define and document the behavior, then write a test for it.\n",
        "createdAt" : "2016-02-18T04:12:52Z",
        "updatedAt" : "2016-06-21T23:19:11Z",
        "lastEditedBy" : "0d70c244-f732-4a44-9ae8-c3f6de7e9b40",
        "tags" : [
        ]
      },
      {
        "id" : "6aa3945c-25dd-42d6-a557-fc2b516a2bfa",
        "parentId" : "c681db2a-8121-4cad-a630-8b6f8277d193",
        "authorId" : "0d70c244-f732-4a44-9ae8-c3f6de7e9b40",
        "body" : "You may want to ask for the opinion of someone who might use such a feature. I can see myself using this function, but only with real inputs, so I would be fine with complex and negative inputs raising an error, returning nan or connecting the endpoints via some meaningful curve. The last option is probably optimal. The point of documenting and writing tests would be that if you change the internals, the public API remains the same and there are tests to make sure that happens.\n",
        "createdAt" : "2016-02-18T04:17:25Z",
        "updatedAt" : "2016-06-21T23:19:11Z",
        "lastEditedBy" : "0d70c244-f732-4a44-9ae8-c3f6de7e9b40",
        "tags" : [
        ]
      }
    ],
    "commit" : "e53570dda20ba7863b1aa225a069a206b9d725e2",
    "line" : 140,
    "diffHunk" : "@@ -1,1 +148,152 @@        y = geomspace(1, 1e6, dtype='int32')\n        assert_equal(y.dtype, dtype('int32'))\n\n        # Native types\n        y = geomspace(1, 1e6, dtype=float)"
  },
  {
    "id" : "1761e128-4bee-4934-a743-9ac24b9beb7e",
    "prId" : 8658,
    "prUrl" : "https://github.com/numpy/numpy/pull/8658#pullrequestreview-23097800",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4a811cc2-677e-41f5-aa3a-e448f811f0ce",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "If this was 0 before, then an assertion (or perhaps better, an exception to make the test error) that it is not zero now would probably be a good thing.",
        "createdAt" : "2017-02-21T22:50:04Z",
        "updatedAt" : "2017-02-22T01:15:14Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "734db1c2-cf30-47ab-ae1c-4061237fadef",
        "parentId" : "4a811cc2-677e-41f5-aa3a-e448f811f0ce",
        "authorId" : "7ff2710f-0a12-46fb-a54a-d405dab78cf7",
        "body" : "I don't think it can be zero now, unless there's a bug in `nextafter`.",
        "createdAt" : "2017-02-21T22:57:15Z",
        "updatedAt" : "2017-02-22T01:15:14Z",
        "lastEditedBy" : "7ff2710f-0a12-46fb-a54a-d405dab78cf7",
        "tags" : [
        ]
      },
      {
        "id" : "c79f040f-6652-4035-81e6-a1e4f8d59dac",
        "parentId" : "4a811cc2-677e-41f5-aa3a-e448f811f0ce",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Testing for a bug in `nextafter` sounds like something that should be tested somewhere, and if not elsewhere, here is as good a place as any",
        "createdAt" : "2017-02-21T23:12:01Z",
        "updatedAt" : "2017-02-22T01:15:14Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "78df10f58d8963829865515f98695f04a1f76e00",
    "line" : 18,
    "diffHunk" : "@@ -1,1 +303,307 @@        # with ICC, which flushes denormals to zero\n        for ftype in sctypes['float']:\n            stop = nextafter(ftype(0), ftype(1)) * 5  # A denormal number\n            assert_(any(linspace(0, stop, 10, endpoint=False, dtype=ftype)))\n"
  },
  {
    "id" : "154fce4f-636b-4d09-8984-720d01a11534",
    "prId" : 12388,
    "prUrl" : "https://github.com/numpy/numpy/pull/12388#pullrequestreview-175037430",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d696a004-6930-4e98-9f45-766285ceda12",
        "parentId" : null,
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "Apparently, the interface is now better, since `shape=()` works at least on my python installation.",
        "createdAt" : "2018-11-14T19:26:47Z",
        "updatedAt" : "2018-12-06T18:10:04Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      }
    ],
    "commit" : "abf62624f7e2ea41029c0dbaeef9c2851429a07a",
    "line" : 98,
    "diffHunk" : "@@ -1,1 +329,333 @@            @property\n            def __array_interface__(self):\n                return {'shape': (), 'typestr': '<i4', 'data': self._data,\n                        'version': 3}\n"
  },
  {
    "id" : "ce30363a-a0af-47c5-a79b-71cd5696e1db",
    "prId" : 13092,
    "prUrl" : "https://github.com/numpy/numpy/pull/13092#pullrequestreview-210479724",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f2e2a2e6-8b1c-4034-99d8-c97e2509edfc",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Might check that the result is an object array.",
        "createdAt" : "2019-03-05T00:51:19Z",
        "updatedAt" : "2019-03-05T00:51:19Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "03f4d1da-6a86-4ff0-871b-533d1bc549ef",
        "parentId" : "f2e2a2e6-8b1c-4034-99d8-c97e2509edfc",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Or should it be?",
        "createdAt" : "2019-03-05T00:51:47Z",
        "updatedAt" : "2019-03-05T00:51:48Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "74cfc1b4-c6f1-4d13-aa4e-ee3552b1be77",
        "parentId" : "f2e2a2e6-8b1c-4034-99d8-c97e2509edfc",
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "I had that test first, but it failed...  And It should, as the `start = asanyarray(start) * 1.0` turns it into a regular float. And for floats, one would expect an array.\r\n\r\nNote that I'm not sure this is necessarily the best behaviour, since it means that for very large ints, as in the original issue (#13089), we'll get back floats that are identical. But I don't know how to solve those anyway, since they cannot hold fractions. In the end, I think this is not numpy's problem... But we can at least avoid raising unrelated error on object input... ",
        "createdAt" : "2019-03-05T02:19:36Z",
        "updatedAt" : "2019-03-05T02:19:36Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      },
      {
        "id" : "9a1bd0d0-057d-466e-bf02-8996383662f6",
        "parentId" : "f2e2a2e6-8b1c-4034-99d8-c97e2509edfc",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "OK, I hadn't checked, but was thinking of object arrays of high precision floats, mpmath or some such. Could be made to work, but not worth the trouble, those who need it can roll their own.",
        "createdAt" : "2019-03-05T03:29:23Z",
        "updatedAt" : "2019-03-05T03:29:23Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "d60b5846-79f8-4a76-a6f0-e15fe0e65e6b",
        "parentId" : "f2e2a2e6-8b1c-4034-99d8-c97e2509edfc",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Precision could be a problem even if the floats don't repeat because float precision decreases with amplitude. I remember having that problem with plot axis in single precision wavenumbers :) Maybe worth a note in the documentation at some point.",
        "createdAt" : "2019-03-05T03:36:12Z",
        "updatedAt" : "2019-03-05T03:36:13Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "b3fdef08b5c586fff50fdabb0967e53ccaaab3c4",
    "line" : 9,
    "diffHunk" : "@@ -1,1 +368,372 @@        stop = array(2, dtype='O')\n        y = linspace(start, stop, 3)\n        assert_array_equal(y, array([1., 1.5, 2.]))"
  },
  {
    "id" : "b97c9c61-d91d-44d8-a6a3-d933ada3d252",
    "prId" : 16411,
    "prUrl" : "https://github.com/numpy/numpy/pull/16411#pullrequestreview-423358487",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5ea8627a-0e84-4a3b-ad18-3f510569a42e",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Could do\r\n```suggestion\r\n    @pytest.mark.parametrize('start_sign', [1, -1])\r\n    @pytest.mark.parametrize('stop_sign', [1, -1])\r\n    @pytest.mark.parametrize('num', [1, 3])\r\n    def test_boundaries_match_start_and_stop_exactly(self, start_sign, stop_sign, num):\r\n```\r\nand adjust the test below accordingly",
        "createdAt" : "2020-05-28T15:52:38Z",
        "updatedAt" : "2020-06-04T10:22:25Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "6887dc85-bd4e-4a6b-91fa-3d437a2e3af4",
        "parentId" : "5ea8627a-0e84-4a3b-ad18-3f510569a42e",
        "authorId" : "e48d9695-21e5-4a2d-96a8-f1a1d677df7f",
        "body" : "Note sure that improves readability...?\r\n\r\n(Let's hope quay.io comes back online anytime soon.)",
        "createdAt" : "2020-05-28T15:58:54Z",
        "updatedAt" : "2020-06-04T10:22:25Z",
        "lastEditedBy" : "e48d9695-21e5-4a2d-96a8-f1a1d677df7f",
        "tags" : [
        ]
      },
      {
        "id" : "6d48598a-0249-4b9d-ae87-b2139fc455e3",
        "parentId" : "5ea8627a-0e84-4a3b-ad18-3f510569a42e",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Ah, this actually catches an additional bug - `np.geomspace(-3, 3, num=3)` should give `[-3, nan, 3]`, not `[nan, nan, 3]`",
        "createdAt" : "2020-05-28T16:01:23Z",
        "updatedAt" : "2020-06-04T10:22:25Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "93fa1c57-68fc-43c5-9bcc-8f49aa2785f5",
        "parentId" : "5ea8627a-0e84-4a3b-ad18-3f510569a42e",
        "authorId" : "e48d9695-21e5-4a2d-96a8-f1a1d677df7f",
        "body" : "True, good catch - shall I amend the unit tests accordingly?",
        "createdAt" : "2020-05-28T16:04:47Z",
        "updatedAt" : "2020-06-04T10:22:25Z",
        "lastEditedBy" : "e48d9695-21e5-4a2d-96a8-f1a1d677df7f",
        "tags" : [
        ]
      },
      {
        "id" : "f7f055f7-6f06-44e0-acb7-189d6a084a7f",
        "parentId" : "5ea8627a-0e84-4a3b-ad18-3f510569a42e",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Yes please!",
        "createdAt" : "2020-05-28T16:52:52Z",
        "updatedAt" : "2020-06-04T10:22:25Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "254f365e-fadf-4a6e-9603-18a08043a892",
        "parentId" : "5ea8627a-0e84-4a3b-ad18-3f510569a42e",
        "authorId" : "e48d9695-21e5-4a2d-96a8-f1a1d677df7f",
        "body" : "Done, please review.",
        "createdAt" : "2020-06-02T06:19:40Z",
        "updatedAt" : "2020-06-04T10:22:25Z",
        "lastEditedBy" : "e48d9695-21e5-4a2d-96a8-f1a1d677df7f",
        "tags" : [
        ]
      },
      {
        "id" : "bc81b53a-7064-431f-8ba4-41ca682bde97",
        "parentId" : "5ea8627a-0e84-4a3b-ad18-3f510569a42e",
        "authorId" : "e48d9695-21e5-4a2d-96a8-f1a1d677df7f",
        "body" : "That additional test leads to a `RuntimeWarning` because it computes `log10(0.0)` which in turn seems to make the test fail. Why does a Warning lead to a test failure please? How can I avoid this?",
        "createdAt" : "2020-06-02T06:49:30Z",
        "updatedAt" : "2020-06-04T10:22:25Z",
        "lastEditedBy" : "e48d9695-21e5-4a2d-96a8-f1a1d677df7f",
        "tags" : [
        ]
      },
      {
        "id" : "dfdfb3db-98d1-402f-8da4-7816333b5800",
        "parentId" : "5ea8627a-0e84-4a3b-ad18-3f510569a42e",
        "authorId" : "fe664d20-2239-4242-9bd1-2c7a4f010863",
        "body" : "you can use something like `with np.errstate(divide=\"raise\"):` and check that the floating point error is raised. if you want to ignore you can do something like `with np.errstate(divide=\"ignore\"):`",
        "createdAt" : "2020-06-02T16:32:26Z",
        "updatedAt" : "2020-06-04T10:22:25Z",
        "lastEditedBy" : "fe664d20-2239-4242-9bd1-2c7a4f010863",
        "tags" : [
        ]
      },
      {
        "id" : "b749024a-bc7d-4ad4-ac2e-f028941eb539",
        "parentId" : "5ea8627a-0e84-4a3b-ad18-3f510569a42e",
        "authorId" : "e48d9695-21e5-4a2d-96a8-f1a1d677df7f",
        "body" : "done, thanks",
        "createdAt" : "2020-06-03T09:04:10Z",
        "updatedAt" : "2020-06-04T10:22:25Z",
        "lastEditedBy" : "e48d9695-21e5-4a2d-96a8-f1a1d677df7f",
        "tags" : [
        ]
      }
    ],
    "commit" : "8cdbe30377c806cef30b0c5c9d54370e8deed4b7",
    "line" : 12,
    "diffHunk" : "@@ -1,1 +114,118 @@        assert_array_equal(y.imag, 0)\n\n    def test_boundaries_match_start_and_stop_exactly(self):\n        # make sure that the boundaries of the returned array exactly\n        # equal 'start' and 'stop' - this isn't obvious because"
  },
  {
    "id" : "f2a0cb2b-72be-471d-b13a-0d6d452b4182",
    "prId" : 16411,
    "prUrl" : "https://github.com/numpy/numpy/pull/16411#pullrequestreview-423389297",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "098b4fc2-d1b0-4586-bfd4-8e1b7d5a812c",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "A test without the endpoint would be good too",
        "createdAt" : "2020-06-03T09:38:01Z",
        "updatedAt" : "2020-06-04T10:22:25Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "58c84ada-8162-4fbf-afcb-e8ffe39b56c4",
        "parentId" : "098b4fc2-d1b0-4586-bfd4-8e1b7d5a812c",
        "authorId" : "e48d9695-21e5-4a2d-96a8-f1a1d677df7f",
        "body" : "good idea - done",
        "createdAt" : "2020-06-03T09:43:25Z",
        "updatedAt" : "2020-06-04T10:22:25Z",
        "lastEditedBy" : "e48d9695-21e5-4a2d-96a8-f1a1d677df7f",
        "tags" : [
        ]
      }
    ],
    "commit" : "8cdbe30377c806cef30b0c5c9d54370e8deed4b7",
    "line" : 34,
    "diffHunk" : "@@ -1,1 +136,140 @@    def test_nan_interior(self):\n        with errstate(invalid='ignore'):\n            y = geomspace(-3, 3, num=4)\n\n        assert_equal(y[0], -3.0)"
  }
]
[
  {
    "id" : "4b6e37f9-ac21-44ff-88f9-b2634d43c50f",
    "prId" : 9063,
    "prUrl" : "https://github.com/numpy/numpy/pull/9063#pullrequestreview-36669605",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "dc831583-4f5e-4735-9655-91e12663e00d",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Perhaps before this loop, or even at the file level:\r\n```\r\nsigns = {\r\n    d: (+1,) if dt in np.typecodes['UnsignedInteger'] else (+1, -1)\r\n    for d in dt\r\n}\r\n```\r\n\r\nAnd then `itertools.product(signs[dt1], signs[dt2])` below, which removes the `continue`s",
        "createdAt" : "2017-05-06T23:10:52Z",
        "updatedAt" : "2017-05-08T00:04:02Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "07397d81-e1e1-4de5-9427-ee6de85d6054",
        "parentId" : "dc831583-4f5e-4735-9655-91e12663e00d",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Actually, better would be, in the class level:\r\n\r\n```\r\ndef _signs(self, dt):\r\n    if dt in np.typecodes['UnsignedInteger']:\r\n        return (+1,)\r\n    else:\r\n        return (+1, -1)\r\n```\r\n\r\nConstructing that dict is kinda clunky, and you'd end up repeating it over multiple tests",
        "createdAt" : "2017-05-06T23:21:38Z",
        "updatedAt" : "2017-05-08T00:04:02Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "f9b96b95-13a3-4834-ad81-b04662054903",
        "parentId" : "dc831583-4f5e-4735-9655-91e12663e00d",
        "authorId" : "576cec6e-8071-43f8-bce9-351a2589f050",
        "body" : "done",
        "createdAt" : "2017-05-07T18:00:41Z",
        "updatedAt" : "2017-05-08T00:04:02Z",
        "lastEditedBy" : "576cec6e-8071-43f8-bce9-351a2589f050",
        "tags" : [
        ]
      }
    ],
    "commit" : "8fbf75e499196c05da46302f035909897c9ec272",
    "line" : 39,
    "diffHunk" : "@@ -1,1 +205,209 @@    def test_modulus_basic(self):\n        dt = np.typecodes['AllInteger'] + np.typecodes['Float']\n        for op in [floordiv_and_mod, divmod]:\n            for dt1, dt2 in itertools.product(dt, dt):\n                for sg1, sg2 in itertools.product(_signs(dt1), _signs(dt2)):"
  },
  {
    "id" : "8f1a0df9-b31f-4a31-bcad-9dd03f5c16fc",
    "prId" : 9971,
    "prUrl" : "https://github.com/numpy/numpy/pull/9971#pullrequestreview-90295575",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8226b337-57f3-418d-8434-761f38c8c50e",
        "parentId" : null,
        "authorId" : "a4f03a99-2e43-482b-a9bc-5a9e359abb03",
        "body" : "This test fails on ppc64. \r\n\r\nI think I'm going to add `@dec.skipif(platform.machine().startswith(\"ppc64\"))` here.",
        "createdAt" : "2018-01-20T05:51:46Z",
        "updatedAt" : "2018-01-20T05:51:46Z",
        "lastEditedBy" : "a4f03a99-2e43-482b-a9bc-5a9e359abb03",
        "tags" : [
        ]
      }
    ],
    "commit" : "e0fb73953a4ed36503e72ec5764be5443688ab24",
    "line" : 36,
    "diffHunk" : "@@ -1,1 +421,425 @@            assert_equal(len(sup.log), 1)\n\n    @dec.skipif(np.finfo(np.double) == np.finfo(np.longdouble))\n    def test_int_from_huge_longdouble(self):\n        # produce a longdouble that would overflow a double"
  },
  {
    "id" : "3d87f0ca-c163-477c-9005-3838641b39c1",
    "prId" : 9973,
    "prUrl" : "https://github.com/numpy/numpy/pull/9973#pullrequestreview-74545238",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1241b544-560b-4075-b14f-45d9cf06aa0b",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Not quite PEP8, but looks better. Lots of these around, so not going to worry about it.",
        "createdAt" : "2017-11-06T20:08:49Z",
        "updatedAt" : "2017-11-06T20:08:50Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "7ee292f7ebd97c6b9a589382c0f92a2579e30f01",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +410,414 @@\n    @dec.knownfailureif(not IS_PYPY,\n        \"__int__ is not the same as int in cpython (gh-9972)\")\n    def test_clongdouble___int__(self):\n        x = np.longdouble(np.inf)"
  },
  {
    "id" : "98a5d23c-5253-4849-a2ed-8949653c3ad9",
    "prId" : 14718,
    "prUrl" : "https://github.com/numpy/numpy/pull/14718#pullrequestreview-307307205",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "594110a4-8cb0-4d3d-9aa4-73c50ed036a6",
        "parentId" : null,
        "authorId" : "73d6f7d8-2c7d-4a48-8754-5ce4a97a850f",
        "body" : "Any reason you changed the original regression test, based on the case originally reported in the issue? It looks like it should have no effect, but then why bother to change it from the original report /my PR?\r\n\r\nPerhaps a larger array is more likely to detect problems, I suppose.",
        "createdAt" : "2019-10-25T02:56:25Z",
        "updatedAt" : "2019-10-25T03:22:52Z",
        "lastEditedBy" : "73d6f7d8-2c7d-4a48-8754-5ce4a97a850f",
        "tags" : [
        ]
      },
      {
        "id" : "682ef450-d475-4573-a802-cf96a7274afe",
        "parentId" : "594110a4-8cb0-4d3d-9aa4-73c50ed036a6",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "I think I wanted to avoid any weird special cases caused by scalar casting rules. I suppose I should have tested both.",
        "createdAt" : "2019-10-25T16:08:29Z",
        "updatedAt" : "2019-10-25T16:08:29Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "ac757b50edbbdb49cf0c1804d7f6273e16d269a4",
    "line" : 17,
    "diffHunk" : "@@ -1,1 +298,302 @@        # this only applies to in-place floordiv //=, because the output type\n        # promotes to float which does not fit\n        a = np.array([1, 2], np.int64)\n        b = np.array([1, 2], np.uint64)\n        pattern = 'could not be coerced to provided output parameter'"
  },
  {
    "id" : "1203c664-32b0-43b0-b109-77434068ab23",
    "prId" : 18330,
    "prUrl" : "https://github.com/numpy/numpy/pull/18330#pullrequestreview-711164662",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "aebd0f55-755d-49c9-9f14-32cbaef824fe",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "A cleaner way to do this is to raise skip inside the function. Something like\r\n```\r\ndef test_builtin_abs(self, dtype):\r\n    if dtype == np.clongdouble and sys.platform == \"cygwin\":\r\n        pytest.skip(\"absl is computed in double precision on cygwin\")\r\n    ...\r\n```\r\nYou could also use `pytest.xfail` instead of `pytest.skip`.",
        "createdAt" : "2021-07-20T21:51:57Z",
        "updatedAt" : "2021-07-20T21:52:57Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "d33518fc-770c-43c4-89a9-53cad9daada7",
        "parentId" : "aebd0f55-755d-49c9-9f14-32cbaef824fe",
        "authorId" : "d9bab799-97ab-4654-9b32-0ac2d7ac9dec",
        "body" : "Done, here and for the next test.",
        "createdAt" : "2021-07-21T00:26:55Z",
        "updatedAt" : "2021-07-21T00:26:55Z",
        "lastEditedBy" : "d9bab799-97ab-4654-9b32-0ac2d7ac9dec",
        "tags" : [
        ]
      }
    ],
    "commit" : "52fa14eeebc6ad917eaf87e4e5185ed7a29bcfc1",
    "line" : 3,
    "diffHunk" : "@@ -1,1 +680,684 @@\n    @pytest.mark.parametrize(\"dtype\", floating_types + complex_floating_types)\n    def test_builtin_abs(self, dtype):\n        if sys.platform == \"cygwin\" and dtype == np.clongdouble:\n            pytest.xfail("
  }
]
[
  {
    "id" : "73f58a05-6be2-44a9-9a9e-c4eb6947536e",
    "prId" : 9998,
    "prUrl" : "https://github.com/numpy/numpy/pull/9998#pullrequestreview-114183589",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e9e1650a-6ce7-4693-b186-8d962cbdcb0c",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "nit: PEP8 wants two spaces before the #. Also, `del i` might be clearer.",
        "createdAt" : "2018-04-21T21:09:57Z",
        "updatedAt" : "2018-04-21T21:09:57Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "4a61fa92-dcb3-42c7-9e6d-5a3289498cfc",
        "parentId" : "e9e1650a-6ce7-4693-b186-8d962cbdcb0c",
        "authorId" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "body" : "fixed (in doc-nditer PR)",
        "createdAt" : "2018-04-21T21:24:20Z",
        "updatedAt" : "2018-04-21T21:24:20Z",
        "lastEditedBy" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "tags" : [
        ]
      }
    ],
    "commit" : "fa9a74165479142e2c1671f871fe7c860146cd52",
    "line" : 76,
    "diffHunk" : "@@ -1,1 +812,816 @@        i.operands[0][:] = 2\n    assert_equal(au, [2]*6)\n    i = None # should not raise a DeprecationWarning\n    # Byte order change by requesting NBO\n    a = np.arange(6, dtype='f4')"
  },
  {
    "id" : "238ea663-265c-4c13-8532-34f2bfede93c",
    "prId" : 10949,
    "prUrl" : "https://github.com/numpy/numpy/pull/10949#pullrequestreview-114185342",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "14520ac6-a22c-4019-9095-e5e381e2ef5e",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "What should happen if the outer `with` continues to use it?",
        "createdAt" : "2018-04-21T22:49:35Z",
        "updatedAt" : "2018-04-25T00:18:38Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "b1d09cdf-2f12-4773-89d6-50200952a16a",
        "parentId" : "14520ac6-a22c-4019-9095-e5e381e2ef5e",
        "authorId" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "body" : "it will error out that it is closed",
        "createdAt" : "2018-04-21T22:50:30Z",
        "updatedAt" : "2018-04-25T00:18:38Z",
        "lastEditedBy" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "tags" : [
        ]
      },
      {
        "id" : "997afd0f-55ad-4c16-9f27-f455baa5ca71",
        "parentId" : "14520ac6-a22c-4019-9095-e5e381e2ef5e",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "That seems to be consistent with `file` and `contextlib.closing`. Can you test that too then?",
        "createdAt" : "2018-04-21T22:58:33Z",
        "updatedAt" : "2018-04-25T00:18:38Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "fc137a7a-63af-43bc-923f-f4f624dbec44",
        "parentId" : "14520ac6-a22c-4019-9095-e5e381e2ef5e",
        "authorId" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "body" : "added",
        "createdAt" : "2018-04-21T23:00:39Z",
        "updatedAt" : "2018-04-25T00:18:38Z",
        "lastEditedBy" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "tags" : [
        ]
      }
    ],
    "commit" : "246ad1dd3006ed4230a5c457838450f96df755e7",
    "line" : 18,
    "diffHunk" : "@@ -1,1 +2843,2847 @@        with it:\n            for x in it:\n                x[...] = 123\n\n    it = nditer(au, [],"
  },
  {
    "id" : "ea01eb6f-a4fc-4e94-a9bf-309a2d6dc834",
    "prId" : 10951,
    "prUrl" : "https://github.com/numpy/numpy/pull/10951#pullrequestreview-114192124",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1805f827-55ee-4998-b770-e653b4c8c2ed",
        "parentId" : null,
        "authorId" : "a4f03a99-2e43-482b-a9bc-5a9e359abb03",
        "body" : "amanger -> manager",
        "createdAt" : "2018-04-22T01:13:45Z",
        "updatedAt" : "2018-04-22T19:35:53Z",
        "lastEditedBy" : "a4f03a99-2e43-482b-a9bc-5a9e359abb03",
        "tags" : [
        ]
      },
      {
        "id" : "74a0f842-d586-4cb7-8020-11eaca01442d",
        "parentId" : "1805f827-55ee-4998-b770-e653b4c8c2ed",
        "authorId" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "body" : "fixed",
        "createdAt" : "2018-04-22T07:24:50Z",
        "updatedAt" : "2018-04-22T19:35:53Z",
        "lastEditedBy" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "tags" : [
        ]
      }
    ],
    "commit" : "ac7d543f52ab50c878b64a13662dce198c6fcb64",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +2849,2853 @@\ndef test_close_equivalent():\n    ''' using a context amanger and using nditer.close are equivalent\n    '''\n    def add_close(x, y, out=None):"
  },
  {
    "id" : "db6de631-7cd8-471b-85ff-01407dff2c22",
    "prId" : 10951,
    "prUrl" : "https://github.com/numpy/numpy/pull/10951#pullrequestreview-114210042",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5f881a22-45b6-4129-82ce-0d5a139304b6",
        "parentId" : null,
        "authorId" : "a4f03a99-2e43-482b-a9bc-5a9e359abb03",
        "body" : "Should we maybe allow access to the operands even after `.close()`? \r\n\r\nMaybe I'm forgetting how this all works, but I think the operands are still safe to use after closing. It is the temp buffers which are unsafe.\r\n\r\nIn fact, isn't it the case that the output operand should only be used by other code *after* close is called?",
        "createdAt" : "2018-04-22T01:20:00Z",
        "updatedAt" : "2018-04-22T19:35:53Z",
        "lastEditedBy" : "a4f03a99-2e43-482b-a9bc-5a9e359abb03",
        "tags" : [
        ]
      },
      {
        "id" : "e6334c07-ea34-4a4d-a7e6-5ec4d546f98e",
        "parentId" : "5f881a22-45b6-4129-82ce-0d5a139304b6",
        "authorId" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "body" : "I would prefer to make explicit that `it.operands` can no longer be trusted, it may retrieve stale data from a closed iterator. I will add documentation to that effect, but am open to other opinons",
        "createdAt" : "2018-04-22T07:24:40Z",
        "updatedAt" : "2018-04-22T19:35:53Z",
        "lastEditedBy" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "tags" : [
        ]
      },
      {
        "id" : "f125bbe5-3f17-43a3-8f6a-ddc31fa346e2",
        "parentId" : "5f881a22-45b6-4129-82ce-0d5a139304b6",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "I'm with @ahaldane on this one. Doesn't `operands` point to the array to write back to, in which case it's not even valid until after the `it.close()` is called?",
        "createdAt" : "2018-04-22T09:24:08Z",
        "updatedAt" : "2018-04-22T19:35:53Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "eac3209b-abec-4ca2-a211-359930aaa56f",
        "parentId" : "5f881a22-45b6-4129-82ce-0d5a139304b6",
        "authorId" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "body" : "I tried to document the behavour wrt writeback semantics [here](https://github.com/numpy/numpy/blob/master/numpy/add_newdocs.py#L401)\r\nIf writeback semantics were used and have been resolved, the operand's data is no longer related to the input array's data. If writeback semantics were not used, the operand shares data with the input array. So we could create a situation where code is fragile: it works without writeback semantics but fails when they are used.\r\n\r\nNote this was true even before PR #9998. The previous trigger to resolve was a call to `NpyIter_Deallocate`, which was done by `del it` or `it = None`. Since `it` was no longer valid, new access to the operands was prevented.\r\n\r\nWe started discussing this in the nditer.close pull request in [Dec](https://github.com/numpy/numpy/pull/10184#pullrequestreview-83745185), but I guess it never really got resolved.\r\n\r\nI am open to suggestions. The motivation/root-cause of this whole mess is that the operand can have a different, non-compatible dtype from the array. At some point that incompatibility needs to be resolved, and from that point forward the operand is unusable or we need some kind of flag to track between the (now writeable) data in the array and the still-valid(?), writeable operand.",
        "createdAt" : "2018-04-22T14:49:43Z",
        "updatedAt" : "2018-04-22T19:35:53Z",
        "lastEditedBy" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "tags" : [
        ]
      },
      {
        "id" : "e7a5b9ed-18bf-49fc-90ee-1c5aa05a0a34",
        "parentId" : "5f881a22-45b6-4129-82ce-0d5a139304b6",
        "authorId" : "a4f03a99-2e43-482b-a9bc-5a9e359abb03",
        "body" : "OK, you're right, I was misunderstanding it. The `it.operands` are indeed the temporary buffers, and not the original output array, and so should not be accessed after closing. Eg,\r\n```python\r\n>>> a = np.arange(24, dtype='f8')\r\n>>> aiter = np.nditer(a, [], [['readwrite', 'updateifcopy']],\r\n...                  casting='same_kind',op_dtypes=[np.dtype('f4')])\r\n>>> with aiter as it:\r\n...     x = it.operands[0]\r\n>>> x[0] = 10\r\n>>> a[0]\r\n0.0\r\n```\r\n\r\nBut in that case all the examples above which do things like `return it.operands[1]` don't make sense, since they appear to be returning the temp buffer rather than the original array. We need to provide a way for the user to access the allocated output arrays even after the iterator is closed.\r\n\r\nPerhaps `it.operators` should point to the original array instead of the temp buffer? Or (more likely) maybe we need to add a new attribute to the nditer object which points to the original arrays.\r\n",
        "createdAt" : "2018-04-22T17:11:56Z",
        "updatedAt" : "2018-04-22T19:35:53Z",
        "lastEditedBy" : "a4f03a99-2e43-482b-a9bc-5a9e359abb03",
        "tags" : [
        ]
      },
      {
        "id" : "6edfa639-bd36-4a5b-96db-0c9266e4f50b",
        "parentId" : "5f881a22-45b6-4129-82ce-0d5a139304b6",
        "authorId" : "a4f03a99-2e43-482b-a9bc-5a9e359abb03",
        "body" : "The nditer docstring says:\r\n```\r\noperands | (tuple of operand(s)) The array(s) to be iterated over.\r\n```\r\nwhich sounds to me like it is describing the \"original\" arrays, not the buffer copies. All of the code which does `return it.operands[1]` seems to implicitly assume `it.operands` refers to the original arrays.  ... except we just found this isn't true.\r\n\r\nThe one exception is in the reduction examples, which start by doing `it.operands[1][..] = 0` to initialize the reduction, which assumes that `it.operands` refers to the buffers. However, there seems to be a whole complicated discussion of a special flag `delay_bufalloc` and a special method `it.reset()` which, looking at it in retrospect, seem to me to be hacks only necessary because of the lack of distinction between the \"original\" arrays and the buffer arrays which we have discovered above. \r\n\r\nMaybe now that we have a context manager, we can deprecate all of that and add some better behavior? That is, you would do `it.operands[1][..] = 0` before the context is entered, (so context entrance replaces `it.reset`)?\r\n\r\n Maybe that's all going too far, though.\r\n\r\n",
        "createdAt" : "2018-04-22T17:40:44Z",
        "updatedAt" : "2018-04-22T19:35:53Z",
        "lastEditedBy" : "a4f03a99-2e43-482b-a9bc-5a9e359abb03",
        "tags" : [
        ]
      },
      {
        "id" : "4e6c9243-1c22-4247-91c0-902ebecc3b6a",
        "parentId" : "5f881a22-45b6-4129-82ce-0d5a139304b6",
        "authorId" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "body" : "maybe the examples should do\r\n```\r\n-     return it.operands[1]\r\n+    if out:\r\n+        return out\r\n+    else:\r\n+        return it.operand[1]\r\n``` \r\nAs for `delay_bufalloc` it relates to the `buffered` flag, which [allocates memory](http://www.numpy.org/devdocs/reference/arrays.nditer.html#buffering-the-array-elements) independent of the `operands`.",
        "createdAt" : "2018-04-22T18:18:06Z",
        "updatedAt" : "2018-04-22T19:35:53Z",
        "lastEditedBy" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "tags" : [
        ]
      }
    ],
    "commit" : "ac7d543f52ab50c878b64a13662dce198c6fcb64",
    "line" : 30,
    "diffHunk" : "@@ -1,1 +2879,2883 @@    it.close()\n    assert_raises(StopIteration, next, it)\n    assert_raises(ValueError, getattr, it, 'operands')\n\ndef test_warn_noclose():"
  },
  {
    "id" : "bbdc4ddd-a5ee-4751-9a46-46a24f1be557",
    "prId" : 15162,
    "prUrl" : "https://github.com/numpy/numpy/pull/15162#pullrequestreview-421407703",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a6073ac3-f77d-45cc-a33c-e00e834bb528",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "What values here would not be an error?",
        "createdAt" : "2020-05-30T09:14:26Z",
        "updatedAt" : "2020-05-30T19:11:46Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "c52abef5-77e1-4dcc-8fdb-920d41b046b7",
        "parentId" : "a6073ac3-f77d-45cc-a33c-e00e834bb528",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "If the axes were 0 and 1 it would work. Hmm, you have to specify all the axes of the array here. I guess that is only true for allocated arrays probably.",
        "createdAt" : "2020-05-30T14:07:13Z",
        "updatedAt" : "2020-05-30T19:11:46Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      }
    ],
    "commit" : "8da4fba24c193807555dfcbc0e67834cae9185ea",
    "line" : 10,
    "diffHunk" : "@@ -1,1 +1527,1531 @@                        [['readonly'], ['readwrite', 'allocate']],\n                        op_dtypes=[None, np.dtype('f4')],\n                        op_axes=[None, [0, np.newaxis, 2]])\n\ndef test_iter_remove_axis():"
  },
  {
    "id" : "300ac0e9-c326-4148-96b0-8c1417be419c",
    "prId" : 18289,
    "prUrl" : "https://github.com/numpy/numpy/pull/18289#pullrequestreview-582880731",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "60ad4040-5b38-4da9-86f9-645ca101f666",
        "parentId" : null,
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "I dunno,`capsys` (https://docs.pytest.org/en/stable/capture.html#accessing-captured-output-from-a-test-function) didn't work for me here, so rather than ditch this path completely went the ugly subprocess way...",
        "createdAt" : "2021-02-03T23:00:35Z",
        "updatedAt" : "2021-02-04T02:05:18Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      }
    ],
    "commit" : "33953d21e735f9e31558a7c848970524ea9e2137",
    "line" : 68,
    "diffHunk" : "@@ -1,1 +2009,2013 @@        \"\"\")\n    res = subprocess.check_output([sys.executable, \"-c\", code],\n                                  stderr=subprocess.STDOUT, text=True)\n    assert \"ValueError\" in res\n"
  }
]
[
  {
    "id" : "01d6b02e-a609-4eb2-a4db-5087859904ee",
    "prId" : 6630,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "69d6e154-8431-4480-9692-5b4bf0616dc6",
        "parentId" : null,
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "The tests could also check that the arrays share memory, but not a big deal, it is obviously enough they should.\n",
        "createdAt" : "2016-01-02T18:25:34Z",
        "updatedAt" : "2016-01-09T23:56:28Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      }
    ],
    "commit" : "8ffde7f488eb583ed2a200702e85a6518c4f94ec",
    "line" : 22,
    "diffHunk" : "@@ -1,1 +2039,2043 @@                                 (-1, (5, 6, 7))]:\n            actual = np.moveaxis(x, source, -1).shape\n            assert_(actual, expected)\n\n    def test_move_new_position(self):"
  },
  {
    "id" : "2bea1edc-120e-4c9e-92f6-121fc7e16efb",
    "prId" : 8843,
    "prUrl" : "https://github.com/numpy/numpy/pull/8843#pullrequestreview-29067267",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "dac93324-728f-4386-93af-ddb614c2ab84",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Error message comparison:\r\n\r\n```\r\nValueError: invalid axis for this array in `destination` argument\r\nAxisError: destination: axis 5 is out of bounds for array of dimension 3\r\n```\r\n",
        "createdAt" : "2017-03-26T10:50:39Z",
        "updatedAt" : "2017-03-28T21:23:31Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "17466ad1839718c091c629bb647e881b7922a148",
    "line" : 11,
    "diffHunk" : "@@ -1,1 +2430,2434 @@        assert_raises_regex(np.AxisError, 'source.*out of bounds',\n                            np.moveaxis, x, -4, 0)\n        assert_raises_regex(np.AxisError, 'destination.*out of bounds',\n                            np.moveaxis, x, 0, 5)\n        assert_raises_regex(ValueError, 'repeated axis in `source`',"
  },
  {
    "id" : "0d528590-0f5c-4cc8-aa35-3872bf0b702e",
    "prId" : 9300,
    "prUrl" : "https://github.com/numpy/numpy/pull/9300#pullrequestreview-55975505",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "05ace6be-83bf-4f0d-bca0-9f4b8e1734a5",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Another useful test might be\r\n```python\r\nclass BoolErrors:\r\n    def __bool__(self):\r\n        raise ValueError(\"Not allowed\")\r\n\r\nnp.array([BoolErrors(), BoolErrors()]).nonzero()\r\n```\r\nwhich is similar to the test that came up for sorting objects with erroring comparators (https://github.com/numpy/numpy/pull/9412/files#diff-bc1e8d40b8b7758facc5e143be016f99R1485)",
        "createdAt" : "2017-08-13T20:45:27Z",
        "updatedAt" : "2017-09-14T04:00:49Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "8d4942bd6a682d0c6a86c503c6af0c08a5333adb",
    "line" : 8,
    "diffHunk" : "@@ -1,1 +1125,1129 @@        a = np.array([np.array([1, 2]), 3])\n        assert_raises(ValueError, np.nonzero, a)\n\n        class BoolErrors:\n            def __bool__(self):"
  },
  {
    "id" : "89d8ef65-29cc-43f9-9bfa-b6941ea089ad",
    "prId" : 11615,
    "prUrl" : "https://github.com/numpy/numpy/pull/11615#pullrequestreview-140733421",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4cedd2b2-052b-476a-88b5-36eddaaa9466",
        "parentId" : null,
        "authorId" : "73d6f7d8-2c7d-4a48-8754-5ce4a97a850f",
        "body" : "So basically `out` is Fortran contiguous and `clip` now restores C contiguity in `out` so the results don't get assigned memory locations down the columns?",
        "createdAt" : "2018-07-26T04:19:09Z",
        "updatedAt" : "2018-07-26T22:11:40Z",
        "lastEditedBy" : "73d6f7d8-2c7d-4a48-8754-5ce4a97a850f",
        "tags" : [
        ]
      },
      {
        "id" : "d7b2be4d-fc77-4034-b8fd-fe60d7b31fa1",
        "parentId" : "4cedd2b2-052b-476a-88b5-36eddaaa9466",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Yeah, clip writes to a temporary C-order array. It could also decide to use the \"slow\" path, which I have no clue if it is much slower when this happens already.",
        "createdAt" : "2018-07-26T13:42:54Z",
        "updatedAt" : "2018-07-26T22:11:40Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      }
    ],
    "commit" : "537135661dd2b589bca1969f1cef24525b4a95d0",
    "line" : 25,
    "diffHunk" : "@@ -1,1 +1726,1730 @@        # Test that the out argument works when tranposed\n        a = np.arange(16).reshape(4, 4)\n        out = np.empty_like(a).T\n        a.clip(4, 10, out=out)\n        expected = self.clip(a, 4, 10)"
  },
  {
    "id" : "c3f13d33-75fc-49f0-9d8c-2575e3396e49",
    "prId" : 11615,
    "prUrl" : "https://github.com/numpy/numpy/pull/11615#pullrequestreview-140733745",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a584a24b-3c97-4775-b8da-39c54d525f72",
        "parentId" : null,
        "authorId" : "73d6f7d8-2c7d-4a48-8754-5ce4a97a850f",
        "body" : "Was there a bug in the test here before then?",
        "createdAt" : "2018-07-26T04:20:11Z",
        "updatedAt" : "2018-07-26T22:11:40Z",
        "lastEditedBy" : "73d6f7d8-2c7d-4a48-8754-5ce4a97a850f",
        "tags" : [
        ]
      },
      {
        "id" : "a0a2591b-2f69-4261-b292-cb4c964d1cfa",
        "parentId" : "a584a24b-3c97-4775-b8da-39c54d525f72",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Yeah, fastclip modifies `a` in place, this `self.clip` is actually a manual clip in the test. Looks wrong to me, can put it into its own commit.",
        "createdAt" : "2018-07-26T13:43:35Z",
        "updatedAt" : "2018-07-26T22:11:40Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      }
    ],
    "commit" : "537135661dd2b589bca1969f1cef24525b4a95d0",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +1531,1535 @@        M = 0.6\n        self.fastclip(a, m, M, a)\n        self.clip(ac, m, M, ac)\n        assert_array_strict_equal(a, ac)\n"
  },
  {
    "id" : "485ef681-dde0-4498-bf94-ba0009aeda9f",
    "prId" : 12152,
    "prUrl" : "https://github.com/numpy/numpy/pull/12152#pullrequestreview-165966358",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "88acc1e8-74d9-4912-862a-a227c285a16b",
        "parentId" : null,
        "authorId" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "body" : "perhaps \"# empty axes defaults to (2,)\"",
        "createdAt" : "2018-10-15T06:16:58Z",
        "updatedAt" : "2019-02-24T09:34:22Z",
        "lastEditedBy" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "tags" : [
        ]
      },
      {
        "id" : "02335763-db68-4002-ab66-e296d97537ee",
        "parentId" : "88acc1e8-74d9-4912-862a-a227c285a16b",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "@mattip: What do you mean \"defaults to (2,)\"? Empty axis just means \"do not contract anything\", which is not a special case at all. It works for higher dimensions too:\r\n```\r\na = np.zeros((2, 3))\r\nb = np.zeros((4, 5))\r\nnp.tensordot(a, b, ([], [])).shape  # (2, 3, 4, 5)\r\n```",
        "createdAt" : "2018-10-18T07:59:17Z",
        "updatedAt" : "2019-02-24T09:34:22Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "3fba5ae7a657b006afb02620927e501eb8ef48de",
    "line" : 8,
    "diffHunk" : "@@ -1,1 +2753,2757 @@        # gh-12130\n        arr_0d = np.array(1)\n        ret = np.tensordot(arr_0d, arr_0d, ([], []))  # contracting no axes is well defined\n        assert_array_equal(ret, arr_0d)"
  },
  {
    "id" : "ca9f8330-1337-4b48-be07-3caa56fcfb90",
    "prId" : 12519,
    "prUrl" : "https://github.com/numpy/numpy/pull/12519#pullrequestreview-223127463",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0323a66a-bf33-40a8-9bba-1460b9c04354",
        "parentId" : null,
        "authorId" : "73d6f7d8-2c7d-4a48-8754-5ce4a97a850f",
        "body" : "need to decide if scalar `np.nan` should propagate so marking this test with xfail too for now; the function spec does propagate the `nan` here.\r\n\r\nHistorical behavior is yet another dimension I haven't fully explored, though the deprecation message implies propagation of nan has been the norm?",
        "createdAt" : "2019-03-12T19:19:00Z",
        "updatedAt" : "2019-05-15T17:09:02Z",
        "lastEditedBy" : "73d6f7d8-2c7d-4a48-8754-5ce4a97a850f",
        "tags" : [
        ]
      },
      {
        "id" : "aee6a65f-50a2-406d-80ed-e0856d7075e1",
        "parentId" : "0323a66a-bf33-40a8-9bba-1460b9c04354",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Historically Nan scalars propagate only in non-native memory orders, which I've deprecated",
        "createdAt" : "2019-03-12T19:51:04Z",
        "updatedAt" : "2019-05-15T17:09:02Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "7e44aa97-c224-4c2f-99ed-f7986b76d96f",
        "parentId" : "0323a66a-bf33-40a8-9bba-1460b9c04354",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "We talked about this briefly yesterday. And I think the consensus is, that whatever the current discussion/state is exactly, we should be be practical. Especially how incorrectly sorted min and max value for clipping behaves is OK to be undefined (or raise an error). And it is OK to risk breaking current code.\r\nWith respect to NaN, I think it does not matter much which way we go and we should just decide for one thing. Although, in the case of NaN, I guess it may make sense to do a deprecation for the scalar case.\r\nSo the gist is: Don't worry too much about some tiny inconsistencies in corner cases of corner cases, it is fine to keep some things undefined (we could even make it well defined later if necessary).",
        "createdAt" : "2019-03-14T14:50:34Z",
        "updatedAt" : "2019-05-15T17:09:02Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "b4c55276-1e59-4329-b424-609b97ddd0b5",
        "parentId" : "0323a66a-bf33-40a8-9bba-1460b9c04354",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "> Although, in the case of NaN, I guess it may make sense to do a deprecation for the scalar case.\r\n\r\nThis is what I've implemented, simply because we actually had tests requiring that behavior",
        "createdAt" : "2019-04-05T07:19:19Z",
        "updatedAt" : "2019-05-15T17:09:02Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "31f0bb1dc7611e5401a52103623d15ea4b3dd00f",
    "line" : 200,
    "diffHunk" : "@@ -1,1 +1877,1881 @@        assert_equal(actual, exp)\n\n    @pytest.mark.xfail(reason=\"no scalar nan propagation yet\")\n    @pytest.mark.parametrize(\"arr, amin, amax\", [\n        # problematic scalar nan case from hypothesis"
  }
]
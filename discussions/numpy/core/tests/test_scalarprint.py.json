[
  {
    "id" : "9c654140-f8f8-41ea-a92d-ab534ce55101",
    "prId" : 10444,
    "prUrl" : "https://github.com/numpy/numpy/pull/10444#pullrequestreview-126523399",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f3a669ac-d073-4027-a227-22d04d07bb2b",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Deliberately avoiding `assert_equal` because the message wouldn't be useful? Might be worth adding a comment about that here.",
        "createdAt" : "2018-05-18T07:56:49Z",
        "updatedAt" : "2018-06-06T19:15:57Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "c4a6a62c-4748-426f-a3bf-78fd087ae125",
        "parentId" : "f3a669ac-d073-4027-a227-22d04d07bb2b",
        "authorId" : "a4f03a99-2e43-482b-a9bc-5a9e359abb03",
        "body" : "It is because we don't have `assert_not_equal` available.\r\n\r\nIt is implemented in `np.ma.testutils`, but I don't want to import from the ma module.",
        "createdAt" : "2018-06-06T19:34:47Z",
        "updatedAt" : "2018-06-06T19:34:48Z",
        "lastEditedBy" : "a4f03a99-2e43-482b-a9bc-5a9e359abb03",
        "tags" : [
        ]
      }
    ],
    "commit" : "cdc6b68476fde6d7e5717b22972cb8147988ce71",
    "line" : 77,
    "diffHunk" : "@@ -1,1 +311,315 @@        b = np.float128(str(a))\n        assert_equal(str(a), str(b))\n        assert_(a != b)\n\n    def float32_roundtrip(self):"
  },
  {
    "id" : "0cd65f6f-c983-42b1-bf05-378dfa438f6e",
    "prId" : 10444,
    "prUrl" : "https://github.com/numpy/numpy/pull/10444#pullrequestreview-126527397",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2bc9398e-5399-41f6-9022-f2380801c48f",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Are we following the printing behavior, or the parsing behavior?",
        "createdAt" : "2018-05-18T07:57:06Z",
        "updatedAt" : "2018-06-06T19:15:57Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "16d53561-6981-43f7-8da6-8fa75e7aee9c",
        "parentId" : "2bc9398e-5399-41f6-9022-f2380801c48f",
        "authorId" : "a4f03a99-2e43-482b-a9bc-5a9e359abb03",
        "body" : "The printing behavior, since the two values are different yet print the same. If we want to \"fix\" it, we need to account for the 107th bit in the dragon4 code above, by slightly changing the \"shift\" calculation, for example so that the 2nd double's mantisa is stored in bits 54 to 0 intead of 53 to 0, and change 53 to 54 in some places.\r\n\r\nI reported this issue here as a question:\r\nhttps://sourceware.org/bugzilla/show_bug.cgi?id=22752\r\n\r\nBut note there is previous discussion I linked there about handling the 107th bit.",
        "createdAt" : "2018-06-06T19:33:56Z",
        "updatedAt" : "2018-06-06T19:39:07Z",
        "lastEditedBy" : "a4f03a99-2e43-482b-a9bc-5a9e359abb03",
        "tags" : [
        ]
      },
      {
        "id" : "faa2f3c6-aab8-47f0-8d22-5d0a37c61f04",
        "parentId" : "2bc9398e-5399-41f6-9022-f2380801c48f",
        "authorId" : "a4f03a99-2e43-482b-a9bc-5a9e359abb03",
        "body" : "Or, correction, it could be that gcc's float128 multiply operation isn't quite right.\r\n\r\nI would summarize the situation as follows:  gcc accounts for the 107th bit when multiplying/dividing, but glibc ignores the 107th bit when printing.",
        "createdAt" : "2018-06-06T19:47:22Z",
        "updatedAt" : "2018-06-06T19:47:22Z",
        "lastEditedBy" : "a4f03a99-2e43-482b-a9bc-5a9e359abb03",
        "tags" : [
        ]
      }
    ],
    "commit" : "cdc6b68476fde6d7e5717b22972cb8147988ce71",
    "line" : 71,
    "diffHunk" : "@@ -1,1 +305,309 @@        assert_equal(got, expected)\n\n        # Note: we follow glibc behavior, but it (or gcc) might not be right.\n        # In particular we can get two values that print the same but are not\n        # equal:"
  }
]
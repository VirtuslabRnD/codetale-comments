[
  {
    "id" : "fd98e525-44df-4425-b983-309eda4a0752",
    "prId" : 14048,
    "prUrl" : "https://github.com/numpy/numpy/pull/14048#pullrequestreview-265156391",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0fe73717-f025-4306-9a04-56306b03f441",
        "parentId" : null,
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "How about we make the validation file float32 specific? Then `convert` is just `lambda x: int(x, 16)`, the dtype starts off with `np.int16` and you can simply use `inval = arr[\"inval_hex\"].view(np.float32)`. I think that is easier to read (in the context of numpy users, also makes the dtype less strange to understand).",
        "createdAt" : "2019-07-19T22:32:51Z",
        "updatedAt" : "2019-07-24T20:43:04Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "6820b454-5d7d-445f-8656-ae92936b2c12",
        "parentId" : "0fe73717-f025-4306-9a04-56306b03f441",
        "authorId" : "bcfc9a54-7a4c-4326-b6cb-aee294b5cf32",
        "body" : "I was hoping to keep it generic for all dtypes, any particular reason to make it float32 specific? ",
        "createdAt" : "2019-07-20T14:44:46Z",
        "updatedAt" : "2019-07-24T20:43:04Z",
        "lastEditedBy" : "bcfc9a54-7a4c-4326-b6cb-aee294b5cf32",
        "tags" : [
        ]
      },
      {
        "id" : "e365977e-cd82-4d36-849b-d6f041603e4e",
        "parentId" : "0fe73717-f025-4306-9a04-56306b03f441",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "I just preferred the view method somewhat, and that does not work well with multiple types. But it is not a big thing, and we can always restructure things a bit.",
        "createdAt" : "2019-07-22T18:55:16Z",
        "updatedAt" : "2019-07-24T20:43:04Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "bc39ab89-db98-41c2-8a7f-7d67d16a38b8",
        "parentId" : "0fe73717-f025-4306-9a04-56306b03f441",
        "authorId" : "bcfc9a54-7a4c-4326-b6cb-aee294b5cf32",
        "body" : "ok, I will leave it as it for now. We could re-factor later if needed. ",
        "createdAt" : "2019-07-23T03:32:20Z",
        "updatedAt" : "2019-07-24T20:43:04Z",
        "lastEditedBy" : "bcfc9a54-7a4c-4326-b6cb-aee294b5cf32",
        "tags" : [
        ]
      }
    ],
    "commit" : "e0860032f45a914501c2bcd339622c394958a687",
    "line" : 40,
    "diffHunk" : "@@ -1,1 +38,42 @@                file_without_comments = (r for r in open(filepath) if not r[0] in ('$', '#'))\n                data = np.genfromtxt(file_without_comments,\n                                     dtype=('|S39','|S39','|S39',np.int),\n                                     names=('type','input','output','ulperr'),\n                                     delimiter=',',"
  },
  {
    "id" : "79e5a721-f770-4c9d-a97f-e0edd7c8b6ff",
    "prId" : 15549,
    "prUrl" : "https://github.com/numpy/numpy/pull/15549#pullrequestreview-357862778",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "be9a623e-e75e-4ed6-a591-c904da3315ae",
        "parentId" : null,
        "authorId" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "body" : "You could write this as `runtest = __cpu_features__.get('AVX512F', False) or (__cpu_features__.get('FMA3', False) and __cpu_features__.get('AVX2', False))`",
        "createdAt" : "2020-02-12T07:35:28Z",
        "updatedAt" : "2020-02-13T04:46:21Z",
        "lastEditedBy" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "tags" : [
        ]
      },
      {
        "id" : "d54cc063-3beb-438f-b406-4f754733ea7a",
        "parentId" : "be9a623e-e75e-4ed6-a591-c904da3315ae",
        "authorId" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "body" : "hmm. Now you don't need the sys.platform (someone brave might try to compile on windows)",
        "createdAt" : "2020-02-12T17:05:58Z",
        "updatedAt" : "2020-02-13T04:46:21Z",
        "lastEditedBy" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "tags" : [
        ]
      },
      {
        "id" : "6bb6c59d-56b3-46e2-bf44-a16483688ce8",
        "parentId" : "be9a623e-e75e-4ed6-a591-c904da3315ae",
        "authorId" : "bcfc9a54-7a4c-4326-b6cb-aee294b5cf32",
        "body" : "It could still call the C standard library of that platform even if AVX is detected at runtime. I know for sure glibc passes these tests on linux, I haven't tested on other OS. Hence the linux constraint. ",
        "createdAt" : "2020-02-12T22:40:49Z",
        "updatedAt" : "2020-02-13T04:46:21Z",
        "lastEditedBy" : "bcfc9a54-7a4c-4326-b6cb-aee294b5cf32",
        "tags" : [
        ]
      },
      {
        "id" : "81c30d22-07b7-4a39-aa19-5c70dfdc0b27",
        "parentId" : "be9a623e-e75e-4ed6-a591-c904da3315ae",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Question about `__cpu_features__`. Does it detect the available CPU features, or did it only find the CPU features that are both available *and* targeted in the build? I assume the \"and targeted in the build\", or should we make a distinction?",
        "createdAt" : "2020-02-12T22:48:10Z",
        "updatedAt" : "2020-02-13T04:46:21Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "91d15293-e498-49fc-b290-1f3df7ddee7b",
        "parentId" : "be9a623e-e75e-4ed6-a591-c904da3315ae",
        "authorId" : "bcfc9a54-7a4c-4326-b6cb-aee294b5cf32",
        "body" : "I think it only detects the available CPU features and has nothing to do with what is targeted in the build. ",
        "createdAt" : "2020-02-12T22:50:49Z",
        "updatedAt" : "2020-02-13T04:46:21Z",
        "lastEditedBy" : "bcfc9a54-7a4c-4326-b6cb-aee294b5cf32",
        "tags" : [
        ]
      },
      {
        "id" : "adc10369-e409-49c1-ab12-f95684f813a6",
        "parentId" : "be9a623e-e75e-4ed6-a591-c904da3315ae",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "I will create an issue to resolve that one, knowing what NumPy is targeted for might be nice, and actually more useful here, no?",
        "createdAt" : "2020-02-12T23:01:27Z",
        "updatedAt" : "2020-02-13T04:46:21Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "9729189c-59ce-4808-b253-d1b221e996f4",
        "parentId" : "be9a623e-e75e-4ed6-a591-c904da3315ae",
        "authorId" : "bcfc9a54-7a4c-4326-b6cb-aee294b5cf32",
        "body" : "umm, won't build targets depend on each Ufunc's implementation? For example, float32 sin/cos/exp/log are build for AVX2 and AVX512F but float64 versions are not. ",
        "createdAt" : "2020-02-12T23:07:07Z",
        "updatedAt" : "2020-02-13T04:46:21Z",
        "lastEditedBy" : "bcfc9a54-7a4c-4326-b6cb-aee294b5cf32",
        "tags" : [
        ]
      },
      {
        "id" : "485295bb-acd5-481a-8ab9-d78618f7053a",
        "parentId" : "be9a623e-e75e-4ed6-a591-c904da3315ae",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "But when you build NumPy you build for a maximal version? I.e. my computer has no AVX2 and AVX512F, so if I build the binary without that and then copy it to a server which has both, my NumPy will definitely not use them. So even though I will not use them, should `__cpu_features__` report them?",
        "createdAt" : "2020-02-12T23:10:06Z",
        "updatedAt" : "2020-02-13T04:46:21Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "e3e4690f-78cb-479a-8857-54626c3ef8d4",
        "parentId" : "be9a623e-e75e-4ed6-a591-c904da3315ae",
        "authorId" : "bcfc9a54-7a4c-4326-b6cb-aee294b5cf32",
        "body" : "As far as I understand, the current build system does not depend on the CPU you build NumPy on.  It only depends on the compiler you use. As long as the compiler can generate AVX2/AVX512F instructions, the Ufunc is build for AVX512F, AVX2 and regular C (assuming the AVX versions exist in the source code). This is done via the function attributes.\r\n\r\nSo, in your example, if you build on a non AVX machine and copy the binary over to a AVX enabled machine, the runtime detects AVX512 and it will run the AVX512 version of the Ufunc.  ",
        "createdAt" : "2020-02-12T23:16:56Z",
        "updatedAt" : "2020-02-13T04:46:21Z",
        "lastEditedBy" : "bcfc9a54-7a4c-4326-b6cb-aee294b5cf32",
        "tags" : [
        ]
      },
      {
        "id" : "c7c06b7b-3527-4be0-98db-29cdacd3cf01",
        "parentId" : "be9a623e-e75e-4ed6-a591-c904da3315ae",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Right, but I still can choose to limit myself (i.e. because my computer cannot run it anyway). And for diagnostics (such as in this tests) it does not really matter what the system supports, what matters whether the running instance is making use of the feature.",
        "createdAt" : "2020-02-12T23:23:38Z",
        "updatedAt" : "2020-02-13T04:46:21Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "b94aea36-56ce-4407-907d-3a991a4b1e35",
        "parentId" : "be9a623e-e75e-4ed6-a591-c904da3315ae",
        "authorId" : "bcfc9a54-7a4c-4326-b6cb-aee294b5cf32",
        "body" : "Ah, I see what you mean. That would mean having both HAVE_ATTRIBUTE_TARGET_AVX512F_WITH_INTRINSICS (which is used for building) and runtime detected features available in the dictionary. I think that would be useful. ",
        "createdAt" : "2020-02-12T23:29:12Z",
        "updatedAt" : "2020-02-13T04:46:21Z",
        "lastEditedBy" : "bcfc9a54-7a4c-4326-b6cb-aee294b5cf32",
        "tags" : [
        ]
      }
    ],
    "commit" : "0a5eb43ac221446ebf6261d7da563c49a28a0b6c",
    "line" : 9,
    "diffHunk" : "@@ -1,1 +10,14 @@IS_AVX = __cpu_features__.get('AVX512F', False) or \\\n        (__cpu_features__.get('FMA3', False) and __cpu_features__.get('AVX2', False))\nruntest = sys.platform.startswith('linux') and IS_AVX\nplatform_skip = pytest.mark.skipif(not runtest,\n                                   reason=\"avoid testing inconsistent platform \""
  }
]
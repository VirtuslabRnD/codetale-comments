[
  {
    "id" : "9b180fa5-fe6d-4fa1-943f-1209d847507b",
    "prId" : 14693,
    "prUrl" : "https://github.com/numpy/numpy/pull/14693#pullrequestreview-304234577",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5e5dfa1d-2745-472f-be55-b2e39f0b0b6c",
        "parentId" : null,
        "authorId" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "body" : "Maybe (please check locally before pushing)\r\n```\r\nx = np.einsum('ijij->', tensor)\r\ny = tensor.trace(axis1=0, axis2=2).trace()\r\nassert_equal(x, y)\r\n```",
        "createdAt" : "2019-10-19T20:55:08Z",
        "updatedAt" : "2019-10-19T22:33:59Z",
        "lastEditedBy" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "tags" : [
        ]
      },
      {
        "id" : "520852b5-5c36-4cb4-9420-1149a2208030",
        "parentId" : "5e5dfa1d-2745-472f-be55-b2e39f0b0b6c",
        "authorId" : "8de63a41-1bc1-4e93-a2df-4f2f940433cf",
        "body" : "With floating point, you can't be sure that `x` and `y` will be *exactly* equal.  Use `assert_allclose` with an appropriately small tolerance, or use an integer array for `tensor` (assuming the test doesn't actually depend on the data type of the array).",
        "createdAt" : "2019-10-19T21:14:33Z",
        "updatedAt" : "2019-10-19T22:33:59Z",
        "lastEditedBy" : "8de63a41-1bc1-4e93-a2df-4f2f940433cf",
        "tags" : [
        ]
      },
      {
        "id" : "2c3f1d86-971b-42e1-98da-d44847ed7de3",
        "parentId" : "5e5dfa1d-2745-472f-be55-b2e39f0b0b6c",
        "authorId" : "853df835-c8c8-466e-a368-8d2c49a415d4",
        "body" : "Done; tested on x86_64, power9, and s390x; and pushed.",
        "createdAt" : "2019-10-19T23:02:20Z",
        "updatedAt" : "2019-10-19T23:02:20Z",
        "lastEditedBy" : "853df835-c8c8-466e-a368-8d2c49a415d4",
        "tags" : [
        ]
      }
    ],
    "commit" : "263f6169339686e723d645c60ae5ea9fe87c7e9d",
    "line" : 20,
    "diffHunk" : "@@ -1,1 +708,712 @@        y = tensor.trace(axis1=0, axis2=2).trace()\n        assert_allclose(x, y)\n\n    def test_einsum_all_contig_non_contig_output(self):\n        # Issue gh-5907, tests that the all contiguous special case"
  },
  {
    "id" : "e463df88-e5de-4a93-8ea0-083963b79a46",
    "prId" : 16080,
    "prUrl" : "https://github.com/numpy/numpy/pull/16080#pullrequestreview-411386984",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "65b95798-69ac-4787-a4c2-7cd6f6579821",
        "parentId" : null,
        "authorId" : "fe664d20-2239-4242-9bd1-2c7a4f010863",
        "body" : "Are we testing for other opt_types for np.int64 and optimize values which are not False. This may be useful to trigger einsum_path code path and ensure _parse_einsum_input is correct.",
        "createdAt" : "2020-05-06T21:26:48Z",
        "updatedAt" : "2020-05-16T07:46:25Z",
        "lastEditedBy" : "fe664d20-2239-4242-9bd1-2c7a4f010863",
        "tags" : [
        ]
      },
      {
        "id" : "8964ba7f-14b4-4ae7-8588-2c96474c8037",
        "parentId" : "65b95798-69ac-4787-a4c2-7cd6f6579821",
        "authorId" : "fcc77d1a-7ae7-4441-abd6-a8696a449efa",
        "body" : "Thanks for the comment!\r\n\r\nSorry, what do you mean by other opt_types? I am very new to working on numpy\r\n\r\nBut it does test for both optimize=False and optimize=True, and goes through both the C and Python implementation if that is what you mean",
        "createdAt" : "2020-05-09T05:22:51Z",
        "updatedAt" : "2020-05-16T07:46:25Z",
        "lastEditedBy" : "fcc77d1a-7ae7-4441-abd6-a8696a449efa",
        "tags" : [
        ]
      },
      {
        "id" : "e74f05da-5185-4967-8725-62c60c6a656b",
        "parentId" : "65b95798-69ac-4787-a4c2-7cd6f6579821",
        "authorId" : "fe664d20-2239-4242-9bd1-2c7a4f010863",
        "body" : "apologies for the delay in reply, what i meant is adding a `self.check_einsum_sums('i8', True)` for `test_einsum_sums_int64`. by other opt_types i mean other options for optimize (False, True, greedy, optimal) (likely False, True, check may suffice).",
        "createdAt" : "2020-05-12T04:39:11Z",
        "updatedAt" : "2020-05-16T07:46:25Z",
        "lastEditedBy" : "fe664d20-2239-4242-9bd1-2c7a4f010863",
        "tags" : [
        ]
      },
      {
        "id" : "b481f04f-d0be-4c7f-93df-e6519e3e31ff",
        "parentId" : "65b95798-69ac-4787-a4c2-7cd6f6579821",
        "authorId" : "fcc77d1a-7ae7-4441-abd6-a8696a449efa",
        "body" : "Ahh, I think I see. It seems like `_parse_einsum_input` is called in all cases if optimization is turned on, so I think the test coverage is complete. I have put the subscript list test in `self.check_einsum_sums` itself so that it is tested with all dtypes and opt_types that were being tested before. Hopefully this is OK",
        "createdAt" : "2020-05-13T04:55:33Z",
        "updatedAt" : "2020-05-16T07:46:25Z",
        "lastEditedBy" : "fcc77d1a-7ae7-4441-abd6-a8696a449efa",
        "tags" : [
        ]
      },
      {
        "id" : "2101c55a-39e2-4103-9624-337b0185e9e8",
        "parentId" : "65b95798-69ac-4787-a4c2-7cd6f6579821",
        "authorId" : "fe664d20-2239-4242-9bd1-2c7a4f010863",
        "body" : "Yes, on a second look I think this test handles other values for optimize and I think it should be fine.",
        "createdAt" : "2020-05-14T00:26:49Z",
        "updatedAt" : "2020-05-16T07:46:25Z",
        "lastEditedBy" : "fe664d20-2239-4242-9bd1-2c7a4f010863",
        "tags" : [
        ]
      }
    ],
    "commit" : "eb388956408bbc01aa526ddcbc37a318f43823ce",
    "line" : 8,
    "diffHunk" : "@@ -1,1 +279,283 @@            assert_equal(np.einsum(a, np_array, optimize=do_opt),\n                         np.trace(a).astype(dtype))\n            assert_equal(np.einsum(a, list(np_array), optimize=do_opt),\n                         np.trace(a).astype(dtype))\n"
  }
]
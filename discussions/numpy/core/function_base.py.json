[
  {
    "id" : "7705bdbd-2d09-4de3-9961-b8f0e6a1dd7b",
    "prId" : 3482,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ca00b1f0-ff64-458c-89ab-de4b598340b3",
        "parentId" : null,
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "After double checking, this seems not quite right. `dtype(None) == np.float64` in other words, this casts to float no matter what the input is if `None` is given, which disagrees with the documentation.\n",
        "createdAt" : "2013-06-28T20:33:51Z",
        "updatedAt" : "2013-09-13T21:28:10Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      }
    ],
    "commit" : "f8cdbbaee1967011d98aa454b14232488df451d3",
    "line" : 48,
    "diffHunk" : "@@ -1,1 +95,99 @@        y = _nx.arange(0, num, dtype=dtype) * step + start\n    if retstep:\n        return y.astype(dtype), step\n    else:\n        return y.astype(dtype)"
  },
  {
    "id" : "0c9ae198-9b9b-44ef-8d18-42ce63a318ba",
    "prId" : 5446,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7a2ee573-5429-4a65-8eee-92334ea0d22f",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Shouldn't 1 item long sequences raise an error if `start != stop` and `endpoint == True`?\n",
        "createdAt" : "2015-01-14T18:40:34Z",
        "updatedAt" : "2015-01-14T18:40:34Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "c9461bc6-aae8-4ca6-affb-793b9a3da5e2",
        "parentId" : "7a2ee573-5429-4a65-8eee-92334ea0d22f",
        "authorId" : "34105ae0-9fd2-4403-be9b-7c550a729828",
        "body" : "It could, but it doesn't right now. A negative `num` is also a good candidate for a `ValueError`, but it also never has.\n\nThere was some minimal discussion on the list between Chris Barker and Ben Root, on whether to return whatever or raise an error. I have no opinion either way, but in the absence of a strong argument, I would go with the principle of least surprise and leave things as they are.\n",
        "createdAt" : "2015-01-14T18:48:37Z",
        "updatedAt" : "2015-01-14T18:48:37Z",
        "lastEditedBy" : "34105ae0-9fd2-4403-be9b-7c550a729828",
        "tags" : [
        ]
      },
      {
        "id" : "5834d4b1-7e53-4d75-9c6b-911e30eadd2f",
        "parentId" : "7a2ee573-5429-4a65-8eee-92334ea0d22f",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Seems to me that both those cases are actually errors. Hmm, I'd even be inclined to require `num` at least two if `endpoint=True`, and at least one if not, but would be pushing things...\n",
        "createdAt" : "2015-01-14T19:08:30Z",
        "updatedAt" : "2015-01-14T19:08:30Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "2aab65415843c8a8c662ddb5d33536dc95671076",
    "line" : 41,
    "diffHunk" : "@@ -1,1 +105,109 @@            y *= step\n    else:\n        # 0 and 1 item long sequences have an undefined step\n        step = NaN\n"
  },
  {
    "id" : "2ae6cf90-513e-43b5-8e1e-3a5358baacb4",
    "prId" : 5446,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ad56ab2f-b688-43e6-8e15-6d3909b93b5f",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Could as easily be `0`, any special reason for `NaN`?\n",
        "createdAt" : "2015-01-14T18:44:28Z",
        "updatedAt" : "2015-01-14T18:44:28Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "2aab65415843c8a8c662ddb5d33536dc95671076",
    "line" : 42,
    "diffHunk" : "@@ -1,1 +106,110 @@    else:\n        # 0 and 1 item long sequences have an undefined step\n        step = NaN\n\n    y += start"
  },
  {
    "id" : "599d7f91-4a48-44ef-9ec1-b196e06960b9",
    "prId" : 7328,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7acfac79-6c2f-480b-9175-62787d37c245",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Why use stack level 3?\n",
        "createdAt" : "2016-03-08T21:24:37Z",
        "updatedAt" : "2016-03-09T08:28:10Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "c2019ea7-389c-4494-ae0f-8d8e5525283f",
        "parentId" : "7acfac79-6c2f-480b-9175-62787d37c245",
        "authorId" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "body" : "That's correct -- the +1 corrects for the helper function's stack frame, and then stacklevel 2 means to warn the caller of linspace (rather than warning linspace itself).\n",
        "createdAt" : "2016-03-08T21:40:31Z",
        "updatedAt" : "2016-03-09T08:28:10Z",
        "lastEditedBy" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "tags" : [
        ]
      }
    ],
    "commit" : "3af411b270c8ec57ca9ced6fb69029cd86a8e417",
    "line" : null,
    "diffHunk" : "@@ -1,1 +16,20 @@               \"an integer.\".format(type(i)))\n        i = int(i)\n        stacklevel += 1\n        warnings.warn(msg, DeprecationWarning, stacklevel=stacklevel)\n    return i"
  },
  {
    "id" : "40a620d1-07c5-470f-a2a5-8a5487d3b610",
    "prId" : 7328,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7fabf496-e6d7-4411-b79f-a495f02d5d52",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Don't use a function for this and using the `try ... except` construct seems unwieldy. I suspect you could either check for the `__index__` attribute, or use the `numbers` module\n\n```\nif not isinstance(i, numbers.Integral):\n    deprecate...\ni = int(i)\n```\n",
        "createdAt" : "2016-03-08T21:34:24Z",
        "updatedAt" : "2016-03-09T08:28:10Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "774ad4f5-feb9-43f4-bc32-d07005c384c3",
        "parentId" : "7fabf496-e6d7-4411-b79f-a495f02d5d52",
        "authorId" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "body" : "Hmm, try/except seems simple and obviously correct to me. I think checking for `__index__` is probably correct but am not as confident, and I'm pretty sure checking for `Integral` is subtly wrong. So I'd vote for the current implementation, on the ground that we should only use style as a tie breaker when we're version that all the options being considered are correct :-).\n\nIt doesn't much matter whether we have a helper function here or write the same code inline, but I think the helper function got added at someone (@seberg's?) request in an earlier round of review, and I do agree that it makes things easier to read. I think the original motivation was that we have a similar helper at the C level and it's useful to use in multiple places; here we only have one user so it doesn't matter as much, but potentially there will be other users in the future.\n",
        "createdAt" : "2016-03-08T21:47:49Z",
        "updatedAt" : "2016-03-09T08:28:10Z",
        "lastEditedBy" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "tags" : [
        ]
      },
      {
        "id" : "69738e60-7dc8-49f0-8bbc-e68493609694",
        "parentId" : "7fabf496-e6d7-4411-b79f-a495f02d5d52",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Yeah, I thought it was a good idea. Of course, it basically only makes sense if we also use it elsewhere, I somewhat expected we have enough other places. Tthough, of course it is also possible that nobody will bother to do similar fixes elsewhere for a long while....\n\nI like using try/except. Try except seems nice to me, since it tries to use the final version we would like to be using at some point. If the final version wasn't what we try first, I would agree that the check might be better (though it also safes me from worrying about weird corner cases).\n",
        "createdAt" : "2016-03-08T21:58:33Z",
        "updatedAt" : "2016-03-09T08:28:10Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "37f71ad1-c61f-48c6-a46c-f4e03c6adf30",
        "parentId" : "7fabf496-e6d7-4411-b79f-a495f02d5d52",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "> I'm pretty sure checking for Integral is subtly wrong.\n\nCould you explain? It gets all the numpy and python integers and their subclasses and can't be worse than calling `__index__` to see what happens. It also guarantees int conversions, and ints are what we want, not indexes.\n",
        "createdAt" : "2016-03-08T23:14:15Z",
        "updatedAt" : "2016-03-09T08:28:10Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "ba3c89ac-01da-4b6c-8014-640c50ff49da",
        "parentId" : "7fabf496-e6d7-4411-b79f-a495f02d5d52",
        "authorId" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "body" : "`__index__` is the standard Python protocol for \"you should support silently coercing me to an integer\", and what we use universally everywhere else (or have been migrating towards using). For the particular types you list either approach will give the same answer, but in general there's no rule that everyone who implements `__index__` has to also subclass `Integral`.\n\nAlso:\n\n```\nIn [4]: isinstance(np.int8, numbers.Integral)\nOut[4]: False\n```\n",
        "createdAt" : "2016-03-08T23:25:00Z",
        "updatedAt" : "2016-03-09T08:28:10Z",
        "lastEditedBy" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "tags" : [
        ]
      },
      {
        "id" : "56c80c21-4453-417a-8104-146ae6367b60",
        "parentId" : "7fabf496-e6d7-4411-b79f-a495f02d5d52",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Note that using index passes numpy booleans, although python booleans always pass as subclasses of int. Also, we are counting (integers) not indexing. If we check for indexes we should change the documentation and warning to reflect that requirement.\n",
        "createdAt" : "2016-03-08T23:48:52Z",
        "updatedAt" : "2016-03-09T08:28:10Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "e5530c79-8c0e-4d7c-9c64-df70e63ee458",
        "parentId" : "7fabf496-e6d7-4411-b79f-a495f02d5d52",
        "authorId" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "body" : "> Note that using index passes numpy booleans, although python booleans always pass as subclasses of int\n\nGood catch :-) gh-7395\n\n> Also, we are counting (integers) not indexing. If we check for indexes we should change the documentation and warning to reflect that requirement.\n\nSome other built-in python functions that are not indexing, but that nonetheless call `__index__`: `hex/oct/bin`, `int(x, base=b)` (calls `x.__int__` but `b.__index__`), `list.__mul__`, `range(...)`, `struct.pack` (when packing an integer), ...\n\nOfficial documentation of `__index__`: \"Called [...] whenever Python needs to losslessly convert the numeric object to an integer object\"\n\nThe name `__index__` is a historical artifact -- indexing is one place where it's used, but that's not really what it's about. `__index__` is very much the standard Python way to do safe casting to `int` (as opposed to `__int__`, which is for unsafe casting).\n",
        "createdAt" : "2016-03-09T00:25:05Z",
        "updatedAt" : "2016-03-09T08:28:10Z",
        "lastEditedBy" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "tags" : [
        ]
      }
    ],
    "commit" : "3af411b270c8ec57ca9ced6fb69029cd86a8e417",
    "line" : 11,
    "diffHunk" : "@@ -1,1 +9,13 @@from .numeric import result_type, NaN, shares_memory, MAY_SHARE_BOUNDS, TooHardError\n\ndef _index_deprecate(i, stacklevel=2):\n    try:\n        i = operator.index(i)"
  }
]
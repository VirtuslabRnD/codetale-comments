[
  {
    "id" : "140ef126-4849-4966-b820-c249a86bb079",
    "prId" : 3341,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "defb6525-f719-4b88-9da1-300f1df119af",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Don't use C++ comment style. \n",
        "createdAt" : "2013-05-23T16:08:03Z",
        "updatedAt" : "2013-05-25T15:36:50Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "ef5c7698-9131-452f-83d3-4e4a02444e35",
        "parentId" : "defb6525-f719-4b88-9da1-300f1df119af",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "nvm. \n",
        "createdAt" : "2013-05-23T16:08:44Z",
        "updatedAt" : "2013-05-25T15:36:50Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "fe69102dd34619ce18cf074ef0e6e46611bc17e7",
    "line" : null,
    "diffHunk" : "@@ -1,1 +424,428 @@ * npy_intp esize = sizeof(v[0]);\n * npy_intp peel = npy_aligned_block_offset(v, esize, 16, n);\n * // peel to alignment 16\n * for (i = 0; i < peel; i++)\n *   <scalar-op>"
  },
  {
    "id" : "44130327-c473-4e4a-83e0-734c7bdf2bc2",
    "prId" : 3376,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "06369854-c881-45e5-bfa6-14e162ac8cb8",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Hmm, haven't seen that before. I assume the `u` prefix means unsigned. Is it portable?\n",
        "createdAt" : "2013-05-29T17:24:12Z",
        "updatedAt" : "2013-05-29T17:58:59Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "ccf97011-79d5-4f03-bcd9-14244ff84a4f",
        "parentId" : "06369854-c881-45e5-bfa6-14e162ac8cb8",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "I'm curious, what does the generated assembly look like for these constructs? Any reason not to use byte addressing?\n",
        "createdAt" : "2013-05-29T17:26:30Z",
        "updatedAt" : "2013-05-29T17:58:59Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "97d6127a-a22e-414c-aa14-2411dce841e1",
        "parentId" : "06369854-c881-45e5-bfa6-14e162ac8cb8",
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "yes it means unsigned, its the same code from lowlevel_strided_loops.c.src so if it worked before it still works now.\n\nthe LLU used for 8 bytes is C99 but its backported to gnu89 numpy uses with gcc.\nIts also just moved old code so it should work.\n",
        "createdAt" : "2013-05-29T17:27:31Z",
        "updatedAt" : "2013-05-29T17:58:59Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      },
      {
        "id" : "176a6418-f754-46cc-81e8-a25dd3875914",
        "parentId" : "06369854-c881-45e5-bfa6-14e162ac8cb8",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "OK, probably the only worry would be MSVC and it doesn't seem to have been a problem. \n",
        "createdAt" : "2013-05-29T17:38:38Z",
        "updatedAt" : "2013-05-29T17:58:59Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "6750112e-c2e3-4187-826b-a61823455531",
        "parentId" : "06369854-c881-45e5-bfa6-14e162ac8cb8",
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "on x86 a newish gcc will replace that with a bswap instruction (or movbe if available on target). if neither is available (i386) a bunch of ror (rotate).\nit does not do the same if you use byte addressing variant, it probably could if someone provides an appropriate pattern matcher to gcc.\n",
        "createdAt" : "2013-05-29T17:39:29Z",
        "updatedAt" : "2013-05-29T17:58:59Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      }
    ],
    "commit" : "0258a3e65ba9fea8892aaa9761bf7e37c999c8fd",
    "line" : 51,
    "diffHunk" : "@@ -1,1 +476,480 @@    return __builtin_bswap32(x);\n#else\n    return ((x & 0xffu) << 24) | ((x & 0xff00u) << 8) |\n           ((x & 0xff0000u) >> 8) | (x >> 24);\n#endif"
  },
  {
    "id" : "5cc854f2-c08f-48a8-831c-7db45be23b41",
    "prId" : 8043,
    "prUrl" : "https://github.com/numpy/numpy/pull/8043#pullrequestreview-21176683",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "070bf4e2-2257-479f-8a50-254d9fa3b7e1",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Seems rather large for inline ;)\n",
        "createdAt" : "2016-11-06T16:56:24Z",
        "updatedAt" : "2017-02-10T19:53:34Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "f8db8ac4-4908-4266-8b87-8d4be54205da",
        "parentId" : "070bf4e2-2257-479f-8a50-254d9fa3b7e1",
        "authorId" : "48d7d71b-9655-46b2-9a18-7c1fba7837d0",
        "body" : "OTOH, I don't really want to put it in a .c file since the logic is tightly coupled to the macros here (and I suspect the multiarray/umath split adds to the mess). Removing the inline makes it emit compiler warnings. I could write this as a macro, but that's messy.",
        "createdAt" : "2017-01-22T02:17:04Z",
        "updatedAt" : "2017-02-10T19:53:34Z",
        "lastEditedBy" : "48d7d71b-9655-46b2-9a18-7c1fba7837d0",
        "tags" : [
        ]
      },
      {
        "id" : "f88eaf69-dc8a-40ff-af16-3ea74ebc37d3",
        "parentId" : "070bf4e2-2257-479f-8a50-254d9fa3b7e1",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "C++ beckons ;)",
        "createdAt" : "2017-02-10T04:12:55Z",
        "updatedAt" : "2017-02-10T19:53:34Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "8e8ce442e8449916a93951093cdce16cec006bcc",
    "line" : 44,
    "diffHunk" : "@@ -1,1 +698,702 @@\nstatic NPY_INLINE int\nPyArray_EQUIVALENTLY_ITERABLE_OVERLAP_OK(PyArrayObject *arr1, PyArrayObject *arr2,\n                                         int arr1_read, int arr2_read)\n{"
  }
]
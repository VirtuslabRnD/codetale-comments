[
  {
    "id" : "b43770e5-f2c9-4608-a791-e0bc7bea7c90",
    "prId" : 6166,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1d9a1761-1b12-41ee-b6e9-f19d11a90b86",
        "parentId" : null,
        "authorId" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "body" : "Since I spent a bit thinking about whether this could happen and looking things up, might make sense to add some notes :-).\n\nMy conclusions: For this to happen, you have to have an actual 64 bit virtual address space -- it can't happen with e.g. a 63-bit address space. Current x86-64 implementations have only a 48-bit virtual address space, though in principle this [could be extended in the future to support the full 64 bits](https://en.wikipedia.org/wiki/X86-64#Architectural_features). It'll still be _extremely_ weird to have a single array that stretches across more than half of this space, given that it's many orders of magnitude larger than any physical memory, but I guess in principle it could happen someday in the future when people are memmaping their multi-exabyte files...\n",
        "createdAt" : "2015-08-11T23:38:44Z",
        "updatedAt" : "2015-08-29T15:20:13Z",
        "lastEditedBy" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "tags" : [
        ]
      }
    ],
    "commit" : "3a52e1942aac937e8ae8381f9ea519b9328fd052",
    "line" : 153,
    "diffHunk" : "@@ -1,1 +151,155 @@  cases). Potential failure modes:\n\n  - Array extent sum(stride*(shape-1)) is too large (for int64).\n\n  - Minimal solutions to a_i x_i + a_j x_j == b are too large,"
  },
  {
    "id" : "487cbeb3-83b1-486c-aedc-82e71ebbb5f2",
    "prId" : 6166,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9c66dadd-6d53-4b06-8c1c-3c40ec86d871",
        "parentId" : null,
        "authorId" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "body" : "Is there any intuition about when this might occur? Or even it'd be nice to know whether this is something you've ever observed in practice.\n",
        "createdAt" : "2015-08-11T23:39:40Z",
        "updatedAt" : "2015-08-29T15:20:13Z",
        "lastEditedBy" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "tags" : [
        ]
      },
      {
        "id" : "19c9824d-23ae-4347-b77d-f27c9efa4d11",
        "parentId" : "9c66dadd-6d53-4b06-8c1c-3c40ec86d871",
        "authorId" : "48d7d71b-9655-46b2-9a18-7c1fba7837d0",
        "body" : "The magnitudes are bounded by |x1|<a2/gcd(a1,a2), |x2|<a1/gcd(a1,a2),\nand intermediate steps compute `b*x1`, `b*x2`.\nOverflows can then occur if both strides and end-start offset of the two arrays are of order 2**32,\nso you can get those with a couple GB arrays.\n\nExample:\n\n```\nfrom numpy.core.multiarray_tests import solve_diophantine\n\np = 2**32 - 1  # Mersenne prime\na1 = p\na2 = p + p - 2\n\nstrides_a = (a1, 1)\nshape_a = (3, 3*p)\noffset_a = 1\n\nstrides_b = (a2, 1)\nshape_b = (3, 2)\noffset_b = p\n\nrhs = offset_a - offset_b + sum(s*(n-1) for s,n in zip(strides_a, shape_a))\n\nsolve_diophantine(strides_a + strides_b,\n                  tuple(n-1 for n in shape_a) + tuple(n-1 for n in shape_b),\n                  rhs,\n                  simplify=1)\n```\n\nUsing 128-bit integers in the computation of t_l,t_u might avoid all integer overflows.\nThis might be the right thing to do...\n",
        "createdAt" : "2015-08-12T09:27:25Z",
        "updatedAt" : "2015-08-29T15:20:13Z",
        "lastEditedBy" : "48d7d71b-9655-46b2-9a18-7c1fba7837d0",
        "tags" : [
        ]
      }
    ],
    "commit" : "3a52e1942aac937e8ae8381f9ea519b9328fd052",
    "line" : 156,
    "diffHunk" : "@@ -1,1 +154,158 @@\n  - Minimal solutions to a_i x_i + a_j x_j == b are too large,\n    in some of the intermediate equations.\n\n    We do this part of the computation in 128-bit integers."
  }
]
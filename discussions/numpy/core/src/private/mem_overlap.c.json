[
  {
    "id" : "b43770e5-f2c9-4608-a791-e0bc7bea7c90",
    "prId" : 6166,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1d9a1761-1b12-41ee-b6e9-f19d11a90b86",
        "parentId" : null,
        "authorId" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "body" : "Since I spent a bit thinking about whether this could happen and looking things up, might make sense to add some notes :-).\n\nMy conclusions: For this to happen, you have to have an actual 64 bit virtual address space -- it can't happen with e.g. a 63-bit address space. Current x86-64 implementations have only a 48-bit virtual address space, though in principle this [could be extended in the future to support the full 64 bits](https://en.wikipedia.org/wiki/X86-64#Architectural_features). It'll still be _extremely_ weird to have a single array that stretches across more than half of this space, given that it's many orders of magnitude larger than any physical memory, but I guess in principle it could happen someday in the future when people are memmaping their multi-exabyte files...\n",
        "createdAt" : "2015-08-11T23:38:44Z",
        "updatedAt" : "2015-08-29T15:20:13Z",
        "lastEditedBy" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "tags" : [
        ]
      }
    ],
    "commit" : "3a52e1942aac937e8ae8381f9ea519b9328fd052",
    "line" : 153,
    "diffHunk" : "@@ -1,1 +151,155 @@  cases). Potential failure modes:\n\n  - Array extent sum(stride*(shape-1)) is too large (for int64).\n\n  - Minimal solutions to a_i x_i + a_j x_j == b are too large,"
  },
  {
    "id" : "487cbeb3-83b1-486c-aedc-82e71ebbb5f2",
    "prId" : 6166,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9c66dadd-6d53-4b06-8c1c-3c40ec86d871",
        "parentId" : null,
        "authorId" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "body" : "Is there any intuition about when this might occur? Or even it'd be nice to know whether this is something you've ever observed in practice.\n",
        "createdAt" : "2015-08-11T23:39:40Z",
        "updatedAt" : "2015-08-29T15:20:13Z",
        "lastEditedBy" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "tags" : [
        ]
      },
      {
        "id" : "19c9824d-23ae-4347-b77d-f27c9efa4d11",
        "parentId" : "9c66dadd-6d53-4b06-8c1c-3c40ec86d871",
        "authorId" : "48d7d71b-9655-46b2-9a18-7c1fba7837d0",
        "body" : "The magnitudes are bounded by |x1|<a2/gcd(a1,a2), |x2|<a1/gcd(a1,a2),\nand intermediate steps compute `b*x1`, `b*x2`.\nOverflows can then occur if both strides and end-start offset of the two arrays are of order 2**32,\nso you can get those with a couple GB arrays.\n\nExample:\n\n```\nfrom numpy.core.multiarray_tests import solve_diophantine\n\np = 2**32 - 1  # Mersenne prime\na1 = p\na2 = p + p - 2\n\nstrides_a = (a1, 1)\nshape_a = (3, 3*p)\noffset_a = 1\n\nstrides_b = (a2, 1)\nshape_b = (3, 2)\noffset_b = p\n\nrhs = offset_a - offset_b + sum(s*(n-1) for s,n in zip(strides_a, shape_a))\n\nsolve_diophantine(strides_a + strides_b,\n                  tuple(n-1 for n in shape_a) + tuple(n-1 for n in shape_b),\n                  rhs,\n                  simplify=1)\n```\n\nUsing 128-bit integers in the computation of t_l,t_u might avoid all integer overflows.\nThis might be the right thing to do...\n",
        "createdAt" : "2015-08-12T09:27:25Z",
        "updatedAt" : "2015-08-29T15:20:13Z",
        "lastEditedBy" : "48d7d71b-9655-46b2-9a18-7c1fba7837d0",
        "tags" : [
        ]
      }
    ],
    "commit" : "3a52e1942aac937e8ae8381f9ea519b9328fd052",
    "line" : 156,
    "diffHunk" : "@@ -1,1 +154,158 @@\n  - Minimal solutions to a_i x_i + a_j x_j == b are too large,\n    in some of the intermediate equations.\n\n    We do this part of the computation in 128-bit integers."
  },
  {
    "id" : "2823362a-37e4-4ee3-b6af-cb9d7781f0be",
    "prId" : 10293,
    "prUrl" : "https://github.com/numpy/numpy/pull/10293#pullrequestreview-85927575",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e52f19c2-5f42-4acc-be7d-a080a72acb36",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Seems `nterms` should be an `int`, to match `PyArray_NDIM`",
        "createdAt" : "2017-12-29T09:06:20Z",
        "updatedAt" : "2017-12-29T15:08:51Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "19c55b91f6c1eca5b44b0e72b27f829bc64c35f8",
    "line" : 12,
    "diffHunk" : "@@ -1,1 +711,715 @@static int\nstrides_to_terms(PyArrayObject *arr, diophantine_term_t *terms,\n                 unsigned int *nterms, int skip_empty)\n{\n    int i;"
  },
  {
    "id" : "ea1ca89d-668a-4168-8815-dcd1635a5539",
    "prId" : 10293,
    "prUrl" : "https://github.com/numpy/numpy/pull/10293#pullrequestreview-85964145",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e392cd26-f36e-4c50-8ddf-43e96768bb7c",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Which would make these `int` again",
        "createdAt" : "2017-12-29T09:19:26Z",
        "updatedAt" : "2017-12-29T15:08:51Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "2699e582-64c9-459e-9413-619a4b5eb46e",
        "parentId" : "e392cd26-f36e-4c50-8ddf-43e96768bb7c",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "That would probably work, but `nterms` gets passed down through several routines and I'd need to audit all of them to make sure nothing could go wrong. This is the safest, quick fix. I do think the overlap code could use a more exhaustive cleanup now that it has had time to settle, but I don't want to do it in this PR.",
        "createdAt" : "2017-12-29T14:25:35Z",
        "updatedAt" : "2017-12-29T15:08:51Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "df60f748-1331-42c2-ab45-0613f24bb3e4",
        "parentId" : "e392cd26-f36e-4c50-8ddf-43e96768bb7c",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "My guess is that no unsigned integers are needed in the code, except possibly `npy_uintp`, and I'm not sure about that as `ptrdiff_t` should serve if present. I'll open an issue for a `mem_overlap` review.",
        "createdAt" : "2017-12-29T14:35:40Z",
        "updatedAt" : "2017-12-29T15:08:51Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "3e81b42f-12e7-48fe-aad2-c03017bd1795",
        "parentId" : "e392cd26-f36e-4c50-8ddf-43e96768bb7c",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "See #10296.",
        "createdAt" : "2017-12-29T14:41:15Z",
        "updatedAt" : "2017-12-29T15:08:51Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "19c55b91f6c1eca5b44b0e72b27f829bc64c35f8",
    "line" : 56,
    "diffHunk" : "@@ -1,1 +849,853 @@    diophantine_term_t terms[NPY_MAXDIMS+1];\n    npy_int64 x[NPY_MAXDIMS+1];\n    unsigned int i, j, nterms;\n\n    if (PyArray_ISCONTIGUOUS(a)) {"
  }
]
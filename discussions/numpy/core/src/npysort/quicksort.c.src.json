[
  {
    "id" : "cb5cfce5-4aff-4a46-b44d-7222c2b09291",
    "prId" : 5494,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bae44b47-ac2a-4881-beba-c851ba462bad",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "I forget. Is this a `cmp` or a `rich_compare`?\n",
        "createdAt" : "2015-02-23T01:50:48Z",
        "updatedAt" : "2015-02-24T05:32:36Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "6a27c567-889f-4632-8dd3-e571554a6dae",
        "parentId" : "bae44b47-ac2a-4881-beba-c851ba462bad",
        "authorId" : "34105ae0-9fd2-4403-be9b-7c550a729828",
        "body" : "For object types, in Python3 it is implemented with two calls to `PyObject_RichCompareBool`, but unless an error is raised it behaves like a compare establishing an ordering. The source is [here](https://github.com/numpy/numpy/blob/maintenance/1.9.x/numpy/core/src/multiarray/arraytypes.c.src#L2590). If an error is raised I think it mistakenly thinks both items compared equal, but the error is caught an raised in `_new_argsortlike`.\n",
        "createdAt" : "2015-02-24T05:20:22Z",
        "updatedAt" : "2015-02-24T05:32:36Z",
        "lastEditedBy" : "34105ae0-9fd2-4403-be9b-7c550a729828",
        "tags" : [
        ]
      }
    ],
    "commit" : "a0aaf752c75c310d4eeae1af1064ec8046e6d5e9",
    "line" : 10,
    "diffHunk" : "@@ -1,1 +368,372 @@{\n    npy_intp elsize = PyArray_ITEMSIZE(arr);\n    PyArray_CompareFunc *cmp = PyArray_DESCR(arr)->f->compare;\n    char *vp;\n    npy_intp *pl = tosort;"
  },
  {
    "id" : "e4301857-f729-4816-9530-e07f806ad20f",
    "prId" : 7871,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "20e155aa-51b7-4aa4-ac78-d414c53360db",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "For instance\n\n```\n                while (sptr != stack) {\n                     pr = *(--sptr);\n                     pl = *(--sptr);\n                     cdepth = *(--psdepth) \n                     if (cdepth < depth_limit) {\n                         break;\n                     }\n                     aheapsort_@suff@(vv, pl, pr - pl + 1, NULL);\n                 }\n                 if (sptr == stack) {\n                     break;\n                 }\n```\n\nwhich gets rid of the goto.\n",
        "createdAt" : "2016-07-27T19:04:12Z",
        "updatedAt" : "2016-07-29T19:42:35Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "0c96bac1-4400-4a6d-afe2-29ae55ae26d2",
        "parentId" : "20e155aa-51b7-4aa4-ac78-d414c53360db",
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "but this switches everything to heapsort on the first bad partition, a bad partition does not mean the full array needs to be heapsorted only the current part\n",
        "createdAt" : "2016-07-27T19:15:28Z",
        "updatedAt" : "2016-07-29T19:42:35Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      },
      {
        "id" : "b415d066-69ca-4888-9931-695e94e0dc35",
        "parentId" : "20e155aa-51b7-4aa4-ac78-d414c53360db",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "No it doesn't, if `depth` is properly incremented it loops at most twice.\n\nEDIT: and heapsorts at most once.\n",
        "createdAt" : "2016-07-27T19:17:59Z",
        "updatedAt" : "2016-07-29T19:42:35Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "eefc439e-994a-4d9d-b579-e327606db694",
        "parentId" : "20e155aa-51b7-4aa4-ac78-d414c53360db",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Note that the logic is basically what you have now, just no `goto`.\n",
        "createdAt" : "2016-07-27T19:20:32Z",
        "updatedAt" : "2016-07-29T19:42:35Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "c5a12cc0-82a9-42b7-bde0-33094bd78d15",
        "parentId" : "20e155aa-51b7-4aa4-ac78-d414c53360db",
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "hm right I misread the break condition.\nI still don't like it as much. The goto variant makes the code structure more similar to the recursive code which is much easier to understand, you just have to interpret the goto stack pop as the equivalent of the return statement in the recursive one.\nBut if you prefer it like that I can change it\n",
        "createdAt" : "2016-07-27T19:29:53Z",
        "updatedAt" : "2016-07-29T19:42:35Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      },
      {
        "id" : "9204c132-8f7e-4291-acb8-fdfc80c67f4b",
        "parentId" : "20e155aa-51b7-4aa4-ac78-d414c53360db",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Well, it has the advantage the need to increment depth on every push is made clear. I think it makes the logic a bit clearer because everything takes place in a few lines. Note that you do need the `++depth` so that the depth is strictly increasing up the stack so only the top partition can be heapsorted on any pass through.\n",
        "createdAt" : "2016-07-27T19:35:36Z",
        "updatedAt" : "2016-07-29T19:42:35Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "8be169de-f8a3-4c14-a5de-e538880a0fe9",
        "parentId" : "20e155aa-51b7-4aa4-ac78-d414c53360db",
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "I feel the opposite, I have to think about your code is doing while the goto is comes natural to me, but that might be from my close to the machine code perspective where a function return is a jump to the stack pop.\n",
        "createdAt" : "2016-07-27T19:38:15Z",
        "updatedAt" : "2016-07-29T19:42:35Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      },
      {
        "id" : "c1207f52-66ae-4eed-a0d0-203e7b7041b0",
        "parentId" : "20e155aa-51b7-4aa4-ac78-d414c53360db",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Yeah, the goto goes back instead of up. I don't think either is crystalline clear, having the stack the way we do breaks the obviousness of the doubly recursive pseudo code. Even pushing the largest partition is a bit subtle.\n",
        "createdAt" : "2016-07-27T19:42:10Z",
        "updatedAt" : "2016-07-29T19:42:35Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "afc4f2419a66ee659e0f71f2891573ef612ddd30",
    "line" : 84,
    "diffHunk" : "@@ -1,1 +154,158 @@        pr = *(--sptr);\n        pl = *(--sptr);\n        cdepth = *(--psdepth);\n    }\n"
  },
  {
    "id" : "285e8de5-66da-4d75-9a7c-8e45ea810825",
    "prId" : 7871,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "760601fd-ef97-4841-937e-e38b2ad0e355",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Well, this is large by a factor of 2, but it certainly doesn't hurt.\n",
        "createdAt" : "2016-07-29T23:03:58Z",
        "updatedAt" : "2016-07-29T23:03:58Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "afc4f2419a66ee659e0f71f2891573ef612ddd30",
    "line" : 62,
    "diffHunk" : "@@ -1,1 +95,99 @@    @type@ **sptr = stack;\n    @type@ *pm, *pi, *pj, *pk;\n    int depth[PYA_QS_STACK];\n    int * psdepth = depth;\n    int cdepth = npy_get_msb(num) * 2;"
  }
]
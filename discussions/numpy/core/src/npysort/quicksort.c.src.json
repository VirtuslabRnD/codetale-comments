[
  {
    "id" : "cb5cfce5-4aff-4a46-b44d-7222c2b09291",
    "prId" : 5494,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bae44b47-ac2a-4881-beba-c851ba462bad",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "I forget. Is this a `cmp` or a `rich_compare`?\n",
        "createdAt" : "2015-02-23T01:50:48Z",
        "updatedAt" : "2015-02-24T05:32:36Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "6a27c567-889f-4632-8dd3-e571554a6dae",
        "parentId" : "bae44b47-ac2a-4881-beba-c851ba462bad",
        "authorId" : "34105ae0-9fd2-4403-be9b-7c550a729828",
        "body" : "For object types, in Python3 it is implemented with two calls to `PyObject_RichCompareBool`, but unless an error is raised it behaves like a compare establishing an ordering. The source is [here](https://github.com/numpy/numpy/blob/maintenance/1.9.x/numpy/core/src/multiarray/arraytypes.c.src#L2590). If an error is raised I think it mistakenly thinks both items compared equal, but the error is caught an raised in `_new_argsortlike`.\n",
        "createdAt" : "2015-02-24T05:20:22Z",
        "updatedAt" : "2015-02-24T05:32:36Z",
        "lastEditedBy" : "34105ae0-9fd2-4403-be9b-7c550a729828",
        "tags" : [
        ]
      }
    ],
    "commit" : "a0aaf752c75c310d4eeae1af1064ec8046e6d5e9",
    "line" : 10,
    "diffHunk" : "@@ -1,1 +368,372 @@{\n    npy_intp elsize = PyArray_ITEMSIZE(arr);\n    PyArray_CompareFunc *cmp = PyArray_DESCR(arr)->f->compare;\n    char *vp;\n    npy_intp *pl = tosort;"
  }
]
[
  {
    "id" : "c799b2bd-a717-4c1b-950e-9b7362a687df",
    "prId" : 359,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "cb270be6-baf9-4f36-b28e-051246dd634b",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Success of memory allocation needs to be checked.\n",
        "createdAt" : "2013-04-01T18:13:58Z",
        "updatedAt" : "2013-05-10T16:48:13Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "1b70fbd7-b1d9-446c-a0ce-830f848f963d",
        "parentId" : "cb270be6-baf9-4f36-b28e-051246dd634b",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Still needs the NULL check. I there an error return available here?\n",
        "createdAt" : "2013-05-03T23:27:39Z",
        "updatedAt" : "2013-05-10T16:48:13Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "c3d71b11-b9f1-4bcd-973d-68f043d1e392",
        "parentId" : "cb270be6-baf9-4f36-b28e-051246dd634b",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Still missing check for allocation success.\n",
        "createdAt" : "2013-05-09T16:17:49Z",
        "updatedAt" : "2013-05-10T16:48:13Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "759d0632-95de-4fa6-a46f-e1ece3b6336e",
        "parentId" : "cb270be6-baf9-4f36-b28e-051246dd634b",
        "authorId" : "b0e7e584-a9be-4737-9003-4922807a34eb",
        "body" : "Somehow I missed these comments before. The op_flags allocation has a matching PyArray_free in the ufunc_dealloc function, but I do need one a few lines down if _parse_signature fails.\n",
        "createdAt" : "2013-05-09T16:33:44Z",
        "updatedAt" : "2013-05-10T16:48:13Z",
        "lastEditedBy" : "b0e7e584-a9be-4737-9003-4922807a34eb",
        "tags" : [
        ]
      },
      {
        "id" : "9a2a0869-63ce-4b5c-952c-9e808fcc81b3",
        "parentId" : "cb270be6-baf9-4f36-b28e-051246dd634b",
        "authorId" : "b0e7e584-a9be-4737-9003-4922807a34eb",
        "body" : "Nevermind, the op_flags will still be freed because ufunc_dealloc gets called if _parse_signature fails.\n",
        "createdAt" : "2013-05-09T16:53:50Z",
        "updatedAt" : "2013-05-10T16:48:13Z",
        "lastEditedBy" : "b0e7e584-a9be-4737-9003-4922807a34eb",
        "tags" : [
        ]
      }
    ],
    "commit" : "ec23d01d9c333f95db5d9349354766b38d37cae7",
    "line" : 172,
    "diffHunk" : "@@ -1,1 +4290,4294 @@    ufunc->doc = doc;\n\n    ufunc->op_flags = PyArray_malloc(sizeof(npy_uint32)*ufunc->nargs);\n    if (ufunc->op_flags == NULL) {\n        return PyErr_NoMemory();"
  },
  {
    "id" : "28bdc6a1-2a36-44a8-9261-9825c8fefd2a",
    "prId" : 359,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8baf09a8-c90d-4b4f-9f6a-a0a66a92286f",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "@seberg ISTR you may have done something relevant to this.\n",
        "createdAt" : "2013-05-09T16:16:30Z",
        "updatedAt" : "2013-05-10T16:48:13Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "9d08e0a6-58d6-4d86-a102-344824dd24c0",
        "parentId" : "8baf09a8-c90d-4b4f-9f6a-a0a66a92286f",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Yeah, my guess is, it can probably be removed. But would have to try too...\n",
        "createdAt" : "2013-05-09T17:00:59Z",
        "updatedAt" : "2013-05-10T16:48:13Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      }
    ],
    "commit" : "ec23d01d9c333f95db5d9349354766b38d37cae7",
    "line" : 144,
    "diffHunk" : "@@ -1,1 +2012,2016 @@     * If there are no iteration dimensions, create a fake one\n     * so that the scalar edge case works right.\n     */\n    if (iter_ndim == 0) {\n        iter_ndim = 1;"
  },
  {
    "id" : "2597e65f-4d90-42b0-8fde-953ba42b6dbc",
    "prId" : 462,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f20bd469-46ab-4df7-92d0-050c927d4943",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Allocation success needs a check.\n",
        "createdAt" : "2013-05-10T20:30:40Z",
        "updatedAt" : "2013-05-15T00:39:24Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "d85f7aa465cf854e2be83f67f39f058660348487",
    "line" : 132,
    "diffHunk" : "@@ -1,1 +4462,4466 @@    }\n\n    arg_typenums = PyArray_malloc(ufunc->nargs * sizeof(int));\n    if (arg_typenums == NULL) {\n        PyErr_NoMemory();"
  },
  {
    "id" : "89b4c023-8e66-4dba-bd03-fb34c5dc8e9c",
    "prId" : 2821,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7e791a53-2b54-4e42-8dd7-b7eeaaafa023",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Need extra indent. The `\\` can be dropped, no?, next line should line up with this one.\n",
        "createdAt" : "2013-04-28T01:33:04Z",
        "updatedAt" : "2013-08-16T21:44:21Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "68ec8d52-5ef7-4b57-ad60-8b205eb83f2f",
        "parentId" : "7e791a53-2b54-4e42-8dd7-b7eeaaafa023",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Can you use the new iterator here with the itershape argument? You could move the buffering/casting for the op2_array also into that iterator then as well using the op_dtypes. That would mean that the \"dummy\" casting iterator only needs to handle the first operand. Probably should check how to replace that with a direct call to the casting functions, but to be honest I don't care too much about that right now and if we add subspace iteration optimizations the dummy iterator wouldn't be quite as dummy any more for those.\n",
        "createdAt" : "2013-05-27T14:25:31Z",
        "updatedAt" : "2013-08-16T21:44:21Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      }
    ],
    "commit" : "acef718f40a30188c1379c13cc49c920d9e7c303",
    "line" : 102,
    "diffHunk" : "@@ -1,1 +4948,4952 @@         */\n        if ((iter2 = (PyArrayIterObject *)\\\n             PyArray_BroadcastToShape((PyObject *)op2_array,\n                                        iter->dimensions, iter->nd))==NULL) {\n            goto fail;"
  },
  {
    "id" : "9a33e67e-5026-4e58-8b3a-0b43c64faefb",
    "prId" : 2821,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0efc491e-d7a4-4fb5-b789-a8fab644ff80",
        "parentId" : null,
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Question: What happens if we have an object array and we get an error during the ufunc call? Such as:\n\n```\na = np.array([1, 2], dtype=object)\nb = np.array(['a'])\nnp.add.at(a, [0], b)\n```\n\nWhen api is needed, the inner loop can return an error I think? I m not sure how this is handled in the ufunc machinery, but I suspect we may need to add some magic in that case.\n",
        "createdAt" : "2013-08-05T16:35:55Z",
        "updatedAt" : "2013-08-16T21:44:21Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "c33f6422-c601-4ec3-ac02-14c212e2d6e6",
        "parentId" : "0efc491e-d7a4-4fb5-b789-a8fab644ff80",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "I guess we can live with `object_array += something` leaving `object_array` in an inconsistent state upon an error? The same will be the case for `ufunc.at(object_array, indices, something)`. Just thought there was an API question here, but `+=` also just stops when the first error occured, so I think we can copy that behaviour, or does anyone disagree?\n",
        "createdAt" : "2013-08-05T16:53:34Z",
        "updatedAt" : "2013-08-16T21:44:21Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "7f9935ce-c505-483b-8eea-735eb30f1c4e",
        "parentId" : "0efc491e-d7a4-4fb5-b789-a8fab644ff80",
        "authorId" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "body" : "Yeah, that sounds right to me.\n\nOn Mon, Aug 5, 2013 at 5:53 PM, seberg notifications@github.com wrote:\n\n> In numpy/core/src/umath/ufunc_object.c:\n> \n> > -         \\* puts result in buffer.\n> > -         */\n> > -        do {\n> > -            innerloop(buffer_dataptr, count, stride, innerloopdata);\n> > -        } while (iternext(iter_buffer));\n> >   +\n> > -        PyArray_MapIterNext(iter);\n> > -        if (iter2 != NULL) {\n> > -            PyArray_ITER_NEXT(iter2);\n> > -        }\n> >   +\n> > -        i--;\n> > -    }\n> >   +\n> > -    if (!needs_api) {\n> > -        NPY_END_THREADS;\n> \n> I guess we can live with object_array += something leaving object_arrayin an inconsistent state upon an error? The same will be the case for\n> ufunc.at(object_array, indices, something). Just thought there was an API\n> question here, but += also just stops when the first error occured, so I\n> think we can copy that behaviour, or does anyone disagree?\n> \n> —\n> Reply to this email directly or view it on GitHubhttps://github.com/numpy/numpy/pull/2821/files#r5583608\n> .\n",
        "createdAt" : "2013-08-05T17:16:24Z",
        "updatedAt" : "2013-08-16T21:44:21Z",
        "lastEditedBy" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "tags" : [
        ]
      }
    ],
    "commit" : "acef718f40a30188c1379c13cc49c920d9e7c303",
    "line" : 279,
    "diffHunk" : "@@ -1,1 +5125,5129 @@\n    if (!needs_api) {\n        NPY_END_THREADS;\n    }\n   "
  },
  {
    "id" : "cb4dba58-67b9-443a-8b2b-042f42746d0d",
    "prId" : 2821,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "36c44788-3026-433f-b738-77ceb4551ac4",
        "parentId" : null,
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Hmm, I think the other ufuncs already stop during calculation instead of the end? Not sure if it matters, might need code duplication, to do it in the loop, but...\nCould you add a test for this too? Something like `np.add.at(np.array(['a', 1], dtype=object), [0, 1], 1)` gives and error (and maybe does not change the 1).\n",
        "createdAt" : "2013-08-09T15:41:53Z",
        "updatedAt" : "2013-08-16T21:44:21Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      }
    ],
    "commit" : "acef718f40a30188c1379c13cc49c920d9e7c303",
    "line" : 292,
    "diffHunk" : "@@ -1,1 +5138,5142 @@    Py_XDECREF(errobj);\n\n    if (needs_api && PyErr_Occurred()) {\n        return NULL;\n    }"
  },
  {
    "id" : "fd96b765-bf62-4953-bac0-ff6a1924b0f0",
    "prId" : 2953,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4889d817-1b58-4e7d-89b3-81dea1a05257",
        "parentId" : null,
        "authorId" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "body" : "Is this NpyIter's buggy behaviour with scalars striking again?\n",
        "createdAt" : "2013-01-31T19:29:22Z",
        "updatedAt" : "2013-01-31T19:29:22Z",
        "lastEditedBy" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "tags" : [
        ]
      }
    ],
    "commit" : "f2c81b485fa18e7ab918b470403c52751648dd3a",
    "line" : 212,
    "diffHunk" : "@@ -1,1 +1987,1991 @@            op_axes[i][0] = -1;\n        }\n    }\n\n    /* Create the iterator */"
  },
  {
    "id" : "c6b37a14-8101-45e4-b6c4-a1038904506f",
    "prId" : 5124,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "99eb72ff-99f7-4981-b19b-c375566bf629",
        "parentId" : null,
        "authorId" : "acce7360-5cef-46f0-ab05-4fb0ffdffe3a",
        "body" : "Oh wait, I misread the old code: it completely ignores `buf`. I assume that the new behavior is what was intended all along? @charris @mwiebe\n",
        "createdAt" : "2014-09-27T11:33:42Z",
        "updatedAt" : "2014-09-27T12:38:56Z",
        "lastEditedBy" : "acce7360-5cef-46f0-ab05-4fb0ffdffe3a",
        "tags" : [
        ]
      },
      {
        "id" : "1151f9bb-633e-4d48-9857-37156ebe8298",
        "parentId" : "99eb72ff-99f7-4981-b19b-c375566bf629",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Yeah, looks like `signature` was a bug. BTW, I'm seldom responsible for a lot of code that `git blame` assigns to me, as I only show up because I made extensive style fixes throughout the code. The downside of style fixes is the loss of history.\n",
        "createdAt" : "2014-09-30T01:37:18Z",
        "updatedAt" : "2014-09-30T01:37:18Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "bfc4bf4421a84eec6e17ddf09a3d2beacf4ea4b7",
    "line" : 16,
    "diffHunk" : "@@ -1,1 +746,750 @@        PyErr_Format(PyExc_ValueError,\n                     \"%s at position %d in \\\"%s\\\"\",\n                     parse_error, i, signature);\n    }\n    return -1;"
  },
  {
    "id" : "14e9a72e-e1b3-4dab-8d78-732aea861917",
    "prId" : 5621,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d05da67d-2e16-4230-8551-de8f769a1bb1",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Might want to scatter a `\\n` or two in the message.\n",
        "createdAt" : "2015-03-08T00:30:21Z",
        "updatedAt" : "2015-03-08T16:00:18Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "bb3ae05f773e1997b4e95655cf1795cb7c8f904b",
    "line" : 174,
    "diffHunk" : "@@ -1,1 +1022,1026 @@                             */\n                            if (PyArray_Check(value) || value == Py_None) {\n                                if (DEPRECATE(\"passing a single array to the \"\n                                              \"'out' keyword argument of a \"\n                                              \"ufunc with\\n\""
  },
  {
    "id" : "4aec1e94-62e9-4125-8b67-911b0b311063",
    "prId" : 7198,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f3b35743-fe30-4781-80a1-93b4b3dacbc1",
        "parentId" : null,
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Actually I am not sure how reliable this is, but don't have a quick better idea either. With all those inner core dimensions, I guess the iterator size could be vastly overestimated possibly (I am not sure).\n",
        "createdAt" : "2016-02-05T21:53:42Z",
        "updatedAt" : "2016-03-17T12:15:12Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "a8a61618-e659-4b30-8d35-b57ac11103f4",
        "parentId" : "f3b35743-fe30-4781-80a1-93b4b3dacbc1",
        "authorId" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "body" : "Can an ssize_t actually meaningfully overflow here? ssize_t = intp, right? So how do you address an array that's bigger then ssize_t can represent?\n",
        "createdAt" : "2016-02-05T23:18:34Z",
        "updatedAt" : "2016-03-17T12:15:12Z",
        "lastEditedBy" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "tags" : [
        ]
      },
      {
        "id" : "3283011e-8832-4b28-9887-cd4aab415fb5",
        "parentId" : "f3b35743-fe30-4781-80a1-93b4b3dacbc1",
        "authorId" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "body" : "Otherwise looks good to me.\n.\nObligatory comment in passing that the code duplication between ufuncs and\ngufuncs sucks.\n\nOn Fri, Feb 5, 2016 at 1:53 PM, seberg notifications@github.com wrote:\n\n> In numpy/core/src/umath/ufunc_object.c\n> https://github.com/numpy/numpy/pull/7198#discussion_r52077858:\n> \n> > @@ -2343,6 +2344,16 @@ PyUFunc_GeneralizedFunction(PyUFuncObject *ufunc,\n> >          }\n> >      }\n> > -    total_problem_size = NpyIter_GetIterSize(iter);\n> > -    if (total_problem_size < 0) {\n> \n> Actually I am not sure how reliable this is, but don't have a quick better\n> idea either. With all those inner core dimensions, I guess the iterator\n> size could be vastly overestimated possibly (I am not sure).\n> \n> —\n> Reply to this email directly or view it on GitHub\n> https://github.com/numpy/numpy/pull/7198/files#r52077858.\n\n## \n\nNathaniel J. Smith -- https://vorpus.org http://vorpus.org\n",
        "createdAt" : "2016-02-05T23:19:20Z",
        "updatedAt" : "2016-03-17T12:15:12Z",
        "lastEditedBy" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "tags" : [
        ]
      },
      {
        "id" : "45601c3d-092c-4e9e-a4d0-a033c8abed70",
        "parentId" : "f3b35743-fe30-4781-80a1-93b4b3dacbc1",
        "authorId" : "34105ae0-9fd2-4403-be9b-7c550a729828",
        "body" : "The array isn't bigger, just the intermediate representation of the iterator before removing some axes. E.g. a call to `numpy.core.umath_tests.inner1d`, which has signature '(i),(i)->()', with two arrays of shapes `(a, 1, c)` and `(1, b, c)` will create an iterator with shape `(a, b, c, c)` before removing the last two dimensions. So with slightly more complicated gufuncs it is a meaningful possibility.\n",
        "createdAt" : "2016-02-06T06:10:13Z",
        "updatedAt" : "2016-03-17T12:15:12Z",
        "lastEditedBy" : "34105ae0-9fd2-4403-be9b-7c550a729828",
        "tags" : [
        ]
      },
      {
        "id" : "10b2209b-d792-42ed-bd84-d2603cbcabb8",
        "parentId" : "f3b35743-fe30-4781-80a1-93b4b3dacbc1",
        "authorId" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "body" : "Eh, I guess. Does the iterator actually handle such cases? Should we care when by the time we're dealing with such numbers we're just as likely to roll back around to positive? I guess it doesn't really matter too much whatever we do here...\n",
        "createdAt" : "2016-02-06T06:27:56Z",
        "updatedAt" : "2016-03-17T12:15:12Z",
        "lastEditedBy" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "tags" : [
        ]
      },
      {
        "id" : "9890166c-8eeb-466c-95fb-ed5be0575d42",
        "parentId" : "f3b35743-fe30-4781-80a1-93b4b3dacbc1",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "If it would not care explicitly, it should error out. So it sets it to \n-1 and errors out unless you remove that stuff again. I added that\nweird feature explicitly for these gufuncs that bloat the iterator.\n",
        "createdAt" : "2016-02-06T07:23:41Z",
        "updatedAt" : "2016-03-17T12:15:12Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      }
    ],
    "commit" : "19655d1d80f299bd76982d485b74aa8b4b0018d6",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +2349,2353 @@\n    total_problem_size = NpyIter_GetIterSize(iter);\n    if (total_problem_size < 0) {\n        /*\n         * Only used for threading, if negative (this means that it is"
  },
  {
    "id" : "bffcebb9-3f8e-4fad-9ffd-a8559aa27e41",
    "prId" : 7373,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2f53fade-658b-4070-9fc2-9483bade78d7",
        "parentId" : null,
        "authorId" : "0d70c244-f732-4a44-9ae8-c3f6de7e9b40",
        "body" : "Why are these values not the same as the ones returned by `assign_reduce_identity_*()`? Specifically, `assign_reduce_identity_minusone()` uses `PyLong_FromLong()` instead of `PyInt_FromLong()`. It looks like one is a macro for the other in Py3, but is that the case in Py2 as well?\n",
        "createdAt" : "2016-03-03T05:02:30Z",
        "updatedAt" : "2016-03-04T02:36:59Z",
        "lastEditedBy" : "0d70c244-f732-4a44-9ae8-c3f6de7e9b40",
        "tags" : [
        ]
      },
      {
        "id" : "d0340563-05f8-4f0b-9892-aa557922437a",
        "parentId" : "2f53fade-658b-4070-9fc2-9483bade78d7",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "They don't matter ;) `ufunc_get_identity` is a getter function for a property of the ufunc object and is only there to make the number visible to python users.\n",
        "createdAt" : "2016-03-03T06:12:41Z",
        "updatedAt" : "2016-03-04T02:36:59Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "13925bf5-2d43-4846-a013-519c130e9c6f",
        "parentId" : "2f53fade-658b-4070-9fc2-9483bade78d7",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "`assign_reduce_identity_minusone()` is used to produce a number that I want passed to `PyLong_AsLongLong` in `PyArray_FillWithScalars` so that the maximum number of bits are produced. Might could use something smaller, maybe not, but why gamble?\n",
        "createdAt" : "2016-03-03T06:17:28Z",
        "updatedAt" : "2016-03-04T02:36:59Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "0936775a-1403-438a-8e34-3aaac5a8edf7",
        "parentId" : "2f53fade-658b-4070-9fc2-9483bade78d7",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "I think the only thing that might matter (not even sure about that) is, whether we want to return -1 or -1L in the object corner cases of empty reductions on python 2. But either way is good in any case, Python makes no real difference between the two (and will silently convert easily).\n",
        "createdAt" : "2016-03-03T15:25:36Z",
        "updatedAt" : "2016-03-04T02:36:59Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      }
    ],
    "commit" : "9653c05a53327332a481cd697708ae9b6360fbf0",
    "line" : 63,
    "diffHunk" : "@@ -1,1 +5604,5608 @@    case PyUFunc_Zero:\n        return PyInt_FromLong(0);\n    case PyUFunc_MinusOne:\n        return PyInt_FromLong(-1);\n    }"
  },
  {
    "id" : "4c902016-e6cc-4858-8357-aecafe687327",
    "prId" : 8043,
    "prUrl" : "https://github.com/numpy/numpy/pull/8043#pullrequestreview-17566404",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "81270d24-ee98-486f-858c-ea5c115fa096",
        "parentId" : null,
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "why is this line added? a bug in the old code or due to the other changes?",
        "createdAt" : "2017-01-12T13:20:51Z",
        "updatedAt" : "2017-02-10T19:53:34Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      },
      {
        "id" : "35f348c0-d46a-45d3-b496-9a42cafba6d1",
        "parentId" : "81270d24-ee98-486f-858c-ea5c115fa096",
        "authorId" : "48d7d71b-9655-46b2-9a18-7c1fba7837d0",
        "body" : "I think it's a noop. Not necessary to add.",
        "createdAt" : "2017-01-12T19:12:42Z",
        "updatedAt" : "2017-02-10T19:53:34Z",
        "lastEditedBy" : "48d7d71b-9655-46b2-9a18-7c1fba7837d0",
        "tags" : [
        ]
      },
      {
        "id" : "626a1992-61ea-4855-8068-67dd6785fd18",
        "parentId" : "81270d24-ee98-486f-858c-ea5c115fa096",
        "authorId" : "48d7d71b-9655-46b2-9a18-7c1fba7837d0",
        "body" : "On second thought, I think it's useful to have here to ensure correctness, if we later on change NPY_ITER_COPY_IF_OVERLAP to make copies of also the input arrays.",
        "createdAt" : "2017-01-19T21:50:35Z",
        "updatedAt" : "2017-02-10T19:53:34Z",
        "lastEditedBy" : "48d7d71b-9655-46b2-9a18-7c1fba7837d0",
        "tags" : [
        ]
      }
    ],
    "commit" : "8e8ce442e8449916a93951093cdce16cec006bcc",
    "line" : 322,
    "diffHunk" : "@@ -1,1 +3691,3695 @@        op[0] = NpyIter_GetOperandArray(iter)[0];\n        op[1] = NpyIter_GetOperandArray(iter)[1];\n        op[2] = NpyIter_GetOperandArray(iter)[2];\n\n        if (out == NULL) {"
  },
  {
    "id" : "ff8bd499-4ffb-4f3d-aa54-068bd73b242a",
    "prId" : 8662,
    "prUrl" : "https://github.com/numpy/numpy/pull/8662#pullrequestreview-228732264",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4a1796ae-40c7-41af-b154-c068cc8444af",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Missing null check after this runs",
        "createdAt" : "2019-04-19T15:36:47Z",
        "updatedAt" : "2019-04-19T15:36:48Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "e043bb98e537742f71cc3a6a54d7be171044fd98",
    "line" : 18,
    "diffHunk" : "@@ -1,1 +5435,5439 @@        \"numpy\",\n        \"matrix\",\n        &_numpy_matrix);\n\n    if (PyObject_IsInstance(tmp, _numpy_matrix)) {"
  },
  {
    "id" : "ecbe7055-d3d8-4533-81a7-6629fad4e1a5",
    "prId" : 8819,
    "prUrl" : "https://github.com/numpy/numpy/pull/8819#pullrequestreview-99833070",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b3a8148f-4cd5-4837-af8f-eaa17b88d639",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Is there a reason we're not using PyArg_ParseTupleAndKeywords here? Out of scope for this PR, but still\r\n",
        "createdAt" : "2017-03-23T21:35:58Z",
        "updatedAt" : "2018-02-28T01:03:35Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "50831a4f-e954-4eba-83ef-ba4ef2ee6b21",
        "parentId" : "b3a8148f-4cd5-4837-af8f-eaa17b88d639",
        "authorId" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "body" : "Probably speed – I haven't checked if this particular case makes a meaningful difference, but the ufunc call path is a place where microseconds count.",
        "createdAt" : "2017-03-23T22:34:30Z",
        "updatedAt" : "2018-02-28T01:03:35Z",
        "lastEditedBy" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "tags" : [
        ]
      },
      {
        "id" : "8f934ffa-8663-4028-99d6-454908767d80",
        "parentId" : "b3a8148f-4cd5-4837-af8f-eaa17b88d639",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Switch statements actually compile as hardwired binary search, so for small lists of possibilities the savings probably don't amount to much. I think the main virtues are compactness, clarity, and fall through, which can be used to select code entry points. The last is probably frowned upon by structured code fanatics...",
        "createdAt" : "2017-03-23T22:45:37Z",
        "updatedAt" : "2018-02-28T01:03:35Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "b44a02eb-c3ed-47d0-bc24-2025a8176b89",
        "parentId" : "b3a8148f-4cd5-4837-af8f-eaa17b88d639",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "If speed really matters here, then presumably we could save a little more with `strcmp(str+1, \"xis\")` on the following lines...\r\n\r\nEither way, I think this probably needs a comment explaining that we're avoiding PyArg_ParseTupleAndKeywords for speed reasons.",
        "createdAt" : "2017-03-23T23:53:08Z",
        "updatedAt" : "2018-02-28T01:03:35Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "a9ef7ad1-6921-4c38-820c-cf7e0123c7f5",
        "parentId" : "b3a8148f-4cd5-4837-af8f-eaa17b88d639",
        "authorId" : "a4f03a99-2e43-482b-a9bc-5a9e359abb03",
        "body" : "We didn't add the comment, but I'm not going to demand it before merging.",
        "createdAt" : "2018-02-27T16:47:06Z",
        "updatedAt" : "2018-02-28T01:03:35Z",
        "lastEditedBy" : "a4f03a99-2e43-482b-a9bc-5a9e359abb03",
        "tags" : [
        ]
      },
      {
        "id" : "ba7c5e28-8270-4429-9301-e49d4a6014fa",
        "parentId" : "b3a8148f-4cd5-4837-af8f-eaa17b88d639",
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "I think a comment on the structure is a bit out-of-scope of this PR (and I don't really know what the original reason was anyway...)",
        "createdAt" : "2018-02-27T19:58:31Z",
        "updatedAt" : "2018-02-28T01:03:35Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      }
    ],
    "commit" : "05a420af6504efa21f99f968b2c66de62c1668d7",
    "line" : 24,
    "diffHunk" : "@@ -1,1 +811,815 @@\n            switch (str[0]) {\n                case 'a':\n                    /* possible axis argument for generalized ufunc */\n                    if (out_axes != NULL && strcmp(str, \"axes\") == 0) {"
  },
  {
    "id" : "b76afdce-c713-4491-992e-db2fcbdda1e0",
    "prId" : 8819,
    "prUrl" : "https://github.com/numpy/numpy/pull/8819#pullrequestreview-86068542",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "cbee463e-5398-40bf-8261-e66ac8ebb0b6",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Can this be negative if the out argument is invalid? Is that checked before this function is called?",
        "createdAt" : "2018-01-01T20:05:59Z",
        "updatedAt" : "2018-02-28T01:03:35Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "353a01f6-4f0f-419d-8e94-d3241961e50b",
        "parentId" : "cbee463e-5398-40bf-8261-e66ac8ebb0b6",
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "Nice catch - this gets checked only in `_get_coredim_sizes`, which is called after (and needs the remap); I'll separate that check out and will add a test.",
        "createdAt" : "2018-01-01T20:09:56Z",
        "updatedAt" : "2018-02-28T01:03:35Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      },
      {
        "id" : "604bf23f-09d4-4cef-9bee-bc6c27cf0c12",
        "parentId" : "cbee463e-5398-40bf-8261-e66ac8ebb0b6",
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "BTW, happy new year!",
        "createdAt" : "2018-01-01T20:10:07Z",
        "updatedAt" : "2018-02-28T01:03:35Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      }
    ],
    "commit" : "05a420af6504efa21f99f968b2c66de62c1668d7",
    "line" : 106,
    "diffHunk" : "@@ -1,1 +1832,1836 @@        if (op[iop] != NULL) {\n            op_ndim = PyArray_NDIM(op[iop]);\n            op_nbroadcast = op_ndim - op_ncore;\n        }\n        else {"
  },
  {
    "id" : "746d4389-3b07-4d7b-ba8f-39343754ebef",
    "prId" : 8819,
    "prUrl" : "https://github.com/numpy/numpy/pull/8819#pullrequestreview-99914965",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a475cd51-889c-4bfc-940f-a4d7a16c7ae7",
        "parentId" : null,
        "authorId" : "a4f03a99-2e43-482b-a9bc-5a9e359abb03",
        "body" : "It would be nice to avoid mallocs. In principle we could replace `nop` by `NPY_MAXARGS` and allocate on the stack, but that would be `32*32` ints, or 8kb (4kb on 32bit), which seems a little large to put on the stack. But I see other places in numpy we have already done this, eg a grep shows:\r\n```\r\nnumpy/core/src/umath/ufunc_object.c:2061:    int op_axes_arrays[NPY_MAXARGS][NPY_MAXDIMS];\r\nnumpy/core/src/multiarray/nditer_pywrap.c:742:    int op_axes_arrays[NPY_MAXARGS][NPY_MAXDIMS];\r\nnumpy/core/src/multiarray/einsum.c.src:2610:    char op_labels[NPY_MAXARGS][NPY_MAXDIMS];\r\nnumpy/core/src/multiarray/einsum.c.src:2617:    int op_axes_arrays[NPY_MAXARGS][NPY_MAXDIMS];\r\n```\r\n\r\nI like the strategy in the 3rd line there to use a `char`, so it is only 1kb. I also like how those other examples use C's 2d static array syntax, instead of allocating a separate index array.\r\n\r\nIn summary, I actually think it would be a significant improvement to allocate `remap_axis_memory` as a static 2d char array.",
        "createdAt" : "2018-02-27T17:18:30Z",
        "updatedAt" : "2018-02-28T01:03:35Z",
        "lastEditedBy" : "a4f03a99-2e43-482b-a9bc-5a9e359abb03",
        "tags" : [
        ]
      },
      {
        "id" : "c88bfe20-9bf1-494f-8e5b-ac13dcc5e97a",
        "parentId" : "a475cd51-889c-4bfc-940f-a4d7a16c7ae7",
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "I had that originally, but thought that it was a waste of memory for what should normally be a rare use case. A yet more complicated alternative would be to allocate a, say, 3x3 2-D array and not use it is there are more arguments. (note that the `char` is for op_labels, which are in fact characters.)",
        "createdAt" : "2018-02-27T17:23:09Z",
        "updatedAt" : "2018-02-28T01:03:35Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      },
      {
        "id" : "abb84992-c097-4762-b710-2e1c752a52a8",
        "parentId" : "a475cd51-889c-4bfc-940f-a4d7a16c7ae7",
        "authorId" : "a4f03a99-2e43-482b-a9bc-5a9e359abb03",
        "body" : "There are a few ways to tidy this along those lines. \r\n\r\nPerhaps do this: Get rid of `remap_axis` and only have  `char remap_axis_memory[NPY_MAXARGS][NPY_MAXDIMS];` Then redefine `#define REMAP_AXIS(iop, axis) ((axes ? remap_axis_memory[iop][axis] : axis)`",
        "createdAt" : "2018-02-27T17:41:23Z",
        "updatedAt" : "2018-02-28T01:03:35Z",
        "lastEditedBy" : "a4f03a99-2e43-482b-a9bc-5a9e359abb03",
        "tags" : [
        ]
      },
      {
        "id" : "9b8f99a1-eac6-4d19-84e2-ef5bbab45efb",
        "parentId" : "a475cd51-889c-4bfc-940f-a4d7a16c7ae7",
        "authorId" : "a4f03a99-2e43-482b-a9bc-5a9e359abb03",
        "body" : "Oh sorry, I didn't see your comment.  Yeah it is debatable.\r\n\r\nI guess if you already investigated both options, I am happy to go with whichever you thin kis better.",
        "createdAt" : "2018-02-27T17:45:16Z",
        "updatedAt" : "2018-02-28T01:03:35Z",
        "lastEditedBy" : "a4f03a99-2e43-482b-a9bc-5a9e359abb03",
        "tags" : [
        ]
      },
      {
        "id" : "b709968f-827a-4a93-ae8f-9383d2925f1e",
        "parentId" : "a475cd51-889c-4bfc-940f-a4d7a16c7ae7",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Any reason not to combine these into one allocation?",
        "createdAt" : "2018-02-27T18:17:36Z",
        "updatedAt" : "2018-02-28T01:03:35Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "817d5d32-7585-4ff4-9531-3d178aa4e96f",
        "parentId" : "a475cd51-889c-4bfc-940f-a4d7a16c7ae7",
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "`remap_axis` is of pointers, `remap_axis_memory` of `int`, so in principle they can have different stride size, correct?",
        "createdAt" : "2018-02-27T19:52:20Z",
        "updatedAt" : "2018-02-28T01:03:35Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      },
      {
        "id" : "f88eef95-e9f6-43f3-8c61-516fd04340ee",
        "parentId" : "a475cd51-889c-4bfc-940f-a4d7a16c7ae7",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Stride size isn't relevant if you're allocating a `void*`. I suppose alignment could be an issue?",
        "createdAt" : "2018-02-27T21:48:18Z",
        "updatedAt" : "2018-02-28T01:03:35Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "fed75379-4236-4809-9c6c-0cdcbeae1d6e",
        "parentId" : "a475cd51-889c-4bfc-940f-a4d7a16c7ae7",
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "In the end, I think this is an implementation detail - the present code is at least somewhat clear, so maybe best to leave it for later.",
        "createdAt" : "2018-02-28T01:07:39Z",
        "updatedAt" : "2018-02-28T01:07:39Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      }
    ],
    "commit" : "05a420af6504efa21f99f968b2c66de62c1668d7",
    "line" : 301,
    "diffHunk" : "@@ -1,1 +2202,2206 @@        remap_axis = PyArray_malloc(sizeof(remap_axis[0]) * nop);\n        remap_axis_memory = PyArray_malloc(sizeof(remap_axis_memory[0]) *\n                                                  nop * NPY_MAXDIMS);\n        if (remap_axis == NULL || remap_axis_memory == NULL) {\n            PyErr_NoMemory();"
  },
  {
    "id" : "566f9b90-6874-4f47-a810-89da0d84f8af",
    "prId" : 8876,
    "prUrl" : "https://github.com/numpy/numpy/pull/8876#pullrequestreview-30097611",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "473374b0-e8d0-45b2-9453-9a0a951b6e62",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Almost all of this function, and its doc-comment, are a direct move of the code from before, with the exception that:\r\n* `goto fail` is just `return -1`\r\n* some fields need re-extracting from ufunc\r\n* `ufunc_name` is recalculated when needed - only in errors, so performance is irrelevant",
        "createdAt" : "2017-03-30T20:02:07Z",
        "updatedAt" : "2017-04-06T10:22:21Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "19ae9fb4f03d0d8379c64bbd5589dad961436044",
    "line" : 57,
    "diffHunk" : "@@ -1,1 +2003,2007 @@ */\nstatic int\n_get_coredim_sizes(PyUFuncObject *ufunc, PyArrayObject **op,\n                   npy_intp* core_dim_sizes) {\n    int i;"
  },
  {
    "id" : "f12242ff-2159-4f42-877f-7c605e50ca0a",
    "prId" : 8876,
    "prUrl" : "https://github.com/numpy/numpy/pull/8876#pullrequestreview-31274207",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "04512a00-3c2a-40fe-8fc2-6dfb856fb3d6",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Starting at 0 makes more sense, because our function works by assigning to it until its not zero",
        "createdAt" : "2017-03-30T20:03:18Z",
        "updatedAt" : "2017-04-06T10:22:21Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "23d35b72-843f-4b05-8885-e990bdaf8aed",
        "parentId" : "04512a00-3c2a-40fe-8fc2-6dfb856fb3d6",
        "authorId" : "34105ae0-9fd2-4403-be9b-7c550a729828",
        "body" : "It's always overwritten, so the value assigned here is irrelevant, right? ",
        "createdAt" : "2017-03-31T21:03:31Z",
        "updatedAt" : "2017-04-06T10:22:21Z",
        "lastEditedBy" : "34105ae0-9fd2-4403-be9b-7c550a729828",
        "tags" : [
        ]
      },
      {
        "id" : "20ed03a0-97a8-41bd-9809-18790ac03043",
        "parentId" : "04512a00-3c2a-40fe-8fc2-6dfb856fb3d6",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "True, but this the correct base case if we end up with a code path that never sets `retval`, so seems like a good thing to keep",
        "createdAt" : "2017-04-06T10:17:45Z",
        "updatedAt" : "2017-04-06T10:22:21Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "19ae9fb4f03d0d8379c64bbd5589dad961436044",
    "line" : 161,
    "diffHunk" : "@@ -1,1 +2108,2112 @@    int i, j, idim, nop;\n    const char *ufunc_name;\n    int retval = 0, subok = 1;\n    int needs_api = 0;\n"
  },
  {
    "id" : "aee2e4d1-b40d-4e1d-a342-46e98cb72008",
    "prId" : 8952,
    "prUrl" : "https://github.com/numpy/numpy/pull/8952#pullrequestreview-32952165",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5b610de8-48bb-4944-a69f-1d75d526d43c",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "This used to be `True` when used internally, and `1` when viewed externally.\r\n\r\nThe upshot is that this fixes #8860.\r\n\r\nIdeally, we'd use `True` for functions like `logical_or`, and `1` for functions like `add`",
        "createdAt" : "2017-04-16T21:56:13Z",
        "updatedAt" : "2017-10-03T07:22:41Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "31fd25debbbabb292c5dc06f1c7418c5dfd97ff7",
    "line" : 31,
    "diffHunk" : "@@ -1,1 +1848,1852 @@    case PyUFunc_One:\n        *reorderable = 1;\n        return PyInt_FromLong(1);\n\n    case PyUFunc_Zero:"
  },
  {
    "id" : "e55c9689-fb9d-40e0-ac45-bf2fbd5b6179",
    "prId" : 8952,
    "prUrl" : "https://github.com/numpy/numpy/pull/8952#pullrequestreview-32952165",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d61b9745-46e4-447b-9e6c-40dd0ffc56e3",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Previously, we cached these values in a static variable. Is this something we should keep doing?",
        "createdAt" : "2017-04-16T21:56:29Z",
        "updatedAt" : "2017-10-03T07:22:41Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "31fd25debbbabb292c5dc06f1c7418c5dfd97ff7",
    "line" : 39,
    "diffHunk" : "@@ -1,1 +1856,1860 @@    case PyUFunc_MinusOne:\n        *reorderable = 1;\n        return PyInt_FromLong(-1);\n\n    case PyUFunc_ReorderableNone:"
  },
  {
    "id" : "304d8bfe-2cdf-492b-82fe-1cfae964b52c",
    "prId" : 8952,
    "prUrl" : "https://github.com/numpy/numpy/pull/8952#pullrequestreview-32952165",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e47cd77b-9a23-4b01-82cc-d934c09913ff",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "`assign_identity` was never anything but this operation",
        "createdAt" : "2017-04-16T21:58:03Z",
        "updatedAt" : "2017-10-03T07:22:41Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "31fd25debbbabb292c5dc06f1c7418c5dfd97ff7",
    "line" : 104,
    "diffHunk" : "@@ -1,1 +2293,2297 @@                    goto fail;\n                }\n                PyArray_FillWithScalar(op[i], identity);\n            }\n        }"
  },
  {
    "id" : "b0c35dc2-25c0-4795-bb57-7ee83d522ce9",
    "prId" : 8952,
    "prUrl" : "https://github.com/numpy/numpy/pull/8952#pullrequestreview-32952165",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5bde853e-63e4-465a-aeea-ca99b6b66d27",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Moving this check to occur first makes cleanup a little easier.",
        "createdAt" : "2017-04-16T21:58:25Z",
        "updatedAt" : "2017-10-03T07:22:41Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "31fd25debbbabb292c5dc06f1c7418c5dfd97ff7",
    "line" : 208,
    "diffHunk" : "@@ -1,1 +2816,2820 @@    }\n\n    if (_get_bufsize_errmask(NULL, \"reduce\", &buffersize, &errormask) < 0) {\n        return NULL;\n    }"
  },
  {
    "id" : "ebd3fe31-ae92-416e-870a-7f9666172d43",
    "prId" : 8952,
    "prUrl" : "https://github.com/numpy/numpy/pull/8952#pullrequestreview-32952165",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b33ac195-721c-44ae-abc3-b776687b7104",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "I don't think this behaviour is justified, but this is a maintenance commit, so for now, we should leave it in",
        "createdAt" : "2017-04-16T21:58:55Z",
        "updatedAt" : "2017-10-03T07:22:41Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "31fd25debbbabb292c5dc06f1c7418c5dfd97ff7",
    "line" : 226,
    "diffHunk" : "@@ -1,1 +2833,2837 @@        identity = Py_None;\n        Py_INCREF(identity);\n    }\n\n    /* Get the reduction dtype */"
  },
  {
    "id" : "ae07f043-9b1c-4b64-b6ab-b2b46d002906",
    "prId" : 9022,
    "prUrl" : "https://github.com/numpy/numpy/pull/9022#pullrequestreview-127444630",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "da081749-54f0-4d55-a26f-e5ed302fbd7b",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "What about `wrap`?",
        "createdAt" : "2018-06-11T03:36:17Z",
        "updatedAt" : "2018-06-13T17:51:08Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "b7106ce7-4863-41f1-ab37-199fae37e47d",
        "parentId" : "da081749-54f0-4d55-a26f-e5ed302fbd7b",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Good catch, thanks",
        "createdAt" : "2018-06-11T06:25:18Z",
        "updatedAt" : "2018-06-13T17:51:08Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "e3b0a3f743cb215cf8a61e318687e9b54a8691a5",
    "line" : 129,
    "diffHunk" : "@@ -1,1 +422,426 @@                context->ufunc, args_tup, context->out_i);\n            Py_DECREF(args_tup);\n            if (py_context == NULL) {\n                goto fail;\n            }"
  },
  {
    "id" : "ed5a0215-84b4-4c62-a82a-eec8e342a22c",
    "prId" : 9022,
    "prUrl" : "https://github.com/numpy/numpy/pull/9022#pullrequestreview-127428277",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bbda39c3-242f-47d2-9d26-41af409676cf",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "What about `wrap`?",
        "createdAt" : "2018-06-11T03:36:48Z",
        "updatedAt" : "2018-06-13T17:51:08Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "e3b0a3f743cb215cf8a61e318687e9b54a8691a5",
    "line" : 123,
    "diffHunk" : "@@ -1,1 +416,420 @@            /* Call the method with appropriate context */\n            args_tup = _get_wrap_prepare_args(context->args);\n            if (args_tup == NULL) {\n                goto fail;\n            }"
  },
  {
    "id" : "d02e3b8c-cebd-4aea-89fb-2af65ec4d402",
    "prId" : 9022,
    "prUrl" : "https://github.com/numpy/numpy/pull/9022#pullrequestreview-128207446",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ccd68535-14f0-47ed-aa5a-34ea71a82e53",
        "parentId" : null,
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "I must admit I find this open context ugly too - I'm trained to think I must be within a special block.  I'd just move the `PyObject *wrap` to the top...",
        "createdAt" : "2018-06-13T01:26:36Z",
        "updatedAt" : "2018-06-13T17:51:08Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      },
      {
        "id" : "de44b827-d5a8-4a67-9fb9-317e36156a7b",
        "parentId" : "ccd68535-14f0-47ed-aa5a-34ea71a82e53",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "I put the comment before the block to make it clearer that there was no control structure missing. I think that the reduced number of local variable to keep track of is worth having a briefly misleading `{`. Also, when we adopt C99, cases like this can all be removed with a find and replace.",
        "createdAt" : "2018-06-13T02:13:21Z",
        "updatedAt" : "2018-06-13T17:51:08Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "e3b0a3f743cb215cf8a61e318687e9b54a8691a5",
    "line" : 182,
    "diffHunk" : "@@ -1,1 +4531,4535 @@\n    /* Wrap and return the output */\n    {\n        /* Find __array_wrap__ - note that these rules are different to the\n         * normal ufunc path"
  },
  {
    "id" : "64675de6-a111-4ab2-9b37-89e05347807a",
    "prId" : 9022,
    "prUrl" : "https://github.com/numpy/numpy/pull/9022#pullrequestreview-128207486",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "70def671-2d71-47fe-91c5-052b5c2aaab9",
        "parentId" : null,
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "Now I think I've made the comment, but perhaps forgot to submit: maybe just define `_ufunc_context context = {ufunc, full_args, i};`? Or is that incorrect syntax? (My C remains quite hopeless...)",
        "createdAt" : "2018-06-13T01:28:24Z",
        "updatedAt" : "2018-06-13T17:51:08Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      },
      {
        "id" : "8242acb6-2a6f-4658-bfc3-aa454be895c2",
        "parentId" : "70def671-2d71-47fe-91c5-052b5c2aaab9",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Sure, that seems reasonable - Definitely correct in some version of C, I think C90 will cope.",
        "createdAt" : "2018-06-13T02:13:42Z",
        "updatedAt" : "2018-06-13T17:51:08Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "e3b0a3f743cb215cf8a61e318687e9b54a8691a5",
    "line" : 310,
    "diffHunk" : "@@ -1,1 +4635,4639 @@        PyObject *wrapped;\n\n        context.ufunc = ufunc;\n        context.args = full_args;\n        context.out_i = i;"
  },
  {
    "id" : "84d74953-a632-44a9-a7a2-98cc7db98dde",
    "prId" : 9335,
    "prUrl" : "https://github.com/numpy/numpy/pull/9335#pullrequestreview-47530048",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bee321e6-2c82-48ae-874c-4e24be4f482b",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "What does `NPY_ITER_WRITEONLY` mean here? Just curious.",
        "createdAt" : "2017-06-30T20:12:10Z",
        "updatedAt" : "2017-06-30T20:12:11Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "e34baa2f-0e75-40ab-b735-66b96817b879",
        "parentId" : "bee321e6-2c82-48ae-874c-4e24be4f482b",
        "authorId" : "48d7d71b-9655-46b2-9a18-7c1fba7837d0",
        "body" : "I think it means the iterator is free to ignore data previously in the array vs. whether it needs to pre-fill buffers with old data. The iterator (correctly) considers READWRITE as an error if it's also asked to allocate the output array.",
        "createdAt" : "2017-07-01T13:03:37Z",
        "updatedAt" : "2017-07-01T13:15:17Z",
        "lastEditedBy" : "48d7d71b-9655-46b2-9a18-7c1fba7837d0",
        "tags" : [
        ]
      }
    ],
    "commit" : "df84fd8c1c7d8f014af3b15cdac3af4ded50ae36",
    "line" : 22,
    "diffHunk" : "@@ -1,1 +1791,1795 @@         */\n        op_flags[i] = default_op_out_flags |\n                      (op[i] != NULL ? NPY_ITER_READWRITE : NPY_ITER_WRITEONLY) |\n                      NPY_ITER_ALIGNED |\n                      NPY_ITER_ALLOCATE |"
  },
  {
    "id" : "95f9f7e7-10fb-4eed-a120-672cd183a2e2",
    "prId" : 9335,
    "prUrl" : "https://github.com/numpy/numpy/pull/9335#pullrequestreview-47530191",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d147259e-5d1d-4c87-b5ae-cf5388a73f89",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "I take it `op[i] == NULL` means it will be allocated by the iterator? ",
        "createdAt" : "2017-06-30T20:14:12Z",
        "updatedAt" : "2017-06-30T20:14:12Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "ffdc00ef-9256-41e4-a2db-9c45ce681165",
        "parentId" : "d147259e-5d1d-4c87-b5ae-cf5388a73f89",
        "authorId" : "48d7d71b-9655-46b2-9a18-7c1fba7837d0",
        "body" : "Yes, the output array is then not user-provided.",
        "createdAt" : "2017-07-01T13:15:39Z",
        "updatedAt" : "2017-07-01T13:15:39Z",
        "lastEditedBy" : "48d7d71b-9655-46b2-9a18-7c1fba7837d0",
        "tags" : [
        ]
      }
    ],
    "commit" : "df84fd8c1c7d8f014af3b15cdac3af4ded50ae36",
    "line" : 39,
    "diffHunk" : "@@ -1,1 +1839,1843 @@         * and returned to the caller, and this needs an extra incref.\n         */\n        if (op[i] == NULL) {\n            op_tmp = op_it[i];\n            Py_INCREF(op_tmp);"
  }
]
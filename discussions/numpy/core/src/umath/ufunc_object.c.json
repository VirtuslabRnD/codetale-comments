[
  {
    "id" : "c799b2bd-a717-4c1b-950e-9b7362a687df",
    "prId" : 359,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "cb270be6-baf9-4f36-b28e-051246dd634b",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Success of memory allocation needs to be checked.\n",
        "createdAt" : "2013-04-01T18:13:58Z",
        "updatedAt" : "2013-05-10T16:48:13Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "1b70fbd7-b1d9-446c-a0ce-830f848f963d",
        "parentId" : "cb270be6-baf9-4f36-b28e-051246dd634b",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Still needs the NULL check. I there an error return available here?\n",
        "createdAt" : "2013-05-03T23:27:39Z",
        "updatedAt" : "2013-05-10T16:48:13Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "c3d71b11-b9f1-4bcd-973d-68f043d1e392",
        "parentId" : "cb270be6-baf9-4f36-b28e-051246dd634b",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Still missing check for allocation success.\n",
        "createdAt" : "2013-05-09T16:17:49Z",
        "updatedAt" : "2013-05-10T16:48:13Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "759d0632-95de-4fa6-a46f-e1ece3b6336e",
        "parentId" : "cb270be6-baf9-4f36-b28e-051246dd634b",
        "authorId" : "b0e7e584-a9be-4737-9003-4922807a34eb",
        "body" : "Somehow I missed these comments before. The op_flags allocation has a matching PyArray_free in the ufunc_dealloc function, but I do need one a few lines down if _parse_signature fails.\n",
        "createdAt" : "2013-05-09T16:33:44Z",
        "updatedAt" : "2013-05-10T16:48:13Z",
        "lastEditedBy" : "b0e7e584-a9be-4737-9003-4922807a34eb",
        "tags" : [
        ]
      },
      {
        "id" : "9a2a0869-63ce-4b5c-952c-9e808fcc81b3",
        "parentId" : "cb270be6-baf9-4f36-b28e-051246dd634b",
        "authorId" : "b0e7e584-a9be-4737-9003-4922807a34eb",
        "body" : "Nevermind, the op_flags will still be freed because ufunc_dealloc gets called if _parse_signature fails.\n",
        "createdAt" : "2013-05-09T16:53:50Z",
        "updatedAt" : "2013-05-10T16:48:13Z",
        "lastEditedBy" : "b0e7e584-a9be-4737-9003-4922807a34eb",
        "tags" : [
        ]
      }
    ],
    "commit" : "ec23d01d9c333f95db5d9349354766b38d37cae7",
    "line" : 172,
    "diffHunk" : "@@ -1,1 +4290,4294 @@    ufunc->doc = doc;\n\n    ufunc->op_flags = PyArray_malloc(sizeof(npy_uint32)*ufunc->nargs);\n    if (ufunc->op_flags == NULL) {\n        return PyErr_NoMemory();"
  },
  {
    "id" : "28bdc6a1-2a36-44a8-9261-9825c8fefd2a",
    "prId" : 359,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8baf09a8-c90d-4b4f-9f6a-a0a66a92286f",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "@seberg ISTR you may have done something relevant to this.\n",
        "createdAt" : "2013-05-09T16:16:30Z",
        "updatedAt" : "2013-05-10T16:48:13Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "9d08e0a6-58d6-4d86-a102-344824dd24c0",
        "parentId" : "8baf09a8-c90d-4b4f-9f6a-a0a66a92286f",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Yeah, my guess is, it can probably be removed. But would have to try too...\n",
        "createdAt" : "2013-05-09T17:00:59Z",
        "updatedAt" : "2013-05-10T16:48:13Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      }
    ],
    "commit" : "ec23d01d9c333f95db5d9349354766b38d37cae7",
    "line" : 144,
    "diffHunk" : "@@ -1,1 +2012,2016 @@     * If there are no iteration dimensions, create a fake one\n     * so that the scalar edge case works right.\n     */\n    if (iter_ndim == 0) {\n        iter_ndim = 1;"
  },
  {
    "id" : "2597e65f-4d90-42b0-8fde-953ba42b6dbc",
    "prId" : 462,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f20bd469-46ab-4df7-92d0-050c927d4943",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Allocation success needs a check.\n",
        "createdAt" : "2013-05-10T20:30:40Z",
        "updatedAt" : "2013-05-15T00:39:24Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "d85f7aa465cf854e2be83f67f39f058660348487",
    "line" : 132,
    "diffHunk" : "@@ -1,1 +4462,4466 @@    }\n\n    arg_typenums = PyArray_malloc(ufunc->nargs * sizeof(int));\n    if (arg_typenums == NULL) {\n        PyErr_NoMemory();"
  },
  {
    "id" : "89b4c023-8e66-4dba-bd03-fb34c5dc8e9c",
    "prId" : 2821,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7e791a53-2b54-4e42-8dd7-b7eeaaafa023",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Need extra indent. The `\\` can be dropped, no?, next line should line up with this one.\n",
        "createdAt" : "2013-04-28T01:33:04Z",
        "updatedAt" : "2013-08-16T21:44:21Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "68ec8d52-5ef7-4b57-ad60-8b205eb83f2f",
        "parentId" : "7e791a53-2b54-4e42-8dd7-b7eeaaafa023",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Can you use the new iterator here with the itershape argument? You could move the buffering/casting for the op2_array also into that iterator then as well using the op_dtypes. That would mean that the \"dummy\" casting iterator only needs to handle the first operand. Probably should check how to replace that with a direct call to the casting functions, but to be honest I don't care too much about that right now and if we add subspace iteration optimizations the dummy iterator wouldn't be quite as dummy any more for those.\n",
        "createdAt" : "2013-05-27T14:25:31Z",
        "updatedAt" : "2013-08-16T21:44:21Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      }
    ],
    "commit" : "acef718f40a30188c1379c13cc49c920d9e7c303",
    "line" : 102,
    "diffHunk" : "@@ -1,1 +4948,4952 @@         */\n        if ((iter2 = (PyArrayIterObject *)\\\n             PyArray_BroadcastToShape((PyObject *)op2_array,\n                                        iter->dimensions, iter->nd))==NULL) {\n            goto fail;"
  },
  {
    "id" : "9a33e67e-5026-4e58-8b3a-0b43c64faefb",
    "prId" : 2821,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0efc491e-d7a4-4fb5-b789-a8fab644ff80",
        "parentId" : null,
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Question: What happens if we have an object array and we get an error during the ufunc call? Such as:\n\n```\na = np.array([1, 2], dtype=object)\nb = np.array(['a'])\nnp.add.at(a, [0], b)\n```\n\nWhen api is needed, the inner loop can return an error I think? I m not sure how this is handled in the ufunc machinery, but I suspect we may need to add some magic in that case.\n",
        "createdAt" : "2013-08-05T16:35:55Z",
        "updatedAt" : "2013-08-16T21:44:21Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "c33f6422-c601-4ec3-ac02-14c212e2d6e6",
        "parentId" : "0efc491e-d7a4-4fb5-b789-a8fab644ff80",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "I guess we can live with `object_array += something` leaving `object_array` in an inconsistent state upon an error? The same will be the case for `ufunc.at(object_array, indices, something)`. Just thought there was an API question here, but `+=` also just stops when the first error occured, so I think we can copy that behaviour, or does anyone disagree?\n",
        "createdAt" : "2013-08-05T16:53:34Z",
        "updatedAt" : "2013-08-16T21:44:21Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "7f9935ce-c505-483b-8eea-735eb30f1c4e",
        "parentId" : "0efc491e-d7a4-4fb5-b789-a8fab644ff80",
        "authorId" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "body" : "Yeah, that sounds right to me.\n\nOn Mon, Aug 5, 2013 at 5:53 PM, seberg notifications@github.com wrote:\n\n> In numpy/core/src/umath/ufunc_object.c:\n> \n> > -         \\* puts result in buffer.\n> > -         */\n> > -        do {\n> > -            innerloop(buffer_dataptr, count, stride, innerloopdata);\n> > -        } while (iternext(iter_buffer));\n> >   +\n> > -        PyArray_MapIterNext(iter);\n> > -        if (iter2 != NULL) {\n> > -            PyArray_ITER_NEXT(iter2);\n> > -        }\n> >   +\n> > -        i--;\n> > -    }\n> >   +\n> > -    if (!needs_api) {\n> > -        NPY_END_THREADS;\n> \n> I guess we can live with object_array += something leaving object_arrayin an inconsistent state upon an error? The same will be the case for\n> ufunc.at(object_array, indices, something). Just thought there was an API\n> question here, but += also just stops when the first error occured, so I\n> think we can copy that behaviour, or does anyone disagree?\n> \n> â€”\n> Reply to this email directly or view it on GitHubhttps://github.com/numpy/numpy/pull/2821/files#r5583608\n> .\n",
        "createdAt" : "2013-08-05T17:16:24Z",
        "updatedAt" : "2013-08-16T21:44:21Z",
        "lastEditedBy" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "tags" : [
        ]
      }
    ],
    "commit" : "acef718f40a30188c1379c13cc49c920d9e7c303",
    "line" : 279,
    "diffHunk" : "@@ -1,1 +5125,5129 @@\n    if (!needs_api) {\n        NPY_END_THREADS;\n    }\n   "
  },
  {
    "id" : "cb4dba58-67b9-443a-8b2b-042f42746d0d",
    "prId" : 2821,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "36c44788-3026-433f-b738-77ceb4551ac4",
        "parentId" : null,
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Hmm, I think the other ufuncs already stop during calculation instead of the end? Not sure if it matters, might need code duplication, to do it in the loop, but...\nCould you add a test for this too? Something like `np.add.at(np.array(['a', 1], dtype=object), [0, 1], 1)` gives and error (and maybe does not change the 1).\n",
        "createdAt" : "2013-08-09T15:41:53Z",
        "updatedAt" : "2013-08-16T21:44:21Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      }
    ],
    "commit" : "acef718f40a30188c1379c13cc49c920d9e7c303",
    "line" : 292,
    "diffHunk" : "@@ -1,1 +5138,5142 @@    Py_XDECREF(errobj);\n\n    if (needs_api && PyErr_Occurred()) {\n        return NULL;\n    }"
  },
  {
    "id" : "fd96b765-bf62-4953-bac0-ff6a1924b0f0",
    "prId" : 2953,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4889d817-1b58-4e7d-89b3-81dea1a05257",
        "parentId" : null,
        "authorId" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "body" : "Is this NpyIter's buggy behaviour with scalars striking again?\n",
        "createdAt" : "2013-01-31T19:29:22Z",
        "updatedAt" : "2013-01-31T19:29:22Z",
        "lastEditedBy" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "tags" : [
        ]
      }
    ],
    "commit" : "f2c81b485fa18e7ab918b470403c52751648dd3a",
    "line" : 212,
    "diffHunk" : "@@ -1,1 +1987,1991 @@            op_axes[i][0] = -1;\n        }\n    }\n\n    /* Create the iterator */"
  },
  {
    "id" : "c6b37a14-8101-45e4-b6c4-a1038904506f",
    "prId" : 5124,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "99eb72ff-99f7-4981-b19b-c375566bf629",
        "parentId" : null,
        "authorId" : "acce7360-5cef-46f0-ab05-4fb0ffdffe3a",
        "body" : "Oh wait, I misread the old code: it completely ignores `buf`. I assume that the new behavior is what was intended all along? @charris @mwiebe\n",
        "createdAt" : "2014-09-27T11:33:42Z",
        "updatedAt" : "2014-09-27T12:38:56Z",
        "lastEditedBy" : "acce7360-5cef-46f0-ab05-4fb0ffdffe3a",
        "tags" : [
        ]
      },
      {
        "id" : "1151f9bb-633e-4d48-9857-37156ebe8298",
        "parentId" : "99eb72ff-99f7-4981-b19b-c375566bf629",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Yeah, looks like `signature` was a bug. BTW, I'm seldom responsible for a lot of code that `git blame` assigns to me, as I only show up because I made extensive style fixes throughout the code. The downside of style fixes is the loss of history.\n",
        "createdAt" : "2014-09-30T01:37:18Z",
        "updatedAt" : "2014-09-30T01:37:18Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "bfc4bf4421a84eec6e17ddf09a3d2beacf4ea4b7",
    "line" : 16,
    "diffHunk" : "@@ -1,1 +746,750 @@        PyErr_Format(PyExc_ValueError,\n                     \"%s at position %d in \\\"%s\\\"\",\n                     parse_error, i, signature);\n    }\n    return -1;"
  }
]
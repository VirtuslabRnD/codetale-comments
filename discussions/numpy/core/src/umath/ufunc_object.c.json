[
  {
    "id" : "c799b2bd-a717-4c1b-950e-9b7362a687df",
    "prId" : 359,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "cb270be6-baf9-4f36-b28e-051246dd634b",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Success of memory allocation needs to be checked.\n",
        "createdAt" : "2013-04-01T18:13:58Z",
        "updatedAt" : "2013-05-10T16:48:13Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "1b70fbd7-b1d9-446c-a0ce-830f848f963d",
        "parentId" : "cb270be6-baf9-4f36-b28e-051246dd634b",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Still needs the NULL check. I there an error return available here?\n",
        "createdAt" : "2013-05-03T23:27:39Z",
        "updatedAt" : "2013-05-10T16:48:13Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "c3d71b11-b9f1-4bcd-973d-68f043d1e392",
        "parentId" : "cb270be6-baf9-4f36-b28e-051246dd634b",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Still missing check for allocation success.\n",
        "createdAt" : "2013-05-09T16:17:49Z",
        "updatedAt" : "2013-05-10T16:48:13Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "759d0632-95de-4fa6-a46f-e1ece3b6336e",
        "parentId" : "cb270be6-baf9-4f36-b28e-051246dd634b",
        "authorId" : "b0e7e584-a9be-4737-9003-4922807a34eb",
        "body" : "Somehow I missed these comments before. The op_flags allocation has a matching PyArray_free in the ufunc_dealloc function, but I do need one a few lines down if _parse_signature fails.\n",
        "createdAt" : "2013-05-09T16:33:44Z",
        "updatedAt" : "2013-05-10T16:48:13Z",
        "lastEditedBy" : "b0e7e584-a9be-4737-9003-4922807a34eb",
        "tags" : [
        ]
      },
      {
        "id" : "9a2a0869-63ce-4b5c-952c-9e808fcc81b3",
        "parentId" : "cb270be6-baf9-4f36-b28e-051246dd634b",
        "authorId" : "b0e7e584-a9be-4737-9003-4922807a34eb",
        "body" : "Nevermind, the op_flags will still be freed because ufunc_dealloc gets called if _parse_signature fails.\n",
        "createdAt" : "2013-05-09T16:53:50Z",
        "updatedAt" : "2013-05-10T16:48:13Z",
        "lastEditedBy" : "b0e7e584-a9be-4737-9003-4922807a34eb",
        "tags" : [
        ]
      }
    ],
    "commit" : "ec23d01d9c333f95db5d9349354766b38d37cae7",
    "line" : 172,
    "diffHunk" : "@@ -1,1 +4290,4294 @@    ufunc->doc = doc;\n\n    ufunc->op_flags = PyArray_malloc(sizeof(npy_uint32)*ufunc->nargs);\n    if (ufunc->op_flags == NULL) {\n        return PyErr_NoMemory();"
  },
  {
    "id" : "28bdc6a1-2a36-44a8-9261-9825c8fefd2a",
    "prId" : 359,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8baf09a8-c90d-4b4f-9f6a-a0a66a92286f",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "@seberg ISTR you may have done something relevant to this.\n",
        "createdAt" : "2013-05-09T16:16:30Z",
        "updatedAt" : "2013-05-10T16:48:13Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "9d08e0a6-58d6-4d86-a102-344824dd24c0",
        "parentId" : "8baf09a8-c90d-4b4f-9f6a-a0a66a92286f",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Yeah, my guess is, it can probably be removed. But would have to try too...\n",
        "createdAt" : "2013-05-09T17:00:59Z",
        "updatedAt" : "2013-05-10T16:48:13Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      }
    ],
    "commit" : "ec23d01d9c333f95db5d9349354766b38d37cae7",
    "line" : 144,
    "diffHunk" : "@@ -1,1 +2012,2016 @@     * If there are no iteration dimensions, create a fake one\n     * so that the scalar edge case works right.\n     */\n    if (iter_ndim == 0) {\n        iter_ndim = 1;"
  },
  {
    "id" : "2597e65f-4d90-42b0-8fde-953ba42b6dbc",
    "prId" : 462,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f20bd469-46ab-4df7-92d0-050c927d4943",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Allocation success needs a check.\n",
        "createdAt" : "2013-05-10T20:30:40Z",
        "updatedAt" : "2013-05-15T00:39:24Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "d85f7aa465cf854e2be83f67f39f058660348487",
    "line" : 132,
    "diffHunk" : "@@ -1,1 +4462,4466 @@    }\n\n    arg_typenums = PyArray_malloc(ufunc->nargs * sizeof(int));\n    if (arg_typenums == NULL) {\n        PyErr_NoMemory();"
  },
  {
    "id" : "89b4c023-8e66-4dba-bd03-fb34c5dc8e9c",
    "prId" : 2821,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7e791a53-2b54-4e42-8dd7-b7eeaaafa023",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Need extra indent. The `\\` can be dropped, no?, next line should line up with this one.\n",
        "createdAt" : "2013-04-28T01:33:04Z",
        "updatedAt" : "2013-08-16T21:44:21Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "68ec8d52-5ef7-4b57-ad60-8b205eb83f2f",
        "parentId" : "7e791a53-2b54-4e42-8dd7-b7eeaaafa023",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Can you use the new iterator here with the itershape argument? You could move the buffering/casting for the op2_array also into that iterator then as well using the op_dtypes. That would mean that the \"dummy\" casting iterator only needs to handle the first operand. Probably should check how to replace that with a direct call to the casting functions, but to be honest I don't care too much about that right now and if we add subspace iteration optimizations the dummy iterator wouldn't be quite as dummy any more for those.\n",
        "createdAt" : "2013-05-27T14:25:31Z",
        "updatedAt" : "2013-08-16T21:44:21Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      }
    ],
    "commit" : "acef718f40a30188c1379c13cc49c920d9e7c303",
    "line" : 102,
    "diffHunk" : "@@ -1,1 +4948,4952 @@         */\n        if ((iter2 = (PyArrayIterObject *)\\\n             PyArray_BroadcastToShape((PyObject *)op2_array,\n                                        iter->dimensions, iter->nd))==NULL) {\n            goto fail;"
  },
  {
    "id" : "9a33e67e-5026-4e58-8b3a-0b43c64faefb",
    "prId" : 2821,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0efc491e-d7a4-4fb5-b789-a8fab644ff80",
        "parentId" : null,
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Question: What happens if we have an object array and we get an error during the ufunc call? Such as:\n\n```\na = np.array([1, 2], dtype=object)\nb = np.array(['a'])\nnp.add.at(a, [0], b)\n```\n\nWhen api is needed, the inner loop can return an error I think? I m not sure how this is handled in the ufunc machinery, but I suspect we may need to add some magic in that case.\n",
        "createdAt" : "2013-08-05T16:35:55Z",
        "updatedAt" : "2013-08-16T21:44:21Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "c33f6422-c601-4ec3-ac02-14c212e2d6e6",
        "parentId" : "0efc491e-d7a4-4fb5-b789-a8fab644ff80",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "I guess we can live with `object_array += something` leaving `object_array` in an inconsistent state upon an error? The same will be the case for `ufunc.at(object_array, indices, something)`. Just thought there was an API question here, but `+=` also just stops when the first error occured, so I think we can copy that behaviour, or does anyone disagree?\n",
        "createdAt" : "2013-08-05T16:53:34Z",
        "updatedAt" : "2013-08-16T21:44:21Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "7f9935ce-c505-483b-8eea-735eb30f1c4e",
        "parentId" : "0efc491e-d7a4-4fb5-b789-a8fab644ff80",
        "authorId" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "body" : "Yeah, that sounds right to me.\n\nOn Mon, Aug 5, 2013 at 5:53 PM, seberg notifications@github.com wrote:\n\n> In numpy/core/src/umath/ufunc_object.c:\n> \n> > -         \\* puts result in buffer.\n> > -         */\n> > -        do {\n> > -            innerloop(buffer_dataptr, count, stride, innerloopdata);\n> > -        } while (iternext(iter_buffer));\n> >   +\n> > -        PyArray_MapIterNext(iter);\n> > -        if (iter2 != NULL) {\n> > -            PyArray_ITER_NEXT(iter2);\n> > -        }\n> >   +\n> > -        i--;\n> > -    }\n> >   +\n> > -    if (!needs_api) {\n> > -        NPY_END_THREADS;\n> \n> I guess we can live with object_array += something leaving object_arrayin an inconsistent state upon an error? The same will be the case for\n> ufunc.at(object_array, indices, something). Just thought there was an API\n> question here, but += also just stops when the first error occured, so I\n> think we can copy that behaviour, or does anyone disagree?\n> \n> â€”\n> Reply to this email directly or view it on GitHubhttps://github.com/numpy/numpy/pull/2821/files#r5583608\n> .\n",
        "createdAt" : "2013-08-05T17:16:24Z",
        "updatedAt" : "2013-08-16T21:44:21Z",
        "lastEditedBy" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "tags" : [
        ]
      }
    ],
    "commit" : "acef718f40a30188c1379c13cc49c920d9e7c303",
    "line" : 279,
    "diffHunk" : "@@ -1,1 +5125,5129 @@\n    if (!needs_api) {\n        NPY_END_THREADS;\n    }\n   "
  },
  {
    "id" : "cb4dba58-67b9-443a-8b2b-042f42746d0d",
    "prId" : 2821,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "36c44788-3026-433f-b738-77ceb4551ac4",
        "parentId" : null,
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Hmm, I think the other ufuncs already stop during calculation instead of the end? Not sure if it matters, might need code duplication, to do it in the loop, but...\nCould you add a test for this too? Something like `np.add.at(np.array(['a', 1], dtype=object), [0, 1], 1)` gives and error (and maybe does not change the 1).\n",
        "createdAt" : "2013-08-09T15:41:53Z",
        "updatedAt" : "2013-08-16T21:44:21Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      }
    ],
    "commit" : "acef718f40a30188c1379c13cc49c920d9e7c303",
    "line" : 292,
    "diffHunk" : "@@ -1,1 +5138,5142 @@    Py_XDECREF(errobj);\n\n    if (needs_api && PyErr_Occurred()) {\n        return NULL;\n    }"
  },
  {
    "id" : "fd96b765-bf62-4953-bac0-ff6a1924b0f0",
    "prId" : 2953,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4889d817-1b58-4e7d-89b3-81dea1a05257",
        "parentId" : null,
        "authorId" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "body" : "Is this NpyIter's buggy behaviour with scalars striking again?\n",
        "createdAt" : "2013-01-31T19:29:22Z",
        "updatedAt" : "2013-01-31T19:29:22Z",
        "lastEditedBy" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "tags" : [
        ]
      }
    ],
    "commit" : "f2c81b485fa18e7ab918b470403c52751648dd3a",
    "line" : 212,
    "diffHunk" : "@@ -1,1 +1987,1991 @@            op_axes[i][0] = -1;\n        }\n    }\n\n    /* Create the iterator */"
  },
  {
    "id" : "c6b37a14-8101-45e4-b6c4-a1038904506f",
    "prId" : 5124,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "99eb72ff-99f7-4981-b19b-c375566bf629",
        "parentId" : null,
        "authorId" : "acce7360-5cef-46f0-ab05-4fb0ffdffe3a",
        "body" : "Oh wait, I misread the old code: it completely ignores `buf`. I assume that the new behavior is what was intended all along? @charris @mwiebe\n",
        "createdAt" : "2014-09-27T11:33:42Z",
        "updatedAt" : "2014-09-27T12:38:56Z",
        "lastEditedBy" : "acce7360-5cef-46f0-ab05-4fb0ffdffe3a",
        "tags" : [
        ]
      },
      {
        "id" : "1151f9bb-633e-4d48-9857-37156ebe8298",
        "parentId" : "99eb72ff-99f7-4981-b19b-c375566bf629",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Yeah, looks like `signature` was a bug. BTW, I'm seldom responsible for a lot of code that `git blame` assigns to me, as I only show up because I made extensive style fixes throughout the code. The downside of style fixes is the loss of history.\n",
        "createdAt" : "2014-09-30T01:37:18Z",
        "updatedAt" : "2014-09-30T01:37:18Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "bfc4bf4421a84eec6e17ddf09a3d2beacf4ea4b7",
    "line" : 16,
    "diffHunk" : "@@ -1,1 +746,750 @@        PyErr_Format(PyExc_ValueError,\n                     \"%s at position %d in \\\"%s\\\"\",\n                     parse_error, i, signature);\n    }\n    return -1;"
  },
  {
    "id" : "14e9a72e-e1b3-4dab-8d78-732aea861917",
    "prId" : 5621,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d05da67d-2e16-4230-8551-de8f769a1bb1",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Might want to scatter a `\\n` or two in the message.\n",
        "createdAt" : "2015-03-08T00:30:21Z",
        "updatedAt" : "2015-03-08T16:00:18Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "bb3ae05f773e1997b4e95655cf1795cb7c8f904b",
    "line" : 174,
    "diffHunk" : "@@ -1,1 +1022,1026 @@                             */\n                            if (PyArray_Check(value) || value == Py_None) {\n                                if (DEPRECATE(\"passing a single array to the \"\n                                              \"'out' keyword argument of a \"\n                                              \"ufunc with\\n\""
  },
  {
    "id" : "4aec1e94-62e9-4125-8b67-911b0b311063",
    "prId" : 7198,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f3b35743-fe30-4781-80a1-93b4b3dacbc1",
        "parentId" : null,
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Actually I am not sure how reliable this is, but don't have a quick better idea either. With all those inner core dimensions, I guess the iterator size could be vastly overestimated possibly (I am not sure).\n",
        "createdAt" : "2016-02-05T21:53:42Z",
        "updatedAt" : "2016-03-17T12:15:12Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "a8a61618-e659-4b30-8d35-b57ac11103f4",
        "parentId" : "f3b35743-fe30-4781-80a1-93b4b3dacbc1",
        "authorId" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "body" : "Can an ssize_t actually meaningfully overflow here? ssize_t = intp, right? So how do you address an array that's bigger then ssize_t can represent?\n",
        "createdAt" : "2016-02-05T23:18:34Z",
        "updatedAt" : "2016-03-17T12:15:12Z",
        "lastEditedBy" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "tags" : [
        ]
      },
      {
        "id" : "3283011e-8832-4b28-9887-cd4aab415fb5",
        "parentId" : "f3b35743-fe30-4781-80a1-93b4b3dacbc1",
        "authorId" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "body" : "Otherwise looks good to me.\n.\nObligatory comment in passing that the code duplication between ufuncs and\ngufuncs sucks.\n\nOn Fri, Feb 5, 2016 at 1:53 PM, seberg notifications@github.com wrote:\n\n> In numpy/core/src/umath/ufunc_object.c\n> https://github.com/numpy/numpy/pull/7198#discussion_r52077858:\n> \n> > @@ -2343,6 +2344,16 @@ PyUFunc_GeneralizedFunction(PyUFuncObject *ufunc,\n> >          }\n> >      }\n> > -    total_problem_size = NpyIter_GetIterSize(iter);\n> > -    if (total_problem_size < 0) {\n> \n> Actually I am not sure how reliable this is, but don't have a quick better\n> idea either. With all those inner core dimensions, I guess the iterator\n> size could be vastly overestimated possibly (I am not sure).\n> \n> â€”\n> Reply to this email directly or view it on GitHub\n> https://github.com/numpy/numpy/pull/7198/files#r52077858.\n\n## \n\nNathaniel J. Smith -- https://vorpus.org http://vorpus.org\n",
        "createdAt" : "2016-02-05T23:19:20Z",
        "updatedAt" : "2016-03-17T12:15:12Z",
        "lastEditedBy" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "tags" : [
        ]
      },
      {
        "id" : "45601c3d-092c-4e9e-a4d0-a033c8abed70",
        "parentId" : "f3b35743-fe30-4781-80a1-93b4b3dacbc1",
        "authorId" : "34105ae0-9fd2-4403-be9b-7c550a729828",
        "body" : "The array isn't bigger, just the intermediate representation of the iterator before removing some axes. E.g. a call to `numpy.core.umath_tests.inner1d`, which has signature '(i),(i)->()', with two arrays of shapes `(a, 1, c)` and `(1, b, c)` will create an iterator with shape `(a, b, c, c)` before removing the last two dimensions. So with slightly more complicated gufuncs it is a meaningful possibility.\n",
        "createdAt" : "2016-02-06T06:10:13Z",
        "updatedAt" : "2016-03-17T12:15:12Z",
        "lastEditedBy" : "34105ae0-9fd2-4403-be9b-7c550a729828",
        "tags" : [
        ]
      },
      {
        "id" : "10b2209b-d792-42ed-bd84-d2603cbcabb8",
        "parentId" : "f3b35743-fe30-4781-80a1-93b4b3dacbc1",
        "authorId" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "body" : "Eh, I guess. Does the iterator actually handle such cases? Should we care when by the time we're dealing with such numbers we're just as likely to roll back around to positive? I guess it doesn't really matter too much whatever we do here...\n",
        "createdAt" : "2016-02-06T06:27:56Z",
        "updatedAt" : "2016-03-17T12:15:12Z",
        "lastEditedBy" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "tags" : [
        ]
      },
      {
        "id" : "9890166c-8eeb-466c-95fb-ed5be0575d42",
        "parentId" : "f3b35743-fe30-4781-80a1-93b4b3dacbc1",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "If it would not care explicitly, it should error out. So it sets it to \n-1 and errors out unless you remove that stuff again. I added that\nweird feature explicitly for these gufuncs that bloat the iterator.\n",
        "createdAt" : "2016-02-06T07:23:41Z",
        "updatedAt" : "2016-03-17T12:15:12Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      }
    ],
    "commit" : "19655d1d80f299bd76982d485b74aa8b4b0018d6",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +2349,2353 @@\n    total_problem_size = NpyIter_GetIterSize(iter);\n    if (total_problem_size < 0) {\n        /*\n         * Only used for threading, if negative (this means that it is"
  },
  {
    "id" : "bffcebb9-3f8e-4fad-9ffd-a8559aa27e41",
    "prId" : 7373,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2f53fade-658b-4070-9fc2-9483bade78d7",
        "parentId" : null,
        "authorId" : "0d70c244-f732-4a44-9ae8-c3f6de7e9b40",
        "body" : "Why are these values not the same as the ones returned by `assign_reduce_identity_*()`? Specifically, `assign_reduce_identity_minusone()` uses `PyLong_FromLong()` instead of `PyInt_FromLong()`. It looks like one is a macro for the other in Py3, but is that the case in Py2 as well?\n",
        "createdAt" : "2016-03-03T05:02:30Z",
        "updatedAt" : "2016-03-04T02:36:59Z",
        "lastEditedBy" : "0d70c244-f732-4a44-9ae8-c3f6de7e9b40",
        "tags" : [
        ]
      },
      {
        "id" : "d0340563-05f8-4f0b-9892-aa557922437a",
        "parentId" : "2f53fade-658b-4070-9fc2-9483bade78d7",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "They don't matter ;) `ufunc_get_identity` is a getter function for a property of the ufunc object and is only there to make the number visible to python users.\n",
        "createdAt" : "2016-03-03T06:12:41Z",
        "updatedAt" : "2016-03-04T02:36:59Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "13925bf5-2d43-4846-a013-519c130e9c6f",
        "parentId" : "2f53fade-658b-4070-9fc2-9483bade78d7",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "`assign_reduce_identity_minusone()` is used to produce a number that I want passed to `PyLong_AsLongLong` in `PyArray_FillWithScalars` so that the maximum number of bits are produced. Might could use something smaller, maybe not, but why gamble?\n",
        "createdAt" : "2016-03-03T06:17:28Z",
        "updatedAt" : "2016-03-04T02:36:59Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "0936775a-1403-438a-8e34-3aaac5a8edf7",
        "parentId" : "2f53fade-658b-4070-9fc2-9483bade78d7",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "I think the only thing that might matter (not even sure about that) is, whether we want to return -1 or -1L in the object corner cases of empty reductions on python 2. But either way is good in any case, Python makes no real difference between the two (and will silently convert easily).\n",
        "createdAt" : "2016-03-03T15:25:36Z",
        "updatedAt" : "2016-03-04T02:36:59Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      }
    ],
    "commit" : "9653c05a53327332a481cd697708ae9b6360fbf0",
    "line" : 63,
    "diffHunk" : "@@ -1,1 +5604,5608 @@    case PyUFunc_Zero:\n        return PyInt_FromLong(0);\n    case PyUFunc_MinusOne:\n        return PyInt_FromLong(-1);\n    }"
  },
  {
    "id" : "4c902016-e6cc-4858-8357-aecafe687327",
    "prId" : 8043,
    "prUrl" : "https://github.com/numpy/numpy/pull/8043#pullrequestreview-17566404",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "81270d24-ee98-486f-858c-ea5c115fa096",
        "parentId" : null,
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "why is this line added? a bug in the old code or due to the other changes?",
        "createdAt" : "2017-01-12T13:20:51Z",
        "updatedAt" : "2017-02-10T19:53:34Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      },
      {
        "id" : "35f348c0-d46a-45d3-b496-9a42cafba6d1",
        "parentId" : "81270d24-ee98-486f-858c-ea5c115fa096",
        "authorId" : "48d7d71b-9655-46b2-9a18-7c1fba7837d0",
        "body" : "I think it's a noop. Not necessary to add.",
        "createdAt" : "2017-01-12T19:12:42Z",
        "updatedAt" : "2017-02-10T19:53:34Z",
        "lastEditedBy" : "48d7d71b-9655-46b2-9a18-7c1fba7837d0",
        "tags" : [
        ]
      },
      {
        "id" : "626a1992-61ea-4855-8068-67dd6785fd18",
        "parentId" : "81270d24-ee98-486f-858c-ea5c115fa096",
        "authorId" : "48d7d71b-9655-46b2-9a18-7c1fba7837d0",
        "body" : "On second thought, I think it's useful to have here to ensure correctness, if we later on change NPY_ITER_COPY_IF_OVERLAP to make copies of also the input arrays.",
        "createdAt" : "2017-01-19T21:50:35Z",
        "updatedAt" : "2017-02-10T19:53:34Z",
        "lastEditedBy" : "48d7d71b-9655-46b2-9a18-7c1fba7837d0",
        "tags" : [
        ]
      }
    ],
    "commit" : "8e8ce442e8449916a93951093cdce16cec006bcc",
    "line" : 322,
    "diffHunk" : "@@ -1,1 +3691,3695 @@        op[0] = NpyIter_GetOperandArray(iter)[0];\n        op[1] = NpyIter_GetOperandArray(iter)[1];\n        op[2] = NpyIter_GetOperandArray(iter)[2];\n\n        if (out == NULL) {"
  },
  {
    "id" : "ff8bd499-4ffb-4f3d-aa54-068bd73b242a",
    "prId" : 8662,
    "prUrl" : "https://github.com/numpy/numpy/pull/8662#pullrequestreview-228732264",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4a1796ae-40c7-41af-b154-c068cc8444af",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Missing null check after this runs",
        "createdAt" : "2019-04-19T15:36:47Z",
        "updatedAt" : "2019-04-19T15:36:48Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "e043bb98e537742f71cc3a6a54d7be171044fd98",
    "line" : 18,
    "diffHunk" : "@@ -1,1 +5435,5439 @@        \"numpy\",\n        \"matrix\",\n        &_numpy_matrix);\n\n    if (PyObject_IsInstance(tmp, _numpy_matrix)) {"
  },
  {
    "id" : "ecbe7055-d3d8-4533-81a7-6629fad4e1a5",
    "prId" : 8819,
    "prUrl" : "https://github.com/numpy/numpy/pull/8819#pullrequestreview-99833070",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b3a8148f-4cd5-4837-af8f-eaa17b88d639",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Is there a reason we're not using PyArg_ParseTupleAndKeywords here? Out of scope for this PR, but still\r\n",
        "createdAt" : "2017-03-23T21:35:58Z",
        "updatedAt" : "2018-02-28T01:03:35Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "50831a4f-e954-4eba-83ef-ba4ef2ee6b21",
        "parentId" : "b3a8148f-4cd5-4837-af8f-eaa17b88d639",
        "authorId" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "body" : "Probably speed â€“ I haven't checked if this particular case makes a meaningful difference, but the ufunc call path is a place where microseconds count.",
        "createdAt" : "2017-03-23T22:34:30Z",
        "updatedAt" : "2018-02-28T01:03:35Z",
        "lastEditedBy" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "tags" : [
        ]
      },
      {
        "id" : "8f934ffa-8663-4028-99d6-454908767d80",
        "parentId" : "b3a8148f-4cd5-4837-af8f-eaa17b88d639",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Switch statements actually compile as hardwired binary search, so for small lists of possibilities the savings probably don't amount to much. I think the main virtues are compactness, clarity, and fall through, which can be used to select code entry points. The last is probably frowned upon by structured code fanatics...",
        "createdAt" : "2017-03-23T22:45:37Z",
        "updatedAt" : "2018-02-28T01:03:35Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "b44a02eb-c3ed-47d0-bc24-2025a8176b89",
        "parentId" : "b3a8148f-4cd5-4837-af8f-eaa17b88d639",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "If speed really matters here, then presumably we could save a little more with `strcmp(str+1, \"xis\")` on the following lines...\r\n\r\nEither way, I think this probably needs a comment explaining that we're avoiding PyArg_ParseTupleAndKeywords for speed reasons.",
        "createdAt" : "2017-03-23T23:53:08Z",
        "updatedAt" : "2018-02-28T01:03:35Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "a9ef7ad1-6921-4c38-820c-cf7e0123c7f5",
        "parentId" : "b3a8148f-4cd5-4837-af8f-eaa17b88d639",
        "authorId" : "a4f03a99-2e43-482b-a9bc-5a9e359abb03",
        "body" : "We didn't add the comment, but I'm not going to demand it before merging.",
        "createdAt" : "2018-02-27T16:47:06Z",
        "updatedAt" : "2018-02-28T01:03:35Z",
        "lastEditedBy" : "a4f03a99-2e43-482b-a9bc-5a9e359abb03",
        "tags" : [
        ]
      },
      {
        "id" : "ba7c5e28-8270-4429-9301-e49d4a6014fa",
        "parentId" : "b3a8148f-4cd5-4837-af8f-eaa17b88d639",
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "I think a comment on the structure is a bit out-of-scope of this PR (and I don't really know what the original reason was anyway...)",
        "createdAt" : "2018-02-27T19:58:31Z",
        "updatedAt" : "2018-02-28T01:03:35Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      }
    ],
    "commit" : "05a420af6504efa21f99f968b2c66de62c1668d7",
    "line" : 24,
    "diffHunk" : "@@ -1,1 +811,815 @@\n            switch (str[0]) {\n                case 'a':\n                    /* possible axis argument for generalized ufunc */\n                    if (out_axes != NULL && strcmp(str, \"axes\") == 0) {"
  },
  {
    "id" : "b76afdce-c713-4491-992e-db2fcbdda1e0",
    "prId" : 8819,
    "prUrl" : "https://github.com/numpy/numpy/pull/8819#pullrequestreview-86068542",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "cbee463e-5398-40bf-8261-e66ac8ebb0b6",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Can this be negative if the out argument is invalid? Is that checked before this function is called?",
        "createdAt" : "2018-01-01T20:05:59Z",
        "updatedAt" : "2018-02-28T01:03:35Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "353a01f6-4f0f-419d-8e94-d3241961e50b",
        "parentId" : "cbee463e-5398-40bf-8261-e66ac8ebb0b6",
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "Nice catch - this gets checked only in `_get_coredim_sizes`, which is called after (and needs the remap); I'll separate that check out and will add a test.",
        "createdAt" : "2018-01-01T20:09:56Z",
        "updatedAt" : "2018-02-28T01:03:35Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      },
      {
        "id" : "604bf23f-09d4-4cef-9bee-bc6c27cf0c12",
        "parentId" : "cbee463e-5398-40bf-8261-e66ac8ebb0b6",
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "BTW, happy new year!",
        "createdAt" : "2018-01-01T20:10:07Z",
        "updatedAt" : "2018-02-28T01:03:35Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      }
    ],
    "commit" : "05a420af6504efa21f99f968b2c66de62c1668d7",
    "line" : 106,
    "diffHunk" : "@@ -1,1 +1832,1836 @@        if (op[iop] != NULL) {\n            op_ndim = PyArray_NDIM(op[iop]);\n            op_nbroadcast = op_ndim - op_ncore;\n        }\n        else {"
  },
  {
    "id" : "746d4389-3b07-4d7b-ba8f-39343754ebef",
    "prId" : 8819,
    "prUrl" : "https://github.com/numpy/numpy/pull/8819#pullrequestreview-99914965",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a475cd51-889c-4bfc-940f-a4d7a16c7ae7",
        "parentId" : null,
        "authorId" : "a4f03a99-2e43-482b-a9bc-5a9e359abb03",
        "body" : "It would be nice to avoid mallocs. In principle we could replace `nop` by `NPY_MAXARGS` and allocate on the stack, but that would be `32*32` ints, or 8kb (4kb on 32bit), which seems a little large to put on the stack. But I see other places in numpy we have already done this, eg a grep shows:\r\n```\r\nnumpy/core/src/umath/ufunc_object.c:2061:    int op_axes_arrays[NPY_MAXARGS][NPY_MAXDIMS];\r\nnumpy/core/src/multiarray/nditer_pywrap.c:742:    int op_axes_arrays[NPY_MAXARGS][NPY_MAXDIMS];\r\nnumpy/core/src/multiarray/einsum.c.src:2610:    char op_labels[NPY_MAXARGS][NPY_MAXDIMS];\r\nnumpy/core/src/multiarray/einsum.c.src:2617:    int op_axes_arrays[NPY_MAXARGS][NPY_MAXDIMS];\r\n```\r\n\r\nI like the strategy in the 3rd line there to use a `char`, so it is only 1kb. I also like how those other examples use C's 2d static array syntax, instead of allocating a separate index array.\r\n\r\nIn summary, I actually think it would be a significant improvement to allocate `remap_axis_memory` as a static 2d char array.",
        "createdAt" : "2018-02-27T17:18:30Z",
        "updatedAt" : "2018-02-28T01:03:35Z",
        "lastEditedBy" : "a4f03a99-2e43-482b-a9bc-5a9e359abb03",
        "tags" : [
        ]
      },
      {
        "id" : "c88bfe20-9bf1-494f-8e5b-ac13dcc5e97a",
        "parentId" : "a475cd51-889c-4bfc-940f-a4d7a16c7ae7",
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "I had that originally, but thought that it was a waste of memory for what should normally be a rare use case. A yet more complicated alternative would be to allocate a, say, 3x3 2-D array and not use it is there are more arguments. (note that the `char` is for op_labels, which are in fact characters.)",
        "createdAt" : "2018-02-27T17:23:09Z",
        "updatedAt" : "2018-02-28T01:03:35Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      },
      {
        "id" : "abb84992-c097-4762-b710-2e1c752a52a8",
        "parentId" : "a475cd51-889c-4bfc-940f-a4d7a16c7ae7",
        "authorId" : "a4f03a99-2e43-482b-a9bc-5a9e359abb03",
        "body" : "There are a few ways to tidy this along those lines. \r\n\r\nPerhaps do this: Get rid of `remap_axis` and only have  `char remap_axis_memory[NPY_MAXARGS][NPY_MAXDIMS];` Then redefine `#define REMAP_AXIS(iop, axis) ((axes ? remap_axis_memory[iop][axis] : axis)`",
        "createdAt" : "2018-02-27T17:41:23Z",
        "updatedAt" : "2018-02-28T01:03:35Z",
        "lastEditedBy" : "a4f03a99-2e43-482b-a9bc-5a9e359abb03",
        "tags" : [
        ]
      },
      {
        "id" : "9b8f99a1-eac6-4d19-84e2-ef5bbab45efb",
        "parentId" : "a475cd51-889c-4bfc-940f-a4d7a16c7ae7",
        "authorId" : "a4f03a99-2e43-482b-a9bc-5a9e359abb03",
        "body" : "Oh sorry, I didn't see your comment.  Yeah it is debatable.\r\n\r\nI guess if you already investigated both options, I am happy to go with whichever you thin kis better.",
        "createdAt" : "2018-02-27T17:45:16Z",
        "updatedAt" : "2018-02-28T01:03:35Z",
        "lastEditedBy" : "a4f03a99-2e43-482b-a9bc-5a9e359abb03",
        "tags" : [
        ]
      },
      {
        "id" : "b709968f-827a-4a93-ae8f-9383d2925f1e",
        "parentId" : "a475cd51-889c-4bfc-940f-a4d7a16c7ae7",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Any reason not to combine these into one allocation?",
        "createdAt" : "2018-02-27T18:17:36Z",
        "updatedAt" : "2018-02-28T01:03:35Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "817d5d32-7585-4ff4-9531-3d178aa4e96f",
        "parentId" : "a475cd51-889c-4bfc-940f-a4d7a16c7ae7",
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "`remap_axis` is of pointers, `remap_axis_memory` of `int`, so in principle they can have different stride size, correct?",
        "createdAt" : "2018-02-27T19:52:20Z",
        "updatedAt" : "2018-02-28T01:03:35Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      },
      {
        "id" : "f88eef95-e9f6-43f3-8c61-516fd04340ee",
        "parentId" : "a475cd51-889c-4bfc-940f-a4d7a16c7ae7",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Stride size isn't relevant if you're allocating a `void*`. I suppose alignment could be an issue?",
        "createdAt" : "2018-02-27T21:48:18Z",
        "updatedAt" : "2018-02-28T01:03:35Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "fed75379-4236-4809-9c6c-0cdcbeae1d6e",
        "parentId" : "a475cd51-889c-4bfc-940f-a4d7a16c7ae7",
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "In the end, I think this is an implementation detail - the present code is at least somewhat clear, so maybe best to leave it for later.",
        "createdAt" : "2018-02-28T01:07:39Z",
        "updatedAt" : "2018-02-28T01:07:39Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      }
    ],
    "commit" : "05a420af6504efa21f99f968b2c66de62c1668d7",
    "line" : 301,
    "diffHunk" : "@@ -1,1 +2202,2206 @@        remap_axis = PyArray_malloc(sizeof(remap_axis[0]) * nop);\n        remap_axis_memory = PyArray_malloc(sizeof(remap_axis_memory[0]) *\n                                                  nop * NPY_MAXDIMS);\n        if (remap_axis == NULL || remap_axis_memory == NULL) {\n            PyErr_NoMemory();"
  },
  {
    "id" : "566f9b90-6874-4f47-a810-89da0d84f8af",
    "prId" : 8876,
    "prUrl" : "https://github.com/numpy/numpy/pull/8876#pullrequestreview-30097611",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "473374b0-e8d0-45b2-9453-9a0a951b6e62",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Almost all of this function, and its doc-comment, are a direct move of the code from before, with the exception that:\r\n* `goto fail` is just `return -1`\r\n* some fields need re-extracting from ufunc\r\n* `ufunc_name` is recalculated when needed - only in errors, so performance is irrelevant",
        "createdAt" : "2017-03-30T20:02:07Z",
        "updatedAt" : "2017-04-06T10:22:21Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "19ae9fb4f03d0d8379c64bbd5589dad961436044",
    "line" : 57,
    "diffHunk" : "@@ -1,1 +2003,2007 @@ */\nstatic int\n_get_coredim_sizes(PyUFuncObject *ufunc, PyArrayObject **op,\n                   npy_intp* core_dim_sizes) {\n    int i;"
  },
  {
    "id" : "f12242ff-2159-4f42-877f-7c605e50ca0a",
    "prId" : 8876,
    "prUrl" : "https://github.com/numpy/numpy/pull/8876#pullrequestreview-31274207",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "04512a00-3c2a-40fe-8fc2-6dfb856fb3d6",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Starting at 0 makes more sense, because our function works by assigning to it until its not zero",
        "createdAt" : "2017-03-30T20:03:18Z",
        "updatedAt" : "2017-04-06T10:22:21Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "23d35b72-843f-4b05-8885-e990bdaf8aed",
        "parentId" : "04512a00-3c2a-40fe-8fc2-6dfb856fb3d6",
        "authorId" : "34105ae0-9fd2-4403-be9b-7c550a729828",
        "body" : "It's always overwritten, so the value assigned here is irrelevant, right? ",
        "createdAt" : "2017-03-31T21:03:31Z",
        "updatedAt" : "2017-04-06T10:22:21Z",
        "lastEditedBy" : "34105ae0-9fd2-4403-be9b-7c550a729828",
        "tags" : [
        ]
      },
      {
        "id" : "20ed03a0-97a8-41bd-9809-18790ac03043",
        "parentId" : "04512a00-3c2a-40fe-8fc2-6dfb856fb3d6",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "True, but this the correct base case if we end up with a code path that never sets `retval`, so seems like a good thing to keep",
        "createdAt" : "2017-04-06T10:17:45Z",
        "updatedAt" : "2017-04-06T10:22:21Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "19ae9fb4f03d0d8379c64bbd5589dad961436044",
    "line" : 161,
    "diffHunk" : "@@ -1,1 +2108,2112 @@    int i, j, idim, nop;\n    const char *ufunc_name;\n    int retval = 0, subok = 1;\n    int needs_api = 0;\n"
  },
  {
    "id" : "aee2e4d1-b40d-4e1d-a342-46e98cb72008",
    "prId" : 8952,
    "prUrl" : "https://github.com/numpy/numpy/pull/8952#pullrequestreview-32952165",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5b610de8-48bb-4944-a69f-1d75d526d43c",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "This used to be `True` when used internally, and `1` when viewed externally.\r\n\r\nThe upshot is that this fixes #8860.\r\n\r\nIdeally, we'd use `True` for functions like `logical_or`, and `1` for functions like `add`",
        "createdAt" : "2017-04-16T21:56:13Z",
        "updatedAt" : "2017-10-03T07:22:41Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "31fd25debbbabb292c5dc06f1c7418c5dfd97ff7",
    "line" : 31,
    "diffHunk" : "@@ -1,1 +1848,1852 @@    case PyUFunc_One:\n        *reorderable = 1;\n        return PyInt_FromLong(1);\n\n    case PyUFunc_Zero:"
  },
  {
    "id" : "e55c9689-fb9d-40e0-ac45-bf2fbd5b6179",
    "prId" : 8952,
    "prUrl" : "https://github.com/numpy/numpy/pull/8952#pullrequestreview-32952165",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d61b9745-46e4-447b-9e6c-40dd0ffc56e3",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Previously, we cached these values in a static variable. Is this something we should keep doing?",
        "createdAt" : "2017-04-16T21:56:29Z",
        "updatedAt" : "2017-10-03T07:22:41Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "31fd25debbbabb292c5dc06f1c7418c5dfd97ff7",
    "line" : 39,
    "diffHunk" : "@@ -1,1 +1856,1860 @@    case PyUFunc_MinusOne:\n        *reorderable = 1;\n        return PyInt_FromLong(-1);\n\n    case PyUFunc_ReorderableNone:"
  },
  {
    "id" : "304d8bfe-2cdf-492b-82fe-1cfae964b52c",
    "prId" : 8952,
    "prUrl" : "https://github.com/numpy/numpy/pull/8952#pullrequestreview-32952165",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e47cd77b-9a23-4b01-82cc-d934c09913ff",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "`assign_identity` was never anything but this operation",
        "createdAt" : "2017-04-16T21:58:03Z",
        "updatedAt" : "2017-10-03T07:22:41Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "31fd25debbbabb292c5dc06f1c7418c5dfd97ff7",
    "line" : 104,
    "diffHunk" : "@@ -1,1 +2293,2297 @@                    goto fail;\n                }\n                PyArray_FillWithScalar(op[i], identity);\n            }\n        }"
  },
  {
    "id" : "b0c35dc2-25c0-4795-bb57-7ee83d522ce9",
    "prId" : 8952,
    "prUrl" : "https://github.com/numpy/numpy/pull/8952#pullrequestreview-32952165",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5bde853e-63e4-465a-aeea-ca99b6b66d27",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Moving this check to occur first makes cleanup a little easier.",
        "createdAt" : "2017-04-16T21:58:25Z",
        "updatedAt" : "2017-10-03T07:22:41Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "31fd25debbbabb292c5dc06f1c7418c5dfd97ff7",
    "line" : 208,
    "diffHunk" : "@@ -1,1 +2816,2820 @@    }\n\n    if (_get_bufsize_errmask(NULL, \"reduce\", &buffersize, &errormask) < 0) {\n        return NULL;\n    }"
  },
  {
    "id" : "ebd3fe31-ae92-416e-870a-7f9666172d43",
    "prId" : 8952,
    "prUrl" : "https://github.com/numpy/numpy/pull/8952#pullrequestreview-32952165",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b33ac195-721c-44ae-abc3-b776687b7104",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "I don't think this behaviour is justified, but this is a maintenance commit, so for now, we should leave it in",
        "createdAt" : "2017-04-16T21:58:55Z",
        "updatedAt" : "2017-10-03T07:22:41Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "31fd25debbbabb292c5dc06f1c7418c5dfd97ff7",
    "line" : 226,
    "diffHunk" : "@@ -1,1 +2833,2837 @@        identity = Py_None;\n        Py_INCREF(identity);\n    }\n\n    /* Get the reduction dtype */"
  },
  {
    "id" : "ae07f043-9b1c-4b64-b6ab-b2b46d002906",
    "prId" : 9022,
    "prUrl" : "https://github.com/numpy/numpy/pull/9022#pullrequestreview-127444630",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "da081749-54f0-4d55-a26f-e5ed302fbd7b",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "What about `wrap`?",
        "createdAt" : "2018-06-11T03:36:17Z",
        "updatedAt" : "2018-06-13T17:51:08Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "b7106ce7-4863-41f1-ab37-199fae37e47d",
        "parentId" : "da081749-54f0-4d55-a26f-e5ed302fbd7b",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Good catch, thanks",
        "createdAt" : "2018-06-11T06:25:18Z",
        "updatedAt" : "2018-06-13T17:51:08Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "e3b0a3f743cb215cf8a61e318687e9b54a8691a5",
    "line" : 129,
    "diffHunk" : "@@ -1,1 +422,426 @@                context->ufunc, args_tup, context->out_i);\n            Py_DECREF(args_tup);\n            if (py_context == NULL) {\n                goto fail;\n            }"
  },
  {
    "id" : "ed5a0215-84b4-4c62-a82a-eec8e342a22c",
    "prId" : 9022,
    "prUrl" : "https://github.com/numpy/numpy/pull/9022#pullrequestreview-127428277",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bbda39c3-242f-47d2-9d26-41af409676cf",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "What about `wrap`?",
        "createdAt" : "2018-06-11T03:36:48Z",
        "updatedAt" : "2018-06-13T17:51:08Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "e3b0a3f743cb215cf8a61e318687e9b54a8691a5",
    "line" : 123,
    "diffHunk" : "@@ -1,1 +416,420 @@            /* Call the method with appropriate context */\n            args_tup = _get_wrap_prepare_args(context->args);\n            if (args_tup == NULL) {\n                goto fail;\n            }"
  },
  {
    "id" : "d02e3b8c-cebd-4aea-89fb-2af65ec4d402",
    "prId" : 9022,
    "prUrl" : "https://github.com/numpy/numpy/pull/9022#pullrequestreview-128207446",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ccd68535-14f0-47ed-aa5a-34ea71a82e53",
        "parentId" : null,
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "I must admit I find this open context ugly too - I'm trained to think I must be within a special block.  I'd just move the `PyObject *wrap` to the top...",
        "createdAt" : "2018-06-13T01:26:36Z",
        "updatedAt" : "2018-06-13T17:51:08Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      },
      {
        "id" : "de44b827-d5a8-4a67-9fb9-317e36156a7b",
        "parentId" : "ccd68535-14f0-47ed-aa5a-34ea71a82e53",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "I put the comment before the block to make it clearer that there was no control structure missing. I think that the reduced number of local variable to keep track of is worth having a briefly misleading `{`. Also, when we adopt C99, cases like this can all be removed with a find and replace.",
        "createdAt" : "2018-06-13T02:13:21Z",
        "updatedAt" : "2018-06-13T17:51:08Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "e3b0a3f743cb215cf8a61e318687e9b54a8691a5",
    "line" : 182,
    "diffHunk" : "@@ -1,1 +4531,4535 @@\n    /* Wrap and return the output */\n    {\n        /* Find __array_wrap__ - note that these rules are different to the\n         * normal ufunc path"
  },
  {
    "id" : "64675de6-a111-4ab2-9b37-89e05347807a",
    "prId" : 9022,
    "prUrl" : "https://github.com/numpy/numpy/pull/9022#pullrequestreview-128207486",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "70def671-2d71-47fe-91c5-052b5c2aaab9",
        "parentId" : null,
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "Now I think I've made the comment, but perhaps forgot to submit: maybe just define `_ufunc_context context = {ufunc, full_args, i};`? Or is that incorrect syntax? (My C remains quite hopeless...)",
        "createdAt" : "2018-06-13T01:28:24Z",
        "updatedAt" : "2018-06-13T17:51:08Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      },
      {
        "id" : "8242acb6-2a6f-4658-bfc3-aa454be895c2",
        "parentId" : "70def671-2d71-47fe-91c5-052b5c2aaab9",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Sure, that seems reasonable - Definitely correct in some version of C, I think C90 will cope.",
        "createdAt" : "2018-06-13T02:13:42Z",
        "updatedAt" : "2018-06-13T17:51:08Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "e3b0a3f743cb215cf8a61e318687e9b54a8691a5",
    "line" : 310,
    "diffHunk" : "@@ -1,1 +4635,4639 @@        PyObject *wrapped;\n\n        context.ufunc = ufunc;\n        context.args = full_args;\n        context.out_i = i;"
  },
  {
    "id" : "84d74953-a632-44a9-a7a2-98cc7db98dde",
    "prId" : 9335,
    "prUrl" : "https://github.com/numpy/numpy/pull/9335#pullrequestreview-47530048",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bee321e6-2c82-48ae-874c-4e24be4f482b",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "What does `NPY_ITER_WRITEONLY` mean here? Just curious.",
        "createdAt" : "2017-06-30T20:12:10Z",
        "updatedAt" : "2017-06-30T20:12:11Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "e34baa2f-0e75-40ab-b735-66b96817b879",
        "parentId" : "bee321e6-2c82-48ae-874c-4e24be4f482b",
        "authorId" : "48d7d71b-9655-46b2-9a18-7c1fba7837d0",
        "body" : "I think it means the iterator is free to ignore data previously in the array vs. whether it needs to pre-fill buffers with old data. The iterator (correctly) considers READWRITE as an error if it's also asked to allocate the output array.",
        "createdAt" : "2017-07-01T13:03:37Z",
        "updatedAt" : "2017-07-01T13:15:17Z",
        "lastEditedBy" : "48d7d71b-9655-46b2-9a18-7c1fba7837d0",
        "tags" : [
        ]
      }
    ],
    "commit" : "df84fd8c1c7d8f014af3b15cdac3af4ded50ae36",
    "line" : 22,
    "diffHunk" : "@@ -1,1 +1791,1795 @@         */\n        op_flags[i] = default_op_out_flags |\n                      (op[i] != NULL ? NPY_ITER_READWRITE : NPY_ITER_WRITEONLY) |\n                      NPY_ITER_ALIGNED |\n                      NPY_ITER_ALLOCATE |"
  },
  {
    "id" : "95f9f7e7-10fb-4eed-a120-672cd183a2e2",
    "prId" : 9335,
    "prUrl" : "https://github.com/numpy/numpy/pull/9335#pullrequestreview-47530191",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d147259e-5d1d-4c87-b5ae-cf5388a73f89",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "I take it `op[i] == NULL` means it will be allocated by the iterator? ",
        "createdAt" : "2017-06-30T20:14:12Z",
        "updatedAt" : "2017-06-30T20:14:12Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "ffdc00ef-9256-41e4-a2db-9c45ce681165",
        "parentId" : "d147259e-5d1d-4c87-b5ae-cf5388a73f89",
        "authorId" : "48d7d71b-9655-46b2-9a18-7c1fba7837d0",
        "body" : "Yes, the output array is then not user-provided.",
        "createdAt" : "2017-07-01T13:15:39Z",
        "updatedAt" : "2017-07-01T13:15:39Z",
        "lastEditedBy" : "48d7d71b-9655-46b2-9a18-7c1fba7837d0",
        "tags" : [
        ]
      }
    ],
    "commit" : "df84fd8c1c7d8f014af3b15cdac3af4ded50ae36",
    "line" : 39,
    "diffHunk" : "@@ -1,1 +1839,1843 @@         * and returned to the caller, and this needs an extra incref.\n         */\n        if (op[i] == NULL) {\n            op_tmp = op_it[i];\n            Py_INCREF(op_tmp);"
  },
  {
    "id" : "5464e0a8-e738-4714-9727-79e87c02ba8f",
    "prId" : 10194,
    "prUrl" : "https://github.com/numpy/numpy/pull/10194#pullrequestreview-82360514",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "65e63927-2b3a-4e2b-9fcb-b5abff591f17",
        "parentId" : null,
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "This is where the `DECREF` was missing.",
        "createdAt" : "2017-12-10T19:00:35Z",
        "updatedAt" : "2017-12-11T13:39:59Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      },
      {
        "id" : "9c67d127-53b2-4c14-9f24-e807f57bf1bd",
        "parentId" : "65e63927-2b3a-4e2b-9fcb-b5abff591f17",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Careless of me, good catch",
        "createdAt" : "2017-12-10T19:59:40Z",
        "updatedAt" : "2017-12-11T13:39:59Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "2fadedee0799df7c4ce8f81caf5a1283df767e57",
    "line" : 132,
    "diffHunk" : "@@ -1,1 +3814,3818 @@        }\n        else if (check_and_adjust_axis(&axis, ndim) < 0) {\n            goto fail;\n        }\n        axes[0] = (int)axis;"
  },
  {
    "id" : "1100acd3-88a4-4968-a838-65ef763764fd",
    "prId" : 10459,
    "prUrl" : "https://github.com/numpy/numpy/pull/10459#pullrequestreview-90961083",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c402496e-8034-403c-8351-8962865b0fd8",
        "parentId" : null,
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "You are on purpose not yet checking whether the `out` argument is a tuple, correct?",
        "createdAt" : "2018-01-23T19:52:35Z",
        "updatedAt" : "2018-01-24T17:35:02Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      },
      {
        "id" : "9ee2e333-5039-455f-af08-352283621707",
        "parentId" : "c402496e-8034-403c-8351-8962865b0fd8",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "I'm on purpose just leaving it as it was - I want to push the `out` argument parsing way upstream",
        "createdAt" : "2018-01-23T19:58:44Z",
        "updatedAt" : "2018-01-24T17:35:02Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "e6956dde2299fb9980eb00437a1cd3af97da5958",
    "line" : 71,
    "diffHunk" : "@@ -1,1 +275,279 @@        /* Output argument one may also be in a keyword argument */\n        else if (i == 0 && kwds != NULL) {\n            obj = PyDict_GetItem(kwds, npy_um_str_out);\n        }\n"
  },
  {
    "id" : "57b1a13a-1a5e-41ef-abbf-074daa241515",
    "prId" : 10919,
    "prUrl" : "https://github.com/numpy/numpy/pull/10919#pullrequestreview-113406378",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "eda04ce6-cf83-4c6a-a177-c0d86e8ef19a",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "@mhvk: The separation between `in` and `out` makes this a little more transparent (no `idx_offset` or `start_idx`)",
        "createdAt" : "2018-04-18T02:58:23Z",
        "updatedAt" : "2018-04-22T19:41:18Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "68f32b9a-c0f3-49da-bc89-5e383eaf9510",
        "parentId" : "eda04ce6-cf83-4c6a-a177-c0d86e8ef19a",
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "True, but at the cost of a new function that combines `in` and `out` to remake `arr_prep_args`; just correcting the implementation of that would have a much smaller footprint.",
        "createdAt" : "2018-04-18T20:25:28Z",
        "updatedAt" : "2018-04-22T19:41:18Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      },
      {
        "id" : "e5f564fd-cb53-45c3-b902-e5a5ae63a3d0",
        "parentId" : "eda04ce6-cf83-4c6a-a177-c0d86e8ef19a",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "That combination had to be added somewhere - part of the original bug was that only `*args` was being used, rather than a normalized `args` struct. Either we combine them at the call site, or we do it during the parse step.\r\n\r\nSince we treat in and out differently in a bunch of places, it seems most useful to keep them separate till the last minute.",
        "createdAt" : "2018-04-18T21:54:14Z",
        "updatedAt" : "2018-04-22T19:41:18Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "40868df10690fe57f182064fb284ff6807a74dbb",
    "line" : 583,
    "diffHunk" : "@@ -1,1 +4252,4256 @@        for (i = 0; i < nout; i++) {\n            output_wrap[i] = _get_output_array_method(\n                PyTuple_GET_ITEM(args.out, i), npy_um_str_array_wrap, wrap);\n        }\n    }"
  },
  {
    "id" : "ffc12f6d-1389-4903-84c4-6f4ab8349470",
    "prId" : 10919,
    "prUrl" : "https://github.com/numpy/numpy/pull/10919#pullrequestreview-114403092",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ba9bc3a8-db63-4e9e-aabb-ba1cc601a782",
        "parentId" : null,
        "authorId" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "body" : "shouldn't the output arguments be last in the declaration?",
        "createdAt" : "2018-04-22T19:53:48Z",
        "updatedAt" : "2018-04-22T19:53:49Z",
        "lastEditedBy" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "tags" : [
        ]
      },
      {
        "id" : "959b8c8a-c456-44d5-9a06-c1f58ac38ff1",
        "parentId" : "ba9bc3a8-db63-4e9e-aabb-ba1cc601a782",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Putting them first matches `memcpy(dst, src, n)` and `f(dst, args...)` more closely resembles `dst = f(args...)`",
        "createdAt" : "2018-04-22T20:22:43Z",
        "updatedAt" : "2018-04-22T20:22:43Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "023bde58-766a-49f1-8963-a609d6b81eee",
        "parentId" : "ba9bc3a8-db63-4e9e-aabb-ba1cc601a782",
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "I slightly wondered why the routine doesn't just return `full_args` (and `NULL` if it fails).\r\n\r\n(Beyond that, @mattip, are you OK with the current implementation? My sense is that it is ready to go in.)",
        "createdAt" : "2018-04-23T13:23:45Z",
        "updatedAt" : "2018-04-23T13:23:46Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      },
      {
        "id" : "d58d81b1-29d6-4d30-bb5b-d6ee25bdf34c",
        "parentId" : "ba9bc3a8-db63-4e9e-aabb-ba1cc601a782",
        "authorId" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "body" : "It is an improvement, from here refactoring will be easier",
        "createdAt" : "2018-04-23T14:17:14Z",
        "updatedAt" : "2018-04-23T14:17:14Z",
        "lastEditedBy" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "tags" : [
        ]
      }
    ],
    "commit" : "40868df10690fe57f182064fb284ff6807a74dbb",
    "line" : 276,
    "diffHunk" : "@@ -1,1 +1771,1775 @@        ufunc_full_args *full_args,\n        npy_intp nin, npy_intp nout,\n        PyObject *args, PyObject *kwds)\n{\n    PyObject *out_kwd = NULL;"
  },
  {
    "id" : "16c97779-6859-40bc-a923-6cfc59c8ad12",
    "prId" : 10919,
    "prUrl" : "https://github.com/numpy/numpy/pull/10919#pullrequestreview-114213844",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "21ccafc3-0e30-45d6-8eac-11a01580efcd",
        "parentId" : null,
        "authorId" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "body" : "assert will be ignored in release",
        "createdAt" : "2018-04-22T19:57:54Z",
        "updatedAt" : "2018-04-22T19:57:54Z",
        "lastEditedBy" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "tags" : [
        ]
      },
      {
        "id" : "7f43fa29-e620-4d57-9876-33954aae29d4",
        "parentId" : "21ccafc3-0e30-45d6-8eac-11a01580efcd",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "That's fine, I don't think this can ever happen",
        "createdAt" : "2018-04-22T20:24:52Z",
        "updatedAt" : "2018-04-22T20:24:52Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "40868df10690fe57f182064fb284ff6807a74dbb",
    "line" : 288,
    "diffHunk" : "@@ -1,1 +1778,1782 @@\n    /* This should have been checked by the caller */\n    assert(nin <= nargs && nargs <= nin + nout);\n\n    /* Initialize so we can XDECREF safely */"
  },
  {
    "id" : "36a9295f-e145-4c64-b274-e94904b36ae7",
    "prId" : 10919,
    "prUrl" : "https://github.com/numpy/numpy/pull/10919#pullrequestreview-114213804",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6f230b65-4d41-4835-bf74-b4a2f774aead",
        "parentId" : null,
        "authorId" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "body" : "Is there a check elsewhere?  assert will be ignored in release",
        "createdAt" : "2018-04-22T20:00:07Z",
        "updatedAt" : "2018-04-22T20:00:07Z",
        "lastEditedBy" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "tags" : [
        ]
      },
      {
        "id" : "fefa2cc0-0971-4834-a05e-8f0cad8e3a1c",
        "parentId" : "6f230b65-4d41-4835-bf74-b4a2f774aead",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Yep, this check already happens in the first round of argument parsing",
        "createdAt" : "2018-04-22T20:23:26Z",
        "updatedAt" : "2018-04-22T20:23:26Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "40868df10690fe57f182064fb284ff6807a74dbb",
    "line" : 313,
    "diffHunk" : "@@ -1,1 +1794,1798 @@\n    if (out_kwd != NULL) {\n        assert(nargs == nin);\n        if (out_kwd == Py_None) {\n            return 0;"
  },
  {
    "id" : "12928047-cd6d-453f-a9f2-fbb380e65318",
    "prId" : 10988,
    "prUrl" : "https://github.com/numpy/numpy/pull/10988#pullrequestreview-119890720",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "241459d9-c845-4f0d-bcd8-656b541819da",
        "parentId" : null,
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "Not quite this PR, but while you're at it: there would seem to be no reason to call this every time in the loop; maybe preset `args_tup` to `NULL` on top, and here only set it if `NULL`? I.e.,\r\n```\r\nif (args_tup == NULL) {\r\n    args_tup = _get_wrap_prepare_args(full_args);\r\n    if (args_tup == NULL) {\r\n        goto fail;\r\n    }\r\n}\r\n```",
        "createdAt" : "2018-04-27T13:53:48Z",
        "updatedAt" : "2018-04-27T13:54:35Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      },
      {
        "id" : "354e4269-2137-4e95-bfe3-e4b6d9fc6212",
        "parentId" : "241459d9-c845-4f0d-bcd8-656b541819da",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "I also considered just caching this on the `full_args` object. Something for another PR, I think.",
        "createdAt" : "2018-05-14T07:28:54Z",
        "updatedAt" : "2018-05-14T07:28:54Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "db895961-b5f7-4c44-a114-7929b5f5c985",
        "parentId" : "241459d9-c845-4f0d-bcd8-656b541819da",
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "OK, that's fine.",
        "createdAt" : "2018-05-14T15:36:55Z",
        "updatedAt" : "2018-05-14T15:36:55Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      }
    ],
    "commit" : "b187c60258a5741dd75bc53f868a7261e87396e8",
    "line" : 35,
    "diffHunk" : "@@ -1,1 +4372,4376 @@\n            /* Call the method with appropriate context */\n            args_tup = _get_wrap_prepare_args(full_args);\n            if (args_tup == NULL) {\n                goto fail;"
  },
  {
    "id" : "59bb3308-2559-43ae-a33d-b6a6bcbab15b",
    "prId" : 11098,
    "prUrl" : "https://github.com/numpy/numpy/pull/11098#pullrequestreview-121423111",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "672de20b-eacd-42c5-b9d2-dc2fa548153d",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Unrelated to this PR: I'm struggling to understand what `j` is, and why its state is kept between outputs",
        "createdAt" : "2018-05-18T07:31:05Z",
        "updatedAt" : "2018-05-18T13:46:54Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "36c09c3c-850b-426b-83cb-e6f46dd49982",
        "parentId" : "672de20b-eacd-42c5-b9d2-dc2fa548153d",
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "I agree, I turn from thinking it clear to having no clue almost every time I look at this...  Mostly because I only partially understand how the iterator works. But this would be a good place to comment it more heavily. For another PR...",
        "createdAt" : "2018-05-18T13:41:54Z",
        "updatedAt" : "2018-05-18T13:46:54Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      }
    ],
    "commit" : "8ccabd6273d4ed598ad732c33d36a5efce6c4a8a",
    "line" : 233,
    "diffHunk" : "@@ -1,1 +2422,2426 @@                                        ufunc->core_dim_ixs[dim_offset + idim]];\n                op_axes_arrays[i][j] = REMAP_AXIS(i, n + idim);\n                ++j;\n            }\n        }"
  },
  {
    "id" : "1c431461-ed6d-4140-9986-1013106e8fb4",
    "prId" : 11175,
    "prUrl" : "https://github.com/numpy/numpy/pull/11175#pullrequestreview-124896859",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "675c67a4-97e0-4838-93c4-f11781535935",
        "parentId" : null,
        "authorId" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "body" : "what if ufunc->version == 0?",
        "createdAt" : "2018-05-30T21:10:12Z",
        "updatedAt" : "2018-10-15T16:45:15Z",
        "lastEditedBy" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "tags" : [
        ]
      },
      {
        "id" : "383005c4-08a1-49b6-83de-0117177dc5d5",
        "parentId" : "675c67a4-97e0-4838-93c4-f11781535935",
        "authorId" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "body" : "version here can never be 0, ignore this comment",
        "createdAt" : "2018-05-31T17:13:33Z",
        "updatedAt" : "2018-10-15T16:45:15Z",
        "lastEditedBy" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "tags" : [
        ]
      }
    ],
    "commit" : "c8e15bafb0d811d8dd805ddf521d102eaac08079",
    "line" : 119,
    "diffHunk" : "@@ -1,1 +639,643 @@             */\n            for(ix = 0; ix < ufunc->core_num_dim_ix; ix++) {\n                if (frozen_size > 0 ?\n                    frozen_size == ufunc->core_dim_sizes[ix] :\n                    _is_same_name(signature + i, var_names[ix])) {"
  },
  {
    "id" : "c99b1b5c-b127-412e-9567-962117ce74f9",
    "prId" : 11175,
    "prUrl" : "https://github.com/numpy/numpy/pull/11175#pullrequestreview-124897186",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f81888c1-da9f-43a8-8dc1-b6ab79a8bfa7",
        "parentId" : null,
        "authorId" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "body" : "what happens if ufunc->version == 0?",
        "createdAt" : "2018-05-30T21:10:56Z",
        "updatedAt" : "2018-10-15T16:45:15Z",
        "lastEditedBy" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "tags" : [
        ]
      },
      {
        "id" : "3704b51b-955c-431d-8689-c82c3555f578",
        "parentId" : "f81888c1-da9f-43a8-8dc1-b6ab79a8bfa7",
        "authorId" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "body" : "version here can never be 0, ignore this comment",
        "createdAt" : "2018-05-31T17:14:27Z",
        "updatedAt" : "2018-10-15T16:45:15Z",
        "lastEditedBy" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "tags" : [
        ]
      }
    ],
    "commit" : "c8e15bafb0d811d8dd805ddf521d102eaac08079",
    "line" : 140,
    "diffHunk" : "@@ -1,1 +657,661 @@                if (can_ignore) {\n                    ufunc->core_dim_flags[ix] |= UFUNC_CORE_DIM_CAN_IGNORE;\n                }\n            } else {\n                if (can_ignore && !(ufunc->core_dim_flags[ix] &"
  },
  {
    "id" : "4a3f21be-b7a1-4964-b708-cf8cec6fb5e6",
    "prId" : 11175,
    "prUrl" : "https://github.com/numpy/numpy/pull/11175#pullrequestreview-154966159",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bb69c5e6-630c-4847-a576-e9030ede52a6",
        "parentId" : null,
        "authorId" : "73d6f7d8-2c7d-4a48-8754-5ce4a97a850f",
        "body" : "Just to confirm -- does `op_dim_size` actually have to be declared inside this for loop instead of at the top of the function with other type declarations? So, limiting the scope of the variable type declaration within the for loop outweighs any cost associated with it happening iteratively because the compiler can optimize that out anyway?",
        "createdAt" : "2018-08-07T00:12:53Z",
        "updatedAt" : "2018-10-15T16:45:15Z",
        "lastEditedBy" : "73d6f7d8-2c7d-4a48-8754-5ce4a97a850f",
        "tags" : [
        ]
      },
      {
        "id" : "7a879f28-4f30-4f96-998d-c305b59f9e07",
        "parentId" : "bb69c5e6-630c-4847-a576-e9030ede52a6",
        "authorId" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "body" : "correct. It is a convenience. I find it easier to track variable lifetimes if they are defined in the block where they live, then I can forget about them after I grok the relevant code.",
        "createdAt" : "2018-09-12T19:32:22Z",
        "updatedAt" : "2018-10-15T16:45:15Z",
        "lastEditedBy" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "tags" : [
        ]
      },
      {
        "id" : "fe87c56b-7b14-47d6-bb28-423e15dc5a60",
        "parentId" : "bb69c5e6-630c-4847-a576-e9030ede52a6",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "> outweighs any cost associated with\r\n\r\nThere is no runtime cost associated with moving a variable to an inner scope in C. C++ is a different story if your type has an expensive constructor / desctructor.",
        "createdAt" : "2018-09-13T07:57:13Z",
        "updatedAt" : "2018-10-15T16:45:15Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "c8e15bafb0d811d8dd805ddf521d102eaac08079",
    "line" : 335,
    "diffHunk" : "@@ -1,1 +2385,2389 @@                int core_dim_index = ufunc->core_dim_ixs[core_index];\n                npy_intp core_dim_size = core_dim_sizes[core_dim_index];\n                npy_intp op_dim_size;\n\n                /* can only happen if flexible; dimension missing altogether */"
  },
  {
    "id" : "63508074-2166-410b-8db4-ac87fc6414ce",
    "prId" : 11175,
    "prUrl" : "https://github.com/numpy/numpy/pull/11175#pullrequestreview-155165031",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7b87f274-7045-493c-9841-af4e8ccf3a24",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Function comment should be updated to explain that `?` is included.",
        "createdAt" : "2018-09-13T08:13:38Z",
        "updatedAt" : "2018-10-15T16:45:15Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "f75a21fd-a437-4a2d-9d98-e88a389b41dd",
        "parentId" : "7b87f274-7045-493c-9841-af4e8ccf3a24",
        "authorId" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "body" : "updated",
        "createdAt" : "2018-09-13T16:26:06Z",
        "updatedAt" : "2018-10-15T16:45:15Z",
        "lastEditedBy" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "tags" : [
        ]
      }
    ],
    "commit" : "c8e15bafb0d811d8dd805ddf521d102eaac08079",
    "line" : 41,
    "diffHunk" : "@@ -1,1 +511,515 @@        ret++;\n    }\n    if (str[ret] == '?') {\n        ret ++;\n    }"
  },
  {
    "id" : "aa1f8f88-5987-4460-b125-e19f6017c567",
    "prId" : 11175,
    "prUrl" : "https://github.com/numpy/numpy/pull/11175#pullrequestreview-164733678",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3e0e980d-0331-47ab-9ea2-4dfc8116b6f5",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "This function should return and intp, and verify that the result fits in an intp, given that it's always cast when called.\r\n\r\n",
        "createdAt" : "2018-09-13T16:46:08Z",
        "updatedAt" : "2018-10-15T16:45:15Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "97c287e3-35db-4172-81d4-b2079c2602b0",
        "parentId" : "3e0e980d-0331-47ab-9ea2-4dfc8116b6f5",
        "authorId" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "body" : "done",
        "createdAt" : "2018-09-13T17:08:59Z",
        "updatedAt" : "2018-10-15T16:45:15Z",
        "lastEditedBy" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "tags" : [
        ]
      },
      {
        "id" : "469673b6-5d3c-4fac-a6ae-4dd990997873",
        "parentId" : "3e0e980d-0331-47ab-9ea2-4dfc8116b6f5",
        "authorId" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "body" : "fixed",
        "createdAt" : "2018-09-13T18:12:13Z",
        "updatedAt" : "2018-10-15T16:45:15Z",
        "lastEditedBy" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "tags" : [
        ]
      },
      {
        "id" : "5894ba7e-6aef-4a08-9ca6-77a86f6ba36c",
        "parentId" : "3e0e980d-0331-47ab-9ea2-4dfc8116b6f5",
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "Seems like the signature is still `npy_int` rather than `npy_intp`?",
        "createdAt" : "2018-10-15T14:38:20Z",
        "updatedAt" : "2018-10-15T16:45:15Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      }
    ],
    "commit" : "c8e15bafb0d811d8dd805ddf521d102eaac08079",
    "line" : 16,
    "diffHunk" : "@@ -1,1 +485,489 @@ */\nstatic npy_intp\n_get_size(const char* str)\n{\n    char *stop;"
  },
  {
    "id" : "76abc097-7328-42f1-a0af-e9a00d90d138",
    "prId" : 11175,
    "prUrl" : "https://github.com/numpy/numpy/pull/11175#pullrequestreview-164795948",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0be134d0-3787-4e84-b275-9781b89348e1",
        "parentId" : null,
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "Either \"which\" -> \"this\", or better, replace the period with a comma (and lower-case \"signal\")",
        "createdAt" : "2018-10-15T14:45:55Z",
        "updatedAt" : "2018-10-15T16:45:15Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      },
      {
        "id" : "f14d4dbe-80a5-486a-8810-c0e4f1bd3c56",
        "parentId" : "0be134d0-3787-4e84-b275-9781b89348e1",
        "authorId" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "body" : "changed",
        "createdAt" : "2018-10-15T16:44:21Z",
        "updatedAt" : "2018-10-15T16:45:15Z",
        "lastEditedBy" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "tags" : [
        ]
      }
    ],
    "commit" : "c8e15bafb0d811d8dd805ddf521d102eaac08079",
    "line" : 480,
    "diffHunk" : "@@ -1,1 +2610,2614 @@    }\n    /*\n     * If keepdims is set and true, which means all input dimensions are\n     * the same, signal that all output dimensions will be the same too.\n     */"
  },
  {
    "id" : "f68d05ae-ddf4-44e8-9770-fe4012a36875",
    "prId" : 11257,
    "prUrl" : "https://github.com/numpy/numpy/pull/11257#pullrequestreview-126457756",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5f922a46-3fd6-4aab-9e78-e103268dc4fb",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "It'd be nice to change it so it does this too, but I suppose there's no need for that to be part of _this_ PR",
        "createdAt" : "2018-06-06T15:53:30Z",
        "updatedAt" : "2018-06-06T15:53:30Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "7c42c35f-0581-40f4-acee-4c9418b90a61",
        "parentId" : "5f922a46-3fd6-4aab-9e78-e103268dc4fb",
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "Yes, I thought about that too, and am happy to do a follow-up PR for that; there is no reason not to clean up.",
        "createdAt" : "2018-06-06T16:36:17Z",
        "updatedAt" : "2018-06-06T16:36:18Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      }
    ],
    "commit" : "aae239cff42720ed4353acebf32c6d9310e824c6",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +556,560 @@ *\n * Note that if an error is returned, the caller must free the\n * non-zero references in out_op.  This function does not do its own clean-up.\n *\n * Note also that all the outputs from keyword arguments contain new references."
  },
  {
    "id" : "0e2a3235-abb5-47c6-b05f-17e2e9ee583c",
    "prId" : 11260,
    "prUrl" : "https://github.com/numpy/numpy/pull/11260#pullrequestreview-126520668",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ebeb539c-f1ce-4c0b-9de9-5d147a1a8f24",
        "parentId" : null,
        "authorId" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "body" : "nop should be used wherever ufunc->nargs appears",
        "createdAt" : "2018-06-06T18:09:20Z",
        "updatedAt" : "2018-06-08T00:49:47Z",
        "lastEditedBy" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "tags" : [
        ]
      },
      {
        "id" : "cbb10d92-f070-4709-97e2-536662521bf6",
        "parentId" : "ebeb539c-f1ce-4c0b-9de9-5d147a1a8f24",
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "Done. And fixed the failures by passing back `retval` correctly.",
        "createdAt" : "2018-06-06T19:26:30Z",
        "updatedAt" : "2018-06-08T00:49:47Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      }
    ],
    "commit" : "584e82fae4ec877fe560f3359ac5886350bb19ac",
    "line" : 18,
    "diffHunk" : "@@ -1,1 +574,578 @@    int nin = ufunc->nin;\n    int nout = ufunc->nout;\n    int nop = ufunc->nargs;\n    PyObject *obj, *context;\n    PyObject *str_key_obj = NULL;"
  },
  {
    "id" : "36c9f0f8-212c-495d-8438-1239352d8e7a",
    "prId" : 11260,
    "prUrl" : "https://github.com/numpy/numpy/pull/11260#pullrequestreview-127371569",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "cb0d8007-c11e-47ed-962f-a2ef8547040d",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Should this do the full cleanup and `goto fail`? Could add a `fail_pre_kwargs` label, if we want to avoid unnecessary cleanup.\r\n\r\nOf course, really the huge hack section of this function should be extracted from the rest of it.",
        "createdAt" : "2018-06-07T07:30:39Z",
        "updatedAt" : "2018-06-08T00:49:47Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "d4b66dbe-ceb5-4967-83fa-575b07e46929",
        "parentId" : "cb0d8007-c11e-47ed-962f-a2ef8547040d",
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "Initially I had a `goto cleanup_out_op` and passed on a `retval`, but then I found that it just became confusing, and might hinder ripping this whole part out (which, as you said, should be done, but better not in this PR...). Fortunately, here we know exactly what has been done up to this point (indeed, this is partially why I moved the `nin == 2` to the if-statement; I wanted to be absolutely sure I decref'd just the right number of operands, even if someone gave their ufunc a name that matches but has more than 2 inputs).",
        "createdAt" : "2018-06-07T13:29:56Z",
        "updatedAt" : "2018-06-08T00:49:47Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      },
      {
        "id" : "24d69b20-1ec9-451e-9ed2-d11169879d26",
        "parentId" : "cb0d8007-c11e-47ed-962f-a2ef8547040d",
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "More for completeness: See #11282",
        "createdAt" : "2018-06-09T16:11:20Z",
        "updatedAt" : "2018-06-09T16:11:21Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      }
    ],
    "commit" : "584e82fae4ec877fe560f3359ac5886350bb19ac",
    "line" : 101,
    "diffHunk" : "@@ -1,1 +796,800 @@#endif\n            Py_DECREF(out_op[0]);\n            Py_DECREF(out_op[1]);\n            return -2;\n        }"
  },
  {
    "id" : "2af511d7-c7b3-4ae5-94fe-84585969cc95",
    "prId" : 11351,
    "prUrl" : "https://github.com/numpy/numpy/pull/11351#pullrequestreview-133142625",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c43b1c82-2ddd-4ef4-a3ae-6d4ed2b61f95",
        "parentId" : null,
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "I'm not 100% sure this way of repeatedly going through the `va_list` is OK generically, but I guess the tests will tell.",
        "createdAt" : "2018-06-28T19:57:25Z",
        "updatedAt" : "2018-06-29T13:51:32Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      },
      {
        "id" : "f8252b3c-c906-48b4-ae72-9404a3d1761e",
        "parentId" : "c43b1c82-2ddd-4ef4-a3ae-6d4ed2b61f95",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Looks like [you're fine](http://www.cplusplus.com/reference/cstdarg/va_start/):\r\n\r\n> `void va_start (va_list ap, paramN);`\r\n> If ap has already been passed as first argument to a previous call to va_start or va_copy, **it shall be passed to va_end before calling this function.**",
        "createdAt" : "2018-06-29T08:38:07Z",
        "updatedAt" : "2018-06-29T13:51:32Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "f93a496134f242e6900c029fe4255adce130595f",
    "line" : 74,
    "diffHunk" : "@@ -1,1 +622,626 @@        }\n        if (kwnames[index]) {\n            va_start(va, kwnames);\n            for (i = 0; i <= index; i++) {\n                convert = va_arg(va, converter *);"
  },
  {
    "id" : "7b471228-5de7-45aa-b028-1a412b0d1e90",
    "prId" : 11580,
    "prUrl" : "https://github.com/numpy/numpy/pull/11580#pullrequestreview-146670860",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "69dadcc6-f714-4959-82da-ff32ea0f33e0",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : " lines < 80 characters.",
        "createdAt" : "2018-08-15T16:18:27Z",
        "updatedAt" : "2018-10-21T05:51:44Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "ca691937-06d4-47b4-8e72-babfb3437ad2",
        "parentId" : "69dadcc6-f714-4959-82da-ff32ea0f33e0",
        "authorId" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "body" : "fixed",
        "createdAt" : "2018-08-16T01:05:01Z",
        "updatedAt" : "2018-10-21T05:51:44Z",
        "lastEditedBy" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "tags" : [
        ]
      }
    ],
    "commit" : "9afa2f7988b15202d8da1064980e81426fe487e8",
    "line" : 213,
    "diffHunk" : "@@ -1,1 +2775,2779 @@     * possible temporary array.\n     */\n    _ufunc_setup_flags(ufunc, NPY_ITER_COPY | NPY_UFUNC_DEFAULT_INPUT_FLAGS,\n                       NPY_ITER_UPDATEIFCOPY |\n                       NPY_ITER_READWRITE |"
  },
  {
    "id" : "ba18b623-1c2d-4cfb-a47a-1407a9994449",
    "prId" : 11580,
    "prUrl" : "https://github.com/numpy/numpy/pull/11580#pullrequestreview-147919670",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bf4da5bb-125b-4174-ad55-d4d5860a7c99",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "This could maybe do with a docstring",
        "createdAt" : "2018-08-21T06:32:44Z",
        "updatedAt" : "2018-10-21T05:51:44Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "9afa2f7988b15202d8da1064980e81426fe487e8",
    "line" : 26,
    "diffHunk" : "@@ -1,1 +331,335 @@ */\nNPY_NO_EXPORT void\n_ufunc_setup_flags(PyUFuncObject *ufunc, npy_uint32 op_in_flags,\n                   npy_uint32 op_out_flags, npy_uint32 *op_flags)\n{"
  },
  {
    "id" : "685ba751-9209-446d-a930-0993bc92c2fa",
    "prId" : 11580,
    "prUrl" : "https://github.com/numpy/numpy/pull/11580#pullrequestreview-147987077",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bb208b9b-6b2a-467a-a778-08e7089eed37",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Are `op_flags` and `ufunc->op_flags` here ever the same pointer?",
        "createdAt" : "2018-08-21T06:33:57Z",
        "updatedAt" : "2018-10-21T05:51:44Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "24ef4849-92d2-4340-847c-c2330e2183bc",
        "parentId" : "bb208b9b-6b2a-467a-a778-08e7089eed37",
        "authorId" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "body" : "No. `op_flags` is the per-call copy of `ufunc->op_flags`, updated for the actual call arguments and variation (`reduce`, `__call__`, `reduceat`)",
        "createdAt" : "2018-08-21T09:56:38Z",
        "updatedAt" : "2018-10-21T05:51:44Z",
        "lastEditedBy" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "tags" : [
        ]
      }
    ],
    "commit" : "9afa2f7988b15202d8da1064980e81426fe487e8",
    "line" : 44,
    "diffHunk" : "@@ -1,1 +349,353 @@    }\n    for (i = nin; i < nop; ++i) {\n        op_flags[i] = ufunc->op_flags[i] ? ufunc->op_flags[i] : op_out_flags;\n    }\n}"
  },
  {
    "id" : "2fe8f7ab-1084-4627-8525-42769a97a7c8",
    "prId" : 11580,
    "prUrl" : "https://github.com/numpy/numpy/pull/11580#pullrequestreview-148151553",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "83b47f2e-3b06-4f81-b844-c672ca66e14d",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Docstring for this function should be updated with this new argument",
        "createdAt" : "2018-08-21T06:39:39Z",
        "updatedAt" : "2018-10-21T05:51:44Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "6f54281e-3029-4b60-8059-f841e7a230fe",
        "parentId" : "83b47f2e-3b06-4f81-b844-c672ca66e14d",
        "authorId" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "body" : "Reworked",
        "createdAt" : "2018-08-21T16:46:42Z",
        "updatedAt" : "2018-10-21T05:51:44Z",
        "lastEditedBy" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "tags" : [
        ]
      }
    ],
    "commit" : "9afa2f7988b15202d8da1064980e81426fe487e8",
    "line" : 121,
    "diffHunk" : "@@ -1,1 +1578,1582 @@                    PyObject **arr_prep,\n                    ufunc_full_args full_args,\n                    npy_uint32 *op_flags)\n{\n    npy_intp nin = ufunc->nin, nout = ufunc->nout;"
  },
  {
    "id" : "d5fa1b9a-3649-4458-9f55-394be699f557",
    "prId" : 11977,
    "prUrl" : "https://github.com/numpy/numpy/pull/11977#pullrequestreview-157610795",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6aef7438-7e31-4ec8-840f-119851dc2ef2",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "I think this is unnecessary - ufuncs are immutable, so it should not be possible for them to be in reference cycles with other immutable objects.\r\n\r\nFurthermore, if you remove this then you can use the presence of `obj` in tp_alloc to decide whether the GC needs to untrack the object.",
        "createdAt" : "2018-09-19T06:02:37Z",
        "updatedAt" : "2019-01-09T12:58:01Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "ffd08899-5fd9-4f97-94ad-16d49d7ff30b",
        "parentId" : "6aef7438-7e31-4ec8-840f-119851dc2ef2",
        "authorId" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "body" : "do you mean `tp_dealloc`? Removed `ufunc_clear` and changed `ufunc_dealloc`",
        "createdAt" : "2018-09-21T09:23:05Z",
        "updatedAt" : "2019-01-09T12:58:01Z",
        "lastEditedBy" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "tags" : [
        ]
      }
    ],
    "commit" : "82419c00ed41899990d8a0d332535d246edc4147",
    "line" : 87,
    "diffHunk" : "@@ -1,1 +5329,5333 @@    }\n    return 0;\n}\n\n/******************************************************************************"
  },
  {
    "id" : "3d2d91ab-4cb2-44ce-bdb9-a2e039f3dc3d",
    "prId" : 11977,
    "prUrl" : "https://github.com/numpy/numpy/pull/11977#pullrequestreview-185941869",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c27c7b49-e4f5-481d-8db2-ac990aee7fc1",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Where did all this come from?",
        "createdAt" : "2018-12-18T07:49:37Z",
        "updatedAt" : "2019-01-09T12:58:01Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "acb2e1c7-33a4-4c98-aefe-ace71aad02d4",
        "parentId" : "c27c7b49-e4f5-481d-8db2-ac990aee7fc1",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Ah, replacing the `memset`. Nice, although might have been clearer in its own commit.",
        "createdAt" : "2018-12-18T07:59:13Z",
        "updatedAt" : "2019-01-09T12:58:01Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "82419c00ed41899990d8a0d332535d246edc4147",
    "line" : 47,
    "diffHunk" : "@@ -1,1 +4932,4936 @@    ufunc->reserved2 = NULL;\n    ufunc->reserved1 = 0;\n    ufunc->iter_flags = 0;\n\n    /* Type resolution and inner loop selection functions */"
  },
  {
    "id" : "8728d5f2-61bf-4874-908a-005600c33fc4",
    "prId" : 11977,
    "prUrl" : "https://github.com/numpy/numpy/pull/11977#pullrequestreview-185983280",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8d48ef84-3b34-460e-8669-1fc4612ce185",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Can you convince me that the order of:\r\n* `Py_DECREF(ufunc->identity_value)`\r\n* `PyObject_GC_UnTrack((PyObject *)ufunc)`\r\n* `Py_DECREF(ufunc->obj)`\r\n\r\nis correct? Putting the untracking between decref seems asymmetric to me - I'd expect the decrefs to be adjacent, although I don't know if they belong before or after the gc",
        "createdAt" : "2018-12-18T08:00:26Z",
        "updatedAt" : "2019-01-09T12:58:01Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "a83c5c5b-6dc7-44b6-8ea2-a56d5a371124",
        "parentId" : "8d48ef84-3b34-460e-8669-1fc4612ce185",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Looking some more - I think you want to call `PyObject_GC_UnTrack` unconditionally now, and first",
        "createdAt" : "2018-12-18T08:14:16Z",
        "updatedAt" : "2019-01-09T12:58:01Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "b06cc9a2-ca45-4e8d-8c2c-4069c1ac4dcd",
        "parentId" : "8d48ef84-3b34-460e-8669-1fc4612ce185",
        "authorId" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "body" : "The [documentation](https://docs.python.org/3/c-api/gcsupport.html#c._PyObject_GC_TRACK) supports your claim. Refactoring.",
        "createdAt" : "2018-12-18T09:52:08Z",
        "updatedAt" : "2019-01-09T12:58:01Z",
        "lastEditedBy" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "tags" : [
        ]
      }
    ],
    "commit" : "82419c00ed41899990d8a0d332535d246edc4147",
    "line" : 69,
    "diffHunk" : "@@ -1,1 +5310,5314 @@    }\n    if (ufunc->obj != NULL) {\n        Py_DECREF(ufunc->obj);\n    }\n    PyObject_GC_Del(ufunc);"
  },
  {
    "id" : "0cad3eb9-3508-4779-81cf-bc90022baa8f",
    "prId" : 11977,
    "prUrl" : "https://github.com/numpy/numpy/pull/11977#pullrequestreview-186013985",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c3961c23-7954-48df-b243-849d09555704",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "I think you also need to set `tp_del` to `PyObject_GC_Del`, but I'm not certain.",
        "createdAt" : "2018-12-18T08:19:12Z",
        "updatedAt" : "2019-01-09T12:58:01Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "deea157b-df36-42e9-b6fd-fe81c1f2038f",
        "parentId" : "c3961c23-7954-48df-b243-849d09555704",
        "authorId" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "body" : "`tp_free` is set to `PyObject_GC_Del`. `tp_del` [seems to be for internal use only and obsolete](https://bugs.python.org/issue4934).",
        "createdAt" : "2018-12-18T11:05:13Z",
        "updatedAt" : "2019-01-09T12:58:01Z",
        "lastEditedBy" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "tags" : [
        ]
      }
    ],
    "commit" : "82419c00ed41899990d8a0d332535d246edc4147",
    "line" : 99,
    "diffHunk" : "@@ -1,1 +6048,6052 @@    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC,    /* tp_flags */\n    0,                                          /* tp_doc */\n    (traverseproc)ufunc_traverse,               /* tp_traverse */\n    0,                                          /* tp_clear */\n    0,                                          /* tp_richcompare */"
  },
  {
    "id" : "16db5821-f5db-4536-951c-ea287ae87cf7",
    "prId" : 12219,
    "prUrl" : "https://github.com/numpy/numpy/pull/12219#pullrequestreview-180501901",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "82cbbb61-e426-45d2-a8b0-15f466b82c12",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Can you use `n_ops.matmul` here instead?",
        "createdAt" : "2018-11-30T06:25:18Z",
        "updatedAt" : "2018-12-03T17:44:04Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "f71d834f-0aef-4a9e-bdbb-ea3de1423fc2",
        "parentId" : "82cbbb61-e426-45d2-a8b0-15f466b82c12",
        "authorId" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "body" : "not cleanly",
        "createdAt" : "2018-12-01T01:04:28Z",
        "updatedAt" : "2018-12-03T17:44:04Z",
        "lastEditedBy" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "tags" : [
        ]
      }
    ],
    "commit" : "18476f5285bdd3f1405086e37240a9bd2640ff16",
    "line" : 9,
    "diffHunk" : "@@ -1,1 +325,329 @@set_matmul_flags(PyObject *d)\n{\n    PyObject *matmul = PyDict_GetItemString(d, \"matmul\");\n    if (matmul == NULL) {\n        return -1;"
  },
  {
    "id" : "02a91897-4a14-4e39-b201-024d2d9165aa",
    "prId" : 12624,
    "prUrl" : "https://github.com/numpy/numpy/pull/12624#pullrequestreview-188415732",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5c00d25f-94ff-457d-9353-ca2f892c5800",
        "parentId" : null,
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "Darn, that's quite dumb of me, having it in the failure path but not in the main one.",
        "createdAt" : "2018-12-29T16:27:16Z",
        "updatedAt" : "2019-01-02T19:17:23Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      }
    ],
    "commit" : "4732c1be2da093711ab544f6e0a302b9d7ee4bcb",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +3064,3068 @@    Py_XDECREF(full_args.in);\n    Py_XDECREF(full_args.out);\n    PyArray_free(remap_axis_memory);\n    PyArray_free(remap_axis);\n"
  },
  {
    "id" : "b896cdec-2904-4266-ae75-e753cc4c78d8",
    "prId" : 12644,
    "prUrl" : "https://github.com/numpy/numpy/pull/12644#pullrequestreview-189074040",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f3897aa6-52a6-41ab-9498-afc0817d01a3",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Possibly clearer to transpose the two loops here:\r\n```C++\r\nnpy_intp i = 0;\r\nwhile (i < count) {\r\n    /* Find where the mask changes */\r\n    char mask = *maskptr;\r\n    npy_intp i_next;\r\n    if (mask_stride == 0) {\r\n        /* optimization */\r\n        i_next = count;\r\n    }\r\n    else {\r\n        i_next = i;\r\n        while (mask == *maskptr && i_next < count) {\r\n            i_next++;\r\n            maskptr += mask_stride;\r\n        }\r\n    }\r\n    /* Copy the last contiguous region */\r\n    npy_intp n = i_next - i;\r\n    if (mask) {\r\n        innerloop(dataptrs_copy, &n,\r\n                  strides_copy, innerloopdata);\r\n    }\r\n    dataptrs_copy[0] += n * strides[0];\r\n    dataptrs_copy[1] += n * strides[1];\r\n    dataptrs_copy[2] = dataptrs_copy[0];\r\n    i = i_next;\r\n}\r\n```\r\n\r\nYou can also leave the stride == 0 optimization to the compiler:\r\n```C\r\nwhile (count > 0) {\r\n    /* Find where the mask changes */\r\n    char mask = *maskptr;\r\n    npy_intp n = find(maskptr, count, mask_stride, !mask);\r\n\r\n    /* Copy the last contiguous region */\r\n    if (mask) {\r\n        innerloop(dataptrs_copy, &n,\r\n                  strides_copy, innerloopdata);\r\n    }\r\n    dataptrs_copy[0] += n * strides[0];\r\n    dataptrs_copy[1] += n * strides[1];\r\n    maskptr          += n * mask_stride\r\n    dataptrs_copy[2] = dataptrs_copy[0];\r\n    count -= n;\r\n}\r\n\r\n/** Find the first index of `value` in `data`, or `n` if none exists */\r\nstatic inline npy_intp\r\nfind(npy_bool *data, npy_intp n, npy_intp stride, bool value) {\r\n    /* let the compiler optimize for zero stride */\r\n    if (stride == 0){\r\n        return find_inner(data, n, stride, value);\r\n    }\r\n    else {\r\n        return find_inner(data, n, stride, value);\r\n    }\r\n}\r\n\r\nstatic inline npy_intp\r\nfind_inner(npy_bool *data, npy_intp n, npy_intp stride, bool value) {\r\n    for (npy_intp i = 0; i < n; i++, data += stride) {\r\n        if (*data == value) {\r\n            return i;\r\n        }\r\n    }\r\n    return n;\r\n}\r\n```",
        "createdAt" : "2019-01-03T14:23:45Z",
        "updatedAt" : "2019-01-03T22:33:15Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "ba5089bb-e96b-48d4-979d-2dc09289ca73",
        "parentId" : "f3897aa6-52a6-41ab-9498-afc0817d01a3",
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "I like the version that does not rely on the compiler to optimize and adopted an even simpler version of it. It makes the case where the mask is all-true quite a bit faster:\r\n```\r\na = np.arange(100000.)\r\nm = ~np.isnan(a)\r\n%timeit np.add.reduce(a, where=m)\r\n# 90 -> 70 us\r\n```\r\nAdding either `a[::100] = np.nan` or `a[::2] = np.nan`, the timings stay basically the same.",
        "createdAt" : "2019-01-03T15:17:13Z",
        "updatedAt" : "2019-01-03T22:33:15Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      },
      {
        "id" : "646a4c2e-da34-4c84-ac46-f294c07568f5",
        "parentId" : "f3897aa6-52a6-41ab-9498-afc0817d01a3",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "To be clear - changing from the version this comment was added on to the latest version gives that speed boost? Or the `stride=0` optimization gives that speed up in either case?",
        "createdAt" : "2019-01-03T15:31:10Z",
        "updatedAt" : "2019-01-03T22:33:15Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "e4dbfae4-5e81-46d5-8660-a48f9cd94d64",
        "parentId" : "f3897aa6-52a6-41ab-9498-afc0817d01a3",
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "The change in version (i.e., the last commit) is what gave the speed boost - it has nothing to do with the `stride=0` optimization (the mask has a stride in my example, it is just set to all True). I'm actually rather confused why there is such a speed-up, it must be that the compiler can make the inner `where` loop substantially faster than the large loop with a complex but unlikely if clause.\r\n\r\np.s. For the record, the timings for the `stride=0` case do not change.",
        "createdAt" : "2019-01-03T15:53:09Z",
        "updatedAt" : "2019-01-03T22:33:15Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      },
      {
        "id" : "401120c4-1da5-4f66-a2d9-89f1b60a7c69",
        "parentId" : "f3897aa6-52a6-41ab-9498-afc0817d01a3",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "> I'm actually rather confused why there is such a speed-up\r\n\r\nSo was I, hence the request for clarification!",
        "createdAt" : "2019-01-03T16:06:44Z",
        "updatedAt" : "2019-01-03T22:33:15Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "5afe650403bdb3aa1a3189c1b8c3233501208521",
    "line" : 50,
    "diffHunk" : "@@ -1,1 +3565,3569 @@                count -= n;\n                n = 1;\n            }\n        }\n    } while (iternext(iter));"
  },
  {
    "id" : "03a62553-5c8f-493b-98f2-166ed3b472ba",
    "prId" : 12932,
    "prUrl" : "https://github.com/numpy/numpy/pull/12932#pullrequestreview-202330452",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b22ff3db-4e95-42b5-a944-a11303db92da",
        "parentId" : null,
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "At least from the code here, it looks like one can in principle have had the last in the chain have `cmp == 0` but `last->arg_dtypes != NULL`.\r\n\r\nTotal nitpick: could you put `current != NULL` at the start?  Or perhaps this is clearer if inverted\r\n```\r\nif (current == NULL || !(cmp == 0 && current->arg_dtypes == NULL)) {\r\n    result = -1;\r\n}\r\nelse {\r\n    ...\r\n}\r\n```",
        "createdAt" : "2019-02-05T17:38:55Z",
        "updatedAt" : "2019-02-11T21:54:35Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      },
      {
        "id" : "7fe3464c-9df6-4363-bf95-fe6e14520af6",
        "parentId" : "b22ff3db-4e95-42b5-a944-a11303db92da",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "This whole function looks to be in a poor state to me, and will return `-1` without setting an exception.",
        "createdAt" : "2019-02-05T18:00:15Z",
        "updatedAt" : "2019-02-11T21:54:35Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "01968c4a-e037-4544-ae89-506174a347da",
        "parentId" : "b22ff3db-4e95-42b5-a944-a11303db92da",
        "authorId" : "ddc821e4-cfa5-46f2-9e84-c47d803eabba",
        "body" : "> will return `-1` without setting an exception\r\n\r\nI noticed that too, but in the few cases the `PyUFunc_RegisterLoopForDescr` is used there's a if `(!PyErr_Occurred()) { PyErr_SetString(PyExc_RuntimeError...` or the output is not checked at all.",
        "createdAt" : "2019-02-05T18:12:34Z",
        "updatedAt" : "2019-02-11T21:54:35Z",
        "lastEditedBy" : "ddc821e4-cfa5-46f2-9e84-c47d803eabba",
        "tags" : [
        ]
      },
      {
        "id" : "ce3b7c89-1546-46e4-a97a-fe641e66bde2",
        "parentId" : "b22ff3db-4e95-42b5-a944-a11303db92da",
        "authorId" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "body" : "added a test that reaches the \"return -1\", added exception string",
        "createdAt" : "2019-02-11T20:51:07Z",
        "updatedAt" : "2019-02-11T21:54:35Z",
        "lastEditedBy" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "tags" : [
        ]
      }
    ],
    "commit" : "f07adb36c377bf979bc348f67f5fe4351c2430ab",
    "line" : 23,
    "diffHunk" : "@@ -1,1 +5182,5186 @@                current = current->next;\n            }\n            if (cmp == 0 && current != NULL && current->arg_dtypes == NULL) {\n                current->arg_dtypes = PyArray_malloc(ufunc->nargs *\n                    sizeof(PyArray_Descr*));"
  },
  {
    "id" : "6e16b61c-b601-4f16-98d4-a51a30995875",
    "prId" : 12932,
    "prUrl" : "https://github.com/numpy/numpy/pull/12932#pullrequestreview-202351252",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ff8ee0cc-4f53-4e05-8703-c5fc95343f20",
        "parentId" : null,
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Shouldn't this be a RuntimeError (although considering the discussion, it is good to know it didn't get replaced)?",
        "createdAt" : "2019-02-11T21:04:17Z",
        "updatedAt" : "2019-02-11T21:54:35Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "41631c78-20fd-4d39-b4fe-fcec759450a2",
        "parentId" : "ff8ee0cc-4f53-4e05-8703-c5fc95343f20",
        "authorId" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "body" : "ok, changing",
        "createdAt" : "2019-02-11T21:38:18Z",
        "updatedAt" : "2019-02-11T21:54:35Z",
        "lastEditedBy" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "tags" : [
        ]
      }
    ],
    "commit" : "f07adb36c377bf979bc348f67f5fe4351c2430ab",
    "line" : 32,
    "diffHunk" : "@@ -1,1 +5201,5205 @@            else {\n                PyErr_SetString(PyExc_RuntimeError,\n                    \"loop already registered\");\n                result = -1;\n            }"
  },
  {
    "id" : "393947a7-3ba3-4d8a-918f-50d15e0bb1af",
    "prId" : 13323,
    "prUrl" : "https://github.com/numpy/numpy/pull/13323#pullrequestreview-226367896",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "53f207a4-5175-4f2a-b3c6-99367c2ed6aa",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Not all that surprised by this bug, given the variable is not used until 200 lines later. I suppose we can't use C99 declarations yet, since this will be backported.",
        "createdAt" : "2019-04-13T20:19:17Z",
        "updatedAt" : "2019-04-13T20:19:18Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "6dac2d6a4a061a39cc41f93641c0c29085cd10a6",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +5573,5577 @@    PyUFuncGenericFunction innerloop;\n    void *innerloopdata;\n    npy_intp i;\n    int nop;\n"
  },
  {
    "id" : "e798860e-1e3e-4dd0-9460-9b1e0c8d3d1a",
    "prId" : 15271,
    "prUrl" : "https://github.com/numpy/numpy/pull/15271#pullrequestreview-616919542",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d561ab30-eb6f-4b58-bc24-2112d2de4a0f",
        "parentId" : null,
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "Maybe note that it returns `0` on failure?",
        "createdAt" : "2021-03-20T15:47:00Z",
        "updatedAt" : "2021-03-24T00:05:12Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      }
    ],
    "commit" : "bebf5c891cb1c547b6de97ecd48af66853841028",
    "line" : 966,
    "diffHunk" : "@@ -1,1 +4057,4061 @@ * Convert function which replaces np._NoValue with NULL.\n * As a converter returns 0 on error and 1 on success.\n */\nstatic int\n_not_NoValue(PyObject *obj, PyObject **out)"
  },
  {
    "id" : "76133b16-e5a4-4199-9a17-b3a850561bbf",
    "prId" : 15271,
    "prUrl" : "https://github.com/numpy/numpy/pull/15271#pullrequestreview-618979597",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d452ebe3-28ba-4783-a2b0-5956fca3536a",
        "parentId" : null,
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "Could we remove it already? (probably best in a follow-up PR... if not very soon, maybe good to have an issue with an appropriate version deadline?)",
        "createdAt" : "2021-03-20T16:06:15Z",
        "updatedAt" : "2021-03-24T00:05:12Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      },
      {
        "id" : "cf80a7a5-1152-4250-9535-598f2596bd7d",
        "parentId" : "d452ebe3-28ba-4783-a2b0-5956fca3536a",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Yes, we can I think. But as you said, lets do it in a followup.  Normal is 2 versions of deprecation, which is now what we got.",
        "createdAt" : "2021-03-22T22:12:24Z",
        "updatedAt" : "2021-03-24T00:05:12Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "d3c4b0e6-b44b-4ad8-b7e3-2d5bfae76c8a",
        "parentId" : "d452ebe3-28ba-4783-a2b0-5956fca3536a",
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "OK, sounds good!",
        "createdAt" : "2021-03-23T19:29:28Z",
        "updatedAt" : "2021-03-24T00:05:12Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      }
    ],
    "commit" : "bebf5c891cb1c547b6de97ecd48af66853841028",
    "line" : 846,
    "diffHunk" : "@@ -1,1 +2853,2857 @@        PyObject *args, PyObject *kwds, PyArrayObject **op)\n{\n    /* NumPy 1.19, 2020-01-24 */\n    if (DEPRECATE(\n                \"PyUFunc_GenericFunction() C-API function is deprecated \""
  },
  {
    "id" : "38a1fe36-8c61-45ba-a7da-0b85b9937435",
    "prId" : 15271,
    "prUrl" : "https://github.com/numpy/numpy/pull/15271#pullrequestreview-618956613",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f525f795-e78e-4147-95e7-94b44fa745ba",
        "parentId" : null,
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "Should this be before `PyArg_ParseTuple`, perhaps with just a check that `if (ufunc->nin == 2 && PyTuple_GET_SIZE(args) < 3)`?",
        "createdAt" : "2021-03-20T16:51:06Z",
        "updatedAt" : "2021-03-24T00:05:12Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      },
      {
        "id" : "041a212b-466a-475e-9823-cfa5b81b689e",
        "parentId" : "f525f795-e78e-4147-95e7-94b44fa745ba",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "This seems a bit more symmetric since in all other cases we parse arguments first now? I think I slightly prefer to keep it.",
        "createdAt" : "2021-03-22T22:17:45Z",
        "updatedAt" : "2021-03-24T00:05:12Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "a9fb6c90-ac38-48bd-b6cb-316eb4c505a1",
        "parentId" : "f525f795-e78e-4147-95e7-94b44fa745ba",
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "OK, that makes sense. Looking again, I see you indeed only get objects out (like elsewhere), so presumably that is very quick.",
        "createdAt" : "2021-03-23T18:52:07Z",
        "updatedAt" : "2021-03-24T00:05:12Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      }
    ],
    "commit" : "bebf5c891cb1c547b6de97ecd48af66853841028",
    "line" : 1982,
    "diffHunk" : "@@ -1,1 +5758,5762 @@        return NULL;\n    }\n    errval = PyUFunc_CheckOverride(ufunc, \"at\",\n            args, NULL, NULL, 0, NULL, &override);\n"
  },
  {
    "id" : "66897ba5-c8b3-483c-99fe-995248c7d6ab",
    "prId" : 15271,
    "prUrl" : "https://github.com/numpy/numpy/pull/15271#pullrequestreview-619054146",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "69d007a9-e0ea-4041-b9bb-59f42bb14953",
        "parentId" : null,
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "Is it worrying that this is stated not to be covered?",
        "createdAt" : "2021-03-23T20:02:23Z",
        "updatedAt" : "2021-03-24T00:05:12Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      },
      {
        "id" : "43548f85-9b4e-4fe9-bc91-577396f2ccd4",
        "parentId" : "69d007a9-e0ea-4041-b9bb-59f42bb14953",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Weird, it definitely is tested.  Changing the `NPY_NO_EXPORT` to `static` since that seems unnecessary. Maybe that helps, otherwise it is a coverage false-positive.",
        "createdAt" : "2021-03-23T20:40:14Z",
        "updatedAt" : "2021-03-24T00:05:12Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      }
    ],
    "commit" : "bebf5c891cb1c547b6de97ecd48af66853841028",
    "line" : 180,
    "diffHunk" : "@@ -1,1 +855,859 @@ */\nstatic int\n_subok_converter(PyObject *obj, npy_bool *subok)\n{\n    if (PyBool_Check(obj)) {"
  },
  {
    "id" : "0e30b757-a9a0-4aad-802d-a23c2df13119",
    "prId" : 17112,
    "prUrl" : "https://github.com/numpy/numpy/pull/17112#pullrequestreview-471433042",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a77d54d4-57a2-432e-a870-2e73492125e3",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "This is a bit sloppy, but  it seemed less invasive that putting the entire section below in an `if`",
        "createdAt" : "2020-08-20T09:45:37Z",
        "updatedAt" : "2020-08-20T09:45:37Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "59723b6a76ed6b16b7fd72933b278aa25d09c08b",
    "line" : 30,
    "diffHunk" : "@@ -1,1 +5197,5201 @@            if (current == NULL) {\n                result = -1;\n                goto done;\n            }\n            while (current != NULL) {"
  },
  {
    "id" : "cc733c4c-cc4b-4a23-aaa6-0786546e1e3b",
    "prId" : 18450,
    "prUrl" : "https://github.com/numpy/numpy/pull/18450#pullrequestreview-602380357",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "82715ee8-8404-4bc6-bf51-7a36b12ac60c",
        "parentId" : null,
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "This break needs to be a `goto finish` or so. Pandas is running into this in their CI.  Will look into it tomorrow at the latest, but the only tricky thing is that it might be nice to have a test.\r\n\r\nxref: https://github.com/pandas-dev/pandas/pull/40158",
        "createdAt" : "2021-03-02T00:30:57Z",
        "updatedAt" : "2021-03-02T00:31:18Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "02d3ef34-8ed1-4a13-943b-d417219c6a2b",
        "parentId" : "82715ee8-8404-4bc6-bf51-7a36b12ac60c",
        "authorId" : "a4f03a99-2e43-482b-a9bc-5a9e359abb03",
        "body" : "I'm going to check it out now and make a test+PR, unless you already have it done",
        "createdAt" : "2021-03-02T18:27:26Z",
        "updatedAt" : "2021-03-02T18:27:52Z",
        "lastEditedBy" : "a4f03a99-2e43-482b-a9bc-5a9e359abb03",
        "tags" : [
        ]
      },
      {
        "id" : "0ac144f6-245b-4520-9180-cd1042ee576a",
        "parentId" : "82715ee8-8404-4bc6-bf51-7a36b12ac60c",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Thanks, I thought a test would be more complicated for some reason.  I think the `iternext` technically also should be checked, although I am willing to bet is not a regression.",
        "createdAt" : "2021-03-02T23:52:21Z",
        "updatedAt" : "2021-03-02T23:52:21Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      }
    ],
    "commit" : "5d864e872060c37308c2fd3ca75508838161061e",
    "line" : 64,
    "diffHunk" : "@@ -1,1 +3526,3530 @@\n            if (needs_api && PyErr_Occurred()) {\n                break;\n            }\n"
  },
  {
    "id" : "1b798732-ff3f-4f39-9721-ec38478a74ad",
    "prId" : 18479,
    "prUrl" : "https://github.com/numpy/numpy/pull/18479#pullrequestreview-597533541",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "41fd1a5d-910c-4a7e-b842-3e2d9cc04822",
        "parentId" : null,
        "authorId" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "body" : "I guess the assignment `current->nargs = ufunc->nargs;` is harmless, but it might be better to future-proof this by adding `goto done;` when an error condition is reached.",
        "createdAt" : "2021-02-24T14:25:26Z",
        "updatedAt" : "2021-02-24T14:57:14Z",
        "lastEditedBy" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "tags" : [
        ]
      }
    ],
    "commit" : "e2740334e8f205faee2e307db44bcc2c65ca586e",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +5222,5226 @@                if (current->arg_dtypes == NULL) {\n                    PyErr_NoMemory();\n                    result = -1;\n                    goto done;\n                }"
  },
  {
    "id" : "d0c2cb81-09c8-4874-a0f3-7296b1374835",
    "prId" : 18479,
    "prUrl" : "https://github.com/numpy/numpy/pull/18479#pullrequestreview-597657687",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d10f02d4-bf9a-4c3b-90fb-833d05252d45",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "The `else` isn't needed here.",
        "createdAt" : "2021-02-24T16:12:21Z",
        "updatedAt" : "2021-02-24T16:12:22Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "e2740334e8f205faee2e307db44bcc2c65ca586e",
    "line" : 10,
    "diffHunk" : "@@ -1,1 +5225,5229 @@                    goto done;\n                }\n                else if (arg_dtypes != NULL) {\n                    for (i = 0; i < ufunc->nargs; i++) {\n                        current->arg_dtypes[i] = arg_dtypes[i];"
  },
  {
    "id" : "3e4e578c-9380-4c5a-80e4-03c8791a3b58",
    "prId" : 18836,
    "prUrl" : "https://github.com/numpy/numpy/pull/18836#pullrequestreview-642618712",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c11e6e74-6f7a-43a3-92a2-7f839b3f9bb5",
        "parentId" : null,
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "This maybe the trickiest logic in the whole PR. And maybe it should use an `&` (the code in `NewFromDescr` is _weird_ about this).  But the test suit unsurprisingly finds many errors if you just pass 0 always here, so its fine.",
        "createdAt" : "2021-04-22T20:02:50Z",
        "updatedAt" : "2021-05-05T02:21:01Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      }
    ],
    "commit" : "134063c0353546729f885e37aa28e2e1b13ac4ae",
    "line" : 160,
    "diffHunk" : "@@ -1,1 +1197,1201 @@        op[nin] = (PyArrayObject *) PyArray_NewFromDescr(&PyArray_Type,\n                dtypes[nin], operation_ndim, operation_shape,\n                NULL, NULL, operation_order==NPY_ARRAY_F_CONTIGUOUS, NULL);\n        if (op[nin] == NULL) {\n            return -1;"
  },
  {
    "id" : "ffcf1b6c-c0cc-45e2-ade8-769002082dda",
    "prId" : 18864,
    "prUrl" : "https://github.com/numpy/numpy/pull/18864#pullrequestreview-646361951",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "13c935d2-aa97-412d-8435-dc06cf507394",
        "parentId" : null,
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "No point in iterating through all, `op[i]` cannot be NULL unless `i >= nin`.",
        "createdAt" : "2021-04-27T21:09:25Z",
        "updatedAt" : "2021-04-27T21:58:52Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "a006c496-6d0b-4353-8d0a-067ee5c96054",
        "parentId" : "13c935d2-aa97-412d-8435-dc06cf507394",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Frankly, this could be moved into the later loop, but for clarity, I wasn't sure that would actually be better...",
        "createdAt" : "2021-04-27T21:09:57Z",
        "updatedAt" : "2021-04-27T21:58:52Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      }
    ],
    "commit" : "18ffb74487c0e121a369fd8b4e2824caa7a20b95",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +2458,2462 @@    {\n        PyArrayObject **operands = NpyIter_GetOperandArray(iter);\n        for (i = nin; i < nop; ++i) {\n            if (op[i] == NULL) {\n                op[i] = operands[i];"
  },
  {
    "id" : "6fe45019-a9d5-4c65-8711-a843eb1e8b26",
    "prId" : 19257,
    "prUrl" : "https://github.com/numpy/numpy/pull/19257#pullrequestreview-684554422",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3c3cb1f9-ab8c-489d-a21d-9bae860c33ee",
        "parentId" : null,
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Not NULL'ing everything seemed a small but noticable micro-optimization.  This could probably be continued to use `alloca` (which would make this a single large memset).\r\n\r\nMoves around `wheremask` which should be a ref-count fix for stranger error paths.",
        "createdAt" : "2021-06-15T22:49:00Z",
        "updatedAt" : "2021-06-15T22:49:00Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      }
    ],
    "commit" : "e40f1dd7e6651b7deec2aa5f826aeb27a4f6cee5",
    "line" : 380,
    "diffHunk" : "@@ -1,1 +4661,4665 @@    memset(operands, 0, nop * sizeof(*operands));\n    memset(operation_descrs, 0, nop * sizeof(*operation_descrs));\n    memset(output_array_prepare, 0, nout * sizeof(*output_array_prepare));\n\n    /*"
  },
  {
    "id" : "ea2ea90f-f647-4861-97b4-516680f0a100",
    "prId" : 19257,
    "prUrl" : "https://github.com/numpy/numpy/pull/19257#pullrequestreview-686696352",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a90d92fe-1966-4e85-b527-2d579a10670b",
        "parentId" : null,
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "It is a bit annoying, but just to note that the whole `execute_fancy_ufunc_loop` is deleted in the follow-up.",
        "createdAt" : "2021-06-17T18:59:20Z",
        "updatedAt" : "2021-06-17T18:59:20Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      }
    ],
    "commit" : "e40f1dd7e6651b7deec2aa5f826aeb27a4f6cee5",
    "line" : 54,
    "diffHunk" : "@@ -1,1 +1558,1562 @@         * was changed by prepare_ufunc_output.\n         */\n        op[i+nin] = op_tmp;\n    }\n"
  },
  {
    "id" : "d452ad36-6150-4da1-9f54-46247186b342",
    "prId" : 19258,
    "prUrl" : "https://github.com/numpy/numpy/pull/19258#pullrequestreview-686805025",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f7d13a21-3e97-4ea5-a2a7-d5315dc39c6b",
        "parentId" : null,
        "authorId" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "body" : "What happened to the `NpyIter_Deallocate(iter);` ?",
        "createdAt" : "2021-06-17T20:01:26Z",
        "updatedAt" : "2021-06-17T20:01:26Z",
        "lastEditedBy" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "tags" : [
        ]
      },
      {
        "id" : "2566a38c-4d44-47b4-a890-0a6545910705",
        "parentId" : "f7d13a21-3e97-4ea5-a2a7-d5315dc39c6b",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Bug, must have lost it while trying to make the various versions of this look more similar. Thanks!",
        "createdAt" : "2021-06-17T20:45:34Z",
        "updatedAt" : "2021-06-17T20:45:35Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "ed42bbac-20e9-4cfd-91c1-b29d3e2fa5cf",
        "parentId" : "f7d13a21-3e97-4ea5-a2a7-d5315dc39c6b",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "(Fixed)",
        "createdAt" : "2021-06-17T20:45:49Z",
        "updatedAt" : "2021-06-17T20:45:49Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      }
    ],
    "commit" : "23600c612624112284e0523dde95a13570862798",
    "line" : 82,
    "diffHunk" : "@@ -1,1 +1318,1322 @@            /* Call the __array_prepare__ functions for the new array */\n            if (prepare_ufunc_output(ufunc,\n                    &op[nin + i], arr_prep[i], full_args, i) < 0) {\n                NpyIter_Deallocate(iter);\n                return -1;"
  },
  {
    "id" : "d7d8001e-4909-429b-878b-13cbb63fd136",
    "prId" : 19258,
    "prUrl" : "https://github.com/numpy/numpy/pull/19258#pullrequestreview-686816269",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "cc3ab982-509f-40d3-965e-796a41d7ed2d",
        "parentId" : null,
        "authorId" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "body" : "wow, the original `NPY_BEGIN_THREADS_NDITER` is a very convoluted macro. Glad to see it gone here.",
        "createdAt" : "2021-06-17T21:00:53Z",
        "updatedAt" : "2021-06-17T21:00:53Z",
        "lastEditedBy" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "tags" : [
        ]
      }
    ],
    "commit" : "23600c612624112284e0523dde95a13570862798",
    "line" : 159,
    "diffHunk" : "@@ -1,1 +1375,1379 @@    if (!needs_api) {\n        NPY_BEGIN_THREADS_THRESHOLDED(full_size);\n    }\n\n    NPY_UF_DBG_PRINT(\"Actual inner loop:\\n\");"
  },
  {
    "id" : "48526165-5741-4c92-aeaa-1b7c18ac48f9",
    "prId" : 19259,
    "prUrl" : "https://github.com/numpy/numpy/pull/19259#pullrequestreview-686915876",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7a806a68-11d2-4449-bdae-783e34cacc27",
        "parentId" : null,
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "In case anyone wonders: Currently at this point `needs_api` is never set (passing it earlier is a well intentioned no-op).  But the future can see that happening, the concept is good. (Except that `NpyIter_IterationNeedsAPI` is not perfect either right now.)",
        "createdAt" : "2021-06-17T23:11:47Z",
        "updatedAt" : "2021-06-17T23:11:48Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      }
    ],
    "commit" : "061ac77a06edbc503bb552e4d4ca6729d524c861",
    "line" : 138,
    "diffHunk" : "@@ -1,1 +1432,1436 @@    npy_intp *strides = NpyIter_GetInnerStrideArray(iter);\n    npy_intp *countptr = NpyIter_GetInnerLoopSizePtr(iter);\n    needs_api |= NpyIter_IterationNeedsAPI(iter);\n\n    NPY_BEGIN_THREADS_DEF;"
  },
  {
    "id" : "13aad167-98f4-4e18-9ec7-e5e8f807b1e2",
    "prId" : 19262,
    "prUrl" : "https://github.com/numpy/numpy/pull/19262#pullrequestreview-686500943",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "17596ce3-2abc-4211-8700-6e3058734a6b",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "You could also put `ufunc, ` on this line.",
        "createdAt" : "2021-06-17T00:27:27Z",
        "updatedAt" : "2021-06-17T00:27:27Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "dda20a66-c302-4b87-96f0-e28c74eec36c",
        "parentId" : "17596ce3-2abc-4211-8700-6e3058734a6b",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Yeah, I have been using this style quite a bit for `self`-like arguments (keeping them on the same line).\r\n\r\nHappy to try and change that habit, or you may just have to do a style cleanup at some point :).",
        "createdAt" : "2021-06-17T16:00:33Z",
        "updatedAt" : "2021-06-17T16:00:33Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      }
    ],
    "commit" : "28dceccde97af2554dd151d8ea879997f171c08f",
    "line" : 46,
    "diffHunk" : "@@ -1,1 +4308,4312 @@        }\n        ret = (PyArrayObject *)PyUFunc_Reduceat(ufunc,\n                mp, indices, out, axes[0], otype->type_num);\n        Py_SETREF(indices, NULL);\n        break;"
  },
  {
    "id" : "f0275a16-901a-4c3c-b31a-04851f73c12b",
    "prId" : 19289,
    "prUrl" : "https://github.com/numpy/numpy/pull/19289#pullrequestreview-692187688",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "23f68374-0795-4c89-9bb4-3f34424e61bc",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "A bit of explanation would be good here. I assume that dtype already holds a reference to the singleton member and cleans that up when dtype is destroyed. True? Might read better  like \r\n```\r\n       otype = dtype->singleton;\r\n       Py_INCREF(otype);\r\n       Py_DECREF(dtype);\r\n```",
        "createdAt" : "2021-06-24T02:11:26Z",
        "updatedAt" : "2021-06-24T02:11:45Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "42900728-deea-4ed0-8eaf-c7132d7b2d1a",
        "parentId" : "23f68374-0795-4c89-9bb4-3f34424e61bc",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Yeah, that is better.  This is a bit weird: `singleton` is guaranteed to exist and `dtype` can never be destroyed because this is limited to \"old-style\" DTypes.\r\n\r\nThis code is simply not yet new-style user `DType` ready.  The whole dance will vanish (or rather: move into legacy-only fallback branches) with the ufunc refactor.  Until then, this is a bit awkward because I try to introduce the new logic step-by-step.",
        "createdAt" : "2021-06-24T20:15:41Z",
        "updatedAt" : "2021-06-24T20:16:03Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      }
    ],
    "commit" : "b4706fa31f1b852f4807b2c09d5da8e4c68e9e5a",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +4055,4059 @@        otype = dtype->singleton;\n        Py_INCREF(otype);\n        Py_DECREF(dtype);\n    }\n    if (out_obj && !PyArray_OutputConverter(out_obj, &out)) {"
  },
  {
    "id" : "b75495ab-ef6a-4a6d-83fc-b214fb22cc69",
    "prId" : 19371,
    "prUrl" : "https://github.com/numpy/numpy/pull/19371#pullrequestreview-695273955",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a373d223-730c-4191-8864-6a93e80bfd24",
        "parentId" : null,
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "We don't actually have to check casting here right now.  The type resolver is currently in charge of checking cast safety.",
        "createdAt" : "2021-06-28T23:54:12Z",
        "updatedAt" : "2021-06-28T23:54:12Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "37c38b00-e039-4768-816a-cc4ccdc2d8e7",
        "parentId" : "a373d223-730c-4191-8864-6a93e80bfd24",
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "I'm confused by the explanation of what's not needed. \r\n\r\nBut just looking at the code: I find the `must_copy` if not aligned or if a casting view is not possible a much clearer indication of what's happening than the `EquivTypes` before",
        "createdAt" : "2021-06-29T01:36:04Z",
        "updatedAt" : "2021-06-29T01:44:35Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      },
      {
        "id" : "e2d8409a-44f2-4cf7-9ae3-3d40cfee4ec7",
        "parentId" : "a373d223-730c-4191-8864-6a93e80bfd24",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Yeah, nevermind.  My comment was that you may expect checks for calls like `np.add(a, b, out=a, casting=\"safe\")` where `a` might not be a valid output based on the casting level provided.\r\n\r\nIn the later changes I actually move that check to here (I think).  Right now the ~indeed~ `Equiv` was indeed just a less clear spelling of \"view works\".",
        "createdAt" : "2021-06-29T16:48:32Z",
        "updatedAt" : "2021-06-29T16:49:32Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      }
    ],
    "commit" : "b26316b452367b637847105fe13aacd4e69bf9d3",
    "line" : 44,
    "diffHunk" : "@@ -1,1 +1017,1021 @@            if (!(safety & _NPY_CAST_IS_VIEW)) {\n                must_copy = 1;\n            }\n        }\n        if (must_copy) {"
  },
  {
    "id" : "8139fc64-cd04-412e-b2aa-a94e4cc15b73",
    "prId" : 19371,
    "prUrl" : "https://github.com/numpy/numpy/pull/19371#pullrequestreview-695382239",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3813e2d3-935f-4f88-bcee-ce92ee0c5979",
        "parentId" : null,
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "It is actually a bit weird that the copy is done here, possibly making a copy when the next argument could fail to be trivial and thus the effort wasted. Though I guess the logic is that the cast has to be done anyway even for a non-trivial loop and it might as well be done here? It still seems surprising for a `check` function...\r\n\r\nAnyway, that was here already, so no big deal!",
        "createdAt" : "2021-06-29T01:35:27Z",
        "updatedAt" : "2021-06-29T01:44:35Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      },
      {
        "id" : "319b7f8b-04aa-43ca-bdef-b4fc77185cb3",
        "parentId" : "3813e2d3-935f-4f88-bcee-ce92ee0c5979",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "The error paths are going to be oddly slow though. Otherwise its odd, but the effort is at least not quite wasted since it will safe work in `NpyIter`.",
        "createdAt" : "2021-06-29T16:40:28Z",
        "updatedAt" : "2021-06-29T16:40:29Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "5e4957f5-a446-429d-994d-b8684bab9741",
        "parentId" : "3813e2d3-935f-4f88-bcee-ce92ee0c5979",
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "I guess a slow error is not bad, and as you note, the effort is not wasted if everything succeeds. It remains odd to do it in a `check_*` function, but out of scope here!",
        "createdAt" : "2021-06-29T18:40:34Z",
        "updatedAt" : "2021-06-29T18:40:34Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      }
    ],
    "commit" : "b26316b452367b637847105fe13aacd4e69bf9d3",
    "line" : 46,
    "diffHunk" : "@@ -1,1 +1019,1023 @@            }\n        }\n        if (must_copy) {\n            /*\n             * If op[j] is a scalar or small one dimensional"
  }
]
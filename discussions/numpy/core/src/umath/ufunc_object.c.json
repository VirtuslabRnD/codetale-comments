[
  {
    "id" : "c799b2bd-a717-4c1b-950e-9b7362a687df",
    "prId" : 359,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "cb270be6-baf9-4f36-b28e-051246dd634b",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Success of memory allocation needs to be checked.\n",
        "createdAt" : "2013-04-01T18:13:58Z",
        "updatedAt" : "2013-05-10T16:48:13Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "1b70fbd7-b1d9-446c-a0ce-830f848f963d",
        "parentId" : "cb270be6-baf9-4f36-b28e-051246dd634b",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Still needs the NULL check. I there an error return available here?\n",
        "createdAt" : "2013-05-03T23:27:39Z",
        "updatedAt" : "2013-05-10T16:48:13Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "c3d71b11-b9f1-4bcd-973d-68f043d1e392",
        "parentId" : "cb270be6-baf9-4f36-b28e-051246dd634b",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Still missing check for allocation success.\n",
        "createdAt" : "2013-05-09T16:17:49Z",
        "updatedAt" : "2013-05-10T16:48:13Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "759d0632-95de-4fa6-a46f-e1ece3b6336e",
        "parentId" : "cb270be6-baf9-4f36-b28e-051246dd634b",
        "authorId" : "b0e7e584-a9be-4737-9003-4922807a34eb",
        "body" : "Somehow I missed these comments before. The op_flags allocation has a matching PyArray_free in the ufunc_dealloc function, but I do need one a few lines down if _parse_signature fails.\n",
        "createdAt" : "2013-05-09T16:33:44Z",
        "updatedAt" : "2013-05-10T16:48:13Z",
        "lastEditedBy" : "b0e7e584-a9be-4737-9003-4922807a34eb",
        "tags" : [
        ]
      },
      {
        "id" : "9a2a0869-63ce-4b5c-952c-9e808fcc81b3",
        "parentId" : "cb270be6-baf9-4f36-b28e-051246dd634b",
        "authorId" : "b0e7e584-a9be-4737-9003-4922807a34eb",
        "body" : "Nevermind, the op_flags will still be freed because ufunc_dealloc gets called if _parse_signature fails.\n",
        "createdAt" : "2013-05-09T16:53:50Z",
        "updatedAt" : "2013-05-10T16:48:13Z",
        "lastEditedBy" : "b0e7e584-a9be-4737-9003-4922807a34eb",
        "tags" : [
        ]
      }
    ],
    "commit" : "ec23d01d9c333f95db5d9349354766b38d37cae7",
    "line" : 172,
    "diffHunk" : "@@ -1,1 +4290,4294 @@    ufunc->doc = doc;\n\n    ufunc->op_flags = PyArray_malloc(sizeof(npy_uint32)*ufunc->nargs);\n    if (ufunc->op_flags == NULL) {\n        return PyErr_NoMemory();"
  },
  {
    "id" : "28bdc6a1-2a36-44a8-9261-9825c8fefd2a",
    "prId" : 359,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8baf09a8-c90d-4b4f-9f6a-a0a66a92286f",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "@seberg ISTR you may have done something relevant to this.\n",
        "createdAt" : "2013-05-09T16:16:30Z",
        "updatedAt" : "2013-05-10T16:48:13Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "9d08e0a6-58d6-4d86-a102-344824dd24c0",
        "parentId" : "8baf09a8-c90d-4b4f-9f6a-a0a66a92286f",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Yeah, my guess is, it can probably be removed. But would have to try too...\n",
        "createdAt" : "2013-05-09T17:00:59Z",
        "updatedAt" : "2013-05-10T16:48:13Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      }
    ],
    "commit" : "ec23d01d9c333f95db5d9349354766b38d37cae7",
    "line" : 144,
    "diffHunk" : "@@ -1,1 +2012,2016 @@     * If there are no iteration dimensions, create a fake one\n     * so that the scalar edge case works right.\n     */\n    if (iter_ndim == 0) {\n        iter_ndim = 1;"
  },
  {
    "id" : "2597e65f-4d90-42b0-8fde-953ba42b6dbc",
    "prId" : 462,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f20bd469-46ab-4df7-92d0-050c927d4943",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Allocation success needs a check.\n",
        "createdAt" : "2013-05-10T20:30:40Z",
        "updatedAt" : "2013-05-15T00:39:24Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "d85f7aa465cf854e2be83f67f39f058660348487",
    "line" : 132,
    "diffHunk" : "@@ -1,1 +4462,4466 @@    }\n\n    arg_typenums = PyArray_malloc(ufunc->nargs * sizeof(int));\n    if (arg_typenums == NULL) {\n        PyErr_NoMemory();"
  },
  {
    "id" : "89b4c023-8e66-4dba-bd03-fb34c5dc8e9c",
    "prId" : 2821,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7e791a53-2b54-4e42-8dd7-b7eeaaafa023",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Need extra indent. The `\\` can be dropped, no?, next line should line up with this one.\n",
        "createdAt" : "2013-04-28T01:33:04Z",
        "updatedAt" : "2013-08-16T21:44:21Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "68ec8d52-5ef7-4b57-ad60-8b205eb83f2f",
        "parentId" : "7e791a53-2b54-4e42-8dd7-b7eeaaafa023",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Can you use the new iterator here with the itershape argument? You could move the buffering/casting for the op2_array also into that iterator then as well using the op_dtypes. That would mean that the \"dummy\" casting iterator only needs to handle the first operand. Probably should check how to replace that with a direct call to the casting functions, but to be honest I don't care too much about that right now and if we add subspace iteration optimizations the dummy iterator wouldn't be quite as dummy any more for those.\n",
        "createdAt" : "2013-05-27T14:25:31Z",
        "updatedAt" : "2013-08-16T21:44:21Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      }
    ],
    "commit" : "acef718f40a30188c1379c13cc49c920d9e7c303",
    "line" : 102,
    "diffHunk" : "@@ -1,1 +4948,4952 @@         */\n        if ((iter2 = (PyArrayIterObject *)\\\n             PyArray_BroadcastToShape((PyObject *)op2_array,\n                                        iter->dimensions, iter->nd))==NULL) {\n            goto fail;"
  },
  {
    "id" : "9a33e67e-5026-4e58-8b3a-0b43c64faefb",
    "prId" : 2821,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0efc491e-d7a4-4fb5-b789-a8fab644ff80",
        "parentId" : null,
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Question: What happens if we have an object array and we get an error during the ufunc call? Such as:\n\n```\na = np.array([1, 2], dtype=object)\nb = np.array(['a'])\nnp.add.at(a, [0], b)\n```\n\nWhen api is needed, the inner loop can return an error I think? I m not sure how this is handled in the ufunc machinery, but I suspect we may need to add some magic in that case.\n",
        "createdAt" : "2013-08-05T16:35:55Z",
        "updatedAt" : "2013-08-16T21:44:21Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "c33f6422-c601-4ec3-ac02-14c212e2d6e6",
        "parentId" : "0efc491e-d7a4-4fb5-b789-a8fab644ff80",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "I guess we can live with `object_array += something` leaving `object_array` in an inconsistent state upon an error? The same will be the case for `ufunc.at(object_array, indices, something)`. Just thought there was an API question here, but `+=` also just stops when the first error occured, so I think we can copy that behaviour, or does anyone disagree?\n",
        "createdAt" : "2013-08-05T16:53:34Z",
        "updatedAt" : "2013-08-16T21:44:21Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "7f9935ce-c505-483b-8eea-735eb30f1c4e",
        "parentId" : "0efc491e-d7a4-4fb5-b789-a8fab644ff80",
        "authorId" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "body" : "Yeah, that sounds right to me.\n\nOn Mon, Aug 5, 2013 at 5:53 PM, seberg notifications@github.com wrote:\n\n> In numpy/core/src/umath/ufunc_object.c:\n> \n> > -         \\* puts result in buffer.\n> > -         */\n> > -        do {\n> > -            innerloop(buffer_dataptr, count, stride, innerloopdata);\n> > -        } while (iternext(iter_buffer));\n> >   +\n> > -        PyArray_MapIterNext(iter);\n> > -        if (iter2 != NULL) {\n> > -            PyArray_ITER_NEXT(iter2);\n> > -        }\n> >   +\n> > -        i--;\n> > -    }\n> >   +\n> > -    if (!needs_api) {\n> > -        NPY_END_THREADS;\n> \n> I guess we can live with object_array += something leaving object_arrayin an inconsistent state upon an error? The same will be the case for\n> ufunc.at(object_array, indices, something). Just thought there was an API\n> question here, but += also just stops when the first error occured, so I\n> think we can copy that behaviour, or does anyone disagree?\n> \n> â€”\n> Reply to this email directly or view it on GitHubhttps://github.com/numpy/numpy/pull/2821/files#r5583608\n> .\n",
        "createdAt" : "2013-08-05T17:16:24Z",
        "updatedAt" : "2013-08-16T21:44:21Z",
        "lastEditedBy" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "tags" : [
        ]
      }
    ],
    "commit" : "acef718f40a30188c1379c13cc49c920d9e7c303",
    "line" : 279,
    "diffHunk" : "@@ -1,1 +5125,5129 @@\n    if (!needs_api) {\n        NPY_END_THREADS;\n    }\n   "
  },
  {
    "id" : "cb4dba58-67b9-443a-8b2b-042f42746d0d",
    "prId" : 2821,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "36c44788-3026-433f-b738-77ceb4551ac4",
        "parentId" : null,
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Hmm, I think the other ufuncs already stop during calculation instead of the end? Not sure if it matters, might need code duplication, to do it in the loop, but...\nCould you add a test for this too? Something like `np.add.at(np.array(['a', 1], dtype=object), [0, 1], 1)` gives and error (and maybe does not change the 1).\n",
        "createdAt" : "2013-08-09T15:41:53Z",
        "updatedAt" : "2013-08-16T21:44:21Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      }
    ],
    "commit" : "acef718f40a30188c1379c13cc49c920d9e7c303",
    "line" : 292,
    "diffHunk" : "@@ -1,1 +5138,5142 @@    Py_XDECREF(errobj);\n\n    if (needs_api && PyErr_Occurred()) {\n        return NULL;\n    }"
  },
  {
    "id" : "fd96b765-bf62-4953-bac0-ff6a1924b0f0",
    "prId" : 2953,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4889d817-1b58-4e7d-89b3-81dea1a05257",
        "parentId" : null,
        "authorId" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "body" : "Is this NpyIter's buggy behaviour with scalars striking again?\n",
        "createdAt" : "2013-01-31T19:29:22Z",
        "updatedAt" : "2013-01-31T19:29:22Z",
        "lastEditedBy" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "tags" : [
        ]
      }
    ],
    "commit" : "f2c81b485fa18e7ab918b470403c52751648dd3a",
    "line" : 212,
    "diffHunk" : "@@ -1,1 +1987,1991 @@            op_axes[i][0] = -1;\n        }\n    }\n\n    /* Create the iterator */"
  },
  {
    "id" : "c6b37a14-8101-45e4-b6c4-a1038904506f",
    "prId" : 5124,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "99eb72ff-99f7-4981-b19b-c375566bf629",
        "parentId" : null,
        "authorId" : "acce7360-5cef-46f0-ab05-4fb0ffdffe3a",
        "body" : "Oh wait, I misread the old code: it completely ignores `buf`. I assume that the new behavior is what was intended all along? @charris @mwiebe\n",
        "createdAt" : "2014-09-27T11:33:42Z",
        "updatedAt" : "2014-09-27T12:38:56Z",
        "lastEditedBy" : "acce7360-5cef-46f0-ab05-4fb0ffdffe3a",
        "tags" : [
        ]
      },
      {
        "id" : "1151f9bb-633e-4d48-9857-37156ebe8298",
        "parentId" : "99eb72ff-99f7-4981-b19b-c375566bf629",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Yeah, looks like `signature` was a bug. BTW, I'm seldom responsible for a lot of code that `git blame` assigns to me, as I only show up because I made extensive style fixes throughout the code. The downside of style fixes is the loss of history.\n",
        "createdAt" : "2014-09-30T01:37:18Z",
        "updatedAt" : "2014-09-30T01:37:18Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "bfc4bf4421a84eec6e17ddf09a3d2beacf4ea4b7",
    "line" : 16,
    "diffHunk" : "@@ -1,1 +746,750 @@        PyErr_Format(PyExc_ValueError,\n                     \"%s at position %d in \\\"%s\\\"\",\n                     parse_error, i, signature);\n    }\n    return -1;"
  },
  {
    "id" : "14e9a72e-e1b3-4dab-8d78-732aea861917",
    "prId" : 5621,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d05da67d-2e16-4230-8551-de8f769a1bb1",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Might want to scatter a `\\n` or two in the message.\n",
        "createdAt" : "2015-03-08T00:30:21Z",
        "updatedAt" : "2015-03-08T16:00:18Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "bb3ae05f773e1997b4e95655cf1795cb7c8f904b",
    "line" : 174,
    "diffHunk" : "@@ -1,1 +1022,1026 @@                             */\n                            if (PyArray_Check(value) || value == Py_None) {\n                                if (DEPRECATE(\"passing a single array to the \"\n                                              \"'out' keyword argument of a \"\n                                              \"ufunc with\\n\""
  },
  {
    "id" : "4aec1e94-62e9-4125-8b67-911b0b311063",
    "prId" : 7198,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f3b35743-fe30-4781-80a1-93b4b3dacbc1",
        "parentId" : null,
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Actually I am not sure how reliable this is, but don't have a quick better idea either. With all those inner core dimensions, I guess the iterator size could be vastly overestimated possibly (I am not sure).\n",
        "createdAt" : "2016-02-05T21:53:42Z",
        "updatedAt" : "2016-03-17T12:15:12Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "a8a61618-e659-4b30-8d35-b57ac11103f4",
        "parentId" : "f3b35743-fe30-4781-80a1-93b4b3dacbc1",
        "authorId" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "body" : "Can an ssize_t actually meaningfully overflow here? ssize_t = intp, right? So how do you address an array that's bigger then ssize_t can represent?\n",
        "createdAt" : "2016-02-05T23:18:34Z",
        "updatedAt" : "2016-03-17T12:15:12Z",
        "lastEditedBy" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "tags" : [
        ]
      },
      {
        "id" : "3283011e-8832-4b28-9887-cd4aab415fb5",
        "parentId" : "f3b35743-fe30-4781-80a1-93b4b3dacbc1",
        "authorId" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "body" : "Otherwise looks good to me.\n.\nObligatory comment in passing that the code duplication between ufuncs and\ngufuncs sucks.\n\nOn Fri, Feb 5, 2016 at 1:53 PM, seberg notifications@github.com wrote:\n\n> In numpy/core/src/umath/ufunc_object.c\n> https://github.com/numpy/numpy/pull/7198#discussion_r52077858:\n> \n> > @@ -2343,6 +2344,16 @@ PyUFunc_GeneralizedFunction(PyUFuncObject *ufunc,\n> >          }\n> >      }\n> > -    total_problem_size = NpyIter_GetIterSize(iter);\n> > -    if (total_problem_size < 0) {\n> \n> Actually I am not sure how reliable this is, but don't have a quick better\n> idea either. With all those inner core dimensions, I guess the iterator\n> size could be vastly overestimated possibly (I am not sure).\n> \n> â€”\n> Reply to this email directly or view it on GitHub\n> https://github.com/numpy/numpy/pull/7198/files#r52077858.\n\n## \n\nNathaniel J. Smith -- https://vorpus.org http://vorpus.org\n",
        "createdAt" : "2016-02-05T23:19:20Z",
        "updatedAt" : "2016-03-17T12:15:12Z",
        "lastEditedBy" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "tags" : [
        ]
      },
      {
        "id" : "45601c3d-092c-4e9e-a4d0-a033c8abed70",
        "parentId" : "f3b35743-fe30-4781-80a1-93b4b3dacbc1",
        "authorId" : "34105ae0-9fd2-4403-be9b-7c550a729828",
        "body" : "The array isn't bigger, just the intermediate representation of the iterator before removing some axes. E.g. a call to `numpy.core.umath_tests.inner1d`, which has signature '(i),(i)->()', with two arrays of shapes `(a, 1, c)` and `(1, b, c)` will create an iterator with shape `(a, b, c, c)` before removing the last two dimensions. So with slightly more complicated gufuncs it is a meaningful possibility.\n",
        "createdAt" : "2016-02-06T06:10:13Z",
        "updatedAt" : "2016-03-17T12:15:12Z",
        "lastEditedBy" : "34105ae0-9fd2-4403-be9b-7c550a729828",
        "tags" : [
        ]
      },
      {
        "id" : "10b2209b-d792-42ed-bd84-d2603cbcabb8",
        "parentId" : "f3b35743-fe30-4781-80a1-93b4b3dacbc1",
        "authorId" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "body" : "Eh, I guess. Does the iterator actually handle such cases? Should we care when by the time we're dealing with such numbers we're just as likely to roll back around to positive? I guess it doesn't really matter too much whatever we do here...\n",
        "createdAt" : "2016-02-06T06:27:56Z",
        "updatedAt" : "2016-03-17T12:15:12Z",
        "lastEditedBy" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "tags" : [
        ]
      },
      {
        "id" : "9890166c-8eeb-466c-95fb-ed5be0575d42",
        "parentId" : "f3b35743-fe30-4781-80a1-93b4b3dacbc1",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "If it would not care explicitly, it should error out. So it sets it to \n-1 and errors out unless you remove that stuff again. I added that\nweird feature explicitly for these gufuncs that bloat the iterator.\n",
        "createdAt" : "2016-02-06T07:23:41Z",
        "updatedAt" : "2016-03-17T12:15:12Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      }
    ],
    "commit" : "19655d1d80f299bd76982d485b74aa8b4b0018d6",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +2349,2353 @@\n    total_problem_size = NpyIter_GetIterSize(iter);\n    if (total_problem_size < 0) {\n        /*\n         * Only used for threading, if negative (this means that it is"
  },
  {
    "id" : "bffcebb9-3f8e-4fad-9ffd-a8559aa27e41",
    "prId" : 7373,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2f53fade-658b-4070-9fc2-9483bade78d7",
        "parentId" : null,
        "authorId" : "0d70c244-f732-4a44-9ae8-c3f6de7e9b40",
        "body" : "Why are these values not the same as the ones returned by `assign_reduce_identity_*()`? Specifically, `assign_reduce_identity_minusone()` uses `PyLong_FromLong()` instead of `PyInt_FromLong()`. It looks like one is a macro for the other in Py3, but is that the case in Py2 as well?\n",
        "createdAt" : "2016-03-03T05:02:30Z",
        "updatedAt" : "2016-03-04T02:36:59Z",
        "lastEditedBy" : "0d70c244-f732-4a44-9ae8-c3f6de7e9b40",
        "tags" : [
        ]
      },
      {
        "id" : "d0340563-05f8-4f0b-9892-aa557922437a",
        "parentId" : "2f53fade-658b-4070-9fc2-9483bade78d7",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "They don't matter ;) `ufunc_get_identity` is a getter function for a property of the ufunc object and is only there to make the number visible to python users.\n",
        "createdAt" : "2016-03-03T06:12:41Z",
        "updatedAt" : "2016-03-04T02:36:59Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "13925bf5-2d43-4846-a013-519c130e9c6f",
        "parentId" : "2f53fade-658b-4070-9fc2-9483bade78d7",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "`assign_reduce_identity_minusone()` is used to produce a number that I want passed to `PyLong_AsLongLong` in `PyArray_FillWithScalars` so that the maximum number of bits are produced. Might could use something smaller, maybe not, but why gamble?\n",
        "createdAt" : "2016-03-03T06:17:28Z",
        "updatedAt" : "2016-03-04T02:36:59Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "0936775a-1403-438a-8e34-3aaac5a8edf7",
        "parentId" : "2f53fade-658b-4070-9fc2-9483bade78d7",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "I think the only thing that might matter (not even sure about that) is, whether we want to return -1 or -1L in the object corner cases of empty reductions on python 2. But either way is good in any case, Python makes no real difference between the two (and will silently convert easily).\n",
        "createdAt" : "2016-03-03T15:25:36Z",
        "updatedAt" : "2016-03-04T02:36:59Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      }
    ],
    "commit" : "9653c05a53327332a481cd697708ae9b6360fbf0",
    "line" : 63,
    "diffHunk" : "@@ -1,1 +5604,5608 @@    case PyUFunc_Zero:\n        return PyInt_FromLong(0);\n    case PyUFunc_MinusOne:\n        return PyInt_FromLong(-1);\n    }"
  },
  {
    "id" : "4c902016-e6cc-4858-8357-aecafe687327",
    "prId" : 8043,
    "prUrl" : "https://github.com/numpy/numpy/pull/8043#pullrequestreview-17566404",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "81270d24-ee98-486f-858c-ea5c115fa096",
        "parentId" : null,
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "why is this line added? a bug in the old code or due to the other changes?",
        "createdAt" : "2017-01-12T13:20:51Z",
        "updatedAt" : "2017-02-10T19:53:34Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      },
      {
        "id" : "35f348c0-d46a-45d3-b496-9a42cafba6d1",
        "parentId" : "81270d24-ee98-486f-858c-ea5c115fa096",
        "authorId" : "48d7d71b-9655-46b2-9a18-7c1fba7837d0",
        "body" : "I think it's a noop. Not necessary to add.",
        "createdAt" : "2017-01-12T19:12:42Z",
        "updatedAt" : "2017-02-10T19:53:34Z",
        "lastEditedBy" : "48d7d71b-9655-46b2-9a18-7c1fba7837d0",
        "tags" : [
        ]
      },
      {
        "id" : "626a1992-61ea-4855-8068-67dd6785fd18",
        "parentId" : "81270d24-ee98-486f-858c-ea5c115fa096",
        "authorId" : "48d7d71b-9655-46b2-9a18-7c1fba7837d0",
        "body" : "On second thought, I think it's useful to have here to ensure correctness, if we later on change NPY_ITER_COPY_IF_OVERLAP to make copies of also the input arrays.",
        "createdAt" : "2017-01-19T21:50:35Z",
        "updatedAt" : "2017-02-10T19:53:34Z",
        "lastEditedBy" : "48d7d71b-9655-46b2-9a18-7c1fba7837d0",
        "tags" : [
        ]
      }
    ],
    "commit" : "8e8ce442e8449916a93951093cdce16cec006bcc",
    "line" : 322,
    "diffHunk" : "@@ -1,1 +3691,3695 @@        op[0] = NpyIter_GetOperandArray(iter)[0];\n        op[1] = NpyIter_GetOperandArray(iter)[1];\n        op[2] = NpyIter_GetOperandArray(iter)[2];\n\n        if (out == NULL) {"
  }
]
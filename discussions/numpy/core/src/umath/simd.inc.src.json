[
  {
    "id" : "1227ba53-4996-4aa3-8e3f-8604e2cbceb5",
    "prId" : 3411,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6b542e09-de6e-4bdc-a70e-7a20498c8c8c",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Dispatcher handles `longdouble`? Is this to simplify things so that `longdouble` doesn't need to be special cased?\n",
        "createdAt" : "2013-06-08T19:25:57Z",
        "updatedAt" : "2013-06-08T21:19:09Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "55fc4fc3-2b75-47a7-8abf-dce6937d3c81",
        "parentId" : "6b542e09-de6e-4bdc-a70e-7a20498c8c8c",
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "previously I solved this via ifdef macros but with the files split we need a (nop) longdouble dispatcher to keep the logic out of loops .c.src\nalternative I see would be to keep the old macros (NPY_HAVE_SIMD_TYPE) and preprocessor guard the run_simd dispatcher in loops.c.src.\n\nhaving it a separate repeat block is just to save on #ifdefs in the actual vectorized repeat block.\n",
        "createdAt" : "2013-06-08T19:32:08Z",
        "updatedAt" : "2013-06-08T21:19:09Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      },
      {
        "id" : "88341dee-a785-4b49-88f9-cd0b94902bec",
        "parentId" : "6b542e09-de6e-4bdc-a70e-7a20498c8c8c",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Makes sense.\n",
        "createdAt" : "2013-06-08T19:39:08Z",
        "updatedAt" : "2013-06-08T21:19:09Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "7fb8b714906a92516905cc0f03e45511bd1ac1ed",
    "line" : 56,
    "diffHunk" : "@@ -1,1 +54,58 @@ * Float types\n *  #type = npy_float, npy_double, npy_longdouble#\n *  #TYPE = FLOAT, DOUBLE, LONGDOUBLE#\n *  #vector = 1, 1, 0#\n */"
  },
  {
    "id" : "7b5a7bd8-dc68-47be-a63b-dc2a6e5ff070",
    "prId" : 3436,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d056cea5-55f6-48a1-ae14-7afd5de33a5b",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "I think you mean 0 or 1 only, right? That is the right thing to do, especially as adding up the booleans is a common operation used to count the number of True values.\n",
        "createdAt" : "2013-06-15T17:12:06Z",
        "updatedAt" : "2013-06-15T17:12:06Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "c7d0f89b-6010-4db4-bd17-f2297bb6df56",
        "parentId" : "d056cea5-55f6-48a1-ae14-7afd5de33a5b",
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "I don't think the C standard guarantees 0 or 1, so I'm actually using whatever the compiler outputs for 1 == 1 as true (see line 539)\n",
        "createdAt" : "2013-06-15T17:17:49Z",
        "updatedAt" : "2013-06-15T17:17:49Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      },
      {
        "id" : "c55d4359-d514-4c02-a86c-993cbdef7d51",
        "parentId" : "d056cea5-55f6-48a1-ae14-7afd5de33a5b",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "You sent me to the standard to check ;) It does specify 0 or 1, but you should be good:\n\n3 The == (equal to) and != (not equal to) operators are analogous to the relational\noperators except for their lower precedence.91) Each of the operators yields 1 if the\nspecified relation is true and 0 if it is false. The result has type int. For any pair of\noperands, exactly one of the relations is true.\n",
        "createdAt" : "2013-06-15T17:58:16Z",
        "updatedAt" : "2013-06-15T17:58:16Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "4b4a7365aeff3dfd19d4b72765db5358963614e9",
    "line" : 120,
    "diffHunk" : "@@ -1,1 +532,536 @@ * consistent, should not be required if bool is used correctly everywhere but\n * you never know\n */\n#if !@and@\nstatic NPY_INLINE @vtype@ byte_to_true(@vtype@ v)"
  },
  {
    "id" : "f9d15163-5df8-4a56-ae0c-f905dd27b031",
    "prId" : 3466,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "60e20e8a-6c15-42e8-9577-532952882f5f",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Looks like you could have another substitution string for `0` and `0xFFFF` to avoid the `#if`.\n",
        "createdAt" : "2013-06-23T13:36:39Z",
        "updatedAt" : "2013-06-23T13:36:39Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "a20edc7b-8fdb-42b4-b46a-85e5d0499c62",
        "parentId" : "60e20e8a-6c15-42e8-9577-532952882f5f",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Out of curiosity, what type is the result of `@vpre@_movemask_epi8(v)`?\n",
        "createdAt" : "2013-06-23T13:54:51Z",
        "updatedAt" : "2013-06-23T13:54:51Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "7a4fa941-b95d-4a20-bce5-37493c20567d",
        "parentId" : "60e20e8a-6c15-42e8-9577-532952882f5f",
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "one could use a substitution, but I think it makes the code harder to read.\n\nmovemask_epi8 returns an integer with 16 bit set to the most significant bit of each of the 16 bytes in the vector.\ncmpeq_epi8 sets true to 0xFF\nfor all/and it checks that all significant bits are zero, meaning no element was zero/false, if not it stops\nfor any/or it checks if any significant bit was zero and stops, if all 16 bits are set all elements are zero/false and it continues\n",
        "createdAt" : "2013-06-23T14:37:01Z",
        "updatedAt" : "2013-06-23T14:40:11Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      }
    ],
    "commit" : "1ae0622fe120b9da4df32525c3fb6970217e4cb4",
    "line" : 85,
    "diffHunk" : "@@ -1,1 +603,607 @@        v = @vpre@_cmpeq_epi8(v, zero);\n#if @and@\n        if ((@vpre@_movemask_epi8(v) != 0)) {\n            *op = 0;\n#else"
  },
  {
    "id" : "7e611ab6-364e-47d9-b8af-f101cc376a73",
    "prId" : 3466,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "dbf93e2f-2fc5-4265-94c6-964fed8a9148",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Could this be simplified to look like the blocked loop? The `@op@=`  form might also be an option here.\n",
        "createdAt" : "2013-06-23T13:38:54Z",
        "updatedAt" : "2013-06-23T13:38:54Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "bbb0655b-479e-4acb-a324-8f05da8998fb",
        "parentId" : "dbf93e2f-2fc5-4265-94c6-964fed8a9148",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "NVM, no &&= etc. operators ;) I suppose bitwise could be used instead since booleans are supposed to be 0 or 1.\n",
        "createdAt" : "2013-06-23T13:43:07Z",
        "updatedAt" : "2013-06-23T13:43:07Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "1ae0622fe120b9da4df32525c3fb6970217e4cb4",
    "line" : 76,
    "diffHunk" : "@@ -1,1 +594,598 @@    const @vtype@ zero = @vpre@_setzero_@vsuf@();\n    LOOP_BLOCK_ALIGN_VAR(ip, npy_bool, 16) {\n        *op = *op @op@ ip[i];\n        if (*op @sc@ 0) {\n            return;"
  },
  {
    "id" : "5518e374-8f20-440b-8bda-3e27525cd009",
    "prId" : 4386,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "849666f1-4534-4d1f-974c-450a761e10ff",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "`>=` doesn't work?\n",
        "createdAt" : "2014-02-27T21:06:43Z",
        "updatedAt" : "2014-02-27T21:06:43Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "1b27dd53-eb2f-41c8-a910-04dd799e2235",
        "parentId" : "849666f1-4534-4d1f-974c-450a761e10ff",
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "don't know this is the original code from loops.c.src, the compiler removes the +0 so I don't mind keeping it like that\n",
        "createdAt" : "2014-02-27T21:08:46Z",
        "updatedAt" : "2014-02-27T21:08:46Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      }
    ],
    "commit" : "3870d1ae49c0c55907bda7d65b46b0ce40467ca5",
    "line" : 23,
    "diffHunk" : "@@ -1,1 +626,630 @@{\n    /* add 0 to clear -0.0 */\n    return (v > 0 ? v: -v) + 0;\n}\n"
  },
  {
    "id" : "9525c599-d962-4b1b-9a95-7320ec8bb9f4",
    "prId" : 5796,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fc660c86-8e00-476a-8424-469d801040bb",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Hmm, certainly no worse than it was ;) I'm thinking about the corner case of `abs` not working for the most negative value of signed integers, but that is a whole other can of worms.\n",
        "createdAt" : "2015-04-24T16:00:21Z",
        "updatedAt" : "2015-04-24T16:00:21Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "9ec8e5c0af892abe25eee4f269bd225dac47414b",
    "line" : 16,
    "diffHunk" : "@@ -1,1 +40,44 @@#endif\n}\n\n/*\n * stride is equal to element size and input and destination are equal or"
  },
  {
    "id" : "14b5b216-4c2a-4bc8-8a2e-85851dac3cc9",
    "prId" : 13134,
    "prUrl" : "https://github.com/numpy/numpy/pull/13134#pullrequestreview-217513638",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fac76913-8404-42d7-a773-983701beaa60",
        "parentId" : null,
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "avx2 has fmadd natively, does it not have the required semantics for this and avx512 fmadd does?",
        "createdAt" : "2019-03-18T20:30:46Z",
        "updatedAt" : "2019-04-19T17:44:30Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      },
      {
        "id" : "905c88af-5413-4746-a9cd-fb4bf684fdbb",
        "parentId" : "fac76913-8404-42d7-a773-983701beaa60",
        "authorId" : "bcfc9a54-7a4c-4326-b6cb-aee294b5cf32",
        "body" : "It does, but it additionally requires \"fma\" attribute. FMA was introduced post AVX2, so it wouldn't work with the older CPU's which have AVX2 but no FMA. ",
        "createdAt" : "2019-03-18T21:03:13Z",
        "updatedAt" : "2019-04-19T17:44:30Z",
        "lastEditedBy" : "bcfc9a54-7a4c-4326-b6cb-aee294b5cf32",
        "tags" : [
        ]
      },
      {
        "id" : "f8ce3327-353b-4694-b13d-fe60ecf44e64",
        "parentId" : "fac76913-8404-42d7-a773-983701beaa60",
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "hm right\r\nThough I wonder if this has an effect on the accuracy bounds you quoted for avx2",
        "createdAt" : "2019-03-20T23:08:42Z",
        "updatedAt" : "2019-04-19T17:44:30Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      },
      {
        "id" : "9aa326bb-e1e3-4545-b3c3-f6e832b54a67",
        "parentId" : "fac76913-8404-42d7-a773-983701beaa60",
        "authorId" : "bcfc9a54-7a4c-4326-b6cb-aee294b5cf32",
        "body" : "The max ULP error and relative error reported above actually holds true for both AVX2 and AVX512 implementations. They were computed by comparing the output of these functions to glibc's scalar implementation of exp and log in double precision (higher precision) across all 32-bit floats (2^32 values). I did that for both AVX2 and AVX512 versions and turns out the max error is the same for both of them. ",
        "createdAt" : "2019-03-21T01:01:55Z",
        "updatedAt" : "2019-04-19T17:44:30Z",
        "lastEditedBy" : "bcfc9a54-7a4c-4326-b6cb-aee294b5cf32",
        "tags" : [
        ]
      },
      {
        "id" : "0d47fc1d-1155-4ceb-9622-c479ab6083cd",
        "parentId" : "fac76913-8404-42d7-a773-983701beaa60",
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "But the two variants do probably not return the exact same results?\r\nFor reproducibility it would be preferable to minimize the amount of different results on different hardware generations.\r\nOnly supporting this for AVX2+fma hardware is probably not unreasonable.\r\n\r\nThough do you know how common avx2 hardware without fma is?",
        "createdAt" : "2019-03-21T18:21:41Z",
        "updatedAt" : "2019-04-19T17:44:30Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      },
      {
        "id" : "82c7da5a-0473-4ef0-97ff-265fd57829a2",
        "parentId" : "fac76913-8404-42d7-a773-983701beaa60",
        "authorId" : "bcfc9a54-7a4c-4326-b6cb-aee294b5cf32",
        "body" : "So, I did run an exhaustive check for all float32 and I verified that avx2/avx512 version of log and exp do produce the exact same result (0 ULP error, 0.0 absolute error). \r\n\r\nIntel introduced FMA in Haswell. So, Ivy Bridge and Sandy Bridge (released in 2011-2012) don't have FMA's. Since they seem to be producing the same result, I would like to keep it as is if that is okay with you. \r\n\r\n> very nice, can you provide the code you used to compare the implementations?\r\n> \r\n> please do not add sin/cos to this PR, lets do that one at the time.",
        "createdAt" : "2019-03-21T22:02:35Z",
        "updatedAt" : "2019-04-19T17:44:30Z",
        "lastEditedBy" : "bcfc9a54-7a4c-4326-b6cb-aee294b5cf32",
        "tags" : [
        ]
      }
    ],
    "commit" : "d3125fa94893af10597f3e0b07613c719940a543",
    "line" : 38,
    "diffHunk" : "@@ -1,1 +1103,1107 @@avx2_fmadd(__m256 a, __m256 b, __m256 c)\n{\n    return _mm256_add_ps(_mm256_mul_ps(a, b), c);\n}\n"
  },
  {
    "id" : "e6800df4-f9f9-4f3d-a857-9fa8cb35d69e",
    "prId" : 13134,
    "prUrl" : "https://github.com/numpy/numpy/pull/13134#pullrequestreview-217035633",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7fbfb197-8f06-46e0-92c6-37fc03603cf1",
        "parentId" : null,
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "the functions all need to be static as we do not need external linkage for them",
        "createdAt" : "2019-03-20T23:50:21Z",
        "updatedAt" : "2019-04-19T17:44:30Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      }
    ],
    "commit" : "d3125fa94893af10597f3e0b07613c719940a543",
    "line" : 48,
    "diffHunk" : "@@ -1,1 +1113,1117 @@\nstatic NPY_INLINE NPY_GCC_OPT_3 NPY_GCC_TARGET_AVX2 __m256\navx2_get_partial_load_mask(const npy_int num_elem, const npy_int total_elem)\n{\n    float maskint[16] = {-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,"
  },
  {
    "id" : "89d9fc3f-1ee0-48d1-8331-14a33ed651bf",
    "prId" : 13415,
    "prUrl" : "https://github.com/numpy/numpy/pull/13415#pullrequestreview-231484834",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bb519ba8-80b0-46e4-9bac-c884dbd2c1ec",
        "parentId" : null,
        "authorId" : "bcfc9a54-7a4c-4326-b6cb-aee294b5cf32",
        "body" : "@juliantaylor, AVX512 provides a neat intrinsic that I use to extract mantissa and exponent in the AVX512 version.  Do you know a better method than what I have in AVX2? (main challenge is handling denormals). ",
        "createdAt" : "2019-04-28T20:27:18Z",
        "updatedAt" : "2019-04-30T00:11:02Z",
        "lastEditedBy" : "bcfc9a54-7a4c-4326-b6cb-aee294b5cf32",
        "tags" : [
        ]
      }
    ],
    "commit" : "a916c38d9f36c7800d9c6dcaef51fe84432ddff3",
    "line" : 22,
    "diffHunk" : "@@ -1,1 +1150,1154 @@    __m256 two_power_100 = _mm256_castsi256_ps(_mm256_set1_epi32(0x71800000));\n    __m256 denormal_mask = _mm256_cmp_ps(x, _mm256_set1_ps(FLT_MIN), _CMP_LT_OQ);\n    __m256 normal_mask = _mm256_cmp_ps(x, _mm256_set1_ps(FLT_MIN), _CMP_GE_OQ);\n\n    __m256 temp1 = _mm256_blendv_ps(x, _mm256_set1_ps(0.0f), normal_mask);"
  }
]
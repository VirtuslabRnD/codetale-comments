[
  {
    "id" : "1227ba53-4996-4aa3-8e3f-8604e2cbceb5",
    "prId" : 3411,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6b542e09-de6e-4bdc-a70e-7a20498c8c8c",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Dispatcher handles `longdouble`? Is this to simplify things so that `longdouble` doesn't need to be special cased?\n",
        "createdAt" : "2013-06-08T19:25:57Z",
        "updatedAt" : "2013-06-08T21:19:09Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "55fc4fc3-2b75-47a7-8abf-dce6937d3c81",
        "parentId" : "6b542e09-de6e-4bdc-a70e-7a20498c8c8c",
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "previously I solved this via ifdef macros but with the files split we need a (nop) longdouble dispatcher to keep the logic out of loops .c.src\nalternative I see would be to keep the old macros (NPY_HAVE_SIMD_TYPE) and preprocessor guard the run_simd dispatcher in loops.c.src.\n\nhaving it a separate repeat block is just to save on #ifdefs in the actual vectorized repeat block.\n",
        "createdAt" : "2013-06-08T19:32:08Z",
        "updatedAt" : "2013-06-08T21:19:09Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      },
      {
        "id" : "88341dee-a785-4b49-88f9-cd0b94902bec",
        "parentId" : "6b542e09-de6e-4bdc-a70e-7a20498c8c8c",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Makes sense.\n",
        "createdAt" : "2013-06-08T19:39:08Z",
        "updatedAt" : "2013-06-08T21:19:09Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "7fb8b714906a92516905cc0f03e45511bd1ac1ed",
    "line" : 56,
    "diffHunk" : "@@ -1,1 +54,58 @@ * Float types\n *  #type = npy_float, npy_double, npy_longdouble#\n *  #TYPE = FLOAT, DOUBLE, LONGDOUBLE#\n *  #vector = 1, 1, 0#\n */"
  },
  {
    "id" : "7b5a7bd8-dc68-47be-a63b-dc2a6e5ff070",
    "prId" : 3436,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d056cea5-55f6-48a1-ae14-7afd5de33a5b",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "I think you mean 0 or 1 only, right? That is the right thing to do, especially as adding up the booleans is a common operation used to count the number of True values.\n",
        "createdAt" : "2013-06-15T17:12:06Z",
        "updatedAt" : "2013-06-15T17:12:06Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "c7d0f89b-6010-4db4-bd17-f2297bb6df56",
        "parentId" : "d056cea5-55f6-48a1-ae14-7afd5de33a5b",
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "I don't think the C standard guarantees 0 or 1, so I'm actually using whatever the compiler outputs for 1 == 1 as true (see line 539)\n",
        "createdAt" : "2013-06-15T17:17:49Z",
        "updatedAt" : "2013-06-15T17:17:49Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      },
      {
        "id" : "c55d4359-d514-4c02-a86c-993cbdef7d51",
        "parentId" : "d056cea5-55f6-48a1-ae14-7afd5de33a5b",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "You sent me to the standard to check ;) It does specify 0 or 1, but you should be good:\n\n3 The == (equal to) and != (not equal to) operators are analogous to the relational\noperators except for their lower precedence.91) Each of the operators yields 1 if the\nspecified relation is true and 0 if it is false. The result has type int. For any pair of\noperands, exactly one of the relations is true.\n",
        "createdAt" : "2013-06-15T17:58:16Z",
        "updatedAt" : "2013-06-15T17:58:16Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "4b4a7365aeff3dfd19d4b72765db5358963614e9",
    "line" : 120,
    "diffHunk" : "@@ -1,1 +532,536 @@ * consistent, should not be required if bool is used correctly everywhere but\n * you never know\n */\n#if !@and@\nstatic NPY_INLINE @vtype@ byte_to_true(@vtype@ v)"
  },
  {
    "id" : "f9d15163-5df8-4a56-ae0c-f905dd27b031",
    "prId" : 3466,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "60e20e8a-6c15-42e8-9577-532952882f5f",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Looks like you could have another substitution string for `0` and `0xFFFF` to avoid the `#if`.\n",
        "createdAt" : "2013-06-23T13:36:39Z",
        "updatedAt" : "2013-06-23T13:36:39Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "a20edc7b-8fdb-42b4-b46a-85e5d0499c62",
        "parentId" : "60e20e8a-6c15-42e8-9577-532952882f5f",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Out of curiosity, what type is the result of `@vpre@_movemask_epi8(v)`?\n",
        "createdAt" : "2013-06-23T13:54:51Z",
        "updatedAt" : "2013-06-23T13:54:51Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "7a4fa941-b95d-4a20-bce5-37493c20567d",
        "parentId" : "60e20e8a-6c15-42e8-9577-532952882f5f",
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "one could use a substitution, but I think it makes the code harder to read.\n\nmovemask_epi8 returns an integer with 16 bit set to the most significant bit of each of the 16 bytes in the vector.\ncmpeq_epi8 sets true to 0xFF\nfor all/and it checks that all significant bits are zero, meaning no element was zero/false, if not it stops\nfor any/or it checks if any significant bit was zero and stops, if all 16 bits are set all elements are zero/false and it continues\n",
        "createdAt" : "2013-06-23T14:37:01Z",
        "updatedAt" : "2013-06-23T14:40:11Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      }
    ],
    "commit" : "1ae0622fe120b9da4df32525c3fb6970217e4cb4",
    "line" : 85,
    "diffHunk" : "@@ -1,1 +603,607 @@        v = @vpre@_cmpeq_epi8(v, zero);\n#if @and@\n        if ((@vpre@_movemask_epi8(v) != 0)) {\n            *op = 0;\n#else"
  },
  {
    "id" : "7e611ab6-364e-47d9-b8af-f101cc376a73",
    "prId" : 3466,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "dbf93e2f-2fc5-4265-94c6-964fed8a9148",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Could this be simplified to look like the blocked loop? The `@op@=`  form might also be an option here.\n",
        "createdAt" : "2013-06-23T13:38:54Z",
        "updatedAt" : "2013-06-23T13:38:54Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "bbb0655b-479e-4acb-a324-8f05da8998fb",
        "parentId" : "dbf93e2f-2fc5-4265-94c6-964fed8a9148",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "NVM, no &&= etc. operators ;) I suppose bitwise could be used instead since booleans are supposed to be 0 or 1.\n",
        "createdAt" : "2013-06-23T13:43:07Z",
        "updatedAt" : "2013-06-23T13:43:07Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "1ae0622fe120b9da4df32525c3fb6970217e4cb4",
    "line" : 76,
    "diffHunk" : "@@ -1,1 +594,598 @@    const @vtype@ zero = @vpre@_setzero_@vsuf@();\n    LOOP_BLOCK_ALIGN_VAR(ip, npy_bool, 16) {\n        *op = *op @op@ ip[i];\n        if (*op @sc@ 0) {\n            return;"
  },
  {
    "id" : "5518e374-8f20-440b-8bda-3e27525cd009",
    "prId" : 4386,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "849666f1-4534-4d1f-974c-450a761e10ff",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "`>=` doesn't work?\n",
        "createdAt" : "2014-02-27T21:06:43Z",
        "updatedAt" : "2014-02-27T21:06:43Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "1b27dd53-eb2f-41c8-a910-04dd799e2235",
        "parentId" : "849666f1-4534-4d1f-974c-450a761e10ff",
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "don't know this is the original code from loops.c.src, the compiler removes the +0 so I don't mind keeping it like that\n",
        "createdAt" : "2014-02-27T21:08:46Z",
        "updatedAt" : "2014-02-27T21:08:46Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      }
    ],
    "commit" : "3870d1ae49c0c55907bda7d65b46b0ce40467ca5",
    "line" : 23,
    "diffHunk" : "@@ -1,1 +626,630 @@{\n    /* add 0 to clear -0.0 */\n    return (v > 0 ? v: -v) + 0;\n}\n"
  },
  {
    "id" : "9525c599-d962-4b1b-9a95-7320ec8bb9f4",
    "prId" : 5796,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fc660c86-8e00-476a-8424-469d801040bb",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Hmm, certainly no worse than it was ;) I'm thinking about the corner case of `abs` not working for the most negative value of signed integers, but that is a whole other can of worms.\n",
        "createdAt" : "2015-04-24T16:00:21Z",
        "updatedAt" : "2015-04-24T16:00:21Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "9ec8e5c0af892abe25eee4f269bd225dac47414b",
    "line" : 16,
    "diffHunk" : "@@ -1,1 +40,44 @@#endif\n}\n\n/*\n * stride is equal to element size and input and destination are equal or"
  },
  {
    "id" : "14b5b216-4c2a-4bc8-8a2e-85851dac3cc9",
    "prId" : 13134,
    "prUrl" : "https://github.com/numpy/numpy/pull/13134#pullrequestreview-217513638",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fac76913-8404-42d7-a773-983701beaa60",
        "parentId" : null,
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "avx2 has fmadd natively, does it not have the required semantics for this and avx512 fmadd does?",
        "createdAt" : "2019-03-18T20:30:46Z",
        "updatedAt" : "2019-04-19T17:44:30Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      },
      {
        "id" : "905c88af-5413-4746-a9cd-fb4bf684fdbb",
        "parentId" : "fac76913-8404-42d7-a773-983701beaa60",
        "authorId" : "bcfc9a54-7a4c-4326-b6cb-aee294b5cf32",
        "body" : "It does, but it additionally requires \"fma\" attribute. FMA was introduced post AVX2, so it wouldn't work with the older CPU's which have AVX2 but no FMA. ",
        "createdAt" : "2019-03-18T21:03:13Z",
        "updatedAt" : "2019-04-19T17:44:30Z",
        "lastEditedBy" : "bcfc9a54-7a4c-4326-b6cb-aee294b5cf32",
        "tags" : [
        ]
      },
      {
        "id" : "f8ce3327-353b-4694-b13d-fe60ecf44e64",
        "parentId" : "fac76913-8404-42d7-a773-983701beaa60",
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "hm right\r\nThough I wonder if this has an effect on the accuracy bounds you quoted for avx2",
        "createdAt" : "2019-03-20T23:08:42Z",
        "updatedAt" : "2019-04-19T17:44:30Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      },
      {
        "id" : "9aa326bb-e1e3-4545-b3c3-f6e832b54a67",
        "parentId" : "fac76913-8404-42d7-a773-983701beaa60",
        "authorId" : "bcfc9a54-7a4c-4326-b6cb-aee294b5cf32",
        "body" : "The max ULP error and relative error reported above actually holds true for both AVX2 and AVX512 implementations. They were computed by comparing the output of these functions to glibc's scalar implementation of exp and log in double precision (higher precision) across all 32-bit floats (2^32 values). I did that for both AVX2 and AVX512 versions and turns out the max error is the same for both of them. ",
        "createdAt" : "2019-03-21T01:01:55Z",
        "updatedAt" : "2019-04-19T17:44:30Z",
        "lastEditedBy" : "bcfc9a54-7a4c-4326-b6cb-aee294b5cf32",
        "tags" : [
        ]
      },
      {
        "id" : "0d47fc1d-1155-4ceb-9622-c479ab6083cd",
        "parentId" : "fac76913-8404-42d7-a773-983701beaa60",
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "But the two variants do probably not return the exact same results?\r\nFor reproducibility it would be preferable to minimize the amount of different results on different hardware generations.\r\nOnly supporting this for AVX2+fma hardware is probably not unreasonable.\r\n\r\nThough do you know how common avx2 hardware without fma is?",
        "createdAt" : "2019-03-21T18:21:41Z",
        "updatedAt" : "2019-04-19T17:44:30Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      },
      {
        "id" : "82c7da5a-0473-4ef0-97ff-265fd57829a2",
        "parentId" : "fac76913-8404-42d7-a773-983701beaa60",
        "authorId" : "bcfc9a54-7a4c-4326-b6cb-aee294b5cf32",
        "body" : "So, I did run an exhaustive check for all float32 and I verified that avx2/avx512 version of log and exp do produce the exact same result (0 ULP error, 0.0 absolute error). \r\n\r\nIntel introduced FMA in Haswell. So, Ivy Bridge and Sandy Bridge (released in 2011-2012) don't have FMA's. Since they seem to be producing the same result, I would like to keep it as is if that is okay with you. \r\n\r\n> very nice, can you provide the code you used to compare the implementations?\r\n> \r\n> please do not add sin/cos to this PR, lets do that one at the time.",
        "createdAt" : "2019-03-21T22:02:35Z",
        "updatedAt" : "2019-04-19T17:44:30Z",
        "lastEditedBy" : "bcfc9a54-7a4c-4326-b6cb-aee294b5cf32",
        "tags" : [
        ]
      }
    ],
    "commit" : "d3125fa94893af10597f3e0b07613c719940a543",
    "line" : 38,
    "diffHunk" : "@@ -1,1 +1103,1107 @@avx2_fmadd(__m256 a, __m256 b, __m256 c)\n{\n    return _mm256_add_ps(_mm256_mul_ps(a, b), c);\n}\n"
  },
  {
    "id" : "e6800df4-f9f9-4f3d-a857-9fa8cb35d69e",
    "prId" : 13134,
    "prUrl" : "https://github.com/numpy/numpy/pull/13134#pullrequestreview-217035633",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7fbfb197-8f06-46e0-92c6-37fc03603cf1",
        "parentId" : null,
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "the functions all need to be static as we do not need external linkage for them",
        "createdAt" : "2019-03-20T23:50:21Z",
        "updatedAt" : "2019-04-19T17:44:30Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      }
    ],
    "commit" : "d3125fa94893af10597f3e0b07613c719940a543",
    "line" : 48,
    "diffHunk" : "@@ -1,1 +1113,1117 @@\nstatic NPY_INLINE NPY_GCC_OPT_3 NPY_GCC_TARGET_AVX2 __m256\navx2_get_partial_load_mask(const npy_int num_elem, const npy_int total_elem)\n{\n    float maskint[16] = {-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,"
  },
  {
    "id" : "89d9fc3f-1ee0-48d1-8331-14a33ed651bf",
    "prId" : 13415,
    "prUrl" : "https://github.com/numpy/numpy/pull/13415#pullrequestreview-231484834",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bb519ba8-80b0-46e4-9bac-c884dbd2c1ec",
        "parentId" : null,
        "authorId" : "bcfc9a54-7a4c-4326-b6cb-aee294b5cf32",
        "body" : "@juliantaylor, AVX512 provides a neat intrinsic that I use to extract mantissa and exponent in the AVX512 version.  Do you know a better method than what I have in AVX2? (main challenge is handling denormals). ",
        "createdAt" : "2019-04-28T20:27:18Z",
        "updatedAt" : "2019-04-30T00:11:02Z",
        "lastEditedBy" : "bcfc9a54-7a4c-4326-b6cb-aee294b5cf32",
        "tags" : [
        ]
      }
    ],
    "commit" : "a916c38d9f36c7800d9c6dcaef51fe84432ddff3",
    "line" : 22,
    "diffHunk" : "@@ -1,1 +1150,1154 @@    __m256 two_power_100 = _mm256_castsi256_ps(_mm256_set1_epi32(0x71800000));\n    __m256 denormal_mask = _mm256_cmp_ps(x, _mm256_set1_ps(FLT_MIN), _CMP_LT_OQ);\n    __m256 normal_mask = _mm256_cmp_ps(x, _mm256_set1_ps(FLT_MIN), _CMP_GE_OQ);\n\n    __m256 temp1 = _mm256_blendv_ps(x, _mm256_set1_ps(0.0f), normal_mask);"
  },
  {
    "id" : "dcee261f-7ee1-4b7c-af6a-52c9ac09a1e0",
    "prId" : 13520,
    "prUrl" : "https://github.com/numpy/numpy/pull/13520#pullrequestreview-236417747",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9cabe0c8-6051-4c7a-8a1b-b335bf8580e6",
        "parentId" : null,
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "why are SSE2 intrinsic needed in this avx2/avx512 section?",
        "createdAt" : "2019-05-12T12:51:47Z",
        "updatedAt" : "2019-05-16T04:28:23Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      }
    ],
    "commit" : "4b4d2ab1f4be70467313975422b668596338c9b7",
    "line" : 15,
    "diffHunk" : "@@ -1,1 +133,137 @@ */\n\n#if defined HAVE_ATTRIBUTE_TARGET_@ISA@_WITH_INTRINSICS && defined NPY_HAVE_SSE2_INTRINSICS\nstatic NPY_INLINE void\n@ISA@_@func@_FLOAT(npy_float *, npy_float *, const npy_intp n);"
  },
  {
    "id" : "405d20e5-b0b4-4688-91c6-4c6fafb0f6e8",
    "prId" : 13581,
    "prUrl" : "https://github.com/numpy/numpy/pull/13581#pullrequestreview-239203175",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ebf19183-e513-48db-935d-2d18fad6c02d",
        "parentId" : null,
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "this is only needed for stride != 1 so it should and its variable declarions be moved into that if condition for minimal scope",
        "createdAt" : "2019-05-18T15:17:10Z",
        "updatedAt" : "2019-05-18T20:02:46Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      },
      {
        "id" : "89b7763a-97a6-41e0-a3a6-9690f0c6536f",
        "parentId" : "ebf19183-e513-48db-935d-2d18fad6c02d",
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "nevermind, the other code is in the loop which would be slow",
        "createdAt" : "2019-05-18T15:52:09Z",
        "updatedAt" : "2019-05-18T20:02:46Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      }
    ],
    "commit" : "59b2a1d08592b11b82b82b6c53aead689648262e",
    "line" : 102,
    "diffHunk" : "@@ -1,1 +1369,1373 @@    @vtype@ zeros_f = _mm@vsize@_set1_ps(0.0f);\n    @vtype@ poly, num_poly, denom_poly, quadrant;\n    @vtype@i vindex = _mm@vsize@_loadu_si@vsize@((@vtype@i*)&indexarr[0]);\n    @vtype@i exponent;\n"
  },
  {
    "id" : "44656c0e-5f28-495c-8c5b-241abd3baed1",
    "prId" : 13581,
    "prUrl" : "https://github.com/numpy/numpy/pull/13581#pullrequestreview-239203185",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c98649ab-0ac9-4a27-91b5-bf96bf9bb0d5",
        "parentId" : null,
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "same as exp",
        "createdAt" : "2019-05-18T15:18:06Z",
        "updatedAt" : "2019-05-18T20:02:46Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      },
      {
        "id" : "5f3d04cb-82ae-431b-8c00-c50599230d61",
        "parentId" : "c98649ab-0ac9-4a27-91b5-bf96bf9bb0d5",
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "same nevermind",
        "createdAt" : "2019-05-18T15:52:21Z",
        "updatedAt" : "2019-05-18T20:02:46Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      }
    ],
    "commit" : "59b2a1d08592b11b82b82b6c53aead689648262e",
    "line" : 168,
    "diffHunk" : "@@ -1,1 +1497,1501 @@    @vtype@ zeros_f = _mm@vsize@_set1_ps(0.0f);\n    @vtype@ ones_f = _mm@vsize@_set1_ps(1.0f);\n    @vtype@i vindex = _mm@vsize@_loadu_si@vsize@((@vtype@i*)indexarr);\n    @vtype@ poly, num_poly, denom_poly, exponent;\n"
  },
  {
    "id" : "5d7cc4fb-6c07-4891-b858-69f5a07b85b3",
    "prId" : 13885,
    "prUrl" : "https://github.com/numpy/numpy/pull/13885#pullrequestreview-408656339",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a3eda6e1-9dc1-412f-9d9a-6eed902cd62e",
        "parentId" : null,
        "authorId" : "23ffb2ec-0278-4386-95f5-84cc15ce2cfd",
        "body" : "I'm trying to understand this line, \"How and why\"?",
        "createdAt" : "2020-05-09T01:45:16Z",
        "updatedAt" : "2020-05-09T01:45:16Z",
        "lastEditedBy" : "23ffb2ec-0278-4386-95f5-84cc15ce2cfd",
        "tags" : [
        ]
      },
      {
        "id" : "38da2143-348b-4ba4-8e02-1d8e4508a5d9",
        "parentId" : "a3eda6e1-9dc1-412f-9d9a-6eed902cd62e",
        "authorId" : "23ffb2ec-0278-4386-95f5-84cc15ce2cfd",
        "body" : "@r-devulap, you forget to remove it right?",
        "createdAt" : "2020-05-09T01:47:06Z",
        "updatedAt" : "2020-05-09T01:47:07Z",
        "lastEditedBy" : "23ffb2ec-0278-4386-95f5-84cc15ce2cfd",
        "tags" : [
        ]
      },
      {
        "id" : "4f014c07-93a6-4368-aef2-90496bcf1ddb",
        "parentId" : "a3eda6e1-9dc1-412f-9d9a-6eed902cd62e",
        "authorId" : "bcfc9a54-7a4c-4326-b6cb-aee294b5cf32",
        "body" : "The masked load instruction loads 0 for elements for which the mask is set to 0 (which happens for the trailing end of the array). For reciprocal, it causes a 1/0 which raises an divide by zero exception. This line replaces the zeros with ones to avoid that exception. ",
        "createdAt" : "2020-05-09T14:04:44Z",
        "updatedAt" : "2020-05-09T14:04:44Z",
        "lastEditedBy" : "bcfc9a54-7a4c-4326-b6cb-aee294b5cf32",
        "tags" : [
        ]
      },
      {
        "id" : "2c6ca2b1-4b4d-4f50-a750-bbdb4850409a",
        "parentId" : "a3eda6e1-9dc1-412f-9d9a-6eed902cd62e",
        "authorId" : "23ffb2ec-0278-4386-95f5-84cc15ce2cfd",
        "body" : "@r-devulap, \"the trailing end of the array\", oh it makes sense now. thank you",
        "createdAt" : "2020-05-09T14:54:36Z",
        "updatedAt" : "2020-05-09T14:54:36Z",
        "lastEditedBy" : "23ffb2ec-0278-4386-95f5-84cc15ce2cfd",
        "tags" : [
        ]
      }
    ],
    "commit" : "5323bbfc15f320ac5b9c4b3bece6394f5bf74ee2",
    "line" : 432,
    "diffHunk" : "@@ -1,1 +1730,1734 @@             * exception in reciprocal\n             */\n            x = @isa@_set_masked_lanes_ps(x, ones_f, inv_load_mask);\n#endif\n        }"
  },
  {
    "id" : "9160521a-176c-45e4-bf50-bb966c5d77fc",
    "prId" : 14048,
    "prUrl" : "https://github.com/numpy/numpy/pull/14048#pullrequestreview-264989815",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0ff6ed54-50fa-457a-bcaa-36c3571f4dcd",
        "parentId" : null,
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Would this make sense to move it out so that it is obvious that the non-denormals use the same code above?",
        "createdAt" : "2019-07-19T22:28:23Z",
        "updatedAt" : "2019-07-24T20:43:04Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "ce523aeb-6063-4d05-8926-9f11077e6ddb",
        "parentId" : "0ff6ed54-50fa-457a-bcaa-36c3571f4dcd",
        "authorId" : "bcfc9a54-7a4c-4326-b6cb-aee294b5cf32",
        "body" : "I'm sorry, could you please elaborate? not sure if I understand. \r\n\r\nProcessing denormals slows down the function a bit, the` if-else` is so that if there are no input that cause a denormal then we would not want to do all the extra work and it goes through the `else `condition. ",
        "createdAt" : "2019-07-20T16:39:52Z",
        "updatedAt" : "2019-07-24T20:43:04Z",
        "lastEditedBy" : "bcfc9a54-7a4c-4326-b6cb-aee294b5cf32",
        "tags" : [
        ]
      },
      {
        "id" : "3dc3e7e7-7850-47c5-8627-5ea94a627b84",
        "parentId" : "0ff6ed54-50fa-457a-bcaa-36c3571f4dcd",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Oh, I just meant the `poly` line/calculation basically, it looked to me like you can calculate that first and then just return if there are no denormals. But not sure it looks nicer.",
        "createdAt" : "2019-07-22T18:53:28Z",
        "updatedAt" : "2019-07-24T20:43:04Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      }
    ],
    "commit" : "e0860032f45a914501c2bcd339622c394958a687",
    "line" : 37,
    "diffHunk" : "@@ -1,1 +1257,1261 @@     else {\n        __m256i exponent = _mm256_slli_epi32(_mm256_cvtps_epi32(quadrant), 23);\n        poly = _mm256_castsi256_ps(\n                   _mm256_add_epi32(\n                       _mm256_castps_si256(poly), exponent));"
  },
  {
    "id" : "724ab7ae-31b6-4be9-acc1-5b5636606619",
    "prId" : 14048,
    "prUrl" : "https://github.com/numpy/numpy/pull/14048#pullrequestreview-264454787",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "14b2e6e5-e955-4123-8904-8d8944e312e4",
        "parentId" : null,
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "I do not know SIMD things really, is this `static`? (I suppose it makes no difference anyway), EDIT: nvm...",
        "createdAt" : "2019-07-19T22:44:30Z",
        "updatedAt" : "2019-07-24T20:43:04Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      }
    ],
    "commit" : "e0860032f45a914501c2bcd339622c394958a687",
    "line" : 19,
    "diffHunk" : "@@ -1,1 +1239,1243 @@     * 6) The final div operation generates the denormal\n     */\n     __m256 minquadrant = _mm256_set1_ps(-125.0f);\n     __m256 denormal_mask = _mm256_cmp_ps(quadrant, minquadrant, _CMP_LE_OQ);\n     if (_mm256_movemask_ps(denormal_mask) != 0x0000) {"
  },
  {
    "id" : "89b4de8b-3fe0-416d-96e4-632da39eab2d",
    "prId" : 14867,
    "prUrl" : "https://github.com/numpy/numpy/pull/14867#pullrequestreview-314633110",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f76704d8-ce3c-4357-bfd0-f30c1aad52b5",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "`i32` looks worrying to me. I think this needs to be whichever of `32` and `64` correspond to `intp`",
        "createdAt" : "2019-11-10T12:51:28Z",
        "updatedAt" : "2020-01-28T16:53:14Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "cffbe50a-e80d-4ff5-9221-663a5345a0c7",
        "parentId" : "f76704d8-ce3c-4357-bfd0-f30c1aad52b5",
        "authorId" : "bcfc9a54-7a4c-4326-b6cb-aee294b5cf32",
        "body" : "The `i32` only refers to the stride and not the array size. As mentioned above, this will be a problem if the stride is large than 2^28. I will change and use the `_mm512_mask_i64scatter `instruction instead. It will need to be fixed for other existing AVX based functions as well, they all use the `_i32_gather `instruction.",
        "createdAt" : "2019-11-10T17:33:14Z",
        "updatedAt" : "2020-01-28T16:53:14Z",
        "lastEditedBy" : "bcfc9a54-7a4c-4326-b6cb-aee294b5cf32",
        "tags" : [
        ]
      },
      {
        "id" : "abba88ba-3a80-4f71-adee-dfd6c162611c",
        "parentId" : "f76704d8-ce3c-4357-bfd0-f30c1aad52b5",
        "authorId" : "bcfc9a54-7a4c-4326-b6cb-aee294b5cf32",
        "body" : "Thanks for pointing it out. Initially I was surprised that this bug wasn't reported by anyone, but then stride of 268435456 seems unusually large :) ",
        "createdAt" : "2019-11-10T17:37:35Z",
        "updatedAt" : "2020-01-28T16:53:14Z",
        "lastEditedBy" : "bcfc9a54-7a4c-4326-b6cb-aee294b5cf32",
        "tags" : [
        ]
      },
      {
        "id" : "0a0ab63a-edf9-47c8-8284-519c0a824725",
        "parentId" : "f76704d8-ce3c-4357-bfd0-f30c1aad52b5",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "By that do you mean that the intel-patched numpy was already released with this code, and no bugs were reported there?\r\n\r\nIs it the case that `npy_intp` is always 64-bit on the processors that support AVX-512F? If so, it might be nice to state that in a comment",
        "createdAt" : "2019-11-10T17:53:57Z",
        "updatedAt" : "2020-01-28T16:53:14Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "855ee205-6375-4992-a4fa-eb7ac4269370",
        "parentId" : "f76704d8-ce3c-4357-bfd0-f30c1aad52b5",
        "authorId" : "bcfc9a54-7a4c-4326-b6cb-aee294b5cf32",
        "body" : "No, there is existing code in NumPy `simd.inc.src` that use `i32_gather_ps` instruction and no bugs were reported here which would have been the case if someone were using a stride as large as 2^28. ",
        "createdAt" : "2019-11-10T18:04:50Z",
        "updatedAt" : "2020-01-28T16:53:14Z",
        "lastEditedBy" : "bcfc9a54-7a4c-4326-b6cb-aee294b5cf32",
        "tags" : [
        ]
      },
      {
        "id" : "a68841cd-5771-43d5-98e6-e9905288c00b",
        "parentId" : "f76704d8-ce3c-4357-bfd0-f30c1aad52b5",
        "authorId" : "bcfc9a54-7a4c-4326-b6cb-aee294b5cf32",
        "body" : "`npy_intp `maps to `long int` in gcc. On a `__x86_64__` platform I believe it is 64-bit. ",
        "createdAt" : "2019-11-10T18:32:57Z",
        "updatedAt" : "2020-01-28T16:53:14Z",
        "lastEditedBy" : "bcfc9a54-7a4c-4326-b6cb-aee294b5cf32",
        "tags" : [
        ]
      }
    ],
    "commit" : "89618ad43b1fa867888fe8e18b7d85e264eb4f27",
    "line" : 180,
    "diffHunk" : "@@ -1,1 +1821,1825 @@        else {\n            /* scatter! */\n            _mm512_mask_i32scatter_@vsuffix@(op, load_mask, vindex_op, out, @scale@);\n        }\n"
  },
  {
    "id" : "88c75c95-6804-4bbb-9734-fce17a5dca11",
    "prId" : 14867,
    "prUrl" : "https://github.com/numpy/numpy/pull/14867#pullrequestreview-316262153",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c976aab9-fae0-432e-bdd3-28d12c737279",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Can you explain where this came from? Are you looking for `NPY_MAX_INT32 / 16`, where 16 is the maximum number of lanes?",
        "createdAt" : "2019-11-11T23:31:17Z",
        "updatedAt" : "2020-01-28T16:53:14Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "bc3f2d85-5ff9-46d5-822a-9e7ad5611e54",
        "parentId" : "c976aab9-fae0-432e-bdd3-28d12c737279",
        "authorId" : "bcfc9a54-7a4c-4326-b6cb-aee294b5cf32",
        "body" : "I don't have a satisfactory explanation to this. What I ended up using is max step size = 2MB since it satisfies 2 criteria:\r\n\r\n1) Typical linux kernel page size is 4Kb, but sometimes it could also be 2MB which is == 2097152 Bytes. For a step size as large as this, surely all the 16 loads falls on 16 different pages which I would think is the worst performance scenario. \r\n2) And it additionally satisfies `MAX_STEP_SIZE*16/esize < NPY_MAX_INT32 ` which allows us to use `i32gather/scatter` without problems. ",
        "createdAt" : "2019-11-11T23:38:41Z",
        "updatedAt" : "2020-01-28T16:53:14Z",
        "lastEditedBy" : "bcfc9a54-7a4c-4326-b6cb-aee294b5cf32",
        "tags" : [
        ]
      },
      {
        "id" : "a8fca22c-0f89-4893-8860-068825575aee",
        "parentId" : "c976aab9-fae0-432e-bdd3-28d12c737279",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Your comment above should go in the source code.\r\n\r\n",
        "createdAt" : "2019-11-13T13:59:19Z",
        "updatedAt" : "2020-01-28T16:53:14Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "89618ad43b1fa867888fe8e18b7d85e264eb4f27",
    "line" : 17,
    "diffHunk" : "@@ -1,1 +48,52 @@ *    i64gather/scatter). esize = element size = 4/8 bytes for float/double.\n */\n#define MAX_STEP_SIZE 2097152\n\nstatic NPY_INLINE npy_uintp"
  },
  {
    "id" : "e61ef738-a2b4-4368-a407-415e9da38cbc",
    "prId" : 14867,
    "prUrl" : "https://github.com/numpy/numpy/pull/14867#pullrequestreview-315218760",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b0063149-9b7e-41fe-a848-1dfe4400593c",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Tangentially related - it looks like the docs are incorrect from intel here:\r\n\r\n* https://software.intel.com/en-us/cpp-compiler-developer-guide-and-reference-mm-i64gather-epi64-mm256-i64gather-epi64\r\n* https://software.intel.com/en-us/cpp-compiler-developer-guide-and-reference-mm-i64gather-epi32-mm256-i64gather-epi32\r\n\r\nBoth these pages show the prototype as `extern __m128i _mm256...`, yet the documentation strongly indicates the return type is `__m256i`. Do you know the channel to report and correct this, since it appears you work for Intel?\r\n",
        "createdAt" : "2019-11-11T23:36:47Z",
        "updatedAt" : "2020-01-28T16:53:14Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "89618ad43b1fa867888fe8e18b7d85e264eb4f27",
    "line" : 29,
    "diffHunk" : "@@ -1,1 +70,74 @@ * Avoid using SIMD for very large step sizes for several reasons:\n * 1) Supporting large step sizes requires use of i64gather/scatter_ps instructions,\n *    in which case we need two i64gather instructions and an additional vinsertf32x8\n *    instruction to load a single zmm register (since one i64gather instruction\n *    loads into a ymm register). This is not ideal for performance."
  },
  {
    "id" : "672065b5-bcda-4da2-99fd-3f3317bade63",
    "prId" : 14867,
    "prUrl" : "https://github.com/numpy/numpy/pull/14867#pullrequestreview-316644031",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7c042f4e-fbcf-4118-a265-254250b72323",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "What is `esize` here?",
        "createdAt" : "2019-11-14T00:18:52Z",
        "updatedAt" : "2020-01-28T16:53:14Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "89618ad43b1fa867888fe8e18b7d85e264eb4f27",
    "line" : 12,
    "diffHunk" : "@@ -1,1 +43,47 @@ *    the loads/stores of gather/scatter instructions falls on 16 different pages\n *    which one would think would slow down gather/scatter instructions.\n * 2) It additionally satisfies MAX_STEP_SIZE*16/esize < NPY_MAX_INT32 which\n *    allows us to use i32 version of gather/scatter (as opposed to the i64 version)\n *    without problems (step larger than NPY_MAX_INT32*esize/16 would require use of"
  },
  {
    "id" : "6aaa64bc-0b7c-495e-9640-94eeaf3b4a13",
    "prId" : 14867,
    "prUrl" : "https://github.com/numpy/numpy/pull/14867#pullrequestreview-316645684",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a563b6a5-d823-4ebd-8556-03bedc8541b2",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Any reason this change doesn't also get applied to `IS_BLOCKABLE_BINARY` and others below?",
        "createdAt" : "2019-11-14T00:23:35Z",
        "updatedAt" : "2020-01-28T16:53:14Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "89618ad43b1fa867888fe8e18b7d85e264eb4f27",
    "line" : 49,
    "diffHunk" : "@@ -1,1 +89,93 @@ */\n#define IS_OUTPUT_BLOCKABLE_UNARY(esize, vsize) \\\n    (steps[1] == (esize) && abs(steps[0]) < MAX_STEP_SIZE && \\\n     (npy_is_aligned(args[0], esize) && npy_is_aligned(args[1], esize)) && \\\n     ((abs_ptrdiff(args[1], args[0]) >= (vsize)) || \\"
  }
]
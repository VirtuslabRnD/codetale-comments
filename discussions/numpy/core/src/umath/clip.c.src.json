[
  {
    "id" : "39c0a84a-10b0-4e07-83b4-81abf2348526",
    "prId" : 12519,
    "prUrl" : "https://github.com/numpy/numpy/pull/12519#pullrequestreview-209089410",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7c48f9d0-e874-4089-8a41-0042660b79fd",
        "parentId" : null,
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "Would it make sense to do the comparison before the isnan check? That way the check gets avoided most of the time.",
        "createdAt" : "2019-02-26T14:55:11Z",
        "updatedAt" : "2019-05-15T17:09:02Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      },
      {
        "id" : "c222672a-73b2-4d97-ae39-9fe736d7897e",
        "parentId" : "7c48f9d0-e874-4089-8a41-0042660b79fd",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "I think this matches the order the minimum and maximum ufuncs use. I believe swapping them produced an msvc bug. @mattip may remember more.",
        "createdAt" : "2019-02-26T16:53:18Z",
        "updatedAt" : "2019-05-15T17:09:02Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "5b304d1c-b840-4bd3-aad0-6919e2a800be",
        "parentId" : "7c48f9d0-e874-4089-8a41-0042660b79fd",
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "Wouldn't our tests show whether there is such a compiler bug?  Maybe at least add a comment to file that a speed-up may be possible? Or are compilers smart enough to realize that `isnan` is usually an unlikely case and should be done last?",
        "createdAt" : "2019-02-28T14:12:52Z",
        "updatedAt" : "2019-05-15T17:09:02Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      }
    ],
    "commit" : "31f0bb1dc7611e5401a52103623d15ea4b3dd00f",
    "line" : 30,
    "diffHunk" : "@@ -1,1 +28,32 @@/**end repeat**/\n\n#define _NPY_HALF_MIN(a, b) (npy_half_isnan(a) || npy_half_le(a, b) ? (a) : (b))\n#define _NPY_HALF_MAX(a, b) (npy_half_isnan(a) || npy_half_ge(a, b) ? (a) : (b))\n"
  },
  {
    "id" : "664d4cef-f448-475f-86ac-459e967d5323",
    "prId" : 12519,
    "prUrl" : "https://github.com/numpy/numpy/pull/12519#pullrequestreview-213572442",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "39bd2ad4-3635-4fd7-96f6-0492a4fdc055",
        "parentId" : null,
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "here it is trickier to do the same... But really `PyArray_MIN` is just what one expects (`(((a)<(b))?(a):(b))` in `ndarraytypes.h`...)",
        "createdAt" : "2019-02-26T14:58:04Z",
        "updatedAt" : "2019-05-15T17:09:02Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      },
      {
        "id" : "8c2eabe0-b0fe-4a22-a471-8bd4f0b14dcf",
        "parentId" : "39bd2ad4-3635-4fd7-96f6-0492a4fdc055",
        "authorId" : "73d6f7d8-2c7d-4a48-8754-5ce4a97a850f",
        "body" : "My problem here is that npy_isnan(a) doesn't seem to work for \"scalar\" `np.nan` as a clip limit, so you don't actually propagate.\r\n\r\nIt looks like some thought has gone into this for this PR, with i.e., `_clip_dep_is_scalar_nan` and a `DeprecationWarning`, but the propagation definitely is not happening through the clip inner loop clip calls through MAX at the moment.\r\n\r\nThis is probably because there seems to be an interception with an infinite value replacing the scalar nan. I'm not sure how to proceed on that--it seems to be a discouraged use case, but not removed yet & I'm not sure if scalar nan should be truly exempted from propagation until the deprecation cycle is over?",
        "createdAt" : "2019-03-12T18:25:04Z",
        "updatedAt" : "2019-05-15T17:09:02Z",
        "lastEditedBy" : "73d6f7d8-2c7d-4a48-8754-5ce4a97a850f",
        "tags" : [
        ]
      }
    ],
    "commit" : "31f0bb1dc7611e5401a52103623d15ea4b3dd00f",
    "line" : 36,
    "diffHunk" : "@@ -1,1 +34,38 @@ * #name = FLOAT, DOUBLE, LONGDOUBLE#\n */\n#define _NPY_@name@_MIN(a, b) (npy_isnan(a) ? (a) : PyArray_MIN(a, b))\n#define _NPY_@name@_MAX(a, b) (npy_isnan(a) ? (a) : PyArray_MAX(a, b))\n/**end repeat**/"
  },
  {
    "id" : "84893669-c79f-41b1-a810-697bed6c0067",
    "prId" : 12519,
    "prUrl" : "https://github.com/numpy/numpy/pull/12519#pullrequestreview-207993892",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d93c6fbc-a596-4254-9f85-451b88b173ec",
        "parentId" : null,
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "Here, it may be possible to swap the order again.",
        "createdAt" : "2019-02-26T14:58:37Z",
        "updatedAt" : "2019-05-15T17:09:02Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      }
    ],
    "commit" : "31f0bb1dc7611e5401a52103623d15ea4b3dd00f",
    "line" : 43,
    "diffHunk" : "@@ -1,1 +41,45 @@ * #name = CFLOAT, CDOUBLE, CLONGDOUBLE#\n */\n#define _NPY_@name@_MIN(a, b) (npy_isnan((a).real) || npy_isnan((a).imag) || PyArray_CLT(a, b) ? (a) : (b))\n#define _NPY_@name@_MAX(a, b) (npy_isnan((a).real) || npy_isnan((a).imag) || PyArray_CGT(a, b) ? (a) : (b))\n/**end repeat**/"
  },
  {
    "id" : "3c61de52-cb03-4fb2-b7bf-ab72d1f7af8d",
    "prId" : 12519,
    "prUrl" : "https://github.com/numpy/numpy/pull/12519#pullrequestreview-209089410",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1b42596f-f308-4faa-a2b3-cd861ef90238",
        "parentId" : null,
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "Compilers are smart enough for that? To help the poor humans, I'd perhaps have done `@type@ *_op1 = (@type@ *)op1` and then `_op1++` in the loop to make it more obvious... But as long as you're sure this works, it is definitely fine by me.",
        "createdAt" : "2019-02-26T15:03:50Z",
        "updatedAt" : "2019-05-15T17:09:02Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      },
      {
        "id" : "e09504fe-e713-4bd2-9fa4-794933e0c63b",
        "parentId" : "1b42596f-f308-4faa-a2b3-cd861ef90238",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "This matches the approach used by other loops. It's possible an alignment check is needed here too though.",
        "createdAt" : "2019-02-26T16:50:16Z",
        "updatedAt" : "2019-05-15T17:09:02Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "a93d28e2-e047-48d7-bfa1-382dcf8085fd",
        "parentId" : "1b42596f-f308-4faa-a2b3-cd861ef90238",
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "How do we find out? If we're not sure, we should at least note that.",
        "createdAt" : "2019-02-28T14:21:49Z",
        "updatedAt" : "2019-05-15T17:09:02Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      }
    ],
    "commit" : "31f0bb1dc7611e5401a52103623d15ea4b3dd00f",
    "line" : 94,
    "diffHunk" : "@@ -1,1 +92,96 @@        npy_intp n = dimensions[0];\n\n        /* contiguous, branch to let the compiler optimize */\n        if (is1 == sizeof(@type@) && os1 == sizeof(@type@)) {\n            for(npy_intp i = 0; i < n; i++, ip1 += is1, op1 += os1) {"
  },
  {
    "id" : "bfcb32e6-0a41-4e72-a651-7e50082c8114",
    "prId" : 12519,
    "prUrl" : "https://github.com/numpy/numpy/pull/12519#pullrequestreview-213172821",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "de9f5940-fe38-4431-a04e-d6aa09aa5509",
        "parentId" : null,
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "Here both arguments are tested, but I think only one should be necessary: DATETIME_NAT Is the minimum, so is guaranteed to be the smaller of the two (though perhaps this is overoptimizing...)",
        "createdAt" : "2019-02-28T14:18:44Z",
        "updatedAt" : "2019-05-15T17:09:02Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      },
      {
        "id" : "76cb875a-ce99-4518-9d2c-c7df843ce694",
        "parentId" : "de9f5940-fe38-4431-a04e-d6aa09aa5509",
        "authorId" : "73d6f7d8-2c7d-4a48-8754-5ce4a97a850f",
        "body" : "This I'm not clear on. If it is worth avoiding the standard minimum ternary operation with an early exit when `a` is `NaT`, why wouldn't it be worth the similar early exit if `b` is `NaT`? Seems like a pretty small detail though.\r\n\r\nI'm slightly more confused by the `_NPY_@name@_MAX` function just below this being identical to the `MIN` version. If that is correct, can't you just call the MIN version from MAX then? Maybe there's some inner loop / custom template language reason we can't, but seems like `@name@` would just get substituted in & call the other function?",
        "createdAt" : "2019-03-05T18:38:20Z",
        "updatedAt" : "2019-05-15T17:09:02Z",
        "lastEditedBy" : "73d6f7d8-2c7d-4a48-8754-5ce4a97a850f",
        "tags" : [
        ]
      },
      {
        "id" : "0ea444cd-085d-44cb-9cfd-ec38bfb8445c",
        "parentId" : "de9f5940-fe38-4431-a04e-d6aa09aa5509",
        "authorId" : "73d6f7d8-2c7d-4a48-8754-5ce4a97a850f",
        "body" : "I wrote a property-based test for `_NPY_TIMEDELTA_MAX`, and it also agreed that MAX and MIN functions should not have the same definition. I've added a unit test & patch for this.\r\n\r\nThe performance-related discussion point is still on the table, so I won't mark that as resolved, but that's probably less crucial.",
        "createdAt" : "2019-03-12T02:43:03Z",
        "updatedAt" : "2019-05-15T17:09:02Z",
        "lastEditedBy" : "73d6f7d8-2c7d-4a48-8754-5ce4a97a850f",
        "tags" : [
        ]
      }
    ],
    "commit" : "31f0bb1dc7611e5401a52103623d15ea4b3dd00f",
    "line" : 51,
    "diffHunk" : "@@ -1,1 +49,53 @@ */\n#define _NPY_@name@_MIN(a, b) ( \\\n    (a) == NPY_DATETIME_NAT ? (a) : \\\n    (b) == NPY_DATETIME_NAT ? (b) : \\\n    (a) < (b) ? (a) : (b) \\"
  },
  {
    "id" : "e59f173c-b8ff-443b-800b-84c2d822aa03",
    "prId" : 12519,
    "prUrl" : "https://github.com/numpy/numpy/pull/12519#pullrequestreview-225906590",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e1baff9e-9b5d-442f-86b7-960a41e8e1e2",
        "parentId" : null,
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "It would seem that for this case one could optimize the checks for `nan` - maybe for now leave a note to that extent?",
        "createdAt" : "2019-02-28T14:27:31Z",
        "updatedAt" : "2019-05-15T17:09:02Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      },
      {
        "id" : "07b27788-2ca4-4a96-9d02-e316ea3860d4",
        "parentId" : "e1baff9e-9b5d-442f-86b7-960a41e8e1e2",
        "authorId" : "73d6f7d8-2c7d-4a48-8754-5ce4a97a850f",
        "body" : "I've added the requested comment about possible `nan` optimization in the future",
        "createdAt" : "2019-03-05T18:13:22Z",
        "updatedAt" : "2019-05-15T17:09:02Z",
        "lastEditedBy" : "73d6f7d8-2c7d-4a48-8754-5ce4a97a850f",
        "tags" : [
        ]
      },
      {
        "id" : "1a38f9c6-f5c3-4428-bc26-3511d44d7927",
        "parentId" : "e1baff9e-9b5d-442f-86b7-960a41e8e1e2",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "I think the compiler will spot the repeated function invocation anyway, not something we need to worry about.",
        "createdAt" : "2019-04-12T05:57:24Z",
        "updatedAt" : "2019-05-15T17:09:02Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "31f0bb1dc7611e5401a52103623d15ea4b3dd00f",
    "line" : 85,
    "diffHunk" : "@@ -1,1 +83,87 @@{\n    if (steps[1] == 0 && steps[2] == 0) {\n        /* min and max are constant throughout the loop, the most common case */\n        /* NOTE: it may be possible to optimize these checks for nan */\n        @type@ min_val = *(@type@ *)args[1];"
  }
]
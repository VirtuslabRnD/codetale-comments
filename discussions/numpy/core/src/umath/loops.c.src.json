[
  {
    "id" : "4590c4be-4b4d-459f-aab3-f2e4c0847e9c",
    "prId" : 197,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d0c6ed3e-62c6-475e-8c05-5441693d8ace",
        "parentId" : null,
        "authorId" : "95359633-f0b0-4899-8e46-e2146fd11511",
        "body" : "I see you slipping in a consistency-improving change here, did you add a corresponding test?\n",
        "createdAt" : "2012-02-05T22:04:50Z",
        "updatedAt" : "2012-02-07T23:36:46Z",
        "lastEditedBy" : "95359633-f0b0-4899-8e46-e2146fd11511",
        "tags" : [
        ]
      },
      {
        "id" : "14e58d54-44ff-4afe-87b3-59f72ae1bdfa",
        "parentId" : "d0c6ed3e-62c6-475e-8c05-5441693d8ace",
        "authorId" : "95359633-f0b0-4899-8e46-e2146fd11511",
        "body" : "Ah, I see the diff may just be confused - it's diffing _divide with _remainder. Sorry!\n",
        "createdAt" : "2012-02-05T22:12:24Z",
        "updatedAt" : "2012-02-07T23:36:46Z",
        "lastEditedBy" : "95359633-f0b0-4899-8e46-e2146fd11511",
        "tags" : [
        ]
      },
      {
        "id" : "554fe193-748d-4933-bbee-c793857d0b23",
        "parentId" : "d0c6ed3e-62c6-475e-8c05-5441693d8ace",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Yeah, I didn't change the code here, just split the single template into two, one for signed and the other for unsigned.\n",
        "createdAt" : "2012-02-05T22:46:24Z",
        "updatedAt" : "2012-02-07T23:36:46Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "87214fbfb095664e70702da421bc0df4cddd26c5",
    "line" : 572,
    "diffHunk" : "@@ -1,1 +888,892 @@            else {\n                *((@type@ *)op1) = rem + in2;\n            }\n        }\n    }"
  },
  {
    "id" : "91fe888b-c071-4c98-a91e-cb5036c84728",
    "prId" : 3341,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2743d01b-c918-417e-89ef-7660d727dda2",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Multiline comment style is\n\n```\n/*\n * blah\n */\n```\n",
        "createdAt" : "2013-05-23T16:18:34Z",
        "updatedAt" : "2013-05-25T15:36:50Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "fe69102dd34619ce18cf074ef0e6e46611bc17e7",
    "line" : 31,
    "diffHunk" : "@@ -1,1 +44,48 @@        && (steps[0] == 0))\n\n/*\n * stride is equal to element size and input and destination are equal or\n * don't overlap within one register"
  },
  {
    "id" : "ba40a754-8e83-46c0-980d-34afbedc8a7c",
    "prId" : 3411,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b49f22fd-87f4-411d-8df7-6d1647f21f7f",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Hmm, from your earlier comments I had the impression that you were including the source so as to use the gcc multiversioning. Is that not the case? \n",
        "createdAt" : "2013-06-08T20:32:04Z",
        "updatedAt" : "2013-06-08T21:19:09Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "b6246667-b6f8-470e-934c-e4c7c8c65d72",
        "parentId" : "b49f22fd-87f4-411d-8df7-6d1647f21f7f",
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "with GCC multiversioning can be done with any file scheme, you don't need to split it into multiple files. You would have to with compiler that have no function specific option pragmas/attributes.\n\nIts not done now as the main reason to do it is AVX, and I don't have the hardware to actually test that.\nAlso it would require a quite new GCC (+ more setup.py configure checks for this)\n",
        "createdAt" : "2013-06-08T20:37:33Z",
        "updatedAt" : "2013-06-08T21:19:09Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      },
      {
        "id" : "62c95716-e1a1-41f7-a631-ef8015a3764b",
        "parentId" : "b49f22fd-87f4-411d-8df7-6d1647f21f7f",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "That sounds sort of like what I was thinking, that is, a very new GCC would be required in order to use a file that was linked in rather than compiled in. Or am I still missing something.\n",
        "createdAt" : "2013-06-08T20:48:54Z",
        "updatedAt" : "2013-06-08T21:19:09Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "f6726850-3d45-4e4f-a597-7ac22f1e9ef5",
        "parentId" : "b49f22fd-87f4-411d-8df7-6d1647f21f7f",
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "in order to use a linked file you have no special compiler requirements. You just need to adapt your buildsystem to treat this file specially.\nGCC just allows you to do it more conveniently by having inline annotations so no special buildsystem treatment of the file is required.\n",
        "createdAt" : "2013-06-08T20:51:48Z",
        "updatedAt" : "2013-06-08T21:19:09Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      },
      {
        "id" : "68aa2e0e-8698-4587-a83f-76235e1421aa",
        "parentId" : "b49f22fd-87f4-411d-8df7-6d1647f21f7f",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "So basically this is just easier than messing with the build system?\n",
        "createdAt" : "2013-06-08T20:54:08Z",
        "updatedAt" : "2013-06-08T21:19:09Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "6cc0f0d7-7464-4f8c-b6e6-c571f642b84c",
        "parentId" : "b49f22fd-87f4-411d-8df7-6d1647f21f7f",
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "yes\n",
        "createdAt" : "2013-06-08T20:54:57Z",
        "updatedAt" : "2013-06-08T21:19:09Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      },
      {
        "id" : "0beb9964-8549-402e-acad-e0600c5d65e1",
        "parentId" : "b49f22fd-87f4-411d-8df7-6d1647f21f7f",
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "note that nothing special is used in this PR, the split just for organizational reasons.\n",
        "createdAt" : "2013-06-08T20:58:18Z",
        "updatedAt" : "2013-06-08T21:19:09Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      }
    ],
    "commit" : "7fb8b714906a92516905cc0f03e45511bd1ac1ed",
    "line" : 15,
    "diffHunk" : "@@ -1,1 +27,31 @@ * platform specific instructions are either masked via the proprocessor or\n * runtime detected\n */\n#include \"simd.inc\"\n"
  },
  {
    "id" : "5a7dcd0c-be62-4869-9c96-5a03f07099d6",
    "prId" : 3419,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4ff2ad7c-538d-402b-a882-3a4ac092e470",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "I'm wondering if this is portable? Some compilers (SUN) would only allow initialization of struct with constants. SUN is history, but I'm not sure it's ancient history. Is it possible to just pass args and steps?\n\nI also looks like this pattern would be a candidate for a macro, maybe something like `SIMD_UNARY_LOOP`?\n",
        "createdAt" : "2013-06-09T20:11:15Z",
        "updatedAt" : "2013-06-11T17:17:56Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "53b6fb91-4792-4dbf-bf67-6798fb9c3aaf",
        "parentId" : "4ff2ad7c-538d-402b-a882-3a4ac092e470",
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "do we really need to support pre C89 compilers?\nits no problem to do this in three steps, but at some point you have to draw the line what you want to support.\n\ncurrently its only used twice and I don't see the need to do it more often. Its just so square and reciprocal are not slower than their explicit counter parts which do the same if the input pointers are equal.\nThe functions are obsolete on amd64 now.\n",
        "createdAt" : "2013-06-09T20:17:06Z",
        "updatedAt" : "2013-06-11T17:17:56Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      },
      {
        "id" : "db9a5833-c5f5-4315-888c-81df83cda7e5",
        "parentId" : "4ff2ad7c-538d-402b-a882-3a4ac092e470",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "We could just give it a try and wait for complaints, if any. As you say, it isn't worth supported obsolete stuff and C89 isn't that new ;) \n",
        "createdAt" : "2013-06-09T20:26:36Z",
        "updatedAt" : "2013-06-11T17:17:56Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "ffa0130774242fb1b35a5f5a36366968d489d729",
    "line" : 24,
    "diffHunk" : "@@ -1,1 +1495,1499 @@@TYPE@_square(char **args, npy_intp *dimensions, npy_intp *steps, void *NPY_UNUSED(data))\n{\n    char * margs[] = {args[0], args[0], args[1]};\n    npy_intp msteps[] = {steps[0], steps[0], steps[1]};\n    if (run_binary_simd_multiply_@TYPE@(margs, dimensions, msteps)) {"
  },
  {
    "id" : "348e9bf6-7742-4541-817e-b9cbeef1fa3d",
    "prId" : 3514,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a195a4b2-222b-4372-8643-0987abd7bf12",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Hmm, is this GIL safe? Do any of the ufuncs release the GIL?\n",
        "createdAt" : "2014-05-04T19:42:41Z",
        "updatedAt" : "2014-05-04T19:42:41Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "3e4a5336-5545-438a-9916-6146f759472b",
        "parentId" : "a195a4b2-222b-4372-8643-0987abd7bf12",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "OK, these are all for object arrays.\n",
        "createdAt" : "2014-05-04T19:51:16Z",
        "updatedAt" : "2014-05-04T19:51:16Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "f40831a53ff2d572f338b1445e40bc88a1167ce7",
    "line" : 30,
    "diffHunk" : "@@ -1,1 +2586,2590 @@#if @identity@ != -1\n            if (in1 == in2) {\n                PyErr_Clear();\n                if (DEPRECATE(\"numpy @kind@ will not check object identity \"\n                              \"in the future. The comparison error will \""
  },
  {
    "id" : "c0c55397-ee18-415f-bff4-bdb21c3798b0",
    "prId" : 3772,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "413c6cce-17f8-49b9-bb4c-de3197657fd8",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "See previous comment.\n",
        "createdAt" : "2013-09-21T21:05:37Z",
        "updatedAt" : "2013-09-21T21:05:37Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "fd2e1104718490be8504f8d6665205ca594a37e7",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +11,15 @@#endif\n\n#include \"numpy/npy_common.h\"\n#include \"numpy/arrayobject.h\"\n#include \"numpy/ufuncobject.h\""
  },
  {
    "id" : "d9e2f92f-7ad0-46fd-9f28-cf8167eeff0a",
    "prId" : 4449,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "53d353dc-9864-41f4-8499-352e9691b846",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Bit curious why you are defining margs and msteps. How does this function differ from the usual?\n",
        "createdAt" : "2014-03-05T20:54:58Z",
        "updatedAt" : "2014-03-05T20:54:58Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "6c7b1f26-1aa0-49d7-b251-f6b540ba57b6",
        "parentId" : "53d353dc-9864-41f4-8499-352e9691b846",
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "its required so we can use the binary dispatcher for with unary loop, the dispatcher will check all three arguments which are uninitialized for unary loops.\nOne could probably also modify the dispatcher to take another argument defining if binary or unary but I this works fine (the same method is already used for _square and _reciprocal)\n",
        "createdAt" : "2014-03-05T21:06:05Z",
        "updatedAt" : "2014-03-05T21:06:05Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      }
    ],
    "commit" : "37967930e05700af8ee3b66bdb35c5b8a02d17dd",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +1521,1525 @@{\n    char * margs[] = {args[0], args[0], args[1]};\n    npy_intp msteps[] = {steps[0], steps[0], steps[1]};\n    if (!@isnan@ || !run_binary_simd_not_equal_@TYPE@(margs, dimensions, msteps)) {\n        UNARY_LOOP {"
  },
  {
    "id" : "5dbef4a4-4591-40d5-a38d-c02e48413f16",
    "prId" : 5144,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f0f81c7f-ab0d-45f2-9dee-a51a67a98343",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "The two loops look identical. What am I missing?\n",
        "createdAt" : "2014-10-11T16:18:00Z",
        "updatedAt" : "2014-10-11T17:03:02Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "5099f8fd-1f5e-48b4-bbd5-ccd708ca7393",
        "parentId" : "f0f81c7f-ab0d-45f2-9dee-a51a67a98343",
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "in the first case the compiler has extra information from the if clause and will remove the stride computations for us so we don't need another loop macro.\n",
        "createdAt" : "2014-10-11T16:21:46Z",
        "updatedAt" : "2014-10-11T17:03:02Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      },
      {
        "id" : "110aff77-c6a7-4cb4-875a-46a254c4a2c6",
        "parentId" : "f0f81c7f-ab0d-45f2-9dee-a51a67a98343",
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "I am again assuming a somewhat smart compiler, works fine with gcc, but we could also make it explicit for less capable ones.\n",
        "createdAt" : "2014-10-11T16:23:48Z",
        "updatedAt" : "2014-10-11T17:03:02Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      },
      {
        "id" : "0fa383c8-ef29-4fe0-8ce3-abd3e47b309c",
        "parentId" : "f0f81c7f-ab0d-45f2-9dee-a51a67a98343",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "The compilers are smarter than me ;) Explicit is better, but at least a note in the comments would be helpful.\n",
        "createdAt" : "2014-10-11T16:34:45Z",
        "updatedAt" : "2014-10-11T17:03:02Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "59d7206c-73c5-41b7-85fe-49ebf0a3868f",
        "parentId" : "f0f81c7f-ab0d-45f2-9dee-a51a67a98343",
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "fyi, tested it with gcc-4.4 which is the one on rh6, so we should be fine on that front. clang 3.5 can't vectorize this even with explicit help.\nI'll add a comment\n",
        "createdAt" : "2014-10-11T16:46:16Z",
        "updatedAt" : "2014-10-11T17:03:02Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      },
      {
        "id" : "485c415c-80f9-4a81-8e42-0c7eb8831281",
        "parentId" : "f0f81c7f-ab0d-45f2-9dee-a51a67a98343",
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "added\n",
        "createdAt" : "2014-10-11T17:03:56Z",
        "updatedAt" : "2014-10-11T17:03:56Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      }
    ],
    "commit" : "2e1ff063751461f7c4287933b88554f4d44d7ee5",
    "line" : 50,
    "diffHunk" : "@@ -1,1 +102,106 @@    else { \\\n        UNARY_LOOP { \\\n            const tin in = *(tin *)ip1; \\\n            tout * out = (tout *)op1; \\\n            op; \\"
  },
  {
    "id" : "1a63e82b-fe16-4cef-a2f4-c003f91b3344",
    "prId" : 5144,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7abdedb4-1c75-442d-8301-41ec47b82b99",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "This loop is a repeat of the first. ?\n",
        "createdAt" : "2014-10-11T16:26:01Z",
        "updatedAt" : "2014-10-11T17:03:02Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "4ed169e7-8356-4895-8d9e-568c9a022def",
        "parentId" : "7abdedb4-1c75-442d-8301-41ec47b82b99",
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "yes same reasoning as before, by using NPY_RESTRICT technically all three loops could be the same, but it wouldn't save any lines of code.\n",
        "createdAt" : "2014-10-11T16:27:34Z",
        "updatedAt" : "2014-10-11T17:03:02Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      }
    ],
    "commit" : "2e1ff063751461f7c4287933b88554f4d44d7ee5",
    "line" : 101,
    "diffHunk" : "@@ -1,1 +160,164 @@    else { \\\n        BINARY_LOOP { \\\n            const tin in1 = *(tin *)ip1; \\\n            const tin in2 = *(tin *)ip2; \\\n            tout * out = (tout *)op1; \\"
  },
  {
    "id" : "bbebc9a3-15b8-4351-be5a-a734bebc8713",
    "prId" : 6269,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "77ed26db-151b-44fe-b5a9-8b374b5d3793",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "I doesn't look like zero is used anymore.\n",
        "createdAt" : "2015-09-27T01:05:05Z",
        "updatedAt" : "2015-09-28T20:16:20Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "ab331cd8-7cf7-44b2-bae0-102a7b051ee9",
        "parentId" : "77ed26db-151b-44fe-b5a9-8b374b5d3793",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Oops, nevermind.\n",
        "createdAt" : "2015-09-27T01:12:13Z",
        "updatedAt" : "2015-09-28T20:16:20Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "00edb2b6a96b7189be91d16cb84981a60c5961e8",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +2619,2623 @@OBJECT_sign(char **args, npy_intp *dimensions, npy_intp *steps, void *NPY_UNUSED(func))\n{\n    PyObject *zero = PyLong_FromLong(0);\n\n    UNARY_LOOP {"
  },
  {
    "id" : "6bc848df-d97d-41f9-954b-208e989d4f66",
    "prId" : 7057,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4e32f3ee-4d29-4925-9863-67286c83fc78",
        "parentId" : null,
        "authorId" : "576cec6e-8071-43f8-bce9-351a2589f050",
        "body" : "Is there a reason for DEPRECATE_FUTUREWARNING rather than just DEPRECATE? Do we have a rule for when to choose which?\n",
        "createdAt" : "2016-01-19T02:10:35Z",
        "updatedAt" : "2016-01-19T02:10:35Z",
        "lastEditedBy" : "576cec6e-8071-43f8-bce9-351a2589f050",
        "tags" : [
        ]
      },
      {
        "id" : "edf4b5ac-3128-424a-8aec-48663d59bbf0",
        "parentId" : "4e32f3ee-4d29-4925-9863-67286c83fc78",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "@shoyer My understanding of the differences is this. A `DeprecationWarning` means that in the future either the feature will be removed or an exception will be raised. OTOH, a `FutureWarning` means that the feature will remain but its behavior will change.\n\nI suppose the macro name `DEPRECATE_FUTUREWARNING` is a bit misleading, it just issues a `FutureWarning`.\n",
        "createdAt" : "2016-01-19T02:31:37Z",
        "updatedAt" : "2016-01-19T02:32:15Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "31dbc05d86c4018c76562466de0ea569eb1f8a62",
    "line" : 23,
    "diffHunk" : "@@ -1,1 +1134,1138 @@            NPY_ALLOW_C_API;\n            /* 2016-01-18, 1.11 */\n            if (DEPRECATE_FUTUREWARNING(\n                    \"In the future, 'NAT @OP@ x' and 'x @OP@ NAT' \"\n                    \"will always be False.\") < 0) {"
  },
  {
    "id" : "11891948-b0a7-4605-a819-22744711b98f",
    "prId" : 7057,
    "prUrl" : "https://github.com/numpy/numpy/pull/7057#pullrequestreview-16862109",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "be34853f-869f-4642-8fbb-73d613070b84",
        "parentId" : null,
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "I assume this should be in2 in the second case?\r\nthis was not detected by our CI because apparently a change removed our compiler warning check ...",
        "createdAt" : "2017-01-16T17:48:48Z",
        "updatedAt" : "2017-01-16T17:48:48Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      },
      {
        "id" : "9c90a06c-91d3-4fdf-bc7b-365e71f4783c",
        "parentId" : "be34853f-869f-4642-8fbb-73d613070b84",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Yep, looks like a bug.",
        "createdAt" : "2017-01-16T18:22:13Z",
        "updatedAt" : "2017-01-16T18:22:13Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "2ff1e56e-9b0f-4118-b0b1-f10a1b883d12",
        "parentId" : "be34853f-869f-4642-8fbb-73d613070b84",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "However, it still issues the required warning (which is why the test passed), it just issues it too often, even when the current comparison is already false.",
        "createdAt" : "2017-01-16T18:25:38Z",
        "updatedAt" : "2017-01-16T18:25:38Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "1a18b5aa-8e35-465d-8015-f47ba8d907ab",
        "parentId" : "be34853f-869f-4642-8fbb-73d613070b84",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "@juliantaylor Could you open is issue or PR for this, milestone 1.12.1",
        "createdAt" : "2017-01-16T18:28:45Z",
        "updatedAt" : "2017-01-16T18:28:45Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "4abc9c32-0b5b-4bad-80dd-4287bc2e3929",
        "parentId" : "be34853f-869f-4642-8fbb-73d613070b84",
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "see gh-8483",
        "createdAt" : "2017-01-16T18:30:29Z",
        "updatedAt" : "2017-01-16T18:30:29Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      }
    ],
    "commit" : "31dbc05d86c4018c76562466de0ea569eb1f8a62",
    "line" : 43,
    "diffHunk" : "@@ -1,1 +1154,1158 @@        *((npy_bool *)op1) = in1 != in2;\n\n        if (in1 == NPY_DATETIME_NAT && in1 == NPY_DATETIME_NAT) {\n            NPY_ALLOW_C_API_DEF\n            NPY_ALLOW_C_API;"
  },
  {
    "id" : "d433d37c-9307-4309-9e8f-0a1fe725f775",
    "prId" : 7651,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0614de9e-905d-4924-a9c2-ef5eebe894c1",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "How about drop the previous if and\n\n```\nif (in2 < 0 && (in1 > 1 || in1 < -1)) {\n```\n\nAnd a special check for divide by zero.\n",
        "createdAt" : "2016-05-20T02:17:46Z",
        "updatedAt" : "2016-05-20T02:17:46Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "5cde31bad1b1e698010fa2801255b5bd8ba3de90",
    "line" : 8,
    "diffHunk" : "@@ -1,1 +926,930 @@            continue;\n        }\n        if (in2 < 0 || in1 == 0) {\n            *((@type@ *)op1) = 0;\n            continue;"
  },
  {
    "id" : "28dc5168-a773-4d68-b9f5-f60a69d25c74",
    "prId" : 7999,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9003c8ee-2bc1-4c55-a2fc-43f2c5a8ae2a",
        "parentId" : null,
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Jeesh, this macro argument passing is starting to give me the creeps ;). By now I think its correct, but could maybe use a comment here to explain things a bit more in depth, I am not used to such macros, but took me a bit to figure out that `in1` always ends up pointing to the correct `args[0]`, etc.\n",
        "createdAt" : "2016-08-31T22:47:55Z",
        "updatedAt" : "2016-09-01T14:12:29Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "702f4c25-02b5-46d8-b493-6fdb06ecf8cb",
        "parentId" : "9003c8ee-2bc1-4c55-a2fc-43f2c5a8ae2a",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Or maybe it is just one of those things you have to stare at until it makes sense...\n",
        "createdAt" : "2016-08-31T22:54:03Z",
        "updatedAt" : "2016-09-01T14:12:29Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      }
    ],
    "commit" : "d555a0ad0f1191daf8ae83e10933da5556b2510e",
    "line" : 46,
    "diffHunk" : "@@ -1,1 +139,143 @@        op; \\\n    }\n#define BASE_BINARY_LOOP_S(tin, tout, cin, cinp, vin, vinp, op) \\\n    const tin cin = *(tin *)cinp; \\\n    BINARY_LOOP { \\"
  },
  {
    "id" : "63087060-9717-4032-8e48-3cf714ff80ee",
    "prId" : 8774,
    "prUrl" : "https://github.com/numpy/numpy/pull/8774#pullrequestreview-28797742",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "76d6a019-6222-4385-b464-00a0bb89d31e",
        "parentId" : null,
        "authorId" : "8de63a41-1bc1-4e93-a2df-4f2f940433cf",
        "body" : "The standard codes for these are `B`, `H`, `I`, `L` and `Q`.  Shouldn't you use those instead?",
        "createdAt" : "2017-03-23T21:44:36Z",
        "updatedAt" : "2017-12-13T04:58:26Z",
        "lastEditedBy" : "8de63a41-1bc1-4e93-a2df-4f2f940433cf",
        "tags" : [
        ]
      },
      {
        "id" : "2af44671-4353-4861-a3f7-2613655d3d32",
        "parentId" : "76d6a019-6222-4385-b464-00a0bb89d31e",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Possibly. Although I didn't see much point implementing `B`, `H`, and `I` separately, because arithmetic always promotes to `int` in C anyway, doesn't it?\r\n\r\n<s>Can you link me to a file that uses these standard codes?</s> Oh, these are the `struct.pack` codes, right? I was trying to write this as though it were a free C function, like `labs` and `llabs` are to `abs`. I guess in hindsight they use a prefix though...",
        "createdAt" : "2017-03-23T22:05:30Z",
        "updatedAt" : "2017-12-13T04:58:26Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "ef310f73-8dcd-4a63-8818-20fb0701f1c8",
        "parentId" : "76d6a019-6222-4385-b464-00a0bb89d31e",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "A better example of what I was imitating might be `strto{l,ll,ul,ull}` from the C standard library.",
        "createdAt" : "2017-03-23T22:21:31Z",
        "updatedAt" : "2017-12-13T04:58:26Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "1996ee82-d21c-4a21-aade-5fc80edccec9",
        "parentId" : "76d6a019-6222-4385-b464-00a0bb89d31e",
        "authorId" : "8de63a41-1bc1-4e93-a2df-4f2f940433cf",
        "body" : "> ...these are the struct.pack codes, right?\r\n\r\nThey are also documented in numpy; see https://docs.scipy.org/doc/numpy/reference/arrays.scalars.html#built-in-scalar-types and `numpy.typecodes['Integer']`, `numpy.typecodes['UnsignedInteger']`, etc.",
        "createdAt" : "2017-03-23T22:56:13Z",
        "updatedAt" : "2017-12-13T04:58:26Z",
        "lastEditedBy" : "8de63a41-1bc1-4e93-a2df-4f2f940433cf",
        "tags" : [
        ]
      }
    ],
    "commit" : "58998a87f4231ea7ede6352df949c8b746830df6",
    "line" : 31,
    "diffHunk" : "@@ -1,1 +1153,1157 @@ * #TYPE = UBYTE, USHORT, UINT, ULONG, ULONGLONG#\n * #type = npy_ubyte, npy_ushort, npy_uint, npy_ulong, npy_ulonglong#\n * #c    = u,u,u,ul,ull#\n */\n"
  },
  {
    "id" : "1b16765c-3b4e-467f-9f01-d56ca4068991",
    "prId" : 8852,
    "prUrl" : "https://github.com/numpy/numpy/pull/8852#pullrequestreview-29176316",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7667e4fe-a173-4ec9-b812-e74d5ba87676",
        "parentId" : null,
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "if someone cares about other compilers, you can likely use this type of pragma there too. Last I checked clang could not vectorize this code, with the pragma it might be able to but it needs testing.",
        "createdAt" : "2017-03-27T13:04:13Z",
        "updatedAt" : "2017-03-27T13:26:23Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      }
    ],
    "commit" : "1964b6a4c5ee377e6489923cbc6b2c61b013a6d5",
    "line" : 8,
    "diffHunk" : "@@ -1,1 +143,147 @@ * vectorize inplace operations (PR80198)\n * must only be used after op1 == ip1 or ip2 has been checked\n * TODO: using ivdep might allow other compilers to vectorize too\n */\n#if __GNUC__ >= 6"
  },
  {
    "id" : "805a98c9-fadc-431a-87e7-6b174ab197ae",
    "prId" : 11660,
    "prUrl" : "https://github.com/numpy/numpy/pull/11660#pullrequestreview-144704057",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e3444ca5-20d3-4140-90d8-94b82dde8c9c",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "I don't think you're winning any prizes by reusing a variable here. Just declare another `const` one, and let the compiler reuse registers for you",
        "createdAt" : "2018-08-09T06:23:22Z",
        "updatedAt" : "2018-08-31T18:45:01Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "f054c215-06f6-4249-b569-6672904961a5",
        "parentId" : "e3444ca5-20d3-4140-90d8-94b82dde8c9c",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Although I suppose it's consistent with what we already have for the others, so out of scope for this PR.",
        "createdAt" : "2018-08-09T06:25:28Z",
        "updatedAt" : "2018-08-31T18:45:01Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "866589cdf7ecb3054ec3ae6493612d51c9d5e56d",
    "line" : 8,
    "diffHunk" : "@@ -1,1 +2227,2231 @@        npy_half in1 = *(npy_half *)ip1;\n        const npy_half in2 = *(npy_half *)ip2;\n        in1 = (@OP@(in1, in2) || npy_half_isnan(in1)) ? in1 : in2;\n        if (npy_half_isnan(in1)) {\n            npy_set_floatstatus_invalid();"
  },
  {
    "id" : "758b1e27-ce81-41b8-8aad-a0fd4022a28c",
    "prId" : 11660,
    "prUrl" : "https://github.com/numpy/numpy/pull/11660#pullrequestreview-151507873",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0e47a6d9-037e-497a-9bfa-9dccec6986b7",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Hmm, now that I look at this, it is not quite the same as the sort ordering for complex numbers containing nans. Oh well.",
        "createdAt" : "2018-08-31T18:36:12Z",
        "updatedAt" : "2018-08-31T18:45:01Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "866589cdf7ecb3054ec3ae6493612d51c9d5e56d",
    "line" : 22,
    "diffHunk" : "@@ -1,1 +2787,2791 @@{\n    BINARY_LOOP {\n        @ftype@ in1r = ((@ftype@ *)ip1)[0];\n        @ftype@ in1i = ((@ftype@ *)ip1)[1];\n        const @ftype@ in2r = ((@ftype@ *)ip2)[0];"
  },
  {
    "id" : "04338d26-12d6-4398-b486-554fab2f4a5d",
    "prId" : 12120,
    "prUrl" : "https://github.com/numpy/numpy/pull/12120#pullrequestreview-163842303",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "66fd1354-8765-438e-962d-6ea4315886e1",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "This function looks correct, thanks",
        "createdAt" : "2018-10-11T14:23:37Z",
        "updatedAt" : "2018-10-15T17:30:14Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "c9a6b02c347960f016ef28088ca8c63e0f2fe2f5",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +1593,1597 @@\nNPY_NO_EXPORT void\nTIMEDELTA_mm_m_remainder(char **args, npy_intp *dimensions, npy_intp *steps, void *NPY_UNUSED(func))\n{\n    BINARY_LOOP {"
  },
  {
    "id" : "c42f799c-54f0-490b-84b6-b2767a5c7fff",
    "prId" : 12236,
    "prUrl" : "https://github.com/numpy/numpy/pull/12236#pullrequestreview-169485159",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "923f11df-462a-4c4f-8e16-49336f9c1518",
        "parentId" : null,
        "authorId" : "576cec6e-8071-43f8-bce9-351a2589f050",
        "body" : "when *do* we set floatstatus_invalid? is that set at the C level?",
        "createdAt" : "2018-10-25T01:10:33Z",
        "updatedAt" : "2018-10-29T15:50:32Z",
        "lastEditedBy" : "576cec6e-8071-43f8-bce9-351a2589f050",
        "tags" : [
        ]
      },
      {
        "id" : "47c9dfcf-23bc-4d35-ba1e-eae418360497",
        "parentId" : "923f11df-462a-4c4f-8e16-49336f9c1518",
        "authorId" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "body" : "Yes, the non-SSE code sets it in `a > b` comparisons. which is why I need to clear it in the float-type loops at line 1849, and the complex-type loops at line 2763, ",
        "createdAt" : "2018-10-25T05:05:47Z",
        "updatedAt" : "2018-10-29T15:50:32Z",
        "lastEditedBy" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "tags" : [
        ]
      },
      {
        "id" : "584fb588-3df2-49f7-aa13-9ce0dd661988",
        "parentId" : "923f11df-462a-4c4f-8e16-49336f9c1518",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Well, set at the FPU level, not at the C level.\r\n\r\nCan't we just reorder the comparisons to do the nan checks first, rather than messing with the FPU flags? ",
        "createdAt" : "2018-10-25T05:18:12Z",
        "updatedAt" : "2018-10-29T15:50:32Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "2ece145d-fb75-4ada-96d9-ae4e7af4b8a0",
        "parentId" : "923f11df-462a-4c4f-8e16-49336f9c1518",
        "authorId" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "body" : "trying, let's see what CI finds",
        "createdAt" : "2018-10-25T10:37:17Z",
        "updatedAt" : "2018-10-29T15:50:32Z",
        "lastEditedBy" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "tags" : [
        ]
      },
      {
        "id" : "c248f6af-d0d1-4436-ba18-3a606656c8e2",
        "parentId" : "923f11df-462a-4c4f-8e16-49336f9c1518",
        "authorId" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "body" : "It turns out simd code also sets it, in a way that it is impossible to avoid the clear after the loop finishes.",
        "createdAt" : "2018-10-25T16:05:54Z",
        "updatedAt" : "2018-10-29T15:50:32Z",
        "lastEditedBy" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "tags" : [
        ]
      },
      {
        "id" : "d8ed7919-e08f-449c-aa44-023a14c7989b",
        "parentId" : "923f11df-462a-4c4f-8e16-49336f9c1518",
        "authorId" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "body" : "Rearranging the order still sets the flag since only one value is checked. It seems cheaper to me to clear the flag than to check both values. In changeset 46452b360 I added back the call to clear the flags, now tests are passing.",
        "createdAt" : "2018-10-29T19:01:00Z",
        "updatedAt" : "2018-10-29T19:01:01Z",
        "lastEditedBy" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "tags" : [
        ]
      },
      {
        "id" : "7aac30e9-5d6c-4dfb-b101-367fc8ca8395",
        "parentId" : "923f11df-462a-4c4f-8e16-49336f9c1518",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "I don't think instruction ordering is safe with modern compilers, at least without some work to make the order stick.",
        "createdAt" : "2018-10-29T19:46:56Z",
        "updatedAt" : "2018-10-29T19:46:57Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "46452b360d9f67d6af78801a3957688515c617fe",
    "line" : 60,
    "diffHunk" : "@@ -1,1 +2195,2199 @@        *((npy_half *)op1) = (@OP@(in1, in2) || npy_half_isnan(in1)) ? in1 : in2;\n    }\n    /* npy_half_isnan will never set floatstatus_invalid, so do not clear */\n}\n/**end repeat**/"
  },
  {
    "id" : "c93eaa9c-d4f3-4918-b35f-7de20765b73d",
    "prId" : 12308,
    "prUrl" : "https://github.com/numpy/numpy/pull/12308#pullrequestreview-182878793",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f6467e53-1d86-4826-a19a-b447f85feb9d",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "I think that you should set `invalid` for all the cases except `in2 == 0`",
        "createdAt" : "2018-12-07T20:37:19Z",
        "updatedAt" : "2018-12-07T21:22:13Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "cb45dc60-5407-45d3-8fb5-47d74bdd9553",
        "parentId" : "f6467e53-1d86-4826-a19a-b447f85feb9d",
        "authorId" : "73d6f7d8-2c7d-4a48-8754-5ce4a97a850f",
        "body" : "done",
        "createdAt" : "2018-12-07T21:23:54Z",
        "updatedAt" : "2018-12-07T21:23:54Z",
        "lastEditedBy" : "73d6f7d8-2c7d-4a48-8754-5ce4a97a850f",
        "tags" : [
        ]
      }
    ],
    "commit" : "2494d11c4450b4a745b5dc1e7aed389da2f31773",
    "line" : 15,
    "diffHunk" : "@@ -1,1 +1631,1635 @@        }\n        else if (in2 == 0) {\n            npy_set_floatstatus_divbyzero();\n            *((npy_timedelta *)op1) = 0;\n        }"
  },
  {
    "id" : "fc919c65-e219-46a7-8157-bde265460bc1",
    "prId" : 12988,
    "prUrl" : "https://github.com/numpy/numpy/pull/12988#pullrequestreview-220365128",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ace4ae5e-6e30-4b75-8964-b708aaa6a049",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Why not just pass the value and move the assignment to the macro where `out` is declared?",
        "createdAt" : "2019-03-29T03:07:33Z",
        "updatedAt" : "2019-03-29T03:07:34Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "360037b6-f019-43c2-afb6-603ec904132b",
        "parentId" : "ace4ae5e-6e30-4b75-8964-b708aaa6a049",
        "authorId" : "8cbd4cb6-9ed2-42f9-9a97-11b0cfc28c49",
        "body" : "It was entirely to preserve calling convention to be similar to the other macros - I've implemented your suggestion in https://github.com/numpy/numpy/pull/13208",
        "createdAt" : "2019-03-29T03:47:02Z",
        "updatedAt" : "2019-03-29T03:47:03Z",
        "lastEditedBy" : "8cbd4cb6-9ed2-42f9-9a97-11b0cfc28c49",
        "tags" : [
        ]
      }
    ],
    "commit" : "5785ca7bef5c0a44042f34c496bceeb79161cd8a",
    "line" : 12,
    "diffHunk" : "@@ -1,1 +653,657 @@BOOL_@kind@(char **args, npy_intp *dimensions, npy_intp *steps, void *NPY_UNUSED(func))\n{\n    OUTPUT_LOOP_FAST(npy_bool, *out = @val@);\n}\n"
  },
  {
    "id" : "5e5d26e4-ba67-4d9a-ac4c-4a844ca07029",
    "prId" : 13520,
    "prUrl" : "https://github.com/numpy/numpy/pull/13520#pullrequestreview-236418164",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a00f0d35-b0ac-4ec3-8534-f0831077dcd3",
        "parentId" : null,
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "this is not correct, the existing logic is to dispatch to the vectorized code function if appropriate and if not return false so the caller can run the fallback code.\r\n\r\nthe logic may be unnecessarily convoluted, a dispatcher that just runs both variants would be nicer. The simd code is in need of refactoring but that is a different issue.\r\nTo fix your code just remove this line and the preprocessor directives around it.\r\n\r\nthe `NPY_GCC_OPT_3` macro can probably also be removed, the UNARY_LOOP macro does not allow for much optimization and to vectorize it with UNARY_LOOP_FAST gcc would require the `-ffast-math` which we intentionally do not use as it has some unwanted side effects (mostly handling of special float values and exceptions).",
        "createdAt" : "2019-05-12T13:03:07Z",
        "updatedAt" : "2019-05-16T04:28:23Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      }
    ],
    "commit" : "4b4d2ab1f4be70467313975422b668596338c9b7",
    "line" : 15,
    "diffHunk" : "@@ -1,1 +1632,1636 @@             */\n#if defined @CHK@ && defined NPY_HAVE_SSE2_INTRINSICS\n            @ISA@_@func@_FLOAT((npy_float *)op1, (npy_float *)ip1, 1);\n#else\n            const npy_float in1 = *(npy_float *)ip1;"
  }
]
[
  {
    "id" : "59bca374-5959-4c53-bb4c-f879752000f0",
    "prId" : 87,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4513fe49-7191-4edc-bf07-96fb58941138",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "What is the reason for the underscore in _datetime.h ?\n",
        "createdAt" : "2011-06-15T05:11:55Z",
        "updatedAt" : "2011-06-16T19:50:35Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "a2640017-ac1b-491d-befc-e4c11258472e",
        "parentId" : "4513fe49-7191-4edc-bf07-96fb58941138",
        "authorId" : "95359633-f0b0-4899-8e46-e2146fd11511",
        "body" : "That's historical, and seems to be because datetime.h is the CPython header for accessing the Python datetime library objects.\n",
        "createdAt" : "2011-06-15T15:14:47Z",
        "updatedAt" : "2011-06-16T19:50:36Z",
        "lastEditedBy" : "95359633-f0b0-4899-8e46-e2146fd11511",
        "tags" : [
        ]
      }
    ],
    "commit" : "2d7d59aef203ebf25b268ceaccfa1be45237b0df",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +20,24 @@#include \"numpymemoryview.h\"\n#include \"lowlevel_strided_loops.h\"\n#include \"_datetime.h\"\n\n/*"
  },
  {
    "id" : "2a018ed6-9b1b-467d-80cd-e4020f64f9f9",
    "prId" : 444,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "146cc9da-105b-41ca-bd6b-484597d74770",
        "parentId" : null,
        "authorId" : "1b526ef0-1c83-44be-b2b5-41cf1ee854e2",
        "body" : "This check is causing np.ndindex() to fail in master which I didn't catch earlier.   Why is this check here?   We needed to remove this check to get code that used np.ndindex() working against master.  \n",
        "createdAt" : "2013-01-09T05:26:12Z",
        "updatedAt" : "2013-01-09T05:26:12Z",
        "lastEditedBy" : "1b526ef0-1c83-44be-b2b5-41cf1ee854e2",
        "tags" : [
        ]
      }
    ],
    "commit" : "92ecbdde33f6f61712d7d1a0e4500c76a65aac7a",
    "line" : 154,
    "diffHunk" : "@@ -1,1 +2081,2085 @@        PyObject *dataptr;\n        if (n == 0) {\n            PyErr_SetString(PyExc_ValueError,\n                    \"__array_interface__ shape must be at least size 1\");\n            goto fail;"
  },
  {
    "id" : "a96990be-fed7-4a0a-9760-a2b250fb5d22",
    "prId" : 3376,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b4713281-c986-48e2-b274-1430d7f2c408",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "I assume adding `stride` keeps he alignment.\n",
        "createdAt" : "2013-05-29T17:18:12Z",
        "updatedAt" : "2013-05-29T17:58:59Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "04a58ebe-132c-4bb1-98be-663036a94bf8",
        "parentId" : "b4713281-c986-48e2-b274-1430d7f2c408",
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "I'm assuming that, if it doesn't the old code would have garbled the input as it was still swapping two/four/eight byte elements\n",
        "createdAt" : "2013-05-29T17:21:16Z",
        "updatedAt" : "2013-05-29T17:58:59Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      }
    ],
    "commit" : "0258a3e65ba9fea8892aaa9761bf7e37c999c8fd",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +313,317 @@    case 4:\n        if (npy_is_aligned(p, sizeof(npy_uint32))) {\n            for (a = (char*)p; n > 0; n--, a += stride) {\n                npy_uint32 * a_ = (npy_uint32 *)a;\n                *a_ = npy_bswap4(*a_);"
  },
  {
    "id" : "00595d32-7e71-44b5-9285-4af0f433a71d",
    "prId" : 3491,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fc9ecdcb-ac17-41bd-9c77-989866fec691",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Looks like there should be more indentation of the logical expression part.\n",
        "createdAt" : "2013-07-07T23:27:47Z",
        "updatedAt" : "2013-07-08T18:44:49Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "bf463eb7-d82f-42c8-8a8f-4f99289a7969",
        "parentId" : "fc9ecdcb-ac17-41bd-9c77-989866fec691",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Yeah, the preceding logical parts need an extra indent. Basically:\n\n```\nif (log1 ||\n        log2 ||\n        log3) {\n    blah;\n}\n```\n",
        "createdAt" : "2013-07-08T17:55:40Z",
        "updatedAt" : "2013-07-08T18:44:49Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "97372dbe877f19ae73a070b05c380cfea0871dc0",
    "line" : 20,
    "diffHunk" : "@@ -1,1 +537,541 @@            PyBuffer_Check(s) ||\n#endif\n            PyUnicode_Check(s)) {\n\n        /* If an object has no length, leave it be */"
  },
  {
    "id" : "aac468bc-ca0e-4e57-a92c-b5003fdf24c2",
    "prId" : 3509,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1fe67176-ad58-4602-b002-156a61addaea",
        "parentId" : null,
        "authorId" : "dd0b7ee8-4e17-4855-aa9e-6c7c9ddba53b",
        "body" : "@charris you were right. It also work for multi-dimensional arrays when (newtype == NULL && flags == 0).\n",
        "createdAt" : "2013-07-08T17:41:17Z",
        "updatedAt" : "2013-07-10T15:28:45Z",
        "lastEditedBy" : "dd0b7ee8-4e17-4855-aa9e-6c7c9ddba53b",
        "tags" : [
        ]
      }
    ],
    "commit" : "6815f865678e88dab68c00c34fb1c9e7166f8f3c",
    "line" : null,
    "diffHunk" : "@@ -1,1 +1803,1807 @@         * If so return it directly instead of checking for casting.\n         */\n        if (flags == 0) {\n            Py_INCREF(arr);\n            return (PyObject *)arr;"
  },
  {
    "id" : "a1a30b27-3ab6-4f0b-b311-3a327947714d",
    "prId" : 3590,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7a90bff0-6abb-4456-912d-24ef08caf9e3",
        "parentId" : null,
        "authorId" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "body" : "This is really ugly. Can't we use the `NewFromDescr` `flags` argument instead?\n",
        "createdAt" : "2013-08-10T16:19:42Z",
        "updatedAt" : "2013-08-16T08:20:25Z",
        "lastEditedBy" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "tags" : [
        ]
      },
      {
        "id" : "723517b8-91f5-40c5-917e-2928cbbdf1e9",
        "parentId" : "7a90bff0-6abb-4456-912d-24ef08caf9e3",
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "if I read the code correctly flags of NewFromDescr is not used as flags, its just a boolean for c or fortran order if data is NULL\n\none could also add a static wrapper for NewFromDescr that takes an extra argument which is used from zeros which would be more explicit than this hack.\n",
        "createdAt" : "2013-08-12T12:49:49Z",
        "updatedAt" : "2013-08-16T08:20:25Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      },
      {
        "id" : "409e9e6f-574e-4afc-9db4-84293193b7f7",
        "parentId" : "7a90bff0-6abb-4456-912d-24ef08caf9e3",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "It's a bit ugly, but at least understandable ;) Might be the easiest thing to do here.\n",
        "createdAt" : "2013-08-13T15:25:36Z",
        "updatedAt" : "2013-08-16T08:20:25Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "d271d977bdfb977959db1ff26956666f3836b56b",
    "line" : 44,
    "diffHunk" : "@@ -1,1 +2695,2699 @@    PyArray_DESCR_REPLACE(type);\n    need_init = PyDataType_FLAGCHK(type, NPY_NEEDS_INIT);\n    type->flags |= NPY_NEEDS_INIT;\n\n    ret = (PyArrayObject *)PyArray_NewFromDescr(&PyArray_Type,"
  },
  {
    "id" : "3cc3454c-73da-4a14-ba99-6502019bd678",
    "prId" : 3761,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8d1adc87-ade5-4193-8a5d-cd8143c3bb47",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "I think PyObject_Unicode should be good for both Python 2 and 3.\n",
        "createdAt" : "2013-09-19T16:09:19Z",
        "updatedAt" : "2013-09-19T16:09:19Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "fa1900bb-3b19-4db3-b928-81a90c249354",
        "parentId" : "8d1adc87-ade5-4193-8a5d-cd8143c3bb47",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "In fact, since you are only trying to find the length, maybe unicode would work for all cases?\n",
        "createdAt" : "2013-09-19T16:38:16Z",
        "updatedAt" : "2013-09-19T16:38:16Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "8619fa90-54ad-4ca6-9bd4-fc80950ba2e5",
        "parentId" : "8d1adc87-ade5-4193-8a5d-cd8143c3bb47",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "In which case `stringtype` may not matter.\n",
        "createdAt" : "2013-09-19T16:39:36Z",
        "updatedAt" : "2013-09-19T16:39:36Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "e41d8e95-c4bc-4b75-ad6c-6c9f9d9b0ce6",
        "parentId" : "8d1adc87-ade5-4193-8a5d-cd8143c3bb47",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Nah, PyObject_Unicode is gone in 3.\n",
        "createdAt" : "2013-09-19T16:48:48Z",
        "updatedAt" : "2013-09-19T16:48:48Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "ee105ff1-48fe-456d-a36b-da8985da2afc",
        "parentId" : "8d1adc87-ade5-4193-8a5d-cd8143c3bb47",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Could add it to `npy_3kcompat`, but this is good as it.\n",
        "createdAt" : "2013-09-19T16:54:22Z",
        "updatedAt" : "2013-09-19T16:54:22Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "f200034eee16a97348400a0daa694870c703d2d9",
    "line" : 25,
    "diffHunk" : "@@ -1,1 +550,554 @@                s_string = PyObject_Str(s);\n#else\n                s_string = PyObject_Unicode(s);\n#endif\n            }"
  },
  {
    "id" : "f6f30f3a-728b-418f-977f-77f37291b6a8",
    "prId" : 3761,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4403b19d-bb4a-41fa-afdb-4ef3a4316560",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Probably want `PyObject_Bytes` here to match with `NPY_STRING`, good for both Python 2, 3.\n",
        "createdAt" : "2013-09-19T16:23:14Z",
        "updatedAt" : "2013-09-19T16:23:14Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "1250f302-5ce1-4df1-905d-0c5f5464b085",
        "parentId" : "4403b19d-bb4a-41fa-afdb-4ef3a4316560",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Or maybe not, `PyObject_Bytes` will fail for integers.\n",
        "createdAt" : "2013-09-19T16:32:27Z",
        "updatedAt" : "2013-09-19T16:32:27Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "3e73e76f-91fe-4665-aa29-703d9ddcd9f4",
        "parentId" : "4403b19d-bb4a-41fa-afdb-4ef3a4316560",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "nvm, I think this is good.\n",
        "createdAt" : "2013-09-19T16:34:05Z",
        "updatedAt" : "2013-09-19T16:34:05Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "f200034eee16a97348400a0daa694870c703d2d9",
    "line" : 19,
    "diffHunk" : "@@ -1,1 +544,548 @@            PyObject *s_string = NULL;\n            if (string_type == NPY_STRING) {\n                s_string = PyObject_Str(s);\n            }\n            else {"
  },
  {
    "id" : "b9bd6ff2-443d-4d29-a8bd-547a716f88d8",
    "prId" : 4244,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7b3bd628-dbf3-474a-9055-5ddda0f5e04b",
        "parentId" : null,
        "authorId" : "34105ae0-9fd2-4403-be9b-7c550a729828",
        "body" : "@juliantaylor Have you noticed this line? It's related with https://github.com/numpy/numpy/issues/4254, which I opened yesterday. Am I getting this right, or am I missing something?\n",
        "createdAt" : "2014-02-03T05:31:52Z",
        "updatedAt" : "2014-02-13T08:25:44Z",
        "lastEditedBy" : "34105ae0-9fd2-4403-be9b-7c550a729828",
        "tags" : [
        ]
      },
      {
        "id" : "3485a1ab-4522-46ec-9d07-4c4dcc147daa",
        "parentId" : "7b3bd628-dbf3-474a-9055-5ddda0f5e04b",
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "I think this is a correct solution, I didn't even know NPY_IGNORE exists :/\nnice work.\n",
        "createdAt" : "2014-02-04T01:01:00Z",
        "updatedAt" : "2014-02-13T08:25:44Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      }
    ],
    "commit" : "9350d4dc9cc5a8288c965008c8dd6034c991289a",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +1840,1844 @@            PyArray_DESCR_REPLACE(descr);\n        }\n        if (descr && descr->byteorder != NPY_IGNORE) {\n            descr->byteorder = NPY_NATIVE;\n        }"
  },
  {
    "id" : "5b81fbb8-4761-4b28-8d30-0fe1bc85cfd4",
    "prId" : 4777,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5b5f1d48-62c0-4ada-9214-7fcdba095bd3",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "How does the `|` work here, is it always safe?\n",
        "createdAt" : "2014-06-04T19:27:52Z",
        "updatedAt" : "2014-06-04T19:27:52Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "503db334-76b1-4325-80f8-4befee17aa6d",
        "parentId" : "5b5f1d48-62c0-4ada-9214-7fcdba095bd3",
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "stride is always added to p so if it is aligned the alignment of p will never be lost\n`is_aligned(a) && is_aligned(b)` is the same as `is_aligned(a | b)` as we are only interested in the low bits which must all be zero for it to be true.\nall alignment checks involving strides in numpy already work this way (e.g. _IsAligned)\n",
        "createdAt" : "2014-06-04T20:25:22Z",
        "updatedAt" : "2014-06-04T20:25:22Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      },
      {
        "id" : "937325ef-5883-44d1-83e8-bff9286c2e0c",
        "parentId" : "5b5f1d48-62c0-4ada-9214-7fcdba095bd3",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "So safe for powers of two alignment, but not in general, i.e., 2 | 4 modulo 3. Hmm... \n",
        "createdAt" : "2014-06-04T20:52:32Z",
        "updatedAt" : "2014-06-04T20:52:32Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "14eb63e9-fe8d-4abd-9007-de07fa34a033",
        "parentId" : "5b5f1d48-62c0-4ada-9214-7fcdba095bd3",
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "are cpus which have alignment requirements that are not powers of two still in existance (if they ever existed)?\n",
        "createdAt" : "2014-06-04T21:17:19Z",
        "updatedAt" : "2014-06-04T21:17:19Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      },
      {
        "id" : "646f0125-1b83-4cff-b80b-09c43a300ec3",
        "parentId" : "5b5f1d48-62c0-4ada-9214-7fcdba095bd3",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Don't know of any, although Burroughs built a machine with 51 bit words, 48 + 3 type bits. The 48 was in order to contain both 6 and 8 bit characters.  `npy_is_aligned` handles the not power of 2 case too, so the potential for error is there.\n",
        "createdAt" : "2014-06-04T21:30:06Z",
        "updatedAt" : "2014-06-04T21:30:06Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "d5e3698b-8736-43f9-9197-fee24fdc3756",
        "parentId" : "5b5f1d48-62c0-4ada-9214-7fcdba095bd3",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Oh, and the PDP-8 had twelve bit words, hence the popularity of octal. Memory was split into 128 word pages with the lowest page acting as common memory for the rest.\n",
        "createdAt" : "2014-06-04T21:39:59Z",
        "updatedAt" : "2014-06-04T21:39:59Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "9749fa92683ceeeac918b369da2824f756e931e8",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +319,323 @@        break;\n    case 4:\n        if (npy_is_aligned((void*)((npy_intp)p | stride), sizeof(npy_uint32))) {\n            for (a = (char*)p; n > 0; n--, a += stride) {\n                npy_uint32 * a_ = (npy_uint32 *)a;"
  }
]
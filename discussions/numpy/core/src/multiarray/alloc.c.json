[
  {
    "id" : "93a4c9c7-42eb-4e57-a34f-474c9a70242d",
    "prId" : 8920,
    "prUrl" : "https://github.com/numpy/numpy/pull/8920#pullrequestreview-31873614",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c7055f88-94fc-4c0c-a95b-8ee9df01f994",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Still don't follow here - how do we end up on this code path? To me, it seems like we always passed an even number in the past.\r\n\r\nSo the only situation is when `sz == 0`. Why do we allocate any memory at all? Why would you ask for 0 bytes then proceed to write two of them?",
        "createdAt" : "2017-04-10T15:00:38Z",
        "updatedAt" : "2017-07-11T10:36:43Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "28fb78ae-562f-4e5a-8173-f186f8c592e6",
        "parentId" : "c7055f88-94fc-4c0c-a95b-8ee9df01f994",
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "The most important reason for existence of the cache is the `npy_alloc_cache_dim(2 * nd)` allocation in `PyArray_NewFromDescr_int`. In the important cases (small arrays) nd is often one.\r\nTo fill the cache with more values for arrays to use all other cache paths also allocate at least two entries.\r\nIt is probably not a particularly important optimization and could be removed with hardly an impact.",
        "createdAt" : "2017-04-10T15:04:53Z",
        "updatedAt" : "2017-07-11T10:36:43Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      },
      {
        "id" : "b9576d8b-3705-4fa2-a39e-e510a66d698f",
        "parentId" : "c7055f88-94fc-4c0c-a95b-8ee9df01f994",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Right, but before this PR that was the only cache path.\r\n\r\nSo is this really a performance optimization so that 0d arrays preallocate data for 1d arrays? Or is this just working around calling `malloc(0)`, which might return `NULL`?",
        "createdAt" : "2017-04-10T15:12:42Z",
        "updatedAt" : "2017-07-11T10:36:43Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "8fe1f618-941b-47df-95ad-1a31af2689d7",
        "parentId" : "c7055f88-94fc-4c0c-a95b-8ee9df01f994",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "On a similar note, we'll be missing the existing cache a lot more here since dims alone can be odd - is it worth looking always looking up in the cache with `sz | 1` or something, so that the lookup is always odd?",
        "createdAt" : "2017-04-10T15:14:50Z",
        "updatedAt" : "2017-07-11T10:36:43Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "0450e3e3-7141-4df8-805d-a0dfbe0b7c8d",
        "parentId" : "c7055f88-94fc-4c0c-a95b-8ee9df01f994",
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "hm right it there was only one path, it was premature optimization then. I probably planned to do this change a lot sooner ;)\r\nfor something to miss one already has to deal with 3d arrays. these are pretty unlikely to be so small that the cache is relevant.\r\nThe cache really does not need to be perfect. It just needs to cover the extremely common alloc + immediate dealloc loop which it does.",
        "createdAt" : "2017-04-10T15:19:18Z",
        "updatedAt" : "2017-07-11T10:36:43Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      }
    ],
    "commit" : "c1141697d67a02c6c390f8f23ac66393d97a0ad4",
    "line" : 9,
    "diffHunk" : "@@ -1,1 +130,134 @@     * make sure any temporary allocation can be used for array metadata which\n     * uses one memory block for both dimensions and strides\n     */\n    if (sz < 2) {\n        sz = 2;"
  },
  {
    "id" : "39016561-6d01-453f-9f90-f280bfd19746",
    "prId" : 14216,
    "prUrl" : "https://github.com/numpy/numpy/pull/14216#pullrequestreview-272142940",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7419817c-666a-4797-8ba1-aa79b7bb2ce5",
        "parentId" : null,
        "authorId" : "7714a86d-e4db-41f5-8928-d91402bb82aa",
        "body" : "I think you should add a comment here that we explicitely do not check the return code of madvise because we want to optimistically ask for HUGEPAGE even in the case that an old kernel is being used. ",
        "createdAt" : "2019-08-07T13:37:57Z",
        "updatedAt" : "2019-08-07T18:16:24Z",
        "lastEditedBy" : "7714a86d-e4db-41f5-8928-d91402bb82aa",
        "tags" : [
        ]
      },
      {
        "id" : "00bb1420-49e7-435c-953f-b18b63955dfa",
        "parentId" : "7419817c-666a-4797-8ba1-aa79b7bb2ce5",
        "authorId" : "6e17f0b6-e8c6-47b6-83f4-6aa30f051dc0",
        "body" : "Agreed. I added that comment in the latest commit.",
        "createdAt" : "2019-08-07T18:16:51Z",
        "updatedAt" : "2019-08-07T18:16:51Z",
        "lastEditedBy" : "6e17f0b6-e8c6-47b6-83f4-6aa30f051dc0",
        "tags" : [
        ]
      }
    ],
    "commit" : "92fa9858db4a17f6818b4241a6d94ffbe7ba1170",
    "line" : 32,
    "diffHunk" : "@@ -1,1 +88,92 @@             * older kernel versions; optimistically tries enabling huge pages.\n             */\n            madvise((void*)((npy_uintp)p + offset), length, MADV_HUGEPAGE);\n        }\n#endif"
  },
  {
    "id" : "5f921453-62ea-4778-9e27-142b835bef2b",
    "prId" : 14216,
    "prUrl" : "https://github.com/numpy/numpy/pull/14216#pullrequestreview-274382902",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "59b0707a-6547-41d1-b9c5-d120ea03ac0b",
        "parentId" : null,
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Is `NPY_OS_LINUX` a true superset of `HAVE_SYS_MMAN_H`? Just curious.",
        "createdAt" : "2019-08-13T14:39:26Z",
        "updatedAt" : "2019-08-13T14:39:27Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "affac6ec-0ea6-4241-bbca-ffa117a8dde8",
        "parentId" : "59b0707a-6547-41d1-b9c5-d120ea03ac0b",
        "authorId" : "6e17f0b6-e8c6-47b6-83f4-6aa30f051dc0",
        "body" : "`<sys/mman.h>` dates back to Unix and I've confirmed that it exists [at least since kernel 2.6.0](http://tomoyo.osdn.jp/cgi-bin/lxr/source/include/linux/mman.h?v=linux-2.6.0) (possibly before), so I think it's a safe bet.",
        "createdAt" : "2019-08-13T15:01:43Z",
        "updatedAt" : "2019-08-13T15:01:43Z",
        "lastEditedBy" : "6e17f0b6-e8c6-47b6-83f4-6aa30f051dc0",
        "tags" : [
        ]
      },
      {
        "id" : "a9992100-744f-4c21-87a9-890de5d82de3",
        "parentId" : "59b0707a-6547-41d1-b9c5-d120ea03ac0b",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Sorry, I mean that `NPY_OS_SOLARIS` or `NPY_OS_DARWIN` may currently succeed `HAVE_SYS_MMAN_H ` but are not covered under `NPY_OS_LINUX `",
        "createdAt" : "2019-08-13T15:10:43Z",
        "updatedAt" : "2019-08-13T15:10:43Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "e2c75977-9880-4dbd-be17-44bb293bd0ca",
        "parentId" : "59b0707a-6547-41d1-b9c5-d120ea03ac0b",
        "authorId" : "6e17f0b6-e8c6-47b6-83f4-6aa30f051dc0",
        "body" : "That's right, but we're only including `<sys/mman.h>` for `MADV_HUGEPAGE`, and, AFAIK, that's a feature only available on Linux.",
        "createdAt" : "2019-08-13T15:50:25Z",
        "updatedAt" : "2019-08-13T15:50:25Z",
        "lastEditedBy" : "6e17f0b6-e8c6-47b6-83f4-6aa30f051dc0",
        "tags" : [
        ]
      }
    ],
    "commit" : "92fa9858db4a17f6818b4241a6d94ffbe7ba1170",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +26,30 @@#include <assert.h>\n\n#ifdef NPY_OS_LINUX\n#include <sys/mman.h>\n#ifndef MADV_HUGEPAGE"
  },
  {
    "id" : "9ce87917-aef2-4557-90f1-bba58df49870",
    "prId" : 14216,
    "prUrl" : "https://github.com/numpy/numpy/pull/14216#pullrequestreview-277441184",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ea3c9b5b-65f2-45a0-b65d-ce3c03204bca",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Just to clarify, this means that even if compiled on a machine running an old kernel, it will enable huge pages when run on a newer kernel?",
        "createdAt" : "2019-08-20T19:03:51Z",
        "updatedAt" : "2019-08-20T19:03:51Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "07bab755-91f6-4ccb-a1f8-b58a8b487186",
        "parentId" : "ea3c9b5b-65f2-45a0-b65d-ce3c03204bca",
        "authorId" : "6e17f0b6-e8c6-47b6-83f4-6aa30f051dc0",
        "body" : "That's correct. An attempt to enable it will be made, and if it errors out, hugepages is simply ignored.",
        "createdAt" : "2019-08-20T21:07:53Z",
        "updatedAt" : "2019-08-20T21:07:53Z",
        "lastEditedBy" : "6e17f0b6-e8c6-47b6-83f4-6aa30f051dc0",
        "tags" : [
        ]
      }
    ],
    "commit" : "92fa9858db4a17f6818b4241a6d94ffbe7ba1170",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +32,36 @@ * Use code 14 (MADV_HUGEPAGE) if it isn't defined. This gives a chance of\n * enabling huge pages even if built with linux kernel < 2.6.38\n */\n#define MADV_HUGEPAGE 14\n#endif"
  },
  {
    "id" : "dbc46e8b-67bd-4fc1-97ce-360a952748f4",
    "prId" : 15769,
    "prUrl" : "https://github.com/numpy/numpy/pull/15769#pullrequestreview-401522950",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5150d6c9-b55e-4765-a915-6e03f2bf152e",
        "parentId" : null,
        "authorId" : "fe664d20-2239-4242-9bd1-2c7a4f010863",
        "body" : "probably doesnt matter, since our code doesnt check the return val, but will this always return Py_RETURN_TRUE ?",
        "createdAt" : "2020-04-27T23:44:18Z",
        "updatedAt" : "2020-04-29T00:22:55Z",
        "lastEditedBy" : "fe664d20-2239-4242-9bd1-2c7a4f010863",
        "tags" : [
        ]
      },
      {
        "id" : "ff73f16a-b871-4a0c-9397-88913948593f",
        "parentId" : "5150d6c9-b55e-4765-a915-6e03f2bf152e",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Not sure I follow, this function sets the behaviour and returns the current state, either `True` or `False` in the line below?",
        "createdAt" : "2020-04-28T00:37:45Z",
        "updatedAt" : "2020-04-29T00:22:55Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "8d6d3067-c299-4ee6-b6d7-8c7e4c38c2aa",
        "parentId" : "5150d6c9-b55e-4765-a915-6e03f2bf152e",
        "authorId" : "fe664d20-2239-4242-9bd1-2c7a4f010863",
        "body" : "but `was_enabled` was set to `_madvise_hugepage` value which is set to 1 above, it doesnt seem to change. isnt `was_enabled` always 1 ?",
        "createdAt" : "2020-04-28T00:42:37Z",
        "updatedAt" : "2020-04-29T00:22:55Z",
        "lastEditedBy" : "fe664d20-2239-4242-9bd1-2c7a4f010863",
        "tags" : [
        ]
      },
      {
        "id" : "a8543eb0-d5d4-49b8-9fe9-eed389317e07",
        "parentId" : "5150d6c9-b55e-4765-a915-6e03f2bf152e",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Maybe I have to add a test to proof that it does, I admit. `was_enabled` is a *copy* of the global static `_madvise_hugepage`, which is modified with `_madvise_hugepage = enabled`. So if `enabled` is 0, on the next call `was_enabled` will be 0.",
        "createdAt" : "2020-04-28T00:45:54Z",
        "updatedAt" : "2020-04-29T00:22:55Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "9a708ad3-487d-401e-b6f5-a655113a9173",
        "parentId" : "5150d6c9-b55e-4765-a915-6e03f2bf152e",
        "authorId" : "fe664d20-2239-4242-9bd1-2c7a4f010863",
        "body" : "okay thanks for explaining, i guess i misunderstood this function completely :grin: . i was expecting it to return true for platforms where _set_madvise_hugepage works (i.e. it is able to use this env variable  and false where it doesnt, didnt realize was_enabled was for the next function call).",
        "createdAt" : "2020-04-28T01:05:43Z",
        "updatedAt" : "2020-04-29T00:22:55Z",
        "lastEditedBy" : "fe664d20-2239-4242-9bd1-2c7a4f010863",
        "tags" : [
        ]
      },
      {
        "id" : "96ae0726-0236-4129-955d-f1e09356988a",
        "parentId" : "5150d6c9-b55e-4765-a915-6e03f2bf152e",
        "authorId" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "body" : "A comment before the function with an explanation may help prevent future confusion.",
        "createdAt" : "2020-04-28T06:09:59Z",
        "updatedAt" : "2020-04-29T00:22:55Z",
        "lastEditedBy" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "tags" : [
        ]
      }
    ],
    "commit" : "33958023330fb739013824849114eb52acabe176",
    "line" : 24,
    "diffHunk" : "@@ -1,1 +68,72 @@    _madvise_hugepage = enabled;\n    if (was_enabled) {\n        Py_RETURN_TRUE;\n    }\n    Py_RETURN_FALSE;"
  }
]
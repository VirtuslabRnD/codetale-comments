[
  {
    "id" : "93a4c9c7-42eb-4e57-a34f-474c9a70242d",
    "prId" : 8920,
    "prUrl" : "https://github.com/numpy/numpy/pull/8920#pullrequestreview-31873614",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c7055f88-94fc-4c0c-a95b-8ee9df01f994",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Still don't follow here - how do we end up on this code path? To me, it seems like we always passed an even number in the past.\r\n\r\nSo the only situation is when `sz == 0`. Why do we allocate any memory at all? Why would you ask for 0 bytes then proceed to write two of them?",
        "createdAt" : "2017-04-10T15:00:38Z",
        "updatedAt" : "2017-07-11T10:36:43Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "28fb78ae-562f-4e5a-8173-f186f8c592e6",
        "parentId" : "c7055f88-94fc-4c0c-a95b-8ee9df01f994",
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "The most important reason for existence of the cache is the `npy_alloc_cache_dim(2 * nd)` allocation in `PyArray_NewFromDescr_int`. In the important cases (small arrays) nd is often one.\r\nTo fill the cache with more values for arrays to use all other cache paths also allocate at least two entries.\r\nIt is probably not a particularly important optimization and could be removed with hardly an impact.",
        "createdAt" : "2017-04-10T15:04:53Z",
        "updatedAt" : "2017-07-11T10:36:43Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      },
      {
        "id" : "b9576d8b-3705-4fa2-a39e-e510a66d698f",
        "parentId" : "c7055f88-94fc-4c0c-a95b-8ee9df01f994",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Right, but before this PR that was the only cache path.\r\n\r\nSo is this really a performance optimization so that 0d arrays preallocate data for 1d arrays? Or is this just working around calling `malloc(0)`, which might return `NULL`?",
        "createdAt" : "2017-04-10T15:12:42Z",
        "updatedAt" : "2017-07-11T10:36:43Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "8fe1f618-941b-47df-95ad-1a31af2689d7",
        "parentId" : "c7055f88-94fc-4c0c-a95b-8ee9df01f994",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "On a similar note, we'll be missing the existing cache a lot more here since dims alone can be odd - is it worth looking always looking up in the cache with `sz | 1` or something, so that the lookup is always odd?",
        "createdAt" : "2017-04-10T15:14:50Z",
        "updatedAt" : "2017-07-11T10:36:43Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "0450e3e3-7141-4df8-805d-a0dfbe0b7c8d",
        "parentId" : "c7055f88-94fc-4c0c-a95b-8ee9df01f994",
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "hm right it there was only one path, it was premature optimization then. I probably planned to do this change a lot sooner ;)\r\nfor something to miss one already has to deal with 3d arrays. these are pretty unlikely to be so small that the cache is relevant.\r\nThe cache really does not need to be perfect. It just needs to cover the extremely common alloc + immediate dealloc loop which it does.",
        "createdAt" : "2017-04-10T15:19:18Z",
        "updatedAt" : "2017-07-11T10:36:43Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      }
    ],
    "commit" : "c1141697d67a02c6c390f8f23ac66393d97a0ad4",
    "line" : 9,
    "diffHunk" : "@@ -1,1 +130,134 @@     * make sure any temporary allocation can be used for array metadata which\n     * uses one memory block for both dimensions and strides\n     */\n    if (sz < 2) {\n        sz = 2;"
  }
]
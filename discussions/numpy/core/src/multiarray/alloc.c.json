[
  {
    "id" : "93a4c9c7-42eb-4e57-a34f-474c9a70242d",
    "prId" : 8920,
    "prUrl" : "https://github.com/numpy/numpy/pull/8920#pullrequestreview-31873614",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c7055f88-94fc-4c0c-a95b-8ee9df01f994",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Still don't follow here - how do we end up on this code path? To me, it seems like we always passed an even number in the past.\r\n\r\nSo the only situation is when `sz == 0`. Why do we allocate any memory at all? Why would you ask for 0 bytes then proceed to write two of them?",
        "createdAt" : "2017-04-10T15:00:38Z",
        "updatedAt" : "2017-07-11T10:36:43Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "28fb78ae-562f-4e5a-8173-f186f8c592e6",
        "parentId" : "c7055f88-94fc-4c0c-a95b-8ee9df01f994",
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "The most important reason for existence of the cache is the `npy_alloc_cache_dim(2 * nd)` allocation in `PyArray_NewFromDescr_int`. In the important cases (small arrays) nd is often one.\r\nTo fill the cache with more values for arrays to use all other cache paths also allocate at least two entries.\r\nIt is probably not a particularly important optimization and could be removed with hardly an impact.",
        "createdAt" : "2017-04-10T15:04:53Z",
        "updatedAt" : "2017-07-11T10:36:43Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      },
      {
        "id" : "b9576d8b-3705-4fa2-a39e-e510a66d698f",
        "parentId" : "c7055f88-94fc-4c0c-a95b-8ee9df01f994",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Right, but before this PR that was the only cache path.\r\n\r\nSo is this really a performance optimization so that 0d arrays preallocate data for 1d arrays? Or is this just working around calling `malloc(0)`, which might return `NULL`?",
        "createdAt" : "2017-04-10T15:12:42Z",
        "updatedAt" : "2017-07-11T10:36:43Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "8fe1f618-941b-47df-95ad-1a31af2689d7",
        "parentId" : "c7055f88-94fc-4c0c-a95b-8ee9df01f994",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "On a similar note, we'll be missing the existing cache a lot more here since dims alone can be odd - is it worth looking always looking up in the cache with `sz | 1` or something, so that the lookup is always odd?",
        "createdAt" : "2017-04-10T15:14:50Z",
        "updatedAt" : "2017-07-11T10:36:43Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "0450e3e3-7141-4df8-805d-a0dfbe0b7c8d",
        "parentId" : "c7055f88-94fc-4c0c-a95b-8ee9df01f994",
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "hm right it there was only one path, it was premature optimization then. I probably planned to do this change a lot sooner ;)\r\nfor something to miss one already has to deal with 3d arrays. these are pretty unlikely to be so small that the cache is relevant.\r\nThe cache really does not need to be perfect. It just needs to cover the extremely common alloc + immediate dealloc loop which it does.",
        "createdAt" : "2017-04-10T15:19:18Z",
        "updatedAt" : "2017-07-11T10:36:43Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      }
    ],
    "commit" : "c1141697d67a02c6c390f8f23ac66393d97a0ad4",
    "line" : 9,
    "diffHunk" : "@@ -1,1 +130,134 @@     * make sure any temporary allocation can be used for array metadata which\n     * uses one memory block for both dimensions and strides\n     */\n    if (sz < 2) {\n        sz = 2;"
  },
  {
    "id" : "39016561-6d01-453f-9f90-f280bfd19746",
    "prId" : 14216,
    "prUrl" : "https://github.com/numpy/numpy/pull/14216#pullrequestreview-272142940",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7419817c-666a-4797-8ba1-aa79b7bb2ce5",
        "parentId" : null,
        "authorId" : "7714a86d-e4db-41f5-8928-d91402bb82aa",
        "body" : "I think you should add a comment here that we explicitely do not check the return code of madvise because we want to optimistically ask for HUGEPAGE even in the case that an old kernel is being used. ",
        "createdAt" : "2019-08-07T13:37:57Z",
        "updatedAt" : "2019-08-07T18:16:24Z",
        "lastEditedBy" : "7714a86d-e4db-41f5-8928-d91402bb82aa",
        "tags" : [
        ]
      },
      {
        "id" : "00bb1420-49e7-435c-953f-b18b63955dfa",
        "parentId" : "7419817c-666a-4797-8ba1-aa79b7bb2ce5",
        "authorId" : "6e17f0b6-e8c6-47b6-83f4-6aa30f051dc0",
        "body" : "Agreed. I added that comment in the latest commit.",
        "createdAt" : "2019-08-07T18:16:51Z",
        "updatedAt" : "2019-08-07T18:16:51Z",
        "lastEditedBy" : "6e17f0b6-e8c6-47b6-83f4-6aa30f051dc0",
        "tags" : [
        ]
      }
    ],
    "commit" : "92fa9858db4a17f6818b4241a6d94ffbe7ba1170",
    "line" : 32,
    "diffHunk" : "@@ -1,1 +88,92 @@             * older kernel versions; optimistically tries enabling huge pages.\n             */\n            madvise((void*)((npy_uintp)p + offset), length, MADV_HUGEPAGE);\n        }\n#endif"
  },
  {
    "id" : "5f921453-62ea-4778-9e27-142b835bef2b",
    "prId" : 14216,
    "prUrl" : "https://github.com/numpy/numpy/pull/14216#pullrequestreview-274382902",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "59b0707a-6547-41d1-b9c5-d120ea03ac0b",
        "parentId" : null,
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Is `NPY_OS_LINUX` a true superset of `HAVE_SYS_MMAN_H`? Just curious.",
        "createdAt" : "2019-08-13T14:39:26Z",
        "updatedAt" : "2019-08-13T14:39:27Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "affac6ec-0ea6-4241-bbca-ffa117a8dde8",
        "parentId" : "59b0707a-6547-41d1-b9c5-d120ea03ac0b",
        "authorId" : "6e17f0b6-e8c6-47b6-83f4-6aa30f051dc0",
        "body" : "`<sys/mman.h>` dates back to Unix and I've confirmed that it exists [at least since kernel 2.6.0](http://tomoyo.osdn.jp/cgi-bin/lxr/source/include/linux/mman.h?v=linux-2.6.0) (possibly before), so I think it's a safe bet.",
        "createdAt" : "2019-08-13T15:01:43Z",
        "updatedAt" : "2019-08-13T15:01:43Z",
        "lastEditedBy" : "6e17f0b6-e8c6-47b6-83f4-6aa30f051dc0",
        "tags" : [
        ]
      },
      {
        "id" : "a9992100-744f-4c21-87a9-890de5d82de3",
        "parentId" : "59b0707a-6547-41d1-b9c5-d120ea03ac0b",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Sorry, I mean that `NPY_OS_SOLARIS` or `NPY_OS_DARWIN` may currently succeed `HAVE_SYS_MMAN_H ` but are not covered under `NPY_OS_LINUX `",
        "createdAt" : "2019-08-13T15:10:43Z",
        "updatedAt" : "2019-08-13T15:10:43Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "e2c75977-9880-4dbd-be17-44bb293bd0ca",
        "parentId" : "59b0707a-6547-41d1-b9c5-d120ea03ac0b",
        "authorId" : "6e17f0b6-e8c6-47b6-83f4-6aa30f051dc0",
        "body" : "That's right, but we're only including `<sys/mman.h>` for `MADV_HUGEPAGE`, and, AFAIK, that's a feature only available on Linux.",
        "createdAt" : "2019-08-13T15:50:25Z",
        "updatedAt" : "2019-08-13T15:50:25Z",
        "lastEditedBy" : "6e17f0b6-e8c6-47b6-83f4-6aa30f051dc0",
        "tags" : [
        ]
      }
    ],
    "commit" : "92fa9858db4a17f6818b4241a6d94ffbe7ba1170",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +26,30 @@#include <assert.h>\n\n#ifdef NPY_OS_LINUX\n#include <sys/mman.h>\n#ifndef MADV_HUGEPAGE"
  },
  {
    "id" : "9ce87917-aef2-4557-90f1-bba58df49870",
    "prId" : 14216,
    "prUrl" : "https://github.com/numpy/numpy/pull/14216#pullrequestreview-277441184",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ea3c9b5b-65f2-45a0-b65d-ce3c03204bca",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Just to clarify, this means that even if compiled on a machine running an old kernel, it will enable huge pages when run on a newer kernel?",
        "createdAt" : "2019-08-20T19:03:51Z",
        "updatedAt" : "2019-08-20T19:03:51Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "07bab755-91f6-4ccb-a1f8-b58a8b487186",
        "parentId" : "ea3c9b5b-65f2-45a0-b65d-ce3c03204bca",
        "authorId" : "6e17f0b6-e8c6-47b6-83f4-6aa30f051dc0",
        "body" : "That's correct. An attempt to enable it will be made, and if it errors out, hugepages is simply ignored.",
        "createdAt" : "2019-08-20T21:07:53Z",
        "updatedAt" : "2019-08-20T21:07:53Z",
        "lastEditedBy" : "6e17f0b6-e8c6-47b6-83f4-6aa30f051dc0",
        "tags" : [
        ]
      }
    ],
    "commit" : "92fa9858db4a17f6818b4241a6d94ffbe7ba1170",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +32,36 @@ * Use code 14 (MADV_HUGEPAGE) if it isn't defined. This gives a chance of\n * enabling huge pages even if built with linux kernel < 2.6.38\n */\n#define MADV_HUGEPAGE 14\n#endif"
  }
]
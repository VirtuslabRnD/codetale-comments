[
  {
    "id" : "d41703f1-8dc8-44f7-9587-cca326ea4d08",
    "prId" : 3243,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ad4f5ccb-5723-46af-9dd6-776621552946",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "`is_valid_conversion` or some such might be a better name. That said, I like the original better is it makes clear the combination of a -1 return value and `PyErr_Occurred`. Might be better to have a function that combined the conversion with the error detection so the two can't become separated. Maybe `NpyInt_AsAxis(tmp, &axis)` or some such.\n",
        "createdAt" : "2013-04-15T17:47:50Z",
        "updatedAt" : "2013-06-09T15:10:57Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "7ba81768-4440-456c-a29f-7b097ecef1b3",
        "parentId" : "ad4f5ccb-5723-46af-9dd6-776621552946",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Make that `PyArray_PyIntAsAxis`.\n",
        "createdAt" : "2013-04-15T17:52:59Z",
        "updatedAt" : "2013-06-09T15:10:57Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "714d69bd-e95e-4b92-975a-e89e2735fb0b",
        "parentId" : "ad4f5ccb-5723-46af-9dd6-776621552946",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Can change it back to the -1 thing. the error_converting is used in some places across numpy and is just a macro anyway. A new public conversion function for a single axes or even integer/intp, or what do you suggest?\n",
        "createdAt" : "2013-04-15T18:23:34Z",
        "updatedAt" : "2013-06-09T15:10:57Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "ba71c3e0-07ea-411f-b723-be27e11390d0",
        "parentId" : "ad4f5ccb-5723-46af-9dd6-776621552946",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Because the error should be checked immediately after the conversion, I think it is a bad idea to separate the two. The name is up for grabs and I don't think it needs to be exposed, but if the variable receiving the result is passed by reference then the function return can be used for an error flag. So I think the `PyErr_Occurred` check should be part of the conversion so you could do\n\n```\nif (pyint_as_axis(obj, &axis) < 0) {\n    PyErr_Format(...);\n    return -1;\n}\n```\n\nMakes it more like a converter. \n",
        "createdAt" : "2013-04-15T18:54:45Z",
        "updatedAt" : "2013-06-09T15:10:57Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "163f6df5a6668d06cb7abfe38dbd03d19b26d6f3",
    "line" : 57,
    "diffHunk" : "@@ -1,1 +230,234 @@            int axis = PyArray_PyIntAsInt(tmp);\n            int axis_orig = axis;\n            if (error_converting(axis)) {\n                return NPY_FAIL;\n            }"
  },
  {
    "id" : "0eb46f18-4fcd-4f4e-bc76-fa152f197200",
    "prId" : 3360,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b6705e71-cfe5-4389-a513-e96ffb872cad",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Maybe \"select kind\", since \"kind\" is like a keyword.\n",
        "createdAt" : "2013-08-02T22:53:48Z",
        "updatedAt" : "2013-08-12T12:26:07Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "76f1809f-c876-4cd8-8478-d7ed3beccee8",
        "parentId" : "b6705e71-cfe5-4389-a513-e96ffb872cad",
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "should the sort be changed too? it uses the same wording\n",
        "createdAt" : "2013-08-12T12:24:34Z",
        "updatedAt" : "2013-08-12T12:26:07Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      },
      {
        "id" : "74654ee7-0ed7-4961-914a-28b8ee32f096",
        "parentId" : "b6705e71-cfe5-4389-a513-e96ffb872cad",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Let's leave it. In morning light the suggestion doesn't look like much of an improvement.\n",
        "createdAt" : "2013-08-12T13:23:21Z",
        "updatedAt" : "2013-08-12T13:23:21Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "4d9cd695486fa095c6bff3238341a85cbdb47d0e",
    "line" : 33,
    "diffHunk" : "@@ -1,1 +436,440 @@    else {\n        PyErr_Format(PyExc_ValueError,\n                     \"%s is an unrecognized kind of select\",\n                     str);\n        Py_XDECREF(tmp);"
  },
  {
    "id" : "edfa9ac2-623e-40c2-ba8d-74608996b667",
    "prId" : 3678,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bc302668-f261-4941-bc49-e24d823159f2",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Strictly speaking, we should probably check for equality of precision with long and long long, and generate a compile error if neither is met, as the overflow check provided by the `PyLong_As...` calls will not be valid in that case. \n",
        "createdAt" : "2013-09-04T03:38:42Z",
        "updatedAt" : "2013-09-04T03:38:58Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "3c8eb4eb396bd5227f2d8298ce60be0c4848fe0e",
    "line" : 3,
    "diffHunk" : "@@ -1,1 +726,730 @@PyArray_PyIntAsIntp(PyObject *o)\n{\n#if (NPY_SIZEOF_LONG < NPY_SIZEOF_INTP)\n    long long long_value = -1;\n#else"
  },
  {
    "id" : "080c6819-3860-4806-bc3a-9d24fedb2b9c",
    "prId" : 3827,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "80d4fadf-efa1-453c-9ea4-942442d69164",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Is it necessary for compatibility?\n",
        "createdAt" : "2013-09-28T19:47:18Z",
        "updatedAt" : "2013-09-28T19:47:18Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "9c0fd468-b35b-43dc-83e3-de68a254047b",
        "parentId" : "80d4fadf-efa1-453c-9ea4-942442d69164",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "I think it is necessary, the only thing that one could maybe argue that the array should instead hold the `view` as `base` (which also holds a reference to the object), but since view is not a python object...\n",
        "createdAt" : "2013-09-29T00:28:59Z",
        "updatedAt" : "2013-09-29T00:28:59Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "fc3bd043-c6e1-41ff-b524-47615ccc9f4c",
        "parentId" : "80d4fadf-efa1-453c-9ea4-942442d69164",
        "authorId" : "48d7d71b-9655-46b2-9a18-7c1fba7837d0",
        "body" : "Yes, strictly speaking, releasing the buffer here is wrong. The correct fix would be to have a \"managed buffer object\" that releases the buffer when its refcount drops to 0. In other places in Numpy, we use the python memoryview object for that --- but it has no mechanism for requiring the contiguity. So we'd need to steal the managed buffer implementation from CPython sources...\n",
        "createdAt" : "2013-09-29T10:49:55Z",
        "updatedAt" : "2013-09-29T10:49:55Z",
        "lastEditedBy" : "48d7d71b-9655-46b2-9a18-7c1fba7837d0",
        "tags" : [
        ]
      },
      {
        "id" : "28f4740d-089e-4ed4-9c03-6bf18d1f41cd",
        "parentId" : "80d4fadf-efa1-453c-9ea4-942442d69164",
        "authorId" : "48d7d71b-9655-46b2-9a18-7c1fba7837d0",
        "body" : "TODO in gh-3831\n",
        "createdAt" : "2013-09-29T10:53:19Z",
        "updatedAt" : "2013-09-29T10:53:19Z",
        "lastEditedBy" : "48d7d71b-9655-46b2-9a18-7c1fba7837d0",
        "tags" : [
        ]
      }
    ],
    "commit" : "3820f9e9c97560ec672dc1ba3b32bc2c38dcc15f",
    "line" : 37,
    "diffHunk" : "@@ -1,1 +176,180 @@     * no strict guarantee that the buffer sticks around after being released.\n     */\n    PyBuffer_Release(&view);\n\n    /* Point to the base of the buffer object if present */"
  }
]
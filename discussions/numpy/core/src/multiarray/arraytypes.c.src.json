[
  {
    "id" : "3b9fa94b-d90b-4be7-a7a2-108b417e2f03",
    "prId" : 3788,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7dfbee88-30a6-457f-8719-aaafe6036203",
        "parentId" : null,
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "I don't know if this can even be plausible triggered... in all other cases there is just no point in not turning the logic around.\n",
        "createdAt" : "2013-09-23T18:13:23Z",
        "updatedAt" : "2013-09-23T18:13:23Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      }
    ],
    "commit" : "ed7e9ab53a43188268cd8ddd7e8eb125fb32e495",
    "line" : 19,
    "diffHunk" : "@@ -1,1 +1162,1166 @@    PyObject *tmp;\n    for (i = 0; i < n; i++, ip +=skip, op++) {\n        tmp = *op;\n        *op = @FROMTYPE@_getitem((char *)ip, aip);\n        Py_XDECREF(tmp);"
  },
  {
    "id" : "258e9010-13dc-449e-9bf4-c81333b249e2",
    "prId" : 4572,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8b17c350-ea29-45ec-a303-f1e0e94799e5",
        "parentId" : null,
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Looks good to me, I think it is correct that we compare all bytes, since only trailing 0-bytes are stripped (`as\\x00d\\x00\\x00` is 'as\\x00d`). Probably doesn't matter, but`elsize` actually is int I think\n",
        "createdAt" : "2014-05-26T14:37:08Z",
        "updatedAt" : "2014-05-26T14:37:08Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "53b785cd-1b84-4623-9670-cbd77f45ab92",
        "parentId" : "8b17c350-ea29-45ec-a303-f1e0e94799e5",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Oh, heh, in my mind I combined the old and new usage of `i`, so nvm.\n",
        "createdAt" : "2014-05-26T14:51:46Z",
        "updatedAt" : "2014-05-26T14:51:46Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      }
    ],
    "commit" : "2f6da63938e516bb653b95f1de7b59b33c05a2fc",
    "line" : 11,
    "diffHunk" : "@@ -1,1 +2599,2603 @@    const unsigned char *c1 = (unsigned char *)ip1;\n    const unsigned char *c2 = (unsigned char *)ip2;\n    const size_t len = PyArray_DESCR(ap)->elsize;\n    int i;\n"
  },
  {
    "id" : "3beb26f8-7da5-41a6-83b4-0ab0c97f7866",
    "prId" : 4712,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "33bb5f96-c21f-41f9-9359-22d498aac69b",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "This returns `__int64`, which is more specific than `long long`. Any reason that strtoll won't be available for MSC? It is in at least VS2013. \n",
        "createdAt" : "2014-05-14T23:55:27Z",
        "updatedAt" : "2014-05-14T23:55:27Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "79734f51-019c-4e35-bf37-0cc684c76e93",
        "parentId" : "33bb5f96-c21f-41f9-9359-22d498aac69b",
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "I'm hoping int64 and long long is the same in VC\nif it has strtoll it will use it even with VC (assuming setup.py detects it)\n",
        "createdAt" : "2014-05-14T23:56:53Z",
        "updatedAt" : "2014-05-14T23:56:53Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      }
    ],
    "commit" : "ceffd0443e548b728708e50a2e1ffc5591c0161b",
    "line" : 10,
    "diffHunk" : "@@ -1,1 +112,116 @@    return strtoll(str, endptr, base);\n#elif defined _MSC_VER\n    return _strtoi64(str, endptr, base);\n#else\n    /* ok on 64 bit posix */"
  },
  {
    "id" : "350332fc-4969-49c9-b42e-1d1e1d85aa17",
    "prId" : 4712,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "476f10ab-500f-4696-8e52-a7d441b0ca01",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Is it safe to fall through here? What about 32 bit posix?\n",
        "createdAt" : "2014-05-14T23:56:22Z",
        "updatedAt" : "2014-05-14T23:56:22Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "2771c45b-718e-4469-9c47-a37d358f2f90",
        "parentId" : "476f10ab-500f-4696-8e52-a7d441b0ca01",
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "the only other option I see is reimplementing strtoll, this should only trigger on obsolete platforms, if someone has one of these and cares they need to provide a patch\n",
        "createdAt" : "2014-05-14T23:57:53Z",
        "updatedAt" : "2014-05-14T23:57:53Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      },
      {
        "id" : "ddc8a242-8aed-4b89-8f50-0ce360098a53",
        "parentId" : "476f10ab-500f-4696-8e52-a7d441b0ca01",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "OK, I guess it isn't any worse than it was ;)\n",
        "createdAt" : "2014-05-15T00:06:13Z",
        "updatedAt" : "2014-05-15T00:06:13Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "ceffd0443e548b728708e50a2e1ffc5591c0161b",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +115,119 @@#else\n    /* ok on 64 bit posix */\n    return PyOS_strtol(str, endptr, base);\n#endif\n}"
  },
  {
    "id" : "0fad9a82-466d-4bf9-aa25-5f33a6175b72",
    "prId" : 5135,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4fa8647d-3184-445e-8475-9aeeb4689893",
        "parentId" : null,
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "this loop could be merged with the inner one if we add restrict qualifiers, then the compiler can do this by itself.\n",
        "createdAt" : "2014-09-29T17:49:18Z",
        "updatedAt" : "2014-09-29T17:49:18Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      },
      {
        "id" : "ff75382d-7916-4ddb-8ab0-ebadc6d5ae40",
        "parentId" : "4fa8647d-3184-445e-8475-9aeeb4689893",
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "hmm if one additionally to the restricts adds NPY_GCC_UNROLL_LOOPS we don't even need the inner loop at all.\n",
        "createdAt" : "2014-09-29T18:10:38Z",
        "updatedAt" : "2014-09-29T18:10:38Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      }
    ],
    "commit" : "d3470b7351358e7d34141a818a6f71e81e0172ef",
    "line" : 65,
    "diffHunk" : "@@ -1,1 +3863,3867 @@                        const @type@ k@ksz@ = k[(@ksz@ - 1) * kstride];\n#endif\n/**end repeat2**/\n                        for (i = 0; i < nd; i++) {\n                            @type@ s = 0;"
  },
  {
    "id" : "ed79d493-28d5-4ab8-88fe-5759f9b02ebf",
    "prId" : 5501,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6f56e6ea-01d6-4195-a7d7-6df44a4f4ba3",
        "parentId" : null,
        "authorId" : "acce7360-5cef-46f0-ab05-4fb0ffdffe3a",
        "body" : "Speaking of branch prediction and code bumming, `gcc -O2` generates a loop with three conditional jumps, but if this conditional block is replaced with\n\n``` c\nj *= (j < nv);\n```\n\nthere's only two of them. Might be worth a try to see if multiplication is faster than modulo.\n",
        "createdAt" : "2015-01-26T22:54:38Z",
        "updatedAt" : "2015-01-26T22:59:58Z",
        "lastEditedBy" : "acce7360-5cef-46f0-ab05-4fb0ffdffe3a",
        "tags" : [
        ]
      },
      {
        "id" : "6718aa46-2e43-4751-a353-e1288fc7582d",
        "parentId" : "6f56e6ea-01d6-4195-a7d7-6df44a4f4ba3",
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "maybe worth a try, though a predicted near branch has among the best low latency/throughput of all instructions, multiplication is I think in the range of latency 4 throughout 1 cycle, likely the reason why the compiler does not do this transformation.\n",
        "createdAt" : "2015-01-27T01:23:18Z",
        "updatedAt" : "2015-01-27T01:23:18Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      },
      {
        "id" : "eac2a985-bdbb-40d3-ba40-c37ed5fdf8fa",
        "parentId" : "6f56e6ea-01d6-4195-a7d7-6df44a4f4ba3",
        "authorId" : "34105ae0-9fd2-4403-be9b-7c550a729828",
        "body" : "With the single benchmark I have been using, multiplying clocks in at 2.36 us, slightly better than current master, but noticeably slower than the single if in this PR, that takes 1.56 us.\n\n~~Playing the \"minimize branch misprediction\" game, my best effort so far, clocking in at 1.25 us and outperforming the current code in this PR is the following:~~\n\n```\ni = 0;\nwhile (i < ni) {\n    for (j = 0; j < nv; ++j, ++i) {\n        if (i >= ni) {\n            break;\n        }\n        in[i] = vals[j];\n    }\n}\n```\n\n~~I suppose this is capitalizing on the ability to smartly predict loops. I am not fully sure that it is worth uglying the code like this, neither would I bet any money on the result being consistent across processor architectures. My timings come from a Sandy Bridge Intel i5, FWIW.~~\n",
        "createdAt" : "2015-01-27T06:04:12Z",
        "updatedAt" : "2015-01-27T06:28:00Z",
        "lastEditedBy" : "34105ae0-9fd2-4403-be9b-7c550a729828",
        "tags" : [
        ]
      },
      {
        "id" : "d058c161-f2d8-46f0-bda8-08fc5d2d02d2",
        "parentId" : "6f56e6ea-01d6-4195-a7d7-6df44a4f4ba3",
        "authorId" : "34105ae0-9fd2-4403-be9b-7c550a729828",
        "body" : "The extra performance was of course coming from leaving the mask check out... Putting it back in the following takes the same time (1.55 us) as the much more readable single if in the current PR:\n\n```\nfor (i = 0; i < ni;) {\n    for (j = 0; j < nv && i < ni; ++j, ++i) {\n        if (mask[i]) {\n            in[i] = vals[j];\n        }\n    }\n}\n```\n",
        "createdAt" : "2015-01-27T06:23:19Z",
        "updatedAt" : "2015-01-27T06:23:19Z",
        "lastEditedBy" : "34105ae0-9fd2-4403-be9b-7c550a729828",
        "tags" : [
        ]
      }
    ],
    "commit" : "fc8db7395f51311e4856eaae25c4b3aa62bd9164",
    "line" : 22,
    "diffHunk" : "@@ -1,1 +3695,3699 @@            if (j >= nv) {\n                j = 0;\n            }\n            if (mask[i]) {\n                in[i] = vals[j];"
  },
  {
    "id" : "a0c13ce6-c6fa-412b-b447-754ffaf9b9fe",
    "prId" : 6053,
    "prUrl" : "https://github.com/numpy/numpy/pull/6053#pullrequestreview-33507581",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "76293c76-10d9-49cd-bf55-14a4f6818e44",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "What type of cast is even allowed here?",
        "createdAt" : "2017-04-19T11:01:45Z",
        "updatedAt" : "2017-09-07T21:54:14Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "8d78b302-fa3a-411b-beb7-2be89d870cb5",
        "parentId" : "76293c76-10d9-49cd-bf55-14a4f6818e44",
        "authorId" : "a4f03a99-2e43-482b-a9bc-5a9e359abb03",
        "body" : "This accounts for assigning between structures with different field types, eg ''f4,f4' to 'i4,i4'.",
        "createdAt" : "2017-04-19T14:05:33Z",
        "updatedAt" : "2017-09-07T21:54:14Z",
        "lastEditedBy" : "a4f03a99-2e43-482b-a9bc-5a9e359abb03",
        "tags" : [
        ]
      }
    ],
    "commit" : "9f27418f48ada95a1cf19c98a8d1116f97f86ec5",
    "line" : 68,
    "diffHunk" : "@@ -1,1 +839,843 @@    /* Slow path */\n    ret = PyArray_CastRawArrays(1, srcdata, dstdata, 0, 0,\n                                srcdescr, dstdescr, 0);\n    if (ret != NPY_SUCCEED) {\n        return -1;"
  }
]
[
  {
    "id" : "f6675ee7-6c6e-4f4d-81bb-d34b65be5e48",
    "prId" : 373,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "343aa303-ca6f-446d-add9-5a40ecdcba37",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "The PyDataMem_\\* functions might be preferable here, might also be a bit of overkill...\n",
        "createdAt" : "2012-08-03T16:38:45Z",
        "updatedAt" : "2012-08-03T16:38:45Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "7867181f-6be8-40d8-ba9a-c9351ac41de8",
        "parentId" : "343aa303-ca6f-446d-add9-5a40ecdcba37",
        "authorId" : "63f665c6-ca13-46c8-b51a-6bb09ba7078e",
        "body" : "I'm certainly no expert, but I know a memory leak when I see one, and I attempted to plug it in the simplest/quickest/least-invasive way I could find. I really have no preference as to how it gets fixed, as long as it gets fixed (preferably soon). [grin]\n\nDo you have (or could you quickly throw together) an alternative patch that uses the method you propose?\n",
        "createdAt" : "2012-08-03T16:59:24Z",
        "updatedAt" : "2012-08-03T16:59:24Z",
        "lastEditedBy" : "63f665c6-ca13-46c8-b51a-6bb09ba7078e",
        "tags" : [
        ]
      },
      {
        "id" : "af42e0f0-daea-4496-83e9-baf78c8e85df",
        "parentId" : "343aa303-ca6f-446d-add9-5a40ecdcba37",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "I think the patch looks fine, but there was a recent commit that allows tracking memory usage with the PyDataMem_NEW/PyDataMem_FREE. functions, so I'd like some input from the patch author as to what all memory we should be tracking and what we shouldn't worry about. You can see the routines themselves as they are in the same code unit.\n",
        "createdAt" : "2012-08-03T17:03:01Z",
        "updatedAt" : "2012-08-03T17:03:01Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "af8f2587-bfe6-45b8-8212-8db2e0c8a02b",
        "parentId" : "343aa303-ca6f-446d-add9-5a40ecdcba37",
        "authorId" : "1b526ef0-1c83-44be-b2b5-41cf1ee854e2",
        "body" : "The PyDataMem_\\* functions are for allocating array data.   This is allocating a c-array of pointers to ArrayObjects.  I don't think it would be helpful to track this in the same way.    \n\nPyArray_malloc/free seem like the right approach.  \n",
        "createdAt" : "2012-08-03T23:53:50Z",
        "updatedAt" : "2012-08-03T23:53:50Z",
        "lastEditedBy" : "1b526ef0-1c83-44be-b2b5-41cf1ee854e2",
        "tags" : [
        ]
      },
      {
        "id" : "396d8a53-2f58-431e-8fbc-99e28f61ad95",
        "parentId" : "343aa303-ca6f-446d-add9-5a40ecdcba37",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Well, that optionally uses the Python allocation. My own preference would probably be malloc/free if we don't want to track memory usage in these things.\n",
        "createdAt" : "2012-08-04T00:04:21Z",
        "updatedAt" : "2012-08-04T00:04:21Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "8a4e0f57844452ceca43388cb87f5a53c3471c80",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +603,607 @@        Py_DECREF(arrays[iarrays]);\n    }\n    PyArray_free(arrays);\n\n    return (PyObject *)ret;"
  },
  {
    "id" : "254724c6-b854-46f3-b06a-37c35e1efb3e",
    "prId" : 440,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "87011b82-ca09-4b1b-81a0-ecf62f046008",
        "parentId" : null,
        "authorId" : "e8ef9b42-d95e-465b-908c-dfe5f69d2334",
        "body" : "Maybe this should be generalized by doing `if (axis > ndim-1)` --> warning message, because this issue probably exists at higher dimensions as well.\n",
        "createdAt" : "2012-09-16T07:15:42Z",
        "updatedAt" : "2012-09-16T11:52:12Z",
        "lastEditedBy" : "e8ef9b42-d95e-465b-908c-dfe5f69d2334",
        "tags" : [
        ]
      },
      {
        "id" : "d1091625-d511-460f-8e0b-30cd7361a2d7",
        "parentId" : "87011b82-ca09-4b1b-81a0-ecf62f046008",
        "authorId" : "7ff2710f-0a12-46fb-a54a-d405dab78cf7",
        "body" : "I think the behavior has only changed for 1D arrays. For example, in numpy 1.6.1:\n\n<pre>\nIn [17]: a = np.zeros((1,3))\n\nIn [18]: b = np.zeros((2,3))\n\nIn [19]: np.concatenate((a, b))\nOut[19]: \narray([[ 0.,  0.,  0.],\n       [ 0.,  0.,  0.],\n       [ 0.,  0.,  0.]])\n\nIn [20]: np.concatenate((a, b), axis=10)\n---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\n<ipython-input-20-1db841fd19b0> in <module>()\n----> 1 np.concatenate((a, b), axis=10)\n\nValueError: bad axis1 argument to swapaxes\n</pre>\n",
        "createdAt" : "2012-09-16T11:43:55Z",
        "updatedAt" : "2012-09-16T11:52:13Z",
        "lastEditedBy" : "7ff2710f-0a12-46fb-a54a-d405dab78cf7",
        "tags" : [
        ]
      },
      {
        "id" : "cd8c1b88-3a23-4402-a4ad-4e7a09ec1c15",
        "parentId" : "87011b82-ca09-4b1b-81a0-ecf62f046008",
        "authorId" : "e8ef9b42-d95e-465b-908c-dfe5f69d2334",
        "body" : "Ah, I see, the current implementation has an explicit bounds-check in concatenate, but in earlier versions it already failed for multidimensional arrays in another part of the code. \n",
        "createdAt" : "2012-09-16T13:05:06Z",
        "updatedAt" : "2012-09-16T13:05:06Z",
        "lastEditedBy" : "e8ef9b42-d95e-465b-908c-dfe5f69d2334",
        "tags" : [
        ]
      }
    ],
    "commit" : "69afd27b870cd85f06c4409fcffd0734ddb2fe76",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +347,351 @@        axis = 0;\n    }\n\n    if (axis < 0 || axis >= ndim) {\n        PyErr_Format(PyExc_IndexError,"
  },
  {
    "id" : "1162f1e4-9a65-4ad2-a274-2d358b0a89e7",
    "prId" : 2777,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fe4aa007-1f2a-44b7-a01a-27275981dcb0",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Hmm, is it OK that PyArray_ITER_RESET is called before the exit? That's the only reason I can see that the loop was constructed that way.\n",
        "createdAt" : "2012-12-01T22:10:01Z",
        "updatedAt" : "2012-12-01T22:10:01Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "c6927377-c558-4f26-9b61-b73fe3decc97",
        "parentId" : "fe4aa007-1f2a-44b7-a01a-27275981dcb0",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Or it was a micro optimization.\n",
        "createdAt" : "2012-12-01T22:20:31Z",
        "updatedAt" : "2012-12-01T22:20:31Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "1961eb5c-4f2c-4839-acb0-fa02918805cb",
        "parentId" : "fe4aa007-1f2a-44b7-a01a-27275981dcb0",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Thought it was just optimization, but I didn't think about the cost of ITER_RESET. Could do an explicit check before the loop instead to keep the optimization.\n",
        "createdAt" : "2012-12-01T22:29:12Z",
        "updatedAt" : "2012-12-01T22:29:12Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "d894ef2f-cf6d-4d65-bad4-a88d902f09c6",
        "parentId" : "fe4aa007-1f2a-44b7-a01a-27275981dcb0",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "If it's not a problem I'd be inclined to keep your version. It adds a small bit of overhead but is clearer code.\n",
        "createdAt" : "2012-12-01T22:34:39Z",
        "updatedAt" : "2012-12-01T22:34:39Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "300783c0ed1518ad1335f3aad9a4bda35f5e1123",
    "line" : 27,
    "diffHunk" : "@@ -1,1 +889,893 @@        }\n        PyArray_ITER_NEXT(it1);\n        PyArray_ITER_RESET(it2);\n    }\n    NPY_END_THREADS_DESCR(PyArray_DESCR(ap2));"
  },
  {
    "id" : "78038c11-79cc-4c05-8409-21e4579db3dc",
    "prId" : 2777,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9bbfab83-dac9-4a61-a5a4-1b85e033bb84",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Is it the case that the size of  `ret` was set above, so this doesn't do anything new about shape/strides, just fills with zeros?\n",
        "createdAt" : "2012-12-01T22:12:30Z",
        "updatedAt" : "2012-12-01T22:12:30Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "bdbaef89-7665-4bfa-a792-ae79b5f78f97",
        "parentId" : "9bbfab83-dac9-4a61-a5a4-1b85e033bb84",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Yes, ret is defined just before this. This code is exactly the same as the one for dot, but was missing in inner.\n",
        "createdAt" : "2012-12-01T22:29:48Z",
        "updatedAt" : "2012-12-01T22:29:48Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "bcb77ef6-5269-4910-ad18-755004d7a04e",
        "parentId" : "9bbfab83-dac9-4a61-a5a4-1b85e033bb84",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Just out of curiosity, what happens if N or M is zero?\n",
        "createdAt" : "2012-12-01T22:38:57Z",
        "updatedAt" : "2012-12-01T22:38:57Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "a23ad5f9-4065-430a-871c-58ddeba787ad",
        "parentId" : "9bbfab83-dac9-4a61-a5a4-1b85e033bb84",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "The output array has 0-size. So nothing needed there. But that was the problem that is fixed by changing that while loop, because it actually did one inner loop in that case before.\n",
        "createdAt" : "2012-12-01T22:44:08Z",
        "updatedAt" : "2012-12-01T22:44:08Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "33f9fff3-7765-4f03-9ce1-b8e2e65dc726",
        "parentId" : "9bbfab83-dac9-4a61-a5a4-1b85e033bb84",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "ah... `PyArray_NBYTES(ret) == 0` that is. Which means memset doesn't do anything...\n",
        "createdAt" : "2012-12-01T22:46:12Z",
        "updatedAt" : "2012-12-01T22:46:12Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "211b5ab4-a57f-450d-b070-511dca71ce67",
        "parentId" : "9bbfab83-dac9-4a61-a5a4-1b85e033bb84",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Ah, got it. A note in the commit message could have clarified that, or maybe if I was smarter ...\n\nI'll just go ahead with the commit.\n",
        "createdAt" : "2012-12-01T22:49:15Z",
        "updatedAt" : "2012-12-01T22:49:15Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "300783c0ed1518ad1335f3aad9a4bda35f5e1123",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +865,869 @@    /* Ensure that multiarray.inner(<Nx0>,<Mx0>) -> zeros((N,M)) */\n    if (PyArray_SIZE(ap1) == 0 && PyArray_SIZE(ap2) == 0) {\n        memset(PyArray_DATA(ret), 0, PyArray_NBYTES(ret));\n    }\n"
  },
  {
    "id" : "4114c4f7-699c-449c-b793-69a314cc9554",
    "prId" : 2777,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5c015e79-7a6e-4f14-8e6b-a1ca6d994a42",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Same comment as previous loop.\n",
        "createdAt" : "2012-12-01T22:13:00Z",
        "updatedAt" : "2012-12-01T22:13:00Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "300783c0ed1518ad1335f3aad9a4bda35f5e1123",
    "line" : 56,
    "diffHunk" : "@@ -1,1 +1019,1023 @@        }\n        PyArray_ITER_NEXT(it1);\n        PyArray_ITER_RESET(it2);\n    }\n    NPY_END_THREADS_DESCR(PyArray_DESCR(ap2));"
  },
  {
    "id" : "933f6537-3cce-4135-8a1e-3d95509462f9",
    "prId" : 4182,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f182740e-cb4e-478d-8caa-894f38f3e93b",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Does this check the x, y elements of `op_in` for NULL?\n",
        "createdAt" : "2014-01-13T00:21:45Z",
        "updatedAt" : "2014-01-14T23:20:55Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "7e158f29-0483-4568-811d-de81a08a2a41",
        "parentId" : "f182740e-cb4e-478d-8caa-894f38f3e93b",
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "they are converted ax and ay arrays earlier and checked for null in the `if` above\n",
        "createdAt" : "2014-01-13T00:37:29Z",
        "updatedAt" : "2014-01-14T23:20:55Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      },
      {
        "id" : "2654c146-0030-4414-b795-c6196a4d871a",
        "parentId" : "f182740e-cb4e-478d-8caa-894f38f3e93b",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Ah yes. Is `PyArray_ResultType` NULL safe? It might be better to do the ax, ax initialization from the functions first and use them later, that would make the logic a bit clearer. ISTR that the old SUN C compiler also had problems with structure initializers whose elements were not constant. I don't know if we want to worry about that anymore.\n",
        "createdAt" : "2014-01-13T01:11:08Z",
        "updatedAt" : "2014-01-14T23:20:55Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "ea027f37e67639d5c73a729f66b07588d8bced6a",
    "line" : null,
    "diffHunk" : "@@ -1,1 +2756,2760 @@            goto fail;\n        }\n        iter =  NpyIter_MultiNew(4, op_in, flags,\n                                 NPY_KEEPORDER, NPY_UNSAFE_CASTING,\n                                 op_flags, op_dt);"
  },
  {
    "id" : "598a9d06-29e4-4640-b4d5-b891178fd56c",
    "prId" : 4215,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f68ce748-5c5c-42fe-aecd-697a61336d21",
        "parentId" : null,
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Any chance of alignment problems here? Didn't check the rest, but an api check looks obviously right, so +1.\n",
        "createdAt" : "2014-01-19T17:57:24Z",
        "updatedAt" : "2014-01-23T00:27:21Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "356c0818-8fd7-469d-a2c4-338f24279224",
        "parentId" : "f68ce748-5c5c-42fe-aecd-697a61336d21",
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "the code uses memcpy which will handle alignment if required. copyswap in the object and swapped path also handles it.\n",
        "createdAt" : "2014-01-19T19:58:58Z",
        "updatedAt" : "2014-01-23T00:27:21Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      },
      {
        "id" : "3287693f-1e79-49c9-afb9-ea0fd96201c4",
        "parentId" : "f68ce748-5c5c-42fe-aecd-697a61336d21",
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "memory aliasing is also no concern as the output buffer is always freshly allocated, np.where has no out= argument (yet).\n",
        "createdAt" : "2014-01-22T17:28:19Z",
        "updatedAt" : "2014-01-23T00:27:21Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      }
    ],
    "commit" : "79cd73535675f189ee77d9cc82c39dfb7149c0e4",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +2783,2787 @@                PyArray_CopySwapFunc *copyswapx = dtx->f->copyswap;\n                PyArray_CopySwapFunc *copyswapy = dty->f->copyswap;\n                int native = (axswap == ayswap) && (axswap == 0) && !needs_api;\n                npy_intp n = (*innersizeptr);\n                npy_intp itemsize = NpyIter_GetDescrArray(iter)[0]->elsize;"
  },
  {
    "id" : "dba5f574-0974-4a40-b9cc-7fc5f616016f",
    "prId" : 4902,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "26426122-d3e7-46e6-9065-b98a65d94b0b",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Hmm, this looks like is could be a simple `if` with the following code, I don't see the need for a `goto`.\n",
        "createdAt" : "2014-07-27T17:28:58Z",
        "updatedAt" : "2014-07-27T19:13:04Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "91369d30a13dcc6484f27195d73e6ea9ba2edd2d",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +1619,1623 @@\n    /* super-fast path for ndarray argument calls */\n    if (PyTuple_GET_SIZE(args) == 0) {\n        goto full_path;\n    }"
  },
  {
    "id" : "0ef15b7c-8489-4ea8-873e-98b68ad976f5",
    "prId" : 4902,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8e90124a-95db-465d-a328-06745639c502",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "OK, I see this branches to `full_path` often.\n",
        "createdAt" : "2014-07-27T17:30:19Z",
        "updatedAt" : "2014-07-27T19:13:04Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "91369d30a13dcc6484f27195d73e6ea9ba2edd2d",
    "line" : 32,
    "diffHunk" : "@@ -1,1 +1637,1641 @@        }\n        if (dtype_obj != Py_None) {\n            goto full_path;\n        }\n"
  },
  {
    "id" : "c8ca7a33-7c18-49c2-a426-b76279e52d19",
    "prId" : 5314,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5a508826-7897-4fe5-a5a5-1e78db0ba82e",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Hmm, this looks right, but the replacement of `m-1` by `m` worries me a bit. Just want to make sure you have checked.\n",
        "createdAt" : "2014-11-26T16:43:13Z",
        "updatedAt" : "2014-11-26T18:07:40Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "9a24de1cac6923055b3010bbc8f63ae8595b534c",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +228,232 @@        }\n        for (i = 0; i < n; i++) {\n            ptr3[i] = (char **) &ptr3[n + m * i];\n            for (j = 0; j < m; j++) {\n                ptr3[i][j] = PyArray_BYTES(ap) + i*PyArray_STRIDES(ap)[0] + j*PyArray_STRIDES(ap)[1];"
  },
  {
    "id" : "55d9c80b-8b5e-4766-ba47-f05f4f2d06dd",
    "prId" : 5878,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "769647d0-17ac-42f6-af37-559dfa4398e3",
        "parentId" : null,
        "authorId" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "body" : "I feel like `PyArray_Matmul` should also do the override check, i.e. it should have identical semantics to the `matmul` function?\n",
        "createdAt" : "2015-05-15T05:53:05Z",
        "updatedAt" : "2015-06-05T00:02:11Z",
        "lastEditedBy" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "tags" : [
        ]
      },
      {
        "id" : "ae8fe69c-f9e3-4fce-82a1-0df183c390fd",
        "parentId" : "769647d0-17ac-42f6-af37-559dfa4398e3",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "That raises the question if it should be in the C-API at this point. I'm tempted to leave it out and just go with the `matmul` method.\n",
        "createdAt" : "2015-05-15T06:32:05Z",
        "updatedAt" : "2015-06-05T00:02:11Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "ff0aa52e-8157-4614-b04a-b1d72a3c50ea",
        "parentId" : "769647d0-17ac-42f6-af37-559dfa4398e3",
        "authorId" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "body" : "I was also feeling a little hesitant about adding it to the C api, so +1 on\nwaiting until we're more sure what we're doing here.\nOn May 14, 2015 11:32 PM, \"Charles Harris\" notifications@github.com wrote:\n\n> In numpy/core/src/multiarray/multiarraymodule.c\n> https://github.com/numpy/numpy/pull/5878#discussion_r30387829:\n> \n> > -    PyObject *v, *a, *o = NULL;\n> > -    char\\* kwlist[] = {\"a\", \"b\", \"out\", NULL };\n> >   +\n> > -    if (cached_npy_matmul == NULL) {\n> > -        PyObject *module, *dict, *matmul;\n> >   +\n> > -        module = PyImport_ImportModule(\"numpy.core.multiarray\");\n> > -        dict = PyModule_GetDict(module);\n> > -        matmul = PyDict_GetItemString(dict, \"matmul\");\n> > -        cached_npy_matmul = (PyUFuncObject*)matmul;\n> > -        Py_INCREF(cached_npy_matmul);\n> > -        Py_DECREF(module);\n> > -    }\n> >   +\n> > -    errval = PyUFunc_CheckOverride(cached_npy_matmul, \"**call**\",\n> > -                                   args, kwds, &override, 2);\n> \n> That raises the question if it should be in the C-API at this point. I'm\n> tempted to leave it out and just go with the matmul method.\n> \n> —\n> Reply to this email directly or view it on GitHub\n> https://github.com/numpy/numpy/pull/5878/files#r30387829.\n",
        "createdAt" : "2015-05-15T06:38:55Z",
        "updatedAt" : "2015-06-05T00:02:11Z",
        "lastEditedBy" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "tags" : [
        ]
      },
      {
        "id" : "603bf993-9ab4-4dc1-9443-d02eac571346",
        "parentId" : "769647d0-17ac-42f6-af37-559dfa4398e3",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Removed.\n",
        "createdAt" : "2015-05-15T07:04:37Z",
        "updatedAt" : "2015-06-05T00:02:11Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "24fcc25e14b272050ab5b7fe757b34d182a8fe85",
    "line" : null,
    "diffHunk" : "@@ -1,1 +2409,2413 @@\n    errval = PyUFunc_CheckOverride(matmul, \"__call__\",\n                                   args, kwds, &override, 2);\n    if (errval) {\n        return NULL;"
  },
  {
    "id" : "3e3b82ab-238c-41b1-92b4-fb29efeeb9af",
    "prId" : 7177,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5c499d6a-4e41-4a95-8129-475cdf5a53b4",
        "parentId" : null,
        "authorId" : "0d70c244-f732-4a44-9ae8-c3f6de7e9b40",
        "body" : "If only you could add an additional axis parameter here...\n",
        "createdAt" : "2016-07-07T18:38:30Z",
        "updatedAt" : "2016-08-05T02:20:47Z",
        "lastEditedBy" : "0d70c244-f732-4a44-9ae8-c3f6de7e9b40",
        "tags" : [
        ]
      },
      {
        "id" : "6721896d-9705-4212-b4a5-89dae6a527cb",
        "parentId" : "5c499d6a-4e41-4a95-8129-475cdf5a53b4",
        "authorId" : "11f18e00-52bd-4b68-b13d-17d0c3237df0",
        "body" : "Yeah...much, much harder said than done. :(\n",
        "createdAt" : "2016-07-07T18:40:48Z",
        "updatedAt" : "2016-08-05T02:20:47Z",
        "lastEditedBy" : "11f18e00-52bd-4b68-b13d-17d0c3237df0",
        "tags" : [
        ]
      },
      {
        "id" : "b1e3adac-42b0-4f06-b6a4-c10440e13799",
        "parentId" : "5c499d6a-4e41-4a95-8129-475cdf5a53b4",
        "authorId" : "0d70c244-f732-4a44-9ae8-c3f6de7e9b40",
        "body" : "Yeah. I'm beginning to see that. I will keep trying though. Even if I succeed eventually, your solution should probably accepted since it provides the correct functionality. A C drop-in replacement implementation should not change the API you propose.\n",
        "createdAt" : "2016-07-07T18:46:52Z",
        "updatedAt" : "2016-08-05T02:20:47Z",
        "lastEditedBy" : "0d70c244-f732-4a44-9ae8-c3f6de7e9b40",
        "tags" : [
        ]
      }
    ],
    "commit" : "0fc9e4520b1d00b58a77f28936da2fec2672de83",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +1984,1988 @@    npy_intp count;\n\n    if (!PyArg_ParseTuple(args, \"O&\", PyArray_Converter, &array)) {\n        return NULL;\n    }"
  },
  {
    "id" : "b028309d-842c-4f21-9279-3c18cdf87ee0",
    "prId" : 8114,
    "prUrl" : "https://github.com/numpy/numpy/pull/8114#pullrequestreview-2597105",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2c3a15e2-c2dd-4ca5-b8bc-6dc5029740c0",
        "parentId" : null,
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "LGTM, two small comments (which I don't care much about)\n1.  Could use `PyNumber_Index` here, which is a bit more general then the long check, but also forbids floats, etc.\n2. Could make it `if ((max_work == -)1 && (PyErr_Occured())) {` AFAIK.\n",
        "createdAt" : "2016-10-03T20:01:55Z",
        "updatedAt" : "2016-10-03T20:02:25Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "ffca0c88-2e66-4921-90a5-3f4a0019037e",
        "parentId" : "2c3a15e2-c2dd-4ca5-b8bc-6dc5029740c0",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "(Or PyArray_PyIntAsIntp` which is however much the same.\n",
        "createdAt" : "2016-10-03T20:02:39Z",
        "updatedAt" : "2016-10-03T20:02:40Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "5dcf7630-c51a-4657-86bf-534ae20c0468",
        "parentId" : "2c3a15e2-c2dd-4ca5-b8bc-6dc5029740c0",
        "authorId" : "48d7d71b-9655-46b2-9a18-7c1fba7837d0",
        "body" : "The Python 3 manual doesn't mention the -1 return value, so I didn't add that...\n",
        "createdAt" : "2016-10-03T20:03:58Z",
        "updatedAt" : "2016-10-03T20:03:58Z",
        "lastEditedBy" : "48d7d71b-9655-46b2-9a18-7c1fba7837d0",
        "tags" : [
        ]
      },
      {
        "id" : "e12d09bc-a2ed-4f28-9aa5-152b664ceaab",
        "parentId" : "2c3a15e2-c2dd-4ca5-b8bc-6dc5029740c0",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "oh, really, did that change in python 3, seems odd?\n",
        "createdAt" : "2016-10-03T20:18:09Z",
        "updatedAt" : "2016-10-03T20:18:09Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      }
    ],
    "commit" : "fd6ff264a1c040dff63cfc913b6505d1b5a5457d",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +3982,3986 @@    else if (PyLong_Check(max_work_obj)) {\n        max_work = PyLong_AsSsize_t(max_work_obj);\n        if (PyErr_Occurred()) {\n            goto fail;\n        }"
  },
  {
    "id" : "52835d9d-a4d7-40fa-b72d-0f58bbc7d68b",
    "prId" : 8584,
    "prUrl" : "https://github.com/numpy/numpy/pull/8584#pullrequestreview-20884559",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "cdffff2e-f958-4485-b1f8-d9566ff4f9c5",
        "parentId" : null,
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "I presume this is for follow up in python code? If so, I think it should be part of a follow-up PR, not be done here (if only to give a chance to discuss whether it is best to go through `C` for something like this).",
        "createdAt" : "2017-02-08T19:06:40Z",
        "updatedAt" : "2017-02-20T22:03:54Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      },
      {
        "id" : "77e3749f-aa94-4777-8e43-159ccb7dc004",
        "parentId" : "cdffff2e-f958-4485-b1f8-d9566ff4f9c5",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "I've added the python stuff to this PR now...\r\n",
        "createdAt" : "2017-02-08T22:18:09Z",
        "updatedAt" : "2017-02-20T22:03:54Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "8d6ec65c925ebef5e0567708de1d16df39077c9d",
    "line" : 27,
    "diffHunk" : "@@ -1,1 +4103,4107 @@}\n\nstatic PyObject *\nnormalize_axis_index(PyObject *NPY_UNUSED(self), PyObject *args, PyObject *kwds)\n{"
  },
  {
    "id" : "db480dcc-6218-4ff8-b57d-211a6f843dc1",
    "prId" : 8843,
    "prUrl" : "https://github.com/numpy/numpy/pull/8843#pullrequestreview-29571387",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8f1df262-eacd-4467-b3f6-008ea031e61e",
        "parentId" : null,
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "Here, again, I think you cannot just use `Py_None`. Also solve by initlializing to `NULL`?",
        "createdAt" : "2017-03-28T20:38:55Z",
        "updatedAt" : "2017-03-28T21:23:31Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      },
      {
        "id" : "f4d1b747-3983-483b-a093-687dbc1e011c",
        "parentId" : "8f1df262-eacd-4467-b3f6-008ea031e61e",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "This is definitely correct. `PyArg_ParseTuple` does not `INCREF` `O` arguments, so this line is exactly equivalent to passing `None` from python.\r\n\r\nThe question remains if I should `INCREF` before calling `check_and_adjust_axis_msg`, but let's discuss that above.",
        "createdAt" : "2017-03-28T20:52:07Z",
        "updatedAt" : "2017-03-28T21:23:31Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "17466ad1839718c091c629bb647e881b7922a148",
    "line" : 8,
    "diffHunk" : "@@ -1,1 +4110,4114 @@    int axis;\n    int ndim;\n    PyObject *msg_prefix = Py_None;\n\n    if (!PyArg_ParseTupleAndKeywords(args, kwds, \"ii|O:normalize_axis_index\","
  },
  {
    "id" : "0595bdd7-1c08-454b-a340-b4b00cf4bf73",
    "prId" : 8861,
    "prUrl" : "https://github.com/numpy/numpy/pull/8861#pullrequestreview-29451523",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b1534b04-cc63-4898-b76c-bbd23b0988c6",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "It's a little annoying how sometimes the C and python function names are inconsistent, like here (`can_cast` vs `can_cast_safely`)",
        "createdAt" : "2017-03-28T13:39:40Z",
        "updatedAt" : "2017-03-28T14:11:59Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "dcafaf4983214a0c1ceefc154f1dcdb3d04db748",
    "line" : 221,
    "diffHunk" : "@@ -1,1 +3264,3268 @@    static char *kwlist[] = {\"from\", \"to\", \"casting\", NULL};\n\n    if(!PyArg_ParseTupleAndKeywords(args, kwds, \"OO&|O&:can_cast\", kwlist,\n                &from_obj,\n                PyArray_DescrConverter2, &d2,"
  },
  {
    "id" : "274b71ad-c7c3-4ed4-a3f7-c49c327cc12a",
    "prId" : 9209,
    "prUrl" : "https://github.com/numpy/numpy/pull/9209#pullrequestreview-41834319",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "48aa729c-5d14-4b56-9d41-1386185b59e4",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "And this if statement",
        "createdAt" : "2017-06-02T17:20:12Z",
        "updatedAt" : "2017-09-18T01:07:40Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "83ed2caff9a61bf8406e3ebb871ff8a62bf02d40",
    "line" : 183,
    "diffHunk" : "@@ -1,1 +531,535 @@        }\n        Py_INCREF(ret);\n    }\n    else {\n        npy_intp stride;"
  },
  {
    "id" : "695259b2-2359-46ed-97a7-20cdc63f704b",
    "prId" : 9209,
    "prUrl" : "https://github.com/numpy/numpy/pull/9209#pullrequestreview-41834319",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ef02094a-3261-47fc-81a3-2152b46c9920",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "And here we just redirect the old API to not break compatibility",
        "createdAt" : "2017-06-02T17:21:02Z",
        "updatedAt" : "2017-09-18T01:07:40Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "83ed2caff9a61bf8406e3ebb871ff8a62bf02d40",
    "line" : 284,
    "diffHunk" : "@@ -1,1 +665,669 @@{\n    return PyArray_ConcatenateInto(op, axis, NULL);\n}\n\nstatic int"
  },
  {
    "id" : "1a256b81-3a51-40db-82e4-7a6cb3a036dd",
    "prId" : 9209,
    "prUrl" : "https://github.com/numpy/numpy/pull/9209#pullrequestreview-62103701",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "067ee8a6-be4b-4984-bee1-8e618eec71ac",
        "parentId" : null,
        "authorId" : "a4f03a99-2e43-482b-a9bc-5a9e359abb03",
        "body" : "incidentally, this is the only place in numpy this function is used.\r\n\r\nFor a second I thought there might be some problem that we ignore strides when out is provided, like in #7633, but it's fine, `PyArray_AssignArray` below is insensitive to order.",
        "createdAt" : "2017-09-11T19:38:54Z",
        "updatedAt" : "2017-09-18T01:07:40Z",
        "lastEditedBy" : "a4f03a99-2e43-482b-a9bc-5a9e359abb03",
        "tags" : [
        ]
      },
      {
        "id" : "01a4077b-0d9b-41a3-9b75-9110698c3332",
        "parentId" : "067ee8a6-be4b-4984-bee1-8e618eec71ac",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Yeah, I assume this is an optimization",
        "createdAt" : "2017-09-11T20:13:46Z",
        "updatedAt" : "2017-09-18T01:07:40Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "37dc14d0-187b-416b-8790-d2966adac601",
        "parentId" : "067ee8a6-be4b-4984-bee1-8e618eec71ac",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "I remember this function being new in 1.7 or so, somewhat thought it was used with the new iterator, but maybe there was some change there (since I also remember there was a some bug with this or its usage). The idea is simple though, find the cache friendliest iteration order....",
        "createdAt" : "2017-09-12T11:54:23Z",
        "updatedAt" : "2017-09-18T01:07:40Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      }
    ],
    "commit" : "83ed2caff9a61bf8406e3ebb871ff8a62bf02d40",
    "line" : 119,
    "diffHunk" : "@@ -1,1 +434,438 @@         * resolution rules matching that of the NpyIter.\n         */\n        PyArray_CreateMultiSortedStridePerm(narrays, arrays, ndim, strideperm);\n        s = dtype->elsize;\n        for (idim = ndim-1; idim >= 0; --idim) {"
  },
  {
    "id" : "aca16824-2ec1-4448-a495-e18bc6677eec",
    "prId" : 11916,
    "prUrl" : "https://github.com/numpy/numpy/pull/11916#pullrequestreview-157922364",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "58b76cad-5b05-4438-b801-1679e6dbe0de",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Doesn't this mean that you're actually _not_ deprecating the python-side APIs, only the C ones?",
        "createdAt" : "2018-09-22T19:07:08Z",
        "updatedAt" : "2018-11-10T00:44:47Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "df40c6dd-7ed7-4b7b-85f4-cf4125af7692",
        "parentId" : "58b76cad-5b05-4438-b801-1679e6dbe0de",
        "authorId" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "body" : "Since this function is mapped to python-level `set_numeric_ops`, I only want the `DeprecationWarning` from `PyArray_SetNumericOps`, three lines down. There is no python-level `get_numeric_ops`.",
        "createdAt" : "2018-09-22T21:04:09Z",
        "updatedAt" : "2018-11-10T00:44:47Z",
        "lastEditedBy" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "tags" : [
        ]
      }
    ],
    "commit" : "08a2e4503de155f2e202bc154287b34220ad1025",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +2991,2995 @@    PyObject *oldops = NULL;\n\n    if ((oldops = _PyArray_GetNumericOps()) == NULL) {\n        return NULL;\n    }"
  },
  {
    "id" : "817c3395-2772-4169-abd7-e41ad5e2399e",
    "prId" : 12354,
    "prUrl" : "https://github.com/numpy/numpy/pull/12354#pullrequestreview-173654356",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1516ac2c-df90-4d8e-a6d3-16a970ab5692",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Might be neat to call `_PyErr_ChainExceptions` here, although you'll need to add a backport of that in `numpy\\core\\include\\numpy\\npy_3kcompat.h` (almost identical to `npy_PyErr_ChainExceptionsCause`)",
        "createdAt" : "2018-11-09T05:05:34Z",
        "updatedAt" : "2018-11-10T11:32:00Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "d8195bca-434a-4b22-b9a9-672a64ff96fd",
        "parentId" : "1516ac2c-df90-4d8e-a6d3-16a970ab5692",
        "authorId" : "589adf51-c83d-4d25-b0fa-10ed4e1f120a",
        "body" : "This is part of the C-API that I'm not really familiar with - `npy_PyErr_ChainExceptionsCause` looks like it's almost identical to `_PyErr_ChainExceptions`.\r\n\r\nWhat are the differences between them and why would I want to use one over the other?",
        "createdAt" : "2018-11-09T08:35:03Z",
        "updatedAt" : "2018-11-10T11:32:00Z",
        "lastEditedBy" : "589adf51-c83d-4d25-b0fa-10ed4e1f120a",
        "tags" : [
        ]
      },
      {
        "id" : "e9fcea2e-efbc-4414-a15e-80960b12fc20",
        "parentId" : "1516ac2c-df90-4d8e-a6d3-16a970ab5692",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "`_PyErr_ChainExceptions` isn't available in python 2.7, which is why you can't use it directly.\r\n\r\n`_PyErr_ChainExceptions` gives the behavior of\r\n```python\r\n>>> try:\r\n\traise ValueError\r\nexcept:\r\n\traise KeyError\r\n\r\nTraceback (most recent call last):\r\n  File \"<pyshell#5>\", line 2, in <module>\r\n    raise ValueError\r\nValueError\r\n\r\nDuring handling of the above exception, another exception occurred:\r\n\r\nTraceback (most recent call last):\r\n  File \"<pyshell#5>\", line 4, in <module>\r\n    raise KeyError\r\nKeyError\r\n```\r\n\r\nWhile `npy_PyErr_ChainExceptionsCause` gives the behavior of:\r\n```python\r\n>>> try:\r\n\traise ValueError\r\nexcept Exception as e:\r\n\traise KeyError from e\r\n\r\nTraceback (most recent call last):\r\n  File \"<pyshell#7>\", line 2, in <module>\r\n    raise ValueError\r\nValueError\r\n\r\nThe above exception was the direct cause of the following exception:\r\n\r\nTraceback (most recent call last):\r\n  File \"<pyshell#7>\", line 4, in <module>\r\n    raise KeyError from e\r\nKeyError\r\n```",
        "createdAt" : "2018-11-09T17:14:52Z",
        "updatedAt" : "2018-11-10T11:32:00Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "7fcbcb55-acbf-49e1-a2c4-7e36d4240b85",
        "parentId" : "1516ac2c-df90-4d8e-a6d3-16a970ab5692",
        "authorId" : "589adf51-c83d-4d25-b0fa-10ed4e1f120a",
        "body" : "Thanks for the explanation, I've added the implementation of that and have used it.",
        "createdAt" : "2018-11-10T07:57:18Z",
        "updatedAt" : "2018-11-10T11:32:00Z",
        "lastEditedBy" : "589adf51-c83d-4d25-b0fa-10ed4e1f120a",
        "tags" : [
        ]
      }
    ],
    "commit" : "fbdcb5b7b38a7063357f881397ccdc546f46ec5b",
    "line" : 23,
    "diffHunk" : "@@ -1,1 +2092,2096 @@    if (own && npy_PyFile_CloseFile(file) < 0) {\n        npy_PyErr_ChainExceptions(err_type, err_value, err_traceback);\n        goto fail;\n    }\n    PyErr_Restore(err_type, err_value, err_traceback);"
  },
  {
    "id" : "7a835984-b78d-443e-8c7d-d1312c10a4f6",
    "prId" : 12624,
    "prUrl" : "https://github.com/numpy/numpy/pull/12624#pullrequestreview-188297471",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7b69c72a-0c7b-4d4a-a333-94584374bfac",
        "parentId" : null,
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "This is probably one of the few ones that could hurt in practice, if someone prints a lot of datetime objects for some reason.",
        "createdAt" : "2018-12-28T14:09:36Z",
        "updatedAt" : "2019-01-02T19:17:23Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      }
    ],
    "commit" : "4732c1be2da093711ab544f6e0a302b9d7ee4bcb",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +3256,3260 @@\n    meta = get_datetime_metadata_from_dtype(dtype);\n    Py_DECREF(dtype);    \n    if (meta == NULL) {\n        return NULL;"
  },
  {
    "id" : "9f733c42-7896-49f1-8dea-0d41ae5bf6a1",
    "prId" : 12624,
    "prUrl" : "https://github.com/numpy/numpy/pull/12624#pullrequestreview-188787101",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6a0abc1b-c9ff-41fc-8c22-9c65f3810837",
        "parentId" : null,
        "authorId" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "body" : "I cannot leave a comment there, but it would be easier to decref `type` just below in the `result == NULL` path rather than in all the error modes of `_vec_string_no_args` / `_vec_string_with_args`",
        "createdAt" : "2019-01-02T18:02:33Z",
        "updatedAt" : "2019-01-02T19:17:23Z",
        "lastEditedBy" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "tags" : [
        ]
      },
      {
        "id" : "936eafa9-b82a-4cfb-93f1-4e12da4d8436",
        "parentId" : "6a0abc1b-c9ff-41fc-8c22-9c65f3810837",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Hmmm, but wouldn't that break convention in the sense that funcs that steal references always steal it? Unless I change those functions to not stealing the reference, which could be prettier indeed.",
        "createdAt" : "2019-01-02T18:30:03Z",
        "updatedAt" : "2019-01-02T19:17:23Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "db82f7de-e005-4299-a168-f7d0021e263a",
        "parentId" : "6a0abc1b-c9ff-41fc-8c22-9c65f3810837",
        "authorId" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "body" : "Indeed, \"funcs that steal references\" means they decref upon failure. Sorry for the noise.",
        "createdAt" : "2019-01-02T18:58:58Z",
        "updatedAt" : "2019-01-02T19:17:23Z",
        "lastEditedBy" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "tags" : [
        ]
      }
    ],
    "commit" : "4732c1be2da093711ab544f6e0a302b9d7ee4bcb",
    "line" : 56,
    "diffHunk" : "@@ -1,1 +3816,3820 @@        PyErr_SetString(PyExc_TypeError,\n                \"'args' must be a sequence of arguments\");\n        goto err;\n    }\n    if (result == NULL) {"
  }
]
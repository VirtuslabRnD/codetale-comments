[
  {
    "id" : "f6675ee7-6c6e-4f4d-81bb-d34b65be5e48",
    "prId" : 373,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "343aa303-ca6f-446d-add9-5a40ecdcba37",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "The PyDataMem_\\* functions might be preferable here, might also be a bit of overkill...\n",
        "createdAt" : "2012-08-03T16:38:45Z",
        "updatedAt" : "2012-08-03T16:38:45Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "7867181f-6be8-40d8-ba9a-c9351ac41de8",
        "parentId" : "343aa303-ca6f-446d-add9-5a40ecdcba37",
        "authorId" : "63f665c6-ca13-46c8-b51a-6bb09ba7078e",
        "body" : "I'm certainly no expert, but I know a memory leak when I see one, and I attempted to plug it in the simplest/quickest/least-invasive way I could find. I really have no preference as to how it gets fixed, as long as it gets fixed (preferably soon). [grin]\n\nDo you have (or could you quickly throw together) an alternative patch that uses the method you propose?\n",
        "createdAt" : "2012-08-03T16:59:24Z",
        "updatedAt" : "2012-08-03T16:59:24Z",
        "lastEditedBy" : "63f665c6-ca13-46c8-b51a-6bb09ba7078e",
        "tags" : [
        ]
      },
      {
        "id" : "af42e0f0-daea-4496-83e9-baf78c8e85df",
        "parentId" : "343aa303-ca6f-446d-add9-5a40ecdcba37",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "I think the patch looks fine, but there was a recent commit that allows tracking memory usage with the PyDataMem_NEW/PyDataMem_FREE. functions, so I'd like some input from the patch author as to what all memory we should be tracking and what we shouldn't worry about. You can see the routines themselves as they are in the same code unit.\n",
        "createdAt" : "2012-08-03T17:03:01Z",
        "updatedAt" : "2012-08-03T17:03:01Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "af8f2587-bfe6-45b8-8212-8db2e0c8a02b",
        "parentId" : "343aa303-ca6f-446d-add9-5a40ecdcba37",
        "authorId" : "1b526ef0-1c83-44be-b2b5-41cf1ee854e2",
        "body" : "The PyDataMem_\\* functions are for allocating array data.   This is allocating a c-array of pointers to ArrayObjects.  I don't think it would be helpful to track this in the same way.    \n\nPyArray_malloc/free seem like the right approach.  \n",
        "createdAt" : "2012-08-03T23:53:50Z",
        "updatedAt" : "2012-08-03T23:53:50Z",
        "lastEditedBy" : "1b526ef0-1c83-44be-b2b5-41cf1ee854e2",
        "tags" : [
        ]
      },
      {
        "id" : "396d8a53-2f58-431e-8fbc-99e28f61ad95",
        "parentId" : "343aa303-ca6f-446d-add9-5a40ecdcba37",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Well, that optionally uses the Python allocation. My own preference would probably be malloc/free if we don't want to track memory usage in these things.\n",
        "createdAt" : "2012-08-04T00:04:21Z",
        "updatedAt" : "2012-08-04T00:04:21Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "8a4e0f57844452ceca43388cb87f5a53c3471c80",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +603,607 @@        Py_DECREF(arrays[iarrays]);\n    }\n    PyArray_free(arrays);\n\n    return (PyObject *)ret;"
  },
  {
    "id" : "254724c6-b854-46f3-b06a-37c35e1efb3e",
    "prId" : 440,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "87011b82-ca09-4b1b-81a0-ecf62f046008",
        "parentId" : null,
        "authorId" : "e8ef9b42-d95e-465b-908c-dfe5f69d2334",
        "body" : "Maybe this should be generalized by doing `if (axis > ndim-1)` --> warning message, because this issue probably exists at higher dimensions as well.\n",
        "createdAt" : "2012-09-16T07:15:42Z",
        "updatedAt" : "2012-09-16T11:52:12Z",
        "lastEditedBy" : "e8ef9b42-d95e-465b-908c-dfe5f69d2334",
        "tags" : [
        ]
      },
      {
        "id" : "d1091625-d511-460f-8e0b-30cd7361a2d7",
        "parentId" : "87011b82-ca09-4b1b-81a0-ecf62f046008",
        "authorId" : "7ff2710f-0a12-46fb-a54a-d405dab78cf7",
        "body" : "I think the behavior has only changed for 1D arrays. For example, in numpy 1.6.1:\n\n<pre>\nIn [17]: a = np.zeros((1,3))\n\nIn [18]: b = np.zeros((2,3))\n\nIn [19]: np.concatenate((a, b))\nOut[19]: \narray([[ 0.,  0.,  0.],\n       [ 0.,  0.,  0.],\n       [ 0.,  0.,  0.]])\n\nIn [20]: np.concatenate((a, b), axis=10)\n---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\n<ipython-input-20-1db841fd19b0> in <module>()\n----> 1 np.concatenate((a, b), axis=10)\n\nValueError: bad axis1 argument to swapaxes\n</pre>\n",
        "createdAt" : "2012-09-16T11:43:55Z",
        "updatedAt" : "2012-09-16T11:52:13Z",
        "lastEditedBy" : "7ff2710f-0a12-46fb-a54a-d405dab78cf7",
        "tags" : [
        ]
      },
      {
        "id" : "cd8c1b88-3a23-4402-a4ad-4e7a09ec1c15",
        "parentId" : "87011b82-ca09-4b1b-81a0-ecf62f046008",
        "authorId" : "e8ef9b42-d95e-465b-908c-dfe5f69d2334",
        "body" : "Ah, I see, the current implementation has an explicit bounds-check in concatenate, but in earlier versions it already failed for multidimensional arrays in another part of the code. \n",
        "createdAt" : "2012-09-16T13:05:06Z",
        "updatedAt" : "2012-09-16T13:05:06Z",
        "lastEditedBy" : "e8ef9b42-d95e-465b-908c-dfe5f69d2334",
        "tags" : [
        ]
      }
    ],
    "commit" : "69afd27b870cd85f06c4409fcffd0734ddb2fe76",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +347,351 @@        axis = 0;\n    }\n\n    if (axis < 0 || axis >= ndim) {\n        PyErr_Format(PyExc_IndexError,"
  },
  {
    "id" : "1162f1e4-9a65-4ad2-a274-2d358b0a89e7",
    "prId" : 2777,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fe4aa007-1f2a-44b7-a01a-27275981dcb0",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Hmm, is it OK that PyArray_ITER_RESET is called before the exit? That's the only reason I can see that the loop was constructed that way.\n",
        "createdAt" : "2012-12-01T22:10:01Z",
        "updatedAt" : "2012-12-01T22:10:01Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "c6927377-c558-4f26-9b61-b73fe3decc97",
        "parentId" : "fe4aa007-1f2a-44b7-a01a-27275981dcb0",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Or it was a micro optimization.\n",
        "createdAt" : "2012-12-01T22:20:31Z",
        "updatedAt" : "2012-12-01T22:20:31Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "1961eb5c-4f2c-4839-acb0-fa02918805cb",
        "parentId" : "fe4aa007-1f2a-44b7-a01a-27275981dcb0",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Thought it was just optimization, but I didn't think about the cost of ITER_RESET. Could do an explicit check before the loop instead to keep the optimization.\n",
        "createdAt" : "2012-12-01T22:29:12Z",
        "updatedAt" : "2012-12-01T22:29:12Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "d894ef2f-cf6d-4d65-bad4-a88d902f09c6",
        "parentId" : "fe4aa007-1f2a-44b7-a01a-27275981dcb0",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "If it's not a problem I'd be inclined to keep your version. It adds a small bit of overhead but is clearer code.\n",
        "createdAt" : "2012-12-01T22:34:39Z",
        "updatedAt" : "2012-12-01T22:34:39Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "300783c0ed1518ad1335f3aad9a4bda35f5e1123",
    "line" : 27,
    "diffHunk" : "@@ -1,1 +889,893 @@        }\n        PyArray_ITER_NEXT(it1);\n        PyArray_ITER_RESET(it2);\n    }\n    NPY_END_THREADS_DESCR(PyArray_DESCR(ap2));"
  },
  {
    "id" : "78038c11-79cc-4c05-8409-21e4579db3dc",
    "prId" : 2777,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9bbfab83-dac9-4a61-a5a4-1b85e033bb84",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Is it the case that the size of  `ret` was set above, so this doesn't do anything new about shape/strides, just fills with zeros?\n",
        "createdAt" : "2012-12-01T22:12:30Z",
        "updatedAt" : "2012-12-01T22:12:30Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "bdbaef89-7665-4bfa-a792-ae79b5f78f97",
        "parentId" : "9bbfab83-dac9-4a61-a5a4-1b85e033bb84",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Yes, ret is defined just before this. This code is exactly the same as the one for dot, but was missing in inner.\n",
        "createdAt" : "2012-12-01T22:29:48Z",
        "updatedAt" : "2012-12-01T22:29:48Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "bcb77ef6-5269-4910-ad18-755004d7a04e",
        "parentId" : "9bbfab83-dac9-4a61-a5a4-1b85e033bb84",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Just out of curiosity, what happens if N or M is zero?\n",
        "createdAt" : "2012-12-01T22:38:57Z",
        "updatedAt" : "2012-12-01T22:38:57Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "a23ad5f9-4065-430a-871c-58ddeba787ad",
        "parentId" : "9bbfab83-dac9-4a61-a5a4-1b85e033bb84",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "The output array has 0-size. So nothing needed there. But that was the problem that is fixed by changing that while loop, because it actually did one inner loop in that case before.\n",
        "createdAt" : "2012-12-01T22:44:08Z",
        "updatedAt" : "2012-12-01T22:44:08Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "33f9fff3-7765-4f03-9ce1-b8e2e65dc726",
        "parentId" : "9bbfab83-dac9-4a61-a5a4-1b85e033bb84",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "ah... `PyArray_NBYTES(ret) == 0` that is. Which means memset doesn't do anything...\n",
        "createdAt" : "2012-12-01T22:46:12Z",
        "updatedAt" : "2012-12-01T22:46:12Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "211b5ab4-a57f-450d-b070-511dca71ce67",
        "parentId" : "9bbfab83-dac9-4a61-a5a4-1b85e033bb84",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Ah, got it. A note in the commit message could have clarified that, or maybe if I was smarter ...\n\nI'll just go ahead with the commit.\n",
        "createdAt" : "2012-12-01T22:49:15Z",
        "updatedAt" : "2012-12-01T22:49:15Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "300783c0ed1518ad1335f3aad9a4bda35f5e1123",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +865,869 @@    /* Ensure that multiarray.inner(<Nx0>,<Mx0>) -> zeros((N,M)) */\n    if (PyArray_SIZE(ap1) == 0 && PyArray_SIZE(ap2) == 0) {\n        memset(PyArray_DATA(ret), 0, PyArray_NBYTES(ret));\n    }\n"
  },
  {
    "id" : "4114c4f7-699c-449c-b793-69a314cc9554",
    "prId" : 2777,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5c015e79-7a6e-4f14-8e6b-a1ca6d994a42",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Same comment as previous loop.\n",
        "createdAt" : "2012-12-01T22:13:00Z",
        "updatedAt" : "2012-12-01T22:13:00Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "300783c0ed1518ad1335f3aad9a4bda35f5e1123",
    "line" : 56,
    "diffHunk" : "@@ -1,1 +1019,1023 @@        }\n        PyArray_ITER_NEXT(it1);\n        PyArray_ITER_RESET(it2);\n    }\n    NPY_END_THREADS_DESCR(PyArray_DESCR(ap2));"
  },
  {
    "id" : "933f6537-3cce-4135-8a1e-3d95509462f9",
    "prId" : 4182,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f182740e-cb4e-478d-8caa-894f38f3e93b",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Does this check the x, y elements of `op_in` for NULL?\n",
        "createdAt" : "2014-01-13T00:21:45Z",
        "updatedAt" : "2014-01-14T23:20:55Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "7e158f29-0483-4568-811d-de81a08a2a41",
        "parentId" : "f182740e-cb4e-478d-8caa-894f38f3e93b",
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "they are converted ax and ay arrays earlier and checked for null in the `if` above\n",
        "createdAt" : "2014-01-13T00:37:29Z",
        "updatedAt" : "2014-01-14T23:20:55Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      },
      {
        "id" : "2654c146-0030-4414-b795-c6196a4d871a",
        "parentId" : "f182740e-cb4e-478d-8caa-894f38f3e93b",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Ah yes. Is `PyArray_ResultType` NULL safe? It might be better to do the ax, ax initialization from the functions first and use them later, that would make the logic a bit clearer. ISTR that the old SUN C compiler also had problems with structure initializers whose elements were not constant. I don't know if we want to worry about that anymore.\n",
        "createdAt" : "2014-01-13T01:11:08Z",
        "updatedAt" : "2014-01-14T23:20:55Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "ea027f37e67639d5c73a729f66b07588d8bced6a",
    "line" : null,
    "diffHunk" : "@@ -1,1 +2756,2760 @@            goto fail;\n        }\n        iter =  NpyIter_MultiNew(4, op_in, flags,\n                                 NPY_KEEPORDER, NPY_UNSAFE_CASTING,\n                                 op_flags, op_dt);"
  },
  {
    "id" : "598a9d06-29e4-4640-b4d5-b891178fd56c",
    "prId" : 4215,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f68ce748-5c5c-42fe-aecd-697a61336d21",
        "parentId" : null,
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Any chance of alignment problems here? Didn't check the rest, but an api check looks obviously right, so +1.\n",
        "createdAt" : "2014-01-19T17:57:24Z",
        "updatedAt" : "2014-01-23T00:27:21Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "356c0818-8fd7-469d-a2c4-338f24279224",
        "parentId" : "f68ce748-5c5c-42fe-aecd-697a61336d21",
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "the code uses memcpy which will handle alignment if required. copyswap in the object and swapped path also handles it.\n",
        "createdAt" : "2014-01-19T19:58:58Z",
        "updatedAt" : "2014-01-23T00:27:21Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      },
      {
        "id" : "3287693f-1e79-49c9-afb9-ea0fd96201c4",
        "parentId" : "f68ce748-5c5c-42fe-aecd-697a61336d21",
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "memory aliasing is also no concern as the output buffer is always freshly allocated, np.where has no out= argument (yet).\n",
        "createdAt" : "2014-01-22T17:28:19Z",
        "updatedAt" : "2014-01-23T00:27:21Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      }
    ],
    "commit" : "79cd73535675f189ee77d9cc82c39dfb7149c0e4",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +2783,2787 @@                PyArray_CopySwapFunc *copyswapx = dtx->f->copyswap;\n                PyArray_CopySwapFunc *copyswapy = dty->f->copyswap;\n                int native = (axswap == ayswap) && (axswap == 0) && !needs_api;\n                npy_intp n = (*innersizeptr);\n                npy_intp itemsize = NpyIter_GetDescrArray(iter)[0]->elsize;"
  },
  {
    "id" : "dba5f574-0974-4a40-b9cc-7fc5f616016f",
    "prId" : 4902,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "26426122-d3e7-46e6-9065-b98a65d94b0b",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Hmm, this looks like is could be a simple `if` with the following code, I don't see the need for a `goto`.\n",
        "createdAt" : "2014-07-27T17:28:58Z",
        "updatedAt" : "2014-07-27T19:13:04Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "91369d30a13dcc6484f27195d73e6ea9ba2edd2d",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +1619,1623 @@\n    /* super-fast path for ndarray argument calls */\n    if (PyTuple_GET_SIZE(args) == 0) {\n        goto full_path;\n    }"
  },
  {
    "id" : "0ef15b7c-8489-4ea8-873e-98b68ad976f5",
    "prId" : 4902,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8e90124a-95db-465d-a328-06745639c502",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "OK, I see this branches to `full_path` often.\n",
        "createdAt" : "2014-07-27T17:30:19Z",
        "updatedAt" : "2014-07-27T19:13:04Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "91369d30a13dcc6484f27195d73e6ea9ba2edd2d",
    "line" : 32,
    "diffHunk" : "@@ -1,1 +1637,1641 @@        }\n        if (dtype_obj != Py_None) {\n            goto full_path;\n        }\n"
  }
]
[
  {
    "id" : "dfa40527-8033-4ce1-8e37-9a0250ad82bc",
    "prId" : 93,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8628af30-f129-439e-9164-b3a2aef47dd8",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Sure you don't want to check if an error was actually set?\n",
        "createdAt" : "2011-06-21T03:48:11Z",
        "updatedAt" : "2011-06-21T15:22:22Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "f98f3aba-2b84-460e-828f-10daa61333f4",
        "parentId" : "8628af30-f129-439e-9164-b3a2aef47dd8",
        "authorId" : "95359633-f0b0-4899-8e46-e2146fd11511",
        "body" : "sure\n",
        "createdAt" : "2011-06-21T14:40:17Z",
        "updatedAt" : "2011-06-21T15:22:23Z",
        "lastEditedBy" : "95359633-f0b0-4899-8e46-e2146fd11511",
        "tags" : [
        ]
      }
    ],
    "commit" : "7c1c7a86057e72490268f084a4e77d857997312b",
    "line" : null,
    "diffHunk" : "@@ -1,1 +148,152 @@                    \"but no error set\");\n        }\n        return;\n    }\n"
  },
  {
    "id" : "8f488fcf-5a56-4d1e-a6be-f3826804ad0c",
    "prId" : 451,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b117b32e-def4-495a-9750-df818d2f8f32",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "I'm a bit concerned because the GIL now needs to be held in case of the deprecation message. We should really be returning an int instead of npy_bool, but it is probably too late to change that.\n",
        "createdAt" : "2012-09-20T23:27:30Z",
        "updatedAt" : "2012-09-20T23:27:30Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "16c27fdc-3e23-4086-8c98-bf06cb1fef34",
        "parentId" : "b117b32e-def4-495a-9750-df818d2f8f32",
        "authorId" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "body" : "PyArray_CanCastTypeTo already requires the GIL -- it allocates and DECREFs dtype objects.\n",
        "createdAt" : "2012-09-21T13:32:12Z",
        "updatedAt" : "2012-09-21T13:32:12Z",
        "lastEditedBy" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "tags" : [
        ]
      }
    ],
    "commit" : "c038fe59a8c355fee50a6c2ac236e750e0ad0ad5",
    "line" : 20,
    "diffHunk" : "@@ -1,1 +520,524 @@NPY_NO_EXPORT npy_bool\nPyArray_CanCastTypeTo(PyArray_Descr *from, PyArray_Descr *to,\n                      NPY_CASTING casting)\n{\n    if (casting == NPY_INTERNAL_UNSAFE_CASTING_BUT_WARN_UNLESS_SAME_KIND) {"
  },
  {
    "id" : "5c8dfdd8-c18a-41d3-b7a9-48719ae26f79",
    "prId" : 3270,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a6953067-adb7-474f-8dc8-f4c82ab691ba",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "To bad there isn't a cleaner way to do this.\n",
        "createdAt" : "2013-04-25T21:34:08Z",
        "updatedAt" : "2013-04-25T22:13:05Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "496f68336f8a434062f61725ca22025895185cd4",
    "line" : null,
    "diffHunk" : "@@ -1,1 +240,244 @@                         * items in an array.\n                         */\n                        list = PyArray_ToList(data_obj);\n                        if (list != NULL) {\n                            result = PyArray_GetArrayParamsFromObject("
  },
  {
    "id" : "4186ebeb-d00a-4835-b23a-4ea9fc008587",
    "prId" : 3270,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f5695279-531b-43ea-87a5-c5fc119c0279",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "I assume the division by 4 is correct here? Does this work if Python is built with 16 bit unicode?\n",
        "createdAt" : "2013-04-25T21:36:57Z",
        "updatedAt" : "2013-04-25T22:13:05Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "ba67cfaf-3b1e-4309-8036-465a4c6e0ab2",
        "parentId" : "f5695279-531b-43ea-87a5-c5fc119c0279",
        "authorId" : "b0e7e584-a9be-4737-9003-4922807a34eb",
        "body" : "Not sure, but I think the same assumption is made about 15 lines further down after the 'case NPY_UNICODE' line.\n",
        "createdAt" : "2013-04-25T21:58:49Z",
        "updatedAt" : "2013-04-25T22:13:05Z",
        "lastEditedBy" : "b0e7e584-a9be-4737-9003-4922807a34eb",
        "tags" : [
        ]
      },
      {
        "id" : "46956073-94e7-4a0a-a745-3b313a47f1d2",
        "parentId" : "f5695279-531b-43ea-87a5-c5fc119c0279",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "It's hard to tell without context, I just recall another spot where there is a check on the python unicode size, which may even be different for python 3.3. Hmm, I've got a 2 byte version of 2.7 somewhere, I'll see what happens...\n",
        "createdAt" : "2013-04-25T22:49:24Z",
        "updatedAt" : "2013-04-25T22:49:24Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "333a3443-23b8-4270-b371-b017fe9b4f12",
        "parentId" : "f5695279-531b-43ea-87a5-c5fc119c0279",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Oh, man, total disaster. Not your fault though, happens in master too.\n\n```\nFAILED (KNOWNFAIL=5, SKIP=13, errors=2, failures=47)\n```\n\nLooks like an error slipped in somewhere along the line.\n",
        "createdAt" : "2013-04-25T23:00:26Z",
        "updatedAt" : "2013-04-25T23:00:26Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "e4994192-92bc-4800-86aa-364c2503925c",
        "parentId" : "f5695279-531b-43ea-87a5-c5fc119c0279",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "nvm, clean install turned up two unrelated errors in master and your PR does the same, so this looks good.\n",
        "createdAt" : "2013-04-25T23:20:48Z",
        "updatedAt" : "2013-04-25T23:20:48Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "496f68336f8a434062f61725ca22025895185cd4",
    "line" : 39,
    "diffHunk" : "@@ -1,1 +249,253 @@                            if (result == 0 && dtype != NULL) {\n                                if (flex_type_num == NPY_UNICODE) {\n                                    size = dtype->elsize / 4;\n                                }\n                                else {"
  },
  {
    "id" : "f83b69c0-2d6a-41c3-aa20-585d78263a04",
    "prId" : 3491,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bab35e3c-b473-4e07-a0ed-4cd27b7175df",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "`flex_dtype` type changed or was this a previous error?\n",
        "createdAt" : "2013-07-07T23:24:45Z",
        "updatedAt" : "2013-07-08T18:44:49Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "8649c077-0af8-4148-b5c2-343ad86cca34",
        "parentId" : "bab35e3c-b473-4e07-a0ed-4cd27b7175df",
        "authorId" : "b0e7e584-a9be-4737-9003-4922807a34eb",
        "body" : "This was a previous error that my first set of tests didn't catch.\n",
        "createdAt" : "2013-07-08T17:42:08Z",
        "updatedAt" : "2013-07-08T18:44:49Z",
        "lastEditedBy" : "b0e7e584-a9be-4737-9003-4922807a34eb",
        "tags" : [
        ]
      }
    ],
    "commit" : "97372dbe877f19ae73a070b05c380cfea0871dc0",
    "line" : 46,
    "diffHunk" : "@@ -1,1 +256,260 @@                            result = PyArray_GetArrayParamsFromObject(\n                                    list,\n                                    *flex_dtype,\n                                    0, &dtype,\n                                    &ndim, dims, &arr, NULL);"
  },
  {
    "id" : "45093929-20e2-475e-ad8b-7389d2345f65",
    "prId" : 8862,
    "prUrl" : "https://github.com/numpy/numpy/pull/8862#pullrequestreview-29839225",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "732df183-bb7d-420f-b592-fdc7a1dc99b3",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "nitpick: I think I'd prefer the static variable to be first",
        "createdAt" : "2017-03-29T20:50:09Z",
        "updatedAt" : "2017-03-29T20:50:09Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "388487206b39dac3da66fb8d2d8daabf5524f57c",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +1917,1921 @@    char *zeroval;\n    int ret, storeflags;\n    static PyObject * zero_obj = NULL;\n\n    if (_check_object_rec(PyArray_DESCR(arr)) < 0) {"
  },
  {
    "id" : "313d858d-64b4-4fad-a180-5754281798c4",
    "prId" : 8862,
    "prUrl" : "https://github.com/numpy/numpy/pull/8862#pullrequestreview-30080695",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7eb876c8-87f4-408c-bb5a-666fa5004780",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Same question as before - what goes wrong if we remove this special case?",
        "createdAt" : "2017-03-29T20:52:37Z",
        "updatedAt" : "2017-03-29T20:52:53Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "43ce9d6f-8145-4905-957f-d8d27040e76f",
        "parentId" : "7eb876c8-87f4-408c-bb5a-666fa5004780",
        "authorId" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "body" : "we ignore the fact that we could not allocate a PyIntOjbect? That seems dangerous, and bad practice. OTOH, if this even occurs we have bigger problems than just this allocation ...",
        "createdAt" : "2017-03-29T21:11:38Z",
        "updatedAt" : "2017-03-29T21:11:38Z",
        "lastEditedBy" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "tags" : [
        ]
      },
      {
        "id" : "9e138035-70d7-4c89-bbb5-100d67343656",
        "parentId" : "7eb876c8-87f4-408c-bb5a-666fa5004780",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "That comment was directed at `if (PyArray_ISOBJECT(arr)) {`, not the lines above it. What's special about `OBJECT_setitem` that means we don't want to call it below?",
        "createdAt" : "2017-03-29T21:13:08Z",
        "updatedAt" : "2017-03-29T21:16:31Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "ec1133ec-2700-40f6-9262-936a49167c70",
        "parentId" : "7eb876c8-87f4-408c-bb5a-666fa5004780",
        "authorId" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "body" : "I'm not sure I follow. AFAIK ``PyArray_DESCR(arr)->f->setitem(one_obj, oneval, arr)`` will assume ``oneval`` is a valid pointer to a block of memory large enough to hold sizeof(PyIntObject), but it is actually a ``void* NULL`` at this point, with no valid content. So ``setitem`` will effectively call  ``memcpy(oneval, one_obj, sizeof(PyIntObject)`` which will attempt to copy around 32 bytes into a NULL pointer.",
        "createdAt" : "2017-03-29T21:24:42Z",
        "updatedAt" : "2017-03-29T21:24:42Z",
        "lastEditedBy" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "tags" : [
        ]
      },
      {
        "id" : "43207ea3-0d03-475f-b1ee-d007593869e9",
        "parentId" : "7eb876c8-87f4-408c-bb5a-666fa5004780",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "> `[zero]val` is a valid pointer to a block of memory large enough to hold `sizeof(PyIntObject)`, but it is actually a `void* NULL`\r\n\r\ncitation needed. I see a `zeroval = PyDataMem_NEW(PyArray_DESCR(arr)->elsize);` on one of the lines above. Obviously it's not NULL, else the memcpy here would fail.",
        "createdAt" : "2017-03-29T21:54:33Z",
        "updatedAt" : "2017-03-29T21:55:11Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "3c03385d-5a19-4d7d-86c6-52ec9f118528",
        "parentId" : "7eb876c8-87f4-408c-bb5a-666fa5004780",
        "authorId" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "body" : "My analysis was wrong, yours was more correct. But in the end, we cannot use ``setitem``, when I tried I got a segfault in ``test_simple_object`` from ``test_multiarray``.\r\n\r\nTheoretically ``PyArray_DESCR(arr)->f->setitem(one_obj, oneval, arr)``, which ends up on ``OBJECT_setitem``, should work, although it would call ``Py_INCREF`` on the ``PyObject*`` so we would need a matching ``Py_DECREF`` after the call, who would do it and when?\r\n\r\nUnfortunately the current implementation crashes since ``OBJECT_setitem`` calls ``Py_XDECREF`` on ``oneval`` (or ``zeroval``) and since the memory was allocated with ``malloc`` via ``PyDataMem_New`` it is not zeroed out, so the ``Py_XDECREF`` crashes the interpreter. Perhaps this is why the original implementer did not call ``setitem``, in addition to the concern about the extra ``Py_INCREF`` needing a matching call somewhere.\r\n\r\n ",
        "createdAt" : "2017-03-30T18:49:42Z",
        "updatedAt" : "2017-03-30T18:49:42Z",
        "lastEditedBy" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "tags" : [
        ]
      }
    ],
    "commit" : "388487206b39dac3da66fb8d2d8daabf5524f57c",
    "line" : 20,
    "diffHunk" : "@@ -1,1 +1934,1938 @@        }\n    }\n    if (PyArray_ISOBJECT(arr)) {\n        /* XXX this is dangerous, the caller probably is not\n           aware that zeroval is actually a static PyObject*"
  },
  {
    "id" : "c6d9c6c5-03aa-4961-b802-ef7adc9c192c",
    "prId" : 10553,
    "prUrl" : "https://github.com/numpy/numpy/pull/10553#pullrequestreview-95668295",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d002b40a-16fa-40cf-a3f4-1b3d1a1dbcfa",
        "parentId" : null,
        "authorId" : "a4f03a99-2e43-482b-a9bc-5a9e359abb03",
        "body" : "I don't think this NULL check is needed.",
        "createdAt" : "2018-02-11T20:23:56Z",
        "updatedAt" : "2018-02-11T20:23:56Z",
        "lastEditedBy" : "a4f03a99-2e43-482b-a9bc-5a9e359abb03",
        "tags" : [
        ]
      },
      {
        "id" : "e74c7166-ba31-443f-822c-12de9acbec70",
        "parentId" : "d002b40a-16fa-40cf-a3f4-1b3d1a1dbcfa",
        "authorId" : "a4f03a99-2e43-482b-a9bc-5a9e359abb03",
        "body" : "oh wait it is, I forgot this is a loop\r\n",
        "createdAt" : "2018-02-11T20:24:56Z",
        "updatedAt" : "2018-02-11T20:24:56Z",
        "lastEditedBy" : "a4f03a99-2e43-482b-a9bc-5a9e359abb03",
        "tags" : [
        ]
      }
    ],
    "commit" : "860cc39dbf1e1b40004c7a128c9c83bf7671b278",
    "line" : 45,
    "diffHunk" : "@@ -1,1 +1327,1331 @@        ret = tmp;\n        if (ret == NULL) {\n            return NULL;\n        }\n    }"
  },
  {
    "id" : "392619de-9602-42dc-9d07-290b5adce30b",
    "prId" : 10555,
    "prUrl" : "https://github.com/numpy/numpy/pull/10555#pullrequestreview-95624733",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "82f7fd09-1851-410d-b167-c998f850f4d3",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Oops, this is causing travis to fail - guess I should have left these on separate lines (my local build doesn't emit the warnings travis does)",
        "createdAt" : "2018-02-10T06:33:25Z",
        "updatedAt" : "2018-02-10T06:33:26Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "d25e85f3-3955-4f7c-ab81-32118ff8645c",
        "parentId" : "82f7fd09-1851-410d-b167-c998f850f4d3",
        "authorId" : "a4f03a99-2e43-482b-a9bc-5a9e359abb03",
        "body" : "oh I misread, I thought circleci failed",
        "createdAt" : "2018-02-10T15:17:41Z",
        "updatedAt" : "2018-02-10T15:17:41Z",
        "lastEditedBy" : "a4f03a99-2e43-482b-a9bc-5a9e359abb03",
        "tags" : [
        ]
      }
    ],
    "commit" : "3bce2be74f228684ca2895ad02b63953f37e2a9d",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +1766,1770 @@            sizeof(*all_dtypes) * (narrs + ndtypes));\n        if (all_dtypes == NULL) {\n            return PyErr_NoMemory();\n        }\n        for (i = 0; i < narrs; ++i) {"
  },
  {
    "id" : "eb992e59-bfa1-45e7-8e06-d5bbdcb06bf3",
    "prId" : 12032,
    "prUrl" : "https://github.com/numpy/numpy/pull/12032#pullrequestreview-159171517",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e57695f7-966f-4bc1-ba35-060cb60b0ff8",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Put the decref on this line, and then you can omit it below.",
        "createdAt" : "2018-09-26T07:27:58Z",
        "updatedAt" : "2018-09-26T17:24:24Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "fcacb7b6-b8e9-4a04-bd7f-076d8714ef50",
        "parentId" : "e57695f7-966f-4bc1-ba35-060cb60b0ff8",
        "authorId" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "body" : "done",
        "createdAt" : "2018-09-26T19:55:25Z",
        "updatedAt" : "2018-09-26T19:55:25Z",
        "lastEditedBy" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "tags" : [
        ]
      }
    ],
    "commit" : "df68e6485e8a9cedb784293ca5d704aba0cf3dbc",
    "line" : 20,
    "diffHunk" : "@@ -1,1 +2074,2078 @@            newtype = PyArray_DescrFromObject(otmp, intype);\n            Py_DECREF(otmp);\n            Py_XDECREF(intype);\n            if (newtype == NULL) {\n                goto fail;"
  },
  {
    "id" : "c3fc7768-dc54-456f-b7c9-52fc12ade16d",
    "prId" : 12032,
    "prUrl" : "https://github.com/numpy/numpy/pull/12032#pullrequestreview-159171467",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0b2d9da4-5b93-45e1-9da5-66fa9edbf967",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Same again - you're done with the object already by this line, so can decref it immediately",
        "createdAt" : "2018-09-26T07:28:21Z",
        "updatedAt" : "2018-09-26T17:24:24Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "cf12d521-fbfe-4fc5-bda9-f06887254900",
        "parentId" : "0b2d9da4-5b93-45e1-9da5-66fa9edbf967",
        "authorId" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "body" : "done",
        "createdAt" : "2018-09-26T19:55:17Z",
        "updatedAt" : "2018-09-26T19:55:17Z",
        "lastEditedBy" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "tags" : [
        ]
      }
    ],
    "commit" : "df68e6485e8a9cedb784293ca5d704aba0cf3dbc",
    "line" : 28,
    "diffHunk" : "@@ -1,1 +2084,2088 @@            newtype = PyArray_DescrFromObject(otmp, stype);\n            Py_DECREF(otmp);\n            Py_XDECREF(stype);\n            if (newtype == NULL) {\n                goto fail;"
  },
  {
    "id" : "499ce513-e33f-4d6c-9af0-02297695deae",
    "prId" : 12234,
    "prUrl" : "https://github.com/numpy/numpy/pull/12234#pullrequestreview-192143867",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d72f27fc-c2cc-41f2-9e0d-40cc0fc0192e",
        "parentId" : null,
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Look like there should be a DECREF right aftr this call. Also removes the need for the decref's later.",
        "createdAt" : "2019-01-04T10:50:26Z",
        "updatedAt" : "2019-01-14T13:08:29Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "b5713eaf-7978-45be-9185-9f7516c44afb",
        "parentId" : "d72f27fc-c2cc-41f2-9e0d-40cc0fc0192e",
        "authorId" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "body" : "adopted",
        "createdAt" : "2019-01-14T10:19:50Z",
        "updatedAt" : "2019-01-14T13:08:30Z",
        "lastEditedBy" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "tags" : [
        ]
      },
      {
        "id" : "7733ac9e-6ddb-4c52-accc-83b4a0cea813",
        "parentId" : "d72f27fc-c2cc-41f2-9e0d-40cc0fc0192e",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "I am confused what I had thought here, but the code looks right...",
        "createdAt" : "2019-01-14T12:47:08Z",
        "updatedAt" : "2019-01-14T13:08:30Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "34a4bce4-35a0-437c-8f40-08a5ca44496c",
        "parentId" : "d72f27fc-c2cc-41f2-9e0d-40cc0fc0192e",
        "authorId" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "body" : "This was the segfault. When removing the `retval = flex_dtype` at the top of the function and moving it to an else clause at the end, I didn't take into account the implied `else` cases in this block. You had suggested moving the `Py_DECREF(flex_type)` out to here, but instead I moved `retval = flex_type` here and left the `Py_DECREF`s in place.",
        "createdAt" : "2019-01-14T13:12:36Z",
        "updatedAt" : "2019-01-14T13:12:36Z",
        "lastEditedBy" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "tags" : [
        ]
      }
    ],
    "commit" : "5db21b862ac7637a2eaeff9c57256fea4874e44a",
    "line" : 176,
    "diffHunk" : "@@ -1,1 +332,336 @@    else if (flex_type_num == NPY_DATETIME ||\n                flex_type_num == NPY_TIMEDELTA) {\n        meta = get_datetime_metadata_from_dtype(flex_dtype);\n        retval = flex_dtype;\n        if (meta == NULL) {"
  },
  {
    "id" : "758aaaf9-bf69-4a1d-898b-bf33fc41f290",
    "prId" : 13648,
    "prUrl" : "https://github.com/numpy/numpy/pull/13648#pullrequestreview-244511983",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5b6b99d7-61b7-4a01-b701-1e0a9d65f69c",
        "parentId" : null,
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "What about object and subarrays? E.g `np.dtype(\"(1,2)u8\")`",
        "createdAt" : "2019-05-29T21:17:22Z",
        "updatedAt" : "2019-06-12T18:48:41Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "df7ad874-499d-4419-898e-c53703850e3d",
        "parentId" : "5b6b99d7-61b7-4a01-b701-1e0a9d65f69c",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Sorry, of course rather something like> `np.dtype([\"f1\", \"f4\", (5,)])` or `np.dtype([(\"f1\", \"f,f\")])`",
        "createdAt" : "2019-05-29T21:43:34Z",
        "updatedAt" : "2019-06-12T18:48:41Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "5bfcffc8-b730-4ebb-8a9d-d1256f925dac",
        "parentId" : "5b6b99d7-61b7-4a01-b701-1e0a9d65f69c",
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "I think for casting to structured array, sub-arrays do not matter - certainly- `astype` happily does it. This particular stanza is really mostly there to ensure we return `False` when casting is not \"unsafe\".",
        "createdAt" : "2019-05-29T23:25:44Z",
        "updatedAt" : "2019-06-12T18:48:41Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      },
      {
        "id" : "fe2046fc-29ff-4e8f-ac41-a3d03a3ab212",
        "parentId" : "5b6b99d7-61b7-4a01-b701-1e0a9d65f69c",
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "For subarrays in `from`, `astype` seems quite happy to just take the first element. So, for now just mimicking that.",
        "createdAt" : "2019-05-29T23:38:11Z",
        "updatedAt" : "2019-06-12T18:48:41Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      },
      {
        "id" : "33ac9926-3008-44e3-9d7d-008329ee38a0",
        "parentId" : "5b6b99d7-61b7-4a01-b701-1e0a9d65f69c",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "What happens for:\r\n```\r\nfrom_dt = np.dtype([('a', ('i4,i4', 2))])\r\nto_dt = np.dtype([('a', 'i4')])\r\n```\r\n\r\nFor instance\r\n```\r\narr = np.array(([(1, 2), (3, 4)],), dtype=from_dt)\r\narr.astype(to_dt)\r\n```\r\n\r\nWhat's currently implemented is not \"just take the first element\", but \"take the first element and ignore all casting rules when casting it\"",
        "createdAt" : "2019-05-31T01:55:18Z",
        "updatedAt" : "2019-06-12T18:48:41Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "dea5d318-0d5d-4b90-b126-8a435d1a0807",
        "parentId" : "5b6b99d7-61b7-4a01-b701-1e0a9d65f69c",
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "Your particular example with `astype` raises an error in both in current master and in my PR, because `from_dt['a']` itself has two fields, which cannot be cast to a single one.\r\n\r\nSadly, though, `can_cast` happily claims this works even in my PR as `from['a']` has no fields (but does have a `subdtype`) - though only for `casting='unsafe'`.\r\n\r\n\r\n\r\n",
        "createdAt" : "2019-05-31T17:04:26Z",
        "updatedAt" : "2019-06-12T18:48:41Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      },
      {
        "id" : "17b6549a-4da3-493b-94a3-d1588191b245",
        "parentId" : "5b6b99d7-61b7-4a01-b701-1e0a9d65f69c",
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "OK, that particular case is solved. But really `astype` is weird - it checks `can_cast` internally but can still throw an error later. This should not be allowed...",
        "createdAt" : "2019-05-31T17:53:59Z",
        "updatedAt" : "2019-06-12T18:48:41Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      },
      {
        "id" : "b1229646-6518-4d6a-ac67-9975203fd1c6",
        "parentId" : "5b6b99d7-61b7-4a01-b701-1e0a9d65f69c",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Well, astype casting could fail based on the values. Of course you are right and it should not fail based on information already inside the dtype.\r\n\r\nI have to catch up a bit here, sorry, but I do not really want crunch my mind too much about it right now, we are talking about corner cases and if we have new infrastructure things _might_ get easier to align.",
        "createdAt" : "2019-05-31T20:35:05Z",
        "updatedAt" : "2019-06-12T18:48:41Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "53bfbaf7-e09e-4a8d-ad59-80e1331587f0",
        "parentId" : "5b6b99d7-61b7-4a01-b701-1e0a9d65f69c",
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "@seberg - agreed that we should take this bit-by-bit. My main goal really is to ensure that structured with multiple fields to unstructured always returns `False`, as this cannot possibly work (and has caused me real head-aches).",
        "createdAt" : "2019-05-31T20:44:38Z",
        "updatedAt" : "2019-06-12T18:48:41Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      }
    ],
    "commit" : "e12c6bda05c8b8c024f04f2d41416e5e63971b3e",
    "line" : 65,
    "diffHunk" : "@@ -1,1 +736,740 @@        }\n    }\n    else if (PyDataType_HASFIELDS(to)) {\n        /*\n         * If \"from\" is a simple data type and \"to\" has fields, then only"
  },
  {
    "id" : "5ed29220-d9eb-48e4-b995-3ab7de2067af",
    "prId" : 13648,
    "prUrl" : "https://github.com/numpy/numpy/pull/13648#pullrequestreview-248952203",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "82ea0faa-2740-400f-bf41-866750679139",
        "parentId" : null,
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "NIT: More indentation is nice, but it really doesn't matter here.",
        "createdAt" : "2019-06-12T16:21:34Z",
        "updatedAt" : "2019-06-12T18:48:41Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "b89bf74e-3c28-404f-a943-2bcb62e400be",
        "parentId" : "82ea0faa-2740-400f-bf41-866750679139",
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "Leaving this for the great C code cleanup...",
        "createdAt" : "2019-06-12T18:49:20Z",
        "updatedAt" : "2019-06-12T18:49:20Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      }
    ],
    "commit" : "e12c6bda05c8b8c024f04f2d41416e5e63971b3e",
    "line" : 16,
    "diffHunk" : "@@ -1,1 +687,691 @@          PyDataType_ISOBJECT(from)) &&\n         NPY_LIKELY(from->type_num == to->type_num) &&\n         NPY_LIKELY(from->byteorder == to->byteorder))) {\n        return 1;\n    }"
  },
  {
    "id" : "c695a956-7273-4bde-8109-a3b1302546ce",
    "prId" : 16133,
    "prUrl" : "https://github.com/numpy/numpy/pull/16133#pullrequestreview-404547792",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a6c5ea92-70b6-4811-8162-15b9121befe7",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "I wonder if this function is even worth it at this point, given it would be a one-liner at each call site.",
        "createdAt" : "2020-05-02T13:43:40Z",
        "updatedAt" : "2020-05-12T20:46:17Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "2bc7b7c1-4f7e-4013-87af-eda580d90b6f",
        "parentId" : "a6c5ea92-70b6-4811-8162-15b9121befe7",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Yeah, have to admit, I am not sure. On the other hand, that way at least the error message is not spelled out in 5 places.",
        "createdAt" : "2020-05-02T13:46:20Z",
        "updatedAt" : "2020-05-12T20:46:17Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "22bcf52c-cd95-476e-aacc-eda7ba5e2baf",
        "parentId" : "a6c5ea92-70b6-4811-8162-15b9121befe7",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Missed how many times this was used, that seems fair. Maybe replace `scalar` with `char const *what`, which makes it possible for the caller to pass more info to put in the message, which will also make the implementation shorter.",
        "createdAt" : "2020-05-02T14:23:15Z",
        "updatedAt" : "2020-05-12T20:46:17Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "8ca3fb0e-6e91-4e75-b49a-597e8db13e3f",
        "parentId" : "a6c5ea92-70b6-4811-8162-15b9121befe7",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "To be fair, 2 of those would be the concatenate fixup...",
        "createdAt" : "2020-05-02T14:26:17Z",
        "updatedAt" : "2020-05-12T20:46:17Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "88579836-2a06-42a5-ab74-38763968eb10",
        "parentId" : "a6c5ea92-70b6-4811-8162-15b9121befe7",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Made that simplifictaion for the iterator code (which is arguably very similar), and adds another 1.5 occurances, which then are not covered here (so we have 2 \"places\" in the code). \r\n\r\nThe only real reason for this being useful is probably the scalar distinction, which is correct, but a bit wonky admittedly.\r\n\r\nEDIT: Trivial duplication is at least super easy to grep for after all...",
        "createdAt" : "2020-05-02T17:55:47Z",
        "updatedAt" : "2020-05-12T20:46:17Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      }
    ],
    "commit" : "9cc3af7abf8728534939d37dcda07c66d68381a3",
    "line" : 35,
    "diffHunk" : "@@ -1,1 +1017,1021 @@ */\nNPY_NO_EXPORT void\nnpy_set_invalid_cast_error(\n        PyArray_Descr *src_dtype, PyArray_Descr *dst_dtype,\n        NPY_CASTING casting, npy_bool scalar)"
  },
  {
    "id" : "c26e6ba5-3f08-4b62-bb56-84b102c7e411",
    "prId" : 16133,
    "prUrl" : "https://github.com/numpy/numpy/pull/16133#pullrequestreview-405301894",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9d7c29f8-2c1b-43c8-a73b-6682409ba10a",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Just to be clear, my comment above from mobile (where multi-line comments are not possible) was questioning whether this would be better as:\r\n```suggestion\r\n        NPY_CASTING casting, char const *what)\r\n{\r\n    PyErr_Format(PyExc_TypeError,\r\n            \"Cannot cast %s from %R to %R according to the rule %s,\r\n            what, src_dtype, dst_dtype, npy_casting_to_string(casting));\r\n```",
        "createdAt" : "2020-05-03T10:20:29Z",
        "updatedAt" : "2020-05-12T20:46:17Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "70b8169b-d743-46e3-a895-67aca1dabfea",
        "parentId" : "9d7c29f8-2c1b-43c8-a73b-6682409ba10a",
        "authorId" : "fe664d20-2239-4242-9bd1-2c7a4f010863",
        "body" : "if this is going to be limited to different msg's for scalar vs non scalar, i prefer the current way, where the msg is decided by `npy_set_invalid_cast_error`. If there are more else if switches added here though, maybe what as the argument would be better.",
        "createdAt" : "2020-05-04T19:57:47Z",
        "updatedAt" : "2020-05-12T20:46:17Z",
        "lastEditedBy" : "fe664d20-2239-4242-9bd1-2c7a4f010863",
        "tags" : [
        ]
      }
    ],
    "commit" : "9cc3af7abf8728534939d37dcda07c66d68381a3",
    "line" : 48,
    "diffHunk" : "@@ -1,1 +1030,1034 @@    }\n    PyErr_Format(PyExc_TypeError,\n            msg, src_dtype, dst_dtype, npy_casting_to_string(casting));\n}\n"
  },
  {
    "id" : "7f87735e-0851-4e80-a82b-8f81576e30b9",
    "prId" : 18398,
    "prUrl" : "https://github.com/numpy/numpy/pull/18398#pullrequestreview-614977482",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "971dc2f4-21af-46f2-86eb-1c4c3b5d704e",
        "parentId" : null,
        "authorId" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "body" : "If this could be hit by a user-defined type (as I think it could), it would be good to test for",
        "createdAt" : "2021-03-17T12:37:52Z",
        "updatedAt" : "2021-03-18T16:28:57Z",
        "lastEditedBy" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "tags" : [
        ]
      },
      {
        "id" : "97a6ac75-fd05-4b2f-b8f7-cf0b740f1051",
        "parentId" : "971dc2f4-21af-46f2-86eb-1c4c3b5d704e",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "It can't be hit by a current user defined dtype. I could currently only hit it by adding a cast twice to a NumPy builtin DType.",
        "createdAt" : "2021-03-17T22:23:38Z",
        "updatedAt" : "2021-03-18T16:28:57Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "d4223eae-a5a2-4f28-bb92-20b2f1fd6707",
        "parentId" : "971dc2f4-21af-46f2-86eb-1c4c3b5d704e",
        "authorId" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "body" : "Please add a comment then that it is an internal error, and will never be hit in practice",
        "createdAt" : "2021-03-18T04:47:32Z",
        "updatedAt" : "2021-03-18T16:28:57Z",
        "lastEditedBy" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "tags" : [
        ]
      }
    ],
    "commit" : "b5de1ceb1f1707d0539446b3d8883f3f8f80cb69",
    "line" : 56,
    "diffHunk" : "@@ -1,1 +1921,1925 @@                    \"A cast was already added for %S -> %S. (method: %s)\",\n                    meth->dtypes[0], meth->dtypes[1], meth->method->name);\n            return -1;\n        }\n        Py_INCREF(meth->method);"
  },
  {
    "id" : "11c767a9-3124-4f8e-a599-b66e061532c2",
    "prId" : 19174,
    "prUrl" : "https://github.com/numpy/numpy/pull/19174#pullrequestreview-676802273",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5fac83f8-7857-48e8-9e45-933170581aeb",
        "parentId" : null,
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "The diff is a bit hard to read, but this is just a refactor, moving the chunk of code out from `PyArray_GetCastSafety`, so that I can use it from `PyArray_CheckCastSafety()` as a function that takes the cast safety as input and can thus check `castingimpl->casting` to short circuit.\r\n\r\n(The use of that short-cut is probably fairly moderate, since it only helps if `np.can_cast(..., ...)` returns definitely `True` – at the moment short-cutting for a definitely `False` return would even be more useful, but that is mainly because of how ufuncs currently work, and that will change.)",
        "createdAt" : "2021-06-05T19:03:32Z",
        "updatedAt" : "2021-06-05T19:03:32Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      }
    ],
    "commit" : "b98ee20e8d10477cc29bce8b595b533de031aec6",
    "line" : 40,
    "diffHunk" : "@@ -1,1 +395,399 @@    assert(casting != (NPY_EQUIV_CASTING|_NPY_CAST_IS_VIEW));\n    return casting;\n}\n\n"
  },
  {
    "id" : "11d843c1-c9da-48d1-b91e-2e9238460951",
    "prId" : 19326,
    "prUrl" : "https://github.com/numpy/numpy/pull/19326#pullrequestreview-691891276",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "707159d3-0bc1-41aa-9e6e-3bb1f63f5950",
        "parentId" : null,
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "This is the right idea, but should be `given_descrs[0]` or `given_descrs[1]` rather than `NULL`.  I guess the unstructured `void` case is missing (i.e. there must be a `V4` or similar involved here somehow), I don't know yet how or why `view` even triggers it...\r\n\r\nFor tests, it may be good to use also check with `np.can_cast` (`casting=\"unsafe\"`).",
        "createdAt" : "2021-06-24T14:46:46Z",
        "updatedAt" : "2021-06-24T14:46:46Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "e627a222-7236-4953-a469-9100f3f8e4f3",
        "parentId" : "707159d3-0bc1-41aa-9e6e-3bb1f63f5950",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Ah, I had not realized that in your example `x.dtype` is `\"V40\"`, than it all adds up.",
        "createdAt" : "2021-06-24T14:49:18Z",
        "updatedAt" : "2021-06-24T14:49:19Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "3cd9bf37-7422-4434-b948-a34ecb055541",
        "parentId" : "707159d3-0bc1-41aa-9e6e-3bb1f63f5950",
        "authorId" : "0625f394-a652-460e-909a-4a85a8b089d6",
        "body" : "Sure, that works without requiring any change to `PyArray_GetCastSafety` itself. Let me look into a test case and I will update",
        "createdAt" : "2021-06-24T15:18:34Z",
        "updatedAt" : "2021-06-24T15:18:34Z",
        "lastEditedBy" : "0625f394-a652-460e-909a-4a85a8b089d6",
        "tags" : [
        ]
      }
    ],
    "commit" : "9bf60f5f8c5d0dde78b737932e61dec61b960d53",
    "line" : 9,
    "diffHunk" : "@@ -1,1 +3297,3301 @@        PyArray_Descr *from_base = (from_sub == NULL) ? given_descrs[0] : from_sub->base;\n        PyArray_Descr *to_base = (to_sub == NULL) ? given_descrs[1] : to_sub->base;\n        NPY_CASTING field_casting = PyArray_GetCastSafety(from_base, to_base, NULL);\n        if (field_casting < 0) {\n            return -1;"
  },
  {
    "id" : "baf8bc51-d9e8-4de7-91d8-5aaf56bb8e85",
    "prId" : 19371,
    "prUrl" : "https://github.com/numpy/numpy/pull/19371#pullrequestreview-697479167",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4d3d9f62-051c-462f-8685-fdd31e7cbb39",
        "parentId" : null,
        "authorId" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "body" : "I don't understand this comment. It seems you could replace both lines with `(NPY_NO_CASTING |_NPY_CAST_IS_VIEW)`? It is in an `assert` anyway, so is not critical.",
        "createdAt" : "2021-06-30T08:11:07Z",
        "updatedAt" : "2021-06-30T08:11:07Z",
        "lastEditedBy" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "tags" : [
        ]
      },
      {
        "id" : "80404702-dfb0-44d2-996c-79646bef598b",
        "parentId" : "4d3d9f62-051c-462f-8685-fdd31e7cbb39",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "I added cast-is-view as a flag, because it is explicit and we could also have `NPY_UNSAFE_CASTING | NPY_CAST_IS_VIEW`.  But \"no\" casting, currently means \"equivalent\" (at most byte-order should be changing) + \"cast-is-view\" (since that ensures no byte-order is happening).  So the first checks that \"equiv+view\" should not be used (it should be \"no\") and the second checks the \"is-view\" flag was not forgotten when \"no\" is returned.\r\n\r\nThese might not be strict rules in the long term, but I can't think of exceptions right now.",
        "createdAt" : "2021-06-30T13:46:14Z",
        "updatedAt" : "2021-06-30T13:46:14Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "69e7f0d2-13f8-4dc9-9469-81208485af04",
        "parentId" : "4d3d9f62-051c-462f-8685-fdd31e7cbb39",
        "authorId" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "body" : "I was not checking the logic, rather trying to match the comment to the values. You write: \r\n> For casts `NPY_NO_CASTING` is equivalent to `(NPY_EQUIV_CASTING|_NPY_CAST_IS_VIEW)` so using that is incorrect\r\n\r\nIf indeed `NPY_NO_CASTING` = `(NPY_EQUIV_CASTING|_NPY_CAST_IS_VIEW)`, then the two asserts contain exactly the same code. Is there a way to briefly improve the comment to explain why both asserts are needed?",
        "createdAt" : "2021-07-01T06:34:54Z",
        "updatedAt" : "2021-07-01T06:34:54Z",
        "lastEditedBy" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "tags" : [
        ]
      },
      {
        "id" : "cecb5458-b258-43a3-a925-675df261780c",
        "parentId" : "4d3d9f62-051c-462f-8685-fdd31e7cbb39",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "OK, I am obviously getting the reasoning not clear.  Changed it to the following, is that clearer?:\r\n```C\r\n    /*\r\n     * Check for less harmful non-standard returns.  The following two returns\r\n     * should never happen. They would be roughly equivalent, but less precise,\r\n     * versions of `(NPY_NO_CASTING|_NPY_CAST_IS_VIEW)`.\r\n     * 1. No-casting must imply cast-is-view.\r\n     * 2. Equivalent-casting + cast-is-view is (currently) the definition\r\n     *    of a \"no\" cast (there may be reasons to relax this).\r\n     * Note that e.g. `(NPY_UNSAFE_CASTING|_NPY_CAST_IS_VIEW)` is valid.\r\n     */\r\n    assert(casting != NPY_NO_CASTING);\r\n    assert(casting != (NPY_EQUIV_CASTING|_NPY_CAST_IS_VIEW));\r\n```",
        "createdAt" : "2021-07-01T14:49:41Z",
        "updatedAt" : "2021-07-01T14:49:41Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "a1e7651f-ccdb-4227-bfdc-d5e84766af1f",
        "parentId" : "4d3d9f62-051c-462f-8685-fdd31e7cbb39",
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "Maybe good to put it in my own words, so that we can check: `NPY_EQUIV_CASTING|_NPY_CAST_IS_VIEW` states that byte-order changes might be needed and that the cast can be done with a view. Since a view implies no byte order changes, this indeed has to be the same as NO_CAST. Should I then interpret your last example similarly: `NPY_UNSAFE_CASTING|_NPY_CAST_IS_VIEW` means unsafe casting may be needed, but it is a view, so it should also be `NPY_NO_CASTING`? Or is this actually meaningful, say, a cast of a float to a structured dtype with just a single float, which can be done as a view?\r\n\r\nI guess it has now left me a bit confused about the purpose of the `_NPY_CAST_IS_VIEW` flag - though best may be not to add more here, but instead clarify in `ndarraytypes.h`...",
        "createdAt" : "2021-07-01T15:42:54Z",
        "updatedAt" : "2021-07-01T15:42:54Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      },
      {
        "id" : "44d18926-98a8-4e2f-9e57-ae17cc9b8b56",
        "parentId" : "4d3d9f62-051c-462f-8685-fdd31e7cbb39",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "> Or is this actually meaningful, say, a cast of a float to a structured dtype with just a single float, which can be done as a view?\r\n\r\nYes.\r\n\r\nThere are a couple of places where I thought this would be useful. The two main examples are probably:\r\n* A `Float64Unit` dtype is an unsafe cast to `Float64`, but it *is* just a view. (In theory `timedelta64 -> int` falls into this category)\r\n* A structured dtype with different names is just a view, but it should be a \"safe\" and not an \"equiv\" cast IMO.\r\n\r\nOverall, I feel it is more explicit...  But since I then somewhat enforce these constraints, it might also just be a bit clunky....\r\n\r\nIn practice, I admit it might be a bit of a half-solution...  There are casts that could be a view+offset and casts that are not \"equiv\" but can be done as a \"view\" may just be rare.  And I am not sure that we should try to apply this e.g. to `datetime64_arr.astype(int64, copy=False)` to be a view – although part of that may be that we should check for NaT creation.",
        "createdAt" : "2021-07-01T16:05:06Z",
        "updatedAt" : "2021-07-01T16:05:06Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "161d084c-f626-4fac-aeb9-583068d462c6",
        "parentId" : "4d3d9f62-051c-462f-8685-fdd31e7cbb39",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Its good to discuss this and it is not close to public API yet, so I am happy to reconsider the whole thing :).  For example:\r\n\r\n1. We could just drop it again (cast-is-view behaviour is only available for \"no\" casts).\r\n2. We could make it an output `npy_intp *view_offset` (initialized to INTP_MIN – so users can ignore it if it does not apply).  That would remove it as a confusing flag on the casting enum and add the flexibility to deal with offsets even.",
        "createdAt" : "2021-07-01T16:19:40Z",
        "updatedAt" : "2021-07-01T16:33:03Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "812dc91d-5d59-46e2-9970-2dd0c1d3e24a",
        "parentId" : "4d3d9f62-051c-462f-8685-fdd31e7cbb39",
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "I like having the concept - using views is part of what makes numpy so powerful and I like your extensions. But I think mixing it in with the CAST enum is indeed a bit confusing, and the offset seems a cleaner suggestion (I guess in principle that means one could view an uint64 as an uint32, as long as one did the offset carefully, taking into account bigendian, etc.) \r\n\r\nPerhaps an idea to open a separate issue? Perhaps even a general one with loose ends? For now, it probably makes more sense to proceed with what you have!",
        "createdAt" : "2021-07-01T17:09:17Z",
        "updatedAt" : "2021-07-01T17:09:17Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      }
    ],
    "commit" : "b26316b452367b637847105fe13aacd4e69bf9d3",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +401,405 @@     * Note that e.g. `(NPY_UNSAFE_CASTING|_NPY_CAST_IS_VIEW)` is valid.\n     */\n    assert(casting != NPY_NO_CASTING);\n    assert(casting != (NPY_EQUIV_CASTING|_NPY_CAST_IS_VIEW));\n    return casting;"
  }
]
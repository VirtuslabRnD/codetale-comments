[
  {
    "id" : "5c0d8ba2-6c88-4b74-b958-41355c64b2c4",
    "prId" : 9998,
    "prUrl" : "https://github.com/numpy/numpy/pull/9998#pullrequestreview-105905990",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "113a5763-361f-47c8-9ae3-f74e2cf57d15",
        "parentId" : null,
        "authorId" : "a4f03a99-2e43-482b-a9bc-5a9e359abb03",
        "body" : "In this file, in `NpyIter_AdvancedNew`, we need some calls to `PyArray_DiscardWritebackIfCopy` if a failure occurs after the call to `npyiter_allocate_arrays`.",
        "createdAt" : "2018-03-12T18:02:28Z",
        "updatedAt" : "2018-04-21T19:57:31Z",
        "lastEditedBy" : "a4f03a99-2e43-482b-a9bc-5a9e359abb03",
        "tags" : [
        ]
      },
      {
        "id" : "ccd5b6a7-3d9b-498d-9e1c-49a41164695d",
        "parentId" : "113a5763-361f-47c8-9ae3-f74e2cf57d15",
        "authorId" : "a4f03a99-2e43-482b-a9bc-5a9e359abb03",
        "body" : "Pinging this one again. I still think we need some calls to `PyArray_DiscardWritebackIfCopy`(2, I think) in `NpyIter_AdvancedNew`, if a failure occurs after the call to `npyiter_allocate_arrays`.",
        "createdAt" : "2018-03-21T19:55:27Z",
        "updatedAt" : "2018-04-21T19:57:31Z",
        "lastEditedBy" : "a4f03a99-2e43-482b-a9bc-5a9e359abb03",
        "tags" : [
        ]
      },
      {
        "id" : "56954d28-3aee-433e-b03d-945680fb52ec",
        "parentId" : "113a5763-361f-47c8-9ae3-f74e2cf57d15",
        "authorId" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "body" : "fixed, added `NpyIter_Close`",
        "createdAt" : "2018-03-21T21:02:04Z",
        "updatedAt" : "2018-04-21T19:57:31Z",
        "lastEditedBy" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "tags" : [
        ]
      }
    ],
    "commit" : "fa9a74165479142e2c1671f871fe7c860146cd52",
    "line" : 45,
    "diffHunk" : "@@ -1,1 +2931,2935 @@                    Py_DECREF(temp);\n                    return 0;\n                }\n                op_itflags[iop] |= NPY_OP_ITFLAG_HAS_WRITEBACK;\n            }"
  },
  {
    "id" : "bb8c5256-ac06-4d4f-878b-4cdb70cfac6c",
    "prId" : 11376,
    "prUrl" : "https://github.com/numpy/numpy/pull/11376#pullrequestreview-130274104",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6c37a6a2-4845-4dac-bfb2-43c1abe50f29",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "For consistency with how `dtype` and `object` are used below, you could use `*op_itflags` and increment it along with the others.\r\n\r\nProbably not worth it though - if anything I find your approach clearer.",
        "createdAt" : "2018-06-20T07:49:04Z",
        "updatedAt" : "2018-06-20T07:49:04Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "73494682ab4cb3469ade494c113672094ce13f47",
    "line" : 50,
    "diffHunk" : "@@ -1,1 +697,701 @@     */\n    for(iop = 0; iop < nop; ++iop, ++dtype, ++object) {\n        if (op_itflags[iop] & NPY_OP_ITFLAG_HAS_WRITEBACK) {\n            if (resolve && PyArray_ResolveWritebackIfCopy(*object) < 0) {\n                resolve = 0;"
  },
  {
    "id" : "25e0c5bd-1329-4928-83e5-4d8c7e67ae83",
    "prId" : 15162,
    "prUrl" : "https://github.com/numpy/numpy/pull/15162#pullrequestreview-422993350",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b8073d5f-c467-408f-9553-7d2ef2f02f06",
        "parentId" : null,
        "authorId" : "fe664d20-2239-4242-9bd1-2c7a4f010863",
        "body" : "nit: feel free to ignore. would be good to have some NPY_IT_DBG_PRINT in npyiter_fill_axis_data, since it hardly outputs anything if it touches this code path, except probably iter shape.",
        "createdAt" : "2020-06-02T19:28:49Z",
        "updatedAt" : "2020-06-02T19:28:49Z",
        "lastEditedBy" : "fe664d20-2239-4242-9bd1-2c7a4f010863",
        "tags" : [
        ]
      }
    ],
    "commit" : "8da4fba24c193807555dfcbc0e67834cae9185ea",
    "line" : 125,
    "diffHunk" : "@@ -1,1 +1670,1674 @@            else {\n                int *axes = op_axes[iop];\n                npy_bool reduction_axis;\n                int i;\n                i = npyiter_get_op_axis(axes[ndim - idim - 1], &reduction_axis);"
  }
]
[
  {
    "id" : "5c0d8ba2-6c88-4b74-b958-41355c64b2c4",
    "prId" : 9998,
    "prUrl" : "https://github.com/numpy/numpy/pull/9998#pullrequestreview-105905990",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "113a5763-361f-47c8-9ae3-f74e2cf57d15",
        "parentId" : null,
        "authorId" : "a4f03a99-2e43-482b-a9bc-5a9e359abb03",
        "body" : "In this file, in `NpyIter_AdvancedNew`, we need some calls to `PyArray_DiscardWritebackIfCopy` if a failure occurs after the call to `npyiter_allocate_arrays`.",
        "createdAt" : "2018-03-12T18:02:28Z",
        "updatedAt" : "2018-04-21T19:57:31Z",
        "lastEditedBy" : "a4f03a99-2e43-482b-a9bc-5a9e359abb03",
        "tags" : [
        ]
      },
      {
        "id" : "ccd5b6a7-3d9b-498d-9e1c-49a41164695d",
        "parentId" : "113a5763-361f-47c8-9ae3-f74e2cf57d15",
        "authorId" : "a4f03a99-2e43-482b-a9bc-5a9e359abb03",
        "body" : "Pinging this one again. I still think we need some calls to `PyArray_DiscardWritebackIfCopy`(2, I think) in `NpyIter_AdvancedNew`, if a failure occurs after the call to `npyiter_allocate_arrays`.",
        "createdAt" : "2018-03-21T19:55:27Z",
        "updatedAt" : "2018-04-21T19:57:31Z",
        "lastEditedBy" : "a4f03a99-2e43-482b-a9bc-5a9e359abb03",
        "tags" : [
        ]
      },
      {
        "id" : "56954d28-3aee-433e-b03d-945680fb52ec",
        "parentId" : "113a5763-361f-47c8-9ae3-f74e2cf57d15",
        "authorId" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "body" : "fixed, added `NpyIter_Close`",
        "createdAt" : "2018-03-21T21:02:04Z",
        "updatedAt" : "2018-04-21T19:57:31Z",
        "lastEditedBy" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "tags" : [
        ]
      }
    ],
    "commit" : "fa9a74165479142e2c1671f871fe7c860146cd52",
    "line" : 45,
    "diffHunk" : "@@ -1,1 +2931,2935 @@                    Py_DECREF(temp);\n                    return 0;\n                }\n                op_itflags[iop] |= NPY_OP_ITFLAG_HAS_WRITEBACK;\n            }"
  },
  {
    "id" : "bb8c5256-ac06-4d4f-878b-4cdb70cfac6c",
    "prId" : 11376,
    "prUrl" : "https://github.com/numpy/numpy/pull/11376#pullrequestreview-130274104",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6c37a6a2-4845-4dac-bfb2-43c1abe50f29",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "For consistency with how `dtype` and `object` are used below, you could use `*op_itflags` and increment it along with the others.\r\n\r\nProbably not worth it though - if anything I find your approach clearer.",
        "createdAt" : "2018-06-20T07:49:04Z",
        "updatedAt" : "2018-06-20T07:49:04Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "73494682ab4cb3469ade494c113672094ce13f47",
    "line" : 50,
    "diffHunk" : "@@ -1,1 +697,701 @@     */\n    for(iop = 0; iop < nop; ++iop, ++dtype, ++object) {\n        if (op_itflags[iop] & NPY_OP_ITFLAG_HAS_WRITEBACK) {\n            if (resolve && PyArray_ResolveWritebackIfCopy(*object) < 0) {\n                resolve = 0;"
  },
  {
    "id" : "25e0c5bd-1329-4928-83e5-4d8c7e67ae83",
    "prId" : 15162,
    "prUrl" : "https://github.com/numpy/numpy/pull/15162#pullrequestreview-422993350",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b8073d5f-c467-408f-9553-7d2ef2f02f06",
        "parentId" : null,
        "authorId" : "fe664d20-2239-4242-9bd1-2c7a4f010863",
        "body" : "nit: feel free to ignore. would be good to have some NPY_IT_DBG_PRINT in npyiter_fill_axis_data, since it hardly outputs anything if it touches this code path, except probably iter shape.",
        "createdAt" : "2020-06-02T19:28:49Z",
        "updatedAt" : "2020-06-02T19:28:49Z",
        "lastEditedBy" : "fe664d20-2239-4242-9bd1-2c7a4f010863",
        "tags" : [
        ]
      }
    ],
    "commit" : "8da4fba24c193807555dfcbc0e67834cae9185ea",
    "line" : 125,
    "diffHunk" : "@@ -1,1 +1670,1674 @@            else {\n                int *axes = op_axes[iop];\n                npy_bool reduction_axis;\n                int i;\n                i = npyiter_get_op_axis(axes[ndim - idim - 1], &reduction_axis);"
  },
  {
    "id" : "50f783d2-849c-44fb-84f9-2350abac6d7f",
    "prId" : 17404,
    "prUrl" : "https://github.com/numpy/numpy/pull/17404#pullrequestreview-500328202",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "871e586a-0133-46cb-9407-876819ae4c56",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Could do\r\n```suggestion\r\n            char const *what = op_flags[iop] & NPY_ITER_READONLY ? \"operand\" : \"output operand\";\r\n            PyErr_Format(PyExc_ValueError,\r\n                \"non-broadcastable %s with shape %S doesn't \"\r\n                \"match the broadcast shape %S\", what, shape1, shape2);\r\n```",
        "createdAt" : "2020-09-30T18:01:31Z",
        "updatedAt" : "2020-09-30T18:01:32Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "deb40516-5295-4188-82b2-96eef6d82134",
        "parentId" : "871e586a-0133-46cb-9407-876819ae4c56",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "I thought about pulling out common parts, but thought it easier to comprehend with separate messages. Part of the problem with understanding the original was that it was all separate bits cobbled together. Easy to code but hard to read :)",
        "createdAt" : "2020-09-30T18:51:41Z",
        "updatedAt" : "2020-09-30T18:51:41Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "75eb3cd3-e671-42a3-a696-b899db3c7f3c",
        "parentId" : "871e586a-0133-46cb-9407-876819ae4c56",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "I agree, there's definitely a benefit to keeping the strings together as much as possible - especially since my workflow is usually to search the C code for the error message I get from pythoon.\r\n\r\nI'd argue that in this particular case the message is still clear, and it's worth the 6 line saving",
        "createdAt" : "2020-10-01T13:09:22Z",
        "updatedAt" : "2020-10-01T13:09:22Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "e13747d8dc27c359f11485b4d6e764d7f8231562",
    "line" : 226,
    "diffHunk" : "@@ -1,1 +1894,1898 @@                    \"non-broadcastable output operand with shape %S doesn't \"\n                    \"match the broadcast shape %S\", shape1, shape2);\n            }\n            Py_DECREF(shape1);\n            Py_DECREF(shape2);"
  },
  {
    "id" : "6c0908d2-2e50-4fbb-aa12-555dfde30bea",
    "prId" : 17404,
    "prUrl" : "https://github.com/numpy/numpy/pull/17404#pullrequestreview-499684142",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3134cbd2-ffe4-4f41-b762-07834c747d86",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Could use `char const *what = op_flags[iop] & NPY_ITER_READONLY ? \"operand\" : \"output operand\";` here too",
        "createdAt" : "2020-09-30T18:02:00Z",
        "updatedAt" : "2020-09-30T18:02:01Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "e13747d8dc27c359f11485b4d6e764d7f8231562",
    "line" : 266,
    "diffHunk" : "@@ -1,1 +1921,1925 @@            }\n\n            if (op_flags[iop] & NPY_ITER_READONLY) {\n                PyErr_Format(PyExc_ValueError,\n                    \"non-broadcastable operand with shape %S \""
  }
]
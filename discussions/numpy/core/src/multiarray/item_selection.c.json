[
  {
    "id" : "1c655ae0-2f56-431a-92f3-1fd87bd823d6",
    "prId" : 2974,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "cf05042b-0800-4ec6-94b6-ce4febc064ed",
        "parentId" : null,
        "authorId" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "body" : "If `PyErr_Occurred` is true, after a BEGIN_THREADS section, then doesn't that imply that someone violated the GIL usage rules? How could a PyErr be created if the GIL was dropped?\n",
        "createdAt" : "2013-02-10T21:40:36Z",
        "updatedAt" : "2013-02-10T21:40:36Z",
        "lastEditedBy" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "tags" : [
        ]
      },
      {
        "id" : "243aeb34-8a01-421a-80d7-c2aa13b34b41",
        "parentId" : "cf05042b-0800-4ec6-94b6-ce4febc064ed",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "there is a goto fail before `NPY_BEGIN_THREADS_DESCR(PyArray_DESCR(op));`. Could special case that, but in LexSort there are a few of them.\n",
        "createdAt" : "2013-02-10T21:49:35Z",
        "updatedAt" : "2013-02-10T21:49:35Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      }
    ],
    "commit" : "2b76da387ef4c8a0317c80ce08e5bbab833b14e5",
    "line" : 56,
    "diffHunk" : "@@ -1,1 +891,895 @@ fail:\n    NPY_END_THREADS;\n    if (!PyErr_Occurred()) {\n        /* Out of memory during sorting or buffer creation */\n        PyErr_NoMemory();"
  },
  {
    "id" : "85ab5222-fb3a-4225-8bb3-aecb9bfee3fc",
    "prId" : 2974,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "db71399e-b663-49a9-930a-6272c4849e9e",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "OK.\n",
        "createdAt" : "2013-02-11T02:20:08Z",
        "updatedAt" : "2013-02-11T02:20:08Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "2b76da387ef4c8a0317c80ce08e5bbab833b14e5",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +751,755 @@    if (needcopy) {\n        char *buffer = PyDataMem_NEW(N*elsize);\n        if (buffer == NULL) {\n            goto fail;\n        }"
  },
  {
    "id" : "2200907a-cac5-4366-b928-2d48fd666ed1",
    "prId" : 2974,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "aecee6ba-f27b-45df-8c06-86c7753d6995",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "I wonder if this should be `NPY_END_THREADS_DESCR(PyArray_DESCR(op))` since the threads were started based on dtype. It could also be moved up to before the fail gotos if that would make the code more readable, not sure about that though.\n",
        "createdAt" : "2013-02-11T02:29:18Z",
        "updatedAt" : "2013-02-11T02:29:18Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "2b76da387ef4c8a0317c80ce08e5bbab833b14e5",
    "line" : 15,
    "diffHunk" : "@@ -1,1 +788,792 @@ fail:\n    /* Out of memory during sorting or buffer creation */\n    NPY_END_THREADS;\n    PyErr_NoMemory();\n    Py_DECREF(it);"
  },
  {
    "id" : "54d3f01f-c94b-418c-b6cc-9d1a1186721a",
    "prId" : 2974,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1dce1513-a7f0-4c92-b89a-e6c357bc63d2",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Maybe we should return the actual error from the sort call.\n",
        "createdAt" : "2013-02-11T02:29:47Z",
        "updatedAt" : "2013-02-11T02:29:47Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "afab8e79-83e3-4897-93ca-5b139d0d3cce",
        "parentId" : "1dce1513-a7f0-4c92-b89a-e6c357bc63d2",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Nah, doesn't look worth the trouble.\n",
        "createdAt" : "2013-02-11T02:36:54Z",
        "updatedAt" : "2013-02-11T02:36:54Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "2b76da387ef4c8a0317c80ce08e5bbab833b14e5",
    "line" : 19,
    "diffHunk" : "@@ -1,1 +791,795 @@    PyErr_NoMemory();\n    Py_DECREF(it);\n    return -1;\n}\n"
  },
  {
    "id" : "58fea242-7c63-47b7-a7c4-2a731a2be57d",
    "prId" : 3002,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9b76ecb4-61fa-4a5a-8ce0-f75ff6ad09a7",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Are these object pointers that are being moved, or larger items?\n",
        "createdAt" : "2013-02-23T15:58:35Z",
        "updatedAt" : "2013-02-25T00:02:02Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "0e9f83cb-fd02-482b-a977-96ecc012f22b",
        "parentId" : "9b76ecb4-61fa-4a5a-8ce0-f75ff6ad09a7",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Those could be larger items in structured types.\n",
        "createdAt" : "2013-02-23T16:07:53Z",
        "updatedAt" : "2013-02-25T00:02:02Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      }
    ],
    "commit" : "230ee3aa201552a8a9fa13c4b319f68cbd504d85",
    "line" : 45,
    "diffHunk" : "@@ -1,1 +140,144 @@                            PyArray_Item_INCREF(tmp_src, PyArray_DESCR(self));\n                            PyArray_Item_XDECREF(dest, PyArray_DESCR(self));\n                            memmove(dest, tmp_src, itemsize);\n                            dest += itemsize;\n                            tmp_src += itemsize;"
  },
  {
    "id" : "ff65f087-da7f-4395-b56d-691deab24d2f",
    "prId" : 3107,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6df10b87-e068-40bf-baae-5a5f80b57099",
        "parentId" : null,
        "authorId" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "body" : "What's the reason for this change?\n",
        "createdAt" : "2013-03-01T23:13:24Z",
        "updatedAt" : "2013-08-17T16:30:32Z",
        "lastEditedBy" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "tags" : [
        ]
      },
      {
        "id" : "7cecb3e0-6dfc-4797-933a-4ee120faa35c",
        "parentId" : "6df10b87-e068-40bf-baae-5a5f80b57099",
        "authorId" : "b79858b9-0a74-4264-b47d-5aebe44f2140",
        "body" : "Mostly for clarity. After these changes, elsize is only used to increment the pkey pointer. So I figured just to be consistent I should look up elsize from the key array (even though both arrays should be of the same type).\n",
        "createdAt" : "2013-03-01T23:20:32Z",
        "updatedAt" : "2013-08-17T16:30:32Z",
        "lastEditedBy" : "b79858b9-0a74-4264-b47d-5aebe44f2140",
        "tags" : [
        ]
      },
      {
        "id" : "b5a20dd1-528d-4b98-a143-d0387afde1ad",
        "parentId" : "6df10b87-e068-40bf-baae-5a5f80b57099",
        "authorId" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "body" : "Oh, we still assume that the `key` array is contiguous? Is there a reason for that, then? :-)\n",
        "createdAt" : "2013-03-01T23:26:08Z",
        "updatedAt" : "2013-08-17T16:30:32Z",
        "lastEditedBy" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "tags" : [
        ]
      },
      {
        "id" : "26eadd85-7ef1-4052-b324-a1d7154dc1a5",
        "parentId" : "6df10b87-e068-40bf-baae-5a5f80b57099",
        "authorId" : "b79858b9-0a74-4264-b47d-5aebe44f2140",
        "body" : "Two reasons. First my naivete, because the key array could have any shape and any strides I didn't know if there was an easy way to handle that in this context.\n\nThe second is that it didn't seem to me that copying the key array was as big of a problem. searchsorted is linear in the size of the key array so making a temporary copy is a relatively small constant multiplier to the run time. Because searchsorted is log(N) in the size of the array being search, making a linear time copy of that array can dominate the run time for large arrays. \n",
        "createdAt" : "2013-03-01T23:35:06Z",
        "updatedAt" : "2013-08-17T16:30:32Z",
        "lastEditedBy" : "b79858b9-0a74-4264-b47d-5aebe44f2140",
        "tags" : [
        ]
      },
      {
        "id" : "2e661cae-5076-4c51-9dd7-adce65a6d737",
        "parentId" : "6df10b87-e068-40bf-baae-5a5f80b57099",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Can use `PyArray_ITEMSIZE` to get `elsize`.\n",
        "createdAt" : "2013-03-02T00:50:22Z",
        "updatedAt" : "2013-08-17T16:30:32Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "1a43252e-6a9b-4b73-b74e-9d0e31831d2a",
        "parentId" : "6df10b87-e068-40bf-baae-5a5f80b57099",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Heh, and I usually have big arrays of keys and small arrays to look them up in. But in general I agree that the lookup times will dominate the key retrieval time.\n",
        "createdAt" : "2013-03-02T01:38:33Z",
        "updatedAt" : "2013-08-17T16:30:32Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "fb38b6e2-2621-42db-8ee5-58c4600ea7d2",
        "parentId" : "6df10b87-e068-40bf-baae-5a5f80b57099",
        "authorId" : "b79858b9-0a74-4264-b47d-5aebe44f2140",
        "body" : "Is there a way to step through an array with arbitrary strides that I could\nuse here for the key array? We could at least stop copying read only\narrays, as @njsmith noted NPY_ARRAY_DEFAULT checks for weight only arrays.\nI could include that in this pull request.\nOn Mar 1, 2013 5:38 PM, \"Charles Harris\" notifications@github.com wrote:\n\n> In numpy/core/src/multiarray/item_selection.c:\n> \n> > @@ -1505,15 +1505,22 @@\n> >      char *parr = PyArray_DATA(arr);\n> >      char *pkey = PyArray_DATA(key);\n> >      npy_intp *pret = (npy_intp *)PyArray_DATA(ret);\n> > -    int elsize = PyArray_DESCR(arr)->elsize;\n> > -    int elsize = PyArray_DESCR(key)->elsize;\n> \n> Heh, and I usually have big arrays of keys and small arrays to look them\n> up in. But in general I agree that the lookup times will dominate the key\n> retrieval time.\n> \n> —\n> Reply to this email directly or view it on GitHubhttps://github.com/numpy/numpy/pull/3107/files#r3213822\n> .\n",
        "createdAt" : "2013-03-02T02:10:37Z",
        "updatedAt" : "2013-08-17T16:30:32Z",
        "lastEditedBy" : "b79858b9-0a74-4264-b47d-5aebe44f2140",
        "tags" : [
        ]
      },
      {
        "id" : "1cee8bf2-89da-4b38-a57c-6152775c2242",
        "parentId" : "6df10b87-e068-40bf-baae-5a5f80b57099",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Using nditer would be the way to go for that, but it would add some overhead.\n",
        "createdAt" : "2013-03-02T02:59:00Z",
        "updatedAt" : "2013-08-17T16:30:32Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "4674b9ee89a641f3b9da2296079a6ed2167e1d8c",
    "line" : 18,
    "diffHunk" : "@@ -1,1 +1883,1887 @@    char *pkey = PyArray_DATA(key);\n    npy_intp *pret = (npy_intp *)PyArray_DATA(ret);\n    int elsize = PyArray_DESCR(key)->elsize;\n    npy_intp arrstride = *PyArray_STRIDES(arr);\n    npy_intp i;"
  },
  {
    "id" : "e263b6f5-4405-4ae4-aa31-75c0dc3d9d6d",
    "prId" : 3107,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "af7eee27-0df3-4496-998c-1f504dbb53c5",
        "parentId" : null,
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "I assume this is the switching logic for cache performance, this needs  in source comment on why its done.\n",
        "createdAt" : "2013-08-16T07:49:08Z",
        "updatedAt" : "2013-08-17T16:30:32Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      }
    ],
    "commit" : "4674b9ee89a641f3b9da2296079a6ed2167e1d8c",
    "line" : null,
    "diffHunk" : "@@ -1,1 +2116,2120 @@     * haystack to a continuous array for improved cache utilization.\n     */\n    if (PyArray_SIZE(ap2) > PyArray_SIZE(op1)) {\n        ap1_flags |= NPY_ARRAY_CARRAY_RO;\n    }"
  },
  {
    "id" : "a7f46543-a117-4c58-bb44-c743bb7c02ee",
    "prId" : 3360,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ccbd94ea-0194-4810-b020-a2bf99b7c9c1",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Someday we've got to get rid of that ugly global.\n",
        "createdAt" : "2013-05-28T01:43:57Z",
        "updatedAt" : "2013-08-12T12:26:07Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "4d9cd695486fa095c6bff3238341a85cbdb47d0e",
    "line" : 345,
    "diffHunk" : "@@ -1,1 +1327,1331 @@        }\n    }\n    global_obj = store_arr;\n\n    if (PyErr_Occurred()) {"
  },
  {
    "id" : "8838b566-ef6d-4400-a0b4-58f220066028",
    "prId" : 3360,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "998042c4-94e7-4857-bcbd-6c2da546bd01",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "This looks like just tossing everything into a bag. It would be nice to have `_new_sort` and `_new_partition` (or equivalent) as separate functions, then perhaps factor out the common bit. Eventually the `_new` stuff should probably go away. That whole section of code needs a fixup.\n",
        "createdAt" : "2013-08-02T23:03:29Z",
        "updatedAt" : "2013-08-12T12:26:07Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "1fc4fc62-9450-4de7-9232-910c351d9209",
        "parentId" : "998042c4-94e7-4857-bcbd-6c2da546bd01",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "The `switch` and `pwitch` don't read that well.\n",
        "createdAt" : "2013-08-02T23:03:56Z",
        "updatedAt" : "2013-08-12T12:26:07Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "986e152e-5559-431d-abe0-9eb54c41234c",
        "parentId" : "998042c4-94e7-4857-bcbd-6c2da546bd01",
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "I didn't see a better way of reusing all the shared code parts besides doing what I did.\nduplicating the whole thing is ugly as all the setup is the same for partition and sort, the only difference is partition has one extra argument.\n",
        "createdAt" : "2013-08-02T23:07:58Z",
        "updatedAt" : "2013-08-12T12:26:07Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      },
      {
        "id" : "830b8b81-4743-4da6-8d93-923dd4b612a8",
        "parentId" : "998042c4-94e7-4857-bcbd-6c2da546bd01",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "This whole section of code was already a mess, so I guess this isn't any worse ;)\n",
        "createdAt" : "2013-08-02T23:35:22Z",
        "updatedAt" : "2013-08-12T12:26:07Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "ef3bd3b1-878e-4354-bd77-f61f8d154db0",
        "parentId" : "998042c4-94e7-4857-bcbd-6c2da546bd01",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "I'd like to combine the _new and old, push the GIL release back down into the functions, and finish getting rid of the globals. All for another day...\n",
        "createdAt" : "2013-08-02T23:36:34Z",
        "updatedAt" : "2013-08-12T12:26:07Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "4d9cd695486fa095c6bff3238341a85cbdb47d0e",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +770,774 @@ */\nstatic int\n_new_sortlike(PyArrayObject *op, int axis,\n              NPY_SORTKIND swhich,\n              PyArray_PartitionFunc * part,"
  },
  {
    "id" : "ae9a222d-2a72-4b73-b453-c8aab1cee594",
    "prId" : 3360,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b89dfc73-46e6-4799-92f2-67533a52c711",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Like the previous comment for `_new_sortlike`.\n",
        "createdAt" : "2013-08-02T23:05:43Z",
        "updatedAt" : "2013-08-12T12:26:07Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "4d9cd695486fa095c6bff3238341a85cbdb47d0e",
    "line" : 96,
    "diffHunk" : "@@ -1,1 +874,878 @@\nstatic PyObject*\n_new_argsortlike(PyArrayObject *op, int axis,\n                 NPY_SORTKIND swhich,\n                 PyArray_ArgPartitionFunc * argpart,"
  },
  {
    "id" : "2b7bc36d-e33c-4bbe-ae12-91d737ce6ec8",
    "prId" : 3360,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "893fc36f-a1c2-480e-8062-f77fd8d709e9",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "There can be negative entries? I assume this is the Python negative indices.\n",
        "createdAt" : "2013-08-02T23:09:21Z",
        "updatedAt" : "2013-08-12T12:26:07Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "a0ff8486-5ea9-4aab-b9a3-bcfa747683b9",
        "parentId" : "893fc36f-a1c2-480e-8062-f77fd8d709e9",
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "yes the kth array is an index array so the indices can be negative which are then wrapped around the axis dimension like other numpy index arrays.\n",
        "createdAt" : "2013-08-02T23:11:49Z",
        "updatedAt" : "2013-08-12T12:26:07Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      }
    ],
    "commit" : "4d9cd695486fa095c6bff3238341a85cbdb47d0e",
    "line" : 205,
    "diffHunk" : "@@ -1,1 +1187,1191 @@\n/*\n * make kth array positive, ravel and sort it\n */\nstatic PyArrayObject *"
  },
  {
    "id" : "0f0eb577-1ee1-4f78-bacb-69d7f051fe34",
    "prId" : 3360,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9a13df52-a132-479e-b8c2-eee4c61fd880",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Might be able to call this directly for `npy_intp`, it is in the sorting library.\n",
        "createdAt" : "2013-08-02T23:13:02Z",
        "updatedAt" : "2013-08-12T12:26:07Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "93f255df-e95b-4f20-8042-e586b1602de1",
        "parentId" : "9a13df52-a132-479e-b8c2-eee4c61fd880",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "nvm, it may be multidimensional.\n",
        "createdAt" : "2013-08-02T23:14:17Z",
        "updatedAt" : "2013-08-12T12:26:07Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "ea1d768e-8aeb-4e0c-b5dd-5d9b1ba78104",
        "parentId" : "9a13df52-a132-479e-b8c2-eee4c61fd880",
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "actually no, it currently must be one dimensional (its raveled earlier)\none could allow multidimensional which would mean partition each axis by a different kth, I'm not sure if thats worth the effort.\n",
        "createdAt" : "2013-08-02T23:21:48Z",
        "updatedAt" : "2013-08-12T12:26:07Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      }
    ],
    "commit" : "4d9cd695486fa095c6bff3238341a85cbdb47d0e",
    "line" : 252,
    "diffHunk" : "@@ -1,1 +1234,1238 @@     * not trample on each other\n     */\n    PyArray_Sort(kthrvl, -1, NPY_QUICKSORT);\n\n    return kthrvl;"
  },
  {
    "id" : "5563ca33-e315-494d-bab9-2ff55855c675",
    "prId" : 3360,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2adb9801-3214-4845-8747-83704e5f90b1",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Maybe `IndexError` ? It goes both ways currently, might be nice to pick one or the other. Thoughts?\n",
        "createdAt" : "2013-08-02T23:16:02Z",
        "updatedAt" : "2013-08-12T12:26:07Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "0e4ab07c-4729-4dde-97cc-196491ada2b1",
        "parentId" : "2adb9801-3214-4845-8747-83704e5f90b1",
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "numpy,sort uses ValueError (thus I used it here as partition is very related)\nufuncs use IndexError so maybe it would be a good idea to change sort and partition to indexerror too\n",
        "createdAt" : "2013-08-12T11:53:59Z",
        "updatedAt" : "2013-08-12T12:26:07Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      }
    ],
    "commit" : "4d9cd695486fa095c6bff3238341a85cbdb47d0e",
    "line" : 282,
    "diffHunk" : "@@ -1,1 +1264,1268 @@    }\n    if ((axis < 0) || (axis >= n)) {\n        PyErr_Format(PyExc_ValueError, \"axis(=%d) out of bounds\", axis_orig);\n        return -1;\n    }"
  },
  {
    "id" : "d751aea8-0bb4-4618-b735-dd5f834fdf23",
    "prId" : 4057,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "edddd04a-9fb3-42a3-9d0b-d735ea7505af",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Even when the cpu can do unaligned accesses, isn't it slower?\n",
        "createdAt" : "2013-11-16T15:38:36Z",
        "updatedAt" : "2013-11-16T15:38:36Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "5329e87f-0b9c-46e6-84d7-01569ae19f1e",
        "parentId" : "edddd04a-9fb3-42a3-9d0b-d735ea7505af",
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "its not very significant for x86 (the only place this macro is currently enabled)\n\n```\nIn [2]: a = np.ones(20000., dtype=np.bool)\n\nIn [3]: %timeit np.count_nonzero(a)\n100000 loops, best of 3: 2.87 µs per loop\n\nIn [4]: %timeit np.count_nonzero(a[1:])\n100000 loops, best of 3: 3.35 µs per loop\n\nvs without this pr\nIn [4]: %timeit np.count_nonzero(a[1:])\n100000 loops, best of 3: 19.4 µs per loop\n```\n",
        "createdAt" : "2013-11-16T17:35:48Z",
        "updatedAt" : "2013-11-16T17:35:48Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      }
    ],
    "commit" : "773c8f3ff8c1ca2377253bc0c003a795a242b596",
    "line" : 37,
    "diffHunk" : "@@ -1,1 +2467,2471 @@            const char *d = data;\n            const char *e = data + shape[0];\n            if (NPY_CPU_HAVE_UNALIGNED_ACCESS ||\n                    npy_is_aligned(d, sizeof(npy_uint64))) {\n                npy_uintp stride = 2 * sizeof(npy_uint64);"
  },
  {
    "id" : "b3483ed4-73e5-4799-a831-db12d19e31b6",
    "prId" : 4244,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "213cd9c1-8bf1-45a3-8c1b-a20112c1e88c",
        "parentId" : null,
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "incref and decref in error case of dtype is missing here, probably causes the debug test failure.\nthis is also a bug in current numpy but not triggered as the old code gets the key stride from the array, it might be better to fix it in master first and then rebase the branch.\n",
        "createdAt" : "2014-02-02T13:40:52Z",
        "updatedAt" : "2014-02-13T08:25:44Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      },
      {
        "id" : "c8697e79-1e35-4bcc-b3aa-73f5db14c55b",
        "parentId" : "213cd9c1-8bf1-45a3-8c1b-a20112c1e88c",
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "actually its no bug in numpy just a subtle optimization, ap1 takes ownership of dtype here.\nso you could do the same by replacing all following `dtype` references with `PyArray_DESCR(ap2)` but this needs to be documented as a comment here.\nthis saves the dtype decref in the success fail path of the function.\n",
        "createdAt" : "2014-02-02T14:28:07Z",
        "updatedAt" : "2014-02-13T08:25:44Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      },
      {
        "id" : "d6e2180b-1b98-4e37-bb75-6c99a73029bf",
        "parentId" : "213cd9c1-8bf1-45a3-8c1b-a20112c1e88c",
        "authorId" : "34105ae0-9fd2-4403-be9b-7c550a729828",
        "body" : "@juliantaylor In the last commit I have littered PyArray_SearchSorted with comments with my reference counts to dtype. I'd appreciate if you could take a look and confirm that I am getting it right this time.\n",
        "createdAt" : "2014-02-07T13:37:43Z",
        "updatedAt" : "2014-02-13T08:25:44Z",
        "lastEditedBy" : "34105ae0-9fd2-4403-be9b-7c550a729828",
        "tags" : [
        ]
      }
    ],
    "commit" : "9350d4dc9cc5a8288c965008c8dd6034c991289a",
    "line" : 259,
    "diffHunk" : "@@ -1,1 +1956,1960 @@        ap1_flags |= NPY_ARRAY_CARRAY_RO;\n    }\n    ap1 = (PyArrayObject *)PyArray_CheckFromAny((PyObject *)op1, dtype,\n                                1, 1, ap1_flags, NULL);\n    /* refs to dtype we own = 0, array creation steals one even on failure */"
  },
  {
    "id" : "97cc7ac2-ef36-4e32-adf4-6478db5e31fc",
    "prId" : 4244,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "cc39c32b-ef8b-4571-938f-d1975311a9da",
        "parentId" : null,
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "As the new code supports strided needles it should be beneficial to drop the contiguous requirement for it.\nCompared to the haystack It does not need to fit well into the cache.\n",
        "createdAt" : "2014-02-02T13:49:29Z",
        "updatedAt" : "2014-02-13T08:25:44Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      },
      {
        "id" : "860ed4ea-abca-4b36-8226-8f7ed6cb617d",
        "parentId" : "cc39c32b-ef8b-4571-938f-d1975311a9da",
        "authorId" : "34105ae0-9fd2-4403-be9b-7c550a729828",
        "body" : "The way searchsorted works right now, and I had made no attempt to change that, is to allow multidimensional needles by making them contiguous and iterating over all axes with the stride set to the element size. So dropping the contiguousness requirement is a little less trivial, and will require setting up an iterator over the needle array, will look into it.\n",
        "createdAt" : "2014-02-02T18:13:15Z",
        "updatedAt" : "2014-02-13T08:25:44Z",
        "lastEditedBy" : "34105ae0-9fd2-4403-be9b-7c550a729828",
        "tags" : [
        ]
      },
      {
        "id" : "502364b3-5e90-41d2-9b69-acbe6aa93b82",
        "parentId" : "cc39c32b-ef8b-4571-938f-d1975311a9da",
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "I don't mean allowing higher dimensional needles, just non-continuous, e.g. needle[::-2]\nyour code already supports that with the key_str parameter.\n",
        "createdAt" : "2014-02-02T20:08:28Z",
        "updatedAt" : "2014-02-13T08:25:44Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      },
      {
        "id" : "4341c05f-64e5-40ad-a3dd-297e2d7761c3",
        "parentId" : "cc39c32b-ef8b-4571-938f-d1975311a9da",
        "authorId" : "34105ae0-9fd2-4403-be9b-7c550a729828",
        "body" : "The thing is higher dimensional needles are already supported:\n\n```\n>>> np.__version__\n'1.8.0'\n>>> a = np.arange(5)\n>>> b = [[1, 2], [3, 4]]\n>>> a.searchsorted(b)\narray([[1, 2],\n       [3, 4]], dtype=int64)\n```\n\nAndthe way it is implemented, this feature requires that the needle be contiguous.\n",
        "createdAt" : "2014-02-07T13:41:51Z",
        "updatedAt" : "2014-02-13T08:25:44Z",
        "lastEditedBy" : "34105ae0-9fd2-4403-be9b-7c550a729828",
        "tags" : [
        ]
      },
      {
        "id" : "49350b96-5c53-4a22-95e5-46cd013a0505",
        "parentId" : "cc39c32b-ef8b-4571-938f-d1975311a9da",
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "can you point me to where the requirement for continuous needle comes in?\nbut regardless this change (if possible) can be done in a separate PR\n",
        "createdAt" : "2014-02-07T17:54:45Z",
        "updatedAt" : "2014-02-13T08:25:44Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      }
    ],
    "commit" : "9350d4dc9cc5a8288c965008c8dd6034c991289a",
    "line" : null,
    "diffHunk" : "@@ -1,1 +1934,1938 @@    }\n\n    /* need ap2 as contiguous array and of right type */\n    /* refs to dtype we own = 1 */\n    Py_INCREF(dtype);"
  },
  {
    "id" : "4dced71b-8b10-4777-97c7-36bf61e4a156",
    "prId" : 4244,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "79286ab0-f5dc-4f67-96ae-b7e24a6fe3aa",
        "parentId" : null,
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "dtype decref missing\n",
        "createdAt" : "2014-02-02T14:01:22Z",
        "updatedAt" : "2014-02-13T08:25:44Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      }
    ],
    "commit" : "9350d4dc9cc5a8288c965008c8dd6034c991289a",
    "line" : null,
    "diffHunk" : "@@ -1,1 +1931,1935 @@        Py_DECREF(dtype);\n        /* refs to dtype we own = 0 */\n        return NULL;\n    }\n"
  },
  {
    "id" : "450b6820-fb3d-47a0-a0ee-2eceb5ef999e",
    "prId" : 4244,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0646cbe9-a6a3-4772-81a2-e408879d7366",
        "parentId" : null,
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "dtype decref missing in fail and success return paths\n",
        "createdAt" : "2014-02-02T14:04:38Z",
        "updatedAt" : "2014-02-13T08:25:44Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      }
    ],
    "commit" : "9350d4dc9cc5a8288c965008c8dd6034c991289a",
    "line" : null,
    "diffHunk" : "@@ -1,1 +2031,2035 @@                        \"Sorter index out of range.\");\n            goto fail;\n        }\n        Py_DECREF(ap3);\n        Py_DECREF(sorter);"
  },
  {
    "id" : "b5cb013c-0f2c-4b34-bf27-8dc0398a2678",
    "prId" : 4475,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ad8d4f48-cb6e-4156-a441-10a717be3f2f",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Looks like this would fit on one line.\n",
        "createdAt" : "2014-03-11T22:38:31Z",
        "updatedAt" : "2014-03-11T22:38:31Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "a177efcd-9e07-492e-ab55-766b7e4f8a2e",
        "parentId" : "ad8d4f48-cb6e-4156-a441-10a717be3f2f",
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "no I tried :(\n",
        "createdAt" : "2014-03-11T22:41:57Z",
        "updatedAt" : "2014-03-11T22:41:57Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      }
    ],
    "commit" : "7add97bcee029ae5269532c33b9531ebf26f89c5",
    "line" : 12,
    "diffHunk" : "@@ -1,1 +137,141 @@                for (j = 0; j < m; j++) {\n                    tmp = ((npy_intp *)(PyArray_DATA(indices)))[j];\n                    if (check_and_adjust_index(&tmp, max_item, axis,\n                                               _save) < 0) {\n                        goto fail;"
  },
  {
    "id" : "0f383545-f3c5-4c6d-8364-a32d94c23210",
    "prId" : 4708,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "58ec1ba8-5d4b-4972-ba80-ed753440fd2b",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Longer term, it looks like the function signature could be simplified to just take `ap1`, `ap2`, `sorter`, and `ret`, with the function itself pulling out the relevant data from those. It's a bit more code repetition, but I think a simple interface may be the better tradeoff. \n",
        "createdAt" : "2014-05-14T14:32:39Z",
        "updatedAt" : "2014-05-14T14:32:39Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "76760cffa9381697e2eb60a32f12d993628beec4",
    "line" : 2,
    "diffHunk" : "@@ -1,1 +2029,2033 @@        int error = 0;\n        NPY_BEGIN_THREADS_DESCR(PyArray_DESCR(ap2));\n        error = argbinsearch((const char *)PyArray_DATA(ap1),\n                             (const char *)PyArray_DATA(ap2),\n                             (const char *)PyArray_DATA(sorter),"
  },
  {
    "id" : "84f51f55-4740-4128-9bce-65b43d4e8b47",
    "prId" : 5458,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7c0b8482-6a04-481b-b754-e9b7b6e926fd",
        "parentId" : null,
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "this block is the same as in sortlike, could be moved into a small function\n",
        "createdAt" : "2015-01-20T19:47:32Z",
        "updatedAt" : "2015-01-22T01:16:36Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      },
      {
        "id" : "39a428fe-c0e1-4f23-bcf3-999bfe1f4628",
        "parentId" : "7c0b8482-6a04-481b-b754-e9b7b6e926fd",
        "authorId" : "34105ae0-9fd2-4403-be9b-7c550a729828",
        "body" : "I thought of it, but it would be a function with 9 or 10 parameters, unless we want to extract `hasrefs`, `copyswapn`, `elsize` and `swap` from `op` in each iteration.\n",
        "createdAt" : "2015-01-21T04:24:11Z",
        "updatedAt" : "2015-01-22T01:16:36Z",
        "lastEditedBy" : "34105ae0-9fd2-4403-be9b-7c550a729828",
        "tags" : [
        ]
      },
      {
        "id" : "867c9ce2-6438-4b15-acea-a083d936bf26",
        "parentId" : "7c0b8482-6a04-481b-b754-e9b7b6e926fd",
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "hm right probably too many arguments for little code saved\n",
        "createdAt" : "2015-01-21T18:13:12Z",
        "updatedAt" : "2015-01-22T01:16:36Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      }
    ],
    "commit" : "3937a87660fa12ce283d8a711056339a7093cd18",
    "line" : 345,
    "diffHunk" : "@@ -1,1 +1003,1007 @@                /* ...then swap in-place if needed */\n                if (swap) {\n                    copyswapn(valbuffer, elsize, NULL, 0, N, swap, op);\n                }\n            }"
  },
  {
    "id" : "a2048f6b-0d80-43f7-af00-dd60560530cb",
    "prId" : 5501,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e50ad7d7-a046-4655-9d49-51b24c65bd40",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Could just increment `src` and `dest` by `chunk` each time around, resetting `src`along with `j`. That would make a difference for dense masks, although there are a other bits in the loop that might take time.  Not needed for this PR, though. \n",
        "createdAt" : "2015-02-24T21:24:29Z",
        "updatedAt" : "2015-02-24T21:24:29Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "fc8db7395f51311e4856eaae25c4b3aa62bd9164",
    "line" : 41,
    "diffHunk" : "@@ -1,1 +494,498 @@            }\n            if (mask_data[i]) {\n                char *src_ptr = src + j*chunk;\n                char *dest_ptr = dest + i*chunk;\n"
  },
  {
    "id" : "a9a3dfb0-f426-476c-afdd-36067fc5168a",
    "prId" : 6312,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "790eba27-13b4-45f9-a7e6-aa1c76a2a77c",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Should this be `||`?\n",
        "createdAt" : "2015-09-14T13:36:21Z",
        "updatedAt" : "2015-10-02T12:07:18Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "fa3227aa-7053-4329-adf8-9c3e9d96757f",
        "parentId" : "790eba27-13b4-45f9-a7e6-aa1c76a2a77c",
        "authorId" : "34105ae0-9fd2-4403-be9b-7c550a729828",
        "body" : "It could be `!(a || b)`, which of course is the same as the current `!a && !b`.\n",
        "createdAt" : "2015-09-14T14:05:36Z",
        "updatedAt" : "2015-10-02T12:07:18Z",
        "lastEditedBy" : "34105ae0-9fd2-4403-be9b-7c550a729828",
        "tags" : [
        ]
      }
    ],
    "commit" : "0862e89fb51b2e6fc2dfe74e6166a218b67ff06d",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +1429,1433 @@        }\n        if (!PyArray_DESCR(mps[i])->f->argsort[NPY_MERGESORT]\n                && !PyArray_DESCR(mps[i])->f->compare) {\n            PyErr_Format(PyExc_TypeError,\n                         \"item %zd type does not have compare function\", i);"
  },
  {
    "id" : "03fcfc7b-2b67-4966-a8d9-4a5d1a1bbd70",
    "prId" : 9300,
    "prUrl" : "https://github.com/numpy/numpy/pull/9300#pullrequestreview-47534537",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4974dac9-487a-4129-bc47-bb66b6fa6b16",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Might be tempted to use `npy_bool`",
        "createdAt" : "2017-07-01T15:43:03Z",
        "updatedAt" : "2017-09-14T04:00:49Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "c3096d59-e2bf-41a8-bfca-54a42aeb1e39",
        "parentId" : "4974dac9-487a-4129-bc47-bb66b6fa6b16",
        "authorId" : "a4f03a99-2e43-482b-a9bc-5a9e359abb03",
        "body" : "It appears to traditionally be `int` in numpy, according to grep. So I'll leave it.",
        "createdAt" : "2017-07-01T18:15:37Z",
        "updatedAt" : "2017-09-14T04:00:49Z",
        "lastEditedBy" : "a4f03a99-2e43-482b-a9bc-5a9e359abb03",
        "tags" : [
        ]
      }
    ],
    "commit" : "8d4942bd6a682d0c6a86c503c6af0c08a5333adb",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +2069,2073 @@    npy_intp stride, count;\n    npy_intp nonzero_count = 0;\n    int needs_api = 0;\n    PyArray_Descr *dtype;\n"
  },
  {
    "id" : "92a71467-77d8-4de7-97b1-d2d377442460",
    "prId" : 9300,
    "prUrl" : "https://github.com/numpy/numpy/pull/9300#pullrequestreview-60088987",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6863ee3c-7666-4901-87a7-767c6c1958f4",
        "parentId" : null,
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "orthogonal to the issue, but this loop could release the GIL if `needs_api` is false, probably best via `NPY_BEGIN_THREADS_THRESHOLDED`",
        "createdAt" : "2017-09-01T09:39:29Z",
        "updatedAt" : "2017-09-14T04:00:49Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      }
    ],
    "commit" : "8d4942bd6a682d0c6a86c503c6af0c08a5333adb",
    "line" : 24,
    "diffHunk" : "@@ -1,1 +2088,2092 @@    /* If it's a trivial one-dimensional loop, don't use an iterator */\n    if (PyArray_TRIVIALLY_ITERABLE(self)) {\n        needs_api = PyDataType_FLAGCHK(dtype, NPY_NEEDS_PYAPI);\n        PyArray_PREPARE_TRIVIAL_ITERATION(self, count, data, stride);\n"
  },
  {
    "id" : "aa692a7c-ad41-46f2-b09a-180e3febbef4",
    "prId" : 13182,
    "prUrl" : "https://github.com/numpy/numpy/pull/13182#pullrequestreview-218080766",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "751c0956-748b-4064-b992-d417f09eae7d",
        "parentId" : null,
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "NIT: Extra empty line.",
        "createdAt" : "2019-03-24T13:01:31Z",
        "updatedAt" : "2019-03-24T17:58:02Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      }
    ],
    "commit" : "a9d3ee9ddf900891c8c39932833b25beb74def5a",
    "line" : 146,
    "diffHunk" : "@@ -1,1 +726,730 @@            goto fail;\n        }\n\n        for (i = 0; i < n; i++) {\n            if (arrays_overlap(out, mps[i])) {"
  },
  {
    "id" : "b4346b5f-7a8a-4ec8-804a-b9d09599e166",
    "prId" : 13860,
    "prUrl" : "https://github.com/numpy/numpy/pull/13860#pullrequestreview-256025997",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d7e61c31-087c-4c84-9c56-38856294b7c7",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Oops, this was recent.",
        "createdAt" : "2019-06-29T06:06:25Z",
        "updatedAt" : "2019-07-03T00:53:55Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "9decdd56-8c81-401f-9ab7-41da60682a36",
        "parentId" : "d7e61c31-087c-4c84-9c56-38856294b7c7",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "I could split off the commit to merge quicker and make sure it is in 1.17.",
        "createdAt" : "2019-06-29T06:09:57Z",
        "updatedAt" : "2019-07-03T00:53:55Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "c0068d51-3c4a-4103-ac78-9575f90a4b5f",
        "parentId" : "d7e61c31-087c-4c84-9c56-38856294b7c7",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Probably not a big deal, this path is unlikely to ever be hit anyway (hence my attempt to deprecate it)",
        "createdAt" : "2019-06-29T06:19:34Z",
        "updatedAt" : "2019-07-03T00:53:55Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "b18b76f6d00c7b710753d0a35fc490beb1cbd643",
    "line" : 15,
    "diffHunk" : "@@ -1,1 +2247,2251 @@        ret_tuple = PyArray_Nonzero(self_1d);\n        Py_DECREF(self_1d);\n        return ret_tuple;\n    }\n"
  },
  {
    "id" : "a5b7ad11-a4c0-418f-9935-f1a1dcda62b0",
    "prId" : 14240,
    "prUrl" : "https://github.com/numpy/numpy/pull/14240#pullrequestreview-273188426",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ce94f4ea-f128-416e-a296-376d97e3e896",
        "parentId" : null,
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "I wonder if we should just add `valbufsize = maxelsize * N` here and set that to 1 if it happens to be 0. That probably reads a bit easier?",
        "createdAt" : "2019-08-09T14:58:02Z",
        "updatedAt" : "2019-08-22T17:00:03Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      }
    ],
    "commit" : "a062d0716c1c659f4d7ddd5a7c91d78438b5b822",
    "line" : 25,
    "diffHunk" : "@@ -1,1 +1518,1522 @@        char *valbuffer, *indbuffer;\n        int *swaps;\n\n        assert(N > 0);  /* Guaranteed and assumed by indbuffer */\n        int valbufsize = N * maxelsize;"
  },
  {
    "id" : "db52a5aa-8c8a-44de-becb-881b0a38e4c3",
    "prId" : 14942,
    "prUrl" : "https://github.com/numpy/numpy/pull/14942#pullrequestreview-320459698",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fb4c5472-6404-4ca4-995e-7cf31eb00d64",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Elsewhere I've seen we have an `-O3` annotation for gcc. If we don't compile at that level by default, can we use that annotation here?",
        "createdAt" : "2019-11-20T17:55:15Z",
        "updatedAt" : "2020-01-16T00:31:56Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "24d54ee6-f52e-4a51-81f0-fa2ba742da05",
        "parentId" : "fb4c5472-6404-4ca4-995e-7cf31eb00d64",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "I had to put the attribute on the `npy_fasttake` function and not on the `_impl` one (or maybe the NPY_INLINE has to have a different order (come first). But I think it broke the inlinening first. In any case that works now. The slowdown with complex256 is still there (no idea...), but the general PutMask slowdown is much less/gone and some things got quite a bit faster.",
        "createdAt" : "2019-11-20T23:00:10Z",
        "updatedAt" : "2020-01-16T00:31:56Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "b9fdaf86-96da-41b5-beca-a4238499ebb0",
        "parentId" : "fb4c5472-6404-4ca4-995e-7cf31eb00d64",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "(the timings in the above comment are updated.)",
        "createdAt" : "2019-11-20T23:00:29Z",
        "updatedAt" : "2020-01-16T00:31:56Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      }
    ],
    "commit" : "68e8d47e68a45ed1ce2fd2870e78265f051a2ceb",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +31,35 @@\nstatic NPY_GCC_OPT_3 NPY_INLINE int\nnpy_fasttake_impl(\n        char *dest, char *src, const npy_intp *indices,\n        npy_intp n, npy_intp m, npy_intp max_item,"
  }
]
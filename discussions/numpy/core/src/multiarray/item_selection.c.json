[
  {
    "id" : "1c655ae0-2f56-431a-92f3-1fd87bd823d6",
    "prId" : 2974,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "cf05042b-0800-4ec6-94b6-ce4febc064ed",
        "parentId" : null,
        "authorId" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "body" : "If `PyErr_Occurred` is true, after a BEGIN_THREADS section, then doesn't that imply that someone violated the GIL usage rules? How could a PyErr be created if the GIL was dropped?\n",
        "createdAt" : "2013-02-10T21:40:36Z",
        "updatedAt" : "2013-02-10T21:40:36Z",
        "lastEditedBy" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "tags" : [
        ]
      },
      {
        "id" : "243aeb34-8a01-421a-80d7-c2aa13b34b41",
        "parentId" : "cf05042b-0800-4ec6-94b6-ce4febc064ed",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "there is a goto fail before `NPY_BEGIN_THREADS_DESCR(PyArray_DESCR(op));`. Could special case that, but in LexSort there are a few of them.\n",
        "createdAt" : "2013-02-10T21:49:35Z",
        "updatedAt" : "2013-02-10T21:49:35Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      }
    ],
    "commit" : "2b76da387ef4c8a0317c80ce08e5bbab833b14e5",
    "line" : 56,
    "diffHunk" : "@@ -1,1 +891,895 @@ fail:\n    NPY_END_THREADS;\n    if (!PyErr_Occurred()) {\n        /* Out of memory during sorting or buffer creation */\n        PyErr_NoMemory();"
  },
  {
    "id" : "85ab5222-fb3a-4225-8bb3-aecb9bfee3fc",
    "prId" : 2974,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "db71399e-b663-49a9-930a-6272c4849e9e",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "OK.\n",
        "createdAt" : "2013-02-11T02:20:08Z",
        "updatedAt" : "2013-02-11T02:20:08Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "2b76da387ef4c8a0317c80ce08e5bbab833b14e5",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +751,755 @@    if (needcopy) {\n        char *buffer = PyDataMem_NEW(N*elsize);\n        if (buffer == NULL) {\n            goto fail;\n        }"
  },
  {
    "id" : "2200907a-cac5-4366-b928-2d48fd666ed1",
    "prId" : 2974,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "aecee6ba-f27b-45df-8c06-86c7753d6995",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "I wonder if this should be `NPY_END_THREADS_DESCR(PyArray_DESCR(op))` since the threads were started based on dtype. It could also be moved up to before the fail gotos if that would make the code more readable, not sure about that though.\n",
        "createdAt" : "2013-02-11T02:29:18Z",
        "updatedAt" : "2013-02-11T02:29:18Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "2b76da387ef4c8a0317c80ce08e5bbab833b14e5",
    "line" : 15,
    "diffHunk" : "@@ -1,1 +788,792 @@ fail:\n    /* Out of memory during sorting or buffer creation */\n    NPY_END_THREADS;\n    PyErr_NoMemory();\n    Py_DECREF(it);"
  },
  {
    "id" : "54d3f01f-c94b-418c-b6cc-9d1a1186721a",
    "prId" : 2974,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1dce1513-a7f0-4c92-b89a-e6c357bc63d2",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Maybe we should return the actual error from the sort call.\n",
        "createdAt" : "2013-02-11T02:29:47Z",
        "updatedAt" : "2013-02-11T02:29:47Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "afab8e79-83e3-4897-93ca-5b139d0d3cce",
        "parentId" : "1dce1513-a7f0-4c92-b89a-e6c357bc63d2",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Nah, doesn't look worth the trouble.\n",
        "createdAt" : "2013-02-11T02:36:54Z",
        "updatedAt" : "2013-02-11T02:36:54Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "2b76da387ef4c8a0317c80ce08e5bbab833b14e5",
    "line" : 19,
    "diffHunk" : "@@ -1,1 +791,795 @@    PyErr_NoMemory();\n    Py_DECREF(it);\n    return -1;\n}\n"
  },
  {
    "id" : "58fea242-7c63-47b7-a7c4-2a731a2be57d",
    "prId" : 3002,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9b76ecb4-61fa-4a5a-8ce0-f75ff6ad09a7",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Are these object pointers that are being moved, or larger items?\n",
        "createdAt" : "2013-02-23T15:58:35Z",
        "updatedAt" : "2013-02-25T00:02:02Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "0e9f83cb-fd02-482b-a977-96ecc012f22b",
        "parentId" : "9b76ecb4-61fa-4a5a-8ce0-f75ff6ad09a7",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Those could be larger items in structured types.\n",
        "createdAt" : "2013-02-23T16:07:53Z",
        "updatedAt" : "2013-02-25T00:02:02Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      }
    ],
    "commit" : "230ee3aa201552a8a9fa13c4b319f68cbd504d85",
    "line" : 45,
    "diffHunk" : "@@ -1,1 +140,144 @@                            PyArray_Item_INCREF(tmp_src, PyArray_DESCR(self));\n                            PyArray_Item_XDECREF(dest, PyArray_DESCR(self));\n                            memmove(dest, tmp_src, itemsize);\n                            dest += itemsize;\n                            tmp_src += itemsize;"
  },
  {
    "id" : "ff65f087-da7f-4395-b56d-691deab24d2f",
    "prId" : 3107,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6df10b87-e068-40bf-baae-5a5f80b57099",
        "parentId" : null,
        "authorId" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "body" : "What's the reason for this change?\n",
        "createdAt" : "2013-03-01T23:13:24Z",
        "updatedAt" : "2013-08-17T16:30:32Z",
        "lastEditedBy" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "tags" : [
        ]
      },
      {
        "id" : "7cecb3e0-6dfc-4797-933a-4ee120faa35c",
        "parentId" : "6df10b87-e068-40bf-baae-5a5f80b57099",
        "authorId" : "b79858b9-0a74-4264-b47d-5aebe44f2140",
        "body" : "Mostly for clarity. After these changes, elsize is only used to increment the pkey pointer. So I figured just to be consistent I should look up elsize from the key array (even though both arrays should be of the same type).\n",
        "createdAt" : "2013-03-01T23:20:32Z",
        "updatedAt" : "2013-08-17T16:30:32Z",
        "lastEditedBy" : "b79858b9-0a74-4264-b47d-5aebe44f2140",
        "tags" : [
        ]
      },
      {
        "id" : "b5a20dd1-528d-4b98-a143-d0387afde1ad",
        "parentId" : "6df10b87-e068-40bf-baae-5a5f80b57099",
        "authorId" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "body" : "Oh, we still assume that the `key` array is contiguous? Is there a reason for that, then? :-)\n",
        "createdAt" : "2013-03-01T23:26:08Z",
        "updatedAt" : "2013-08-17T16:30:32Z",
        "lastEditedBy" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "tags" : [
        ]
      },
      {
        "id" : "26eadd85-7ef1-4052-b324-a1d7154dc1a5",
        "parentId" : "6df10b87-e068-40bf-baae-5a5f80b57099",
        "authorId" : "b79858b9-0a74-4264-b47d-5aebe44f2140",
        "body" : "Two reasons. First my naivete, because the key array could have any shape and any strides I didn't know if there was an easy way to handle that in this context.\n\nThe second is that it didn't seem to me that copying the key array was as big of a problem. searchsorted is linear in the size of the key array so making a temporary copy is a relatively small constant multiplier to the run time. Because searchsorted is log(N) in the size of the array being search, making a linear time copy of that array can dominate the run time for large arrays. \n",
        "createdAt" : "2013-03-01T23:35:06Z",
        "updatedAt" : "2013-08-17T16:30:32Z",
        "lastEditedBy" : "b79858b9-0a74-4264-b47d-5aebe44f2140",
        "tags" : [
        ]
      },
      {
        "id" : "2e661cae-5076-4c51-9dd7-adce65a6d737",
        "parentId" : "6df10b87-e068-40bf-baae-5a5f80b57099",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Can use `PyArray_ITEMSIZE` to get `elsize`.\n",
        "createdAt" : "2013-03-02T00:50:22Z",
        "updatedAt" : "2013-08-17T16:30:32Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "1a43252e-6a9b-4b73-b74e-9d0e31831d2a",
        "parentId" : "6df10b87-e068-40bf-baae-5a5f80b57099",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Heh, and I usually have big arrays of keys and small arrays to look them up in. But in general I agree that the lookup times will dominate the key retrieval time.\n",
        "createdAt" : "2013-03-02T01:38:33Z",
        "updatedAt" : "2013-08-17T16:30:32Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "fb38b6e2-2621-42db-8ee5-58c4600ea7d2",
        "parentId" : "6df10b87-e068-40bf-baae-5a5f80b57099",
        "authorId" : "b79858b9-0a74-4264-b47d-5aebe44f2140",
        "body" : "Is there a way to step through an array with arbitrary strides that I could\nuse here for the key array? We could at least stop copying read only\narrays, as @njsmith noted NPY_ARRAY_DEFAULT checks for weight only arrays.\nI could include that in this pull request.\nOn Mar 1, 2013 5:38 PM, \"Charles Harris\" notifications@github.com wrote:\n\n> In numpy/core/src/multiarray/item_selection.c:\n> \n> > @@ -1505,15 +1505,22 @@\n> >      char *parr = PyArray_DATA(arr);\n> >      char *pkey = PyArray_DATA(key);\n> >      npy_intp *pret = (npy_intp *)PyArray_DATA(ret);\n> > -    int elsize = PyArray_DESCR(arr)->elsize;\n> > -    int elsize = PyArray_DESCR(key)->elsize;\n> \n> Heh, and I usually have big arrays of keys and small arrays to look them\n> up in. But in general I agree that the lookup times will dominate the key\n> retrieval time.\n> \n> â€”\n> Reply to this email directly or view it on GitHubhttps://github.com/numpy/numpy/pull/3107/files#r3213822\n> .\n",
        "createdAt" : "2013-03-02T02:10:37Z",
        "updatedAt" : "2013-08-17T16:30:32Z",
        "lastEditedBy" : "b79858b9-0a74-4264-b47d-5aebe44f2140",
        "tags" : [
        ]
      },
      {
        "id" : "1cee8bf2-89da-4b38-a57c-6152775c2242",
        "parentId" : "6df10b87-e068-40bf-baae-5a5f80b57099",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Using nditer would be the way to go for that, but it would add some overhead.\n",
        "createdAt" : "2013-03-02T02:59:00Z",
        "updatedAt" : "2013-08-17T16:30:32Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "4674b9ee89a641f3b9da2296079a6ed2167e1d8c",
    "line" : 18,
    "diffHunk" : "@@ -1,1 +1883,1887 @@    char *pkey = PyArray_DATA(key);\n    npy_intp *pret = (npy_intp *)PyArray_DATA(ret);\n    int elsize = PyArray_DESCR(key)->elsize;\n    npy_intp arrstride = *PyArray_STRIDES(arr);\n    npy_intp i;"
  },
  {
    "id" : "e263b6f5-4405-4ae4-aa31-75c0dc3d9d6d",
    "prId" : 3107,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "af7eee27-0df3-4496-998c-1f504dbb53c5",
        "parentId" : null,
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "I assume this is the switching logic for cache performance, this needs  in source comment on why its done.\n",
        "createdAt" : "2013-08-16T07:49:08Z",
        "updatedAt" : "2013-08-17T16:30:32Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      }
    ],
    "commit" : "4674b9ee89a641f3b9da2296079a6ed2167e1d8c",
    "line" : null,
    "diffHunk" : "@@ -1,1 +2116,2120 @@     * haystack to a continuous array for improved cache utilization.\n     */\n    if (PyArray_SIZE(ap2) > PyArray_SIZE(op1)) {\n        ap1_flags |= NPY_ARRAY_CARRAY_RO;\n    }"
  },
  {
    "id" : "a7f46543-a117-4c58-bb44-c743bb7c02ee",
    "prId" : 3360,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ccbd94ea-0194-4810-b020-a2bf99b7c9c1",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Someday we've got to get rid of that ugly global.\n",
        "createdAt" : "2013-05-28T01:43:57Z",
        "updatedAt" : "2013-08-12T12:26:07Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "4d9cd695486fa095c6bff3238341a85cbdb47d0e",
    "line" : 345,
    "diffHunk" : "@@ -1,1 +1327,1331 @@        }\n    }\n    global_obj = store_arr;\n\n    if (PyErr_Occurred()) {"
  },
  {
    "id" : "8838b566-ef6d-4400-a0b4-58f220066028",
    "prId" : 3360,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "998042c4-94e7-4857-bcbd-6c2da546bd01",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "This looks like just tossing everything into a bag. It would be nice to have `_new_sort` and `_new_partition` (or equivalent) as separate functions, then perhaps factor out the common bit. Eventually the `_new` stuff should probably go away. That whole section of code needs a fixup.\n",
        "createdAt" : "2013-08-02T23:03:29Z",
        "updatedAt" : "2013-08-12T12:26:07Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "1fc4fc62-9450-4de7-9232-910c351d9209",
        "parentId" : "998042c4-94e7-4857-bcbd-6c2da546bd01",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "The `switch` and `pwitch` don't read that well.\n",
        "createdAt" : "2013-08-02T23:03:56Z",
        "updatedAt" : "2013-08-12T12:26:07Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "986e152e-5559-431d-abe0-9eb54c41234c",
        "parentId" : "998042c4-94e7-4857-bcbd-6c2da546bd01",
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "I didn't see a better way of reusing all the shared code parts besides doing what I did.\nduplicating the whole thing is ugly as all the setup is the same for partition and sort, the only difference is partition has one extra argument.\n",
        "createdAt" : "2013-08-02T23:07:58Z",
        "updatedAt" : "2013-08-12T12:26:07Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      },
      {
        "id" : "830b8b81-4743-4da6-8d93-923dd4b612a8",
        "parentId" : "998042c4-94e7-4857-bcbd-6c2da546bd01",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "This whole section of code was already a mess, so I guess this isn't any worse ;)\n",
        "createdAt" : "2013-08-02T23:35:22Z",
        "updatedAt" : "2013-08-12T12:26:07Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "ef3bd3b1-878e-4354-bd77-f61f8d154db0",
        "parentId" : "998042c4-94e7-4857-bcbd-6c2da546bd01",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "I'd like to combine the _new and old, push the GIL release back down into the functions, and finish getting rid of the globals. All for another day...\n",
        "createdAt" : "2013-08-02T23:36:34Z",
        "updatedAt" : "2013-08-12T12:26:07Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "4d9cd695486fa095c6bff3238341a85cbdb47d0e",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +770,774 @@ */\nstatic int\n_new_sortlike(PyArrayObject *op, int axis,\n              NPY_SORTKIND swhich,\n              PyArray_PartitionFunc * part,"
  },
  {
    "id" : "ae9a222d-2a72-4b73-b453-c8aab1cee594",
    "prId" : 3360,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b89dfc73-46e6-4799-92f2-67533a52c711",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Like the previous comment for `_new_sortlike`.\n",
        "createdAt" : "2013-08-02T23:05:43Z",
        "updatedAt" : "2013-08-12T12:26:07Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "4d9cd695486fa095c6bff3238341a85cbdb47d0e",
    "line" : 96,
    "diffHunk" : "@@ -1,1 +874,878 @@\nstatic PyObject*\n_new_argsortlike(PyArrayObject *op, int axis,\n                 NPY_SORTKIND swhich,\n                 PyArray_ArgPartitionFunc * argpart,"
  },
  {
    "id" : "2b7bc36d-e33c-4bbe-ae12-91d737ce6ec8",
    "prId" : 3360,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "893fc36f-a1c2-480e-8062-f77fd8d709e9",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "There can be negative entries? I assume this is the Python negative indices.\n",
        "createdAt" : "2013-08-02T23:09:21Z",
        "updatedAt" : "2013-08-12T12:26:07Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "a0ff8486-5ea9-4aab-b9a3-bcfa747683b9",
        "parentId" : "893fc36f-a1c2-480e-8062-f77fd8d709e9",
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "yes the kth array is an index array so the indices can be negative which are then wrapped around the axis dimension like other numpy index arrays.\n",
        "createdAt" : "2013-08-02T23:11:49Z",
        "updatedAt" : "2013-08-12T12:26:07Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      }
    ],
    "commit" : "4d9cd695486fa095c6bff3238341a85cbdb47d0e",
    "line" : 205,
    "diffHunk" : "@@ -1,1 +1187,1191 @@\n/*\n * make kth array positive, ravel and sort it\n */\nstatic PyArrayObject *"
  },
  {
    "id" : "0f0eb577-1ee1-4f78-bacb-69d7f051fe34",
    "prId" : 3360,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9a13df52-a132-479e-b8c2-eee4c61fd880",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Might be able to call this directly for `npy_intp`, it is in the sorting library.\n",
        "createdAt" : "2013-08-02T23:13:02Z",
        "updatedAt" : "2013-08-12T12:26:07Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "93f255df-e95b-4f20-8042-e586b1602de1",
        "parentId" : "9a13df52-a132-479e-b8c2-eee4c61fd880",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "nvm, it may be multidimensional.\n",
        "createdAt" : "2013-08-02T23:14:17Z",
        "updatedAt" : "2013-08-12T12:26:07Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "ea1d768e-8aeb-4e0c-b5dd-5d9b1ba78104",
        "parentId" : "9a13df52-a132-479e-b8c2-eee4c61fd880",
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "actually no, it currently must be one dimensional (its raveled earlier)\none could allow multidimensional which would mean partition each axis by a different kth, I'm not sure if thats worth the effort.\n",
        "createdAt" : "2013-08-02T23:21:48Z",
        "updatedAt" : "2013-08-12T12:26:07Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      }
    ],
    "commit" : "4d9cd695486fa095c6bff3238341a85cbdb47d0e",
    "line" : 252,
    "diffHunk" : "@@ -1,1 +1234,1238 @@     * not trample on each other\n     */\n    PyArray_Sort(kthrvl, -1, NPY_QUICKSORT);\n\n    return kthrvl;"
  },
  {
    "id" : "5563ca33-e315-494d-bab9-2ff55855c675",
    "prId" : 3360,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2adb9801-3214-4845-8747-83704e5f90b1",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Maybe `IndexError` ? It goes both ways currently, might be nice to pick one or the other. Thoughts?\n",
        "createdAt" : "2013-08-02T23:16:02Z",
        "updatedAt" : "2013-08-12T12:26:07Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "0e4ab07c-4729-4dde-97cc-196491ada2b1",
        "parentId" : "2adb9801-3214-4845-8747-83704e5f90b1",
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "numpy,sort uses ValueError (thus I used it here as partition is very related)\nufuncs use IndexError so maybe it would be a good idea to change sort and partition to indexerror too\n",
        "createdAt" : "2013-08-12T11:53:59Z",
        "updatedAt" : "2013-08-12T12:26:07Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      }
    ],
    "commit" : "4d9cd695486fa095c6bff3238341a85cbdb47d0e",
    "line" : 282,
    "diffHunk" : "@@ -1,1 +1264,1268 @@    }\n    if ((axis < 0) || (axis >= n)) {\n        PyErr_Format(PyExc_ValueError, \"axis(=%d) out of bounds\", axis_orig);\n        return -1;\n    }"
  }
]
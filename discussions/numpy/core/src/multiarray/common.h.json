[
  {
    "id" : "be550248-6da1-49cb-87ba-592dd26c3a16",
    "prId" : 3594,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ab3562f3-89ea-424c-af38-12bca1532ff2",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Cute. Another version: `(a & -a) == a`, but neither work for 0. Does 0 need to be checked for?\n",
        "createdAt" : "2013-08-10T01:58:27Z",
        "updatedAt" : "2013-08-10T01:58:27Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "e87bef88-7488-43ad-87b6-8d0935ea3875",
        "parentId" : "ab3562f3-89ea-424c-af38-12bca1532ff2",
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "0 does not make any sense as an alignment, the smallest alignment something can have is one unit of memory, which is always true.\nputting in zero will return true too, so it should be fine if someone uses zero instead of one to indicate that alignment doesn't matter.\n",
        "createdAt" : "2013-08-10T15:19:32Z",
        "updatedAt" : "2013-08-10T15:19:32Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      },
      {
        "id" : "11f014f0-c1a6-4ea8-956e-a3d9c77556f0",
        "parentId" : "ab3562f3-89ea-424c-af38-12bca1532ff2",
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "hm no it won't return true in the & branch, but I still don't think its worth caring about, maybe one can put an assert in there\n",
        "createdAt" : "2013-08-10T15:21:27Z",
        "updatedAt" : "2013-08-10T15:21:27Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      }
    ],
    "commit" : "e91acdb17b2a9c65a0fb9b7a97764aa375819784",
    "line" : 21,
    "diffHunk" : "@@ -1,1 +77,81 @@     * the test is faster than a direct modulo\n     */\n    if (NPY_LIKELY((alignment & (alignment - 1)) == 0)) {\n        return ((npy_uintp)(p) & ((alignment) - 1)) == 0;\n    }"
  },
  {
    "id" : "5a75ae8f-7db8-4199-819d-a0d32d1cfca2",
    "prId" : 3594,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6d0a8195-86a8-4206-bbb2-c76c83c231c4",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Although 0 looks like it will always fail unless p == 0.\n",
        "createdAt" : "2013-08-10T02:02:49Z",
        "updatedAt" : "2013-08-10T02:02:49Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "e91acdb17b2a9c65a0fb9b7a97764aa375819784",
    "line" : 22,
    "diffHunk" : "@@ -1,1 +78,82 @@     */\n    if (NPY_LIKELY((alignment & (alignment - 1)) == 0)) {\n        return ((npy_uintp)(p) & ((alignment) - 1)) == 0;\n    }\n    else {"
  },
  {
    "id" : "26c00838-06bc-4395-81e4-ee56741fee96",
    "prId" : 3820,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f4ef4a22-2eaf-47d7-9077-c6095f750ac7",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "There is already a version of this function floating around somewhere in multiarray, maybe two. It would be good to unify things.\n",
        "createdAt" : "2013-10-14T17:26:48Z",
        "updatedAt" : "2013-10-14T17:26:48Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "d86839b2-7bc1-4911-b8b4-1d31e96210c5",
        "parentId" : "f4ef4a22-2eaf-47d7-9077-c6095f750ac7",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "OK, one implementation is in `ctors.c` line 929. And there is a function somewhere that I can't find at the moment. A grep for 'overflow' turns up other spots where this is a concern, sometimes for addition.\n",
        "createdAt" : "2013-10-14T17:38:40Z",
        "updatedAt" : "2013-10-14T17:38:40Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "f66974bc-a7cd-4bdd-82c6-986b2205e3d5",
        "parentId" : "f4ef4a22-2eaf-47d7-9077-c6095f750ac7",
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "I don't see anything in ctors.c.\nI also checked the grep overflow, saw nothing really similar.\n",
        "createdAt" : "2013-10-14T17:43:30Z",
        "updatedAt" : "2013-10-14T17:43:30Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      },
      {
        "id" : "68a78b4b-2622-486f-9fe6-be98329ed472",
        "parentId" : "f4ef4a22-2eaf-47d7-9077-c6095f750ac7",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "There is `PyArray_OverflowMultiplyList` which complements `PyArray_MultiplyList`. Hmm, that's a bit of work to unify all these treatments. But problems due to overflow do turn up now and then, maybe there should be a `safe_arithmetic.c` file somewhere with common routines.\n",
        "createdAt" : "2013-10-14T17:48:54Z",
        "updatedAt" : "2013-10-14T17:48:54Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "3c4ef15b-e535-493e-9458-f3ee17f5b8b5",
        "parentId" : "f4ef4a22-2eaf-47d7-9077-c6095f750ac7",
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "this PR already uses it for PyArray_OverflowMultiplyList\n",
        "createdAt" : "2013-10-14T17:52:15Z",
        "updatedAt" : "2013-10-14T17:52:15Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      },
      {
        "id" : "a3368b59-bf19-445a-a9fa-8842452af066",
        "parentId" : "f4ef4a22-2eaf-47d7-9077-c6095f750ac7",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "OK, that's one down ;) There are different work arounds here and there that are probably not identical to this but could maybe use it.\n",
        "createdAt" : "2013-10-14T17:57:16Z",
        "updatedAt" : "2013-10-14T17:57:16Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "51dafb38-8786-46d4-bf9a-52b5dfc9ce35",
        "parentId" : "f4ef4a22-2eaf-47d7-9077-c6095f750ac7",
        "authorId" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "body" : "Away from computer, but, I think scalarmath may have another.\nOn 14 Oct 2013 18:59, \"Charles Harris\" notifications@github.com wrote:\n\n> In numpy/core/src/multiarray/common.h:\n> \n> > @@ -84,6 +84,29 @@\n> >      }\n> >  }\n> > \n> > +/*\n> > - \\* writes result of a \\* b into r\n> > - \\* returns 1 if a \\* b overflowed else returns 0\n> > - */\n> >   +static NPY_INLINE int\n> >   +npy_mul_with_overflow_intp(npy_intp \\* r, npy_intp a, npy_intp b)\n> \n> OK, that's one down ;) There are different work arounds here and there\n> that are probably not identical to this but could maybe use it.\n> \n> â€”\n> Reply to this email directly or view it on GitHubhttps://github.com/numpy/numpy/pull/3820/files#r6950656\n> .\n",
        "createdAt" : "2013-10-14T18:28:42Z",
        "updatedAt" : "2013-10-14T18:28:42Z",
        "lastEditedBy" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "tags" : [
        ]
      },
      {
        "id" : "1ec936ee-d2f4-44f8-8c00-28e6aff3e4c3",
        "parentId" : "f4ef4a22-2eaf-47d7-9077-c6095f750ac7",
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "right, I'll have a look if it can use the same function.\n",
        "createdAt" : "2013-10-14T18:36:44Z",
        "updatedAt" : "2013-10-14T18:36:44Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      },
      {
        "id" : "15d5ba30-8013-4817-9c4e-5a727b285d6b",
        "parentId" : "f4ef4a22-2eaf-47d7-9077-c6095f750ac7",
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "interestingly that code is never used, it checks for #if NPY_SIZEOF_LONGLONG == 64\nwhich is always false as the size is 8 :/\n",
        "createdAt" : "2013-10-14T18:46:00Z",
        "updatedAt" : "2013-10-14T18:46:00Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      },
      {
        "id" : "62e2d95f-2cdf-4933-835b-a82248f6ab4a",
        "parentId" : "f4ef4a22-2eaf-47d7-9077-c6095f750ac7",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Heh.\n",
        "createdAt" : "2013-10-14T19:03:55Z",
        "updatedAt" : "2013-10-14T19:03:55Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "19d344bfd4c0b348e6c978a6c90a1da4372d8f82",
    "line" : 9,
    "diffHunk" : "@@ -1,1 +90,94 @@ */\nstatic NPY_INLINE int\nnpy_mul_with_overflow_intp(npy_intp * r, npy_intp a, npy_intp b)\n{\n    const npy_intp half_sz = (((npy_intp)1 << (sizeof(a) * 8 / 2)) - 1);"
  },
  {
    "id" : "87108175-76d8-4f77-9e59-1d9c5001b151",
    "prId" : 3931,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "27a37928-076a-4ee1-bf88-aff222292677",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Seems a bit large for inline ;) I assume this is so you can use it in both umath and multiarray?\n",
        "createdAt" : "2013-10-16T22:08:46Z",
        "updatedAt" : "2013-10-16T23:02:07Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "43484b4e-0ad0-4e34-a481-fb8b6c460ead",
        "parentId" : "27a37928-076a-4ee1-bf88-aff222292677",
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "its so the compiler can remove the constants (like invert and stride) out of the loops.\npossibly there would not be much impact if we duplicate it for invert and make it non inlineable, but I prefer to let the compiler take that decision.\n",
        "createdAt" : "2013-10-16T22:44:37Z",
        "updatedAt" : "2013-10-16T23:02:07Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      }
    ],
    "commit" : "7d4ea165817fc613c79bb92ccb3844df94d1beed",
    "line" : 19,
    "diffHunk" : "@@ -1,1 +93,97 @@ * is not found.\n */\nstatic NPY_INLINE char *\nnpy_memchr(char * haystack, char needle,\n           npy_intp stride, npy_intp size, npy_intp * subloopsize, int invert)"
  },
  {
    "id" : "3f5257be-f763-409d-b596-efa5abba9ef8",
    "prId" : 8584,
    "prUrl" : "https://github.com/numpy/numpy/pull/8584#pullrequestreview-20839214",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0593e82b-6288-4b41-8b5a-e6046e158921",
        "parentId" : null,
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "`adjust` seems to imply something always happens; how about `check_and_normalize_axis`.  Or just `normalize_axis`?",
        "createdAt" : "2017-02-08T18:58:49Z",
        "updatedAt" : "2017-02-20T22:03:54Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      }
    ],
    "commit" : "8d6ec65c925ebef5e0567708de1d16df39077c9d",
    "line" : 10,
    "diffHunk" : "@@ -1,1 +141,145 @@ */\nstatic NPY_INLINE int\ncheck_and_adjust_axis(int *axis, int ndim)\n{\n    /* Check that index is valid, taking into account negative indices */"
  },
  {
    "id" : "79c54b99-883e-481e-a292-eaea09e06b87",
    "prId" : 8584,
    "prUrl" : "https://github.com/numpy/numpy/pull/8584#pullrequestreview-23380379",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8181ba3f-e980-4b08-a7ae-0a8be39b85ed",
        "parentId" : null,
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "More for my education than anything else, is there a reason not just to `#include <npy_import.h>` at the top?",
        "createdAt" : "2017-02-20T19:14:28Z",
        "updatedAt" : "2017-02-20T22:03:54Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      },
      {
        "id" : "d24117e1-aac2-4e1d-b7ce-aa5614b6a5df",
        "parentId" : "8181ba3f-e980-4b08-a7ae-0a8be39b85ed",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "This is a public header, but I think `npy_import` is private. So when another module includes this header, it can no longer find `npy_import`.\r\n\r\nThat could be fixed by moving this to `common.c`, but I don't know if the inlining would then work",
        "createdAt" : "2017-02-20T19:29:30Z",
        "updatedAt" : "2017-02-20T22:03:54Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "37e8bdad-ed98-41f4-bf52-31d2f512e414",
        "parentId" : "8181ba3f-e980-4b08-a7ae-0a8be39b85ed",
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "Since every problem supposedly is solvable with another layer of redirection, could one call an error-producing function in `common.c` here, where that function raises the error? (But maybe this is very much not worth it...)",
        "createdAt" : "2017-02-20T19:54:59Z",
        "updatedAt" : "2017-02-20T22:03:54Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      },
      {
        "id" : "55a8572d-d225-43ca-8671-1375303667d9",
        "parentId" : "8181ba3f-e980-4b08-a7ae-0a8be39b85ed",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Arguably, the inlining is not important here, as this isn't nearly as critical a path as `check_and_adjust_index`",
        "createdAt" : "2017-02-20T20:19:46Z",
        "updatedAt" : "2017-02-20T22:03:54Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "ff65e277-0a6c-419d-acf3-dc30222900b6",
        "parentId" : "8181ba3f-e980-4b08-a7ae-0a8be39b85ed",
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "OK, how about then moving it to `common.c`? Somewhat nicer anyway to have c code reside in `*.c` files...",
        "createdAt" : "2017-02-21T16:37:41Z",
        "updatedAt" : "2017-02-21T16:37:41Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      },
      {
        "id" : "36f22fc3-ebbb-42c3-aa13-819296fb75bc",
        "parentId" : "8181ba3f-e980-4b08-a7ae-0a8be39b85ed",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Main argument for leaving it here is it gives clear contrast with `check_and_adjust_index`",
        "createdAt" : "2017-02-21T17:02:54Z",
        "updatedAt" : "2017-02-21T17:02:54Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "53e5fef5-f3e7-487b-9831-116aa2d009ec",
        "parentId" : "8181ba3f-e980-4b08-a7ae-0a8be39b85ed",
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "True; fine to keep as is too even if it duplicates a bit of code.",
        "createdAt" : "2017-02-21T17:17:49Z",
        "updatedAt" : "2017-02-21T17:17:49Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      },
      {
        "id" : "2061c442-3134-4f88-a604-40f127c4eb44",
        "parentId" : "8181ba3f-e980-4b08-a7ae-0a8be39b85ed",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "@eric-wieser did you try to include `npy_import.h`? It should work. Private here means private to numpy. The files therein should be available to everything in `numpy/core/src`.",
        "createdAt" : "2017-02-23T01:00:39Z",
        "updatedAt" : "2017-02-23T01:00:40Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "2e146330-b071-4861-892c-2b9f8b0ca822",
        "parentId" : "8181ba3f-e980-4b08-a7ae-0a8be39b85ed",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "I think the problem is that something outside numpy/core/src tries to include \"common.h\", which then doesn't have access to npy_include. I remember it not building, but I forget the exact error.",
        "createdAt" : "2017-02-23T01:04:13Z",
        "updatedAt" : "2017-02-23T01:04:13Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "1808c9cc-f441-40ac-9d84-3c10e280bf2c",
        "parentId" : "8181ba3f-e980-4b08-a7ae-0a8be39b85ed",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "And just to be clear, the \"public\" headers are in `numpy/core/include/numpy`. ",
        "createdAt" : "2017-02-23T01:34:25Z",
        "updatedAt" : "2017-02-23T01:34:25Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "8d6ec65c925ebef5e0567708de1d16df39077c9d",
    "line" : 16,
    "diffHunk" : "@@ -1,1 +147,151 @@        /*\n         * Load the exception type, if we don't already have it. Unfortunately\n         * we don't have access to npy_cache_import here\n         */\n        static PyObject *AxisError_cls = NULL;"
  },
  {
    "id" : "90a5fe0a-dab0-4b8a-a4ae-33d06b00c53f",
    "prId" : 8843,
    "prUrl" : "https://github.com/numpy/numpy/pull/8843#pullrequestreview-29564208",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "14f2b379-c1e5-42ec-af7e-2fec4fcff1ae",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "This was the way I should have written this the first time...",
        "createdAt" : "2017-03-28T20:23:01Z",
        "updatedAt" : "2017-03-28T21:23:31Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "17466ad1839718c091c629bb647e881b7922a148",
    "line" : 31,
    "diffHunk" : "@@ -1,1 +165,169 @@        /* Invoke the AxisError constructor */\n        exc = PyObject_CallFunction(AxisError_cls, \"iiO\",\n                                    *axis, ndim, msg_prefix);\n        if (exc == NULL) {\n            return -1;"
  },
  {
    "id" : "b8b39d7c-d2f5-4275-9c37-fe1fd98be176",
    "prId" : 8843,
    "prUrl" : "https://github.com/numpy/numpy/pull/8843#pullrequestreview-29582130",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b343ba20-54ea-4539-b01f-bf4614995e1c",
        "parentId" : null,
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "I think you have to `Py_INCREF(Py_None)` before passing it on. Since you then would have to `Py_DECREF` it as well, I suggest passing in `NULL` here, and doing the translation to `Py_None` above.",
        "createdAt" : "2017-03-28T20:37:55Z",
        "updatedAt" : "2017-03-28T21:23:31Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      },
      {
        "id" : "1ebf9ffa-6aee-4e8f-8043-873c3a07d87f",
        "parentId" : "b343ba20-54ea-4539-b01f-bf4614995e1c",
        "authorId" : "4b0602db-f9ac-4b54-b200-2e79d0cfb7c3",
        "body" : "`Py_None` is garantueed to exist and as long as it doesn't escape to the user and it isn't decref'd everything should be fine. `PyObject_CallFunction` increments it's reference count for the exception so what the user gets is a new reference.\r\n\r\nUsing `NULL` seems cleaner though.",
        "createdAt" : "2017-03-28T20:45:56Z",
        "updatedAt" : "2017-03-28T21:23:31Z",
        "lastEditedBy" : "4b0602db-f9ac-4b54-b200-2e79d0cfb7c3",
        "tags" : [
        ]
      },
      {
        "id" : "559f3665-ff04-4260-a530-4513dd03babb",
        "parentId" : "b343ba20-54ea-4539-b01f-bf4614995e1c",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "I don't need to here, because `check_and_adjust_axis_msg` takes a borrowed reference. It doesn't actually need a refcount at all until it makes it to the python code, and `PyObject_CallFunction()` increments the refcount for me, AFAICT.\r\n\r\nIt took a lot of iteration to get this working, and attempts at doing what you describe only caused segfaults",
        "createdAt" : "2017-03-28T20:46:23Z",
        "updatedAt" : "2017-03-28T21:23:31Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "08a9ef9f-3c87-469d-933a-bfa2af9a5da5",
        "parentId" : "b343ba20-54ea-4539-b01f-bf4614995e1c",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "> Using NULL seems cleaner though.\r\n\r\nWhy? We already need to handle `Py_None` being passed in from user code. Furthermore, when we get `Py_None` from usercode, it's a borrowed reference - so like here, it doesn't need an incref unless it escapes to python code.\r\n\r\nThe only thing that's unclear to me is whether I need to `INCREF` `msg_prefix` on the line immediately before `PyObject_CallFunction`. I think the answer is no, (it was no when I used Py_Buildvalue here previously), but that's not clear from the documentation",
        "createdAt" : "2017-03-28T20:53:59Z",
        "updatedAt" : "2017-03-28T21:23:31Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "349bae04-cfa1-4331-8cac-32c6e55431ac",
        "parentId" : "b343ba20-54ea-4539-b01f-bf4614995e1c",
        "authorId" : "4b0602db-f9ac-4b54-b200-2e79d0cfb7c3",
        "body" : "@eric-wieser How would it cause segfaults? You could just initialize it as `NULL` and when you call the \"exception\" you do `PyObject_CallFunction(AxisError_cls, \"iiO\", *axis, ndim, msg_prefix?msg_prefix:Py_None);`",
        "createdAt" : "2017-03-28T20:55:30Z",
        "updatedAt" : "2017-03-28T21:23:31Z",
        "lastEditedBy" : "4b0602db-f9ac-4b54-b200-2e79d0cfb7c3",
        "tags" : [
        ]
      },
      {
        "id" : "112b492e-b3ed-401f-acbf-5eeab62c3d04",
        "parentId" : "b343ba20-54ea-4539-b01f-bf4614995e1c",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Wait, why on earth is `msg_prefix?msg_prefix:Py_None` better than just passing `Py_None` in the first place? The refcounting is identical",
        "createdAt" : "2017-03-28T20:58:50Z",
        "updatedAt" : "2017-03-28T21:23:31Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "aa5e76f4-91b2-4284-bccc-1ec5d21b5b59",
        "parentId" : "b343ba20-54ea-4539-b01f-bf4614995e1c",
        "authorId" : "4b0602db-f9ac-4b54-b200-2e79d0cfb7c3",
        "body" : "That was meant as question to your\r\n\r\n> It took a lot of iteration to get this working, and attempts at doing what you describe only caused segfaults\r\n\r\nI just wondered how that could segfault.",
        "createdAt" : "2017-03-28T21:06:03Z",
        "updatedAt" : "2017-03-28T21:23:31Z",
        "lastEditedBy" : "4b0602db-f9ac-4b54-b200-2e79d0cfb7c3",
        "tags" : [
        ]
      },
      {
        "id" : "c3f5458d-1d9d-4bd8-9f9b-90e346a01db8",
        "parentId" : "b343ba20-54ea-4539-b01f-bf4614995e1c",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Segfaults came from other attempts at refcounting. I wasn't aiming to be passing null originally. Sorry if that was unclear. You're correct, what you have would add support for passing null, and would work correctly assuming that this works correctly - but I see no purpose in adding that as a special case\r\n",
        "createdAt" : "2017-03-28T21:07:40Z",
        "updatedAt" : "2017-03-28T21:23:31Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "30c499ac-0b61-4105-9c48-8c6d65bd9d36",
        "parentId" : "b343ba20-54ea-4539-b01f-bf4614995e1c",
        "authorId" : "4b0602db-f9ac-4b54-b200-2e79d0cfb7c3",
        "body" : "Yeah, that's the reason why it's generally not a good idea to pass borrowed references around. But I didn't check the numpy source code, maybe it's common here. In that case please ignore my comments.",
        "createdAt" : "2017-03-28T21:09:08Z",
        "updatedAt" : "2017-03-28T21:23:31Z",
        "lastEditedBy" : "4b0602db-f9ac-4b54-b200-2e79d0cfb7c3",
        "tags" : [
        ]
      },
      {
        "id" : "eaeb2cb1-036e-4111-8f11-f55c04d386ea",
        "parentId" : "b343ba20-54ea-4539-b01f-bf4614995e1c",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "I guess my argument would be that if I manually inlined the contents of `check_and_adjust_axis_msg` into `normalize_axis_index`, you would not expect me to add any additional `Py_INCREF`s\r\n\r\nI'm not sure what you mean there - can you elaborate on exactly why it is a bad idea? (and perhaps link me to some recommendations for working with python refcounting)\r\n\r\nCounter-point to it generally not being a good idea - every function in a `PyMethodDef` object is passed borrowed references - so python seems to favor it internally.",
        "createdAt" : "2017-03-28T21:12:52Z",
        "updatedAt" : "2017-03-28T21:23:31Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "bb02d533-40a6-49bf-bb57-8b883cca6f4e",
        "parentId" : "b343ba20-54ea-4539-b01f-bf4614995e1c",
        "authorId" : "4b0602db-f9ac-4b54-b200-2e79d0cfb7c3",
        "body" : "ok, this goes a bit off-topic. I [still think](https://github.com/numpy/numpy/pull/8843#discussion_r108532657) the code is correct wrt reference counting.",
        "createdAt" : "2017-03-28T21:35:40Z",
        "updatedAt" : "2017-03-28T21:35:40Z",
        "lastEditedBy" : "4b0602db-f9ac-4b54-b200-2e79d0cfb7c3",
        "tags" : [
        ]
      },
      {
        "id" : "a1cfeb4e-7fa1-47dc-9035-9ad148988d79",
        "parentId" : "b343ba20-54ea-4539-b01f-bf4614995e1c",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Some confusion added here by my first comment being written before yours appeared (and not directed at you), I think :).",
        "createdAt" : "2017-03-28T21:39:34Z",
        "updatedAt" : "2017-03-28T21:39:34Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "17466ad1839718c091c629bb647e881b7922a148",
    "line" : 48,
    "diffHunk" : "@@ -1,1 +183,187 @@check_and_adjust_axis(int *axis, int ndim)\n{\n    return check_and_adjust_axis_msg(axis, ndim, Py_None);\n}\n"
  },
  {
    "id" : "442f6ba6-f7e5-48b6-b29c-fec167d8ced9",
    "prId" : 15069,
    "prUrl" : "https://github.com/numpy/numpy/pull/15069#pullrequestreview-471426994",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "499da4ea-9635-4049-ab99-51b2e738d6e8",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "xref gh-17111, the return type here is `int`, but we're comparing against the bounds for `int64`",
        "createdAt" : "2020-08-20T09:39:09Z",
        "updatedAt" : "2020-08-20T09:39:09Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "85447b1ed7df98aff0ed9d666a92f8714f08c2ee",
    "line" : 9,
    "diffHunk" : "@@ -1,1 +309,313 @@        if (stride <= NPY_MAX_INT64) {\n#endif\n            return stride;\n        }\n    }"
  }
]
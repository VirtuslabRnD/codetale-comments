[
  {
    "id" : "be550248-6da1-49cb-87ba-592dd26c3a16",
    "prId" : 3594,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ab3562f3-89ea-424c-af38-12bca1532ff2",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Cute. Another version: `(a & -a) == a`, but neither work for 0. Does 0 need to be checked for?\n",
        "createdAt" : "2013-08-10T01:58:27Z",
        "updatedAt" : "2013-08-10T01:58:27Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "e87bef88-7488-43ad-87b6-8d0935ea3875",
        "parentId" : "ab3562f3-89ea-424c-af38-12bca1532ff2",
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "0 does not make any sense as an alignment, the smallest alignment something can have is one unit of memory, which is always true.\nputting in zero will return true too, so it should be fine if someone uses zero instead of one to indicate that alignment doesn't matter.\n",
        "createdAt" : "2013-08-10T15:19:32Z",
        "updatedAt" : "2013-08-10T15:19:32Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      },
      {
        "id" : "11f014f0-c1a6-4ea8-956e-a3d9c77556f0",
        "parentId" : "ab3562f3-89ea-424c-af38-12bca1532ff2",
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "hm no it won't return true in the & branch, but I still don't think its worth caring about, maybe one can put an assert in there\n",
        "createdAt" : "2013-08-10T15:21:27Z",
        "updatedAt" : "2013-08-10T15:21:27Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      }
    ],
    "commit" : "e91acdb17b2a9c65a0fb9b7a97764aa375819784",
    "line" : 21,
    "diffHunk" : "@@ -1,1 +77,81 @@     * the test is faster than a direct modulo\n     */\n    if (NPY_LIKELY((alignment & (alignment - 1)) == 0)) {\n        return ((npy_uintp)(p) & ((alignment) - 1)) == 0;\n    }"
  },
  {
    "id" : "5a75ae8f-7db8-4199-819d-a0d32d1cfca2",
    "prId" : 3594,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6d0a8195-86a8-4206-bbb2-c76c83c231c4",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Although 0 looks like it will always fail unless p == 0.\n",
        "createdAt" : "2013-08-10T02:02:49Z",
        "updatedAt" : "2013-08-10T02:02:49Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "e91acdb17b2a9c65a0fb9b7a97764aa375819784",
    "line" : 22,
    "diffHunk" : "@@ -1,1 +78,82 @@     */\n    if (NPY_LIKELY((alignment & (alignment - 1)) == 0)) {\n        return ((npy_uintp)(p) & ((alignment) - 1)) == 0;\n    }\n    else {"
  },
  {
    "id" : "26c00838-06bc-4395-81e4-ee56741fee96",
    "prId" : 3820,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f4ef4a22-2eaf-47d7-9077-c6095f750ac7",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "There is already a version of this function floating around somewhere in multiarray, maybe two. It would be good to unify things.\n",
        "createdAt" : "2013-10-14T17:26:48Z",
        "updatedAt" : "2013-10-14T17:26:48Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "d86839b2-7bc1-4911-b8b4-1d31e96210c5",
        "parentId" : "f4ef4a22-2eaf-47d7-9077-c6095f750ac7",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "OK, one implementation is in `ctors.c` line 929. And there is a function somewhere that I can't find at the moment. A grep for 'overflow' turns up other spots where this is a concern, sometimes for addition.\n",
        "createdAt" : "2013-10-14T17:38:40Z",
        "updatedAt" : "2013-10-14T17:38:40Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "f66974bc-a7cd-4bdd-82c6-986b2205e3d5",
        "parentId" : "f4ef4a22-2eaf-47d7-9077-c6095f750ac7",
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "I don't see anything in ctors.c.\nI also checked the grep overflow, saw nothing really similar.\n",
        "createdAt" : "2013-10-14T17:43:30Z",
        "updatedAt" : "2013-10-14T17:43:30Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      },
      {
        "id" : "68a78b4b-2622-486f-9fe6-be98329ed472",
        "parentId" : "f4ef4a22-2eaf-47d7-9077-c6095f750ac7",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "There is `PyArray_OverflowMultiplyList` which complements `PyArray_MultiplyList`. Hmm, that's a bit of work to unify all these treatments. But problems due to overflow do turn up now and then, maybe there should be a `safe_arithmetic.c` file somewhere with common routines.\n",
        "createdAt" : "2013-10-14T17:48:54Z",
        "updatedAt" : "2013-10-14T17:48:54Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "3c4ef15b-e535-493e-9458-f3ee17f5b8b5",
        "parentId" : "f4ef4a22-2eaf-47d7-9077-c6095f750ac7",
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "this PR already uses it for PyArray_OverflowMultiplyList\n",
        "createdAt" : "2013-10-14T17:52:15Z",
        "updatedAt" : "2013-10-14T17:52:15Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      },
      {
        "id" : "a3368b59-bf19-445a-a9fa-8842452af066",
        "parentId" : "f4ef4a22-2eaf-47d7-9077-c6095f750ac7",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "OK, that's one down ;) There are different work arounds here and there that are probably not identical to this but could maybe use it.\n",
        "createdAt" : "2013-10-14T17:57:16Z",
        "updatedAt" : "2013-10-14T17:57:16Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "51dafb38-8786-46d4-bf9a-52b5dfc9ce35",
        "parentId" : "f4ef4a22-2eaf-47d7-9077-c6095f750ac7",
        "authorId" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "body" : "Away from computer, but, I think scalarmath may have another.\nOn 14 Oct 2013 18:59, \"Charles Harris\" notifications@github.com wrote:\n\n> In numpy/core/src/multiarray/common.h:\n> \n> > @@ -84,6 +84,29 @@\n> >      }\n> >  }\n> > \n> > +/*\n> > - \\* writes result of a \\* b into r\n> > - \\* returns 1 if a \\* b overflowed else returns 0\n> > - */\n> >   +static NPY_INLINE int\n> >   +npy_mul_with_overflow_intp(npy_intp \\* r, npy_intp a, npy_intp b)\n> \n> OK, that's one down ;) There are different work arounds here and there\n> that are probably not identical to this but could maybe use it.\n> \n> â€”\n> Reply to this email directly or view it on GitHubhttps://github.com/numpy/numpy/pull/3820/files#r6950656\n> .\n",
        "createdAt" : "2013-10-14T18:28:42Z",
        "updatedAt" : "2013-10-14T18:28:42Z",
        "lastEditedBy" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "tags" : [
        ]
      },
      {
        "id" : "1ec936ee-d2f4-44f8-8c00-28e6aff3e4c3",
        "parentId" : "f4ef4a22-2eaf-47d7-9077-c6095f750ac7",
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "right, I'll have a look if it can use the same function.\n",
        "createdAt" : "2013-10-14T18:36:44Z",
        "updatedAt" : "2013-10-14T18:36:44Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      },
      {
        "id" : "15d5ba30-8013-4817-9c4e-5a727b285d6b",
        "parentId" : "f4ef4a22-2eaf-47d7-9077-c6095f750ac7",
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "interestingly that code is never used, it checks for #if NPY_SIZEOF_LONGLONG == 64\nwhich is always false as the size is 8 :/\n",
        "createdAt" : "2013-10-14T18:46:00Z",
        "updatedAt" : "2013-10-14T18:46:00Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      },
      {
        "id" : "62e2d95f-2cdf-4933-835b-a82248f6ab4a",
        "parentId" : "f4ef4a22-2eaf-47d7-9077-c6095f750ac7",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Heh.\n",
        "createdAt" : "2013-10-14T19:03:55Z",
        "updatedAt" : "2013-10-14T19:03:55Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "19d344bfd4c0b348e6c978a6c90a1da4372d8f82",
    "line" : 9,
    "diffHunk" : "@@ -1,1 +90,94 @@ */\nstatic NPY_INLINE int\nnpy_mul_with_overflow_intp(npy_intp * r, npy_intp a, npy_intp b)\n{\n    const npy_intp half_sz = (((npy_intp)1 << (sizeof(a) * 8 / 2)) - 1);"
  }
]
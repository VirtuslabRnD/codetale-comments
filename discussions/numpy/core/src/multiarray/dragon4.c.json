[
  {
    "id" : "6b12a85f-e157-4d67-9ab9-dd546cd29acf",
    "prId" : 9966,
    "prUrl" : "https://github.com/numpy/numpy/pull/9966#pullrequestreview-74327064",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3f4eae27-8d49-4fcd-8cbe-1f12615a4992",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Can you add a comment explaining the purpose of `cutoffNumber >= 0`? the only comment i can see in this diff about `cutoffNumber == -1` is a deletion!",
        "createdAt" : "2017-11-06T06:26:18Z",
        "updatedAt" : "2017-11-06T19:29:42Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "719afcc7ae0d8fdc883011715fe392ed400e182b",
    "line" : 80,
    "diffHunk" : "@@ -1,1 +1171,1175 @@     * accurate value or it will clamp it above the accurate value.\n     */\n    if (cutoffNumber >= 0 && cutoffMode == CutoffMode_FractionLength &&\n            digitExponent <= -cutoffNumber) {\n        digitExponent = -cutoffNumber + 1;"
  },
  {
    "id" : "03dd2285-b162-403c-9a5f-95151d3f657e",
    "prId" : 11167,
    "prUrl" : "https://github.com/numpy/numpy/pull/11167#pullrequestreview-125707522",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "be058b7e-6ff8-4f7b-9642-cf80b0a4c038",
        "parentId" : null,
        "authorId" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "body" : "I admit to not liking multiline macros, they are terribly difficult to debug. Could this be rewritten using the existing NumPy `repeat ` syntax?\r\n\r\nEdit: typo",
        "createdAt" : "2018-06-04T18:30:54Z",
        "updatedAt" : "2018-06-05T21:50:51Z",
        "lastEditedBy" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "tags" : [
        ]
      },
      {
        "id" : "9277bcea-522e-4002-aa38-a6a35df592b2",
        "parentId" : "be058b7e-6ff8-4f7b-9642-cf80b0a4c038",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "I think we would normally make this a template for preprocessing. The reason that isn't done here is probably because the code originates elsewhere. May be worth considering breaking some of it out into its own template file.",
        "createdAt" : "2018-06-04T18:42:26Z",
        "updatedAt" : "2018-06-05T21:50:51Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "045063f9-b591-4e73-9afd-9d8b3473c5e2",
        "parentId" : "be058b7e-6ff8-4f7b-9642-cf80b0a4c038",
        "authorId" : "a4f03a99-2e43-482b-a9bc-5a9e359abb03",
        "body" : "Yeah, I considered that, since I don't like the multiline macros much either.\r\n\r\nBut since this is the only place in this file that needs to repeat, I thought it would be overkill to convert the whole file to a `.src` file needing special preprocessing just for this one function. In contrast the other `.src` files use `repeat` extensively throughout the file.",
        "createdAt" : "2018-06-04T18:59:33Z",
        "updatedAt" : "2018-06-05T21:50:51Z",
        "lastEditedBy" : "a4f03a99-2e43-482b-a9bc-5a9e359abb03",
        "tags" : [
        ]
      },
      {
        "id" : "af792525-06bb-427d-a1b7-3f7425e47a1f",
        "parentId" : "be058b7e-6ff8-4f7b-9642-cf80b0a4c038",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Could be part of a later cleanup. It would have the virtue of turning the macros into functions with argument types and make it much easier to understand. Using template files is actually pretty easy.",
        "createdAt" : "2018-06-04T19:18:28Z",
        "updatedAt" : "2018-06-05T21:50:51Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "e8fb557b8f5fb45d3778a2a562a79546d5eedb55",
    "line" : 1642,
    "diffHunk" : "@@ -1,1 +2896,2900 @@\\\n    return Dragon4_Scientific_##Type##_opt(val, &opt);\\\n}\n\n#define make_dragon4_typefuncs(Type, npy_type, format) \\"
  },
  {
    "id" : "f97ef1ae-cfd0-4dec-931e-9a455eb712e7",
    "prId" : 11167,
    "prUrl" : "https://github.com/numpy/numpy/pull/11167#pullrequestreview-125708547",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6be2acab-362b-4ad3-842b-23a23c9e0318",
        "parentId" : null,
        "authorId" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "body" : "Did you test that using this assert (line 39) still passes tests?",
        "createdAt" : "2018-06-04T18:39:26Z",
        "updatedAt" : "2018-06-05T21:50:51Z",
        "lastEditedBy" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "tags" : [
        ]
      },
      {
        "id" : "7ac48eb3-30c8-4edc-9e38-820b3840cf4a",
        "parentId" : "6be2acab-362b-4ad3-842b-23a23c9e0318",
        "authorId" : "a4f03a99-2e43-482b-a9bc-5a9e359abb03",
        "body" : "Good idea, I hadn't actually.\r\n\r\nI just did now and tests pass. (dragon4 related tests, anyway).",
        "createdAt" : "2018-06-04T19:21:05Z",
        "updatedAt" : "2018-06-05T21:50:51Z",
        "lastEditedBy" : "a4f03a99-2e43-482b-a9bc-5a9e359abb03",
        "tags" : [
        ]
      }
    ],
    "commit" : "e8fb557b8f5fb45d3778a2a562a79546d5eedb55",
    "line" : 289,
    "diffHunk" : "@@ -1,1 +1174,1178 @@    npy_bool low, high, roundDown;\n\n    DEBUG_ASSERT(bufferSize > 0);\n\n    /* if the mantissa is zero, the value is zero regardless of the exponent */"
  },
  {
    "id" : "659b6967-16b7-4270-b076-44acbf1a306d",
    "prId" : 11184,
    "prUrl" : "https://github.com/numpy/numpy/pull/11184#pullrequestreview-123862714",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fb3d341d-c611-4686-8d06-311f7ab5c5f6",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "These lines are my own changes, since #11167 removes them completely.\r\n\r\nShould be straightforward to discard these (and all other changes) when rebasing",
        "createdAt" : "2018-05-29T06:40:02Z",
        "updatedAt" : "2018-05-29T06:40:02Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "3d21112d6cc5491b5fea1df8cad9efd7642f0319",
    "line" : 145,
    "diffHunk" : "@@ -1,1 +1456,1460 @@npy_bool   IsNegative_F16(FloatUnion16 *v) { return (v->integer >> 15) != 0; }\nnpy_uint32 GetExponent_F16(FloatUnion16 *v) { return (v->integer >> 10) & bitmask_u32(5);}\nnpy_uint32 GetMantissa_F16(FloatUnion16 *v) { return v->integer & bitmask_u32(10); }\n\n"
  },
  {
    "id" : "0e48d74a-b8d4-4f2b-bfcf-5f21a547fd59",
    "prId" : 11184,
    "prUrl" : "https://github.com/numpy/numpy/pull/11184#pullrequestreview-124134509",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3aebed07-842c-41f9-8078-c724088ae4fe",
        "parentId" : null,
        "authorId" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "body" : "seems more readable to spell this as 0x7",
        "createdAt" : "2018-05-29T19:09:21Z",
        "updatedAt" : "2018-05-29T19:09:21Z",
        "lastEditedBy" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "tags" : [
        ]
      },
      {
        "id" : "9fd06f3d-a3fb-4f8d-8fdd-7379bf09b129",
        "parentId" : "3aebed07-842c-41f9-8078-c724088ae4fe",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Writing it this way makes the code match the comment",
        "createdAt" : "2018-05-29T19:17:58Z",
        "updatedAt" : "2018-05-29T19:17:58Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "3d21112d6cc5491b5fea1df8cad9efd7642f0319",
    "line" : 94,
    "diffHunk" : "@@ -1,1 +667,671 @@     * the first 3 bits\n     */\n    smallExponent = exponent & bitmask_u32(3);\n    BigInt_Set_uint32(curTemp, g_PowerOf10_U32[smallExponent]);\n"
  },
  {
    "id" : "33c6f1cd-23e1-4fcd-a637-b10d326c871f",
    "prId" : 11184,
    "prUrl" : "https://github.com/numpy/numpy/pull/11184#pullrequestreview-124171161",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2859e7f4-8006-4897-9ecd-1488febd89bd",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Mattip: How about I just add a doc comment here?",
        "createdAt" : "2018-05-29T19:19:15Z",
        "updatedAt" : "2018-05-29T19:19:16Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "bd73ddef-0706-481d-999d-be02ad60f925",
        "parentId" : "2859e7f4-8006-4897-9ecd-1488febd89bd",
        "authorId" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "body" : "ok, but still it seems to violate KISS to convert 0x7 into a function call, even if the compiler is smart enough to make it a constant.",
        "createdAt" : "2018-05-29T19:37:46Z",
        "updatedAt" : "2018-05-29T19:37:46Z",
        "lastEditedBy" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "tags" : [
        ]
      },
      {
        "id" : "6ea6af9c-665c-4fb7-80f4-13ed4d0cb70f",
        "parentId" : "2859e7f4-8006-4897-9ecd-1488febd89bd",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "`0x7FFFFF` is more clearly 23 bits as `bitmask_u32(23)` - where do you draw the line? Isn't it better to just be consistent? Perhaps the function just needs a better name? `lower_n_bits`?",
        "createdAt" : "2018-05-29T19:46:40Z",
        "updatedAt" : "2018-05-29T19:46:40Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "fcfb56ba-17c7-418c-b0fe-e5769e5872ee",
        "parentId" : "2859e7f4-8006-4897-9ecd-1488febd89bd",
        "authorId" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "body" : "anything more than 0x7 can IMO be made a call. It is not the name, it is the cognitive load to translate callsomething(n) to 0x7f when parsing the already-very-dense numpy code. I would like to make the code base more accessible to newcomers, all the macros and functions are very off-putting.",
        "createdAt" : "2018-05-29T20:06:46Z",
        "updatedAt" : "2018-05-29T20:06:46Z",
        "lastEditedBy" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "tags" : [
        ]
      },
      {
        "id" : "7c4ed0c9-abbe-4650-8ad1-cef1cd1c292e",
        "parentId" : "2859e7f4-8006-4897-9ecd-1488febd89bd",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "The point is you're not supposed to be translating to `0x7F`, because `0x7F` isn't a useful way to think about it in the first place. Float fields are defined in terms of bit widths and bit offsets, not in terms of hex masks. `x & bitmask(n)` should be read as \"take the first N bits of x\" - if that's not how you're reading it, then perhaps the name needs fixing. Ideally we'd just use bitfields to encode this\r\n\r\n```\r\nstruct ieee_float {\r\n    uint64_t sign: 1;\r\n    uint64_t mantissa: 23;\r\n    uint64_t exponent: 8;\r\n}\r\n```\r\n\r\nThat's not portable though. Using `bitmask` at least allows the numbers 1, 23, and 8 to appear in the source code.",
        "createdAt" : "2018-05-29T20:36:35Z",
        "updatedAt" : "2018-05-29T20:40:19Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "3fc6cdcc-62ba-4d1d-96e6-66341b303881",
        "parentId" : "2859e7f4-8006-4897-9ecd-1488febd89bd",
        "authorId" : "a4f03a99-2e43-482b-a9bc-5a9e359abb03",
        "body" : "Just to jump in, I think `bitmask_u32(3)` is more accessible than `0x7` - the latter doesn't make clear we are trying to select the last 3 bits, and would be inconsistent with the rest of the file.",
        "createdAt" : "2018-05-29T21:01:20Z",
        "updatedAt" : "2018-05-29T21:01:20Z",
        "lastEditedBy" : "a4f03a99-2e43-482b-a9bc-5a9e359abb03",
        "tags" : [
        ]
      }
    ],
    "commit" : "3d21112d6cc5491b5fea1df8cad9efd7642f0319",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +53,57 @@{\n    return ~(~((npy_uint32)0) << n);\n}\n\n/*"
  }
]
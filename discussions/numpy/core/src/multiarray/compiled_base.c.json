[
  {
    "id" : "4943dda2-6aa3-4be3-b0cb-92be8ca2343f",
    "prId" : 5594,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5e485676-95c3-476e-be2b-c0a04cddc2cb",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Hmm, might be better to move this section up before line:513 as the more likely case. Some redundant computations also. Might be possible to make this a loop of some sort. Just sayin' might be worth a second look.\n",
        "createdAt" : "2015-03-09T03:41:00Z",
        "updatedAt" : "2015-03-09T03:41:00Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "6b558e27-b8fb-482d-8a57-142df2ea8a7f",
        "parentId" : "5e485676-95c3-476e-be2b-c0a04cddc2cb",
        "authorId" : "0e6bf86e-4d40-42bd-9fe4-3d493f6e043b",
        "body" : "@charris  I don't understand the comment about \"before line:513\" -- \nThe code between line 513:518 ensures `guess` is in range.\n\nRe: redundancies (I think only access of `arr[guess]`, `arr[guess + 1]` and `arr[guess - 1]`).  I thought this did not warrant making local variables, and to let the compiler optimize this.\n\nThe code between line 532:538 could be removed -- it's probably too machine-dependent, and seems to help only for a limited kind of \"not well-ordered\" data.   Otherwise, it's not likely to do any harm, but that might be faint praise.\n",
        "createdAt" : "2015-03-09T04:09:03Z",
        "updatedAt" : "2015-03-09T04:09:03Z",
        "lastEditedBy" : "0e6bf86e-4d40-42bd-9fe4-3d493f6e043b",
        "tags" : [
        ]
      }
    ],
    "commit" : "eb21e7d5769ba705d02cca196acf8e3e8f15eef3",
    "line" : 47,
    "diffHunk" : "@@ -1,1 +518,522 @@    }\n\n    /* check most likely values: guess, guess + 1, guess - 1 */\n    if ((key > arr[guess]) && (key <= arr[guess + 1])) {\n        return guess;"
  },
  {
    "id" : "ea9b3a9b-b148-47d6-acdc-e632c5fd89c4",
    "prId" : 5594,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "46d2f032-0a27-4693-8f29-3a2cfca9fae8",
        "parentId" : null,
        "authorId" : "34105ae0-9fd2-4403-be9b-7c550a729828",
        "body" : "With `len == 1` or `len == 2` you can go into this branch with `guess == 0` or `guess == 1`, which will leave `guess` pointing outside the array, and cause a segmentation fault in the next few lines.\n\nNot sure what the best solution is. I think the ideal situation would be to special-case anything with `len < 4` (I would suggest a linear search ignoring `guess`), and for the larger arrays make sure in this normalization that `guess >= 1` and `guess <= len - 3`, so that the testing of the three most likely intervals can be done with no extra checking with a couple of nested branches, e.g.:\n\n```\nassert(guess >=1 && guess <= len-3);\n\nif (key > arr[guess]) {\n    if (key <= arr[guess + 1]) {\n        return guess;\n    }\n    else if (key <= arr[guess + 2]) {\n        return guess + 1;\n    }\n    imin = guess + 2;\n}\nelse if (key > arr[guess - 1]) {\n    return guess - 1;\n}\nelse {\n    imax = guess - 1;\n}\n```\n",
        "createdAt" : "2015-03-09T23:44:58Z",
        "updatedAt" : "2015-03-09T23:44:58Z",
        "lastEditedBy" : "34105ae0-9fd2-4403-be9b-7c550a729828",
        "tags" : [
        ]
      },
      {
        "id" : "ab051fdb-f669-4c19-abe9-69317ba9e11f",
        "parentId" : "46d2f032-0a27-4693-8f29-3a2cfca9fae8",
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "nice catch, swapping the if's and making the else if an if should work too, I'll do some testing with avoiding range checks in an followup\n",
        "createdAt" : "2015-03-09T23:49:20Z",
        "updatedAt" : "2015-03-09T23:49:20Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      },
      {
        "id" : "0c00b3b4-7ec4-4376-b6e2-154b8686e663",
        "parentId" : "46d2f032-0a27-4693-8f29-3a2cfca9fae8",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Oops.\n\nI like your solution though, it is more in line with what I was thinking.\n",
        "createdAt" : "2015-03-09T23:50:15Z",
        "updatedAt" : "2015-03-09T23:50:15Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "761b6e1f-28c7-42d2-a03b-e28f48ca8a47",
        "parentId" : "46d2f032-0a27-4693-8f29-3a2cfca9fae8",
        "authorId" : "0e6bf86e-4d40-42bd-9fe4-3d493f6e043b",
        "body" : "Sorry that I hadn't consider very short arrays. I would just put a `if (len > 16){  }` test around the whole set of tests involving the value of guess, and not bother trying to optimize for very small arrays.\n",
        "createdAt" : "2015-03-10T02:34:31Z",
        "updatedAt" : "2015-03-10T02:48:44Z",
        "lastEditedBy" : "0e6bf86e-4d40-42bd-9fe4-3d493f6e043b",
        "tags" : [
        ]
      }
    ],
    "commit" : "eb21e7d5769ba705d02cca196acf8e3e8f15eef3",
    "line" : 44,
    "diffHunk" : "@@ -1,1 +515,519 @@    }\n    else if (guess >= len - 1) {\n        guess = len - 2;\n    }\n"
  }
]
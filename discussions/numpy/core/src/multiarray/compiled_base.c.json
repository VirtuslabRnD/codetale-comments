[
  {
    "id" : "4943dda2-6aa3-4be3-b0cb-92be8ca2343f",
    "prId" : 5594,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5e485676-95c3-476e-be2b-c0a04cddc2cb",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Hmm, might be better to move this section up before line:513 as the more likely case. Some redundant computations also. Might be possible to make this a loop of some sort. Just sayin' might be worth a second look.\n",
        "createdAt" : "2015-03-09T03:41:00Z",
        "updatedAt" : "2015-03-09T03:41:00Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "6b558e27-b8fb-482d-8a57-142df2ea8a7f",
        "parentId" : "5e485676-95c3-476e-be2b-c0a04cddc2cb",
        "authorId" : "0e6bf86e-4d40-42bd-9fe4-3d493f6e043b",
        "body" : "@charris  I don't understand the comment about \"before line:513\" -- \nThe code between line 513:518 ensures `guess` is in range.\n\nRe: redundancies (I think only access of `arr[guess]`, `arr[guess + 1]` and `arr[guess - 1]`).  I thought this did not warrant making local variables, and to let the compiler optimize this.\n\nThe code between line 532:538 could be removed -- it's probably too machine-dependent, and seems to help only for a limited kind of \"not well-ordered\" data.   Otherwise, it's not likely to do any harm, but that might be faint praise.\n",
        "createdAt" : "2015-03-09T04:09:03Z",
        "updatedAt" : "2015-03-09T04:09:03Z",
        "lastEditedBy" : "0e6bf86e-4d40-42bd-9fe4-3d493f6e043b",
        "tags" : [
        ]
      }
    ],
    "commit" : "eb21e7d5769ba705d02cca196acf8e3e8f15eef3",
    "line" : 47,
    "diffHunk" : "@@ -1,1 +518,522 @@    }\n\n    /* check most likely values: guess, guess + 1, guess - 1 */\n    if ((key > arr[guess]) && (key <= arr[guess + 1])) {\n        return guess;"
  },
  {
    "id" : "ea9b3a9b-b148-47d6-acdc-e632c5fd89c4",
    "prId" : 5594,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "46d2f032-0a27-4693-8f29-3a2cfca9fae8",
        "parentId" : null,
        "authorId" : "34105ae0-9fd2-4403-be9b-7c550a729828",
        "body" : "With `len == 1` or `len == 2` you can go into this branch with `guess == 0` or `guess == 1`, which will leave `guess` pointing outside the array, and cause a segmentation fault in the next few lines.\n\nNot sure what the best solution is. I think the ideal situation would be to special-case anything with `len < 4` (I would suggest a linear search ignoring `guess`), and for the larger arrays make sure in this normalization that `guess >= 1` and `guess <= len - 3`, so that the testing of the three most likely intervals can be done with no extra checking with a couple of nested branches, e.g.:\n\n```\nassert(guess >=1 && guess <= len-3);\n\nif (key > arr[guess]) {\n    if (key <= arr[guess + 1]) {\n        return guess;\n    }\n    else if (key <= arr[guess + 2]) {\n        return guess + 1;\n    }\n    imin = guess + 2;\n}\nelse if (key > arr[guess - 1]) {\n    return guess - 1;\n}\nelse {\n    imax = guess - 1;\n}\n```\n",
        "createdAt" : "2015-03-09T23:44:58Z",
        "updatedAt" : "2015-03-09T23:44:58Z",
        "lastEditedBy" : "34105ae0-9fd2-4403-be9b-7c550a729828",
        "tags" : [
        ]
      },
      {
        "id" : "ab051fdb-f669-4c19-abe9-69317ba9e11f",
        "parentId" : "46d2f032-0a27-4693-8f29-3a2cfca9fae8",
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "nice catch, swapping the if's and making the else if an if should work too, I'll do some testing with avoiding range checks in an followup\n",
        "createdAt" : "2015-03-09T23:49:20Z",
        "updatedAt" : "2015-03-09T23:49:20Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      },
      {
        "id" : "0c00b3b4-7ec4-4376-b6e2-154b8686e663",
        "parentId" : "46d2f032-0a27-4693-8f29-3a2cfca9fae8",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Oops.\n\nI like your solution though, it is more in line with what I was thinking.\n",
        "createdAt" : "2015-03-09T23:50:15Z",
        "updatedAt" : "2015-03-09T23:50:15Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "761b6e1f-28c7-42d2-a03b-e28f48ca8a47",
        "parentId" : "46d2f032-0a27-4693-8f29-3a2cfca9fae8",
        "authorId" : "0e6bf86e-4d40-42bd-9fe4-3d493f6e043b",
        "body" : "Sorry that I hadn't consider very short arrays. I would just put a `if (len > 16){  }` test around the whole set of tests involving the value of guess, and not bother trying to optimize for very small arrays.\n",
        "createdAt" : "2015-03-10T02:34:31Z",
        "updatedAt" : "2015-03-10T02:48:44Z",
        "lastEditedBy" : "0e6bf86e-4d40-42bd-9fe4-3d493f6e043b",
        "tags" : [
        ]
      }
    ],
    "commit" : "eb21e7d5769ba705d02cca196acf8e3e8f15eef3",
    "line" : 44,
    "diffHunk" : "@@ -1,1 +515,519 @@    }\n    else if (guess >= len - 1) {\n        guess = len - 2;\n    }\n"
  },
  {
    "id" : "4bc85790-f108-4f4d-9e8c-910cc480810e",
    "prId" : 6872,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a6775e17-2866-4aa1-8d1b-692aa384f793",
        "parentId" : null,
        "authorId" : "a4f03a99-2e43-482b-a9bc-5a9e359abb03",
        "body" : "also, add a blank line here between functions\n",
        "createdAt" : "2016-05-10T22:14:12Z",
        "updatedAt" : "2016-05-12T20:59:08Z",
        "lastEditedBy" : "a4f03a99-2e43-482b-a9bc-5a9e359abb03",
        "tags" : [
        ]
      }
    ],
    "commit" : "6aa21ad951e8334ba3d3ac677390f7afe76cd242",
    "line" : 178,
    "diffHunk" : "@@ -1,1 +839,843 @@    Py_XDECREF(af);\n    return NULL;\n}\n\n/*"
  },
  {
    "id" : "ef5355d3-81d7-41d9-bf7d-d5c54f82c5d8",
    "prId" : 7003,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "567a7699-3d02-4699-813f-46c9639cb184",
        "parentId" : null,
        "authorId" : "34105ae0-9fd2-4403-be9b-7c550a729828",
        "body" : "You could make this check part of the main loop, and spare yourself an extra iteration over mask.  It would be (the main loop) something like:\n\n``` C\nnpy_bool empty_values = 0;\nfor (i = 0; i < ni; i++) {\n    if (mask_data[i]) {\n        if (j >= nv) {\n            if (nv == 0) {\n                empty_values = 1;\n                break;\n            }\n            j = 0\n        }\n        copyswap(dest + i*chunk, src + j*chunk, 0, array);\n        j++;\n    }\n}\nif (empty_values) {\n    PyErr_SetString(PyExc_ValueError,\n                    \"Cannot insert from an empty array!\");\n}\n```\n\nEven if you decide to keep the emptiness check separate, testing for `j >= nv` only when a value is actually needed is probably a good idea.\n",
        "createdAt" : "2016-01-29T06:36:39Z",
        "updatedAt" : "2016-03-15T14:05:10Z",
        "lastEditedBy" : "34105ae0-9fd2-4403-be9b-7c550a729828",
        "tags" : [
        ]
      },
      {
        "id" : "506f4846-c240-4783-8ff8-800c8b2336cd",
        "parentId" : "567a7699-3d02-4699-813f-46c9639cb184",
        "authorId" : "11f18e00-52bd-4b68-b13d-17d0c3237df0",
        "body" : "Agreed.  I moved the `j >= nv` check inside.\n",
        "createdAt" : "2016-01-29T21:32:07Z",
        "updatedAt" : "2016-03-15T14:05:10Z",
        "lastEditedBy" : "11f18e00-52bd-4b68-b13d-17d0c3237df0",
        "tags" : [
        ]
      }
    ],
    "commit" : "9128ed5198cc8544406467a00824e5fe6791f090",
    "line" : 171,
    "diffHunk" : "@@ -1,1 +360,364 @@\n    nv = PyArray_SIZE(values); /* zero if null array */\n    if (nv <= 0) {\n        npy_bool allFalse = 1;\n        i = 0;"
  },
  {
    "id" : "40c2a6da-90a7-476e-bb07-88c184540492",
    "prId" : 8326,
    "prUrl" : "https://github.com/numpy/numpy/pull/8326#pullrequestreview-12786580",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "43ca9741-480b-47e5-ab61-74f87515459f",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "I wonder if it might be faster to use a local buffer and the lookup table, then copy the result to the destination?",
        "createdAt" : "2016-12-05T18:51:18Z",
        "updatedAt" : "2017-01-12T16:26:40Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "6ba060db-3bea-4e95-a0a7-da36f667cfd7",
        "parentId" : "43ca9741-480b-47e5-ab61-74f87515459f",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Or just copy from the table directly with the stride for the output pointer.",
        "createdAt" : "2016-12-05T20:13:54Z",
        "updatedAt" : "2017-01-12T16:26:40Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "962413f4-5543-4d36-9895-73d5d43995e2",
        "parentId" : "43ca9741-480b-47e5-ab61-74f87515459f",
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "I don't think this would be faster, you need a 8 element loop anyway and the original one is pretty fast already.",
        "createdAt" : "2016-12-13T21:46:57Z",
        "updatedAt" : "2017-01-12T16:26:40Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      }
    ],
    "commit" : "f2a47486a4ccaa141ceeb585e24b2be17b359998",
    "line" : 122,
    "diffHunk" : "@@ -1,1 +1773,1777 @@                unsigned char mask = 128;\n\n                for (i = 0; i < 8; i++) {\n                    *outptr = ((mask & (*inptr)) != 0);\n                    outptr += out_stride;"
  },
  {
    "id" : "37d274b9-2cbf-48e1-96a2-8d2388726c01",
    "prId" : 8348,
    "prUrl" : "https://github.com/numpy/numpy/pull/8348#pullrequestreview-29037020",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "dfe5e6a9-ee9f-4bea-9a1d-32c49c69dbee",
        "parentId" : null,
        "authorId" : "34105ae0-9fd2-4403-be9b-7c550a729828",
        "body" : "I suppose we can't do it because backwards compatibility... But the temptation is strong to change the `PyArg_ParseTupleAndKeywords` format string to `\"O|On\"` and get rid of the `mlength` variable and the `None` handling logic altogether...",
        "createdAt" : "2016-12-06T09:32:15Z",
        "updatedAt" : "2017-03-25T06:51:07Z",
        "lastEditedBy" : "34105ae0-9fd2-4403-be9b-7c550a729828",
        "tags" : [
        ]
      },
      {
        "id" : "5f287fc6-2346-4ee7-9c32-5195db74e7d9",
        "parentId" : "dfe5e6a9-ee9f-4bea-9a1d-32c49c69dbee",
        "authorId" : "4b199d8d-ad49-4d20-ac90-89741ac9c7bb",
        "body" : "It is very strong.  Note that I did change the docstring to pretend this is the case...",
        "createdAt" : "2016-12-06T18:51:19Z",
        "updatedAt" : "2017-03-25T06:51:07Z",
        "lastEditedBy" : "4b199d8d-ad49-4d20-ac90-89741ac9c7bb",
        "tags" : [
        ]
      },
      {
        "id" : "9ae44a2c-eeac-4102-9e79-bb528068ed74",
        "parentId" : "dfe5e6a9-ee9f-4bea-9a1d-32c49c69dbee",
        "authorId" : "34105ae0-9fd2-4403-be9b-7c550a729828",
        "body" : "Yes, I did notice, much better default if you ask me.",
        "createdAt" : "2016-12-07T09:48:14Z",
        "updatedAt" : "2017-03-25T06:51:07Z",
        "lastEditedBy" : "34105ae0-9fd2-4403-be9b-7c550a729828",
        "tags" : [
        ]
      },
      {
        "id" : "16f73836-1045-4b77-b5c4-7b6e35ba6d50",
        "parentId" : "dfe5e6a9-ee9f-4bea-9a1d-32c49c69dbee",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Would be great to add a deprecation warning for passing `None` here, so that down the line we have an option to remove it",
        "createdAt" : "2017-03-25T01:50:08Z",
        "updatedAt" : "2017-03-25T06:51:07Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "ec6d4295a80e5df235d3f5445e6425581309c930",
    "line" : 3,
    "diffHunk" : "@@ -1,1 +116,120 @@    }\n    else {\n        minlength = PyArray_PyIntAsIntp(mlength);\n        if (minlength < 0) {\n            if (!PyErr_Occurred()) {"
  }
]
[
  {
    "id" : "5e4f39e4-ed09-440d-90e6-3123cbee7e7a",
    "prId" : 9998,
    "prUrl" : "https://github.com/numpy/numpy/pull/9998#pullrequestreview-114184162",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "aeddbb0a-e557-445f-8765-d816f19a3d76",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "The comment above this line is no longer correct, right?",
        "createdAt" : "2018-04-21T21:31:57Z",
        "updatedAt" : "2018-04-21T21:31:57Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "7289646d-09bc-45b5-b187-aacfece8202f",
        "parentId" : "aeddbb0a-e557-445f-8765-d816f19a3d76",
        "authorId" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "body" : "fixed",
        "createdAt" : "2018-04-21T21:53:56Z",
        "updatedAt" : "2018-04-21T21:53:56Z",
        "lastEditedBy" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "tags" : [
        ]
      }
    ],
    "commit" : "fa9a74165479142e2c1671f871fe7c860146cd52",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +30,34 @@    char started, finished;\n    /* iter must used as a context manager if writebackifcopy semantics used */\n    char managed;\n    /* Child to update for nested iteration */\n    NewNpyArrayIterObject *nested_child;"
  },
  {
    "id" : "7af78a99-aa1b-46d0-ad60-6c455f3d650f",
    "prId" : 9998,
    "prUrl" : "https://github.com/numpy/numpy/pull/9998#pullrequestreview-114184995",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "474b4df6-4550-4cb8-b2a3-861233cc4128",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Should probably also check that you're not re-entering the iterator",
        "createdAt" : "2018-04-21T21:33:04Z",
        "updatedAt" : "2018-04-21T21:33:04Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "06f38756-30c6-4671-91ca-499e854c9789",
        "parentId" : "474b4df6-4550-4cb8-b2a3-861233cc4128",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Either that, or allow re-entrant `with`s, but only cleanup on the outermost one.",
        "createdAt" : "2018-04-21T21:35:28Z",
        "updatedAt" : "2018-04-21T21:35:28Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "6b44f61a-d6cd-4352-9786-bc1f0d7eb475",
        "parentId" : "474b4df6-4550-4cb8-b2a3-861233cc4128",
        "authorId" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "body" : "Reentrant is OK (test added), multiple cleanups are harmless. Once the cleanup is finished, we set `self->managed = CONTEXT_EXITED` so reentering a closed nditer fails (there is a test for that in `test_nditer.py`, line 2847",
        "createdAt" : "2018-04-21T21:43:28Z",
        "updatedAt" : "2018-04-21T21:43:28Z",
        "lastEditedBy" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "tags" : [
        ]
      },
      {
        "id" : "b400c283-27b8-4333-9d1d-eebbd7231928",
        "parentId" : "474b4df6-4550-4cb8-b2a3-861233cc4128",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "I guess the question is, is this the behavior we expect?\r\n```\r\nwith it:\r\n    with it:\r\n        do_stuff_with_it()  # ok\r\n    do_stuff_with(it)  # error: already closed\r\n```\r\n\r\nIt does seem to match how `contextlib.closing` works, so I suppose is consistent.",
        "createdAt" : "2018-04-21T22:37:41Z",
        "updatedAt" : "2018-04-21T22:37:41Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "fa9a74165479142e2c1671f871fe7c860146cd52",
    "line" : 178,
    "diffHunk" : "@@ -1,1 +2407,2411 @@        return NULL;\n    }\n    self->managed = CONTEXT_INSIDE;\n    Py_INCREF(self);\n    return (PyObject *)self;"
  },
  {
    "id" : "370d86b9-0b9e-40f7-8233-fc9f31a60382",
    "prId" : 9998,
    "prUrl" : "https://github.com/numpy/numpy/pull/9998#pullrequestreview-114185462",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7342fac1-5aa0-415c-88b9-fbf11724e73d",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Shouldn't this happen after `.close()` is called, not just after `__exit__` is called?",
        "createdAt" : "2018-04-21T22:55:59Z",
        "updatedAt" : "2018-04-21T22:55:59Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "6d6b97c0-1dc5-44b4-b6db-51f4c70ce551",
        "parentId" : "7342fac1-5aa0-415c-88b9-fbf11724e73d",
        "authorId" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "body" : "yes, see new PR for issue #10950",
        "createdAt" : "2018-04-21T23:08:44Z",
        "updatedAt" : "2018-04-21T23:08:44Z",
        "lastEditedBy" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "tags" : [
        ]
      }
    ],
    "commit" : "fa9a74165479142e2c1671f871fe7c860146cd52",
    "line" : 65,
    "diffHunk" : "@@ -1,1 +1492,1496 @@    if (self->managed == CONTEXT_EXITED) {\n        PyErr_SetString(PyExc_ValueError,\n                \"Iterator is closed\");\n        return NULL;\n    }"
  },
  {
    "id" : "44dd0a95-0e73-4516-9a06-1e68f3170d56",
    "prId" : 11376,
    "prUrl" : "https://github.com/numpy/numpy/pull/11376#pullrequestreview-130544033",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "cda27cf6-3cf8-4a73-a4c9-dfbf2ef5befc",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Do we have a solution to #10956 yet? Is it guaranteed that this warning will never appear if `out` is allocated by the iterator?",
        "createdAt" : "2018-06-20T07:50:19Z",
        "updatedAt" : "2018-06-20T07:50:20Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "99e3b3fb-f66a-4cef-b327-d694cf00dbdd",
        "parentId" : "cda27cf6-3cf8-4a73-a4c9-dfbf2ef5befc",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "@mattip This seems to be the only outstanding issue here that needs to be resolved.",
        "createdAt" : "2018-06-20T15:20:54Z",
        "updatedAt" : "2018-06-20T15:20:55Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "092af2b0-d9ea-4161-86e0-b31d1cdf72ff",
        "parentId" : "cda27cf6-3cf8-4a73-a4c9-dfbf2ef5befc",
        "authorId" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "body" : "I am not sure #10956 is an issue. See my last comment there. It is more a discussion about what is meant by operands. In any case, if `out` is allocated by the iterator it will never have writeback semantics and so the warning will not appear.",
        "createdAt" : "2018-06-20T17:57:39Z",
        "updatedAt" : "2018-06-20T17:57:39Z",
        "lastEditedBy" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "tags" : [
        ]
      },
      {
        "id" : "f9ad4e1a-1671-4df1-9306-ac63d1fe786b",
        "parentId" : "cda27cf6-3cf8-4a73-a4c9-dfbf2ef5befc",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "> In any case, if out is allocated by the iterator it will never have writeback semantics and so the warning will not appear.\r\n\r\nGreat, this is what I was worried about",
        "createdAt" : "2018-06-20T18:55:25Z",
        "updatedAt" : "2018-06-20T18:55:25Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "73494682ab4cb3469ade494c113672094ce13f47",
    "line" : 49,
    "diffHunk" : "@@ -1,1 +1185,1189 @@                    \"operands. Typically nditer is used as a context manager \"\n                    \"otherwise 'close' must be called before reading iteration \"\n                    \"results.\", 1) < 0) {\n                PyObject *s;\n"
  },
  {
    "id" : "e61946e3-3f82-4855-a38d-3773d917eb7a",
    "prId" : 11376,
    "prUrl" : "https://github.com/numpy/numpy/pull/11376#pullrequestreview-130283527",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1d9c8fbb-0837-48a0-9227-5b581bec12b1",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Ideally this would move to `tp_finalize`, once we drop 2.7. Then you could also just pass `npiter.__del__` in as the argument to WriteUnraiseable.\r\n\r\nWe'd use the `PyObject_CallFinalizerFromDealloc` function, which is undocumented (https://bugs.python.org/issue33909)",
        "createdAt" : "2018-06-20T08:17:55Z",
        "updatedAt" : "2018-06-20T08:24:21Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "73494682ab4cb3469ade494c113672094ce13f47",
    "line" : 44,
    "diffHunk" : "@@ -1,1 +1180,1184 @@{\n    if (self->iter) {\n        if (npyiter_has_writeback(self->iter)) {\n            if (PyErr_WarnEx(PyExc_RuntimeWarning,\n                    \"Temporary data has not been written back to one of the \""
  },
  {
    "id" : "33799b70-9062-45a9-8350-526bc9fe0e78",
    "prId" : 18289,
    "prUrl" : "https://github.com/numpy/numpy/pull/18289#pullrequestreview-582881504",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fb466ba1-4689-4a7b-97c0-34fed5638993",
        "parentId" : null,
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Surprisingly, there was a test that actually tripped when `dealloc` accidentally cleared an existing error.  Apparently, that is important, at least if we fail during `init`.",
        "createdAt" : "2021-02-03T23:02:03Z",
        "updatedAt" : "2021-02-04T02:05:18Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      }
    ],
    "commit" : "33953d21e735f9e31558a7c848970524ea9e2137",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +1137,1141 @@        /* Store error, so that WriteUnraisable cannot clear an existing one */\n        PyObject *exc, *val, *tb;\n        PyErr_Fetch(&exc, &val, &tb);\n        if (npyiter_has_writeback(self->iter)) {\n            if (PyErr_WarnEx(PyExc_RuntimeWarning,"
  }
]
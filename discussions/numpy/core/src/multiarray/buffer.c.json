[
  {
    "id" : "c7902853-f5ca-41d1-8c8b-dd9d0f380c99",
    "prId" : 278,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5c164f60-af07-4d80-8dec-77cc41e5a3ec",
        "parentId" : null,
        "authorId" : "810880d7-9b25-4940-a0cb-9281ddc2d16a",
        "body" : "As discussed on the mailing list earlier, wouldn't this prevent implementations that currently handle these arrays just fine from operating?  It still looks like the right call to me, but I wanted to check.  For the rest, the patch looks good.\n",
        "createdAt" : "2012-05-10T21:58:36Z",
        "updatedAt" : "2012-05-10T21:58:36Z",
        "lastEditedBy" : "810880d7-9b25-4940-a0cb-9281ddc2d16a",
        "tags" : [
        ]
      },
      {
        "id" : "299a98ec-b243-470b-ba58-33589bb4a63f",
        "parentId" : "5c164f60-af07-4d80-8dec-77cc41e5a3ec",
        "authorId" : "95359633-f0b0-4899-8e46-e2146fd11511",
        "body" : "This prevents code which currently produce invalid results for NA inputs from running, by raising an exception instead. This way, people can write code the way they're accustomed to, without worrying about NAs producing bizarre results. If they choose to later support NA, it will be obvious where to do that because of these exceptions.\n",
        "createdAt" : "2012-05-10T22:01:37Z",
        "updatedAt" : "2012-05-10T22:01:37Z",
        "lastEditedBy" : "95359633-f0b0-4899-8e46-e2146fd11511",
        "tags" : [
        ]
      },
      {
        "id" : "aa7ff60b-af7d-44b9-816a-493e20326682",
        "parentId" : "5c164f60-af07-4d80-8dec-77cc41e5a3ec",
        "authorId" : "810880d7-9b25-4940-a0cb-9281ddc2d16a",
        "body" : "Right, I guess changing a NA to another value without knowing could have dire consequences for the array interpretation.\n\n+1\n",
        "createdAt" : "2012-05-10T22:05:44Z",
        "updatedAt" : "2012-05-10T22:05:44Z",
        "lastEditedBy" : "810880d7-9b25-4940-a0cb-9281ddc2d16a",
        "tags" : [
        ]
      }
    ],
    "commit" : "bfa66da9bddf4bd50a0c098d8d2dc79b17e8b4a2",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +610,614 @@        PyErr_SetString(PyExc_TypeError, \"NA-masked arrays are not supported by the Python buffer protocol\");\n        goto fail;\n    }\n    if ((flags & PyBUF_C_CONTIGUOUS) == PyBUF_C_CONTIGUOUS &&\n        !PyArray_CHKFLAGS(self, NPY_ARRAY_C_CONTIGUOUS)) {"
  },
  {
    "id" : "fdcc380a-a96e-40e4-bcf1-6485f158614a",
    "prId" : 3655,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8eb4deec-9417-4981-a4a2-2579ea60c0a4",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Is this malloc checked further down?\n",
        "createdAt" : "2013-08-29T22:03:13Z",
        "updatedAt" : "2013-08-30T09:59:00Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "9680b46b-5c72-4f63-81d8-aecf6c2acc3f",
        "parentId" : "8eb4deec-9417-4981-a4a2-2579ea60c0a4",
        "authorId" : "acce7360-5cef-46f0-ab05-4fb0ffdffe3a",
        "body" : "It's not, and the caller is doing a lot of unchecked stuff. Fixing that now.\n",
        "createdAt" : "2013-08-30T09:38:02Z",
        "updatedAt" : "2013-08-30T09:59:00Z",
        "lastEditedBy" : "acce7360-5cef-46f0-ab05-4fb0ffdffe3a",
        "tags" : [
        ]
      }
    ],
    "commit" : "0167ac1daa6adb058d646efd0790ce129059116a",
    "line" : 78,
    "diffHunk" : "@@ -1,1 +467,471 @@    }\n    else {\n        info->shape = malloc(sizeof(Py_ssize_t) * PyArray_NDIM(arr) * 2 + 1);\n        if (info->shape == NULL) {\n            goto fail;"
  },
  {
    "id" : "9ad89189-f489-40b4-81e4-1de6f57ea073",
    "prId" : 3779,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c30a09d9-6fb1-4c31-8caf-7e982c677f71",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "What is the distinction here? Does non-native determine the precision?\n",
        "createdAt" : "2013-09-22T18:14:25Z",
        "updatedAt" : "2013-09-22T18:14:25Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "bb19b6be-adf7-4903-8eec-3f7a11726d5a",
        "parentId" : "c30a09d9-6fb1-4c31-8caf-7e982c677f71",
        "authorId" : "48d7d71b-9655-46b2-9a18-7c1fba7837d0",
        "body" : "It's this: http://docs.python.org/2/library/struct.html#byte-order-size-and-alignment\n\nNative determines whether the size comes from C compiler, or that table in Python docs.\n",
        "createdAt" : "2013-09-22T18:15:17Z",
        "updatedAt" : "2013-09-22T18:16:08Z",
        "lastEditedBy" : "48d7d71b-9655-46b2-9a18-7c1fba7837d0",
        "tags" : [
        ]
      }
    ],
    "commit" : "b7aec6035d2b2cfbcabe84e308ce3b09ea5fe540",
    "line" : 124,
    "diffHunk" : "@@ -1,1 +930,934 @@    case 'i': return native ? NPY_INT : NPY_INT32;\n    case 'I': return native ? NPY_UINT : NPY_UINT32;\n    case 'l': return native ? NPY_LONG : NPY_INT32;\n    case 'L': return native ? NPY_ULONG : NPY_UINT32;\n    case 'q': return native ? NPY_LONGLONG : NPY_INT64;"
  },
  {
    "id" : "daca84da-2555-4c53-bf05-81627c6b1fc0",
    "prId" : 4197,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4c73f58c-1970-49c9-9094-07ed37813b7b",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Looks like at least one of the elements of `fmt` should be initialized with a `NULL` rather than 0. It's a small point, but...\n",
        "createdAt" : "2014-01-15T03:13:16Z",
        "updatedAt" : "2014-01-15T23:30:16Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "2f8d33bc755b869639e38e0482c0abda956578cc",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +455,459 @@    /* Fill in format */\n    if (_buffer_format_string(PyArray_DESCR(arr), &fmt, arr, NULL, NULL) != 0) {\n        free(fmt.s);\n        goto fail;\n    }"
  },
  {
    "id" : "6fe4f7be-165f-45cc-aa8c-1691d4f4fd97",
    "prId" : 4350,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2c25af15-93a9-44c9-882c-bf7cfbbe4130",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "I'm guessing from context that you don't always increment `p`?\n",
        "createdAt" : "2014-02-22T18:39:38Z",
        "updatedAt" : "2014-02-22T18:39:38Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "7c7fbd79-84e2-4f46-ac84-6e57cd3bc246",
        "parentId" : "2c25af15-93a9-44c9-882c-bf7cfbbe4130",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Yeah, p is supposed to be whitespace stripped, but currently if you look at the code, it will just stay uninitialized on whitespaces. Which is certainly bad.\n",
        "createdAt" : "2014-02-22T18:50:36Z",
        "updatedAt" : "2014-02-22T18:50:36Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      }
    ],
    "commit" : "6c4e64204df6f336b617ff0447d0ea104cdf1ae6",
    "line" : 12,
    "diffHunk" : "@@ -1,1 +812,816 @@            p++;\n        }\n        s++;\n    }\n    *p = '\\0';"
  },
  {
    "id" : "9f2cc20c-83de-4db3-b3b3-a9e5b4271e70",
    "prId" : 5086,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0f81e652-645d-420f-bcde-716ec3a1f0de",
        "parentId" : null,
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "-1 has nothing to do with anything, but it isn't wrong as such, so OK :)\n",
        "createdAt" : "2014-09-19T19:30:07Z",
        "updatedAt" : "2014-10-20T21:25:27Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      }
    ],
    "commit" : "7d1cb081c8677c5939995b700ab0ee34d5d0e154",
    "line" : 19,
    "diffHunk" : "@@ -1,1 +711,715 @@         * contiguous, but it won't look that way to Python when it\n         * tries to determine contiguity by looking at the strides\n         * (since one of the elements may be -1).  In that case, just\n         * regenerate strides from shape.\n         */"
  },
  {
    "id" : "6bd287d3-3921-408b-8247-c0869c492ee6",
    "prId" : 10564,
    "prUrl" : "https://github.com/numpy/numpy/pull/10564#pullrequestreview-99588751",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2e35c30f-bbc5-4844-9861-875062021a61",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Pleased to see that you did this",
        "createdAt" : "2018-02-27T08:12:42Z",
        "updatedAt" : "2018-03-19T14:44:14Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "f81d64173de284db012b8da5012151a5db1fd3e0",
    "line" : 224,
    "diffHunk" : "@@ -1,1 +819,823 @@        elsize >>= 1;\n    }\n#endif\n    view->len = elsize;\n    view->itemsize = elsize;"
  },
  {
    "id" : "2b04e235-0900-40a6-9581-f1ee861c705a",
    "prId" : 11694,
    "prUrl" : "https://github.com/numpy/numpy/pull/11694#pullrequestreview-147448102",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b620f631-71e8-46c8-af27-4bcb92e001fc",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Something for another PR: We ought to be checking the return value of `_append_char`, but we don't",
        "createdAt" : "2018-08-19T05:53:08Z",
        "updatedAt" : "2018-08-19T06:40:42Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "c94d1c757b1d1423acb28c94fd1497305432ccbb",
    "line" : 25,
    "diffHunk" : "@@ -1,1 +493,497 @@         */\n        _append_char(&fmt, 'B');\n        _append_char(&fmt, '\\0');\n        info->ndim = 1;\n        info->shape = malloc(sizeof(Py_ssize_t) * 2);"
  },
  {
    "id" : "bc55e8bd-342a-4b97-8691-bde94712970f",
    "prId" : 12045,
    "prUrl" : "https://github.com/numpy/numpy/pull/12045#pullrequestreview-160116187",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "65df721e-38e2-4ea0-8690-376b68d013ad",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Hmm, freeing a possibly NULL pointer is supposed to be safe, although there were archaic platforms on which it segfaulted. We'll go with it.",
        "createdAt" : "2018-09-30T14:03:16Z",
        "updatedAt" : "2018-09-30T14:03:16Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "78ac0ed8c6b8e4006c62d6bc68e41cdd438fe4e5",
    "line" : 12,
    "diffHunk" : "@@ -1,1 +571,575 @@\nfail:\n    free(fmt.s);\n    free(info);\n    return NULL;"
  },
  {
    "id" : "19a03c5c-9407-4adc-8f08-fc8126e4d634",
    "prId" : 12624,
    "prUrl" : "https://github.com/numpy/numpy/pull/12624#pullrequestreview-188184012",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c517e059-15e1-4246-bf4b-1b9e55182071",
        "parentId" : null,
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Frankly, right now I do not understand the logic of the cache, but I did not try to either and I guess they are very small objects.",
        "createdAt" : "2018-12-27T21:58:57Z",
        "updatedAt" : "2019-01-02T19:17:23Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      }
    ],
    "commit" : "4732c1be2da093711ab544f6e0a302b9d7ee4bcb",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +513,517 @@     * Note that the buffer info is cached as pyints making them appear like\n     * unreachable lost memory to valgrind.\n     */\n    info = malloc(sizeof(_buffer_info_t));\n    if (info == NULL) {"
  },
  {
    "id" : "ebb919a3-4e01-41cc-a7b6-0d90cd9bff76",
    "prId" : 13993,
    "prUrl" : "https://github.com/numpy/numpy/pull/13993#pullrequestreview-261593736",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c507bfd6-ef7e-4434-b1ba-48fd51d92e81",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Mixed tabs and spaces here",
        "createdAt" : "2019-07-14T18:26:31Z",
        "updatedAt" : "2019-07-14T21:54:05Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "c24e43c0eb4dd6f9e4bf12519000cb9f662a5425",
    "line" : 26,
    "diffHunk" : "@@ -1,1 +790,794 @@     * If a read-only buffer is requested on a read-write array, we return a\n     * read-write buffer as per buffer protocol.\n     * We set a requested buffer to readonly also if the array will be readonly\n     * after a deprecation. This jumps the deprecation, but avoiding the\n     * warning is not convenient here. A warning is given if a writeable"
  },
  {
    "id" : "c663c472-9aa8-4416-8ea8-41b5722da8a2",
    "prId" : 16523,
    "prUrl" : "https://github.com/numpy/numpy/pull/16523#pullrequestreview-426357242",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9deddb1e-2b65-4520-b0cc-783dc2c0543a",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Can we play it safe with:\r\n\r\n```suggestion\r\n    if (PyArray_IsScalar(obj, Generic)) {\r\n```",
        "createdAt" : "2020-06-08T14:56:08Z",
        "updatedAt" : "2020-06-08T16:34:08Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "eb6b55f0-2acb-4a38-8a64-6cf2fafc7cdb",
        "parentId" : "9deddb1e-2b65-4520-b0cc-783dc2c0543a",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "If this path is hit for anything but a void scalar it is a bug now? Which is why I added the assert in the array path?",
        "createdAt" : "2020-06-08T15:08:56Z",
        "updatedAt" : "2020-06-08T16:34:08Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "6ba5b76a-d610-4dbe-ae53-001c7d04fc39",
        "parentId" : "9deddb1e-2b65-4520-b0cc-783dc2c0543a",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "What makes it a bug? The default implementation throws `ValueError`, which seems a lot better than segfaulting.",
        "createdAt" : "2020-06-08T15:28:09Z",
        "updatedAt" : "2020-06-08T16:34:08Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "e52ef51eb1ba49493cd565da100cf1a063c180f1",
    "line" : 95,
    "diffHunk" : "@@ -1,1 +469,473 @@    int err = 0;\n\n    if (PyArray_IsScalar(obj, Void)) {\n        info = PyObject_Malloc(sizeof(_buffer_info_t));\n        if (info == NULL) {"
  },
  {
    "id" : "7c03ac73-a35d-4b77-87b6-c95726eafb62",
    "prId" : 16936,
    "prUrl" : "https://github.com/numpy/numpy/pull/16936#pullrequestreview-454372596",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bbcf8c6b-64d1-4225-bed4-1e52e8445441",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Do we have any evidence these users exist?",
        "createdAt" : "2020-07-23T17:53:17Z",
        "updatedAt" : "2020-10-20T04:12:28Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "2d1ee5a9-0395-4fe7-a4c6-90b4953916b6",
        "parentId" : "bbcf8c6b-64d1-4225-bed4-1e52e8445441",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Also, should this code be conditional on NPY_RELAXED_STRIDES_CHECKING ?",
        "createdAt" : "2020-07-23T17:54:16Z",
        "updatedAt" : "2020-10-20T04:12:28Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "037f1cc1-13ea-4d32-82aa-0b050fba6db3",
        "parentId" : "bbcf8c6b-64d1-4225-bed4-1e52e8445441",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Happy to make it conditional. Without it, its basically a no-op currently.\r\n\r\nAs to evidence: There used to be issues with scipy, etc. when we switched NumPy over.  From the comment, I somewhat think Python _used_ to have issues around it (I doubt it still has with a brief look at the code).\r\n\r\nIt would be nice to just remove this dance completely.  But, I am unwilling to do this in 1.19, so I think we should probably put this in anyway, and then consider doing the additional step with a big release note.  The problem is, that relaxed strides was not a simple matter: We had to do multiple releases with it enabled during RC, but disabled during release to flush out (potential) issues.  We can do that again of course (set relaxed strides to debug mode during release), but it might be painful.",
        "createdAt" : "2020-07-23T18:01:29Z",
        "updatedAt" : "2020-10-20T04:12:28Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      }
    ],
    "commit" : "c42e6904b723c096cdebd9abbb877ed5b4f00b20",
    "line" : 25,
    "diffHunk" : "@@ -1,1 +514,518 @@             * (This is unnecessary, but has no effect in the case where\n             * NPY_RELAXED_STRIDES CHECKING is disabled.)\n             */\n            if (PyArray_IS_C_CONTIGUOUS(arr) && !(\n                    f_contiguous && PyArray_IS_F_CONTIGUOUS(arr))) {"
  },
  {
    "id" : "eca47468-422f-41b6-9395-15c538c93f48",
    "prId" : 16936,
    "prUrl" : "https://github.com/numpy/numpy/pull/16936#pullrequestreview-454458186",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3694c517-308a-4f83-9455-a44797ffbfae",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Something for a follow-up - this is overly strict, if the user did not request a contiguous buffer at all we still construct these replacement strides.",
        "createdAt" : "2020-07-23T19:55:36Z",
        "updatedAt" : "2020-10-20T04:12:28Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "8b679679-25ff-4476-8ce3-0d15791ce97d",
        "parentId" : "3694c517-308a-4f83-9455-a44797ffbfae",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "IIRC there was a reason for that. Maybe Cython may sometimes requested a buffer without specifying the flag, but then checking for it anyway later-on (potentially even raising an error). I somewhat expects cython caught up over time with our interpretation of relaxed strides, but I am not 100% sure.",
        "createdAt" : "2020-07-23T20:08:01Z",
        "updatedAt" : "2020-10-20T04:12:28Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      }
    ],
    "commit" : "c42e6904b723c096cdebd9abbb877ed5b4f00b20",
    "line" : 42,
    "diffHunk" : "@@ -1,1 +531,535 @@                    sd *= info->shape[k];\n                }\n            }\n            else {\n#else  /* NPY_RELAXED_STRIDES_CHECKING */"
  },
  {
    "id" : "5643c4fa-b675-48be-b8e2-62444f4db0bf",
    "prId" : 16936,
    "prUrl" : "https://github.com/numpy/numpy/pull/16936#pullrequestreview-454584173",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "545e5e18-18d9-464f-832e-fa23b7ccdfce",
        "parentId" : null,
        "authorId" : "3d662ecc-ff21-4f34-b3c6-b800d65daac9",
        "body" : "If a new buffer info is always constructed anyway, what's the benefit of having a cache at all? Also, it's a list but I only ever see the last item in the list referenced. Couldn't it be replaced with a single object per array? Then there is no memory growth at all.",
        "createdAt" : "2020-07-23T23:58:17Z",
        "updatedAt" : "2020-10-20T04:12:28Z",
        "lastEditedBy" : "3d662ecc-ff21-4f34-b3c6-b800d65daac9",
        "tags" : [
        ]
      },
      {
        "id" : "efd394a3-c3ef-4aa1-abae-212782859f17",
        "parentId" : "545e5e18-18d9-464f-832e-fa23b7ccdfce",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Yeah, it would be nice to skip part of that sometimes... and would be a small speed enhancement.  But, we have to reuse the old one, so that you do not leak memory and we need to hold on to it to be able to free it again.\r\n\r\nThe problem is that we can only *free* these when the array is deleted, which is the reason for your memory leak.  This is a fundamental issue around the buffer protocol, which actually does also provide the answer to the issue (by providing a `free` function).  But due to some backcompat issues, we can't just use that...\r\n\r\nTimes change, and the need for that backcompat probably goes down.  Maybe one more thing that would be nice to try out if we had a major release, I doubt that it would create a big issue in most cases.",
        "createdAt" : "2020-07-24T00:23:42Z",
        "updatedAt" : "2020-10-20T04:12:28Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "989400f7-c3f6-49b5-b916-1cb33319739b",
        "parentId" : "545e5e18-18d9-464f-832e-fa23b7ccdfce",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Sorry, the important part is that, even though nobody likes that, arrays are currently mutable both in shape/strides and dtype... So we can't just stick to a single exported buffer object :(.",
        "createdAt" : "2020-07-24T00:26:38Z",
        "updatedAt" : "2020-10-20T04:12:28Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "33cc223f-eba4-46d0-9042-d9e199c6d686",
        "parentId" : "545e5e18-18d9-464f-832e-fa23b7ccdfce",
        "authorId" : "3d662ecc-ff21-4f34-b3c6-b800d65daac9",
        "body" : "So to sum up, it isn't a cache in the usual sense but instead a store of all buffer objects.\r\n\r\nI see this was 577dbbd844b60958a59e062dae428a34a9c3644f which is 11 years old. If the fix 11 years old, perhaps that `PyArgs_ParseTuple` issue has been fixed in the mean time?",
        "createdAt" : "2020-07-24T00:31:15Z",
        "updatedAt" : "2020-10-20T04:12:28Z",
        "lastEditedBy" : "3d662ecc-ff21-4f34-b3c6-b800d65daac9",
        "tags" : [
        ]
      },
      {
        "id" : "98d924c7-63c7-481f-9b1e-eb1052eb1df3",
        "parentId" : "545e5e18-18d9-464f-832e-fa23b7ccdfce",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "No, that issue is still in `PyArg_ParseTuple` with an ugly comment as well there.  It may be that *users* of it are less now though.  And yes, you are right, the name \"cache\" is a misnomer, since it is persistent.",
        "createdAt" : "2020-07-24T00:52:06Z",
        "updatedAt" : "2020-10-20T04:12:28Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      }
    ],
    "commit" : "c42e6904b723c096cdebd9abbb877ed5b4f00b20",
    "line" : 86,
    "diffHunk" : "@@ -1,1 +631,635 @@            item = PyList_GetItem(item_list, item_list_length - 1);\n            old_info = (_buffer_info_t*)PyLong_AsVoidPtr(item);\n            if (_buffer_info_cmp(info, old_info) == 0) {\n                _buffer_info_free(info);\n                info = old_info;"
  },
  {
    "id" : "72ec400f-d19a-4f57-9593-fde290260324",
    "prId" : 16936,
    "prUrl" : "https://github.com/numpy/numpy/pull/16936#pullrequestreview-454766385",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "05c10079-0ff1-436b-9dad-d82914870695",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "```suggestion\r\n             * Some buffer users who requested a contiguous buffer may expect\r\n             * it to have well formatted strides even when a dimension is 1,\r\n             * but we do not guarantee this internally when\r\n             * NPY_RELAXED_STRIDES_CHECKING is used, so must recalculate\r\n             * strides. For simplicity, we do this for all contiguous arrays,\r\n             * even if contiguity was not explicitly requested.\r\n             */\r\n```",
        "createdAt" : "2020-07-24T09:57:14Z",
        "updatedAt" : "2020-10-20T04:12:28Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "c42e6904b723c096cdebd9abbb877ed5b4f00b20",
    "line" : 25,
    "diffHunk" : "@@ -1,1 +514,518 @@             * (This is unnecessary, but has no effect in the case where\n             * NPY_RELAXED_STRIDES CHECKING is disabled.)\n             */\n            if (PyArray_IS_C_CONTIGUOUS(arr) && !(\n                    f_contiguous && PyArray_IS_F_CONTIGUOUS(arr))) {"
  },
  {
    "id" : "aba892cb-ca90-4355-afe6-2783881513cc",
    "prId" : 16936,
    "prUrl" : "https://github.com/numpy/numpy/pull/16936#pullrequestreview-466922814",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9a4e3bb7-1b80-4b79-9030-25fbf52141d1",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "As an aside for a future PR, I think we could get a reasonable speedup for the cache hit case by using `Py_capsure` objects instead of `PyLong_AsVoidPtr` here - converting pointers to big integers and back seems silly when we could just keep the pointer around.",
        "createdAt" : "2020-08-13T09:03:08Z",
        "updatedAt" : "2020-10-20T04:12:28Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "b156bd18-b0cc-4918-aedf-15691daa2138",
        "parentId" : "9a4e3bb7-1b80-4b79-9030-25fbf52141d1",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Possibly (and probably nicer in any case).  I would prefer the approach in: gh-16938, but I don't have the mental capacity to figure out how annoying growing the struct is (I doubt its very) and mainly what could be done to reduce the chance of issues.",
        "createdAt" : "2020-08-13T16:26:00Z",
        "updatedAt" : "2020-10-20T04:12:28Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      }
    ],
    "commit" : "c42e6904b723c096cdebd9abbb877ed5b4f00b20",
    "line" : 84,
    "diffHunk" : "@@ -1,1 +630,634 @@        if (item_list_length > 0) {\n            item = PyList_GetItem(item_list, item_list_length - 1);\n            old_info = (_buffer_info_t*)PyLong_AsVoidPtr(item);\n            if (_buffer_info_cmp(info, old_info) == 0) {\n                _buffer_info_free(info);"
  },
  {
    "id" : "49cd04e5-46a9-403e-9a88-bb35c6a37921",
    "prId" : 16936,
    "prUrl" : "https://github.com/numpy/numpy/pull/16936#pullrequestreview-498878016",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "254d3287-0873-4512-b3cf-f3a82167f2a7",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "```suggestion\r\n    /* Fill in information: void scalars are always C-order (0) */\r\n```",
        "createdAt" : "2020-09-29T20:44:20Z",
        "updatedAt" : "2020-10-20T04:12:28Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "c42e6904b723c096cdebd9abbb877ed5b4f00b20",
    "line" : 161,
    "diffHunk" : "@@ -1,1 +825,829 @@    }\n\n    /* Fill in information */\n    info = _buffer_get_info(self, 0);\n    if (info == NULL) {"
  }
]
[
  {
    "id" : "5670b421-b89a-43b2-9cb6-cd6dc2358521",
    "prId" : 4889,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "807bfb01-3c46-40a1-984a-efbb38a33c46",
        "parentId" : null,
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "hm, we could possible make this saver by performing a PyObject_Copy\n",
        "createdAt" : "2014-07-18T20:08:30Z",
        "updatedAt" : "2014-07-18T20:08:30Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      },
      {
        "id" : "baaf1254-3e92-4eea-9b64-a4993e750bab",
        "parentId" : "807bfb01-3c46-40a1-984a-efbb38a33c46",
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "urg there is no PyObject_Copy capi?\n",
        "createdAt" : "2014-07-18T20:12:28Z",
        "updatedAt" : "2014-07-18T20:12:28Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      }
    ],
    "commit" : "c09d0ce0e11c94a83413c1bc6c9b2f5f40008a5a",
    "line" : 10,
    "diffHunk" : "@@ -1,1 +280,284 @@            Py_XINCREF(obj);\n            NPY_COPY_PYOBJECT_PTR(optr, &obj);\n            optr += sizeof(obj);\n        }\n        return;"
  },
  {
    "id" : "774fee55-a846-4e3c-aa15-ec6c7fd02bcc",
    "prId" : 12650,
    "prUrl" : "https://github.com/numpy/numpy/pull/12650#pullrequestreview-192066970",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "edb0f44b-f652-4c20-94b0-3fc076a5b92f",
        "parentId" : null,
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "Surely `obj` cannot be `NULL` here?",
        "createdAt" : "2019-01-02T18:15:39Z",
        "updatedAt" : "2019-01-14T19:55:38Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      },
      {
        "id" : "9747a7d8-2ca4-4537-906c-132703293714",
        "parentId" : "edb0f44b-f652-4c20-94b0-3fc076a5b92f",
        "authorId" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "body" : "@seberg do you want to change this?",
        "createdAt" : "2019-01-13T06:10:19Z",
        "updatedAt" : "2019-01-14T19:55:38Z",
        "lastEditedBy" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "tags" : [
        ]
      },
      {
        "id" : "b549a9b1-4e9e-4969-9ae3-35c5ceba1f0e",
        "parentId" : "edb0f44b-f652-4c20-94b0-3fc076a5b92f",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "@mattip, I don't mind changing this. I am just not sure how much we implicitly support this, since NULL is also always checked e.g. in the ufunc loops that you worked on with the exception chaining.\r\nBut, I am pretty ambivalent about it. If you/anyone thinks we should just move away from it, lets do that. I do not really see the point in it.",
        "createdAt" : "2019-01-14T09:33:23Z",
        "updatedAt" : "2019-01-14T19:55:38Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      }
    ],
    "commit" : "9963a9b854e6e33dd15a927fd865619e18e8a7b8",
    "line" : 86,
    "diffHunk" : "@@ -1,1 +311,315 @@    }\n    if (dtype->type_num == NPY_OBJECT) {\n        Py_XINCREF(obj);\n        NPY_COPY_PYOBJECT_PTR(optr, &obj);\n    }"
  },
  {
    "id" : "c2e18e1d-422d-4b52-9800-d40940e15426",
    "prId" : 12650,
    "prUrl" : "https://github.com/numpy/numpy/pull/12650#pullrequestreview-189239657",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e219cbc1-50c5-44ea-84b8-fa1c0f69789f",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Should any of these be `intp`?",
        "createdAt" : "2019-01-04T00:42:52Z",
        "updatedAt" : "2019-01-14T19:55:38Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "f0891eae-cc1b-411b-b646-11a6b4808038",
        "parentId" : "e219cbc1-50c5-44ea-84b8-fa1c0f69789f",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "I think `int` is correct, since that is what dtypes use for the `elsize` so we are stuck with it.",
        "createdAt" : "2019-01-04T00:59:43Z",
        "updatedAt" : "2019-01-14T19:55:38Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "bc7a175b-730e-44df-b01d-8dd36e08a280",
        "parentId" : "e219cbc1-50c5-44ea-84b8-fa1c0f69789f",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "I guess we could use `intp` anyway...",
        "createdAt" : "2019-01-04T00:59:58Z",
        "updatedAt" : "2019-01-14T19:55:38Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      }
    ],
    "commit" : "9963a9b854e6e33dd15a927fd865619e18e8a7b8",
    "line" : 19,
    "diffHunk" : "@@ -1,1 +57,61 @@    }\n    else if (PyDataType_HASSUBARRAY(descr)) {\n        int size, i, inner_elsize;\n\n        inner_elsize = descr->subarray->base->elsize;"
  },
  {
    "id" : "3554b145-72b4-4aa8-b140-f0185b156ae5",
    "prId" : 12650,
    "prUrl" : "https://github.com/numpy/numpy/pull/12650#pullrequestreview-189643963",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "cfbf1634-08b8-4fd1-a65a-426103938005",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "This divides by zero for `np.dtype(('V0', (1, 2)))`. You should either special case `inner_elsize == 0`, or just compute the size by taking the product of the dimensions",
        "createdAt" : "2019-01-04T00:43:22Z",
        "updatedAt" : "2019-01-14T19:55:38Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "5a0f0b30-fefc-4381-b9f5-eab432700e7e",
        "parentId" : "cfbf1634-08b8-4fd1-a65a-426103938005",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Hmm, I can't work out how to construct that dtype any more",
        "createdAt" : "2019-01-04T00:47:52Z",
        "updatedAt" : "2019-01-14T19:55:38Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "19dba27f-0d48-486e-b3c2-502420a6e045",
        "parentId" : "cfbf1634-08b8-4fd1-a65a-426103938005",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Numpy tries really hard to stop me, but I can produce that type with:\r\n```python\r\ndt = np.dtype('V0')\r\ndt = copy.copy(dt)\r\ndt.__setstate__((3, '|', (np.dtype('V0'), (1, 2,)), None, None, 0, 1, 0)))\r\n```",
        "createdAt" : "2019-01-04T01:08:50Z",
        "updatedAt" : "2019-01-14T19:55:38Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "ae32240e-0936-48f3-851a-9deefb77498a",
        "parentId" : "cfbf1634-08b8-4fd1-a65a-426103938005",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Wow, good point. Calculating from shape would be nice, but unfortunately I think the shape is only stored as a python tuple right now, so I doubt that is prettier then even checking explicitly for `inner_elsize == 0`.\r\n\r\nI think I would just add it, with a comment that it seems currently not possible. I think the real problem would be a dtype such as `np.dtype([('a', 'i4'), ('b', [('ba', 'f', (5, 0))], (3,3))])` (a subarray containing a 0-size subarray). A simple `V0` cannot hold a referene so it can't reach this far (although that is not obvious).",
        "createdAt" : "2019-01-04T01:10:07Z",
        "updatedAt" : "2019-01-14T19:55:38Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "78662581-e9d4-464e-a120-a1605b16eda5",
        "parentId" : "cfbf1634-08b8-4fd1-a65a-426103938005",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Guess what? Numpy tries really hard to stop you producing that type too, which is clearly a bug. #8970 would make creating these types easy, but is a compatibility break I don't know how to handle.",
        "createdAt" : "2019-01-04T01:15:41Z",
        "updatedAt" : "2019-01-14T19:55:38Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "74483167-adbe-44ae-a461-dfce6adeca92",
        "parentId" : "cfbf1634-08b8-4fd1-a65a-426103938005",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Perhaps an intermediate step of changing to\r\n```\r\n#define PyDataType_ISUNSIZED(dtype) (\\\r\n    (dtype)->elsize == 0 && !PyDataType_HASSUBARRAY(dtype) && !PyDataType_HASFIELDS(dtype))\r\n```\r\nWould make these types creatable without going through pickle.",
        "createdAt" : "2019-01-04T01:21:10Z",
        "updatedAt" : "2019-01-14T19:55:38Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "3b511e39-9cc4-4bf3-8ef2-0dab56f732d4",
        "parentId" : "cfbf1634-08b8-4fd1-a65a-426103938005",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Yeah. It is a bit strange that mine was also not creatable (not sure if you trick can manage). For here, I think I would just go with a check for `if elsize == 0: return` since it obviously cannot hold references then, and will be future proof no matter what.\r\n\r\nI think \"unsized\" probably means things like `S0` which actually are used to mean \"S<whatever size>\"? Would have to look at the code to be quite sure.",
        "createdAt" : "2019-01-04T01:33:27Z",
        "updatedAt" : "2019-01-14T19:55:38Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "a6c90755-72ed-4f1f-abc9-3b115543e0a4",
        "parentId" : "cfbf1634-08b8-4fd1-a65a-426103938005",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Hmmm, sorry, I guess your check would likely suffice in most places when it comes to that.",
        "createdAt" : "2019-01-04T01:36:54Z",
        "updatedAt" : "2019-01-14T19:55:38Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "9f931669-e392-4e4e-9c17-3c9bb6c5d4d6",
        "parentId" : "cfbf1634-08b8-4fd1-a65a-426103938005",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "To be clear - I'm not saying you should use that check - I'm saying that the existing `PyDataType_ISUNSIZED` is wrong and misfires on empty subarrays and on structures with no fields.",
        "createdAt" : "2019-01-04T01:51:57Z",
        "updatedAt" : "2019-01-14T19:55:38Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "5eafacdc-abdc-44df-bb11-784d5ca5a25d",
        "parentId" : "cfbf1634-08b8-4fd1-a65a-426103938005",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "> not sure if you trick can manage\r\n\r\nHere's the general solution\r\n```python\r\ndef subarray_dtype(scalar, shape):\r\n    \"\"\" like np.dtype((scalar, shape)), but always produces subarrays in corner cases \"\"\"\r\n    scalar = np.dtype(scalar)\r\n    dt = np.dtype(np.void)\r\n    dt = copy.copy(dt)\r\n    dt.__setstate__((3, '|', (scalar, shape), None, None, scalar.itemsize * np.prod(shape), scalar.alignment, 0))\r\n    return dt\r\n```",
        "createdAt" : "2019-01-04T01:56:24Z",
        "updatedAt" : "2019-01-14T19:55:38Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "6f4b3eb8-6495-429a-a669-c61c9c60505f",
        "parentId" : "cfbf1634-08b8-4fd1-a65a-426103938005",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Moved discussion about the dtype construction pain to #12681, and resolving this comment since you fixed the C code here.",
        "createdAt" : "2019-01-06T20:55:04Z",
        "updatedAt" : "2019-01-14T19:55:38Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "9963a9b854e6e33dd15a927fd865619e18e8a7b8",
    "line" : 27,
    "diffHunk" : "@@ -1,1 +65,69 @@        }\n        /* Subarrays are always contiguous in memory */\n        size = descr->elsize / inner_elsize;\n\n        for (i = 0; i < size; i++){"
  },
  {
    "id" : "7a8938b6-358c-4d7a-a3a4-5d1d94eff0b4",
    "prId" : 12650,
    "prUrl" : "https://github.com/numpy/numpy/pull/12650#pullrequestreview-189645845",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ba164914-0241-452f-85c1-cb4ad249760e",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Out of scope, but - line 295 will set an exception if an integer larger than `2**64` is passed in, which will probably lead to a `SystemError`",
        "createdAt" : "2019-01-06T21:00:52Z",
        "updatedAt" : "2019-01-14T19:55:38Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "44296129-9f8e-4cc6-be32-6f562c91a9b2",
        "parentId" : "ba164914-0241-452f-85c1-cb4ad249760e",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Frankly, I hope that this is only ever used for `0` or `None`, unfortunately it is public API.",
        "createdAt" : "2019-01-06T21:47:21Z",
        "updatedAt" : "2019-01-14T19:55:38Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      }
    ],
    "commit" : "9963a9b854e6e33dd15a927fd865619e18e8a7b8",
    "line" : 82,
    "diffHunk" : "@@ -1,1 +307,311 @@                dtype->f->setitem(obj, optr, arr);\n            }\n            Py_XDECREF(arr);\n        }\n    }"
  },
  {
    "id" : "c3438afa-554b-4dee-8b80-f7c030fff8d5",
    "prId" : 12650,
    "prUrl" : "https://github.com/numpy/numpy/pull/12650#pullrequestreview-189650545",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fcd947c4-8d86-4ee5-acd5-e4332c36b306",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Out of scope, but: Something weird is going on with the indent above this line",
        "createdAt" : "2019-01-06T23:42:04Z",
        "updatedAt" : "2019-01-14T19:55:38Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "9963a9b854e6e33dd15a927fd865619e18e8a7b8",
    "line" : 56,
    "diffHunk" : "@@ -1,1 +117,121 @@                PyArray_Item_XDECREF(data + offset, new);\n            }\n        }\n    else if (PyDataType_HASSUBARRAY(descr)) {\n        int size, i, inner_elsize;"
  },
  {
    "id" : "c256838b-6430-4bbb-a813-1202c28d6be7",
    "prId" : 17364,
    "prUrl" : "https://github.com/numpy/numpy/pull/17364#pullrequestreview-495793476",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a5f5159c-f2b1-4da8-bf75-b560576bb9c6",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "It looks to me like this can set an exception that doesn't get cleared or propagated, which can result in a systemerror.\r\n\r\n\r\nAdmittedly the old code was just as broken.",
        "createdAt" : "2020-09-22T21:55:31Z",
        "updatedAt" : "2020-09-24T17:21:28Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "7e7c3ea6-2ec4-45a6-9636-69cd54249d50",
        "parentId" : "a5f5159c-f2b1-4da8-bf75-b560576bb9c6",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "I'll take another look.",
        "createdAt" : "2020-09-22T23:25:22Z",
        "updatedAt" : "2020-09-24T17:21:28Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "7fce6752-c5cf-4c85-8b49-5b3c64af39d9",
        "parentId" : "a5f5159c-f2b1-4da8-bf75-b560576bb9c6",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "OK, I'm going to just clear any possible error, the function doesn't allow error handling. The whole thing probably needs to be redesigned.",
        "createdAt" : "2020-09-24T17:16:11Z",
        "updatedAt" : "2020-09-24T17:21:28Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "5ef7e95b-2fc1-4990-9c88-b1a173d0a72d",
        "parentId" : "a5f5159c-f2b1-4da8-bf75-b560576bb9c6",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "To be honest, I think you have to here. This function is mainly called during array deallocation and has to clear out references, so we could \"print unraisable\", but it should clear any error and continue work at the very least.\r\n\r\nI suppose it might be nice if it did report errors (after finishing as well as possible?), even if the error ends up being ignored most of the time.\r\n\r\nEDIT: Or actually, I guess continuing its work doesn't make sense. If an actual error occurs here, we are in deep trouble in any case.",
        "createdAt" : "2020-09-24T17:25:41Z",
        "updatedAt" : "2020-09-24T17:37:17Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      }
    ],
    "commit" : "976d1b3845dcc3f9116dec09501d036304dabe42",
    "line" : 8,
    "diffHunk" : "@@ -1,1 +296,300 @@\n        if ((obj == Py_None) ||\n                (PyLong_Check(obj) && PyLong_AsLong(obj) == 0)) {\n            return;\n        }"
  }
]
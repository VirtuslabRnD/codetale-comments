[
  {
    "id" : "5aeca4b2-6171-4f1e-8533-57116b93c580",
    "prId" : 3360,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "de034c87-1751-43bb-bf3b-ac1053cd4fb1",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "I think it would be more accurate to say that the values `a[i]` partition the array. The indices themselves are likely to be not unique when there are repeated values.\n",
        "createdAt" : "2013-08-02T22:38:13Z",
        "updatedAt" : "2013-08-12T12:26:07Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "4d9cd695486fa095c6bff3238341a85cbdb47d0e",
    "line" : 132,
    "diffHunk" : "@@ -1,1 +654,658 @@    -------\n    index_array : ndarray, int\n        Array of indices that partition`a` along the specified axis.\n        In other words, ``a[index_array]`` yields a sorted `a`.\n"
  },
  {
    "id" : "6e14869d-0fbd-42a3-9206-28e2cc9e1c2b",
    "prId" : 5264,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "001f9e83-b47c-4662-b7c1-54927fa7a745",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Might say that `axes` is the same as in the original transposition.\n",
        "createdAt" : "2014-11-11T22:39:47Z",
        "updatedAt" : "2014-11-11T22:39:47Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "7b1f8e2723c7611803b0341987b544d42706d0f7",
    "line" : 9,
    "diffHunk" : "@@ -1,1 +519,523 @@    -----\n    Use `transpose(a, argsort(axes))` to invert the transposition of tensors\n    when using the `axes` keyword argument.\n\n    Examples"
  },
  {
    "id" : "2ee610da-6553-4a78-8c5c-d2c1a8f2386c",
    "prId" : 8850,
    "prUrl" : "https://github.com/numpy/numpy/pull/8850#pullrequestreview-29996913",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6dc3e839-b6ab-4df0-ab76-2fb82a5b3e50",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Where did `>>> np.nonzero(x)` go?",
        "createdAt" : "2017-03-30T13:50:13Z",
        "updatedAt" : "2017-03-30T13:50:17Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "da2736704dea1a68160effe5565b385609484dcf",
    "line" : 15,
    "diffHunk" : "@@ -1,1 +1515,1519 @@           [0, 2, 0],\n           [1, 1, 0]])\n    >>> (array([0, 1, 2, 2], dtype=int64), array([0, 1, 0, 1], dtype=int64))\n\n    >>> x[np.nonzero(x)]"
  },
  {
    "id" : "d18f78aa-256f-4911-a525-156f16eb9166",
    "prId" : 9946,
    "prUrl" : "https://github.com/numpy/numpy/pull/9946#pullrequestreview-78340440",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "534b9ee5-ca7a-4771-949b-6096619db91c",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Alternatively:\r\n\r\n```python\r\nout[(*ii, *jj, *kk)] = a[(*ii, indices[jj], *kk)]\r\n```\r\n\r\nIt's a shame the unpacking generalizations don't apply to tuples within indexing brackets",
        "createdAt" : "2017-11-21T09:55:30Z",
        "updatedAt" : "2017-11-22T05:44:29Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "de28e829-3273-46ee-933b-849d25cbc4ab",
        "parentId" : "534b9ee5-ca7a-4771-949b-6096619db91c",
        "authorId" : "a4f03a99-2e43-482b-a9bc-5a9e359abb03",
        "body" : "Also, while we are using `s_`, another way to express take is \r\n\r\n```\r\narr[(s_[:],)*axis + (indices, Ellipsis)]\r\n```\r\n\r\nwhich is essentially what my comment in the intro of the docstring was saying about `a[:,:,:,indices,...]`. \r\n\r\nWhat about adding something like this to the docstring? :\r\n```\r\n     This function does the same thing as \"fancy\" indexing (indexing arrays\r\n     using arrays); however, it can be easier to use if you need elements\r\n     along a given axis and supports `out` and `mode` arguments.\r\n\r\n     That is, a call such as ``np.take(arr, indices, axis=3)`` is equivalent to\r\n     ``arr[:,:,:,indices,...]``. More explicitly, `take` is equivalent to the \r\n     following use of `ndindex` which sets each of ``ii``, ``jj``, and ``kk``\r\n     to a tuple of indices::\r\n```",
        "createdAt" : "2017-11-21T18:10:11Z",
        "updatedAt" : "2017-11-22T05:44:29Z",
        "lastEditedBy" : "a4f03a99-2e43-482b-a9bc-5a9e359abb03",
        "tags" : [
        ]
      },
      {
        "id" : "4f341b8c-eefe-4749-88f0-50dde764b740",
        "parentId" : "534b9ee5-ca7a-4771-949b-6096619db91c",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Added, with some rephrasing",
        "createdAt" : "2017-11-22T05:44:20Z",
        "updatedAt" : "2017-11-22T05:44:29Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "21ef1383cb4f6e27af188a6da5cdca93cff1bd07",
    "line" : 22,
    "diffHunk" : "@@ -1,1 +82,86 @@            for jj in ndindex(Nj):\n                for kk in ndindex(Nk):\n                    out[ii + jj + kk] = a[ii + (indices[jj],) + kk]\n\n    Parameters"
  },
  {
    "id" : "2a838580-34dd-47d9-aeca-b2215e564612",
    "prId" : 9946,
    "prUrl" : "https://github.com/numpy/numpy/pull/9946#pullrequestreview-78203287",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2cfe310f-0c30-479a-9a57-8da4c42b6f8e",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "As in the above comment, could be:\r\n```python\r\nout[(*ii, ..., *kk)] = a[(*ii, s_[:], *kk)]\r\n```",
        "createdAt" : "2017-11-21T09:56:25Z",
        "updatedAt" : "2017-11-22T05:44:29Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "bc9b36eb-e14f-41d7-a434-708003cf1b3b",
        "parentId" : "2cfe310f-0c30-479a-9a57-8da4c42b6f8e",
        "authorId" : "a4f03a99-2e43-482b-a9bc-5a9e359abb03",
        "body" : "I think there is a little less mental overhead for tuple-addition than for tuple-unpacking, especially for people new to python.",
        "createdAt" : "2017-11-21T17:54:14Z",
        "updatedAt" : "2017-11-22T05:44:29Z",
        "lastEditedBy" : "a4f03a99-2e43-482b-a9bc-5a9e359abb03",
        "tags" : [
        ]
      }
    ],
    "commit" : "21ef1383cb4f6e27af188a6da5cdca93cff1bd07",
    "line" : 66,
    "diffHunk" : "@@ -1,1 +131,135 @@        for ii in ndindex(Ni):\n            for kk in ndindex(Nj):\n                out[ii + s_[...,] + kk] = a[ii + s_[:,] + kk][indices]\n\n    For this reason, it is equivalent to (but faster than) the following use"
  },
  {
    "id" : "8801a705-9989-4c52-9485-40e27f4cab38",
    "prId" : 10072,
    "prUrl" : "https://github.com/numpy/numpy/pull/10072#pullrequestreview-79648515",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b1469070-d66e-4b57-abc7-d1cfe8eaed88",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Hmm, that isn't right, probably goes way back to when there was contiguous and fcontiguos. A transpose changes C contiguous arrays into F contiguous arrays and vice versa.\r\n```\r\nIn [1]: a = np.zeros((10, 2))\r\n\r\nIn [2]: a.flags\r\nOut[2]: \r\n  C_CONTIGUOUS : True\r\n  F_CONTIGUOUS : False\r\n  OWNDATA : True\r\n  WRITEABLE : True\r\n  ALIGNED : True\r\n  WRITEBACKIFCOPY : False\r\n  UPDATEIFCOPY : False\r\n\r\nIn [3]: a.T.flags\r\nOut[3]: \r\n  C_CONTIGUOUS : False\r\n  F_CONTIGUOUS : True\r\n  OWNDATA : False\r\n  WRITEABLE : True\r\n  ALIGNED : True\r\n  WRITEBACKIFCOPY : False\r\n  UPDATEIFCOPY : False\r\n```",
        "createdAt" : "2017-11-25T16:24:05Z",
        "updatedAt" : "2017-11-28T20:38:40Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "65145bc1-a924-4c6e-9c05-dee8fd3386ec",
        "parentId" : "b1469070-d66e-4b57-abc7-d1cfe8eaed88",
        "authorId" : "0b26c330-f021-4b8b-9165-e9135e37c5bc",
        "body" : "Updated the line to reflect this. However, it might be better to just remove the explanation entirely. This isn't information the user needs if they want to raise an error if data is copied when reshaping an array.",
        "createdAt" : "2017-11-27T15:44:34Z",
        "updatedAt" : "2017-11-28T20:38:40Z",
        "lastEditedBy" : "0b26c330-f021-4b8b-9165-e9135e37c5bc",
        "tags" : [
        ]
      },
      {
        "id" : "ccfb4dd2-d60d-4c17-beb0-1a4bdaa930ba",
        "parentId" : "b1469070-d66e-4b57-abc7-d1cfe8eaed88",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "I think this was correct before - the point is that the error message also says \"contiguous\", not `C-contiguous'. I suppose both could be updated, but that seems out of scope for a typo fix!\r\n\r\nRevert this to just the typo fixes, and I'll merge it.",
        "createdAt" : "2017-11-28T05:18:18Z",
        "updatedAt" : "2017-11-28T20:38:40Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "ecdd028b-9528-449a-8bfb-50601fc3c380",
        "parentId" : "b1469070-d66e-4b57-abc7-d1cfe8eaed88",
        "authorId" : "0b26c330-f021-4b8b-9165-e9135e37c5bc",
        "body" : "Ah, got it. Reverted!",
        "createdAt" : "2017-11-28T20:38:46Z",
        "updatedAt" : "2017-11-28T20:38:46Z",
        "lastEditedBy" : "0b26c330-f021-4b8b-9165-e9135e37c5bc",
        "tags" : [
        ]
      }
    ],
    "commit" : "efc24aed261acc78435223123d9ca8078fc61c04",
    "line" : 10,
    "diffHunk" : "@@ -1,1 +176,180 @@\n     >>> a = np.zeros((10, 2))\n     # A transpose makes the array non-contiguous\n     >>> b = a.T\n     # Taking a view makes it possible to modify the shape without modifying"
  }
]
[
  {
    "id" : "d357e6ef-60e0-4e5f-ba02-7623124e1a0a",
    "prId" : 7373,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d807fa07-147e-4ecb-a89b-902e170edca7",
        "parentId" : null,
        "authorId" : "0d70c244-f732-4a44-9ae8-c3f6de7e9b40",
        "body" : "That last sentence is not strictly necessary. There could potentially be other ufuncs that use this.\n",
        "createdAt" : "2016-03-03T05:02:24Z",
        "updatedAt" : "2016-03-04T02:36:59Z",
        "lastEditedBy" : "0d70c244-f732-4a44-9ae8-c3f6de7e9b40",
        "tags" : [
        ]
      },
      {
        "id" : "ee55b246-a623-42eb-b852-3b6b9ec1715d",
        "parentId" : "d807fa07-147e-4ecb-a89b-902e170edca7",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "There might be others, but I could not think of any. Hence the bit of explanation as to why this otherwise useless macro is there. I suppose it could be \"Introduced\" instead of \"Intended\".\n",
        "createdAt" : "2016-03-03T06:25:48Z",
        "updatedAt" : "2016-03-04T02:36:59Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "9653c05a53327332a481cd697708ae9b6360fbf0",
    "line" : 17,
    "diffHunk" : "@@ -1,1 +263,267 @@/*\n * UFunc has unit of -1, and the order of operations can be reordered\n * This case allows reduction with multiple axes at once. Intended for\n * bitwise_and reduction.\n */"
  },
  {
    "id" : "0c298775-a23d-4c69-ac3f-541263d7e3f7",
    "prId" : 8955,
    "prUrl" : "https://github.com/numpy/numpy/pull/8955#pullrequestreview-171876985",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0c61263a-718a-4c26-beec-83763a6542e3",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "This breaks ABI compatibility, doesn't it...",
        "createdAt" : "2017-07-08T20:48:25Z",
        "updatedAt" : "2018-11-12T17:16:04Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "e8826841-738a-42a3-ab19-d456d95430db",
        "parentId" : "0c61263a-718a-4c26-beec-83763a6542e3",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "?",
        "createdAt" : "2017-10-02T16:32:55Z",
        "updatedAt" : "2018-11-12T17:16:04Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "606b5bd1-7143-415b-a2e0-6cf7d84410e3",
        "parentId" : "0c61263a-718a-4c26-beec-83763a6542e3",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Adding a new field changes.`sizeof(PyUfuncObject)`, which as I understand it could be a breaking abi change.",
        "createdAt" : "2017-10-02T16:43:09Z",
        "updatedAt" : "2018-11-12T17:16:04Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "f818f07f-0c7a-4415-81a7-c42c1021e29e",
        "parentId" : "0c61263a-718a-4c26-beec-83763a6542e3",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Resolves as part of the other change that made ufuncs larger",
        "createdAt" : "2018-11-06T06:27:54Z",
        "updatedAt" : "2018-11-12T17:16:04Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "e044ae30ad80250ad9add0ff6e56ab972e1ec3d5",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +225,229 @@\n        /* Identity for reduction, when identity == PyUFunc_IdentityValue */\n        PyObject *identity_value;\n\n} PyUFuncObject;"
  },
  {
    "id" : "32cb5927-cb9a-403f-bb2e-8265ac9b9df7",
    "prId" : 11175,
    "prUrl" : "https://github.com/numpy/numpy/pull/11175#pullrequestreview-124950352",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "73bd799e-952e-4271-a0c2-5d587c1e5290",
        "parentId" : null,
        "authorId" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "body" : "The changes need an update to doc/source/reference/c-api.types-and_structures.rst, line 680 or so, with a qualifier that the new fields should only be used if `version > 0`. Come to think of it, we should be checking that as well, just in case someone is mixing headers from old code",
        "createdAt" : "2018-05-30T21:05:30Z",
        "updatedAt" : "2018-10-15T16:45:15Z",
        "lastEditedBy" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "tags" : [
        ]
      },
      {
        "id" : "42ff799d-8b95-40f7-a9f0-40c1765fe1c3",
        "parentId" : "73bd799e-952e-4271-a0c2-5d587c1e5290",
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "I guess if we find version 0 we can quickly default to -1 for the sizes and 0 for the flags. But where should one do this? And should there be a warning? (Feel free to make a PR to my branch...)",
        "createdAt" : "2018-05-30T21:24:53Z",
        "updatedAt" : "2018-10-15T16:45:15Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      },
      {
        "id" : "f49ce79c-c264-4d36-8332-a7dd6e865cdd",
        "parentId" : "73bd799e-952e-4271-a0c2-5d587c1e5290",
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "OK, I see now. From your comments below, you're specifically worried about C code that was compiled with an old include file, and then will try to construct the ufunc with parse_signature but with an old version. Seems like that should be do-able.",
        "createdAt" : "2018-05-30T21:26:43Z",
        "updatedAt" : "2018-10-15T16:45:15Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      },
      {
        "id" : "c9a9e7c8-ea19-4e18-a86e-dae104f2ffba",
        "parentId" : "73bd799e-952e-4271-a0c2-5d587c1e5290",
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "But it would need a test - would it be enough to just use a new `ufunc` but with version = 0 and then checking the new additions do not get set?",
        "createdAt" : "2018-05-30T21:32:30Z",
        "updatedAt" : "2018-10-15T16:45:15Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      },
      {
        "id" : "da6e1c78-70e3-4781-b264-d1d55f0f8861",
        "parentId" : "73bd799e-952e-4271-a0c2-5d587c1e5290",
        "authorId" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "body" : "Sounds good to me. If you want I can work on this",
        "createdAt" : "2018-05-30T21:36:13Z",
        "updatedAt" : "2018-10-15T16:45:15Z",
        "lastEditedBy" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "tags" : [
        ]
      },
      {
        "id" : "e1a3eb6c-4b47-49ee-82cb-24026c8c863b",
        "parentId" : "73bd799e-952e-4271-a0c2-5d587c1e5290",
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "Yes, super! I've spent a bit more time on this than I really should have, and things related to my normal work have been piling up...",
        "createdAt" : "2018-05-30T21:40:08Z",
        "updatedAt" : "2018-10-15T16:45:15Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      },
      {
        "id" : "b6447a1c-5a1e-4b23-8eb2-279f80f97e5c",
        "parentId" : "73bd799e-952e-4271-a0c2-5d587c1e5290",
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "(Commenting here instead of at https://github.com/mhvk/numpy/pull/1 so that history get kept.)\r\n\r\nI'm still a bit confused when exactly this becomes a problem. Suppose I wrote my own ufunc module and have it compiled with the old `ufuncobject.h`, so that internally it counts on the struct not to have `core_dim_flags` and `core_dim_sizes`. Now if I load my module with a new numpy, what exactly happens? From what I saw in cases where I mistakenly loaded astropy in my development branch, it seems one does get a warning automatically, but then code gets run.\r\n\r\nNow, presumably, this old module is organized a bit like `_umath_tests.src.c` and thus has a `PyMODINIT_FUNC`, which will run several `PyUFunc_FromFuncAndDataAndSignature`. These in turn will call `parse_signature` and, hey, presto, segmentation fault if that writes to outside the old ufunc struct. So, it does seem one needs a version check in `parse_signature` in addition to having one here that guards against accessing the new additions.",
        "createdAt" : "2018-05-31T15:29:56Z",
        "updatedAt" : "2018-10-15T16:45:15Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      },
      {
        "id" : "5459835b-a8c4-48b6-aee3-bf647f554e7b",
        "parentId" : "73bd799e-952e-4271-a0c2-5d587c1e5290",
        "authorId" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "body" : "hmm. `_parse_signature` is marked `static` so it should never leak out of `PyUFunc_FromFuncAndDataAndSignature`, and the latter allocates its own `PyUFuncObject`. So AFAICT we cannot enter `_parse_signature` with an old struct. My bad, I should have thought this through before requesting changes to this code.",
        "createdAt" : "2018-05-31T17:12:25Z",
        "updatedAt" : "2018-10-15T16:45:15Z",
        "lastEditedBy" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "tags" : [
        ]
      },
      {
        "id" : "c41d22a7-730b-4151-98f7-25fc4171efa4",
        "parentId" : "73bd799e-952e-4271-a0c2-5d587c1e5290",
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "Well, that at least is good news!",
        "createdAt" : "2018-05-31T19:49:29Z",
        "updatedAt" : "2018-10-15T16:45:15Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      }
    ],
    "commit" : "c8e15bafb0d811d8dd805ddf521d102eaac08079",
    "line" : 17,
    "diffHunk" : "@@ -1,1 +223,227 @@         */\n        npy_uint32 *core_dim_flags;\n\n\n"
  }
]
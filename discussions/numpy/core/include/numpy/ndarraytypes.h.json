[
  {
    "id" : "7c8e5173-4b54-4333-b4ac-976b4dac0e45",
    "prId" : 87,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "900e45d1-9032-4fe8-9d31-61f13dd8e864",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Could these go in npy_common.h?\n",
        "createdAt" : "2011-06-15T05:04:07Z",
        "updatedAt" : "2011-06-16T19:50:35Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "7c20fdc4-f550-436b-8e73-b32186e35fad",
        "parentId" : "900e45d1-9032-4fe8-9d31-61f13dd8e864",
        "authorId" : "95359633-f0b0-4899-8e46-e2146fd11511",
        "body" : "Yeah, that sounds fine. I'm wanting to rename away from the 'frequency' nomenclature as well.\n",
        "createdAt" : "2011-06-15T15:07:58Z",
        "updatedAt" : "2011-06-16T19:50:36Z",
        "lastEditedBy" : "95359633-f0b0-4899-8e46-e2146fd11511",
        "tags" : [
        ]
      }
    ],
    "commit" : "2d7d59aef203ebf25b268ceaccfa1be45237b0df",
    "line" : 1,
    "diffHunk" : "@@ -1,1 +231,235 @@\ntypedef enum {\n        NPY_FR_Y, /* Years */\n        NPY_FR_M, /* Months */\n        NPY_FR_W, /* Weeks */"
  },
  {
    "id" : "6bbc44bc-e490-4d60-857f-03c180cee019",
    "prId" : 87,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0870359d-250b-41e4-a9f2-62f9536c32a9",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "I've moved that into npy_common for the sort library. Looks like I'll need to do some merging ;)\n",
        "createdAt" : "2011-06-15T05:05:34Z",
        "updatedAt" : "2011-06-16T19:50:35Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "b54f8db6-acbf-47fc-bc83-8920e6219a65",
        "parentId" : "0870359d-250b-41e4-a9f2-62f9536c32a9",
        "authorId" : "95359633-f0b0-4899-8e46-e2146fd11511",
        "body" : "I want to do a relatively invasive header shuffle at some point towards managing future ABI compatibility, we'll have to make sure not to step on each others toes with that.\n",
        "createdAt" : "2011-06-15T15:10:40Z",
        "updatedAt" : "2011-06-16T19:50:36Z",
        "lastEditedBy" : "95359633-f0b0-4899-8e46-e2146fd11511",
        "tags" : [
        ]
      }
    ],
    "commit" : "2d7d59aef203ebf25b268ceaccfa1be45237b0df",
    "line" : 61,
    "diffHunk" : "@@ -1,1 +292,296 @@\n/*\n * This is to typedef npy_intp to the appropriate pointer size for\n * this platform.  Py_intptr_t, Py_uintptr_t are defined in pyport.h.\n */"
  },
  {
    "id" : "26e2c28f-cd37-476a-817d-2755d83f69a8",
    "prId" : 116,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "263911b7-ed64-4ab9-b30d-72098baaff3b",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "I believe tags are in their own namespace, so the tag prefix isn't really needed. Adding '_t' to the typedef is more commonly done.\n",
        "createdAt" : "2011-07-20T02:24:52Z",
        "updatedAt" : "2011-07-26T17:12:40Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "c1e3894d-b21b-459a-a949-64a6662efc4d",
        "parentId" : "263911b7-ed64-4ab9-b30d-72098baaff3b",
        "authorId" : "95359633-f0b0-4899-8e46-e2146fd11511",
        "body" : "I haven't noticed any consistent convention in NumPy with regards to this. I agree that typedefs like npy_int32 should be npy_int32_t as you suggest, but there are lots of things to change to make it consistent. This is the kind of thing that would go in a NumPy coding standards document somewhere...\n",
        "createdAt" : "2011-07-20T14:36:27Z",
        "updatedAt" : "2011-07-26T17:12:40Z",
        "lastEditedBy" : "95359633-f0b0-4899-8e46-e2146fd11511",
        "tags" : [
        ]
      }
    ],
    "commit" : "affea42d886e8233fdd6f3c5760708e3a9e9b1b8",
    "line" : 51,
    "diffHunk" : "@@ -1,1 +617,621 @@ */\n#ifdef NPY_NO_DEPRECATED_API\ntypedef struct tagPyArrayObject {\n        PyObject_HEAD\n} PyArrayObject;"
  },
  {
    "id" : "8cf433ad-3370-41c1-9cdf-5e8b703ce08d",
    "prId" : 116,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "06a23291-64e1-4fcb-b84d-a5ed48f790b0",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Now I contradict myself and wonder if these should be inline functions. Having a typecheck on the 'it' variable could be helpful.\n",
        "createdAt" : "2011-07-20T02:27:46Z",
        "updatedAt" : "2011-07-26T17:12:40Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "21f48f51-0a31-4b77-b4a4-87e13627068a",
        "parentId" : "06a23291-64e1-4fcb-b84d-a5ed48f790b0",
        "authorId" : "95359633-f0b0-4899-8e46-e2146fd11511",
        "body" : "It's unfortunate that all the NumPy array creation functions return PyObject\\* instead of PyArrayObject*.\n",
        "createdAt" : "2011-07-20T14:38:41Z",
        "updatedAt" : "2011-07-26T17:12:40Z",
        "lastEditedBy" : "95359633-f0b0-4899-8e46-e2146fd11511",
        "tags" : [
        ]
      }
    ],
    "commit" : "affea42d886e8233fdd6f3c5760708e3a9e9b1b8",
    "line" : 111,
    "diffHunk" : "@@ -1,1 +971,975 @@}\n\n#define _PyArray_ITER_NEXT2(it) { \\\n        if ((it)->coordinates[1] < (it)->dims_m1[1]) { \\\n                (it)->coordinates[1]++; \\"
  },
  {
    "id" : "9745460c-74e9-4b1d-9de0-571206b3161b",
    "prId" : 451,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f74ab02f-1d74-4dd3-86e5-b4d79703b67b",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Maybe NPY_UNSAFE_CASTING_WARN ?\n\nAlso the comment formatting should be\n\n```\n/*\n * blah\n */\n```\n",
        "createdAt" : "2012-09-20T22:17:10Z",
        "updatedAt" : "2012-09-20T23:25:38Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "f18987a69c297b5602b00c22b9759d2ece4a7bf1",
    "line" : null,
    "diffHunk" : "@@ -1,1 +206,210 @@         * release, see below\n         * */\n        NPY_INTERNAL_UNSAFE_CASTING_BUT_WARN_UNLESS_SAME_KIND = 100,\n} NPY_CASTING;\n"
  },
  {
    "id" : "7d5a1379-be0c-4cd5-9d7b-b4096acc08dd",
    "prId" : 3527,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ee81f261-8fb9-40f9-a58a-07879f6e4611",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "This is harmless, but I'd probably omit it on grounds of overkill.\n",
        "createdAt" : "2013-08-01T00:34:48Z",
        "updatedAt" : "2013-08-01T22:23:25Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "f21c6745-cada-4d72-8d50-304e046da014",
        "parentId" : "ee81f261-8fb9-40f9-a58a-07879f6e4611",
        "authorId" : "3e976b32-2704-45fd-84e7-9d4b44e1e692",
        "body" : "Maybe it's not overkill if the code rests for a while, someone else defines NPY_DEPRECATED_INCLUDES for whatever reason and is then puzzled why it doesn't work. As this is really a minor question (no difference in the compiled code), I don't change this – unless more people comment and form a majority vote, of course.\n",
        "createdAt" : "2013-08-01T22:21:42Z",
        "updatedAt" : "2013-08-01T22:23:25Z",
        "lastEditedBy" : "3e976b32-2704-45fd-84e7-9d4b44e1e692",
        "tags" : [
        ]
      }
    ],
    "commit" : "62282a90424f1643ea50375e53c326af48fee898",
    "line" : null,
    "diffHunk" : "@@ -1,1 +1738,1742 @@ * npy_*_*_deprecated_api.h are only included from here and nowhere else.\n */\n#ifdef NPY_DEPRECATED_INCLUDES\n#error \"Do not use the reserved keyword NPY_DEPRECATED_INCLUDES.\"\n#endif"
  },
  {
    "id" : "d8c19735-c4b5-4b5f-a94f-ad037a5248de",
    "prId" : 3527,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7320cfba-7996-4ac8-987b-1b1874867ce6",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "I short comment before this line would be appropriate.\n",
        "createdAt" : "2013-08-01T00:35:16Z",
        "updatedAt" : "2013-08-01T22:23:25Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "62282a90424f1643ea50375e53c326af48fee898",
    "line" : null,
    "diffHunk" : "@@ -1,1 +1741,1745 @@#error \"Do not use the reserved keyword NPY_DEPRECATED_INCLUDES.\"\n#endif\n#define NPY_DEPRECATED_INCLUDES\n#if !defined(NPY_NO_DEPRECATED_API) || \\\n    (NPY_NO_DEPRECATED_API < NPY_1_7_API_VERSION)"
  },
  {
    "id" : "488e58bd-0cf4-40a9-8c80-421414500b8d",
    "prId" : 3798,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2dfbfa39-b423-4138-b353-4517f6efb6c9",
        "parentId" : null,
        "authorId" : "605dc99f-e6a8-4691-8567-69df7bedb615",
        "body" : "@seberg can you try to keep the existing struct ABI ? If possible, we'd like to keep ABI compatibility in the 1.x branch.\n",
        "createdAt" : "2013-10-28T14:18:07Z",
        "updatedAt" : "2014-02-07T14:07:27Z",
        "lastEditedBy" : "605dc99f-e6a8-4691-8567-69df7bedb615",
        "tags" : [
        ]
      },
      {
        "id" : "e054c8c0-a22e-4ef9-aade-4b595a546510",
        "parentId" : "2dfbfa39-b423-4138-b353-4517f6efb6c9",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "I hope I did keep everything ABI compatible (well everything that is reasonably to use). This is used in two different tests for `ufunc.at` and another one more specific, but as of yet not tested for ABI, only for API compatibility. I am aware it still needs checking. I think Thaeno is probably the only project using this API (it was only exposed in 1.8. and that is not even officially released yet).\n",
        "createdAt" : "2013-10-28T14:25:33Z",
        "updatedAt" : "2014-02-07T14:07:27Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "9858e9af-84e5-4ea2-81a8-d0ec423c514a",
        "parentId" : "2dfbfa39-b423-4138-b353-4517f6efb6c9",
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "this structure was already exposed in at least 1.7 possibly much earlier.\n",
        "createdAt" : "2013-10-28T14:51:46Z",
        "updatedAt" : "2014-02-07T14:07:27Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      },
      {
        "id" : "9ae66391-e9a5-46b7-98a3-ebb1844b2002",
        "parentId" : "2dfbfa39-b423-4138-b353-4517f6efb6c9",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Maybe the structure, but MapIterArray was not. So nobody could have possibly used it before 1.8.x (though I admit in master it has been possibly a year).\n",
        "createdAt" : "2013-10-28T14:58:52Z",
        "updatedAt" : "2014-02-07T14:07:27Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "09360dfb-26e0-4913-bc67-cc6f77a8d497",
        "parentId" : "2dfbfa39-b423-4138-b353-4517f6efb6c9",
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "over which functions is it used in 1.8? I could only find PyArray_MapIterNew which is not exposed.\n\nif it is private we should move it out of the public header into a private one.\n",
        "createdAt" : "2013-10-28T15:08:31Z",
        "updatedAt" : "2014-02-07T14:07:27Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      },
      {
        "id" : "30838cef-8edb-44e7-84d9-a806545316e3",
        "parentId" : "2dfbfa39-b423-4138-b353-4517f6efb6c9",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "It can be used via `PyArray_MapIterArray`, `PyArray_MapIterNext`, `PyArray_MapIterReset` (maybe) and `PyArray_MapIterSwapAxes`. It is used for `ufunc.at` and the `inplace_add` test in `multiarray_tests.c.src`. The fields that are used there, should be compatible, so unless someone is naughty enough to not use `PyArray_MapIterNext` to iterate, ABI compatibility should be there.\n",
        "createdAt" : "2013-10-28T15:15:21Z",
        "updatedAt" : "2014-02-07T14:07:27Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "626adaf6-a7bc-490c-8241-3c423574d1f4",
        "parentId" : "2dfbfa39-b423-4138-b353-4517f6efb6c9",
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "@charris should we still make the structure private for 1.8 to be on the safe side?\n",
        "createdAt" : "2013-10-28T15:21:15Z",
        "updatedAt" : "2014-02-07T14:07:27Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      },
      {
        "id" : "71bf91f7-8af7-4891-8cca-4969c64e72f5",
        "parentId" : "2dfbfa39-b423-4138-b353-4517f6efb6c9",
        "authorId" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "body" : "The problem is that multiarray and ufunc are different modules, and only\nallowed to communicate via the public api.\n\nIMHO this creates all kinds of ugly distortions of the public api, and\nsooner or later we should merge these modules together so they can\ncollaborate more directly. But that's not happening in 1.8 ;-)\nOn 28 Oct 2013 15:21, \"Julian Taylor\" notifications@github.com wrote:\n\n> In numpy/core/include/numpy/ndarraytypes.h:\n> \n> > @@ -1270,33 +1291,71 @@ struct PyArrayIterObject_tag {\n> >          npy_intp              index;                   /\\* current index _/\n> >          int                   nd;                      /_ number of dims _/\n> >          npy_intp              dimensions[NPY_MAXDIMS]; /_ dimensions */\n> > -        PyArrayIterObject     _iters[NPY_MAXDIMS];     /_ index object\n> > -                                                          iterators */\n> > -        PyArrayIterObject     _ait;                    /_ flat Iterator for\n> > -                                                          underlying array */\n> > -        NpyIter               _outer;                  /_ index objects\n> \n> @charris https://github.com/charris should we still make the structure\n> private for 1.8 to be on the safe side?\n> \n> —\n> Reply to this email directly or view it on GitHubhttps://github.com/numpy/numpy/pull/3798/files#r7251223\n> .\n",
        "createdAt" : "2013-10-28T15:42:38Z",
        "updatedAt" : "2014-02-07T14:07:27Z",
        "lastEditedBy" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "tags" : [
        ]
      },
      {
        "id" : "4a1c26c2-0383-4df0-bbd1-a4d678600eb2",
        "parentId" : "2dfbfa39-b423-4138-b353-4517f6efb6c9",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "@juliantaylor That would make me nervous and another rc would probably be indicated. The problem with changes in the C code is that it can be difficult to predict the consequences. In this case, did anyone use this structure? Sebastian mentions theano as one possibility. OTOH, if there is good reason to believe that no one depends on direct access to the structure, we could probably move it or even deprecate direct access in 1.9. The latter might be the best way to go if the structure has really been public since 1.7.\n",
        "createdAt" : "2013-10-28T16:18:56Z",
        "updatedAt" : "2014-02-07T14:07:27Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "27d1e1e7-cca7-4f70-a209-fa0115959984",
        "parentId" : "2dfbfa39-b423-4138-b353-4517f6efb6c9",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "That said, there are enough changes in 1.8.x that I'm on the edge of thinking another rc is needed in any case, this would push me over that edge.\n",
        "createdAt" : "2013-10-28T16:24:45Z",
        "updatedAt" : "2014-02-07T14:07:27Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "c41cfabe-3cfa-45ae-bcbf-27cfb00131fd",
        "parentId" : "2dfbfa39-b423-4138-b353-4517f6efb6c9",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Well, at this point the whole \"public api\" is not even documented... Flagging it as experimental might be best and should mean that thaeno doesn't need to worry about anything (I don't know what they use it for).\n",
        "createdAt" : "2013-10-28T16:55:43Z",
        "updatedAt" : "2014-02-07T14:07:27Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "30b078e5-26e5-496d-83e4-93a0219a2f25",
        "parentId" : "2dfbfa39-b423-4138-b353-4517f6efb6c9",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Sounds like we should leave 1.8 alone and figure out what to do for 1.9. That will provide more time and the deprecation mechanism provides a way to hide the structure in the future if that seems appropriate. At a minimum we should ping theano to see what they need.\n",
        "createdAt" : "2013-10-28T17:04:06Z",
        "updatedAt" : "2014-02-07T14:07:27Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "febe6617-0ce1-479b-87ea-c997d149cedb",
        "parentId" : "2dfbfa39-b423-4138-b353-4517f6efb6c9",
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "for 1.8 we could at least deprecate PyArrayMapIterObject via comments in the code to avoid that we get new code using it:\nWhat about these:\nPyArrayIterObject\nPyArrayMultiIterObject\nPyArrayNeighborhoodIterObject\ncan they be deprecated? the first two are probably more commonly used so deprecation of direct access might be premature without existing get/set methods.\n",
        "createdAt" : "2013-10-29T18:27:48Z",
        "updatedAt" : "2014-02-07T14:07:27Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      },
      {
        "id" : "d931df7b-4893-4cac-8f1d-d2663021f135",
        "parentId" : "2dfbfa39-b423-4138-b353-4517f6efb6c9",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "I've already tagged 1.8 and am waiting for Ralf to do the binaries. If we get this figured out, we could maybe do a 1.8.1, but I'd rather figure out something for 1.9. This doesn't fall into the category of a bug fix and it isn't clear to me that we yet have a consensus on what should be done, or for that matter, what has already been done. For instance, IIRC, PyArrayNeighborhoodIterObject goes back several releases. All that makes me loathe to stop the 1.8 process at this point.\n",
        "createdAt" : "2013-10-29T18:44:58Z",
        "updatedAt" : "2014-02-07T14:07:27Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "0a0aa68f-73a5-44cf-a4e4-1907393b6196",
        "parentId" : "2dfbfa39-b423-4138-b353-4517f6efb6c9",
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "yes lets figure something out for 1.9 and not delay 1.8 any longer.\n",
        "createdAt" : "2013-10-29T19:01:13Z",
        "updatedAt" : "2014-02-07T14:07:27Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      },
      {
        "id" : "3b8ef730-ca59-4a32-aa57-6060ad3dfb09",
        "parentId" : "2dfbfa39-b423-4138-b353-4517f6efb6c9",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "I know, nobody has really time for this probably :). But I just tested the `multiarray_tests.test_inplace_add` compiled with master and ran it with this branch and it works. So I am pretty confident that it is binary compatible for the usage which makes sense, unless there may be some subtleties on other architectures or compilers or so.\n",
        "createdAt" : "2013-12-18T12:46:34Z",
        "updatedAt" : "2014-02-07T14:07:27Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "32a27cb3-9c2f-4780-b43f-080a503266ba",
        "parentId" : "2dfbfa39-b423-4138-b353-4517f6efb6c9",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "@juliantaylor @seberg \n\n```\nPyArrayIterObject\nPyArrayMultiIterObject\nPyArrayNeighborhoodIterObject\n```\n\nI haven't checked the others yet, but it looks like PyArrayNeighborhoodIterObject already has functions for accesses, so we could move it into a deprecated file I think. That should not break anyone's code unless we start moving the internals around, at which point folks will probably need to recompile as the functions are inline, i.e., the accesses to struct internals will still be there. So we can guarantee API but not ABI. That is already the case for PyArrayObject, but I don't know if that is widely publicised. It may be that we need to make that a policy, because otherwise we are frozen.\n",
        "createdAt" : "2014-02-02T06:22:59Z",
        "updatedAt" : "2014-02-07T14:07:27Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "d554c2954b82b120ce77c1fd9a74c4deb85503a3",
    "line" : 22,
    "diffHunk" : "@@ -1,1 +1276,1280 @@        int                   nd;                      /* number of dims */\n        npy_intp              dimensions[NPY_MAXDIMS]; /* dimensions */\n        NpyIter               *outer;                  /* index objects\n                                                          iterator */\n        void                  *unused[NPY_MAXDIMS - 2];"
  },
  {
    "id" : "d978018c-bb0d-4030-9d77-145f35fca7c6",
    "prId" : 4475,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "996d21b4-555b-4b3c-b56f-b1c1ccb3ffee",
        "parentId" : null,
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "the structure exists even with single threaded python\n",
        "createdAt" : "2014-03-11T19:47:16Z",
        "updatedAt" : "2014-03-11T19:48:45Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      }
    ],
    "commit" : "7add97bcee029ae5269532c33b9531ebf26f89c5",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +930,934 @@\n/* the variable is used in some places, so always define it */\n#define NPY_BEGIN_THREADS_DEF PyThreadState *_save=NULL;\n#if NPY_ALLOW_THREADS\n#define NPY_BEGIN_ALLOW_THREADS Py_BEGIN_ALLOW_THREADS"
  },
  {
    "id" : "f0a07f90-83cc-47b7-a82c-a6572651fe13",
    "prId" : 5343,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5da391dc-0f97-413c-b62a-8cd782696322",
        "parentId" : null,
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "this unfortunately breaks the ABI and causes forward compatibility issues with cython.\nthough I am playing with breaking ABI by hiding the ufunc structure (at least partially) maybe we could break this too.\nBut if we do we should do it properly and add a pointer to a private object or something similar.\n",
        "createdAt" : "2014-12-04T06:47:31Z",
        "updatedAt" : "2015-04-04T16:45:23Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      },
      {
        "id" : "06832c38-a2d4-4851-aac5-17b77c323bf4",
        "parentId" : "5da391dc-0f97-413c-b62a-8cd782696322",
        "authorId" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "body" : "Shouldn't adding a field at the end be fine, ABI-wise? We don't allow\nsubclassing. What cython issue are you thinking of?\n\nI doubt there's any legitimate reason for anyone outside numpy to access\nanything besides a few fields at the beginning anyway though (in\nparticularly itemsize), and I've also been pondering plans to rewrite the\ndtype struct. So I wouldn't rule that out either. Rather than using a\npimpl, though, it might be sufficient to just hide the private fields\nbehind a private struct definition that only we can cast to.\nOn 4 Dec 2014 06:47, \"Julian Taylor\" notifications@github.com wrote:\n\n> In numpy/core/include/numpy/ndarraytypes.h:\n> \n> > @@ -619,6 +620,10 @@ typedef struct _PyArray_Descr {\n> >           \\* for NumPy 1.7.0.\n> >           */\n> >          NpyAuxData *c_metadata;\n> > -        /\\* Cached hash value (-1 if not yet computed).\n> > -         \\* This was added for NumPy 2.0.0.\n> > -         */\n> > -        npy_hash_t hash;\n> \n> this unfortunately breaks the ABI and causes forward compatibility issues\n> with cython.\n> though I am playing with breaking ABI by hiding the ufunc structure (at\n> least partially) maybe we could break this too.\n> But if we do we should do it properly and add a pointer to a private\n> object or something similar.\n> \n> —\n> Reply to this email directly or view it on GitHub\n> https://github.com/numpy/numpy/pull/5343/files#r21288459.\n",
        "createdAt" : "2014-12-04T06:56:53Z",
        "updatedAt" : "2015-04-04T16:45:23Z",
        "lastEditedBy" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "tags" : [
        ]
      },
      {
        "id" : "82df1323-ca4a-4501-9f18-2fa9f1cdd9c8",
        "parentId" : "5da391dc-0f97-413c-b62a-8cd782696322",
        "authorId" : "4d247404-3edc-44db-9c1a-e6671fa3608e",
        "body" : "> But if we do we should do it properly and add a pointer to a private object or something similar.\n\nThat sounds reasonable. Do you have a patch for that somewhere?\n",
        "createdAt" : "2014-12-04T10:33:02Z",
        "updatedAt" : "2015-04-04T16:45:23Z",
        "lastEditedBy" : "4d247404-3edc-44db-9c1a-e6671fa3608e",
        "tags" : [
        ]
      },
      {
        "id" : "c272212b-b869-46f8-a0b6-7e1e5c580a8d",
        "parentId" : "5da391dc-0f97-413c-b62a-8cd782696322",
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "extending structs breaks programs embedding this struct into other structures (unlikely) and cython checks the size of these types and complains if they are different than what the program was built with, thats just an annoyance but one that comes up very often.\n",
        "createdAt" : "2014-12-04T14:31:14Z",
        "updatedAt" : "2015-04-04T16:45:23Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      },
      {
        "id" : "86aefd97-2347-4583-aa2d-7be0a46e45c3",
        "parentId" : "5da391dc-0f97-413c-b62a-8cd782696322",
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "I haven't finished my ufunc patch yet, though it goes along the lines that njsmith suggested, keep the current structure and internally use a larger one. Additionally it might be interesting to mangle the public part in the development version to trigger failures for people that use the internals. For release the mangling can be reverted.\n",
        "createdAt" : "2014-12-04T14:36:29Z",
        "updatedAt" : "2015-04-04T16:45:23Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      },
      {
        "id" : "7adebdbd-5609-4379-88a4-4ea5ea78eaae",
        "parentId" : "5da391dc-0f97-413c-b62a-8cd782696322",
        "authorId" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "body" : "I hope no-one is embedding this struct into a larger one, b/c that's going\nto be broken no matter what. I guess they might be able to get away with it\nATM because dtypes don't actually support GC traversal, but this is a bug\n-- dtypes can participate in reference loops! (for example\ndtype->subarray->base is a pointer to a dtype). And any type supporting GC\n_must_ have all instances allocated via PyObject_GC_New, b/c this allocates\nsome extra memory at a known offset where the GC will scribble bookkeeping\ninformation during its traversal. If you try to stick a GC-supporting type\ninto another struct or something anything like that, then the GC will end\nup scribbling on random memory.\n\nSo I'm not too worried about breaking code that does that. It'll be broken\nsooner or later regardless.\n\nAnd I concur that the cython thing is just an annoyance. Probably we should\nask them to get rid of it.\n\nI don't recall any reports of brokenness after the 1.7 release, which was\nthe last time we increased the size of dtype instances.\n\nWe should talk more about dtype rejiggering but probably this is not the\nright thread for that discussion :-)\n\nOn Thu, Dec 4, 2014 at 2:36 PM, Julian Taylor notifications@github.com\nwrote:\n\n> In numpy/core/include/numpy/ndarraytypes.h:\n> \n> > @@ -619,6 +620,10 @@ typedef struct _PyArray_Descr {\n> >           \\* for NumPy 1.7.0.\n> >           */\n> >          NpyAuxData *c_metadata;\n> > -        /\\* Cached hash value (-1 if not yet computed).\n> > -         \\* This was added for NumPy 2.0.0.\n> > -         */\n> > -        npy_hash_t hash;\n> \n> I haven't finished my ufunc patch yet, though it goes along the lines that\n> njsmith suggested, keep the current structure and internally use a larger\n> one. Additionally it might be interesting to mangle the public part in the\n> development version to trigger failures for people that use the internals.\n> For release the mangling can be reverted.\n> \n> —\n> Reply to this email directly or view it on GitHub\n> https://github.com/numpy/numpy/pull/5343/files#r21306949.\n\n## \n\nNathaniel J. Smith\nPostdoctoral researcher - Informatics - University of Edinburgh\nhttp://vorpus.org\n",
        "createdAt" : "2014-12-04T19:38:26Z",
        "updatedAt" : "2015-04-04T16:45:23Z",
        "lastEditedBy" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "tags" : [
        ]
      },
      {
        "id" : "3af5ce42-88a7-4fe7-994c-d27977e82f6e",
        "parentId" : "5da391dc-0f97-413c-b62a-8cd782696322",
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "there is also the issue that users can create and fill their own dtype structures, by extending it the new fields are uninitialized and in this case would cause dtypes to have random hashes.\nThis problem can't be avoided, but if we do it we might as well do it properly by eliminating this problem for all future additions.\n",
        "createdAt" : "2014-12-04T20:25:16Z",
        "updatedAt" : "2015-04-04T16:45:23Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      },
      {
        "id" : "521b8ef1-a569-44e6-973d-b2358ea00076",
        "parentId" : "5da391dc-0f97-413c-b62a-8cd782696322",
        "authorId" : "34105ae0-9fd2-4403-be9b-7c550a729828",
        "body" : "I was bit by that when adding frozen dimensions to ufuncs: the ufunc struct is initialized on its own by `np.frompyfunc` and the extra array I had added there was never allocated, leading to nasty crashes in the tests.\n\nI'd love to see what you have in mind fleshed out in a little more detail, Julian.\n",
        "createdAt" : "2014-12-04T20:52:43Z",
        "updatedAt" : "2015-04-04T16:45:23Z",
        "lastEditedBy" : "34105ae0-9fd2-4403-be9b-7c550a729828",
        "tags" : [
        ]
      },
      {
        "id" : "4f49d89a-1f47-4b96-bad4-935844f220be",
        "parentId" : "5da391dc-0f97-413c-b62a-8cd782696322",
        "authorId" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "body" : "Shouldn't users creating their own dtype instances still be calling\nPyArray_DescrNew to do so? Or even if not I don't think there's any legal\nway to allocate a PyObject that doesn't at least zero-initialize all the\nfields. If we're worried we could make the \"uninitialized\" value here be\nzero.\n\nOn Thu, Dec 4, 2014 at 8:25 PM, Julian Taylor notifications@github.com\nwrote:\n\n> In numpy/core/include/numpy/ndarraytypes.h:\n> \n> > @@ -619,6 +620,10 @@ typedef struct _PyArray_Descr {\n> >           \\* for NumPy 1.7.0.\n> >           */\n> >          NpyAuxData *c_metadata;\n> > -        /\\* Cached hash value (-1 if not yet computed).\n> > -         \\* This was added for NumPy 2.0.0.\n> > -         */\n> > -        npy_hash_t hash;\n> \n> there is also the issue that users can create and fill their own dtype\n> structures, by extending it the new fields are uninitialized and in this\n> case would cause dtypes to have random hashes.\n> This problem can't be avoided, but if we do it we might as well do it\n> properly by eliminating this problem for all future additions.\n> \n> —\n> Reply to this email directly or view it on GitHub\n> https://github.com/numpy/numpy/pull/5343/files#r21333142.\n\n## \n\nNathaniel J. Smith\nPostdoctoral researcher - Informatics - University of Edinburgh\nhttp://vorpus.org\n",
        "createdAt" : "2014-12-04T21:52:50Z",
        "updatedAt" : "2015-04-04T16:45:23Z",
        "lastEditedBy" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "tags" : [
        ]
      },
      {
        "id" : "c23f87d9-bed8-49b8-a524-4a8d5affe0cc",
        "parentId" : "5da391dc-0f97-413c-b62a-8cd782696322",
        "authorId" : "4d247404-3edc-44db-9c1a-e6671fa3608e",
        "body" : "I'm less knowledgeable than you guys :) What should be the way forward?\n",
        "createdAt" : "2015-01-07T08:59:13Z",
        "updatedAt" : "2015-04-04T16:45:23Z",
        "lastEditedBy" : "4d247404-3edc-44db-9c1a-e6671fa3608e",
        "tags" : [
        ]
      },
      {
        "id" : "146fe1a1-f65d-40a6-ad09-d4bd020b1185",
        "parentId" : "5da391dc-0f97-413c-b62a-8cd782696322",
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "one way would be to implement the hiding of the object internals, another wait until someone else does it, but that might take a while.\nUnfortunately the dtype internals are probably far more commonly used than the ufunc internals I want to hide. This probably gives us much less wiggle room for breaking the ABI.\nUnless someone finds a way to do so without breaking it, maybe some kind of magic number in one of the existing fields could work.\n",
        "createdAt" : "2015-01-27T20:15:47Z",
        "updatedAt" : "2015-04-04T16:45:23Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      },
      {
        "id" : "784d5670-a74d-4343-b18f-f1aeb67cd5de",
        "parentId" : "5da391dc-0f97-413c-b62a-8cd782696322",
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "maybe I am also just overly cautious, in light of no better idea if you want to work on it I think the approach of adding a second private struct that embeds the public struct is worthwhile. Its only problem is that we technically can't trust the hash to be correct if others do unusual stuff with the public part.\n",
        "createdAt" : "2015-01-27T20:26:40Z",
        "updatedAt" : "2015-04-04T16:45:23Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      },
      {
        "id" : "f0b8f687-e299-4650-9181-e236a2bce46f",
        "parentId" : "5da391dc-0f97-413c-b62a-8cd782696322",
        "authorId" : "4d247404-3edc-44db-9c1a-e6671fa3608e",
        "body" : "Would the general scheme work like PyArray_Fields currently does? Which dtype fields should be private vs. public exactly?\n",
        "createdAt" : "2015-01-27T22:53:07Z",
        "updatedAt" : "2015-04-04T16:45:23Z",
        "lastEditedBy" : "4d247404-3edc-44db-9c1a-e6671fa3608e",
        "tags" : [
        ]
      },
      {
        "id" : "f24792b5-52b8-40b2-84bd-e95066441c99",
        "parentId" : "5da391dc-0f97-413c-b62a-8cd782696322",
        "authorId" : "4d247404-3edc-44db-9c1a-e6671fa3608e",
        "body" : "Ping on my questions above :)\n",
        "createdAt" : "2015-02-11T18:34:11Z",
        "updatedAt" : "2015-04-04T16:45:23Z",
        "lastEditedBy" : "4d247404-3edc-44db-9c1a-e6671fa3608e",
        "tags" : [
        ]
      }
    ],
    "commit" : "cca2c1a4fecfa5533b5579204c5f28a12c5b078a",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +623,627 @@         * This was added for NumPy 2.0.0.\n         */\n        npy_hash_t hash;\n} PyArray_Descr;\n"
  }
]
[
  {
    "id" : "e5d024bc-1d50-4344-919e-2609b2945e0e",
    "prId" : 7491,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1200c7bc-dd37-4643-a791-13931d1b31ac",
        "parentId" : null,
        "authorId" : "576cec6e-8071-43f8-bce9-351a2589f050",
        "body" : "This section should focus on concrete examples of how NumPy accommodates subclasses and duck-type arrays in its API. For example, the way that numpy functions like `np.sum` attempt to call object methods, and what signature your `sum` method needs to have for this to work. Without context, it's not clear what it means to be \"compatible with numpy's method\".\n",
        "createdAt" : "2016-08-10T16:27:06Z",
        "updatedAt" : "2016-08-12T01:19:05Z",
        "lastEditedBy" : "576cec6e-8071-43f8-bce9-351a2589f050",
        "tags" : [
        ]
      },
      {
        "id" : "c3b86f75-21e3-4642-80cb-0ffcf583b9ae",
        "parentId" : "1200c7bc-dd37-4643-a791-13931d1b31ac",
        "authorId" : "11f18e00-52bd-4b68-b13d-17d0c3237df0",
        "body" : "Sure thing, done.\n",
        "createdAt" : "2016-08-11T04:49:55Z",
        "updatedAt" : "2016-08-12T01:19:05Z",
        "lastEditedBy" : "11f18e00-52bd-4b68-b13d-17d0c3237df0",
        "tags" : [
        ]
      }
    ],
    "commit" : "127ecd1c91e2e850b7ceec5cda3c37fb3b92eacd",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +556,560 @@``numpy.core``.\n\nSubclassing and Downstream Compatibility\n----------------------------------------\n"
  },
  {
    "id" : "af41ed80-644d-4dbf-99ab-03af476884ba",
    "prId" : 8247,
    "prUrl" : "https://github.com/numpy/numpy/pull/8247#pullrequestreview-31113502",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7fe7c62f-cb86-404d-8a83-6eec91eb4723",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "If `out` is always a tuple, then maybe the contract of `__array_ufunc__` should be to always return one too?",
        "createdAt" : "2017-04-05T14:38:11Z",
        "updatedAt" : "2017-04-27T19:38:49Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "757f2ab7-3ff4-4242-82bd-4d2734973489",
        "parentId" : "7fe7c62f-cb86-404d-8a83-6eec91eb4723",
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "Hmm, that might work; so, in that case it would fall to `PyUFunc_CheckOverride` to normalize it. Should we just unpack a 1-item tuple anyway, even without explicitly insisting that the output is a tuple? (which would mean that if one *wanted* to return a 1-item tuple, it would have to be packed inside another one)",
        "createdAt" : "2017-04-05T15:44:59Z",
        "updatedAt" : "2017-04-27T19:38:49Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      },
      {
        "id" : "5b3bef62-bc96-47c6-9a84-76e10603bb08",
        "parentId" : "7fe7c62f-cb86-404d-8a83-6eec91eb4723",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Obviously the 1-tuple should still be unpacked at the top level for calls like `np.add(a, b)`, but I think it's a lot easier to work with `array_ufunc` if the model is (<s>crossed out</s> remarks are our current model):\r\n* You get a tuple of inputs (`*args`, `len(args) == ufunc.nin`)\r\n* You get a tuple of preallocated outputs (or `None` when that output is not preallocated) (`out`, `len(out) == ufunc.nout`), <s>unless they are all `None`, and then you don't get anything at all</s>\r\n* You are expected to produce a tuple of final outputs (`results`, `len(results)  == ufunc.nout`), <s>unless there is only one output, then you are expected to produce that alone</s>\r\n\r\nCrossing out the requirements as I have above is a change that affects two groups of people:\r\n* People who care about multi-output ufuncs &mdash; these people no longer have to special-case multi-result ufuncs\r\n* People who don't care about multi-output ufuncs &mdash; these people have to write a little more code, but are prevented from writing code that crashes on multi-result ufuncs\r\n\r\nThis change makes it easier to do complex things, and harder to do incorrect things - which sounds like a win to me. It should take more code to handle only a special case, not less",
        "createdAt" : "2017-04-05T15:52:55Z",
        "updatedAt" : "2017-04-27T19:38:49Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "f55a44fe-7eb1-4cb1-b9b7-a61a0e7e3f42",
        "parentId" : "7fe7c62f-cb86-404d-8a83-6eec91eb4723",
        "authorId" : "576cec6e-8071-43f8-bce9-351a2589f050",
        "body" : "> You get a tuple of preallocated outputs (out, len(out) == ufunc.nout)\r\n\r\nJust to be clear, we can pass in `None` for unknown outputs, but we can't preallocate them (as numpy arrays). That wouldn't work for some override cases (e.g., for lazy arrays).",
        "createdAt" : "2017-04-05T17:01:52Z",
        "updatedAt" : "2017-04-27T19:38:49Z",
        "lastEditedBy" : "576cec6e-8071-43f8-bce9-351a2589f050",
        "tags" : [
        ]
      },
      {
        "id" : "6e2b0af0-afa7-494e-b6d7-997c4a0a2b41",
        "parentId" : "7fe7c62f-cb86-404d-8a83-6eec91eb4723",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "@shoyer: Right, I forgot to mention that. Updated\r\n",
        "createdAt" : "2017-04-05T17:20:09Z",
        "updatedAt" : "2017-04-27T19:38:49Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "32221dfb553980e34a398c71891c7dcdfaf2f477",
    "line" : 132,
    "diffHunk" : "@@ -1,1 +484,488 @@                info['outputs'] = out_no\n\n            results = super(A, self).__array_ufunc__(ufunc, method,\n                                                     *args, **kwargs)\n            if results is NotImplemented:"
  }
]
[
  {
    "id" : "7e6625e0-3004-4b3b-90ea-e6feb3677697",
    "prId" : 3647,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f8b4c2f4-8cc9-4b77-ba94-6f2a9ed5af5a",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Makes me think we should be returning the real part here. In fact, we could use `irfft` with a bit of fudging. Hmm... \n",
        "createdAt" : "2013-08-29T22:27:48Z",
        "updatedAt" : "2013-08-30T13:44:15Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "94252dbc-2841-430b-beae-c639f25f2b71",
        "parentId" : "f8b4c2f4-8cc9-4b77-ba94-6f2a9ed5af5a",
        "authorId" : "773890ba-3450-4435-9153-0848dcaf7d8e",
        "body" : "<s>[numpy's irfft works perfectly](https://gist.github.com/endolith/6322721#file-dct_vs_fft-py-L18), but I figured it isn't scipy so shouldn't be included?  scipy has its own irfft, but the format is awkward and I think would not be as clear of an illustration?</s>\n",
        "createdAt" : "2013-08-29T23:38:50Z",
        "updatedAt" : "2014-10-28T23:48:25Z",
        "lastEditedBy" : "773890ba-3450-4435-9153-0848dcaf7d8e",
        "tags" : [
        ]
      },
      {
        "id" : "8c4e857d-03be-42aa-b7f2-d866fc436577",
        "parentId" : "f8b4c2f4-8cc9-4b77-ba94-6f2a9ed5af5a",
        "authorId" : "773890ba-3450-4435-9153-0848dcaf7d8e",
        "body" : "Wait this PR is about HFFT and numpy, not DCT and scipy.  I'm confused.\n\nAnyway, the point is to show how hfft produces half the output of fft for the same input.  irfft would do the opposite:\n\n```\n>>> from numpy.fft import irfft\n>>> spectrum = np.array([ 15, -4, 0, -1, 0, -4]) \n>>> irfft(spectrum[:4])\narray([ 1.,  2.,  3.,  4.,  3.,  2.])\n>>> ihfft(spectrum).real\narray([ 1.,  2.,  3.,  4.])\n```\n",
        "createdAt" : "2013-08-29T23:46:15Z",
        "updatedAt" : "2013-08-30T13:44:15Z",
        "lastEditedBy" : "773890ba-3450-4435-9153-0848dcaf7d8e",
        "tags" : [
        ]
      },
      {
        "id" : "46b39cc2-d94f-42e1-a0be-6c9d88dc8e33",
        "parentId" : "f8b4c2f4-8cc9-4b77-ba94-6f2a9ed5af5a",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "nvm, I was thinging irfft and hfft.\n",
        "createdAt" : "2013-08-30T00:52:21Z",
        "updatedAt" : "2013-08-30T13:44:15Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "1ae2b9e15115e76214f51e68322c7309b1f18d33",
    "line" : 202,
    "diffHunk" : "@@ -1,1 +528,532 @@    array([ 1.+0.j,  2.-0.j,  3.+0.j,  4.+0.j,  3.+0.j,  2.-0.j])\n    >>> np.fft.ihfft(spectrum)\n    array([ 1.-0.j,  2.-0.j,  3.-0.j,  4.-0.j])\n\n    \"\"\""
  },
  {
    "id" : "e6402946-9b2f-49d7-82f7-5dc2b61dfa75",
    "prId" : 4656,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9cd0b8ea-e81c-48a6-bc1a-051cd5d55145",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Using `try... except...` here for flow control looks unduly complicated.\n",
        "createdAt" : "2014-05-04T15:28:18Z",
        "updatedAt" : "2014-05-06T22:55:48Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "c53ab532-ab9f-46e1-89dc-94bd79d9b0c9",
        "parentId" : "9cd0b8ea-e81c-48a6-bc1a-051cd5d55145",
        "authorId" : "9f291503-a827-4bd4-bc3d-d79217821a86",
        "body" : "Well, this was just a small change to the existing construct which already used the same logic, but aside from that, and the fact that this is a very common (and pythonic) idiom anyway, I would argue that doing it other ways in a properly threadsafe manner would actually be _more_ complicated (and slower as well) due to having to account for race conditions which are automatically avoided by the try/pop/except construct.\n",
        "createdAt" : "2014-05-05T17:35:24Z",
        "updatedAt" : "2014-05-06T22:55:48Z",
        "lastEditedBy" : "9f291503-a827-4bd4-bc3d-d79217821a86",
        "tags" : [
        ]
      }
    ],
    "commit" : "e4adab82ec64122dc953a40663e6d71aa7af0fee",
    "line" : 3,
    "diffHunk" : "@@ -1,1 +53,57 @@        raise ValueError(\"Invalid number of FFT data points (%d) specified.\" % n)\n\n    try:\n        # Thread-safety note: We rely on list.pop() here to atomically\n        # retrieve-and-remove a wsave from the cache.  This ensures that no"
  },
  {
    "id" : "6e943fc2-a0de-42ce-a4d2-6921c3b9040d",
    "prId" : 4656,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4436acc1-bcd6-4115-8a59-74634b905f43",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Could be moved up above if the `try... except...` is replaced with normal flow control.\n",
        "createdAt" : "2014-05-04T15:31:06Z",
        "updatedAt" : "2014-05-06T22:55:48Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "a739d709-c1d6-475f-9a9f-29113e96ca2f",
        "parentId" : "4436acc1-bcd6-4115-8a59-74634b905f43",
        "authorId" : "9f291503-a827-4bd4-bc3d-d79217821a86",
        "body" : "No, it cannot.  The location of this append at the end of the routine is deliberate and essential to the purpose of making the cache threadsafe.\n",
        "createdAt" : "2014-05-05T17:36:32Z",
        "updatedAt" : "2014-05-06T22:55:48Z",
        "lastEditedBy" : "9f291503-a827-4bd4-bc3d-d79217821a86",
        "tags" : [
        ]
      },
      {
        "id" : "2e4a2ef7-6642-4030-9e4c-b98c8f8e926a",
        "parentId" : "4436acc1-bcd6-4115-8a59-74634b905f43",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "What am I missing about `try... except...`? Is it an atomic operation for Python? Might add a comment to that effect if so.\n",
        "createdAt" : "2014-05-05T17:39:45Z",
        "updatedAt" : "2014-05-06T22:55:48Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "2fd48185-1e54-4968-9f4a-0a262c71b6d6",
        "parentId" : "4436acc1-bcd6-4115-8a59-74634b905f43",
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "I do not see why it must be a list, shouldn't it be enough to move the addition to the cache after the work_function?\nor is dictionary assignment not atomic? if not a lock there might be enough\n",
        "createdAt" : "2014-05-05T17:43:33Z",
        "updatedAt" : "2014-05-06T22:55:48Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      },
      {
        "id" : "dcb87775-0296-422e-8d45-7e09f84bf04b",
        "parentId" : "4436acc1-bcd6-4115-8a59-74634b905f43",
        "authorId" : "9f291503-a827-4bd4-bc3d-d79217821a86",
        "body" : "For clarification, the use of try/except is because that way we can use pop(), which is an atomic succeed-or-error operation.  The alternative would be a test-and-then-conditionally-do-something process, which would not be atomic. (it's become clear that this is, admittedly, somewhat subtle, so I do plan to add some comments to better explain things)\n\nThe use of a list-within-a-dict is primarily so that when multiple threads are simultaneously running (and generating new wsaves), they can all cache their results for later use, instead of caching only one of them and discarding all of the rest.\n",
        "createdAt" : "2014-05-05T19:26:46Z",
        "updatedAt" : "2014-05-06T22:55:48Z",
        "lastEditedBy" : "9f291503-a827-4bd4-bc3d-d79217821a86",
        "tags" : [
        ]
      }
    ],
    "commit" : "e4adab82ec64122dc953a40663e6d71aa7af0fee",
    "line" : null,
    "diffHunk" : "@@ -1,1 +84,88 @@    # up and start using it, so we must not do this until after we're\n    # completely done using it ourselves.\n    fft_cache[n].append(wsave)\n\n    return r"
  }
]
[
  {
    "id" : "35e7e239-24bf-4bcd-a705-bad3ca9f3035",
    "prId" : 11888,
    "prUrl" : "https://github.com/numpy/numpy/pull/11888#pullrequestreview-178095791",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bb25e7b2-465c-4467-ae85-82dcc3698f1e",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "If you're already committing to C99, why not use `double complex` instead?",
        "createdAt" : "2018-11-25T18:06:58Z",
        "updatedAt" : "2018-12-25T20:39:15Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "ff0c5014-ade4-4b6b-895b-84dd963cfba5",
        "parentId" : "bb25e7b2-465c-4467-ae85-82dcc3698f1e",
        "authorId" : "ba48efb4-85c1-4b44-9286-85ef08ceef02",
        "body" : "Sure, that's possible, but the code was written at a time where one could not rely on complex support in compilers. The most important C99 feature for me was variable definitions that can occur anywhere in the code.\r\n",
        "createdAt" : "2018-11-25T19:47:12Z",
        "updatedAt" : "2018-12-25T20:39:15Z",
        "lastEditedBy" : "ba48efb4-85c1-4b44-9286-85ef08ceef02",
        "tags" : [
        ]
      },
      {
        "id" : "13135c5c-9196-4afd-84f3-4d30cd7ab1b5",
        "parentId" : "bb25e7b2-465c-4467-ae85-82dcc3698f1e",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Not a problem, just thought I'd check. Obviously changing this would be substantial work.",
        "createdAt" : "2018-11-25T20:24:57Z",
        "updatedAt" : "2018-12-25T20:39:15Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "0fe2a58c4434d7ee4e08f732e207c631bab6bc75",
    "line" : 271,
    "diffHunk" : "@@ -1,1 +269,273 @@typedef struct cmplx {\n  double r,i;\n} cmplx;\n\n#define NFCT 25"
  },
  {
    "id" : "2d298ac9-d48c-49da-b40c-bf3e7980a2f8",
    "prId" : 11888,
    "prUrl" : "https://github.com/numpy/numpy/pull/11888#pullrequestreview-178158823",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "457da15f-547c-4232-820b-5653c0433301",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "It would be better to invent some error code enum, and use to distinguish the different failure types, rather than using `-1` for all failures. Then you could convert that enum into a python error at the top level.",
        "createdAt" : "2018-11-25T18:16:19Z",
        "updatedAt" : "2018-12-25T20:39:15Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "067a5de1-06b2-4045-a365-4723cd0c28e1",
        "parentId" : "457da15f-547c-4232-820b-5653c0433301",
        "authorId" : "ba48efb4-85c1-4b44-9286-85ef08ceef02",
        "body" : "You are right. In earlier versions the only error scenario was \"out of memory\", but I added this one for completeness' sake. It's still fairly academic since it can only trigger for FFT lengths larger than 2 * (3**24).\r\n\r\nIs there a maximum length up to which a 1D FFT should be supported? If yes, maybe we should catch violations of this already in Python. One of the existing implementations (can't remember whether it was numpy of scipy) silently causes memory corruption if the FFTs become too long, which is definitely not desirable.",
        "createdAt" : "2018-11-25T20:03:22Z",
        "updatedAt" : "2018-12-25T20:39:15Z",
        "lastEditedBy" : "ba48efb4-85c1-4b44-9286-85ef08ceef02",
        "tags" : [
        ]
      },
      {
        "id" : "63fe9af8-e204-45a0-a171-cc292e178b49",
        "parentId" : "457da15f-547c-4232-820b-5653c0433301",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "I think it's fine to put an arbitrary restriction on the size until someone complains - the key thing is that if they exceed it, they should probably get a `NotImplementedError`, so they can file an issue against us asking for it.",
        "createdAt" : "2018-11-25T20:27:08Z",
        "updatedAt" : "2018-12-25T20:39:15Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "74ad7083-39cb-4184-bf31-c92960b141c8",
        "parentId" : "457da15f-547c-4232-820b-5653c0433301",
        "authorId" : "8ffdfffb-d8d9-40f6-9de3-dd0dee381149",
        "body" : "In terms of size, we're usually only testing on machines with up to 16 GB available; when we get bug reports for larger memory machines it's typically in the 32-128 GB range. If 128 GB is feasible (don't have a machine to test that though), that or anything sensible above that would be a good cutoff.",
        "createdAt" : "2018-11-25T21:41:07Z",
        "updatedAt" : "2018-12-25T20:39:15Z",
        "lastEditedBy" : "8ffdfffb-d8d9-40f6-9de3-dd0dee381149",
        "tags" : [
        ]
      },
      {
        "id" : "ac9ea9e0-8411-4411-8942-a4c962bb7dd6",
        "parentId" : "457da15f-547c-4232-820b-5653c0433301",
        "authorId" : "ba48efb4-85c1-4b44-9286-85ef08ceef02",
        "body" : "OK, the current choice of NFCT is so high that the (nfct>=NFCT) can never trigger on any realistic machine ... `2*3**24` is roughly `5.6e11`, and an FFT of that size would require at least 8TB of memory. I guess we can safely assume that the user will run out of memory before arriving at this check.\r\n(In contrast, the current implementation reserves space for 15 factors, running out of space at `2*3**14`, which is around 10 million and not totally unrealistic.)",
        "createdAt" : "2018-11-26T07:35:43Z",
        "updatedAt" : "2018-12-25T20:39:15Z",
        "lastEditedBy" : "ba48efb4-85c1-4b44-9286-85ef08ceef02",
        "tags" : [
        ]
      }
    ],
    "commit" : "0fe2a58c4434d7ee4e08f732e207c631bab6bc75",
    "line" : 971,
    "diffHunk" : "@@ -1,1 +969,973 @@    length>>=1;\n    // factor 2 should be at the front of the factor list\n    if (nfct>=NFCT) return -1;\n    plan->fct[nfct++].fct=2;\n    SWAP(plan->fct[0].fct, plan->fct[nfct-1].fct,size_t);"
  },
  {
    "id" : "328e8105-a45f-43b0-8987-7b62083c4509",
    "prId" : 11888,
    "prUrl" : "https://github.com/numpy/numpy/pull/11888#pullrequestreview-178679812",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "df0b367b-3e4e-434b-ace6-7d15f991e606",
        "parentId" : null,
        "authorId" : "36af3e0e-5ab8-4968-9f1f-ecfbb7f88576",
        "body" : "We have to watch out here on Windows platforms (and possibly others). The Visual studio compiler will not treat `fma` as an intrinsic and will call an `fma` function instead, which performs a software emulation if it not provided the correct flags [[1]](https://stackoverflow.com/questions/34265982/automatically-generate-fma-instructions-in-msvc). However this software emulation is apparently really bad and does not provide the actual fma operation with a single rounding. This is the reason fma is not available in Python yet [[2]](https://bugs.python.org/issue29282) and [[3]](https://bugs.python.org/msg312480).\r\n\r\nUnfortunately, I do not have a Windows platform at hand where I could test the accuracy of this function. But we should probably do so to make sure the fma operations are compiled correctly. Also I apologize that I brought the `sincospi` up and it now turns out to be such a hassle to implement on different platforms. Maybe we should stick with the libm implementation of sin and cos.",
        "createdAt" : "2018-11-26T12:17:58Z",
        "updatedAt" : "2018-12-25T20:39:15Z",
        "lastEditedBy" : "36af3e0e-5ab8-4968-9f1f-ecfbb7f88576",
        "tags" : [
        ]
      },
      {
        "id" : "816aa699-2387-43ef-ae7a-d9db15a12ac2",
        "parentId" : "df0b367b-3e4e-434b-ace6-7d15f991e606",
        "authorId" : "ba48efb4-85c1-4b44-9286-85ef08ceef02",
        "body" : "I don't expect big problems resulting from double rounding in the `fma` function. Results won't be as accurate, but they won't be actually bad.",
        "createdAt" : "2018-11-26T12:23:10Z",
        "updatedAt" : "2018-12-25T20:39:15Z",
        "lastEditedBy" : "ba48efb4-85c1-4b44-9286-85ef08ceef02",
        "tags" : [
        ]
      },
      {
        "id" : "d0368b0e-a42c-4323-bb20-0e32efa7392c",
        "parentId" : "df0b367b-3e4e-434b-ace6-7d15f991e606",
        "authorId" : "ba48efb4-85c1-4b44-9286-85ef08ceef02",
        "body" : "We could estimate the error by replacing the `fma` temporarily with normal arithmetic instructions. I'll see if I find some time for that.",
        "createdAt" : "2018-11-26T12:28:19Z",
        "updatedAt" : "2018-12-25T20:39:15Z",
        "lastEditedBy" : "ba48efb4-85c1-4b44-9286-85ef08ceef02",
        "tags" : [
        ]
      },
      {
        "id" : "f72aae71-54f3-4107-a3d6-070c46b10779",
        "parentId" : "df0b367b-3e4e-434b-ace6-7d15f991e606",
        "authorId" : "ba48efb4-85c1-4b44-9286-85ef08ceef02",
        "body" : "Also, libm `cos` wouldn't give me the `cos(x)-1` value accurately, which I need for the twiddle factors. Overall I think we will be doing well with the current implementation.",
        "createdAt" : "2018-11-26T13:58:37Z",
        "updatedAt" : "2018-12-25T20:39:15Z",
        "lastEditedBy" : "ba48efb4-85c1-4b44-9286-85ef08ceef02",
        "tags" : [
        ]
      },
      {
        "id" : "4ed461c1-08bb-4623-956b-5c2a5b4a3e01",
        "parentId" : "df0b367b-3e4e-434b-ace6-7d15f991e606",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : " `cos(x) - 1 = -sin(x)**2/(cos(x) + 1)` should have good accuracy for `cos(x) > 0`.",
        "createdAt" : "2018-11-26T16:47:35Z",
        "updatedAt" : "2018-12-25T20:39:15Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "3026a7fb-e8dd-4d15-ab93-c71e9d39585a",
        "parentId" : "df0b367b-3e4e-434b-ace6-7d15f991e606",
        "authorId" : "ba48efb4-85c1-4b44-9286-85ef08ceef02",
        "body" : "Thanks, that's very handy!\r\nStill, the accuracy plots seem to indicate that we won't need to go there.\r\n",
        "createdAt" : "2018-11-27T09:30:04Z",
        "updatedAt" : "2018-12-25T20:39:15Z",
        "lastEditedBy" : "ba48efb4-85c1-4b44-9286-85ef08ceef02",
        "tags" : [
        ]
      }
    ],
    "commit" : "0fe2a58c4434d7ee4e08f732e207c631bab6bc75",
    "line" : 53,
    "diffHunk" : "@@ -1,1 +51,55 @@  r = fma (r, s, -1.3352627688538006e+0);\n  r = fma (r, s,  4.0587121264167623e+0);\n  r = fma (r, s, -4.9348022005446790e+0);\n  double c = r*s;\n  /* Approximate sin(pi*x) for x in [-0.25,0.25] */"
  }
]
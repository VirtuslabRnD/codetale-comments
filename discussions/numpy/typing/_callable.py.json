[
  {
    "id" : "5483c6c7-a303-400b-b096-ab06d07faed8",
    "prId" : 17465,
    "prUrl" : "https://github.com/numpy/numpy/pull/17465#pullrequestreview-504166361",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "925e374e-4239-4133-a01c-bea04993c492",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "This comment seems misplaced to me, it applies to the second overload only.",
        "createdAt" : "2020-10-07T18:30:22Z",
        "updatedAt" : "2020-10-07T18:30:22Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "5e249cd3-7b4c-4a97-923f-af6c45ffca25",
        "parentId" : "925e374e-4239-4133-a01c-bea04993c492",
        "authorId" : "ebbd559e-4e98-4695-a417-e4a6bc303d63",
        "body" : "This is correct. Inserting a comment between two overloads looks visually rather bad though, hence why it is on top.",
        "createdAt" : "2020-10-07T18:40:44Z",
        "updatedAt" : "2020-10-07T18:40:44Z",
        "lastEditedBy" : "ebbd559e-4e98-4695-a417-e4a6bc303d63",
        "tags" : [
        ]
      }
    ],
    "commit" : "d934c2620439cbcf9b6f19b6037c1c67346dd71f",
    "line" : 30,
    "diffHunk" : "@@ -1,1 +116,120 @@        # TODO: The likes of `uint64 | np.signedinteger` will fail as there\n        # is no signed integer type large enough to hold a `uint64`\n        # See https://github.com/numpy/numpy/issues/2524\n        @overload\n        def __call__(self, __other: Union[bool, unsignedinteger]) -> unsignedinteger: ..."
  },
  {
    "id" : "9c3ed2ae-d257-4a88-b7ff-fd1ae31612fa",
    "prId" : 17778,
    "prUrl" : "https://github.com/numpy/numpy/pull/17778#pullrequestreview-530826683",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6774d8e1-42da-45fc-88b6-9b5628400456",
        "parentId" : null,
        "authorId" : "ebbd559e-4e98-4695-a417-e4a6bc303d63",
        "body" : "The comparison ops of `generic` are one the few that accept actual array-like object (rather than just arrays and/or scalar). Consequently, the signatures are still a bit too broad whenever array-like objects are involved (something to revisit in a future PR after https://github.com/numpy/numpy/pull/17719):\r\n\r\n``` python\r\nimport numpy as np\r\n\r\nU = np.str_()\r\ni8 = np.int64()\r\n\r\ni8 > U  # This is considered acceptable (for now) due to the broad definition of `ArrayLike`\r\n```",
        "createdAt" : "2020-11-15T19:19:36Z",
        "updatedAt" : "2020-11-24T17:06:00Z",
        "lastEditedBy" : "ebbd559e-4e98-4695-a417-e4a6bc303d63",
        "tags" : [
        ]
      }
    ],
    "commit" : "e78b9f3f06677d20463a1fed9d8da37924633749",
    "line" : 24,
    "diffHunk" : "@@ -1,1 +319,323 @@        def __call__(self, __other: _T) -> bool_: ...\n        @overload\n        def __call__(self, __other: ArrayLike) -> Union[ndarray, bool_]: ...\n\nelse:"
  },
  {
    "id" : "f2acc080-0488-40cd-8483-9ca7fcda4342",
    "prId" : 17778,
    "prUrl" : "https://github.com/numpy/numpy/pull/17778#pullrequestreview-540480595",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3263c8fd-8cb4-44a8-adfc-5fa6847f4121",
        "parentId" : null,
        "authorId" : "8ffdfffb-d8d9-40f6-9de3-dd0dee381149",
        "body" : "Are these overloads in the right order? I can't find docs so quickly, but I had expected overloads to be checked in order, so `_T` would also match `ArrayLike`.",
        "createdAt" : "2020-11-28T13:00:12Z",
        "updatedAt" : "2020-11-28T13:00:13Z",
        "lastEditedBy" : "8ffdfffb-d8d9-40f6-9de3-dd0dee381149",
        "tags" : [
        ]
      },
      {
        "id" : "5345165d-0591-4b65-8e7f-daa8463c9415",
        "parentId" : "3263c8fd-8cb4-44a8-adfc-5fa6847f4121",
        "authorId" : "ebbd559e-4e98-4695-a417-e4a6bc303d63",
        "body" : "Yes, in practice the first overload is used for all valid scalar-types, which always return `bool_`, while the second one is used for the much broader `ArrayLike` (a superset of the first overload).",
        "createdAt" : "2020-11-28T13:41:10Z",
        "updatedAt" : "2020-11-28T13:41:10Z",
        "lastEditedBy" : "ebbd559e-4e98-4695-a417-e4a6bc303d63",
        "tags" : [
        ]
      },
      {
        "id" : "73604097-c13d-468c-9747-d90332abbffd",
        "parentId" : "3263c8fd-8cb4-44a8-adfc-5fa6847f4121",
        "authorId" : "ebbd559e-4e98-4695-a417-e4a6bc303d63",
        "body" : "Also note that `_T` is a typevar, so it should be substituted with an actual value.\r\nFor example, `_ComparisonOp[datetime64]` replaces `_T` with `datetime64`.",
        "createdAt" : "2020-11-28T13:45:09Z",
        "updatedAt" : "2020-11-28T13:45:10Z",
        "lastEditedBy" : "ebbd559e-4e98-4695-a417-e4a6bc303d63",
        "tags" : [
        ]
      },
      {
        "id" : "039bd9f1-57db-4916-a22f-5c6f6d51b55a",
        "parentId" : "3263c8fd-8cb4-44a8-adfc-5fa6847f4121",
        "authorId" : "8ffdfffb-d8d9-40f6-9de3-dd0dee381149",
        "body" : "> Yes, in practice the first overload is used for all valid scalar-types\r\n\r\nThanks. That's what I was (am) fuzzy about. The Python docs on `TypeVar` are pretty bad, and PEP 484 says _\"By default, a type variable ranges over all possible types.\"_. My interpretation was really \"all\", not \"all scalar\". You can use `TypeVar( ...bound=`  with classes, mappings, etc. as bounds. So I thought `_T` would match array-likes as well here.",
        "createdAt" : "2020-11-28T14:04:37Z",
        "updatedAt" : "2020-11-28T14:04:38Z",
        "lastEditedBy" : "8ffdfffb-d8d9-40f6-9de3-dd0dee381149",
        "tags" : [
        ]
      },
      {
        "id" : "cbbe28b7-5db1-4921-b920-f21d3953fa6e",
        "parentId" : "3263c8fd-8cb4-44a8-adfc-5fa6847f4121",
        "authorId" : "ebbd559e-4e98-4695-a417-e4a6bc303d63",
        "body" : "For an unbound (_i.e._ unassigned) typevars this statement is actually true, even if the `bound` parameter is specified (because reasons...). This is the very reason why it is recommended to always assign some value to subscriptable types, _e.g._ use `Sequence[Any]` instead of plain `Sequence`.\r\n\r\nThe above-mentioned fortunately becomes irrelevant once a value has been assigned to the typevar (`Seq3` in the example below).\r\n\r\n``` python\r\nfrom typing import TypeVar, Sequence\r\n\r\nT = TypeVar(\"T\", bound=int)\r\n\r\nSeq1 = Sequence  # equivalent to `Sequence[Any]`\r\nSeq2 = Sequence[T]  # equivalent to `Sequence[Any]`\r\nSeq3 = Seq2[int]  # equivalent to `Sequence[int]`\r\n```",
        "createdAt" : "2020-11-28T14:39:09Z",
        "updatedAt" : "2020-11-28T14:39:22Z",
        "lastEditedBy" : "ebbd559e-4e98-4695-a417-e4a6bc303d63",
        "tags" : [
        ]
      },
      {
        "id" : "555f866a-a3b9-4e7a-afcf-bfc9e4b45264",
        "parentId" : "3263c8fd-8cb4-44a8-adfc-5fa6847f4121",
        "authorId" : "8ffdfffb-d8d9-40f6-9de3-dd0dee381149",
        "body" : "Thanks, that makes more sense now.",
        "createdAt" : "2020-11-29T13:37:25Z",
        "updatedAt" : "2020-11-29T13:37:25Z",
        "lastEditedBy" : "8ffdfffb-d8d9-40f6-9de3-dd0dee381149",
        "tags" : [
        ]
      }
    ],
    "commit" : "e78b9f3f06677d20463a1fed9d8da37924633749",
    "line" : 22,
    "diffHunk" : "@@ -1,1 +317,321 @@    class _ComparisonOp(Protocol[_T]):\n        @overload\n        def __call__(self, __other: _T) -> bool_: ...\n        @overload\n        def __call__(self, __other: ArrayLike) -> Union[ndarray, bool_]: ..."
  }
]
[
  {
    "id" : "855d04e6-51d6-49d1-bda1-52b527061792",
    "prId" : 12381,
    "prUrl" : "https://github.com/numpy/numpy/pull/12381#pullrequestreview-174994264",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e347ef2e-0dcd-4c80-bf8c-eb68bb3d2689",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Isn't this going to result in `__del__` being called twice and `shutil` failing? I suppose it doesn't cause the tests to fail, but is sort of messy.",
        "createdAt" : "2018-11-14T08:20:36Z",
        "updatedAt" : "2018-11-14T08:20:37Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "4af98a52-ff29-4570-bdba-d520d5639604",
        "parentId" : "e347ef2e-0dcd-4c80-bf8c-eb68bb3d2689",
        "authorId" : "73d6f7d8-2c7d-4a48-8754-5ce4a97a850f",
        "body" : "Just trying to be thorough -- I could just delete the unit test for the 0.5 line adjustment that prevents the destructor from raising an exception in the refguide worfklow. Calling the destructor when the initialization of an object fails seems to be a source of debate in language design.\r\n\r\nAs [noted here](https://stackoverflow.com/a/7501167/2942522):\r\n\r\n> That is why in C++ and in other object-oriented languages that have been designed with exception safety in mind, the destructor is not called if an exception is thrown in the constructor of an object ",
        "createdAt" : "2018-11-14T17:50:07Z",
        "updatedAt" : "2018-11-14T17:50:07Z",
        "lastEditedBy" : "73d6f7d8-2c7d-4a48-8754-5ce4a97a850f",
        "tags" : [
        ]
      }
    ],
    "commit" : "470d53fc6bc8267fec7d7cf5c7116d5e7437d789",
    "line" : 18,
    "diffHunk" : "@@ -1,1 +376,380 @@    # should not raise an AttributeError if __del__\n    # gracefully handles failed __init__:\n    ds.__del__()"
  },
  {
    "id" : "f7b4a4e6-8ce1-4ff6-a285-908de8e36a6e",
    "prId" : 12381,
    "prUrl" : "https://github.com/numpy/numpy/pull/12381#pullrequestreview-175229891",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7f83ea30-9277-40df-af53-27988c9ee581",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "I don't think this needs a special explanation - `__del__` is _always_ called once `__init__` starts running, whether it succeeds or fails.",
        "createdAt" : "2018-11-14T08:22:17Z",
        "updatedAt" : "2018-11-14T08:22:17Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "d40bf616-3795-408b-8699-9be1a9dd147d",
        "parentId" : "7f83ea30-9277-40df-af53-27988c9ee581",
        "authorId" : "73d6f7d8-2c7d-4a48-8754-5ce4a97a850f",
        "body" : "You're saying that `__del__` is called when an uncaught exception occurs in `__init__`? The [`__del__` docs](https://docs.python.org/3/reference/datamodel.html#object.__del__) indicate that \r\n\r\n> It is not guaranteed that __del__() methods are called for objects that still exist when the interpreter exits.\r\n\r\nFrom what I can see on StackOverflow, the need to keep a reference to the object alive to report the traceback will [prevent the destructor call from happening](https://stackoverflow.com/a/6409718/2942522) if the exception isn't caught. There are a lot of warnings in the del docs as well--I'm not sure it is really that obvious at all what happens in various exception-related scenarios.",
        "createdAt" : "2018-11-14T17:44:58Z",
        "updatedAt" : "2018-11-14T17:44:58Z",
        "lastEditedBy" : "73d6f7d8-2c7d-4a48-8754-5ce4a97a850f",
        "tags" : [
        ]
      },
      {
        "id" : "6a8f690e-5cb4-48d7-a8a2-5692f040bbd1",
        "parentId" : "7f83ea30-9277-40df-af53-27988c9ee581",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Yes, as soon as `object.__new__` is called (before `__init__` is even entered), then `__del__` is guaranteed to be called if/when the refcount of `self` is 0. As a test case:\r\n```python\r\n>>> class Bad(object):\r\n\t__init__ = None\r\n\tdef __del__(self):\r\n\t\tprint(\"__del__\")\r\n\r\n\t\t\r\n>>> Bad()\r\n__del__\r\nTraceback (most recent call last):\r\n  File \"<pyshell#8>\", line 1, in <module>\r\n    Bad()\r\nTypeError: 'NoneType' object is not callable\r\n```\r\n\r\nYour quote is simply saying that it's not guaranteed that the objects end up with a reference count of 0 at exit - but that only happens with bad cycles, or an abrupt exit.",
        "createdAt" : "2018-11-15T08:14:03Z",
        "updatedAt" : "2018-11-15T08:20:37Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "470d53fc6bc8267fec7d7cf5c7116d5e7437d789",
    "line" : 10,
    "diffHunk" : "@@ -1,1 +368,372 @@    # Exception object is caught by the\n    # caller as happens in refguide_check\n    # is_deprecated() function\n\n    ds = datasource.DataSource()"
  }
]
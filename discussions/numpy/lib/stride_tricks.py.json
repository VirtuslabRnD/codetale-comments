[
  {
    "id" : "df645e14-e006-4e14-968e-e299b77a5af7",
    "prId" : 4377,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "882aff34-ae6f-4f2a-b160-53c0c05c4697",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "What about the custom dtypes mentioned in the comment?\n",
        "createdAt" : "2014-02-27T01:07:57Z",
        "updatedAt" : "2014-02-27T01:07:57Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "84e06f68-b5a7-4acd-be5b-53cf60703b81",
        "parentId" : "882aff34-ae6f-4f2a-b160-53c0c05c4697",
        "authorId" : "b0e7e584-a9be-4737-9003-4922807a34eb",
        "body" : "setting array.dtype = x.dtype is only needed for custom dtypes, but throws an exception for object dtypes. I added a check to only set array.dtype for custom dtypes. I think every other dtype should be okay. Now that I think about it though, maybe the real issue is that np.asarray returns an array with a raw byte dtype, requiring the setting of array.dtype in the first place?\n",
        "createdAt" : "2014-02-27T01:49:50Z",
        "updatedAt" : "2014-02-27T01:49:50Z",
        "lastEditedBy" : "b0e7e584-a9be-4737-9003-4922807a34eb",
        "tags" : [
        ]
      },
      {
        "id" : "bf0cdaa4-331f-4949-94b2-6b8c0ebe66bc",
        "parentId" : "882aff34-ae6f-4f2a-b160-53c0c05c4697",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Ah, that may be. np.asarray is just array with `copy=0`, so the problem would be in array. Hmm, this is a tricky problem, how _can_ array detect custom dtypes? It needs to be able to look them up somewhere, or at least get hold of the descriptor if they come with one.\n",
        "createdAt" : "2014-02-27T02:03:10Z",
        "updatedAt" : "2014-02-27T02:03:10Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "a57924a7-1dc8-4cce-b256-ea7ecc634357",
        "parentId" : "882aff34-ae6f-4f2a-b160-53c0c05c4697",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "We do have the rational dtype to fool with, an np.asarray seems to work\n\n```\nIn [6]: import numpy.core.test_rational as rat\n\nIn [7]: r = rat.rational(1,2)\n\nIn [8]: asarray(r)\nOut[8]: array(rational(1,2), dtype=rational)\n```\n",
        "createdAt" : "2014-02-27T02:08:56Z",
        "updatedAt" : "2014-02-27T02:08:56Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "fba2a28c-d14c-465e-ade0-1c5cd5d7be6b",
        "parentId" : "882aff34-ae6f-4f2a-b160-53c0c05c4697",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "```\nif array.dtype.type is np.void:\n```\n\nmay be preferable to\n\n```\nif array.dtype.kind == 'V':\n```\n\nThe assigning of a dtype is just ugly. Maybe a view can be used instead.\n",
        "createdAt" : "2014-02-27T02:40:52Z",
        "updatedAt" : "2014-02-27T02:41:08Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "dbac5026-60e4-40c4-b63a-98928fcfaefa",
        "parentId" : "882aff34-ae6f-4f2a-b160-53c0c05c4697",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Hmmmm, checking `is void` does not seems to work:\n\n```\nIn [36]: a\nOut[36]: array(rational(1,2), dtype=rational)\n\nIn [37]: a.dtype.type is np.void\nOut[37]: False\n\nIn [38]: a.dtype.kind == 'V'\nOut[38]: True\n```\n\nThis is indeed identical to another PR, which tried the opposite. Instead of assigning the dtype where necessary, it didn't do it for object arrays where it is known it is not necessary ;).\n",
        "createdAt" : "2014-02-28T19:21:14Z",
        "updatedAt" : "2014-02-28T19:21:14Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      }
    ],
    "commit" : "a98b6b4ef12d09c51e5c9f015992c5b2ae164607",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +30,34 @@    array = np.asarray(DummyArray(interface, base=x))\n    # Make sure dtype is correct in case of custom dtype\n    if array.dtype.kind == 'V':\n        array.dtype = x.dtype\n    return array"
  },
  {
    "id" : "5a3295ba-424d-424e-92e8-a68efb528249",
    "prId" : 4622,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "92a6e640-4677-4bfb-a6b2-caf44e075c05",
        "parentId" : null,
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "What I meant was this. `__array_interface__` is basically just one way to define an \"array-like\". So this function currently does not support most array likes out there at all (for example memoryviews, etc.), since they implement the buffer interface instead. To really support this, I think we should (first thing), call:\n\n```\nx = np.asanyarray(x)\n```\n\nhere. After you have done that, `__array_finalize__` is guaranteed to be defined. We will guarantee to return an array and not some array-like, which can be seen as an advantage or disadvantage. But I think I am fine with returning always an array (or array subclass here). On the other hand, the pandas guys might disagree?\n",
        "createdAt" : "2014-08-27T10:00:16Z",
        "updatedAt" : "2014-08-27T21:04:55Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "7bcfa0c1-1f4d-4aaf-bbcf-d46b5d92a873",
        "parentId" : "92a6e640-4677-4bfb-a6b2-caf44e075c05",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Hmmm, pandas implements array wrap but not array finalize. I kind of think it is fine to say that `as_strided`  will always return an array, like `np.asanyarray`, but honestly this is a jungle, so if someone disagrees....\n",
        "createdAt" : "2014-08-27T10:03:16Z",
        "updatedAt" : "2014-08-27T21:04:55Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "1d3a2c7e-a07e-46bd-b63b-5ff63bad9346",
        "parentId" : "92a6e640-4677-4bfb-a6b2-caf44e075c05",
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "@seberg - I guess adding `x = np.asanyarray(x)` deals with a somewhat separate issue, but obviously it is good to ensure the code is as general as possible, and this would allow one at least to remove the `isinstance(x, np.ndarray)` stanza from the if statement below. \n\nI'll do that, but also a question: since with this change, we know that x is an `ndarray` subclass, might this also allow one to change the strides and shape more easily than through the `DummyArray` mechanism, so that the `dtype` and `subclass` issues get handled more elegantly as well?\n",
        "createdAt" : "2014-08-27T18:08:32Z",
        "updatedAt" : "2014-08-27T21:04:55Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      },
      {
        "id" : "e61ce7c9-958c-4a2e-b118-a9fb18509b90",
        "parentId" : "92a6e640-4677-4bfb-a6b2-caf44e075c05",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "From C, you could do that very easily, but from python there is no other way really.\n",
        "createdAt" : "2014-08-27T20:21:55Z",
        "updatedAt" : "2014-08-27T21:04:55Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "3cc01850-9dee-4440-8b1b-16ea746b33f5",
        "parentId" : "92a6e640-4677-4bfb-a6b2-caf44e075c05",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "And yeah, you are right, it deals with a seperate issue... I somewhat thought it might make this one simpler, too, but that doesn't change much.\n",
        "createdAt" : "2014-08-27T20:32:46Z",
        "updatedAt" : "2014-08-27T21:04:55Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "0ae8b00c-1a31-46fe-a587-e93da83d5c85",
        "parentId" : "92a6e640-4677-4bfb-a6b2-caf44e075c05",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Oh, actually if you really hate DummyArray, you can also use the `np.ndarray` class constructor. You still will have to manually call finalize, etc. since that does not allow to set a parent.\n",
        "createdAt" : "2014-08-27T20:39:12Z",
        "updatedAt" : "2014-08-27T21:04:55Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      }
    ],
    "commit" : "e8590311a7b312711c7a4f40c1a15496e34d0ee6",
    "line" : null,
    "diffHunk" : "@@ -1,1 +26,30 @@    # first convert input to array, possibly keeping subclass\n    x = np.array(x, copy=False, subok=subok)\n    interface = dict(x.__array_interface__)\n    if shape is not None:\n        interface['shape'] = tuple(shape)"
  },
  {
    "id" : "2d0a9e8d-8036-4dc5-80e1-a0c2638ba1ac",
    "prId" : 4622,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1d9c71f6-0ab9-4c41-9576-0a9bce4eb545",
        "parentId" : null,
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "I think the `.view` call already results in an `__array_finalize__`.\n",
        "createdAt" : "2014-08-27T10:01:39Z",
        "updatedAt" : "2014-08-27T21:04:55Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "0d8fe270-ac69-47d5-b192-49f6f0d7f8e4",
        "parentId" : "1d9c71f6-0ab9-4c41-9576-0a9bce4eb545",
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "Taking `array.view(...)` does indeed result in a call to `__array_finalize__`, but with `array` passed on, not `x` as in the call below, and hence one does not have access to possible attributes of `x` that one might want to copy.\n",
        "createdAt" : "2014-08-27T15:59:39Z",
        "updatedAt" : "2014-08-27T21:04:55Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      },
      {
        "id" : "3be5022f-6d92-4fcf-8d7d-0dca5d736128",
        "parentId" : "1d9c71f6-0ab9-4c41-9576-0a9bce4eb545",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "right, so its fine as is I guess. Still think i would prefere the early `asanyarray` call in any case.\n",
        "createdAt" : "2014-08-27T16:27:57Z",
        "updatedAt" : "2014-08-27T21:04:55Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      }
    ],
    "commit" : "e8590311a7b312711c7a4f40c1a15496e34d0ee6",
    "line" : null,
    "diffHunk" : "@@ -1,1 +38,42 @@        # if input was an ndarray subclass and subclasses were OK,\n        # then view the result as that subclass.\n        array = array.view(type=type(x))\n        # Since we have done something akin to a view from x, we should let\n        # the subclass finalize (if it has it implemented, i.e., is not None)."
  },
  {
    "id" : "206f033b-d21b-4265-afbb-fd36f9bef87b",
    "prId" : 7609,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "edefabc9-6c26-449f-ae86-22b6e930db06",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Any particular reason for `!r` instead of `!s`?\n",
        "createdAt" : "2016-05-09T03:03:22Z",
        "updatedAt" : "2016-05-09T03:03:22Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "699cf79b-0dd0-4a2b-9e75-1f39eed37649",
        "parentId" : "edefabc9-6c26-449f-ae86-22b6e930db06",
        "authorId" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "body" : "`!r` (= repr) will put quotes around the key and escape any weird junk that might be in it, both of which seem like good things to me in this context\n",
        "createdAt" : "2016-05-09T03:06:47Z",
        "updatedAt" : "2016-05-09T03:06:47Z",
        "lastEditedBy" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "tags" : [
        ]
      },
      {
        "id" : "a29b9c0a-aae3-4d56-a660-e34eac5233f2",
        "parentId" : "edefabc9-6c26-449f-ae86-22b6e930db06",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "`!r` is what a normal `TypeError` due to extra kwargs seems to do\n",
        "createdAt" : "2016-05-09T03:56:24Z",
        "updatedAt" : "2016-05-09T03:56:24Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "8894b81b166f6b0c200dde77a70fb360e95b0f7c",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +245,249 @@    if kwargs:\n        raise TypeError('broadcast_arrays() got an unexpected keyword '\n                        'argument {!r}'.format(kwargs.keys()[0]))\n    args = [np.array(_m, copy=False, subok=subok) for _m in args]\n"
  },
  {
    "id" : "98527427-c1e4-4ada-b789-f800f076077e",
    "prId" : 8617,
    "prUrl" : "https://github.com/numpy/numpy/pull/8617#pullrequestreview-21867190",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9991980a-1984-4970-a97e-e9f4815fd4c8",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Is there any reason that `np.broadcast()` is forbidden? Seems to work just fine with the check for `ndim >= 1` removed.",
        "createdAt" : "2017-02-13T21:26:43Z",
        "updatedAt" : "2017-02-13T22:52:05Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "44e3e52c-a06f-4ffa-8836-6d208bb79376",
        "parentId" : "9991980a-1984-4970-a97e-e9f4815fd4c8",
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "Agreed.",
        "createdAt" : "2017-02-14T18:50:32Z",
        "updatedAt" : "2017-02-14T18:50:32Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      },
      {
        "id" : "b3283838-ea43-4609-a49b-227265fd541e",
        "parentId" : "9991980a-1984-4970-a97e-e9f4815fd4c8",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "@mhvk: So you'd be in favor of a separate PR that removes that restriction from the C code?",
        "createdAt" : "2017-02-14T19:40:03Z",
        "updatedAt" : "2017-02-14T19:40:03Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "75552ef6-6bbb-4e3f-9d92-771398bae76c",
        "parentId" : "9991980a-1984-4970-a97e-e9f4815fd4c8",
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "I slightly misunderstood -- I agreed with your change here for sure. I'm less sure about messing with the C code, but this is mostly because quite a while ago, on earlier changes in `stride_tricks`, there was the following https://github.com/numpy/numpy/pull/5371#issuecomment-67233157",
        "createdAt" : "2017-02-14T21:22:10Z",
        "updatedAt" : "2017-02-14T21:22:10Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      }
    ],
    "commit" : "d9b26f804117ebc1f591dff33d06ce2339af9339",
    "line" : 8,
    "diffHunk" : "@@ -1,1 +183,187 @@    # use the old-iterator because np.nditer does not handle size 0 arrays\n    # consistently\n    b = np.broadcast(*args[:32])\n    # unfortunately, it cannot handle 32 or more arguments directly\n    for pos in range(32, len(args), 31):"
  },
  {
    "id" : "e9e75eeb-1374-4348-8d25-74e131dfdbf1",
    "prId" : 17394,
    "prUrl" : "https://github.com/numpy/numpy/pull/17394#pullrequestreview-500316251",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "074ee708-ab33-4ae3-9fa9-fa4cac74226d",
        "parentId" : null,
        "authorId" : "ebbd559e-4e98-4695-a417-e4a6bc303d63",
        "body" : "```suggestion\r\n    x = np.asanyarray(x)\r\n```",
        "createdAt" : "2020-09-29T21:22:22Z",
        "updatedAt" : "2020-10-29T18:10:16Z",
        "lastEditedBy" : "ebbd559e-4e98-4695-a417-e4a6bc303d63",
        "tags" : [
        ]
      },
      {
        "id" : "d2da3c95-2a3a-46cc-b24b-153f6e5cc1c2",
        "parentId" : "074ee708-ab33-4ae3-9fa9-fa4cac74226d",
        "authorId" : "fe9eeac5-91bb-46cc-9f64-99f70f1ace1f",
        "body" : "This was briefly discussed in the previous PR https://github.com/numpy/numpy/pull/10771#discussion_r317427162. There, @eric-wieser suggested that this was done on purpose and to conform with `as_strided`. That's why I kept it, but I have to admit that I don't understand the issue in detail.\r\n\r\n@eric-wieser, would you care to way in?",
        "createdAt" : "2020-09-30T09:32:54Z",
        "updatedAt" : "2020-10-29T18:10:16Z",
        "lastEditedBy" : "fe9eeac5-91bb-46cc-9f64-99f70f1ace1f",
        "tags" : [
        ]
      },
      {
        "id" : "f3713fea-f321-4919-8e82-9fdeee0d2618",
        "parentId" : "074ee708-ab33-4ae3-9fa9-fa4cac74226d",
        "authorId" : "ebbd559e-4e98-4695-a417-e4a6bc303d63",
        "body" : "IMO this sounds more like an argument for changing `as_strided`. \r\nStill, as this is quite minor I don't have particularly strong feelings about either option; feel free to ignore.",
        "createdAt" : "2020-10-01T12:51:20Z",
        "updatedAt" : "2020-10-29T18:10:16Z",
        "lastEditedBy" : "ebbd559e-4e98-4695-a417-e4a6bc303d63",
        "tags" : [
        ]
      },
      {
        "id" : "78b0cdb9-e380-4d46-b4b8-8121b6dc1ba8",
        "parentId" : "074ee708-ab33-4ae3-9fa9-fa4cac74226d",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "I think we should leave this as is for now. `_broadcast_to` also uses the same pattern. @BvB93, if you feel strongly about this feel welcome to open a follow-up PR that changes all the conversions in this file.",
        "createdAt" : "2020-10-01T12:56:00Z",
        "updatedAt" : "2020-10-29T18:10:16Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "c6ef8d68dc56abf92485193332bc7d67b6988604",
    "line" : 214,
    "diffHunk" : "@@ -1,1 +304,308 @@                    else (window_shape,))\n    # first convert input to array, possibly keeping subclass\n    x = np.array(x, copy=False, subok=subok)\n\n    window_shape_array = np.array(window_shape)"
  },
  {
    "id" : "a574ea3b-1b60-43bf-860e-a263c9825496",
    "prId" : 17394,
    "prUrl" : "https://github.com/numpy/numpy/pull/17394#pullrequestreview-500444348",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "630a1ccf-9a60-4fc8-9234-138219135797",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "I think it would be nice to show this use-case too:\r\n```suggestion\r\n\r\n    Combining with stepped slicing (`::step`), this can be used to take sliding views which skip elements:\r\n\r\n    >>> x = np.arange(7)\r\n    >>> sliding_window_view(x, 5)[:, ::2]\r\n    array([[0, 2, 4],\r\n           [1, 3, 5],\r\n           [2, 4, 6]])\r\n\r\n    or views which move by multiple elements\r\n     \r\n    >>> x = np.arange(7)\r\n    >>> sliding_window_view(x, 5)[::2, :]\r\n    array([[0, 1, 2],\r\n           [2, 3, 4],\r\n           [4, 5, 6]])\r\n\r\n```\r\n\r\n",
        "createdAt" : "2020-10-01T15:04:15Z",
        "updatedAt" : "2020-10-29T18:10:16Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "c6ef8d68dc56abf92485193332bc7d67b6988604",
    "line" : 118,
    "diffHunk" : "@@ -1,1 +208,212 @@           [2, 3, 4],\n           [3, 4, 5]])\n\n    This also works in more dimensions, e.g.\n"
  },
  {
    "id" : "717b7657-ecd0-4ef6-a1ae-2f9d155e38ea",
    "prId" : 17394,
    "prUrl" : "https://github.com/numpy/numpy/pull/17394#pullrequestreview-507568455",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b761e936-dc71-402c-9a1e-b11912279abb",
        "parentId" : null,
        "authorId" : "b15cf1a1-ba9d-47aa-b157-e0c1f40c5c5c",
        "body" : "Should there be an example showing how the sliding window view can be used say to compute a sliding window mean similar to `pd.rolling`",
        "createdAt" : "2020-10-13T09:36:40Z",
        "updatedAt" : "2020-10-29T18:10:16Z",
        "lastEditedBy" : "b15cf1a1-ba9d-47aa-b157-e0c1f40c5c5c",
        "tags" : [
        ]
      },
      {
        "id" : "0df6c798-abd6-42ab-a3ba-4179abb91246",
        "parentId" : "b761e936-dc71-402c-9a1e-b11912279abb",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "I was wondering if it could be used for an IIR filter, although I think SciPy already has a function for that.",
        "createdAt" : "2020-10-13T13:11:48Z",
        "updatedAt" : "2020-10-29T18:10:16Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "332bb6a0-35db-489e-b8ca-717adeb49f81",
        "parentId" : "b761e936-dc71-402c-9a1e-b11912279abb",
        "authorId" : "fe9eeac5-91bb-46cc-9f64-99f70f1ace1f",
        "body" : "I am not knowledgable enough to construct an IIR example, but I will include a simple moving average.",
        "createdAt" : "2020-10-13T15:05:15Z",
        "updatedAt" : "2020-10-29T18:10:16Z",
        "lastEditedBy" : "fe9eeac5-91bb-46cc-9f64-99f70f1ace1f",
        "tags" : [
        ]
      },
      {
        "id" : "decdab39-07f3-4ea8-8c38-25edd6f618e3",
        "parentId" : "b761e936-dc71-402c-9a1e-b11912279abb",
        "authorId" : "fe9eeac5-91bb-46cc-9f64-99f70f1ace1f",
        "body" : "Thanks for your comments!\r\n\r\nI added a simple moving average example. If you consider this not sufficient in terms of application examples, I am open for other suggestions. Otherwise, I will not consider this a blocker for merging.",
        "createdAt" : "2020-10-13T15:32:27Z",
        "updatedAt" : "2020-10-29T18:10:16Z",
        "lastEditedBy" : "fe9eeac5-91bb-46cc-9f64-99f70f1ace1f",
        "tags" : [
        ]
      }
    ],
    "commit" : "c6ef8d68dc56abf92485193332bc7d67b6988604",
    "line" : 107,
    "diffHunk" : "@@ -1,1 +197,201 @@    Examples\n    --------\n    >>> x = np.arange(6)\n    >>> x.shape\n    (6,)"
  },
  {
    "id" : "943242dc-8949-4226-a90e-98dfcde61cca",
    "prId" : 17394,
    "prUrl" : "https://github.com/numpy/numpy/pull/17394#pullrequestreview-515483789",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c27d1e44-f292-48a3-8b8e-85d78eaaa3cc",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "I wonder if we should expand on the performance note here too:\r\n\r\n```suggestion\r\n    \r\n    Note that this also provides an example of a case when `sliding_window_view` is not the fastest algorithm.\r\n    The above needed (len(x)-3+1)*(3-1)=8 additions, but we can do it in `len(x) - 1` additions and 1 subtraction with `cumsum`:\r\n    \r\n    >>> cx = np.cumsum(x)\r\n    >>> moving_average = (cx[3:] - cx[:-3]) / 3\r\n    >>> moving_average\r\n    array([1., 2., 3., 4.])\r\n    \"\"\"\r\n```\r\n\r\nThis does overlap with the `notes` section...\r\n\r\nThe efficiently argument would be easier if `3` were in a variable, perhaps `n=3`.",
        "createdAt" : "2020-10-13T15:41:16Z",
        "updatedAt" : "2020-10-29T18:10:16Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "3f14bd7b-004a-4327-a3b9-d858f4710c9b",
        "parentId" : "c27d1e44-f292-48a3-8b8e-85d78eaaa3cc",
        "authorId" : "fe9eeac5-91bb-46cc-9f64-99f70f1ace1f",
        "body" : "Well, this also shows the difficulty with other algorithms: Your calculation misses the first window and produces `[2, 3, 4]` only. Is this fixable?",
        "createdAt" : "2020-10-14T09:46:37Z",
        "updatedAt" : "2020-10-29T18:10:16Z",
        "lastEditedBy" : "fe9eeac5-91bb-46cc-9f64-99f70f1ace1f",
        "tags" : [
        ]
      },
      {
        "id" : "c96b6f08-e2ae-4b89-845a-65eca5546018",
        "parentId" : "c27d1e44-f292-48a3-8b8e-85d78eaaa3cc",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Ah, I always forget that complexity. Yes, either `cx` or `x` needs a zero prepending.",
        "createdAt" : "2020-10-14T09:56:17Z",
        "updatedAt" : "2020-10-29T18:10:16Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "b9914b9d-77f9-459c-8f64-cedb86648ac8",
        "parentId" : "c27d1e44-f292-48a3-8b8e-85d78eaaa3cc",
        "authorId" : "fe9eeac5-91bb-46cc-9f64-99f70f1ace1f",
        "body" : "So, just to clarify. Let `n = len(x)` the length of the vector and `w = 3` the window size. Then the moving window approach needs `(n - (w-1))*(w-1) = (w-1)n - (w-1)^2 = 8` additions. The cumsum approach needs `n - 1` additions for the cumsum and `n - (w-1))` additions for the difference for a total of `n-1 + n - (w-1) = 2n - w = 9` additions, right? Granted, the larger the window, the more the moving window approach takes, but perhaps for moderate data and window sizes the example is not so convincing? Unless I got my numbers wrong, of course.",
        "createdAt" : "2020-10-14T14:28:24Z",
        "updatedAt" : "2020-10-29T18:10:16Z",
        "lastEditedBy" : "fe9eeac5-91bb-46cc-9f64-99f70f1ace1f",
        "tags" : [
        ]
      },
      {
        "id" : "9304345e-99b4-4622-ba59-39376dc38da8",
        "parentId" : "c27d1e44-f292-48a3-8b8e-85d78eaaa3cc",
        "authorId" : "fe9eeac5-91bb-46cc-9f64-99f70f1ace1f",
        "body" : "Both are O(n), for most window sizes the factor is better for cumsum than for rolling window, but the window approach is more parallelizable since every calculation is local.\r\n\r\nI wonder how much of this discussion really should be in the docstring of the function.",
        "createdAt" : "2020-10-14T14:37:26Z",
        "updatedAt" : "2020-10-29T18:10:16Z",
        "lastEditedBy" : "fe9eeac5-91bb-46cc-9f64-99f70f1ace1f",
        "tags" : [
        ]
      },
      {
        "id" : "2c4c93b6-227e-40c8-8130-3544354123ad",
        "parentId" : "c27d1e44-f292-48a3-8b8e-85d78eaaa3cc",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Both are O(n) in the length, but a [summed area table](https://en.wikipedia.org/wiki/Summed-area_table) is O(1) in the *window* size.  We probably do not need to give an exact calculation, but a rough estimation that this approach scales with the window size, while a summed area table does not (and thus is magnitudes faster for larger windows) is important IMO, since it should be quite typical that this is a nice quick solution, but rarely a particular performant one.",
        "createdAt" : "2020-10-14T14:52:49Z",
        "updatedAt" : "2020-10-29T18:10:16Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "c930fb8e-d5be-4184-904f-fcf257479e17",
        "parentId" : "c27d1e44-f292-48a3-8b8e-85d78eaaa3cc",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Whoops, I miscounted the subtraction\r\n\r\n> Then the moving window approach needs `(n - (w-1))*(w-1) = (w-1)n - (w-1)^2 = 8` additions. The cumsum approach needs `n - 1` additions for the cumsum and `n - (w-1))` additions for the difference for a total of `n-1 + n - (w-1) = 2n - w = 9` additions, right? \r\n\r\nThat sounds correct to me - as @seberg  points out, the key property is that the former is quadratic in `w`.",
        "createdAt" : "2020-10-14T15:23:12Z",
        "updatedAt" : "2020-10-29T18:10:16Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "f01553c6-d1f9-4818-89ba-0dda11d3edbc",
        "parentId" : "c27d1e44-f292-48a3-8b8e-85d78eaaa3cc",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Maybe we should just expand the Notes, and add a sentence here saying: \"Note that this approach perform poorly unless the window is very small (see Notes).\"?\r\n\r\nWe could consider mentioning more complicated examples, such as `scipy.ndimage.median_filter`. And generally expand the Notes section (just thinking):\r\n\r\n> Using this approach often performs poorly unless the window size is very small. As a rough estimate, using a sliding view performs `O(N*W)` where `N` is the size of the array and `W` is the number of elements in the window.  Algorithm designed with overlapping windows in mind can improve this and often achieve `O(N)`: When the window has 100 elements such an algorithm can be 100 times faster.\r\nExamples for faster algorithms are summed area tables and the related convolution/correlation, or fast a median as implemented in `scipy.ndimage.median_filter`.",
        "createdAt" : "2020-10-14T16:04:21Z",
        "updatedAt" : "2020-10-29T18:10:16Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "bb491d53-5524-4583-8b99-665a3ff244ed",
        "parentId" : "c27d1e44-f292-48a3-8b8e-85d78eaaa3cc",
        "authorId" : "fe9eeac5-91bb-46cc-9f64-99f70f1ace1f",
        "body" : "Hm. I agree with the fact, of course, but the wording is a bit strong for me. After all, the scaling is indeed linear in the operations, but flops are (essentially) for free these days; memory and communication is not. A summed area table can be calculated in one pass, but only serially and it will require either destruction of the original data for an in-place summation or double the memory requirement. So over all, for modern problems in a heterogeneous, multi-level memory, big data problem, the balance is not quite as obvious to me.",
        "createdAt" : "2020-10-15T22:08:50Z",
        "updatedAt" : "2020-10-29T18:10:16Z",
        "lastEditedBy" : "fe9eeac5-91bb-46cc-9f64-99f70f1ace1f",
        "tags" : [
        ]
      },
      {
        "id" : "d6c91695-9f71-4d87-b5d8-57c2de01a5f4",
        "parentId" : "c27d1e44-f292-48a3-8b8e-85d78eaaa3cc",
        "authorId" : "576cec6e-8071-43f8-bce9-351a2589f050",
        "body" : "I suspect `cumsum` would also be prone to overflow.\r\n\r\nThat said, there are other methods for rolling window sum. Pandas and bottleneck use an approach that also runs in O(1) with respect to the window size, where a single element is added and subtracted from the rolling sum in each step.",
        "createdAt" : "2020-10-15T22:54:08Z",
        "updatedAt" : "2020-10-29T18:10:16Z",
        "lastEditedBy" : "576cec6e-8071-43f8-bce9-351a2589f050",
        "tags" : [
        ]
      },
      {
        "id" : "7bb41b32-29b2-49f6-ba7d-5027005526df",
        "parentId" : "c27d1e44-f292-48a3-8b8e-85d78eaaa3cc",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "I am happy to tune it down, but I think the statement should include something to the fact that this can easily be hundreds of times slower than a proper solution and that such a proper solution is sometimes readily available! I guess the \"100 times\" may sound a bit too strong, but users may well be unaware of the big O notation and algorithmic complexity.\r\n\r\nSo, I think we should cover:\r\n\r\n* For large windows, this can be orders of magnitude slower than an optimal approach.\r\n* There are often much better solutions (e.g. in scipy), users should consider looking for them.\r\n* Yes, for small windows there is probably no issue, and even for larger windows: This is will often be a very practical, sound solution (at least as long as the window sizes is fixed/limited)\r\n\r\nFor the summed are table, I don't know, maybe we should not mention it (it is a nice, simple example, but chances are fftconvolve and not building the full table are just better solutions).\r\n\r\n@shoyer good point about bottleneck, we could also mention that here (although a lot of the tools are probably also available in `scipy.ndimage`, albeit probably slower for certain tasks.",
        "createdAt" : "2020-10-15T23:08:14Z",
        "updatedAt" : "2020-10-29T18:10:16Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "2d186718-734a-4d47-98aa-7a337d220413",
        "parentId" : "c27d1e44-f292-48a3-8b8e-85d78eaaa3cc",
        "authorId" : "fe9eeac5-91bb-46cc-9f64-99f70f1ace1f",
        "body" : "Good input, thanks guys! I added a note in line (I believe) with @seberg's suggestion as well as links to scipy.ndimage and bottleneck (thanks for that, @shoyer).\r\n\r\nWhat do you think about this formulation?",
        "createdAt" : "2020-10-16T12:25:42Z",
        "updatedAt" : "2020-10-29T18:10:16Z",
        "lastEditedBy" : "fe9eeac5-91bb-46cc-9f64-99f70f1ace1f",
        "tags" : [
        ]
      },
      {
        "id" : "20dbc429-c423-4b7e-b5b1-a4d0041901f0",
        "parentId" : "c27d1e44-f292-48a3-8b8e-85d78eaaa3cc",
        "authorId" : "fe9eeac5-91bb-46cc-9f64-99f70f1ace1f",
        "body" : "For ease of review, the proposed formulation is this (see [here](https://16504-908607-gh.circle-artifacts.com/0/doc/build/html/reference/generated/numpy.sliding_window_view.html#numpy.sliding_window_view) for full rendered documentation):\r\n\r\nAt the moving average example I added a comment stating:\r\n> Note that a sliding windows approach is often **not** optimal (see Notes).\r\n\r\nAnd in the notes section the following:\r\n> For some cases there may be more efficient approaches to calculate\r\ntransformations across multi-dimensional arrays, for instance\r\n`scipy.signal.fftconvolve`, where combining the iterating step with the\r\ncalculation itself while storing partial results can result in significant\r\nspeedups.\r\n>\r\n> As a rough estimate, a sliding window approach with an input size of `N`\r\nand a window size of `W` will scale as `O(N*W)` where frequently a special\r\nalgorithm can achieve `O(N)`. That means that the sliding window variant\r\nfor a window size of 100 can be a 100 times slower than a more specialized\r\nversion.\r\n> For many common problems these better, specialized solutions already exist\r\nin libraries such as\r\n`scipy.ndimage <https://docs.scipy.org/doc/scipy/reference/ndimage.html>`_\r\nor `bottleneck <https://github.com/pydata/bottleneck>`_.\r\n>\r\n> Nevertheless, for small window sizes, when no custom algorithm exists, or\r\nas a prototyping and developing tool, this function can be a good solution.\r\n",
        "createdAt" : "2020-10-21T14:06:10Z",
        "updatedAt" : "2020-10-29T18:10:16Z",
        "lastEditedBy" : "fe9eeac5-91bb-46cc-9f64-99f70f1ace1f",
        "tags" : [
        ]
      },
      {
        "id" : "75f58b5e-e694-4cc3-86c6-c9b75867c57e",
        "parentId" : "c27d1e44-f292-48a3-8b8e-85d78eaaa3cc",
        "authorId" : "fe9eeac5-91bb-46cc-9f64-99f70f1ace1f",
        "body" : "@seberg, sorry, can I push this? It seems we are almost there. If you feel this needs stronger language, I am fine with that too. That is certainly not the hill I want (this PR) to die on.",
        "createdAt" : "2020-10-23T09:10:54Z",
        "updatedAt" : "2020-10-29T18:10:16Z",
        "lastEditedBy" : "fe9eeac5-91bb-46cc-9f64-99f70f1ace1f",
        "tags" : [
        ]
      }
    ],
    "commit" : "c6ef8d68dc56abf92485193332bc7d67b6988604",
    "line" : 209,
    "diffHunk" : "@@ -1,1 +299,303 @@\n    Note that a sliding window approach is often **not** optimal (see Notes).\n    \"\"\"\n    window_shape = (tuple(window_shape)\n                    if np.iterable(window_shape)"
  },
  {
    "id" : "4712ac3f-a8eb-4c96-a0a6-35dab4e5523b",
    "prId" : 17394,
    "prUrl" : "https://github.com/numpy/numpy/pull/17394#pullrequestreview-519915938",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e3470a3e-becb-44d4-87ef-70a1df4f660f",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "```suggestion\r\n    positions.\r\n    \r\n    .. versionadded:: 1.20.0\r\n```",
        "createdAt" : "2020-10-29T17:36:11Z",
        "updatedAt" : "2020-10-29T18:10:16Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "c6ef8d68dc56abf92485193332bc7d67b6988604",
    "line" : 39,
    "diffHunk" : "@@ -1,1 +129,133 @@    Also known as rolling or moving window, the window slides across all\n    dimensions of the array and extracts subsets of the array at all window\n    positions.\n    \n    .. versionadded:: 1.20.0"
  }
]
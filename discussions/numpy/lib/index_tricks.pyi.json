[
  {
    "id" : "26f31de3-f30e-443f-8502-b8f05bca39d5",
    "prId" : 18397,
    "prUrl" : "https://github.com/numpy/numpy/pull/18397#pullrequestreview-589534551",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "67e394e6-4ee3-4067-a39e-2ab34a64db45",
        "parentId" : null,
        "authorId" : "ebbd559e-4e98-4695-a417-e4a6bc303d63",
        "body" : "Both `diag_indices` and `diag_indices_from` return tuples of `int_` arrays.\r\nShouldn't they be returning `intp` arrays considering, the values are supposed to represent indices?",
        "createdAt" : "2021-02-11T17:59:22Z",
        "updatedAt" : "2021-02-25T13:06:55Z",
        "lastEditedBy" : "ebbd559e-4e98-4695-a417-e4a6bc303d63",
        "tags" : [
        ]
      },
      {
        "id" : "51b4fae6-3d85-4b60-8697-16ac3b9b1aea",
        "parentId" : "67e394e6-4ee3-4067-a39e-2ab34a64db45",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Seems they return whatever arange returns. Arange probably returns whatever `n` is? So I guess it probably will go to 64bit if the value is too large.  But I tend to agree, in the spirit of not changing the output dtype `intp` would make more sense.",
        "createdAt" : "2021-02-11T18:13:34Z",
        "updatedAt" : "2021-02-25T13:06:55Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "14e7049e-b0e3-48be-a6cc-3c8d335fa768",
        "parentId" : "67e394e6-4ee3-4067-a39e-2ab34a64db45",
        "authorId" : "ebbd559e-4e98-4695-a417-e4a6bc303d63",
        "body" : "> In the spirit of not changing the output dtype `intp` would make more sense.\r\n\r\nIf there are no objections then I'd like to change `arange(...)` to `arange(..., dtype=np.intp)`.\r\nIn practice this should only affect Windows and 32-bit platforms anyway, as `int_` already\r\nmaps to `int64` on all (most?) other platforms.",
        "createdAt" : "2021-02-11T18:22:41Z",
        "updatedAt" : "2021-02-25T13:06:55Z",
        "lastEditedBy" : "ebbd559e-4e98-4695-a417-e4a6bc303d63",
        "tags" : [
        ]
      },
      {
        "id" : "c872614b-8063-43fd-a7ac-fa7438a70136",
        "parentId" : "67e394e6-4ee3-4067-a39e-2ab34a64db45",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "I would like to try changing the default integer to `intp` entirely :), while pretty simple, it may be a big step. Is it very valuable here? It feels a bit like we have this problem all over the place and the only reason this one jumps at you is that `_indices` is in the function name.  Although, maybe that is a great reason!",
        "createdAt" : "2021-02-11T18:30:31Z",
        "updatedAt" : "2021-02-25T13:06:55Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "3290f762-5082-4ccf-9d7e-508a2c2c55ed",
        "parentId" : "67e394e6-4ee3-4067-a39e-2ab34a64db45",
        "authorId" : "ebbd559e-4e98-4695-a417-e4a6bc303d63",
        "body" : "> It feels a bit like we have this problem all over the place and the only reason this one jumps at you is that `_indices` is in the function name.\r\n\r\nYeah, that's basically my motivation here. Functions that return indices generally return them as `intp` arrays, this one didn't so it stood out to me.\r\n\r\n> I would like to try changing the default integer to `intp` entirely :)\r\n\r\n+1 to that suggestion!",
        "createdAt" : "2021-02-11T19:11:56Z",
        "updatedAt" : "2021-02-25T13:06:55Z",
        "lastEditedBy" : "ebbd559e-4e98-4695-a417-e4a6bc303d63",
        "tags" : [
        ]
      },
      {
        "id" : "9dbd4162-1871-4b29-ba28-2f1d912dc3ea",
        "parentId" : "67e394e6-4ee3-4067-a39e-2ab34a64db45",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "I had a PR once (with some tiny holes possible). Its not _that_ bad, it \"only\" affects 64bit windows, and any library should already be written in a non-insane way and not really notice the change much.\r\n\r\nMy problem is that we would have to some risk analysis probably. Its not like we can _warn_ about it... It doesn't make sense if every `np.arange` call or `np.array([3])` call spits out a warning.\r\n\r\nIt is something I would rather try with a \"major release\", but in cetero censeo: I think we should just plan one and hopefully tick of one or two other things.  But, I don't have the energy/motivation right now to attempt that without more encouragement.\r\n\r\n---\r\n\r\nAbout this, I am fine with going for it here (although maybe not `dtype=np.intp` which might force cast a float input).  But it needs to go through the mailing list, since it is technically an incompatible change without a deprecation period!",
        "createdAt" : "2021-02-11T19:28:54Z",
        "updatedAt" : "2021-02-25T13:06:55Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "72a4869c-3da7-4143-85af-c3018b0211b8",
        "parentId" : "67e394e6-4ee3-4067-a39e-2ab34a64db45",
        "authorId" : "ebbd559e-4e98-4695-a417-e4a6bc303d63",
        "body" : "> But it needs to go through the mailing list, since it is technically an incompatible change without a deprecation period!\r\n\r\nAh, that's something I hadn't actually, since I suppose that you don't _technically_ have to pass an integer `diag_indices`. In any case, this seemingly small change sounds like something that would benefit from a dedicated PR after all.",
        "createdAt" : "2021-02-12T14:50:48Z",
        "updatedAt" : "2021-02-25T13:06:55Z",
        "lastEditedBy" : "ebbd559e-4e98-4695-a417-e4a6bc303d63",
        "tags" : [
        ]
      }
    ],
    "commit" : "f345d732a97b647de1fb26aeae533ca48e8229e9",
    "line" : 176,
    "diffHunk" : "@@ -1,1 +174,178 @@\ndef fill_diagonal(a: ndarray[Any, Any], val: Any, wrap: bool = ...) -> None: ...\ndef diag_indices(n: int, ndim: int = ...) -> Tuple[_ArrayND[int_], ...]: ...\ndef diag_indices_from(arr: ArrayLike) -> Tuple[_ArrayND[int_], ...]: ...\n"
  },
  {
    "id" : "b28373ce-904e-4cc0-8370-9e04544031d1",
    "prId" : 18397,
    "prUrl" : "https://github.com/numpy/numpy/pull/18397#pullrequestreview-600161307",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6e6e1698-e117-4bbb-8de9-aea1fb27c840",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "These annotations seem odd to me - `ix_` just has an `ArrayLike` in each `args[i]`. Is there no way at the moment to type this as something like\r\n```\r\ndef ix_(*args: ArrayLike[T]) -> Tuple[_ArrayND[T], ...]: ...\r\n```\r\n",
        "createdAt" : "2021-02-14T13:29:26Z",
        "updatedAt" : "2021-02-25T13:06:55Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "484117e0-1b63-4971-a95b-8a98fcfbe940",
        "parentId" : "6e6e1698-e117-4bbb-8de9-aea1fb27c840",
        "authorId" : "ebbd559e-4e98-4695-a417-e4a6bc303d63",
        "body" : "The big challenge here is that we'd somehow have to express the builtin scalar types as some object parametrized w.r.t. `np.dtype`/`np.generic`, via a protocol for example: `SuperFancyProtocol[np.int_] == builtins.int`.\r\n\r\nThe problem is that no such protocol or object exists, so we're stuck with the current situation.\r\n\r\nThis is even more of an issue with dtypes, as there are roughly ~30 sets of string-literals that each map to their own dtype.",
        "createdAt" : "2021-02-14T15:49:14Z",
        "updatedAt" : "2021-02-25T13:06:55Z",
        "lastEditedBy" : "ebbd559e-4e98-4695-a417-e4a6bc303d63",
        "tags" : [
        ]
      },
      {
        "id" : "f08b2aa3-99a8-49d7-9de2-754ddf42cf55",
        "parentId" : "6e6e1698-e117-4bbb-8de9-aea1fb27c840",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Fair enough - I haven't been following the typing too closely.",
        "createdAt" : "2021-02-15T11:33:04Z",
        "updatedAt" : "2021-02-25T13:06:55Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "6f1849fa-9d08-4e51-966d-215aa66cd4c7",
        "parentId" : "6e6e1698-e117-4bbb-8de9-aea1fb27c840",
        "authorId" : "8ffdfffb-d8d9-40f6-9de3-dd0dee381149",
        "body" : "This was the same question I had, so let me unresolve this - it has value for people looking at this in the future.\r\n\r\nAlso, this is a good reason to exclude `dtype=builtins.int`, format strings and the like in `numpy.array_api` (NEP 47). For all the functions in that namespace the `func([ndarray[T]]) -> ndarray[T]: ...` pattern should work.",
        "createdAt" : "2021-02-27T15:16:41Z",
        "updatedAt" : "2021-02-27T15:16:41Z",
        "lastEditedBy" : "8ffdfffb-d8d9-40f6-9de3-dd0dee381149",
        "tags" : [
        ]
      }
    ],
    "commit" : "f345d732a97b647de1fb26aeae533ca48e8229e9",
    "line" : 88,
    "diffHunk" : "@@ -1,1 +86,90 @@def ix_(*args: _NestedSequence[complex]) -> Tuple[_ArrayND[complex_], ...]: ...\n@overload\ndef ix_(*args: _RecursiveSequence) -> Tuple[_ArrayND[Any], ...]: ...\n\nclass nd_grid(Generic[_BoolType]):"
  }
]
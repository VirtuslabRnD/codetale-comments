[
  {
    "id" : "cf87ae4a-45e0-4c6f-a110-15135ae14927",
    "prId" : 192,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "eeb8e6a7-800f-4d5a-a927-b5ee7b18f347",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Maybe explain this with a connection to image plots, where the 'x' typically runs left to right and is the 'fast' index. Or is that what this is about. Where would one use 'ij' ?\n",
        "createdAt" : "2012-02-01T03:58:04Z",
        "updatedAt" : "2012-02-05T14:57:50Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "b4c44beb-644c-4493-92f0-3e614530a6b8",
        "parentId" : "eeb8e6a7-800f-4d5a-a927-b5ee7b18f347",
        "authorId" : "1b526ef0-1c83-44be-b2b5-41cf1ee854e2",
        "body" : "I agree.  I find the \"matrix indexing\" versus \"Cartesian indexing\" description hard to understand.   I think you are talking about \"image\" conventions versus \"plotting\" conventions.  Is that correct? \n",
        "createdAt" : "2012-02-01T07:38:10Z",
        "updatedAt" : "2012-02-05T14:57:50Z",
        "lastEditedBy" : "1b526ef0-1c83-44be-b2b5-41cf1ee854e2",
        "tags" : [
        ]
      },
      {
        "id" : "f750562d-0fd1-47b4-a56d-4ffab4a207b8",
        "parentId" : "eeb8e6a7-800f-4d5a-a927-b5ee7b18f347",
        "authorId" : "8ffdfffb-d8d9-40f6-9de3-dd0dee381149",
        "body" : "Correct, image convention vs. just standard array/matrix indexing. Since this is the most confusing part apparently (see also discussion on this point at http://projects.scipy.org/numpy/ticket/966), I'm tempted to just leave out the `indexing` keyword after all. This seems to be confusing for Matlab users too, see for example the comments at http://blogs.mathworks.com/loren/2007/06/21/indexing-terminology/.\n\nThere really isn't an ideal solution here. \n\nNote that `mgrid` and `ogrid` use 'ij', while currently meshgrid uses 'xy':\n\n```\nIn [35]: mgrid[0:2, 3:5]\nOut[35]: \narray([[[0, 0],\n        [1, 1]],\n\n       [[3, 4],\n        [3, 4]]])\n\nIn [36]: meshgrid([0, 1], [3, 4])\nOut[36]: \n[array([[0, 1],\n       [0, 1]]), array([[3, 3],\n       [4, 4]])]\n```\n",
        "createdAt" : "2012-02-05T15:06:11Z",
        "updatedAt" : "2012-02-05T15:06:11Z",
        "lastEditedBy" : "8ffdfffb-d8d9-40f6-9de3-dd0dee381149",
        "tags" : [
        ]
      },
      {
        "id" : "780b6501-0bad-47fa-b853-957dee86302e",
        "parentId" : "eeb8e6a7-800f-4d5a-a927-b5ee7b18f347",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Maybe call ir 'image' indexing? I find in practice it is easier to settle on a single convention ('ij'), always put x in the first index, and just transpose for showing images. Mixing the conventions leads to all sorts of confusion.\n",
        "createdAt" : "2012-02-05T15:38:28Z",
        "updatedAt" : "2012-02-05T15:38:28Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "4e6d6cf4-4877-445f-8cc6-0bd3f618f999",
        "parentId" : "eeb8e6a7-800f-4d5a-a927-b5ee7b18f347",
        "authorId" : "8ffdfffb-d8d9-40f6-9de3-dd0dee381149",
        "body" : "Only using 'ij' would be best probably, but since currently `meshgrid` uses 'xy' we can't do that.\n",
        "createdAt" : "2012-02-05T15:41:00Z",
        "updatedAt" : "2012-02-05T15:41:00Z",
        "lastEditedBy" : "8ffdfffb-d8d9-40f6-9de3-dd0dee381149",
        "tags" : [
        ]
      },
      {
        "id" : "8fc3775d-77ff-4a3b-b887-d53bbea3652b",
        "parentId" : "eeb8e6a7-800f-4d5a-a927-b5ee7b18f347",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Oops, see, I already got confused ;) I think a different choice of names would clarify things, 'xy' seems ok, 'standard' would be another option, and then maybe 'image' for the second choice, with a short explanation (images are displayed left-right, top-bottom) and a translation for Matlab users.\n",
        "createdAt" : "2012-02-05T15:50:50Z",
        "updatedAt" : "2012-02-05T15:50:50Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "1deb66fe-aade-4ac3-a252-d70c7743088c",
        "parentId" : "eeb8e6a7-800f-4d5a-a927-b5ee7b18f347",
        "authorId" : "8ffdfffb-d8d9-40f6-9de3-dd0dee381149",
        "body" : "`ij` --> `image` sounds OK to me. Although I forgot the details by now. With added explanation it should work.\n",
        "createdAt" : "2012-05-28T17:39:56Z",
        "updatedAt" : "2012-05-28T17:39:56Z",
        "lastEditedBy" : "8ffdfffb-d8d9-40f6-9de3-dd0dee381149",
        "tags" : [
        ]
      }
    ],
    "commit" : "d48b756b232c99b6624d76db3188090052e0db60",
    "line" : 55,
    "diffHunk" : "@@ -1,1 +3242,3246 @@    argument.  Giving the string 'ij' returns a meshgrid with matrix indexing,\n    while 'xy' returns a meshgrid with Cartesian indexing.  In the 2-D case\n    with inputs of length M and N, the outputs are of shape (N, M) for 'xy'\n    indexing and (M, N) for 'ij' indexing.  In the 3-D case with inputs of\n    length M, N and P, outputs are of shape (N, M, P) for 'xy' indexing and (M,"
  },
  {
    "id" : "ac7a7823-986c-49ab-aae1-5a20a6bc85bf",
    "prId" : 192,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fda19608-5e4b-4b4b-afa0-f2aabcbea531",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "So 'xy' indexing only affects the first two axis?\n",
        "createdAt" : "2012-02-01T04:01:06Z",
        "updatedAt" : "2012-02-05T14:57:50Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "ba07668d-a0fe-490c-8a1e-925be52e3be7",
        "parentId" : "fda19608-5e4b-4b4b-afa0-f2aabcbea531",
        "authorId" : "8ffdfffb-d8d9-40f6-9de3-dd0dee381149",
        "body" : "yes\n",
        "createdAt" : "2012-02-05T15:07:06Z",
        "updatedAt" : "2012-02-05T15:07:06Z",
        "lastEditedBy" : "8ffdfffb-d8d9-40f6-9de3-dd0dee381149",
        "tags" : [
        ]
      }
    ],
    "commit" : "d48b756b232c99b6624d76db3188090052e0db60",
    "line" : 149,
    "diffHunk" : "@@ -1,1 +3316,3320 @@        output[1].shape = (-1, 1) + (1,)*(ndim - 2)\n        shape[0], shape[1] = shape[1], shape[0]\n\n    if sparse:\n        if copy_:"
  },
  {
    "id" : "f94b8f19-9044-4ea3-8e96-394c0aec7f9c",
    "prId" : 3658,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e0bc2ea4-ad9f-4e46-a231-5329cba74c14",
        "parentId" : null,
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "midpoint is not implemented\n\nshouldn't there be also be lowhigh, highlow and closest to be complete?\n",
        "createdAt" : "2013-08-29T15:47:09Z",
        "updatedAt" : "2013-09-16T16:47:13Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      },
      {
        "id" : "a14a2bd3-1afb-4c71-8465-931baa9fcae0",
        "parentId" : "e0bc2ea4-ad9f-4e46-a231-5329cba74c14",
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "forget highlow and lowhigh I was thinking only in terms of percentile with len(q) = 2 \n",
        "createdAt" : "2013-08-29T15:48:42Z",
        "updatedAt" : "2013-09-16T16:47:13Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      },
      {
        "id" : "8ff3fe5e-c540-444f-9b7d-240d10a919e9",
        "parentId" : "e0bc2ea4-ad9f-4e46-a231-5329cba74c14",
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "maybe 'nearest' is a better choice than closest?\nwould be more similar with matplotlibs imshow(interpolation='nearest')\n",
        "createdAt" : "2013-09-06T17:01:39Z",
        "updatedAt" : "2013-09-16T16:47:13Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      },
      {
        "id" : "0e156aed-683b-4b46-8491-701fa7b7bd4b",
        "parentId" : "e0bc2ea4-ad9f-4e46-a231-5329cba74c14",
        "authorId" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "body" : "Yeah, I agree on `\"nearest\"` -- the idiom is \"nearest neighbor\", not \"closest neighbor\".\n",
        "createdAt" : "2013-09-14T11:36:42Z",
        "updatedAt" : "2013-09-16T16:47:13Z",
        "lastEditedBy" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "tags" : [
        ]
      }
    ],
    "commit" : "9316110a42c370616cbb80ae3e1769534d04de10",
    "line" : 31,
    "diffHunk" : "@@ -1,1 +2787,2791 @@              fractional part of the index surrounded by `i` and `j`.\n            * lower: `i`.\n            * higher: `j`.\n            * nearest: `i` or `j` whichever is nearest.\n            * midpoint: (`i` + `j`) / 2."
  },
  {
    "id" : "d4d71cf7-89d0-495b-b251-1cf993480a4d",
    "prId" : 3775,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "88b59b8f-543a-4ce0-9477-c55d0c4ff856",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Can this line be broken after `not`?\n",
        "createdAt" : "2013-09-22T16:57:56Z",
        "updatedAt" : "2013-09-24T06:50:33Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "b55297be-67a2-4e56-88c5-806382bcc444",
        "parentId" : "88b59b8f-543a-4ce0-9477-c55d0c4ff856",
        "authorId" : "83f4e38e-88e6-4696-b8d1-477d2db3e891",
        "body" : "Then we'll need to break it to three lines.\n",
        "createdAt" : "2013-09-24T06:45:27Z",
        "updatedAt" : "2013-09-24T06:50:33Z",
        "lastEditedBy" : "83f4e38e-88e6-4696-b8d1-477d2db3e891",
        "tags" : [
        ]
      }
    ],
    "commit" : "ec50fb1b7683c44d065914b946d250dbe01aae9f",
    "line" : 274,
    "diffHunk" : "@@ -1,1 +690,694 @@    x = asanyarray(x)\n    n2 = len(funclist)\n    if (isscalar(condlist) or not (isinstance(condlist[0], list) or\n                                   isinstance(condlist[0], ndarray))):\n        condlist = [condlist]"
  },
  {
    "id" : "3905e09c-8ce8-44df-8d92-8bcfcc880745",
    "prId" : 3775,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7112c930-5645-4c4d-b393-46f21d65f6e3",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "keep is an array, so can remove `,` in the indexing.\n",
        "createdAt" : "2013-09-27T03:05:29Z",
        "updatedAt" : "2013-09-27T03:05:29Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "ec50fb1b7683c44d065914b946d250dbe01aae9f",
    "line" : 1004,
    "diffHunk" : "@@ -1,1 +3413,3417 @@            obj = obj[positive_indices]\n\n        keep[obj, ] = False\n        slobj[axis] = keep\n        new = arr[slobj]"
  },
  {
    "id" : "8d4357ab-f071-4196-acb4-cbf3ab759d4f",
    "prId" : 3908,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bf035c93-25a6-44dd-8f4c-8ce3a0d01928",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Could maybe simplify this, as `axis=tuple(...)` is currently the only alternative to a single integer.\n",
        "createdAt" : "2014-03-13T00:31:05Z",
        "updatedAt" : "2014-03-13T20:10:53Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "1cce771c-e4da-44ad-a553-23a20220d9bb",
        "parentId" : "bf035c93-25a6-44dd-8f4c-8ce3a0d01928",
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "can you elaborate? I don't understand what you mean\n",
        "createdAt" : "2014-03-13T18:11:22Z",
        "updatedAt" : "2014-03-13T20:10:53Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      },
      {
        "id" : "076f40b7-7c9a-4cf0-acb9-f0ac4a3d70fc",
        "parentId" : "bf035c93-25a6-44dd-8f4c-8ce3a0d01928",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "I was thinking just check for tuple instead of the try...except construct. But that is minor and the current approach might be safer.\n",
        "createdAt" : "2014-03-13T19:05:54Z",
        "updatedAt" : "2014-03-13T20:10:53Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "7d53c812d3e68ff28320ee7e32bc9816937b4142",
    "line" : 44,
    "diffHunk" : "@@ -1,1 +2727,2731 @@        keepdim = list(a.shape)\n        nd = a.ndim\n        try:\n            axis = operator.index(axis)\n            if axis >= nd or axis < -nd:"
  },
  {
    "id" : "9579ad26-5d58-4bb2-aebb-d4dc0ec9ea80",
    "prId" : 3908,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2e95181f-ac94-4939-8bc8-c26d0596d5e0",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Curious note, the result of `a.sum()` is not writeable, but the reshaped view is. That only seems to happen for 0-D arrays. Hmm...\n",
        "createdAt" : "2014-03-13T00:41:15Z",
        "updatedAt" : "2014-03-13T20:10:53Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "7d53c812d3e68ff28320ee7e32bc9816937b4142",
    "line" : 110,
    "diffHunk" : "@@ -1,1 +2841,2845 @@                    overwrite_input=overwrite_input)\n    if keepdims:\n        return r.reshape(k)\n    else:\n        return r"
  },
  {
    "id" : "d4e35dcd-035d-41ea-85e9-57db05aa4ec0",
    "prId" : 4089,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "62e45d74-ee7e-4da6-a826-1d91bfdb8428",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Do we check for `values.ndim == 0`?\n",
        "createdAt" : "2013-12-02T16:22:33Z",
        "updatedAt" : "2013-12-02T16:22:33Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "34bf0358-f734-479a-ae45-bf4714df863e",
        "parentId" : "62e45d74-ee7e-4da6-a826-1d91bfdb8428",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "It is safe, inserting into a 0-dim array does not make sense (it errors out/special cased before this).\n",
        "createdAt" : "2013-12-02T17:39:51Z",
        "updatedAt" : "2013-12-02T17:39:51Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      }
    ],
    "commit" : "9d6caf9710e98af2a99cc72650b95dd7ea0727ee",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +3608,3612 @@            # very different from a[:,[0],:] = ...! This changes values so that\n            # it works likes the second case. (here a[:,0:1,:])\n            values = np.rollaxis(values, 0, (axis % values.ndim) + 1)\n        numnew = values.shape[axis]\n        newshape[axis] += numnew"
  },
  {
    "id" : "2f7c7647-b351-4063-8415-5a136453d1e5",
    "prId" : 4358,
    "prUrl" : "https://github.com/numpy/numpy/pull/4358#pullrequestreview-92009684",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f38168fd-9a57-478f-8337-a26fd2d3712d",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "What's the rationale for deprecating this?",
        "createdAt" : "2017-10-22T23:50:44Z",
        "updatedAt" : "2017-10-22T23:51:22Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "2ab149e9-643b-41be-be2f-d2b7e4e30917",
        "parentId" : "f38168fd-9a57-478f-8337-a26fd2d3712d",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Don't remember, maybe you would not know the result shape?",
        "createdAt" : "2017-10-23T18:26:53Z",
        "updatedAt" : "2017-10-23T18:26:54Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "a91c5363-5d38-41bd-a2eb-bb53f9ff3530",
        "parentId" : "f38168fd-9a57-478f-8337-a26fd2d3712d",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Or the correct dtype, the comment above seems like an oversight that should be removed",
        "createdAt" : "2017-10-23T18:28:19Z",
        "updatedAt" : "2017-10-23T18:28:19Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "030293f9-13ec-47af-9291-af0ba9e92455",
        "parentId" : "f38168fd-9a57-478f-8337-a26fd2d3712d",
        "authorId" : "0424b539-8828-4e4b-b0c7-8a8f1726b0f0",
        "body" : "@eric-wieser \r\n\r\nWhat would be the semantic meaning of numpy.select without any basis for selecting?\r\n\r\nby analogy:    1+    <--- what is the meaning of + without a thing to add?",
        "createdAt" : "2018-01-26T21:15:18Z",
        "updatedAt" : "2018-01-26T21:15:18Z",
        "lastEditedBy" : "0424b539-8828-4e4b-b0c7-8a8f1726b0f0",
        "tags" : [
        ]
      },
      {
        "id" : "433ca3dd-6f4a-43c5-909c-038408c5428a",
        "parentId" : "f38168fd-9a57-478f-8337-a26fd2d3712d",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "The problem is not the basis of selecting, but the shape of what is \"inside\" choicelist being unknown. I think this was actually about choicelist being empty more then condlist being empty probably.\r\n\r\nTo be honest, it would somewhat make sense to allow it if default is passed in and can be used to get the shape. That seems dubious though (and even if, it seems like this needs to be deprecated first).\r\n\r\nAnyway, I am starting to have memories of a similar discussion, so nvm. if Eric is still curious will look at it again.",
        "createdAt" : "2018-01-26T21:38:40Z",
        "updatedAt" : "2018-01-26T21:38:40Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "fd941e25-772f-4f74-919d-6c039a17470c",
        "parentId" : "f38168fd-9a57-478f-8337-a26fd2d3712d",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "> To be honest, it would somewhat make sense to allow it if default is passed in and can be used to get the shape. \r\n\r\nThis is the point I was making. By having a default, the operation becomes well-defined - in the same way that `max([])` is an error in python, but `max([], default=0)` is not",
        "createdAt" : "2018-01-27T01:08:39Z",
        "updatedAt" : "2018-01-27T01:08:39Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "c221389f-14d8-4978-9843-5108a6896b40",
        "parentId" : "f38168fd-9a57-478f-8337-a26fd2d3712d",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "> What would be the semantic meaning of numpy.select without any basis for selecting?\r\n\r\nPhrase it as _\"choose `choicelist[i]` if `condlist[i]` is `True`. If not any of `condlist[i]` are `True`, choose `default`\"_, and the semantic meaning is clear, because `not any([])` is defined as True",
        "createdAt" : "2018-01-27T01:12:28Z",
        "updatedAt" : "2018-01-27T01:12:54Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "123b319be37f01e3c4f2e42552d4ca121b27ca38",
    "line" : 36,
    "diffHunk" : "@@ -1,1 +781,785 @@                      \"and will be deprecated\",\n                      DeprecationWarning)\n        return np.asarray(default)[()]\n\n    choicelist = [np.asarray(choice) for choice in choicelist]"
  },
  {
    "id" : "97414216-3996-4a7c-b2c6-2af496b4789e",
    "prId" : 4405,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ee8c46f0-a763-4a87-a46e-0386468a09c4",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Probably not the simplest fix, but OK.\n",
        "createdAt" : "2014-03-01T14:57:35Z",
        "updatedAt" : "2014-03-01T14:57:35Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "1f7022c70b4ec64611ff311abe8779e4a2deda58",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +366,370 @@            on_edge = (around(sample[:, i], decimal) == around(edges[i][-1], decimal))\n            # Shift these points one bin to the left.\n            Ncount[i][where(on_edge & not_smaller_than_edge)[0]] -= 1\n\n    # Flattened histogram matrix (1D)"
  },
  {
    "id" : "19226555-ff81-481c-b35f-09504a5472f5",
    "prId" : 4792,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "cc04d4c7-4f19-4e55-abef-316e36ebfef2",
        "parentId" : null,
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "do we need to define the value?\nif not I think it would be better to leave it undefined for now. Just to keep options open to use the ufunc `where=` argument in future for some things\n",
        "createdAt" : "2014-06-08T12:38:51Z",
        "updatedAt" : "2014-06-08T13:41:05Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      },
      {
        "id" : "69172261-273d-40ee-8cf8-9429510875a5",
        "parentId" : "cc04d4c7-4f19-4e55-abef-316e36ebfef2",
        "authorId" : "2a53bb37-068e-4640-a89e-6420b778e916",
        "body" : "I also think it would be better to leave it `nan` but that changes the behaviour of the function. I have no problem in addressing that if you devs agree.\n",
        "createdAt" : "2014-06-08T12:57:23Z",
        "updatedAt" : "2014-06-08T13:41:05Z",
        "lastEditedBy" : "2a53bb37-068e-4640-a89e-6420b778e916",
        "tags" : [
        ]
      },
      {
        "id" : "09ea1bdc-c245-49a7-9c0b-c727c4aab95a",
        "parentId" : "cc04d4c7-4f19-4e55-abef-316e36ebfef2",
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "yes nan would make more sense but we want to release 1.9 soon and I don't want to rush in a change that might bite us later\nleaving the status quo of undefined is safer, we can revisit for 1.10\n",
        "createdAt" : "2014-06-08T13:12:04Z",
        "updatedAt" : "2014-06-08T13:41:05Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      },
      {
        "id" : "12b0c530-34eb-48bc-8fca-0113e2fb1e43",
        "parentId" : "cc04d4c7-4f19-4e55-abef-316e36ebfef2",
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "not fixed yet\n",
        "createdAt" : "2014-06-08T13:27:04Z",
        "updatedAt" : "2014-06-08T13:41:05Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      },
      {
        "id" : "cdd2934c-b6c3-4a43-8ae5-1f312a887528",
        "parentId" : "cc04d4c7-4f19-4e55-abef-316e36ebfef2",
        "authorId" : "2a53bb37-068e-4640-a89e-6420b778e916",
        "body" : "Excuse me, the status quo now is not undefined, but 0 as a default: that's what I kept in these changes. In fact most of the tests rely on this, see https://github.com/Juanlu001/numpy/blob/292b9ff538ea4950c7380c76cf65d1a5b108b75c/numpy/lib/tests/test_function_base.py#L1466. Either I set this to `nan` or leave it as it is now, but in this case the docs were wrong.\n",
        "createdAt" : "2014-06-08T13:48:32Z",
        "updatedAt" : "2014-06-08T13:48:32Z",
        "lastEditedBy" : "2a53bb37-068e-4640-a89e-6420b778e916",
        "tags" : [
        ]
      },
      {
        "id" : "bb952aff-b069-4be4-a0a2-de12f71c8ace",
        "parentId" : "cc04d4c7-4f19-4e55-abef-316e36ebfef2",
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "in principle the documentation defines the interface but if our tets rely on it maybe also third party software\n\nusing 0 has the advantages that it is defined for all types (including integers) and the memory can be sparsely allocated on capable operating systems, so I guess it is fine to keep it.\nthanks, merging\n",
        "createdAt" : "2014-06-08T14:01:30Z",
        "updatedAt" : "2014-06-08T14:01:30Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      }
    ],
    "commit" : "292b9ff538ea4950c7380c76cf65d1a5b108b75c",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +652,656 @@        calling the functions in `funclist` on the appropriate portions of `x`,\n        as defined by the boolean arrays in `condlist`.  Portions not covered\n        by any condition have a default value of 0.\n\n"
  },
  {
    "id" : "cdf3231b-eebd-420a-9e3f-d41173af5aad",
    "prId" : 4792,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "dc3020c0-ba8e-40ca-b370-38296d6405b6",
        "parentId" : null,
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "not something for this PR but the following part could maybe use np.select somehow, just to reduce the optimization targets, e.g. select uses copyto instead of indexing as its a little faster.\n",
        "createdAt" : "2014-06-08T12:40:54Z",
        "updatedAt" : "2014-06-08T13:41:05Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      },
      {
        "id" : "d0c47b61-c7e4-4d3d-bab6-8c9c1ed8ad3a",
        "parentId" : "dc3020c0-ba8e-40ca-b370-38296d6405b6",
        "authorId" : "2a53bb37-068e-4640-a89e-6420b778e916",
        "body" : "Actually I tend to use `select` myself and avoid `piecewise` because of these little annoyances. I can quickly try it or leave it for the next version.\n",
        "createdAt" : "2014-06-08T12:59:18Z",
        "updatedAt" : "2014-06-08T13:41:05Z",
        "lastEditedBy" : "2a53bb37-068e-4640-a89e-6420b778e916",
        "tags" : [
        ]
      },
      {
        "id" : "76bf8c5b-7f8e-4db6-bb33-32a20285a531",
        "parentId" : "dc3020c0-ba8e-40ca-b370-38296d6405b6",
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "lets leave that to the next version\n",
        "createdAt" : "2014-06-08T13:12:43Z",
        "updatedAt" : "2014-06-08T13:41:05Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      }
    ],
    "commit" : "292b9ff538ea4950c7380c76cf65d1a5b108b75c",
    "line" : 52,
    "diffHunk" : "@@ -1,1 +714,718 @@\n    y = zeros(x.shape, x.dtype)\n    for k in range(n):\n        item = funclist[k]\n        if not isinstance(item, collections.Callable):"
  },
  {
    "id" : "e3bfa868-e716-48de-9494-f43780548178",
    "prId" : 4960,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "47940521-3c35-4244-86b8-7c017ec7ca8c",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "OK.\n",
        "createdAt" : "2015-05-12T19:03:25Z",
        "updatedAt" : "2015-05-13T09:00:54Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "d87d2ca584b888bcc48fd2fd25c07eb0c08c0939",
    "line" : null,
    "diffHunk" : "@@ -1,1 +2006,2010 @@    # Determine the normalization\n    if w is None:\n        fact = float(X.shape[1] - ddof)\n    else:\n        if ddof == 0:"
  },
  {
    "id" : "3d99cdce-0213-47e4-b35f-4e33e8d0ba1d",
    "prId" : 4960,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2af6cf22-e8cb-41fd-b310-35a9921dcc15",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "OK.\n",
        "createdAt" : "2015-05-12T19:04:16Z",
        "updatedAt" : "2015-05-13T09:00:54Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "d87d2ca584b888bcc48fd2fd25c07eb0c08c0939",
    "line" : null,
    "diffHunk" : "@@ -1,1 +2014,2018 @@        else:\n            fact = w_sum - ddof*sum(w*aweights)/w_sum\n\n    if fact <= 0:\n        warnings.warn(\"Degrees of freedom <= 0 for slice\", RuntimeWarning)"
  },
  {
    "id" : "11de1278-8bd1-4faa-8fb5-74bbcb777339",
    "prId" : 4960,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e0457d13-6d39-4a65-a166-7becbb64013e",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Hmm, I see this is inherited, `X.shape[0] == 1]` always overrode `rowvar == 0`. Doesn't seem right, but that is how it was...\n",
        "createdAt" : "2015-05-12T22:25:33Z",
        "updatedAt" : "2015-05-13T09:00:54Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "d87d2ca584b888bcc48fd2fd25c07eb0c08c0939",
    "line" : 102,
    "diffHunk" : "@@ -1,1 +1952,1956 @@        dtype = np.result_type(m, y, np.float64)\n    X = array(m, ndmin=2, dtype=dtype)\n    if rowvar == 0 and X.shape[0] != 1:\n        X = X.T\n    if X.shape[0] == 0:"
  },
  {
    "id" : "9c033edc-aae6-4e56-89aa-a910731a7421",
    "prId" : 5117,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bbedcb76-6c9b-4660-9369-ab18d2512726",
        "parentId" : null,
        "authorId" : "34105ae0-9fd2-4403-be9b-7c550a729828",
        "body" : "I don't like this code repetition... You could integrate all this first branch into the code below, have a common code base for handling the array checks, branch only to do the modulo, sorting, appending and prepending if `period` is not `None`, and finish with a single call to `compiled_interp`. I think it would be cleaner.\n",
        "createdAt" : "2014-09-26T05:40:51Z",
        "updatedAt" : "2014-10-17T06:16:15Z",
        "lastEditedBy" : "34105ae0-9fd2-4403-be9b-7c550a729828",
        "tags" : [
        ]
      },
      {
        "id" : "1d684816-935c-4285-8465-24f71950f8fe",
        "parentId" : "bbedcb76-6c9b-4660-9369-ab18d2512726",
        "authorId" : "34105ae0-9fd2-4403-be9b-7c550a729828",
        "body" : "What happens if `period <= 0`? Is the behavior well defined? Or should an error be raised?\n",
        "createdAt" : "2014-09-26T05:41:52Z",
        "updatedAt" : "2014-10-17T06:16:15Z",
        "lastEditedBy" : "34105ae0-9fd2-4403-be9b-7c550a729828",
        "tags" : [
        ]
      },
      {
        "id" : "15471224-b040-42df-b8e0-09193cc39d2d",
        "parentId" : "bbedcb76-6c9b-4660-9369-ab18d2512726",
        "authorId" : "bbf79ef1-9dc7-4be3-914e-a2ad60fdf617",
        "body" : "@jaimefrio I liked to keep the two branches because the additional overhead cost of this enhancement will be only a `is None` check... if I had to perform the other checks for all cases there would be a higher overhead...\n\nSecond question about `period <= 0`... being checked\n",
        "createdAt" : "2014-09-26T06:03:53Z",
        "updatedAt" : "2014-10-17T06:16:15Z",
        "lastEditedBy" : "bbf79ef1-9dc7-4be3-914e-a2ad60fdf617",
        "tags" : [
        ]
      },
      {
        "id" : "7eed27ec-01be-4dc8-8fe2-cf2a7807049c",
        "parentId" : "bbedcb76-6c9b-4660-9369-ab18d2512726",
        "authorId" : "bbf79ef1-9dc7-4be3-914e-a2ad60fdf617",
        "body" : "@jaimefrio an error should be raised only for `period==0`... and do `period = abs(period)` to guarantee a positive period.... otherwise I would have to change this:\n\n```\n        xp = np.concatenate((xp[-1:]-abs(period), xp, xp[0:1]+abs(period)))\n```\n\ni.e. adding two times `abs()`\n",
        "createdAt" : "2014-09-26T06:13:53Z",
        "updatedAt" : "2014-10-17T06:16:15Z",
        "lastEditedBy" : "bbf79ef1-9dc7-4be3-914e-a2ad60fdf617",
        "tags" : [
        ]
      }
    ],
    "commit" : "498b84a35da66bceb1b08e49ee4dcd02c870e5fe",
    "line" : 67,
    "diffHunk" : "@@ -1,1 +1200,1204 @@\n    \"\"\"\n    if period is None:\n        if isinstance(x, (float, int, number)):\n            return compiled_interp([x], xp, fp, left, right).item()"
  },
  {
    "id" : "5b324404-208b-4c47-bd80-89c7d96a89ab",
    "prId" : 6029,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8ecad1f1-e966-4052-8141-ef38ccf3ef42",
        "parentId" : null,
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "I would say, putting it only with the keyword is sufficient (but frankly we have reached bikeshedding). The other option we do is to putting it only in the Notes section. So will put this in soon (unless someone beats me to it). Lets not start breaking rules again, rather hope that 1.11 is soon. I feel there may be some nice things coming up soon enough ;).\n",
        "createdAt" : "2015-08-14T19:37:44Z",
        "updatedAt" : "2015-08-14T19:37:44Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      }
    ],
    "commit" : "388ee595330e2375a1e4c8187c17de7ea9fb2f6f",
    "line" : 143,
    "diffHunk" : "@@ -1,1 +253,257 @@    4.\n\n    .. versionadded:: 1.11.0\n\n    The methods to estimate the optimal number of bins are well found in literature,"
  },
  {
    "id" : "64295e51-d197-45fb-8b8f-b364b1edafb3",
    "prId" : 6100,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d7c35edb-b67c-4bdc-9cbc-718865bf2197",
        "parentId" : null,
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "this seems poorly chosen, this is one L1 cache and numpy likes its copies so you always end up wiping it.\nI get a 30% performance increase for N = 20000 when block is 4 times smaller, though the same can be achived by doing the keep computation in place.\n",
        "createdAt" : "2015-07-22T19:50:15Z",
        "updatedAt" : "2015-07-23T07:17:05Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      },
      {
        "id" : "999f393b-11b5-42bf-bbda-b9fddc0e163f",
        "parentId" : "d7c35edb-b67c-4bdc-9cbc-718865bf2197",
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "ah its not the cache (it is very hard to make use of L1 with numpy unfortunately), its removes 200.000 page faults, 64k seems to trigger some different code path in glibc, not sure why yet, glibc usually only switches allocation mode at much larger values\n",
        "createdAt" : "2015-07-22T19:54:27Z",
        "updatedAt" : "2015-07-23T07:17:05Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      },
      {
        "id" : "176fd586-ba8f-4ed4-8b72-b66c73143a2e",
        "parentId" : "d7c35edb-b67c-4bdc-9cbc-718865bf2197",
        "authorId" : "3c0a8102-3ad5-4f4a-9deb-148e8660e2cc",
        "body" : "Just to clarify, I just used the value that was set for the original slow method, but as I indicated in https://github.com/numpy/numpy/pull/6100#issuecomment-123618622 for large arrays we'd actually benefit from a slightly larger block size.\n\nRather than spend too much time trying to find a one-size-fits-all block size, I would suggest leaving the block size for now since this is code that I plan to try and replace with a C iteration (as @jaimefrio and I were discussing).\n\nHowever, I agree that the keep operation could be done in-place instead. I'll look at this now.\n",
        "createdAt" : "2015-07-22T19:57:33Z",
        "updatedAt" : "2015-07-23T07:17:05Z",
        "lastEditedBy" : "3c0a8102-3ad5-4f4a-9deb-148e8660e2cc",
        "tags" : [
        ]
      },
      {
        "id" : "6b45b2fe-d130-4a24-8315-28c26a7d5ba2",
        "parentId" : "d7c35edb-b67c-4bdc-9cbc-718865bf2197",
        "authorId" : "3c0a8102-3ad5-4f4a-9deb-148e8660e2cc",
        "body" : "@juliantaylor - actually could you clarify what you mean by doing the keep computation inplace? I tried doing:\n\n``` python\nkeep = tmp_a >= mn\nnp.logical_and(keep,  tmp_a <= mx, out=keep)\n```\n\nbut I don't see any improvements. Did you mean something else?\n\nI also just checked with `BLOCK=65536/4` for different array sizes from 1 to 1e8 but couldn't see any for which this was faster than the current block size.\n",
        "createdAt" : "2015-07-22T20:08:52Z",
        "updatedAt" : "2015-07-23T07:17:05Z",
        "lastEditedBy" : "3c0a8102-3ad5-4f4a-9deb-148e8660e2cc",
        "tags" : [
        ]
      },
      {
        "id" : "08a42107-135d-4d9f-bd22-f168ec53b11d",
        "parentId" : "d7c35edb-b67c-4bdc-9cbc-718865bf2197",
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "this is more readable:\n\n```\n        keep = (tmp_a >= mn)\n        keep &= (tmp_a <= mx)\n```\n\nI don't really understand what is going on, though my simple testcase seems to trigger some bad memory allocation pattern. If I add another histogram call of another size it disappears.\nIt still might be a good idea as its there is at least one case where its significantly better and just adds one line\n",
        "createdAt" : "2015-07-22T20:25:06Z",
        "updatedAt" : "2015-07-23T07:17:05Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      },
      {
        "id" : "158da90d-7823-4bd8-87ab-0b177568e745",
        "parentId" : "d7c35edb-b67c-4bdc-9cbc-718865bf2197",
        "authorId" : "3c0a8102-3ad5-4f4a-9deb-148e8660e2cc",
        "body" : "Ok, done in 46b28f30539bacc19e803f4392fab95fc3c127db!\n",
        "createdAt" : "2015-07-22T20:36:17Z",
        "updatedAt" : "2015-07-23T07:17:05Z",
        "lastEditedBy" : "3c0a8102-3ad5-4f4a-9deb-148e8660e2cc",
        "tags" : [
        ]
      }
    ],
    "commit" : "34b582aadae8272e7b7209f7a05594e9258ba217",
    "line" : 12,
    "diffHunk" : "@@ -1,1 +184,188 @@    # We set a block size, as this allows us to iterate over chunks when\n    # computing histograms, to minimize memory usage.\n    BLOCK = 65536\n\n    if not iterable(bins):"
  },
  {
    "id" : "6b6ce373-605b-4405-9114-3f337ee6434e",
    "prId" : 6100,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6e1734fc-03b1-4f91-b8ac-7520f9550bba",
        "parentId" : null,
        "authorId" : "34105ae0-9fd2-4403-be9b-7c550a729828",
        "body" : "I think the correct iteration limit is something like `range(0, ((len(a) - 1) // BLOCK + 1) * BLOCK, BLOCK)`. With the current limit an array of size a multiple of `BLOCK` will run an extra iteration on an empty array.\n\nAlso, I think using Python's `range` here is better than NumPy's `arange`, as it will be an iterator in Py3K, and in Python 2 building a list is typically faster than an array.\n",
        "createdAt" : "2015-07-23T08:05:00Z",
        "updatedAt" : "2015-07-23T08:05:00Z",
        "lastEditedBy" : "34105ae0-9fd2-4403-be9b-7c550a729828",
        "tags" : [
        ]
      },
      {
        "id" : "9804b3da-90bd-4ae1-a4b1-d5b920b859d0",
        "parentId" : "6e1734fc-03b1-4f91-b8ac-7520f9550bba",
        "authorId" : "3c0a8102-3ad5-4f4a-9deb-148e8660e2cc",
        "body" : "Should I change this for the 'original' method too? (I copied it from there)\n",
        "createdAt" : "2015-07-23T08:57:51Z",
        "updatedAt" : "2015-07-23T08:57:51Z",
        "lastEditedBy" : "3c0a8102-3ad5-4f4a-9deb-148e8660e2cc",
        "tags" : [
        ]
      },
      {
        "id" : "ef30d2dd-3aee-44af-b384-520487ee1ef2",
        "parentId" : "6e1734fc-03b1-4f91-b8ac-7520f9550bba",
        "authorId" : "3c0a8102-3ad5-4f4a-9deb-148e8660e2cc",
        "body" : "@jaimefrio - are you sure about the extra iteration? If len(a) is a multiple of BLOCKSIZE, then because range is exclusive at the upper end, I think it does the right thing:\n\n```\nIn [3]: np.arange(0, 30, 10)\nOut[3]: array([ 0, 10, 20])\n```\n\n(but yes, we could simply change to Python's range)\n",
        "createdAt" : "2015-07-23T08:59:58Z",
        "updatedAt" : "2015-07-23T08:59:58Z",
        "lastEditedBy" : "3c0a8102-3ad5-4f4a-9deb-148e8660e2cc",
        "tags" : [
        ]
      },
      {
        "id" : "8d448742-f878-4ad5-bd75-9b6e6176ffbb",
        "parentId" : "6e1734fc-03b1-4f91-b8ac-7520f9550bba",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Yes, and `a[20:20+10]` is the full last block.\nedit: maybe the confusing thing  is that python ranges do not care about out of bounds.\n",
        "createdAt" : "2015-07-23T09:27:08Z",
        "updatedAt" : "2015-07-23T09:28:31Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "9cec9f73-1826-48bf-9612-0b5225debce1",
        "parentId" : "6e1734fc-03b1-4f91-b8ac-7520f9550bba",
        "authorId" : "3c0a8102-3ad5-4f4a-9deb-148e8660e2cc",
        "body" : "@seberg - so you agree that the only thing that needs changing is `arange` -> `range`, but otherwise it's ok? (want to make sure I wait until there is a consensus otherwise if I amend the existing commit and force push it might get rid of this thread)\n",
        "createdAt" : "2015-07-23T10:35:28Z",
        "updatedAt" : "2015-07-23T10:35:28Z",
        "lastEditedBy" : "3c0a8102-3ad5-4f4a-9deb-148e8660e2cc",
        "tags" : [
        ]
      },
      {
        "id" : "067cc267-86dd-473a-a920-c8ee6bb3bbe6",
        "parentId" : "6e1734fc-03b1-4f91-b8ac-7520f9550bba",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Sorry, would look like it to me, it was a bit of a stupid comment, misread the rest.\n",
        "createdAt" : "2015-07-23T10:57:17Z",
        "updatedAt" : "2015-07-23T10:57:17Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "039a6e53-da63-4ed9-aac1-c38d4000e690",
        "parentId" : "6e1734fc-03b1-4f91-b8ac-7520f9550bba",
        "authorId" : "3c0a8102-3ad5-4f4a-9deb-148e8660e2cc",
        "body" : "@jaimefrio - do you agree? If so, will make the `arange` -> `range` change\n",
        "createdAt" : "2015-07-23T11:49:44Z",
        "updatedAt" : "2015-07-23T11:49:44Z",
        "lastEditedBy" : "3c0a8102-3ad5-4f4a-9deb-148e8660e2cc",
        "tags" : [
        ]
      },
      {
        "id" : "964a2f6e-893c-475a-bac4-4a2defc39346",
        "parentId" : "6e1734fc-03b1-4f91-b8ac-7520f9550bba",
        "authorId" : "34105ae0-9fd2-4403-be9b-7c550a729828",
        "body" : "And that's why you don't review code after midnight... You, and whoever wrote the first version, are absolutely right, I was absolutely wrong. I won't make you push yet another change for the range/arange thing.\n",
        "createdAt" : "2015-07-23T14:53:21Z",
        "updatedAt" : "2015-07-23T14:53:21Z",
        "lastEditedBy" : "34105ae0-9fd2-4403-be9b-7c550a729828",
        "tags" : [
        ]
      }
    ],
    "commit" : "34b582aadae8272e7b7209f7a05594e9258ba217",
    "line" : 41,
    "diffHunk" : "@@ -1,1 +220,224 @@        # limit of large arrays.\n        for i in arange(0, len(a), BLOCK):\n            tmp_a = a[i:i+BLOCK]\n            if weights is None:\n                tmp_w = None"
  },
  {
    "id" : "dcef3ff1-f8ed-414a-b783-a3dda86e0655",
    "prId" : 6100,
    "prUrl" : "https://github.com/numpy/numpy/pull/6100#pullrequestreview-70455498",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9cb2800f-d779-48c7-bfb3-d253959c52a0",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "What is the rationale for this? What type of weight would not work here?",
        "createdAt" : "2017-10-19T06:10:09Z",
        "updatedAt" : "2017-10-19T06:10:09Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "b6f6da66-59bf-4abf-9f82-d4af940b0100",
        "parentId" : "9cb2800f-d779-48c7-bfb3-d253959c52a0",
        "authorId" : "3c0a8102-3ad5-4f4a-9deb-148e8660e2cc",
        "body" : "I can't remember for sure, but I think e.g. object arrays work in the weights array:\r\n\r\n```python\r\nIn [7]: np.histogram([1,2,3], weights=np.array([Decimal(1), Decimal(2.2), Decimal(4.4)], dtype=np.object))\r\nOut[7]: \r\n(array([Decimal('1'), Decimal('0'), Decimal('0'), Decimal('0'),\r\n        Decimal('0'), Decimal('2.200000000000000177635683940'),\r\n        Decimal('0E-27'), Decimal('0E-27'), Decimal('0E-27'),\r\n        Decimal('4.400000000000000355271367880')], dtype=object),\r\n array([ 1. ,  1.2,  1.4,  1.6,  1.8,  2. ,  2.2,  2.4,  2.6,  2.8,  3. ]))\r\n```",
        "createdAt" : "2017-10-19T08:08:16Z",
        "updatedAt" : "2017-10-19T08:08:24Z",
        "lastEditedBy" : "3c0a8102-3ad5-4f4a-9deb-148e8660e2cc",
        "tags" : [
        ]
      },
      {
        "id" : "e0173e02-72cf-43b3-865b-257fbf63ee3e",
        "parentId" : "9cb2800f-d779-48c7-bfb3-d253959c52a0",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Yep, that's it, thanks - you're guarding `bincount`, that only works for the types you list there.",
        "createdAt" : "2017-10-19T08:24:35Z",
        "updatedAt" : "2017-10-19T08:24:35Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "34b582aadae8272e7b7209f7a05594e9258ba217",
    "line" : 22,
    "diffHunk" : "@@ -1,1 +201,205 @@            mx += 0.5\n        # At this point, if the weights are not integer, floating point, or\n        # complex, we have to use the slow algorithm.\n        if weights is not None and not (np.can_cast(weights.dtype, np.double) or\n                                        np.can_cast(weights.dtype, np.complex)):"
  },
  {
    "id" : "06a62b2d-e797-4400-9ef5-472b224e8037",
    "prId" : 6129,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1192f35d-43d3-4215-a160-e6e667cdd770",
        "parentId" : null,
        "authorId" : "34105ae0-9fd2-4403-be9b-7c550a729828",
        "body" : "Unless I am missing something, this code will error on an explicit `None` passed in by the user, which is documented as being equivalent as \"over all axes.\"\n\nMy suggestion would be to have the default value when you `.pop` `'axis'` be `None`, then immediately check if `axes` is `None` and have it replaced by `tuple(range(N))`: it kind of makes the code tell the story both of `None` being the default, and of it meaning all axes.\n",
        "createdAt" : "2015-08-17T14:59:28Z",
        "updatedAt" : "2015-09-06T12:42:54Z",
        "lastEditedBy" : "34105ae0-9fd2-4403-be9b-7c550a729828",
        "tags" : [
        ]
      }
    ],
    "commit" : "bc1990e770966535d188785cafaa3230c0a0377e",
    "line" : 65,
    "diffHunk" : "@@ -1,1 +1185,1189 @@        axes = (axes,)\n    if not isinstance(axes, tuple):\n        raise TypeError(\"A tuple of integers or a single integer is required\")\n\n    # normalize axis values:"
  },
  {
    "id" : "9b99b6d7-f89e-462b-aee9-a7080927b669",
    "prId" : 6129,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e7c093b6-c5a2-4ab4-9e05-280055294ad4",
        "parentId" : null,
        "authorId" : "34105ae0-9fd2-4403-be9b-7c550a729828",
        "body" : "Interesting way of doing it: I would have written this as `any(x >= N or x < 0 for x in axes)`, but your approach is perfectly fine.\n",
        "createdAt" : "2015-08-17T15:05:05Z",
        "updatedAt" : "2015-09-06T12:42:54Z",
        "lastEditedBy" : "34105ae0-9fd2-4403-be9b-7c550a729828",
        "tags" : [
        ]
      }
    ],
    "commit" : "bc1990e770966535d188785cafaa3230c0a0377e",
    "line" : 69,
    "diffHunk" : "@@ -1,1 +1189,1193 @@    # normalize axis values:\n    axes = tuple(x + N if x < 0 else x for x in axes)\n    if max(axes) >= N or min(axes) < 0:\n        raise ValueError(\"'axis' entry is out of bounds\")\n"
  },
  {
    "id" : "45c5cd9b-49df-409b-8113-979ff8c5c30f",
    "prId" : 6129,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1acc5806-8d68-46f5-91ee-58c52c86ecb3",
        "parentId" : null,
        "authorId" : "34105ae0-9fd2-4403-be9b-7c550a729828",
        "body" : "I just realized... We need a `.. versionadded:: 1.11` tag right here. Look at the example right above for a template. Needs a blank line before and after, too.\n",
        "createdAt" : "2015-09-03T13:58:16Z",
        "updatedAt" : "2015-09-06T12:42:54Z",
        "lastEditedBy" : "34105ae0-9fd2-4403-be9b-7c550a729828",
        "tags" : [
        ]
      }
    ],
    "commit" : "bc1990e770966535d188785cafaa3230c0a0377e",
    "line" : 20,
    "diffHunk" : "@@ -1,1 +1138,1142 @@        The default (axis = None) is to calculate the gradient for all the axes of the input array.\n        axis may be negative, in which case it counts from the last to the first axis.\n\n        .. versionadded:: 1.11.0\n"
  },
  {
    "id" : "f78b5c57-f440-4564-acb4-b7823fc5498e",
    "prId" : 7000,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0aced5d6-c205-4c30-89ab-5df8f4eecb20",
        "parentId" : null,
        "authorId" : "576cec6e-8071-43f8-bce9-351a2589f050",
        "body" : "Could we use the same duck-typing solution as above, with the try/except clause?\n",
        "createdAt" : "2016-01-13T17:37:35Z",
        "updatedAt" : "2016-01-14T19:05:40Z",
        "lastEditedBy" : "576cec6e-8071-43f8-bce9-351a2589f050",
        "tags" : [
        ]
      },
      {
        "id" : "7dcbd60b-1046-4696-b8ed-dc1033cbe5ec",
        "parentId" : "0aced5d6-c205-4c30-89ab-5df8f4eecb20",
        "authorId" : "11f18e00-52bd-4b68-b13d-17d0c3237df0",
        "body" : "It feels little more awkward in this case because `_insert` is not an `ndarray` method.  I suppose you could do something like the following:\n\n```\ntry:\n   put = arr.put\nexcept AttributeError:\n   raise TypeError(...)\nreturn _insert(arr, mask, vals)\n```\n\nHowever, it seems like more contrived compared to the others since we're relying on a method that has nothing to do with what is being called.\n",
        "createdAt" : "2016-01-13T17:48:30Z",
        "updatedAt" : "2016-01-14T19:05:40Z",
        "lastEditedBy" : "11f18e00-52bd-4b68-b13d-17d0c3237df0",
        "tags" : [
        ]
      },
      {
        "id" : "49fe64ee-9adb-49d5-9428-10fb0aad7fc1",
        "parentId" : "0aced5d6-c205-4c30-89ab-5df8f4eecb20",
        "authorId" : "576cec6e-8071-43f8-bce9-351a2589f050",
        "body" : "What error message do you get when `place` is not valid? What sort of duck typing does it currently support, if any?\n\nIt might be worth updating `_insert` instead.\n",
        "createdAt" : "2016-01-13T18:04:11Z",
        "updatedAt" : "2016-01-14T19:05:40Z",
        "lastEditedBy" : "576cec6e-8071-43f8-bce9-351a2589f050",
        "tags" : [
        ]
      },
      {
        "id" : "d2ecdaf4-705e-4e64-afb2-a0036855df01",
        "parentId" : "0aced5d6-c205-4c30-89ab-5df8f4eecb20",
        "authorId" : "11f18e00-52bd-4b68-b13d-17d0c3237df0",
        "body" : "@shoyer : See #7003, which does a complete revamp of `arr_insert` (that is tied to `_insert`) and does the type checking.  In the case of `np.place`, this PR should serve as a stopgap measure until #7003 can be merged.\n",
        "createdAt" : "2016-01-13T18:07:04Z",
        "updatedAt" : "2016-01-14T19:05:40Z",
        "lastEditedBy" : "11f18e00-52bd-4b68-b13d-17d0c3237df0",
        "tags" : [
        ]
      },
      {
        "id" : "23ebb09b-e22f-40e5-bcd0-81e9f07f53e7",
        "parentId" : "0aced5d6-c205-4c30-89ab-5df8f4eecb20",
        "authorId" : "11f18e00-52bd-4b68-b13d-17d0c3237df0",
        "body" : "@shoyer : Sorry, I didn't answer the remainder of your question; I only had seen the \"It might be worth\" part on my phone when I was reading it.  `place` doesn't actually do any duck-typing if you pass in a non-`ndarray` to it.  Rather, it does nothing, which is why I added that `isinstance` check to the code.  However, #7003 will embed that check into the C code, which is preferable.  However, I wouldn't mind merging the `isinstance` check into the codebase FTTB.\n",
        "createdAt" : "2016-01-13T19:28:07Z",
        "updatedAt" : "2016-01-14T19:05:40Z",
        "lastEditedBy" : "11f18e00-52bd-4b68-b13d-17d0c3237df0",
        "tags" : [
        ]
      },
      {
        "id" : "dc18b136-ca3e-4cef-93f5-f4c5c942d255",
        "parentId" : "0aced5d6-c205-4c30-89ab-5df8f4eecb20",
        "authorId" : "576cec6e-8071-43f8-bce9-351a2589f050",
        "body" : "OK, agreed!\n",
        "createdAt" : "2016-01-13T19:35:03Z",
        "updatedAt" : "2016-01-14T19:05:40Z",
        "lastEditedBy" : "576cec6e-8071-43f8-bce9-351a2589f050",
        "tags" : [
        ]
      }
    ],
    "commit" : "02bcbd7e99f7b73c2abcb2726f79ea01a6bba2da",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +1802,1806 @@\n    \"\"\"\n    if not isinstance(arr, np.ndarray):\n        raise TypeError(\"argument 1 must be numpy.ndarray, \"\n                        \"not {name}\".format(name=type(arr).__name__))"
  },
  {
    "id" : "b9f44307-3dc5-497c-9ea0-b59ff3867106",
    "prId" : 7125,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7f89ef0d-d9d6-4796-9a08-38c3478dcf2f",
        "parentId" : null,
        "authorId" : "576cec6e-8071-43f8-bce9-351a2589f050",
        "body" : "good catch!\n",
        "createdAt" : "2016-01-27T05:05:16Z",
        "updatedAt" : "2016-01-27T05:13:13Z",
        "lastEditedBy" : "576cec6e-8071-43f8-bce9-351a2589f050",
        "tags" : [
        ]
      }
    ],
    "commit" : "d7c847b0cb6bdfe46862de9013b3bf7d1e909eb7",
    "line" : 109,
    "diffHunk" : "@@ -1,1 +3458,3462 @@           [ 3,  2,  1]])\n    >>> np.percentile(a, 50)\n    3.5\n    >>> np.percentile(a, 50, axis=0)\n    array([[ 6.5,  4.5,  2.5]])"
  },
  {
    "id" : "9cfd769c-bae2-42ba-bee4-8d6b95afc954",
    "prId" : 7129,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ac62e1fd-6245-4f35-b47a-b2ddefab841b",
        "parentId" : null,
        "authorId" : "576cec6e-8071-43f8-bce9-351a2589f050",
        "body" : "Is this right for non-integers? I would be happier with this if I understood the origins of the \"midpoint\" rule.\n",
        "createdAt" : "2016-01-27T16:37:40Z",
        "updatedAt" : "2016-02-01T01:04:15Z",
        "lastEditedBy" : "576cec6e-8071-43f8-bce9-351a2589f050",
        "tags" : [
        ]
      },
      {
        "id" : "8be5aa72-61c9-4bfb-8de0-03fe40e46edf",
        "parentId" : "ac62e1fd-6245-4f35-b47a-b2ddefab841b",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Frankly, I am not sure :(, it might be my error for thinking about it back the. IIRC, it might be there because it is what matlab uses when it draws boxplots (this statement may be completly wrong).\nI am happy about corrections, even deprecations if it is found too weird...\n",
        "createdAt" : "2016-01-27T16:52:58Z",
        "updatedAt" : "2016-02-01T01:04:15Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "f304eddf-4a9e-4012-b3b6-31d345b60a36",
        "parentId" : "ac62e1fd-6245-4f35-b47a-b2ddefab841b",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Other then that, compare with R, I believe it had more then just one option maybe.\n",
        "createdAt" : "2016-01-27T16:53:18Z",
        "updatedAt" : "2016-02-01T01:04:15Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "919310d7-9d44-4996-a96a-3626123ee0d3",
        "parentId" : "ac62e1fd-6245-4f35-b47a-b2ddefab841b",
        "authorId" : "0d70c244-f732-4a44-9ae8-c3f6de7e9b40",
        "body" : "If you look at the docs, `midpoint` is just half-way between the surrounding points, making it effectively a special case of `linear`. The previous definition of `floor(indices) + 0.5` worked fine unless `indices` was an integer. I that case, the result should just be the element that the percentile matches exactly. Float indices are used to do a linear interpolation on the bounding elements. My initial gut response was to do\n\n```\nf = floor(indices)\nif f == indices:\n    indices = indices.astype(intp)\nelse:\n    indices = f\n```\n\nThe problem is of course that some of the indices may be integers and some may not. In this case, we have to do the linear interpolation on all of them, which I have set up correctly. Basically, if the index has a factional part, take the midpoint of the bounding element, otherwise interpolate, but with both bounds being the same.\n",
        "createdAt" : "2016-01-27T17:24:51Z",
        "updatedAt" : "2016-02-01T01:04:15Z",
        "lastEditedBy" : "0d70c244-f732-4a44-9ae8-c3f6de7e9b40",
        "tags" : [
        ]
      },
      {
        "id" : "96e81422-b2ce-475c-b812-5600a605e4c8",
        "parentId" : "ac62e1fd-6245-4f35-b47a-b2ddefab841b",
        "authorId" : "0d70c244-f732-4a44-9ae8-c3f6de7e9b40",
        "body" : "You may also find this Wikipedia article informative as to how the percentiles are supposed to be computed: https://en.wikipedia.org/wiki/Quantile\n",
        "createdAt" : "2016-01-27T17:28:09Z",
        "updatedAt" : "2016-02-01T01:04:15Z",
        "lastEditedBy" : "0d70c244-f732-4a44-9ae8-c3f6de7e9b40",
        "tags" : [
        ]
      },
      {
        "id" : "7650d0f5-adf6-4ebf-9a30-81be93e6e5ee",
        "parentId" : "ac62e1fd-6245-4f35-b47a-b2ddefab841b",
        "authorId" : "576cec6e-8071-43f8-bce9-351a2589f050",
        "body" : "OK, this is what I get for reading this out of context -- indices is the location of the values that enter into the percentiles, not the calculated result. So this looks good to me.\n",
        "createdAt" : "2016-01-27T17:30:02Z",
        "updatedAt" : "2016-02-01T01:04:15Z",
        "lastEditedBy" : "576cec6e-8071-43f8-bce9-351a2589f050",
        "tags" : [
        ]
      },
      {
        "id" : "933c377a-f15d-4dcc-8205-476a2cb77027",
        "parentId" : "ac62e1fd-6245-4f35-b47a-b2ddefab841b",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Yeah, I didn't know that wikipedia list, seems it is all fine then :).\n",
        "createdAt" : "2016-01-27T18:11:12Z",
        "updatedAt" : "2016-02-01T01:04:15Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "55e8d183-db88-4dd5-be38-2c7c585f9ff0",
        "parentId" : "ac62e1fd-6245-4f35-b47a-b2ddefab841b",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Hmmm, do we have a policy for this kind of bug fix? Should it be in the release notes?\n",
        "createdAt" : "2016-01-27T18:40:19Z",
        "updatedAt" : "2016-02-01T01:04:15Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      }
    ],
    "commit" : "9ec694b69a231a8de43032711c657d253edbed9d",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +3542,3546 @@        indices = ceil(indices).astype(intp)\n    elif interpolation == 'midpoint':\n        indices = 0.5 * (floor(indices) + ceil(indices))\n    elif interpolation == 'nearest':\n        indices = around(indices).astype(intp)"
  },
  {
    "id" : "2e1be24f-b42d-467f-805a-1c293c3dd929",
    "prId" : 7243,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "45a1720d-6fa1-4e28-9476-b239ea427db6",
        "parentId" : null,
        "authorId" : "576cec6e-8071-43f8-bce9-351a2589f050",
        "body" : "use `np.all(keep)` instead\n",
        "createdAt" : "2016-02-14T23:39:47Z",
        "updatedAt" : "2016-02-14T23:39:47Z",
        "lastEditedBy" : "576cec6e-8071-43f8-bce9-351a2589f050",
        "tags" : [
        ]
      },
      {
        "id" : "07294a13-a889-43a2-9364-e8857ff99a0c",
        "parentId" : "45a1720d-6fa1-4e28-9476-b239ea427db6",
        "authorId" : "0d70c244-f732-4a44-9ae8-c3f6de7e9b40",
        "body" : "I agree that maintainability and legibility outweighs a fractional improvement in speed. However, @nayyarv made a pretty good argument for keeping it this way. Could I have one more person weigh in to break the tie?\n",
        "createdAt" : "2016-02-15T00:02:06Z",
        "updatedAt" : "2016-02-15T00:02:06Z",
        "lastEditedBy" : "0d70c244-f732-4a44-9ae8-c3f6de7e9b40",
        "tags" : [
        ]
      },
      {
        "id" : "a58260ad-6531-4c70-974d-80ff7fd53e45",
        "parentId" : "45a1720d-6fa1-4e28-9476-b239ea427db6",
        "authorId" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "body" : "Previous discussion with @nayyarv's comment was here: https://github.com/numpy/numpy/pull/6288#discussion_r38879392\n\nI.e., this file uses `and.reduce` elsewhere for this same computation. I'm not too bothered either way, using `add.reduce` consistently isn't really worse than using `all` in some places and `add.reduce` in others, and I'd like to get this moving for 1.11, so @shoyer -- I'm going to merge this and we can figure out whether we care about `add.reduce` versus `all` as a separate matter? Feel free to squawk if you think this is a grave mistake :-)\n",
        "createdAt" : "2016-02-15T00:10:38Z",
        "updatedAt" : "2016-02-15T00:10:38Z",
        "lastEditedBy" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "tags" : [
        ]
      },
      {
        "id" : "c355a75b-10e4-493c-97c9-a26f9be2eb74",
        "parentId" : "45a1720d-6fa1-4e28-9476-b239ea427db6",
        "authorId" : "576cec6e-8071-43f8-bce9-351a2589f050",
        "body" : "Oops... I forgot I already made this comment! \n\nThis is fine :)\n",
        "createdAt" : "2016-02-15T00:12:15Z",
        "updatedAt" : "2016-02-15T00:12:15Z",
        "lastEditedBy" : "576cec6e-8071-43f8-bce9-351a2589f050",
        "tags" : [
        ]
      },
      {
        "id" : "0d809727-3b4d-4d1e-982b-34325a506089",
        "parentId" : "45a1720d-6fa1-4e28-9476-b239ea427db6",
        "authorId" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "body" : "I guess this was an inadverdant double-blind test of your review consistency. You did [better than NIPS](http://blog.mrtz.org/2014/12/15/the-nips-experiment.html) ;-)\n",
        "createdAt" : "2016-02-15T00:17:29Z",
        "updatedAt" : "2016-02-15T00:17:29Z",
        "lastEditedBy" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "tags" : [
        ]
      },
      {
        "id" : "8a96c1e4-0171-4b50-a911-df84006aeeb2",
        "parentId" : "45a1720d-6fa1-4e28-9476-b239ea427db6",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "There are some advantages to `np.all`\n\n```\n    arr = asanyarray(a)\n    kwargs = {}\n    if keepdims is not np._NoValue:\n        kwargs['keepdims'] = keepdims\n    return arr.all(axis=axis, out=out, **kwargs)\n```\n\nI don't know if they apply here, but I do know that when I did the initial nanfunctions using the higher level `np.sum` and such was urged upon me and did indeed improve behavior with subclasses and such.\n",
        "createdAt" : "2016-02-15T00:34:28Z",
        "updatedAt" : "2016-02-15T00:34:28Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "62bb0cb9681f638b56dc29b970228cb36c2104b6",
    "line" : 38,
    "diffHunk" : "@@ -1,1 +110,114 @@        keep = (a >= mn)\n        keep &= (a <= mx)\n        if not np.logical_and.reduce(keep):\n            a = a[keep]\n"
  },
  {
    "id" : "70460a34-6b7f-470d-9e9e-fe8f71ba1e71",
    "prId" : 7382,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6483bc19-e85f-4c83-aa09-957dd58d4e49",
        "parentId" : null,
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Should this be an `or` or `and` with the same for wgt? Hmmm, actually, if, which one, hmmm :), I guess or?\n",
        "createdAt" : "2016-03-07T09:49:59Z",
        "updatedAt" : "2016-03-07T17:41:25Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "e2a7cd2b-4582-4d7c-9289-b4e6c10f542f",
        "parentId" : "6483bc19-e85f-4c83-aa09-957dd58d4e49",
        "authorId" : "a4f03a99-2e43-482b-a9bc-5a9e359abb03",
        "body" : "I think the type of `wgt` doesn't matter. The current code does as follows for the four combinations to think about (`float` means `f4` or `f8`):\n\n```\na     wgt        result_dtype\n---   ---        ---\nint   int        f8\nint   float      f8\nfloat int        f8\nfloat float2     biggest(float, float2)\n```\n\nI suppose in the 2nd line we could cast to whatever wgt's floating type was (f4 or f8) but I'm not sure whether that's helpful or unnecessarily complicated. \n\n(Edit: Actually the 2nd line will give back `f8` no matter what we do, since `int`+`f4` coerces to `f8` anyway)\n",
        "createdAt" : "2016-03-07T17:09:05Z",
        "updatedAt" : "2016-03-07T17:50:38Z",
        "lastEditedBy" : "a4f03a99-2e43-482b-a9bc-5a9e359abb03",
        "tags" : [
        ]
      }
    ],
    "commit" : "5ceab8f982d80c68b3b5e90697cd20df51f4a3e8",
    "line" : 16,
    "diffHunk" : "@@ -1,1 +907,911 @@        wgt = np.asanyarray(weights)\n\n        if issubclass(a.dtype.type, (np.integer, np.bool_)):\n            result_dtype = np.result_type(a.dtype, wgt.dtype, 'f8')\n        else:"
  },
  {
    "id" : "85b169aa-ba7c-4e9a-a677-7c90d33d928d",
    "prId" : 7414,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "da51036b-041d-4aa9-b3d8-c005da3db0aa",
        "parentId" : null,
        "authorId" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "body" : "Have we checked that this is faster? (I would certainly hope that it is, but you never know :-).) Also, having read up a bit more I withdraw my worry about numerical stability, in case you want to do the multiply-by-inverse thing.\n",
        "createdAt" : "2016-03-13T23:47:54Z",
        "updatedAt" : "2016-03-14T02:06:23Z",
        "lastEditedBy" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "tags" : [
        ]
      },
      {
        "id" : "5c079d2c-a211-4f51-8524-a994891f730e",
        "parentId" : "da51036b-041d-4aa9-b3d8-c005da3db0aa",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "It's about the same. Using multiplication makes it 2% faster for the test problem in the original fix. I think most of the time is always going to be in `cov`. However, I prefer this version for its clarity, OTOH, you get two zero division warnings when one of the diagonals is zero (which can happen).\n",
        "createdAt" : "2016-03-13T23:53:59Z",
        "updatedAt" : "2016-03-14T02:06:23Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "204308463955f6604356887e3043743dc163d391",
    "line" : 46,
    "diffHunk" : "@@ -1,1 +2549,2553 @@    stddev = sqrt(d.real)\n    c /= stddev[:, None]\n    c /= stddev[None, :]\n\n    # Clip real and imaginary parts to [-1, 1].  This does not guarantee"
  },
  {
    "id" : "626114cd-77df-4553-9305-7b1f393dc6d3",
    "prId" : 7414,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3c07396b-db5f-4e49-a1a0-7e0a5745a2cb",
        "parentId" : null,
        "authorId" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "body" : "I'd probably have been even lazier and done something like `if isreal(c): np.clip(c, -1, 1, out=c)`, but this seems fine too...\n",
        "createdAt" : "2016-03-13T23:54:08Z",
        "updatedAt" : "2016-03-14T02:06:23Z",
        "lastEditedBy" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "tags" : [
        ]
      }
    ],
    "commit" : "204308463955f6604356887e3043743dc163d391",
    "line" : 53,
    "diffHunk" : "@@ -1,1 +2556,2560 @@    np.clip(c.real, -1, 1, out=c.real)\n    if np.iscomplexobj(c):\n        np.clip(c.imag, -1, 1, out=c.imag)\n\n    return c"
  },
  {
    "id" : "95b4a33c-f9ea-4fa8-a481-f4c066a7f6b8",
    "prId" : 7416,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9224f5c2-14c4-458e-9540-2158ffcde2a4",
        "parentId" : null,
        "authorId" : "ada2f86e-4f20-4b98-b907-d0b9920ded93",
        "body" : "Shouldn't the np.ceil be removed from this?\n",
        "createdAt" : "2016-03-16T17:00:49Z",
        "updatedAt" : "2016-03-16T17:00:49Z",
        "lastEditedBy" : "ada2f86e-4f20-4b98-b907-d0b9920ded93",
        "tags" : [
        ]
      }
    ],
    "commit" : "8869c1ace77affefff75c8a772edb2983b68a015",
    "line" : 39,
    "diffHunk" : "@@ -1,1 +188,192 @@    h : An estimate of the optimal bin width for the given data.\n    \"\"\"\n    return x.ptp() / np.ceil(np.log2(x.size) + 1.0)\n\n"
  },
  {
    "id" : "51b15874-c6fc-43ca-92de-8062bda505dd",
    "prId" : 8054,
    "prUrl" : "https://github.com/numpy/numpy/pull/8054#pullrequestreview-2520248",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "96a53aa4-651f-42ca-a539-2e8d2668e636",
        "parentId" : null,
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "Does this test carry much overhead? My always-try-to-optimize the normal path temptation would be to put the return statement inside a `try/except` clause like\n\n```\ntry:\n    return ...\nexcept Exception:\n    if not re.match...\n        raise ValueError(...)\n    else:\n        raise\n```\n",
        "createdAt" : "2016-10-03T04:05:12Z",
        "updatedAt" : "2016-10-17T17:26:27Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      },
      {
        "id" : "0b6388be-0b68-45fc-a551-42f21c9fd52f",
        "parentId" : "96a53aa4-651f-42ca-a539-2e8d2668e636",
        "authorId" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "body" : "the parsing is not really performance relevant, it is done on the object creation, the time consuming part is executing it on the data\nbut if you want to improve it, precompiling the regex might be worthwhile\n",
        "createdAt" : "2016-10-03T10:20:25Z",
        "updatedAt" : "2016-10-17T17:26:27Z",
        "lastEditedBy" : "0e0ae9fd-53e5-41a6-8774-29bcec6001df",
        "tags" : [
        ]
      },
      {
        "id" : "9efbd3d9-54b0-437a-a596-df11678fe0ff",
        "parentId" : "96a53aa4-651f-42ca-a539-2e8d2668e636",
        "authorId" : "576cec6e-8071-43f8-bce9-351a2589f050",
        "body" : "I agree with @juliantaylor that this is unlikely to be a performance bottleneck, given that it is done on construction. My timing shows it takes around 10us, which is really in micro-benchmark territory.\n\nMy understanding is that in most cases it isn't necessary to worry about precompiling a regex because the `re` module maintains its own cache: https://docs.python.org/2/library/re.html#re.compile\n",
        "createdAt" : "2016-10-03T13:23:34Z",
        "updatedAt" : "2016-10-17T17:26:27Z",
        "lastEditedBy" : "576cec6e-8071-43f8-bce9-351a2589f050",
        "tags" : [
        ]
      }
    ],
    "commit" : "138cbd339e2d200a586a3be992b7a758ed34de5b",
    "line" : 80,
    "diffHunk" : "@@ -1,1 +2270,2274 @@    of the form List[Tuple[str, ...]].\n    \"\"\"\n    if not re.match(_SIGNATURE, signature):\n        raise ValueError(\n            'not a valid gufunc signature: {}'.format(signature))"
  },
  {
    "id" : "dfd4dec5-00e5-4d51-bbe8-e8c3de81d471",
    "prId" : 8206,
    "prUrl" : "https://github.com/numpy/numpy/pull/8206#pullrequestreview-151255052",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "af01b7aa-b7dc-4d77-a348-8af3c7eab9d0",
        "parentId" : null,
        "authorId" : "576cec6e-8071-43f8-bce9-351a2589f050",
        "body" : "Can we add a test verifying that `ValueError` is raised if the shape doesn't match?",
        "createdAt" : "2018-08-31T04:14:44Z",
        "updatedAt" : "2018-09-26T02:06:24Z",
        "lastEditedBy" : "576cec6e-8071-43f8-bce9-351a2589f050",
        "tags" : [
        ]
      }
    ],
    "commit" : "8ec391a3384fc1637e3a6ba0a6a6a7b06a348ea1",
    "line" : 18,
    "diffHunk" : "@@ -1,1 +1114,1118 @@        arrays with length 1 in the direction of axis and the shape\n        of the input array in along all other axes.  Otherwise the\n        dimension and shape must match \"a\" except along axis.\n\n    Returns"
  },
  {
    "id" : "5452da53-ea7f-427c-ae23-f89f554e5495",
    "prId" : 8206,
    "prUrl" : "https://github.com/numpy/numpy/pull/8206#pullrequestreview-158807269",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "572e611f-451e-409e-b93e-a70a2cf55f9e",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "... otherwise this will throw an IndexError, rather than the more useful `AxisError`",
        "createdAt" : "2018-09-26T01:53:33Z",
        "updatedAt" : "2018-09-26T02:06:24Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "8ec391a3384fc1637e3a6ba0a6a6a7b06a348ea1",
    "line" : 41,
    "diffHunk" : "@@ -1,1 +1198,1202 @@        if append.ndim == 0:\n            shape = list(a.shape)\n            shape[axis] = 1\n            append = np.broadcast_to(append, tuple(shape))\n        combined.append(append)"
  },
  {
    "id" : "308b4a86-3b88-4b20-96bb-c96a5ba36e49",
    "prId" : 8446,
    "prUrl" : "https://github.com/numpy/numpy/pull/8446#pullrequestreview-16028598",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "138347ba-191c-48e4-b0d5-a9aca170038f",
        "parentId" : null,
        "authorId" : "576cec6e-8071-43f8-bce9-351a2589f050",
        "body" : "This is starting to look a little repetitive. Can you maybe break this out into a few helper functions so it's easier to follow the high level logic?\r\n\r\nAlternatively, maybe you can reuse some of the logic for the scalar case `dx` vs array of coordinates `x`? e.g., just set `a`, `b` and `c` different?",
        "createdAt" : "2017-01-09T04:21:23Z",
        "updatedAt" : "2017-02-22T09:51:14Z",
        "lastEditedBy" : "576cec6e-8071-43f8-bce9-351a2589f050",
        "tags" : [
        ]
      },
      {
        "id" : "95730f5b-6032-4977-8ba1-4f34041ec98e",
        "parentId" : "138347ba-191c-48e4-b0d5-a9aca170038f",
        "authorId" : "1a3779d3-314a-481f-b8f0-2fbed43338d0",
        "body" : "Done. And also optimised further...now when entering the uniform_spacing branches is ~10-30% faster than original np.gradient\r\n\r\n    np.gradient 13.1845779419\r\n    gradient_opt vector 10.7180240154\r\n    gradient_noopt vector 20.1845788956\r\n    gradient_opt scalar 10.6630008221\r\n    gradient_noopt scalar 13.2290189266\r\n",
        "createdAt" : "2017-01-10T22:18:32Z",
        "updatedAt" : "2017-02-22T09:51:14Z",
        "lastEditedBy" : "1a3779d3-314a-481f-b8f0-2fbed43338d0",
        "tags" : [
        ]
      },
      {
        "id" : "d19fd68f-9d7e-4140-a76b-f280f3503dce",
        "parentId" : "138347ba-191c-48e4-b0d5-a9aca170038f",
        "authorId" : "576cec6e-8071-43f8-bce9-351a2589f050",
        "body" : "Much better, thanks",
        "createdAt" : "2017-01-10T22:29:39Z",
        "updatedAt" : "2017-02-22T09:51:14Z",
        "lastEditedBy" : "576cec6e-8071-43f8-bce9-351a2589f050",
        "tags" : [
        ]
      }
    ],
    "commit" : "9520de90837d0afaac3d1612047f4b952563b3d5",
    "line" : 408,
    "diffHunk" : "@@ -1,1 +1834,1838 @@                a = (dx2) / (dx1 * (dx1 + dx2))\n                b = - (dx2 + dx1) / (dx1 * dx2)\n                c = (2. * dx2 + dx1) / (dx2 * (dx1 + dx2))\n            # 1D equivalent -- out[-1] = a * f[-3] + b * f[-2] + c * f[-1]\n            out[slice1] = a * y[slice2] + b * y[slice3] + c * y[slice4]        "
  },
  {
    "id" : "0d02491a-2a8b-4c7f-8e1d-245a719362d4",
    "prId" : 8446,
    "prUrl" : "https://github.com/numpy/numpy/pull/8446#pullrequestreview-16028477",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7578a99f-b532-4d7b-8068-c985fd3a0a88",
        "parentId" : null,
        "authorId" : "1a3779d3-314a-481f-b8f0-2fbed43338d0",
        "body" : "I am not sure whether I like this version of ifs more that the previous one with duplicated checks. what do you think?",
        "createdAt" : "2017-01-10T22:14:57Z",
        "updatedAt" : "2017-02-22T09:51:14Z",
        "lastEditedBy" : "1a3779d3-314a-481f-b8f0-2fbed43338d0",
        "tags" : [
        ]
      },
      {
        "id" : "be1581d1-03f1-46b0-a386-9c8ce0c10c79",
        "parentId" : "7578a99f-b532-4d7b-8068-c985fd3a0a88",
        "authorId" : "576cec6e-8071-43f8-bce9-351a2589f050",
        "body" : "I think this is a step in the right direction. I'll have more detailed suggestions, but let's settle on the overall API first.",
        "createdAt" : "2017-01-10T22:28:58Z",
        "updatedAt" : "2017-02-22T09:51:14Z",
        "lastEditedBy" : "576cec6e-8071-43f8-bce9-351a2589f050",
        "tags" : [
        ]
      }
    ],
    "commit" : "9520de90837d0afaac3d1612047f4b952563b3d5",
    "line" : 260,
    "diffHunk" : "@@ -1,1 +1700,1704 @@    elif n == len_axes or (n == 1 and np.isscalar(varargs[0])):\n        dx = list(varargs)\n        for i, distances in enumerate(dx):\n            if np.isscalar(distances):\n                continue"
  },
  {
    "id" : "24f798ee-9b06-4cfd-aa8b-6beba3c33f3d",
    "prId" : 8843,
    "prUrl" : "https://github.com/numpy/numpy/pull/8843#pullrequestreview-29067213",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6925e86d-e4cf-4ea8-9302-723e8223fea9",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "This guards against `IndexError`",
        "createdAt" : "2017-03-26T10:47:51Z",
        "updatedAt" : "2017-03-28T21:23:31Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "17466ad1839718c091c629bb647e881b7922a148",
    "line" : 78,
    "diffHunk" : "@@ -1,1 +4749,4753 @@            return arr.copy(order=arrorder)\n\n    axis = normalize_axis_index(axis, ndim)\n\n    slobj = [slice(None)]*ndim"
  },
  {
    "id" : "4d3c1895-5a74-4ad7-9a28-388430abbfc3",
    "prId" : 9408,
    "prUrl" : "https://github.com/numpy/numpy/pull/9408#pullrequestreview-49782996",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "142a6635-e353-4491-83d0-278793fbc8aa",
        "parentId" : null,
        "authorId" : "1a3779d3-314a-481f-b8f0-2fbed43338d0",
        "body" : "right, didn't thought about explicit error message for not 1D arrays",
        "createdAt" : "2017-07-13T12:47:24Z",
        "updatedAt" : "2017-07-22T10:42:58Z",
        "lastEditedBy" : "1a3779d3-314a-481f-b8f0-2fbed43338d0",
        "tags" : [
        ]
      },
      {
        "id" : "ebfff72e-9ef0-4aba-83cf-0d062bcdc39f",
        "parentId" : "142a6635-e353-4491-83d0-278793fbc8aa",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "I suspect we can do something much more powerful for nd arrays if we think about it (perhaps the grad operator from vector calculus?), but short-term we just want to disable the currently-broken behaviour",
        "createdAt" : "2017-07-13T12:56:02Z",
        "updatedAt" : "2017-07-22T10:42:58Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "ca3a6946-baf1-4d99-b67f-56785cc8dbef",
        "parentId" : "142a6635-e353-4491-83d0-278793fbc8aa",
        "authorId" : "1a3779d3-314a-481f-b8f0-2fbed43338d0",
        "body" : "Well, that behaviour was already disabled and the docstring correctly says what is the expected input. \r\nWhen I firstly implemented this I thought about allowing a list of coordinates instead of individual parameters, but I discarded that because I think it is quite error prone and error checking is more complex. Anyway, if I am not wrong, you cannot pass a \"real\"-2d matrix unless in the special case where your data have the same dimension along each axis.\r\nSo, IMHO, disabling this is not a short term patch but rather the most convenient thing to do.",
        "createdAt" : "2017-07-13T13:18:25Z",
        "updatedAt" : "2017-07-22T10:42:58Z",
        "lastEditedBy" : "1a3779d3-314a-481f-b8f0-2fbed43338d0",
        "tags" : [
        ]
      },
      {
        "id" : "c7d8eebf-d037-4dcf-b680-55560fbd1606",
        "parentId" : "142a6635-e353-4491-83d0-278793fbc8aa",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "> unless in the special case where your data have the same dimension along each axis.\r\n\r\nCorrect, but this is exactly the case that all our tests use!",
        "createdAt" : "2017-07-13T13:20:12Z",
        "updatedAt" : "2017-07-22T10:42:58Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "36d72c73-40e5-451d-9ce0-5225caf4c2ff",
        "parentId" : "142a6635-e353-4491-83d0-278793fbc8aa",
        "authorId" : "1a3779d3-314a-481f-b8f0-2fbed43338d0",
        "body" : "Allowing instead to compute the gradient with an arbitrary 2d list of coordinates would require a quite different approach and implementation. Anyway, even in this case you would require at maximum a 2d array with shape (num_points, num_dimensions)",
        "createdAt" : "2017-07-13T13:22:21Z",
        "updatedAt" : "2017-07-22T10:42:58Z",
        "lastEditedBy" : "1a3779d3-314a-481f-b8f0-2fbed43338d0",
        "tags" : [
        ]
      },
      {
        "id" : "c3eff07b-738c-497d-a875-e9fa20b497f6",
        "parentId" : "142a6635-e353-4491-83d0-278793fbc8aa",
        "authorId" : "1a3779d3-314a-481f-b8f0-2fbed43338d0",
        "body" : "> >    unless in the special case where your data have the same dimension along each axis.\r\n\r\n> Correct, but this is exactly the case that all our tests use!\r\n\r\nI agree that we can add a more general test to check ND-\"rectangular\" data as well as \"squared\" ones, but this is quite unrelated to the dimension/type of input coordinates , is it? \r\nWhat I meant that even in the case we decide to implement this it should not be a 2d-array but a list of 1d-arrays because each would require to have a potentially different size.",
        "createdAt" : "2017-07-13T13:35:02Z",
        "updatedAt" : "2017-07-22T10:42:58Z",
        "lastEditedBy" : "1a3779d3-314a-481f-b8f0-2fbed43338d0",
        "tags" : [
        ]
      },
      {
        "id" : "5339432d-6a95-4b27-815b-787dfa0a11ff",
        "parentId" : "142a6635-e353-4491-83d0-278793fbc8aa",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Let's discuss that type of extension elsewhere: #9409",
        "createdAt" : "2017-07-13T13:49:46Z",
        "updatedAt" : "2017-07-22T10:42:58Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "1f4ba5bee1240cc7a888087dc06acb7709f12870",
    "line" : 18,
    "diffHunk" : "@@ -1,1 +1698,1702 @@                continue\n            elif np.ndim(distances) != 1:\n                raise ValueError(\"distances must be either scalars or 1d\")\n            if len(distances) != f.shape[axes[i]]:\n                raise ValueError(\"when 1d, distances must match \""
  },
  {
    "id" : "4675be73-7681-40aa-bb21-8dc1c55d9289",
    "prId" : 9889,
    "prUrl" : "https://github.com/numpy/numpy/pull/9889#pullrequestreview-70435995",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d1227d00-4ad8-43dd-8fe3-d94fc173a88a",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "No need for `np.any` here - these are tuples",
        "createdAt" : "2017-10-19T06:52:27Z",
        "updatedAt" : "2017-10-20T06:05:39Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "5b7b87e4ebd91b1f0e17db05113a94e6776a5701",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +648,652 @@    if weights is not None:\n        weights = asarray(weights)\n        if weights.shape != a.shape:\n            raise ValueError(\n                'weights should have the same shape as a.')"
  },
  {
    "id" : "e8698d86-fdae-4a8a-843e-25494eb614eb",
    "prId" : 9889,
    "prUrl" : "https://github.com/numpy/numpy/pull/9889#pullrequestreview-70435995",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a8db774b-0f63-4893-86d9-878331ab234c",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Using these names makes things a lot clearer, rather than `bins` meaning different things in different places",
        "createdAt" : "2017-10-19T06:55:59Z",
        "updatedAt" : "2017-10-20T06:05:39Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "5b7b87e4ebd91b1f0e17db05113a94e6776a5701",
    "line" : 50,
    "diffHunk" : "@@ -1,1 +679,683 @@    # parse the overloaded bins argument\n    n_equal_bins = None\n    bin_edges = None\n\n    if isinstance(bins, basestring):"
  },
  {
    "id" : "7a819601-648b-4664-9a4e-3eaaeb461cc6",
    "prId" : 9900,
    "prUrl" : "https://github.com/numpy/numpy/pull/9900#pullrequestreview-71247512",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d759b256-6871-411c-bb8a-0f72921ea410",
        "parentId" : null,
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "So, was the idea to deprecate this? An alternative might be to just add `ndmin=1` in the conversion to boolean array below.",
        "createdAt" : "2017-10-23T13:50:49Z",
        "updatedAt" : "2017-10-24T03:32:16Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      },
      {
        "id" : "9a923fd3-8dd5-4155-be43-5c3cfae99c46",
        "parentId" : "d759b256-6871-411c-bb8a-0f72921ea410",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "I'd like to deprecate this in future, but this patch is orthogonal to that",
        "createdAt" : "2017-10-23T16:27:22Z",
        "updatedAt" : "2017-10-24T03:32:16Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "1b2cb583-5912-41ea-b8fe-5a01fe188c29",
        "parentId" : "d759b256-6871-411c-bb8a-0f72921ea410",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "`ndim=1` won't help - this is intended to also promote 1d arrays to a list of length 1 containing a single 1d array.",
        "createdAt" : "2017-10-23T16:27:59Z",
        "updatedAt" : "2017-10-24T03:32:16Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "c875b1391286a982c958d349d58eb720eb081069",
    "line" : 31,
    "diffHunk" : "@@ -1,1 +1329,1333 @@            not isinstance(condlist[0], (list, ndarray)) and x.ndim != 0):\n        condlist = [condlist]\n\n    condlist = array(condlist, dtype=bool)\n    n = len(condlist)"
  },
  {
    "id" : "56a0e52e-3b1f-4d3e-a48c-73e599e9651f",
    "prId" : 10195,
    "prUrl" : "https://github.com/numpy/numpy/pull/10195#pullrequestreview-82360986",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a3ce993f-af6b-48b0-8917-917aeca7a9ac",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "[As requested](https://github.com/numpy/numpy/pull/9213#discussion_r135806136) by @charris, removing description from the `: param_type` section",
        "createdAt" : "2017-12-10T20:17:36Z",
        "updatedAt" : "2017-12-10T22:05:27Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "f2947e5917a2b2a8cbc6582f09944d5064321c8d",
    "line" : 9,
    "diffHunk" : "@@ -1,1 +4191,4195 @@    q : array_like of float\n        Percentile or sequence of percentiles to compute, which must be between\n        0 and 100 inclusive.\n    axis : {int, tuple of int, None}, optional\n        Axis or axes along which the percentiles are computed. The"
  },
  {
    "id" : "b8e6e52f-a415-42c4-a184-e25223828847",
    "prId" : 10241,
    "prUrl" : "https://github.com/numpy/numpy/pull/10241#pullrequestreview-84562577",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1f0a6390-a3fa-4a29-9dd2-f86a5471c4f2",
        "parentId" : null,
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "While you're at it, would it be an idea to just remove this special casing? The timing does switch at 10 elements, at ~3us on my machine, and for 2 elements the python loop is 1.2us, while the numpy loop is still ~3us. But why do we care if next we are going to sort a whole array? This optimization is just not worth it.\r\n\r\nIf we do keep the loop, maybe at least make it do:\r\n```\r\n    for _q in q:\r\n        if not (0.0 <= _q <= 1.0):\r\n            return False\r\n```\r\n(which is faster both for not getting indices and for doing the combined comparison)\r\n\r\np.s. the `count_nonzero` is worth it",
        "createdAt" : "2017-12-19T18:19:06Z",
        "updatedAt" : "2017-12-19T18:19:06Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      },
      {
        "id" : "98b87082-8a9c-4f0d-8886-3728262c8c3d",
        "parentId" : "1f0a6390-a3fa-4a29-9dd2-f86a5471c4f2",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Was planning to put that in a separate PR",
        "createdAt" : "2017-12-19T19:25:12Z",
        "updatedAt" : "2017-12-19T19:25:12Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "b0740b7b5625181dbed25f6b13bc424c1f37614b",
    "line" : 29,
    "diffHunk" : "@@ -1,1 +4307,4311 @@    # avoid expensive reductions, relevant for arrays with < O(1000) elements\n    if q.ndim == 1 and q.size < 10:\n        for i in range(q.size):\n            if q[i] < 0.0 or q[i] > 1.0:\n                return False"
  },
  {
    "id" : "b0983e43-ac29-4409-bea0-a9b8a0ee872b",
    "prId" : 10241,
    "prUrl" : "https://github.com/numpy/numpy/pull/10241#pullrequestreview-86072541",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0a3e3da0-95c8-4063-a0c6-cf4140d4b11b",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Could probably use `|` here, something like `np.count_nonzero((q < 0.0) | (q > 1.0))`, or even in place. Just a note for the separate PR.",
        "createdAt" : "2018-01-02T00:12:52Z",
        "updatedAt" : "2018-01-02T00:12:52Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "61b4996f-5ec3-40b0-a0be-3e1ff80f080f",
        "parentId" : "0a3e3da0-95c8-4063-a0c6-cf4140d4b11b",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Doing the `or` vectorized is algorithmically slower - `n` or operations vs `1`.",
        "createdAt" : "2018-01-02T00:14:01Z",
        "updatedAt" : "2018-01-02T00:14:01Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "b0740b7b5625181dbed25f6b13bc424c1f37614b",
    "line" : 34,
    "diffHunk" : "@@ -1,1 +4312,4316 @@    else:\n        # faster than any()\n        if np.count_nonzero(q < 0.0) or np.count_nonzero(q > 1.0):\n            return False\n    return True"
  }
]
[
  {
    "id" : "1e492dac-19ee-4492-9ee6-957b0514a91b",
    "prId" : 9070,
    "prUrl" : "https://github.com/numpy/numpy/pull/9070#pullrequestreview-36861120",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d58f18e0-2cb0-4ac1-b9c3-91be11a42ac4",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Perhaps `dtype[['field1', 'field2']]` should be legal, to replace this function (but not needed for this PR, and would conflict with the refactor in #8814).",
        "createdAt" : "2017-05-08T18:23:28Z",
        "updatedAt" : "2017-05-10T02:18:10Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "d4cb16c6-e8cb-441c-ada3-f87d15604869",
        "parentId" : "d58f18e0-2cb0-4ac1-b9c3-91be11a42ac4",
        "authorId" : "a4f03a99-2e43-482b-a9bc-5a9e359abb03",
        "body" : "That's true, that's why I made `_keep_fields` private with a leading underscore. I don't want users depending on it since it might be made obsolete in the next year or two, one way or another.",
        "createdAt" : "2017-05-08T19:21:14Z",
        "updatedAt" : "2017-05-10T02:18:10Z",
        "lastEditedBy" : "a4f03a99-2e43-482b-a9bc-5a9e359abb03",
        "tags" : [
        ]
      }
    ],
    "commit" : "9177d0b5776550e2fbb3b1c9a922832a6553f3e2",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +524,528 @@\n\ndef _keep_fields(base, keep_names, usemask=True, asrecarray=False):\n    \"\"\"\n    Return a new array keeping only the fields in `keep_names`,"
  },
  {
    "id" : "24814f16-e5b8-4f7a-bb6b-e38bc30cdb66",
    "prId" : 9343,
    "prUrl" : "https://github.com/numpy/numpy/pull/9343#pullrequestreview-47533725",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "434996fb-5fd9-4894-90d0-ba04350ac4f0",
        "parentId" : null,
        "authorId" : "a4f03a99-2e43-482b-a9bc-5a9e359abb03",
        "body" : "Empty fields names causes headaches and bugs in the npy.io code, which I hope to fix once other PRs get in. \"aligned\" dtypes are particularly a problem, because `np.dtype('i1,f4', align=True).descr` is [('f0', '|i1'), ('', '|V3'), ('f1', '<f4')], so you often end up with lots of dummy fields named ''.\r\n\r\nThe point of my comment here is to say that actually your code is fine and I think you are probably fixing even more bugs than you think here, for aligned dtypes, because this function now skips padding bytes.",
        "createdAt" : "2017-07-01T16:12:21Z",
        "updatedAt" : "2017-07-01T19:54:02Z",
        "lastEditedBy" : "a4f03a99-2e43-482b-a9bc-5a9e359abb03",
        "tags" : [
        ]
      },
      {
        "id" : "629d2ae3-2f03-4d8b-b4d0-0841c09db2f7",
        "parentId" : "434996fb-5fd9-4894-90d0-ba04350ac4f0",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Yep, this test previously failed:\r\n```\r\ndt = np.dtype('i1,f4', align=True)\r\ndt.names = ('k', 'v')\r\na = np.array([(1, 3), (3, 2)], dt)\r\nb = np.array([(1, 1), (2, 2)], dt)\r\njoin_by('k', a, b)\r\n```\r\n\r\nDue to `np.ma.default_fill_value(np.dtype('V4'))` returning an object that won't cast to `np.void`...",
        "createdAt" : "2017-07-01T16:22:44Z",
        "updatedAt" : "2017-07-01T19:54:02Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "6def6164-a5ba-4d7a-bb01-dd38869d1ed3",
        "parentId" : "434996fb-5fd9-4894-90d0-ba04350ac4f0",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "I'll add a test for this",
        "createdAt" : "2017-07-01T17:18:18Z",
        "updatedAt" : "2017-07-01T19:54:02Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "ae14f151d2534dfa1b632ed156fe8e7fc9753de2",
    "line" : 25,
    "diffHunk" : "@@ -1,1 +92,96 @@    if dtype.names is None:\n        # .descr returns a nameless field, so we should too\n        return [('', dtype)]\n    else:\n        fields = ((name, dtype.fields[name]) for name in dtype.names)"
  },
  {
    "id" : "71637ad8-f30b-47c7-9b83-e66a8490a715",
    "prId" : 11526,
    "prUrl" : "https://github.com/numpy/numpy/pull/11526#pullrequestreview-135236110",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "10cedc22-2b6f-4c39-807b-05585b2de74f",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Check `align` here too?",
        "createdAt" : "2018-07-08T15:06:46Z",
        "updatedAt" : "2018-11-23T21:36:26Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "61371de744b363eacdb2ae277c33d365164380f3",
    "line" : 187,
    "diffHunk" : "@@ -1,1 +1045,1049 @@    else:\n        if names is not None:\n            raise ValueError(\"don't supply both dtype and names\")\n        # sanity check of the input dtype\n        fields = _get_fields_and_offsets(dtype)"
  },
  {
    "id" : "1e9a1934-aa0e-4194-9079-e27883aba88f",
    "prId" : 11526,
    "prUrl" : "https://github.com/numpy/numpy/pull/11526#pullrequestreview-178037185",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0e34b390-2b29-4f7f-b1e6-d019dcd24d77",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "I think that this needs a warning that fields are all cast to the same type",
        "createdAt" : "2018-11-24T01:41:52Z",
        "updatedAt" : "2018-11-24T01:41:52Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "61371de744b363eacdb2ae277c33d365164380f3",
    "line" : 224,
    "diffHunk" : "@@ -1,1 +1082,1086 @@\n    This is similar to `apply_along_axis`, but treats the fields of a\n    structured array as an extra axis.\n\n    Parameters"
  },
  {
    "id" : "45b5e1e3-9454-4e09-8bf4-a1c1698f8c4a",
    "prId" : 11526,
    "prUrl" : "https://github.com/numpy/numpy/pull/11526#pullrequestreview-178059809",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5c261d13-eb63-48c9-b9f5-3f9563af0c32",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "To work on 0d arrays, this needs to be `...`",
        "createdAt" : "2018-11-24T01:43:49Z",
        "updatedAt" : "2018-11-24T01:43:49Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "dc7b30a8-f8fb-49ed-acc9-dc91a2cd90c4",
        "parentId" : "5c261d13-eb63-48c9-b9f5-3f9563af0c32",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Good point.",
        "createdAt" : "2018-11-24T19:15:01Z",
        "updatedAt" : "2018-11-24T19:15:02Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "61371de744b363eacdb2ae277c33d365164380f3",
    "line" : 288,
    "diffHunk" : "@@ -1,1 +1146,1150 @@\n    if dst.dtype.names is None:\n        dst[:] = src\n        return\n"
  },
  {
    "id" : "609822dc-66b7-4932-a9d0-4a0f9c765d87",
    "prId" : 11526,
    "prUrl" : "https://github.com/numpy/numpy/pull/11526#pullrequestreview-178037264",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9801ff89-50fe-4f07-a174-1b3bb0b9f214",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "This name strikes me as a little odd, but I also can't think of a better one.\r\n\r\nIt might be handy to use the word \"require\" in the description somewhere, to make the name easier to remember.",
        "createdAt" : "2018-11-24T01:46:16Z",
        "updatedAt" : "2018-11-24T01:46:16Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "61371de744b363eacdb2ae277c33d365164380f3",
    "line" : 303,
    "diffHunk" : "@@ -1,1 +1161,1165 @@\n@array_function_dispatch(_require_fields_dispatcher)\ndef require_fields(array, required_dtype):\n    \"\"\"\n    Casts a structured array to a new dtype using assignment by field-name."
  },
  {
    "id" : "31acf53f-b989-4257-ac64-513dea450bc1",
    "prId" : 11526,
    "prUrl" : "https://github.com/numpy/numpy/pull/11526#pullrequestreview-178471502",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d215b611-d3c5-4fd3-a572-f253e2e415af",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "What happens if `dtype` is itself a structured array? Eg, consider:\r\n\r\n```\r\npoint = np.dtype([('x'. int), ('y', int)])\r\ntriangle = np.dtype([('p_a', point), ('p_b', point), ('p_c', point)]\r\n```\r\n\r\nI'd expect to be able to do\r\n```\r\narr = np.zeros(10, triangle)\r\n\r\nstructured_to_unstructured(arr, dtype=point)\r\n```",
        "createdAt" : "2018-11-25T00:31:35Z",
        "updatedAt" : "2018-11-25T21:06:07Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "9feb1d31-9fe7-4c4c-84f3-2a0bf5448ef7",
        "parentId" : "d215b611-d3c5-4fd3-a572-f253e2e415af",
        "authorId" : "a4f03a99-2e43-482b-a9bc-5a9e359abb03",
        "body" : "This is accounted for, however your particular example shows there is a bug in this code because it can't account for repeated field names in the nested structures. Will fix.",
        "createdAt" : "2018-11-25T04:11:52Z",
        "updatedAt" : "2018-11-25T04:11:52Z",
        "lastEditedBy" : "a4f03a99-2e43-482b-a9bc-5a9e359abb03",
        "tags" : [
        ]
      },
      {
        "id" : "005efc3a-355f-4a69-b792-d98c6590d0cb",
        "parentId" : "d215b611-d3c5-4fd3-a572-f253e2e415af",
        "authorId" : "a4f03a99-2e43-482b-a9bc-5a9e359abb03",
        "body" : "On second examination, I also missed that your output was structured. `structured_to_unstructured` doesn't account for that the way you expected, and I'm not sure there is a good \"rule\" for how it should work. Your example makes sense because each field can be unambiguously cast to the new structured type, so you expect the output shape to be (10, 3) with `point` dtype. My implementation currently casts all *nested* fields to the new dtype, resulting in a (10, 6) array of points: It casts the x and y of each point to a point individually.",
        "createdAt" : "2018-11-25T05:44:58Z",
        "updatedAt" : "2018-11-25T05:45:09Z",
        "lastEditedBy" : "a4f03a99-2e43-482b-a9bc-5a9e359abb03",
        "tags" : [
        ]
      },
      {
        "id" : "59541a02-b864-457a-b057-7c1819d1bd76",
        "parentId" : "d215b611-d3c5-4fd3-a572-f253e2e415af",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Generating `\"field_{}\".format(i)` as the name for each field is probably the safest bet - if you control all the names, you don't need to worry about escape sequences.",
        "createdAt" : "2018-11-25T19:25:23Z",
        "updatedAt" : "2018-11-25T19:25:23Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "e0ef228e-f910-434a-9d5e-92adf9d374ca",
        "parentId" : "d215b611-d3c5-4fd3-a572-f253e2e415af",
        "authorId" : "a4f03a99-2e43-482b-a9bc-5a9e359abb03",
        "body" : "Yup, that's already fixed/implemented in #12446.\r\n\r\nI'd rather not attempt to account for structured dtypes in the output though: That's not a pre-existing use-case we're trying to fix, and the best behavior to implement  is unclear to me at the moment. Any users who previously did something like that can still do it using `repack_fields` instead of `structured_to_unstructured`, though without the added safety the latter has added.",
        "createdAt" : "2018-11-25T20:52:15Z",
        "updatedAt" : "2018-11-25T20:52:16Z",
        "lastEditedBy" : "a4f03a99-2e43-482b-a9bc-5a9e359abb03",
        "tags" : [
        ]
      },
      {
        "id" : "e961153a-eb07-4506-bb63-1f2775a83da7",
        "parentId" : "d215b611-d3c5-4fd3-a572-f253e2e415af",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "> That's not a pre-existing use-case we're trying to fix,\r\n\r\nAs I understand it, the purpose of `structured_to_unstructured` is to replace the `arr[fields].view(dt)` idiom. But it sounds like it doesn't work as a universal replacement:\r\n\r\n* `arr[['f_a', 'f_b']].view(float)`  &rarr; `structured_to_unstructured(arr['f_a', 'f_c'], float)`\r\n* `arr[['p_a', 'p_b']].view(point)` &rarr; ???\r\n\r\nIs there a way to spell the second case with these functions?",
        "createdAt" : "2018-11-25T21:08:50Z",
        "updatedAt" : "2018-11-25T21:08:50Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "5e3c6230-7ecf-4a92-b561-099a22fdaa36",
        "parentId" : "d215b611-d3c5-4fd3-a572-f253e2e415af",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "> though without the added safety the latter has added.\r\n\r\nCan you give an example of that safety, maybe even in the docs?",
        "createdAt" : "2018-11-25T21:22:26Z",
        "updatedAt" : "2018-11-25T21:22:26Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "3dc53efb-78bc-4704-bb45-df343af8a07c",
        "parentId" : "d215b611-d3c5-4fd3-a572-f253e2e415af",
        "authorId" : "a4f03a99-2e43-482b-a9bc-5a9e359abb03",
        "body" : "Here's my understanding: \r\n\r\nAll code of the form `arr[['field1', 'field2, ...]].view(dt)` in 1.15 can be replaced by `repack_fields(arr[['field1', 'field2, ...]]).view(dt)` in 1.16, without exceptions. It should be identical performance, since in both cases a copy is made.\r\n\r\nAdditionally, we have implemented a new function `structured_to_unstructured`. Although this can't be used as a replacement in all cases as you point out, in the many cases where it *can* be used it is better because it avoids a copy for multifield-indexes, it is safer since it is memory-layout-agnostic, and it better documents the user's intent. It is safer because it saves the user from bugs when doing the `view`: If the user tries to do the view themselves it is quite easy to forget to account for padding bytes, endianness, dtype, or misunderstand the memory layout, but `structured_to_unstructured` is written in a way to guarantee the view is \"safe\" for any memory layout and dtype (the fields are always viewed with the right offsets). `structured_to_unstructured` also casts the fields if needed, which the view above does not do.\r\n",
        "createdAt" : "2018-11-26T17:36:55Z",
        "updatedAt" : "2018-11-26T17:36:55Z",
        "lastEditedBy" : "a4f03a99-2e43-482b-a9bc-5a9e359abb03",
        "tags" : [
        ]
      },
      {
        "id" : "2a32132f-b912-4042-af29-9d198c9b742f",
        "parentId" : "d215b611-d3c5-4fd3-a572-f253e2e415af",
        "authorId" : "a4f03a99-2e43-482b-a9bc-5a9e359abb03",
        "body" : "I added a description based on my last comment in #12447",
        "createdAt" : "2018-11-26T19:53:29Z",
        "updatedAt" : "2018-11-26T19:53:30Z",
        "lastEditedBy" : "a4f03a99-2e43-482b-a9bc-5a9e359abb03",
        "tags" : [
        ]
      }
    ],
    "commit" : "61371de744b363eacdb2ae277c33d365164380f3",
    "line" : 47,
    "diffHunk" : "@@ -1,1 +905,909 @@\n    Nested fields, as well as each element of any subarray fields, all count\n    as a single field-elements.\n\n    Parameters"
  },
  {
    "id" : "01a026d1-5ddc-430b-95e8-43724407f784",
    "prId" : 11526,
    "prUrl" : "https://github.com/numpy/numpy/pull/11526#pullrequestreview-178417729",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bea3d3c8-a303-4d36-811d-e50d68d05413",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "I think there are places we learnt that `unsafe` was a bad default, but ended up stuck with it, leaving users surprised by the conversion.\r\n\r\nShould we apply that learning here, and pick a more conservative default?",
        "createdAt" : "2018-11-25T00:32:56Z",
        "updatedAt" : "2018-11-25T00:32:56Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "4ef0f48c-77bc-4978-9f7f-1bd503b73196",
        "parentId" : "bea3d3c8-a303-4d36-811d-e50d68d05413",
        "authorId" : "a4f03a99-2e43-482b-a9bc-5a9e359abb03",
        "body" : "I may have missed that. Maybe in #8733? But that was about assignment using `unsafe` casting, with no option to specify otherwise, unlike here where there is a keyword the user can specify.",
        "createdAt" : "2018-11-25T20:58:03Z",
        "updatedAt" : "2018-11-25T20:58:04Z",
        "lastEditedBy" : "a4f03a99-2e43-482b-a9bc-5a9e359abb03",
        "tags" : [
        ]
      },
      {
        "id" : "a9370046-fe92-44a9-a748-cf18b145d4da",
        "parentId" : "bea3d3c8-a303-4d36-811d-e50d68d05413",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Yeah, that issue was one of the ones I was thinking of - thanks for linking it, I was looking for that for unrelated reasons too!\r\n\r\nUnsafe just feels like an... unsafe default to me. In my opinion, unsafe behavior should be something you ask for, not something you get by default. You're picking between:\r\n\r\n* as is: `f(...)` vs `f(..., casting='safe')`\r\n* proposed: `f(..., casting='unsafe')` vs `f(...)`\r\n\r\nI'd much rather see the word 'unsafe' to tell me I need to think more carefully about that line of code, rather than having to look for the absence of it.\r\n\r\nI don't have a good memory of how the other casting modes behave. I'd be inclined to pick `same_kind` to match the default value of the casting argument for for `ufunc`s",
        "createdAt" : "2018-11-25T21:13:43Z",
        "updatedAt" : "2018-11-25T21:13:43Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "0353a817-a66a-4bdd-8049-4b3aade0444e",
        "parentId" : "bea3d3c8-a303-4d36-811d-e50d68d05413",
        "authorId" : "a4f03a99-2e43-482b-a9bc-5a9e359abb03",
        "body" : "Here's an argument for `unsafe`: \r\n\r\nFirst, it matches the default for the same keyword in `astype`, and so its easier for the user to remember if they are used to using `astype`. \r\n\r\nSecond, it seems like most of the time the user *wants* `unsafe`, because there are many common casts that are ruled out otherwise. For instance casts from `f8` to `i8` are disallowed with `same_kind`, but I expect this is a very common cast.\r\n\r\nActually, for reasons I don't understand, ufuncs seem to allow casts from `f8` to `i8` even though they supposedly use `same_kind`:\r\n```python\r\n>>> np.arange(3, dtype='f8').astype('i8', casting='same_kind')                 \r\nTypeError: Cannot cast array from dtype('float64') to dtype('int64') according to the rule 'same_kind'\r\n>>> np.add(np.arange(3, dtype='f8'), np.arange(3, dtype='i8'))                 \r\narray([0., 2., 4.])\r\n>>> np.can_cast('f8', 'i8', casting='same_kind')\r\nFalse\r\n```\r\nSo ufuncs appear to use `unsafe` casting despite the keyword default??",
        "createdAt" : "2018-11-26T17:47:40Z",
        "updatedAt" : "2018-11-26T17:51:36Z",
        "lastEditedBy" : "a4f03a99-2e43-482b-a9bc-5a9e359abb03",
        "tags" : [
        ]
      }
    ],
    "commit" : "61371de744b363eacdb2ae277c33d365164380f3",
    "line" : 37,
    "diffHunk" : "@@ -1,1 +895,899 @@\n@array_function_dispatch(_structured_to_unstructured_dispatcher)\ndef structured_to_unstructured(arr, dtype=None, copy=False, casting='unsafe'):\n    \"\"\"\n    Converts and n-D structured array into an (n+1)-D unstructured array."
  },
  {
    "id" : "1fd572d1-83a0-48ae-9644-e16cee504c24",
    "prId" : 12253,
    "prUrl" : "https://github.com/numpy/numpy/pull/12253#pullrequestreview-181526195",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "95ac1152-d533-4dd6-9fb1-114c9f29c82c",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "This looks like a bug - perhaps just open an issue",
        "createdAt" : "2018-12-02T01:07:20Z",
        "updatedAt" : "2018-12-14T18:23:52Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "8ddfe615-c400-449a-ae17-8f91bd99d57d",
        "parentId" : "95ac1152-d533-4dd6-9fb1-114c9f29c82c",
        "authorId" : "73d6f7d8-2c7d-4a48-8754-5ce4a97a850f",
        "body" : "see #12485 -- I'm inclined to leave the \"truth\" (a traceback) until this is fixed / cleared up, but can add a skip otherwise.",
        "createdAt" : "2018-12-04T23:12:01Z",
        "updatedAt" : "2018-12-14T18:23:52Z",
        "lastEditedBy" : "73d6f7d8-2c7d-4a48-8754-5ce4a97a850f",
        "tags" : [
        ]
      }
    ],
    "commit" : "28f8a85b9ece5773a8ac75ffcd2502fc93612eff",
    "line" : 55,
    "diffHunk" : "@@ -1,1 +160,164 @@    Traceback (most recent call last):\n        ...\n    AttributeError: 'numpy.ndarray' object has no attribute 'names'\n    >>> rfn.get_names_flat(np.empty((1,), dtype=[('A',int), ('B', float)]))\n    Traceback (most recent call last):"
  },
  {
    "id" : "2ab06b7e-9b30-40f2-bfb1-5949ada3f9ca",
    "prId" : 12446,
    "prUrl" : "https://github.com/numpy/numpy/pull/12446#pullrequestreview-178065303",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d01e7022-559d-42b2-ae5d-45e96d643a00",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Can you add an example of this too?",
        "createdAt" : "2018-11-24T23:20:44Z",
        "updatedAt" : "2018-11-26T18:03:00Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "032e91b9-70fe-463c-89b8-a31043656cd5",
        "parentId" : "d01e7022-559d-42b2-ae5d-45e96d643a00",
        "authorId" : "a4f03a99-2e43-482b-a9bc-5a9e359abb03",
        "body" : "done",
        "createdAt" : "2018-11-24T23:41:38Z",
        "updatedAt" : "2018-11-26T18:03:00Z",
        "lastEditedBy" : "a4f03a99-2e43-482b-a9bc-5a9e359abb03",
        "tags" : [
        ]
      }
    ],
    "commit" : "191d5c78383771e9a4825801062d0f23625410bf",
    "line" : 116,
    "diffHunk" : "@@ -1,1 +1179,1183 @@\n    If a field name in the required_dtype does not exist in the\n    input array, that field is created and set to 0 in the output array.\n\n    Parameters"
  },
  {
    "id" : "8f0dfa02-245b-49e1-9327-4483ea0325cf",
    "prId" : 13334,
    "prUrl" : "https://github.com/numpy/numpy/pull/13334#pullrequestreview-226434135",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "18e3aba1-3437-4f3a-a8f4-de6319326910",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "This is a strong argument for why #13326 is a good idea",
        "createdAt" : "2019-04-15T02:28:24Z",
        "updatedAt" : "2019-04-24T04:57:52Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "58c28d4fd1c54b455d19372f0c838fed5fc71fe4",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +981,985 @@\n    # finally is it safe to view the packed fields as the unstructured type\n    return arr.view((out_dtype, (sum(counts),)))\n\ndef _unstructured_to_structured_dispatcher(arr, dtype=None, names=None,"
  }
]
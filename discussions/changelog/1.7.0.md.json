[
  {
    "id" : "98c2cb7b-6275-43e6-ab24-953ecdcc8bb3",
    "prId" : 796,
    "prUrl" : "https://github.com/scalameta/scalameta/pull/796#pullrequestreview-32318260",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "52ff3140-8065-4591-a17a-0f0b47790ed5",
        "parentId" : null,
        "authorId" : "56d6821a-439f-4d87-aba8-a6368926dbc5",
        "body" : "@DavidDudson @olafurpg Do you think we should mention more new developments in this area?",
        "createdAt" : "2017-04-11T22:11:02Z",
        "updatedAt" : "2017-04-12T21:30:43Z",
        "lastEditedBy" : "56d6821a-439f-4d87-aba8-a6368926dbc5",
        "tags" : [
        ]
      },
      {
        "id" : "b12235d7-64aa-4cb4-a546-5bff68eae1e3",
        "parentId" : "52ff3140-8065-4591-a17a-0f0b47790ed5",
        "authorId" : "951817ab-7f84-47b3-b139-e9583e3a2714",
        "body" : "Are there any?",
        "createdAt" : "2017-04-12T01:34:16Z",
        "updatedAt" : "2017-04-12T21:30:43Z",
        "lastEditedBy" : "951817ab-7f84-47b3-b139-e9583e3a2714",
        "tags" : [
        ]
      },
      {
        "id" : "158ceec8-e9eb-476f-b535-4d433e9ada9a",
        "parentId" : "52ff3140-8065-4591-a17a-0f0b47790ed5",
        "authorId" : "bd90d0d4-3cfe-485f-b03d-29764e6b2eae",
        "body" : "There are none.",
        "createdAt" : "2017-04-12T09:13:34Z",
        "updatedAt" : "2017-04-12T21:30:43Z",
        "lastEditedBy" : "bd90d0d4-3cfe-485f-b03d-29764e6b2eae",
        "tags" : [
        ]
      }
    ],
    "commit" : "f364019b6a278c511a2abfdf5f01ca7486005772",
    "line" : 47,
    "diffHunk" : "@@ -1,1 +43,47 @@  - More use-cases for Extract are in the pipeline, follow #741 for more details.\n- `structurally` and `syntactically` have been added as enrichments to `Set[Tree]`.\n  - See the `contrib` testsuite for examples.\n- Scaladoc parsing functionality has been added as enrichment to `Comment` (see above).\n"
  },
  {
    "id" : "53edc447-0c84-4ecf-bc39-fb3c5e62146e",
    "prId" : 711,
    "prUrl" : "https://github.com/scalameta/scalameta/pull/711#pullrequestreview-24436995",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9b57152e-752a-4acd-be93-bb750c4a6562",
        "parentId" : null,
        "authorId" : "951817ab-7f84-47b3-b139-e9583e3a2714",
        "body" : "This is not the only case.\r\n\r\nFor instance in the case of `Term.Name` and `Type.Name` they are sibling types. Thus switching the order is irrelevant. This is a typesafe equals. Meaning that the rhs must be the lhs type or a subtype of the lhs type.",
        "createdAt" : "2017-03-01T09:41:57Z",
        "updatedAt" : "2017-03-01T09:45:09Z",
        "lastEditedBy" : "951817ab-7f84-47b3-b139-e9583e3a2714",
        "tags" : [
        ]
      },
      {
        "id" : "1442843a-4b4e-4d24-9c0b-c270cd5e855c",
        "parentId" : "9b57152e-752a-4acd-be93-bb750c4a6562",
        "authorId" : "bd90d0d4-3cfe-485f-b03d-29764e6b2eae",
        "body" : "Good point, you could argue though that the sibling case is a bug fix rather than a breaking change. Comparing sibling types will always be false in the structural equality case (although not in syntax ðŸ¤” )",
        "createdAt" : "2017-03-01T09:51:28Z",
        "updatedAt" : "2017-03-01T09:51:28Z",
        "lastEditedBy" : "bd90d0d4-3cfe-485f-b03d-29764e6b2eae",
        "tags" : [
        ]
      }
    ],
    "commit" : "def79d923770e546406342e053456e0d7afb9c90",
    "line" : 11,
    "diffHunk" : "@@ -1,1 +9,13 @@- `isEqual` defaults to structual equality, so it's not longer necessary to\n  write `[Structurally]` in `a.isEqual[Structurally](b)`.\n- `(a: Subtype).isEqual(b: Supertype)` will no longer compile, either upcast\n  `a: Supertype` or swap the order to `b.isEqual(a)`"
  }
]
[
  {
    "id" : "f8e3a942-8937-4b3f-acf5-687778431927",
    "prId" : 2814,
    "prUrl" : "https://github.com/scalameta/metals/pull/2814#pullrequestreview-669194691",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "58ae2a21-08e7-4be2-b930-6f8b2c4823e5",
        "parentId" : null,
        "authorId" : "84490516-a7af-4f7f-9947-360c279c4400",
        "body" : "So I know when we do an actual format we do a check to ensure that if the user has manually set the `scalafmtConfigPath` it actually exists. here we also call `scalafmtConf`, but don't do that check. Do you think we should also do a check to ensure something wonky doesn't happen here, or even move that check into `scalafmtConf` to ensure that not only have they set the configPath, but it's also valid and there?",
        "createdAt" : "2021-05-25T08:43:48Z",
        "updatedAt" : "2021-05-25T08:50:01Z",
        "lastEditedBy" : "84490516-a7af-4f7f-9947-360c279c4400",
        "tags" : [
        ]
      },
      {
        "id" : "186a689b-cd2c-4c08-a86b-d22665a39a0c",
        "parentId" : "58ae2a21-08e7-4be2-b930-6f8b2c4823e5",
        "authorId" : "2df071f3-6c0f-4323-b87d-c872a042f228",
        "body" : "`scalafmtConf` is this function that checks `userConfig`\r\nhttps://github.com/scalameta/metals/blob/270804287a8abe18bdd072ec7cb0608fc77b1e2c/metals/src/main/scala/scala/meta/internal/metals/FormattingProvider.scala#L362-L365",
        "createdAt" : "2021-05-25T17:39:52Z",
        "updatedAt" : "2021-05-25T17:39:52Z",
        "lastEditedBy" : "2df071f3-6c0f-4323-b87d-c872a042f228",
        "tags" : [
        ]
      },
      {
        "id" : "8c1bc88f-4a0d-4659-bb59-6d0edaa12647",
        "parentId" : "58ae2a21-08e7-4be2-b930-6f8b2c4823e5",
        "authorId" : "84490516-a7af-4f7f-9947-360c279c4400",
        "body" : "Sure, but it doesn't validate anything right? So if `userConfig().scalafmtConfigPath` returns `/my/wrong/path.conf`, that is still returned here and give to you even if it doesn't exists.",
        "createdAt" : "2021-05-26T04:54:20Z",
        "updatedAt" : "2021-05-26T04:54:20Z",
        "lastEditedBy" : "84490516-a7af-4f7f-9947-360c279c4400",
        "tags" : [
        ]
      },
      {
        "id" : "2376e5e3-fea4-40cf-8d7f-5fff9382439b",
        "parentId" : "58ae2a21-08e7-4be2-b930-6f8b2c4823e5",
        "authorId" : "2df071f3-6c0f-4323-b87d-c872a042f228",
        "body" : "oh. now I got what you mean. Will fix that",
        "createdAt" : "2021-05-26T08:39:02Z",
        "updatedAt" : "2021-05-26T08:39:02Z",
        "lastEditedBy" : "2df071f3-6c0f-4323-b87d-c872a042f228",
        "tags" : [
        ]
      },
      {
        "id" : "f08d675e-56c2-493d-8a75-8540314a52ea",
        "parentId" : "58ae2a21-08e7-4be2-b930-6f8b2c4823e5",
        "authorId" : "2df071f3-6c0f-4323-b87d-c872a042f228",
        "body" : "Did two changes around that:\r\n- in case if the conf file doesn't exist or has syntax error now message shows the correct file path in the text\r\n- in case if upgrade is required Metals will suggest only to fix if it's the default one - (`.scalafmt.conf`).\r\n  For a file that is specified in `userConfig` it will only warn about that as it might be shared across several projects. ",
        "createdAt" : "2021-05-26T15:38:53Z",
        "updatedAt" : "2021-05-26T15:38:53Z",
        "lastEditedBy" : "2df071f3-6c0f-4323-b87d-c872a042f228",
        "tags" : [
        ]
      }
    ],
    "commit" : "d60677d3fc5ef32440ddd51547481c8143735402",
    "line" : 205,
    "diffHunk" : "@@ -1,1 +359,363 @@\n  def validateWorkspace(): Future[Unit] = {\n    if (scalafmtConf.exists) {\n      val text = scalafmtConf.toInputFromBuffers(buffers).text\n      ScalafmtConfig.parse(text) match {"
  },
  {
    "id" : "6da3580f-9bce-46af-a057-60ea346698ff",
    "prId" : 2814,
    "prUrl" : "https://github.com/scalameta/metals/pull/2814#pullrequestreview-670000559",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a7e8dc42-73c6-44ef-8984-395382ca4996",
        "parentId" : null,
        "authorId" : "f252b48f-54a9-478d-8bbb-85f01e5c28e7",
        "body" : "```suggestion\r\n        val requiredDialectForTarget =\r\n```",
        "createdAt" : "2021-05-27T10:52:24Z",
        "updatedAt" : "2021-05-27T11:24:05Z",
        "lastEditedBy" : "f252b48f-54a9-478d-8bbb-85f01e5c28e7",
        "tags" : [
        ]
      }
    ],
    "commit" : "d60677d3fc5ef32440ddd51547481c8143735402",
    "line" : 112,
    "diffHunk" : "@@ -1,1 +266,270 @@    ): Option[ScalafmtDialect] = {\n      if (buildTargetIds.nonEmpty && sourceItem.exists) {\n        val required =\n          buildTargetIds\n            .flatMap(buildTargets.scalaTarget)"
  },
  {
    "id" : "d3af1390-702c-4013-a657-631d63650352",
    "prId" : 2814,
    "prUrl" : "https://github.com/scalameta/metals/pull/2814#pullrequestreview-675524321",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "413d5291-c66d-415f-a074-990d27f91ce0",
        "parentId" : null,
        "authorId" : "f252b48f-54a9-478d-8bbb-85f01e5c28e7",
        "body" : "```suggestion\r\n        if (required != default) {\r\n```\r\nwe only have one default",
        "createdAt" : "2021-05-27T10:53:01Z",
        "updatedAt" : "2021-05-27T11:24:05Z",
        "lastEditedBy" : "f252b48f-54a9-478d-8bbb-85f01e5c28e7",
        "tags" : [
        ]
      },
      {
        "id" : "4142d095-3c10-409a-a471-5be588587ebb",
        "parentId" : "413d5291-c66d-415f-a074-990d27f91ce0",
        "authorId" : "2df071f3-6c0f-4323-b87d-c872a042f228",
        "body" : "It's needed to compare them using ordering.  required` might be less than `default`.",
        "createdAt" : "2021-06-03T17:01:01Z",
        "updatedAt" : "2021-06-03T17:01:01Z",
        "lastEditedBy" : "2df071f3-6c0f-4323-b87d-c872a042f228",
        "tags" : [
        ]
      }
    ],
    "commit" : "d60677d3fc5ef32440ddd51547481c8143735402",
    "line" : 120,
    "diffHunk" : "@@ -1,1 +274,278 @@            .getOrElse(ScalafmtDialect.Scala213)\n\n        if (ord.gt(required, default)) {\n          nonExcludedSources(sourceItem) match {\n            case Nil => None"
  },
  {
    "id" : "6fdc8226-87fa-463c-b79a-5a904aac439a",
    "prId" : 2814,
    "prUrl" : "https://github.com/scalameta/metals/pull/2814#pullrequestreview-679504771",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "17a4aa3d-f7fa-434a-bece-b1b9810a24db",
        "parentId" : null,
        "authorId" : "f252b48f-54a9-478d-8bbb-85f01e5c28e7",
        "body" : "Should we not try to always update the version?",
        "createdAt" : "2021-06-09T09:50:36Z",
        "updatedAt" : "2021-06-09T10:13:09Z",
        "lastEditedBy" : "f252b48f-54a9-478d-8bbb-85f01e5c28e7",
        "tags" : [
        ]
      },
      {
        "id" : "688cffb2-15ca-4ef7-8f50-37a6665d60d0",
        "parentId" : "17a4aa3d-f7fa-434a-bece-b1b9810a24db",
        "authorId" : "2df071f3-6c0f-4323-b87d-c872a042f228",
        "body" : "To avoid triggering non-required reformatting that might happen due to version upgrade.",
        "createdAt" : "2021-06-09T10:57:22Z",
        "updatedAt" : "2021-06-09T10:57:22Z",
        "lastEditedBy" : "2df071f3-6c0f-4323-b87d-c872a042f228",
        "tags" : [
        ]
      }
    ],
    "commit" : "d60677d3fc5ef32440ddd51547481c8143735402",
    "line" : 249,
    "diffHunk" : "@@ -1,1 +480,484 @@\n    def rewrite(text: String): String = {\n      val updVersion = versionUpgrade\n      rewriteType match {\n        case RewriteType.GlobalDialect =>"
  },
  {
    "id" : "9669a3e9-8feb-4858-bcd0-48df51cfcd99",
    "prId" : 429,
    "prUrl" : "https://github.com/scalameta/metals/pull/429#pullrequestreview-186889445",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1bdb3c96-d27b-4875-972d-c1e55dee82db",
        "parentId" : null,
        "authorId" : "cea3c370-4fa4-4787-a40c-c406eb22d8b2",
        "body" : "Note. I'm not sure anymore if this is the best reflective API. I think the spotless implementation for Gradle might be more robust https://github.com/diffplug/spotless/blob/9ff51754f13d94731f715b9f302a4de606f3f62d/lib/src/main/java/com/diffplug/spotless/scala/ScalaFmtStep.java#L71-L125 I wish scalafmt had the same nice story for reflective invocation as scalafix üòè \r\n\r\nAnyways, I think this is fine for now. I'm tempted to add a nice reflective API in Scalafmt and then we can use that for newer versions.",
        "createdAt" : "2018-12-20T09:03:50Z",
        "updatedAt" : "2018-12-22T11:11:14Z",
        "lastEditedBy" : "cea3c370-4fa4-4787-a40c-c406eb22d8b2",
        "tags" : [
        ]
      }
    ],
    "commit" : "ec1161fecfaec6824cba1eb2a21806f972c8f67f",
    "line" : 158,
    "diffHunk" : "@@ -1,1 +156,160 @@        }\n        val scalafmt210 = classloader\n          .loadClass(\"org.scalafmt.cli.Scalafmt210\")\n          .newInstance()\n          .asInstanceOf[Scalafmt210]"
  }
]
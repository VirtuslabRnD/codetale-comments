[
  {
    "id" : "9a0a8e04-1de7-47ec-8eda-179023bd899f",
    "prId" : 2921,
    "prUrl" : "https://github.com/scalameta/metals/pull/2921#pullrequestreview-698840891",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0b606dff-cfd8-4aab-b743-eb6b44632bd2",
        "parentId" : null,
        "authorId" : "f252b48f-54a9-478d-8bbb-85f01e5c28e7",
        "body" : "Should we not check the build target errors? It will not work even if the file is ok, but some others failed.",
        "createdAt" : "2021-07-02T13:26:26Z",
        "updatedAt" : "2021-07-02T13:26:26Z",
        "lastEditedBy" : "f252b48f-54a9-478d-8bbb-85f01e5c28e7",
        "tags" : [
        ]
      },
      {
        "id" : "da4fee13-d0b1-4e11-b659-0a21f19af2c9",
        "parentId" : "0b606dff-cfd8-4aab-b743-eb6b44632bd2",
        "authorId" : "84490516-a7af-4f7f-9947-360c279c4400",
        "body" : "I went back and forth on this. If we want to be 100% sure they can actually organize the imports, then yea, we should check build target errors. However, there may be situations where they want to clean up a file and organize the imports in there and the semanticdb for that file is still valid since nothing changed in it. I could be convinced either way. What do you think?",
        "createdAt" : "2021-07-02T14:11:21Z",
        "updatedAt" : "2021-07-02T14:11:22Z",
        "lastEditedBy" : "84490516-a7af-4f7f-9947-360c279c4400",
        "tags" : [
        ]
      },
      {
        "id" : "f71af34a-8f5f-4328-be83-0b82d462dfdd",
        "parentId" : "0b606dff-cfd8-4aab-b743-eb6b44632bd2",
        "authorId" : "f252b48f-54a9-478d-8bbb-85f01e5c28e7",
        "body" : "We could catch the stale exception and check afterwards if the build target contains an error. This would just mean changing the message in case of the stale semanticdb error.",
        "createdAt" : "2021-07-02T14:46:59Z",
        "updatedAt" : "2021-07-02T14:46:59Z",
        "lastEditedBy" : "f252b48f-54a9-478d-8bbb-85f01e5c28e7",
        "tags" : [
        ]
      },
      {
        "id" : "77404413-774e-42a2-beb6-bb5d95c5b800",
        "parentId" : "0b606dff-cfd8-4aab-b743-eb6b44632bd2",
        "authorId" : "84490516-a7af-4f7f-9947-360c279c4400",
        "body" : "Ah yea that's a good idea. I'll add that extra check.",
        "createdAt" : "2021-07-02T14:48:04Z",
        "updatedAt" : "2021-07-02T14:48:04Z",
        "lastEditedBy" : "84490516-a7af-4f7f-9947-360c279c4400",
        "tags" : [
        ]
      },
      {
        "id" : "7a5cb836-4a22-4f2e-81c9-415b8a18622d",
        "parentId" : "0b606dff-cfd8-4aab-b743-eb6b44632bd2",
        "authorId" : "506802e6-3dfb-4c6d-84be-1b8a5d08fbe4",
        "body" : "I didn't know that we produce a semanticdb file if it's not compiling.",
        "createdAt" : "2021-07-05T06:41:19Z",
        "updatedAt" : "2021-07-05T06:41:20Z",
        "lastEditedBy" : "506802e6-3dfb-4c6d-84be-1b8a5d08fbe4",
        "tags" : [
        ]
      }
    ],
    "commit" : "f8242d62730c1b72b1c1ca677a611efacc1b6dc2",
    "line" : 12,
    "diffHunk" : "@@ -1,1 +169,173 @@    syntaxError.contains(path)\n\n  def hasDiagnosticError(path: AbsolutePath): Boolean = {\n    val fileDiagnostics = diagnostics\n      .get(path)"
  }
]
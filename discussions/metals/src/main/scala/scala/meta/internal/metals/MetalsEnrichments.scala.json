[
  {
    "id" : "7fc3630a-68c0-4808-8ad9-781e90f660e6",
    "prId" : 2668,
    "prUrl" : "https://github.com/scalameta/metals/pull/2668#pullrequestreview-640321918",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "24d86262-6f1c-4a11-8114-4f985eb8686e",
        "parentId" : null,
        "authorId" : "84490516-a7af-4f7f-9947-360c279c4400",
        "body" : "Do we also need to consider srcjars here? https://github.com/scalameta/metals/pull/2710",
        "createdAt" : "2021-04-17T14:33:35Z",
        "updatedAt" : "2021-04-23T16:07:37Z",
        "lastEditedBy" : "84490516-a7af-4f7f-9947-360c279c4400",
        "tags" : [
        ]
      },
      {
        "id" : "2a7332af-4041-450b-9afb-680d9a96dae3",
        "parentId" : "24d86262-6f1c-4a11-8114-4f985eb8686e",
        "authorId" : "2df071f3-6c0f-4323-b87d-c872a042f228",
        "body" : "Good catch. Thx!",
        "createdAt" : "2021-04-20T16:41:13Z",
        "updatedAt" : "2021-04-23T16:07:37Z",
        "lastEditedBy" : "2df071f3-6c0f-4323-b87d-c872a042f228",
        "tags" : [
        ]
      },
      {
        "id" : "afe5f748-abe7-4ef3-ae36-98fc7e490d5a",
        "parentId" : "24d86262-6f1c-4a11-8114-4f985eb8686e",
        "authorId" : "2df071f3-6c0f-4323-b87d-c872a042f228",
        "body" : "Ah. Actually, that's a filesystem scheme. For  filesystem over `.srcjar` it should be the same: \"jar\"",
        "createdAt" : "2021-04-20T17:38:03Z",
        "updatedAt" : "2021-04-23T16:07:37Z",
        "lastEditedBy" : "2df071f3-6c0f-4323-b87d-c872a042f228",
        "tags" : [
        ]
      },
      {
        "id" : "ace98d5e-213c-4345-9c66-ae44d4e61b6d",
        "parentId" : "24d86262-6f1c-4a11-8114-4f985eb8686e",
        "authorId" : "84490516-a7af-4f7f-9947-360c279c4400",
        "body" : "Ah ok, I wasn't 100% sure, that's why I brought it up.",
        "createdAt" : "2021-04-20T18:55:56Z",
        "updatedAt" : "2021-04-23T16:07:37Z",
        "lastEditedBy" : "84490516-a7af-4f7f-9947-360c279c4400",
        "tags" : [
        ]
      }
    ],
    "commit" : "e3fcc251f9126b13a9372df15273d675aff8f745",
    "line" : 20,
    "diffHunk" : "@@ -1,1 +285,289 @@    def jarPath: Option[AbsolutePath] = {\n      val filesystem = path.toNIO.getFileSystem()\n      if (filesystem.provider().getScheme().equals(\"jar\")) {\n        Some(\n          AbsolutePath("
  },
  {
    "id" : "f90d04c0-9a4d-40fc-9cc1-b815c2534f9c",
    "prId" : 2668,
    "prUrl" : "https://github.com/scalameta/metals/pull/2668#pullrequestreview-643307776",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b7942de5-25a4-4b59-b8dd-f1bf011c9117",
        "parentId" : null,
        "authorId" : "f252b48f-54a9-478d-8bbb-85f01e5c28e7",
        "body" : "Is it possible that relative might be empty?",
        "createdAt" : "2021-04-22T10:39:12Z",
        "updatedAt" : "2021-04-23T16:07:37Z",
        "lastEditedBy" : "f252b48f-54a9-478d-8bbb-85f01e5c28e7",
        "tags" : [
        ]
      },
      {
        "id" : "8c26eec7-b069-41f6-9897-c643cd18ccaa",
        "parentId" : "b7942de5-25a4-4b59-b8dd-f1bf011c9117",
        "authorId" : "2df071f3-6c0f-4323-b87d-c872a042f228",
        "body" : "Honestly, I'm not sure about Windows.\r\nIn Linux, it can't.",
        "createdAt" : "2021-04-23T13:38:54Z",
        "updatedAt" : "2021-04-23T16:07:37Z",
        "lastEditedBy" : "2df071f3-6c0f-4323-b87d-c872a042f228",
        "tags" : [
        ]
      }
    ],
    "commit" : "e3fcc251f9126b13a9372df15273d675aff8f745",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +279,283 @@    def toRelativeInside(prefix: AbsolutePath): Option[RelativePath] = {\n      val relative = path.toRelative(prefix)\n      if (relative.toNIO.getName(0).filename != \"..\") Some(relative)\n      else None\n    }"
  },
  {
    "id" : "6414da4a-e5be-4b0f-aa33-2072758b982c",
    "prId" : 2374,
    "prUrl" : "https://github.com/scalameta/metals/pull/2374#pullrequestreview-572395546",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e6b8d5e5-7a73-4c18-97c7-c5316971339b",
        "parentId" : null,
        "authorId" : "9cdd9387-08db-4d42-9b6d-ceaa233cadd5",
        "body" : "[note] Previously, the tokenizer always use `Trees.defaultDialect`, now it uses an appropriate dialect for the input.",
        "createdAt" : "2021-01-20T16:17:07Z",
        "updatedAt" : "2021-01-22T16:41:19Z",
        "lastEditedBy" : "9cdd9387-08db-4d42-9b6d-ceaa233cadd5",
        "tags" : [
        ]
      }
    ],
    "commit" : "e3bdee6d5b72cf6cfee580941ef1b1c2987b172b",
    "line" : 20,
    "diffHunk" : "@@ -1,1 +702,706 @@      tree.origin match {\n        case Origin.Parsed(input, dialect, pos) =>\n          val tokens = dialect(input).tokenize.get\n          tokens.slice(0, pos.start - 1).reverseIterator\n        case _ => Iterator.empty"
  },
  {
    "id" : "b7b71833-236b-42a1-9fd7-177eb3a19834",
    "prId" : 1523,
    "prUrl" : "https://github.com/scalameta/metals/pull/1523#pullrequestreview-387685455",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2f6a28f6-f8e5-46cd-8635-6ee77aad7f95",
        "parentId" : null,
        "authorId" : "84490516-a7af-4f7f-9947-360c279c4400",
        "body" : "Ignorant question. This is just because Scala3 produces semanticdb, and therefore are checking for this rather than the plugin right?",
        "createdAt" : "2020-04-04T08:48:59Z",
        "updatedAt" : "2020-04-15T13:50:25Z",
        "lastEditedBy" : "84490516-a7af-4f7f-9947-360c279c4400",
        "tags" : [
        ]
      },
      {
        "id" : "96455eb4-a92c-4523-9773-79cc71ef0099",
        "parentId" : "2f6a28f6-f8e5-46cd-8635-6ee77aad7f95",
        "authorId" : "f252b48f-54a9-478d-8bbb-85f01e5c28e7",
        "body" : "Yes, we don't need to check for the plugin, since we don't need one.",
        "createdAt" : "2020-04-04T09:55:10Z",
        "updatedAt" : "2020-04-15T13:50:25Z",
        "lastEditedBy" : "f252b48f-54a9-478d-8bbb-85f01e5c28e7",
        "tags" : [
        ]
      }
    ],
    "commit" : "1142490703f832961ac0df1debd14b4f3b12ce7d",
    "line" : 112,
    "diffHunk" : "@@ -1,1 +483,487 @@    def isSemanticdbEnabled(scalaVersion: String): Boolean = {\n      if (ScalaVersions.isScala3Version(scalaVersion)) {\n        item.getOptions.asScala.exists { opt => opt == \"-Ysemanticdb\" }\n      } else {\n        item.getOptions.asScala.exists { opt =>"
  },
  {
    "id" : "5ec1d38d-edfe-4225-a384-01014f533d5d",
    "prId" : 1155,
    "prUrl" : "https://github.com/scalameta/metals/pull/1155#pullrequestreview-328205719",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "98f3d91a-7ea1-4d1c-a32a-ee30f364c63c",
        "parentId" : null,
        "authorId" : "f252b48f-54a9-478d-8bbb-85f01e5c28e7",
        "body" : "So there is still a risk we will have a non-atomic operation? Shouldn't we retry the atomic move again or resign altogether.",
        "createdAt" : "2019-12-05T20:41:02Z",
        "updatedAt" : "2019-12-05T20:41:11Z",
        "lastEditedBy" : "f252b48f-54a9-478d-8bbb-85f01e5c28e7",
        "tags" : [
        ]
      },
      {
        "id" : "78b0d53e-922e-4255-8287-c00386d9d822",
        "parentId" : "98f3d91a-7ea1-4d1c-a32a-ee30f364c63c",
        "authorId" : "cea3c370-4fa4-4787-a40c-c406eb22d8b2",
        "body" : "Some file systems donâ€™t support atomic moves so the best we can do is fall back to a normal move. ",
        "createdAt" : "2019-12-05T20:59:11Z",
        "updatedAt" : "2019-12-05T20:59:11Z",
        "lastEditedBy" : "cea3c370-4fa4-4787-a40c-c406eb22d8b2",
        "tags" : [
        ]
      },
      {
        "id" : "52b68101-1227-4104-97d2-48088a5c1c8c",
        "parentId" : "98f3d91a-7ea1-4d1c-a32a-ee30f364c63c",
        "authorId" : "d66a6438-cedf-4b6c-bfdf-ceff0a38786d",
        "body" : "Could there be a more specific exception to catch here?",
        "createdAt" : "2019-12-05T21:00:23Z",
        "updatedAt" : "2019-12-05T21:00:23Z",
        "lastEditedBy" : "d66a6438-cedf-4b6c-bfdf-ceff0a38786d",
        "tags" : [
        ]
      },
      {
        "id" : "8260f790-ef26-4f1f-bd8d-32cb80a3d898",
        "parentId" : "98f3d91a-7ea1-4d1c-a32a-ee30f364c63c",
        "authorId" : "cea3c370-4fa4-4787-a40c-c406eb22d8b2",
        "body" : "The docs don't specify what exception will be thrown so I didn't want to be too specific. ",
        "createdAt" : "2019-12-06T13:36:25Z",
        "updatedAt" : "2019-12-06T13:36:26Z",
        "lastEditedBy" : "cea3c370-4fa4-4787-a40c-c406eb22d8b2",
        "tags" : [
        ]
      }
    ],
    "commit" : "b68fb8c5f762e67fc61452fc9363fd1cebf0ac19",
    "line" : 32,
    "diffHunk" : "@@ -1,1 +365,369 @@      } catch {\n        case NonFatal(_) =>\n          Files.move(tmp, path.toNIO, StandardCopyOption.REPLACE_EXISTING)\n      }\n    }"
  },
  {
    "id" : "fac6ba45-823a-42a5-b801-7eaa09c1ce70",
    "prId" : 1057,
    "prUrl" : "https://github.com/scalameta/metals/pull/1057#pullrequestreview-314924943",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d42d128c-f803-4b6b-b46f-c0fac4e99ce8",
        "parentId" : null,
        "authorId" : "cea3c370-4fa4-4787-a40c-c406eb22d8b2",
        "body" : "ðŸ™ˆ ",
        "createdAt" : "2019-11-11T04:03:20Z",
        "updatedAt" : "2019-11-11T14:41:31Z",
        "lastEditedBy" : "cea3c370-4fa4-4787-a40c-c406eb22d8b2",
        "tags" : [
        ]
      },
      {
        "id" : "565f18ae-3186-4970-9e93-2ac7a02a5f7b",
        "parentId" : "d42d128c-f803-4b6b-b46f-c0fac4e99ce8",
        "authorId" : "cea3c370-4fa4-4787-a40c-c406eb22d8b2",
        "body" : "Wish this was easier to write...",
        "createdAt" : "2019-11-11T04:03:29Z",
        "updatedAt" : "2019-11-11T14:41:31Z",
        "lastEditedBy" : "cea3c370-4fa4-4787-a40c-c406eb22d8b2",
        "tags" : [
        ]
      },
      {
        "id" : "79a5cec6-1323-4ff8-8a2d-ce1ee97772ca",
        "parentId" : "d42d128c-f803-4b6b-b46f-c0fac4e99ce8",
        "authorId" : "cea3c370-4fa4-4787-a40c-c406eb22d8b2",
        "body" : "```scala\r\ntry initializeParams.getCapabilities.getTextDocument.getCompletion.getCompletionItem.getSnippetSupport.booleanValue\r\ncatch { case _: NPE => false }\r\n```\r\n ðŸ˜… ",
        "createdAt" : "2019-11-11T04:04:34Z",
        "updatedAt" : "2019-11-11T14:41:31Z",
        "lastEditedBy" : "cea3c370-4fa4-4787-a40c-c406eb22d8b2",
        "tags" : [
        ]
      },
      {
        "id" : "50ccf8b6-ced8-4458-9d95-491610a61d87",
        "parentId" : "d42d128c-f803-4b6b-b46f-c0fac4e99ce8",
        "authorId" : "d66a6438-cedf-4b6c-bfdf-ceff0a38786d",
        "body" : "poor man's monad :P ",
        "createdAt" : "2019-11-11T14:20:14Z",
        "updatedAt" : "2019-11-11T14:41:31Z",
        "lastEditedBy" : "d66a6438-cedf-4b6c-bfdf-ceff0a38786d",
        "tags" : [
        ]
      }
    ],
    "commit" : "03c3f686dd1789f90cd4b4dd18b979160753abb7",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +510,514 @@      } yield hierarchicalDocumentSymbolSupport.booleanValue).getOrElse(false)\n\n    def supportsCompletionSnippets: Boolean =\n      (for {\n        params <- initializeParams"
  },
  {
    "id" : "180dcb3f-8ff6-437d-af7a-17691936599e",
    "prId" : 1048,
    "prUrl" : "https://github.com/scalameta/metals/pull/1048#pullrequestreview-315013161",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "514429f7-8d63-447c-b0bb-5af481b69a35",
        "parentId" : null,
        "authorId" : "cea3c370-4fa4-4787-a40c-c406eb22d8b2",
        "body" : "`path.startsWith(workspace)` should strictly speaking be a condition as well",
        "createdAt" : "2019-11-11T13:50:07Z",
        "updatedAt" : "2019-11-11T16:33:17Z",
        "lastEditedBy" : "cea3c370-4fa4-4787-a40c-c406eb22d8b2",
        "tags" : [
        ]
      },
      {
        "id" : "1da65146-93bb-43e6-a9d5-7b47eabf82e7",
        "parentId" : "514429f7-8d63-447c-b0bb-5af481b69a35",
        "authorId" : "f252b48f-54a9-478d-8bbb-85f01e5c28e7",
        "body" : "Added! ",
        "createdAt" : "2019-11-11T16:33:44Z",
        "updatedAt" : "2019-11-11T16:33:44Z",
        "lastEditedBy" : "f252b48f-54a9-478d-8bbb-85f01e5c28e7",
        "tags" : [
        ]
      }
    ],
    "commit" : "32617da1c138d4dd74af7289c14ff3aeb1bc9654",
    "line" : 11,
    "diffHunk" : "@@ -1,1 +254,258 @@        isInReadonlyDirectory(workspace)\n\n    def isWorkspaceSource(workspace: AbsolutePath): Boolean =\n      isLocalFileSystem(workspace) &&\n        !isInReadonlyDirectory(workspace) &&"
  },
  {
    "id" : "20bbf833-6a6a-41d1-9506-2b09ebc25403",
    "prId" : 632,
    "prUrl" : "https://github.com/scalameta/metals/pull/632#pullrequestreview-224838245",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "32195092-5d47-4ed0-b4c0-58550e771564",
        "parentId" : null,
        "authorId" : "cea3c370-4fa4-4787-a40c-c406eb22d8b2",
        "body" : "\\o/",
        "createdAt" : "2019-04-10T08:53:10Z",
        "updatedAt" : "2019-04-10T09:48:55Z",
        "lastEditedBy" : "cea3c370-4fa4-4787-a40c-c406eb22d8b2",
        "tags" : [
        ]
      }
    ],
    "commit" : "79793f51fa23f5e83e6e9dc8e633ae708eeb17a1",
    "line" : 21,
    "diffHunk" : "@@ -1,1 +502,506 @@  }\n\n  implicit class XtensionTreeTokenStream(tree: Tree) {\n    def leadingTokens: Iterator[Token] = tree.origin match {\n      case Origin.Parsed(input, _, pos) =>"
  },
  {
    "id" : "f1412cbd-1ba9-4715-9729-4b6b5bc25062",
    "prId" : 3004,
    "prUrl" : "https://github.com/scalameta/metals/pull/3004#pullrequestreview-719044045",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "76cee810-8ea5-4da2-a3b0-6673968b45ab",
        "parentId" : null,
        "authorId" : "84490516-a7af-4f7f-9947-360c279c4400",
        "body" : "Probably not a real issue, but could this ever cause a loop? If there is an `IOException`, then if we wait a bit and try again it should be fine, but is there any situation where that exception could keep happening and fall into an infinite loop?",
        "createdAt" : "2021-07-30T08:23:45Z",
        "updatedAt" : "2021-07-30T08:28:42Z",
        "lastEditedBy" : "84490516-a7af-4f7f-9947-360c279c4400",
        "tags" : [
        ]
      },
      {
        "id" : "914f4438-65e6-449f-bf90-9539c51fe628",
        "parentId" : "76cee810-8ea5-4da2-a3b0-6673968b45ab",
        "authorId" : "2df071f3-6c0f-4323-b87d-c872a042f228",
        "body" : "Good point. I think there non-zero chance to fall into it due to some extra obstacles like unexpected workspace directory ownership changes  /not enough space on disk etc.\r\nAdded an exit clause to avoid infinity loop.",
        "createdAt" : "2021-07-30T12:51:23Z",
        "updatedAt" : "2021-07-30T12:51:23Z",
        "lastEditedBy" : "2df071f3-6c0f-4323-b87d-c872a042f228",
        "tags" : [
        ]
      }
    ],
    "commit" : "f0a0c311e9a97ccc020fbd6a092799d10109d83c",
    "line" : 107,
    "diffHunk" : "@@ -1,1 +415,419 @@                }\n                copyFile(path, out)\n              }(retry)\n            } else\n              out"
  },
  {
    "id" : "46e66d31-21f4-4930-8a4e-baa8b51d1d0a",
    "prId" : 3004,
    "prUrl" : "https://github.com/scalameta/metals/pull/3004#pullrequestreview-720240854",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "469a08d5-7832-4592-83bc-7eba9e759f9e",
        "parentId" : null,
        "authorId" : "f252b48f-54a9-478d-8bbb-85f01e5c28e7",
        "body" : "Wouldn't it be enough to just check if the file exists and then not copy it? Since, we have directory based on the jar name and jar names contain the version, it should never really change, only if someone creates snapshot jars locally, but in that case they will also look at the original sources.\r\n\r\n",
        "createdAt" : "2021-07-30T11:49:29Z",
        "updatedAt" : "2021-07-30T11:49:34Z",
        "lastEditedBy" : "f252b48f-54a9-478d-8bbb-85f01e5c28e7",
        "tags" : [
        ]
      },
      {
        "id" : "8bff6981-e97b-41a5-bb17-fcc4f33233ec",
        "parentId" : "469a08d5-7832-4592-83bc-7eba9e759f9e",
        "authorId" : "2df071f3-6c0f-4323-b87d-c872a042f228",
        "body" : "I agree that it feels a bit redundant but this mechanic with jar-name is far from being perfect. \r\n\r\nThere might be a lot of rare cases when jar name won't guarantee that it's the same artifact.\r\nIn addition to local snapshots, it might be a snapshot jar from some remote repository. Or it might be a forked artifact with the same version (like: `org.scalameta.metals-..` and `com.virtuslab.metals-..`).\r\n\r\nI think that even in these rare cases, it is worth preventing the use of the wrong sources, if possible.\r\nOtherwise, someone might be confused/spend time investigating why the source is different from a real execution before he realizes that it's outdated and only manual cleanup will help.",
        "createdAt" : "2021-07-30T13:10:55Z",
        "updatedAt" : "2021-07-30T13:11:19Z",
        "lastEditedBy" : "2df071f3-6c0f-4323-b87d-c872a042f228",
        "tags" : [
        ]
      },
      {
        "id" : "d0fb047c-7274-4f1c-b3ce-0312b6457933",
        "parentId" : "469a08d5-7832-4592-83bc-7eba9e759f9e",
        "authorId" : "f252b48f-54a9-478d-8bbb-85f01e5c28e7",
        "body" : "Makes sense!",
        "createdAt" : "2021-08-02T14:04:21Z",
        "updatedAt" : "2021-08-02T14:04:21Z",
        "lastEditedBy" : "f252b48f-54a9-478d-8bbb-85f01e5c28e7",
        "tags" : [
        ]
      }
    ],
    "commit" : "f0a0c311e9a97ccc020fbd6a092799d10109d83c",
    "line" : 97,
    "diffHunk" : "@@ -1,1 +405,409 @@\n            val updateMeta = !jarDir.exists || !currentJarMeta.contains(jarMeta)\n            if (!out.exists || updateMeta) {\n              withJarDirLock(jarDir) {\n                if (updateMeta) {"
  }
]
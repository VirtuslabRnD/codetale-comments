[
  {
    "id" : "f4418c51-f3b4-413c-9f16-8239f32854ff",
    "prId" : 2668,
    "prUrl" : "https://github.com/scalameta/metals/pull/2668#pullrequestreview-638229121",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c9e2391a-6f2d-494a-8e72-54c37de29d5f",
        "parentId" : null,
        "authorId" : "84490516-a7af-4f7f-9947-360c279c4400",
        "body" : "I wish we had a `nonEmptySet` to use here.",
        "createdAt" : "2021-04-09T13:56:34Z",
        "updatedAt" : "2021-04-23T16:07:36Z",
        "lastEditedBy" : "84490516-a7af-4f7f-9947-360c279c4400",
        "tags" : [
        ]
      },
      {
        "id" : "bd7fabcc-4a94-458a-8e13-d973eb77782a",
        "parentId" : "c9e2391a-6f2d-494a-8e72-54c37de29d5f",
        "authorId" : "2df071f3-6c0f-4323-b87d-c872a042f228",
        "body" : "I wish the same but as it used in the index too it's required to implement it without additional mem-overhead.\r\nI've seen such implementation in [cats](https://github.com/typelevel/cats/blob/main/core/src/main/scala/cats/data/NonEmptySet.scala) but I don't know if it worths copy-paste their implementation for these two cases.\r\n",
        "createdAt" : "2021-04-12T13:47:23Z",
        "updatedAt" : "2021-04-23T16:07:36Z",
        "lastEditedBy" : "2df071f3-6c0f-4323-b87d-c872a042f228",
        "tags" : [
        ]
      },
      {
        "id" : "fed74194-5bab-471d-b64b-c3da3cc9da7a",
        "parentId" : "c9e2391a-6f2d-494a-8e72-54c37de29d5f",
        "authorId" : "84490516-a7af-4f7f-9947-360c279c4400",
        "body" : "Ha, for sure not worth it. Was just thinking out loud :)",
        "createdAt" : "2021-04-17T13:53:49Z",
        "updatedAt" : "2021-04-23T16:07:36Z",
        "lastEditedBy" : "84490516-a7af-4f7f-9947-360c279c4400",
        "tags" : [
        ]
      }
    ],
    "commit" : "e3fcc251f9126b13a9372df15273d675aff8f745",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +50,54 @@    TrieMap.empty[BuildTargetIdentifier, util.Set[AbsolutePath]]\n  private val inverseDependencySources =\n    TrieMap.empty[AbsolutePath, Set[BuildTargetIdentifier]]\n  private val isSourceRoot =\n    ConcurrentHashSet.empty[AbsolutePath]"
  },
  {
    "id" : "d3741e17-4e05-4565-b088-4cdcd4cae638",
    "prId" : 1865,
    "prUrl" : "https://github.com/scalameta/metals/pull/1865#pullrequestreview-455985796",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8ea37ec6-00c5-41b3-8272-e5f7c70c181d",
        "parentId" : null,
        "authorId" : "f252b48f-54a9-478d-8bbb-85f01e5c28e7",
        "body" : "Do we return the right sbt target for the Scala files located in `project` directories? I think if Bloop doesn't provide use with proper source roots we could add a custom logic for resolving target by source file in `inverseSources`. If no build target is found we can look if this file should belong to an sbt build target. What do you think?",
        "createdAt" : "2020-07-27T13:01:46Z",
        "updatedAt" : "2020-07-31T11:55:17Z",
        "lastEditedBy" : "f252b48f-54a9-478d-8bbb-85f01e5c28e7",
        "tags" : [
        ]
      },
      {
        "id" : "99683ba4-71a4-4a5c-9792-051513f44efb",
        "parentId" : "8ea37ec6-00c5-41b3-8272-e5f7c70c181d",
        "authorId" : "2df071f3-6c0f-4323-b87d-c872a042f228",
        "body" : "This method is only for `.*sbt` files.\r\nFor `*.scala` files from meta build `inverseSources` is used as usual.\r\n\r\nI think when we start implementing compilation for `.*sbt` files it would be better to move this logic into `inverseSources` method. But for now, I'm not sure if there is a need for that.\r\n",
        "createdAt" : "2020-07-27T17:24:04Z",
        "updatedAt" : "2020-07-31T11:55:17Z",
        "lastEditedBy" : "2df071f3-6c0f-4323-b87d-c872a042f228",
        "tags" : [
        ]
      }
    ],
    "commit" : "1ecc085ce9f65d042e2055d19fd627c5d49e7918",
    "line" : 72,
    "diffHunk" : "@@ -1,1 +246,250 @@   *   because `*.sbt` aren't included in `sourceFiles` set\n   */\n  def sbtBuildScalaTarget(file: AbsolutePath): Option[ScalaTarget] = {\n    val targetMetaBuildDir = file.parent.resolve(\"project\")\n    buildTargetInfo.values"
  },
  {
    "id" : "e7def911-a564-414b-9047-57931b940432",
    "prId" : 1781,
    "prUrl" : "https://github.com/scalameta/metals/pull/1781#pullrequestreview-419141553",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "efe6d1ae-8a64-4869-8d1b-fbbcfdde9509",
        "parentId" : null,
        "authorId" : "84490516-a7af-4f7f-9947-360c279c4400",
        "body" : "So I _think_ I understand what is going on here, but why when used up above do we so a `sortBy` and below we use `max`?. Also, what's the benefit of using binary shift operators here? I've actually never came across these in the wild before ðŸ˜¬ ",
        "createdAt" : "2020-05-27T12:05:48Z",
        "updatedAt" : "2020-05-27T12:07:41Z",
        "lastEditedBy" : "84490516-a7af-4f7f-9947-360c279c4400",
        "tags" : [
        ]
      },
      {
        "id" : "c4b6f041-f37a-4066-8c20-4bbded2e7834",
        "parentId" : "efe6d1ae-8a64-4869-8d1b-fbbcfdde9509",
        "authorId" : "f252b48f-54a9-478d-8bbb-85f01e5c28e7",
        "body" : "We are using maxBy in a scenario that we know the list is not empty and it produces a single element. `sortBy` still produces a list, which is useful in the other scenario.\r\n\r\nBinary shift is I think just an easy way to introduce priority.",
        "createdAt" : "2020-05-27T12:16:58Z",
        "updatedAt" : "2020-05-27T12:16:58Z",
        "lastEditedBy" : "f252b48f-54a9-478d-8bbb-85f01e5c28e7",
        "tags" : [
        ]
      },
      {
        "id" : "9df859e9-ec20-49f1-876b-efd936de11aa",
        "parentId" : "efe6d1ae-8a64-4869-8d1b-fbbcfdde9509",
        "authorId" : "84490516-a7af-4f7f-9947-360c279c4400",
        "body" : "Sounds good. Thanks for explaining.",
        "createdAt" : "2020-05-27T12:29:11Z",
        "updatedAt" : "2020-05-27T12:29:11Z",
        "lastEditedBy" : "84490516-a7af-4f7f-9947-360c279c4400",
        "tags" : [
        ]
      }
    ],
    "commit" : "376535f14d761d5513fd67b015e9ab10588f0ac7",
    "line" : 23,
    "diffHunk" : "@@ -1,1 +72,76 @@\n      score\n  }\n\n  def setTables(newTables: Tables): Unit = {"
  },
  {
    "id" : "947dc10f-414b-48c4-b78d-6f3cf0c12123",
    "prId" : 1145,
    "prUrl" : "https://github.com/scalameta/metals/pull/1145#pullrequestreview-327444170",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "cf84c4b9-92b2-4ff4-b9ca-22874e472200",
        "parentId" : null,
        "authorId" : "d66a6438-cedf-4b6c-bfdf-ceff0a38786d",
        "body" : "`.toOption`?",
        "createdAt" : "2019-12-04T17:28:38Z",
        "updatedAt" : "2019-12-05T11:14:30Z",
        "lastEditedBy" : "d66a6438-cedf-4b6c-bfdf-ceff0a38786d",
        "tags" : [
        ]
      },
      {
        "id" : "83bb9181-557b-426c-b1df-b853fefeb786",
        "parentId" : "cf84c4b9-92b2-4ff4-b9ca-22874e472200",
        "authorId" : "cea3c370-4fa4-4787-a40c-c406eb22d8b2",
        "body" : "This code is unchanged from before, it just moved. I think `toOption.flatten` is a valid refactoring but it's unrelated to this PR.",
        "createdAt" : "2019-12-05T10:26:24Z",
        "updatedAt" : "2019-12-05T11:14:30Z",
        "lastEditedBy" : "cea3c370-4fa4-4787-a40c-c406eb22d8b2",
        "tags" : [
        ]
      }
    ],
    "commit" : "c032fa899f1747d53cf2025b6e1cf03227b19980",
    "line" : 54,
    "diffHunk" : "@@ -1,1 +254,258 @@  ): Option[BuildTargetIdentifier] = {\n    if (source.isDependencySource(workspace)) {\n      Try(unsafeInferBuildTarget(source)).getOrElse(None)\n    } else {\n      val fromInference ="
  },
  {
    "id" : "f67446fa-fcd3-40cb-9b14-416a8c974526",
    "prId" : 1145,
    "prUrl" : "https://github.com/scalameta/metals/pull/1145#pullrequestreview-327473884",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "39075e50-c91f-4591-be60-ac90815e11e9",
        "parentId" : null,
        "authorId" : "f252b48f-54a9-478d-8bbb-85f01e5c28e7",
        "body" : "Same for buildTargetReference?",
        "createdAt" : "2019-12-04T18:27:21Z",
        "updatedAt" : "2019-12-05T11:14:30Z",
        "lastEditedBy" : "f252b48f-54a9-478d-8bbb-85f01e5c28e7",
        "tags" : [
        ]
      },
      {
        "id" : "afccf50f-0178-4e05-9d95-43ce1a04d9ca",
        "parentId" : "39075e50-c91f-4591-be60-ac90815e11e9",
        "authorId" : "cea3c370-4fa4-4787-a40c-c406eb22d8b2",
        "body" : "Nice catch! Fixed.",
        "createdAt" : "2019-12-05T11:14:08Z",
        "updatedAt" : "2019-12-05T11:14:30Z",
        "lastEditedBy" : "cea3c370-4fa4-4787-a40c-c406eb22d8b2",
        "tags" : [
        ]
      }
    ],
    "commit" : "c032fa899f1747d53cf2025b6e1cf03227b19980",
    "line" : 15,
    "diffHunk" : "@@ -1,1 +62,66 @@    buildTargetSources.clear()\n    inverseDependencySources.clear()\n    isSourceRoot.clear()\n    buildTargetInference.clear()\n  }"
  },
  {
    "id" : "5a48d698-8a21-42eb-9fbd-29cd432333dd",
    "prId" : 948,
    "prUrl" : "https://github.com/scalameta/metals/pull/948#pullrequestreview-294242420",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "319dd603-4e92-4daa-8728-c1769b8caf3c",
        "parentId" : null,
        "authorId" : "fd1e81aa-f1f7-46f0-84c3-a8d7faae9085",
        "body" : "NiceðŸ‘Œ",
        "createdAt" : "2019-09-27T10:31:57Z",
        "updatedAt" : "2019-09-27T10:32:40Z",
        "lastEditedBy" : "fd1e81aa-f1f7-46f0-84c3-a8d7faae9085",
        "tags" : [
        ]
      }
    ],
    "commit" : "468f3ce838bfa1ab613b941981f8aefa06619232",
    "line" : 39,
    "diffHunk" : "@@ -1,1 +205,209 @@          t => ScalaVersions.isSupportedScalaVersion(t.getScalaVersion())\n        )\n        if (isSupportedScalaVersion) score <<= 2\n\n        val isJVM = scalacOptions(t).exists(_.isJVM)"
  },
  {
    "id" : "d0a7e632-75d8-443b-afb3-4142ecf5ea07",
    "prId" : 857,
    "prUrl" : "https://github.com/scalameta/metals/pull/857#pullrequestreview-272360644",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c9d8930a-86b4-42c4-a7eb-8b05ab83fb71",
        "parentId" : null,
        "authorId" : "a1d420d1-83d4-48b5-b245-772065f6633b",
        "body" : "I was thinking about renaming the `sourceItems` to just `sources` whenever we find it ;)",
        "createdAt" : "2019-08-08T06:15:50Z",
        "updatedAt" : "2019-08-08T16:25:02Z",
        "lastEditedBy" : "a1d420d1-83d4-48b5-b245-772065f6633b",
        "tags" : [
        ]
      }
    ],
    "commit" : "0dd3eede29c603619dd79001b736615bb5743729",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +32,36 @@  }\n  private var tables: Option[Tables] = None\n  private val sourceItemsToBuildTarget =\n    TrieMap.empty[AbsolutePath, ConcurrentLinkedQueue[BuildTargetIdentifier]]\n  private val buildTargetInfo ="
  }
]
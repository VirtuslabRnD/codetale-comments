[
  {
    "id" : "f54b6c81-ad29-4e5c-8891-e613a1cc62e9",
    "prId" : 1477,
    "prUrl" : "https://github.com/typelevel/cats-effect/pull/1477#pullrequestreview-549155990",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "16e3a161-d5af-4580-b91b-bf506570bce0",
        "parentId" : null,
        "authorId" : "df537f5b-c150-4710-8eb4-40b8b59c3bcc",
        "body" : "I'd rather have `Unique.Mk` similar to the Ref/Deferred ones, then even the standard implementation can be with `Sync`.",
        "createdAt" : "2020-12-10T10:55:56Z",
        "updatedAt" : "2020-12-18T22:34:24Z",
        "lastEditedBy" : "df537f5b-c150-4710-8eb4-40b8b59c3bcc",
        "tags" : [
        ]
      },
      {
        "id" : "3c457d0f-2e79-43ac-b5b0-5fefb9ddea4d",
        "parentId" : "16e3a161-d5af-4580-b91b-bf506570bce0",
        "authorId" : "a5a514ff-cd89-45cb-bcc8-796f0fa2a445",
        "body" : "The reason not to have it is the same why we avoided `Mk` for `Ref/Deferred` as the main way of abstraction. It's a very low level implementation detail that pollutes everything, and the main use case for `Unique` (at least for me) it's been using it for concurrent abstractions.\r\n\r\nAlso, if the only way to create `Unique` is `Sync`, fs2 cannot use it, basically, since we want to be able to compile under `Concurrent` only. It's definitely on the hacky side though, I can see that :)",
        "createdAt" : "2020-12-10T12:35:16Z",
        "updatedAt" : "2020-12-18T22:34:24Z",
        "lastEditedBy" : "a5a514ff-cd89-45cb-bcc8-796f0fa2a445",
        "tags" : [
        ]
      },
      {
        "id" : "18f9a95a-f405-4b79-ad78-76a89b4588c5",
        "parentId" : "16e3a161-d5af-4580-b91b-bf506570bce0",
        "authorId" : "df537f5b-c150-4710-8eb4-40b8b59c3bcc",
        "body" : "Yeah, I see your point - if someone wants to make a Unique they'll likely need Concurrent too...",
        "createdAt" : "2020-12-10T12:40:46Z",
        "updatedAt" : "2020-12-18T22:34:24Z",
        "lastEditedBy" : "df537f5b-c150-4710-8eb4-40b8b59c3bcc",
        "tags" : [
        ]
      }
    ],
    "commit" : "7158131458d9947bd216e7a2a1691c9c9bf1858a",
    "line" : 45,
    "diffHunk" : "@@ -1,1 +43,47 @@  def apply[F[_]: Concurrent]: F[Unique] = Concurrent[F].unit.map(_ => new Unique)\n\n  def sync[F[_]: Sync]: F[Unique] = Sync[F].delay(new Unique)\n\n  implicit val uniqueInstances: Hash[Unique] ="
  },
  {
    "id" : "0a667b40-4323-4f9e-92d6-8a330487c1a5",
    "prId" : 1477,
    "prUrl" : "https://github.com/typelevel/cats-effect/pull/1477#pullrequestreview-550640075",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e5775793-1129-41b7-a194-6e6acfd3798b",
        "parentId" : null,
        "authorId" : "211229ef-cf92-4efb-a365-b4e7be832c88",
        "body" : "It might be worth noting in the Scaladoc that a `Unique` value is _only_ guaranteed to be unique in terms of the reference equality comparison. That is, two `Unique` values created with different effects can have to same `.hashCode` and `.toString`, even though they compare as non-equal.\r\n\r\n```scala\r\nscala> res7\r\nval res17: cats.effect.std.Unique = Unique(2c0e55fe)\r\n\r\nscala> res8\r\nval res18: cats.effect.std.Unique = Unique(2c0e55fe)\r\n\r\nscala> res7 == res8\r\nval res19: Boolean = false\r\n\r\nscala> res7.hashCode == res8.hashCode\r\nval res20: Boolean = true\r\n\r\nscala> res7.toString == res8.toString\r\nval res21: Boolean = true\r\n```\r\n\r\nOn JRE 15 with default settings I hit a collision for hashCode usually between 10K-100K invocations.",
        "createdAt" : "2020-12-11T23:17:17Z",
        "updatedAt" : "2020-12-18T22:34:24Z",
        "lastEditedBy" : "211229ef-cf92-4efb-a365-b4e7be832c88",
        "tags" : [
        ]
      }
    ],
    "commit" : "7158131458d9947bd216e7a2a1691c9c9bf1858a",
    "line" : 40,
    "diffHunk" : "@@ -1,1 +38,42 @@ */\nfinal class Unique private extends Serializable {\n  override def toString: String = s\"Unique(${hashCode.toHexString})\"\n}\nobject Unique {"
  }
]
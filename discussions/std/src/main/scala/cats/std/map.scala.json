[
  {
    "id" : "edbc356a-d9e0-4c20-be84-dad602bb97ad",
    "prId" : 65,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0ebb436f-e3dd-402d-a272-952f0afc9cd7",
        "parentId" : null,
        "authorId" : "db2259e2-e814-4267-a82a-58d7cfbc050f",
        "body" : "rest ? you mean tail?\n",
        "createdAt" : "2015-02-04T14:07:59Z",
        "updatedAt" : "2015-02-06T16:27:43Z",
        "lastEditedBy" : "db2259e2-e814-4267-a82a-58d7cfbc050f",
        "tags" : [
        ]
      },
      {
        "id" : "47481b8c-7aa6-4383-b102-6a601cb6dd15",
        "parentId" : "0ebb436f-e3dd-402d-a272-952f0afc9cd7",
        "authorId" : "89a3e0e3-e301-4aa8-b150-74070eb5a619",
        "body" : "I think that's based on code I wrote.\n\nWhen I'm deconstructing things I like to avoid the words _head_ and _tail_ since they potentially can be confused with the methods involved. In this case, we are splitting a list into `a` (the head value) and `rest` (the rest of the list).\n\nI guess tastes vary. Interested to hear if this bugs other people too?\n",
        "createdAt" : "2015-02-04T14:28:08Z",
        "updatedAt" : "2015-02-06T16:27:43Z",
        "lastEditedBy" : "89a3e0e3-e301-4aa8-b150-74070eb5a619",
        "tags" : [
        ]
      },
      {
        "id" : "92a2da55-3cf4-47ce-8191-d6fb56250b0d",
        "parentId" : "0ebb436f-e3dd-402d-a272-952f0afc9cd7",
        "authorId" : "b3959098-dd79-469e-9fce-aff8d8e90465",
        "body" : "I call it `rest` too, but your reason is better than mine.\nOn Wed, Feb 4, 2015 at 09:28 Erik Osheim notifications@github.com wrote:\n\n> In std/src/main/scala/cats/std/map.scala\n> https://github.com/non/cats/pull/65#discussion_r24085953:\n> \n> > +\n> > -      override def flatMap[A, B](fa: Map[K, A])(f: (A) => Map[K, B]): Map[K, B] =\n> > -        fa.flatMap { case (_, a) => f(a) }\n> >   +\n> > -      override def foldLeft[A, B](fa: Map[K, A], b: B)(f: (B, A) => B): B =\n> > -        fa.foldLeft(b) { case (x, (k, a)) => f(x, a)}\n> >   +\n> > -      override def foldRight[A, B](fa: Map[K, A], b: B)(f: (A, B) => B): B =\n> > -        fa.foldRight(b) { case ((k, a), z) => f(a, z)}\n> >   +\n> > -      override def foldRight[A, B](fa: Map[K, A], b: Lazy[B])(f: (A, Lazy[B]) => B): Lazy[B] = {\n> > -        // we use Lazy.byName(...) to avoid memoizing intermediate values.\n> > -        def loop(as: Map[K, A], b: Lazy[B]): Lazy[B] =\n> > -          as.toList match {\n> > -            case Nil => b\n> > -            case a :: rest => Lazy.byName(f(a._2, foldRight(rest.toMap, b)(f)))\n> \n> I think that's based on code I wrote.\n> \n> When I'm deconstructing things I like to avoid the words _head_ and _tail_\n> since they potentially can be confused with the methods involved. In this\n> case, we are splitting a list into a (the head value) and rest (the rest\n> of the list).\n> \n> I guess tastes vary. Interested to hear if this bugs other people too?\n> \n> â€”\n> Reply to this email directly or view it on GitHub\n> https://github.com/non/cats/pull/65/files#r24085953.\n",
        "createdAt" : "2015-02-04T14:30:24Z",
        "updatedAt" : "2015-02-06T16:27:43Z",
        "lastEditedBy" : "b3959098-dd79-469e-9fce-aff8d8e90465",
        "tags" : [
        ]
      },
      {
        "id" : "5687a52f-ca83-41e9-87ae-0ff5ed955f87",
        "parentId" : "0ebb436f-e3dd-402d-a272-952f0afc9cd7",
        "authorId" : "14c86714-0b80-493d-ab9e-1f96f9bc1e59",
        "body" : "like @gbougeard I prefer `head :: tail` but your reason @non is persuasive and I think consistency is important and it is the reason why I choose `a :: rest`  ( because I hesitate to switch to `head :: tail` ) \n",
        "createdAt" : "2015-02-04T14:51:11Z",
        "updatedAt" : "2015-02-06T16:27:43Z",
        "lastEditedBy" : "14c86714-0b80-493d-ab9e-1f96f9bc1e59",
        "tags" : [
        ]
      }
    ],
    "commit" : "2a3d12751f61bb3322d7e6ebc30f20c7fd123390",
    "line" : 33,
    "diffHunk" : "@@ -1,1 +31,35 @@          as.toList match {\n            case Nil => b\n            case a :: rest => Lazy.byName(f(a._2, foldRight(rest.toMap, b)(f)))\n          }\n        // we memoize the first \"step\" with Lazy(...)."
  }
]
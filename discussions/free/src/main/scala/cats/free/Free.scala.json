[
  {
    "id" : "926be11b-7560-4918-82d1-cd72604e5f9d",
    "prId" : 2169,
    "prUrl" : "https://github.com/typelevel/cats/pull/2169#pullrequestreview-104631668",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3263e564-1574-44f5-87da-254565a32816",
        "parentId" : null,
        "authorId" : "b714495a-5740-47d4-aaaa-98f354f5c0a7",
        "body" : "I'm surprised that it's not a problem to use this as a public return type when the class is package private. It looks like this is the pattern that we are using elsewhere, though. I guess since it's a value class that gets erased it ends up not mattering?",
        "createdAt" : "2018-03-16T16:23:16Z",
        "updatedAt" : "2018-03-16T16:24:24Z",
        "lastEditedBy" : "b714495a-5740-47d4-aaaa-98f354f5c0a7",
        "tags" : [
        ]
      }
    ],
    "commit" : "4f0f016960e86118f4c4728c661e653748b52071",
    "line" : 26,
    "diffHunk" : "@@ -1,1 +282,286 @@    * Uses the [[http://typelevel.org/cats/guidelines.html#partially-applied-type-params Partially Applied Type Params technique]] for ergonomics.\n    */\n  private[free] final class FreeLiftInjectKPartiallyApplied[G[_]](val dummy: Boolean = true ) extends AnyVal {\n    def apply[F[_], A](fa: F[A])(implicit I: InjectK[F, G]): Free[G, A] =\n      Free.liftF(I.inj(fa))"
  },
  {
    "id" : "86100e7c-5474-4acc-bd66-2dfcff73ba0c",
    "prId" : 1840,
    "prUrl" : "https://github.com/typelevel/cats/pull/1840#pullrequestreview-58034479",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ec5bfb4b-cfb3-4c7f-ba4e-16d0149093a8",
        "parentId" : null,
        "authorId" : "98bd6ddf-86cb-413a-a672-ee7d989ba290",
        "body" : "I think that `lbb.flatMap(bb => foldRight(g(a), Eval.now(bb))(f))` instead of `foldRight(g(a), lbb)(f)` should make this stack safe.\r\n\r\nWe should probably add a test to check this. Something like (haven't compiled this):\r\n\r\n```scala\r\nval n = 50000\r\nval freeOption: Int => Free[Option, Int] = Free.pure(x)\r\nval free = (0 to n).foldLeft(freeOption(0))((r, _) => r.flatMap(n => freeOption(n + 1)))\r\nfree.foldRight(0)((a, lb) => lb.map(_ + a)) should (n)\r\n```",
        "createdAt" : "2017-08-22T22:01:27Z",
        "updatedAt" : "2017-08-25T20:01:34Z",
        "lastEditedBy" : "98bd6ddf-86cb-413a-a672-ee7d989ba290",
        "tags" : [
        ]
      },
      {
        "id" : "214fae6c-42e3-488c-ad2b-597abf6a72fd",
        "parentId" : "ec5bfb4b-cfb3-4c7f-ba4e-16d0149093a8",
        "authorId" : "0ac6dfbf-d966-445b-b037-bbe7bf2ea549",
        "body" : "i've added the test!",
        "createdAt" : "2017-08-23T10:19:37Z",
        "updatedAt" : "2017-08-25T20:01:34Z",
        "lastEditedBy" : "0ac6dfbf-d966-445b-b037-bbe7bf2ea549",
        "tags" : [
        ]
      }
    ],
    "commit" : "3cdb62d37be2253eecc465a0719834ab36e3e6ac",
    "line" : 50,
    "diffHunk" : "@@ -1,1 +281,285 @@      a => f(a, lb),\n      fa => F.foldRight(fa, lb)(f),\n      { case (fx, g) => F.foldRight(fx, lb)( (a, lbb) => foldRight(g(a), lbb)(f)) }\n    )\n}"
  },
  {
    "id" : "fc284c21-c13d-489b-87cc-071da93cc200",
    "prId" : 1306,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "588e74b6-b385-45a7-b6fe-0e264c5fbe95",
        "parentId" : null,
        "authorId" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "body" : "Isn't this a recursive flatMap? Why isn't this using tailRecM?\n",
        "createdAt" : "2016-08-20T22:24:04Z",
        "updatedAt" : "2016-08-20T22:24:04Z",
        "lastEditedBy" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "tags" : [
        ]
      },
      {
        "id" : "ad21588b-8677-4f95-a1e7-c912ba8291dc",
        "parentId" : "588e74b6-b385-45a7-b6fe-0e264c5fbe95",
        "authorId" : "4aafd631-794d-4704-aeda-a6c56ce667d1",
        "body" : "Yeah it is - I just went around changing stuff from `Either` to `Xor`, didn't really look at implementations at all.\n\nI think I know how to change this to use `tailRecM` but since you and Eric are currently reviewing and I'd like to keep this all in one commit, I'll let you guys finish reviewing, fix it, have you give it a glance, and push.\n",
        "createdAt" : "2016-08-20T22:32:57Z",
        "updatedAt" : "2016-08-20T22:32:57Z",
        "lastEditedBy" : "4aafd631-794d-4704-aeda-a6c56ce667d1",
        "tags" : [
        ]
      },
      {
        "id" : "9a7e4279-2387-44aa-80f5-3cd9eb549833",
        "parentId" : "588e74b6-b385-45a7-b6fe-0e264c5fbe95",
        "authorId" : "89a3e0e3-e301-4aa8-b150-74070eb5a619",
        "body" : "Given that this was there already I say let's open an issue and not hold this PR up for this.\n",
        "createdAt" : "2016-08-20T22:35:52Z",
        "updatedAt" : "2016-08-20T22:35:52Z",
        "lastEditedBy" : "89a3e0e3-e301-4aa8-b150-74070eb5a619",
        "tags" : [
        ]
      },
      {
        "id" : "4196a25b-b164-4583-b77a-6780ea7e4600",
        "parentId" : "588e74b6-b385-45a7-b6fe-0e264c5fbe95",
        "authorId" : "89a3e0e3-e301-4aa8-b150-74070eb5a619",
        "body" : "(We can still fix it today but I want to get _master_ out of the DANGER DANGER state as soon as possible.)\n",
        "createdAt" : "2016-08-20T22:36:40Z",
        "updatedAt" : "2016-08-20T22:36:40Z",
        "lastEditedBy" : "89a3e0e3-e301-4aa8-b150-74070eb5a619",
        "tags" : [
        ]
      },
      {
        "id" : "97a9ed5b-a29e-4f2a-aa71-b6398a6884b2",
        "parentId" : "588e74b6-b385-45a7-b6fe-0e264c5fbe95",
        "authorId" : "4aafd631-794d-4704-aeda-a6c56ce667d1",
        "body" : "Sounds good\n",
        "createdAt" : "2016-08-20T22:37:48Z",
        "updatedAt" : "2016-08-20T22:37:48Z",
        "lastEditedBy" : "4aafd631-794d-4704-aeda-a6c56ce667d1",
        "tags" : [
        ]
      },
      {
        "id" : "9b472448-9a54-4a1f-b6ed-45652c693554",
        "parentId" : "588e74b6-b385-45a7-b6fe-0e264c5fbe95",
        "authorId" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "body" : "I'll try to have a branch hot and ready to fix this, but yes, let's merge this first.\n",
        "createdAt" : "2016-08-20T22:50:27Z",
        "updatedAt" : "2016-08-20T22:50:27Z",
        "lastEditedBy" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "tags" : [
        ]
      }
    ],
    "commit" : "1867956e3e803ca95ed42339de4839c6ce631d4f",
    "line" : 43,
    "diffHunk" : "@@ -1,1 +82,86 @@  final def runM[M[_]](f: S[Free[S, A]] => M[Free[S, A]])(implicit S: Functor[S], M: Monad[M]): M[A] = {\n    def runM2(t: Free[S, A]): M[A] = t.resume match {\n      case Xor.Left(s) => Monad[M].flatMap(f(s))(runM2)\n      case Xor.Right(r) => Monad[M].pure(r)\n    }"
  },
  {
    "id" : "ced06b81-3869-4058-b729-fb05f5a67941",
    "prId" : 1085,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "79198073-fc61-4d39-8358-39163fad43a6",
        "parentId" : null,
        "authorId" : "5fc8c7f8-34e6-46ea-986e-eb92cd93a6ce",
        "body" : "Did I miss it, or does this method not use the `G.tailRecM` method at all?\n\nAlso, it seems like there is double trampolining (once via `Free` and once via `Eval` in `F.foldRight`)? I wonder if a more direct implementation (using either `Free` or `Eval`, but not both) is possible.\n",
        "createdAt" : "2016-06-10T19:42:06Z",
        "updatedAt" : "2016-06-10T19:42:06Z",
        "lastEditedBy" : "5fc8c7f8-34e6-46ea-986e-eb92cd93a6ce",
        "tags" : [
        ]
      },
      {
        "id" : "aaac5be3-5a81-4cd8-af78-47cadafe9116",
        "parentId" : "79198073-fc61-4d39-8358-39163fad43a6",
        "authorId" : "b714495a-5740-47d4-aaaa-98f354f5c0a7",
        "body" : "@TomasMikula as the author of this code, I'll be the first to say that it is a bit bizarre. `G.tailRecM` should be being called by the `runTailRec` call on the `Free` structure. `Eval` makes an appearance due to the `foldRight` type signature, but really we are just using `foldRight` because of its laziness, and `unsafeFoldLeftM` is calling `.value` on the `Eval`, so we don't actually get any `Eval` trampolining here. It's effectively like we are using a scalaz-style `foldRight` that takes a byname parameter, since we aren't taking advantage `Eval`'s trampolining.\n\nIf you can figure out a way to provide a more direct implementation, I'd definitely be interested. I think that this has to be done in terms of `foldRight` if we want laziness, though, which means `Eval` will definitely be in play. You may be able to use `MonadRec` and `foldRight` without `Free`, and if so that'd be great - as it stands I'm kind of convinced that we should move `Free` (the monad but not the other free structures) back into core for this sort of thing.\n",
        "createdAt" : "2016-06-11T12:37:00Z",
        "updatedAt" : "2016-06-11T12:37:00Z",
        "lastEditedBy" : "b714495a-5740-47d4-aaaa-98f354f5c0a7",
        "tags" : [
        ]
      },
      {
        "id" : "449db935-2a8e-43ce-8829-c827c542fbca",
        "parentId" : "79198073-fc61-4d39-8358-39163fad43a6",
        "authorId" : "b714495a-5740-47d4-aaaa-98f354f5c0a7",
        "body" : "One other note: it really isn't obvious to me that this implementation should be stack safe, but the tests kind of prove that it is `Â¯\\_(ãƒ„)_/Â¯`\n",
        "createdAt" : "2016-06-11T12:38:51Z",
        "updatedAt" : "2016-06-11T12:38:59Z",
        "lastEditedBy" : "b714495a-5740-47d4-aaaa-98f354f5c0a7",
        "tags" : [
        ]
      },
      {
        "id" : "e7e658cf-e8ef-4685-a78d-27154acc90f7",
        "parentId" : "79198073-fc61-4d39-8358-39163fad43a6",
        "authorId" : "5fc8c7f8-34e6-46ea-986e-eb92cd93a6ce",
        "body" : "somehow I completely missed that `.runTailRec` at the end ðŸ˜Š \n",
        "createdAt" : "2016-06-11T17:53:45Z",
        "updatedAt" : "2016-06-11T17:53:45Z",
        "lastEditedBy" : "5fc8c7f8-34e6-46ea-986e-eb92cd93a6ce",
        "tags" : [
        ]
      }
    ],
    "commit" : "36e947197cfcbf48796f9f2384e88dd8da087105",
    "line" : 223,
    "diffHunk" : "@@ -1,1 +220,224 @@    unsafeFoldLeftM[F, Free[G, ?], A, B](fa, z) { (b, a) =>\n      Free.liftF(f(b, a))\n    }.runTailRec\n\n  private def unsafeFoldLeftM[F[_], G[_], A, B](fa: F[A], z: B)(f: (B, A) => G[B])(implicit F: Foldable[F], G: Monad[G]): G[B] ="
  }
]
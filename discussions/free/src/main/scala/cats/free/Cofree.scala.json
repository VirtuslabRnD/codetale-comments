[
  {
    "id" : "a8229a9c-66cd-41c6-8601-e5b2bbba3727",
    "prId" : 1446,
    "prUrl" : "https://github.com/typelevel/cats/pull/1446#pullrequestreview-6331234",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "176915e7-29d6-432e-aa0e-670652cb551d",
        "parentId" : null,
        "authorId" : "4aafd631-794d-4704-aeda-a6c56ce667d1",
        "body" : "Was this derived/based on Scalaz's [Cofree](https://github.com/scalaz/scalaz/blob/series/7.3.x/core/src/main/scala/scalaz/Cofree.scala) or from scratch? If former could you add attribution to Scalaz, similar to what we have [here](https://github.com/typelevel/cats/blob/master/free/src/main/scala/cats/free/FreeT.scala#L14) ?\n",
        "createdAt" : "2016-10-28T22:23:22Z",
        "updatedAt" : "2016-12-21T02:26:37Z",
        "lastEditedBy" : "4aafd631-794d-4704-aeda-a6c56ce667d1",
        "tags" : [
        ]
      },
      {
        "id" : "f200a9ec-ca63-43da-b8c5-821a098c74a1",
        "parentId" : "176915e7-29d6-432e-aa0e-670652cb551d",
        "authorId" : "b084ae12-948e-41db-b85f-097bb81e5826",
        "body" : "Totally derived from the one at Scalaz. I did not know there was an example of such an attribution somewhere in the code to crib from, I'll add it in.\n",
        "createdAt" : "2016-10-28T22:52:59Z",
        "updatedAt" : "2016-12-21T02:26:37Z",
        "lastEditedBy" : "b084ae12-948e-41db-b85f-097bb81e5826",
        "tags" : [
        ]
      }
    ],
    "commit" : "52067df2902de3c68a70a0c079f09f6f4414f3a6",
    "line" : null,
    "diffHunk" : "@@ -1,1 +11,15 @@  * [[https://github.com/scalaz/scalaz/blob/series/7.3.x/core/src/main/scala/scalaz/Cofree.scala Scalaz's Cofree]],\n  * originally written by RÃºnar Bjarnason.\n  */\nfinal case class Cofree[S[_], A](head: A, tail: Eval[S[Cofree[S, A]]]) {\n"
  },
  {
    "id" : "e0c79f49-ccc4-43e9-b30b-c61b3a1f3962",
    "prId" : 1446,
    "prUrl" : "https://github.com/typelevel/cats/pull/1446#pullrequestreview-12344802",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9714c72d-d6f1-4612-a60f-d374bd7a44d9",
        "parentId" : null,
        "authorId" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "body" : "why did you do this vs something like:\r\n\r\n```scala\r\nf(ta.head, fa.tailEval.map { reduceRightTo(_)(z)(f) })\r\n```",
        "createdAt" : "2016-12-03T00:02:55Z",
        "updatedAt" : "2016-12-21T02:26:37Z",
        "lastEditedBy" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "tags" : [
        ]
      },
      {
        "id" : "8bae6501-fe7e-433a-bfd2-b178ab607181",
        "parentId" : "9714c72d-d6f1-4612-a60f-d374bd7a44d9",
        "authorId" : "b084ae12-948e-41db-b85f-097bb81e5826",
        "body" : "Try doing that yourself. Doesn't typecheck as far as I can see; you're expecting `tailEval` to hold an `Eval[Cofree[F, A]]` instead of an `Eval[F[Cofree[F, A]]]`.",
        "createdAt" : "2016-12-10T09:01:08Z",
        "updatedAt" : "2016-12-21T02:26:37Z",
        "lastEditedBy" : "b084ae12-948e-41db-b85f-097bb81e5826",
        "tags" : [
        ]
      }
    ],
    "commit" : "52067df2902de3c68a70a0c079f09f6f4414f3a6",
    "line" : 133,
    "diffHunk" : "@@ -1,1 +131,135 @@    F.foldLeft(fa.tailForced, z(fa.head))((b, cof) => foldLeft(cof, b)(f))\n\n  override def reduceRightTo[A, B](fa: Cofree[F, A])(z: A => B)(f: (A, Eval[B]) => Eval[B]): Eval[B] = {\n    foldRight(fa, Eval.now((None: Option[B]))) {\n      case (l, e) => e.flatMap {"
  },
  {
    "id" : "dc79693f-6784-4f5a-8451-4b8c2bdc1436",
    "prId" : 1446,
    "prUrl" : "https://github.com/typelevel/cats/pull/1446#pullrequestreview-13879075",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4fe4f9a4-7daa-4578-a264-e2bce86a0684",
        "parentId" : null,
        "authorId" : "8106957f-b999-418b-b22b-14067e9a3932",
        "body" : "It would be nice to have the monadic ana as well.\r\n\r\n```scala\r\ndef unfoldM[M[_]: Monad, F[_]: Traverse, A](a: A)(f: A => M[F[A]]): M[Cofree[F, A]]\r\n```",
        "createdAt" : "2016-12-21T00:16:18Z",
        "updatedAt" : "2016-12-21T02:26:37Z",
        "lastEditedBy" : "8106957f-b999-418b-b22b-14067e9a3932",
        "tags" : [
        ]
      },
      {
        "id" : "67ce7dd8-a503-4302-8405-d8a6c2d1329b",
        "parentId" : "4fe4f9a4-7daa-4578-a264-e2bce86a0684",
        "authorId" : "b084ae12-948e-41db-b85f-097bb81e5826",
        "body" : "Sure :)",
        "createdAt" : "2016-12-21T00:22:23Z",
        "updatedAt" : "2016-12-21T02:26:37Z",
        "lastEditedBy" : "b084ae12-948e-41db-b85f-097bb81e5826",
        "tags" : [
        ]
      }
    ],
    "commit" : "52067df2902de3c68a70a0c079f09f6f4414f3a6",
    "line" : 65,
    "diffHunk" : "@@ -1,1 +63,67 @@  def unfold[F[_], A](a: A)(f: A => F[A])(implicit F: Functor[F]): Cofree[F, A] =\n    Cofree[F, A](a, Eval.later(F.map(f(a))(unfold(_)(f))))\n\n  /**\n    * A stack-safe algebraic recursive fold out of the cofree comonad."
  },
  {
    "id" : "47691428-a184-48f1-b7a1-a5634d8a6622",
    "prId" : 1446,
    "prUrl" : "https://github.com/typelevel/cats/pull/1446#pullrequestreview-13879087",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2c6cf377-ac70-433e-a943-2120b7041f8f",
        "parentId" : null,
        "authorId" : "8106957f-b999-418b-b22b-14067e9a3932",
        "body" : "I am unhappy that `Eval` forces `Traverse[F]` when the strict version would only need `Functor`.",
        "createdAt" : "2016-12-21T00:18:13Z",
        "updatedAt" : "2016-12-21T02:26:37Z",
        "lastEditedBy" : "8106957f-b999-418b-b22b-14067e9a3932",
        "tags" : [
        ]
      },
      {
        "id" : "e3b2d422-08ac-41f3-a184-0ea7ac580e51",
        "parentId" : "2c6cf377-ac70-433e-a943-2120b7041f8f",
        "authorId" : "b084ae12-948e-41db-b85f-097bb81e5826",
        "body" : "Let the record show that I am also made unhappy by this.",
        "createdAt" : "2016-12-21T00:22:31Z",
        "updatedAt" : "2016-12-21T02:26:37Z",
        "lastEditedBy" : "b084ae12-948e-41db-b85f-097bb81e5826",
        "tags" : [
        ]
      }
    ],
    "commit" : "52067df2902de3c68a70a0c079f09f6f4414f3a6",
    "line" : 69,
    "diffHunk" : "@@ -1,1 +67,71 @@    * A stack-safe algebraic recursive fold out of the cofree comonad.\n    */\n  def cata[F[_], A, B](cof: Cofree[F, A])(folder: (A, F[B]) => Eval[B])(implicit F: Traverse[F]): Eval[B] =\n    F.traverse(cof.tailForced)(cata(_)(folder)).flatMap(folder(cof.head, _))\n"
  }
]
[
  {
    "id" : "8b67adb4-cee0-4155-9399-5552e7aa4c54",
    "prId" : 1266,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "589256d7-b882-46ae-b8d8-77cc6abc9737",
        "parentId" : null,
        "authorId" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "body" : "what's the rationale for `g @ FlatMapped(_, _) => g.a` rather than `FlatMapped(a, _) =>`\n\nsame below.\n\nAlso, why not:\n\n``` scala\nthis match {\n  case FlatMapped(FlatMapped(a, fn0), fn1) =>\n    a.flatMap(a => fn0(a).flatMap(fn1)).step\n  case nonNestedFlatMap => nonNestedFlatMap\n}\n```\n",
        "createdAt" : "2016-08-11T05:36:06Z",
        "updatedAt" : "2016-08-20T04:37:55Z",
        "lastEditedBy" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "tags" : [
        ]
      },
      {
        "id" : "2eacabff-b5e5-478f-bbdc-05868ba25f8e",
        "parentId" : "589256d7-b882-46ae-b8d8-77cc6abc9737",
        "authorId" : "38b2671a-e346-400c-b290-b97f8c3dc652",
        "body" : "These are for the same reasons as https://github.com/typelevel/cats/pull/1266#discussion_r73614872 Inference does not work when referring to an abstract type member.\n",
        "createdAt" : "2016-08-11T05:53:00Z",
        "updatedAt" : "2016-08-20T04:37:55Z",
        "lastEditedBy" : "38b2671a-e346-400c-b290-b97f8c3dc652",
        "tags" : [
        ]
      },
      {
        "id" : "2c284825-c48a-47de-8e02-06dc33901378",
        "parentId" : "589256d7-b882-46ae-b8d8-77cc6abc9737",
        "authorId" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "body" : "scala!!!!!!!!!!\n\nOkay.\n",
        "createdAt" : "2016-08-11T17:48:54Z",
        "updatedAt" : "2016-08-20T04:37:55Z",
        "lastEditedBy" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "tags" : [
        ]
      }
    ],
    "commit" : "c4161274d1c3bf26a5354e0ab02771e308f1bb57",
    "line" : 124,
    "diffHunk" : "@@ -1,1 +122,126 @@  private def step: FreeT[S, M, A] =\n    this match {\n      case g @ FlatMapped(_, _) => g.a match {\n        case g0 @ FlatMapped(_, _) => g0.a.flatMap(a => g0.f(a).flatMap(g.f)).step\n        case _ => g"
  },
  {
    "id" : "69fd2ab3-9d7a-44ed-ba10-89b325cc8f4e",
    "prId" : 1266,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "cd95ac9e-4de3-4239-ac92-142edb733887",
        "parentId" : null,
        "authorId" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "body" : "why do we need `RecursiveTailRecM` here?\n",
        "createdAt" : "2016-08-18T18:43:33Z",
        "updatedAt" : "2016-08-20T04:37:55Z",
        "lastEditedBy" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "tags" : [
        ]
      },
      {
        "id" : "0e762071-b2b1-4218-8f55-b96eaf71a60c",
        "parentId" : "cd95ac9e-4de3-4239-ac92-142edb733887",
        "authorId" : "38b2671a-e346-400c-b290-b97f8c3dc652",
        "body" : "Constrains the nested M to be also stack safe but if you think is not necessary we can remove this constrain.\n",
        "createdAt" : "2016-08-18T19:10:39Z",
        "updatedAt" : "2016-08-20T04:37:55Z",
        "lastEditedBy" : "38b2671a-e346-400c-b290-b97f8c3dc652",
        "tags" : [
        ]
      }
    ],
    "commit" : "c4161274d1c3bf26a5354e0ab02771e308f1bb57",
    "line" : 188,
    "diffHunk" : "@@ -1,1 +186,190 @@\nprivate[free] sealed trait FreeTInstances2 extends FreeTInstances3 {\n  implicit def catsFreeMonadErrorForFreeT[S[_], M[_]: RecursiveTailRecM, E](implicit E: MonadError[M, E]): MonadError[FreeT[S, M, ?], E] =\n    new MonadError[FreeT[S, M, ?], E] with FreeTMonad[S, M] {\n      override def M = implicitly"
  }
]
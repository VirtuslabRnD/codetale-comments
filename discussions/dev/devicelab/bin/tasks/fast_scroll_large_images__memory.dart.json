[
  {
    "id" : "879b6d82-a668-451e-8867-dee4dd7f24f2",
    "prId" : 46626,
    "prUrl" : "https://github.com/flutter/flutter/pull/46626#pullrequestreview-330188844",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "41f7731a-7a8d-4ca8-b6fc-beb83862dfd7",
        "parentId" : null,
        "authorId" : "9b5a6de7-1648-432f-a400-7a47bea935d8",
        "body" : "rather than waiting an arbitrary time, which is super flaky, can we just wait until the test is known to have finished, somehow?",
        "createdAt" : "2019-12-10T00:45:53Z",
        "updatedAt" : "2019-12-10T00:45:53Z",
        "lastEditedBy" : "9b5a6de7-1648-432f-a400-7a47bea935d8",
        "tags" : [
        ]
      },
      {
        "id" : "f85cb78e-7b9b-4fef-9b14-b961d495740b",
        "parentId" : "41f7731a-7a8d-4ca8-b6fc-beb83862dfd7",
        "authorId" : "9b5a6de7-1648-432f-a400-7a47bea935d8",
        "body" : "(e.g. watching the logs, like some of the other tests do?)",
        "createdAt" : "2019-12-10T00:46:04Z",
        "updatedAt" : "2019-12-10T00:46:05Z",
        "lastEditedBy" : "9b5a6de7-1648-432f-a400-7a47bea935d8",
        "tags" : [
        ]
      },
      {
        "id" : "9101cb30-e587-4233-9443-01dbd27b763f",
        "parentId" : "41f7731a-7a8d-4ca8-b6fc-beb83862dfd7",
        "authorId" : "0dfb4b67-cdbe-4905-93ea-e8b19d917e2a",
        "body" : "Agree that waiting for some actual signal would be much better. Although this would rely on some (to-be-added) signals/logs being generated by the engine in the IO thread, so this would require some engine changes first. There's an additional difficulty that we should wait for the last cleanup signal, but it's unclear to me how to determine whether a signal is the final one as the engine could generate arbitrary number of such signals at arbitrary times. CC @dnfield and @chinmaygarde for more thoughts on how to provide a deterministic signal from the engine.",
        "createdAt" : "2019-12-10T21:29:15Z",
        "updatedAt" : "2019-12-10T21:29:15Z",
        "lastEditedBy" : "0dfb4b67-cdbe-4905-93ea-e8b19d917e2a",
        "tags" : [
        ]
      },
      {
        "id" : "d2a8db36-2072-4e4b-ab49-864b1f5cab8a",
        "parentId" : "41f7731a-7a8d-4ca8-b6fc-beb83862dfd7",
        "authorId" : "9b5a6de7-1648-432f-a400-7a47bea935d8",
        "body" : "can't we just print from the dart code in the test?",
        "createdAt" : "2019-12-10T22:09:56Z",
        "updatedAt" : "2019-12-10T22:09:56Z",
        "lastEditedBy" : "9b5a6de7-1648-432f-a400-7a47bea935d8",
        "tags" : [
        ]
      },
      {
        "id" : "d2b9bc8c-d38d-4a02-ae85-bd987e886f6d",
        "parentId" : "41f7731a-7a8d-4ca8-b6fc-beb83862dfd7",
        "authorId" : "0dfb4b67-cdbe-4905-93ea-e8b19d917e2a",
        "body" : "When the Dart code released the image, the engine IO thread and Skia would still hold the graphics memory. The actually release won't happen until a `Drain` task is executed, which could be delayed by up to 3 seconds, or even more if there are some slow IO thread tasks. The test only makes sense to measure the memory when the last engine IO thread `Drain` task actually finishes. That's why printing something from the Dart code isn't an option here.",
        "createdAt" : "2019-12-10T22:27:38Z",
        "updatedAt" : "2019-12-10T22:27:38Z",
        "lastEditedBy" : "0dfb4b67-cdbe-4905-93ea-e8b19d917e2a",
        "tags" : [
        ]
      }
    ],
    "commit" : "9bff37d690b8f49081a02e794436dc00dc4ae89f",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +31,35 @@    await recordStart();\n    await device.shellExec('input', <String>['swipe', '0 1500 0 0 50']);\n    await Future<void>.delayed(const Duration(milliseconds: 15000));\n    await recordEnd();\n  }"
  }
]
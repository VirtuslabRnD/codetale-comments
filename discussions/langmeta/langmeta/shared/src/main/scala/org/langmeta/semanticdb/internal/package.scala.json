[
  {
    "id" : "93b28ef3-9a5d-4698-9aca-98242790cafd",
    "prId" : 1416,
    "prUrl" : "https://github.com/scalameta/scalameta/pull/1416#pullrequestreview-102582915",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8277f793-0aca-4fc4-ad2f-c40aa9d6cacc",
        "parentId" : null,
        "authorId" : "bd90d0d4-3cfe-485f-b03d-29764e6b2eae",
        "body" : "👏 👏 ",
        "createdAt" : "2018-03-09T09:24:21Z",
        "updatedAt" : "2018-03-09T15:12:28Z",
        "lastEditedBy" : "bd90d0d4-3cfe-485f-b03d-29764e6b2eae",
        "tags" : [
        ]
      }
    ],
    "commit" : "2ff10c15502b6b6400abe286a263819084a11d18",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +112,116 @@              var dflags = 0L\n              def dflip(dbit: Long) = dflags ^= dbit\n              if (slanguage == l.JAVA) dflip(d.JAVADEFINED)\n              skind match {\n                case k.LOCAL => dflip(d.LOCAL)"
  },
  {
    "id" : "47265cb1-00d3-4ce7-8f23-0dd84940a456",
    "prId" : 1373,
    "prUrl" : "https://github.com/scalameta/scalameta/pull/1373#pullrequestreview-99591959",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4e2360b9-6359-488c-b12f-6dd4aced19ad",
        "parentId" : null,
        "authorId" : "bd90d0d4-3cfe-485f-b03d-29764e6b2eae",
        "body" : "👍 ",
        "createdAt" : "2018-02-27T09:59:43Z",
        "updatedAt" : "2018-02-27T11:18:13Z",
        "lastEditedBy" : "bd90d0d4-3cfe-485f-b03d-29764e6b2eae",
        "tags" : [
        ]
      }
    ],
    "commit" : "384068564d24a8d1d4b4b578ae673d40f3d2ab0d",
    "line" : 12,
    "diffHunk" : "@@ -1,1 +345,349 @@              val slocation = None\n              val ssignature = {\n                if (ddenot.signature.nonEmpty) {\n                  val stext = ddenot.signature\n                  val soccurrences = ddenot.names.map {"
  },
  {
    "id" : "ae466c28-b25d-4ea1-a66d-d1c576735244",
    "prId" : 1253,
    "prUrl" : "https://github.com/scalameta/scalameta/pull/1253#pullrequestreview-93856619",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2d6c0063-4206-4e9a-b137-c6dcdc8bfa4f",
        "parentId" : null,
        "authorId" : "afdf3934-3a83-4268-8ebd-d85e5cabfcd6",
        "body" : "suri is always a file?",
        "createdAt" : "2018-02-04T11:01:59Z",
        "updatedAt" : "2018-02-04T11:01:59Z",
        "lastEditedBy" : "afdf3934-3a83-4268-8ebd-d85e5cabfcd6",
        "tags" : [
        ]
      },
      {
        "id" : "f9a0e511-5456-499f-96e5-fe878683cf54",
        "parentId" : "2d6c0063-4206-4e9a-b137-c6dcdc8bfa4f",
        "authorId" : "afdf3934-3a83-4268-8ebd-d85e5cabfcd6",
        "body" : "What if you have a cross-project?",
        "createdAt" : "2018-02-04T11:06:42Z",
        "updatedAt" : "2018-02-04T11:06:42Z",
        "lastEditedBy" : "afdf3934-3a83-4268-8ebd-d85e5cabfcd6",
        "tags" : [
        ]
      },
      {
        "id" : "0e58681f-df11-41bc-bc5e-e482fe2fe7ec",
        "parentId" : "2d6c0063-4206-4e9a-b137-c6dcdc8bfa4f",
        "authorId" : "56d6821a-439f-4d87-aba8-a6368926dbc5",
        "body" : "`suri` is a relative path (original source's path minus the original sourceroot).\r\n\r\nIn case of multiple projects sharing the same files, you end up with SemanticDB payloads that have the same uris. This means that local symbols aren't guaranteed to be unique within universes that mix such projects.\r\n\r\nHowever, this problem was also present in SemanticDB v2. This pull requests doesn't aim to fix this problem though - just to achieve feature parity between v2 and v3.",
        "createdAt" : "2018-02-04T20:21:48Z",
        "updatedAt" : "2018-02-04T20:21:48Z",
        "lastEditedBy" : "56d6821a-439f-4d87-aba8-a6368926dbc5",
        "tags" : [
        ]
      }
    ],
    "commit" : "c787ab1acc1b048e2f532befcc18c966e6423558",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +64,68 @@      assert(sschema == s.Schema.SEMANTICDB3, \"s.TextDocument.schema must be ${s.Schema.SEMANTICDB3}\")\n      def dsymbol(ssymbol: String) = {\n        def suffix = suri.replace(\"/\", \"_\").replace(\".\", \"_\")\n        if (ssymbol.startsWith(\"local\")) d.Symbol(ssymbol + \"_\" + suffix)\n        else d.Symbol(ssymbol)"
  },
  {
    "id" : "60f79c28-320d-4474-96c3-3debd98ecb64",
    "prId" : 1238,
    "prUrl" : "https://github.com/scalameta/scalameta/pull/1238#pullrequestreview-93325587",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4759e2e6-b2f5-45d1-ae6f-ac25790a8b03",
        "parentId" : null,
        "authorId" : "bd90d0d4-3cfe-485f-b03d-29764e6b2eae",
        "body" : "we should make lineToOffset non-package-private, both metals and metaconfig have custom files in org.langmeta package to access this method. Now that line/character are the default I think we should bake these into the public API.\r\n\r\nMaybe even add new Position.Range constructor: `Position.Range.fromLine(input, startLine, startColumn, endLine, endColumn)`",
        "createdAt" : "2018-02-01T12:26:05Z",
        "updatedAt" : "2018-02-01T16:00:22Z",
        "lastEditedBy" : "bd90d0d4-3cfe-485f-b03d-29764e6b2eae",
        "tags" : [
        ]
      },
      {
        "id" : "74f30dca-d621-4eb2-a71b-962906d6651e",
        "parentId" : "4759e2e6-b2f5-45d1-ae6f-ac25790a8b03",
        "authorId" : "56d6821a-439f-4d87-aba8-a6368926dbc5",
        "body" : "Done.",
        "createdAt" : "2018-02-01T15:39:26Z",
        "updatedAt" : "2018-02-01T16:00:22Z",
        "lastEditedBy" : "56d6821a-439f-4d87-aba8-a6368926dbc5",
        "tags" : [
        ]
      }
    ],
    "commit" : "0295ec5950b1f4dad650d2b602c7cbe9e15b136f",
    "line" : 104,
    "diffHunk" : "@@ -1,1 +80,84 @@      object sRange {\n        def unapply(srange: s.Range): Option[dPosition] = {\n          val dstartOffset = dinput.lineToOffset(srange.startLine) + srange.startCharacter\n          val dendOffset = dinput.lineToOffset(srange.endLine) + srange.endCharacter\n          Some(dPosition.Range(dinput, dstartOffset, dendOffset))"
  },
  {
    "id" : "6fbffb05-b002-490e-b832-bfb40941c9f6",
    "prId" : 1238,
    "prUrl" : "https://github.com/scalameta/scalameta/pull/1238#pullrequestreview-93206891",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "867ae818-bb47-467d-82a3-e8f7e50314e5",
        "parentId" : null,
        "authorId" : "bd90d0d4-3cfe-485f-b03d-29764e6b2eae",
        "body" : "General note, I've found the error messages in these conversion to be cryptic. If for example `d.Symbol` fails then I want the error message from that apply instead of a generic \"bad protobuf\". Pattern matching is not helping us here IMO.",
        "createdAt" : "2018-02-01T12:30:04Z",
        "updatedAt" : "2018-02-01T16:00:22Z",
        "lastEditedBy" : "bd90d0d4-3cfe-485f-b03d-29764e6b2eae",
        "tags" : [
        ]
      }
    ],
    "commit" : "0295ec5950b1f4dad650d2b602c7cbe9e15b136f",
    "line" : 233,
    "diffHunk" : "@@ -1,1 +179,183 @@                    d.ResolvedName(dsyntheticpos, dsym, disDefinition)\n                  case other =>\n                    sys.error(s\"bad protobuf: unsupported occurrence $other\")\n                }.toList\n              }.getOrElse(Nil)"
  },
  {
    "id" : "31034861-c58e-4b3e-ab60-527fa24eeec3",
    "prId" : 1238,
    "prUrl" : "https://github.com/scalameta/scalameta/pull/1238#pullrequestreview-93325302",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "da35d0d0-32c4-4b0d-8f6a-5f353a5954c0",
        "parentId" : null,
        "authorId" : "bd90d0d4-3cfe-485f-b03d-29764e6b2eae",
        "body" : "While were refactoring this, can we please add more expect tests for modifiers? The current expect tests don't handle all available modifiers, writing a single file like\r\n```scala\r\npackage object App {\r\n  trait Trait\r\n  class Class\r\n  object Object\r\n  implicit def Implicit = 1\r\n  sealed trait Sealed\r\n  protected def Protected = 2\r\n  def TypeParameter[T] = 3\r\n  def Parameter(Param: Int) = 4\r\n  ...\r\n}\r\n```\r\n\r\nWe have hit on roundtrip bugs and those are usually not discovered until we pull in the latest release in scalafix.",
        "createdAt" : "2018-02-01T12:37:33Z",
        "updatedAt" : "2018-02-01T16:00:22Z",
        "lastEditedBy" : "bd90d0d4-3cfe-485f-b03d-29764e6b2eae",
        "tags" : [
        ]
      },
      {
        "id" : "1bbae76c-0340-4d05-a5ea-0b96e12ccb45",
        "parentId" : "da35d0d0-32c4-4b0d-8f6a-5f353a5954c0",
        "authorId" : "56d6821a-439f-4d87-aba8-a6368926dbc5",
        "body" : "Done.",
        "createdAt" : "2018-02-01T15:38:43Z",
        "updatedAt" : "2018-02-01T16:00:22Z",
        "lastEditedBy" : "56d6821a-439f-4d87-aba8-a6368926dbc5",
        "tags" : [
        ]
      }
    ],
    "commit" : "0295ec5950b1f4dad650d2b602c7cbe9e15b136f",
    "line" : 329,
    "diffHunk" : "@@ -1,1 +250,254 @@            }\n          }\n          object dResolvedSymbol {\n            def unapply(dresolvedSymbol: d.ResolvedSymbol): Option[s.SymbolInformation] = {\n              val d.ResolvedSymbol(dsymbol, ddenot) = dresolvedSymbol"
  }
]
[
  {
    "id" : "042748e7-3757-4e21-8709-c99bce97d9d5",
    "prId" : 7568,
    "prUrl" : "https://github.com/apache/kafka/pull/7568#pullrequestreview-305273025",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4fe15c9f-c467-4789-b2be-9f64d150319e",
        "parentId" : null,
        "authorId" : "4873aa72-3842-44ba-91a8-a59ea9830460",
        "body" : "Calling nextTokens with negative n would cause infinite loop.",
        "createdAt" : "2019-10-21T21:54:01Z",
        "updatedAt" : "2020-01-22T16:43:32Z",
        "lastEditedBy" : "4873aa72-3842-44ba-91a8-a59ea9830460",
        "tags" : [
        ]
      },
      {
        "id" : "ed029822-1057-4c49-9bb0-6a8bd25a9b81",
        "parentId" : "4fe15c9f-c467-4789-b2be-9f64d150319e",
        "authorId" : "145db0de-7396-4643-9a2c-9977e1c6219b",
        "body" : "~Added a check.~\r\n\r\nActually removed this method variant. See next comment.",
        "createdAt" : "2019-10-22T14:53:00Z",
        "updatedAt" : "2020-01-22T16:43:32Z",
        "lastEditedBy" : "145db0de-7396-4643-9a2c-9977e1c6219b",
        "tags" : [
        ]
      }
    ],
    "commit" : "f53e431b77355b9dba30f28e304cba13fef7d93c",
    "line" : 217,
    "diffHunk" : "@@ -1,1 +1174,1178 @@            int current = mark();\n            int start = mark();\n            for (int i = 0; i != n; ++i) {\n                if (!hasNext()) {\n                    rewindTo(start);"
  },
  {
    "id" : "df37a6a5-b16f-4eaf-a440-522697b0814a",
    "prId" : 7593,
    "prUrl" : "https://github.com/apache/kafka/pull/7593#pullrequestreview-307493253",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9c88a929-c26d-4e47-a0a4-29f6f21c44c3",
        "parentId" : null,
        "authorId" : "12b658fc-2aaf-48e9-ad8b-15fd33dc8321",
        "body" : "This function is true iff (the literal is consumed) and ((this is an embedded value) or (there is no next token)). The consume logic was already in place, and it semantically makes sense here, so I'm satisfied with that.\r\nThe second condition is new, and would cause a failure to consume if (we are not embedded) and (there was a next token). \r\n\r\nBecause the canConsume was successful, `nextToken` must then be null, and `hasNext()` defers to a length check on the string, and having a next token is equivalent to having remaining string contents.\r\nIt appears that the parser is embedded whenever it's not parsing the top-level string, and is embedded for all deeper recursive calls.\r\n\r\nThis condition overall will only trigger a failure to consume when we're on the top-level parse, and the token has extra data following it. This wasn't obvious to me from first reading, so I wonder how we can make this more clear. Maybe a comment like \"If there are tokens after the expected token, and we're on a top-level parse, fail to consume the token because it's malformed\".",
        "createdAt" : "2019-10-25T18:46:14Z",
        "updatedAt" : "2019-10-25T23:37:33Z",
        "lastEditedBy" : "12b658fc-2aaf-48e9-ad8b-15fd33dc8321",
        "tags" : [
        ]
      },
      {
        "id" : "c74f449c-9783-4019-b32a-1421e61211ca",
        "parentId" : "9c88a929-c26d-4e47-a0a4-29f6f21c44c3",
        "authorId" : "f1480a85-4082-46f9-89c6-fe7231733b83",
        "body" : "Yeah, this section was reworked so a top-level string like `\"true}\"` would parse correctly as the string `\"true}\"` as opposed to the boolean literal `true`. The special case for `embedded` was necessary since the substring `\"true}\"` in the string `\"{3: true}\"` should be parsed as the boolean `true` and the map end delimiter, as opposed to just the string `\"true}\"`.\r\n\r\nYou've convinced me to not only add a comment here detailing the intended functionality, but also a few more tests making sure that whitespace doesn't mess with the parsing of top-level booleans (it doesn't, but still good to add a test now to prevent regression).",
        "createdAt" : "2019-10-25T23:37:37Z",
        "updatedAt" : "2019-10-25T23:37:38Z",
        "lastEditedBy" : "f1480a85-4082-46f9-89c6-fe7231733b83",
        "tags" : [
        ]
      }
    ],
    "commit" : "d38391483b7f2c0ae8b0f794a0ce2f209d858176",
    "line" : 15,
    "diffHunk" : "@@ -1,1 +735,739 @@            //      a string. For example, the top-level string \"true}\" will be tokenized as the tokens \"true\" and\n            //      \"}\", but should ultimately be parsed as just the string \"true}\" instead of the boolean true.\n            if (embedded || !parser.hasNext()) {\n                return true;\n            }"
  },
  {
    "id" : "514e7330-5367-4300-8a11-bcb591d3c01c",
    "prId" : 7593,
    "prUrl" : "https://github.com/apache/kafka/pull/7593#pullrequestreview-307493300",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "302955ca-67e0-4d73-a72a-4fcc13cec13c",
        "parentId" : null,
        "authorId" : "12b658fc-2aaf-48e9-ad8b-15fd33dc8321",
        "body" : "Does this line produce an NPE without the previous guard?",
        "createdAt" : "2019-10-25T21:01:45Z",
        "updatedAt" : "2019-10-25T23:37:33Z",
        "lastEditedBy" : "12b658fc-2aaf-48e9-ad8b-15fd33dc8321",
        "tags" : [
        ]
      },
      {
        "id" : "fb113263-c23f-4f58-8ed1-730ab0820e29",
        "parentId" : "302955ca-67e0-4d73-a72a-4fcc13cec13c",
        "authorId" : "f1480a85-4082-46f9-89c6-fe7231733b83",
        "body" : "Yes, but there's one calling location and a null check is performed by that caller before invoking this method.",
        "createdAt" : "2019-10-25T23:37:55Z",
        "updatedAt" : "2019-10-25T23:37:55Z",
        "lastEditedBy" : "f1480a85-4082-46f9-89c6-fe7231733b83",
        "tags" : [
        ]
      }
    ],
    "commit" : "d38391483b7f2c0ae8b0f794a0ce2f209d858176",
    "line" : 172,
    "diffHunk" : "@@ -1,1 +1003,1007 @@\n    protected static List<Object> alignListEntriesWithSchema(Schema schema, List<Object> input) {\n        Schema valueSchema = schema.valueSchema();\n        List<Object> result = new ArrayList<>();\n        for (Object value : input) {"
  },
  {
    "id" : "56ac8a90-493a-470f-b04d-e1f09a4ebc25",
    "prId" : 7593,
    "prUrl" : "https://github.com/apache/kafka/pull/7593#pullrequestreview-307493307",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a96593ec-b306-455d-8115-840989e6637a",
        "parentId" : null,
        "authorId" : "12b658fc-2aaf-48e9-ad8b-15fd33dc8321",
        "body" : "Same as above.",
        "createdAt" : "2019-10-25T21:01:59Z",
        "updatedAt" : "2019-10-25T23:37:33Z",
        "lastEditedBy" : "12b658fc-2aaf-48e9-ad8b-15fd33dc8321",
        "tags" : [
        ]
      },
      {
        "id" : "e7e5f23b-61bc-4b71-b98d-8505835814d3",
        "parentId" : "a96593ec-b306-455d-8115-840989e6637a",
        "authorId" : "f1480a85-4082-46f9-89c6-fe7231733b83",
        "body" : "Same as above :)",
        "createdAt" : "2019-10-25T23:37:57Z",
        "updatedAt" : "2019-10-25T23:37:57Z",
        "lastEditedBy" : "f1480a85-4082-46f9-89c6-fe7231733b83",
        "tags" : [
        ]
      }
    ],
    "commit" : "d38391483b7f2c0ae8b0f794a0ce2f209d858176",
    "line" : 182,
    "diffHunk" : "@@ -1,1 +1013,1017 @@\n    protected static Map<Object, Object> alignMapKeysAndValuesWithSchema(Schema mapSchema, Map<Object, Object> input) {\n        Schema keySchema = mapSchema.keySchema();\n        Schema valueSchema = mapSchema.valueSchema();\n        Map<Object, Object> result = new LinkedHashMap<>();"
  }
]
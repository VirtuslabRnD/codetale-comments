[
  {
    "id" : "e18242d1-6591-4aff-ba02-04643f2743f0",
    "prId" : 8720,
    "prUrl" : "https://github.com/apache/kafka/pull/8720#pullrequestreview-419315156",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e5611e40-ee64-4400-af0a-81c3c5d992bb",
        "parentId" : null,
        "authorId" : "145db0de-7396-4643-9a2c-9977e1c6219b",
        "body" : "Let's avoid unnecessary blank lines.\r\n```suggestion\r\n```",
        "createdAt" : "2020-05-27T15:51:42Z",
        "updatedAt" : "2020-05-28T04:04:20Z",
        "lastEditedBy" : "145db0de-7396-4643-9a2c-9977e1c6219b",
        "tags" : [
        ]
      }
    ],
    "commit" : "1c4442fffdc3b163458bf42b7af29183062c636f",
    "line" : 135,
    "diffHunk" : "@@ -1,1 +133,137 @@\n        private final List<Future<RecordMetadata>> futures;\n\n        public ErrantRecordFuture(List<Future<RecordMetadata>> producerFutures) {\n            futures = producerFutures;"
  },
  {
    "id" : "4779b29e-59e7-40da-923b-546e7d7fb20d",
    "prId" : 8720,
    "prUrl" : "https://github.com/apache/kafka/pull/8720#pullrequestreview-419315156",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ce172adc-8c84-4fce-9ffb-2e974e4c630d",
        "parentId" : null,
        "authorId" : "145db0de-7396-4643-9a2c-9977e1c6219b",
        "body" : "Rather than have a list of futures, why not have a single `Future` delegate that is either a `CompletableFuture.allOf(...)` or a single feature? This makes the constructor a little more complex, but it would simplify all of the other methods tremendously since they merely have to delegate (except for `cancel()` and `isCancelled()`, which can stay the same:\r\n```suggestion\r\n        public ErrantRecordFuture(List<Future<RecordMetadata>> producerFutures) {\r\n            if (producerFutures == null || producerFutures.isEmpty()) {\r\n                future = CompletableFuture.completedFuture(null);\r\n            } else {\r\n                futures = CompletableFutures.allOf(producerFutures);\r\n            }\r\n        }\r\n```\r\nThis will make `get(long, TimeUnit)` behave more correctly by requiring that all futures complete within the stated time.",
        "createdAt" : "2020-05-27T16:00:06Z",
        "updatedAt" : "2020-05-28T04:04:20Z",
        "lastEditedBy" : "145db0de-7396-4643-9a2c-9977e1c6219b",
        "tags" : [
        ]
      }
    ],
    "commit" : "1c4442fffdc3b163458bf42b7af29183062c636f",
    "line" : 138,
    "diffHunk" : "@@ -1,1 +136,140 @@        public ErrantRecordFuture(List<Future<RecordMetadata>> producerFutures) {\n            futures = producerFutures;\n        }\n\n        public boolean cancel(boolean mayInterruptIfRunning) {"
  },
  {
    "id" : "58c4b0f1-7e94-430a-a10c-5a6f5087e864",
    "prId" : 8720,
    "prUrl" : "https://github.com/apache/kafka/pull/8720#pullrequestreview-419501284",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "76e68047-19c6-4587-bb07-0454f898edbb",
        "parentId" : null,
        "authorId" : "145db0de-7396-4643-9a2c-9977e1c6219b",
        "body" : "```suggestion\r\n        // Most of the records will be an internal sink record, but the task could potentially\r\n        // report modified or new records, so handle both cases\r\n        if (record instanceof InternalSinkRecord) {\r\n```",
        "createdAt" : "2020-05-27T19:01:37Z",
        "updatedAt" : "2020-05-28T04:04:20Z",
        "lastEditedBy" : "145db0de-7396-4643-9a2c-9977e1c6219b",
        "tags" : [
        ]
      }
    ],
    "commit" : "1c4442fffdc3b163458bf42b7af29183062c636f",
    "line" : 72,
    "diffHunk" : "@@ -1,1 +70,74 @@        // Most of the records will be an internal sink record, but the task could potentially\n        // report modified or new records, so handle both cases\n        if (record instanceof InternalSinkRecord) {\n            consumerRecord = ((InternalSinkRecord) record).originalRecord();\n        } else {"
  },
  {
    "id" : "b80b360b-1fc2-409f-9d9b-502cc5980a24",
    "prId" : 8720,
    "prUrl" : "https://github.com/apache/kafka/pull/8720#pullrequestreview-419548029",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "61db4c3b-98ae-48fd-b1d4-09b1e6c073b8",
        "parentId" : null,
        "authorId" : "145db0de-7396-4643-9a2c-9977e1c6219b",
        "body" : "How about clarifying this a bit:\r\n```suggestion\r\n            // Generate a new consumer record from the modified sink record. We prefer\r\n            // to send the original consumer record (pre-transformed) to the DLQ, \r\n            // but in this case we don't have one and send the potentially transformed\r\n            // record instead\r\n            String topic = record.topic();\r\n```",
        "createdAt" : "2020-05-27T19:44:44Z",
        "updatedAt" : "2020-05-28T04:04:20Z",
        "lastEditedBy" : "145db0de-7396-4643-9a2c-9977e1c6219b",
        "tags" : [
        ]
      }
    ],
    "commit" : "1c4442fffdc3b163458bf42b7af29183062c636f",
    "line" : 79,
    "diffHunk" : "@@ -1,1 +77,81 @@            // but in this case we don't have one and send the potentially transformed\n            // record instead\n            String topic = record.topic();\n            byte[] key = keyConverter.fromConnectData(topic, record.keySchema(), record.key());\n            byte[] value = valueConverter.fromConnectData(topic,"
  }
]
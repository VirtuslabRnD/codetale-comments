[
  {
    "id" : "5d8f515e-bcb9-4cf3-85f0-bcc413c9fbde",
    "prId" : 4855,
    "prUrl" : "https://github.com/apache/kafka/pull/4855#pullrequestreview-123564105",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6479bebc-7779-4cb5-97cc-9c1c7650a4ab",
        "parentId" : null,
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "Do we need this? Seems like the same signature as the parent.",
        "createdAt" : "2018-05-25T22:35:04Z",
        "updatedAt" : "2018-05-26T00:00:49Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      },
      {
        "id" : "ff288c30-c148-4889-97a2-9308456cb215",
        "parentId" : "6479bebc-7779-4cb5-97cc-9c1c7650a4ab",
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "It's weird, but doing this makes the method accessible in the `WorkerCoordinatorTest`, which it isn't otherwise because the test is in a different package from `AbstractCoordinator`. `WorkerCoordinator` can see the superclass's method because it is a subclass.",
        "createdAt" : "2018-05-25T23:34:31Z",
        "updatedAt" : "2018-05-26T00:00:49Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      },
      {
        "id" : "911222b4-2a2d-4e3c-9184-ce503d426c1b",
        "parentId" : "6479bebc-7779-4cb5-97cc-9c1c7650a4ab",
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "Makes sense.",
        "createdAt" : "2018-05-26T18:42:32Z",
        "updatedAt" : "2018-05-26T18:42:32Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      }
    ],
    "commit" : "c3fce0f22e8b12e03475212b2bf07e69bc230362",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +106,110 @@    // expose for tests\n    @Override\n    protected synchronized boolean ensureCoordinatorReady(final long timeoutMs) {\n        return super.ensureCoordinatorReady(timeoutMs);\n    }"
  },
  {
    "id" : "8ad59e2f-c15a-480d-82d4-e44053783772",
    "prId" : 6363,
    "prUrl" : "https://github.com/apache/kafka/pull/6363#pullrequestreview-222511189",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "98a69f0a-4e32-40da-9e40-f22b87853ced",
        "parentId" : null,
        "authorId" : "145db0de-7396-4643-9a2c-9977e1c6219b",
        "body" : "Nit: seems odd to have statics after member fields.",
        "createdAt" : "2019-03-26T01:16:43Z",
        "updatedAt" : "2019-05-17T01:31:30Z",
        "lastEditedBy" : "145db0de-7396-4643-9a2c-9977e1c6219b",
        "tags" : [
        ]
      },
      {
        "id" : "29206a94-75cc-4af5-9008-c1d98738b3f6",
        "parentId" : "98a69f0a-4e32-40da-9e40-f22b87853ced",
        "authorId" : "e77724e7-3db9-47d6-b4d8-a865b1d06edc",
        "body" : "In general, I'm not sure our checkstyle is very opinionated w.r.t to this order. Changed to bring EMPTY first. ",
        "createdAt" : "2019-04-16T00:19:14Z",
        "updatedAt" : "2019-05-17T01:31:30Z",
        "lastEditedBy" : "e77724e7-3db9-47d6-b4d8-a865b1d06edc",
        "tags" : [
        ]
      }
    ],
    "commit" : "eb1853d8040f29948c1b9e54f95c0c2400d5b66e",
    "line" : 386,
    "diffHunk" : "@@ -1,1 +374,378 @@    public static class ConnectorsAndTasks {\n        public static final ConnectorsAndTasks EMPTY =\n                new ConnectorsAndTasks(Collections.emptyList(), Collections.emptyList());\n\n        private final Collection<String> connectors;"
  },
  {
    "id" : "5d3c7777-4790-4863-adb0-3b2ae0fd8ce1",
    "prId" : 6363,
    "prUrl" : "https://github.com/apache/kafka/pull/6363#pullrequestreview-227547036",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0aa76553-4d6b-4f05-97ef-c102b129e102",
        "parentId" : null,
        "authorId" : "145db0de-7396-4643-9a2c-9977e1c6219b",
        "body" : "I think these fields will never be null based upon how it is currently used, but there are no asserts or checks to ensure there are no NPEs here. Is this intentional?",
        "createdAt" : "2019-03-26T01:31:27Z",
        "updatedAt" : "2019-05-17T01:31:30Z",
        "lastEditedBy" : "145db0de-7396-4643-9a2c-9977e1c6219b",
        "tags" : [
        ]
      },
      {
        "id" : "7c431233-a296-41e9-be66-5337f13c15b7",
        "parentId" : "0aa76553-4d6b-4f05-97ef-c102b129e102",
        "authorId" : "e77724e7-3db9-47d6-b4d8-a865b1d06edc",
        "body" : "I'll add a requirement in the constructor rather than here. ",
        "createdAt" : "2019-04-16T00:23:38Z",
        "updatedAt" : "2019-05-17T01:31:30Z",
        "lastEditedBy" : "e77724e7-3db9-47d6-b4d8-a865b1d06edc",
        "tags" : [
        ]
      },
      {
        "id" : "fb30a476-b3bc-4841-aecf-79bedcee9c48",
        "parentId" : "0aa76553-4d6b-4f05-97ef-c102b129e102",
        "authorId" : "e77724e7-3db9-47d6-b4d8-a865b1d06edc",
        "body" : "Added guard in the constructor",
        "createdAt" : "2019-04-17T04:39:04Z",
        "updatedAt" : "2019-05-17T01:31:30Z",
        "lastEditedBy" : "e77724e7-3db9-47d6-b4d8-a865b1d06edc",
        "tags" : [
        ]
      }
    ],
    "commit" : "eb1853d8040f29948c1b9e54f95c0c2400d5b66e",
    "line" : 565,
    "diffHunk" : "@@ -1,1 +553,557 @@            return worker.equals(that.worker) &&\n                    connectors.equals(that.connectors) &&\n                    tasks.equals(that.tasks);\n        }\n"
  },
  {
    "id" : "814462f3-ec58-431e-963d-d24b018de749",
    "prId" : 6363,
    "prUrl" : "https://github.com/apache/kafka/pull/6363#pullrequestreview-231253602",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "342f1046-2d1a-4a70-a6e0-ffc6e1a36c1a",
        "parentId" : null,
        "authorId" : "f4cc0a00-0225-4972-8b58-0b97edf58337",
        "body" : "Seems we are missing `COOPERATIVE` case here? seems like if we don't handle it here, that setting won't work and having that mode doesn't serve much purpose (even if we encourage people to just leave it in `COMPATIBLE` given expected low overhead generally)",
        "createdAt" : "2019-04-26T01:47:04Z",
        "updatedAt" : "2019-05-17T01:31:30Z",
        "lastEditedBy" : "f4cc0a00-0225-4972-8b58-0b97edf58337",
        "tags" : [
        ]
      },
      {
        "id" : "92cf59d9-5b5c-43a3-9bb1-2fc5318e46a1",
        "parentId" : "342f1046-2d1a-4a70-a6e0-ffc6e1a36c1a",
        "authorId" : "e77724e7-3db9-47d6-b4d8-a865b1d06edc",
        "body" : "Maybe you started reviewing when it hadn't been removed. As mentioned in a comment above, `COOPERATIVE` has been removed to reflect the KIP. ",
        "createdAt" : "2019-04-27T00:46:30Z",
        "updatedAt" : "2019-05-17T01:31:30Z",
        "lastEditedBy" : "e77724e7-3db9-47d6-b4d8-a865b1d06edc",
        "tags" : [
        ]
      }
    ],
    "commit" : "eb1853d8040f29948c1b9e54f95c0c2400d5b66e",
    "line" : 98,
    "diffHunk" : "@@ -1,1 +168,172 @@            case COMPATIBLE:\n                return IncrementalCooperativeConnectProtocol.metadataRequest(workerState);\n            default:\n                throw new IllegalStateException(\"Unknown Connect protocol compatibility mode \" + protocolCompatibility);\n        }"
  },
  {
    "id" : "fad766f5-dd6d-4d88-8e0b-4058e0b1f9b7",
    "prId" : 6363,
    "prUrl" : "https://github.com/apache/kafka/pull/6363#pullrequestreview-238179176",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "77c5fe28-fff6-4ffb-9542-b7c4f320954f",
        "parentId" : null,
        "authorId" : "f4cc0a00-0225-4972-8b58-0b97edf58337",
        "body" : "would any of this be better handled by dynamic dispatch rather than switch statements (for further extensibility)? not a huge deal, but given (at least in this case) it seems like we could dispatch to one of the `[X]ConnectProtocol` classes, i'm wondering if it avoids switch case hell and keeps the logic for each closer to related protocols and outside of otherwise more general logic. (this admittedly could have been done initially but not nearly as valuable with just one case...)",
        "createdAt" : "2019-04-26T01:59:34Z",
        "updatedAt" : "2019-05-17T01:31:30Z",
        "lastEditedBy" : "f4cc0a00-0225-4972-8b58-0b97edf58337",
        "tags" : [
        ]
      },
      {
        "id" : "224d308f-06d9-4d37-bc9c-d273a5895f50",
        "parentId" : "77c5fe28-fff6-4ffb-9542-b7c4f320954f",
        "authorId" : "145db0de-7396-4643-9a2c-9977e1c6219b",
        "body" : "Right, and that would be easier to unit test, too.",
        "createdAt" : "2019-05-02T06:20:00Z",
        "updatedAt" : "2019-05-17T01:31:30Z",
        "lastEditedBy" : "145db0de-7396-4643-9a2c-9977e1c6219b",
        "tags" : [
        ]
      },
      {
        "id" : "669e15f7-db64-4ae6-ac6d-04c6ed898f92",
        "parentId" : "77c5fe28-fff6-4ffb-9542-b7c4f320954f",
        "authorId" : "e77724e7-3db9-47d6-b4d8-a865b1d06edc",
        "body" : "Dynamic dispatch is not very easy or elegant here, because the protocol classes are effectively static classes (have only static methods) and we can't hold on to a reference on their instance and use inheritance effectively. I've moved the creation of `JoinGroupRequestProtocolCollection` in the protocols though, and now the `switch` block (which I also dislike compared to dynamic dispatch) is small. ",
        "createdAt" : "2019-05-16T05:02:43Z",
        "updatedAt" : "2019-05-17T01:31:31Z",
        "lastEditedBy" : "e77724e7-3db9-47d6-b4d8-a865b1d06edc",
        "tags" : [
        ]
      }
    ],
    "commit" : "eb1853d8040f29948c1b9e54f95c0c2400d5b66e",
    "line" : 93,
    "diffHunk" : "@@ -1,1 +163,167 @@        configSnapshot = configStorage.snapshot();\n        ExtendedWorkerState workerState = new ExtendedWorkerState(restUrl, configSnapshot.offset(), assignmentSnapshot);\n        switch (protocolCompatibility) {\n            case EAGER:\n                return ConnectProtocol.metadataRequest(workerState);"
  },
  {
    "id" : "fc8c5780-fe5e-4f7f-a0ef-0f0c2398646b",
    "prId" : 6363,
    "prUrl" : "https://github.com/apache/kafka/pull/6363#pullrequestreview-238576967",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "29290734-60d0-4ddb-9f64-18c75689ab15",
        "parentId" : null,
        "authorId" : "f4cc0a00-0225-4972-8b58-0b97edf58337",
        "body" : "This approach seems interesting -- we previously had this class handle this as immutable (the entire snapshot was left unchanged or entirely replaced). Do we actually need to mutate like we do here? A few lines down we do\r\n\r\n```\r\nassignmentSnapshot = newAssignment;\r\n```\r\n\r\nso main value here seems to be for the log statement a couple lines below.\r\n\r\nThe other value in mutating things in this block seems to be for `newAssignment`. But it's taking anything *left* in the old assignment and adding it to `newAssignment`. But I thought in the KIP we still reiterate to the member all assigned resources, so adding the old leftover ones seems redundant. Shouldn't the `newAssignment` already contain exactly what we want to update `assignmentSnapshot` with before we attempt any of these mutations?",
        "createdAt" : "2019-04-26T02:17:05Z",
        "updatedAt" : "2019-05-17T01:31:30Z",
        "lastEditedBy" : "f4cc0a00-0225-4972-8b58-0b97edf58337",
        "tags" : [
        ]
      },
      {
        "id" : "8598185c-0ebe-495e-b7e0-d55b1b4b9e6a",
        "parentId" : "29290734-60d0-4ddb-9f64-18c75689ab15",
        "authorId" : "e77724e7-3db9-47d6-b4d8-a865b1d06edc",
        "body" : "At this point I will avoid the risk of optimizations and will include this in the ticket that will revisit tuning of the new rebalancing code. Thanks!",
        "createdAt" : "2019-05-16T18:52:51Z",
        "updatedAt" : "2019-05-17T01:31:31Z",
        "lastEditedBy" : "e77724e7-3db9-47d6-b4d8-a865b1d06edc",
        "tags" : [
        ]
      }
    ],
    "commit" : "eb1853d8040f29948c1b9e54f95c0c2400d5b66e",
    "line" : 194,
    "diffHunk" : "@@ -1,1 +189,193 @@\n            if (assignmentSnapshot != null) {\n                assignmentSnapshot.connectors().removeAll(newAssignment.revokedConnectors());\n                assignmentSnapshot.tasks().removeAll(newAssignment.revokedTasks());\n                log.debug(\"After revocations snapshot of assignment: {}\", assignmentSnapshot);"
  },
  {
    "id" : "5738af95-67f8-4841-ae4c-da3fe5ca4d85",
    "prId" : 6363,
    "prUrl" : "https://github.com/apache/kafka/pull/6363#pullrequestreview-238572520",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1d8970e4-b677-4584-8b69-c26abe7c05c3",
        "parentId" : null,
        "authorId" : "f4cc0a00-0225-4972-8b58-0b97edf58337",
        "body" : "didn't notice earlier in review that we're making previously internal state mutable. seems to be used primarily by the assignors for identical logic. can we keep this internal state by pushing that logic into this class? i.e. some sort of `tryUpdateSnapshot(maxOffset)`?",
        "createdAt" : "2019-04-26T02:30:58Z",
        "updatedAt" : "2019-05-17T01:31:30Z",
        "lastEditedBy" : "f4cc0a00-0225-4972-8b58-0b97edf58337",
        "tags" : [
        ]
      },
      {
        "id" : "b2b0f591-aac3-4d94-b85b-8df0bf555ffc",
        "parentId" : "1d8970e4-b677-4584-8b69-c26abe7c05c3",
        "authorId" : "e77724e7-3db9-47d6-b4d8-a865b1d06edc",
        "body" : "I'll create a ticket for future refactoring to address this. ",
        "createdAt" : "2019-05-16T18:43:45Z",
        "updatedAt" : "2019-05-17T01:31:31Z",
        "lastEditedBy" : "e77724e7-3db9-47d6-b4d8-a865b1d06edc",
        "tags" : [
        ]
      }
    ],
    "commit" : "eb1853d8040f29948c1b9e54f95c0c2400d5b66e",
    "line" : 311,
    "diffHunk" : "@@ -1,1 +274,278 @@     */\n    public void configSnapshot(ClusterConfigState update) {\n        configSnapshot = update;\n    }\n"
  },
  {
    "id" : "186160a5-e858-44e9-8cde-28780a38f173",
    "prId" : 7771,
    "prUrl" : "https://github.com/apache/kafka/pull/7771#pullrequestreview-327051077",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d94f7e52-74e8-4f25-8476-c7a5217a9a52",
        "parentId" : null,
        "authorId" : "145db0de-7396-4643-9a2c-9977e1c6219b",
        "body" : "Thanks for improving the atomicity of clearing out the snapshot. However, IIUC the way this class is access by multiple threads means that the various places where `assignmentSnapshot` is read, the read may not be consistent and might result in a NPE. This line is the only place where `assignmentSnapshot` can be assigned to null after being not null, but that means other places where `assignmentSnapshot` is read could potentially produce a NPE. For example, `onJoinComplete(...)` (lines 197-199) does the following:\r\n```\r\n            if (assignmentSnapshot != null) {\r\n                assignmentSnapshot.connectors().removeAll(newAssignment.revokedConnectors());\r\n                assignmentSnapshot.tasks().removeAll(newAssignment.revokedTasks());\r\n```\r\nbut if the broker coordinator is lost after the first line but before the second or third lines, the latter would produce a NPE. I think there are a few such places, and it'd be good to make the `assignmentSnapshot` member volatile (to ensure proper read semantics for multiple threads) and to use local variables to ensure consistent reads of the snapshot.",
        "createdAt" : "2019-12-04T17:18:30Z",
        "updatedAt" : "2019-12-04T18:07:06Z",
        "lastEditedBy" : "145db0de-7396-4643-9a2c-9977e1c6219b",
        "tags" : [
        ]
      },
      {
        "id" : "c4ede66f-e2d7-405b-b57f-128ecf57412c",
        "parentId" : "d94f7e52-74e8-4f25-8476-c7a5217a9a52",
        "authorId" : "e77724e7-3db9-47d6-b4d8-a865b1d06edc",
        "body" : "Valid points. To be on the safe side I've made `assignmentSnapshot` volatile, and wherever it's used I'm using a local copy of the reference instead (`final ExtendedAssignment localAssignmentSnapshot = assignmentSnapshot`)\r\n\r\nTesting with faults while this PR builds. ",
        "createdAt" : "2019-12-04T18:14:16Z",
        "updatedAt" : "2019-12-04T18:14:16Z",
        "lastEditedBy" : "e77724e7-3db9-47d6-b4d8-a865b1d06edc",
        "tags" : [
        ]
      }
    ],
    "commit" : "a031894a59ce13839b6e5d54bf22152fc5640f88",
    "line" : 41,
    "diffHunk" : "@@ -1,1 +138,142 @@                                \"avoid running tasks while not being a member the group\", coordinatorDiscoveryTimeoutMs, localAssignmentSnapshot);\n                        listener.onRevoked(localAssignmentSnapshot.leader(), localAssignmentSnapshot.connectors(), localAssignmentSnapshot.tasks());\n                        assignmentSnapshot = null;\n                    }\n                }"
  }
]
[
  {
    "id" : "eb22efe0-25c3-4283-bb07-5143e3d1637f",
    "prId" : 4523,
    "prUrl" : "https://github.com/apache/kafka/pull/4523#pullrequestreview-93857321",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "64d9148b-71cc-4bf7-98d8-9eac182f94bc",
        "parentId" : null,
        "authorId" : "d905bbc8-359a-4ad8-a92a-b255422c038c",
        "body" : "I think this test will pass even without your change as you creating struct object using the same schema.",
        "createdAt" : "2018-02-04T11:01:06Z",
        "updatedAt" : "2018-02-14T16:42:27Z",
        "lastEditedBy" : "d905bbc8-359a-4ad8-a92a-b255422c038c",
        "tags" : [
        ]
      },
      {
        "id" : "0233cf85-7481-4094-8111-431d4cf67979",
        "parentId" : "64d9148b-71cc-4bf7-98d8-9eac182f94bc",
        "authorId" : "32d43f1c-0232-4c2f-9548-9c3dfd6f181a",
        "body" : "@bartektartanus Isn't that the purpose of this test? To create a scenario in which a struct and schema is passed to JsonConverter#convertToJson()?",
        "createdAt" : "2018-02-04T16:38:59Z",
        "updatedAt" : "2018-02-14T16:42:27Z",
        "lastEditedBy" : "32d43f1c-0232-4c2f-9548-9c3dfd6f181a",
        "tags" : [
        ]
      },
      {
        "id" : "71d788e0-88ec-4287-b6ef-7716a55dbf72",
        "parentId" : "64d9148b-71cc-4bf7-98d8-9eac182f94bc",
        "authorId" : "d905bbc8-359a-4ad8-a92a-b255422c038c",
        "body" : "Yes, but you are passing the same schema in the same OBJECT. So comparing them using == will return true. In my case the schema and schema in struct are the same (equal) but in different objects, co equals method returns true, but == returns false. \r\nWhile this test might be useful, it does not cover the change you are making here.",
        "createdAt" : "2018-02-04T20:44:31Z",
        "updatedAt" : "2018-02-14T16:42:27Z",
        "lastEditedBy" : "d905bbc8-359a-4ad8-a92a-b255422c038c",
        "tags" : [
        ]
      }
    ],
    "commit" : "29d4c7179d837711722a945b6dc2a28543c3ee03",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +565,569 @@\n    @Test\n    public void structSchemaIdentical() {\n        Schema schema = SchemaBuilder.struct().field(\"field1\", Schema.BOOLEAN_SCHEMA)\n                                              .field(\"field2\", Schema.STRING_SCHEMA)"
  },
  {
    "id" : "3c00ea5e-0538-4339-83d1-1e3b6817bf79",
    "prId" : 7354,
    "prUrl" : "https://github.com/apache/kafka/pull/7354#pullrequestreview-295856310",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "55c58712-3403-48cf-a61c-9bda2eb86848",
        "parentId" : null,
        "authorId" : "145db0de-7396-4643-9a2c-9977e1c6219b",
        "body" : "IIUC, the only existing test for deserializing a JSON float verified this only for the schema case, and there was no test that verified the behavior for the no schema case.\r\n\r\nWhat do you think about adding more unit tests that check serialization and deserialization for all of the Connect data types?",
        "createdAt" : "2019-10-01T19:19:26Z",
        "updatedAt" : "2019-10-01T20:16:50Z",
        "lastEditedBy" : "145db0de-7396-4643-9a2c-9977e1c6219b",
        "tags" : [
        ]
      },
      {
        "id" : "bcf94a57-57f7-4375-99d7-f703c40ae947",
        "parentId" : "55c58712-3403-48cf-a61c-9bda2eb86848",
        "authorId" : "c1d8c456-76f0-40c1-8f33-97bb2067c9ea",
        "body" : "It looks like we have tests for all of the primitive types (e.g. `floatToConnect` for the schema case and `nullSchemaPrimitiveToConnect` for the schemaless test). I hope those would be sufficient to catch any regression there.\r\n\r\nTo be safe, I've also made sure that only the JsonConverter uses the new deserializer feature to deserialize floats big decimals.",
        "createdAt" : "2019-10-01T19:59:25Z",
        "updatedAt" : "2019-10-01T20:16:50Z",
        "lastEditedBy" : "c1d8c456-76f0-40c1-8f33-97bb2067c9ea",
        "tags" : [
        ]
      }
    ],
    "commit" : "c9e3db9b265141feec7eb47c0aadd7f5f100e1ac",
    "line" : 12,
    "diffHunk" : "@@ -1,1 +254,258 @@    }\n\n    @Test\n    public void numericDecimalToConnect() {\n        BigDecimal reference = new BigDecimal(new BigInteger(\"156\"), 2);"
  }
]
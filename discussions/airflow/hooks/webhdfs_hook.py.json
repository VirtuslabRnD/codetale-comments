[
  {
    "id" : "6d8ca89e-3d04-4bd9-9da8-fcb7a5d969d2",
    "prId" : 604,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "43e8e696-4b24-4420-8369-d63604d50d40",
        "parentId" : null,
        "authorId" : "0624866b-ba3a-41a3-abab-e487a9cfb78c",
        "body" : "Are we expecting namenodes to fail often? I guess since it's a sensor we don't want to have a loose trigger, the downside is silencing legit errors  (say if the configuration refers to a deprecated node we might never figure it out)\n",
        "createdAt" : "2015-11-06T16:08:34Z",
        "updatedAt" : "2015-11-06T19:51:14Z",
        "lastEditedBy" : "0624866b-ba3a-41a3-abab-e487a9cfb78c",
        "tags" : [
        ]
      },
      {
        "id" : "bc56db1e-b94c-4029-9e85-942180b118b0",
        "parentId" : "43e8e696-4b24-4420-8369-d63604d50d40",
        "authorId" : "0ff67aea-e186-487e-bd0f-83d1c809bd31",
        "body" : "Not necessarily. It is a poor man's High Availability client so that we can enter a list of the namenodes (primary and secondary) in the connections. It only raises if all the namenodes with that connection ID fail. Are you suggesting we cache it and then rescue the specific error and retry with another namenode in the list if needed?\n",
        "createdAt" : "2015-11-06T17:50:01Z",
        "updatedAt" : "2015-11-06T19:51:14Z",
        "lastEditedBy" : "0ff67aea-e186-487e-bd0f-83d1c809bd31",
        "tags" : [
        ]
      },
      {
        "id" : "b8604fc1-f2fb-4e68-8a0f-79a3f1982362",
        "parentId" : "43e8e696-4b24-4420-8369-d63604d50d40",
        "authorId" : "0624866b-ba3a-41a3-abab-e487a9cfb78c",
        "body" : "Don't bother that's fine as is\n",
        "createdAt" : "2015-11-06T19:54:11Z",
        "updatedAt" : "2015-11-06T19:54:11Z",
        "lastEditedBy" : "0624866b-ba3a-41a3-abab-e487a9cfb78c",
        "tags" : [
        ]
      }
    ],
    "commit" : "29747f0ec1e40a11de273fa79bf6848672ece3ae",
    "line" : 34,
    "diffHunk" : "@@ -1,1 +32,36 @@        nn_connections = self.get_connections(self.webhdfs_conn_id)\n        for nn in nn_connections:\n            try:\n                logging.debug('Trying namenode {}'.format(nn.host))\n                connection_str = 'http://{nn.host}:{nn.port}'.format(nn=nn)"
  },
  {
    "id" : "dd12bf5d-66e2-41b0-a7ca-a19cd2419e5e",
    "prId" : 942,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3f776ffa-a16d-42ef-a470-bab3d8445381",
        "parentId" : null,
        "authorId" : "0624866b-ba3a-41a3-abab-e487a9cfb78c",
        "body" : "I'm not familiar with the lib, what is this change about?\n",
        "createdAt" : "2016-02-07T21:31:14Z",
        "updatedAt" : "2016-02-07T21:31:14Z",
        "lastEditedBy" : "0624866b-ba3a-41a3-abab-e487a9cfb78c",
        "tags" : [
        ]
      },
      {
        "id" : "7b0755c9-f276-4354-bd9e-570dea8ac135",
        "parentId" : "3f776ffa-a16d-42ef-a470-bab3d8445381",
        "authorId" : "5072f48b-89ba-478e-9107-e61ee2ebc916",
        "body" : "As I understand, the content method is called to check if the namenode is valid, but it fails also on current airflow, if the task is run as any user != hdfs, while the status method will not, so I think that calling status is better for checking the namenode validity.\nThe other change is for adding the \"doAs\" also to the hdfs client.\n",
        "createdAt" : "2016-02-07T22:20:49Z",
        "updatedAt" : "2016-02-07T22:20:49Z",
        "lastEditedBy" : "5072f48b-89ba-478e-9107-e61ee2ebc916",
        "tags" : [
        ]
      }
    ],
    "commit" : "9a3a75547db61937ccdc1e28011af0cf6cf070ec",
    "line" : 19,
    "diffHunk" : "@@ -1,1 +41,45 @@                  proxy_user = self.proxy_user or nn.login\n                  client = InsecureClient(connection_str, user=proxy_user)\n                client.status('/')\n                logging.debug('Using namenode {} for hook'.format(nn.host))\n                return client"
  }
]
[
  {
    "id" : "21dc4ef9-18a0-4be2-8a02-c276638f10c3",
    "prId" : 5920,
    "prUrl" : "https://github.com/apache/kafka/pull/5920#pullrequestreview-335463773",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d132b443-e877-4799-93f1-0db26f58900f",
        "parentId" : null,
        "authorId" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "body" : "Are we testing the SSL in the test? It seems that the security protocol is always plaintext.",
        "createdAt" : "2019-02-21T22:32:40Z",
        "updatedAt" : "2020-01-12T16:09:00Z",
        "lastEditedBy" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "tags" : [
        ]
      },
      {
        "id" : "60380661-9d4b-47cb-ba42-0463c41669fe",
        "parentId" : "d132b443-e877-4799-93f1-0db26f58900f",
        "authorId" : "b4936a15-698a-496e-85a1-b1e229b4986b",
        "body" : "We have `SslSelectorTest` that extends this class, so all the tests are run with PLAINTEXT and SSL.",
        "createdAt" : "2019-12-20T19:05:57Z",
        "updatedAt" : "2020-01-12T16:09:00Z",
        "lastEditedBy" : "b4936a15-698a-496e-85a1-b1e229b4986b",
        "tags" : [
        ]
      }
    ],
    "commit" : "aa849a468dc6e5e693bdeeb9625678db4102e84a",
    "line" : 138,
    "diffHunk" : "@@ -1,1 +546,550 @@     * For PLAINTEXT, pending receives are always read from socket without any buffering, so this\n     * test is only verifying that channels are not expired while there is data to read from socket.\n     * For SSL, pending receives may also be in SSL netReadBuffer or appReadBuffer. So the test verifies\n     * that connection is not expired when data is available from buffers or network.\n     */"
  },
  {
    "id" : "44529f77-23c6-45e2-a047-39b4e4bbb22e",
    "prId" : 5920,
    "prUrl" : "https://github.com/apache/kafka/pull/5920#pullrequestreview-335465297",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e1356d25-378f-4836-b8e4-9031009fb1ae",
        "parentId" : null,
        "authorId" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "body" : "I guess the reason that we don't know the exact ReceiveCountAfterClose is that we don't know how much data is in the socket buffer when we close the connections on the server. But how do we guarantee that we always have at least 5 receives?",
        "createdAt" : "2019-02-21T22:42:52Z",
        "updatedAt" : "2020-01-12T16:09:00Z",
        "lastEditedBy" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "tags" : [
        ]
      },
      {
        "id" : "df52112e-59af-49aa-8d77-352e088423ce",
        "parentId" : "e1356d25-378f-4836-b8e4-9031009fb1ae",
        "authorId" : "b4936a15-698a-496e-85a1-b1e229b4986b",
        "body" : "The loop above retries until we have at least 5 but limits the number of retries to 100, so this is checking that it worked within that retry limit.",
        "createdAt" : "2019-12-20T19:09:26Z",
        "updatedAt" : "2020-01-12T16:09:00Z",
        "lastEditedBy" : "b4936a15-698a-496e-85a1-b1e229b4986b",
        "tags" : [
        ]
      }
    ],
    "commit" : "aa849a468dc6e5e693bdeeb9625678db4102e84a",
    "line" : 198,
    "diffHunk" : "@@ -1,1 +596,600 @@            maxReceiveCountAfterClose = Math.max(maxReceiveCountAfterClose, receiveCount);\n        }\n        assertTrue(\"Too few receives after close: \" + maxReceiveCountAfterClose, maxReceiveCountAfterClose >= 5);\n    }\n"
  },
  {
    "id" : "f3db6a24-f94c-4bbf-9f70-d69e2e2b6f7c",
    "prId" : 5920,
    "prUrl" : "https://github.com/apache/kafka/pull/5920#pullrequestreview-341584409",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e8381f16-381d-4e96-861f-309e8292ff9b",
        "parentId" : null,
        "authorId" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "body" : "Hmm, where is the logic to close the connection?",
        "createdAt" : "2020-01-09T19:42:22Z",
        "updatedAt" : "2020-01-12T16:09:00Z",
        "lastEditedBy" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "tags" : [
        ]
      },
      {
        "id" : "9bf47bda-be9d-4890-a0bc-c6c1958805cb",
        "parentId" : "e8381f16-381d-4e96-861f-309e8292ff9b",
        "authorId" : "b4936a15-698a-496e-85a1-b1e229b4986b",
        "body" : "We update the mock time above and expect the channel to be closed due to idle timeout.",
        "createdAt" : "2020-01-12T16:10:55Z",
        "updatedAt" : "2020-01-12T16:10:55Z",
        "lastEditedBy" : "b4936a15-698a-496e-85a1-b1e229b4986b",
        "tags" : [
        ]
      }
    ],
    "commit" : "aa849a468dc6e5e693bdeeb9625678db4102e84a",
    "line" : 151,
    "diffHunk" : "@@ -1,1 +557,561 @@        while (selector.disconnected().isEmpty()) {\n            time.sleep(6000); // The max idle time is 5000ms\n            selector.poll(completedReceives == expectedReceives ? 0 : 1000);\n            completedReceives += selector.completedReceives().size();\n            if (!selector.completedReceives().isEmpty()) {"
  }
]
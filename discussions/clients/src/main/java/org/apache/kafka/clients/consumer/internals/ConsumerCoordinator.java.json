[
  {
    "id" : "6671866e-3f4c-4d12-a9fe-4afb289ff7cc",
    "prId" : 4326,
    "prUrl" : "https://github.com/apache/kafka/pull/4326#pullrequestreview-148319429",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3ae1a272-160a-4ff8-a15b-31fbbec3e16a",
        "parentId" : null,
        "authorId" : "3e414f4e-e846-4984-a05e-2537617c5141",
        "body" : "This modification can lead to repeated commit offset because of nextAutoCommitDeadline has not increased. Could someone tell me this is normal or correct me if I am wrong",
        "createdAt" : "2018-08-22T03:03:44Z",
        "updatedAt" : "2018-08-22T03:18:45Z",
        "lastEditedBy" : "3e414f4e-e846-4984-a05e-2537617c5141",
        "tags" : [
        ]
      }
    ],
    "commit" : "d5426e18c6c8136578819b36e66bc663a547ddf5",
    "line" : 26,
    "diffHunk" : "@@ -1,1 +626,630 @@\n    public void maybeAutoCommitOffsetsAsync(long now) {\n        if (autoCommitEnabled && now >= nextAutoCommitDeadline) {\n            doAutoCommitOffsetsAsync();\n        }"
  },
  {
    "id" : "2c32c672-16f3-4724-85f4-6219736b1433",
    "prId" : 4855,
    "prUrl" : "https://github.com/apache/kafka/pull/4855#pullrequestreview-123424401",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b4454c7d-ce3f-46d3-8221-e0616abd7305",
        "parentId" : null,
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "Same comment as before. We can skip the time system calls by passing the current time since the common case is that no work needs to be done here.",
        "createdAt" : "2018-05-25T16:37:44Z",
        "updatedAt" : "2018-05-26T00:00:49Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      }
    ],
    "commit" : "c3fce0f22e8b12e03475212b2bf07e69bc230362",
    "line" : 62,
    "diffHunk" : "@@ -1,1 +302,306 @@     * @return true iff the operation succeeded\n     */\n    public boolean poll(final long timeoutMs) {\n        final long startTime = time.milliseconds();\n        long elapsed = 0L;"
  },
  {
    "id" : "f3b31834-794f-4e57-b4a8-d406a4d40eff",
    "prId" : 4855,
    "prUrl" : "https://github.com/apache/kafka/pull/4855#pullrequestreview-123564019",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a5b43e6d-ff28-4c3d-b1e4-f065329ee250",
        "parentId" : null,
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "I guess it's tough to avoid blocking here. All of this would be considerably easier if we moved the rebalance to the background thread. Another improvement for another time.",
        "createdAt" : "2018-05-26T18:37:58Z",
        "updatedAt" : "2018-05-26T18:38:50Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      }
    ],
    "commit" : "c3fce0f22e8b12e03475212b2bf07e69bc230362",
    "line" : 139,
    "diffHunk" : "@@ -1,1 +395,399 @@        // update metadata (if needed) and keep track of the metadata used for assignment so that\n        // we can check after rebalance completion whether anything has changed\n        if (!client.ensureFreshMetadata(Long.MAX_VALUE)) throw new TimeoutException();\n\n        isLeader = true;"
  },
  {
    "id" : "06b15bbc-788d-4672-a79a-69786d7430d7",
    "prId" : 4855,
    "prUrl" : "https://github.com/apache/kafka/pull/4855#pullrequestreview-124078456",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "31947692-17b7-4eee-a83e-d5c329f4b07a",
        "parentId" : null,
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "The names here are a bit misleading, maybe we can fix them in https://github.com/apache/kafka/pull/5087? cc @hachikuji . I'm thinking `requestedPartitions` and `requestedGeneration`?",
        "createdAt" : "2018-05-29T16:46:07Z",
        "updatedAt" : "2018-05-29T16:49:07Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      }
    ],
    "commit" : "c3fce0f22e8b12e03475212b2bf07e69bc230362",
    "line" : 16,
    "diffHunk" : "@@ -1,1 +92,96 @@\n    private static class PendingCommittedOffsetRequest {\n        private final Set<TopicPartition> request;\n        private final Generation generation;\n        private final RequestFuture<Map<TopicPartition, OffsetAndMetadata>> response;"
  },
  {
    "id" : "7494aeb2-15f7-44d5-b62b-0025b58018ec",
    "prId" : 4855,
    "prUrl" : "https://github.com/apache/kafka/pull/4855#pullrequestreview-124078456",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5dc8b301-9597-48fd-aa43-bd7436488175",
        "parentId" : null,
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "We have three `remainingTimeAtLeastZero` functions, in AbstractCoordinator, ConsumerCoordinator and KafkaConsumer. Is it intentional? If not we could leave just one to avoid unintentional code divergence in the future. cc @vvcephei ",
        "createdAt" : "2018-05-29T16:48:02Z",
        "updatedAt" : "2018-05-29T16:49:07Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      }
    ],
    "commit" : "c3fce0f22e8b12e03475212b2bf07e69bc230362",
    "line" : 124,
    "diffHunk" : "@@ -1,1 +353,357 @@    }\n\n    private long remainingTimeAtLeastZero(final long timeoutMs, final long elapsed) {\n        return Math.max(0, timeoutMs - elapsed);\n    }"
  },
  {
    "id" : "670d5218-ca8e-4d7d-896c-86e07563fda2",
    "prId" : 5084,
    "prUrl" : "https://github.com/apache/kafka/pull/5084#pullrequestreview-124594426",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3f45efaf-3fcf-4fe2-848e-1319f311c025",
        "parentId" : null,
        "authorId" : "cb6f8432-d515-4113-87f8-14e555ab8ed1",
        "body" : "Do you need this currentTime because `ensureCoordinatorReady`, `ensureFreshMetadata` and `ensureActiveGroup` are somewhat long-running?",
        "createdAt" : "2018-05-30T12:46:17Z",
        "updatedAt" : "2018-05-30T21:46:19Z",
        "lastEditedBy" : "cb6f8432-d515-4113-87f8-14e555ab8ed1",
        "tags" : [
        ]
      },
      {
        "id" : "3f4baa31-4dbf-4e6c-bcdf-66cb6eba712f",
        "parentId" : "3f45efaf-3fcf-4fe2-848e-1319f311c025",
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "Yes, right. I think the approach in #5087 is less irritating.",
        "createdAt" : "2018-05-30T21:10:00Z",
        "updatedAt" : "2018-05-30T21:46:19Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      }
    ],
    "commit" : "ea9fe01ef54c446cfddb36fba41218d989f6e275",
    "line" : 52,
    "diffHunk" : "@@ -1,1 +301,305 @@    public boolean poll(final long timeoutMs) {\n        final long startTime = time.milliseconds();\n        long currentTime = startTime;\n        long elapsed = 0L;\n"
  },
  {
    "id" : "e69ac94f-83b3-4c96-a54f-19a6dcc0eddf",
    "prId" : 5087,
    "prUrl" : "https://github.com/apache/kafka/pull/5087#pullrequestreview-142907077",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6b56544b-2b88-45dd-bccf-509f42be0850",
        "parentId" : null,
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "Nice catch :)",
        "createdAt" : "2018-08-02T18:43:50Z",
        "updatedAt" : "2018-08-03T20:47:50Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      }
    ],
    "commit" : "0ef469881a5e14aecbaa3dbe890d30335c2c75a8",
    "line" : 31,
    "diffHunk" : "@@ -1,1 +280,284 @@\n        // reschedule the auto commit starting from now\n        if (autoCommitEnabled)\n            this.nextAutoCommitTimer.updateAndReset(autoCommitIntervalMs);\n"
  },
  {
    "id" : "9857f9c6-e03a-4705-918d-ea4cb3e1a110",
    "prId" : 5087,
    "prUrl" : "https://github.com/apache/kafka/pull/5087#pullrequestreview-143260988",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3a3d5d43-ed7a-45ba-b732-8fe939773a64",
        "parentId" : null,
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "Why changing `if` to a `while`, and also add a `client.poll()`? ",
        "createdAt" : "2018-08-02T19:05:46Z",
        "updatedAt" : "2018-08-03T20:47:50Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "5d8d0bc6-ebd6-43f0-99a6-483b741dc061",
        "parentId" : "3a3d5d43-ed7a-45ba-b732-8fe939773a64",
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "I think the point of this check was to allow some time for pending async commits to return, but the previous code seemed a little bizarre. What was the point of ensuring the coordinator is ready and then immediately closing?  It made more sense to turn this into a loop and call `poll` so that we could give the OffsetCommit responses a chance to be delivered.",
        "createdAt" : "2018-08-02T20:18:49Z",
        "updatedAt" : "2018-08-03T20:47:50Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      },
      {
        "id" : "328e1433-ff8c-4206-ba7a-3b1c1ecd8d28",
        "parentId" : "3a3d5d43-ed7a-45ba-b732-8fe939773a64",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "makes sense.",
        "createdAt" : "2018-08-03T17:04:41Z",
        "updatedAt" : "2018-08-03T20:47:50Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      }
    ],
    "commit" : "0ef469881a5e14aecbaa3dbe890d30335c2c75a8",
    "line" : 247,
    "diffHunk" : "@@ -1,1 +556,560 @@        try {\n            maybeAutoCommitOffsetsSync(timer);\n            while (pendingAsyncCommits.get() > 0 && timer.notExpired()) {\n                ensureCoordinatorReady(timer);\n                client.poll(timer);"
  },
  {
    "id" : "2f3e5809-86f4-4c01-8ec2-9b2b3b4d83ab",
    "prId" : 6778,
    "prUrl" : "https://github.com/apache/kafka/pull/6778#pullrequestreview-246331886",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "99740ebf-c2ac-4c46-bb7f-3eba8d06de4b",
        "parentId" : null,
        "authorId" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "body" : "Is this a possible state?",
        "createdAt" : "2019-05-26T21:02:52Z",
        "updatedAt" : "2019-06-19T00:38:37Z",
        "lastEditedBy" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "tags" : [
        ]
      },
      {
        "id" : "d442b690-8600-4a73-8b3a-8f695e2b0a75",
        "parentId" : "99740ebf-c2ac-4c46-bb7f-3eba8d06de4b",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "This is not possible state, and hence I'm logging a WARN. I can also just throw an exception actually.",
        "createdAt" : "2019-06-06T01:43:21Z",
        "updatedAt" : "2019-06-19T00:38:37Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      }
    ],
    "commit" : "8440e7defc7a3b3c0fa6c378969b33035ad1a21d",
    "line" : 67,
    "diffHunk" : "@@ -1,1 +297,301 @@        switch (protocol) {\n            case EAGER:\n                if (!ownedPartitions.isEmpty()) {\n                    log.info(\"Coordinator has owned partitions {} that are not revoked with {} protocol, \" +\n                        \"it is likely client is woken up before a previous pending rebalance completes its callback\", ownedPartitions, protocol);"
  },
  {
    "id" : "e52162c2-cbda-451c-a6de-81de8171f84f",
    "prId" : 6778,
    "prUrl" : "https://github.com/apache/kafka/pull/6778#pullrequestreview-251391867",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "806cc832-eaf8-4b18-9a89-3891903eb153",
        "parentId" : null,
        "authorId" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "body" : "Slight readability improvement: could we factor this into a method, maybe #assignPartitions? We could also then have just #revokePartitions and the cooperative case could call both -- this way it's immediately clear what each protocol does/how they differ",
        "createdAt" : "2019-06-13T05:29:35Z",
        "updatedAt" : "2019-06-19T00:38:37Z",
        "lastEditedBy" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "tags" : [
        ]
      },
      {
        "id" : "595a8e9c-e47f-4bef-bf95-ce46d7379830",
        "parentId" : "806cc832-eaf8-4b18-9a89-3891903eb153",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "I tried to update it in the way you suggested, but it turns out a bit tricky since for some cases we do want to update the owned-partitions state if COOPERATIVE is used, while for some others we do not rely on the protocol to decide if the owned partitions would be revoked or not..",
        "createdAt" : "2019-06-18T21:59:10Z",
        "updatedAt" : "2019-06-19T00:38:37Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "2ad5ea9f-abd8-45a1-a9de-90df95a9623c",
        "parentId" : "806cc832-eaf8-4b18-9a89-3891903eb153",
        "authorId" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "body" : "I agree you'd have to factor out the logic of what exactly is being revoked/assigned into the switch statement and then call assign/revoke on the appropriate set of partitions. Might be worth doing if we add another protocol but for now it's not that important",
        "createdAt" : "2019-06-18T22:19:51Z",
        "updatedAt" : "2019-06-19T00:38:37Z",
        "lastEditedBy" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "tags" : [
        ]
      }
    ],
    "commit" : "8440e7defc7a3b3c0fa6c378969b33035ad1a21d",
    "line" : 66,
    "diffHunk" : "@@ -1,1 +296,300 @@\n        switch (protocol) {\n            case EAGER:\n                if (!ownedPartitions.isEmpty()) {\n                    log.info(\"Coordinator has owned partitions {} that are not revoked with {} protocol, \" +"
  },
  {
    "id" : "18b6357e-a0f7-4a7d-8786-1026dd3cc06c",
    "prId" : 6778,
    "prUrl" : "https://github.com/apache/kafka/pull/6778#pullrequestreview-252949891",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "81d0404e-6608-478d-901c-9749007a4fae",
        "parentId" : null,
        "authorId" : "4c968502-bb3d-46ee-8719-0c0bdbc6242f",
        "body" : "Did this slip? Seems it should be a `WARN` as you said above.",
        "createdAt" : "2019-06-21T16:09:46Z",
        "updatedAt" : "2019-06-21T17:26:03Z",
        "lastEditedBy" : "4c968502-bb3d-46ee-8719-0c0bdbc6242f",
        "tags" : [
        ]
      },
      {
        "id" : "f00928f2-eb9e-4fb4-a8d1-4ef00ede7802",
        "parentId" : "81d0404e-6608-478d-901c-9749007a4fae",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "I originally make it an exception since it should not happen, but later in unit test I realized it could normally happen if we have a wakeup exception during rebalance listener call, and therefore I change it to INFO",
        "createdAt" : "2019-06-21T17:42:33Z",
        "updatedAt" : "2019-06-21T17:42:33Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      }
    ],
    "commit" : "8440e7defc7a3b3c0fa6c378969b33035ad1a21d",
    "line" : 68,
    "diffHunk" : "@@ -1,1 +298,302 @@            case EAGER:\n                if (!ownedPartitions.isEmpty()) {\n                    log.info(\"Coordinator has owned partitions {} that are not revoked with {} protocol, \" +\n                        \"it is likely client is woken up before a previous pending rebalance completes its callback\", ownedPartitions, protocol);\n                }"
  },
  {
    "id" : "828157a0-fc6f-4fde-9270-0f2d90a7c6a1",
    "prId" : 6778,
    "prUrl" : "https://github.com/apache/kafka/pull/6778#pullrequestreview-254940879",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "85510e07-ef70-4b6b-b34b-36f0fbfecc02",
        "parentId" : null,
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "Won't this break in the `switch` below? Am I missing something?",
        "createdAt" : "2019-06-24T23:14:50Z",
        "updatedAt" : "2019-06-24T23:14:50Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      },
      {
        "id" : "4ce03f2e-d153-4f49-95b2-f0edb965909f",
        "parentId" : "85510e07-ef70-4b6b-b34b-36f0fbfecc02",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "We have a check at the beginning of `ConsumerCoordinator.poll`:\r\n\r\n```\r\n            if (protocol == null) {\r\n                throw new IllegalStateException(\"User confingure ConsumerConfig#PARTITION_ASSIGNMENT_STRATEGY_CONFIG to empty \" +\r\n                    \"while trying to subscribe for group protocol to auto assign partitions\");\r\n            }\r\n```\r\n\r\nBasically if user does not call `subscribe()` it is okay to not set the protocol at all; otherwise we will throw error.",
        "createdAt" : "2019-06-26T16:07:11Z",
        "updatedAt" : "2019-06-26T16:07:11Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "4d4cf2e9-5fb0-4b39-a623-3a09cd8db710",
        "parentId" : "85510e07-ef70-4b6b-b34b-36f0fbfecc02",
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "Ok. We also have a check in `subscribe` to ensure that the set of assignors is not empty. There might be a way to remove the redundant checking.\r\n\r\nBy the way, there's a typo above: `confingure`.",
        "createdAt" : "2019-06-26T19:56:13Z",
        "updatedAt" : "2019-06-26T19:56:14Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      },
      {
        "id" : "23bb15eb-3caf-499d-9bf5-f2ac63dc06d3",
        "parentId" : "85510e07-ef70-4b6b-b34b-36f0fbfecc02",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "Ack.",
        "createdAt" : "2019-06-27T00:17:50Z",
        "updatedAt" : "2019-06-27T00:17:51Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "51837c0d-745e-47ca-9aec-aa20d7dd0640",
        "parentId" : "85510e07-ef70-4b6b-b34b-36f0fbfecc02",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "Yeah I think we can indeed remove it:\r\n\r\n1. if no assignors specified, then `subscribe` will throw.\r\n2. if assignors specified but no common supported protocol, then constructor will throw.",
        "createdAt" : "2019-06-27T00:20:12Z",
        "updatedAt" : "2019-06-27T00:20:12Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      }
    ],
    "commit" : "8440e7defc7a3b3c0fa6c378969b33035ad1a21d",
    "line" : 44,
    "diffHunk" : "@@ -1,1 +185,189 @@            protocol = supportedProtocols.get(supportedProtocols.size() - 1);\n        } else {\n            protocol = null;\n        }\n"
  },
  {
    "id" : "a733c77b-6868-4df7-91dd-0767f17f6708",
    "prId" : 6778,
    "prUrl" : "https://github.com/apache/kafka/pull/6778#pullrequestreview-254941229",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "219173cb-ec22-421d-9a55-1d9effa9a2ea",
        "parentId" : null,
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "nit: since we're not doing anything in the EAGER case, couldn't we simplify this:\r\n```java\r\nif (protocol == COOPERATIVE)\r\n  adjustAssignment(ownedPartitions, assignments)\r\n```\r\n\r\nSimilarly in `onJoinPrepare`",
        "createdAt" : "2019-06-24T23:26:45Z",
        "updatedAt" : "2019-06-24T23:26:45Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      },
      {
        "id" : "744b7b62-9c9d-41ba-870c-8ad07033615a",
        "parentId" : "219173cb-ec22-421d-9a55-1d9effa9a2ea",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "Ack here; For `onJoinPrepare` though in the pt.3 this is modified a bit since with EAGER we may still revoke.",
        "createdAt" : "2019-06-27T00:21:53Z",
        "updatedAt" : "2019-06-27T00:21:53Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      }
    ],
    "commit" : "8440e7defc7a3b3c0fa6c378969b33035ad1a21d",
    "line" : 163,
    "diffHunk" : "@@ -1,1 +497,501 @@        Map<String, Assignment> assignments = assignor.assign(metadata.fetch(), subscriptions);\n\n        switch (protocol) {\n            case EAGER:\n                break;"
  },
  {
    "id" : "b4af89d1-4456-45f5-8155-84afa5391eb4",
    "prId" : 6778,
    "prUrl" : "https://github.com/apache/kafka/pull/6778#pullrequestreview-254941488",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "476790eb-4779-41c4-bc41-67f9ae35e08a",
        "parentId" : null,
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "I think this log message is more confusing than useful. Maybe it would be better to log a message below in the Wakeup/Interrupt exception handler?",
        "createdAt" : "2019-06-24T23:59:12Z",
        "updatedAt" : "2019-06-24T23:59:13Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      },
      {
        "id" : "fbcf07e6-9508-4261-aabc-64275d06b43a",
        "parentId" : "476790eb-4779-41c4-bc41-67f9ae35e08a",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "Ack.",
        "createdAt" : "2019-06-27T00:23:11Z",
        "updatedAt" : "2019-06-27T00:23:11Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      }
    ],
    "commit" : "8440e7defc7a3b3c0fa6c378969b33035ad1a21d",
    "line" : 69,
    "diffHunk" : "@@ -1,1 +299,303 @@                if (!ownedPartitions.isEmpty()) {\n                    log.info(\"Coordinator has owned partitions {} that are not revoked with {} protocol, \" +\n                        \"it is likely client is woken up before a previous pending rebalance completes its callback\", ownedPartitions, protocol);\n                }\n"
  },
  {
    "id" : "045e57b6-4bb2-41f3-b2ec-3eacc55bc32e",
    "prId" : 6778,
    "prUrl" : "https://github.com/apache/kafka/pull/6778#pullrequestreview-254943627",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ad90291a-59d9-42fb-bda8-faa797438fab",
        "parentId" : null,
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "It would be helpful to have some high-level documentation somewhere in the code about the cooperative strategy and how it works. Perhaps this already exists? At a minimum, we should explain in the `ConsumerRebalanceListener` docs how the two strategies affect the API.",
        "createdAt" : "2019-06-25T00:09:04Z",
        "updatedAt" : "2019-06-25T00:09:17Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      },
      {
        "id" : "59df8236-f3c9-44b3-8478-7ad084b9e406",
        "parentId" : "ad90291a-59d9-42fb-bda8-faa797438fab",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "Yeah my plan is to add the javadoc change in pt.3, and will do another doc PR for web-docs / upgrade-path; the rationale is that some of the behavior changes are yet to be agreed on in pt.3 so I'd like to defer that to later.",
        "createdAt" : "2019-06-27T00:34:16Z",
        "updatedAt" : "2019-06-27T00:34:17Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      }
    ],
    "commit" : "8440e7defc7a3b3c0fa6c378969b33035ad1a21d",
    "line" : 94,
    "diffHunk" : "@@ -1,1 +324,328 @@    }\n\n    private void assignAndRevoke(final ConsumerRebalanceListener listener,\n                                 final Set<TopicPartition> assignedPartitions,\n                                 final Set<TopicPartition> ownedPartitions) {"
  },
  {
    "id" : "eb91e787-2132-47b0-b5e7-3937c7360602",
    "prId" : 6778,
    "prUrl" : "https://github.com/apache/kafka/pull/6778#pullrequestreview-254950718",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "acb6e0a2-0c3c-4b33-b2a9-93dc3d7edde6",
        "parentId" : null,
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "A brief description of the purpose of this adjustment would be helpful.",
        "createdAt" : "2019-06-25T00:13:35Z",
        "updatedAt" : "2019-06-25T00:43:36Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      },
      {
        "id" : "2429e629-b793-415a-be09-ae109eb69a20",
        "parentId" : "acb6e0a2-0c3c-4b33-b2a9-93dc3d7edde6",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "Ack.",
        "createdAt" : "2019-06-27T01:12:55Z",
        "updatedAt" : "2019-06-27T01:12:56Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      }
    ],
    "commit" : "8440e7defc7a3b3c0fa6c378969b33035ad1a21d",
    "line" : 168,
    "diffHunk" : "@@ -1,1 +502,506 @@\n            case COOPERATIVE:\n                adjustAssignment(ownedPartitions, assignments);\n                break;\n        }"
  },
  {
    "id" : "6d66bede-1023-451d-8543-6a2d4cd619e1",
    "prId" : 6778,
    "prUrl" : "https://github.com/apache/kafka/pull/6778#pullrequestreview-254960191",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f40e72d5-3b15-4776-9500-1259ec5200a7",
        "parentId" : null,
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "We may have discussed this in the past, but I'm not too thrilled with the consumer mucking around with assignments from the plugin. Couldn't we just raise an error if the assignment doesn't respect ownership?",
        "createdAt" : "2019-06-25T00:39:46Z",
        "updatedAt" : "2019-06-25T00:43:36Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      },
      {
        "id" : "7b453037-3211-4e5c-84ad-a0e9a94625e1",
        "parentId" : "f40e72d5-3b15-4776-9500-1259ec5200a7",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "```\r\nCouldn't we just raise an error if the assignment doesn't respect ownership?\r\n```\r\n\r\nHmm, I think that's doable. But on the other hand we are requiring users to be aware how to leverage on `owned-partitions` list and respect it with `COOPERATIVE`. \r\n\r\nI see pros and cons of this approach: not silently mucking around user assignor returned data, but pushing the responsibility of implementing `COOPERATIVE`-supported assignors to users themselves. @ableegoldman wdyt?",
        "createdAt" : "2019-06-27T01:32:50Z",
        "updatedAt" : "2019-06-27T01:32:50Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      }
    ],
    "commit" : "8440e7defc7a3b3c0fa6c378969b33035ad1a21d",
    "line" : 200,
    "diffHunk" : "@@ -1,1 +548,552 @@    }\n\n    private void adjustAssignment(final Map<TopicPartition, String> ownedPartitions,\n                                  final Map<String, Assignment> assignments) {\n        boolean revocationsNeeded = false;"
  },
  {
    "id" : "c742a048-7bd6-46e5-90ae-4776a95bc4da",
    "prId" : 6884,
    "prUrl" : "https://github.com/apache/kafka/pull/6884#pullrequestreview-253719486",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a6524438-e53c-4df2-b905-c1e9652088e0",
        "parentId" : null,
        "authorId" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "body" : "We don't seem to be using this anymore?",
        "createdAt" : "2019-06-24T23:46:45Z",
        "updatedAt" : "2019-08-08T21:28:14Z",
        "lastEditedBy" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "tags" : [
        ]
      },
      {
        "id" : "55608dc9-c901-46f8-a1ca-a07fda7b23ee",
        "parentId" : "a6524438-e53c-4df2-b905-c1e9652088e0",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "Ah my bad, I think the rebasing messed up the logic here. And also the other comment you made below.",
        "createdAt" : "2019-06-25T00:24:28Z",
        "updatedAt" : "2019-08-08T21:28:14Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      }
    ],
    "commit" : "6041a792f58b0b9a38983a60e052e9018319a6e6",
    "line" : 188,
    "diffHunk" : "@@ -1,1 +374,378 @@            case COOPERATIVE:\n                Set<TopicPartition> revokedPartitions = new HashSet<>(ownedPartitions);\n                revokedPartitions.removeAll(assignedPartitions);\n\n                log.info(\"Updating with newly assigned partitions: {}, compare with already owned partitions: {}, \" +"
  },
  {
    "id" : "9ce3dd1f-a3b0-4c71-8b80-63379e1fd4dc",
    "prId" : 6884,
    "prUrl" : "https://github.com/apache/kafka/pull/6884#pullrequestreview-266908614",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bfcb7bbb-6e65-43ba-a98e-5c7396d488b1",
        "parentId" : null,
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "Hmm.. Do we know how this is getting propagated in all cases? Some of the responses are handled using a `RequestCompletionHandler`, but NetworkClient currently eats any exception raised from this callback.",
        "createdAt" : "2019-06-28T21:46:29Z",
        "updatedAt" : "2019-08-08T21:28:14Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      },
      {
        "id" : "1744117d-b825-49bf-9cee-0e229f37e567",
        "parentId" : "bfcb7bbb-6e65-43ba-a98e-5c7396d488b1",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "Good point, will make a pass through all the call traces.",
        "createdAt" : "2019-07-25T21:57:20Z",
        "updatedAt" : "2019-08-08T21:28:14Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "2cfb9d61-5ed4-488e-abb7-44877dc9a9f1",
        "parentId" : "bfcb7bbb-6e65-43ba-a98e-5c7396d488b1",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "Just to confirm: for AbstractCoordinator we have a specific `CoordinatorResponseHandler` which captures the `RuntimeException` (and KafkaException extends it) and raise to ConsumerCoordinator. So I think that path is covered.",
        "createdAt" : "2019-07-25T22:03:00Z",
        "updatedAt" : "2019-08-08T21:28:14Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      }
    ],
    "commit" : "6041a792f58b0b9a38983a60e052e9018319a6e6",
    "line" : 427,
    "diffHunk" : "@@ -1,1 +706,710 @@\n            if (e != null) {\n                throw new KafkaException(\"User rebalance callback throws an error\", e);\n            }\n        }"
  },
  {
    "id" : "b0478c44-1c43-4b27-b20a-30c066e42eee",
    "prId" : 6884,
    "prUrl" : "https://github.com/apache/kafka/pull/6884#pullrequestreview-266953974",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a43b0307-c299-46cd-b9ec-2f97b83c55e0",
        "parentId" : null,
        "authorId" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "body" : "nit: \"User rebalance callback **threw** an error\"",
        "createdAt" : "2019-07-26T01:11:33Z",
        "updatedAt" : "2019-08-08T21:28:14Z",
        "lastEditedBy" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "tags" : [
        ]
      },
      {
        "id" : "d6f47796-2757-4580-b1c7-ba4e16972e94",
        "parentId" : "a43b0307-c299-46cd-b9ec-2f97b83c55e0",
        "authorId" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "body" : "Also, might it be good to clarify that this was the first exception but another method may also have thrown? Or even save the message from any/all exceptions thrown from callbacks?",
        "createdAt" : "2019-07-26T01:19:12Z",
        "updatedAt" : "2019-08-08T21:28:14Z",
        "lastEditedBy" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "tags" : [
        ]
      }
    ],
    "commit" : "6041a792f58b0b9a38983a60e052e9018319a6e6",
    "line" : 245,
    "diffHunk" : "@@ -1,1 +404,408 @@\n        if (firstException.get() != null)\n            throw new KafkaException(\"User rebalance callback throws an error\", firstException.get());\n    }\n"
  },
  {
    "id" : "5f24a11c-2aca-45b4-93f0-264ac4029092",
    "prId" : 6884,
    "prUrl" : "https://github.com/apache/kafka/pull/6884#pullrequestreview-268736427",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "99ddafb2-69e5-4acf-a7d1-1ffd96c9d34b",
        "parentId" : null,
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "This is the bug I found while working on the unit test: without it we would still put a null value to the HashMap.",
        "createdAt" : "2019-07-26T01:21:20Z",
        "updatedAt" : "2019-08-08T21:28:14Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "be4ce6f0-908b-4ca1-b353-0da1437c8bc4",
        "parentId" : "99ddafb2-69e5-4acf-a7d1-1ffd96c9d34b",
        "authorId" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "body" : "Nice catch!",
        "createdAt" : "2019-07-31T00:42:20Z",
        "updatedAt" : "2019-08-08T21:28:14Z",
        "lastEditedBy" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "tags" : [
        ]
      }
    ],
    "commit" : "6041a792f58b0b9a38983a60e052e9018319a6e6",
    "line" : 481,
    "diffHunk" : "@@ -1,1 +1271,1275 @@            for (String topic : subscription.groupSubscription()) {\n                Integer numPartitions = cluster.partitionCountForTopic(topic);\n                if (numPartitions != null)\n                    partitionsPerTopic.put(topic, numPartitions);\n            }"
  },
  {
    "id" : "e516fdb9-d12e-4e66-ba79-35a516c09cda",
    "prId" : 6884,
    "prUrl" : "https://github.com/apache/kafka/pull/6884#pullrequestreview-268057590",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8bd54274-fa89-4c74-85bd-a390ef405c34",
        "parentId" : null,
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "Just making sure I understand this. I think the main thing we're trying to validate is that for each member, the new assignment contains all the owned partitions. is there additional validation needed?",
        "createdAt" : "2019-07-29T20:15:30Z",
        "updatedAt" : "2019-08-08T21:28:14Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      },
      {
        "id" : "20dfa909-79a6-434d-8c53-00af71efe1d2",
        "parentId" : "8bd54274-fa89-4c74-85bd-a390ef405c34",
        "authorId" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "body" : "I think the idea is to validate that the new assignment doesn't contain any partitions that are being revoked during this rebalance",
        "createdAt" : "2019-07-29T21:26:23Z",
        "updatedAt" : "2019-08-08T21:28:14Z",
        "lastEditedBy" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "tags" : [
        ]
      },
      {
        "id" : "14a90822-1f8e-4d10-b758-17e14e69b55e",
        "parentId" : "8bd54274-fa89-4c74-85bd-a390ef405c34",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "@ableegoldman is right here: we just want to make sure no prev-owned-partitions have been re-assigned.",
        "createdAt" : "2019-07-29T21:43:55Z",
        "updatedAt" : "2019-08-08T21:28:14Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      }
    ],
    "commit" : "6041a792f58b0b9a38983a60e052e9018319a6e6",
    "line" : 308,
    "diffHunk" : "@@ -1,1 +605,609 @@     * member, and then in the next rebalance it can finally reassign those partitions not owned by anyone to consumers.\n     */\n    private void validateCooperativeAssignment(final Map<String, List<TopicPartition>> ownedPartitions,\n                                               final Map<String, Assignment> assignments) {\n        Set<TopicPartition> totalRevokedPartitions = new HashSet<>();"
  },
  {
    "id" : "e0e5a434-4124-4786-a7a7-d7a5b163a3e0",
    "prId" : 6884,
    "prUrl" : "https://github.com/apache/kafka/pull/6884#pullrequestreview-269888591",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "88dc4052-bfa0-4dac-b74b-574003e401ea",
        "parentId" : null,
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "How critical do you think this validation is? Since there are so few assignors in the wild, I think I'm wondering if we can just document the requirement and leave it up to the assignor. We don't do other validations such as verifying disjoint assignments.",
        "createdAt" : "2019-07-29T20:15:49Z",
        "updatedAt" : "2019-08-08T21:28:14Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      },
      {
        "id" : "0d646716-20f3-4986-bb04-15c0fedb4bbf",
        "parentId" : "88dc4052-bfa0-4dac-b74b-574003e401ea",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "My arguments come from this: there are different levels of severity from ill-behaved assignor:\r\n\r\n1) duplicate consumption: one partition being consumed by multiple members, this can also be caused by non-disjoint assignments.\r\n\r\n2) runtime error: the consumer would just break and die; this can be caused by incorrect movement, e.g. `consumer.position` returns an IllegalStateException.\r\n\r\nI think it is okay to falls into 1) due to ill-behaved assignor, but 2) should better be avoided, and to do so it is reasonable to fail-early.",
        "createdAt" : "2019-07-30T00:13:13Z",
        "updatedAt" : "2019-08-08T21:28:14Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "e26d6904-d13d-4717-8627-6cd1d24f031d",
        "parentId" : "88dc4052-bfa0-4dac-b74b-574003e401ea",
        "authorId" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "body" : "I don't feel too strongly one way or another, but it seems to me like 1) is more similar to what we're avoiding by doing this validation, ie guarding against a partition being assigned when it has not yet been fully revoked and is therefore still (sort of ) assigned to two members?\r\nI do agree it seems a bit weird to validate this but accept possibly overlapping assignments from poorly behaving assignor implementations in other cases",
        "createdAt" : "2019-07-31T00:24:56Z",
        "updatedAt" : "2019-08-08T21:28:14Z",
        "lastEditedBy" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "tags" : [
        ]
      },
      {
        "id" : "9c3e1b4e-e5aa-476d-a399-6e45772dd035",
        "parentId" : "88dc4052-bfa0-4dac-b74b-574003e401ea",
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "I don't feel too strongly. I think it may be useful initially for users who are trying to figure out how cooperative assignment is supposed to work. Its semantics are more subtle than eager assignment. I'm not sure I understand how case 2) could happen though even with a buggy assignor.",
        "createdAt" : "2019-08-01T22:00:36Z",
        "updatedAt" : "2019-08-08T21:28:14Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      }
    ],
    "commit" : "6041a792f58b0b9a38983a60e052e9018319a6e6",
    "line" : 290,
    "diffHunk" : "@@ -1,1 +552,556 @@\n        if (protocol == RebalanceProtocol.COOPERATIVE) {\n            validateCooperativeAssignment(ownedPartitions, assignments);\n        }\n"
  },
  {
    "id" : "e021ff9e-3885-4ef5-9dfd-c3ad578c2ace",
    "prId" : 6884,
    "prUrl" : "https://github.com/apache/kafka/pull/6884#pullrequestreview-271655815",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fd304d67-2d26-44d7-88fb-e02b4bbfcf79",
        "parentId" : null,
        "authorId" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "body" : "This is the case when the heartbeat thread triggered the rebalance, right? We should add a comment explaining how we are signaling this by setting memberId to Generation.NO_GENERATION.memberId",
        "createdAt" : "2019-08-06T21:06:12Z",
        "updatedAt" : "2019-08-08T21:28:14Z",
        "lastEditedBy" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "tags" : [
        ]
      },
      {
        "id" : "51750a49-a6ba-402c-878a-eb0c056afb26",
        "parentId" : "fd304d67-2d26-44d7-88fb-e02b4bbfcf79",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "Yes, will add the comment.",
        "createdAt" : "2019-08-06T22:54:02Z",
        "updatedAt" : "2019-08-08T21:28:14Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      }
    ],
    "commit" : "6041a792f58b0b9a38983a60e052e9018319a6e6",
    "line" : 351,
    "diffHunk" : "@@ -1,1 +646,650 @@        Exception exception = null;\n        final Set<TopicPartition> revokedPartitions;\n        if (generation == Generation.NO_GENERATION.generationId &&\n            memberId.equals(Generation.NO_GENERATION.memberId)) {\n            revokedPartitions = new HashSet<>(subscriptions.assignedPartitions());"
  },
  {
    "id" : "b0a6c402-019c-4669-b745-5f022a1286dd",
    "prId" : 6936,
    "prUrl" : "https://github.com/apache/kafka/pull/6936#pullrequestreview-250725592",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "565e3af3-69c4-4616-933c-e1b52a5e1845",
        "parentId" : null,
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "Meta: I'd suggest we do not include the optional instance.id in the constructor, since that is primarily used for deserialization whereas the instance.id is `set` directly; we could instead just add a `setter` of instance.id which is initialized as Null.\r\n\r\nIn the setter we can also check that instance.id is indeed Null to avoid setting more than once. And by doing it the unit test below can be simplified as well.",
        "createdAt" : "2019-06-17T20:24:45Z",
        "updatedAt" : "2019-06-17T20:25:45Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      }
    ],
    "commit" : "020a3027d8834ac602ce5d8ecfcff008e0fd93ae",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +399,403 @@        Set<String> allSubscribedTopics = new HashSet<>();\n        Map<String, Subscription> subscriptions = new HashMap<>();\n        for (JoinGroupResponseData.JoinGroupResponseMember memberSubscription : allSubscriptions) {\n            Subscription subscription = ConsumerProtocol.deserializeSubscription(ByteBuffer.wrap(memberSubscription.metadata()),\n                                                                                 Optional.ofNullable(memberSubscription.groupInstanceId()));"
  },
  {
    "id" : "247ff1cb-bad9-4349-b91f-d92d26bffd80",
    "prId" : 7108,
    "prUrl" : "https://github.com/apache/kafka/pull/7108#pullrequestreview-266307634",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0f858265-619e-483b-bdf9-e51879f073b6",
        "parentId" : null,
        "authorId" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "body" : "Could we do the `new ArrayList<>(joinedSubscription)` only once before the for loop and reuse it?",
        "createdAt" : "2019-07-25T06:21:26Z",
        "updatedAt" : "2019-07-25T18:05:47Z",
        "lastEditedBy" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "tags" : [
        ]
      }
    ],
    "commit" : "20e8f3bc5998d975a2888493d114914fe101d291",
    "line" : 61,
    "diffHunk" : "@@ -1,1 +206,210 @@\n        for (ConsumerPartitionAssignor assignor : assignors) {\n            Subscription subscription = new Subscription(new ArrayList<>(joinedSubscription),\n                                                         assignor.subscriptionUserData(joinedSubscription),\n                                                         subscriptions.assignedPartitionsList());"
  },
  {
    "id" : "c175ffee-a5d2-49e7-888d-68473f00da48",
    "prId" : 7108,
    "prUrl" : "https://github.com/apache/kafka/pull/7108#pullrequestreview-266307634",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "de89ee53-3a93-4ca5-87f9-cc262d5e7300",
        "parentId" : null,
        "authorId" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "body" : "nit: could be organized as:\r\n```\r\nreturn assignors.stream()\r\n                   .filter(assignor -> assignor.name().equals(name))\r\n                   .findFirst().orElse(null);\r\n```\r\nbut it's up to you",
        "createdAt" : "2019-07-25T06:24:21Z",
        "updatedAt" : "2019-07-25T18:05:47Z",
        "lastEditedBy" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "tags" : [
        ]
      }
    ],
    "commit" : "20e8f3bc5998d975a2888493d114914fe101d291",
    "line" : 74,
    "diffHunk" : "@@ -1,1 +227,231 @@\n    private ConsumerPartitionAssignor lookupAssignor(String name) {\n        for (ConsumerPartitionAssignor assignor : this.assignors) {\n            if (assignor.name().equals(name))\n                return assignor;"
  },
  {
    "id" : "6c3f0889-a731-4ef7-a07f-55d08813eb4d",
    "prId" : 7312,
    "prUrl" : "https://github.com/apache/kafka/pull/7312#pullrequestreview-340204221",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6a17f72d-148d-4ce0-986d-293babea984a",
        "parentId" : null,
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "Do you think it's worth adding a debug message saying that we're ignoring the fetched offset?",
        "createdAt" : "2020-01-08T23:18:24Z",
        "updatedAt" : "2020-01-09T19:24:33Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      }
    ],
    "commit" : "27f76b7b68256a0b935ed2ffb490616718608782",
    "line" : 49,
    "diffHunk" : "@@ -1,1 +764,768 @@                entry.getValue().leaderEpoch().ifPresent(epoch -> this.metadata.updateLastSeenEpochIfNewer(entry.getKey(), epoch));\n\n                // it's possible that the partition is no longer assigned when the response is received,\n                // so we need to ignore seeking if that's the case\n                if (this.subscriptions.isAssigned(tp)) {"
  },
  {
    "id" : "0c5418f0-00bb-462b-96e5-3bde747a2c95",
    "prId" : 7312,
    "prUrl" : "https://github.com/apache/kafka/pull/7312#pullrequestreview-340756922",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9af5d1d5-f371-4fbf-8fc6-050528918ca8",
        "parentId" : null,
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "nit: I'd suggest \"Ignoring the fetched committed offset\"",
        "createdAt" : "2020-01-09T18:22:55Z",
        "updatedAt" : "2020-01-09T19:24:33Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      },
      {
        "id" : "62252fc4-82d1-4192-b690-9a7ae6e92b7f",
        "parentId" : "9af5d1d5-f371-4fbf-8fc6-050528918ca8",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "I originally did that, but then I realize `OffsetAndMetadata#toString` contains this already so I decided to avoid duplicated wording.",
        "createdAt" : "2020-01-09T19:20:20Z",
        "updatedAt" : "2020-01-09T19:24:33Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      }
    ],
    "commit" : "27f76b7b68256a0b935ed2ffb490616718608782",
    "line" : 61,
    "diffHunk" : "@@ -1,1 +776,780 @@                    log.info(\"Setting offset for partition {} to the committed offset {}\", tp, position);\n                } else {\n                    log.info(\"Ignoring the returned {} since its partition {} is no longer assigned\",\n                        offsetAndMetadata, tp);\n                }"
  },
  {
    "id" : "7da4b76e-1b17-4e0a-9df3-d6e2fd955ad7",
    "prId" : 7321,
    "prUrl" : "https://github.com/apache/kafka/pull/7321#pullrequestreview-290283484",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1f733ba0-c444-4279-991f-de5080d32266",
        "parentId" : null,
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "Sorry if I'm being dense, but what was the reason to move this and the following from before the \"protocol conditional\" block?\r\n\r\nI think it looks fine, just wondering.",
        "createdAt" : "2019-09-18T23:33:36Z",
        "updatedAt" : "2019-09-24T05:45:47Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      },
      {
        "id" : "c2f6c503-4ec3-4ee7-a08c-c65e3f38968c",
        "parentId" : "1f733ba0-c444-4279-991f-de5080d32266",
        "authorId" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "body" : "We should call `onPartitionsRevoked` before updating any state, including the assignor's in addition to the assigned partitions",
        "createdAt" : "2019-09-19T00:39:51Z",
        "updatedAt" : "2019-09-24T05:45:47Z",
        "lastEditedBy" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "tags" : [
        ]
      },
      {
        "id" : "d42e701b-4a13-44ca-9590-05946cf24f20",
        "parentId" : "1f733ba0-c444-4279-991f-de5080d32266",
        "authorId" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "body" : "ie we should call `assignor#onAssignment` next to `subscriptions.assignFromSubscribed`, in between the two listener callbacks",
        "createdAt" : "2019-09-19T00:41:20Z",
        "updatedAt" : "2019-09-24T05:45:47Z",
        "lastEditedBy" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "tags" : [
        ]
      },
      {
        "id" : "64d8f637-bbba-4e9f-8aa0-8c2962631cb7",
        "parentId" : "1f733ba0-c444-4279-991f-de5080d32266",
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "Ah, got it. Thanks!",
        "createdAt" : "2019-09-19T01:36:19Z",
        "updatedAt" : "2019-09-24T05:45:47Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      }
    ],
    "commit" : "c3935aa6be7cc55911bb4e24332557df24d01f18",
    "line" : 70,
    "diffHunk" : "@@ -1,1 +376,380 @@        // The leader may have assigned partitions which match our subscription pattern, but which\n        // were not explicitly requested, so we update the joined subscription here.\n        maybeUpdateJoinedSubscription(assignedPartitions);\n\n        // give the assignor a chance to update internal state based on the received assignment"
  },
  {
    "id" : "064b4a4e-17c8-46ff-b9a2-b0a9c011b44e",
    "prId" : 7321,
    "prUrl" : "https://github.com/apache/kafka/pull/7321#pullrequestreview-291442467",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ae4dbe82-296a-4a97-9e1d-d88eb59d7baf",
        "parentId" : null,
        "authorId" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "body" : "This log line seems a bit redundant to me. Wouldn't it suffice to log the owned partitions, the added partitions, and the revoked partitions?\r\nnit: the closing parenthesis should be on a new line.\r\n",
        "createdAt" : "2019-09-19T01:20:39Z",
        "updatedAt" : "2019-09-24T05:45:47Z",
        "lastEditedBy" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "tags" : [
        ]
      },
      {
        "id" : "3073ea68-5f28-481d-a194-ecba30e0ab5a",
        "parentId" : "ae4dbe82-296a-4a97-9e1d-d88eb59d7baf",
        "authorId" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "body" : "@guozhangwang who wrote this :) -- might be useful to at least add linebreaks, kind of difficult to read as is when looking through the logs",
        "createdAt" : "2019-09-21T00:16:10Z",
        "updatedAt" : "2019-09-24T05:45:47Z",
        "lastEditedBy" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "tags" : [
        ]
      },
      {
        "id" : "d8a28780-4ba1-4623-a758-4f5d16d6622d",
        "parentId" : "ae4dbe82-296a-4a97-9e1d-d88eb59d7baf",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "You know I'm always overly diligent in log4j",
        "createdAt" : "2019-09-21T00:52:54Z",
        "updatedAt" : "2019-09-24T05:45:47Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      }
    ],
    "commit" : "c3935aa6be7cc55911bb4e24332557df24d01f18",
    "line" : 42,
    "diffHunk" : "@@ -1,1 +360,364 @@                Utils.join(ownedPartitions, \", \"),\n                Utils.join(addedPartitions, \", \"),\n                Utils.join(revokedPartitions, \", \"));\n\n"
  },
  {
    "id" : "7ca7e6e5-92c2-4036-ab44-c3343f6260a8",
    "prId" : 7441,
    "prUrl" : "https://github.com/apache/kafka/pull/7441#pullrequestreview-306214794",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "83c358d1-acb3-4110-898c-3c790e148d65",
        "parentId" : null,
        "authorId" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "body" : "@abbccdda Just wondering, have you tried running the failing `test_broker_type_bounce` without this optimization? ",
        "createdAt" : "2019-10-23T20:15:11Z",
        "updatedAt" : "2019-10-24T17:00:49Z",
        "lastEditedBy" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "tags" : [
        ]
      },
      {
        "id" : "38c728b5-4498-49fd-b69c-3171bdea8525",
        "parentId" : "83c358d1-acb3-4110-898c-3c790e148d65",
        "authorId" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "body" : "No I haven't, that's a good idea.",
        "createdAt" : "2019-10-23T21:54:05Z",
        "updatedAt" : "2019-10-24T17:00:49Z",
        "lastEditedBy" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "tags" : [
        ]
      }
    ],
    "commit" : "1bdf5cf22677bebab206c070889d709efcc7aa1e",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +698,702 @@        if (subscriptions.partitionsAutoAssigned() && !droppedPartitions.isEmpty()) {\n            final Exception e;\n            if (generation() != Generation.NO_GENERATION) {\n                e = invokePartitionsRevoked(droppedPartitions);\n            } else {"
  },
  {
    "id" : "172fd225-37ab-4bf6-92f5-ed1c2b954adb",
    "prId" : 7451,
    "prUrl" : "https://github.com/apache/kafka/pull/7451#pullrequestreview-299073232",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2652d499-2a5e-4a6f-9669-6e4a151147ba",
        "parentId" : null,
        "authorId" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "body" : "Do you think it would be useful to also log the generation somewhere for the followers as well, maybe at the beginning of the rebalance in case it \"fails\" or else when we log that the SyncGroup was unsuccessful eg because group already started another rebalance?",
        "createdAt" : "2019-10-08T00:52:55Z",
        "updatedAt" : "2019-10-08T21:56:48Z",
        "lastEditedBy" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "tags" : [
        ]
      },
      {
        "id" : "f0903508-18a9-4fd8-8916-3fd3a5382336",
        "parentId" : "2652d499-2a5e-4a6f-9669-6e4a151147ba",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "I checked the log4j trace and I think we are good covered with `Received successful JoinGroup response`. So I'm just gonna augment the existing entry at the end of the response handler.",
        "createdAt" : "2019-10-08T21:56:19Z",
        "updatedAt" : "2019-10-08T21:56:48Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      }
    ],
    "commit" : "6bae4d94b47a17569f11cfe185d630bcc68d347e",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +583,587 @@        assignmentSnapshot = metadataSnapshot;\n\n        log.info(\"Finished assignment for group at generation {}: {}\", generation().generationId, assignments);\n\n        Map<String, ByteBuffer> groupAssignment = new HashMap<>();"
  },
  {
    "id" : "f18aea14-cb31-4298-b3f8-24e2b418c91c",
    "prId" : 7906,
    "prUrl" : "https://github.com/apache/kafka/pull/7906#pullrequestreview-340180070",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "24d9a389-15cd-48a2-9602-464e0bec7874",
        "parentId" : null,
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "Since this callback is not synchronized and nor does the getter `groupMetadata()`, we should declare this cached object volatile.",
        "createdAt" : "2020-01-08T04:49:23Z",
        "updatedAt" : "2020-01-09T00:02:21Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "4c39baa4-57e9-4552-ab13-0c81af17a901",
        "parentId" : "24d9a389-15cd-48a2-9602-464e0bec7874",
        "authorId" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "body" : "For normal consumer user, this callback should be executed on the same thread of the caller right? Why do we need to make it volatile?",
        "createdAt" : "2020-01-08T21:47:07Z",
        "updatedAt" : "2020-01-09T00:02:21Z",
        "lastEditedBy" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "tags" : [
        ]
      },
      {
        "id" : "09164404-f705-4dd3-92ab-7e9e5abb374f",
        "parentId" : "24d9a389-15cd-48a2-9602-464e0bec7874",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "Well I was thinking two threads could be two threads, one calling `consumer.groupMetadata` and one calling `consumer.poll` which is creating a new object, but on a second thought this race condition maybe fine anyways since we cannot guarantee time-ordering if it happens.",
        "createdAt" : "2020-01-08T22:14:44Z",
        "updatedAt" : "2020-01-09T00:02:21Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      }
    ],
    "commit" : "928c95e56ed2e1a6b19e79de8ed69ab6217b9368",
    "line" : 32,
    "diffHunk" : "@@ -1,1 +393,397 @@\n        // give the assignor a chance to update internal state based on the received assignment\n        groupMetadata = new ConsumerGroupMetadata(rebalanceConfig.groupId, generation, memberId, rebalanceConfig.groupInstanceId);\n        assignor.onAssignment(assignment, groupMetadata);\n"
  },
  {
    "id" : "e6330c6f-e0b5-40f5-8143-ea4781bfed6d",
    "prId" : 7997,
    "prUrl" : "https://github.com/apache/kafka/pull/7997#pullrequestreview-353395684",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a179334b-de2c-460b-9c54-08a3bd1cdf23",
        "parentId" : null,
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "@ableegoldman @mjsax This is another bug I found while trouble-shooting the system test failures (dates before the cleanup): when we got a task-migrated exception, and then enforce a rebalance, we call `unsubscribe` which would trigger `onLeavePrepare`, here if it was from task-migrated then it is likely that we are already undergoing a rebalance and in that case we should lose the tasks instead of revoke them since otherwise, we would still try to `commit` which would fail with a RebalanceInProgress exception.",
        "createdAt" : "2020-02-04T23:53:21Z",
        "updatedAt" : "2020-02-05T05:05:33Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "fad9154e-9a10-4dac-b2bc-5e2da90ab7f7",
        "parentId" : "a179334b-de2c-460b-9c54-08a3bd1cdf23",
        "authorId" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "body" : "Good catch. Also it's pretty unfortunate that we can only trigger a rebalance from outside the client by unsubscribing and closing/suspending the entire assignment...this limits the usefulness of KIP-429 during version probing upgrades.\r\n\r\nIt also has some implications for the \"rebalances are cheap\" assumption of KIP-441. Would be better phrased as \"rebalances are cheap, except for the member who triggers them\". ",
        "createdAt" : "2020-02-05T00:11:15Z",
        "updatedAt" : "2020-02-05T05:05:33Z",
        "lastEditedBy" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "tags" : [
        ]
      },
      {
        "id" : "7aa722b6-964d-4450-94c5-7b8e2c33654a",
        "parentId" : "a179334b-de2c-460b-9c54-08a3bd1cdf23",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "Yeah ... maybe we should consider adding a new API to consumer to `rejoin` the group, in a cheaper way.",
        "createdAt" : "2020-02-05T00:14:00Z",
        "updatedAt" : "2020-02-05T05:05:33Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "c37f5174-92c8-41a2-8e6e-8f14caed2f8c",
        "parentId" : "a179334b-de2c-460b-9c54-08a3bd1cdf23",
        "authorId" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "body" : "I agree :) -- would be happy to write up a small KIP for it and kick off discussion",
        "createdAt" : "2020-02-05T00:23:05Z",
        "updatedAt" : "2020-02-05T05:05:33Z",
        "lastEditedBy" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "tags" : [
        ]
      }
    ],
    "commit" : "196e7c0210b659ec81335d5624ae0cf5127fdf21",
    "line" : 50,
    "diffHunk" : "@@ -1,1 +710,714 @@        if (subscriptions.hasAutoAssignedPartitions() && !droppedPartitions.isEmpty()) {\n            final Exception e;\n            if (generation() == Generation.NO_GENERATION || rebalanceInProgress()) {\n                e = invokePartitionsLost(droppedPartitions);\n            } else {"
  }
]
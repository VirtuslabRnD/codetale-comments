[
  {
    "id" : "eba60b5e-bfc6-400e-b9cf-790b02daa213",
    "prId" : 5291,
    "prUrl" : "https://github.com/apache/kafka/pull/5291#pullrequestreview-137206155",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0eef9b7f-07ea-40aa-8e25-0fcd767360a9",
        "parentId" : null,
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "Have you thought about compatibility with the old schema? I am wondering if it would be better to somehow use the generation from the consumer group so that we don't have to change this schema.",
        "createdAt" : "2018-07-11T20:18:17Z",
        "updatedAt" : "2019-04-14T01:16:52Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      },
      {
        "id" : "615c3be5-6690-4274-9ae7-ae7d2c681b49",
        "parentId" : "0eef9b7f-07ea-40aa-8e25-0fcd767360a9",
        "authorId" : "2a5e5a4d-e0e2-4e26-b139-0930dd63f949",
        "body" : "@hachikuji, thanks for the feedback, I had thought about it, but noticed it needed some updates. The new patch should address it.\r\n\r\nRegarding using the existing consumer group generation, I think it may not worth the trouble and added complexity. We don't have consumer group generation on the client side (as far as I can tell), and protocol changes will be required. Plus, supporting the old schema seems to be simple enough. What do you think?",
        "createdAt" : "2018-07-12T02:15:56Z",
        "updatedAt" : "2019-04-14T01:16:52Z",
        "lastEditedBy" : "2a5e5a4d-e0e2-4e26-b139-0930dd63f949",
        "tags" : [
        ]
      },
      {
        "id" : "fd4f31cb-6b01-4d96-b829-fe141c4f6874",
        "parentId" : "0eef9b7f-07ea-40aa-8e25-0fcd767360a9",
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "Have you verified that this change is forward compatible as well? Older versions of the sticky assignor need to be able to work with the updated version.\r\n\r\nThe client definitely has access to the group's generation. The question is whether and how to expose it to the assigner.",
        "createdAt" : "2018-07-12T16:43:00Z",
        "updatedAt" : "2019-04-14T01:16:52Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      },
      {
        "id" : "2b5af99d-2c0b-48f5-ad17-9c29486a6048",
        "parentId" : "0eef9b7f-07ea-40aa-8e25-0fcd767360a9",
        "authorId" : "2a5e5a4d-e0e2-4e26-b139-0930dd63f949",
        "body" : "I tested this with a mix of old and new clients (using old and new versions of sticky assignor), and things seem to be running smoothly. The old clients deserializes only the partition array of the schema from the new clients and ignores their generation marker.\r\n\r\nSorry, you're right. Generation seems to be available in the coordinator. But exposing it to just the sticky assignor could add complexity (other assignors don't need it). I still think the existing solution addresses the raised concern. But if you feel that using the consumer group generation is the way to go I can explore that approach. Thanks!",
        "createdAt" : "2018-07-13T00:03:38Z",
        "updatedAt" : "2019-04-14T01:16:52Z",
        "lastEditedBy" : "2a5e5a4d-e0e2-4e26-b139-0930dd63f949",
        "tags" : [
        ]
      },
      {
        "id" : "1396e7b6-0fd9-469a-87be-21661d9fcca9",
        "parentId" : "0eef9b7f-07ea-40aa-8e25-0fcd767360a9",
        "authorId" : "62fe8b85-4ed8-4db5-9fb4-40779aed3bc6",
        "body" : "@vahidhashemian when I first proposed the generation counters, I looked at the coordinator code, and I had the impression that you have only access to the current / your own generation counter, but not the ones used/known by the other generation counters.\r\n\r\nSo my interpretation is, that if you make this generation accessible to the `Assignor` you can only use it as an input source to for the generation counter we send in every ConsumerUserData.\r\nSo I think its value is rather limited.",
        "createdAt" : "2018-07-13T05:24:21Z",
        "updatedAt" : "2019-04-14T01:16:52Z",
        "lastEditedBy" : "62fe8b85-4ed8-4db5-9fb4-40779aed3bc6",
        "tags" : [
        ]
      },
      {
        "id" : "e9a5b1ab-d21a-42e6-9a24-bb45c51386a3",
        "parentId" : "0eef9b7f-07ea-40aa-8e25-0fcd767360a9",
        "authorId" : "2a5e5a4d-e0e2-4e26-b139-0930dd63f949",
        "body" : "@steven-aerts yes, that should still work if we decide to take that path. The leader always uses the latest generation and sends that along with the assigned partitions to each consumer in the group. Then later if a consumer drops for a brief period they would have a stale assignment (with an old generation). The leader knows to ignore those partition assignments in the case of a conflict. Would that make sense?",
        "createdAt" : "2018-07-13T15:48:56Z",
        "updatedAt" : "2019-04-14T01:16:52Z",
        "lastEditedBy" : "2a5e5a4d-e0e2-4e26-b139-0930dd63f949",
        "tags" : [
        ]
      },
      {
        "id" : "8b4ae626-bef4-491a-93c8-285df82ce33c",
        "parentId" : "0eef9b7f-07ea-40aa-8e25-0fcd767360a9",
        "authorId" : "62fe8b85-4ed8-4db5-9fb4-40779aed3bc6",
        "body" : "It certainly makes sense, however, I do not see much added benefit compared to the more or less arbitrary generation counter you implemented in this PR.\r\nIf it was already exposed, you could use it, but I would not expose it just for this use case.",
        "createdAt" : "2018-07-13T16:21:27Z",
        "updatedAt" : "2019-04-14T01:16:52Z",
        "lastEditedBy" : "62fe8b85-4ed8-4db5-9fb4-40779aed3bc6",
        "tags" : [
        ]
      },
      {
        "id" : "edeb6da2-a557-4252-97da-4d898b18c368",
        "parentId" : "0eef9b7f-07ea-40aa-8e25-0fcd767360a9",
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "Frankly I think you need a KIP for this change either way since you are changing the schema for the sticky assigner user data. Anything exposed on the wire is a public API. I'm actually a little skeptical that this solution can even work if you are using a local generation counter, but I have not reviewed the implementation in detail, so I could be wrong. \r\n\r\nThe advantage of using the generation from the group is that it is guaranteed to increase monotonically after every rebalance. Exposing it in `PartitionAssignor.Assignment` seems reasonable at a glance and may be useful for other stateful assigners.",
        "createdAt" : "2018-07-13T17:13:08Z",
        "updatedAt" : "2019-04-14T01:16:52Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      },
      {
        "id" : "90df388a-fbb7-449b-861b-5ace40e57a44",
        "parentId" : "0eef9b7f-07ea-40aa-8e25-0fcd767360a9",
        "authorId" : "2a5e5a4d-e0e2-4e26-b139-0930dd63f949",
        "body" : "I can write a short KIP. I have tested this in some common use cases and have not noticed an issue. I'll let you review this implementation, and I'll look at how your suggestion would work from an implementation point of view. Thanks!",
        "createdAt" : "2018-07-13T19:22:21Z",
        "updatedAt" : "2019-04-14T01:16:52Z",
        "lastEditedBy" : "2a5e5a4d-e0e2-4e26-b139-0930dd63f949",
        "tags" : [
        ]
      },
      {
        "id" : "fb3e2b75-7b07-42a6-adb8-bc875cfa7126",
        "parentId" : "0eef9b7f-07ea-40aa-8e25-0fcd767360a9",
        "authorId" : "2a5e5a4d-e0e2-4e26-b139-0930dd63f949",
        "body" : "[KIP-341](https://cwiki.apache.org/confluence/display/KAFKA/KIP-341%3A+Update+Sticky+Assignor%27s+User+Data+Protocol) is created for this PR.",
        "createdAt" : "2018-07-13T22:19:39Z",
        "updatedAt" : "2019-04-14T01:16:52Z",
        "lastEditedBy" : "2a5e5a4d-e0e2-4e26-b139-0930dd63f949",
        "tags" : [
        ]
      }
    ],
    "commit" : "a03a73432c4febeeb166b18d07fe24a304676a44",
    "line" : 31,
    "diffHunk" : "@@ -1,1 +200,204 @@    private static final Schema STICKY_ASSIGNOR_USER_DATA_V1 = new Schema(\n            new Field(TOPIC_PARTITIONS_KEY_NAME, new ArrayOf(TOPIC_ASSIGNMENT)),\n            new Field(GENERATION_KEY_NAME, Type.INT32));\n\n    private List<TopicPartition> memberAssignment = null;"
  },
  {
    "id" : "cdb4992b-a65d-4af5-ab97-15678f7d39af",
    "prId" : 5291,
    "prUrl" : "https://github.com/apache/kafka/pull/5291#pullrequestreview-190570851",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "16e15c29-868f-4bf3-a8be-8104ffb647ed",
        "parentId" : null,
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "Effectively what we are doing is sorting the assignments for each partition using the generation and picking the latest two for the current and previous assignments. Is that right? Could we simplify the logic by building a `SortedMap<Integer, String>` for each partition where the key is the generation and the value is the memberID? Then the current assignment would be the last entry and the previous assignment would be the one prior.\r\n",
        "createdAt" : "2019-01-08T21:47:04Z",
        "updatedAt" : "2019-04-14T01:16:52Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      },
      {
        "id" : "447bf666-afd6-4774-856a-ff9ed9155cfc",
        "parentId" : "16e15c29-868f-4bf3-a8be-8104ffb647ed",
        "authorId" : "2a5e5a4d-e0e2-4e26-b139-0930dd63f949",
        "body" : "Great suggestion! It helps simplifying the code and makes `currentPartitionConsumer` redundant. I tried refactoring the code to accommodate this in the new patch.",
        "createdAt" : "2019-01-09T06:41:44Z",
        "updatedAt" : "2019-04-14T01:16:52Z",
        "lastEditedBy" : "2a5e5a4d-e0e2-4e26-b139-0930dd63f949",
        "tags" : [
        ]
      }
    ],
    "commit" : "a03a73432c4febeeb166b18d07fe24a304676a44",
    "line" : 128,
    "diffHunk" : "@@ -1,1 +326,330 @@            ConsumerUserData consumerUserData = deserializeTopicPartitionAssignment(userData);\n\n            for (TopicPartition partition: consumerUserData.partitions) {\n                if (sortedPartitionConsumersByGeneration.containsKey(partition)) {\n                    Map<Integer, String> consumers = sortedPartitionConsumersByGeneration.get(partition);"
  },
  {
    "id" : "c9c35ffc-aaa5-4384-9fe5-ff3bc3f68606",
    "prId" : 5291,
    "prUrl" : "https://github.com/apache/kafka/pull/5291#pullrequestreview-207509572",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ccd44c21-023a-4bfe-a9ed-a2a531d29240",
        "parentId" : null,
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "nit: It might be a little clearer to use `Optional<Integer>` for the type here.",
        "createdAt" : "2019-02-23T22:46:44Z",
        "updatedAt" : "2019-04-14T01:16:52Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      },
      {
        "id" : "cdb7b914-b7b4-4e84-89f8-71afeaff4d08",
        "parentId" : "ccd44c21-023a-4bfe-a9ed-a2a531d29240",
        "authorId" : "2a5e5a4d-e0e2-4e26-b139-0930dd63f949",
        "body" : "I considered following your advice, which probably hints at removing the `DEFAULT_GENERATION`. But that could easily makes things more complex, because at some point(s) we'll have to switch from `Optional` to `int` values because there are sorted structures (`TreeMap`, ...) that rely on default integer comparison. Because of that I feel if we don't want to add complexity we should stay with the `int` type here. Please advise if I misunderstood your point.",
        "createdAt" : "2019-02-24T05:51:16Z",
        "updatedAt" : "2019-04-14T01:16:52Z",
        "lastEditedBy" : "2a5e5a4d-e0e2-4e26-b139-0930dd63f949",
        "tags" : [
        ]
      },
      {
        "id" : "43723cd7-e5be-49d3-b905-c12e73cfa481",
        "parentId" : "ccd44c21-023a-4bfe-a9ed-a2a531d29240",
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "Mainly I was just trying to ensure we do not abuse the sentinel, but it sounds like you have thought through its usage.",
        "createdAt" : "2019-02-25T16:51:47Z",
        "updatedAt" : "2019-04-14T01:16:52Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      }
    ],
    "commit" : "a03a73432c4febeeb166b18d07fe24a304676a44",
    "line" : 35,
    "diffHunk" : "@@ -1,1 +204,208 @@    private List<TopicPartition> memberAssignment = null;\n    private PartitionMovements partitionMovements;\n    private int generation = DEFAULT_GENERATION; // consumer group generation\n\n    static final class ConsumerUserData {"
  }
]
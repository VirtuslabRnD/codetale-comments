[
  {
    "id" : "a794ab0b-acbe-4c1e-9cbf-5a63ab5e2a78",
    "prId" : 7867,
    "prUrl" : "https://github.com/apache/kafka/pull/7867#pullrequestreview-336803254",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "96757e3c-a3f3-4e1a-9ce0-99c9aa6f4e28",
        "parentId" : null,
        "authorId" : "e0554c25-f6f3-4e49-a325-bcc5d4dc5fb2",
        "body" : "needs `@param logContext`",
        "createdAt" : "2019-12-27T15:39:28Z",
        "updatedAt" : "2020-01-06T18:43:12Z",
        "lastEditedBy" : "e0554c25-f6f3-4e49-a325-bcc5d4dc5fb2",
        "tags" : [
        ]
      }
    ],
    "commit" : "30f7b4b32d70c783a5e49ab15a492aa7feefb655",
    "line" : 17,
    "diffHunk" : "@@ -1,1 +52,56 @@     * @param logContext the log context instance\n     *\n     * @return the configured `ChannelBuilder`\n     * @throws IllegalArgumentException if `mode` invariants described above is not maintained\n     */"
  },
  {
    "id" : "ad8e31fa-5077-4af4-a562-9a60592c775d",
    "prId" : 7867,
    "prUrl" : "https://github.com/apache/kafka/pull/7867#pullrequestreview-336803254",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "60703e9e-04fb-41bd-b991-63c2658af96a",
        "parentId" : null,
        "authorId" : "e0554c25-f6f3-4e49-a325-bcc5d4dc5fb2",
        "body" : "Needs `@param logContext` in Javadoc (and also `@param isInterBrokerListener`, `@param isInterBrokerListener `, and `@param time`)",
        "createdAt" : "2019-12-27T15:44:14Z",
        "updatedAt" : "2020-01-06T18:43:12Z",
        "lastEditedBy" : "e0554c25-f6f3-4e49-a325-bcc5d4dc5fb2",
        "tags" : [
        ]
      }
    ],
    "commit" : "30f7b4b32d70c783a5e49ab15a492aa7feefb655",
    "line" : 61,
    "diffHunk" : "@@ -1,1 +94,98 @@                                                      DelegationTokenCache tokenCache,\n                                                      Time time,\n                                                      LogContext logContext) {\n        return create(securityProtocol, Mode.SERVER, JaasContext.Type.SERVER, config, listenerName,\n                isInterBrokerListener, null, true, credentialCache,"
  },
  {
    "id" : "90ae93fa-e63b-424d-a115-c00c00f7d7c2",
    "prId" : 8826,
    "prUrl" : "https://github.com/apache/kafka/pull/8826#pullrequestreview-438712110",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "47c7deb9-1c83-4398-884f-e5c40d874e8a",
        "parentId" : null,
        "authorId" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "body" : "I'm confused, why does convert the type of config will change the way we interpret the config value?",
        "createdAt" : "2020-06-27T16:39:57Z",
        "updatedAt" : "2020-12-02T15:49:33Z",
        "lastEditedBy" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "tags" : [
        ]
      },
      {
        "id" : "728d492f-6d1f-4ff1-b708-2393d8488b48",
        "parentId" : "47c7deb9-1c83-4398-884f-e5c40d874e8a",
        "authorId" : "0f776378-bb23-4193-9bb0-1db5973f3781",
        "body" : "> Does it make sense to just change the logging\r\n\r\nPardon me, I failed to get your point.\r\n\r\n> And in terms of misleading, does this log confuse the user by any chance?\r\n\r\nfor example, the ssl-related configs used to create ssl protocol are viewed as *unknown* when creating ```KafkaAdmin```.\r\n\r\n> why does convert the type of config will change the way we interpret the config value?\r\n\r\nthe fix is unrelated to the type of config. The ```configs``` returned by this method is changed to the inner map (```RecordingMap```) of ```AbstractConfig``` so the keys used to call ```Map#get``` will be added to *used list* of ```AbstractConfig```. ",
        "createdAt" : "2020-06-27T17:21:04Z",
        "updatedAt" : "2020-12-02T15:49:33Z",
        "lastEditedBy" : "0f776378-bb23-4193-9bb0-1db5973f3781",
        "tags" : [
        ]
      }
    ],
    "commit" : "bee0513e40c2eae343456a067d7dce26af55854a",
    "line" : 12,
    "diffHunk" : "@@ -1,1 +164,168 @@    @SuppressWarnings(\"unchecked\")\n    static Map<String, Object> channelBuilderConfigs(final AbstractConfig config, final ListenerName listenerName) {\n        Map<String, Object> parsedConfigs;\n        if (listenerName == null)\n            parsedConfigs = (Map<String, Object>) config.values();"
  },
  {
    "id" : "7d4ed9e3-bfbe-48f1-9e8e-5884e7b54b85",
    "prId" : 8826,
    "prUrl" : "https://github.com/apache/kafka/pull/8826#pullrequestreview-526795911",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "98eade13-e400-4cba-b7cd-1309547fca30",
        "parentId" : null,
        "authorId" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "body" : "Does this cover the case when listenerName is not null? I guess that can only happen on the server side and since we don't log unused configs on the server, so maybe this is ok for now?",
        "createdAt" : "2020-11-10T01:21:34Z",
        "updatedAt" : "2020-12-02T15:49:33Z",
        "lastEditedBy" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "tags" : [
        ]
      },
      {
        "id" : "4f97737b-2f9c-4e45-8a93-ca7b659dd974",
        "parentId" : "98eade13-e400-4cba-b7cd-1309547fca30",
        "authorId" : "0f776378-bb23-4193-9bb0-1db5973f3781",
        "body" : "```java\r\n        if (listenerName == null)\r\n            parsedConfigs = (Map<String, Object>) config.values();\r\n        else\r\n            parsedConfigs = config.valuesWithPrefixOverride(listenerName.configPrefix());\r\n```\r\n\r\nthe method ```config.valuesWithPrefixOverride``` also returns ```RecordingMap so it is ok.",
        "createdAt" : "2020-11-10T01:59:21Z",
        "updatedAt" : "2020-12-02T15:49:33Z",
        "lastEditedBy" : "0f776378-bb23-4193-9bb0-1db5973f3781",
        "tags" : [
        ]
      }
    ],
    "commit" : "bee0513e40c2eae343456a067d7dce26af55854a",
    "line" : 15,
    "diffHunk" : "@@ -1,1 +166,170 @@        Map<String, Object> parsedConfigs;\n        if (listenerName == null)\n            parsedConfigs = (Map<String, Object>) config.values();\n        else\n            parsedConfigs = config.valuesWithPrefixOverride(listenerName.configPrefix());"
  },
  {
    "id" : "249e92fd-325a-4efc-b927-fe022ce5cfb3",
    "prId" : 10007,
    "prUrl" : "https://github.com/apache/kafka/pull/10007#pullrequestreview-581208380",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6affd066-09e2-4c77-833e-3f1d2d318f93",
        "parentId" : null,
        "authorId" : "59ca7821-b29c-4f24-a9d5-cbd394145686",
        "body" : "Constructing the config for the listener prefix seems a bit wasteful just to check that a config exists. I wonder if this is really necessary and if we could check `listenerName.configPrefix() + BrokerSecurityConfigs.SSL_CLIENT_AUTH_CONFIG` in `config` directly instead. Maybe it does not matter too much here as we do this only once after all. What do you think? ",
        "createdAt" : "2021-02-02T08:31:10Z",
        "updatedAt" : "2021-02-02T10:16:40Z",
        "lastEditedBy" : "59ca7821-b29c-4f24-a9d5-cbd394145686",
        "tags" : [
        ]
      },
      {
        "id" : "b63419ed-135f-4732-9d54-802a6b5fa0c9",
        "parentId" : "6affd066-09e2-4c77-833e-3f1d2d318f93",
        "authorId" : "b4936a15-698a-496e-85a1-b1e229b4986b",
        "body" : "We can't do `config.getString(prefix+configName)` because `AbstractConfig` only allows configs from its definition to be obtained using `get` and the prefixed config is not treated as a defined config. I couldn't think of alternative way that doesn't need the originals in some form. As you said, it is only used once when broker starts up, so should be ok. But happy to change if you can think of an alternative.",
        "createdAt" : "2021-02-02T10:20:42Z",
        "updatedAt" : "2021-02-02T10:20:42Z",
        "lastEditedBy" : "b4936a15-698a-496e-85a1-b1e229b4986b",
        "tags" : [
        ]
      },
      {
        "id" : "7ca4dc3b-718c-4e7b-94c2-e5cae55bd045",
        "parentId" : "6affd066-09e2-4c77-833e-3f1d2d318f93",
        "authorId" : "59ca7821-b29c-4f24-a9d5-cbd394145686",
        "body" : "Ah right. I can't think of a better way neither.",
        "createdAt" : "2021-02-02T10:41:38Z",
        "updatedAt" : "2021-02-02T10:41:38Z",
        "lastEditedBy" : "59ca7821-b29c-4f24-a9d5-cbd394145686",
        "tags" : [
        ]
      }
    ],
    "commit" : "2379302af78a1e15b2625ad994f20328890ff54f",
    "line" : 43,
    "diffHunk" : "@@ -1,1 +142,146 @@                        String configuredClientAuth = (String) configs.get(BrokerSecurityConfigs.SSL_CLIENT_AUTH_CONFIG);\n                        String listenerClientAuth = (String) config.originalsWithPrefix(listenerName.configPrefix(), true)\n                                .get(BrokerSecurityConfigs.SSL_CLIENT_AUTH_CONFIG);\n\n                        // If `ssl.client.auth` is configured at the listener-level, we don't set an override and SslFactory"
  },
  {
    "id" : "2fb42fc5-a627-421a-93cc-0103a0a798c3",
    "prId" : 10007,
    "prUrl" : "https://github.com/apache/kafka/pull/10007#pullrequestreview-581209004",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7b3ba90e-4c82-499b-844a-1c778a799a95",
        "parentId" : null,
        "authorId" : "59ca7821-b29c-4f24-a9d5-cbd394145686",
        "body" : "I was a bit confused by this at first as I was wondering why `listenerClientAuth` is not set to `listenerClientAuth` here are well. `null` means that we let the ssl factory get the configuration from `configs` later on. We could perhaps add a comment to make this clearer.\r\n\r\nAlternatively, could we just override `SSL_CLIENT_AUTH_CONFIG` in `configs` directly here instead of doing it in `SslFactory#configure`? This might make the handling clearer here. I don't feel strong about this. What do you think?",
        "createdAt" : "2021-02-02T08:56:32Z",
        "updatedAt" : "2021-02-02T10:16:40Z",
        "lastEditedBy" : "59ca7821-b29c-4f24-a9d5-cbd394145686",
        "tags" : [
        ]
      },
      {
        "id" : "556f0a12-4949-40e8-99f6-8b62ad695bda",
        "parentId" : "7b3ba90e-4c82-499b-844a-1c778a799a95",
        "authorId" : "b4936a15-698a-496e-85a1-b1e229b4986b",
        "body" : "We let SslFactory deal with the override since it needs to apply the override when it is reconfigured.  Added a comment. Let me know what you think.",
        "createdAt" : "2021-02-02T10:25:09Z",
        "updatedAt" : "2021-02-02T10:25:09Z",
        "lastEditedBy" : "b4936a15-698a-496e-85a1-b1e229b4986b",
        "tags" : [
        ]
      },
      {
        "id" : "25babca0-ce43-4bb9-8c48-cbad56845070",
        "parentId" : "7b3ba90e-4c82-499b-844a-1c778a799a95",
        "authorId" : "59ca7821-b29c-4f24-a9d5-cbd394145686",
        "body" : "That makes sense. I did not think about the reconfiguration case.",
        "createdAt" : "2021-02-02T10:42:23Z",
        "updatedAt" : "2021-02-02T10:42:23Z",
        "lastEditedBy" : "59ca7821-b29c-4f24-a9d5-cbd394145686",
        "tags" : [
        ]
      }
    ],
    "commit" : "2379302af78a1e15b2625ad994f20328890ff54f",
    "line" : 50,
    "diffHunk" : "@@ -1,1 +149,153 @@                        // ssl.client.auth` cannot be dynamically altered.\n                        if (listenerClientAuth == null) {\n                            sslClientAuthOverride = SslClientAuth.NONE.name().toLowerCase(Locale.ROOT);\n                            if (configuredClientAuth != null && !configuredClientAuth.equalsIgnoreCase(SslClientAuth.NONE.name())) {\n                                log.warn(\"Broker configuration '{}' is applied only to SSL listeners. Listener-prefixed configuration can be used\" +"
  }
]
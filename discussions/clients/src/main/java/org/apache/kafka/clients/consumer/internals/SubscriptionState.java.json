[
  {
    "id" : "229be854-6465-486a-b5b1-9247de236f99",
    "prId" : 6304,
    "prUrl" : "https://github.com/apache/kafka/pull/6304#pullrequestreview-206957818",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f30d4462-34f5-43f4-bcf9-09dbddf69edb",
        "parentId" : null,
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "It may be helpful to have some focused unit tests in `SubscriptionStateTest`.",
        "createdAt" : "2019-02-22T01:35:38Z",
        "updatedAt" : "2019-02-23T00:12:25Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      },
      {
        "id" : "3753f556-ead1-4cd9-ab50-fae4363abc70",
        "parentId" : "f30d4462-34f5-43f4-bcf9-09dbddf69edb",
        "authorId" : "4a7c311c-0954-4671-a0d2-266cb67437ad",
        "body" : "Good catch. We have many tests in `SubscriptionStateTest`. I updated all of them to assert the correct value is returned.",
        "createdAt" : "2019-02-22T18:15:07Z",
        "updatedAt" : "2019-02-23T00:12:25Z",
        "lastEditedBy" : "4a7c311c-0954-4671-a0d2-266cb67437ad",
        "tags" : [
        ]
      }
    ],
    "commit" : "71eca2a2a6a03a63f1deb7540fce228f3eb9d910",
    "line" : 40,
    "diffHunk" : "@@ -1,1 +185,189 @@     * @return true if assignments matches subscription, otherwise false\n     */\n    public boolean assignFromSubscribed(Collection<TopicPartition> assignments) {\n        if (!this.partitionsAutoAssigned())\n            throw new IllegalArgumentException(\"Attempt to dynamically assign partitions while manual assignment in use\");"
  },
  {
    "id" : "e142d145-dce2-443c-babc-94c6df269a7b",
    "prId" : 6371,
    "prUrl" : "https://github.com/apache/kafka/pull/6371#pullrequestreview-217995699",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ccaa2175-5ad5-4215-ba75-70a60572f65b",
        "parentId" : null,
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "It's a little confusing to say we have a position while it is still being reset. Maybe it could be `isInitializing` or something like that?",
        "createdAt" : "2019-03-22T23:24:44Z",
        "updatedAt" : "2019-04-19T22:50:06Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      }
    ],
    "commit" : "0934f5ac0211e742b1c5b77b1b5c067ed5ff9a6e",
    "line" : 317,
    "diffHunk" : "@@ -1,1 +649,653 @@        }\n\n        private boolean hasPosition() {\n            return fetchState.hasPosition();\n        }"
  },
  {
    "id" : "9f547fb6-0115-4241-99b4-20fea94ff63d",
    "prId" : 6371,
    "prUrl" : "https://github.com/apache/kafka/pull/6371#pullrequestreview-228048411",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d7e80e2f-16bc-40fe-b102-ed46ecdf267b",
        "parentId" : null,
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "Should this be named `currentLeaderAndEpoch`?",
        "createdAt" : "2019-04-18T15:20:14Z",
        "updatedAt" : "2019-04-19T22:50:06Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      }
    ],
    "commit" : "0934f5ac0211e742b1c5b77b1b5c067ed5ff9a6e",
    "line" : 78,
    "diffHunk" : "@@ -1,1 +374,378 @@    }\n\n    public boolean maybeValidatePosition(TopicPartition tp, Metadata.LeaderAndEpoch leaderAndEpoch) {\n        return assignedState(tp).maybeValidatePosition(leaderAndEpoch);\n    }"
  },
  {
    "id" : "2330a661-57ec-4b9d-8852-d25cfc60c056",
    "prId" : 6407,
    "prUrl" : "https://github.com/apache/kafka/pull/6407#pullrequestreview-230599230",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e0d387a5-9f75-45dc-aa8f-9d84f5d44d2e",
        "parentId" : null,
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "Why put this outside the lock?",
        "createdAt" : "2019-04-12T17:01:34Z",
        "updatedAt" : "2019-05-29T14:54:58Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      },
      {
        "id" : "1634a2f4-5603-4f4f-b1cb-ebb388d614e4",
        "parentId" : "e0d387a5-9f75-45dc-aa8f-9d84f5d44d2e",
        "authorId" : "cb6f8432-d515-4113-87f8-14e555ab8ed1",
        "body" : "The `ConsumerRebalanceListener` is given by the user, so it can be anything, therefore I didn't want to lock it. Do you think we should lock it?",
        "createdAt" : "2019-04-18T11:09:26Z",
        "updatedAt" : "2019-05-29T14:54:58Z",
        "lastEditedBy" : "cb6f8432-d515-4113-87f8-14e555ab8ed1",
        "tags" : [
        ]
      },
      {
        "id" : "d6befbd1-2010-4c07-a7c9-4349d99b26c2",
        "parentId" : "e0d387a5-9f75-45dc-aa8f-9d84f5d44d2e",
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "Hmm, but we're not actually calling the listener here. We do that separately. ",
        "createdAt" : "2019-04-24T18:38:51Z",
        "updatedAt" : "2019-05-29T14:54:58Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      },
      {
        "id" : "06e32d64-51d8-40f4-9b9d-4da3685a483b",
        "parentId" : "e0d387a5-9f75-45dc-aa8f-9d84f5d44d2e",
        "authorId" : "cb6f8432-d515-4113-87f8-14e555ab8ed1",
        "body" : "Ok, that's a fair point. I'll make it snychronized.",
        "createdAt" : "2019-04-25T11:47:32Z",
        "updatedAt" : "2019-05-29T14:54:58Z",
        "lastEditedBy" : "cb6f8432-d515-4113-87f8-14e555ab8ed1",
        "tags" : [
        ]
      }
    ],
    "commit" : "c6ef4274d4b3b39eeca4c68ffc7ae2520657f24f",
    "line" : 90,
    "diffHunk" : "@@ -1,1 +158,162 @@\n    public synchronized boolean subscribe(Set<String> topics, ConsumerRebalanceListener listener) {\n        registerRebalanceListener(listener);\n        setSubscriptionType(SubscriptionType.AUTO_TOPICS);\n        return changeSubscription(topics);"
  },
  {
    "id" : "9c47d9b4-33e0-40b0-bce6-f7215ed4f891",
    "prId" : 6407,
    "prUrl" : "https://github.com/apache/kafka/pull/6407#pullrequestreview-228249728",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f48b4119-a8cd-4988-9bb2-59afb8b78ee3",
        "parentId" : null,
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "We're returning the collection directly here which violates the synchronization. Actually there's some inconsistency between `groupSubscription` and `subscription`. The latter is effectively immutable in the sense that we do not update the set once it is created. Perhaps we can do the same for `groupSubscription` which would fix this problem.",
        "createdAt" : "2019-04-12T17:15:07Z",
        "updatedAt" : "2019-05-29T14:54:58Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      },
      {
        "id" : "1936d41a-8676-424b-ba41-024f031d2fff",
        "parentId" : "f48b4119-a8cd-4988-9bb2-59afb8b78ee3",
        "authorId" : "cb6f8432-d515-4113-87f8-14e555ab8ed1",
        "body" : "Ok, makes sense.",
        "createdAt" : "2019-04-18T12:14:57Z",
        "updatedAt" : "2019-05-29T14:54:58Z",
        "lastEditedBy" : "cb6f8432-d515-4113-87f8-14e555ab8ed1",
        "tags" : [
        ]
      }
    ],
    "commit" : "c6ef4274d4b3b39eeca4c68ffc7ae2520657f24f",
    "line" : 262,
    "diffHunk" : "@@ -1,1 +331,335 @@     *   of the current generation; otherwise it returns the same set as {@link #subscription()}\n     */\n    synchronized Set<String> groupSubscription() {\n        return this.groupSubscription;\n    }"
  },
  {
    "id" : "d899253f-0add-4095-8567-939988ba42a6",
    "prId" : 6407,
    "prUrl" : "https://github.com/apache/kafka/pull/6407#pullrequestreview-230290941",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "deb37781-264a-4759-8542-94a8cd899808",
        "parentId" : null,
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "This method is also not safe since we are returning a view to the underlying collection. As far as I can tell, we have only two uses for this method: 1) create a copy of the collection, 2) iterate over the members. Perhaps we can let this method do the copy so that it is protected with the lock to handle case 1. For case 2, potentially we can add a `forEachAssigned` or something like that which is also protected by the lock. What do you think?",
        "createdAt" : "2019-04-12T17:20:05Z",
        "updatedAt" : "2019-05-29T14:54:58Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      },
      {
        "id" : "f573591d-c982-460d-a94d-93a245d7b486",
        "parentId" : "deb37781-264a-4759-8542-94a8cd899808",
        "authorId" : "cb6f8432-d515-4113-87f8-14e555ab8ed1",
        "body" : "(1) seems fair.\r\n(2) seems fair too. First I was debating whether we need that or not but for iterations it might be better to acquire the lock one time and not _n_ times given that the operations done in `TopicPartitionState` are fairly cheap too.",
        "createdAt" : "2019-04-18T13:47:53Z",
        "updatedAt" : "2019-05-29T14:54:58Z",
        "lastEditedBy" : "cb6f8432-d515-4113-87f8-14e555ab8ed1",
        "tags" : [
        ]
      },
      {
        "id" : "9eba9569-0f9a-4e85-813b-114d62ecc12a",
        "parentId" : "deb37781-264a-4759-8542-94a8cd899808",
        "authorId" : "cb6f8432-d515-4113-87f8-14e555ab8ed1",
        "body" : "What's even more I think for (2) it'd be enough to modify (or overload) requestOffsetReset to have list parameters so you can pass in multiple partitions.\r\n(`subscriptions.assignedPartitions()` is only called in seekTo... methods which in turn call `requestOffsetReset`)",
        "createdAt" : "2019-04-18T13:56:38Z",
        "updatedAt" : "2019-05-29T14:54:58Z",
        "lastEditedBy" : "cb6f8432-d515-4113-87f8-14e555ab8ed1",
        "tags" : [
        ]
      },
      {
        "id" : "4381d386-b792-4c40-a15c-46e8e34af655",
        "parentId" : "deb37781-264a-4759-8542-94a8cd899808",
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "Makes sense.",
        "createdAt" : "2019-04-24T18:44:08Z",
        "updatedAt" : "2019-05-29T14:54:58Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      }
    ],
    "commit" : "c6ef4274d4b3b39eeca4c68ffc7ae2520657f24f",
    "line" : 317,
    "diffHunk" : "@@ -1,1 +379,383 @@     * @return a modifiable copy of the currently assigned partitions\n     */\n    public synchronized Set<TopicPartition> assignedPartitions() {\n        return new HashSet<>(this.assignment.partitionSet());\n    }"
  },
  {
    "id" : "82672f24-6247-49e9-ad1c-8354add70634",
    "prId" : 6782,
    "prUrl" : "https://github.com/apache/kafka/pull/6782#pullrequestreview-240910936",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d7f9d35e-b26c-464e-9db9-771103d366b6",
        "parentId" : null,
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "nit: The first `toString()` you added made more sense in the context of the new log message. It just didn't handle the case of manual assignment. I think the warning will be a little more consumable if we just mention the state that is relevant to it. Could we have a `prettyString()` or something which gives a nice representation of the user subscription/assignment?",
        "createdAt" : "2019-05-21T23:04:03Z",
        "updatedAt" : "2019-05-23T18:35:31Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      },
      {
        "id" : "a3ac0bbc-edfd-417d-8149-28ce4dc34014",
        "parentId" : "d7f9d35e-b26c-464e-9db9-771103d366b6",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "I agree, would change it again.",
        "createdAt" : "2019-05-22T01:18:14Z",
        "updatedAt" : "2019-05-23T18:35:31Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "6f20f87b-64df-46d9-a929-a456281e9e42",
        "parentId" : "d7f9d35e-b26c-464e-9db9-771103d366b6",
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "I can't tell if you're trolling me 😜 . The method `prettyString` below still does not handle manual assignment. Maybe it could be something like this?\r\n```java\r\npublic String prettyString() {\r\n  switch (subscriptionType) {\r\n    case NONE: \r\n      return \"None\";\r\n    case AUTO_TOPICS:\r\n      return \"subscribe($topics)\";\r\n    case AUTO_PATTERN:\r\n      return \"subscribe($pattern)\";\r\n    case USER_ASSIGNED:\r\n      return \"assign($partitions)\";\r\n  }\r\n}\r\n```",
        "createdAt" : "2019-05-22T18:01:20Z",
        "updatedAt" : "2019-05-23T18:35:31Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      },
      {
        "id" : "79d7ebf8-0907-45d2-a598-e303495b4352",
        "parentId" : "d7f9d35e-b26c-464e-9db9-771103d366b6",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "Ah I missed it --- so no I was not intentional but just need more coffee :P Will change again.",
        "createdAt" : "2019-05-22T22:27:18Z",
        "updatedAt" : "2019-05-23T18:35:31Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      }
    ],
    "commit" : "0d58279c5e6747c3c5e25ad400d498b38a834f64",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +103,107 @@\n    @Override\n    public String toString() {\n        return \"SubscriptionState{\" +\n            \"type=\" + subscriptionType +"
  },
  {
    "id" : "6a4def49-913c-44d5-8464-9406a9b87589",
    "prId" : 6811,
    "prUrl" : "https://github.com/apache/kafka/pull/6811#pullrequestreview-242810297",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0e0340e7-1f8e-4ce2-9fde-2705958e784f",
        "parentId" : null,
        "authorId" : "083f2f03-ca7e-48a1-9781-482564dfdf53",
        "body" : "+1, the above check for empty leader and epoch obviates the extra check we were doing in safeToFetchFrom. I missed that",
        "createdAt" : "2019-05-28T15:14:29Z",
        "updatedAt" : "2019-05-30T01:23:58Z",
        "lastEditedBy" : "083f2f03-ca7e-48a1-9781-482564dfdf53",
        "tags" : [
        ]
      },
      {
        "id" : "0324fd8a-6567-4d6d-9cb4-e7ff95e88048",
        "parentId" : "0e0340e7-1f8e-4ce2-9fde-2705958e784f",
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "Yeah, I was happy to simplify this. I think I was responsible for the initial confusing check.",
        "createdAt" : "2019-05-28T17:18:58Z",
        "updatedAt" : "2019-05-30T01:23:58Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      }
    ],
    "commit" : "f27693428f8f6dff45f893b2abc849a97d1ca208",
    "line" : 165,
    "diffHunk" : "@@ -1,1 +738,742 @@            }\n\n            if (position != null && !position.currentLeader.equals(currentLeaderAndEpoch)) {\n                FetchPosition newPosition = new FetchPosition(position.offset, position.offsetEpoch, currentLeaderAndEpoch);\n                validatePosition(newPosition);"
  },
  {
    "id" : "b89b1bc8-2ac6-400e-857a-3e6b50a80943",
    "prId" : 6884,
    "prUrl" : "https://github.com/apache/kafka/pull/6884#pullrequestreview-268506465",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "460380c3-5388-4fda-910b-75a27a6beaed",
        "parentId" : null,
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "I'll have to separate the logic of checking matched subscriptions and updating assignment since we need to inject the logic of callback in between now.",
        "createdAt" : "2019-07-30T16:10:18Z",
        "updatedAt" : "2019-08-08T21:28:14Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      }
    ],
    "commit" : "6041a792f58b0b9a38983a60e052e9018319a6e6",
    "line" : 55,
    "diffHunk" : "@@ -1,1 +267,271 @@     * different from {@link #assignFromUser(Set)} which directly set the assignment from user inputs.\n     */\n    public synchronized void assignFromSubscribed(Collection<TopicPartition> assignments) {\n        if (!this.partitionsAutoAssigned())\n            throw new IllegalArgumentException(\"Attempt to dynamically assign partitions while manual assignment in use\");"
  },
  {
    "id" : "ed3266af-db04-442b-8023-14c2ce1d5a01",
    "prId" : 6884,
    "prUrl" : "https://github.com/apache/kafka/pull/6884#pullrequestreview-270434563",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5f593827-b405-4334-9380-96b536068136",
        "parentId" : null,
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "This is another orthogonal minor bug I found from the flaky tests: `requestFailed` can be called in the response handler, in which the subscription may has been changed already.",
        "createdAt" : "2019-08-03T00:05:03Z",
        "updatedAt" : "2019-08-08T21:28:14Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      }
    ],
    "commit" : "6041a792f58b0b9a38983a60e052e9018319a6e6",
    "line" : 72,
    "diffHunk" : "@@ -1,1 +653,657 @@\n    synchronized void requestFailed(Set<TopicPartition> partitions, long nextRetryTimeMs) {\n        for (TopicPartition partition : partitions) {\n            // by the time the request failed, the assignment may no longer\n            // contain this partition any more, in which case we would just ignore."
  },
  {
    "id" : "2a881f40-d6b2-4fca-9ba9-c5db276d23ab",
    "prId" : 7108,
    "prUrl" : "https://github.com/apache/kafka/pull/7108#pullrequestreview-266354652",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5cdc22dd-50c3-4472-a2f7-9ce9cf1adf53",
        "parentId" : null,
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "Did you add this just to avoid an additional copy?\r\n\r\nBy the way, it's a little weird to indicate that the result is modifiable (I know you were just copying). That seems to suggest that the changes are propagated back to `SubscriptionState`.",
        "createdAt" : "2019-07-25T00:38:37Z",
        "updatedAt" : "2019-07-25T18:05:47Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      },
      {
        "id" : "838c0b22-3645-4a08-850c-8b25174997e2",
        "parentId" : "5cdc22dd-50c3-4472-a2f7-9ce9cf1adf53",
        "authorId" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "body" : "Yeah, it seemed awkward to be copying twice. And idk, to me \"a modifiable copy\" means you can safely modify the copy. I guess that's sort of inherent in the definition of copy, but I don't interpret it as meaning modifications to the copy will affect the original",
        "createdAt" : "2019-07-25T00:46:32Z",
        "updatedAt" : "2019-07-25T18:05:47Z",
        "lastEditedBy" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "tags" : [
        ]
      },
      {
        "id" : "14f8ccfd-8046-493c-9b34-b49b1afc4d9a",
        "parentId" : "5cdc22dd-50c3-4472-a2f7-9ce9cf1adf53",
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "Ok, I guess the word \"copy\" is clear enough.",
        "createdAt" : "2019-07-25T00:53:54Z",
        "updatedAt" : "2019-07-25T18:05:47Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      }
    ],
    "commit" : "20e8f3bc5998d975a2888493d114914fe101d291",
    "line" : 15,
    "diffHunk" : "@@ -1,1 +392,396 @@     * @return a modifiable copy of the currently assigned partitions as a list\n     */\n    public synchronized List<TopicPartition> assignedPartitionsList() {\n        return new ArrayList<>(this.assignment.partitionSet());\n    }"
  }
]
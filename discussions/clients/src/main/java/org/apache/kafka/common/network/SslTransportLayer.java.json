[
  {
    "id" : "79902710-64e9-49ce-b702-1a7031267163",
    "prId" : 5371,
    "prUrl" : "https://github.com/apache/kafka/pull/5371#pullrequestreview-137851903",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bc23a70a-5ffa-4f92-8cf4-e93f0ed4c0cb",
        "parentId" : null,
        "authorId" : "d8c7cf80-a55a-474c-a4f4-f60a9efda52c",
        "body" : "It would be good to elaborate on why we need to do this as it's not obvious by just reading the code.",
        "createdAt" : "2018-07-17T07:34:00Z",
        "updatedAt" : "2018-07-18T08:33:12Z",
        "lastEditedBy" : "d8c7cf80-a55a-474c-a4f4-f60a9efda52c",
        "tags" : [
        ]
      },
      {
        "id" : "5ebeb8eb-c3a4-42a6-a422-3899ee2e2c4d",
        "parentId" : "bc23a70a-5ffa-4f92-8cf4-e93f0ed4c0cb",
        "authorId" : "b4936a15-698a-496e-85a1-b1e229b4986b",
        "body" : "Added comments in a new method to process the exceptions.",
        "createdAt" : "2018-07-17T14:20:30Z",
        "updatedAt" : "2018-07-18T08:33:12Z",
        "lastEditedBy" : "b4936a15-698a-496e-85a1-b1e229b4986b",
        "tags" : [
        ]
      }
    ],
    "commit" : "deac2b2a853a92b7342edc5a9387bc5216eef18c",
    "line" : 23,
    "diffHunk" : "@@ -1,1 +263,267 @@\n            // this exception could be due to a write. If there is data available to unwrap,\n            // process the data so that any SSL handshake exceptions are reported\n            if (handshakeStatus == HandshakeStatus.NEED_UNWRAP && netReadBuffer.position() > 0) {\n                try {"
  },
  {
    "id" : "8973fa67-18ac-476b-9444-5d2034f207e3",
    "prId" : 5371,
    "prUrl" : "https://github.com/apache/kafka/pull/5371#pullrequestreview-138020485",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "cabae5f1-6274-4d8c-866b-393ef4be858b",
        "parentId" : null,
        "authorId" : "d8c7cf80-a55a-474c-a4f4-f60a9efda52c",
        "body" : "Would it be easier to understand if this handled all of the unwrap exceptions after the IOException? And then we could call this method `processUnwrapExceptionAfterIOException`.",
        "createdAt" : "2018-07-17T18:31:39Z",
        "updatedAt" : "2018-07-18T08:33:12Z",
        "lastEditedBy" : "d8c7cf80-a55a-474c-a4f4-f60a9efda52c",
        "tags" : [
        ]
      },
      {
        "id" : "105394e4-7a92-4439-b0ed-e347a3ef653e",
        "parentId" : "cabae5f1-6274-4d8c-866b-393ef4be858b",
        "authorId" : "b4936a15-698a-496e-85a1-b1e229b4986b",
        "body" : "@ijuma Thanks for the review. At the moment, this method is used to process `SSLException` in two places, regardless of whether the original exception was after `IOException` or not.  I thought it would be better to do the String check in a single method rather than separate out handling of `IOException`. We need to handle both cases because `SSLException` due to `close_notify` may be processed before or after `IOException`. I can use two methods if a single method is confusing.",
        "createdAt" : "2018-07-17T19:59:42Z",
        "updatedAt" : "2018-07-18T08:33:12Z",
        "lastEditedBy" : "b4936a15-698a-496e-85a1-b1e229b4986b",
        "tags" : [
        ]
      },
      {
        "id" : "b8d9d8fd-c6f6-4073-9c0f-b2ec1ea09f76",
        "parentId" : "cabae5f1-6274-4d8c-866b-393ef4be858b",
        "authorId" : "d8c7cf80-a55a-474c-a4f4-f60a9efda52c",
        "body" : "Good point. So the name doesn't work, but in both cases we have two catches like:\r\n\r\n```scala\r\n} catch (SSLHandshakeException | SSLProtocolException | SSLPeerUnverifiedException | SSLKeyException e) {\r\n  ...\r\n} catch (SSLException e1) {\r\n ...\r\n}\r\n```\r\n\r\nMaybe we can catch SSLException and then pass it to the shared method. What do you think?",
        "createdAt" : "2018-07-17T20:27:11Z",
        "updatedAt" : "2018-07-18T08:33:12Z",
        "lastEditedBy" : "d8c7cf80-a55a-474c-a4f4-f60a9efda52c",
        "tags" : [
        ]
      },
      {
        "id" : "f1d4bb76-b97a-4e84-b5d6-7afa30b80df4",
        "parentId" : "cabae5f1-6274-4d8c-866b-393ef4be858b",
        "authorId" : "b4936a15-698a-496e-85a1-b1e229b4986b",
        "body" : "@ijuma Yes, I was in two minds about that - whether to use `instanceof` in one place or catch the exception in two places. I have updated to use the common method. Thanks.",
        "createdAt" : "2018-07-17T21:11:23Z",
        "updatedAt" : "2018-07-18T08:33:12Z",
        "lastEditedBy" : "b4936a15-698a-496e-85a1-b1e229b4986b",
        "tags" : [
        ]
      }
    ],
    "commit" : "deac2b2a853a92b7342edc5a9387bc5216eef18c",
    "line" : 50,
    "diffHunk" : "@@ -1,1 +840,844 @@    // To do this we need to rely on the exception string. Since it is safer to throw a retriable exception\n    // when we are not sure, we will treat only the first exception string as a handshake exception.\n    private void maybeProcessHandshakeFailure(SSLException sslException, boolean flush, IOException ioException) throws IOException {\n        if (sslException instanceof SSLHandshakeException || sslException instanceof SSLProtocolException ||\n                sslException instanceof SSLPeerUnverifiedException || sslException instanceof SSLKeyException ||"
  }
]
[
  {
    "id" : "2bede019-0e43-4a08-a813-3182ca83ef81",
    "prId" : 6626,
    "prUrl" : "https://github.com/apache/kafka/pull/6626#pullrequestreview-235190128",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "822323f7-79a5-40bf-ba07-3c0d88571502",
        "parentId" : null,
        "authorId" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "body" : "should be index >= size, right?",
        "createdAt" : "2019-05-06T20:45:15Z",
        "updatedAt" : "2019-05-09T15:01:46Z",
        "lastEditedBy" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "tags" : [
        ]
      },
      {
        "id" : "b67b2592-4769-4b01-8f87-f8649dda80f3",
        "parentId" : "822323f7-79a5-40bf-ba07-3c0d88571502",
        "authorId" : "e88252f3-8879-452a-8098-afb39cb614dc",
        "body" : "No, this is right. A ListIterator has `size + 1` valid cursor positions. `listIterator(size)` should return an iterator at the end of the list that can move backwards but not forwards.",
        "createdAt" : "2019-05-08T01:04:56Z",
        "updatedAt" : "2019-05-09T15:01:46Z",
        "lastEditedBy" : "e88252f3-8879-452a-8098-afb39cb614dc",
        "tags" : [
        ]
      },
      {
        "id" : "3a9989be-a308-4549-9e2f-69aca7661502",
        "parentId" : "822323f7-79a5-40bf-ba07-3c0d88571502",
        "authorId" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "body" : "Good call-- thanks for the correction.",
        "createdAt" : "2019-05-08T17:31:43Z",
        "updatedAt" : "2019-05-09T15:01:46Z",
        "lastEditedBy" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "tags" : [
        ]
      }
    ],
    "commit" : "a26a589784c48ddaa4fbb22998ad0e4c41bb84c6",
    "line" : 125,
    "diffHunk" : "@@ -1,1 +221,225 @@        @Override\n        public ListIterator<E> listIterator(int index) {\n            if (index < 0 || index > size) {\n                throw new IndexOutOfBoundsException();\n            }"
  },
  {
    "id" : "be93316d-0b30-4ec2-b438-62c12f9a85de",
    "prId" : 6626,
    "prUrl" : "https://github.com/apache/kafka/pull/6626#pullrequestreview-234826155",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "68e6dffa-e783-4aab-b315-19d1b3a978dd",
        "parentId" : null,
        "authorId" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "body" : "There are some bugs here:\r\n\r\n* If you call remove twice in a row, it should fail.  Remember:\r\n\r\n> Note that the remove() and set(Object) methods are not defined in terms of the cursor position; they are defined to operate on the last element returned by a call to next() or previous().\r\n\r\nSo you can't `remove` twice in a row-- you have to call `next` or `previous` again before you can call `remove`.  Since lastReturned can be non-null here after we call `remove`, something bad will happen if we call it twice.\r\n\r\n* If you get to the end of the list and then call `previous`, it should work.  It fails here because we check `cur` against `head`\r\n\r\n* Indices (`nextIndex` / `previousIndex`) get screwed up after calling `remove`\r\n\r\n* In general, there seems to be no value in having both a `cur` and a `next`.  We can always follow the doubly-linked list backwards, so having an extra field doesn't add any efficiency.  We also have `lastReturned` to track what was last returned, and `cursor` to track whether we're at the end or the beginning of the list (which is implemented as a circular linked list, as you've no doubt noted)  If you choose to have both of these fields, you need to keep them properly updated when you remove an element.  Sounds like a pain.",
        "createdAt" : "2019-05-06T21:04:34Z",
        "updatedAt" : "2019-05-09T15:01:46Z",
        "lastEditedBy" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "tags" : [
        ]
      },
      {
        "id" : "dd059de7-8baa-4303-8bac-cf3fbe0fd4bd",
        "parentId" : "68e6dffa-e783-4aab-b315-19d1b3a978dd",
        "authorId" : "e88252f3-8879-452a-8098-afb39cb614dc",
        "body" : "Good catches all around, thanks. I've improved the remove logic and added some additional testing",
        "createdAt" : "2019-05-08T01:05:28Z",
        "updatedAt" : "2019-05-09T15:01:46Z",
        "lastEditedBy" : "e88252f3-8879-452a-8098-afb39cb614dc",
        "tags" : [
        ]
      }
    ],
    "commit" : "a26a589784c48ddaa4fbb22998ad0e4c41bb84c6",
    "line" : 29,
    "diffHunk" : "@@ -1,1 +133,137 @@    }\n\n    private class ImplicitLinkedHashCollectionIterator implements ListIterator<E> {\n        private int cursor = 0;\n        private Element cur = head;"
  },
  {
    "id" : "47abba78-1e39-4a37-bfed-023551936005",
    "prId" : 10456,
    "prUrl" : "https://github.com/apache/kafka/pull/10456#pullrequestreview-626739522",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a1ca56a1-9544-4988-8a48-6aa46649505d",
        "parentId" : null,
        "authorId" : "d8c7cf80-a55a-474c-a4f4-f60a9efda52c",
        "body" : "I assume we don't have an `addAll` method that has inherent perf advantages, right?",
        "createdAt" : "2021-04-01T21:05:01Z",
        "updatedAt" : "2021-04-02T01:23:29Z",
        "lastEditedBy" : "d8c7cf80-a55a-474c-a4f4-f60a9efda52c",
        "tags" : [
        ]
      },
      {
        "id" : "18a56dd0-d12e-4683-adfa-2a9287e59c07",
        "parentId" : "a1ca56a1-9544-4988-8a48-6aa46649505d",
        "authorId" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "body" : "The addAll for AbstractCollection is just a simple `for` loop.",
        "createdAt" : "2021-04-02T01:21:28Z",
        "updatedAt" : "2021-04-02T01:23:29Z",
        "lastEditedBy" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "tags" : [
        ]
      }
    ],
    "commit" : "d7206678e1e3fbde54b735b0186f0b0514b0a67c",
    "line" : 24,
    "diffHunk" : "@@ -1,1 +690,694 @@        array.sort(comparator);\n        for (E e : array) {\n            add(e);\n        }\n    }"
  }
]
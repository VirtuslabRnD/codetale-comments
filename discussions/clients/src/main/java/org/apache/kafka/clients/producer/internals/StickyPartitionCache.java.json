[
  {
    "id" : "3e2712e4-7242-4bcc-9c78-664925f36cce",
    "prId" : 6997,
    "prUrl" : "https://github.com/apache/kafka/pull/6997#pullrequestreview-268537879",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "194fa091-8a94-47e3-b0c9-1285499ece06",
        "parentId" : null,
        "authorId" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "body" : "Can you add a comment explaining that this is an internal class (which should not be used externally) which implements a cache used for sticky partitioning behavior",
        "createdAt" : "2019-07-30T17:06:19Z",
        "updatedAt" : "2019-08-01T17:34:42Z",
        "lastEditedBy" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "tags" : [
        ]
      }
    ],
    "commit" : "93f350844be9c391ab375fc9b0c207b4ea4335be",
    "line" : 32,
    "diffHunk" : "@@ -1,1 +30,34 @@ * partition for any given topic. This class should not be used externally. \n */\npublic class StickyPartitionCache {\n    private final ConcurrentMap<String, Integer> indexCache;\n    public StickyPartitionCache() {"
  },
  {
    "id" : "5361f67b-02e0-4e91-afd1-444540b88dab",
    "prId" : 6997,
    "prUrl" : "https://github.com/apache/kafka/pull/6997#pullrequestreview-269212753",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "240babad-ea80-4938-a8d1-26b097ceea5c",
        "parentId" : null,
        "authorId" : "6c4430fc-3795-49d6-9c36-cf6aa694824e",
        "body" : "Would it be worth commenting on the reason for the `oldPart == prevPartition` check? I'm guessing this is due to another send switching the partition out from underneath it, meaning that we should simply get the partition that exists in the cache?",
        "createdAt" : "2019-07-31T17:31:52Z",
        "updatedAt" : "2019-08-01T17:34:42Z",
        "lastEditedBy" : "6c4430fc-3795-49d6-9c36-cf6aa694824e",
        "tags" : [
        ]
      },
      {
        "id" : "d40079c3-0912-4825-972a-2f625c2b27e5",
        "parentId" : "240babad-ea80-4938-a8d1-26b097ceea5c",
        "authorId" : "a31dcef8-b459-4b48-bb49-44e910fa9f34",
        "body" : "It is that, or potentially we could have a keyed value triggering a new batch when we do not need a new sticky batch. Checking the prevPartition would help in this case too. ",
        "createdAt" : "2019-07-31T17:33:33Z",
        "updatedAt" : "2019-08-01T17:34:42Z",
        "lastEditedBy" : "a31dcef8-b459-4b48-bb49-44e910fa9f34",
        "tags" : [
        ]
      },
      {
        "id" : "779becd1-ee3b-4717-8c43-cc3a6b6908de",
        "parentId" : "240babad-ea80-4938-a8d1-26b097ceea5c",
        "authorId" : "a31dcef8-b459-4b48-bb49-44e910fa9f34",
        "body" : "_// Check that the current sticky partition for the topic is either not set or that the partition that just filled up matches the sticky partition that needs to be changed._\r\n\r\nTechnically this comment does not cover one case but I don't know if it's worth being overly pedantic in the comment to cover all cases.",
        "createdAt" : "2019-07-31T18:35:32Z",
        "updatedAt" : "2019-08-01T17:34:42Z",
        "lastEditedBy" : "a31dcef8-b459-4b48-bb49-44e910fa9f34",
        "tags" : [
        ]
      },
      {
        "id" : "6a4be872-a6f3-4f88-904c-165447d56800",
        "parentId" : "240babad-ea80-4938-a8d1-26b097ceea5c",
        "authorId" : "a31dcef8-b459-4b48-bb49-44e910fa9f34",
        "body" : "Actually this might be better:\r\n_// Check that the current sticky partition for the topic is either not set or that the partition that triggered the new batch matches the sticky partition that needs to be changed._",
        "createdAt" : "2019-07-31T18:48:38Z",
        "updatedAt" : "2019-08-01T17:34:42Z",
        "lastEditedBy" : "a31dcef8-b459-4b48-bb49-44e910fa9f34",
        "tags" : [
        ]
      }
    ],
    "commit" : "93f350844be9c391ab375fc9b0c207b4ea4335be",
    "line" : 52,
    "diffHunk" : "@@ -1,1 +50,54 @@        // Check that the current sticky partition for the topic is either not set or that the partition that \n        // triggered the new batch matches the sticky partition that needs to be changed.\n        if (oldPart == null || oldPart == prevPartition) {\n            List<PartitionInfo> availablePartitions = cluster.availablePartitionsForTopic(topic);\n            Integer random = Utils.toPositive(ThreadLocalRandom.current().nextInt());"
  },
  {
    "id" : "849c7f02-8407-4a09-8fc2-5e6e7e23f491",
    "prId" : 6997,
    "prUrl" : "https://github.com/apache/kafka/pull/6997#pullrequestreview-269883045",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a4010104-f291-430e-891b-db6f13177478",
        "parentId" : null,
        "authorId" : "6c4430fc-3795-49d6-9c36-cf6aa694824e",
        "body" : "nit: It seems like we don't use the previously calculated random result if we hit this else branch? It seems very slightly wasteful. Maybe it would be better to move the initial random calculation into this if branch to avoid the double random call? https://github.com/apache/kafka/pull/6997/files#diff-6ca6600cf78e2de41d5d7806ebc4ec18R54. We can probably then also avoid mutating `random`.",
        "createdAt" : "2019-08-01T21:13:37Z",
        "updatedAt" : "2019-08-01T21:14:31Z",
        "lastEditedBy" : "6c4430fc-3795-49d6-9c36-cf6aa694824e",
        "tags" : [
        ]
      },
      {
        "id" : "d670ae0f-e9dc-47f9-af9e-3913100add0c",
        "parentId" : "a4010104-f291-430e-891b-db6f13177478",
        "authorId" : "a31dcef8-b459-4b48-bb49-44e910fa9f34",
        "body" : "We do need it for another branch, but I could just put a random calculation in that branch too?",
        "createdAt" : "2019-08-01T21:15:16Z",
        "updatedAt" : "2019-08-01T21:15:17Z",
        "lastEditedBy" : "a31dcef8-b459-4b48-bb49-44e910fa9f34",
        "tags" : [
        ]
      }
    ],
    "commit" : "93f350844be9c391ab375fc9b0c207b4ea4335be",
    "line" : 60,
    "diffHunk" : "@@ -1,1 +58,62 @@                newPart = availablePartitions.get(0).partition();\n            } else {\n                while (newPart == null || newPart.equals(oldPart)) {\n                    random = Utils.toPositive(ThreadLocalRandom.current().nextInt());\n                    newPart = availablePartitions.get(random % availablePartitions.size()).partition();"
  }
]
[
  {
    "id" : "8ec74b4f-2099-4aab-96d5-c232c5be99a0",
    "prId" : 10275,
    "prUrl" : "https://github.com/apache/kafka/pull/10275#pullrequestreview-607097230",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6b198153-572d-49a3-b43b-3b1e9c58b868",
        "parentId" : null,
        "authorId" : "0f776378-bb23-4193-9bb0-1db5973f3781",
        "body" : "Is this method safe? If there are same values, it would return unrelated key.",
        "createdAt" : "2021-03-08T18:53:53Z",
        "updatedAt" : "2021-03-25T00:52:34Z",
        "lastEditedBy" : "0f776378-bb23-4193-9bb0-1db5973f3781",
        "tags" : [
        ]
      },
      {
        "id" : "8d143aed-9acf-4d71-bada-dc2ac13647d0",
        "parentId" : "6b198153-572d-49a3-b43b-3b1e9c58b868",
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "The assumption here is that a value can map to only one key. This is protected by `reverseMap`.",
        "createdAt" : "2021-03-09T07:37:46Z",
        "updatedAt" : "2021-03-25T00:52:34Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      }
    ],
    "commit" : "237e8ecb9a9fe7e8311f181191f7d6a1c68b57ab",
    "line" : 457,
    "diffHunk" : "@@ -1,1 +455,459 @@\n        Optional<K> getKey(V value) {\n            return Optional.ofNullable(reverseMap.get(value));\n        }\n"
  },
  {
    "id" : "5904bcf9-31e5-4b26-bd69-3f2844442354",
    "prId" : 10275,
    "prUrl" : "https://github.com/apache/kafka/pull/10275#pullrequestreview-607095479",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "dca6e4cb-31aa-4605-96e9-80b76c19aa7f",
        "parentId" : null,
        "authorId" : "0f776378-bb23-4193-9bb0-1db5973f3781",
        "body" : "It seems `keyToBrokerId` (and `getKey`) are used by testing only. Is it worthwhile to keep a `reverseMap` in production code for testing? ",
        "createdAt" : "2021-03-08T18:55:33Z",
        "updatedAt" : "2021-03-25T00:52:34Z",
        "lastEditedBy" : "0f776378-bb23-4193-9bb0-1db5973f3781",
        "tags" : [
        ]
      },
      {
        "id" : "f5d2e3aa-2dc4-421b-b4e3-400bd2b0b7bc",
        "parentId" : "dca6e4cb-31aa-4605-96e9-80b76c19aa7f",
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "It was mainly for `remove` that I added it.",
        "createdAt" : "2021-03-09T07:34:55Z",
        "updatedAt" : "2021-03-25T00:52:34Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      }
    ],
    "commit" : "237e8ecb9a9fe7e8311f181191f7d6a1c68b57ab",
    "line" : 147,
    "diffHunk" : "@@ -1,1 +145,149 @@    }\n\n    OptionalInt keyToBrokerId(K key) {\n        Optional<FulfillmentScope> scope = fulfillmentMap.getKey(key);\n        if (scope.isPresent()) {"
  },
  {
    "id" : "8f8b74cf-e397-4006-a362-8187f5aeebb8",
    "prId" : 10275,
    "prUrl" : "https://github.com/apache/kafka/pull/10275#pullrequestreview-612948871",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "14f1dc01-c58a-4732-9ecf-123158367184",
        "parentId" : null,
        "authorId" : "0f776378-bb23-4193-9bb0-1db5973f3781",
        "body" : "It groups values by hash code of key. Hence, callers must implements the hash code for key type. Otherwise, it can't group values as default hash is memory-based. Is it error-prone? ",
        "createdAt" : "2021-03-09T09:08:05Z",
        "updatedAt" : "2021-03-25T00:52:34Z",
        "lastEditedBy" : "0f776378-bb23-4193-9bb0-1db5973f3781",
        "tags" : [
        ]
      },
      {
        "id" : "5e72d549-df9a-456c-a83d-97818656ba27",
        "parentId" : "14f1dc01-c58a-4732-9ecf-123158367184",
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "I am not sure I follow the point. My expectation is that both key and value types have reasonable hashCode/equals implementations. Would it help if I document that expectation?",
        "createdAt" : "2021-03-10T02:29:08Z",
        "updatedAt" : "2021-03-25T00:52:34Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      },
      {
        "id" : "25551b76-8b76-4d15-b076-70d5dfeecb62",
        "parentId" : "14f1dc01-c58a-4732-9ecf-123158367184",
        "authorId" : "0f776378-bb23-4193-9bb0-1db5973f3781",
        "body" : "> My expectation is that both key and value types have reasonable hashCode/equals implementations. Would it help if I document that expectation?\r\n\r\nI feel the document is good as the requisite is not obvious. BTW, what will happen if custom key/value type do not offer hashCode/equals implementations? performance regression or a quick failure? ",
        "createdAt" : "2021-03-10T04:51:16Z",
        "updatedAt" : "2021-03-25T00:52:34Z",
        "lastEditedBy" : "0f776378-bb23-4193-9bb0-1db5973f3781",
        "tags" : [
        ]
      },
      {
        "id" : "e8c8fd28-de89-4db1-a7cc-49ac13aec15c",
        "parentId" : "14f1dc01-c58a-4732-9ecf-123158367184",
        "authorId" : "59ca7821-b29c-4f24-a9d5-cbd394145686",
        "body" : "I think that it is reasonable to assume that both key and value types have a reasonable hashCode/equals implementations in this case.",
        "createdAt" : "2021-03-16T09:48:30Z",
        "updatedAt" : "2021-03-25T00:52:34Z",
        "lastEditedBy" : "59ca7821-b29c-4f24-a9d5-cbd394145686",
        "tags" : [
        ]
      }
    ],
    "commit" : "237e8ecb9a9fe7e8311f181191f7d6a1c68b57ab",
    "line" : 435,
    "diffHunk" : "@@ -1,1 +433,437 @@    private static class BiMultimap<K, V> {\n        private final Map<V, K> reverseMap = new HashMap<>();\n        private final Map<K, Set<V>> map = new HashMap<>();\n\n        void put(K key, V value) {"
  },
  {
    "id" : "5e86ce11-4a65-4f4f-9f03-3f0c644bd1e5",
    "prId" : 10275,
    "prUrl" : "https://github.com/apache/kafka/pull/10275#pullrequestreview-617830577",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5ccec55d-2f07-40f8-8fd4-5ef53e5f48d8",
        "parentId" : null,
        "authorId" : "0f776378-bb23-4193-9bb0-1db5973f3781",
        "body" : "Why we need this `tries`? We already trace the `tries` of `Call`.\r\n",
        "createdAt" : "2021-03-22T07:29:29Z",
        "updatedAt" : "2021-03-25T00:52:34Z",
        "lastEditedBy" : "0f776378-bb23-4193-9bb0-1db5973f3781",
        "tags" : [
        ]
      },
      {
        "id" : "ce243297-5d6c-493a-98b4-bac0cdbff035",
        "parentId" : "5ccec55d-2f07-40f8-8fd4-5ef53e5f48d8",
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "The lookup requests can often result in ping-pong behavior. For example, we use metadata to find partition leader, then we send a request to the leader and get a NOT_LEADER error, which sends us back to the metadata request, and so on. I was not too concerned that the number of tries would be reflected perfectly (as I noted in the javadoc, the behavior is ambigious for these cases), but I wanted to at least ensure that the count continued growing. So if a user does configure a `retries` limit, then eventually we'll hit it even in these ping-pong scenarios if we cannot satisfy the request.",
        "createdAt" : "2021-03-22T18:00:39Z",
        "updatedAt" : "2021-03-25T00:52:34Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      }
    ],
    "commit" : "237e8ecb9a9fe7e8311f181191f7d6a1c68b57ab",
    "line" : 376,
    "diffHunk" : "@@ -1,1 +374,378 @@    private class RequestState {\n        private Optional<RequestSpec<K>> inflightRequest = Optional.empty();\n        private int tries = 0;\n        private long nextAllowedRetryMs = 0;\n"
  },
  {
    "id" : "64143d71-758b-42a7-832e-9ac46e188bfe",
    "prId" : 10743,
    "prUrl" : "https://github.com/apache/kafka/pull/10743#pullrequestreview-679987372",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0704b98d-7ef2-4882-aefb-9169ec75b816",
        "parentId" : null,
        "authorId" : "491bcd91-bc8d-4f54-b5fd-d6c7be5e8693",
        "body" : "Need to fix Javadoc for `#poll()`m which now has a broken link to this method.",
        "createdAt" : "2021-06-07T14:05:26Z",
        "updatedAt" : "2021-06-07T15:14:18Z",
        "lastEditedBy" : "491bcd91-bc8d-4f54-b5fd-d6c7be5e8693",
        "tags" : [
        ]
      },
      {
        "id" : "608b3154-8683-4b1d-970a-d9351a354438",
        "parentId" : "0704b98d-7ef2-4882-aefb-9169ec75b816",
        "authorId" : "d31db46e-de6d-4fea-8dc5-6f7b17b636be",
        "body" : "Good catch!",
        "createdAt" : "2021-06-09T18:09:55Z",
        "updatedAt" : "2021-06-09T18:09:55Z",
        "lastEditedBy" : "d31db46e-de6d-4fea-8dc5-6f7b17b636be",
        "tags" : [
        ]
      }
    ],
    "commit" : "ae09d742171c8a3a7d60587ce0502dce35945f73",
    "line" : 27,
    "diffHunk" : "@@ -1,1 +208,212 @@        RequestSpec<K> spec,\n        AbstractResponse response,\n        Node node\n    ) {\n        clearInflightRequest(currentTimeMs, spec);"
  },
  {
    "id" : "e11389ee-bdfb-4904-98c1-c18fc792a7d3",
    "prId" : 10743,
    "prUrl" : "https://github.com/apache/kafka/pull/10743#pullrequestreview-679950718",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5ed66cf8-3ef4-4f6a-bfdd-88286cd0ebb9",
        "parentId" : null,
        "authorId" : "491bcd91-bc8d-4f54-b5fd-d6c7be5e8693",
        "body" : "The need for this typecast (i.e. the coupling between the strategy and the exception) makes me think that the name of `UnsupportedBatchLookupException` isn't ideal. It's pretty specific to the `FindCoordinators` API, but that's not really conveyed by its name. Maybe something like `NoBatchedFindCoordinatorsException`?",
        "createdAt" : "2021-06-07T14:40:33Z",
        "updatedAt" : "2021-06-07T15:14:18Z",
        "lastEditedBy" : "491bcd91-bc8d-4f54-b5fd-d6c7be5e8693",
        "tags" : [
        ]
      },
      {
        "id" : "cb0ad5a0-36a6-4aeb-a3f0-7660ecebe3dd",
        "parentId" : "5ed66cf8-3ef4-4f6a-bfdd-88286cd0ebb9",
        "authorId" : "d31db46e-de6d-4fea-8dc5-6f7b17b636be",
        "body" : "Right `UnsupportedBatchLookupException` is not a great name!",
        "createdAt" : "2021-06-09T17:34:08Z",
        "updatedAt" : "2021-06-09T17:34:08Z",
        "lastEditedBy" : "d31db46e-de6d-4fea-8dc5-6f7b17b636be",
        "tags" : [
        ]
      }
    ],
    "commit" : "ae09d742171c8a3a7d60587ce0502dce35945f73",
    "line" : 45,
    "diffHunk" : "@@ -1,1 +255,259 @@\n        } else if (t instanceof NoBatchedFindCoordinatorsException) {\n            ((CoordinatorStrategy) handler.lookupStrategy()).disableBatch();\n            Set<K> keysToUnmap = spec.keys.stream()\n                .filter(future.lookupKeys()::contains)"
  },
  {
    "id" : "125f65c5-9b67-47e6-8ad7-ce2873561268",
    "prId" : 10743,
    "prUrl" : "https://github.com/apache/kafka/pull/10743#pullrequestreview-689102082",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "97fe48dd-5f3a-4b43-b763-3cb0d6970d19",
        "parentId" : null,
        "authorId" : "491bcd91-bc8d-4f54-b5fd-d6c7be5e8693",
        "body" : "Why the differing behaviour depending on the scope? There's no need to back off on find coordinator requests?",
        "createdAt" : "2021-06-07T14:43:47Z",
        "updatedAt" : "2021-06-07T15:14:18Z",
        "lastEditedBy" : "491bcd91-bc8d-4f54-b5fd-d6c7be5e8693",
        "tags" : [
        ]
      },
      {
        "id" : "f1c48e7c-4af5-4aff-8907-59b6c6852485",
        "parentId" : "97fe48dd-5f3a-4b43-b763-3cb0d6970d19",
        "authorId" : "d31db46e-de6d-4fea-8dc5-6f7b17b636be",
        "body" : "That surprised me too. It is the current behaviour that all`*RetryBackoff` tests in `KafkaAdminClientTest` enforce",
        "createdAt" : "2021-06-09T17:25:32Z",
        "updatedAt" : "2021-06-09T17:25:32Z",
        "lastEditedBy" : "d31db46e-de6d-4fea-8dc5-6f7b17b636be",
        "tags" : [
        ]
      },
      {
        "id" : "bdde3e86-9253-4425-838e-13254a70cbb9",
        "parentId" : "97fe48dd-5f3a-4b43-b763-3cb0d6970d19",
        "authorId" : "59ca7821-b29c-4f24-a9d5-cbd394145686",
        "body" : "I think that this is worth a comment as it is not obvious.",
        "createdAt" : "2021-06-22T07:03:46Z",
        "updatedAt" : "2021-06-22T07:09:09Z",
        "lastEditedBy" : "59ca7821-b29c-4f24-a9d5-cbd394145686",
        "tags" : [
        ]
      }
    ],
    "commit" : "ae09d742171c8a3a7d60587ce0502dce35945f73",
    "line" : 62,
    "diffHunk" : "@@ -1,1 +281,285 @@                requestState.clearInflight(currentTimeMs + retryBackoffMs);\n            } else {\n                requestState.clearInflight(currentTimeMs);\n            }\n        }"
  },
  {
    "id" : "18ed6a3a-3239-4980-b011-8adce474e3f2",
    "prId" : 10743,
    "prUrl" : "https://github.com/apache/kafka/pull/10743#pullrequestreview-695490369",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4a66af32-f009-4aac-a449-bb1f09cb5549",
        "parentId" : null,
        "authorId" : "59ca7821-b29c-4f24-a9d5-cbd394145686",
        "body" : "It feels a bit weird to handle a special case like this one in the driver. It is probably OK for the time being but we don't want to add more custom cases like this in the driver, I think. I wonder if we could delegate the decision to the handler. We could add an `handleUnsupportedVersionException` method to the `AdminApiHandler` for this purpose to delegate the decision. That method could basically return the keys to unmap and the keys to complete with the exception.\r\n\r\nAn alternative would be to rely on the the `handleUnsupportedVersionException` method in `Call`. The driver could also implement it and still delegate the decision to the handler. The advantage of using this method is that downgrade would not be counted as failures and thus does not count for the retries.\r\n\r\nHave you considered something like this?",
        "createdAt" : "2021-06-28T08:54:25Z",
        "updatedAt" : "2021-06-28T09:09:37Z",
        "lastEditedBy" : "59ca7821-b29c-4f24-a9d5-cbd394145686",
        "tags" : [
        ]
      },
      {
        "id" : "606998bb-e643-47ac-b49e-461bde9ba703",
        "parentId" : "4a66af32-f009-4aac-a449-bb1f09cb5549",
        "authorId" : "d31db46e-de6d-4fea-8dc5-6f7b17b636be",
        "body" : "`AdminApiDriver` was still evolving rapidly while I was implementing this KIP so I went for the straighforward approach.\r\n\r\nBut I agree, it would be best to avoid this type of logic here. The goal would be to find a mechanism that works for all clients. @tombentley suggested an alternative option in https://github.com/apache/kafka/pull/10743#discussion_r649872433. \r\n\r\nI've not had the time to look into better alternatives yet.",
        "createdAt" : "2021-06-28T09:41:35Z",
        "updatedAt" : "2021-06-28T09:41:35Z",
        "lastEditedBy" : "d31db46e-de6d-4fea-8dc5-6f7b17b636be",
        "tags" : [
        ]
      },
      {
        "id" : "14ce937b-cc89-49ce-a844-08d920e9687c",
        "parentId" : "4a66af32-f009-4aac-a449-bb1f09cb5549",
        "authorId" : "59ca7821-b29c-4f24-a9d5-cbd394145686",
        "body" : "Should we file a Jira to not forget about improving this?",
        "createdAt" : "2021-06-29T07:02:06Z",
        "updatedAt" : "2021-06-29T07:02:06Z",
        "lastEditedBy" : "59ca7821-b29c-4f24-a9d5-cbd394145686",
        "tags" : [
        ]
      },
      {
        "id" : "2238acd0-434e-47da-9da3-c55f0a07eab1",
        "parentId" : "4a66af32-f009-4aac-a449-bb1f09cb5549",
        "authorId" : "d31db46e-de6d-4fea-8dc5-6f7b17b636be",
        "body" : "I opened https://issues.apache.org/jira/browse/KAFKA-13013",
        "createdAt" : "2021-06-29T20:54:11Z",
        "updatedAt" : "2021-06-29T20:54:11Z",
        "lastEditedBy" : "d31db46e-de6d-4fea-8dc5-6f7b17b636be",
        "tags" : [
        ]
      }
    ],
    "commit" : "ae09d742171c8a3a7d60587ce0502dce35945f73",
    "line" : 44,
    "diffHunk" : "@@ -1,1 +254,258 @@            retryLookup(keysToUnmap);\n\n        } else if (t instanceof NoBatchedFindCoordinatorsException) {\n            ((CoordinatorStrategy) handler.lookupStrategy()).disableBatch();\n            Set<K> keysToUnmap = spec.keys.stream()"
  }
]
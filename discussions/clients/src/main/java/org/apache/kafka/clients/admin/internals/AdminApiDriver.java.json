[
  {
    "id" : "8ec74b4f-2099-4aab-96d5-c232c5be99a0",
    "prId" : 10275,
    "prUrl" : "https://github.com/apache/kafka/pull/10275#pullrequestreview-607097230",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6b198153-572d-49a3-b43b-3b1e9c58b868",
        "parentId" : null,
        "authorId" : "0f776378-bb23-4193-9bb0-1db5973f3781",
        "body" : "Is this method safe? If there are same values, it would return unrelated key.",
        "createdAt" : "2021-03-08T18:53:53Z",
        "updatedAt" : "2021-03-25T00:52:34Z",
        "lastEditedBy" : "0f776378-bb23-4193-9bb0-1db5973f3781",
        "tags" : [
        ]
      },
      {
        "id" : "8d143aed-9acf-4d71-bada-dc2ac13647d0",
        "parentId" : "6b198153-572d-49a3-b43b-3b1e9c58b868",
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "The assumption here is that a value can map to only one key. This is protected by `reverseMap`.",
        "createdAt" : "2021-03-09T07:37:46Z",
        "updatedAt" : "2021-03-25T00:52:34Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      }
    ],
    "commit" : "237e8ecb9a9fe7e8311f181191f7d6a1c68b57ab",
    "line" : 457,
    "diffHunk" : "@@ -1,1 +455,459 @@\n        Optional<K> getKey(V value) {\n            return Optional.ofNullable(reverseMap.get(value));\n        }\n"
  },
  {
    "id" : "5904bcf9-31e5-4b26-bd69-3f2844442354",
    "prId" : 10275,
    "prUrl" : "https://github.com/apache/kafka/pull/10275#pullrequestreview-607095479",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "dca6e4cb-31aa-4605-96e9-80b76c19aa7f",
        "parentId" : null,
        "authorId" : "0f776378-bb23-4193-9bb0-1db5973f3781",
        "body" : "It seems `keyToBrokerId` (and `getKey`) are used by testing only. Is it worthwhile to keep a `reverseMap` in production code for testing? ",
        "createdAt" : "2021-03-08T18:55:33Z",
        "updatedAt" : "2021-03-25T00:52:34Z",
        "lastEditedBy" : "0f776378-bb23-4193-9bb0-1db5973f3781",
        "tags" : [
        ]
      },
      {
        "id" : "f5d2e3aa-2dc4-421b-b4e3-400bd2b0b7bc",
        "parentId" : "dca6e4cb-31aa-4605-96e9-80b76c19aa7f",
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "It was mainly for `remove` that I added it.",
        "createdAt" : "2021-03-09T07:34:55Z",
        "updatedAt" : "2021-03-25T00:52:34Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      }
    ],
    "commit" : "237e8ecb9a9fe7e8311f181191f7d6a1c68b57ab",
    "line" : 147,
    "diffHunk" : "@@ -1,1 +145,149 @@    }\n\n    OptionalInt keyToBrokerId(K key) {\n        Optional<FulfillmentScope> scope = fulfillmentMap.getKey(key);\n        if (scope.isPresent()) {"
  },
  {
    "id" : "8f8b74cf-e397-4006-a362-8187f5aeebb8",
    "prId" : 10275,
    "prUrl" : "https://github.com/apache/kafka/pull/10275#pullrequestreview-612948871",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "14f1dc01-c58a-4732-9ecf-123158367184",
        "parentId" : null,
        "authorId" : "0f776378-bb23-4193-9bb0-1db5973f3781",
        "body" : "It groups values by hash code of key. Hence, callers must implements the hash code for key type. Otherwise, it can't group values as default hash is memory-based. Is it error-prone? ",
        "createdAt" : "2021-03-09T09:08:05Z",
        "updatedAt" : "2021-03-25T00:52:34Z",
        "lastEditedBy" : "0f776378-bb23-4193-9bb0-1db5973f3781",
        "tags" : [
        ]
      },
      {
        "id" : "5e72d549-df9a-456c-a83d-97818656ba27",
        "parentId" : "14f1dc01-c58a-4732-9ecf-123158367184",
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "I am not sure I follow the point. My expectation is that both key and value types have reasonable hashCode/equals implementations. Would it help if I document that expectation?",
        "createdAt" : "2021-03-10T02:29:08Z",
        "updatedAt" : "2021-03-25T00:52:34Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      },
      {
        "id" : "25551b76-8b76-4d15-b076-70d5dfeecb62",
        "parentId" : "14f1dc01-c58a-4732-9ecf-123158367184",
        "authorId" : "0f776378-bb23-4193-9bb0-1db5973f3781",
        "body" : "> My expectation is that both key and value types have reasonable hashCode/equals implementations. Would it help if I document that expectation?\r\n\r\nI feel the document is good as the requisite is not obvious. BTW, what will happen if custom key/value type do not offer hashCode/equals implementations? performance regression or a quick failure? ",
        "createdAt" : "2021-03-10T04:51:16Z",
        "updatedAt" : "2021-03-25T00:52:34Z",
        "lastEditedBy" : "0f776378-bb23-4193-9bb0-1db5973f3781",
        "tags" : [
        ]
      },
      {
        "id" : "e8c8fd28-de89-4db1-a7cc-49ac13aec15c",
        "parentId" : "14f1dc01-c58a-4732-9ecf-123158367184",
        "authorId" : "59ca7821-b29c-4f24-a9d5-cbd394145686",
        "body" : "I think that it is reasonable to assume that both key and value types have a reasonable hashCode/equals implementations in this case.",
        "createdAt" : "2021-03-16T09:48:30Z",
        "updatedAt" : "2021-03-25T00:52:34Z",
        "lastEditedBy" : "59ca7821-b29c-4f24-a9d5-cbd394145686",
        "tags" : [
        ]
      }
    ],
    "commit" : "237e8ecb9a9fe7e8311f181191f7d6a1c68b57ab",
    "line" : 435,
    "diffHunk" : "@@ -1,1 +433,437 @@    private static class BiMultimap<K, V> {\n        private final Map<V, K> reverseMap = new HashMap<>();\n        private final Map<K, Set<V>> map = new HashMap<>();\n\n        void put(K key, V value) {"
  },
  {
    "id" : "5e86ce11-4a65-4f4f-9f03-3f0c644bd1e5",
    "prId" : 10275,
    "prUrl" : "https://github.com/apache/kafka/pull/10275#pullrequestreview-617830577",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5ccec55d-2f07-40f8-8fd4-5ef53e5f48d8",
        "parentId" : null,
        "authorId" : "0f776378-bb23-4193-9bb0-1db5973f3781",
        "body" : "Why we need this `tries`? We already trace the `tries` of `Call`.\r\n",
        "createdAt" : "2021-03-22T07:29:29Z",
        "updatedAt" : "2021-03-25T00:52:34Z",
        "lastEditedBy" : "0f776378-bb23-4193-9bb0-1db5973f3781",
        "tags" : [
        ]
      },
      {
        "id" : "ce243297-5d6c-493a-98b4-bac0cdbff035",
        "parentId" : "5ccec55d-2f07-40f8-8fd4-5ef53e5f48d8",
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "The lookup requests can often result in ping-pong behavior. For example, we use metadata to find partition leader, then we send a request to the leader and get a NOT_LEADER error, which sends us back to the metadata request, and so on. I was not too concerned that the number of tries would be reflected perfectly (as I noted in the javadoc, the behavior is ambigious for these cases), but I wanted to at least ensure that the count continued growing. So if a user does configure a `retries` limit, then eventually we'll hit it even in these ping-pong scenarios if we cannot satisfy the request.",
        "createdAt" : "2021-03-22T18:00:39Z",
        "updatedAt" : "2021-03-25T00:52:34Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      }
    ],
    "commit" : "237e8ecb9a9fe7e8311f181191f7d6a1c68b57ab",
    "line" : 376,
    "diffHunk" : "@@ -1,1 +374,378 @@    private class RequestState {\n        private Optional<RequestSpec<K>> inflightRequest = Optional.empty();\n        private int tries = 0;\n        private long nextAllowedRetryMs = 0;\n"
  }
]
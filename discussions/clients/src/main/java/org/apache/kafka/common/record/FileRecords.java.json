[
  {
    "id" : "4320bd76-6100-400e-a151-1db93f4732b6",
    "prId" : 5169,
    "prUrl" : "https://github.com/apache/kafka/pull/5169#pullrequestreview-129788939",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "94c51677-3cec-4f5f-843e-753ca53858d3",
        "parentId" : null,
        "authorId" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "body" : "We need to change the return value in java doc.",
        "createdAt" : "2018-06-19T01:36:08Z",
        "updatedAt" : "2018-06-19T15:58:05Z",
        "lastEditedBy" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "tags" : [
        ]
      }
    ],
    "commit" : "c71b1e5937a33e525f483cd5d2edaa925fa68ccb",
    "line" : 9,
    "diffHunk" : "@@ -1,1 +113,117 @@     * possible exceptions\n     */\n    public void readInto(ByteBuffer buffer, int position) throws IOException {\n        Utils.readFully(channel, buffer, position + this.start);\n        buffer.flip();"
  },
  {
    "id" : "d6011435-324d-444c-ad98-5be813c30fff",
    "prId" : 8451,
    "prUrl" : "https://github.com/apache/kafka/pull/8451#pullrequestreview-390140549",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "854f2b0f-4532-49a3-8334-29c8ac681bdd",
        "parentId" : null,
        "authorId" : "d8c7cf80-a55a-474c-a4f4-f60a9efda52c",
        "body" : "Was the boundary check wrong? You changed `>=` to `>`.",
        "createdAt" : "2020-04-08T16:16:17Z",
        "updatedAt" : "2020-04-08T16:16:18Z",
        "lastEditedBy" : "d8c7cf80-a55a-474c-a4f4-f60a9efda52c",
        "tags" : [
        ]
      },
      {
        "id" : "c55dd661-774c-404c-81b2-0bdd13d51fc7",
        "parentId" : "854f2b0f-4532-49a3-8334-29c8ac681bdd",
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "The common case that we would see this is when the limit matches the file end exactly. So changing this to `>` would also have fixed this problem for that case. I decided to remove it here though just because the equality check is redundant (if `end == start + currentSizeInBytes`, then there's no need to update it).",
        "createdAt" : "2020-04-08T16:23:54Z",
        "updatedAt" : "2020-04-08T16:37:10Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      },
      {
        "id" : "ec0836ab-70a6-477b-8ca3-cb8a991abfc5",
        "parentId" : "854f2b0f-4532-49a3-8334-29c8ac681bdd",
        "authorId" : "d8c7cf80-a55a-474c-a4f4-f60a9efda52c",
        "body" : "Makes sense.",
        "createdAt" : "2020-04-08T16:32:19Z",
        "updatedAt" : "2020-04-08T16:32:19Z",
        "lastEditedBy" : "d8c7cf80-a55a-474c-a4f4-f60a9efda52c",
        "tags" : [
        ]
      }
    ],
    "commit" : "a362b45b814a5712861d7eca66f1453361aa1bff",
    "line" : 19,
    "diffHunk" : "@@ -1,1 +148,152 @@        int end = this.start + position + size;\n        // handle integer overflow or if end is beyond the end of the file\n        if (end < 0 || end > start + currentSizeInBytes)\n            end = start + currentSizeInBytes;\n        return new FileRecords(file, channel, this.start + position, end, true);"
  },
  {
    "id" : "b1226412-e57c-4a24-b405-14d094ced4b8",
    "prId" : 9819,
    "prUrl" : "https://github.com/apache/kafka/pull/9819#pullrequestreview-575096217",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "603f1680-4d1f-4959-bfbb-b98f58338c1f",
        "parentId" : null,
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "Can we add method documentation? I think the key thing to note is that this method is reserved for cases where the position is not necessarily on an offset boundary. It is worth mentioning the `FetchSnapshot` use case explicitly.",
        "createdAt" : "2021-01-25T06:34:47Z",
        "updatedAt" : "2021-01-26T08:26:00Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      }
    ],
    "commit" : "d75d65b77e2a8ea36e0a236e46a8b11c3316ba20",
    "line" : 20,
    "diffHunk" : "@@ -1,1 +151,155 @@     * @return A unaligned slice of records on this message set limited based on the given position and size\n     */\n    public UnalignedFileRecords sliceUnaligned(int position, int size) {\n        int availableBytes = availableBytes(position, size);\n        return new UnalignedFileRecords(channel, this.start + position, availableBytes);"
  },
  {
    "id" : "372926b8-fe7d-44ba-a9f4-de1a95e2e832",
    "prId" : 9970,
    "prUrl" : "https://github.com/apache/kafka/pull/9970#pullrequestreview-576672965",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "821a8d2d-2b5e-4476-a8ef-26239751b0ba",
        "parentId" : null,
        "authorId" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "body" : "This code is called from SocketServer through RecordsSend. The expectation is that the underlying file channel has enough bytes to return for the requested length. Normally this should be the case. If for some reason this is not true, by bounding the transfer amount by the remaining bytes in the file channel will cause RecordsSend.writeTo() to be called in a loop until the request times out. This may hide a real problem.\r\n\r\nPerhaps what we could do is to throw an IllegalStateException if the file channel doesn't have enough bytes left. This will cause the socket channel to be closed and the Selector to log a warning.",
        "createdAt" : "2021-01-26T18:45:30Z",
        "updatedAt" : "2021-01-26T18:45:50Z",
        "lastEditedBy" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "tags" : [
        ]
      },
      {
        "id" : "4c440e49-c6a7-4557-87e9-9b00433b0a0a",
        "parentId" : "821a8d2d-2b5e-4476-a8ef-26239751b0ba",
        "authorId" : "0f776378-bb23-4193-9bb0-1db5973f3781",
        "body" : "> Perhaps what we could do is to throw an IllegalStateException if the file channel doesn't have enough bytes left. This will cause the socket channel to be closed and the Selector to log a warning.\r\n\r\nPlease update docs for related ```writeTo``` methods if we want to apply this behavior. The current code use return value to calculate the length for next write. The return value gets redundant since the number of transferred data is always equal to expected length (it throws exception when there is no enough bytes left).",
        "createdAt" : "2021-01-26T19:08:54Z",
        "updatedAt" : "2021-01-26T19:08:54Z",
        "lastEditedBy" : "0f776378-bb23-4193-9bb0-1db5973f3781",
        "tags" : [
        ]
      }
    ],
    "commit" : "5864444650a74b2dbd817ef952ff92bdab325df1",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +279,283 @@\n        long position = start + offset;\n        long count = Math.min(length, oldSize - offset);\n        return destChannel.transferFrom(channel, position, count);\n    }"
  }
]
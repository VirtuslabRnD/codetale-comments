[
  {
    "id" : "4320bd76-6100-400e-a151-1db93f4732b6",
    "prId" : 5169,
    "prUrl" : "https://github.com/apache/kafka/pull/5169#pullrequestreview-129788939",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "94c51677-3cec-4f5f-843e-753ca53858d3",
        "parentId" : null,
        "authorId" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "body" : "We need to change the return value in java doc.",
        "createdAt" : "2018-06-19T01:36:08Z",
        "updatedAt" : "2018-06-19T15:58:05Z",
        "lastEditedBy" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "tags" : [
        ]
      }
    ],
    "commit" : "c71b1e5937a33e525f483cd5d2edaa925fa68ccb",
    "line" : 9,
    "diffHunk" : "@@ -1,1 +113,117 @@     * possible exceptions\n     */\n    public void readInto(ByteBuffer buffer, int position) throws IOException {\n        Utils.readFully(channel, buffer, position + this.start);\n        buffer.flip();"
  },
  {
    "id" : "d6011435-324d-444c-ad98-5be813c30fff",
    "prId" : 8451,
    "prUrl" : "https://github.com/apache/kafka/pull/8451#pullrequestreview-390140549",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "854f2b0f-4532-49a3-8334-29c8ac681bdd",
        "parentId" : null,
        "authorId" : "d8c7cf80-a55a-474c-a4f4-f60a9efda52c",
        "body" : "Was the boundary check wrong? You changed `>=` to `>`.",
        "createdAt" : "2020-04-08T16:16:17Z",
        "updatedAt" : "2020-04-08T16:16:18Z",
        "lastEditedBy" : "d8c7cf80-a55a-474c-a4f4-f60a9efda52c",
        "tags" : [
        ]
      },
      {
        "id" : "c55dd661-774c-404c-81b2-0bdd13d51fc7",
        "parentId" : "854f2b0f-4532-49a3-8334-29c8ac681bdd",
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "The common case that we would see this is when the limit matches the file end exactly. So changing this to `>` would also have fixed this problem for that case. I decided to remove it here though just because the equality check is redundant (if `end == start + currentSizeInBytes`, then there's no need to update it).",
        "createdAt" : "2020-04-08T16:23:54Z",
        "updatedAt" : "2020-04-08T16:37:10Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      },
      {
        "id" : "ec0836ab-70a6-477b-8ca3-cb8a991abfc5",
        "parentId" : "854f2b0f-4532-49a3-8334-29c8ac681bdd",
        "authorId" : "d8c7cf80-a55a-474c-a4f4-f60a9efda52c",
        "body" : "Makes sense.",
        "createdAt" : "2020-04-08T16:32:19Z",
        "updatedAt" : "2020-04-08T16:32:19Z",
        "lastEditedBy" : "d8c7cf80-a55a-474c-a4f4-f60a9efda52c",
        "tags" : [
        ]
      }
    ],
    "commit" : "a362b45b814a5712861d7eca66f1453361aa1bff",
    "line" : 19,
    "diffHunk" : "@@ -1,1 +148,152 @@        int end = this.start + position + size;\n        // handle integer overflow or if end is beyond the end of the file\n        if (end < 0 || end > start + currentSizeInBytes)\n            end = start + currentSizeInBytes;\n        return new FileRecords(file, channel, this.start + position, end, true);"
  },
  {
    "id" : "b1226412-e57c-4a24-b405-14d094ced4b8",
    "prId" : 9819,
    "prUrl" : "https://github.com/apache/kafka/pull/9819#pullrequestreview-575096217",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "603f1680-4d1f-4959-bfbb-b98f58338c1f",
        "parentId" : null,
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "Can we add method documentation? I think the key thing to note is that this method is reserved for cases where the position is not necessarily on an offset boundary. It is worth mentioning the `FetchSnapshot` use case explicitly.",
        "createdAt" : "2021-01-25T06:34:47Z",
        "updatedAt" : "2021-01-26T08:26:00Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      }
    ],
    "commit" : "d75d65b77e2a8ea36e0a236e46a8b11c3316ba20",
    "line" : 20,
    "diffHunk" : "@@ -1,1 +151,155 @@     * @return A unaligned slice of records on this message set limited based on the given position and size\n     */\n    public UnalignedFileRecords sliceUnaligned(int position, int size) {\n        int availableBytes = availableBytes(position, size);\n        return new UnalignedFileRecords(channel, this.start + position, availableBytes);"
  }
]
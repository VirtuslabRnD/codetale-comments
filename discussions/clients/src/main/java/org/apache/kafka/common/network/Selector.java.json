[
  {
    "id" : "e500e5e3-5f1e-45e2-b51d-b923a0b0eea8",
    "prId" : 4517,
    "prUrl" : "https://github.com/apache/kafka/pull/4517#pullrequestreview-95253153",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3c20e04b-111a-4502-80cb-fefbc87a6056",
        "parentId" : null,
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "The need for this check is a bit unfortunate since it makes the api a bit unsafe (kind of tough to tell at a glance that all current uses are safe, though I think they are). Since we have only three valid options, I was wondering if we could replace the two booleans with an enum representing the disconnect state or something. Not too big of a deal since it's internal, but might be worth considering.",
        "createdAt" : "2018-02-08T19:30:49Z",
        "updatedAt" : "2018-02-09T10:39:08Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      },
      {
        "id" : "7bf4cdab-b131-48b7-89bd-9f146bf94a7f",
        "parentId" : "3c20e04b-111a-4502-80cb-fefbc87a6056",
        "authorId" : "b4936a15-698a-496e-85a1-b1e229b4986b",
        "body" : "@hachikuji Thanks for the review. Updated to use an enum. Can you do another quick review? If it looks ok, I will merge and backport when the tests complete.",
        "createdAt" : "2018-02-08T22:16:05Z",
        "updatedAt" : "2018-02-09T10:39:08Z",
        "lastEditedBy" : "b4936a15-698a-496e-85a1-b1e229b4986b",
        "tags" : [
        ]
      }
    ],
    "commit" : "5dd275a7572161e62276ea38a4a8a81ee6593cc0",
    "line" : 78,
    "diffHunk" : "@@ -1,1 +704,708 @@    private void close(KafkaChannel channel, boolean processOutstanding, boolean notifyDisconnect) {\n\n        if (processOutstanding && !notifyDisconnect)\n            throw new IllegalStateException(\"Disconnect notification required for remote disconnect after processing outstanding requests\");\n"
  },
  {
    "id" : "c917e844-8907-4d9b-992f-1aeeda2355c3",
    "prId" : 5582,
    "prUrl" : "https://github.com/apache/kafka/pull/5582#pullrequestreview-160565733",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e1d255ea-3e0e-4b60-8c7a-b05e610c2fda",
        "parentId" : null,
        "authorId" : "b4936a15-698a-496e-85a1-b1e229b4986b",
        "body" : "Add `-ms` to the metric names?",
        "createdAt" : "2018-10-01T11:53:24Z",
        "updatedAt" : "2018-10-25T19:47:00Z",
        "lastEditedBy" : "b4936a15-698a-496e-85a1-b1e229b4986b",
        "tags" : [
        ]
      },
      {
        "id" : "f3cc0e76-6d66-4e4d-8483-fb3d31605d39",
        "parentId" : "e1d255ea-3e0e-4b60-8c7a-b05e610c2fda",
        "authorId" : "e0554c25-f6f3-4e49-a325-bcc5d4dc5fb2",
        "body" : "`request-latency-avg` and `request-latency-max` don't have it (neither do `commit-latency`, `poll-latency`, and `process-latency` metrics). Assume this means it should remain as-is.",
        "createdAt" : "2018-10-02T04:48:06Z",
        "updatedAt" : "2018-10-25T19:47:00Z",
        "lastEditedBy" : "e0554c25-f6f3-4e49-a325-bcc5d4dc5fb2",
        "tags" : [
        ]
      }
    ],
    "commit" : "9c30b80b2b29b7f5c86af21fd19fc520cfe798db",
    "line" : 89,
    "diffHunk" : "@@ -1,1 +1054,1058 @@\n            this.reauthenticationLatency = sensor(\"reauthentication-latency:\" + tagsSuffix);\n            MetricName reauthenticationLatencyMaxMetricName = metrics.metricName(\"reauthentication-latency-max\",\n                    metricGrpName, \"The max latency observed due to re-authentication\",\n                    metricTags);"
  },
  {
    "id" : "9ba37241-65e3-4fe8-aeba-72b2ea7090b9",
    "prId" : 5856,
    "prUrl" : "https://github.com/apache/kafka/pull/5856#pullrequestreview-190742064",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "716639be-146b-438a-8433-55c582144b85",
        "parentId" : null,
        "authorId" : "d8c7cf80-a55a-474c-a4f4-f60a9efda52c",
        "body" : "Can we swap the `if/else` so that we don't have to negate the first `if`? That seems unnecessarily confusing.",
        "createdAt" : "2019-01-09T14:09:48Z",
        "updatedAt" : "2019-01-09T15:39:33Z",
        "lastEditedBy" : "d8c7cf80-a55a-474c-a4f4-f60a9efda52c",
        "tags" : [
        ]
      }
    ],
    "commit" : "7f0612ce2aab356559c101d1969d0ab46188e5c2",
    "line" : 9,
    "diffHunk" : "@@ -1,1 +535,539 @@                        boolean isReauthentication = channel.successfulAuthentications() > 0;\n                        if (isReauthentication)\n                            sensors.failedReauthentication.record();\n                        else\n                            sensors.failedAuthentication.record();"
  },
  {
    "id" : "4ee9a661-562e-40a2-82d6-a3797c6ae867",
    "prId" : 5920,
    "prUrl" : "https://github.com/apache/kafka/pull/5920#pullrequestreview-335461511",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8d13c59a-fdbe-44ae-9dd4-85b3bc686835",
        "parentId" : null,
        "authorId" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "body" : "Do we need to check hasCompletedReceive here? completedReceives is cleared after each poll and the same socket key is never polled more than once within each poll.",
        "createdAt" : "2019-02-21T02:30:38Z",
        "updatedAt" : "2020-01-12T16:09:00Z",
        "lastEditedBy" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "tags" : [
        ]
      },
      {
        "id" : "1f1ad284-512d-4f4b-b671-9e077a90e2b8",
        "parentId" : "8d13c59a-fdbe-44ae-9dd4-85b3bc686835",
        "authorId" : "b4936a15-698a-496e-85a1-b1e229b4986b",
        "body" : "We need the check because the reauthentication code above may add a completed receive.",
        "createdAt" : "2019-12-20T19:00:53Z",
        "updatedAt" : "2020-01-12T16:09:00Z",
        "lastEditedBy" : "b4936a15-698a-496e-85a1-b1e229b4986b",
        "tags" : [
        ]
      }
    ],
    "commit" : "aa849a468dc6e5e693bdeeb9625678db4102e84a",
    "line" : 104,
    "diffHunk" : "@@ -1,1 +576,580 @@                //if channel is ready and has bytes to read from socket or buffer, and has no\n                //previous completed receive then read from it\n                if (channel.ready() && (key.isReadable() || channel.hasBytesBuffered()) && !hasCompletedReceive(channel)\n                        && !explicitlyMutedChannels.contains(channel)) {\n                    attemptRead(channel);"
  },
  {
    "id" : "44272fb6-6967-473f-bd58-3c351525955c",
    "prId" : 5920,
    "prUrl" : "https://github.com/apache/kafka/pull/5920#pullrequestreview-335462682",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "77fd3bbd-6cdc-41fd-8682-7a2b84dd43e9",
        "parentId" : null,
        "authorId" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "body" : "Not sure why we need to set the channel state here. If channel.ready() is true, it seems that channel.state() should be READY?",
        "createdAt" : "2019-02-21T02:48:43Z",
        "updatedAt" : "2020-01-12T16:09:00Z",
        "lastEditedBy" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "tags" : [
        ]
      },
      {
        "id" : "2ace0a9c-bafe-4fb8-aba1-0db65c9dd393",
        "parentId" : "77fd3bbd-6cdc-41fd-8682-7a2b84dd43e9",
        "authorId" : "b4936a15-698a-496e-85a1-b1e229b4986b",
        "body" : "We don't currently set channel state to READY (and nothing relies on it). But since it is good to set the state anyway, I added this code.",
        "createdAt" : "2019-12-20T19:03:26Z",
        "updatedAt" : "2020-01-12T16:09:00Z",
        "lastEditedBy" : "b4936a15-698a-496e-85a1-b1e229b4986b",
        "tags" : [
        ]
      }
    ],
    "commit" : "aa849a468dc6e5e693bdeeb9625678db4102e84a",
    "line" : 95,
    "diffHunk" : "@@ -1,1 +567,571 @@                }\n                if (channel.ready() && channel.state() == ChannelState.NOT_CONNECTED)\n                    channel.state(ChannelState.READY);\n                Optional<NetworkReceive> responseReceivedDuringReauthentication = channel.pollResponseReceivedDuringReauthentication();\n                responseReceivedDuringReauthentication.ifPresent(receive -> {"
  },
  {
    "id" : "7b774110-1527-49a1-bc3d-1887b6bc2b5a",
    "prId" : 5920,
    "prUrl" : "https://github.com/apache/kafka/pull/5920#pullrequestreview-335463203",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8b23b1eb-15c2-41dd-8d55-5081d187c3b3",
        "parentId" : null,
        "authorId" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "body" : "Is the ordering of the map important?",
        "createdAt" : "2019-02-21T20:10:15Z",
        "updatedAt" : "2020-01-12T16:09:00Z",
        "lastEditedBy" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "tags" : [
        ]
      },
      {
        "id" : "ab433c47-7127-4b16-b8e4-e037c37b164f",
        "parentId" : "8b23b1eb-15c2-41dd-8d55-5081d187c3b3",
        "authorId" : "b4936a15-698a-496e-85a1-b1e229b4986b",
        "body" : "No, but we used to return a List before, so this retains the order.",
        "createdAt" : "2019-12-20T19:04:41Z",
        "updatedAt" : "2020-01-12T16:09:00Z",
        "lastEditedBy" : "b4936a15-698a-496e-85a1-b1e229b4986b",
        "tags" : [
        ]
      }
    ],
    "commit" : "aa849a468dc6e5e693bdeeb9625678db4102e84a",
    "line" : 34,
    "diffHunk" : "@@ -1,1 +108,112 @@    private boolean outOfMemory;\n    private final List<Send> completedSends;\n    private final LinkedHashMap<KafkaChannel, NetworkReceive> completedReceives;\n    private final Set<SelectionKey> immediatelyConnectedKeys;\n    private final Map<String, KafkaChannel> closingChannels;"
  },
  {
    "id" : "66209aa8-d5b2-4a41-ad14-d5faf73c7b1d",
    "prId" : 5920,
    "prUrl" : "https://github.com/apache/kafka/pull/5920#pullrequestreview-340683207",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "515e4d8f-2ab9-42b9-a4ce-fa46f8ab993a",
        "parentId" : null,
        "authorId" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "body" : "This is an existing issue. The line above, \"we've have\" => \"we have\".",
        "createdAt" : "2020-01-09T17:15:06Z",
        "updatedAt" : "2020-01-12T16:09:00Z",
        "lastEditedBy" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "tags" : [
        ]
      }
    ],
    "commit" : "aa849a468dc6e5e693bdeeb9625678db4102e84a",
    "line" : 58,
    "diffHunk" : "@@ -1,1 +427,431 @@     * application buffer size. This means we might be reading additional bytes than the requested size.\n     * If there is no further data to read from socketChannel selector won't invoke that channel and we have additional bytes\n     * in the buffer. To overcome this issue we added \"keysWithBufferedRead\" map which tracks channels which have data in the SSL\n     * buffers. If there are channels with buffered data that can by processed, we set \"timeout\" to 0 and process the data even\n     * if there is no more data to read from the socket."
  },
  {
    "id" : "ba98f34f-a17c-4b1c-87fd-6a48925db100",
    "prId" : 5920,
    "prUrl" : "https://github.com/apache/kafka/pull/5920#pullrequestreview-341584377",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8ff71c52-77dc-4e04-9887-9dd9c1fb2806",
        "parentId" : null,
        "authorId" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "body" : "This is probably not a concern, but the current logic means that the pending reads in closingChannels could be delayed by the selector timeout.",
        "createdAt" : "2020-01-09T19:06:52Z",
        "updatedAt" : "2020-01-12T16:09:00Z",
        "lastEditedBy" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "tags" : [
        ]
      },
      {
        "id" : "b021dbb9-ea9f-4208-b9ab-5d29b755f910",
        "parentId" : "8ff71c52-77dc-4e04-9887-9dd9c1fb2806",
        "authorId" : "b4936a15-698a-496e-85a1-b1e229b4986b",
        "body" : "Yes, I can't think of an easy way to fix that unfortunately.",
        "createdAt" : "2020-01-12T16:10:18Z",
        "updatedAt" : "2020-01-12T16:10:19Z",
        "lastEditedBy" : "b4936a15-698a-496e-85a1-b1e229b4986b",
        "tags" : [
        ]
      }
    ],
    "commit" : "aa849a468dc6e5e693bdeeb9625678db4102e84a",
    "line" : 69,
    "diffHunk" : "@@ -1,1 +451,455 @@        boolean dataInBuffers = !keysWithBufferedRead.isEmpty();\n\n        if (!immediatelyConnectedKeys.isEmpty() || (madeReadProgressLastCall && dataInBuffers))\n            timeout = 0;\n"
  },
  {
    "id" : "3216348b-1d79-4f51-a73d-48dbbe151f79",
    "prId" : 7749,
    "prUrl" : "https://github.com/apache/kafka/pull/7749#pullrequestreview-331785092",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4a7478ab-dae0-4327-88a4-ad4ea97aee44",
        "parentId" : null,
        "authorId" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "body" : "If this already exists, we should check to see if it's equal to the new information we wanted to register.  If it is, we can skip the decrement metric + increment metric dance.",
        "createdAt" : "2019-12-12T17:23:51Z",
        "updatedAt" : "2019-12-13T11:08:14Z",
        "lastEditedBy" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "tags" : [
        ]
      },
      {
        "id" : "b3ea5651-b6b8-41a9-a19e-87586f8df173",
        "parentId" : "4a7478ab-dae0-4327-88a4-ad4ea97aee44",
        "authorId" : "59ca7821-b29c-4f24-a9d5-cbd394145686",
        "body" : "Ack. That makes sense.",
        "createdAt" : "2019-12-13T10:29:47Z",
        "updatedAt" : "2019-12-13T11:08:14Z",
        "lastEditedBy" : "59ca7821-b29c-4f24-a9d5-cbd394145686",
        "tags" : [
        ]
      }
    ],
    "commit" : "1f4dd576d146b8eb3ca2d543f3f537c506c591b7",
    "line" : 79,
    "diffHunk" : "@@ -1,1 +1093,1097 @@        @Override\n        public void registerClientInformation(final ClientInformation clientInformation) {\n            if (this.clientInformation != null) {\n                if (this.clientInformation.equals(clientInformation))\n                    return;"
  },
  {
    "id" : "4159d4db-1444-4a88-abb0-c935ca805bb7",
    "prId" : 7749,
    "prUrl" : "https://github.com/apache/kafka/pull/7749#pullrequestreview-331785360",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1def72a8-0ec8-4a30-8c83-8c1df38be39d",
        "parentId" : null,
        "authorId" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "body" : "It would be good to make this consistent with `registerClientInformation` by making it re-register the cipher information if appropriate (and if the new information is different).\r\n\r\nQuestion for @rajinisivaram: can the SSL cipher of a connection change when an SSL handshake is done on an already established SSL connection?",
        "createdAt" : "2019-12-12T17:25:24Z",
        "updatedAt" : "2019-12-13T11:08:14Z",
        "lastEditedBy" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "tags" : [
        ]
      },
      {
        "id" : "089f9aae-29a6-44fb-93c1-b957b1ae58d5",
        "parentId" : "1def72a8-0ec8-4a30-8c83-8c1df38be39d",
        "authorId" : "59ca7821-b29c-4f24-a9d5-cbd394145686",
        "body" : "I don't think the cipher could change but I will do it to stay consistent.",
        "createdAt" : "2019-12-13T10:30:19Z",
        "updatedAt" : "2019-12-13T11:08:14Z",
        "lastEditedBy" : "59ca7821-b29c-4f24-a9d5-cbd394145686",
        "tags" : [
        ]
      }
    ],
    "commit" : "1f4dd576d146b8eb3ca2d543f3f537c506c591b7",
    "line" : 61,
    "diffHunk" : "@@ -1,1 +1075,1079 @@\n        @Override\n        public void registerCipherInformation(final CipherInformation cipherInformation) {\n            if (this.cipherInformation != null) {\n                if (this.cipherInformation.equals(cipherInformation))"
  },
  {
    "id" : "b8e25d08-1ea5-4f3e-b8b9-ff9b4df7cbbe",
    "prId" : 8685,
    "prUrl" : "https://github.com/apache/kafka/pull/8685#pullrequestreview-425901202",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8bf3efd1-9f7b-46a8-befe-2304aad25030",
        "parentId" : null,
        "authorId" : "d8c7cf80-a55a-474c-a4f4-f60a9efda52c",
        "body" : "Have we considered using `Utils.closeAll` instead of multiple `closeQuietly`?",
        "createdAt" : "2020-05-18T19:34:55Z",
        "updatedAt" : "2020-06-08T03:53:02Z",
        "lastEditedBy" : "d8c7cf80-a55a-474c-a4f4-f60a9efda52c",
        "tags" : [
        ]
      },
      {
        "id" : "684f2163-6b21-4ebc-bf9e-30d6532b77ce",
        "parentId" : "8bf3efd1-9f7b-46a8-befe-2304aad25030",
        "authorId" : "0f776378-bb23-4193-9bb0-1db5973f3781",
        "body" : "```Utils.closeAll``` handle only ```IOException``` and it throws exception instead of keeping exception. Hence, it is not suitable to this case. ",
        "createdAt" : "2020-05-19T07:39:07Z",
        "updatedAt" : "2020-06-08T03:53:02Z",
        "lastEditedBy" : "0f776378-bb23-4193-9bb0-1db5973f3781",
        "tags" : [
        ]
      },
      {
        "id" : "58272c65-8bf4-481a-b707-6975c48c385f",
        "parentId" : "8bf3efd1-9f7b-46a8-befe-2304aad25030",
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "Would it make sense to have a `closeAllQuietly`?",
        "createdAt" : "2020-06-07T21:25:38Z",
        "updatedAt" : "2020-06-08T03:53:02Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      },
      {
        "id" : "82c09fed-c906-40e9-bdc0-d66fcba44b82",
        "parentId" : "8bf3efd1-9f7b-46a8-befe-2304aad25030",
        "authorId" : "0f776378-bb23-4193-9bb0-1db5973f3781",
        "body" : "> Would it make sense to have a closeAllQuietly?\r\n\r\ncopy that",
        "createdAt" : "2020-06-08T03:52:07Z",
        "updatedAt" : "2020-06-08T03:53:02Z",
        "lastEditedBy" : "0f776378-bb23-4193-9bb0-1db5973f3781",
        "tags" : [
        ]
      }
    ],
    "commit" : "665e7efd171a17ef783ec82bb87cde17b7deb5d7",
    "line" : 21,
    "diffHunk" : "@@ -1,1 +364,368 @@    public void close() {\n        List<String> connections = new ArrayList<>(channels.keySet());\n        AtomicReference<Throwable> firstException = new AtomicReference<>();\n        Utils.closeAllQuietly(firstException, \"release connections\",\n                connections.stream().map(id -> (AutoCloseable) () -> close(id)).toArray(AutoCloseable[]::new));"
  }
]
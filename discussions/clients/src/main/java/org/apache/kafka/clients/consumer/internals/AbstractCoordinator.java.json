[
  {
    "id" : "1aba31c0-c027-4708-b34b-ff7938d6f7e7",
    "prId" : 4349,
    "prUrl" : "https://github.com/apache/kafka/pull/4349#pullrequestreview-84959068",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f84f48f7-57d0-44dc-bd42-426a6db57b94",
        "parentId" : null,
        "authorId" : "0c73d886-f3da-4107-8045-92d8e3c8fb75",
        "body" : "Shouldn't coordinator be declared volatile ?",
        "createdAt" : "2017-12-21T02:20:43Z",
        "updatedAt" : "2018-01-19T21:01:27Z",
        "lastEditedBy" : "0c73d886-f3da-4107-8045-92d8e3c8fb75",
        "tags" : [
        ]
      },
      {
        "id" : "d5d40ca6-4852-453f-bee1-ce3e82808efd",
        "parentId" : "f84f48f7-57d0-44dc-bd42-426a6db57b94",
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "I don't see any references outside of the lock.",
        "createdAt" : "2017-12-21T03:13:58Z",
        "updatedAt" : "2018-01-19T21:01:27Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      }
    ],
    "commit" : "33e2c04b0b91081d41114b3971db75109f88ac54",
    "line" : 69,
    "diffHunk" : "@@ -1,1 +654,658 @@            // requests may attempt to do likewise. This also prevents new requests from being sent to the\n            // coordinator while the disconnect is in progress.\n            this.coordinator = null;\n\n            // Disconnect from the coordinator to ensure that there are no in-flight requests remaining."
  },
  {
    "id" : "3cc6e414-0065-44fe-a88c-cf2c81f5ffcd",
    "prId" : 4625,
    "prUrl" : "https://github.com/apache/kafka/pull/4625#pullrequestreview-100542543",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d065a762-0e1d-4f04-8d9a-ddf373766f2b",
        "parentId" : null,
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "Nice separation.",
        "createdAt" : "2018-03-01T00:31:12Z",
        "updatedAt" : "2018-03-01T16:39:19Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "7a65ed99-c440-4ffa-aa72-b5776fa3296b",
        "parentId" : "d065a762-0e1d-4f04-8d9a-ddf373766f2b",
        "authorId" : "d8c7cf80-a55a-474c-a4f4-f60a9efda52c",
        "body" : "Wouldn't it be more readable if there was also a method for the disconnected = true case?",
        "createdAt" : "2018-03-01T18:32:23Z",
        "updatedAt" : "2018-03-01T18:32:23Z",
        "lastEditedBy" : "d8c7cf80-a55a-474c-a4f4-f60a9efda52c",
        "tags" : [
        ]
      }
    ],
    "commit" : "e789bcb63bead18998d51218f58ad8f8ab366c92",
    "line" : 71,
    "diffHunk" : "@@ -1,1 +649,653 @@    }\n\n    protected synchronized void markCoordinatorUnknown() {\n        markCoordinatorUnknown(false);\n    }"
  },
  {
    "id" : "e802ce23-103c-41dc-9ebe-552eebbecce3",
    "prId" : 4855,
    "prUrl" : "https://github.com/apache/kafka/pull/4855#pullrequestreview-122280843",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a5440c90-0b84-4e78-acf2-7297906149b3",
        "parentId" : null,
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "again, preserving the old indefinite block.",
        "createdAt" : "2018-05-22T18:55:32Z",
        "updatedAt" : "2018-05-26T00:00:49Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      }
    ],
    "commit" : "c3fce0f22e8b12e03475212b2bf07e69bc230362",
    "line" : 103,
    "diffHunk" : "@@ -1,1 +310,314 @@        while (!ensureActiveGroup(Long.MAX_VALUE)) {\n            log.warn(\"still waiting to ensure active group\");\n        }\n    }\n"
  },
  {
    "id" : "48721cb9-3039-4414-bef0-4441c206c98a",
    "prId" : 4855,
    "prUrl" : "https://github.com/apache/kafka/pull/4855#pullrequestreview-123526042",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3f3a221e-dcb5-4901-a78f-048f6c0291e8",
        "parentId" : null,
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "We should probably update the javadoc",
        "createdAt" : "2018-05-25T22:18:23Z",
        "updatedAt" : "2018-05-26T00:00:49Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      }
    ],
    "commit" : "c3fce0f22e8b12e03475212b2bf07e69bc230362",
    "line" : 91,
    "diffHunk" : "@@ -1,1 +266,270 @@     * @return true if it should, false otherwise\n     */\n    protected synchronized boolean rejoinNeededOrPending() {\n        // if there's a pending joinFuture, we should try to complete handling it.\n        return rejoinNeeded || joinFuture != null;"
  },
  {
    "id" : "3ac8ddfa-f2c8-4a77-9a83-5da3a8cbd89f",
    "prId" : 5087,
    "prUrl" : "https://github.com/apache/kafka/pull/5087#pullrequestreview-142907077",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "427cad52-4dbe-4c54-81db-73d3e810ea21",
        "parentId" : null,
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "This is a bit overkill, but I agree it is cleaner..",
        "createdAt" : "2018-08-02T18:47:17Z",
        "updatedAt" : "2018-08-03T20:47:50Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      }
    ],
    "commit" : "0ef469881a5e14aecbaa3dbe890d30335c2c75a8",
    "line" : 184,
    "diffHunk" : "@@ -1,1 +747,751 @@    @Override\n    public final void close() {\n        close(time.timer(0));\n    }\n"
  },
  {
    "id" : "5da44ed8-eb71-4e71-a1eb-3294d7cfdfd6",
    "prId" : 6058,
    "prUrl" : "https://github.com/apache/kafka/pull/6058#pullrequestreview-188361649",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "077d5b2b-5206-429f-a1be-ede114b2873c",
        "parentId" : null,
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "Can we add a unit test to verify this path?",
        "createdAt" : "2018-12-22T22:52:00Z",
        "updatedAt" : "2019-01-15T03:26:21Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      },
      {
        "id" : "27380800-756e-42d3-a0fc-25cfdfd71493",
        "parentId" : "077d5b2b-5206-429f-a1be-ede114b2873c",
        "authorId" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "body" : "The changes I made to the #joinGroup function in GroupCoordinatorTest is actually serving as the unit test for this logic.",
        "createdAt" : "2018-12-23T05:18:51Z",
        "updatedAt" : "2019-01-15T03:26:21Z",
        "lastEditedBy" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "tags" : [
        ]
      },
      {
        "id" : "c5a7983d-b895-440a-87af-f1e34e78272d",
        "parentId" : "077d5b2b-5206-429f-a1be-ede114b2873c",
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "Yeah, I was referring to the testing of the client-side logic. It should be possible to modify one of the existing tests in either `AbstractCoordinatorTest` or `ConsumerCoordinatorTest`.",
        "createdAt" : "2018-12-28T18:35:46Z",
        "updatedAt" : "2019-01-15T03:26:21Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      },
      {
        "id" : "e6d244db-452c-4e07-b80e-b7cfb975d2b7",
        "parentId" : "077d5b2b-5206-429f-a1be-ede114b2873c",
        "authorId" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "body" : "Sound goodÔºÅ",
        "createdAt" : "2018-12-28T20:07:41Z",
        "updatedAt" : "2019-01-15T03:26:21Z",
        "lastEditedBy" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "tags" : [
        ]
      }
    ],
    "commit" : "29f668ef1a9b2ee5939791b9bd5b89bf1a1660bb",
    "line" : 22,
    "diffHunk" : "@@ -1,1 +551,555 @@            } else if (error == Errors.GROUP_AUTHORIZATION_FAILED) {\n                future.raise(new GroupAuthorizationException(groupId));\n            } else if (error == Errors.MEMBER_ID_REQUIRED) {\n                // Broker requires a concrete member id to be allowed to join the group. Update member id\n                // and send another join group request in next cycle."
  },
  {
    "id" : "422f0622-d73b-43a2-aa1e-841968a7c679",
    "prId" : 6163,
    "prUrl" : "https://github.com/apache/kafka/pull/6163#pullrequestreview-198714870",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f5d08771-300e-4471-84ba-7205752ccb0a",
        "parentId" : null,
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "If we have to handle this separately, maybe we could move the check to the top level like the `GROUP_AUTHORIZATION` check.",
        "createdAt" : "2019-01-24T17:32:34Z",
        "updatedAt" : "2019-02-01T23:36:21Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      },
      {
        "id" : "da8bc85d-8437-4977-857f-a2db885c5d56",
        "parentId" : "f5d08771-300e-4471-84ba-7205752ccb0a",
        "authorId" : "df911192-d6c6-4af9-8568-f67bf2dcf926",
        "body" : "I think it would be good to have the log\r\n```\r\nlog.error(\"Attempt to join group failed due to fatal error: {}\", error.message());\r\n```\r\n\r\nMaybe we could move the `GROUP_AUTHORIZATION` to this level?",
        "createdAt" : "2019-01-31T17:21:39Z",
        "updatedAt" : "2019-02-01T23:36:21Z",
        "lastEditedBy" : "df911192-d6c6-4af9-8568-f67bf2dcf926",
        "tags" : [
        ]
      }
    ],
    "commit" : "1421a43a3fcf28c99477bea7a1499a8fa17e50d9",
    "line" : 21,
    "diffHunk" : "@@ -1,1 +551,555 @@                    || error == Errors.GROUP_MAX_SIZE_REACHED) {\n                log.error(\"Attempt to join group failed due to fatal error: {}\", error.message());\n                if (error == Errors.GROUP_MAX_SIZE_REACHED) {\n                    future.raise(new GroupMaxSizeReachedException(groupId));\n                } else if (error == Errors.GROUP_AUTHORIZATION_FAILED) {"
  },
  {
    "id" : "15b17f5b-ec5e-4c47-a00f-cd492082c063",
    "prId" : 6177,
    "prUrl" : "https://github.com/apache/kafka/pull/6177#pullrequestreview-229169855",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "71c219b2-938d-4808-9c49-01432f1a5bc7",
        "parentId" : null,
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "Hmm.. This method is also called when a call to `unsubscribe()` is made. Would we not want a static member to leave in this case?",
        "createdAt" : "2019-04-09T22:22:41Z",
        "updatedAt" : "2019-04-26T15:12:49Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      },
      {
        "id" : "62d91cfa-f892-44ab-9bf4-3bfa23f9a84e",
        "parentId" : "71c219b2-938d-4808-9c49-01432f1a5bc7",
        "authorId" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "body" : "I quickly checked `unsubscribe()` use cases, and there are mainly two:\r\n1. illegal topic/partition data, i.e empty topic partitions to subscribe\r\n2. consumer self managed membership (subscription)\r\n\r\nI think it makes sense to make static member behavior consistent in these two cases, because the effect of leaving is minimal.",
        "createdAt" : "2019-04-11T05:50:52Z",
        "updatedAt" : "2019-04-26T15:12:49Z",
        "lastEditedBy" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "tags" : [
        ]
      },
      {
        "id" : "9490d1fa-ee8e-4cc5-8b79-577afe028cd4",
        "parentId" : "71c219b2-938d-4808-9c49-01432f1a5bc7",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "I've thought about this a bit more, and also searched in github: https://github.com/search?l=Java&q=%22consumer.unsubscribe%22&type=Code\r\n\r\nI think a third common case is to use a temporary consumer for its APIs, like get offset by timestamp, get log end offset etc; generally speaking for temporary consumer case, they should not use static members (and by default it would not be the case). \r\n\r\nSo I think it really boils down to: for static members, do we consider the admin request kicking it out of the group be the only appropriate way for it to leave in time or not? I.e. even if the consumer shuts down itself, it should not be considered as \"I want to leave\" but another request has to be made to effectively kick him out.",
        "createdAt" : "2019-04-22T17:59:41Z",
        "updatedAt" : "2019-04-26T15:12:49Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      }
    ],
    "commit" : "932118542844c01e3caf657e2eee9c16dfd269d7",
    "line" : 78,
    "diffHunk" : "@@ -1,1 +830,834 @@     */\n    public synchronized void maybeLeaveGroup() {\n        // Starting from 2.3, only dynamic members will send LeaveGroupRequest to the broker,\n        // consumer with valid group.instance.id is viewed as static member that never sends LeaveGroup,\n        // and the membership expiration is only controlled by session timeout."
  },
  {
    "id" : "91aeb5ed-baa4-4f11-aa3f-b9ae7ca6b878",
    "prId" : 6251,
    "prUrl" : "https://github.com/apache/kafka/pull/6251#pullrequestreview-204539047",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c26a8046-d5a0-4e30-bda0-8844ec2089c2",
        "parentId" : null,
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "How much effort would it be to have a test case for this? We have a few  LeaveGroup tests in `ConsumerCoordinatorTest`.",
        "createdAt" : "2019-02-16T18:33:25Z",
        "updatedAt" : "2019-02-19T06:13:25Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      },
      {
        "id" : "a0a2d979-6116-4833-a777-5a096b5986ef",
        "parentId" : "c26a8046-d5a0-4e30-bda0-8844ec2089c2",
        "authorId" : "1462ba0d-5f6b-4517-98de-68943d892c2b",
        "body" : "this has been added. resolving comment.",
        "createdAt" : "2019-02-16T23:40:29Z",
        "updatedAt" : "2019-02-19T06:13:25Z",
        "lastEditedBy" : "1462ba0d-5f6b-4517-98de-68943d892c2b",
        "tags" : [
        ]
      }
    ],
    "commit" : "2102b7c04ffb64ba163904304f9ee7fb9dab3432",
    "line" : 21,
    "diffHunk" : "@@ -1,1 +817,821 @@     */\n    public synchronized void maybeLeaveGroup() {\n        if (!coordinatorUnknown() && state != MemberState.UNJOINED && generation.hasMemberId()) {\n            // this is a minimal effort attempt to leave the group. we do not\n            // attempt any resending if the request fails or times out."
  },
  {
    "id" : "3e578ee1-0f53-481b-9638-8b838981c030",
    "prId" : 6419,
    "prUrl" : "https://github.com/apache/kafka/pull/6419#pullrequestreview-215831148",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "314acdac-1a89-4ce2-8af3-0985cef82399",
        "parentId" : null,
        "authorId" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "body" : "Should this be a `JoinGroupResponseDataSet`?",
        "createdAt" : "2019-03-15T17:14:38Z",
        "updatedAt" : "2019-03-15T18:44:44Z",
        "lastEditedBy" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "tags" : [
        ]
      },
      {
        "id" : "e23ca5b5-02c3-41d9-b85b-8f0da58ae38b",
        "parentId" : "314acdac-1a89-4ce2-8af3-0985cef82399",
        "authorId" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "body" : "I don't see this struct anywhere, but I think a list should be fine here?",
        "createdAt" : "2019-03-15T18:44:18Z",
        "updatedAt" : "2019-03-15T18:44:44Z",
        "lastEditedBy" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "tags" : [
        ]
      },
      {
        "id" : "e506b65d-fad0-42b6-a959-4160c89ae1e3",
        "parentId" : "314acdac-1a89-4ce2-8af3-0985cef82399",
        "authorId" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "body" : "Sorry, I meant `JoinGroupResponseMemberSet`.  Anyway, a list is fine too-- I don't feel that strongly about it.",
        "createdAt" : "2019-03-18T20:21:24Z",
        "updatedAt" : "2019-03-18T20:21:24Z",
        "lastEditedBy" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "tags" : [
        ]
      }
    ],
    "commit" : "99578dc91d650a228e1f16b4b3c39d379329ace1",
    "line" : 40,
    "diffHunk" : "@@ -1,1 +204,208 @@    protected abstract Map<String, ByteBuffer> performAssignment(String leaderId,\n                                                                 String protocol,\n                                                                 List<JoinGroupResponseData.JoinGroupResponseMember> allMemberMetadata);\n\n    /**"
  },
  {
    "id" : "eedfaca6-0f9b-4391-b2cd-7022567667e9",
    "prId" : 6650,
    "prUrl" : "https://github.com/apache/kafka/pull/6650#pullrequestreview-235228193",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0c542359-bcce-4cc4-9462-2607885d476f",
        "parentId" : null,
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "Note that users's callback / future would see the fixed error message\r\n\r\n\"The coordinator reports a more recent member.id associated with the consumer's group.instance.id.\"\r\n\r\nI felt the above error message is more understandable to users, as \"a more recent member.id\" seems a bit confusing, maybe we can update that error message in `Errors` as well as this static log4j error message as:\r\n\r\n\"The broker rejected this static consumer since another instance with the same group.instance.id has registered with a more recent timestamp\".\r\n",
        "createdAt" : "2019-05-08T00:50:23Z",
        "updatedAt" : "2019-05-18T04:04:24Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "58638a94-b154-4e81-8b5b-3a5cc8460d92",
        "parentId" : "0c542359-bcce-4cc4-9462-2607885d476f",
        "authorId" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "body" : "Sounds good!",
        "createdAt" : "2019-05-08T18:47:14Z",
        "updatedAt" : "2019-05-18T04:04:24Z",
        "lastEditedBy" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "tags" : [
        ]
      }
    ],
    "commit" : "4a0c245434329139d931b0cc904704ef8c26a62c",
    "line" : 22,
    "diffHunk" : "@@ -1,1 +561,565 @@            } else if (error == Errors.FENCED_INSTANCE_ID) {\n                log.error(\"Received fatal exception: group.instance.id gets fenced\");\n                future.raise(error);\n            } else if (error == Errors.INCONSISTENT_GROUP_PROTOCOL\n                    || error == Errors.INVALID_SESSION_TIMEOUT"
  },
  {
    "id" : "828a2a97-b5dc-4a8c-b696-76b5c742c6e7",
    "prId" : 6650,
    "prUrl" : "https://github.com/apache/kafka/pull/6650#pullrequestreview-235368936",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9b7bf66d-9875-478c-af81-f334591261e3",
        "parentId" : null,
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "Similar to commit, if this error is thrown, then in `AbstractCoordinator#initiateJoinGroup`:\r\n\r\n```\r\n             public void onFailure(RuntimeException e) {\r\n                    // we handle failures below after the request finishes. if the join completes\r\n                    // after having been woken up, the exception is ignored and we will rejoin\r\n                    synchronized (AbstractCoordinator.this) {\r\n                        state = MemberState.UNJOINED;\r\n                    }\r\n                }\r\n```\r\n\r\nI.e. it will also be swallowed and retry. Should we instead let this consumer to fail by throwing this exception all the way up, like in KafkaProducer we throw `ProduceFencedException` all the way to the caller's face.",
        "createdAt" : "2019-05-08T01:12:37Z",
        "updatedAt" : "2019-05-18T04:04:24Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "71901d4f-f0ed-45d3-a734-dce9dcad15a6",
        "parentId" : "9b7bf66d-9875-478c-af81-f334591261e3",
        "authorId" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "body" : "I could see #initiateJoinGroup being called and we do check future later here for exceptions:\r\n```\r\n} else {\r\n                resetJoinGroupFuture();\r\n                final RuntimeException exception = future.exception();\r\n                if (exception instanceof UnknownMemberIdException ||\r\n                        exception instanceof RebalanceInProgressException ||\r\n                        exception instanceof IllegalGenerationException ||\r\n                        exception instanceof MemberIdRequiredException)\r\n                    continue;\r\n                else if (!future.isRetriable())\r\n                    throw exception;\r\n```\r\nSo my understanding is that we will not retry in the case, since the exception is thrown.",
        "createdAt" : "2019-05-08T18:54:26Z",
        "updatedAt" : "2019-05-18T04:04:24Z",
        "lastEditedBy" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "tags" : [
        ]
      },
      {
        "id" : "804afe4a-1b38-40f0-8ba5-b2d3058c06ad",
        "parentId" : "9b7bf66d-9875-478c-af81-f334591261e3",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "Ah makes sense.",
        "createdAt" : "2019-05-09T01:53:01Z",
        "updatedAt" : "2019-05-18T04:04:24Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      }
    ],
    "commit" : "4a0c245434329139d931b0cc904704ef8c26a62c",
    "line" : 64,
    "diffHunk" : "@@ -1,1 +666,670 @@                    log.debug(\"SyncGroup failed because the group began another rebalance\");\n                    future.raise(error);\n                } else if (error == Errors.FENCED_INSTANCE_ID) {\n                    log.error(\"Received fatal exception: group.instance.id gets fenced\");\n                    future.raise(error);"
  },
  {
    "id" : "f1f0281e-646f-4e8e-9a0c-82af0d1c3fe9",
    "prId" : 6650,
    "prUrl" : "https://github.com/apache/kafka/pull/6650#pullrequestreview-239175775",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f48e1c23-c5d4-4f18-8f09-5185c0b51edc",
        "parentId" : null,
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "If we are fenced, should we keep track of that somewhere so that we do not keep sending RPCs to the coordinator?",
        "createdAt" : "2019-05-17T15:07:20Z",
        "updatedAt" : "2019-05-18T04:04:24Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      },
      {
        "id" : "bdb5b5a2-78c2-4824-96a2-32525ae4ce64",
        "parentId" : "f48e1c23-c5d4-4f18-8f09-5185c0b51edc",
        "authorId" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "body" : "As long as we don't reset our generation info, all subsequent requests should be failing once other consumer joins the group right? Eventually this will lead to a complete crash IIUC.",
        "createdAt" : "2019-05-17T16:58:09Z",
        "updatedAt" : "2019-05-18T04:04:24Z",
        "lastEditedBy" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "tags" : [
        ]
      },
      {
        "id" : "890a5fd0-7309-4271-be17-2365ea5f1f45",
        "parentId" : "f48e1c23-c5d4-4f18-8f09-5185c0b51edc",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "For JoinResponse specifically, it should be caught in line 427 above and then falls into `else if (!future.isRetriable())` to throw the exception to the callers immediately. So I agree with @abbccdda that no extra logic would be needed.",
        "createdAt" : "2019-05-17T18:42:40Z",
        "updatedAt" : "2019-05-18T04:04:24Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "ac69d353-a90d-45bb-b86c-5b6d4a76ad3a",
        "parentId" : "f48e1c23-c5d4-4f18-8f09-5185c0b51edc",
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "I think I wasn't clear. What I'm asking is whether the consumer should remember the fact that it was fenced. So if the user continues trying to do stuff, we fail immediately instead of sending additional requests to the broker.",
        "createdAt" : "2019-05-17T20:55:18Z",
        "updatedAt" : "2019-05-18T04:04:24Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      },
      {
        "id" : "7326c7ec-8c34-4a5e-b5db-d9d9d80c47d8",
        "parentId" : "f48e1c23-c5d4-4f18-8f09-5185c0b51edc",
        "authorId" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "body" : "For `Join/Sync/OffsetCommitSync` the failures should be immediate; for `heartbeat/commitAsync` it would not be immediate but will be quickly surfaced. If we do want a global variable indicating the failure, potentially we need to add a new `MemberState`",
        "createdAt" : "2019-05-17T23:58:16Z",
        "updatedAt" : "2019-05-18T04:04:24Z",
        "lastEditedBy" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "tags" : [
        ]
      },
      {
        "id" : "08a6d61f-39f3-4ef9-8ff9-7305e29a62f6",
        "parentId" : "f48e1c23-c5d4-4f18-8f09-5185c0b51edc",
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "Yes, a new MemberState would be a nice way to handle this. We can do this later if you do not think it is important now.",
        "createdAt" : "2019-05-18T00:03:35Z",
        "updatedAt" : "2019-05-18T04:04:24Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      },
      {
        "id" : "fcc20ab0-beb2-433d-8a3f-207876075ff3",
        "parentId" : "f48e1c23-c5d4-4f18-8f09-5185c0b51edc",
        "authorId" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "body" : "SG!",
        "createdAt" : "2019-05-18T00:37:39Z",
        "updatedAt" : "2019-05-18T04:04:24Z",
        "lastEditedBy" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "tags" : [
        ]
      }
    ],
    "commit" : "4a0c245434329139d931b0cc904704ef8c26a62c",
    "line" : 29,
    "diffHunk" : "@@ -1,1 +566,570 @@                    || error == Errors.INVALID_GROUP_ID\n                    || error == Errors.GROUP_AUTHORIZATION_FAILED\n                    || error == Errors.GROUP_MAX_SIZE_REACHED) {\n                // log the error and re-throw the exception\n                log.error(\"Attempt to join group failed due to fatal error: {}\", error.message());"
  },
  {
    "id" : "dd673de3-4ec4-4017-b2c4-9672c8e5f114",
    "prId" : 6650,
    "prUrl" : "https://github.com/apache/kafka/pull/6650#pullrequestreview-238975578",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1cbf98c5-09cd-4c0b-ac39-a93276f26e31",
        "parentId" : null,
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "Maybe worth a log message that we caught the fenced error in the heartbeat thread.",
        "createdAt" : "2019-05-17T15:07:30Z",
        "updatedAt" : "2019-05-18T04:04:24Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      }
    ],
    "commit" : "4a0c245434329139d931b0cc904704ef8c26a62c",
    "line" : 94,
    "diffHunk" : "@@ -1,1 +1144,1148 @@                                        } else if (e instanceof FencedInstanceIdException) {\n                                            log.error(\"Caught fenced group.instance.id {} error in heartbeat thread\", groupInstanceId);\n                                            heartbeatThread.failed.set(e);\n                                            heartbeatThread.disable();\n                                        } else {"
  },
  {
    "id" : "56cea4c0-dbe0-4878-8617-361c51aa0b94",
    "prId" : 6650,
    "prUrl" : "https://github.com/apache/kafka/pull/6650#pullrequestreview-239079340",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9c74d122-a9c1-4adb-8a1e-54e6dfe5116f",
        "parentId" : null,
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "We should print the `groupInstanceId` value as well in error message, as in other cases.",
        "createdAt" : "2019-05-17T18:49:08Z",
        "updatedAt" : "2019-05-18T04:04:24Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      }
    ],
    "commit" : "4a0c245434329139d931b0cc904704ef8c26a62c",
    "line" : 92,
    "diffHunk" : "@@ -1,1 +1142,1146 @@                                            // however, then the session timeout may expire before we can rejoin.\n                                            heartbeat.receiveHeartbeat();\n                                        } else if (e instanceof FencedInstanceIdException) {\n                                            log.error(\"Caught fenced group.instance.id {} error in heartbeat thread\", groupInstanceId);\n                                            heartbeatThread.failed.set(e);"
  },
  {
    "id" : "a89cb4d6-a061-4d54-936b-99f9c44cece4",
    "prId" : 6650,
    "prUrl" : "https://github.com/apache/kafka/pull/6650#pullrequestreview-239176057",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "92b40c81-1764-4517-b45b-798fb1e59bb7",
        "parentId" : null,
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "Should we return after we fail the heartbeat thread? We do no want it to keep running I assume.",
        "createdAt" : "2019-05-18T00:00:37Z",
        "updatedAt" : "2019-05-18T04:04:24Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      },
      {
        "id" : "9c3efd92-28f4-450d-8233-d1ce348512d1",
        "parentId" : "92b40c81-1764-4517-b45b-798fb1e59bb7",
        "authorId" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "body" : "We are in a if-else branch here, but I agree. In case someone adds logic after if-else block in the future.",
        "createdAt" : "2019-05-18T00:14:54Z",
        "updatedAt" : "2019-05-18T04:04:24Z",
        "lastEditedBy" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "tags" : [
        ]
      },
      {
        "id" : "258674d1-72f0-469d-8d21-b86425baa7c0",
        "parentId" : "92b40c81-1764-4517-b45b-798fb1e59bb7",
        "authorId" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "body" : "Oh, actually it's against code style, so just leave it.",
        "createdAt" : "2019-05-18T00:15:22Z",
        "updatedAt" : "2019-05-18T04:04:24Z",
        "lastEditedBy" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "tags" : [
        ]
      },
      {
        "id" : "d53ffe16-20f8-4fc8-9987-9a570b5d2603",
        "parentId" : "92b40c81-1764-4517-b45b-798fb1e59bb7",
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "We do need a way to stop the heartbeat thread still, right? Perhaps we can invoke `disable()`?",
        "createdAt" : "2019-05-18T00:31:42Z",
        "updatedAt" : "2019-05-18T04:04:24Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      },
      {
        "id" : "0f072b39-f395-4852-b586-a91619c9b50d",
        "parentId" : "92b40c81-1764-4517-b45b-798fb1e59bb7",
        "authorId" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "body" : "Oh, got it. Let's stop it through disable() then",
        "createdAt" : "2019-05-18T00:41:29Z",
        "updatedAt" : "2019-05-18T04:04:24Z",
        "lastEditedBy" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "tags" : [
        ]
      }
    ],
    "commit" : "4a0c245434329139d931b0cc904704ef8c26a62c",
    "line" : 94,
    "diffHunk" : "@@ -1,1 +1144,1148 @@                                        } else if (e instanceof FencedInstanceIdException) {\n                                            log.error(\"Caught fenced group.instance.id {} error in heartbeat thread\", groupInstanceId);\n                                            heartbeatThread.failed.set(e);\n                                            heartbeatThread.disable();\n                                        } else {"
  },
  {
    "id" : "d8309529-d1e0-47fc-922c-ca90499fc52e",
    "prId" : 6650,
    "prUrl" : "https://github.com/apache/kafka/pull/6650#pullrequestreview-239174940",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3282f427-b2ad-4a63-8e53-6d35f84e7167",
        "parentId" : null,
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "nit: missing space after \"retry\"\r\n\r\nI think it would be better to just say that the broker does not support the use of `group.instance.id`. It's a little weird to tell the user to unset a configuration.",
        "createdAt" : "2019-05-18T00:04:06Z",
        "updatedAt" : "2019-05-18T04:04:24Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      },
      {
        "id" : "95c65584-5a67-4a8c-9917-4af9ac9d3ed2",
        "parentId" : "3282f427-b2ad-4a63-8e53-6d35f84e7167",
        "authorId" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "body" : "Got it",
        "createdAt" : "2019-05-18T00:26:11Z",
        "updatedAt" : "2019-05-18T04:04:24Z",
        "lastEditedBy" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "tags" : [
        ]
      }
    ],
    "commit" : "4a0c245434329139d931b0cc904704ef8c26a62c",
    "line" : 38,
    "diffHunk" : "@@ -1,1 +577,581 @@                }\n            } else if (error == Errors.UNSUPPORTED_VERSION) {\n                log.error(\"Attempt to join group failed due to unsupported version error. Please unset field group.instance.id and retry\" +\n                        \"to see if the problem resolves\");\n                future.raise(error);"
  },
  {
    "id" : "fed33ae5-7c03-4a20-a049-714d3c7571c3",
    "prId" : 6714,
    "prUrl" : "https://github.com/apache/kafka/pull/6714#pullrequestreview-262052374",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "438525ee-4bea-4795-b22c-02c70f8af5e3",
        "parentId" : null,
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "Don't we need to set `groupInstanceId` as well? Maybe we are missing test cases.",
        "createdAt" : "2019-07-13T06:59:52Z",
        "updatedAt" : "2019-07-26T04:38:45Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      },
      {
        "id" : "cb599a1a-ddcd-4bf6-b4b3-994f040d0cf5",
        "parentId" : "438525ee-4bea-4795-b22c-02c70f8af5e3",
        "authorId" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "body" : "We don't need to because under current code logic we shouldn't leave group when the `group.instance.id` is set.",
        "createdAt" : "2019-07-15T20:20:45Z",
        "updatedAt" : "2019-07-26T04:38:45Z",
        "lastEditedBy" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "tags" : [
        ]
      }
    ],
    "commit" : "ab085e9764aa35dece48891a8d707b743b5bf711",
    "line" : 30,
    "diffHunk" : "@@ -1,1 +859,863 @@                rebalanceConfig.groupId,\n                Collections.singletonList(new MemberIdentity()\n                                              .setMemberId(generation.memberId))\n            );\n            future = client.send(coordinator, request)"
  },
  {
    "id" : "e7af152d-72d9-4834-aa37-77448c14dada",
    "prId" : 6894,
    "prUrl" : "https://github.com/apache/kafka/pull/6894#pullrequestreview-246828218",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "951f2cd8-411a-4b9d-b0c3-87394cddb28d",
        "parentId" : null,
        "authorId" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "body" : "Could we raise the error after else block in L954 and only switch it in the last two cases:\r\n```\r\n } else if (error == Errors.GROUP_AUTHORIZATION_FAILED) {\r\n                error = new GroupAuthorizationException(groupId));\r\n} else {\r\n  error = new KafkaException(\"Unexpected error in heartbeat response: \" + error.message());\r\n}\r\nfuture.raise(error);\r\n```",
        "createdAt" : "2019-06-06T18:16:28Z",
        "updatedAt" : "2019-06-11T01:42:06Z",
        "lastEditedBy" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "tags" : [
        ]
      },
      {
        "id" : "da891bee-d118-4838-b4f7-3c125e19e3d3",
        "parentId" : "951f2cd8-411a-4b9d-b0c3-87394cddb28d",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "I feel it does not worth this cleanup for readability since we need another hierarchy of `else` covering the error cases..",
        "createdAt" : "2019-06-06T21:36:24Z",
        "updatedAt" : "2019-06-11T01:42:06Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      }
    ],
    "commit" : "9bb2b5f92caf46b4d78268db42075c829306fe64",
    "line" : 38,
    "diffHunk" : "@@ -1,1 +954,958 @@                future.raise(error);\n            } else if (error == Errors.GROUP_AUTHORIZATION_FAILED) {\n                future.raise(new GroupAuthorizationException(groupId));\n            } else {\n                future.raise(new KafkaException(\"Unexpected error in heartbeat response: \" + error.message()));"
  },
  {
    "id" : "62184699-dc33-4564-85c0-c56ffdc187a4",
    "prId" : 7347,
    "prUrl" : "https://github.com/apache/kafka/pull/7347#pullrequestreview-289561588",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f7b06b35-5246-4c42-bbc6-651ab5c5dea9",
        "parentId" : null,
        "authorId" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "body" : "Wonder if it would be useful to add a \"failed rebalances\" metric?",
        "createdAt" : "2019-09-17T21:05:25Z",
        "updatedAt" : "2019-09-21T00:48:46Z",
        "lastEditedBy" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "tags" : [
        ]
      },
      {
        "id" : "343143b3-0f28-4e5d-956b-ba101d31be4e",
        "parentId" : "f7b06b35-5246-4c42-bbc6-651ab5c5dea9",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "Good point, will add one. I think it is sufficient to only record the rate and only record failed rebalance latency though.",
        "createdAt" : "2019-09-17T21:38:04Z",
        "updatedAt" : "2019-09-21T00:48:46Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      }
    ],
    "commit" : "89dc784c146b285afe3d52bd19ed6b6ddbad7434",
    "line" : 39,
    "diffHunk" : "@@ -1,1 +446,450 @@            // a rebalance can be triggered consecutively if the previous one failed,\n            // in this case we would not update the start time.\n            if (lastRebalanceStartMs == -1L)\n                lastRebalanceStartMs = time.milliseconds();\n            joinFuture = sendJoinGroupRequest();"
  },
  {
    "id" : "7a5234e3-7ade-41ce-8fdc-a659cd050ce9",
    "prId" : 7347,
    "prUrl" : "https://github.com/apache/kafka/pull/7347#pullrequestreview-289606376",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "dd4d0ede-e7bb-424f-a2cb-82fa540a5c8e",
        "parentId" : null,
        "authorId" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "body" : "`new Avg()` should be on a new line. See also below.",
        "createdAt" : "2019-09-18T00:13:29Z",
        "updatedAt" : "2019-09-21T00:48:46Z",
        "lastEditedBy" : "b7cbfdaf-f3e2-4130-8254-501ace9562ac",
        "tags" : [
        ]
      }
    ],
    "commit" : "89dc784c146b285afe3d52bd19ed6b6ddbad7434",
    "line" : 141,
    "diffHunk" : "@@ -1,1 +1055,1059 @@                this.metricGrpName,\n                \"The average time taken for a group to complete a successful rebalance, which may be composed of \" +\n                    \"several failed re-trials until it succeeded\"), new Avg());\n            this.successfulRebalanceSensor.add(metrics.metricName(\"rebalance-latency-max\",\n                this.metricGrpName,"
  },
  {
    "id" : "e1ee7fbe-fe0e-42fe-bdb9-5da91fad5407",
    "prId" : 7347,
    "prUrl" : "https://github.com/apache/kafka/pull/7347#pullrequestreview-290282922",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "209f7c8f-55c3-4283-ad25-b7bbdfd1a66b",
        "parentId" : null,
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "This is a piggy-backed fix: if no heartbeat is triggered, we simply return `now` value which is meaningless as it is just since the epoch. So I've refactored to also return -1 as we did for the newly added last-rebalance.",
        "createdAt" : "2019-09-19T01:33:39Z",
        "updatedAt" : "2019-09-21T00:48:46Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      }
    ],
    "commit" : "89dc784c146b285afe3d52bd19ed6b6ddbad7434",
    "line" : 206,
    "diffHunk" : "@@ -1,1 +1103,1107 @@                lastRebalance);\n\n            Measurable lastHeartbeat = (config, now) -> {\n                if (heartbeat.lastHeartbeatSend() == 0L)\n                    // if no heartbeat is ever triggered, just return -1."
  },
  {
    "id" : "d7b4be58-2eb9-4fc9-b196-bc2c9148f678",
    "prId" : 7347,
    "prUrl" : "https://github.com/apache/kafka/pull/7347#pullrequestreview-291441580",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e76b3133-0bef-4c67-b158-a33301e63ae4",
        "parentId" : null,
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "nit: seems this is for testing only? Should it be package private? Maybe also add comment `// for testing` ?",
        "createdAt" : "2019-09-20T23:11:10Z",
        "updatedAt" : "2019-09-21T00:48:46Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "aecaeb93-cabf-468f-af6a-46d5d36a6232",
        "parentId" : "e76b3133-0bef-4c67-b158-a33301e63ae4",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "The previous function is testing only too and we have a comment in line 1316.",
        "createdAt" : "2019-09-21T00:40:57Z",
        "updatedAt" : "2019-09-21T00:48:46Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      }
    ],
    "commit" : "89dc784c146b285afe3d52bd19ed6b6ddbad7434",
    "line" : 221,
    "diffHunk" : "@@ -1,1 +1319,1323 @@    }\n\n    public void setLastRebalanceTime(final long timestamp) {\n        lastRebalanceEndMs = timestamp;\n    }"
  },
  {
    "id" : "604f0bd9-84e2-48b6-b9f6-70923369118f",
    "prId" : 7451,
    "prUrl" : "https://github.com/apache/kafka/pull/7451#pullrequestreview-298482888",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a78fa28e-8fe3-45a8-9aad-a690bafb0325",
        "parentId" : null,
        "authorId" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "body" : "Can you maybe extend the docs a bit to explain that this always returns the latest stable generation, regardless of whether it is currently stable? Is that an accurate description?",
        "createdAt" : "2019-10-08T00:40:05Z",
        "updatedAt" : "2019-10-08T21:56:48Z",
        "lastEditedBy" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "tags" : [
        ]
      }
    ],
    "commit" : "6bae4d94b47a17569f11cfe185d630bcc68d347e",
    "line" : 28,
    "diffHunk" : "@@ -1,1 +793,797 @@     * of a rebalance, after the join-group response is received.\n     *\n     * @return the current generation\n     */\n    protected synchronized Generation generation() {"
  },
  {
    "id" : "4efa269a-75a5-4a7e-b24f-b32ea4f4ae0e",
    "prId" : 8272,
    "prUrl" : "https://github.com/apache/kafka/pull/8272#pullrequestreview-374756590",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2272f9bd-801c-4379-baa1-73631b795d4f",
        "parentId" : null,
        "authorId" : "d8c7cf80-a55a-474c-a4f4-f60a9efda52c",
        "body" : "Why are we logging this at error level when it's a client issue?",
        "createdAt" : "2020-03-12T02:17:49Z",
        "updatedAt" : "2020-03-12T02:17:49Z",
        "lastEditedBy" : "d8c7cf80-a55a-474c-a4f4-f60a9efda52c",
        "tags" : [
        ]
      },
      {
        "id" : "ab20b114-eb57-46bd-bda4-561eb02849f6",
        "parentId" : "2272f9bd-801c-4379-baa1-73631b795d4f",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "@ijuma not sure I understand your question?",
        "createdAt" : "2020-03-12T03:58:57Z",
        "updatedAt" : "2020-03-12T03:58:57Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "ae555d6a-129c-4be7-b063-bdbb96170d31",
        "parentId" : "2272f9bd-801c-4379-baa1-73631b795d4f",
        "authorId" : "d8c7cf80-a55a-474c-a4f4-f60a9efda52c",
        "body" : "Logging at error level should indicate a broker error. Bad client requests are a client error though and should not generate the logs at error level. Does that make sense?",
        "createdAt" : "2020-03-12T07:11:58Z",
        "updatedAt" : "2020-03-12T07:11:59Z",
        "lastEditedBy" : "d8c7cf80-a55a-474c-a4f4-f60a9efda52c",
        "tags" : [
        ]
      },
      {
        "id" : "88460a1c-8384-41fe-a074-c6c9c9089260",
        "parentId" : "2272f9bd-801c-4379-baa1-73631b795d4f",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "Atm we cannot say for sure, but it's likely that what's observed on KAFKA-9701 is a broker-side issue; we can either 1) add the check on broker-side across all members to make sure the selected protocol is consistent for everyone, so if the broker already made a wrong choice itself would log an ERROR, or 2) let it check on the client side. I think for trouble-shooting purposes option 2) is fine, and if we later discovered that this bug is actually on the client side I'm happy to revert this change after fixing it.",
        "createdAt" : "2020-03-14T20:20:27Z",
        "updatedAt" : "2020-03-14T20:20:27Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "9d02d6ca-f13c-428b-b76d-02f830767f2e",
        "parentId" : "2272f9bd-801c-4379-baa1-73631b795d4f",
        "authorId" : "d8c7cf80-a55a-474c-a4f4-f60a9efda52c",
        "body" : "So the `if (isProtocolTypeInconsistent(joinResponse.data().protocolType()))` check is like an assert for a bug in the broker implementation versus validating the join group request?",
        "createdAt" : "2020-03-14T21:54:40Z",
        "updatedAt" : "2020-03-14T21:54:41Z",
        "lastEditedBy" : "d8c7cf80-a55a-474c-a4f4-f60a9efda52c",
        "tags" : [
        ]
      }
    ],
    "commit" : "ebfdc71cba3b6d35ba88b032b1664c3afa78f97f",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +577,581 @@            if (error == Errors.NONE) {\n                if (isProtocolTypeInconsistent(joinResponse.data().protocolType())) {\n                    log.error(\"JoinGroup failed due to inconsistent Protocol Type, received {} but expected {}\",\n                        joinResponse.data().protocolType(), protocolType());\n                    future.raise(Errors.INCONSISTENT_GROUP_PROTOCOL);"
  },
  {
    "id" : "bf0f2ec5-af06-4b6a-a85d-fbf695b6ce2f",
    "prId" : 8324,
    "prUrl" : "https://github.com/apache/kafka/pull/8324#pullrequestreview-379207666",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "95cfcae4-d5b7-4112-aa97-7e04d1068ace",
        "parentId" : null,
        "authorId" : "59ca7821-b29c-4f24-a9d5-cbd394145686",
        "body" : "@guozhangwang @abbccdda Shouldn't we synchronise this or use a local reference of the generation to be 100% safe?",
        "createdAt" : "2020-03-23T08:19:01Z",
        "updatedAt" : "2020-03-23T08:19:01Z",
        "lastEditedBy" : "59ca7821-b29c-4f24-a9d5-cbd394145686",
        "tags" : [
        ]
      }
    ],
    "commit" : "5fccb32033c53fb3be3ea04fc99bb989913722ea",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +915,919 @@    private boolean isProtocolNameInconsistent(String protocolName) {\n        return protocolName != null && generation() != Generation.NO_GENERATION\n                   && !protocolName.equals(generation().protocolName);\n    }\n"
  },
  {
    "id" : "3a947f0b-b0f2-4893-92e8-f2dd67fb0412",
    "prId" : 8349,
    "prUrl" : "https://github.com/apache/kafka/pull/8349#pullrequestreview-381835478",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "20605741-8fff-48e1-82f4-ccac4149e620",
        "parentId" : null,
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "@dajac just to clarify, are you concerning that the `generation()` may change between the check and the error-log? If yes maybe we do not need to synchronize the whole function, instead we just get a reference of the returned `generation()` call and use that in the error-log, since the generation object is immutable.",
        "createdAt" : "2020-03-25T21:18:46Z",
        "updatedAt" : "2020-03-25T21:35:36Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "33ea5631-3674-464d-a4c4-615583c8ee5a",
        "parentId" : "20605741-8fff-48e1-82f4-ccac4149e620",
        "authorId" : "59ca7821-b29c-4f24-a9d5-cbd394145686",
        "body" : "@guozhangwang Yes, keeping the reference is fine. I was concerned by the check itself because we were calling `generation()` twice in the previous implementation thus we could get two different instances.\r\n```\r\ngeneration() != Generation.NO_GENERATION && !protocolName.equals(generation().protocolName)\r\n```\r\nI haven't thought about the error-log but it is also a good point.",
        "createdAt" : "2020-03-26T09:35:16Z",
        "updatedAt" : "2020-03-26T09:35:16Z",
        "lastEditedBy" : "59ca7821-b29c-4f24-a9d5-cbd394145686",
        "tags" : [
        ]
      }
    ],
    "commit" : "dd16cf46cb2f99075ae17ec0f1aba46aabbfeb77",
    "line" : 24,
    "diffHunk" : "@@ -1,1 +917,921 @@            !protocolName.equals(currentGeneration.protocolName);\n\n        if (protocolNameInconsistent) {\n            log.error(\"{} failed due to inconsistent Protocol Name, received {} but expected {}\",\n                key, protocolName, currentGeneration.protocolName);"
  },
  {
    "id" : "a9d357f5-d1db-46f0-ab2d-a66e8f110074",
    "prId" : 8405,
    "prUrl" : "https://github.com/apache/kafka/pull/8405#pullrequestreview-387467187",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2254556e-20b3-4d17-8b16-8bc8a2335286",
        "parentId" : null,
        "authorId" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "body" : "What's the reasoning for this move?",
        "createdAt" : "2020-04-02T02:42:40Z",
        "updatedAt" : "2020-04-07T17:54:37Z",
        "lastEditedBy" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "tags" : [
        ]
      },
      {
        "id" : "1f964e0e-eaf3-4b3c-b03f-361fa09cad39",
        "parentId" : "2254556e-20b3-4d17-8b16-8bc8a2335286",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "No specific reasoning, I just prefer to change the state after we log the message :)",
        "createdAt" : "2020-04-03T18:15:00Z",
        "updatedAt" : "2020-04-07T17:54:37Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      }
    ],
    "commit" : "c44f148e48f1bbed4e5717680b17c2b0b5c53044",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +454,458 @@                final RuntimeException exception = future.exception();\n                log.info(\"Join group failed with {}\", exception.toString());\n                resetJoinGroupFuture();\n                if (exception instanceof UnknownMemberIdException ||\n                    exception instanceof RebalanceInProgressException ||"
  },
  {
    "id" : "78000fb9-69a9-4249-a26a-7953ffbfd86c",
    "prId" : 8405,
    "prUrl" : "https://github.com/apache/kafka/pull/8405#pullrequestreview-388570454",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fa9fb200-6d53-40c4-b358-7fc68a7802df",
        "parentId" : null,
        "authorId" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "body" : "Should be equivalent to `state == MemberState.STABLE`?",
        "createdAt" : "2020-04-02T02:44:31Z",
        "updatedAt" : "2020-04-07T17:54:37Z",
        "lastEditedBy" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "tags" : [
        ]
      },
      {
        "id" : "f920b59a-d940-44ab-acca-ae829f8fd81e",
        "parentId" : "fa9fb200-6d53-40c4-b358-7fc68a7802df",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "There are other states beside STABLE and REBALANCING",
        "createdAt" : "2020-04-03T18:08:55Z",
        "updatedAt" : "2020-04-07T17:54:37Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "5eb5d700-0490-4d1e-804d-8d54a8645731",
        "parentId" : "fa9fb200-6d53-40c4-b358-7fc68a7802df",
        "authorId" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "body" : "But we are moving to UNJOINED anyway, so it won't affect the result right?",
        "createdAt" : "2020-04-06T19:56:07Z",
        "updatedAt" : "2020-04-07T17:54:37Z",
        "lastEditedBy" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "tags" : [
        ]
      }
    ],
    "commit" : "c44f148e48f1bbed4e5717680b17c2b0b5c53044",
    "line" : 25,
    "diffHunk" : "@@ -1,1 +901,905 @@\n        // only reset the state to un-joined when it is not already in rebalancing\n        if (state != MemberState.REBALANCING)\n            state = MemberState.UNJOINED;\n"
  },
  {
    "id" : "df73aaef-96ed-48c1-abc7-5a37f467b72c",
    "prId" : 8405,
    "prUrl" : "https://github.com/apache/kafka/pull/8405#pullrequestreview-388644944",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "050ded63-3d10-4dfa-9476-38f6380ee53d",
        "parentId" : null,
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "A couple questions on this change:\r\n\r\n1. If we are leaving the group through `resetGenerationOnLeaveGroup`, do we still want to continue the rebalance?\r\n2. We use the the `REBALANCING` state to tell whether to return `RebalanceInProgressException` or `CommitFailedException`. If we reset the generation _and_ leave the state in `REBALANCING`, wouldn't that mess up the check?\r\n\r\nMentioned this offline, but if the problem is misinterpreting responses from the wrong generation, I think it would be safer to detect them directly. We can add the generation information to `HeartbeatResponseHandler` for example. If the stored generation does not match the current generation when the response is received, we can ignore it.",
        "createdAt" : "2020-04-03T04:14:24Z",
        "updatedAt" : "2020-04-07T17:54:37Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      },
      {
        "id" : "93ce160f-a4f9-4422-8b7c-881e2c902389",
        "parentId" : "050ded63-3d10-4dfa-9476-38f6380ee53d",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "1. Good call, I think the two code path should better not sharing the same callee anyways.\r\n2. I think it would not, since if the member is indeed be participating in a rebalance (i.e. it has already sent a join-group request) and a commit is being failed, then heartbeat failure should not change it to return `CommitFailedException`.\r\n\r\nAbout your general comment, I agree that it's better to let heartbeat request remember the generation when it was sent and compare against it even with this change in place. Let me just do that in this PR.",
        "createdAt" : "2020-04-03T18:13:26Z",
        "updatedAt" : "2020-04-07T17:54:37Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "1490ba46-ed18-46de-b2f4-c18956145d0d",
        "parentId" : "050ded63-3d10-4dfa-9476-38f6380ee53d",
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "Was the first point addressed? As far as I can tell, `resetGenerationOnLeaveGroup` is still going through `resetGeneration`.",
        "createdAt" : "2020-04-04T00:02:40Z",
        "updatedAt" : "2020-04-07T17:54:37Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      },
      {
        "id" : "99d3ea29-41af-4d9d-a2d2-1aa95625cc05",
        "parentId" : "050ded63-3d10-4dfa-9476-38f6380ee53d",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "Regarding the first point, I change the code path to move `this.rejoinNeeded = true;` out of `resetGeneration` and only in `resetGenerationOnResponseError`. But then in trouble-shooting the failed unit test I realized that when heartbeat's poll timer expired it needs to call `leaveGroup` to notify the caller to re-join upon next `poll`. While on the other hand, the only other caller `consumer.close` would close other modules including the coordinator anyways so that right after this call, there will be no heartbeat request or other consumer poll calls, so I think it is actually fine to keep it as is.",
        "createdAt" : "2020-04-05T22:16:18Z",
        "updatedAt" : "2020-04-07T17:54:37Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "669cf550-24c6-42fb-8b8a-e7b71711e2cb",
        "parentId" : "050ded63-3d10-4dfa-9476-38f6380ee53d",
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "How about `unsubscribe`? That is a case where we send `LeaveGroup`, but we do not intend to rejoin the group. ",
        "createdAt" : "2020-04-06T21:19:14Z",
        "updatedAt" : "2020-04-07T17:54:37Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      },
      {
        "id" : "c30da6d4-4137-4414-a389-a988e3922b33",
        "parentId" : "050ded63-3d10-4dfa-9476-38f6380ee53d",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "My thoughts for `unsubscribe` is that, if consumer still calls `poll` after `unsubscribe` then it needs to either `subscribe` to some other topics or `assign` specifically with topic-partitions. In the first case, the consumer did need to re-join the group, while in the last case, the consumer's coordinator would not call `rejoinNeededOrPending` anyways.",
        "createdAt" : "2020-04-06T21:53:17Z",
        "updatedAt" : "2020-04-07T17:54:37Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      }
    ],
    "commit" : "c44f148e48f1bbed4e5717680b17c2b0b5c53044",
    "line" : 25,
    "diffHunk" : "@@ -1,1 +901,905 @@\n        // only reset the state to un-joined when it is not already in rebalancing\n        if (state != MemberState.REBALANCING)\n            state = MemberState.UNJOINED;\n"
  },
  {
    "id" : "e8ba4ceb-1746-4267-b3da-f508c3dc6329",
    "prId" : 8405,
    "prUrl" : "https://github.com/apache/kafka/pull/8405#pullrequestreview-387867300",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "110658a1-7d21-4bbd-aee9-8b4c3294cf55",
        "parentId" : null,
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "Seems like we'd want to do this for `OffsetCommitResponseHandler` and `SyncGroupResponseHandler` as well? I am thinking this will be a big enough change that we should pull it into a separate PR.",
        "createdAt" : "2020-04-04T00:10:47Z",
        "updatedAt" : "2020-04-07T17:54:37Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      },
      {
        "id" : "2f6334cf-1fad-41e6-857f-5250086a9172",
        "parentId" : "110658a1-7d21-4bbd-aee9-8b4c3294cf55",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "SG, I'm reverting this and putting into https://issues.apache.org/jira/browse/KAFKA-9823",
        "createdAt" : "2020-04-05T22:16:43Z",
        "updatedAt" : "2020-04-07T17:54:37Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      }
    ],
    "commit" : "c44f148e48f1bbed4e5717680b17c2b0b5c53044",
    "line" : 59,
    "diffHunk" : "@@ -1,1 +1032,1036 @@\n    private class HeartbeatResponseHandler extends CoordinatorResponseHandler<HeartbeatResponse, Void> {\n        private final Generation sentGeneration;\n\n        private HeartbeatResponseHandler(final Generation generation) {"
  },
  {
    "id" : "b553ecbf-2bbe-4744-bf67-ba867476dd6f",
    "prId" : 8445,
    "prUrl" : "https://github.com/apache/kafka/pull/8445#pullrequestreview-396169244",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "191c829d-50c9-487c-8e1b-caf274509741",
        "parentId" : null,
        "authorId" : "e77724e7-3db9-47d6-b4d8-a865b1d06edc",
        "body" : "Hey @guozhangwang. \r\nTrying to understand if any of these changes have implications for the `WorkerCoordinator` too. \r\n\r\nWhat I've observed is that if the `WorkerCoordinator` fails to receive a valid `SyncGroup` request, it may miss several generations until it succeeds again. Is the branch here safe? `resetGenerationOnResponseError` will be called (and therefore rejoin will be requested) only if `generationUnchanged` returns true. Is there any risk that we suppress any useful retries to rejoin?",
        "createdAt" : "2020-04-16T02:07:20Z",
        "updatedAt" : "2020-04-23T18:32:47Z",
        "lastEditedBy" : "e77724e7-3db9-47d6-b4d8-a865b1d06edc",
        "tags" : [
        ]
      },
      {
        "id" : "68e12a1e-0d48-4a97-97ab-2385052f9d6b",
        "parentId" : "191c829d-50c9-487c-8e1b-caf274509741",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "The rationale is that if the generation has changed, it is either reset by the heartbeat thread in which case the generation is reset and rejoin is already requested, or it is changed by another join-group request; but since inside AbstractCoordinator we will only have one in-flight request at a given time the second scenario should not happen. So the only possibility is the heartbeat resetting.",
        "createdAt" : "2020-04-16T21:12:41Z",
        "updatedAt" : "2020-04-23T18:32:47Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "84fefd71-9f58-49f7-b2ad-3357b795ae35",
        "parentId" : "191c829d-50c9-487c-8e1b-caf274509741",
        "authorId" : "e77724e7-3db9-47d6-b4d8-a865b1d06edc",
        "body" : "Makes sense. Thanks",
        "createdAt" : "2020-04-20T06:25:52Z",
        "updatedAt" : "2020-04-23T18:32:47Z",
        "lastEditedBy" : "e77724e7-3db9-47d6-b4d8-a865b1d06edc",
        "tags" : [
        ]
      }
    ],
    "commit" : "fc4c6888df3cc6dcfe6e88bb35bd9bb13f0cda0c",
    "line" : 75,
    "diffHunk" : "@@ -1,1 +760,764 @@                        || error == Errors.ILLEGAL_GENERATION) {\n                    log.info(\"SyncGroup with {} failed: {}, would request re-join\", sentGeneration, error.message());\n                    if (generationUnchanged())\n                        resetGenerationOnResponseError(ApiKeys.SYNC_GROUP, error);\n"
  },
  {
    "id" : "9de8f33e-8b09-46cc-be45-3196240fec10",
    "prId" : 8445,
    "prUrl" : "https://github.com/apache/kafka/pull/8445#pullrequestreview-395055857",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ae08673a-d6aa-4f44-9c06-0907382d9421",
        "parentId" : null,
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "If the consumer has been legitimately fenced, is it safe to rejoin the group after resetting the member id? Would that not lead to a ping-pong scenario?",
        "createdAt" : "2020-04-16T22:28:19Z",
        "updatedAt" : "2020-04-23T18:32:47Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      },
      {
        "id" : "c02f3761-84d7-4d2a-a171-3705a72b0049",
        "parentId" : "ae08673a-d6aa-4f44-9c06-0907382d9421",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "Note since we set the `InstanceFenced` error in future, and hence in the caller:\r\n\r\n```\r\nfinal RuntimeException exception = future.exception();\r\n                log.info(\"Join group failed with {}\", exception.toString());\r\n                resetJoinGroupFuture();\r\n                if (exception instanceof UnknownMemberIdException ||\r\n                    exception instanceof RebalanceInProgressException ||\r\n                    exception instanceof IllegalGenerationException ||\r\n                    exception instanceof MemberIdRequiredException)\r\n                    continue;\r\n                else if (!future.isRetriable())\r\n                    throw exception;\r\n```\r\n\r\nWe would throw that retriable exception still.",
        "createdAt" : "2020-04-16T22:59:43Z",
        "updatedAt" : "2020-04-23T18:32:47Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      }
    ],
    "commit" : "fc4c6888df3cc6dcfe6e88bb35bd9bb13f0cda0c",
    "line" : 159,
    "diffHunk" : "@@ -1,1 +1084,1088 @@            } else if (error == Errors.ILLEGAL_GENERATION ||\n                       error == Errors.UNKNOWN_MEMBER_ID ||\n                       error == Errors.FENCED_INSTANCE_ID) {\n                if (generationUnchanged()) {\n                    log.info(\"Attempt to heartbeat with {} and group instance id {} failed due to {}, resetting generation\","
  },
  {
    "id" : "4f066106-048c-4d8f-918b-400f02aa50c4",
    "prId" : 8702,
    "prUrl" : "https://github.com/apache/kafka/pull/8702#pullrequestreview-417014962",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a725a672-6f2e-4dd9-ac97-2adb3751b713",
        "parentId" : null,
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "The previous max check was wrong, but an alternative here is to use rebalanceTimeout + 5s in all cases regardless of the request timeout.",
        "createdAt" : "2020-05-21T01:01:30Z",
        "updatedAt" : "2020-05-22T15:48:58Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      },
      {
        "id" : "e26b067f-e948-4f66-8641-e6179ff3a370",
        "parentId" : "a725a672-6f2e-4dd9-ac97-2adb3751b713",
        "authorId" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "body" : "Could we log a debug info here for the timeout we used?",
        "createdAt" : "2020-05-22T00:42:04Z",
        "updatedAt" : "2020-05-22T15:48:58Z",
        "lastEditedBy" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "tags" : [
        ]
      },
      {
        "id" : "ce3fbb8b-b128-49c8-9348-ed2b66e2c379",
        "parentId" : "a725a672-6f2e-4dd9-ac97-2adb3751b713",
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "I added the request timeout to the send message in `NetworkClient`. Also made some tweaks for more consistent logging.",
        "createdAt" : "2020-05-22T15:49:38Z",
        "updatedAt" : "2020-05-22T15:49:39Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      }
    ],
    "commit" : "023302f48c3e2b1da07af111f8077d2f84cb466f",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +567,571 @@        // Note that we override the request timeout using the rebalance timeout since that is the\n        // maximum time that it may block on the coordinator. We add an extra 5 seconds for small delays.\n        int joinGroupTimeoutMs = Math.max(client.defaultRequestTimeoutMs(),\n            rebalanceConfig.rebalanceTimeoutMs + JOIN_GROUP_TIMEOUT_LAPSE);\n        return client.send(coordinator, requestBuilder, joinGroupTimeoutMs)"
  },
  {
    "id" : "44fac727-45d0-4663-80db-27f3f9be216c",
    "prId" : 8834,
    "prUrl" : "https://github.com/apache/kafka/pull/8834#pullrequestreview-426706399",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2f84f507-d32a-4317-8fd6-96e5622a86fb",
        "parentId" : null,
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "Minor log4j improvement.",
        "createdAt" : "2020-06-09T00:18:04Z",
        "updatedAt" : "2020-09-09T04:33:54Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      }
    ],
    "commit" : "df9f9958c177e2066fb1243927a0a8a336880971",
    "line" : 227,
    "diffHunk" : "@@ -1,1 +645,649 @@                // and send another join group request in next cycle.\n                String memberId = joinResponse.data().memberId();\n                log.debug(\"Attempt to join group returned {} error. Will set the member id as {} and then rejoin\", error, memberId);\n                synchronized (AbstractCoordinator.this) {\n                    AbstractCoordinator.this.generation = new Generation(OffsetCommitRequest.DEFAULT_GENERATION_ID, memberId, null);"
  },
  {
    "id" : "6f9699e7-9b89-41cf-8b64-31d5ce731e6d",
    "prId" : 8834,
    "prUrl" : "https://github.com/apache/kafka/pull/8834#pullrequestreview-426737483",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "065e98c0-3f9b-46b8-abe9-2cdd74412434",
        "parentId" : null,
        "authorId" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "body" : "There might be slight performance gain if we just say \"Attempt to join group and receive member id required error.\" instead of passing in the error.",
        "createdAt" : "2020-06-09T01:59:29Z",
        "updatedAt" : "2020-09-09T04:33:54Z",
        "lastEditedBy" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "tags" : [
        ]
      }
    ],
    "commit" : "df9f9958c177e2066fb1243927a0a8a336880971",
    "line" : 227,
    "diffHunk" : "@@ -1,1 +645,649 @@                // and send another join group request in next cycle.\n                String memberId = joinResponse.data().memberId();\n                log.debug(\"Attempt to join group returned {} error. Will set the member id as {} and then rejoin\", error, memberId);\n                synchronized (AbstractCoordinator.this) {\n                    AbstractCoordinator.this.generation = new Generation(OffsetCommitRequest.DEFAULT_GENERATION_ID, memberId, null);"
  },
  {
    "id" : "6536397c-28bc-4bab-9ad8-62a9eba9afdc",
    "prId" : 8834,
    "prUrl" : "https://github.com/apache/kafka/pull/8834#pullrequestreview-475088943",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "363f34bc-5c3c-457c-a10e-0e98a5f9c2ef",
        "parentId" : null,
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "This is the major fix 2) in description.",
        "createdAt" : "2020-08-26T01:26:41Z",
        "updatedAt" : "2020-09-09T04:33:54Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      }
    ],
    "commit" : "df9f9958c177e2066fb1243927a0a8a336880971",
    "line" : 45,
    "diffHunk" : "@@ -1,1 +334,338 @@\n    protected synchronized long timeToNextHeartbeat(long now) {\n        // if we have not joined the group or we are preparing rebalance,\n        // we don't need to send heartbeats\n        if (state.hasNotJoinedGroup())"
  },
  {
    "id" : "da0740d0-f443-4134-914b-3a533fa58df3",
    "prId" : 8834,
    "prUrl" : "https://github.com/apache/kafka/pull/8834#pullrequestreview-475088943",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ca434247-8d8f-4b7a-9549-bbd2a4c5c494",
        "parentId" : null,
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "This is the major fix 1).",
        "createdAt" : "2020-08-26T01:33:38Z",
        "updatedAt" : "2020-09-09T04:33:54Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      }
    ],
    "commit" : "df9f9958c177e2066fb1243927a0a8a336880971",
    "line" : 394,
    "diffHunk" : "@@ -1,1 +1328,1332 @@                        // also if we already have fatal error, the client will be\n                        // crashed soon, hence we do not need to continue heartbeating either\n                        if (state.hasNotJoinedGroup() || hasFailed()) {\n                            disable();\n                            continue;"
  },
  {
    "id" : "a2baf0af-ca01-4282-a2ce-baeea28bb00c",
    "prId" : 8834,
    "prUrl" : "https://github.com/apache/kafka/pull/8834#pullrequestreview-484645680",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a13efc98-5b74-45a8-b705-10c01b98d4c9",
        "parentId" : null,
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "Should we also reset the generation here? With the new condition above, we may now enter this block if generation is _not_ `NO_GENERATION`. I'm not sure if we want to have the generation set to some value but state set to `UNJOINED` and `rejoinNeeded := true`.",
        "createdAt" : "2020-09-01T19:13:31Z",
        "updatedAt" : "2020-09-09T04:33:54Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      },
      {
        "id" : "afad44b7-3eb0-4a2e-b2c1-ce33c1ed2a35",
        "parentId" : "a13efc98-5b74-45a8-b705-10c01b98d4c9",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "That's a good question. I just thought about this and I think I can change the caller of `resetGeneration` (which is the only place that hb thread can reset the generation) and move the `state = MemberState.UNJOINED;` into the callee to make sure that they are always changed together.",
        "createdAt" : "2020-09-09T04:04:07Z",
        "updatedAt" : "2020-09-09T04:33:54Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      }
    ],
    "commit" : "df9f9958c177e2066fb1243927a0a8a336880971",
    "line" : 108,
    "diffHunk" : "@@ -1,1 +461,465 @@                         \"the rebalance callback is triggered, marking this rebalance as failed and retry\",\n                         generationSnapshot, stateSnapshot);\n                    resetStateAndRejoin();\n                    resetJoinGroupFuture();\n                }"
  },
  {
    "id" : "87eafd1d-8f69-4629-b23f-8aeb7f22c309",
    "prId" : 9295,
    "prUrl" : "https://github.com/apache/kafka/pull/9295#pullrequestreview-492128968",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4b8debb5-582d-44e3-bb93-ad40c404ba49",
        "parentId" : null,
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "Why promote it from debug to info while leaving others debug?",
        "createdAt" : "2020-09-19T19:17:19Z",
        "updatedAt" : "2020-09-25T22:50:57Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      }
    ],
    "commit" : "ccfc1950c203ed31b2dbae1e0c9f2da448efefa9",
    "line" : 28,
    "diffHunk" : "@@ -1,1 +603,607 @@                future.raise(error);\n            } else if (error == Errors.UNKNOWN_MEMBER_ID) {\n                log.info(\"JoinGroup failed: {} Need to re-join the group. Sent generation was {}\",\n                         error.message(), sentGeneration);\n                // only need to reset the member id if generation has not been changed,"
  },
  {
    "id" : "80b9a63a-7cf1-438c-8b56-76e5b67c69c3",
    "prId" : 9354,
    "prUrl" : "https://github.com/apache/kafka/pull/9354#pullrequestreview-500803907",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4b79e4c2-96b2-481f-bfb0-7551fbd4c49f",
        "parentId" : null,
        "authorId" : "0f776378-bb23-4193-9bb0-1db5973f3781",
        "body" : "@dajac I feel this patch can fix https://issues.apache.org/jira/browse/KAFKA-8266\r\n\r\nThe test case in https://issues.apache.org/jira/browse/KAFKA-8266 restarts all brokers to activate new configs. However, the data of group (__consumer_offsets) may get lost if all brokers are killed too quick (the log folder is changed when restarting broker so the restarting broker has to fetch data from other brokers). The heartbeat of running consumer will encounter ```UNKNOWN_MEMBER_ID``` in sending heartbeat request since the group data is gone. Without this patch, the heartbeat thread is disabled and the state is in ```UNJOINED``` but the ```rejoinNeeded``` is still false. In short, the consumer is not going to rejoin group so we can't see expected error.",
        "createdAt" : "2020-09-30T09:49:50Z",
        "updatedAt" : "2020-10-02T00:56:09Z",
        "lastEditedBy" : "0f776378-bb23-4193-9bb0-1db5973f3781",
        "tags" : [
        ]
      },
      {
        "id" : "39ccaa41-462b-4945-91f8-a1da9592ccea",
        "parentId" : "4b79e4c2-96b2-481f-bfb0-7551fbd4c49f",
        "authorId" : "59ca7821-b29c-4f24-a9d5-cbd394145686",
        "body" : "Nice find! I analyzed the logs and I was actually trying to find out why the consumer was not rejoining. The logs coincides with what you described. It may be due to this as you pointed out.",
        "createdAt" : "2020-09-30T17:58:40Z",
        "updatedAt" : "2020-10-02T00:56:09Z",
        "lastEditedBy" : "59ca7821-b29c-4f24-a9d5-cbd394145686",
        "tags" : [
        ]
      },
      {
        "id" : "7a77d01a-decb-49f1-86a5-7f7d82ea77f8",
        "parentId" : "4b79e4c2-96b2-481f-bfb0-7551fbd4c49f",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "@chia7712 @dajac I think this bug is only introduced recently in this PR: https://github.com/apache/kafka/pull/8834. If your tests is executed before it then maybe there are other issues yet to be discovered.",
        "createdAt" : "2020-09-30T18:16:28Z",
        "updatedAt" : "2020-10-02T00:56:09Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "48e3a81e-83ab-4dd9-a972-9d363ad6ddd1",
        "parentId" : "4b79e4c2-96b2-481f-bfb0-7551fbd4c49f",
        "authorId" : "59ca7821-b29c-4f24-a9d5-cbd394145686",
        "body" : "That test became flaky quite recently. Time wise, that could coincides. I will try to run the test without https://github.com/apache/kafka/pull/8834 to check tomorrow.",
        "createdAt" : "2020-09-30T18:38:53Z",
        "updatedAt" : "2020-10-02T00:56:09Z",
        "lastEditedBy" : "59ca7821-b29c-4f24-a9d5-cbd394145686",
        "tags" : [
        ]
      },
      {
        "id" : "2c1ad650-851e-4f7c-8631-2d80fcb269a8",
        "parentId" : "4b79e4c2-96b2-481f-bfb0-7551fbd4c49f",
        "authorId" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "body" : "It seems that we would rejoin on FENCED_INSTANCE_ID as well, is that intentional? https://github.com/apache/kafka/blob/bd462df20321ff5b75a7e3eae70634268582d90b/clients/src/main/java/org/apache/kafka/clients/consumer/internals/AbstractCoordinator.java#L1106",
        "createdAt" : "2020-10-01T03:19:24Z",
        "updatedAt" : "2020-10-02T00:56:09Z",
        "lastEditedBy" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "tags" : [
        ]
      },
      {
        "id" : "62c8e83b-2cd1-43df-828e-0cef17a0a51d",
        "parentId" : "4b79e4c2-96b2-481f-bfb0-7551fbd4c49f",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "That is fine since in the outer caller `FENCED_INSTANCE_ID` would be treated as fatal, in line 1386.",
        "createdAt" : "2020-10-02T00:46:00Z",
        "updatedAt" : "2020-10-02T00:56:09Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      }
    ],
    "commit" : "34cd77113701ff54ef1c90cde12497e5c01132ca",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +949,953 @@        log.debug(\"Resetting generation after encountering {} from {} response and requesting re-join\", error, api);\n\n        resetStateAndRejoin();\n    }\n"
  },
  {
    "id" : "5d78ea84-8263-44b6-bc5b-bbc3b0ab37d9",
    "prId" : 9667,
    "prUrl" : "https://github.com/apache/kafka/pull/9667#pullrequestreview-545184579",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "22cdbb71-2589-473a-9bbd-aa7fe861c663",
        "parentId" : null,
        "authorId" : "0f776378-bb23-4193-9bb0-1db5973f3781",
        "body" : "Is ```JoinGroupResponseHandler``` a better place to log error? For example, the error ```UNKNOWN_MEMBER_ID``` is log twice. \r\n(https://github.com/apache/kafka/blob/trunk/clients/src/main/java/org/apache/kafka/clients/consumer/internals/AbstractCoordinator.java#L605)\r\n",
        "createdAt" : "2020-12-04T07:48:18Z",
        "updatedAt" : "2020-12-04T18:08:03Z",
        "lastEditedBy" : "0f776378-bb23-4193-9bb0-1db5973f3781",
        "tags" : [
        ]
      },
      {
        "id" : "78762530-757d-4da8-a3e3-7a8651443449",
        "parentId" : "22cdbb71-2589-473a-9bbd-aa7fe861c663",
        "authorId" : "0f776378-bb23-4193-9bb0-1db5973f3781",
        "body" : "For another, does it need some comment to explain why ```MemberIdRequiredException``` is excluded.",
        "createdAt" : "2020-12-04T07:50:39Z",
        "updatedAt" : "2020-12-04T18:08:03Z",
        "lastEditedBy" : "0f776378-bb23-4193-9bb0-1db5973f3781",
        "tags" : [
        ]
      },
      {
        "id" : "9a26f8c2-7187-4a8d-8c1e-835a29c6a6f7",
        "parentId" : "22cdbb71-2589-473a-9bbd-aa7fe861c663",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "I think I agree with you: it is a bit redundant. I think originally it is because this future may contain the error that is either from join-response or from sync-response, but at the moment both errors are logged inside the Join/SyncGroupHandler anyways. Just to maintain compatibility in case some trouble shooting scenarios are dependent on this summary entry for now.",
        "createdAt" : "2020-12-04T18:06:56Z",
        "updatedAt" : "2020-12-04T18:08:03Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      }
    ],
    "commit" : "51dcab57ea74a07df1b6cd7937e2fb2bbf0c1380",
    "line" : 8,
    "diffHunk" : "@@ -1,1 +469,473 @@                // we do not need to log error for memberId required,\n                // since it is not really an error and is transient\n                if (!(exception instanceof MemberIdRequiredException)) {\n                    log.info(\"Rebalance failed.\", exception);\n                }"
  },
  {
    "id" : "0fb45de8-f55c-4ef4-a4fb-1405702ae742",
    "prId" : 9671,
    "prUrl" : "https://github.com/apache/kafka/pull/9671#pullrequestreview-548514208",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a0adefef-40f2-403e-83f8-9c697dbabf81",
        "parentId" : null,
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "I think this is a better approach, but we need to be careful about the callee inside hb thread:\r\n\r\n```\r\nif (findCoordinatorFuture != null || lookupCoordinator().failed())\r\n```\r\n\r\ni.e. a hb thread sending a discover-coordinator request would also cause a future to be assigned, but that future would only be cleared by the main thread caller. Thinking about that for a sec I think this is okay, but maybe worth having a second pair of eyes over it.",
        "createdAt" : "2020-12-02T18:24:25Z",
        "updatedAt" : "2021-01-26T23:14:19Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "4aa1c835-0e16-4517-95da-db5606a2db0e",
        "parentId" : "a0adefef-40f2-403e-83f8-9c697dbabf81",
        "authorId" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "body" : "Ah, good point...actually I think that's probably not ok for it to only ever be cleared in the main thread, since eg the main thread might be stuck in long processing while the hb threads should not be blocked from looking up the coordinator.\r\nSo, maybe we should also call `clearFindCoordinatorFuture` inside the hb thread in the `if (findCoordinatorFuture != null || lookupCoordinator().failed())` block (if it did indeed finish and has failed) -- WDYT?",
        "createdAt" : "2020-12-08T02:44:39Z",
        "updatedAt" : "2021-01-26T23:14:19Z",
        "lastEditedBy" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "tags" : [
        ]
      },
      {
        "id" : "218b6308-8a5b-4060-b494-8abff62c4716",
        "parentId" : "a0adefef-40f2-403e-83f8-9c697dbabf81",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "That makes sense, we can `clearFindCoordinatorFuture` inside the hb thread as well.",
        "createdAt" : "2020-12-09T19:02:22Z",
        "updatedAt" : "2021-01-26T23:14:19Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      }
    ],
    "commit" : "5d111d889e7b994b2c9d6f2d522dc032ff7237d9",
    "line" : 49,
    "diffHunk" : "@@ -1,1 +267,271 @@            }\n\n            clearFindCoordinatorFuture();\n            if (fatalException !=  null)\n                throw fatalException;"
  },
  {
    "id" : "94c38577-1663-4734-8b59-ec65bda1e4bd",
    "prId" : 9671,
    "prUrl" : "https://github.com/apache/kafka/pull/9671#pullrequestreview-576845742",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c4e33731-0718-4ec0-a3e4-7b5508ccb9a7",
        "parentId" : null,
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "I think the issue is spot-on! The logic here becomes a bit hard to understand for other readers now and I'd suggest update the cmment as:\r\n\r\n\"Clear the future so that after the backoff in the next iteration, if hb still sees coordinator unknown it will try re-discover the coordinator in case the main thread cannot\"\r\n\r\nOtherwise, LGTM.",
        "createdAt" : "2021-01-26T23:06:49Z",
        "updatedAt" : "2021-01-26T23:14:19Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "0a8a75e4-f792-4a0d-a61b-e2459b0d2d00",
        "parentId" : "c4e33731-0718-4ec0-a3e4-7b5508ccb9a7",
        "authorId" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "body" : "SG",
        "createdAt" : "2021-01-26T23:13:53Z",
        "updatedAt" : "2021-01-26T23:14:19Z",
        "lastEditedBy" : "d97f50bf-60f9-45b3-81a0-a24a5f42f740",
        "tags" : [
        ]
      }
    ],
    "commit" : "5d111d889e7b994b2c9d6f2d522dc032ff7237d9",
    "line" : 116,
    "diffHunk" : "@@ -1,1 +1369,1373 @@\n                        if (coordinatorUnknown()) {\n                            if (findCoordinatorFuture != null) {\n                                // clear the future so that after the backoff, if the hb still sees coordinator unknown in\n                                // the next iteration it will try to re-discover the coordinator in case the main thread cannot"
  },
  {
    "id" : "ecd5824f-3f7a-460b-a1e9-72e95728f8d7",
    "prId" : 9729,
    "prUrl" : "https://github.com/apache/kafka/pull/9729#pullrequestreview-550528846",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "262db629-1a12-42a7-b845-d57b7733ac93",
        "parentId" : null,
        "authorId" : "6c4430fc-3795-49d6-9c36-cf6aa694824e",
        "body" : "Should this be extracted into a constant?",
        "createdAt" : "2020-12-10T23:33:23Z",
        "updatedAt" : "2020-12-11T23:50:08Z",
        "lastEditedBy" : "6c4430fc-3795-49d6-9c36-cf6aa694824e",
        "tags" : [
        ]
      },
      {
        "id" : "7d1b5192-36e0-4331-a66c-6d5392860abe",
        "parentId" : "262db629-1a12-42a7-b845-d57b7733ac93",
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "I'm ok with it. This is just informational and the literal value is easier to read.",
        "createdAt" : "2020-12-11T19:46:23Z",
        "updatedAt" : "2020-12-11T23:50:08Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      }
    ],
    "commit" : "7e06e0f5464a6eac918f4aa2693e7a797f2dfd75",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +258,262 @@                // we found the coordinator, but the connection has failed, so mark\n                // it dead and backoff before retrying discovery\n                markCoordinatorUnknown(\"coordinator unavailable\");\n                timer.sleep(rebalanceConfig.retryBackoffMs);\n            }"
  },
  {
    "id" : "0c623586-a7f3-4a70-825e-409ba0abffb0",
    "prId" : 10232,
    "prUrl" : "https://github.com/apache/kafka/pull/10232#pullrequestreview-600427641",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "79abd9ff-c3ca-46d7-a0a1-a8e081fd93ab",
        "parentId" : null,
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "Minor cleanup, we only need to print the error message but not the stack trace.",
        "createdAt" : "2021-03-01T06:49:18Z",
        "updatedAt" : "2021-03-12T23:24:12Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      }
    ],
    "commit" : "c8cb7ab8291f610289f56e5497d8e1958afc63d5",
    "line" : 63,
    "diffHunk" : "@@ -1,1 +857,861 @@        @Override\n        public void onFailure(RuntimeException e, RequestFuture<Void> future) {\n            log.debug(\"FindCoordinator request failed due to {}\", e.toString());\n\n            if (!(e instanceof RetriableException)) {"
  }
]
[
  {
    "id" : "41cf0e93-e749-4957-94e3-25dba373879e",
    "prId" : 10137,
    "prUrl" : "https://github.com/apache/kafka/pull/10137#pullrequestreview-596492661",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "88d73070-ee13-42da-b5f6-fddd11e9e048",
        "parentId" : null,
        "authorId" : "0f776378-bb23-4193-9bb0-1db5973f3781",
        "body" : "Pardon me, KIP-695 does not include this change. It seems KIP-695 is still based on `metadata`? Please correct me If I misunderstand anything :)",
        "createdAt" : "2021-02-17T05:18:42Z",
        "updatedAt" : "2021-02-23T16:44:16Z",
        "lastEditedBy" : "0f776378-bb23-4193-9bb0-1db5973f3781",
        "tags" : [
        ]
      },
      {
        "id" : "5567f395-d5d3-4bee-a6c0-a36af899d443",
        "parentId" : "88d73070-ee13-42da-b5f6-fddd11e9e048",
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "Woah, you are _fast_, @chia7712 !\r\n\r\nI just sent a message to the vote thread. I wanted to submit this PR first so that the vote thread message can have the full context available.\r\n\r\nDo you mind reading over what I said there? If it sounds good to you, then I'll update the KIP, and we can maybe put this whole mess to bed.",
        "createdAt" : "2021-02-17T05:21:52Z",
        "updatedAt" : "2021-02-23T16:44:16Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      },
      {
        "id" : "b4897c87-9b9e-46b1-8dd9-5c5fdfa13667",
        "parentId" : "88d73070-ee13-42da-b5f6-fddd11e9e048",
        "authorId" : "d8c7cf80-a55a-474c-a4f4-f60a9efda52c",
        "body" : "Quick question, should the API take a `Collection<TopicPartition>` like other APIs?",
        "createdAt" : "2021-02-22T15:40:23Z",
        "updatedAt" : "2021-02-23T16:44:16Z",
        "lastEditedBy" : "d8c7cf80-a55a-474c-a4f4-f60a9efda52c",
        "tags" : [
        ]
      },
      {
        "id" : "f4f5bc64-ea00-407c-978d-2bc8d3d7fa5a",
        "parentId" : "88d73070-ee13-42da-b5f6-fddd11e9e048",
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "Thanks @ijuma, I considered it, but decided on the current API because:\r\n1. This is a very quick, local in-memory lookup, so there's no reason to batch multiple requests in one\r\n2. It complicates the return type. We'd have to return either a `Map<TP, Long>`, with mappings missing for unknown lags (which creates unfortunate null semantics for users), or a `Map<TP, OptionalLong>` which creates a complex-to-understand two hop lookup (`lag:=result.get(tp).get()`). Or else, we could return a more complex domain object object like @chia7712 proposed in the mailing list. All these complications seem like unnecessary complexity in the case of this particular API, given the first point.\r\n\r\nWDYT?",
        "createdAt" : "2021-02-22T16:59:02Z",
        "updatedAt" : "2021-02-23T16:44:16Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      },
      {
        "id" : "a517f033-2792-43c3-8478-1c5a585fd396",
        "parentId" : "88d73070-ee13-42da-b5f6-fddd11e9e048",
        "authorId" : "d8c7cf80-a55a-474c-a4f4-f60a9efda52c",
        "body" : "If there is no batching benefit, then the simpler API makes sense. @hachikuji Any reason why batching could be useful here?",
        "createdAt" : "2021-02-22T17:08:21Z",
        "updatedAt" : "2021-02-23T16:44:16Z",
        "lastEditedBy" : "d8c7cf80-a55a-474c-a4f4-f60a9efda52c",
        "tags" : [
        ]
      },
      {
        "id" : "6070ef5e-6f71-4f57-af0e-61eff8387cfd",
        "parentId" : "88d73070-ee13-42da-b5f6-fddd11e9e048",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "For API calls that may incur a broker round trip, have batching of partitions makes sense. For this API I think single partition lookup is good enough.",
        "createdAt" : "2021-02-23T05:47:52Z",
        "updatedAt" : "2021-02-23T16:44:16Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "5ab7185c-878c-4554-9fa3-77e5b19d43bc",
        "parentId" : "88d73070-ee13-42da-b5f6-fddd11e9e048",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "If we concern that users may call this function too frequent looping a large number of partitions, and each call is synchronizing on the subscription state, then maybe we can make it in a batching mode.",
        "createdAt" : "2021-02-23T06:02:42Z",
        "updatedAt" : "2021-02-23T16:44:17Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "db86abcc-8e90-4bb7-8b41-4ac063dddcdd",
        "parentId" : "88d73070-ee13-42da-b5f6-fddd11e9e048",
        "authorId" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "body" : "That's a good point, @guozhangwang. Entering the synchronized block will have some overhead each time it's called.\r\n\r\nI think we can just reason about the use cases here. My guess is that people would either tend to spot-check specific lags, as we are doing here, or they would tend to periodically check all lags. In the former case, I'd hazard that the current API is fine. In the latter case, we'd face more overhead. I'm sure this is motivated reasoning, but perhaps we can lump the latter case in with @chia7712 's suggestion to expose more metadata and defer it to the future.",
        "createdAt" : "2021-02-23T15:52:21Z",
        "updatedAt" : "2021-02-23T16:44:17Z",
        "lastEditedBy" : "f84c555e-0e5d-4773-b994-4121b6b8dada",
        "tags" : [
        ]
      }
    ],
    "commit" : "096c4e321a2e687c168fb4e5d48d1711461e23b2",
    "line" : 15,
    "diffHunk" : "@@ -1,1 +248,252 @@     * @see KafkaConsumer#currentLag(TopicPartition)\n     */\n    OptionalLong currentLag(TopicPartition topicPartition);\n\n    /**"
  }
]
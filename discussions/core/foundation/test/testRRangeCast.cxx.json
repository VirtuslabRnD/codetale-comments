[
  {
    "id" : "10f86709-b055-4476-93be-f06fd8df8f4a",
    "prId" : 8769,
    "prUrl" : "https://github.com/root-project/root/pull/8769#pullrequestreview-723392744",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "329495c4-b501-4f70-bc72-43aff312c6b3",
        "parentId" : null,
        "authorId" : "ec1903c5-44e7-4fb1-bee9-25de61836fba",
        "body" : "Here, you are checking the pointers. However, the types (i.e. that the casting happens) aren't checked. See this:\r\n```c++\r\nroot [0] class A{} a; class B : public A {} b;\r\nroot [3] &a == &b\r\n(bool) false\r\nroot [4] static_cast<A*>(&b) == &b\r\n(bool) true\r\n```\r\nThat's why I suggested the `static_assert`.",
        "createdAt" : "2021-08-05T13:06:40Z",
        "updatedAt" : "2021-08-05T13:07:14Z",
        "lastEditedBy" : "ec1903c5-44e7-4fb1-bee9-25de61836fba",
        "tags" : [
        ]
      },
      {
        "id" : "307ab998-55f2-40bc-8f84-f5ffc1151a0e",
        "parentId" : "329495c4-b501-4f70-bc72-43aff312c6b3",
        "authorId" : "080bddae-e637-45c8-b6c1-53aef7161d62",
        "body" : "Ah okay, I thought this was implicitly done with the pointer comparison, but I checked now that it doesn't cover it because you can compare `A*` with `B*`. Now I brought in the static assert.",
        "createdAt" : "2021-08-05T14:00:28Z",
        "updatedAt" : "2021-08-05T14:00:28Z",
        "lastEditedBy" : "080bddae-e637-45c8-b6c1-53aef7161d62",
        "tags" : [
        ]
      }
    ],
    "commit" : "221173a85d2f78a1a61a1b68be3f47f60918bef4",
    "line" : 21,
    "diffHunk" : "@@ -1,1 +19,23 @@      static_assert(std::is_same<decltype(item), const ClassB *>::value,\n                    \"RangeStaticCast didn't convert to the right type\");\n      EXPECT_EQ(item, static_cast<const ClassB *>(arr[n]));\n      ++n;\n   }"
  },
  {
    "id" : "9101c888-121d-4abc-b7eb-c0bec0c251b7",
    "prId" : 8769,
    "prUrl" : "https://github.com/root-project/root/pull/8769#pullrequestreview-723392744",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1685c4f5-1842-438f-a624-3de1ecc9c7bc",
        "parentId" : null,
        "authorId" : "ec1903c5-44e7-4fb1-bee9-25de61836fba",
        "body" : "Here, you are checking the pointers. However, the types (i.e. that the casting happens) aren't checked. See this:\r\n```c++\r\nroot [0] class A{} a; class B : public A {} b;\r\nroot [3] &a == &b\r\n(bool) false\r\nroot [4] static_cast<A*>(&b) == &b\r\n(bool) true\r\n```\r\nThat's why I suggested the `static_assert`.",
        "createdAt" : "2021-08-05T13:06:40Z",
        "updatedAt" : "2021-08-05T13:07:14Z",
        "lastEditedBy" : "ec1903c5-44e7-4fb1-bee9-25de61836fba",
        "tags" : [
        ]
      },
      {
        "id" : "1d711699-0082-42fb-ac50-9fc88fa6e7ea",
        "parentId" : "1685c4f5-1842-438f-a624-3de1ecc9c7bc",
        "authorId" : "080bddae-e637-45c8-b6c1-53aef7161d62",
        "body" : "Ah okay, I thought this was implicitly done with the pointer comparison, but I checked now that it doesn't cover it because you can compare `A*` with `B*`. Now I brought in the static assert.",
        "createdAt" : "2021-08-05T14:00:28Z",
        "updatedAt" : "2021-08-05T14:00:28Z",
        "lastEditedBy" : "080bddae-e637-45c8-b6c1-53aef7161d62",
        "tags" : [
        ]
      }
    ],
    "commit" : "221173a85d2f78a1a61a1b68be3f47f60918bef4",
    "line" : 21,
    "diffHunk" : "@@ -1,1 +19,23 @@      static_assert(std::is_same<decltype(item), const ClassB *>::value,\n                    \"RangeStaticCast didn't convert to the right type\");\n      EXPECT_EQ(item, static_cast<const ClassB *>(arr[n]));\n      ++n;\n   }"
  }
]
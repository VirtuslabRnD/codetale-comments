[
  {
    "id" : "4cedbc77-3416-43dd-9079-bd8ce76954e2",
    "prId" : 636,
    "prUrl" : "https://github.com/root-project/root/pull/636#pullrequestreview-43679592",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d2ad6f42-f6fc-42c5-93a5-d660576d74e4",
        "parentId" : null,
        "authorId" : "335eabbd-4b70-43fb-a046-bf82995f5dd3",
        "body" : "What is the difference between TakeFirst and TakeFirstParameter?  Do we need both?  Can we distinguish them more?",
        "createdAt" : "2017-06-13T06:43:10Z",
        "updatedAt" : "2017-06-26T20:17:08Z",
        "lastEditedBy" : "335eabbd-4b70-43fb-a046-bf82995f5dd3",
        "tags" : [
        ]
      },
      {
        "id" : "09948b74-6fa5-4cfb-8f6e-848e3625211d",
        "parentId" : "d2ad6f42-f6fc-42c5-93a5-d660576d74e4",
        "authorId" : "f2c15ca6-f995-45d3-a26d-40d002e52d07",
        "body" : "`TakeFirst` acts on variadic lists of types, e.g. `TakeFirst_t<A,B>` is `A`. `TakeFirstParameter` acts on the parameter list of a template object, e.g. `TakeFirstParameter_t<U<A,B>>` is `A`. They do different things, so I would say we \"need\" them both. I'm open to suggestions regarding the names (`TakeFirstType` and `TakeFirstParameter`?). I thought the docs were clear but maybe not?",
        "createdAt" : "2017-06-13T07:44:09Z",
        "updatedAt" : "2017-06-26T20:17:08Z",
        "lastEditedBy" : "f2c15ca6-f995-45d3-a26d-40d002e52d07",
        "tags" : [
        ]
      },
      {
        "id" : "8bd2799b-081e-447f-aa61-3384e0be1f98",
        "parentId" : "d2ad6f42-f6fc-42c5-93a5-d660576d74e4",
        "authorId" : "f2c15ca6-f995-45d3-a26d-40d002e52d07",
        "body" : "renamed to `TakeFirstType`",
        "createdAt" : "2017-06-13T10:00:40Z",
        "updatedAt" : "2017-06-26T20:17:08Z",
        "lastEditedBy" : "f2c15ca6-f995-45d3-a26d-40d002e52d07",
        "tags" : [
        ]
      },
      {
        "id" : "4e506d28-10cc-4cff-a8d7-7e7f5b1ab253",
        "parentId" : "d2ad6f42-f6fc-42c5-93a5-d660576d74e4",
        "authorId" : "335eabbd-4b70-43fb-a046-bf82995f5dd3",
        "body" : "I suppose your renamed the first one (formely TakeFirst), in which case, this is indeed better.  thanks",
        "createdAt" : "2017-06-13T10:19:03Z",
        "updatedAt" : "2017-06-26T20:17:08Z",
        "lastEditedBy" : "335eabbd-4b70-43fb-a046-bf82995f5dd3",
        "tags" : [
        ]
      }
    ],
    "commit" : "24b2b18b273d5b2438645822c2b172b483364567",
    "line" : 137,
    "diffHunk" : "@@ -1,1 +135,139 @@///      TakeFirstParameter<T> is T\ntemplate <typename T>\nstruct TakeFirstParameter {\n   using type = void;\n};"
  },
  {
    "id" : "3f0ae2c7-fffd-4e6a-997d-d5ad2787cef7",
    "prId" : 636,
    "prUrl" : "https://github.com/root-project/root/pull/636#pullrequestreview-45905551",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6e89d1fd-ccaa-4962-8bed-54c9a82b3add",
        "parentId" : null,
        "authorId" : "09b7e073-cbeb-42e8-aa22-8b1468de56ae",
        "body" : "I'd have written that as\r\n```\r\ntemplate<class A,\r\n  class NonConstA = typename std::remove_const<A>::type,\r\n  class ConstA = typename std::add_const<A>::type>\r\nTest(NonConstA::iterator = {},\r\n   ConstA::const_iterator = {},\r\n   NonConstA::iterator = decltype(NonConstA().begin())()\r\n   NonConstA::iterator = decltype(NonConstA().end())(),\r\n   ConstA::const_iterator = decltype(ConstA().begin())(),\r\n   ConstA::const_iterator = decltype(ConstA().end())(),\r\n   bool = typename std::is_same<delctype(*ConstA::const_iterator()), typename add_const<ConstA::value_type>::type>::value,\r\n   bool = typename std::is_same<delctype(*NonConstA::iterator()), ConstA::value_type>::value)\r\n```\r\nThis ensures that\r\n- the container and `(const_)iterator` are default constructible\r\n- there is a `(const_)iterator` that matches the return types of `begin()` and `end()`, const and non-const versions,\r\n- `(const_)iterator` can be derefed giving `(const) value_type`\r\n\r\nI see you have more tests in the body. Note that e.g. `**pi`will trigger a compilation failure if `iterator` has no deref, instead of returning `false`,  which is why I added checks to the signature. More might be needed.",
        "createdAt" : "2017-06-13T07:36:51Z",
        "updatedAt" : "2017-06-26T20:17:08Z",
        "lastEditedBy" : "09b7e073-cbeb-42e8-aa22-8b1468de56ae",
        "tags" : [
        ]
      },
      {
        "id" : "b0cf5003-5d96-4eb6-90f1-d73f9a5d5c50",
        "parentId" : "6e89d1fd-ccaa-4962-8bed-54c9a82b3add",
        "authorId" : "f2c15ca6-f995-45d3-a26d-40d002e52d07",
        "body" : "Thanks for looking into this. This was implemented by @dpiparo so I would ask his opinion too.",
        "createdAt" : "2017-06-13T08:17:56Z",
        "updatedAt" : "2017-06-26T20:17:08Z",
        "lastEditedBy" : "f2c15ca6-f995-45d3-a26d-40d002e52d07",
        "tags" : [
        ]
      },
      {
        "id" : "8691a862-4d4b-4236-bca4-6b37e4ad91b4",
        "parentId" : "6e89d1fd-ccaa-4962-8bed-54c9a82b3add",
        "authorId" : "28bf1eea-b1ed-4971-b001-9f6e3a5ec44f",
        "body" : "Hi @bluehood , @Axel-Naumann I am of course fine with the new implementation!",
        "createdAt" : "2017-06-23T06:09:16Z",
        "updatedAt" : "2017-06-26T20:17:08Z",
        "lastEditedBy" : "28bf1eea-b1ed-4971-b001-9f6e3a5ec44f",
        "tags" : [
        ]
      }
    ],
    "commit" : "24b2b18b273d5b2438645822c2b172b483364567",
    "line" : 43,
    "diffHunk" : "@@ -1,1 +41,45 @@\n   template <typename A>\n   static constexpr bool Test(A *pt, A const *cpt = nullptr, decltype(pt->begin()) * = nullptr,\n                              decltype(pt->end()) * = nullptr, decltype(cpt->begin()) * = nullptr,\n                              decltype(cpt->end()) * = nullptr, typename A::iterator *pi = nullptr,"
  },
  {
    "id" : "82511c9e-9921-4da7-aad7-8da6f355e8c9",
    "prId" : 636,
    "prUrl" : "https://github.com/root-project/root/pull/636#pullrequestreview-43675855",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "71c761b5-da67-4048-935e-5d0fb29aed47",
        "parentId" : null,
        "authorId" : "09b7e073-cbeb-42e8-aa22-8b1468de56ae",
        "body" : "I would make the generic one empty. Then have a specialization for those `T` that have a call operator.",
        "createdAt" : "2017-06-13T07:46:22Z",
        "updatedAt" : "2017-06-26T20:17:08Z",
        "lastEditedBy" : "09b7e073-cbeb-42e8-aa22-8b1468de56ae",
        "tags" : [
        ]
      },
      {
        "id" : "7385f26b-db45-4e43-a885-0c22ce4bd726",
        "parentId" : "71c761b5-da67-4048-935e-5d0fb29aed47",
        "authorId" : "f2c15ca6-f995-45d3-a26d-40d002e52d07",
        "body" : "will do",
        "createdAt" : "2017-06-13T10:02:17Z",
        "updatedAt" : "2017-06-26T20:17:08Z",
        "lastEditedBy" : "f2c15ca6-f995-45d3-a26d-40d002e52d07",
        "tags" : [
        ]
      }
    ],
    "commit" : "24b2b18b273d5b2438645822c2b172b483364567",
    "line" : 74,
    "diffHunk" : "@@ -1,1 +72,76 @@\n/// Extract types from the signature of a callable object.\ntemplate <typename T>\nstruct CallableTraits {\n   using arg_types = typename CallableTraits<decltype(&T::operator())>::arg_types;"
  },
  {
    "id" : "0357e971-e6f7-43ac-b931-ab4349cc7c9d",
    "prId" : 636,
    "prUrl" : "https://github.com/root-project/root/pull/636#pullrequestreview-43664610",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6fc379a5-d535-4ee4-8c97-9c634750899a",
        "parentId" : null,
        "authorId" : "09b7e073-cbeb-42e8-aa22-8b1468de56ae",
        "body" : "Can you spell the *result* (please use the std wording here) type using `result_of` and `invoke_result`, for all cases, moving the arg_types deduction into a helper detail struct that you then partially specialize?",
        "createdAt" : "2017-06-13T07:51:45Z",
        "updatedAt" : "2017-06-26T20:17:08Z",
        "lastEditedBy" : "09b7e073-cbeb-42e8-aa22-8b1468de56ae",
        "tags" : [
        ]
      },
      {
        "id" : "7e00f6c3-fb71-47a8-bde1-b2fb760abf5e",
        "parentId" : "6fc379a5-d535-4ee4-8c97-9c634750899a",
        "authorId" : "09b7e073-cbeb-42e8-aa22-8b1468de56ae",
        "body" : "Let me rephrase:\r\n```\r\nstruct foo{\r\n  int operator()(int);\r\n  double operator()(double);\r\n};\r\nusing res = typename CallableTraits<foo(float)>::ret_type;\r\n```\r\nshould `res` be `double` or should this be ill-formed?",
        "createdAt" : "2017-06-13T08:00:21Z",
        "updatedAt" : "2017-06-26T20:17:08Z",
        "lastEditedBy" : "09b7e073-cbeb-42e8-aa22-8b1468de56ae",
        "tags" : [
        ]
      },
      {
        "id" : "8d4e8519-acf3-401d-a83d-d0fae5f1d8a9",
        "parentId" : "6fc379a5-d535-4ee4-8c97-9c634750899a",
        "authorId" : "f2c15ca6-f995-45d3-a26d-40d002e52d07",
        "body" : "What is the standard wording? `result_of` and `invoke_result` contain a `type`, but I think it would be a confusing name here? boost uses `return_type` in their `function_traits`, I can change it to that if you prefer.\r\n\r\nYour example should be ill-formed because `CallableTraits` does not require to specify the argument types, users just pass in a callable object. Supporting the syntax you used might be a nice addition but we have no use for it, at least for now.",
        "createdAt" : "2017-06-13T08:27:58Z",
        "updatedAt" : "2017-06-26T20:17:08Z",
        "lastEditedBy" : "f2c15ca6-f995-45d3-a26d-40d002e52d07",
        "tags" : [
        ]
      },
      {
        "id" : "2b524f4c-6b46-432d-b304-e1462dac9cd5",
        "parentId" : "6fc379a5-d535-4ee4-8c97-9c634750899a",
        "authorId" : "09b7e073-cbeb-42e8-aa22-8b1468de56ae",
        "body" : "Forget what I said - you test the callable, not the expression. Return type is just fine.",
        "createdAt" : "2017-06-13T09:16:33Z",
        "updatedAt" : "2017-06-26T20:17:08Z",
        "lastEditedBy" : "09b7e073-cbeb-42e8-aa22-8b1468de56ae",
        "tags" : [
        ]
      }
    ],
    "commit" : "24b2b18b273d5b2438645822c2b172b483364567",
    "line" : 78,
    "diffHunk" : "@@ -1,1 +76,80 @@   using arg_types = typename CallableTraits<decltype(&T::operator())>::arg_types;\n   using arg_types_nodecay = typename CallableTraits<decltype(&T::operator())>::arg_types_nodecay;\n   using ret_type = typename CallableTraits<decltype(&T::operator())>::ret_type;\n};\n"
  },
  {
    "id" : "6af94873-3e53-4353-80eb-2bc8e9371d2b",
    "prId" : 636,
    "prUrl" : "https://github.com/root-project/root/pull/636#pullrequestreview-43675650",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "caf33024-eb08-411c-9d88-0ef9425c54cb",
        "parentId" : null,
        "authorId" : "09b7e073-cbeb-42e8-aa22-8b1468de56ae",
        "body" : "You allow for non-member function references but not for member function references. Intentional?",
        "createdAt" : "2017-06-13T07:52:56Z",
        "updatedAt" : "2017-06-26T20:17:08Z",
        "lastEditedBy" : "09b7e073-cbeb-42e8-aa22-8b1468de56ae",
        "tags" : [
        ]
      },
      {
        "id" : "3bfadedb-d962-481b-b867-f919b463a626",
        "parentId" : "caf33024-eb08-411c-9d88-0ef9425c54cb",
        "authorId" : "f2c15ca6-f995-45d3-a26d-40d002e52d07",
        "body" : "Can you give me an example?\r\n\r\nThis works:\r\n```\r\nstruct A { void foo() {} };\r\nstatic_assert(std::is_same<CallableTraits<decltype(&A::foo)>::ret_type, void>::value, \"\");\r\n```",
        "createdAt" : "2017-06-13T08:37:12Z",
        "updatedAt" : "2017-06-26T20:17:08Z",
        "lastEditedBy" : "f2c15ca6-f995-45d3-a26d-40d002e52d07",
        "tags" : [
        ]
      },
      {
        "id" : "94589b71-16e3-43d4-b51b-ea5241b2df75",
        "parentId" : "caf33024-eb08-411c-9d88-0ef9425c54cb",
        "authorId" : "09b7e073-cbeb-42e8-aa22-8b1468de56ae",
        "body" : "Does `static_assert(std::is_same<CallableTraits<decltype(A::foo)>::ret_type, void>::value, \"\");` work?",
        "createdAt" : "2017-06-13T09:15:58Z",
        "updatedAt" : "2017-06-26T20:17:08Z",
        "lastEditedBy" : "09b7e073-cbeb-42e8-aa22-8b1468de56ae",
        "tags" : [
        ]
      },
      {
        "id" : "6f02871b-8902-493e-ae3f-e35203b9f4e5",
        "parentId" : "caf33024-eb08-411c-9d88-0ef9425c54cb",
        "authorId" : "f2c15ca6-f995-45d3-a26d-40d002e52d07",
        "body" : "It does not. Can you ever use `decltype(A::foo)` anywhere?",
        "createdAt" : "2017-06-13T09:49:49Z",
        "updatedAt" : "2017-06-26T20:17:08Z",
        "lastEditedBy" : "f2c15ca6-f995-45d3-a26d-40d002e52d07",
        "tags" : [
        ]
      },
      {
        "id" : "8561241c-3e9f-4f8a-82e5-66638c14a91f",
        "parentId" : "caf33024-eb08-411c-9d88-0ef9425c54cb",
        "authorId" : "09b7e073-cbeb-42e8-aa22-8b1468de56ae",
        "body" : "Indeed, thanks! Forget this comment, too! :-)",
        "createdAt" : "2017-06-13T10:01:19Z",
        "updatedAt" : "2017-06-26T20:17:08Z",
        "lastEditedBy" : "09b7e073-cbeb-42e8-aa22-8b1468de56ae",
        "tags" : [
        ]
      }
    ],
    "commit" : "24b2b18b273d5b2438645822c2b172b483364567",
    "line" : 91,
    "diffHunk" : "@@ -1,1 +89,93 @@// mutable lambdas and functor classes\ntemplate <typename R, typename T, typename... Args>\nstruct CallableTraits<R (T::*)(Args...)> {\n   using arg_types = TypeList<typename std::decay<Args>::type...>;\n   using arg_types_nodecay = TypeList<Args...>;"
  },
  {
    "id" : "fd57f73b-47dd-432d-b2a6-61e748a19d8b",
    "prId" : 636,
    "prUrl" : "https://github.com/root-project/root/pull/636#pullrequestreview-43675375",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1c4702a5-977c-47fe-bea6-85e64a424705",
        "parentId" : null,
        "authorId" : "09b7e073-cbeb-42e8-aa22-8b1468de56ae",
        "body" : "That is a very ... rare ... behavior. Providing this as a general tool might see misuses / misunderstanding of the interface. I'd naively expect that `TakeFirstParameter<T>` is either empty or ill-formed, instead of mixing template levels... Do you expect generic usage of this? (Do you really know you need this behavior in your use case? I didn't look at it, it seems surprising...)",
        "createdAt" : "2017-06-13T08:04:42Z",
        "updatedAt" : "2017-06-26T20:17:08Z",
        "lastEditedBy" : "09b7e073-cbeb-42e8-aa22-8b1468de56ae",
        "tags" : [
        ]
      },
      {
        "id" : "f430b69e-d58a-4801-8e65-16da1b58d4e6",
        "parentId" : "1c4702a5-977c-47fe-bea6-85e64a424705",
        "authorId" : "f2c15ca6-f995-45d3-a26d-40d002e52d07",
        "body" : "I agree, I will change the behaviour",
        "createdAt" : "2017-06-13T08:30:53Z",
        "updatedAt" : "2017-06-26T20:17:08Z",
        "lastEditedBy" : "f2c15ca6-f995-45d3-a26d-40d002e52d07",
        "tags" : [
        ]
      },
      {
        "id" : "d86211c7-7710-4cae-b8b7-fa3699426c60",
        "parentId" : "1c4702a5-977c-47fe-bea6-85e64a424705",
        "authorId" : "f2c15ca6-f995-45d3-a26d-40d002e52d07",
        "body" : "done",
        "createdAt" : "2017-06-13T09:59:57Z",
        "updatedAt" : "2017-06-26T20:17:08Z",
        "lastEditedBy" : "f2c15ca6-f995-45d3-a26d-40d002e52d07",
        "tags" : [
        ]
      }
    ],
    "commit" : "24b2b18b273d5b2438645822c2b172b483364567",
    "line" : 135,
    "diffHunk" : "@@ -1,1 +133,137 @@/// For non-template types, the result is the type itself.\n/// e.g. TakeFirstParameter<U<A,B>> is A\n///      TakeFirstParameter<T> is T\ntemplate <typename T>\nstruct TakeFirstParameter {"
  },
  {
    "id" : "b3bbf22d-7178-4659-b72b-642be46b971f",
    "prId" : 1029,
    "prUrl" : "https://github.com/root-project/root/pull/1029#pullrequestreview-64197244",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "85f35884-6168-4568-876b-9731183ff3b5",
        "parentId" : null,
        "authorId" : "a66b5f61-1206-4ddd-b280-befb0005276f",
        "body" : "Why is this here and not in `ROOT/RArrayView.hxx`? I don't understand.",
        "createdAt" : "2017-09-21T06:12:42Z",
        "updatedAt" : "2017-09-21T06:12:43Z",
        "lastEditedBy" : "a66b5f61-1206-4ddd-b280-befb0005276f",
        "tags" : [
        ]
      },
      {
        "id" : "b1517a0d-3d91-4597-b618-e72d723ceecb",
        "parentId" : "85f35884-6168-4568-876b-9731183ff3b5",
        "authorId" : "28bf1eea-b1ed-4971-b001-9f6e3a5ec44f",
        "body" : "I think because we would like to have the TypeTraits to be aware of the array_view and not the opposite.\r\n",
        "createdAt" : "2017-09-21T07:02:33Z",
        "updatedAt" : "2017-09-21T07:02:33Z",
        "lastEditedBy" : "28bf1eea-b1ed-4971-b001-9f6e3a5ec44f",
        "tags" : [
        ]
      },
      {
        "id" : "1dfdcce8-89ca-4bce-9f25-010f2982dc6c",
        "parentId" : "85f35884-6168-4568-876b-9731183ff3b5",
        "authorId" : "a66b5f61-1206-4ddd-b280-befb0005276f",
        "body" : "Ah, sorry, somehow I though that this was a TDF header... makes sense.",
        "createdAt" : "2017-09-21T07:23:01Z",
        "updatedAt" : "2017-09-21T07:23:01Z",
        "lastEditedBy" : "a66b5f61-1206-4ddd-b280-befb0005276f",
        "tags" : [
        ]
      }
    ],
    "commit" : "931734e84aaff00d2223fa11ca6fc6d92afe0248",
    "line" : 15,
    "diffHunk" : "@@ -1,1 +68,72 @@struct IsContainer<std::array_view<T>> {\n   static constexpr bool value = true;\n};\n\n/// Lightweight storage for a collection of types."
  }
]
[
  {
    "id" : "4d18fe6f-0230-4161-a299-29b4af834c82",
    "prId" : 1351,
    "prUrl" : "https://github.com/root-project/root/pull/1351#pullrequestreview-78447777",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ca4b275d-3d2d-4cb6-9ca8-088ca2f83fa2",
        "parentId" : null,
        "authorId" : "a66b5f61-1206-4ddd-b280-befb0005276f",
        "body" : "> Eventhough we hold the read lock if one of the call to RecursiveRemove request the write lock then the read lock will be suspended and another thread can modify the list\r\n\r\nWhat? We cannot suspend the read lock. The writer *has* to wait for all readers to be done before writing anything.",
        "createdAt" : "2017-11-22T08:28:09Z",
        "updatedAt" : "2017-11-26T23:21:45Z",
        "lastEditedBy" : "a66b5f61-1206-4ddd-b280-befb0005276f",
        "tags" : [
        ]
      },
      {
        "id" : "f982daae-ad3a-4259-8410-73d61aa37c8b",
        "parentId" : "ca4b275d-3d2d-4cb6-9ca8-088ca2f83fa2",
        "authorId" : "335eabbd-4b70-43fb-a046-bf82995f5dd3",
        "body" : "This is one of the case:\r\n\r\nthread1: Take ReadLock; call Stuff; inside Stuff: Try to take the WriteLock\r\nthread2: Take ReadLock; Call Stuff; inside Stuff: Try to take the WriteLock\r\n\r\nthere we can either have a dead-lock or one of the two threads must yield their read-lock ...",
        "createdAt" : "2017-11-22T12:19:05Z",
        "updatedAt" : "2017-11-26T23:21:45Z",
        "lastEditedBy" : "335eabbd-4b70-43fb-a046-bf82995f5dd3",
        "tags" : [
        ]
      },
      {
        "id" : "79c0ac1c-0e2e-4aeb-aad0-a9ffd31c74eb",
        "parentId" : "ca4b275d-3d2d-4cb6-9ca8-088ca2f83fa2",
        "authorId" : "a66b5f61-1206-4ddd-b280-befb0005276f",
        "body" : "Yes, readers cannot block after acquiring the lock for any reason. This means that you cannot \"call stuff\" after acquiring the read lock.",
        "createdAt" : "2017-11-22T13:09:32Z",
        "updatedAt" : "2017-11-26T23:21:45Z",
        "lastEditedBy" : "a66b5f61-1206-4ddd-b280-befb0005276f",
        "tags" : [
        ]
      },
      {
        "id" : "731274b8-18b4-4263-aeae-3be4e8f2ffbd",
        "parentId" : "ca4b275d-3d2d-4cb6-9ca8-088ca2f83fa2",
        "authorId" : "335eabbd-4b70-43fb-a046-bf82995f5dd3",
        "body" : "Yes.  Although adhering strictly to this would mean excessive lock churn, hence the comment/behavior noted above.",
        "createdAt" : "2017-11-22T13:44:48Z",
        "updatedAt" : "2017-11-26T23:21:45Z",
        "lastEditedBy" : "335eabbd-4b70-43fb-a046-bf82995f5dd3",
        "tags" : [
        ]
      }
    ],
    "commit" : "998e13365a4cf976200895680305b1c6bf40dddc",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +338,342 @@   // another thread can modify the list; thanks to the shared_pointer\n   // forward-and-backward links, our view of the list is still intact\n   // but might contains node will nullptr payload)\n   auto lnk  = fFirst;\n   decltype(lnk) next;"
  }
]
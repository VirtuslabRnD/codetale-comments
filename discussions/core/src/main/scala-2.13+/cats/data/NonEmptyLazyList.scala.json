[
  {
    "id" : "9f1c0ce7-2d2d-4fee-ba20-90a2eba2f848",
    "prId" : 3382,
    "prUrl" : "https://github.com/typelevel/cats/pull/3382#pullrequestreview-422634134",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a0f03ccc-0d32-4be5-b456-f9b90ece5912",
        "parentId" : null,
        "authorId" : "ee04e3fc-01cf-4b53-b73a-ec7dfe8d58cf",
        "body" : "There is a bit of LISP here. This code may be more readable as follows: \r\n\r\n```suggestion\r\n          val fh = f(head)\r\n          tail match {\r\n            case _ if tail.isEmpty => \r\n              Eval.now(Apply[G].map(fh)(NonEmptyLazyList(_)))\r\n            case h #:: ttail => \r\n              val ftail = Eval.defer(loop(h, ttail))\r\n              Apply[G].map2Eval(fh, ftail)(_ +: _)\r\n          }\r\n```\r\nThe changes are: \r\n\r\n- Extract `f(head)`, which is eagerly evaluated in both branches, as a `val`.\r\n- Replace the `Option.fold` by a pattern-match.\r\n- Replace the cases of `headOption` by two cases on the `tail` lazy list itself. For the first case, there seems not to be any case-object, like `Nil`, for the empty list. [Discussion](https://users.scala-lang.org/t/pattern-matching-lazylist/5105).\r\n- In the second case, abbreviate `(b, acc) => b +: acc` by underscores `_ +: _`.",
        "createdAt" : "2020-04-19T12:18:40Z",
        "updatedAt" : "2020-06-02T12:28:35Z",
        "lastEditedBy" : "ee04e3fc-01cf-4b53-b73a-ec7dfe8d58cf",
        "tags" : [
        ]
      },
      {
        "id" : "13dc1fb8-d6e0-460a-9dfd-411101357a68",
        "parentId" : "a0f03ccc-0d32-4be5-b456-f9b90ece5912",
        "authorId" : "429eae10-8138-404f-b9b2-421bcdcf30be",
        "body" : "Hello, I see what you mean there. \r\n\r\nOn my part, usually I try to avoid pattern match (it's slow)",
        "createdAt" : "2020-06-02T12:41:00Z",
        "updatedAt" : "2020-06-02T12:41:24Z",
        "lastEditedBy" : "429eae10-8138-404f-b9b2-421bcdcf30be",
        "tags" : [
        ]
      }
    ],
    "commit" : "50a0cf91c1750c57b32be2669c4096f2f7d9e0f1",
    "line" : 12,
    "diffHunk" : "@@ -1,1 +478,482 @@          tail.headOption.fold(Eval.now(Apply[G].map(f(head))(NonEmptyLazyList(_)))) { h =>\n            Apply[G].map2Eval(f(head), Eval.defer(loop(h, tail.tail)))((b, acc) => b +: acc)\n          }\n\n        loop(fa.head, fa.tail).value"
  },
  {
    "id" : "ddc06c40-31eb-4e98-b1e8-ef4fe8a1df82",
    "prId" : 2983,
    "prUrl" : "https://github.com/typelevel/cats/pull/2983#pullrequestreview-277589863",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "42d58715-dd20-4587-84ec-e564c70505f8",
        "parentId" : null,
        "authorId" : "240add12-1fe5-499a-918c-053b1f46b348",
        "body" : "I think this is the wrong `Applicative`, no? It's `pure` should be `LazyList.continually`.",
        "createdAt" : "2019-08-20T19:27:31Z",
        "updatedAt" : "2019-08-22T07:17:11Z",
        "lastEditedBy" : "240add12-1fe5-499a-918c-053b1f46b348",
        "tags" : [
        ]
      },
      {
        "id" : "79fdf6f0-e11b-47bd-93a1-552614b2ab52",
        "parentId" : "42d58715-dd20-4587-84ec-e564c70505f8",
        "authorId" : "6943dbfe-856b-4f1b-bd04-dca0091e8291",
        "body" : "@LukaJCB It's the same as the one used in the `Parallel` instance for `NonEmptyStream`, and works the same way:\r\n\r\n```scala\r\nscala> import cats.data._\r\nimport cats.data._\r\n\r\nscala> val F = OneAnd.catsDataApplicativeForOneAnd(ZipLazyList.catsDataAlternativeForZipLazyList)\r\nF: cats.Applicative[[β$22$]cats.data.OneAnd[[A]cats.data.ZipLazyList[A],β$22$]] = cats.data.OneAndLowPriority2$$anon$8@3e84b276\r\n\r\nscala> F.pure(1).unwrap.value.take(10).toList\r\nres0: List[Int] = List(1, 1, 1, 1, 1, 1, 1, 1, 1, 1)\r\n```",
        "createdAt" : "2019-08-20T20:44:56Z",
        "updatedAt" : "2019-08-22T07:17:11Z",
        "lastEditedBy" : "6943dbfe-856b-4f1b-bd04-dca0091e8291",
        "tags" : [
        ]
      },
      {
        "id" : "fd0f6e12-95e9-4a05-bb36-0875ff44a1bd",
        "parentId" : "42d58715-dd20-4587-84ec-e564c70505f8",
        "authorId" : "6943dbfe-856b-4f1b-bd04-dca0091e8291",
        "body" : "(Which is just to say I'm pretty sure it's the right one, and its `pure` does return an infinite `OneAnd`.)",
        "createdAt" : "2019-08-20T20:53:50Z",
        "updatedAt" : "2019-08-22T07:17:11Z",
        "lastEditedBy" : "6943dbfe-856b-4f1b-bd04-dca0091e8291",
        "tags" : [
        ]
      },
      {
        "id" : "85104d4e-49e7-4bac-9902-a22aba055b2b",
        "parentId" : "42d58715-dd20-4587-84ec-e564c70505f8",
        "authorId" : "240add12-1fe5-499a-918c-053b1f46b348",
        "body" : "Ah great, sorry about that. I guess I'm a bit confused as `catsDataApplicativeForOneAnd ` looks like this: https://github.com/typelevel/cats/blob/48c8b344aaed1f796aebbfdfa610432bee641d84/core/src/main/scala/cats/data/OneAnd.scala#L234",
        "createdAt" : "2019-08-20T20:59:23Z",
        "updatedAt" : "2019-08-22T07:17:11Z",
        "lastEditedBy" : "240add12-1fe5-499a-918c-053b1f46b348",
        "tags" : [
        ]
      },
      {
        "id" : "d09d83d2-3154-423d-a93a-b3426e964181",
        "parentId" : "42d58715-dd20-4587-84ec-e564c70505f8",
        "authorId" : "6943dbfe-856b-4f1b-bd04-dca0091e8291",
        "body" : "@LukaJCB Right, the `continually`-ing happens in `unwrap`.",
        "createdAt" : "2019-08-21T06:57:30Z",
        "updatedAt" : "2019-08-22T07:17:11Z",
        "lastEditedBy" : "6943dbfe-856b-4f1b-bd04-dca0091e8291",
        "tags" : [
        ]
      }
    ],
    "commit" : "6a1c3340dc0f84cbc1e1d7fce3c4dd034aa8c957",
    "line" : 11,
    "diffHunk" : "@@ -1,1 +369,373 @@\n      def applicative: Applicative[OneAnd[ZipLazyList, *]] =\n        OneAnd.catsDataApplicativeForOneAnd(ZipLazyList.catsDataAlternativeForZipLazyList)\n      def monad: Monad[NonEmptyLazyList] = NonEmptyLazyList.catsDataInstancesForNonEmptyLazyList\n"
  },
  {
    "id" : "d1fc72d1-f606-4fb1-ac77-00e4cfee7889",
    "prId" : 2941,
    "prUrl" : "https://github.com/typelevel/cats/pull/2941#pullrequestreview-262715054",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "584821e9-3df9-4e7e-b8d0-8f5532370174",
        "parentId" : null,
        "authorId" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "body" : "I don’t understand how these are abstract on a concrete `object`. What is Type?",
        "createdAt" : "2019-07-16T16:29:02Z",
        "updatedAt" : "2019-07-16T21:28:17Z",
        "lastEditedBy" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "tags" : [
        ]
      },
      {
        "id" : "65d0dcb6-b4be-4da3-b283-558df69b60e3",
        "parentId" : "584821e9-3df9-4e7e-b8d0-8f5532370174",
        "authorId" : "6b760ef7-e448-44a7-b744-0c25c840a80a",
        "body" : "This is the newtype encoding (kind of a hack of the Scala type system) that eliminates all runtime overhead. I didn't come up with it. But it has been battle tested cats since 1.0 in NonEmtySet and NonEmptyMap, and later NonEmptyChain",
        "createdAt" : "2019-07-16T17:13:19Z",
        "updatedAt" : "2019-07-16T21:28:17Z",
        "lastEditedBy" : "6b760ef7-e448-44a7-b744-0c25c840a80a",
        "tags" : [
        ]
      },
      {
        "id" : "f41c134b-9085-49eb-aa61-1536a4c72e65",
        "parentId" : "584821e9-3df9-4e7e-b8d0-8f5532370174",
        "authorId" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "body" : "I know the trick, I just didn't know objects could have totally abstract types. Is that intended, or some quirk of the compiler?\r\n\r\nSeems to me, anything we an abstract type should have to be abstract.\r\n\r\nDo we have this documented somewhere that we can link to? I think it is not at all clear to the reader what the various parts are here and why they are all required:\r\n\r\n1. why do we need Base?\r\n2. why do we need Tag?\r\n3. why should the above be `private[data]` vs `private` or `public`?\r\n4. how is the aliasing of this type to `NonEmptyLazyList` accomplished? Is that a package alias?",
        "createdAt" : "2019-07-16T17:26:04Z",
        "updatedAt" : "2019-07-16T21:28:17Z",
        "lastEditedBy" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "tags" : [
        ]
      },
      {
        "id" : "8f786e1f-398b-4fb0-a876-ef18a8541ca6",
        "parentId" : "584821e9-3df9-4e7e-b8d0-8f5532370174",
        "authorId" : "6b760ef7-e448-44a7-b744-0c25c840a80a",
        "body" : "good point. Link added. ",
        "createdAt" : "2019-07-16T21:28:16Z",
        "updatedAt" : "2019-07-16T21:28:17Z",
        "lastEditedBy" : "6b760ef7-e448-44a7-b744-0c25c840a80a",
        "tags" : [
        ]
      },
      {
        "id" : "ef50760c-5930-4d9d-a646-e74f2ae80a4c",
        "parentId" : "584821e9-3df9-4e7e-b8d0-8f5532370174",
        "authorId" : "6b760ef7-e448-44a7-b744-0c25c840a80a",
        "body" : "also cc @LukaJCB to see if he has anything to add to the simple description and the link",
        "createdAt" : "2019-07-16T22:07:46Z",
        "updatedAt" : "2019-07-16T22:07:46Z",
        "lastEditedBy" : "6b760ef7-e448-44a7-b744-0c25c840a80a",
        "tags" : [
        ]
      }
    ],
    "commit" : "4c0febb93d7a274bc3cbe25c1551c940a2f72144",
    "line" : 19,
    "diffHunk" : "@@ -1,1 +17,21 @@  private[data] trait Tag extends Any\n  /* aliased in data package as NonEmptyLazyList */\n  type Type[+A] <: Base with Tag\n\n  private[data] def create[A](s: LazyList[A]): Type[A] ="
  }
]
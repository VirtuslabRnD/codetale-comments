[
  {
    "id" : "21f13b56-3993-40f8-a3bb-4732d3f75752",
    "prId" : 1837,
    "prUrl" : "https://github.com/typelevel/cats/pull/1837#pullrequestreview-62257223",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5f576a82-fb8e-4c14-9c6d-c48d409acc21",
        "parentId" : null,
        "authorId" : "6b760ef7-e448-44a7-b744-0c25c840a80a",
        "body" : "when I made the suggestion, I was thinking having this method on Parallel instance. I.e. \r\n```\r\ntrait Parallel[M[_], F[_]] extends Serializable {\r\n    ....\r\n   def parallelError[E](implicit ME: MonadError[M, E]):  ApplicativeError[F, E] = ...\r\n}\r\n```\r\nwhich feels a natural addition to the existing API. Your API has benefits too. What do you think? Maybe we have both API?",
        "createdAt" : "2017-09-12T19:11:38Z",
        "updatedAt" : "2017-10-19T15:46:49Z",
        "lastEditedBy" : "6b760ef7-e448-44a7-b744-0c25c840a80a",
        "tags" : [
        ]
      },
      {
        "id" : "cba0caad-2680-4588-a2d7-19c12eacba7a",
        "parentId" : "5f576a82-fb8e-4c14-9c6d-c48d409acc21",
        "authorId" : "240add12-1fe5-499a-918c-053b1f46b348",
        "body" : "I think yours is definitely more useful, but I'd be okay with having both :)",
        "createdAt" : "2017-09-12T19:15:25Z",
        "updatedAt" : "2017-10-19T15:46:49Z",
        "lastEditedBy" : "240add12-1fe5-499a-918c-053b1f46b348",
        "tags" : [
        ]
      },
      {
        "id" : "80dc4462-2912-4083-b313-a827ac8ee9a7",
        "parentId" : "5f576a82-fb8e-4c14-9c6d-c48d409acc21",
        "authorId" : "240add12-1fe5-499a-918c-053b1f46b348",
        "body" : "Done!",
        "createdAt" : "2017-09-12T20:34:59Z",
        "updatedAt" : "2017-10-19T15:46:49Z",
        "lastEditedBy" : "240add12-1fe5-499a-918c-053b1f46b348",
        "tags" : [
        ]
      }
    ],
    "commit" : "0c87a1b03b0026ad8bf04c1b45fd52b0dfb17ad5",
    "line" : 250,
    "diffHunk" : "@@ -1,1 +248,252 @@    * then you can get `ApplicativeError[F, E]` from `MonadError[M, E]`.\n    */\n  def applicativeError[M[_], F[_], E]\n  (implicit P: Parallel[M, F], E: MonadError[M, E]): ApplicativeError[F, E] = P.applicativeError\n"
  },
  {
    "id" : "b4511d55-1c17-4127-be33-1e9524a2824b",
    "prId" : 1837,
    "prUrl" : "https://github.com/typelevel/cats/pull/1837#pullrequestreview-66251863",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d88f7607-05bf-4a16-8d36-3cad1dd4ae2c",
        "parentId" : null,
        "authorId" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "body" : "I think we should override basically everything here or we could de-optimize an existing `applicative`.",
        "createdAt" : "2017-09-29T19:44:04Z",
        "updatedAt" : "2017-10-19T15:46:49Z",
        "lastEditedBy" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "tags" : [
        ]
      }
    ],
    "commit" : "0c87a1b03b0026ad8bf04c1b45fd52b0dfb17ad5",
    "line" : 69,
    "diffHunk" : "@@ -1,1 +67,71 @@    def pure[A](x: A): F[A] = applicative.pure(x)\n\n    def ap[A, B](ff: F[(A) => B])(fa: F[A]): F[B] = applicative.ap(ff)(fa)\n\n    override def map[A, B](fa: F[A])(f: (A) => B): F[B] = applicative.map(fa)(f)"
  }
]
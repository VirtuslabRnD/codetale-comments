[
  {
    "id" : "78be5f12-b2b8-4f83-a956-b4c3e36983d9",
    "prId" : 3130,
    "prUrl" : "https://github.com/typelevel/cats/pull/3130#pullrequestreview-314061635",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "100d4c4a-c2c2-465c-84c6-1911b7bb80f4",
        "parentId" : null,
        "authorId" : "6943dbfe-856b-4f1b-bd04-dca0091e8291",
        "body" : "Do we actually know that this is true? My intuition is that it generally will be, but there's also some `Either` overhead involved in the `tailRecM` implementation.",
        "createdAt" : "2019-11-08T08:47:35Z",
        "updatedAt" : "2019-11-08T08:56:45Z",
        "lastEditedBy" : "6943dbfe-856b-4f1b-bd04-dca0091e8291",
        "tags" : [
        ]
      }
    ],
    "commit" : "6f9b8cceeeada6f8dae46ed5dce402379361af1b",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +337,341 @@   * Equivalent to foldMapM.\n   * The difference is that foldMapA only requires G to be an Applicative\n   * rather than a Monad. It is also slower due to use of Eval.\n   */\n  def foldMapA[G[_], A, B](fa: F[A])(f: A => G[B])(implicit G: Applicative[G], B: Monoid[B]): G[B] ="
  },
  {
    "id" : "a71eb791-57e6-43dd-8a31-9f1d8469d956",
    "prId" : 2030,
    "prUrl" : "https://github.com/typelevel/cats/pull/2030#pullrequestreview-77824575",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "29486742-64a4-43a4-9d92-7543f139b20a",
        "parentId" : null,
        "authorId" : "2ed5d687-cc94-4d72-ba74-717be38944e9",
        "body" : "Is it worth mentioning that a more efficient implementation is often possible?  We do this on `size` and `foldM`, but I suppose it would be easy to get carried away with this.  I don't feel strongly.",
        "createdAt" : "2017-11-19T21:59:32Z",
        "updatedAt" : "2017-11-20T21:41:08Z",
        "lastEditedBy" : "2ed5d687-cc94-4d72-ba74-717be38944e9",
        "tags" : [
        ]
      },
      {
        "id" : "fc402828-1fb4-4be2-9ab6-9da050af1f40",
        "parentId" : "29486742-64a4-43a4-9d92-7543f139b20a",
        "authorId" : "2ed5d687-cc94-4d72-ba74-717be38944e9",
        "body" : "My battery is going to die before I can run the tests, but I think this might be right:\r\n\r\n```scala\r\n    foldRight(fa, Eval.now(Option.empty[B])) { (a, lb) =>\r\n      var result: Eval[Option[B]] = lb\r\n      pf.runWith(b => result = Eval.now(Some(b)))(a)\r\n      result\r\n    }.value\r\n```",
        "createdAt" : "2017-11-19T22:42:03Z",
        "updatedAt" : "2017-11-20T21:41:08Z",
        "lastEditedBy" : "2ed5d687-cc94-4d72-ba74-717be38944e9",
        "tags" : [
        ]
      },
      {
        "id" : "5e1b3ccd-a43d-4f4d-a7e5-c57038ba36c0",
        "parentId" : "29486742-64a4-43a4-9d92-7543f139b20a",
        "authorId" : "2ed5d687-cc94-4d72-ba74-717be38944e9",
        "body" : "This is the `TraversableOnce` trick in `foldRight` form.  `TraversableOnce` claims it's faster than `runWith`, but I have not benchmarked it in this context.  Tests pass even after I remove the overrides.  `sentinel` could be moved to a private member of the companion.\r\n\r\n```scala\r\n    val sentinel: Function1[A, Any] = new scala.runtime.AbstractFunction1[A, Any]{ def apply(a: A) = this }\r\n    foldRight(fa, Eval.now(Option.empty[B])) { (a, lb) =>\r\n      val x = pf.applyOrElse(a, sentinel)\r\n      if (x.asInstanceOf[AnyRef] ne sentinel) Eval.now(Some(x.asInstanceOf[B]))\r\n      else lb\r\n    }.value\r\n```",
        "createdAt" : "2017-11-20T02:01:18Z",
        "updatedAt" : "2017-11-20T21:41:08Z",
        "lastEditedBy" : "2ed5d687-cc94-4d72-ba74-717be38944e9",
        "tags" : [
        ]
      },
      {
        "id" : "db4e9cdc-6dae-48bb-8155-a4f10555771b",
        "parentId" : "29486742-64a4-43a4-9d92-7543f139b20a",
        "authorId" : "6b760ef7-e448-44a7-b744-0c25c840a80a",
        "body" : "thanks a lot @rossabaker , I made the change. ",
        "createdAt" : "2017-11-20T15:41:59Z",
        "updatedAt" : "2017-11-20T21:41:08Z",
        "lastEditedBy" : "6b760ef7-e448-44a7-b744-0c25c840a80a",
        "tags" : [
        ]
      }
    ],
    "commit" : "3d9c390e1359488b5de902db6faa83227d03cd87",
    "line" : 12,
    "diffHunk" : "@@ -1,1 +216,220 @@      }\n\n  def collectFirst[A, B](fa: F[A])(pf: PartialFunction[A, B]): Option[B] =\n    foldRight(fa, Eval.now(Option.empty[B])) { (a, lb) =>\n      // trick from TravsersableOnce"
  },
  {
    "id" : "2acd45ab-b531-45fe-8e0a-b18ec5400686",
    "prId" : 1858,
    "prUrl" : "https://github.com/typelevel/cats/pull/1858#pullrequestreview-59680751",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b7c4babe-f91c-4040-854f-e947ebd5a5db",
        "parentId" : null,
        "authorId" : "98bd6ddf-86cb-413a-a672-ee7d989ba290",
        "body" : "If we did define it in `Alternative`, we could add a consistency law checking this equality, but hey ... you can't always get what you want :smiley: \r\n ",
        "createdAt" : "2017-08-30T17:16:26Z",
        "updatedAt" : "2017-09-06T19:49:27Z",
        "lastEditedBy" : "98bd6ddf-86cb-413a-a672-ee7d989ba290",
        "tags" : [
        ]
      },
      {
        "id" : "80242bec-d0a3-4d07-9b27-6ffbd08d2150",
        "parentId" : "b7c4babe-f91c-4040-854f-e947ebd5a5db",
        "authorId" : "240add12-1fe5-499a-918c-053b1f46b348",
        "body" : "True, I don't really mind either way tbh.\r\nWe could add a test that checks if it's consistent with List#partition though 😄 ",
        "createdAt" : "2017-08-30T20:17:01Z",
        "updatedAt" : "2017-09-06T19:49:27Z",
        "lastEditedBy" : "240add12-1fe5-499a-918c-053b1f46b348",
        "tags" : [
        ]
      }
    ],
    "commit" : "e1d39b1d1efcdcfd789f43620a8db7a38c0c3ea9",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +409,413 @@  /**\n    * Separate this Foldable into a Tuple by a separating function `A => Either[B, C]`\n    * Equivalent to `Functor#map` and then `Alternative#separate`.\n    *\n    * {{{"
  },
  {
    "id" : "6c871b23-75c6-4170-94da-0673a022a767",
    "prId" : 1520,
    "prUrl" : "https://github.com/typelevel/cats/pull/1520#pullrequestreview-15522484",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ae65517a-19a9-447f-bd78-e1c217b4ae27",
        "parentId" : null,
        "authorId" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "body" : "It is not clear what we should expect if there is only 1 item in the foldable (nor is it tested). I would expect no additional item is added. I think that is what the code does but can you add a doc test example as well as a test?",
        "createdAt" : "2017-01-06T16:50:26Z",
        "updatedAt" : "2017-01-06T21:29:12Z",
        "lastEditedBy" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "tags" : [
        ]
      }
    ],
    "commit" : "d02699ea2e15edc56dacaf215abe3aebd136c35f",
    "line" : null,
    "diffHunk" : "@@ -1,1 +400,404 @@   * scala> Foldable[Vector].intercalate(Vector(1,2,3), 1)\n   * res3: Int = 8\n   * }}}\n   */\n  def intercalate[A](fa: F[A], a: A)(implicit A: Monoid[A]): A ="
  },
  {
    "id" : "57d16fdb-1b9a-427f-8b61-4007119f71b2",
    "prId" : 1414,
    "prUrl" : "https://github.com/typelevel/cats/pull/1414#pullrequestreview-5274356",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7fbc5353-d661-4b2b-98c9-89fa7231acd3",
        "parentId" : null,
        "authorId" : "6b760ef7-e448-44a7-b744-0c25c840a80a",
        "body" : "How about we also mention here in the doc the incentive of this special implementation for `Iteratable`s? \n",
        "createdAt" : "2016-10-21T15:05:21Z",
        "updatedAt" : "2016-10-21T22:24:59Z",
        "lastEditedBy" : "6b760ef7-e448-44a7-b744-0c25c840a80a",
        "tags" : [
        ]
      }
    ],
    "commit" : "6f3da09b39cf3a1521085484a3daabb60704a784",
    "line" : null,
    "diffHunk" : "@@ -1,1 +407,411 @@   * you wouldn't call this method explicitly like in the example above.\n   */\n  def iteratorFoldM[M[_], A, B](it: Iterator[A], z: B)(f: (B, A) => M[B])(implicit M: Monad[M]): M[B] = {\n    val go: B => M[Either[B, B]] = { b =>\n      if (it.hasNext) M.map(f(b, it.next))(Left(_))"
  },
  {
    "id" : "3782ebae-3341-4105-85cf-5160445cdb8b",
    "prId" : 1414,
    "prUrl" : "https://github.com/typelevel/cats/pull/1414#pullrequestreview-5307861",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "279f89e4-20ef-4d91-8fde-37f947e2cc55",
        "parentId" : null,
        "authorId" : "5fc8c7f8-34e6-46ea-986e-eb92cd93a6ce",
        "body" : "Since `Iterator` is mutable, I would keep it private to the method (otherwise we lose referential transparency). I would keep the signature as you had before, and only use `Iterator` inside.\n",
        "createdAt" : "2016-10-21T19:39:28Z",
        "updatedAt" : "2016-10-21T22:24:59Z",
        "lastEditedBy" : "5fc8c7f8-34e6-46ea-986e-eb92cd93a6ce",
        "tags" : [
        ]
      },
      {
        "id" : "fecce78e-40e3-40d7-8e6f-aa3e1db7cb8e",
        "parentId" : "279f89e4-20ef-4d91-8fde-37f947e2cc55",
        "authorId" : "5fc8c7f8-34e6-46ea-986e-eb92cd93a6ce",
        "body" : "Sorry if this was not clear from my previous comment.\n",
        "createdAt" : "2016-10-21T19:41:30Z",
        "updatedAt" : "2016-10-21T22:24:59Z",
        "lastEditedBy" : "5fc8c7f8-34e6-46ea-986e-eb92cd93a6ce",
        "tags" : [
        ]
      }
    ],
    "commit" : "6f3da09b39cf3a1521085484a3daabb60704a784",
    "line" : null,
    "diffHunk" : "@@ -1,1 +410,414 @@    val go: B => M[Either[B, B]] = { b =>\n      if (it.hasNext) M.map(f(b, it.next))(Left(_))\n      else M.pure(Right(b))\n    }\n    M.tailRecM(z)(go)"
  },
  {
    "id" : "f6bd7f14-9b10-4056-8685-921951fee3c3",
    "prId" : 1306,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "76fd7043-1fcf-43f3-a921-f9d3875681dd",
        "parentId" : null,
        "authorId" : "4aafd631-794d-4704-aeda-a6c56ce667d1",
        "body" : "For some reason `validate` was giving me \"Could not find any members to link for \"scala.util.Either\" so I went for the easy way out.\n",
        "createdAt" : "2016-08-20T22:17:10Z",
        "updatedAt" : "2016-08-20T22:17:10Z",
        "lastEditedBy" : "4aafd631-794d-4704-aeda-a6c56ce667d1",
        "tags" : [
        ]
      },
      {
        "id" : "a703bf8b-0d71-427c-a196-6d4487eda86f",
        "parentId" : "76fd7043-1fcf-43f3-a921-f9d3875681dd",
        "authorId" : "89a3e0e3-e301-4aa8-b150-74070eb5a619",
        "body" : "I totally endorse this. I may-or-may-not have made a snarky tweet about Scaladoc today related to this.\n",
        "createdAt" : "2016-08-20T22:32:14Z",
        "updatedAt" : "2016-08-20T22:32:14Z",
        "lastEditedBy" : "89a3e0e3-e301-4aa8-b150-74070eb5a619",
        "tags" : [
        ]
      }
    ],
    "commit" : "1867956e3e803ca95ed42339de4839c6ce631d4f",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +252,256 @@   * Behaves like sequence_, but uses [[Unapply]] to find the\n   * [[Applicative]] instance for `G` - used when `G` is a\n   * type constructor with two or more parameters such as `scala.util.Either`\n   *\n   * {{{"
  },
  {
    "id" : "7fa129ff-d48f-4695-be5e-77408058dee5",
    "prId" : 1167,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0758d51b-2fe1-4618-a7e4-adf65512997c",
        "parentId" : null,
        "authorId" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "body" : "what about `minOption`. Do we need such a long name?\n",
        "createdAt" : "2016-06-29T18:56:17Z",
        "updatedAt" : "2016-06-29T18:56:17Z",
        "lastEditedBy" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "tags" : [
        ]
      },
      {
        "id" : "8ddc43a0-73cd-41f4-9b03-fe23b680f964",
        "parentId" : "0758d51b-2fe1-4618-a7e4-adf65512997c",
        "authorId" : "b714495a-5740-47d4-aaaa-98f354f5c0a7",
        "body" : "This is just to be consistent with `minimum`. Is this okay considering the discussion [here](https://github.com/typelevel/cats/pull/1167#discussion_r69006590)?\n",
        "createdAt" : "2016-07-19T10:55:38Z",
        "updatedAt" : "2016-07-19T10:55:38Z",
        "lastEditedBy" : "b714495a-5740-47d4-aaaa-98f354f5c0a7",
        "tags" : [
        ]
      },
      {
        "id" : "a9e1a95b-a4e9-4d33-9b17-7dcd9fbd8e80",
        "parentId" : "0758d51b-2fe1-4618-a7e4-adf65512997c",
        "authorId" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "body" : "totally. Sorry. I'm +1 on the whole PR. My 👍 above may not have been clear about that.\n",
        "createdAt" : "2016-07-21T17:33:36Z",
        "updatedAt" : "2016-07-21T17:33:36Z",
        "lastEditedBy" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "tags" : [
        ]
      }
    ],
    "commit" : "de06e6523be1111027e76b069815fdb9e53999d6",
    "line" : 70,
    "diffHunk" : "@@ -1,1 +125,129 @@   * @see [[maximumOption]] for maximum instead of minimum.\n   */\n  def minimumOption[A](fa: F[A])(implicit A: Order[A]): Option[A] =\n    reduceLeftOption(fa)(A.min)\n"
  },
  {
    "id" : "464e4ca6-7fa4-4600-8902-4dd7e7ac6449",
    "prId" : 1114,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e98948e1-df9d-4707-9ecb-489cb7dbfc17",
        "parentId" : null,
        "authorId" : "b714495a-5740-47d4-aaaa-98f354f5c0a7",
        "body" : "👍 I think that `Long` was a good choice here. `Int` is probably the first thing that would have come to my mind, but people could conceivably be using `Foldable` for some very large structures. Though hopefully if their structure is large enough to pass the max `Int` value they have overridden `size` to a more efficient implementation :)\n",
        "createdAt" : "2016-06-11T14:20:03Z",
        "updatedAt" : "2016-06-13T22:07:08Z",
        "lastEditedBy" : "b714495a-5740-47d4-aaaa-98f354f5c0a7",
        "tags" : [
        ]
      }
    ],
    "commit" : "15a0c4d8257aa0ca0fc28b05068a8ab79804b57d",
    "line" : null,
    "diffHunk" : "@@ -1,1 +66,70 @@   * Note: will not terminate for infinite-sized collections.\n   */\n  def size[A](fa: F[A]): Long = foldMap(fa)(_ => 1)\n\n  /**"
  },
  {
    "id" : "543867d4-14fb-45cc-902c-fa06b446e4cc",
    "prId" : 533,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bffb99d2-2d47-47e7-a0e5-af08c22e2b02",
        "parentId" : null,
        "authorId" : "4aafd631-794d-4704-aeda-a6c56ce667d1",
        "body" : "Beautiful\n",
        "createdAt" : "2015-09-15T23:00:57Z",
        "updatedAt" : "2015-09-15T23:00:57Z",
        "lastEditedBy" : "4aafd631-794d-4704-aeda-a6c56ce667d1",
        "tags" : [
        ]
      }
    ],
    "commit" : "5cdeabb5c35d3626ed9511e5dc1cdcda4a4fedf2",
    "line" : 16,
    "diffHunk" : "@@ -1,1 +213,217 @@    foldRight(fa, Now(Streaming.empty[A])){ (a, ls) =>\n      Now(Streaming.cons(a, ls))\n    }.value\n}\n"
  },
  {
    "id" : "6d189569-f840-443d-a14a-1992d9bb949d",
    "prId" : 298,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "66ee7137-d850-44ed-b7e2-0ca72ace072c",
        "parentId" : null,
        "authorId" : "b714495a-5740-47d4-aaaa-98f354f5c0a7",
        "body" : "What's the reasoning/convention behind the underscores here and in `filter_`?\n",
        "createdAt" : "2015-05-20T10:44:49Z",
        "updatedAt" : "2015-05-20T13:15:21Z",
        "lastEditedBy" : "b714495a-5740-47d4-aaaa-98f354f5c0a7",
        "tags" : [
        ]
      },
      {
        "id" : "22049949-3413-4835-85ec-06bf3206565d",
        "parentId" : "66ee7137-d850-44ed-b7e2-0ca72ace072c",
        "authorId" : "89a3e0e3-e301-4aa8-b150-74070eb5a619",
        "body" : "So, I took the naming convention from other places in `Foldable`, where you have less powerful versions of _sequence_ and _traverse_ which are named _sequence__ and _traverse__ (as opposed to the methods named in `Traversable`).\n\nSimilarly, in this case we can't _filter_ or _dropWhile_ to an `F[A]` value, but only to a `List[A]` (unlike something like `MonadFilter`). So I decided to use the same convention.\n",
        "createdAt" : "2015-05-20T12:30:09Z",
        "updatedAt" : "2015-05-20T13:15:21Z",
        "lastEditedBy" : "89a3e0e3-e301-4aa8-b150-74070eb5a619",
        "tags" : [
        ]
      },
      {
        "id" : "a983c825-56cf-4ee0-a205-6607011776e3",
        "parentId" : "66ee7137-d850-44ed-b7e2-0ca72ace072c",
        "authorId" : "b714495a-5740-47d4-aaaa-98f354f5c0a7",
        "body" : "Okay, that makes sense. If I have this question, I imagine others will too. I wonder if there's a good way to document it and make it easy to discover.\n",
        "createdAt" : "2015-05-20T12:47:31Z",
        "updatedAt" : "2015-05-20T13:15:21Z",
        "lastEditedBy" : "b714495a-5740-47d4-aaaa-98f354f5c0a7",
        "tags" : [
        ]
      }
    ],
    "commit" : "d0467800edf5679f813fa76c7faef8cd8c4e58d4",
    "line" : 121,
    "diffHunk" : "@@ -1,1 +170,174 @@   * match `p`.\n   */\n  def dropWhile_[A](fa: F[A])(p: A => Boolean): List[A] =\n    foldLeft(fa, mutable.ListBuffer.empty[A]) { (buf, a) =>\n      if (buf.nonEmpty || p(a)) buf += a else buf"
  },
  {
    "id" : "7994fc9d-0c90-4dc3-8c37-b2e9a30bbf2b",
    "prId" : 150,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8b38d027-4c23-41ca-acd8-657c21a49b75",
        "parentId" : null,
        "authorId" : "841f9474-2dfc-46b8-9cfa-77b23455116a",
        "body" : "maybe we could add a comment saying why are we using `Fold`, if I understood correctly it is to implement a _stack-safe_ lazy foldRight\n",
        "createdAt" : "2015-02-09T08:18:24Z",
        "updatedAt" : "2015-02-11T02:56:23Z",
        "lastEditedBy" : "841f9474-2dfc-46b8-9cfa-77b23455116a",
        "tags" : [
        ]
      },
      {
        "id" : "c229c5ea-2ff1-4335-968f-f446e5419685",
        "parentId" : "8b38d027-4c23-41ca-acd8-657c21a49b75",
        "authorId" : "89a3e0e3-e301-4aa8-b150-74070eb5a619",
        "body" : "That's a good point. I'll add some better language there.\n",
        "createdAt" : "2015-02-09T17:01:23Z",
        "updatedAt" : "2015-02-11T02:56:23Z",
        "lastEditedBy" : "89a3e0e3-e301-4aa8-b150-74070eb5a619",
        "tags" : [
        ]
      }
    ],
    "commit" : "d8901bb058310bda84776ebddb15b79afb08e810",
    "line" : null,
    "diffHunk" : "@@ -1,1 +32,36 @@   * Right associative lazy fold on `F` using the folding function 'f'.\n   *\n   * This method evaluates `b` lazily (in some cases it will not be\n   * needed), and returns a lazy value. We are using `A => Fold[B]` to\n   * support laziness in a stack-safe way."
  }
]
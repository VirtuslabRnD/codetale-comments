[
  {
    "id" : "d4edacca-0792-4159-b1d7-659c9dfe8eb0",
    "prId" : 1621,
    "prUrl" : "https://github.com/typelevel/cats/pull/1621#pullrequestreview-35279689",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1a3f0280-7ba5-434c-9b02-5fdc2dedcaaf",
        "parentId" : null,
        "authorId" : "4aafd631-794d-4704-aeda-a6c56ce667d1",
        "body" : "One thing Edward Kmett noted in a talk he gave on [monad homomorphisms](https://youtu.be/YTaNkWjd-ac) is that `MonadTrans` provides no constraint that the resulting `MT[M, A]` has a `Monad` instance. I believe in his talk he fixes this by adding a function taking the `Monad[M]` constraint and providing a `Monad[MT[M, ?]]` constraint. In Scala it might look something like:\r\n\r\n```scala\r\nimplicit def mtMonad[M[_]: Monad]: Monad[MT[M, ?]]\r\n```\r\n\r\nWould we want something like that here?",
        "createdAt" : "2017-04-28T05:33:21Z",
        "updatedAt" : "2017-04-28T05:33:33Z",
        "lastEditedBy" : "4aafd631-794d-4704-aeda-a6c56ce667d1",
        "tags" : [
        ]
      },
      {
        "id" : "408255d1-933f-4d2a-8c94-d2fb455bed36",
        "parentId" : "1a3f0280-7ba5-434c-9b02-5fdc2dedcaaf",
        "authorId" : "156b444e-c294-46e2-a345-79380994b8e4",
        "body" : "scalaz [does it](https://github.com/scalaz/scalaz/blob/series/7.3.x/core/src/main/scala/scalaz/MonadTrans.scala#L16). Not sure if it's useful. But it makes sense in theory.",
        "createdAt" : "2017-04-28T05:43:46Z",
        "updatedAt" : "2017-04-28T05:43:46Z",
        "lastEditedBy" : "156b444e-c294-46e2-a345-79380994b8e4",
        "tags" : [
        ]
      },
      {
        "id" : "2b4c04d0-2b6d-441c-a34e-ef4b332ab525",
        "parentId" : "1a3f0280-7ba5-434c-9b02-5fdc2dedcaaf",
        "authorId" : "4aafd631-794d-4704-aeda-a6c56ce667d1",
        "body" : "This would communicate the law: For every lawful `M[_]: Monad` there exists a lawful `MT[M, ?]: Monad`",
        "createdAt" : "2017-04-28T05:45:24Z",
        "updatedAt" : "2017-04-28T05:45:24Z",
        "lastEditedBy" : "4aafd631-794d-4704-aeda-a6c56ce667d1",
        "tags" : [
        ]
      },
      {
        "id" : "bbafe744-0a61-4d1b-a7e7-6aa5780491f6",
        "parentId" : "1a3f0280-7ba5-434c-9b02-5fdc2dedcaaf",
        "authorId" : "8106957f-b999-418b-b22b-14067e9a3932",
        "body" : "Can we check such a law? Would be cool if we could rule out the na√Øve `ListT` for instance.",
        "createdAt" : "2017-04-28T05:49:39Z",
        "updatedAt" : "2017-04-28T05:49:39Z",
        "lastEditedBy" : "8106957f-b999-418b-b22b-14067e9a3932",
        "tags" : [
        ]
      },
      {
        "id" : "894ecce7-827c-4f0f-9eff-6a2c8d8819b9",
        "parentId" : "1a3f0280-7ba5-434c-9b02-5fdc2dedcaaf",
        "authorId" : "4aafd631-794d-4704-aeda-a6c56ce667d1",
        "body" : "A simple way would be to pick a fixed `M`, e.g. `Option`, get the `Monad[MT[Option, ?]]` from this method, and then law-check that.\r\n\r\nA fancier way would be to use existentials or something to be able to vary `M` and do law-checking across all these :-)\r\n\r\n**EDIT** Hmm I actually don't know what that would look like in terms of code though.",
        "createdAt" : "2017-04-28T05:52:21Z",
        "updatedAt" : "2017-04-28T05:52:54Z",
        "lastEditedBy" : "4aafd631-794d-4704-aeda-a6c56ce667d1",
        "tags" : [
        ]
      }
    ],
    "commit" : "d39d2f965665d4d9528adf7986c3ec9e54adbc21",
    "line" : 12,
    "diffHunk" : "@@ -1,1 +10,14 @@   * Lift a value of type M[A] into a monad transformer MT[M, A]\n   */\n  def liftT[M[_]: Monad, A](ma: M[A]): MT[M, A]\n}\n"
  }
]
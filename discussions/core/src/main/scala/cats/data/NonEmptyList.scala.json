[
  {
    "id" : "197f76c2-28e1-40af-b00d-c17e112b147b",
    "prId" : 3423,
    "prUrl" : "https://github.com/typelevel/cats/pull/3423#pullrequestreview-417363218",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3c8e4e56-fdbd-422d-a802-dfe5e67f8cf6",
        "parentId" : null,
        "authorId" : "6943dbfe-856b-4f1b-bd04-dca0091e8291",
        "body" : "Is there a reason this one isn't final but the one above is?",
        "createdAt" : "2020-05-24T11:18:49Z",
        "updatedAt" : "2020-05-24T11:18:50Z",
        "lastEditedBy" : "6943dbfe-856b-4f1b-bd04-dca0091e8291",
        "tags" : [
        ]
      },
      {
        "id" : "8f69262e-3895-400d-b938-47efac6ed67c",
        "parentId" : "3c8e4e56-fdbd-422d-a802-dfe5e67f8cf6",
        "authorId" : "f87cdbdd-aef9-4937-af57-08dc61ea4ddd",
        "body" : "Yes. NonEmptyList is a final class. LazyNonEmptyList is not. ",
        "createdAt" : "2020-05-24T14:22:14Z",
        "updatedAt" : "2020-05-24T14:22:14Z",
        "lastEditedBy" : "f87cdbdd-aef9-4937-af57-08dc61ea4ddd",
        "tags" : [
        ]
      }
    ],
    "commit" : "cf92734b86c6d80368450c78aa2c8b1c13f0d403",
    "line" : 17,
    "diffHunk" : "@@ -1,1 +451,455 @@   *}}}\n   */\n  def toNev[B >: A]: NonEmptyVector[B] =\n    NonEmptyVector.fromVectorUnsafe(toList.toVector)\n}"
  },
  {
    "id" : "8e7ba086-0eac-48c1-a2ee-a2b664a47b6b",
    "prId" : 1838,
    "prUrl" : "https://github.com/typelevel/cats/pull/1838#pullrequestreview-57583275",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fb6796b9-8ddf-456b-9b83-8cb2a6094dc2",
        "parentId" : null,
        "authorId" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "body" : "why can't this just be `concat`? `NonEmptyList` and `List` are different types. I'm not sure why we took this route and if there is not a good reason I'd rather change it before 1.0.",
        "createdAt" : "2017-08-21T19:07:08Z",
        "updatedAt" : "2017-10-17T19:06:53Z",
        "lastEditedBy" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "tags" : [
        ]
      }
    ],
    "commit" : "f18b06ff4de48034f0facae6156a2436ca7a9c92",
    "line" : 26,
    "diffHunk" : "@@ -1,1 +88,92 @@   * Append another NonEmptyList\n   */\n  def concatNel[AA >: A](other: NonEmptyList[AA]): NonEmptyList[AA] =\n    NonEmptyList(head, tail ::: other.toList)\n"
  },
  {
    "id" : "a227b9c7-7fb9-4c1c-9f22-ca565f677952",
    "prId" : 1628,
    "prUrl" : "https://github.com/typelevel/cats/pull/1628#pullrequestreview-34250074",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8b55cae8-7e93-4727-b0c9-5ec6f465cfe0",
        "parentId" : null,
        "authorId" : "98bd6ddf-86cb-413a-a672-ee7d989ba290",
        "body" : "Shouldn't this be `head :: Nil`?",
        "createdAt" : "2017-04-24T09:18:46Z",
        "updatedAt" : "2017-04-25T16:51:46Z",
        "lastEditedBy" : "98bd6ddf-86cb-413a-a672-ee7d989ba290",
        "tags" : [
        ]
      },
      {
        "id" : "957707cb-25ff-48bb-9472-0498913979da",
        "parentId" : "8b55cae8-7e93-4727-b0c9-5ec6f465cfe0",
        "authorId" : "af71e540-58ff-4077-a996-af18dd50f1b8",
        "body" : "If the tail is empty the last element is the head, so the result is the empty list",
        "createdAt" : "2017-04-24T09:23:26Z",
        "updatedAt" : "2017-04-25T16:51:46Z",
        "lastEditedBy" : "af71e540-58ff-4077-a996-af18dd50f1b8",
        "tags" : [
        ]
      },
      {
        "id" : "922e36d4-bc12-424e-95c4-62fcf1e96c4f",
        "parentId" : "8b55cae8-7e93-4727-b0c9-5ec6f465cfe0",
        "authorId" : "af71e540-58ff-4077-a996-af18dd50f1b8",
        "body" : "@peterneyens I added tests for `init` and `size`",
        "createdAt" : "2017-04-24T09:35:20Z",
        "updatedAt" : "2017-04-25T16:51:46Z",
        "lastEditedBy" : "af71e540-58ff-4077-a996-af18dd50f1b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "63f74f1bf95a307ce98e7faf3af08e2986c9568a",
    "line" : 38,
    "diffHunk" : "@@ -1,1 +52,56 @@   */\n  def init: List[A] = tail match {\n    case Nil => List.empty\n    case t => head :: t.init\n  }"
  },
  {
    "id" : "98307490-e604-4e95-ba9f-f6632d3fa3c2",
    "prId" : 1628,
    "prUrl" : "https://github.com/typelevel/cats/pull/1628#pullrequestreview-34968837",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9c0b6224-543d-4e3b-a57b-aaaeb7f24dc7",
        "parentId" : null,
        "authorId" : "6b760ef7-e448-44a7-b744-0c25c840a80a",
        "body" : "`tail.lastOption.getOrElse(head)` might be more performant. ",
        "createdAt" : "2017-04-24T12:55:31Z",
        "updatedAt" : "2017-04-25T16:51:46Z",
        "lastEditedBy" : "6b760ef7-e448-44a7-b744-0c25c840a80a",
        "tags" : [
        ]
      },
      {
        "id" : "f7494205-773d-4b65-9a50-1e14575b7793",
        "parentId" : "9c0b6224-543d-4e3b-a57b-aaaeb7f24dc7",
        "authorId" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "body" : "he got the exact opposite advice from me a few days ago. Why do you say this? My understanding is that case class matching is very efficient and this also avoids the closure allocation (since getOrElse is by-name).",
        "createdAt" : "2017-04-26T16:24:46Z",
        "updatedAt" : "2017-04-26T16:24:46Z",
        "lastEditedBy" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "tags" : [
        ]
      },
      {
        "id" : "835a4949-02e2-45b0-baec-eeed740d93c0",
        "parentId" : "9c0b6224-543d-4e3b-a57b-aaaeb7f24dc7",
        "authorId" : "6b760ef7-e448-44a7-b744-0c25c840a80a",
        "body" : "@johnynek yeah, I forgot that `getOrElse` is by-name, and corrected myself in the other comment https://github.com/typelevel/cats/pull/1628#discussion_r113015121",
        "createdAt" : "2017-04-26T21:32:15Z",
        "updatedAt" : "2017-04-26T21:32:21Z",
        "lastEditedBy" : "6b760ef7-e448-44a7-b744-0c25c840a80a",
        "tags" : [
        ]
      }
    ],
    "commit" : "63f74f1bf95a307ce98e7faf3af08e2986c9568a",
    "line" : 24,
    "diffHunk" : "@@ -1,1 +38,42 @@  def last: A = tail.lastOption match {\n    case None    => head\n    case Some(a) => a\n  }\n"
  },
  {
    "id" : "3b464d88-d689-4c28-9b53-1031071a1312",
    "prId" : 1628,
    "prUrl" : "https://github.com/typelevel/cats/pull/1628#pullrequestreview-34768147",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b1d47aff-a854-4d2d-bef0-1ca1d0e2b8dd",
        "parentId" : null,
        "authorId" : "af71e540-58ff-4077-a996-af18dd50f1b8",
        "body" : "@kailuowang any preference regarding `init` performance? `toList.init` is also an alternative",
        "createdAt" : "2017-04-24T16:33:11Z",
        "updatedAt" : "2017-04-25T16:51:46Z",
        "lastEditedBy" : "af71e540-58ff-4077-a996-af18dd50f1b8",
        "tags" : [
        ]
      },
      {
        "id" : "8e226a5d-e428-4919-b251-bc1f31038720",
        "parentId" : "b1d47aff-a854-4d2d-bef0-1ca1d0e2b8dd",
        "authorId" : "6b760ef7-e448-44a7-b744-0c25c840a80a",
        "body" : "I am going to stop pretend that I know anything about performance. I don't know if much difference can be made here. ",
        "createdAt" : "2017-04-24T17:59:50Z",
        "updatedAt" : "2017-04-25T16:51:46Z",
        "lastEditedBy" : "6b760ef7-e448-44a7-b744-0c25c840a80a",
        "tags" : [
        ]
      },
      {
        "id" : "f502bf2b-6aa9-4e03-b9f1-f6245edb47c5",
        "parentId" : "b1d47aff-a854-4d2d-bef0-1ca1d0e2b8dd",
        "authorId" : "b084ae12-948e-41db-b85f-097bb81e5826",
        "body" : "It (should) be more performant this way I think, because there's one less branch. But only very slightly.",
        "createdAt" : "2017-04-26T07:53:07Z",
        "updatedAt" : "2017-04-26T07:53:07Z",
        "lastEditedBy" : "b084ae12-948e-41db-b85f-097bb81e5826",
        "tags" : [
        ]
      }
    ],
    "commit" : "63f74f1bf95a307ce98e7faf3af08e2986c9568a",
    "line" : 37,
    "diffHunk" : "@@ -1,1 +51,55 @@   * }}}\n   */\n  def init: List[A] = tail match {\n    case Nil => List.empty\n    case t => head :: t.init"
  },
  {
    "id" : "a5b47220-3e22-4ff0-b84c-05046cbc0e13",
    "prId" : 1243,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "57f73d0e-baf9-43bf-85be-d503390f3148",
        "parentId" : null,
        "authorId" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "body" : "only question: there is an `O(N^2)` algorithm that uses only `Eq[A]` I wonder is it makes sense to also implement that?\n\nwe could use something like: https://github.com/non/algebra/blob/master/core/src/main/scala/algebra/Priority.scala\n\n(or we could use `Xor` for that) and have something like:\n\n``` scala\ndef distinct(implicit oe: Xor[Eq[A], Order[A]]): NonEmptyList[A] = oe match {\n  case Xor.Right(ord) => // do the tree set which is `O(log N)` per check\n  case Xor.Left(eq) => // do a \"listset\" approach of checking each item, this incurs `O(N)` per check\n}\n```\n\nIf we had a `Hash[A]` type that potentially extended `Eq[A]` we could even have something like:\n\n``` scala\ndef distinct(implicit oe: Xor[Eq[A], Xor[Order[A], Hash[A]]]): NonEmptyList[A]\n```\n\nwhich would prefer to use hash sets, then tree sets, then list sets.\n\nThis is perhaps best served with different method names so readers can be more clear which complexity they get, but it is interesting that the semantics of the method don't care.\n",
        "createdAt" : "2016-07-29T18:00:19Z",
        "updatedAt" : "2016-08-12T17:28:26Z",
        "lastEditedBy" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "tags" : [
        ]
      },
      {
        "id" : "465dfb17-6f95-4e3a-bc5e-16ac3a2ad4f5",
        "parentId" : "57f73d0e-baf9-43bf-85be-d503390f3148",
        "authorId" : "279973d3-77e2-4dc0-b607-6dff65e4bc2c",
        "body" : "Is `Priority` recursive, i.e. can support > 2 implicits? Regarding hash sets and `Hash` typeclass, since hash sets implementations in Scala are based on `Object.hashcode()` it would require some wrapping of the elements, wouldn't it?\n",
        "createdAt" : "2016-07-30T05:20:55Z",
        "updatedAt" : "2016-08-12T17:28:26Z",
        "lastEditedBy" : "279973d3-77e2-4dc0-b607-6dff65e4bc2c",
        "tags" : [
        ]
      },
      {
        "id" : "70a7a074-78c2-450b-8850-a83d4085cb6f",
        "parentId" : "57f73d0e-baf9-43bf-85be-d503390f3148",
        "authorId" : "b714495a-5740-47d4-aaaa-98f354f5c0a7",
        "body" : "> This is perhaps best served with different method names so readers can be more clear which complexity they get\n\nI strongly agree with this statement. Especially since IntelliJ has a nasty habit of telling people that imports are unused when they are only used to bring in implicit instances. It would be really unfortunate if deleting an import brought the `Hash` or `Order` instance out of scope and some code went from `O(n)` to `O(n^2)`.\n\nI don't feel a strong need to add an `O(n^2)` version that requires `Eq[A]` instead of `Order[A]`, because `O(n^2)` operations are often impractical, and I suspect that most of the cases in which you want to do something like this you probably can have an `Order[A]` available. I could definitely see some value in a hash-based approach, but that's a higher barrier given what's currently in Cats.\n\nPersonally I'm pretty happy to go forward with this approach and leave open the possibility of another approach in the future.\n",
        "createdAt" : "2016-07-30T10:59:34Z",
        "updatedAt" : "2016-08-12T17:28:26Z",
        "lastEditedBy" : "b714495a-5740-47d4-aaaa-98f354f5c0a7",
        "tags" : [
        ]
      }
    ],
    "commit" : "5f2483f4d80e81728ebcb71a260e8ed5c094c0b3",
    "line" : 16,
    "diffHunk" : "@@ -1,1 +112,116 @@   * Remove duplicates. Duplicates are checked using `Order[_]` instance.\n   */\n  def distinct(implicit O: Order[A]): NonEmptyList[A] = {\n    implicit val ord = O.toOrdering\n"
  },
  {
    "id" : "8d8aebc3-6c5c-4489-9ad4-1ebd54b078db",
    "prId" : 1231,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2696bea9-8c37-4c8f-8b5c-33115899fc0e",
        "parentId" : null,
        "authorId" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "body" : "what if we did something similar to `NonEmptyVector` and made this a value class around `::[A]`? Then we would not need to allocate in some cases.\n",
        "createdAt" : "2016-07-25T20:46:50Z",
        "updatedAt" : "2016-07-27T00:18:40Z",
        "lastEditedBy" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "tags" : [
        ]
      }
    ],
    "commit" : "cfdd085189defe565a1fd3690795326634eae7cb",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +12,16 @@ * single element (head) and optional structure (tail).\n */\nfinal case class NonEmptyList[A](head: A, tail: List[A]) {\n\n  /**"
  },
  {
    "id" : "4620fc00-1406-414e-bcc2-7f349bad5772",
    "prId" : 1231,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a1301851-caef-4651-9125-062b9a80170c",
        "parentId" : null,
        "authorId" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "body" : "if we did the `::[A]` trick, this would require a cast. Maybe the real class is the way to go.\n",
        "createdAt" : "2016-07-25T20:47:36Z",
        "updatedAt" : "2016-07-27T00:18:40Z",
        "lastEditedBy" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "tags" : [
        ]
      },
      {
        "id" : "2876b7c0-a50d-4244-a01f-23288527e3df",
        "parentId" : "a1301851-caef-4651-9125-062b9a80170c",
        "authorId" : "b714495a-5740-47d4-aaaa-98f354f5c0a7",
        "body" : "One thing that we could do would be to define it as a `sealed abstract class` so we have some flexibility in changing it in the future. However, we still wouldn't be able to change it into a value class without breaking binary compatibility.\n",
        "createdAt" : "2016-07-26T10:49:11Z",
        "updatedAt" : "2016-07-27T00:18:40Z",
        "lastEditedBy" : "b714495a-5740-47d4-aaaa-98f354f5c0a7",
        "tags" : [
        ]
      }
    ],
    "commit" : "cfdd085189defe565a1fd3690795326634eae7cb",
    "line" : 24,
    "diffHunk" : "@@ -1,1 +22,26 @@   *  Applies f to all the elements of the structure\n   */\n  def map[B](f: A => B): NonEmptyList[B] =\n    NonEmptyList(f(head), tail.map(f))\n"
  },
  {
    "id" : "707eacd4-aaff-46c6-901f-971453b9fad5",
    "prId" : 1231,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d5d7f066-7581-43e6-9150-7cd30f7e8e74",
        "parentId" : null,
        "authorId" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "body" : "what about\n\n``` scala\nl match {\n  case Nil => throw new IllegalArgumentException(\"Cannot create NonEmptyList from empty list\")\n  case h :: t => NonEmptyList(h, t)\n}\n```\n",
        "createdAt" : "2016-07-25T20:51:43Z",
        "updatedAt" : "2016-07-27T00:18:40Z",
        "lastEditedBy" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "tags" : [
        ]
      }
    ],
    "commit" : "cfdd085189defe565a1fd3690795326634eae7cb",
    "line" : null,
    "diffHunk" : "@@ -1,1 +134,138 @@   * is empty.\n   */\n  def fromListUnsafe[A](l: List[A]): NonEmptyList[A] =\n    l match {\n      case Nil => throw new IllegalArgumentException(\"Cannot create NonEmptyList from empty list\")"
  },
  {
    "id" : "f011919c-2476-4597-9e65-352a8c196694",
    "prId" : 1231,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d9fe9e73-70dd-4fd6-b950-b745a2259d82",
        "parentId" : null,
        "authorId" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "body" : "what about:\n\n``` scala\nif (p(head)) Some(head)\nelse tail.find(p)\n```\n",
        "createdAt" : "2016-07-25T21:02:52Z",
        "updatedAt" : "2016-07-27T00:18:40Z",
        "lastEditedBy" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "tags" : [
        ]
      }
    ],
    "commit" : "cfdd085189defe565a1fd3690795326634eae7cb",
    "line" : 53,
    "diffHunk" : "@@ -1,1 +51,55 @@   * Find the first element matching the predicate, if one exists\n   */\n  def find(p: A => Boolean): Option[A] =\n    if (p(head)) Some(head)\n    else tail.find(p)"
  }
]
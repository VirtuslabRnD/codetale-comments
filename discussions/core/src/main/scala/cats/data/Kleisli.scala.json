[
  {
    "id" : "ae9b2e6d-1f34-478c-9742-684c24d02a20",
    "prId" : 2722,
    "prUrl" : "https://github.com/typelevel/cats/pull/2722#pullrequestreview-199869583",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "62015c3b-c870-42ed-ac1b-f5f32c576db1",
        "parentId" : null,
        "authorId" : "b714495a-5740-47d4-aaaa-98f354f5c0a7",
        "body" : "This comment is true, but I think that it could be more illustrative. In my mind, `ask` is to `Kleisli` as `identity` is to `Function1`. I think that it would be helpful to point out that in the resulting `Kleisli`, the output `A` is the same as the input `A` (the actual value not just the type). A code example might help get this point across.",
        "createdAt" : "2019-02-04T17:31:29Z",
        "updatedAt" : "2019-02-05T07:24:51Z",
        "lastEditedBy" : "b714495a-5740-47d4-aaaa-98f354f5c0a7",
        "tags" : [
        ]
      },
      {
        "id" : "b07972bd-bf03-4111-beb7-397c00131d6c",
        "parentId" : "62015c3b-c870-42ed-ac1b-f5f32c576db1",
        "authorId" : "2b134052-7dd4-4664-8a0b-7200f55535fa",
        "body" : "Just updated and added an example to `ask`",
        "createdAt" : "2019-02-05T00:10:03Z",
        "updatedAt" : "2019-02-05T07:24:51Z",
        "lastEditedBy" : "2b134052-7dd4-4664-8a0b-7200f55535fa",
        "tags" : [
        ]
      }
    ],
    "commit" : "b22a1a4ab2510a25fefa88af761ed5afa815ffaf",
    "line" : 103,
    "diffHunk" : "@@ -1,1 +230,234 @@   * res0: Option[Int]: Some(1)\n   * }}}\n   */\n  def ask[F[_], A](implicit F: Applicative[F]): Kleisli[F, A, A] =\n    Kleisli(F.pure)"
  },
  {
    "id" : "9da73117-fb5a-48a2-bd25-b843d0d84632",
    "prId" : 1766,
    "prUrl" : "https://github.com/typelevel/cats/pull/1766#pullrequestreview-50084083",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "139b7d73-60e4-4133-a00c-3f64522037ad",
        "parentId" : null,
        "authorId" : "b084ae12-948e-41db-b85f-097bb81e5826",
        "body" : "`Kleisli[F, A, B]` is seemingly a commutative monad now too, given `F[_]: CommutativeMonad`. `ReaderT` has no added effects, so I think this has to be the case.",
        "createdAt" : "2017-07-14T16:01:04Z",
        "updatedAt" : "2017-07-19T16:07:07Z",
        "lastEditedBy" : "b084ae12-948e-41db-b85f-097bb81e5826",
        "tags" : [
        ]
      }
    ],
    "commit" : "f34c6e512e51298c0d704f49c6feeefb607efced",
    "line" : 37,
    "diffHunk" : "@@ -1,1 +104,108 @@    catsDataCommutativeArrowForKleisli[Id]\n\n  implicit def catsDataMonadReaderForKleisliId[A]: MonadReader[Kleisli[Id, A, ?], A] =\n    catsDataMonadReaderForKleisli[Id, A]\n"
  },
  {
    "id" : "50276445-1eb8-4441-a30b-ad45d0eba475",
    "prId" : 1543,
    "prUrl" : "https://github.com/typelevel/cats/pull/1543#pullrequestreview-24715179",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "38398b61-ccd5-4a8f-95cc-b8290a01b73b",
        "parentId" : null,
        "authorId" : "98bd6ddf-86cb-413a-a672-ee7d989ba290",
        "body" : "Like this we have the same code twice:\r\n\r\n- here in `KleisliFlatMap`\r\n- and in `catsDataMonadReaderForKleisli`\r\n\r\nMaybe we could create a `KleisliMonad` which can be extended by a `KleisliMonadReader` and a `KleisliMonadError` (similar as how it is done in `StateT`) ?",
        "createdAt" : "2017-03-02T12:11:32Z",
        "updatedAt" : "2017-03-05T15:29:09Z",
        "lastEditedBy" : "98bd6ddf-86cb-413a-a672-ee7d989ba290",
        "tags" : [
        ]
      }
    ],
    "commit" : "cf7d5c17eb817ddd68b4ef73dc27fa9bece8b58c",
    "line" : 132,
    "diffHunk" : "@@ -1,1 +299,303 @@  def tailRecM[B, C](b: B)(f: B => Kleisli[F, A, Either[B, C]]): Kleisli[F, A, C] =\n    Kleisli[F, A, C]({ a => FlatMap[F].tailRecM(b) { f(_).run(a) } })\n}\n\nprivate trait KleisliApplicative[F[_], A] extends Applicative[Kleisli[F, A, ?]] {"
  }
]
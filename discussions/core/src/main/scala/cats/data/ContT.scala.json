[
  {
    "id" : "ea31cc5c-e0f1-44b4-a280-5f63fe9f318a",
    "prId" : 3748,
    "prUrl" : "https://github.com/typelevel/cats/pull/3748#pullrequestreview-582937029",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "57d33140-0c69-49ba-81f2-8e6be031ad2a",
        "parentId" : null,
        "authorId" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "body" : "putting this inside a `Defer` seems more likely to be needed...\r\n\r\nCan we add a stack-safety test here in some way?",
        "createdAt" : "2021-01-28T22:06:42Z",
        "updatedAt" : "2021-02-04T09:30:52Z",
        "lastEditedBy" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "tags" : [
        ]
      },
      {
        "id" : "ca195fbc-2441-4fd6-a4e4-a9dd9adb8340",
        "parentId" : "57d33140-0c69-49ba-81f2-8e6be031ad2a",
        "authorId" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "body" : "I don't see why `Monad` is needed here. It seems to me that only `Applicative` should be since I think `apply` requires nothing and `eval` just requires Applicative and Defer.",
        "createdAt" : "2021-02-04T00:33:13Z",
        "updatedAt" : "2021-02-04T09:30:52Z",
        "lastEditedBy" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "tags" : [
        ]
      }
    ],
    "commit" : "45acf6b1b814746b94505cc3186fdf5e09b921ab",
    "line" : 72,
    "diffHunk" : "@@ -1,1 +241,245 @@   */\n  def shiftT[M[_]: Applicative: Defer, A, B](f: (B => M[A]) => ContT[M, A, A]): ContT[M, A, B] =\n    apply(cb => f(cb).eval)\n\n  def tailRecM[M[_], A, B, C](a: A)(fn: A => ContT[M, C, Either[A, B]])(implicit M: Defer[M]): ContT[M, C, B] ="
  },
  {
    "id" : "9891615e-ad8e-45d3-86e3-60d9550d64f6",
    "prId" : 3748,
    "prUrl" : "https://github.com/typelevel/cats/pull/3748#pullrequestreview-582332485",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b33dac9e-fb2d-4df5-9914-d819689786e5",
        "parentId" : null,
        "authorId" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "body" : "can you add what this is supposed to do? It you don't understand shift and reset (and I am foggy on it), I don't think this comment helps you.",
        "createdAt" : "2021-02-02T19:07:25Z",
        "updatedAt" : "2021-02-04T09:30:52Z",
        "lastEditedBy" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "tags" : [
        ]
      },
      {
        "id" : "4ca6cf41-994d-4425-bd3e-b9a12aa638f8",
        "parentId" : "b33dac9e-fb2d-4df5-9914-d819689786e5",
        "authorId" : "0305d3a6-be70-4124-b2db-e5f54937820d",
        "body" : "Yup üëç ",
        "createdAt" : "2021-02-03T12:55:57Z",
        "updatedAt" : "2021-02-04T09:30:52Z",
        "lastEditedBy" : "0305d3a6-be70-4124-b2db-e5f54937820d",
        "tags" : [
        ]
      }
    ],
    "commit" : "45acf6b1b814746b94505cc3186fdf5e09b921ab",
    "line" : 65,
    "diffHunk" : "@@ -1,1 +234,238 @@   *     _ <- ContT.liftF(IO.println(\"5\"))\n   *   } yield ()\n   * }}}\n   *\n   * The continuation captured by k is {{{ >> ContT.liftF(IO.println(\"3\")) }}}"
  },
  {
    "id" : "a067d0c2-ff38-41d2-a6b2-eea473e04ec3",
    "prId" : 3747,
    "prUrl" : "https://github.com/typelevel/cats/pull/3747#pullrequestreview-577746794",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a7a891ab-31e7-4277-94a7-93bd3b262844",
        "parentId" : null,
        "authorId" : "0d2d63af-42da-46db-94c5-685de5c1494b",
        "body" : "Use brackets instead of parentheses to make it cleaner looking?",
        "createdAt" : "2021-01-27T20:51:14Z",
        "updatedAt" : "2021-02-01T09:52:08Z",
        "lastEditedBy" : "0d2d63af-42da-46db-94c5-685de5c1494b",
        "tags" : [
        ]
      }
    ],
    "commit" : "f07d03137f2b17baaa55ff4644d2976d68bdabe1",
    "line" : 23,
    "diffHunk" : "@@ -1,1 +116,120 @@   * {{{\n   *   for {\n   *     _ <- ContT.callCC( (k: Unit => ContT[IO, Unit, Unit]) =>\n   *       ContT.liftF(IO.println(\"this will print first\")) >>\n   *         k(()) >>"
  },
  {
    "id" : "ea8a3b2d-13af-49ad-95d1-1da22236757a",
    "prId" : 3274,
    "prUrl" : "https://github.com/typelevel/cats/pull/3274#pullrequestreview-349389354",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c1316c02-aa62-455c-be43-a1cf96225256",
        "parentId" : null,
        "authorId" : "6b760ef7-e448-44a7-b744-0c25c840a80a",
        "body" : "How about we add a doc test here as well? ",
        "createdAt" : "2020-01-28T13:54:23Z",
        "updatedAt" : "2020-01-29T11:03:21Z",
        "lastEditedBy" : "6b760ef7-e448-44a7-b744-0c25c840a80a",
        "tags" : [
        ]
      }
    ],
    "commit" : "76bb6418cad82102cafe037fcd36056bb3082f36",
    "line" : 30,
    "diffHunk" : "@@ -1,1 +98,102 @@   * res0: Either[String, Int] = Right(1)\n   * }}}\n   */\n  def liftK[M[_], B](implicit M: FlatMap[M]): M ~> ContT[M, B, *] =\n    Œª[M ~> ContT[M, B, *]](ContT.liftF(_))"
  },
  {
    "id" : "286c0576-7ba8-4c18-9c44-1d6ea994690f",
    "prId" : 2506,
    "prUrl" : "https://github.com/typelevel/cats/pull/2506#pullrequestreview-156173743",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c723bad4-4986-4c4d-a7d6-2873f150b2ea",
        "parentId" : null,
        "authorId" : "9e8a6a6c-6f4e-49b4-ab87-ee2c5ced7e78",
        "body" : "I stand very much corrected here. **I'm convinced that this *is* stack-safe.** I owe you an apology, @johnynek. Dear internets, please link here if you're looking for a handy example of me being wrong.\r\n\r\nWhen I first reviewed this PR on my phone, it looked like a slightly different version of the trick you used in #1400, but this is considerably better. You're basically inheriting the stack-safety of the underlying monad by explicitly hitting a stack-safe join at this point and returning to its trampoline (which it must have due to `Defer`). I'm not sure you even need the `AndThen`, since the stack is cut by the `defer`.",
        "createdAt" : "2018-09-18T00:23:06Z",
        "updatedAt" : "2018-09-18T01:09:00Z",
        "lastEditedBy" : "9e8a6a6c-6f4e-49b4-ab87-ee2c5ced7e78",
        "tags" : [
        ]
      },
      {
        "id" : "acd22459-40b5-40dc-a78f-00618f778a70",
        "parentId" : "c723bad4-4986-4c4d-a7d6-2873f150b2ea",
        "authorId" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "body" : "We all make mistakes here and there. I very much admire folks who feel no shame about it. Kudos to you.",
        "createdAt" : "2018-09-18T01:07:43Z",
        "updatedAt" : "2018-09-18T01:09:00Z",
        "lastEditedBy" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "tags" : [
        ]
      }
    ],
    "commit" : "ed1cebc4e10b11eae45508d39078c0c3eb9f2c22",
    "line" : 45,
    "diffHunk" : "@@ -1,1 +43,47 @@      val contRun: ContT[M, A, C] => M[A] = (_.run(fn2))\n      val fn3: B => M[A] = fnAndThen.andThen(contRun)\n      M.defer(run(fn3))\n    }\n  }"
  },
  {
    "id" : "6c569521-f422-4b4f-8db3-e894bfab587a",
    "prId" : 2506,
    "prUrl" : "https://github.com/typelevel/cats/pull/2506#pullrequestreview-156167041",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "df25d250-72c0-451d-90bc-0efd70bcd420",
        "parentId" : null,
        "authorId" : "9e8a6a6c-6f4e-49b4-ab87-ee2c5ced7e78",
        "body" : "Can just delegate to `flatMap` now. Probably slightly slower than this though.",
        "createdAt" : "2018-09-18T00:23:24Z",
        "updatedAt" : "2018-09-18T01:09:00Z",
        "lastEditedBy" : "9e8a6a6c-6f4e-49b4-ab87-ee2c5ced7e78",
        "tags" : [
        ]
      }
    ],
    "commit" : "ed1cebc4e10b11eae45508d39078c0c3eb9f2c22",
    "line" : 77,
    "diffHunk" : "@@ -1,1 +75,79 @@    DeferCont(() => FromFn(AndThen(fn)))\n\n  def tailRecM[M[_], A, B, C](a: A)(fn: A => ContT[M, C, Either[A, B]])(implicit M: Defer[M]): ContT[M, C, B] =\n    ContT[M, C, B] { cb: (B => M[C]) =>\n"
  },
  {
    "id" : "c07863ce-efda-4fa0-811f-6fa64b12f471",
    "prId" : 2506,
    "prUrl" : "https://github.com/typelevel/cats/pull/2506#pullrequestreview-156167041",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4a94f8a8-5569-477b-83b9-b31fd587d0fb",
        "parentId" : null,
        "authorId" : "9e8a6a6c-6f4e-49b4-ab87-ee2c5ced7e78",
        "body" : "Random thought‚Ä¶\r\n\r\nWhat if we implicitly prioritize a bit here? `ContT` is still useful with very short bind chains even when the underlying monad is not `Defer`, it just wouldn't be stack-safe. So make the higher priority `Monad` instance a `Monad with Defer` and require the `Defer[M]` constraint. Provide a lower priority instance which doesn't require or provide the `Defer[M]` (and thus also has a stack-unsafe `tailRecM`). Obviously this means removing the `flatMap` and `map` implementations from the `ContT` class itself and only making them visible via implicit enrichment (if the imports are a problem for usability, we can `with MonadSyntax` on the companion object).\r\n\r\nThe advantage would be a more broadly applicable `ContT` (admittedly, I'm not sure how much people care about continuations on the JVM outside of async effects, so‚Ä¶ maybe not a big advantage?) which transparently preserves stack-safety whenever possible, and gracefully degrades whenever not. Maybe this is taking the \"`tailRecM` doesn't really need to be stack-safe to be lawful\" idea too far though.",
        "createdAt" : "2018-09-18T00:27:25Z",
        "updatedAt" : "2018-09-18T01:09:00Z",
        "lastEditedBy" : "9e8a6a6c-6f4e-49b4-ab87-ee2c5ced7e78",
        "tags" : [
        ]
      }
    ],
    "commit" : "ed1cebc4e10b11eae45508d39078c0c3eb9f2c22",
    "line" : 95,
    "diffHunk" : "@@ -1,1 +93,97 @@    }\n\n  implicit def catsDataContTMonad[M[_]: Defer, A]: Monad[ContT[M, A, ?]] =\n    new Monad[ContT[M, A, ?]] {\n      def pure[B](b: B): ContT[M, A, B] ="
  },
  {
    "id" : "d3d4f1f6-7a53-42da-a7c1-d5289f654520",
    "prId" : 2506,
    "prUrl" : "https://github.com/typelevel/cats/pull/2506#pullrequestreview-156167041",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5c69e016-f88f-42c0-9791-4a3754fbe50a",
        "parentId" : null,
        "authorId" : "9e8a6a6c-6f4e-49b4-ab87-ee2c5ced7e78",
        "body" : "You can just make `ContT` take `runAndThen` as a parameter to get the same benefit without the subtype limit. :-) A more impactful micro-optimization would be to make the implementations within `ContT` marked as `final`, since then it won't matter how many subtypes you have.",
        "createdAt" : "2018-09-18T00:28:39Z",
        "updatedAt" : "2018-09-18T01:09:00Z",
        "lastEditedBy" : "9e8a6a6c-6f4e-49b4-ab87-ee2c5ced7e78",
        "tags" : [
        ]
      }
    ],
    "commit" : "ed1cebc4e10b11eae45508d39078c0c3eb9f2c22",
    "line" : 53,
    "diffHunk" : "@@ -1,1 +51,55 @@\n  // Note, we only have two instances of ContT in order to be gentle on the JVM JIT\n  // which treats classes with more than two subclasses differently\n\n  private case class FromFn[M[_], A, B](runAndThen: AndThen[B => M[A], M[A]]) extends ContT[M, A, B]"
  },
  {
    "id" : "aebd88f7-7518-4cd0-b13c-caf0f97c91a7",
    "prId" : 2506,
    "prUrl" : "https://github.com/typelevel/cats/pull/2506#pullrequestreview-156182812",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ddc2a946-4523-4eb4-b2b6-5b6e60153230",
        "parentId" : null,
        "authorId" : "9e8a6a6c-6f4e-49b4-ab87-ee2c5ced7e78",
        "body" : "I'd also like to see an `applyPure` or something like that defined as:\r\n\r\n```scala\r\ndef applyPure[M[_]: Applicative, A, B](fn: (B => A) => A): ContT[M, A, B] =\r\n  apply[M, A, B](_(fn.andThen(_.pure)).pure)\r\n```\r\n\r\nOr thereabouts‚Ä¶",
        "createdAt" : "2018-09-18T00:31:04Z",
        "updatedAt" : "2018-09-18T01:09:00Z",
        "lastEditedBy" : "9e8a6a6c-6f4e-49b4-ab87-ee2c5ced7e78",
        "tags" : [
        ]
      },
      {
        "id" : "dbd9373d-5cc7-423e-905d-30cd6e97b35f",
        "parentId" : "ddc2a946-4523-4eb4-b2b6-5b6e60153230",
        "authorId" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "body" : "actually, I don't think we can do that I think we need Applicative and Comonad (we need to go `B => M[A]` to `B => A` to call `fn`.",
        "createdAt" : "2018-09-18T01:05:25Z",
        "updatedAt" : "2018-09-18T01:09:00Z",
        "lastEditedBy" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "tags" : [
        ]
      },
      {
        "id" : "7afca0f9-28c0-4209-b4e6-a965d10e0d81",
        "parentId" : "ddc2a946-4523-4eb4-b2b6-5b6e60153230",
        "authorId" : "9e8a6a6c-6f4e-49b4-ab87-ee2c5ced7e78",
        "body" : "Oh I see what you mean. That's definitely unfortunate. I'm not sure the function would be useful at all requiring `Comonad`",
        "createdAt" : "2018-09-18T02:11:09Z",
        "updatedAt" : "2018-09-18T02:11:10Z",
        "lastEditedBy" : "9e8a6a6c-6f4e-49b4-ab87-ee2c5ced7e78",
        "tags" : [
        ]
      }
    ],
    "commit" : "ed1cebc4e10b11eae45508d39078c0c3eb9f2c22",
    "line" : 72,
    "diffHunk" : "@@ -1,1 +70,74 @@\n  def apply[M[_], A, B](fn: (B => M[A]) => M[A]): ContT[M, A, B] =\n    FromFn(AndThen(fn))\n\n  def later[M[_], A, B](fn: => (B => M[A]) => M[A]): ContT[M, A, B] ="
  }
]
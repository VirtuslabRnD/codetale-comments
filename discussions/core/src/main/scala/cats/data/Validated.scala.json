[
  {
    "id" : "533a42c1-cbdd-43db-aa37-e313fc3cfadd",
    "prId" : 2431,
    "prUrl" : "https://github.com/typelevel/cats/pull/2431#pullrequestreview-151491227",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "885818b0-e6ca-497f-bf7f-f9e2c3445169",
        "parentId" : null,
        "authorId" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "body" : "validated is already covariant. What about `ValidatedNec[Nothing, B]` here?",
        "createdAt" : "2018-08-20T18:33:05Z",
        "updatedAt" : "2018-08-21T08:26:19Z",
        "lastEditedBy" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "tags" : [
        ]
      },
      {
        "id" : "e142d312-b17e-42b2-9870-3845de721794",
        "parentId" : "885818b0-e6ca-497f-bf7f-f9e2c3445169",
        "authorId" : "240add12-1fe5-499a-918c-053b1f46b348",
        "body" : "Now that I think about it returning `ValidatedNec[Nothing, B]` is the same as `Validated[Nothing, B]` correct? So this constructor makes more sense if you want a fully typed `Validated`, if you want `Nothing` you can use `Validated.Valid`",
        "createdAt" : "2018-08-21T09:25:15Z",
        "updatedAt" : "2018-08-21T09:25:15Z",
        "lastEditedBy" : "240add12-1fe5-499a-918c-053b1f46b348",
        "tags" : [
        ]
      },
      {
        "id" : "43414be8-e6ef-4f00-9699-0c18795dbcd2",
        "parentId" : "885818b0-e6ca-497f-bf7f-f9e2c3445169",
        "authorId" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "body" : "So, why do we need it? In cases where type inference falls down? e.g. in folds the initial value?",
        "createdAt" : "2018-08-31T17:46:06Z",
        "updatedAt" : "2018-08-31T17:47:45Z",
        "lastEditedBy" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "tags" : [
        ]
      }
    ],
    "commit" : "46c513d4a07c737b9a0c71a41b13238146419b7c",
    "line" : 26,
    "diffHunk" : "@@ -1,1 +616,620 @@   * }}}\n   */\n  def validNec[A, B](b: B): ValidatedNec[A, B] = Validated.Valid(b)\n\n"
  },
  {
    "id" : "59973232-627e-4d37-8651-b025b271d134",
    "prId" : 2431,
    "prUrl" : "https://github.com/typelevel/cats/pull/2431#pullrequestreview-147767778",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "cc29051d-d027-46d6-90eb-ebee6cf3ca43",
        "parentId" : null,
        "authorId" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "body" : "same variance question, `invalidNec[A](a: A): ValidatedNec[A, Nothing]`?",
        "createdAt" : "2018-08-20T18:33:34Z",
        "updatedAt" : "2018-08-21T08:26:19Z",
        "lastEditedBy" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "tags" : [
        ]
      }
    ],
    "commit" : "46c513d4a07c737b9a0c71a41b13238146419b7c",
    "line" : 39,
    "diffHunk" : "@@ -1,1 +629,633 @@   * }}}\n   */\n  def invalidNec[A, B](a: A): ValidatedNec[A, B] = Validated.Invalid(NonEmptyChain.one(a))\n\n  /**"
  },
  {
    "id" : "11cc9067-ccb5-4154-a495-e816e80ac043",
    "prId" : 1927,
    "prUrl" : "https://github.com/typelevel/cats/pull/1927#pullrequestreview-69900064",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "853dcc0f-34b6-47de-8394-3a0cbec7e920",
        "parentId" : null,
        "authorId" : "6b760ef7-e448-44a7-b744-0c25c840a80a",
        "body" : "Is it possible to extract this and `ApplicativeError` to a common super trait? ",
        "createdAt" : "2017-10-17T13:49:45Z",
        "updatedAt" : "2017-10-19T17:56:23Z",
        "lastEditedBy" : "6b760ef7-e448-44a7-b744-0c25c840a80a",
        "tags" : [
        ]
      },
      {
        "id" : "292531ae-3e21-4c1c-ab78-0bac9596d8a0",
        "parentId" : "853dcc0f-34b6-47de-8394-3a0cbec7e920",
        "authorId" : "240add12-1fe5-499a-918c-053b1f46b348",
        "body" : "You mean adding a `CommutativeApplicativeError` typeclass? Or just reshuffling the instances?",
        "createdAt" : "2017-10-17T14:02:41Z",
        "updatedAt" : "2017-10-19T17:56:23Z",
        "lastEditedBy" : "240add12-1fe5-499a-918c-053b1f46b348",
        "tags" : [
        ]
      },
      {
        "id" : "5c7a7e69-c973-41c4-8d8a-f2c40e4b15ff",
        "parentId" : "853dcc0f-34b6-47de-8394-3a0cbec7e920",
        "authorId" : "6b760ef7-e448-44a7-b744-0c25c840a80a",
        "body" : "not a new type class, just a new private trait for duplicated code in the two instances. ",
        "createdAt" : "2017-10-17T14:08:26Z",
        "updatedAt" : "2017-10-19T17:56:23Z",
        "lastEditedBy" : "6b760ef7-e448-44a7-b744-0c25c840a80a",
        "tags" : [
        ]
      },
      {
        "id" : "7e516557-b7f9-4c0d-9ec4-b3c4ef89bc21",
        "parentId" : "853dcc0f-34b6-47de-8394-3a0cbec7e920",
        "authorId" : "240add12-1fe5-499a-918c-053b1f46b348",
        "body" : "Ah of course, will do! :)\r\n",
        "createdAt" : "2017-10-17T14:17:26Z",
        "updatedAt" : "2017-10-19T17:56:23Z",
        "lastEditedBy" : "240add12-1fe5-499a-918c-053b1f46b348",
        "tags" : [
        ]
      }
    ],
    "commit" : "d673655d57c319118282f47fff03ff770553981c",
    "line" : 33,
    "diffHunk" : "@@ -1,1 +424,428 @@    }\n\n  implicit def catsDataCommutativeApplicativeForValidated[E: CommutativeSemigroup]: CommutativeApplicative[Validated[E, ?]] =\n    new ValidatedApplicative[E] with CommutativeApplicative[Validated[E, ?]]\n"
  },
  {
    "id" : "12ff2b0b-98df-4a34-a259-2ae4380048f9",
    "prId" : 1540,
    "prUrl" : "https://github.com/typelevel/cats/pull/1540#pullrequestreview-22848400",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d8e23bfa-3f50-4607-b85d-f7400fb888af",
        "parentId" : null,
        "authorId" : "b084ae12-948e-41db-b85f-097bb81e5826",
        "body" : ":+1: ",
        "createdAt" : "2017-02-20T22:37:41Z",
        "updatedAt" : "2017-03-11T02:02:10Z",
        "lastEditedBy" : "b084ae12-948e-41db-b85f-097bb81e5826",
        "tags" : [
        ]
      }
    ],
    "commit" : "ef82db6cd661cc361557d5315e6871e950d30b7f",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +79,83 @@    * Returns Valid values wrapped in Ior.Right, and None for Ior.Left values\n    */\n  def toIor: Ior[E, A] = fold(Ior.left, Ior.right)\n\n  /**"
  },
  {
    "id" : "8f2eab7c-ef35-4da3-a44a-43c7041bb718",
    "prId" : 1532,
    "prUrl" : "https://github.com/typelevel/cats/pull/1532#pullrequestreview-19864922",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "24dec45f-3e9f-4f6b-8850-f374db0f66f2",
        "parentId" : null,
        "authorId" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "body" : "next 5 methods untested.",
        "createdAt" : "2017-02-02T19:09:44Z",
        "updatedAt" : "2017-02-03T09:46:59Z",
        "lastEditedBy" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "tags" : [
        ]
      }
    ],
    "commit" : "96c62466b4e161c284fe8fba775d19a25a648bc0",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +326,330 @@      def raiseError[A](e: E): Validated[E, A] = Validated.Invalid(e)\n\n      override def reduceLeftToOption[A, B](fa: Validated[E, A])(f: A => B)(g: (B, A) => B): Option[B] =\n        fa.map(f).toOption\n"
  },
  {
    "id" : "6168ddf1-6bc3-4fcd-bc23-b9228f4735a6",
    "prId" : 1532,
    "prUrl" : "https://github.com/typelevel/cats/pull/1532#pullrequestreview-19864922",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "80a1fcda-0e87-482a-a4f7-6535f8d9e518",
        "parentId" : null,
        "authorId" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "body" : "untested",
        "createdAt" : "2017-02-02T19:10:36Z",
        "updatedAt" : "2017-02-03T09:46:59Z",
        "lastEditedBy" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "tags" : [
        ]
      }
    ],
    "commit" : "96c62466b4e161c284fe8fba775d19a25a648bc0",
    "line" : 41,
    "diffHunk" : "@@ -1,1 +354,358 @@\n      override def toList[A](fa: Validated[E, A]): List[A] =\n        fa.fold(_ => Nil, _ :: Nil)\n\n      override def isEmpty[A](fa: Validated[E, A]): Boolean = fa.isInvalid"
  }
]
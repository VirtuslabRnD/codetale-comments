[
  {
    "id" : "f354826f-c3d8-40a3-a591-e382777112d9",
    "prId" : 1938,
    "prUrl" : "https://github.com/typelevel/cats/pull/1938#pullrequestreview-75736101",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e833100e-07bf-4a64-8622-6a713609a74a",
        "parentId" : null,
        "authorId" : "6b760ef7-e448-44a7-b744-0c25c840a80a",
        "body" : "This should be lawful right? but we can't test it...that's awkward. how about moving it to alleycats? ",
        "createdAt" : "2017-11-06T17:59:05Z",
        "updatedAt" : "2017-11-14T18:54:42Z",
        "lastEditedBy" : "6b760ef7-e448-44a7-b744-0c25c840a80a",
        "tags" : [
        ]
      },
      {
        "id" : "1becd19f-203d-4bee-bb32-5a716f66d03c",
        "parentId" : "e833100e-07bf-4a64-8622-6a713609a74a",
        "authorId" : "240add12-1fe5-499a-918c-053b1f46b348",
        "body" : "Awkward indeed, I'm not sure if alleycats is the right place, since they can be proven to be lawful in e.g. Haskell, but I agree that it's awkward.\r\n\r\nMaybe we should move the `CommutativeApplicative` instance to Alleycats and keep the `CommutativeApply` instance here? ",
        "createdAt" : "2017-11-10T10:53:13Z",
        "updatedAt" : "2017-11-14T18:54:42Z",
        "lastEditedBy" : "240add12-1fe5-499a-918c-053b1f46b348",
        "tags" : [
        ]
      },
      {
        "id" : "0c447cb6-bf62-410c-bb78-186dc7dead70",
        "parentId" : "e833100e-07bf-4a64-8622-6a713609a74a",
        "authorId" : "6b760ef7-e448-44a7-b744-0c25c840a80a",
        "body" : "I thought about that but it would cause implicit conflict if you import both right? Unless we do the export hook trick which is kind of deprecated. Maybe we just document a bit more. \r\n",
        "createdAt" : "2017-11-10T11:54:17Z",
        "updatedAt" : "2017-11-14T18:54:42Z",
        "lastEditedBy" : "6b760ef7-e448-44a7-b744-0c25c840a80a",
        "tags" : [
        ]
      }
    ],
    "commit" : "15def6029490a07800a996eb7d8b4aceb441107d",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +11,15 @@\n  implicit val catsDataAlternativeForZipStream: Alternative[ZipStream] with CommutativeApplicative[ZipStream] =\n    new Alternative[ZipStream] with CommutativeApplicative[ZipStream] {\n      def pure[A](x: A): ZipStream[A] = new ZipStream(Stream.continually(x))\n"
  }
]
[
  {
    "id" : "4745d2cc-2a49-4dee-a825-73d32e1de387",
    "prId" : 1611,
    "prUrl" : "https://github.com/typelevel/cats/pull/1611#pullrequestreview-40677611",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fb113074-7122-4ac2-8078-9aa429c2c360",
        "parentId" : null,
        "authorId" : "98bd6ddf-86cb-413a-a672-ee7d989ba290",
        "body" : "Can you add the implementation of `traverse` used in the `Traverse` instance above here as well?",
        "createdAt" : "2017-05-28T18:51:04Z",
        "updatedAt" : "2017-06-12T18:02:57Z",
        "lastEditedBy" : "98bd6ddf-86cb-413a-a672-ee7d989ba290",
        "tags" : [
        ]
      }
    ],
    "commit" : "50cc4c0cbdc92f7fe199a6126a4ca22138c02312",
    "line" : 33,
    "diffHunk" : "@@ -1,1 +235,239 @@          .reduceLeft(((acc, a) => (acc |@| a).map((x: OneAnd[F, B], y: OneAnd[F, B]) => x.combine(y))))\n      }\n\n\n      override def traverse[G[_], A, B](fa: OneAnd[F, A])(f: (A) => G[B])(implicit G: Applicative[G]): G[OneAnd[F, B]] = {"
  },
  {
    "id" : "86d15cc9-5167-479f-91c2-633073514af6",
    "prId" : 1464,
    "prUrl" : "https://github.com/typelevel/cats/pull/1464#pullrequestreview-39178352",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a7d08294-8891-4deb-b599-217b500dced3",
        "parentId" : null,
        "authorId" : "98bd6ddf-86cb-413a-a672-ee7d989ba290",
        "body" : "I think we can add this implementation to `NonEmptyReducible` (in _Reducible.scala_) as well,",
        "createdAt" : "2017-05-19T09:23:21Z",
        "updatedAt" : "2017-05-19T11:16:18Z",
        "lastEditedBy" : "98bd6ddf-86cb-413a-a672-ee7d989ba290",
        "tags" : [
        ]
      },
      {
        "id" : "0d0b8ac4-0841-4e97-8f55-f2822499ae44",
        "parentId" : "a7d08294-8891-4deb-b599-217b500dced3",
        "authorId" : "b43434dc-f706-4cba-a4f2-eb4b74682cdf",
        "body" : "Done. I know there isn't a test currently; but I think that if such a test exists it should be comparing the default implementation to any overrides which exist.\r\n\r\nDo you mind if we put that on a different issue because I think that the consistency of the methods is important.",
        "createdAt" : "2017-05-19T12:12:32Z",
        "updatedAt" : "2017-05-19T12:12:32Z",
        "lastEditedBy" : "b43434dc-f706-4cba-a4f2-eb4b74682cdf",
        "tags" : [
        ]
      }
    ],
    "commit" : "71d4fd6c6a86a8a713be3db3f1c4a4c4cc55db19",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +119,123 @@\n      override def get[A](fa: OneAnd[F, A])(idx: Long): Option[A] =\n        if (idx == 0L) Some(fa.head) else F.get(fa.tail)(idx - 1L)\n\n      override def size[A](fa: OneAnd[F, A]): Long = 1 + F.size(fa.tail)"
  },
  {
    "id" : "4a365b4d-521c-47d3-b405-8acb7704b201",
    "prId" : 298,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d0e578c8-8582-44ce-8661-d53767628f77",
        "parentId" : null,
        "authorId" : "b714495a-5740-47d4-aaaa-98f354f5c0a7",
        "body" : "I think it should wait for another PR as this one is already pretty large, but it looks like we are missing a `oneAndReducible` instance. Is that right?\n",
        "createdAt" : "2015-05-20T11:02:09Z",
        "updatedAt" : "2015-05-20T13:15:21Z",
        "lastEditedBy" : "b714495a-5740-47d4-aaaa-98f354f5c0a7",
        "tags" : [
        ]
      }
    ],
    "commit" : "d0467800edf5679f813fa76c7faef8cd8c4e58d4",
    "line" : 140,
    "diffHunk" : "@@ -1,1 +98,102 @@    }\n\n  implicit def oneAndFoldable[F[_]](implicit foldable: Foldable[F]): Foldable[OneAnd[?,F]] =\n    new Foldable[OneAnd[?,F]] {\n      override def foldLeft[A, B](fa: OneAnd[A, F], b: B)(f: (B, A) => B): B ="
  }
]
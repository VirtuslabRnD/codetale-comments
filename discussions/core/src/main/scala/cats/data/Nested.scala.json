[
  {
    "id" : "1833942d-17fe-4144-b76b-01c8dc0c1bce",
    "prId" : 1893,
    "prUrl" : "https://github.com/typelevel/cats/pull/1893#pullrequestreview-61658197",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1a521fd6-b7a6-47bf-9d4f-95c95d2c2eac",
        "parentId" : null,
        "authorId" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "body" : "couldn't you do it both ways? Put the `F[_]: ApplicativeError` or the `G[_]: ApplicativeError`?\r\n\r\nLike: `Nested[Validated[String, ?], Option, ?]` or `Nested[Option, Validate[String, ?], ?]` You could have put the error on the inside or out, no?",
        "createdAt" : "2017-09-09T00:56:16Z",
        "updatedAt" : "2017-09-09T00:56:16Z",
        "lastEditedBy" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "tags" : [
        ]
      },
      {
        "id" : "247db107-9654-445f-877d-6f56182380b3",
        "parentId" : "1a521fd6-b7a6-47bf-9d4f-95c95d2c2eac",
        "authorId" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "body" : "could we make two implementations at different priorities?",
        "createdAt" : "2017-09-09T00:56:52Z",
        "updatedAt" : "2017-09-09T00:56:52Z",
        "lastEditedBy" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "tags" : [
        ]
      },
      {
        "id" : "f5d67b13-cbec-414b-b274-8c4e24596e65",
        "parentId" : "1a521fd6-b7a6-47bf-9d4f-95c95d2c2eac",
        "authorId" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "body" : "I see your comment about reversing being hard unless you have `F[_]: Monad`. Indeed.\r\n\r\nI wonder if it is worth adding that instance (`F[_]: Monad` and `G[_]: ApplicativeError`).",
        "createdAt" : "2017-09-09T02:23:36Z",
        "updatedAt" : "2017-09-09T02:23:36Z",
        "lastEditedBy" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "tags" : [
        ]
      },
      {
        "id" : "65861758-c029-4b69-a9a4-f27e1d2b76bc",
        "parentId" : "1a521fd6-b7a6-47bf-9d4f-95c95d2c2eac",
        "authorId" : "240add12-1fe5-499a-918c-053b1f46b348",
        "body" : "Generally, I don't think we often have a constellation like that, but yeah for something like `Nested[Option, Validated[String, ?], ?]` it would work. However, I don't think it's enough to implement it on `Nested`. In my comment, I used `F[Validated[E, A]]` (aka `ValidatedT[F, E, A]`), but that has the extra property of being able to fold the `Validated` inside.\r\n\r\nIf all we have is `ApplicativeError`, we can't get there, because we don't have a function from `E => G[A]`, we only have `E => F[G[A]]`\r\n\r\n```scala\r\n// We only have this\r\ndef handleErrorWith(ga: G[A])(f: E => G[A]): G[A]\r\n\r\n// but we need to implement this:\r\ndef handleErrorWith(fa: Nested[F, G, A])(f: E => Nested[F, G, A]): Nested[F, G, A]\r\n```\r\nWe can't use the `f: E => Nested[F, G, A]` for the inner `ApplicativeError`, since we have no way to turn a `Nested[F, G, A]` into a `G[A]`\r\n\r\n The only way to do that, would be to give F and G `Traverse` instances or F an extra `Comonad` instance. Both of which would make this whole thing not really worth it IMO.\r\n \r\nWe can do it with `Validated`, because it allows us to `fold` it, but that's not true for the generic `ApplicativeError`.\r\n\r\nOf course, I might be completely wrong, so point me in the right direction if I made a wrong assumption somewhere. ðŸ˜„",
        "createdAt" : "2017-09-09T08:20:25Z",
        "updatedAt" : "2017-09-09T08:20:25Z",
        "lastEditedBy" : "240add12-1fe5-499a-918c-053b1f46b348",
        "tags" : [
        ]
      }
    ],
    "commit" : "af55ca52eb89917de9c66f24a5ce49919e852c11",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +82,86 @@\nprivate[data] sealed abstract class NestedInstances4 extends NestedInstances5 {\n  implicit def catsDataApplicativeErrorForNested[F[_]: ApplicativeError[?[_], E], G[_]: Applicative, E]: ApplicativeError[Nested[F, G, ?], E] =\n    new NestedApplicativeError[F, G, E] {\n      val G: Applicative[G] = Applicative[G]"
  }
]
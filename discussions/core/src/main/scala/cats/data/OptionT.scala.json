[
  {
    "id" : "c696a0fd-8e59-4907-ba2a-d0d209390e32",
    "prId" : 3335,
    "prUrl" : "https://github.com/typelevel/cats/pull/3335#pullrequestreview-391779666",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "59e73d93-4a25-49aa-8833-0ad7ab56ed26",
        "parentId" : null,
        "authorId" : "ee04e3fc-01cf-4b53-b73a-ec7dfe8d58cf",
        "body" : "```suggestion\r\n  def foldF[B](ifNone: => F[B])(withSome: A => F[B])(implicit F: FlatMap[F]): F[B] =\r\n```\r\nShould we add more informative names?",
        "createdAt" : "2020-04-11T13:36:29Z",
        "updatedAt" : "2020-04-11T16:18:28Z",
        "lastEditedBy" : "ee04e3fc-01cf-4b53-b73a-ec7dfe8d58cf",
        "tags" : [
        ]
      },
      {
        "id" : "e12b3622-cb40-424a-9f98-286da8189073",
        "parentId" : "59e73d93-4a25-49aa-8833-0ad7ab56ed26",
        "authorId" : "054e5467-279a-4f2a-b200-4723d4922619",
        "body" : "While I agree with your intention (and have hence changed it on `flatTapNone` â€“ thx), I would value consistency with `fold` more and keep the parameter names the same.",
        "createdAt" : "2020-04-11T16:20:05Z",
        "updatedAt" : "2020-04-11T16:20:06Z",
        "lastEditedBy" : "054e5467-279a-4f2a-b200-4723d4922619",
        "tags" : [
        ]
      }
    ],
    "commit" : "468e4f78ec8ca15bd1b1965eda41fc398dce2469",
    "line" : 16,
    "diffHunk" : "@@ -1,1 +27,31 @@   * }}}\n   */\n  def foldF[B](default: => F[B])(f: A => F[B])(implicit F: FlatMap[F]): F[B] =\n    F.flatMap(value)(_.fold(default)(f))\n"
  },
  {
    "id" : "e919bb50-f2c2-47ca-b22a-7d9e95e0234b",
    "prId" : 3335,
    "prUrl" : "https://github.com/typelevel/cats/pull/3335#pullrequestreview-391779975",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7ac8a352-8f63-4ee4-937f-a59ace955f5b",
        "parentId" : null,
        "authorId" : "ee04e3fc-01cf-4b53-b73a-ec7dfe8d58cf",
        "body" : "I am aware of the notions of _catamorphisms_, but is that also a unified term or notion across `cats`? I can only grep the words  `def cata` in `OptionT`and in `CoFree`. \r\n\r\nUnless we want to extend the use across the whole of `cats`, perhaps we should drop them, to avoid confusion.",
        "createdAt" : "2020-04-11T13:39:31Z",
        "updatedAt" : "2020-04-11T16:18:28Z",
        "lastEditedBy" : "ee04e3fc-01cf-4b53-b73a-ec7dfe8d58cf",
        "tags" : [
        ]
      },
      {
        "id" : "3ef6213b-a104-4526-8c19-65b6061f5cbc",
        "parentId" : "7ac8a352-8f63-4ee4-937f-a59ace955f5b",
        "authorId" : "054e5467-279a-4f2a-b200-4723d4922619",
        "body" : "There's a `cata` to `fold` already, so when seeing `foldF`, I'd expect `cataF` there as well. Whether `cata` should have been introduced with that name in the first place seems to be outside of the scope of this PRâ€¦but that's just my two cents.",
        "createdAt" : "2020-04-11T16:24:05Z",
        "updatedAt" : "2020-04-11T16:24:06Z",
        "lastEditedBy" : "054e5467-279a-4f2a-b200-4723d4922619",
        "tags" : [
        ]
      }
    ],
    "commit" : "468e4f78ec8ca15bd1b1965eda41fc398dce2469",
    "line" : 31,
    "diffHunk" : "@@ -1,1 +43,47 @@   * contexts.\n   */\n  def cataF[B](default: => F[B], f: A => F[B])(implicit F: FlatMap[F]): F[B] =\n    foldF(default)(f)\n"
  },
  {
    "id" : "b52d00b0-07fc-4d0a-9a57-b797063582a8",
    "prId" : 3335,
    "prUrl" : "https://github.com/typelevel/cats/pull/3335#pullrequestreview-391780483",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "dc1d0911-3970-45b7-bed4-61895b3a5b1a",
        "parentId" : null,
        "authorId" : "ee04e3fc-01cf-4b53-b73a-ec7dfe8d58cf",
        "body" : "We have had this conversation before: given that the `B` has no relevance on the types of the outputs, should we just make it an existential?\r\n```suggestion\r\n  def semiflatTap(withSome: A => F[_])(implicit F: Monad[F]): OptionT[F, A] =\r\n```",
        "createdAt" : "2020-04-11T13:40:54Z",
        "updatedAt" : "2020-04-11T16:18:28Z",
        "lastEditedBy" : "ee04e3fc-01cf-4b53-b73a-ec7dfe8d58cf",
        "tags" : [
        ]
      },
      {
        "id" : "0ed5cacd-9c96-407a-a0c7-dc8f80451cc5",
        "parentId" : "dc1d0911-3970-45b7-bed4-61895b3a5b1a",
        "authorId" : "054e5467-279a-4f2a-b200-4723d4922619",
        "body" : "`FlatMap` has this type parameter for `flatTap`, `EitherT` has it for it's `semiFlatTap`, so again, I would vote for consistency to give cats users a reliable experience in terms of how signatures look and when type inference works. Or do you see any other advantage of the existential which would outweigh this aspect?",
        "createdAt" : "2020-04-11T16:29:53Z",
        "updatedAt" : "2020-04-11T16:29:53Z",
        "lastEditedBy" : "054e5467-279a-4f2a-b200-4723d4922619",
        "tags" : [
        ]
      }
    ],
    "commit" : "468e4f78ec8ca15bd1b1965eda41fc398dce2469",
    "line" : 41,
    "diffHunk" : "@@ -1,1 +67,71 @@    flatMap(a => OptionT.liftF(f(a)))\n\n  def semiflatTap[B](f: A => F[B])(implicit F: Monad[F]): OptionT[F, A] =\n    semiflatMap(a => F.as(f(a), a))\n"
  },
  {
    "id" : "50923b0f-a110-4d45-880c-8bc4aab50bbb",
    "prId" : 3233,
    "prUrl" : "https://github.com/typelevel/cats/pull/3233#pullrequestreview-338335271",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "940740d4-79ef-4864-8e8b-a5610d513871",
        "parentId" : null,
        "authorId" : "66a3e1fe-d02b-4e16-badc-4e9980e148af",
        "body" : "I find the implementation of the `else` branch surprising. I would have thought that it is just `OptionT.none[F, A]` if `cond` is `false` (analogous to `OptionT.when`) but the current implementation runs the `F`-effect and then replaces the `A` with `None: Option[A]`.",
        "createdAt" : "2020-01-02T19:26:57Z",
        "updatedAt" : "2020-01-02T19:26:57Z",
        "lastEditedBy" : "66a3e1fe-d02b-4e16-badc-4e9980e148af",
        "tags" : [
        ]
      },
      {
        "id" : "d907809e-4a3f-43ae-a955-195855b117af",
        "parentId" : "940740d4-79ef-4864-8e8b-a5610d513871",
        "authorId" : "a75f1f8c-53ef-4f72-9b09-105119704576",
        "body" : "~~It seems odd and it works when F = List and fa = List.empty because we want to get `OptionT(List.empty)` not `OptionT(List(None))`. But it breaks the case `OptionT.whenF[List, Int](false)(List(1,2))` because we have `OptionT(List(None, None))` not `OptionT(List.empty)`ðŸ˜±~~\r\n\r\n~~I will create a follow-up pull request to fix it.~~  I find no easy \"fix\" ðŸ˜±\r\n`whenF` uses `liftF` if `cond` is true. `liftF` is `OptionT(F.map(fa)(Some(_)))` so if `cond` is false, I think it should use something similar to `liftF` so that some \"good\" properties hold:\r\n\r\n```\r\nList(1, 2, 3).map(Option.when(false)(_)) == OptionT.whenF(false)(List(1, 2, 3)).value\r\n\r\nList(1, 2, 3).map(Option.when(true)(_)) == OptionT.whenF(true)(List(1, 2, 3)).value\r\n\r\nList().map(Option.when(true)(_)) == OptionT.whenF(true)(List()).value\r\n\r\nList().map(Option.when(false)(_)) == OptionT.whenF(false)(List()).value\r\n```\r\n\r\n~~I should have implemented the case when F assumes the empty value or F is a Monoid separately.~~ Any comments and suggestions are welcome!",
        "createdAt" : "2020-01-02T23:51:16Z",
        "updatedAt" : "2020-01-03T02:55:02Z",
        "lastEditedBy" : "a75f1f8c-53ef-4f72-9b09-105119704576",
        "tags" : [
        ]
      },
      {
        "id" : "145c95cf-951c-48e3-855a-d52dae385450",
        "parentId" : "940740d4-79ef-4864-8e8b-a5610d513871",
        "authorId" : "66a3e1fe-d02b-4e16-badc-4e9980e148af",
        "body" : "If these properties imply that `val launchMissiles: IO[Unit] = ...; OptionT.whenF(cond)(launchMissiles)` always launches the missiles, no matter what `cond` is, then I think we should get rid of either these properties or `whenF`. I would prefer the former because `whenF` seems like a useful utility to me.",
        "createdAt" : "2020-01-03T08:51:33Z",
        "updatedAt" : "2020-01-03T08:51:33Z",
        "lastEditedBy" : "66a3e1fe-d02b-4e16-badc-4e9980e148af",
        "tags" : [
        ]
      },
      {
        "id" : "e149e6a7-441b-45ca-9e05-343a13e9a8d0",
        "parentId" : "940740d4-79ef-4864-8e8b-a5610d513871",
        "authorId" : "2ed5d687-cc94-4d72-ba74-717be38944e9",
        "body" : "I agree with @fthomas.  Good catch.\r\n\r\nHow about this for `whenF`?  Many of the `F` methods on transformers are specified in terms of `Id`, and passes with Frank's proposed change:\r\n\r\n```\r\n  test(\"OptionT.whenF[Id, A] consistent with Option.when\") {\r\n    def when[A] = (c: Boolean, a: A) => if (c) Some(a) else None\r\n    forAll { (i: Int, b: Boolean) =>\r\n      OptionT.whenF[Id, Int](b)(i).value should ===(when(b, i))\r\n    }\r\n  }\r\n```\r\n\r\nWe might even relate it to `.sequence` for less trivial effects:\r\n\r\n```scala\r\nforAll { (i: List[Int], b: Boolean) =>\r\n  OptionT.whenF[List, Int](b)(i).value should ===(when(b, i).sequence)\r\n}\r\n```",
        "createdAt" : "2020-01-04T01:54:24Z",
        "updatedAt" : "2020-01-04T01:54:25Z",
        "lastEditedBy" : "2ed5d687-cc94-4d72-ba74-717be38944e9",
        "tags" : [
        ]
      },
      {
        "id" : "644bf776-1a4a-4162-b04d-6d96858c0a89",
        "parentId" : "940740d4-79ef-4864-8e8b-a5610d513871",
        "authorId" : "a75f1f8c-53ef-4f72-9b09-105119704576",
        "body" : "@fthomas @rossabaker Thank you both for your helpful examples. I will make a follow-up pull request.",
        "createdAt" : "2020-01-04T03:29:24Z",
        "updatedAt" : "2020-01-04T03:29:24Z",
        "lastEditedBy" : "a75f1f8c-53ef-4f72-9b09-105119704576",
        "tags" : [
        ]
      }
    ],
    "commit" : "49be1770e66e43dc3b3139daf8b2e499b5715e5b",
    "line" : 17,
    "diffHunk" : "@@ -1,1 +237,241 @@   */\n  def whenF[F[_], A](cond: Boolean)(fa: => F[A])(implicit F: Applicative[F]): OptionT[F, A] =\n    if (cond) OptionT.liftF(fa) else OptionT(F.map(fa)(_ => Option.empty))\n\n  /**"
  },
  {
    "id" : "d6f2db36-8d98-4c48-9219-5da888e67a43",
    "prId" : 2965,
    "prUrl" : "https://github.com/typelevel/cats/pull/2965#pullrequestreview-270464341",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "339724f5-27c6-4cee-99ca-8647479188a7",
        "parentId" : null,
        "authorId" : "2ed5d687-cc94-4d72-ba74-717be38944e9",
        "body" : "I think this could call the corrected one instead of duplicating the implementation. The key is that it's deprecated and no longer the implicit.",
        "createdAt" : "2019-08-03T15:50:34Z",
        "updatedAt" : "2019-08-05T01:46:52Z",
        "lastEditedBy" : "2ed5d687-cc94-4d72-ba74-717be38944e9",
        "tags" : [
        ]
      }
    ],
    "commit" : "9254957d326129555fd0cd89a8e9a22643c513e8",
    "line" : 15,
    "diffHunk" : "@@ -1,1 +270,274 @@\n  @deprecated(\"renamed to catsDataTraverseFilterForOptionT\", \"2.0.0\")\n  def catsDateTraverseFilterForOptionT[F[_]](implicit F0: Traverse[F]): TraverseFilter[OptionT[F, *]] =\n    catsDataTraverseFilterForOptionT\n}"
  }
]
[
  {
    "id" : "2742d4f3-61b4-4c04-91c8-8f77f65cb6bd",
    "prId" : 3556,
    "prUrl" : "https://github.com/typelevel/cats/pull/3556#pullrequestreview-465994949",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "05a11515-e0d0-46fa-87be-dbf652efbb81",
        "parentId" : null,
        "authorId" : "9e8a6a6c-6f4e-49b4-ab87-ee2c5ced7e78",
        "body" : "Is this a normal thing to add directly to the type? I actually don't know what our idiom is here.",
        "createdAt" : "2020-08-12T14:51:59Z",
        "updatedAt" : "2020-08-12T14:52:37Z",
        "lastEditedBy" : "9e8a6a6c-6f4e-49b4-ab87-ee2c5ced7e78",
        "tags" : [
        ]
      }
    ],
    "commit" : "eacd3887cff5a59e7d4756f3fef2dd46db6bf032",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +323,327 @@\n  def compare(that: WriterT[F, L, V])(implicit Ord: Order[F[(L, V)]]): Int =\n    Ord.compare(run, that.run)\n}\n"
  },
  {
    "id" : "4437f759-2d36-4ccb-a27a-07cf2e51baec",
    "prId" : 2792,
    "prUrl" : "https://github.com/typelevel/cats/pull/2792#pullrequestreview-227591538",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "cf37e060-2f66-4024-8fc6-30e0b19dbb79",
        "parentId" : null,
        "authorId" : "6b760ef7-e448-44a7-b744-0c25c840a80a",
        "body" : "Just curious, was this an optimization opportunity you happen to come across or was it broken on RC1?\r\nAlso would it be simpler to just call `fa.ap(f)`",
        "createdAt" : "2019-04-17T01:17:19Z",
        "updatedAt" : "2019-04-17T20:05:43Z",
        "lastEditedBy" : "6b760ef7-e448-44a7-b744-0c25c840a80a",
        "tags" : [
        ]
      },
      {
        "id" : "659dc976-1b83-4175-875e-59d8599860c2",
        "parentId" : "cf37e060-2f66-4024-8fc6-30e0b19dbb79",
        "authorId" : "6943dbfe-856b-4f1b-bd04-dca0091e8291",
        "body" : "This is from @SethTisue's commit, but the issue is that 2.13 sees the `ap` definitions in `FlatMap` and `WriterTApply` as conflicting. I personally think picking out the appropriate implementation via `super` is the right thing to do in this case, but I also don't think it matters much, and am happy to change it to `fa.ap(f)` if you'd prefer.",
        "createdAt" : "2019-04-17T07:34:44Z",
        "updatedAt" : "2019-04-17T20:05:43Z",
        "lastEditedBy" : "6943dbfe-856b-4f1b-bd04-dca0091e8291",
        "tags" : [
        ]
      }
    ],
    "commit" : "143a62b377ea605a4c3e2da5037add422a8eaefa",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +358,362 @@  implicit def L0: Monoid[L]\n\n  override def ap[A, B](f: WriterT[F, L, A => B])(fa: WriterT[F, L, A]): WriterT[F, L, B] =\n    super[WriterTApply].ap(f)(fa)\n"
  },
  {
    "id" : "aa75f27d-bb9b-4a4b-9c59-e8776e64c9bd",
    "prId" : 2182,
    "prUrl" : "https://github.com/typelevel/cats/pull/2182#pullrequestreview-102854676",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b8b4c39b-93b6-4758-8bfd-6cd862dd2eec",
        "parentId" : null,
        "authorId" : "6b760ef7-e448-44a7-b744-0c25c840a80a",
        "body" : "@barambani you can't have any instance that potentially conflicts in the same trait level.  \r\n I think there is `Functor` instance conflict here for `[WriterT[Id, L, ?]`. I think you might need to create quite a few more priority layers to separate the instances. ",
        "createdAt" : "2018-03-09T17:27:27Z",
        "updatedAt" : "2018-03-12T15:21:32Z",
        "lastEditedBy" : "6b760ef7-e448-44a7-b744-0c25c840a80a",
        "tags" : [
        ]
      },
      {
        "id" : "6bd7ef5a-7c86-430c-ae43-3e5066896bf5",
        "parentId" : "b8b4c39b-93b6-4758-8bfd-6cd862dd2eec",
        "authorId" : "6b760ef7-e448-44a7-b744-0c25c840a80a",
        "body" : "to be clear I didn't see the actually error message on travis. But I think separating them out might solve the problem. ",
        "createdAt" : "2018-03-09T17:28:48Z",
        "updatedAt" : "2018-03-12T15:21:32Z",
        "lastEditedBy" : "6b760ef7-e448-44a7-b744-0c25c840a80a",
        "tags" : [
        ]
      },
      {
        "id" : "b9bcff33-1df6-4f23-841b-1b3449ae691a",
        "parentId" : "b8b4c39b-93b6-4758-8bfd-6cd862dd2eec",
        "authorId" : "6eab4df0-103c-4334-ab61-5d3e9aa43193",
        "body" : "Sorry for the confusion, my bad for the lack of clarity. This prioritisation should work (let's see when the CI completes). My question was more in general about the reason why we needed to create instances for `Id`. I would have expected that something like `Comonad[WriterT[Id, ListWrapper[Int], ?]]` could summon the instance for `F[_]` and I was wondering if you had resources about why that's not the case.\r\nThis doesn't mean that I'm not happy to add more priority levels if you think that's better. Thanks for the great help here. ",
        "createdAt" : "2018-03-09T17:57:51Z",
        "updatedAt" : "2018-03-12T15:21:32Z",
        "lastEditedBy" : "6eab4df0-103c-4334-ab61-5d3e9aa43193",
        "tags" : [
        ]
      },
      {
        "id" : "87300969-5a7e-414d-ad87-2d42bd25cbef",
        "parentId" : "b8b4c39b-93b6-4758-8bfd-6cd862dd2eec",
        "authorId" : "b714495a-5740-47d4-aaaa-98f354f5c0a7",
        "body" : "@barambani I don't know the underlying reason that `Id` needs to be special-cased, but it's a weakness in scalac's type inference. [This](https://stackoverflow.com/questions/11913128/scalaz-7-why-using-type-alias-results-in-ambigous-typeclass-resolution-for-rea) is a related Stack Overflow post that I've seen before. Something like `Id` might be a tricky one because `A =:= Id[A] =:= Id[Id[A]]`, so there may be some logic to short-circuit inference when applying a type results in the same type so you don't end up in an infinite loop or something. This is pure speculation :)",
        "createdAt" : "2018-03-10T15:42:16Z",
        "updatedAt" : "2018-03-12T15:21:32Z",
        "lastEditedBy" : "b714495a-5740-47d4-aaaa-98f354f5c0a7",
        "tags" : [
        ]
      },
      {
        "id" : "02c759ac-f6b9-42a9-bc2a-b60e6909940b",
        "parentId" : "b8b4c39b-93b6-4758-8bfd-6cd862dd2eec",
        "authorId" : "6eab4df0-103c-4334-ab61-5d3e9aa43193",
        "body" : "@ceedubs thanks a lot, I didn't want for you to waste time on this. I was just taking advantage of this discussion in case you knew it out of your head ğŸ˜ƒ ğŸ‘ ",
        "createdAt" : "2018-03-10T15:57:00Z",
        "updatedAt" : "2018-03-12T15:21:32Z",
        "lastEditedBy" : "6eab4df0-103c-4334-ab61-5d3e9aa43193",
        "tags" : [
        ]
      }
    ],
    "commit" : "152ee7a933ed3a31c7a9103245f8eef8e995bb7a",
    "line" : 33,
    "diffHunk" : "@@ -1,1 +108,112 @@    }\n\n  implicit def catsDataTraverseForWriterTId[L](implicit F: Traverse[Id]): Traverse[WriterT[Id, L, ?]] =\n    catsDataTraverseForWriterT[Id, L](F)\n}"
  },
  {
    "id" : "a6428664-c15d-46de-ac14-798601529f40",
    "prId" : 928,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "79692d77-e956-4508-baa7-d1e8989c390f",
        "parentId" : null,
        "authorId" : "4aafd631-794d-4704-aeda-a6c56ce667d1",
        "body" : "Hm we should be able to delete this line right?\n",
        "createdAt" : "2016-03-17T07:12:13Z",
        "updatedAt" : "2016-03-17T07:12:13Z",
        "lastEditedBy" : "4aafd631-794d-4704-aeda-a6c56ce667d1",
        "tags" : [
        ]
      },
      {
        "id" : "8862c72d-0b55-4193-82c2-dcf0c4922fcf",
        "parentId" : "79692d77-e956-4508-baa7-d1e8989c390f",
        "authorId" : "b714495a-5740-47d4-aaaa-98f354f5c0a7",
        "body" : "@adelbertc isn't the `Show` instance delegating to this method?\n",
        "createdAt" : "2016-03-17T12:55:42Z",
        "updatedAt" : "2016-03-17T12:55:42Z",
        "lastEditedBy" : "b714495a-5740-47d4-aaaa-98f354f5c0a7",
        "tags" : [
        ]
      },
      {
        "id" : "afd3da10-a553-4b8e-998c-783c31095b79",
        "parentId" : "79692d77-e956-4508-baa7-d1e8989c390f",
        "authorId" : "11416d6f-f459-44a5-9cb8-b5fb85bc9252",
        "body" : "Yeah, the `Show` instance is delegating to this method.  I modeled this on the change that added a `Show` instance for OptionT (see: https://github.com/typelevel/cats/pull/600/files; and in particular: https://github.com/typelevel/cats/blob/6dbd4b04aff336867f563c9f6ec04fde828aa816/core/src/main/scala/cats/data/OptionT.scala#L90).  But I agree it is not strictly needed (assuming the `Show` instance is updated accordingly).\n",
        "createdAt" : "2016-03-17T14:45:04Z",
        "updatedAt" : "2016-03-17T14:47:08Z",
        "lastEditedBy" : "11416d6f-f459-44a5-9cb8-b5fb85bc9252",
        "tags" : [
        ]
      },
      {
        "id" : "801b8b8f-b885-4279-b763-59c1c1eca903",
        "parentId" : "79692d77-e956-4508-baa7-d1e8989c390f",
        "authorId" : "4aafd631-794d-4704-aeda-a6c56ce667d1",
        "body" : "Oh I see now, I read it as `Show[(L, V)]` - ignore me :-)\n",
        "createdAt" : "2016-03-17T18:23:53Z",
        "updatedAt" : "2016-03-17T18:23:53Z",
        "lastEditedBy" : "4aafd631-794d-4704-aeda-a6c56ce667d1",
        "tags" : [
        ]
      }
    ],
    "commit" : "42a0583ce30379aecea24374e8e48c34739f2e9a",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +46,50 @@    mapWritten(_ => monoidL.empty)\n\n  def show(implicit F: Show[F[(L, V)]]): String = F.show(run)\n}\nobject WriterT extends WriterTInstances with WriterTFunctions"
  },
  {
    "id" : "de667409-ff6a-4a30-8094-60cc5ef6c157",
    "prId" : 689,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1aee4846-164b-4ac2-81d9-92488ba3ba3d",
        "parentId" : null,
        "authorId" : "f75a02fd-6511-4437-8cc0-9d87743d5ec7",
        "body" : "I wonder if you should append the L from fa.run and the L that results from f(e).run ?\nIn other words, if the Log that came from fa will be lost (maybe it's ok for it to be forgotten)\n",
        "createdAt" : "2016-01-12T11:33:36Z",
        "updatedAt" : "2016-07-22T13:39:44Z",
        "lastEditedBy" : "f75a02fd-6511-4437-8cc0-9d87743d5ec7",
        "tags" : [
        ]
      },
      {
        "id" : "79462fdc-1880-4515-8cc9-0debdc6dfa39",
        "parentId" : "1aee4846-164b-4ac2-81d9-92488ba3ba3d",
        "authorId" : "b714495a-5740-47d4-aaaa-98f354f5c0a7",
        "body" : "@lukiano sorry I'm just seeing this. I don't think we can do what you have recommended. Let's consider `Future` as `F` (and thus `Throwable` as `E`). If the `Future` fails, then there is no log. We _do_ have a log if the future succeeds, but in that case the function that we pass to `handleErrorWith` will never be called, because there is no error to handle.\n\nDoes that sound right?\n",
        "createdAt" : "2016-05-13T12:16:58Z",
        "updatedAt" : "2016-07-22T13:39:44Z",
        "lastEditedBy" : "b714495a-5740-47d4-aaaa-98f354f5c0a7",
        "tags" : [
        ]
      },
      {
        "id" : "71b18a76-8c5a-46d0-95a3-c6343fbeef57",
        "parentId" : "1aee4846-164b-4ac2-81d9-92488ba3ba3d",
        "authorId" : "f75a02fd-6511-4437-8cc0-9d87743d5ec7",
        "body" : "I think you are right. I was thinking of something like XorT -> WriterT -> Future, but in this case F is just Future so there's no monadError instance for it. XorT will provide the MonadError and will already do the right thing. \n",
        "createdAt" : "2016-05-13T21:19:16Z",
        "updatedAt" : "2016-07-22T13:39:44Z",
        "lastEditedBy" : "f75a02fd-6511-4437-8cc0-9d87743d5ec7",
        "tags" : [
        ]
      }
    ],
    "commit" : "172cf6214d9627febce40ab31c1bd0ba97a863fd",
    "line" : 43,
    "diffHunk" : "@@ -1,1 +257,261 @@\n  def handleErrorWith[A](fa: WriterT[F, L, A])(f: E => WriterT[F, L, A]): WriterT[F, L, A] =\n    WriterT(F0.handleErrorWith(fa.run)(e => f(e).run))\n}\n"
  }
]
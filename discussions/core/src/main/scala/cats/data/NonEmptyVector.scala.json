[
  {
    "id" : "811937e6-5806-4318-87b5-9fed167e2604",
    "prId" : 1885,
    "prUrl" : "https://github.com/typelevel/cats/pull/1885#pullrequestreview-60230894",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "40790852-0307-4616-a18a-bf5554b117ab",
        "parentId" : null,
        "authorId" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "body" : "I think this will be maybe faster if we do:\r\n```scala\r\ntoVector.iterator.zip(b.toVector.iterator).map(f).toVector\r\n```\r\nI think the current code has to allocate a NonEmptyVector after `zipped` and then another one after `map`.\r\n\r\nBut I'm just guessing since I don't know this tuple enrichment. Can you comment as to why this is incorrect if I am wrong?",
        "createdAt" : "2017-09-01T18:22:28Z",
        "updatedAt" : "2017-09-01T18:23:53Z",
        "lastEditedBy" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "tags" : [
        ]
      },
      {
        "id" : "bc4efad5-9468-473c-b0e5-1ababc90d6c7",
        "parentId" : "40790852-0307-4616-a18a-bf5554b117ab",
        "authorId" : "240add12-1fe5-499a-918c-053b1f46b348",
        "body" : "Yes of course! I'm on my phone right now, but if you look at the source for zipped https://github.com/scala/scala/tree/v2.12.3/src/library/scala/runtime/Tuple2Zipped.scala#L1 you'll see that it does not actually iterate over either of the vectors until you call map or any of the other methods :) ",
        "createdAt" : "2017-09-01T19:18:38Z",
        "updatedAt" : "2017-09-01T19:18:38Z",
        "lastEditedBy" : "240add12-1fe5-499a-918c-053b1f46b348",
        "tags" : [
        ]
      },
      {
        "id" : "877d08ca-11f0-4c80-b7a0-0daa6cecedf6",
        "parentId" : "40790852-0307-4616-a18a-bf5554b117ab",
        "authorId" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "body" : "ahh nice.",
        "createdAt" : "2017-09-01T20:07:21Z",
        "updatedAt" : "2017-09-01T20:07:21Z",
        "lastEditedBy" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "tags" : [
        ]
      }
    ],
    "commit" : "5abdb482d82ea97c0e3220d6ab8b4c9868db5c98",
    "line" : 17,
    "diffHunk" : "@@ -1,1 +198,202 @@    */\n  def zipWith[B, C](b: NonEmptyVector[B])(f: (A, B) => C): NonEmptyVector[C] =\n    NonEmptyVector.fromVectorUnsafe((toVector, b.toVector).zipped.map(f))\n}\n"
  },
  {
    "id" : "109b1c3d-5c67-42c8-90fa-dff482438447",
    "prId" : 1838,
    "prUrl" : "https://github.com/typelevel/cats/pull/1838#pullrequestreview-58184757",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "11ad0bd5-3069-4a4a-ba29-ba04d8b2b1ec",
        "parentId" : null,
        "authorId" : "98bd6ddf-86cb-413a-a672-ee7d989ba290",
        "body" : "You could use this to override `Traverse#zipWithIndex` for `NonEmptyVector`.",
        "createdAt" : "2017-08-23T08:08:19Z",
        "updatedAt" : "2017-10-17T19:06:53Z",
        "lastEditedBy" : "98bd6ddf-86cb-413a-a672-ee7d989ba290",
        "tags" : [
        ]
      },
      {
        "id" : "a624ccf8-7599-4bb4-81d3-fcd1de1eb71b",
        "parentId" : "11ad0bd5-3069-4a4a-ba29-ba04d8b2b1ec",
        "authorId" : "d4c926be-8eed-42c7-9c7c-0ff0bf086280",
        "body" : "Done.",
        "createdAt" : "2017-08-23T19:09:37Z",
        "updatedAt" : "2017-10-17T19:06:53Z",
        "lastEditedBy" : "d4c926be-8eed-42c7-9c7c-0ff0bf086280",
        "tags" : [
        ]
      }
    ],
    "commit" : "f18b06ff4de48034f0facae6156a2436ca7a9c92",
    "line" : 28,
    "diffHunk" : "@@ -1,1 +209,213 @@    new NonEmptyVector(toVector.reverse)\n\n  def zipWithIndex: NonEmptyVector[(A, Int)] =\n    new NonEmptyVector(toVector.zipWithIndex)\n"
  },
  {
    "id" : "ba9520ad-dc20-4c6f-812c-268150eb183f",
    "prId" : 1838,
    "prUrl" : "https://github.com/typelevel/cats/pull/1838#pullrequestreview-60292849",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "130611c2-ce6d-4ed2-8234-78c6aa76960d",
        "parentId" : null,
        "authorId" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "body" : "this is untested, so I guess that means zipWithIndex is currently lawless.",
        "createdAt" : "2017-09-01T18:27:37Z",
        "updatedAt" : "2017-10-17T19:06:53Z",
        "lastEditedBy" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "tags" : [
        ]
      },
      {
        "id" : "82877273-082e-4626-b697-8291a5a93f18",
        "parentId" : "130611c2-ce6d-4ed2-8234-78c6aa76960d",
        "authorId" : "240add12-1fe5-499a-918c-053b1f46b348",
        "body" : "We could write a test to check if `zipWithIndex` is consistent with `zipWith(Range(0, size))` :)",
        "createdAt" : "2017-09-03T10:24:35Z",
        "updatedAt" : "2017-10-17T19:06:53Z",
        "lastEditedBy" : "240add12-1fe5-499a-918c-053b1f46b348",
        "tags" : [
        ]
      }
    ],
    "commit" : "f18b06ff4de48034f0facae6156a2436ca7a9c92",
    "line" : 44,
    "diffHunk" : "@@ -1,1 +271,275 @@\n      override def zipWithIndex[A](fa: NonEmptyVector[A]): NonEmptyVector[(A, Int)] =\n        fa.zipWithIndex\n\n      override def foldLeft[A, B](fa: NonEmptyVector[A], b: B)(f: (B, A) => B): B ="
  },
  {
    "id" : "f4ecbbcb-1c1c-4ad2-827e-70524c1f71c4",
    "prId" : 1532,
    "prUrl" : "https://github.com/typelevel/cats/pull/1532#pullrequestreview-19864922",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c440daa9-4214-4c78-acb4-b36c6725c9d4",
        "parentId" : null,
        "authorId" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "body" : "code path is untested.",
        "createdAt" : "2017-02-02T19:09:00Z",
        "updatedAt" : "2017-02-03T09:46:59Z",
        "lastEditedBy" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "tags" : [
        ]
      }
    ],
    "commit" : "96c62466b4e161c284fe8fba775d19a25a648bc0",
    "line" : 16,
    "diffHunk" : "@@ -1,1 +255,259 @@\n      override def foldM[G[_], A, B](fa: NonEmptyVector[A], z: B)(f: (B, A) => G[B])(implicit G: Monad[G]): G[B] =\n        Foldable.iteratorFoldM(fa.toVector.toIterator, z)(f)\n\n      override def find[A](fa: NonEmptyVector[A])(f: A => Boolean): Option[A] ="
  },
  {
    "id" : "52514b79-4643-4470-a65f-46570ab35ee1",
    "prId" : 1265,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2923beb7-5a60-4e6f-a02c-5ad49cf381ce",
        "parentId" : null,
        "authorId" : "b714495a-5740-47d4-aaaa-98f354f5c0a7",
        "body" : "Is there a foreseeable use-case where having the static return type as `Some` instead of `Option` will cause inference (or similar) issues?\n",
        "createdAt" : "2016-08-04T18:36:04Z",
        "updatedAt" : "2016-08-04T18:36:04Z",
        "lastEditedBy" : "b714495a-5740-47d4-aaaa-98f354f5c0a7",
        "tags" : [
        ]
      },
      {
        "id" : "b833ef5e-6ce8-4781-be35-40a8cf358551",
        "parentId" : "2923beb7-5a60-4e6f-a02c-5ad49cf381ce",
        "authorId" : "6943dbfe-856b-4f1b-bd04-dca0091e8291",
        "body" : "@ceedubs There's some reason to prefer `Some` as the return type for extractors that can't fail—the compiler actually uses that information in some way, but I can't remember the details. I'll try to look up a reference…\n",
        "createdAt" : "2016-08-04T18:39:02Z",
        "updatedAt" : "2016-08-04T18:39:02Z",
        "lastEditedBy" : "6943dbfe-856b-4f1b-bd04-dca0091e8291",
        "tags" : [
        ]
      },
      {
        "id" : "a8be7e99-2179-4ebe-8648-436681d248e6",
        "parentId" : "2923beb7-5a60-4e6f-a02c-5ad49cf381ce",
        "authorId" : "9ef0156b-afd7-4f35-80a6-bb89d6331b7c",
        "body" : "The compiler can check for exhaustiveness if it returns `Some`. It can't when it returns `Option`.\n",
        "createdAt" : "2016-08-04T18:52:51Z",
        "updatedAt" : "2016-08-04T18:52:51Z",
        "lastEditedBy" : "9ef0156b-afd7-4f35-80a6-bb89d6331b7c",
        "tags" : [
        ]
      },
      {
        "id" : "7603d10d-ccd7-424f-aea4-f6e01ac0314a",
        "parentId" : "2923beb7-5a60-4e6f-a02c-5ad49cf381ce",
        "authorId" : "e146bf5a-b942-458a-855d-3cc0cf3de9bb",
        "body" : "@larsrh Got a code snippet showing that?\n\nAFAIK Some can't check exhaustiveness any more than Option as it's not sealed (sealedness isn't transitive nor does final imply sealed, double sadly).\n",
        "createdAt" : "2016-08-04T19:31:20Z",
        "updatedAt" : "2016-08-04T19:31:35Z",
        "lastEditedBy" : "e146bf5a-b942-458a-855d-3cc0cf3de9bb",
        "tags" : [
        ]
      },
      {
        "id" : "aeb8cf25-075a-4454-bcb6-6f1859f30e95",
        "parentId" : "2923beb7-5a60-4e6f-a02c-5ad49cf381ce",
        "authorId" : "9ef0156b-afd7-4f35-80a6-bb89d6331b7c",
        "body" : "``` scala\nscala> object MyCons1 { def unapply[A](xs: scala.collection.immutable.::[A]): Some[(A, List[A])] = Some(xs.head, xs.tail) }\ndefined object MyCons1\n\nscala> object MyCons2 { def unapply[A](xs: scala.collection.immutable.::[A]): Option[(A, List[A])] = Some(xs.head, xs.tail) }\ndefined object MyCons2\n\nscala> def x = List(1, 2) match { case MyCons1(_, _) => }\n<console>:12: warning: match may not be exhaustive.\nIt would fail on the following input: Nil\n       def x = List(1, 2) match { case MyCons1(_, _) => }\n                   ^\nx: Unit\n\nscala> def x = List(1, 2) match { case MyCons2(_, _) => }\nx: Unit\n```\n",
        "createdAt" : "2016-08-04T19:35:25Z",
        "updatedAt" : "2016-08-04T19:35:25Z",
        "lastEditedBy" : "9ef0156b-afd7-4f35-80a6-bb89d6331b7c",
        "tags" : [
        ]
      },
      {
        "id" : "f45cae19-14cc-4108-8ee3-ffea8100b38a",
        "parentId" : "2923beb7-5a60-4e6f-a02c-5ad49cf381ce",
        "authorId" : "9ef0156b-afd7-4f35-80a6-bb89d6331b7c",
        "body" : "AFAICT it's unspecced behaviour, but I think it makes a lot of sense for the pattern matcher to behave that way.\n",
        "createdAt" : "2016-08-04T19:37:51Z",
        "updatedAt" : "2016-08-04T19:37:51Z",
        "lastEditedBy" : "9ef0156b-afd7-4f35-80a6-bb89d6331b7c",
        "tags" : [
        ]
      },
      {
        "id" : "918e63b4-3234-4c39-9e00-08b6f9164f68",
        "parentId" : "2923beb7-5a60-4e6f-a02c-5ad49cf381ce",
        "authorId" : "b714495a-5740-47d4-aaaa-98f354f5c0a7",
        "body" : "Oh neat. Thanks, @larsrh!\n",
        "createdAt" : "2016-08-04T19:40:20Z",
        "updatedAt" : "2016-08-04T19:40:20Z",
        "lastEditedBy" : "b714495a-5740-47d4-aaaa-98f354f5c0a7",
        "tags" : [
        ]
      }
    ],
    "commit" : "e7c093fb8710fbe08b50b4ba0841cec5ad940b5e",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +224,228 @@  }\n\n  def unapply[A](nev: NonEmptyVector[A]): Some[(A, Vector[A])] = Some((nev.head, nev.tail))\n\n  def fromVector[A](vector: Vector[A]): Option[NonEmptyVector[A]] ="
  },
  {
    "id" : "9e077c24-a1ac-43be-9dae-dcf29f87204e",
    "prId" : 1212,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3a9132ae-8046-49fd-89a5-12d104943fd0",
        "parentId" : null,
        "authorId" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "body" : "I'm a bit nervous about `isDefinedAt` I'm afraid this could be coming from `Function` and not be specialized well for vector. What about:\n\n``` scala\n@inline\nprivate def inBounds(i: Int): Boolean = 0 <= i && i <= toVector.size\n```\n\nAnd use it here and on `get`?\n",
        "createdAt" : "2016-07-27T17:27:27Z",
        "updatedAt" : "2016-07-27T17:27:27Z",
        "lastEditedBy" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "tags" : [
        ]
      },
      {
        "id" : "0642aeee-f63d-448d-b541-eba772906e39",
        "parentId" : "3a9132ae-8046-49fd-89a5-12d104943fd0",
        "authorId" : "507becc8-343f-49eb-9c0b-58304a1630c2",
        "body" : "Yea we could do that. For reference `Vector` inherits `isDefinedAt` from `GenSeqLike` - https://github.com/scala/scala/blob/v2.11.8/src/library/scala/collection/GenSeqLike.scala#L64-L72\n\nDefinition is pretty much the same, with the exception that a local implementation can be private and inlined.\n",
        "createdAt" : "2016-07-28T07:13:40Z",
        "updatedAt" : "2016-07-28T07:13:40Z",
        "lastEditedBy" : "507becc8-343f-49eb-9c0b-58304a1630c2",
        "tags" : [
        ]
      },
      {
        "id" : "c05adf20-0df7-4082-9c17-841e74b9c5ce",
        "parentId" : "3a9132ae-8046-49fd-89a5-12d104943fd0",
        "authorId" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "body" : "Okay, this is fine then. (Lacking an IDE, finding such definitions is really painful for me in the insane collections hierarchy).\n",
        "createdAt" : "2016-07-28T19:06:44Z",
        "updatedAt" : "2016-07-28T19:06:44Z",
        "lastEditedBy" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "tags" : [
        ]
      }
    ],
    "commit" : "a5dbc18bbe04fcab8d2738fb17907c5c5cc0b00b",
    "line" : 21,
    "diffHunk" : "@@ -1,1 +24,28 @@  /** Updates the element at the index, if it exists */\n  def updated(i: Int, a: A): Option[NonEmptyVector[A]] =\n    if (toVector.isDefinedAt(i)) Some(new NonEmptyVector(toVector.updated(i, a))) else None\n\n  /**"
  },
  {
    "id" : "d876b104-d221-42a6-9185-f014c48c08dd",
    "prId" : 1212,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "88803033-88c0-4214-8522-fc0b553a2d32",
        "parentId" : null,
        "authorId" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "body" : "any reason not to do `= concat(other.toVector)`\n",
        "createdAt" : "2016-07-27T17:29:12Z",
        "updatedAt" : "2016-07-27T17:29:12Z",
        "lastEditedBy" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "tags" : [
        ]
      },
      {
        "id" : "0a547f6d-ee41-42b0-9665-07c67af75c00",
        "parentId" : "88803033-88c0-4214-8522-fc0b553a2d32",
        "authorId" : "507becc8-343f-49eb-9c0b-58304a1630c2",
        "body" : "No reason I can think of. I wouldn't have a huge preference either way because they are functionally equivalent.\n",
        "createdAt" : "2016-07-28T07:16:43Z",
        "updatedAt" : "2016-07-28T07:16:44Z",
        "lastEditedBy" : "507becc8-343f-49eb-9c0b-58304a1630c2",
        "tags" : [
        ]
      }
    ],
    "commit" : "a5dbc18bbe04fcab8d2738fb17907c5c5cc0b00b",
    "line" : 60,
    "diffHunk" : "@@ -1,1 +55,59 @@   * Append another `NonEmptyVector` to this, producing a new `NonEmptyVector`.\n   */\n  def concatNEV(other: NonEmptyVector[A]): NonEmptyVector[A] = new NonEmptyVector(toVector ++ other.toVector)\n\n  /**"
  },
  {
    "id" : "ec92ff2e-f753-43b1-ad7c-e3d5287b8c15",
    "prId" : 1203,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4946d370-71f6-4f35-aca5-4ad4c7bb274c",
        "parentId" : null,
        "authorId" : "6b760ef7-e448-44a7-b744-0c25c840a80a",
        "body" : "Good catch there.\n",
        "createdAt" : "2016-07-15T15:22:30Z",
        "updatedAt" : "2016-07-15T22:30:09Z",
        "lastEditedBy" : "6b760ef7-e448-44a7-b744-0c25c840a80a",
        "tags" : [
        ]
      }
    ],
    "commit" : "ed88a6dd13fc5cfe7c01a2a3cfc3992b0cce815d",
    "line" : 50,
    "diffHunk" : "@@ -1,1 +144,148 @@      override def split[A](fa: NonEmptyVector[A]): (A, Vector[A]) = (fa.head, fa.tail)\n\n      override def size[A](fa: NonEmptyVector[A]): Long = fa.length.toLong\n\n      override def reduceLeft[A](fa: NonEmptyVector[A])(f: (A, A) => A): A ="
  },
  {
    "id" : "7a587bf8-d4f2-456f-ae61-4114f3e32b30",
    "prId" : 1137,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f76ef246-38b2-450f-86a4-6d5418e345f0",
        "parentId" : null,
        "authorId" : "ce96b419-753f-4ea1-afb3-3adc3b30fcc7",
        "body" : "Is this show correct?  \nOr should I have `s\"NonEmptyVector(${Show[Vector[A]].show(vector)})\"` instead?\n",
        "createdAt" : "2016-06-17T22:53:25Z",
        "updatedAt" : "2016-07-08T15:05:15Z",
        "lastEditedBy" : "ce96b419-753f-4ea1-afb3-3adc3b30fcc7",
        "tags" : [
        ]
      },
      {
        "id" : "586d4889-286a-41f5-9296-3310d08fe3ce",
        "parentId" : "f76ef246-38b2-450f-86a4-6d5418e345f0",
        "authorId" : "6b760ef7-e448-44a7-b744-0c25c840a80a",
        "body" : "I think it's better than the `cons` like show. \n",
        "createdAt" : "2016-06-17T23:24:52Z",
        "updatedAt" : "2016-07-08T15:05:15Z",
        "lastEditedBy" : "6b760ef7-e448-44a7-b744-0c25c840a80a",
        "tags" : [
        ]
      }
    ],
    "commit" : "e173928c4e25a4479033c1692737919e0a542906",
    "line" : null,
    "diffHunk" : "@@ -1,1 +125,129 @@  def show(implicit A: Show[A]): String =\n    s\"NonEmptyVector(${Show[Vector[A]].show(toVector)})\"\n}\n\nprivate[data] sealed trait NonEmptyVectorInstances {"
  },
  {
    "id" : "0621aedb-bec8-4799-ad6c-24c81352ab60",
    "prId" : 1137,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "73fa9418-b294-47cd-b37b-8e849359b1f8",
        "parentId" : null,
        "authorId" : "89a3e0e3-e301-4aa8-b150-74070eb5a619",
        "body" : "I feel like it's worth supporting `apply` and `updated` for this structure, since indexed access is one of the best reasons to want to be using a vector. I'd probably use the standard signatures but I could be persuaded to have them return `Option[A]` and `Option[Unit]` respectively.\n",
        "createdAt" : "2016-06-18T03:52:40Z",
        "updatedAt" : "2016-07-08T15:05:15Z",
        "lastEditedBy" : "89a3e0e3-e301-4aa8-b150-74070eb5a619",
        "tags" : [
        ]
      },
      {
        "id" : "7392b6bf-81c4-46db-9450-6fa7def88daa",
        "parentId" : "73fa9418-b294-47cd-b37b-8e849359b1f8",
        "authorId" : "4aafd631-794d-4704-aeda-a6c56ce667d1",
        "body" : "Or both? :-) But agree on wanting indexed access.\n",
        "createdAt" : "2016-06-18T06:31:05Z",
        "updatedAt" : "2016-07-08T15:05:15Z",
        "lastEditedBy" : "4aafd631-794d-4704-aeda-a6c56ce667d1",
        "tags" : [
        ]
      },
      {
        "id" : "3cb1dd88-e6a1-4a24-8ab3-22a4423fc57c",
        "parentId" : "73fa9418-b294-47cd-b37b-8e849359b1f8",
        "authorId" : "b714495a-5740-47d4-aaaa-98f354f5c0a7",
        "body" : "@non you mean `Option[NonEmptyVector[A]]` for `updated` right? :)\n\nI'd be in favor of `updated` that returned an `Option` and `updatedUnsafe` that had the behavior of the the std lib (throwing an exception if the index doesn't exists). Similarly for accessing an index, but the name may be a little awkward there if we use `apply`. Maybe `atIndex`/`atIndexUnsafe` or `at` or `elem` or something?\n",
        "createdAt" : "2016-06-18T12:39:54Z",
        "updatedAt" : "2016-07-08T15:05:15Z",
        "lastEditedBy" : "b714495a-5740-47d4-aaaa-98f354f5c0a7",
        "tags" : [
        ]
      },
      {
        "id" : "c2fd904c-bd6f-4e54-8a17-e3d27d01f6a0",
        "parentId" : "73fa9418-b294-47cd-b37b-8e849359b1f8",
        "authorId" : "89a3e0e3-e301-4aa8-b150-74070eb5a619",
        "body" : "Yes! Sorry, in my defense it was late! ;)\n",
        "createdAt" : "2016-06-18T14:19:23Z",
        "updatedAt" : "2016-07-08T15:05:15Z",
        "lastEditedBy" : "89a3e0e3-e301-4aa8-b150-74070eb5a619",
        "tags" : [
        ]
      },
      {
        "id" : "cb95dd15-bd12-4fff-af6a-972fb13130fa",
        "parentId" : "73fa9418-b294-47cd-b37b-8e849359b1f8",
        "authorId" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "body" : "why not have:\n\n``` scala\ndef get(i: Int): Option[A]\n// This is unsafe, it may throw on out-of-bounds, see `get` for a safe variant.\ndef apply(i: Int): A\n```\n\nfor updated I would like:\n\n``` scala\ndef updatedOption(i: Int, a: A): Option[NonEmptyVector[A]]\n// this will throw is i is out of bounds.\ndef updated(i: Int, a: A): NonEmptyVector[A]\n```\n\nI feel like adding `Option` as a suffix signals (like `headOption`, `reduceOption` is pretty standard), and I think the unsafe methods should keep the same name (lest we train people that this method is safe in some contexts but not others. Reading the code you have to know exactly if it is NonEmptyVector or Vector to see if `apply` or `updated` is safe, I'd rather always make them unsafe so we are consistent).\n",
        "createdAt" : "2016-06-18T20:56:05Z",
        "updatedAt" : "2016-07-08T15:05:15Z",
        "lastEditedBy" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "tags" : [
        ]
      },
      {
        "id" : "e311da53-4a92-4789-9d62-a84e6469760c",
        "parentId" : "73fa9418-b294-47cd-b37b-8e849359b1f8",
        "authorId" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "body" : "alternatively, since `toVector` is free, we could have only `get` and require `ne.toVector(12)` for unsafe apply.\n",
        "createdAt" : "2016-06-18T20:58:34Z",
        "updatedAt" : "2016-07-08T15:05:15Z",
        "lastEditedBy" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "tags" : [
        ]
      },
      {
        "id" : "752ed681-263b-4bf7-8033-f90f29e6d35b",
        "parentId" : "73fa9418-b294-47cd-b37b-8e849359b1f8",
        "authorId" : "b714495a-5740-47d4-aaaa-98f354f5c0a7",
        "body" : "This is tough. I think that `updated` and `apply` have names that seem too benign for throwing exceptions in common cases. It's nice to be consistent with the standard library, but I also have seen lots of scala devs mess up with `head` and `reduce` when I don't think they would have if these had been the safe options and separate `headUnsafe` and `reduceUnsafe` options had existed. I'm hesitant to pull in gotchas just to have consistent naming with the standard library. Hmmm.\n",
        "createdAt" : "2016-06-19T12:49:12Z",
        "updatedAt" : "2016-07-08T15:05:15Z",
        "lastEditedBy" : "b714495a-5740-47d4-aaaa-98f354f5c0a7",
        "tags" : [
        ]
      },
      {
        "id" : "1377e384-1d24-4622-9ca5-db66da10aba1",
        "parentId" : "73fa9418-b294-47cd-b37b-8e849359b1f8",
        "authorId" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "body" : "I can see your point on safety, but there is also a cost (especially to reviewers of future code) of using names that are unsafe on Vector to be safe here (if they change the type signature).\n\nMy bias is using `cats` in a large codebase with many novices that mostly work with the standard library. I'd rather avoid confusion in naming (not at the cost of safety though). So, I would say `updateOption` and maybe `updateUnsafe` would be the best solution.\n\nMaybe I would say: when we can safely follow standard naming conventions, we should. Otherwise, if we want to add methods that can throw, use `Unsafe` as a suffix (or prefix).\n\n`head` has the same type signature, so I am not worried about it. Changing `updated` to be optional seems like it will create reading difficulties, so I prefer a new name for a safe variant.\n",
        "createdAt" : "2016-06-19T20:22:27Z",
        "updatedAt" : "2016-07-08T15:05:15Z",
        "lastEditedBy" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "tags" : [
        ]
      },
      {
        "id" : "48a0fc34-515d-4406-a44f-0f584b032a1c",
        "parentId" : "73fa9418-b294-47cd-b37b-8e849359b1f8",
        "authorId" : "b714495a-5740-47d4-aaaa-98f354f5c0a7",
        "body" : "@johnynek everything that you said sounds good to me. So it sounds like it'll be `updateOption` and `updateUnsafe` for the update methods. And maybe `get` and `getUnsafe` for index access? Or it could be `getOption` to be symmetric if you'd prefer. Either one is fine with me.\n",
        "createdAt" : "2016-06-19T23:52:49Z",
        "updatedAt" : "2016-07-08T15:05:15Z",
        "lastEditedBy" : "b714495a-5740-47d4-aaaa-98f354f5c0a7",
        "tags" : [
        ]
      }
    ],
    "commit" : "e173928c4e25a4479033c1692737919e0a542906",
    "line" : null,
    "diffHunk" : "@@ -1,1 +29,33 @@\n  def tail: Vector[A] = toVector.tail\n\n  /**\n   * remove elements not matching the predicate"
  },
  {
    "id" : "8bd0640d-3d3e-4603-8a49-3bb595bda09d",
    "prId" : 1137,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2bcc9efe-9d3f-4741-a838-216a256220b1",
        "parentId" : null,
        "authorId" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "body" : "what about `reduce`? Since, we know that this is non-empty the `reduce(fn: (A, A) => A): A` is a safe signature. That or we could have: `def combineAll(implicit: sg: Semigroup[T]): T` (or we could have both).\n",
        "createdAt" : "2016-06-18T20:46:01Z",
        "updatedAt" : "2016-07-08T15:05:15Z",
        "lastEditedBy" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "tags" : [
        ]
      },
      {
        "id" : "d319aa35-79b0-48ba-89bb-9630411aef70",
        "parentId" : "2bcc9efe-9d3f-4741-a838-216a256220b1",
        "authorId" : "b714495a-5740-47d4-aaaa-98f354f5c0a7",
        "body" : "`reduce` and several other methods are available via the `Reducible` instance, but I agree that it would probably be nice to have some of these helpers on the class itself.\n",
        "createdAt" : "2016-06-19T12:50:46Z",
        "updatedAt" : "2016-07-08T15:05:15Z",
        "lastEditedBy" : "b714495a-5740-47d4-aaaa-98f354f5c0a7",
        "tags" : [
        ]
      },
      {
        "id" : "a4d5690a-01b4-46be-9ee1-1087845a2669",
        "parentId" : "2bcc9efe-9d3f-4741-a838-216a256220b1",
        "authorId" : "ce96b419-753f-4ea1-afb3-3adc3b30fcc7",
        "body" : "I think they should be called `reduceLeft(f: (A, A) => A): A` and `reduce(implicit S: Semigroup[A]): A` to be consistent with `cats.Reducible`.  AFAK, the standard library has similar names.\n",
        "createdAt" : "2016-06-27T12:21:48Z",
        "updatedAt" : "2016-07-08T15:05:15Z",
        "lastEditedBy" : "ce96b419-753f-4ea1-afb3-3adc3b30fcc7",
        "tags" : [
        ]
      }
    ],
    "commit" : "e173928c4e25a4479033c1692737919e0a542906",
    "line" : null,
    "diffHunk" : "@@ -1,1 +105,109 @@  def reduce(implicit S: Semigroup[A]): A =\n    S.combineAllOption(toVector).get\n\n  /**\n   * Typesafe equality operator."
  },
  {
    "id" : "b0e5af22-2eef-4008-b53d-d0c01e9c5525",
    "prId" : 1137,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7080f99e-1fd3-4297-9345-3b6546181e34",
        "parentId" : null,
        "authorId" : "b714495a-5740-47d4-aaaa-98f354f5c0a7",
        "body" : "Minor: since `MonadRec` extends `Monad`, you can replace the `with Monad[NonEmptyVector]` in the two places it shows up here.\n",
        "createdAt" : "2016-07-01T10:48:06Z",
        "updatedAt" : "2016-07-08T15:05:15Z",
        "lastEditedBy" : "b714495a-5740-47d4-aaaa-98f354f5c0a7",
        "tags" : [
        ]
      }
    ],
    "commit" : "e173928c4e25a4479033c1692737919e0a542906",
    "line" : null,
    "diffHunk" : "@@ -1,1 +132,136 @@      with Comonad[NonEmptyVector] with Traverse[NonEmptyVector] with MonadRec[NonEmptyVector] =\n    new NonEmptyReducible[NonEmptyVector, Vector] with SemigroupK[NonEmptyVector]\n        with Comonad[NonEmptyVector] with Traverse[NonEmptyVector] with MonadRec[NonEmptyVector] {\n\n      def combineK[A](a: NonEmptyVector[A], b: NonEmptyVector[A]): NonEmptyVector[A] ="
  },
  {
    "id" : "f2049d14-8e2b-4591-8553-53ffff3fe23c",
    "prId" : 1137,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6d877b7a-fef6-4543-92af-702b33c36de2",
        "parentId" : null,
        "authorId" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "body" : "we could add `def zip[B](that: NonEmptyVector[B]): NonEmpty[(A, B)]` which could be nice.\n",
        "createdAt" : "2016-07-01T18:14:55Z",
        "updatedAt" : "2016-07-08T15:05:15Z",
        "lastEditedBy" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "tags" : [
        ]
      }
    ],
    "commit" : "e173928c4e25a4479033c1692737919e0a542906",
    "line" : null,
    "diffHunk" : "@@ -1,1 +105,109 @@  def reduce(implicit S: Semigroup[A]): A =\n    S.combineAllOption(toVector).get\n\n  /**\n   * Typesafe equality operator."
  },
  {
    "id" : "0d060925-ce6f-44f8-bfbc-7964cda1de47",
    "prId" : 1137,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a758f606-bf3c-441d-9fc8-f4fdb7f9d8a4",
        "parentId" : null,
        "authorId" : "98bd6ddf-86cb-413a-a672-ee7d989ba290",
        "body" : "I think this will give us something like `NonEmptyVector(Vector(1, 2, 3))` for `NonEmptyVector(1, 2, 3)`.\nMaybe we could do `\"NonEmpty\" + Show[Vector[A]].show(toVector)` which should give us `NonEmptyVector(1,2,3)` ?\n",
        "createdAt" : "2016-07-11T18:09:32Z",
        "updatedAt" : "2016-07-11T18:09:32Z",
        "lastEditedBy" : "98bd6ddf-86cb-413a-a672-ee7d989ba290",
        "tags" : [
        ]
      }
    ],
    "commit" : "e173928c4e25a4479033c1692737919e0a542906",
    "line" : 126,
    "diffHunk" : "@@ -1,1 +124,128 @@   */\n  def show(implicit A: Show[A]): String =\n    s\"NonEmptyVector(${Show[Vector[A]].show(toVector)})\"\n}\n"
  },
  {
    "id" : "8b43d6fc-32e0-4d14-9123-573317197ba3",
    "prId" : 1137,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "cc7da47a-cf4f-403f-8c35-dafb66280c87",
        "parentId" : null,
        "authorId" : "98bd6ddf-86cb-413a-a672-ee7d989ba290",
        "body" : "Slightly nitpicking but the 2 spaces for indentation seem to be missing.\n",
        "createdAt" : "2016-07-11T18:12:58Z",
        "updatedAt" : "2016-07-11T18:12:58Z",
        "lastEditedBy" : "98bd6ddf-86cb-413a-a672-ee7d989ba290",
        "tags" : [
        ]
      }
    ],
    "commit" : "e173928c4e25a4479033c1692737919e0a542906",
    "line" : 170,
    "diffHunk" : "@@ -1,1 +168,172 @@\n      def traverse[G[_], A, B](fa: NonEmptyVector[A])(f: (A) => G[B])(implicit G: Applicative[G]): G[NonEmptyVector[B]] =\n      G.map2Eval(f(fa.head), Always(Traverse[Vector].traverse(fa.tail)(f)))(NonEmptyVector(_, _)).value\n\n"
  },
  {
    "id" : "63e119f8-9779-412b-ab74-6c04e9cc6293",
    "prId" : 1137,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5ee7d699-b7da-46e1-aaa2-c6da03e76f97",
        "parentId" : null,
        "authorId" : "98bd6ddf-86cb-413a-a672-ee7d989ba290",
        "body" : "Again some minor nitpicking about formatting, but both the `++` methods ScalaDoc's can be changed to \n\n``` scala\n/**\n * Alias for concat\n */\n```\n",
        "createdAt" : "2016-07-11T18:24:26Z",
        "updatedAt" : "2016-07-11T18:24:26Z",
        "lastEditedBy" : "98bd6ddf-86cb-413a-a672-ee7d989ba290",
        "tags" : [
        ]
      }
    ],
    "commit" : "e173928c4e25a4479033c1692737919e0a542906",
    "line" : 55,
    "diffHunk" : "@@ -1,1 +53,57 @@    * Alias for concat\n    */\n  def ++(other: Vector[A]): NonEmptyVector[A] = concat(other)\n\n  /**"
  },
  {
    "id" : "a2828efb-f919-4e31-ab56-571da1351223",
    "prId" : 1137,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fde982b8-499a-4239-98d8-9990c9b35bb3",
        "parentId" : null,
        "authorId" : "98bd6ddf-86cb-413a-a672-ee7d989ba290",
        "body" : "Small typo: exeption -> exception.\n",
        "createdAt" : "2016-07-11T18:34:22Z",
        "updatedAt" : "2016-07-11T18:34:22Z",
        "lastEditedBy" : "98bd6ddf-86cb-413a-a672-ee7d989ba290",
        "tags" : [
        ]
      }
    ],
    "commit" : "e173928c4e25a4479033c1692737919e0a542906",
    "line" : 24,
    "diffHunk" : "@@ -1,1 +22,26 @@    if (toVector.isDefinedAt(i)) Some(NonEmptyVector(toVector.updated(i, a))) else None\n\n  /** Updates the element at the index, or throws an exeption if none exists */\n  def updatedUnsafe(i: Int, a: A):\n      NonEmptyVector[A] = NonEmptyVector(toVector.updated(i, a))"
  },
  {
    "id" : "fee353c7-0675-4384-ab37-4ed08212b37b",
    "prId" : 1137,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "210864f5-5281-414d-b6e2-a457a93e3df7",
        "parentId" : null,
        "authorId" : "b714495a-5740-47d4-aaaa-98f354f5c0a7",
        "body" : "Would be nice to make this `Alias for [[concat]]` so that the scaladoc has a link.\n",
        "createdAt" : "2016-07-13T11:39:28Z",
        "updatedAt" : "2016-07-13T11:39:28Z",
        "lastEditedBy" : "b714495a-5740-47d4-aaaa-98f354f5c0a7",
        "tags" : [
        ]
      },
      {
        "id" : "29a7e25c-ca7c-4f09-b777-e8051748fab5",
        "parentId" : "210864f5-5281-414d-b6e2-a457a93e3df7",
        "authorId" : "b714495a-5740-47d4-aaaa-98f354f5c0a7",
        "body" : "Oh I see that we are using overloading, so I don't know how that works with scaladoc. I'm generally skeptical of overloading, though it's probably fine in this instance. I think it would prevent us from being able to turn `NonEmptyVector` into a value class though, wouldn't it?\n",
        "createdAt" : "2016-07-13T11:41:03Z",
        "updatedAt" : "2016-07-13T11:41:03Z",
        "lastEditedBy" : "b714495a-5740-47d4-aaaa-98f354f5c0a7",
        "tags" : [
        ]
      }
    ],
    "commit" : "e173928c4e25a4479033c1692737919e0a542906",
    "line" : 43,
    "diffHunk" : "@@ -1,1 +41,45 @@\n  /**\n    * Alias for concat\n    */\n  def ++(other: NonEmptyVector[A]): NonEmptyVector[A] = concat(other)"
  }
]
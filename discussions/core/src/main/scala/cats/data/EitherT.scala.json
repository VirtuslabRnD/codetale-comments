[
  {
    "id" : "1689d3ed-c2a8-4877-b32f-b5b03d1c3778",
    "prId" : 3374,
    "prUrl" : "https://github.com/typelevel/cats/pull/3374#pullrequestreview-384803776",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "30ba7d53-1324-4c3d-a58a-f16cec552c16",
        "parentId" : null,
        "authorId" : "6943dbfe-856b-4f1b-bd04-dca0091e8291",
        "body" : "We've been removing the value-level kind-projector syntax for polymorphic functions, since there's no real possibility of it ever cross-building on Dotty, and since writing this out explicitly as:\r\n\r\n```scala\r\nnew (F ~> EitherT[F, E, *]) { def apply[A](fa: F[A]): EitherT[F, E, A] = EitherT(F.attempt(fa)) }\r\n```\r\n…is only marginally less readable. I don't think that needs to be changed in this PR, though, since we're not actually cross-building on Dotty yet.\r\n\r\n(Note that the type-level `λ` is fine on Dotty with `-Ykind-projector`.)",
        "createdAt" : "2020-03-31T09:46:39Z",
        "updatedAt" : "2020-03-31T09:46:59Z",
        "lastEditedBy" : "6943dbfe-856b-4f1b-bd04-dca0091e8291",
        "tags" : [
        ]
      },
      {
        "id" : "eecd37eb-a86d-4732-bd92-d2e072d2d727",
        "parentId" : "30ba7d53-1324-4c3d-a58a-f16cec552c16",
        "authorId" : "c922a9b6-a191-4a1d-b6d1-67a1b509a11b",
        "body" : "oh, I was under the impression this was also part of the `-Ykind-projector` feature. But it makes sense, I'll keep it in mind.",
        "createdAt" : "2020-03-31T14:34:59Z",
        "updatedAt" : "2020-03-31T14:34:59Z",
        "lastEditedBy" : "c922a9b6-a191-4a1d-b6d1-67a1b509a11b",
        "tags" : [
        ]
      },
      {
        "id" : "cf59c0fb-dbe5-499a-9182-d3e65d462b2c",
        "parentId" : "30ba7d53-1324-4c3d-a58a-f16cec552c16",
        "authorId" : "6943dbfe-856b-4f1b-bd04-dca0091e8291",
        "body" : "@kubukoz No, I hate kind-projector's value-level lambda syntax and couldn't be bothered to implement it in `-Ykind-projector`. :smile: (Also it would have required much more disruptive changes than anything else that made it into `-Ykind-projector`.)",
        "createdAt" : "2020-03-31T14:41:56Z",
        "updatedAt" : "2020-03-31T14:41:57Z",
        "lastEditedBy" : "6943dbfe-856b-4f1b-bd04-dca0091e8291",
        "tags" : [
        ]
      }
    ],
    "commit" : "e75a32af77ce1603aa0991e99f8f342e7eb9df8a",
    "line" : 21,
    "diffHunk" : "@@ -1,1 +760,764 @@   */\n  final def liftAttemptK[F[_], E](implicit F: ApplicativeError[F, E]): F ~> EitherT[F, E, *] =\n    λ[F ~> EitherT[F, E, *]](fa => EitherT(F.attempt(fa)))\n\n  @deprecated(\"Use EitherT.liftF.\", \"1.0.0-RC1\")"
  },
  {
    "id" : "5b6add13-eff6-4ca8-a9dc-47c46b761a08",
    "prId" : 3316,
    "prUrl" : "https://github.com/typelevel/cats/pull/3316#pullrequestreview-363613717",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "920c300d-3143-445d-807e-a92beb2bdfd8",
        "parentId" : null,
        "authorId" : "240add12-1fe5-499a-918c-053b1f46b348",
        "body" : "What do we think about using `Unit` here to signify that this resulting type is going to be discarded? Might be a bit more cumbersome on the usage side, but it's just an extra `.void`",
        "createdAt" : "2020-02-24T18:34:43Z",
        "updatedAt" : "2020-02-24T18:34:43Z",
        "lastEditedBy" : "240add12-1fe5-499a-918c-053b1f46b348",
        "tags" : [
        ]
      },
      {
        "id" : "4957bbb9-2cd8-4db6-9b22-dfe5404853d3",
        "parentId" : "920c300d-3143-445d-807e-a92beb2bdfd8",
        "authorId" : "6943dbfe-856b-4f1b-bd04-dca0091e8291",
        "body" : "We already have a `flatTap` on `FlatMap` that doesn't require `Unit`, and `tap`, `tapWith`, etc. on `Kleisli` don't constrain the output type to be `Unit`. My personal preference would be consistency—I think that plus slightly easier use outweighs a little extra expressivity in the types.",
        "createdAt" : "2020-02-24T18:43:18Z",
        "updatedAt" : "2020-02-24T18:45:16Z",
        "lastEditedBy" : "6943dbfe-856b-4f1b-bd04-dca0091e8291",
        "tags" : [
        ]
      },
      {
        "id" : "4706b7a6-6d9c-4482-856d-210bcf32e73e",
        "parentId" : "920c300d-3143-445d-807e-a92beb2bdfd8",
        "authorId" : "b2f44833-d51c-4609-890c-56698922caa5",
        "body" : "@LukaJCB I first thought about it, but then saw that `FlatMap[F].flatTap` takes `A => F[B]` instead of `A => F[Unit]`, so I wanted to be consistent with existing signature.",
        "createdAt" : "2020-02-24T18:43:22Z",
        "updatedAt" : "2020-02-24T18:43:22Z",
        "lastEditedBy" : "b2f44833-d51c-4609-890c-56698922caa5",
        "tags" : [
        ]
      }
    ],
    "commit" : "74cd7248211df8a34a16661f824b0398edfac970",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +451,455 @@    semiflatMap(b => F.as(f(b), b))\n\n  def leftSemiflatTap[C](f: A => F[C])(implicit F: Monad[F]): EitherT[F, A, B] =\n    leftSemiflatMap(a => F.as(f(a), a))\n"
  },
  {
    "id" : "15b303ce-be23-4362-be04-22aa6acbf2d3",
    "prId" : 2573,
    "prUrl" : "https://github.com/typelevel/cats/pull/2573#pullrequestreview-173684057",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1befa524-2f63-4521-8732-51cc83085d13",
        "parentId" : null,
        "authorId" : "5b5d8846-f0f9-4ffa-bc89-2b1aea0c83d3",
        "body" : "would not it be more intuitive to say `case Right(b) => fb(b).value` at L.84 to match with the type `B` fb expects?",
        "createdAt" : "2018-11-11T04:18:06Z",
        "updatedAt" : "2018-11-11T04:18:06Z",
        "lastEditedBy" : "5b5d8846-f0f9-4ffa-bc89-2b1aea0c83d3",
        "tags" : [
        ]
      }
    ],
    "commit" : "b16f5fa0279fede568eb9ab57a0dc90db2d8d194",
    "line" : 8,
    "diffHunk" : "@@ -1,1 +82,86 @@    EitherT(F.flatMap(value) {\n      case Left(a)  => fa(a).value\n      case Right(a) => fb(a).value\n    })\n"
  },
  {
    "id" : "46afa4af-da9e-4ad3-ad33-6a76b3f9bbed",
    "prId" : 1790,
    "prUrl" : "https://github.com/typelevel/cats/pull/1790#pullrequestreview-60398103",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "162a75fe-4752-4967-867f-6aab452b850e",
        "parentId" : null,
        "authorId" : "240add12-1fe5-499a-918c-053b1f46b348",
        "body" : "Tiny nitpick, but can we change this to `case r: Right => ...` since we don't actually want to extract anything?",
        "createdAt" : "2017-09-03T10:19:05Z",
        "updatedAt" : "2017-09-29T08:17:18Z",
        "lastEditedBy" : "240add12-1fe5-499a-918c-053b1f46b348",
        "tags" : [
        ]
      },
      {
        "id" : "82780606-14cd-4881-a0d5-7422c56bc245",
        "parentId" : "162a75fe-4752-4967-867f-6aab452b850e",
        "authorId" : "4aafd631-794d-4704-aeda-a6c56ce667d1",
        "body" : "While in practice I don't think it matters, the use of `:` implies type casing which is generally used in contexts where parametricity is violated: https://typelevel.org/blog/2014/11/10/why_is_adt_pattern_matching_allowed.html\r\n\r\nI could have sworn there were some cases where `:` was allowed and ADT patmat wasn't but I can't remember.",
        "createdAt" : "2017-09-04T07:45:42Z",
        "updatedAt" : "2017-09-29T08:17:18Z",
        "lastEditedBy" : "4aafd631-794d-4704-aeda-a6c56ce667d1",
        "tags" : [
        ]
      },
      {
        "id" : "3181e404-56dd-485a-870e-c5f0029ca217",
        "parentId" : "162a75fe-4752-4967-867f-6aab452b850e",
        "authorId" : "240add12-1fe5-499a-918c-053b1f46b348",
        "body" : "Very interesting article, thanks a lot! :) \r\nI always thought that scalac transforms `case t: Type` into an `isInstanceOf` check whereas `case Type(_)` would be turned into `Type.unapply(...)`, but that article shows that my assumption was false. \r\nIt seems then, there's no real benefit to my suggestion, so disregard.\r\n",
        "createdAt" : "2017-09-04T12:11:08Z",
        "updatedAt" : "2017-09-29T08:17:18Z",
        "lastEditedBy" : "240add12-1fe5-499a-918c-053b1f46b348",
        "tags" : [
        ]
      }
    ],
    "commit" : "edef90880e8d95ac9cba753f7bc0ef3d94dfd07d",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +100,104 @@    EitherT(F.flatMap(value) {\n      case Left(a) => f(a).value\n      case r@Right(_) => F.pure(r.leftCast)\n    })\n"
  },
  {
    "id" : "9dd644b1-b5cc-464a-9499-d6ee0cac38a6",
    "prId" : 1790,
    "prUrl" : "https://github.com/typelevel/cats/pull/1790#pullrequestreview-60292768",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1bb9af55-89dc-403c-b270-f8d516eea5dc",
        "parentId" : null,
        "authorId" : "240add12-1fe5-499a-918c-053b1f46b348",
        "body" : "Ditto, as above :)",
        "createdAt" : "2017-09-03T10:19:16Z",
        "updatedAt" : "2017-09-29T08:17:18Z",
        "lastEditedBy" : "240add12-1fe5-499a-918c-053b1f46b348",
        "tags" : [
        ]
      }
    ],
    "commit" : "edef90880e8d95ac9cba753f7bc0ef3d94dfd07d",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +106,110 @@    EitherT(F.flatMap(value) {\n      case Left(a) => F.map(f(a)) { d => Left(d) }\n      case r@Right(_) => F.pure(r.leftCast)\n    })\n"
  },
  {
    "id" : "e16e93f7-168c-4ac3-819c-f9f71f2e2553",
    "prId" : 1614,
    "prUrl" : "https://github.com/typelevel/cats/pull/1614#pullrequestreview-33861256",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b4a98a2b-f5a1-4ca7-9b26-1217a09e98fd",
        "parentId" : null,
        "authorId" : "b084ae12-948e-41db-b85f-097bb81e5826",
        "body" : "I am curious. Is Scalaz's trick here (add a dummy parameter to this class to make it an `AnyVal`; see [here](https://github.com/scalaz/scalaz/blob/926dd8c380bab865afed8ac1a2d9da2bde488a00/core/src/main/scala/scalaz/EitherT.scala)) necessary to make this zero-cost?",
        "createdAt" : "2017-04-20T08:43:28Z",
        "updatedAt" : "2017-04-20T15:39:45Z",
        "lastEditedBy" : "b084ae12-948e-41db-b85f-097bb81e5826",
        "tags" : [
        ]
      },
      {
        "id" : "d5f50c54-57a5-4363-a402-77cf394e6fb7",
        "parentId" : "b4a98a2b-f5a1-4ca7-9b26-1217a09e98fd",
        "authorId" : "6b760ef7-e448-44a7-b744-0c25c840a80a",
        "body" : "That seems a nice trick. Do we want to use it here first in this PR, or create another PR applying the pattern globally? ",
        "createdAt" : "2017-04-20T15:42:04Z",
        "updatedAt" : "2017-04-20T15:42:04Z",
        "lastEditedBy" : "6b760ef7-e448-44a7-b744-0c25c840a80a",
        "tags" : [
        ]
      },
      {
        "id" : "d7ef7b3c-3045-4576-8ef1-a6dcc5da50b4",
        "parentId" : "b4a98a2b-f5a1-4ca7-9b26-1217a09e98fd",
        "authorId" : "b084ae12-948e-41db-b85f-097bb81e5826",
        "body" : "I'm okay with another PR to apply it globally.",
        "createdAt" : "2017-04-20T19:13:27Z",
        "updatedAt" : "2017-04-20T19:13:27Z",
        "lastEditedBy" : "b084ae12-948e-41db-b85f-097bb81e5826",
        "tags" : [
        ]
      }
    ],
    "commit" : "5e67748a1ae286e2bad024c2a2497cec9347401f",
    "line" : 16,
    "diffHunk" : "@@ -1,1 +238,242 @@private[data] trait EitherTFunctions {\n\n  final class LeftPartiallyApplied[B] private[EitherTFunctions] {\n    def apply[F[_], A](fa: F[A])(implicit F: Functor[F]): EitherT[F, A, B] = EitherT(F.map(fa)(Either.left))\n  }"
  },
  {
    "id" : "a1051407-7c04-4098-a8e4-7ea3291423c9",
    "prId" : 1614,
    "prUrl" : "https://github.com/typelevel/cats/pull/1614#pullrequestreview-34154580",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e556fe3c-27fb-42b8-9ecd-126255f5c889",
        "parentId" : null,
        "authorId" : "98bd6ddf-86cb-413a-a672-ee7d989ba290",
        "body" : "Just wondering, is this better than `OptionT(fopt).toRight(ifNone)` ?",
        "createdAt" : "2017-04-20T21:07:20Z",
        "updatedAt" : "2017-04-20T21:07:20Z",
        "lastEditedBy" : "98bd6ddf-86cb-413a-a672-ee7d989ba290",
        "tags" : [
        ]
      },
      {
        "id" : "280cf180-3f40-4f5c-9edf-e54425c72080",
        "parentId" : "e556fe3c-27fb-42b8-9ecd-126255f5c889",
        "authorId" : "6b760ef7-e448-44a7-b744-0c25c840a80a",
        "body" : "Didn't know about the `OptionT.toRight`, Looks like this one has slightly less function calls and an allocation to `OptionT`? ",
        "createdAt" : "2017-04-20T21:33:48Z",
        "updatedAt" : "2017-04-20T21:33:48Z",
        "lastEditedBy" : "6b760ef7-e448-44a7-b744-0c25c840a80a",
        "tags" : [
        ]
      },
      {
        "id" : "9eed2086-a6c4-445a-a12b-b1fb14028e98",
        "parentId" : "e556fe3c-27fb-42b8-9ecd-126255f5c889",
        "authorId" : "6b760ef7-e448-44a7-b744-0c25c840a80a",
        "body" : "@peterneyens anything else in this PR?",
        "createdAt" : "2017-04-22T10:17:53Z",
        "updatedAt" : "2017-04-22T10:17:53Z",
        "lastEditedBy" : "6b760ef7-e448-44a7-b744-0c25c840a80a",
        "tags" : [
        ]
      }
    ],
    "commit" : "5e67748a1ae286e2bad024c2a2497cec9347401f",
    "line" : 105,
    "diffHunk" : "@@ -1,1 +373,377 @@   * }}}\n   */\n  final def fromOptionF[F[_], E, A](fopt: F[Option[A]], ifNone: => E)(implicit F: Functor[F]): EitherT[F, E, A] =\n    EitherT(F.map(fopt)(opt => Either.fromOption(opt, ifNone)))\n"
  },
  {
    "id" : "b0bc8abf-8995-4924-82d3-d13d25fedffe",
    "prId" : 1481,
    "prUrl" : "https://github.com/typelevel/cats/pull/1481#pullrequestreview-11634364",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6eb411f4-f101-4645-ac53-73dc899d5c29",
        "parentId" : null,
        "authorId" : "98bd6ddf-86cb-413a-a672-ee7d989ba290",
        "body" : "I think we need to import `cats.data.EitherT` and (for the `Applicative[Future]`) `cats.implicits._`, `scala.concurrent.Future` and an `ExecutionContext`. Newlines also need a `|` at the start of the line (see for example the `toNested` example).\r\n\r\nIt seems that this `cond` example wasn't tested by travis (if I haven't missed it), maybe because the format wasn't right ?\r\n\r\nThe easiest way I found to quickly test a doctest example is to paste it in a fresh `console` (otherwise it is easy to forget some of the imports).\r\n\r\nApart of the example :+1: ",
        "createdAt" : "2016-12-02T18:26:18Z",
        "updatedAt" : "2016-12-16T21:22:04Z",
        "lastEditedBy" : "98bd6ddf-86cb-413a-a672-ee7d989ba290",
        "tags" : [
        ]
      },
      {
        "id" : "5bac5307-9092-4677-8fe5-e8f6d02e2ef2",
        "parentId" : "6eb411f4-f101-4645-ac53-73dc899d5c29",
        "authorId" : "5e69f9a7-81f7-4c30-81de-392443f2c68d",
        "body" : "I had the doc example code running correctly, but the travis build was spitting out errors that the imports weren't needed. I actually went back and removed the imports just for the sake of appeasing Travis!\r\n\r\nI'll push a new commit to see what happens. If it all goes well, I can squash before a merge.",
        "createdAt" : "2016-12-02T21:28:13Z",
        "updatedAt" : "2016-12-16T21:22:04Z",
        "lastEditedBy" : "5e69f9a7-81f7-4c30-81de-392443f2c68d",
        "tags" : [
        ]
      },
      {
        "id" : "62ba8026-b3be-4acf-9605-ff489109ceab",
        "parentId" : "6eb411f4-f101-4645-ac53-73dc899d5c29",
        "authorId" : "5e69f9a7-81f7-4c30-81de-392443f2c68d",
        "body" : "I pushed a new commit, but when I run the tests locally I get:\r\n```\r\n> test:compileIncremental\r\n[info] Compiling 26 Scala sources to /Users/andy/git/cats/core/.jvm/target/scala-2.12/test-classes...\r\n[error] /Users/andy/git/cats/core/.jvm/target/scala-2.12/src_managed/test/cats/data/EitherTDoctest.scala:217: Unused import\r\n[error]     import cats.data.EitherT\r\n[error]                      ^\r\n[error] /Users/andy/git/cats/core/.jvm/target/scala-2.12/src_managed/test/cats/data/EitherTDoctest.scala:219: Unused import\r\n[error]     import cats.implicits._\r\n[error]                           ^\r\n[error] /Users/andy/git/cats/core/.jvm/target/scala-2.12/src_managed/test/cats/data/EitherTDoctest.scala:221: Unused import\r\n[error]     import scala.concurrent.Future\r\n[error]                             ^\r\n[error] /Users/andy/git/cats/core/.jvm/target/scala-2.12/src_managed/test/cats/data/EitherTDoctest.scala:223: Unused import\r\n[error]     import scala.concurrent.ExecutionContext.Implicits.global\r\n[error]                                                        ^\r\n[error] four errors found\r\n[error] (coreJVM/test:compileIncremental) Compilation failed\r\n[error] Total time: 12 s, completed Dec 6, 2016 9:09:21 AM\r\n>\r\n```",
        "createdAt" : "2016-12-06T17:10:56Z",
        "updatedAt" : "2016-12-16T21:22:04Z",
        "lastEditedBy" : "5e69f9a7-81f7-4c30-81de-392443f2c68d",
        "tags" : [
        ]
      }
    ],
    "commit" : "355b5a75a7b34754acaf0dfec5bb273a1712f815",
    "line" : null,
    "diffHunk" : "@@ -1,1 +302,306 @@    * scala> import cats.Id\n    * scala> import cats.data.EitherT\n    * scala> val userInput = \"hello world\"\n    * scala> EitherT.cond[Id](\n    *      |   userInput.forall(_.isDigit) && userInput.size == 10,"
  },
  {
    "id" : "f44e19c3-2a5c-4793-90fc-26d1ab8c377c",
    "prId" : 1327,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e2082123-3f41-4b1f-9714-499d192c0f95",
        "parentId" : null,
        "authorId" : "87827373-839d-4659-b70a-3dfef48eaa6a",
        "body" : "1) In the doctests\n",
        "createdAt" : "2016-08-24T17:08:56Z",
        "updatedAt" : "2016-08-24T17:08:56Z",
        "lastEditedBy" : "87827373-839d-4659-b70a-3dfef48eaa6a",
        "tags" : [
        ]
      }
    ],
    "commit" : "50db00cd02a51f0fcf760e03db857c5a400de7ec",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +262,266 @@   * res0: EitherT[List, String, Int]  = EitherT(List(Left(Answer not known.)))\n   * scala> EitherT.fromOption[List](Some(42), \"Answer not known.\")\n   * res1: EitherT[List, String, Int] = EitherT(List(Right(42)))\n   * }}}\n   */"
  },
  {
    "id" : "adf50ca8-d6e7-4372-b7f7-df3d9fed0dee",
    "prId" : 1289,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b1d91b4e-84cb-4e2d-8cdc-0a984ddbcc84",
        "parentId" : null,
        "authorId" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "body" : "Can this `extends AnyVal`?\n",
        "createdAt" : "2016-08-15T04:03:31Z",
        "updatedAt" : "2016-08-17T06:02:17Z",
        "lastEditedBy" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "tags" : [
        ]
      },
      {
        "id" : "534bd2de-e0b5-4c80-a587-84f93bbf9fc7",
        "parentId" : "b1d91b4e-84cb-4e2d-8cdc-0a984ddbcc84",
        "authorId" : "4aafd631-794d-4704-aeda-a6c56ce667d1",
        "body" : "Hm I'm getting a lot of `EitherT.scala:253 bridge generated for method compare: (x: cats.data.EitherT[F, L, A], y: cats.data.EitherT[F, L, A])Int in trait EitherTOrder which overrides method compare: (x: A, y: A)Int in trait Order clashes with definition of member itself; both have erased type (x: Object, y: Object)Int` and similar for other methods (11 such occurences) - I suspect this is also why `XorT` is currently not a value class?\n",
        "createdAt" : "2016-08-15T18:25:47Z",
        "updatedAt" : "2016-08-17T06:02:17Z",
        "lastEditedBy" : "4aafd631-794d-4704-aeda-a6c56ce667d1",
        "tags" : [
        ]
      },
      {
        "id" : "f0b133c1-ea29-4ecc-b4eb-2cb432c9e5c0",
        "parentId" : "b1d91b4e-84cb-4e2d-8cdc-0a984ddbcc84",
        "authorId" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "body" : "okay. Bummer.\n",
        "createdAt" : "2016-08-15T18:30:13Z",
        "updatedAt" : "2016-08-17T06:02:17Z",
        "lastEditedBy" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "tags" : [
        ]
      }
    ],
    "commit" : "ba1a7860a34829755fd5adc9d0397c12adb8b2eb",
    "line" : 15,
    "diffHunk" : "@@ -1,1 +13,17 @@ * and lifted in to a `EitherT[F, C, B]` via `EitherT.left`.\n */\nfinal case class EitherT[F[_], A, B](value: F[Either[A, B]]) {\n  def fold[C](fa: A => C, fb: B => C)(implicit F: Functor[F]): F[C] = F.map(value)(_.fold(fa, fb))\n"
  }
]
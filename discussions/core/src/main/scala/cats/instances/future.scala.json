[
  {
    "id" : "91143ae8-773e-4b4d-86d8-f6733856f9ec",
    "prId" : 3348,
    "prUrl" : "https://github.com/typelevel/cats/pull/3348#pullrequestreview-371895432",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8331e039-12f8-479d-ac3e-f53c8240f462",
        "parentId" : null,
        "authorId" : "6943dbfe-856b-4f1b-bd04-dca0091e8291",
        "body" : "There are no actual changes in this file, right?",
        "createdAt" : "2020-03-10T08:07:29Z",
        "updatedAt" : "2020-03-10T08:08:06Z",
        "lastEditedBy" : "6943dbfe-856b-4f1b-bd04-dca0091e8291",
        "tags" : [
        ]
      },
      {
        "id" : "dc03b911-27d3-481e-9a48-79891e195214",
        "parentId" : "8331e039-12f8-479d-ac3e-f53c8240f462",
        "authorId" : "429eae10-8138-404f-b9b2-421bcdcf30be",
        "body" : "yes, only formatting",
        "createdAt" : "2020-03-10T12:10:23Z",
        "updatedAt" : "2020-03-10T12:10:23Z",
        "lastEditedBy" : "429eae10-8138-404f-b9b2-421bcdcf30be",
        "tags" : [
        ]
      }
    ],
    "commit" : "9ef51987515afe1a82103d529658ae83bf865a10",
    "line" : 31,
    "diffHunk" : "@@ -1,1 +23,27 @@        Future.failed(e)\n\n      override def handleError[A](fea: Future[A])(f: Throwable => A): Future[A] =\n        fea.recover { case t => f(t) }\n"
  },
  {
    "id" : "754e667e-8c78-4bb2-9420-03fdf8cd89db",
    "prId" : 1261,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8d28cefb-a1a2-46b3-9d1b-8b08feda5dea",
        "parentId" : null,
        "authorId" : "6b760ef7-e448-44a7-b744-0c25c840a80a",
        "body" : "shall we add `@tailrec` ?\n",
        "createdAt" : "2016-08-03T16:17:18Z",
        "updatedAt" : "2016-08-03T18:17:37Z",
        "lastEditedBy" : "6b760ef7-e448-44a7-b744-0c25c840a80a",
        "tags" : [
        ]
      },
      {
        "id" : "bc3afb00-f918-4683-98b1-408343f244c3",
        "parentId" : "8d28cefb-a1a2-46b3-9d1b-8b08feda5dea",
        "authorId" : "6943dbfe-856b-4f1b-bd04-dca0091e8291",
        "body" : "@kailuowang This implementation won't actually compile with `@tailrec`, since the recursive call is inside the `flatMap`. It is stack-safe, though, thanks to the way `Future#flatMap` works.\n",
        "createdAt" : "2016-08-03T16:59:49Z",
        "updatedAt" : "2016-08-03T18:17:37Z",
        "lastEditedBy" : "6943dbfe-856b-4f1b-bd04-dca0091e8291",
        "tags" : [
        ]
      },
      {
        "id" : "9920b3d0-171c-40d7-b736-ae8a6e3e801b",
        "parentId" : "8d28cefb-a1a2-46b3-9d1b-8b08feda5dea",
        "authorId" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "body" : "@travisbrown is this stack safe on all versions of scala? I thought scala futures could have issues with this (at least in 2.10 or something. This is just a vague recollection).\n",
        "createdAt" : "2016-08-03T17:11:01Z",
        "updatedAt" : "2016-08-03T18:17:37Z",
        "lastEditedBy" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "tags" : [
        ]
      },
      {
        "id" : "94045955-c3b0-4470-8e17-86e1637e1f38",
        "parentId" : "8d28cefb-a1a2-46b3-9d1b-8b08feda5dea",
        "authorId" : "6943dbfe-856b-4f1b-bd04-dca0091e8291",
        "body" : "@johnynek I'm pretty sure that was only an issue with the original Akka `Future` implementation, and that by the time SIP-14 landed `flatMap` was stack-safe (thanks to pressure from Twitter and inspired by `c.t.u.Future`). I'll double-check that, though.\n",
        "createdAt" : "2016-08-03T17:14:03Z",
        "updatedAt" : "2016-08-03T18:17:37Z",
        "lastEditedBy" : "6943dbfe-856b-4f1b-bd04-dca0091e8291",
        "tags" : [
        ]
      },
      {
        "id" : "6f11e1d6-6c5e-4c41-98c7-d5e01f521ef1",
        "parentId" : "8d28cefb-a1a2-46b3-9d1b-8b08feda5dea",
        "authorId" : "6943dbfe-856b-4f1b-bd04-dca0091e8291",
        "body" : "@johnynek I'm not finding the discussion I was thinking of at the moment, but I did try this on 2.9.3:\n\n``` scala\nimport scala.concurrent.{ Await, Future }, scala.concurrent.duration._\nimport scala.concurrent.ExecutionContext.Implicits.global\n\ndef test(i: Int)(f: Int => Future[Int]): Future[Int] = f(i).flatMap {\n  case x if x > 100000 => Future.successful(x)\n  case x => test(x)(f)\n}\n\nval f1 = test(0)(x => Future(x + 1))\nval f2 = test(0)(x => Future(x))\n```\n\nNeither blows the stack, and `f1` succeeds as expected.\n",
        "createdAt" : "2016-08-03T17:37:41Z",
        "updatedAt" : "2016-08-03T18:17:37Z",
        "lastEditedBy" : "6943dbfe-856b-4f1b-bd04-dca0091e8291",
        "tags" : [
        ]
      },
      {
        "id" : "0a003f76-a601-4164-9aca-b45199777596",
        "parentId" : "8d28cefb-a1a2-46b3-9d1b-8b08feda5dea",
        "authorId" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "body" : "Yeah, looks legit. Thanks (I know Twitter's is stack safe, I didn't know scala was).\n",
        "createdAt" : "2016-08-03T17:44:58Z",
        "updatedAt" : "2016-08-03T18:17:37Z",
        "lastEditedBy" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "tags" : [
        ]
      },
      {
        "id" : "071a47a8-994f-40c2-acc4-e783b0cfbe0e",
        "parentId" : "8d28cefb-a1a2-46b3-9d1b-8b08feda5dea",
        "authorId" : "66a3e1fe-d02b-4e16-badc-4e9980e148af",
        "body" : "Maybe a code comment mentioning that this construct is actually stack-safe would be appropriate here?\n",
        "createdAt" : "2016-08-03T17:50:18Z",
        "updatedAt" : "2016-08-03T18:17:37Z",
        "lastEditedBy" : "66a3e1fe-d02b-4e16-badc-4e9980e148af",
        "tags" : [
        ]
      },
      {
        "id" : "63794ba9-aa60-4de2-9c17-0a9b300ba0af",
        "parentId" : "8d28cefb-a1a2-46b3-9d1b-8b08feda5dea",
        "authorId" : "6943dbfe-856b-4f1b-bd04-dca0091e8291",
        "body" : "@fthomas Makes senseâ€”done.\n",
        "createdAt" : "2016-08-03T18:18:23Z",
        "updatedAt" : "2016-08-03T18:18:23Z",
        "lastEditedBy" : "6943dbfe-856b-4f1b-bd04-dca0091e8291",
        "tags" : [
        ]
      }
    ],
    "commit" : "cad6429c2cb24a1feba229b96a7e9448dd317826",
    "line" : null,
    "diffHunk" : "@@ -1,1 +19,23 @@       * it is in fact stack-safe.\n       */\n      final def tailRecM[B, C](b: B)(f: B => Future[(B Xor C)]): Future[C] =\n        f(b).flatMap {\n          case Xor.Left(b1) => tailRecM(b1)(f)"
  }
]
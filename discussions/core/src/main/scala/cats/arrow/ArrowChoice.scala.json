[
  {
    "id" : "717ae510-3920-490b-8005-9707b77a6b3f",
    "prId" : 2096,
    "prUrl" : "https://github.com/typelevel/cats/pull/2096#pullrequestreview-82894283",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2b0e01ee-62d7-4cb4-8c54-3429224d0c4a",
        "parentId" : null,
        "authorId" : "74d1b5f4-28cd-44b3-ac44-bbc4dac94474",
        "body" : "I noticed that `choice` doesnâ€™t have `|||` as a symbolic alias. This is not really related to this PR but that would be a good thing to have.",
        "createdAt" : "2017-12-12T08:37:54Z",
        "updatedAt" : "2017-12-13T19:23:40Z",
        "lastEditedBy" : "74d1b5f4-28cd-44b3-ac44-bbc4dac94474",
        "tags" : [
        ]
      },
      {
        "id" : "02a4cba5-7715-435f-a5f0-3ce30961d228",
        "parentId" : "2b0e01ee-62d7-4cb4-8c54-3429224d0c4a",
        "authorId" : "578d04c8-51eb-46e6-af71-72c52643fcc1",
        "body" : "Good call, I can add.",
        "createdAt" : "2017-12-12T16:30:44Z",
        "updatedAt" : "2017-12-13T19:23:41Z",
        "lastEditedBy" : "578d04c8-51eb-46e6-af71-72c52643fcc1",
        "tags" : [
        ]
      }
    ],
    "commit" : "8b5d4972f83b452f1c8da7228bdf76c058491057",
    "line" : 42,
    "diffHunk" : "@@ -1,1 +40,44 @@\n  override def choice[A, B, C](f: F[A, C], g: F[B, C]): F[Either[A, B], C] =\n    rmap(choose(f)(g))(_.fold(identity, identity))\n}"
  },
  {
    "id" : "4e33039c-0191-42eb-8703-53ca7c3572c6",
    "prId" : 2096,
    "prUrl" : "https://github.com/typelevel/cats/pull/2096#pullrequestreview-83234238",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bafa38fc-adb6-4b93-99c7-47658b606596",
        "parentId" : null,
        "authorId" : "6b760ef7-e448-44a7-b744-0c25c840a80a",
        "body" : "This is never tested by law as I noticed from the law set defined in Haskell. Thus it doesn't have any test coverage. \r\nShall we add a law for this something like \r\n```scala\r\n  def leftRightConsistent[A, B, C](f: A => B): IsEq[F[Either[C, A], Either[C, B]]] =\r\n     F.right[A, B, C](F.lift[A, B](f)) <-> F.left[A, B, C](F.lift[A, B](f)).dimap(_.swap, _.swap)\r\n```\r\n",
        "createdAt" : "2017-12-13T16:26:06Z",
        "updatedAt" : "2017-12-13T19:23:41Z",
        "lastEditedBy" : "6b760ef7-e448-44a7-b744-0c25c840a80a",
        "tags" : [
        ]
      },
      {
        "id" : "07757b3e-c5b9-4f6b-b4cb-42e6ecbd30b8",
        "parentId" : "bafa38fc-adb6-4b93-99c7-47658b606596",
        "authorId" : "578d04c8-51eb-46e6-af71-72c52643fcc1",
        "body" : "I actually added symmetric versions for all the laws last night for that reason, but it takes the method well over 50 lines. Something like that sounds like a more reasonable way to get similar effect. I'll try it out today, it certainly should work.",
        "createdAt" : "2017-12-13T16:34:08Z",
        "updatedAt" : "2017-12-13T19:23:41Z",
        "lastEditedBy" : "578d04c8-51eb-46e6-af71-72c52643fcc1",
        "tags" : [
        ]
      }
    ],
    "commit" : "8b5d4972f83b452f1c8da7228bdf76c058491057",
    "line" : 39,
    "diffHunk" : "@@ -1,1 +37,41 @@\n  def right[A, B, C](fab: F[A, B]): F[Either[C, A], Either[C, B]] =\n    choose(lift(identity[C]))(fab)\n\n  override def choice[A, B, C](f: F[A, C], g: F[B, C]): F[Either[A, B], C] ="
  }
]
[
  {
    "id" : "6906d360-467c-4c71-a647-5b6588e04fd9",
    "prId" : 3907,
    "prUrl" : "https://github.com/typelevel/cats/pull/3907#pullrequestreview-671767825",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c4396d11-eda2-4e12-a77b-5c6f0f8305a1",
        "parentId" : null,
        "authorId" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "body" : "Awesome idea!",
        "createdAt" : "2021-05-29T19:08:56Z",
        "updatedAt" : "2021-05-29T19:08:56Z",
        "lastEditedBy" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "tags" : [
        ]
      }
    ],
    "commit" : "5d1c531441c7ecfa1b9656fc62e0042943da9b82",
    "line" : 18,
    "diffHunk" : "@@ -1,1 +70,74 @@    if (n <= 0) pure(Nil)\n    else {\n      map(Chain.traverseViaChain(new IndexedSeq[F[A]] {\n        override def length = n\n        override def apply(i: Int) = fa"
  },
  {
    "id" : "41f36bef-8bd4-4a65-80fe-38ab11076f44",
    "prId" : 3392,
    "prUrl" : "https://github.com/typelevel/cats/pull/3392#pullrequestreview-394483473",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "90194b59-e57c-4fab-b8c0-a952d7882ccb",
        "parentId" : null,
        "authorId" : "429eae10-8138-404f-b9b2-421bcdcf30be",
        "body" : "since `PartialFunction` is subtype of `Function1` there was implicit ambiguity here",
        "createdAt" : "2020-04-16T10:03:34Z",
        "updatedAt" : "2020-06-12T11:59:18Z",
        "lastEditedBy" : "429eae10-8138-404f-b9b2-421bcdcf30be",
        "tags" : [
        ]
      }
    ],
    "commit" : "4fd89272ba41cf5ed989c840262ce3076a8df80a",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +203,207 @@   * scala> val toLong: Int => Long = _.toLong\n   * scala> val double: Int => Int = 2*_\n   * scala> val f: Int => (Long, Int) = catsApplicativeForArrow[Function1, Int].product(toLong, double)\n   * scala> f(3)\n   * res0: (Long, Int) = (3,6)"
  },
  {
    "id" : "a1bca92e-1920-4d0b-b496-64d18ec54ea9",
    "prId" : 455,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "da51f0f2-95d7-4f31-8545-cece50072301",
        "parentId" : null,
        "authorId" : "4aafd631-794d-4704-aeda-a6c56ce667d1",
        "body" : "Making the default delegate to `pure` would negate any laziness properties of the `Eval` instance we pass in right? Oh - the intention would be to override as necessary, say when defining it for a `Task`-y thing?\n",
        "createdAt" : "2015-08-17T02:23:39Z",
        "updatedAt" : "2015-08-26T19:14:06Z",
        "lastEditedBy" : "4aafd631-794d-4704-aeda-a6c56ce667d1",
        "tags" : [
        ]
      },
      {
        "id" : "e71b97d9-6614-4721-9067-f3684a18e4bf",
        "parentId" : "da51f0f2-95d7-4f31-8545-cece50072301",
        "authorId" : "89a3e0e3-e301-4aa8-b150-74070eb5a619",
        "body" : "Right exactly. Particular monad instances could do something different here.\n",
        "createdAt" : "2015-08-17T02:32:12Z",
        "updatedAt" : "2015-08-26T19:14:06Z",
        "lastEditedBy" : "89a3e0e3-e301-4aa8-b150-74070eb5a619",
        "tags" : [
        ]
      }
    ],
    "commit" : "fb01f5d1ea5ba518a058bd9cbdcb5daac90ad8e6",
    "line" : 18,
    "diffHunk" : "@@ -1,1 +27,31 @@   * This variant supports optional laziness.\n   */\n  def pureEval[A](x: Eval[A]): F[A] = pure(x.value)\n\n  override def map[A, B](fa: F[A])(f: A => B): F[B] = ap(fa)(pure(f))"
  },
  {
    "id" : "063a7fd2-1d49-469e-b2f0-ec8864e327ba",
    "prId" : 102,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d3a8da7a-9c48-4f71-850c-1a459677e733",
        "parentId" : null,
        "authorId" : "841f9474-2dfc-46b8-9cfa-77b23455116a",
        "body" : "same for this one: http://staff.city.ac.uk/~ross/papers/Applicative.pdf\n",
        "createdAt" : "2015-02-06T17:56:44Z",
        "updatedAt" : "2015-02-07T15:53:18Z",
        "lastEditedBy" : "841f9474-2dfc-46b8-9cfa-77b23455116a",
        "tags" : [
        ]
      }
    ],
    "commit" : "bab13c2c653aaea6c078d3b80bab3ee954386b77",
    "line" : null,
    "diffHunk" : "@@ -1,1 +9,13 @@ *\n * See: [[https://www.cs.ox.ac.uk/jeremy.gibbons/publications/iterator.pdf The Essence of the Iterator Pattern]]\n * Also: [[http://staff.city.ac.uk/~ross/papers/Applicative.pdf Applicative programming with effects]]\n *\n * Must obey the following laws:"
  }
]
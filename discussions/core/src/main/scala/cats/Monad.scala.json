[
  {
    "id" : "d66fe6c6-781a-4c35-9a46-f335a8bf6541",
    "prId" : 1571,
    "prUrl" : "https://github.com/typelevel/cats/pull/1571#pullrequestreview-29859697",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f34e9587-15e3-404d-8108-d52cdeda1457",
        "parentId" : null,
        "authorId" : "6b760ef7-e448-44a7-b744-0c25c840a80a",
        "body" : "Notice here that to maintain the order of evaluation results I have to append the latest result to the end of the `Alternative`, which means the performance will be horrible for `List`. \r\nI see 3 options here: \r\n1. in the API document, point this out and warn people against data structures with non-constant append performance. \r\n2. use prepend here and return the `G` with results in the reverse order, i.e. last result first. \r\n3. maintain an internal `List` in the reverse order and construct the `G` at last in the right order. \r\n\r\n@tpolecat and @Atry, what would be your preference here? ",
        "createdAt" : "2017-03-27T00:13:03Z",
        "updatedAt" : "2017-03-27T15:35:14Z",
        "lastEditedBy" : "6b760ef7-e448-44a7-b744-0c25c840a80a",
        "tags" : [
        ]
      },
      {
        "id" : "87e44c9b-3233-4214-9ed3-516312131e84",
        "parentId" : "f34e9587-15e3-404d-8108-d52cdeda1457",
        "authorId" : "8106957f-b999-418b-b22b-14067e9a3932",
        "body" : "I think it's fine to just document the behavior, rather than trying to be clever. This is a general issue with accumulating structures.",
        "createdAt" : "2017-03-29T22:26:31Z",
        "updatedAt" : "2017-03-30T16:14:17Z",
        "lastEditedBy" : "8106957f-b999-418b-b22b-14067e9a3932",
        "tags" : [
        ]
      }
    ],
    "commit" : "5d173f14b14ced058d16a6eb535481ae0c5f8e0a",
    "line" : 26,
    "diffHunk" : "@@ -1,1 +28,32 @@      ifTrue = {\n        map(b.value) { bv =>\n          Left(G.combineK(xs, G.pure(bv)))\n        }\n      },"
  },
  {
    "id" : "acbcf592-9829-4cb5-8bc2-cc3d88e3eafb",
    "prId" : 1571,
    "prUrl" : "https://github.com/typelevel/cats/pull/1571#pullrequestreview-30077368",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c90c9f0b-2030-4fee-8fe9-ce2e910bbcca",
        "parentId" : null,
        "authorId" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "body" : "why the later vs always semantics? For most monads it shouldn't matter, but for something like `Future` or `Try` where there is possibly a side-effect going on, it would.",
        "createdAt" : "2017-03-27T17:53:57Z",
        "updatedAt" : "2017-03-27T17:54:43Z",
        "lastEditedBy" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "tags" : [
        ]
      },
      {
        "id" : "9ad0f760-83e9-45ca-ad8b-e47b453722b4",
        "parentId" : "c90c9f0b-2030-4fee-8fe9-ce2e910bbcca",
        "authorId" : "6b760ef7-e448-44a7-b744-0c25c840a80a",
        "body" : "Do you think these methods would be of practical use for `Future` or `Try`? For the conditional param `p`, neither a `Try[Boolean]` nor `Future[Boolean]` will ever change the underneath value, and it's call by value.\r\nIt seems to me that the original incentive of introducing these methods are **only** for data types that track side effects such as `IO`/`Task`/`StateT`. When it comes to other data types like `Option` or `List`, they don't make sense to me, at least with current type signatures. ",
        "createdAt" : "2017-03-27T20:22:51Z",
        "updatedAt" : "2017-03-28T01:08:48Z",
        "lastEditedBy" : "6b760ef7-e448-44a7-b744-0c25c840a80a",
        "tags" : [
        ]
      },
      {
        "id" : "9b85d60b-06ec-407f-bf2e-950e6ff7c65d",
        "parentId" : "c90c9f0b-2030-4fee-8fe9-ce2e910bbcca",
        "authorId" : "8106957f-b999-418b-b22b-14067e9a3932",
        "body" : "I agree with @kailuowang. This is for data types that have something to say about side-effects or state-passing. `Future` and `Try` do not.",
        "createdAt" : "2017-03-29T22:33:11Z",
        "updatedAt" : "2017-03-30T16:14:17Z",
        "lastEditedBy" : "8106957f-b999-418b-b22b-14067e9a3932",
        "tags" : [
        ]
      },
      {
        "id" : "1189f59b-809f-4812-b373-232ee86b3b6b",
        "parentId" : "c90c9f0b-2030-4fee-8fe9-ce2e910bbcca",
        "authorId" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "body" : "That's fine, I was mostly asking because of the `Eval.later`. If we used `Eval.always` then you could use `Try` or `Future` by sneaking some effect into the call-by-name param, but I'm not a fan of that.\r\n\r\nIf we want to stick with `Eval.later` over lazy val, I'd like us to document the reason. The only reason I can see is that it allows the thunk in the call-by-name to be GC'ed after we run, which can be nice. We should comment why because someone will forget and revert since Later is only more work (it uses lazy val + some work).",
        "createdAt" : "2017-03-30T17:33:13Z",
        "updatedAt" : "2017-03-30T17:33:34Z",
        "lastEditedBy" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "tags" : [
        ]
      },
      {
        "id" : "b6e88eaa-4f67-4235-a31a-361c2785a375",
        "parentId" : "c90c9f0b-2030-4fee-8fe9-ce2e910bbcca",
        "authorId" : "6b760ef7-e448-44a7-b744-0c25c840a80a",
        "body" : "I agree we should document these not-so-obvious tech decisions somewhere (another example in my mind is typeclass instance priority). Maybe in the [contributing](http://typelevel.org/cats/contributing.html)? ",
        "createdAt" : "2017-03-30T18:37:18Z",
        "updatedAt" : "2017-03-30T18:37:18Z",
        "lastEditedBy" : "6b760ef7-e448-44a7-b744-0c25c840a80a",
        "tags" : [
        ]
      }
    ],
    "commit" : "5d173f14b14ced058d16a6eb535481ae0c5f8e0a",
    "line" : 41,
    "diffHunk" : "@@ -1,1 +43,47 @@    val continue: Either[Unit, Unit] = Left(())\n    val stop: F[Either[Unit, Unit]] = pure(Right(()))\n    val b = Eval.later(body)\n    tailRecM(())(_ => ifM(p)(\n      ifTrue = {"
  },
  {
    "id" : "64ace463-6d6e-4047-b037-e52aa250a8ea",
    "prId" : 1571,
    "prUrl" : "https://github.com/typelevel/cats/pull/1571#pullrequestreview-30087670",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "efb85ea6-544b-41ca-b9b5-bdfb585e0db7",
        "parentId" : null,
        "authorId" : "8106957f-b999-418b-b22b-14067e9a3932",
        "body" : "So, is `val p = Eval.later(cond)` what we're doing instead of `lazy val p = cond`? Is there a discussion somewhere?",
        "createdAt" : "2017-03-30T16:09:47Z",
        "updatedAt" : "2017-03-30T16:14:17Z",
        "lastEditedBy" : "8106957f-b999-418b-b22b-14067e9a3932",
        "tags" : [
        ]
      },
      {
        "id" : "1b9e016e-5723-4c15-b74f-9d5fa631ed60",
        "parentId" : "efb85ea6-544b-41ca-b9b5-bdfb585e0db7",
        "authorId" : "6b760ef7-e448-44a7-b744-0c25c840a80a",
        "body" : "Yes. I picked `Eval.later(cond)` over `lazy val` because of the optimization in `Later`, and the fact that an equivalent `Need` is used in scalaz. But I don't have proof that it is worth the extra allocation. \r\nI am not aware of any discussion regarding choosing between these two in cats. ",
        "createdAt" : "2017-03-30T16:31:00Z",
        "updatedAt" : "2017-03-30T16:31:00Z",
        "lastEditedBy" : "6b760ef7-e448-44a7-b744-0c25c840a80a",
        "tags" : [
        ]
      },
      {
        "id" : "f5125ec9-a0c6-4cd5-a9f4-4a2202c4c392",
        "parentId" : "efb85ea6-544b-41ca-b9b5-bdfb585e0db7",
        "authorId" : "8106957f-b999-418b-b22b-14067e9a3932",
        "body" : "Ok, I don't feel strongly about it. Was just curious.",
        "createdAt" : "2017-03-30T16:32:13Z",
        "updatedAt" : "2017-03-30T16:32:13Z",
        "lastEditedBy" : "8106957f-b999-418b-b22b-14067e9a3932",
        "tags" : [
        ]
      },
      {
        "id" : "6608e727-fd40-4821-95a2-6348091cbc72",
        "parentId" : "efb85ea6-544b-41ca-b9b5-bdfb585e0db7",
        "authorId" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "body" : "Later just uses lazy val under the hood: https://github.com/typelevel/cats/blob/master/core/src/main/scala/cats/Eval.scala#L186 \r\n\r\nThe only reason I can think of to use `Later` vs `lazy val` is maybe the thunk can be GC'd in the Later case? cc @non",
        "createdAt" : "2017-03-30T17:29:52Z",
        "updatedAt" : "2017-03-30T17:29:52Z",
        "lastEditedBy" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "tags" : [
        ]
      },
      {
        "id" : "2f3e48eb-74f6-4b34-beb0-ce48d35fef96",
        "parentId" : "efb85ea6-544b-41ca-b9b5-bdfb585e0db7",
        "authorId" : "89a3e0e3-e301-4aa8-b150-74070eb5a619",
        "body" : "There's also a locking issue -- lazy vals lock their enclosing class, `Later` only locks itself.",
        "createdAt" : "2017-03-30T18:02:05Z",
        "updatedAt" : "2017-03-30T18:02:05Z",
        "lastEditedBy" : "89a3e0e3-e301-4aa8-b150-74070eb5a619",
        "tags" : [
        ]
      },
      {
        "id" : "34db1e92-d04c-44c6-b180-05989b6a3b3f",
        "parentId" : "efb85ea6-544b-41ca-b9b5-bdfb585e0db7",
        "authorId" : "8106957f-b999-418b-b22b-14067e9a3932",
        "body" : "Yeah see https://github.com/scalaz/scalaz/issues/1144 for discussion (moving my comment up).",
        "createdAt" : "2017-03-30T18:03:56Z",
        "updatedAt" : "2017-03-30T18:03:57Z",
        "lastEditedBy" : "8106957f-b999-418b-b22b-14067e9a3932",
        "tags" : [
        ]
      },
      {
        "id" : "9e41c64f-cb08-438a-9ddb-7892b41aa0ce",
        "parentId" : "efb85ea6-544b-41ca-b9b5-bdfb585e0db7",
        "authorId" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "body" : "okay. Makes sense to me. üëç ",
        "createdAt" : "2017-03-30T19:18:46Z",
        "updatedAt" : "2017-03-30T19:18:46Z",
        "lastEditedBy" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "tags" : [
        ]
      }
    ],
    "commit" : "5d173f14b14ced058d16a6eb535481ae0c5f8e0a",
    "line" : 60,
    "diffHunk" : "@@ -1,1 +62,66 @@    val p = Eval.later(cond)\n    flatMap(f)(x => map(whileM(map(p.value)(!_))(f))(xs => G.combineK(G.pure(x), xs)))\n  }\n\n  /**"
  }
]
[
  {
    "id" : "60194734-54e1-4379-869b-446ed24d3a4e",
    "prId" : 3647,
    "prUrl" : "https://github.com/typelevel/cats/pull/3647#pullrequestreview-516846818",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0265e18c-8de3-4a0a-903e-091d058dabb4",
        "parentId" : null,
        "authorId" : "c922a9b6-a191-4a1d-b6d1-67a1b509a11b",
        "body" : "Double import (counts as unused on 2.13, which is why I think the build failed on that version)",
        "createdAt" : "2020-10-26T11:22:58Z",
        "updatedAt" : "2020-10-29T21:10:12Z",
        "lastEditedBy" : "c922a9b6-a191-4a1d-b6d1-67a1b509a11b",
        "tags" : [
        ]
      },
      {
        "id" : "82b5c82d-7dbc-4f79-9d60-231e200c27da",
        "parentId" : "0265e18c-8de3-4a0a-903e-091d058dabb4",
        "authorId" : "399928f6-5db9-4b5d-a76b-699f9f6f85d8",
        "body" : "fixed now",
        "createdAt" : "2020-10-26T14:41:00Z",
        "updatedAt" : "2020-10-29T21:10:12Z",
        "lastEditedBy" : "399928f6-5db9-4b5d-a76b-699f9f6f85d8",
        "tags" : [
        ]
      }
    ],
    "commit" : "525b82b2c9cb458666107a1e37a21668272fcc18",
    "line" : 12,
    "diffHunk" : "@@ -1,1 +46,50 @@   * Example:\n   * {{{\n   * scala> import cats.implicits._\n   * scala> import java.io.IOException\n   * scala> type IO[A] = Either[IOException, A]"
  },
  {
    "id" : "83a566ef-e2a5-4599-8324-b0826410bf94",
    "prId" : 3647,
    "prUrl" : "https://github.com/typelevel/cats/pull/3647#pullrequestreview-516710250",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "13529b85-f786-49ee-8978-9c067dac5f86",
        "parentId" : null,
        "authorId" : "c922a9b6-a191-4a1d-b6d1-67a1b509a11b",
        "body" : "Technically we could use `Functor[G].as`, but we have the applicative anyway, so it probably doesn't matter.",
        "createdAt" : "2020-10-26T11:24:06Z",
        "updatedAt" : "2020-10-29T21:10:12Z",
        "lastEditedBy" : "c922a9b6-a191-4a1d-b6d1-67a1b509a11b",
        "tags" : [
        ]
      },
      {
        "id" : "d00011b3-45b1-4f1e-974a-279ae62f8243",
        "parentId" : "13529b85-f786-49ee-8978-9c067dac5f86",
        "authorId" : "399928f6-5db9-4b5d-a76b-699f9f6f85d8",
        "body" : "Would that work even if `traverse` requires an `Applicative` for `G`?",
        "createdAt" : "2020-10-26T11:46:48Z",
        "updatedAt" : "2020-10-29T21:10:12Z",
        "lastEditedBy" : "399928f6-5db9-4b5d-a76b-699f9f6f85d8",
        "tags" : [
        ]
      },
      {
        "id" : "045be907-35a5-47bb-8910-f1d4ed258017",
        "parentId" : "13529b85-f786-49ee-8978-9c067dac5f86",
        "authorId" : "c922a9b6-a191-4a1d-b6d1-67a1b509a11b",
        "body" : "it'll work because Functor <:< Applicative",
        "createdAt" : "2020-10-26T12:03:28Z",
        "updatedAt" : "2020-10-29T21:10:12Z",
        "lastEditedBy" : "c922a9b6-a191-4a1d-b6d1-67a1b509a11b",
        "tags" : [
        ]
      }
    ],
    "commit" : "525b82b2c9cb458666107a1e37a21668272fcc18",
    "line" : 21,
    "diffHunk" : "@@ -1,1 +55,59 @@   */\n  def traverseTap[G[_]: Applicative, A, B](fa: F[A])(f: A => G[B]): G[F[A]] =\n    traverse(fa)(a => Applicative[G].as(f(a), a))\n\n  /**"
  },
  {
    "id" : "8cc94c6c-0264-4f1e-a10c-7a7f4e2aad82",
    "prId" : 1761,
    "prUrl" : "https://github.com/typelevel/cats/pull/1761#pullrequestreview-48992134",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a04959b8-fb70-44f2-9fc2-6e6f2732776c",
        "parentId" : null,
        "authorId" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "body" : "can we override this for `List`, `Vector` and `Stream`?",
        "createdAt" : "2017-07-10T18:24:21Z",
        "updatedAt" : "2017-07-14T15:47:10Z",
        "lastEditedBy" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "tags" : [
        ]
      },
      {
        "id" : "6d354a7c-5216-4e90-8af2-b076b340619b",
        "parentId" : "a04959b8-fb70-44f2-9fc2-6e6f2732776c",
        "authorId" : "5e69f9a7-81f7-4c30-81de-392443f2c68d",
        "body" : "Sure thing",
        "createdAt" : "2017-07-10T18:33:07Z",
        "updatedAt" : "2017-07-14T15:47:10Z",
        "lastEditedBy" : "5e69f9a7-81f7-4c30-81de-392443f2c68d",
        "tags" : [
        ]
      }
    ],
    "commit" : "9789c2d874f4e9ce3ea8325bea8d009364dcc298",
    "line" : 18,
    "diffHunk" : "@@ -1,1 +106,110 @@   * F when calling the function.\n   */\n  def mapWithIndex[A, B](fa: F[A])(f: (A, Int) => B): F[B] =\n    traverse(fa)(a =>\n      State((s: Int) => (s + 1, f(a, s)))).runA(0).value"
  },
  {
    "id" : "7cce318c-b9f7-418a-a6f3-8875031d3275",
    "prId" : 1020,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ed21255c-0d41-427a-ba3b-1b66f6b163b5",
        "parentId" : null,
        "authorId" : "98bd6ddf-86cb-413a-a672-ee7d989ba290",
        "body" : "We got `F` (`FlatMap[F]`) as an `Applicative[F]`, but we could also use the `Traverse` itself : `G.map(traverse(fa)(f)(this))(F.flatten)`.\n\nI am not sure if there is a reason to choose one over the other ?\n",
        "createdAt" : "2016-05-07T16:06:18Z",
        "updatedAt" : "2016-05-07T16:06:18Z",
        "lastEditedBy" : "98bd6ddf-86cb-413a-a672-ee7d989ba290",
        "tags" : [
        ]
      },
      {
        "id" : "f01424a4-a062-46d0-a7ee-498f87e98d4e",
        "parentId" : "ed21255c-0d41-427a-ba3b-1b66f6b163b5",
        "authorId" : "b714495a-5740-47d4-aaaa-98f354f5c0a7",
        "body" : "I think the version that you currently have is probably better, because `Applicative.traverse` ends up delegating through to `Traverse.traverse` anyway.\n",
        "createdAt" : "2016-05-07T20:43:01Z",
        "updatedAt" : "2016-05-07T20:43:01Z",
        "lastEditedBy" : "b714495a-5740-47d4-aaaa-98f354f5c0a7",
        "tags" : [
        ]
      },
      {
        "id" : "2e755803-8148-47d3-8172-ef7df6f2fc20",
        "parentId" : "ed21255c-0d41-427a-ba3b-1b66f6b163b5",
        "authorId" : "4aafd631-794d-4704-aeda-a6c56ce667d1",
        "body" : "Should this be called `traverseA` ? Consistent with `replicateA`. I think the `M` suffix is usually used when it has a `Monad` constraint.\n",
        "createdAt" : "2016-05-07T21:57:12Z",
        "updatedAt" : "2016-05-07T21:57:12Z",
        "lastEditedBy" : "4aafd631-794d-4704-aeda-a6c56ce667d1",
        "tags" : [
        ]
      },
      {
        "id" : "1001e7d8-d138-4f2b-ae35-5e210f3d4470",
        "parentId" : "ed21255c-0d41-427a-ba3b-1b66f6b163b5",
        "authorId" : "b714495a-5740-47d4-aaaa-98f354f5c0a7",
        "body" : "@adelbertc The `Applicative[G]` is required on `traverse` also. Here I think of the `M` as \"monadic\", referring to the `FlatMap[F]`. I guess we could call it `traverseF` instead, though that runs the risk of being confused with `Functor`.\n",
        "createdAt" : "2016-05-08T11:34:13Z",
        "updatedAt" : "2016-05-08T11:34:13Z",
        "lastEditedBy" : "b714495a-5740-47d4-aaaa-98f354f5c0a7",
        "tags" : [
        ]
      },
      {
        "id" : "e8214879-6ca6-4502-aa70-f4ce23073311",
        "parentId" : "ed21255c-0d41-427a-ba3b-1b66f6b163b5",
        "authorId" : "98bd6ddf-86cb-413a-a672-ee7d989ba290",
        "body" : "I was not really sure about the `M`. `traverseA` seems a bit strange because we need `FlatMap`. `traverseF` could also be confusing with the `flatMapF` and `mapF` on (some) monad transformers.\n\nMaybe we can call it `traverseFlatten` ?\n",
        "createdAt" : "2016-05-08T16:06:27Z",
        "updatedAt" : "2016-05-08T16:06:27Z",
        "lastEditedBy" : "98bd6ddf-86cb-413a-a672-ee7d989ba290",
        "tags" : [
        ]
      },
      {
        "id" : "e74b1544-2fa7-4495-9048-7a4f131b8360",
        "parentId" : "ed21255c-0d41-427a-ba3b-1b66f6b163b5",
        "authorId" : "4aafd631-794d-4704-aeda-a6c56ce667d1",
        "body" : "Oh I totally did not see the `FlatMap` requirement.. the size of my screen stopped right at `Applicative` so I assumed that was all there was. I am good with `traverseM` in that case\n",
        "createdAt" : "2016-05-08T19:05:59Z",
        "updatedAt" : "2016-05-08T19:05:59Z",
        "lastEditedBy" : "4aafd631-794d-4704-aeda-a6c56ce667d1",
        "tags" : [
        ]
      }
    ],
    "commit" : "7ef5e5b1af9555852c0f31e281622bdc23f4d775",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +34,38 @@   */\n  def traverseM[G[_], A, B](fa: F[A])(f: A => G[F[B]])(implicit G: Applicative[G], F: FlatMap[F]): G[F[B]] =\n    G.map(traverse(fa)(f))(F.flatten)\n\n  /**"
  }
]
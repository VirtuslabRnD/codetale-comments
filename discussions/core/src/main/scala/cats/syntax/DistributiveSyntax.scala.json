[
  {
    "id" : "559cfc26-4339-4f32-9bab-6d1d49933730",
    "prId" : 2046,
    "prUrl" : "https://github.com/typelevel/cats/pull/2046#pullrequestreview-79881733",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "17683e56-84d9-46e5-a62d-9c7b4c428eb9",
        "parentId" : null,
        "authorId" : "240add12-1fe5-499a-918c-053b1f46b348",
        "body" : "Maybe we should add another class for `cosequence`, we wouldn't need `cats.evidence` then:\r\n\r\n```scala\r\nfinal class CosequenceOps[F[_]: Functor, G[_]: Distributive, A](val fga: F[G[A]]) extends AnyVal {\r\n  def cosequence: G[F[A]] = G.cosequence(fga)\r\n}\r\n```",
        "createdAt" : "2017-11-28T08:47:16Z",
        "updatedAt" : "2017-12-12T15:34:20Z",
        "lastEditedBy" : "240add12-1fe5-499a-918c-053b1f46b348",
        "tags" : [
        ]
      },
      {
        "id" : "143ebf67-51ef-4923-a1d0-5eeaafd0212c",
        "parentId" : "17683e56-84d9-46e5-a62d-9c7b4c428eb9",
        "authorId" : "bc1752b5-357e-4556-a244-7e3932d74a3c",
        "body" : "Hmmm, not sure I see a reason why that's better? The evidence constraint is on just the one method and it saves the extra class for syntax. Is there a reason it should be preferred? ",
        "createdAt" : "2017-11-29T03:16:51Z",
        "updatedAt" : "2017-12-12T15:34:20Z",
        "lastEditedBy" : "bc1752b5-357e-4556-a244-7e3932d74a3c",
        "tags" : [
        ]
      },
      {
        "id" : "6fb0b57a-ee43-4575-8f14-ce6b40345ff1",
        "parentId" : "17683e56-84d9-46e5-a62d-9c7b4c428eb9",
        "authorId" : "240add12-1fe5-499a-918c-053b1f46b348",
        "body" : "Maybe you're right, disregard me! :D",
        "createdAt" : "2017-11-29T15:18:43Z",
        "updatedAt" : "2017-12-12T15:34:20Z",
        "lastEditedBy" : "240add12-1fe5-499a-918c-053b1f46b348",
        "tags" : [
        ]
      }
    ],
    "commit" : "b686896505c15458d860e7ff0991c6087f5a4686",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +5,9 @@\ntrait DistributiveSyntax extends Distributive.ToDistributiveOps {\n  implicit final def catsSyntaxDistributiveOps[F[_]: Functor, A](fa: F[A]): DistributiveOps[F, A] = new DistributiveOps[F, A](fa)\n}\n"
  }
]
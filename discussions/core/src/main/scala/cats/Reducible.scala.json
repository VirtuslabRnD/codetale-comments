[
  {
    "id" : "6bbf7d3a-7a5d-42e9-9c73-9a2a3042c744",
    "prId" : 1858,
    "prUrl" : "https://github.com/typelevel/cats/pull/1858#pullrequestreview-60855714",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4bdcdd89-9d4b-418d-bff6-4e15328016ed",
        "parentId" : null,
        "authorId" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "body" : "couldn't we do this considerably more efficiently for NonEmptyList and NonEmptyVector? Can we add methods to those datatypes that does so? Eval is kind of a perf killer, sadly, which this method hides.",
        "createdAt" : "2017-09-05T19:39:56Z",
        "updatedAt" : "2017-09-06T19:49:27Z",
        "lastEditedBy" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "tags" : [
        ]
      },
      {
        "id" : "9fb80724-0d64-41a3-96fd-637366d9e469",
        "parentId" : "4bdcdd89-9d4b-418d-bff6-4e15328016ed",
        "authorId" : "240add12-1fe5-499a-918c-053b1f46b348",
        "body" : "I just had the same idea :D I already implemented a O(n) solution for `partitionEither` on `List` and will override nonemptyPartition as well!",
        "createdAt" : "2017-09-05T19:57:15Z",
        "updatedAt" : "2017-09-06T19:49:27Z",
        "lastEditedBy" : "240add12-1fe5-499a-918c-053b1f46b348",
        "tags" : [
        ]
      },
      {
        "id" : "d0080144-1518-463d-9411-b1ffc8382ae9",
        "parentId" : "4bdcdd89-9d4b-418d-bff6-4e15328016ed",
        "authorId" : "240add12-1fe5-499a-918c-053b1f46b348",
        "body" : "Added overrides for NEL and NEV :)",
        "createdAt" : "2017-09-06T09:40:52Z",
        "updatedAt" : "2017-09-06T19:49:27Z",
        "lastEditedBy" : "240add12-1fe5-499a-918c-053b1f46b348",
        "tags" : [
        ]
      }
    ],
    "commit" : "e1d39b1d1efcdcfd789f43620a8db7a38c0c3ea9",
    "line" : 25,
    "diffHunk" : "@@ -1,1 +189,193 @@    * }}}\n    */\n  def nonEmptyPartition[A, B, C](fa: F[A])(f: A => Either[B, C]): Ior[NonEmptyList[B], NonEmptyList[C]] = {\n    import cats.syntax.either._\n"
  },
  {
    "id" : "d746153a-4a04-4667-9ce8-1db602904a4a",
    "prId" : 1685,
    "prUrl" : "https://github.com/typelevel/cats/pull/1685#pullrequestreview-40566656",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ca14b3a8-b0c0-4ccf-8f67-3f975de26c34",
        "parentId" : null,
        "authorId" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "body" : "this is not actually tested according to codecov.\r\n\r\nCan we write a test to explicitly exercise this?",
        "createdAt" : "2017-05-19T19:18:45Z",
        "updatedAt" : "2017-05-26T15:38:35Z",
        "lastEditedBy" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "tags" : [
        ]
      },
      {
        "id" : "9bea4684-5b61-4920-97f7-48b81fa9c3bf",
        "parentId" : "ca14b3a8-b0c0-4ccf-8f67-3f975de26c34",
        "authorId" : "b43434dc-f706-4cba-a4f2-eb4b74682cdf",
        "body" : "@johnynek done.",
        "createdAt" : "2017-05-26T16:39:09Z",
        "updatedAt" : "2017-05-26T16:39:09Z",
        "lastEditedBy" : "b43434dc-f706-4cba-a4f2-eb4b74682cdf",
        "tags" : [
        ]
      }
    ],
    "commit" : "bb9f8c9ac8d84cebb26bb8efd8d84f5780517f28",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +228,232 @@\n  override def get[A](fa: F[A])(idx: Long): Option[A] =\n    if (idx == 0L) Some(split(fa)._1) else G.get(split(fa)._2)(idx - 1L)\n\n  override def fold[A](fa: F[A])(implicit A: Monoid[A]): A = {"
  },
  {
    "id" : "f37ee311-857d-4ee5-ad96-bcd80c45ec64",
    "prId" : 1532,
    "prUrl" : "https://github.com/typelevel/cats/pull/1532#pullrequestreview-19864922",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e00e5efa-130c-487a-a7c2-19e215daa390",
        "parentId" : null,
        "authorId" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "body" : "this method code path is untested",
        "createdAt" : "2017-02-02T19:06:50Z",
        "updatedAt" : "2017-02-03T09:46:59Z",
        "lastEditedBy" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "tags" : [
        ]
      }
    ],
    "commit" : "96c62466b4e161c284fe8fba775d19a25a648bc0",
    "line" : 66,
    "diffHunk" : "@@ -1,1 +257,261 @@  }\n\n  override def toNonEmptyList[A](fa: F[A]): NonEmptyList[A] = {\n    val (a, ga) = split(fa)\n    NonEmptyList(a, G.toList(ga))"
  },
  {
    "id" : "642482ec-dcee-4f59-876a-54aee7a6d7fb",
    "prId" : 1464,
    "prUrl" : "https://github.com/typelevel/cats/pull/1464#pullrequestreview-39192630",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c97c022b-e1ad-410e-b238-7c244a9ea5f5",
        "parentId" : null,
        "authorId" : "b714495a-5740-47d4-aaaa-98f354f5c0a7",
        "body" : "Shouldn't this be `else G.get(split(fa)._2)(idx - 1L)`?\r\n\r\nIt's a bit funny that the only line of your PR that isn't covered by a unit test is the one with a bug in it üòú",
        "createdAt" : "2017-05-19T12:28:40Z",
        "updatedAt" : "2017-05-19T12:59:45Z",
        "lastEditedBy" : "b714495a-5740-47d4-aaaa-98f354f5c0a7",
        "tags" : [
        ]
      },
      {
        "id" : "045d4e37-0b9b-4b7c-9c86-0638bd830e0f",
        "parentId" : "c97c022b-e1ad-410e-b238-7c244a9ea5f5",
        "authorId" : "b43434dc-f706-4cba-a4f2-eb4b74682cdf",
        "body" : ":cry: You're right.",
        "createdAt" : "2017-05-19T13:17:03Z",
        "updatedAt" : "2017-05-19T13:17:03Z",
        "lastEditedBy" : "b43434dc-f706-4cba-a4f2-eb4b74682cdf",
        "tags" : [
        ]
      },
      {
        "id" : "090c1436-9b64-4321-b426-32f756ec5427",
        "parentId" : "c97c022b-e1ad-410e-b238-7c244a9ea5f5",
        "authorId" : "98bd6ddf-86cb-413a-a672-ee7d989ba290",
        "body" : "Shit, looked over that one too quickly as well. Thanks @ceedubs for paying attention.",
        "createdAt" : "2017-05-19T13:23:38Z",
        "updatedAt" : "2017-05-19T13:23:38Z",
        "lastEditedBy" : "98bd6ddf-86cb-413a-a672-ee7d989ba290",
        "tags" : [
        ]
      }
    ],
    "commit" : "71d4fd6c6a86a8a713be3db3f1c4a4c4cc55db19",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +228,232 @@\n  override def get[A](fa: F[A])(idx: Long): Option[A] =\n    if (idx == 0L) Some(split(fa)._1) else G.get(split(fa)._2)(idx)\n\n  override def fold[A](fa: F[A])(implicit A: Monoid[A]): A = {"
  },
  {
    "id" : "8693a557-fc9a-4f71-9c70-53da8874d086",
    "prId" : 1231,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c909a67f-70ad-4517-8e4e-5ef647db47e8",
        "parentId" : null,
        "authorId" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "body" : "should we add `a :: nel` to make a new NonEmptyList?\n\n``` scala\ndef ::(a: A): NonEmptyList[A] = NonEmptyList(a, head :: tail)\n```\n",
        "createdAt" : "2016-07-26T17:35:00Z",
        "updatedAt" : "2016-07-27T00:18:40Z",
        "lastEditedBy" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "tags" : [
        ]
      },
      {
        "id" : "673bb201-25cf-4d26-a79e-70e14f1b6a99",
        "parentId" : "c909a67f-70ad-4517-8e4e-5ef647db47e8",
        "authorId" : "b714495a-5740-47d4-aaaa-98f354f5c0a7",
        "body" : "Added.\n",
        "createdAt" : "2016-07-27T01:01:10Z",
        "updatedAt" : "2016-07-27T01:01:10Z",
        "lastEditedBy" : "b714495a-5740-47d4-aaaa-98f354f5c0a7",
        "tags" : [
        ]
      }
    ],
    "commit" : "cfdd085189defe565a1fd3690795326634eae7cb",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +118,122 @@  def toNonEmptyList[A](fa: F[A]): NonEmptyList[A] =\n    reduceRightTo(fa)(a => NonEmptyList(a, Nil)) { (a, lnel) =>\n      lnel.map { case NonEmptyList(h, t) => NonEmptyList(a, h :: t) }\n    }.value\n"
  },
  {
    "id" : "4a2dec2d-7773-480a-96b3-9a2918da197d",
    "prId" : 1167,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5d0fcfe3-58b5-47da-aa69-0d3898f4eccc",
        "parentId" : null,
        "authorId" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "body" : "why not `.min` to be closer to stdlib (and fewer chars).\n",
        "createdAt" : "2016-06-29T18:56:01Z",
        "updatedAt" : "2016-06-29T18:56:01Z",
        "lastEditedBy" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "tags" : [
        ]
      },
      {
        "id" : "4f5739e9-3d86-42b3-9467-82b340f6c727",
        "parentId" : "5d0fcfe3-58b5-47da-aa69-0d3898f4eccc",
        "authorId" : "b714495a-5740-47d4-aaaa-98f354f5c0a7",
        "body" : "I did this specifically to avoid collision with the std lib. If I refactor something from a `NonEmptyList` to a `List` I'd prefer to get a compile error instead of something with no type signature change but that will start throwing exceptions at runtime.\n\nHaving said that, there's a question of how much we should bend over backwards to avoid collisions with std lib names. I'm not set in stone on this if people would prefer `min`.\n",
        "createdAt" : "2016-06-29T19:07:55Z",
        "updatedAt" : "2016-06-29T19:07:55Z",
        "lastEditedBy" : "b714495a-5740-47d4-aaaa-98f354f5c0a7",
        "tags" : [
        ]
      },
      {
        "id" : "9e2f2430-21fd-444f-b437-392c598a02af",
        "parentId" : "5d0fcfe3-58b5-47da-aa69-0d3898f4eccc",
        "authorId" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "body" : "In this case you would have `Reducible[NonEmptyList].min(myThing)` how could there be a collision with the stdlib in practice? The collision could come with an implicit class that adds `.min` to any `Reducible`, and then we have anxiety, perhaps, when reading the code if we are getting the safe `Reducible` one or the stdlib (which would be safe in exactly the cases that the Reducible exists).\n\nIs that what you mean?\n",
        "createdAt" : "2016-06-29T21:03:52Z",
        "updatedAt" : "2016-06-29T21:03:52Z",
        "lastEditedBy" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "tags" : [
        ]
      },
      {
        "id" : "c78b8d79-2033-4789-bc02-58d8832d7b24",
        "parentId" : "5d0fcfe3-58b5-47da-aa69-0d3898f4eccc",
        "authorId" : "b714495a-5740-47d4-aaaa-98f354f5c0a7",
        "body" : "@johnynek yes that's what I mean, but note that we already have syntax enrichment for `Reducible`, and it's generated by Simulacrum so it will automatically inherit the name of the method on the type class.\n",
        "createdAt" : "2016-06-29T21:39:11Z",
        "updatedAt" : "2016-06-29T21:39:11Z",
        "lastEditedBy" : "b714495a-5740-47d4-aaaa-98f354f5c0a7",
        "tags" : [
        ]
      },
      {
        "id" : "88345d17-e162-46e8-969d-591d9b56c9d8",
        "parentId" : "5d0fcfe3-58b5-47da-aa69-0d3898f4eccc",
        "authorId" : "b714495a-5740-47d4-aaaa-98f354f5c0a7",
        "body" : "@johnynek do you have any further thoughts on this after my note about the syntax enrichment that currently exists?\n\nIf there's a strong preference for `min` then I can change it, but I do have a hesitation about potential refactoring bugs that could come out of it.\n",
        "createdAt" : "2016-07-16T15:10:47Z",
        "updatedAt" : "2016-07-16T15:10:47Z",
        "lastEditedBy" : "b714495a-5740-47d4-aaaa-98f354f5c0a7",
        "tags" : [
        ]
      },
      {
        "id" : "0c62c656-b812-4551-9086-dcc0d2c99b1e",
        "parentId" : "5d0fcfe3-58b5-47da-aa69-0d3898f4eccc",
        "authorId" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "body" : "I see...\n\nI'm not a huge implicit syntax fan (this example, but also confusion for novices as to where methods are coming from).\n\nBut I recognize many cats users do like this, so avoiding the collision seems safest.\n\nüëç \n",
        "createdAt" : "2016-07-18T20:45:01Z",
        "updatedAt" : "2016-07-18T20:45:01Z",
        "lastEditedBy" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "tags" : [
        ]
      }
    ],
    "commit" : "de06e6523be1111027e76b069815fdb9e53999d6",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +114,118 @@    }\n\n  def minimum[A](fa: F[A])(implicit A: Order[A]): A =\n    reduceLeft(fa)(A.min)\n"
  },
  {
    "id" : "a3788af6-9131-4a1d-8108-03c997bba865",
    "prId" : 298,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "777f1ce4-dbf3-4dc9-8f14-d3f0689fafb0",
        "parentId" : null,
        "authorId" : "b714495a-5740-47d4-aaaa-98f354f5c0a7",
        "body" : "Thanks. This is one of many really helpful comments in this PR.\n",
        "createdAt" : "2015-05-20T10:56:08Z",
        "updatedAt" : "2015-05-20T13:15:21Z",
        "lastEditedBy" : "b714495a-5740-47d4-aaaa-98f354f5c0a7",
        "tags" : [
        ]
      }
    ],
    "commit" : "d0467800edf5679f813fa76c7faef8cd8c4e58d4",
    "line" : 88,
    "diffHunk" : "@@ -1,1 +86,90 @@   * `Applicative#map2`.\n   *\n   * This method does the same thing as `Foldable#traverse_`.  The\n   * difference is that we only need `Apply[G]` here, since we don't\n   * need to call `Applicative#pure` for a starting value."
  }
]
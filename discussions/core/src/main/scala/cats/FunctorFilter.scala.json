[
  {
    "id" : "788ac26f-e78b-4519-987a-89140eb3d086",
    "prId" : 1225,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "63d22be5-649e-4074-b28e-aec51f6c3184",
        "parentId" : null,
        "authorId" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "body" : "I wonder if it is worth thinking about a typeclass for mapConcat? The law would be similar to the one here. Collections support this but also distributed compute libraries like spark and scalding.\n",
        "createdAt" : "2016-07-24T03:39:21Z",
        "updatedAt" : "2016-07-27T23:27:38Z",
        "lastEditedBy" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "tags" : [
        ]
      },
      {
        "id" : "de0181de-5034-464c-be44-58e2ec8e9edb",
        "parentId" : "63d22be5-649e-4074-b28e-aec51f6c3184",
        "authorId" : "b714495a-5740-47d4-aaaa-98f354f5c0a7",
        "body" : "@johnynek what's `mapConcat`?\n",
        "createdAt" : "2016-07-24T11:47:49Z",
        "updatedAt" : "2016-07-27T23:27:38Z",
        "lastEditedBy" : "b714495a-5740-47d4-aaaa-98f354f5c0a7",
        "tags" : [
        ]
      },
      {
        "id" : "afafdb5a-8738-4aa4-9ad4-239de50d6852",
        "parentId" : "63d22be5-649e-4074-b28e-aec51f6c3184",
        "authorId" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "body" : "`def mapConcat[A, B](fa: F[A])(f: A => Iterable[B]): F[B]` something like that.\n\nFor instance there is no `FunctorMapConcat[Option]` but there is `FunctorMapConcat[Vector]` and in the case of scalding `FunctorMapConcat[TypedPipe]`.\n",
        "createdAt" : "2016-07-25T17:33:39Z",
        "updatedAt" : "2016-07-27T23:27:38Z",
        "lastEditedBy" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "tags" : [
        ]
      },
      {
        "id" : "61951a15-a105-49bd-9ac7-2862618125a3",
        "parentId" : "63d22be5-649e-4074-b28e-aec51f6c3184",
        "authorId" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "body" : "Actually, when you think about it, it might be something like this:\n\n``` scala\ntrait FunctorArrow[F[_], A[_, _]] extends Functor[F] {\n  def arrow: Arrow[A]\n  def mapArrow[T, U](f: F[T], arrow: A[T, U]): F[U]\n}\n```\n\nAnd we are just talking about various `KleisliArrows` here.\n\nOr maybe we mean something like:\n\n``` scala\ntrait FunctorTraverse[F[_], M[_]] extends Functor[F] {\n  // this is similar to traverse, except we end up with `F[B]` not `M[F[B]]`\n  def mapTraverse[A, B](fa: F[A])(f: A => M[B]): F[B]\n}\n```\n\nIt is not clear what the right level of generalization is. It seems to me `A => M[B]` where you have `Foldable[M]` is pretty generally useful. Maybe that is the thing you want instead of mapConcat:\n\n``` scala\ntrait FunctorFoldableFn[F[_]] extend Functor[F] {\n  def mapFoldable[A, B, M[_]](f: F[A])(f: A => M[B])(implicit M: Foldable[M]): F[A]\n}\n```\n",
        "createdAt" : "2016-07-25T17:46:26Z",
        "updatedAt" : "2016-07-27T23:27:38Z",
        "lastEditedBy" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "tags" : [
        ]
      },
      {
        "id" : "f5b6acc7-b079-4cf8-ab52-8a7b92c52e17",
        "parentId" : "63d22be5-649e-4074-b28e-aec51f6c3184",
        "authorId" : "b714495a-5740-47d4-aaaa-98f354f5c0a7",
        "body" : "There was some similar discussion a long time ago [here](https://github.com/typelevel/cats/issues/842#issuecomment-178583594). I wonder what the valid laws for this construct would be and whether you would run into issues where just working with `Foldable` would mean implementations would tend to be inefficient.\n\n@johnynek were you suggesting something like this instead of `FunctorFilter` or `TraverseFilter`? I would tend to think that something like this should be in addition to these type classes. As you've mentioned you couldn't have an instance of this type class for `Option` or `OptionT`, which I think is a pretty big limitation, since they are common types to call `filter` or `collect` on. I also feel like there is some benefit to knowing these methods can never make your structure grow (they can only reduce it or leave it the same); however this is just a fuzzy feeling and not something that I can confidently say is a useful property.\n",
        "createdAt" : "2016-07-26T13:00:21Z",
        "updatedAt" : "2016-07-27T23:27:38Z",
        "lastEditedBy" : "b714495a-5740-47d4-aaaa-98f354f5c0a7",
        "tags" : [
        ]
      },
      {
        "id" : "df4d8ea2-1cba-4c7b-a6d1-ce848a33b364",
        "parentId" : "63d22be5-649e-4074-b28e-aec51f6c3184",
        "authorId" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "body" : "I was mostly thinking out loud to figure out what this should be.\n",
        "createdAt" : "2016-07-27T21:08:49Z",
        "updatedAt" : "2016-07-27T23:27:38Z",
        "lastEditedBy" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "tags" : [
        ]
      }
    ],
    "commit" : "5a67c7f86f7de78af14540e481d70f0dccacb99c",
    "line" : 22,
    "diffHunk" : "@@ -1,1 +20,24 @@   * }}}\n   */\n  def mapFilter[A, B](fa: F[A])(f: A => Option[B]): F[B]\n\n  /**"
  }
]
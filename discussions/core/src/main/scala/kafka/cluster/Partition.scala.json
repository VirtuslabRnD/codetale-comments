[
  {
    "id" : "a547f512-e82e-485d-9b91-0c31e441e23a",
    "prId" : 5436,
    "prUrl" : "https://github.com/apache/kafka/pull/5436#pullrequestreview-144051029",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a44a69a3-475e-411d-9152-a0a8c114cf4a",
        "parentId" : null,
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "I wonder if we can elaborate on this a little bit. I think the main point is that if we have somehow missed a leader epoch, then we have also missed a required truncation.",
        "createdAt" : "2018-08-07T15:32:43Z",
        "updatedAt" : "2018-08-10T19:00:12Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      }
    ],
    "commit" : "a96fb4cd18c4eb347abb75ecc132a0558c1addc2",
    "line" : 23,
    "diffHunk" : "@@ -1,1 +347,351 @@      zkVersion = partitionStateInfo.basePartitionState.zkVersion\n\n      // If the leader is unchanged and the epochs are no more than one change apart, indicate that no follower changes are required\n      // Otherwise, we missed a leader epoch update, which means the leader's log may have been truncated prior to the current epoch.\n      if (leaderReplicaIdOpt.contains(newLeaderBrokerId) && (leaderEpoch == oldLeaderEpoch || leaderEpoch == oldLeaderEpoch + 1)) {"
  },
  {
    "id" : "99e51044-4d51-4f36-9aff-7d13b6bb8b5d",
    "prId" : 5557,
    "prUrl" : "https://github.com/apache/kafka/pull/5557#pullrequestreview-150236471",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "872535fc-b063-49db-afb0-d4a5a567b269",
        "parentId" : null,
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "Is this fixing a bug in the original code with the use of `getReplica` prior to replica creation? But presumably, that would have actually caused some failure because of the call `get`?",
        "createdAt" : "2018-08-28T15:54:40Z",
        "updatedAt" : "2018-08-28T15:59:19Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      },
      {
        "id" : "b7414d3d-fd24-4c92-b214-890ff8778462",
        "parentId" : "872535fc-b063-49db-afb0-d4a5a567b269",
        "authorId" : "e235ea82-83a9-41e5-8e3a-15b2e1b6f350",
        "body" : "I moved this up because it seems safer. The code above also calls `getOrCreateReplica` for all replicas in ISR. I am not sure if we can get LeaderAndIsr for new partition where there are no replicas in ISR (in leaderAndIsr request) -- probably not? So, probably there is no bug in the original code, but still seems safer to call `createOrGetReplica` earlier, before trying to use any Replica object.",
        "createdAt" : "2018-08-28T17:35:57Z",
        "updatedAt" : "2018-08-28T17:35:57Z",
        "lastEditedBy" : "e235ea82-83a9-41e5-8e3a-15b2e1b6f350",
        "tags" : [
        ]
      }
    ],
    "commit" : "bc027ec8fc4468d3b552ba45be3b9c1c501cd0d8",
    "line" : 22,
    "diffHunk" : "@@ -1,1 +292,296 @@      (assignedReplicas.map(_.brokerId) -- newAssignedReplicas).foreach(removeReplica)\n      inSyncReplicas = newInSyncReplicas\n      newAssignedReplicas.foreach(id => getOrCreateReplica(id, partitionStateInfo.isNew))\n\n      val leaderReplica = getReplica().get"
  }
]
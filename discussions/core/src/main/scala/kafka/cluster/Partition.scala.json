[
  {
    "id" : "a547f512-e82e-485d-9b91-0c31e441e23a",
    "prId" : 5436,
    "prUrl" : "https://github.com/apache/kafka/pull/5436#pullrequestreview-144051029",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a44a69a3-475e-411d-9152-a0a8c114cf4a",
        "parentId" : null,
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "I wonder if we can elaborate on this a little bit. I think the main point is that if we have somehow missed a leader epoch, then we have also missed a required truncation.",
        "createdAt" : "2018-08-07T15:32:43Z",
        "updatedAt" : "2018-08-10T19:00:12Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      }
    ],
    "commit" : "a96fb4cd18c4eb347abb75ecc132a0558c1addc2",
    "line" : 23,
    "diffHunk" : "@@ -1,1 +347,351 @@      zkVersion = partitionStateInfo.basePartitionState.zkVersion\n\n      // If the leader is unchanged and the epochs are no more than one change apart, indicate that no follower changes are required\n      // Otherwise, we missed a leader epoch update, which means the leader's log may have been truncated prior to the current epoch.\n      if (leaderReplicaIdOpt.contains(newLeaderBrokerId) && (leaderEpoch == oldLeaderEpoch || leaderEpoch == oldLeaderEpoch + 1)) {"
  },
  {
    "id" : "99e51044-4d51-4f36-9aff-7d13b6bb8b5d",
    "prId" : 5557,
    "prUrl" : "https://github.com/apache/kafka/pull/5557#pullrequestreview-150236471",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "872535fc-b063-49db-afb0-d4a5a567b269",
        "parentId" : null,
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "Is this fixing a bug in the original code with the use of `getReplica` prior to replica creation? But presumably, that would have actually caused some failure because of the call `get`?",
        "createdAt" : "2018-08-28T15:54:40Z",
        "updatedAt" : "2018-08-28T15:59:19Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      },
      {
        "id" : "b7414d3d-fd24-4c92-b214-890ff8778462",
        "parentId" : "872535fc-b063-49db-afb0-d4a5a567b269",
        "authorId" : "e235ea82-83a9-41e5-8e3a-15b2e1b6f350",
        "body" : "I moved this up because it seems safer. The code above also calls `getOrCreateReplica` for all replicas in ISR. I am not sure if we can get LeaderAndIsr for new partition where there are no replicas in ISR (in leaderAndIsr request) -- probably not? So, probably there is no bug in the original code, but still seems safer to call `createOrGetReplica` earlier, before trying to use any Replica object.",
        "createdAt" : "2018-08-28T17:35:57Z",
        "updatedAt" : "2018-08-28T17:35:57Z",
        "lastEditedBy" : "e235ea82-83a9-41e5-8e3a-15b2e1b6f350",
        "tags" : [
        ]
      }
    ],
    "commit" : "bc027ec8fc4468d3b552ba45be3b9c1c501cd0d8",
    "line" : 22,
    "diffHunk" : "@@ -1,1 +292,296 @@      (assignedReplicas.map(_.brokerId) -- newAssignedReplicas).foreach(removeReplica)\n      inSyncReplicas = newInSyncReplicas\n      newAssignedReplicas.foreach(id => getOrCreateReplica(id, partitionStateInfo.isNew))\n\n      val leaderReplica = getReplica().get"
  },
  {
    "id" : "2b5b1a50-543d-41d3-a9c2-73749dc1cce6",
    "prId" : 5661,
    "prUrl" : "https://github.com/apache/kafka/pull/5661#pullrequestreview-160516687",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bde2abf2-d500-4968-8ad6-a74b58a05ac3",
        "parentId" : null,
        "authorId" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "body" : "Since currentLeaderEpoch is not present, do we need to hold the leaderIsrUpdateLock here?",
        "createdAt" : "2018-09-28T19:12:12Z",
        "updatedAt" : "2018-10-05T16:40:27Z",
        "lastEditedBy" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "tags" : [
        ]
      },
      {
        "id" : "cd4c4509-6bdd-47cd-9a4b-dc7362c0dfaf",
        "parentId" : "bde2abf2-d500-4968-8ad6-a74b58a05ac3",
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "I had thought we may as well protect `fetchOnlyFromLeader` behavior. Do you think it is not worthwhile?",
        "createdAt" : "2018-10-01T21:58:06Z",
        "updatedAt" : "2018-10-05T16:40:27Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      },
      {
        "id" : "70640662-0079-494c-87ef-801c96e32463",
        "parentId" : "bde2abf2-d500-4968-8ad6-a74b58a05ac3",
        "authorId" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "body" : "Ah, ok. Then, we can leave it as it is.",
        "createdAt" : "2018-10-01T22:58:21Z",
        "updatedAt" : "2018-10-05T16:40:27Z",
        "lastEditedBy" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "tags" : [
        ]
      }
    ],
    "commit" : "f9bc468a7415831841a1203315789e683066dad4",
    "line" : 392,
    "diffHunk" : "@@ -1,1 +846,850 @@                                     maxNumOffsets: Int,\n                                     isFromConsumer: Boolean,\n                                     fetchOnlyFromLeader: Boolean): Seq[Long] = inReadLock(leaderIsrUpdateLock) {\n    val localReplica = localReplicaWithEpochOrException(Optional.empty(), fetchOnlyFromLeader)\n    val allOffsets = logManager.getLog(topicPartition) match {"
  },
  {
    "id" : "febfdd47-adbc-4ff4-8291-3c98771f3254",
    "prId" : 5661,
    "prUrl" : "https://github.com/apache/kafka/pull/5661#pullrequestreview-159982255",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "129922ec-4adf-419a-b17c-d9a2d3e1a3ab",
        "parentId" : null,
        "authorId" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "body" : "Could we add the new params to the javadoc?",
        "createdAt" : "2018-09-28T20:42:07Z",
        "updatedAt" : "2018-10-05T16:40:27Z",
        "lastEditedBy" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "tags" : [
        ]
      }
    ],
    "commit" : "f9bc468a7415831841a1203315789e683066dad4",
    "line" : 482,
    "diffHunk" : "@@ -1,1 +946,950 @@   */\n  def lastOffsetForLeaderEpoch(currentLeaderEpoch: Optional[Integer],\n                               leaderEpoch: Int,\n                               fetchOnlyFromLeader: Boolean): EpochEndOffset = {\n    inReadLock(leaderIsrUpdateLock) {"
  },
  {
    "id" : "164fa80c-02e6-44ad-b37c-9153fb24f4fa",
    "prId" : 5866,
    "prUrl" : "https://github.com/apache/kafka/pull/5866#pullrequestreview-342209506",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1bd900f1-e3e0-44cf-8900-13be753bdcbc",
        "parentId" : null,
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "Not a major issue, but since `needsShrinkIsr` is exposed, maybe we can move the lock acquire to it?",
        "createdAt" : "2020-01-13T21:54:18Z",
        "updatedAt" : "2020-01-13T23:27:59Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      },
      {
        "id" : "e72f6b77-9ea0-4efa-9199-f495d5e8584d",
        "parentId" : "1bd900f1-e3e0-44cf-8900-13be753bdcbc",
        "authorId" : "b4936a15-698a-496e-85a1-b1e229b4986b",
        "body" : "Actually `needsShrinkIsr` can be private, updated. Left the lock in here to be consistent with `needsExpandIsr`.",
        "createdAt" : "2020-01-13T23:31:35Z",
        "updatedAt" : "2020-01-13T23:31:36Z",
        "lastEditedBy" : "b4936a15-698a-496e-85a1-b1e229b4986b",
        "tags" : [
        ]
      }
    ],
    "commit" : "a6e56086a2eb5d11a1e8eee59d1a7aa88d0af5ce",
    "line" : 73,
    "diffHunk" : "@@ -1,1 +835,839 @@\n  def maybeShrinkIsr(): Unit = {\n    val needsIsrUpdate = inReadLock(leaderIsrUpdateLock) {\n      needsShrinkIsr()\n    }"
  }
]
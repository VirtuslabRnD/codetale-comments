[
  {
    "id" : "a547f512-e82e-485d-9b91-0c31e441e23a",
    "prId" : 5436,
    "prUrl" : "https://github.com/apache/kafka/pull/5436#pullrequestreview-144051029",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a44a69a3-475e-411d-9152-a0a8c114cf4a",
        "parentId" : null,
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "I wonder if we can elaborate on this a little bit. I think the main point is that if we have somehow missed a leader epoch, then we have also missed a required truncation.",
        "createdAt" : "2018-08-07T15:32:43Z",
        "updatedAt" : "2018-08-10T19:00:12Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      }
    ],
    "commit" : "a96fb4cd18c4eb347abb75ecc132a0558c1addc2",
    "line" : 23,
    "diffHunk" : "@@ -1,1 +347,351 @@      zkVersion = partitionStateInfo.basePartitionState.zkVersion\n\n      // If the leader is unchanged and the epochs are no more than one change apart, indicate that no follower changes are required\n      // Otherwise, we missed a leader epoch update, which means the leader's log may have been truncated prior to the current epoch.\n      if (leaderReplicaIdOpt.contains(newLeaderBrokerId) && (leaderEpoch == oldLeaderEpoch || leaderEpoch == oldLeaderEpoch + 1)) {"
  },
  {
    "id" : "99e51044-4d51-4f36-9aff-7d13b6bb8b5d",
    "prId" : 5557,
    "prUrl" : "https://github.com/apache/kafka/pull/5557#pullrequestreview-150236471",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "872535fc-b063-49db-afb0-d4a5a567b269",
        "parentId" : null,
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "Is this fixing a bug in the original code with the use of `getReplica` prior to replica creation? But presumably, that would have actually caused some failure because of the call `get`?",
        "createdAt" : "2018-08-28T15:54:40Z",
        "updatedAt" : "2018-08-28T15:59:19Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      },
      {
        "id" : "b7414d3d-fd24-4c92-b214-890ff8778462",
        "parentId" : "872535fc-b063-49db-afb0-d4a5a567b269",
        "authorId" : "e235ea82-83a9-41e5-8e3a-15b2e1b6f350",
        "body" : "I moved this up because it seems safer. The code above also calls `getOrCreateReplica` for all replicas in ISR. I am not sure if we can get LeaderAndIsr for new partition where there are no replicas in ISR (in leaderAndIsr request) -- probably not? So, probably there is no bug in the original code, but still seems safer to call `createOrGetReplica` earlier, before trying to use any Replica object.",
        "createdAt" : "2018-08-28T17:35:57Z",
        "updatedAt" : "2018-08-28T17:35:57Z",
        "lastEditedBy" : "e235ea82-83a9-41e5-8e3a-15b2e1b6f350",
        "tags" : [
        ]
      }
    ],
    "commit" : "bc027ec8fc4468d3b552ba45be3b9c1c501cd0d8",
    "line" : 22,
    "diffHunk" : "@@ -1,1 +292,296 @@      (assignedReplicas.map(_.brokerId) -- newAssignedReplicas).foreach(removeReplica)\n      inSyncReplicas = newInSyncReplicas\n      newAssignedReplicas.foreach(id => getOrCreateReplica(id, partitionStateInfo.isNew))\n\n      val leaderReplica = getReplica().get"
  },
  {
    "id" : "2b5b1a50-543d-41d3-a9c2-73749dc1cce6",
    "prId" : 5661,
    "prUrl" : "https://github.com/apache/kafka/pull/5661#pullrequestreview-160516687",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bde2abf2-d500-4968-8ad6-a74b58a05ac3",
        "parentId" : null,
        "authorId" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "body" : "Since currentLeaderEpoch is not present, do we need to hold the leaderIsrUpdateLock here?",
        "createdAt" : "2018-09-28T19:12:12Z",
        "updatedAt" : "2018-10-05T16:40:27Z",
        "lastEditedBy" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "tags" : [
        ]
      },
      {
        "id" : "cd4c4509-6bdd-47cd-9a4b-dc7362c0dfaf",
        "parentId" : "bde2abf2-d500-4968-8ad6-a74b58a05ac3",
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "I had thought we may as well protect `fetchOnlyFromLeader` behavior. Do you think it is not worthwhile?",
        "createdAt" : "2018-10-01T21:58:06Z",
        "updatedAt" : "2018-10-05T16:40:27Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      },
      {
        "id" : "70640662-0079-494c-87ef-801c96e32463",
        "parentId" : "bde2abf2-d500-4968-8ad6-a74b58a05ac3",
        "authorId" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "body" : "Ah, ok. Then, we can leave it as it is.",
        "createdAt" : "2018-10-01T22:58:21Z",
        "updatedAt" : "2018-10-05T16:40:27Z",
        "lastEditedBy" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "tags" : [
        ]
      }
    ],
    "commit" : "f9bc468a7415831841a1203315789e683066dad4",
    "line" : 392,
    "diffHunk" : "@@ -1,1 +846,850 @@                                     maxNumOffsets: Int,\n                                     isFromConsumer: Boolean,\n                                     fetchOnlyFromLeader: Boolean): Seq[Long] = inReadLock(leaderIsrUpdateLock) {\n    val localReplica = localReplicaWithEpochOrException(Optional.empty(), fetchOnlyFromLeader)\n    val allOffsets = logManager.getLog(topicPartition) match {"
  },
  {
    "id" : "febfdd47-adbc-4ff4-8291-3c98771f3254",
    "prId" : 5661,
    "prUrl" : "https://github.com/apache/kafka/pull/5661#pullrequestreview-159982255",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "129922ec-4adf-419a-b17c-d9a2d3e1a3ab",
        "parentId" : null,
        "authorId" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "body" : "Could we add the new params to the javadoc?",
        "createdAt" : "2018-09-28T20:42:07Z",
        "updatedAt" : "2018-10-05T16:40:27Z",
        "lastEditedBy" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "tags" : [
        ]
      }
    ],
    "commit" : "f9bc468a7415831841a1203315789e683066dad4",
    "line" : 482,
    "diffHunk" : "@@ -1,1 +946,950 @@   */\n  def lastOffsetForLeaderEpoch(currentLeaderEpoch: Optional[Integer],\n                               leaderEpoch: Int,\n                               fetchOnlyFromLeader: Boolean): EpochEndOffset = {\n    inReadLock(leaderIsrUpdateLock) {"
  },
  {
    "id" : "164fa80c-02e6-44ad-b37c-9153fb24f4fa",
    "prId" : 5866,
    "prUrl" : "https://github.com/apache/kafka/pull/5866#pullrequestreview-342209506",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1bd900f1-e3e0-44cf-8900-13be753bdcbc",
        "parentId" : null,
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "Not a major issue, but since `needsShrinkIsr` is exposed, maybe we can move the lock acquire to it?",
        "createdAt" : "2020-01-13T21:54:18Z",
        "updatedAt" : "2020-01-13T23:27:59Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      },
      {
        "id" : "e72f6b77-9ea0-4efa-9199-f495d5e8584d",
        "parentId" : "1bd900f1-e3e0-44cf-8900-13be753bdcbc",
        "authorId" : "b4936a15-698a-496e-85a1-b1e229b4986b",
        "body" : "Actually `needsShrinkIsr` can be private, updated. Left the lock in here to be consistent with `needsExpandIsr`.",
        "createdAt" : "2020-01-13T23:31:35Z",
        "updatedAt" : "2020-01-13T23:31:36Z",
        "lastEditedBy" : "b4936a15-698a-496e-85a1-b1e229b4986b",
        "tags" : [
        ]
      }
    ],
    "commit" : "a6e56086a2eb5d11a1e8eee59d1a7aa88d0af5ce",
    "line" : 73,
    "diffHunk" : "@@ -1,1 +835,839 @@\n  def maybeShrinkIsr(): Unit = {\n    val needsIsrUpdate = inReadLock(leaderIsrUpdateLock) {\n      needsShrinkIsr()\n    }"
  },
  {
    "id" : "79fe17d1-6045-4bb4-8fc0-8dc83b3b2de0",
    "prId" : 6256,
    "prUrl" : "https://github.com/apache/kafka/pull/6256#pullrequestreview-204911168",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f69b05a7-a764-4095-bf1c-e243723fb674",
        "parentId" : null,
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "nit: unneeded import",
        "createdAt" : "2019-02-18T18:20:06Z",
        "updatedAt" : "2019-02-20T01:22:38Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      }
    ],
    "commit" : "69581d42d22c6fd9b5dcfecaefe9d3076b9b15ad",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +21,25 @@\nimport com.yammer.metrics.core.Gauge\nimport kafka.api.{ApiVersion, LeaderAndIsr, Request}\nimport kafka.common.UnexpectedAppendOffsetException\nimport kafka.controller.KafkaController"
  },
  {
    "id" : "40fb409b-5d48-4a41-bd3c-b9cf6cd73c73",
    "prId" : 6705,
    "prUrl" : "https://github.com/apache/kafka/pull/6705#pullrequestreview-235943245",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b27ed6e2-b190-4612-9ce6-6fcddd414b45",
        "parentId" : null,
        "authorId" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "body" : "Java doc for `highWatermarkCheckpoints`",
        "createdAt" : "2019-05-10T06:30:16Z",
        "updatedAt" : "2019-05-22T21:10:21Z",
        "lastEditedBy" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "tags" : [
        ]
      }
    ],
    "commit" : "46365108de264bfa9552bc671e6817e1158cab24",
    "line" : 289,
    "diffHunk" : "@@ -1,1 +282,286 @@    * @return true iff the future replica is created\n    */\n  def maybeCreateFutureReplica(logDir: String, highWatermarkCheckpoints: OffsetCheckpoints): Boolean = {\n    // The writeLock is needed to make sure that while the caller checks the log directory of the\n    // current replica and the existence of the future replica, no other thread can update the log directory of the"
  }
]
[
  {
    "id" : "b346327b-1e67-408a-a060-a89a20b7177b",
    "prId" : 9418,
    "prUrl" : "https://github.com/apache/kafka/pull/9418#pullrequestreview-517085254",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a161b782-c85c-4579-9647-adb329e61299",
        "parentId" : null,
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "nit: maybe add a comment indicating this function is for testing only (and hence we do not care about the correlation id).",
        "createdAt" : "2020-10-21T00:07:48Z",
        "updatedAt" : "2020-10-27T03:04:10Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "09549f61-db0c-4a6d-92a7-cc9f28263e7e",
        "parentId" : "a161b782-c85c-4579-9647-adb329e61299",
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "This was actually a bug. The implementation was treating `correlationId` as unique across all connections, which of course was wrong. My fix was just to overwrite the `correlationId` from the header with one that could be unique, but obviously this loses traceability through the Raft layer. If it's ok with you, I'd like to address this problem more generally in a follow-up. ",
        "createdAt" : "2020-10-21T21:53:01Z",
        "updatedAt" : "2020-10-27T03:04:10Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      },
      {
        "id" : "88e5da56-df38-4a09-ae10-c23a84eb8db3",
        "parentId" : "a161b782-c85c-4579-9647-adb329e61299",
        "authorId" : "4a7c311c-0954-4671-a0d2-266cb67437ad",
        "body" : "Currently, `postInboundRequest` in only used by `TestRaftRequestHandler` and `KafkaNetworkChannelTest`. Are you thinking that we will use the same or similar method when integrating with the broker code?",
        "createdAt" : "2020-10-23T18:57:32Z",
        "updatedAt" : "2020-10-27T03:04:10Z",
        "lastEditedBy" : "4a7c311c-0954-4671-a0d2-266cb67437ad",
        "tags" : [
        ]
      },
      {
        "id" : "c7363f73-5671-4afa-9c58-551348f9a68f",
        "parentId" : "a161b782-c85c-4579-9647-adb329e61299",
        "authorId" : "4a7c311c-0954-4671-a0d2-266cb67437ad",
        "body" : "Unrelated with this change but when reading the code. I was confused by the name `pollInboundResponses`. That function returns both pending request and responses.",
        "createdAt" : "2020-10-23T18:59:09Z",
        "updatedAt" : "2020-10-27T03:04:10Z",
        "lastEditedBy" : "4a7c311c-0954-4671-a0d2-266cb67437ad",
        "tags" : [
        ]
      },
      {
        "id" : "f637f415-9a0f-4fe8-b547-11e06c202354",
        "parentId" : "a161b782-c85c-4579-9647-adb329e61299",
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "> Unrelated with this change but when reading the code. I was confused by the name pollInboundResponses. That function returns both pending request and responses.\r\n\r\nI don't think that's right. It only delivers responses for outbound requests (in other words, inbound responses).\r\n\r\nIn regard to the confusion, I took an unconventional turn in the beginning by consolidating inbound and outbound requests through a single API. This was useful because it allowed inputs and outputs to be serialized, which made it easier to have deterministic simulation tests. The main defect from the perspective of Raft is that fetch requests cannot be handled concurrently. I think we are going to have to address this problem in the long term, but it is outside the scope of this PR.\r\n",
        "createdAt" : "2020-10-26T18:44:37Z",
        "updatedAt" : "2020-10-27T03:04:10Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      },
      {
        "id" : "5b9539a8-e8ca-4558-8968-2823e2fc44fd",
        "parentId" : "a161b782-c85c-4579-9647-adb329e61299",
        "authorId" : "4a7c311c-0954-4671-a0d2-266cb67437ad",
        "body" : "> I don't think that's right. It only delivers responses for outbound requests (in other words, inbound responses).\r\n\r\nHmm. I misspoke a bit. I should have said that `pollInboundResponses` returns both inbound requests and responses. These are my observations:\r\n\r\n`postInboundRequest` puts requests in `undelivered`:\r\nhttps://github.com/apache/kafka/pull/9418/files#diff-c9b2a05e69be1d2391d91a33f408eab4fde1245d4ea9cf9f52305c8cb89208ceR224\r\n\r\n`pollInboundResponses` returns everything in `undelivered`:\r\nhttps://github.com/apache/kafka/pull/9418/files#diff-c9b2a05e69be1d2391d91a33f408eab4fde1245d4ea9cf9f52305c8cb89208ceR201-R202\r\n\r\nThe raft client gets all of the inbound messages (requests and reponses) by calling `receive` which in term calls `pollInboundResponses`:\r\nhttps://github.com/apache/kafka/pull/9418/files#diff-1da15c51e641ea46ea5c86201ab8f21cfee9e7c575102a39c7bae0d5ffd7de39L1596",
        "createdAt" : "2020-10-26T18:54:43Z",
        "updatedAt" : "2020-10-27T03:04:10Z",
        "lastEditedBy" : "4a7c311c-0954-4671-a0d2-266cb67437ad",
        "tags" : [
        ]
      },
      {
        "id" : "5568fa6f-d821-4165-a005-7aa9472d2151",
        "parentId" : "a161b782-c85c-4579-9647-adb329e61299",
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "My mistake. This _was_ being used for both inbound requests and responses. Let me change the name and add some docs.",
        "createdAt" : "2020-10-26T18:56:56Z",
        "updatedAt" : "2020-10-27T03:04:10Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      }
    ],
    "commit" : "fac5c0a9507f9f40f99dac017242d12500a97d5d",
    "line" : 49,
    "diffHunk" : "@@ -1,1 +225,229 @@  }\n\n  def postInboundRequest(request: AbstractRequest, onResponseReceived: ResponseHandler): Unit = {\n    val data = requestData(request)\n    val correlationId = newCorrelationId()"
  },
  {
    "id" : "a2304a70-5050-4dd0-a921-693e361ebbfa",
    "prId" : 9732,
    "prUrl" : "https://github.com/apache/kafka/pull/9732#pullrequestreview-552721559",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "38c83bb7-0be2-462f-8bc2-bbce973306e2",
        "parentId" : null,
        "authorId" : "083f2f03-ca7e-48a1-9781-482564dfdf53",
        "body" : "style nit/question: I think we have a mixture of argument indentation for Scala classes/methods. Do we have an established style convention for this? Normally I follow the opening paren when breaking out arguments into their own line (though I'm not sure that's correct)",
        "createdAt" : "2020-12-15T17:16:24Z",
        "updatedAt" : "2020-12-21T20:43:49Z",
        "lastEditedBy" : "083f2f03-ca7e-48a1-9781-482564dfdf53",
        "tags" : [
        ]
      },
      {
        "id" : "dca461c5-16f8-439d-8c6d-962d62fcd533",
        "parentId" : "38c83bb7-0be2-462f-8bc2-bbce973306e2",
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "Not really as far as I know. This is my favored style of late because it results in consistent alignment of parameters. I get really annoyed when I see stuff like this:\r\n```\r\ndef someMethodWithAnArguablyOverVerboseName(foo: String,\r\n                                            bar: Option[List[Int]]): (Option[String], List[String)\r\n\r\ndef concicseMethod(foo: String,\r\n                   bar: String): Unit = {\r\n```\r\nNo matter how you look at it, it seems hideous.",
        "createdAt" : "2020-12-15T17:55:59Z",
        "updatedAt" : "2020-12-21T20:43:49Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      }
    ],
    "commit" : "c31ba33f2ffb1144e0acbe975ddf45cc5d4065bc",
    "line" : 58,
    "diffHunk" : "@@ -1,1 +55,59 @@}\n\nprivate[raft] class RaftSendThread(\n  name: String,\n  networkClient: KafkaClient,"
  },
  {
    "id" : "a43ad965-15d8-44ed-81c6-82d1f88ee80c",
    "prId" : 9839,
    "prUrl" : "https://github.com/apache/kafka/pull/9839#pullrequestreview-563722722",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "762017fd-b55f-42f4-a10d-12c6ae8c73c3",
        "parentId" : null,
        "authorId" : "0f776378-bb23-4193-9bb0-1db5973f3781",
        "body" : "Is this a bug fix?",
        "createdAt" : "2021-01-07T05:26:18Z",
        "updatedAt" : "2021-01-08T18:44:35Z",
        "lastEditedBy" : "0f776378-bb23-4193-9bb0-1db5973f3781",
        "tags" : [
        ]
      },
      {
        "id" : "82309500-1bdf-4eb6-b425-f13086da6c26",
        "parentId" : "762017fd-b55f-42f4-a10d-12c6ae8c73c3",
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "Yes indeed, thanks for noticing. I guess your point is that we should have a test case. Let me see about writing one.",
        "createdAt" : "2021-01-07T18:28:34Z",
        "updatedAt" : "2021-01-08T18:44:35Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      }
    ],
    "commit" : "8c3044ff0c003b732cb84c35a9352b9914498e74",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +88,92 @@  def sendRequest(request: RequestAndCompletionHandler): Unit = {\n    queue.add(request)\n    wakeup()\n  }\n"
  },
  {
    "id" : "55b8511e-fa33-4175-92cd-96b730b5717b",
    "prId" : 10157,
    "prUrl" : "https://github.com/apache/kafka/pull/10157#pullrequestreview-594982659",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b314d902-47b1-4ebb-8c86-5974e6c56091",
        "parentId" : null,
        "authorId" : "d8c7cf80-a55a-474c-a4f4-f60a9efda52c",
        "body" : "Why do we treat authentication problems as retriable?",
        "createdAt" : "2021-02-20T19:02:21Z",
        "updatedAt" : "2021-02-22T16:35:16Z",
        "lastEditedBy" : "d8c7cf80-a55a-474c-a4f4-f60a9efda52c",
        "tags" : [
        ]
      },
      {
        "id" : "c22549a3-e32e-4f98-adcc-d1b783083c8c",
        "parentId" : "b314d902-47b1-4ebb-8c86-5974e6c56091",
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "I agree it is debatable. If we make it a fatal error, I think we would do so under the expectation that the broker receiving the authentication failure is the one misconfigured. However, that may or may not be true. If a misconfigured broker tries to join the cluster, it could end up crashing all of the other brokers through authentication failures. Perhaps what we want is for authentication failures to be fatal during some initial window when the broker is starting up and non-fatal afterwards. In any case, because we do not have a good mechanism in place here to propagate fatal errors, it seemed simpler to treat it as retriable.",
        "createdAt" : "2021-02-20T20:51:03Z",
        "updatedAt" : "2021-02-22T16:35:16Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      },
      {
        "id" : "22e35308-7045-4fca-99df-656ee6cbcf75",
        "parentId" : "b314d902-47b1-4ebb-8c86-5974e6c56091",
        "authorId" : "d8c7cf80-a55a-474c-a4f4-f60a9efda52c",
        "body" : "Makes sense. Let's file a JIRA to improve it as you suggested here.",
        "createdAt" : "2021-02-21T22:22:29Z",
        "updatedAt" : "2021-02-22T16:35:16Z",
        "lastEditedBy" : "d8c7cf80-a55a-474c-a4f4-f60a9efda52c",
        "tags" : [
        ]
      },
      {
        "id" : "1ac42d72-1f4a-4847-9edc-5c66d9dfa47a",
        "parentId" : "b314d902-47b1-4ebb-8c86-5974e6c56091",
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "Filed this: https://issues.apache.org/jira/browse/KAFKA-12355.",
        "createdAt" : "2021-02-22T03:09:56Z",
        "updatedAt" : "2021-02-22T16:35:16Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      }
    ],
    "commit" : "6dcc4bdeefebe062e0f03c6264c84cd7c917e145",
    "line" : 17,
    "diffHunk" : "@@ -1,1 +136,140 @@        error(s\"Request $request failed due to authentication error\",\n          clientResponse.authenticationException)\n        errorResponse(request.data, Errors.NETWORK_EXCEPTION)\n      } else if (clientResponse.wasDisconnected()) {\n        errorResponse(request.data, Errors.BROKER_NOT_AVAILABLE)"
  }
]
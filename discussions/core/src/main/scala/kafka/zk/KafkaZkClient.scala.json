[
  {
    "id" : "554ba59b-b4bf-40ee-a695-e9c4544b033f",
    "prId" : 4351,
    "prUrl" : "https://github.com/apache/kafka/pull/4351#pullrequestreview-85251105",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fb1c6111-1cb9-4355-a1b6-a7e547727211",
        "parentId" : null,
        "authorId" : "915b2f67-05e6-4824-939a-398e7be58870",
        "body" : "nit: typo \"borker\"",
        "createdAt" : "2017-12-22T07:15:17Z",
        "updatedAt" : "2017-12-22T08:37:57Z",
        "lastEditedBy" : "915b2f67-05e6-4824-939a-398e7be58870",
        "tags" : [
        ]
      }
    ],
    "commit" : "d10b7657e7d5ebc621fbbf1c9ed6402af7cc63a1",
    "line" : 75,
    "diffHunk" : "@@ -1,1 +1218,1222 @@\n  /**\n    * Generate a borker id by updating the broker sequence id path in ZK and return the version of the path.\n    * The version is incremented by one on every update starting from 1.\n    * @return sequence number as the broker id"
  },
  {
    "id" : "668943c2-5116-4c9a-b297-7bb09c8d3a95",
    "prId" : 4596,
    "prUrl" : "https://github.com/apache/kafka/pull/4596#pullrequestreview-97932517",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8a9363d2-8013-4364-b380-fe9db8b803f5",
        "parentId" : null,
        "authorId" : "915b2f67-05e6-4824-939a-398e7be58870",
        "body" : "good catch.",
        "createdAt" : "2018-02-20T18:14:32Z",
        "updatedAt" : "2018-03-01T22:48:10Z",
        "lastEditedBy" : "915b2f67-05e6-4824-939a-398e7be58870",
        "tags" : [
        ]
      }
    ],
    "commit" : "6e2b0c8a6d7003c6c14373983ff6e06405fbcde9",
    "line" : 15,
    "diffHunk" : "@@ -1,1 +423,427 @@    val getChildrenResponse = retryRequestUntilConnected(GetChildrenRequest(LogDirEventNotificationZNode.path))\n    if (getChildrenResponse.resultCode == Code.OK) {\n      deleteLogDirEventNotifications(getChildrenResponse.children.map(LogDirEventNotificationSequenceZNode.sequenceNumber))\n    } else if (getChildrenResponse.resultCode != Code.NONODE) {\n      getChildrenResponse.maybeThrow"
  },
  {
    "id" : "7d805898-922b-4c24-be62-10e67a32c36a",
    "prId" : 4727,
    "prUrl" : "https://github.com/apache/kafka/pull/4727#pullrequestreview-104757347",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "75a3f813-fca2-4f01-8144-0bc8c5a73c42",
        "parentId" : null,
        "authorId" : "d8c7cf80-a55a-474c-a4f4-f60a9efda52c",
        "body" : "I think this makes sense for 1.1 and to get the tests passing again, but maybe calling `zkClient.createTopLevelPaths()` from the config tool is a better long term solution. We can do the latter in a separate PR (I can include it in a related clean-up PR that I have been working on for too long).",
        "createdAt" : "2018-03-17T00:11:15Z",
        "updatedAt" : "2018-03-17T00:11:23Z",
        "lastEditedBy" : "d8c7cf80-a55a-474c-a4f4-f60a9efda52c",
        "tags" : [
        ]
      },
      {
        "id" : "ca1015d2-94bb-4435-b7d5-3eef5a698a49",
        "parentId" : "75a3f813-fca2-4f01-8144-0bc8c5a73c42",
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "Sounds good to me. I considered doing just that in fact, but decided for the incremental fix instead.",
        "createdAt" : "2018-03-17T05:27:14Z",
        "updatedAt" : "2018-03-17T05:27:14Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      }
    ],
    "commit" : "2e3905db686f8a3d1f5a4b2fb306e7e5948ad9a5",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +287,291 @@   */\n  def createConfigChangeNotification(sanitizedEntityPath: String): Unit = {\n    makeSurePersistentPathExists(ConfigEntityChangeNotificationZNode.path)\n    val path = ConfigEntityChangeNotificationSequenceZNode.createPath\n    val createRequest = CreateRequest(path, ConfigEntityChangeNotificationSequenceZNode.encode(sanitizedEntityPath), acls(path), CreateMode.PERSISTENT_SEQUENTIAL)"
  },
  {
    "id" : "5eea906f-1f65-4825-84c0-157cc0ff581a",
    "prId" : 5161,
    "prUrl" : "https://github.com/apache/kafka/pull/5161#pullrequestreview-128095958",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "aba62d13-7e8f-4f9c-af31-6aa35fdc3f04",
        "parentId" : null,
        "authorId" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "body" : "The comment of the method should be adjusted to \"Creates the required zk nodes for Acl storage and Acl change storage\".",
        "createdAt" : "2018-06-12T17:28:36Z",
        "updatedAt" : "2018-06-12T18:40:32Z",
        "lastEditedBy" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "tags" : [
        ]
      },
      {
        "id" : "12b33aff-ae7a-40d7-8b43-2c9af8c4d435",
        "parentId" : "aba62d13-7e8f-4f9c-af31-6aa35fdc3f04",
        "authorId" : "e431deb4-a19e-4e78-a775-12af049c9089",
        "body" : "Done.",
        "createdAt" : "2018-06-12T18:36:26Z",
        "updatedAt" : "2018-06-12T18:40:32Z",
        "lastEditedBy" : "e431deb4-a19e-4e78-a775-12af049c9089",
        "tags" : [
        ]
      }
    ],
    "commit" : "23bb972dc517ee4efdc54a4703e6d89602b8241a",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +950,954 @@    })\n\n    ZkAclChangeStore.stores.foreach(store => createRecursive(store.aclChangePath, throwIfPathExists = false))\n  }\n"
  },
  {
    "id" : "3096f926-8720-495c-9b7f-d18caca9cf35",
    "prId" : 5259,
    "prUrl" : "https://github.com/apache/kafka/pull/5259#pullrequestreview-131388424",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f82be847-1421-4cd2-a7d5-204a772405d7",
        "parentId" : null,
        "authorId" : "0c73d886-f3da-4107-8045-92d8e3c8fb75",
        "body" : "The second parameter can be replaced with configData, right ?",
        "createdAt" : "2018-06-23T08:08:41Z",
        "updatedAt" : "2018-06-23T08:08:41Z",
        "lastEditedBy" : "0c73d886-f3da-4107-8045-92d8e3c8fb75",
        "tags" : [
        ]
      }
    ],
    "commit" : "abda862dee625c5fb0ce6f2d3077c5cac61e151f",
    "line" : 21,
    "diffHunk" : "@@ -1,1 +266,270 @@    def createOrSet(configData: Array[Byte]): Unit = {\n      val path = ConfigEntityZNode.path(rootEntityType, sanitizedEntityName)\n      try createRecursive(path, ConfigEntityZNode.encode(config))\n      catch {\n        case _: NodeExistsException => set(configData).maybeThrow"
  }
]
[
  {
    "id" : "554ba59b-b4bf-40ee-a695-e9c4544b033f",
    "prId" : 4351,
    "prUrl" : "https://github.com/apache/kafka/pull/4351#pullrequestreview-85251105",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fb1c6111-1cb9-4355-a1b6-a7e547727211",
        "parentId" : null,
        "authorId" : "915b2f67-05e6-4824-939a-398e7be58870",
        "body" : "nit: typo \"borker\"",
        "createdAt" : "2017-12-22T07:15:17Z",
        "updatedAt" : "2017-12-22T08:37:57Z",
        "lastEditedBy" : "915b2f67-05e6-4824-939a-398e7be58870",
        "tags" : [
        ]
      }
    ],
    "commit" : "d10b7657e7d5ebc621fbbf1c9ed6402af7cc63a1",
    "line" : 75,
    "diffHunk" : "@@ -1,1 +1218,1222 @@\n  /**\n    * Generate a borker id by updating the broker sequence id path in ZK and return the version of the path.\n    * The version is incremented by one on every update starting from 1.\n    * @return sequence number as the broker id"
  },
  {
    "id" : "668943c2-5116-4c9a-b297-7bb09c8d3a95",
    "prId" : 4596,
    "prUrl" : "https://github.com/apache/kafka/pull/4596#pullrequestreview-97932517",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8a9363d2-8013-4364-b380-fe9db8b803f5",
        "parentId" : null,
        "authorId" : "915b2f67-05e6-4824-939a-398e7be58870",
        "body" : "good catch.",
        "createdAt" : "2018-02-20T18:14:32Z",
        "updatedAt" : "2018-03-01T22:48:10Z",
        "lastEditedBy" : "915b2f67-05e6-4824-939a-398e7be58870",
        "tags" : [
        ]
      }
    ],
    "commit" : "6e2b0c8a6d7003c6c14373983ff6e06405fbcde9",
    "line" : 15,
    "diffHunk" : "@@ -1,1 +423,427 @@    val getChildrenResponse = retryRequestUntilConnected(GetChildrenRequest(LogDirEventNotificationZNode.path))\n    if (getChildrenResponse.resultCode == Code.OK) {\n      deleteLogDirEventNotifications(getChildrenResponse.children.map(LogDirEventNotificationSequenceZNode.sequenceNumber))\n    } else if (getChildrenResponse.resultCode != Code.NONODE) {\n      getChildrenResponse.maybeThrow"
  },
  {
    "id" : "7d805898-922b-4c24-be62-10e67a32c36a",
    "prId" : 4727,
    "prUrl" : "https://github.com/apache/kafka/pull/4727#pullrequestreview-104757347",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "75a3f813-fca2-4f01-8144-0bc8c5a73c42",
        "parentId" : null,
        "authorId" : "d8c7cf80-a55a-474c-a4f4-f60a9efda52c",
        "body" : "I think this makes sense for 1.1 and to get the tests passing again, but maybe calling `zkClient.createTopLevelPaths()` from the config tool is a better long term solution. We can do the latter in a separate PR (I can include it in a related clean-up PR that I have been working on for too long).",
        "createdAt" : "2018-03-17T00:11:15Z",
        "updatedAt" : "2018-03-17T00:11:23Z",
        "lastEditedBy" : "d8c7cf80-a55a-474c-a4f4-f60a9efda52c",
        "tags" : [
        ]
      },
      {
        "id" : "ca1015d2-94bb-4435-b7d5-3eef5a698a49",
        "parentId" : "75a3f813-fca2-4f01-8144-0bc8c5a73c42",
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "Sounds good to me. I considered doing just that in fact, but decided for the incremental fix instead.",
        "createdAt" : "2018-03-17T05:27:14Z",
        "updatedAt" : "2018-03-17T05:27:14Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      }
    ],
    "commit" : "2e3905db686f8a3d1f5a4b2fb306e7e5948ad9a5",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +287,291 @@   */\n  def createConfigChangeNotification(sanitizedEntityPath: String): Unit = {\n    makeSurePersistentPathExists(ConfigEntityChangeNotificationZNode.path)\n    val path = ConfigEntityChangeNotificationSequenceZNode.createPath\n    val createRequest = CreateRequest(path, ConfigEntityChangeNotificationSequenceZNode.encode(sanitizedEntityPath), acls(path), CreateMode.PERSISTENT_SEQUENTIAL)"
  },
  {
    "id" : "5eea906f-1f65-4825-84c0-157cc0ff581a",
    "prId" : 5161,
    "prUrl" : "https://github.com/apache/kafka/pull/5161#pullrequestreview-128095958",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "aba62d13-7e8f-4f9c-af31-6aa35fdc3f04",
        "parentId" : null,
        "authorId" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "body" : "The comment of the method should be adjusted to \"Creates the required zk nodes for Acl storage and Acl change storage\".",
        "createdAt" : "2018-06-12T17:28:36Z",
        "updatedAt" : "2018-06-12T18:40:32Z",
        "lastEditedBy" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "tags" : [
        ]
      },
      {
        "id" : "12b33aff-ae7a-40d7-8b43-2c9af8c4d435",
        "parentId" : "aba62d13-7e8f-4f9c-af31-6aa35fdc3f04",
        "authorId" : "e431deb4-a19e-4e78-a775-12af049c9089",
        "body" : "Done.",
        "createdAt" : "2018-06-12T18:36:26Z",
        "updatedAt" : "2018-06-12T18:40:32Z",
        "lastEditedBy" : "e431deb4-a19e-4e78-a775-12af049c9089",
        "tags" : [
        ]
      }
    ],
    "commit" : "23bb972dc517ee4efdc54a4703e6d89602b8241a",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +950,954 @@    })\n\n    ZkAclChangeStore.stores.foreach(store => createRecursive(store.aclChangePath, throwIfPathExists = false))\n  }\n"
  },
  {
    "id" : "3096f926-8720-495c-9b7f-d18caca9cf35",
    "prId" : 5259,
    "prUrl" : "https://github.com/apache/kafka/pull/5259#pullrequestreview-131388424",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f82be847-1421-4cd2-a7d5-204a772405d7",
        "parentId" : null,
        "authorId" : "0c73d886-f3da-4107-8045-92d8e3c8fb75",
        "body" : "The second parameter can be replaced with configData, right ?",
        "createdAt" : "2018-06-23T08:08:41Z",
        "updatedAt" : "2018-06-23T08:08:41Z",
        "lastEditedBy" : "0c73d886-f3da-4107-8045-92d8e3c8fb75",
        "tags" : [
        ]
      }
    ],
    "commit" : "abda862dee625c5fb0ce6f2d3077c5cac61e151f",
    "line" : 21,
    "diffHunk" : "@@ -1,1 +266,270 @@    def createOrSet(configData: Array[Byte]): Unit = {\n      val path = ConfigEntityZNode.path(rootEntityType, sanitizedEntityName)\n      try createRecursive(path, ConfigEntityZNode.encode(config))\n      catch {\n        case _: NodeExistsException => set(configData).maybeThrow"
  },
  {
    "id" : "6ec2d2cc-4cb8-47a8-a353-e458e4ce6039",
    "prId" : 5575,
    "prUrl" : "https://github.com/apache/kafka/pull/5575#pullrequestreview-169654919",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2ba4e54f-caf1-49ca-b921-101410fb72a4",
        "parentId" : null,
        "authorId" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "body" : "Could we add some comments why we need this and that we want to remove this once ZOOKEEPER-2985 is fixed?",
        "createdAt" : "2018-10-29T23:49:59Z",
        "updatedAt" : "2018-11-08T18:13:38Z",
        "lastEditedBy" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "tags" : [
        ]
      },
      {
        "id" : "8e4b7dbb-6a0d-48f0-a94c-5bb779788d15",
        "parentId" : "2ba4e54f-caf1-49ca-b921-101410fb72a4",
        "authorId" : "d247117d-335e-4fd3-b317-b598d1fea4b3",
        "body" : "Yes, is definitely needed, I will add a comment with the appropriated references.\r\nOnce again, thanks for the heads up.",
        "createdAt" : "2018-10-30T08:29:45Z",
        "updatedAt" : "2018-11-08T18:13:38Z",
        "lastEditedBy" : "d247117d-335e-4fd3-b317-b598d1fea4b3",
        "tags" : [
        ]
      }
    ],
    "commit" : "b0e2df540d41a0b83892bdbb759af229223c94d9",
    "line" : 119,
    "diffHunk" : "@@ -1,1 +1718,1722 @@        // This code is part of the work around done in the KAFKA-7165, once ZOOKEEPER-2985 is complete, this code must\n        // be deleted.\n        case Code.OK if shouldReCreateEphemeralZNode(ephemeralOwnerId) =>\n          info(s\"Was not possible to create the ephemeral at $path, node already exists and owner \" +\n            s\"'$ephemeralOwnerId' does not match current session '${zooKeeperClient.sessionId}'\" +"
  },
  {
    "id" : "bcee3e7b-61bd-43e9-a9ce-ecc991a3f9ae",
    "prId" : 5575,
    "prUrl" : "https://github.com/apache/kafka/pull/5575#pullrequestreview-170406320",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d68ac224-5ad2-49ae-984b-7c3e61b7437d",
        "parentId" : null,
        "authorId" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "body" : "Do we really need this? Could we just create a subclass of KafkaZkClient and overwrite the return value of shouldReCreateEphemeralZNode() in the test?",
        "createdAt" : "2018-10-29T23:51:19Z",
        "updatedAt" : "2018-11-08T18:13:38Z",
        "lastEditedBy" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "tags" : [
        ]
      },
      {
        "id" : "65928f19-a91f-4fa7-a889-579e7d314f87",
        "parentId" : "d68ac224-5ad2-49ae-984b-7c3e61b7437d",
        "authorId" : "d247117d-335e-4fd3-b317-b598d1fea4b3",
        "body" : "As you pointed out, this is a momentaneous workaround to tackle the issue. I have thought on a more elegant way to do it, as you propose. Probably am opting for the simples but not elegant solution for this. The rationale behind my proposal is:\r\n\r\n- Keeping everything in the same place/file (now with the comments you suggested is better), in this way, the workaround is framed to a single place.\r\n- Once the Zookeeper issue is addressed properly, we just have to come to this file/class and delete this code.\r\n\r\nHaving said that, am more than happy to change it if you think is better :)",
        "createdAt" : "2018-10-30T08:56:37Z",
        "updatedAt" : "2018-11-08T18:13:38Z",
        "lastEditedBy" : "d247117d-335e-4fd3-b317-b598d1fea4b3",
        "tags" : [
        ]
      },
      {
        "id" : "7870f2a5-1a5b-450f-b2fc-d7799c9af9f5",
        "parentId" : "d68ac224-5ad2-49ae-984b-7c3e61b7437d",
        "authorId" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "body" : "Yes, I am mostly after simplicity. The patch as it is seems a bit hard for me to read. Part of that is to have to understand the meaning of 2 separate ZK session ids and when they are updated. I thought maintaining just one session id var could be simpler. With regard to keeping things in one place, I guess in either case, we have to change the test case when this logic is eventually removed?",
        "createdAt" : "2018-10-30T18:27:25Z",
        "updatedAt" : "2018-11-08T18:13:38Z",
        "lastEditedBy" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "tags" : [
        ]
      },
      {
        "id" : "fa66f460-0205-4f99-a19e-4840c9f752b7",
        "parentId" : "d68ac224-5ad2-49ae-984b-7c3e61b7437d",
        "authorId" : "d247117d-335e-4fd3-b317-b598d1fea4b3",
        "body" : "Yes, it makes sense, am changing the code to achieve that. ðŸ‘ ",
        "createdAt" : "2018-10-31T18:24:50Z",
        "updatedAt" : "2018-11-08T18:13:38Z",
        "lastEditedBy" : "d247117d-335e-4fd3-b317-b598d1fea4b3",
        "tags" : [
        ]
      }
    ],
    "commit" : "b0e2df540d41a0b83892bdbb759af229223c94d9",
    "line" : 17,
    "diffHunk" : "@@ -1,1 +72,76 @@  // This code is part of the work around done in the KAFKA-7165, once ZOOKEEPER-2985 is complete, this code must\n  // be deleted.\n  private var currentZooKeeperSessionId: Long = -1\n\n  /**"
  },
  {
    "id" : "19afbdc9-ef8a-4256-86c1-ab5153729e87",
    "prId" : 5575,
    "prUrl" : "https://github.com/apache/kafka/pull/5575#pullrequestreview-171333869",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "022a02d3-1b4c-46b5-b748-ffdbcb94ef85",
        "parentId" : null,
        "authorId" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "body" : "It seems that if code is NoNode, we should just let it go.",
        "createdAt" : "2018-11-03T00:09:19Z",
        "updatedAt" : "2018-11-08T18:13:38Z",
        "lastEditedBy" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "tags" : [
        ]
      },
      {
        "id" : "502e9b97-6f14-4f63-9633-8e9cce5a8f2c",
        "parentId" : "022a02d3-1b4c-46b5-b748-ffdbcb94ef85",
        "authorId" : "d247117d-335e-4fd3-b317-b598d1fea4b3",
        "body" : "@junrao sorry, but I do not get this comment.\r\nIs true (after you point this out) that at the moment we try to delete the ephemeral znode, it could not be present anymore an a `NoNode` response will be received, and because we are just checking `if (codeAfterDelete == Code.OK)` the `created()` call will not be performed, hence, the Broker will be not registered. Is that what you meant?\r\n\r\nIf so, will be adding `if (codeAfterDelete == Code.OK || codeAfterDelete == Code.NONODE)`?\r\n\r\nHope you can help me to understand your point.\r\n\r\nCheers!",
        "createdAt" : "2018-11-03T13:00:56Z",
        "updatedAt" : "2018-11-08T18:13:38Z",
        "lastEditedBy" : "d247117d-335e-4fd3-b317-b598d1fea4b3",
        "tags" : [
        ]
      },
      {
        "id" : "7d61923f-3d2a-409d-8a93-1cb01e3b8a39",
        "parentId" : "022a02d3-1b4c-46b5-b748-ffdbcb94ef85",
        "authorId" : "d247117d-335e-4fd3-b317-b598d1fea4b3",
        "body" : "Or this?\r\n```\r\ndeleteResponse.resultCode match {\r\n        case code@ Code.OK => code\r\n        \r\n\r\n      > case code@ Code.NONODE => code\r\n\r\n        case code =>\r\n          error(s\"Error while deleting ephemeral node at $path with return code: $code\")\r\n          code\r\n}\r\n```",
        "createdAt" : "2018-11-03T13:12:03Z",
        "updatedAt" : "2018-11-08T18:13:38Z",
        "lastEditedBy" : "d247117d-335e-4fd3-b317-b598d1fea4b3",
        "tags" : [
        ]
      },
      {
        "id" : "88fe34a7-fdd3-401d-a03f-c2a2fa30a3f7",
        "parentId" : "022a02d3-1b4c-46b5-b748-ffdbcb94ef85",
        "authorId" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "body" : "Yes, it seems that if the node doesn't exist (ZK server could have deleted), we should still do the create() instead of returning an error code.",
        "createdAt" : "2018-11-03T16:50:09Z",
        "updatedAt" : "2018-11-08T18:13:38Z",
        "lastEditedBy" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "tags" : [
        ]
      }
    ],
    "commit" : "b0e2df540d41a0b83892bdbb759af229223c94d9",
    "line" : 88,
    "diffHunk" : "@@ -1,1 +1688,1692 @@        case code@ Code.OK => code\n        case code@ Code.NONODE => code\n        case code =>\n          error(s\"Error while deleting ephemeral node at $path with return code: $code\")\n          code"
  },
  {
    "id" : "000a1eb8-7cdd-4b8f-a07a-3698dfb2c693",
    "prId" : 5575,
    "prUrl" : "https://github.com/apache/kafka/pull/5575#pullrequestreview-172248000",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "600b6034-16bd-4f81-9809-0845598f7df2",
        "parentId" : null,
        "authorId" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "body" : "Could we just move the call to updateCurrentZKSessionId() here? This way, there will be a single place where updateCurrentZKSessionId() will be called.",
        "createdAt" : "2018-11-05T21:27:02Z",
        "updatedAt" : "2018-11-08T18:13:38Z",
        "lastEditedBy" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "tags" : [
        ]
      },
      {
        "id" : "c641bf37-bd0d-4e17-a3e5-4e0e3ad8008e",
        "parentId" : "600b6034-16bd-4f81-9809-0845598f7df2",
        "authorId" : "d247117d-335e-4fd3-b317-b598d1fea4b3",
        "body" : "Hmmmm, where exactly @junrao?\r\n\r\nWe are setting the `currentZooKeeperSessionId` at the end of `private def checkedEphemeralCreate(path: String, data: Array[Byte])` method, this ensures that the first time the broker tries to registered we have the session Id used.\r\n\r\nIf we do not do that, the method `isZKSessionTheEphemeralOwner` will return `false` (since `-1 != zooKeeperClient.sessionId`) and will not try to recreate the ephemeral node.\r\n\r\nThen we are setting `currentZooKeeperSessionId` again if the condition `case Code.OK if shouldReCreateEphemeralZNode(ephemeralOwnerId) =>` applies, becase this will update the `currentZooKeeperSessionId` with the newest session, useful when trying to recreate the ephemeral node.\r\n\r\nAm pretty sure am missing something since you point this out, but I can not see it, hope you can give me a clue :) \r\n",
        "createdAt" : "2018-11-06T13:51:56Z",
        "updatedAt" : "2018-11-08T18:13:38Z",
        "lastEditedBy" : "d247117d-335e-4fd3-b317-b598d1fea4b3",
        "tags" : [
        ]
      },
      {
        "id" : "abf84bb6-057e-4871-9aa0-efeb0b9a142d",
        "parentId" : "600b6034-16bd-4f81-9809-0845598f7df2",
        "authorId" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "body" : "Sorry, I didn't make it clear. Basically, we want to set the session id after a successful creation of the ephemeral path. I was thinking  that we can call updateCurrentZKSessionId() after line 1667 in CheckedEphemeral.create() when the return code is ok. Then, we don't need to call updateCurrentZKSessionId() anywhere else.",
        "createdAt" : "2018-11-06T21:34:56Z",
        "updatedAt" : "2018-11-08T18:13:38Z",
        "lastEditedBy" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "tags" : [
        ]
      },
      {
        "id" : "305a9c81-eb3f-478e-8460-443b04715f89",
        "parentId" : "600b6034-16bd-4f81-9809-0845598f7df2",
        "authorId" : "d247117d-335e-4fd3-b317-b598d1fea4b3",
        "body" : "+1",
        "createdAt" : "2018-11-06T21:46:01Z",
        "updatedAt" : "2018-11-08T18:13:38Z",
        "lastEditedBy" : "d247117d-335e-4fd3-b317-b598d1fea4b3",
        "tags" : [
        ]
      }
    ],
    "commit" : "b0e2df540d41a0b83892bdbb759af229223c94d9",
    "line" : 86,
    "diffHunk" : "@@ -1,1 +1686,1690 @@      val deleteResponse = retryRequestUntilConnected(deleteRequest)\n      deleteResponse.resultCode match {\n        case code@ Code.OK => code\n        case code@ Code.NONODE => code\n        case code =>"
  },
  {
    "id" : "ae577f94-90db-4e91-b489-a0e99e62bbf7",
    "prId" : 5575,
    "prUrl" : "https://github.com/apache/kafka/pull/5575#pullrequestreview-172623331",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4fb2277f-449e-4efd-b831-9ac8ad05e1b8",
        "parentId" : null,
        "authorId" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "body" : "Do we need to expose package level visibility for this method?",
        "createdAt" : "2018-11-06T23:13:04Z",
        "updatedAt" : "2018-11-08T18:13:38Z",
        "lastEditedBy" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "tags" : [
        ]
      },
      {
        "id" : "06f24f3e-a024-4c1c-a961-4356030ae325",
        "parentId" : "4fb2277f-449e-4efd-b831-9ac8ad05e1b8",
        "authorId" : "d247117d-335e-4fd3-b317-b598d1fea4b3",
        "body" : "Is to take advantage of that method to perform the call to Zookeeper.\r\n\r\nI can move the method `getPathCzxid` present in the class `ExpiredKafkaZkClient` from the test, to the class `KafkaZkClient` (but not useful in that class `KafkaZkClient`).\r\n\r\nOr I can add more code just to make the call to Zookeeper to get the `czxid` in the class `ExpiredKafkaZkClient`\r\n\r\nWhat do you think?",
        "createdAt" : "2018-11-07T18:03:34Z",
        "updatedAt" : "2018-11-08T18:13:38Z",
        "lastEditedBy" : "d247117d-335e-4fd3-b317-b598d1fea4b3",
        "tags" : [
        ]
      }
    ],
    "commit" : "b0e2df540d41a0b83892bdbb759af229223c94d9",
    "line" : 27,
    "diffHunk" : "@@ -1,1 +1592,1596 @@  private def acls(path: String): Seq[ACL] = ZkData.defaultAcls(isSecure, path)\n\n  private[zk] def retryRequestUntilConnected[Req <: AsyncRequest](request: Req): Req#Response = {\n    retryRequestsUntilConnected(Seq(request)).head\n  }"
  },
  {
    "id" : "4daf581b-0f47-45fd-8653-1562bee5461f",
    "prId" : 5575,
    "prUrl" : "https://github.com/apache/kafka/pull/5575#pullrequestreview-173100832",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "70abe666-3be3-4774-a299-cda661628ea0",
        "parentId" : null,
        "authorId" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "body" : "Perhaps the code can be simplified a bit as the following?\r\n\r\n```\r\n      val createResultCode = \r\n        createResponse.resultCode match {\r\n          case code@ Code.OK =>\r\n            code\r\n          case Code.NODEEXISTS =>\r\n            getAfterNodeExists()\r\n          case code =>\r\n            error(s\"Error while creating ephemeral at $path with return code: $code\")\r\n            code\r\n      }\r\n```",
        "createdAt" : "2018-11-08T00:37:59Z",
        "updatedAt" : "2018-11-08T18:13:38Z",
        "lastEditedBy" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "tags" : [
        ]
      },
      {
        "id" : "73458355-00d8-4c2f-8989-717c6409ae54",
        "parentId" : "70abe666-3be3-4774-a299-cda661628ea0",
        "authorId" : "d247117d-335e-4fd3-b317-b598d1fea4b3",
        "body" : "Yes, it definitely is simpler and allow use to use `val` instead of `var`.\r\nDoing it.",
        "createdAt" : "2018-11-08T18:12:08Z",
        "updatedAt" : "2018-11-08T18:13:38Z",
        "lastEditedBy" : "d247117d-335e-4fd3-b317-b598d1fea4b3",
        "tags" : [
        ]
      }
    ],
    "commit" : "b0e2df540d41a0b83892bdbb759af229223c94d9",
    "line" : 66,
    "diffHunk" : "@@ -1,1 +1666,1670 @@          error(s\"Error while creating ephemeral at $path with return code: $code\")\n          code\n      }\n\n      if (createResultCode == Code.OK) {"
  },
  {
    "id" : "5ffd0b9a-207a-494a-af3e-bc5a7584403e",
    "prId" : 5821,
    "prUrl" : "https://github.com/apache/kafka/pull/5821#pullrequestreview-173692995",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c039fe94-b3d6-40cd-b250-739840cc068b",
        "parentId" : null,
        "authorId" : "220f032c-6592-42d9-9042-aed276632816",
        "body" : "Now we have three methods named `retryRequestsUntilConnected(...)`. I am wondering if it would be more readable to keep the number still as two, one for single request and the other for sequence of requests. One thing that may be confusing to the reader is that, `retryRequestsUntilConnected[Req <: AsyncRequest](requests: Seq[Req])` does not take `expectedControllerZkVersion` as parameter and thus it is not clear what is the expected behavior with controller epoch check in this method.",
        "createdAt" : "2018-11-07T00:23:49Z",
        "updatedAt" : "2018-12-01T16:57:02Z",
        "lastEditedBy" : "220f032c-6592-42d9-9042-aed276632816",
        "tags" : [
        ]
      },
      {
        "id" : "a2f6c934-f670-4ee4-a519-36fe2c8a4b9d",
        "parentId" : "c039fe94-b3d6-40cd-b250-739840cc068b",
        "authorId" : "e9f2a5b6-a46b-4418-b0e8-3a587ddbbf67",
        "body" : "I am a little bit confused about your concern. There is no controller epoch check in `retryRequestsUntilConnected[Req <: AsyncRequest](requests: Seq[Req])` because this is the raw method that only does send requests as well as receive responses, and the epoch check happens outside of this method when calling `wrapRequestWithControllerEpochCheck` and `unwrapResponseWithControllerEpochCheck`. Maybe I understand you wrong, I think there is little confusion here.\r\n\r\nDo you suggest only have `retryRequestsUntilConnected[Req <: AsyncRequest](requests: Seq[Req], expectedControllerEpochZkVersion: Int)` and `retryRequestsUntilConnected[Req <: AsyncRequest](request: Req, expectedControllerEpochZkVersion: Int)`?",
        "createdAt" : "2018-11-07T23:09:38Z",
        "updatedAt" : "2018-12-01T16:57:02Z",
        "lastEditedBy" : "e9f2a5b6-a46b-4418-b0e8-3a587ddbbf67",
        "tags" : [
        ]
      },
      {
        "id" : "8f083ffa-2315-4fef-8432-db6e2b468954",
        "parentId" : "c039fe94-b3d6-40cd-b250-739840cc068b",
        "authorId" : "220f032c-6592-42d9-9042-aed276632816",
        "body" : "Right, that is what I would suggest to reduce the overloaded methods number from 3 to 2. Now looking at it again, the current way also looks good.",
        "createdAt" : "2018-11-11T10:46:07Z",
        "updatedAt" : "2018-12-01T16:57:02Z",
        "lastEditedBy" : "220f032c-6592-42d9-9042-aed276632816",
        "tags" : [
        ]
      }
    ],
    "commit" : "aec83c36f2b7f46b7ffc1990f56e60f0a9811149",
    "line" : 303,
    "diffHunk" : "@@ -1,1 +1643,1647 @@  }\n\n  private def retryRequestsUntilConnected[Req <: AsyncRequest](requests: Seq[Req], expectedControllerZkVersion: Int): Seq[Req#Response] = {\n    expectedControllerZkVersion match {\n      case ZkVersion.MatchAnyVersion => retryRequestsUntilConnected(requests)"
  },
  {
    "id" : "d3d5c1ec-39b5-4cb0-b048-7ff086dd0e6b",
    "prId" : 5821,
    "prUrl" : "https://github.com/apache/kafka/pull/5821#pullrequestreview-173655681",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a1192e37-b724-42e3-9657-8fffd83dcfdd",
        "parentId" : null,
        "authorId" : "220f032c-6592-42d9-9042-aed276632816",
        "body" : "Can we also throw `IllegalStateException` if `zkOpResults` does not match the pattern `Seq(ZkOpResult(checkOp: CheckOp, checkOpResult), zkOpResult)`?",
        "createdAt" : "2018-11-07T00:27:31Z",
        "updatedAt" : "2018-12-01T16:57:02Z",
        "lastEditedBy" : "220f032c-6592-42d9-9042-aed276632816",
        "tags" : [
        ]
      },
      {
        "id" : "2dcb96e7-9e1f-4316-891f-e41c99de7b3d",
        "parentId" : "a1192e37-b724-42e3-9657-8fffd83dcfdd",
        "authorId" : "e9f2a5b6-a46b-4418-b0e8-3a587ddbbf67",
        "body" : "Sure. Done.",
        "createdAt" : "2018-11-10T08:55:02Z",
        "updatedAt" : "2018-12-01T16:57:02Z",
        "lastEditedBy" : "e9f2a5b6-a46b-4418-b0e8-3a587ddbbf67",
        "tags" : [
        ]
      }
    ],
    "commit" : "aec83c36f2b7f46b7ffc1990f56e60f0a9811149",
    "line" : 493,
    "diffHunk" : "@@ -1,1 +1852,1856 @@      case MultiResponse(resultCode, _, ctx, zkOpResults, responseMetadata) =>\n        zkOpResults match {\n          case Seq(ZkOpResult(checkOp: CheckOp, checkOpResult), zkOpResult) =>\n            checkOpResult match {\n              case errorResult: ErrorResult =>"
  },
  {
    "id" : "6b71490d-907a-4d6c-8265-6df63bc4f7b9",
    "prId" : 5821,
    "prUrl" : "https://github.com/apache/kafka/pull/5821#pullrequestreview-172756891",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6415694f-05cf-46d4-813a-b47230d2898b",
        "parentId" : null,
        "authorId" : "220f032c-6592-42d9-9042-aed276632816",
        "body" : "Now the patch is not longer using zookeeper transaction, will there be issue if e.g. controller znode is created but the controller epoch is not incremented?",
        "createdAt" : "2018-11-07T00:50:29Z",
        "updatedAt" : "2018-12-01T16:57:02Z",
        "lastEditedBy" : "220f032c-6592-42d9-9042-aed276632816",
        "tags" : [
        ]
      },
      {
        "id" : "73d4e281-dc59-46d4-a2c9-f8934b70be89",
        "parentId" : "6415694f-05cf-46d4-813a-b47230d2898b",
        "authorId" : "e9f2a5b6-a46b-4418-b0e8-3a587ddbbf67",
        "body" : "It is fine because we are using the zookeeper multi op directly right now. It is essentially the same as using zk transaction so we still provide the same guarantee.",
        "createdAt" : "2018-11-08T00:02:31Z",
        "updatedAt" : "2018-12-01T16:57:02Z",
        "lastEditedBy" : "e9f2a5b6-a46b-4418-b0e8-3a587ddbbf67",
        "tags" : [
        ]
      }
    ],
    "commit" : "aec83c36f2b7f46b7ffc1990f56e60f0a9811149",
    "line" : 70,
    "diffHunk" : "@@ -1,1 +140,144 @@\n    def tryCreateControllerZNodeAndIncrementEpoch(): (Int, Int) = {\n      val response = retryRequestUntilConnected(\n        MultiRequest(Seq(\n          CreateOp(ControllerZNode.path, ControllerZNode.encode(controllerId, timestamp), defaultAcls(ControllerZNode.path), CreateMode.EPHEMERAL),"
  },
  {
    "id" : "51a7271a-eeda-4aae-953a-1ea706600376",
    "prId" : 5821,
    "prUrl" : "https://github.com/apache/kafka/pull/5821#pullrequestreview-173730368",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7a759b15-e800-4abf-bff0-ff6e70e348f5",
        "parentId" : null,
        "authorId" : "220f032c-6592-42d9-9042-aed276632816",
        "body" : "nits: It seems that intellIj complains here. Can you change it to `getSortedBrokerList()`.",
        "createdAt" : "2018-11-11T10:24:33Z",
        "updatedAt" : "2018-12-01T16:57:02Z",
        "lastEditedBy" : "220f032c-6592-42d9-9042-aed276632816",
        "tags" : [
        ]
      },
      {
        "id" : "8e67dd47-0b9c-4f65-af93-563f639932a5",
        "parentId" : "7a759b15-e800-4abf-bff0-ff6e70e348f5",
        "authorId" : "e9f2a5b6-a46b-4418-b0e8-3a587ddbbf67",
        "body" : "Fixed.",
        "createdAt" : "2018-11-12T01:46:39Z",
        "updatedAt" : "2018-12-01T16:57:02Z",
        "lastEditedBy" : "e9f2a5b6-a46b-4418-b0e8-3a587ddbbf67",
        "tags" : [
        ]
      }
    ],
    "commit" : "aec83c36f2b7f46b7ffc1990f56e60f0a9811149",
    "line" : 118,
    "diffHunk" : "@@ -1,1 +416,420 @@    */\n  def getAllBrokerAndEpochsInCluster: Map[Broker, Long] = {\n    val brokerIds = getSortedBrokerList\n    val getDataRequests = brokerIds.map(brokerId => GetDataRequest(BrokerIdZNode.path(brokerId), ctx = Some(brokerId)))\n    val getDataResponses = retryRequestsUntilConnected(getDataRequests)"
  },
  {
    "id" : "b5933ae5-b9c0-47b6-b373-b490f1763630",
    "prId" : 5821,
    "prUrl" : "https://github.com/apache/kafka/pull/5821#pullrequestreview-174057210",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5e3cbe0b-192b-4773-9a87-4c3e1cb241b2",
        "parentId" : null,
        "authorId" : "220f032c-6592-42d9-9042-aed276632816",
        "body" : "According to the zookeeper client Javadoc, the name in `CreateResponse` is expected to be `The name of the Znode that was created`. Also, it is mentioned that `On success, <i>name</i> and <i>path</i> are usually, equal, unless a sequential node has been created`.\r\n\r\nOn the other hand, the Javadoc for `CreateResult` says that, `A result from a create operation.  This kind of result allows the path to be retrieved since the create might have been a sequential create`.\r\n\r\nWe need to make sure that the `CreateResult.path` has the same value as the original value of the `name` in `CreateResponse` when a sequential node is created. The Javadoc  `CreateResult` suggests this is the case but the name of its variable, i.e. `path`, suggests they are different. Can you double check this by creating a sequential znode?\r\n\r\n",
        "createdAt" : "2018-11-12T08:08:05Z",
        "updatedAt" : "2018-12-01T16:57:02Z",
        "lastEditedBy" : "220f032c-6592-42d9-9042-aed276632816",
        "tags" : [
        ]
      },
      {
        "id" : "495b1f90-f0a3-4d0b-9f70-01b750c6934e",
        "parentId" : "5e3cbe0b-192b-4773-9a87-4c3e1cb241b2",
        "authorId" : "e9f2a5b6-a46b-4418-b0e8-3a587ddbbf67",
        "body" : "Both zookeeper `CreateRequest` and `CreateResponse` use the field `path` to represent the resulting path (can handle the sequential create case). I think what you think it is confusing is that when we are using zookeeper async create, the `processResult` methond in `StringCallback` has a `path` field to represent the path included in the request and has a `name` field to represent the resulting path.\r\n\r\nI double check zookeeper source code and zookeeper client (to be more specific, in `ClientCnxn.java`). The logic to invoke the callback is:\r\n```\r\n...\r\nelse if (p.response instanceof CreateResponse) {\r\n                      StringCallback cb = (StringCallback) p.cb;\r\n                      CreateResponse rsp = (CreateResponse) p.response;\r\n                      if (rc == 0) {\r\n                          cb.processResult(rc, clientPath, p.ctx,\r\n                                  (chrootPath == null\r\n                                          ? rsp.getPath()\r\n                                          : rsp.getPath()\r\n                                    .substring(chrootPath.length())));\r\n                      } else {\r\n                          cb.processResult(rc, clientPath, p.ctx, null);\r\n                      }\r\n                  }\r\n...\r\n```\r\nThe 2nd argument in `processResult` is `path` and the 4th argument is `name`. This confirms that we use `rsp.getPath()` for the `name` in `processResult`.",
        "createdAt" : "2018-11-12T18:25:36Z",
        "updatedAt" : "2018-12-01T16:57:02Z",
        "lastEditedBy" : "e9f2a5b6-a46b-4418-b0e8-3a587ddbbf67",
        "tags" : [
        ]
      },
      {
        "id" : "c673f502-4d56-492b-b7b8-57d9501afb8e",
        "parentId" : "5e3cbe0b-192b-4773-9a87-4c3e1cb241b2",
        "authorId" : "220f032c-6592-42d9-9042-aed276632816",
        "body" : "Sounds good. Thanks for the explanation.",
        "createdAt" : "2018-11-12T19:25:59Z",
        "updatedAt" : "2018-12-01T16:57:02Z",
        "lastEditedBy" : "220f032c-6592-42d9-9042-aed276632816",
        "tags" : [
        ]
      }
    ],
    "commit" : "aec83c36f2b7f46b7ffc1990f56e60f0a9811149",
    "line" : 510,
    "diffHunk" : "@@ -1,1 +1869,1873 @@              case createOp: CreateOp =>\n                val name = rawOpResult match {\n                  case c: CreateResult => c.getPath\n                  case _ => null\n                }"
  },
  {
    "id" : "2654ac9e-0d43-4a54-baba-d76ce9df3fe2",
    "prId" : 5821,
    "prUrl" : "https://github.com/apache/kafka/pull/5821#pullrequestreview-179633168",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e04b8748-80b0-411e-ad50-9fd16511e6d9",
        "parentId" : null,
        "authorId" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "body" : "This may be an existing problem. If a ZK multi fails because of one of the operations, does that error get reflected in the rc in the top level response or in individual ZkOpResult?",
        "createdAt" : "2018-11-16T00:24:48Z",
        "updatedAt" : "2018-12-01T16:57:02Z",
        "lastEditedBy" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "tags" : [
        ]
      },
      {
        "id" : "89c8d659-ca87-4e5c-8a57-a628bfd214bf",
        "parentId" : "e04b8748-80b0-411e-ad50-9fd16511e6d9",
        "authorId" : "e9f2a5b6-a46b-4418-b0e8-3a587ddbbf67",
        "body" : "Code from zookeeper (ClientCnxn.java):\r\n```\r\n...\r\nelse if (p.response instanceof MultiResponse) {\r\n  MultiCallback cb = (MultiCallback) p.cb;\r\n  MultiResponse rsp = (MultiResponse) p.response;\r\n  if (rc == 0) {\r\n          List<OpResult> results = rsp.getResultList();\r\n          int newRc = rc;\r\n          for (OpResult result : results) {\r\n                  if (result instanceof ErrorResult\r\n                      && KeeperException.Code.OK.intValue()\r\n                          != (newRc = ((ErrorResult) result).getErr())) {\r\n                          break;\r\n                  }\r\n          }\r\n          cb.processResult(newRc, clientPath, p.ctx, results);\r\n  } else {\r\n          cb.processResult(rc, clientPath, p.ctx, null);\r\n  }\r\n}\r\n...\r\n```\r\nThis suggests that if we can get back the OpResult from zookeeper (no CONNECTION_LOSS), rc represents the first error in the operations. So using the rc in the top level response after unwrapping the multi response is fine becuase the first error will also be the actual error for create/setData/delete if we pass the controller epoch check.\r\n\r\nThis also suggests that List[OpResult] can be null in the callback and I don't handle this in our ZookeeperClient so I will fix it.",
        "createdAt" : "2018-11-16T10:13:25Z",
        "updatedAt" : "2018-12-01T16:57:02Z",
        "lastEditedBy" : "e9f2a5b6-a46b-4418-b0e8-3a587ddbbf67",
        "tags" : [
        ]
      },
      {
        "id" : "9105b9ce-54fc-457a-98e7-f135224c80ec",
        "parentId" : "e04b8748-80b0-411e-ad50-9fd16511e6d9",
        "authorId" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "body" : "Thanks. Since the code still uses the rc in the individual ops, it seems that we need to change it to check the top level rc?",
        "createdAt" : "2018-11-28T01:05:33Z",
        "updatedAt" : "2018-12-01T16:57:02Z",
        "lastEditedBy" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "tags" : [
        ]
      },
      {
        "id" : "0a12ad46-e855-46c7-9a34-2e8c1bf74799",
        "parentId" : "e04b8748-80b0-411e-ad50-9fd16511e6d9",
        "authorId" : "e9f2a5b6-a46b-4418-b0e8-3a587ddbbf67",
        "body" : "We need to use the rc in the individual ops (check and create/delete/set) because we need to differentiate whether the error happened in the controller epoch znode zkVersion check or in create/delete/set. The OpResut for the Check op will reflect whether it has succeeded or not.  If it succeeds, the top level rc will reflect the error happened in create/delete/set and we do use top level rc when constrcuting the response for create/delete/set. If the Check op fails, we will throw exception accordingly.",
        "createdAt" : "2018-11-29T05:27:45Z",
        "updatedAt" : "2018-12-01T16:57:02Z",
        "lastEditedBy" : "e9f2a5b6-a46b-4418-b0e8-3a587ddbbf67",
        "tags" : [
        ]
      }
    ],
    "commit" : "aec83c36f2b7f46b7ffc1990f56e60f0a9811149",
    "line" : 495,
    "diffHunk" : "@@ -1,1 +1854,1858 @@          case Seq(ZkOpResult(checkOp: CheckOp, checkOpResult), zkOpResult) =>\n            checkOpResult match {\n              case errorResult: ErrorResult =>\n                if (checkOp.path.equals(ControllerEpochZNode.path)) {\n                  val errorCode = Code.get(errorResult.getErr)"
  },
  {
    "id" : "de1705fd-abee-4f89-8bcc-92d913d1f8c3",
    "prId" : 5821,
    "prUrl" : "https://github.com/apache/kafka/pull/5821#pullrequestreview-179633447",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4799164c-e7af-4f88-bbed-78072b80210f",
        "parentId" : null,
        "authorId" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "body" : "Is it still useful to log in the above line since codeAfterReCreate hasn't changed?",
        "createdAt" : "2018-11-16T01:04:43Z",
        "updatedAt" : "2018-12-01T16:57:02Z",
        "lastEditedBy" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "tags" : [
        ]
      },
      {
        "id" : "1c045621-29db-4674-9d0c-46376f74f23a",
        "parentId" : "4799164c-e7af-4f88-bbed-78072b80210f",
        "authorId" : "e9f2a5b6-a46b-4418-b0e8-3a587ddbbf67",
        "body" : "No. My bad. I have removed the log.",
        "createdAt" : "2018-11-29T05:29:33Z",
        "updatedAt" : "2018-12-01T16:57:02Z",
        "lastEditedBy" : "e9f2a5b6-a46b-4418-b0e8-3a587ddbbf67",
        "tags" : [
        ]
      }
    ],
    "commit" : "aec83c36f2b7f46b7ffc1990f56e60f0a9811149",
    "line" : 410,
    "diffHunk" : "@@ -1,1 +1755,1759 @@      debug(s\"Result of znode ephemeral deletion at $path is: $codeAfterDelete\")\n      if (codeAfterDelete == Code.OK || codeAfterDelete == Code.NONODE) {\n        create()\n      } else {\n        throw KeeperException.create(codeAfterReCreate)"
  },
  {
    "id" : "6e54f32e-79a8-478b-ad31-288305fc7abe",
    "prId" : 6258,
    "prUrl" : "https://github.com/apache/kafka/pull/6258#pullrequestreview-203385103",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "32c6675f-4c85-46f5-832b-f3692af7ce8d",
        "parentId" : null,
        "authorId" : "d8c7cf80-a55a-474c-a4f4-f60a9efda52c",
        "body" : "@junrao Please check that this is OK.",
        "createdAt" : "2019-02-12T15:15:12Z",
        "updatedAt" : "2019-02-14T04:07:44Z",
        "lastEditedBy" : "d8c7cf80-a55a-474c-a4f4-f60a9efda52c",
        "tags" : [
        ]
      },
      {
        "id" : "52f6a555-d301-4ea3-ab13-5e40f48ec95a",
        "parentId" : "32c6675f-4c85-46f5-832b-f3692af7ce8d",
        "authorId" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "body" : "@ijuma : Yes, this part looks good to me.",
        "createdAt" : "2019-02-13T18:50:41Z",
        "updatedAt" : "2019-02-14T04:07:44Z",
        "lastEditedBy" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "tags" : [
        ]
      }
    ],
    "commit" : "b0d70daf55fabceeb379062c4641749466d771c5",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +1881,1885 @@                }\n                SetDataResponse(resultCode, setDataOp.path, ctx, stat, responseMetadata)\n              case zkOp => throw new IllegalStateException(s\"Unexpected zkOp: $zkOp\")\n            }\n          case null => throw KeeperException.create(resultCode)"
  }
]
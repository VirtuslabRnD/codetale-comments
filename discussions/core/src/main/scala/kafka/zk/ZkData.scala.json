[
  {
    "id" : "53e63f08-999a-46aa-9269-ea765e5314d2",
    "prId" : 4351,
    "prUrl" : "https://github.com/apache/kafka/pull/4351#pullrequestreview-85275179",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "13c59b9f-8bc1-4a09-809e-f4a3d8dbbc1f",
        "parentId" : null,
        "authorId" : "d8c7cf80-a55a-474c-a4f4-f60a9efda52c",
        "body" : "Shouldn't we do this for `Broker` and `User` as well?",
        "createdAt" : "2017-12-22T10:11:36Z",
        "updatedAt" : "2017-12-22T10:27:00Z",
        "lastEditedBy" : "d8c7cf80-a55a-474c-a4f4-f60a9efda52c",
        "tags" : [
        ]
      }
    ],
    "commit" : "d10b7657e7d5ebc621fbbf1c9ed6402af7cc63a1",
    "line" : 51,
    "diffHunk" : "@@ -1,1 +373,377 @@    ConfigEntityChangeNotificationZNode.path,\n    ConfigEntityTypeZNode.path(ConfigType.Topic),\n    ConfigEntityTypeZNode.path(ConfigType.Client),\n    DeleteTopicsZNode.path,\n    BrokerSequenceIdZNode.path,"
  },
  {
    "id" : "1618a336-922e-48b7-891a-76146952979d",
    "prId" : 5152,
    "prUrl" : "https://github.com/apache/kafka/pull/5152#pullrequestreview-126938739",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "92c70747-db0d-416f-b075-33bdbc17967e",
        "parentId" : null,
        "authorId" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "body" : "Probably better to say \"invalid name type\" since rather than \"Unknown name type\", since the name type may not be UNKNOWN ",
        "createdAt" : "2018-06-07T18:23:31Z",
        "updatedAt" : "2018-06-08T11:50:22Z",
        "lastEditedBy" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "tags" : [
        ]
      },
      {
        "id" : "fc3c7326-e11b-408b-a435-ff59bba42ae2",
        "parentId" : "92c70747-db0d-416f-b075-33bdbc17967e",
        "authorId" : "e431deb4-a19e-4e78-a775-12af049c9089",
        "body" : "Done, (but in an up coming PR)",
        "createdAt" : "2018-06-07T20:12:10Z",
        "updatedAt" : "2018-06-08T11:50:22Z",
        "lastEditedBy" : "e431deb4-a19e-4e78-a775-12af049c9089",
        "tags" : [
        ]
      }
    ],
    "commit" : "269b948c3911f007467b220cb9d65e5ab9ca3dc2",
    "line" : 22,
    "diffHunk" : "@@ -1,1 +462,466 @@    case ResourceNameType.LITERAL => \"/kafka-acl\"\n    case ResourceNameType.PREFIXED => \"/kafka-prefixed-acl\"\n    case _ => throw new IllegalArgumentException(\"Unknown name type:\" + nameType)\n  }\n"
  },
  {
    "id" : "9d26f4e1-a136-4684-ad19-19ee67fd909c",
    "prId" : 5152,
    "prUrl" : "https://github.com/apache/kafka/pull/5152#pullrequestreview-126938831",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "928ae0b1-1b22-4697-b54e-09577cad0488",
        "parentId" : null,
        "authorId" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "body" : "\r\n\r\nProbably better to say \"invalid name type\" since rather than \"Unknown name type\", since the name type may not be UNKNOWN\r\n",
        "createdAt" : "2018-06-07T18:23:43Z",
        "updatedAt" : "2018-06-08T11:50:22Z",
        "lastEditedBy" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "tags" : [
        ]
      },
      {
        "id" : "7853e0d4-5292-46c5-96c6-ef2323a9b41d",
        "parentId" : "928ae0b1-1b22-4697-b54e-09577cad0488",
        "authorId" : "e431deb4-a19e-4e78-a775-12af049c9089",
        "body" : "Removed in an upcoming PR.",
        "createdAt" : "2018-06-07T20:12:26Z",
        "updatedAt" : "2018-06-08T11:50:22Z",
        "lastEditedBy" : "e431deb4-a19e-4e78-a775-12af049c9089",
        "tags" : [
        ]
      }
    ],
    "commit" : "269b948c3911f007467b220cb9d65e5ab9ca3dc2",
    "line" : 30,
    "diffHunk" : "@@ -1,1 +468,472 @@    case ResourceNameType.LITERAL => \"/kafka-acl-changes\"\n    case ResourceNameType.PREFIXED => \"/kafka-prefixed-acl-changes\"\n    case _ => throw new IllegalArgumentException(\"Unknown name type:\" + nameType)\n  }\n"
  },
  {
    "id" : "e712ed38-20d0-40ca-8073-815e46f3810c",
    "prId" : 5161,
    "prUrl" : "https://github.com/apache/kafka/pull/5161#pullrequestreview-127695011",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8554c10f-ef20-4941-9458-43872b5c0a26",
        "parentId" : null,
        "authorId" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "body" : "unused imports Failure, Success",
        "createdAt" : "2018-06-11T15:56:43Z",
        "updatedAt" : "2018-06-12T18:40:32Z",
        "lastEditedBy" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "tags" : [
        ]
      },
      {
        "id" : "9d5d8416-7542-418b-aed8-053bf46b6109",
        "parentId" : "8554c10f-ef20-4941-9458-43872b5c0a26",
        "authorId" : "e431deb4-a19e-4e78-a775-12af049c9089",
        "body" : "Done.",
        "createdAt" : "2018-06-11T18:49:33Z",
        "updatedAt" : "2018-06-12T18:40:32Z",
        "lastEditedBy" : "e431deb4-a19e-4e78-a775-12af049c9089",
        "tags" : [
        ]
      }
    ],
    "commit" : "23bb972dc517ee4efdc54a4703e6d89602b8241a",
    "line" : 21,
    "diffHunk" : "@@ -1,1 +45,49 @@import scala.collection.mutable.ArrayBuffer\nimport scala.collection.{Seq, breakOut}\nimport scala.util.{Failure, Success, Try}\n\n// This file contains objects for encoding/decoding data stored in ZooKeeper nodes (znodes)."
  },
  {
    "id" : "267387b8-afe8-4eb8-b43b-5c1b8d7697f4",
    "prId" : 5161,
    "prUrl" : "https://github.com/apache/kafka/pull/5161#pullrequestreview-128041853",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5a36d327-1cbe-4327-b259-4c98219a6e44",
        "parentId" : null,
        "authorId" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "body" : "We could store literal patterns under the new path, right?\r\n\r\nIt's more like, the old path can only have LITERAL patterns, but the new path can have that and other stuff.",
        "createdAt" : "2018-06-12T15:20:43Z",
        "updatedAt" : "2018-06-12T18:40:32Z",
        "lastEditedBy" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "tags" : [
        ]
      },
      {
        "id" : "8c2e1c13-4261-4fbf-bc79-6f150a1d5b44",
        "parentId" : "5a36d327-1cbe-4327-b259-4c98219a6e44",
        "authorId" : "e431deb4-a19e-4e78-a775-12af049c9089",
        "body" : "If we stored any literal under the new path old brokers wouldn't pick them up. So for now all literal go under the old path.",
        "createdAt" : "2018-06-12T16:14:24Z",
        "updatedAt" : "2018-06-12T18:40:32Z",
        "lastEditedBy" : "e431deb4-a19e-4e78-a775-12af049c9089",
        "tags" : [
        ]
      }
    ],
    "commit" : "23bb972dc517ee4efdc54a4703e6d89602b8241a",
    "line" : 37,
    "diffHunk" : "@@ -1,1 +455,459 @@  *   The format is JSON. See [[kafka.zk.ResourceZNode]] for details.</li>\n  *   <li>All other patterns are stored under '/kafka-acl-extended/<i>pattern-type</i>'.\n  *   The format is JSON. See [[kafka.zk.ResourceZNode]] for details.</li>\n  * </ul>\n  *"
  },
  {
    "id" : "754ad148-d3ad-4d91-ac89-489aa0c64b53",
    "prId" : 5161,
    "prUrl" : "https://github.com/apache/kafka/pull/5161#pullrequestreview-128042040",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8e806cbe-d8f0-49de-bb83-b031c566164e",
        "parentId" : null,
        "authorId" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "body" : "Why not have a JSON field describing prefixed vs. literal vs. whatever?  That would cut down on the number of ZK paths we have to listen to.",
        "createdAt" : "2018-06-12T15:22:54Z",
        "updatedAt" : "2018-06-12T18:40:32Z",
        "lastEditedBy" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "tags" : [
        ]
      },
      {
        "id" : "a24bc5c1-487b-4c9b-8e9d-f1b50f2c754a",
        "parentId" : "8e806cbe-d8f0-49de-bb83-b031c566164e",
        "authorId" : "e431deb4-a19e-4e78-a775-12af049c9089",
        "body" : "As discussed, not possible, as we'd get ZK path clashes between pattern types.",
        "createdAt" : "2018-06-12T16:14:52Z",
        "updatedAt" : "2018-06-12T18:40:32Z",
        "lastEditedBy" : "e431deb4-a19e-4e78-a775-12af049c9089",
        "tags" : [
        ]
      }
    ],
    "commit" : "23bb972dc517ee4efdc54a4703e6d89602b8241a",
    "line" : 51,
    "diffHunk" : "@@ -1,1 +468,472 @@  *\n  * // Prefixed patterns:\n  * /kafka-acl-extended/PREFIXED/Group/group-1 => {\"version\": 1, \"acls\": [ { \"host\":\"host1\", \"permissionType\": \"Allow\",\"operation\": \"Read\",\"principal\": \"User:alice\"}]}\n  * </pre>\n  *"
  },
  {
    "id" : "2ac442d0-5d66-46fe-bb10-7376f88aed42",
    "prId" : 5161,
    "prUrl" : "https://github.com/apache/kafka/pull/5161#pullrequestreview-128095453",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "78758471-0804-4e3b-afc2-ffa849ad2176",
        "parentId" : null,
        "authorId" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "body" : "Do we need to extend from AutoCloseable since close() doesn't throw exception?",
        "createdAt" : "2018-06-12T17:11:56Z",
        "updatedAt" : "2018-06-12T18:40:32Z",
        "lastEditedBy" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "tags" : [
        ]
      },
      {
        "id" : "d2b8cfe3-8a45-47dc-8c82-409286e8d904",
        "parentId" : "78758471-0804-4e3b-afc2-ffa849ad2176",
        "authorId" : "e431deb4-a19e-4e78-a775-12af049c9089",
        "body" : "Yep.",
        "createdAt" : "2018-06-12T18:35:11Z",
        "updatedAt" : "2018-06-12T18:40:32Z",
        "lastEditedBy" : "e431deb4-a19e-4e78-a775-12af049c9089",
        "tags" : [
        ]
      }
    ],
    "commit" : "23bb972dc517ee4efdc54a4703e6d89602b8241a",
    "line" : 138,
    "diffHunk" : "@@ -1,1 +536,540 @@}\n\ntrait AclChangeSubscription extends AutoCloseable {\n  def close(): Unit\n}"
  },
  {
    "id" : "5fbc2f63-7556-4015-aa8b-f477cc62b5a7",
    "prId" : 7128,
    "prUrl" : "https://github.com/apache/kafka/pull/7128#pullrequestreview-268573715",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ae9747e2-3cef-49ba-a8eb-621165817f5c",
        "parentId" : null,
        "authorId" : "df911192-d6c6-4af9-8568-f67bf2dcf926",
        "body" : "Do we need to bump the version here?",
        "createdAt" : "2019-07-30T18:09:38Z",
        "updatedAt" : "2019-09-09T17:48:38Z",
        "lastEditedBy" : "df911192-d6c6-4af9-8568-f67bf2dcf926",
        "tags" : [
        ]
      }
    ],
    "commit" : "8538961c460c50be1828a050793f45d8558ea9b9",
    "line" : 54,
    "diffHunk" : "@@ -1,1 +255,259 @@\n    Json.encodeAsBytes(Map(\n      \"version\" -> 2,\n      \"partitions\" -> replicaAssignmentJson.asJava,\n      \"addingReplicas\" -> addingReplicasAssignmentJson.asJava,"
  },
  {
    "id" : "b9baa097-13d8-43f5-b4b0-f4f370cb5c96",
    "prId" : 7334,
    "prUrl" : "https://github.com/apache/kafka/pull/7334#pullrequestreview-296212512",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c2f919c5-482e-452b-a880-edb8f0e44363",
        "parentId" : null,
        "authorId" : "d8c7cf80-a55a-474c-a4f4-f60a9efda52c",
        "body" : "Do we have a unit test for `decode`? If not, we should.",
        "createdAt" : "2019-09-17T11:57:40Z",
        "updatedAt" : "2019-09-19T15:36:21Z",
        "lastEditedBy" : "d8c7cf80-a55a-474c-a4f4-f60a9efda52c",
        "tags" : [
        ]
      },
      {
        "id" : "5b971a8a-4a5d-4b0e-8cfc-63a1ac1e873c",
        "parentId" : "c2f919c5-482e-452b-a880-edb8f0e44363",
        "authorId" : "df911192-d6c6-4af9-8568-f67bf2dcf926",
        "body" : "We didn't, I added one with 91572b79fe564e1810fe3e7f4696501098c9a5f4 - thanks",
        "createdAt" : "2019-09-17T14:45:09Z",
        "updatedAt" : "2019-09-19T15:36:21Z",
        "lastEditedBy" : "df911192-d6c6-4af9-8568-f67bf2dcf926",
        "tags" : [
        ]
      },
      {
        "id" : "cf02c514-5780-4eeb-a6b4-2df6838938ec",
        "parentId" : "c2f919c5-482e-452b-a880-edb8f0e44363",
        "authorId" : "4a7c311c-0954-4671-a0d2-266cb67437ad",
        "body" : "Interesting. Is it fair to stay that all of the tests passed because the partition leader is ignoring `removingReplicas`? Same of the controller, the controller only waits for `addingReplicas` to join the ISR?",
        "createdAt" : "2019-09-24T22:03:28Z",
        "updatedAt" : "2019-09-24T22:03:28Z",
        "lastEditedBy" : "4a7c311c-0954-4671-a0d2-266cb67437ad",
        "tags" : [
        ]
      },
      {
        "id" : "b7942e82-fe8e-4454-b0ac-76153cfd082d",
        "parentId" : "c2f919c5-482e-452b-a880-edb8f0e44363",
        "authorId" : "df911192-d6c6-4af9-8568-f67bf2dcf926",
        "body" : "The partition leaders do not currently make use of the new removing/adding replicas fields. When receiving a LAIR, they simply start treating all of `replicas` as replicas\r\n\r\nWe did not catch this because we were lacking an assertion in an integration test that reloads the reassignment state from ZK - https://github.com/apache/kafka/pull/7334/files#diff-386e7e8ca0062980d6c88c2ae9c055f0R687",
        "createdAt" : "2019-10-02T12:50:35Z",
        "updatedAt" : "2019-10-02T12:50:35Z",
        "lastEditedBy" : "df911192-d6c6-4af9-8568-f67bf2dcf926",
        "tags" : [
        ]
      }
    ],
    "commit" : "eb366547bfd91c80f30c87978a0356a524b0f199",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +282,286 @@            replicas.to[Seq[Int]],\n            getReplicas(addingReplicasJsonOpt, partition),\n            getReplicas(removingReplicasJsonOpt, partition)\n          )\n        }"
  },
  {
    "id" : "781c1e3b-5792-4332-9a49-7fa07b80015c",
    "prId" : 8680,
    "prUrl" : "https://github.com/apache/kafka/pull/8680#pullrequestreview-414092115",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "471bb046-3fbd-4a61-979e-5013c3ca8cd7",
        "parentId" : null,
        "authorId" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "body" : "I don't think we need a nested if-else:\r\n```\r\n val version = {\r\n      if (apiVersion >= KAFKA_2_6_IV1) \r\n        5\r\n      else if (apiVersion >= KAFKA_0_10_0_IV1)\r\n        4\r\n      else\r\n        2\r\n    }\r\n```",
        "createdAt" : "2020-05-18T23:10:56Z",
        "updatedAt" : "2020-06-11T05:59:01Z",
        "lastEditedBy" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "tags" : [
        ]
      },
      {
        "id" : "404573a5-0607-45de-863d-9e1205a09ed1",
        "parentId" : "471bb046-3fbd-4a61-979e-5013c3ca8cd7",
        "authorId" : "b4f52e78-c19e-46b4-b486-6da86e32e687",
        "body" : "Done. Good point!",
        "createdAt" : "2020-05-19T06:07:55Z",
        "updatedAt" : "2020-06-11T05:59:01Z",
        "lastEditedBy" : "b4f52e78-c19e-46b4-b486-6da86e32e687",
        "tags" : [
        ]
      }
    ],
    "commit" : "8e3ef56c552da13226c1fcc472c8d339fb98c7a8",
    "line" : 40,
    "diffHunk" : "@@ -1,1 +96,100 @@   */\n  def apply(broker: Broker, apiVersion: ApiVersion, jmxPort: Int): BrokerInfo = {\n    val version = {\n      if (apiVersion >= KAFKA_2_7_IV0)\n        5"
  },
  {
    "id" : "38829511-22d0-4e0d-8d2f-8a9f2fc269a5",
    "prId" : 8680,
    "prUrl" : "https://github.com/apache/kafka/pull/8680#pullrequestreview-416042080",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "314bc2a9-9e69-45e0-8a6b-e1339daf15cc",
        "parentId" : null,
        "authorId" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "body" : "Could we log statusInt here as well? Also I feel the exception should be thrown from  `FeatureZNodeStatus.withNameOpt`",
        "createdAt" : "2020-05-21T04:11:27Z",
        "updatedAt" : "2020-06-11T05:59:01Z",
        "lastEditedBy" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "tags" : [
        ]
      },
      {
        "id" : "068ce627-fc30-4d90-a91b-1bdd3cd9de75",
        "parentId" : "314bc2a9-9e69-45e0-8a6b-e1339daf15cc",
        "authorId" : "b4f52e78-c19e-46b4-b486-6da86e32e687",
        "body" : "Done.\r\nFor the other point, I don't feel strongly for it. I feel it is OK to have an API that doesn't throw and just lets the caller decide (based on the context) if an empty returned value is incorrect.",
        "createdAt" : "2020-05-22T07:01:08Z",
        "updatedAt" : "2020-06-11T05:59:01Z",
        "lastEditedBy" : "b4f52e78-c19e-46b4-b486-6da86e32e687",
        "tags" : [
        ]
      }
    ],
    "commit" : "8e3ef56c552da13226c1fcc472c8d339fb98c7a8",
    "line" : 290,
    "diffHunk" : "@@ -1,1 +930,934 @@        }\n        val status = FeatureZNodeStatus.withNameOpt(statusInt.get)\n        if (status.isEmpty) {\n          throw new IllegalArgumentException(\n            s\"Malformed status: $statusInt found in feature information: ${new String(jsonBytes, UTF_8)}\")"
  },
  {
    "id" : "f1d21a41-ae67-4113-9dca-81b5b1c7f11b",
    "prId" : 8680,
    "prUrl" : "https://github.com/apache/kafka/pull/8680#pullrequestreview-427700099",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "39fe279b-d879-44bc-b6b9-49c74f339cdf",
        "parentId" : null,
        "authorId" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "body" : "I feel we might worth creating a separate thread discussing whether we could get some benefit of the automated protocol generation framework here, as I think this could be easily represented as JSON if we define it in the common package like other RPC data. The difficulty right now is mostly on the serialization and deserialization for feature itself, but these could have workarounds if we want to do so.",
        "createdAt" : "2020-05-21T04:19:58Z",
        "updatedAt" : "2020-06-11T05:59:01Z",
        "lastEditedBy" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "tags" : [
        ]
      },
      {
        "id" : "3f713a9d-2853-499d-b8ca-e6b405fa8fe0",
        "parentId" : "39fe279b-d879-44bc-b6b9-49c74f339cdf",
        "authorId" : "b4f52e78-c19e-46b4-b486-6da86e32e687",
        "body" : "As far as I can see, no ZK node class defined in this file is defined in such a way. Every class in this file encodes/decodes JSON by itself, and manages its own attributes.\r\nShould we break the norm?",
        "createdAt" : "2020-05-22T07:07:36Z",
        "updatedAt" : "2020-06-11T05:59:01Z",
        "lastEditedBy" : "b4f52e78-c19e-46b4-b486-6da86e32e687",
        "tags" : [
        ]
      },
      {
        "id" : "e2ca2d50-acb9-400c-baa0-40127965aa85",
        "parentId" : "39fe279b-d879-44bc-b6b9-49c74f339cdf",
        "authorId" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "body" : "I think the norm exists because we don't have automated framework by then, and doing hand-written json serialization and deserialization is a bit wasting. cc @hachikuji @cmccabe as this is a major direction discussion.",
        "createdAt" : "2020-05-23T03:52:57Z",
        "updatedAt" : "2020-06-11T05:59:01Z",
        "lastEditedBy" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "tags" : [
        ]
      },
      {
        "id" : "8977a0f5-0f70-4cc9-9a70-606d0d4ca26f",
        "parentId" : "39fe279b-d879-44bc-b6b9-49c74f339cdf",
        "authorId" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "body" : "I think I'm no longer insisting on this point, as we could make this as a follow-up work. Filed JIRA here: https://issues.apache.org/jira/browse/KAFKA-10130",
        "createdAt" : "2020-06-09T17:27:52Z",
        "updatedAt" : "2020-06-11T05:59:01Z",
        "lastEditedBy" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "tags" : [
        ]
      },
      {
        "id" : "2658e3c9-6101-45b3-a150-89665a2af31f",
        "parentId" : "39fe279b-d879-44bc-b6b9-49c74f339cdf",
        "authorId" : "b4f52e78-c19e-46b4-b486-6da86e32e687",
        "body" : "Thanks. Good idea to leave a jira. I have linked it to KAFKA-9755.",
        "createdAt" : "2020-06-10T05:54:19Z",
        "updatedAt" : "2020-06-11T05:59:01Z",
        "lastEditedBy" : "b4f52e78-c19e-46b4-b486-6da86e32e687",
        "tags" : [
        ]
      }
    ],
    "commit" : "8e3ef56c552da13226c1fcc472c8d339fb98c7a8",
    "line" : 212,
    "diffHunk" : "@@ -1,1 +852,856 @@}\n\nobject FeatureZNode {\n  private val VersionKey = \"version\"\n  private val StatusKey = \"status\""
  }
]
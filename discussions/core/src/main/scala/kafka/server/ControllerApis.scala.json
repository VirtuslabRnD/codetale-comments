[
  {
    "id" : "ecb34b04-8ffa-4a25-ad65-ee056ff604bf",
    "prId" : 10184,
    "prUrl" : "https://github.com/apache/kafka/pull/10184#pullrequestreview-597865888",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7d1d8aaa-bbad-4a9f-9615-f5dcf578cdfd",
        "parentId" : null,
        "authorId" : "0f776378-bb23-4193-9bb0-1db5973f3781",
        "body" : "How about using `throw Errors.INVALID_REQUEST.exception()`? That makes sure the exception is correlated to expected `Errors`",
        "createdAt" : "2021-02-23T14:06:54Z",
        "updatedAt" : "2021-03-04T17:23:46Z",
        "lastEditedBy" : "0f776378-bb23-4193-9bb0-1db5973f3781",
        "tags" : [
        ]
      },
      {
        "id" : "2466fb48-4d17-4ba4-8275-c3a2d9b78f87",
        "parentId" : "7d1d8aaa-bbad-4a9f-9615-f5dcf578cdfd",
        "authorId" : "d8c7cf80-a55a-474c-a4f4-f60a9efda52c",
        "body" : "The error message would be less useful in that case.",
        "createdAt" : "2021-02-23T15:11:54Z",
        "updatedAt" : "2021-03-04T17:23:46Z",
        "lastEditedBy" : "d8c7cf80-a55a-474c-a4f4-f60a9efda52c",
        "tags" : [
        ]
      },
      {
        "id" : "0d6346d9-ebea-4bf3-9f0a-92484da41d82",
        "parentId" : "7d1d8aaa-bbad-4a9f-9615-f5dcf578cdfd",
        "authorId" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "body" : "As @ijuma said, in this case the error message gives extra information which would be very helpful to users. If we always wanted the same message, there would be no reason to have the string field in the wire protocol.",
        "createdAt" : "2021-02-24T19:52:21Z",
        "updatedAt" : "2021-03-04T17:23:46Z",
        "lastEditedBy" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "tags" : [
        ]
      }
    ],
    "commit" : "6aec8bdb9327d2f72b67f7acc8e158d737491711",
    "line" : 103,
    "diffHunk" : "@@ -1,1 +185,189 @@    if (!config.deleteTopicEnable) {\n      if (apiVersion < 3) {\n        throw new InvalidRequestException(\"Topic deletion is disabled.\")\n      } else {\n        throw new TopicDeletionDisabledException()"
  },
  {
    "id" : "47bc4e00-049c-4aac-bc3a-28568d09cfa0",
    "prId" : 10184,
    "prUrl" : "https://github.com/apache/kafka/pull/10184#pullrequestreview-598262044",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b0b9e4ff-e233-4e55-a7f5-bf92b5e447ff",
        "parentId" : null,
        "authorId" : "0f776378-bb23-4193-9bb0-1db5973f3781",
        "body" : "unintentional?",
        "createdAt" : "2021-02-25T07:55:56Z",
        "updatedAt" : "2021-03-04T17:23:46Z",
        "lastEditedBy" : "0f776378-bb23-4193-9bb0-1db5973f3781",
        "tags" : [
        ]
      }
    ],
    "commit" : "6aec8bdb9327d2f72b67f7acc8e158d737491711",
    "line" : 35,
    "diffHunk" : "@@ -1,1 +53,57 @@import scala.jdk.CollectionConverters._\n\n\n/**\n * Request handler for Controller APIs"
  },
  {
    "id" : "3ca63bf9-fb93-47d3-a8f3-fd0aca12532b",
    "prId" : 10184,
    "prUrl" : "https://github.com/apache/kafka/pull/10184#pullrequestreview-599919849",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "952114d7-96d7-40d2-92e0-1f9e5bdd6a6a",
        "parentId" : null,
        "authorId" : "0f776378-bb23-4193-9bb0-1db5973f3781",
        "body" : "How about using `DeletableTopicResultCollection` replace `util.List[DeletableTopicResult]`? That change can eliminate extra collection.",
        "createdAt" : "2021-02-26T07:47:42Z",
        "updatedAt" : "2021-03-04T17:23:46Z",
        "lastEditedBy" : "0f776378-bb23-4193-9bb0-1db5973f3781",
        "tags" : [
        ]
      },
      {
        "id" : "2811e3cb-484d-42c1-823a-2bff71d549ff",
        "parentId" : "952114d7-96d7-40d2-92e0-1f9e5bdd6a6a",
        "authorId" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "body" : "Unfortunately, that will not work since we have to shuffle it at the end",
        "createdAt" : "2021-02-26T20:30:49Z",
        "updatedAt" : "2021-03-04T17:23:46Z",
        "lastEditedBy" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "tags" : [
        ]
      }
    ],
    "commit" : "6aec8bdb9327d2f72b67f7acc8e158d737491711",
    "line" : 99,
    "diffHunk" : "@@ -1,1 +181,185 @@                   hasClusterAuth: Boolean,\n                   getDescribableTopics: Iterable[String] => Set[String],\n                   getDeletableTopics: Iterable[String] => Set[String]): util.List[DeletableTopicResult] = {\n    // Check if topic deletion is enabled at all.\n    if (!config.deleteTopicEnable) {"
  },
  {
    "id" : "d01251b4-edac-4159-9a79-69dda80e1398",
    "prId" : 10184,
    "prUrl" : "https://github.com/apache/kafka/pull/10184#pullrequestreview-599970734",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "282c0322-7be4-4f0c-b0d7-407b6d55cfc1",
        "parentId" : null,
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "There seems to be enough complexity in the handling here that it might be worth pulling this logic into a separate class. Not required for this PR, but it would be nice to come up with a nicer pattern so that we don't end up with a giant class like `KafkaApis`.",
        "createdAt" : "2021-02-26T20:03:12Z",
        "updatedAt" : "2021-03-04T17:23:46Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      },
      {
        "id" : "fa2fa3e1-d6b2-49ee-8b39-1746eb186db8",
        "parentId" : "282c0322-7be4-4f0c-b0d7-407b6d55cfc1",
        "authorId" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "body" : "It is kind of frustrating that there is this much complexity in the \"apis\" class.  At least there is a good unit test for it now, though.  I hope that most other APIs won't be this complex.",
        "createdAt" : "2021-02-26T21:57:26Z",
        "updatedAt" : "2021-03-04T17:23:46Z",
        "lastEditedBy" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "tags" : [
        ]
      }
    ],
    "commit" : "6aec8bdb9327d2f72b67f7acc8e158d737491711",
    "line" : 95,
    "diffHunk" : "@@ -1,1 +177,181 @@  }\n\n  def deleteTopics(request: DeleteTopicsRequestData,\n                   apiVersion: Int,\n                   hasClusterAuth: Boolean,"
  },
  {
    "id" : "cf17963e-5ae1-463c-a170-3075ca75e57b",
    "prId" : 10184,
    "prUrl" : "https://github.com/apache/kafka/pull/10184#pullrequestreview-600150778",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "017ab81c-82a7-44f7-9d8d-f3667fb785f5",
        "parentId" : null,
        "authorId" : "0f776378-bb23-4193-9bb0-1db5973f3781",
        "body" : "Should it pass `UNKNOWN_TOPIC_ID` for this case (according to comment)?",
        "createdAt" : "2021-02-27T14:41:41Z",
        "updatedAt" : "2021-03-04T17:23:46Z",
        "lastEditedBy" : "0f776378-bb23-4193-9bb0-1db5973f3781",
        "tags" : [
        ]
      }
    ],
    "commit" : "6aec8bdb9327d2f72b67f7acc8e158d737491711",
    "line" : 162,
    "diffHunk" : "@@ -1,1 +244,248 @@    controller.findTopicNames(providedIds).get().forEach { (id, nameOrError) =>\n      if (nameOrError.isError) {\n        appendResponse(null, id, nameOrError.error())\n      } else {\n        toAuthenticate.add(nameOrError.result())"
  },
  {
    "id" : "7b602837-2bf4-4c3b-b3c0-c05331a94235",
    "prId" : 10194,
    "prUrl" : "https://github.com/apache/kafka/pull/10194#pullrequestreview-599152107",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7988a43a-8d9f-4bdd-ac6e-e1663c3729a0",
        "parentId" : null,
        "authorId" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "body" : "I think we do need to fill in the feature fields eventually. But for 2.8, this is OK.",
        "createdAt" : "2021-02-25T23:54:43Z",
        "updatedAt" : "2021-02-26T00:13:25Z",
        "lastEditedBy" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "tags" : [
        ]
      },
      {
        "id" : "a6483ad7-279d-41f6-94cb-b1f17d768500",
        "parentId" : "7988a43a-8d9f-4bdd-ac6e-e1663c3729a0",
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "Right. I think the change makes sense in any case since the feature logic will end up getting handled by `ApiVersionManager` (as we do with the broker).",
        "createdAt" : "2021-02-26T00:05:32Z",
        "updatedAt" : "2021-02-26T00:13:25Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      },
      {
        "id" : "ee9d5332-01ff-4240-93c8-e0a8f78c8bb8",
        "parentId" : "7988a43a-8d9f-4bdd-ac6e-e1663c3729a0",
        "authorId" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "body" : "agreed. we will have to have some way for the controller to update those fields in ApiVersionsManager (possibly an atomic / volatile field or something).",
        "createdAt" : "2021-02-26T00:12:42Z",
        "updatedAt" : "2021-02-26T00:13:31Z",
        "lastEditedBy" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "tags" : [
        ]
      }
    ],
    "commit" : "254e33cfea44b56ecb014c4f05068f3cd2b9c412",
    "line" : 187,
    "diffHunk" : "@@ -1,1 +218,222 @@        apiVersionRequest.getErrorResponse(requestThrottleMs, Errors.INVALID_REQUEST.exception)\n      } else {\n        apiVersionManager.apiVersionResponse(requestThrottleMs)\n      }\n    }"
  },
  {
    "id" : "825922d3-2de7-415a-9610-e01c5c1d2368",
    "prId" : 10505,
    "prUrl" : "https://github.com/apache/kafka/pull/10505#pullrequestreview-634976574",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a0fb580e-cbbc-49a7-a21f-24268563aeeb",
        "parentId" : null,
        "authorId" : "083f2f03-ca7e-48a1-9781-482564dfdf53",
        "body" : "In KafkaApis we import `Errors` rather than importing all the members of the enum via a wildcard import. Any reason to prefer one way over the other? It seems more common in our code base to import the enum and refer to members like `Errors.ILLEGAL_SASL_STATE`",
        "createdAt" : "2021-04-13T00:23:07Z",
        "updatedAt" : "2021-04-15T17:38:11Z",
        "lastEditedBy" : "083f2f03-ca7e-48a1-9781-482564dfdf53",
        "tags" : [
        ]
      },
      {
        "id" : "b34b2c45-a54b-48eb-afb8-176704dde69b",
        "parentId" : "a0fb580e-cbbc-49a7-a21f-24268563aeeb",
        "authorId" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "body" : "I think this makes it more readable.  Long lines make reading and merging difficult",
        "createdAt" : "2021-04-13T20:00:59Z",
        "updatedAt" : "2021-04-15T17:38:11Z",
        "lastEditedBy" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "tags" : [
        ]
      }
    ],
    "commit" : "b6584bdc90c51da779cede24fec57848dcfb48b8",
    "line" : 26,
    "diffHunk" : "@@ -1,1 +42,46 @@import org.apache.kafka.common.message.MetadataResponseData.MetadataResponseBroker\nimport org.apache.kafka.common.message._\nimport org.apache.kafka.common.protocol.Errors._\nimport org.apache.kafka.common.protocol.{ApiKeys, ApiMessage, Errors}\nimport org.apache.kafka.common.requests._"
  },
  {
    "id" : "6c2408bf-f83b-44df-9b06-a5bc3db85823",
    "prId" : 10505,
    "prUrl" : "https://github.com/apache/kafka/pull/10505#pullrequestreview-634982109",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2cf46466-cddf-40f1-9cd1-9b56e387821e",
        "parentId" : null,
        "authorId" : "083f2f03-ca7e-48a1-9781-482564dfdf53",
        "body" : "Indentation seems weird. (I don't really know if it's correct or not)",
        "createdAt" : "2021-04-13T00:29:11Z",
        "updatedAt" : "2021-04-15T17:38:11Z",
        "lastEditedBy" : "083f2f03-ca7e-48a1-9781-482564dfdf53",
        "tags" : [
        ]
      },
      {
        "id" : "8cd623e8-8842-4b3a-8832-587b4d0d3e26",
        "parentId" : "2cf46466-cddf-40f1-9cd1-9b56e387821e",
        "authorId" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "body" : "It's kind of a long return type, so I'd prefer to have it on a separate line.",
        "createdAt" : "2021-04-13T20:08:09Z",
        "updatedAt" : "2021-04-15T17:38:11Z",
        "lastEditedBy" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "tags" : [
        ]
      }
    ],
    "commit" : "b6584bdc90c51da779cede24fec57848dcfb48b8",
    "line" : 285,
    "diffHunk" : "@@ -1,1 +349,353 @@                   hasClusterAuth: Boolean,\n                   getCreatableTopics: Iterable[String] => Set[String])\n                   : CompletableFuture[CreateTopicsResponseData] = {\n    val topicNames = new util.HashSet[String]()\n    val duplicateTopicNames = new util.HashSet[String]()"
  },
  {
    "id" : "c07bc395-2c7b-4744-b335-8ca25bbb9485",
    "prId" : 10505,
    "prUrl" : "https://github.com/apache/kafka/pull/10505#pullrequestreview-636955482",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c7847521-cb92-4542-b8e8-465d37ee62a3",
        "parentId" : null,
        "authorId" : "0f776378-bb23-4193-9bb0-1db5973f3781",
        "body" : "just code style. Could we use following style\r\n```scala\r\ncontroller.findTopicNames(providedIds).thenCompose { topicNames =>\r\n\r\n}\r\n```\r\n\r\ninstead of\r\n\r\n```scala\r\ncontroller.findTopicNames(providedIds).thenCompose(topicNames => {\r\n\r\n})\r\n```",
        "createdAt" : "2021-04-14T06:51:07Z",
        "updatedAt" : "2021-04-15T17:38:11Z",
        "lastEditedBy" : "0f776378-bb23-4193-9bb0-1db5973f3781",
        "tags" : [
        ]
      },
      {
        "id" : "29418ab9-0571-46da-a3c3-6ff99c1ed7fb",
        "parentId" : "c7847521-cb92-4542-b8e8-465d37ee62a3",
        "authorId" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "body" : "For some reason leaving out the braces doesn't work here.  Maybe it's because this block needs to be translated into a `java.util.Function` object.",
        "createdAt" : "2021-04-14T17:50:18Z",
        "updatedAt" : "2021-04-15T17:38:11Z",
        "lastEditedBy" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "tags" : [
        ]
      },
      {
        "id" : "1bbdd323-7533-4f89-965f-80168fcbf174",
        "parentId" : "c7847521-cb92-4542-b8e8-465d37ee62a3",
        "authorId" : "0f776378-bb23-4193-9bb0-1db5973f3781",
        "body" : "> For some reason leaving out the braces doesn't work here.\r\n\r\nPardon me. Did you mean it can't be compiled? The following code can compile on my local (and `ControllerApisTest` pass)\r\n```scala\r\n    controller.findTopicNames(providedIds).thenCompose { topicNames =>\r\n      topicNames.forEach { (id, nameOrError) =>\r\n        if (nameOrError.isError) {\r\n          appendResponse(null, id, nameOrError.error())\r\n        } else {\r\n          toAuthenticate.add(nameOrError.result())\r\n          idToName.put(id, nameOrError.result())\r\n        }\r\n      }\r\n      // Get the list of deletable topics (those we can delete) and the list of describeable\r\n      // topics.\r\n      val topicsToAuthenticate = toAuthenticate.asScala\r\n      val (describeable, deletable) = if (hasClusterAuth) {\r\n        (topicsToAuthenticate.toSet, topicsToAuthenticate.toSet)\r\n      } else {\r\n        (getDescribableTopics(topicsToAuthenticate), getDeletableTopics(topicsToAuthenticate))\r\n      }\r\n      // For each topic that was provided by ID, check if authentication failed.\r\n      // If so, remove it from the idToName map and create an error response for it.\r\n      val iterator = idToName.entrySet().iterator()\r\n      while (iterator.hasNext) {\r\n        val entry = iterator.next()\r\n        val id = entry.getKey\r\n        val name = entry.getValue\r\n        if (!deletable.contains(name)) {\r\n          if (describeable.contains(name)) {\r\n            appendResponse(name, id, new ApiError(TOPIC_AUTHORIZATION_FAILED))\r\n          } else {\r\n            appendResponse(null, id, new ApiError(TOPIC_AUTHORIZATION_FAILED))\r\n          }\r\n          iterator.remove()\r\n        }\r\n      }\r\n      // For each topic that was provided by name, check if authentication failed.\r\n      // If so, create an error response for it. Otherwise, add it to the idToName map.\r\n      controller.findTopicIds(providedNames).thenCompose { topicIds =>\r\n        topicIds.forEach { (name, idOrError) =>\r\n          if (!describeable.contains(name)) {\r\n            appendResponse(name, ZERO_UUID, new ApiError(TOPIC_AUTHORIZATION_FAILED))\r\n          } else if (idOrError.isError) {\r\n            appendResponse(name, ZERO_UUID, idOrError.error)\r\n          } else if (deletable.contains(name)) {\r\n            val id = idOrError.result()\r\n            if (duplicateProvidedIds.contains(id) || idToName.put(id, name) != null) {\r\n              // This is kind of a weird case: what if we supply topic ID X and also a name\r\n              // that maps to ID X?  In that case, _if authorization succeeds_, we end up\r\n              // here.  If authorization doesn't succeed, we refrain from commenting on the\r\n              // situation since it would reveal topic ID mappings.\r\n              duplicateProvidedIds.add(id)\r\n              idToName.remove(id)\r\n              appendResponse(name, id, new ApiError(INVALID_REQUEST,\r\n                \"The provided topic name maps to an ID that was already supplied.\"))\r\n            }\r\n          } else {\r\n            appendResponse(name, ZERO_UUID, new ApiError(TOPIC_AUTHORIZATION_FAILED))\r\n          }\r\n        }\r\n        // Finally, the idToName map contains all the topics that we are authorized to delete.\r\n        // Perform the deletion and create responses for each one.\r\n        controller.deleteTopics(idToName.keySet).thenApply { idToError =>\r\n          idToError.forEach { (id, error) =>\r\n            appendResponse(idToName.get(id), id, error)\r\n          }\r\n          // Shuffle the responses so that users can not use patterns in their positions to\r\n          // distinguish between absent topics and topics we are not permitted to see.\r\n          Collections.shuffle(responses)\r\n          responses\r\n        }\r\n      }\r\n    }\r\n```",
        "createdAt" : "2021-04-15T07:03:14Z",
        "updatedAt" : "2021-04-15T17:38:11Z",
        "lastEditedBy" : "0f776378-bb23-4193-9bb0-1db5973f3781",
        "tags" : [
        ]
      },
      {
        "id" : "a5a593f3-844b-422b-9f4f-65cb40714c5b",
        "parentId" : "c7847521-cb92-4542-b8e8-465d37ee62a3",
        "authorId" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "body" : "When I remove the braces I get this compiler error:\r\n```\r\n> Task :core:compileScala FAILED\r\n[Error] /home/cmccabe/src/kafka1/core/src/main/scala/kafka/server/ControllerApis.scala:270: ')' expected but 'val' found.\r\n[Error] /home/cmccabe/src/kafka1/core/src/main/scala/kafka/server/ControllerApis.scala:278: ';' expected but 'val' found.\r\ntwo errors found\r\n```\r\n\r\nMaybe let's follow up on this in a separate PR, if you can find a way to remove some of the braces and still have it compile...",
        "createdAt" : "2021-04-15T17:31:58Z",
        "updatedAt" : "2021-04-15T17:38:11Z",
        "lastEditedBy" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "tags" : [
        ]
      },
      {
        "id" : "98b74afb-f6e6-4e64-ae4b-ca1345c100f0",
        "parentId" : "c7847521-cb92-4542-b8e8-465d37ee62a3",
        "authorId" : "0f776378-bb23-4193-9bb0-1db5973f3781",
        "body" : "Sure. I will file a PR to deal with it if I get a way.",
        "createdAt" : "2021-04-15T17:34:39Z",
        "updatedAt" : "2021-04-15T17:38:11Z",
        "lastEditedBy" : "0f776378-bb23-4193-9bb0-1db5973f3781",
        "tags" : [
        ]
      }
    ],
    "commit" : "b6584bdc90c51da779cede24fec57848dcfb48b8",
    "line" : 154,
    "diffHunk" : "@@ -1,1 +257,261 @@    toAuthenticate.addAll(providedNames)\n    val idToName = new util.HashMap[Uuid, String]\n    controller.findTopicNames(providedIds).thenCompose(topicNames => {\n      topicNames.forEach { (id, nameOrError) =>\n        if (nameOrError.isError) {"
  },
  {
    "id" : "58f54515-2567-4be4-9118-d1a4b3d039fb",
    "prId" : 10550,
    "prUrl" : "https://github.com/apache/kafka/pull/10550#pullrequestreview-661261246",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "09509246-9ac3-4585-b1c4-c5fdc67afb43",
        "parentId" : null,
        "authorId" : "e0554c25-f6f3-4e49-a325-bcc5d4dc5fb2",
        "body" : "When would the controller ever process `DescribeAcls`?  It seems to me that it never would because brokers don't forward that request.  And if that is correct, I think my change to `DescribeAclsRequest.json` to set `\"listeners\": [\"zkBroker\", \"broker\", \"controller\"],` should instead be setting it to `\"listeners\": [\"zkBroker\", \"broker\"],`.",
        "createdAt" : "2021-05-16T16:05:03Z",
        "updatedAt" : "2021-05-16T16:05:04Z",
        "lastEditedBy" : "e0554c25-f6f3-4e49-a325-bcc5d4dc5fb2",
        "tags" : [
        ]
      },
      {
        "id" : "9c7a5208-754d-4539-8ba3-301f0175f0fa",
        "parentId" : "09509246-9ac3-4585-b1c4-c5fdc67afb43",
        "authorId" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "body" : "We might want the controller to process DescribeAcls for debug purposes.  There's no reason to artificially disable it from processing the RPC, although I agree that it will normally not be used.",
        "createdAt" : "2021-05-17T18:09:10Z",
        "updatedAt" : "2021-05-17T18:09:10Z",
        "lastEditedBy" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "tags" : [
        ]
      }
    ],
    "commit" : "71df16378d8b6e8a0b85f57edddb5a9b404b049e",
    "line" : 12,
    "diffHunk" : "@@ -1,1 +102,106 @@        case ApiKeys.SASL_AUTHENTICATE => handleSaslAuthenticateRequest(request)\n        case ApiKeys.CREATE_PARTITIONS => handleCreatePartitions(request)\n        case ApiKeys.DESCRIBE_ACLS => aclApis.handleDescribeAcls(request)\n        case ApiKeys.CREATE_ACLS => aclApis.handleCreateAcls(request)\n        case ApiKeys.DELETE_ACLS => aclApis.handleDeleteAcls(request)"
  }
]
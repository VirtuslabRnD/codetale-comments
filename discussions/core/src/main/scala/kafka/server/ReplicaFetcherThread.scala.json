[
  {
    "id" : "e5877f8d-91d2-4922-9513-497d9ae41b6e",
    "prId" : 4882,
    "prUrl" : "https://github.com/apache/kafka/pull/4882#pullrequestreview-118089156",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9ac5e961-fc81-489f-a566-9f42599a1cf6",
        "parentId" : null,
        "authorId" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "body" : "Now that we have 2 different versions of the LeaderEpochRequest, we need to use the right version of the request depending on inter broker protocol version.",
        "createdAt" : "2018-05-01T00:24:43Z",
        "updatedAt" : "2018-05-09T21:46:13Z",
        "lastEditedBy" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "tags" : [
        ]
      },
      {
        "id" : "c5818e6d-e1a8-4e2e-acdc-8633c10f5826",
        "parentId" : "9ac5e961-fc81-489f-a566-9f42599a1cf6",
        "authorId" : "e235ea82-83a9-41e5-8e3a-15b2e1b6f350",
        "body" : "I have a question regarding this. In OffsetsForLeaderEpochResponse, I used `partitionStruct.setIfExists` and `partitionAndEpoch.getOrElse` for new leader epoch field vs. explicitly checking version for setting/getting fields. I think, it should be correct to e.g., return the leader epoch but make sure to use the older protocol in fetcher if the inter-broker protocol is below 2.0. Or is it preferred to check the version and not set the field in OffsetsForLeaderEpochResponse? I looked at the code, and it looks like different request/response use different approaches (either one I described).\r\n\r\nThis particular line of code is correct independent of version, since undefined offsets means falling back to high watermark, independent if epoch is set or not (or defined or not defined). \r\n\r\nI agree I need to update the truncation logic to make sure the behavior is consistent with the protocol version.",
        "createdAt" : "2018-05-01T19:01:19Z",
        "updatedAt" : "2018-05-09T21:46:13Z",
        "lastEditedBy" : "e235ea82-83a9-41e5-8e3a-15b2e1b6f350",
        "tags" : [
        ]
      },
      {
        "id" : "1a016045-a2ff-46df-b277-9e51a73c69bb",
        "parentId" : "9ac5e961-fc81-489f-a566-9f42599a1cf6",
        "authorId" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "body" : "Using setIfExists seems fine. However, we need to pass in the version number to OffsetsForLeaderEpochRequest.Builder based on inter broker protocol version. Similar to what we do when building the fetch request.",
        "createdAt" : "2018-05-02T22:00:27Z",
        "updatedAt" : "2018-05-09T21:46:13Z",
        "lastEditedBy" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "tags" : [
        ]
      },
      {
        "id" : "896473ef-6ff5-4b08-94cb-f32134e306ff",
        "parentId" : "9ac5e961-fc81-489f-a566-9f42599a1cf6",
        "authorId" : "e235ea82-83a9-41e5-8e3a-15b2e1b6f350",
        "body" : "I looked at OffsetsForLeaderEpochRequest.Builder, and I see that we pass version to the builder:\r\n`public OffsetsForLeaderEpochRequest build(short version) {`\r\n` public OffsetsForLeaderEpochRequest(Struct struct, short version) {`\r\n` @Override\r\n    protected Struct toStruct() {\r\n        Struct requestStruct = new Struct(ApiKeys.OFFSET_FOR_LEADER_EPOCH.requestSchema(version()));\r\n... `\r\nOr am I missing something?",
        "createdAt" : "2018-05-07T17:46:19Z",
        "updatedAt" : "2018-05-09T21:46:13Z",
        "lastEditedBy" : "e235ea82-83a9-41e5-8e3a-15b2e1b6f350",
        "tags" : [
        ]
      },
      {
        "id" : "7e0de71d-6dbf-4213-a69b-ac4b8cbae33f",
        "parentId" : "9ac5e961-fc81-489f-a566-9f42599a1cf6",
        "authorId" : "e235ea82-83a9-41e5-8e3a-15b2e1b6f350",
        "body" : "Oh I see now, version is not in OffsetForLeaderEpochResponse constructor, not request. Will fix.",
        "createdAt" : "2018-05-07T17:58:28Z",
        "updatedAt" : "2018-05-09T21:46:13Z",
        "lastEditedBy" : "e235ea82-83a9-41e5-8e3a-15b2e1b6f350",
        "tags" : [
        ]
      }
    ],
    "commit" : "544f4fdf83ce6f540124668d95a58d2cdebc1ea8",
    "line" : 88,
    "diffHunk" : "@@ -1,1 +353,357 @@          // if we get any unexpected exception, mark all partitions with an error\n          result = partitions.map { case (tp, _) =>\n            tp -> new EpochEndOffset(Errors.forException(t), UNDEFINED_EPOCH, UNDEFINED_EPOCH_OFFSET)\n          }\n      }"
  },
  {
    "id" : "ed223c40-b276-4f46-aafd-d552f9d7d485",
    "prId" : 6232,
    "prUrl" : "https://github.com/apache/kafka/pull/6232#pullrequestreview-201478184",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "15d0b941-dc34-41b3-a5a9-2783908d1d58",
        "parentId" : null,
        "authorId" : "df911192-d6c6-4af9-8568-f67bf2dcf926",
        "body" : "I see this is used in `fetchTruncatingPartitions` only to filter partitions with epochs. `brokerSupportsLeaderEpochRequest` depends on `inter.broker.protocol.version > 0.10`. This means that we won't truncate partitions according to epochs in `maybeTruncate()` if we have `message.format.version > 0.10` but `inter.broker.protocol.version=0.10`.\r\n\r\nI know we don't recommend such a configuration, yet it's worth asking whether this is desired.",
        "createdAt" : "2019-02-06T18:10:12Z",
        "updatedAt" : "2019-02-08T04:13:43Z",
        "lastEditedBy" : "df911192-d6c6-4af9-8568-f67bf2dcf926",
        "tags" : [
        ]
      },
      {
        "id" : "f4dfd4b3-ce90-49e4-9406-52916414450e",
        "parentId" : "15d0b941-dc34-41b3-a5a9-2783908d1d58",
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "I think it is unavoidable. The OffsetsForLeaderEpoch API that this logic relies on is only available in 0.11.",
        "createdAt" : "2019-02-06T19:56:45Z",
        "updatedAt" : "2019-02-08T04:13:43Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      },
      {
        "id" : "8d153301-8a8a-4b8f-8a54-22b999b21d39",
        "parentId" : "15d0b941-dc34-41b3-a5a9-2783908d1d58",
        "authorId" : "d8c7cf80-a55a-474c-a4f4-f60a9efda52c",
        "body" : "We actually disallow `message.format.version > 0.10` and `inter.broker.protocol.version=0.10`.",
        "createdAt" : "2019-02-08T08:55:35Z",
        "updatedAt" : "2019-02-08T08:55:35Z",
        "lastEditedBy" : "d8c7cf80-a55a-474c-a4f4-f60a9efda52c",
        "tags" : [
        ]
      }
    ],
    "commit" : "ab429a3c1ea54d660cfae70d6c14c21ad8bf4c1e",
    "line" : 91,
    "diffHunk" : "@@ -1,1 +320,324 @@  }\n\n  override def isOffsetForLeaderEpochSupported: Boolean = brokerSupportsLeaderEpochRequest\n\n"
  },
  {
    "id" : "6c3251d0-25c9-4e0e-b594-d4a045c346fb",
    "prId" : 6232,
    "prUrl" : "https://github.com/apache/kafka/pull/6232#pullrequestreview-200796731",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "138a042c-d4b8-47d8-a229-fab5d62a5504",
        "parentId" : null,
        "authorId" : "df911192-d6c6-4af9-8568-f67bf2dcf926",
        "body" : "I'm not sure whether this makes sense to have in the code anymore, I think it can never evaluated to true.\r\n\r\nIt is only called from `truncateToEpochEndOffsets` which is only called in `maybeTruncate()` like this:\r\n```\r\nif (partitionsWithEpochs.nonEmpty) {\r\n      truncateToEpochEndOffsets(partitionsWithEpochs)\r\n    }\r\n```",
        "createdAt" : "2019-02-06T18:15:08Z",
        "updatedAt" : "2019-02-08T04:13:43Z",
        "lastEditedBy" : "df911192-d6c6-4af9-8568-f67bf2dcf926",
        "tags" : [
        ]
      },
      {
        "id" : "732ae528-8958-4223-8436-f87d9977e8ff",
        "parentId" : "138a042c-d4b8-47d8-a229-fab5d62a5504",
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "Fair enough. Sometimes it is difficult to strike a good balance between good defensiveness and avoiding redundant validation. I think I will just get rid of the `nonEmpty` check.",
        "createdAt" : "2019-02-06T19:59:00Z",
        "updatedAt" : "2019-02-08T04:13:43Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      },
      {
        "id" : "972c22d9-7c1c-48d2-b1ce-6be16d0eb679",
        "parentId" : "138a042c-d4b8-47d8-a229-fab5d62a5504",
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "After looking at it, I think I prefer to leave it as is. The cost is small and it makes the code a little more resilient if we can avoid unnecessary assumptions about arguments, particularly when the logic is split across separate classes.",
        "createdAt" : "2019-02-06T20:48:25Z",
        "updatedAt" : "2019-02-08T04:13:43Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      }
    ],
    "commit" : "ab429a3c1ea54d660cfae70d6c14c21ad8bf4c1e",
    "line" : 37,
    "diffHunk" : "@@ -1,1 +295,299 @@  override def fetchEpochEndOffsets(partitions: Map[TopicPartition, EpochData]): Map[TopicPartition, EpochEndOffset] = {\n\n    if (partitions.isEmpty) {\n      debug(\"Skipping leaderEpoch request since all partitions do not have an epoch\")\n      return Map.empty"
  },
  {
    "id" : "ccd6300c-ff72-4d58-a81d-875d21234030",
    "prId" : 7443,
    "prUrl" : "https://github.com/apache/kafka/pull/7443#pullrequestreview-297237163",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4c43ea19-ba58-485d-b8b8-c1454fba998b",
        "parentId" : null,
        "authorId" : "6c4430fc-3795-49d6-9c36-cf6aa694824e",
        "body" : "Use the new builder which presizes the PartitionData hashmap, and which does not make another copy of sessionPartitions. We will not be modifying sessionPartitions, or using it again after we have processed the fetch request, so we do not need to make an unnecessary copy.",
        "createdAt" : "2019-10-04T02:19:41Z",
        "updatedAt" : "2019-10-15T22:47:30Z",
        "lastEditedBy" : "6c4430fc-3795-49d6-9c36-cf6aa694824e",
        "tags" : [
        ]
      }
    ],
    "commit" : "1aa07f40ac1c69349f51604ba85e44344e1644d2",
    "line" : 62,
    "diffHunk" : "@@ -1,1 +245,249 @@    val partitionsWithError = mutable.Set[TopicPartition]()\n\n    val builder = fetchSessionHandler.newBuilder(partitionMap.size, false)\n    partitionMap.foreach { case (topicPartition, fetchState) =>\n      // We will not include a replica in the fetch request if it should be throttled."
  },
  {
    "id" : "670577b1-9475-45a5-ba7f-4d54e0354a11",
    "prId" : 7443,
    "prUrl" : "https://github.com/apache/kafka/pull/7443#pullrequestreview-297237543",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b456919f-a831-49e2-9804-5f8896db0723",
        "parentId" : null,
        "authorId" : "6c4430fc-3795-49d6-9c36-cf6aa694824e",
        "body" : "By passing through sessionPartitions we can avoid making another copy of the PartitionMap in https://github.com/apache/kafka/pull/7443/files#diff-2d03a5d4349a23e56c09b4e773055249L119. sessionPartitions contains all of the PartitionData that we need to process the fetch response.",
        "createdAt" : "2019-10-04T02:21:47Z",
        "updatedAt" : "2019-10-15T22:47:30Z",
        "lastEditedBy" : "6c4430fc-3795-49d6-9c36-cf6aa694824e",
        "tags" : [
        ]
      }
    ],
    "commit" : "1aa07f40ac1c69349f51604ba85e44344e1644d2",
    "line" : 78,
    "diffHunk" : "@@ -1,1 +271,275 @@        .toForget(fetchData.toForget)\n        .metadata(fetchData.metadata)\n      Some(ReplicaFetch(fetchData.sessionPartitions(), requestBuilder))\n    }\n"
  },
  {
    "id" : "a80a86a1-f9b5-4006-84cc-f135c92e016d",
    "prId" : 7443,
    "prUrl" : "https://github.com/apache/kafka/pull/7443#pullrequestreview-297237714",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c5983a92-f802-4161-b44e-8311ddebd079",
        "parentId" : null,
        "authorId" : "6c4430fc-3795-49d6-9c36-cf6aa694824e",
        "body" : "We avoid a HashMap lookup here by including the lag in the PartitionFetchState directly.",
        "createdAt" : "2019-10-04T02:22:41Z",
        "updatedAt" : "2019-10-15T22:47:30Z",
        "lastEditedBy" : "6c4430fc-3795-49d6-9c36-cf6aa694824e",
        "tags" : [
        ]
      }
    ],
    "commit" : "1aa07f40ac1c69349f51604ba85e44344e1644d2",
    "line" : 90,
    "diffHunk" : "@@ -1,1 +337,341 @@   */\n  private def shouldFollowerThrottle(quota: ReplicaQuota, fetchState: PartitionFetchState, topicPartition: TopicPartition): Boolean = {\n    !fetchState.isReplicaInSync && quota.isThrottled(topicPartition) && quota.isQuotaExceeded\n  }\n"
  },
  {
    "id" : "c14da696-4bb9-4c27-8ccd-b4ac93d04bed",
    "prId" : 7443,
    "prUrl" : "https://github.com/apache/kafka/pull/7443#pullrequestreview-302273040",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "09b88937-e5a2-4031-99ad-6d4cdb56ca58",
        "parentId" : null,
        "authorId" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "body" : "Hmm, here, we choose not to copy sessionPartitions in the builder. However, in line 265 and line 273, we still read  sessionPartitions. Is that correct?",
        "createdAt" : "2019-10-15T20:39:54Z",
        "updatedAt" : "2019-10-15T22:47:30Z",
        "lastEditedBy" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "tags" : [
        ]
      },
      {
        "id" : "67afbc83-25ec-43a2-8299-6791f4ccbafa",
        "parentId" : "09b88937-e5a2-4031-99ad-6d4cdb56ca58",
        "authorId" : "6c4430fc-3795-49d6-9c36-cf6aa694824e",
        "body" : "I believe this is still correct. We do not copy sessionPartitions, but sessionPartitions will also not be modified until the next fetch/doWork iteration, and all use of it is from the same thread. I believe it is thus safe to use it without making a copy.",
        "createdAt" : "2019-10-15T21:32:51Z",
        "updatedAt" : "2019-10-15T22:47:30Z",
        "lastEditedBy" : "6c4430fc-3795-49d6-9c36-cf6aa694824e",
        "tags" : [
        ]
      },
      {
        "id" : "164a30e3-655e-4bfc-a15d-37574d311b28",
        "parentId" : "09b88937-e5a2-4031-99ad-6d4cdb56ca58",
        "authorId" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "body" : "Thanks for the explanation. That makes sense.",
        "createdAt" : "2019-10-16T00:55:36Z",
        "updatedAt" : "2019-10-16T00:55:36Z",
        "lastEditedBy" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "tags" : [
        ]
      }
    ],
    "commit" : "1aa07f40ac1c69349f51604ba85e44344e1644d2",
    "line" : 62,
    "diffHunk" : "@@ -1,1 +245,249 @@    val partitionsWithError = mutable.Set[TopicPartition]()\n\n    val builder = fetchSessionHandler.newBuilder(partitionMap.size, false)\n    partitionMap.foreach { case (topicPartition, fetchState) =>\n      // We will not include a replica in the fetch request if it should be throttled."
  }
]
[
  {
    "id" : "bb887540-a477-434d-be1a-50d2caede3ca",
    "prId" : 6397,
    "prUrl" : "https://github.com/apache/kafka/pull/6397#pullrequestreview-212147517",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ffe70a44-318f-4b0d-b2fd-9ecf1802dd7c",
        "parentId" : null,
        "authorId" : "aa2f3d2f-93f8-421b-a14a-37805d03ea87",
        "body" : "Actually, do you think we can switch this to be a plain `j.u.List`? See next comment as well.",
        "createdAt" : "2019-03-08T05:46:37Z",
        "updatedAt" : "2019-03-22T08:30:39Z",
        "lastEditedBy" : "aa2f3d2f-93f8-421b-a14a-37805d03ea87",
        "tags" : [
        ]
      }
    ],
    "commit" : "aabb6735a0168c4b04ec92cd1a9d4ac50173df8a",
    "line" : 9,
    "diffHunk" : "@@ -1,1 +55,59 @@  // `Iterable[Integer]` instead of `Iterable[Int]` to avoid a collection copy.\n  // filterUnavailableEndpoints exists to support v0 MetadataResponses\n  private def getEndpoints(snapshot: MetadataSnapshot, brokers: Iterable[java.lang.Integer], listenerName: ListenerName, filterUnavailableEndpoints: Boolean): Seq[Node] = {\n    val result = new mutable.ArrayBuffer[Node](math.min(snapshot.aliveBrokers.size, brokers.size))\n    brokers.foreach { brokerId =>"
  },
  {
    "id" : "a94b63b9-a16b-4d8a-a985-d7bfb0eb3da4",
    "prId" : 6397,
    "prUrl" : "https://github.com/apache/kafka/pull/6397#pullrequestreview-212150932",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "dfcaaacf-a0e6-4fed-b849-ee177dbe45f8",
        "parentId" : null,
        "authorId" : "aa2f3d2f-93f8-421b-a14a-37805d03ea87",
        "body" : "basically, these fields are all originally `j.u.List`s. There seems to be an unnecessary conversion to Scala collections and then back to Java (https://github.com/apache/kafka/pull/6397/files#diff-bfeebf48d90e86c1ffb850fbbe019dd6R112). I think we can avoid these altogether. Although there are Scala-collection-specific filters applied for debug logging (https://github.com/apache/kafka/pull/6397/files#diff-bfeebf48d90e86c1ffb850fbbe019dd6R107 for example), you can just use `JavaConverters.collectionAsScalaIterable` which IIUC does not do any copying.",
        "createdAt" : "2019-03-08T05:52:44Z",
        "updatedAt" : "2019-03-22T08:30:39Z",
        "lastEditedBy" : "aa2f3d2f-93f8-421b-a14a-37805d03ea87",
        "tags" : [
        ]
      },
      {
        "id" : "8361049e-8af3-45b7-8f08-fdaf4c7e7505",
        "parentId" : "dfcaaacf-a0e6-4fed-b849-ee177dbe45f8",
        "authorId" : "aa2f3d2f-93f8-421b-a14a-37805d03ea87",
        "body" : "actually, nm - these aren't copying conversions except for the type conversion which your patch eliminates. So I think we are good.",
        "createdAt" : "2019-03-08T06:05:09Z",
        "updatedAt" : "2019-03-22T08:30:39Z",
        "lastEditedBy" : "aa2f3d2f-93f8-421b-a14a-37805d03ea87",
        "tags" : [
        ]
      },
      {
        "id" : "82670b22-f012-47c2-b514-ab639a48b21b",
        "parentId" : "dfcaaacf-a0e6-4fed-b849-ee177dbe45f8",
        "authorId" : "d8c7cf80-a55a-474c-a4f4-f60a9efda52c",
        "body" : "Yeah, none of the converters do copying. It's just unfortunate that there's no way to have `Int` as a collection parameter without copying. We can live with `Integer` here.",
        "createdAt" : "2019-03-08T06:06:25Z",
        "updatedAt" : "2019-03-22T08:30:39Z",
        "lastEditedBy" : "d8c7cf80-a55a-474c-a4f4-f60a9efda52c",
        "tags" : [
        ]
      }
    ],
    "commit" : "aabb6735a0168c4b04ec92cd1a9d4ac50173df8a",
    "line" : 18,
    "diffHunk" : "@@ -1,1 +78,82 @@        val leaderEpoch = partitionState.basePartitionState.leaderEpoch\n        val maybeLeader = getAliveEndpoint(snapshot, leaderBrokerId, listenerName)\n        val replicas = partitionState.basePartitionState.replicas.asScala\n        val replicaInfo = getEndpoints(snapshot, replicas, listenerName, errorUnavailableEndpoints)\n        val offlineReplicaInfo = getEndpoints(snapshot, partitionState.offlineReplicas.asScala, listenerName, errorUnavailableEndpoints)"
  }
]
[
  {
    "id" : "bb887540-a477-434d-be1a-50d2caede3ca",
    "prId" : 6397,
    "prUrl" : "https://github.com/apache/kafka/pull/6397#pullrequestreview-212147517",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ffe70a44-318f-4b0d-b2fd-9ecf1802dd7c",
        "parentId" : null,
        "authorId" : "aa2f3d2f-93f8-421b-a14a-37805d03ea87",
        "body" : "Actually, do you think we can switch this to be a plain `j.u.List`? See next comment as well.",
        "createdAt" : "2019-03-08T05:46:37Z",
        "updatedAt" : "2019-03-22T08:30:39Z",
        "lastEditedBy" : "aa2f3d2f-93f8-421b-a14a-37805d03ea87",
        "tags" : [
        ]
      }
    ],
    "commit" : "aabb6735a0168c4b04ec92cd1a9d4ac50173df8a",
    "line" : 9,
    "diffHunk" : "@@ -1,1 +55,59 @@  // `Iterable[Integer]` instead of `Iterable[Int]` to avoid a collection copy.\n  // filterUnavailableEndpoints exists to support v0 MetadataResponses\n  private def getEndpoints(snapshot: MetadataSnapshot, brokers: Iterable[java.lang.Integer], listenerName: ListenerName, filterUnavailableEndpoints: Boolean): Seq[Node] = {\n    val result = new mutable.ArrayBuffer[Node](math.min(snapshot.aliveBrokers.size, brokers.size))\n    brokers.foreach { brokerId =>"
  },
  {
    "id" : "a94b63b9-a16b-4d8a-a985-d7bfb0eb3da4",
    "prId" : 6397,
    "prUrl" : "https://github.com/apache/kafka/pull/6397#pullrequestreview-212150932",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "dfcaaacf-a0e6-4fed-b849-ee177dbe45f8",
        "parentId" : null,
        "authorId" : "aa2f3d2f-93f8-421b-a14a-37805d03ea87",
        "body" : "basically, these fields are all originally `j.u.List`s. There seems to be an unnecessary conversion to Scala collections and then back to Java (https://github.com/apache/kafka/pull/6397/files#diff-bfeebf48d90e86c1ffb850fbbe019dd6R112). I think we can avoid these altogether. Although there are Scala-collection-specific filters applied for debug logging (https://github.com/apache/kafka/pull/6397/files#diff-bfeebf48d90e86c1ffb850fbbe019dd6R107 for example), you can just use `JavaConverters.collectionAsScalaIterable` which IIUC does not do any copying.",
        "createdAt" : "2019-03-08T05:52:44Z",
        "updatedAt" : "2019-03-22T08:30:39Z",
        "lastEditedBy" : "aa2f3d2f-93f8-421b-a14a-37805d03ea87",
        "tags" : [
        ]
      },
      {
        "id" : "8361049e-8af3-45b7-8f08-fdaf4c7e7505",
        "parentId" : "dfcaaacf-a0e6-4fed-b849-ee177dbe45f8",
        "authorId" : "aa2f3d2f-93f8-421b-a14a-37805d03ea87",
        "body" : "actually, nm - these aren't copying conversions except for the type conversion which your patch eliminates. So I think we are good.",
        "createdAt" : "2019-03-08T06:05:09Z",
        "updatedAt" : "2019-03-22T08:30:39Z",
        "lastEditedBy" : "aa2f3d2f-93f8-421b-a14a-37805d03ea87",
        "tags" : [
        ]
      },
      {
        "id" : "82670b22-f012-47c2-b514-ab639a48b21b",
        "parentId" : "dfcaaacf-a0e6-4fed-b849-ee177dbe45f8",
        "authorId" : "d8c7cf80-a55a-474c-a4f4-f60a9efda52c",
        "body" : "Yeah, none of the converters do copying. It's just unfortunate that there's no way to have `Int` as a collection parameter without copying. We can live with `Integer` here.",
        "createdAt" : "2019-03-08T06:06:25Z",
        "updatedAt" : "2019-03-22T08:30:39Z",
        "lastEditedBy" : "d8c7cf80-a55a-474c-a4f4-f60a9efda52c",
        "tags" : [
        ]
      }
    ],
    "commit" : "aabb6735a0168c4b04ec92cd1a9d4ac50173df8a",
    "line" : 18,
    "diffHunk" : "@@ -1,1 +78,82 @@        val leaderEpoch = partitionState.basePartitionState.leaderEpoch\n        val maybeLeader = getAliveEndpoint(snapshot, leaderBrokerId, listenerName)\n        val replicas = partitionState.basePartitionState.replicas.asScala\n        val replicaInfo = getEndpoints(snapshot, replicas, listenerName, errorUnavailableEndpoints)\n        val offlineReplicaInfo = getEndpoints(snapshot, partitionState.offlineReplicas.asScala, listenerName, errorUnavailableEndpoints)"
  },
  {
    "id" : "51791f01-6830-41ff-b89e-9576a27f405a",
    "prId" : 6832,
    "prUrl" : "https://github.com/apache/kafka/pull/6832#pullrequestreview-257164748",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "654f2799-dc99-4c3f-8cbf-43aa720034e4",
        "parentId" : null,
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "We could make this a `flatMap` and skip the `filter` below.",
        "createdAt" : "2019-07-02T21:52:07Z",
        "updatedAt" : "2019-07-04T02:59:14Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      }
    ],
    "commit" : "4649c14a969cd8c88d06cad68f65d39a0cfdd905",
    "line" : 17,
    "diffHunk" : "@@ -1,1 +202,206 @@      val replicaIds = partitionInfo.basePartitionState.replicas\n      replicaIds.asScala\n        .map(replicaId => replicaId.intValue() -> {\n          snapshot.aliveBrokers.get(replicaId.longValue()) match {\n            case Some(broker) =>"
  },
  {
    "id" : "c3e966c2-0fa2-4500-905a-f123029686b0",
    "prId" : 6836,
    "prUrl" : "https://github.com/apache/kafka/pull/6836#pullrequestreview-264104952",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b8cf4279-4c92-474d-90da-cb94333fe1a3",
        "parentId" : null,
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "Can we have a test case for this change?",
        "createdAt" : "2019-07-01T22:00:43Z",
        "updatedAt" : "2019-07-01T22:00:51Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      },
      {
        "id" : "83e9047a-459b-4a01-af6c-6b60b2c785a2",
        "parentId" : "b8cf4279-4c92-474d-90da-cb94333fe1a3",
        "authorId" : "2b8ddac3-3f74-403c-9e9d-62dc37cb6655",
        "body" : "Do you think MetadataCacheTest#getTopicMetadataPartitionLeaderNotAvailable cover this?",
        "createdAt" : "2019-07-19T09:24:38Z",
        "updatedAt" : "2019-07-19T09:24:38Z",
        "lastEditedBy" : "2b8ddac3-3f74-403c-9e9d-62dc37cb6655",
        "tags" : [
        ]
      }
    ],
    "commit" : "654949d269673ccb612261f3e635d3fc0a1b6621",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +94,98 @@            }\n            new MetadataResponse.PartitionMetadata(error, partitionId.toInt, Node.noNode(),\n              Optional.empty(), replicaInfo.asJava, isrInfo.asJava,\n              offlineReplicaInfo.asJava)\n"
  },
  {
    "id" : "5e859c43-12de-4944-8f69-8d5670aaa166",
    "prId" : 7770,
    "prUrl" : "https://github.com/apache/kafka/pull/7770#pullrequestreview-350858924",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d483d2e7-218f-425e-a693-2033332413ba",
        "parentId" : null,
        "authorId" : "d8c7cf80-a55a-474c-a4f4-f60a9efda52c",
        "body" : "Part of this comment doesn't seem accurate anymore. For example, `brokers` is now a `List`?",
        "createdAt" : "2020-01-30T15:00:50Z",
        "updatedAt" : "2020-02-05T00:33:47Z",
        "lastEditedBy" : "d8c7cf80-a55a-474c-a4f4-f60a9efda52c",
        "tags" : [
        ]
      }
    ],
    "commit" : "fb5a99fe09a3a7caca8a71256d2810115bfe47e1",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +58,62 @@  // we should be careful about adding additional logic here. Relatedly, `brokers` is\n  // `List[Integer]` instead of `List[Int]` to avoid a collection copy.\n  // filterUnavailableEndpoints exists to support v0 MetadataResponses\n  private def maybeFilterAliveReplicas(snapshot: MetadataSnapshot,\n                                       brokers: java.util.List[Integer],"
  },
  {
    "id" : "94b383a0-d15b-4f4c-a0f3-ce6135b7ef26",
    "prId" : 7770,
    "prUrl" : "https://github.com/apache/kafka/pull/7770#pullrequestreview-352720720",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "511abd2b-5b26-4995-bbc2-7b33862f9bb5",
        "parentId" : null,
        "authorId" : "d8c7cf80-a55a-474c-a4f4-f60a9efda52c",
        "body" : "May be worth mentioning that we added this method for perf reasons and it has the same semantics as `getAliveEndpoint` (which has a comment explaining how it works). Otherwise, I can see someone removing this method in a refactoring.",
        "createdAt" : "2020-02-04T14:25:13Z",
        "updatedAt" : "2020-02-05T00:33:47Z",
        "lastEditedBy" : "d8c7cf80-a55a-474c-a4f4-f60a9efda52c",
        "tags" : [
        ]
      }
    ],
    "commit" : "fb5a99fe09a3a7caca8a71256d2810115bfe47e1",
    "line" : 115,
    "diffHunk" : "@@ -1,1 +134,138 @@   */\n  private def hasAliveEndpoint(snapshot: MetadataSnapshot, brokerId: Int, listenerName: ListenerName): Boolean = {\n    snapshot.aliveNodes.get(brokerId).exists(_.contains(listenerName))\n  }\n"
  },
  {
    "id" : "35c1255f-f39d-4977-a756-34041fbd9fed",
    "prId" : 8320,
    "prUrl" : "https://github.com/apache/kafka/pull/8320#pullrequestreview-382210318",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "923f9607-0c08-416c-ace2-29ff019f0b1d",
        "parentId" : null,
        "authorId" : "df911192-d6c6-4af9-8568-f67bf2dcf926",
        "body" : "Should we add a comment that these trace logs are expensive?",
        "createdAt" : "2020-03-26T13:11:48Z",
        "updatedAt" : "2020-03-26T18:05:26Z",
        "lastEditedBy" : "df911192-d6c6-4af9-8568-f67bf2dcf926",
        "tags" : [
        ]
      },
      {
        "id" : "a3b1a395-a14b-49ee-b725-39368a485a74",
        "parentId" : "923f9607-0c08-416c-ace2-29ff019f0b1d",
        "authorId" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "body" : "Yes, we can add a comment.",
        "createdAt" : "2020-03-26T16:57:15Z",
        "updatedAt" : "2020-03-26T18:05:26Z",
        "lastEditedBy" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "tags" : [
        ]
      }
    ],
    "commit" : "8fc7ca7de7ffd00ed32fcd3ced1cc4774ad503c0",
    "line" : 39,
    "diffHunk" : "@@ -1,1 +332,336 @@          if (state.leader == LeaderAndIsr.LeaderDuringDelete) {\n            removePartitionInfo(partitionStates, tp.topic, tp.partition)\n            if (traceEnabled)\n              stateChangeLogger.trace(s\"Deleted partition $tp from metadata cache in response to UpdateMetadata \" +\n                s\"request sent by controller $controllerId epoch $controllerEpoch with correlation id $correlationId\")"
  },
  {
    "id" : "56650db5-f9db-45a6-a6e4-47579dc20baf",
    "prId" : 9802,
    "prUrl" : "https://github.com/apache/kafka/pull/9802#pullrequestreview-562084895",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ac70f9e5-dbcb-45a0-9847-54009204dc7a",
        "parentId" : null,
        "authorId" : "0f776378-bb23-4193-9bb0-1db5973f3781",
        "body" : "How about using a helper method to create ```new Node(id, \"\", -1)``` ? It can be used by ```MetadataResponse``` also.",
        "createdAt" : "2020-12-31T06:35:27Z",
        "updatedAt" : "2020-12-31T06:38:14Z",
        "lastEditedBy" : "0f776378-bb23-4193-9bb0-1db5973f3781",
        "tags" : [
        ]
      },
      {
        "id" : "96f76558-026b-4c99-9a2d-26b9ac93a9f3",
        "parentId" : "ac70f9e5-dbcb-45a0-9847-54009204dc7a",
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "That's not a bad idea. I think `Node` is public, though we haven't always been strict about requiring KIPs for new methods. A couple options are to add a new constructor or a static factory. We could also add a utility somewhere, but that feels a little clumsy. Thoughts?",
        "createdAt" : "2021-01-05T00:04:11Z",
        "updatedAt" : "2021-01-05T00:04:11Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      },
      {
        "id" : "ae9cd116-da74-4c08-b7f3-719dd786a9d7",
        "parentId" : "ac70f9e5-dbcb-45a0-9847-54009204dc7a",
        "authorId" : "0f776378-bb23-4193-9bb0-1db5973f3781",
        "body" : ">  I think Node is public, though we haven't always been strict about requiring KIPs for new methods. A couple options are to add a new constructor or a static factory. We could also add a utility somewhere, but that feels a little clumsy. Thoughts?\r\n\r\nYou are right.\r\n\r\nFor another, is this a kind of behavior change to ```ClientQuotaCallback``` (if custom ```ClientQuotaCallback``` does depend on the ```null``` value)? If so, how we keep the compatibility or should we offer a helper method to enable ```ClientQuotaCallback``` to validate the \"new Node(id, \"\", -1)\"?",
        "createdAt" : "2021-01-05T02:55:13Z",
        "updatedAt" : "2021-01-05T02:55:13Z",
        "lastEditedBy" : "0f776378-bb23-4193-9bb0-1db5973f3781",
        "tags" : [
        ]
      },
      {
        "id" : "3eaff5ed-328d-4917-9168-2b8108657b41",
        "parentId" : "ac70f9e5-dbcb-45a0-9847-54009204dc7a",
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "I think what we are implementing here is what is documented in `PartitionInfo`:\r\n```java\r\n    /**\r\n     * The complete set of replicas for this partition regardless of whether they are alive or up-to-date\r\n     */\r\n    public Node[] replicas() {\r\n        return replicas;\r\n    }\r\n```\r\nEven the internal logic in `PartitionInfo` assumes non-null values in the array (I caught this issue because of an NPE in the `toString`). We probably can't 100% guarantee that all quota callbacks have appropriate `isEmpty` checks, but my guess is that usage of this plugin is rare in any case and reliance on the replica set is less likely than reliance on the leader. All in all, I think we're better fixing the bug.",
        "createdAt" : "2021-01-05T17:43:17Z",
        "updatedAt" : "2021-01-05T17:43:17Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      },
      {
        "id" : "dc4a792c-6e0d-4080-90b1-89ada12e79c2",
        "parentId" : "ac70f9e5-dbcb-45a0-9847-54009204dc7a",
        "authorId" : "0f776378-bb23-4193-9bb0-1db5973f3781",
        "body" : "> my guess is that usage of this plugin is rare in any case and reliance on the replica set is less likely than reliance on the leader. All in all, I think we're better fixing the bug.\r\n\r\nmake sense to me. Thanks for your explanation!",
        "createdAt" : "2021-01-05T19:51:41Z",
        "updatedAt" : "2021-01-05T19:51:41Z",
        "lastEditedBy" : "0f776378-bb23-4193-9bb0-1db5973f3781",
        "tags" : [
        ]
      }
    ],
    "commit" : "81dd02bb015d75975ab6f27e78bf7e5eb0e6a224",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +274,278 @@\n    def node(id: Integer): Node = {\n      nodes.getOrElse(id.toLong, new Node(id, \"\", -1))\n    }\n"
  },
  {
    "id" : "6b54f9d5-e93b-4dae-8fef-2f5523cd8669",
    "prId" : 10049,
    "prUrl" : "https://github.com/apache/kafka/pull/10049#pullrequestreview-584533945",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1ef87574-186f-4579-889b-1f6bce0b2e1f",
        "parentId" : null,
        "authorId" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "body" : "The formatting is kind of weird here.  Why the blank line after `getTopicMetadata(`?\r\n\r\nAlso, it would be good to have Javadoc for this function",
        "createdAt" : "2021-02-05T17:05:50Z",
        "updatedAt" : "2021-02-05T20:41:21Z",
        "lastEditedBy" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "tags" : [
        ]
      }
    ],
    "commit" : "c398ad29c850fef263e71c9a89fb57d0ee5d2eb3",
    "line" : 38,
    "diffHunk" : "@@ -1,1 +55,59 @@   * @return                            A collection of topic metadata.\n   */\n  def getTopicMetadata(\n    topics: collection.Set[String],\n    listenerName: ListenerName,"
  },
  {
    "id" : "7cb085bb-c875-44e4-8f20-847b5c5ab824",
    "prId" : 10049,
    "prUrl" : "https://github.com/apache/kafka/pull/10049#pullrequestreview-584564655",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f51e94f4-b34e-495b-86d9-a51d922f3dff",
        "parentId" : null,
        "authorId" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "body" : "can you put this in javadoc format ?  i.e. `@returns`",
        "createdAt" : "2021-02-05T17:06:37Z",
        "updatedAt" : "2021-02-05T20:41:21Z",
        "lastEditedBy" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "tags" : [
        ]
      },
      {
        "id" : "2e927b3e-d9ad-43e0-ba42-40af5829a623",
        "parentId" : "f51e94f4-b34e-495b-86d9-a51d922f3dff",
        "authorId" : "083f2f03-ca7e-48a1-9781-482564dfdf53",
        "body" : "Yea, this just got pulled up from the class when I extracted the trait. I'll fix up these comments",
        "createdAt" : "2021-02-05T17:43:26Z",
        "updatedAt" : "2021-02-05T20:41:21Z",
        "lastEditedBy" : "083f2f03-ca7e-48a1-9781-482564dfdf53",
        "tags" : [
        ]
      }
    ],
    "commit" : "c398ad29c850fef263e71c9a89fb57d0ee5d2eb3",
    "line" : 65,
    "diffHunk" : "@@ -1,1 +82,86 @@   *          return None\n   */\n  def getPartitionLeaderEndpoint(topic: String, partitionId: Int, listenerName: ListenerName): Option[Node]\n\n  def getPartitionReplicaEndpoints(tp: TopicPartition, listenerName: ListenerName): Map[Int, Node]"
  },
  {
    "id" : "e8ffe1bf-5c35-4f8d-85a0-a1904fe15c94",
    "prId" : 10049,
    "prUrl" : "https://github.com/apache/kafka/pull/10049#pullrequestreview-584608306",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5ae729d3-9d24-488e-93cf-e6b36e40e495",
        "parentId" : null,
        "authorId" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "body" : "This is kind of a lot of code so why not have it in its own file?\r\n\r\nThe JavaDoc should also explain that this is for brokers using ZK and not for brokers using the metadata quorum.",
        "createdAt" : "2021-02-05T17:08:34Z",
        "updatedAt" : "2021-02-05T20:41:21Z",
        "lastEditedBy" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "tags" : [
        ]
      },
      {
        "id" : "e67ea44e-d9b7-42c2-b50c-696898696032",
        "parentId" : "5ae729d3-9d24-488e-93cf-e6b36e40e495",
        "authorId" : "083f2f03-ca7e-48a1-9781-482564dfdf53",
        "body" : "I left the ZK implementation in place since it's really the only production implementation for now. It also reduces the size of the diff for this change. I don't feel very strongly about it either way, so I'm happy to relocate it to a separate file",
        "createdAt" : "2021-02-05T17:42:41Z",
        "updatedAt" : "2021-02-05T20:41:21Z",
        "lastEditedBy" : "083f2f03-ca7e-48a1-9781-482564dfdf53",
        "tags" : [
        ]
      },
      {
        "id" : "17a8c562-27d7-4347-ba44-d39a7b2129e9",
        "parentId" : "5ae729d3-9d24-488e-93cf-e6b36e40e495",
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "Perhaps we can do this as a follow-up? It is nice at the moment to see the diffs clearly.",
        "createdAt" : "2021-02-05T17:47:46Z",
        "updatedAt" : "2021-02-05T20:41:21Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      },
      {
        "id" : "3b315226-10fc-44ad-b32f-9798a217c917",
        "parentId" : "5ae729d3-9d24-488e-93cf-e6b36e40e495",
        "authorId" : "083f2f03-ca7e-48a1-9781-482564dfdf53",
        "body" : "KAFKA-12299",
        "createdAt" : "2021-02-05T18:40:53Z",
        "updatedAt" : "2021-02-05T20:41:21Z",
        "lastEditedBy" : "083f2f03-ca7e-48a1-9781-482564dfdf53",
        "tags" : [
        ]
      }
    ],
    "commit" : "c398ad29c850fef263e71c9a89fb57d0ee5d2eb3",
    "line" : 100,
    "diffHunk" : "@@ -1,1 +116,120 @@ *  UpdateMetadataRequest from the controller. Every broker maintains the same cache, asynchronously.\n */\nclass ZkMetadataCache(brokerId: Int) extends MetadataCache with Logging {\n\n  private val partitionMetadataLock = new ReentrantReadWriteLock()"
  },
  {
    "id" : "8c3673a0-8e65-4fd8-b794-6b148e1f8148",
    "prId" : 10049,
    "prUrl" : "https://github.com/apache/kafka/pull/10049#pullrequestreview-584576114",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3d278846-c42b-4e38-be28-a1d46eef63b7",
        "parentId" : null,
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "nit: I don't think these factories are providing much over the constructors `MetdataCache.zkMetadataCache` vs `new ZkMetadataCache`",
        "createdAt" : "2021-02-05T17:42:00Z",
        "updatedAt" : "2021-02-05T20:41:21Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      },
      {
        "id" : "9f1ec510-c29b-4046-85e7-8ca2898d3ddf",
        "parentId" : "3d278846-c42b-4e38-be28-a1d46eef63b7",
        "authorId" : "083f2f03-ca7e-48a1-9781-482564dfdf53",
        "body" : "I was thinking it might be easier to refactor in the future if we only need to rename the factory method rather than changing all the `new Class`. ",
        "createdAt" : "2021-02-05T17:51:42Z",
        "updatedAt" : "2021-02-05T20:41:21Z",
        "lastEditedBy" : "083f2f03-ca7e-48a1-9781-482564dfdf53",
        "tags" : [
        ]
      },
      {
        "id" : "41602d09-de65-4f0e-8db7-6faf1d69cf2b",
        "parentId" : "3d278846-c42b-4e38-be28-a1d46eef63b7",
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "Ok. Probably not a ton of work either way, but will leave it up to you.",
        "createdAt" : "2021-02-05T17:58:09Z",
        "updatedAt" : "2021-02-05T20:41:21Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      }
    ],
    "commit" : "c398ad29c850fef263e71c9a89fb57d0ee5d2eb3",
    "line" : 86,
    "diffHunk" : "@@ -1,1 +103,107 @@\nobject MetadataCache {\n  def zkMetadataCache(brokerId: Int): ZkMetadataCache = {\n    new ZkMetadataCache(brokerId)\n  }"
  },
  {
    "id" : "2393b7b3-491b-44f6-adb2-4663f6446e0c",
    "prId" : 10049,
    "prUrl" : "https://github.com/apache/kafka/pull/10049#pullrequestreview-584607925",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c934eceb-036d-4fc4-a920-623e27e5f7f9",
        "parentId" : null,
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "nit: We can save it for a follow-up, but it would be nice to drop all the `get` prefixes here",
        "createdAt" : "2021-02-05T17:59:51Z",
        "updatedAt" : "2021-02-05T20:41:21Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      },
      {
        "id" : "a510e7c4-b22f-4086-878c-1532cc9998fe",
        "parentId" : "c934eceb-036d-4fc4-a920-623e27e5f7f9",
        "authorId" : "083f2f03-ca7e-48a1-9781-482564dfdf53",
        "body" : "KAFKA-12299",
        "createdAt" : "2021-02-05T18:40:30Z",
        "updatedAt" : "2021-02-05T20:41:21Z",
        "lastEditedBy" : "083f2f03-ca7e-48a1-9781-482564dfdf53",
        "tags" : [
        ]
      }
    ],
    "commit" : "c398ad29c850fef263e71c9a89fb57d0ee5d2eb3",
    "line" : 44,
    "diffHunk" : "@@ -1,1 +61,65 @@    errorUnavailableListeners: Boolean = false): collection.Seq[MetadataResponseData.MetadataResponseTopic]\n\n  def getAllTopics(): collection.Set[String]\n\n  def getAllPartitions(): collection.Set[TopicPartition]"
  }
]
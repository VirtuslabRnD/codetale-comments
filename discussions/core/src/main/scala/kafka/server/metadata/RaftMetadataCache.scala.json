[
  {
    "id" : "51d4306e-aa71-4b46-a4b1-99c178fa3c91",
    "prId" : 10049,
    "prUrl" : "https://github.com/apache/kafka/pull/10049#pullrequestreview-584603099",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ee4ddd03-599f-4eea-82fd-a1f765adf24b",
        "parentId" : null,
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "We shouldn't need this for the RaftMetadataCache. Did we end up rewriting the code to update from the image builder?",
        "createdAt" : "2021-02-05T18:20:59Z",
        "updatedAt" : "2021-02-05T20:41:21Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      },
      {
        "id" : "271dfe3e-a890-4729-9c75-5f420a30ac7c",
        "parentId" : "ee4ddd03-599f-4eea-82fd-a1f765adf24b",
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "Discussed offline. This is useful temporarily to allow reuse of `MetadataCacheTest`. Once 2.8 is cut, we'll hopefully be able to consolidate this logic to use the MetadataImage for both zk and raft.",
        "createdAt" : "2021-02-05T18:33:38Z",
        "updatedAt" : "2021-02-05T20:41:21Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      }
    ],
    "commit" : "c398ad29c850fef263e71c9a89fb57d0ee5d2eb3",
    "line" : 305,
    "diffHunk" : "@@ -1,1 +303,307 @@\n  // This method returns the deleted TopicPartitions received from UpdateMetadataRequest\n  override def updateMetadata(correlationId: Int, request: UpdateMetadataRequest): Seq[TopicPartition] = {\n    inLock(lock) {\n      val image = _currentImage"
  },
  {
    "id" : "972f24dd-4e0d-4020-bd52-950b8e703ba1",
    "prId" : 10049,
    "prUrl" : "https://github.com/apache/kafka/pull/10049#pullrequestreview-584711178",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b3190964-8419-4540-8e06-c912f5a60a1d",
        "parentId" : null,
        "authorId" : "083f2f03-ca7e-48a1-9781-482564dfdf53",
        "body" : "Note that here we are, somewhat incorrectly, excluding the broker's rack from the Node object. This was done to keep the behavior compatible with the existing MetadataCache (now ZkMetadataCache). Once we have this merged and 2.8 is released, we can work on determining if this was done for a good reason, or if it's a bug in the existing MetadataCache logic. Since this class isn't used for any production code yet, we can leave this as-is for now.",
        "createdAt" : "2021-02-05T21:13:42Z",
        "updatedAt" : "2021-02-05T21:13:50Z",
        "lastEditedBy" : "083f2f03-ca7e-48a1-9781-482564dfdf53",
        "tags" : [
        ]
      }
    ],
    "commit" : "c398ad29c850fef263e71c9a89fb57d0ee5d2eb3",
    "line" : 315,
    "diffHunk" : "@@ -1,1 +313,317 @@      def toMetadataBroker(broker: UpdateMetadataBroker): MetadataBroker = {\n        val endpoints = broker.endpoints().asScala.map { endpoint =>\n          endpoint.listener -> new Node(broker.id(), endpoint.host(), endpoint.port())\n        }.toMap\n        MetadataBroker(broker.id(), broker.rack(), endpoints, fenced = false)"
  }
]
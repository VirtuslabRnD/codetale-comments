[
  {
    "id" : "603cfdb0-f030-4e85-9b3a-447b81b9ac91",
    "prId" : 4501,
    "prUrl" : "https://github.com/apache/kafka/pull/4501#pullrequestreview-94918475",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "46952625-a587-4353-81c6-ab07106da854",
        "parentId" : null,
        "authorId" : "d8c7cf80-a55a-474c-a4f4-f60a9efda52c",
        "body" : "Do we still want this change? I think `handlePartitionsWithErrors` can be safely called with an empty collection. But maybe this is clearer. Leaving it to you to decide.",
        "createdAt" : "2018-02-08T00:03:48Z",
        "updatedAt" : "2018-02-08T00:03:53Z",
        "lastEditedBy" : "d8c7cf80-a55a-474c-a4f4-f60a9efda52c",
        "tags" : [
        ]
      },
      {
        "id" : "eeb89387-9273-4c84-8456-0d843e40468a",
        "parentId" : "46952625-a587-4353-81c6-ab07106da854",
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "No strong feeling. If we didn't already have the empty check for the log message, it wouldn't bother me. But since the check is there, it seemed more natural to skip the call to `handlePartitionsWithError`. Of course both implementations repeat the empty check anyway. I'll probably leave it this way.",
        "createdAt" : "2018-02-08T00:11:21Z",
        "updatedAt" : "2018-02-08T00:11:43Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      }
    ],
    "commit" : "5c15aed3bf20e993d986ce1299955bc514879c3f",
    "line" : 69,
    "diffHunk" : "@@ -1,1 +236,240 @@      debug(s\"Handling errors for partitions $partitionsWithError\")\n      handlePartitionsWithErrors(partitionsWithError)\n    }\n  }\n"
  },
  {
    "id" : "0cf4a43e-8a84-4aca-ad72-9c1242fa10ec",
    "prId" : 4882,
    "prUrl" : "https://github.com/apache/kafka/pull/4882#pullrequestreview-118473834",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ff404894-5e23-4c37-924f-4079a082bc83",
        "parentId" : null,
        "authorId" : "220f032c-6592-42d9-9042-aed276632816",
        "body" : "nits: this replica can be either follower or future replica. Maybe the variable can be named `replicaName`?",
        "createdAt" : "2018-05-08T06:43:03Z",
        "updatedAt" : "2018-05-09T21:46:13Z",
        "lastEditedBy" : "220f032c-6592-42d9-9042-aed276632816",
        "tags" : [
        ]
      },
      {
        "id" : "125d6159-5dd0-4d9e-88f8-bfac462350d6",
        "parentId" : "ff404894-5e23-4c37-924f-4079a082bc83",
        "authorId" : "e235ea82-83a9-41e5-8e3a-15b2e1b6f350",
        "body" : "Yeah, I already went back and forth couple of times regarding \"replica\" vs. \"follower\" (also re: your comment below). Jun commented (in this PR) that replica is also confusing in a way that leader is also a replica. And in case of future replica, it is also a follower, but of a different type. I propose to keep this name as is, but replace `replicaEndOffset` with `followerEndOffset` re: your comment below.",
        "createdAt" : "2018-05-08T18:09:53Z",
        "updatedAt" : "2018-05-09T21:46:13Z",
        "lastEditedBy" : "e235ea82-83a9-41e5-8e3a-15b2e1b6f350",
        "tags" : [
        ]
      }
    ],
    "commit" : "544f4fdf83ce6f540124668d95a58d2cdebc1ea8",
    "line" : 92,
    "diffHunk" : "@@ -1,1 +321,325 @@  def getOffsetTruncationState(tp: TopicPartition, leaderEpochOffset: EpochEndOffset, replica: Replica, isFutureReplica: Boolean = false): OffsetTruncationState = {\n    // to make sure we can distinguish log output for fetching from remote leader or local replica\n    val followerName = if (isFutureReplica) \"future replica\" else \"follower\"\n\n    if (leaderEpochOffset.endOffset == UNDEFINED_EPOCH_OFFSET) {"
  },
  {
    "id" : "c9506581-2f1c-4938-9b88-55b1038fa788",
    "prId" : 4882,
    "prUrl" : "https://github.com/apache/kafka/pull/4882#pullrequestreview-118836530",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4b83d15c-4e85-4ee2-aa64-c3186f648f46",
        "parentId" : null,
        "authorId" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "body" : "In general, we don't expect the truncation point to be < local HW. So, it would be useful to log a warning when this happens. Not sure what's the easiest way since now we can have intermediate truncation point.",
        "createdAt" : "2018-05-09T17:50:28Z",
        "updatedAt" : "2018-05-09T21:46:13Z",
        "lastEditedBy" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "tags" : [
        ]
      }
    ],
    "commit" : "544f4fdf83ce6f540124668d95a58d2cdebc1ea8",
    "line" : 132,
    "diffHunk" : "@@ -1,1 +361,365 @@      } else {\n        val offsetToTruncateTo = min(followerEndOffset, leaderEpochOffset.endOffset)\n        OffsetTruncationState(min(offsetToTruncateTo, replica.logEndOffset.messageOffset), truncationCompleted = true)\n      }\n    }"
  }
]
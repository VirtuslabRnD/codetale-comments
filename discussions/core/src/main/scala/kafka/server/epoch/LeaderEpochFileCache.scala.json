[
  {
    "id" : "affb7943-d809-44d6-a378-b067a430eb97",
    "prId" : 5678,
    "prUrl" : "https://github.com/apache/kafka/pull/5678#pullrequestreview-160348281",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "53c833d8-ccd3-44b8-ba50-56848bce6f7a",
        "parentId" : null,
        "authorId" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "body" : "Could we add all the params to the javadoc above?",
        "createdAt" : "2018-10-01T15:18:29Z",
        "updatedAt" : "2018-10-03T17:40:09Z",
        "lastEditedBy" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "tags" : [
        ]
      }
    ],
    "commit" : "9bece85a158a9e4ce023095dbf49fc5048bb964a",
    "line" : 43,
    "diffHunk" : "@@ -1,1 +38,42 @@ */\nclass LeaderEpochFileCache(topicPartition: TopicPartition,\n                           logEndOffset: () => Long,\n                           checkpoint: LeaderEpochCheckpoint) extends Logging {\n  this.logIdent = s\"[LeaderEpochCache $topicPartition] \""
  },
  {
    "id" : "3ce80db8-c9aa-4d72-87ec-737208ac5ef0",
    "prId" : 5678,
    "prUrl" : "https://github.com/apache/kafka/pull/5678#pullrequestreview-161030403",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5c4c9d59-011c-4003-987f-3476a4ef8400",
        "parentId" : null,
        "authorId" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "body" : "With this change, it seems that epochs should never be empty when used?",
        "createdAt" : "2018-10-01T15:37:15Z",
        "updatedAt" : "2018-10-03T17:40:09Z",
        "lastEditedBy" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "tags" : [
        ]
      },
      {
        "id" : "c331a88c-258e-4a23-bf64-26ca364a9009",
        "parentId" : "5c4c9d59-011c-4003-987f-3476a4ef8400",
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "Yeah, I kept this for upgrade compatibility.",
        "createdAt" : "2018-10-03T07:01:19Z",
        "updatedAt" : "2018-10-03T17:40:09Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      }
    ],
    "commit" : "9bece85a158a9e4ce023095dbf49fc5048bb964a",
    "line" : 121,
    "diffHunk" : "@@ -1,1 +116,120 @@      val epochAndOffset =\n        if (requestedEpoch == UNDEFINED_EPOCH) {\n          // This may happen if a bootstrapping follower sends a request with undefined epoch or\n          // a follower is on the older message format where leader epochs are not recorded\n          (UNDEFINED_EPOCH, UNDEFINED_EPOCH_OFFSET)"
  },
  {
    "id" : "cc9c4f91-bba6-4e5e-a963-4dc12bb8f9c0",
    "prId" : 9275,
    "prUrl" : "https://github.com/apache/kafka/pull/9275#pullrequestreview-488240979",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "17e56845-cffd-41ad-9881-54f073770a53",
        "parentId" : null,
        "authorId" : "b4936a15-698a-496e-85a1-b1e229b4986b",
        "body" : "I guess we would always be removing a range from the start or end. Are we going through the whole map and checking each one because there is no suitable API to remove multiple entries from start or end?",
        "createdAt" : "2020-09-14T15:53:23Z",
        "updatedAt" : "2020-09-15T17:45:57Z",
        "lastEditedBy" : "b4936a15-698a-496e-85a1-b1e229b4986b",
        "tags" : [
        ]
      },
      {
        "id" : "9d37849b-7a50-4fd8-9022-ef3b5a306dad",
        "parentId" : "17e56845-cffd-41ad-9881-54f073770a53",
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "That's a good question. We probably could be smarter in `truncateAndAppend` if it was safe to assume epoch/start offset increases monotonically. Maybe we just need to add the logic to validate that invariant on startup. Let me take a look at that.",
        "createdAt" : "2020-09-15T00:25:00Z",
        "updatedAt" : "2020-09-15T17:45:57Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      }
    ],
    "commit" : "00867faf4ec2ac8b520191320832e88eb8fd1e83",
    "line" : 128,
    "diffHunk" : "@@ -1,1 +126,130 @@    val removedEpochs = mutable.ListBuffer.empty[EpochEntry]\n\n    while (iterator.hasNext) {\n      val entry = iterator.next().getValue\n      if (predicate.apply(entry)) {"
  }
]
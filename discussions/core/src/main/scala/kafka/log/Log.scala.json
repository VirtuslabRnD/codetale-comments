[
  {
    "id" : "07833fb6-b522-4d1c-a097-f603b4ae8025",
    "prId" : 4907,
    "prUrl" : "https://github.com/apache/kafka/pull/4907#pullrequestreview-115377119",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9c8308ee-297c-46da-b4bd-0454b4e0a490",
        "parentId" : null,
        "authorId" : "d8c7cf80-a55a-474c-a4f4-f60a9efda52c",
        "body" : "I wonder if we should allow `LogContext` to be passed to `KafkaException` to avoid a bunch of duplication. Doesn't have to be in this PR, but is it a good idea?",
        "createdAt" : "2018-04-25T04:59:21Z",
        "updatedAt" : "2018-04-25T22:24:58Z",
        "lastEditedBy" : "d8c7cf80-a55a-474c-a4f4-f60a9efda52c",
        "tags" : [
        ]
      },
      {
        "id" : "642431b9-3275-4760-877b-00f03adeea2c",
        "parentId" : "9c8308ee-297c-46da-b4bd-0454b4e0a490",
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "It's worth considering for sure. It does seem more awkward since you'd have to add overloads to all the sub-type constructors as well. And many of the exception types are public ðŸ˜ž . If we can find a nice way to do it, it's a good idea.",
        "createdAt" : "2018-04-25T22:28:50Z",
        "updatedAt" : "2018-04-25T22:28:50Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      }
    ],
    "commit" : "2777ab489b6bd3fbaf0733fb85eaf8619d43acdf",
    "line" : 88,
    "diffHunk" : "@@ -1,1 +1382,1386 @@        if (prev != null)\n          throw new KafkaException(s\"Trying to roll a new log segment for topic partition $topicPartition with \" +\n            s\"start offset $newOffset while it already exists.\")\n        // We need to update the segment base offset and append position data of the metadata when log rolls.\n        // The next offset should not change."
  },
  {
    "id" : "000ebd10-0ca5-483f-8f47-87146d732626",
    "prId" : 4975,
    "prUrl" : "https://github.com/apache/kafka/pull/4975#pullrequestreview-126872964",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4fe2214d-f236-419d-9015-7769dac5d8b2",
        "parentId" : null,
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "Maybe we can have a separate `splitAndReplace` method so that we can call this from `loadSegments` without needing to mutate the internal state. Gives an excuse to reduce the size of this big function as well (even if just a little bit).",
        "createdAt" : "2018-06-06T21:24:36Z",
        "updatedAt" : "2018-06-07T00:53:17Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      },
      {
        "id" : "f7c5caec-6013-45df-b48f-f154ed03c06f",
        "parentId" : "4fe2214d-f236-419d-9015-7769dac5d8b2",
        "authorId" : "93b1c273-8917-4547-bd53-5101f22161c0",
        "body" : "I don't fully understand the intent here. Do you want to avoid the call to `replaceSegments` when `splitSegmentOnOffsetOverflow` is called from `loadSegments`?",
        "createdAt" : "2018-06-07T00:35:10Z",
        "updatedAt" : "2018-06-07T00:53:17Z",
        "lastEditedBy" : "93b1c273-8917-4547-bd53-5101f22161c0",
        "tags" : [
        ]
      },
      {
        "id" : "8b0e976f-138c-4427-a789-3785803f2f3e",
        "parentId" : "4fe2214d-f236-419d-9015-7769dac5d8b2",
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "Yes, that's right. The expectation in `replaceSegments` is that the segments have already been loaded. It is easy to avoid violating this expectation and makes the code easier to reason about. ",
        "createdAt" : "2018-06-07T17:03:21Z",
        "updatedAt" : "2018-06-07T17:07:52Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      }
    ],
    "commit" : "88121f86f4c732905a44c1bdb21b6383a2e073cf",
    "line" : 539,
    "diffHunk" : "@@ -1,1 +1944,1948 @@\n    // replace old segment with new ones\n    replaceSegments(newSegments.toList, List(segment), isRecoveredSwapFile = false)\n    newSegments.toList\n  }"
  },
  {
    "id" : "dbbcb00d-97a1-4e47-830b-6805dfe19e1f",
    "prId" : 4975,
    "prUrl" : "https://github.com/apache/kafka/pull/4975#pullrequestreview-126881769",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "76d1d82e-d138-47bf-b925-8f1a853ff6a1",
        "parentId" : null,
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "Any reason not to make this a case class?",
        "createdAt" : "2018-06-06T21:24:59Z",
        "updatedAt" : "2018-06-07T00:53:17Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      },
      {
        "id" : "9fbee259-6a47-412f-8aa9-c120e8d4cf1f",
        "parentId" : "76d1d82e-d138-47bf-b925-8f1a853ff6a1",
        "authorId" : "93b1c273-8917-4547-bd53-5101f22161c0",
        "body" : "findbugs does not seem to like it. Detailed response here: https://github.com/apache/kafka/pull/4975#discussion_r187756280",
        "createdAt" : "2018-06-07T00:36:54Z",
        "updatedAt" : "2018-06-07T00:53:17Z",
        "lastEditedBy" : "93b1c273-8917-4547-bd53-5101f22161c0",
        "tags" : [
        ]
      },
      {
        "id" : "217d7d7f-6a61-46e1-ba29-808e6beaf1e0",
        "parentId" : "76d1d82e-d138-47bf-b925-8f1a853ff6a1",
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "Ok, I see. I think this is kind of an indirect way of telling us that what we're doing is a little odd. I'd probably suggest pulling `copyRecordsToSegment` up--perhaps even moving it into `LogSegment`--but we can leave that for a follow-up.",
        "createdAt" : "2018-06-07T17:28:40Z",
        "updatedAt" : "2018-06-07T17:28:56Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      }
    ],
    "commit" : "88121f86f4c732905a44c1bdb21b6383a2e073cf",
    "line" : 448,
    "diffHunk" : "@@ -1,1 +1853,1857 @@    var readBuffer = ByteBuffer.allocate(1024 * 1024)\n\n    class CopyResult(val bytesRead: Int, val overflowOffset: Option[Long])\n\n    // Helper method to copy `records` into `segment`. Makes sure records being appended do not result in offset overflow."
  },
  {
    "id" : "5fba58e6-2ade-4edc-bd5c-029dbb195e8d",
    "prId" : 4975,
    "prUrl" : "https://github.com/apache/kafka/pull/4975#pullrequestreview-127408782",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7b495922-fadf-436f-856e-4c02d97d388a",
        "parentId" : null,
        "authorId" : "0c73d886-f3da-4107-8045-92d8e3c8fb75",
        "body" : "It seems we use the traversal of sortedNewSegments in descending order below.\r\n```\r\nnewSegments.sortBy(- _.baseOffset)\r\n```\r\nIf we use the above to sort, the code would be more readable.\r\n\r\nsortedNewSegments.tail should be used on line 1778",
        "createdAt" : "2018-06-10T20:19:56Z",
        "updatedAt" : "2018-06-10T20:20:49Z",
        "lastEditedBy" : "0c73d886-f3da-4107-8045-92d8e3c8fb75",
        "tags" : [
        ]
      }
    ],
    "commit" : "88121f86f4c732905a44c1bdb21b6383a2e073cf",
    "line" : 359,
    "diffHunk" : "@@ -1,1 +1762,1766 @@   */\n  private[log] def replaceSegments(newSegments: Seq[LogSegment], oldSegments: Seq[LogSegment], isRecoveredSwapFile: Boolean = false) {\n    val sortedNewSegments = newSegments.sortBy(_.baseOffset)\n    val sortedOldSegments = oldSegments.sortBy(_.baseOffset)\n"
  },
  {
    "id" : "614ab52f-32e1-4c0f-bf0e-eca2ac021af1",
    "prId" : 5133,
    "prUrl" : "https://github.com/apache/kafka/pull/5133#pullrequestreview-128601412",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fa002b9f-675b-4776-b974-6d6b1d1780d4",
        "parentId" : null,
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "Need to update the parameter list above",
        "createdAt" : "2018-06-13T23:38:48Z",
        "updatedAt" : "2018-06-14T05:35:55Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      }
    ],
    "commit" : "486f83e3422d512e3660225606caeb067a58b41f",
    "line" : 37,
    "diffHunk" : "@@ -1,1 +87,91 @@                         validBytes: Int,\n                         offsetsMonotonic: Boolean,\n                         lastOffsetOfFirstBatch: Long) {\n  /**\n   * Get the first offset if it exists, else get the last offset of the first batch"
  },
  {
    "id" : "bec53497-6112-4f18-a32a-2726ab00cef8",
    "prId" : 5169,
    "prUrl" : "https://github.com/apache/kafka/pull/5169#pullrequestreview-127652268",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fe60d4b8-c631-4897-8a35-2ca0fe6136b2",
        "parentId" : null,
        "authorId" : "93b1c273-8917-4547-bd53-5101f22161c0",
        "body" : "I am not sure if we want to throw an exception in this case. Could we have an overflown segment (may be produced by the log cleaner) such that messages appear only after the overflow offset?",
        "createdAt" : "2018-06-08T22:29:38Z",
        "updatedAt" : "2018-06-19T15:58:05Z",
        "lastEditedBy" : "93b1c273-8917-4547-bd53-5101f22161c0",
        "tags" : [
        ]
      },
      {
        "id" : "dead1cc7-93aa-467d-9a57-470ea47967f3",
        "parentId" : "fe60d4b8-c631-4897-8a35-2ca0fe6136b2",
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "Hmm.. That's an interesting point. It might be possible for a compacted topic since the base offset is only determined by the input segments. ",
        "createdAt" : "2018-06-09T05:12:28Z",
        "updatedAt" : "2018-06-19T15:58:05Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      },
      {
        "id" : "22893160-cd61-4128-9303-e66304e93fa9",
        "parentId" : "fe60d4b8-c631-4897-8a35-2ca0fe6136b2",
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "On second thought, I think this assertion is fine. We should always have at least one batch that we can append since we are starting the new segment from the base offset of the first batch. What needs to change for this case is the assertion below that `newSegments` is greater than one. I will fix this and add a test case.",
        "createdAt" : "2018-06-11T16:52:45Z",
        "updatedAt" : "2018-06-19T15:58:05Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      }
    ],
    "commit" : "c71b1e5937a33e525f483cd5d2edaa925fa68ccb",
    "line" : 157,
    "diffHunk" : "@@ -1,1 +1878,1882 @@        val bytesAppended = newSegment.appendFromFile(sourceRecords, position)\n        if (bytesAppended == 0)\n          throw new IllegalStateException(s\"Failed to append records from position $position in $segment\")\n\n        position += bytesAppended"
  },
  {
    "id" : "382ef6b2-1084-4b1f-a433-11358d8df7ff",
    "prId" : 5986,
    "prUrl" : "https://github.com/apache/kafka/pull/5986#pullrequestreview-180933235",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8b6639e2-612e-4127-b97d-da89475902e5",
        "parentId" : null,
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "I wonder if `newOffset <= activeSegment.baseOffset` would be a stricter validation?",
        "createdAt" : "2018-12-02T00:40:47Z",
        "updatedAt" : "2018-12-04T17:22:20Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      },
      {
        "id" : "43e8beea-a38e-4838-bb85-47dbafea5eff",
        "parentId" : "8b6639e2-612e-4127-b97d-da89475902e5",
        "authorId" : "e235ea82-83a9-41e5-8e3a-15b2e1b6f350",
        "body" : "Since we are already validating `newOffset == activeSegment.baseOffset`, `newOffset < activeSegment.baseOffset` means that logEndOffset is lower than base offset of the active segment (based on `val newOffset = math.max(expectedNextOffset, logEndOffset)`). We probably validate this in other places, but could be useful to validate here as well. In that case, I would still validate `if (segments.containsKey(newOffset)) {` separately, and `else if `newOffset < activeSegment.baseOffset` throw another KafkaException. What do you think?",
        "createdAt" : "2018-12-03T17:22:17Z",
        "updatedAt" : "2018-12-04T17:22:20Z",
        "lastEditedBy" : "e235ea82-83a9-41e5-8e3a-15b2e1b6f350",
        "tags" : [
        ]
      },
      {
        "id" : "77553851-7e25-446f-8ea7-ba4500f449db",
        "parentId" : "8b6639e2-612e-4127-b97d-da89475902e5",
        "authorId" : "e235ea82-83a9-41e5-8e3a-15b2e1b6f350",
        "body" : "Actually I think we don't need that additional validation. That would cause \"out of order offsets\" earlier when we try to do an append.",
        "createdAt" : "2018-12-03T18:33:24Z",
        "updatedAt" : "2018-12-04T17:22:20Z",
        "lastEditedBy" : "e235ea82-83a9-41e5-8e3a-15b2e1b6f350",
        "tags" : [
        ]
      },
      {
        "id" : "bf1686d0-347d-4629-8af3-6c0865006948",
        "parentId" : "8b6639e2-612e-4127-b97d-da89475902e5",
        "authorId" : "e235ea82-83a9-41e5-8e3a-15b2e1b6f350",
        "body" : "On a third thought, does not hurt to check that we are not rolling to offset < base offset of the active segment, even though a segment with this base offset does not exist.",
        "createdAt" : "2018-12-03T19:14:38Z",
        "updatedAt" : "2018-12-04T17:22:20Z",
        "lastEditedBy" : "e235ea82-83a9-41e5-8e3a-15b2e1b6f350",
        "tags" : [
        ]
      }
    ],
    "commit" : "e0cafe042f395068cab7dc3bdd079745960b4a37",
    "line" : 33,
    "diffHunk" : "@@ -1,1 +1571,1575 @@        val logFile = Log.logFile(dir, newOffset)\n\n        if (segments.containsKey(newOffset)) {\n          // segment with the same base offset already exists and loaded\n          if (activeSegment.baseOffset == newOffset && activeSegment.size == 0) {"
  },
  {
    "id" : "cfa90ac8-9e57-47a9-9dfb-2318936cfdbf",
    "prId" : 5986,
    "prUrl" : "https://github.com/apache/kafka/pull/5986#pullrequestreview-181034261",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7947c3d9-da4c-4a3c-b53f-8ccb79fcecb2",
        "parentId" : null,
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "nit: missing a space before `exists`",
        "createdAt" : "2018-12-03T21:59:57Z",
        "updatedAt" : "2018-12-04T17:22:20Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      },
      {
        "id" : "b4de25a9-2321-4434-882a-97c3eea54758",
        "parentId" : "7947c3d9-da4c-4a3c-b53f-8ccb79fcecb2",
        "authorId" : "e235ea82-83a9-41e5-8e3a-15b2e1b6f350",
        "body" : "added space after \"already\"",
        "createdAt" : "2018-12-03T23:42:03Z",
        "updatedAt" : "2018-12-04T17:22:20Z",
        "lastEditedBy" : "e235ea82-83a9-41e5-8e3a-15b2e1b6f350",
        "tags" : [
        ]
      }
    ],
    "commit" : "e0cafe042f395068cab7dc3bdd079745960b4a37",
    "line" : 40,
    "diffHunk" : "@@ -1,1 +1578,1582 @@            warn(s\"Trying to roll a new log segment with start offset $newOffset \" +\n                 s\"=max(provided offset = $expectedNextOffset, LEO = $logEndOffset) while it already \" +\n                 s\"exists and is active with size 0. Size of time index: ${activeSegment.timeIndex.entries},\" +\n                 s\" size of offset index: ${activeSegment.offsetIndex.entries}.\")\n            deleteSegment(activeSegment)"
  },
  {
    "id" : "0a07c6cb-0777-4f4a-87b5-3d066a636864",
    "prId" : 5986,
    "prUrl" : "https://github.com/apache/kafka/pull/5986#pullrequestreview-181034798",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "29d76210-488b-44dc-9291-c2429e8dbc3f",
        "parentId" : null,
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "I guess another option would be to resize the index files. Did you feel this would be more reliable?",
        "createdAt" : "2018-12-03T23:25:04Z",
        "updatedAt" : "2018-12-04T17:22:20Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      },
      {
        "id" : "a9a7a8a6-6a77-4908-a181-e2b0c15953eb",
        "parentId" : "29d76210-488b-44dc-9291-c2429e8dbc3f",
        "authorId" : "e235ea82-83a9-41e5-8e3a-15b2e1b6f350",
        "body" : "I am concerned about resizing index, because it does not seem like the issue happens because we explicitly resize the index. Seems like something happens to mmaped file, which we don't understand yet. So, it seems more reliable to remove and recreate the segment.",
        "createdAt" : "2018-12-03T23:44:11Z",
        "updatedAt" : "2018-12-04T17:22:20Z",
        "lastEditedBy" : "e235ea82-83a9-41e5-8e3a-15b2e1b6f350",
        "tags" : [
        ]
      }
    ],
    "commit" : "e0cafe042f395068cab7dc3bdd079745960b4a37",
    "line" : 42,
    "diffHunk" : "@@ -1,1 +1580,1584 @@                 s\"exists and is active with size 0. Size of time index: ${activeSegment.timeIndex.entries},\" +\n                 s\" size of offset index: ${activeSegment.offsetIndex.entries}.\")\n            deleteSegment(activeSegment)\n          } else {\n            throw new KafkaException(s\"Trying to roll a new log segment for topic partition $topicPartition with start offset $newOffset\" +"
  }
]
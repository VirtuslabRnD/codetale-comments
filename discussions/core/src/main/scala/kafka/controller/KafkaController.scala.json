[
  {
    "id" : "773d4b80-c279-43b2-88bf-ebcb1c0b2cb4",
    "prId" : 3848,
    "prUrl" : "https://github.com/apache/kafka/pull/3848#pullrequestreview-191900203",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ef6953b8-aa74-4511-9ea1-e02ae2195547",
        "parentId" : null,
        "authorId" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "body" : "Could we add a comment to describe the return value of the method?",
        "createdAt" : "2019-01-11T23:43:21Z",
        "updatedAt" : "2019-01-25T09:57:17Z",
        "lastEditedBy" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "tags" : [
        ]
      }
    ],
    "commit" : "9df18c6b3232f3e8b9bf879b7a8dd762a5968c6c",
    "line" : 59,
    "diffHunk" : "@@ -1,1 +642,646 @@    *         the exception that was thrown.\n    */\n  private def onPreferredReplicaElection(partitions: Set[TopicPartition],\n                                         electionType: ElectionType): Map[TopicPartition, Throwable] = {\n    info(s\"Starting preferred replica leader election for partitions ${partitions.mkString(\",\")}\")"
  },
  {
    "id" : "0e2059fe-ddcf-4678-891d-82db179bd47a",
    "prId" : 3848,
    "prUrl" : "https://github.com/apache/kafka/pull/3848#pullrequestreview-193898101",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9240abc8-4848-40d9-b918-7d981e4a2ed8",
        "parentId" : null,
        "authorId" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "body" : "This is an existing issue. When handing a ZK session expiration, we call beforeInitializingSession, which first clear the event queue before adding an Expire event. The issue is that the clear events including PreferredReplicaLeaderElection or ControlledShutdown and the callbacks on those events won't be called. This means the client will never receive a response and will time out. I am thinking that one way to fix this is the following: go through each cleared event and if the event has a callback, call the callback with an error.",
        "createdAt" : "2019-01-15T00:04:20Z",
        "updatedAt" : "2019-01-25T09:57:17Z",
        "lastEditedBy" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "tags" : [
        ]
      },
      {
        "id" : "1db53abf-74aa-4ace-8b25-b7d539363c0c",
        "parentId" : "9240abc8-4848-40d9-b918-7d981e4a2ed8",
        "authorId" : "491bcd91-bc8d-4f54-b5fd-d6c7be5e8693",
        "body" : "Makes sense. Do you want me to implement this for `PreferredReplicaLeaderElection` _and `ControlledShutdown`_? What testing would you like to see?",
        "createdAt" : "2019-01-16T11:16:09Z",
        "updatedAt" : "2019-01-25T09:57:17Z",
        "lastEditedBy" : "491bcd91-bc8d-4f54-b5fd-d6c7be5e8693",
        "tags" : [
        ]
      },
      {
        "id" : "46117d22-0e70-46dd-b273-62e25bfed6f3",
        "parentId" : "9240abc8-4848-40d9-b918-7d981e4a2ed8",
        "authorId" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "body" : "Right now, only PreferredReplicaLeaderElection and ControlledShutdown have callbacks. So, we can just handle them. As for testing, perhaps we can queue up some events in ControllerEventManager and call clearAndPut(), and assert that the queued events' callback are called.",
        "createdAt" : "2019-01-17T23:55:56Z",
        "updatedAt" : "2019-01-25T09:57:17Z",
        "lastEditedBy" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "tags" : [
        ]
      }
    ],
    "commit" : "9df18c6b3232f3e8b9bf879b7a8dd762a5968c6c",
    "line" : 150,
    "diffHunk" : "@@ -1,1 +1562,1566 @@\n    override def handleProcess(): Unit = {\n      if (!isActive) {\n        callback(Map.empty, partitionsFromAdminClientOpt match {\n          case Some(partitions) => partitions.map(partition => partition -> new ApiError(Errors.NOT_CONTROLLER, null)).toMap"
  },
  {
    "id" : "d7394551-afc0-47cc-97c8-da207d93262b",
    "prId" : 4488,
    "prUrl" : "https://github.com/apache/kafka/pull/4488#pullrequestreview-93799718",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4c34c6cb-528c-491b-aa77-2d7dc1be7470",
        "parentId" : null,
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "Perhaps we should have a log message?",
        "createdAt" : "2018-02-02T22:21:32Z",
        "updatedAt" : "2018-02-04T02:11:57Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      },
      {
        "id" : "785640b7-014e-49d0-9d26-e06e3453708c",
        "parentId" : "4c34c6cb-528c-491b-aa77-2d7dc1be7470",
        "authorId" : "b4936a15-698a-496e-85a1-b1e229b4986b",
        "body" : "Since we have a log message in the process() method of BrokerModifications, do we need another one here? For other events, logging is in `process()` method of the event.",
        "createdAt" : "2018-02-03T01:15:58Z",
        "updatedAt" : "2018-02-04T02:11:57Z",
        "lastEditedBy" : "b4936a15-698a-496e-85a1-b1e229b4986b",
        "tags" : [
        ]
      }
    ],
    "commit" : "a0488d78e0ea02c3ddde1a31f6c1e0613a443e3d",
    "line" : 121,
    "diffHunk" : "@@ -1,1 +1520,1524 @@  override val path: String = BrokerIdZNode.path(brokerId)\n\n  override def handleDataChange(): Unit = {\n    eventManager.put(controller.BrokerModifications)\n  }"
  },
  {
    "id" : "549b8e7f-9665-4d71-973c-dbcb7ddb7ed6",
    "prId" : 4488,
    "prUrl" : "https://github.com/apache/kafka/pull/4488#pullrequestreview-102563161",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "df864efb-d0d6-44f7-8bfc-8a1086938226",
        "parentId" : null,
        "authorId" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "body" : "@rajinisivaram : Sorry for the late review. Just a minor comment. It seems that we can avoid reading all brokers from ZK by passing in brokerId to BrokerModifications and only read the info for that brokerId?",
        "createdAt" : "2018-03-01T22:31:33Z",
        "updatedAt" : "2018-03-01T22:31:33Z",
        "lastEditedBy" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "tags" : [
        ]
      },
      {
        "id" : "b3abdce9-42e4-4377-b6f0-c316c5aa14eb",
        "parentId" : "df864efb-d0d6-44f7-8bfc-8a1086938226",
        "authorId" : "b4936a15-698a-496e-85a1-b1e229b4986b",
        "body" : "@junrao Thanks for the review. Opened PR #4670.",
        "createdAt" : "2018-03-09T07:34:43Z",
        "updatedAt" : "2018-03-09T07:34:43Z",
        "lastEditedBy" : "b4936a15-698a-496e-85a1-b1e229b4986b",
        "tags" : [
        ]
      }
    ],
    "commit" : "a0488d78e0ea02c3ddde1a31f6c1e0613a443e3d",
    "line" : 88,
    "diffHunk" : "@@ -1,1 +1246,1250 @@      if (!isActive) return\n      val curBrokers = zkClient.getAllBrokersInCluster.toSet\n      val updatedBrokers = controllerContext.liveBrokers.filter { broker =>\n        val existingBroker = curBrokers.find(_.id == broker.id)\n        existingBroker match {"
  }
]
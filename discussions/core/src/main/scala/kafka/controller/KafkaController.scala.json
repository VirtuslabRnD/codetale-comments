[
  {
    "id" : "773d4b80-c279-43b2-88bf-ebcb1c0b2cb4",
    "prId" : 3848,
    "prUrl" : "https://github.com/apache/kafka/pull/3848#pullrequestreview-191900203",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ef6953b8-aa74-4511-9ea1-e02ae2195547",
        "parentId" : null,
        "authorId" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "body" : "Could we add a comment to describe the return value of the method?",
        "createdAt" : "2019-01-11T23:43:21Z",
        "updatedAt" : "2019-01-25T09:57:17Z",
        "lastEditedBy" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "tags" : [
        ]
      }
    ],
    "commit" : "9df18c6b3232f3e8b9bf879b7a8dd762a5968c6c",
    "line" : 59,
    "diffHunk" : "@@ -1,1 +642,646 @@    *         the exception that was thrown.\n    */\n  private def onPreferredReplicaElection(partitions: Set[TopicPartition],\n                                         electionType: ElectionType): Map[TopicPartition, Throwable] = {\n    info(s\"Starting preferred replica leader election for partitions ${partitions.mkString(\",\")}\")"
  },
  {
    "id" : "0e2059fe-ddcf-4678-891d-82db179bd47a",
    "prId" : 3848,
    "prUrl" : "https://github.com/apache/kafka/pull/3848#pullrequestreview-193898101",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9240abc8-4848-40d9-b918-7d981e4a2ed8",
        "parentId" : null,
        "authorId" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "body" : "This is an existing issue. When handing a ZK session expiration, we call beforeInitializingSession, which first clear the event queue before adding an Expire event. The issue is that the clear events including PreferredReplicaLeaderElection or ControlledShutdown and the callbacks on those events won't be called. This means the client will never receive a response and will time out. I am thinking that one way to fix this is the following: go through each cleared event and if the event has a callback, call the callback with an error.",
        "createdAt" : "2019-01-15T00:04:20Z",
        "updatedAt" : "2019-01-25T09:57:17Z",
        "lastEditedBy" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "tags" : [
        ]
      },
      {
        "id" : "1db53abf-74aa-4ace-8b25-b7d539363c0c",
        "parentId" : "9240abc8-4848-40d9-b918-7d981e4a2ed8",
        "authorId" : "491bcd91-bc8d-4f54-b5fd-d6c7be5e8693",
        "body" : "Makes sense. Do you want me to implement this for `PreferredReplicaLeaderElection` _and `ControlledShutdown`_? What testing would you like to see?",
        "createdAt" : "2019-01-16T11:16:09Z",
        "updatedAt" : "2019-01-25T09:57:17Z",
        "lastEditedBy" : "491bcd91-bc8d-4f54-b5fd-d6c7be5e8693",
        "tags" : [
        ]
      },
      {
        "id" : "46117d22-0e70-46dd-b273-62e25bfed6f3",
        "parentId" : "9240abc8-4848-40d9-b918-7d981e4a2ed8",
        "authorId" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "body" : "Right now, only PreferredReplicaLeaderElection and ControlledShutdown have callbacks. So, we can just handle them. As for testing, perhaps we can queue up some events in ControllerEventManager and call clearAndPut(), and assert that the queued events' callback are called.",
        "createdAt" : "2019-01-17T23:55:56Z",
        "updatedAt" : "2019-01-25T09:57:17Z",
        "lastEditedBy" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "tags" : [
        ]
      }
    ],
    "commit" : "9df18c6b3232f3e8b9bf879b7a8dd762a5968c6c",
    "line" : 150,
    "diffHunk" : "@@ -1,1 +1562,1566 @@\n    override def handleProcess(): Unit = {\n      if (!isActive) {\n        callback(Map.empty, partitionsFromAdminClientOpt match {\n          case Some(partitions) => partitions.map(partition => partition -> new ApiError(Errors.NOT_CONTROLLER, null)).toMap"
  }
]
[
  {
    "id" : "396592ba-63a3-42ed-b9a9-98c73d49ec05",
    "prId" : 4825,
    "prUrl" : "https://github.com/apache/kafka/pull/4825#pullrequestreview-112192483",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a82748c1-4652-4376-a52d-90b49e2aa9ac",
        "parentId" : null,
        "authorId" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "body" : "It seems that we could just iterate on validReplicas and get rid of the code from line 217 to 219?",
        "createdAt" : "2018-04-12T01:19:31Z",
        "updatedAt" : "2018-04-14T01:45:12Z",
        "lastEditedBy" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "tags" : [
        ]
      },
      {
        "id" : "6302385f-fa95-47fe-a6d1-8e50fd261c63",
        "parentId" : "a82748c1-4652-4376-a52d-90b49e2aa9ac",
        "authorId" : "7d732cb7-eb6e-42e2-a773-db6c10d43f26",
        "body" : "If we do that, then the replicas with leadership, but failed to be removed from ISR would also transition to OfflineReplica state. The removeReplicasFromIsr already has logic to mark those replica transitions as failed, so doing that would generate confusing logs.",
        "createdAt" : "2018-04-14T01:38:53Z",
        "updatedAt" : "2018-04-14T01:45:12Z",
        "lastEditedBy" : "7d732cb7-eb6e-42e2-a773-db6c10d43f26",
        "tags" : [
        ]
      }
    ],
    "commit" : "029cfa62bda7522c2197c26cbcb2ef4909beec2c",
    "line" : 21,
    "diffHunk" : "@@ -1,1 +223,227 @@          logSuccessfulTransition(replicaId, replica.topicPartition, replicaState(replica), OfflineReplica)\n          replicaState.put(replica, OfflineReplica)\n        }\n      case ReplicaDeletionStarted =>\n        validReplicas.foreach { replica =>"
  },
  {
    "id" : "f3238ab5-e882-4621-8dd7-1ac84bb67d50",
    "prId" : 6588,
    "prUrl" : "https://github.com/apache/kafka/pull/6588#pullrequestreview-229239604",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e89b6209-034c-4dff-b847-5bdb7ccd1588",
        "parentId" : null,
        "authorId" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "body" : "Should we mark this as override?",
        "createdAt" : "2019-04-22T22:47:20Z",
        "updatedAt" : "2019-04-24T22:00:55Z",
        "lastEditedBy" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "tags" : [
        ]
      }
    ],
    "commit" : "6b68fbe3cb047ef1c25bacb7c65955805306c96c",
    "line" : 78,
    "diffHunk" : "@@ -1,1 +69,73 @@  }\n\n  def handleStateChanges(replicas: Seq[PartitionAndReplica], targetState: ReplicaState): Unit\n}\n"
  },
  {
    "id" : "fa96e98d-ed12-4589-93f9-dda9189a096d",
    "prId" : 6588,
    "prUrl" : "https://github.com/apache/kafka/pull/6588#pullrequestreview-229239604",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "59569fe2-570a-4bec-95fd-b99d52960696",
        "parentId" : null,
        "authorId" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "body" : "This change seems reasonable. Could we update the comment in line 88 accordingly?",
        "createdAt" : "2019-04-22T22:53:32Z",
        "updatedAt" : "2019-04-24T22:00:55Z",
        "lastEditedBy" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "tags" : [
        ]
      }
    ],
    "commit" : "6b68fbe3cb047ef1c25bacb7c65955805306c96c",
    "line" : 319,
    "diffHunk" : "@@ -1,1 +428,432 @@case object ReplicaDeletionIneligible extends ReplicaState {\n  val state: Byte = 6\n  val validPreviousStates: Set[ReplicaState] = Set(OfflineReplica, ReplicaDeletionStarted)\n}\n"
  },
  {
    "id" : "98c3a5f7-a328-4b21-bdb2-527eeed7a555",
    "prId" : 7924,
    "prUrl" : "https://github.com/apache/kafka/pull/7924#pullrequestreview-341478434",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e507972d-2f3d-4c39-8ad6-d1c6f9b8f542",
        "parentId" : null,
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "This code smells a bit (not from this PR). Feels like we need to refetch the assignment state in order to confirm whether the replicaId should be there or not. I guess after zk removal, the controller context will be guaranteed to be up to date and we can improve this.",
        "createdAt" : "2020-01-10T21:56:43Z",
        "updatedAt" : "2020-01-10T21:57:24Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      },
      {
        "id" : "75a32714-41cd-410d-a610-e26a884e1219",
        "parentId" : "e507972d-2f3d-4c39-8ad6-d1c6f9b8f542",
        "authorId" : "4a7c311c-0954-4671-a0d2-266cb67437ad",
        "body" : "Yeah. This state machine is a little strange. I convinced myself that this condition is not possible. The controllers needs to find out that `replicaId` is assigned to `partition` to be able to call `doHandleStateChanges` with those values and this is only possible if `controllerContext` has this information.\r\n\r\nAnother insight to why this code path is not possible is that this condition would magically change the ordering of the assignment.\r\n\r\nI made the conservative change and simply logged an error message. If we are interested, I can revisit this code to remove this code path.",
        "createdAt" : "2020-01-10T22:21:56Z",
        "updatedAt" : "2020-01-10T22:21:56Z",
        "lastEditedBy" : "4a7c311c-0954-4671-a0d2-266cb67437ad",
        "tags" : [
        ]
      },
      {
        "id" : "8805186d-1093-4c68-81c2-c5b901583c54",
        "parentId" : "e507972d-2f3d-4c39-8ad6-d1c6f9b8f542",
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "Yeah, we don't need to do it here, but if you think the state is not reachable, I'd suggest filing a separate PR. I'd rather raise an error instead of trying to fix up some state inconsistency. It's a bit arbitrary to assume the state change is probably right.",
        "createdAt" : "2020-01-10T23:50:27Z",
        "updatedAt" : "2020-01-10T23:50:27Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      }
    ],
    "commit" : "137563e19e1c116edc0818e57b7c1b4f7c97d115",
    "line" : 10,
    "diffHunk" : "@@ -1,1 +196,200 @@              if (!assignment.replicas.contains(replicaId)) {\n                error(s\"Adding replica ($replicaId) that is not part of the assignment $assignment\")\n                val newAssignment = assignment.copy(replicas = assignment.replicas :+ replicaId)\n                controllerContext.updatePartitionFullReplicaAssignment(partition, newAssignment)\n              }"
  }
]
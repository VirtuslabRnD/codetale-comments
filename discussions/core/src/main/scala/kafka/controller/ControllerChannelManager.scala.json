[
  {
    "id" : "2a223157-681f-4310-ac9a-153ec4a65c3a",
    "prId" : 6588,
    "prUrl" : "https://github.com/apache/kafka/pull/6588#pullrequestreview-227999811",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "70b6a15e-1373-481e-b258-03710504fa7b",
        "parentId" : null,
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "TODO: `if (deletePartititon)`",
        "createdAt" : "2019-04-17T21:08:55Z",
        "updatedAt" : "2019-04-24T22:00:55Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      }
    ],
    "commit" : "6b68fbe3cb047ef1c25bacb7c65955805306c96c",
    "line" : 20,
    "diffHunk" : "@@ -1,1 +357,361 @@    brokerIds.filter(_ >= 0).foreach { brokerId =>\n      def topicDeletionCallback(stopReplicaResponse: AbstractResponse): Unit = {\n        controller.eventManager.put(controller.TopicDeletionStopReplicaResponseReceived(stopReplicaResponse, brokerId))\n      }\n"
  },
  {
    "id" : "1d390158-8d6d-49a7-9562-5e3caaa4af4d",
    "prId" : 6642,
    "prUrl" : "https://github.com/apache/kafka/pull/6642#pullrequestreview-231677498",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a1f80795-3929-4a57-9d6e-14c7fd29f1c9",
        "parentId" : null,
        "authorId" : "d8c7cf80-a55a-474c-a4f4-f60a9efda52c",
        "body" : "Out of curiosity, why are we using `ListBuffer`?",
        "createdAt" : "2019-04-29T13:34:38Z",
        "updatedAt" : "2019-05-13T23:04:49Z",
        "lastEditedBy" : "d8c7cf80-a55a-474c-a4f4-f60a9efda52c",
        "tags" : [
        ]
      }
    ],
    "commit" : "d3d0db41a3c6ca30e89f9e83db0959b2bb88eef9",
    "line" : 93,
    "diffHunk" : "@@ -1,1 +335,339 @@  val controllerId: Int = config.brokerId\n  val leaderAndIsrRequestMap = mutable.Map.empty[Int, mutable.Map[TopicPartition, LeaderAndIsrRequest.PartitionState]]\n  val stopReplicaRequestMap = mutable.Map.empty[Int, ListBuffer[StopReplicaRequestInfo]]\n  val updateMetadataRequestBrokerSet = mutable.Set.empty[Int]\n  val updateMetadataRequestPartitionInfoMap = mutable.Map.empty[TopicPartition, UpdateMetadataRequest.PartitionState]"
  },
  {
    "id" : "821fb801-8ab3-4b65-afc6-8de65e5d83fc",
    "prId" : 6642,
    "prUrl" : "https://github.com/apache/kafka/pull/6642#pullrequestreview-236939981",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0075f6f8-b12d-42ed-9035-59610a9e2ead",
        "parentId" : null,
        "authorId" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "body" : "This is probably an existing issue. We have the following code in line 79. Since removeExistingBroker updates brokerStateInfo directly, I am wondering if this will prevent values() from iterating all entries.\r\n\r\n`brokerStateInfo.values.foreach(removeExistingBroker)`",
        "createdAt" : "2019-05-07T21:01:53Z",
        "updatedAt" : "2019-05-13T23:04:49Z",
        "lastEditedBy" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "tags" : [
        ]
      },
      {
        "id" : "02d86f86-6e7b-4fec-a015-4d36ecf47134",
        "parentId" : "0075f6f8-b12d-42ed-9035-59610a9e2ead",
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "I am not sure. Probably best to make a copy.",
        "createdAt" : "2019-05-13T21:57:18Z",
        "updatedAt" : "2019-05-13T23:04:49Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      }
    ],
    "commit" : "d3d0db41a3c6ca30e89f9e83db0959b2bb88eef9",
    "line" : 34,
    "diffHunk" : "@@ -1,1 +69,73 @@  def startup() = {\n    controllerContext.liveOrShuttingDownBrokers.foreach(addNewBroker)\n\n    brokerLock synchronized {\n      brokerStateInfo.foreach(brokerState => startRequestSendThread(brokerState._1))"
  },
  {
    "id" : "105c3c42-9ee3-4f37-83f3-a08d1a6ad174",
    "prId" : 8257,
    "prUrl" : "https://github.com/apache/kafka/pull/8257#pullrequestreview-392909695",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b73280fc-325e-410a-aa19-ea84e8211476",
        "parentId" : null,
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "No need to fix here, but do you know why we do this filtering?",
        "createdAt" : "2020-04-14T01:22:29Z",
        "updatedAt" : "2020-04-14T13:16:08Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      },
      {
        "id" : "d26681be-fafc-4f88-807c-67dc2321d34f",
        "parentId" : "b73280fc-325e-410a-aa19-ea84e8211476",
        "authorId" : "59ca7821-b29c-4f24-a9d5-cbd394145686",
        "body" : "I've asked myself the same question but I couldn't find a reason. I believe that `brokerId` is always >= 0 in the controller.",
        "createdAt" : "2020-04-14T13:10:09Z",
        "updatedAt" : "2020-04-14T13:16:08Z",
        "lastEditedBy" : "59ca7821-b29c-4f24-a9d5-cbd394145686",
        "tags" : [
        ]
      }
    ],
    "commit" : "49360d6d46bf292c7b9a774be923073fd049c19d",
    "line" : 48,
    "diffHunk" : "@@ -1,1 +406,410 @@    }\n\n    brokerIds.filter(_ >= 0).foreach { brokerId =>\n      val result = stopReplicaRequestMap.getOrElseUpdate(brokerId, mutable.Map.empty)\n      val alreadyDelete = result.get(topicPartition).exists(_.deletePartition)"
  }
]
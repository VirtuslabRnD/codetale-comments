[
  {
    "id" : "d8800936-26f3-4972-b736-c1e11f8d6942",
    "prId" : 4896,
    "prUrl" : "https://github.com/apache/kafka/pull/4896#pullrequestreview-124955033",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e574da4f-a299-495d-9a0f-9f4c30d31060",
        "parentId" : null,
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "This is a little confusing. The function `baseTimestamp` can return -1 if no current state timestamp is set, which would cause this check to incorrectly succeed. This would be the case if we were loading the state of a group which existed before we began using the new group metadata schema. Are there any guards which prevent this case?\r\n\r\nBasically the problem is that we need to handle the case that there is no expiration timestamp and there is no current state timestamp. I think in this case, `baseTimestamp` should just use the commit timestamp, which is basically like reverting to the old behavior. In other words, we should only be allowed to use the new behavior if `currentStateTimestamp` is defined.",
        "createdAt" : "2018-05-31T07:19:11Z",
        "updatedAt" : "2018-06-20T21:29:56Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      },
      {
        "id" : "778326f2-1092-4588-99b0-0de163530933",
        "parentId" : "e574da4f-a299-495d-9a0f-9f4c30d31060",
        "authorId" : "2a5e5a4d-e0e2-4e26-b139-0930dd63f949",
        "body" : "That's correct. Your suggested solution should work, and is implemented in the new commit. Thanks!",
        "createdAt" : "2018-05-31T20:14:30Z",
        "updatedAt" : "2018-06-20T21:29:56Z",
        "lastEditedBy" : "2a5e5a4d-e0e2-4e26-b139-0930dd63f949",
        "tags" : [
        ]
      }
    ],
    "commit" : "2b688c84bae947aeab8d28896ee109330fca0cf5",
    "line" : 74,
    "diffHunk" : "@@ -1,1 +451,455 @@              case None =>\n                // current version with no per partition retention\n                currentTimestamp - baseTimestamp(commitRecordMetadataAndOffset) >= offsetRetentionMs\n              case Some(expireTimestamp) =>\n                // older versions with explicit expire_timestamp field => old expiration semantics is used"
  },
  {
    "id" : "78953c9d-f089-465d-84d0-3e1eca77df0f",
    "prId" : 6058,
    "prUrl" : "https://github.com/apache/kafka/pull/6058#pullrequestreview-189107591",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d14c5107-2ff9-412c-80c4-2e76c5a7704a",
        "parentId" : null,
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "Is it ever possible that a memberId is in both collections?",
        "createdAt" : "2019-01-03T01:17:00Z",
        "updatedAt" : "2019-01-15T03:26:21Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      },
      {
        "id" : "5d7c8c3c-dff7-4c16-b871-2d1b71afeeeb",
        "parentId" : "d14c5107-2ff9-412c-80c4-2e76c5a7704a",
        "authorId" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "body" : "In the current logic, no, adding the check here just to ensure no one accidentally break the handling logic.",
        "createdAt" : "2019-01-03T17:27:37Z",
        "updatedAt" : "2019-01-15T03:26:21Z",
        "lastEditedBy" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "tags" : [
        ]
      }
    ],
    "commit" : "29f668ef1a9b2ee5939791b9bd5b89bf1a1660bb",
    "line" : 21,
    "diffHunk" : "@@ -1,1 +241,245 @@  }\n\n  def isPendingMember(memberId: String): Boolean = pendingMembers.contains(memberId) && !has(memberId)\n\n  def addPendingMember(memberId: String) = pendingMembers.add(memberId)"
  }
]
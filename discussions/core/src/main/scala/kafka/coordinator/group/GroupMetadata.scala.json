[
  {
    "id" : "d8800936-26f3-4972-b736-c1e11f8d6942",
    "prId" : 4896,
    "prUrl" : "https://github.com/apache/kafka/pull/4896#pullrequestreview-124955033",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e574da4f-a299-495d-9a0f-9f4c30d31060",
        "parentId" : null,
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "This is a little confusing. The function `baseTimestamp` can return -1 if no current state timestamp is set, which would cause this check to incorrectly succeed. This would be the case if we were loading the state of a group which existed before we began using the new group metadata schema. Are there any guards which prevent this case?\r\n\r\nBasically the problem is that we need to handle the case that there is no expiration timestamp and there is no current state timestamp. I think in this case, `baseTimestamp` should just use the commit timestamp, which is basically like reverting to the old behavior. In other words, we should only be allowed to use the new behavior if `currentStateTimestamp` is defined.",
        "createdAt" : "2018-05-31T07:19:11Z",
        "updatedAt" : "2018-06-20T21:29:56Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      },
      {
        "id" : "778326f2-1092-4588-99b0-0de163530933",
        "parentId" : "e574da4f-a299-495d-9a0f-9f4c30d31060",
        "authorId" : "2a5e5a4d-e0e2-4e26-b139-0930dd63f949",
        "body" : "That's correct. Your suggested solution should work, and is implemented in the new commit. Thanks!",
        "createdAt" : "2018-05-31T20:14:30Z",
        "updatedAt" : "2018-06-20T21:29:56Z",
        "lastEditedBy" : "2a5e5a4d-e0e2-4e26-b139-0930dd63f949",
        "tags" : [
        ]
      }
    ],
    "commit" : "2b688c84bae947aeab8d28896ee109330fca0cf5",
    "line" : 74,
    "diffHunk" : "@@ -1,1 +451,455 @@              case None =>\n                // current version with no per partition retention\n                currentTimestamp - baseTimestamp(commitRecordMetadataAndOffset) >= offsetRetentionMs\n              case Some(expireTimestamp) =>\n                // older versions with explicit expire_timestamp field => old expiration semantics is used"
  },
  {
    "id" : "78953c9d-f089-465d-84d0-3e1eca77df0f",
    "prId" : 6058,
    "prUrl" : "https://github.com/apache/kafka/pull/6058#pullrequestreview-189107591",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d14c5107-2ff9-412c-80c4-2e76c5a7704a",
        "parentId" : null,
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "Is it ever possible that a memberId is in both collections?",
        "createdAt" : "2019-01-03T01:17:00Z",
        "updatedAt" : "2019-01-15T03:26:21Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      },
      {
        "id" : "5d7c8c3c-dff7-4c16-b871-2d1b71afeeeb",
        "parentId" : "d14c5107-2ff9-412c-80c4-2e76c5a7704a",
        "authorId" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "body" : "In the current logic, no, adding the check here just to ensure no one accidentally break the handling logic.",
        "createdAt" : "2019-01-03T17:27:37Z",
        "updatedAt" : "2019-01-15T03:26:21Z",
        "lastEditedBy" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "tags" : [
        ]
      }
    ],
    "commit" : "29f668ef1a9b2ee5939791b9bd5b89bf1a1660bb",
    "line" : 21,
    "diffHunk" : "@@ -1,1 +241,245 @@  }\n\n  def isPendingMember(memberId: String): Boolean = pendingMembers.contains(memberId) && !has(memberId)\n\n  def addPendingMember(memberId: String) = pendingMembers.add(memberId)"
  },
  {
    "id" : "39865731-612f-47a6-963a-c5c288ec23e2",
    "prId" : 6163,
    "prUrl" : "https://github.com/apache/kafka/pull/6163#pullrequestreview-194059714",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "cdc8a01d-ae4e-4584-a2f7-86a600377d5c",
        "parentId" : null,
        "authorId" : "979e3650-ce20-4720-a0da-e44d283b558b",
        "body" : "is this an intentional bugfix? ",
        "createdAt" : "2019-01-17T19:07:32Z",
        "updatedAt" : "2019-02-01T23:36:21Z",
        "lastEditedBy" : "979e3650-ce20-4720-a0da-e44d283b558b",
        "tags" : [
        ]
      },
      {
        "id" : "2692b075-f57f-4e4c-9aa5-0812ddfead19",
        "parentId" : "cdc8a01d-ae4e-4584-a2f7-86a600377d5c",
        "authorId" : "df911192-d6c6-4af9-8568-f67bf2dcf926",
        "body" : "Yes, we discussed it offline with @hachikuji. We should never have `members.size < numMembersAwaitingJoin`",
        "createdAt" : "2019-01-18T11:44:32Z",
        "updatedAt" : "2019-02-01T23:36:21Z",
        "lastEditedBy" : "df911192-d6c6-4af9-8568-f67bf2dcf926",
        "tags" : [
        ]
      }
    ],
    "commit" : "1421a43a3fcf28c99477bea7a1499a8fa17e50d9",
    "line" : 33,
    "diffHunk" : "@@ -1,1 +252,256 @@  def notYetRejoinedMembers = members.values.filter(!_.isAwaitingJoin).toList\n\n  def hasAllMembersJoined = members.size == numMembersAwaitingJoin && pendingMembers.isEmpty\n\n  def allMembers = members.keySet"
  },
  {
    "id" : "7976cc89-5f15-4e07-8caa-4cc3cb8b5087",
    "prId" : 6177,
    "prUrl" : "https://github.com/apache/kafka/pull/6177#pullrequestreview-230892121",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d9bd0c74-3fbc-4f01-81d8-dbd8acb1de35",
        "parentId" : null,
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "For all the three callers of it: two already checks `member.isStaticMember` and one has the assert already. So I'd suggest we pass in `groupInstanceId: String` as parameter directly from caller.",
        "createdAt" : "2019-04-23T00:18:13Z",
        "updatedAt" : "2019-04-26T15:12:49Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "d6a2f453-cd8e-47eb-bbf4-28b912a8d132",
        "parentId" : "d9bd0c74-3fbc-4f01-81d8-dbd8acb1de35",
        "authorId" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "body" : "We could remove the assertion here, but I guess we still need to throw exception since new caller may forget to check it.",
        "createdAt" : "2019-04-23T04:20:25Z",
        "updatedAt" : "2019-04-26T15:12:49Z",
        "lastEditedBy" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "tags" : [
        ]
      },
      {
        "id" : "0fa34126-2e07-431d-8eab-a4f3d67b4d32",
        "parentId" : "d9bd0c74-3fbc-4f01-81d8-dbd8acb1de35",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "That sounds good. We can check that the passed in `String` (not `Option[String]` for simplicity since all current callers actually can pass in the string parameter) is not null and throw otherwise.",
        "createdAt" : "2019-04-24T01:28:38Z",
        "updatedAt" : "2019-04-26T15:12:49Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "7ee2446c-b022-4a0d-b540-14d34e7ce24b",
        "parentId" : "d9bd0c74-3fbc-4f01-81d8-dbd8acb1de35",
        "authorId" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "body" : "I feel we could keep Option[String] in the function parameters. The reason is for consistent handling of this piece of information in GroupCoordinator until we actually extract the String for internal data structure update. The other approach would be using the case switch here which is more Option friendly. WDYT?",
        "createdAt" : "2019-04-24T04:45:48Z",
        "updatedAt" : "2019-04-26T15:12:49Z",
        "lastEditedBy" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "tags" : [
        ]
      },
      {
        "id" : "2986b8dc-fed4-4ac3-a726-a2c1c3d8f20b",
        "parentId" : "d9bd0c74-3fbc-4f01-81d8-dbd8acb1de35",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "After a second thought I think I agree with you, it's not worth optimizing the parameter while giving up consistency in call traces.",
        "createdAt" : "2019-04-25T21:23:36Z",
        "updatedAt" : "2019-04-26T15:12:49Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      }
    ],
    "commit" : "932118542844c01e3caf657e2eee9c16dfd269d7",
    "line" : 72,
    "diffHunk" : "@@ -1,1 +282,286 @@  }\n\n  def addStaticMember(groupInstanceId: Option[String], newMemberId: String) = {\n    if(groupInstanceId.isEmpty) {\n      throw new IllegalArgumentException(s\"unexpected null group.instance.id in addStaticMember\")"
  },
  {
    "id" : "467b2897-a9e1-4d81-b051-59a238755d2e",
    "prId" : 6650,
    "prUrl" : "https://github.com/apache/kafka/pull/6650#pullrequestreview-239079340",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e40714e0-35db-4171-87f3-64d2e21d8f66",
        "parentId" : null,
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "Ah this is better. Thanks for the refactoring.",
        "createdAt" : "2019-05-17T19:36:24Z",
        "updatedAt" : "2019-05-18T04:04:24Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      }
    ],
    "commit" : "4a0c245434329139d931b0cc904704ef8c26a62c",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +254,258 @@    */\n  def maybeElectNewJoinedLeader(): Boolean = {\n    leaderId.exists { currentLeaderId =>\n      val currentLeader = get(currentLeaderId)\n      if (!currentLeader.isAwaitingJoin) {"
  },
  {
    "id" : "05b29e5d-98a3-41d6-a792-8fc702c6c328",
    "prId" : 6899,
    "prUrl" : "https://github.com/apache/kafka/pull/6899#pullrequestreview-247907179",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5afe0b58-6e26-4e22-9981-4e288898d678",
        "parentId" : null,
        "authorId" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "body" : "should also fence sync callback",
        "createdAt" : "2019-06-11T00:41:22Z",
        "updatedAt" : "2019-06-12T04:56:07Z",
        "lastEditedBy" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "tags" : [
        ]
      }
    ],
    "commit" : "d3d2900439cab3b6134ba74dab5d231c1380edb6",
    "line" : 28,
    "diffHunk" : "@@ -1,1 +299,303 @@      subProtocol = GroupCoordinator.NoProtocol,\n      leaderId = GroupCoordinator.NoLeader,\n      error = Errors.FENCED_INSTANCE_ID))\n\n    maybeInvokeSyncCallback(oldMember, SyncGroupResult("
  },
  {
    "id" : "625ff81b-eb5f-446c-8ebd-46a8ba392dec",
    "prId" : 6899,
    "prUrl" : "https://github.com/apache/kafka/pull/6899#pullrequestreview-247929583",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f03a0304-dae4-4462-ae0b-bed85fb7d308",
        "parentId" : null,
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "Can we have some simple unit tests in `GroupMetadataTest` for this function and `replaceGroupInstance`?",
        "createdAt" : "2019-06-11T16:55:10Z",
        "updatedAt" : "2019-06-12T04:56:07Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      }
    ],
    "commit" : "d3d2900439cab3b6134ba74dab5d231c1380edb6",
    "line" : 53,
    "diffHunk" : "@@ -1,1 +451,455 @@    * @return true if a sync callback actually performs.\n    */\n  def maybeInvokeSyncCallback(member: MemberMetadata,\n                              syncGroupResult: SyncGroupResult): Boolean = {\n    if (member.isAwaitingSync) {"
  },
  {
    "id" : "c55fcf9a-cd6c-412a-b47e-184f81c9579d",
    "prId" : 7276,
    "prUrl" : "https://github.com/apache/kafka/pull/7276#pullrequestreview-288145330",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6e9c4f4c-bede-42ba-a7ec-4a85343ea051",
        "parentId" : null,
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "So this means that offset deletion does not take into account the subscriptions of an active rebalance. That's probably fine I guess since it is simpler and we are not modifying the commit state for any partitions which are actively being fetched.\r\n\r\nA couple questions for completeness:\r\n\r\n1. For the sake of argument, suppose we loosened the validation so that we allow explicit deletions (but not expirations) without respect to the group or subscription state. The behavior of the consumer would be a little unpredictable. It might just write over the deletion. It might also force an offset reset if an OffsetFetch followed the deletion. Because the behavior is undefined, we do not allow it, which seems fair. However, the downside is that it makes the API a little harder to use, so just wanted to check whether you think it is a worthwhile restriction.\r\n\r\n2. If we know the subscription, then it wouldn't be much trouble to delete the offsets of all partitions that are not currently subscribed to. This could be supported in the API by using a null in the OffsetDelete request. I think it could be useful, but I'm inclined to leave it for future work. What do you think?",
        "createdAt" : "2019-09-11T18:40:21Z",
        "updatedAt" : "2019-09-13T19:33:00Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      },
      {
        "id" : "fa853e89-1d20-4786-bf0f-d8730e787ea0",
        "parentId" : "6e9c4f4c-bede-42ba-a7ec-4a85343ea051",
        "authorId" : "59ca7821-b29c-4f24-a9d5-cbd394145686",
        "body" : "Yes and No. I have distinguished two cases when I designed this:\r\n\r\n1) When the group is empty and the initial rebalance takes place, subscriptions will be ignored until the rebalance is completed and a new generation is initialised. I thought it would be inappropriate to compute the set of subscribed topics before having the full view of the consumer group. \r\n\r\n2) When the group is not empty and a rebalance takes place, the current set of subscribed topics will remain until all rebalance is completed and a new generation is initialised. I think this is a good think to be conservative here until the group has a full view of all the members.\r\n\r\nAnother aspect is that the protocol is actually selected at this point as well. I think it is better to stay consistent and parse the consumer protocol once the protocol of the group has been selected. It is not a hard requirement though as we could parse any versions but it feels more consistent in my opinion.\r\n\r\nTo answer your questions:\r\n\r\n1) I think allowing explicit deletions without respect to the group or subscription state would be really risky as the behaviour of the consumer would be unpredictable as you pointed out. I would say that it does not make much sense anyway to delete offsets of a topic while a running consumer group consumes this topic. It is good to have the restriction in place in my opinion.\r\n\r\n2) Yeah. It would be possible to delete the offsets of all partitions *of the topics* that are not currently subscribed to. I wonder it it really useful though as they will be eventually cleaned up now. I don't see the benefit of having the possibility to basically force the immediate clean up. I would leave it for future work and re-iterate based on the feedback we get from the users.\r\n",
        "createdAt" : "2019-09-12T07:55:38Z",
        "updatedAt" : "2019-09-13T19:33:00Z",
        "lastEditedBy" : "59ca7821-b29c-4f24-a9d5-cbd394145686",
        "tags" : [
        ]
      },
      {
        "id" : "dd28a11b-abfa-4c32-b055-b0456a663511",
        "parentId" : "6e9c4f4c-bede-42ba-a7ec-4a85343ea051",
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "Thanks for the response. Makes sense and I agree.",
        "createdAt" : "2019-09-13T17:16:53Z",
        "updatedAt" : "2019-09-13T19:33:00Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      }
    ],
    "commit" : "d96c9908a2b95e75aa853ea79d04532c229d007a",
    "line" : 35,
    "diffHunk" : "@@ -1,1 +211,215 @@\n  // When protocolType == `consumer`, a set of subscribed topics is maintained. The set is\n  // computed when a new generation is created or when the group is restored from the log.\n  private var subscribedTopics: Option[Set[String]] = None\n"
  }
]
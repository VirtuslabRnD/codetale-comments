[
  {
    "id" : "d8800936-26f3-4972-b736-c1e11f8d6942",
    "prId" : 4896,
    "prUrl" : "https://github.com/apache/kafka/pull/4896#pullrequestreview-124955033",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e574da4f-a299-495d-9a0f-9f4c30d31060",
        "parentId" : null,
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "This is a little confusing. The function `baseTimestamp` can return -1 if no current state timestamp is set, which would cause this check to incorrectly succeed. This would be the case if we were loading the state of a group which existed before we began using the new group metadata schema. Are there any guards which prevent this case?\r\n\r\nBasically the problem is that we need to handle the case that there is no expiration timestamp and there is no current state timestamp. I think in this case, `baseTimestamp` should just use the commit timestamp, which is basically like reverting to the old behavior. In other words, we should only be allowed to use the new behavior if `currentStateTimestamp` is defined.",
        "createdAt" : "2018-05-31T07:19:11Z",
        "updatedAt" : "2018-06-20T21:29:56Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      },
      {
        "id" : "778326f2-1092-4588-99b0-0de163530933",
        "parentId" : "e574da4f-a299-495d-9a0f-9f4c30d31060",
        "authorId" : "2a5e5a4d-e0e2-4e26-b139-0930dd63f949",
        "body" : "That's correct. Your suggested solution should work, and is implemented in the new commit. Thanks!",
        "createdAt" : "2018-05-31T20:14:30Z",
        "updatedAt" : "2018-06-20T21:29:56Z",
        "lastEditedBy" : "2a5e5a4d-e0e2-4e26-b139-0930dd63f949",
        "tags" : [
        ]
      }
    ],
    "commit" : "2b688c84bae947aeab8d28896ee109330fca0cf5",
    "line" : 74,
    "diffHunk" : "@@ -1,1 +451,455 @@              case None =>\n                // current version with no per partition retention\n                currentTimestamp - baseTimestamp(commitRecordMetadataAndOffset) >= offsetRetentionMs\n              case Some(expireTimestamp) =>\n                // older versions with explicit expire_timestamp field => old expiration semantics is used"
  },
  {
    "id" : "78953c9d-f089-465d-84d0-3e1eca77df0f",
    "prId" : 6058,
    "prUrl" : "https://github.com/apache/kafka/pull/6058#pullrequestreview-189107591",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d14c5107-2ff9-412c-80c4-2e76c5a7704a",
        "parentId" : null,
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "Is it ever possible that a memberId is in both collections?",
        "createdAt" : "2019-01-03T01:17:00Z",
        "updatedAt" : "2019-01-15T03:26:21Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      },
      {
        "id" : "5d7c8c3c-dff7-4c16-b871-2d1b71afeeeb",
        "parentId" : "d14c5107-2ff9-412c-80c4-2e76c5a7704a",
        "authorId" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "body" : "In the current logic, no, adding the check here just to ensure no one accidentally break the handling logic.",
        "createdAt" : "2019-01-03T17:27:37Z",
        "updatedAt" : "2019-01-15T03:26:21Z",
        "lastEditedBy" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "tags" : [
        ]
      }
    ],
    "commit" : "29f668ef1a9b2ee5939791b9bd5b89bf1a1660bb",
    "line" : 21,
    "diffHunk" : "@@ -1,1 +241,245 @@  }\n\n  def isPendingMember(memberId: String): Boolean = pendingMembers.contains(memberId) && !has(memberId)\n\n  def addPendingMember(memberId: String) = pendingMembers.add(memberId)"
  },
  {
    "id" : "39865731-612f-47a6-963a-c5c288ec23e2",
    "prId" : 6163,
    "prUrl" : "https://github.com/apache/kafka/pull/6163#pullrequestreview-194059714",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "cdc8a01d-ae4e-4584-a2f7-86a600377d5c",
        "parentId" : null,
        "authorId" : "979e3650-ce20-4720-a0da-e44d283b558b",
        "body" : "is this an intentional bugfix? ",
        "createdAt" : "2019-01-17T19:07:32Z",
        "updatedAt" : "2019-02-01T23:36:21Z",
        "lastEditedBy" : "979e3650-ce20-4720-a0da-e44d283b558b",
        "tags" : [
        ]
      },
      {
        "id" : "2692b075-f57f-4e4c-9aa5-0812ddfead19",
        "parentId" : "cdc8a01d-ae4e-4584-a2f7-86a600377d5c",
        "authorId" : "df911192-d6c6-4af9-8568-f67bf2dcf926",
        "body" : "Yes, we discussed it offline with @hachikuji. We should never have `members.size < numMembersAwaitingJoin`",
        "createdAt" : "2019-01-18T11:44:32Z",
        "updatedAt" : "2019-02-01T23:36:21Z",
        "lastEditedBy" : "df911192-d6c6-4af9-8568-f67bf2dcf926",
        "tags" : [
        ]
      }
    ],
    "commit" : "1421a43a3fcf28c99477bea7a1499a8fa17e50d9",
    "line" : 33,
    "diffHunk" : "@@ -1,1 +252,256 @@  def notYetRejoinedMembers = members.values.filter(!_.isAwaitingJoin).toList\n\n  def hasAllMembersJoined = members.size == numMembersAwaitingJoin && pendingMembers.isEmpty\n\n  def allMembers = members.keySet"
  },
  {
    "id" : "7976cc89-5f15-4e07-8caa-4cc3cb8b5087",
    "prId" : 6177,
    "prUrl" : "https://github.com/apache/kafka/pull/6177#pullrequestreview-230892121",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d9bd0c74-3fbc-4f01-81d8-dbd8acb1de35",
        "parentId" : null,
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "For all the three callers of it: two already checks `member.isStaticMember` and one has the assert already. So I'd suggest we pass in `groupInstanceId: String` as parameter directly from caller.",
        "createdAt" : "2019-04-23T00:18:13Z",
        "updatedAt" : "2019-04-26T15:12:49Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "d6a2f453-cd8e-47eb-bbf4-28b912a8d132",
        "parentId" : "d9bd0c74-3fbc-4f01-81d8-dbd8acb1de35",
        "authorId" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "body" : "We could remove the assertion here, but I guess we still need to throw exception since new caller may forget to check it.",
        "createdAt" : "2019-04-23T04:20:25Z",
        "updatedAt" : "2019-04-26T15:12:49Z",
        "lastEditedBy" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "tags" : [
        ]
      },
      {
        "id" : "0fa34126-2e07-431d-8eab-a4f3d67b4d32",
        "parentId" : "d9bd0c74-3fbc-4f01-81d8-dbd8acb1de35",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "That sounds good. We can check that the passed in `String` (not `Option[String]` for simplicity since all current callers actually can pass in the string parameter) is not null and throw otherwise.",
        "createdAt" : "2019-04-24T01:28:38Z",
        "updatedAt" : "2019-04-26T15:12:49Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "7ee2446c-b022-4a0d-b540-14d34e7ce24b",
        "parentId" : "d9bd0c74-3fbc-4f01-81d8-dbd8acb1de35",
        "authorId" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "body" : "I feel we could keep Option[String] in the function parameters. The reason is for consistent handling of this piece of information in GroupCoordinator until we actually extract the String for internal data structure update. The other approach would be using the case switch here which is more Option friendly. WDYT?",
        "createdAt" : "2019-04-24T04:45:48Z",
        "updatedAt" : "2019-04-26T15:12:49Z",
        "lastEditedBy" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "tags" : [
        ]
      },
      {
        "id" : "2986b8dc-fed4-4ac3-a726-a2c1c3d8f20b",
        "parentId" : "d9bd0c74-3fbc-4f01-81d8-dbd8acb1de35",
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "After a second thought I think I agree with you, it's not worth optimizing the parameter while giving up consistency in call traces.",
        "createdAt" : "2019-04-25T21:23:36Z",
        "updatedAt" : "2019-04-26T15:12:49Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      }
    ],
    "commit" : "932118542844c01e3caf657e2eee9c16dfd269d7",
    "line" : 72,
    "diffHunk" : "@@ -1,1 +282,286 @@  }\n\n  def addStaticMember(groupInstanceId: Option[String], newMemberId: String) = {\n    if(groupInstanceId.isEmpty) {\n      throw new IllegalArgumentException(s\"unexpected null group.instance.id in addStaticMember\")"
  },
  {
    "id" : "467b2897-a9e1-4d81-b051-59a238755d2e",
    "prId" : 6650,
    "prUrl" : "https://github.com/apache/kafka/pull/6650#pullrequestreview-239079340",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e40714e0-35db-4171-87f3-64d2e21d8f66",
        "parentId" : null,
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "Ah this is better. Thanks for the refactoring.",
        "createdAt" : "2019-05-17T19:36:24Z",
        "updatedAt" : "2019-05-18T04:04:24Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      }
    ],
    "commit" : "4a0c245434329139d931b0cc904704ef8c26a62c",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +254,258 @@    */\n  def maybeElectNewJoinedLeader(): Boolean = {\n    leaderId.exists { currentLeaderId =>\n      val currentLeader = get(currentLeaderId)\n      if (!currentLeader.isAwaitingJoin) {"
  },
  {
    "id" : "05b29e5d-98a3-41d6-a792-8fc702c6c328",
    "prId" : 6899,
    "prUrl" : "https://github.com/apache/kafka/pull/6899#pullrequestreview-247907179",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5afe0b58-6e26-4e22-9981-4e288898d678",
        "parentId" : null,
        "authorId" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "body" : "should also fence sync callback",
        "createdAt" : "2019-06-11T00:41:22Z",
        "updatedAt" : "2019-06-12T04:56:07Z",
        "lastEditedBy" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "tags" : [
        ]
      }
    ],
    "commit" : "d3d2900439cab3b6134ba74dab5d231c1380edb6",
    "line" : 28,
    "diffHunk" : "@@ -1,1 +299,303 @@      subProtocol = GroupCoordinator.NoProtocol,\n      leaderId = GroupCoordinator.NoLeader,\n      error = Errors.FENCED_INSTANCE_ID))\n\n    maybeInvokeSyncCallback(oldMember, SyncGroupResult("
  },
  {
    "id" : "625ff81b-eb5f-446c-8ebd-46a8ba392dec",
    "prId" : 6899,
    "prUrl" : "https://github.com/apache/kafka/pull/6899#pullrequestreview-247929583",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f03a0304-dae4-4462-ae0b-bed85fb7d308",
        "parentId" : null,
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "Can we have some simple unit tests in `GroupMetadataTest` for this function and `replaceGroupInstance`?",
        "createdAt" : "2019-06-11T16:55:10Z",
        "updatedAt" : "2019-06-12T04:56:07Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      }
    ],
    "commit" : "d3d2900439cab3b6134ba74dab5d231c1380edb6",
    "line" : 53,
    "diffHunk" : "@@ -1,1 +451,455 @@    * @return true if a sync callback actually performs.\n    */\n  def maybeInvokeSyncCallback(member: MemberMetadata,\n                              syncGroupResult: SyncGroupResult): Boolean = {\n    if (member.isAwaitingSync) {"
  }
]
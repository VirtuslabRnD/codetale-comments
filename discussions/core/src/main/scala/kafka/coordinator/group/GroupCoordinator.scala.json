[
  {
    "id" : "b6990de4-9f31-4f12-bf51-9a449776d85e",
    "prId" : 4479,
    "prUrl" : "https://github.com/apache/kafka/pull/4479#pullrequestreview-92814289",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "864242f1-c7d2-4ce6-b7d1-1e82f2c730c8",
        "parentId" : null,
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "This still feels a bit hacky. As an alternative, maybe we can let the offset selector be provided as a function. Something like this:\r\n\r\n```scala\r\ndef cleanupGroupMetadata(\r\n groups: Iterable[GroupMetadata], \r\n collectOffsetsToRemove: Group => Map[TopicPartition, OffsetAndMetadata])\r\n```\r\n\r\nWhat do you think?",
        "createdAt" : "2018-01-30T22:20:49Z",
        "updatedAt" : "2018-01-31T19:11:21Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      },
      {
        "id" : "580caacb-72a1-46b4-a3e5-e98b6213c967",
        "parentId" : "864242f1-c7d2-4ce6-b7d1-1e82f2c730c8",
        "authorId" : "2a5e5a4d-e0e2-4e26-b139-0930dd63f949",
        "body" : "I'm not sure which part you consider hacky, and am trying to understand your suggestion.\r\n\r\nFor the sake of `deleteGroups` functionality, we can use `group.allOffsets` that conforms to the function signature above. But how about the existing functionality, where we want to delete specific topic partitions from a group: `groupManager.cleanupGroupMetadata(Some(topicPartitions), groupManager.currentGroups, time.milliseconds())` and populate the corresponding `OffsetAndMetadata` values? I'm assuming we want to reuse the same `cleanupGroupMetadata` method for both cases.\r\n\r\nOn the same assumption, we also need to factor in the concept of current time so we can determine the expired offsets for the existing functionality.\r\n\r\nOn the other hand if you are proposing to create A new `cleanupGroupMetadata` method that calls on the existing method, we should make this call once per group (since topic partitions are group-specific).\r\n\r\nOr maybe I'm missing the point :)",
        "createdAt" : "2018-01-31T03:40:55Z",
        "updatedAt" : "2018-01-31T19:11:21Z",
        "lastEditedBy" : "2a5e5a4d-e0e2-4e26-b139-0930dd63f949",
        "tags" : [
        ]
      },
      {
        "id" : "57e4e53d-bfb3-4c49-807d-d506de269e23",
        "parentId" : "864242f1-c7d2-4ce6-b7d1-1e82f2c730c8",
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "It's not that big of a deal. I just thought it was a mild abuse to reuse the expiration logic to delete all offsets. Alternatively, what I was suggesting is to let the caller choose the offsets to delete.",
        "createdAt" : "2018-01-31T06:09:39Z",
        "updatedAt" : "2018-01-31T19:11:21Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      }
    ],
    "commit" : "ca60b651ee8c2c38a6122b0300504aad8d2972b9",
    "line" : 41,
    "diffHunk" : "@@ -1,1 +376,380 @@\n      if (eligibleGroups.nonEmpty) {\n        groupManager.cleanupGroupMetadata(None, eligibleGroups, Long.MaxValue)\n        groupErrors ++= eligibleGroups.map(_.groupId -> Errors.NONE).toMap\n        info(s\"The following groups were deleted: ${eligibleGroups.map(_.groupId).mkString(\", \")}\")"
  }
]
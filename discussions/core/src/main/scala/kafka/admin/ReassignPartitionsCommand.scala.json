[
  {
    "id" : "41967390-2442-4835-8f61-62beaa7afd25",
    "prId" : 8244,
    "prUrl" : "https://github.com/apache/kafka/pull/8244#pullrequestreview-371447277",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d679f60d-8f25-4b44-95cd-8bf96bdd4c49",
        "parentId" : null,
        "authorId" : "df911192-d6c6-4af9-8568-f67bf2dcf926",
        "body" : "Should this be true given that no move is in progress, or should we update the docstring for the `done` variable to mention that error states are false",
        "createdAt" : "2020-03-09T13:45:08Z",
        "updatedAt" : "2020-03-20T01:25:57Z",
        "lastEditedBy" : "df911192-d6c6-4af9-8568-f67bf2dcf926",
        "tags" : [
        ]
      },
      {
        "id" : "8abf3ae8-7879-4e36-95ac-be71dcda22f8",
        "parentId" : "d679f60d-8f25-4b44-95cd-8bf96bdd4c49",
        "authorId" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "body" : "As a practical matter, we probably don't want to remove the throttles in `--verify` if the log directory move is screwed up (because of an offline log directory or similar).  I will update the docstring.",
        "createdAt" : "2020-03-09T18:57:49Z",
        "updatedAt" : "2020-03-20T01:25:57Z",
        "lastEditedBy" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "tags" : [
        ]
      }
    ],
    "commit" : "829a0e60ee0d119833156dc1a781c523a6d43232",
    "line" : 142,
    "diffHunk" : "@@ -1,1 +141,145 @@  sealed case class MissingLogDirMoveState(targetLogDir: String)\n      extends LogDirMoveState {\n    override def done = false\n  }\n"
  },
  {
    "id" : "ea20d5ee-fb28-41b2-8d98-617ccf298e3c",
    "prId" : 8244,
    "prUrl" : "https://github.com/apache/kafka/pull/8244#pullrequestreview-371451431",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5695a147-1bc5-42c1-95c6-f408b650d5ca",
        "parentId" : null,
        "authorId" : "df911192-d6c6-4af9-8568-f67bf2dcf926",
        "body" : "Do we allow cancellation only of partition reassignments whose `addingReplicas` isn't empty or whose `removingReplicas` isn't empty? If so, the latter check needs a `!`\r\n\r\nWhat about the alternative - allow cancellation of whatever `listPartitionReassignments()` returns? The API should return reassignments that are in progress only anyway",
        "createdAt" : "2020-03-09T14:17:16Z",
        "updatedAt" : "2020-03-20T01:25:57Z",
        "lastEditedBy" : "df911192-d6c6-4af9-8568-f67bf2dcf926",
        "tags" : [
        ]
      },
      {
        "id" : "3e9e22c3-26dd-4f3e-9c1d-1b1176c10ad8",
        "parentId" : "5695a147-1bc5-42c1-95c6-f408b650d5ca",
        "authorId" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "body" : "Hmm, github is showing this comment in a weird place-- on the `calculateMoveMap` function rather than in the `cancelAssignment` function as you probably intended.\r\n\r\nGood find on the missing negation.  That was definitely not intended.  Fixed.\r\n\r\nIf users want to cancel arbitrary partition moves, they can create a JSON file and use `--cancel` on it, right?",
        "createdAt" : "2020-03-09T19:04:01Z",
        "updatedAt" : "2020-03-20T01:25:57Z",
        "lastEditedBy" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "tags" : [
        ]
      }
    ],
    "commit" : "829a0e60ee0d119833156dc1a781c523a6d43232",
    "line" : 1671,
    "diffHunk" : "@@ -1,1 +1533,1537 @@    val curReassigningParts = adminClient.listPartitionReassignments(targetPartsSet.asJava).\n        reassignments().get().asScala.flatMap {\n      case (part, reassignment) => if (!reassignment.addingReplicas().isEmpty ||\n          !reassignment.removingReplicas().isEmpty) {\n        Some(part)"
  },
  {
    "id" : "05605354-2cae-4d0d-9919-55c19370a004",
    "prId" : 8244,
    "prUrl" : "https://github.com/apache/kafka/pull/8244#pullrequestreview-371107281",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "80b67c5e-6688-4029-9ae9-a4c08cb007b7",
        "parentId" : null,
        "authorId" : "df911192-d6c6-4af9-8568-f67bf2dcf926",
        "body" : "Should we print the ones that were successfully cancelled?",
        "createdAt" : "2020-03-09T14:18:47Z",
        "updatedAt" : "2020-03-20T01:25:57Z",
        "lastEditedBy" : "df911192-d6c6-4af9-8568-f67bf2dcf926",
        "tags" : [
        ]
      }
    ],
    "commit" : "829a0e60ee0d119833156dc1a781c523a6d43232",
    "line" : 1681,
    "diffHunk" : "@@ -1,1 +1543,1547 @@      val errors = cancelPartitionReassignments(adminClient, curReassigningParts)\n      if (errors.nonEmpty) {\n        throw new TerseReassignmentFailureException(\n          \"Error cancelling partition reassignment%s for:%n%s\".format(\n            if (errors.size == 1) \"\" else \"s\","
  },
  {
    "id" : "da22d01e-2f62-471b-a3df-acfbfd56a79b",
    "prId" : 8244,
    "prUrl" : "https://github.com/apache/kafka/pull/8244#pullrequestreview-372837834",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "aa428eaf-df6e-4eaf-9038-711f7de87a33",
        "parentId" : null,
        "authorId" : "df911192-d6c6-4af9-8568-f67bf2dcf926",
        "body" : "Do we have a test to ensure that the old way to run replica log dir reassignments with ZK works? i.e `./kafka-reassign-partitions --zookeeper ZK --bootstrap-server server --reassignment-json-file file_with_dir_reassignments.json`\r\nFrom reading the code, I think so - but always worth making sure",
        "createdAt" : "2020-03-09T14:41:58Z",
        "updatedAt" : "2020-03-20T01:25:57Z",
        "lastEditedBy" : "df911192-d6c6-4af9-8568-f67bf2dcf926",
        "tags" : [
        ]
      },
      {
        "id" : "8148b396-0d38-4e06-9c9e-741e20d57cec",
        "parentId" : "aa428eaf-df6e-4eaf-9038-711f7de87a33",
        "authorId" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "body" : "If you supply both `--zookeeper` and `--bootstrap-server`, then --zookeeper is ignored.  So there's no need for separate tests for the combination.",
        "createdAt" : "2020-03-09T18:47:22Z",
        "updatedAt" : "2020-03-20T01:25:57Z",
        "lastEditedBy" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "tags" : [
        ]
      },
      {
        "id" : "d07b2765-1cd8-41f0-9334-e37e00fe50ac",
        "parentId" : "aa428eaf-df6e-4eaf-9038-711f7de87a33",
        "authorId" : "083f2f03-ca7e-48a1-9781-482564dfdf53",
        "body" : "It would be nice if we gave a warning that the `--zookeeper` flag was being ignore in this case",
        "createdAt" : "2020-03-11T15:54:00Z",
        "updatedAt" : "2020-03-20T01:25:57Z",
        "lastEditedBy" : "083f2f03-ca7e-48a1-9781-482564dfdf53",
        "tags" : [
        ]
      }
    ],
    "commit" : "829a0e60ee0d119833156dc1a781c523a6d43232",
    "line" : 1246,
    "diffHunk" : "@@ -1,1 +1108,1112 @@    val (proposedParts, proposedReplicas) = parseExecuteAssignmentArgs(reassignmentJson)\n    if (proposedReplicas.nonEmpty) {\n      throw new AdminCommandFailedException(\"bootstrap-server needs to be provided when \" +\n        \"replica reassignments are present.\")\n    }"
  },
  {
    "id" : "8d6ff7db-3ae1-497a-9c0a-ed28fa41d4a7",
    "prId" : 8244,
    "prUrl" : "https://github.com/apache/kafka/pull/8244#pullrequestreview-373154173",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "11bd5a7f-3cee-441c-8d77-7c4c9599a5b2",
        "parentId" : null,
        "authorId" : "083f2f03-ca7e-48a1-9781-482564dfdf53",
        "body" : "Maybe we could split this into two \"main\" methods: one for AdminClient and one for ZK? Might make this a bit more readable.",
        "createdAt" : "2020-03-11T15:03:49Z",
        "updatedAt" : "2020-03-20T01:25:57Z",
        "lastEditedBy" : "083f2f03-ca7e-48a1-9781-482564dfdf53",
        "tags" : [
        ]
      },
      {
        "id" : "94f6bf4d-acdf-4556-8dea-14c8c85db194",
        "parentId" : "11bd5a7f-3cee-441c-8d77-7c4c9599a5b2",
        "authorId" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "body" : "ok",
        "createdAt" : "2020-03-11T21:59:29Z",
        "updatedAt" : "2020-03-20T01:25:57Z",
        "lastEditedBy" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "tags" : [
        ]
      }
    ],
    "commit" : "829a0e60ee0d119833156dc1a781c523a6d43232",
    "line" : 209,
    "diffHunk" : "@@ -1,1 +197,201 @@\n    try {\n      if (opts.options.has(opts.bootstrapServerOpt)) {\n        if (opts.options.has(opts.zkConnectOpt)) {\n          println(\"Warning: ignoring deprecated --zookeeper option because \" +"
  },
  {
    "id" : "076154b5-7a0c-4216-b633-97ae599a87af",
    "prId" : 8244,
    "prUrl" : "https://github.com/apache/kafka/pull/8244#pullrequestreview-375348290",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b4fd9936-b368-4409-af95-8f0e9d66c0f4",
        "parentId" : null,
        "authorId" : "083f2f03-ca7e-48a1-9781-482564dfdf53",
        "body" : "Since these two `generateAssignment` methods are nearly identical, do you think it's worth trying to factor out the common parts? Maybe we could have a single `generateAssignment` that accepts an `Either[Admin, ZkClient]`?",
        "createdAt" : "2020-03-11T15:27:30Z",
        "updatedAt" : "2020-03-20T01:25:57Z",
        "lastEditedBy" : "083f2f03-ca7e-48a1-9781-482564dfdf53",
        "tags" : [
        ]
      },
      {
        "id" : "247c0b44-52a5-410b-9d18-a4496fdb4297",
        "parentId" : "b4fd9936-b368-4409-af95-8f0e9d66c0f4",
        "authorId" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "body" : "Good question.  The zookeeper code is going away soon, so I don't think it's worth trying to combine the functions.\r\n\r\nI could write a function to factor out the \"print\" statements, but I'm not sure it's worth it since the main work is done by `calculateAssignment` and `formatAsReassignmentJson`, which are already shared code.",
        "createdAt" : "2020-03-11T22:03:14Z",
        "updatedAt" : "2020-03-20T01:25:57Z",
        "lastEditedBy" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "tags" : [
        ]
      },
      {
        "id" : "8c808699-7838-4174-99d3-064cb042a7bb",
        "parentId" : "b4fd9936-b368-4409-af95-8f0e9d66c0f4",
        "authorId" : "083f2f03-ca7e-48a1-9781-482564dfdf53",
        "body" : "Yea, probably not worth the effort in this case.",
        "createdAt" : "2020-03-16T16:00:29Z",
        "updatedAt" : "2020-03-20T01:25:57Z",
        "lastEditedBy" : "083f2f03-ca7e-48a1-9781-482564dfdf53",
        "tags" : [
        ]
      }
    ],
    "commit" : "829a0e60ee0d119833156dc1a781c523a6d43232",
    "line" : 857,
    "diffHunk" : "@@ -1,1 +749,753 @@    val (brokersToReassign, topicsToReassign) =\n      parseGenerateAssignmentArgs(reassignmentJson, brokerListString)\n    val currentAssignments = getReplicaAssignmentForTopics(adminClient, topicsToReassign)\n    val brokerMetadatas = getBrokerMetadata(adminClient, brokersToReassign, enableRackAwareness)\n    val proposedAssignments = calculateAssignment(currentAssignments, brokerMetadatas)"
  },
  {
    "id" : "77ef1c04-5c36-4171-b756-f8a3ed529a39",
    "prId" : 8891,
    "prUrl" : "https://github.com/apache/kafka/pull/8891#pullrequestreview-434261140",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "860eae44-5bc4-4615-8291-12f826c08204",
        "parentId" : null,
        "authorId" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "body" : "seems to break the symmetry a bit, doesn't it?  Although, I don't feel strongly about this.",
        "createdAt" : "2020-06-18T22:21:56Z",
        "updatedAt" : "2020-10-12T16:54:10Z",
        "lastEditedBy" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "tags" : [
        ]
      },
      {
        "id" : "2cb1033b-db16-4f28-ab25-348258b13475",
        "parentId" : "860eae44-5bc4-4615-8291-12f826c08204",
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "I can revert. It looked a little more reasonable when next to the suggested alter command.",
        "createdAt" : "2020-06-19T18:10:25Z",
        "updatedAt" : "2020-10-12T16:54:10Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      }
    ],
    "commit" : "b2b340f502a469ff68f66da24b711aa969891779",
    "line" : 343,
    "diffHunk" : "@@ -1,1 +1703,1707 @@        opts.reassignmentJsonFileOpt\n      ),\n      opts.listOpt -> collection.immutable.Seq.empty\n    )\n    CommandLineUtils.checkRequiredArgs(opts.parser, opts.options, requiredArgs(action): _*)"
  },
  {
    "id" : "668b31f3-5c68-4262-9a3d-e4df93638719",
    "prId" : 9807,
    "prUrl" : "https://github.com/apache/kafka/pull/9807#pullrequestreview-562841122",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bc4b450b-533e-4b2f-a654-2137a9d92693",
        "parentId" : null,
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "It might be just me, but the logic in this method is as clear as mud to me. At a high level, we are just trying to identify the sources and the destinations to fill a `PartitionMove`. The destinations are the adding replicas (AR) and the sources are the current replicas (CR) without the adding replicas. The current logic below first calls `calculateCurrentMoveMap` which does the following:\r\n\r\n1. Add each replica to both sources and destinations\r\n2. Add all AR to destinations \r\n3. Remove all removing replicas (RR) from destinations\r\n\r\nI think this computes the destinations correctly (even if it does so in an odd way), but sources will include all replicas, which is wrong. You have fixed this by removing AR from sources explicitly, but I think we can simplify a bit more. Maybe something like this\r\n\r\n```scala\r\nmove.destinations = reassignment.addingReplicas\r\nmove.sources = reassignment.replicas - reassignment.addingReplicas\r\n```\r\n\r\nAfter computing the current move map, the current logic tries to account for the proposed reassignments. It does the following:\r\n\r\n1. Overwrite current move with an empty move and set destinations to the target replicas (TR)\r\n2. Iterate through all moves and check if sources is empty, which means we have overwritten the move in step 1. If so, then we add all of CR to sources.\r\n3. Now we do one more pass over the moves and remove all of the destinations from sources.\r\n\r\nI have a hard time making sense of this logic. The main problem is that it assumes that TR are only destinations, but that is wrong. For example, if we reassign [1, 2] to [1, 3], then 1 should be a source, not a destination even though it is present in TR. I think the correct logic should be the following:\r\n\r\n1. for each proposed assignment TR, check if there is already a reassignment in progress:\r\n2. if there is a reassignment in progress, then we need to account for the current AR. We can compute sources as CR - AR, which is what we already did when calculating the current move map\r\n3. if there is no reassignment in progress, then we set sources to CR\r\n4. regardless of whether there is a reassignment in progress, we set destinations to TR - sources\r\n\r\nSomething like this?\r\n```scala\r\nproposedParts.foreach {\r\n  case (part, targetReplicas) =>\r\n    val partMoves = moveMap.getOrElseUpdate(part.topic, new mutable.HashMap[Int, PartitionMove])\r\n    val sources = partMoves.get(part) match {\r\n      case Some(move) => move.sources\r\n      case None => currentParts.get(part)\r\n    }\r\n    val destinations = targetReplicas - sources\r\n    partMoves.put(part.partition, PartitionMove(sources, destinations))\r\n}\r\n```\r\n\r\nCheck that over and see if it makes sense to you. Basically I think the current logic is unnecessarily complicated and probably wrong in multiple ways.",
        "createdAt" : "2021-01-06T03:06:26Z",
        "updatedAt" : "2021-01-07T12:09:08Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      },
      {
        "id" : "7cae4c85-9719-4ff4-aa03-8c9fe55e3f4e",
        "parentId" : "bc4b450b-533e-4b2f-a654-2137a9d92693",
        "authorId" : "12f98c82-b9ef-4668-aa6f-5a62bf3439bb",
        "body" : "Thank you @hachikuji , I also spend much time making sense of this logic since it's unnecessarily complicated and I tried to solve the issue with the least code change, which made it even much more untidy. Now I have rewritten the code according to your suggestions and have simplified it tremendously, PTAL.",
        "createdAt" : "2021-01-06T16:13:04Z",
        "updatedAt" : "2021-01-07T12:09:08Z",
        "lastEditedBy" : "12f98c82-b9ef-4668-aa6f-5a62bf3439bb",
        "tags" : [
        ]
      }
    ],
    "commit" : "191b4f4c09ab94fc98c27b2360546d9014c5748a",
    "line" : 95,
    "diffHunk" : "@@ -1,1 +1262,1266 @@   *                                the movements for that partition.\n   */\n  def calculateProposedMoveMap(currentReassignments: Map[TopicPartition, PartitionReassignment],\n                               proposedParts: Map[TopicPartition, Seq[Int]],\n                               currentParts: Map[TopicPartition, Seq[Int]]): MoveMap = {"
  },
  {
    "id" : "72b74c60-6bfc-489c-a390-1aea6d027314",
    "prId" : 10141,
    "prUrl" : "https://github.com/apache/kafka/pull/10141#pullrequestreview-606358755",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1f8e986b-c7e1-4c80-812a-cb0a67635a92",
        "parentId" : null,
        "authorId" : "d8c7cf80-a55a-474c-a4f4-f60a9efda52c",
        "body" : "Hmm. why not write this as `t.getCause.isInstanceOf[UnknownTopicOrPartitionException]`?",
        "createdAt" : "2021-03-02T20:52:46Z",
        "updatedAt" : "2021-03-02T20:52:47Z",
        "lastEditedBy" : "d8c7cf80-a55a-474c-a4f4-f60a9efda52c",
        "tags" : [
        ]
      },
      {
        "id" : "03cda3b2-62a3-4215-bbe8-19259e39deea",
        "parentId" : "1f8e986b-c7e1-4c80-812a-cb0a67635a92",
        "authorId" : "d8c7cf80-a55a-474c-a4f4-f60a9efda52c",
        "body" : "Also, you can have the `if` in the `case t` line and then a second `case` for the rethrow case.",
        "createdAt" : "2021-03-02T20:53:31Z",
        "updatedAt" : "2021-03-02T20:53:31Z",
        "lastEditedBy" : "d8c7cf80-a55a-474c-a4f4-f60a9efda52c",
        "tags" : [
        ]
      },
      {
        "id" : "d23d5fc8-0a4e-4a78-b3ed-62d45faf47f3",
        "parentId" : "1f8e986b-c7e1-4c80-812a-cb0a67635a92",
        "authorId" : "59ca7821-b29c-4f24-a9d5-cbd394145686",
        "body" : "I initially used `t.getCause != null && t.getCause.isInstanceOf[UnknownTopicOrPartitionException]`. @chia7712 suggested to use `classOf[UnknownTopicOrPartitionException].isInstance(t.getCause)` to avoid having to do the null check as `isInstance` does it. That seemed reasonable to me so I went with it. Is there a reason not to use it?\r\n\r\nI do agree with your second comment.",
        "createdAt" : "2021-03-03T08:04:51Z",
        "updatedAt" : "2021-03-03T08:04:51Z",
        "lastEditedBy" : "59ca7821-b29c-4f24-a9d5-cbd394145686",
        "tags" : [
        ]
      },
      {
        "id" : "ce9c474b-2a80-403a-96d7-377a99ee05a8",
        "parentId" : "1f8e986b-c7e1-4c80-812a-cb0a67635a92",
        "authorId" : "d8c7cf80-a55a-474c-a4f4-f60a9efda52c",
        "body" : "Hmm, I think this is an example of code that is less readable. If `cause` may be nullable, it's better to write code that makes that clear rather than a non obvious alternative that could have been used for many other reasons (using `Option` to handle nullables is fine as a counter example since it's common usage to do that to handle nulls).\r\n\r\nWhat do you think?",
        "createdAt" : "2021-03-08T13:37:01Z",
        "updatedAt" : "2021-03-08T13:37:24Z",
        "lastEditedBy" : "d8c7cf80-a55a-474c-a4f4-f60a9efda52c",
        "tags" : [
        ]
      },
      {
        "id" : "0b19dfe4-3efb-4b01-a807-03627e644ebf",
        "parentId" : "1f8e986b-c7e1-4c80-812a-cb0a67635a92",
        "authorId" : "d8c7cf80-a55a-474c-a4f4-f60a9efda52c",
        "body" : "Oh, one more thing, did you check that the null check is actually needed? I think isInstanceOf is defined for null too.",
        "createdAt" : "2021-03-08T13:38:29Z",
        "updatedAt" : "2021-03-08T13:38:29Z",
        "lastEditedBy" : "d8c7cf80-a55a-474c-a4f4-f60a9efda52c",
        "tags" : [
        ]
      },
      {
        "id" : "257e10bc-345f-4ced-81e6-00679fa0cd3a",
        "parentId" : "1f8e986b-c7e1-4c80-812a-cb0a67635a92",
        "authorId" : "0f776378-bb23-4193-9bb0-1db5973f3781",
        "body" : "> I think isInstanceOf is defined for null too.\r\n\r\nyou are right. Scala does define it. https://scala-lang.org/files/archive/spec/2.13/spec.pdf\r\n\r\n‘’’\r\n\r\nisInstanceOf[T] always returns false.\r\n‘’’\r\n\r\nGood to know that :)\r\n\r\n+1 to use ‘t.getCause.isInstanceOf[UnknownTopicOrPartitionException]‘ as it can deal with null check.\r\n\r\nSorry for my imprecise comment :(\r\n\r\n",
        "createdAt" : "2021-03-08T14:10:45Z",
        "updatedAt" : "2021-03-08T14:10:45Z",
        "lastEditedBy" : "0f776378-bb23-4193-9bb0-1db5973f3781",
        "tags" : [
        ]
      },
      {
        "id" : "a2dd1af6-aff7-471d-a3d6-4026df6df2ce",
        "parentId" : "1f8e986b-c7e1-4c80-812a-cb0a67635a92",
        "authorId" : "59ca7821-b29c-4f24-a9d5-cbd394145686",
        "body" : "@ijuma Yeah, I do agree with you. For the null check, I was not aware that isInstanceOf handles it. That's good to know, thanks.\r\n\r\nI will open a small PR to fix this.",
        "createdAt" : "2021-03-08T14:38:06Z",
        "updatedAt" : "2021-03-08T14:38:07Z",
        "lastEditedBy" : "59ca7821-b29c-4f24-a9d5-cbd394145686",
        "tags" : [
        ]
      }
    ],
    "commit" : "e71bcc1ba91648872b901b20b16fffbb10f50cc1",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +823,827 @@        catch {\n          case t: ExecutionException =>\n            if (classOf[UnknownTopicOrPartitionException].isInstance(t.getCause)) {\n              throw new ExecutionException(\n                new UnknownTopicOrPartitionException(s\"Topic $topicName not found.\"))"
  },
  {
    "id" : "eb869bbc-db04-4394-ab28-1f045b233551",
    "prId" : 10329,
    "prUrl" : "https://github.com/apache/kafka/pull/10329#pullrequestreview-613965460",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "48fac0f9-7580-4c74-bfb2-9a3bf2d5af59",
        "parentId" : null,
        "authorId" : "59ca7821-b29c-4f24-a9d5-cbd394145686",
        "body" : "nit: The indentation of the two lines below could be corrected now.",
        "createdAt" : "2021-03-17T06:48:42Z",
        "updatedAt" : "2021-03-17T08:51:40Z",
        "lastEditedBy" : "59ca7821-b29c-4f24-a9d5-cbd394145686",
        "tags" : [
        ]
      }
    ],
    "commit" : "a31bf6f0e786652d14c3d6321f77521a88911939",
    "line" : 43,
    "diffHunk" : "@@ -1,1 +1189,1193 @@  def alterPartitionReassignments(adminClient: Admin,\n                                  reassignments: Map[TopicPartition, Seq[Int]]): Map[TopicPartition, Throwable] = {\n    val results = adminClient.alterPartitionReassignments(reassignments.map { case (part, replicas) =>\n      (part, Optional.of(new NewPartitionReassignment(replicas.map(Integer.valueOf).asJava)))\n    }.asJava).values().asScala"
  },
  {
    "id" : "c87174f9-2356-42cf-9c0e-c17c6a9e4fe4",
    "prId" : 10329,
    "prUrl" : "https://github.com/apache/kafka/pull/10329#pullrequestreview-613965460",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d098a054-f7cc-4104-a0f6-c8991aa864af",
        "parentId" : null,
        "authorId" : "59ca7821-b29c-4f24-a9d5-cbd394145686",
        "body" : "ditto",
        "createdAt" : "2021-03-17T06:48:48Z",
        "updatedAt" : "2021-03-17T08:51:40Z",
        "lastEditedBy" : "59ca7821-b29c-4f24-a9d5-cbd394145686",
        "tags" : [
        ]
      }
    ],
    "commit" : "a31bf6f0e786652d14c3d6321f77521a88911939",
    "line" : 57,
    "diffHunk" : "@@ -1,1 +1214,1218 @@                                   reassignments: Set[TopicPartition])\n  : Map[TopicPartition, Throwable] = {\n    val results = adminClient.alterPartitionReassignments(reassignments.map {\n      (_, Optional.empty[NewPartitionReassignment]())\n    }.toMap.asJava).values().asScala"
  },
  {
    "id" : "7965a746-1958-425e-bee8-da960c130a75",
    "prId" : 10471,
    "prUrl" : "https://github.com/apache/kafka/pull/10471#pullrequestreview-629762001",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "231ae6e5-3b2e-470a-9378-3696eac3a8ce",
        "parentId" : null,
        "authorId" : "d8c7cf80-a55a-474c-a4f4-f60a9efda52c",
        "body" : "Do we need to pass `bootstrapServerOpt` here and the lines below?",
        "createdAt" : "2021-04-06T12:56:47Z",
        "updatedAt" : "2021-04-16T10:03:21Z",
        "lastEditedBy" : "d8c7cf80-a55a-474c-a4f4-f60a9efda52c",
        "tags" : [
        ]
      },
      {
        "id" : "d9448acb-62e8-4895-90f7-fb168f8df3a0",
        "parentId" : "231ae6e5-3b2e-470a-9378-3696eac3a8ce",
        "authorId" : "d520dc4e-6bae-4b0b-90d6-4c0a1cabb518",
        "body" : "Yes, if `bootstrapServerOpt` is not in the permitted arg list, the check will fail since `bootstrapServerOpt` is not permitted option for this action.",
        "createdAt" : "2021-04-07T08:58:30Z",
        "updatedAt" : "2021-04-16T10:03:21Z",
        "lastEditedBy" : "d520dc4e-6bae-4b0b-90d6-4c0a1cabb518",
        "tags" : [
        ]
      }
    ],
    "commit" : "8dc473117f6863ef46ee5a8dd75cf4645d99dc2b",
    "line" : 476,
    "diffHunk" : "@@ -1,1 +1369,1373 @@    val permittedArgs = Map(\n      opts.verifyOpt -> Seq(\n        opts.bootstrapServerOpt,\n        opts.commandConfigOpt,\n        opts.preserveThrottlesOpt,"
  }
]
[
  {
    "id" : "41967390-2442-4835-8f61-62beaa7afd25",
    "prId" : 8244,
    "prUrl" : "https://github.com/apache/kafka/pull/8244#pullrequestreview-371447277",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d679f60d-8f25-4b44-95cd-8bf96bdd4c49",
        "parentId" : null,
        "authorId" : "df911192-d6c6-4af9-8568-f67bf2dcf926",
        "body" : "Should this be true given that no move is in progress, or should we update the docstring for the `done` variable to mention that error states are false",
        "createdAt" : "2020-03-09T13:45:08Z",
        "updatedAt" : "2020-03-20T01:25:57Z",
        "lastEditedBy" : "df911192-d6c6-4af9-8568-f67bf2dcf926",
        "tags" : [
        ]
      },
      {
        "id" : "8abf3ae8-7879-4e36-95ac-be71dcda22f8",
        "parentId" : "d679f60d-8f25-4b44-95cd-8bf96bdd4c49",
        "authorId" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "body" : "As a practical matter, we probably don't want to remove the throttles in `--verify` if the log directory move is screwed up (because of an offline log directory or similar).  I will update the docstring.",
        "createdAt" : "2020-03-09T18:57:49Z",
        "updatedAt" : "2020-03-20T01:25:57Z",
        "lastEditedBy" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "tags" : [
        ]
      }
    ],
    "commit" : "829a0e60ee0d119833156dc1a781c523a6d43232",
    "line" : 142,
    "diffHunk" : "@@ -1,1 +141,145 @@  sealed case class MissingLogDirMoveState(targetLogDir: String)\n      extends LogDirMoveState {\n    override def done = false\n  }\n"
  },
  {
    "id" : "ea20d5ee-fb28-41b2-8d98-617ccf298e3c",
    "prId" : 8244,
    "prUrl" : "https://github.com/apache/kafka/pull/8244#pullrequestreview-371451431",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5695a147-1bc5-42c1-95c6-f408b650d5ca",
        "parentId" : null,
        "authorId" : "df911192-d6c6-4af9-8568-f67bf2dcf926",
        "body" : "Do we allow cancellation only of partition reassignments whose `addingReplicas` isn't empty or whose `removingReplicas` isn't empty? If so, the latter check needs a `!`\r\n\r\nWhat about the alternative - allow cancellation of whatever `listPartitionReassignments()` returns? The API should return reassignments that are in progress only anyway",
        "createdAt" : "2020-03-09T14:17:16Z",
        "updatedAt" : "2020-03-20T01:25:57Z",
        "lastEditedBy" : "df911192-d6c6-4af9-8568-f67bf2dcf926",
        "tags" : [
        ]
      },
      {
        "id" : "3e9e22c3-26dd-4f3e-9c1d-1b1176c10ad8",
        "parentId" : "5695a147-1bc5-42c1-95c6-f408b650d5ca",
        "authorId" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "body" : "Hmm, github is showing this comment in a weird place-- on the `calculateMoveMap` function rather than in the `cancelAssignment` function as you probably intended.\r\n\r\nGood find on the missing negation.  That was definitely not intended.  Fixed.\r\n\r\nIf users want to cancel arbitrary partition moves, they can create a JSON file and use `--cancel` on it, right?",
        "createdAt" : "2020-03-09T19:04:01Z",
        "updatedAt" : "2020-03-20T01:25:57Z",
        "lastEditedBy" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "tags" : [
        ]
      }
    ],
    "commit" : "829a0e60ee0d119833156dc1a781c523a6d43232",
    "line" : 1671,
    "diffHunk" : "@@ -1,1 +1533,1537 @@    val curReassigningParts = adminClient.listPartitionReassignments(targetPartsSet.asJava).\n        reassignments().get().asScala.flatMap {\n      case (part, reassignment) => if (!reassignment.addingReplicas().isEmpty ||\n          !reassignment.removingReplicas().isEmpty) {\n        Some(part)"
  },
  {
    "id" : "05605354-2cae-4d0d-9919-55c19370a004",
    "prId" : 8244,
    "prUrl" : "https://github.com/apache/kafka/pull/8244#pullrequestreview-371107281",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "80b67c5e-6688-4029-9ae9-a4c08cb007b7",
        "parentId" : null,
        "authorId" : "df911192-d6c6-4af9-8568-f67bf2dcf926",
        "body" : "Should we print the ones that were successfully cancelled?",
        "createdAt" : "2020-03-09T14:18:47Z",
        "updatedAt" : "2020-03-20T01:25:57Z",
        "lastEditedBy" : "df911192-d6c6-4af9-8568-f67bf2dcf926",
        "tags" : [
        ]
      }
    ],
    "commit" : "829a0e60ee0d119833156dc1a781c523a6d43232",
    "line" : 1681,
    "diffHunk" : "@@ -1,1 +1543,1547 @@      val errors = cancelPartitionReassignments(adminClient, curReassigningParts)\n      if (errors.nonEmpty) {\n        throw new TerseReassignmentFailureException(\n          \"Error cancelling partition reassignment%s for:%n%s\".format(\n            if (errors.size == 1) \"\" else \"s\","
  },
  {
    "id" : "da22d01e-2f62-471b-a3df-acfbfd56a79b",
    "prId" : 8244,
    "prUrl" : "https://github.com/apache/kafka/pull/8244#pullrequestreview-372837834",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "aa428eaf-df6e-4eaf-9038-711f7de87a33",
        "parentId" : null,
        "authorId" : "df911192-d6c6-4af9-8568-f67bf2dcf926",
        "body" : "Do we have a test to ensure that the old way to run replica log dir reassignments with ZK works? i.e `./kafka-reassign-partitions --zookeeper ZK --bootstrap-server server --reassignment-json-file file_with_dir_reassignments.json`\r\nFrom reading the code, I think so - but always worth making sure",
        "createdAt" : "2020-03-09T14:41:58Z",
        "updatedAt" : "2020-03-20T01:25:57Z",
        "lastEditedBy" : "df911192-d6c6-4af9-8568-f67bf2dcf926",
        "tags" : [
        ]
      },
      {
        "id" : "8148b396-0d38-4e06-9c9e-741e20d57cec",
        "parentId" : "aa428eaf-df6e-4eaf-9038-711f7de87a33",
        "authorId" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "body" : "If you supply both `--zookeeper` and `--bootstrap-server`, then --zookeeper is ignored.  So there's no need for separate tests for the combination.",
        "createdAt" : "2020-03-09T18:47:22Z",
        "updatedAt" : "2020-03-20T01:25:57Z",
        "lastEditedBy" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "tags" : [
        ]
      },
      {
        "id" : "d07b2765-1cd8-41f0-9334-e37e00fe50ac",
        "parentId" : "aa428eaf-df6e-4eaf-9038-711f7de87a33",
        "authorId" : "083f2f03-ca7e-48a1-9781-482564dfdf53",
        "body" : "It would be nice if we gave a warning that the `--zookeeper` flag was being ignore in this case",
        "createdAt" : "2020-03-11T15:54:00Z",
        "updatedAt" : "2020-03-20T01:25:57Z",
        "lastEditedBy" : "083f2f03-ca7e-48a1-9781-482564dfdf53",
        "tags" : [
        ]
      }
    ],
    "commit" : "829a0e60ee0d119833156dc1a781c523a6d43232",
    "line" : 1246,
    "diffHunk" : "@@ -1,1 +1108,1112 @@    val (proposedParts, proposedReplicas) = parseExecuteAssignmentArgs(reassignmentJson)\n    if (proposedReplicas.nonEmpty) {\n      throw new AdminCommandFailedException(\"bootstrap-server needs to be provided when \" +\n        \"replica reassignments are present.\")\n    }"
  },
  {
    "id" : "8d6ff7db-3ae1-497a-9c0a-ed28fa41d4a7",
    "prId" : 8244,
    "prUrl" : "https://github.com/apache/kafka/pull/8244#pullrequestreview-373154173",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "11bd5a7f-3cee-441c-8d77-7c4c9599a5b2",
        "parentId" : null,
        "authorId" : "083f2f03-ca7e-48a1-9781-482564dfdf53",
        "body" : "Maybe we could split this into two \"main\" methods: one for AdminClient and one for ZK? Might make this a bit more readable.",
        "createdAt" : "2020-03-11T15:03:49Z",
        "updatedAt" : "2020-03-20T01:25:57Z",
        "lastEditedBy" : "083f2f03-ca7e-48a1-9781-482564dfdf53",
        "tags" : [
        ]
      },
      {
        "id" : "94f6bf4d-acdf-4556-8dea-14c8c85db194",
        "parentId" : "11bd5a7f-3cee-441c-8d77-7c4c9599a5b2",
        "authorId" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "body" : "ok",
        "createdAt" : "2020-03-11T21:59:29Z",
        "updatedAt" : "2020-03-20T01:25:57Z",
        "lastEditedBy" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "tags" : [
        ]
      }
    ],
    "commit" : "829a0e60ee0d119833156dc1a781c523a6d43232",
    "line" : 209,
    "diffHunk" : "@@ -1,1 +197,201 @@\n    try {\n      if (opts.options.has(opts.bootstrapServerOpt)) {\n        if (opts.options.has(opts.zkConnectOpt)) {\n          println(\"Warning: ignoring deprecated --zookeeper option because \" +"
  },
  {
    "id" : "076154b5-7a0c-4216-b633-97ae599a87af",
    "prId" : 8244,
    "prUrl" : "https://github.com/apache/kafka/pull/8244#pullrequestreview-375348290",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b4fd9936-b368-4409-af95-8f0e9d66c0f4",
        "parentId" : null,
        "authorId" : "083f2f03-ca7e-48a1-9781-482564dfdf53",
        "body" : "Since these two `generateAssignment` methods are nearly identical, do you think it's worth trying to factor out the common parts? Maybe we could have a single `generateAssignment` that accepts an `Either[Admin, ZkClient]`?",
        "createdAt" : "2020-03-11T15:27:30Z",
        "updatedAt" : "2020-03-20T01:25:57Z",
        "lastEditedBy" : "083f2f03-ca7e-48a1-9781-482564dfdf53",
        "tags" : [
        ]
      },
      {
        "id" : "247c0b44-52a5-410b-9d18-a4496fdb4297",
        "parentId" : "b4fd9936-b368-4409-af95-8f0e9d66c0f4",
        "authorId" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "body" : "Good question.  The zookeeper code is going away soon, so I don't think it's worth trying to combine the functions.\r\n\r\nI could write a function to factor out the \"print\" statements, but I'm not sure it's worth it since the main work is done by `calculateAssignment` and `formatAsReassignmentJson`, which are already shared code.",
        "createdAt" : "2020-03-11T22:03:14Z",
        "updatedAt" : "2020-03-20T01:25:57Z",
        "lastEditedBy" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "tags" : [
        ]
      },
      {
        "id" : "8c808699-7838-4174-99d3-064cb042a7bb",
        "parentId" : "b4fd9936-b368-4409-af95-8f0e9d66c0f4",
        "authorId" : "083f2f03-ca7e-48a1-9781-482564dfdf53",
        "body" : "Yea, probably not worth the effort in this case.",
        "createdAt" : "2020-03-16T16:00:29Z",
        "updatedAt" : "2020-03-20T01:25:57Z",
        "lastEditedBy" : "083f2f03-ca7e-48a1-9781-482564dfdf53",
        "tags" : [
        ]
      }
    ],
    "commit" : "829a0e60ee0d119833156dc1a781c523a6d43232",
    "line" : 857,
    "diffHunk" : "@@ -1,1 +749,753 @@    val (brokersToReassign, topicsToReassign) =\n      parseGenerateAssignmentArgs(reassignmentJson, brokerListString)\n    val currentAssignments = getReplicaAssignmentForTopics(adminClient, topicsToReassign)\n    val brokerMetadatas = getBrokerMetadata(adminClient, brokersToReassign, enableRackAwareness)\n    val proposedAssignments = calculateAssignment(currentAssignments, brokerMetadatas)"
  },
  {
    "id" : "77ef1c04-5c36-4171-b756-f8a3ed529a39",
    "prId" : 8891,
    "prUrl" : "https://github.com/apache/kafka/pull/8891#pullrequestreview-434261140",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "860eae44-5bc4-4615-8291-12f826c08204",
        "parentId" : null,
        "authorId" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "body" : "seems to break the symmetry a bit, doesn't it?  Although, I don't feel strongly about this.",
        "createdAt" : "2020-06-18T22:21:56Z",
        "updatedAt" : "2020-10-12T16:54:10Z",
        "lastEditedBy" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "tags" : [
        ]
      },
      {
        "id" : "2cb1033b-db16-4f28-ab25-348258b13475",
        "parentId" : "860eae44-5bc4-4615-8291-12f826c08204",
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "I can revert. It looked a little more reasonable when next to the suggested alter command.",
        "createdAt" : "2020-06-19T18:10:25Z",
        "updatedAt" : "2020-10-12T16:54:10Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      }
    ],
    "commit" : "b2b340f502a469ff68f66da24b711aa969891779",
    "line" : 343,
    "diffHunk" : "@@ -1,1 +1703,1707 @@        opts.reassignmentJsonFileOpt\n      ),\n      opts.listOpt -> collection.immutable.Seq.empty\n    )\n    CommandLineUtils.checkRequiredArgs(opts.parser, opts.options, requiredArgs(action): _*)"
  },
  {
    "id" : "668b31f3-5c68-4262-9a3d-e4df93638719",
    "prId" : 9807,
    "prUrl" : "https://github.com/apache/kafka/pull/9807#pullrequestreview-562841122",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bc4b450b-533e-4b2f-a654-2137a9d92693",
        "parentId" : null,
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "It might be just me, but the logic in this method is as clear as mud to me. At a high level, we are just trying to identify the sources and the destinations to fill a `PartitionMove`. The destinations are the adding replicas (AR) and the sources are the current replicas (CR) without the adding replicas. The current logic below first calls `calculateCurrentMoveMap` which does the following:\r\n\r\n1. Add each replica to both sources and destinations\r\n2. Add all AR to destinations \r\n3. Remove all removing replicas (RR) from destinations\r\n\r\nI think this computes the destinations correctly (even if it does so in an odd way), but sources will include all replicas, which is wrong. You have fixed this by removing AR from sources explicitly, but I think we can simplify a bit more. Maybe something like this\r\n\r\n```scala\r\nmove.destinations = reassignment.addingReplicas\r\nmove.sources = reassignment.replicas - reassignment.addingReplicas\r\n```\r\n\r\nAfter computing the current move map, the current logic tries to account for the proposed reassignments. It does the following:\r\n\r\n1. Overwrite current move with an empty move and set destinations to the target replicas (TR)\r\n2. Iterate through all moves and check if sources is empty, which means we have overwritten the move in step 1. If so, then we add all of CR to sources.\r\n3. Now we do one more pass over the moves and remove all of the destinations from sources.\r\n\r\nI have a hard time making sense of this logic. The main problem is that it assumes that TR are only destinations, but that is wrong. For example, if we reassign [1, 2] to [1, 3], then 1 should be a source, not a destination even though it is present in TR. I think the correct logic should be the following:\r\n\r\n1. for each proposed assignment TR, check if there is already a reassignment in progress:\r\n2. if there is a reassignment in progress, then we need to account for the current AR. We can compute sources as CR - AR, which is what we already did when calculating the current move map\r\n3. if there is no reassignment in progress, then we set sources to CR\r\n4. regardless of whether there is a reassignment in progress, we set destinations to TR - sources\r\n\r\nSomething like this?\r\n```scala\r\nproposedParts.foreach {\r\n  case (part, targetReplicas) =>\r\n    val partMoves = moveMap.getOrElseUpdate(part.topic, new mutable.HashMap[Int, PartitionMove])\r\n    val sources = partMoves.get(part) match {\r\n      case Some(move) => move.sources\r\n      case None => currentParts.get(part)\r\n    }\r\n    val destinations = targetReplicas - sources\r\n    partMoves.put(part.partition, PartitionMove(sources, destinations))\r\n}\r\n```\r\n\r\nCheck that over and see if it makes sense to you. Basically I think the current logic is unnecessarily complicated and probably wrong in multiple ways.",
        "createdAt" : "2021-01-06T03:06:26Z",
        "updatedAt" : "2021-01-07T12:09:08Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      },
      {
        "id" : "7cae4c85-9719-4ff4-aa03-8c9fe55e3f4e",
        "parentId" : "bc4b450b-533e-4b2f-a654-2137a9d92693",
        "authorId" : "12f98c82-b9ef-4668-aa6f-5a62bf3439bb",
        "body" : "Thank you @hachikuji , I also spend much time making sense of this logic since it's unnecessarily complicated and I tried to solve the issue with the least code change, which made it even much more untidy. Now I have rewritten the code according to your suggestions and have simplified it tremendously, PTAL.",
        "createdAt" : "2021-01-06T16:13:04Z",
        "updatedAt" : "2021-01-07T12:09:08Z",
        "lastEditedBy" : "12f98c82-b9ef-4668-aa6f-5a62bf3439bb",
        "tags" : [
        ]
      }
    ],
    "commit" : "191b4f4c09ab94fc98c27b2360546d9014c5748a",
    "line" : 95,
    "diffHunk" : "@@ -1,1 +1262,1266 @@   *                                the movements for that partition.\n   */\n  def calculateProposedMoveMap(currentReassignments: Map[TopicPartition, PartitionReassignment],\n                               proposedParts: Map[TopicPartition, Seq[Int]],\n                               currentParts: Map[TopicPartition, Seq[Int]]): MoveMap = {"
  }
]
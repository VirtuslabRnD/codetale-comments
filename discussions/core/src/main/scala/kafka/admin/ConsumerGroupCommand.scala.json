[
  {
    "id" : "1ffcf01c-c2c5-4f27-b012-6cf13de344ea",
    "prId" : 4479,
    "prUrl" : "https://github.com/apache/kafka/pull/4479#pullrequestreview-92406080",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "958d7c06-4e2e-4b5b-99ba-1e7a61f95514",
        "parentId" : null,
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "Hmm.. It's a little weird that we allow multiple groups to be passed when using the new consumer, but we expect a single group for the old consumer. If we're to stay consistent, do you think it would be restrictive in practice to only support deletion of a single group at a time?",
        "createdAt" : "2018-01-29T23:10:12Z",
        "updatedAt" : "2018-01-31T19:11:21Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      },
      {
        "id" : "98c93684-8e79-492a-a620-c53eb998560c",
        "parentId" : "958d7c06-4e2e-4b5b-99ba-1e7a61f95514",
        "authorId" : "2a5e5a4d-e0e2-4e26-b139-0930dd63f949",
        "body" : "In the meantime I'll look at your other feedback (thanks btw) regarding this one, it seems the old consumer also supports deleting multiple groups, i.e. `... --delete --group group1 --group group2` works and attempts to remove both groups.\r\n\r\nI originally wanted to support single group deletion only, but after considering the existing behavior for old consumer decided otherwise.",
        "createdAt" : "2018-01-30T00:14:38Z",
        "updatedAt" : "2018-01-31T19:11:21Z",
        "lastEditedBy" : "2a5e5a4d-e0e2-4e26-b139-0930dd63f949",
        "tags" : [
        ]
      },
      {
        "id" : "a58a0a47-59db-433b-9a96-4f1f9ae8a038",
        "parentId" : "958d7c06-4e2e-4b5b-99ba-1e7a61f95514",
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "Ah, you are right. The name `deleteForGroup` is kind of misleading. Maybe it just needs to be pluralized. I wouldn't hate it if we came up with better names for all of these `deleteForXXX` APIs.",
        "createdAt" : "2018-01-30T00:26:15Z",
        "updatedAt" : "2018-01-31T19:11:21Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      },
      {
        "id" : "5c3ade00-9e68-4863-b431-894219090515",
        "parentId" : "958d7c06-4e2e-4b5b-99ba-1e7a61f95514",
        "authorId" : "2a5e5a4d-e0e2-4e26-b139-0930dd63f949",
        "body" : "Sure, I gave this a quick try. Let me know if you have better suggestions.",
        "createdAt" : "2018-01-30T06:16:53Z",
        "updatedAt" : "2018-01-31T19:11:21Z",
        "lastEditedBy" : "2a5e5a4d-e0e2-4e26-b139-0930dd63f949",
        "tags" : [
        ]
      }
    ],
    "commit" : "ca60b651ee8c2c38a6122b0300504aad8d2972b9",
    "line" : 119,
    "diffHunk" : "@@ -1,1 +817,821 @@\n    override def deleteGroups(): Map[String, Errors] = {\n      val groupsToDelete = opts.options.valuesOf(opts.groupOpt).asScala.toList\n      val result = adminClient.deleteConsumerGroups(groupsToDelete)\n      val successfullyDeleted = result.filter {"
  },
  {
    "id" : "94e9f6c1-a5cc-48f3-a8f7-f076c2ef4dfe",
    "prId" : 4479,
    "prUrl" : "https://github.com/apache/kafka/pull/4479#pullrequestreview-92694127",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "712bf28b-7d15-479d-8645-c5144eba8634",
        "parentId" : null,
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "Seems like you were intending to use the results of the `deleteGroupsInfo` and such. We should probably have a test case (could be done in a follow-up).",
        "createdAt" : "2018-01-30T17:17:16Z",
        "updatedAt" : "2018-01-31T19:11:21Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      },
      {
        "id" : "8a45d4c0-1198-4a73-9b02-4be87ed171b4",
        "parentId" : "712bf28b-7d15-479d-8645-c5144eba8634",
        "authorId" : "2a5e5a4d-e0e2-4e26-b139-0930dd63f949",
        "body" : "Sure, I'll submit a separate PR with proper test(s) after this is merged.",
        "createdAt" : "2018-01-30T19:39:34Z",
        "updatedAt" : "2018-01-31T19:11:21Z",
        "lastEditedBy" : "2a5e5a4d-e0e2-4e26-b139-0930dd63f949",
        "tags" : [
        ]
      }
    ],
    "commit" : "ca60b651ee8c2c38a6122b0300504aad8d2972b9",
    "line" : 40,
    "diffHunk" : "@@ -1,1 +369,373 @@        deleteAllGroupsInfoForTopic()\n\n      Map()\n    }\n"
  },
  {
    "id" : "41c102cd-10b9-46b7-97ac-50618dfe2566",
    "prId" : 5726,
    "prUrl" : "https://github.com/apache/kafka/pull/5726#pullrequestreview-193605984",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0ded092a-46ee-4486-9082-7391436acfa3",
        "parentId" : null,
        "authorId" : "2a5e5a4d-e0e2-4e26-b139-0930dd63f949",
        "body" : "Is there a benefit in calling these methods for each group vs. the alternative of having the method itself deal with the group list and return the full result set at once? With the latter we seem to at least save a number of method calls.",
        "createdAt" : "2019-01-16T06:58:14Z",
        "updatedAt" : "2019-04-08T12:25:50Z",
        "lastEditedBy" : "2a5e5a4d-e0e2-4e26-b139-0930dd63f949",
        "tags" : [
        ]
      },
      {
        "id" : "019843af-f116-4bed-85a4-46e2a4aa8c06",
        "parentId" : "0ded092a-46ee-4486-9082-7391436acfa3",
        "authorId" : "2a5e5a4d-e0e2-4e26-b139-0930dd63f949",
        "body" : "@rootex-  For some reason I don't see your response to this message on github even though I received it in email. What I meant was to more the `for` loop inside each of `collectGroupOffsets`, `collectGroupMembers`, `collectGroupState` and have them return the full output at once, to reduce the number of times they are called to 1. Does that make sense?",
        "createdAt" : "2019-01-16T20:41:10Z",
        "updatedAt" : "2019-04-08T12:25:50Z",
        "lastEditedBy" : "2a5e5a4d-e0e2-4e26-b139-0930dd63f949",
        "tags" : [
        ]
      },
      {
        "id" : "93c0fc02-e8dc-4310-b259-21e7d989ddf4",
        "parentId" : "0ded092a-46ee-4486-9082-7391436acfa3",
        "authorId" : "b0d5107f-51e2-4145-bcbb-c082a84a2d61",
        "body" : "> @rootex- For some reason I don't see your response to this message on github even though I received it in email. What I meant was to more the `for` loop inside each of `collectGroupOffsets`, `collectGroupMembers`, `collectGroupState` and have them return the full output at once, to reduce the number of times they are called to 1. Does that make sense?\r\n\r\n@vahidhashemian yes, you were totally right! Thanks for your attention to detail. By doing this we actually reduce the number of calls to AdminClient API and really speed things up ðŸ‘  Definitely that makes sense. I have applied all corrections, please kindly review once again ",
        "createdAt" : "2019-01-17T12:48:10Z",
        "updatedAt" : "2019-04-08T12:25:50Z",
        "lastEditedBy" : "b0d5107f-51e2-4145-bcbb-c082a84a2d61",
        "tags" : [
        ]
      }
    ],
    "commit" : "d46a39a67c8313bff14fc4693ccd6692657a7a79",
    "line" : 352,
    "diffHunk" : "@@ -1,1 +318,322 @@        val states = collectGroupsState(groupIds)\n        printStates(states)\n      }\n    }\n"
  },
  {
    "id" : "0288ed04-2b6c-4055-8c6a-f6b3e59b58f2",
    "prId" : 5726,
    "prUrl" : "https://github.com/apache/kafka/pull/5726#pullrequestreview-213252646",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f2da7e0f-5af9-456b-9b25-dbfeeb13bc82",
        "parentId" : null,
        "authorId" : "2a5e5a4d-e0e2-4e26-b139-0930dd63f949",
        "body" : "Do you think it makes sense to sort the rows by group id? I don't have a strong preference, but think sorting would help when there are several groups in the result.",
        "createdAt" : "2019-01-18T06:41:23Z",
        "updatedAt" : "2019-04-08T12:25:50Z",
        "lastEditedBy" : "2a5e5a4d-e0e2-4e26-b139-0930dd63f949",
        "tags" : [
        ]
      },
      {
        "id" : "7e64f641-f39b-4357-a85d-802e3f49d1f7",
        "parentId" : "f2da7e0f-5af9-456b-9b25-dbfeeb13bc82",
        "authorId" : "b0d5107f-51e2-4145-bcbb-c082a84a2d61",
        "body" : "> Do you think it makes sense to sort the rows by group id? I don't have a strong preference, but think sorting would help when there are several groups in the result.\r\n\r\n@vahidhashemian I don't have a strong preference either. At least we could sort by default or add a `--sorted` option if that makes sense. But we can always grep and sort by group id using standard Linux shell utils. From the user perspective though, data given in a sorted order is a bit more expected and desired than randomly ordered. Do you think the same? (I mean to enable sorting by default)",
        "createdAt" : "2019-01-18T09:04:07Z",
        "updatedAt" : "2019-04-08T12:25:50Z",
        "lastEditedBy" : "b0d5107f-51e2-4145-bcbb-c082a84a2d61",
        "tags" : [
        ]
      },
      {
        "id" : "e223a7a5-a652-4bce-9670-8b7577b6e4cb",
        "parentId" : "f2da7e0f-5af9-456b-9b25-dbfeeb13bc82",
        "authorId" : "2a5e5a4d-e0e2-4e26-b139-0930dd63f949",
        "body" : "Yes, sorting by default would make sense to me. A `--sorted` option was not discussed in the KIP, so let's go by default sorting based on group id. We can always make additional enhancements to this if necessary.\r\n\r\nBTW, is the failed unit test relevant to this PR?",
        "createdAt" : "2019-01-18T15:40:40Z",
        "updatedAt" : "2019-04-08T12:25:50Z",
        "lastEditedBy" : "2a5e5a4d-e0e2-4e26-b139-0930dd63f949",
        "tags" : [
        ]
      },
      {
        "id" : "7ccb7bb3-1386-4bc7-8f9c-7b591c2e3c09",
        "parentId" : "f2da7e0f-5af9-456b-9b25-dbfeeb13bc82",
        "authorId" : "b0d5107f-51e2-4145-bcbb-c082a84a2d61",
        "body" : "> Yes, sorting by default would make sense to me. A --sorted option was not discussed in the KIP, so let's go by default sorting based on group id. We can always make additional enhancements to this if necessary.\r\n\r\n@vahidhashemian done, please kindly review once again.\r\n\r\n> BTW, is the failed unit test relevant to this PR?\r\n\r\nWhich one was it? No info available at this moment.",
        "createdAt" : "2019-01-20T14:23:11Z",
        "updatedAt" : "2019-04-08T12:25:50Z",
        "lastEditedBy" : "b0d5107f-51e2-4145-bcbb-c082a84a2d61",
        "tags" : [
        ]
      },
      {
        "id" : "f7b989d9-757e-470f-8521-9e10ee9b45e6",
        "parentId" : "f2da7e0f-5af9-456b-9b25-dbfeeb13bc82",
        "authorId" : "b0d5107f-51e2-4145-bcbb-c082a84a2d61",
        "body" : "@vahidhashemian all done",
        "createdAt" : "2019-03-12T08:43:44Z",
        "updatedAt" : "2019-04-08T12:25:50Z",
        "lastEditedBy" : "b0d5107f-51e2-4145-bcbb-c082a84a2d61",
        "tags" : [
        ]
      }
    ],
    "commit" : "d46a39a67c8313bff14fc4693ccd6692657a7a79",
    "line" : 179,
    "diffHunk" : "@@ -1,1 +208,212 @@\n    private def printOffsets(offsets: Map[String, (Option[String], Option[Seq[PartitionAssignmentState]])]): Unit = {\n      for ((groupId, (state, assignments)) <- offsets) {\n        if (shouldPrintMemberState(groupId, state, size(assignments))) {\n          // find proper columns width"
  },
  {
    "id" : "53ab4928-91ac-4e5b-8f7b-ed2fab056a04",
    "prId" : 6989,
    "prUrl" : "https://github.com/apache/kafka/pull/6989#pullrequestreview-254395008",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f5a61561-511f-4e88-8aba-0a84b96bc130",
        "parentId" : null,
        "authorId" : "4a7c311c-0954-4671-a0d2-266cb67437ad",
        "body" : "I think importing `scala.collection.{Set, Seq, Map, etc}` causes a lot of issues. I think this is going to be even more problematic with 2.13. I think we should ban these imports and only allow the `Predef` imports, `scala.collection.mutable` and `scala.collection.immutable`. What do you think?",
        "createdAt" : "2019-06-24T16:08:31Z",
        "updatedAt" : "2019-06-30T07:35:40Z",
        "lastEditedBy" : "4a7c311c-0954-4671-a0d2-266cb67437ad",
        "tags" : [
        ]
      },
      {
        "id" : "18ca9ca6-7896-42f3-9efb-335be7c54a47",
        "parentId" : "f5a61561-511f-4e88-8aba-0a84b96bc130",
        "authorId" : "d8c7cf80-a55a-474c-a4f4-f60a9efda52c",
        "body" : "Can you elaborate on the issues you are thinking of? The Predef imports are all about immutable collections and they have different performance characteristics and I don't think it makes sense to make that change for Scala 2.13 support.",
        "createdAt" : "2019-06-24T18:27:51Z",
        "updatedAt" : "2019-06-30T07:35:40Z",
        "lastEditedBy" : "d8c7cf80-a55a-474c-a4f4-f60a9efda52c",
        "tags" : [
        ]
      },
      {
        "id" : "f639dcf0-910f-46c6-a2cb-af0e31e0fa6f",
        "parentId" : "f5a61561-511f-4e88-8aba-0a84b96bc130",
        "authorId" : "4a7c311c-0954-4671-a0d2-266cb67437ad",
        "body" : "If we take `Map` as an example, the issue is that `collection.Map`, `collection.immutable.Map` and `collection.mutable.Map` are all different types. `collection.Map` is a parent both mutable and immutable but the reality is that `collection.Map` cannot be safely downcasted to `collection.immutable.Map` or `collection.mutable.Map`.\r\n\r\n```\r\n[info] Compiling 1 Scala source to target/scala-2.12/classes ...\r\n[error] TestCollection.scala:16:22: type mismatch;\r\n[error]  found   : Map[String,String] (in scala.collection)\r\n[error]  required: Map[String,String] (in scala.collection.immutable)\r\n[error]   expectImmutableMap(map)\r\n[error]                      ^\r\n[error] TestCollection.scala:18:22: type mismatch;\r\n[error]  found   : Map[String,String] (in scala.collection.mutable)\r\n[error]  required: Map[String,String] (in scala.collection.immutable)\r\n[error]   expectImmutableMap(mutableMap)\r\n[error]                      ^\r\n[error] TestCollection.scala:20:20: type mismatch;\r\n[error]  found   : Map[String,String] (in scala.collection)\r\n[error]  required: Map[String,String] (in scala.collection.mutable)\r\n[error]   expectMutableMap(map)\r\n[error]                    ^\r\n[error] TestCollection.scala:21:20: type mismatch;\r\n[error]  found   : Map[String,String] (in scala.collection.immutable)\r\n[error]  required: Map[String,String] (in scala.collection.mutable)\r\n[error]   expectMutableMap(immutableMap)\r\n[error]                    ^\r\n[error] four errors found\r\n```\r\n\r\nIt is very rare that we have code that is generic over mutable vs immutable collection. I think that this conversions are simplify is we require a concrete version like `collection.immtable.Map` or `collection.mutable.Map`.",
        "createdAt" : "2019-06-24T20:56:31Z",
        "updatedAt" : "2019-06-30T07:35:40Z",
        "lastEditedBy" : "4a7c311c-0954-4671-a0d2-266cb67437ad",
        "tags" : [
        ]
      },
      {
        "id" : "4a73261a-7c40-463c-ba02-fadf82c336f9",
        "parentId" : "f5a61561-511f-4e88-8aba-0a84b96bc130",
        "authorId" : "4a7c311c-0954-4671-a0d2-266cb67437ad",
        "body" : "> The Predef imports are all about immutable collections\r\n\r\nThis is true except for `Seq` but they are fixing this in Scala 2.13. In the other Scala version `Seq` was a alias for `collection.Seq` which is the parent class for `collection.immutable.Seq` and `collection.mutable.Seq`.",
        "createdAt" : "2019-06-24T20:58:31Z",
        "updatedAt" : "2019-06-30T07:35:40Z",
        "lastEditedBy" : "4a7c311c-0954-4671-a0d2-266cb67437ad",
        "tags" : [
        ]
      },
      {
        "id" : "5de6ade8-ffb6-4716-93e9-cb5f1da9cbe4",
        "parentId" : "f5a61561-511f-4e88-8aba-0a84b96bc130",
        "authorId" : "d8c7cf80-a55a-474c-a4f4-f60a9efda52c",
        "body" : "I think it's worth understanding the context. The Kafka code was written with the assumption that the Seq in Predef was not immutable. In Scala 2.13 it has become immutable. The simplest change to maintain existing assumptions is to add `import scala.collection.Seq` everywhere. In the future, we can consider other changes, I don't think they should be in the Scala 2.13 PR.\r\n\r\nIn this particular class, I did add an import to `scala.collection.Map` and I can remove that if that's what you are objecting to.\r\n\r\n> It is very rare that we have code that is generic over mutable vs immutable collection.\r\n\r\nI don't think this is true, a lot of code just does `map/filter/flatMap/foreach/etc`. Such code doesn't care whether the collection is mutable or immutable.\r\n\r\n> but the reality is that collection.Map cannot be safely downcasted to collection.immutable.Map or collection.mutable.Map\r\n\r\nI don't think you should ever downcast collections outside of very specialized collection utility code (e.g. a method that converts from one collection to another could do this for best performance).",
        "createdAt" : "2019-06-26T06:00:00Z",
        "updatedAt" : "2019-06-30T07:35:40Z",
        "lastEditedBy" : "d8c7cf80-a55a-474c-a4f4-f60a9efda52c",
        "tags" : [
        ]
      }
    ],
    "commit" : "36d72d5e6c54f763fa145ca508a203974337e852",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +35,39 @@import scala.collection.JavaConverters._\nimport scala.collection.mutable.ListBuffer\nimport scala.collection.{immutable, Map, Seq, Set, mutable}\nimport scala.util.{Failure, Success, Try}\nimport joptsimple.OptionSpec"
  },
  {
    "id" : "9ac1c4a6-7aa8-47c1-81d5-2470efbb5ed0",
    "prId" : 7478,
    "prUrl" : "https://github.com/apache/kafka/pull/7478#pullrequestreview-304719458",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9bf144bf-4e18-4c13-8cad-5f68bd4c3880",
        "parentId" : null,
        "authorId" : "59ca7821-b29c-4f24-a9d5-cbd394145686",
        "body" : "I think this should be moved in the case it gives details for (`GROUP_SUBSCRIBED_TO_TOPIC`, etc.) as it does not bring any value for the other cases. What do you think?",
        "createdAt" : "2019-10-21T14:01:19Z",
        "updatedAt" : "2019-10-25T02:13:46Z",
        "lastEditedBy" : "59ca7821-b29c-4f24-a9d5-cbd394145686",
        "tags" : [
        ]
      },
      {
        "id" : "a83d218d-9c07-41ba-9607-0c141f197e52",
        "parentId" : "9bf144bf-4e18-4c13-8cad-5f68bd4c3880",
        "authorId" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "body" : "I feel this information is helpful no matter what the error case we hit, and for longer term this means we don't have worry too much about adding some error case into a specific case bucket.",
        "createdAt" : "2019-10-21T17:17:56Z",
        "updatedAt" : "2019-10-25T02:13:46Z",
        "lastEditedBy" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "tags" : [
        ]
      }
    ],
    "commit" : "0e00990aa16e167cae6d17125063f4a54f778b05",
    "line" : 92,
    "diffHunk" : "@@ -1,1 +481,485 @@      }\n\n      println(\"\\n%-30s %-15s %-15s\".format(\"TOPIC\", \"PARTITION\", \"STATUS\"))\n      partitionLevelResult.toList.sortBy(t => t._1.topic + t._1.partition.toString).foreach { case (tp, error) =>\n        println(\"%-30s %-15s %-15s\".format("
  },
  {
    "id" : "397785f7-cb21-4090-b629-b790d08f699d",
    "prId" : 8238,
    "prUrl" : "https://github.com/apache/kafka/pull/8238#pullrequestreview-419761723",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "156c06c7-0100-4bbb-83e3-024e4424c8d5",
        "parentId" : null,
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "Since we have an optional argument, do we need to validate that it is not provided when `--describe` is used?",
        "createdAt" : "2020-05-28T06:11:22Z",
        "updatedAt" : "2020-05-29T09:30:58Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      }
    ],
    "commit" : "acb64f32f6fc2353dcaec2be44d05c6cd1a77b2d",
    "line" : 165,
    "diffHunk" : "@@ -1,1 +1061,1065 @@    val stateOpt = parser.accepts(\"state\", StateDoc)\n                         .availableIf(describeOpt, listOpt)\n                         .withOptionalArg()\n                         .ofType(classOf[String])\n"
  },
  {
    "id" : "af8ef6a8-0874-4f40-9f97-0972ccbf50ec",
    "prId" : 8931,
    "prUrl" : "https://github.com/apache/kafka/pull/8931#pullrequestreview-438245111",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a981f83e-2720-40e4-bff2-98f19c619a51",
        "parentId" : null,
        "authorId" : "d8c7cf80-a55a-474c-a4f4-f60a9efda52c",
        "body" : "New warning flagged by the compiler.",
        "createdAt" : "2020-06-26T12:14:51Z",
        "updatedAt" : "2020-06-26T12:14:51Z",
        "lastEditedBy" : "d8c7cf80-a55a-474c-a4f4-f60a9efda52c",
        "tags" : [
        ]
      }
    ],
    "commit" : "261ab95d14bbc7d88b6d57f5ad291351eed91e0b",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +569,573 @@      * Returns the state of the specified consumer group and partition assignment states\n      */\n    @nowarn(\"cat=optimizer\")\n    def collectGroupOffsets(groupId: String): (Option[String], Option[Seq[PartitionAssignmentState]]) = {\n      collectGroupsOffsets(List(groupId)).getOrElse(groupId, (None, None))"
  },
  {
    "id" : "460cc992-14a3-4d53-a686-d188a6aca63a",
    "prId" : 9255,
    "prUrl" : "https://github.com/apache/kafka/pull/9255#pullrequestreview-499644898",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "baa25130-455d-4c6e-8f8a-cf9e6775643e",
        "parentId" : null,
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "I am must wondering if we can have a dependency from `core` to `clients` module? \\cc @ijuma ",
        "createdAt" : "2020-09-11T22:40:26Z",
        "updatedAt" : "2020-09-16T11:03:04Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "6b286482-1b57-4295-bf95-36bf1acfc576",
        "parentId" : "baa25130-455d-4c6e-8f8a-cf9e6775643e",
        "authorId" : "dc57ad2f-4b98-4cb2-8a4f-2be6bf46015c",
        "body" : "@mjsax @guozhangwang request you to please suggest where we can put this common code.",
        "createdAt" : "2020-09-16T15:11:03Z",
        "updatedAt" : "2020-09-16T15:35:10Z",
        "lastEditedBy" : "dc57ad2f-4b98-4cb2-8a4f-2be6bf46015c",
        "tags" : [
        ]
      },
      {
        "id" : "c7ee5e90-eaf2-4f4c-a567-b71b1c2852a0",
        "parentId" : "baa25130-455d-4c6e-8f8a-cf9e6775643e",
        "authorId" : "d8c7cf80-a55a-474c-a4f4-f60a9efda52c",
        "body" : "`core` does depend on `clients` generally.",
        "createdAt" : "2020-09-30T17:02:49Z",
        "updatedAt" : "2020-09-30T17:02:49Z",
        "lastEditedBy" : "d8c7cf80-a55a-474c-a4f4-f60a9efda52c",
        "tags" : [
        ]
      },
      {
        "id" : "27dd666b-3680-4601-9a9c-4dd1068d399b",
        "parentId" : "baa25130-455d-4c6e-8f8a-cf9e6775643e",
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "Thanks for clarification. So we are good.",
        "createdAt" : "2020-09-30T17:10:40Z",
        "updatedAt" : "2020-09-30T17:10:40Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      }
    ],
    "commit" : "08b49370ebf9c970f8e595acc2b72d40dbbeeb4a",
    "line" : 33,
    "diffHunk" : "@@ -1,1 +810,814 @@        }\n      } else if (opts.options.has(opts.resetToDatetimeOpt)) {\n        val timestamp = Utils.getDateTime(opts.options.valueOf(opts.resetToDatetimeOpt))\n        val logTimestampOffsets = getLogTimestampOffsets(groupId, partitionsToReset, timestamp)\n        partitionsToReset.map { topicPartition =>"
  }
]
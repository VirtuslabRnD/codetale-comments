[
  {
    "id" : "9a03da0c-b77b-4656-8d15-6ac52c17451f",
    "prId" : 7911,
    "prUrl" : "https://github.com/apache/kafka/pull/7911#pullrequestreview-340538527",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "84631594-fce2-4b8f-b75a-91d1ea6461b4",
        "parentId" : null,
        "authorId" : "d8c7cf80-a55a-474c-a4f4-f60a9efda52c",
        "body" : "Another thing to consider for a separate PR: this method seems highly inefficient. We take _all_ the keys in the cache and do a bunch of transformations. It seems like we should avoid that, no? Intuitively, we would do a filter operation first and then transform only the cache items that match.",
        "createdAt" : "2020-01-09T13:24:38Z",
        "updatedAt" : "2020-01-09T13:24:38Z",
        "lastEditedBy" : "d8c7cf80-a55a-474c-a4f4-f60a9efda52c",
        "tags" : [
        ]
      },
      {
        "id" : "374e3bec-7d06-4de3-88e8-2c7a0b59b624",
        "parentId" : "84631594-fce2-4b8f-b75a-91d1ea6461b4",
        "authorId" : "b4936a15-698a-496e-85a1-b1e229b4986b",
        "body" : "I will do https://issues.apache.org/jira/browse/KAFKA-8847 first to remove references to the old classes and deprecate those. And that would avoid a lot of the unnecessary conversions. I can see if more can be done to improve this in the same PR.",
        "createdAt" : "2020-01-09T13:43:49Z",
        "updatedAt" : "2020-01-09T13:43:50Z",
        "lastEditedBy" : "b4936a15-698a-496e-85a1-b1e229b4986b",
        "tags" : [
        ]
      },
      {
        "id" : "bdcea45f-1719-4653-92a2-5276a68dce60",
        "parentId" : "84631594-fce2-4b8f-b75a-91d1ea6461b4",
        "authorId" : "d8c7cf80-a55a-474c-a4f4-f60a9efda52c",
        "body" : "Sounds good.",
        "createdAt" : "2020-01-09T14:01:03Z",
        "updatedAt" : "2020-01-09T14:01:03Z",
        "lastEditedBy" : "d8c7cf80-a55a-474c-a4f4-f60a9efda52c",
        "tags" : [
        ]
      }
    ],
    "commit" : "ac83288aaa1dbd164b088ca140d12b23d4608b19",
    "line" : 16,
    "diffHunk" : "@@ -1,1 +191,195 @@      // Find all potentially matching resource patterns from the provided filters and ACL cache and apply the filters\n      val resources = aclCache.keys ++ filters.map(_._1.patternFilter).filter(_.matchesAtMostOne).flatMap(filterToResources)\n      val resourcesToUpdate = resources.map { resource =>\n        val matchingFilters = filters.filter { case (filter, _) =>\n          filter.patternFilter.matches(resource.toPattern)"
  }
]
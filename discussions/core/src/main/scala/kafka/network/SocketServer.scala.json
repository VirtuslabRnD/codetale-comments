[
  {
    "id" : "3bf6c771-522a-43cc-81dc-3ce9c958f66c",
    "prId" : 4471,
    "prUrl" : "https://github.com/apache/kafka/pull/4471#pullrequestreview-92406826",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "15928730-8780-4925-931d-d199a6109934",
        "parentId" : null,
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "I'm not really sure it's worth it, but I guess `processors` could be a concurrent map to avoid holding the lock when we just need to access the collection.",
        "createdAt" : "2018-01-29T19:03:26Z",
        "updatedAt" : "2018-01-30T15:24:51Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      },
      {
        "id" : "2a6eaf7c-0b6f-448b-a08c-04c2d02ca2ed",
        "parentId" : "15928730-8780-4925-931d-d199a6109934",
        "authorId" : "b4936a15-698a-496e-85a1-b1e229b4986b",
        "body" : "I left this synchronization in there since this is only for new connections.",
        "createdAt" : "2018-01-30T00:27:38Z",
        "updatedAt" : "2018-01-30T15:24:51Z",
        "lastEditedBy" : "b4936a15-698a-496e-85a1-b1e229b4986b",
        "tags" : [
        ]
      }
    ],
    "commit" : "5c25c58922801e023bc1fe56919dfbab7f4565f5",
    "line" : 196,
    "diffHunk" : "@@ -1,1 +332,336 @@                iter.remove()\n                if (key.isAcceptable) {\n                  val processor = synchronized {\n                    currentProcessor = currentProcessor % processors.size\n                    processors(currentProcessor)"
  },
  {
    "id" : "579b83c8-ed39-4baf-8bca-4e14a731a6fe",
    "prId" : 4471,
    "prUrl" : "https://github.com/apache/kafka/pull/4471#pullrequestreview-92406477",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "cf95883c-83e7-49ed-853f-beac1083c83f",
        "parentId" : null,
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "Do we need to reset `nextProcessorId`, or is the intent to always assign new processors with an id which hasn't been used before?",
        "createdAt" : "2018-01-29T19:09:28Z",
        "updatedAt" : "2018-01-30T15:24:51Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      },
      {
        "id" : "234976a5-bad0-4871-8495-22795d40451b",
        "parentId" : "cf95883c-83e7-49ed-853f-beac1083c83f",
        "authorId" : "b4936a15-698a-496e-85a1-b1e229b4986b",
        "body" : "Thought it was better not to reuse processor ids, hence the `Map` of processors.",
        "createdAt" : "2018-01-30T00:25:51Z",
        "updatedAt" : "2018-01-30T15:24:51Z",
        "lastEditedBy" : "b4936a15-698a-496e-85a1-b1e229b4986b",
        "tags" : [
        ]
      }
    ],
    "commit" : "5c25c58922801e023bc1fe56919dfbab7f4565f5",
    "line" : 177,
    "diffHunk" : "@@ -1,1 +303,307 @@  }\n\n  private[network] def removeProcessors(removeCount: Int, requestChannel: RequestChannel): Unit = synchronized {\n    // Shutdown `removeCount` processors. Remove them from the processor list first so that no more\n    // connections are assigned. Shutdown the removed processors, closing the selector and its connections."
  },
  {
    "id" : "b3472025-9a07-4df0-8ba1-efed625f2c26",
    "prId" : 4488,
    "prUrl" : "https://github.com/apache/kafka/pull/4488#pullrequestreview-93722756",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "31467e79-bc5a-4bd4-860f-a512385b8353",
        "parentId" : null,
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "Add log line her and in `removeListeners`?",
        "createdAt" : "2018-02-02T22:22:32Z",
        "updatedAt" : "2018-02-04T02:11:57Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      }
    ],
    "commit" : "a0488d78e0ea02c3ddde1a31f6c1e0613a443e3d",
    "line" : 101,
    "diffHunk" : "@@ -1,1 +193,197 @@  }\n\n  def addListeners(listenersAdded: Seq[EndPoint]): Unit = synchronized {\n    info(s\"Adding listeners for endpoints $listenersAdded\")\n    createProcessors(config.numNetworkThreads, listenersAdded)"
  },
  {
    "id" : "98c870ca-fec8-44bf-a787-19b5d66bd494",
    "prId" : 4542,
    "prUrl" : "https://github.com/apache/kafka/pull/4542#pullrequestreview-95213874",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "53c8a3a5-d2ed-4e16-89fe-bca0640dbfb1",
        "parentId" : null,
        "authorId" : "d8c7cf80-a55a-474c-a4f4-f60a9efda52c",
        "body" : "Doesn't this change the full metric name?",
        "createdAt" : "2018-02-08T19:42:30Z",
        "updatedAt" : "2018-02-08T19:42:45Z",
        "lastEditedBy" : "d8c7cf80-a55a-474c-a4f4-f60a9efda52c",
        "tags" : [
        ]
      },
      {
        "id" : "fdb7d744-3888-488d-ae76-7a5d55cbb6b6",
        "parentId" : "53c8a3a5-d2ed-4e16-89fe-bca0640dbfb1",
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "Yeah, you are right. I forgot about the type attribute. @rajinisivaram Maybe you can fix it in #4539?",
        "createdAt" : "2018-02-08T19:56:52Z",
        "updatedAt" : "2018-02-08T19:56:52Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      },
      {
        "id" : "a36486a7-ef63-467f-b3f2-80a3f5f76da6",
        "parentId" : "53c8a3a5-d2ed-4e16-89fe-bca0640dbfb1",
        "authorId" : "b4936a15-698a-496e-85a1-b1e229b4986b",
        "body" : "@hachikuji I had forgotten too. Yes, I will update in #4539",
        "createdAt" : "2018-02-08T20:02:28Z",
        "updatedAt" : "2018-02-08T20:02:28Z",
        "lastEditedBy" : "b4936a15-698a-496e-85a1-b1e229b4986b",
        "tags" : [
        ]
      }
    ],
    "commit" : "e82524c88b3b3e0fb771bcb92f096fe8890b61b7",
    "line" : 54,
    "diffHunk" : "@@ -1,1 +476,480 @@  ).asJava\n\n  newGauge(\"ResponseQueueSize\",\n    new Gauge[Int] {\n      def value = responseQueue.size()"
  },
  {
    "id" : "43b2341e-f19f-4736-987b-9800985bc91b",
    "prId" : 4867,
    "prUrl" : "https://github.com/apache/kafka/pull/4867#pullrequestreview-112329517",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a884dc3d-1af4-4f79-98ac-de6002ba0537",
        "parentId" : null,
        "authorId" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "body" : "This is not directly related to this patch. However, it seems that we need some synchronization on processor between the reader and the writer?",
        "createdAt" : "2018-04-13T21:47:58Z",
        "updatedAt" : "2018-04-16T13:58:03Z",
        "lastEditedBy" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "tags" : [
        ]
      },
      {
        "id" : "274274ac-de66-4767-bc34-9a8f3edf453a",
        "parentId" : "a884dc3d-1af4-4f79-98ac-de6002ba0537",
        "authorId" : "b4936a15-698a-496e-85a1-b1e229b4986b",
        "body" : "@junrao Thanks for the review. We were already synchronizing on all read/write accesses to `processors` apart from `shutdown()`. I think that was safe anyway, but I have added synchronize in shutdown as well to be consistent.",
        "createdAt" : "2018-04-16T08:59:50Z",
        "updatedAt" : "2018-04-16T13:58:03Z",
        "lastEditedBy" : "b4936a15-698a-496e-85a1-b1e229b4986b",
        "tags" : [
        ]
      }
    ],
    "commit" : "d881674db8abb655be89fd0d126c34c99cf8d2fd",
    "line" : 60,
    "diffHunk" : "@@ -1,1 +334,338 @@\n  private[network] def addProcessors(newProcessors: Buffer[Processor]): Unit = synchronized {\n    processors ++= newProcessors\n    if (processorsStarted.get)\n      startProcessors(newProcessors)"
  },
  {
    "id" : "3de31528-d0f6-47a8-8030-2364de9ac15d",
    "prId" : 5921,
    "prUrl" : "https://github.com/apache/kafka/pull/5921#pullrequestreview-181372959",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "20516e1c-e222-4911-aae9-bdb76b8f9932",
        "parentId" : null,
        "authorId" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "body" : "Could we change the comment above SocketServer and a few other places accordingly?",
        "createdAt" : "2018-11-30T23:15:00Z",
        "updatedAt" : "2018-12-21T21:26:18Z",
        "lastEditedBy" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "tags" : [
        ]
      },
      {
        "id" : "b7a563f3-41af-4e02-a9c2-ffd814c8f352",
        "parentId" : "20516e1c-e222-4911-aae9-bdb76b8f9932",
        "authorId" : "68c9b940-6e55-49f3-b14b-008ab7e2e635",
        "body" : "Agreed.",
        "createdAt" : "2018-12-04T17:05:16Z",
        "updatedAt" : "2018-12-21T21:26:18Z",
        "lastEditedBy" : "68c9b940-6e55-49f3-b14b-008ab7e2e635",
        "tags" : [
        ]
      }
    ],
    "commit" : "c40a575b7d984205ae4a8ac4b0584b9731566090",
    "line" : 27,
    "diffHunk" : "@@ -1,1 +71,75 @@class SocketServer(val config: KafkaConfig, val metrics: Metrics, val time: Time, val credentialProvider: CredentialProvider) extends Logging with KafkaMetricsGroup {\n\n  val DataPlanePrefix = \"data-plane\"\n  val ControlPlanePrefix = \"control-plane\"\n"
  },
  {
    "id" : "734e515f-c9a4-4874-9f5c-cd1169ddc93a",
    "prId" : 5921,
    "prUrl" : "https://github.com/apache/kafka/pull/5921#pullrequestreview-181426533",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9c56b8f5-7247-40e6-9756-5956719b9070",
        "parentId" : null,
        "authorId" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "body" : "Should we include expired connections from the control plane processor too?",
        "createdAt" : "2018-12-04T00:22:38Z",
        "updatedAt" : "2018-12-21T21:26:18Z",
        "lastEditedBy" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "tags" : [
        ]
      },
      {
        "id" : "5c10bf20-a1b2-49e1-912d-6f1a5af40f5d",
        "parentId" : "9c56b8f5-7247-40e6-9756-5956719b9070",
        "authorId" : "68c9b940-6e55-49f3-b14b-008ab7e2e635",
        "body" : "Agreed. Will add \"ControlPlaneExpiredConnectionsKilledCount\". I wanted to check if we can change the existing metric to \"DataPlaneExpiredConnectionsKilledCount\". \r\nIf we agree as per the pros and cons listed above for request/response queue size metric naming, I will update the KIP or revert this change, accordingly.",
        "createdAt" : "2018-12-04T19:02:43Z",
        "updatedAt" : "2018-12-21T21:26:18Z",
        "lastEditedBy" : "68c9b940-6e55-49f3-b14b-008ab7e2e635",
        "tags" : [
        ]
      }
    ],
    "commit" : "c40a575b7d984205ae4a8ac4b0584b9731566090",
    "line" : 101,
    "diffHunk" : "@@ -1,1 +160,164 @@\n        def value = SocketServer.this.synchronized {\n          val expiredConnectionsKilledCountMetricNames = dataPlaneProcessors.values.asScala.map { p =>\n            metrics.metricName(\"expired-connections-killed-count\", \"socket-server-metrics\", p.metricTags)\n          }"
  },
  {
    "id" : "e181bf52-ab12-492f-b346-0cee34edab86",
    "prId" : 5921,
    "prUrl" : "https://github.com/apache/kafka/pull/5921#pullrequestreview-185883995",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "01899242-ec12-4b87-a80e-0d5c6b99bba0",
        "parentId" : null,
        "authorId" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "body" : "It seems that listenerProcessors can be local to the foreach clause below?",
        "createdAt" : "2018-12-14T18:10:01Z",
        "updatedAt" : "2018-12-21T21:26:18Z",
        "lastEditedBy" : "442b5138-0781-4001-8ac5-0593f2136d1c",
        "tags" : [
        ]
      },
      {
        "id" : "650b09b6-56a1-43de-b6ed-66a7d3099fa4",
        "parentId" : "01899242-ec12-4b87-a80e-0d5c6b99bba0",
        "authorId" : "68c9b940-6e55-49f3-b14b-008ab7e2e635",
        "body" : "Agreed.",
        "createdAt" : "2018-12-18T02:24:07Z",
        "updatedAt" : "2018-12-21T21:26:18Z",
        "lastEditedBy" : "68c9b940-6e55-49f3-b14b-008ab7e2e635",
        "tags" : [
        ]
      }
    ],
    "commit" : "c40a575b7d984205ae4a8ac4b0584b9731566090",
    "line" : 177,
    "diffHunk" : "@@ -1,1 +229,233 @@      controlPlaneAcceptorOpt = Some(controlPlaneAcceptor)\n      controlPlaneProcessorOpt = Some(controlPlaneProcessor)\n      val listenerProcessors = new ArrayBuffer[Processor]()\n      listenerProcessors += controlPlaneProcessor\n      controlPlaneRequestChannelOpt.foreach(_.addProcessor(controlPlaneProcessor))"
  },
  {
    "id" : "2147ee42-e8e6-4c16-9b8c-3946d32818c5",
    "prId" : 7749,
    "prUrl" : "https://github.com/apache/kafka/pull/7749#pullrequestreview-331400714",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4ebb0f67-5956-4331-b5a6-ca1391ed57b5",
        "parentId" : null,
        "authorId" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "body" : "good to include a short reference to kip-511 in a comment here",
        "createdAt" : "2019-12-12T17:30:11Z",
        "updatedAt" : "2019-12-13T11:08:14Z",
        "lastEditedBy" : "514c0afb-8649-4fd9-a6ea-ee9e1b695274",
        "tags" : [
        ]
      }
    ],
    "commit" : "1f4dd576d146b8eb3ca2d543f3f537c506c591b7",
    "line" : 32,
    "diffHunk" : "@@ -1,1 +923,927 @@                // KIP-511: ApiVersionsRequest is intercepted here to catch the client software name\n                // and version. It is done here to avoid wiring things up to the api layer.\n                if (header.apiKey == ApiKeys.API_VERSIONS) {\n                  val apiVersionsRequest = req.body[ApiVersionsRequest]\n                  if (apiVersionsRequest.isValid) {"
  },
  {
    "id" : "d89ee682-91c2-4479-b7ff-ce7a55339b6f",
    "prId" : 8768,
    "prUrl" : "https://github.com/apache/kafka/pull/8768#pullrequestreview-430448738",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "53d92028-d81c-4f72-b370-5f42d8406617",
        "parentId" : null,
        "authorId" : "59ca7821-b29c-4f24-a9d5-cbd394145686",
        "body" : "A thread waiting here will be notified when a connection is closed (when `dec` is called). As connections in AK are long lived, couldn't we end up in a case where a connection is throttled for a longer period than the computed `trottleTimeMs` if no connection is closed in between?",
        "createdAt" : "2020-06-02T08:08:56Z",
        "updatedAt" : "2020-08-17T03:38:12Z",
        "lastEditedBy" : "59ca7821-b29c-4f24-a9d5-cbd394145686",
        "tags" : [
        ]
      },
      {
        "id" : "cc3507bd-6759-44db-b58d-771aec200ccc",
        "parentId" : "53d92028-d81c-4f72-b370-5f42d8406617",
        "authorId" : "e235ea82-83a9-41e5-8e3a-15b2e1b6f350",
        "body" : "This is exactly the behavior proposed in KIP -- if we reach any limit (number of connections or connection rate), we need to wait. So, if there is no space for a new connection, and the delay due to rate limit has passed, we would have to wait for a connection slot. However, remember that if we are waiting on an inter-broker connection slot, the broker finds and closes a connection of another listener to accommodate inter-broker connection. See KIP-402.\r\n",
        "createdAt" : "2020-06-12T00:23:42Z",
        "updatedAt" : "2020-08-17T03:38:12Z",
        "lastEditedBy" : "e235ea82-83a9-41e5-8e3a-15b2e1b6f350",
        "tags" : [
        ]
      },
      {
        "id" : "d0252ed0-2432-4d2d-a234-a47d880aace8",
        "parentId" : "53d92028-d81c-4f72-b370-5f42d8406617",
        "authorId" : "59ca7821-b29c-4f24-a9d5-cbd394145686",
        "body" : "Thanks for the clarification. I am sorry but I misread the code the first time.",
        "createdAt" : "2020-06-15T08:58:57Z",
        "updatedAt" : "2020-08-17T03:38:12Z",
        "lastEditedBy" : "59ca7821-b29c-4f24-a9d5-cbd394145686",
        "tags" : [
        ]
      }
    ],
    "commit" : "508a754f397b5a1939c44dfcba72ba996bc912c5",
    "line" : 113,
    "diffHunk" : "@@ -1,1 +1287,1291 @@        var remainingThrottleTimeMs = throttleTimeMs\n        do {\n          counts.wait(remainingThrottleTimeMs)\n          remainingThrottleTimeMs = math.max(endThrottleTimeMs - time.milliseconds, 0)\n        } while (remainingThrottleTimeMs > 0 || !connectionSlotAvailable(listenerName))"
  },
  {
    "id" : "ac2a93c6-3bb1-4c37-9679-fc4319597abf",
    "prId" : 8768,
    "prUrl" : "https://github.com/apache/kafka/pull/8768#pullrequestreview-422415324",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5346933f-db01-459c-a22e-6d4e6bfcded2",
        "parentId" : null,
        "authorId" : "59ca7821-b29c-4f24-a9d5-cbd394145686",
        "body" : "nit: I would put an empty line before declaring the method.",
        "createdAt" : "2020-06-02T08:17:46Z",
        "updatedAt" : "2020-08-17T03:38:12Z",
        "lastEditedBy" : "59ca7821-b29c-4f24-a9d5-cbd394145686",
        "tags" : [
        ]
      }
    ],
    "commit" : "508a754f397b5a1939c44dfcba72ba996bc912c5",
    "line" : 246,
    "diffHunk" : "@@ -1,1 +1440,1444 @@    }\n\n    private def maxConnectionCreationRate(configs: util.Map[String, _]): Int = {\n      Option(configs.get(KafkaConfig.MaxConnectionCreationRateProp)).map(_.toString.toInt).getOrElse(Int.MaxValue)\n    }"
  },
  {
    "id" : "ba36edc2-4376-40ee-b7b1-1707cc2531f2",
    "prId" : 8768,
    "prUrl" : "https://github.com/apache/kafka/pull/8768#pullrequestreview-448748648",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d653a814-7f02-433a-93d8-a1c92b7b3497",
        "parentId" : null,
        "authorId" : "59ca7821-b29c-4f24-a9d5-cbd394145686",
        "body" : "nit: Shall we add a javadoc to this one as well?",
        "createdAt" : "2020-07-15T08:42:48Z",
        "updatedAt" : "2020-08-17T03:38:12Z",
        "lastEditedBy" : "59ca7821-b29c-4f24-a9d5-cbd394145686",
        "tags" : [
        ]
      }
    ],
    "commit" : "508a754f397b5a1939c44dfcba72ba996bc912c5",
    "line" : 152,
    "diffHunk" : "@@ -1,1 +1345,1349 @@   * @return throttle time in milliseconds if quota got violated, otherwise 0\n   */\n  private def recordAndGetThrottleTimeMs(sensor: Sensor, timeMs: Long): Int = {\n    try {\n      sensor.record(1.0, timeMs)"
  },
  {
    "id" : "034c54be-4ded-4847-9323-166bb1defc9e",
    "prId" : 8768,
    "prUrl" : "https://github.com/apache/kafka/pull/8768#pullrequestreview-448748648",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a01fd3fa-36d3-4852-82bb-8bc3d2e8e7cd",
        "parentId" : null,
        "authorId" : "59ca7821-b29c-4f24-a9d5-cbd394145686",
        "body" : "nit: Shall we add a javadoc to this one as well?",
        "createdAt" : "2020-07-15T08:42:59Z",
        "updatedAt" : "2020-08-17T03:38:12Z",
        "lastEditedBy" : "59ca7821-b29c-4f24-a9d5-cbd394145686",
        "tags" : [
        ]
      }
    ],
    "commit" : "508a754f397b5a1939c44dfcba72ba996bc912c5",
    "line" : 181,
    "diffHunk" : "@@ -1,1 +1374,1378 @@   * Updates quota configuration for a given listener or broker-wide (if 'listenerOpt' is None)\n   */\n  private def updateConnectionRateQuota(quotaLimit: Int, listenerOpt: Option[String] = None): Unit = {\n    val metric = metrics.metric(connectionRateMetricName(listenerOpt))\n    metric.config(rateQuotaMetricConfig(quotaLimit))"
  },
  {
    "id" : "f443b2a6-a1fc-46eb-9e45-012bf415e859",
    "prId" : 9386,
    "prUrl" : "https://github.com/apache/kafka/pull/9386#pullrequestreview-515599044",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7f9b0dc1-ba77-4a09-9c77-06418fb83268",
        "parentId" : null,
        "authorId" : "59ca7821-b29c-4f24-a9d5-cbd394145686",
        "body" : "Out of curiosity, have we considered using a \"reaper\" running in a separate thread to drain the queue and close throttled connections?",
        "createdAt" : "2020-10-12T13:46:49Z",
        "updatedAt" : "2020-11-19T01:19:49Z",
        "lastEditedBy" : "59ca7821-b29c-4f24-a9d5-cbd394145686",
        "tags" : [
        ]
      },
      {
        "id" : "8cfbe1d9-7ec3-4360-989a-38cb637c4e8e",
        "parentId" : "7f9b0dc1-ba77-4a09-9c77-06418fb83268",
        "authorId" : "e400c702-fb4f-4635-8164-bc79063a89a7",
        "body" : "I did consider this. I chose to do the work of closing connections in the acceptor thread to mirror the `Processor` thread which similarly has a `openSomeConnections()`, `closeSomeConnections()` loop.\r\nDitto for `Selector.poll()`\r\n\r\nAdditionally, as a future extension, we may want to re-try accepting a connection after its throttle time expires, and adding a new reaper thread would add additional complexity for that logic.",
        "createdAt" : "2020-10-13T05:12:31Z",
        "updatedAt" : "2020-11-19T01:19:49Z",
        "lastEditedBy" : "e400c702-fb4f-4635-8164-bc79063a89a7",
        "tags" : [
        ]
      },
      {
        "id" : "8e348f0d-1765-4a67-b6d3-d304194042d0",
        "parentId" : "7f9b0dc1-ba77-4a09-9c77-06418fb83268",
        "authorId" : "59ca7821-b29c-4f24-a9d5-cbd394145686",
        "body" : "That makes sense.",
        "createdAt" : "2020-10-23T15:12:05Z",
        "updatedAt" : "2020-11-19T01:19:49Z",
        "lastEditedBy" : "59ca7821-b29c-4f24-a9d5-cbd394145686",
        "tags" : [
        ]
      }
    ],
    "commit" : "156149090a3ff4bd6394dbc8432d2747e518d1d8",
    "line" : 155,
    "diffHunk" : "@@ -1,1 +615,619 @@        try {\n          acceptNewConnections()\n          closeThrottledConnections()\n        }\n        catch {"
  },
  {
    "id" : "32fd606b-08cd-4d83-83af-a08396c27258",
    "prId" : 9386,
    "prUrl" : "https://github.com/apache/kafka/pull/9386#pullrequestreview-517969836",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ccfb37fe-5234-44d3-ad4e-3c264febe9e5",
        "parentId" : null,
        "authorId" : "59ca7821-b29c-4f24-a9d5-cbd394145686",
        "body" : "nit: Could we make this one private?",
        "createdAt" : "2020-10-23T11:59:22Z",
        "updatedAt" : "2020-11-19T01:19:49Z",
        "lastEditedBy" : "59ca7821-b29c-4f24-a9d5-cbd394145686",
        "tags" : [
        ]
      },
      {
        "id" : "2be86b88-4640-4625-a78a-3d6204f47d8a",
        "parentId" : "ccfb37fe-5234-44d3-ad4e-3c264febe9e5",
        "authorId" : "e235ea82-83a9-41e5-8e3a-15b2e1b6f350",
        "body" : "this method is also called from the derived class.",
        "createdAt" : "2020-10-27T17:29:59Z",
        "updatedAt" : "2020-11-19T01:19:49Z",
        "lastEditedBy" : "e235ea82-83a9-41e5-8e3a-15b2e1b6f350",
        "tags" : [
        ]
      }
    ],
    "commit" : "156149090a3ff4bd6394dbc8432d2747e518d1d8",
    "line" : 83,
    "diffHunk" : "@@ -1,1 +529,533 @@  }\n\n  protected def closeSocket(channel: SocketChannel): Unit = {\n    CoreUtils.swallow(channel.socket().close(), this, Level.ERROR)\n    CoreUtils.swallow(channel.close(), this, Level.ERROR)"
  },
  {
    "id" : "c9eef454-b12c-4508-9468-b66e9ecf52d0",
    "prId" : 9386,
    "prUrl" : "https://github.com/apache/kafka/pull/9386#pullrequestreview-515599044",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e636d05d-f417-440f-8b0a-3e8a6bb9be62",
        "parentId" : null,
        "authorId" : "59ca7821-b29c-4f24-a9d5-cbd394145686",
        "body" : "nit: Could we add some doc to explain this trait?",
        "createdAt" : "2020-10-23T14:29:18Z",
        "updatedAt" : "2020-11-19T01:19:49Z",
        "lastEditedBy" : "59ca7821-b29c-4f24-a9d5-cbd394145686",
        "tags" : [
        ]
      }
    ],
    "commit" : "156149090a3ff4bd6394dbc8432d2747e518d1d8",
    "line" : 261,
    "diffHunk" : "@@ -1,1 +1316,1320 @@ * broker, listener or IP level.\n */\nsealed trait ConnectionQuotaEntity {\n  def sensorName: String\n  def metricName: String"
  },
  {
    "id" : "3e26eabd-7011-42d8-a54d-922f219ae17d",
    "prId" : 9386,
    "prUrl" : "https://github.com/apache/kafka/pull/9386#pullrequestreview-528154202",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9c06a3d3-f8a3-44c7-8257-55b2bfef5c55",
        "parentId" : null,
        "authorId" : "59ca7821-b29c-4f24-a9d5-cbd394145686",
        "body" : "nit: It is a bit weird to have this case class define in the middle of the block of variables. Would it make sense to move it to another place? May be after the block of variables?",
        "createdAt" : "2020-11-11T13:06:09Z",
        "updatedAt" : "2020-11-19T01:19:49Z",
        "lastEditedBy" : "59ca7821-b29c-4f24-a9d5-cbd394145686",
        "tags" : [
        ]
      }
    ],
    "commit" : "156149090a3ff4bd6394dbc8432d2747e518d1d8",
    "line" : 107,
    "diffHunk" : "@@ -1,1 +555,559 @@  private[network] val throttledSockets = new mutable.PriorityQueue[DelayedCloseSocket]()\n\n  private[network] case class DelayedCloseSocket(socket: SocketChannel, endThrottleTimeMs: Long) extends Ordered[DelayedCloseSocket] {\n    override def compare(that: DelayedCloseSocket): Int = endThrottleTimeMs compare that.endThrottleTimeMs\n  }"
  },
  {
    "id" : "0211a231-c8e4-443f-bc89-8332d26a6e7a",
    "prId" : 9386,
    "prUrl" : "https://github.com/apache/kafka/pull/9386#pullrequestreview-528154202",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9511ead9-fa50-4cc9-8909-5845afbd4e6d",
        "parentId" : null,
        "authorId" : "59ca7821-b29c-4f24-a9d5-cbd394145686",
        "body" : "nit: We may want to clear `throttledSockets` for completeness. ",
        "createdAt" : "2020-11-11T13:10:47Z",
        "updatedAt" : "2020-11-19T01:19:49Z",
        "lastEditedBy" : "59ca7821-b29c-4f24-a9d5-cbd394145686",
        "tags" : [
        ]
      }
    ],
    "commit" : "156149090a3ff4bd6394dbc8432d2747e518d1d8",
    "line" : 167,
    "diffHunk" : "@@ -1,1 +629,633 @@      CoreUtils.swallow(serverChannel.close(), this, Level.ERROR)\n      CoreUtils.swallow(nioSelector.close(), this, Level.ERROR)\n      throttledSockets.foreach(throttledSocket => closeSocket(throttledSocket.socket))\n      throttledSockets.clear()\n      shutdownComplete()"
  },
  {
    "id" : "7affb0ca-5dc5-4922-85ad-8cb58307c34f",
    "prId" : 9386,
    "prUrl" : "https://github.com/apache/kafka/pull/9386#pullrequestreview-528154202",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d53a22b9-b602-4c76-b0cf-1765002795b8",
        "parentId" : null,
        "authorId" : "59ca7821-b29c-4f24-a9d5-cbd394145686",
        "body" : "It seems that we don't have any unit tests which exercise this un-recording logic. I wonder if we could add a unit test that verifies that the listener rate does not change when a connection is rejected due to violating the per-ip quota or something along these lines.",
        "createdAt" : "2020-11-11T16:14:41Z",
        "updatedAt" : "2020-11-19T01:19:49Z",
        "lastEditedBy" : "59ca7821-b29c-4f24-a9d5-cbd394145686",
        "tags" : [
        ]
      }
    ],
    "commit" : "156149090a3ff4bd6394dbc8432d2747e518d1d8",
    "line" : 426,
    "diffHunk" : "@@ -1,1 +1627,1631 @@        // unrecord the connection since we won't accept the connection\n        sensor.record(-1.0, timeMs, false)\n        unrecordListenerConnection(listenerName, timeMs)\n        throw new ConnectionThrottledException(address, timeMs, throttleMs)\n      }"
  },
  {
    "id" : "561a4a87-fe15-4d1b-99f6-182883c5d3fe",
    "prId" : 9386,
    "prUrl" : "https://github.com/apache/kafka/pull/9386#pullrequestreview-533269776",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e92e7a11-6631-4b67-b055-9b6d16894843",
        "parentId" : null,
        "authorId" : "59ca7821-b29c-4f24-a9d5-cbd394145686",
        "body" : "nit: Could we add an empty line after this one?",
        "createdAt" : "2020-11-18T09:48:53Z",
        "updatedAt" : "2020-11-19T01:19:49Z",
        "lastEditedBy" : "59ca7821-b29c-4f24-a9d5-cbd394145686",
        "tags" : [
        ]
      }
    ],
    "commit" : "156149090a3ff4bd6394dbc8432d2747e518d1d8",
    "line" : 345,
    "diffHunk" : "@@ -1,1 +1425,1429 @@    def shouldUpdateQuota(metric: KafkaMetric, quotaLimit: Int) = {\n      quotaLimit != metric.config.quota.bound\n    }\n\n    ip match {"
  },
  {
    "id" : "8938c0b7-e637-4618-a84c-9682aac17bd2",
    "prId" : 9386,
    "prUrl" : "https://github.com/apache/kafka/pull/9386#pullrequestreview-533269776",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c2e43439-8d54-4680-9d42-060d6bcf6a85",
        "parentId" : null,
        "authorId" : "59ca7821-b29c-4f24-a9d5-cbd394145686",
        "body" : "It would be great to add a comment here explaining why we do this. As `connectionRatePerIp` is a ConcurrentMap, it is not obvious.",
        "createdAt" : "2020-11-18T09:50:02Z",
        "updatedAt" : "2020-11-19T01:19:49Z",
        "lastEditedBy" : "59ca7821-b29c-4f24-a9d5-cbd394145686",
        "tags" : [
        ]
      }
    ],
    "commit" : "156149090a3ff4bd6394dbc8432d2747e518d1d8",
    "line" : 350,
    "diffHunk" : "@@ -1,1 +1430,1434 @@      case Some(address) =>\n        // synchronize on counts to ensure reading an IP connection rate quota and creating a quota config is atomic\n        counts.synchronized {\n          maxConnectionRate match {\n            case Some(rate) =>"
  },
  {
    "id" : "79dd55ee-2484-4eb4-a13c-117777ff8857",
    "prId" : 9386,
    "prUrl" : "https://github.com/apache/kafka/pull/9386#pullrequestreview-533269776",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1a945207-0813-4fd4-884b-0420b7f49cd5",
        "parentId" : null,
        "authorId" : "59ca7821-b29c-4f24-a9d5-cbd394145686",
        "body" : "We could also add a similar comment here.",
        "createdAt" : "2020-11-18T09:50:17Z",
        "updatedAt" : "2020-11-19T01:19:49Z",
        "lastEditedBy" : "59ca7821-b29c-4f24-a9d5-cbd394145686",
        "tags" : [
        ]
      }
    ],
    "commit" : "156149090a3ff4bd6394dbc8432d2747e518d1d8",
    "line" : 363,
    "diffHunk" : "@@ -1,1 +1443,1447 @@      case None =>\n        // synchronize on counts to ensure reading an IP connection rate quota and creating a quota config is atomic\n        counts.synchronized {\n          defaultConnectionRatePerIp = maxConnectionRate.getOrElse(DynamicConfig.Ip.DefaultConnectionCreationRate)\n        }"
  },
  {
    "id" : "53ae0c9b-6182-4e88-94fc-b19ed87667b7",
    "prId" : 9386,
    "prUrl" : "https://github.com/apache/kafka/pull/9386#pullrequestreview-534248644",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4ea1ef2f-3cf0-4a6c-9826-1b225d6b4b30",
        "parentId" : null,
        "authorId" : "59ca7821-b29c-4f24-a9d5-cbd394145686",
        "body" : "It may be better to keep IP as string in `connectionRateForIp` in order to avoid having to resolve them when we update the metrics. I don't see any reason to `InetAddress` internally. Is there any? `InetAddress.getByName` seems sufficient when we validate the configuration in the config handler.",
        "createdAt" : "2020-11-18T09:53:35Z",
        "updatedAt" : "2020-11-19T01:19:49Z",
        "lastEditedBy" : "59ca7821-b29c-4f24-a9d5-cbd394145686",
        "tags" : [
        ]
      },
      {
        "id" : "f62f0716-d317-4a2f-86cb-94136f4872bb",
        "parentId" : "4ea1ef2f-3cf0-4a6c-9826-1b225d6b4b30",
        "authorId" : "e400c702-fb4f-4635-8164-bc79063a89a7",
        "body" : "reasons for using `InetAddress` would be that it's more consistent with the other IP-related data structures in `ConnectionQuotas`, `maxConnectionsPerIpOverrides` and `counts`.\r\n\r\nadditionally, `inc()` is called with an `InetAddress`, so it's convenient to keep our data structure using `InetAddress` as a key so that we don't need to convert `InetAddress` => `String` in cases where we would not create a sensor (e.g., when IP quotas are disabled).",
        "createdAt" : "2020-11-19T01:12:13Z",
        "updatedAt" : "2020-11-19T01:19:49Z",
        "lastEditedBy" : "e400c702-fb4f-4635-8164-bc79063a89a7",
        "tags" : [
        ]
      },
      {
        "id" : "0f643cb4-b079-4129-81dc-9d41c45441ee",
        "parentId" : "4ea1ef2f-3cf0-4a6c-9826-1b225d6b4b30",
        "authorId" : "59ca7821-b29c-4f24-a9d5-cbd394145686",
        "body" : "Make sense, thanks.",
        "createdAt" : "2020-11-19T09:52:43Z",
        "updatedAt" : "2020-11-19T09:52:43Z",
        "lastEditedBy" : "59ca7821-b29c-4f24-a9d5-cbd394145686",
        "tags" : [
        ]
      }
    ],
    "commit" : "156149090a3ff4bd6394dbc8432d2747e518d1d8",
    "line" : 369,
    "diffHunk" : "@@ -1,1 +1449,1453 @@        metrics.metrics.forEach { (metricName, metric) =>\n          if (isIpConnectionRateMetric(metricName)) {\n            val quota = connectionRateForIp(InetAddress.getByName(metricName.tags.get(IpMetricTag)))\n            if (shouldUpdateQuota(metric, quota)) {\n              debug(s\"Updating existing connection rate quota config for ${metricName.tags} to $quota\")"
  },
  {
    "id" : "e96f87d0-0342-4e2f-8f6e-b2fb6af64866",
    "prId" : 9386,
    "prUrl" : "https://github.com/apache/kafka/pull/9386#pullrequestreview-534004060",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0a5e82ae-f08a-41ce-a32f-1c2e850ffb89",
        "parentId" : null,
        "authorId" : "59ca7821-b29c-4f24-a9d5-cbd394145686",
        "body" : "Could we also add a comment here which states that we don't explicitly protect this section because we hold the `counts` lock.",
        "createdAt" : "2020-11-18T09:54:39Z",
        "updatedAt" : "2020-11-19T01:19:49Z",
        "lastEditedBy" : "59ca7821-b29c-4f24-a9d5-cbd394145686",
        "tags" : [
        ]
      },
      {
        "id" : "79502fb5-f17b-4ad8-9170-ef4e05fc5182",
        "parentId" : "0a5e82ae-f08a-41ce-a32f-1c2e850ffb89",
        "authorId" : "e400c702-fb4f-4635-8164-bc79063a89a7",
        "body" : "I will add this detail to `recordIpConnectionMaybeThrottle`. I think that is a more fitting place to put the comment, since that's the section of code that calls `connectionRateForIp` and `getOrCreateConnectionRateQuotaSensor` which are the components we need to be atomic.",
        "createdAt" : "2020-11-19T01:06:50Z",
        "updatedAt" : "2020-11-19T01:19:49Z",
        "lastEditedBy" : "e400c702-fb4f-4635-8164-bc79063a89a7",
        "tags" : [
        ]
      }
    ],
    "commit" : "156149090a3ff4bd6394dbc8432d2747e518d1d8",
    "line" : 449,
    "diffHunk" : "@@ -1,1 +1659,1663 @@   */\n  private def getOrCreateConnectionRateQuotaSensor(quotaLimit: Int, connectionQuotaEntity: ConnectionQuotaEntity): Sensor = {\n    Option(metrics.getSensor(connectionQuotaEntity.sensorName)).getOrElse {\n      val sensor = metrics.sensor(\n        connectionQuotaEntity.sensorName,"
  }
]
[
  {
    "id" : "e8deedc6-699f-4bda-bc4a-d4d997dbe9bd",
    "prId" : 9418,
    "prUrl" : "https://github.com/apache/kafka/pull/9418#pullrequestreview-514197430",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f10c22ca-031b-4390-87d2-9cc299026618",
        "parentId" : null,
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "Even if the leader has changed back, previously pending appends may still get committed right? I think it is sufficient to just poll-and-drop them in `handleCommit` when leader changes and not clearing the queue here.",
        "createdAt" : "2020-10-21T00:25:44Z",
        "updatedAt" : "2020-10-27T03:04:10Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "c3d0a7ba-d622-4001-9bcd-7c34e36528be",
        "parentId" : "f10c22ca-031b-4390-87d2-9cc299026618",
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "You are right that the appends may still be committed, but in this patch, the `handleCommit` API is only invoked for appends within the current epoch. I thought it seemed simpler for now to just reset state at the start of the epoch. We can be more clever in the future once `handleCommit` is extended to account for replication.",
        "createdAt" : "2020-10-21T21:24:45Z",
        "updatedAt" : "2020-10-27T03:04:10Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      }
    ],
    "commit" : "fac5c0a9507f9f40f99dac017242d12500a97d5d",
    "line" : 161,
    "diffHunk" : "@@ -1,1 +314,318 @@        isLeader = latestLeaderAndEpoch.leaderId.orElse(-1) == brokerId\n        if (isLeader) {\n          pendingAppends.clear()\n          throttler = new ThroughputThrottler(time, recordsPerSec)\n          recordCount = 0"
  }
]
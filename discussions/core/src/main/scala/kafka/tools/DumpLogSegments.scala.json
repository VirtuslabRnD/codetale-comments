[
  {
    "id" : "01191ab8-3814-43c7-8627-40512fe44cda",
    "prId" : 4396,
    "prUrl" : "https://github.com/apache/kafka/pull/4396#pullrequestreview-87013375",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2be9bd40-4bd2-4d3d-bca0-748fa1eadec8",
        "parentId" : null,
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "Do you think we should also imply deep iteration if a message decoder is provided explicitly?",
        "createdAt" : "2018-01-05T18:32:20Z",
        "updatedAt" : "2018-02-16T18:10:42Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      },
      {
        "id" : "23afc34e-7f33-4de7-9554-fbba1673ad8a",
        "parentId" : "2be9bd40-4bd2-4d3d-bca0-748fa1eadec8",
        "authorId" : "b4936a15-698a-496e-85a1-b1e229b4986b",
        "body" : "@hachikuji `printDataLog` is already automatically set if decoders are provided. So this will enable deep iteration in that case.",
        "createdAt" : "2018-01-05T20:04:21Z",
        "updatedAt" : "2018-02-16T18:10:42Z",
        "lastEditedBy" : "b4936a15-698a-496e-85a1-b1e229b4986b",
        "tags" : [
        ]
      },
      {
        "id" : "e5683637-2c49-47fb-8250-c28fa181992d",
        "parentId" : "2be9bd40-4bd2-4d3d-bca0-748fa1eadec8",
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "Ah, you're right. I was looking for it in the logic below when constructing the message parser.",
        "createdAt" : "2018-01-05T20:20:22Z",
        "updatedAt" : "2018-02-16T18:10:42Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      }
    ],
    "commit" : "e0f67aed217859568dbb7f976530117a04c2798d",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +86,90 @@    val files = options.valueOf(filesOpt).split(\",\")\n    val maxMessageSize = options.valueOf(maxMessageSizeOpt).intValue()\n    val isDeepIteration = options.has(deepIterationOpt) || printDataLog\n\n    val messageParser = if (options.has(offsetsOpt)) {"
  },
  {
    "id" : "1dbabca5-0755-4998-8b3f-5f859d30f643",
    "prId" : 5756,
    "prUrl" : "https://github.com/apache/kafka/pull/5756#pullrequestreview-166651195",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2a0dd2f3-dcd1-424a-ba5f-4faaf0264311",
        "parentId" : null,
        "authorId" : "2d677cb0-7f58-4f02-8104-880b46eb7fb3",
        "body" : "Nit: same as before",
        "createdAt" : "2018-10-19T18:52:53Z",
        "updatedAt" : "2019-02-18T02:13:48Z",
        "lastEditedBy" : "2d677cb0-7f58-4f02-8104-880b46eb7fb3",
        "tags" : [
        ]
      }
    ],
    "commit" : "445654a846cc274a71a513d2e02401712352a74a",
    "line" : 177,
    "diffHunk" : "@@ -1,1 +179,183 @@        // since it is a sparse file, in the event of a crash there may be many zero entries, stop if we see one\n        if (entry.offset == timeIndex.baseOffset && i > 0)\n          return\n\n        val position = index.lookup(entry.offset).position"
  }
]
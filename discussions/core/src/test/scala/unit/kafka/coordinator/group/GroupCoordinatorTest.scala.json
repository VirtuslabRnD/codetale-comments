[
  {
    "id" : "f4ac4a59-8392-4739-9597-2de72efe8f50",
    "prId" : 4479,
    "prUrl" : "https://github.com/apache/kafka/pull/4479#pullrequestreview-92406080",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b4d53255-dc8b-4367-83e4-e9fc7d56b256",
        "parentId" : null,
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "We should have a test case which tests removal when there are stored offsets.",
        "createdAt" : "2018-01-29T23:23:27Z",
        "updatedAt" : "2018-01-31T19:11:21Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      },
      {
        "id" : "31ec6c4e-7788-4673-8b8c-358199ece5f2",
        "parentId" : "b4d53255-dc8b-4367-83e4-e9fc7d56b256",
        "authorId" : "2a5e5a4d-e0e2-4e26-b139-0930dd63f949",
        "body" : "I added one in the new commit.",
        "createdAt" : "2018-01-30T06:31:23Z",
        "updatedAt" : "2018-01-31T19:11:21Z",
        "lastEditedBy" : "2a5e5a4d-e0e2-4e26-b139-0930dd63f949",
        "tags" : [
        ]
      }
    ],
    "commit" : "ca60b651ee8c2c38a6122b0300504aad8d2972b9",
    "line" : 35,
    "diffHunk" : "@@ -1,1 +1295,1299 @@\n  @Test\n  def testDeleteEmptyGroup() {\n    val memberId = JoinGroupRequest.UNKNOWN_MEMBER_ID\n    val joinGroupResult = joinGroup(groupId, memberId, protocolType, protocols)"
  },
  {
    "id" : "2d51648f-96fb-443a-bb41-467c3b248dbd",
    "prId" : 5962,
    "prUrl" : "https://github.com/apache/kafka/pull/5962#pullrequestreview-180046281",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ed3f9e5e-653e-438e-8768-3bc4212438ae",
        "parentId" : null,
        "authorId" : "df911192-d6c6-4af9-8568-f67bf2dcf926",
        "body" : "This is scheduled by an executor, right? I just want to make sure this test can't be flaky",
        "createdAt" : "2018-11-29T10:41:48Z",
        "updatedAt" : "2018-12-10T18:22:26Z",
        "lastEditedBy" : "df911192-d6c6-4af9-8568-f67bf2dcf926",
        "tags" : [
        ]
      },
      {
        "id" : "9d841364-eb21-4b4a-8065-874983824f5c",
        "parentId" : "ed3f9e5e-653e-438e-8768-3bc4212438ae",
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "I think tasks run by `MockTimer` just run in the foreground. Execution should be deterministic since we rely on `MockTime` under the covers.",
        "createdAt" : "2018-11-29T22:28:41Z",
        "updatedAt" : "2018-12-10T18:22:26Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      }
    ],
    "commit" : "259f70653f00eaeec3377abc30580ca801974b78",
    "line" : 77,
    "diffHunk" : "@@ -1,1 +296,300 @@    assertNotEquals(firstMemberId, newMember.memberId)\n\n    timer.advanceClock(GroupCoordinator.NewMemberJoinTimeoutMs + 1)\n    assertTrue(responseFuture.isCompleted)\n"
  },
  {
    "id" : "e4233676-0a52-4748-a541-3cbdf1375d63",
    "prId" : 5962,
    "prUrl" : "https://github.com/apache/kafka/pull/5962#pullrequestreview-182019475",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6fd25ad7-afaf-453a-8bd2-2b05904df448",
        "parentId" : null,
        "authorId" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "body" : "Why we increase max session timeout here?",
        "createdAt" : "2018-12-05T01:22:32Z",
        "updatedAt" : "2018-12-10T18:22:26Z",
        "lastEditedBy" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "tags" : [
        ]
      },
      {
        "id" : "758eeb6c-d7f0-4867-bb81-454594cfa7f4",
        "parentId" : "6fd25ad7-afaf-453a-8bd2-2b05904df448",
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "Note this is just a test case. I needed a more reasonable value in order to verify the behavior in this patch which depends on a static timeout.",
        "createdAt" : "2018-12-05T23:13:18Z",
        "updatedAt" : "2018-12-10T18:22:26Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      }
    ],
    "commit" : "259f70653f00eaeec3377abc30580ca801974b78",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +58,62 @@  val ClientHost = \"localhost\"\n  val GroupMinSessionTimeout = 10\n  val GroupMaxSessionTimeout = 10 * 60 * 1000\n  val DefaultRebalanceTimeout = 500\n  val DefaultSessionTimeout = 500"
  },
  {
    "id" : "defa4524-1d43-41d1-b20b-e191505c8abf",
    "prId" : 6058,
    "prUrl" : "https://github.com/apache/kafka/pull/6058#pullrequestreview-188194279",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "139632f1-6c40-4703-9815-837e28c2d443",
        "parentId" : null,
        "authorId" : "df911192-d6c6-4af9-8568-f67bf2dcf926",
        "body" : "In this case, would a third request with the correct protocol finish the join? Maybe it wouldn't hurt to test that as well",
        "createdAt" : "2018-12-26T09:09:43Z",
        "updatedAt" : "2019-01-15T03:26:21Z",
        "lastEditedBy" : "df911192-d6c6-4af9-8568-f67bf2dcf926",
        "tags" : [
        ]
      },
      {
        "id" : "7b88aca1-450f-4c08-8635-49f37d3ed354",
        "parentId" : "139632f1-6c40-4703-9815-837e28c2d443",
        "authorId" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "body" : "Sounds good!",
        "createdAt" : "2018-12-27T23:32:25Z",
        "updatedAt" : "2019-01-15T03:26:21Z",
        "lastEditedBy" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "tags" : [
        ]
      }
    ],
    "commit" : "29f668ef1a9b2ee5939791b9bd5b89bf1a1660bb",
    "line" : 53,
    "diffHunk" : "@@ -1,1 +357,361 @@    responseFuture = sendJoinGroup(groupId, memberId, protocolType, List(), requireKnownMemberId = true)\n    joinGroupResult = Await.result(responseFuture, Duration(DefaultRebalanceTimeout + 1, TimeUnit.MILLISECONDS))\n    assertEquals(Errors.INCONSISTENT_GROUP_PROTOCOL, joinGroupResult.error)\n\n    // Sending consistent protocol shall be accepted"
  },
  {
    "id" : "8b95acb4-21c3-4d0b-8d25-af40b398939e",
    "prId" : 6058,
    "prUrl" : "https://github.com/apache/kafka/pull/6058#pullrequestreview-188196463",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4ac3ca03-1091-45c4-9f0e-9e6f65743b81",
        "parentId" : null,
        "authorId" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "body" : "@hachikuji This is the part that I tested the new logic.",
        "createdAt" : "2018-12-27T23:58:41Z",
        "updatedAt" : "2019-01-15T03:26:21Z",
        "lastEditedBy" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "tags" : [
        ]
      }
    ],
    "commit" : "29f668ef1a9b2ee5939791b9bd5b89bf1a1660bb",
    "line" : 120,
    "diffHunk" : "@@ -1,1 +1717,1721 @@                        rebalanceTimeout: Int = DefaultRebalanceTimeout): JoinGroupResult = {\n    val requireKnownMemberId = true\n    var responseFuture = sendJoinGroup(groupId, memberId, protocolType, protocols, sessionTimeout, rebalanceTimeout, requireKnownMemberId)\n\n    // Since member id is required, we need another bounce to get the successful join group result."
  },
  {
    "id" : "64584f5f-6c4c-4bba-a8eb-5d3fce7f548f",
    "prId" : 6163,
    "prUrl" : "https://github.com/apache/kafka/pull/6163#pullrequestreview-195345542",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "db25fd0a-d2d5-4e10-9f33-79cef37058ec",
        "parentId" : null,
        "authorId" : "979e3650-ce20-4720-a0da-e44d283b558b",
        "body" : "seems to be consistently failing for me with: \r\njava.util.concurrent.TimeoutException: Futures timed out after [1 millisecond]",
        "createdAt" : "2019-01-17T22:01:51Z",
        "updatedAt" : "2019-02-01T23:36:21Z",
        "lastEditedBy" : "979e3650-ce20-4720-a0da-e44d283b558b",
        "tags" : [
        ]
      },
      {
        "id" : "93815b02-8a05-4dab-a358-04b9390a2ce1",
        "parentId" : "db25fd0a-d2d5-4e10-9f33-79cef37058ec",
        "authorId" : "2a5e5a4d-e0e2-4e26-b139-0930dd63f949",
        "body" : "I do not see any failures. Passed 100/100. ",
        "createdAt" : "2019-01-20T07:32:38Z",
        "updatedAt" : "2019-02-01T23:36:21Z",
        "lastEditedBy" : "2a5e5a4d-e0e2-4e26-b139-0930dd63f949",
        "tags" : [
        ]
      },
      {
        "id" : "6be9e048-d538-4b15-b205-fa8d938043e9",
        "parentId" : "db25fd0a-d2d5-4e10-9f33-79cef37058ec",
        "authorId" : "2a5e5a4d-e0e2-4e26-b139-0930dd63f949",
        "body" : "This is now failing for me too.",
        "createdAt" : "2019-01-23T05:55:05Z",
        "updatedAt" : "2019-02-01T23:36:21Z",
        "lastEditedBy" : "2a5e5a4d-e0e2-4e26-b139-0930dd63f949",
        "tags" : [
        ]
      }
    ],
    "commit" : "1421a43a3fcf28c99477bea7a1499a8fa17e50d9",
    "line" : 29,
    "diffHunk" : "@@ -1,1 +195,199 @@\n  @Test\n  def testJoinGroupShouldReceiveErrorIfGroupOverMaxSize() {\n    var futures = ArrayBuffer[Future[JoinGroupResult]]()\n    val rebalanceTimeout = GroupInitialRebalanceDelay * 2"
  },
  {
    "id" : "ead6f443-0f88-42b8-88da-b9262c3c31d9",
    "prId" : 6251,
    "prUrl" : "https://github.com/apache/kafka/pull/6251#pullrequestreview-204539037",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0fb6c08f-b804-462c-be3a-1b51600a53b8",
        "parentId" : null,
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "A brief comment describing the test scenario would be helpful since these tests are complicated.",
        "createdAt" : "2019-02-16T18:51:17Z",
        "updatedAt" : "2019-02-19T06:13:25Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      },
      {
        "id" : "03d87900-8d09-488b-a7d9-a8d21b99f1bb",
        "parentId" : "0fb6c08f-b804-462c-be3a-1b51600a53b8",
        "authorId" : "1462ba0d-5f6b-4517-98de-68943d892c2b",
        "body" : "comment added above.",
        "createdAt" : "2019-02-16T23:39:53Z",
        "updatedAt" : "2019-02-19T06:13:25Z",
        "lastEditedBy" : "1462ba0d-5f6b-4517-98de-68943d892c2b",
        "tags" : [
        ]
      }
    ],
    "commit" : "2102b7c04ffb64ba163904304f9ee7fb9dab3432",
    "line" : 11,
    "diffHunk" : "@@ -1,1 +796,800 @@    */\n  @Test\n  def testSecondMemberPartiallyJoinAndTimeout() {\n    val firstJoinResult = joinGroup(groupId, JoinGroupRequest.UNKNOWN_MEMBER_ID, protocolType, protocols)\n    val firstMemberId = firstJoinResult.memberId"
  },
  {
    "id" : "d2605a41-1539-4704-b6db-edc7a3c27205",
    "prId" : 6251,
    "prUrl" : "https://github.com/apache/kafka/pull/6251#pullrequestreview-204544798",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bffd1283-0c08-43aa-977d-dbf00d82db2a",
        "parentId" : null,
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "nit: it's conventional to handle `Some` first.",
        "createdAt" : "2019-02-17T00:25:33Z",
        "updatedAt" : "2019-02-19T06:13:25Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      },
      {
        "id" : "4f5ea02b-30d3-4d51-853e-ee6f159f8a30",
        "parentId" : "bffd1283-0c08-43aa-977d-dbf00d82db2a",
        "authorId" : "1462ba0d-5f6b-4517-98de-68943d892c2b",
        "body" : "done.",
        "createdAt" : "2019-02-17T04:17:19Z",
        "updatedAt" : "2019-02-19T06:13:25Z",
        "lastEditedBy" : "1462ba0d-5f6b-4517-98de-68943d892c2b",
        "tags" : [
        ]
      }
    ],
    "commit" : "2102b7c04ffb64ba163904304f9ee7fb9dab3432",
    "line" : 175,
    "diffHunk" : "@@ -1,1 +960,964 @@                               groupState: GroupState): Unit = {\n    groupCoordinator.groupManager.getGroup(groupId) match {\n      case Some(group) => assertEquals(groupState, group.currentState)\n      case None => fail(s\"Group $groupId not found in coordinator\")\n    }"
  },
  {
    "id" : "c0fea5d6-c30b-4ade-b683-69885734a59e",
    "prId" : 6251,
    "prUrl" : "https://github.com/apache/kafka/pull/6251#pullrequestreview-204574718",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "762ba6bb-f4c8-4fc6-8ad7-635cd8d0f76d",
        "parentId" : null,
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "I think this test is good now. I verified that it fails without the fix in `onExpireHeartbeat`. The other case that is worth having a test for is if the pending member successfully rejoins. Similarly we should see the group transition to `CompletingRebalance`. The test cases will be mostly the same. The only difference is whether we advance the clock and expire or rejoin the pending member, so it might be possible to factor out the rest of the logic.",
        "createdAt" : "2019-02-17T17:41:31Z",
        "updatedAt" : "2019-02-19T06:13:25Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      },
      {
        "id" : "cc860b2b-00d5-432f-be09-5ff0a65d90ef",
        "parentId" : "762ba6bb-f4c8-4fc6-8ad7-635cd8d0f76d",
        "authorId" : "1462ba0d-5f6b-4517-98de-68943d892c2b",
        "body" : "addressed this comment, @hachikuji. let me know what you think. ",
        "createdAt" : "2019-02-17T18:53:36Z",
        "updatedAt" : "2019-02-19T06:13:25Z",
        "lastEditedBy" : "1462ba0d-5f6b-4517-98de-68943d892c2b",
        "tags" : [
        ]
      }
    ],
    "commit" : "2102b7c04ffb64ba163904304f9ee7fb9dab3432",
    "line" : 147,
    "diffHunk" : "@@ -1,1 +932,936 @@    timer.advanceClock(120)\n\n    assertGroupState(groupState = CompletingRebalance)\n    assertEquals(2, group().allMembers.size)\n    assertEquals(0, group().numPending)"
  },
  {
    "id" : "03245567-ef05-4c2a-aa26-e2cd5e81dd97",
    "prId" : 6666,
    "prUrl" : "https://github.com/apache/kafka/pull/6666#pullrequestreview-237433635",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6c7121bd-bef2-45ee-974c-af9df7313c4a",
        "parentId" : null,
        "authorId" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "body" : "@hachikuji This test case covers the case where all static members are not joined but haven't session timeout yet. No new generation shall be bumped.\r\n",
        "createdAt" : "2019-05-14T18:44:41Z",
        "updatedAt" : "2019-05-16T01:44:15Z",
        "lastEditedBy" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "tags" : [
        ]
      }
    ],
    "commit" : "16de0b4222e65788435f0ffdb2c0bc8c3b32e74d",
    "line" : 99,
    "diffHunk" : "@@ -1,1 +790,794 @@\n    timer.advanceClock(DefaultRebalanceTimeout + 1)\n    // Only static leader is maintained, and group is stuck at PreparingRebalance stage\n    assertEquals(1, getGroup(groupId).allMembers.size)\n    assertEquals(Set(rebalanceResult.leaderId), getGroup(groupId).allMembers)"
  },
  {
    "id" : "b7a1d530-4f26-41f5-b6e6-7d27101ef745",
    "prId" : 6666,
    "prUrl" : "https://github.com/apache/kafka/pull/6666#pullrequestreview-238127269",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6f623ca2-9cce-4870-8b35-70e255844abe",
        "parentId" : null,
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "Should we assert that the number of members is 1?",
        "createdAt" : "2019-05-15T23:54:20Z",
        "updatedAt" : "2019-05-16T01:44:15Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      },
      {
        "id" : "b1380f3c-9194-4994-afda-50cb9738d10f",
        "parentId" : "6f623ca2-9cce-4870-8b35-70e255844abe",
        "authorId" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "body" : "Sounds good",
        "createdAt" : "2019-05-16T00:07:18Z",
        "updatedAt" : "2019-05-16T01:44:15Z",
        "lastEditedBy" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "tags" : [
        ]
      }
    ],
    "commit" : "16de0b4222e65788435f0ffdb2c0bc8c3b32e74d",
    "line" : 101,
    "diffHunk" : "@@ -1,1 +792,796 @@    // Only static leader is maintained, and group is stuck at PreparingRebalance stage\n    assertEquals(1, getGroup(groupId).allMembers.size)\n    assertEquals(Set(rebalanceResult.leaderId), getGroup(groupId).allMembers)\n    assertEquals(2, getGroup(groupId).generationId)\n    assertGroupState(groupState = PreparingRebalance)"
  },
  {
    "id" : "a6510cbf-b014-49e9-9c07-410856caec6e",
    "prId" : 6666,
    "prUrl" : "https://github.com/apache/kafka/pull/6666#pullrequestreview-239072103",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "11fc74fb-cf4e-4f42-9d95-c0fd1f2dcb3a",
        "parentId" : null,
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "Not clear why we want to override to half of the value?",
        "createdAt" : "2019-05-17T18:16:24Z",
        "updatedAt" : "2019-05-17T18:19:30Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "09feca65-d75a-45b9-aae7-34206fe09e57",
        "parentId" : "11fc74fb-cf4e-4f42-9d95-c0fd1f2dcb3a",
        "authorId" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "body" : "We are just trying to make sure we timeout the follower instance because default session timeout = default rebalance timeout",
        "createdAt" : "2019-05-17T18:25:41Z",
        "updatedAt" : "2019-05-17T18:25:42Z",
        "lastEditedBy" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "tags" : [
        ]
      }
    ],
    "commit" : "16de0b4222e65788435f0ffdb2c0bc8c3b32e74d",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +481,485 @@  @Test\n  def staticMemberRejoinWithLeaderIdAndKnownMemberId() {\n    val rebalanceResult = staticMembersJoinAndRebalance(leaderInstanceId, followerInstanceId, sessionTimeout = DefaultRebalanceTimeout / 2)\n\n    // A static leader with known id rejoin will trigger rebalance."
  },
  {
    "id" : "12eb2ff6-3572-4cb4-9e4a-f81f0647e4ab",
    "prId" : 6666,
    "prUrl" : "https://github.com/apache/kafka/pull/6666#pullrequestreview-239072470",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a0512897-40ac-434b-8dd9-4c00ef818d1e",
        "parentId" : null,
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "Ditto, why double the value here?",
        "createdAt" : "2019-05-17T18:16:51Z",
        "updatedAt" : "2019-05-17T18:19:30Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "b9a281a8-84c6-4f42-9d2b-5c47bebbaa41",
        "parentId" : "a0512897-40ac-434b-8dd9-4c00ef818d1e",
        "authorId" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "body" : "Doubling is aiming to reproduce the scenario where `rebalanceTImeout` < `sessionTimeout`. I could write comments for both scenarios.",
        "createdAt" : "2019-05-17T18:26:32Z",
        "updatedAt" : "2019-05-17T18:26:32Z",
        "lastEditedBy" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "tags" : [
        ]
      }
    ],
    "commit" : "16de0b4222e65788435f0ffdb2c0bc8c3b32e74d",
    "line" : 19,
    "diffHunk" : "@@ -1,1 +523,527 @@  @Test\n  def staticMemberRejoinWithFollowerIdAndChangeOfProtocol() {\n    val rebalanceResult = staticMembersJoinAndRebalance(leaderInstanceId, followerInstanceId, sessionTimeout = DefaultSessionTimeout * 2)\n\n    // A static follower rejoin with changed protocol will trigger rebalance."
  },
  {
    "id" : "3fec073c-e82e-4879-8790-271a233a0c05",
    "prId" : 6666,
    "prUrl" : "https://github.com/apache/kafka/pull/6666#pullrequestreview-239064735",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e93eb5f1-e74f-4258-8214-d8404f534845",
        "parentId" : null,
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "Thanks for adding these two test cases for improving the coverage!",
        "createdAt" : "2019-05-17T18:18:05Z",
        "updatedAt" : "2019-05-17T18:19:30Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      }
    ],
    "commit" : "16de0b4222e65788435f0ffdb2c0bc8c3b32e74d",
    "line" : 107,
    "diffHunk" : "@@ -1,1 +798,802 @@\n  @Test\n  def testStaticMemberFollowerFailToRejoinBeforeRebalanceTimeout() {\n    // Increase session timeout so that the follower won't be evicted when rebalance timeout is reached.\n    val initialRebalanceResult = staticMembersJoinAndRebalance(leaderInstanceId, followerInstanceId, sessionTimeout = DefaultRebalanceTimeout * 2)"
  },
  {
    "id" : "ef8aedf0-89e0-40b9-86fd-fd4a735fbbd6",
    "prId" : 6666,
    "prUrl" : "https://github.com/apache/kafka/pull/6666#pullrequestreview-239064735",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "45bf7544-d245-4a75-9740-a0fa34b75aa4",
        "parentId" : null,
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "Nice refactoring.",
        "createdAt" : "2019-05-17T18:18:50Z",
        "updatedAt" : "2019-05-17T18:19:30Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      }
    ],
    "commit" : "16de0b4222e65788435f0ffdb2c0bc8c3b32e74d",
    "line" : 233,
    "diffHunk" : "@@ -1,1 +1175,1179 @@\n    // send a couple heartbeats to keep the member alive while the rebalance finishes\n    var expectedResultList = List(Errors.REBALANCE_IN_PROGRESS, Errors.REBALANCE_IN_PROGRESS)\n    for (expectedResult <- expectedResultList) {\n      timer.advanceClock(otherMemberSessionTimeout)"
  },
  {
    "id" : "e5e5752a-1a3a-4ec8-815c-606cd9ea88ac",
    "prId" : 6899,
    "prUrl" : "https://github.com/apache/kafka/pull/6899#pullrequestreview-247825464",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c315a17b-0a11-4f9f-af4a-90427877a299",
        "parentId" : null,
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "+1.",
        "createdAt" : "2019-06-10T20:25:33Z",
        "updatedAt" : "2019-06-12T04:56:07Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      }
    ],
    "commit" : "d3d2900439cab3b6134ba74dab5d231c1380edb6",
    "line" : 222,
    "diffHunk" : "@@ -1,1 +745,749 @@    // Rebalance complete immediately after follower rejoin.\n    EasyMock.reset(replicaManager)\n    val followerRejoinWithFuture = sendJoinGroup(groupId, rebalanceResult.followerId, protocolType, protocolSuperset, followerInstanceId)\n\n    timer.advanceClock(1)"
  },
  {
    "id" : "7b53f2cf-9786-4d8e-8f1b-d8d57673eec3",
    "prId" : 6899,
    "prUrl" : "https://github.com/apache/kafka/pull/6899#pullrequestreview-247825464",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f4945363-b6ab-4dd7-bd2b-47b10410f9e7",
        "parentId" : null,
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "Good catch.",
        "createdAt" : "2019-06-10T20:26:19Z",
        "updatedAt" : "2019-06-12T04:56:07Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      }
    ],
    "commit" : "d3d2900439cab3b6134ba74dab5d231c1380edb6",
    "line" : 240,
    "diffHunk" : "@@ -1,1 +1148,1152 @@                                   expectedLeaderId: String = JoinGroupRequest.UNKNOWN_MEMBER_ID,\n                                   expectedMemberId: String = JoinGroupRequest.UNKNOWN_MEMBER_ID) {\n    assertEquals(expectedError, joinGroupResult.error)\n    assertEquals(expectedGeneration, joinGroupResult.generationId)\n    assertEquals(expectedGroupInstanceIds.size, joinGroupResult.members.size)"
  },
  {
    "id" : "c28e2e31-0595-451b-8bb4-c5bb74f0261e",
    "prId" : 7377,
    "prUrl" : "https://github.com/apache/kafka/pull/7377#pullrequestreview-293282340",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7f3a2e2d-d1e3-48d1-92ec-9d201f4531fa",
        "parentId" : null,
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "Could we also have a test case for the scenario where tryComplete is called for the heartbeat of a member that was already removed from the group?",
        "createdAt" : "2019-09-25T18:41:55Z",
        "updatedAt" : "2019-09-26T18:21:04Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      }
    ],
    "commit" : "f9294499a7f7e226b91c5a51b13fc6bf1978df34",
    "line" : 24,
    "diffHunk" : "@@ -1,1 +2890,2894 @@\n  @Test\n  def testCompleteHeartbeatWithGroupDead(): Unit = {\n    val rebalanceResult = staticMembersJoinAndRebalance(leaderInstanceId, followerInstanceId)\n    EasyMock.reset(replicaManager)"
  },
  {
    "id" : "722ee005-d744-41db-bf76-be649d0f4655",
    "prId" : 7753,
    "prUrl" : "https://github.com/apache/kafka/pull/7753#pullrequestreview-335039445",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "56503e04-bd52-4127-9189-b9c79f2b13db",
        "parentId" : null,
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "Might be worth asserting `latestHeartbeat` as well?",
        "createdAt" : "2019-12-20T02:31:52Z",
        "updatedAt" : "2019-12-20T22:44:34Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      }
    ],
    "commit" : "69477f8f5aa319bcf6993b9bb6f35babcd5eb14b",
    "line" : 16,
    "diffHunk" : "@@ -1,1 +326,330 @@\n    assertEquals(Errors.NONE, joinResult.error)\n    assertEquals(0, group.allMemberMetadata.count(_.isNew))\n\n    EasyMock.reset(replicaManager)"
  },
  {
    "id" : "bb3b3452-c731-4533-b55f-ed83ad0ab78f",
    "prId" : 7878,
    "prUrl" : "https://github.com/apache/kafka/pull/7878#pullrequestreview-341466560",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "132f6752-0237-4b10-9014-bcdab2a23496",
        "parentId" : null,
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "This is only a negative test, ie, test ABORT case. Can we duplicate this test and let the transaction `COMMIT` and verify that the committed offset is returned afterwards?",
        "createdAt" : "2020-01-10T19:31:15Z",
        "updatedAt" : "2020-01-14T03:19:53Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "68217127-6097-4424-907c-50284553750b",
        "parentId" : "132f6752-0237-4b10-9014-bcdab2a23496",
        "authorId" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "body" : "Good catch!",
        "createdAt" : "2020-01-10T23:01:34Z",
        "updatedAt" : "2020-01-14T03:19:53Z",
        "lastEditedBy" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "tags" : [
        ]
      }
    ],
    "commit" : "444fc571446e41ecc8941df7df2de8ef936d73c0",
    "line" : 107,
    "diffHunk" : "@@ -1,1 +2214,2218 @@    assertEquals(Errors.NONE, secondReqError)\n    assertEquals(Some(OffsetFetchResponse.INVALID_OFFSET), secondReqPartitionData.get(tp).map(_.offset))\n    assertEquals(Some(Errors.NONE), secondReqPartitionData.get(tp).map(_.error))\n  }\n"
  },
  {
    "id" : "6dd26697-3a4d-4be6-8597-b90d72646e10",
    "prId" : 7897,
    "prUrl" : "https://github.com/apache/kafka/pull/7897#pullrequestreview-338382552",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1794cbeb-b722-4a08-8b0d-fb3aa6cf4c95",
        "parentId" : null,
        "authorId" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "body" : "By adding reset in the end of helper function, we reduced redundant replica manager reset.",
        "createdAt" : "2020-01-05T06:14:08Z",
        "updatedAt" : "2020-01-14T20:20:27Z",
        "lastEditedBy" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "tags" : [
        ]
      }
    ],
    "commit" : "943bdf3604b662dfd20e7cfd586ada10e3412bc8",
    "line" : 182,
    "diffHunk" : "@@ -1,1 +1203,1207 @@    assertTrue(getGroup(groupId).is(Stable))\n\n    EasyMock.reset(replicaManager)\n    new RebalanceResult(newGeneration,\n      leaderId,"
  },
  {
    "id" : "ce436056-c2f3-4810-b220-f8c0b3b39d17",
    "prId" : 7897,
    "prUrl" : "https://github.com/apache/kafka/pull/7897#pullrequestreview-341500912",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d2131399-d377-45c8-a1e9-6c63507fe8c3",
        "parentId" : null,
        "authorId" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "body" : "Why reset the replica manager mock here?",
        "createdAt" : "2020-01-11T00:09:05Z",
        "updatedAt" : "2020-01-14T20:20:27Z",
        "lastEditedBy" : "eba565e8-e1d5-4749-9c9a-5d117de6c96c",
        "tags" : [
        ]
      },
      {
        "id" : "23b6e0c6-cff1-4148-9cb2-f68b2cf7174b",
        "parentId" : "d2131399-d377-45c8-a1e9-6c63507fe8c3",
        "authorId" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "body" : "As we have used dynamicJoinGroup IIUC",
        "createdAt" : "2020-01-11T03:24:53Z",
        "updatedAt" : "2020-01-14T20:20:27Z",
        "lastEditedBy" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "tags" : [
        ]
      }
    ],
    "commit" : "943bdf3604b662dfd20e7cfd586ada10e3412bc8",
    "line" : 245,
    "diffHunk" : "@@ -1,1 +2535,2539 @@    assertEquals(Errors.NONE, joinGroupError)\n\n    EasyMock.reset(replicaManager)\n\n    val assignedConsumerId = joinGroupResult.memberId"
  },
  {
    "id" : "46d769bc-e9df-473b-a10b-86f7a477248f",
    "prId" : 7897,
    "prUrl" : "https://github.com/apache/kafka/pull/7897#pullrequestreview-342959542",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "19343050-8d6f-4590-b317-77e4eec53922",
        "parentId" : null,
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "I am not sure if I understand this test. (1) why do we test with a static member? Fencing could also happen for non-static members now? (2) Why does the member get fenced at all (it seems that `staticMembersJoinAndRebalance` should successfully add two members to the consumer group?) (3) Why do we no pass a `groupInstanceId` into `commitTransactionalOffsets()` on the first call, as we use static group membership? ",
        "createdAt" : "2020-01-14T23:06:38Z",
        "updatedAt" : "2020-01-14T23:13:52Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "7cef8b7a-42c8-4fdf-a96a-b43db6f51c11",
        "parentId" : "19343050-8d6f-4590-b317-77e4eec53922",
        "authorId" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "body" : "I will make this test more explicit by adding the definition for member.id. It basically tries to test out that static membership fencing is working properly, as the leader instance is already registered, and the txn commit call with leader.instance.id is not actually using a correct member.id: either empty or invalid ",
        "createdAt" : "2020-01-15T02:35:46Z",
        "updatedAt" : "2020-01-15T02:37:17Z",
        "lastEditedBy" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "tags" : [
        ]
      }
    ],
    "commit" : "943bdf3604b662dfd20e7cfd586ada10e3412bc8",
    "line" : 191,
    "diffHunk" : "@@ -1,1 +2481,2485 @@\n  @Test\n  def testTxnCommitOffsetWithFencedInstanceId(): Unit = {\n    val tp = new TopicPartition(\"topic\", 0)\n    val offset = offsetAndMetadata(0)"
  },
  {
    "id" : "45c62acc-d8cf-4ef7-aecc-c2759be0ad02",
    "prId" : 7897,
    "prUrl" : "https://github.com/apache/kafka/pull/7897#pullrequestreview-342973941",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "45e8a0bb-59e9-4553-80e2-6f1aabb210ca",
        "parentId" : null,
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "Why do we pass `Option.empty` -- isn't this the default anyway?",
        "createdAt" : "2020-01-14T23:08:54Z",
        "updatedAt" : "2020-01-14T23:13:52Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "6478ab66-6b5b-44ba-9030-908f6cb3e25e",
        "parentId" : "45e8a0bb-59e9-4553-80e2-6f1aabb210ca",
        "authorId" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "body" : "No, we don't need to, will address that.",
        "createdAt" : "2020-01-15T03:39:52Z",
        "updatedAt" : "2020-01-15T03:40:03Z",
        "lastEditedBy" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "tags" : [
        ]
      }
    ],
    "commit" : "943bdf3604b662dfd20e7cfd586ada10e3412bc8",
    "line" : 221,
    "diffHunk" : "@@ -1,1 +2511,2515 @@    EasyMock.reset(replicaManager)\n    val invalidIdCommitOffsetResult = commitTransactionalOffsets(groupId, producerId, producerEpoch,\n      Map(tp -> offset), \"invalid-member\", Option.empty)\n    assertEquals(Errors.UNKNOWN_MEMBER_ID, invalidIdCommitOffsetResult (tp))\n"
  },
  {
    "id" : "ad9ef827-9644-4869-af1a-87e86bd38c66",
    "prId" : 7897,
    "prUrl" : "https://github.com/apache/kafka/pull/7897#pullrequestreview-342974282",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4052e26e-6cba-4ff8-8b0f-24c3f83dbde7",
        "parentId" : null,
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "This should be it's own test -- it test backward compatibility for older clients if I read it correctly.",
        "createdAt" : "2020-01-14T23:10:54Z",
        "updatedAt" : "2020-01-14T23:13:52Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "0ce4faee-673b-48e1-8d02-43337de58674",
        "parentId" : "4052e26e-6cba-4ff8-8b0f-24c3f83dbde7",
        "authorId" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "body" : "Actually I think this is safe to be removed, as other test cases who don't use member.id is covering this case.",
        "createdAt" : "2020-01-15T03:41:29Z",
        "updatedAt" : "2020-01-15T03:41:30Z",
        "lastEditedBy" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "tags" : [
        ]
      }
    ],
    "commit" : "943bdf3604b662dfd20e7cfd586ada10e3412bc8",
    "line" : 226,
    "diffHunk" : "@@ -1,1 +2516,2520 @@    val unknownMemberIdCommitOffsetResult = commitTransactionalOffsets(groupId, producerId, producerEpoch,\n      Map(tp -> offset), JoinGroupRequest.UNKNOWN_MEMBER_ID, Option.empty)\n    assertEquals(Errors.NONE, unknownMemberIdCommitOffsetResult (tp))\n\n    val assignedConsumerId = joinGroupResult.memberId"
  },
  {
    "id" : "37557b9f-4e5d-4bb7-9da8-1e52963d60b9",
    "prId" : 7897,
    "prUrl" : "https://github.com/apache/kafka/pull/7897#pullrequestreview-342974451",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8b996c32-c630-4673-8042-a301363bf5ca",
        "parentId" : null,
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "This should be it's own test -- the test name says `WithUnknownMemberId` but this test passes a known memberId",
        "createdAt" : "2020-01-14T23:11:53Z",
        "updatedAt" : "2020-01-14T23:13:52Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "3ce4599d-76aa-43c6-a9ed-185a790df397",
        "parentId" : "8b996c32-c630-4673-8042-a301363bf5ca",
        "authorId" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "body" : "Will do",
        "createdAt" : "2020-01-15T03:42:18Z",
        "updatedAt" : "2020-01-15T03:42:18Z",
        "lastEditedBy" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "tags" : [
        ]
      }
    ],
    "commit" : "943bdf3604b662dfd20e7cfd586ada10e3412bc8",
    "line" : 231,
    "diffHunk" : "@@ -1,1 +2521,2525 @@    val leaderCommitOffsetResult = commitTransactionalOffsets(groupId, producerId, producerEpoch,\n      Map(tp -> offset), assignedConsumerId, Option.empty)\n    assertEquals(Errors.NONE, leaderCommitOffsetResult (tp))\n  }\n"
  },
  {
    "id" : "2e20e5d1-81aa-4409-8830-a7171b5e5fc8",
    "prId" : 7897,
    "prUrl" : "https://github.com/apache/kafka/pull/7897#pullrequestreview-342974539",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4109e38d-adcc-4f3a-b7bb-f4ec2d34fd5a",
        "parentId" : null,
        "authorId" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "body" : "The test name says `WithIllegalGeneration` -- but this is a positive test using the correct generationId -- should be two tests.",
        "createdAt" : "2020-01-14T23:13:09Z",
        "updatedAt" : "2020-01-14T23:13:52Z",
        "lastEditedBy" : "9baadc38-cd41-4762-be0c-791258ced78c",
        "tags" : [
        ]
      },
      {
        "id" : "771a6162-ca8b-42d4-b32e-5b88cc806122",
        "parentId" : "4109e38d-adcc-4f3a-b7bb-f4ec2d34fd5a",
        "authorId" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "body" : "Will do",
        "createdAt" : "2020-01-15T03:42:42Z",
        "updatedAt" : "2020-01-15T03:42:42Z",
        "lastEditedBy" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "tags" : [
        ]
      }
    ],
    "commit" : "943bdf3604b662dfd20e7cfd586ada10e3412bc8",
    "line" : 251,
    "diffHunk" : "@@ -1,1 +2541,2545 @@    val leaderCommitOffsetResult = commitTransactionalOffsets(groupId, producerId, producerEpoch,\n      Map(tp -> offset), assignedConsumerId, Option.empty, initialGenerationId)\n    assertEquals(Errors.NONE, leaderCommitOffsetResult (tp))\n\n    val illegalGenerationCommitOffsetResult = commitTransactionalOffsets(groupId, producerId, producerEpoch,"
  },
  {
    "id" : "50f6ba9b-da8a-4815-bfc2-e19b5f75756c",
    "prId" : 7952,
    "prUrl" : "https://github.com/apache/kafka/pull/7952#pullrequestreview-342977007",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b8d22dce-60f2-4188-87c7-6a313db6d04c",
        "parentId" : null,
        "authorId" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "body" : "Addressing https://github.com/apache/kafka/pull/7897#discussion_r366620076",
        "createdAt" : "2020-01-15T03:54:37Z",
        "updatedAt" : "2020-01-22T18:43:33Z",
        "lastEditedBy" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "tags" : [
        ]
      }
    ],
    "commit" : "e81e0daaec396ec5be7cc3d3cc2adae42f242e95",
    "line" : 26,
    "diffHunk" : "@@ -1,1 +2493,2497 @@    assertEquals(Errors.FENCED_INSTANCE_ID, leaderNoMemberIdCommitOffsetResult (tp))\n\n    val leaderInvalidMemberIdCommitOffsetResult = commitTransactionalOffsets(groupId, producerId, producerEpoch,\n      Map(tp -> offset), memberId = \"invalid-member\", groupInstanceId = leaderInstanceId)\n    assertEquals(Errors.FENCED_INSTANCE_ID, leaderInvalidMemberIdCommitOffsetResult (tp))"
  },
  {
    "id" : "3b20dcd0-9b24-4c14-8a6b-de275bd369d0",
    "prId" : 7952,
    "prUrl" : "https://github.com/apache/kafka/pull/7952#pullrequestreview-342977112",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "61f156ac-3b19-42fc-8eb9-2308b97e4cdb",
        "parentId" : null,
        "authorId" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "body" : "This and the following new tests are addressing the comments for separating valid and invalid scenario: https://github.com/apache/kafka/pull/7897#discussion_r366621880",
        "createdAt" : "2020-01-15T03:55:10Z",
        "updatedAt" : "2020-01-22T18:43:33Z",
        "lastEditedBy" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "tags" : [
        ]
      }
    ],
    "commit" : "e81e0daaec396ec5be7cc3d3cc2adae42f242e95",
    "line" : 37,
    "diffHunk" : "@@ -1,1 +2503,2507 @@\n  @Test\n  def testTxnCommitOffsetWithInvalidMemberId(): Unit = {\n    val tp = new TopicPartition(\"topic\", 0)\n    val offset = offsetAndMetadata(0)"
  },
  {
    "id" : "c5808e95-a26e-4a7e-ad53-b32dda62796b",
    "prId" : 9270,
    "prUrl" : "https://github.com/apache/kafka/pull/9270#pullrequestreview-509973628",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6719d049-4807-45f0-b6e6-3ff1dc58089a",
        "parentId" : null,
        "authorId" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "body" : "Seems the helper only gets called once?\r\n",
        "createdAt" : "2020-10-15T17:37:26Z",
        "updatedAt" : "2020-10-21T15:08:47Z",
        "lastEditedBy" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "tags" : [
        ]
      },
      {
        "id" : "28b26e91-672c-4afc-be57-5c4983a84d33",
        "parentId" : "6719d049-4807-45f0-b6e6-3ff1dc58089a",
        "authorId" : "410e5da8-f561-43d9-a4a1-a8ffb52d0269",
        "body" : "Yes, exactly, should I make it inline ?",
        "createdAt" : "2020-10-16T02:40:54Z",
        "updatedAt" : "2020-10-21T15:08:47Z",
        "lastEditedBy" : "410e5da8-f561-43d9-a4a1-a8ffb52d0269",
        "tags" : [
        ]
      }
    ],
    "commit" : "c9f358d6b8eaf14e5d5da232ba7f5ca024f0ef7a",
    "line" : 113,
    "diffHunk" : "@@ -1,1 +3853,3857 @@  }\n\n  private def sendStaticJoinGroupWithPersistence(groupId: String,\n                                                 memberId: String,\n                                                 protocolType: String,"
  }
]
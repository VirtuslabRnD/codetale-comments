[
  {
    "id" : "f4ac4a59-8392-4739-9597-2de72efe8f50",
    "prId" : 4479,
    "prUrl" : "https://github.com/apache/kafka/pull/4479#pullrequestreview-92406080",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b4d53255-dc8b-4367-83e4-e9fc7d56b256",
        "parentId" : null,
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "We should have a test case which tests removal when there are stored offsets.",
        "createdAt" : "2018-01-29T23:23:27Z",
        "updatedAt" : "2018-01-31T19:11:21Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      },
      {
        "id" : "31ec6c4e-7788-4673-8b8c-358199ece5f2",
        "parentId" : "b4d53255-dc8b-4367-83e4-e9fc7d56b256",
        "authorId" : "2a5e5a4d-e0e2-4e26-b139-0930dd63f949",
        "body" : "I added one in the new commit.",
        "createdAt" : "2018-01-30T06:31:23Z",
        "updatedAt" : "2018-01-31T19:11:21Z",
        "lastEditedBy" : "2a5e5a4d-e0e2-4e26-b139-0930dd63f949",
        "tags" : [
        ]
      }
    ],
    "commit" : "ca60b651ee8c2c38a6122b0300504aad8d2972b9",
    "line" : 35,
    "diffHunk" : "@@ -1,1 +1295,1299 @@\n  @Test\n  def testDeleteEmptyGroup() {\n    val memberId = JoinGroupRequest.UNKNOWN_MEMBER_ID\n    val joinGroupResult = joinGroup(groupId, memberId, protocolType, protocols)"
  },
  {
    "id" : "2d51648f-96fb-443a-bb41-467c3b248dbd",
    "prId" : 5962,
    "prUrl" : "https://github.com/apache/kafka/pull/5962#pullrequestreview-180046281",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ed3f9e5e-653e-438e-8768-3bc4212438ae",
        "parentId" : null,
        "authorId" : "df911192-d6c6-4af9-8568-f67bf2dcf926",
        "body" : "This is scheduled by an executor, right? I just want to make sure this test can't be flaky",
        "createdAt" : "2018-11-29T10:41:48Z",
        "updatedAt" : "2018-12-10T18:22:26Z",
        "lastEditedBy" : "df911192-d6c6-4af9-8568-f67bf2dcf926",
        "tags" : [
        ]
      },
      {
        "id" : "9d841364-eb21-4b4a-8065-874983824f5c",
        "parentId" : "ed3f9e5e-653e-438e-8768-3bc4212438ae",
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "I think tasks run by `MockTimer` just run in the foreground. Execution should be deterministic since we rely on `MockTime` under the covers.",
        "createdAt" : "2018-11-29T22:28:41Z",
        "updatedAt" : "2018-12-10T18:22:26Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      }
    ],
    "commit" : "259f70653f00eaeec3377abc30580ca801974b78",
    "line" : 77,
    "diffHunk" : "@@ -1,1 +296,300 @@    assertNotEquals(firstMemberId, newMember.memberId)\n\n    timer.advanceClock(GroupCoordinator.NewMemberJoinTimeoutMs + 1)\n    assertTrue(responseFuture.isCompleted)\n"
  },
  {
    "id" : "e4233676-0a52-4748-a541-3cbdf1375d63",
    "prId" : 5962,
    "prUrl" : "https://github.com/apache/kafka/pull/5962#pullrequestreview-182019475",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6fd25ad7-afaf-453a-8bd2-2b05904df448",
        "parentId" : null,
        "authorId" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "body" : "Why we increase max session timeout here?",
        "createdAt" : "2018-12-05T01:22:32Z",
        "updatedAt" : "2018-12-10T18:22:26Z",
        "lastEditedBy" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "tags" : [
        ]
      },
      {
        "id" : "758eeb6c-d7f0-4867-bb81-454594cfa7f4",
        "parentId" : "6fd25ad7-afaf-453a-8bd2-2b05904df448",
        "authorId" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "body" : "Note this is just a test case. I needed a more reasonable value in order to verify the behavior in this patch which depends on a static timeout.",
        "createdAt" : "2018-12-05T23:13:18Z",
        "updatedAt" : "2018-12-10T18:22:26Z",
        "lastEditedBy" : "5c21df64-97d8-46ab-9722-a7e9ba1d7c49",
        "tags" : [
        ]
      }
    ],
    "commit" : "259f70653f00eaeec3377abc30580ca801974b78",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +58,62 @@  val ClientHost = \"localhost\"\n  val GroupMinSessionTimeout = 10\n  val GroupMaxSessionTimeout = 10 * 60 * 1000\n  val DefaultRebalanceTimeout = 500\n  val DefaultSessionTimeout = 500"
  },
  {
    "id" : "defa4524-1d43-41d1-b20b-e191505c8abf",
    "prId" : 6058,
    "prUrl" : "https://github.com/apache/kafka/pull/6058#pullrequestreview-188194279",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "139632f1-6c40-4703-9815-837e28c2d443",
        "parentId" : null,
        "authorId" : "df911192-d6c6-4af9-8568-f67bf2dcf926",
        "body" : "In this case, would a third request with the correct protocol finish the join? Maybe it wouldn't hurt to test that as well",
        "createdAt" : "2018-12-26T09:09:43Z",
        "updatedAt" : "2019-01-15T03:26:21Z",
        "lastEditedBy" : "df911192-d6c6-4af9-8568-f67bf2dcf926",
        "tags" : [
        ]
      },
      {
        "id" : "7b88aca1-450f-4c08-8635-49f37d3ed354",
        "parentId" : "139632f1-6c40-4703-9815-837e28c2d443",
        "authorId" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "body" : "Sounds good!",
        "createdAt" : "2018-12-27T23:32:25Z",
        "updatedAt" : "2019-01-15T03:26:21Z",
        "lastEditedBy" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "tags" : [
        ]
      }
    ],
    "commit" : "29f668ef1a9b2ee5939791b9bd5b89bf1a1660bb",
    "line" : 53,
    "diffHunk" : "@@ -1,1 +357,361 @@    responseFuture = sendJoinGroup(groupId, memberId, protocolType, List(), requireKnownMemberId = true)\n    joinGroupResult = Await.result(responseFuture, Duration(DefaultRebalanceTimeout + 1, TimeUnit.MILLISECONDS))\n    assertEquals(Errors.INCONSISTENT_GROUP_PROTOCOL, joinGroupResult.error)\n\n    // Sending consistent protocol shall be accepted"
  },
  {
    "id" : "8b95acb4-21c3-4d0b-8d25-af40b398939e",
    "prId" : 6058,
    "prUrl" : "https://github.com/apache/kafka/pull/6058#pullrequestreview-188196463",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4ac3ca03-1091-45c4-9f0e-9e6f65743b81",
        "parentId" : null,
        "authorId" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "body" : "@hachikuji This is the part that I tested the new logic.",
        "createdAt" : "2018-12-27T23:58:41Z",
        "updatedAt" : "2019-01-15T03:26:21Z",
        "lastEditedBy" : "3dfe0270-df82-43af-827f-0681ce1c6ad9",
        "tags" : [
        ]
      }
    ],
    "commit" : "29f668ef1a9b2ee5939791b9bd5b89bf1a1660bb",
    "line" : 120,
    "diffHunk" : "@@ -1,1 +1717,1721 @@                        rebalanceTimeout: Int = DefaultRebalanceTimeout): JoinGroupResult = {\n    val requireKnownMemberId = true\n    var responseFuture = sendJoinGroup(groupId, memberId, protocolType, protocols, sessionTimeout, rebalanceTimeout, requireKnownMemberId)\n\n    // Since member id is required, we need another bounce to get the successful join group result."
  }
]
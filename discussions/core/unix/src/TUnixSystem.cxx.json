[
  {
    "id" : "1250fbbd-ef57-4a49-993e-d9decd9218e3",
    "prId" : 4671,
    "prUrl" : "https://github.com/root-project/root/pull/4671#pullrequestreview-328462645",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "544a6454-8ab2-40a2-b928-543f8d3bf153",
        "parentId" : null,
        "authorId" : "335eabbd-4b70-43fb-a046-bf82995f5dd3",
        "body" : "What's the reasoning/purpose of this addition?  Note that \"too-often\" the signal handler itself gets silly (for example on my MacOS it is common for the stack trace generator to get stuck) and I need to force the end of the process with kill -9  ... does that prevent it .. or not?",
        "createdAt" : "2019-12-06T14:56:24Z",
        "updatedAt" : "2020-01-20T14:49:24Z",
        "lastEditedBy" : "335eabbd-4b70-43fb-a046-bf82995f5dd3",
        "tags" : [
        ]
      },
      {
        "id" : "f4fc2986-33f9-47ef-94be-fe72a7e53f62",
        "parentId" : "544a6454-8ab2-40a2-b928-543f8d3bf153",
        "authorId" : "4c541c6e-f658-422b-9f5a-7ae0b2a9a1f5",
        "body" : "Even if I do not know how the whole signal capturing / exception mechanism works in ROOT, my guess is that this is added to handle sigabrt in case a library has a critical error and sends the signal (@wlav can better comment perhaps). Anyway I understand this should not affect sigkill.",
        "createdAt" : "2019-12-06T15:19:06Z",
        "updatedAt" : "2020-01-20T14:49:24Z",
        "lastEditedBy" : "4c541c6e-f658-422b-9f5a-7ae0b2a9a1f5",
        "tags" : [
        ]
      },
      {
        "id" : "257c9f72-120b-4658-aa14-77b5654b53c3",
        "parentId" : "544a6454-8ab2-40a2-b928-543f8d3bf153",
        "authorId" : "683b29c3-de55-4bfa-a8f9-8a107533453c",
        "body" : "SIGABRT comes from assertion failures. Having the handle, cppyy can trace the abort from a C++ function in a (automatically generated) callback through Python, yielding both a C++ and Python stack trace. Not sure about the technical term \"gets silly\". Actually, in cppyy when using controlled execution with `with`, cppyy will by default switch the C++ tracing of. It's never been good on Mac or Windows (with the latter now changing for the better, I see) and it's dog-slow on Linux plus annoyingly duplicated. (On the wishlist to patch.)\r\n\r\nEither which way, since the signal map is not accessible through an API, it is repeated in clingwrapper.cxx, so just as a heads up you need to patch that in your copy if you don't add SIGABRT. (Alternatively, SIGABRT could be moved to the end of the map, so then you don't have to, as it will never appear nor bump the number of the others.)",
        "createdAt" : "2019-12-06T15:37:16Z",
        "updatedAt" : "2020-01-20T14:49:24Z",
        "lastEditedBy" : "683b29c3-de55-4bfa-a8f9-8a107533453c",
        "tags" : [
        ]
      },
      {
        "id" : "363ea050-47af-40e4-ba95-e68340847754",
        "parentId" : "544a6454-8ab2-40a2-b928-543f8d3bf153",
        "authorId" : "335eabbd-4b70-43fb-a046-bf82995f5dd3",
        "body" : "> Not sure about the technical term \"gets silly\"\r\n\r\nIn my case, takes for ever and no longer react to CTRL+C or CTRL+Z, usually because something is going awry (infinite loop?, crash?) in the stack trace generator (gdb).\r\n\r\n> (On the wishlist to patch.)\r\n\r\nNote the related PR: https://github.com/root-project/root/pull/1053\r\n\r\n> SIGABRT comes from assertion failures. \r\n\r\nhumm ... so my point is moot, I mistoke SIGABRT (6) for SIGKILL (9) .. so never mind :)\r\n",
        "createdAt" : "2019-12-06T21:13:15Z",
        "updatedAt" : "2020-01-20T14:49:24Z",
        "lastEditedBy" : "335eabbd-4b70-43fb-a046-bf82995f5dd3",
        "tags" : [
        ]
      },
      {
        "id" : "68e63cc1-20dd-43e3-afb5-ddbebda462db",
        "parentId" : "544a6454-8ab2-40a2-b928-543f8d3bf153",
        "authorId" : "683b29c3-de55-4bfa-a8f9-8a107533453c",
        "body" : "CTRL+\\ is your friend. It sends SIGQUIT, which the application can not intercept (contrary to SIGINT or SIGTSTP as coming from the other two).",
        "createdAt" : "2019-12-06T21:17:22Z",
        "updatedAt" : "2020-01-20T14:49:24Z",
        "lastEditedBy" : "683b29c3-de55-4bfa-a8f9-8a107533453c",
        "tags" : [
        ]
      }
    ],
    "commit" : "4de70afdd8a2ae78c0cd2dae5902d27cffdc09b2",
    "line" : 12,
    "diffHunk" : "@@ -1,1 +3584,3588 @@   { SIGPIPE,  0, 0, \"write on a pipe with no one to read it\" },\n   { SIGILL,   0, 0, \"illegal instruction\" },\n   { SIGABRT,  0, 0, \"abort\" },\n   { SIGQUIT,  0, 0, \"quit\" },\n   { SIGINT,   0, 0, \"interrupt\" },"
  },
  {
    "id" : "ec1b6182-05e3-4a93-ba0d-b88d5bb3050b",
    "prId" : 4900,
    "prUrl" : "https://github.com/root-project/root/pull/4900#pullrequestreview-350991026",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e5e527c8-4fb4-4e81-8239-6881d2075358",
        "parentId" : null,
        "authorId" : "335eabbd-4b70-43fb-a046-bf82995f5dd3",
        "body" : "If we are not going to fix the memory leak and the platform is not currently supported, I would put an assert .... or even a ```#error```\r\n",
        "createdAt" : "2020-01-30T16:32:08Z",
        "updatedAt" : "2020-01-31T07:29:23Z",
        "lastEditedBy" : "335eabbd-4b70-43fb-a046-bf82995f5dd3",
        "tags" : [
        ]
      },
      {
        "id" : "0cef43ab-9772-41b3-9511-05d937a89ed1",
        "parentId" : "e5e527c8-4fb4-4e81-8239-6881d2075358",
        "authorId" : "e4571402-a12a-4377-8cca-960e88b81e3d",
        "body" : "I guess, memory leak is better than blocking people to try something.\r\nMaybe there are enthusiast who want to re-activate cyginw/gcc combination.\r\n",
        "createdAt" : "2020-01-30T16:43:17Z",
        "updatedAt" : "2020-01-31T07:29:23Z",
        "lastEditedBy" : "e4571402-a12a-4377-8cca-960e88b81e3d",
        "tags" : [
        ]
      },
      {
        "id" : "f7b3cb1b-b00d-42d3-9bcc-8b53103cac4c",
        "parentId" : "e5e527c8-4fb4-4e81-8239-6881d2075358",
        "authorId" : "335eabbd-4b70-43fb-a046-bf82995f5dd3",
        "body" : "@Axel-Naumann opinion?",
        "createdAt" : "2020-01-30T16:46:19Z",
        "updatedAt" : "2020-01-31T07:29:23Z",
        "lastEditedBy" : "335eabbd-4b70-43fb-a046-bf82995f5dd3",
        "tags" : [
        ]
      },
      {
        "id" : "da81203c-601f-426c-8ced-23f68467219c",
        "parentId" : "e5e527c8-4fb4-4e81-8239-6881d2075358",
        "authorId" : "09b7e073-cbeb-42e8-aa22-8b1468de56ae",
        "body" : "Not a strong opinion, but applying this and adding an `#error \"unsupported platform\"` sounds pretty reasonable to me.",
        "createdAt" : "2020-01-30T17:06:03Z",
        "updatedAt" : "2020-01-31T07:29:23Z",
        "lastEditedBy" : "09b7e073-cbeb-42e8-aa22-8b1468de56ae",
        "tags" : [
        ]
      }
    ],
    "commit" : "a6ccb4565338c0284c8b98cf1e51c63fe1a4fc69",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +2858,2862 @@      strlcpy(longerexe, exe,lenexe+5);\n      strlcat(longerexe, \".exe\",lenexe+5);\n      exe = longerexe;  // memory leak\n      #error \"unsupported platform, fix memory leak to use it\"\n   }"
  }
]
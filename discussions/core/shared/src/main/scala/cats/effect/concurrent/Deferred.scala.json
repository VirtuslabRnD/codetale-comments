[
  {
    "id" : "066c9785-77eb-4b12-b925-0f332cd0209d",
    "prId" : 424,
    "prUrl" : "https://github.com/typelevel/cats-effect/pull/424#pullrequestreview-180141693",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "670b26aa-0979-48c6-9bce-fe56de3f586d",
        "parentId" : null,
        "authorId" : "e856ded5-89e9-4e09-937c-311c66e1f1a6",
        "body" : "`F.void` instead of `F.map(..)(mapUnit)`?",
        "createdAt" : "2018-11-26T17:56:05Z",
        "updatedAt" : "2018-11-30T07:16:29Z",
        "lastEditedBy" : "e856ded5-89e9-4e09-937c-311c66e1f1a6",
        "tags" : [
        ]
      },
      {
        "id" : "57d07ddb-4b0f-40f9-8a52-1f837a3f90b1",
        "parentId" : "670b26aa-0979-48c6-9bce-fe56de3f586d",
        "authorId" : "efc45bfc-463c-4c9e-946d-ad472fabc9f0",
        "body" : "`F.void` is more wasteful, because it translates to `F.map(task)(_ => ())` and the Scala compiler won't reuse the created `_ => ()`.\r\n\r\nWhen doing performance-sensitive work, in general I care about these issues in about this order:\r\n\r\n1. avoiding extraneous async or lazy boundaries\r\n2. avoiding extraneous `compareAndSet` operations\r\n3. avoiding extraneous memory allocations\r\n\r\nCaching dummy functions like `_ => ()` falls into point 3, and sometimes I screw up due to the code becoming unclear, but it doesn't happen that often ðŸ™‚ ",
        "createdAt" : "2018-11-30T07:06:45Z",
        "updatedAt" : "2018-11-30T07:16:29Z",
        "lastEditedBy" : "efc45bfc-463c-4c9e-946d-ad472fabc9f0",
        "tags" : [
        ]
      }
    ],
    "commit" : "456e4f77eecf2037258e5087d655a7d530a67383",
    "line" : 85,
    "diffHunk" : "@@ -1,1 +207,211 @@      while (cursor.hasNext) {\n        val next = cursor.next()\n        val task = F.map(F.start(F.delay(next(a))))(mapUnit)\n        acc = F.flatMap(acc)(_ => task)\n      }"
  },
  {
    "id" : "ef2cd568-8828-48f5-b9df-a933cae2a558",
    "prId" : 395,
    "prUrl" : "https://github.com/typelevel/cats-effect/pull/395#pullrequestreview-177340289",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1ddfc303-3994-4ce3-bee7-71e328d3235a",
        "parentId" : null,
        "authorId" : "92207535-a44d-4e62-a734-e9ca077fe214",
        "body" : "Why `abstract class` and not `trait`?",
        "createdAt" : "2018-10-19T17:42:50Z",
        "updatedAt" : "2018-12-25T07:55:20Z",
        "lastEditedBy" : "92207535-a44d-4e62-a734-e9ca077fe214",
        "tags" : [
        ]
      },
      {
        "id" : "c73e4933-72b0-49a0-ad96-759f15e1a8ed",
        "parentId" : "1ddfc303-3994-4ce3-bee7-71e328d3235a",
        "authorId" : "855e0d4a-4c1d-49a7-8fd0-9333d518b4d7",
        "body" : "It analogous to the original `Deferred` definition",
        "createdAt" : "2018-10-19T18:05:00Z",
        "updatedAt" : "2018-12-25T07:55:20Z",
        "lastEditedBy" : "855e0d4a-4c1d-49a7-8fd0-9333d518b4d7",
        "tags" : [
        ]
      },
      {
        "id" : "4fe0a5d0-4c36-4b1a-8fd6-23fc6b0772c5",
        "parentId" : "1ddfc303-3994-4ce3-bee7-71e328d3235a",
        "authorId" : "855e0d4a-4c1d-49a7-8fd0-9333d518b4d7",
        "body" : "I think it's pragmatic soltuion to reduce generated classes count, lighten library, reduce some generated casts idk",
        "createdAt" : "2018-10-19T18:06:38Z",
        "updatedAt" : "2018-12-25T07:55:20Z",
        "lastEditedBy" : "855e0d4a-4c1d-49a7-8fd0-9333d518b4d7",
        "tags" : [
        ]
      },
      {
        "id" : "942c5e9b-2f4f-4e89-b521-bf9cd2eaaaed",
        "parentId" : "1ddfc303-3994-4ce3-bee7-71e328d3235a",
        "authorId" : "e856ded5-89e9-4e09-937c-311c66e1f1a6",
        "body" : "Abstract classes let us safely add derived methods on 2.11. We can do this with traits in 2.12+ so I expect this pattern to fall out of fashion once 2.11 cross-build support goes away.",
        "createdAt" : "2018-10-19T18:13:00Z",
        "updatedAt" : "2018-12-25T07:55:20Z",
        "lastEditedBy" : "e856ded5-89e9-4e09-937c-311c66e1f1a6",
        "tags" : [
        ]
      },
      {
        "id" : "0385dfe5-915e-4d63-92ec-eb2dad3a0a04",
        "parentId" : "1ddfc303-3994-4ce3-bee7-71e328d3235a",
        "authorId" : "a5a514ff-cd89-45cb-bcc8-796f0fa2a445",
        "body" : "An abstract class is preferred because it's possible to add a new method to it (if there's a default implementation), without breaking bincompat in 2.11. With a trait that's not the case.\r\nIt didn't help here but it generally does.",
        "createdAt" : "2018-10-19T18:13:05Z",
        "updatedAt" : "2018-12-25T07:55:20Z",
        "lastEditedBy" : "a5a514ff-cd89-45cb-bcc8-796f0fa2a445",
        "tags" : [
        ]
      },
      {
        "id" : "7af81363-64d4-4288-beab-af48ac5d7208",
        "parentId" : "1ddfc303-3994-4ce3-bee7-71e328d3235a",
        "authorId" : "92207535-a44d-4e62-a734-e9ca077fe214",
        "body" : "TIL",
        "createdAt" : "2018-10-20T04:37:59Z",
        "updatedAt" : "2018-12-25T07:55:20Z",
        "lastEditedBy" : "92207535-a44d-4e62-a734-e9ca077fe214",
        "tags" : [
        ]
      },
      {
        "id" : "11abd308-1e17-4595-aad7-ad345d06912c",
        "parentId" : "1ddfc303-3994-4ce3-bee7-71e328d3235a",
        "authorId" : "efc45bfc-463c-4c9e-946d-ad472fabc9f0",
        "body" : "Btw, our `abstract class` usage hasn't helped us in adding new operations while maintaining bincompat because we've made the error of not adding the `F[_]` restriction as well. Without `F[_] : Async` or whatever, there isn't much that you can do to add operations.\r\n\r\nSomething to keep in mind for Cats-Effect 2.0.",
        "createdAt" : "2018-11-21T16:54:13Z",
        "updatedAt" : "2018-12-25T07:55:20Z",
        "lastEditedBy" : "efc45bfc-463c-4c9e-946d-ad472fabc9f0",
        "tags" : [
        ]
      }
    ],
    "commit" : "5911bb991f3a3013931ca1a0a0b72fc65a2e41d1",
    "line" : 12,
    "diffHunk" : "@@ -1,1 +84,88 @@}\n\nabstract class TryableDeferred[F[_], A] extends Deferred[F, A]{\n  /**\n   * Obtains the current value of the `Deferred`, or None if it hasn't completed."
  }
]
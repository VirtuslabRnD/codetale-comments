[
  {
    "id" : "dc4d0ffb-cee4-495b-9d62-26fab309f640",
    "prId" : 1081,
    "prUrl" : "https://github.com/typelevel/cats-effect/pull/1081#pullrequestreview-468446967",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f8129b55-167c-49ed-b0b0-0dc15090f064",
        "parentId" : null,
        "authorId" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "body" : "Can we make the algebraic cases `private`?",
        "createdAt" : "2020-08-14T02:23:39Z",
        "updatedAt" : "2020-08-14T03:29:37Z",
        "lastEditedBy" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "tags" : [
        ]
      },
      {
        "id" : "1c0b2564-3ec1-4657-bc67-3f0e3391e6da",
        "parentId" : "f8129b55-167c-49ed-b0b0-0dc15090f064",
        "authorId" : "a5a514ff-cd89-45cb-bcc8-796f0fa2a445",
        "body" : "they are interpreted in fs2",
        "createdAt" : "2020-08-14T16:59:31Z",
        "updatedAt" : "2020-08-14T16:59:31Z",
        "lastEditedBy" : "a5a514ff-cd89-45cb-bcc8-796f0fa2a445",
        "tags" : [
        ]
      },
      {
        "id" : "57e8458b-8cd1-4178-848d-f6c3c32960bf",
        "parentId" : "f8129b55-167c-49ed-b0b0-0dc15090f064",
        "authorId" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "body" : "Why do you have to say such horrible things to me?",
        "createdAt" : "2020-08-14T17:23:47Z",
        "updatedAt" : "2020-08-14T17:23:47Z",
        "lastEditedBy" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "tags" : [
        ]
      },
      {
        "id" : "31acb03b-df11-4bb5-afc7-642530e49a74",
        "parentId" : "f8129b55-167c-49ed-b0b0-0dc15090f064",
        "authorId" : "a5a514ff-cd89-45cb-bcc8-796f0fa2a445",
        "body" : "Btw, this was by design when resource was created. The fs2 interpretation is nothing crazy, but it's basically because Resource is the Free encoding of the \"region\"  abstraction (that we need for fs2 bracket)",
        "createdAt" : "2020-08-17T13:09:43Z",
        "updatedAt" : "2020-08-17T13:09:43Z",
        "lastEditedBy" : "a5a514ff-cd89-45cb-bcc8-796f0fa2a445",
        "tags" : [
        ]
      }
    ],
    "commit" : "876aaec4bc58da38411ed4a4df626acc21407956",
    "line" : 463,
    "diffHunk" : "@@ -1,1 +461,465 @@   * along with its finalizers.\n   */\n  final case class Allocate[F[_], A](resource: F[(A, ExitCase => F[Unit])])\n      extends Resource[F, A]\n"
  },
  {
    "id" : "18b4ca0f-2dd5-4a60-b46a-8010657c3ba2",
    "prId" : 1081,
    "prUrl" : "https://github.com/typelevel/cats-effect/pull/1081#pullrequestreview-467730747",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "25be33cd-05bf-4b79-9260-d3eb8d07c392",
        "parentId" : null,
        "authorId" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "body" : "`LiftIO` is in **core**, so we can technically have this.",
        "createdAt" : "2020-08-14T02:25:10Z",
        "updatedAt" : "2020-08-14T03:29:37Z",
        "lastEditedBy" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "tags" : [
        ]
      },
      {
        "id" : "88dcd520-43cd-434e-aee7-98660b44ee7a",
        "parentId" : "25be33cd-05bf-4b79-9260-d3eb8d07c392",
        "authorId" : "a5a514ff-cd89-45cb-bcc8-796f0fa2a445",
        "body" : "yep, another TODO to fix then",
        "createdAt" : "2020-08-14T17:00:26Z",
        "updatedAt" : "2020-08-14T17:00:27Z",
        "lastEditedBy" : "a5a514ff-cd89-45cb-bcc8-796f0fa2a445",
        "tags" : [
        ]
      }
    ],
    "commit" : "876aaec4bc58da38411ed4a4df626acc21407956",
    "line" : 631,
    "diffHunk" : "@@ -1,1 +629,633 @@  //     def F0 = F00\n  //     def F1 = F10\n  //   }\n\n  implicit def catsEffectCommutativeApplicativeForResourcePar[F[_]]("
  },
  {
    "id" : "4a9f2262-6ebf-4718-b17d-5418b7313f57",
    "prId" : 1060,
    "prUrl" : "https://github.com/typelevel/cats-effect/pull/1060#pullrequestreview-463804428",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4ae02247-eb61-4ed9-9eaf-cf938aa8cde4",
        "parentId" : null,
        "authorId" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "body" : "This is a significant constraint to add to something like this. Why exactly do we ned the `Ref`-based implementation below?",
        "createdAt" : "2020-08-08T03:27:22Z",
        "updatedAt" : "2020-08-18T09:22:30Z",
        "lastEditedBy" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "tags" : [
        ]
      },
      {
        "id" : "16e28e18-4dc8-4998-ba8d-f8597da1b242",
        "parentId" : "4ae02247-eb61-4ed9-9eaf-cf938aa8cde4",
        "authorId" : "3764809f-6ca4-4c5d-877f-8c00b82ef419",
        "body" : "> Why exactly do we ned the `Ref`-based implementation below?\n\nI can't say for sure, but I couldn't come up with anything else so I ~stole~ adapted this from the `parTupled` implementation.\n\nThat said, I can't see a way to do this without capturing the finalizer through a side-effect. To do that we'd need to either (1) allocate the resource ourselves before invoking the underlying `combineK` or (2) get the finalizer from the result of the underlying `combineK`. (1) was the original approach and is incorrect because it allocated both resources whether or not the underlying `combineK` runs both effects; (2) was my first approach in this PR but it can't guarantee that the underlying `combineK` will produce a finalizer that releases all allocated resources. Maybe there's another way I didn't think of though?\n\n\n\n\n\n",
        "createdAt" : "2020-08-08T12:15:18Z",
        "updatedAt" : "2020-08-18T09:22:30Z",
        "lastEditedBy" : "3764809f-6ca4-4c5d-877f-8c00b82ef419",
        "tags" : [
        ]
      },
      {
        "id" : "6a763beb-100c-438a-80e8-4e7a321cccc2",
        "parentId" : "4ae02247-eb61-4ed9-9eaf-cf938aa8cde4",
        "authorId" : "3764809f-6ca4-4c5d-877f-8c00b82ef419",
        "body" : "I guess it might be possible to do the same thing with `StateT` - I'll give it a try later.",
        "createdAt" : "2020-08-08T12:56:40Z",
        "updatedAt" : "2020-08-18T09:22:30Z",
        "lastEditedBy" : "3764809f-6ca4-4c5d-877f-8c00b82ef419",
        "tags" : [
        ]
      },
      {
        "id" : "3a515030-d5bc-4987-b931-50583ea4e591",
        "parentId" : "4ae02247-eb61-4ed9-9eaf-cf938aa8cde4",
        "authorId" : "3764809f-6ca4-4c5d-877f-8c00b82ef419",
        "body" : "Nope, `StateT` has exactly the same problem - if the value gets discarded by the underlying instance, so does the state.",
        "createdAt" : "2020-08-08T13:52:52Z",
        "updatedAt" : "2020-08-18T09:22:30Z",
        "lastEditedBy" : "3764809f-6ca4-4c5d-877f-8c00b82ef419",
        "tags" : [
        ]
      }
    ],
    "commit" : "c1bf06942cb34385483c410bdd2f682f0924e8e5",
    "line" : 26,
    "diffHunk" : "@@ -1,1 +576,580 @@    }\n\n  implicit def catsEffectSemigroupKForResource2[F[_]](implicit F0: Sync[F],\n                                                      K: SemigroupK[F]): SemigroupK[Resource[F, *]] =\n    new SemigroupK[Resource[F, *]] {"
  },
  {
    "id" : "1e9996cc-332b-4a38-a9a2-c6bea2cc53c9",
    "prId" : 849,
    "prUrl" : "https://github.com/typelevel/cats-effect/pull/849#pullrequestreview-402355916",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a0942560-dc9b-42e3-b8a4-4bf643995ada",
        "parentId" : null,
        "authorId" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "body" : "I'm not sure this one is necessary, btw.",
        "createdAt" : "2020-04-29T04:20:41Z",
        "updatedAt" : "2020-04-29T15:16:07Z",
        "lastEditedBy" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "tags" : [
        ]
      }
    ],
    "commit" : "e0e85070e446a40eb906889cd07b4ccacd04cfbc",
    "line" : 15,
    "diffHunk" : "@@ -1,1 +170,174 @@   **/\n  def parZip[G[x] >: F[x]: Sync: Parallel, B](\n    that: Resource[G[?], B]\n  ): Resource[G[?], (A, B)] = {\n    type Update = (G[Unit] => G[Unit]) => G[Unit]"
  },
  {
    "id" : "326fa2eb-5cef-4d52-b721-2741f3ef9442",
    "prId" : 742,
    "prUrl" : "https://github.com/typelevel/cats-effect/pull/742#pullrequestreview-350316961",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "08450747-e12d-4bee-a710-c0147fe62d62",
        "parentId" : null,
        "authorId" : "df537f5b-c150-4710-8eb4-40b8b59c3bcc",
        "body" : "```suggestion\r\n   *       IO(scala.util.Random.nextInt(1000).millis).flatMap(IO.sleep) *>\r\n```",
        "createdAt" : "2020-01-29T18:09:43Z",
        "updatedAt" : "2020-01-29T18:09:44Z",
        "lastEditedBy" : "df537f5b-c150-4710-8eb4-40b8b59c3bcc",
        "tags" : [
        ]
      }
    ],
    "commit" : "c69210a641c6f3f54f2a57391a4d728330c92d09",
    "line" : 75,
    "diffHunk" : "@@ -1,1 +156,160 @@   *   def mkResource(name: String) = {\n   *     val acquire =\n   *       IO(scala.util.Random.nextInt(1000).millis) *>\n   *       IO(println(s\"Acquiring $$name\")).as(name)\n   *"
  },
  {
    "id" : "93f54c14-3774-432f-a26b-a4dcef25946a",
    "prId" : 496,
    "prUrl" : "https://github.com/typelevel/cats-effect/pull/496#pullrequestreview-279345143",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c96aa9f2-5490-4522-896e-eee4b1bee09d",
        "parentId" : null,
        "authorId" : "df537f5b-c150-4710-8eb4-40b8b59c3bcc",
        "body" : "Only now do I realize how smart this is. You avoided adding a new node and support from the use loop with this simple trick (`suspend(fa.map)`) - great work as always Fabio @systemfw!",
        "createdAt" : "2019-08-25T17:09:37Z",
        "updatedAt" : "2019-08-25T17:09:37Z",
        "lastEditedBy" : "df537f5b-c150-4710-8eb4-40b8b59c3bcc",
        "tags" : [
        ]
      }
    ],
    "commit" : "8ce69a477df81320636fa0349bc3b0ed43a2b9e9",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +316,320 @@   */\n  def liftF[F[_], A](fa: F[A])(implicit F: Applicative[F]): Resource[F, A] =\n    Resource.suspend(fa.map(a => Resource.pure(a)))\n\n  /**"
  },
  {
    "id" : "7ac92934-f131-42f6-a1cc-df51bd6b6e36",
    "prId" : 439,
    "prUrl" : "https://github.com/typelevel/cats-effect/pull/439#pullrequestreview-183681591",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a8b7978e-7117-4a3c-a2f7-6ca57d4a214c",
        "parentId" : null,
        "authorId" : "efc45bfc-463c-4c9e-946d-ad472fabc9f0",
        "body" : "Is an alias like this really useful?\r\n\r\nI mean it is convenient, but it introduces yet another name that people have to learn.\r\n\r\nFor example this `semiflatMap` in Monix's `Iterant` is called `mapEval` and I'm pretty sure it has another name in FS2. And a divergence in naming is going to be more problematic than the absence of this helper.\r\n\r\nSo what precedent do we have for this name?",
        "createdAt" : "2018-12-06T08:43:43Z",
        "updatedAt" : "2018-12-11T15:11:17Z",
        "lastEditedBy" : "efc45bfc-463c-4c9e-946d-ad472fabc9f0",
        "tags" : [
        ]
      },
      {
        "id" : "419687fd-d9c6-4885-bfaf-0a76c3a535cc",
        "parentId" : "a8b7978e-7117-4a3c-a2f7-6ca57d4a214c",
        "authorId" : "52e57876-e824-4b50-b392-b9a015a4be8c",
        "body" : "The precedent is [this](https://github.com/typelevel/cats/blob/e1a7cfcddce0fd48403669a5744df50e4a08631c/core/src/main/scala/cats/data/EitherT.scala#L112) method on `EitherT` in cats. But to be honest I lilke `evalMap` better. Isn't that also what it's called on `fs2.Stream`?\r\n\r\nAs to whether it's useful, I do think so. This seems like a very common usecase and exposing it directly makes it a lot easier to discover, especially for beginners. Browsing the cats scaladoc sort of is my hoogle substitute and I missed `liftF` scanning through.\r\n\r\nThen again, a section in the Resource docs mentioning `liftF` would probably work too. If that is preferred I'll PR that instead.",
        "createdAt" : "2018-12-06T09:44:02Z",
        "updatedAt" : "2018-12-11T15:11:17Z",
        "lastEditedBy" : "52e57876-e824-4b50-b392-b9a015a4be8c",
        "tags" : [
        ]
      },
      {
        "id" : "f7d4e05d-4861-426c-99e5-935afd02e724",
        "parentId" : "a8b7978e-7117-4a3c-a2f7-6ca57d4a214c",
        "authorId" : "efc45bfc-463c-4c9e-946d-ad472fabc9f0",
        "body" : "We can add this too, we just have to agree about the naming.",
        "createdAt" : "2018-12-06T14:59:22Z",
        "updatedAt" : "2018-12-11T15:11:17Z",
        "lastEditedBy" : "efc45bfc-463c-4c9e-946d-ad472fabc9f0",
        "tags" : [
        ]
      },
      {
        "id" : "3d78babe-4781-4505-b523-c2d46da4b20a",
        "parentId" : "a8b7978e-7117-4a3c-a2f7-6ca57d4a214c",
        "authorId" : "52e57876-e824-4b50-b392-b9a015a4be8c",
        "body" : "Oh, I didn't realize the difference `mapEval` vs `evalMap`. `Stream.evalMap` seems to not exactly be the same because the effect type is allowed to vary. `mapEval` still seems nicer than `semiflatMap`, though. But that's your call. I'll update this PR with an appropriate addition to the docs next time I find some time.",
        "createdAt" : "2018-12-06T16:31:38Z",
        "updatedAt" : "2018-12-11T15:11:17Z",
        "lastEditedBy" : "52e57876-e824-4b50-b392-b9a015a4be8c",
        "tags" : [
        ]
      },
      {
        "id" : "15bc29a2-8d55-4a58-8018-1702865479c3",
        "parentId" : "a8b7978e-7117-4a3c-a2f7-6ca57d4a214c",
        "authorId" : "efc45bfc-463c-4c9e-946d-ad472fabc9f0",
        "body" : "I would be fine with either, pick one.",
        "createdAt" : "2018-12-06T16:42:48Z",
        "updatedAt" : "2018-12-11T15:11:17Z",
        "lastEditedBy" : "efc45bfc-463c-4c9e-946d-ad472fabc9f0",
        "tags" : [
        ]
      },
      {
        "id" : "e514cb50-d0ce-4074-968a-ee7eaadf5deb",
        "parentId" : "a8b7978e-7117-4a3c-a2f7-6ca57d4a214c",
        "authorId" : "19f1b7b0-eaed-49a1-9ac5-80ac65598c75",
        "body" : "Is `Resource` a monad transformer?  I would argue yes.  And `semiflatMap` is what this operation is called on several monad transformers in cats.  (I think a couple of its `flatMapF` look more like `semiflatMap`, but that's a debate for another repo.)\r\n\r\nAre `Iterant` and `Stream` monad transformers? :thinking:",
        "createdAt" : "2018-12-06T17:29:09Z",
        "updatedAt" : "2018-12-11T15:11:17Z",
        "lastEditedBy" : "19f1b7b0-eaed-49a1-9ac5-80ac65598c75",
        "tags" : [
        ]
      },
      {
        "id" : "d4e35413-cb7a-4f1b-81b4-bac58ccbf631",
        "parentId" : "a8b7978e-7117-4a3c-a2f7-6ca57d4a214c",
        "authorId" : "52e57876-e824-4b50-b392-b9a015a4be8c",
        "body" : "That is a good argument for `semiflatMap`. I'll leave it then, because I think consistency is more important than an intuitive name. I've also updated the docs with examples on `liftF` and `semiflatMap` now",
        "createdAt" : "2018-12-06T21:38:34Z",
        "updatedAt" : "2018-12-11T15:11:17Z",
        "lastEditedBy" : "52e57876-e824-4b50-b392-b9a015a4be8c",
        "tags" : [
        ]
      },
      {
        "id" : "2ffbc730-7418-4270-ae1e-d7a9ca6f789a",
        "parentId" : "a8b7978e-7117-4a3c-a2f7-6ca57d4a214c",
        "authorId" : "efc45bfc-463c-4c9e-946d-ad472fabc9f0",
        "body" : "I'm not very familiar with Cats' monad transformers. If @rossabaker says `semiflatMap` is OK, then I guess it's fine.",
        "createdAt" : "2018-12-07T10:21:15Z",
        "updatedAt" : "2018-12-11T15:11:17Z",
        "lastEditedBy" : "efc45bfc-463c-4c9e-946d-ad472fabc9f0",
        "tags" : [
        ]
      },
      {
        "id" : "9e263a23-d207-43e8-bfc6-50488c674f6e",
        "parentId" : "a8b7978e-7117-4a3c-a2f7-6ca57d4a214c",
        "authorId" : "52e57876-e824-4b50-b392-b9a015a4be8c",
        "body" : "I'm still struggling a little with that name (and others seem to as well). Other suggestions from the gitter channel were: `flatMapF` and `liftMap`. At least `flatMapF` seems to have some precedent on other monad transformers, e.g. `StateT`, `IdT` and `Kleisli`, and while maybe not perfect, it seems a bit nicer than `semiflatMap`. Especially since the name `semiflatMap` seems to have only been a compromise because `flatMapF` was already taken on `OptionT` and `EitherT` (https://github.com/typelevel/cats/pull/999, as pointed out by @oleg-py) Thus the precedent for `flatMapF` is older. I'm updating accordingly",
        "createdAt" : "2018-12-10T14:42:52Z",
        "updatedAt" : "2018-12-11T15:11:17Z",
        "lastEditedBy" : "52e57876-e824-4b50-b392-b9a015a4be8c",
        "tags" : [
        ]
      },
      {
        "id" : "69edc0e7-9826-4fd8-9fba-e2bb86f6d169",
        "parentId" : "a8b7978e-7117-4a3c-a2f7-6ca57d4a214c",
        "authorId" : "efc45bfc-463c-4c9e-946d-ad472fabc9f0",
        "body" : "👍 for `flatMapF`, personally I like it.",
        "createdAt" : "2018-12-10T14:53:50Z",
        "updatedAt" : "2018-12-11T15:11:17Z",
        "lastEditedBy" : "efc45bfc-463c-4c9e-946d-ad472fabc9f0",
        "tags" : [
        ]
      },
      {
        "id" : "1c883232-ae81-46ad-bf1c-5caa4b8e8ee7",
        "parentId" : "a8b7978e-7117-4a3c-a2f7-6ca57d4a214c",
        "authorId" : "19f1b7b0-eaed-49a1-9ac5-80ac65598c75",
        "body" : ":-1: `flatMapF` is a mess in cats, whose shape is determined by historical quirks\r\n\r\nPreference:\r\n1. `semiflatMap`: consistent upstream where it appears\r\n2. `evalMap` or `mapEval`: used downstream, intuitive. If fs2 and monix had picked the same name, it would be my first choice.\r\n4. `flatMapF`: I can't ever remember what this does on which type\r\n\r\nThis is a preference, not a veto.  If I'm outvoted, I won't pout. :+1: to the rest of the ticket.",
        "createdAt" : "2018-12-10T17:57:10Z",
        "updatedAt" : "2018-12-11T15:11:17Z",
        "lastEditedBy" : "19f1b7b0-eaed-49a1-9ac5-80ac65598c75",
        "tags" : [
        ]
      },
      {
        "id" : "5f0ab398-c7ab-435e-80a3-d14513c00d01",
        "parentId" : "a8b7978e-7117-4a3c-a2f7-6ca57d4a214c",
        "authorId" : "52e57876-e824-4b50-b392-b9a015a4be8c",
        "body" : ":slightly_smiling_face: I can live with either. What's needed to reach consensus though? Anything I could do?\r\n\r\nOne other thing that imo is a good argument for `flatMapF` is that it would be somewhat consistent with `liftF`, which already exists on `Resource`.",
        "createdAt" : "2018-12-10T22:08:31Z",
        "updatedAt" : "2018-12-11T15:11:17Z",
        "lastEditedBy" : "52e57876-e824-4b50-b392-b9a015a4be8c",
        "tags" : [
        ]
      },
      {
        "id" : "a0f20eeb-66cc-4060-bb79-8aa18f6d268b",
        "parentId" : "a8b7978e-7117-4a3c-a2f7-6ca57d4a214c",
        "authorId" : "19f1b7b0-eaed-49a1-9ac5-80ac65598c75",
        "body" : "I'll mention the issue on the channel again, and if nobody else comes to argue against `flatMapF` in the next day or so, I'll admit defeat. :smile:",
        "createdAt" : "2018-12-11T13:36:11Z",
        "updatedAt" : "2018-12-11T15:11:17Z",
        "lastEditedBy" : "19f1b7b0-eaed-49a1-9ac5-80ac65598c75",
        "tags" : [
        ]
      },
      {
        "id" : "0ae66c7f-60b8-41a2-bb82-db31e2e5a4df",
        "parentId" : "a8b7978e-7117-4a3c-a2f7-6ca57d4a214c",
        "authorId" : "f03705f3-792d-4b36-bfdf-380cd6f2af9a",
        "body" : "What is flatMapF? I think semiFlatMap makes more sense as well. Putting a letter F tells me nothing about the context. SemiFlatMap, tells my you are lifting into the transformers inner context. That increased clarity seems preferable to me as well.",
        "createdAt" : "2018-12-11T13:42:10Z",
        "updatedAt" : "2018-12-11T15:11:17Z",
        "lastEditedBy" : "f03705f3-792d-4b36-bfdf-380cd6f2af9a",
        "tags" : [
        ]
      },
      {
        "id" : "7836c060-80b7-4160-b68c-e0bd4a9e8e20",
        "parentId" : "a8b7978e-7117-4a3c-a2f7-6ca57d4a214c",
        "authorId" : "a5a514ff-cd89-45cb-bcc8-796f0fa2a445",
        "body" : "I vote for `evalMap`",
        "createdAt" : "2018-12-11T13:45:07Z",
        "updatedAt" : "2018-12-11T15:11:17Z",
        "lastEditedBy" : "a5a514ff-cd89-45cb-bcc8-796f0fa2a445",
        "tags" : [
        ]
      }
    ],
    "commit" : "c5772ec7cf66f4b1ee341972ff20ea42978fc2e9",
    "line" : 10,
    "diffHunk" : "@@ -1,1 +208,212 @@    */\n  def evalMap[B](f: A => F[B])(implicit F: Applicative[F]): Resource[F, B] =\n    this.flatMap(a => Resource.liftF(f(a)))\n}\n"
  },
  {
    "id" : "7acfa06a-5c33-4ce5-aba9-17cd0c1d2b4e",
    "prId" : 419,
    "prUrl" : "https://github.com/typelevel/cats-effect/pull/419#pullrequestreview-176390750",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1330fb64-6a08-4b8e-a13e-a2a4e7bdebcb",
        "parentId" : null,
        "authorId" : "92207535-a44d-4e62-a734-e9ca077fe214",
        "body" : "💯 This is great doc",
        "createdAt" : "2018-11-19T16:43:13Z",
        "updatedAt" : "2018-11-21T13:59:40Z",
        "lastEditedBy" : "92207535-a44d-4e62-a734-e9ca077fe214",
        "tags" : [
        ]
      }
    ],
    "commit" : "eedc830c82506df430d1273d4a52dc6f4407db0a",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +139,143 @@    Bind(this, f)\n\n  /**\n    * Given a `Resource`, possibly built by composing multiple\n    * `Resource`s monadically, returns the acquired resource, as well"
  },
  {
    "id" : "1d93d178-97ea-4450-9c6e-075131c76398",
    "prId" : 419,
    "prUrl" : "https://github.com/typelevel/cats-effect/pull/419#pullrequestreview-176402626",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4ac9d627-f2f2-426b-be3f-dd5f762ebb45",
        "parentId" : null,
        "authorId" : "efc45bfc-463c-4c9e-946d-ad472fabc9f0",
        "body" : "At a cursory look, what jumps out at me is that you're calling `release` here, irregardless of the `ExitCase`. And I thought the purpose of `allocate` is to not call release, but to save it for later.\r\n\r\nAm I missing something?",
        "createdAt" : "2018-11-19T17:03:07Z",
        "updatedAt" : "2018-11-21T13:59:40Z",
        "lastEditedBy" : "efc45bfc-463c-4c9e-946d-ad472fabc9f0",
        "tags" : [
        ]
      },
      {
        "id" : "99ea8894-5a8a-4005-a889-add268fe3aa7",
        "parentId" : "4ac9d627-f2f2-426b-be3f-dd5f762ebb45",
        "authorId" : "a5a514ff-cd89-45cb-bcc8-796f0fa2a445",
        "body" : "it's a `bracketCase`, not `bracket`. I'm calling release if the outer `F` fails or is interrupted during the process of acquiring resources, but if it completes properly, I then return the finaliser.\r\nThe rationale is here https://github.com/typelevel/cats-effect/pull/419/files#diff-ca16b2d95f362b8bc9b6c405f858be0cR146",
        "createdAt" : "2018-11-19T17:04:55Z",
        "updatedAt" : "2018-11-21T13:59:40Z",
        "lastEditedBy" : "a5a514ff-cd89-45cb-bcc8-796f0fa2a445",
        "tags" : [
        ]
      },
      {
        "id" : "afc9c5b6-9613-435b-bad1-7ef04e077e52",
        "parentId" : "4ac9d627-f2f2-426b-be3f-dd5f762ebb45",
        "authorId" : "efc45bfc-463c-4c9e-946d-ad472fabc9f0",
        "body" : "Ah, sorry, this is in case it isn't `Completed`.",
        "createdAt" : "2018-11-19T17:07:36Z",
        "updatedAt" : "2018-11-21T13:59:40Z",
        "lastEditedBy" : "efc45bfc-463c-4c9e-946d-ad472fabc9f0",
        "tags" : [
        ]
      }
    ],
    "commit" : "eedc830c82506df430d1273d4a52dc6f4407db0a",
    "line" : 55,
    "diffHunk" : "@@ -1,1 +189,193 @@              F.unit\n            case ((_, release), ec) =>\n              release(ec)\n          }\n        case Resource.Bind(source, f0) =>"
  },
  {
    "id" : "4055006c-08cf-450c-8679-fee55b47f234",
    "prId" : 188,
    "prUrl" : "https://github.com/typelevel/cats-effect/pull/188#pullrequestreview-115413637",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f76f2d56-7f1a-4ad3-b355-a8c5c6bd47cd",
        "parentId" : null,
        "authorId" : "19f1b7b0-eaed-49a1-9ac5-80ac65598c75",
        "body" : "I tried making this a final class with a `val allocate`, but I couldn't get the scaladoc on the `allocate` member.",
        "createdAt" : "2018-04-20T02:22:48Z",
        "updatedAt" : "2018-05-07T19:42:45Z",
        "lastEditedBy" : "19f1b7b0-eaed-49a1-9ac5-80ac65598c75",
        "tags" : [
        ]
      },
      {
        "id" : "abb1c273-4255-403a-a31b-d8fafef65d48",
        "parentId" : "f76f2d56-7f1a-4ad3-b355-a8c5c6bd47cd",
        "authorId" : "83ab113f-c154-4a9d-bfce-e6c8d65cfb99",
        "body" : "Is there a performance difference (JIT, allocations, bytecode etc) that make a final class formulation worthwhile?",
        "createdAt" : "2018-04-25T19:25:19Z",
        "updatedAt" : "2018-05-07T19:42:45Z",
        "lastEditedBy" : "83ab113f-c154-4a9d-bfce-e6c8d65cfb99",
        "tags" : [
        ]
      },
      {
        "id" : "4100ae5f-40b9-4fa9-a679-edf4b083c730",
        "parentId" : "f76f2d56-7f1a-4ad3-b355-a8c5c6bd47cd",
        "authorId" : "19f1b7b0-eaed-49a1-9ac5-80ac65598c75",
        "body" : "I have not measured, but I think this encoding looks a lot like the [\"single type case\" in this blog](https://shipilev.net/blog/2015/black-magic-method-dispatch/#_single_type).  The JVM is quite clever about these.  I don't expect a significant difference, but could probably find time for a benchmark tomorrow.\r\n\r\nI regret that scaladoc is driving the encoding.  We can get the scaladoc we want if we make it a case class.  But then we get equality, toString, etc. that don't make sense for an effect.",
        "createdAt" : "2018-04-26T02:30:23Z",
        "updatedAt" : "2018-05-07T19:42:45Z",
        "lastEditedBy" : "19f1b7b0-eaed-49a1-9ac5-80ac65598c75",
        "tags" : [
        ]
      }
    ],
    "commit" : "d0353acea53c61a0bee141b1612c4393fc895a22",
    "line" : 54,
    "diffHunk" : "@@ -1,1 +52,56 @@  * @tparam A the type of resource\n  */\nsealed abstract class Resource[F[_], A] {\n  /** An effect that returns a tuple of a resource and an effect to\n    * release it."
  },
  {
    "id" : "29af89dd-8ab1-41d7-b60d-20b321ace9ec",
    "prId" : 188,
    "prUrl" : "https://github.com/typelevel/cats-effect/pull/188#pullrequestreview-113832826",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0e8688e6-4ed7-48c4-b4c0-fb29ac78767e",
        "parentId" : null,
        "authorId" : "19f1b7b0-eaed-49a1-9ac5-80ac65598c75",
        "body" : "fs2 and monix are the two things I have in mind with this comment.  I didn't want to make one the favorite, or make both the favorite over a third option.  Too vague?\r\n\r\nIt would be great to show an example of this in a tut, and why it's different from a single-output bracket.  I'm not excited about reinventing a dumber Stream/Iterant.  Maybe this concept is better explained in fs2 and monix docs?",
        "createdAt" : "2018-04-20T02:27:27Z",
        "updatedAt" : "2018-05-07T19:42:45Z",
        "lastEditedBy" : "19f1b7b0-eaed-49a1-9ac5-80ac65598c75",
        "tags" : [
        ]
      }
    ],
    "commit" : "d0353acea53c61a0bee141b1612c4393fc895a22",
    "line" : 59,
    "diffHunk" : "@@ -1,1 +57,61 @@    *\n    * Streaming types might implement a bracket operation that keeps\n    * the resource open through multiple outputs of a stream.\n    */\n  def allocate: F[(A, F[Unit])]"
  },
  {
    "id" : "bf3219b6-97b5-4872-b904-986f84038618",
    "prId" : 188,
    "prUrl" : "https://github.com/typelevel/cats-effect/pull/188#pullrequestreview-115318060",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1d475a7f-cd35-48e3-9c6f-e9d3398071cc",
        "parentId" : null,
        "authorId" : "efc45bfc-463c-4c9e-946d-ad472fabc9f0",
        "body" : "Describing the `release` via an `F[Unit]` is not sufficient, for the reasons we talked about in the `Bracket` PR. When doing the release, we also need an `ExitCode` to differentiate cancelation from normal termination or errors.\r\n\r\nThat's because cancelation might require extra multi-threading synchronization or even different logic.",
        "createdAt" : "2018-04-20T13:42:47Z",
        "updatedAt" : "2018-05-07T19:42:45Z",
        "lastEditedBy" : "efc45bfc-463c-4c9e-946d-ad472fabc9f0",
        "tags" : [
        ]
      },
      {
        "id" : "dabac478-7646-4c23-8b7e-ed46a19a4922",
        "parentId" : "1d475a7f-cd35-48e3-9c6f-e9d3398071cc",
        "authorId" : "e856ded5-89e9-4e09-937c-311c66e1f1a6",
        "body" : "Note that requiring an `ExitCase` will make this not usable with FS2 unless we adopt `ExitCase` throughout the internal algebra.",
        "createdAt" : "2018-04-20T13:46:19Z",
        "updatedAt" : "2018-05-07T19:42:45Z",
        "lastEditedBy" : "e856ded5-89e9-4e09-937c-311c66e1f1a6",
        "tags" : [
        ]
      },
      {
        "id" : "66db1c7f-e45b-4375-b43c-c83ba3db8e30",
        "parentId" : "1d475a7f-cd35-48e3-9c6f-e9d3398071cc",
        "authorId" : "efc45bfc-463c-4c9e-946d-ad472fabc9f0",
        "body" : "M'kay, well, I guess that working with `F[Unit]` makes it less flexible, but it's still usable.",
        "createdAt" : "2018-04-20T13:57:32Z",
        "updatedAt" : "2018-05-07T19:42:45Z",
        "lastEditedBy" : "efc45bfc-463c-4c9e-946d-ad472fabc9f0",
        "tags" : [
        ]
      },
      {
        "id" : "637ddf73-ac1b-4588-8c13-3fcdbcf8113b",
        "parentId" : "1d475a7f-cd35-48e3-9c6f-e9d3398071cc",
        "authorId" : "efc45bfc-463c-4c9e-946d-ad472fabc9f0",
        "body" : "Just as a follow up after playing with `Iterant` — `ExitCase` is less useful for streams because an `Error` case can easily turn into a `Canceled` when using `flatMap`, at least with `Iterant` usage, because its internal algebra also uses `F[Unit]` to model \"early stop\". And an \"early stop\" event is also not concurrent, but deterministic, so there's no need for synchronization.",
        "createdAt" : "2018-04-20T15:24:27Z",
        "updatedAt" : "2018-05-07T19:42:45Z",
        "lastEditedBy" : "efc45bfc-463c-4c9e-946d-ad472fabc9f0",
        "tags" : [
        ]
      },
      {
        "id" : "98ae1b60-774b-48bb-af9a-72852a8ad7b4",
        "parentId" : "1d475a7f-cd35-48e3-9c6f-e9d3398071cc",
        "authorId" : "19f1b7b0-eaed-49a1-9ac5-80ac65598c75",
        "body" : "`ExitCase` comes up again if we try to go deeper in the hierarchy.  Is a `Bracket[Resource[F, ?], E]` useful?  My two motivators are the monad instance and the easy adaptation to streaming bracket semantics.",
        "createdAt" : "2018-04-20T15:32:49Z",
        "updatedAt" : "2018-05-07T19:42:45Z",
        "lastEditedBy" : "19f1b7b0-eaed-49a1-9ac5-80ac65598c75",
        "tags" : [
        ]
      },
      {
        "id" : "81785a8b-d9bb-456b-a558-cac4aaf7c5d8",
        "parentId" : "1d475a7f-cd35-48e3-9c6f-e9d3398071cc",
        "authorId" : "83ab113f-c154-4a9d-bfce-e6c8d65cfb99",
        "body" : "I don’t find any instance stronger than Monad necessary, as error handling and bracketing will be handled in F, and Resource will probably only be used for composition.",
        "createdAt" : "2018-04-25T19:16:02Z",
        "updatedAt" : "2018-05-07T19:42:45Z",
        "lastEditedBy" : "83ab113f-c154-4a9d-bfce-e6c8d65cfb99",
        "tags" : [
        ]
      }
    ],
    "commit" : "d0353acea53c61a0bee141b1612c4393fc895a22",
    "line" : 61,
    "diffHunk" : "@@ -1,1 +59,63 @@    * the resource open through multiple outputs of a stream.\n    */\n  def allocate: F[(A, F[Unit])]\n\n  /**"
  }
]
[
  {
    "id" : "92873a8e-94c3-426b-b8c5-aec61f9812c6",
    "prId" : 232,
    "prUrl" : "https://github.com/typelevel/cats-effect/pull/232#pullrequestreview-121647532",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f921feb4-9c2f-4e2a-a1f3-b12530d7b08f",
        "parentId" : null,
        "authorId" : "b93e2985-c394-41e6-a036-b46320cfbf21",
        "body" : "Do we need to shift both? Isnâ€™t shifting just fa enough?",
        "createdAt" : "2018-05-20T15:50:04Z",
        "updatedAt" : "2018-05-22T13:39:01Z",
        "lastEditedBy" : "b93e2985-c394-41e6-a036-b46320cfbf21",
        "tags" : [
        ]
      }
    ],
    "commit" : "010d6d7b9aa78233caabf17f7d14a68a4ea251f7",
    "line" : 28,
    "diffHunk" : "@@ -1,1 +58,62 @@\n          IORunLoop.startCancelable(timer.shift *> fa, connA, callbackA(connB))\n          IORunLoop.startCancelable(timer.shift *> fb, connB, callbackB(connA))\n        }\n"
  },
  {
    "id" : "0593ed19-e99d-4123-b7b8-c64372a8ce39",
    "prId" : 115,
    "prUrl" : "https://github.com/typelevel/cats-effect/pull/115#pullrequestreview-89133765",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d1ce762b-e572-4b13-a491-ec06d237be5e",
        "parentId" : null,
        "authorId" : "f03705f3-792d-4b36-bfdf-380cd6f2af9a",
        "body" : "Why is this `asInstanceOf` necessary?",
        "createdAt" : "2018-01-16T15:08:18Z",
        "updatedAt" : "2018-01-17T15:56:11Z",
        "lastEditedBy" : "f03705f3-792d-4b36-bfdf-380cd6f2af9a",
        "tags" : [
        ]
      },
      {
        "id" : "c55395ef-cdc9-42b5-88bb-4beded971eda",
        "parentId" : "d1ce762b-e572-4b13-a491-ec06d237be5e",
        "authorId" : "efc45bfc-463c-4c9e-946d-ad472fabc9f0",
        "body" : "Because I want to reuse that value, as I know it's correct, but the compiler isn't smart enough ðŸ™ƒ\r\n\r\n```\r\n[error] cats-effect/core/shared/src/main/scala/cats/effect/internals/IOParMap.scala:48:26: type mismatch;\r\n[error]  found   : scala.util.Left[Throwable,B]\r\n[error]  required: Either[Throwable,C]\r\n[error]                       cb(error)\r\n[error]                          ^\r\n```",
        "createdAt" : "2018-01-16T15:24:19Z",
        "updatedAt" : "2018-01-17T15:56:11Z",
        "lastEditedBy" : "efc45bfc-463c-4c9e-946d-ad472fabc9f0",
        "tags" : [
        ]
      }
    ],
    "commit" : "122405f51b33642b9afbd688cea417654558b29c",
    "line" : 48,
    "diffHunk" : "@@ -1,1 +46,50 @@                      cb(try Right(f(a, b)) catch { case NonFatal(e) => Left(e) })\n                    case error @ Left(_) =>\n                      cb(error.asInstanceOf[Left[Throwable, C]])\n                  }\n                case left @ Left(e1) =>"
  },
  {
    "id" : "8e262c7d-88fb-4690-8dd7-020f8270695c",
    "prId" : 115,
    "prUrl" : "https://github.com/typelevel/cats-effect/pull/115#pullrequestreview-89132373",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3ac5795c-2ea8-43c2-a5cc-942d2cec6433",
        "parentId" : null,
        "authorId" : "f03705f3-792d-4b36-bfdf-380cd6f2af9a",
        "body" : "These blocks are due to `Either[Either[Throwable, A], Either[Throwable, B]]` as we expect asynchronously to expect both values, if we already have a State of an `A` set it should be impossible to receive another?",
        "createdAt" : "2018-01-16T15:10:14Z",
        "updatedAt" : "2018-01-17T15:56:11Z",
        "lastEditedBy" : "f03705f3-792d-4b36-bfdf-380cd6f2af9a",
        "tags" : [
        ]
      },
      {
        "id" : "b0e0257b-e1c9-42da-93a9-90815b37e1ce",
        "parentId" : "3ac5795c-2ea8-43c2-a5cc-942d2cec6433",
        "authorId" : "efc45bfc-463c-4c9e-946d-ad472fabc9f0",
        "body" : "So these cannot happen if the `IO.async` callback contract is respected, if that callback gets called at most once.\r\n\r\nBut the protocol can get violated, as the type system can't prevent it. Well, not by users because they are protected by that callback wrapper (`IOPlatform.onceOnly`) injected in `IO.async`. But if you workaround the library's encapsulation, or by mistakes from the library authors, then it's possible.",
        "createdAt" : "2018-01-16T15:20:37Z",
        "updatedAt" : "2018-01-17T15:56:11Z",
        "lastEditedBy" : "efc45bfc-463c-4c9e-946d-ad472fabc9f0",
        "tags" : [
        ]
      }
    ],
    "commit" : "122405f51b33642b9afbd688cea417654558b29c",
    "line" : 67,
    "diffHunk" : "@@ -1,1 +65,69 @@              case null => () // wait for B\n              case Right(attemptB) => complete(attemptA, attemptB)\n              case left =>\n                // $COVERAGE-OFF$\n                throw new IllegalStateException(s\"parMap: $left\")"
  },
  {
    "id" : "66b1cbda-e8b7-48d1-8586-21ab2eb446d1",
    "prId" : 115,
    "prUrl" : "https://github.com/typelevel/cats-effect/pull/115#pullrequestreview-89136884",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e9d8174d-6a4b-4640-9392-11075d50295a",
        "parentId" : null,
        "authorId" : "f03705f3-792d-4b36-bfdf-380cd6f2af9a",
        "body" : "This is what restores the error handling behavior, as our case `NonFatal(e) => Left(e)` enables the recovery from the eventual possible failure conditions within `IO.async`?",
        "createdAt" : "2018-01-16T15:15:38Z",
        "updatedAt" : "2018-01-17T15:56:11Z",
        "lastEditedBy" : "f03705f3-792d-4b36-bfdf-380cd6f2af9a",
        "tags" : [
        ]
      },
      {
        "id" : "d2838fcd-0356-4b31-a951-71c288edcb21",
        "parentId" : "e9d8174d-6a4b-4640-9392-11075d50295a",
        "authorId" : "efc45bfc-463c-4c9e-946d-ad472fabc9f0",
        "body" : "IMO I wouldn't leave `IO.async` to catch exceptions. Currently the exception handling is reliable due to being protected by `IOPlatform.onlyOnce`, but that requires extra synchronization.\r\n\r\nIn Monix there is no `onlyOnce` backed by an `AtomicReference`, that check being only a plain variable. And in this case what happens is that the error simply gets reported with the provided `Scheduler` and thus it can't be recovered. From a usability perspective I find that reasonable, as the user is given a callback and you can't expect a `Task` to complete without ensuring that the callback gets called. \r\n\r\nAlso in this particular case that error is triggered asynchronously. It might happen from another thread, depending on the `IO` values it evaluated. So it won't be caught by `IO.async`.",
        "createdAt" : "2018-01-16T15:31:54Z",
        "updatedAt" : "2018-01-17T15:56:11Z",
        "lastEditedBy" : "efc45bfc-463c-4c9e-946d-ad472fabc9f0",
        "tags" : [
        ]
      }
    ],
    "commit" : "122405f51b33642b9afbd688cea417654558b29c",
    "line" : 46,
    "diffHunk" : "@@ -1,1 +44,48 @@                  rb match {\n                    case Right(b) =>\n                      cb(try Right(f(a, b)) catch { case NonFatal(e) => Left(e) })\n                    case error @ Left(_) =>\n                      cb(error.asInstanceOf[Left[Throwable, C]])"
  }
]
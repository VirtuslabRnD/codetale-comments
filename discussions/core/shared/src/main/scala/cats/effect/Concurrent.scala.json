[
  {
    "id" : "925f9610-dae1-48fe-990f-2ea245085e23",
    "prId" : 799,
    "prUrl" : "https://github.com/typelevel/cats-effect/pull/799#pullrequestreview-366807812",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6fbb0f55-bbc7-4de2-8446-007f5f376ac5",
        "parentId" : null,
        "authorId" : "a680c99b-0d47-47f6-a175-cad1562111ac",
        "body" : "I feel like we could remove this `attempt` if we can make the following assumption for generic code:\r\n\r\nAFAIK `F#start` can only fail with something like `RejectedExecutionException` before creating the fiber for cats IO and Monix Task. It returns `UIO` for ZIO and Monix BIO so `attempt` won't do anything there",
        "createdAt" : "2020-02-29T16:29:59Z",
        "updatedAt" : "2020-02-29T16:29:59Z",
        "lastEditedBy" : "a680c99b-0d47-47f6-a175-cad1562111ac",
        "tags" : [
        ]
      },
      {
        "id" : "e6e47b18-c37f-4f8f-b24a-a5edde45cc7c",
        "parentId" : "6fbb0f55-bbc7-4de2-8446-007f5f376ac5",
        "authorId" : "df537f5b-c150-4710-8eb4-40b8b59c3bcc",
        "body" : "Removing this `attempt` causes this test to fail:\r\n\r\n```scala\r\n\r\n  testAsync(\"Concurrent.continual behaves like handleErrorWith on errors\") { implicit ec =>\r\n    implicit val cs: ContextShift[IO] = ec.ioContextShift\r\n\r\n    val ex = new Exception(\"boom\")\r\n    val task = IO.raiseError[Unit](ex).continual(n => IO(n.swap.toOption.get))\r\n\r\n    val f = task.unsafeToFuture()\r\n    ec.tick()\r\n    f.value shouldBe Some(Success(ex))\r\n  }\r\n\r\n```\r\n\r\nI think it's because if `fiber` fails, `fiber.join.guaranteeCase` will also fail and we won't get the result from the Deferred (which would be a `Left[Throwable]`, so a valid `Either[Throwable, B]`), but a failed effect.\r\n\r\nSo it's not about `start` failing, but `use` failing due to the fiber failing in the future :)",
        "createdAt" : "2020-02-29T16:42:42Z",
        "updatedAt" : "2020-02-29T16:43:09Z",
        "lastEditedBy" : "df537f5b-c150-4710-8eb4-40b8b59c3bcc",
        "tags" : [
        ]
      },
      {
        "id" : "11f5c8a0-d2cd-45ae-b48a-86a86756a029",
        "parentId" : "6fbb0f55-bbc7-4de2-8446-007f5f376ac5",
        "authorId" : "a680c99b-0d47-47f6-a175-cad1562111ac",
        "body" : "Ah, right, I've forgotten about `fa` ðŸ˜… ",
        "createdAt" : "2020-02-29T16:54:44Z",
        "updatedAt" : "2020-02-29T16:54:45Z",
        "lastEditedBy" : "a680c99b-0d47-47f6-a175-cad1562111ac",
        "tags" : [
        ]
      }
    ],
    "commit" : "78a41930ab5da9d79e07f246e0ad45e3feff1172",
    "line" : 29,
    "diffHunk" : "@@ -1,1 +619,623 @@          fiber.cancel\n        case _ => F.unit\n      }.attempt *> r.get.rethrow\n    }\n  }"
  },
  {
    "id" : "0c25ed17-5eaf-4650-942e-95b86cfc8be6",
    "prId" : 537,
    "prUrl" : "https://github.com/typelevel/cats-effect/pull/537#pullrequestreview-242017263",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5faf7d40-7b74-406c-8bba-895b21563af0",
        "parentId" : null,
        "authorId" : "19f1b7b0-eaed-49a1-9ac5-80ac65598c75",
        "body" : "Standardized spelling\r\n\r\n```suggestion\r\n    * Lazily memoizes `f`. Assuming no cancellation happens, the effect\r\n```",
        "createdAt" : "2019-05-25T19:39:25Z",
        "updatedAt" : "2019-05-25T19:54:44Z",
        "lastEditedBy" : "19f1b7b0-eaed-49a1-9ac5-80ac65598c75",
        "tags" : [
        ]
      },
      {
        "id" : "0bd96c43-7f37-4a9a-863e-d9587345cc74",
        "parentId" : "5faf7d40-7b74-406c-8bba-895b21563af0",
        "authorId" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "body" : "*twitches*",
        "createdAt" : "2019-05-25T20:25:56Z",
        "updatedAt" : "2019-05-25T20:25:56Z",
        "lastEditedBy" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "tags" : [
        ]
      },
      {
        "id" : "f581c98d-525a-4604-9e1a-e503ce1bfc05",
        "parentId" : "5faf7d40-7b74-406c-8bba-895b21563af0",
        "authorId" : "19f1b7b0-eaed-49a1-9ac5-80ac65598c75",
        "body" : ":us: :fireworks: :statue_of_liberty:",
        "createdAt" : "2019-05-25T22:23:01Z",
        "updatedAt" : "2019-05-25T22:28:56Z",
        "lastEditedBy" : "19f1b7b0-eaed-49a1-9ac5-80ac65598c75",
        "tags" : [
        ]
      }
    ],
    "commit" : "61c62f87650d5eb2d30b00e1083828e95e73f09d",
    "line" : 15,
    "diffHunk" : "@@ -1,1 +355,359 @@\n  /**\n    * Lazily memoizes `f`. Assuming no cancelation happens, the effect\n    * `f` will be performed at most once for every time the returned\n    * `F[F[A]]` is bound (when the inner `F[A]` is bound the first"
  },
  {
    "id" : "0fedca04-bacd-42e7-a9b1-e8ab277bc295",
    "prId" : 537,
    "prUrl" : "https://github.com/typelevel/cats-effect/pull/537#pullrequestreview-242013658",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9350a881-024c-437e-95c0-3e2e57d4736d",
        "parentId" : null,
        "authorId" : "19f1b7b0-eaed-49a1-9ac5-80ac65598c75",
        "body" : "```suggestion\r\n    * which does not allow cancellation.\r\n```",
        "createdAt" : "2019-05-25T19:40:32Z",
        "updatedAt" : "2019-05-25T19:54:45Z",
        "lastEditedBy" : "19f1b7b0-eaed-49a1-9ac5-80ac65598c75",
        "tags" : [
        ]
      }
    ],
    "commit" : "61c62f87650d5eb2d30b00e1083828e95e73f09d",
    "line" : 30,
    "diffHunk" : "@@ -1,1 +369,373 @@    *\n    * You can look at `Async.memoize` for a version of this function\n    * which does not allow cancelation.\n    */\n  def memoize[F[_], A](f: F[A])(implicit F: Concurrent[F]): F[F[A]] = {"
  },
  {
    "id" : "eb08c7e6-f103-492b-a06a-119f44679970",
    "prId" : 537,
    "prUrl" : "https://github.com/typelevel/cats-effect/pull/537#pullrequestreview-242017263",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "51bdc916-1bb0-45fb-be72-d8850b00f82e",
        "parentId" : null,
        "authorId" : "19f1b7b0-eaed-49a1-9ac5-80ac65598c75",
        "body" : "I wish we'd called this `fa` but I don't care enough to do the `@deprecatedName` dance.",
        "createdAt" : "2019-05-25T19:41:09Z",
        "updatedAt" : "2019-05-25T19:54:45Z",
        "lastEditedBy" : "19f1b7b0-eaed-49a1-9ac5-80ac65598c75",
        "tags" : [
        ]
      },
      {
        "id" : "7e4d89d4-24b5-49d6-adf2-f9cd6891a7f8",
        "parentId" : "51bdc916-1bb0-45fb-be72-d8850b00f82e",
        "authorId" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "body" : "Any opinions on whether or not we should consider such things valid for our fast-and-loose 2.0 compatibility? I doubt anyone is calling `memoize` with by-name parameters, so in practice this is almost certainly source compatible, but I'm very open to being convinced otherwise.",
        "createdAt" : "2019-05-25T20:27:09Z",
        "updatedAt" : "2019-05-25T20:27:09Z",
        "lastEditedBy" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "tags" : [
        ]
      },
      {
        "id" : "a5094800-3c33-4c9c-84c5-55e937bdae21",
        "parentId" : "51bdc916-1bb0-45fb-be72-d8850b00f82e",
        "authorId" : "19f1b7b0-eaed-49a1-9ac5-80ac65598c75",
        "body" : "I'm okay changing it, but if we do, we should scan for others.\r\n\r\nI was going to be polite and throw in a `@deprecatedName`, but Scala 2.13 deprecates the parameters to Scala 2.12, rendering it mostly useful to Scala itself. :man_shrugging: ",
        "createdAt" : "2019-05-25T22:23:55Z",
        "updatedAt" : "2019-05-25T22:28:56Z",
        "lastEditedBy" : "19f1b7b0-eaed-49a1-9ac5-80ac65598c75",
        "tags" : [
        ]
      }
    ],
    "commit" : "61c62f87650d5eb2d30b00e1083828e95e73f09d",
    "line" : 44,
    "diffHunk" : "@@ -1,1 +371,375 @@    * which does not allow cancelation.\n    */\n  def memoize[F[_], A](f: F[A])(implicit F: Concurrent[F]): F[F[A]] = {\n    sealed trait State\n    case class Subs(n: Int) extends State"
  },
  {
    "id" : "b9d4d563-3add-4193-979c-fc1b41e53649",
    "prId" : 537,
    "prUrl" : "https://github.com/typelevel/cats-effect/pull/537#pullrequestreview-242017263",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b21f5406-7b82-415d-99f1-68869e6d11cf",
        "parentId" : null,
        "authorId" : "19f1b7b0-eaed-49a1-9ac5-80ac65598c75",
        "body" : "I agree this is unreachable, but is it unrecoverable?  Would it corrupt things (further) to return `None -> F.unit` and log a loud warning?",
        "createdAt" : "2019-05-25T19:54:04Z",
        "updatedAt" : "2019-05-25T19:54:45Z",
        "lastEditedBy" : "19f1b7b0-eaed-49a1-9ac5-80ac65598c75",
        "tags" : [
        ]
      },
      {
        "id" : "44914051-ee07-4fe8-a05c-6ab165ba850f",
        "parentId" : "b21f5406-7b82-415d-99f1-68869e6d11cf",
        "authorId" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "body" : "I'm leery about effect types logging. I guess we do it already though in a couple other places?",
        "createdAt" : "2019-05-25T20:28:39Z",
        "updatedAt" : "2019-05-25T20:28:39Z",
        "lastEditedBy" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "tags" : [
        ]
      },
      {
        "id" : "99bdd673-b069-4e1a-9fdf-9bf1f1e435bc",
        "parentId" : "b21f5406-7b82-415d-99f1-68869e6d11cf",
        "authorId" : "19f1b7b0-eaed-49a1-9ac5-80ac65598c75",
        "body" : "I'm leery about effect types logging but I'm leerier about applications crashing with fatal errors for cases that we know how to recover from.",
        "createdAt" : "2019-05-25T22:28:41Z",
        "updatedAt" : "2019-05-25T22:28:56Z",
        "lastEditedBy" : "19f1b7b0-eaed-49a1-9ac5-80ac65598c75",
        "tags" : [
        ]
      }
    ],
    "commit" : "61c62f87650d5eb2d30b00e1083828e95e73f09d",
    "line" : 57,
    "diffHunk" : "@@ -1,1 +384,388 @@            state.modify {\n              case None =>\n                throw new AssertionError(\"unreachable\")\n              case s @ Some(Fetch(Done, _, _)) =>\n                s -> F.unit"
  },
  {
    "id" : "7fe18749-5efc-45db-b848-55a68799c849",
    "prId" : 519,
    "prUrl" : "https://github.com/typelevel/cats-effect/pull/519#pullrequestreview-232897239",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3f6335de-56ad-44b6-a400-edc50061d1b8",
        "parentId" : null,
        "authorId" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "body" : "Is there a more efficient implementation of this for `IO`, or other concrete datatypes?",
        "createdAt" : "2019-04-30T22:03:46Z",
        "updatedAt" : "2019-05-25T23:33:10Z",
        "lastEditedBy" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "tags" : [
        ]
      },
      {
        "id" : "a068158f-537a-4fea-afc6-3dd64a146251",
        "parentId" : "3f6335de-56ad-44b6-a400-edc50061d1b8",
        "authorId" : "a5a514ff-cd89-45cb-bcc8-796f0fa2a445",
        "body" : "There are all sorts of things you can do if you allow internal changes, at various levels of ambition. If all you want is `continual`, all you need to do is disable the the interrupt check on `flatMap` (`continual` is equivalent to our previous model without interruptible flatMaps, in which case it's equivalent to `attempt.flatMap`)",
        "createdAt" : "2019-04-30T22:42:45Z",
        "updatedAt" : "2019-05-25T23:33:10Z",
        "lastEditedBy" : "a5a514ff-cd89-45cb-bcc8-796f0fa2a445",
        "tags" : [
        ]
      },
      {
        "id" : "d3e404a8-cb52-4777-ad15-0bc19655d612",
        "parentId" : "3f6335de-56ad-44b6-a400-edc50061d1b8",
        "authorId" : "efc45bfc-463c-4c9e-946d-ad472fabc9f0",
        "body" : "We could implement it more efficiently, yes. It should eventually end up on one of our traits.",
        "createdAt" : "2019-05-02T08:50:56Z",
        "updatedAt" : "2019-05-25T23:33:10Z",
        "lastEditedBy" : "efc45bfc-463c-4c9e-946d-ad472fabc9f0",
        "tags" : [
        ]
      }
    ],
    "commit" : "a7c0acd1d89e82e6edd762fbcda161b93c1d295b",
    "line" : 61,
    "diffHunk" : "@@ -1,1 +525,529 @@   * This is the default [[Concurrent.continual]] implementation.\n   */\n  def continual[F[_], A, B](fa: F[A])(f: Either[Throwable, A] => F[B])\n    (implicit F: Concurrent[F]): F[B] = {\n    import cats.effect.implicits._"
  },
  {
    "id" : "bc82869e-825d-4099-bf70-db0f084832dc",
    "prId" : 519,
    "prUrl" : "https://github.com/typelevel/cats-effect/pull/519#pullrequestreview-232899081",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "46bef992-fab3-41aa-b10c-3d50df737a4a",
        "parentId" : null,
        "authorId" : "efc45bfc-463c-4c9e-946d-ad472fabc9f0",
        "body" : "This obviously breaks binary compatibility on Scala 2.11.\r\n\r\nI'll be glad when we won't have to support Scala 2.11 anymore.",
        "createdAt" : "2019-05-02T08:55:30Z",
        "updatedAt" : "2019-05-25T23:33:10Z",
        "lastEditedBy" : "efc45bfc-463c-4c9e-946d-ad472fabc9f0",
        "tags" : [
        ]
      }
    ],
    "commit" : "a7c0acd1d89e82e6edd762fbcda161b93c1d295b",
    "line" : 49,
    "diffHunk" : "@@ -1,1 +349,353 @@   * companion object.\n   */\n  def continual[A, B](fa: F[A])(f: Either[Throwable, A] => F[B]): F[B] =\n    Concurrent.continual(fa)(f)(this)\n}"
  },
  {
    "id" : "0ce37a6c-c5dc-412d-b528-7a7e6420a91e",
    "prId" : 519,
    "prUrl" : "https://github.com/typelevel/cats-effect/pull/519#pullrequestreview-242014537",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3b53a465-a3b1-41ce-8582-172f3b37bd16",
        "parentId" : null,
        "authorId" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "body" : "This is all very clever and terrifying. I look forward to when we have a more primitive implementation.",
        "createdAt" : "2019-05-25T20:15:50Z",
        "updatedAt" : "2019-05-25T23:33:10Z",
        "lastEditedBy" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "tags" : [
        ]
      }
    ],
    "commit" : "a7c0acd1d89e82e6edd762fbcda161b93c1d295b",
    "line" : 76,
    "diffHunk" : "@@ -1,1 +540,544 @@      )(_ => r.get.void)\n      .flatMap(_ => r.get.rethrow)\n    }\n  }\n"
  },
  {
    "id" : "b38af66a-b3cc-4b38-92be-39ae84c76c52",
    "prId" : 424,
    "prUrl" : "https://github.com/typelevel/cats-effect/pull/424#pullrequestreview-180141976",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "958a66f4-e59f-4ea3-baf3-aac213a05386",
        "parentId" : null,
        "authorId" : "e856ded5-89e9-4e09-937c-311c66e1f1a6",
        "body" : "What guarantees are provided w.r.t. cancelation of the returned action?",
        "createdAt" : "2018-11-26T17:58:26Z",
        "updatedAt" : "2018-11-30T07:16:29Z",
        "lastEditedBy" : "e856ded5-89e9-4e09-937c-311c66e1f1a6",
        "tags" : [
        ]
      },
      {
        "id" : "8130ba22-1204-4e84-804e-aae5166120bf",
        "parentId" : "958a66f4-e59f-4ea3-baf3-aac213a05386",
        "authorId" : "efc45bfc-463c-4c9e-946d-ad472fabc9f0",
        "body" : "This is a very good question.\r\n\r\nI realized that the task generated by the provided generator function should be evaluated uninterruptedly, otherwise it can leak. \r\n\r\nI fixed it and added a ScalaDoc comment about it.\r\n\r\nIt's now using `bracketCase`, which tbh isn't ideal for performance, but it does so only after the first `put` or `take` attempt failed, so it's not on the happy path.",
        "createdAt" : "2018-11-30T07:08:32Z",
        "updatedAt" : "2018-11-30T07:16:29Z",
        "lastEditedBy" : "efc45bfc-463c-4c9e-946d-ad472fabc9f0",
        "tags" : [
        ]
      }
    ],
    "commit" : "456e4f77eecf2037258e5087d655a7d530a67383",
    "line" : 29,
    "diffHunk" : "@@ -1,1 +390,394 @@\n  /**\n   * Function that creates an async and cancelable `F[A]`, similar with\n   * [[Concurrent.cancelable]], but with the semantics of [[Async.asyncF]].\n   *"
  },
  {
    "id" : "689bbba5-7ca3-41b4-b810-3e58d3f9394d",
    "prId" : 328,
    "prUrl" : "https://github.com/typelevel/cats-effect/pull/328#pullrequestreview-150810590",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "76b95095-e26b-4fc9-a1df-03513d3123ba",
        "parentId" : null,
        "authorId" : "b93e2985-c394-41e6-a036-b46320cfbf21",
        "body" : "can't we do this for `Async` as well?",
        "createdAt" : "2018-08-30T01:30:25Z",
        "updatedAt" : "2018-08-30T16:24:18Z",
        "lastEditedBy" : "b93e2985-c394-41e6-a036-b46320cfbf21",
        "tags" : [
        ]
      }
    ],
    "commit" : "43248dc33dfa1e1bb7c42a91ca12ed094324f07d",
    "line" : 19,
    "diffHunk" : "@@ -1,1 +360,364 @@    * Note: `start` can be used for eager memoization.\n    */\n  def memoize[F[_], A](f: F[A])(implicit F: Concurrent[F]): F[F[A]] =\n    Ref.of[F, Option[Deferred[F, Either[Throwable, A]]]](None).map { ref =>\n      Deferred[F, Either[Throwable, A]].flatMap { d =>"
  },
  {
    "id" : "c3a67136-546c-46ec-b2af-b1d03a122264",
    "prId" : 290,
    "prUrl" : "https://github.com/typelevel/cats-effect/pull/290#pullrequestreview-141672522",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9fdb4c0d-02ba-4745-8f11-f1c18838ca4f",
        "parentId" : null,
        "authorId" : "14fa9071-c3b2-4b1b-a7aa-9d7398bdbade",
        "body" : "Why don't we push this override down to `Async[Either[Throwable, ?]]`?",
        "createdAt" : "2018-07-30T09:37:12Z",
        "updatedAt" : "2018-08-05T07:42:16Z",
        "lastEditedBy" : "14fa9071-c3b2-4b1b-a7aa-9d7398bdbade",
        "tags" : [
        ]
      },
      {
        "id" : "682b0b8c-379e-4022-8f5a-7e079998a64f",
        "parentId" : "9fdb4c0d-02ba-4745-8f11-f1c18838ca4f",
        "authorId" : "efc45bfc-463c-4c9e-946d-ad472fabc9f0",
        "body" : "Because `Async` has no such method?",
        "createdAt" : "2018-07-30T09:38:02Z",
        "updatedAt" : "2018-08-05T07:42:16Z",
        "lastEditedBy" : "efc45bfc-463c-4c9e-946d-ad472fabc9f0",
        "tags" : [
        ]
      },
      {
        "id" : "477e026a-9ed5-4cab-9f63-838a850cc3e5",
        "parentId" : "9fdb4c0d-02ba-4745-8f11-f1c18838ca4f",
        "authorId" : "efc45bfc-463c-4c9e-946d-ad472fabc9f0",
        "body" : "In case it wasn't clear, `Async.cancelable` is a function on the `Async` companion object, not on the trait.\r\n\r\nThe intent was to provide a default implementation for the `cancelable` operation in `Concurrent` and if we do that, we might as well expose that default implementation on Async's companion object. \r\n\r\nThe `Async` type class cannot have a `cancelable` operation however because it would be lawless and confusing at the same time (i.e. `Async` can describe non-cancelable data types).",
        "createdAt" : "2018-07-30T09:46:44Z",
        "updatedAt" : "2018-08-05T07:42:16Z",
        "lastEditedBy" : "efc45bfc-463c-4c9e-946d-ad472fabc9f0",
        "tags" : [
        ]
      },
      {
        "id" : "6a4f63ee-977e-4b15-a943-f4986229b492",
        "parentId" : "9fdb4c0d-02ba-4745-8f11-f1c18838ca4f",
        "authorId" : "14fa9071-c3b2-4b1b-a7aa-9d7398bdbade",
        "body" : "Oh, thanks, I really didn't notice that.\r\n\r\nSay, I'm making a library that has some cancelable operations. What constraint should I choose - the `Async[F]`, as least powerful abstraction, or `Concurrent[F]`, which is probably going to be faster?\r\n\r\nAs of this PR, it seems that Async is powerful enough to encode all FFI necessities - in which case, I think, implementations should be able to provide optimized versions. Having two versions of a method for the same purpose isn't going to be less confusing than having just one on a type class.\r\n\r\nOTOH, maybe it doesn't make sense to separate Concurrent and Async. Are there any data types that cannot implement Concurrent, but can implement Async? How would the `Async.cancelable` builder behave for those types?",
        "createdAt" : "2018-07-30T13:44:43Z",
        "updatedAt" : "2018-08-05T07:42:16Z",
        "lastEditedBy" : "14fa9071-c3b2-4b1b-a7aa-9d7398bdbade",
        "tags" : [
        ]
      },
      {
        "id" : "50172636-f12f-40d9-abee-2a94445dc442",
        "parentId" : "9fdb4c0d-02ba-4745-8f11-f1c18838ca4f",
        "authorId" : "efc45bfc-463c-4c9e-946d-ad472fabc9f0",
        "body" : "There are cases in which the data type needs to be cancelable, for example in any race condition, otherwise you can end up with a leak. You cannot describe polymorphic code featuring race conditions without having laws that observe the ability to cancel running tasks.\r\n\r\nIn other words when cancellation logic is just an optimization that's optional, then you can use `Async` (or `Sync` or `Bracket` for that matter, which is exactly what `Resource` is doing), otherwise you need to use `Concurrent`. And when in doubt use `Concurrent`, because you can always relax the requirements later, whereas adding restrictions is always harder from a compatibility point of view.\r\n\r\nIf `Async.cancelable` leads to confusion, I can make it an internal implementation, as the purpose of the PR isn't to expose `Async.cancelable`. But you can think of it like this: \r\n\r\n- it's fine to have a `cancelable` function that's described in terms of `Async`'s `asyncF` and `bracket` because it depends on the behavior of `asyncF` and `bracket`, whatever that behavior is\r\n- it's not fine to expose type class operations without laws and there are very few exceptions to this rule (e.g. `Show`)\r\n\r\nN.B. in my opinion we've been stretching it with `Bracket` being a super-type, due to `bracketCase` and because it needs sub-types like `Concurrent` for turning undefined behavior into lawful behavior. As I said from the start, such decisions end up infecting the whole type class hierarchy if we aren't careful.",
        "createdAt" : "2018-07-30T15:22:41Z",
        "updatedAt" : "2018-08-05T07:42:16Z",
        "lastEditedBy" : "efc45bfc-463c-4c9e-946d-ad472fabc9f0",
        "tags" : [
        ]
      },
      {
        "id" : "618b354d-c6c7-497a-9b78-2e523a6849d0",
        "parentId" : "9fdb4c0d-02ba-4745-8f11-f1c18838ca4f",
        "authorId" : "14fa9071-c3b2-4b1b-a7aa-9d7398bdbade",
        "body" : "> You cannot describe polymorphic code featuring race conditions without having laws that observe the ability to cancel running tasks.\r\n\r\nIndeed :) I was just thinking that maybe - just maybe - asynchronity and concurrency are tied together enough that we should drop Async and have just Concurrent - not vice versa.\r\n\r\nThis is just a thought to explore - I know current implementation of cats IO relies on that separation after the auto-shift, but I still feel that .\r\n\r\n> If Async.cancelable leads to confusion, I can make it an internal implementation, as the purpose of the PR isn't to expose Async.cancelable.\r\n\r\nI think I'd prefer it to be internal, if it's not intended to be available to general public. As that library author above, I would rather not be faced with a choice of suboptimal cancelability vs. heavier constraint and have just one way of making what I intend.\r\n\r\nIn particular, if our own Semaphore/MVar constructors will still require `Concurrent`, we don't get any benefits from having cancelable builder available on `Async`.",
        "createdAt" : "2018-07-30T16:29:23Z",
        "updatedAt" : "2018-08-05T07:42:16Z",
        "lastEditedBy" : "14fa9071-c3b2-4b1b-a7aa-9d7398bdbade",
        "tags" : [
        ]
      },
      {
        "id" : "f8027956-8e72-4da6-b320-1e74c87401bf",
        "parentId" : "9fdb4c0d-02ba-4745-8f11-f1c18838ca4f",
        "authorId" : "efc45bfc-463c-4c9e-946d-ad472fabc9f0",
        "body" : "I see your point. We'll make that function internal for now and reconsider later. It's good to be a little conservative in exposed API anyway.",
        "createdAt" : "2018-07-30T18:56:43Z",
        "updatedAt" : "2018-08-05T07:42:16Z",
        "lastEditedBy" : "efc45bfc-463c-4c9e-946d-ad472fabc9f0",
        "tags" : [
        ]
      },
      {
        "id" : "f8099144-2b74-4ac1-b516-ce744fd7329c",
        "parentId" : "9fdb4c0d-02ba-4745-8f11-f1c18838ca4f",
        "authorId" : "14fa9071-c3b2-4b1b-a7aa-9d7398bdbade",
        "body" : "@alexandru thanks - and for discussion too :-)",
        "createdAt" : "2018-07-30T19:01:12Z",
        "updatedAt" : "2018-08-05T07:42:16Z",
        "lastEditedBy" : "14fa9071-c3b2-4b1b-a7aa-9d7398bdbade",
        "tags" : [
        ]
      }
    ],
    "commit" : "64a853160078b3989b34092016653b552ae997d4",
    "line" : 203,
    "diffHunk" : "@@ -1,1 +410,414 @@    type Fiber[A] = cats.effect.Fiber[EitherT[F, L, ?], A]\n\n    override def cancelable[A](k: (Either[Throwable, A] => Unit) => CancelToken[EitherT[F, L, ?]]): EitherT[F, L, A] =\n      EitherT.liftF(F.cancelable(k.andThen(_.value.map(_ => ()))))(F)\n"
  },
  {
    "id" : "3471c162-a588-48f9-8a7e-fc48294e231b",
    "prId" : 145,
    "prUrl" : "https://github.com/typelevel/cats-effect/pull/145#pullrequestreview-102887009",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f8926663-6416-47e3-a6a4-694a809406f4",
        "parentId" : null,
        "authorId" : "b2cb0b28-3ac6-4c8a-ab19-4d96cb8b70a4",
        "body" : "Also, it seems like no `flatMap` for given `F`. Not sure if it matters.",
        "createdAt" : "2018-03-11T15:14:00Z",
        "updatedAt" : "2018-03-11T15:14:00Z",
        "lastEditedBy" : "b2cb0b28-3ac6-4c8a-ab19-4d96cb8b70a4",
        "tags" : [
        ]
      },
      {
        "id" : "e8401cf6-660e-4bbd-bd8d-d148ff6e2690",
        "parentId" : "f8926663-6416-47e3-a6a4-694a809406f4",
        "authorId" : "f03705f3-792d-4b36-bfdf-380cd6f2af9a",
        "body" : "flatmap should be present from concurrent, although it would need the syntax, from `cats.implicits._` or `cats.syntax.flatMap._`",
        "createdAt" : "2018-03-11T15:28:05Z",
        "updatedAt" : "2018-03-11T15:28:12Z",
        "lastEditedBy" : "f03705f3-792d-4b36-bfdf-380cd6f2af9a",
        "tags" : [
        ]
      },
      {
        "id" : "96faeb80-462b-464e-8550-2df3fc3a6409",
        "parentId" : "f8926663-6416-47e3-a6a4-694a809406f4",
        "authorId" : "efc45bfc-463c-4c9e-946d-ad472fabc9f0",
        "body" : "You can also import `cats.syntax.all._`.\r\n\r\nDo you think we should add all imports necessary in all samples?\r\nI judged that on a case by case basis.",
        "createdAt" : "2018-03-11T15:52:28Z",
        "updatedAt" : "2018-03-11T15:53:02Z",
        "lastEditedBy" : "efc45bfc-463c-4c9e-946d-ad472fabc9f0",
        "tags" : [
        ]
      },
      {
        "id" : "5ff50fba-577e-4b1c-9a15-bfd57794deb9",
        "parentId" : "f8926663-6416-47e3-a6a4-694a809406f4",
        "authorId" : "b2cb0b28-3ac6-4c8a-ab19-4d96cb8b70a4",
        "body" : "That what I wanted to ask. There are no imports for `TimeoutException` and `flatMap syntax`. Does it matter to have a fully compilable snippet or better keep it concise and simple as it is? ",
        "createdAt" : "2018-03-11T16:02:55Z",
        "updatedAt" : "2018-03-11T16:02:55Z",
        "lastEditedBy" : "b2cb0b28-3ac6-4c8a-ab19-4d96cb8b70a4",
        "tags" : [
        ]
      },
      {
        "id" : "e15181bd-8d41-4d35-96fa-18429a0178c6",
        "parentId" : "f8926663-6416-47e3-a6a4-694a809406f4",
        "authorId" : "efc45bfc-463c-4c9e-946d-ad472fabc9f0",
        "body" : "We'll leave it like this for now. If more people start complaining, we'll add them.",
        "createdAt" : "2018-03-11T16:03:37Z",
        "updatedAt" : "2018-03-11T16:03:37Z",
        "lastEditedBy" : "efc45bfc-463c-4c9e-946d-ad472fabc9f0",
        "tags" : [
        ]
      }
    ],
    "commit" : "8cb82f4f00ac4fc9517f30eb9a68fd15486bc162",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +360,364 @@   *     (implicit F: Concurrent[F], timer: Timer[F]): F[A] = {\n   *\n   *      F.race(fa, timer.sleep(after)).flatMap {\n   *        case Left((a, _)) => F.pure(a)\n   *        case Right((_, _)) => fallback"
  },
  {
    "id" : "2231146a-4597-489a-936a-2f259fe2b97c",
    "prId" : 137,
    "prUrl" : "https://github.com/typelevel/cats-effect/pull/137#pullrequestreview-101685040",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1f128cec-d6c3-46e4-9d3b-1da22579e4cd",
        "parentId" : null,
        "authorId" : "b93e2985-c394-41e6-a036-b46320cfbf21",
        "body" : "i wonder if this can actually be on Async. I think you can do this one without cancellation.",
        "createdAt" : "2018-03-06T18:38:57Z",
        "updatedAt" : "2018-03-06T18:50:34Z",
        "lastEditedBy" : "b93e2985-c394-41e6-a036-b46320cfbf21",
        "tags" : [
        ]
      },
      {
        "id" : "b8b1f77d-b8f3-4d22-ab59-068504413c15",
        "parentId" : "1f128cec-d6c3-46e4-9d3b-1da22579e4cd",
        "authorId" : "efc45bfc-463c-4c9e-946d-ad472fabc9f0",
        "body" : "You can do it without cancelation, but it's going to be unsafe because you have no way to cancel the loser and release resources early. It's an optimisation, but a very important one.\r\n\r\nLike `Future.firstCompletedOf` for example â€” people use it, but it's what drove me away from `Future`, because I was doing timeouts with it and my process was crashing.\r\n\r\nI think `Async` should keep its original spirit, being meant for things that don't deal with preemption or race conditions. And `race` is the definition of race conditions ðŸ™‚",
        "createdAt" : "2018-03-06T19:33:45Z",
        "updatedAt" : "2018-03-06T19:33:45Z",
        "lastEditedBy" : "efc45bfc-463c-4c9e-946d-ad472fabc9f0",
        "tags" : [
        ]
      }
    ],
    "commit" : "03317769dbca865d725b3e148a2cc42139af70b4",
    "line" : 66,
    "diffHunk" : "@@ -1,1 +377,381 @@   * the loser automatically on successful results.\n   */\n  def race[A, B](fa: F[A], fb: F[B]): F[Either[A, B]] =\n    flatMap(racePair(fa, fb)) {\n      case Left((a, fiberB)) => map(fiberB.cancel)(_ => Left(a))"
  },
  {
    "id" : "6e098e7c-c3d0-4c75-8fea-340edef94c90",
    "prId" : 137,
    "prUrl" : "https://github.com/typelevel/cats-effect/pull/137#pullrequestreview-101685160",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8bdb361a-beb9-467a-b25b-9ee38a1e3647",
        "parentId" : null,
        "authorId" : "b93e2985-c394-41e6-a036-b46320cfbf21",
        "body" : "maybe you want `.leftCast` here. https://github.com/typelevel/cats/blob/master/core/src/main/scala/cats/syntax/either.scala#L341 so we have an easier time seeing the cast is safe. if you bind `left@Left(_) =>` you can use leftCast.",
        "createdAt" : "2018-03-06T18:41:15Z",
        "updatedAt" : "2018-03-06T18:50:34Z",
        "lastEditedBy" : "b93e2985-c394-41e6-a036-b46320cfbf21",
        "tags" : [
        ]
      },
      {
        "id" : "23e96a93-21d3-4f9b-9c3f-e5222cfa6b33",
        "parentId" : "8bdb361a-beb9-467a-b25b-9ee38a1e3647",
        "authorId" : "efc45bfc-463c-4c9e-946d-ad472fabc9f0",
        "body" : "Ah, nice, thanks.",
        "createdAt" : "2018-03-06T19:34:03Z",
        "updatedAt" : "2018-03-06T19:34:03Z",
        "lastEditedBy" : "efc45bfc-463c-4c9e-946d-ad472fabc9f0",
        "tags" : [
        ]
      }
    ],
    "commit" : "03317769dbca865d725b3e148a2cc42139af70b4",
    "line" : 120,
    "diffHunk" : "@@ -1,1 +480,484 @@          value match {\n            case Left(_) =>\n              fiberB.cancel.map(_ => value.asInstanceOf[Left[L, Nothing]])\n            case Right(r) =>\n              F.pure(Right(Left((r, fiberT[B](fiberB)))))"
  }
]
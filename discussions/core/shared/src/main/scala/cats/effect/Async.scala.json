[
  {
    "id" : "36f234a3-5e84-47dd-aeff-374449af1cf3",
    "prId" : 591,
    "prUrl" : "https://github.com/typelevel/cats-effect/pull/591#pullrequestreview-267482176",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "76c31ebd-4e9f-4c33-bfab-55fc97412e04",
        "parentId" : null,
        "authorId" : "92207535-a44d-4e62-a734-e9ca077fe214",
        "body" : "One thing I wasn't sure of - IO wraps the `f => ...` bit in a concrete class (presumably to reduce lambda allocations?), `IOFromFuture`. Should this do something similar? Does it help at all, since it couldn't be an `object` and would need the `new FFromFuture[F]` construction anyway?",
        "createdAt" : "2019-07-25T18:57:20Z",
        "updatedAt" : "2019-07-26T14:42:50Z",
        "lastEditedBy" : "92207535-a44d-4e62-a734-e9ca077fe214",
        "tags" : [
        ]
      },
      {
        "id" : "87147294-9098-4fd5-aaa9-6242dbbeca55",
        "parentId" : "76c31ebd-4e9f-4c33-bfab-55fc97412e04",
        "authorId" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "body" : "I think this is fine as-is. I'm actually not 100% sure why `IOFromFuture` (and friends) are a thing. It doesn't actually reduce allocations to my knowledge, since there needs to be a synthetic wrapper to put it on the heap *anyway*, so it seems to be more a code organization thing. @alexandru could explain better, for sure.",
        "createdAt" : "2019-07-25T20:17:44Z",
        "updatedAt" : "2019-07-26T14:42:50Z",
        "lastEditedBy" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "tags" : [
        ]
      },
      {
        "id" : "7f1a817a-7354-42e4-a3e6-0dbd7ec9a6d5",
        "parentId" : "76c31ebd-4e9f-4c33-bfab-55fc97412e04",
        "authorId" : "efc45bfc-463c-4c9e-946d-ad472fabc9f0",
        "body" : "Yes, it's a code organization thing. I hate big files.\r\n\r\nThere was also a problem with `.class` files getting too big, a problem on Android that could be avoided if the implementation of the functions was moved in other classes, so for big data types like `IO`, `Task`, `Observable`, etc, I tend to prefer that multi-line functions to be in their own file.",
        "createdAt" : "2019-07-27T21:04:41Z",
        "updatedAt" : "2019-07-27T21:05:00Z",
        "lastEditedBy" : "efc45bfc-463c-4c9e-946d-ad472fabc9f0",
        "tags" : [
        ]
      }
    ],
    "commit" : "8174b67e925fd61ee6741c4557ef861312390f5a",
    "line" : 19,
    "diffHunk" : "@@ -1,1 +279,283 @@\n  def fromFuture[F[_], A](fa: F[Future[A]])(implicit F: Async[F], cs: ContextShift[F]): F[A] =\n    F.guarantee(fa.flatMap(f => f.value match {\n      case Some(result) =>\n        result match {"
  },
  {
    "id" : "8beba96f-4f37-4c8d-8fb5-fef4833e66c0",
    "prId" : 577,
    "prUrl" : "https://github.com/typelevel/cats-effect/pull/577#pullrequestreview-271641200",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "55bc6e8b-94c1-42b6-82da-20030b8b74ac",
        "parentId" : null,
        "authorId" : "f03705f3-792d-4b36-bfdf-380cd6f2af9a",
        "body" : "This uses Monoid.empty, which seems suspicious to me.",
        "createdAt" : "2019-08-06T22:04:31Z",
        "updatedAt" : "2019-08-07T05:29:54Z",
        "lastEditedBy" : "f03705f3-792d-4b36-bfdf-380cd6f2af9a",
        "tags" : [
        ]
      },
      {
        "id" : "b88a2858-31d9-4df4-96aa-3bf0fcd67942",
        "parentId" : "55bc6e8b-94c1-42b6-82da-20030b8b74ac",
        "authorId" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "body" : "I believe `L` is the writer type, which is conventionally a `Monoid` anyway.",
        "createdAt" : "2019-08-06T22:07:38Z",
        "updatedAt" : "2019-08-07T05:29:54Z",
        "lastEditedBy" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "tags" : [
        ]
      }
    ],
    "commit" : "fdc7c513fb97572544b505467ba6542402d99f09",
    "line" : 27,
    "diffHunk" : "@@ -1,1 +497,501 @@\n    override def asyncF[A](k: (Either[Throwable, A] => Unit) => ReaderWriterStateT[F, E, L, S, Unit]): ReaderWriterStateT[F, E, L, S, A] =\n      ReaderWriterStateT((e, s) => F.map(F.asyncF((cb: Either[Throwable, A] => Unit) => F.as(k(cb).run(e, s), ())))(a => (L.empty, s, a)))\n\n    override def async[A](k: (Either[Throwable, A] => Unit) => Unit): ReaderWriterStateT[F, E, L, S, A] ="
  },
  {
    "id" : "ea258604-b028-45dc-94a3-295d0f7199e8",
    "prId" : 498,
    "prUrl" : "https://github.com/typelevel/cats-effect/pull/498#pullrequestreview-217547306",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ec6245c5-961f-42d5-95cd-804150c0837d",
        "parentId" : null,
        "authorId" : "a5a514ff-cd89-45cb-bcc8-796f0fa2a445",
        "body" : "Why are you using `uncancelable` here? That strikes me as a bug",
        "createdAt" : "2019-03-22T00:09:26Z",
        "updatedAt" : "2019-06-10T23:26:18Z",
        "lastEditedBy" : "a5a514ff-cd89-45cb-bcc8-796f0fa2a445",
        "tags" : [
        ]
      },
      {
        "id" : "a72556a2-e493-4c81-a2c3-e6175bc5c494",
        "parentId" : "ec6245c5-961f-42d5-95cd-804150c0837d",
        "authorId" : "f504f061-e798-42b5-9fb8-82b7e19a527d",
        "body" : "I can work with mere `Async` and don't need `Concurrent`. Would you suggest to change that to `Semaphore.apply`?",
        "createdAt" : "2019-03-22T00:10:44Z",
        "updatedAt" : "2019-06-10T23:26:18Z",
        "lastEditedBy" : "f504f061-e798-42b5-9fb8-82b7e19a527d",
        "tags" : [
        ]
      },
      {
        "id" : "65a04a2a-e7a2-4fe4-8831-46cfc67e5b9a",
        "parentId" : "ec6245c5-961f-42d5-95cd-804150c0837d",
        "authorId" : "a5a514ff-cd89-45cb-bcc8-796f0fa2a445",
        "body" : "Yes",
        "createdAt" : "2019-03-22T00:12:44Z",
        "updatedAt" : "2019-06-10T23:26:18Z",
        "lastEditedBy" : "a5a514ff-cd89-45cb-bcc8-796f0fa2a445",
        "tags" : [
        ]
      }
    ],
    "commit" : "152d35fcd83787c0d2a76519ba0b86aa84d37bf4",
    "line" : 18,
    "diffHunk" : "@@ -1,1 +325,329 @@  def parTraverseN[T[_]: Traverse, M[_], F[_], A, B](n: Long)(ta: T[A])(f: A => M[B])(implicit M: Async[M], P: Parallel[M, F]): M[T[B]] =\n    for {\n      semaphore <- Semaphore.uncancelable(n)(M)\n      tb <- ta.parTraverse { a =>\n          semaphore.withPermit(f(a))"
  },
  {
    "id" : "d881537d-254a-47ab-8368-94ebeeb3c154",
    "prId" : 168,
    "prUrl" : "https://github.com/typelevel/cats-effect/pull/168#pullrequestreview-105987495",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "66ecc479-5f4a-4c6e-ab2c-7124acdd58fa",
        "parentId" : null,
        "authorId" : "b93e2985-c394-41e6-a036-b46320cfbf21",
        "body" : "can we write a law on this that they are equivalent? Might be hard to express since they never complete.",
        "createdAt" : "2018-03-22T02:21:06Z",
        "updatedAt" : "2018-04-04T03:55:24Z",
        "lastEditedBy" : "b93e2985-c394-41e6-a036-b46320cfbf21",
        "tags" : [
        ]
      },
      {
        "id" : "e8572a96-cd1c-4631-a029-5d1eeb06ed32",
        "parentId" : "66ecc479-5f4a-4c6e-ab2c-7124acdd58fa",
        "authorId" : "efc45bfc-463c-4c9e-946d-ad472fabc9f0",
        "body" : "The way `Eq[IO]` works in tests makes it possible to test for non-termination. \r\n\r\n`IO` is turned into a `Future`, `TestContext` is triggered and after that `future.value` gets compared. Non-terminating `IO`s will yield a `None`.",
        "createdAt" : "2018-03-22T05:03:14Z",
        "updatedAt" : "2018-04-04T03:55:24Z",
        "lastEditedBy" : "efc45bfc-463c-4c9e-946d-ad472fabc9f0",
        "tags" : [
        ]
      }
    ],
    "commit" : "113b750685ff882ae2cd272cefc6dab6cca5f173",
    "line" : 8,
    "diffHunk" : "@@ -1,1 +130,134 @@    * with a result, being equivalent to `async(_ => ())`\n    */\n  def never[A]: F[A] = async(_ => ())\n\n  /**"
  },
  {
    "id" : "919c3cdd-359e-4c3c-be86-1bd52a7092fe",
    "prId" : 137,
    "prUrl" : "https://github.com/typelevel/cats-effect/pull/137#pullrequestreview-101683504",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "509529b8-cd83-46a2-99cb-2972b7963e6c",
        "parentId" : null,
        "authorId" : "b93e2985-c394-41e6-a036-b46320cfbf21",
        "body" : "should we put this on Async? since some implementations might be better than using async and never calling (for instance we could avoid an allocation for a covariant F that keeps a never value around.",
        "createdAt" : "2018-03-06T18:24:36Z",
        "updatedAt" : "2018-03-06T18:50:34Z",
        "lastEditedBy" : "b93e2985-c394-41e6-a036-b46320cfbf21",
        "tags" : [
        ]
      },
      {
        "id" : "6238b528-8e1f-4edc-bc32-9bfebe3c16cd",
        "parentId" : "509529b8-cd83-46a2-99cb-2972b7963e6c",
        "authorId" : "efc45bfc-463c-4c9e-946d-ad472fabc9f0",
        "body" : "I initially wanted to do it, but adding it on `Async` breaks compatibility and I think we might want to keep binary compatibility for 0.10. Maybe we'll create a ticket for it and after 0.10 we can do it â€” the plans are set in stone though, all this is just tentative.",
        "createdAt" : "2018-03-06T19:29:39Z",
        "updatedAt" : "2018-03-06T19:29:39Z",
        "lastEditedBy" : "efc45bfc-463c-4c9e-946d-ad472fabc9f0",
        "tags" : [
        ]
      }
    ],
    "commit" : "03317769dbca865d725b3e148a2cc42139af70b4",
    "line" : 9,
    "diffHunk" : "@@ -1,1 +150,154 @@   */\n  def never[F[_], A](implicit F: Async[F]): F[A] =\n    F.async(_ => ())\n\n  /**"
  },
  {
    "id" : "023a6041-ce53-4df9-832a-2abf8cc4314a",
    "prId" : 57,
    "prUrl" : "https://github.com/typelevel/cats-effect/pull/57#pullrequestreview-37985548",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "dbe0fb6c-c20a-4d4d-8a69-29af339be8f8",
        "parentId" : null,
        "authorId" : "efc45bfc-463c-4c9e-946d-ad472fabc9f0",
        "body" : "Btw, my only worry is that this creates a cyclic dependency. This code would not be possible to express in languages that don't allow cyclic dependencies, like F#.\r\n\r\nIt isn't necessarily bad, but a comment in the `override def liftIO` of `IO` would be nice.",
        "createdAt" : "2017-05-13T07:14:59Z",
        "updatedAt" : "2017-05-13T07:14:59Z",
        "lastEditedBy" : "efc45bfc-463c-4c9e-946d-ad472fabc9f0",
        "tags" : [
        ]
      },
      {
        "id" : "5b5b7fca-4084-448d-95c1-718c2978baab",
        "parentId" : "dbe0fb6c-c20a-4d4d-8a69-29af339be8f8",
        "authorId" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "body" : "We already have a cyclic dependency via `Effect`, so I'm not too concerned about it.  Also all of the target platforms for Scala support cycles, and when Scala targeted the CLR it emulated the behavior.\r\n\r\nMore documentation does sound good though.",
        "createdAt" : "2017-05-13T18:53:54Z",
        "updatedAt" : "2017-05-13T18:53:54Z",
        "lastEditedBy" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "tags" : [
        ]
      }
    ],
    "commit" : "331b6ec04d1e93bced3d07015a623305738f486e",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +45,49 @@  def async[A](k: (Either[Throwable, A] => Unit) => Unit): F[A]\n\n  def liftIO[A](ioa: IO[A]): F[A] = ioa.to[F](this)\n}\n"
  }
]
[
  {
    "id" : "eef62616-6c16-41be-bca3-67b86462cce2",
    "prId" : 374,
    "prUrl" : "https://github.com/typelevel/cats-effect/pull/374#pullrequestreview-162611643",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ce88f893-ba14-466a-b5c7-6189e2613a9d",
        "parentId" : null,
        "authorId" : "cb0f018a-5103-44a6-b26f-2348d7669137",
        "body" : "`flatMapF`",
        "createdAt" : "2018-10-08T19:37:37Z",
        "updatedAt" : "2018-11-19T09:36:27Z",
        "lastEditedBy" : "cb0f018a-5103-44a6-b26f-2348d7669137",
        "tags" : [
        ]
      }
    ],
    "commit" : "d1a5a409d1f2cad860e8b9bb49a76b72fe011fc7",
    "line" : 33,
    "diffHunk" : "@@ -1,1 +108,112 @@      (release: (A, ExitCase[Throwable]) => EitherT[F, L, Unit]): EitherT[F, L, B] = {\n\n      EitherT.liftF(Ref.of[F, Option[L]](None)).flatMap { ref =>\n          EitherT(\n            F.bracketCase(acquire.value) {"
  },
  {
    "id" : "4bfd1b0f-bc87-4b3f-b016-9650a53a4ad8",
    "prId" : 374,
    "prUrl" : "https://github.com/typelevel/cats-effect/pull/374#pullrequestreview-162611643",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8cbdf314-4e84-4309-aaad-058ed242040c",
        "parentId" : null,
        "authorId" : "cb0f018a-5103-44a6-b26f-2348d7669137",
        "body" : "And here",
        "createdAt" : "2018-10-08T19:39:41Z",
        "updatedAt" : "2018-11-19T09:36:27Z",
        "lastEditedBy" : "cb0f018a-5103-44a6-b26f-2348d7669137",
        "tags" : [
        ]
      }
    ],
    "commit" : "d1a5a409d1f2cad860e8b9bb49a76b72fe011fc7",
    "line" : 69,
    "diffHunk" : "@@ -1,1 +158,162 @@\n      //Boolean represents if release returned None\n      OptionT.liftF(Ref.of[F, Boolean](false)).flatMap { ref =>\n        OptionT(\n          F.bracketCase(acquire.value) {"
  },
  {
    "id" : "68601c67-85f8-4ab2-a81c-40e9735037f4",
    "prId" : 374,
    "prUrl" : "https://github.com/typelevel/cats-effect/pull/374#pullrequestreview-162611643",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fd9d4918-39f2-4e12-b79a-6bfaa13c6c42",
        "parentId" : null,
        "authorId" : "cb0f018a-5103-44a6-b26f-2348d7669137",
        "body" : "And here",
        "createdAt" : "2018-10-08T19:40:20Z",
        "updatedAt" : "2018-11-19T09:36:27Z",
        "lastEditedBy" : "cb0f018a-5103-44a6-b26f-2348d7669137",
        "tags" : [
        ]
      }
    ],
    "commit" : "d1a5a409d1f2cad860e8b9bb49a76b72fe011fc7",
    "line" : 103,
    "diffHunk" : "@@ -1,1 +206,210 @@      (use: A => StateT[F, S, B])\n      (release: (A, ExitCase[Throwable]) => StateT[F, S, Unit]): StateT[F, S, B] =\n        StateT.liftF(Ref.of[F, Option[S]](None)).flatMap { ref =>\n          StateT { startS =>\n            F.bracketCase[(S, A), (S, B)](acquire.run(startS)) { case (s, a) =>"
  },
  {
    "id" : "eee0d40b-98e4-43ee-bd4e-b4295407e803",
    "prId" : 365,
    "prUrl" : "https://github.com/typelevel/cats-effect/pull/365#pullrequestreview-162659149",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3dc1c091-888d-441f-b439-9f4aaf627515",
        "parentId" : null,
        "authorId" : "cb0f018a-5103-44a6-b26f-2348d7669137",
        "body" : "@LukaJCB please review the new `bracketCase` impl",
        "createdAt" : "2018-10-08T22:21:22Z",
        "updatedAt" : "2018-11-25T21:23:09Z",
        "lastEditedBy" : "cb0f018a-5103-44a6-b26f-2348d7669137",
        "tags" : [
        ]
      }
    ],
    "commit" : "eeba43ad796d11acf26c9866e1e52e007cc30e79",
    "line" : 32,
    "diffHunk" : "@@ -1,1 +317,321 @@      IorT.liftF(F.raiseError(e))\n\n    def bracketCase[A, B](acquire: IorT[F, L, A])\n                         (use: A => IorT[F, L, B])\n                         (release: (A, ExitCase[Throwable]) => IorT[F, L, Unit]): IorT[F, L, B] ="
  },
  {
    "id" : "117b23b1-1d12-4c26-b428-5ff7a1dc7c1e",
    "prId" : 365,
    "prUrl" : "https://github.com/typelevel/cats-effect/pull/365#pullrequestreview-178061280",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "93e35638-78f1-4f3a-841b-36f98eceec7b",
        "parentId" : null,
        "authorId" : "d81b9fb1-6c03-41f4-af77-6e45f8c2f7da",
        "body" : "I think this is worth taking a look from maintainers. Keeping the whole `Ior` inside the Ref here is a trade-off if favor of much simpler implementation vs slightly less allocations.\r\nI personally favor @catostrophe's approach, since pattern matching on `Ior` is especially painful and error-prone. @LukaJCB, just raising this so that it doesn't go unnoticed",
        "createdAt" : "2018-10-09T05:50:01Z",
        "updatedAt" : "2018-11-25T21:23:09Z",
        "lastEditedBy" : "d81b9fb1-6c03-41f4-af77-6e45f8c2f7da",
        "tags" : [
        ]
      },
      {
        "id" : "70013283-7d71-4c08-a7bc-3256f28f18db",
        "parentId" : "93e35638-78f1-4f3a-841b-36f98eceec7b",
        "authorId" : "efc45bfc-463c-4c9e-946d-ad472fabc9f0",
        "body" : "You mean we can describe `bracketCase` without the `Ref`?\r\n\r\nThe problem with `Ref` isn't only the extraneous allocations, but also the extra `compareAndSet` operations needed to evolve it.\r\n\r\nIf we can't do it without the `Ref`, that's fine, if the alternative is not having the instance at all.",
        "createdAt" : "2018-11-24T18:57:21Z",
        "updatedAt" : "2018-11-25T21:23:09Z",
        "lastEditedBy" : "efc45bfc-463c-4c9e-946d-ad472fabc9f0",
        "tags" : [
        ]
      },
      {
        "id" : "14e47fdf-47c9-4f29-baee-512b4eb611ad",
        "parentId" : "93e35638-78f1-4f3a-841b-36f98eceec7b",
        "authorId" : "cb0f018a-5103-44a6-b26f-2348d7669137",
        "body" : "The implementation with `Ref` is fine and almost identical to what @LukaJCB did for the other transformers.\r\n\r\nI think the concern regarding the container for extra `IorT` effects has been resolved. @vpavkin agree?",
        "createdAt" : "2018-11-24T19:16:01Z",
        "updatedAt" : "2018-11-25T21:23:09Z",
        "lastEditedBy" : "cb0f018a-5103-44a6-b26f-2348d7669137",
        "tags" : [
        ]
      },
      {
        "id" : "79b06a9b-071c-4b9e-977c-514d7ff65c48",
        "parentId" : "93e35638-78f1-4f3a-841b-36f98eceec7b",
        "authorId" : "d81b9fb1-6c03-41f4-af77-6e45f8c2f7da",
        "body" : "sure! :+1:",
        "createdAt" : "2018-11-24T20:19:41Z",
        "updatedAt" : "2018-11-25T21:23:09Z",
        "lastEditedBy" : "d81b9fb1-6c03-41f4-af77-6e45f8c2f7da",
        "tags" : [
        ]
      }
    ],
    "commit" : "eeba43ad796d11acf26c9866e1e52e007cc30e79",
    "line" : 35,
    "diffHunk" : "@@ -1,1 +320,324 @@                         (use: A => IorT[F, L, B])\n                         (release: (A, ExitCase[Throwable]) => IorT[F, L, Unit]): IorT[F, L, B] =\n      IorT.liftF(Ref[F].of(().rightIor[L])).flatMapF { ref =>\n        F.bracketCase(acquire.value) { ia =>\n          IorT.fromIor[F](ia).flatMap(use).value"
  },
  {
    "id" : "1ca2f5a2-cfce-441f-8ed7-868797da4f79",
    "prId" : 365,
    "prUrl" : "https://github.com/typelevel/cats-effect/pull/365#pullrequestreview-176220777",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "06fef6b2-f29d-4243-b6cb-d94e2f92a5c5",
        "parentId" : null,
        "authorId" : "cb0f018a-5103-44a6-b26f-2348d7669137",
        "body" : "Another dilemma: this one-liner vs direct pattern matching on `Ior`s and mapping on F (see prev version). This one looks simplier, but may require more allocations.",
        "createdAt" : "2018-10-09T05:58:10Z",
        "updatedAt" : "2018-11-25T21:23:09Z",
        "lastEditedBy" : "cb0f018a-5103-44a6-b26f-2348d7669137",
        "tags" : [
        ]
      },
      {
        "id" : "d2fb0d66-bf4a-4104-9408-a119bfda1411",
        "parentId" : "06fef6b2-f29d-4243-b6cb-d94e2f92a5c5",
        "authorId" : "ff78fcf6-a54d-4325-a0c8-d28cc86fb75e",
        "body" : "I think less allocations is always better than more concise code in library code :)\r\nDo we actually know if this allocates more though?",
        "createdAt" : "2018-11-19T10:07:17Z",
        "updatedAt" : "2018-11-25T21:23:09Z",
        "lastEditedBy" : "ff78fcf6-a54d-4325-a0c8-d28cc86fb75e",
        "tags" : [
        ]
      }
    ],
    "commit" : "eeba43ad796d11acf26c9866e1e52e007cc30e79",
    "line" : 37,
    "diffHunk" : "@@ -1,1 +322,326 @@      IorT.liftF(Ref[F].of(().rightIor[L])).flatMapF { ref =>\n        F.bracketCase(acquire.value) { ia =>\n          IorT.fromIor[F](ia).flatMap(use).value\n        } { (ia, ec) =>\n          ia.toOption.fold(F.unit) { a =>"
  },
  {
    "id" : "d363b940-82c2-4426-b9ab-97620b90c246",
    "prId" : 296,
    "prUrl" : "https://github.com/typelevel/cats-effect/pull/296#pullrequestreview-143854261",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5e058f36-d5c0-40a0-a993-8f4317814f55",
        "parentId" : null,
        "authorId" : "e856ded5-89e9-4e09-937c-311c66e1f1a6",
        "body" : "Why is `excludeParents` necessary here?",
        "createdAt" : "2018-08-07T01:41:13Z",
        "updatedAt" : "2018-08-12T17:38:00Z",
        "lastEditedBy" : "e856ded5-89e9-4e09-937c-311c66e1f1a6",
        "tags" : [
        ]
      },
      {
        "id" : "d4fdbb27-1fac-48fb-b6c6-6dba8788e142",
        "parentId" : "5e058f36-d5c0-40a0-a993-8f4317814f55",
        "authorId" : "a680c99b-0d47-47f6-a175-cad1562111ac",
        "body" : "Compiler was complaining with `type AllOps is not a member of object cats.Defer`, I've got fix from https://github.com/mpilquist/simulacrum/issues/38",
        "createdAt" : "2018-08-07T06:24:55Z",
        "updatedAt" : "2018-08-12T17:38:00Z",
        "lastEditedBy" : "a680c99b-0d47-47f6-a175-cad1562111ac",
        "tags" : [
        ]
      }
    ],
    "commit" : "944a19ff47d8b76b5e3f16bc5e067d8dd8866d89",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +26,30 @@ * in the `F[_]` context.\n */\n@typeclass(excludeParents = List(\"Defer\"))\ntrait Sync[F[_]] extends Bracket[F, Throwable] with Defer[F] {\n  /**"
  },
  {
    "id" : "446a59e0-3d88-4569-b4b7-86ceafde30ab",
    "prId" : 80,
    "prUrl" : "https://github.com/typelevel/cats-effect/pull/80#pullrequestreview-73422080",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5466095e-14e7-4987-8c09-0174ec2a5464",
        "parentId" : null,
        "authorId" : "19f1b7b0-eaed-49a1-9ac5-80ac65598c75",
        "body" : "I have not spent any time whatsoever considering whether the instances can be generalized to `IndexedStateT`.  This is minimal to make it compile.",
        "createdAt" : "2017-10-31T20:09:00Z",
        "updatedAt" : "2017-10-31T20:43:24Z",
        "lastEditedBy" : "19f1b7b0-eaed-49a1-9ac5-80ac65598c75",
        "tags" : [
        ]
      },
      {
        "id" : "6e89a146-08a6-4f48-948d-eb1ddcdf4af9",
        "parentId" : "5466095e-14e7-4987-8c09-0174ec2a5464",
        "authorId" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "body" : "I'm fine sticking with this for the time being.  It seems likely that we'll be able to generalize a bit, but it'll take some looking.",
        "createdAt" : "2017-11-01T09:33:24Z",
        "updatedAt" : "2017-11-01T09:33:24Z",
        "lastEditedBy" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "tags" : [
        ]
      }
    ],
    "commit" : "04df956db3da43c68ee3a337e0b64f0de1277ad2",
    "line" : 23,
    "diffHunk" : "@@ -1,1 +153,157 @@    // overwriting the pre-existing one, since flatMap is guaranteed stack-safe\n    def tailRecM[A, B](a: A)(f: A => StateT[F, S, Either[A, B]]): StateT[F, S, B] =\n      IndexedStateT.catsDataMonadForIndexedStateT[F, S].tailRecM(a)(f)\n\n    def suspend[A](thunk: => StateT[F, S, A]): StateT[F, S, A] ="
  }
]
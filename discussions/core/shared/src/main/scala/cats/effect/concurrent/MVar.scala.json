[
  {
    "id" : "72aec41d-746d-410a-b17d-f3c8aafb6b28",
    "prId" : 739,
    "prUrl" : "https://github.com/typelevel/cats-effect/pull/739#pullrequestreview-358104884",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b5a79dce-33f2-44eb-8ac4-7d69c44f0149",
        "parentId" : null,
        "authorId" : "efc45bfc-463c-4c9e-946d-ad472fabc9f0",
        "body" : "We want to provide good ScalaDocs. I wonder what we can do here, because people are going to be looking at the description of `MVar2`, which has this sentence that has technical implementation details and with no link to `MVar`. And then if they'll take a look at the ScalaDoc for `MVar`, they'll see it as being deprecated.",
        "createdAt" : "2020-02-11T07:26:46Z",
        "updatedAt" : "2020-03-22T21:16:58Z",
        "lastEditedBy" : "efc45bfc-463c-4c9e-946d-ad472fabc9f0",
        "tags" : [
        ]
      },
      {
        "id" : "c65a142b-e0df-49f0-847e-35c98e5147af",
        "parentId" : "b5a79dce-33f2-44eb-8ac4-7d69c44f0149",
        "authorId" : "f6334970-8381-42df-a409-4161feef3eb2",
        "body" : "Good point. It seems there are two ways:\r\n\r\n- Reference both. The downside of it is that tools (IDE helpers) won't give the relevant docs immediately. \r\n- Copy docs from `MVar` to `MVar2`. The downside is maintaining the two copies.\r\n\r\nAre there something else? What do you think?",
        "createdAt" : "2020-02-11T12:15:16Z",
        "updatedAt" : "2020-03-22T21:16:58Z",
        "lastEditedBy" : "f6334970-8381-42df-a409-4161feef3eb2",
        "tags" : [
        ]
      },
      {
        "id" : "f2852a52-5c54-4225-bca9-16d62e3cbd5e",
        "parentId" : "b5a79dce-33f2-44eb-8ac4-7d69c44f0149",
        "authorId" : "efc45bfc-463c-4c9e-946d-ad472fabc9f0",
        "body" : "You can define reusable documentation via `@define` in ScalaDoc.\r\n\r\nAnd definitions get inherited, so if you `@define` something on `MVar`, it should then be available in `MVar2`. And a trick would be to do something like ...\r\n\r\n```scala\r\n/** \r\n  * @define mvarDescription An MVar is a mutable location that can be empty or \r\n  *         contain a value, asynchronously blocking reads when empty and \r\n  *         blocking writes when full.\r\n  * \r\n  *         Use-cases:\r\n  *          - bla bla ...\r\n  */\r\nprivate[concurrent] trait MVarDocs extends Any {}\r\n\r\n/** \r\n  * $mvarDescription\r\n  */\r\nabstract class MVar[F[_], A] extends MVarDocs\r\n\r\n/** \r\n  * $mvarDescription\r\n  */\r\nabstract class MVar2[F[_], A] extends MVar[F, A]\r\n```\r\n\r\nIt's just a template value, so you can add your warning before or after it.",
        "createdAt" : "2020-02-13T07:50:58Z",
        "updatedAt" : "2020-03-22T21:16:58Z",
        "lastEditedBy" : "efc45bfc-463c-4c9e-946d-ad472fabc9f0",
        "tags" : [
        ]
      },
      {
        "id" : "c94a69d5-3bae-4e0e-ba8f-d486441d7cef",
        "parentId" : "b5a79dce-33f2-44eb-8ac4-7d69c44f0149",
        "authorId" : "f6334970-8381-42df-a409-4161feef3eb2",
        "body" : "Ah, it is a great suggestion, thank you. I just added it. \r\n\r\nI have tried to avoid the redundant `trait`, but scaladocs kept crashing with expansion errors.",
        "createdAt" : "2020-02-13T10:26:41Z",
        "updatedAt" : "2020-03-22T21:16:58Z",
        "lastEditedBy" : "f6334970-8381-42df-a409-4161feef3eb2",
        "tags" : [
        ]
      }
    ],
    "commit" : "78cc2810925268ba9fa80982a71c064f442be31f",
    "line" : 49,
    "diffHunk" : "@@ -1,1 +133,137 @@ *\n * The `MVar2` is the successor of `MVar` with [[tryRead]] and [[swap]]. It was implemented separately only to maintain\n * binary compatibility with `MVar`.\n */\n@silent(\"deprecated\")"
  },
  {
    "id" : "d33d8b41-5ad6-4706-857d-cd1d66859763",
    "prId" : 222,
    "prUrl" : "https://github.com/typelevel/cats-effect/pull/222#pullrequestreview-120416359",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "78aff0f2-c4d0-4cc9-80cb-3b40e40bb621",
        "parentId" : null,
        "authorId" : "efc45bfc-463c-4c9e-946d-ad472fabc9f0",
        "body" : "Wouldn't `liftF` be a more appropriate name for `ofF`?\r\n\r\nNot sure, but I see it used in all monad transformers.",
        "createdAt" : "2018-05-15T21:10:53Z",
        "updatedAt" : "2018-05-15T21:10:53Z",
        "lastEditedBy" : "efc45bfc-463c-4c9e-946d-ad472fabc9f0",
        "tags" : [
        ]
      }
    ],
    "commit" : "0aed499d725323e859960c580741d7d73f1a7a40",
    "line" : 70,
    "diffHunk" : "@@ -1,1 +172,176 @@   *        describe cancelable operations\n   */\n  def ofF[F[_], A](fa: F[A])(implicit F: Concurrent[F]): F[MVar[F, A]] =\n    F.map(fa)(MVarConcurrent.apply(_))\n"
  },
  {
    "id" : "2697d62e-27f6-49c4-b68a-665fa59aee76",
    "prId" : 217,
    "prUrl" : "https://github.com/typelevel/cats-effect/pull/217#pullrequestreview-120243812",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "80da29a5-092a-4767-b380-82e7dd04a3f9",
        "parentId" : null,
        "authorId" : "e856ded5-89e9-4e09-937c-311c66e1f1a6",
        "body" : "I like this pattern - can we use it in `Ref` too? Specifically the notion of having both the regular method on companion and then `ApplyBuilders` for the type curried type params.",
        "createdAt" : "2018-05-15T13:54:53Z",
        "updatedAt" : "2018-05-15T13:54:54Z",
        "lastEditedBy" : "e856ded5-89e9-4e09-937c-311c66e1f1a6",
        "tags" : [
        ]
      }
    ],
    "commit" : "18d3161d31290d27bdc5fd3272f296f506bccac3",
    "line" : 112,
    "diffHunk" : "@@ -1,1 +110,114 @@   * @see [[init]], [[initF]] and [[empty]]\n   */\n  def apply[F[_]](implicit F: Concurrent[F]): ApplyBuilders[F] =\n    new ApplyBuilders[F](F)\n"
  }
]
[
  {
    "id" : "1bfc3ceb-e5e6-4cd4-b6a5-f9bb78a52162",
    "prId" : 2041,
    "prUrl" : "https://github.com/typelevel/cats-effect/pull/2041#pullrequestreview-676883383",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a2dd7dd1-47ae-4cec-898f-41bef6c25ca1",
        "parentId" : null,
        "authorId" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "body" : "Sanity-check: do we need to re-interrupt the current thread if we clear the bit here?",
        "createdAt" : "2021-06-06T16:02:27Z",
        "updatedAt" : "2021-06-06T16:07:40Z",
        "lastEditedBy" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "tags" : [
        ]
      },
      {
        "id" : "ea950104-a77b-436e-acc2-911a898d7678",
        "parentId" : "a2dd7dd1-47ae-4cec-898f-41bef6c25ca1",
        "authorId" : "566d094c-978a-46cc-94f5-bc87e03c9fd3",
        "body" : "What do you mean exactly? I do the interruption at the end of this method.",
        "createdAt" : "2021-06-06T16:09:13Z",
        "updatedAt" : "2021-06-06T16:09:13Z",
        "lastEditedBy" : "566d094c-978a-46cc-94f5-bc87e03c9fd3",
        "tags" : [
        ]
      },
      {
        "id" : "7a69ebb1-9701-4d12-9e09-9fc4315ef03a",
        "parentId" : "a2dd7dd1-47ae-4cec-898f-41bef6c25ca1",
        "authorId" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "body" : "Oh, gotcha. Okay then!",
        "createdAt" : "2021-06-06T16:38:13Z",
        "updatedAt" : "2021-06-06T16:38:13Z",
        "lastEditedBy" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "tags" : [
        ]
      }
    ],
    "commit" : "6464c16e0368a06795246da1054253b6e753ed1d",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +1327,1331 @@    // Make sure the shutdown did not interrupt this thread.\n    Thread.interrupted()\n\n    var idx = 0\n    val tables = runtime.fiberErrorCbs.tables"
  },
  {
    "id" : "5ecb5a4a-1bd8-439e-bc49-b0dcfe737f1f",
    "prId" : 1894,
    "prUrl" : "https://github.com/typelevel/cats-effect/pull/1894#pullrequestreview-632752392",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f3ccdd00-eca7-4fff-9ccd-2fe5ab1ae94a",
        "parentId" : null,
        "authorId" : "3f1176f1-791a-4566-8749-308589834168",
        "body" : "That was subtle!",
        "createdAt" : "2021-04-09T20:09:29Z",
        "updatedAt" : "2021-04-09T20:17:46Z",
        "lastEditedBy" : "3f1176f1-791a-4566-8749-308589834168",
        "tags" : [
        ]
      }
    ],
    "commit" : "9236ca48fded9162767bbb6f30ef9956f739ced5",
    "line" : 9,
    "diffHunk" : "@@ -1,1 +1063,1067 @@\n  private[this] def rescheduleFiber(ec: ExecutionContext)(fiber: IOFiber[_]): Unit = {\n    if (ec.isInstanceOf[WorkStealingThreadPool]) {\n      ec.asInstanceOf[WorkStealingThreadPool].rescheduleFiber(fiber)\n    } else {"
  },
  {
    "id" : "109b7732-01bb-4807-97db-a12f6abfa3a8",
    "prId" : 1829,
    "prUrl" : "https://github.com/typelevel/cats-effect/pull/1829#pullrequestreview-622773565",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1207c752-acd8-4b9e-9429-4871486ece39",
        "parentId" : null,
        "authorId" : "566d094c-978a-46cc-94f5-bc87e03c9fd3",
        "body" : "Really nice.",
        "createdAt" : "2021-03-28T19:04:27Z",
        "updatedAt" : "2021-03-28T22:46:51Z",
        "lastEditedBy" : "566d094c-978a-46cc-94f5-bc87e03c9fd3",
        "tags" : [
        ]
      }
    ],
    "commit" : "3931d86bcecf000100431bb9cae034eff0ac0a9d",
    "line" : 41,
    "diffHunk" : "@@ -1,1 +669,673 @@            ()\n          }\n          finalizers.push(fin)\n          conts.push(OnCancelK)\n"
  },
  {
    "id" : "b9acd68b-60c1-4267-95ac-56cdde76c2ee",
    "prId" : 1829,
    "prUrl" : "https://github.com/typelevel/cats-effect/pull/1829#pullrequestreview-622781996",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1925129b-be14-4f98-b5cf-97151c56fb15",
        "parentId" : null,
        "authorId" : "566d094c-978a-46cc-94f5-bc87e03c9fd3",
        "body" : "Just to confirm, `ContState` guards against very late, repeated async invocations, while if `ContState` itself is not completed, the fiber can't be, so the `outcome` check is not needed. Is my intuition correct?",
        "createdAt" : "2021-03-28T19:26:39Z",
        "updatedAt" : "2021-03-28T22:46:51Z",
        "lastEditedBy" : "566d094c-978a-46cc-94f5-bc87e03c9fd3",
        "tags" : [
        ]
      },
      {
        "id" : "1dd96add-fea7-474f-baca-532e9d4abb5c",
        "parentId" : "1925129b-be14-4f98-b5cf-97151c56fb15",
        "authorId" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "body" : "Also the fact that we set `suspended` to `false` in `done`, meaning that you can't `resume()` if `outcome` is non-null.",
        "createdAt" : "2021-03-28T20:52:12Z",
        "updatedAt" : "2021-03-28T22:46:51Z",
        "lastEditedBy" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "tags" : [
        ]
      }
    ],
    "commit" : "3931d86bcecf000100431bb9cae034eff0ac0a9d",
    "line" : 3,
    "diffHunk" : "@@ -1,1 +567,571 @@                // `wasFinalizing` is published\n                if (finalizing == state.wasFinalizing) {\n                  if (!shouldFinalize()) {\n                    /* we weren't canceled or completed, so schedule the runloop for execution */\n                    val ec = currentCtx"
  },
  {
    "id" : "9d78108a-e266-4bfc-989d-3c8a025b83e7",
    "prId" : 1829,
    "prUrl" : "https://github.com/typelevel/cats-effect/pull/1829#pullrequestreview-622775497",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b9f634ec-7784-457c-a4c9-db229f077a6d",
        "parentId" : null,
        "authorId" : "566d094c-978a-46cc-94f5-bc87e03c9fd3",
        "body" : "Nitpicking: the instead of hte, and two lines below, finalizers instead of finalisers.",
        "createdAt" : "2021-03-28T19:29:21Z",
        "updatedAt" : "2021-03-28T22:46:51Z",
        "lastEditedBy" : "566d094c-978a-46cc-94f5-bc87e03c9fd3",
        "tags" : [
        ]
      }
    ],
    "commit" : "3931d86bcecf000100431bb9cae034eff0ac0a9d",
    "line" : 30,
    "diffHunk" : "@@ -1,1 +604,608 @@\n              /*\n               * If we are canceled or completed or in hte process of finalizing\n               * when we previously weren't, just die off and let `cancel` or `get`\n               * win the race to `resume` and run the finalisers."
  },
  {
    "id" : "ba3dbe53-c89c-41ce-94a1-652fc4ac7d2c",
    "prId" : 1829,
    "prUrl" : "https://github.com/typelevel/cats-effect/pull/1829#pullrequestreview-622775521",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "92a7356a-e707-4c82-a7b2-4e657bbc3849",
        "parentId" : null,
        "authorId" : "566d094c-978a-46cc-94f5-bc87e03c9fd3",
        "body" : "Critical fix right here. So glad we found this.",
        "createdAt" : "2021-03-28T19:29:46Z",
        "updatedAt" : "2021-03-28T22:46:51Z",
        "lastEditedBy" : "566d094c-978a-46cc-94f5-bc87e03c9fd3",
        "tags" : [
        ]
      }
    ],
    "commit" : "3931d86bcecf000100431bb9cae034eff0ac0a9d",
    "line" : 53,
    "diffHunk" : "@@ -1,1 +712,716 @@                  asyncCancel(null)\n                else\n                  suspend()\n              }\n            }"
  },
  {
    "id" : "9bdb6b68-745a-457c-9a09-0a03632b775e",
    "prId" : 1829,
    "prUrl" : "https://github.com/typelevel/cats-effect/pull/1829#pullrequestreview-622778968",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "924765b7-5e37-47c6-887d-be90e199a995",
        "parentId" : null,
        "authorId" : "566d094c-978a-46cc-94f5-bc87e03c9fd3",
        "body" : "Question for future development. Is there any chance `outcome` can be non-volatile and published in terms of `suspended`?",
        "createdAt" : "2021-03-28T19:32:06Z",
        "updatedAt" : "2021-03-28T22:46:51Z",
        "lastEditedBy" : "566d094c-978a-46cc-94f5-bc87e03c9fd3",
        "tags" : [
        ]
      },
      {
        "id" : "bfc8b7d1-6594-4206-ba46-00bac05b2827",
        "parentId" : "924765b7-5e37-47c6-887d-be90e199a995",
        "authorId" : "566d094c-978a-46cc-94f5-bc87e03c9fd3",
        "body" : "I'm guessing no because of the interaction with `CallbackStack`.",
        "createdAt" : "2021-03-28T20:13:24Z",
        "updatedAt" : "2021-03-28T22:46:51Z",
        "lastEditedBy" : "566d094c-978a-46cc-94f5-bc87e03c9fd3",
        "tags" : [
        ]
      }
    ],
    "commit" : "3931d86bcecf000100431bb9cae034eff0ac0a9d",
    "line" : 62,
    "diffHunk" : "@@ -1,1 +750,754 @@\n              runLoop(next, nextIteration)\n            } else if (outcome == null) {\n              /*\n               * we were canceled, but `cancel` cannot run the finalisers"
  },
  {
    "id" : "3d117145-2ee5-4d92-8599-6792e963d6dd",
    "prId" : 1773,
    "prUrl" : "https://github.com/typelevel/cats-effect/pull/1773#pullrequestreview-611645783",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "02542f4f-c19d-4faa-b92b-c3468b076606",
        "parentId" : null,
        "authorId" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "body" : "Wait… what? How? Doesn't this break down if you nest multiple `evalOn`s?",
        "createdAt" : "2021-03-13T22:26:35Z",
        "updatedAt" : "2021-03-13T22:26:38Z",
        "lastEditedBy" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "tags" : [
        ]
      },
      {
        "id" : "cdd93bde-ee35-45c7-bbb8-310247cb3700",
        "parentId" : "02542f4f-c19d-4faa-b92b-c3468b076606",
        "authorId" : "566d094c-978a-46cc-94f5-bc87e03c9fd3",
        "body" : "Each `evalOn` relinquishes the runloop immediately with `execute(ec)(this)`, so the pushing to the `objectState` is immediately followed by a pop in `evalOnR`. It's the exact same logic.",
        "createdAt" : "2021-03-13T23:27:12Z",
        "updatedAt" : "2021-03-13T23:27:12Z",
        "lastEditedBy" : "566d094c-978a-46cc-94f5-bc87e03c9fd3",
        "tags" : [
        ]
      }
    ],
    "commit" : "b46b29623917f326d41fe5b66ccdd3c9e0142ab0",
    "line" : 85,
    "diffHunk" : "@@ -1,1 +792,796 @@\n            resumeTag = EvalOnR\n            resumeIO = cur.ioa\n            execute(ec)(this)\n          }"
  },
  {
    "id" : "267857af-e134-4dc2-a020-72138a13605f",
    "prId" : 1716,
    "prUrl" : "https://github.com/typelevel/cats-effect/pull/1716#pullrequestreview-594794231",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "47fd3682-0f3d-4f04-a193-6f84bcaeb4cf",
        "parentId" : null,
        "authorId" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "body" : "Oh! This is very smart. And also it's entirely legal. The case here is that the callback was satisfied prior to the `Get` being scheduled, so you have it as a guarantee that you're on the correct thread to begin with.",
        "createdAt" : "2021-02-20T23:47:53Z",
        "updatedAt" : "2021-02-20T23:47:53Z",
        "lastEditedBy" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "tags" : [
        ]
      },
      {
        "id" : "234b95e6-ff22-4622-8321-3428a8c81fd3",
        "parentId" : "47fd3682-0f3d-4f04-a193-6f84bcaeb4cf",
        "authorId" : "566d094c-978a-46cc-94f5-bc87e03c9fd3",
        "body" : "Exactly my reasoning.",
        "createdAt" : "2021-02-20T23:48:49Z",
        "updatedAt" : "2021-02-20T23:48:49Z",
        "lastEditedBy" : "566d094c-978a-46cc-94f5-bc87e03c9fd3",
        "tags" : [
        ]
      }
    ],
    "commit" : "254ecc847e3a5ce3d682e0e940db375660e0edcc",
    "line" : 24,
    "diffHunk" : "@@ -1,1 +582,586 @@              }\n\n              runLoop(next, nextIteration)\n            } else {\n              /*"
  },
  {
    "id" : "ff69fab3-8376-428f-a331-0c9ec386365b",
    "prId" : 1340,
    "prUrl" : "https://github.com/typelevel/cats-effect/pull/1340#pullrequestreview-512249650",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ad133ea4-e9df-4d8f-a012-f2036d395951",
        "parentId" : null,
        "authorId" : "3b5d55eb-40d5-4d14-a8a4-3ed1601b5bff",
        "body" : "Should we just start passing in the `IORuntime` into the constructor and adding `private[this]` fields for stuff inside it?",
        "createdAt" : "2020-10-19T23:49:11Z",
        "updatedAt" : "2020-10-21T09:06:38Z",
        "lastEditedBy" : "3b5d55eb-40d5-4d14-a8a4-3ed1601b5bff",
        "tags" : [
        ]
      },
      {
        "id" : "207514ee-d2f3-4e4d-ab48-0cab5579bcac",
        "parentId" : "ad133ea4-e9df-4d8f-a012-f2036d395951",
        "authorId" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "body" : "There are also other good reasons to do this",
        "createdAt" : "2020-10-20T00:30:12Z",
        "updatedAt" : "2020-10-21T09:06:38Z",
        "lastEditedBy" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "tags" : [
        ]
      }
    ],
    "commit" : "0fdd5f41e5a9af487a906cce93bf68db5e3808ce",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +68,72 @@    cb: OutcomeIO[A] => Unit,\n    startIO: IO[A],\n    startEC: ExecutionContext,\n    runtime: IORuntime)\n    extends IOFiberPlatform[A]"
  },
  {
    "id" : "2a4c14e5-b1df-4c2b-b143-21368c804042",
    "prId" : 1340,
    "prUrl" : "https://github.com/typelevel/cats-effect/pull/1340#pullrequestreview-513441778",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e654bf6d-d21b-4863-8b3e-8a9fed8f8202",
        "parentId" : null,
        "authorId" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "body" : "We do need to check the performance implications of this. I think it would be worth running the benchmarks with this setup, then try swapping in a hard-coded integer value and see how different the results are. *Hopefully* the difference will be negligable.",
        "createdAt" : "2020-10-20T22:53:00Z",
        "updatedAt" : "2020-10-21T09:06:38Z",
        "lastEditedBy" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "tags" : [
        ]
      },
      {
        "id" : "a3c4d0f0-d3ca-4941-a95e-60f7104f724c",
        "parentId" : "e654bf6d-d21b-4863-8b3e-8a9fed8f8202",
        "authorId" : "940c7717-e09f-4735-b1e2-bb5b29e96dd8",
        "body" : "You mean because it's not a constant and hence can't be inlined? I had wondered about this...",
        "createdAt" : "2020-10-21T08:42:57Z",
        "updatedAt" : "2020-10-21T09:06:38Z",
        "lastEditedBy" : "940c7717-e09f-4735-b1e2-bb5b29e96dd8",
        "tags" : [
        ]
      }
    ],
    "commit" : "0fdd5f41e5a9af487a906cce93bf68db5e3808ce",
    "line" : 25,
    "diffHunk" : "@@ -1,1 +136,140 @@  private[this] val cancellationCheckThreshold = runtime.config.cancellationCheckThreshold\n  private[this] val autoYieldThreshold = runtime.config.autoYieldThreshold\n  private[this] val iterationThreshold = autoYieldThreshold\n\n  override def run(): Unit = {"
  },
  {
    "id" : "7ce0cd6d-aea2-4f8e-9b7d-cb6cb99f04a7",
    "prId" : 1328,
    "prUrl" : "https://github.com/typelevel/cats-effect/pull/1328#pullrequestreview-511124545",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "deaad646-5256-487c-9373-394640107f37",
        "parentId" : null,
        "authorId" : "3b5d55eb-40d5-4d14-a8a4-3ed1601b5bff",
        "body" : "moved a read barrier from before all async boundaries to after it",
        "createdAt" : "2020-10-18T09:14:17Z",
        "updatedAt" : "2020-10-18T09:19:24Z",
        "lastEditedBy" : "3b5d55eb-40d5-4d14-a8a4-3ed1601b5bff",
        "tags" : [
        ]
      }
    ],
    "commit" : "a18b94af9ac89793a5044d445c3b1fa28c59c708",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +135,139 @@  override def run(): Unit = {\n    // insert a read barrier after every async boundary\n    readBarrier()\n    (resumeTag: @switch) match {\n      case 0 => execR()"
  },
  {
    "id" : "a8869f5c-a364-4e9e-b4cc-18d8aedb738f",
    "prId" : 1328,
    "prUrl" : "https://github.com/typelevel/cats-effect/pull/1328#pullrequestreview-511124625",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f63c5d2c-5a5d-48fa-9ed6-da9e03d319fc",
        "parentId" : null,
        "authorId" : "3b5d55eb-40d5-4d14-a8a4-3ed1601b5bff",
        "body" : "`succeeded` and `failed` are tail recursive with respect to this `attempt` case, so we don't actually need to increment the depth counter",
        "createdAt" : "2020-10-18T09:15:28Z",
        "updatedAt" : "2020-10-18T09:19:24Z",
        "lastEditedBy" : "3b5d55eb-40d5-4d14-a8a4-3ed1601b5bff",
        "tags" : [
        ]
      }
    ],
    "commit" : "a18b94af9ac89793a5044d445c3b1fa28c59c708",
    "line" : 1190,
    "diffHunk" : "@@ -1,1 +1027,1031 @@      case 7 => uncancelableFailureK(error, depth)\n      case 8 => unmaskFailureK(error, depth)\n      case 9 => succeeded(Left(error), depth) // attemptK\n    }\n  }"
  },
  {
    "id" : "80bc27db-a442-4095-8722-5b8c341719d4",
    "prId" : 1165,
    "prUrl" : "https://github.com/typelevel/cats-effect/pull/1165#pullrequestreview-487331293",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "994cd38d-21d7-44bd-9546-6ef1650ce1f3",
        "parentId" : null,
        "authorId" : "df537f5b-c150-4710-8eb4-40b8b59c3bcc",
        "body" : "Just wondering, can these be replaced with final vals? Wouldn't they be inlined at compile time?",
        "createdAt" : "2020-09-13T18:28:45Z",
        "updatedAt" : "2020-10-04T17:55:47Z",
        "lastEditedBy" : "df537f5b-c150-4710-8eb4-40b8b59c3bcc",
        "tags" : [
        ]
      },
      {
        "id" : "8f821993-7a00-46f3-9966-0a20f0857626",
        "parentId" : "994cd38d-21d7-44bd-9546-6ef1650ce1f3",
        "authorId" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "body" : "Nope! There are bugs in scalac related to this stuff. Generally-speaking, you can't get a `tableswitch` to generate if you use vals; you need to actually inline the constants manually.",
        "createdAt" : "2020-09-13T18:30:09Z",
        "updatedAt" : "2020-10-04T17:55:47Z",
        "lastEditedBy" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "tags" : [
        ]
      },
      {
        "id" : "085952e7-9724-450c-a673-a5b66fb046e3",
        "parentId" : "994cd38d-21d7-44bd-9546-6ef1650ce1f3",
        "authorId" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "body" : "(also, curiously, `@inline` appears to *sometimes* fix this issue, but not always; this is, to my knowledge, the only practically visible impact of that annotation)",
        "createdAt" : "2020-09-13T18:30:37Z",
        "updatedAt" : "2020-10-04T17:55:47Z",
        "lastEditedBy" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "tags" : [
        ]
      },
      {
        "id" : "558175cb-3030-4f11-9db1-d804dd7cd7dd",
        "parentId" : "994cd38d-21d7-44bd-9546-6ef1650ce1f3",
        "authorId" : "df537f5b-c150-4710-8eb4-40b8b59c3bcc",
        "body" : "eh. Thanks ;)",
        "createdAt" : "2020-09-13T18:55:41Z",
        "updatedAt" : "2020-10-04T17:55:47Z",
        "lastEditedBy" : "df537f5b-c150-4710-8eb4-40b8b59c3bcc",
        "tags" : [
        ]
      }
    ],
    "commit" : "4fe596800ba0b0593f7ab7722be2e2b8a5ae5a90",
    "line" : 640,
    "diffHunk" : "@@ -1,1 +474,478 @@          runLoop(next, nextIteration)\n\n        case 12 =>\n          val cur = cur0.asInstanceOf[IOCont.Get[Any]]\n"
  },
  {
    "id" : "b22979c7-2bce-48f5-a3f6-b2311e0f17d5",
    "prId" : 1165,
    "prUrl" : "https://github.com/typelevel/cats-effect/pull/1165#pullrequestreview-495241084",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fa712337-830c-45e1-bdb6-c80a7f6cc309",
        "parentId" : null,
        "authorId" : "3b5d55eb-40d5-4d14-a8a4-3ed1601b5bff",
        "body" : "I was expecting otherwise, but it's interesting that this `stateLoop` stayed mostly intact from the old `Async`. I think that goes to say that old finalizer registration mechanism was just a more specific variant of what we have now",
        "createdAt" : "2020-09-24T06:33:08Z",
        "updatedAt" : "2020-10-04T17:55:47Z",
        "lastEditedBy" : "3b5d55eb-40d5-4d14-a8a4-3ed1601b5bff",
        "tags" : [
        ]
      }
    ],
    "commit" : "4fe596800ba0b0593f7ab7722be2e2b8a5ae5a90",
    "line" : 547,
    "diffHunk" : "@@ -1,1 +439,443 @@             */\n            @tailrec\n            def stateLoop(): Unit = {\n              val old = state.get\n              val tag = old.tag"
  },
  {
    "id" : "63dcb1c0-0972-4feb-98d3-86b79aaaba22",
    "prId" : 1165,
    "prUrl" : "https://github.com/typelevel/cats-effect/pull/1165#pullrequestreview-500986084",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "195b1aa8-bdeb-45a8-8140-59bd02532b48",
        "parentId" : null,
        "authorId" : "3b5d55eb-40d5-4d14-a8a4-3ed1601b5bff",
        "body" : "is this supposed to be somewhere else",
        "createdAt" : "2020-10-02T08:29:31Z",
        "updatedAt" : "2020-10-04T17:55:47Z",
        "lastEditedBy" : "3b5d55eb-40d5-4d14-a8a4-3ed1601b5bff",
        "tags" : [
        ]
      },
      {
        "id" : "d38b6009-f0ec-400b-8428-a1bf17e05612",
        "parentId" : "195b1aa8-bdeb-45a8-8140-59bd02532b48",
        "authorId" : "a5a514ff-cd89-45cb-bcc8-796f0fa2a445",
        "body" : "It was there before my changes as well. Not quite sure where to put it, it's a general point, which affects `childMask`, `initMask`, `masks`, `case 9` and `case 10` in the runloop (that's a candidate spot), `isUnmasked`, etc",
        "createdAt" : "2020-10-02T09:25:17Z",
        "updatedAt" : "2020-10-04T17:55:47Z",
        "lastEditedBy" : "a5a514ff-cd89-45cb-bcc8-796f0fa2a445",
        "tags" : [
        ]
      }
    ],
    "commit" : "4fe596800ba0b0593f7ab7722be2e2b8a5ae5a90",
    "line" : 256,
    "diffHunk" : "@@ -1,1 +191,195 @@    }\n\n  /* masks encoding: initMask => no masks, ++ => push, -- => pop */\n  @tailrec\n  private[this] def runLoop(_cur0: IO[Any], iteration: Int): Unit = {"
  },
  {
    "id" : "1b3385ad-638c-4b58-a89c-63fc65f0a1d7",
    "prId" : 1165,
    "prUrl" : "https://github.com/typelevel/cats-effect/pull/1165#pullrequestreview-500989005",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3282fa28-d2f4-4f7b-ab0a-ac20d9f58fdc",
        "parentId" : null,
        "authorId" : "3b5d55eb-40d5-4d14-a8a4-3ed1601b5bff",
        "body" : "ooh, this is a really good catch",
        "createdAt" : "2020-10-02T08:49:28Z",
        "updatedAt" : "2020-10-04T17:55:47Z",
        "lastEditedBy" : "3b5d55eb-40d5-4d14-a8a4-3ed1601b5bff",
        "tags" : [
        ]
      },
      {
        "id" : "0a8daab7-da37-46da-999f-383e7dbf9929",
        "parentId" : "3282fa28-d2f4-4f7b-ab0a-ac20d9f58fdc",
        "authorId" : "a5a514ff-cd89-45cb-bcc8-796f0fa2a445",
        "body" : "The solution here was surprisingly simple, I had gone down a really complicated avenue of double checking AtomicReferences before realising I could use `IO` itself and `onCancel`. This is the solution to \"`get` within an `onCancel`\" bug, ftr.",
        "createdAt" : "2020-10-02T09:29:53Z",
        "updatedAt" : "2020-10-04T17:55:47Z",
        "lastEditedBy" : "a5a514ff-cd89-45cb-bcc8-796f0fa2a445",
        "tags" : [
        ]
      }
    ],
    "commit" : "4fe596800ba0b0593f7ab7722be2e2b8a5ae5a90",
    "line" : 589,
    "diffHunk" : "@@ -1,1 +467,471 @@               * a finalizer still works with the same logic.\n               */\n              IO(state.compareAndSet(ContStateWaiting, ContStateInitial)).void\n            )\n"
  },
  {
    "id" : "1fad1646-86f1-4b98-94a0-ef6ff6cf058c",
    "prId" : 1165,
    "prUrl" : "https://github.com/typelevel/cats-effect/pull/1165#pullrequestreview-501642486",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "cc41917a-6d52-496d-b45b-16287946b2ba",
        "parentId" : null,
        "authorId" : "3b5d55eb-40d5-4d14-a8a4-3ed1601b5bff",
        "body" : "I *think* this looks good to me, will keep on thinking about it. Here's an alternative state coordination mechanism that makes somewhat more sense to me:\r\n1. Renaming `wasFinalizing` to `waiting`. The purpose of this variable is to communicate to the callback whether the fiber is ready to resume from *this* callback specifically.\r\n2. Add an extra statement to the `Get` finalizer that sets `waiting` to false.\r\n3. Replace this conditional with `waiting.get()`. This basically indicates that the runloop suspended with the intention if waiting on this fiber. \r\n4. We can remove the `finalizing` field member.\r\n\r\nIf it's actually correct, I think this mechanism is slightly easier to understand, since it's completely independent of finalization. It's \"if the runloop is waiting on me, then I can proceed\" rather than \"if the current runloop finalization state is the same as the state of whoever is currently waiting\".",
        "createdAt" : "2020-10-04T08:24:32Z",
        "updatedAt" : "2020-10-04T17:55:47Z",
        "lastEditedBy" : "3b5d55eb-40d5-4d14-a8a4-3ed1601b5bff",
        "tags" : [
        ]
      },
      {
        "id" : "3ce1f09c-2cb0-4b78-bc9c-9b83120fda9d",
        "parentId" : "cc41917a-6d52-496d-b45b-16287946b2ba",
        "authorId" : "a5a514ff-cd89-45cb-bcc8-796f0fa2a445",
        "body" : "I find the solution in the PR (and the one in the old async) a bit opaque.\r\nI _think_ I prefer the direction with the `id` of the suspension, which acts as a sort of epoch number, because I think the specific problem is more accurately described as \"we don't want a callback of a previous epoch to resume the runloop in a new epoch\", with an orthogonal statement that says \"a change of epoch happens during finalisation, in the presence of an async finaliser\"",
        "createdAt" : "2020-10-04T14:26:25Z",
        "updatedAt" : "2020-10-04T17:55:47Z",
        "lastEditedBy" : "a5a514ff-cd89-45cb-bcc8-796f0fa2a445",
        "tags" : [
        ]
      },
      {
        "id" : "84346847-222a-480c-8c75-a346f91ea407",
        "parentId" : "cc41917a-6d52-496d-b45b-16287946b2ba",
        "authorId" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "body" : "I think that @RaasAhsan's proposed solution is even *better* than the epoch number, actually, since we only need an epoch bit and his solution achieves it while removing the extra state from `IOFiber` itself. I really like that, but I think we should implement it in a follow-up PR.\r\n\r\nThe solution currently on the branch is definitely opaque, I just want to get this landed in a functional form so that we can unblock everything else. :-D",
        "createdAt" : "2020-10-04T17:19:37Z",
        "updatedAt" : "2020-10-04T17:55:47Z",
        "lastEditedBy" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "tags" : [
        ]
      },
      {
        "id" : "d20fa361-30b9-42e8-9d0e-75a8f8c16f7a",
        "parentId" : "cc41917a-6d52-496d-b45b-16287946b2ba",
        "authorId" : "a5a514ff-cd89-45cb-bcc8-796f0fa2a445",
        "body" : "I'm fixing the conflicts as we speak, let's get it merged and then @RaasAhsan can add his solution and the additional tests in a follow up",
        "createdAt" : "2020-10-04T17:20:55Z",
        "updatedAt" : "2020-10-04T17:55:47Z",
        "lastEditedBy" : "a5a514ff-cd89-45cb-bcc8-796f0fa2a445",
        "tags" : [
        ]
      }
    ],
    "commit" : "4fe596800ba0b0593f7ab7722be2e2b8a5ae5a90",
    "line" : 480,
    "diffHunk" : "@@ -1,1 +390,394 @@              /* try to take ownership of the runloop */\n              if (resume()) {\n                if (finalizing == wasFinalizing.get()) {\n                  if (!shouldFinalize()) {\n                    /* we weren't cancelled, so resume the runloop */"
  },
  {
    "id" : "684f584f-f8ea-4f7d-86bc-2c3bb5e9e337",
    "prId" : 1134,
    "prUrl" : "https://github.com/typelevel/cats-effect/pull/1134#pullrequestreview-477897325",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ea1cc6a1-deb2-43ab-82eb-395569469433",
        "parentId" : null,
        "authorId" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "body" : "IIRC, HotSpot has some special logic to detect this particular pattern, so I imagine this will be very fast.",
        "createdAt" : "2020-08-28T16:51:57Z",
        "updatedAt" : "2020-08-30T22:15:10Z",
        "lastEditedBy" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "tags" : [
        ]
      },
      {
        "id" : "f857b6ea-4898-40e3-9bdf-096b3cf82e6b",
        "parentId" : "ea1cc6a1-deb2-43ab-82eb-395569469433",
        "authorId" : "566d094c-978a-46cc-94f5-bc87e03c9fd3",
        "body" : "Seems like it, it's much faster than the virtual dispatch solution from earlier.",
        "createdAt" : "2020-08-28T17:14:05Z",
        "updatedAt" : "2020-08-30T22:15:10Z",
        "lastEditedBy" : "566d094c-978a-46cc-94f5-bc87e03c9fd3",
        "tags" : [
        ]
      }
    ],
    "commit" : "412008eb9f64d092ec05f6618aece641293712d6",
    "line" : 51,
    "diffHunk" : "@@ -1,1 +688,692 @@\n    if (ec.isInstanceOf[WorkStealingThreadPool]) {\n      ec.asInstanceOf[WorkStealingThreadPool].executeFiber(fiber)\n    } else {\n      try {"
  },
  {
    "id" : "3ec18f49-188d-4469-887e-54e2478e8fc4",
    "prId" : 1066,
    "prUrl" : "https://github.com/typelevel/cats-effect/pull/1066#pullrequestreview-463904137",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4eb6bfcc-b6c9-41ae-a629-17071e11c982",
        "parentId" : null,
        "authorId" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "body" : "As an aside, it would be worth writing a unit test for this. There's a law to this effect, but it doesn't comprehensively model the race conditions.",
        "createdAt" : "2020-08-09T17:37:44Z",
        "updatedAt" : "2020-08-09T21:18:57Z",
        "lastEditedBy" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "tags" : [
        ]
      },
      {
        "id" : "7f7f7965-66e7-498d-960b-af970f452cbe",
        "parentId" : "4eb6bfcc-b6c9-41ae-a629-17071e11c982",
        "authorId" : "566d094c-978a-46cc-94f5-bc87e03c9fd3",
        "body" : "Done.",
        "createdAt" : "2020-08-09T21:19:10Z",
        "updatedAt" : "2020-08-09T21:19:11Z",
        "lastEditedBy" : "566d094c-978a-46cc-94f5-bc87e03c9fd3",
        "tags" : [
        ]
      }
    ],
    "commit" : "af922bbde85aa9174147e7781064f6f562bd1a45",
    "line" : 71,
    "diffHunk" : "@@ -1,1 +345,349 @@            def loop(old: Byte): Unit = {\n              if (resume()) {\n                state.lazySet(AsyncStateDone) // avoid leaks\n\n                // Race condition check:"
  },
  {
    "id" : "cabbbf4b-aafb-41e9-9952-db84f3d42f08",
    "prId" : 1059,
    "prUrl" : "https://github.com/typelevel/cats-effect/pull/1059#pullrequestreview-463410371",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "40af8b1e-9375-4096-a2ee-66fa8bf5e7bb",
        "parentId" : null,
        "authorId" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "body" : "I completely didn't even think about this! Nice catch.",
        "createdAt" : "2020-08-07T15:36:32Z",
        "updatedAt" : "2020-08-07T15:37:43Z",
        "lastEditedBy" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "tags" : [
        ]
      }
    ],
    "commit" : "a502f194a0f60e7c366a7f27ff53c0f35f5213c6",
    "line" : 31,
    "diffHunk" : "@@ -1,1 +336,340 @@          // Async callbacks may only resume if the finalization state\n          // remains the same after we re-acquire the runloop\n          val wasFinalizing = finalizing\n\n          objectState.push(done)"
  },
  {
    "id" : "a037731f-8b93-482e-94ae-8aebe5daf22c",
    "prId" : 1043,
    "prUrl" : "https://github.com/typelevel/cats-effect/pull/1043#pullrequestreview-462624677",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b91fdc9d-cb1f-4922-9fd4-bbc61cc775e7",
        "parentId" : null,
        "authorId" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "body" : "Wait, how is this instantiated in `IO` if it's `private`?",
        "createdAt" : "2020-08-06T02:01:40Z",
        "updatedAt" : "2020-08-06T09:48:07Z",
        "lastEditedBy" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "tags" : [
        ]
      },
      {
        "id" : "093725bb-df63-4498-afc3-6625848db1a7",
        "parentId" : "b91fdc9d-cb1f-4922-9fd4-bbc61cc775e7",
        "authorId" : "566d094c-978a-46cc-94f5-bc87e03c9fd3",
        "body" : "`private` for top level class and object definitions only means that the class/object is visible in its given package. `IO` is also in the `cats.effect` package, and therefore can see `IOFiber`. The constructor is not marked private and is available. I think `[effect]` in this case is superfluous. I guess you can use the feature to mark it available in a broader package, maybe `[cats]`.",
        "createdAt" : "2020-08-06T09:39:33Z",
        "updatedAt" : "2020-08-06T09:48:07Z",
        "lastEditedBy" : "566d094c-978a-46cc-94f5-bc87e03c9fd3",
        "tags" : [
        ]
      },
      {
        "id" : "df3bc7e0-dd33-4733-bcd2-02e14270b95b",
        "parentId" : "b91fdc9d-cb1f-4922-9fd4-bbc61cc775e7",
        "authorId" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "body" : "TIL",
        "createdAt" : "2020-08-06T15:22:21Z",
        "updatedAt" : "2020-08-06T15:22:21Z",
        "lastEditedBy" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "tags" : [
        ]
      }
    ],
    "commit" : "e2833afceb8347d96c6bb5b9185a57fb0e5342f7",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +58,62 @@ * merely a fast-path and are not necessary for correctness.\n */\nprivate final class IOFiber[A](\n    name: String,\n    scheduler: unsafe.Scheduler,"
  },
  {
    "id" : "83ca37af-231c-443a-8566-c1547c0807d1",
    "prId" : 1005,
    "prUrl" : "https://github.com/typelevel/cats-effect/pull/1005#pullrequestreview-456170748",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "185ee4a9-2ec8-4313-9fea-3f14fa435670",
        "parentId" : null,
        "authorId" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "body" : "LOL! I'm laughing so hard right now…",
        "createdAt" : "2020-07-27T22:10:40Z",
        "updatedAt" : "2020-07-28T00:47:11Z",
        "lastEditedBy" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "tags" : [
        ]
      }
    ],
    "commit" : "d3280c0cc263ca653bb303a3b526ec0ef3009a21",
    "line" : 80,
    "diffHunk" : "@@ -1,1 +550,554 @@                    fiberB.prepare(cur.iob, ec)\n                    execute(ec)(fiberA)\n                    execute(ec)(fiberB)\n\n                    Some(fiberA.cancel.both(fiberB.cancel).void)"
  },
  {
    "id" : "e30bd244-d52d-4f67-a370-53cd7a7239fe",
    "prId" : 1005,
    "prUrl" : "https://github.com/typelevel/cats-effect/pull/1005#pullrequestreview-456177960",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "35b898cb-40dd-4b34-b3fa-0d002a2db78e",
        "parentId" : null,
        "authorId" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "body" : "Unnecessary change?",
        "createdAt" : "2020-07-27T22:11:22Z",
        "updatedAt" : "2020-07-28T00:47:11Z",
        "lastEditedBy" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "tags" : [
        ]
      },
      {
        "id" : "24aa4fd9-c80f-4ca1-b834-40de06b7c809",
        "parentId" : "35b898cb-40dd-4b34-b3fa-0d002a2db78e",
        "authorId" : "566d094c-978a-46cc-94f5-bc87e03c9fd3",
        "body" : "I meant to ask this. There are two `IOFiber[Any]` instances created in `racePair`. This one here is actually an `IOFiber[Nothing]`. Does it need changing? Otherwise, I'll drop it.",
        "createdAt" : "2020-07-27T22:15:09Z",
        "updatedAt" : "2020-07-28T00:47:11Z",
        "lastEditedBy" : "566d094c-978a-46cc-94f5-bc87e03c9fd3",
        "tags" : [
        ]
      },
      {
        "id" : "9a91d5c6-8d97-46f9-afe7-f1c02f2af27c",
        "parentId" : "35b898cb-40dd-4b34-b3fa-0d002a2db78e",
        "authorId" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "body" : "Oh, I didn't realize it was `IOFiber[Nothing]`. I'm cool with fixing that. The compiler sometimes freaks out around `Nothing`, so we may as well be explicit.",
        "createdAt" : "2020-07-27T22:26:16Z",
        "updatedAt" : "2020-07-28T00:47:11Z",
        "lastEditedBy" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "tags" : [
        ]
      }
    ],
    "commit" : "d3280c0cc263ca653bb303a3b526ec0ef3009a21",
    "line" : 59,
    "diffHunk" : "@@ -1,1 +511,515 @@            val initMask2 = childMask\n\n            val fiber = new IOFiber[Any](childName, scheduler, blockingEc, initMask2)\n\n            // println(s\"<$name> spawning <$childName>\")"
  },
  {
    "id" : "a2cbe0a4-9dce-4a61-beb5-5753857dde4a",
    "prId" : 1004,
    "prUrl" : "https://github.com/typelevel/cats-effect/pull/1004#pullrequestreview-456174672",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f0492800-adf8-4ba5-ab9d-cb9fbf24d6a6",
        "parentId" : null,
        "authorId" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "body" : "I'm amazed this actually works, but it truly does. The logic here: for a given `IOFiber` instance, we're not going to be using more than one of these at a time, because the runloop *will be suspended*. So we really can just aggressively preallocate it.",
        "createdAt" : "2020-07-27T22:03:44Z",
        "updatedAt" : "2020-07-27T23:05:37Z",
        "lastEditedBy" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "tags" : [
        ]
      },
      {
        "id" : "41cbe9ac-456d-460e-8769-69078808d3e7",
        "parentId" : "f0492800-adf8-4ba5-ab9d-cb9fbf24d6a6",
        "authorId" : "566d094c-978a-46cc-94f5-bc87e03c9fd3",
        "body" : "That was my intuition as well.",
        "createdAt" : "2020-07-27T22:08:34Z",
        "updatedAt" : "2020-07-27T23:05:37Z",
        "lastEditedBy" : "566d094c-978a-46cc-94f5-bc87e03c9fd3",
        "tags" : [
        ]
      },
      {
        "id" : "4d6a8429-6c7e-4a18-8061-11cc73165cc5",
        "parentId" : "f0492800-adf8-4ba5-ab9d-cb9fbf24d6a6",
        "authorId" : "3b5d55eb-40d5-4d14-a8a4-3ed1601b5bff",
        "body" : "👍  The CE2 run-loop exploited the same idea with `RestartCallback`",
        "createdAt" : "2020-07-27T22:19:12Z",
        "updatedAt" : "2020-07-27T23:05:37Z",
        "lastEditedBy" : "3b5d55eb-40d5-4d14-a8a4-3ed1601b5bff",
        "tags" : [
        ]
      }
    ],
    "commit" : "9d3ffc9940f66da94a534ae9adbeb8879b27a712",
    "line" : 42,
    "diffHunk" : "@@ -1,1 +267,271 @@    if (!shouldFinalize()) {\n      asyncContinueClosure.prepare(e)\n      execute(ec)(asyncContinueClosure)\n    } else {\n      asyncCancel(null)"
  },
  {
    "id" : "1c1ef3d1-cb40-4c82-9c92-282eeb0c4cd6",
    "prId" : 998,
    "prUrl" : "https://github.com/typelevel/cats-effect/pull/998#pullrequestreview-455333566",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "189b2eb7-0e72-405b-b7dd-2adb78c3bc98",
        "parentId" : null,
        "authorId" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "body" : "`false` or `true`? Fibers start out as `suspended = true`, and we're pretty consistent about \"`suspended = true` implies someone has `runLoop` somewhere\".",
        "createdAt" : "2020-07-26T05:28:45Z",
        "updatedAt" : "2020-07-26T05:32:33Z",
        "lastEditedBy" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "tags" : [
        ]
      },
      {
        "id" : "9f9e238f-4bda-4242-ab04-7111dc5e6388",
        "parentId" : "189b2eb7-0e72-405b-b7dd-2adb78c3bc98",
        "authorId" : "3b5d55eb-40d5-4d14-a8a4-3ed1601b5bff",
        "body" : "This is merely a write memory barrier (the comment above it is wrong) to publish the write to `mask`, the value of `suspended` doesn't change at all. I want to avoid setting it back to `true` so that no one can acquire the runloop again (see point 4 in the PR description).",
        "createdAt" : "2020-07-26T05:36:12Z",
        "updatedAt" : "2020-07-26T05:36:13Z",
        "lastEditedBy" : "3b5d55eb-40d5-4d14-a8a4-3ed1601b5bff",
        "tags" : [
        ]
      },
      {
        "id" : "4ba7c1f7-5c35-4aa3-881f-da60b44e52fb",
        "parentId" : "189b2eb7-0e72-405b-b7dd-2adb78c3bc98",
        "authorId" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "body" : "Ah I see! Rather than setting `suspended` to `true` when you're done with finalization, you just let it stay `false` since `outcome` is already set, so it shouldn't, ultimately, matter.",
        "createdAt" : "2020-07-26T05:42:31Z",
        "updatedAt" : "2020-07-26T05:42:32Z",
        "lastEditedBy" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "tags" : [
        ]
      }
    ],
    "commit" : "bd829f56f89f4b114a6fc9609e5ac130e0ab98ba",
    "line" : 80,
    "diffHunk" : "@@ -1,1 +220,224 @@    masks = initMask\n    // full memory barrier to publish masks\n    suspended.set(false)\n\n    // clear out literally everything to avoid any possible memory leaks"
  },
  {
    "id" : "c04d5992-376a-42c6-9285-814b910cef08",
    "prId" : 911,
    "prUrl" : "https://github.com/typelevel/cats-effect/pull/911#pullrequestreview-443300363",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "70958ebc-7cec-4c75-afe7-be3541238810",
        "parentId" : null,
        "authorId" : "3b5d55eb-40d5-4d14-a8a4-3ed1601b5bff",
        "body" : "If we're going to go with the integer tags, naming the constants would improve readability a ton",
        "createdAt" : "2020-07-06T17:02:14Z",
        "updatedAt" : "2020-07-11T18:35:51Z",
        "lastEditedBy" : "3b5d55eb-40d5-4d14-a8a4-3ed1601b5bff",
        "tags" : [
        ]
      },
      {
        "id" : "a38be86a-fb7a-464f-9943-02a4d5bdf14c",
        "parentId" : "70958ebc-7cec-4c75-afe7-be3541238810",
        "authorId" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "body" : "There's a bug on Scala 2.12 where named constants can't be used in `@switch` matches. I generally navigate the runloop using **find** in my editor, since each case has the name of the class either in a cast or in a comment.",
        "createdAt" : "2020-07-06T18:07:14Z",
        "updatedAt" : "2020-07-11T18:35:51Z",
        "lastEditedBy" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "tags" : [
        ]
      }
    ],
    "commit" : "11095f3ade81d210f681ceeeb6c55e2c3c66a768",
    "line" : 308,
    "diffHunk" : "@@ -1,1 +306,310 @@      if (!conts.isEmpty() && cur0 != null) {\n        (cur0.tag: @switch) match {\n          case 0 =>\n            val cur = cur0.asInstanceOf[Pure[Any]]\n            runLoop(succeeded(cur.value, 0), nextIteration)"
  },
  {
    "id" : "f330c38a-9546-4007-87d8-3ec3fd8e3d75",
    "prId" : 911,
    "prUrl" : "https://github.com/typelevel/cats-effect/pull/911#pullrequestreview-443300748",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fe65f90b-393f-437b-8e32-182a611099d8",
        "parentId" : null,
        "authorId" : "3b5d55eb-40d5-4d14-a8a4-3ed1601b5bff",
        "body" : "Nice! Giving fibers a stable identity will make it very easy to start implementing fiber identity/ancestry, fiber-local state, and will probably simplify fiber tracing implementation",
        "createdAt" : "2020-07-06T17:08:21Z",
        "updatedAt" : "2020-07-11T18:35:51Z",
        "lastEditedBy" : "3b5d55eb-40d5-4d14-a8a4-3ed1601b5bff",
        "tags" : [
        ]
      },
      {
        "id" : "33215301-2515-45f0-bfee-0574ad957671",
        "parentId" : "fe65f90b-393f-437b-8e32-182a611099d8",
        "authorId" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "body" : "That was my thought! I got this idea initially when working on `PureConc`, which has a similar design.",
        "createdAt" : "2020-07-06T18:07:54Z",
        "updatedAt" : "2020-07-11T18:35:51Z",
        "lastEditedBy" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "tags" : [
        ]
      }
    ],
    "commit" : "11095f3ade81d210f681ceeeb6c55e2c3c66a768",
    "line" : 84,
    "diffHunk" : "@@ -1,1 +82,86 @@ * will result in a simultaneous `push` on `SafeArrayStack`.\n */\nprivate[effect] final class IOFiber[A](name: String, timer: UnsafeTimer, initMask: Int) extends Fiber[IO, Throwable, A] {\n  import IO._\n"
  },
  {
    "id" : "64644cad-98be-4688-b458-1714a7007094",
    "prId" : 911,
    "prUrl" : "https://github.com/typelevel/cats-effect/pull/911#pullrequestreview-445727558",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4cebb288-050d-4dee-9ca1-840fe3113369",
        "parentId" : null,
        "authorId" : "3b5d55eb-40d5-4d14-a8a4-3ed1601b5bff",
        "body" : "I have a feeling this isn't thread-safe - manipulating a non-volatile local variable from possibly another thread ? (the child fibers can shift threads, so the callback can be invoked on another thread). I suppose this is fine for the current fiber since a happens-before relationship is established before invoking the continuation, but does *another* thread/fiber ever need to observe this state?",
        "createdAt" : "2020-07-06T17:14:40Z",
        "updatedAt" : "2020-07-11T18:35:51Z",
        "lastEditedBy" : "3b5d55eb-40d5-4d14-a8a4-3ed1601b5bff",
        "tags" : [
        ]
      },
      {
        "id" : "1c77f83b-26ff-49c3-af31-a64dc9e897a7",
        "parentId" : "4cebb288-050d-4dee-9ca1-840fe3113369",
        "authorId" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "body" : "> but does another thread/fiber ever need to observe this state?\r\n\r\n*observe*, no, but *write*, yes. It's definitely unsafe from the standpoint of \"a fiber in another thread could cancel us and we wouldn't see it for a while\", but that isn't unsafe *per se* since cancelation is ultimately just a performance hint! Note that cancelation is reflected immediately (and atomically) in the event that a fiber is asynchronously suspended (represented by the `suspended: AtomicBoolean` flag).\r\n\r\nBasically, by making this non-volatile, we're creating a situation where cancelation can only be observed when the \"canceler\" has passed through a write barrier and the \"cancelee\" has passed through a read barrier. `cede` and `async` are both trivially read *and* write barriers, so effectively we're tying cancelation resolution and fairness together.",
        "createdAt" : "2020-07-06T18:11:24Z",
        "updatedAt" : "2020-07-11T18:35:51Z",
        "lastEditedBy" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "tags" : [
        ]
      },
      {
        "id" : "f5dd2582-2661-495f-814f-b40acc9f2eaa",
        "parentId" : "4cebb288-050d-4dee-9ca1-840fe3113369",
        "authorId" : "3b5d55eb-40d5-4d14-a8a4-3ed1601b5bff",
        "body" : "I missed this explanation in the PR description :)",
        "createdAt" : "2020-07-07T00:53:37Z",
        "updatedAt" : "2020-07-11T18:35:51Z",
        "lastEditedBy" : "3b5d55eb-40d5-4d14-a8a4-3ed1601b5bff",
        "tags" : [
        ]
      },
      {
        "id" : "7d125f3e-b6d0-48ea-9c05-b94d5591c965",
        "parentId" : "4cebb288-050d-4dee-9ca1-840fe3113369",
        "authorId" : "a5a514ff-cd89-45cb-bcc8-796f0fa2a445",
        "body" : "> Basically, by making this non-volatile, we're creating a situation where cancelation can only be observed when the \"canceler\" has passed through a write barrier and the \"cancelee\" has passed through a read barrier. cede and async are both trivially read and write barriers, so effectively we're tying cancelation resolution and fairness together.\r\n\r\nDoes this mean that you have effectively disabled cancellable binds? That seems like a step back from master: cancellation at async boundaries only is how `IO` used to work, and we did a lot to allow cancelable binds (including the new `uncancelable` model), I think it's a bit of a shame to disallow it now for an implementation concern, especially as master has good performance as well",
        "createdAt" : "2020-07-07T08:29:28Z",
        "updatedAt" : "2020-07-11T18:35:51Z",
        "lastEditedBy" : "a5a514ff-cd89-45cb-bcc8-796f0fa2a445",
        "tags" : [
        ]
      },
      {
        "id" : "231b353c-85d6-4d36-a60e-fafc35ad3350",
        "parentId" : "4cebb288-050d-4dee-9ca1-840fe3113369",
        "authorId" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "body" : "Master also only polls for cancelation once every 1024 suspensions. By an interesting coincidence, 1024 is also the default number of suspensions between auto-yields in Monix, but we've made the argument numerous times that `IO` doesn't need auto-yielding because async boundaries are quite common in practice (and I agree with this).\r\n\r\nEvery async boundary is a full write barrier, so at a *minimum* we'll be seeing cancelation that often. However, we only need a *read* barrier on a fiber following a *write* barrier on the canceler to see the flag, and seeing as `cancel` immediately hits a write barrier, it's practically just \"hit a read barrier\". Read barriers are still-more common (any `volatile` read will do it, and remember, just sequencing `IO.pure` involves at least one volatile read), so in practice we should be seeing this almost immediately.\r\n\r\nRegarding performance, it's worth noting that the async runloop on master is out-performed by the runloop here by at least 3-4x (the benchmarks don't do a good job of isolating this exactly, but I'm planning on writing one which is more precise). @RaasAhsan pointed this out down below. The Deep/Shallow bind benchmarks on master are basically testing `SyncIO`'s runloop, not `IO`'s, while on this PR there's only a single runloop which manages both sync and async evaluation.",
        "createdAt" : "2020-07-07T20:01:25Z",
        "updatedAt" : "2020-07-11T18:35:51Z",
        "lastEditedBy" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "tags" : [
        ]
      },
      {
        "id" : "d94d6c5e-e8a1-4b2d-a21a-40131e4d08eb",
        "parentId" : "4cebb288-050d-4dee-9ca1-840fe3113369",
        "authorId" : "3b5d55eb-40d5-4d14-a8a4-3ed1601b5bff",
        "body" : "> However, we only need a read barrier on a fiber following a write barrier on the canceler to see the flag, and seeing as cancel immediately hits a write barrier, it's practically just \"hit a read barrier\".\r\n\r\nJust to be clear, the read barrier is this one?\r\n```scala\r\n                if (s != null && suspended.compareAndSet(true, false)) {\r\n                  if (s.isRight) {\r\n```\r\nand that should propagate writes to `cancel` and `masks` in `asyncContinue`:\r\n```scala\r\nif (!canceled || masks != initMask) {\r\n      ec execute { () =>\r\n```",
        "createdAt" : "2020-07-08T03:28:43Z",
        "updatedAt" : "2020-07-11T18:35:51Z",
        "lastEditedBy" : "3b5d55eb-40d5-4d14-a8a4-3ed1601b5bff",
        "tags" : [
        ]
      },
      {
        "id" : "f98b6d99-3113-4a0b-9c4e-35e63c8d8978",
        "parentId" : "4cebb288-050d-4dee-9ca1-840fe3113369",
        "authorId" : "a5a514ff-cd89-45cb-bcc8-796f0fa2a445",
        "body" : "> Master also only polls for cancelation once every 1024 suspensions.\r\n\r\nit's actually 512, 1024 is the monix fairness boundary.\r\n\r\n> s, so effectively we're tying cancelation resolution and fairness together.\r\n\r\nI'm not sure about this: as a user, if the code you're calling isn't very fair, there are still other factors at play, like the number of CPUs coupled with the preemption from the underlying real threads. With cancelation, if we don't check, there is nothing the user can do short of having to modify the code.\r\n\r\nMoreover, I think one of the problems we've seen in cats-effect 2 is how opaque the model is, I'd be really keen to offer users a clear cut explanation of what things can be canceled and when, I think it helps quite a lot when reasoning about the library (even if, at some level, this might be more for peace of mind in the sense of \"I understand what's going on\", rather than practical impact), and this \r\n\r\n>  Basically, by making this non-volatile, we're creating a situation where cancelation can only be observed when the \"canceler\" has passed through a write barrier and the \"cancelee\" has passed through a read barrier\r\n\r\nIs way too low level to give to our users, and also ties the _semantics_ of cancelation to the details of our current implementation, which (as seen in ce 2) can change quite a lot even in point releases.\r\n\r\n I'm not 100% opposed to doing this, but I worry about compromising clarity for the purpose of optimising something that is so far from an actual bottleneck that the tradeoff is no longer worth it : we're not only talking about optimising the runloop in general, but about making it faster than the _current_ runloop, which is already super fast.",
        "createdAt" : "2020-07-08T13:52:27Z",
        "updatedAt" : "2020-07-11T18:35:51Z",
        "lastEditedBy" : "a5a514ff-cd89-45cb-bcc8-796f0fa2a445",
        "tags" : [
        ]
      },
      {
        "id" : "71a97f57-6405-40e1-bcc0-bdbe123a3170",
        "parentId" : "4cebb288-050d-4dee-9ca1-840fe3113369",
        "authorId" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "body" : "> Just to be clear, the read barrier is this one?\r\n\r\nI believe CAS is actually a write barrier, since the happens-before relation on writes must be maintained, and the \"swap\" portion of that acronym is immediately visible across threads. I will freely admit though that my understanding of the JVM's (and x86's) memory barriers is imperfect.\r\n\r\n> it's actually 512, 1024 is the monix fairness boundary.\r\n\r\nAh, my mistake!\r\n\r\n> Moreover, I think one of the problems we've seen in cats-effect 2 is how opaque the model is, I'd be really keen to offer users a clear cut explanation of what things can be canceled and when, I think it helps quite a lot when reasoning about the library (even if, at some level, this might be more for peace of mind in the sense of \"I understand what's going on\", rather than practical impact), and this\r\n\r\nI agree with this, but I'm not quite sure how to achieve it in practice without a serious performance hit, and even then there would still be nondeterminism. Also, we need to be clear about separating the semantics *in abstract* (as defined by **kernel**) from the practical implementation of `IO`. The latter must be compatible with the former, but the quirks of the latter do not define or constrain the former any more than the quirks of Monix or ZIO do. But back to how to achieve lower opacity…\r\n\r\nThe *least* opaque model would be to mark `canceled` as `@volatile`. We poll it on every iteration of the runloop, which means that if we're actively looping, we should see it \"immediately\". The air-quotes there are significant though, because we *don't* see it immediately. There are three major factors here:\r\n\r\n- Are we asynchronously suspended? If so, then cancelation is reflected instantly on the carrier thread for the *calling* fiber.\r\n- Are we within some sort of expensive action? `Delay` is the most common culprit here, but an expensive (but pure) computation within `map` or `flatMap` can also be an issue. If so, then we won't see the flag until it completes. Obviously if \"expensive action\" means \"actually blocking\" then we're really in trouble.\r\n- Is our thread even being scheduled by the kernel right now?\r\n\r\nThat ultimate one obviously we can't get away from at all unless we use a single-threaded pool (e.g. JavaScript or Coop), and the penultimate one is fundamental to the fact that cancelation is a *hint* rather than an enforced action. This, I think, is really where the rubber meets the road on cooperative multitasking on the JVM. Thread pools and the nature of asynchronous suspensions mean that we usually don't have to think much about `cede` outside of fairness optimizations, but *cancelation* is something that fibers have to actively cooperate on, and they don't always have the option of doing so.\r\n\r\nThus, even in the least opaque model (a `@volatile` flag polled on every loop), we still can't give users a totally clear cut \"*this* will happen every time you sequence `Fiber#cancel`\", because it just isn't possible to know.\r\n\r\nNow, the least opaque model is a bit of a non-starter if we want a pretense of performance in the runloop, since crossing a read barrier on every iteration is going to degrade performance. Though, in my measurements, the degradation doesn't seem quite as bad as I expected (around 0.5-1.5% slower in the `pure` bind benchmarks when I mark `canceled` as `@volatile`, which is almost within the margin of error on my laptop for the mode I was running in). This kind of raises the question of what kind of performance we really care about here, which is a fair argument that I'm trying to avoid, since it makes optimization of almost any kind in `IO` feel pretty pointless. :-)\r\n\r\nIt's also worth noting that the JVM might be doing something fancy to eliminate the uncontested read barrier in benchmarks. It honestly wouldn't surprise me if that were the case.\r\n\r\nBut at any rate, master mitigates the performance hit of the read barrier by only crossing it once every 512 loops, but if you're only polling once every 512 iterations, are you really giving users a more comprehensible model of what's going on? And are users *seriously* going to go that many `flatMap`s without accessing *any* `object` at all? (the moment they do, a read barrier is hit and cancelation becomes visible)\r\n\r\nOh, and all of this is ignoring the effects of masking, which makes cancelation even *less* reliable from an outside fiber's perspective, since you can't be canceled within a masked block (cancelation takes effect the moment you exit the block though, or the moment you hit a `poll` within the block that removes your mask).\r\n\r\nUltimately, I think that the way to give users a definite model of what's going to happen when they sequence `cancel` is to promise *less*, as the abstractions do. We can say the following with absolute confidence and accuracy:\r\n\r\n- If the canceled fiber is semantically blocked, it will be *immediately* canceled and finalizers run when `cancel` is sequenced\r\n- At all other times, cancelation is a *hint* which is likely to be observed and acted upon very quickly, but you shouldn't rely on any precise timing\r\n\r\nWithin the framework of those invariants, I honestly think it's fine to keep `canceled` as non-volatile. It only affects the granularity of second invariant, and only to a limited degree. In practice, it *probably* results in higher granularity than master anyway, since we're polling on every loop. With that said, the performance impact of the volatile read doesn't appear to be too severe (though without reading the assembly, I can't be 100% sure that the JVM didn't out-smart my benchmark), so if you feel strongly about it, we can go down the volatile bit road and see where it takes us.",
        "createdAt" : "2020-07-08T14:50:48Z",
        "updatedAt" : "2020-07-11T18:35:51Z",
        "lastEditedBy" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "tags" : [
        ]
      },
      {
        "id" : "41130572-3572-41c1-8b53-be64ec62017b",
        "parentId" : "4cebb288-050d-4dee-9ca1-840fe3113369",
        "authorId" : "a5a514ff-cd89-45cb-bcc8-796f0fa2a445",
        "body" : "I mostly agree with the above. My main point is this actually (after more thinking). I think we should be able to answer the question: \"what's the most reasonable code that users can write, that becomes practically uncancelable under this model?\", whereas by \"practically\" I mean that cancelation kicks in so late that it's pointless, for example a long loop where only the last instruction is cancelable, it's not practically cancelable.\r\n\r\n\r\n",
        "createdAt" : "2020-07-08T14:59:11Z",
        "updatedAt" : "2020-07-11T18:35:51Z",
        "lastEditedBy" : "a5a514ff-cd89-45cb-bcc8-796f0fa2a445",
        "tags" : [
        ]
      },
      {
        "id" : "398fe4ca-9d17-4b29-8095-be1b4b1e9ee4",
        "parentId" : "4cebb288-050d-4dee-9ca1-840fe3113369",
        "authorId" : "a5a514ff-cd89-45cb-bcc8-796f0fa2a445",
        "body" : "> With that said, the performance impact of the volatile read doesn't appear to be too severe\r\n\r\nTbh on the volatile I'm more worried about correctness than  anything else, especially when this IO becomes a live codebase, correctness seems to be predicated on rather subtle invariants, so I think the info about the perf hit of `volatile` is good to keep in mind anyway.",
        "createdAt" : "2020-07-08T15:01:56Z",
        "updatedAt" : "2020-07-11T18:35:51Z",
        "lastEditedBy" : "a5a514ff-cd89-45cb-bcc8-796f0fa2a445",
        "tags" : [
        ]
      },
      {
        "id" : "592bb2db-8874-4206-af18-e32f3785c01e",
        "parentId" : "4cebb288-050d-4dee-9ca1-840fe3113369",
        "authorId" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "body" : "> what's the most reasonable code that users can write, that becomes practically uncancelable under this model?\r\n\r\nSee that's the interesting thing: it's *really* hard to avoid read barriers. For example:\r\n\r\n```scala\r\nlazy val loop: IO[Unit] = IO.unit.flatMap(_ => loop)\r\n```\r\n\r\nThat has a read barrier on every iteration (hitting the `IO.MODULE$` volatile static). Maybe we can avoid this by capturing the `Monad` instance though:\r\n\r\n```scala\r\nimport cats.syntax.monad._\r\ndef loop[F[_]: Monad]: IO[Unit] =\r\n  Monad[F].unit.flatMap(_ => loop[F])\r\n\r\nloop[IO]\r\n```\r\n\r\nThis has *two* read barriers per loop: the `Monad` module read, and the `cats.syntax.monad` module read (for the `flatMap` extension method). Okay so maybe we try to capture more instances:\r\n\r\n```scala\r\ndef loop[F[_]](implicit F: Monad[F]): F[Unit] =\r\n  F.unit.flatMap(_ => loop[F])\r\n\r\nloop[IO]\r\n```\r\n\r\nWe're avoiding one of the barriers! We still need to avoid the other one though:\r\n\r\n```scala\r\ndef loop[F[_]](implicit F: Monad[F]): F[Unit] =\r\n  F.flatMap(F.unit)(_ => loop[F])\r\n\r\nloop[IO]\r\n```\r\n\r\nAnother option would be to just loop forever on a concrete `IO` we were handed:\r\n\r\n```scala\r\ndef loop[A](ioa: IO[A]): IO[Unit] =\r\n  ioa.flatMap(_ => loop(ioa))\r\n```\r\n\r\nOkay, *that* has no read barriers within the loop. Both are also a little silly. How long do you go in Scala *without* hitting an `object` or `package object`? *Particularly* if using Cats, which has tons and tons of objects everywhere that you may not even see (like the syntax objects)? I'd be willing to bet that, outside of severely contrived cases, this just isn't going to happen. You're honestly going to have to work *very* hard to build a long loop that doesn't have any read barriers at all.",
        "createdAt" : "2020-07-08T15:09:39Z",
        "updatedAt" : "2020-07-11T18:35:51Z",
        "lastEditedBy" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "tags" : [
        ]
      },
      {
        "id" : "84c42ce2-7f8a-42cf-912b-62ce8d90a82c",
        "parentId" : "4cebb288-050d-4dee-9ca1-840fe3113369",
        "authorId" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "body" : "> Tbh on the volatile I'm more worried about correctness than anything else, especially when this IO becomes a live codebase, correctness seems to be predicated on rather subtle invariants, so I think the info about the perf hit of volatile is good to keep in mind anyway.\r\n\r\nThis probably means I should dig up the actual specification on read semantics of non-volatile fields… Also I agree with you. There are a *lot* of subtle invariants being relied upon in here. Honestly I'm less worried about cancelation and more worried about the `finalizers` stack, which is based on an array, but if non-volatile writes don't get properly published when passing through hard write barriers (in the case I'm worried about, specifically bouncing through an `Executor`), then finalizers might get nondeterministically lost during asynchronous suspensions, which is obviously a nonstarter.",
        "createdAt" : "2020-07-08T15:22:02Z",
        "updatedAt" : "2020-07-11T18:35:51Z",
        "lastEditedBy" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "tags" : [
        ]
      },
      {
        "id" : "26f821e9-3989-44d1-b8ac-5faa1c26d827",
        "parentId" : "4cebb288-050d-4dee-9ca1-840fe3113369",
        "authorId" : "a5a514ff-cd89-45cb-bcc8-796f0fa2a445",
        "body" : "I'm thinking things patterns like `Pull` (but with `IO`), on FFI code, where you basically have a loop `IO(...).flatMap( if condition then stop else loop)`, but I am coming around :)\r\n\r\nAlso agree on the `finalizers` comment, although I haven't yet had a look at how that works",
        "createdAt" : "2020-07-08T15:28:43Z",
        "updatedAt" : "2020-07-11T18:35:51Z",
        "lastEditedBy" : "a5a514ff-cd89-45cb-bcc8-796f0fa2a445",
        "tags" : [
        ]
      },
      {
        "id" : "ce1586cc-1947-4000-bc12-b4df8716c9b1",
        "parentId" : "4cebb288-050d-4dee-9ca1-840fe3113369",
        "authorId" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "body" : "> IO(...).flatMap( if condition then stop else loop)\r\n\r\nRead barrier on that `IO(...)`! :-)\r\n\r\n> Also agree on the finalizers comment, although I haven't yet had a look at how that works\r\n \r\nI have a mild suspicion that, right now, it doesn't. I'm chasing down a bug in `race` which might be caused by it.",
        "createdAt" : "2020-07-08T15:30:17Z",
        "updatedAt" : "2020-07-11T18:35:51Z",
        "lastEditedBy" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "tags" : [
        ]
      },
      {
        "id" : "87fb206f-e1af-4c3b-886c-31c456a2e699",
        "parentId" : "4cebb288-050d-4dee-9ca1-840fe3113369",
        "authorId" : "3b5d55eb-40d5-4d14-a8a4-3ed1601b5bff",
        "body" : "> See that's the interesting thing: it's really hard to avoid read barriers. For example:\r\n\r\nIn your example, there's a read barrier, but I don't think its guaranteed to ever propagate writes to `canceled`. IIRC the semantic is something like this: all writes by thread A to non-volatile variables that happen before a write to a volatile variable (or something with an equivalent memory effect) will be visible to thread B *after* B reads that volatile variable. There might be more implementation details but I don't think we should rely on them. So unless one thread is actually writing to the `IO` module object, reading that reference would never cause state to be published.",
        "createdAt" : "2020-07-08T15:30:24Z",
        "updatedAt" : "2020-07-11T18:35:51Z",
        "lastEditedBy" : "3b5d55eb-40d5-4d14-a8a4-3ed1601b5bff",
        "tags" : [
        ]
      },
      {
        "id" : "1c4c01a6-4536-4268-8094-07c1198b94d1",
        "parentId" : "4cebb288-050d-4dee-9ca1-840fe3113369",
        "authorId" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "body" : "I really need to just read the JVM documentation on this one… I'm making too many assumptions for my own comfort.",
        "createdAt" : "2020-07-08T15:31:40Z",
        "updatedAt" : "2020-07-11T18:35:51Z",
        "lastEditedBy" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "tags" : [
        ]
      },
      {
        "id" : "c914e0c9-7920-4879-98df-cdbbe251a708",
        "parentId" : "4cebb288-050d-4dee-9ca1-840fe3113369",
        "authorId" : "3b5d55eb-40d5-4d14-a8a4-3ed1601b5bff",
        "body" : "> I believe CAS is actually a write barrier, since the happens-before relation on writes must be maintained, and the \"swap\" portion of that acronym is immediately visible across threads. I will freely admit though that my understanding of the JVM's (and x86's) memory barriers is imperfect.\r\n\r\nAccording to the docs, CAS has the effects of both a read and write memory barrier (as do all other get-and-set style operations), so I think it works, since the read memory barrier is what we need here for `canceled` to be up-to-date. \r\n\r\nSo, the cancellation flow would look something like this:\r\n1. Fiber A cancels B, setting `fiberB.canceled` to true\r\n2. Fiber A performs a CAS on `fiberB.suspended`, publishing the write to `fiberB.canceled`\r\n3. Fiber B performs a CAS on `fiberB.suspended`, pulling in the writes to `fiberB.canceled`\r\n4. Fiber B reads an up-to-date value of `fiberB.canceled`\r\n\r\nThere is that one read of `canceled` before #3 that I'm thinking about now",
        "createdAt" : "2020-07-08T15:36:36Z",
        "updatedAt" : "2020-07-11T18:35:51Z",
        "lastEditedBy" : "3b5d55eb-40d5-4d14-a8a4-3ed1601b5bff",
        "tags" : [
        ]
      },
      {
        "id" : "5eb99548-fa16-464c-816f-8c3f07c87b3e",
        "parentId" : "4cebb288-050d-4dee-9ca1-840fe3113369",
        "authorId" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "body" : "The flow that's more troublesome is this:\r\n\r\n1. Fiber A (on Thread 1) cancels B (on Thread 2) setting `fiberB.canceled` to `true`\r\n2. Fiber A performs a CAS on `fiberB.suspended`, publishing writes to `fiberB.canceled`\r\n3. Fiber A performs a CAS on `fiberA.suspended` and releases Thread 1 back to the pool (which also has associated barriers)\r\n4. Fiber B (on Thread 1) merrily churns through `runLoop`, reading `fiberB.canceled` but never having looked at `fiberB.suspended`\r\n5. … profit?\r\n\r\nIn other words, I think you may be right that this is insufficient, and *in practice* you're only going to see cancelation at `cede` boundaries, since you either need to hit `suspended` (which only happens when you semantically block in `async`) or you need to bounce through the executor and hit *its* memory barriers, which happens during `cede` and after every `async`.",
        "createdAt" : "2020-07-08T15:44:14Z",
        "updatedAt" : "2020-07-11T18:35:51Z",
        "lastEditedBy" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "tags" : [
        ]
      },
      {
        "id" : "03c572c1-48f8-4606-a65f-6956f55610d5",
        "parentId" : "4cebb288-050d-4dee-9ca1-840fe3113369",
        "authorId" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "body" : "Okay, having thought about this more, here's what I propose…\r\n\r\nI'll add an `Int` counter to `runLoop`, incremented on each tail-recursive call. When the counter hits 512, we'll run `suspended.get()` just to insert a read barrier and reset the counter. All bounces through the executor can also reset the counter, since that functions nicely as a read/write barrier in and of itself. `canceled` will remain non-volatile.\r\n\r\nI believe this is, overall, still more efficient than master (since we're avoiding memory barriers more aggressively), has *at worst* the same resolution of cancelation detection (once every 512 pure `flatMap`s), and in many cases, much finer-grained resolution. It also ensures that self-cancelation is detected immediately, which is obviously important to preserve.",
        "createdAt" : "2020-07-09T15:26:53Z",
        "updatedAt" : "2020-07-11T18:35:51Z",
        "lastEditedBy" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "tags" : [
        ]
      }
    ],
    "commit" : "11095f3ade81d210f681ceeeb6c55e2c3c66a768",
    "line" : 538,
    "diffHunk" : "@@ -1,1 +536,540 @@                    if (!firstCanceled.compareAndSet(false, true)) {\n                      // both are canceled, and we're the second, then cancel the outer fiber\n                      canceled = true\n                      // TODO manually reset our masks to initMask; IO.uncancelable(p => IO.race(p(IO.canceled), IO.pure(42))) doesn't work\n                      // this is tricky, but since we forward our masks to our child, we *know* that we aren't masked, so the runLoop will just immediately run the finalizers for us"
  },
  {
    "id" : "0f111c43-2d13-4e80-b676-87c9c86d9ff6",
    "prId" : 911,
    "prUrl" : "https://github.com/typelevel/cats-effect/pull/911#pullrequestreview-443303910",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9206ee42-a136-4140-a274-9fd40b51db80",
        "parentId" : null,
        "authorId" : "3b5d55eb-40d5-4d14-a8a4-3ed1601b5bff",
        "body" : "Thread safety concern here again",
        "createdAt" : "2020-07-06T17:16:28Z",
        "updatedAt" : "2020-07-11T18:35:51Z",
        "lastEditedBy" : "3b5d55eb-40d5-4d14-a8a4-3ed1601b5bff",
        "tags" : [
        ]
      },
      {
        "id" : "07361b4f-925a-401e-af90-29f33f2008c3",
        "parentId" : "9206ee42-a136-4140-a274-9fd40b51db80",
        "authorId" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "body" : "Similar argument here: if the mutation to `cancel` is *not* observed by another thread, then it will just… run the old `cancel`, which performs two idempotent non-volatile writes and then gets gated by an `AtomicReference` CAS and bails out. So in other words, the `cancel` and `join` mutations are actually just fast-path optimizations: it's still correct to use the old versions, it's just *faster* to use the new versions, but not faster by enough of a margin that it's worth hitting a memory barrier every time.",
        "createdAt" : "2020-07-06T18:12:51Z",
        "updatedAt" : "2020-07-11T18:35:51Z",
        "lastEditedBy" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "tags" : [
        ]
      }
    ],
    "commit" : "11095f3ade81d210f681ceeeb6c55e2c3c66a768",
    "line" : 147,
    "diffHunk" : "@@ -1,1 +145,149 @@    val prelude = IO {\n      canceled = true\n      cancel = IO.unit\n    }\n"
  },
  {
    "id" : "1718c7ae-fb6d-4292-8aca-6dad66878de1",
    "prId" : 911,
    "prUrl" : "https://github.com/typelevel/cats-effect/pull/911#pullrequestreview-443325677",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c5261a4a-e0a2-4ae6-98b5-5acf04558191",
        "parentId" : null,
        "authorId" : "3b5d55eb-40d5-4d14-a8a4-3ed1601b5bff",
        "body" : "So, if both of the child fibers are cancelled, we're going to cancel the supervisor fiber. I assume we want to do this because fibers can cancel themselves now (what's the rationale behind this btw? `raiseError` always feels like the right choice when a fiber decides to terminate on its own), and if both happen to cancel, the supervisor would otherwise be stuck in the void.\r\n\r\nI wonder if it's worth communicating the state of both fibers being cancelled, and writing a combinator that would reflect the behavior here? Cancelling the parent fiber seems too strong",
        "createdAt" : "2020-07-06T17:52:16Z",
        "updatedAt" : "2020-07-11T18:35:51Z",
        "lastEditedBy" : "3b5d55eb-40d5-4d14-a8a4-3ed1601b5bff",
        "tags" : [
        ]
      },
      {
        "id" : "ca98e227-90b9-41a6-8083-6fb81dea1d51",
        "parentId" : "c5261a4a-e0a2-4ae6-98b5-5acf04558191",
        "authorId" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "body" : "I guess I haven't actually tested this on master. Basically the semantic (which is codified by `ConcurrentLaws`) is this kind of situation:\r\n\r\n```scala\r\nF.race(fa >> F.canceled >> fb, fc)\r\n```\r\n\r\nAssume that `canceled` represents a point at which the inner fiber is canceled, then I really think the outer fiber should be canceled as well. There are really only two scenarios here:\r\n\r\n- Canceled by some outer-outer fiber, which is in turn being forwarded on to the child fibers by the cancelation handler on `async`. In this scenario, the outer fiber is already canceled, so it's all good\r\n- *Self*-cancelation within the body of the `race`. In this case, I guess I'm making a subjective call that this should be treated the same as outer cancelation\r\n\r\nThe crux of my argument comes down to mental models: I don't think of `racePair` as being the same as `start`. It certainly behaves differently in terms of `uncancelable`. Instead, I kind of think of `racePair` as being a special construct which only uses fibers as an implementation detail, and thus it should behave the same as any other combinator when it comes to fiber identity, and thus cancelation semantics.",
        "createdAt" : "2020-07-06T18:18:22Z",
        "updatedAt" : "2020-07-11T18:35:51Z",
        "lastEditedBy" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "tags" : [
        ]
      },
      {
        "id" : "5fa47dfd-a15c-491b-a107-0aad0fa88ad5",
        "parentId" : "c5261a4a-e0a2-4ae6-98b5-5acf04558191",
        "authorId" : "3b5d55eb-40d5-4d14-a8a4-3ed1601b5bff",
        "body" : "On master, self-cancellation isn't possible, so you couldn't really end up in a situation like this. Only one of the handles of the fibers are exposed, but only after the other completes, so you would never end up in a state where both fibers are externally cancelled either.\r\n\r\nYour mental model makes sense to me",
        "createdAt" : "2020-07-06T18:47:25Z",
        "updatedAt" : "2020-07-11T18:35:51Z",
        "lastEditedBy" : "3b5d55eb-40d5-4d14-a8a4-3ed1601b5bff",
        "tags" : [
        ]
      }
    ],
    "commit" : "11095f3ade81d210f681ceeeb6c55e2c3c66a768",
    "line" : 536,
    "diffHunk" : "@@ -1,1 +534,538 @@                    }\n                  } else {\n                    if (!firstCanceled.compareAndSet(false, true)) {\n                      // both are canceled, and we're the second, then cancel the outer fiber\n                      canceled = true"
  },
  {
    "id" : "2f6eaf75-b9c0-4faf-ad4e-5366abd6427d",
    "prId" : 911,
    "prUrl" : "https://github.com/typelevel/cats-effect/pull/911#pullrequestreview-443995540",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9d5bc711-37ce-4c66-b117-c6fe68b4a8f4",
        "parentId" : null,
        "authorId" : "3b5d55eb-40d5-4d14-a8a4-3ed1601b5bff",
        "body" : "Seems like some formatting issues here",
        "createdAt" : "2020-07-07T01:40:37Z",
        "updatedAt" : "2020-07-11T18:35:51Z",
        "lastEditedBy" : "3b5d55eb-40d5-4d14-a8a4-3ed1601b5bff",
        "tags" : [
        ]
      },
      {
        "id" : "07c04063-1a01-4ae1-86ea-5f9896bc2312",
        "parentId" : "9d5bc711-37ce-4c66-b117-c6fe68b4a8f4",
        "authorId" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "body" : "Actually I *think* this is correct.",
        "createdAt" : "2020-07-07T01:47:41Z",
        "updatedAt" : "2020-07-11T18:35:51Z",
        "lastEditedBy" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "tags" : [
        ]
      },
      {
        "id" : "cb097520-c78b-41aa-b604-10d41f6e2138",
        "parentId" : "9d5bc711-37ce-4c66-b117-c6fe68b4a8f4",
        "authorId" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "body" : "Oh it's on the *next* line that it's messed up! Wow I can't believe I missed that. Thank you!",
        "createdAt" : "2020-07-07T15:17:43Z",
        "updatedAt" : "2020-07-11T18:35:51Z",
        "lastEditedBy" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "tags" : [
        ]
      }
    ],
    "commit" : "11095f3ade81d210f681ceeeb6c55e2c3c66a768",
    "line" : 270,
    "diffHunk" : "@@ -1,1 +268,272 @@          case Right(a) => succeeded(a, 0)\n        }\n\n        runLoop(next, 0)    // we've definitely hit suspended as part of evaluating async\n      }"
  },
  {
    "id" : "e74ed1cc-5037-42d5-b5d7-9769481316f3",
    "prId" : 911,
    "prUrl" : "https://github.com/typelevel/cats-effect/pull/911#pullrequestreview-443990937",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "aca61e1b-4f78-4695-ab84-28cc2eddebaa",
        "parentId" : null,
        "authorId" : "3b5d55eb-40d5-4d14-a8a4-3ed1601b5bff",
        "body" : "The effect of this is that cancellation of a fiber will invoke the finalizers only if the fiber is suspended in an asynchronous boundary, correct? In `IO` on master, if the cancellee was in a flatMap loop, the *canceller* would still run the finalizers. In this PR, the finalizers would be invoked by the *cancellee* once the `flatMap` loop encounters an asynchronous boundary.",
        "createdAt" : "2020-07-07T04:09:01Z",
        "updatedAt" : "2020-07-11T18:35:51Z",
        "lastEditedBy" : "3b5d55eb-40d5-4d14-a8a4-3ed1601b5bff",
        "tags" : [
        ]
      },
      {
        "id" : "80110f56-2ee2-40dc-8c9d-996b912aaa1e",
        "parentId" : "aca61e1b-4f78-4695-ab84-28cc2eddebaa",
        "authorId" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "body" : "This is correct. I did this mostly to ensure that the runloop doesn't need to be forcibly relocated. Additionally, this creates strong sequencing between the runloop and the finalizers: if the runloop is actively running something (like a `Delay`), it will wait to complete *before* running the finalizers, which seems like a more reasonable user semantic. Avoiding the need to forcibly relocate the loop is a huge win because it avoids the need to inject costly polling into the loop. This right here is the reason that `canceled` can be non-volatile.",
        "createdAt" : "2020-07-07T15:12:49Z",
        "updatedAt" : "2020-07-11T18:35:51Z",
        "lastEditedBy" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "tags" : [
        ]
      }
    ],
    "commit" : "11095f3ade81d210f681ceeeb6c55e2c3c66a768",
    "line" : 150,
    "diffHunk" : "@@ -1,1 +148,152 @@    }\n\n    val completion = IO(suspended.compareAndSet(true, false)).ifM(\n      IO {\n        // println(s\"<$name> running cancelation (finalizers.length = ${finalizers.unsafeIndex()})\")"
  },
  {
    "id" : "e489cfc5-ffc2-46e2-8167-ee1b85169b61",
    "prId" : 911,
    "prUrl" : "https://github.com/typelevel/cats-effect/pull/911#pullrequestreview-445728405",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7c071bf8-20d7-4ccd-954a-d50839346088",
        "parentId" : null,
        "authorId" : "3b5d55eb-40d5-4d14-a8a4-3ed1601b5bff",
        "body" : "Is the `objectState` stack being used to hold the callback value (rather than an instance variable) because finalizers run in the same `IOFiber`, but possibly on a different thread? It was quite a bit of indirection to get my head around",
        "createdAt" : "2020-07-07T04:11:59Z",
        "updatedAt" : "2020-07-11T18:35:51Z",
        "lastEditedBy" : "3b5d55eb-40d5-4d14-a8a4-3ed1601b5bff",
        "tags" : [
        ]
      },
      {
        "id" : "9a9cedfd-26a5-4d93-ad10-9582c80ab64a",
        "parentId" : "7c071bf8-20d7-4ccd-954a-d50839346088",
        "authorId" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "body" : "`objectState` is actually being used to hold anything that is needed by continuations, since the continuations are all pre-allocated. It's easier to understand in the context of the `Map` interpretation, where the `f` is what gets pushed onto the stack. I agree it's really confusing. :-)\r\n\r\nBasically, this is just an allocation-free bit of closure encoding. Or rather, *amortized* allocation-free, since the array doubles when it grows.",
        "createdAt" : "2020-07-07T15:14:41Z",
        "updatedAt" : "2020-07-11T18:35:51Z",
        "lastEditedBy" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "tags" : [
        ]
      },
      {
        "id" : "d054c833-b225-415c-88d8-4b333bb8e87e",
        "parentId" : "7c071bf8-20d7-4ccd-954a-d50839346088",
        "authorId" : "3b5d55eb-40d5-4d14-a8a4-3ed1601b5bff",
        "body" : "All the continuations still have access to the member variables of `IOFiber` though. I guess I don't see the point of the stack, since, if I'm not mistaken, you never really stack asynchronous state in the same way that you need to for bind continuations.\r\n\r\nThis is probably more in the realm of optimization, but what if `state` was just a member variable that's reused for every `Async` op (not dissimilar from how `RestartCallback` held state)? Then we're avoiding an allocation and two `ArrayStack` operations. Same argument for `done` and maybe others.",
        "createdAt" : "2020-07-08T02:57:12Z",
        "updatedAt" : "2020-07-11T18:35:51Z",
        "lastEditedBy" : "3b5d55eb-40d5-4d14-a8a4-3ed1601b5bff",
        "tags" : [
        ]
      },
      {
        "id" : "5632c0eb-9e0e-4c0b-b7c4-28b24052d308",
        "parentId" : "7c071bf8-20d7-4ccd-954a-d50839346088",
        "authorId" : "3b5d55eb-40d5-4d14-a8a4-3ed1601b5bff",
        "body" : "Ah, I think I see it now... is it because of the registration effect that an async op returns? That effect can run an async op, so we need to be able to stack this state in order to avoid invoking a new run-loop, which is what `IO` on master does",
        "createdAt" : "2020-07-08T03:48:18Z",
        "updatedAt" : "2020-07-11T18:35:51Z",
        "lastEditedBy" : "3b5d55eb-40d5-4d14-a8a4-3ed1601b5bff",
        "tags" : [
        ]
      },
      {
        "id" : "7239f69b-1f34-4d41-b5ef-fbfb4b87f9be",
        "parentId" : "7c071bf8-20d7-4ccd-954a-d50839346088",
        "authorId" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "body" : "Well, we do technically invoke a new runloop. :-) That's in `asyncContinue`.\r\n\r\nThe \"state as a stack\" model is required to handle right-associated combinators, but particularly `map`/`flatMap`. For example:\r\n\r\n```scala\r\nfa.flatMap(_ => fb).flatMap(_ => fc)\r\n```\r\n\r\nThere will be two elements on the `objectState` stack here, `(_ => fb)` and `(_ => fc)`, and two continuations on the `conts` stack, both `FlatMapK`. This alone makes it impossible to have just a single variable maintaining the state, but it gets worse if `fb` is something complicated (like a series of `flatMap`s), because all of those need to be pushed on the stack *above* the continuation and state for `(_ => fc)`. So this is why the stack encoding in the first place.\r\n\r\nIn a sense, it's best to think of the three stacks (`conts`, `objectState`, and `booleanState`) as being the *call stack* of the `IO`. It has to live on the heap because the whole monad is based around continuations, which can be relocated to a different thread at any moment. Without allocating, we can't merge these three stacks together into a single data structure, so we keep them separate since everything we push onto them has already been allocated by someone else (e.g. the closure associated with the `flatMap`).",
        "createdAt" : "2020-07-08T14:18:29Z",
        "updatedAt" : "2020-07-11T18:35:51Z",
        "lastEditedBy" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "tags" : [
        ]
      },
      {
        "id" : "514bf411-5856-4713-8be1-bb5df775faa6",
        "parentId" : "7c071bf8-20d7-4ccd-954a-d50839346088",
        "authorId" : "3b5d55eb-40d5-4d14-a8a4-3ed1601b5bff",
        "body" : "Do you mean left-associated combinators? The example you posted translates to something like `FlatMap(FlatMap(fa, _ => fb), _ => fc)`. The right-associated version doesn't need to push more than one continuation onto the stack.",
        "createdAt" : "2020-07-08T20:50:10Z",
        "updatedAt" : "2020-07-11T18:35:51Z",
        "lastEditedBy" : "3b5d55eb-40d5-4d14-a8a4-3ed1601b5bff",
        "tags" : [
        ]
      },
      {
        "id" : "a0ecaa9c-818f-4e41-9e99-0ef2f61e9268",
        "parentId" : "7c071bf8-20d7-4ccd-954a-d50839346088",
        "authorId" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "body" : "Oh yeah you're completely right. Sorry, I get \"left vs right\" mixed up when dealing with endofunctors. :-)",
        "createdAt" : "2020-07-09T15:27:52Z",
        "updatedAt" : "2020-07-11T18:35:51Z",
        "lastEditedBy" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "tags" : [
        ]
      }
    ],
    "commit" : "11095f3ade81d210f681ceeeb6c55e2c3c66a768",
    "line" : 351,
    "diffHunk" : "@@ -1,1 +349,353 @@\n            objectState.push(done)\n            objectState.push(state)\n\n            val next = cur.k { e =>"
  },
  {
    "id" : "20395abc-dbc6-4fc0-91b1-575766a0cd1b",
    "prId" : 911,
    "prUrl" : "https://github.com/typelevel/cats-effect/pull/911#pullrequestreview-445912094",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f1ea64e8-e4b1-4877-b9e8-74a9aa4e6d6e",
        "parentId" : null,
        "authorId" : "3b5d55eb-40d5-4d14-a8a4-3ed1601b5bff",
        "body" : "This is just `async_(cb => cb(Right(())))` as a primitive?",
        "createdAt" : "2020-07-08T04:58:05Z",
        "updatedAt" : "2020-07-11T18:35:51Z",
        "lastEditedBy" : "3b5d55eb-40d5-4d14-a8a4-3ed1601b5bff",
        "tags" : [
        ]
      },
      {
        "id" : "20b20be2-8983-42a2-be97-6e8f6172965e",
        "parentId" : "f1ea64e8-e4b1-4877-b9e8-74a9aa4e6d6e",
        "authorId" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "body" : "Yep, but it's considerably more efficient since we know a few important things. The most expensive bits of `Async`'s implementation are dealing with the race between registration and callback, and then subsequently avoiding multi-shot continuations, not to mention the boxing into `Either` imposed by error handling. `cede` doesn't use any of that stuff (its registration function does nothing, its callback is guaranteed to be invoked exactly once, and it never errors), so it can be a lot simpler.",
        "createdAt" : "2020-07-08T14:11:44Z",
        "updatedAt" : "2020-07-11T18:35:51Z",
        "lastEditedBy" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "tags" : [
        ]
      },
      {
        "id" : "88c065e2-e72e-49e6-a0f3-d9382434fd9d",
        "parentId" : "f1ea64e8-e4b1-4877-b9e8-74a9aa4e6d6e",
        "authorId" : "3b5d55eb-40d5-4d14-a8a4-3ed1601b5bff",
        "body" : "Since we established that the read barrier on `IO` module object won't update `canceled`, do we need to check for cancellation explicitly for `cede` now? Maybe even suspend the fiber since this is technically an asynchronous boundary",
        "createdAt" : "2020-07-08T20:20:27Z",
        "updatedAt" : "2020-07-11T18:35:51Z",
        "lastEditedBy" : "3b5d55eb-40d5-4d14-a8a4-3ed1601b5bff",
        "tags" : [
        ]
      },
      {
        "id" : "a437ed09-db93-4344-afc8-6d7ceba12c79",
        "parentId" : "f1ea64e8-e4b1-4877-b9e8-74a9aa4e6d6e",
        "authorId" : "3b5d55eb-40d5-4d14-a8a4-3ed1601b5bff",
        "body" : "I also don't think we can rely on the `ExecutionContext` to propagate state because (1) `ExecutionContext` is an abstraction that says nothing about memory effects and implementations have a great deal of liberty in how they decide to synchronize state and (2) if we could rely on the fact that `ExecutionContext` had an internal memory barrier, a cancelling fiber would need to pass the write memory barrier on it after writing to `cancel`.",
        "createdAt" : "2020-07-08T20:58:48Z",
        "updatedAt" : "2020-07-11T18:35:51Z",
        "lastEditedBy" : "3b5d55eb-40d5-4d14-a8a4-3ed1601b5bff",
        "tags" : [
        ]
      },
      {
        "id" : "29e880ce-57db-427f-bb62-6f7a447dce26",
        "parentId" : "f1ea64e8-e4b1-4877-b9e8-74a9aa4e6d6e",
        "authorId" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "body" : "> Since we established that the read barrier on IO module object won't update canceled, do we need to check for cancellation explicitly for cede now?\r\n> […]\r\n> I also don't think we can rely on the ExecutionContext to propagate state because (1) ExecutionContext is an abstraction that says nothing about memory effects and implementations have a great deal of liberty in how they decide to synchronize state and (2) if we could rely on the fact that ExecutionContext had an internal memory barrier, a cancelling fiber would need to pass the write memory barrier on it after writing to cancel.\r\n\r\nIf we assume that the `ExecutionContext` *implementation* involves multiple `Thread`s, then there must exist a pair of write barriers within the implementation: one on `execute` (which is the task enqueue), and one on the worker `Thread` dequeueing the task. These barriers are, I believe, *entirely* fundamental and cannot be avoided. Even a super-naive `ExecutionContext` which creates a `new Thread` on every `execute` and allows it to die upon completion would still hit these kinds of barriers (I believe thread creation/destruction *also* counts as a write barrier).\r\n\r\nConversely, we could assume `ExecutionContext`'s implementation is single-threaded (e.g. `parasitic`). In this case, memory barriers are irrelevant since everything is on the same carrier `Thread` anyway, so we don't need to worry about visibility.\r\n\r\nThus, in all cases, we can rely on suspension to be a visibility guarantee on all of our non-volatile state.\r\n\r\n> Maybe even suspend the fiber since this is technically an asynchronous boundary\r\n\r\n`suspended` is perhaps a bit misnamed. What it really means is that the runloop is disassociated with any particular owner and may be reclaimed. By \"owner\" in this case I mean \"semantic thread of execution\". `cede` doesn't fall into this category because it's simply relocating a stable runloop to a different thread (or potentially the same thread). It isn't *suspended* so much as *yielded*.\r\n\r\nPerhaps a clearer way of looking at it: suspension has a potentially unbounded duration, while yielding is entirely within the control of the executor, and likely to be very short. The relevant consequence here is for `cancel`: when a fiber is within a `cede`, the runloop is coming back, and so we want *that* runloop to control cancelation and termination, since like, it *can*. Conversely, when a fiber is within an `async`, we don't know when or even if the runloop will return to active status, so `cancel` can take over and run the finalizers itself. This is what `suspended` governs.",
        "createdAt" : "2020-07-09T15:39:42Z",
        "updatedAt" : "2020-07-11T18:35:51Z",
        "lastEditedBy" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "tags" : [
        ]
      },
      {
        "id" : "2de9de86-ae3a-483e-aaca-2b931976979c",
        "parentId" : "f1ea64e8-e4b1-4877-b9e8-74a9aa4e6d6e",
        "authorId" : "3b5d55eb-40d5-4d14-a8a4-3ed1601b5bff",
        "body" : "For the cancellee fiber to actually observe cancellation, we need its bound thread to pass through at least a read barrier or a full memory barrier, since write barriers don't actually guarantee the visibility of changes made by other threads.\r\n\r\nEven if we can rely on the `ExecutionContext` having memory barriers, the canceller fiber still needs to pass through a write barrier on the synchronizing state behind the *same* `ExecutionContext`, which it doesn't in the current definition of `cancel`. In general, read and write barriers are associated with a specific memory location, so you can't just rely on *any* barrier for visibility.\r\n\r\nExplanation of `suspended` makes sense, thanks!",
        "createdAt" : "2020-07-09T16:13:31Z",
        "updatedAt" : "2020-07-11T18:35:51Z",
        "lastEditedBy" : "3b5d55eb-40d5-4d14-a8a4-3ed1601b5bff",
        "tags" : [
        ]
      },
      {
        "id" : "bc140643-10b5-4f3e-a594-7572b8b07913",
        "parentId" : "f1ea64e8-e4b1-4877-b9e8-74a9aa4e6d6e",
        "authorId" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "body" : "> Even if we can rely on the ExecutionContext having memory barriers, the canceller fiber still needs to pass through a write barrier on the synchronizing state behind the same ExecutionContext, which it doesn't in the current definition of cancel. In general, read and write barriers are associated with a specific memory location, so you can't just rely on any barrier for visibility.\r\n\r\nCheck my logic on this…\r\n\r\nThere are two `cancel` cases. In the `suspended = true` case, `cancel` controls the cancelation, and so we don't have to worry about visibility of `canceled = true`, so what we're really interested in is the case where `suspended = false`.\r\n\r\nIn this case, `cancel` itself hits a read/write barrier on `cancellee.suspended`, and then subsequently sequences `join`, which in turn is defined by `async`, which in *turn* hits a read/write barrier on `self.suspended` (as well as a few other local ones). Ultimately, it will swing round to `runLoop(null)`, which drops the carrier thread and returns to the `ExecutionContext`. The carrier thread will then pass through the read/write barrier *on the `ExecutionContext`'s task queue* (which I previously argued was fundamental regardless of implementation) before it either parks or grabs the next task. This ties the visibility of `canceled` to the read/write barrier on the `ExecutionContext`'s task queue.\r\n\r\nThis in *turn* means that there are two cancellee-relevant barriers which can be used to make `canceled` visible:\r\n\r\n- `suspended`\r\n- The `ExecutionContext`\r\n\r\nThus, when we `cede`, or even when we just call `execute`, we pass through the `ExecutionContext` read/write barrier, which forces `canceled`. I believe the only case where we *don't* see `canceled` quickly is a long chain of pure `flatMap`/`map`/`handleErrorWith` combinators. This is what my suggestion above (artificially inserting a `suspended.get()` when `runLoop` has iterated ≥ 512 times) attempts to resolve.",
        "createdAt" : "2020-07-09T16:59:02Z",
        "updatedAt" : "2020-07-11T18:35:51Z",
        "lastEditedBy" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "tags" : [
        ]
      },
      {
        "id" : "9b559a08-273d-4ab7-9d8c-ba5c370acbe2",
        "parentId" : "f1ea64e8-e4b1-4877-b9e8-74a9aa4e6d6e",
        "authorId" : "3b5d55eb-40d5-4d14-a8a4-3ed1601b5bff",
        "body" : "I think we'd need to guarantee that the carrier threads for both fibers are running on the same `ExecutionContext`, which isn't necessarily true right?\r\n```scala\r\nfa.start.flatMap(_.cancel.evalOn(ec2))\r\n```\r\nI think this is getting pretty hard to reason about. If the desired semantics dictate that `cede` should respect cancellation as soon as possible, we should make that explicitly clear. Since `ctx.execute()` is also probably hitting a queue of some sort, I imagine an extra read barrier on `cede` isn't even worth the optimization.",
        "createdAt" : "2020-07-09T17:27:56Z",
        "updatedAt" : "2020-07-11T18:35:51Z",
        "lastEditedBy" : "3b5d55eb-40d5-4d14-a8a4-3ed1601b5bff",
        "tags" : [
        ]
      },
      {
        "id" : "7c242c9c-3d64-4ffb-a8c3-fce86062dd4e",
        "parentId" : "f1ea64e8-e4b1-4877-b9e8-74a9aa4e6d6e",
        "authorId" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "body" : "> I think we'd need to guarantee that the carrier threads for both fibers are running on the same ExecutionContext, which isn't necessarily true right?\r\n\r\nExcellent point. Okay so we need to add a `suspended.get()` on `cede`, `async`, and `start` then I think.",
        "createdAt" : "2020-07-09T19:36:38Z",
        "updatedAt" : "2020-07-11T18:35:51Z",
        "lastEditedBy" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "tags" : [
        ]
      }
    ],
    "commit" : "11095f3ade81d210f681ceeeb6c55e2c3c66a768",
    "line" : 587,
    "diffHunk" : "@@ -1,1 +585,589 @@\n          // Cede\n          case 17 =>\n            currentCtx execute { () =>\n              // println(\"continuing from cede \")"
  },
  {
    "id" : "c7019e9b-9100-4bff-a5f6-b0e4d7e45a4a",
    "prId" : 911,
    "prUrl" : "https://github.com/typelevel/cats-effect/pull/911#pullrequestreview-446684019",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4bb6f8c2-765d-4260-bb42-a0b2528784bb",
        "parentId" : null,
        "authorId" : "3b5d55eb-40d5-4d14-a8a4-3ed1601b5bff",
        "body" : "I think this is a bug. If you happen to nest 2 `poll`s, the fiber will never be able to observe cancellation and will run to completion.\r\n```scala\r\nfor {\r\n  _ <- IO.uncancelable(poll => poll(poll(IO.unit)).flatMap(_ => IO.canceled))\r\n  _ <- IO(println(\"2\")) // This will print\r\n} yield ()\r\n```\r\nThe first poll will decrement the `masks` counter, the second won't because `id` isn't equal, but the continuations for both will increment `masks`, so we end up with an extra mask that will never be lost. I think it also breaks additional calls to `poll`",
        "createdAt" : "2020-07-10T20:08:46Z",
        "updatedAt" : "2020-07-11T18:35:51Z",
        "lastEditedBy" : "3b5d55eb-40d5-4d14-a8a4-3ed1601b5bff",
        "tags" : [
        ]
      },
      {
        "id" : "5b559179-9e03-4241-8240-812c84397d87",
        "parentId" : "4bb6f8c2-765d-4260-bb42-a0b2528784bb",
        "authorId" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "body" : "Good call! I'm almost positive you're correct",
        "createdAt" : "2020-07-10T20:31:39Z",
        "updatedAt" : "2020-07-11T18:35:51Z",
        "lastEditedBy" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "tags" : [
        ]
      }
    ],
    "commit" : "11095f3ade81d210f681ceeeb6c55e2c3c66a768",
    "line" : 1009,
    "diffHunk" : "@@ -1,1 +1007,1011 @@      import self._\n\n      pushMask()\n      if (success)\n        succeeded(result, depth + 1)"
  }
]
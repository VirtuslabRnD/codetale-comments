[
  {
    "id" : "407f1853-e6c3-4e81-a68f-d4283163af73",
    "prId" : 889,
    "prUrl" : "https://github.com/zio/zio/pull/889#pullrequestreview-241685915",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "53f897e2-0386-4238-b8e1-342416a86cd6",
        "parentId" : null,
        "authorId" : "4ace600a-1453-4cce-81f8-efdc7c98ad7a",
        "body" : "Nice !",
        "createdAt" : "2019-05-24T11:17:56Z",
        "updatedAt" : "2019-05-24T11:17:56Z",
        "lastEditedBy" : "4ace600a-1453-4cce-81f8-efdc7c98ad7a",
        "tags" : [
        ]
      },
      {
        "id" : "bd5ca312-2b66-415b-afa1-cd612e41f7bb",
        "parentId" : "53f897e2-0386-4238-b8e1-342416a86cd6",
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "😄 \r\n\r\nIf TRef is created inside the transaction, then it will not exist until transaction committed, so we don't need to add suspended transaction to `todo` list of new TRef. Now the `diffJournal` method just ignores all the \"new\" TRefs created in that transaction so process will terminate even without stable identifiers.\r\n\r\nAlso I deleted all TRef identities, since we can just use the `TRef` itself as the identity in the hash map. It cleaned up code and improved performance. 💃 ",
        "createdAt" : "2019-05-24T11:20:24Z",
        "updatedAt" : "2019-05-24T11:20:24Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      }
    ],
    "commit" : "5e6c860d919494a63fb2e4c730143b411405f5a4",
    "line" : 258,
    "diffHunk" : "@@ -1,1 +572,576 @@      protected[this] var newValue: A\n\n      val isNew: Boolean\n\n      private[this] var _isChanged = false"
  },
  {
    "id" : "aa15cb55-a2f8-407a-96c0-736ca2ca13ba",
    "prId" : 889,
    "prUrl" : "https://github.com/zio/zio/pull/889#pullrequestreview-241685987",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bb85d4e0-e67c-4583-8a02-ee7317f91cd5",
        "parentId" : null,
        "authorId" : "4ace600a-1453-4cce-81f8-efdc7c98ad7a",
        "body" : "(not related) but we can simplify it:\r\n```scala\r\ncase TRez.Succeed(a)  if pf.isDefinedAt(a) => TRez.Succeed(pf(a))\r\ncase _ => TRez.Retry\r\n```",
        "createdAt" : "2019-05-24T11:20:36Z",
        "updatedAt" : "2019-05-24T11:20:36Z",
        "lastEditedBy" : "4ace600a-1453-4cce-81f8-efdc7c98ad7a",
        "tags" : [
        ]
      }
    ],
    "commit" : "5e6c860d919494a63fb2e4c730143b411405f5a4",
    "line" : 19,
    "diffHunk" : "@@ -1,1 +110,114 @@        self.exec(journal) match {\n          case t @ TRez.Fail(_) => t\n          case TRez.Succeed(a)  => if (pf.isDefinedAt(a)) TRez.Succeed(pf(a)) else TRez.Retry\n          case TRez.Retry       => TRez.Retry\n        }"
  },
  {
    "id" : "89d392a1-a6a7-48c2-8a64-87bacfbe6be8",
    "prId" : 873,
    "prUrl" : "https://github.com/zio/zio/pull/873#pullrequestreview-239245178",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "31f89e76-770e-4051-941d-3dfd47f9f87c",
        "parentId" : null,
        "authorId" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "body" : "Is there no chance of different values for the same key?",
        "createdAt" : "2019-05-19T15:36:50Z",
        "updatedAt" : "2019-05-19T15:36:58Z",
        "lastEditedBy" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "tags" : [
        ]
      },
      {
        "id" : "6b40114b-b2f4-4098-b971-dc6714cce205",
        "parentId" : "31f89e76-770e-4051-941d-3dfd47f9f87c",
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "I _think_ that for this purpose, we just care whether or not we knew about the existence of the entry, because if we knew it existed, then regardless of its value, we added it to the `todo` list of the references, and therefore don't need to consider it in the diff. Does that make sense?",
        "createdAt" : "2019-05-19T15:53:15Z",
        "updatedAt" : "2019-05-19T15:53:15Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      },
      {
        "id" : "d54d7f00-19d8-460a-a170-7f035262ed88",
        "parentId" : "31f89e76-770e-4051-941d-3dfd47f9f87c",
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "^^^ @regiskuckaertz ",
        "createdAt" : "2019-05-19T15:53:26Z",
        "updatedAt" : "2019-05-19T15:53:26Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      },
      {
        "id" : "8ecb2e4e-d918-464f-b8c3-7530bcc2aae0",
        "parentId" : "31f89e76-770e-4051-941d-3dfd47f9f87c",
        "authorId" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "body" : "ah yeah, I get it 👍 ",
        "createdAt" : "2019-05-19T16:31:41Z",
        "updatedAt" : "2019-05-19T16:31:42Z",
        "lastEditedBy" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "tags" : [
        ]
      }
    ],
    "commit" : "23b2eaf5fc45a828a94529fc69e64cc13bf39e87",
    "line" : 268,
    "diffHunk" : "@@ -1,1 +459,463 @@\n      newJournal.forEach { (key, _) =>\n        if (oldJournal.containsKey(key)) {\n          diffJournal.remove(key); ()\n        }"
  },
  {
    "id" : "65343fe8-e3dd-402c-9749-a98445ec2588",
    "prId" : 863,
    "prUrl" : "https://github.com/zio/zio/pull/863#pullrequestreview-238826246",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "86fec1e8-c991-46d6-9c7e-c19fb797c49f",
        "parentId" : null,
        "authorId" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "body" : "Everything is super clean, but I don't understand this line. Isn't it redundant with the line above?",
        "createdAt" : "2019-05-17T08:47:32Z",
        "updatedAt" : "2019-05-17T08:47:32Z",
        "lastEditedBy" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "tags" : [
        ]
      },
      {
        "id" : "ab1ec3c3-14b2-424b-bf72-d3ff9043d84e",
        "parentId" : "86fec1e8-c991-46d6-9c7e-c19fb797c49f",
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "In between the time when the STM was executed and the \"todo\" was added, it may happen that the variables underlying the transaction have changed (by some _other_ transaction), and the \"todo\" lists cleared by that transaction. In this case, the suspended transaction would never be retried. This line detects this case, and re-runs the transaction again if necessary.\r\n\r\nThis way of structuring the code allows dramatic minimization of the commit lock, albeit at the cost of trickier reasoning about correctness.",
        "createdAt" : "2019-05-17T09:31:54Z",
        "updatedAt" : "2019-05-17T09:31:54Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      }
    ],
    "commit" : "c9a2804ee74fac01acdce17736aba0d9ccc072f1",
    "line" : 167,
    "diffHunk" : "@@ -1,1 +440,444 @@        addTodo(txnId, journal, () => tryCommitAsync(null, platform, stm, txnId, done)(k))\n\n        if (isInvalid(journal)) tryCommit(platform, stm) match {\n          case TryCommit.Done(io) => complete(io)\n          case _                  =>"
  },
  {
    "id" : "39ab89c9-86ac-46f1-b4d2-318453b8feb0",
    "prId" : 742,
    "prUrl" : "https://github.com/zio/zio/pull/742#pullrequestreview-226118621",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "532ab4a3-805f-4f3e-a66c-8724c85a91cb",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "Can you make this one delegate to the other one, to avoid duplicated code?",
        "createdAt" : "2019-04-12T14:18:39Z",
        "updatedAt" : "2019-04-13T11:29:22Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      },
      {
        "id" : "530aa646-55c2-41ef-b240-5c8c17012fec",
        "parentId" : "532ab4a3-805f-4f3e-a66c-8724c85a91cb",
        "authorId" : "7e3942e8-574e-4098-a8e1-89fffa0c877d",
        "body" : "Removed duplicate code by delegating to new function.",
        "createdAt" : "2019-04-12T14:38:35Z",
        "updatedAt" : "2019-04-13T11:29:22Z",
        "lastEditedBy" : "7e3942e8-574e-4098-a8e1-89fffa0c877d",
        "tags" : [
        ]
      }
    ],
    "commit" : "402ba627f2a70f5580c6a905063dfe72bd27e16a",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +227,231 @@   * Maps the success value of this effect to unit.\n   */\n  @deprecated(\"use unit\", \"1.0.0\")\n  final def void: STM[E, Unit] = unit\n"
  },
  {
    "id" : "5a5f13d9-5830-4959-8df4-caddac61aca3",
    "prId" : 721,
    "prUrl" : "https://github.com/zio/zio/pull/721#pullrequestreview-223667927",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7afd44b3-95a1-435d-bb18-487077222a59",
        "parentId" : null,
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "Hmm, personally I'm pretty happy with `zip` for this operation without a symbolic alias. Moreover, `<*>` is not what I'd expect for it :-)",
        "createdAt" : "2019-04-05T09:55:16Z",
        "updatedAt" : "2019-04-07T08:46:36Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      },
      {
        "id" : "ca684eee-5f10-469b-a50a-8a594e879d0b",
        "parentId" : "7afd44b3-95a1-435d-bb18-487077222a59",
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "- `<*` — zip, take left\r\n- `*>` — zip, take right\r\n- `<*>` — zip, take both\r\n\r\nThe `*` is product, but is too overloaded, `<` `>` are used for applicative operators, hence `<*>`. It's also worth noting the canonical applicative operator in Haskell is `ap` which has the alias `<*>`, but in Scala (without curried functions), it's actually zip, which by all rights should use the same operator.",
        "createdAt" : "2019-04-05T09:59:56Z",
        "updatedAt" : "2019-04-07T08:46:36Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      },
      {
        "id" : "86a23019-8f04-4a73-b8de-5bb8b519ffc2",
        "parentId" : "7afd44b3-95a1-435d-bb18-487077222a59",
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "Ok, I'm sold on the consistency with `*>` and `<*`. I think `ZIO` is missing that currently. Would also be nice to have `<&>` etc. for the `Par` versions.",
        "createdAt" : "2019-04-05T11:07:43Z",
        "updatedAt" : "2019-04-07T08:46:36Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      },
      {
        "id" : "41d91c95-35ab-424c-a732-7358ec7c340c",
        "parentId" : "7afd44b3-95a1-435d-bb18-487077222a59",
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "That would be great. I'll add tickets, both to add `<*>` as an alias for `zip`, and add `<&>` as an alias for `zipPar`, pervasively over all the data types that support them.",
        "createdAt" : "2019-04-05T12:10:43Z",
        "updatedAt" : "2019-04-07T08:46:36Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      },
      {
        "id" : "bafb226e-f450-4d16-8a2b-555932f333de",
        "parentId" : "7afd44b3-95a1-435d-bb18-487077222a59",
        "authorId" : "83d27ce0-1568-4f50-ba44-fb22504231d0",
        "body" : "`>*< :: f a -> f b -> f (a, b)`\r\nhttps://hackage.haskell.org/package/invertible-0.2.0.5/docs/Control-Invertible-Monoidal.html#v:-62--42--60-",
        "createdAt" : "2019-04-08T06:56:43Z",
        "updatedAt" : "2019-04-08T06:56:44Z",
        "lastEditedBy" : "83d27ce0-1568-4f50-ba44-fb22504231d0",
        "tags" : [
        ]
      }
    ],
    "commit" : "5bf0df204c01420fbb22665b9e8645f15bc14152",
    "line" : 59,
    "diffHunk" : "@@ -1,1 +57,61 @@   * Sequentially zips this value with the specified one.\n   */\n  final def <*>[E1 >: E, B](that: => STM[E1, B]): STM[E1, (A, B)] =\n    self zip that\n"
  },
  {
    "id" : "73db0d04-aa97-489f-988d-e1ff674c4940",
    "prId" : 721,
    "prUrl" : "https://github.com/zio/zio/pull/721#pullrequestreview-223239921",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3a408721-960a-42ee-bf0d-060dd106ebaf",
        "parentId" : null,
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "What would it take to chop this up? Can transactions lock on all participating `TRef`s instead?",
        "createdAt" : "2019-04-05T11:09:25Z",
        "updatedAt" : "2019-04-07T08:46:36Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      },
      {
        "id" : "06e3c943-389a-46ad-a5a1-110fbd4408b1",
        "parentId" : "3a408721-960a-42ee-bf0d-060dd106ebaf",
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "It's certainly possible. First I want to squeeze down the overhead in this implementation and benchmark the solution. The amount of work being done in the lock is extremely minimal (a check followed by commit), so when optimized, it's possible it will achieve higher throughput than a more complicated, fine-grained strategy, at least for some number of cores `n` (obviously as `n` increases, the overhead becomes less important; figuring out if the cutoff is `4` or `40` seems important).",
        "createdAt" : "2019-04-05T12:15:41Z",
        "updatedAt" : "2019-04-07T08:46:36Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      }
    ],
    "commit" : "5bf0df204c01420fbb22665b9e8645f15bc14152",
    "line" : 334,
    "diffHunk" : "@@ -1,1 +332,336 @@    private[this] val txnCounter: AtomicLong = new AtomicLong()\n\n    final val globalLock = new java.util.concurrent.Semaphore(1)\n\n    sealed trait TRez[+A, +B] extends Serializable with Product"
  },
  {
    "id" : "d990d0e4-463d-40c2-aac9-42c190882a4f",
    "prId" : 721,
    "prUrl" : "https://github.com/zio/zio/pull/721#pullrequestreview-223538477",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5bd324a1-a975-4fd1-b2e1-d7ef42327497",
        "parentId" : null,
        "authorId" : "d4a4aca7-8e2d-4ce4-90f5-8ab65955767f",
        "body" : "Since most of the time ppl will use `STM` using this idiom (`STM.atomically { … } `) maybe make `STM.apply` an alias?",
        "createdAt" : "2019-04-06T08:42:08Z",
        "updatedAt" : "2019-04-07T08:46:36Z",
        "lastEditedBy" : "d4a4aca7-8e2d-4ce4-90f5-8ab65955767f",
        "tags" : [
        ]
      },
      {
        "id" : "6d20f525-dadd-4364-8478-de0eee6f81e9",
        "parentId" : "5bd324a1-a975-4fd1-b2e1-d7ef42327497",
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "There is already the much sorter `.commit` method on STM. Also, to be consistent with other effect types in ZIO, `apply` would be reserved for `succeed` or `succeedLazy`.",
        "createdAt" : "2019-04-06T11:43:36Z",
        "updatedAt" : "2019-04-07T08:46:36Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      }
    ],
    "commit" : "5bf0df204c01420fbb22665b9e8645f15bc14152",
    "line" : 33,
    "diffHunk" : "@@ -1,1 +31,35 @@ * def transfer(receiver: TRef[Int],\n *              sender: TRef[Int], much: Int): UIO[Int] =\n *   STM.atomically {\n *     for {\n *       balance <- sender.get"
  }
]
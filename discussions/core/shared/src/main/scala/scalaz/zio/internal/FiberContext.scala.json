[
  {
    "id" : "6f0804b2-bca0-42fe-8009-81dd4c33889d",
    "prId" : 849,
    "prUrl" : "https://github.com/zio/zio/pull/849#pullrequestreview-237239972",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "34f30525-d915-4481-81df-ba541c1691ac",
        "parentId" : null,
        "authorId" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "body" : "That may be a silly question but what is the cost of all these checks when everything is disabled? Perhaps it is worth adding a nanopass AST phase to the compiler that is the identity function in `FiberContext` and one that calls `addTrace` in `FiberTracing` or something like that.",
        "createdAt" : "2019-05-13T08:53:12Z",
        "updatedAt" : "2019-05-30T01:18:27Z",
        "lastEditedBy" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "tags" : [
        ]
      },
      {
        "id" : "94a6ae6c-0619-4e63-a295-d0aa3221e814",
        "parentId" : "34f30525-d915-4481-81df-ba541c1691ac",
        "authorId" : "fe8c0309-9574-4c2c-a95a-2f54e9bd5411",
        "body" : "It's written like that so that the JIT can compile it away completely when it sees that it will never be true because a `final` variable is false / was false for a long time. Benchmarks actually show an *increase* in performance with disabled tracing compared to master because I turned inlining back on in sbt. I think anything involving closures might likely be slower than a conditional.",
        "createdAt" : "2019-05-13T09:32:47Z",
        "updatedAt" : "2019-05-30T01:18:27Z",
        "lastEditedBy" : "fe8c0309-9574-4c2c-a95a-2f54e9bd5411",
        "tags" : [
        ]
      },
      {
        "id" : "6646ceca-936f-4f2d-9d48-42eac42fd1bb",
        "parentId" : "34f30525-d915-4481-81df-ba541c1691ac",
        "authorId" : "02674bd6-d0ac-4b09-b920-a5e05b0a5cad",
        "body" : "`if` should be lot faster than a stackframe creation. Also we checked and there is no noticeable perf impact when tracing is off.",
        "createdAt" : "2019-05-14T12:54:57Z",
        "updatedAt" : "2019-05-30T01:18:27Z",
        "lastEditedBy" : "02674bd6-d0ac-4b09-b920-a5e05b0a5cad",
        "tags" : [
        ]
      },
      {
        "id" : "d19aa173-8346-4ceb-bdcf-50f77f03f8ba",
        "parentId" : "34f30525-d915-4481-81df-ba541c1691ac",
        "authorId" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "body" : "Thanks both, that's very insightful üëç ",
        "createdAt" : "2019-05-14T13:23:38Z",
        "updatedAt" : "2019-05-30T01:18:27Z",
        "lastEditedBy" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "tags" : [
        ]
      }
    ],
    "commit" : "2c5bbbea1c9833689e7f728f96b420cad75711fc",
    "line" : 170,
    "diffHunk" : "@@ -1,1 +254,258 @@                      val io2 = nested.asInstanceOf[ZIO.Succeed[Any]]\n\n                      if (traceExec && inTracingRegion) addTrace(k)\n\n                      curZio = k(io2.value)"
  },
  {
    "id" : "023f3227-1ca1-4abb-97b6-22e1839d83e7",
    "prId" : 849,
    "prUrl" : "https://github.com/zio/zio/pull/849#pullrequestreview-243586976",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "341899a8-649a-4b5b-8941-407ba0c3f2be",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "I am ok with this for this PR, although I do think we should pull all of this out into a separate class, and eliminate conditionals inside FiberContext. e.g. a \"dummy tracer\" will perform or not perform based on config, and we feed it everything it needs from FiberContext. Goal is to get all this code out of FiberContext and into a form where it's easier to reason about.",
        "createdAt" : "2019-05-27T23:54:07Z",
        "updatedAt" : "2019-05-30T01:18:27Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      },
      {
        "id" : "36dd7c0d-5fee-46d1-9111-5afaaf180bc3",
        "parentId" : "341899a8-649a-4b5b-8941-407ba0c3f2be",
        "authorId" : "fe8c0309-9574-4c2c-a95a-2f54e9bd5411",
        "body" : ":+1:",
        "createdAt" : "2019-05-28T08:11:37Z",
        "updatedAt" : "2019-05-30T01:18:27Z",
        "lastEditedBy" : "fe8c0309-9574-4c2c-a95a-2f54e9bd5411",
        "tags" : [
        ]
      },
      {
        "id" : "17dbd237-97c9-4dc3-9e90-8ea93e1f66a6",
        "parentId" : "341899a8-649a-4b5b-8941-407ba0c3f2be",
        "authorId" : "fe8c0309-9574-4c2c-a95a-2f54e9bd5411",
        "body" : "Moved to https://github.com/scalaz/scalaz-zio/issues/915",
        "createdAt" : "2019-05-30T01:15:40Z",
        "updatedAt" : "2019-05-30T01:18:27Z",
        "lastEditedBy" : "fe8c0309-9574-4c2c-a95a-2f54e9bd5411",
        "tags" : [
        ]
      }
    ],
    "commit" : "2c5bbbea1c9833689e7f728f96b420cad75711fc",
    "line" : 53,
    "diffHunk" : "@@ -1,1 +79,83 @@    else null\n\n  private[this] val tracer = platform.tracing.tracer\n\n  @noinline"
  },
  {
    "id" : "20ddd280-2e7e-4adb-ae4f-8e1b0e4ec324",
    "prId" : 849,
    "prUrl" : "https://github.com/zio/zio/pull/849#pullrequestreview-243574087",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e87f32ec-e4a3-46f1-bb06-227310e4944d",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "This will be allocated on the heap in an `ObjectRef`.",
        "createdAt" : "2019-05-28T00:00:49Z",
        "updatedAt" : "2019-05-30T01:18:27Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      },
      {
        "id" : "82f53a19-bf61-4061-8600-fa06a4996dd8",
        "parentId" : "e87f32ec-e4a3-46f1-bb06-227310e4944d",
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "Which argues for pulling this logic out into the aforementioned utility class.",
        "createdAt" : "2019-05-28T00:01:32Z",
        "updatedAt" : "2019-05-30T01:18:27Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      },
      {
        "id" : "d6dcbc79-7a4a-4b05-a985-388b2e2f1f2c",
        "parentId" : "e87f32ec-e4a3-46f1-bb06-227310e4944d",
        "authorId" : "fe8c0309-9574-4c2c-a95a-2f54e9bd5411",
        "body" : "Are you sure? I'm assigning to a val before passing. Also null can't be allocated on the heap?",
        "createdAt" : "2019-05-28T08:15:55Z",
        "updatedAt" : "2019-05-30T01:18:27Z",
        "lastEditedBy" : "fe8c0309-9574-4c2c-a95a-2f54e9bd5411",
        "tags" : [
        ]
      },
      {
        "id" : "f3f363f9-51ae-4082-afca-faa460f573d2",
        "parentId" : "e87f32ec-e4a3-46f1-bb06-227310e4944d",
        "authorId" : "fe8c0309-9574-4c2c-a95a-2f54e9bd5411",
        "body" : "Ok, I see that\r\n",
        "createdAt" : "2019-05-29T23:03:55Z",
        "updatedAt" : "2019-05-30T01:18:27Z",
        "lastEditedBy" : "fe8c0309-9574-4c2c-a95a-2f54e9bd5411",
        "tags" : [
        ]
      },
      {
        "id" : "5f704c09-b974-416e-b7a4-1627c59b4bfd",
        "parentId" : "e87f32ec-e4a3-46f1-bb06-227310e4944d",
        "authorId" : "fe8c0309-9574-4c2c-a95a-2f54e9bd5411",
        "body" : "inlining forces that to disappear, but gives, consistently, just slightly lower performance:\r\n`@noinline` with ObjectRef:\r\n```\r\n[info] Result \"scalaz.zio.IOLeftBindBenchmark.scalazLeftBindBenchmark\":\r\n[info]   4930.188 ¬±(99.9%) 77.862 ops/s [Average]\r\n[info]   (min, avg, max) = (4817.133, 4930.188, 4987.029), stdev = 51.501\r\n[info]   CI (99.9%): [4852.325, 5008.050] (assumes normal distribution)\r\n```\r\n`@inline` without ObjectRef:\r\n```\r\n[info] Result \"scalaz.zio.IOLeftBindBenchmark.scalazLeftBindBenchmark\":\r\n[info]   4893.806 ¬±(99.9%) 74.707 ops/s [Average]\r\n[info]   (min, avg, max) = (4821.052, 4893.806, 4989.764), stdev = 49.414\r\n[info]   CI (99.9%): [4819.099, 4968.512] (assumes normal distribution)\r\n```\r\n'worker-wrapper' with `@noinline`  on part of fastPathTrace and inlined assignment without ObjectRef\r\n```\r\n[info] Result \"scalaz.zio.IOLeftBindBenchmark.scalazLeftBindBenchmark\":\r\n[info]   4887.192 ¬±(99.9%) 105.314 ops/s [Average]\r\n[info]   (min, avg, max) = (4777.507, 4887.192, 5003.847), stdev = 69.658\r\n[info]   CI (99.9%): [4781.878, 4992.505] (assumes normal distribution)\r\n```\r\n\r\nSeems like the gain from `@noinline` hot-spot is consistently higher here than the overhead of ObjectRef",
        "createdAt" : "2019-05-30T00:08:33Z",
        "updatedAt" : "2019-05-30T01:18:27Z",
        "lastEditedBy" : "fe8c0309-9574-4c2c-a95a-2f54e9bd5411",
        "tags" : [
        ]
      }
    ],
    "commit" : "2c5bbbea1c9833689e7f728f96b420cad75711fc",
    "line" : 141,
    "diffHunk" : "@@ -1,1 +206,210 @@    // Store the trace of the immediate future flatMap during evaluation\n    // of a 1-hop left bind, to show a stack trace closer to the point of failure\n    var fastPathFlatMapContinuationTrace: ZTraceElement = null\n\n    @noinline def fastPathTrace(k: Any => ZIO[Any, E, Any], effect: AnyRef): ZTraceElement ="
  },
  {
    "id" : "2d8d34d4-a769-4a90-8bb4-17423e1e0040",
    "prId" : 849,
    "prUrl" : "https://github.com/zio/zio/pull/849#pullrequestreview-243561756",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "69c3ace2-c495-47f7-bcd9-4e0f6023b278",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "All the testing for `inTracingRegion` can be accelerated (right now it goes through heap access every time).",
        "createdAt" : "2019-05-28T00:04:55Z",
        "updatedAt" : "2019-05-30T01:18:27Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      },
      {
        "id" : "580255ba-ea3c-4adb-aff5-bf8cd8d1c7fc",
        "parentId" : "69c3ace2-c495-47f7-bcd9-4e0f6023b278",
        "authorId" : "fe8c0309-9574-4c2c-a95a-2f54e9bd5411",
        "body" : "Will do. Although, I have to recheck, but I'm fairly sure it gets JIT'ed away on current benchmarks due to tracingStatus never changing, will need a benchmark that toggles tracing",
        "createdAt" : "2019-05-28T08:25:16Z",
        "updatedAt" : "2019-05-30T01:18:27Z",
        "lastEditedBy" : "fe8c0309-9574-4c2c-a95a-2f54e9bd5411",
        "tags" : [
        ]
      },
      {
        "id" : "b8d3a7c2-7390-47e4-8ee4-8b8d3c8e2b17",
        "parentId" : "69c3ace2-c495-47f7-bcd9-4e0f6023b278",
        "authorId" : "fe8c0309-9574-4c2c-a95a-2f54e9bd5411",
        "body" : "After testing: Putting the StackBool on stack hurts performance in the common case when tracing status is not changed. Using a `var currentStatus: Boolean` instead of the heap also hurts perf (4800 vs. 4900 ops). Seems like using class fields is more jit friendly in this case.",
        "createdAt" : "2019-05-29T22:50:39Z",
        "updatedAt" : "2019-05-30T01:18:27Z",
        "lastEditedBy" : "fe8c0309-9574-4c2c-a95a-2f54e9bd5411",
        "tags" : [
        ]
      },
      {
        "id" : "e5a3440c-be08-462a-99bc-96d069aaec12",
        "parentId" : "69c3ace2-c495-47f7-bcd9-4e0f6023b278",
        "authorId" : "fe8c0309-9574-4c2c-a95a-2f54e9bd5411",
        "body" : "Using a `var` means we have to create a `BooleanRef` to be able to change it in `bracket_` which hurts performance and JIT-ability... Adding more primops to toggle status might alleviate that, but I guess it's too much since we're probably getting the best performance for the commont case of non-changing tracing status currently anyway.",
        "createdAt" : "2019-05-29T23:18:17Z",
        "updatedAt" : "2019-05-30T01:18:27Z",
        "lastEditedBy" : "fe8c0309-9574-4c2c-a95a-2f54e9bd5411",
        "tags" : [
        ]
      }
    ],
    "commit" : "2c5bbbea1c9833689e7f728f96b420cad75711fc",
    "line" : 240,
    "diffHunk" : "@@ -1,1 +315,319 @@                  val effect = zio.effect\n\n                  if (traceEffects && inTracingRegion) addTrace(effect)\n\n                  curZio = nextInstr(effect())"
  },
  {
    "id" : "da58e2db-799f-420f-b355-629920f3ee71",
    "prId" : 740,
    "prUrl" : "https://github.com/zio/zio/pull/740#pullrequestreview-226398051",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "77eb6a0e-fa59-496e-b66a-812017836908",
        "parentId" : null,
        "authorId" : "95c01fb1-bb18-4024-89b0-5dc9e51e2912",
        "body" : "Why have `interruptStatus` at all when you can have\r\n```scala\r\nprivate[this] var interruptible = true\r\nprivate class InterruptExit(val wasInterruptible: Boolean) extends Function[Any, IO[E, Any]] {\r\n  final def apply(v: Any): IO[E, Any] = {\r\n    interruptible = wasInterruptible\r\n    ZIO.succeed(v)\r\n  }\r\n}\r\n```\r\nand `interruptStatus.peekOrElse(true)` becomes just `interruptible`?",
        "createdAt" : "2019-04-13T18:16:03Z",
        "updatedAt" : "2019-04-15T14:55:56Z",
        "lastEditedBy" : "95c01fb1-bb18-4024-89b0-5dc9e51e2912",
        "tags" : [
        ]
      },
      {
        "id" : "c3491539-33d8-4ea6-9364-fd454c1394d3",
        "parentId" : "77eb6a0e-fa59-496e-b66a-812017836908",
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "Performance reasons. Compare heap allocations: pushing/popping booleans from `interruptStack` will require no heap and is super fast; and pushing the single `object` that is `InterruptExit` onto the pre-allocated stack also involves no allocations. ",
        "createdAt" : "2019-04-13T22:26:41Z",
        "updatedAt" : "2019-04-15T14:55:56Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      },
      {
        "id" : "166a5816-bf6b-4d30-8cfe-2daaf1cffd53",
        "parentId" : "77eb6a0e-fa59-496e-b66a-812017836908",
        "authorId" : "95c01fb1-bb18-4024-89b0-5dc9e51e2912",
        "body" : "There is no need for allocations:\r\n```scala\r\nprivate object InterruptExit {\r\n  val WasInterruptible = new InterruptExit(true)\r\n  val WasNotInterruptible = new InterruptExit(false)\r\n  def apply(wasInterruptible: Boolean): InterruptExit = if (wasInterruptible) WasInterruptible else WasNotInteruptible\r\n}\r\n```",
        "createdAt" : "2019-04-14T10:45:57Z",
        "updatedAt" : "2019-04-15T14:55:56Z",
        "lastEditedBy" : "95c01fb1-bb18-4024-89b0-5dc9e51e2912",
        "tags" : [
        ]
      },
      {
        "id" : "49c5e219-3bfe-4ba0-a59f-a33e4dd70ba8",
        "parentId" : "77eb6a0e-fa59-496e-b66a-812017836908",
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "Do we always statically know what the state should be at the time we add an interrupt change to the stack? I'll look at that. The current approach does not know, it just pops off the last boolean on the stack. ",
        "createdAt" : "2019-04-14T11:47:46Z",
        "updatedAt" : "2019-04-15T14:55:56Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      },
      {
        "id" : "faf440fd-6219-42f3-9496-13367c868a6c",
        "parentId" : "77eb6a0e-fa59-496e-b66a-812017836908",
        "authorId" : "95c01fb1-bb18-4024-89b0-5dc9e51e2912",
        "body" : "Yes, we do. Pops happen in `InterruptExit.apply and in `unwindStack`. In both cases we have the `InterruptExit` instance.",
        "createdAt" : "2019-04-14T14:26:39Z",
        "updatedAt" : "2019-04-15T14:55:56Z",
        "lastEditedBy" : "95c01fb1-bb18-4024-89b0-5dc9e51e2912",
        "tags" : [
        ]
      }
    ],
    "commit" : "889bcdf8060876dbcf923fa3cae3d5675cf66cc9",
    "line" : 37,
    "diffHunk" : "@@ -1,1 +55,59 @@    }\n\n  private object InterruptExit extends Function[Any, IO[E, Any]] {\n    final def apply(v: Any): IO[E, Any] = {\n      val isInterruptible = interruptStatus.peekOrElse(true)"
  },
  {
    "id" : "613837e4-d4b4-4dab-b004-42b8bbdace11",
    "prId" : 740,
    "prUrl" : "https://github.com/zio/zio/pull/740#pullrequestreview-226381499",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ace28485-283e-4fb3-b89a-6cdce8903baf",
        "parentId" : null,
        "authorId" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "body" : "ha, such a great simplification ‚ù§Ô∏è ",
        "createdAt" : "2019-04-14T07:12:45Z",
        "updatedAt" : "2019-04-15T14:55:56Z",
        "lastEditedBy" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "tags" : [
        ]
      }
    ],
    "commit" : "889bcdf8060876dbcf923fa3cae3d5675cf66cc9",
    "line" : 63,
    "diffHunk" : "@@ -1,1 +73,77 @@   * interruptible / uninterruptible regions.\n   */\n  final def unwindStack(): Unit = {\n    var unwinding = true\n"
  },
  {
    "id" : "4fe10a03-20a3-439a-a2e8-f22a44678640",
    "prId" : 740,
    "prUrl" : "https://github.com/zio/zio/pull/740#pullrequestreview-226395579",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "820bd61f-056b-4546-ab44-68f1ed5c74a0",
        "parentId" : null,
        "authorId" : "95c01fb1-bb18-4024-89b0-5dc9e51e2912",
        "body" : "`return`?",
        "createdAt" : "2019-04-14T11:05:53Z",
        "updatedAt" : "2019-04-15T14:55:56Z",
        "lastEditedBy" : "95c01fb1-bb18-4024-89b0-5dc9e51e2912",
        "tags" : [
        ]
      },
      {
        "id" : "ac06d27e-51b4-4123-bfe2-5e6812000e45",
        "parentId" : "820bd61f-056b-4546-ab44-68f1ed5c74a0",
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "<https://tpolecat.github.io/2014/05/09/return.html>",
        "createdAt" : "2019-04-14T11:40:03Z",
        "updatedAt" : "2019-04-15T14:55:56Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      },
      {
        "id" : "0f2e47a6-1809-456e-b470-ed4198928dfc",
        "parentId" : "820bd61f-056b-4546-ab44-68f1ed5c74a0",
        "authorId" : "95c01fb1-bb18-4024-89b0-5dc9e51e2912",
        "body" : "Oh, come on, it is low-level code full of `null`s and `asInstanceOf`s.",
        "createdAt" : "2019-04-14T13:24:46Z",
        "updatedAt" : "2019-04-15T14:55:56Z",
        "lastEditedBy" : "95c01fb1-bb18-4024-89b0-5dc9e51e2912",
        "tags" : [
        ]
      },
      {
        "id" : "b4a2e37c-62fb-4ae9-86c9-9fdfe7532c9b",
        "parentId" : "820bd61f-056b-4546-ab44-68f1ed5c74a0",
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "True. Old habits die hard. üòÑ ",
        "createdAt" : "2019-04-14T13:25:41Z",
        "updatedAt" : "2019-04-15T14:55:56Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      },
      {
        "id" : "4961204c-b4e8-488d-aab1-f530461f0fc7",
        "parentId" : "820bd61f-056b-4546-ab44-68f1ed5c74a0",
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "Although do you know what `return` compiles to? try / catch? I know what the while loop compiles to.",
        "createdAt" : "2019-04-14T13:26:15Z",
        "updatedAt" : "2019-04-15T14:55:56Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      }
    ],
    "commit" : "889bcdf8060876dbcf923fa3cae3d5675cf66cc9",
    "line" : 87,
    "diffHunk" : "@@ -1,1 +84,88 @@          // Push error handler back onto the stack and halt iteration:\n          stack.push(fold.failure.asInstanceOf[Any => ZIO[Any, Any, Any]])\n          unwinding = false\n        case _ =>\n      }"
  },
  {
    "id" : "cca6d361-a549-4d98-9c21-aed77dae15b2",
    "prId" : 675,
    "prUrl" : "https://github.com/zio/zio/pull/675#pullrequestreview-218016564",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "645d6a38-efa9-4c7e-96fa-1cc3e0d68ed0",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "Oh wow, love this. So clean now.",
        "createdAt" : "2019-03-23T00:29:41Z",
        "updatedAt" : "2019-03-23T14:59:58Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      }
    ],
    "commit" : "4494bd105d155ef0137167f50c8c4d1b08b6943f",
    "line" : 61,
    "diffHunk" : "@@ -1,1 +413,417 @@    IO.effectTotal {\n      supervising -= 1\n      supervised = supervised drop 1\n    }\n"
  },
  {
    "id" : "81fe7ff8-cbaa-414f-9571-b93b7eb40ddd",
    "prId" : 665,
    "prUrl" : "https://github.com/zio/zio/pull/665#pullrequestreview-239247411",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a424fd92-d6a4-4193-a099-a97dc31841f9",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "`synchronized` is not supported in Scala.js, which we have to support.\r\n\r\nWe could push that requirement into `WeakHashMap` on `Platform`, which could return a synchronized weak hash map.",
        "createdAt" : "2019-05-18T20:50:22Z",
        "updatedAt" : "2019-05-22T20:33:36Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      },
      {
        "id" : "e9fe7267-19a2-4578-a72f-71fe581c8b5a",
        "parentId" : "a424fd92-d6a4-4193-a099-a97dc31841f9",
        "authorId" : "6a92f7d6-4dd1-411e-a84c-242d2ab76df6",
        "body" : "Changed docs for `scalaz.zio.internal.Platform#newWeakHashMap`, modified implementation in `scalaz.zio.internal.PlatformLive`",
        "createdAt" : "2019-05-19T17:38:16Z",
        "updatedAt" : "2019-05-22T20:33:36Z",
        "lastEditedBy" : "6a92f7d6-4dd1-411e-a84c-242d2ab76df6",
        "tags" : [
        ]
      }
    ],
    "commit" : "1de46fa03a686ae8f0cae79d2cfa549eb52bd6d0",
    "line" : 32,
    "diffHunk" : "@@ -1,1 +299,303 @@                  val fiberRef = new FiberRef[Any](io.initialValue)\n                  fiberRefLocals.put(fiberRef, io.initialValue)\n\n                  curIo = nextInstr(fiberRef)\n"
  },
  {
    "id" : "f007a766-c800-4e86-b0a0-f61617377ea2",
    "prId" : 665,
    "prUrl" : "https://github.com/zio/zio/pull/665#pullrequestreview-239207818",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "36abb121-def2-4339-bad6-6acdc9169324",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "Same for above.",
        "createdAt" : "2019-05-18T20:50:30Z",
        "updatedAt" : "2019-05-22T20:33:36Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      }
    ],
    "commit" : "1de46fa03a686ae8f0cae79d2cfa549eb52bd6d0",
    "line" : 41,
    "diffHunk" : "@@ -1,1 +308,312 @@                  val (result, newValue) = io.f(oldValue.getOrElse(io.fiberRef.initial))\n                  fiberRefLocals.put(io.fiberRef, newValue)\n\n                  curIo = nextInstr(result)\n"
  },
  {
    "id" : "52666cf0-d398-4c98-9f9a-64ba6540628b",
    "prId" : 665,
    "prUrl" : "https://github.com/zio/zio/pull/665#pullrequestreview-239253843",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7790421f-a239-4930-aafa-2c1dbece8017",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "Looks good. üëç ",
        "createdAt" : "2019-05-19T20:28:10Z",
        "updatedAt" : "2019-05-22T20:33:36Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      }
    ],
    "commit" : "1de46fa03a686ae8f0cae79d2cfa549eb52bd6d0",
    "line" : 53,
    "diffHunk" : "@@ -1,1 +365,369 @@  final def fork[E, A](io: IO[E, A]): FiberContext[E, A] = {\n    val childFiberRefLocals: FiberRefLocals = platform.newWeakHashMap()\n    childFiberRefLocals.putAll(fiberRefLocals)\n    val context = new FiberContext[E, A](platform, environment.peek(), childFiberRefLocals)\n"
  },
  {
    "id" : "68889970-743e-4426-8133-c4e90c129f9a",
    "prId" : 616,
    "prUrl" : "https://github.com/zio/zio/pull/616#pullrequestreview-213232371",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c72be125-29c6-4d3f-af0a-a7394f5f5eb5",
        "parentId" : null,
        "authorId" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "body" : "Should we make sure this IO runs on the async thread pool?",
        "createdAt" : "2019-03-11T07:43:31Z",
        "updatedAt" : "2019-03-11T07:44:08Z",
        "lastEditedBy" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "tags" : [
        ]
      },
      {
        "id" : "f5c1f03d-f49e-43cb-9f0a-0dd2115ab88f",
        "parentId" : "c72be125-29c6-4d3f-af0a-a7394f5f5eb5",
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "That will automatically happen if it's supposed to. The `lock` uses ensuring to bump back to the previous thread pool after it's done. So \"on the way out\", when cleaning up after termination, if appropriate the fiber will jump to previous thread pools.",
        "createdAt" : "2019-03-12T07:47:24Z",
        "updatedAt" : "2019-03-12T07:47:24Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      }
    ],
    "commit" : "01287571629d6ae3e71accee4f88f1421065570e",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +293,297 @@        case _: InterruptedException =>\n          Thread.interrupted\n          curIo = terminate(IO.interrupt)\n\n        // Catastrophic error handler. Any error thrown inside the interpreter is"
  },
  {
    "id" : "dbf2fda1-1c46-4568-8b73-160f2c98f1c6",
    "prId" : 452,
    "prUrl" : "https://github.com/zio/zio/pull/452#pullrequestreview-184995917",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "09110e15-cd59-4709-ad81-1e146736b45f",
        "parentId" : null,
        "authorId" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "body" : "üëç ‚ú® ",
        "createdAt" : "2018-12-14T07:46:41Z",
        "updatedAt" : "2018-12-16T00:00:49Z",
        "lastEditedBy" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "tags" : [
        ]
      }
    ],
    "commit" : "3eb71c8c2a3962595c473e2f4e5c4bae6f60c82e",
    "line" : 222,
    "diffHunk" : "@@ -1,1 +500,504 @@        else null\n\n      case Done(v) => v\n    }\n  }"
  },
  {
    "id" : "13fafc25-f17d-4f43-9675-6c41421d6a88",
    "prId" : 452,
    "prUrl" : "https://github.com/zio/zio/pull/452#pullrequestreview-185357547",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2cb47983-b24f-4ddb-9407-6edcbb7eb6d6",
        "parentId" : null,
        "authorId" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "body" : "What about:\r\n```scala\r\nobject Async {\r\n  def now[A](value: A): Async[Nothing, A] = Now(IO.now(a))\r\n  def fail[E](error: E): Async[E, Nothing] = Now(IO.fail(e))\r\n}\r\n```",
        "createdAt" : "2018-12-15T08:32:33Z",
        "updatedAt" : "2018-12-16T00:00:49Z",
        "lastEditedBy" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "tags" : [
        ]
      },
      {
        "id" : "62c98b56-4457-4346-b010-826bb25e1121",
        "parentId" : "2cb47983-b24f-4ddb-9407-6edcbb7eb6d6",
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "Then we'd need to add `success` / `interrupt`, `fail0`, etc., and it would start to look like `IO`.",
        "createdAt" : "2018-12-15T14:36:25Z",
        "updatedAt" : "2018-12-16T00:00:49Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      },
      {
        "id" : "8734a919-d554-4038-8dd4-278976a82077",
        "parentId" : "2cb47983-b24f-4ddb-9407-6edcbb7eb6d6",
        "authorId" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "body" : "Yeah, fair enough üëç ",
        "createdAt" : "2018-12-15T15:05:16Z",
        "updatedAt" : "2018-12-16T00:00:49Z",
        "lastEditedBy" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "tags" : [
        ]
      }
    ],
    "commit" : "3eb71c8c2a3962595c473e2f4e5c4bae6f60c82e",
    "line" : 204,
    "diffHunk" : "@@ -1,1 +486,490 @@    register0(k) match {\n      case null => Async.later\n      case x    => Async.now(IO.now(x))\n    }\n"
  }
]
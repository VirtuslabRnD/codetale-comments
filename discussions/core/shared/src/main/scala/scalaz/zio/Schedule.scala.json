[
  {
    "id" : "6cc11a36-914f-4fe6-bcb7-ce234da038af",
    "prId" : 282,
    "prUrl" : "https://github.com/zio/zio/pull/282#pullrequestreview-161739328",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "94b0d8d3-7d8f-4770-972c-55b5fc7d06c6",
        "parentId" : null,
        "authorId" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "body" : "How about `outputWhile`? It seems `<verb><conjunction>` is more idiomatic. In `IO`: `retryOrElse`, `seqWith`, `sandboxWith`, etc. Also reminds me of `takeWhile`, `takeUntil` et al. the vernacular of traversable data structures.",
        "createdAt" : "2018-10-04T08:49:42Z",
        "updatedAt" : "2018-10-04T13:03:56Z",
        "lastEditedBy" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "tags" : [
        ]
      },
      {
        "id" : "dea8a93d-c565-40a8-88a4-d345eb65257e",
        "parentId" : "94b0d8d3-7d8f-4770-972c-55b5fc7d06c6",
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "Here's the meaning of these things:\r\n\r\n * `whileInput` â€” it decides to continue for as long as the input matches the specified condition\r\n * `untilInput` â€” it decides to continue until the input matches the specified condition\r\n * `whileOutput` â€” it decides to continue for as long as the output matches the specified condition\r\n * `untilOutput` â€” it decides to continue until the output matches the specified condition\r\n\r\nIt's not so much that it will \"output\" while the condition is satisfied, but that the schedule will continue for as long the output of the schedule satisfies the condition.\r\n\r\nThis suggests terminology like `continueWhileOutput` or something (although that's too long). I'm not sure.",
        "createdAt" : "2018-10-04T13:03:00Z",
        "updatedAt" : "2018-10-04T13:03:56Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      },
      {
        "id" : "403d0ac6-b815-48a3-a2e9-2bded7237a8b",
        "parentId" : "94b0d8d3-7d8f-4770-972c-55b5fc7d06c6",
        "authorId" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "body" : "ymmv, but I'm ok with some methods having long names if they are specific to a fairly niche use case. Examples like `traverseWithKey`, `mapKeysMonotonic` for maps in haskell come to mind. In this case though, I think you're right that it's too long, as these look like valuable combinators a user would typically embed in larger expressions.",
        "createdAt" : "2018-10-04T18:01:44Z",
        "updatedAt" : "2018-10-04T18:01:45Z",
        "lastEditedBy" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "tags" : [
        ]
      }
    ],
    "commit" : "e1f60df2ee29b4ed761dccd0e98639a15143323b",
    "line" : 64,
    "diffHunk" : "@@ -1,1 +133,137 @@   * is satisfied on the output value of the schedule.\n   */\n  final def whileOutput(f: B => Boolean): Schedule[A, B] =\n    check[A, B]((_, b) => IO.now(f(b)))\n"
  },
  {
    "id" : "aba5f355-564c-45e0-a1c7-33c44f726040",
    "prId" : 282,
    "prUrl" : "https://github.com/zio/zio/pull/282#pullrequestreview-161597829",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "defef8da-193f-411a-afdc-0d3334690875",
        "parentId" : null,
        "authorId" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "body" : "ðŸ˜ ",
        "createdAt" : "2018-10-04T08:52:03Z",
        "updatedAt" : "2018-10-04T13:03:56Z",
        "lastEditedBy" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "tags" : [
        ]
      },
      {
        "id" : "676d7639-6d0b-4800-b54a-0b11f1c52825",
        "parentId" : "defef8da-193f-411a-afdc-0d3334690875",
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "Lots more arrow goodness. ðŸ˜„ ",
        "createdAt" : "2018-10-04T13:03:20Z",
        "updatedAt" : "2018-10-04T13:03:56Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      }
    ],
    "commit" : "e1f60df2ee29b4ed761dccd0e98639a15143323b",
    "line" : 144,
    "diffHunk" : "@@ -1,1 +453,457 @@   * Split the input\n   */\n  final def ***[C, D](that: Schedule[C, D]): Schedule[(A, C), (B, D)] =\n    new Schedule[(A, C), (B, D)] {\n      type State = (self.State, that.State)"
  },
  {
    "id" : "d730f5a6-73d4-4434-85e2-4c81ecfb9cf8",
    "prId" : 198,
    "prUrl" : "https://github.com/zio/zio/pull/198#pullrequestreview-148621669",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "623b2171-068e-4c40-b4cc-de07a835c1de",
        "parentId" : null,
        "authorId" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "body" : "ðŸŽ‰ ",
        "createdAt" : "2018-08-22T18:50:46Z",
        "updatedAt" : "2018-08-22T19:11:00Z",
        "lastEditedBy" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "tags" : [
        ]
      }
    ],
    "commit" : "0f768eacd739cfae05eef5b8ff80d72c984977c9",
    "line" : 431,
    "diffHunk" : "@@ -1,1 +429,433 @@   */\n  final val never: Schedule[Any, Nothing] =\n    Schedule[Nothing, Any, Nothing](IO.never, (_, _) => IO.never)\n\n  /**"
  }
]
[
  {
    "id" : "4ad579da-b185-46f5-b7ac-d41faa694748",
    "prId" : 721,
    "prUrl" : "https://github.com/zio/zio/pull/721#pullrequestreview-223595806",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ab615367-77f2-4807-9cd8-c855eb4c447b",
        "parentId" : null,
        "authorId" : "64a07906-0c26-4393-9002-344c9bbf55d9",
        "body" : "Just curious - why not Some(ab)? Seems like a redundant allocation. Also why not more generic return type?",
        "createdAt" : "2019-04-06T16:17:43Z",
        "updatedAt" : "2019-04-07T08:46:36Z",
        "lastEditedBy" : "64a07906-0c26-4393-9002-344c9bbf55d9",
        "tags" : [
        ]
      },
      {
        "id" : "cc5fc640-dfd6-4877-b542-79e98879fcc7",
        "parentId" : "ab615367-77f2-4807-9cd8-c855eb4c447b",
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "It's the way pattern matching works, unfortunately.",
        "createdAt" : "2019-04-07T11:36:51Z",
        "updatedAt" : "2019-04-07T11:36:52Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      },
      {
        "id" : "56f73583-64c7-458e-ae61-9f97cac3b969",
        "parentId" : "ab615367-77f2-4807-9cd8-c855eb4c447b",
        "authorId" : "64a07906-0c26-4393-9002-344c9bbf55d9",
        "body" : "WDYM? I meant there is no need to construct a new tuple if you already have one.\r\n\r\n```scala\r\n@ object <*> {\r\n    def unapply[A, B](x: (A, B)): Option[(A, B)] = Some(x)\r\n  }\r\ndefined object <*>\r\n\r\n@ (1,2) match {\r\n    case x <*> y => x + \", \" + y\r\n    case (x, y) => s\"!$x !$y\"\r\n    case z => s\"@$z@\"\r\n  }\r\nres1: String = \"1, 2\"\r\n```",
        "createdAt" : "2019-04-07T13:46:39Z",
        "updatedAt" : "2019-04-07T13:48:00Z",
        "lastEditedBy" : "64a07906-0c26-4393-9002-344c9bbf55d9",
        "tags" : [
        ]
      },
      {
        "id" : "4b1c337c-c4af-4d51-a7c2-b65f9a721b2e",
        "parentId" : "ab615367-77f2-4807-9cd8-c855eb4c447b",
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "@tkroman Sorry, thought you meant something else! You're right of course. ðŸ˜„ ",
        "createdAt" : "2019-04-07T18:41:05Z",
        "updatedAt" : "2019-04-07T18:41:05Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      }
    ],
    "commit" : "5bf0df204c01420fbb22665b9e8645f15bc14152",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +42,46 @@  object <*> {\n    def unapply[A, B](ab: (A, B)): Some[(A, B)] =\n      Some((ab._1, ab._2))\n  }\n}"
  },
  {
    "id" : "4497f4b7-3461-46d6-8553-f3a46352b13a",
    "prId" : 593,
    "prUrl" : "https://github.com/zio/zio/pull/593#pullrequestreview-211201387",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1fa2801c-54f5-4cac-9d72-a991e23766c1",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "Can you add an object for `TaskR` in the `ZIO.scala` file, following the convention of the `Task` object? This let's people access `TaskR.succeed(.)`, etc.",
        "createdAt" : "2019-03-05T06:59:03Z",
        "updatedAt" : "2019-03-08T13:53:04Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      },
      {
        "id" : "3b022112-4b07-46ba-9597-275657970876",
        "parentId" : "1fa2801c-54f5-4cac-9d72-a991e23766c1",
        "authorId" : "af51f515-618e-4f28-8285-000375fe3283",
        "body" : "@jdegoes Something like this?\r\n\r\n```scala\r\nobject TaskR extends ZIO_E_Throwable {\r\n  type UpperE = Throwable\r\n\r\n  def apply[R, A](a: => A): TaskR[R, A] = effect(a)\r\n}\r\n```\r\n\r\nOr this?\r\n\r\n```scala\r\nobject TaskR extends ZIO_E_Throwable {\r\n  type UpperE = Throwable\r\n\r\n  def apply[A](a: => A): Task[A] = effect(a)\r\n}\r\n```\r\n\r\nI'm confused by the `IO` object that returns a `Task`.",
        "createdAt" : "2019-03-05T09:59:34Z",
        "updatedAt" : "2019-03-08T13:53:04Z",
        "lastEditedBy" : "af51f515-618e-4f28-8285-000375fe3283",
        "tags" : [
        ]
      },
      {
        "id" : "e24b6ab1-bc57-4d71-aaed-d1dff030ed5b",
        "parentId" : "1fa2801c-54f5-4cac-9d72-a991e23766c1",
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "An `IO` object can return a task because a task can always be interpreted as an `IO` for some choice of `E` and `A`. The reverse is not true.\r\n\r\nSo the latter one is correct because a `Task` can always be interpreted as a `Task`. The former one is also correct but contains a useless `R` parameter that will only cause type inference problems (Scala can't infer it).",
        "createdAt" : "2019-03-06T12:26:37Z",
        "updatedAt" : "2019-03-08T13:53:04Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      }
    ],
    "commit" : "6c3adaa2bfd47747c5a40c76e6b0bb915ff33fcc",
    "line" : 9,
    "diffHunk" : "@@ -1,1 +25,29 @@  type IO[+E, +A]    = ZIO[Any, E, A]\n  type Task[+A]      = ZIO[Any, Throwable, A]\n  type TaskR[-R, +A] = ZIO[R, Throwable, A]\n  type UIO[+A]       = ZIO[Any, Nothing, A]\n"
  }
]
[
  {
    "id" : "99cceb59-3124-4bcd-be9a-8d64e7961b61",
    "prId" : 602,
    "prUrl" : "https://github.com/zio/zio/pull/602#pullrequestreview-210835455",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "41c66fb6-cea7-4f8e-82ec-e251c1c7628f",
        "parentId" : null,
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "I had to annotate these lines explictly, otherwise this is inferred as `ZIO[Any, E2, Option[A]]` and line 584 results in an error that `Any` is required but `R2` is found.\r\n\r\nI haven't investigated why the narrowing fails, but this might be another candidate for inference improvements before 1.0.",
        "createdAt" : "2019-03-05T18:15:14Z",
        "updatedAt" : "2019-03-05T18:15:14Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      }
    ],
    "commit" : "456714bd3dbb96810131d7e081fc072ccb80bd49",
    "line" : 18,
    "diffHunk" : "@@ -1,1 +565,569 @@            s: S\n          ): ZIO[R2, E2, S] = {\n            val takeLeft: ZIO[R2, E2, Option[A]]  = if (leftDone) IO.succeed(None) else Take.option(q1.take)\n            val takeRight: ZIO[R2, E2, Option[B]] = if (rightDone) IO.succeed(None) else Take.option(q2.take)\n"
  },
  {
    "id" : "8ec948a3-4cbd-43b3-babc-3a39d7f4b8b4",
    "prId" : 443,
    "prUrl" : "https://github.com/zio/zio/pull/443#pullrequestreview-182956852",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "be8d1926-b649-42b7-8360-64801b8820be",
        "parentId" : null,
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "Elegant!",
        "createdAt" : "2018-12-08T21:00:12Z",
        "updatedAt" : "2018-12-11T00:28:45Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      }
    ],
    "commit" : "e07e21d205c44a56c7f23e504486d71b44f32370",
    "line" : 18,
    "diffHunk" : "@@ -1,1 +654,658 @@   */\n  final def fromQueue[A](queue: Queue[A]): Stream[Nothing, A] =\n    unfoldM(())(_ => queue.take.map(a => Some((a, ()))) <> IO.now(None))\n\n  /**"
  },
  {
    "id" : "8a45e4e7-808a-424c-8dd2-8058569c271f",
    "prId" : 374,
    "prUrl" : "https://github.com/zio/zio/pull/374#pullrequestreview-177410047",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2dfe407b-d9a1-407e-beb2-f62a2ada8c0c",
        "parentId" : null,
        "authorId" : "c83bbe86-1484-4d60-a513-1b56afb6c46d",
        "body" : "It seems that the `unfold` stop after the first value. The `loop` is not called recursively.\r\n\r\nI tried the following code which seems to work better:\r\n\r\n    final def unfold[S, A](s: S)(f0: S => Option[(A, S)]): Stream[Nothing, A] =\r\n      new StreamPure[A] {\r\n        override def fold[E, A1 >: A, S2](s2: S2)(f: (S2, A1) => IO[E, Step[S2]]): IO[E, Step[S2]] = {\r\n          def loop(s: S, s2: S2): IO[E, Step[S2]] =\r\n            f0(s) match {\r\n              case None         => IO.now(Step.Stop(s2))\r\n              case Some((a, s)) => f(s2, a).flatMap {\r\n                case Step.Cont(s2) => loop(s, s2)\r\n                case Step.Stop(s2) => IO.now(Step.stop(s2))\r\n              }\r\n            }\r\n  \r\n          loop(s, s2)\r\n        }\r\n  \r\n        override def foldPure[A1 >: A, S2](s2: S2)(f: (S2, A1) => Step[S2]): Step[S2] = {\r\n          def loop(s: S, s2: S2): Step[S2] =\r\n            f0(s) match {\r\n              case None         => Step.Stop(s2)\r\n              case Some((a, s)) => f(s2, a) match {\r\n                case Step.Cont(s2) => loop(s, s2)\r\n                case Step.Stop(s2) => Step.stop(s2)\r\n              }\r\n            }\r\n  \r\n          loop(s, s2)\r\n        }\r\n      }\r\n\r\nThe problem is the same with `unfoldM`.",
        "createdAt" : "2018-11-21T09:49:34Z",
        "updatedAt" : "2018-12-05T19:31:12Z",
        "lastEditedBy" : "c83bbe86-1484-4d60-a513-1b56afb6c46d",
        "tags" : [
        ]
      },
      {
        "id" : "a4996d22-cf42-45d7-bec0-4803aadad9f8",
        "parentId" : "2dfe407b-d9a1-407e-beb2-f62a2ada8c0c",
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "🤦🏼‍♂️",
        "createdAt" : "2018-11-21T20:00:52Z",
        "updatedAt" : "2018-12-05T19:31:12Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      }
    ],
    "commit" : "b14e4b5ddb73c03a775d9592f4d94bf482679041",
    "line" : 712,
    "diffHunk" : "@@ -1,1 +710,714 @@        loop(s, s2)._2\n      }\n    }\n\n  /**"
  },
  {
    "id" : "be2e7c59-1bbd-4948-b8b8-99fb2b733bc4",
    "prId" : 374,
    "prUrl" : "https://github.com/zio/zio/pull/374#pullrequestreview-178057149",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2990eaf8-8d68-4dcb-ac4f-7135075d112a",
        "parentId" : null,
        "authorId" : "c83bbe86-1484-4d60-a513-1b56afb6c46d",
        "body" : "Why using `.forever` here ? It needlessly floods the queue with `Left(Take.End)` items when the right stream is not terminated. ",
        "createdAt" : "2018-11-21T22:31:08Z",
        "updatedAt" : "2018-12-05T19:31:12Z",
        "lastEditedBy" : "c83bbe86-1484-4d60-a513-1b56afb6c46d",
        "tags" : [
        ]
      },
      {
        "id" : "b3dcbb04-13f6-4f6e-800e-81ef2128a585",
        "parentId" : "2990eaf8-8d68-4dcb-ac4f-7135075d112a",
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "Previously, we didn't have a means to express Queue shutdown. We will change all these to do:\r\n\r\n`queue.offer(endToken) *> queue.shutdown`\r\n\r\nThat way, you get 1 chance to see the queue is ended. If you call queue methods after that, you'll be terminated.",
        "createdAt" : "2018-11-24T17:36:51Z",
        "updatedAt" : "2018-12-05T19:31:12Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      }
    ],
    "commit" : "b14e4b5ddb73c03a775d9592f4d94bf482679041",
    "line" : 238,
    "diffHunk" : "@@ -1,1 +236,240 @@          catchL = (e: E2) => queue.offer(Left(Take.Fail(e)))\n          catchR = (e: E2) => queue.offer(Right(Take.Fail(e)))\n          endL   = queue.offer(Left(Take.End)).forever\n          endR   = queue.offer(Right(Take.End)).forever\n          _      <- (self.foreach(putL) *> endL).catchAll(catchL).fork"
  },
  {
    "id" : "5c55c811-37c9-4aa0-8b56-5c4aa683024d",
    "prId" : 374,
    "prUrl" : "https://github.com/zio/zio/pull/374#pullrequestreview-178506852",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7371120b-56cb-4e59-96fd-8f76a0ef2fcc",
        "parentId" : null,
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "@jdegoes Could you review this implementation of transduce? I had to add the last `extract` attempt to get the test passing.",
        "createdAt" : "2018-11-26T21:17:15Z",
        "updatedAt" : "2018-12-05T19:31:12Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      },
      {
        "id" : "17cb6b1f-0fdd-4257-8d77-064bb4c2f68f",
        "parentId" : "7371120b-56cb-4e59-96fd-8f76a0ef2fcc",
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "Such a lovely combinator, by the way. Probably equivalent in power to a `Stream.scanM`, but much easier to use due to the Sink combinators.",
        "createdAt" : "2018-11-26T21:23:18Z",
        "updatedAt" : "2018-12-05T19:31:12Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      }
    ],
    "commit" : "b14e4b5ddb73c03a775d9592f4d94bf482679041",
    "line" : 448,
    "diffHunk" : "@@ -1,1 +446,450 @@   * of type `A` into elements of type `C`.\n   */\n  final def transduce[E1 >: E, A1 >: A, C](sink: Sink[E1, A1, A1, C]): Stream[E1, C] =\n    new Stream[E1, C] {\n      override def foldLazy[E2 >: E1, C1 >: C, S2]("
  }
]
[
  {
    "id" : "09e8e8f4-530b-4475-b396-bf3b3cdec646",
    "prId" : 4381,
    "prUrl" : "https://github.com/zio/zio/pull/4381#pullrequestreview-524890649",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "67dc5ef1-873a-4113-b8df-9f646df6d66d",
        "parentId" : null,
        "authorId" : "6080cd8f-e671-4d49-a54c-b6159456ac0e",
        "body" : "Should we have the one for `foreach_` as well? ",
        "createdAt" : "2020-11-06T06:32:36Z",
        "updatedAt" : "2020-11-06T06:33:02Z",
        "lastEditedBy" : "6080cd8f-e671-4d49-a54c-b6159456ac0e",
        "tags" : [
        ]
      },
      {
        "id" : "9f44f90e-a98b-4168-85fe-3b76c4421922",
        "parentId" : "67dc5ef1-873a-4113-b8df-9f646df6d66d",
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "We don't need it because that one just takes an `Iterable` since it doesn't need to honor the \"returns the same collection type\" guarantee.",
        "createdAt" : "2020-11-06T06:43:50Z",
        "updatedAt" : "2020-11-06T06:43:50Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      },
      {
        "id" : "72b62bad-3572-487f-8270-aca4a687213d",
        "parentId" : "67dc5ef1-873a-4113-b8df-9f646df6d66d",
        "authorId" : "6080cd8f-e671-4d49-a54c-b6159456ac0e",
        "body" : "Good point. ",
        "createdAt" : "2020-11-06T06:44:55Z",
        "updatedAt" : "2020-11-06T06:44:55Z",
        "lastEditedBy" : "6080cd8f-e671-4d49-a54c-b6159456ac0e",
        "tags" : [
        ]
      }
    ],
    "commit" : "a7a2105b1c8a01999e25a4b2f17bf7e55eca3714",
    "line" : 59,
    "diffHunk" : "@@ -1,1 +1150,1154 @@   * transactional effect that produces a new `Set[B]`.\n   */\n  def foreach[R, E, A, B](in: Set[A])(f: A => ZSTM[R, E, B]): ZSTM[R, E, Set[B]] =\n    foreach[R, E, A, B, Iterable](in)(f).map(_.toSet)\n"
  },
  {
    "id" : "46d8af49-9cf3-498e-8d01-6150204cc965",
    "prId" : 4289,
    "prUrl" : "https://github.com/zio/zio/pull/4289#pullrequestreview-509938529",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2737b9de-8711-461c-b207-11e48ba99b65",
        "parentId" : null,
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "This should be the version that the deprecated method will be removed, so `2.0.0`.",
        "createdAt" : "2020-10-16T00:24:02Z",
        "updatedAt" : "2020-10-16T00:24:02Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      },
      {
        "id" : "abacd487-fdfb-4224-8fdf-542475d3dce7",
        "parentId" : "2737b9de-8711-461c-b207-11e48ba99b65",
        "authorId" : "d75be8fa-2835-4186-80dc-40caf532bcef",
        "body" : "According to the scaladoc for `@deprecated` it's when it was first deprecated. If zio does things differently that's fine but this should probably be documented somewhere.  I can't find any mention of this in the repo. Do you still want me to change it?\r\n\r\n```scala\r\n/**\r\n*...\r\n*@param  since   a string identifying the first version in which the definition was deprecated\r\n*...\r\n*/\r\nclass deprecated(message: String = \"\", since: String = \"\") extends scala.annotation.StaticAnnotation\r\n```",
        "createdAt" : "2020-10-16T00:32:40Z",
        "updatedAt" : "2020-10-16T00:32:41Z",
        "lastEditedBy" : "d75be8fa-2835-4186-80dc-40caf532bcef",
        "tags" : [
        ]
      },
      {
        "id" : "7131dc13-cb1b-4360-b174-895cd3c65c70",
        "parentId" : "2737b9de-8711-461c-b207-11e48ba99b65",
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "You're right.",
        "createdAt" : "2020-10-16T00:35:34Z",
        "updatedAt" : "2020-10-16T00:35:34Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      }
    ],
    "commit" : "db5bdcb0f6b34b3942cad15a3029029c1f41dd06",
    "line" : 38,
    "diffHunk" : "@@ -1,1 +400,404 @@  @deprecated(\n    \"Repeating until failure doesn't make sense in the context of STM because it will always roll back the transaction\",\n    \"1.0.2\"\n  )\n  def forever: ZSTM[R, E, Nothing] = self *> self.forever"
  },
  {
    "id" : "a3966f34-7109-47af-9770-ca72bed94b8b",
    "prId" : 4115,
    "prUrl" : "https://github.com/zio/zio/pull/4115#pullrequestreview-472836890",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b67428d6-03ea-4c12-a8bd-4e7501ae8ee5",
        "parentId" : null,
        "authorId" : "6080cd8f-e671-4d49-a54c-b6159456ac0e",
        "body" : "Hmm, this behavior is the one we tried to remove with `orTry`, i.e. being \"stuck\" in retrying the first transaction.",
        "createdAt" : "2020-08-21T06:30:50Z",
        "updatedAt" : "2020-08-25T16:58:51Z",
        "lastEditedBy" : "6080cd8f-e671-4d49-a54c-b6159456ac0e",
        "tags" : [
        ]
      },
      {
        "id" : "bbb40e0c-b1be-4ae7-93a3-62db28668766",
        "parentId" : "b67428d6-03ea-4c12-a8bd-4e7501ae8ee5",
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "Sorry, can you remind me what the issue is here? If the left side retries we evaluate the right side, which I think is what we want, and if the right side retries we go back and retry the whole thing, which I think is also what we want. Do we have a test for the expected behavior here?",
        "createdAt" : "2020-08-21T13:50:26Z",
        "updatedAt" : "2020-08-25T16:58:51Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      },
      {
        "id" : "6e731a97-f01e-4e52-8ebd-f46618bf88d4",
        "parentId" : "b67428d6-03ea-4c12-a8bd-4e7501ae8ee5",
        "authorId" : "6080cd8f-e671-4d49-a54c-b6159456ac0e",
        "body" : "Ah so, the reason behind `orTry` was quirky behavior of `orElse` from haskell's perspective. In this particular case, `that` would continue until success, which should not be the case, i.e. if it retries we should go back to `self`. ",
        "createdAt" : "2020-08-21T14:18:46Z",
        "updatedAt" : "2020-08-25T16:58:51Z",
        "lastEditedBy" : "6080cd8f-e671-4d49-a54c-b6159456ac0e",
        "tags" : [
        ]
      },
      {
        "id" : "11ae4cb6-a513-40ea-b8c2-f1dd8d2e0bf9",
        "parentId" : "b67428d6-03ea-4c12-a8bd-4e7501ae8ee5",
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "But aren't we going back to `self` here? In the test the only way we eventually succeed with \"left\" is because we go back to evaluate `left` again after `right` retries.",
        "createdAt" : "2020-08-21T14:33:52Z",
        "updatedAt" : "2020-08-25T16:58:51Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      },
      {
        "id" : "3d7cef44-d364-4f18-a6af-8f058df2e0f2",
        "parentId" : "b67428d6-03ea-4c12-a8bd-4e7501ae8ee5",
        "authorId" : "6080cd8f-e671-4d49-a54c-b6159456ac0e",
        "body" : "Hm, I remember I had to invoke `orTry` in reverse order to get the desired behavior. There should be a test for it, so if it passes it should be ok. ",
        "createdAt" : "2020-08-21T14:44:14Z",
        "updatedAt" : "2020-08-25T16:58:51Z",
        "lastEditedBy" : "6080cd8f-e671-4d49-a54c-b6159456ac0e",
        "tags" : [
        ]
      },
      {
        "id" : "538e4c0c-ffa8-4440-8352-0403ac0f05da",
        "parentId" : "b67428d6-03ea-4c12-a8bd-4e7501ae8ee5",
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "Okay. Yes all tests passing so should be good.",
        "createdAt" : "2020-08-21T14:49:59Z",
        "updatedAt" : "2020-08-25T16:58:51Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      },
      {
        "id" : "6d37c857-9ea6-49e2-b355-5dff8426923a",
        "parentId" : "b67428d6-03ea-4c12-a8bd-4e7501ae8ee5",
        "authorId" : "6080cd8f-e671-4d49-a54c-b6159456ac0e",
        "body" : "Re-checking this one, I think we need to keep the journal reset here. Also it would be interesting to check whether we can push `orElse` to the same state but that can be done independently.",
        "createdAt" : "2020-08-21T20:41:49Z",
        "updatedAt" : "2020-08-25T16:58:51Z",
        "lastEditedBy" : "6080cd8f-e671-4d49-a54c-b6159456ac0e",
        "tags" : [
        ]
      },
      {
        "id" : "9b1dd5a1-74c1-4ecb-987b-a3ddd941cdaf",
        "parentId" : "b67428d6-03ea-4c12-a8bd-4e7501ae8ee5",
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "Okay, so how do you think it should be implemented? The original version does a busy loop in the test \"retries left after retries right\". If I replace `{ reset(); that.orTry(self).provide(r) }` with `{ { reset(); that.provide(r) }` we never retry the left side and the test fails. Is there a test we can add for the expected behavior that this version doesn't satisfy?",
        "createdAt" : "2020-08-21T21:31:31Z",
        "updatedAt" : "2020-08-25T16:58:51Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      },
      {
        "id" : "7fa57f01-aff8-4bef-81dc-33ed6771bbd1",
        "parentId" : "b67428d6-03ea-4c12-a8bd-4e7501ae8ee5",
        "authorId" : "6080cd8f-e671-4d49-a54c-b6159456ac0e",
        "body" : "Let's keep the new implementation. Until there's a test to verify, the busy loop is a fact and this implementation fixes it. ",
        "createdAt" : "2020-08-21T21:49:21Z",
        "updatedAt" : "2020-08-25T16:58:51Z",
        "lastEditedBy" : "6080cd8f-e671-4d49-a54c-b6159456ac0e",
        "tags" : [
        ]
      }
    ],
    "commit" : "e3fac45cf9f8ec359dadc1637487ba5e1d05608b",
    "line" : 33,
    "diffHunk" : "@@ -1,1 +627,631 @@      case TExit.Fail(e)    => ZSTM.fail(e)\n      case TExit.Succeed(a) => ZSTM.succeedNow(a)\n      case TExit.Retry      => that\n    }\n"
  },
  {
    "id" : "aaed39d3-cd3d-4770-b8c7-57aebbde4202",
    "prId" : 2829,
    "prUrl" : "https://github.com/zio/zio/pull/2829#pullrequestreview-355161378",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "eb2a6625-c256-41cb-9bb5-9423989f8a0e",
        "parentId" : null,
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "Could also implement this and `fromFunctionM` as `access(f)` and `assessM(f)`.",
        "createdAt" : "2020-02-07T13:28:43Z",
        "updatedAt" : "2020-02-07T13:40:50Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      },
      {
        "id" : "f16bc452-a29a-43ad-9018-5344da555b09",
        "parentId" : "eb2a6625-c256-41cb-9bb5-9423989f8a0e",
        "authorId" : "6080cd8f-e671-4d49-a54c-b6159456ac0e",
        "body" : "Good point. Should we change that in ZIO as well?",
        "createdAt" : "2020-02-07T13:33:43Z",
        "updatedAt" : "2020-02-07T13:40:50Z",
        "lastEditedBy" : "6080cd8f-e671-4d49-a54c-b6159456ac0e",
        "tags" : [
        ]
      },
      {
        "id" : "7a94a0e9-0f02-4461-87d2-35ef5bdf2c2a",
        "parentId" : "eb2a6625-c256-41cb-9bb5-9423989f8a0e",
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "Probably slightly more efficient since we do it in one `Read` operation instead of a `Read` and a `FlatMap`.",
        "createdAt" : "2020-02-07T13:36:03Z",
        "updatedAt" : "2020-02-07T13:40:50Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      },
      {
        "id" : "dde5fa49-fc3d-4cf8-a7ea-177dcb2e7e38",
        "parentId" : "eb2a6625-c256-41cb-9bb5-9423989f8a0e",
        "authorId" : "6080cd8f-e671-4d49-a54c-b6159456ac0e",
        "body" : "Done.",
        "createdAt" : "2020-02-07T13:40:49Z",
        "updatedAt" : "2020-02-07T13:40:50Z",
        "lastEditedBy" : "6080cd8f-e671-4d49-a54c-b6159456ac0e",
        "tags" : [
        ]
      }
    ],
    "commit" : "cc7bcff155fbede6c13218089942c227bf967c7b",
    "line" : 16,
    "diffHunk" : "@@ -1,1 +701,705 @@   * Lifts a function `R => A` into a `ZSTM[R, Nothing, A]`.\n   */\n  def fromFunction[R, A](f: R => A): ZSTM[R, Nothing, A] =\n    access(f)\n"
  },
  {
    "id" : "519cab0e-633a-4d2f-99dd-01b3b0e20bdb",
    "prId" : 2799,
    "prUrl" : "https://github.com/zio/zio/pull/2799#pullrequestreview-354177567",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "489154e4-7e79-4b30-9f46-30c03985f6cc",
        "parentId" : null,
        "authorId" : "fe8c0309-9574-4c2c-a95a-2f54e9bd5411",
        "body" : "@adamgfraser \r\nshould be `s = inc(s)`, `val s`->`var s` here?",
        "createdAt" : "2020-02-06T00:00:52Z",
        "updatedAt" : "2020-02-06T00:00:52Z",
        "lastEditedBy" : "fe8c0309-9574-4c2c-a95a-2f54e9bd5411",
        "tags" : [
        ]
      },
      {
        "id" : "6f9366ba-b30e-4471-ab82-2ef9a8cefba4",
        "parentId" : "489154e4-7e79-4b30-9f46-30c03985f6cc",
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "Yes you're right. Just submitted a PR to fix.",
        "createdAt" : "2020-02-06T03:08:02Z",
        "updatedAt" : "2020-02-06T03:08:02Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      }
    ],
    "commit" : "d10bdb9e70b40db18cd37faaf639ed6fc8850618",
    "line" : 72,
    "diffHunk" : "@@ -1,1 +1002,1006 @@   * while (cont(s)) {\n   *   body(s)\n   *   inc(s)\n   * }\n   * }}}"
  },
  {
    "id" : "b6c6a99e-5b9e-4469-b5d7-f77e517b7c99",
    "prId" : 2651,
    "prUrl" : "https://github.com/zio/zio/pull/2651#pullrequestreview-344975457",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "cba173f1-b263-45cd-94bb-141ff6ed58f6",
        "parentId" : null,
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "I believe there was a bug here where effects were evaluated in the wrong order. I added a fix for it and a test.",
        "createdAt" : "2020-01-19T03:58:42Z",
        "updatedAt" : "2020-01-19T23:21:27Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      }
    ],
    "commit" : "8ae2955d0f934445f1fad52c6d41389355cfe544",
    "line" : 3,
    "diffHunk" : "@@ -1,1 +845,849 @@   * transactional effect that produces a list of values.\n   */\n  def collectAll[E, A](i: Iterable[STM[E, A]]): STM[E, List[A]] =\n    i.foldRight[STM[E, List[A]]](STM.succeed(Nil))(_.zipWith(_)(_ :: _))\n"
  }
]
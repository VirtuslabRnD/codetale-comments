[
  {
    "id" : "1fc82924-55c4-49e9-93c2-5b0c730a9c5f",
    "prId" : 5229,
    "prUrl" : "https://github.com/zio/zio/pull/5229#pullrequestreview-690726486",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1fd13bd1-9faa-494e-9077-c45c5cc89245",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "Thank you for all the `@deprecated` warnings! It will help early users of 2.0 release candidates.",
        "createdAt" : "2021-06-23T14:21:09Z",
        "updatedAt" : "2021-06-23T14:21:09Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      }
    ],
    "commit" : "140dba88ecac0298b9bb2e25b34f585986a08e42",
    "line" : 185,
    "diffHunk" : "@@ -1,1 +899,903 @@   * Takes all elements so long as the effectual predicate returns true.\n   */\n  @deprecated(\"use takeWhileZIO\", \"2.0.0\")\n  def takeWhileM[R, E](p: A => ZIO[R, E, Boolean]): ZIO[R, E, Chunk[A]] =\n    takeWhileZIO(p)"
  },
  {
    "id" : "6bdf60f1-af81-40a3-8bba-5ca2aaa78ff8",
    "prId" : 4504,
    "prUrl" : "https://github.com/zio/zio/pull/4504#pullrequestreview-555855357",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a86a4652-9145-424d-95be-59f7c4f75d59",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "May be faster to materialize into an array, and then copy portions of it into sub arrays. But this looks good for now!",
        "createdAt" : "2020-12-18T22:40:01Z",
        "updatedAt" : "2020-12-18T22:40:01Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      }
    ],
    "commit" : "63ffcad19beddc4792e9bd370dac226f4b3f1ee6",
    "line" : 12,
    "diffHunk" : "@@ -1,1 +699,703 @@    val remainder = length % n\n    val iterator  = self.iterator\n    val chunks    = ChunkBuilder.make[Chunk[A]]()\n    var i         = 0\n    while (i < remainder) {"
  },
  {
    "id" : "e3d001f4-e569-45a6-9a2b-bbbb2458cea5",
    "prId" : 4037,
    "prUrl" : "https://github.com/zio/zio/pull/4037#pullrequestreview-459645411",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "92da1f71-abcf-47e9-90f4-34ec7a2138c9",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "üòç ",
        "createdAt" : "2020-08-02T12:28:18Z",
        "updatedAt" : "2020-08-02T15:20:09Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      }
    ],
    "commit" : "f227401f0ee9a606e7a100c3aface01e47081487",
    "line" : 21,
    "diffHunk" : "@@ -1,1 +616,620 @@   */\n  final def mapM[R, E, B](f: A => ZIO[R, E, B]): ZIO[R, E, Chunk[B]] =\n    ZIO.foreach(self)(f)\n\n  /**"
  },
  {
    "id" : "6dbb3126-5995-4e2c-85a0-5e58660f3368",
    "prId" : 4011,
    "prUrl" : "https://github.com/zio/zio/pull/4011#pullrequestreview-458004788",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fcf971b8-a7ef-4f4e-8bf4-f22edef27e0b",
        "parentId" : null,
        "authorId" : "afb03ae4-dda4-44cf-b8cc-01869283581a",
        "body" : "Why not have a simpler implementation ‚Äî \r\n\r\n```scala\r\nmapM(A => pred(A).map(cond => (A, cond)).takeUntil(_._2).map(_._1)\r\n```",
        "createdAt" : "2020-07-30T01:26:50Z",
        "updatedAt" : "2020-07-30T01:26:50Z",
        "lastEditedBy" : "afb03ae4-dda4-44cf-b8cc-01869283581a",
        "tags" : [
        ]
      }
    ],
    "commit" : "d3804c51cda6d59a3d8aedef5522957a5ed6240f",
    "line" : 33,
    "diffHunk" : "@@ -1,1 +827,831 @@        }\n      }\n      taking as builder.result()\n    }\n"
  },
  {
    "id" : "d626fee7-e3a8-4448-90c0-537b8b505662",
    "prId" : 3678,
    "prUrl" : "https://github.com/zio/zio/pull/3678#pullrequestreview-416334619",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e737a26a-af5a-4f57-af4d-b0b51f1e52c1",
        "parentId" : null,
        "authorId" : "0676ff00-bbe5-4a0f-8ff4-791926933b92",
        "body" : "I wonder if it would make sense to have a naming convention to serve the same purpose as this warning. `Chunk.fromArray` could copy by default and then the alternate \"unsafe\" one would be the fast version. Depends if there is already a precedent for that in the ZIO codebase.\r\n\r\nAlso when seeing this, I also thought about if there might be a use for a `Chunk.fromArray[A](array: Array[A], start: Int, len: Int)` version.",
        "createdAt" : "2020-05-21T14:59:09Z",
        "updatedAt" : "2020-05-21T14:59:09Z",
        "lastEditedBy" : "0676ff00-bbe5-4a0f-8ff4-791926933b92",
        "tags" : [
        ]
      },
      {
        "id" : "db7dcfda-64da-4f45-9862-f092df4ea69b",
        "parentId" : "e737a26a-af5a-4f57-af4d-b0b51f1e52c1",
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "@reibitto I like the slicing version! Could be a nice PR if you have the cycles.\r\n\r\nRe the naming: I think a warning is sufficient because we're not going to add the other variant. The caller can always defensively copy if required.",
        "createdAt" : "2020-05-21T17:11:52Z",
        "updatedAt" : "2020-05-21T17:11:52Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      }
    ],
    "commit" : "c94f068aa769d127d49ae46ab3a55733190e0a45",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +769,773 @@   * Returns a chunk backed by an array.\n   *\n   * WARNING: The array must not be mutated after creating the chunk.\n   */\n  def fromArray[A](array: Array[A]): Chunk[A] ="
  },
  {
    "id" : "f3b58e75-2e51-4d7e-8b88-4ce897ac9b9a",
    "prId" : 3576,
    "prUrl" : "https://github.com/zio/zio/pull/3576#pullrequestreview-411476593",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2e13571b-b049-4490-9eb4-da847b245bc3",
        "parentId" : null,
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "Let's make this method do the right thing by pattern matching on the array. You can see an example for this in `WrappedArray.make`.",
        "createdAt" : "2020-05-14T05:36:26Z",
        "updatedAt" : "2020-05-14T09:35:36Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      }
    ],
    "commit" : "83217f8eccc7b6d732f621e1cd09571935a2b295",
    "line" : 12,
    "diffHunk" : "@@ -1,1 +753,757 @@   * Returns a chunk backed by an array.\n   */\n  def fromArray[A](array: Array[A]): Chunk[A] =\n    (if (array.isEmpty) Empty\n     else"
  },
  {
    "id" : "99d01c0e-55b2-4d0e-b3c7-17e077e6d62b",
    "prId" : 3576,
    "prUrl" : "https://github.com/zio/zio/pull/3576#pullrequestreview-411957010",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4857426c-5961-4a78-8e33-d90f82e99c67",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "Have you tested to make sure Scala is doing the right thing here w.r.t type erasure? Ordinarily you can't match on, e.g., `List[Int]` because of type erasure. There is a means to do this for arrays, because they store their type inside them, but I'm not 100% sure if Scala utilizes this to make this type casing sane. Worth testing to be sure.\r\n\r\nOr to avoid you could match on `Array#elemTag` which gives you the tag of the element\u0010 type.",
        "createdAt" : "2020-05-14T14:52:23Z",
        "updatedAt" : "2020-05-14T14:52:23Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      },
      {
        "id" : "3beeb42c-7dcd-4dc7-8bb4-dbf18d05dcb8",
        "parentId" : "4857426c-5961-4a78-8e33-d90f82e99c67",
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "I‚Äôve tested in the REPL that a byte array becomes a ByteArray",
        "createdAt" : "2020-05-14T15:58:57Z",
        "updatedAt" : "2020-05-14T15:58:57Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      },
      {
        "id" : "0080d1e6-c777-4397-b919-9f2ea2183ceb",
        "parentId" : "4857426c-5961-4a78-8e33-d90f82e99c67",
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "The pattern matching works here because an Array[Int] is a distinct type at runtime, whereas List[Int] is just a List[AnyRef] at runtime",
        "createdAt" : "2020-05-14T16:00:05Z",
        "updatedAt" : "2020-05-14T16:00:05Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      },
      {
        "id" : "2343b451-8712-4235-909e-441245adf6f0",
        "parentId" : "4857426c-5961-4a78-8e33-d90f82e99c67",
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "Ok, so Scalac has baked this in. üëç ",
        "createdAt" : "2020-05-14T16:04:56Z",
        "updatedAt" : "2020-05-14T16:04:56Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      }
    ],
    "commit" : "83217f8eccc7b6d732f621e1cd09571935a2b295",
    "line" : 17,
    "diffHunk" : "@@ -1,1 +757,761 @@     else\n       array.asInstanceOf[AnyRef] match {\n         case x: Array[AnyRef]  => AnyRefArray(x)\n         case x: Array[Int]     => IntArray(x)\n         case x: Array[Double]  => DoubleArray(x)"
  },
  {
    "id" : "0d384fb9-a6d4-4a84-9dbb-f6bb7f78fe1c",
    "prId" : 3576,
    "prUrl" : "https://github.com/zio/zio/pull/3576#pullrequestreview-411956679",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "550f5db2-2f55-4051-834d-2ac9240d81aa",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "Really nice to see all these box-free accessors!! ‚ù§Ô∏è \r\n",
        "createdAt" : "2020-05-14T14:55:24Z",
        "updatedAt" : "2020-05-14T14:55:25Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      },
      {
        "id" : "f9cacb44-3953-4b66-8640-f67450f83d67",
        "parentId" : "550f5db2-2f55-4051-834d-2ac9240d81aa",
        "authorId" : "ee35f1f5-00d2-440f-b26d-a358e9823986",
        "body" : "Is there a note anywhere on this technique for avoiding boxing? I don't understand what role the implicit is serving here.",
        "createdAt" : "2020-05-14T15:00:22Z",
        "updatedAt" : "2020-05-14T15:00:23Z",
        "lastEditedBy" : "ee35f1f5-00d2-440f-b26d-a358e9823986",
        "tags" : [
        ]
      },
      {
        "id" : "6fa88fcc-7bdd-48ff-98cb-077236d2827a",
        "parentId" : "550f5db2-2f55-4051-834d-2ac9240d81aa",
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "The implicit acts as proof in the parent type that it is safe to call this method in the child type. It's a way of exposing the specialized method in the parent.",
        "createdAt" : "2020-05-14T16:04:34Z",
        "updatedAt" : "2020-05-14T16:04:35Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      }
    ],
    "commit" : "83217f8eccc7b6d732f621e1cd09571935a2b295",
    "line" : 73,
    "diffHunk" : "@@ -1,1 +1365,1369 @@\n  final case class ShortArray(array: Array[Short]) extends Arr[Short] {\n    override def short(index: Int)(implicit ev: Short <:< Short): Short = array(index)\n  }\n"
  },
  {
    "id" : "12496389-5b62-4ece-a137-52fbaebdd519",
    "prId" : 3515,
    "prUrl" : "https://github.com/zio/zio/pull/3515#pullrequestreview-404553793",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "385ab8e6-57c3-4664-8532-ec3a22a58366",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "This whole function body needs to be encased in `ZIO.effectSuspendTotal`. Right now, it is not referentially transparent, which will cause bugs.",
        "createdAt" : "2020-05-02T18:28:30Z",
        "updatedAt" : "2020-05-02T19:27:07Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      },
      {
        "id" : "a7f0baf8-b773-48f8-b292-a4ca90f653c4",
        "parentId" : "385ab8e6-57c3-4664-8532-ec3a22a58366",
        "authorId" : "3baf0778-64e2-43e6-9c28-acfb964a2880",
        "body" : "Thanks! I got it.\r\nShould I also encase the function bodies of `mapAccumM` in `ZIO.effectSuspendTotal`?",
        "createdAt" : "2020-05-02T19:19:11Z",
        "updatedAt" : "2020-05-02T19:27:07Z",
        "lastEditedBy" : "3baf0778-64e2-43e6-9c28-acfb964a2880",
        "tags" : [
        ]
      },
      {
        "id" : "eca66223-bd58-4382-be33-237fa260d439",
        "parentId" : "385ab8e6-57c3-4664-8532-ec3a22a58366",
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "Yes please, the construction of a builder is impure, and those methods must be wrapped in `effectSuspendTotal`. Thank you so much! üôè ",
        "createdAt" : "2020-05-02T19:19:59Z",
        "updatedAt" : "2020-05-02T19:27:07Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      }
    ],
    "commit" : "11e17d1ed5bd2b1d732c0c47ba2638b10e6f45f3",
    "line" : 8,
    "diffHunk" : "@@ -1,1 +165,169 @@\n  def dropWhileM[R, E](p: A => ZIO[R, E, Boolean]): ZIO[R, E, Chunk[A]] = ZIO.effectSuspendTotal {\n    val len     = self.length\n    val builder = ChunkBuilder.make[A]()\n    builder.sizeHint(len)"
  },
  {
    "id" : "2cd583fa-a5f3-43f6-83f2-d07bc7cd1ba8",
    "prId" : 3416,
    "prUrl" : "https://github.com/zio/zio/pull/3416#pullrequestreview-396459202",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b663d6cf-f35d-454f-88fe-af4a6a46b582",
        "parentId" : null,
        "authorId" : "6080cd8f-e671-4d49-a54c-b6159456ac0e",
        "body" : "Doesn't `copyToArray` return `Unit`?",
        "createdAt" : "2020-04-20T06:44:44Z",
        "updatedAt" : "2020-05-19T20:58:20Z",
        "lastEditedBy" : "6080cd8f-e671-4d49-a54c-b6159456ac0e",
        "tags" : [
        ]
      },
      {
        "id" : "02a869ea-996a-4b2b-aed2-ed7bbe27b8f5",
        "parentId" : "b663d6cf-f35d-454f-88fe-af4a6a46b582",
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "On Scala 2.13 it returns an integer with the number of elements written to the array.",
        "createdAt" : "2020-04-20T13:20:55Z",
        "updatedAt" : "2020-05-19T20:58:20Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      },
      {
        "id" : "162e6e78-0cfd-42ff-8023-36ddbb2d024f",
        "parentId" : "b663d6cf-f35d-454f-88fe-af4a6a46b582",
        "authorId" : "6080cd8f-e671-4d49-a54c-b6159456ac0e",
        "body" : "Ah, I see, my bad.",
        "createdAt" : "2020-04-20T13:36:57Z",
        "updatedAt" : "2020-05-19T20:58:20Z",
        "lastEditedBy" : "6080cd8f-e671-4d49-a54c-b6159456ac0e",
        "tags" : [
        ]
      }
    ],
    "commit" : "dbf04993ed5c421175cbeebf04351b8dcbec66e2",
    "line" : 207,
    "diffHunk" : "@@ -1,1 +966,970 @@    override protected[zio] def toArray[A1 >: A](n: Int, dest: Array[A1]): Unit = {\n      start.toArray(n, dest)\n      val _ = buffer.asInstanceOf[Array[A]].copyToArray(dest, n + start.length, bufferUsed)\n    }\n  }"
  },
  {
    "id" : "8d31f785-66a1-40e6-b2fb-f5f8757304d6",
    "prId" : 3416,
    "prUrl" : "https://github.com/zio/zio/pull/3416#pullrequestreview-396675254",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e9133a1b-e332-43dc-a2cc-6125caffbb4e",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "This one is going to be tricky. I'm not sure the right number to choose. I'd think somewhere between `32` and `128`. Higher numbers equal faster performance for repeated adds, while lower numbers yield higher waste for infrequent adds.",
        "createdAt" : "2020-04-20T14:42:57Z",
        "updatedAt" : "2020-05-19T20:58:20Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      },
      {
        "id" : "ba5e02ef-3c36-4f69-9ac1-e98c96da0ffd",
        "parentId" : "e9133a1b-e332-43dc-a2cc-6125caffbb4e",
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "Maybe we start with 64 and we can always adjust? I think we probably need some aggregate benchmark for a varied set of tasks to really pick the \"right\" number here and may also make sense to get in some of the other improvements we're making before doing that degree of optimization.",
        "createdAt" : "2020-04-20T15:51:44Z",
        "updatedAt" : "2020-05-19T20:58:20Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      },
      {
        "id" : "a327d4f4-3131-4a91-b600-6b8a0daaec4e",
        "parentId" : "e9133a1b-e332-43dc-a2cc-6125caffbb4e",
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "Makes sense to me! üëç ",
        "createdAt" : "2020-04-20T15:55:53Z",
        "updatedAt" : "2020-05-19T20:58:20Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      },
      {
        "id" : "ca855e24-1e9b-4fa4-84cd-a751f67e3467",
        "parentId" : "e9133a1b-e332-43dc-a2cc-6125caffbb4e",
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "One other thing we could do here is have some heuristic for the buffer size. Like we could start out with a buffer size of `1` and double the buffer size every time something is \"too big\" so we are learning and optimizing for how the user is working with the chunk.",
        "createdAt" : "2020-04-20T17:23:57Z",
        "updatedAt" : "2020-05-19T20:58:20Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      },
      {
        "id" : "986cf45f-d43c-4be8-a196-7c95ae7b706b",
        "parentId" : "e9133a1b-e332-43dc-a2cc-6125caffbb4e",
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "My feeling is that it will not perform that well compared to just choosing a static number.\r\n\r\nI remember some research showing the vast majority of collections are \"small collections\". The constant doubling (from 1 to 2, 2 to 4, etc.) means a lot of copying on your way to a small size.",
        "createdAt" : "2020-04-20T17:41:57Z",
        "updatedAt" : "2020-05-19T20:58:20Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      },
      {
        "id" : "4dd76ec4-84fa-4d0a-83e5-7c4deb5578f1",
        "parentId" : "e9133a1b-e332-43dc-a2cc-6125caffbb4e",
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "Yes. We could also start at an intermediate size like say `8` and double from there but also fine as is and can always optimize later.",
        "createdAt" : "2020-04-20T17:44:48Z",
        "updatedAt" : "2020-05-19T20:58:20Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      }
    ],
    "commit" : "dbf04993ed5c421175cbeebf04351b8dcbec66e2",
    "line" : 181,
    "diffHunk" : "@@ -1,1 +940,944 @@   * The maximum number of elements in the buffer for fast append.\n   */\n  private val BufferSize: Int =\n    64\n"
  },
  {
    "id" : "b908a912-5c9c-4d3b-919a-3d1011b337c4",
    "prId" : 3374,
    "prUrl" : "https://github.com/zio/zio/pull/3374#pullrequestreview-393695529",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bac488e7-6a8e-4bf8-8012-48be5e807d65",
        "parentId" : null,
        "authorId" : "2a2f79ba-933f-43cd-9d45-5d769ab0f54d",
        "body" : "this could still return NonEmptyChunk",
        "createdAt" : "2020-04-15T08:12:56Z",
        "updatedAt" : "2020-04-15T11:40:50Z",
        "lastEditedBy" : "2a2f79ba-933f-43cd-9d45-5d769ab0f54d",
        "tags" : [
        ]
      },
      {
        "id" : "d1f0db48-8e6e-4da7-b32e-c8e3dfde4748",
        "parentId" : "bac488e7-6a8e-4bf8-8012-48be5e807d65",
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "We could but there is potentially a little extra overhead in creating the `NonEmptyChunk` which I thought you might not want if you were doing repeated appends and were doing high performance stuff where you didn't care about whether it was empty or not (e.g. you're just calling `foreach` on it). So right now you kind of stay in the `Chunk` world unless you explicitly go to the `NonEmptyChunk` world, and once you're there we preserve that information whenever possible. But we could definitely change as you suggest.",
        "createdAt" : "2020-04-15T11:43:21Z",
        "updatedAt" : "2020-04-15T11:43:21Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      }
    ],
    "commit" : "3636d9a60bd16bdf2ff45405a5e0c32b391a4dd7",
    "line" : 9,
    "diffHunk" : "@@ -1,1 +37,41 @@   * Appends an element to the chunk\n   */\n  final def +[A1 >: A](a: A1): Chunk[A1] =\n    if (self.length == 0) Chunk.single(a)\n    else Chunk.Concat(self, Chunk.single(a))"
  },
  {
    "id" : "adf19d07-35f0-43d8-919e-7194831c4e7c",
    "prId" : 3318,
    "prUrl" : "https://github.com/zio/zio/pull/3318#pullrequestreview-391720084",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c885a35a-4609-4652-9d0a-eabbea42260e",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "This is technically correct, I think. Although in any case where we look at this class tag and are tempted to use it (to create a new array), we should probably be special casing and instead creating a bit chunk... so hopefully we never use the class tag.",
        "createdAt" : "2020-04-11T00:56:18Z",
        "updatedAt" : "2020-04-11T04:39:06Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      }
    ],
    "commit" : "809a947e363df79b1a9368fbe7431df7bd016f53",
    "line" : 444,
    "diffHunk" : "@@ -1,1 +856,860 @@    case x: Slice[A]       => x.classTag\n    case x: VectorChunk[A] => x.classTag\n    case _: BitChunk       => ClassTag.Boolean.asInstanceOf[ClassTag[A]]\n  }\n"
  },
  {
    "id" : "db1f3e93-d40b-4877-b334-550d94269b81",
    "prId" : 3318,
    "prUrl" : "https://github.com/zio/zio/pull/3318#pullrequestreview-391720228",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e9874c90-42b4-445d-990f-255f2f55577a",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "Eventually this can be optimized so you iterate over the bytes in `bytes` and call `f` 8 times for each byte.",
        "createdAt" : "2020-04-11T00:57:57Z",
        "updatedAt" : "2020-04-11T04:39:06Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      }
    ],
    "commit" : "809a947e363df79b1a9368fbe7431df7bd016f53",
    "line" : 505,
    "diffHunk" : "@@ -1,1 +1230,1234 @@    override def foreach(f: Boolean => Any): Unit = {\n      var i = 0\n      while (i < length) {\n        f(apply(i))\n        i += 1"
  },
  {
    "id" : "9ce7ce91-abc0-47c0-a100-1ea7a1773469",
    "prId" : 3309,
    "prUrl" : "https://github.com/zio/zio/pull/3309#pullrequestreview-388752091",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1961c05b-43d6-4847-a18b-f16915e9e6cc",
        "parentId" : null,
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "Can move this variant back to the trait.",
        "createdAt" : "2020-04-07T02:59:21Z",
        "updatedAt" : "2020-04-07T03:32:23Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      }
    ],
    "commit" : "15b6571f9fe26a4a3f020baaab31f19f4f9c24b4",
    "line" : 21,
    "diffHunk" : "@@ -1,1 +598,602 @@     * Returns the concatenation of this chunk with the specified chunk.\n     */\n    def ++[A1 >: A](chunk: Chunk[A1]): Chunk[A1] = concat(self, chunk)\n\n    /**"
  },
  {
    "id" : "7d2a18d6-92c9-4f92-8617-75a8ebadefd0",
    "prId" : 3297,
    "prUrl" : "https://github.com/zio/zio/pull/3297#pullrequestreview-389473473",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8108d47f-188d-4c6a-9e9e-bc79eedff84e",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "Why copy this? You can wrap it into a chunk directly, right?",
        "createdAt" : "2020-04-07T12:15:10Z",
        "updatedAt" : "2020-04-07T21:54:51Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      },
      {
        "id" : "5dd431a9-26fd-4690-8f08-7e9e35a29781",
        "parentId" : "8108d47f-188d-4c6a-9e9e-bc79eedff84e",
        "authorId" : "1724c5b2-b76c-4a84-8962-52e808e74b8a",
        "body" : "It is faster to copy it directly with the missing element `a`, even in the creation. It is faster also when using it after.",
        "createdAt" : "2020-04-07T12:48:11Z",
        "updatedAt" : "2020-04-07T21:54:51Z",
        "lastEditedBy" : "1724c5b2-b76c-4a84-8962-52e808e74b8a",
        "tags" : [
        ]
      },
      {
        "id" : "c8d44716-29fd-476f-ac2f-35a299fd257a",
        "parentId" : "8108d47f-188d-4c6a-9e9e-bc79eedff84e",
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "Isn‚Äôt it faster we because we are capturing the existing class tag versus creating a new one? Is there a variant where we reuse the class tag but just create a new Concat with the first element and the existing array?",
        "createdAt" : "2020-04-07T12:53:25Z",
        "updatedAt" : "2020-04-07T21:54:51Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      },
      {
        "id" : "bcaf8449-18db-4ca5-be6c-ca5a7ecb703a",
        "parentId" : "8108d47f-188d-4c6a-9e9e-bc79eedff84e",
        "authorId" : "1724c5b2-b76c-4a84-8962-52e808e74b8a",
        "body" : "strangely it cost a lot more, for `Chunk(1, 2, 3, 4)`: \r\n* 20 ns if you recopy\r\n* 60+ ns if you `Concat(Singleton(a), Arr(element, tag))`\r\n\r\nI had both methods on a benchmark : \r\n* new is `Concat`\r\n* current is full recopy\r\n* old is the one on master\r\n\r\nthe mix of those two methods at N=16 is coming from this benchmark.\r\n```scala\r\n[info] Benchmark                                  Mode  Cnt    Score     Error  Units\r\n[info] ChunkCreationBenchmarks.arrayCreate01      avgt    5    4.936 ¬±   0.052  ns/op\r\n[info] ChunkCreationBenchmarks.arrayCreate02      avgt    5    4.604 ¬±   0.145  ns/op\r\n[info] ChunkCreationBenchmarks.arrayCreate04      avgt    5    5.742 ¬±   0.082  ns/op\r\n[info] ChunkCreationBenchmarks.arrayCreate08      avgt    5    8.498 ¬±   0.105  ns/op\r\n[info] ChunkCreationBenchmarks.arrayCreate16      avgt    5   13.976 ¬±   0.219  ns/op\r\n[info] ChunkCreationBenchmarks.arrayCreate32      avgt    5   24.785 ¬±   0.053  ns/op\r\n[info] ChunkCreationBenchmarks.chunkCreate01      avgt    5   45.557 ¬±   0.758  ns/op\r\n[info] ChunkCreationBenchmarks.chunkCreate01_new  avgt    5   44.548 ¬±   2.560  ns/op\r\n[info] ChunkCreationBenchmarks.chunkCreate01_old  avgt    5   46.464 ¬±   2.556  ns/op\r\n[info] ChunkCreationBenchmarks.chunkCreate02      avgt    5   14.258 ¬±   0.123  ns/op\r\n[info] ChunkCreationBenchmarks.chunkCreate02_new  avgt    5   58.595 ¬±   1.976  ns/op\r\n[info] ChunkCreationBenchmarks.chunkCreate02_old  avgt    5   62.040 ¬±   4.300  ns/op\r\n[info] ChunkCreationBenchmarks.chunkCreate04      avgt    5   17.231 ¬±   0.202  ns/op\r\n[info] ChunkCreationBenchmarks.chunkCreate04_new  avgt    5   63.196 ¬±  39.850  ns/op\r\n[info] ChunkCreationBenchmarks.chunkCreate04_old  avgt    5   66.586 ¬±   0.316  ns/op\r\n[info] ChunkCreationBenchmarks.chunkCreate08      avgt    5   30.694 ¬±   1.041  ns/op\r\n[info] ChunkCreationBenchmarks.chunkCreate08_new  avgt    5   57.755 ¬±   5.651  ns/op\r\n[info] ChunkCreationBenchmarks.chunkCreate08_old  avgt    5   75.993 ¬±   4.792  ns/op\r\n[info] ChunkCreationBenchmarks.chunkCreate16      avgt    5   61.813 ¬±   3.506  ns/op\r\n[info] ChunkCreationBenchmarks.chunkCreate16_new  avgt    5   62.322 ¬±   4.343  ns/op\r\n[info] ChunkCreationBenchmarks.chunkCreate16_old  avgt    5  106.836 ¬±   1.873  ns/op\r\n[info] ChunkCreationBenchmarks.chunkCreate32      avgt    5  180.660 ¬± 187.046  ns/op\r\n[info] ChunkCreationBenchmarks.chunkCreate32_new  avgt    5  116.431 ¬±  98.966  ns/op\r\n[info] ChunkCreationBenchmarks.chunkCreate32_old  avgt    5  196.811 ¬± 183.724  ns/op\r\n[info] ChunkCreationBenchmarks.vectorCreate01     avgt    5   78.172 ¬±  14.909  ns/op\r\n[info] ChunkCreationBenchmarks.vectorCreate02     avgt    5   82.857 ¬±  27.224  ns/op\r\n[info] ChunkCreationBenchmarks.vectorCreate04     avgt    5   98.103 ¬±   3.921  ns/op\r\n[info] ChunkCreationBenchmarks.vectorCreate08     avgt    5  132.327 ¬±  12.716  ns/op\r\n[info] ChunkCreationBenchmarks.vectorCreate16     avgt    5  205.143 ¬±   8.434  ns/op\r\n[info] ChunkCreationBenchmarks.vectorCreate32     avgt    5  335.735 ¬±   8.287  ns/op\r\n[success] Total time: 3033 s (50:33), completed 6 Apr 2020, 01:30:48\r\n\r\n```",
        "createdAt" : "2020-04-07T13:05:19Z",
        "updatedAt" : "2020-04-07T21:54:51Z",
        "lastEditedBy" : "1724c5b2-b76c-4a84-8962-52e808e74b8a",
        "tags" : [
        ]
      },
      {
        "id" : "cc3c8e99-131c-4a8d-987d-534e6e4a86ef",
        "parentId" : "8108d47f-188d-4c6a-9e9e-bc79eedff84e",
        "authorId" : "1724c5b2-b76c-4a84-8962-52e808e74b8a",
        "body" : "The variant with Concat is when N>16 :\r\nhttps://github.com/zio/zio/pull/3297/files#diff-290e96e6c64027a32c36d751a35d65deR631",
        "createdAt" : "2020-04-07T13:08:08Z",
        "updatedAt" : "2020-04-07T21:54:51Z",
        "lastEditedBy" : "1724c5b2-b76c-4a84-8962-52e808e74b8a",
        "tags" : [
        ]
      },
      {
        "id" : "dbca9bfe-0670-4702-b551-8073f03e7677",
        "parentId" : "8108d47f-188d-4c6a-9e9e-bc79eedff84e",
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "Sounds good!",
        "createdAt" : "2020-04-07T20:40:28Z",
        "updatedAt" : "2020-04-07T21:54:51Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      }
    ],
    "commit" : "84e82efa103ddcd49a51628fed15bdd2e278faca",
    "line" : 45,
    "diffHunk" : "@@ -1,1 +619,623 @@        if (len <= 16) {\n\n          val dest: Array[A] = Array.ofDim[A](len)(ct)\n          dest(0) = a\n          var i: Int = 1"
  },
  {
    "id" : "304c02e1-ead1-4c29-b0cb-830dfbd80f74",
    "prId" : 3281,
    "prUrl" : "https://github.com/zio/zio/pull/3281#pullrequestreview-391452415",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c2bcd097-5c9e-4062-be78-25c97c986e4c",
        "parentId" : null,
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "Do we need this one? It's not used in this PR.",
        "createdAt" : "2020-04-10T13:50:08Z",
        "updatedAt" : "2020-04-10T13:50:09Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      },
      {
        "id" : "6c5cf7ae-6f31-4b68-9ac3-70bf703ba4a1",
        "parentId" : "c2bcd097-5c9e-4062-be78-25c97c986e4c",
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "Oh sorry I see the forwarder added in `ZManaged`.",
        "createdAt" : "2020-04-10T13:51:22Z",
        "updatedAt" : "2020-04-10T13:51:23Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      }
    ],
    "commit" : "c30aa3d640ac1993956ca1e6d5d509c63e9289f7",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +656,660 @@   * Effectfully maps the elements of this chunk.\n   */\n  final def mapManaged[R, E, B](f: A => ZManaged[R, E, B]): ZManaged[R, E, Chunk[B]] = {\n    val len                             = self.length\n    var array: ZManaged[R, E, Array[B]] = ZManaged.succeedNow(null.asInstanceOf[Array[B]])"
  },
  {
    "id" : "1904cf04-4567-4b8c-8395-e1de1f358165",
    "prId" : 2793,
    "prUrl" : "https://github.com/zio/zio/pull/2793#pullrequestreview-352333840",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "39761a36-1d37-4ee6-a227-83166581678e",
        "parentId" : null,
        "authorId" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "body" : "ü§¶‚Äç‚ôÇ ",
        "createdAt" : "2020-02-03T15:18:02Z",
        "updatedAt" : "2020-02-03T15:18:02Z",
        "lastEditedBy" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "tags" : [
        ]
      },
      {
        "id" : "90629676-2f2f-4a04-97ec-413469795c75",
        "parentId" : "39761a36-1d37-4ee6-a227-83166581678e",
        "authorId" : "6bab7be3-690b-49f9-9a0d-a8415f4c0c8e",
        "body" : "Haha, it's not a big deal really, it happens. :)",
        "createdAt" : "2020-02-03T15:21:34Z",
        "updatedAt" : "2020-02-03T15:21:35Z",
        "lastEditedBy" : "6bab7be3-690b-49f9-9a0d-a8415f4c0c8e",
        "tags" : [
        ]
      }
    ],
    "commit" : "e16f6d6d0355c24d4a34d0ee0f1d867be486a356",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +174,178 @@    var exists = false\n    var i      = 0\n    while (!exists && i < len) {\n      if (f(self(i))) exists = true\n      i += 1"
  },
  {
    "id" : "a1ea692c-ece5-4b06-9447-d82856f65593",
    "prId" : 2169,
    "prUrl" : "https://github.com/zio/zio/pull/2169#pullrequestreview-313702220",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "aaea082f-86d0-43ab-84ac-018d3d7f12de",
        "parentId" : null,
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "This was the problem with the `ArrayStoreException`?",
        "createdAt" : "2019-11-07T07:50:15Z",
        "updatedAt" : "2019-11-12T02:32:19Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      },
      {
        "id" : "dfd10c1f-a658-4f02-bed4-9fa060f754f5",
        "parentId" : "aaea082f-86d0-43ab-84ac-018d3d7f12de",
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "Yes. And I dug in deep, it literally has no stack trace attached, probably because it's generated from Scala code.\r\n\r\nIt happens when we have an array like `Array(Dog, Animal, Cat)` and detect the type as `Dog` and so specialize to `[LDog` but then putting `Animal` or `Cat` in there throws `ArrayStoreException`. So we either need to be not lazy or just use `AnyRef`. There's no reason I can tell for specializing the array, may as well just always do `AnyRef` arrays. But the types are a lie so we should encode that more nicely.",
        "createdAt" : "2019-11-07T23:22:12Z",
        "updatedAt" : "2019-11-12T02:32:19Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      }
    ],
    "commit" : "e597a3f9ff4c9895deccd1a7dc9ed0e94e93be52",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +1040,1044 @@      else if (isDouble(c)) DoubleClass.asInstanceOf[ClassTag[A]]\n      else if (isChar(c)) CharClass.asInstanceOf[ClassTag[A]]\n      else classTag[AnyRef].asInstanceOf[ClassTag[A]] // TODO: Find a better way\n\n    private final def isBoolean(c: ClassTag[_]): Boolean ="
  },
  {
    "id" : "758d82bb-4371-4eb7-a486-6c1b85f65c3b",
    "prId" : 1825,
    "prUrl" : "https://github.com/zio/zio/pull/1825#pullrequestreview-293570960",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ff798c76-76d8-4cf9-87a3-690ea454a0b7",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "Another thing you can do: anytime `length` is referenced, instead put it into a local `val`. This way it won't go through `invokevirtual` like all (non-`private[this]`) `val` access does.",
        "createdAt" : "2019-09-26T08:45:40Z",
        "updatedAt" : "2019-09-26T08:45:40Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      }
    ],
    "commit" : "65744906efeb360f250f32dbf21c3300cea4b3f9",
    "line" : 30,
    "diffHunk" : "@@ -1,1 +809,813 @@    override def toArray[A1 >: A](implicit tag: ClassTag[A1]): Array[A1] = array.asInstanceOf[Array[A1]]\n\n    override val length: Int = array.length\n\n    override def apply(n: Int): A = array(n)"
  },
  {
    "id" : "9a70a3ae-745b-4613-924d-bbe41f15c270",
    "prId" : 1797,
    "prUrl" : "https://github.com/zio/zio/pull/1797#pullrequestreview-291693344",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4a0e0b3a-cb95-4579-81c9-a1792d63e21e",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "Looks great!",
        "createdAt" : "2019-09-23T10:49:49Z",
        "updatedAt" : "2019-09-23T11:26:11Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      }
    ],
    "commit" : "1cec357c3d7d08c15a86774979671b92a69267d1",
    "line" : 54,
    "diffHunk" : "@@ -1,1 +393,397 @@  private def toArrayOption[A1 >: A]: Option[Array[A1]] = self match {\n    case Chunk.Empty => None\n    case chunk       => Some(chunk.toArray(Chunk.classTagOf(self)))\n  }\n"
  },
  {
    "id" : "8e0dae3a-640a-42fc-b600-fc34973b8373",
    "prId" : 1572,
    "prUrl" : "https://github.com/zio/zio/pull/1572#pullrequestreview-283861798",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "eceea4d0-82c3-4a5d-b3fd-cddafd451779",
        "parentId" : null,
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "Interesting that this did not show up in the property checks either. Good catch either way!",
        "createdAt" : "2019-09-04T20:03:17Z",
        "updatedAt" : "2019-09-04T20:07:06Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      }
    ],
    "commit" : "3e525ec06e3ae9939654cf2ff25c3553c6d015e1",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +53,57 @@\n    if (n <= 0) self\n    else if (n >= len) Chunk.empty\n    else\n      self match {"
  }
]
[
  {
    "id" : "e2ed2048-d79d-4be2-9731-4ab04915817e",
    "prId" : 5330,
    "prUrl" : "https://github.com/zio/zio/pull/5330#pullrequestreview-716232763",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5bc4b223-21e6-455b-9f3d-16f2695cb144",
        "parentId" : null,
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "👍 for removing this. This one is a little unusual in that it combines values of two different types unlike other binary operators. It is also something that you actually see used sometime which can make code bases less accessible.",
        "createdAt" : "2021-07-27T18:15:18Z",
        "updatedAt" : "2021-07-27T18:15:18Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      }
    ],
    "commit" : "5ce66c0463dc349abd2cd3f9f624c800e788be0b",
    "line" : 74,
    "diffHunk" : "@@ -1,1 +160,164 @@   */\n  @deprecated(\"use flatMap\", \"2.0.0\")\n  final def >>=[R1 <: R, E1 >: E, B](k: A => ZIO[R1, E1, B]): ZIO[R1, E1, B] = flatMap(k)\n\n  /**"
  },
  {
    "id" : "0f62b295-3e44-433b-9deb-ab66f87e0736",
    "prId" : 5330,
    "prUrl" : "https://github.com/zio/zio/pull/5330#pullrequestreview-716241041",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "baf77ad9-a42b-4f23-86e8-582f90c759e5",
        "parentId" : null,
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "Agreed.",
        "createdAt" : "2021-07-27T18:25:06Z",
        "updatedAt" : "2021-07-27T18:25:06Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      }
    ],
    "commit" : "5ce66c0463dc349abd2cd3f9f624c800e788be0b",
    "line" : 159,
    "diffHunk" : "@@ -1,1 +964,968 @@   */\n  @deprecated(\"use some\", \"2.0.0\")\n  final def get[B](implicit\n    ev1: E IsSubtypeOfError Nothing,\n    ev2: A IsSubtypeOfOutput Option[B]"
  },
  {
    "id" : "e119ed63-dbea-4599-8ba9-4fa55ce14b06",
    "prId" : 5330,
    "prUrl" : "https://github.com/zio/zio/pull/5330#pullrequestreview-716244196",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "333133b7-32c6-40c6-a4af-a3cf9dc9befd",
        "parentId" : null,
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "I think we have found overloading itself created issues, it is nice to say `for X to do A, for Y do B` rather than explain that there are actually two different variants of `A` that do different things.  We're moving away from that a little with `from` but I think that is quite explicitly saying \"give me everything and I will turn it into a ZIO\".",
        "createdAt" : "2021-07-27T18:28:46Z",
        "updatedAt" : "2021-07-27T18:28:46Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      }
    ],
    "commit" : "5ce66c0463dc349abd2cd3f9f624c800e788be0b",
    "line" : 217,
    "diffHunk" : "@@ -1,1 +1162,1166 @@   */\n  @deprecated(\"use lockExecutionContext\", \"2.0.0\")\n  final def on(ec: ExecutionContext): ZIO[R, E, A] =\n    self.lockExecutionContext(ec)\n"
  },
  {
    "id" : "5b739661-9deb-40ae-9147-44612c6e50dc",
    "prId" : 5080,
    "prUrl" : "https://github.com/zio/zio/pull/5080#pullrequestreview-660314295",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "242ba5c2-44af-4ada-a476-e004a030fef3",
        "parentId" : null,
        "authorId" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "body" : "Is this fine in `shared`?",
        "createdAt" : "2021-05-15T07:02:30Z",
        "updatedAt" : "2021-05-15T07:02:30Z",
        "lastEditedBy" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "tags" : [
        ]
      },
      {
        "id" : "ba2edd07-5774-4b0e-a05b-1455d18dfd42",
        "parentId" : "242ba5c2-44af-4ada-a476-e004a030fef3",
        "authorId" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "body" : "ah yeah looks like it https://github.com/scala-js/scala-js/blob/8a0655b2ddf3047c13d49814c4debb7f10b88931/javalanglib/src/main/scala/java/lang/Thread.scala",
        "createdAt" : "2021-05-15T07:06:36Z",
        "updatedAt" : "2021-05-15T07:06:37Z",
        "lastEditedBy" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "tags" : [
        ]
      }
    ],
    "commit" : "a134055d9260a3f10ec30d8cee6e7b21b984f0e9",
    "line" : 68,
    "diffHunk" : "@@ -1,1 +2770,2774 @@    ZIOFn.recordTrace(() => effect) {\n      ZIO.effectSuspendTotal {\n        import java.util.concurrent.atomic.AtomicReference\n        import java.util.concurrent.locks.ReentrantLock\n"
  },
  {
    "id" : "6833da17-60f0-4964-aa08-0f6737347929",
    "prId" : 4937,
    "prUrl" : "https://github.com/zio/zio/pull/4937#pullrequestreview-633713606",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8c3860c8-54b3-486e-9c04-ecb6a7155fe4",
        "parentId" : null,
        "authorId" : "304ecfba-c066-4140-afed-f4ca40d48b3f",
        "body" : "Apologies for the naive question, but why is the \"partially applied\" pattern used in this scenario? I was under the impression that it helps with type inference if the method is supposed to walk, talk and quack as though it had multiple parameter lists.",
        "createdAt" : "2021-04-10T21:29:01Z",
        "updatedAt" : "2021-04-11T00:31:57Z",
        "lastEditedBy" : "304ecfba-c066-4140-afed-f4ca40d48b3f",
        "tags" : [
        ]
      },
      {
        "id" : "237d33df-c7d5-4a8a-ad7a-75e4c460b2f6",
        "parentId" : "8c3860c8-54b3-486e-9c04-ecb6a7155fe4",
        "authorId" : "cfcc6d7b-bd8b-4cf1-994d-6e0971f0180e",
        "body" : "Hi, Adam! 😄 Ask all the questions you have!\r\n\r\nUnfortunately, one cannot _partially apply_ type parameters. We need to use this pattern if we want to be able to call this method as such:\r\n```scala\r\nZIO.serviceWith[Foo](_.foo(int))\r\n```\r\nIf it didn't use this awkward PartiallyApplied class trick, we'd have to specify the error and return types:\r\n\r\n```scala\r\nZIO.serviceWith[Foo, Nothing, Int](_.foo(int))\r\n```\r\n\r\nSo it's just a slight QOL improvement.",
        "createdAt" : "2021-04-11T00:35:49Z",
        "updatedAt" : "2021-04-11T00:36:49Z",
        "lastEditedBy" : "cfcc6d7b-bd8b-4cf1-994d-6e0971f0180e",
        "tags" : [
        ]
      },
      {
        "id" : "448e255e-285b-4c3e-b3e6-bafcea298532",
        "parentId" : "8c3860c8-54b3-486e-9c04-ecb6a7155fe4",
        "authorId" : "304ecfba-c066-4140-afed-f4ca40d48b3f",
        "body" : "Gotcha. In an alternative universe, would an alternative Scala allow something like this?\r\n```\r\ndef serviceWith[Service][E, A](f: Service => ZIO[Has[Service], E, A])\r\n```\r\nIf so, has such syntax been proposed with the keepers of Scala?",
        "createdAt" : "2021-04-11T00:47:04Z",
        "updatedAt" : "2021-04-11T00:47:04Z",
        "lastEditedBy" : "304ecfba-c066-4140-afed-f4ca40d48b3f",
        "tags" : [
        ]
      },
      {
        "id" : "d43a4bfe-0039-44a1-8651-d3d752f6f3b1",
        "parentId" : "8c3860c8-54b3-486e-9c04-ecb6a7155fe4",
        "authorId" : "8f897f9d-0efc-4372-9ef5-b638d98d7407",
        "body" : "> Gotcha. In an alternative universe, would an alternative Scala allow something like this?\r\n> \r\n> ```\r\n> def serviceWith[Service][E, A](f: Service => ZIO[Has[Service], E, A])\r\n> ```\r\n> \r\n> If so, has such syntax been proposed with the keepers of Scala?\r\n\r\nIn scala3 you have [named type arguments](https://dotty.epfl.ch/docs/reference/other-new-features/named-typeargs)\r\n\r\nIf I'm not mistaken, it should allow you to do something like:\r\n```scala\r\nZIO.serviceWith[Service = Foo](_.foo(int))\r\n```",
        "createdAt" : "2021-04-12T08:45:01Z",
        "updatedAt" : "2021-04-12T08:45:01Z",
        "lastEditedBy" : "8f897f9d-0efc-4372-9ef5-b638d98d7407",
        "tags" : [
        ]
      },
      {
        "id" : "a6e71487-7e96-4c73-8169-dd4c97bb377b",
        "parentId" : "8c3860c8-54b3-486e-9c04-ecb6a7155fe4",
        "authorId" : "cfcc6d7b-bd8b-4cf1-994d-6e0971f0180e",
        "body" : "@ivanpagano That's amazing! I had no idea.",
        "createdAt" : "2021-04-12T16:00:07Z",
        "updatedAt" : "2021-04-12T16:00:07Z",
        "lastEditedBy" : "cfcc6d7b-bd8b-4cf1-994d-6e0971f0180e",
        "tags" : [
        ]
      }
    ],
    "commit" : "45449e0a164862ff88ce7ed1569b2041c39f3a78",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +3875,3879 @@   * }}}\n   */\n  def serviceWith[Service]: ServiceWithPartiallyApplied[Service] =\n    new ServiceWithPartiallyApplied[Service]\n"
  },
  {
    "id" : "aafb345f-64ca-453e-baf0-f669faf48d97",
    "prId" : 4910,
    "prUrl" : "https://github.com/zio/zio/pull/4910#pullrequestreview-644285304",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e245fc02-db74-41c3-b57c-a3cd2cb1c053",
        "parentId" : null,
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "Did you come to a conclusion of what was going on with the early initialization issues?",
        "createdAt" : "2021-04-22T04:22:13Z",
        "updatedAt" : "2021-04-26T07:23:03Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      },
      {
        "id" : "91f40e82-2a99-4b44-951a-5dd2cd480bff",
        "parentId" : "e245fc02-db74-41c3-b57c-a3cd2cb1c053",
        "authorId" : "cfcc6d7b-bd8b-4cf1-994d-6e0971f0180e",
        "body" : "No :( Nothing beyond Scala 2.0 weirdness",
        "createdAt" : "2021-04-26T05:55:14Z",
        "updatedAt" : "2021-04-26T07:23:03Z",
        "lastEditedBy" : "cfcc6d7b-bd8b-4cf1-994d-6e0971f0180e",
        "tags" : [
        ]
      }
    ],
    "commit" : "94922c1a634a230e98f2782a78f336c91a0be2a4",
    "line" : 271,
    "diffHunk" : "@@ -1,1 +3519,3523 @@   * method.\n   */\n  lazy val interrupt: UIO[Nothing] = ZIO.fiberId.flatMap(fiberId => interruptAs(fiberId))\n\n  /**"
  },
  {
    "id" : "4c39a851-dcc6-453d-b4e0-6723a76e7a40",
    "prId" : 4818,
    "prUrl" : "https://github.com/zio/zio/pull/4818#pullrequestreview-621608953",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0efb695f-752b-4c75-9773-4c239ce0891a",
        "parentId" : null,
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "I would how we should handle a defect here? It seems like it could be useful for debugging but the full cause can be extremely long. Maybe we could just show the first cause in that case?",
        "createdAt" : "2021-03-25T04:27:36Z",
        "updatedAt" : "2021-03-25T04:27:37Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      },
      {
        "id" : "98ebed5b-fc24-4af7-9b9d-4260d6bcb669",
        "parentId" : "0efb695f-752b-4c75-9773-4c239ce0891a",
        "authorId" : "cfcc6d7b-bd8b-4cf1-994d-6e0971f0180e",
        "body" : "Something like?\r\n```scala\r\n  /**\r\n   * Taps the effect, printing the result of calling `.toString` on the value\r\n   * or the error.\r\n   */\r\n  final def debug: ZIO[R, E, A] =\r\n    self\r\n      .tapCause(cause =>\r\n        cause.find {\r\n          case Cause.Interrupt(fiberId) => s\"<INTERRUPT> by $fiberId\"\r\n          case Cause.Die(throwable)     => s\"<DIE> $throwable\"\r\n          case Cause.Fail(error)        => s\"<FAIL> $error\"\r\n        }.fold(UIO.unit) { message =>\r\n          UIO(println(message))\r\n        }\r\n      )\r\n      .tap(value => UIO(println(value)))\r\n\r\n  /**\r\n   * Taps the effect, printing the result of calling `.toString` on the value.\r\n   * Prefixes the output with the given message.\r\n   */\r\n  final def debug(prefix: => String): ZIO[R, E, A] =\r\n    self\r\n      .tapCause(cause =>\r\n        cause.find {\r\n          case Cause.Interrupt(fiberId) => s\"$prefix: <INTERRUPT> by $fiberId\"\r\n          case Cause.Die(throwable)     => s\"$prefix: <DIE> $throwable\"\r\n          case Cause.Fail(error)        => s\"$prefix: <FAIL> $error\"\r\n        }.fold(UIO.unit) { message =>\r\n          UIO(println(message))\r\n        }\r\n      )\r\n      .tap(value => UIO(println(s\"$prefix: $value\")))\r\n```",
        "createdAt" : "2021-03-25T21:50:45Z",
        "updatedAt" : "2021-03-25T21:50:46Z",
        "lastEditedBy" : "cfcc6d7b-bd8b-4cf1-994d-6e0971f0180e",
        "tags" : [
        ]
      },
      {
        "id" : "ac123691-18ad-44ec-bba3-196b9770d371",
        "parentId" : "0efb695f-752b-4c75-9773-4c239ce0891a",
        "authorId" : "cfcc6d7b-bd8b-4cf1-994d-6e0971f0180e",
        "body" : "Also, I wouldn't mind not keeping it as it is, and letting the runtime render dies.",
        "createdAt" : "2021-03-25T21:51:39Z",
        "updatedAt" : "2021-03-25T21:51:39Z",
        "lastEditedBy" : "cfcc6d7b-bd8b-4cf1-994d-6e0971f0180e",
        "tags" : [
        ]
      }
    ],
    "commit" : "3d5728830c6c3e79add286521519a387b8932472",
    "line" : 8,
    "diffHunk" : "@@ -1,1 +460,464 @@   */\n  final def debug: ZIO[R, E, A] =\n    self.tapBoth(\n      error => UIO(println(s\"<FAIL> $error\")),\n      value => UIO(println(value))"
  },
  {
    "id" : "4f30cd85-b998-41a7-a619-f81d2984d81c",
    "prId" : 4676,
    "prUrl" : "https://github.com/zio/zio/pull/4676#pullrequestreview-603428034",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "856b8c3c-3cca-4cde-a716-b6c379568429",
        "parentId" : null,
        "authorId" : "6080cd8f-e671-4d49-a54c-b6159456ac0e",
        "body" : "Super nitpick, I'd use `ZIO.unitFn`.",
        "createdAt" : "2021-03-03T22:57:19Z",
        "updatedAt" : "2021-03-03T22:58:11Z",
        "lastEditedBy" : "6080cd8f-e671-4d49-a54c-b6159456ac0e",
        "tags" : [
        ]
      }
    ],
    "commit" : "fbf4bde2427276ceda912f24e8199c15f1bfec77",
    "line" : 15,
    "diffHunk" : "@@ -1,1 +1826,1830 @@   */\n  final def tapSome[R1 <: R, E1 >: E](f: PartialFunction[A, ZIO[R1, E1, Any]]): ZIO[R1, E1, A] =\n    self.tap(f.applyOrElse(_, (_: A) => ZIO.unit))\n\n  /**"
  },
  {
    "id" : "1a72347f-9a78-4317-a8bd-433adb1d56a3",
    "prId" : 4296,
    "prUrl" : "https://github.com/zio/zio/pull/4296#pullrequestreview-504845890",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0c51da5b-7d90-4505-a89e-955b6cba193b",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "How about this:\r\n\r\n```scala\r\nscheduleWith(a)(schedule)\r\n```\r\n\r\nThen:\r\n\r\n```scala\r\ndef schedule(s) = scheduleWith(())(s)\r\n```",
        "createdAt" : "2020-10-08T13:21:47Z",
        "updatedAt" : "2020-10-08T17:35:07Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      },
      {
        "id" : "97880c71-9985-4e9a-b6fc-712574a9a2b7",
        "parentId" : "0c51da5b-7d90-4505-a89e-955b6cba193b",
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "Exactly.",
        "createdAt" : "2020-10-08T14:30:12Z",
        "updatedAt" : "2020-10-08T17:35:07Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      }
    ],
    "commit" : "57bd5c5ad84464d0f92f1dd04ac5fa8b151f9970",
    "line" : 10,
    "diffHunk" : "@@ -1,1 +1672,1676 @@   * depend on the rsult of this effect.\n   */\n  final def schedule[R1 <: R, B](schedule: Schedule[R1, Any, B]): ZIO[R1 with Clock, E, B] =\n    scheduleFrom(())(schedule)\n"
  },
  {
    "id" : "663b3279-fc0a-4bcf-a131-464b30296426",
    "prId" : 4201,
    "prUrl" : "https://github.com/zio/zio/pull/4201#pullrequestreview-487311466",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "687d85e1-5c07-4293-a63a-f3e3e4ce4091",
        "parentId" : null,
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "Would be good to have variants of this for the type alias companion objects.",
        "createdAt" : "2020-09-13T14:20:00Z",
        "updatedAt" : "2020-09-14T18:51:59Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      }
    ],
    "commit" : "61ea119bf297d33dfefd0bd4f944f969f3681e11",
    "line" : 20,
    "diffHunk" : "@@ -1,1 +3301,3305 @@   * Returns a new effect where boolean value of this effect is negated.\n   */\n  def not[R, E](effect: ZIO[R, E, Boolean]): ZIO[R, E, Boolean] =\n    effect.negate\n"
  },
  {
    "id" : "e350a040-9b63-46b3-9c96-cf9f3e728185",
    "prId" : 4142,
    "prUrl" : "https://github.com/zio/zio/pull/4142#pullrequestreview-478143886",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "63d59d78-1ab9-4b74-a6c5-4d89c59693f4",
        "parentId" : null,
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "Adding an additional field here is a binary incompatible change even though this is package private. We could potentially revert and use the previous implementation of `forkInternal` for everything except the `raceWith` implementation.",
        "createdAt" : "2020-08-29T16:39:31Z",
        "updatedAt" : "2020-09-01T17:42:45Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      },
      {
        "id" : "11461ae8-1d77-492f-823d-32a67cff1d20",
        "parentId" : "63d59d78-1ab9-4b74-a6c5-4d89c59693f4",
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "Safe to mark as an exclusion I think",
        "createdAt" : "2020-08-29T17:40:23Z",
        "updatedAt" : "2020-09-01T17:42:45Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      },
      {
        "id" : "9bc03ad4-08fe-41d4-8ac3-bf884fcd22ef",
        "parentId" : "63d59d78-1ab9-4b74-a6c5-4d89c59693f4",
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "I think so too. Will do.",
        "createdAt" : "2020-08-29T17:42:26Z",
        "updatedAt" : "2020-09-01T17:42:45Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      }
    ],
    "commit" : "540d5a1d60355c8119469616e5f4028fed503f27",
    "line" : 34,
    "diffHunk" : "@@ -1,1 +4179,4183 @@    val value: ZIO[R, E, A],\n    val scope: Option[ZScope[Exit[Any, Any]]],\n    val reportFailure: Option[Cause[Any] => Unit]\n  ) extends URIO[R, Fiber.Runtime[E, A]] {\n    override def tag = Tags.Fork"
  },
  {
    "id" : "04c63f30-16fb-41b6-8d87-cea5e49b2ac9",
    "prId" : 4115,
    "prUrl" : "https://github.com/zio/zio/pull/4115#pullrequestreview-474429481",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "593b845f-c3aa-4a03-a0e3-394de6959b72",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "These look awesome. Making ZIO \"single-thread safe\" by default is going to be amazing.",
        "createdAt" : "2020-08-25T12:28:04Z",
        "updatedAt" : "2020-08-25T16:58:51Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      }
    ],
    "commit" : "e3fac45cf9f8ec359dadc1637487ba5e1d05608b",
    "line" : 15,
    "diffHunk" : "@@ -1,1 +685,689 @@   */\n  final def forever: ZIO[R, E, Nothing] =\n    self *> ZIO.yieldNow *> forever\n\n  /**"
  },
  {
    "id" : "cae2442b-3539-43ba-8211-b701665e92d1",
    "prId" : 3994,
    "prUrl" : "https://github.com/zio/zio/pull/3994#pullrequestreview-453338084",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a06f0cfa-b762-48fc-bfc3-3a45ef3cf338",
        "parentId" : null,
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "Nothing is awaiting the `result` with this change. Is it still required?",
        "createdAt" : "2020-07-22T06:06:48Z",
        "updatedAt" : "2020-07-22T13:35:32Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      },
      {
        "id" : "92c9c2ac-d1a5-49fd-975d-c7d8cd3f1648",
        "parentId" : "a06f0cfa-b762-48fc-bfc3-3a45ef3cf338",
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "You're right. Deleted the old `result` and renamed `failureTrigger` to `result`.",
        "createdAt" : "2020-07-22T13:51:40Z",
        "updatedAt" : "2020-07-22T13:51:40Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      }
    ],
    "commit" : "f8166582d99fddb88a176cab7668b01fe9ff1a6a",
    "line" : 46,
    "diffHunk" : "@@ -1,1 +2858,2862 @@        _ <- interrupter.use_ {\n              ZIO\n                .whenM(ZIO.foreach(fibers)(_.await).map(_.exists(!_.succeeded))) {\n                  result.fail(()) *> causes.get.flatMap(ZIO.halt(_))\n                }"
  },
  {
    "id" : "8e18da55-78eb-419a-8f08-0ebae37e55f2",
    "prId" : 3976,
    "prUrl" : "https://github.com/zio/zio/pull/3976#pullrequestreview-457693452",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b548afd0-0915-4ad3-8b37-cba7c7341b59",
        "parentId" : null,
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "I realized we already have these named `doXXX` and so on. I kind of like the symmetry of `repeatXXX` and `retryXXX` but maybe it is too late for name changes. Either way we should only have one or the other.",
        "createdAt" : "2020-07-29T16:31:18Z",
        "updatedAt" : "2020-08-03T16:13:23Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      }
    ],
    "commit" : "b8e12c2ec77edc0a8c0330627c470cff962892be",
    "line" : 113,
    "diffHunk" : "@@ -1,1 +1499,1503 @@   * Repeats this effect until its error satisfies the specified predicate.\n   */\n  final def repeatUntil(f: A => Boolean): ZIO[R, E, A] =\n    repeatUntilM(a => ZIO.succeed(f(a)))\n"
  },
  {
    "id" : "9ee4fd1b-33ee-47d5-a7ce-f22ecafba25c",
    "prId" : 3750,
    "prUrl" : "https://github.com/zio/zio/pull/3750#pullrequestreview-424023616",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7babe2ae-2488-4060-8d66-f0762bcf1f53",
        "parentId" : null,
        "authorId" : "1724c5b2-b76c-4a84-8962-52e808e74b8a",
        "body" : "@adamgfraser not sure about this one, it looked better with fewer calls.",
        "createdAt" : "2020-06-03T23:40:43Z",
        "updatedAt" : "2020-06-04T23:51:07Z",
        "lastEditedBy" : "1724c5b2-b76c-4a84-8962-52e808e74b8a",
        "tags" : [
        ]
      },
      {
        "id" : "87f58793-3128-40db-8395-740c166e0abd",
        "parentId" : "7babe2ae-2488-4060-8d66-f0762bcf1f53",
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "@ahoy-jon Looks good.",
        "createdAt" : "2020-06-04T00:29:34Z",
        "updatedAt" : "2020-06-04T23:51:07Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      }
    ],
    "commit" : "e3e5de6e622c4aa0ec150bddec5ac539e714cbaf",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +1040,1044 @@   */\n  final def orDieWith(f: E => Throwable)(implicit ev: CanFail[E]): URIO[R, A] =\n    self.foldM(e => ZIO.die(f(e)), ZIO.succeedNow)\n\n  /**"
  },
  {
    "id" : "119fa1e7-9ee2-4ed7-b239-9281102174f5",
    "prId" : 3750,
    "prUrl" : "https://github.com/zio/zio/pull/3750#pullrequestreview-424910132",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5cf77abe-999e-4f21-a026-984a98acf430",
        "parentId" : null,
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "Fine to do it the other way here if you think that is more efficient.",
        "createdAt" : "2020-06-04T22:10:27Z",
        "updatedAt" : "2020-06-04T23:51:07Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      },
      {
        "id" : "e0c0e1f0-0282-4c9d-8b51-f5caee651410",
        "parentId" : "5cf77abe-999e-4f21-a026-984a98acf430",
        "authorId" : "1724c5b2-b76c-4a84-8962-52e808e74b8a",
        "body" : "Using `foldCauseM` is like taping directly into `new ZIO.Fold` so might be hard to beat that!\r\nHowever, reusing existing combinators improves the discovery of those!",
        "createdAt" : "2020-06-04T23:47:59Z",
        "updatedAt" : "2020-06-04T23:51:07Z",
        "lastEditedBy" : "1724c5b2-b76c-4a84-8962-52e808e74b8a",
        "tags" : [
        ]
      }
    ],
    "commit" : "e3e5de6e622c4aa0ec150bddec5ac539e714cbaf",
    "line" : 27,
    "diffHunk" : "@@ -1,1 +1051,1055 @@   */\n  final def resurrect(implicit ev1: E <:< Throwable): RIO[R, A] =\n    self.unrefineWith({ case e => e })(ev1)\n\n  /**"
  },
  {
    "id" : "0162e5f9-27e2-4ce2-95a7-95b2141aea37",
    "prId" : 3530,
    "prUrl" : "https://github.com/zio/zio/pull/3530#pullrequestreview-406218617",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c3f3bc53-0088-48ed-884b-1869cb1a3f87",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "We discovered you can \"Inline\" this annotation to avoid the need for a new `CanFilter` class.",
        "createdAt" : "2020-05-05T12:39:14Z",
        "updatedAt" : "2020-06-04T07:10:31Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      },
      {
        "id" : "b4808212-96b0-456b-bcf1-abe058645e66",
        "parentId" : "c3f3bc53-0088-48ed-884b-1869cb1a3f87",
        "authorId" : "b07fe5ec-3ba6-4df5-b718-27aef96bd2ea",
        "body" : "Like that?\r\n```\r\nobject Evidences {\r\n  @implicitNotFound(\"provideCustomLayer expect all layers except those provided by ZIO (ZEnv) instead it got $R1. If you intend to provide some of layers only then use provideSomeLayer instead\")\r\n  type ProvideCustomLayer[-R1, +R] = ZEnv with R1 <:< R\r\n}\r\n```",
        "createdAt" : "2020-05-05T13:07:27Z",
        "updatedAt" : "2020-06-04T07:10:31Z",
        "lastEditedBy" : "b07fe5ec-3ba6-4df5-b718-27aef96bd2ea",
        "tags" : [
        ]
      },
      {
        "id" : "29ce15ae-1b11-48d4-bea0-b158619607ee",
        "parentId" : "c3f3bc53-0088-48ed-884b-1869cb1a3f87",
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "Even more! Inline where the function is:\r\n\r\n```scala\r\n@implicitNotFound(\"\") implicit ev: ...\r\n```\r\n\r\nTry that!",
        "createdAt" : "2020-05-05T14:08:40Z",
        "updatedAt" : "2020-06-04T07:10:31Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      },
      {
        "id" : "69f73440-2ad5-4518-aa2e-d53b5d16b620",
        "parentId" : "c3f3bc53-0088-48ed-884b-1869cb1a3f87",
        "authorId" : "fe8c0309-9574-4c2c-a95a-2f54e9bd5411",
        "body" : "Note that this applies to 2.13+ only (which may be fine anyway)",
        "createdAt" : "2020-05-05T17:13:52Z",
        "updatedAt" : "2020-06-04T07:10:31Z",
        "lastEditedBy" : "fe8c0309-9574-4c2c-a95a-2f54e9bd5411",
        "tags" : [
        ]
      },
      {
        "id" : "f4cbd4c7-e10f-4e32-a20c-8d124989b816",
        "parentId" : "c3f3bc53-0088-48ed-884b-1869cb1a3f87",
        "authorId" : "b07fe5ec-3ba6-4df5-b718-27aef96bd2ea",
        "body" : "Yeah, I tried it and it doesn't work on default scala version. \r\nIs there any runtime overhead? If no - I'd go with a bulky solution.\r\nIf yes - we can put extensions in version-specific directories",
        "createdAt" : "2020-05-05T18:08:43Z",
        "updatedAt" : "2020-06-04T07:10:31Z",
        "lastEditedBy" : "b07fe5ec-3ba6-4df5-b718-27aef96bd2ea",
        "tags" : [
        ]
      },
      {
        "id" : "a4f93bfa-b438-48eb-9db0-411f5514b166",
        "parentId" : "c3f3bc53-0088-48ed-884b-1869cb1a3f87",
        "authorId" : "b07fe5ec-3ba6-4df5-b718-27aef96bd2ea",
        "body" : "@jdegoes @neko-kai I made implementation version-specific. Have no idea what I'm doing but it compiles!",
        "createdAt" : "2020-05-05T23:16:21Z",
        "updatedAt" : "2020-06-04T07:10:31Z",
        "lastEditedBy" : "b07fe5ec-3ba6-4df5-b718-27aef96bd2ea",
        "tags" : [
        ]
      }
    ],
    "commit" : "2c732f49da9d01fb36bae6e86f25c8080c45d288",
    "line" : 12,
    "diffHunk" : "@@ -1,1 +3695,3699 @@  }\n\n  @implicitNotFound(\n    \"Pattern guards are only supported when the error type is a supertype of NoSuchElementException. However, your effect has ${E} for the error type.\"\n  )"
  },
  {
    "id" : "a67ce1e2-5c75-46b1-a746-b05e2ed1970f",
    "prId" : 3510,
    "prUrl" : "https://github.com/zio/zio/pull/3510#pullrequestreview-408663784",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "790aa3a1-6c55-4f3a-896f-a4b3a29c91c4",
        "parentId" : null,
        "authorId" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "body" : "Perhaps worth mentioning that `f` must be commutative and associative?",
        "createdAt" : "2020-05-09T08:20:59Z",
        "updatedAt" : "2020-05-09T19:03:22Z",
        "lastEditedBy" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "tags" : [
        ]
      },
      {
        "id" : "96a148b5-f601-49e6-bc08-12166a0849c8",
        "parentId" : "790aa3a1-6c55-4f3a-896f-a4b3a29c91c4",
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "Yes 👍 ",
        "createdAt" : "2020-05-09T16:16:11Z",
        "updatedAt" : "2020-05-09T19:03:22Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      }
    ],
    "commit" : "6f5d0b97fd3ea7ab30a7846653e09688cc672071",
    "line" : 60,
    "diffHunk" : "@@ -1,1 +3232,3236 @@\n  /**\n   * Reduces an `Iterable[IO]` to a single `IO`, working in up to `n` fibers in parallel.\n   */\n  def reduceAllParN[R, R1 <: R, E, A](n: Int)(a: ZIO[R, E, A], as: Iterable[ZIO[R1, E, A]])("
  },
  {
    "id" : "2eb15775-58ef-4bb5-ac6d-a998c026462f",
    "prId" : 3241,
    "prUrl" : "https://github.com/zio/zio/pull/3241#pullrequestreview-386075702",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d776897c-aaeb-4947-a96e-5c88efd4a64c",
        "parentId" : null,
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "We should eventually add variants for `foreachParN` and `collectAllParN` as well as aliases in the companion objects.",
        "createdAt" : "2020-03-31T17:55:41Z",
        "updatedAt" : "2020-04-05T14:05:28Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      },
      {
        "id" : "7772b5bc-8036-4ab4-9319-f66dabef40a0",
        "parentId" : "d776897c-aaeb-4947-a96e-5c88efd4a64c",
        "authorId" : "1724c5b2-b76c-4a84-8962-52e808e74b8a",
        "body" : "To be sure, do you mean moving to `object Chunk`?\r\n\r\n",
        "createdAt" : "2020-03-31T21:04:02Z",
        "updatedAt" : "2020-04-05T14:05:28Z",
        "lastEditedBy" : "1724c5b2-b76c-4a84-8962-52e808e74b8a",
        "tags" : [
        ]
      },
      {
        "id" : "ab46ece1-c6e4-41a8-8c29-69ef9696a9fd",
        "parentId" : "d776897c-aaeb-4947-a96e-5c88efd4a64c",
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "No. In `ZIO.scala` there are `foreachParN` variants and `collectAllParN` variants. So we should implement versions for `NonEmptyChunk` in that file. Then all of these methods are aliased in `UIO.scala`, `URIO.scala`, `Task.scala`, etc...",
        "createdAt" : "2020-04-01T00:11:54Z",
        "updatedAt" : "2020-04-05T14:05:28Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      },
      {
        "id" : "1bd38d75-d282-4a65-a7f3-24a4665081c5",
        "parentId" : "d776897c-aaeb-4947-a96e-5c88efd4a64c",
        "authorId" : "1724c5b2-b76c-4a84-8962-52e808e74b8a",
        "body" : "ok, I see, they don't exist yet for `Chunk[A]`:\r\n```scala\r\nscala> ZIO.foreachParN(5)(Chunk())\r\n<console>:25: error: type mismatch;\r\n found   : zio.Chunk[Nothing]\r\n required: Iterable[?]\r\n       ZIO.foreachParN(5)(Chunk())\r\n```\r\n\r\nI will add both versions of them.",
        "createdAt" : "2020-04-01T03:24:10Z",
        "updatedAt" : "2020-04-05T14:05:28Z",
        "lastEditedBy" : "1724c5b2-b76c-4a84-8962-52e808e74b8a",
        "tags" : [
        ]
      },
      {
        "id" : "0250f438-1567-476b-a17e-810cdffbcba2",
        "parentId" : "d776897c-aaeb-4947-a96e-5c88efd4a64c",
        "authorId" : "1724c5b2-b76c-4a84-8962-52e808e74b8a",
        "body" : "I did the alias for all the methods in UIO, Task, ..., ...\r\n\r\nFor `foreachParN` on Chunk and NonEmpty that will go in another PR.",
        "createdAt" : "2020-04-02T02:37:37Z",
        "updatedAt" : "2020-04-05T14:05:28Z",
        "lastEditedBy" : "1724c5b2-b76c-4a84-8962-52e808e74b8a",
        "tags" : [
        ]
      },
      {
        "id" : "dcd87ecb-71bf-4a88-8f38-886491c5fae2",
        "parentId" : "d776897c-aaeb-4947-a96e-5c88efd4a64c",
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "Agreed.",
        "createdAt" : "2020-04-02T02:49:10Z",
        "updatedAt" : "2020-04-05T14:05:28Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      }
    ],
    "commit" : "636dde1f75b61da49bb21be2b721534817bc2454",
    "line" : 39,
    "diffHunk" : "@@ -1,1 +2526,2530 @@   * If you do not need the results, see `foreach_` for a more efficient implementation.\n   */\n  final def foreach[R, E, A, B](in: NonEmptyChunk[A])(f: A => ZIO[R, E, B]): ZIO[R, E, NonEmptyChunk[B]] =\n    in.mapM(f)\n"
  },
  {
    "id" : "d2622d85-2a5a-4c5b-9336-d781722133ea",
    "prId" : 3125,
    "prUrl" : "https://github.com/zio/zio/pull/3125#pullrequestreview-379007532",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "44794e1d-c576-4083-9986-9f42ebcfdec4",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "```suggestion\r\n    /**\r\n     * Returns a new effect that, if the parent region is uninterruptible, can be interrupted in the background\r\n     * instantaneously. If the parent region is interruptible, then the effect can be interrupted normally,\r\n     * in the foreground.\r\n     */\r\n    def force[R, E, A](zio: ZIO[R, E, A]): ZIO[R, E, A] =\r\n```",
        "createdAt" : "2020-03-22T13:55:37Z",
        "updatedAt" : "2020-03-22T14:05:59Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      }
    ],
    "commit" : "971762cd889b876f459cfe69ea97c5356810f64e",
    "line" : 50,
    "diffHunk" : "@@ -1,1 +3298,3302 @@     * foreground.\n     */\n    def force[R, E, A](zio: ZIO[R, E, A]): ZIO[R, E, A] =\n      if (flag == InterruptStatus.Uninterruptible) zio.uninterruptible.disconnect.interruptible\n      else zio.interruptStatus(flag)"
  },
  {
    "id" : "7420b206-6607-4219-9873-7f07c424db94",
    "prId" : 3086,
    "prUrl" : "https://github.com/zio/zio/pull/3086#pullrequestreview-372047194",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d182688f-f34b-4a63-8e4a-2188ee95cb94",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "```suggestion\r\n\r\n   * '''WARNING''': There is no sensible way to recover from defects. This method should be used only at the boundary between ZIO and an external system, to transmit information on a defect for diagnostic or explanatory purposes.\r\n```\r\n\r\nHere and below.",
        "createdAt" : "2020-03-10T13:51:37Z",
        "updatedAt" : "2020-03-10T15:12:02Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      },
      {
        "id" : "844172fe-fba8-4e85-8dfe-e9f0e5d07fac",
        "parentId" : "d182688f-f34b-4a63-8e4a-2188ee95cb94",
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "Done.",
        "createdAt" : "2020-03-10T15:12:27Z",
        "updatedAt" : "2020-03-10T15:12:27Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      }
    ],
    "commit" : "dc139df051c15566d7e0b08718db9b59964a1d79",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +322,326 @@  /**\n   * Recovers from all defects with provided function.\n   *\n   * {{{\n   * effect.catchSomeDefect(_ => backup())"
  },
  {
    "id" : "40ca4fce-8b73-4ce6-841a-f7f93e9c2607",
    "prId" : 2883,
    "prUrl" : "https://github.com/zio/zio/pull/2883#pullrequestreview-359130977",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1f2d826d-14f8-47c5-bf31-9099df002ab5",
        "parentId" : null,
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "Good catch!",
        "createdAt" : "2020-02-14T18:21:11Z",
        "updatedAt" : "2020-02-17T08:29:38Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      }
    ],
    "commit" : "437a9ea0bec3c47f94ac6c4bbe24395595d55e10",
    "line" : 61,
    "diffHunk" : "@@ -1,1 +1383,1387 @@   * Retries this effect while its error satisfies the specified predicate.\n   */\n  final def retryWhile(f: E => Boolean)(implicit ev: CanFail[E]): ZIO[R, E, A] =\n    retry(Schedule.doWhile(f))\n"
  },
  {
    "id" : "d8c4c91f-b45d-4df7-99ba-c4a4ef402b70",
    "prId" : 2883,
    "prUrl" : "https://github.com/zio/zio/pull/2883#pullrequestreview-359130977",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "63137a51-8a25-4211-b831-715fdb7ff3f7",
        "parentId" : null,
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "You need to change the parameter to `Schedule.doWhileEquals` to be by name if you want this to actually be lazy.",
        "createdAt" : "2020-02-14T18:22:06Z",
        "updatedAt" : "2020-02-17T08:29:38Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      }
    ],
    "commit" : "437a9ea0bec3c47f94ac6c4bbe24395595d55e10",
    "line" : 68,
    "diffHunk" : "@@ -1,1 +1390,1394 @@   */\n  final def retryWhileEquals[E1 >: E](e: => E1)(implicit ev: CanFail[E1]): ZIO[R, E1, A] =\n    retry(Schedule.doWhileEquals(e))\n\n  /**"
  },
  {
    "id" : "4e5fba5d-2506-4935-a9fb-f5e13cb8723c",
    "prId" : 2883,
    "prUrl" : "https://github.com/zio/zio/pull/2883#pullrequestreview-359130977",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "becc2990-43b7-4f68-89d6-a130ee7f81b9",
        "parentId" : null,
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "Same comment as below regarding `Schedule.doUntilEquals`.",
        "createdAt" : "2020-02-14T18:22:56Z",
        "updatedAt" : "2020-02-17T08:29:38Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      }
    ],
    "commit" : "437a9ea0bec3c47f94ac6c4bbe24395595d55e10",
    "line" : 49,
    "diffHunk" : "@@ -1,1 +1372,1376 @@   */\n  final def retryUntilEquals[E1 >: E](e: => E1)(implicit ev: CanFail[E1]): ZIO[R, E1, A] =\n    retry(Schedule.doUntilEquals(e))\n\n  /**"
  },
  {
    "id" : "05f1485b-34d6-49b6-bc87-7188ee9308b1",
    "prId" : 2883,
    "prUrl" : "https://github.com/zio/zio/pull/2883#pullrequestreview-359130977",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b7ee6d5f-93df-49dc-9f15-fa0024ea14c1",
        "parentId" : null,
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "Nice!",
        "createdAt" : "2020-02-14T18:23:07Z",
        "updatedAt" : "2020-02-17T08:29:38Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      }
    ],
    "commit" : "437a9ea0bec3c47f94ac6c4bbe24395595d55e10",
    "line" : 42,
    "diffHunk" : "@@ -1,1 +1365,1369 @@   * Retries this effect until its error satisfies the specified predicate.\n   */\n  final def retryUntil(f: E => Boolean)(implicit ev: CanFail[E]): ZIO[R, E, A] =\n    retry(Schedule.doUntil(f))\n"
  },
  {
    "id" : "1eeef906-b051-4540-a1dc-e3c2720e83b8",
    "prId" : 2883,
    "prUrl" : "https://github.com/zio/zio/pull/2883#pullrequestreview-359267018",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a1ae94db-2133-4dd3-9d1b-5b652a7c715e",
        "parentId" : null,
        "authorId" : "6080cd8f-e671-4d49-a54c-b6159456ac0e",
        "body" : "~~I believe you can omit the type bound here.~~ Also, as Adam pointed out, `doUntilEquals` accepts parameter by value.",
        "createdAt" : "2020-02-14T23:03:13Z",
        "updatedAt" : "2020-02-17T08:29:38Z",
        "lastEditedBy" : "6080cd8f-e671-4d49-a54c-b6159456ac0e",
        "tags" : [
        ]
      },
      {
        "id" : "0ca830ca-6957-462a-805d-3f179d009049",
        "parentId" : "a1ae94db-2133-4dd3-9d1b-5b652a7c715e",
        "authorId" : "6080cd8f-e671-4d49-a54c-b6159456ac0e",
        "body" : "Ah, scratch it, forgot about the variance. Laziness it is :).",
        "createdAt" : "2020-02-14T23:06:19Z",
        "updatedAt" : "2020-02-17T08:29:38Z",
        "lastEditedBy" : "6080cd8f-e671-4d49-a54c-b6159456ac0e",
        "tags" : [
        ]
      }
    ],
    "commit" : "437a9ea0bec3c47f94ac6c4bbe24395595d55e10",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +381,385 @@   * Repeats this effect until its result is equal to the predicate.\n   */\n  final def doUntilEquals[A1 >: A](a: => A1): ZIO[R, E, A1] =\n    repeat(Schedule.doUntilEquals(a))\n"
  },
  {
    "id" : "d277293e-4113-4cb6-b341-df2d17af2a1c",
    "prId" : 2849,
    "prUrl" : "https://github.com/zio/zio/pull/2849#pullrequestreview-355546554",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9100b38b-f305-4740-b85d-001737dcf5fe",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "For ZIO, this can be slightly faster: you can do `foldCause` which involves no wrapping.",
        "createdAt" : "2020-02-08T12:51:29Z",
        "updatedAt" : "2020-02-08T15:16:32Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      }
    ],
    "commit" : "7ae7c3041149ced28f21561084286e420abf952c",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +671,675 @@   * Returns a new effect that ignores the success or failure of this effect.\n   */\n  final def ignore: URIO[R, Unit] = self.fold(ZIO.unitFn, ZIO.unitFn)\n\n  /**"
  },
  {
    "id" : "2d2649eb-517d-4101-8085-e293b6dea65e",
    "prId" : 2800,
    "prUrl" : "https://github.com/zio/zio/pull/2800#pullrequestreview-353229602",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e6e214b8-f62f-46d0-8ed0-5b0e68a14def",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "If this works well, would be nice to add to the usual suspects (`Spec`, `ZManaged`, `ZStream`).",
        "createdAt" : "2020-02-04T18:48:38Z",
        "updatedAt" : "2020-02-06T06:07:55Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      },
      {
        "id" : "a1b8f662-edee-433e-89e7-7a43e7fe1646",
        "parentId" : "e6e214b8-f62f-46d0-8ed0-5b0e68a14def",
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "Yes I agree. One other thing that might be worth thinking about is our nomenclature for `provide` methods. I think we could potentially implement a similar mechanic for, say providing a managed, by converting the managed to a layer and calling `provideSomeLayer`, with the appropriate implicit evidence. So we could conceptually have three varieties of \"provide\", (1) provide the whole environment, (2) providing part of the environment by providing something that goes from a part to the whole environment (e.g. existing `provideSome`), and (3) providing part of the environment and leaving the remainder (e.g. new `provideSomeLayer`. And you could have variants for each different data type being provided. Maybe `provideSome` could be use for (3) and we find another name for (2)? Or do you think this should exclusively be a mechanic for layers?",
        "createdAt" : "2020-02-04T19:00:01Z",
        "updatedAt" : "2020-02-06T06:07:55Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      },
      {
        "id" : "51350f02-617d-41f7-88a5-604f483ca2a5",
        "parentId" : "e6e214b8-f62f-46d0-8ed0-5b0e68a14def",
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "I do think it's worth rethinking this right now, before RC18.\r\n\r\nOne could even get away from `provide` for ZLayer, favoring maybe:\r\n\r\n - `interpret` / `interpretSome` (\"interpret from one layer to another\")\r\n - `translate` / `translate` (\"translate from one layer to another\")\r\n - `shift` / `shiftSome` (\"shift from one layer to another\")\r\n\r\nOr we could continue running with `provide` and just try to emphasize the primacy of ZLayer.\r\n\r\nNow providing method to convert `ZManaged` into a `ZLayer` sounds good and could let us delete the `*Managed` variants without too much fuss.",
        "createdAt" : "2020-02-04T19:10:32Z",
        "updatedAt" : "2020-02-06T06:07:55Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      }
    ],
    "commit" : "97f5e5a5257c8d086659ca80943cbd728c4998d9",
    "line" : 16,
    "diffHunk" : "@@ -1,1 +977,981 @@   * }}}\n   */\n  final def provideSomeLayer[R0 <: Has[_]]: ZIO.ProvideSomeLayer[R0, R, E, A] =\n    new ZIO.ProvideSomeLayer[R0, R, E, A](self)\n"
  },
  {
    "id" : "ca464665-15cf-421e-8936-3ef4b8f8dc1b",
    "prId" : 2800,
    "prUrl" : "https://github.com/zio/zio/pull/2800#pullrequestreview-355115487",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2148f0a8-9c23-47ae-a30c-c97169773746",
        "parentId" : null,
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "`provideOne` can be trivially implemented in terms of `provideSomeLayer` now. It isn't being used anywhere. We should either delete if we want layers to be the sole means of doing this or move up to the top level with new naming convention.",
        "createdAt" : "2020-02-06T06:35:58Z",
        "updatedAt" : "2020-02-06T06:35:59Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      },
      {
        "id" : "2f13a774-43fc-4e0b-bfd1-d8d418dfce53",
        "parentId" : "2148f0a8-9c23-47ae-a30c-c97169773746",
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "Agreed, let's delete it.",
        "createdAt" : "2020-02-07T12:11:20Z",
        "updatedAt" : "2020-02-07T12:11:20Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      }
    ],
    "commit" : "97f5e5a5257c8d086659ca80943cbd728c4998d9",
    "line" : 23,
    "diffHunk" : "@@ -1,1 +3283,3287 @@  class ProvideOne[R1](r1: R1) {\n    def apply[R2 <: Has[_], E, A](zio: ZIO[Has[R1] with R2, E, A])(implicit R1: Tagged[R1]): ZIO[R2, E, A] =\n      zio.provideSome[R2](r2 => r2.add(r1))\n  }\n"
  },
  {
    "id" : "194ac8dc-67b0-42c2-ab19-4a301e6cdd11",
    "prId" : 2774,
    "prUrl" : "https://github.com/zio/zio/pull/2774#pullrequestreview-351836213",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ad8e7df8-3ead-4d9b-96eb-7f84e7d15fcf",
        "parentId" : null,
        "authorId" : "a603d67d-c027-4b04-8bb5-d78c0c594d8d",
        "body" : "Just out of curiosity — why is this pattern used vs. inlining `IfM.apply?`",
        "createdAt" : "2020-01-31T23:39:09Z",
        "updatedAt" : "2020-01-31T23:39:09Z",
        "lastEditedBy" : "a603d67d-c027-4b04-8bb5-d78c0c594d8d",
        "tags" : [
        ]
      },
      {
        "id" : "85d67758-7f70-48cd-b117-7ea3a1356199",
        "parentId" : "ad8e7df8-3ead-4d9b-96eb-7f84e7d15fcf",
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "For improved type inference. If we don't do this then the compiler will fix the type parameters based on the first parameter list in a curried function. So if the `b` effect was something like `ref.get` the compiler would infer `R` as `Any` and `E` as `Nothing`. Then if our actual `onTrue` and `onFalse` effects required some environment or could fail the compiler would complain and we would have to manually specify type parameters and then people would be sad.",
        "createdAt" : "2020-01-31T23:41:18Z",
        "updatedAt" : "2020-01-31T23:41:19Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      }
    ],
    "commit" : "985309130ab8ff3edb7511edb81ee48f45f78706",
    "line" : 8,
    "diffHunk" : "@@ -1,1 +2564,2568 @@   */\n  def ifM[R, E](b: ZIO[R, E, Boolean]): ZIO.IfM[R, E] =\n    new ZIO.IfM(b)\n\n  /**"
  },
  {
    "id" : "02eb634d-5e36-4292-9d02-0a145918dcd8",
    "prId" : 2770,
    "prUrl" : "https://github.com/zio/zio/pull/2770#pullrequestreview-351413831",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5dc84eb5-b3ab-42ba-8441-358643a998c5",
        "parentId" : null,
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "The semantics here currently are \"execute at most once\", since errors / interruption will leave the flag set but `self` was not necessarily performed. Maybe we should use `bracketExit` here?\r\n\r\nAlso, it'd be nice to make this return the value `A` and allow for a fallback value/effect when the ref is already set. This is the prevalent pattern in ZStream.",
        "createdAt" : "2020-01-31T07:29:35Z",
        "updatedAt" : "2020-02-21T03:33:51Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      },
      {
        "id" : "a3ba9360-96d4-475b-8c2d-1ebf7f3efef0",
        "parentId" : "5dc84eb5-b3ab-42ba-8441-358643a998c5",
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "I'm not sure what the right semantics are here. My original intention was \"guarantee that this effect will only begin execution once\" so you could pass the effect around and get the same semantics as if you only evaluated it once (and it potentially was interrupted or failed). Resetting the flag raises the possibility that the \"work\" will be done multiple times if there are failures or the effect is interrupted after doing significant work. We could definitely generalize by allowing the caller to provide a `Exit[E, A] => Boolean` function and a default value, thought it does complicate the method signature.",
        "createdAt" : "2020-01-31T10:15:19Z",
        "updatedAt" : "2020-02-21T03:33:51Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      },
      {
        "id" : "88c662d6-c96f-4b3e-9ab2-1aca8b050ae7",
        "parentId" : "5dc84eb5-b3ab-42ba-8441-358643a998c5",
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "`onceWith/M` sounds like a great variant :-)",
        "createdAt" : "2020-01-31T10:26:37Z",
        "updatedAt" : "2020-02-21T03:33:51Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      }
    ],
    "commit" : "3ba752fc8f0d0c7604e00c4d20f8727571d3c6ae",
    "line" : 9,
    "diffHunk" : "@@ -1,1 +781,785 @@   */\n  final def once: UIO[ZIO[R, E, Unit]] =\n    Ref.make(true).map(ref => self.whenM(ref.getAndSet(false)))\n\n  /**"
  },
  {
    "id" : "a6cd5acc-28ef-4386-8bc6-e7599d6468bd",
    "prId" : 2748,
    "prUrl" : "https://github.com/zio/zio/pull/2748#pullrequestreview-366840746",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3e3a958f-642f-4aed-ba21-00a00d69d570",
        "parentId" : null,
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "Goodbye fiber leaks!",
        "createdAt" : "2020-03-01T07:45:44Z",
        "updatedAt" : "2020-03-01T18:33:37Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      }
    ],
    "commit" : "8106319c9c2a9300eb1dd1aec0aeee42c9b2f451",
    "line" : 214,
    "diffHunk" : "@@ -1,1 +713,717 @@   * }}}\n   */\n  final def fork: URIO[R, Fiber.Runtime[E, A]] = fork(SuperviseMode.Interrupt)\n\n  /**"
  },
  {
    "id" : "deaa421f-53a3-48d6-ba41-0b3130c9a229",
    "prId" : 2748,
    "prUrl" : "https://github.com/zio/zio/pull/2748#pullrequestreview-366840746",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b6c579de-f1a3-4834-9f68-14fdb336f010",
        "parentId" : null,
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "👍🏻",
        "createdAt" : "2020-03-01T07:46:01Z",
        "updatedAt" : "2020-03-01T18:33:37Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      }
    ],
    "commit" : "8106319c9c2a9300eb1dd1aec0aeee42c9b2f451",
    "line" : 198,
    "diffHunk" : "@@ -1,1 +697,701 @@   * Returns an effect that forks this effect into its own separate fiber,\n   * returning the fiber immediately, without waiting for it to begin\n   * executing the effect.\n   *\n   * The returned fiber can be used to interrupt the forked fiber, await its"
  },
  {
    "id" : "c8869637-ebd7-49d7-837a-707528faf474",
    "prId" : 2723,
    "prUrl" : "https://github.com/zio/zio/pull/2723#pullrequestreview-348372196",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "56f7277e-065b-4da8-838f-dfeceb45a786",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "❤️  Beautiful.",
        "createdAt" : "2020-01-26T11:06:28Z",
        "updatedAt" : "2020-01-26T12:40:42Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      }
    ],
    "commit" : "c1a5f1c226720e269306ab1090b6cde677c480ec",
    "line" : 20,
    "diffHunk" : "@@ -1,1 +2692,2696 @@    in: Iterable[A]\n  )(f: A => ZIO[R, E, B])(implicit ev: CanFail[E]): ZIO[R, Nothing, (List[E], List[B])] =\n    ZIO.foreach(in)(f(_).either).map(partitionMap(_)(ZIO.identityFn))\n\n  /**"
  },
  {
    "id" : "c063cd2c-e5f5-4619-96c3-42774a0d2098",
    "prId" : 2635,
    "prUrl" : "https://github.com/zio/zio/pull/2635#pullrequestreview-343829378",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "824a26bc-8d0c-41c7-8152-af82e7382068",
        "parentId" : null,
        "authorId" : "c9b92c27-ac07-4362-92e2-eae234a7ecf4",
        "body" : "Is it better to avoid unnecessary allocations and just deal with null?\r\n\r\n```scala\r\nmergeAllPar(all)(null) { (acc, elem) =>\r\n  if (acc eq null) elem else f(acc, elem)\r\n}\r\n```",
        "createdAt" : "2020-01-16T05:37:59Z",
        "updatedAt" : "2020-01-16T09:08:55Z",
        "lastEditedBy" : "c9b92c27-ac07-4362-92e2-eae234a7ecf4",
        "tags" : [
        ]
      },
      {
        "id" : "13edfb56-501f-4b6e-9fdb-abe13517b386",
        "parentId" : "824a26bc-8d0c-41c7-8152-af82e7382068",
        "authorId" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "body" : "It looks a lot like `mergeAllPar(as)(a)(f)` 🤔",
        "createdAt" : "2020-01-16T07:15:55Z",
        "updatedAt" : "2020-01-16T09:08:55Z",
        "lastEditedBy" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "tags" : [
        ]
      },
      {
        "id" : "7ae86f2b-5359-4eea-a2d0-0390d5324915",
        "parentId" : "824a26bc-8d0c-41c7-8152-af82e7382068",
        "authorId" : "c9b92c27-ac07-4362-92e2-eae234a7ecf4",
        "body" : "If we pass `a` as a second argument, then `f` should be of type `(ZIO[R, E, A], A) => ZIO[R, E, A]`. So, doesn't match.",
        "createdAt" : "2020-01-16T07:51:12Z",
        "updatedAt" : "2020-01-16T09:08:55Z",
        "lastEditedBy" : "c9b92c27-ac07-4362-92e2-eae234a7ecf4",
        "tags" : [
        ]
      },
      {
        "id" : "42be5239-05fe-4e92-b82b-2e43a26499b1",
        "parentId" : "824a26bc-8d0c-41c7-8152-af82e7382068",
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "The allocation overhead is probably minuscule compared to the concurrency overhead, so I wouldn't bother with working with `null` here.",
        "createdAt" : "2020-01-16T07:57:44Z",
        "updatedAt" : "2020-01-16T09:08:55Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      },
      {
        "id" : "27831f20-a169-4077-acb0-f5d426339eb2",
        "parentId" : "824a26bc-8d0c-41c7-8152-af82e7382068",
        "authorId" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "body" : "Sure, I was just questioning the using of `Option`, is all.\r\n```scala\r\na.flatMap(mergeAllPar(as)(_)(f))\r\n```\r\nperhaps?",
        "createdAt" : "2020-01-16T08:38:26Z",
        "updatedAt" : "2020-01-16T09:08:55Z",
        "lastEditedBy" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "tags" : [
        ]
      },
      {
        "id" : "a1cf5935-a0c8-43d2-9153-09fd1bff14ec",
        "parentId" : "824a26bc-8d0c-41c7-8152-af82e7382068",
        "authorId" : "c9b92c27-ac07-4362-92e2-eae234a7ecf4",
        "body" : "Then `a` isn't run in parallel with `as`. :(",
        "createdAt" : "2020-01-16T09:24:38Z",
        "updatedAt" : "2020-01-16T09:24:38Z",
        "lastEditedBy" : "c9b92c27-ac07-4362-92e2-eae234a7ecf4",
        "tags" : [
        ]
      },
      {
        "id" : "6d1c34c2-fca7-45ec-80ab-b4cd85161bf8",
        "parentId" : "824a26bc-8d0c-41c7-8152-af82e7382068",
        "authorId" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "body" : "Fair enough, that's too bad but hey the numbers are awesome!",
        "createdAt" : "2020-01-16T10:57:32Z",
        "updatedAt" : "2020-01-16T10:57:32Z",
        "lastEditedBy" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "tags" : [
        ]
      },
      {
        "id" : "285064a0-6d15-458a-ac51-4c1abd5c0cb3",
        "parentId" : "824a26bc-8d0c-41c7-8152-af82e7382068",
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "Yes, I think unfortunately we need this. We could use `zipWithPar` to execute the `a` in parallel but then we don't have a zero value for the merge operation.",
        "createdAt" : "2020-01-16T10:57:51Z",
        "updatedAt" : "2020-01-16T10:57:52Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      }
    ],
    "commit" : "36471c25bdcfb5431b2299088ab04055e9b1da26",
    "line" : 17,
    "diffHunk" : "@@ -1,1 +2740,2744 @@    mergeAllPar(all)(Option.empty[A]) { (acc, elem) =>\n      Some(acc.fold(elem)(f(_, elem)))\n    }.map(_.get)\n  }\n"
  },
  {
    "id" : "cb8c0558-e5fc-427e-af82-d8915141c2fa",
    "prId" : 2635,
    "prUrl" : "https://github.com/zio/zio/pull/2635#pullrequestreview-344099142",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a20b1eb5-fb1e-4b3d-89ab-b925df229325",
        "parentId" : null,
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "```suggestion\r\n    }.flatMap(_.fold(a)(UIO.succeed))\r\n```",
        "createdAt" : "2020-01-16T08:01:01Z",
        "updatedAt" : "2020-01-16T09:08:55Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      },
      {
        "id" : "7d085a83-4448-4b74-85e8-341777ddb735",
        "parentId" : "a20b1eb5-fb1e-4b3d-89ab-b925df229325",
        "authorId" : "c9b92c27-ac07-4362-92e2-eae234a7ecf4",
        "body" : "If we ever make a bug in this code, then such `flatMap` will silently execute `a` effect twice. Are we sure it's better to rush for purity in this case?",
        "createdAt" : "2020-01-16T09:04:43Z",
        "updatedAt" : "2020-01-16T09:08:55Z",
        "lastEditedBy" : "c9b92c27-ac07-4362-92e2-eae234a7ecf4",
        "tags" : [
        ]
      },
      {
        "id" : "6ef62309-43b6-4994-8118-b7c5b180377e",
        "parentId" : "a20b1eb5-fb1e-4b3d-89ab-b925df229325",
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "It does seem like it is an internal error of ZIO if `get` fails so I would be inclined to leave it as is.",
        "createdAt" : "2020-01-16T11:01:38Z",
        "updatedAt" : "2020-01-16T11:01:39Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      },
      {
        "id" : "454f752a-f068-4c11-9664-2d356918fdb4",
        "parentId" : "a20b1eb5-fb1e-4b3d-89ab-b925df229325",
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "@iravid Are you good with this?",
        "createdAt" : "2020-01-16T17:46:21Z",
        "updatedAt" : "2020-01-16T17:46:21Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      }
    ],
    "commit" : "36471c25bdcfb5431b2299088ab04055e9b1da26",
    "line" : 17,
    "diffHunk" : "@@ -1,1 +2740,2744 @@    mergeAllPar(all)(Option.empty[A]) { (acc, elem) =>\n      Some(acc.fold(elem)(f(_, elem)))\n    }.map(_.get)\n  }\n"
  },
  {
    "id" : "67f26b7e-e561-46f3-9229-575849346796",
    "prId" : 2590,
    "prUrl" : "https://github.com/zio/zio/pull/2590#pullrequestreview-341261636",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d2d86359-ba60-4a47-aefb-bf76f6033607",
        "parentId" : null,
        "authorId" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "body" : "It looks like you could avoid the `foldLeft` just by making `loop` tail recursive:\r\n```scala\r\n@tailrec def loop(it: Iterator[A], acc: ZIO[R, E, Any]): ZIO[R, E, Any] =\r\n  if (it.hasNext)\r\n    loop(it, acc <&> f(it.next))\r\n  else\r\n    acc\r\n\r\nloop(i, ZIO.unit).unit\r\n```",
        "createdAt" : "2020-01-10T08:54:30Z",
        "updatedAt" : "2020-01-10T08:56:53Z",
        "lastEditedBy" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "tags" : [
        ]
      },
      {
        "id" : "936532fc-e7c9-4c8e-9d2a-efba0800c838",
        "parentId" : "d2d86359-ba60-4a47-aefb-bf76f6033607",
        "authorId" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "body" : "woops, small mistake, I corrected.",
        "createdAt" : "2020-01-10T08:56:50Z",
        "updatedAt" : "2020-01-10T08:56:50Z",
        "lastEditedBy" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "tags" : [
        ]
      },
      {
        "id" : "d99b7182-53b8-4047-92c8-158537a1fe23",
        "parentId" : "d2d86359-ba60-4a47-aefb-bf76f6033607",
        "authorId" : "c9b92c27-ac07-4362-92e2-eae234a7ecf4",
        "body" : "In my opinion, version with `foldLeft` is a lot simpler. Also, consiming one more stack frame doesn't seem like a big deal.\r\n\r\nWhy should we avoid `foldLeft` here?",
        "createdAt" : "2020-01-10T10:05:46Z",
        "updatedAt" : "2020-01-10T10:05:46Z",
        "lastEditedBy" : "c9b92c27-ac07-4362-92e2-eae234a7ecf4",
        "tags" : [
        ]
      },
      {
        "id" : "f0ec28ef-0fc8-44fc-a3cd-d4c736d9bb55",
        "parentId" : "d2d86359-ba60-4a47-aefb-bf76f6033607",
        "authorId" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "body" : "I may be wrong but `foldLeft` will box primitive types no matter what, whereas using a while loop won't.",
        "createdAt" : "2020-01-10T10:31:29Z",
        "updatedAt" : "2020-01-10T10:31:29Z",
        "lastEditedBy" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "tags" : [
        ]
      },
      {
        "id" : "0ab764e8-866f-4b42-86eb-c3c8846fadda",
        "parentId" : "d2d86359-ba60-4a47-aefb-bf76f6033607",
        "authorId" : "c9b92c27-ac07-4362-92e2-eae234a7ecf4",
        "body" : "Usually, they will be already boxed anyway inside `as: Iterable[A]`. So, `foldLeft` shouldn't do any boxing again in that case, at the first glance.",
        "createdAt" : "2020-01-10T16:05:18Z",
        "updatedAt" : "2020-01-10T16:05:18Z",
        "lastEditedBy" : "c9b92c27-ac07-4362-92e2-eae234a7ecf4",
        "tags" : [
        ]
      }
    ],
    "commit" : "6dce4af8fa724e3103a3d73e69de897ba6a0e26c",
    "line" : 12,
    "diffHunk" : "@@ -1,1 +2233,2237 @@   */\n  def foreachPar_[R, E, A](as: Iterable[A])(f: A => ZIO[R, E, Any]): ZIO[R, E, Unit] =\n    as.foldLeft(unit: ZIO[R, E, Unit]) { (acc, a) =>\n        acc.zipParLeft(f(a))\n      }"
  },
  {
    "id" : "865ca955-2453-4a9c-8b7d-63ef21afced4",
    "prId" : 2555,
    "prUrl" : "https://github.com/zio/zio/pull/2555#pullrequestreview-337545099",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8a77fc04-fa27-4fbd-b946-058d1bbd4309",
        "parentId" : null,
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "Beautiful!",
        "createdAt" : "2020-01-02T06:51:42Z",
        "updatedAt" : "2020-01-02T06:56:20Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      }
    ],
    "commit" : "2bc09956428f238a617081341250421abc9d182d",
    "line" : 34,
    "diffHunk" : "@@ -1,1 +2891,2895 @@    in: Iterable[A]\n  )(f: A => ZIO[R, E, B])(implicit ev: CanFail[E]): ZIO[R, List[E], B] =\n    ZIO.foreachPar(in)(f(_).flip).flip\n\n  /**"
  },
  {
    "id" : "12c30d2f-00da-4e82-bf86-ebf47b0525b1",
    "prId" : 2492,
    "prUrl" : "https://github.com/zio/zio/pull/2492#pullrequestreview-343775425",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "387f054c-bd6c-4e26-960c-2cc69bb5e07d",
        "parentId" : null,
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "@horned-sphere If every fiber is operating in its own index, why do you need an ARA here?",
        "createdAt" : "2020-01-15T07:05:03Z",
        "updatedAt" : "2020-01-15T17:56:03Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      },
      {
        "id" : "6009d699-83ca-4186-8eb6-3271d1a14ff8",
        "parentId" : "387f054c-bd6c-4e26-960c-2cc69bb5e07d",
        "authorId" : "2303f9be-956c-47b2-b012-9f9dffa4f637",
        "body" : "@iravid The issue isn't with the paralell sets, it's with the sets followed by the gets at the end. As @evis points out above, the Java memory model doesn't guarantee that these writes will be observable to the following reads.\r\n\r\nIdeally what I would do is have an array of volatile references, however the JVM only allows for volatile references to arrays. The only ways to perform volatile sets/gets on an array in Java are an atomic array or a VarHandle (JVM >= 9). The ARA is used for volatility not atomicity.\r\n\r\nI don't think this would ever be a problem on x86 but on an architecture with weak memory consistency (like arm for example) it would be required",
        "createdAt" : "2020-01-15T09:13:34Z",
        "updatedAt" : "2020-01-15T17:56:03Z",
        "lastEditedBy" : "2303f9be-956c-47b2-b012-9f9dffa4f637",
        "tags" : [
        ]
      },
      {
        "id" : "2dd59eee-cc46-4bef-ab07-8054d12ce8a5",
        "parentId" : "387f054c-bd6c-4e26-960c-2cc69bb5e07d",
        "authorId" : "2303f9be-956c-47b2-b012-9f9dffa4f637",
        "body" : "I've left it as it is for now unless someone has a convincing argument for that reasoning being wrong :).",
        "createdAt" : "2020-01-15T18:02:16Z",
        "updatedAt" : "2020-01-15T18:02:16Z",
        "lastEditedBy" : "2303f9be-956c-47b2-b012-9f9dffa4f637",
        "tags" : [
        ]
      },
      {
        "id" : "eb70f75c-5392-40e7-befd-4d4a9ecba579",
        "parentId" : "387f054c-bd6c-4e26-960c-2cc69bb5e07d",
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "I think that we are okay without the `AtomicReferenceArray` because we have already completed the `foreachPar_` effect which involves a `Ref` and ` Promise` for coordination so I think by the time we evaluate the continuation we can rely on the effects in `foreachPar_` being completed and visible.",
        "createdAt" : "2020-01-16T02:25:21Z",
        "updatedAt" : "2020-01-16T02:51:37Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      },
      {
        "id" : "ff6e3b65-5e98-4f0e-ac52-69b87df7af15",
        "parentId" : "387f054c-bd6c-4e26-960c-2cc69bb5e07d",
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "@adamgfraser I think they checked that against the Java memory model spec and concluded there's no visibility guarantee on that when writing from multiple threads.\r\n\r\nI agree it's probably good for 99% of the cases, but the overhead of the parallelism here dominates the overhead of writing to the array so this precaution probably does not considerably affect performance.",
        "createdAt" : "2020-01-16T07:38:48Z",
        "updatedAt" : "2020-01-16T07:38:48Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      },
      {
        "id" : "3321408d-6edf-447c-9b4e-8a073d182946",
        "parentId" : "387f054c-bd6c-4e26-960c-2cc69bb5e07d",
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "@iravid Sounds good.",
        "createdAt" : "2020-01-16T09:30:52Z",
        "updatedAt" : "2020-01-16T09:30:52Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      }
    ],
    "commit" : "33d276bd8429ab8b414ee51bf8ca5276e04b1624",
    "line" : 18,
    "diffHunk" : "@@ -1,1 +2236,2240 @@  final def foreachPar[R, E, A, B](as: Iterable[A])(fn: A => ZIO[R, E, B]): ZIO[R, E, List[B]] = {\n    val size      = as.size\n    val resultArr = new AtomicReferenceArray[B](size)\n\n    val wrappedFn: ZIOFn1[(A, Int), ZIO[R, E, Any]] = ZIOFn(fn) {"
  },
  {
    "id" : "9240ac72-46ab-42c4-9c6f-2c7820eec2d7",
    "prId" : 2492,
    "prUrl" : "https://github.com/zio/zio/pull/2492#pullrequestreview-343786528",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a030a9a6-c8e2-429f-8464-9a95d251377e",
        "parentId" : null,
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "Do we need the `toStream` call here?",
        "createdAt" : "2020-01-16T02:33:05Z",
        "updatedAt" : "2020-01-16T02:51:37Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      },
      {
        "id" : "f74ea8f9-aeb5-4af6-bee4-3c3e2f069146",
        "parentId" : "a030a9a6-c8e2-429f-8464-9a95d251377e",
        "authorId" : "2303f9be-956c-47b2-b012-9f9dffa4f637",
        "body" : "This is in response to a review by @vasilmkd way back up at the top with regards to minimizing traversals of the iterable. I originally resolved it by doing a foldLeft, however after reimplementing foreachPar in terms of foreachPar_ this was no longer possible so I replaced it by converting the interable to a stream (the stream just wraps an iterator so isn't especially expensive). I'm not opposed to getting rid of it.",
        "createdAt" : "2020-01-16T09:15:29Z",
        "updatedAt" : "2020-01-16T09:15:29Z",
        "lastEditedBy" : "2303f9be-956c-47b2-b012-9f9dffa4f637",
        "tags" : [
        ]
      },
      {
        "id" : "660561f2-6c34-4d3f-884e-42e6fc5c9bfc",
        "parentId" : "a030a9a6-c8e2-429f-8464-9a95d251377e",
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "Got it. The cost of any of this is probably dwarfed by everything else we're doing so fine either way. We could use `iterator` here potentially.",
        "createdAt" : "2020-01-16T09:48:21Z",
        "updatedAt" : "2020-01-16T09:48:21Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      }
    ],
    "commit" : "33d276bd8429ab8b414ee51bf8ca5276e04b1624",
    "line" : 24,
    "diffHunk" : "@@ -1,1 +2242,2246 @@    }\n\n    foreachPar_(as.toStream.zipWithIndex)(wrappedFn).as(\n      (0 until size).reverse.foldLeft[List[B]](Nil) { (acc, i) =>\n        resultArr.get(i) :: acc"
  },
  {
    "id" : "c7dc8bdf-101f-4138-b750-bfc1b131f141",
    "prId" : 2492,
    "prUrl" : "https://github.com/zio/zio/pull/2492#pullrequestreview-343776914",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "362ac648-ffd0-4a86-87da-7afd094add79",
        "parentId" : null,
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "Could become `toList` it we change the array to an ordinary `Array`.",
        "createdAt" : "2020-01-16T02:33:52Z",
        "updatedAt" : "2020-01-16T02:51:37Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      },
      {
        "id" : "342f6b4c-64dd-4058-b67e-5ca479c49f79",
        "parentId" : "362ac648-ffd0-4a86-87da-7afd094add79",
        "authorId" : "2303f9be-956c-47b2-b012-9f9dffa4f637",
        "body" : "Yes, that's what I did in the original array based implementation (although it requires a nasty casy from Array[Any] to Array[B] as we don't have a ClassTag in the signature).",
        "createdAt" : "2020-01-16T09:17:53Z",
        "updatedAt" : "2020-01-16T09:17:53Z",
        "lastEditedBy" : "2303f9be-956c-47b2-b012-9f9dffa4f637",
        "tags" : [
        ]
      },
      {
        "id" : "df3d2e3e-e979-44ea-9204-62dfe5ce01ec",
        "parentId" : "362ac648-ffd0-4a86-87da-7afd094add79",
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "Yes.",
        "createdAt" : "2020-01-16T09:33:06Z",
        "updatedAt" : "2020-01-16T09:33:06Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      }
    ],
    "commit" : "33d276bd8429ab8b414ee51bf8ca5276e04b1624",
    "line" : 25,
    "diffHunk" : "@@ -1,1 +2243,2247 @@\n    foreachPar_(as.toStream.zipWithIndex)(wrappedFn).as(\n      (0 until size).reverse.foldLeft[List[B]](Nil) { (acc, i) =>\n        resultArr.get(i) :: acc\n      }"
  },
  {
    "id" : "16abac33-68a3-4a16-9d81-be8bbef2b37a",
    "prId" : 2492,
    "prUrl" : "https://github.com/zio/zio/pull/2492#pullrequestreview-343792466",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0bce42c2-4bcb-4ded-b92f-0c3bf0f5c414",
        "parentId" : null,
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "What do we gain by using a `Managed` here? It looks like we are converting it to a `Managed` without a release action and then we immediately use it so seems like we could use a simpler combinator. ",
        "createdAt" : "2020-01-16T02:40:31Z",
        "updatedAt" : "2020-01-16T02:51:37Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      },
      {
        "id" : "c97bac20-94c1-423f-8fb5-47cb174e04e2",
        "parentId" : "0bce42c2-4bcb-4ded-b92f-0c3bf0f5c414",
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "He's forking the `Managed` to get a guarantee on interruption of the fiber when `use_` is done below",
        "createdAt" : "2020-01-16T07:34:37Z",
        "updatedAt" : "2020-01-16T07:34:37Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      },
      {
        "id" : "5c22f742-547f-4297-939c-5c90890adaf3",
        "parentId" : "0bce42c2-4bcb-4ded-b92f-0c3bf0f5c414",
        "authorId" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "body" : "This is a pattern I've seen elsewhere in the codebase.",
        "createdAt" : "2020-01-16T09:22:59Z",
        "updatedAt" : "2020-01-16T09:23:00Z",
        "lastEditedBy" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "tags" : [
        ]
      },
      {
        "id" : "972cd0eb-a223-4cfa-ba70-1d43ac63236f",
        "parentId" : "0bce42c2-4bcb-4ded-b92f-0c3bf0f5c414",
        "authorId" : "2303f9be-956c-47b2-b012-9f9dffa4f637",
        "body" : "Yes, that is the reason. I introudced this due to a problem I had, early on, when running the benchmark. When the interruption fiber was unbounded, in some proportion of executions it would outlive the fiber running foreachPar in the benchmark. Through some chain of events this led to the interruption fiber being added to Fiber._rootFibers (and not removed). Over the many, many executions in the benchmark that set became huge and the performance took a huge hit. To solve this I decided I wanted a guarantee that the helper fibers could not outlive the execution of the combinator and managing the fiber seemed to be the best way to express that intention.\r\n\r\nThat no longer seems to happen (I'm guessing there have bene improvements to the fiber lifetime management in the interim) however the principal that the fiber should be guarnateed to not outlive the combinator seems to be good in general. In this case, I think it should be safe to replace that with just joining the fiber rather than using the managed so I can replace it with that.\r\n\r\nApologies for the long winded explanation.",
        "createdAt" : "2020-01-16T09:26:05Z",
        "updatedAt" : "2020-01-16T09:26:05Z",
        "lastEditedBy" : "2303f9be-956c-47b2-b012-9f9dffa4f637",
        "tags" : [
        ]
      },
      {
        "id" : "5495f3e8-d707-4590-8f92-eac007e5955b",
        "parentId" : "0bce42c2-4bcb-4ded-b92f-0c3bf0f5c414",
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "Got it, thanks!",
        "createdAt" : "2020-01-16T09:37:07Z",
        "updatedAt" : "2020-01-16T09:37:08Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      },
      {
        "id" : "450603b4-efac-4816-ab4e-824e80a6323d",
        "parentId" : "0bce42c2-4bcb-4ded-b92f-0c3bf0f5c414",
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "Couldn't this be simplified by removing the `toManaged` and replacing `use_` with `bracket_` in the line below with `ZIO.unit` as the release action? Or even doing `uninterruptible` instead of `toManaged` and then `*>` instead of `use_` on the line below? I may be missing something but how does a managed without a release action provide us stronger guarantees about the lifetime of the fiber?",
        "createdAt" : "2020-01-16T09:43:20Z",
        "updatedAt" : "2020-01-16T09:43:20Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      },
      {
        "id" : "45022866-e563-4018-a155-e09204140f7a",
        "parentId" : "0bce42c2-4bcb-4ded-b92f-0c3bf0f5c414",
        "authorId" : "2303f9be-956c-47b2-b012-9f9dffa4f637",
        "body" : "The realease action is added by the call to .fork on the next line (this is forking the managed rather than an effect).",
        "createdAt" : "2020-01-16T09:47:30Z",
        "updatedAt" : "2020-01-16T09:47:31Z",
        "lastEditedBy" : "2303f9be-956c-47b2-b012-9f9dffa4f637",
        "tags" : [
        ]
      },
      {
        "id" : "b1200856-e964-4d4d-9d64-32b5d07b12c5",
        "parentId" : "0bce42c2-4bcb-4ded-b92f-0c3bf0f5c414",
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "Ah, got it.",
        "createdAt" : "2020-01-16T09:51:53Z",
        "updatedAt" : "2020-01-16T09:51:53Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      },
      {
        "id" : "204f2a9b-029b-4a3a-8ffd-10f4dee5ddde",
        "parentId" : "0bce42c2-4bcb-4ded-b92f-0c3bf0f5c414",
        "authorId" : "2303f9be-956c-47b2-b012-9f9dffa4f637",
        "body" : "I could make that more explicit by constructing the managed fiber myself rather than doing .use_.fork (or just get rid of the managed block entirely and join the fiber as mentioned above). I _think_ that if the inner effect completes the interrupter thread is guarnateed to complete eventually too so it should be equivalent.",
        "createdAt" : "2020-01-16T09:53:27Z",
        "updatedAt" : "2020-01-16T09:53:27Z",
        "lastEditedBy" : "2303f9be-956c-47b2-b012-9f9dffa4f637",
        "tags" : [
        ]
      },
      {
        "id" : "2a44f932-02d1-49e8-a7bc-578d0c0d6e3b",
        "parentId" : "0bce42c2-4bcb-4ded-b92f-0c3bf0f5c414",
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "No I think it is fine. I didn't realize that `Managed#fork` added that logic though it makes sense. I thought we could rely on the fiber being garbage collected when it terminates without having to explicitly interrupt it but it sounds like that wasn't the case at least recently.",
        "createdAt" : "2020-01-16T09:57:19Z",
        "updatedAt" : "2020-01-16T09:57:20Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      }
    ],
    "commit" : "33d276bd8429ab8b414ee51bf8ca5276e04b1624",
    "line" : 65,
    "diffHunk" : "@@ -1,1 +2285,2289 @@        interrupter = result.await\n          .catchAll(_ => ZIO.foreach(fibers)(_.interruptAs(parentId).fork) >>= Fiber.joinAll)\n          .toManaged_\n          .fork\n        _ <- interrupter.use_(result.await.foldM(_ => causes.get >>= ZIO.halt, _ => ZIO.unit).refailWithTrace)"
  },
  {
    "id" : "74b629c0-74d2-4259-861e-5f585a3057e7",
    "prId" : 2487,
    "prUrl" : "https://github.com/zio/zio/pull/2487#pullrequestreview-333496259",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "751cfeae-0a18-46a0-989e-55ebcc54e56d",
        "parentId" : null,
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "I think we want to implement this more directly in terms of existing combinators:\r\n\r\n```scala\r\nfinal def partitionMPar[R, E, A, B](\r\n  in: Iterable[A]\r\n)(f: A => ZIO[R, E, B])(implicit ev: CanFail[E]): ZIO[R, Nothing, (List[E], List[B])] =\r\n  ZIO\r\n    .foreachPar(in)(f(_).either)\r\n    .map(_.foldRight((List.empty[E], List.empty[B])) {\r\n      case (Left(e), (es, bs))  => (e :: es, bs)\r\n      case (Right(b), (es, bs)) => (es, b :: bs)\r\n    })\r\n\r\n```\r\n\r\nI know we went with a slightly different implementation for `partitionM` to avoid the extra allocations but the cost of that is going to be dwarfed by the additional machinery of the queue and promises here.",
        "createdAt" : "2019-12-17T18:12:39Z",
        "updatedAt" : "2019-12-19T16:35:21Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      },
      {
        "id" : "737b0e33-2c08-4ece-bad0-c5facef25e43",
        "parentId" : "751cfeae-0a18-46a0-989e-55ebcc54e56d",
        "authorId" : "de0bc6c7-e62a-427d-8426-7cca7227a8f1",
        "body" : "I had the same issue again. I forgot there is the either combinator.... gosh my approach was over-engineered for nothing. XD Before taking the promise / queue approach I was looking for a combinator that would give me either an A or E in the success channel but was not bright enough to think it would be either. Facepalm",
        "createdAt" : "2019-12-17T18:43:35Z",
        "updatedAt" : "2019-12-19T16:35:21Z",
        "lastEditedBy" : "de0bc6c7-e62a-427d-8426-7cca7227a8f1",
        "tags" : [
        ]
      }
    ],
    "commit" : "f71d9408969aeb8621d95d1f7eaeda48e66e371c",
    "line" : 18,
    "diffHunk" : "@@ -1,1 +2474,2478 @@   *\n   */\n  final def partitionMPar[R, E, A, B](\n    in: Iterable[A]\n  )(f: A => ZIO[R, E, B])(implicit ev: CanFail[E]): ZIO[R, Nothing, (List[E], List[B])] ="
  },
  {
    "id" : "25e92032-f7ac-4074-a522-8221adedea95",
    "prId" : 2483,
    "prUrl" : "https://github.com/zio/zio/pull/2483#pullrequestreview-333271208",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d628d7db-bc0b-483a-ab48-baf50bdf0a71",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "I'd make sure this one has a `ZIO.interruptibleFork` variant for symmetry with `ZIO.interruptible`.",
        "createdAt" : "2019-12-17T13:04:03Z",
        "updatedAt" : "2019-12-18T18:10:40Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      },
      {
        "id" : "37be7400-724b-4313-981c-b9fc33ccd9dd",
        "parentId" : "d628d7db-bc0b-483a-ab48-baf50bdf0a71",
        "authorId" : "b1aff51e-d900-4aaa-bb80-5307cca96485",
        "body" : "do you mean add a `ZIO.interruptibleForkMask` ? (The prefix form of `ZIO#interruptibleFork` is on line 2450)",
        "createdAt" : "2019-12-17T13:27:36Z",
        "updatedAt" : "2019-12-18T18:10:40Z",
        "lastEditedBy" : "b1aff51e-d900-4aaa-bb80-5307cca96485",
        "tags" : [
        ]
      }
    ],
    "commit" : "7f3fc31bc167eb0ea40a27297c6711e2e0d2dfbe",
    "line" : 74,
    "diffHunk" : "@@ -1,1 +645,649 @@   * However, the effect and its interruption occurs in a forked fiber\n   */\n  final def interruptibleFork: ZIO[R, E, A] =\n    ZIO.uninterruptible {\n      for {"
  },
  {
    "id" : "e6e2b2c9-b1bf-4d61-a23c-5e6406c6babe",
    "prId" : 2453,
    "prUrl" : "https://github.com/zio/zio/pull/2453#pullrequestreview-332241577",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6f39bd8a-e876-4030-a45e-9f425bb28ec6",
        "parentId" : null,
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "Nice addition!",
        "createdAt" : "2019-12-15T03:34:28Z",
        "updatedAt" : "2019-12-16T15:28:28Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      }
    ],
    "commit" : "fd7ca24aa8de3db4a219e2d3bb48b39507328c05",
    "line" : 16,
    "diffHunk" : "@@ -1,1 +2053,2057 @@   * Folds an Iterable[A] using an effectual function f, working sequentially from right to left.\n   */\n  final def foldRight[R, E, S, A](\n    in: Iterable[A]\n  )(zero: S)(f: (A, S) => ZIO[R, E, S]): ZIO[R, E, S] ="
  },
  {
    "id" : "bc6b4a55-8e7a-437a-865e-9782cff4276b",
    "prId" : 2449,
    "prUrl" : "https://github.com/zio/zio/pull/2449#pullrequestreview-329726679",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2aa298f0-aa88-4666-ba06-c1e1ea579f29",
        "parentId" : null,
        "authorId" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "body" : "`catchAll(_ => ZIO.succeed(a))`",
        "createdAt" : "2019-12-09T10:03:29Z",
        "updatedAt" : "2019-12-09T16:19:22Z",
        "lastEditedBy" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "tags" : [
        ]
      },
      {
        "id" : "e49da057-4ee6-4eec-a9fc-b75ccfaf2e6e",
        "parentId" : "2aa298f0-aa88-4666-ba06-c1e1ea579f29",
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "I'm not sure this is better if we need to wrap the result in an additional effect constructor. ",
        "createdAt" : "2019-12-09T16:52:42Z",
        "updatedAt" : "2019-12-09T16:52:42Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      },
      {
        "id" : "5811f329-a5bf-425f-a528-dcd65f1e0b9c",
        "parentId" : "2aa298f0-aa88-4666-ba06-c1e1ea579f29",
        "authorId" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "body" : "There’s no difference in that regard, one additional indirection  in `fold` in fact. But it’s a shame it’s longer, perhaps there should have been a `catchAllM` too.",
        "createdAt" : "2019-12-10T06:30:30Z",
        "updatedAt" : "2019-12-10T06:31:00Z",
        "lastEditedBy" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "tags" : [
        ]
      },
      {
        "id" : "1e5f69d8-47da-4503-b7d5-a1083accfe6c",
        "parentId" : "2aa298f0-aa88-4666-ba06-c1e1ea579f29",
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "You're right. Aren't they the the same though? Both are implemented in terms of `foldM` and have to wrap the success or failure in an effect constructor. `fold` does both of them internally whereas `catchAll` only does the success case itself and then we would need to wrap the failure case in an effect constructor here.",
        "createdAt" : "2019-12-10T09:15:11Z",
        "updatedAt" : "2019-12-10T09:15:11Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      },
      {
        "id" : "29da54b9-b874-4e95-bc00-9463b0eb7dfd",
        "parentId" : "2aa298f0-aa88-4666-ba06-c1e1ea579f29",
        "authorId" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "body" : "Yep, they are. You must be getting tired of hearing this, but: awesome work 😅 ",
        "createdAt" : "2019-12-10T09:25:08Z",
        "updatedAt" : "2019-12-10T09:25:08Z",
        "lastEditedBy" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "tags" : [
        ]
      },
      {
        "id" : "4ff6d6b9-4af9-429e-aeae-552a5a0bca7b",
        "parentId" : "2aa298f0-aa88-4666-ba06-c1e1ea579f29",
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "Thanks! Lot of people including you doing awesome work on this project! Just trying to contribute and learn. 😃 ",
        "createdAt" : "2019-12-10T10:21:26Z",
        "updatedAt" : "2019-12-10T10:21:27Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      }
    ],
    "commit" : "63aac6beb5ff771857cf11f70bdfce40ed159456",
    "line" : 9,
    "diffHunk" : "@@ -1,1 +378,382 @@   */\n  final def fallback[A1 >: A](a: => A1)(implicit ev: CanFail[E]): ZIO[R, Nothing, A1] =\n    fold(_ => a, identity)\n\n  /**"
  },
  {
    "id" : "771f763b-df54-4a37-a092-2b89187e93fd",
    "prId" : 2423,
    "prUrl" : "https://github.com/zio/zio/pull/2423#pullrequestreview-328478463",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c056f802-ba1d-45f0-bb87-405032d7fdb4",
        "parentId" : null,
        "authorId" : "05793de5-8cbe-49ba-90b1-8ef51f2dd854",
        "body" : "It's better to use AtomicBooleanFieldUpdater",
        "createdAt" : "2019-12-06T21:53:45Z",
        "updatedAt" : "2019-12-06T21:53:45Z",
        "lastEditedBy" : "05793de5-8cbe-49ba-90b1-8ef51f2dd854",
        "tags" : [
        ]
      }
    ],
    "commit" : "d99914407394451410bf2a162dcd92a1e11def85",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +2244,2248 @@    Task.descriptorWith { d =>\n      val ec          = d.executor.asEC\n      val interrupted = new java.util.concurrent.atomic.AtomicBoolean(false)\n      val latch       = scala.concurrent.Promise[Unit]()\n      val interruptibleEC = new scala.concurrent.ExecutionContext {"
  },
  {
    "id" : "8053cd0c-c2bf-4c27-bcc8-a9f55ec47666",
    "prId" : 2399,
    "prUrl" : "https://github.com/zio/zio/pull/2399#pullrequestreview-326283704",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "53a43964-af3f-43ac-a131-497494902c41",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "Clever. Could be more widely used",
        "createdAt" : "2019-12-03T16:38:35Z",
        "updatedAt" : "2019-12-03T16:55:42Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      }
    ],
    "commit" : "c497bdb2ed5eb481202045f8500cacf68cf474cb",
    "line" : 16,
    "diffHunk" : "@@ -1,1 +2747,2751 @@  final class BracketAcquire[-R, +E, +A](private val acquire: ZIO[R, E, A]) extends AnyVal {\n    def apply[R1](release: A => URIO[R1, Any]): BracketRelease[R with R1, E, A] =\n      new BracketRelease[R with R1, E, A](acquire, release)\n  }\n  final class BracketRelease[-R, +E, +A](acquire: ZIO[R, E, A], release: A => URIO[R, Any]) {"
  },
  {
    "id" : "89dd5de6-3e67-443f-8580-fbeaae3a5051",
    "prId" : 2361,
    "prUrl" : "https://github.com/zio/zio/pull/2361#pullrequestreview-324863996",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "63144c79-c0df-4b70-9f86-fec450dd095a",
        "parentId" : null,
        "authorId" : "fe8c0309-9574-4c2c-a95a-2f54e9bd5411",
        "body" : "@adamgfraser \r\nHmm, I thought the idea was to move the implicit classes on tuples to the companion object? That way they will be picked up without a wildcard import, because conversions are searched also for type parameters and ZIO is present as a type parameter of tuple/Iterable.",
        "createdAt" : "2019-11-29T15:54:03Z",
        "updatedAt" : "2019-11-30T08:07:41Z",
        "lastEditedBy" : "fe8c0309-9574-4c2c-a95a-2f54e9bd5411",
        "tags" : [
        ]
      },
      {
        "id" : "cef2e89e-3c17-4dca-aa07-54a17057a0cf",
        "parentId" : "63144c79-c0df-4b70-9f86-fec450dd095a",
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "@neko-kai Sorry I misunderstood you. We could definitely do that, or potentially both variants.\r\n\r\nMy thinking was that the problem we're trying to solve here is providing a way for users to combine multiple effects. I thought this was better provided through a concrete method on the companion object that doesn't require any implicits. If I have:\r\n\r\n```scala\r\nval zio1: ZIO[R, E, A] = ???\r\nval zio2: ZIO[R, E, B] = ???\r\nval zio3: ZIO[R, E, C] = ???\r\nval zio4: ZIO[R, E, D] = ???\r\nval f: (A, B, C, D) => E = ???\r\n```\r\n\r\nIt seems slightly more natural to do:\r\n\r\n```scala\r\nZIO.mapN(zio1, zio2, zio3, zio4)(f)\r\n```\r\n\r\nthan:\r\n\r\n```scala\r\n(zio1, zio2, zio3, zio4).mapN(f)\r\n```\r\n\r\nBoth of them are concise and read well but the first is probably more easily discoverable just being a normal method on an object instead of implicit syntax.\r\n\r\nWhere the new signature is not as convenient is where you already have a tuple of effects, because then you need to destructure the tuple to feed to `mapN`, but I'm not sure how common that is.\r\n\r\nI'm happy to do either but that why I thought this was the better solution.",
        "createdAt" : "2019-11-29T17:16:18Z",
        "updatedAt" : "2019-11-30T08:07:41Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      },
      {
        "id" : "d0626cf2-384f-46d9-94d4-eee42843224b",
        "parentId" : "63144c79-c0df-4b70-9f86-fec450dd095a",
        "authorId" : "fe8c0309-9574-4c2c-a95a-2f54e9bd5411",
        "body" : "@adamgfraser \r\nI'm fine either way (or both!), just checking if that's intentional. Note though, that plain methods are not equivalent in cases with chaining or variables e.g. ```io.flatMap(_.mapN { ... }))``` – Scala has auto-tupling, but no auto-untupling and I believe `ZIO.mapN.tupled(_) { ... }` will probably not work due to direction of type inference.",
        "createdAt" : "2019-11-29T17:42:54Z",
        "updatedAt" : "2019-11-30T08:07:41Z",
        "lastEditedBy" : "fe8c0309-9574-4c2c-a95a-2f54e9bd5411",
        "tags" : [
        ]
      },
      {
        "id" : "0de5b94c-c7af-4988-a674-343237b34d40",
        "parentId" : "63144c79-c0df-4b70-9f86-fec450dd095a",
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "I like `ZIO.mapN` more as it's obvious where to find it. It's not obvious we add methods to tuples. I've never really liked that style.\r\n\r\nI do think `io.flatMap(_.mapN(...))` working only with the syntax is a good point, though. Although in practice it only occurs where an effect produces a tuple. The most obvious candidates for tuple production would be `zip` and `zipPar`, but if we added `ZIO.zipN`, and `ZIO.zipParN`, then suddenly tuple creation doesn't become common anymore, which lessens the argument for it.\r\n\r\n🤷‍♂ ",
        "createdAt" : "2019-11-29T22:37:14Z",
        "updatedAt" : "2019-11-30T08:07:41Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      }
    ],
    "commit" : "7b455076a06e13d9b3821ca0a02f1bd20bcbe98e",
    "line" : 8,
    "diffHunk" : "@@ -1,1 +2338,2342 @@   * function.\n   */\n  final def mapN[R, E, A, B, C](zio1: ZIO[R, E, A], zio2: ZIO[R, E, B])(f: (A, B) => C): ZIO[R, E, C] =\n    zio1.zipWith(zio2)(f)\n"
  },
  {
    "id" : "0f1c4e6d-725b-4aff-b05f-e41a215e122a",
    "prId" : 2360,
    "prUrl" : "https://github.com/zio/zio/pull/2360#pullrequestreview-324448912",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "17200c7d-d2d4-400c-af2d-f27aa79cb2d9",
        "parentId" : null,
        "authorId" : "fe8c0309-9574-4c2c-a95a-2f54e9bd5411",
        "body" : "Is the implicit class necessary? Does\r\n```scala\r\nfinal def refineToOrDie[E1 <: E: ClassTag](implicit ev1: E <:< Throwable, ev2: CanFail[E]): ZIO[R, E1, A] =\r\n```\r\nbehave differently?",
        "createdAt" : "2019-11-28T16:54:46Z",
        "updatedAt" : "2019-11-28T16:54:47Z",
        "lastEditedBy" : "fe8c0309-9574-4c2c-a95a-2f54e9bd5411",
        "tags" : [
        ]
      },
      {
        "id" : "a459b050-d28e-4939-9003-c83af99bdb99",
        "parentId" : "17200c7d-d2d4-400c-af2d-f27aa79cb2d9",
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "That won't compile because the covariant `E` appears in contravariant position in the type bound, which is why we need the implicit class.",
        "createdAt" : "2019-11-28T17:07:40Z",
        "updatedAt" : "2019-11-28T17:07:41Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      },
      {
        "id" : "39c73395-fa6b-4402-85ab-d10c15dfc836",
        "parentId" : "17200c7d-d2d4-400c-af2d-f27aa79cb2d9",
        "authorId" : "fe8c0309-9574-4c2c-a95a-2f54e9bd5411",
        "body" : "Got it!",
        "createdAt" : "2019-11-28T20:21:23Z",
        "updatedAt" : "2019-11-28T20:21:23Z",
        "lastEditedBy" : "fe8c0309-9574-4c2c-a95a-2f54e9bd5411",
        "tags" : [
        ]
      }
    ],
    "commit" : "84e6476b39ae89c18f013a3b12bc574a1a3d2fc0",
    "line" : 22,
    "diffHunk" : "@@ -1,1 +2644,2648 @@     * Keeps some of the errors, and terminates the fiber with the rest.\n     */\n    final def refineToOrDie[E1 <: E: ClassTag](implicit ev: CanFail[E]): ZIO[R, E1, A] =\n      self.refineOrDie { case e: E1 => e }\n  }"
  },
  {
    "id" : "6db54600-87f3-477c-af68-e10c692d8966",
    "prId" : 2305,
    "prUrl" : "https://github.com/zio/zio/pull/2305#pullrequestreview-321934535",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "80e448d1-b3f3-41ee-a0d8-0ccfb3508b8f",
        "parentId" : null,
        "authorId" : "73db9f28-01ba-4a29-946b-7a2ae5ac5350",
        "body" : "We have a convention that is when we add a function to the `ZIO` object, we also add the equivalent to the `UIO`, `RIO`, `IO`, `Task`, `URIO` objects. You can see how `interruptibleMask` is handled since it's similar to this one.",
        "createdAt" : "2019-11-23T23:54:44Z",
        "updatedAt" : "2019-11-24T10:38:57Z",
        "lastEditedBy" : "73db9f28-01ba-4a29-946b-7a2ae5ac5350",
        "tags" : [
        ]
      }
    ],
    "commit" : "e1796d3e9af86ce9955ba414e16cd19a167eec6f",
    "line" : 30,
    "diffHunk" : "@@ -1,1 +1860,1864 @@   * the effect is composed into.\n   */\n  final def daemonMask[R, E, A](k: ZIO.DaemonStatusRestore => ZIO[R, E, A]): ZIO[R, E, A] =\n    checkDaemon(status => k(new ZIO.DaemonStatusRestore(status)).daemon)\n"
  },
  {
    "id" : "da871275-db5b-4297-9e05-e757e599b9bd",
    "prId" : 2091,
    "prUrl" : "https://github.com/zio/zio/pull/2091#pullrequestreview-312465213",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6786405f-8bae-4890-bcac-edc2d73a2b2d",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "This looks like new functionality—isn't `raceWith` supposed to do the inheritance?",
        "createdAt" : "2019-11-04T04:11:06Z",
        "updatedAt" : "2019-11-05T10:45:26Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      },
      {
        "id" : "c7e9a742-4514-44aa-aa97-e2b4ba667c60",
        "parentId" : "6786405f-8bae-4890-bcac-edc2d73a2b2d",
        "authorId" : "9bd3b19c-4c36-4bed-bf40-e006d1b18e7d",
        "body" : "Without this fix, a test in `FiberRefSpec` fails:\r\n\r\n```scala\r\ntestM(\"nothing gets inherited with a failure in zipPar\") {\r\n  for {\r\n      fiberRef <- FiberRef.make(initial)\r\n       success  = fiberRef.set(update)\r\n       failure1 = fiberRef.set(update1) *> ZIO.fail(\":-(\")\r\n       failure2 = fiberRef.set(update2) *> ZIO.fail(\":-O\")\r\n       _        <- success.zipPar(failure1.zipPar(failure2)).orElse(ZIO.unit)\r\n       value    <- fiberRef.get\r\n     } yield assert(value, equalTo(initial))\r\n}\r\n```\r\nI wasn't sure breaking existing behavior was the way to go. This test assumes that if one of fibers fail, we don't carry the `FiberRef` of the successful fiber either, even if it won the race. What do you think should be done here?",
        "createdAt" : "2019-11-04T17:01:27Z",
        "updatedAt" : "2019-11-05T10:45:26Z",
        "lastEditedBy" : "9bd3b19c-4c36-4bed-bf40-e006d1b18e7d",
        "tags" : [
        ]
      },
      {
        "id" : "a81e2663-4181-486a-9841-0466253021f2",
        "parentId" : "6786405f-8bae-4890-bcac-edc2d73a2b2d",
        "authorId" : "fe8c0309-9574-4c2c-a95a-2f54e9bd5411",
        "body" : "@YuvalItzchakov zip and race are different operations. Failure in zip cancels the computation and prevents ref inheritance – there is no \"winner\" in a failed zip.",
        "createdAt" : "2019-11-05T18:08:28Z",
        "updatedAt" : "2019-11-05T18:08:28Z",
        "lastEditedBy" : "fe8c0309-9574-4c2c-a95a-2f54e9bd5411",
        "tags" : [
        ]
      },
      {
        "id" : "cf163555-a9a6-462d-bd47-c80e681fb080",
        "parentId" : "6786405f-8bae-4890-bcac-edc2d73a2b2d",
        "authorId" : "fe8c0309-9574-4c2c-a95a-2f54e9bd5411",
        "body" : "@YuvalItzchakov zip and race are different operations. Failure in zip cancels the computation and prevents ref inheritance – there is no \"winner\" in a failed zip.",
        "createdAt" : "2019-11-05T18:08:33Z",
        "updatedAt" : "2019-11-05T18:08:33Z",
        "lastEditedBy" : "fe8c0309-9574-4c2c-a95a-2f54e9bd5411",
        "tags" : [
        ]
      },
      {
        "id" : "30d9f5d5-fd61-468f-b2c9-9a10683014ad",
        "parentId" : "6786405f-8bae-4890-bcac-edc2d73a2b2d",
        "authorId" : "9bd3b19c-4c36-4bed-bf40-e006d1b18e7d",
        "body" : "@neko-kai As long as zip uses race underneath, it's going to need to apply these additional semantics. That's why I added these change to compensate. Making `race` await for both fibers slows it down significantly.",
        "createdAt" : "2019-11-06T14:21:44Z",
        "updatedAt" : "2019-11-06T14:22:46Z",
        "lastEditedBy" : "9bd3b19c-4c36-4bed-bf40-e006d1b18e7d",
        "tags" : [
        ]
      }
    ],
    "commit" : "3e631beee2e7d26db97fb6569eb19fa375713e49",
    "line" : 85,
    "diffHunk" : "@@ -1,1 +1504,1508 @@    val g = (b: B, a: A) => f(a, b)\n    (self raceWith that)(coordinate(f, true), coordinate(g, false)).fork.flatMap { f =>\n      f.await.flatMap { exit =>\n        if (exit.succeeded) f.inheritFiberRefs *> ZIO.done(exit)\n        else ZIO.done(exit)"
  },
  {
    "id" : "6e44bcbd-2d63-418b-8517-3b00a87c5f54",
    "prId" : 2049,
    "prUrl" : "https://github.com/zio/zio/pull/2049#pullrequestreview-308569613",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bafa6437-107f-498a-b8b1-24e0b6a6314d",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "This one makes sense because for an effect with `E = Nothing`, it can already be treated as a subtype of a more specific error type.",
        "createdAt" : "2019-10-29T14:45:38Z",
        "updatedAt" : "2019-10-30T21:14:08Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      }
    ],
    "commit" : "53f26da337c14e906076896b7c9dcf5591b0edcf",
    "line" : 26,
    "diffHunk" : "@@ -1,1 +106,110 @@   * Maps the error value of this effect to the specified constant value.\n   */\n  final def asError[E1](e1: => E1)(implicit ev: CanFail[E]): ZIO[R, E1, A] =\n    mapError(new ZIO.ConstFn(() => e1))\n"
  },
  {
    "id" : "20a29fe6-8cd0-42aa-97e7-632d5ddce996",
    "prId" : 2049,
    "prUrl" : "https://github.com/zio/zio/pull/2049#pullrequestreview-308583447",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e9c279b2-337b-4b42-a5f9-84e7beb3f4dc",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "This one makes sense but seems more trouble than it's worth, because the right hand side is always useful; so at worse this is \"half useful\".",
        "createdAt" : "2019-10-29T14:46:16Z",
        "updatedAt" : "2019-10-30T21:14:08Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      },
      {
        "id" : "6a08b948-7bbd-4bf6-b888-e02b31fe3baf",
        "parentId" : "e9c279b2-337b-4b42-a5f9-84e7beb3f4dc",
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "Hmm, I guess such `bimap` can always be replaced by `map`, so maybe it's useful to leave this one (sorry!).",
        "createdAt" : "2019-10-29T14:54:08Z",
        "updatedAt" : "2019-10-30T21:14:08Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      },
      {
        "id" : "5dd20bf7-b066-4ecc-966d-a85cda1c5d23",
        "parentId" : "e9c279b2-337b-4b42-a5f9-84e7beb3f4dc",
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "No problem! I struggled with the same thing on some of these.",
        "createdAt" : "2019-10-29T15:01:09Z",
        "updatedAt" : "2019-10-30T21:14:08Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      }
    ],
    "commit" : "53f26da337c14e906076896b7c9dcf5591b0edcf",
    "line" : 34,
    "diffHunk" : "@@ -1,1 +113,117 @@   * the specified pair of functions, `f` and `g`.\n   */\n  final def bimap[E2, B](f: E => E2, g: A => B)(implicit ev: CanFail[E]): ZIO[R, E2, B] = mapError(f).map(g)\n\n  /**"
  },
  {
    "id" : "0a744c57-270f-409a-b68e-ac20b59c8f4d",
    "prId" : 2049,
    "prUrl" : "https://github.com/zio/zio/pull/2049#pullrequestreview-308604790",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "807d5b4c-43f7-440b-91a3-5d892a6d170c",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "This one can still be useful, because a user can utilize `E = Nothing` to prove there is no error. I would not change this method.",
        "createdAt" : "2019-10-29T14:48:02Z",
        "updatedAt" : "2019-10-30T21:14:08Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      },
      {
        "id" : "3c1f5db2-45f2-44ad-bb05-3dc990e503a8",
        "parentId" : "807d5b4c-43f7-440b-91a3-5d892a6d170c",
        "authorId" : "fe8c0309-9574-4c2c-a95a-2f54e9bd5411",
        "body" : "Do you mean use an implicit `E =:= Nothing`? They can still use this method If E is not literal a Nothing, but only by evidence. Otherwise I'm missing what's the additional power vs. `.map(success)`, for E=Nothing the type is always `ZIO[R, Nothing, A] => ZIO[R, Nothing, B]`, i.e. `map`",
        "createdAt" : "2019-10-29T15:17:25Z",
        "updatedAt" : "2019-10-30T21:14:08Z",
        "lastEditedBy" : "fe8c0309-9574-4c2c-a95a-2f54e9bd5411",
        "tags" : [
        ]
      },
      {
        "id" : "57900d4c-344d-4309-86e4-e312948ed67f",
        "parentId" : "807d5b4c-43f7-440b-91a3-5d892a6d170c",
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "It does seem like any use of `fold` could be replaced by `map` and `foldM` by `flatMap` if the error type is `Nothing`.",
        "createdAt" : "2019-10-29T15:26:13Z",
        "updatedAt" : "2019-10-30T21:14:08Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      }
    ],
    "commit" : "53f26da337c14e906076896b7c9dcf5591b0edcf",
    "line" : 91,
    "diffHunk" : "@@ -1,1 +424,428 @@   * function passed to `fold`.\n   */\n  final def fold[B](failure: E => B, success: A => B)(implicit ev: CanFail[E]): ZIO[R, Nothing, B] =\n    foldM(new ZIO.MapFn(failure), new ZIO.MapFn(success))\n"
  },
  {
    "id" : "8c1bae13-4516-4db2-a9e2-11c866f34d21",
    "prId" : 2049,
    "prUrl" : "https://github.com/zio/zio/pull/2049#pullrequestreview-308572069",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fc7657e7-6ade-4439-8f28-f4e9ab5b4563",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "I would not change this one either, it can be used for proofs that the error cannot happen.",
        "createdAt" : "2019-10-29T14:48:19Z",
        "updatedAt" : "2019-10-30T21:14:08Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      }
    ],
    "commit" : "53f26da337c14e906076896b7c9dcf5591b0edcf",
    "line" : 100,
    "diffHunk" : "@@ -1,1 +450,454 @@   * it will depend on the `IO`s returned by the given continuations.\n   */\n  final def foldM[R1 <: R, E2, B](failure: E => ZIO[R1, E2, B], success: A => ZIO[R1, E2, B])(\n    implicit ev: CanFail[E]\n  ): ZIO[R1, E2, B] ="
  },
  {
    "id" : "ed062e71-2c53-4568-84e9-a9fb5427247e",
    "prId" : 2049,
    "prUrl" : "https://github.com/zio/zio/pull/2049#pullrequestreview-308572469",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b5dadcb7-c718-4946-a1e7-517209ea0f29",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "This one is useful since there is no need to map the error when `E` = Nothing, since it's already a subtype of all other errors.",
        "createdAt" : "2019-10-29T14:48:47Z",
        "updatedAt" : "2019-10-30T21:14:08Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      }
    ],
    "commit" : "53f26da337c14e906076896b7c9dcf5591b0edcf",
    "line" : 111,
    "diffHunk" : "@@ -1,1 +566,570 @@   * error.\n   */\n  final def mapError[E2](f: E => E2)(implicit ev: CanFail[E]): ZIO[R, E2, A] =\n    self.foldCauseM(new ZIO.MapErrorFn(f), new ZIO.SucceedFn(f))\n"
  },
  {
    "id" : "ad3b30d0-40e1-49ae-81d2-92acdd34f771",
    "prId" : 2049,
    "prUrl" : "https://github.com/zio/zio/pull/2049#pullrequestreview-308576467",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0b5a9415-2bff-494d-a133-bb1398b09cb2",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "I like how this change fixed some issues like this (dead code). ❤️ ",
        "createdAt" : "2019-10-29T14:53:17Z",
        "updatedAt" : "2019-10-30T21:14:08Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      }
    ],
    "commit" : "53f26da337c14e906076896b7c9dcf5591b0edcf",
    "line" : 217,
    "diffHunk" : "@@ -1,1 +1165,1169 @@    self.foldM(\n      e => ZIO.fail(Some(e)),\n      a => a.fold[ZIO[R, Option[E], B]](ZIO.fail(Option.empty[E]))(ZIO.succeed(_))\n    )\n"
  },
  {
    "id" : "0e0d9996-788b-4bf9-95a4-53cb3862d15b",
    "prId" : 2049,
    "prUrl" : "https://github.com/zio/zio/pull/2049#pullrequestreview-308577604",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c2602d27-64c4-478b-bf3b-9fca9266893a",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "A failing example can always be replaced by `tap`, so I think this is useful.",
        "createdAt" : "2019-10-29T14:54:33Z",
        "updatedAt" : "2019-10-30T21:14:08Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      }
    ],
    "commit" : "53f26da337c14e906076896b7c9dcf5591b0edcf",
    "line" : 227,
    "diffHunk" : "@@ -1,1 +1268,1272 @@   */\n  final def tapBoth[R1 <: R, E1 >: E](f: E => ZIO[R1, E1, Any], g: A => ZIO[R1, E1, Any])(\n    implicit ev: CanFail[E]\n  ): ZIO[R1, E1, A] =\n    self.foldCauseM(new ZIO.TapErrorRefailFn(f), new ZIO.TapFn(g))"
  },
  {
    "id" : "5621091c-4713-4a58-a828-a3aa4678d16a",
    "prId" : 1949,
    "prUrl" : "https://github.com/zio/zio/pull/1949#pullrequestreview-300494507",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ec277204-4f89-4a41-872b-2eef063eca80",
        "parentId" : null,
        "authorId" : "524c15e0-b013-4ec4-bd1d-2b61884828d1",
        "body" : "Thanks for doc",
        "createdAt" : "2019-10-11T06:52:13Z",
        "updatedAt" : "2019-10-13T19:45:02Z",
        "lastEditedBy" : "524c15e0-b013-4ec4-bd1d-2b61884828d1",
        "tags" : [
        ]
      }
    ],
    "commit" : "93f720fe7d0ca1203f198c81cfbcd4532438eb89",
    "line" : 27,
    "diffHunk" : "@@ -1,1 +1581,1585 @@   * reported. This is useful for implementing combinators that handle failures\n   * themselves.\n   */\n  private[zio] final def forkInternal: ZIO[R, Nothing, Fiber[E, A]] =\n    run.fork.map(_.mapM(IO.done))"
  },
  {
    "id" : "e3907f0c-b6b0-4bef-9f08-72d05ea18db3",
    "prId" : 1949,
    "prUrl" : "https://github.com/zio/zio/pull/1949#pullrequestreview-301058021",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "dc3b7451-6b61-450c-8181-7a114b4367df",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "Beautiful!",
        "createdAt" : "2019-10-13T17:33:49Z",
        "updatedAt" : "2019-10-13T19:45:02Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      }
    ],
    "commit" : "93f720fe7d0ca1203f198c81cfbcd4532438eb89",
    "line" : 29,
    "diffHunk" : "@@ -1,1 +1583,1587 @@   */\n  private[zio] final def forkInternal: ZIO[R, Nothing, Fiber[E, A]] =\n    run.fork.map(_.mapM(IO.done))\n}\n"
  },
  {
    "id" : "e6e6eef6-2ffd-48f0-8b19-7fb5673ee4ae",
    "prId" : 1870,
    "prUrl" : "https://github.com/zio/zio/pull/1870#pullrequestreview-295609065",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "469ea550-281b-4119-85cd-b7df53e84edb",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "This looks good, can you make sure `either` is consistent with this?",
        "createdAt" : "2019-10-01T13:33:41Z",
        "updatedAt" : "2019-10-01T13:33:41Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      },
      {
        "id" : "da5633a8-0535-45c5-a1c4-4cc99ab29207",
        "parentId" : "469ea550-281b-4119-85cd-b7df53e84edb",
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "Just checked and `either` is implemented in terms of `foldM` versus `foldCauseM`, so I think we are good here. Also reinforces that this is the right way to go as these methods should be consistent.",
        "createdAt" : "2019-10-01T13:38:25Z",
        "updatedAt" : "2019-10-01T13:38:25Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      }
    ],
    "commit" : "71bc7e8db265c354dab9fa5dbad0e07109618c81",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +647,651 @@   */\n  final def option: ZIO[R, Nothing, Option[A]] =\n    self.foldM(_ => IO.succeed(None), a => IO.succeed(Some(a)))\n\n  final def optional[E1](implicit ev: E <:< Option[E1]): ZIO[R, E1, Option[A]] ="
  },
  {
    "id" : "d3afdedb-3ff1-498e-8c63-8e899fafef2f",
    "prId" : 1848,
    "prUrl" : "https://github.com/zio/zio/pull/1848#pullrequestreview-294651243",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9a4655e7-9ee5-4229-aa17-29bfb12ece94",
        "parentId" : null,
        "authorId" : "2a2f79ba-933f-43cd-9d45-5d769ab0f54d",
        "body" : "This is very nice. Makes it far easier to understand interruption semantics without digging through ZManaged / bracket",
        "createdAt" : "2019-09-28T19:36:18Z",
        "updatedAt" : "2019-09-28T19:37:31Z",
        "lastEditedBy" : "2a2f79ba-933f-43cd-9d45-5d769ab0f54d",
        "tags" : [
        ]
      }
    ],
    "commit" : "5dad0d8e6762f8f34f65321bcc7d5d7b1d790a49",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +1325,1329 @@\n  /**\n   * Converts this ZIO to [[zio.Managed]]. This ZIO and the provided release action\n   * will be performed uninterruptibly.\n   */"
  },
  {
    "id" : "bcb4ea8a-387b-4da9-9d19-89ad1ede1dc7",
    "prId" : 1828,
    "prUrl" : "https://github.com/zio/zio/pull/1828#pullrequestreview-319067294",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1e335c2b-a948-471a-bc47-a7db6eae7e5a",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "If we are going to wrap in `Cause.die` (I am not sure 😆 ), we could avoid `stripFailures` altogether.",
        "createdAt" : "2019-09-29T22:50:18Z",
        "updatedAt" : "2019-11-18T12:19:11Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      },
      {
        "id" : "9243ba57-1a97-4b0f-ba65-e2f0c6839a15",
        "parentId" : "1e335c2b-a948-471a-bc47-a7db6eae7e5a",
        "authorId" : "ad71b567-3c3b-4fc7-812b-282c0567f621",
        "body" : "Are we? I thought `stripFailures` were used to continue execution if the error that happened previously wasn't fatal. Otherwise execution halts.",
        "createdAt" : "2019-09-30T05:52:09Z",
        "updatedAt" : "2019-11-18T12:19:11Z",
        "lastEditedBy" : "ad71b567-3c3b-4fc7-812b-282c0567f621",
        "tags" : [
        ]
      },
      {
        "id" : "6fe83661-8df8-4d35-a65d-b3338183afe9",
        "parentId" : "1e335c2b-a948-471a-bc47-a7db6eae7e5a",
        "authorId" : "ad71b567-3c3b-4fc7-812b-282c0567f621",
        "body" : "For example `IO.die(1) orElse IO.fail(2)` would fail on the right side instead of dying on the left side.",
        "createdAt" : "2019-09-30T07:07:02Z",
        "updatedAt" : "2019-11-18T12:19:11Z",
        "lastEditedBy" : "ad71b567-3c3b-4fc7-812b-282c0567f621",
        "tags" : [
        ]
      },
      {
        "id" : "36c42f5e-ba1f-4ab1-b814-cf4099f569d6",
        "parentId" : "1e335c2b-a948-471a-bc47-a7db6eae7e5a",
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "`stripFailures` will remove the `E` from the `fail`. But if you are taking the _whole_ cause and putting it into `Die`, then that `E` will not be visible at the type level.\r\n\r\nWe will always do `that` right after `this` fails, it's only when both fail that we take the whole left `cause`, smash it into `Die`, and then follow it by the right's (typed) failure.\r\n\r\nYou can write a test here to see the behavior of `self.catchAllCause(cause1 => that.catchAllCause(cause2 => Cause.die(FiberFailure(cause1)) ++ cause2))`",
        "createdAt" : "2019-09-30T09:10:53Z",
        "updatedAt" : "2019-11-18T12:19:11Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      },
      {
        "id" : "ee7fe24c-ee51-4e18-9fbe-9c363527907d",
        "parentId" : "1e335c2b-a948-471a-bc47-a7db6eae7e5a",
        "authorId" : "ad71b567-3c3b-4fc7-812b-282c0567f621",
        "body" : "Yes, I understand it, and if I do `self.catchAllCause(cause1 => that.catchAllCause(cause2 => Cause.die(FiberFailure(cause1)) ++ cause2))` then `ZIOSpecJvm.testOrElseDefectHandling` fails, because `(ZIO.die(ex) <> IO.unit).run` isn't equal to `Exit.die(ex)` anymore. Should I change this behaviour or does it need to be preserved?",
        "createdAt" : "2019-09-30T11:10:50Z",
        "updatedAt" : "2019-11-18T12:19:11Z",
        "lastEditedBy" : "ad71b567-3c3b-4fc7-812b-282c0567f621",
        "tags" : [
        ]
      },
      {
        "id" : "cb719ed6-bad9-4e3a-b6cc-3883dff8cb8b",
        "parentId" : "1e335c2b-a948-471a-bc47-a7db6eae7e5a",
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "Hmm, what does the error change to?",
        "createdAt" : "2019-10-03T23:15:09Z",
        "updatedAt" : "2019-11-18T12:19:11Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      },
      {
        "id" : "3dfb12ea-5803-4618-9c83-7d469f393a1c",
        "parentId" : "1e335c2b-a948-471a-bc47-a7db6eae7e5a",
        "authorId" : "ad71b567-3c3b-4fc7-812b-282c0567f621",
        "body" : "```\r\nSuccess(()) != Failure(Die(java.lang.Exception: Died))\r\nExpected :Failure(Die(java.lang.Exception: Died))\r\nActual   :Success(())\r\n```",
        "createdAt" : "2019-10-04T09:14:51Z",
        "updatedAt" : "2019-11-18T12:19:11Z",
        "lastEditedBy" : "ad71b567-3c3b-4fc7-812b-282c0567f621",
        "tags" : [
        ]
      },
      {
        "id" : "d03a3766-ca77-4c38-8a33-1cedfdbaed6f",
        "parentId" : "1e335c2b-a948-471a-bc47-a7db6eae7e5a",
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "OK, right. That's because we don't want `orElse` to \"recover\" from defects. So if there are any defects, we fail it. Well, we can do that in another way:\r\n\r\n```scala\r\n       ZIOFn(() => that) { cause =>\r\n         if (cause.died) ZIO.halt(cause)\r\n         else that.catchAllCause(cause2 => ZIO.halt(Cause.die(FiberFailure(cause)) ++ cause2))\r\n       }\r\n```\r\n\r\nThis is more direct and reflects intention better than `stripFailures`.",
        "createdAt" : "2019-11-13T20:24:31Z",
        "updatedAt" : "2019-11-18T12:19:11Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      },
      {
        "id" : "d8b87b2c-aefa-435a-b6eb-f5ad3979e37f",
        "parentId" : "1e335c2b-a948-471a-bc47-a7db6eae7e5a",
        "authorId" : "fe8c0309-9574-4c2c-a95a-2f54e9bd5411",
        "body" : "I agree, but `cause.died` would still recover from internal interrupts, might as well use `cause.failed` to be in line with other typed error recovery functions",
        "createdAt" : "2019-11-14T13:46:30Z",
        "updatedAt" : "2019-11-18T12:19:11Z",
        "lastEditedBy" : "fe8c0309-9574-4c2c-a95a-2f54e9bd5411",
        "tags" : [
        ]
      },
      {
        "id" : "9ca95eb7-d782-4a57-9b3c-55078599ea41",
        "parentId" : "1e335c2b-a948-471a-bc47-a7db6eae7e5a",
        "authorId" : "ad71b567-3c3b-4fc7-812b-282c0567f621",
        "body" : "@jdegoes I'm sorry, I haven't seen your response. In my opinion, `stripFailures` is better because it returns `Option[Cause[Nothin]]`, and can pass it directly to `ZIO#halt`. Otherwise I would need to wrap `cause` into `Cause.die(FiberFailure(cause))`.",
        "createdAt" : "2019-11-19T13:58:03Z",
        "updatedAt" : "2019-11-19T13:58:03Z",
        "lastEditedBy" : "ad71b567-3c3b-4fc7-812b-282c0567f621",
        "tags" : [
        ]
      },
      {
        "id" : "759e4468-42a1-43dc-9d87-bcd0def41187",
        "parentId" : "1e335c2b-a948-471a-bc47-a7db6eae7e5a",
        "authorId" : "fe8c0309-9574-4c2c-a95a-2f54e9bd5411",
        "body" : "Seems like `stripFailures` is required here to typecheck, so I think there's not much to be changed here and it's probably good to go as is, so I'll merge. 👍 ",
        "createdAt" : "2019-11-19T14:13:56Z",
        "updatedAt" : "2019-11-19T14:13:57Z",
        "lastEditedBy" : "fe8c0309-9574-4c2c-a95a-2f54e9bd5411",
        "tags" : [
        ]
      },
      {
        "id" : "6fff1cb9-8c14-4a51-9741-cc9e6b886265",
        "parentId" : "1e335c2b-a948-471a-bc47-a7db6eae7e5a",
        "authorId" : "fe8c0309-9574-4c2c-a95a-2f54e9bd5411",
        "body" : "Another way would be to cast the Cause, but I guess it's not necessary tbh:\r\n\r\n```scala\r\n       ZIOFn(() => that) { cause =>\r\n         if (!cause.failed) ZIO.halt(cause.asInstanceOf[Cause[E2])\r\n         else that.catchAllCause(cause2 => ZIO.halt(Cause.die(FiberFailure(cause)) ++ cause2))\r\n       }\r\n```",
        "createdAt" : "2019-11-19T14:17:21Z",
        "updatedAt" : "2019-11-19T14:17:21Z",
        "lastEditedBy" : "fe8c0309-9574-4c2c-a95a-2f54e9bd5411",
        "tags" : [
        ]
      }
    ],
    "commit" : "e7453232c986fcae881c1b1a13ca1becc0a284e3",
    "line" : 10,
    "diffHunk" : "@@ -1,1 +1415,1419 @@      ZIOFn(() => that) { cause =>\n        cause.stripFailures match {\n          case None    => that.catchAllCause(cause2 => ZIO.halt(Cause.die(FiberFailure(cause)) ++ cause2))\n          case Some(c) => ZIO.halt(c)\n        }"
  },
  {
    "id" : "85c13cf0-3766-42ca-b0d5-f24dd1d06361",
    "prId" : 1798,
    "prUrl" : "https://github.com/zio/zio/pull/1798#pullrequestreview-307477401",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7d6bb3e9-ae2c-42f8-9959-e6cc79fcbb20",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "Awesome to see this, truly awesome! 👍 ",
        "createdAt" : "2019-10-25T22:26:33Z",
        "updatedAt" : "2019-10-27T21:13:24Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      }
    ],
    "commit" : "85723fa5b39983f7ca4e00175970147787e755db",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +1029,1033 @@   * `io.repeat(Schedule.once)` means \"execute io and in case of success repeat `io` once\".\n   */\n  final def repeat[R1 <: R, B](schedule: ZSchedule[R1, A, B]): ZIO[R1, E, B] =\n    repeatOrElse[R1, E, B](schedule, (e, _) => ZIO.fail(e))\n"
  },
  {
    "id" : "f4ecf01c-7b95-40a4-a183-249b4cbda54a",
    "prId" : 1798,
    "prUrl" : "https://github.com/zio/zio/pull/1798#pullrequestreview-307477401",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bf264598-50de-4518-9f8a-6225d7ce885f",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "Ditto",
        "createdAt" : "2019-10-25T22:26:40Z",
        "updatedAt" : "2019-10-27T21:13:24Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      }
    ],
    "commit" : "85723fa5b39983f7ca4e00175970147787e755db",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +1040,1044 @@    schedule: ZSchedule[R1, A, B],\n    orElse: (E, Option[B]) => ZIO[R1, E2, B]\n  ): ZIO[R1, E2, B] =\n    repeatOrElseEither[R1, B, E2, B](schedule, orElse).map(_.merge)\n"
  },
  {
    "id" : "420a04cf-68d6-42bb-8f87-67cbf25e56aa",
    "prId" : 1798,
    "prUrl" : "https://github.com/zio/zio/pull/1798#pullrequestreview-307477401",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f788ac62-e659-4b7e-b9c2-e2b90b257444",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "👍 ",
        "createdAt" : "2019-10-25T22:26:52Z",
        "updatedAt" : "2019-10-27T21:13:24Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      }
    ],
    "commit" : "85723fa5b39983f7ca4e00175970147787e755db",
    "line" : 36,
    "diffHunk" : "@@ -1,1 +1051,1055 @@    schedule: ZSchedule[R1, A, B],\n    orElse: (E, Option[B]) => ZIO[R1, E2, C]\n  ): ZIO[R1, E2, Either[C, B]] = {\n    def loop(last: A, state: schedule.State): ZIO[R1, E2, Either[C, B]] =\n      schedule"
  },
  {
    "id" : "d1402e7a-8e9f-4322-9ac0-3ee9196e2d94",
    "prId" : 1694,
    "prUrl" : "https://github.com/zio/zio/pull/1694#pullrequestreview-289409786",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "24b14c90-359f-4bee-9df7-8a53838c9788",
        "parentId" : null,
        "authorId" : "fe8c0309-9574-4c2c-a95a-2f54e9bd5411",
        "body" : "Doesn't that look like a reason for invariant syntax to be there? 🤔 ",
        "createdAt" : "2019-09-17T15:26:39Z",
        "updatedAt" : "2019-09-17T15:26:39Z",
        "lastEditedBy" : "fe8c0309-9574-4c2c-a95a-2f54e9bd5411",
        "tags" : [
        ]
      },
      {
        "id" : "7e312739-2780-4598-9725-9b60a9c566fb",
        "parentId" : "24b14c90-359f-4bee-9df7-8a53838c9788",
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "Ah, right...",
        "createdAt" : "2019-09-17T16:08:04Z",
        "updatedAt" : "2019-09-17T16:08:05Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      },
      {
        "id" : "b6998b4e-0563-498d-8149-77569e3f267f",
        "parentId" : "24b14c90-359f-4bee-9df7-8a53838c9788",
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "Oops. Backout?",
        "createdAt" : "2019-09-17T16:08:23Z",
        "updatedAt" : "2019-09-17T16:08:23Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      },
      {
        "id" : "847fc6f5-c132-4c8d-b2e6-1523252832c0",
        "parentId" : "24b14c90-359f-4bee-9df7-8a53838c9788",
        "authorId" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "body" : "I guess so 😟 then remove `bracketExit` from the main class too?",
        "createdAt" : "2019-09-17T16:58:07Z",
        "updatedAt" : "2019-09-17T16:58:08Z",
        "lastEditedBy" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "tags" : [
        ]
      }
    ],
    "commit" : "b9592d75dc526b18675ddd6baea86101796ad41d",
    "line" : 40,
    "diffHunk" : "@@ -1,1 +2509,2513 @@     */\n    def bracketAuto[R1 <: R, E1 >: E, B](use: A => ZIO[R1, E1, B]): ZIO[R1, E1, B] =\n      io.bracket[R1, E1, B](a => UIO(a.close()), use)\n\n    /**"
  },
  {
    "id" : "3d94130a-69a2-4244-9e17-2a4f613b0284",
    "prId" : 1594,
    "prUrl" : "https://github.com/zio/zio/pull/1594#pullrequestreview-286984835",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "34e3d4c6-f1c4-4cac-b34d-29a9aeaebd22",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "There is a more direct way to encode this: use `Ref[Task[Unit]]`. Then you can start that `Ref` off with `ZIO.unit`, and then you can either stick `left2.inheritFiberRefs` into that, or `right2.inheritFiberRefs` into it, depending on the race outcome.\r\n\r\nThis will simplify the code a _lot_.",
        "createdAt" : "2019-09-10T19:08:36Z",
        "updatedAt" : "2019-09-11T19:58:48Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      },
      {
        "id" : "168b593e-6efc-44a9-af6f-a18372e13392",
        "parentId" : "34e3d4c6-f1c4-4cac-b34d-29a9aeaebd22",
        "authorId" : "1e0d5b88-5182-4600-a09d-55e8abbff2a7",
        "body" : "Hmm, you can't access the currently executing fiber, can you? Because to do the refactoring you propose, I would need to access either `left2` or `right2` from within `arbiter`, which is not possible otherwise. Also note that simply inheriting from `left` or `right` is not correct, because if the winning fiber failed, the caller might have joined the loosing fiber (which is exactly what `raceEither` does).\r\n\r\nOr maybe I didn't understand you correctly?",
        "createdAt" : "2019-09-11T18:23:27Z",
        "updatedAt" : "2019-09-11T19:58:48Z",
        "lastEditedBy" : "1e0d5b88-5182-4600-a09d-55e8abbff2a7",
        "tags" : [
        ]
      }
    ],
    "commit" : "816539897f7c1a3793f902958dc5ebb6e89a23bc",
    "line" : 44,
    "diffHunk" : "@@ -1,1 +898,902 @@              inheritFiberRefs = inherit.get.flatMap {\n                case None        => ZIO.unit\n                case Some(true)  => left2.inheritFiberRefs\n                case Some(false) => right2.inheritFiberRefs\n              }"
  },
  {
    "id" : "475a8c88-b201-48e0-a19a-16421f1c1d74",
    "prId" : 1594,
    "prUrl" : "https://github.com/zio/zio/pull/1594#pullrequestreview-286985025",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "644cd365-b9b3-47db-9b15-83ed1b48e17a",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "This would change to `Ref[Task[Unit]]`, see below.",
        "createdAt" : "2019-09-10T19:09:02Z",
        "updatedAt" : "2019-09-11T19:58:48Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      },
      {
        "id" : "1c8fc778-d14a-41e5-834c-d292ae134b1d",
        "parentId" : "644cd365-b9b3-47db-9b15-83ed1b48e17a",
        "authorId" : "1e0d5b88-5182-4600-a09d-55e8abbff2a7",
        "body" : "See above",
        "createdAt" : "2019-09-11T18:23:45Z",
        "updatedAt" : "2019-09-11T19:58:48Z",
        "lastEditedBy" : "1e0d5b88-5182-4600-a09d-55e8abbff2a7",
        "tags" : [
        ]
      }
    ],
    "commit" : "816539897f7c1a3793f902958dc5ebb6e89a23bc",
    "line" : 9,
    "diffHunk" : "@@ -1,1 +872,876 @@      leftWins: Boolean,\n      raceDone: Ref[Boolean],\n      inherit: Ref[Option[Boolean]],\n      done: Promise[E2, C]\n    )(res: Exit[E0, A]): ZIO[R1, Nothing, _] = {"
  },
  {
    "id" : "6215e42c-aa86-47dd-8d7d-0e42852a4d04",
    "prId" : 1175,
    "prUrl" : "https://github.com/zio/zio/pull/1175#pullrequestreview-261417360",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "84a7a547-57a6-4234-a275-f2a7332c1ed0",
        "parentId" : null,
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "~Hmm why `E1 >: NoSuchElementException` rather than just returning `ZIO[R, NoSuchElementException, B]`? Since `E1` doesn't show up in the function's parameters (other than the `ev2` but that doesn't influence inference, I think), this might not infer properly (or worse inferred as `Any`)~",
        "createdAt" : "2019-07-12T18:45:14Z",
        "updatedAt" : "2019-07-14T18:42:47Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      }
    ],
    "commit" : "b3b5acd4a2feae65a3ad9872705654ab391e1195",
    "line" : 16,
    "diffHunk" : "@@ -1,1 +800,804 @@   * Returns a successful effect if the value is `Left`, or fails with a [[java.util.NoSuchElementException]].\n   */\n  def leftOrFailException[B, C, E1 >: NoSuchElementException](\n    implicit ev: A <:< Either[B, C],\n    ev2: E <:< E1"
  },
  {
    "id" : "49803f1d-e85c-40f8-8e2f-1cefaf9acf41",
    "prId" : 1175,
    "prUrl" : "https://github.com/zio/zio/pull/1175#pullrequestreview-261417360",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5bd02261-c7e9-4189-8156-26eb4d5adf29",
        "parentId" : null,
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "Same as with `leftOrFailException`",
        "createdAt" : "2019-07-12T18:48:00Z",
        "updatedAt" : "2019-07-14T18:42:47Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      }
    ],
    "commit" : "b3b5acd4a2feae65a3ad9872705654ab391e1195",
    "line" : 39,
    "diffHunk" : "@@ -1,1 +823,827 @@   * Returns a successful effect if the value is `Right`, or fails with a [[java.util.NoSuchElementException]].\n   */\n  def rightOrFailException[B, C, E1 >: NoSuchElementException](\n    implicit ev: A <:< Either[B, C],\n    ev2: E <:< E1"
  },
  {
    "id" : "52ead5e5-f3ee-4468-9aec-808193f174a4",
    "prId" : 1175,
    "prUrl" : "https://github.com/zio/zio/pull/1175#pullrequestreview-261417360",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bba46250-e7c8-45e9-be3b-1df9c33de976",
        "parentId" : null,
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "Same comments as with `leftOrFailException`",
        "createdAt" : "2019-07-12T18:48:15Z",
        "updatedAt" : "2019-07-14T18:42:47Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      }
    ],
    "commit" : "b3b5acd4a2feae65a3ad9872705654ab391e1195",
    "line" : 67,
    "diffHunk" : "@@ -1,1 +1163,1167 @@   * Extracts the optional value, or fails with a [[java.util.NoSuchElementException]]\n   */\n  def someOrFailException[B, E1 >: NoSuchElementException](implicit ev: A <:< Option[B], ev2: E <:< E1): ZIO[R, E1, B] =\n    self.foldM(e => ZIO.fail(ev2(e)), ev(_) match {\n      case Some(value) => ZIO.succeed(value)"
  },
  {
    "id" : "928a3e5d-d4c6-4255-9f4c-f9db9f1ad867",
    "prId" : 1175,
    "prUrl" : "https://github.com/zio/zio/pull/1175#pullrequestreview-261544456",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "61ea9642-f9da-4630-9ca0-35a522ba573b",
        "parentId" : null,
        "authorId" : "c9b92c27-ac07-4362-92e2-eae234a7ecf4",
        "body" : "This method does almost the same as `ZIO#get`, do we really need both?",
        "createdAt" : "2019-07-13T08:28:53Z",
        "updatedAt" : "2019-07-14T18:42:47Z",
        "lastEditedBy" : "c9b92c27-ac07-4362-92e2-eae234a7ecf4",
        "tags" : [
        ]
      },
      {
        "id" : "9848fc51-d396-4e9b-94a7-3e5a347e6508",
        "parentId" : "61ea9642-f9da-4630-9ca0-35a522ba573b",
        "authorId" : "dc528136-aa25-410d-8dbb-cbbbe7526c66",
        "body" : "@evis, I agree with you.\r\nI think the difference is that: `someOrFailException` gives you an exception in case of a failure while `.get` just return the unit value.\r\n\r\nwhat do you think about expressing `.get` using `someOrFailException`? does that make sense? \r\n\r\nSomething like\r\n```scala\r\nfinal def get[E1 >: E, B](implicit ev: A <:< Option[B]): ZIO[R, Unit, B] =\r\n    self.someOrFail(()).mapError(_ => ())\r\n```",
        "createdAt" : "2019-07-13T14:50:22Z",
        "updatedAt" : "2019-07-14T18:42:47Z",
        "lastEditedBy" : "dc528136-aa25-410d-8dbb-cbbbe7526c66",
        "tags" : [
        ]
      },
      {
        "id" : "1afcd7dd-a9b8-4082-80e7-04ce9006ce06",
        "parentId" : "61ea9642-f9da-4630-9ca0-35a522ba573b",
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "Good idea @dorsev ",
        "createdAt" : "2019-07-13T14:55:11Z",
        "updatedAt" : "2019-07-14T18:42:47Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      }
    ],
    "commit" : "b3b5acd4a2feae65a3ad9872705654ab391e1195",
    "line" : 67,
    "diffHunk" : "@@ -1,1 +1163,1167 @@   * Extracts the optional value, or fails with a [[java.util.NoSuchElementException]]\n   */\n  def someOrFailException[B, E1 >: NoSuchElementException](implicit ev: A <:< Option[B], ev2: E <:< E1): ZIO[R, E1, B] =\n    self.foldM(e => ZIO.fail(ev2(e)), ev(_) match {\n      case Some(value) => ZIO.succeed(value)"
  },
  {
    "id" : "1084baf8-9f69-458c-b01a-b5de15fba3b5",
    "prId" : 1107,
    "prUrl" : "https://github.com/zio/zio/pull/1107#pullrequestreview-256082795",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "dab4c7c5-6d40-47eb-83e3-86534284dd45",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "Good name, seems useful! 👍 ",
        "createdAt" : "2019-06-30T16:56:44Z",
        "updatedAt" : "2019-06-30T16:56:44Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      }
    ],
    "commit" : "c986bec91ae52ecd27a1aea2c4d651a18dd57182",
    "line" : 12,
    "diffHunk" : "@@ -1,1 +365,369 @@   */\n  final def mapErrorCause[E2](h: Cause[E] => Cause[E2]): ZIO[R, E2, A] =\n    self.foldCauseM(new ZIO.MapErrorCauseFn(h), new ZIO.SucceedFn(h))\n\n  /**"
  },
  {
    "id" : "a727a1c4-ed77-4b3f-9d77-d81e5cd03d16",
    "prId" : 968,
    "prUrl" : "https://github.com/zio/zio/pull/968#pullrequestreview-250270466",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "90a6bef2-4cec-4a29-a759-19ec8feac91c",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "The only issue I see is with the parameter ordering for `filterOrElse_` and `filterOrElse`. Ordinarily, the error would be first, because it is most likely to be constant, while the predicate is most likely to vary. \r\n\r\nIs there a reason you have the current ordering?",
        "createdAt" : "2019-06-15T23:55:29Z",
        "updatedAt" : "2019-06-15T23:55:29Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      },
      {
        "id" : "80e90c26-ae3e-4360-aa20-f3f6c205eaaf",
        "parentId" : "90a6bef2-4cec-4a29-a759-19ec8feac91c",
        "authorId" : "cee4afcb-562c-48aa-98f9-d03a07569a08",
        "body" : "Entirely matching the parameter ordering of the Scala stdlib as well as cats. I'm opening to swapping them if you'd prefer.",
        "createdAt" : "2019-06-16T01:50:16Z",
        "updatedAt" : "2019-06-16T01:50:16Z",
        "lastEditedBy" : "cee4afcb-562c-48aa-98f9-d03a07569a08",
        "tags" : [
        ]
      },
      {
        "id" : "061cc5b8-76e9-45d8-bb1a-13a170f71caa",
        "parentId" : "90a6bef2-4cec-4a29-a759-19ec8feac91c",
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "Works for me!",
        "createdAt" : "2019-06-17T02:25:38Z",
        "updatedAt" : "2019-06-17T02:25:38Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      }
    ],
    "commit" : "cb8603cf799809ea364fa0cd128c9d3919a58f5a",
    "line" : 22,
    "diffHunk" : "@@ -1,1 +1187,1191 @@   * Fails with `e` if the predicate fails.\n   */\n  final def filterOrFail[E1 >: E](p: A => Boolean)(e: => E1): ZIO[R, E1, A] =\n    filterOrElse_[R, E1, A](p)(ZIO.fail(e))\n"
  }
]
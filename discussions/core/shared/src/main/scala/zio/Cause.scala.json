[
  {
    "id" : "cec48f7e-c618-4c8d-8a0d-5322094793e8",
    "prId" : 2169,
    "prUrl" : "https://github.com/zio/zio/pull/2169#pullrequestreview-314265702",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "618fc9b2-2ff3-4baa-9818-65fe6f15c900",
        "parentId" : null,
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "Missing Both?",
        "createdAt" : "2019-11-08T13:46:37Z",
        "updatedAt" : "2019-11-12T02:32:19Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      },
      {
        "id" : "0e2d7a7d-5f47-48e3-88fd-824ea0359936",
        "parentId" : "618fc9b2-2ff3-4baa-9818-65fe6f15c900",
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "`flattenSeq` should not flatten both. @adamgfraser fixed all this logic in the new one.",
        "createdAt" : "2019-11-08T15:16:17Z",
        "updatedAt" : "2019-11-12T02:32:19Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      }
    ],
    "commit" : "e597a3f9ff4c9895deccd1a7dc9ed0e94e93be52",
    "line" : 308,
    "diffHunk" : "@@ -1,1 +607,611 @@\n  private[Cause] def flattenSeq(c: Cause[_]): Vector[Cause[_]] = c match {\n    case Then(left, right) => flattenSeq(left) ++ flattenSeq(right)\n    case Traced(cause, _)  => flattenSeq(cause)\n    case o                 => Vector(o)"
  },
  {
    "id" : "5aca14b2-5caf-4eb1-bb14-1c69222f3915",
    "prId" : 1990,
    "prUrl" : "https://github.com/zio/zio/pull/1990#pullrequestreview-302963293",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5c0fc1c7-299a-4027-9c71-1865faba4e11",
        "parentId" : null,
        "authorId" : "524c15e0-b013-4ec4-bd1d-2b61884828d1",
        "body" : "Nice trick!",
        "createdAt" : "2019-10-16T20:33:00Z",
        "updatedAt" : "2019-10-17T07:13:45Z",
        "lastEditedBy" : "524c15e0-b013-4ec4-bd1d-2b61884828d1",
        "tags" : [
        ]
      },
      {
        "id" : "c7c68e51-9145-4b67-9ba4-7b344800608b",
        "parentId" : "5c0fc1c7-299a-4027-9c71-1865faba4e11",
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "Thanks!",
        "createdAt" : "2019-10-17T01:39:59Z",
        "updatedAt" : "2019-10-17T07:13:45Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      }
    ],
    "commit" : "c4a2611d9c2efc3ba5db68147d1fc6fb5f150d2c",
    "line" : 132,
    "diffHunk" : "@@ -1,1 +340,344 @@  private def foldLeft[Z](z: Z)(f: PartialFunction[(Z, Cause[E]), Z]): Z = {\n    @tailrec\n    def loop(z: Z, cause: Cause[E], stack: List[Cause[E]]): Z =\n      (f.applyOrElse[(Z, Cause[E]), Z](z -> cause, _ => z), cause) match {\n        case (z, Then(left, right)) => loop(z, left, right :: stack)"
  },
  {
    "id" : "b64e3df3-3816-4f15-854f-9a8ea5133567",
    "prId" : 1990,
    "prUrl" : "https://github.com/zio/zio/pull/1990#pullrequestreview-303034759",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "051a3c18-9603-4d41-b004-7dd2db164100",
        "parentId" : null,
        "authorId" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "body" : "I suggest `f.lift(cause) orElse ...` to avoid pattern matching",
        "createdAt" : "2019-10-17T06:41:38Z",
        "updatedAt" : "2019-10-17T07:13:45Z",
        "lastEditedBy" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "tags" : [
        ]
      },
      {
        "id" : "fc0b0c82-72a9-46f5-910a-1dd1a32322c3",
        "parentId" : "051a3c18-9603-4d41-b004-7dd2db164100",
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "The issue is if you do that the recursive call to `loop` is no longer in tail position.",
        "createdAt" : "2019-10-17T06:45:51Z",
        "updatedAt" : "2019-10-17T07:13:45Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      },
      {
        "id" : "62cce6f5-c00e-473a-ad70-9487103e800e",
        "parentId" : "051a3c18-9603-4d41-b004-7dd2db164100",
        "authorId" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "body" : "Yes indeed 👍 I should have put the comment below with this one 🤦‍♂ ",
        "createdAt" : "2019-10-17T06:51:40Z",
        "updatedAt" : "2019-10-17T07:13:45Z",
        "lastEditedBy" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "tags" : [
        ]
      }
    ],
    "commit" : "c4a2611d9c2efc3ba5db68147d1fc6fb5f150d2c",
    "line" : 110,
    "diffHunk" : "@@ -1,1 +320,324 @@    @tailrec\n    def loop(cause: Cause[E], stack: List[Cause[E]]): Option[Z] =\n      f.lift(cause) match {\n        case Some(z) => Some(z)\n        case None =>"
  },
  {
    "id" : "b16ac552-11a2-4fd1-8d57-8c129fa849a1",
    "prId" : 1990,
    "prUrl" : "https://github.com/zio/zio/pull/1990#pullrequestreview-303048876",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "29704e9a-21b7-4629-a6bd-3894979af946",
        "parentId" : null,
        "authorId" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "body" : "This is `cause.foldLeft(None) { case (_, cause) if f.isDefinedAt(cause) => Some(f(cause)) }`, so find could be written as\r\n```scala\r\nprivate def find[Z](f: PartialFunction[Cause[E], Z]): Option[Z] = {\r\n  f.lift(self) orElse foldLeft(None){ case (_, cause) if f.isDefinedAt(cause) => Some(f(cause)) }\r\n```\r\n",
        "createdAt" : "2019-10-17T06:47:42Z",
        "updatedAt" : "2019-10-17T07:13:45Z",
        "lastEditedBy" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "tags" : [
        ]
      },
      {
        "id" : "66932624-9e03-4588-854f-e833f5a76a6d",
        "parentId" : "29704e9a-21b7-4629-a6bd-3894979af946",
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "I think this would require us to traverse the entire data structure if `f.lift(self)` is `None`, because then we call `foldLeft` which always traverses the entire data structure. The `PartialFunction` in `foldLeft` controls whether a value from a particular cause will be added to the accumulator but can't terminate the traversal early.",
        "createdAt" : "2019-10-17T06:54:14Z",
        "updatedAt" : "2019-10-17T07:13:45Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      },
      {
        "id" : "7125cd90-54fe-4c4c-8f6c-23a879aa2644",
        "parentId" : "29704e9a-21b7-4629-a6bd-3894979af946",
        "authorId" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "body" : "Ha yeah right, you would need lazyness to get around that. Shame, that is elegant:\r\n```scala\r\nprivate def find[Z](f: PartialFunction[Cause[E], Z]): Option[Z] = {\r\n  f.lift(self) orElse foldLeft(None){ case (z, cause) if f.isDefinedAt(cause) => z orElse Some(f(cause)) }\r\n```\r\nOut of curiosity, why a `PartialFunction` in `foldLeft`?",
        "createdAt" : "2019-10-17T07:15:53Z",
        "updatedAt" : "2019-10-17T07:15:53Z",
        "lastEditedBy" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "tags" : [
        ]
      },
      {
        "id" : "cc5b313b-24ce-4024-b15c-504a597a996b",
        "parentId" : "29704e9a-21b7-4629-a6bd-3894979af946",
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "Yeah, if the fold was lazy we could do everything in terms of it, but laziness has its own cost.\r\n\r\nI'm not sure. That was the method signature before any of my changes. The main alternative I see is `(Z, Cause[E] => Option[Z]`, which is isomorphic, because you want to be able to both filter for certain types of causes and transform them. I think a partial function just creates nicer ergonomics for callers because they can pattern match on the `Cause` and don't have to wrap the result in `Some` or explicitly specify `None` for the other case.",
        "createdAt" : "2019-10-17T07:25:20Z",
        "updatedAt" : "2019-10-17T07:25:20Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      }
    ],
    "commit" : "c4a2611d9c2efc3ba5db68147d1fc6fb5f150d2c",
    "line" : 113,
    "diffHunk" : "@@ -1,1 +323,327 @@        case Some(z) => Some(z)\n        case None =>\n          cause match {\n            case Then(left, right) => loop(left, right :: stack)\n            case Both(left, right) => loop(left, right :: stack)"
  },
  {
    "id" : "e6b4f5ef-f997-4598-9ade-4c1f9990d206",
    "prId" : 1706,
    "prUrl" : "https://github.com/zio/zio/pull/1706#pullrequestreview-291470260",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8881a89b-e9ec-4e45-b797-2960d653471c",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "I'd make all the companion objects private, too.",
        "createdAt" : "2019-09-21T15:40:13Z",
        "updatedAt" : "2019-10-01T19:39:59Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      },
      {
        "id" : "d72b84d5-81a2-4c2c-936f-f647af1b824d",
        "parentId" : "8881a89b-e9ec-4e45-b797-2960d653471c",
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "We need these if we want to expose the `apply` methods on them. Normally I wouldn't do this but there is a good amount of code that uses them, and `then` is a reserved keyword so we can't use the normal lower case smart constructor for that. I could delete the companion objects and replace with methods with capitalized names or we could go through and change everything, maybe using `parallel` and `sequential` for the smart constructors, though that is wordier.",
        "createdAt" : "2019-09-21T15:48:43Z",
        "updatedAt" : "2019-10-01T19:39:59Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      }
    ],
    "commit" : "0f04654da637a0fac77e8753646cb68cabe1abf3",
    "line" : 327,
    "diffHunk" : "@@ -1,1 +393,397 @@  }\n\n  object Fail {\n    def apply[E](value: E): Cause[E] =\n      new Fail(value)"
  },
  {
    "id" : "46e202bd-0467-4b33-a81e-741c29e3763c",
    "prId" : 1117,
    "prUrl" : "https://github.com/zio/zio/pull/1117#pullrequestreview-256365792",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6f96525e-d652-4306-84ba-924a67f2a5f8",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "Don't forget the Apache copyright header, you can copy it from another file!",
        "createdAt" : "2019-07-01T14:18:09Z",
        "updatedAt" : "2019-07-01T14:53:38Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      }
    ],
    "commit" : "7a94edf818c768ace2306ceea08c8e259ded3faa",
    "line" : 17,
    "diffHunk" : "@@ -1,1 +15,19 @@ */\n\npackage zio\n\nsealed trait Cause[+E] extends Product with Serializable { self =>"
  }
]
[
  {
    "id" : "314a13ec-1314-4c00-a2f1-9c30a97c1fd2",
    "prId" : 3269,
    "prUrl" : "https://github.com/zio/zio/pull/3269#pullrequestreview-387161582",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2de196d1-dda1-4656-b78a-61aa6dc6c8d2",
        "parentId" : null,
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "These two methods should have the same signature.",
        "createdAt" : "2020-04-03T10:41:38Z",
        "updatedAt" : "2020-04-03T11:07:11Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      },
      {
        "id" : "0971fd45-cbc6-4360-b84d-3f88a3360fb5",
        "parentId" : "2de196d1-dda1-4656-b78a-61aa6dc6c8d2",
        "authorId" : "c7a38fcf-9440-4855-908f-2b4369a39b08",
        "body" : "Right! Fixed.",
        "createdAt" : "2020-04-03T11:07:48Z",
        "updatedAt" : "2020-04-03T11:07:48Z",
        "lastEditedBy" : "c7a38fcf-9440-4855-908f-2b4369a39b08",
        "tags" : [
        ]
      }
    ],
    "commit" : "165869b7d3098056e75d8663829eaeb91b4ed3bf",
    "line" : 10,
    "diffHunk" : "@@ -1,1 +2046,2050 @@     * outputs of both this layer and the specified layer.\n     */\n    def >+>[E1 >: E, RIn2 >: ROut, ROut1 >: ROut, ROut2 <: Has[_]](\n      that: ZLayer[RIn2, E1, ROut2]\n    )(implicit tagged: Tagged[ROut2]): ZLayer[RIn, E1, ROut1 with ROut2] ="
  },
  {
    "id" : "dca378a4-e2c7-4c89-b654-3c4147a8a603",
    "prId" : 3116,
    "prUrl" : "https://github.com/zio/zio/pull/3116#pullrequestreview-373959296",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f3d4441d-c412-4479-b534-d330171baf10",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "Not to delay further but I'm not sure they are alphabetized. I'll approve though!",
        "createdAt" : "2020-03-12T23:14:07Z",
        "updatedAt" : "2020-03-12T23:14:08Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      },
      {
        "id" : "2e4b21db-1c11-4a45-b80a-b5f376010fe9",
        "parentId" : "f3d4441d-c412-4479-b534-d330171baf10",
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "I think they are but `and` just appears far down in the file because it is in the syntax class that provides evidence that the output type is a subtype of `Has[_]`.",
        "createdAt" : "2020-03-12T23:15:58Z",
        "updatedAt" : "2020-03-12T23:15:58Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      }
    ],
    "commit" : "fe62dd8f2da3bf17027a9347427a78bbe15e4c43",
    "line" : 20,
    "diffHunk" : "@@ -1,1 +2044,2048 @@      * A named alias for `++`.\n      */\n    def and[E1 >: E, RIn2, ROut1 >: ROut, ROut2 <: Has[_]](\n      that: ZLayer[RIn2, E1, ROut2]\n    )(implicit tagged: Tagged[ROut2]): ZLayer[RIn with RIn2, E1, ROut1 with ROut2] ="
  },
  {
    "id" : "cb67c67b-33d0-4c9f-aa67-d25a3a08eb38",
    "prId" : 2930,
    "prUrl" : "https://github.com/zio/zio/pull/2930#pullrequestreview-360944554",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1c364664-e7b9-439b-9fad-b1db1e9d182d",
        "parentId" : null,
        "authorId" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "body" : "I'm wondering if you should maybe use `uninterruptibleMask` to make sure the `observers` ref is always updated?",
        "createdAt" : "2020-02-19T07:44:40Z",
        "updatedAt" : "2020-02-19T10:04:09Z",
        "lastEditedBy" : "4f7a0777-ad97-4424-aa99-3fcea1de6a97",
        "tags" : [
        ]
      },
      {
        "id" : "5c87ede0-87ba-49ea-90f3-15013177cc31",
        "parentId" : "1c364664-e7b9-439b-9fad-b1db1e9d182d",
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "I think we are okay because `observers` is always updated in either the `acquire` or `release` action of a `Managed`.",
        "createdAt" : "2020-02-19T09:13:22Z",
        "updatedAt" : "2020-02-19T10:04:09Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      }
    ],
    "commit" : "baf7dac2fc867537025e824c1f168f64a47225cc",
    "line" : 127,
    "diffHunk" : "@@ -1,1 +465,469 @@                      } yield (\n                        Reservation(\n                          observers.update(_ + 1) *>\n                            reservation.acquire.to(promise) *> promise.await,\n                          _ =>"
  },
  {
    "id" : "4cb64dc1-11f4-477b-b228-9eb2c6fa4b65",
    "prId" : 2864,
    "prUrl" : "https://github.com/zio/zio/pull/2864#pullrequestreview-357082306",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2e561877-ec9e-4751-90d0-e7c10e127c90",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "I noticed (like you pointed out) this is a specialization fo `++` when `ROut2` is just a single `Has` that is already a part of `ROut`.\r\n\r\nThe implementation is almost the same, except instead of `union`, `update` is being called to do a targeted replacement of `A`.\r\n\r\nI wonder why `union` would not overwrite in this case? In theory, `l union r` should always cause `r` to overwrite any parts already contained by `l`.\r\n\r\nAny thoughts on this?",
        "createdAt" : "2020-02-11T12:46:07Z",
        "updatedAt" : "2020-02-11T12:46:07Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      },
      {
        "id" : "32eab94c-3e54-4a0b-ae98-fe22d98c7f64",
        "parentId" : "2e561877-ec9e-4751-90d0-e7c10e127c90",
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "I agree. I haven't done a deep dive on this yet. Maybe something to do with the ordering of the underlying map implementations? I can look into this.",
        "createdAt" : "2020-02-11T13:23:30Z",
        "updatedAt" : "2020-02-11T13:23:30Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      },
      {
        "id" : "db43320c-98c0-4b9f-a411-45fd7ce98f0f",
        "parentId" : "2e561877-ec9e-4751-90d0-e7c10e127c90",
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "It looks like when `l` and `r` are combined with `union` in `++` we get a `Has` instance that has two entries in the map associated with the `Clock`, which is leading to the indeterminacy.",
        "createdAt" : "2020-02-11T20:25:55Z",
        "updatedAt" : "2020-02-11T20:25:55Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      },
      {
        "id" : "c3947b8a-448a-4795-a0e8-58dd4a14ca69",
        "parentId" : "2e561877-ec9e-4751-90d0-e7c10e127c90",
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "More updates on this. I think the issue is that in addition to having a string representation type tags have a hash code and the hash code is not always the same for the same type. In particular, it appears that if a type tag is summoned from different compilation units the hash code will be different. So for example if I print `implicitly[Tagged[Has[Clock.Service]]]` from `zio.clock` and `zio.test.environment.EnvironmentSpec` they will have different hash codes. That's why we're getting duplicate entries in the map underlying `Has`. When we do `unionAll` in `Has` we're assuming that we will just overwrite the old implementations of the same service but instead we're adding a second one.\r\n\r\nI think we probably want to say that two tags are equal if they have are for the same type so I think we probably either need our own type to wrap tags that hashes them based on their string representation or a specialized map for type tags that hashes them based on their string representation.",
        "createdAt" : "2020-02-11T21:31:08Z",
        "updatedAt" : "2020-02-11T21:31:08Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      },
      {
        "id" : "179cf985-95e4-4634-9fef-57d86f8e6f3f",
        "parentId" : "2e561877-ec9e-4751-90d0-e7c10e127c90",
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "Oh my. Well, Kai did warn us. ðŸ˜†  \r\n\r\nI think we absolutely will replace `TypeTag` but until then we could wrap it in something like:\r\n\r\n```scala\r\ncase class FixedTypeTag[A](value: TypeTag[A]) {\r\n  override def equals(that: Any): Boolean = \r\n    that match { case FixedTypeTag(that) => value.toString == that.toString }\r\n  override def hashCode = value.toString.hashCode\r\n}\r\n```\r\n\r\nThen `Tagged[A]` becomes `FixedTypeTag[A]` and no ZIO code (outside that package object) needs to know how broken it is. Obviously we gotta fix the problem at the source for RC18.",
        "createdAt" : "2020-02-11T23:40:46Z",
        "updatedAt" : "2020-02-11T23:40:46Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      }
    ],
    "commit" : "bb7567845a1e8da1c3b894327f7c34e271dab211",
    "line" : 33,
    "diffHunk" : "@@ -1,1 +128,132 @@          l <- memoMap.getOrElseMemoize(self, finalizerRef)\n          r <- memoMap.getOrElseMemoize(that, finalizerRef)\n        } yield l.update[A](_ => r.get[A])\n      }\n    )"
  },
  {
    "id" : "595064b9-74a5-4595-8ecf-1244cba85894",
    "prId" : 2864,
    "prUrl" : "https://github.com/zio/zio/pull/2864#pullrequestreview-356626946",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "19577cae-29ae-4793-9eec-cc1047e7cfc8",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "Looks great!",
        "createdAt" : "2020-02-11T12:46:23Z",
        "updatedAt" : "2020-02-11T12:46:24Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      }
    ],
    "commit" : "bb7567845a1e8da1c3b894327f7c34e271dab211",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +102,106 @@   * Returns a new layer whose output is mapped by the specified function.\n   */\n  def map[ROut1 >: ROut <: Has[_]](f: ROut => ROut1): ZLayer[RIn, E, ROut1] =\n    self >>> ZLayer.fromEnvironment(f)\n"
  },
  {
    "id" : "357262b1-86f9-4247-a1fd-09d185d992d8",
    "prId" : 2864,
    "prUrl" : "https://github.com/zio/zio/pull/2864#pullrequestreview-356627343",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d1944504-092f-4029-9086-35083b6d0383",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "Nice cleanup!",
        "createdAt" : "2020-02-11T12:47:02Z",
        "updatedAt" : "2020-02-11T12:47:02Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      }
    ],
    "commit" : "bb7567845a1e8da1c3b894327f7c34e271dab211",
    "line" : 50,
    "diffHunk" : "@@ -1,1 +143,147 @@   */\n  def update[A: Tagged](f: A => A)(implicit ev: ROut <:< Has[A]): ZLayer[RIn, E, ROut] =\n    self >>> ZLayer.fromEnvironment(_.update[A](f))\n}\n"
  },
  {
    "id" : "3062fdd1-d14e-462e-9c41-cfa4e8ed4266",
    "prId" : 2775,
    "prUrl" : "https://github.com/zio/zio/pull/2775#pullrequestreview-355442170",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0dd0843f-1e50-4604-93ed-37180f2c2f45",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "Nice cleanups",
        "createdAt" : "2020-02-07T21:17:21Z",
        "updatedAt" : "2020-02-07T21:21:40Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      }
    ],
    "commit" : "18d413b38aac22fe3187ddd44df3b8c9704de52c",
    "line" : 122,
    "diffHunk" : "@@ -1,1 +153,157 @@   * Constructs a layer that purely depends on the specified service.\n   */\n  def fromService[A: Tagged, B <: Has[_]](f: A => B): ZLayer[Has[A], Nothing, B] =\n    ZLayer(ZManaged.fromEffect(ZIO.access[Has[A]](m => f(m.get[A]))))\n"
  },
  {
    "id" : "c553f700-0a9f-4018-a10f-d0e1e76ae60b",
    "prId" : 2775,
    "prUrl" : "https://github.com/zio/zio/pull/2775#pullrequestreview-355496035",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9e406933-ad39-4d82-8987-aa4f1823a37c",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "Is this safe for arbitrary interruption, or would it be useful to add `uninterruptibleMask` to protect critical regions, and allow interruption only some places (e.g. `reservation.acquire`?)?",
        "createdAt" : "2020-02-07T21:25:29Z",
        "updatedAt" : "2020-02-07T21:25:30Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      },
      {
        "id" : "afd60d37-04ae-4bab-87fd-2354f1c872fc",
        "parentId" : "9e406933-ad39-4d82-8987-aa4f1823a37c",
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "So I think we are okay here but it is definitely the right question. My analysis is:\r\n\r\n1. First we check if the dependency is in the map and if so just return it. I don't think there is any problem with being interrupted here because we haven't acquired any resources at this point that require finalization.\r\n2. If we don't have the resource yet, we do `layer.scope.flatMap(_.apply(self))` which creates one Managed that describes entering both the inner and outer scopes to create the dependency.\r\n3. Then we call `reserve` on it to access the `acquire` and `release` actions of the managed separately but we still haven't actually acquired any resources.\r\n4. The actual acquisition of resources comes in `reservation.acquire` which is in this reservation we are constructing that will create a new `Managed`, so the acquisition of the dependency and adding it to the memo map will be uninterruptible and if it starts the finalizers are guaranteed to be added to the outer scope, also uninterruptibly, because that is in the release action of the managed.",
        "createdAt" : "2020-02-07T21:34:57Z",
        "updatedAt" : "2020-02-07T21:34:58Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      },
      {
        "id" : "a930a2d7-5322-41c5-aa6d-c6110a342485",
        "parentId" : "9e406933-ad39-4d82-8987-aa4f1823a37c",
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "It's tricky, but I think you're right..",
        "createdAt" : "2020-02-07T23:31:33Z",
        "updatedAt" : "2020-02-07T23:31:33Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      }
    ],
    "commit" : "18d413b38aac22fe3187ddd44df3b8c9704de52c",
    "line" : 242,
    "diffHunk" : "@@ -1,1 +405,409 @@    ): ZManaged[A, E, B] =\n      ZManaged {\n        get(layer).flatMap {\n          case Some(b) => ZIO.succeedNow(Reservation(ZIO.succeedNow(b), _ => UIO.unit))\n          case None =>"
  }
]
[
  {
    "id" : "171845e7-6e30-464f-bf85-8c666c0794ca",
    "prId" : 453,
    "prUrl" : "https://github.com/zio/zio/pull/453#pullrequestreview-185037845",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d9343879-252a-4518-a7ac-f674495ecaf4",
        "parentId" : null,
        "authorId" : "05793de5-8cbe-49ba-90b1-8ef51f2dd854",
        "body" : "should add a method for` awaitTermination ` too.",
        "createdAt" : "2018-12-14T09:59:35Z",
        "updatedAt" : "2018-12-14T09:59:35Z",
        "lastEditedBy" : "05793de5-8cbe-49ba-90b1-8ef51f2dd854",
        "tags" : [
        ]
      }
    ],
    "commit" : "622be4e1e59fd8403ed9ae65a9ddd3ef75dda553",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +16,20 @@    env.unsafeRunAsync(io, k)\n\n  final def shutdown(): Unit = env.shutdown()\n}"
  },
  {
    "id" : "d1ef37a0-f093-42d6-9061-d075971617e1",
    "prId" : 397,
    "prUrl" : "https://github.com/zio/zio/pull/397#pullrequestreview-179876782",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9dc7513c-9b6d-418f-b590-67a6a2a8dc2f",
        "parentId" : null,
        "authorId" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "body" : "`if(shouldDie)`?",
        "createdAt" : "2018-11-29T10:38:56Z",
        "updatedAt" : "2018-11-29T16:47:40Z",
        "lastEditedBy" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "tags" : [
        ]
      },
      {
        "id" : "ef586eaf-0694-4af7-b25c-23c103ad0fd0",
        "parentId" : "9dc7513c-9b6d-418f-b590-67a6a2a8dc2f",
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "`shouldDie` is cached in each thread, so it's stale (however, it's much faster to access than `state.get.interrupted`). So here we have to use the slow method to make sure we evade race conditions between the start of an async action and a kill attempt.",
        "createdAt" : "2018-11-29T16:07:01Z",
        "updatedAt" : "2018-11-29T16:47:40Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      }
    ],
    "commit" : "ecd7e7f21f9080b3facbc2a9acaea1ed1b64c715",
    "line" : 137,
    "diffHunk" : "@@ -1,1 +356,360 @@                      // otherwise, it would not be interrupted).\n                      try {\n                        if (state.get.interrupted && noInterrupt == 0) curIo = IO.interrupt\n                        else\n                          io.register(resumeAsync) match {"
  },
  {
    "id" : "8b7a0910-506f-4f6a-918b-2c7c58d72ae9",
    "prId" : 389,
    "prUrl" : "https://github.com/zio/zio/pull/389#pullrequestreview-180787255",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2c417771-db6c-4a69-bb27-a1c4b2524c83",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "@ghostdogpr Can you turn this into `val` and not `lazy val` in a follow-up PR? `lazy val` will synchronize which will impose performance penalty.",
        "createdAt" : "2018-12-03T12:58:14Z",
        "updatedAt" : "2018-12-03T12:58:14Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      },
      {
        "id" : "84aded18-f060-469c-ab8d-2d42af5e8ed4",
        "parentId" : "2c417771-db6c-4a69-bb27-a1c4b2524c83",
        "authorId" : "73db9f28-01ba-4a29-946b-7a2ae5ac5350",
        "body" : "Oops, sure!",
        "createdAt" : "2018-12-03T14:21:50Z",
        "updatedAt" : "2018-12-03T14:21:50Z",
        "lastEditedBy" : "73db9f28-01ba-4a29-946b-7a2ae5ac5350",
        "tags" : [
        ]
      }
    ],
    "commit" : "7cb229ed92dbf0330f2545e7b12a727dc92fc493",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +67,71 @@   * The fiber's execution context.\n   */\n  lazy val executionContext = ExecutionContext.fromExecutor(threadPool)\n\n  /**"
  },
  {
    "id" : "02396d29-0c09-4364-818c-206896548929",
    "prId" : 376,
    "prUrl" : "https://github.com/zio/zio/pull/376#pullrequestreview-178043907",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1a76aa45-7c9d-498c-ba63-2d6ac2a24e12",
        "parentId" : null,
        "authorId" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "body" : "This is so much easier to read!",
        "createdAt" : "2018-11-24T08:26:00Z",
        "updatedAt" : "2018-11-24T14:26:16Z",
        "lastEditedBy" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "tags" : [
        ]
      }
    ],
    "commit" : "022be82057c72021151ee9dc3f44b8b8acaa66f4",
    "line" : 442,
    "diffHunk" : "@@ -1,1 +707,711 @@            val cancel = status.cancel.getOrElse(IO.unit)\n\n            rts.submit(evaluate(cancel *> IO.interrupt))\n\n            Async.later"
  },
  {
    "id" : "87b96af4-c513-46e2-8027-5b53d8f59a7e",
    "prId" : 376,
    "prUrl" : "https://github.com/zio/zio/pull/376#pullrequestreview-178052792",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d30ba7c7-2a5c-43c5-b213-3769579a09df",
        "parentId" : null,
        "authorId" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "body" : "Isn't it faster to just inline in `Running` and `Suspended`?",
        "createdAt" : "2018-11-24T08:30:40Z",
        "updatedAt" : "2018-11-24T14:26:16Z",
        "lastEditedBy" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "tags" : [
        ]
      },
      {
        "id" : "8de1db90-4190-4fb6-b474-6e76e4087f28",
        "parentId" : "d30ba7c7-2a5c-43c5-b213-3769579a09df",
        "authorId" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "body" : "In fact you can get rid of `FiberStatus` and just have an `Option[IO[Nothing, Unit]]`. When running, it is `None`, otherwise it is `Some(IO.unit)` (or a custom canceler). Then `suspended` can be replaced with a simple pattern match.",
        "createdAt" : "2018-11-24T08:55:31Z",
        "updatedAt" : "2018-11-24T14:26:16Z",
        "lastEditedBy" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "tags" : [
        ]
      },
      {
        "id" : "3ccf202d-eeeb-40cf-a5a8-dbeb099b4026",
        "parentId" : "d30ba7c7-2a5c-43c5-b213-3769579a09df",
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "Unfortunately, there is `Running`, `Suspending` (when the async action has been started but before the `register` has returned, which gives us a canceler), and `Suspended` (which has a canceler). So it's tri state and we'd need something like `Either[Unit, Option[Cancel]]`, which becomes harder to understand than `FiberStatus`.",
        "createdAt" : "2018-11-24T14:15:25Z",
        "updatedAt" : "2018-11-24T14:26:16Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      },
      {
        "id" : "965b401d-c035-4204-9d56-c6e4086c8e46",
        "parentId" : "d30ba7c7-2a5c-43c5-b213-3769579a09df",
        "authorId" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "body" : "Yes, here's what I thought:\r\n- `Running â‰¡ None`\r\n- `Suspending â‰¡ Some(IO.unit)`\r\n- `Suspended â‰¡ Some(cancel)`\r\n\r\n It's probably too subtle and could lead to errors, let's keep it that way ðŸ‘ ",
        "createdAt" : "2018-11-24T14:28:04Z",
        "updatedAt" : "2018-11-24T14:28:05Z",
        "lastEditedBy" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "tags" : [
        ]
      },
      {
        "id" : "57d75c0e-02ee-4320-b234-1d51c75339b1",
        "parentId" : "d30ba7c7-2a5c-43c5-b213-3769579a09df",
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "Ah, I see, and then just swap out the dummy cancel when the new one comes in. That should work! I will try to change this next time I'm in there. ",
        "createdAt" : "2018-11-24T14:41:04Z",
        "updatedAt" : "2018-11-24T14:41:04Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      }
    ],
    "commit" : "022be82057c72021151ee9dc3f44b8b8acaa66f4",
    "line" : 521,
    "diffHunk" : "@@ -1,1 +758,762 @@  }\n  sealed abstract class FiberStatus extends Serializable with Product {\n    final def suspended: Boolean = this match {\n      case FiberStatus.Running      => false\n      case FiberStatus.Suspended(_) => true"
  },
  {
    "id" : "94db93eb-b7af-4d2e-8cb4-98a1e3c23911",
    "prId" : 376,
    "prUrl" : "https://github.com/zio/zio/pull/376#pullrequestreview-178052181",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7445d6bd-932d-4696-af1e-723085a484f1",
        "parentId" : null,
        "authorId" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "body" : "`final val`",
        "createdAt" : "2018-11-24T08:32:49Z",
        "updatedAt" : "2018-11-24T14:26:16Z",
        "lastEditedBy" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "tags" : [
        ]
      },
      {
        "id" : "19559b5b-75f8-4b69-8a75-eb84a7ed5f5d",
        "parentId" : "7445d6bd-932d-4696-af1e-723085a484f1",
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "If we use `val`, it will store memory for `interrupted` even if it's not used. But we can recompute it on the fly if it's called, so I think it's better to use `def` to save memory (calling it will be uncommon).",
        "createdAt" : "2018-11-24T14:16:04Z",
        "updatedAt" : "2018-11-24T14:26:16Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      }
    ],
    "commit" : "022be82057c72021151ee9dc3f44b8b8acaa66f4",
    "line" : 559,
    "diffHunk" : "@@ -1,1 +784,788 @@    ) extends FiberState[E, A]\n    final case class Done[E, A](value: ExitResult[E, A]) extends FiberState[E, A] {\n      def interrupted: Boolean = value.interrupted\n    }\n"
  },
  {
    "id" : "d071d890-d9d3-49ab-b459-20a929a84dd7",
    "prId" : 342,
    "prUrl" : "https://github.com/zio/zio/pull/342#pullrequestreview-171360377",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d6496da3-51c4-49a5-bf18-02ce5f040d61",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "Hmmm, this suggests to me the solution is more complex than just introducing `selfInterrupt`.\r\n\r\nThe runtime system really wants a term in `IO` for interruption, e.g.:\r\n\r\n```scala\r\nclass Interrupt(causes: List[Throwable], defects: List[Throwable] extends IO[Nothing, Nothing]\r\n```\r\n\r\npermitting a method:\r\n\r\n```scala\r\nobject IO {\r\n  ...\r\n  def interrupt(causes: List[Throwable], defects: List[Throwable])\r\n  ...\r\n}\r\n```\r\n\r\nwhich will perform self-interruption.\r\n\r\nIntroducing this term could actually simplify some core logic because it's possible (though not certain) we could remove causes / defects from the fiber state with enough work.",
        "createdAt" : "2018-11-04T11:32:45Z",
        "updatedAt" : "2018-11-09T01:44:35Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      },
      {
        "id" : "125be24f-d03e-4f3f-8cea-42d3dd606a0f",
        "parentId" : "d6496da3-51c4-49a5-bf18-02ce5f040d61",
        "authorId" : "73db9f28-01ba-4a29-946b-7a2ae5ac5350",
        "body" : "Yeah I was leaning towards that too. Seems it's the only way to handle self interruption if we want to remove `terminate` without throwable (which is currently used).",
        "createdAt" : "2018-11-04T12:22:21Z",
        "updatedAt" : "2018-11-09T01:44:35Z",
        "lastEditedBy" : "73db9f28-01ba-4a29-946b-7a2ae5ac5350",
        "tags" : [
        ]
      }
    ],
    "commit" : "3a03e319bc75fd45669400738c0a1117e86bb1a5",
    "line" : 316,
    "diffHunk" : "@@ -1,1 +531,535 @@\n              // Fiber was interrupted\n              curIo = IO.interrupt\n            }\n"
  },
  {
    "id" : "38d729f1-2516-4e09-a74c-64cfeab4c51d",
    "prId" : 342,
    "prUrl" : "https://github.com/zio/zio/pull/342#pullrequestreview-171559711",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "46055041-d264-4bcb-aa92-5715bff4e0a1",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "This whole section of code shows accretion of small changes that now require a refactor.\r\n\r\nIn particular, the old representation inside the state (which splits things into termination causes and defects) is breaking down and should be replaced by a `Cause`.\r\n\r\nThen we can simply `++` causes generated during finalizers. It will dramatically simplify all this code and make it much more likely to be correct.",
        "createdAt" : "2018-11-05T15:57:36Z",
        "updatedAt" : "2018-11-09T01:44:35Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      }
    ],
    "commit" : "3a03e319bc75fd45669400738c0a1117e86bb1a5",
    "line" : 262,
    "diffHunk" : "@@ -1,1 +483,487 @@                        // No finalizer, so immediately produce the error.\n                        curIo = null\n\n                        val cause = if (status.get.interrupted) io.cause ++ Cause.interrupted else io.cause\n                        result = ExitResult.failed(cause)"
  },
  {
    "id" : "a140a177-7391-4202-8877-deacd6d04aa5",
    "prId" : 342,
    "prUrl" : "https://github.com/zio/zio/pull/342#pullrequestreview-172549934",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "52efd246-a7cf-44d6-acef-551c1d8f0de4",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "The comment can be revised since we're deleting causes of interruption and turning `terminationCauses` into a simple `interrupted: Boolean`.",
        "createdAt" : "2018-11-07T15:37:02Z",
        "updatedAt" : "2018-11-09T01:44:35Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      }
    ],
    "commit" : "3a03e319bc75fd45669400738c0a1117e86bb1a5",
    "line" : 316,
    "diffHunk" : "@@ -1,1 +531,535 @@\n              // Fiber was interrupted\n              curIo = IO.interrupt\n            }\n"
  },
  {
    "id" : "b8dae32f-efac-499e-b647-ce49f5d2e097",
    "prId" : 342,
    "prUrl" : "https://github.com/zio/zio/pull/342#pullrequestreview-172989843",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4b03e626-148d-49f4-9fe7-9e85721b0db2",
        "parentId" : null,
        "authorId" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "body" : "Am I correct to say that this reduces the memory footprint of a approximately fiber by half?",
        "createdAt" : "2018-11-08T09:29:43Z",
        "updatedAt" : "2018-11-09T01:44:35Z",
        "lastEditedBy" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "tags" : [
        ]
      },
      {
        "id" : "da4f3d07-3270-4bf1-af5c-0ac04449ee15",
        "parentId" : "4b03e626-148d-49f4-9fe7-9e85721b0db2",
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "Of the `FiberStatus`, yes (although not quite half), although the `FiberContext` has other crap (stack, etc.).",
        "createdAt" : "2018-11-08T15:50:07Z",
        "updatedAt" : "2018-11-09T01:44:35Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      }
    ],
    "commit" : "3a03e319bc75fd45669400738c0a1117e86bb1a5",
    "line" : 650,
    "diffHunk" : "@@ -1,1 +900,904 @@  object FiberStatus extends Serializable {\n    final case class Executing[E, A](\n      interrupted: Boolean,\n      observers: List[Callback[Nothing, ExitResult[E, A]]]\n    ) extends FiberStatus[E, A]"
  },
  {
    "id" : "626e611b-cf57-4e0d-a728-72b54d73d6e9",
    "prId" : 342,
    "prUrl" : "https://github.com/zio/zio/pull/342#pullrequestreview-172989843",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fb89c909-13a2-4736-8a71-d684efc28221",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "```scala\r\nc1.flatMap(c1 => c2.map(c1 ++ _)).orElse(c1).orElse(c2)\r\n```",
        "createdAt" : "2018-11-08T15:39:30Z",
        "updatedAt" : "2018-11-09T01:44:35Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      }
    ],
    "commit" : "3a03e319bc75fd45669400738c0a1117e86bb1a5",
    "line" : 141,
    "diffHunk" : "@@ -1,1 +262,266 @@    }\n\n    private final def zipCauses(c1: Option[Cause[Nothing]], c2: Option[Cause[Nothing]]): Option[Cause[Nothing]] =\n      c1.flatMap(c1 => c2.map(c1 ++ _)).orElse(c1).orElse(c2)\n"
  },
  {
    "id" : "6edf523d-6ea6-413b-a3dc-6a06c2e6769b",
    "prId" : 342,
    "prUrl" : "https://github.com/zio/zio/pull/342#pullrequestreview-172989843",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "08461584-97a1-4b80-be82-2984d9c935c5",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "This logic is 10x better than the old logic!",
        "createdAt" : "2018-11-08T15:45:57Z",
        "updatedAt" : "2018-11-09T01:44:35Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      }
    ],
    "commit" : "3a03e319bc75fd45669400738c0a1117e86bb1a5",
    "line" : 281,
    "diffHunk" : "@@ -1,1 +495,499 @@                    } else {\n                      // Error caught:\n                      if (finalizer eq null) {\n                        curIo = nextInstr[E](io.cause, stack)\n                      } else {"
  },
  {
    "id" : "6219c310-c0fa-49cd-bfda-46c6103fe68f",
    "prId" : 306,
    "prUrl" : "https://github.com/zio/zio/pull/306#pullrequestreview-169160366",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "45edca1d-3d9c-4bcc-ab17-6ebeb8a2fd27",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "This will have an effect on performance. Have you done benchmarks before / after?\r\n\r\nOtherwise, this PR looks great and ready to merge!",
        "createdAt" : "2018-10-28T09:33:11Z",
        "updatedAt" : "2018-10-28T09:33:21Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      },
      {
        "id" : "59c51cfc-643b-4eac-815c-dd8866342ab3",
        "parentId" : "45edca1d-3d9c-4bcc-ab17-6ebeb8a2fd27",
        "authorId" : "94a9bd21-bc51-4681-8e4e-61d5917ea48f",
        "body" : "@jdegoes yep, a couple messages above I posted results https://github.com/scalaz/scalaz-zio/pull/306#issuecomment-432246993 I didn't have the opportunity to run all 20 forks, but nothing seemed crazy off, so I assumed it's a safe change. ",
        "createdAt" : "2018-10-29T06:10:58Z",
        "updatedAt" : "2018-10-29T06:10:58Z",
        "lastEditedBy" : "94a9bd21-bc51-4681-8e4e-61d5917ea48f",
        "tags" : [
        ]
      },
      {
        "id" : "0d2006e0-6223-4829-adee-c31c71d36ff8",
        "parentId" : "45edca1d-3d9c-4bcc-ab17-6ebeb8a2fd27",
        "authorId" : "94a9bd21-bc51-4681-8e4e-61d5917ea48f",
        "body" : "For the context - @regiskuckaertz suggested to change MaxOpCount to improve the situation in this scenario https://github.com/scalaz/scalaz-zio/issues/273",
        "createdAt" : "2018-10-29T06:13:53Z",
        "updatedAt" : "2018-10-29T06:13:53Z",
        "lastEditedBy" : "94a9bd21-bc51-4681-8e4e-61d5917ea48f",
        "tags" : [
        ]
      }
    ],
    "commit" : "873c7e2e719d4405e1cb6c3143a24cbd3887c6a2",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +73,77 @@   * FIXME: Replace this entirely with the new scheme.\n   */\n  val YieldMaxOpCount = 1024\n\n  lazy val scheduledExecutor = newDefaultScheduledExecutor()"
  },
  {
    "id" : "5a056b2b-8eaa-407e-809e-d39070b253a3",
    "prId" : 299,
    "prUrl" : "https://github.com/zio/zio/pull/299#pullrequestreview-164665357",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a87e7a5f-311c-4cc8-8d67-3fe476e4e4fb",
        "parentId" : null,
        "authorId" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "body" : "I had another version that was much simpler:\r\n```scala\r\nval f: IO[Nothing, Unit] = fork(f0.finalizer, accumFailures).observe.void\r\n```\r\nwhich allowed me to get rid of `collectDefect` and `zipFailures`; however, the unhandled errors handler action is submitted on the thread pool, so there is no guarantee of ordering.",
        "createdAt" : "2018-10-13T15:35:46Z",
        "updatedAt" : "2018-10-13T15:36:27Z",
        "lastEditedBy" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "tags" : [
        ]
      },
      {
        "id" : "caca39a2-6723-48d0-ad7f-315814500f3b",
        "parentId" : "a87e7a5f-311c-4cc8-8d67-3fe476e4e4fb",
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "Exactly, and finalizers must be linearly ordered.",
        "createdAt" : "2018-10-15T11:43:50Z",
        "updatedAt" : "2018-10-15T11:43:50Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      }
    ],
    "commit" : "55c18429107e92249838464a4c53e7a4b299ab85",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +280,284 @@        stack.pop() match {\n          case f0: Finalizer =>\n            val f: IO[Nothing, Option[List[Throwable]]] = fork(f0.finalizer, _ => IO.unit).observe.map(collectDefect)\n            if (finalizer eq null) finalizer = f\n            else finalizer = finalizer.seqWith(f)(zipFailures)"
  },
  {
    "id" : "c3310997-f844-4150-ae85-5c49db1c31c3",
    "prId" : 295,
    "prUrl" : "https://github.com/zio/zio/pull/295#pullrequestreview-163610546",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6e237469-e983-465a-b323-05a57f571e23",
        "parentId" : null,
        "authorId" : "02674bd6-d0ac-4b09-b920-a5e05b0a5cad",
        "body" : "I would recomend you to copy all that \"securitymanager\" crap from default thread factory or at least make the factory configurable by user (just make it a field in RTS).",
        "createdAt" : "2018-10-11T00:24:07Z",
        "updatedAt" : "2018-10-16T00:56:21Z",
        "lastEditedBy" : "02674bd6-d0ac-4b09-b920-a5e05b0a5cad",
        "tags" : [
        ]
      }
    ],
    "commit" : "35789ce62c5d03de05397f2691b58b0bbfdeecf7",
    "line" : 43,
    "diffHunk" : "@@ -1,1 +1122,1126 @@  }\n\n  final class NamedThreadFactory(name: String, daemon: Boolean) extends ThreadFactory {\n\n    private val parentGroup ="
  },
  {
    "id" : "d039cb97-8a1f-4711-b560-b5f8199f5cb2",
    "prId" : 260,
    "prUrl" : "https://github.com/zio/zio/pull/260#pullrequestreview-158067134",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4dffcf1e-58af-493d-854a-afbf599d8510",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "Love all this simplification!",
        "createdAt" : "2018-09-24T11:48:26Z",
        "updatedAt" : "2018-09-25T12:21:33Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      }
    ],
    "commit" : "838bea108a7804e9f74a58d7f5a1d580cf9a6ea0",
    "line" : 64,
    "diffHunk" : "@@ -1,1 +781,785 @@\n      oldStatus match {\n        case AsyncRegion(terminationCauses, defects, reentrancy, resume, cancel, observers) =>\n          val newReentrancy = reentrancy + 1\n"
  },
  {
    "id" : "da529243-c00b-4e4d-bc49-bb1e5e36df2b",
    "prId" : 260,
    "prUrl" : "https://github.com/zio/zio/pull/260#pullrequestreview-158386515",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "07c50ad5-3af0-44be-80b4-6084d52e5ea9",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "It's wonderful to see these errors no longer thrown away. You caught all the places we were throwing away errors? I could just recall this one off the top of my head.",
        "createdAt" : "2018-09-24T20:38:39Z",
        "updatedAt" : "2018-09-25T12:21:33Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      },
      {
        "id" : "d2e161c5-b89f-4a1e-aacf-5db37b1ed0a2",
        "parentId" : "07c50ad5-3af0-44be-80b4-6084d52e5ea9",
        "authorId" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "body" : "I haven't changed the signature of `redeem` (multiple combinators rely on it), I think this is the only place left.",
        "createdAt" : "2018-09-25T05:58:12Z",
        "updatedAt" : "2018-09-25T12:21:33Z",
        "lastEditedBy" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "tags" : [
        ]
      }
    ],
    "commit" : "838bea108a7804e9f74a58d7f5a1d580cf9a6ea0",
    "line" : 29,
    "diffHunk" : "@@ -1,1 +654,658 @@          else evaluate(io)\n\n        case ExitResult.Failed(t, ts) => evaluate(IO.fail0[E](t, ts))\n\n        case ExitResult.Terminated(ts) => evaluate(IO.terminate0(ts))"
  },
  {
    "id" : "6b57d323-1ffa-415d-8492-bafb3e9c6c8d",
    "prId" : 107,
    "prUrl" : "https://github.com/zio/zio/pull/107#pullrequestreview-143395785",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "92f6742a-27ef-43d4-8332-e35fd709c22d",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "Looks like we're dropping some errors on the floor here! We should figure out a home for them.\r\n\r\nThis is the asymmetry between `IO.fail` and `ExitResult.Failed`. This is pointing to a flaw in the design: it suggests to me `Failed` is too expressive or `IO.fail` is not expressive enough.",
        "createdAt" : "2018-08-04T22:55:16Z",
        "updatedAt" : "2018-08-05T12:35:24Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      }
    ],
    "commit" : "e0678f0b1c77862a214a5e4cd2ee578de3280b92",
    "line" : 305,
    "diffHunk" : "@@ -1,1 +668,672 @@          else evaluate(io)\n\n        case ExitResult.Failed(t, _) => evaluate(IO.fail[E](t))\n\n        case ExitResult.Terminated(ts) => evaluate(IO.terminate0(ts))"
  },
  {
    "id" : "c419081b-327e-4f3e-812b-e97edb62849f",
    "prId" : 107,
    "prUrl" : "https://github.com/zio/zio/pull/107#pullrequestreview-143816549",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0354ba99-7bb9-4d17-9b5b-9ad141db238a",
        "parentId" : null,
        "authorId" : "bad22193-a0ec-4736-a528-dcb8b6223b09",
        "body" : "This is a re-implementation of one of the `Semigroup` instances for `Option[A]`.",
        "createdAt" : "2018-08-06T00:51:32Z",
        "updatedAt" : "2018-08-06T00:51:32Z",
        "lastEditedBy" : "bad22193-a0ec-4736-a528-dcb8b6223b09",
        "tags" : [
        ]
      },
      {
        "id" : "ee520694-2727-4bdd-b25d-dd63f2c26515",
        "parentId" : "0354ba99-7bb9-4d17-9b5b-9ad141db238a",
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "It's true, but now Scalaz depends on ZIO (which means, at the very least, no more impure code in Scalaz), so the reimplementation is necessary.",
        "createdAt" : "2018-08-07T01:55:00Z",
        "updatedAt" : "2018-08-07T01:55:00Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      }
    ],
    "commit" : "e0678f0b1c77862a214a5e4cd2ee578de3280b92",
    "line" : 163,
    "diffHunk" : "@@ -1,1 +297,301 @@        case (None, None)           => None\n      }\n\n    /**\n     * The main interpreter loop for `IO` actions. For purely synchronous actions,"
  },
  {
    "id" : "2a5dc64d-dad8-42f0-855f-c7f7c0b68650",
    "prId" : 86,
    "prUrl" : "https://github.com/zio/zio/pull/86#pullrequestreview-133155090",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "65dc5697-347d-4087-a4bd-73d2d638a476",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "Dang. Wonder how this got dropped.",
        "createdAt" : "2018-06-29T09:21:18Z",
        "updatedAt" : "2018-06-29T13:03:08Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      }
    ],
    "commit" : "5c0848bbe7a76b635d66550ab54511f66ddb3c26",
    "line" : 47,
    "diffHunk" : "@@ -1,1 +494,498 @@                    val io = curIo.asInstanceOf[IO.AsyncIOEffect[E, Any]]\n\n                    enterAsyncStart()\n\n                    try {"
  },
  {
    "id" : "bdf3d4d8-9ff1-424c-a71a-aca47ef76a6c",
    "prId" : 69,
    "prUrl" : "https://github.com/zio/zio/pull/69#pullrequestreview-131546411",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f3b434be-8715-4880-96cc-f82edd778cd8",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "This is correct and what we want.",
        "createdAt" : "2018-06-25T10:21:13Z",
        "updatedAt" : "2018-06-25T21:27:00Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      }
    ],
    "commit" : "bcbbc1ea00b8662f9b3229f62b72b92dce8a2ec1",
    "line" : 162,
    "diffHunk" : "@@ -1,1 +638,642 @@                  case IO.Tags.Ensuring =>\n                    val io = curIo.asInstanceOf[IO.Ensuring[E, Any]]\n                    stack.push(Finalizer[E](io.finalizer))\n                    curIo = io.io\n                }"
  },
  {
    "id" : "921a5a6b-ac57-4419-a441-bfd2e48798f1",
    "prId" : 69,
    "prUrl" : "https://github.com/zio/zio/pull/69#pullrequestreview-131649370",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "18f17eba-d402-4235-9475-f3ec4acb9688",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "This is the tricky case where, in the \"happy\" path (no errors in the body), interruption of the finalizer is possible (but should not be possible).\r\n\r\nOne way is to solve this in `nextInstr`â€”if we see a `Finalizer` coming off the stack, we `++` the `noInterrupt` and push a `_ => exitUninterruptible` onto the stack. It will be slower though. In any case, maybe best dealt with in a separate PR. It's definitely a problem though.",
        "createdAt" : "2018-06-25T10:26:11Z",
        "updatedAt" : "2018-06-25T21:27:00Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      },
      {
        "id" : "f20b867e-13fa-4dac-9c91-3f1b58b88863",
        "parentId" : "18f17eba-d402-4235-9475-f3ec4acb9688",
        "authorId" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "body" : "I see. Couldn't this be done in `Finalizer.apply` itself? It's only ever called in `nextInstr` afaics. Then we could keep the `Ensuring` branch as is and avoid a pattern match.\r\n```scala\r\n@inline def noInterrupt[E, A](io: IO[E, A]) = \r\n  enterUninterruptible *> io *> exitUninterruptible\r\nfinal case class Finalizer[E](finalizer: Infallible[Unit]) extends Function[Any, IO[E, Any]] {\r\n  final def apply(v: Any): IO[E, Any] = noInterrupt(finalizer) *> IO.now(v)\r\n}\r\n```",
        "createdAt" : "2018-06-25T14:40:52Z",
        "updatedAt" : "2018-06-25T21:27:00Z",
        "lastEditedBy" : "cc8bc8c4-90ec-4817-908a-529be81ef42a",
        "tags" : [
        ]
      },
      {
        "id" : "078673cb-a07f-4a39-a2dc-33e3b2bb93a3",
        "parentId" : "18f17eba-d402-4235-9475-f3ec4acb9688",
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "No, because `Finalizer` will be popped off the stack as `curIo`, then the next time through the `while` loop, interruption will be checked. At this point, if it's interrupted, the whole `Finalizer` will be off the stack and onto `curIo`, so when `interruptStack` is called, it won't be cleaned up properly.",
        "createdAt" : "2018-06-25T15:01:55Z",
        "updatedAt" : "2018-06-25T21:27:00Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      }
    ],
    "commit" : "bcbbc1ea00b8662f9b3229f62b72b92dce8a2ec1",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +154,158 @@\n  final case class Finalizer[E](finalizer: Infallible[Unit]) extends Function[Any, IO[E, Any]] {\n    final def apply(v: Any): IO[E, Any] = finalizer.widenError[E] *> IO.now(v)\n  }\n"
  },
  {
    "id" : "667712af-9fc2-4e58-a1b5-bd5fd6f42fcb",
    "prId" : 69,
    "prUrl" : "https://github.com/zio/zio/pull/69#pullrequestreview-131663876",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "420822d8-e284-4a8a-9ab6-2bcf1e28f973",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "If you want, you can make this faster with:\r\n\r\n```scala\r\ncase f0 if f0.getClass == Finalizer.class` =>\r\n```\r\n\r\nIt will be a little faster than an `instanceOf` check. Same for `IO.Attempt`.",
        "createdAt" : "2018-06-25T15:03:19Z",
        "updatedAt" : "2018-06-25T21:27:00Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      },
      {
        "id" : "d1f014e6-9e30-4c20-921b-833e5a7f97f0",
        "parentId" : "420822d8-e284-4a8a-9ab6-2bcf1e28f973",
        "authorId" : "c6c25285-c6a4-42f1-9c1d-0046b5584182",
        "body" : "[someone run a benchmark](https://stackoverflow.com/questions/103564/the-performance-impact-of-using-instanceof-in-java/26514984#26514984) that would suggest that `_.isInstanceOf[Finalizer[_]]` is slightly faster (but basically same perf) than `_.getClass eq classOf[Finalizer[_]]` .",
        "createdAt" : "2018-06-25T15:13:34Z",
        "updatedAt" : "2018-06-25T21:27:00Z",
        "lastEditedBy" : "c6c25285-c6a4-42f1-9c1d-0046b5584182",
        "tags" : [
        ]
      },
      {
        "id" : "50402aee-b103-47eb-bd9a-6f4626a09c20",
        "parentId" : "420822d8-e284-4a8a-9ab6-2bcf1e28f973",
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "All right, then let's not change it. ðŸ‘ \r\n\r\nMust be due to performance optimizations since the reverse used to be true...",
        "createdAt" : "2018-06-25T15:34:32Z",
        "updatedAt" : "2018-06-25T21:27:00Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      }
    ],
    "commit" : "bcbbc1ea00b8662f9b3229f62b72b92dce8a2ec1",
    "line" : 41,
    "diffHunk" : "@@ -1,1 +253,257 @@            errorHandler = a.err.asInstanceOf[Any => IO[Any, Any]]\n          case f0: Finalizer[_] =>\n            val f: IO[Void, List[Throwable]] = f0.finalizer.run.map(collectDefect)\n            if (finalizer eq null) finalizer = f\n            else finalizer = finalizer.zipWith(f)(_ ++ _)"
  }
]
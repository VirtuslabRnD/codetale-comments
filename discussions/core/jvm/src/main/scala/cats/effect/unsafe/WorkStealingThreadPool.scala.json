[
  {
    "id" : "e10b43e1-e32d-4581-9189-77a2a829296f",
    "prId" : 1734,
    "prUrl" : "https://github.com/typelevel/cats-effect/pull/1734#pullrequestreview-599855571",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2281e193-a3f1-49e6-b5aa-7e8bd3786e35",
        "parentId" : null,
        "authorId" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "body" : "Can we just make `WorkerThread` and `HelperThread` both extend some common superclass to remove one of these branches? Though I suppose that the implementations are distinct, so it might actually be better to have the branching exactly as you wrote it.",
        "createdAt" : "2021-02-26T17:39:20Z",
        "updatedAt" : "2021-02-26T17:41:57Z",
        "lastEditedBy" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "tags" : [
        ]
      },
      {
        "id" : "585392a7-7706-4133-839f-8689513ad067",
        "parentId" : "2281e193-a3f1-49e6-b5aa-7e8bd3786e35",
        "authorId" : "566d094c-978a-46cc-94f5-bc87e03c9fd3",
        "body" : "Back in the day in my original implementation of the WorkStealingPool, I had exactly that. I created our own type `IOExecutor` which both our `WorkStealingThreadPool` and any `ExecutionContext` could implement (precisely to avoid this branching). That _tanked_ performance, so I've been shying away from inheritance solutions since.\r\n\r\nFurthermore, in #1609 I had an even less optimized version of this code, and we were still a lot faster than what's currently in `series/3.x`.",
        "createdAt" : "2021-02-26T18:53:40Z",
        "updatedAt" : "2021-02-26T18:54:03Z",
        "lastEditedBy" : "566d094c-978a-46cc-94f5-bc87e03c9fd3",
        "tags" : [
        ]
      },
      {
        "id" : "0e34de36-9349-415c-9fc3-ca8d29076743",
        "parentId" : "2281e193-a3f1-49e6-b5aa-7e8bd3786e35",
        "authorId" : "566d094c-978a-46cc-94f5-bc87e03c9fd3",
        "body" : "Btw this exact branch is only a factor when we call `execute` on our `WorkStealingPool`, which is only at async boundaries originating from the outside world (i.e. already the slowest path).",
        "createdAt" : "2021-02-26T18:55:35Z",
        "updatedAt" : "2021-02-26T18:55:54Z",
        "lastEditedBy" : "566d094c-978a-46cc-94f5-bc87e03c9fd3",
        "tags" : [
        ]
      },
      {
        "id" : "9bb8b521-c1e2-42ce-a23e-5ed6483c8231",
        "parentId" : "2281e193-a3f1-49e6-b5aa-7e8bd3786e35",
        "authorId" : "566d094c-978a-46cc-94f5-bc87e03c9fd3",
        "body" : "Also this https://shipilev.net/blog/2015/black-magic-method-dispatch/#_bimorphic_cases.",
        "createdAt" : "2021-02-26T18:56:44Z",
        "updatedAt" : "2021-02-26T18:59:04Z",
        "lastEditedBy" : "566d094c-978a-46cc-94f5-bc87e03c9fd3",
        "tags" : [
        ]
      }
    ],
    "commit" : "dd624df0787c90e52d41fb4de63e4f91220befe7",
    "line" : 45,
    "diffHunk" : "@@ -1,1 +273,277 @@      thread.asInstanceOf[WorkerThread].schedule(fiber)\n    } else if (thread.isInstanceOf[HelperThread]) {\n      thread.asInstanceOf[HelperThread].schedule(fiber)\n    } else {\n      externalQueue.offer(fiber)"
  },
  {
    "id" : "f9a5f869-7fa3-4b24-a457-b6ad57b4dbc0",
    "prId" : 1349,
    "prUrl" : "https://github.com/typelevel/cats-effect/pull/1349#pullrequestreview-516319387",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f8bdfd87-262f-4f89-8919-271b8ea70810",
        "parentId" : null,
        "authorId" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "body" : "Amusingly, I completely forgot this was a source of unsafe running…",
        "createdAt" : "2020-10-25T02:16:04Z",
        "updatedAt" : "2020-10-25T11:30:50Z",
        "lastEditedBy" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "tags" : [
        ]
      }
    ],
    "commit" : "02a7c43fd1256a0a8951d015bca7be54c5009f45",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +316,320 @@\n      // `unsafeRunFiber(true)` will enqueue the fiber, no need to do it manually\n      IO(runnable.run()).unsafeRunFiber(reportFailure, _ => ())(self)\n      ()\n    }"
  },
  {
    "id" : "fd7d58aa-5088-4a24-b1a3-92cef451933a",
    "prId" : 1202,
    "prUrl" : "https://github.com/typelevel/cats-effect/pull/1202#pullrequestreview-491604278",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4221b3e2-25a9-4438-9de2-76490f386bc6",
        "parentId" : null,
        "authorId" : "566d094c-978a-46cc-94f5-bc87e03c9fd3",
        "body" : "Should we maybe throw a `RejectedExecutionException`?",
        "createdAt" : "2020-09-17T13:18:01Z",
        "updatedAt" : "2020-09-17T13:18:02Z",
        "lastEditedBy" : "566d094c-978a-46cc-94f5-bc87e03c9fd3",
        "tags" : [
        ]
      },
      {
        "id" : "2bde472e-5470-4306-a355-60606479fa71",
        "parentId" : "4221b3e2-25a9-4438-9de2-76490f386bc6",
        "authorId" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "body" : "That would be more in line with other executors. I don't have strong feelings either way.",
        "createdAt" : "2020-09-18T16:14:10Z",
        "updatedAt" : "2020-09-18T16:14:34Z",
        "lastEditedBy" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "tags" : [
        ]
      }
    ],
    "commit" : "fdaaa8200515888779b3a40e142af623322b5418",
    "line" : 11,
    "diffHunk" : "@@ -1,1 +312,316 @@      // directly, as `IOFiber` is not a public type.\n      if (done) {\n        return\n      }\n"
  },
  {
    "id" : "b77d6396-2fd0-4367-a4c6-1623fe16c206",
    "prId" : 1134,
    "prUrl" : "https://github.com/typelevel/cats-effect/pull/1134#pullrequestreview-477893353",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0e6a957c-df74-4f52-89ce-8bb929f917ba",
        "parentId" : null,
        "authorId" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "body" : "Another potential use-case for `ReentrantLock`",
        "createdAt" : "2020-08-27T22:41:50Z",
        "updatedAt" : "2020-08-30T22:15:10Z",
        "lastEditedBy" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "tags" : [
        ]
      },
      {
        "id" : "ec60b3a4-e013-4bac-9db1-f847af104a1a",
        "parentId" : "0e6a957c-df74-4f52-89ce-8bb929f917ba",
        "authorId" : "566d094c-978a-46cc-94f5-bc87e03c9fd3",
        "body" : "I'll rewrite and benchmark.",
        "createdAt" : "2020-08-28T17:07:47Z",
        "updatedAt" : "2020-08-30T22:15:10Z",
        "lastEditedBy" : "566d094c-978a-46cc-94f5-bc87e03c9fd3",
        "tags" : [
        ]
      }
    ],
    "commit" : "412008eb9f64d092ec05f6618aece641293712d6",
    "line" : 74,
    "diffHunk" : "@@ -1,1 +72,76 @@\n  // Lock that ensures exclusive access to the references of sleeping threads.\n  private[this] val lock: AnyRef = new Object()\n\n  // LIFO access to references of sleeping worker threads."
  },
  {
    "id" : "832cec3e-2ff6-495d-9cd6-c1dafc8f2c34",
    "prId" : 1134,
    "prUrl" : "https://github.com/typelevel/cats-effect/pull/1134#pullrequestreview-477893554",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "dbdab542-a5f8-47c7-9b23-efbdb17155fd",
        "parentId" : null,
        "authorId" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "body" : "Random note: `ArrayStack` isn't thread-safe.",
        "createdAt" : "2020-08-27T22:42:23Z",
        "updatedAt" : "2020-08-30T22:15:10Z",
        "lastEditedBy" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "tags" : [
        ]
      },
      {
        "id" : "8d54be4e-7cc0-47e3-80a3-60499cfb6ef0",
        "parentId" : "dbdab542-a5f8-47c7-9b23-efbdb17155fd",
        "authorId" : "566d094c-978a-46cc-94f5-bc87e03c9fd3",
        "body" : "It's only ever used under the lock.",
        "createdAt" : "2020-08-28T17:08:05Z",
        "updatedAt" : "2020-08-30T22:15:10Z",
        "lastEditedBy" : "566d094c-978a-46cc-94f5-bc87e03c9fd3",
        "tags" : [
        ]
      }
    ],
    "commit" : "412008eb9f64d092ec05f6618aece641293712d6",
    "line" : 77,
    "diffHunk" : "@@ -1,1 +75,79 @@\n  // LIFO access to references of sleeping worker threads.\n  private[this] val sleepers: ArrayStack[WorkerThread] = new ArrayStack(threadCount)\n\n  // Track currently sleeping threads by their indices."
  },
  {
    "id" : "8829888a-47b9-4706-8025-39141b818f60",
    "prId" : 1134,
    "prUrl" : "https://github.com/typelevel/cats-effect/pull/1134#pullrequestreview-478131451",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f58746f6-ab33-4bad-b57d-c208dc7922bd",
        "parentId" : null,
        "authorId" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "body" : "The use of locks continues to scare me…",
        "createdAt" : "2020-08-27T22:47:45Z",
        "updatedAt" : "2020-08-30T22:15:10Z",
        "lastEditedBy" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "tags" : [
        ]
      },
      {
        "id" : "89f760bd-34e6-4660-be4b-8ee8a25568f5",
        "parentId" : "f58746f6-ab33-4bad-b57d-c208dc7922bd",
        "authorId" : "566d094c-978a-46cc-94f5-bc87e03c9fd3",
        "body" : "This is more or less directly translated from `tokio`.",
        "createdAt" : "2020-08-28T17:12:34Z",
        "updatedAt" : "2020-08-30T22:15:10Z",
        "lastEditedBy" : "566d094c-978a-46cc-94f5-bc87e03c9fd3",
        "tags" : [
        ]
      },
      {
        "id" : "12ed2bb5-4075-4fc2-b7ea-98fcdae8e94d",
        "parentId" : "f58746f6-ab33-4bad-b57d-c208dc7922bd",
        "authorId" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "body" : "That's really, really, really interesting to me. Do they have any specific discussion about the use of locks rather than a lock-free encoding?",
        "createdAt" : "2020-08-28T23:16:15Z",
        "updatedAt" : "2020-08-30T22:15:10Z",
        "lastEditedBy" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "tags" : [
        ]
      },
      {
        "id" : "858ea633-aefd-479c-854d-cc07acf14948",
        "parentId" : "f58746f6-ab33-4bad-b57d-c208dc7922bd",
        "authorId" : "566d094c-978a-46cc-94f5-bc87e03c9fd3",
        "body" : "Nothing that I could find.",
        "createdAt" : "2020-08-29T00:56:44Z",
        "updatedAt" : "2020-08-30T22:15:10Z",
        "lastEditedBy" : "566d094c-978a-46cc-94f5-bc87e03c9fd3",
        "tags" : [
        ]
      },
      {
        "id" : "cc5bc5ea-9b7b-4d95-babb-f5a743126519",
        "parentId" : "f58746f6-ab33-4bad-b57d-c208dc7922bd",
        "authorId" : "b93e2985-c394-41e6-a036-b46320cfbf21",
        "body" : "I seem to remember seeing something about this in the past that lock free complex data structures often don't win. When you are in the contended state you are redoing a lot of work due to transaction failures, and in the uncontended case there is no win from concurrency anyway (because there is only one or two items).\r\n\r\nI'd be reluctant to second guess their lock-based design without evidence across a variety of loads that there isn't a catastrophic case. I'd fear the wheels could really come off this under load if we went lock free: exactly when the contention increases that causes the throughput to decrease, which causes death-spiral-like behavior in some cases.",
        "createdAt" : "2020-08-29T02:07:46Z",
        "updatedAt" : "2020-08-30T22:15:10Z",
        "lastEditedBy" : "b93e2985-c394-41e6-a036-b46320cfbf21",
        "tags" : [
        ]
      },
      {
        "id" : "f4e90779-f328-4f01-b59e-2770cc1bf8d3",
        "parentId" : "f58746f6-ab33-4bad-b57d-c208dc7922bd",
        "authorId" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "body" : "Extremely valid points. And I've seen similar work on throughput of locks vs optimistic encodings under contention. As I recall, once the contention ratios start getting to be meaningful, locks do in fact win. Perhaps this is one of those cases. \n\nAt the very least, locks on the JVM aren't worse than in Rust, and they chose them intentionally.",
        "createdAt" : "2020-08-29T04:02:22Z",
        "updatedAt" : "2020-08-30T22:15:10Z",
        "lastEditedBy" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "tags" : [
        ]
      },
      {
        "id" : "51d6f914-995b-4ed1-a396-8e6e6e26d60f",
        "parentId" : "f58746f6-ab33-4bad-b57d-c208dc7922bd",
        "authorId" : "566d094c-978a-46cc-94f5-bc87e03c9fd3",
        "body" : "They have a slightly nicer API surface in Rust. Mutexes are parameterized and they \"wrap\" the state that they protect. But otherwise yes, performance should be exactly the same.",
        "createdAt" : "2020-08-29T14:24:01Z",
        "updatedAt" : "2020-08-30T22:15:10Z",
        "lastEditedBy" : "566d094c-978a-46cc-94f5-bc87e03c9fd3",
        "tags" : [
        ]
      }
    ],
    "commit" : "412008eb9f64d092ec05f6618aece641293712d6",
    "line" : 172,
    "diffHunk" : "@@ -1,1 +170,174 @@    }\n\n    lock.synchronized {\n      if (!notifyShouldWakeup()) {\n        // Again, there are enough searching and/or running worker threads."
  }
]
[
  {
    "id" : "8b433213-6eef-42b4-ae94-dff03073abe0",
    "prId" : 8713,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/8713#pullrequestreview-392158247",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "81654b57-cb82-4302-829b-2da72e016dbe",
        "parentId" : null,
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "Now we have a cast in both branches. Aren't the type ascriptions not supposed to avoid this extra cast in bytecode?",
        "createdAt" : "2020-04-13T05:18:01Z",
        "updatedAt" : "2020-04-13T05:18:01Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      },
      {
        "id" : "5060f907-4e20-4a8e-ab4a-256c0f768faa",
        "parentId" : "81654b57-cb82-4302-829b-2da72e016dbe",
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "The erased result type of the generic Array.apply is `Object`, so a checkcast is necessary to actually use it as an Array. Without the type ascription, the compiler doesn't always insert that checkcast because we don't actually do anything with the Array.",
        "createdAt" : "2020-04-13T13:55:04Z",
        "updatedAt" : "2020-04-13T13:55:04Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      }
    ],
    "commit" : "82e7d201987ada044225d445ea11b1546f7d837d",
    "line" : 33,
    "diffHunk" : "@@ -1,1 +72,76 @@    test(\"IArray(1, 2)\", newArray2Opcodes(T_INT, init))\n\n    val init2 = List(Op(DUP), Op(ICONST_0), Field(GETSTATIC, \"Foo$\", \"MODULE$\", \"LFoo$;\"), Invoke(INVOKEVIRTUAL, \"Foo$\", \"t\", \"()I\", false), Op(IASTORE), Op(DUP), Op(ICONST_1), Field(GETSTATIC, \"Foo$\", \"MODULE$\", \"LFoo$;\"), Invoke(INVOKEVIRTUAL, \"Foo$\", \"t\", \"()I\", false), Op(IASTORE), TypeOp(CHECKCAST, \"[I\"))\n    test(\"\"\"Array[T](t, t): Array[T]\"\"\", newArray2Opcodes(T_INT, init2))\n    test(\"\"\"IArray[T](t, t): IArray[T]\"\"\", newArray2Opcodes(T_INT, init2))"
  }
]
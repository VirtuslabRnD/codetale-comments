[
  {
    "id" : "18e18d54-242d-4f8b-9127-0f6ff7f67a2b",
    "prId" : 10509,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/10509#pullrequestreview-539497850",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "743ea026-a1c3-469a-9ff4-ed4aa8a7ef24",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "\"statified\" is an interesting neologism :). Maybe add a comment explaining what it does to keep things clear?",
        "createdAt" : "2020-11-26T18:10:58Z",
        "updatedAt" : "2020-11-27T09:38:43Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      }
    ],
    "commit" : "dec6cc670f1a5c8d585afaf6079fc96ade14f306",
    "line" : 61,
    "diffHunk" : "@@ -1,1 +660,664 @@     *  }}}\n     */\n    private def makeStatifiedDefDef(dd: DefDef): DefDef =\n      val origSym = dd.symbol.asTerm\n      val newSym = makeStatifiedDefSymbol(origSym, origSym.name)"
  },
  {
    "id" : "26512430-e7ad-4bb0-95af-ff4a5811a133",
    "prId" : 9600,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/9600#pullrequestreview-470768002",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a4546a31-9545-4036-a492-5ef483a167aa",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "We should inline the commit message from https://github.com/lampepfl/dotty/commit/33b989478c1b0ee8ce69691f9dde427ba94d8dab here to explain what's going on:\r\n```suggestion\r\n        // To avoid deadlocks when combining objects, lambdas and multi-threading,\r\n        // lambdas in objects are compiled to instance methods of the module class\r\n        // instead of static methods (see tests/run/deadlock.scala and\r\n        // https://github.com/scala/scala-dev/issues/195 for details).\r\n        // This has worked well for us so far but this is problematic for\r\n        // serialization: serializing a lambda requires serializing all the values\r\n        // it captures, if this lambda is in an object, this means serializing the\r\n        // enclosing object, which fails if the object does not extend\r\n        // Serializable.\r\n        // Because serializing objects is basically free since #5775, it seems like\r\n        // the simplest solution is to simply make all objects Serializable, this\r\n        // certainly seems preferable to deadlocks.\r\n        if (claszSymbol.is(ModuleClass) && !interfaceNames0.contains(\"java/io/Serializable\"))\r\n```\r\nAnd maybe add an extra note about the fact that this can't be done earlier because scala.js won't like it.",
        "createdAt" : "2020-08-19T19:23:10Z",
        "updatedAt" : "2020-08-20T07:42:55Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      }
    ],
    "commit" : "ab25d6be26db7a1a03a09f03b650fe53d77e70e2",
    "line" : 25,
    "diffHunk" : "@@ -1,1 +259,263 @@       */\n      val interfaceNames =\n        if (claszSymbol.is(ModuleClass) && !interfaceNames0.contains(\"java/io/Serializable\"))\n          interfaceNames0 :+ \"java/io/Serializable\"\n        else"
  },
  {
    "id" : "0c60ba67-b5ac-4e7d-acf7-be029843b262",
    "prId" : 9600,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/9600#pullrequestreview-470801664",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "24c8806a-61a1-4edd-96d9-87dd32c8d183",
        "parentId" : null,
        "authorId" : "128563de-a925-4397-af34-450c7978a8d2",
        "body" : "I think we should be careful here because in SyntheticMembers the writeReplace method is only generated if an object is serializable https://github.com/lampepfl/dotty/blob/c5e1f0ceedabbbcbf70d84f30ce265dda9a4c22f/compiler/src/dotty/tools/dotc/transform/SyntheticMembers.scala#L369",
        "createdAt" : "2020-08-19T19:43:29Z",
        "updatedAt" : "2020-08-20T07:42:55Z",
        "lastEditedBy" : "128563de-a925-4397-af34-450c7978a8d2",
        "tags" : [
        ]
      },
      {
        "id" : "c1546ce8-aeac-4318-9e0b-998c6dd304f7",
        "parentId" : "24c8806a-61a1-4edd-96d9-87dd32c8d183",
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Oh yeah that needs to become unconditional (with a comment mentioning that all objects are serialized in the backend)",
        "createdAt" : "2020-08-19T19:49:25Z",
        "updatedAt" : "2020-08-20T07:42:55Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      }
    ],
    "commit" : "ab25d6be26db7a1a03a09f03b650fe53d77e70e2",
    "line" : 25,
    "diffHunk" : "@@ -1,1 +259,263 @@       */\n      val interfaceNames =\n        if (claszSymbol.is(ModuleClass) && !interfaceNames0.contains(\"java/io/Serializable\"))\n          interfaceNames0 :+ \"java/io/Serializable\"\n        else"
  },
  {
    "id" : "1d71e08a-58e1-4a05-a83a-ae37e12e5ec2",
    "prId" : 9181,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/9181#pullrequestreview-451680792",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c9e6f63c-75b6-42e6-a6ed-5f6cfde0a0e5",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Do you think this could be done in a mini-phase just before the backend?",
        "createdAt" : "2020-07-18T18:32:10Z",
        "updatedAt" : "2020-08-06T20:20:36Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "4868cbca-0e33-4b17-9ab2-490138179987",
        "parentId" : "c9e6f63c-75b6-42e6-a6ed-5f6cfde0a0e5",
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "> Do you think this could be done in a mini-phase just before the backend?\r\n\r\nActually that might not be a good idea if it interfers with scala.js/native like with https://github.com/lampepfl/dotty/pull/8652/commits/08a1ca0e6581ca997115ce1d483efa20d61427a4#r456815962, wdyt @sjrd ?",
        "createdAt" : "2020-07-20T13:12:30Z",
        "updatedAt" : "2020-08-06T20:20:36Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "0013bfe8-4e35-4aac-bdf8-13365d283af1",
        "parentId" : "c9e6f63c-75b6-42e6-a6ed-5f6cfde0a0e5",
        "authorId" : "5a9cd756-9120-4d5e-ac88-e9c636084f0e",
        "body" : "Ah yes, moving that before the back-end would make things significantly more complicated for Scala.js and Native. Both have a first-class concept of `ModuleClass`, and encode the singleton pattern of `MODULE$` in a completely different way. In the Scala.js IR, there even isn't anything that corresponds to `MODULE$` per se.\r\n\r\nSo if you move this before the back-end, then Scala.js and Scala Native will have to reverse all the effects of this transformation, which would be counter-productive.",
        "createdAt" : "2020-07-20T14:49:58Z",
        "updatedAt" : "2020-08-06T20:20:36Z",
        "lastEditedBy" : "5a9cd756-9120-4d5e-ac88-e9c636084f0e",
        "tags" : [
        ]
      }
    ],
    "commit" : "745d53c78e040aea398c38754bcc8ff3ad2df91d",
    "line" : 50,
    "diffHunk" : "@@ -1,1 +114,118 @@      val cd = if (isCZStaticModule) {\n        // Move statements from the primary constructor following the superclass constructor call to\n        // a newly synthesised tree representing the \"<clinit>\", which also assigns the MODULE$ field.\n        // Because the assigments to both the module instance fields, and the fields of the module itself\n        // are in the <clinit>, these fields can be static + final."
  },
  {
    "id" : "c9812b12-b34f-4805-8772-6daf5934ada6",
    "prId" : 8652,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/8652#pullrequestreview-451119745",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "cf1fe96c-aeea-4be9-b4a6-4444909078cb",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Could this be done in a mini-phase before the backend?",
        "createdAt" : "2020-07-18T18:34:48Z",
        "updatedAt" : "2020-07-22T08:29:14Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "90aed543-d93a-4010-bfad-da44024bd612",
        "parentId" : "cf1fe96c-aeea-4be9-b4a6-4444909078cb",
        "authorId" : "5a9cd756-9120-4d5e-ac88-e9c636084f0e",
        "body" : "No, because it must not be done for JS (nor Native). So it would have to be alone in its own MegaPhase between `GenSJSIR` and `GenBCode`. That would be a huge cost for a few lines of code. I have explained that in a comment.",
        "createdAt" : "2020-07-19T10:43:56Z",
        "updatedAt" : "2020-07-22T08:29:14Z",
        "lastEditedBy" : "5a9cd756-9120-4d5e-ac88-e9c636084f0e",
        "tags" : [
        ]
      }
    ],
    "commit" : "77e29253e1443d26a9bb4852e36c9d5f3da15d48",
    "line" : 31,
    "diffHunk" : "@@ -1,1 +511,515 @@            claszSymbol.isInterface && !dd.rhs.isEmpty && !sym.isPrivate && !sym.isStaticMember\n          if needsStaticImplMethod then\n            genStaticForwarderForDefDef(dd)\n\n          genDefDef(dd)"
  }
]
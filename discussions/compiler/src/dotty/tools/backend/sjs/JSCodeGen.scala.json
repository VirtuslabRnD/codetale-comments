[
  {
    "id" : "5ce38141-2b7f-41b8-9798-061c921ac447",
    "prId" : 12657,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/12657#pullrequestreview-689910486",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2ed9ce24-935e-404f-bd40-3a16e83cbca3",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "What's `<undefined-param>` ? I see the test cases set the default value to `= js.undefined` but what if I use a different default value?",
        "createdAt" : "2021-06-22T18:05:59Z",
        "updatedAt" : "2021-06-22T18:05:59Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "8010af57-59c5-41c3-804d-03b07294cae1",
        "parentId" : "2ed9ce24-935e-404f-bd40-3a16e83cbca3",
        "authorId" : "5a9cd756-9120-4d5e-ac88-e9c636084f0e",
        "body" : "The right-hand-side of a default value is irrelevant. As soon as there is a default value, where `= js.undefined`, `= 42` or `= js.native`, that parameter will be an `<undefined-param>`. `<undefined-param>`'s are markers that are always eliminated at compile-time, and replaced by *no* argument (because you can do that in JS). That is done at\r\nhttps://github.com/lampepfl/dotty/blob/0d1d47a8fde5226b81376f5ff09512be17abaa0c/compiler/src/dotty/tools/backend/sjs/JSCodeGen.scala#L3764-L3776",
        "createdAt" : "2021-06-22T18:42:58Z",
        "updatedAt" : "2021-06-22T18:42:58Z",
        "lastEditedBy" : "5a9cd756-9120-4d5e-ac88-e9c636084f0e",
        "tags" : [
        ]
      },
      {
        "id" : "eb6bc016-4b22-4abb-b730-89d003089b56",
        "parentId" : "2ed9ce24-935e-404f-bd40-3a16e83cbca3",
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Ah, so should the compiler disallow a default value that is not exactly `js.undefined` ?",
        "createdAt" : "2021-06-22T18:44:54Z",
        "updatedAt" : "2021-06-22T18:44:54Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "1e8d04eb-13b1-4471-8b5b-2aec84ad8f4c",
        "parentId" : "2ed9ce24-935e-404f-bd40-3a16e83cbca3",
        "authorId" : "5a9cd756-9120-4d5e-ac88-e9c636084f0e",
        "body" : "No, it shouldn't. It wouldn't work when the type of the parameter is `Int`, for example. Also, an actual value can have valuable documentation purposes. It's been allowed for 8 years in Scala.js for Scala 2, so we can't change that.",
        "createdAt" : "2021-06-22T19:19:21Z",
        "updatedAt" : "2021-06-22T19:19:21Z",
        "lastEditedBy" : "5a9cd756-9120-4d5e-ac88-e9c636084f0e",
        "tags" : [
        ]
      }
    ],
    "commit" : "dc89ac4d802ec67af0f7baba89b37086763c78c2",
    "line" : 15,
    "diffHunk" : "@@ -1,1 +1074,1078 @@        /* #12572 Bridges for default accessors in non-native JS classes must not be emitted,\n         * because they call another default accessor, making their entire body an\n         * <undefined-param> that cannot be eliminated.\n         * Such methods are never called anyway, because they are filtered out in\n         * JSExportsGen.defaultGetterDenot()."
  },
  {
    "id" : "241a60d4-082f-4f80-84e5-8145bc43c5f1",
    "prId" : 10164,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/10164#pullrequestreview-528866962",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "89efc5d2-d9ba-4403-9080-e5dadcc99097",
        "parentId" : null,
        "authorId" : "f186a0ec-8fc4-4e94-87e9-c629d1b38b60",
        "body" : "Do you recall why we didn't simply do this in Scala 2?",
        "createdAt" : "2020-11-12T08:13:20Z",
        "updatedAt" : "2020-11-12T08:25:59Z",
        "lastEditedBy" : "f186a0ec-8fc4-4e94-87e9-c629d1b38b60",
        "tags" : [
        ]
      },
      {
        "id" : "406fb49b-bcec-4dd5-8fdc-c9c8fdce2118",
        "parentId" : "89efc5d2-d9ba-4403-9080-e5dadcc99097",
        "authorId" : "5a9cd756-9120-4d5e-ac88-e9c636084f0e",
        "body" : "I don't know. It's probably historical, following a long chain of changes. `@JSExportTopLevel` inherited from `@JSExport` on classes and objects, in which the name could be implicit; which might explain it. git blame suggests https://github.com/scala-js/scala-js/commit/273e9b82fea10628e4669aba121027b07c34f5e0 as the moment at which we introduced those out-of-the-band mutable maps, but at the time `@JSExportTopLevel` did not exist yet.\r\n\r\nWe could try to get rid of it in Scala 2.",
        "createdAt" : "2020-11-12T08:50:21Z",
        "updatedAt" : "2020-11-12T08:50:21Z",
        "lastEditedBy" : "5a9cd756-9120-4d5e-ac88-e9c636084f0e",
        "tags" : [
        ]
      }
    ],
    "commit" : "69afa9cf05e232814348d9779a999b51db650f87",
    "line" : 208,
    "diffHunk" : "@@ -1,1 +3934,3938 @@\n      (f, true)\n    } else if (sym.hasAnnotation(jsdefn.JSExportTopLevelAnnot)) {\n      val f = js.SelectStatic(encodeClassName(sym.owner), encodeFieldSym(sym))(jstpe.AnyType)\n      (f, true)"
  },
  {
    "id" : "d9d2793c-cfe4-4377-9218-6a59ec56eada",
    "prId" : 9955,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/9955#pullrequestreview-506545112",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8202fa28-c642-4c8e-b8e4-0e591fd74455",
        "parentId" : null,
        "authorId" : "5a9cd756-9120-4d5e-ac88-e9c636084f0e",
        "body" : "We should add a comment somewhere around here explaining that this generates static getters for static fields, and that this is necessary notably for enums.",
        "createdAt" : "2020-10-08T09:20:17Z",
        "updatedAt" : "2020-10-13T11:07:38Z",
        "lastEditedBy" : "5a9cd756-9120-4d5e-ac88-e9c636084f0e",
        "tags" : [
        ]
      },
      {
        "id" : "b6d56e4f-1df8-4b15-b2f5-21738ca21306",
        "parentId" : "8202fa28-c642-4c8e-b8e4-0e591fd74455",
        "authorId" : "128563de-a925-4397-af34-450c7978a8d2",
        "body" : "I've added a comment",
        "createdAt" : "2020-10-12T11:44:42Z",
        "updatedAt" : "2020-10-13T11:07:38Z",
        "lastEditedBy" : "128563de-a925-4397-af34-450c7978a8d2",
        "tags" : [
        ]
      }
    ],
    "commit" : "dc31c9d49fdc05001b053fc9c2c7e487dc626d39",
    "line" : 38,
    "diffHunk" : "@@ -1,1 +807,811 @@        val fieldDef = js.FieldDef(flags, fieldIdent, originalName, irTpe)\n        val optionalStaticFieldGetter =\n          if isStaticField then\n            // Here we are generating a public static getter for the static field,\n            // this is its API for other units. This is necessary for singleton"
  },
  {
    "id" : "560264b6-f78e-434a-899a-ba048fd90e51",
    "prId" : 9774,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/9774#pullrequestreview-494715746",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "34877a45-153d-49a5-a90b-8f0e61702b3d",
        "parentId" : null,
        "authorId" : "f186a0ec-8fc4-4e94-87e9-c629d1b38b60",
        "body" : "It seems we're amassing quite a bit of tech debt that can be fixed dotty internally. That is OK, especially if it is to bootstrap into something usable we can improve on.\r\nMy recommendation would be to track these in some form (can be issue tracker, doesn't have to be) so we can keep a grasp on them.",
        "createdAt" : "2020-09-19T16:09:59Z",
        "updatedAt" : "2020-10-02T07:35:23Z",
        "lastEditedBy" : "f186a0ec-8fc4-4e94-87e9-c629d1b38b60",
        "tags" : [
        ]
      },
      {
        "id" : "9a9975ef-a263-4483-9808-5cdb218253a6",
        "parentId" : "34877a45-153d-49a5-a90b-8f0e61702b3d",
        "authorId" : "5a9cd756-9120-4d5e-ac88-e9c636084f0e",
        "body" : "I intend to submit an issue for this one, but I haven't spent time on minimizing it yet. I'd like to find a minimization that is independent of Scala.js, since this is a typechecker issue.",
        "createdAt" : "2020-09-23T14:23:37Z",
        "updatedAt" : "2020-10-02T07:35:23Z",
        "lastEditedBy" : "5a9cd756-9120-4d5e-ac88-e9c636084f0e",
        "tags" : [
        ]
      }
    ],
    "commit" : "a91beaebba68297205b5e3716ff72edef1a2c570",
    "line" : 1190,
    "diffHunk" : "@@ -1,1 +3473,3477 @@         *\n         * Hopefully this will become unnecessary when/if we manage to\n         * reinterpret js.| as a true Dotty union type.\n         */\n        genArgs2._1"
  },
  {
    "id" : "d23bab3b-0b76-4dbe-8abb-207fb5f79fca",
    "prId" : 9725,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/9725#pullrequestreview-487318597",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "648267e1-76bc-4925-a908-fc315912d1ad",
        "parentId" : null,
        "authorId" : "f186a0ec-8fc4-4e94-87e9-c629d1b38b60",
        "body" : "It seems odd that the distinction of receiver types needs to be made here.",
        "createdAt" : "2020-09-13T09:23:30Z",
        "updatedAt" : "2020-09-14T20:05:33Z",
        "lastEditedBy" : "f186a0ec-8fc4-4e94-87e9-c629d1b38b60",
        "tags" : [
        ]
      },
      {
        "id" : "6a6c8b92-0de3-4208-b085-f090e7c225f5",
        "parentId" : "648267e1-76bc-4925-a908-fc315912d1ad",
        "authorId" : "5a9cd756-9120-4d5e-ac88-e9c636084f0e",
        "body" : "It's also done in scala-js/scala-js:\r\nhttps://github.com/scala-js/scala-js/blob/730931a3a11b351ea850a5c6107cfbd332c52a9b/compiler/src/main/scala/org/scalajs/nscplugin/GenJSCode.scala#L6171-L6188\r\n\r\nThat is necessary because the owner `SomeObject` referred to in an `@JSName(SomeObject.aSymbolVal)` can be a Scala object, a native JS object or a non-native JS object.",
        "createdAt" : "2020-09-13T15:52:14Z",
        "updatedAt" : "2020-09-14T20:05:33Z",
        "lastEditedBy" : "5a9cd756-9120-4d5e-ac88-e9c636084f0e",
        "tags" : [
        ]
      }
    ],
    "commit" : "9bcba442107e53e95c821c5372e21bea374296a6",
    "line" : 58,
    "diffHunk" : "@@ -1,1 +1026,1030 @@    } else {\n      genApplyMethod(module, sym, arguments = Nil)\n    }\n  }\n"
  },
  {
    "id" : "6da80266-6906-4761-b179-4e5c3762255f",
    "prId" : 9427,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/9427#pullrequestreview-455024085",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "12bdd0cb-fde1-415d-956b-730333788557",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "I wonder if you could make that conversion method inline to avoid having to deal with it here.",
        "createdAt" : "2020-07-24T15:49:55Z",
        "updatedAt" : "2020-07-27T09:02:45Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "694787a7-3948-4864-9f9d-3fa797a5c752",
        "parentId" : "12bdd0cb-fde1-415d-956b-730333788557",
        "authorId" : "5a9cd756-9120-4d5e-ac88-e9c636084f0e",
        "body" : "I tried that initially, but if I do that, then suddenly Type Mismatch errors anywhere suggests to import that implicit conversion because it could \"make progress towards a solution\" ... even though the result type is monomorphically `scala.reflect.Selectable`, even for type mismatches like \"Expected String but found Boolean\".\r\n\r\nI think the suggestion mechanism assumes that any `inline implicit def` could return a more precise type than what is declared (because you know, blackbox macros are just whitebox macros with a special body, so nobody can tell from the outside, which is a problem that seems to pop up every now and then in various scenarios).",
        "createdAt" : "2020-07-24T16:15:18Z",
        "updatedAt" : "2020-07-27T09:02:45Z",
        "lastEditedBy" : "5a9cd756-9120-4d5e-ac88-e9c636084f0e",
        "tags" : [
        ]
      },
      {
        "id" : "5fe44c8a-0b24-485a-a82a-38d7f5e6d32a",
        "parentId" : "12bdd0cb-fde1-415d-956b-730333788557",
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "> I think the suggestion mechanism assumes that any inline implicit def could return a more precise type than what is declared (because you know, blackbox macros are just whitebox macros with a special body, so nobody can tell from the outside, which is a problem that seems to pop up every now and then in various scenarios).\r\n\r\n@nicolasstucki What's the current status of whether `transparent` should be a flag or not? Is this a known issue with the current encoding?",
        "createdAt" : "2020-07-24T16:20:06Z",
        "updatedAt" : "2020-07-27T09:02:45Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "d419a98d-fb82-4335-a936-a2fdb48dc0bf",
        "parentId" : "12bdd0cb-fde1-415d-956b-730333788557",
        "authorId" : "5a9cd756-9120-4d5e-ac88-e9c636084f0e",
        "body" : "Anyway, for this specific case, I figured it would be better *not* to have it `inline`, otherwise it gets sketchy to rely on the fact that the inliner will preserve the shape of the tree, and in particular that the `fun1` directly inside the `Apply` will indeed be the call to `reflectiveSelectable` (and not a `Block` that ends in a call to `reflectiveSelectable`, notably).",
        "createdAt" : "2020-07-24T16:28:16Z",
        "updatedAt" : "2020-07-27T09:02:45Z",
        "lastEditedBy" : "5a9cd756-9120-4d5e-ac88-e9c636084f0e",
        "tags" : [
        ]
      }
    ],
    "commit" : "d5e88310d8ea83dac2426a6ecc2c8270f820872b",
    "line" : 114,
    "diffHunk" : "@@ -1,1 +2914,2918 @@      case Apply(fun1, receiver :: _)\n          if fun1.symbol == jsdefn.ReflectSelectable_reflectiveSelectable ||\n              fun1.symbol == jsdefn.Selectable_reflectiveSelectableFromLangReflectiveCalls =>\n        genExpr(receiver)\n"
  },
  {
    "id" : "09233691-7c40-477c-ac35-4061477a30cc",
    "prId" : 9427,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/9427#pullrequestreview-455346731",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "db13da93-ebd4-4713-8a4d-c5338a2f4b02",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "The compilers can also generate calls to ClassTag.Any, etc: https://github.com/lampepfl/dotty/blob/fd18546f7e6e08218a1dd269ae840096db4e585d/compiler/src/dotty/tools/dotc/typer/Synthesizer.scala#L39-L43, is that not handled?",
        "createdAt" : "2020-07-24T15:52:30Z",
        "updatedAt" : "2020-07-27T09:02:45Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "cbd67fb8-161c-4e49-a3e9-d07fd1ae43e0",
        "parentId" : "db13da93-ebd4-4713-8a4d-c5338a2f4b02",
        "authorId" : "5a9cd756-9120-4d5e-ac88-e9c636084f0e",
        "body" : "Ah, no it's not handled! I initially expected the compiler to do that for certain types, but I had not been able to reproduce it. I'll try with `Unit`, `Any` and `AnyVal`.",
        "createdAt" : "2020-07-24T16:16:40Z",
        "updatedAt" : "2020-07-27T09:02:45Z",
        "lastEditedBy" : "5a9cd756-9120-4d5e-ac88-e9c636084f0e",
        "tags" : [
        ]
      },
      {
        "id" : "69e17257-885b-403f-ac24-cbe492b538bf",
        "parentId" : "db13da93-ebd4-4713-8a4d-c5338a2f4b02",
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "I'm not sure why only these three are special-cased when https://github.com/scala/scala/blob/2.13.x/src/library/scala/reflect/ClassTag.scala also define Object and AnyRef which I don't think are problematic, in any case it would be a good idea to have a list of these things in Definitions and reuse that list in the JS backend and the Synthesizer to avoid them getting out of sync.",
        "createdAt" : "2020-07-24T16:22:05Z",
        "updatedAt" : "2020-07-27T09:02:45Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "b6d71526-cd01-446a-9399-d45f8c69f4b9",
        "parentId" : "db13da93-ebd4-4713-8a4d-c5338a2f4b02",
        "authorId" : "5a9cd756-9120-4d5e-ac88-e9c636084f0e",
        "body" : "Done as suggested, and I added test cases for those.",
        "createdAt" : "2020-07-26T09:12:48Z",
        "updatedAt" : "2020-07-27T09:02:45Z",
        "lastEditedBy" : "5a9cd756-9120-4d5e-ac88-e9c636084f0e",
        "tags" : [
        ]
      }
    ],
    "commit" : "d5e88310d8ea83dac2426a6ecc2c8270f820872b",
    "line" : 161,
    "diffHunk" : "@@ -1,1 +2961,2965 @@              report.error(\n                  \"The ClassTags passed to Selectable.applyDynamic must be \" +\n                  \"literal ClassTag(classOf[T]) expressions \" +\n                  \"(typically compiler-generated). \" +\n                  \"Other uses are not supported in Scala.js.\","
  },
  {
    "id" : "11bcebd9-e97a-4a8a-97a7-a6560a30cb06",
    "prId" : 9427,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/9427#pullrequestreview-455016710",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "812ba46a-3906-4541-be95-ef759d3e6fa7",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Do we have neg tests for the various error conditions in this method?",
        "createdAt" : "2020-07-24T15:53:26Z",
        "updatedAt" : "2020-07-27T09:02:45Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "36d73e19-7535-4e26-b75d-8da02ee54af1",
        "parentId" : "812ba46a-3906-4541-be95-ef759d3e6fa7",
        "authorId" : "5a9cd756-9120-4d5e-ac88-e9c636084f0e",
        "body" : "No. I'm not sure yet how to write negative tests for Scala.js-specific error messages.",
        "createdAt" : "2020-07-24T16:17:07Z",
        "updatedAt" : "2020-07-27T09:02:45Z",
        "lastEditedBy" : "5a9cd756-9120-4d5e-ac88-e9c636084f0e",
        "tags" : [
        ]
      }
    ],
    "commit" : "d5e88310d8ea83dac2426a6ecc2c8270f820872b",
    "line" : 180,
    "diffHunk" : "@@ -1,1 +2980,2984 @@          report.error(\n              \"Passing the varargs of Selectable.applyDynamic with `: _*` \" +\n              \"is not supported in Scala.js.\",\n              tree.sourcePos)\n          (Nil, Nil)"
  },
  {
    "id" : "47778f59-2ef4-47bc-af07-8ff879eb329f",
    "prId" : 9427,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/9427#pullrequestreview-455469303",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ca914ebc-19ac-4b30-a58d-3d86a58c9fe5",
        "parentId" : null,
        "authorId" : "f186a0ec-8fc4-4e94-87e9-c629d1b38b60",
        "body" : "Using a thing like `scala.reflect.Selectable` seems like a neat trick to easily implement reflective calls on backends that support reflection.\r\n\r\nHowever, here it seems that this trick is now doing the entire compiler a disservice: We have ~100 LOC simply reconstructing things and then a single LOC actually issuing the call. (and additionally failures that IIUC simply cannot happen with reflective calls).\r\n\r\nHave you considered introducing a form of transient tree and doing the translation to a call to `Selectable` later? (I realize that the call relies on other transformations that happen earlier, so it might be worse overall).",
        "createdAt" : "2020-07-24T16:25:27Z",
        "updatedAt" : "2020-07-27T09:02:45Z",
        "lastEditedBy" : "f186a0ec-8fc4-4e94-87e9-c629d1b38b60",
        "tags" : [
        ]
      },
      {
        "id" : "205d3b1f-eee1-4fbf-af2e-b99e7772d4f2",
        "parentId" : "ca914ebc-19ac-4b30-a58d-3d86a58c9fe5",
        "authorId" : "5a9cd756-9120-4d5e-ac88-e9c636084f0e",
        "body" : "I agree that the situation is very inconvenient. But the desugaring that is now done in Typer is actually *specced* as is now. It's not \"a trick\". It is the normal way of compiling calls to members of structural types. `reflectiveSelectable` is just *one* possible implicit that can provide an implementation for those, but there can be other, user-defined implementation (that don't really on Java reflection, but on an internal Map, for example).\r\n\r\nThe reference is here: https://dotty.epfl.ch/docs/reference/changed-features/structural-types.html\r\n\r\nWe need to support `reflectiveSelectable` because it corresponds to Scala 2 reflective calls, and it's the only way that our back-end would emit calls to reflective proxies (which we really need in some cases; we use them in the JDK implem in Scala.js itself for example).\r\n\r\nUsers can implement other `Selectable`s not relying on Java run-time reflection, and those would also work.\r\n\r\nSo we *can't* introduce a form of transient tree to be desugared later. The desugaring is by spec and requires interactions with other tasks of typechecking, including implicit resolution. It's impossible to delay that.",
        "createdAt" : "2020-07-26T09:21:59Z",
        "updatedAt" : "2020-07-27T09:02:45Z",
        "lastEditedBy" : "5a9cd756-9120-4d5e-ac88-e9c636084f0e",
        "tags" : [
        ]
      },
      {
        "id" : "28b22a43-5f36-4418-89a4-45a6f97e9f15",
        "parentId" : "ca914ebc-19ac-4b30-a58d-3d86a58c9fe5",
        "authorId" : "f186a0ec-8fc4-4e94-87e9-c629d1b38b60",
        "body" : "Hmmm... I see. So is the expectation that any custom `Selectable` that needs compile time reflection needs to do this ceremony? The page you linked doesn't go into details about that.\r\n\r\nFurther, if that is the case, shouldn't we introduce *another* `Selectable` for Scala.js? The main issue I see here is that with the current specification, it would be allowed to use `reflectiveSelectable` on its own, without structural types. However, such use would immediately lead to non-portable code. Maybe we should make this more obvious?",
        "createdAt" : "2020-07-27T04:44:22Z",
        "updatedAt" : "2020-07-27T09:02:45Z",
        "lastEditedBy" : "f186a0ec-8fc4-4e94-87e9-c629d1b38b60",
        "tags" : [
        ]
      },
      {
        "id" : "f12b5caf-511b-47d3-8a84-d8049e21a6ae",
        "parentId" : "ca914ebc-19ac-4b30-a58d-3d86a58c9fe5",
        "authorId" : "f186a0ec-8fc4-4e94-87e9-c629d1b38b60",
        "body" : "I realize this is probably a larger discussion, so you might want to go ahead with this PR. I still think it is worth thinking about this a bit more.",
        "createdAt" : "2020-07-27T04:50:04Z",
        "updatedAt" : "2020-07-27T09:02:45Z",
        "lastEditedBy" : "f186a0ec-8fc4-4e94-87e9-c629d1b38b60",
        "tags" : [
        ]
      }
    ],
    "commit" : "d5e88310d8ea83dac2426a6ecc2c8270f820872b",
    "line" : 101,
    "diffHunk" : "@@ -1,1 +2901,2905 @@   *\n   *  Virtually all of the code in `genReflectiveCall` deals with recovering\n   *  those elements. Constructing the IR Tree is the easy part after that.\n   */\n  private def genReflectiveCall(tree: Apply, isSelectDynamic: Boolean): js.Tree = {"
  },
  {
    "id" : "df4e8e9d-9f0b-4ccb-887a-ec8a161ce51a",
    "prId" : 9427,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/9427#pullrequestreview-455468052",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6345dc02-8a4f-4ac8-9e11-435e3c3c7a10",
        "parentId" : null,
        "authorId" : "f186a0ec-8fc4-4e94-87e9-c629d1b38b60",
        "body" : "Judging from the code of `reflect.Selectable`, `selectDynamic` is able to select actual bytecode fields (as opposed to accessors). Then again, it falls back to `applyDynamic`.\r\n\r\nI do not know the details of how dotty translates fields, but it seems this is problematic for exact compatibility.",
        "createdAt" : "2020-07-24T16:31:25Z",
        "updatedAt" : "2020-07-27T09:02:45Z",
        "lastEditedBy" : "f186a0ec-8fc4-4e94-87e9-c629d1b38b60",
        "tags" : [
        ]
      },
      {
        "id" : "33e606ac-fd47-488b-8b25-13b2161d9bc5",
        "parentId" : "6345dc02-8a4f-4ac8-9e11-435e3c3c7a10",
        "authorId" : "5a9cd756-9120-4d5e-ac88-e9c636084f0e",
        "body" : "On the JVM, we need to look up fields because of Java interop. A Java class such as\r\n```java\r\npublic class A {\r\n  public int foo = 5;\r\n}\r\n```\r\nqualifies for the Scala structural type\r\n```scala\r\n{ val foo: Int }\r\n```\r\nso for Java we need to try fields.\r\n\r\nIn the SJSIR, however, since JDK classes are implemented in Scala anyway, I don't think there can be an issue.",
        "createdAt" : "2020-07-26T09:17:03Z",
        "updatedAt" : "2020-07-27T09:02:45Z",
        "lastEditedBy" : "5a9cd756-9120-4d5e-ac88-e9c636084f0e",
        "tags" : [
        ]
      },
      {
        "id" : "d2df640a-4ca7-4dde-ab73-862c14cf2b61",
        "parentId" : "6345dc02-8a4f-4ac8-9e11-435e3c3c7a10",
        "authorId" : "f186a0ec-8fc4-4e94-87e9-c629d1b38b60",
        "body" : "Ah, OK. Fair enough.",
        "createdAt" : "2020-07-27T04:44:56Z",
        "updatedAt" : "2020-07-27T09:02:45Z",
        "lastEditedBy" : "f186a0ec-8fc4-4e94-87e9-c629d1b38b60",
        "tags" : [
        ]
      }
    ],
    "commit" : "d5e88310d8ea83dac2426a6ecc2c8270f820872b",
    "line" : 188,
    "diffHunk" : "@@ -1,1 +2988,2992 @@    val methodName = MethodName.reflectiveProxy(methodNameStr, formalParamTypeRefs)\n\n    js.Apply(js.ApplyFlags.empty, receiver, js.MethodIdent(methodName), actualArgs)(jstpe.AnyType)\n  }\n"
  },
  {
    "id" : "02fd3ced-ec2d-4dee-8d52-d2615a633610",
    "prId" : 9181,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/9181#pullrequestreview-453953377",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ca0e9136-41eb-45a0-98da-3238b737b6f5",
        "parentId" : null,
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "@sjrd The change causes non-termination in existing tests (not `RegressionTest.scala`). Any ideas?",
        "createdAt" : "2020-07-22T08:55:09Z",
        "updatedAt" : "2020-08-06T20:20:36Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "6a9ba710-3b16-457c-86bc-4331a1401412",
        "parentId" : "ca0e9136-41eb-45a0-98da-3238b737b6f5",
        "authorId" : "5a9cd756-9120-4d5e-ac88-e9c636084f0e",
        "body" : "Hum. If I apply the same change on `master`, I can successfully run all existing tests (but not `RegressionTest.scala`). So it seems that it is related to other changes in this PR. :s",
        "createdAt" : "2020-07-22T09:23:50Z",
        "updatedAt" : "2020-08-06T20:20:36Z",
        "lastEditedBy" : "5a9cd756-9120-4d5e-ac88-e9c636084f0e",
        "tags" : [
        ]
      },
      {
        "id" : "11644fbb-f63b-4f2e-a2cb-0a0c768a87e4",
        "parentId" : "ca0e9136-41eb-45a0-98da-3238b737b6f5",
        "authorId" : "5a9cd756-9120-4d5e-ac88-e9c636084f0e",
        "body" : "Perhaps this has to do with the fact that the JVM back-end uses `DesugaredSelect` instead of `Select`. `DesugaredSelect` is a helper in `DottyBackendInterface` that turns an `Ident` whose `tpe` is a prefix type into a `Select`.\r\n\r\nIf this becomes too complicated, drop the Scala.js part, and I'll have a look once this PR is merged.",
        "createdAt" : "2020-07-22T09:51:21Z",
        "updatedAt" : "2020-08-06T20:20:36Z",
        "lastEditedBy" : "5a9cd756-9120-4d5e-ac88-e9c636084f0e",
        "tags" : [
        ]
      },
      {
        "id" : "0eb11b70-7c47-4254-818f-8d41a281d486",
        "parentId" : "ca0e9136-41eb-45a0-98da-3238b737b6f5",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "Now it works after rebase, without using `DesugaredSelect`. The `RegressionTest.scala` test causes non-termination, so I didn't enable it.",
        "createdAt" : "2020-07-23T09:03:00Z",
        "updatedAt" : "2020-08-06T20:20:36Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "c2ce0c48-cdfa-406d-b547-cbd8fd13727c",
        "parentId" : "ca0e9136-41eb-45a0-98da-3238b737b6f5",
        "authorId" : "5a9cd756-9120-4d5e-ac88-e9c636084f0e",
        "body" : "Cool thank you :)",
        "createdAt" : "2020-07-23T09:05:41Z",
        "updatedAt" : "2020-08-06T20:20:36Z",
        "lastEditedBy" : "5a9cd756-9120-4d5e-ac88-e9c636084f0e",
        "tags" : [
        ]
      }
    ],
    "commit" : "745d53c78e040aea398c38754bcc8ff3ad2df91d",
    "line" : 18,
    "diffHunk" : "@@ -1,1 +1424,1428 @@       */\n      val superCall = genApplyMethodStatically(\n          genExpr(qual), sym, genActualArgs(sym, args))\n\n      // Initialize the module instance just after the super constructor call."
  }
]
[
  {
    "id" : "330a225f-bd64-4a49-b8dd-638bd354ddc5",
    "prId" : 10164,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/10164#pullrequestreview-526035728",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "392d54bc-88b2-42c6-91f3-06740398491d",
        "parentId" : null,
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "I noticed the scala 2 implementation is named `GenJSExports` and this one is named `JSExportsGen`. Was this change intentional?",
        "createdAt" : "2020-11-09T08:07:13Z",
        "updatedAt" : "2020-11-11T15:34:18Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      },
      {
        "id" : "f64286d3-8751-41e2-a177-a3f6951df635",
        "parentId" : "392d54bc-88b2-42c6-91f3-06740398491d",
        "authorId" : "5a9cd756-9120-4d5e-ac88-e9c636084f0e",
        "body" : "Yes, it was more consistent with `JSCodeGen`.",
        "createdAt" : "2020-11-09T08:51:32Z",
        "updatedAt" : "2020-11-11T15:34:18Z",
        "lastEditedBy" : "5a9cd756-9120-4d5e-ac88-e9c636084f0e",
        "tags" : [
        ]
      }
    ],
    "commit" : "69afa9cf05e232814348d9779a999b51db650f87",
    "line" : 23,
    "diffHunk" : "@@ -1,1 +41,45 @@\nfinal class JSExportsGen(jsCodeGen: JSCodeGen)(using Context) {\n  import jsCodeGen._\n  import positionConversions._\n"
  },
  {
    "id" : "866c5344-7424-45c6-8833-8299071b10d9",
    "prId" : 9774,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/9774#pullrequestreview-492005487",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "63c70208-4b1c-4d7d-b8e7-c26786172adb",
        "parentId" : null,
        "authorId" : "5a9cd756-9120-4d5e-ac88-e9c636084f0e",
        "body" : "In scalac, all three of those are `List[ParamSpec]`. In dotc the last 2 are `List[js.ParamDef]`, because it seems we cannot reliably obtain `Symbol`s for parameters added by intermediate phases (in this case, erasure and lambdalift).\r\n\r\nSomehow it looks like this computation has become even uglier than it was in scalac ...",
        "createdAt" : "2020-09-18T14:04:32Z",
        "updatedAt" : "2020-10-02T07:35:23Z",
        "lastEditedBy" : "5a9cd756-9120-4d5e-ac88-e9c636084f0e",
        "tags" : [
        ]
      },
      {
        "id" : "d62bec7c-7fb9-441e-862f-4151fbfc2b38",
        "parentId" : "63c70208-4b1c-4d7d-b8e7-c26786172adb",
        "authorId" : "5a9cd756-9120-4d5e-ac88-e9c636084f0e",
        "body" : "I have now simplified this a lot. It looks better than what we have in Scala 2 now :)",
        "createdAt" : "2020-09-20T08:49:26Z",
        "updatedAt" : "2020-10-02T07:35:23Z",
        "lastEditedBy" : "5a9cd756-9120-4d5e-ac88-e9c636084f0e",
        "tags" : [
        ]
      },
      {
        "id" : "5c3f1a83-0f5e-4386-86a1-5d1278fe6cb9",
        "parentId" : "63c70208-4b1c-4d7d-b8e7-c26786172adb",
        "authorId" : "f186a0ec-8fc4-4e94-87e9-c629d1b38b60",
        "body" : "Hum... So this *definitely* needs to go on the tech debt list. Could we maybe add a flag `isCaptureParam` or something that is set by the relevant phases?",
        "createdAt" : "2020-09-22T15:25:27Z",
        "updatedAt" : "2020-10-02T07:35:23Z",
        "lastEditedBy" : "f186a0ec-8fc4-4e94-87e9-c629d1b38b60",
        "tags" : [
        ]
      }
    ],
    "commit" : "a91beaebba68297205b5e3716ff72edef1a2c570",
    "line" : 581,
    "diffHunk" : "@@ -1,1 +579,583 @@\n    // params: List[ParamSpec] ; captureParams and captureParamsBack: List[js.ParamDef]\n    val (params, captureParamsFront, captureParamsBack) = {\n      val (paramNamesAtElimRepeated, paramInfosAtElimRepeated, methodHasDefaultParams) =\n        atPhase(elimRepeatedPhase)((sym.info.paramNamess.flatten, sym.info.paramInfoss.flatten, sym.hasDefaultParams))"
  },
  {
    "id" : "a0e018a2-85b6-4b21-97b8-09057df3cf5e",
    "prId" : 9774,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/9774#pullrequestreview-491492650",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c0a04722-84b2-4eb3-8eaf-277164db8c4f",
        "parentId" : null,
        "authorId" : "5a9cd756-9120-4d5e-ac88-e9c636084f0e",
        "body" : "Reviewers: From here until the end of this file, the contents are basically copied verbatim from Scala 2.",
        "createdAt" : "2020-09-18T14:07:46Z",
        "updatedAt" : "2020-10-02T07:35:23Z",
        "lastEditedBy" : "5a9cd756-9120-4d5e-ac88-e9c636084f0e",
        "tags" : [
        ]
      }
    ],
    "commit" : "a91beaebba68297205b5e3716ff72edef1a2c570",
    "line" : 677,
    "diffHunk" : "@@ -1,1 +675,679 @@\n  // !!! Hash codes of RTTypeTest are meaningless because of InstanceOfTypeTest\n  private sealed abstract class RTTypeTest\n\n  private case class PrimitiveTypeTest(tpe: jstpe.Type, rank: Int) extends RTTypeTest"
  },
  {
    "id" : "83351bc5-468d-4a58-acb4-b7f130532e49",
    "prId" : 9774,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/9774#pullrequestreview-495690725",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "76597df2-ae32-4e5d-9009-128b77ea0796",
        "parentId" : null,
        "authorId" : "f186a0ec-8fc4-4e94-87e9-c629d1b38b60",
        "body" : "This *imports* quite a bit of tech debt. (`Exported` as a class IMO does not make sense anymore, I have tried removing it, but it requires control flow changes, so I haven't gotten around to it yet).\r\n\r\nMaybe this is also OK, just want to point it out.",
        "createdAt" : "2020-09-19T16:28:35Z",
        "updatedAt" : "2020-10-02T07:35:23Z",
        "lastEditedBy" : "f186a0ec-8fc4-4e94-87e9-c629d1b38b60",
        "tags" : [
        ]
      },
      {
        "id" : "94e5fedb-4ec6-487e-a4d0-08337a2e2376",
        "parentId" : "76597df2-ae32-4e5d-9009-128b77ea0796",
        "authorId" : "5a9cd756-9120-4d5e-ac88-e9c636084f0e",
        "body" : "I'm not sure what's wrong, here. `Exported` gathers the information about how a method behaves in the context of the run-time overloading dispatch that `JSExportsGen` has to build. Since constructing that information is non-obvious, and is then reused several times over the run-time overloading dispatch generation algorithm, it makes sense to me to store that info somewhere, and it seems to me that a class is perfectly applicable for that.",
        "createdAt" : "2020-09-23T14:28:28Z",
        "updatedAt" : "2020-10-02T07:35:23Z",
        "lastEditedBy" : "5a9cd756-9120-4d5e-ac88-e9c636084f0e",
        "tags" : [
        ]
      },
      {
        "id" : "a01ea98a-0dfe-41cb-85ba-cf77f9323808",
        "parentId" : "76597df2-ae32-4e5d-9009-128b77ea0796",
        "authorId" : "f186a0ec-8fc4-4e94-87e9-c629d1b38b60",
        "body" : "What is strange IMO is that we calculate things inside the class itself (rather than in the flow of export generation). An `Exported` has no more semantic meaning than a `Symbol` (it used to, but not anymore). So IMO a better thing would be something more semantically meaningful.",
        "createdAt" : "2020-09-24T14:04:44Z",
        "updatedAt" : "2020-10-02T07:35:23Z",
        "lastEditedBy" : "f186a0ec-8fc4-4e94-87e9-c629d1b38b60",
        "tags" : [
        ]
      },
      {
        "id" : "81334978-194d-41e0-9259-e1f74c55cdb5",
        "parentId" : "76597df2-ae32-4e5d-9009-128b77ea0796",
        "authorId" : "5a9cd756-9120-4d5e-ac88-e9c636084f0e",
        "body" : "So ... IIUC, it would be better to\r\n\r\n1. Move the *computations* in a separate method that then instantiates the `Exported` with all the already computed data (rather than put everything in the constructor), and\r\n2. Rename it to something more meaningful, perhaps `SymbolExportInfo`?\r\n\r\nWould that address your concerns, or am I missing something?",
        "createdAt" : "2020-09-24T15:01:14Z",
        "updatedAt" : "2020-10-02T07:35:23Z",
        "lastEditedBy" : "5a9cd756-9120-4d5e-ac88-e9c636084f0e",
        "tags" : [
        ]
      },
      {
        "id" : "01c13695-4b92-48cb-8d0f-72bfb99239b1",
        "parentId" : "76597df2-ae32-4e5d-9009-128b77ea0796",
        "authorId" : "f186a0ec-8fc4-4e94-87e9-c629d1b38b60",
        "body" : "Yes. My feeling is that with a better control flow, some of this data becomes more local. But it's just a gut feeling. I haven't tried.",
        "createdAt" : "2020-09-24T15:24:32Z",
        "updatedAt" : "2020-10-02T07:35:23Z",
        "lastEditedBy" : "f186a0ec-8fc4-4e94-87e9-c629d1b38b60",
        "tags" : [
        ]
      }
    ],
    "commit" : "a91beaebba68297205b5e3716ff72edef1a2c570",
    "line" : 89,
    "diffHunk" : "@@ -1,1 +87,91 @@\n  def genJSConstructorDispatch(alts: List[Symbol]): (Option[List[js.ParamDef]], js.JSMethodDef) = {\n    val exporteds = alts.map(Exported)\n\n    val isConstructorOfNestedJSClass = exporteds.head.isConstructorOfNestedJSClass"
  },
  {
    "id" : "d40aa9a9-7af3-4b51-becb-aa3e1eeacc51",
    "prId" : 9774,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/9774#pullrequestreview-494715746",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "15cfd3bf-ac18-4ecc-b4ab-b0a123384f73",
        "parentId" : null,
        "authorId" : "f186a0ec-8fc4-4e94-87e9-c629d1b38b60",
        "body" : "Why does this need `groupByWithoutHashCode`? `RTTypeTest` seems to only have concrete case class / case object subtypes.",
        "createdAt" : "2020-09-22T10:45:51Z",
        "updatedAt" : "2020-10-02T07:35:23Z",
        "lastEditedBy" : "f186a0ec-8fc4-4e94-87e9-c629d1b38b60",
        "tags" : [
        ]
      },
      {
        "id" : "2a4c7a76-a390-4d8a-a204-2c506bf968db",
        "parentId" : "15cfd3bf-ac18-4ecc-b4ab-b0a123384f73",
        "authorId" : "5a9cd756-9120-4d5e-ac88-e9c636084f0e",
        "body" : "The concrete subtype `InstanceOfTypeTest` contains a `Type`, with an `equals` method that compares the `Type`s using `=:=`. It does not provide a `hashCode` because `=:=` does not have a corresponding notion of hash code. That's why we have to use `groupByWithoutHashCode`. I have added comments on `RTTypeTest` and `InstanceOfTypeTest` to make that clear.\r\n\r\nWe have exactly the same situation in Scala 2.",
        "createdAt" : "2020-09-23T15:23:14Z",
        "updatedAt" : "2020-10-02T07:35:23Z",
        "lastEditedBy" : "5a9cd756-9120-4d5e-ac88-e9c636084f0e",
        "tags" : [
        ]
      }
    ],
    "commit" : "a91beaebba68297205b5e3716ff72edef1a2c570",
    "line" : 301,
    "diffHunk" : "@@ -1,1 +299,303 @@      js.Undefined()\n    } else {\n      val altsByTypeTest = groupByWithoutHashCode(alts) { exported =>\n        typeTestForTpe(exported.exportArgTypeAt(paramIndex))\n      }"
  },
  {
    "id" : "9a680f02-7122-4ad0-b39b-9737f4ed8346",
    "prId" : 9774,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/9774#pullrequestreview-494715746",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0123eaaf-2aba-46f8-aa07-d0a203c2ccee",
        "parentId" : null,
        "authorId" : "f186a0ec-8fc4-4e94-87e9-c629d1b38b60",
        "body" : "Use `genApplyJSMethodGeneric`?",
        "createdAt" : "2020-09-22T12:02:22Z",
        "updatedAt" : "2020-10-02T07:35:23Z",
        "lastEditedBy" : "f186a0ec-8fc4-4e94-87e9-c629d1b38b60",
        "tags" : [
        ]
      },
      {
        "id" : "a58bfda7-3825-4ab2-a38a-2a37f8973eaf",
        "parentId" : "0123eaaf-2aba-46f8-aa07-d0a203c2ccee",
        "authorId" : "5a9cd756-9120-4d5e-ac88-e9c636084f0e",
        "body" : "That was actually very tempting, but it doesn't work because `genApplyJSMethodGeneric` unboxes the result, and here we must keep it boxed.",
        "createdAt" : "2020-09-23T15:51:15Z",
        "updatedAt" : "2020-10-02T07:35:23Z",
        "lastEditedBy" : "5a9cd756-9120-4d5e-ac88-e9c636084f0e",
        "tags" : [
        ]
      }
    ],
    "commit" : "a91beaebba68297205b5e3716ff72edef1a2c570",
    "line" : 423,
    "diffHunk" : "@@ -1,1 +421,425 @@    } else {\n      js.JSSuperMethodCall(superClass, receiver, nameTree, allArgs)\n    }\n  }\n"
  },
  {
    "id" : "653841f6-6867-4d06-94cb-196d2ee67b8f",
    "prId" : 9774,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/9774#pullrequestreview-494715746",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "648636b9-4af0-4c2d-991b-24d9af5b1281",
        "parentId" : null,
        "authorId" : "f186a0ec-8fc4-4e94-87e9-c629d1b38b60",
        "body" : "Hum, isn't there an issue with `allArgs` here? It is generate from the `FormalArgsRegistry` which has arguments for *all* overloads. So it might very well be that there are more args, but they are just unused for this overload.",
        "createdAt" : "2020-09-22T14:53:29Z",
        "updatedAt" : "2020-10-02T07:35:23Z",
        "lastEditedBy" : "f186a0ec-8fc4-4e94-87e9-c629d1b38b60",
        "tags" : [
        ]
      },
      {
        "id" : "635b533a-9bc5-4b52-8ce0-c0976855828b",
        "parentId" : "648636b9-4af0-4c2d-991b-24d9af5b1281",
        "authorId" : "5a9cd756-9120-4d5e-ac88-e9c636084f0e",
        "body" : "That cannot happen because a getter cannot be overloaded with non-getter methods (in exports or JS classes). This is tested in `genJSClassDispatcher`, which reports a compile error if it is violated.",
        "createdAt" : "2020-09-23T15:27:21Z",
        "updatedAt" : "2020-10-02T07:35:23Z",
        "lastEditedBy" : "5a9cd756-9120-4d5e-ac88-e9c636084f0e",
        "tags" : [
        ]
      }
    ],
    "commit" : "a91beaebba68297205b5e3716ff72edef1a2c570",
    "line" : 413,
    "diffHunk" : "@@ -1,1 +411,415 @@\n    if (sym.isJSGetter) {\n      assert(allArgs.isEmpty,\n          s\"getter symbol $sym does not have a getter signature\")\n      js.JSSuperSelect(superClass, receiver, nameTree)"
  },
  {
    "id" : "346a9afc-1067-4d0d-b6f5-761345655db6",
    "prId" : 9774,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/9774#pullrequestreview-494715746",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4a33f682-6204-4ff6-ab57-3e2be14d2be3",
        "parentId" : null,
        "authorId" : "f186a0ec-8fc4-4e94-87e9-c629d1b38b60",
        "body" : "Same here: Aren't we potentially passing too many args? (Which might make the fun to behave differently).",
        "createdAt" : "2020-09-22T14:54:40Z",
        "updatedAt" : "2020-10-02T07:35:23Z",
        "lastEditedBy" : "f186a0ec-8fc4-4e94-87e9-c629d1b38b60",
        "tags" : [
        ]
      },
      {
        "id" : "2bf6e3ce-182b-40e6-be5c-19c047bb066c",
        "parentId" : "4a33f682-6204-4ff6-ab57-3e2be14d2be3",
        "authorId" : "5a9cd756-9120-4d5e-ac88-e9c636084f0e",
        "body" : "No, we're passing exactly the arguments that we received (the rest param being passed with a spread to re-expand it).",
        "createdAt" : "2020-09-23T15:43:12Z",
        "updatedAt" : "2020-10-02T07:35:23Z",
        "lastEditedBy" : "5a9cd756-9120-4d5e-ac88-e9c636084f0e",
        "tags" : [
        ]
      }
    ],
    "commit" : "a91beaebba68297205b5e3716ff72edef1a2c570",
    "line" : 422,
    "diffHunk" : "@@ -1,1 +420,424 @@          allArgs.head.asInstanceOf[js.Tree])\n    } else {\n      js.JSSuperMethodCall(superClass, receiver, nameTree, allArgs)\n    }\n  }"
  },
  {
    "id" : "c319b538-1a47-4270-a82d-0e66ffcb07fc",
    "prId" : 9774,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/9774#pullrequestreview-494670027",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a3849cfc-e10c-45d0-804c-007264c25ce5",
        "parentId" : null,
        "authorId" : "f186a0ec-8fc4-4e94-87e9-c629d1b38b60",
        "body" : "This is suspicious: It feel like it's a bug in the compiler if something is marked as default param but doesn't have a getter. Or do I not understand how this works in Dotty?",
        "createdAt" : "2020-09-22T15:16:24Z",
        "updatedAt" : "2020-10-02T07:35:23Z",
        "lastEditedBy" : "f186a0ec-8fc4-4e94-87e9-c629d1b38b60",
        "tags" : [
        ]
      },
      {
        "id" : "3a95f9d8-d8e6-47b0-a7f7-518b1e52745a",
        "parentId" : "a3849cfc-e10c-45d0-804c-007264c25ce5",
        "authorId" : "5a9cd756-9120-4d5e-ac88-e9c636084f0e",
        "body" : "In dotty, params themselves are not marked as default parms. The *method* is marked as having one or more defaults. This is what `methodHasDefaultParams` tests. Then, once the the method has default params, we need to test whether a particular parameter has a default value by testing whether a default getter exists for it, depending on its owning method name and its index.\r\n\r\nBoth tests are necessary. If we only test whether a default getter exists, we would mistakenly think that a parameter has a default value, when in fact it is a parameter in the same position *of an overload* of the method that has a default value, like:\r\n```scala\r\ndef foo(a: Int, x: Int): Int = ???\r\ndef foo(b: Int, y: String = \"hello\"): String = ???\r\n```\r\nwe would think that `x` has a default value, because `defaultGetterDenot` would return the getter for `\"hello\"`. And if we only test `methodHasDefaultParams`, we would think that `b` has a default value.\r\n\r\nSo both sides of the `&&` are required and make sense.",
        "createdAt" : "2020-09-23T13:39:06Z",
        "updatedAt" : "2020-10-02T07:35:23Z",
        "lastEditedBy" : "5a9cd756-9120-4d5e-ac88-e9c636084f0e",
        "tags" : [
        ]
      }
    ],
    "commit" : "a91beaebba68297205b5e3716ff72edef1a2c570",
    "line" : 570,
    "diffHunk" : "@@ -1,1 +568,572 @@      val isRepeated = infoAtElimRepeated.isRepeatedParam\n      val info = if (isRepeated) infoAtElimRepeated.repeatedToSingle else infoAtElimEVT\n      val hasDefault = methodHasDefaultParams && defaultGetterDenot(methodSym, paramIndex).exists\n      new ParamSpec(info, isRepeated, hasDefault)\n    }"
  }
]
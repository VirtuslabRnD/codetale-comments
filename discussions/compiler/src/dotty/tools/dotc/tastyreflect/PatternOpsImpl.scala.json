[
  {
    "id" : "18fe5599-b679-4e75-bd7e-93505340c64c",
    "prId" : 5953,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/5953#pullrequestreview-205808230",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8658c65c-7d2d-4ef1-aa3e-1aae9586dfcf",
        "parentId" : null,
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "This seems to be an argument that we should disregard TypeTrees in TastyReflect -- they are not reliable, macros should always depend on types instead of type trees.",
        "createdAt" : "2019-02-20T13:22:13Z",
        "updatedAt" : "2019-02-20T13:22:21Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "c5ef27be-bddc-4220-a8bc-a7777c7ad0b4",
        "parentId" : "8658c65c-7d2d-4ef1-aa3e-1aae9586dfcf",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "We need the trees for positions. And this is not a type tree, it is the pattern `_: T` of a `case _: T =>`",
        "createdAt" : "2019-02-20T15:03:21Z",
        "updatedAt" : "2019-02-20T15:03:21Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      }
    ],
    "commit" : "c2fd8d93660dc4f447f538441b27c357f7b3b5ee",
    "line" : 45,
    "diffHunk" : "@@ -1,1 +135,139 @@\n      def copy(original: TypeTest)(tpt: TypeTree)(implicit ctx: Context): TypeTest =\n        tpd.cpy.Typed(original)(untpd.Ident(nme.WILDCARD).withSpan(original.span).withType(tpt.tpe), tpt)\n\n      def unapply(x: Pattern)(implicit ctx: Context): Option[TypeTree] = x match {"
  },
  {
    "id" : "8d22f462-dc26-41d0-925e-3331fed185d7",
    "prId" : 5438,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/5438#pullrequestreview-185990063",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "dce0e4c5-b4fd-47ea-b88e-0189c7a13e73",
        "parentId" : null,
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "Do we need `apply` and `copy` for `Value`? I have the impression that constructors are usually concrete.",
        "createdAt" : "2018-12-18T08:51:42Z",
        "updatedAt" : "2018-12-18T09:09:48Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "82fa817a-4711-4819-ba5e-18ae4da89d6b",
        "parentId" : "dce0e4c5-b4fd-47ea-b88e-0189c7a13e73",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "Yes, I am considering splitting the `Value` type into more concrete types for literals and term references",
        "createdAt" : "2018-12-18T10:07:21Z",
        "updatedAt" : "2018-12-18T10:07:22Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      }
    ],
    "commit" : "5419a4c3914c08378e25dd46bcc692ed32566b64",
    "line" : 63,
    "diffHunk" : "@@ -1,1 +60,64 @@        case ref: tpd.RefTree if ref.isTerm => tpd.cpy.Ref(original.asInstanceOf[tpd.RefTree])(ref.name)\n        case ths: tpd.This => tpd.cpy.This(original)(ths.qual)\n      }\n      def unapply(x: Pattern)(implicit ctx: Context): Option[Term] = IsValue.unapply(x)\n    }"
  }
]
[
  {
    "id" : "f3e71955-211a-4d87-8b13-bc3b301cf6ae",
    "prId" : 8808,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/8808#pullrequestreview-401985294",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6a9b6353-1f10-4a93-8e9e-ea2545fcd51a",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Can we avoid all these unchecked warnings by replacing `x: Any` by `x: tpd.Tree` here and below? /cc @nicolasstucki ",
        "createdAt" : "2020-04-28T16:05:50Z",
        "updatedAt" : "2020-04-29T12:04:28Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      }
    ],
    "commit" : "841d19176f3fdc7da45e800634e9f3f6971c9add",
    "line" : 3,
    "diffHunk" : "@@ -1,1 +117,121 @@  def isInstanceOfPackageClause(using ctx: Context): IsInstanceOf[PackageClause] = new {\n    def runtimeClass: Class[?] = classOf[PackageClause]\n    override def unapply(x: Any): Option[PackageClause] = x match\n      case x: tpd.PackageDef @unchecked => Some(x)\n      case _ => None"
  },
  {
    "id" : "f4f6c90c-d235-46b6-8cee-8ca733b91f1f",
    "prId" : 8251,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/8251#pullrequestreview-356832628",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "99dc6993-db7e-4ce4-813a-4e15581b0620",
        "parentId" : null,
        "authorId" : "98bdc06d-7937-462c-9d62-1f850e7819aa",
        "body" : "@fhackett won't this crash if the ascribed type has a `val apply` member that's not a method? I think this could happen if the term passed as `fn` is not really a function, or if the `apply` is overloaded. Something like:\r\n\r\n```scala\r\nscala> object test extends (String => String) { val apply = (x:Int) => x; def apply(x: String) = x }\r\n// defined object test\r\n\r\nscala> test.apply(\"abc\")\r\nval res0: String = abc\r\n\r\nscala> test.apply\r\nval res1: Int => Int = test$$$Lambda$1268/578362229@6f3bd37f\r\n```\r\n",
        "createdAt" : "2020-02-11T10:54:03Z",
        "updatedAt" : "2020-02-11T10:54:03Z",
        "lastEditedBy" : "98bdc06d-7937-462c-9d62-1f850e7819aa",
        "tags" : [
        ]
      },
      {
        "id" : "cade5a35-f88f-417d-9c1f-0fad3644a5f2",
        "parentId" : "99dc6993-db7e-4ce4-813a-4e15581b0620",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "This case is only reached if the prefix is an explicit closure.",
        "createdAt" : "2020-02-11T12:22:11Z",
        "updatedAt" : "2020-02-11T12:22:11Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      },
      {
        "id" : "39cd9514-6f71-4047-b879-f39ff3531eac",
        "parentId" : "99dc6993-db7e-4ce4-813a-4e15581b0620",
        "authorId" : "98bdc06d-7937-462c-9d62-1f850e7819aa",
        "body" : "Right, I had missed the `closureDef` pattern. But it seems even a `Closure` can have a type that contains an overloaded `apply` member: indeed it [can be any SAM type](https://github.com/lampepfl/dotty/blob/a29178ce4ac848e773423f57f45186373f410970/compiler/src/dotty/tools/dotc/ast/Trees.scala#L508-L510), no?",
        "createdAt" : "2020-02-11T13:18:03Z",
        "updatedAt" : "2020-02-11T13:18:03Z",
        "lastEditedBy" : "98bdc06d-7937-462c-9d62-1f850e7819aa",
        "tags" : [
        ]
      },
      {
        "id" : "d06095a7-31a6-4218-afc0-d295ad6979cf",
        "parentId" : "99dc6993-db7e-4ce4-813a-4e15581b0620",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "Maybe, I will have to check if we can get one of those here. @LPTK did you have a specific example in mind?",
        "createdAt" : "2020-02-11T13:28:56Z",
        "updatedAt" : "2020-02-11T13:28:57Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      },
      {
        "id" : "ee4df525-a807-49db-a60c-152f4c0c6978",
        "parentId" : "99dc6993-db7e-4ce4-813a-4e15581b0620",
        "authorId" : "98bdc06d-7937-462c-9d62-1f850e7819aa",
        "body" : "Something like `betaReduce('{ (x => x) : Test }, ...)` where we have:\r\n\r\n```scala\r\nabstract class Test extends (String => String) { val apply = 123 }\r\n```",
        "createdAt" : "2020-02-11T15:22:14Z",
        "updatedAt" : "2020-02-11T15:22:50Z",
        "lastEditedBy" : "98bdc06d-7937-462c-9d62-1f850e7819aa",
        "tags" : [
        ]
      },
      {
        "id" : "7c7c7a21-9fb9-40f9-8cf5-295e6896af5c",
        "parentId" : "99dc6993-db7e-4ce4-813a-4e15581b0620",
        "authorId" : "458c389d-bdc4-40dd-8a41-33a82a521583",
        "body" : "I tried it, and we get a class cast exception.\r\nI can figure out a fix - should I push a second commit here or open a second issue+PR?",
        "createdAt" : "2020-02-11T16:43:03Z",
        "updatedAt" : "2020-02-11T16:43:04Z",
        "lastEditedBy" : "458c389d-bdc4-40dd-8a41-33a82a521583",
        "tags" : [
        ]
      },
      {
        "id" : "b70591df-0de2-45a0-906c-2cf85b644959",
        "parentId" : "99dc6993-db7e-4ce4-813a-4e15581b0620",
        "authorId" : "458c389d-bdc4-40dd-8a41-33a82a521583",
        "body" : "Actually, I can do one \"better\". See this fun edge case:\r\n```Scala\r\nabstract class Test extends (Int => Int) {\r\n  def impl(i: Int): Int\r\n  def apply(i: Int): Int = ???\r\n}\r\n```",
        "createdAt" : "2020-02-11T16:49:27Z",
        "updatedAt" : "2020-02-11T16:49:55Z",
        "lastEditedBy" : "458c389d-bdc4-40dd-8a41-33a82a521583",
        "tags" : [
        ]
      },
      {
        "id" : "1c6c7281-e554-4405-a042-410f25303ac5",
        "parentId" : "99dc6993-db7e-4ce4-813a-4e15581b0620",
        "authorId" : "458c389d-bdc4-40dd-8a41-33a82a521583",
        "body" : "This is getting more involved than just a quick fix, so I'll open a fresh issue.",
        "createdAt" : "2020-02-11T16:52:59Z",
        "updatedAt" : "2020-02-11T16:52:59Z",
        "lastEditedBy" : "458c389d-bdc4-40dd-8a41-33a82a521583",
        "tags" : [
        ]
      },
      {
        "id" : "b231f405-40fe-46c1-a219-477112377b95",
        "parentId" : "99dc6993-db7e-4ce4-813a-4e15581b0620",
        "authorId" : "458c389d-bdc4-40dd-8a41-33a82a521583",
        "body" : "Continued on #8290",
        "createdAt" : "2020-02-11T17:03:38Z",
        "updatedAt" : "2020-02-11T17:03:39Z",
        "lastEditedBy" : "458c389d-bdc4-40dd-8a41-33a82a521583",
        "tags" : [
        ]
      }
    ],
    "commit" : "0c349946c0260ed1c25927fb8a0e775a771f270d",
    "line" : 28,
    "diffHunk" : "@@ -1,1 +2064,2068 @@          case Some(tpt) =>\n            // we assume the ascribed type has an apply that has a MethodType with a single param list (there should be no polys)\n            val methodType = tpt.tpe.member(nme.apply).info.asInstanceOf[MethodType]\n            // result might contain paramrefs, so we substitute them with arg termrefs\n            val resultTypeWithSubst = methodType.resultType.substParams(methodType, argRefs.map(_.tpe))"
  },
  {
    "id" : "08773a08-6657-4cc8-a89e-6f24ff7406ba",
    "prId" : 7528,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/7528#pullrequestreview-318600736",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "56d743e3-659f-4d41-a6e2-a5f62c14704d",
        "parentId" : null,
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "Can `isInstanceOfPackageClause` be `val`, given the `rootContext`? Same question for similar cases.",
        "createdAt" : "2019-11-18T16:11:38Z",
        "updatedAt" : "2019-11-18T20:26:19Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "0e9c24ed-ed88-421a-894e-4621781f008c",
        "parentId" : "56d743e3-659f-4d41-a6e2-a5f62c14704d",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "Maybe they can. I will explore that possibility later.",
        "createdAt" : "2019-11-18T20:14:07Z",
        "updatedAt" : "2019-11-18T20:26:19Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      }
    ],
    "commit" : "3798b6ff97f64be290d46310128fcc630508146d",
    "line" : 21,
    "diffHunk" : "@@ -1,1 +100,104 @@      case x: tpd.PackageDef => Some(x)\n      case _ => None\n  }\n\n  def PackageClause_pid(self: PackageClause)(given Context): Ref = self.pid"
  },
  {
    "id" : "f72ac8be-602c-4b0a-b2df-d27f66bff7bc",
    "prId" : 7528,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/7528#pullrequestreview-318602351",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1e83fda8-ff4f-48e0-bb0a-4bf606138784",
        "parentId" : null,
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "Maybe define an inline method to abstract the code pattern to make the implementation more succinct?",
        "createdAt" : "2019-11-18T16:19:18Z",
        "updatedAt" : "2019-11-18T20:26:19Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "09611bea-319f-4608-901f-924f94498b06",
        "parentId" : "1e83fda8-ff4f-48e0-bb0a-4bf606138784",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "This code will change when we replace the ClassTag. I would wait to factor out logic until then.",
        "createdAt" : "2019-11-18T20:17:06Z",
        "updatedAt" : "2019-11-18T20:26:19Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      }
    ],
    "commit" : "3798b6ff97f64be290d46310128fcc630508146d",
    "line" : 344,
    "diffHunk" : "@@ -1,1 +481,485 @@      case x: tpd.Assign => Some(x)\n      case _ => None\n  }\n\n  def Assign_lhs(self: Assign)(given Context): Term = self.lhs"
  },
  {
    "id" : "d4b6876a-bca7-475c-bb90-2258ebf67632",
    "prId" : 7506,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/7506#pullrequestreview-312542465",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "515d52c8-1804-45ac-ad9d-3eba2b8c81f8",
        "parentId" : null,
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "This change seems to break consistency with other types of trees.",
        "createdAt" : "2019-11-06T11:14:44Z",
        "updatedAt" : "2019-11-06T15:55:05Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "bfb2ddde-3253-44c4-9190-5fe6057bda48",
        "parentId" : "515d52c8-1804-45ac-ad9d-3eba2b8c81f8",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "Those should also change. It should be as in the dotty tree copier. I will adapt the missing ones.",
        "createdAt" : "2019-11-06T11:33:31Z",
        "updatedAt" : "2019-11-06T15:55:05Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      },
      {
        "id" : "97a9063e-cac3-48a7-9a9b-a42ceb38d711",
        "parentId" : "515d52c8-1804-45ac-ad9d-3eba2b8c81f8",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "Changed them",
        "createdAt" : "2019-11-06T15:55:34Z",
        "updatedAt" : "2019-11-06T15:55:34Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      }
    ],
    "commit" : "845fe936a7dff6a93499c47e75102f766d23874f",
    "line" : 42,
    "diffHunk" : "@@ -1,1 +206,210 @@\n  def DefDef_copy(original: Tree)(name: String, typeParams: List[TypeDef], paramss: List[List[ValDef]], tpt: TypeTree, rhs: Option[Term])(given Context): DefDef =\n    tpd.cpy.DefDef(original)(name.toTermName, typeParams, paramss, tpt, rhs.getOrElse(tpd.EmptyTree))\n\n  type ValDef = tpd.ValDef"
  }
]
[
  {
    "id" : "7d37c1f7-ce6e-41fb-a194-43e1d1d3f078",
    "prId" : 5763,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/5763#pullrequestreview-202048028",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "38dc6eb0-ba86-4d6d-81df-df4748ac6016",
        "parentId" : null,
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Ahead warning: We'll probably drop non-local returns so this will change at some point.\r\n",
        "createdAt" : "2019-02-10T18:02:02Z",
        "updatedAt" : "2019-02-14T06:43:23Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "5a5158c6-b7aa-4701-b446-ee9e4fde5420",
        "parentId" : "38dc6eb0-ba86-4d6d-81df-df4748ac6016",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "I am aware of this, that is why it always references the owner. If we do not drop non-local returns I would have to add it as an extra parameter to `copy`, `apply` and `unapply`.",
        "createdAt" : "2019-02-11T11:04:18Z",
        "updatedAt" : "2019-02-14T06:43:23Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      }
    ],
    "commit" : "bb9874c4bd40b5e853ae19721898c16d4393e7a1",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +778,782 @@\n      def copy(original: Tree)(expr: Term)(implicit ctx: Context): Return =\n        tpd.cpy.Return(original)(expr, tpd.ref(ctx.owner))\n\n      def unapply(x: Term)(implicit ctx: Context): Option[Term] = x match {"
  },
  {
    "id" : "0a72dbc8-5216-468d-aea4-b236fcc66519",
    "prId" : 5138,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/5138#pullrequestreview-158976319",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9d9fed29-75ca-4ade-a6e9-040c9607fb1a",
        "parentId" : null,
        "authorId" : "223e67d6-1873-432a-9af9-f40b82a7eedd",
        "body" : "Maybe make this part of the `scala.quoted.Expr` API as suggested by @nicolasstucki initially",
        "createdAt" : "2018-09-26T12:21:22Z",
        "updatedAt" : "2018-09-26T14:05:31Z",
        "lastEditedBy" : "223e67d6-1873-432a-9af9-f40b82a7eedd",
        "tags" : [
        ]
      },
      {
        "id" : "0cac58c0-9c14-4654-8915-77f72c075812",
        "parentId" : "9d9fed29-75ca-4ade-a6e9-040c9607fb1a",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "No, this is the correct way to do it. If you do not inspect the tree, you should not know about the implementation details. I mean when using purely generative macros.",
        "createdAt" : "2018-09-26T12:36:44Z",
        "updatedAt" : "2018-09-26T14:05:31Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      },
      {
        "id" : "65e2fcd9-b0f7-4dbf-860e-b707adf04746",
        "parentId" : "9d9fed29-75ca-4ade-a6e9-040c9607fb1a",
        "authorId" : "223e67d6-1873-432a-9af9-f40b82a7eedd",
        "body" : "Sorry, I meant as an extension method like `toTasty`:\r\nhttps://github.com/lampepfl/dotty/blob/06738295d54f1e945becf89dc809b3ff923dc57a/compiler/src/dotty/tools/dotc/tastyreflect/QuotedOpsImpl.scala#L11\r\n\r\nSo not visible when doing only purely generative macros",
        "createdAt" : "2018-09-26T12:41:21Z",
        "updatedAt" : "2018-09-26T14:05:31Z",
        "lastEditedBy" : "223e67d6-1873-432a-9af9-f40b82a7eedd",
        "tags" : [
        ]
      },
      {
        "id" : "bd817fb6-1c68-4022-b5c4-ea99cd62999f",
        "parentId" : "9d9fed29-75ca-4ade-a6e9-040c9607fb1a",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "Oh yes. This way is more flexible as it does not only work for the parameters but for any term you might have inside the tree.",
        "createdAt" : "2018-09-26T12:46:55Z",
        "updatedAt" : "2018-09-26T14:05:31Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      }
    ],
    "commit" : "0b8ffaff6ef8b91952a0a4cc05831eadc9c025c0",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +185,189 @@    def pos(implicit ctx: Context): Position = term.pos\n    def tpe(implicit ctx: Context): Types.Type = term.tpe\n    def underlyingArgument(implicit ctx: Context): Term = {\n      import tpd._\n      term.underlyingArgument"
  },
  {
    "id" : "56579d20-aa68-4640-9df4-d9d20b65eeaf",
    "prId" : 5113,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/5113#pullrequestreview-156246861",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "af965a41-be65-4a17-a068-9b445d060377",
        "parentId" : null,
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "Before this case we should check that this is not a `do while`.",
        "createdAt" : "2018-09-18T08:08:11Z",
        "updatedAt" : "2018-09-21T18:56:15Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      },
      {
        "id" : "7e7439a8-fd7d-4988-9302-5e337c502eec",
        "parentId" : "af965a41-be65-4a17-a068-9b445d060377",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "Or maybe it would be better to remove the `do while` extractor and place that condition in the decompiler.",
        "createdAt" : "2018-09-18T08:09:31Z",
        "updatedAt" : "2018-09-21T18:56:15Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      }
    ],
    "commit" : "2acfbf83d81601fc8ff6d3ea1aa1a57dc023ae8c",
    "line" : 28,
    "diffHunk" : "@@ -1,1 +375,379 @@    object While extends WhileExtractor {\n      def unapply(x: Term)(implicit ctx: Context): Option[(Term, Term)] = x match {\n        case x: tpd.WhileDo => Some((x.cond, x.body))\n        case _ => None\n      }"
  },
  {
    "id" : "fedd915c-9833-4692-8ffa-c681580ab850",
    "prId" : 4998,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/4998#pullrequestreview-149535198",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "75e95c8a-39d5-4f21-a8d2-2c6d7479126e",
        "parentId" : null,
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "This seems dangerous to me, as any term can now be disguised as `Parent`. The same for `TypeTree`. Conceptually, how it is different from making `Parent` a supertype of `Term` and `TypeTree`?",
        "createdAt" : "2018-08-26T09:38:01Z",
        "updatedAt" : "2018-08-26T09:38:04Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "44108c99-828a-4278-805d-b2acd7e2e8e4",
        "parentId" : "75e95c8a-39d5-4f21-a8d2-2c6d7479126e",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "It is not conceptually different, but it solves the ambiguity in the extractor when passing a `Term` as term could be a `Tree` or a `Parent`. This will be removed when we bootstrap and I'll be able to define `type Parent = Term | TypeTree` and have a simple extractor for both.",
        "createdAt" : "2018-08-26T11:35:41Z",
        "updatedAt" : "2018-08-26T11:35:41Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      }
    ],
    "commit" : "12f0e436eae51237197cd22def6a7b1f7e56bc3a",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +398,402 @@  }\n\n  def termAsParent(term: Term): Parent = term\n}"
  }
]
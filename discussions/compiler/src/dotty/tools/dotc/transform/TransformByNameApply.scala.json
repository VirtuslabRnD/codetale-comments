[
  {
    "id" : "be37231f-7ab2-4125-862d-fb2f31b89b34",
    "prId" : 9753,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/9753#pullrequestreview-485635770",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "746c851a-7268-4e59-b1ad-1df30853fb29",
        "parentId" : null,
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "Does it matter? If I were correct, the body of inlined methods is never executed, thus only the TASTY matters.",
        "createdAt" : "2020-09-10T06:12:51Z",
        "updatedAt" : "2020-09-10T06:13:09Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "19803f6c-26ac-4366-9187-09cf3b6624c7",
        "parentId" : "746c851a-7268-4e59-b1ad-1df30853fb29",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "In theory that seems to be the case. But I caught one that came for the `DottyPredef.assert` when compiling dotty itself. It might be a re-bootstrapping issue.",
        "createdAt" : "2020-09-10T06:42:59Z",
        "updatedAt" : "2020-09-10T06:43:00Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      },
      {
        "id" : "79581c5a-c8ce-40ad-a2a4-6f0c46947eef",
        "parentId" : "746c851a-7268-4e59-b1ad-1df30853fb29",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "I see. It could be some invariants after the typer -- and it's always good to do so.",
        "createdAt" : "2020-09-10T07:02:20Z",
        "updatedAt" : "2020-09-10T07:02:21Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      }
    ],
    "commit" : "c15936185c153781a0e055f5c6201075b6b84c14",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +48,52 @@          arg match {\n            case Apply(Select(qual, nme.apply), Nil)\n            if qual.tpe.derivesFrom(defn.FunctionClass(0)) && (isPureExpr(qual) || qual.symbol.isAllOf(Inline | Param)) =>\n              wrap(qual)\n            case _ =>"
  },
  {
    "id" : "1c9b1481-195e-4894-9347-047b03f1e23c",
    "prId" : 5713,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/5713#pullrequestreview-194194469",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c7199110-ee2a-4e92-8684-1ce642791454",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "How come we need an explicit withSpan here ?",
        "createdAt" : "2019-01-18T15:45:43Z",
        "updatedAt" : "2019-01-18T18:36:33Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "655334ec-55f6-4823-9e3f-f10042911ae7",
        "parentId" : "c7199110-ee2a-4e92-8684-1ce642791454",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "I don't remember all the details.  I believe it was a cbn argument from another sourcefile. We do treat these situations specially when we wrap in a Hole or an Inlined. Here we have another case of such wrapping, but arguably the position does not matter, since the cbn-arg will be eliminated at erasure anyway.\r\n",
        "createdAt" : "2019-01-18T17:06:19Z",
        "updatedAt" : "2019-01-18T18:36:33Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "fc2e65471eb9473409f7c8e4b6d8028998e9f40d",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +45,49 @@        if (defn.isBottomType(argType)) argType = formal.widenExpr\n        def wrap(arg: Tree) =\n          ref(defn.cbnArg).appliedToType(argType).appliedTo(arg).withSpan(arg.span)\n        arg match {\n          case Apply(Select(qual, nme.apply), Nil)"
  },
  {
    "id" : "b3c2ad3b-7795-4e39-aa3f-c99206114900",
    "prId" : 2282,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/2282#pullrequestreview-35366171",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "cb5180bb-b840-43a7-a819-093fc84183a6",
        "parentId" : null,
        "authorId" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "body" : "can be private",
        "createdAt" : "2017-04-28T10:05:51Z",
        "updatedAt" : "2017-04-28T13:57:03Z",
        "lastEditedBy" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "tags" : [
        ]
      },
      {
        "id" : "87cdc12f-8449-4776-8182-d5c0c6feb0e7",
        "parentId" : "cb5180bb-b840-43a7-a819-093fc84183a6",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "No it's used in elimByName",
        "createdAt" : "2017-04-28T13:54:47Z",
        "updatedAt" : "2017-04-28T13:57:03Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "b14969c50efd5239a8d76236d522f144977a9167",
    "line" : 27,
    "diffHunk" : "@@ -1,1 +25,29 @@\n  /** If denotation had an ExprType before, it now gets a function type */\n  protected def exprBecomesFunction(symd: SymDenotation)(implicit ctx: Context) =\n    (symd is Param) || (symd is (ParamAccessor, butNot = Method))\n"
  }
]
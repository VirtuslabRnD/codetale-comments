[
  {
    "id" : "4053982a-63ef-4326-b9fd-85544f84e9cd",
    "prId" : 1775,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/1775#pullrequestreview-13041588",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ce23eea2-d73a-489d-a147-b3525f788b6f",
        "parentId" : null,
        "authorId" : "348fab8e-49e2-442e-884d-850c7f41fdde",
        "body" : "Any reason why this optimization is restricted to implicit functions? Done this way, this seems rather ad-hoc.",
        "createdAt" : "2016-12-13T19:45:51Z",
        "updatedAt" : "2016-12-17T20:50:40Z",
        "lastEditedBy" : "348fab8e-49e2-442e-884d-850c7f41fdde",
        "tags" : [
        ]
      },
      {
        "id" : "ba5ba574-ed8c-4e41-9ae8-5d529e7e8d89",
        "parentId" : "ce23eea2-d73a-489d-a147-b3525f788b6f",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "The main reason is that the rewrite is based on the *type* of the result. For implicit function types we have a perfect match. The typing rules guarantee that every function that has an implicit function result type **must** be implemented by a closure. For normal functions this is not guaranteed, so we do not know whether the optimization is globally effective or not. It could make things worse, actually.",
        "createdAt" : "2016-12-13T19:51:03Z",
        "updatedAt" : "2016-12-17T20:50:40Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "65f49363-c438-4f31-866e-f505937f7350",
        "parentId" : "ce23eea2-d73a-489d-a147-b3525f788b6f",
        "authorId" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "body" : "@Blaisorblade, additionally note that normal function types are non-final and in case `m` is overriden in as subclass by a non closure with custom apply logic, you could have hard time figuring out what should `$direct` method do.",
        "createdAt" : "2016-12-13T19:53:53Z",
        "updatedAt" : "2016-12-17T20:50:40Z",
        "lastEditedBy" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "tags" : [
        ]
      },
      {
        "id" : "5c0e1a9a-8d87-44c6-a84a-5701c356965c",
        "parentId" : "ce23eea2-d73a-489d-a147-b3525f788b6f",
        "authorId" : "348fab8e-49e2-442e-884d-850c7f41fdde",
        "body" : "> The typing rules guarantee that every function that has an implicit function result type must be implemented by a closure.\r\n\r\nSo I can't implement an implicit function type by returning a closure? Are those non-first-class?\r\n\r\nQuite a few things suggest the following: `A => B` is a value type, while `implicit A => B` is a non-value type (IMHO a method type). I see why you're doing that, but that doesn't sound very orthogonal to me—this is a small thing, but that's the sort of thing which gives Scala its reputation for complexity. And while this fits in the heads of compiler hackers, the heads of (advanced) users also matter.\r\n\r\nOn Discourse I started sketching, as an alternative, a (limited) form of abstraction on non-value types (in particular, method types). I expect there are questions there too, but right now it seems to me you are in fact implementing a special-case of that.\r\n(I don't propose abstract non-value types—I'd expect them to be type aliases, according to the same rules you use here, whatever they are exactly).",
        "createdAt" : "2016-12-13T20:21:09Z",
        "updatedAt" : "2016-12-17T20:50:40Z",
        "lastEditedBy" : "348fab8e-49e2-442e-884d-850c7f41fdde",
        "tags" : [
        ]
      },
      {
        "id" : "675e45ab-e143-43d2-8b4d-1f4b2adb92c6",
        "parentId" : "ce23eea2-d73a-489d-a147-b3525f788b6f",
        "authorId" : "348fab8e-49e2-442e-884d-850c7f41fdde",
        "body" : "Link to sketch: https://contributors.scala-lang.org/t/implicit-function-types/219/21?u=blaisorblade",
        "createdAt" : "2016-12-13T20:22:05Z",
        "updatedAt" : "2016-12-17T20:50:40Z",
        "lastEditedBy" : "348fab8e-49e2-442e-884d-850c7f41fdde",
        "tags" : [
        ]
      },
      {
        "id" : "f4c9c5c5-6c9b-4403-a7fa-31d46f0c6f20",
        "parentId" : "ce23eea2-d73a-489d-a147-b3525f788b6f",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Let's say you have\r\n\r\n     val cl: implicit A => B\r\n     def f: implicit A => B = cl\r\n\r\nThen by the rules of implicit expansion this will gve you an eta-expansion on the rhs of `f`:\r\n\r\n    def f: implicit A => B = implicit $x: A => cl($x)\r\n\r\nThat's what guarantees that the right-hand side of every method with implicit function result type is an implicit function value. For normal functions that guarantee does not hold, so we might well be pessimizing code with a shortcutting optimization. ",
        "createdAt" : "2016-12-14T15:22:23Z",
        "updatedAt" : "2016-12-17T20:50:40Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "d9efcdd2-69d7-456f-bfde-5c7b63d6840e",
        "parentId" : "ce23eea2-d73a-489d-a147-b3525f788b6f",
        "authorId" : "348fab8e-49e2-442e-884d-850c7f41fdde",
        "body" : "Ah, so here we inline the eta-expansion and emit a call to `cl`, while with normal functions we only have a non-inlined call to CL (which will be inlined anyway by the JVM). Fair enough.\r\nMaybe some info about this should be part of the code docs?",
        "createdAt" : "2016-12-15T00:55:47Z",
        "updatedAt" : "2016-12-17T20:50:40Z",
        "lastEditedBy" : "348fab8e-49e2-442e-884d-850c7f41fdde",
        "tags" : [
        ]
      }
    ],
    "commit" : "2e99511840915e2805e7a2c07571d3859a3db698",
    "line" : 30,
    "diffHunk" : "@@ -1,1 +28,32 @@ *\n *      def m(xs: Ts): IF = implicit (ys: Us) => m$direct(xs)(ys)\n *      def m$direct(xs: Ts)(ys: Us): R = E\n *\n *  (and equivalently for methods with type parameters or a different number of value parameter lists)."
  },
  {
    "id" : "0c8b4fa8-5878-4a8e-82d3-a1af055bc5ec",
    "prId" : 1775,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/1775#pullrequestreview-13173697",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9a455f47-c7d3-4ed1-a35b-55672b2e586f",
        "parentId" : null,
        "authorId" : "1f1241a4-206b-4204-be44-be9e433da151",
        "body" : "This sort of transform needs to take some care about what annotations end up on the old and new methods, for things like `@synchronized` and `@strictfp` semantics depend on it. For general annotations, having a copy on both methods might break assumptions of the consumer of the annotations.\r\n\r\nRepresentative bug fix in Scala: https://github.com/scala/scala/pull/5540",
        "createdAt" : "2016-12-15T01:17:30Z",
        "updatedAt" : "2016-12-17T20:50:40Z",
        "lastEditedBy" : "1f1241a4-206b-4204-be44-be9e433da151",
        "tags" : [
        ]
      },
      {
        "id" : "6b7ed9e5-d8cc-4601-9a56-bbcb93dbd817",
        "parentId" : "9a455f47-c7d3-4ed1-a35b-55672b2e586f",
        "authorId" : "1f1241a4-206b-4204-be44-be9e433da151",
        "body" : "The same applies to the flags. The original sym might have `OVERRIDE`, but that doesn't guarantee that the direct method will override.\r\n\r\n```\r\ntrait T[A] { def foo: A = ??? }\r\nclass C extends T[Transactional[Int]] {\r\n  override def foo: Transactional[Int] = ??? // direct method won't be an override\r\n}\r\n```",
        "createdAt" : "2016-12-15T01:26:32Z",
        "updatedAt" : "2016-12-17T20:50:40Z",
        "lastEditedBy" : "1f1241a4-206b-4204-be44-be9e433da151",
        "tags" : [
        ]
      },
      {
        "id" : "a4f65146-c0af-4d5c-b901-584c55912c96",
        "parentId" : "9a455f47-c7d3-4ed1-a35b-55672b2e586f",
        "authorId" : "1f1241a4-206b-4204-be44-be9e433da151",
        "body" : "Confused myself above, `synchronized` is a flag (on class methods after uncurry) not an annotation.",
        "createdAt" : "2016-12-15T01:38:56Z",
        "updatedAt" : "2016-12-17T20:50:40Z",
        "lastEditedBy" : "1f1241a4-206b-4204-be44-be9e433da151",
        "tags" : [
        ]
      },
      {
        "id" : "b7ddd1f9-b303-4e8c-b67d-5bc87d191482",
        "parentId" : "9a455f47-c7d3-4ed1-a35b-55672b2e586f",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "We still don't do a systematic job for annotations. We just copy them wholesale when copying symbols. This should be guided by some meta-annotation scheme but that remains to be done. As to flags, I agree it's not clean to always copy \"Override\". I don't think it matters because we don't test the flag after the transform, but we should avoid it anyway. I'll add a change.",
        "createdAt" : "2016-12-15T17:06:32Z",
        "updatedAt" : "2016-12-17T20:50:40Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "2e99511840915e2805e7a2c07571d3859a3db698",
    "line" : null,
    "diffHunk" : "@@ -1,1 +94,98 @@        name = sym.name.directName,\n        flags = sym.flags | Synthetic,\n        info = directInfo(sym.info))\n      if (direct.allOverriddenSymbols.isEmpty) direct.resetFlag(Override)\n      direct"
  },
  {
    "id" : "2f30c013-c5bc-4725-9748-51beb1509ea1",
    "prId" : 1775,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/1775#pullrequestreview-13174523",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c0d5f8bd-c559-494e-bbfc-ecf3120d610d",
        "parentId" : null,
        "authorId" : "1f1241a4-206b-4204-be44-be9e433da151",
        "body" : "I'm guessing that this transform is (correctly) skipped for:\r\n\r\n```\r\nscala> def foo(a: Any): Transactional[Int] = 42\r\ndef foo(a: Any): Transactional[Int]\r\nscala> (if (\"\".isEmpty) foo(\"\") else foo(\"\")).apply(\"\")\r\n```\r\n\r\nBecause `tree.qualifier.symbol` would be `NoSymbol`.\r\n\r\nBut just wanted to check that I'm reading this correctly.",
        "createdAt" : "2016-12-15T01:31:45Z",
        "updatedAt" : "2016-12-17T20:50:40Z",
        "lastEditedBy" : "1f1241a4-206b-4204-be44-be9e433da151",
        "tags" : [
        ]
      },
      {
        "id" : "472be4f8-e0e2-4f71-96d4-625c7cb05989",
        "parentId" : "c0d5f8bd-c559-494e-bbfc-ecf3120d610d",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Yes, that's correct.\r\n",
        "createdAt" : "2016-12-15T17:10:32Z",
        "updatedAt" : "2016-12-17T20:50:40Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "2e99511840915e2805e7a2c07571d3859a3db698",
    "line" : 125,
    "diffHunk" : "@@ -1,1 +123,127 @@          case tree: RefTree =>\n            cpy.Ref(tree)(tree.name.directName)\n              .withType(directMethod(tree.symbol).termRef)\n        }\n        directQual(tree.qualifier)"
  },
  {
    "id" : "e6209150-8b8c-42fc-9dae-4fa545739a48",
    "prId" : 1775,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/1775#pullrequestreview-13338323",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "48997c0e-5c72-43f9-b289-593a38af118e",
        "parentId" : null,
        "authorId" : "1f1241a4-206b-4204-be44-be9e433da151",
        "body" : "Does this force the current info transform on the base types? If not, the result might be non-determistic. I found this a bit fiddly to get right in an [example i once created](https://github.com/retronym/scalac-survival-guide/blob/master/src/main/scala/guide/_22_InfoTransform.scala) for how to do this in a compiler plugin.",
        "createdAt" : "2016-12-16T11:16:39Z",
        "updatedAt" : "2016-12-17T20:50:40Z",
        "lastEditedBy" : "1f1241a4-206b-4204-be44-be9e433da151",
        "tags" : [
        ]
      },
      {
        "id" : "868fefcf-d212-43bd-814e-378b36f00ae0",
        "parentId" : "48997c0e-5c72-43f9-b289-593a38af118e",
        "authorId" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "body" : "It will invoke infoTransforms, but this phase doesn't register one(it actually does, but it's identity), it forcefully updates denotations. ",
        "createdAt" : "2016-12-16T11:43:31Z",
        "updatedAt" : "2016-12-17T20:50:40Z",
        "lastEditedBy" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "tags" : [
        ]
      },
      {
        "id" : "7e70cea4-0f9d-4f25-a97b-d219a12d0105",
        "parentId" : "48997c0e-5c72-43f9-b289-593a38af118e",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "@retronym Any infoTransforms in phases up to this one would be forced on the basetypes, yes.\r\n",
        "createdAt" : "2016-12-16T14:04:32Z",
        "updatedAt" : "2016-12-17T20:50:40Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "2e99511840915e2805e7a2c07571d3859a3db698",
    "line" : 98,
    "diffHunk" : "@@ -1,1 +96,100 @@        info = directInfo(sym.info))\n      if (direct.allOverriddenSymbols.isEmpty) direct.resetFlag(Override)\n      direct\n    }\n"
  },
  {
    "id" : "b05dd127-e35d-4418-82b0-5e8ef2cdfd0b",
    "prId" : 1775,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/1775#pullrequestreview-13338463",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3bdbda11-9273-4bf4-990a-ae6c5265cb44",
        "parentId" : null,
        "authorId" : "1f1241a4-206b-4204-be44-be9e433da151",
        "body" : "Do you need to reset the `ABSTRACT` flag on the original method, now that it always contains a forwarder?",
        "createdAt" : "2016-12-16T11:18:31Z",
        "updatedAt" : "2016-12-17T20:50:40Z",
        "lastEditedBy" : "1f1241a4-206b-4204-be44-be9e433da151",
        "tags" : [
        ]
      },
      {
        "id" : "c359deac-72eb-480a-b7c3-da6849fedb3d",
        "parentId" : "3bdbda11-9273-4bf4-990a-ae6c5265cb44",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "No, a Deferred method would not get a forwarder.\r\n",
        "createdAt" : "2016-12-16T14:05:32Z",
        "updatedAt" : "2016-12-17T20:50:40Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "2e99511840915e2805e7a2c07571d3859a3db698",
    "line" : 158,
    "diffHunk" : "@@ -1,1 +156,160 @@\n        val (remappedCore, fwdClosure) = splitClosure(mdef.rhs)\n        val originalDef = cpy.DefDef(mdef)(rhs = fwdClosure)\n        val directDef = polyDefDef(direct.asTerm, remappedCore)\n        Thicket(originalDef, directDef)"
  }
]
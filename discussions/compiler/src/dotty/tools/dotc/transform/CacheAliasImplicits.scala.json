[
  {
    "id" : "f1f8a568-d0ac-42a8-82cb-49ce8bc37f85",
    "prId" : 10371,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/10371#pullrequestreview-535646645",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "75b56762-297d-4b5b-8c86-795bd753e120",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "The documentation comment of this class still states that aliases start as defs, it should be updated to describe how things work now.",
        "createdAt" : "2020-11-20T17:45:38Z",
        "updatedAt" : "2020-11-23T09:26:54Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      }
    ],
    "commit" : "8c3f80a6047566a5489e043210dacb3d369c3660",
    "line" : 38,
    "diffHunk" : "@@ -1,1 +36,40 @@class CacheAliasImplicits extends MiniPhase with IdentityDenotTransformer { thisPhase =>\n  import tpd._\n\n  override def phaseName: String = CacheAliasImplicits.name\n"
  },
  {
    "id" : "3e2df9d7-10f9-4e98-b657-42356df43ccd",
    "prId" : 10371,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/10371#pullrequestreview-536292344",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d0465a8d-608d-4b55-8749-21c612ff049a",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "So this code path is only triggered because of these generated defs? Couldn't they be defined as given lazy vals too?",
        "createdAt" : "2020-11-20T17:47:26Z",
        "updatedAt" : "2020-11-23T09:26:54Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "1ecceca1-7a0e-43ed-a4ff-f32a1830ba73",
        "parentId" : "d0465a8d-608d-4b55-8749-21c612ff049a",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "I thought of it but then decided against. Typeclass derivation is very implicit. I felt its better to generate in one way only. This would make a difference if, say, the generated typeclass would have a side effect on instantiation. I have no idea whether something like this would be useful or not. But its easier to reason about if parameterized instances and parameterless instances behave the same.\r\n",
        "createdAt" : "2020-11-23T09:26:26Z",
        "updatedAt" : "2020-11-23T09:26:54Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "8c3f80a6047566a5489e043210dacb3d369c3660",
    "line" : 63,
    "diffHunk" : "@@ -1,1 +61,65 @@   *    y\n   *\n   *  Parameterless given defs are generated during typeclass derivation.\n   */\n  override def transformDefDef(tree: DefDef)(using Context): Tree = {"
  }
]
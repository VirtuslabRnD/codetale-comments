[
  {
    "id" : "4da20fde-36b3-491b-b426-582f1aaa67b0",
    "prId" : 4045,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/4045#pullrequestreview-101224706",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c5b8b1b1-e7be-4b0d-aff8-ef9dede514e3",
        "parentId" : null,
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "Add comment warning maintainers this code is fragile, since unchecked might hide type errors...",
        "createdAt" : "2018-03-05T16:17:05Z",
        "updatedAt" : "2018-04-05T14:26:58Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      }
    ],
    "commit" : "2b00b7a8b352f1adbedfca70946a2170c8148b94",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +154,158 @@     *    (this eq that) || {\n     *      that match {\n     *        case x$0 @ (_: C @unchecked) => this.x == this$0.x && this.y == x$0.y\n     *        case _ => false\n     *     }"
  },
  {
    "id" : "0cc76c21-c342-4cfe-a203-0e06e2bd691b",
    "prId" : 3342,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/3342#pullrequestreview-90726426",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3ff2a1c3-8462-471e-b9ab-7daa07e04997",
        "parentId" : null,
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "??? Did not understand. Can you give an example?",
        "createdAt" : "2018-01-21T20:13:31Z",
        "updatedAt" : "2018-02-21T10:25:44Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "c0e81adc-5e49-4065-b601-3dda6110e538",
        "parentId" : "3ff2a1c3-8462-471e-b9ab-7daa07e04997",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "Value classes must have exactly one parameter, but we can add additional ones if they are `unused`. We already check that the first parameter list is not `unused` (same for case classes).\r\n```scala\r\nclass Foo(v: Int)(unused ev: Ev) extends AnyVal\r\n```\r\nWhen we have that, we need to ignore the `unused` parameters when generating synthetic methods. In the case of a value class we know that the only the first parameter is needed.",
        "createdAt" : "2018-01-23T07:19:34Z",
        "updatedAt" : "2018-02-21T10:25:44Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      }
    ],
    "commit" : "68afbcd915c5f6e17f4d1347c6a784c9b1639b13",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +60,64 @@    val clazzType = clazz.appliedRef\n    lazy val accessors =\n      if (isDerivedValueClass(clazz)) clazz.paramAccessors.take(1) // Tail parameters can only be `unused`\n      else clazz.caseAccessors\n"
  },
  {
    "id" : "0ddc0677-d96a-42a8-a824-11812fab5364",
    "prId" : 3125,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/3125#pullrequestreview-64886717",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8061f100-0c7a-453f-bf06-86bc752a7b05",
        "parentId" : null,
        "authorId" : "6d71bb21-e402-4464-b2b1-8bdd8e068461",
        "body" : "I would just do `myValueSymbols = defn.Any_hashCode :: (if (clazz.is(Module)) defn.Any_equals :: Nil else Nil)` instead",
        "createdAt" : "2017-09-25T12:43:41Z",
        "updatedAt" : "2017-09-25T12:43:41Z",
        "lastEditedBy" : "6d71bb21-e402-4464-b2b1-8bdd8e068461",
        "tags" : [
        ]
      },
      {
        "id" : "08f4b135-6e96-4282-926d-142922b173b8",
        "parentId" : "8061f100-0c7a-453f-bf06-86bc752a7b05",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "That can't be done here, this is precomputing the lists for any `clazz`. We do not have access to the `clazz` in `initSymbols`",
        "createdAt" : "2017-09-25T13:01:12Z",
        "updatedAt" : "2017-09-25T13:01:12Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      }
    ],
    "commit" : "c8eed58af14bb5d2de85afdc27d989cd47bec8f5",
    "line" : 11,
    "diffHunk" : "@@ -1,1 +49,53 @@      myCaseSymbols = myValueSymbols ++ List(defn.Any_toString, defn.Product_canEqual,\n        defn.Product_productArity, defn.Product_productPrefix, defn.Product_productElement)\n      myCaseModuleSymbols = myCaseSymbols.filter(_ ne defn.Any_equals)\n    }\n"
  },
  {
    "id" : "f3fca41d-e2db-4f1a-9a2a-0d2a0cd1716b",
    "prId" : 2314,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/2314#pullrequestreview-36002848",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b0dc9b7d-36a7-459d-a027-4cef0edca880",
        "parentId" : null,
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "I think there's an easier way to get this, but I'll play with it and do it in a different PR.\r\n",
        "createdAt" : "2017-05-02T14:08:32Z",
        "updatedAt" : "2017-05-02T14:08:59Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "a3be58ac-e007-40f4-bda0-073bcb0f2fbe",
        "parentId" : "b0dc9b7d-36a7-459d-a027-4cef0edca880",
        "authorId" : "6d71bb21-e402-4464-b2b1-8bdd8e068461",
        "body" : "`IndexOutOfBoundsException` contains two declarations, its primary constructor (which takes not argument), and this other constructor that takes a String. I first did `.decls.toList.tail.head`, then changed it to this very precise filter, do you have something in between?",
        "createdAt" : "2017-05-03T12:22:50Z",
        "updatedAt" : "2017-05-03T12:22:50Z",
        "lastEditedBy" : "6d71bb21-e402-4464-b2b1-8bdd8e068461",
        "tags" : [
        ]
      }
    ],
    "commit" : "c7de6a4fc46417a466a79e5cf2931c9fcd063fd0",
    "line" : 73,
    "diffHunk" : "@@ -1,1 +120,124 @@      def filterStringConstructor(s: Symbol): Boolean = s.info match {\n        case m: MethodType if s.isConstructor => m.paramInfos == List(defn.StringType)\n        case _ => false\n      }\n      val constructor = ioob.typeSymbol.info.decls.find(filterStringConstructor _).asTerm"
  },
  {
    "id" : "e6fbadc1-8243-4c24-9443-b247b9fcfb74",
    "prId" : 2159,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/2159#pullrequestreview-30496096",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a8d27f2d-e528-4cd6-bcd5-d8b67253576d",
        "parentId" : null,
        "authorId" : "1f1241a4-206b-4204-be44-be9e433da151",
        "body" : "`scalac` uses `productPrefix` (which is user definable), rather than the class name. \r\n\r\nWhat is the definition of `fullName` for non-member classes?",
        "createdAt" : "2017-04-03T11:39:26Z",
        "updatedAt" : "2017-04-03T11:39:27Z",
        "lastEditedBy" : "1f1241a4-206b-4204-be44-be9e433da151",
        "tags" : [
        ]
      },
      {
        "id" : "d62b3fe0-4ee3-49bd-bb04-a8dbc97d2f58",
        "parentId" : "a8d27f2d-e528-4cd6-bcd5-d8b67253576d",
        "authorId" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "body" : "> scalac uses productPrefix (which is user definable), rather than the class name.\r\n\r\nWhat's the motivation behind this?\r\nProduct prefix isn't required to even return the same value, so one can break hash-code by returning different values there.",
        "createdAt" : "2017-04-03T11:42:52Z",
        "updatedAt" : "2017-04-03T11:42:52Z",
        "lastEditedBy" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "tags" : [
        ]
      },
      {
        "id" : "da253a98-a2d1-44b4-af70-c44b7b23cd01",
        "parentId" : "a8d27f2d-e528-4cd6-bcd5-d8b67253576d",
        "authorId" : "1f1241a4-206b-4204-be44-be9e433da151",
        "body" : "Neither are the case accessors (they could be `var`s).\r\n\r\nI guess a motivation would be to have more stable hash codes for a local case class so that it wasn't volatile wrt fresh name suffixes. Perhaps this implementation acheives the same by inlining `fullName`, rather than calling `this.getClass.toString`).\r\n\r\nI'm just pointing out the deviation.",
        "createdAt" : "2017-04-03T11:44:35Z",
        "updatedAt" : "2017-04-03T11:45:43Z",
        "lastEditedBy" : "1f1241a4-206b-4204-be44-be9e433da151",
        "tags" : [
        ]
      },
      {
        "id" : "1fc9a6a2-782b-42e8-8ffd-ed54ff980f6c",
        "parentId" : "a8d27f2d-e528-4cd6-bcd5-d8b67253576d",
        "authorId" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "body" : "AFAIK, The full name here won't include any fresh name suffices. They will be only added after Flatten. Two local classes with the same name will get the same constant.",
        "createdAt" : "2017-04-03T11:47:00Z",
        "updatedAt" : "2017-04-03T11:47:00Z",
        "lastEditedBy" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "tags" : [
        ]
      },
      {
        "id" : "abb774ec-c476-41f5-8a6d-1e4bf799ceea",
        "parentId" : "a8d27f2d-e528-4cd6-bcd5-d8b67253576d",
        "authorId" : "1f1241a4-206b-4204-be44-be9e433da151",
        "body" : "> Neither are the case accessors (they could be vars).\r\n\r\nI see now, though, that a mutable `productPrefix` would be worse that a var accessor, as `equals` does not check that `this.productPrefix == that.productPrefix`.",
        "createdAt" : "2017-04-03T11:53:45Z",
        "updatedAt" : "2017-04-03T11:53:45Z",
        "lastEditedBy" : "1f1241a4-206b-4204-be44-be9e433da151",
        "tags" : [
        ]
      }
    ],
    "commit" : "710e700b2285738bc0700ed548517efc1f368bb0",
    "line" : 20,
    "diffHunk" : "@@ -1,1 +159,163 @@    def caseHashCodeBody(implicit ctx: Context): Tree = {\n      val acc = ctx.newSymbol(ctx.owner, \"acc\".toTermName, Mutable | Synthetic, defn.IntType, coord = ctx.owner.pos)\n      val accDef = ValDef(acc, Literal(Constant(clazz.fullName.toString.hashCode)))\n      val mixes = for (accessor <- accessors.toList) yield\n        Assign(ref(acc), ref(defn.staticsMethod(\"mix\")).appliedTo(ref(acc), hashImpl(accessor)))"
  }
]
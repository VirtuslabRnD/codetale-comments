[
  {
    "id" : "5e0affaf-c5fb-45ad-8f51-48e05502c1a0",
    "prId" : 4045,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/4045#pullrequestreview-106472442",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "756a8880-7554-4b88-b5ae-a338729f8ac0",
        "parentId" : null,
        "authorId" : "223e67d6-1873-432a-9af9-f40b82a7eedd",
        "body" : "Can you explain why there is a special treatment for Array?",
        "createdAt" : "2018-03-22T10:05:00Z",
        "updatedAt" : "2018-04-05T14:26:58Z",
        "lastEditedBy" : "223e67d6-1873-432a-9af9-f40b82a7eedd",
        "tags" : [
        ]
      },
      {
        "id" : "c1186450-9ccb-4a6b-98d4-2be5045393c6",
        "parentId" : "756a8880-7554-4b88-b5ae-a338729f8ac0",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "Thanks @allanrenucci for the helpful feedback, I've addressed them in the latest commit.\r\n\r\nFor `Array`,  we need a special treatment, because JVM carries type information of array elements, it's possible to test the element type at runtime `[1]`:\r\n\r\n```Scala\r\nscala> Array(1, 2, 3).getClass\r\nres2: Class[_ <: Array[Int]] = class [I\r\n// where the string \"[I\" is the run-time type signature for the class \r\n// object \"array with component type int\".\r\n```\r\n\r\n`[1]`: https://docs.oracle.com/javase/specs/jls/se7/html/jls-10.html",
        "createdAt" : "2018-03-23T12:24:47Z",
        "updatedAt" : "2018-04-05T14:26:58Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      }
    ],
    "commit" : "2b00b7a8b352f1adbedfca70946a2170c8148b94",
    "line" : 57,
    "diffHunk" : "@@ -1,1 +55,59 @@   *  2. if `P` is a singleton type, TRUE\n   *  3. if `P` refers to an abstract type member or type parameter, FALSE\n   *  4. if `P = Array[T]`, checkable(E, T) where `E` is the element type of `X`, defaults to `Any`.\n   *  5. if `P` is `pre.F[Ts]` and `pre.F` refers to a class which is not `Array`:\n   *     (a) replace `Ts` with fresh type variables `Xs`"
  },
  {
    "id" : "2a05e7d6-101f-44d5-96ab-def41ab83fd1",
    "prId" : 4045,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/4045#pullrequestreview-106040174",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "aa8bd936-2276-4115-bad3-a583b697643d",
        "parentId" : null,
        "authorId" : "223e67d6-1873-432a-9af9-f40b82a7eedd",
        "body" : "Can you add a test for `&` types. For example:\r\n```scala\r\ntrait Marker\r\ndef foo[T](x: T) = x match {\r\n  case _: T & Marker => // no warning\r\n  // case _: T with Marker => // scalac emits a warning\r\n  case _ =>\r\n}\r\n```\r\nScalac emits a warning but I believe it is erroneous.\r\nUse case:\r\n```scala\r\ndef foo[T](xs: List[T]): List[T] = xs.collect { case x: T with Marker => x }\r\n```",
        "createdAt" : "2018-03-22T10:14:29Z",
        "updatedAt" : "2018-04-05T14:26:58Z",
        "lastEditedBy" : "223e67d6-1873-432a-9af9-f40b82a7eedd",
        "tags" : [
        ]
      }
    ],
    "commit" : "2b00b7a8b352f1adbedfca70946a2170c8148b94",
    "line" : 62,
    "diffHunk" : "@@ -1,1 +60,64 @@   *     (b) constrain `Xs` with `pre.F[Xs] <:< X`\n   *     (c) instantiate Xs and check `pre.F[Xs] <:< P`\n   *  6. if `P = T1 | T2` or `P = T1 & T2`, checkable(X, T1) && checkable(X, T2).\n   *  7. if `P` is a refinement type, FALSE\n   *  8. otherwise, TRUE"
  }
]
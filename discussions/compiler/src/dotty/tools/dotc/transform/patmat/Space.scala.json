[
  {
    "id" : "70df91aa-43de-4729-88d2-cba68adf2c77",
    "prId" : 13030,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/13030#pullrequestreview-703880743",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "84d0252c-d95c-4cb3-ac6d-6e9b77ea6365",
        "parentId" : null,
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "It seems `false` aligns better with the protocol that if a component is `sealed`, then perform the check.",
        "createdAt" : "2021-07-09T16:31:24Z",
        "updatedAt" : "2021-07-09T16:31:25Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "d9a2ae37-28a2-4eb2-8ae1-d520dd5c59f9",
        "parentId" : "84d0252c-d95c-4cb3-ac6d-6e9b77ea6365",
        "authorId" : "5f907c64-1898-4d74-945b-1f630a7406b9",
        "body" : "Given something like `case class Foo(parent: Option[Foo], other: Bar)` this else branch is hit when we've running `isCheckable(Foo)` on the Foo in the Option.  My thinking is we can optimistically return `true` here, and then whether or not `Bar` is checkable will determine if the top `Foo` is checkable.  So I think `true` is right here, no?",
        "createdAt" : "2021-07-09T20:35:42Z",
        "updatedAt" : "2021-07-09T20:35:42Z",
        "lastEditedBy" : "5f907c64-1898-4d74-945b-1f630a7406b9",
        "tags" : [
        ]
      },
      {
        "id" : "27b65287-5992-40fa-a214-29dd4a3eb028",
        "parentId" : "84d0252c-d95c-4cb3-ac6d-6e9b77ea6365",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "Given the following type:\r\n\r\n```Scala\r\ncase class A(a: A)\r\n```\r\nIIRC, the implementation above will have `isCheckable(A) == true`. If that's as expected, then `true` is fine. Otherwise, it seems `false`  should be used here.\r\n",
        "createdAt" : "2021-07-10T19:31:56Z",
        "updatedAt" : "2021-07-10T19:31:56Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "71b0f256-bbcc-4648-9262-ebc4bdcfca00",
        "parentId" : "84d0252c-d95c-4cb3-ac6d-6e9b77ea6365",
        "authorId" : "5f907c64-1898-4d74-945b-1f630a7406b9",
        "body" : "Yeah, I'm happy with that result.",
        "createdAt" : "2021-07-12T09:02:38Z",
        "updatedAt" : "2021-07-12T09:02:38Z",
        "lastEditedBy" : "5f907c64-1898-4d74-945b-1f630a7406b9",
        "tags" : [
        ]
      }
    ],
    "commit" : "9fd4000e550b8ceca20031e68fd46cc9f63ecb87",
    "line" : 17,
    "diffHunk" : "@@ -1,1 +821,825 @@      classSym.is(Case) && {\n        if seen.add(tpw) then productSelectorTypes(tpw, sel.srcPos).exists(isCheckable(_))\n        else true // recursive case class: return true and other members can still fail the check\n      }\n"
  },
  {
    "id" : "4ab338af-622d-4eb2-a3bb-61b050722af0",
    "prId" : 12271,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/12271#pullrequestreview-648358649",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "96cbf87e-d28d-499d-84a7-9090318b1c9f",
        "parentId" : null,
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "I wonder if it would help performance if we do not compute `spaces.filter(_ ne sp)` eagerly.",
        "createdAt" : "2021-04-29T13:18:05Z",
        "updatedAt" : "2021-04-29T13:20:37Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      },
      {
        "id" : "f8bc834f-8b53-4f75-ab55-7833f320ea59",
        "parentId" : "96cbf87e-d28d-499d-84a7-9090318b1c9f",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "Here `spaces` has a size < 10, so should not matter much.",
        "createdAt" : "2021-04-29T15:34:29Z",
        "updatedAt" : "2021-04-29T15:34:30Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      }
    ],
    "commit" : "16a622fd1b953cb544b6d984c3dd59a017bb0238",
    "line" : 64,
    "diffHunk" : "@@ -1,1 +138,142 @@    if (spaces.lengthCompare(1) <= 0 || spaces.lengthCompare(10) >= 0) spaces\n    else {\n      val res = spaces.map(sp => (sp, spaces.filter(_ ne sp))).find {\n        case (sp, sps) => isSubspace(sp, Or(LazyList(sps: _*)))\n      }"
  },
  {
    "id" : "7a4795bd-90a9-41e5-b519-f844b2daa5cd",
    "prId" : 11503,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/11503#pullrequestreview-595854133",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5374dcad-8cef-4ec4-96c4-9147aef0bce4",
        "parentId" : null,
        "authorId" : "4107dafe-4e7b-4e85-8d5b-63e06e0e6318",
        "body" : "Isn't `_*` parsed as a single token? Should it be `_ *` instead? ",
        "createdAt" : "2021-02-22T22:17:40Z",
        "updatedAt" : "2021-02-22T22:19:20Z",
        "lastEditedBy" : "4107dafe-4e7b-4e85-8d5b-63e06e0e6318",
        "tags" : [
        ]
      },
      {
        "id" : "13cf4c1b-1ddd-4693-a15c-49d844bb97cf",
        "parentId" : "5374dcad-8cef-4ec4-96c4-9147aef0bce4",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "From the syntax specification, `_*` will be parsed correctly, and the implementation agrees with the syntax: https://scastie.scala-lang.org/EvlND8SaTMGnJjyhaqdRIA ",
        "createdAt" : "2021-02-22T22:38:36Z",
        "updatedAt" : "2021-02-22T22:38:36Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "5fb5c4cd-a56d-4b2d-bcc7-92b7a8e05552",
        "parentId" : "5374dcad-8cef-4ec4-96c4-9147aef0bce4",
        "authorId" : "4107dafe-4e7b-4e85-8d5b-63e06e0e6318",
        "body" : "This snippet crashes the compiler.",
        "createdAt" : "2021-02-22T22:40:20Z",
        "updatedAt" : "2021-02-22T22:40:21Z",
        "lastEditedBy" : "4107dafe-4e7b-4e85-8d5b-63e06e0e6318",
        "tags" : [
        ]
      },
      {
        "id" : "de670a71-b16f-4314-9aed-5b202e9ccb76",
        "parentId" : "5374dcad-8cef-4ec4-96c4-9147aef0bce4",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "I enabled `-Xprint:typer` in the above, the output is noisy. Here is a clean one: https://scastie.scala-lang.org/KnwXPu1kTQKYp9EGI8qrQw",
        "createdAt" : "2021-02-22T22:44:11Z",
        "updatedAt" : "2021-02-22T22:44:11Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      }
    ],
    "commit" : "9fe17af7a9d125004d249a11770ac0f62053e694",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +764,768 @@        else if (scalaListType.isRef(sym))\n          if (flattenList) \"_*\" else \"_: List\"\n        else if (scalaConsType.isRef(sym))\n          if (flattenList) \"_, _*\"  else \"List(_, _*)\"\n        else if (tp.classSymbol.is(Sealed) && tp.classSymbol.hasAnonymousChild)"
  },
  {
    "id" : "0547780b-77b8-4f6b-ba49-3788f93d3d22",
    "prId" : 10112,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/10112#pullrequestreview-521128092",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a563dcc3-e4ef-4bde-9f63-d7c854032f29",
        "parentId" : null,
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Nice!",
        "createdAt" : "2020-10-31T10:14:38Z",
        "updatedAt" : "2020-10-31T10:14:39Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "04632009fde20cb5ad0c4744073b87760b862223",
    "line" : 18,
    "diffHunk" : "@@ -1,1 +157,161 @@      ss.foldLeft(LazyList(Nil : List[Space])) { (acc, flat) =>\n        for { sps <- acc; s <- flat }\n        yield sps :+ s\n      }.map { sps =>\n        Prod(tp, fun, sps, full)"
  },
  {
    "id" : "2a9dbea5-22ee-48f6-921b-231a90d14743",
    "prId" : 8789,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/8789#pullrequestreview-399950420",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fed02fd6-9576-45fb-815c-18c69636e944",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "I was a bit confused by this description, here's a proposed slightly different version:\r\n```suggestion\r\n  /** True if we can assume that the two unapply methods are the same.\r\n   *  That is, given the same parameter, they return the same result.\r\n   *\r\n   *  We assume that unapply methods are pure, but the same method may\r\n   *  be called with different prefixes, thus behaving differently.\r\n   */\r\n```",
        "createdAt" : "2020-04-24T13:34:15Z",
        "updatedAt" : "2020-04-24T13:34:15Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      }
    ],
    "commit" : "74e46c50759dc4108ab1ee8e1844997d0dc363a8",
    "line" : 10,
    "diffHunk" : "@@ -1,1 +84,88 @@   *\n   *  This is more general than purity, as the same `unapply` method may\n   *  take different prefix, thus behaves differently.\n   */\n  def isSameUnapply(tp1: TermRef, tp2: TermRef): Boolean"
  },
  {
    "id" : "e427156d-5289-4ee0-95ea-26811c9012a2",
    "prId" : 8698,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/8698#pullrequestreview-392614005",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d8eec7f2-928f-4374-a803-c80a7cbba0ed",
        "parentId" : null,
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "Forgot to remove this",
        "createdAt" : "2020-04-14T05:33:08Z",
        "updatedAt" : "2020-04-14T05:45:06Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      }
    ],
    "commit" : "41f4cbbda1f3e27c0b168ba62b2d55eed4a56d23",
    "line" : 255,
    "diffHunk" : "@@ -1,1 +507,511 @@    def caseClass = unappSym.owner.linkedClass\n\n    // println(\"scrutineeTp = \" + scrutineeTp.show)\n\n    lazy val caseAccessors = caseClass.caseAccessors.filter(_.is(Method))"
  },
  {
    "id" : "4225c3db-6954-421c-8415-5826b6e7badb",
    "prId" : 7546,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/7546#pullrequestreview-324418945",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "94f49322-5e43-4453-a19b-01eb969c3d49",
        "parentId" : null,
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "It would be good if Fengyun could review this part.",
        "createdAt" : "2019-11-14T18:34:19Z",
        "updatedAt" : "2019-12-13T22:40:38Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "0f711504-2651-43e4-932f-3e2b86103e9c",
        "parentId" : "94f49322-5e43-4453-a19b-01eb969c3d49",
        "authorId" : "aa14f673-3d29-4a61-bf43-a86828212cf2",
        "body" : "Fengyun ok'ed the `Space` changes.",
        "createdAt" : "2019-11-28T17:56:33Z",
        "updatedAt" : "2019-12-13T22:40:38Z",
        "lastEditedBy" : "aa14f673-3d29-4a61-bf43-a86828212cf2",
        "tags" : [
        ]
      }
    ],
    "commit" : "85c08556cefabc64ca96079b5b891a1761f69c82",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +23,27 @@import config.Printers.{exhaustivity => debug}\nimport util.SourcePosition\nimport NullOpsDecorator._\n\n/** Space logic for checking exhaustivity and unreachability of pattern matching"
  },
  {
    "id" : "4f3ae8cf-a237-4952-93a2-ab1df4403038",
    "prId" : 5996,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/5996#pullrequestreview-211240232",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4f4be9bc-c785-49bc-935f-b3e3407d1930",
        "parentId" : null,
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "It seems that a nested non-inhabitable intersection type does not necessarily mean the outer type is non-inhabited, just as `Nothing` does not imply `F[Nothing]` is non-inhabited..",
        "createdAt" : "2019-03-06T10:52:45Z",
        "updatedAt" : "2019-03-06T14:04:39Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "a3ab95aa-3ff1-48f2-8c04-d6c00011723b",
        "parentId" : "4f4be9bc-c785-49bc-935f-b3e3407d1930",
        "authorId" : "6d71bb21-e402-4464-b2b1-8bdd8e068461",
        "body" : "Good point, I've updated that check to be more conservative while traversing `refined`.",
        "createdAt" : "2019-03-06T13:52:36Z",
        "updatedAt" : "2019-03-06T14:04:39Z",
        "lastEditedBy" : "6d71bb21-e402-4464-b2b1-8bdd8e068461",
        "tags" : [
        ]
      }
    ],
    "commit" : "ea04343f99a912cd94e2afd3106cd0c85e2c6cc1",
    "line" : 41,
    "diffHunk" : "@@ -1,1 +480,484 @@\n          if (inhabited(refined)) refined\n          else NoType\n        } filter(_.exists)\n"
  },
  {
    "id" : "4cd4a828-ee31-4870-b970-57be12c940f6",
    "prId" : 4299,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/4299#pullrequestreview-112032031",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "cf57ae21-29d6-46ef-bcf5-455a25c2cf7b",
        "parentId" : null,
        "authorId" : "223e67d6-1873-432a-9af9-f40b82a7eedd",
        "body" : "While you're at it, maybe replace this by `tp.symbol.isTypeParam`",
        "createdAt" : "2018-04-13T14:04:48Z",
        "updatedAt" : "2018-04-13T14:04:49Z",
        "lastEditedBy" : "223e67d6-1873-432a-9af9-f40b82a7eedd",
        "tags" : [
        ]
      },
      {
        "id" : "83e56736-d371-4668-a146-36c7e01ee2db",
        "parentId" : "cf57ae21-29d6-46ef-bcf5-455a25c2cf7b",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "@allanrenucci : `tp.symbol.isTypeParam` will miss the case where the reference is a type member.",
        "createdAt" : "2018-04-13T14:26:48Z",
        "updatedAt" : "2018-04-13T14:26:49Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      }
    ],
    "commit" : "e5b18ebb804453941ce3f8816d3f04a8b880fa7e",
    "line" : 18,
    "diffHunk" : "@@ -1,1 +611,615 @@\n      def apply(tp: Type): Type = tp match {\n        case tp: TypeRef if tp.underlying.isInstanceOf[TypeBounds] =>\n          val lo = this(tp.info.loBound)\n          val hi = this(tp.info.hiBound)"
  },
  {
    "id" : "ee4abfa4-fc44-442f-a97b-4f114ac2840a",
    "prId" : 4056,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/4056#pullrequestreview-100523037",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "04d9a836-0a83-4e18-aa16-d541f9a30a5b",
        "parentId" : null,
        "authorId" : "348fab8e-49e2-442e-884d-850c7f41fdde",
        "body" : "To be sure: basically this throws away `_$1` and `_$2`, which is fine now but might be less fine if we had type arguments for extractor patterns (which at least I'd like eventually?)",
        "createdAt" : "2018-03-01T15:51:41Z",
        "updatedAt" : "2018-03-01T15:51:41Z",
        "lastEditedBy" : "348fab8e-49e2-442e-884d-850c7f41fdde",
        "tags" : [
        ]
      },
      {
        "id" : "6e2e6f37-6dde-4566-9e85-fd960cbc91a2",
        "parentId" : "04d9a836-0a83-4e18-aa16-d541f9a30a5b",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "If we check according to semantics, I think it's correct. I cannot come up with a counter-example. If some type cannot be checked at run-time, they get a warning instead.",
        "createdAt" : "2018-03-01T15:56:39Z",
        "updatedAt" : "2018-03-01T15:56:39Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "9300f39a-3563-4ea2-895e-17f098889e3a",
        "parentId" : "04d9a836-0a83-4e18-aa16-d541f9a30a5b",
        "authorId" : "348fab8e-49e2-442e-884d-850c7f41fdde",
        "body" : "Yes; since type arguments to classes/traits are erased at runtime, the only use case is for annotating what GADT inference should deduce or for binding type variables generated by GADT inference. For instance:\r\n\r\n```scala\r\ntrait Exp[T]\r\ncase class[A, B])[f: Exp[A => B])\r\ndef eval[T](e: Exp[T])(env: Env): T = e match {\r\n    case Fun[a, b](x, body) =>\r\n      (v: a) => body.eval(env + (x -> v))\r\n}\r\n```",
        "createdAt" : "2018-03-01T16:03:49Z",
        "updatedAt" : "2018-03-01T16:03:49Z",
        "lastEditedBy" : "348fab8e-49e2-442e-884d-850c7f41fdde",
        "tags" : [
        ]
      },
      {
        "id" : "5efef60c-b342-413d-bacf-e24dd42defe5",
        "parentId" : "04d9a836-0a83-4e18-aa16-d541f9a30a5b",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "It seems the example doesn't compile at all, despite any repairing efforts.",
        "createdAt" : "2018-03-01T16:14:35Z",
        "updatedAt" : "2018-03-01T16:14:35Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "8eea6a34-3850-458b-9f68-b6986cf05a1c",
        "parentId" : "04d9a836-0a83-4e18-aa16-d541f9a30a5b",
        "authorId" : "348fab8e-49e2-442e-884d-850c7f41fdde",
        "body" : "I mentioned upfront the issue is with a potential future feature, so of course my example doesn't work yet:\r\n\r\n>  if we *had* type arguments for extractor patterns (which at least I'd like eventually?)",
        "createdAt" : "2018-03-01T17:34:19Z",
        "updatedAt" : "2018-03-01T17:34:19Z",
        "lastEditedBy" : "348fab8e-49e2-442e-884d-850c7f41fdde",
        "tags" : [
        ]
      }
    ],
    "commit" : "21e572155140f5e1f0de1e1b19f4a62959ddad6b",
    "line" : 38,
    "diffHunk" : "@@ -1,1 +328,332 @@          Prod(erase(pat.tpe.stripAnnots), fun.tpe, fun.symbol, projectSeq(pats) :: Nil, irrefutable(fun))\n      else\n        Prod(erase(pat.tpe.stripAnnots), fun.tpe, fun.symbol, pats.map(project), irrefutable(fun))\n    case Typed(pat @ UnApply(_, _, _), _) => project(pat)\n    case Typed(expr, tpt) =>"
  },
  {
    "id" : "49c655f8-538e-48b4-9535-64ce08a3fc61",
    "prId" : 3891,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/3891#pullrequestreview-91960808",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "68f17d2b-f91e-4561-aeb2-0b28b58b2e79",
        "parentId" : null,
        "authorId" : "6d71bb21-e402-4464-b2b1-8bdd8e068461",
        "body" : "Maybe you could iterate over `cases.inits` instead?",
        "createdAt" : "2018-01-26T16:59:06Z",
        "updatedAt" : "2018-01-27T07:21:45Z",
        "lastEditedBy" : "6d71bb21-e402-4464-b2b1-8bdd8e068461",
        "tags" : [
        ]
      },
      {
        "id" : "fcc99b0c-9b95-46b7-b4b3-7b568024f7af",
        "parentId" : "68f17d2b-f91e-4561-aeb2-0b28b58b2e79",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "Thanks, I didn't know `inits` before, I'll consider use it later. In the current case, I do need `i` to get the current clause, `init` doesn't help much here.",
        "createdAt" : "2018-01-26T20:31:16Z",
        "updatedAt" : "2018-01-27T07:21:45Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      }
    ],
    "commit" : "26f384b085eace23810fa239954f46cb47183f47",
    "line" : 234,
    "diffHunk" : "@@ -1,1 +906,910 @@    val selTyp = sel.tpe.widen.dealias\n\n    (0 until cases.length).foreach { i =>\n      // in redundancy check, take guard as false in order to soundly approximate\n      val prevs ="
  },
  {
    "id" : "486f2fb6-72b3-4bd5-9a0c-4dfe59d5e2cf",
    "prId" : 3202,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/3202#pullrequestreview-66025814",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e7d35829-2fc0-4834-9594-69f16ae1307d",
        "parentId" : null,
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "Nice refactoring!",
        "createdAt" : "2017-09-28T23:23:26Z",
        "updatedAt" : "2017-09-29T06:43:24Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      }
    ],
    "commit" : "acdf2e8f3cd97a02e8b30941dadfea9cb1f59f14",
    "line" : 10,
    "diffHunk" : "@@ -1,1 +515,519 @@  /** Decompose a type into subspaces -- assume the type can be decomposed */\n  def decompose(tp: Type): List[Space] = {\n    val children = tp.classSymbol.children\n\n    debug.println(s\"candidates for ${tp.show} : [${children.map(_.show).mkString(\", \")}]\")"
  },
  {
    "id" : "0b304f75-c582-4c25-855d-4a13ad9bba05",
    "prId" : 3156,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/3156#pullrequestreview-65605809",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d108c954-ec20-44b2-82d6-44a779493632",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Instead of passing an implicit around, you could have an outer function which defines `warn` and an inner recursive function which uses it.",
        "createdAt" : "2017-09-27T13:50:52Z",
        "updatedAt" : "2017-09-27T20:16:22Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "3bdb937f-dbed-4f85-9706-5f1de7a81c1f",
        "parentId" : "d108c954-ec20-44b2-82d6-44a779493632",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "@smarter thanks a lot, I've addressed other comments.  For this one, doing the refactoring would require to pass an additional `Position` to `erase`, which will make the API a little ugly.",
        "createdAt" : "2017-09-27T16:27:49Z",
        "updatedAt" : "2017-09-27T20:16:22Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      }
    ],
    "commit" : "608a17c8bb76fc85c281e5f69b436dd973bf02a3",
    "line" : 25,
    "diffHunk" : "@@ -1,1 +414,418 @@\n  /* Erase a type binding according to erasure semantics in pattern matching */\n  def erase(tp: Type)(implicit warn: String => Unit): Type = tp match {\n    case tp @ AppliedType(tycon, args) =>\n      if (tycon.isRef(defn.ArrayClass)) tp.derivedAppliedType(tycon, args.map(erase))"
  },
  {
    "id" : "227b25d5-46c6-4946-88e2-32d267357d54",
    "prId" : 2424,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/2424#pullrequestreview-38112991",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8075a613-fe07-4614-8034-e03526da0a35",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "I suggest adding a `Printer` for the exhaustiveness checker in https://github.com/lampepfl/dotty/blob/master/compiler/src/dotty/tools/dotc/config/Printers.scala instead of using `debug` here.",
        "createdAt" : "2017-05-15T13:11:24Z",
        "updatedAt" : "2017-05-15T15:31:49Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "12ee26bc-3d89-4acb-bfcd-75cb0c84aa61",
        "parentId" : "8075a613-fe07-4614-8034-e03526da0a35",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "The `debug` is just a rename of the exhaustivity printer :)",
        "createdAt" : "2017-05-15T13:22:22Z",
        "updatedAt" : "2017-05-15T15:31:49Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      }
    ],
    "commit" : "1e695eafa2b1830ae52e49691ce7ba1cc19e8741",
    "line" : 386,
    "diffHunk" : "@@ -1,1 +796,800 @@      val curr = project(cases(i).pat)\n\n      debug.println(s\"---------------reachable? ${show(curr)}\")\n      debug.println(s\"prev: ${show(prevs)}\")\n"
  }
]
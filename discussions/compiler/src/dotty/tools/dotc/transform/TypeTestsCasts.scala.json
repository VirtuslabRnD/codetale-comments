[
  {
    "id" : "78276cfb-e198-4e92-b464-328b325b6736",
    "prId" : 11768,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/11768#pullrequestreview-614623650",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0af79dde-e37d-45af-bf6f-0cb4a0db2017",
        "parentId" : null,
        "authorId" : "3a56b927-736f-4aab-8690-358cd24ca570",
        "body" : "I think I understand the intent here, but it's a bit surprising that we don't widen the params, given that doing so is necessary for soundness. What would be a motivating example for _not_ widening them here?",
        "createdAt" : "2021-03-17T11:24:42Z",
        "updatedAt" : "2021-03-17T17:50:53Z",
        "lastEditedBy" : "3a56b927-736f-4aab-8690-358cd24ca570",
        "tags" : [
        ]
      },
      {
        "id" : "3e11afdc-20c7-4a28-967f-64983c60c671",
        "parentId" : "0af79dde-e37d-45af-bf6f-0cb4a0db2017",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "The motivation for not widening is something specific to the algorithm: here for `P1 = pre.F[Xs]`, all `Xs` are type variables. We want the `Xs` to be constrained.",
        "createdAt" : "2021-03-17T11:29:46Z",
        "updatedAt" : "2021-03-17T17:50:53Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "4d34b94a-f600-421d-aa5f-29ae569f5ef3",
        "parentId" : "0af79dde-e37d-45af-bf6f-0cb4a0db2017",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "I feel very happy the work on the GADT makes the checking so elegant that we remove a lot of ad-hoc tweaks. The fact that the algorithm is simpler and it found more bugs in the compiler gives more confidence.",
        "createdAt" : "2021-03-17T11:31:16Z",
        "updatedAt" : "2021-03-17T17:50:53Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "76e3c2d0-6815-4d24-921e-5ff8296f761d",
        "parentId" : "0af79dde-e37d-45af-bf6f-0cb4a0db2017",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "One example is the following:\r\n\r\n```Scala\r\n  // tests/neg-custom-args/isInstanceOf/JavaSeqLiteral.scala\r\n  trait Tree[-T]\r\n\r\n  class JavaSeqLiteral[-T] extends Tree[T]\r\n\r\n  trait Type\r\n\r\n  class DummyTree extends JavaSeqLiteral[Any]\r\n\r\n  def foo1(tree: Tree[Type]) =\r\n    tree.isInstanceOf[JavaSeqLiteral[Type]]\r\n```\r\n\r\nIn checking whether the test `tree.isInstanceOf[JavaSeqLiteral[Type]]` is realizable, we want to constrain `JavaSeqLiteral[X] <: Tree[Type]`, such that we can infer `X = Type` and `JavaSeqLiteral[X] <:< JavaSeqLiteral[Type]`.\r\n\r\nIf we perform widening, we will get `X = Nothing`, and we don't have `JavaSeqLiteral[X] <:< JavaSeqLiteral[Type]` any more.",
        "createdAt" : "2021-03-17T11:43:12Z",
        "updatedAt" : "2021-03-17T17:50:53Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "b8959d17-54e2-4111-a2ea-4a413a7ccf68",
        "parentId" : "0af79dde-e37d-45af-bf6f-0cb4a0db2017",
        "authorId" : "3a56b927-736f-4aab-8690-358cd24ca570",
        "body" : "Ok, I think what we're doing here is sound, but with small changes we could easily make it unsound. I'll need to add a comment explaining what's going on, and then we can merge the PR.",
        "createdAt" : "2021-03-17T16:56:24Z",
        "updatedAt" : "2021-03-17T17:50:53Z",
        "lastEditedBy" : "3a56b927-736f-4aab-8690-358cd24ca570",
        "tags" : [
        ]
      },
      {
        "id" : "8a5688d4-9c84-450b-8db6-68252bced932",
        "parentId" : "0af79dde-e37d-45af-bf6f-0cb4a0db2017",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "Yes, I'll add a comment explaining the code.",
        "createdAt" : "2021-03-17T17:40:26Z",
        "updatedAt" : "2021-03-17T17:50:53Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "047c492f-749c-4f53-902b-d1aa7346602b",
        "parentId" : "0af79dde-e37d-45af-bf6f-0cb4a0db2017",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "Comment added in aa296ba",
        "createdAt" : "2021-03-17T17:51:37Z",
        "updatedAt" : "2021-03-17T17:51:37Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      }
    ],
    "commit" : "aa296ba3da6da3ea646e1d300831a0b384d4d6d8",
    "line" : 70,
    "diffHunk" : "@@ -1,1 +99,103 @@        // Ident[X] <:< Ident[Int] any more.\n        TypeComparer.constrainPatternType(P1, X, widenParams = false)\n        debug.println(TypeComparer.explained(_.constrainPatternType(P1, X, widenParams = false)))\n      }\n"
  },
  {
    "id" : "a7a44cd1-6831-4e61-be1a-f0dca975a894",
    "prId" : 9980,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/9980#pullrequestreview-517452976",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ad74c44e-50c6-4f6e-9054-c6d46cd27689",
        "parentId" : null,
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "This line seems to change semantics of the original code:\r\n```suggestion\r\n                  && ((testCls.is(Final) || !testCls.is(Trait) && !foundCls.is(Trait)))\r\n```",
        "createdAt" : "2020-10-12T06:55:58Z",
        "updatedAt" : "2020-10-12T06:56:38Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "39dadf36-5116-431e-8c1e-eb29c021fcf4",
        "parentId" : "ad74c44e-50c6-4f6e-9054-c6d46cd27689",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "I don't think so. All the suggestion does is double the pair of outer parens\r\n",
        "createdAt" : "2020-10-27T08:34:27Z",
        "updatedAt" : "2020-10-27T08:34:28Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "22ee015f0e2b7908ccc79e3c2d5b0f04d1114ff0",
    "line" : 30,
    "diffHunk" : "@@ -1,1 +234,238 @@                  !testCls.derivesFrom(foundCls)\n                  && !unboxedTestCls.derivesFrom(foundCls)\n                  && (testCls.is(Final) || !testCls.is(Trait) && !foundCls.is(Trait))\n                if (foundCls.is(Final))\n                  unreachable(i\"$exprType is not a subclass of $testCls\")"
  },
  {
    "id" : "d921fe23-2c2f-4152-bdbc-319276507794",
    "prId" : 8808,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/8808#pullrequestreview-402007444",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b94d33d8-627c-47eb-b0c0-e0111c5d3e63",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "I don't undestand what is going on here, the documentation above still says \"constrain `Xs` with `pre.F[Xs] <:< X`\", but this is not true in general since no constraint will be added if `P1` is not a subtype of `X`. The documentation need to explain why this is safe.",
        "createdAt" : "2020-04-28T16:03:39Z",
        "updatedAt" : "2020-04-29T12:04:28Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "8dce88e8-c343-49fa-ba27-230402d7da69",
        "parentId" : "b94d33d8-627c-47eb-b0c0-e0111c5d3e63",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "That is expected if `P1` is not a subtype of `X`. It just tries to infer type parameters of `P1` from `X` if the value `x` indeed has the type  skeleton `pre.F[_]`. Then it goes on to check if `P1 <: P`, which means the type arguments in `P` are trivial, thus no runtime checks are needed for them. Therefore, no warnings in such cases.\r\n\r\nI'll refine the doc.",
        "createdAt" : "2020-04-28T16:26:22Z",
        "updatedAt" : "2020-04-29T12:04:28Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      }
    ],
    "commit" : "841d19176f3fdc7da45e800634e9f3f6971c9add",
    "line" : 29,
    "diffHunk" : "@@ -1,1 +112,116 @@      // if P1 <: P, which means the type arguments in P are trivial,\n      // thus no runtime checks are needed for them.\n      P1 <:< X\n\n      // Maximization of the type means we try to cover all possible values"
  },
  {
    "id" : "0972ac50-fdd1-4112-a0c4-eb60087b6472",
    "prId" : 8808,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/8808#pullrequestreview-402037706",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1a86ad3b-84fd-452a-a5fb-66645518acac",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Similarly, why is it correct to use `maximizeType` here ?",
        "createdAt" : "2020-04-28T16:04:05Z",
        "updatedAt" : "2020-04-29T12:04:28Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "542125a1-01ee-4969-ae28-3a5245781d6e",
        "parentId" : "1a86ad3b-84fd-452a-a5fb-66645518acac",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "Maximization of the type means we try to cover all possible values which conform to the skeleton `pre.F[_]` and `X`. Then we have to make sure all of them are actually of the type `P`,  which implies that the type arguments in `P` are trivial (no runtime check needed).",
        "createdAt" : "2020-04-28T17:02:58Z",
        "updatedAt" : "2020-04-29T12:04:28Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      }
    ],
    "commit" : "841d19176f3fdc7da45e800634e9f3f6971c9add",
    "line" : 37,
    "diffHunk" : "@@ -1,1 +118,122 @@      // sure all of them are actually of the type P, which implies that the\n      // type arguments in P are trivial (no runtime check needed).\n      maximizeType(P1, span, fromScala2x = false)\n\n      val res = P1 <:< P"
  },
  {
    "id" : "a685fb8a-b855-4492-b766-8538ce726ed6",
    "prId" : 8808,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/8808#pullrequestreview-402550754",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2a6dedc8-0e9b-4e58-8d1c-8ab2f26640c1",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "This comment should be moved one line below since it's about the first call to isClassDetermined. Also it'd be nice to add a comment here about the use of `!mayHaveCommonChild` explaining that unreachability is checked elsewhere.",
        "createdAt" : "2020-04-29T10:42:36Z",
        "updatedAt" : "2020-04-29T12:04:28Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      }
    ],
    "commit" : "841d19176f3fdc7da45e800634e9f3f6971c9add",
    "line" : 61,
    "diffHunk" : "@@ -1,1 +149,153 @@            X.classSymbol.exists && P.classSymbol.exists &&\n              !X.classSymbol.asClass.mayHaveCommonChild(P.classSymbol.asClass) ||\n            // first try without striping type parameters for performance\n            typeArgsTrivial(X, tpe) ||\n            typeArgsTrivial(stripTypeParam(X), tpe)"
  },
  {
    "id" : "8fd80951-e057-4974-b7de-53b2c40b7d5c",
    "prId" : 5874,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/5874#pullrequestreview-201511280",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5dcf2254-5546-4a69-bf25-1874b0bd4566",
        "parentId" : null,
        "authorId" : "6d71bb21-e402-4464-b2b1-8bdd8e068461",
        "body" : "For completeness I would add a test where x is a side effect",
        "createdAt" : "2019-02-08T09:44:58Z",
        "updatedAt" : "2019-02-08T10:22:28Z",
        "lastEditedBy" : "6d71bb21-e402-4464-b2b1-8bdd8e068461",
        "tags" : [
        ]
      },
      {
        "id" : "fce73142-b755-4d10-b73e-231467727be6",
        "parentId" : "5dcf2254-5546-4a69-bf25-1874b0bd4566",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "Added",
        "createdAt" : "2019-02-08T10:22:34Z",
        "updatedAt" : "2019-02-08T10:22:34Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      }
    ],
    "commit" : "2b7439406678428b04106190e0d883d0f46b934e",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +247,251 @@          else if (testCls eq defn.NothingClass) {\n            // In the JVM `x.asInstanceOf[Nothing]` would throw a class cast exception except when `x eq null`.\n            // To avoid this loophole we execute `x` and then regardless of the result throw a `ClassCastException`\n            val throwCCE = Throw(New(defn.ClassCastExceptionClass.typeRef, defn.ClassCastExceptionClass_stringConstructor,\n                Literal(Constant(\"Cannot cast to scala.Nothing\")) :: Nil))"
  },
  {
    "id" : "9722c178-1f6c-4908-ab54-425232ed795f",
    "prId" : 5858,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/5858#pullrequestreview-200846221",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2e94f07c-f289-4308-8a95-36912589a751",
        "parentId" : null,
        "authorId" : "348fab8e-49e2-442e-884d-850c7f41fdde",
        "body" : "I'm familiar with `TypeComparer#either` but I'm not sure I get what you are saying...\r\n```\r\nThis case is required to match type inference, which simplifies constraints in the following two cases:\r\n```\r\n\r\nBut if that's the reason, what about `T1 & T2 <:< T3`? Do we need to handle that somehow?",
        "createdAt" : "2019-02-06T17:46:22Z",
        "updatedAt" : "2019-02-06T22:58:52Z",
        "lastEditedBy" : "348fab8e-49e2-442e-884d-850c7f41fdde",
        "tags" : [
        ]
      },
      {
        "id" : "e4aaca0e-d519-446b-b6c3-d8220c3f91f4",
        "parentId" : "2e94f07c-f289-4308-8a95-36912589a751",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "`T1 & T2 <:< T3` is handled in the top-level match on `P`",
        "createdAt" : "2019-02-06T22:48:05Z",
        "updatedAt" : "2019-02-06T22:58:52Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      }
    ],
    "commit" : "fe21298f1f2c640c93b17cfeea905f592804c463",
    "line" : 32,
    "diffHunk" : "@@ -1,1 +126,130 @@          case OrType(tp1, tp2) =>\n            // This case is required to retrofit type inference,\n            // which cut constraints in the following two cases:\n            //   - T1 <:< T2 | T3\n            //   - T1 & T2 <:< T3"
  },
  {
    "id" : "0b11d9ce-bb6c-4239-a86c-12feea9d179a",
    "prId" : 2820,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/2820#pullrequestreview-47824908",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b5a2a4c4-4bf2-4f42-ba25-307007553266",
        "parentId" : null,
        "authorId" : "2dc29bea-17b2-4800-bf4f-843c62cca7de",
        "body" : "Forgotten removal - or leave in as a nice point for debug?",
        "createdAt" : "2017-07-04T10:03:48Z",
        "updatedAt" : "2017-07-04T10:06:29Z",
        "lastEditedBy" : "2dc29bea-17b2-4800-bf4f-843c62cca7de",
        "tags" : [
        ]
      }
    ],
    "commit" : "c9e36fb3c12d722038d6d0054b8600a82ab35674",
    "line" : 69,
    "diffHunk" : "@@ -1,1 +37,41 @@\n        def foundCls = expr.tpe.widen.classSymbol\n        // println(i\"ta $tree, found = $foundCls\")\n\n        def inMatch ="
  }
]
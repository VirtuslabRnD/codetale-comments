[
  {
    "id" : "8b9e9dcc-2ae9-49dc-b866-d2eb07aae581",
    "prId" : 8543,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/8543#pullrequestreview-377567386",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "43f51b63-d272-412a-82af-57359c6f9a0e",
        "parentId" : null,
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "In the current implementation, would it type check if we call this method in source? ",
        "createdAt" : "2020-03-17T18:54:44Z",
        "updatedAt" : "2020-03-19T09:37:36Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      },
      {
        "id" : "7c211b36-18f2-4948-8275-a3d161a7c08a",
        "parentId" : "43f51b63-d272-412a-82af-57359c6f9a0e",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "You can't call it in source. `f$retainedBody` is a semantic name. So if you tried to call it writing `f$retainedBody` literally, you'd get a member not found.",
        "createdAt" : "2020-03-19T09:53:29Z",
        "updatedAt" : "2020-03-19T09:54:36Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "453319bb133c74f49dfa2ec5752f0ac783a5dcb6",
    "line" : 78,
    "diffHunk" : "@@ -1,1 +897,901 @@     *\n     *     inline override def f(x: T) = body1\n     *     private def f$retainedBody(x: T) = body2\n     *\n     *  return the runtime version of `f` as"
  },
  {
    "id" : "6e70e65b-7539-402f-9359-2837005cac00",
    "prId" : 8519,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/8519#pullrequestreview-373335522",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5ccbfa74-ecbb-4313-8eb0-3c6eab8a99c0",
        "parentId" : null,
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Amazing that this worked before. Or was `typer` set by other means?",
        "createdAt" : "2020-03-12T07:49:26Z",
        "updatedAt" : "2020-03-12T07:49:26Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "d3c252d8afca1ebca55f730d01bcbc407e0a8a05",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +102,106 @@  def run(implicit ctx: Context): Unit = {\n    val unit = ctx.compilationUnit\n    unit.tpdTree = eraser.typedExpr(unit.tpdTree)(ctx.fresh.setTyper(eraser).setPhase(this.next))\n  }\n"
  },
  {
    "id" : "92d91721-8b44-4834-9644-3bb077c154ec",
    "prId" : 6424,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/6424#pullrequestreview-233372068",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d8c9b518-506d-4634-8d60-17651e5c0f2e",
        "parentId" : null,
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "In `RefChecks.scala`, there is commented code:\r\n\r\n```Scala\r\n    /*  (Not enabled yet)\r\n       *  See an explanation of compileTimeOnly in its scaladoc at scala.annotation.compileTimeOnly.\r\n       *\r\n      if (sym.isCompileTimeOnly) {\r\n        def defaultMsg =\r\n          sm\"\"\"Reference to ${sym.fullLocationString} should not have survived past type checking,\r\n              |it should have been processed and eliminated during expansion of an enclosing macro.\"\"\"\r\n        // The getOrElse part should never happen, it's just here as a backstop.\r\n        ctx.error(sym.compileTimeOnlyMessage getOrElse defaultMsg, pos)\r\n      }*/\r\n```\r\n\r\nMaybe we should just revive the code?",
        "createdAt" : "2019-05-02T16:28:23Z",
        "updatedAt" : "2019-05-03T14:41:39Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "72917468-4bd1-47a6-85dc-9a3073c7e035",
        "parentId" : "d8c9b518-506d-4634-8d60-17651e5c0f2e",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "No, it would not take into account if it is into an erased context or not. Which is already performed in the place where I check it.",
        "createdAt" : "2019-05-02T17:36:22Z",
        "updatedAt" : "2019-05-03T14:41:39Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      },
      {
        "id" : "64e569bc-01fe-4582-b3d3-1d57366e20f6",
        "parentId" : "d8c9b518-506d-4634-8d60-17651e5c0f2e",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "As in https://github.com/lampepfl/dotty/pull/6424/files#diff-a12cb93e6ac05566103dd86ede6e5901R12, where the reference of the `@compileTimeOnly` is inside an `erased def`",
        "createdAt" : "2019-05-03T08:47:17Z",
        "updatedAt" : "2019-05-03T14:41:39Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      }
    ],
    "commit" : "41f79c71bbfbe32b2812b8097e8a86712cac0e46",
    "line" : 18,
    "diffHunk" : "@@ -1,1 +339,343 @@          case _ => // OK\n        }\n      }\n      tree\n    }"
  },
  {
    "id" : "f1d99648-db6b-48dd-b79c-a8ae64f788d0",
    "prId" : 6221,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/6221#pullrequestreview-222249488",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "dcf82c08-3801-4824-a042-cf171670e7b9",
        "parentId" : null,
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "The problematic `Typed.tpt` is inserted in [TypeTestsCasts.scala#L236](https://github.com/lampepfl/dotty/blob/master/compiler/src/dotty/tools/dotc/transform/TypeTestsCasts.scala#L236), this case could also be handled there.",
        "createdAt" : "2019-04-03T14:32:44Z",
        "updatedAt" : "2019-04-03T15:18:32Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      }
    ],
    "commit" : "e505c88b3bd65a00b0143958e1f2775cfc94fa1c",
    "line" : 10,
    "diffHunk" : "@@ -1,1 +362,366 @@        case Block(_, tpt) => tpt // erase type aliases (statements) from type block\n        case tpt => tpt\n      }\n      val tpt2 = promote(tpt1)\n      val expr1 = typed(expr, tpt2.tpe)"
  },
  {
    "id" : "93388882-8015-407c-9e49-7ef55670721b",
    "prId" : 5957,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/5957#pullrequestreview-206466212",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6655fc7c-724d-41a0-9ef0-93f3bdb1da4f",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Move to TreeInfo.scala ?",
        "createdAt" : "2019-02-21T16:11:48Z",
        "updatedAt" : "2019-02-23T13:42:32Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "491d4788-271a-483d-9978-de89fc731112",
        "parentId" : "6655fc7c-724d-41a0-9ef0-93f3bdb1da4f",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Since it seems to be used only in erasure, I'd leave it there.",
        "createdAt" : "2019-02-21T18:24:07Z",
        "updatedAt" : "2019-02-23T13:42:32Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "d4306dd3ca6c963497b31c342695cfb5d9138557",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +320,324 @@    import Boxing._\n\n    def isErased(tree: Tree)(implicit ctx: Context): Boolean = tree match {\n      case TypeApply(Select(qual, _), _) if tree.symbol == defn.Any_typeCast =>\n        isErased(qual)"
  },
  {
    "id" : "cf1b6435-ba02-4ca3-8faf-30a034e87c16",
    "prId" : 4772,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/4772#pullrequestreview-135199124",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5d503a2f-102c-4346-b931-15b5cc82bac1",
        "parentId" : null,
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "Can we change the type of `myErasurePhase` in `Context` to `DenotTransformer`, so that we don't need to pass the duplicate information around and keep the design consistent?",
        "createdAt" : "2018-07-06T22:47:52Z",
        "updatedAt" : "2018-07-07T09:46:09Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "bad08bde-aab8-48f8-9ff6-6d9a14e909a0",
        "parentId" : "5d503a2f-102c-4346-b931-15b5cc82bac1",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Hmm. But then we have to cast myErasurePhase there, as `phaseOf` gives a phase, not a DenotTransformer. ",
        "createdAt" : "2018-07-07T09:27:45Z",
        "updatedAt" : "2018-07-07T09:46:09Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "ca23f258ff89fd8d7688cc0d6a16a7c618f47845",
    "line" : 15,
    "diffHunk" : "@@ -1,1 +316,320 @@\n  class Typer(erasurePhase: DenotTransformer) extends typer.ReTyper with NoChecking {\n    import Boxing._\n\n    def erasedType(tree: untpd.Tree)(implicit ctx: Context): Type = {"
  },
  {
    "id" : "9c285d45-cf83-41eb-8c06-f52dec5e4dd0",
    "prId" : 4080,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/4080#pullrequestreview-102084330",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "98bef78f-769f-467a-9abb-1ebe24e3d42c",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Why did this change?",
        "createdAt" : "2018-03-07T17:27:10Z",
        "updatedAt" : "2018-03-07T20:37:43Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "7d15876e-c475-49d0-b58a-06eebf9fa663",
        "parentId" : "98bef78f-769f-467a-9abb-1ebe24e3d42c",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Not sure why. Some transform ran at phase erasure and used the erasure typer to do it. Seems legit. Not sure why it did not run before.",
        "createdAt" : "2018-03-07T20:25:58Z",
        "updatedAt" : "2018-03-07T20:37:43Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "855e0e906ecca91c7c54d1af9805350f5437b94d",
    "line" : 8,
    "diffHunk" : "@@ -1,1 +678,682 @@    override def adapt(tree: Tree, pt: Type, locked: TypeVars)(implicit ctx: Context): Tree =\n      trace(i\"adapting ${tree.showSummary}: ${tree.tpe} to $pt\", show = true) {\n        assert(ctx.phase == ctx.erasurePhase || ctx.phase == ctx.erasurePhase.next, ctx.phase)\n        if (tree.isEmpty) tree\n        else if (ctx.mode is Mode.Pattern) tree // TODO: replace with assertion once pattern matcher is active"
  },
  {
    "id" : "14bfc395-de11-4cc3-861f-a5dc9377453d",
    "prId" : 3342,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/3342#pullrequestreview-90339104",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e6d9d797-d6db-4824-9b4a-46d904d4b11a",
        "parentId" : null,
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "You don't need the `assert` as zipWithConserve will fail anyway if the assert is false.",
        "createdAt" : "2017-12-07T17:51:40Z",
        "updatedAt" : "2018-02-21T10:25:44Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "5fc9c835-198e-4734-9ecf-6e1845d6bb90",
        "parentId" : "e6d9d797-d6db-4824-9b4a-46d904d4b11a",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "So the previous logic looks fine to me.",
        "createdAt" : "2017-12-07T17:52:01Z",
        "updatedAt" : "2018-02-21T10:25:44Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "2b7b0541-b463-45d2-99cd-f53b69480acf",
        "parentId" : "e6d9d797-d6db-4824-9b4a-46d904d4b11a",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "`zipWithConserve` starts with `if (xs.isEmpty || ys.isEmpty) Nil` and therefore it will trim the longest list. Maybe we should change it to `xs.isEmpty && ys.isEmpty` and require the two list to be of the same size.",
        "createdAt" : "2017-12-11T13:01:41Z",
        "updatedAt" : "2018-02-21T10:25:44Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      },
      {
        "id" : "42cd4215-a66c-4f17-91a2-f94e355f8e85",
        "parentId" : "e6d9d797-d6db-4824-9b4a-46d904d4b11a",
        "authorId" : "223e67d6-1873-432a-9af9-f40b82a7eedd",
        "body" : "Note that both `x.zip(y)` and `(x, y).zipped` trim the longest list",
        "createdAt" : "2017-12-11T13:14:26Z",
        "updatedAt" : "2018-02-21T10:25:44Z",
        "lastEditedBy" : "223e67d6-1873-432a-9af9-f40b82a7eedd",
        "tags" : [
        ]
      },
      {
        "id" : "48472ac9-b8f5-42a2-8d27-d51970875f7a",
        "parentId" : "e6d9d797-d6db-4824-9b4a-46d904d4b11a",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "We could change the semantics of ours to ensure no unexpected trimming is done.",
        "createdAt" : "2017-12-11T17:18:47Z",
        "updatedAt" : "2018-02-21T10:25:44Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      },
      {
        "id" : "865f4033-e23b-48c0-8f1a-0978361c5f89",
        "parentId" : "e6d9d797-d6db-4824-9b4a-46d904d4b11a",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "No, it's fine. I forgot about the trimming behavior. So the current implementation is OK.",
        "createdAt" : "2018-01-21T19:49:42Z",
        "updatedAt" : "2018-02-21T10:25:44Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "68afbcd915c5f6e17f4d1347c6a784c9b1639b13",
    "line" : 36,
    "diffHunk" : "@@ -1,1 +510,514 @@              // Arguments are phantom if an only if the parameters are phantom, guaranteed by the separation of type lattices\n              val args1 = args0.filterConserve(arg => !wasPhantom(arg.typeOpt))\n              assert(args1 hasSameLengthAs mt.paramInfos)\n              val args2 = args1.zipWithConserve(mt.paramInfos)(typedExpr)\n              untpd.cpy.Apply(tree)(fun1, args2) withType mt.resultType"
  },
  {
    "id" : "596f7451-e1aa-4642-9a31-1a49299bb0b6",
    "prId" : 1758,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/1758#pullrequestreview-10761540",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "42d3a9e3-9cbf-4078-8687-5210c51b3311",
        "parentId" : null,
        "authorId" : "6d71bb21-e402-4464-b2b1-8bdd8e068461",
        "body" : "`s/to ise/into/`?",
        "createdAt" : "2016-11-30T15:00:27Z",
        "updatedAt" : "2016-12-01T12:32:12Z",
        "lastEditedBy" : "6d71bb21-e402-4464-b2b1-8bdd8e068461",
        "tags" : [
        ]
      }
    ],
    "commit" : "055f12f957ec176323e4e0bf01af51666b9ff433",
    "line" : 108,
    "diffHunk" : "@@ -1,1 +504,508 @@\n    /** Besides normal typing, this function also compacts anonymous functions\n     *  with more than `MaxImplementedFunctionArity` parameters to ise a single\n     *  parameter of type `[]Object`.\n     */"
  }
]
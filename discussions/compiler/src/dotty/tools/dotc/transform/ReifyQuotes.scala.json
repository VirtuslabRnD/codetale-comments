[
  {
    "id" : "92eada7b-6486-4261-881c-80e69a24282a",
    "prId" : 9146,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/9146#pullrequestreview-430369425",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "22192ded-745b-4c7f-937c-b33de0fa685c",
        "parentId" : null,
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "@nicolasstucki I'm not sure if this is the best fix. Could you advise? The detailed message is in 235e393965bc9680f0d0c1a386f9d7c87a6b22d0.",
        "createdAt" : "2020-06-11T15:20:44Z",
        "updatedAt" : "2020-06-11T15:20:44Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "be7efdd2-e13c-4264-983d-206ec8689bb3",
        "parentId" : "22192ded-745b-4c7f-937c-b33de0fa685c",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "This change seems to be good",
        "createdAt" : "2020-06-15T07:02:53Z",
        "updatedAt" : "2020-06-15T07:02:53Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      }
    ],
    "commit" : "3c61bcaae28b6969d5437e7a0498f4921904c77d",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +271,275 @@      val tpe = MethodType(defn.SeqType.appliedTo(defn.AnyType) :: Nil, tree.tpe.widen)\n      val meth = ctx.newSymbol(lambdaOwner, UniqueName.fresh(nme.ANON_FUN), Synthetic | Method, tpe)\n      Closure(meth, tss => body(tss.head.head)(ctx.withOwner(meth)).changeNonLocalOwners(meth)).withSpan(tree.span)\n    }\n"
  },
  {
    "id" : "ec93dc64-fa1e-4b4c-8239-bcc0cb180402",
    "prId" : 8561,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/8561#pullrequestreview-385493159",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "db640fd8-3b19-482e-a8fc-0c5dfd281827",
        "parentId" : null,
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "Will approximation of the hole type have consequences on member resolution in unpickling?",
        "createdAt" : "2020-04-01T09:56:09Z",
        "updatedAt" : "2020-04-01T13:31:51Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "21769dde-c94d-450e-b874-7b1771207223",
        "parentId" : "db640fd8-3b19-482e-a8fc-0c5dfd281827",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "Yes, the consequence is that when unpickling we use the same known bounds of the types to resolve members selection as was done in typed. This is the key to make sure they do not change.",
        "createdAt" : "2020-04-01T11:24:15Z",
        "updatedAt" : "2020-04-01T12:21:36Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      }
    ],
    "commit" : "cebfdd8f5b6249aa1f7d8f4870bf0da7b7349152",
    "line" : 31,
    "diffHunk" : "@@ -1,1 +358,362 @@          case tp =>\n            mapOver(tp)\n      }\n\n      val holeType = if isTermHole then getTermHoleType(tpe) else getTypeHoleType(tpe)"
  },
  {
    "id" : "854b4e0b-ba08-4068-9e82-655eb5f21fc6",
    "prId" : 7531,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/7531#pullrequestreview-315134369",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "57578bcf-52bc-400a-9b9c-bc10e04baf9f",
        "parentId" : null,
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "Does it mean it throws the annotation away? That will make it impossible to keep some annotations in types.",
        "createdAt" : "2019-11-11T18:17:33Z",
        "updatedAt" : "2019-11-11T18:17:34Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "c4e78597-dbfa-4854-ba83-eebd429e40e1",
        "parentId" : "57578bcf-52bc-400a-9b9c-bc10e04baf9f",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "We throw away the annotation on the type but then recover it from the `Annotated` type tree while unpickling. \r\nMaybe I should only do it if it contains a splice. In that case we would always have the tree.",
        "createdAt" : "2019-11-11T20:20:12Z",
        "updatedAt" : "2019-11-11T20:20:13Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      }
    ],
    "commit" : "02536cdbc3724e6c37dbe4c77ab58873093de927",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +159,163 @@            }\n          case AnnotatedType(parent, _) =>\n            apply(parent) // Only keep the Annotated tree\n          case _ =>\n            mapOver(tp)"
  },
  {
    "id" : "87c7d31a-8bba-4a15-8d64-40af9820d119",
    "prId" : 7053,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/7053#pullrequestreview-278859811",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6dc8b6fd-6376-4ce4-95b9-2f1a0b586fd0",
        "parentId" : null,
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "Why we need `level > 1`?",
        "createdAt" : "2019-08-21T09:57:59Z",
        "updatedAt" : "2019-08-21T11:32:27Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "cd3b615d-15f1-4bf2-9370-c70d5169253a",
        "parentId" : "6dc8b6fd-6376-4ce4-95b9-2f1a0b586fd0",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "For code like this\r\n```scala\r\nimport scala.quoted._\r\nclass Test {\r\n  def foo(str: String) given QuoteContext = '{\r\n   '{\r\n     @deprecated(str, \"\") // error\r\n      def bar = ???\r\n    }\r\n  }\r\n}\r\n```\r\nI will add a test case",
        "createdAt" : "2019-08-21T11:24:38Z",
        "updatedAt" : "2019-08-21T11:32:27Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      },
      {
        "id" : "bb73d969-91a0-4beb-b611-6cfd960a3cf6",
        "parentId" : "6dc8b6fd-6376-4ce4-95b9-2f1a0b586fd0",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "Added",
        "createdAt" : "2019-08-21T11:32:41Z",
        "updatedAt" : "2019-08-21T11:32:41Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      },
      {
        "id" : "d1b9c5c7-4387-46ab-83e3-fcd9bd9a5c2b",
        "parentId" : "6dc8b6fd-6376-4ce4-95b9-2f1a0b586fd0",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "I'm wondering if the following code is possible and if it's handled by the compiler.\r\n\r\n```Scala\r\nimport scala.quoted._\r\n\r\nclass annot[T: Type](x: T)\r\n\r\nclass Test()(given qtx: QuoteContext) {\r\n  @annot(4)\r\n  def foo(str: String) = ()\r\n}\r\n```",
        "createdAt" : "2019-08-23T08:22:58Z",
        "updatedAt" : "2019-08-23T08:23:02Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      }
    ],
    "commit" : "866d6abd5f6947c6bffd3b53aeabdcb2a44a63a2",
    "line" : 20,
    "diffHunk" : "@@ -1,1 +413,417 @@            }\n            tree.symbol.annotations = newAnnotations\n            super.transform(tree)\n          case _ =>\n            super.transform(tree)"
  },
  {
    "id" : "d3832173-66e2-4c0c-b1fc-51fbc21887c3",
    "prId" : 6793,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/6793#pullrequestreview-257964505",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "025fe15c-1e48-4ea4-916e-7f82bb34a7cd",
        "parentId" : null,
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "We still need special compiler support for lifting primitives? Or it's for backward-compatibility.",
        "createdAt" : "2019-07-04T10:12:00Z",
        "updatedAt" : "2019-07-04T10:17:47Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "469c6e97-aafa-49a8-ad26-2cdee795aab1",
        "parentId" : "025fe15c-1e48-4ea4-916e-7f82bb34a7cd",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "We do not need it anymore.",
        "createdAt" : "2019-07-04T10:30:42Z",
        "updatedAt" : "2019-07-04T10:30:43Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      }
    ],
    "commit" : "65901c5d9eee7c17f0ea4f0d2d997abcd03e9bd5",
    "line" : 45,
    "diffHunk" : "@@ -1,1 +225,229 @@        }\n      }\n\n      def pickleAsTasty() = {\n        val meth ="
  },
  {
    "id" : "58ba319f-efa3-4d57-8623-1916bddc0989",
    "prId" : 5153,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/5153#pullrequestreview-158988660",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1765bb08-f76a-4084-8f62-572288b8c9f4",
        "parentId" : null,
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "A document is deserved here.",
        "createdAt" : "2018-09-26T12:14:15Z",
        "updatedAt" : "2018-09-26T12:33:02Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "de358dc7-65fa-4215-a4c5-9c8099f8e00b",
        "parentId" : "1765bb08-f76a-4084-8f62-572288b8c9f4",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "Added",
        "createdAt" : "2018-09-26T13:15:36Z",
        "updatedAt" : "2018-09-26T13:15:36Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      }
    ],
    "commit" : "f1a37dd83940e2975883eec989825bc38f5d29ed",
    "line" : 38,
    "diffHunk" : "@@ -1,1 +499,503 @@       * hence we should take that as owner directly.\n       */\n      val lambdaOwner = if (level == -1) ctx.owner else outer.rctx.owner\n\n      val tpe = MethodType(defn.SeqType.appliedTo(defn.AnyType) :: Nil, tree.tpe.widen)"
  },
  {
    "id" : "e86829f3-1de8-405f-bc94-5fc188476e5e",
    "prId" : 4856,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/4856#pullrequestreview-141969740",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "03ddd820-66db-4568-97df-2cc36afabff4",
        "parentId" : null,
        "authorId" : "37519144-0f9f-4b2b-85f7-34dde9be2e11",
        "body" : "Small question. We don't split if we are in a transparent method but the level is above or equal zero?\r\nIf yes, we can move splitting inside the `if` now.",
        "createdAt" : "2018-07-31T13:43:58Z",
        "updatedAt" : "2018-07-31T13:48:26Z",
        "lastEditedBy" : "37519144-0f9f-4b2b-85f7-34dde9be2e11",
        "tags" : [
        ]
      },
      {
        "id" : "f93e0463-ccb4-453a-bd97-62c35bea52c3",
        "parentId" : "03ddd820-66db-4568-97df-2cc36afabff4",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "We do not split, but we still need to perform the checks that split does. We should be able to improve the performance by calling transform directly in another branch. I will try that later, nice catch :)",
        "createdAt" : "2018-07-31T14:02:44Z",
        "updatedAt" : "2018-07-31T14:02:57Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      }
    ],
    "commit" : "817cc9ba098457f2875adba4211c6b912dce91c9",
    "line" : 28,
    "diffHunk" : "@@ -1,1 +365,369 @@        case _=>\n          val (body1, splices) = nested(isQuote = true).split(body)\n          if (level == 0 && !ctx.inTransparentMethod) pickledQuote(body1, splices, body.tpe, isType).withPos(quote.pos)\n          else {\n            // In top-level splice in an transparent def. Keep the tree as it is, it will be transformed at inline site."
  },
  {
    "id" : "47fa8504-822d-4fd1-983f-a8628ef7297c",
    "prId" : 4822,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/4822#pullrequestreview-141053661",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5285c702-e217-438c-984d-9956790fffdf",
        "parentId" : null,
        "authorId" : "37519144-0f9f-4b2b-85f7-34dde9be2e11",
        "body" : "Does the comment that was here before apply here as well?",
        "createdAt" : "2018-07-27T08:43:21Z",
        "updatedAt" : "2018-07-27T15:26:25Z",
        "lastEditedBy" : "37519144-0f9f-4b2b-85f7-34dde9be2e11",
        "tags" : [
        ]
      },
      {
        "id" : "12ad86c2-5383-4963-a381-b6d5ba76fe0c",
        "parentId" : "5285c702-e217-438c-984d-9956790fffdf",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "No. Now we just remove the RHS to prune the tree earlier in the pipeline. Maybe this could be done later. ",
        "createdAt" : "2018-07-27T09:58:16Z",
        "updatedAt" : "2018-07-27T15:26:25Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      },
      {
        "id" : "c6e13b31-954f-4e43-bccc-c70a01017675",
        "parentId" : "5285c702-e217-438c-984d-9956790fffdf",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "This logic will be simplified later in #4826.",
        "createdAt" : "2018-07-27T10:00:38Z",
        "updatedAt" : "2018-07-27T15:26:25Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      }
    ],
    "commit" : "a17b25b5fefa3d542ccb1ff59702ef2ce0427262",
    "line" : 127,
    "diffHunk" : "@@ -1,1 +567,571 @@                val reifier = nested(isQuote = true)\n                reifier.transform(tree) // Ignore output, only check PCP\n                cpy.DefDef(tree)(rhs = defaultValue(tree.rhs.tpe))\n              case _ =>\n                ctx.error("
  },
  {
    "id" : "a732d2b9-e457-45cc-a32b-da1850cca4fa",
    "prId" : 4460,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/4460#pullrequestreview-119885873",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c3de5335-b2e6-4b76-9ef8-e0e44723efda",
        "parentId" : null,
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "The addition of `!defn.isFunctionType(sym.info)` is the only real change in this PR, the rest is refactoring.",
        "createdAt" : "2018-05-13T06:12:03Z",
        "updatedAt" : "2018-05-13T06:12:03Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      },
      {
        "id" : "ce56c717-aa03-4549-9dc6-ba52e39c09ea",
        "parentId" : "c3de5335-b2e6-4b76-9ef8-e0e44723efda",
        "authorId" : "37519144-0f9f-4b2b-85f7-34dde9be2e11",
        "body" : "LGTM",
        "createdAt" : "2018-05-14T12:27:38Z",
        "updatedAt" : "2018-05-14T12:27:39Z",
        "lastEditedBy" : "37519144-0f9f-4b2b-85f7-34dde9be2e11",
        "tags" : [
        ]
      },
      {
        "id" : "df081572-3c59-45a1-b53f-a5767592d6bf",
        "parentId" : "c3de5335-b2e6-4b76-9ef8-e0e44723efda",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "After discussion with Aggelos, also LGTM for me. \r\n\r\n@Blaisorblade \"cross stage persistence in reverse\" is a good way to characterize this.",
        "createdAt" : "2018-05-14T15:26:12Z",
        "updatedAt" : "2018-05-14T15:26:12Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "b75714f88dabdc8fe41447ffdc648d31d9e6a76a",
    "line" : 79,
    "diffHunk" : "@@ -1,1 +631,635 @@\n    private def isStage0Value(sym: Symbol)(implicit ctx: Context): Boolean =\n      sym.is(Inline) && sym.owner.is(Macro) && !defn.isFunctionType(sym.info)\n\n    private def liftList(list: List[Tree], tpe: Type)(implicit ctx: Context): Tree = {"
  },
  {
    "id" : "8c9d9f7e-1a9a-4033-98aa-38fbafa2712e",
    "prId" : 4261,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/4261#pullrequestreview-110126834",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "193461a9-2b09-45cb-9699-9c702ace96d9",
        "parentId" : null,
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "`ctx.compilationUnit.containsQuotesOrSplices` will always be true. We only run this phase if it is true\r\nhttps://github.com/lampepfl/dotty/pull/4261/files#diff-7b199cbe62cc044a10a26459c0f0fa46R94",
        "createdAt" : "2018-04-06T05:55:48Z",
        "updatedAt" : "2018-04-06T05:56:07Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      },
      {
        "id" : "b730cd7d-861c-4af2-a40c-9a3776d42021",
        "parentId" : "193461a9-2b09-45cb-9699-9c702ace96d9",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "I was wrong, we do need this check.",
        "createdAt" : "2018-04-06T09:34:30Z",
        "updatedAt" : "2018-04-06T09:34:31Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      },
      {
        "id" : "804272ca-7ea2-4110-b515-844aff355de9",
        "parentId" : "193461a9-2b09-45cb-9699-9c702ace96d9",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "We could also avoid accessing the symbol \r\n```scala\r\n  override def transform(ref: SingleDenotation)(implicit ctx: Context): SingleDenotation =\r\n    if (ctx.compilationUnit.containsQuotesOrSplices) super.transform(ref) else ref\r\n\r\n  override protected def mayChange(sym: Symbol)(implicit ctx: Context): Boolean = sym.isTerm && sym.is(Macro)\r\n```",
        "createdAt" : "2018-04-06T09:37:23Z",
        "updatedAt" : "2018-04-06T09:37:23Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      },
      {
        "id" : "cfde1b85-2a7d-4bf2-a375-ca84bae0bec5",
        "parentId" : "193461a9-2b09-45cb-9699-9c702ace96d9",
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Calling `Denotation#symbol` is just a field access, so I don't think that's worth it.",
        "createdAt" : "2018-04-06T14:13:47Z",
        "updatedAt" : "2018-04-06T14:13:47Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "3d2e6ed5-5f8b-4a2f-922e-ad8750c53d6c",
        "parentId" : "193461a9-2b09-45cb-9699-9c702ace96d9",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "Ok",
        "createdAt" : "2018-04-06T16:26:28Z",
        "updatedAt" : "2018-04-06T16:26:28Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      }
    ],
    "commit" : "2ebf138651ba64253b854bdb05f0a9e46478eb9d",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +622,626 @@\n  override protected def mayChange(sym: Symbol)(implicit ctx: Context): Boolean =\n    ctx.compilationUnit.containsQuotesOrSplices && sym.isTerm && sym.is(Macro)\n\n  /** Returns the type of the compiled macro as a lambda: Seq[Any] => Object */"
  },
  {
    "id" : "e517de4d-d2c9-4531-8203-20e159ca217b",
    "prId" : 4081,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/4081#pullrequestreview-103760726",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5c45160b-0e03-4282-abd5-cc4657cd357c",
        "parentId" : null,
        "authorId" : "37519144-0f9f-4b2b-85f7-34dde9be2e11",
        "body" : "`splice` could handle the case of a `TypeTree` before. 🤔 ",
        "createdAt" : "2018-03-14T10:25:24Z",
        "updatedAt" : "2018-03-16T07:24:17Z",
        "lastEditedBy" : "37519144-0f9f-4b2b-85f7-34dde9be2e11",
        "tags" : [
        ]
      }
    ],
    "commit" : "b74c7237f097a9a4c6e4a77f0d4f27673584c6ae",
    "line" : 232,
    "diffHunk" : "@@ -1,1 +304,308 @@     *  are in the body of an inline method.\n     */\n    private def splice(splice: Select)(implicit ctx: Context): Tree = {\n      if (level > 1) {\n        val body1 = nested(isQuote = false).transform(splice.qualifier)"
  },
  {
    "id" : "19a50ed3-f1bd-4c93-ae05-b033845af87d",
    "prId" : 4012,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/4012#pullrequestreview-97608798",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0e3c2967-61b6-45e7-83f5-22c887350880",
        "parentId" : null,
        "authorId" : "223e67d6-1873-432a-9af9-f40b82a7eedd",
        "body" : "Can you give an example of when this happen?",
        "createdAt" : "2018-02-19T10:08:06Z",
        "updatedAt" : "2018-02-21T13:54:57Z",
        "lastEditedBy" : "223e67d6-1873-432a-9af9-f40b82a7eedd",
        "tags" : [
        ]
      },
      {
        "id" : "525ff549-cb46-4703-844e-806d5801ff47",
        "parentId" : "0e3c2967-61b6-45e7-83f5-22c887350880",
        "authorId" : "37519144-0f9f-4b2b-85f7-34dde9be2e11",
        "body" : "Yes, this is related to the implicit conversion related to value discarding (simply put when an `e` returns a value and it's called from a function of expected type `Unit` and it is converted into `{ e; () }`). This manifested in quoted code as well.",
        "createdAt" : "2018-02-19T15:14:00Z",
        "updatedAt" : "2018-02-21T13:54:57Z",
        "lastEditedBy" : "37519144-0f9f-4b2b-85f7-34dde9be2e11",
        "tags" : [
        ]
      },
      {
        "id" : "acc2ccda-d228-45e3-8dde-c89164baa338",
        "parentId" : "0e3c2967-61b6-45e7-83f5-22c887350880",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "For example `inline foo: Unit = 4` will become `inline foo: Unit = { 4; () }` and then be inlined as `{ 4; () }`. In our case we have a `~xyz` instead of `4`.",
        "createdAt" : "2018-02-19T15:19:06Z",
        "updatedAt" : "2018-02-21T13:54:57Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      },
      {
        "id" : "cdf55216-9459-4ea1-859f-e459ef6cd80b",
        "parentId" : "0e3c2967-61b6-45e7-83f5-22c887350880",
        "authorId" : "223e67d6-1873-432a-9af9-f40b82a7eedd",
        "body" : "Got it! I would add a comment explaining why this is needed (i.e. the compiler can insert `()`).",
        "createdAt" : "2018-02-19T17:01:04Z",
        "updatedAt" : "2018-02-21T13:54:57Z",
        "lastEditedBy" : "223e67d6-1873-432a-9af9-f40b82a7eedd",
        "tags" : [
        ]
      }
    ],
    "commit" : "57afac679778c49c59f4207ce8c8887592e44b0a",
    "line" : 38,
    "diffHunk" : "@@ -1,1 +359,363 @@          case expansion: Select if expansion.symbol.isSplice =>\n            Some(expansion)\n          case Block(List(stat), Literal(Constant(()))) => unapply(stat)\n          case Block(Nil, expr) => unapply(expr)\n          case _ => None"
  },
  {
    "id" : "405bf1cb-5faa-4289-a00d-21e7d61f268a",
    "prId" : 4012,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/4012#pullrequestreview-98139924",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0b5597cd-6e29-4a74-86e3-94ec42455833",
        "parentId" : null,
        "authorId" : "223e67d6-1873-432a-9af9-f40b82a7eedd",
        "body" : "I don't know how performance sensitive this code is but you could return a `Tree` instead of `Option[Select]` to avoid boxing (and `EmptyTree` instead of `None`)",
        "createdAt" : "2018-02-19T17:26:24Z",
        "updatedAt" : "2018-02-21T13:54:57Z",
        "lastEditedBy" : "223e67d6-1873-432a-9af9-f40b82a7eedd",
        "tags" : [
        ]
      },
      {
        "id" : "e6e482a9-d287-4a56-a277-d3725b3eece8",
        "parentId" : "0b5597cd-6e29-4a74-86e3-94ec42455833",
        "authorId" : "37519144-0f9f-4b2b-85f7-34dde9be2e11",
        "body" : "We need that `.get` method on `unapply`'s return type so isn't `Option` unavoidable?",
        "createdAt" : "2018-02-21T10:18:07Z",
        "updatedAt" : "2018-02-21T13:54:57Z",
        "lastEditedBy" : "37519144-0f9f-4b2b-85f7-34dde9be2e11",
        "tags" : [
        ]
      },
      {
        "id" : "dc187eff-525b-41b1-a8b6-60436ac74fa7",
        "parentId" : "0b5597cd-6e29-4a74-86e3-94ec42455833",
        "authorId" : "223e67d6-1873-432a-9af9-f40b82a7eedd",
        "body" : "I believe `Tree` qualifies for both [product pattern](http://dotty.epfl.ch/docs/reference/changed/pattern-matching.html#product-pattern) and [name based pattern](http://dotty.epfl.ch/docs/reference/changed/pattern-matching.html#name-based-pattern). And scalac supports name based pattern",
        "createdAt" : "2018-02-21T10:27:02Z",
        "updatedAt" : "2018-02-21T13:54:57Z",
        "lastEditedBy" : "223e67d6-1873-432a-9af9-f40b82a7eedd",
        "tags" : [
        ]
      }
    ],
    "commit" : "57afac679778c49c59f4207ce8c8887592e44b0a",
    "line" : 33,
    "diffHunk" : "@@ -1,1 +354,358 @@     *  consists of a (possibly multiple & nested) block or a sole expression.\n     */\n    object InlineSplice {\n      def unapply(tree: Tree)(implicit ctx: Context): Option[Select] = {\n        tree match {"
  },
  {
    "id" : "d44ab136-9094-4550-97bd-c88c0cfb7793",
    "prId" : 3833,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/3833#pullrequestreview-88784822",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b077ad19-f8e8-4096-86d5-665869c237a9",
        "parentId" : null,
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "@odersky could you have a look at this one. I did not manage to use the `MacroTransformWithImplicits` and `inferImplicitArg` to get the implicit argument. I looked at b466e0afa6ea1908fcef8dc0fe2b30fa2887949a but it might be too outdated.",
        "createdAt" : "2018-01-15T11:07:33Z",
        "updatedAt" : "2018-01-17T16:48:31Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      }
    ],
    "commit" : "e4b93e72d653ba1a2fcfa4caa20df47cbea87dc4",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +137,141 @@        val trefs = importedTypes.toList\n        val typeDefs = for (tref <- trefs) yield {\n          val tag = New(defn.QuotedTypeType.appliedTo(tref), Nil) // FIXME: should be an implicitly inferred defn.QuotedTypeType.appliedTo(tref)\n          val rhs = transform(tag.select(tpnme.UNARY_~))\n          val alias = ctx.typeAssigner.assignType(untpd.TypeBoundsTree(rhs, rhs), rhs, rhs)"
  }
]
[
  {
    "id" : "665696a2-fe2e-4217-b0ee-48f78a558925",
    "prId" : 4672,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/4672#pullrequestreview-130798278",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "970c405c-936e-410e-81e7-69e45f6a98af",
        "parentId" : null,
        "authorId" : "348fab8e-49e2-442e-884d-850c7f41fdde",
        "body" : "I wonder if we should allow writing such a class `Foo`, rather than just allowing closures — we don't for implicit function types and nobody seems to mind the restriction, and this restriction enables transformations such as `ShortcutImplicits`. https://github.com/lampepfl/dotty/pull/1775/files#diff-71350811180f41d868e7fb3258fd774dR18",
        "createdAt" : "2018-06-21T10:02:47Z",
        "updatedAt" : "2019-05-30T13:05:55Z",
        "lastEditedBy" : "348fab8e-49e2-442e-884d-850c7f41fdde",
        "tags" : [
        ]
      },
      {
        "id" : "29ed9053-3f92-4f88-af5b-d27bb30ee6f9",
        "parentId" : "970c405c-936e-410e-81e7-69e45f6a98af",
        "authorId" : "98bdc06d-7937-462c-9d62-1f850e7819aa",
        "body" : "Note that it can be really useful being able to extend/implement a polymorphic function type; it's one of the use cases I mention in https://github.com/lampepfl/dotty/issues/4670#issuecomment-397819801 – making polymorphic ~~type~~ case classes extend the corresponding polymorphic function type.\r\n\r\nEDIT – typo: \"type class\" -> \"case class\"",
        "createdAt" : "2018-06-21T11:30:09Z",
        "updatedAt" : "2019-05-30T13:05:55Z",
        "lastEditedBy" : "98bdc06d-7937-462c-9d62-1f850e7819aa",
        "tags" : [
        ]
      },
      {
        "id" : "3c5abf65-25a6-4ae6-a624-5c57c128962a",
        "parentId" : "970c405c-936e-410e-81e7-69e45f6a98af",
        "authorId" : "348fab8e-49e2-442e-884d-850c7f41fdde",
        "body" : "Ah right, tho `s/type classes/case classes/`. But if we follow the approach for implicit function types, `val b: Int => B[Int] = B` could still work by eta-expansion. In fact, it's not clear why eta-expansion doesn't handle that case today by turning `B` into `B _` or `B.apply` (and I'm not going to try which ones do work, I'd just ask they all work unless backward compatibility gets in the way).",
        "createdAt" : "2018-06-21T11:57:39Z",
        "updatedAt" : "2019-05-30T13:05:55Z",
        "lastEditedBy" : "348fab8e-49e2-442e-884d-850c7f41fdde",
        "tags" : [
        ]
      },
      {
        "id" : "7694777e-d3a4-4907-8b14-38114f8dfc65",
        "parentId" : "970c405c-936e-410e-81e7-69e45f6a98af",
        "authorId" : "98bdc06d-7937-462c-9d62-1f850e7819aa",
        "body" : "@Blaisorblade AFAIK eta expansion never inserts `.apply` calls on things that are not functions. It's true that adding this behavior could be an alternative solution to the stated polymorphic case class problem.",
        "createdAt" : "2018-06-21T12:47:19Z",
        "updatedAt" : "2019-05-30T13:05:55Z",
        "lastEditedBy" : "98bdc06d-7937-462c-9d62-1f850e7819aa",
        "tags" : [
        ]
      }
    ],
    "commit" : "112aa55d80bfd626b336fbc57fb4f3b5caeec31c",
    "line" : 19,
    "diffHunk" : "@@ -1,1 +17,21 @@ *      class Foo extends FunctionN {\n *          def apply(x_1: P_1, ..., x_N: P_N): R = rhs\n *      }\n */\nclass ElimPolyFunction extends MiniPhase with DenotTransformer {"
  }
]
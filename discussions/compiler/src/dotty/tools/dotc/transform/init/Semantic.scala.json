[
  {
    "id" : "ab3d25fb-5c0f-4eed-83e7-01b5098bc5fe",
    "prId" : 12711,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/12711#pullrequestreview-677744588",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "59297353-8c43-456d-8cef-651be326a240",
        "parentId" : null,
        "authorId" : "ed629d1e-b3d4-4235-b1d2-9b900fd9ee32",
        "body" : "These constructor parameters are the `args` field in `Warm`, right?",
        "createdAt" : "2021-06-07T16:41:34Z",
        "updatedAt" : "2021-06-07T17:47:35Z",
        "lastEditedBy" : "ed629d1e-b3d4-4235-b1d2-9b900fd9ee32",
        "tags" : [
        ]
      },
      {
        "id" : "6cfb4e02-8b3c-42e1-b989-06156ebc265b",
        "parentId" : "59297353-8c43-456d-8cef-651be326a240",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "`Warm` only contain arguments to the constructor of the concrete class, but not arguments to its super-constructors.",
        "createdAt" : "2021-06-07T18:17:02Z",
        "updatedAt" : "2021-06-07T20:29:30Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      }
    ],
    "commit" : "7fde75e3a11ae2b87b992a2b3d32f550636525f1",
    "line" : 50,
    "diffHunk" : "@@ -1,1 +152,156 @@   *  constructors, we don't need to put environment as the cache key. The\n   *  reason is that constructor parameters are determined by the value of\n   *  `this` --- it suffices to make the value of `this` as part of the cache\n   *  key.\n   *"
  },
  {
    "id" : "cccdc8a1-7e4e-47b4-bc78-f68e17b09272",
    "prId" : 12711,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/12711#pullrequestreview-677744588",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c6c81c51-5e18-4359-8e67-0b0771c8f28c",
        "parentId" : null,
        "authorId" : "ed629d1e-b3d4-4235-b1d2-9b900fd9ee32",
        "body" : "Is `isCurrentObjectPromoted` for `ThisRef` and `values` for `Warm` values?",
        "createdAt" : "2021-06-07T16:43:50Z",
        "updatedAt" : "2021-06-07T17:47:35Z",
        "lastEditedBy" : "ed629d1e-b3d4-4235-b1d2-9b900fd9ee32",
        "tags" : [
        ]
      },
      {
        "id" : "74394925-e029-4f57-9bfd-ba8340336416",
        "parentId" : "c6c81c51-5e18-4359-8e67-0b0771c8f28c",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "Yes, that's correct. However, `values` may also contain functions values.",
        "createdAt" : "2021-06-07T18:17:28Z",
        "updatedAt" : "2021-06-07T18:33:23Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      }
    ],
    "commit" : "7fde75e3a11ae2b87b992a2b3d32f550636525f1",
    "line" : 92,
    "diffHunk" : "@@ -1,1 +194,198 @@    class PromotionInfo {\n      var isCurrentObjectPromoted: Boolean = false\n      val values = mutable.Set.empty[Value]\n    }\n    /** Values that have been safely promoted */"
  },
  {
    "id" : "be52e9e3-0edd-4901-875e-d8fc50336657",
    "prId" : 12711,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/12711#pullrequestreview-677765602",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "cf0c0362-8b1d-424d-9f82-730bd2bf597c",
        "parentId" : null,
        "authorId" : "ed629d1e-b3d4-4235-b1d2-9b900fd9ee32",
        "body" : "Is there a specific reason to prefer this pattern of `given` over the `use()` method?",
        "createdAt" : "2021-06-07T17:02:33Z",
        "updatedAt" : "2021-06-07T17:47:35Z",
        "lastEditedBy" : "ed629d1e-b3d4-4235-b1d2-9b900fd9ee32",
        "tags" : [
        ]
      },
      {
        "id" : "014906d2-d5cd-458b-b84e-fe2da4140d30",
        "parentId" : "cf0c0362-8b1d-424d-9f82-730bd2bf597c",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "I try to use `given T = e` whenever possible. However, in same places we cannot easily use `given`, because of scoping interference. I described the problem in more detail [here](https://github.com/lampepfl/dotty/discussions/12529).",
        "createdAt" : "2021-06-07T18:43:49Z",
        "updatedAt" : "2021-06-07T20:29:56Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      }
    ],
    "commit" : "7fde75e3a11ae2b87b992a2b3d32f550636525f1",
    "line" : 238,
    "diffHunk" : "@@ -1,1 +408,412 @@              val env2 = Env(ddef, args.map(_.value).widenArgs)\n              if target.isPrimaryConstructor then\n                given Env = env2\n                val tpl = cls.defTree.asInstanceOf[TypeDef].rhs.asInstanceOf[Template]\n                val res = withTrace(trace.add(cls.defTree)) { eval(tpl, addr, cls, cacheResult = true) }"
  },
  {
    "id" : "38b2f6f5-9be4-4d02-b3f6-0418f64d61c3",
    "prId" : 12711,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/12711#pullrequestreview-677652176",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4c4859e0-2a1b-4a78-8d65-66fe992a4b75",
        "parentId" : null,
        "authorId" : "ed629d1e-b3d4-4235-b1d2-9b900fd9ee32",
        "body" : "There is now a lot of nesting of if-then-else here. Perhaps the code would be easier to understand if the final `else` clause in each `if` statement had a comment to say which case it's covering.",
        "createdAt" : "2021-06-07T17:07:58Z",
        "updatedAt" : "2021-06-07T17:47:35Z",
        "lastEditedBy" : "ed629d1e-b3d4-4235-b1d2-9b900fd9ee32",
        "tags" : [
        ]
      }
    ],
    "commit" : "7fde75e3a11ae2b87b992a2b3d32f550636525f1",
    "line" : 243,
    "diffHunk" : "@@ -1,1 +412,416 @@                val res = withTrace(trace.add(cls.defTree)) { eval(tpl, addr, cls, cacheResult = true) }\n                Result(addr, res.errors)\n              else if target.isConstructor then\n                given Env = env2\n                eval(ddef.rhs, addr, cls, cacheResult = true)"
  },
  {
    "id" : "befbd66b-9268-46c1-a061-e80815636846",
    "prId" : 12711,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/12711#pullrequestreview-677744588",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9c1e7668-5d9a-4cef-9606-0fe7a46d0e55",
        "parentId" : null,
        "authorId" : "ed629d1e-b3d4-4235-b1d2-9b900fd9ee32",
        "body" : "Should the call to `eval` below use `env` somehow?",
        "createdAt" : "2021-06-07T17:29:19Z",
        "updatedAt" : "2021-06-07T17:47:35Z",
        "lastEditedBy" : "ed629d1e-b3d4-4235-b1d2-9b900fd9ee32",
        "tags" : [
        ]
      },
      {
        "id" : "a0477eb6-deba-4029-9b7e-671118694032",
        "parentId" : "9c1e7668-5d9a-4cef-9606-0fe7a46d0e55",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "Good catch. Yes, we should use `env` as suggested above.\r\n\r\nStrictly speaking, the `env` argument is not needed. This is because  with the current restriction of non-hot to constructors and widening to Cold, it's impossible for a function that captures an environment to escape. \r\n Therefore, the environment `env` will be the same as the \"ambient\" environment.\r\n\r\nNote that putting `env` in `Fun` will not incur performance penalty (as `Fun` will never be `thisV` thus never cache key).",
        "createdAt" : "2021-06-07T18:29:59Z",
        "updatedAt" : "2021-06-07T18:33:23Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      }
    ],
    "commit" : "7fde75e3a11ae2b87b992a2b3d32f550636525f1",
    "line" : 459,
    "diffHunk" : "@@ -1,1 +569,573 @@        }\n\n      case fun @ Fun(body, thisV, klass, env) =>\n        if promoted.contains(fun) then Nil\n        else"
  },
  {
    "id" : "582843b9-f313-4212-9f85-5aeb9f8fd07e",
    "prId" : 12711,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/12711#pullrequestreview-677744588",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3f66c811-3f02-4883-b3b9-a08871bb7879",
        "parentId" : null,
        "authorId" : "ed629d1e-b3d4-4235-b1d2-9b900fd9ee32",
        "body" : "Why do we not pass `trace2` anymore?",
        "createdAt" : "2021-06-07T17:34:42Z",
        "updatedAt" : "2021-06-07T17:47:35Z",
        "lastEditedBy" : "ed629d1e-b3d4-4235-b1d2-9b900fd9ee32",
        "tags" : [
        ]
      },
      {
        "id" : "d6e02967-813b-489d-b315-54eebfbbf416",
        "parentId" : "3f66c811-3f02-4883-b3b9-a08871bb7879",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "Here we refactored the tracing logic: they are moved to `Value.call`.",
        "createdAt" : "2021-06-07T18:30:27Z",
        "updatedAt" : "2021-06-07T18:33:23Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      }
    ],
    "commit" : "7fde75e3a11ae2b87b992a2b3d32f550636525f1",
    "line" : 557,
    "diffHunk" : "@@ -1,1 +741,745 @@      case Call(ref, argss) =>\n        // check args\n        val (errors, args) = evalArgs(argss.flatten, thisV, klass)\n\n        ref match"
  },
  {
    "id" : "d3943e50-532d-4e21-a4e1-01a73f941f32",
    "prId" : 12711,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/12711#pullrequestreview-677744588",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f374afe2-a4dd-4ae5-8ffd-e0c1d1cb9828",
        "parentId" : null,
        "authorId" : "ed629d1e-b3d4-4235-b1d2-9b900fd9ee32",
        "body" : "I don't understand what this case corresponds to.",
        "createdAt" : "2021-06-07T17:40:38Z",
        "updatedAt" : "2021-06-07T17:47:35Z",
        "lastEditedBy" : "ed629d1e-b3d4-4235-b1d2-9b900fd9ee32",
        "tags" : [
        ]
      },
      {
        "id" : "7a6be300-6f7f-47f9-ae30-220351d792d9",
        "parentId" : "f374afe2-a4dd-4ae5-8ffd-e0c1d1cb9828",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "`cls.isStaticOwner` means it's a global object, `klass.isContainedIn(cls)` means we have `O.this` outside the body of the object `O`. We don't check global objects, so simply return `Hot` here.",
        "createdAt" : "2021-06-07T18:32:14Z",
        "updatedAt" : "2021-06-07T18:33:23Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      }
    ],
    "commit" : "7fde75e3a11ae2b87b992a2b3d32f550636525f1",
    "line" : 629,
    "diffHunk" : "@@ -1,1 +907,911 @@\n      case tp @ ThisType(tref) =>\n        val cls = tref.classSymbol.asClass\n        if cls.isStaticOwner && !klass.isContainedIn(cls) then\n          // O.this outside the body of the object O"
  },
  {
    "id" : "dbf4f452-11cf-4af1-be4e-000765eb8e4e",
    "prId" : 12711,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/12711#pullrequestreview-679149807",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fe74443b-d698-489c-99b1-456360daafed",
        "parentId" : null,
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "This is problematic: still possible to crash.",
        "createdAt" : "2021-06-08T15:31:45Z",
        "updatedAt" : "2021-06-08T15:31:46Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "dad39b90-cfd9-4bdb-b047-526e45b0582a",
        "parentId" : "fe74443b-d698-489c-99b1-456360daafed",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "@olhotak @EnzeXing In 98a0977 and 7f91775, I proposed two different fixes. Which fix makes more sense?\r\n\r\nI can squash the commits after we decide on one.",
        "createdAt" : "2021-06-08T21:10:44Z",
        "updatedAt" : "2021-06-08T21:19:35Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "efb97981-342c-468d-a57e-e55456901b08",
        "parentId" : "fe74443b-d698-489c-99b1-456360daafed",
        "authorId" : "ed629d1e-b3d4-4235-b1d2-9b900fd9ee32",
        "body" : "I'm not sure but I think I like https://github.com/lampepfl/dotty/commit/98a0977761a7a3151a2cf0a5e2d19c21a9373226 better. The error it gives is more explicit about why the code is being rejected. Also, in tests/init/neg/secondary-ctor4.scala, https://github.com/lampepfl/dotty/commit/7f917756a1abcc8b682aa2d58a38a3e8f76e72df reports more errors that are not related to inner classes in a secondary constructor.",
        "createdAt" : "2021-06-08T21:50:37Z",
        "updatedAt" : "2021-06-08T21:50:37Z",
        "lastEditedBy" : "ed629d1e-b3d4-4235-b1d2-9b900fd9ee32",
        "tags" : [
        ]
      },
      {
        "id" : "ba38a2d2-a626-4fc2-aaeb-e418db186975",
        "parentId" : "fe74443b-d698-489c-99b1-456360daafed",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "The errors are fewer in 98a0977  because the analysis just skipped the check.",
        "createdAt" : "2021-06-08T22:25:51Z",
        "updatedAt" : "2021-06-08T22:25:51Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "7e11a52f-f0a8-4008-9350-55a704fb3755",
        "parentId" : "fe74443b-d698-489c-99b1-456360daafed",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "I kind of prefer 7f91775, as the code is more regular --- we only have one special case in variable resolution. As the examples are all invented, I don't expect the two have an observable difference in expressiveness nor usability.",
        "createdAt" : "2021-06-08T22:33:20Z",
        "updatedAt" : "2021-06-09T06:03:53Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "1322a41f-90af-4f8f-add0-6f07dabc9e01",
        "parentId" : "fe74443b-d698-489c-99b1-456360daafed",
        "authorId" : "ed629d1e-b3d4-4235-b1d2-9b900fd9ee32",
        "body" : "OK, I'm OK with https://github.com/lampepfl/dotty/commit/7f917756a1abcc8b682aa2d58a38a3e8f76e72df as well. Simpler implementation is an advantage.",
        "createdAt" : "2021-06-09T02:15:42Z",
        "updatedAt" : "2021-06-09T02:15:43Z",
        "lastEditedBy" : "ed629d1e-b3d4-4235-b1d2-9b900fd9ee32",
        "tags" : [
        ]
      }
    ],
    "commit" : "7fde75e3a11ae2b87b992a2b3d32f550636525f1",
    "line" : 329,
    "diffHunk" : "@@ -1,1 +482,486 @@\n          val value = Warm(klass, outer, ctor, args.map(_.value).widenArgs).ensureExists\n          val res = value.call(ctor, args, superType = NoType, source)\n          Result(value, res.errors)\n"
  },
  {
    "id" : "60ee0b80-4cfa-40f4-b3b3-cd63a8e0894b",
    "prId" : 12608,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/12608#pullrequestreview-673053546",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a8908b95-1a77-4ce8-ac05-e093a4a12920",
        "parentId" : null,
        "authorId" : "ed629d1e-b3d4-4235-b1d2-9b900fd9ee32",
        "body" : "Before this change, the `Heap` contained only one object, the object at whose constructor we begin the analysis with `init`.\r\n\r\nAfter this change, the `Heap` contains more than one object. Which objects are they? How do we decide which concrete objects are represented in the `Heap` and which concrete objects are represented just by abstract values like `Hot` or `Cold`? What is the intended concretization of `Warm(C, outer)` as an `Addr`, which concrete object(s) does it represent? Does a `Heap` always contain exactly one `ThisRef` or can it contain multiple `ThisRef`s with different values of `klass`? If it can contain multiple `ThisRef`s, what is their concretization?",
        "createdAt" : "2021-05-31T16:39:07Z",
        "updatedAt" : "2021-05-31T16:39:08Z",
        "lastEditedBy" : "ed629d1e-b3d4-4235-b1d2-9b900fd9ee32",
        "tags" : [
        ]
      },
      {
        "id" : "e527f010-03e8-4a31-9802-0cd7dd8e6bae",
        "parentId" : "a8908b95-1a77-4ce8-ac05-e093a4a12920",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "Thank you @olhotak. These are good theoretical concerns. Indeed, the refactoring blurs the theoretical structure of the analysis.\r\n\r\nI claimed that in essence this PR is the same as master, but I was not clear on why they are the same, and how we arrive at the refactoring. Inspired by your questions above, I think we can see the refactoring in steps, which should answer the questions above:\r\n\r\n**1. Introduce Summary for `Warm`**\r\n\r\nFirst, to enable caching of outers for warn objects (and simplify the logic in `resolveThis`), we would like to store the immediate outers of all super-classes in a map, let's call it _summary_:\r\n\r\n``` Scala\r\ntype Summary = Map[Warm, Objekt]\r\n```\r\n\r\nNote that, in the above we use `Objekt` that caches the fields in addition to the outers. The rationale is, why not go a step further to cache fields as well? This way, `Value.select` can avoid dealing with the low-level `cache` for expressions. And in the future, if class parameters can be non-hot, they can easily be handled by storing them as fields.\r\n\r\nAt this point, we still only have one object in the heap, the _summary_ and _heap_ are two different entities. In essence, it's no different from the master. \r\n\r\n**2. Avoid code duplication**\r\n\r\nAs you insightfully pointed out in https://github.com/lampepfl/dotty/pull/12495#discussion_r634745509, we should avoid the code duplication in `Value.select` and `Value.call` for `ThisRef` and `Warm`.\r\n\r\nAs `Warm` is a key to a map, to unify them, we would make `ThisRef` a key to the same map as well:\r\n\r\n``` Scala\r\ntrait Key extends Value\r\ncase class ThisRef(...) extends Key\r\ncase class Warm(...) extends Key\r\n\r\ntype Summary = Map[Key, Objekt]\r\n```\r\n\r\nTo make sure that the heap only contains one `ThisRef` as key, we remove `ThisRef` from the summary after checking each class. This refactoring would still be the safe as the master.\r\n\r\nBut why bother removing the key from the summary, if the key is never reachable again? So it's fine to keep multiple `ThisRef` keys in the summary -- conceptually we may think the unreachable keys are garbage collected.\r\n\r\nHowever, there is a small semantic difference between `ThisRef` and `Warm`: selecting a missing field in `ThisRef` is an error, while the field should be computed on-demand for `Warm`. That's the only specialized logic we need.\r\n\r\nThis overloading usage of summary is directly inspired by your comment in https://github.com/lampepfl/dotty/pull/12495#discussion_r634745509. Overloading of store-like structures happens not only in engineering, but also exists in theoretical work. For example, in [_Abstracting abstract machines_][aam], it uses `Store` to hold both continuations and closures (Section 2.3).\r\n\r\n[aam]: https://dl.acm.org/doi/10.1145/1863543.1863553\r\n\r\n**3. Renaming**\r\n\r\nAs the summary contains abstract objects: \r\n\r\n- `ThisRef` refers to objects which may have uninitialized fields\r\n- `Warm` refers to objects whose fields are all initialized but may reach objects with empty fields\r\n\r\nWhy not rename `key` as `Addr` and `Summary` as `Heap`, which corresponds concrete semantics? Finishing this step leads to the current PR:\r\n\r\n``` Scala\r\ntrait Addr extends Value\r\ncase class ThisRef(...) extends Addr\r\ncase class Warm(...) extends Addr\r\n\r\ntype Heap = Map[Addr, Objekt]\r\n```\r\n\r\nThis PR also use opaque types for `Heap` instead of type aliases. But such refactoring is cosmetic.\r\n\r\nTo summarize, the refactoring is inspired by your comments in https://github.com/lampepfl/dotty/pull/12495#discussion_r634745509 and benefited a lot from our previous discussions and the insights from the OOPSLA paper (in OOPSLA we do `this` substitution instead of having cache for `Warm`). The refactoring might have made the theoretical structure less clear, but from the engineering perspective, it seems to be a win.",
        "createdAt" : "2021-05-31T18:34:25Z",
        "updatedAt" : "2021-05-31T18:52:38Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "2b47c9b1-7ed0-427e-8f03-2c97960faf7c",
        "parentId" : "a8908b95-1a77-4ce8-ac05-e093a4a12920",
        "authorId" : "ed629d1e-b3d4-4235-b1d2-9b900fd9ee32",
        "body" : "I'll try to explain the fundamental problem. `ThisRef` and `Warm` are abstractions that represent some number of concrete objects. If an `Addr` can represent more than one concrete object, then it is unsound to call `updateField` or `updateOuter` on that `Addr`. I understand that `ThisRef(C)` represents a unique concrete object, so that's fine. But we need to be sure that `Warm(C, outer)` also represents a unique concrete object before we can use it as an `Addr`. This is why I am asking *which* concrete object `Warm(C, outer)` represents.\r\n\r\nMy understanding of `Warm(C, outer)` is that it represents *all* objects of class `C` whose fields have all been assigned and whose `outer` has the given abstract value. If this understanding is correct, then this change introduces unsoundness, because there can be multiple such concrete objects. If this understanding is not correct, then I would like to correct it by identifying the unique concrete object that `Warm(C, outer)` represents.",
        "createdAt" : "2021-05-31T19:11:49Z",
        "updatedAt" : "2021-05-31T19:11:49Z",
        "lastEditedBy" : "ed629d1e-b3d4-4235-b1d2-9b900fd9ee32",
        "tags" : [
        ]
      },
      {
        "id" : "7c1870b9-7c11-4d1d-85c6-558445343917",
        "parentId" : "a8908b95-1a77-4ce8-ac05-e093a4a12920",
        "authorId" : "ed629d1e-b3d4-4235-b1d2-9b900fd9ee32",
        "body" : "Would it be correct to understand that `Warm(C, outer)`, when used as an `Addr` for the `Heap`, does not represent *all* warm objects of class `C`, but only *the* unique object on which we invoke `init` to analyze its constructor, in the case when that object is not hot because its outer is not hot?",
        "createdAt" : "2021-05-31T19:37:51Z",
        "updatedAt" : "2021-05-31T19:37:51Z",
        "lastEditedBy" : "ed629d1e-b3d4-4235-b1d2-9b900fd9ee32",
        "tags" : [
        ]
      },
      {
        "id" : "32c80e83-eee9-44b4-9054-276ad0f2665a",
        "parentId" : "a8908b95-1a77-4ce8-ac05-e093a4a12920",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "> My understanding of Warm(C, outer) is that it represents all objects of class C whose fields have all been assigned and whose outer has the given abstract value. If this understanding is correct, then this change introduces unsoundness, because there can be multiple such concrete objects. If this understanding is not correct, then I would like to correct it by identifying the unique concrete object that Warm(C, outer) represents.\r\n\r\nTo be short, it's not unique and I believe it's sound. I don't think being unique is a necessary requirement in all analyses, and definitely not in our case. One example is type analysis, where we abstract the type of a field by the type of the initializer. Then we reject the program if later a value of a different type is assigned to the field.\r\n\r\nThe same holds for our analysis, the field abstractions cannot be changed by mutation, and it's uniquely determined by the specific value of `Warm`. The `updateField` and `updateOuter` are in essence cache operations --- the same values can be computed with `eval` or fetched from the low-level expression-based cache. All those values are determined by a specific choice of `Warm`. As all objects that are abstracted by the same `Warm` have the same abstract field values, it is safe to compute, cache, and reuse them. \r\n\r\nFrom anther perspective, this analysis is equivalent to the OOPSLA type-and-effect system (but with better engineering qualities). Any unsoundness example will in turn be a counter-example to the OOPSLA paper.",
        "createdAt" : "2021-05-31T19:53:51Z",
        "updatedAt" : "2021-05-31T19:53:51Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "c55b55e3-d12a-4c88-b4ed-882d976facde",
        "parentId" : "a8908b95-1a77-4ce8-ac05-e093a4a12920",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "> Would it be correct to understand that `Warm(C, outer)`, when used as an `Addr` for the `Heap`, does not represent _all_ warm objects of class `C`, but only _the_ unique object on which we invoke `init` to analyze its constructor, in the case when that object is not hot because its outer is not hot?\r\n\r\n`Warm(C, outer)` is an abstraction for all objects of `C` with the same `outer` at a specific time point during execution of the program. For example, given the following program:\r\n\r\n```Scala\r\nclass C {\r\n    class B() { ... }\r\n    val a = new B\r\n    val b = new B\r\n    // here\r\n}\r\n```\r\n\r\nThere are at least two objects above abstracted by `Warm(C, ThisRef(C))` after field `b`. The reason why we can abstract with the same warm value is that they are indistinguishable in the abstract domain --- all field values and outers agree.",
        "createdAt" : "2021-05-31T20:04:28Z",
        "updatedAt" : "2021-05-31T20:04:29Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "2fe3ccd2-d552-4f56-9fb4-16ab6e76dbdc",
        "parentId" : "a8908b95-1a77-4ce8-ac05-e093a4a12920",
        "authorId" : "ed629d1e-b3d4-4235-b1d2-9b900fd9ee32",
        "body" : "Based on the discussion above, would it be correct to state the following invariants?\r\n\r\n1. The analysis never queries `heap(ThisRef(D))` where `D` is any class other than the class on which `init` was launched. Although the `heap` may contain such `ThisRef`s, they are stale and it would be an error to ask about them.\r\n2. The analysis never queries `heap(ThisRef(C)).outers`. It would be an error to do so.\r\n3. `heap(Warm(C,outer)).field(s) == eval(s.defTree.rhs, Warm(C, outer), C)`\r\n4. `heap(Warm(C,outer)).outers(D) == outerValue(?, Warm(C, outer), D, ?)`\r\n\r\nIn other words, `heap(ThisRef(C))` maintains the state of the object on which `init` was launched, but `heap(Warm)` is only a cache of `eval` and `outerValue`.\r\n\r\nIn that case, 3 and 4 are non-trivial results and should have at least some informal proof (not necessarily in the code, of course, but if these are lemmas to be proven externally, they should at least be stated in comments in the code). In particular, are 3 and 4 preserved if `outer` is `Warm` but we then to early promotion of it?\r\n\r\nIt would also be helpful to list, somewhere, what all the possible values of `outer` in a `Warm` are. Are all `Value`s possible, or only `Warm` and `ThisRef(C)` where `C` is the class on which `init` was launched?",
        "createdAt" : "2021-05-31T21:09:58Z",
        "updatedAt" : "2021-05-31T21:09:58Z",
        "lastEditedBy" : "ed629d1e-b3d4-4235-b1d2-9b900fd9ee32",
        "tags" : [
        ]
      },
      {
        "id" : "18e4b4de-0e36-4072-8c3c-ab0c3c759a3c",
        "parentId" : "a8908b95-1a77-4ce8-ac05-e093a4a12920",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "> 1. The analysis never queries heap(ThisRef(D)) where D is any class other than the class on which init was launched. Although the heap may contain such ThisRefs, they are stale and it would be an error to ask about them.\r\n\r\nYes, this is correct.\r\n\r\n> 2. The analysis never queries heap(ThisRef(C)).outers. It would be an error to do so.\r\n\r\nThere is flexibility here: either we handle outers for `ThisRef` uniformly as `Warm`, in spite of knowing that they can only   be `Hot`. Or, in `resolveThis`, we have a special case for `ThisRef`. Both works well. Current PR uses the latter. But for uniformity, it's better to do the former.\r\n\r\n> 3. heap(Warm(C,outer)).field(s) == eval(s.defTree.rhs, Warm(C, outer), C)\r\n\r\nYes, that's how we compute the value for fields of warm objects -- the place where we call `updateField`. Thus it holds by construction.\r\n\r\n> 4. heap(Warm(C,outer)).outers(D) == outerValue(?, Warm(C, outer), D, ?)\r\n\r\nYes, that's how we compute the outers for warm objects  -- the place where we call `updateOuter`. Thus it holds by construction.\r\n\r\n> In other words, heap(ThisRef(C)) maintains the state of the object on which init was launched, but heap(Warm) is only a cache of eval and outerValue.\r\n\r\nYes, that's correct. But `heap(ThisRef(C))` can also be regarded as a cache of the abstract values for the fields, so that later access does not need re-computation.\r\n\r\n> In particular, are 3 and 4 preserved if outer is Warm but we then to early promotion of it?\r\n\r\n3 and 4 hold by construction, thus they are not affected by early promotion. Early promotion does not change summaries for `Warm`.\r\n\r\n> It would also be helpful to list, somewhere, what all the possible values of outer in a Warm are. Are all Values possible, or only Warm and ThisRef(C) where C is the class on which init was launched?\r\n\r\nThat's a good suggestion to improve the documentation of `Warm`. The implicit invariant here is that the `outer` can only be `RefSet`, `Warm` and `Cold`. It should not be `Hot` nor `Fun`.\r\n",
        "createdAt" : "2021-05-31T21:33:55Z",
        "updatedAt" : "2021-05-31T21:33:55Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "79a401c9-8df1-4cec-930b-7f85c7e355a0",
        "parentId" : "a8908b95-1a77-4ce8-ac05-e093a4a12920",
        "authorId" : "ed629d1e-b3d4-4235-b1d2-9b900fd9ee32",
        "body" : "For invariants 3 and 4, the concern is not that the summary (the LHS of the invariant) would change, but that the result of `eval` and `outerValue` (the RHS of the invariant) could change after a change to the fields of the object on which `init` was launched. Specifically, what if the `rhs` of a field of an inner class depends somehow on the outer class, so evaluating the `rhs` changes after the outer class becomes more initialized?\r\n\r\nFor invariant 3, since `eval` already uses `cache`, why do we need to cache its result again in `heap`?",
        "createdAt" : "2021-05-31T21:55:46Z",
        "updatedAt" : "2021-05-31T21:55:46Z",
        "lastEditedBy" : "ed629d1e-b3d4-4235-b1d2-9b900fd9ee32",
        "tags" : [
        ]
      },
      {
        "id" : "a1468caf-edcb-4167-a901-b994bd182dbe",
        "parentId" : "a8908b95-1a77-4ce8-ac05-e093a4a12920",
        "authorId" : "ed629d1e-b3d4-4235-b1d2-9b900fd9ee32",
        "body" : "I guess what's confusing me is that the behaviour of `eval` depends on how many fields are in `heap(ThisRef(C)).fields`, but it presumably should not depend on how many fields are in `heap(Warm(C,outer)).fields` or on `heap(???).outers`. Understanding the inputs that `eval` depends on is important to understanding how the analysis works. The confusion is that things that `eval` does and does not depend on are mixed together in `heap`.",
        "createdAt" : "2021-05-31T23:13:50Z",
        "updatedAt" : "2021-05-31T23:13:50Z",
        "lastEditedBy" : "ed629d1e-b3d4-4235-b1d2-9b900fd9ee32",
        "tags" : [
        ]
      },
      {
        "id" : "c6b7c97a-03d7-4c1e-a2c8-b56b3e1f2df1",
        "parentId" : "a8908b95-1a77-4ce8-ac05-e093a4a12920",
        "authorId" : "ed629d1e-b3d4-4235-b1d2-9b900fd9ee32",
        "body" : "``` Scala\r\nclass C {\r\n    class Base { def m: C }\r\n    class MIsCold extends Base { def m = C.this }\r\n    class MIsHot extends Base { def m = new C }\r\n    class B(base: Base) { val field = base.m }\r\n    val a = new B(new MIsHot)\r\n    val b = new B(new MIsCold)\r\n    // here\r\n    leak(a.field)\r\n    leak(b.field)\r\n    val c = ???\r\n}\r\n```\r\n\r\nAt `// here`, what is `heap(Warm(B,ThisRef(C))).fields(field)`? For `a` it should be `Hot` but for `b` it should be `Cold`, shouldn't it?",
        "createdAt" : "2021-06-01T00:19:55Z",
        "updatedAt" : "2021-06-01T00:19:55Z",
        "lastEditedBy" : "ed629d1e-b3d4-4235-b1d2-9b900fd9ee32",
        "tags" : [
        ]
      },
      {
        "id" : "281a5536-6fca-4d22-8bbd-87ff05ac592a",
        "parentId" : "a8908b95-1a77-4ce8-ac05-e093a4a12920",
        "authorId" : "ed629d1e-b3d4-4235-b1d2-9b900fd9ee32",
        "body" : "Or is it the case that although the type declaration makes `fields` and `outers` mutable for all `Addr` in the heap, we\r\n1. mutate them only during the execution of `init`, and\r\n2. during the execution of `init(thisV = addr)` we mutate only `heap(addr)`, and not the heap of any other addresses.\r\nThen after `init(thisV = addr)` finishes, `heap(addr)` is never mutated anymore. We use it only in a read-only manner to determine what the state was at the end of the constructor of the object represented by `addr`.\r\n\r\nIs that right?",
        "createdAt" : "2021-06-01T01:52:44Z",
        "updatedAt" : "2021-06-01T01:52:45Z",
        "lastEditedBy" : "ed629d1e-b3d4-4235-b1d2-9b900fd9ee32",
        "tags" : [
        ]
      },
      {
        "id" : "df9ed5ab-6725-47f2-80f8-11b531ded12f",
        "parentId" : "a8908b95-1a77-4ce8-ac05-e093a4a12920",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "> For invariants 3 and 4, the concern is not that the summary (the LHS of the invariant) would change, but that the result of `eval` and `outerValue` (the RHS of the invariant) could change after a change to the fields of the object on which `init` was launched. Specifically, what if the `rhs` of a field of an inner class depends somehow on the outer class, so evaluating the `rhs` changes after the outer class becomes more initialized?\r\n\r\nThis relies on a fundamental idea of the analysis: the changes in the heap don't have any impact on the result of `eval` --- the result of an expression only depends on `thisV` (and `Env` once we have the extension). That's why we can do cache for expressions without having `heap` as part of the key.\r\n\r\nThat's also the idea in the type-and-effect system where we can create summaries for fields and methods without caring about how many fields are initialized.\r\n\r\n> \r\n> For invariant 3, since `eval` already uses `cache`, why do we need to cache its result again in `heap`?\r\n\r\nThe reason is a bit hidden in the long comment, the reason is uniformity for engineering benefits, and support future extension to non-hot class parameters:\r\n\r\n\"Note that, in the above we use Objekt that caches the fields in addition to the outers. The rationale is, why not go a step further to cache fields as well? This way, Value.select can avoid dealing with the low-level cache for expressions. And in the future, if class parameters can be non-hot, they can easily be handled by storing them as fields.\"\r\n\r\n\r\n",
        "createdAt" : "2021-06-01T08:21:38Z",
        "updatedAt" : "2021-06-01T08:21:38Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "5d84355b-ec1b-44cc-9335-e374473a3a8a",
        "parentId" : "a8908b95-1a77-4ce8-ac05-e093a4a12920",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "> I guess what's confusing me is that the behaviour of eval depends on how many fields are in heap(ThisRef(C)).fields, but it presumably should not depend on how many fields are in heap(Warm(C,outer)).fields or on heap(???).outers. Understanding the inputs that eval depends on is important to understanding how the analysis works. The confusion is that things that eval does and does not depend on are mixed together in heap.\r\n\r\nStrictly speaking, the result of `eval` does not depend on the heap for a given valid program, neither `heap(ThisRef(C))` nor `heap(Warm(C,outer))`. Otherwise, the cache has to make the heap part of the key --- which is one of the most important design insights. Similarly, in the type-and-effect system, the summary for an expression does not care about the initialization state of `this`.",
        "createdAt" : "2021-06-01T08:30:25Z",
        "updatedAt" : "2021-06-01T08:30:26Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "50c5dc26-6ac6-463b-9315-8991f846176a",
        "parentId" : "a8908b95-1a77-4ce8-ac05-e093a4a12920",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "> ```scala\r\n> class C {\r\n>     class Base { def m: C }\r\n>     class MIsCold extends Base { def m = C.this }\r\n>     class MIsHot extends Base { def m = new C }\r\n>     class B(base: Base) { val field = base.m }\r\n>     val a = new B(new MIsHot)\r\n>     val b = new B(new MIsCold)\r\n>     // here\r\n>     leak(a.field)\r\n>     leak(b.field)\r\n>     val c = ???\r\n> }\r\n> ```\r\n> \r\n> At `// here`, what is `heap(Warm(B,ThisRef(C))).fields(field)`? For `a` it should be `Hot` but for `b` it should be `Cold`, shouldn't it?\r\n\r\nThis depends on what abstract domains we are working on. In the current abstract domain, all class parameters must be hot, thus the abstraction for `field` is always `Hot`.\r\n\r\nOnce we extend the domain to allow non-hot class parameters:\r\n\r\n```Scala\r\ncase class Warm(klass: ClassSymbol, outer: Value, ctor: Symbol, args: List[Value]) extends Addr\r\n```\r\n\r\nThen the abstraction for `field` is dependent on the abstract value of `args`. Here we need to widen `args` the same way as we widen `outer` to finitize the addresses to ensure termination, good performance, and usability.",
        "createdAt" : "2021-06-01T08:37:23Z",
        "updatedAt" : "2021-06-01T08:37:57Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "c9e47e75-bbdb-4609-9d4a-0666972e456f",
        "parentId" : "a8908b95-1a77-4ce8-ac05-e093a4a12920",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "> Or is it the case that although the type declaration makes `fields` and `outers` mutable for all `Addr` in the heap, we\r\n> \r\n> 1. mutate them only during the execution of `init`, and\r\n\r\nYes, that's the only place where `updateOuter` and `updateField` is called. And because of the opaque types, they cannot be accidentally mutated.\r\n\r\n> 2. during the execution of `init(thisV = addr)` we mutate only `heap(addr)`, and not the heap of any other addresses.\r\n>    Then after `init(thisV = addr)` finishes, `heap(addr)` is never mutated anymore. We use it only in a read-only manner to determine what the state was at the end of the constructor of the object represented by `addr`.\r\n> \r\n\r\nYes, that's correct. It's in that sense it's equivalent to the type-and-effect system. In particular, in an assignment, we don't update the heap. This makes it different from typical analysis, where we do a union on the heap for assignment.\r\n",
        "createdAt" : "2021-06-01T08:42:27Z",
        "updatedAt" : "2021-06-01T08:42:28Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "8aa0db81-be5c-4390-8922-1cca3b7fea14",
        "parentId" : "a8908b95-1a77-4ce8-ac05-e093a4a12920",
        "authorId" : "ed629d1e-b3d4-4235-b1d2-9b900fd9ee32",
        "body" : "> This relies on a fundamental idea of the analysis: the changes in the heap don't have any impact on the result of `eval` --- the result of an expression only depends on `thisV` (and `Env` once we have the extension). That's why we can do cache for expressions without having `heap` as part of the key.\r\n\r\nI don't understand this point. `eval` calls `Value.select` on values other than `thisV`, and `select` calls `heap(value).fields`.",
        "createdAt" : "2021-06-01T13:02:25Z",
        "updatedAt" : "2021-06-01T13:02:25Z",
        "lastEditedBy" : "ed629d1e-b3d4-4235-b1d2-9b900fd9ee32",
        "tags" : [
        ]
      },
      {
        "id" : "10fb9a66-dd2a-4b22-9902-8f7a7659497f",
        "parentId" : "a8908b95-1a77-4ce8-ac05-e093a4a12920",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "I was not clear, by `thisV` I mean the value for `this`, not `ThisRef`.",
        "createdAt" : "2021-06-01T13:05:52Z",
        "updatedAt" : "2021-06-01T13:05:52Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "08631f6e-8d8b-4737-aa7b-bdef3ab2efdb",
        "parentId" : "a8908b95-1a77-4ce8-ac05-e093a4a12920",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "Note that all the values stored in the heap depend on `thisV`, so the heap is just a cache or summary.",
        "createdAt" : "2021-06-01T13:11:54Z",
        "updatedAt" : "2021-06-01T13:11:54Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      }
    ],
    "commit" : "9527eac60c70f96b62c362acbb957cbdc7758410",
    "line" : 54,
    "diffHunk" : "@@ -1,1 +105,109 @@   *\n   */\n  object Heap {\n    opaque type Heap = mutable.Map[Addr, Objekt]\n"
  },
  {
    "id" : "867a9449-7e64-4aea-87ab-189b6ce6a17d",
    "prId" : 12608,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/12608#pullrequestreview-673389131",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e665ea85-2720-450a-b22e-f9e361e3e43d",
        "parentId" : null,
        "authorId" : "ed629d1e-b3d4-4235-b1d2-9b900fd9ee32",
        "body" : "This changed from `target.owner.asClass` to `target.owner.enclosingClass.asClass`. Is that intended?",
        "createdAt" : "2021-06-01T16:08:30Z",
        "updatedAt" : "2021-06-01T16:23:36Z",
        "lastEditedBy" : "ed629d1e-b3d4-4235-b1d2-9b900fd9ee32",
        "tags" : [
        ]
      },
      {
        "id" : "a68a59dc-d076-44dc-a2b4-df1683862ca1",
        "parentId" : "e665ea85-2720-450a-b22e-f9e361e3e43d",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "Yes, it's intentional -- here we reuse the code for calling local methods.\r\n\r\nThe related code change can be found below for `case id: Ident =>`.",
        "createdAt" : "2021-06-01T17:16:18Z",
        "updatedAt" : "2021-06-01T17:16:19Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      }
    ],
    "commit" : "9527eac60c70f96b62c362acbb957cbdc7758410",
    "line" : 225,
    "diffHunk" : "@@ -1,1 +321,325 @@          if target.isOneOf(Flags.Method | Flags.Lazy) then\n            if target.hasSource then\n              val cls = target.owner.enclosingClass.asClass\n              if target.isPrimaryConstructor then\n                val tpl = cls.defTree.asInstanceOf[TypeDef].rhs.asInstanceOf[Template]"
  },
  {
    "id" : "23cdbd3c-644b-4f96-9d1e-71ec149fad34",
    "prId" : 12608,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/12608#pullrequestreview-673387387",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3ea77874-4d76-436e-bc3c-f2efd2cd507b",
        "parentId" : null,
        "authorId" : "ed629d1e-b3d4-4235-b1d2-9b900fd9ee32",
        "body" : "Will this `Objekt` continue to have empty `fields` and `outers` forever since we never call `init` on the new `value`?",
        "createdAt" : "2021-06-01T16:14:13Z",
        "updatedAt" : "2021-06-01T16:23:36Z",
        "lastEditedBy" : "ed629d1e-b3d4-4235-b1d2-9b900fd9ee32",
        "tags" : [
        ]
      },
      {
        "id" : "287258e5-442b-4228-8bbe-e97403df7b93",
        "parentId" : "3ea77874-4d76-436e-bc3c-f2efd2cd507b",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "The call happens at line 367 -- it's a constructor call on the object.",
        "createdAt" : "2021-06-01T17:14:19Z",
        "updatedAt" : "2021-06-01T17:14:20Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      }
    ],
    "commit" : "9527eac60c70f96b62c362acbb957cbdc7758410",
    "line" : 299,
    "diffHunk" : "@@ -1,1 +370,374 @@          val value = Warm(klass, outer)\n          if !heap.contains(value) then\n            val obj = Objekt(klass, fields = mutable.Map.empty, outers = mutable.Map(klass -> outer))\n            heap.update(value, obj)\n          val res = value.call(ctor, superType = NoType, source)"
  },
  {
    "id" : "98ec9f00-f0b7-4ce4-836d-75e89add5803",
    "prId" : 12495,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/12495#pullrequestreview-662530142",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6599dfe5-c852-4b8b-a91d-7589a2bf5298",
        "parentId" : null,
        "authorId" : "ed629d1e-b3d4-4235-b1d2-9b900fd9ee32",
        "body" : "I would like more visual separation (comments) here so people don't accidentally think that `Object extends Value`.",
        "createdAt" : "2021-05-18T20:44:50Z",
        "updatedAt" : "2021-05-18T22:21:53Z",
        "lastEditedBy" : "ed629d1e-b3d4-4235-b1d2-9b900fd9ee32",
        "tags" : [
        ]
      }
    ],
    "commit" : "12bfbd27637d381f8860fcaf804dd8c2859bfa49",
    "line" : 89,
    "diffHunk" : "@@ -1,1 +87,91 @@  // end of value definition\n\n  /** The current object under initialization\n   *\n   *  Note: Object is NOT a value."
  },
  {
    "id" : "62c97dea-ddb2-4119-a73e-c875b02ac766",
    "prId" : 12495,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/12495#pullrequestreview-662801112",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8d3c0e7e-30d9-4a98-8dd8-e69f4be2fcd0",
        "parentId" : null,
        "authorId" : "ed629d1e-b3d4-4235-b1d2-9b900fd9ee32",
        "body" : "consider moving earlier, closer to definition of `Value`",
        "createdAt" : "2021-05-18T20:49:07Z",
        "updatedAt" : "2021-05-18T22:21:53Z",
        "lastEditedBy" : "ed629d1e-b3d4-4235-b1d2-9b900fd9ee32",
        "tags" : [
        ]
      },
      {
        "id" : "1532d89a-ae3b-488e-b060-14990cfe8fc2",
        "parentId" : "8d3c0e7e-30d9-4a98-8dd8-e69f4be2fcd0",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "I feel it's better to group all domain operations in one section --- in IDEs, it's possible to fold/collapse the whole section. Putting them in the domains section (or directly in value classes) would make it hard to read at a glance what are the domaims.",
        "createdAt" : "2021-05-19T06:16:25Z",
        "updatedAt" : "2021-05-19T06:16:25Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      }
    ],
    "commit" : "12bfbd27637d381f8860fcaf804dd8c2859bfa49",
    "line" : 175,
    "diffHunk" : "@@ -1,1 +173,177 @@// ----- Operations on domains -----------------------------\n  extension (a: Value)\n    def join(b: Value): Value =\n      (a, b) match\n      case (Hot, _)  => b"
  },
  {
    "id" : "c8d50c2e-d145-4d3a-addc-5242651a1138",
    "prId" : 12495,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/12495#pullrequestreview-665140815",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ee72a5ed-bac2-4762-aece-6a260d0db0b4",
        "parentId" : null,
        "authorId" : "ed629d1e-b3d4-4235-b1d2-9b900fd9ee32",
        "body" : "Are there cases where `Warm join ThisRef` should be just `Warm`?",
        "createdAt" : "2021-05-18T20:50:44Z",
        "updatedAt" : "2021-05-18T22:21:53Z",
        "lastEditedBy" : "ed629d1e-b3d4-4235-b1d2-9b900fd9ee32",
        "tags" : [
        ]
      },
      {
        "id" : "4c07ff64-2e09-42f9-8d99-a6efb9c45733",
        "parentId" : "ee72a5ed-bac2-4762-aece-6a260d0db0b4",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "Yes, we have `Warm(C, outer).join(ThisRef(C)) = ThisRef(C)`. ",
        "createdAt" : "2021-05-19T06:19:18Z",
        "updatedAt" : "2021-05-19T06:19:18Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "c7ca45d5-667b-49d7-ba6d-91a2dc4012ad",
        "parentId" : "ee72a5ed-bac2-4762-aece-6a260d0db0b4",
        "authorId" : "57665b8e-1ae2-4f2e-8825-5012c5c07ccc",
        "body" : "According to the code, Warm join ThisRef can only be ThisRef or RefSet, right?",
        "createdAt" : "2021-05-20T19:55:01Z",
        "updatedAt" : "2021-05-20T19:55:01Z",
        "lastEditedBy" : "57665b8e-1ae2-4f2e-8825-5012c5c07ccc",
        "tags" : [
        ]
      },
      {
        "id" : "5d6fe481-a564-4c58-b63c-1a61a2b0287e",
        "parentId" : "ee72a5ed-bac2-4762-aece-6a260d0db0b4",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "Yes, that's correct.",
        "createdAt" : "2021-05-21T06:51:48Z",
        "updatedAt" : "2021-05-21T06:56:58Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      }
    ],
    "commit" : "12bfbd27637d381f8860fcaf804dd8c2859bfa49",
    "line" : 186,
    "diffHunk" : "@@ -1,1 +184,188 @@      case (a: ThisRef, b: Warm) if a.klass == b.klass => a\n\n      case (a: (Fun | Warm | ThisRef), b: (Fun | Warm | ThisRef)) => RefSet(a :: b :: Nil)\n\n      case (a: (Fun | Warm | ThisRef), RefSet(refs))    => RefSet(a :: refs)"
  },
  {
    "id" : "75ea26c7-c856-426c-a9ce-ac310c6b8c5d",
    "prId" : 12495,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/12495#pullrequestreview-662530142",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2d80ff6a-b4df-426f-907c-13b7e95e6c32",
        "parentId" : null,
        "authorId" : "ed629d1e-b3d4-4235-b1d2-9b900fd9ee32",
        "body" : "Modify error message of `CallUnknown` to consider that it could be a field access, not only a method call.",
        "createdAt" : "2021-05-18T20:55:17Z",
        "updatedAt" : "2021-05-18T22:21:53Z",
        "lastEditedBy" : "ed629d1e-b3d4-4235-b1d2-9b900fd9ee32",
        "tags" : [
        ]
      }
    ],
    "commit" : "12bfbd27637d381f8860fcaf804dd8c2859bfa49",
    "line" : 223,
    "diffHunk" : "@@ -1,1 +221,225 @@            eval(rhs, warm, target.owner.asClass, cacheResult = true)\n          else\n            val error = CallUnknown(field, source, trace)\n            Result(Hot, error :: Nil)\n"
  },
  {
    "id" : "78c8cc69-7345-4c66-a9ce-cbbf20543e4e",
    "prId" : 12495,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/12495#pullrequestreview-662810606",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "052543a3-6aec-4c04-9c5a-e52a8db0635d",
        "parentId" : null,
        "authorId" : "ed629d1e-b3d4-4235-b1d2-9b900fd9ee32",
        "body" : "There is some code duplication between `case ThisRef` and `case Warm`.",
        "createdAt" : "2021-05-18T21:01:55Z",
        "updatedAt" : "2021-05-18T22:21:53Z",
        "lastEditedBy" : "ed629d1e-b3d4-4235-b1d2-9b900fd9ee32",
        "tags" : [
        ]
      },
      {
        "id" : "4c93e006-47b6-4f80-88a3-751b7cf0b71a",
        "parentId" : "052543a3-6aec-4c04-9c5a-e52a8db0635d",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "Yes, I think there's room to improve this. We could re-introduce addresses to unify them: for `Warm` addresses, if a field access does not exist in the heap object, load it lazily.\r\n\r\nI'd like to leave the refactoring to another PR so that we can have a version where domains are very simple.",
        "createdAt" : "2021-05-19T06:33:01Z",
        "updatedAt" : "2021-05-19T07:00:45Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      }
    ],
    "commit" : "12bfbd27637d381f8860fcaf804dd8c2859bfa49",
    "line" : 271,
    "diffHunk" : "@@ -1,1 +269,273 @@            Result(Hot, error :: Nil)\n\n        case warm: Warm =>\n          val target =\n            if superType.exists then"
  },
  {
    "id" : "6ed31853-d5fc-42ba-a73d-b53e65198c57",
    "prId" : 12495,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/12495#pullrequestreview-665140815",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d1ff6aae-0070-4566-91bf-40a12f170c05",
        "parentId" : null,
        "authorId" : "ed629d1e-b3d4-4235-b1d2-9b900fd9ee32",
        "body" : "I'm not clear on the difference between `instantiate` and `call` a constructor. Comment(s) would help.",
        "createdAt" : "2021-05-18T21:05:56Z",
        "updatedAt" : "2021-05-18T22:21:53Z",
        "lastEditedBy" : "ed629d1e-b3d4-4235-b1d2-9b900fd9ee32",
        "tags" : [
        ]
      },
      {
        "id" : "5960f1fc-0f7b-4180-b2a4-e32dcce16bc2",
        "parentId" : "d1ff6aae-0070-4566-91bf-40a12f170c05",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "`instantiate` is called on the prefix `p` of a new expression `new p.C`: this is the place where we create objects.\r\n\r\nConstructor calls only initialize existing objects.",
        "createdAt" : "2021-05-19T06:35:26Z",
        "updatedAt" : "2021-05-19T07:00:46Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "a0183148-c3a3-4987-b581-66eb7afbbad5",
        "parentId" : "d1ff6aae-0070-4566-91bf-40a12f170c05",
        "authorId" : "ed629d1e-b3d4-4235-b1d2-9b900fd9ee32",
        "body" : "OK, please add comment:\r\n// call on prefix p of a new expression new p.C",
        "createdAt" : "2021-05-20T15:22:02Z",
        "updatedAt" : "2021-05-20T15:25:34Z",
        "lastEditedBy" : "ed629d1e-b3d4-4235-b1d2-9b900fd9ee32",
        "tags" : [
        ]
      },
      {
        "id" : "be541a5c-b6a2-4e49-8e93-cddf20e892ef",
        "parentId" : "d1ff6aae-0070-4566-91bf-40a12f170c05",
        "authorId" : "57665b8e-1ae2-4f2e-8825-5012c5c07ccc",
        "body" : "Why do we need to consider \"tupled\" specifically in line 281? Are there any other corner cases for Fun?",
        "createdAt" : "2021-05-20T20:15:46Z",
        "updatedAt" : "2021-05-20T20:15:46Z",
        "lastEditedBy" : "57665b8e-1ae2-4f2e-8825-5012c5c07ccc",
        "tags" : [
        ]
      },
      {
        "id" : "a0bf051d-7273-4c4a-a490-eb41606369d6",
        "parentId" : "d1ff6aae-0070-4566-91bf-40a12f170c05",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "`tupled` is a method defined on functions. We want to be faithful to its semantics. We could support more, but we can do that later.",
        "createdAt" : "2021-05-21T06:54:59Z",
        "updatedAt" : "2021-05-21T06:56:58Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      }
    ],
    "commit" : "12bfbd27637d381f8860fcaf804dd8c2859bfa49",
    "line" : 306,
    "diffHunk" : "@@ -1,1 +304,308 @@\n    /** Handle a new expression `new p.C` where `p` is abstracted by `value` */\n    def instantiate(klass: ClassSymbol, ctor: Symbol, source: Tree): Contextual[Result] =\n      value match {\n        case Hot  =>"
  },
  {
    "id" : "61a281da-e625-4ed6-aa96-ca3d291c64da",
    "prId" : 12495,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/12495#pullrequestreview-662530142",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e06b875e-10ec-4b30-88d4-fb4afa02f9e5",
        "parentId" : null,
        "authorId" : "ed629d1e-b3d4-4235-b1d2-9b900fd9ee32",
        "body" : "Include nested classes condition in comment.",
        "createdAt" : "2021-05-18T21:31:24Z",
        "updatedAt" : "2021-05-18T22:21:53Z",
        "lastEditedBy" : "ed629d1e-b3d4-4235-b1d2-9b900fd9ee32",
        "tags" : [
        ]
      }
    ],
    "commit" : "12bfbd27637d381f8860fcaf804dd8c2859bfa49",
    "line" : 435,
    "diffHunk" : "@@ -1,1 +433,437 @@     *  2. for each concrete field `f` of the warm object:\n     *     promote the field value\n     *\n     *  If the object contains nested classes as members, the checker simply\n     *  reports a warning to avoid expensive checks."
  },
  {
    "id" : "10744f81-0079-4eab-9ae8-5e7adae76b58",
    "prId" : 12495,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/12495#pullrequestreview-662810606",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "628e3f38-a418-426d-92b1-b159a10b82e1",
        "parentId" : null,
        "authorId" : "ed629d1e-b3d4-4235-b1d2-9b900fd9ee32",
        "body" : "Consider `foreach` instead of `exists`.",
        "createdAt" : "2021-05-18T21:33:14Z",
        "updatedAt" : "2021-05-18T22:21:53Z",
        "lastEditedBy" : "ed629d1e-b3d4-4235-b1d2-9b900fd9ee32",
        "tags" : [
        ]
      },
      {
        "id" : "c2439349-ca38-4987-9af7-d48c3e503a66",
        "parentId" : "628e3f38-a418-426d-92b1-b159a10b82e1",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "Here the intention is to stop expensive computing if errors are found already.",
        "createdAt" : "2021-05-19T06:38:50Z",
        "updatedAt" : "2021-05-19T07:00:46Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      }
    ],
    "commit" : "12bfbd27637d381f8860fcaf804dd8c2859bfa49",
    "line" : 452,
    "diffHunk" : "@@ -1,1 +450,454 @@      val buffer  = new mutable.ArrayBuffer[Error]\n\n      fields.exists { denot =>\n        val f = denot.symbol\n        if !f.isOneOf(Flags.Deferred | Flags.Private | Flags.Protected) && f.hasSource then"
  },
  {
    "id" : "ca4378c2-238b-4f01-beff-eea79dac0205",
    "prId" : 12495,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/12495#pullrequestreview-662810606",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e0c7c21d-af3f-4b07-8b47-52113b0425c1",
        "parentId" : null,
        "authorId" : "ed629d1e-b3d4-4235-b1d2-9b900fd9ee32",
        "body" : "Consider `if` instead of `||`, `foreach` instead of `exists`.",
        "createdAt" : "2021-05-18T21:33:48Z",
        "updatedAt" : "2021-05-18T22:21:53Z",
        "lastEditedBy" : "ed629d1e-b3d4-4235-b1d2-9b900fd9ee32",
        "tags" : [
        ]
      },
      {
        "id" : "1ed8cc72-126e-4ecf-b3e3-4032f40e552d",
        "parentId" : "e0c7c21d-af3f-4b07-8b47-52113b0425c1",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "Same as above.",
        "createdAt" : "2021-05-19T06:38:58Z",
        "updatedAt" : "2021-05-19T07:00:46Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      }
    ],
    "commit" : "12bfbd27637d381f8860fcaf804dd8c2859bfa49",
    "line" : 460,
    "diffHunk" : "@@ -1,1 +458,462 @@      }\n\n      buffer.nonEmpty || methods.exists { denot =>\n        val m = denot.symbol\n        if !m.isConstructor && m.hasSource then"
  },
  {
    "id" : "c4ef7059-d2ca-4f7d-a7e7-7daa39db3dab",
    "prId" : 12495,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/12495#pullrequestreview-662530142",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4a96230b-cc43-4c16-9cb8-2c3abe67f58f",
        "parentId" : null,
        "authorId" : "ed629d1e-b3d4-4235-b1d2-9b900fd9ee32",
        "body" : "Add comment explaining which class is `klass` and how it relates to the class of which `thisV` is the this ref.",
        "createdAt" : "2021-05-18T21:35:55Z",
        "updatedAt" : "2021-05-18T22:21:53Z",
        "lastEditedBy" : "ed629d1e-b3d4-4235-b1d2-9b900fd9ee32",
        "tags" : [
        ]
      }
    ],
    "commit" : "12bfbd27637d381f8860fcaf804dd8c2859bfa49",
    "line" : 503,
    "diffHunk" : "@@ -1,1 +501,505 @@   *  This method only handles cache logic and delegates the work to `cases`.\n   */\n  def eval(expr: Tree, thisV: Value, klass: ClassSymbol, cacheResult: Boolean = false): Contextual[Result] = log(\"evaluating \" + expr.show + \", this = \" + thisV.show, printer, res => res.asInstanceOf[Result].show) {\n    val innerMap = cache.getOrElseUpdate(thisV, new EqHashMap[Tree, Value])\n    if (innerMap.contains(expr)) Result(innerMap(expr), noErrors)"
  },
  {
    "id" : "538a2d23-78ed-4653-bb1d-01d0769fe4d7",
    "prId" : 12495,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/12495#pullrequestreview-662810606",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "47b78c0b-89da-42bf-9476-87ee495acdae",
        "parentId" : null,
        "authorId" : "ed629d1e-b3d4-4235-b1d2-9b900fd9ee32",
        "body" : "Why can we ignore the body of the local method if `this` is Hot?",
        "createdAt" : "2021-05-18T21:42:38Z",
        "updatedAt" : "2021-05-18T22:21:53Z",
        "lastEditedBy" : "ed629d1e-b3d4-4235-b1d2-9b900fd9ee32",
        "tags" : [
        ]
      },
      {
        "id" : "9042d5f7-126a-4fc8-9087-41c95a54830e",
        "parentId" : "47b78c0b-89da-42bf-9476-87ee495acdae",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "That comes from local reasoning: `thisV2` is the only possibly uninitialized value that `thisV2` can access.",
        "createdAt" : "2021-05-19T06:40:24Z",
        "updatedAt" : "2021-05-19T07:00:46Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      }
    ],
    "commit" : "12bfbd27637d381f8860fcaf804dd8c2859bfa49",
    "line" : 584,
    "diffHunk" : "@@ -1,1 +582,586 @@            val thisValue2 = resolveThis(enclosingClass, thisV, klass, id)\n            thisValue2 match\n            case Hot => Result(Hot, errors)\n            case _ =>\n              val rhs = id.symbol.defTree.asInstanceOf[DefDef].rhs"
  },
  {
    "id" : "71df35b9-6780-4826-bcc3-e0f20a10aaf6",
    "prId" : 12495,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/12495#pullrequestreview-662530142",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "02dde156-eaa9-49c5-85c1-eeaf238bee08",
        "parentId" : null,
        "authorId" : "ed629d1e-b3d4-4235-b1d2-9b900fd9ee32",
        "body" : "Maybe a more specific comment that the path of a path-dependent type must be initialized.",
        "createdAt" : "2021-05-18T21:46:18Z",
        "updatedAt" : "2021-05-18T22:21:54Z",
        "lastEditedBy" : "ed629d1e-b3d4-4235-b1d2-9b900fd9ee32",
        "tags" : [
        ]
      }
    ],
    "commit" : "12bfbd27637d381f8860fcaf804dd8c2859bfa49",
    "line" : 865,
    "diffHunk" : "@@ -1,1 +863,867 @@  /** Check that path in path-dependent types are initialized\n   *\n   *  This is intended to avoid type soundness issues in Dotty.\n   */\n  def checkTermUsage(tpt: Tree, thisV: Value, klass: ClassSymbol): Contextual[List[Error]] ="
  },
  {
    "id" : "6c3601a3-ed2b-499a-aec8-857a9b381113",
    "prId" : 12495,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/12495#pullrequestreview-662810606",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fefae00e-06d3-43a2-b74c-9f446e1b9f67",
        "parentId" : null,
        "authorId" : "ed629d1e-b3d4-4235-b1d2-9b900fd9ee32",
        "body" : "Can this case ever be called for an assignment to a local variable within a method (i.e. `lhs` is not a field but a local variable)?",
        "createdAt" : "2021-05-18T21:48:05Z",
        "updatedAt" : "2021-05-18T22:21:54Z",
        "lastEditedBy" : "ed629d1e-b3d4-4235-b1d2-9b900fd9ee32",
        "tags" : [
        ]
      },
      {
        "id" : "84af80b1-e3ad-4081-8835-ced42f8db9d0",
        "parentId" : "fefae00e-06d3-43a2-b74c-9f446e1b9f67",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "Yes, it can be both field assignment or local variable assignment.",
        "createdAt" : "2021-05-19T06:41:05Z",
        "updatedAt" : "2021-05-19T07:00:46Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      }
    ],
    "commit" : "12bfbd27637d381f8860fcaf804dd8c2859bfa49",
    "line" : 608,
    "diffHunk" : "@@ -1,1 +606,610 @@        eval(arg, thisV, klass)\n\n      case Assign(lhs, rhs) =>\n        lhs match\n        case Select(qual, _) =>"
  },
  {
    "id" : "2a129ae0-96f3-45b3-bdc1-879ebfcc8f6b",
    "prId" : 12495,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/12495#pullrequestreview-662810606",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b8e0b57d-9230-46ae-be47-9ead2f9a6bdc",
        "parentId" : null,
        "authorId" : "ed629d1e-b3d4-4235-b1d2-9b900fd9ee32",
        "body" : "I couldn't follow the logic here.",
        "createdAt" : "2021-05-18T21:58:23Z",
        "updatedAt" : "2021-05-18T22:21:54Z",
        "lastEditedBy" : "ed629d1e-b3d4-4235-b1d2-9b900fd9ee32",
        "tags" : [
        ]
      },
      {
        "id" : "cc7a10bd-555a-453a-9438-b41ede2c2903",
        "parentId" : "b8e0b57d-9230-46ae-be47-9ead2f9a6bdc",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "This is closely related to concrete semantics. In inner class semantics where the outer can only be a stable path, all outers of all classes in the inheritance hierarchy are determined by the unique immediate outer of the concrete class of the object. That's the reason why we can only store one outer in `Warm`.\r\n\r\nIn concrete semantics (without caching of outers), when we see `A.this` in class `B` while `this = C(...)`, we need to compute `A.this` from the base class `C`: what's the prefix used for inheriting `B` -- so we can get the value of the immediate outer of `B`. Then we just recur (go up the nesting classes of `B`) until we reach `A.this`.\r\n\r\nThe abstract semantics should follow the concrete semantics. However, thanks to path-dependent types, the type system already have this logic, so we just take advantage of that here.",
        "createdAt" : "2021-05-19T06:53:10Z",
        "updatedAt" : "2021-05-19T07:00:46Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      }
    ],
    "commit" : "12bfbd27637d381f8860fcaf804dd8c2859bfa49",
    "line" : 754,
    "diffHunk" : "@@ -1,1 +752,756 @@        case Hot | _: ThisRef => Hot\n        case warm: Warm =>\n          // use existing type information as a shortcut\n          val tref = typeRefOf(warm.klass.typeRef.baseType(klass))\n          if tref.prefix == NoPrefix then"
  },
  {
    "id" : "3c3f5ef7-5e4b-4bce-b36a-288ecea3a6a2",
    "prId" : 12495,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/12495#pullrequestreview-662810606",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d95a285c-3e32-487b-9613-646cd7e719ab",
        "parentId" : null,
        "authorId" : "ed629d1e-b3d4-4235-b1d2-9b900fd9ee32",
        "body" : "Is the primary constructor always the one with zero args?",
        "createdAt" : "2021-05-18T22:11:15Z",
        "updatedAt" : "2021-05-18T22:21:54Z",
        "lastEditedBy" : "ed629d1e-b3d4-4235-b1d2-9b900fd9ee32",
        "tags" : [
        ]
      },
      {
        "id" : "af1052c8-9726-4780-8d39-d3ad8498fb8a",
        "parentId" : "d95a285c-3e32-487b-9613-646cd7e719ab",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "According to the language spec,  if the mix trait requires arguments, then the class must provide arguments to it explicitly in the parent list. That means we will encounter it in the `Some` branch.\r\n\r\nWhen a trait `A` extends a parameterized trait `B`, it cannot provide term arguments to `B`. That can only be done in a concrete class.",
        "createdAt" : "2021-05-19T06:57:12Z",
        "updatedAt" : "2021-05-19T07:00:46Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      }
    ],
    "commit" : "12bfbd27637d381f8860fcaf804dd8c2859bfa49",
    "line" : 842,
    "diffHunk" : "@@ -1,1 +840,844 @@          // term arguments to B. That can only be done in a concrete class.\n          val tref = typeRefOf(klass.typeRef.baseType(mixin).typeConstructor)\n          val ctor = tref.classSymbol.primaryConstructor\n          if ctor.exists then superCall(tref, ctor, superParent)\n      }"
  },
  {
    "id" : "c75bb098-c82a-473c-949c-b6f88a780987",
    "prId" : 12495,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/12495#pullrequestreview-662810606",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "88259502-6ba7-41b5-acd4-8a0892e0ca71",
        "parentId" : null,
        "authorId" : "ed629d1e-b3d4-4235-b1d2-9b900fd9ee32",
        "body" : "Is there something like this extractor elsewhere in Dotty for general use? If not, should there be (should this be moved out of init where other code can use it)?",
        "createdAt" : "2021-05-18T22:16:34Z",
        "updatedAt" : "2021-05-18T22:21:54Z",
        "lastEditedBy" : "ed629d1e-b3d4-4235-b1d2-9b900fd9ee32",
        "tags" : [
        ]
      },
      {
        "id" : "7b482ab5-a3e5-4643-b27b-96d0b3a2d8d7",
        "parentId" : "88259502-6ba7-41b5-acd4-8a0892e0ca71",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "The logic here is specific to our analysis, thus it's better to keep it here. The handling of `ByNameArg` is also special to our purpose. In the compiler, we also do the same thing.",
        "createdAt" : "2021-05-19T06:59:29Z",
        "updatedAt" : "2021-05-19T07:00:46Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      }
    ],
    "commit" : "12bfbd27637d381f8860fcaf804dd8c2859bfa49",
    "line" : 900,
    "diffHunk" : "@@ -1,1 +898,902 @@      case ByNameArg(t) => t\n\n  object Call {\n\n    def unapply(tree: Tree)(using Context): Option[(Tree, List[List[Arg]])] ="
  },
  {
    "id" : "2191b5fe-246e-4ba2-8fe1-1dfd9cfa337b",
    "prId" : 12495,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/12495#pullrequestreview-662810606",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d5947f17-6256-48f7-8486-ddc923baa1d9",
        "parentId" : null,
        "authorId" : "ed629d1e-b3d4-4235-b1d2-9b900fd9ee32",
        "body" : "Is there something like this elsewhere in Dotty? Should there be?",
        "createdAt" : "2021-05-18T22:21:17Z",
        "updatedAt" : "2021-05-18T22:21:54Z",
        "lastEditedBy" : "ed629d1e-b3d4-4235-b1d2-9b900fd9ee32",
        "tags" : [
        ]
      },
      {
        "id" : "69c56285-3d52-4bc8-b5bb-8a8b8329f3e8",
        "parentId" : "d5947f17-6256-48f7-8486-ddc923baa1d9",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "There isn't anything similar, so I think it's better to keep it here -- also because they are two important helper methods in the logic of the analysis.",
        "createdAt" : "2021-05-19T07:00:41Z",
        "updatedAt" : "2021-05-19T07:00:46Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      }
    ],
    "commit" : "12bfbd27637d381f8860fcaf804dd8c2859bfa49",
    "line" : 954,
    "diffHunk" : "@@ -1,1 +952,956 @@\n  def resolveSuper(cls: ClassSymbol, superType: Type, sym: Symbol)(using Context): Symbol = {\n    import annotation.tailrec\n    @tailrec def loop(bcs: List[ClassSymbol]): Symbol = bcs match {\n      case bc :: bcs1 =>"
  },
  {
    "id" : "cdedb9e3-86ae-40bb-a803-f476d5997792",
    "prId" : 12495,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/12495#pullrequestreview-665167354",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ce69cb16-c059-4919-b75b-31321d48ff68",
        "parentId" : null,
        "authorId" : "ed629d1e-b3d4-4235-b1d2-9b900fd9ee32",
        "body" : "I like the diagram but I think RefSet should be above ThisRef(C), Warm(D), and Fun (but below Cold).",
        "createdAt" : "2021-05-20T15:20:08Z",
        "updatedAt" : "2021-05-20T15:25:34Z",
        "lastEditedBy" : "ed629d1e-b3d4-4235-b1d2-9b900fd9ee32",
        "tags" : [
        ]
      },
      {
        "id" : "9c1869c1-cbd1-4b59-a8f1-d7a288df8930",
        "parentId" : "ce69cb16-c059-4919-b75b-31321d48ff68",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "Putting `RefSet` above `ThisRef(C)` is also problematic (it might not be a member). In the end, I added more text to explain the ordering with `RefSet`.",
        "createdAt" : "2021-05-21T07:28:29Z",
        "updatedAt" : "2021-05-21T07:28:29Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      }
    ],
    "commit" : "12bfbd27637d381f8860fcaf804dd8c2859bfa49",
    "line" : 57,
    "diffHunk" : "@@ -1,1 +55,59 @@   *         V  R if V  R\n   *\n   */\n  sealed abstract class Value {\n    def show: String = this.toString()"
  },
  {
    "id" : "b2159c57-9dcf-47bb-90fe-7cf0c61cda5a",
    "prId" : 12495,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/12495#pullrequestreview-665140815",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "19ac99f5-be90-4f47-b830-c99619db702b",
        "parentId" : null,
        "authorId" : "57665b8e-1ae2-4f2e-8825-5012c5c07ccc",
        "body" : "Can you explain why we don't evaluate an expression when thisV is cold?",
        "createdAt" : "2021-05-20T20:54:00Z",
        "updatedAt" : "2021-05-20T20:54:00Z",
        "lastEditedBy" : "57665b8e-1ae2-4f2e-8825-5012c5c07ccc",
        "tags" : [
        ]
      },
      {
        "id" : "6dd2bb88-7df3-4b24-a550-19356ea8bf1a",
        "parentId" : "19ac99f5-be90-4f47-b830-c99619db702b",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "That's part of the design of the system -- when we call a method on a cold value, the system reports a warning. That's why this branch cannot be reached.",
        "createdAt" : "2021-05-21T06:56:45Z",
        "updatedAt" : "2021-05-21T06:56:58Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      }
    ],
    "commit" : "12bfbd27637d381f8860fcaf804dd8c2859bfa49",
    "line" : 622,
    "diffHunk" : "@@ -1,1 +620,624 @@          Result(value, Nil)\n        case _ =>\n          // The reason is that we never evaluate an expression if `thisV` is\n          // Cold. And `thisV` can never be `Fun`.\n          report.warning(\"Unexpected branch reached. this = \" + thisV.show, expr.srcPos)"
  }
]
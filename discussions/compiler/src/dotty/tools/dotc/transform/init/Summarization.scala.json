[
  {
    "id" : "ebdb8b4c-a4e3-454a-9f23-461697147c01",
    "prId" : 11716,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/11716#pullrequestreview-614127966",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0c11f944-29dd-4c85-8e69-1c04a72ef0db",
        "parentId" : null,
        "authorId" : "93042d2a-fea3-48fb-8f26-bcce79e4118b",
        "body" : "Is this function calculating the effects of constructing an instance of type `tp`?",
        "createdAt" : "2021-03-17T10:04:51Z",
        "updatedAt" : "2021-03-17T15:09:17Z",
        "lastEditedBy" : "93042d2a-fea3-48fb-8f26-bcce79e4118b",
        "tags" : [
        ]
      },
      {
        "id" : "ae11e61d-b064-4e96-8280-b29c74fff0f8",
        "parentId" : "0c11f944-29dd-4c85-8e69-1c04a72ef0db",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "It's calculating field access effects in types. In Scala we can have types like `p.f.T`, here we summarize the effects for `p.f`.",
        "createdAt" : "2021-03-17T10:12:19Z",
        "updatedAt" : "2021-03-17T15:09:17Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      }
    ],
    "commit" : "ad1aac006c13f437b2941b63cf3fa42cbde4f5a6",
    "line" : 43,
    "diffHunk" : "@@ -1,1 +215,219 @@  }\n\n  private def effectsOfType(tp: Type, source: Tree)(implicit env: Env): Effects =\n    var summary = Summary.empty\n    val traverser = new TypeTraverser {"
  },
  {
    "id" : "b313d47d-82d5-4688-8aa4-217c7e273469",
    "prId" : 11716,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/11716#pullrequestreview-614421202",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5563b655-6691-4c3a-9322-7f4a25072f1e",
        "parentId" : null,
        "authorId" : "ed629d1e-b3d4-4235-b1d2-9b900fd9ee32",
        "body" : "Why do we restrict to SingletonType here as a prefix of the TermRef?\r\n\r\nWhat could the prefix be other than a SingletonType and why is it OK to skip those cases?",
        "createdAt" : "2021-03-17T14:10:16Z",
        "updatedAt" : "2021-03-17T15:09:17Z",
        "lastEditedBy" : "ed629d1e-b3d4-4235-b1d2-9b900fd9ee32",
        "tags" : [
        ]
      },
      {
        "id" : "bcc1dcca-01eb-49f6-8a86-f4ec902e3fd9",
        "parentId" : "5563b655-6691-4c3a-9322-7f4a25072f1e",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "In the community build, the project effpi (which use compiler plugin for session protocol checking) generates types like the following:\r\n\r\n```\r\neffpi.examples.demo.audit.types.Pay#replyTo\r\n```\r\n\r\nThe type looks dubious, but the compiler seems to be fine with it. For such a type, our code will simply recur on the prefix `effpi.examples.demo.audit.types.Pay` and look for term selections recursively.",
        "createdAt" : "2021-03-17T14:20:55Z",
        "updatedAt" : "2021-03-17T15:09:17Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "196e299e-c8fa-4d75-be04-52961e2a61ad",
        "parentId" : "5563b655-6691-4c3a-9322-7f4a25072f1e",
        "authorId" : "ed629d1e-b3d4-4235-b1d2-9b900fd9ee32",
        "body" : "I'm still confused.\r\n\r\nThat type is a TypeRef, right? And we recurse on its prefix below in `case _ => traverseChildren(tp)`, right? What would go wrong if this case was just `case _: TermRef =>` instead of the pattern with the `SingletonType`?",
        "createdAt" : "2021-03-17T14:35:42Z",
        "updatedAt" : "2021-03-17T15:09:17Z",
        "lastEditedBy" : "ed629d1e-b3d4-4235-b1d2-9b900fd9ee32",
        "tags" : [
        ]
      },
      {
        "id" : "79e0daa7-ae6c-4afd-a07f-002bf16a3f2a",
        "parentId" : "5563b655-6691-4c3a-9322-7f4a25072f1e",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "I didn't make it clear:  it's a display problem, it's a TermRef where the prefix is a TypeRef. \r\n\r\nIf we only have `_: TermRef`, we will need to do more error-handling in `analyze(tp)` to avoid crash: currently it's pretty strict about what types it may get.",
        "createdAt" : "2021-03-17T14:41:37Z",
        "updatedAt" : "2021-03-17T15:09:17Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "75b2cc04-6b2f-44bf-8881-dc70b2299149",
        "parentId" : "5563b655-6691-4c3a-9322-7f4a25072f1e",
        "authorId" : "ed629d1e-b3d4-4235-b1d2-9b900fd9ee32",
        "body" : "Oh, sorry, yes, this makes sense now.\r\n\r\nThen I just wonder why the restriction is for the prefix to be a `SingletonType` rather than the prefix being something like `TermRef | NoPrefix`. Can a `SingletonType` be more things than that and are those things that we want?",
        "createdAt" : "2021-03-17T15:00:46Z",
        "updatedAt" : "2021-03-17T15:09:17Z",
        "lastEditedBy" : "ed629d1e-b3d4-4235-b1d2-9b900fd9ee32",
        "tags" : [
        ]
      },
      {
        "id" : "70f3c260-a7c8-4277-a325-5b2c401e8fa3",
        "parentId" : "5563b655-6691-4c3a-9322-7f4a25072f1e",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "Yes, the prefix can also be `ThisType`, which is usually what we care about. If the prefix is `NoPrefix`, the variable is a local variable --- the analysis currently enforces that all local variables are hot. ",
        "createdAt" : "2021-03-17T15:04:53Z",
        "updatedAt" : "2021-03-17T15:09:17Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      }
    ],
    "commit" : "ad1aac006c13f437b2941b63cf3fa42cbde4f5a6",
    "line" : 47,
    "diffHunk" : "@@ -1,1 +219,223 @@    val traverser = new TypeTraverser {\n      def traverse(tp: Type): Unit = tp match {\n        case TermRef(_: SingletonType, _) =>\n          summary = summary + analyze(tp, source)\n        case _ =>"
  },
  {
    "id" : "58690fe8-ee7d-482c-ac81-1c3cfbdab71e",
    "prId" : 7789,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/7789#pullrequestreview-347870125",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "93fb0f47-dd48-4bdf-b600-6f9d96000e09",
        "parentId" : null,
        "authorId" : "3a3c9c08-5985-41f6-a86b-7fc5a427f51a",
        "body" : "If both `vdef.symbol.owner.isClass` and `vdef.symbol.is(Flags.Lazy)` are `true`, the call to `analyze(vdef.rhs)` above can be avoided.",
        "createdAt" : "2020-01-24T13:36:56Z",
        "updatedAt" : "2020-02-13T13:59:50Z",
        "lastEditedBy" : "3a3c9c08-5985-41f6-a86b-7fc5a427f51a",
        "tags" : [
        ]
      }
    ],
    "commit" : "6a4d06a40b13b72ae3468486d1c2d916400dea8e",
    "line" : 191,
    "diffHunk" : "@@ -1,1 +189,193 @@\n        if (vdef.symbol.owner.isClass)\n          (Potentials.empty, if (vdef.symbol.is(Flags.Lazy)) Effects.empty else effs)\n        else\n          (Potentials.empty, pots.promote(vdef) ++ effs)"
  },
  {
    "id" : "6fd22936-b8e7-4e6c-ad4a-6c65022e6ed3",
    "prId" : 7789,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/7789#pullrequestreview-347870125",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d89f6439-80a2-4ccd-bc46-c255b4807ebe",
        "parentId" : null,
        "authorId" : "3a3c9c08-5985-41f6-a86b-7fc5a427f51a",
        "body" : "If the condition is `false` here, the call to `analyze(ddef.rhs)` above can be avoided.",
        "createdAt" : "2020-01-24T13:38:02Z",
        "updatedAt" : "2020-02-13T13:59:50Z",
        "lastEditedBy" : "3a3c9c08-5985-41f6-a86b-7fc5a427f51a",
        "tags" : [
        ]
      }
    ],
    "commit" : "6a4d06a40b13b72ae3468486d1c2d916400dea8e",
    "line" : 202,
    "diffHunk" : "@@ -1,1 +200,204 @@        lazy val (pots, effs) = analyze(ddef.rhs)\n\n        if (ddef.symbol.owner.isClass) Summary.empty\n        else (Potentials.empty, pots.promote(ddef) ++ effs)\n"
  }
]
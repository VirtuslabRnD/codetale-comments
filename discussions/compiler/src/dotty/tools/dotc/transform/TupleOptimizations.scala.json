[
  {
    "id" : "d415ecce-c954-41bf-998b-224c28d79a28",
    "prId" : 9049,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/9049#pullrequestreview-426261399",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "83f296f7-4d3b-452b-9486-57c1e55ca2ec",
        "parentId" : null,
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "Maybe define a type in Definitions for `defn.EmptyTupleModule.termRef`.",
        "createdAt" : "2020-06-08T13:48:50Z",
        "updatedAt" : "2020-06-08T13:48:50Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      }
    ],
    "commit" : "5e5c736b88e2b6a222b3f53ee0d7492e7692cdc3",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +71,75 @@        if (size == 1)\n          // scala.EmptyTuple\n          ref(defn.EmptyTupleModule.termRef)\n        else if (size <= 5)\n          // val t = tup.asInstanceOf[TupleN[...]]"
  },
  {
    "id" : "cc65a51b-b41e-4b01-b2cb-18bfcdcee27b",
    "prId" : 8326,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/8326#pullrequestreview-359820817",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7ee5703f-8cb7-471b-9fe9-2643bd3c2789",
        "parentId" : null,
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "Maybe move `.dealias` before `. widenTermRefExpr`? Can we just use `widen` instead of `widenTermRefExpr`?",
        "createdAt" : "2020-02-17T13:54:37Z",
        "updatedAt" : "2020-02-17T13:54:47Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "aabc2e83-2610-4d26-9b40-c1982a5cbeed",
        "parentId" : "7ee5703f-8cb7-471b-9fe9-2643bd3c2789",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "No, the alias appears after the widening of the term ref. I did not find a case where we needed to completely widen the type. For the case of indices and sizes, this might widen the constant typea.",
        "createdAt" : "2020-02-17T14:06:40Z",
        "updatedAt" : "2020-02-17T14:06:41Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      },
      {
        "id" : "faf0501c-f144-459c-a358-db5e40246636",
        "parentId" : "7ee5703f-8cb7-471b-9fe9-2643bd3c2789",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "We only widen the term refs that come from inserting val bindings when inlining.",
        "createdAt" : "2020-02-17T14:45:31Z",
        "updatedAt" : "2020-02-17T14:45:31Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      },
      {
        "id" : "ea61d288-1fe6-4f4b-a378-20a2042c7ff6",
        "parentId" : "7ee5703f-8cb7-471b-9fe9-2643bd3c2789",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "We could mark the parameters an inline to avoid it. But I will remove the inline altogether in a future PR as it does not really have a purpose anymore.",
        "createdAt" : "2020-02-17T14:47:12Z",
        "updatedAt" : "2020-02-17T14:47:12Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      },
      {
        "id" : "77162356-42b6-4eea-a9a1-7b228bfad0a5",
        "parentId" : "7ee5703f-8cb7-471b-9fe9-2643bd3c2789",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "> For the case of indices and sizes, this might widen the constant type.\r\n\r\nThe type is a tuple type, it thus may not be constant types.\r\n\r\nFor dealiasing, what I've in mind is `type T = a.type`. But I guess no programmers will write such code, so it's fine to ignore such cases.\r\n",
        "createdAt" : "2020-02-17T15:35:21Z",
        "updatedAt" : "2020-02-17T15:35:21Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      }
    ],
    "commit" : "9aca3a333e0796677516265cfd77d45d1a4abc8e",
    "line" : 21,
    "diffHunk" : "@@ -1,1 +36,40 @@  private def transformTupleCons(tree: tpd.Apply)(implicit ctx: Context): Tree = {\n    val head :: tail :: Nil = tree.args\n    defn.tupleTypes(tree.tpe.widenTermRefExpr.dealias) match {\n      case Some(tpes) =>\n        // Generate a the tuple directly with TupleN+1.apply"
  },
  {
    "id" : "99dfa236-3bd8-44f7-bff6-d32a7ac68062",
    "prId" : 6539,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/6539#pullrequestreview-246146711",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e4c34a93-e28c-443a-9fa2-46a27bda20a3",
        "parentId" : null,
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "There is already a `tupleTypes` in Definitions. Should that be deleted?",
        "createdAt" : "2019-06-05T16:16:12Z",
        "updatedAt" : "2019-06-06T07:10:13Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "d90cac53-60b2-4cec-9023-14eed225f90c",
        "parentId" : "e4c34a93-e28c-443a-9fa2-46a27bda20a3",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "In Definitions we have `tupleType` which is the opposite operation, it takes a list of types and returns the tuple type representing that type.\r\n\r\nFirst I wanted to add this one in definition but I did not due to the special short-circuit behavior of this operation which is tailored to the need of `TupleOptimizations.scala`.",
        "createdAt" : "2019-06-05T17:21:10Z",
        "updatedAt" : "2019-06-06T07:10:13Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      }
    ],
    "commit" : "e5b880f751226d6a14b6cf883c9de6af6216ed9a",
    "line" : 225,
    "diffHunk" : "@@ -1,1 +223,227 @@  }\n\n  private def tupleTypes(tp: Type, bound: Int = Int.MaxValue)(implicit ctx: Context): Option[List[Type]] = {\n    @tailrec def rec(tp: Type, acc: List[Type], bound: Int): Option[List[Type]] = tp match {\n      case _ if bound < 0 => Some(acc.reverse)"
  }
]
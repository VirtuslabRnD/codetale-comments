[
  {
    "id" : "60c998cf-3ffd-4b37-b6cc-a5bc943db214",
    "prId" : 12710,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/12710#pullrequestreview-684258247",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7f393b98-37c5-4230-be6b-8fabe9cadd17",
        "parentId" : null,
        "authorId" : "998ba0f7-d6a6-448f-a3ba-0d2237ed0cf9",
        "body" : "This was needed for [test `run/t3452g`](https://github.com/lampepfl/dotty/blob/master/tests/run/t3452g/A.scala)\r\n\r\nThe backend calls `TypeErasure.transformInfo(<Symbol TraversableLike.tail>, <Type ExprType(AbstractTrav[String])>)`.\r\n\r\nErasure should, I assume, continue to work on `AbstractTrav[String]` (which is `rt` here). Calling `sym.info.finalResultType` gives `Repr` which erases differently.",
        "createdAt" : "2021-06-04T13:13:24Z",
        "updatedAt" : "2021-06-04T13:13:24Z",
        "lastEditedBy" : "998ba0f7-d6a6-448f-a3ba-0d2237ed0cf9",
        "tags" : [
        ]
      },
      {
        "id" : "c29b69bd-cd91-423c-9942-0a9604116b6c",
        "parentId" : "7f393b98-37c5-4230-be6b-8fabe9cadd17",
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Apparently that was intentionally changed in https://github.com/lampepfl/dotty/commit/76af6c53cd65a8569069b5fed00aa9ca12e30ee7",
        "createdAt" : "2021-06-04T14:14:30Z",
        "updatedAt" : "2021-06-04T14:14:30Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "1773b8af-9cf2-41d1-9223-c8a4e3848b8c",
        "parentId" : "7f393b98-37c5-4230-be6b-8fabe9cadd17",
        "authorId" : "998ba0f7-d6a6-448f-a3ba-0d2237ed0cf9",
        "body" : "Tests passed...",
        "createdAt" : "2021-06-04T17:05:42Z",
        "updatedAt" : "2021-06-04T17:05:42Z",
        "lastEditedBy" : "998ba0f7-d6a6-448f-a3ba-0d2237ed0cf9",
        "tags" : [
        ]
      },
      {
        "id" : "8bcdb0fb-8b6a-40c9-8504-77843300cb16",
        "parentId" : "7f393b98-37c5-4230-be6b-8fabe9cadd17",
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Sure, but at the very least we need to carefully check if this breaks binary compatibility.",
        "createdAt" : "2021-06-04T17:26:24Z",
        "updatedAt" : "2021-06-04T17:26:24Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "c7ceb6d7-6d67-4718-a3ee-80621f7498e1",
        "parentId" : "7f393b98-37c5-4230-be6b-8fabe9cadd17",
        "authorId" : "998ba0f7-d6a6-448f-a3ba-0d2237ed0cf9",
        "body" : "Very true. How could I do that? Compile the community build twice and do a [jardiff](https://github.com/scala/jardiff)?",
        "createdAt" : "2021-06-04T18:04:00Z",
        "updatedAt" : "2021-06-04T18:04:00Z",
        "lastEditedBy" : "998ba0f7-d6a6-448f-a3ba-0d2237ed0cf9",
        "tags" : [
        ]
      },
      {
        "id" : "ce66cd0c-e1ce-477e-bac1-3fc9c80735f8",
        "parentId" : "7f393b98-37c5-4230-be6b-8fabe9cadd17",
        "authorId" : "998ba0f7-d6a6-448f-a3ba-0d2237ed0cf9",
        "body" : "I ran `dotty.communitybuild.CommunityBuildTestA` twice; once with this PR, once with the line here reverted. This resulted in 14081 identical classfiles.\r\n\r\nI also added a check to see when the old and new erasure are different and it only happened when called from the backend:\r\n\r\n```diff\r\n+          val a = eraseResult(rt.translateFromRepeated(toArray = sourceLanguage.isJava))\r\n+          val b = eraseResult(sym.info.finalResultType.translateFromRepeated(toArray = sourceLanguage.isJava))\r\n+          if (!(a =:= b) && !(new Exception).getStackTrace.exists(_.toString.contains(\"getStaticForwarderGenericSignature\"))) then\r\n+            throw new Exception(s\"[ERASURE]\\n- $a\\n- $b\\n- $tp\\n- ${sym.showFullName}\")\r\n           MethodType(Nil, Nil,\r\n-            eraseResult(rt.translateFromRepeated(toArray = sourceLanguage.isJava)))\r\n+            a)\r\n```\r\n\r\nI ran the `sbt test` and `CommunityBuildTestA` with this in place and did't see the exception showing up.\r\n\r\n@smarter any other ideas?",
        "createdAt" : "2021-06-08T11:51:46Z",
        "updatedAt" : "2021-06-08T11:51:46Z",
        "lastEditedBy" : "998ba0f7-d6a6-448f-a3ba-0d2237ed0cf9",
        "tags" : [
        ]
      },
      {
        "id" : "f7857b13-1c02-479a-bd12-759dcf6bbb6b",
        "parentId" : "7f393b98-37c5-4230-be6b-8fabe9cadd17",
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Thanks, I've run a similar test on the whole CI and it also didn't show any situation where the two types differed, this makes sense since the tp passed to eraseInfo should always be the symbol info at that point (it's only called from transformInfo which is only called from Erasure#transform, which always uses the symbol info except for `java.lang.Object` which is treated specially), so LGTM :sparkler: ",
        "createdAt" : "2021-06-15T16:52:31Z",
        "updatedAt" : "2021-06-15T16:52:31Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      }
    ],
    "commit" : "5c8188aeda2f325de2853771e8ba512aa8bfbfdc",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +698,702 @@        else\n          MethodType(Nil, Nil,\n            eraseResult(rt.translateFromRepeated(toArray = sourceLanguage.isJava)))\n      case tp1: PolyType =>\n        eraseResult(tp1.resultType) match"
  },
  {
    "id" : "e5a6f227-9cab-4c67-b63b-2cce12be1c3d",
    "prId" : 11808,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/11808#pullrequestreview-617427424",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9c27c4da-f159-4041-a9ed-54bdf68a4fad",
        "parentId" : null,
        "authorId" : "5a9cd756-9120-4d5e-ac88-e9c636084f0e",
        "body" : "In our last discussion, hadn't we come to the conclusion that we should never return an Interface as the erasure of an intersection type (unless an interface dominates everything else, of course)? IIRC the issue was that `Object & T1 & T2` would otherwise have a different erasure than `T1 & T2`, even though `Object & T1 & T2` can simplify to `T1 & T2` and though Java would erase to `Object`.",
        "createdAt" : "2021-03-22T10:38:09Z",
        "updatedAt" : "2021-03-22T14:16:08Z",
        "lastEditedBy" : "5a9cd756-9120-4d5e-ac88-e9c636084f0e",
        "tags" : [
        ]
      },
      {
        "id" : "d46d03ee-a6d5-46fb-8b7d-ae91e8003522",
        "parentId" : "9c27c4da-f159-4041-a9ed-54bdf68a4fad",
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "> In our last discussion, hadn't we come to the conclusion that we should never return an Interface as the erasure of an intersection type \r\n\r\nYes, I went with this version originally but decided it wasn't worth it in the end:\r\n- Many more types end up being erased to Object which can lead to overloading clashes (it happened in the community build for example), I fear this could be a big problem in the wild making cross-compilation difficult.\r\n- Admittedly, the fact that `Object & T1 & T2` has a different erasure than `T1 & T2` isn't great, but then so is the fact\r\n  `Object & T1` has a different erasure than `T1`.\r\n- It turns out that intersection of traits in Java signatures actually work.\r\n- Having erasedGlb(A, B) always return either A or B allows us to implement it as the minimum of a total order, which gives us commutativity and associativity for free and in general makes it easier to reason about what this method does.",
        "createdAt" : "2021-03-22T11:15:58Z",
        "updatedAt" : "2021-03-22T14:16:08Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "32ef2420-5e90-427a-93cd-0201ba3161cf",
        "parentId" : "9c27c4da-f159-4041-a9ed-54bdf68a4fad",
        "authorId" : "5a9cd756-9120-4d5e-ac88-e9c636084f0e",
        "body" : "I see. IIUC, this is the critical aspect that allows this approach to work at all:\r\n\r\n> It turns out that intersection of traits in Java signatures actually work.",
        "createdAt" : "2021-03-22T11:27:40Z",
        "updatedAt" : "2021-03-22T14:16:08Z",
        "lastEditedBy" : "5a9cd756-9120-4d5e-ac88-e9c636084f0e",
        "tags" : [
        ]
      },
      {
        "id" : "6446eb04-bc12-45a6-b2eb-e608d140f57b",
        "parentId" : "9c27c4da-f159-4041-a9ed-54bdf68a4fad",
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "It's helpful, but if those Java signatures weren't allowed, we could also emit a signature containing just the first trait as an approximation, we already have to use approximated signatures in various situations where our type system is more expressive than Java's.",
        "createdAt" : "2021-03-22T11:45:36Z",
        "updatedAt" : "2021-03-22T14:16:08Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      }
    ],
    "commit" : "9af4bad2a0f3cc6078ab8385c14bbb82fac2947f",
    "line" : 15,
    "diffHunk" : "@@ -1,1 +402,406 @@   *    erased like javac would erase them (a Java intersection is composed of\n   *    exactly one class and one or more interfaces and always erases to the\n   *    class).\n   */\n  def erasedGlb(tp1: Type, tp2: Type)(using Context): Type ="
  },
  {
    "id" : "56cd6dc5-f3d9-4dcb-bf66-eab3cf09932f",
    "prId" : 11603,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/11603#pullrequestreview-605396648",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0a0e0fcf-1ce4-4de4-9d07-bf240734b787",
        "parentId" : null,
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Would it not be easier if the SourceLanguaageBits came last? Then we need not do the fiddling with `bits`.\r\n",
        "createdAt" : "2021-03-05T16:30:18Z",
        "updatedAt" : "2021-03-08T12:43:00Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "943636ff3be1ba52daf6fb409ddf7101aae8272b",
    "line" : 56,
    "diffHunk" : "@@ -1,1 +144,148 @@\n  private def erasureIdx(sourceLanguage: SourceLanguage, semiEraseVCs: Boolean, isConstructor: Boolean, wildcardOK: Boolean) =\n    extension (b: Boolean) def toInt = if b then 1 else 0\n    wildcardOK.toInt\n    + (isConstructor.toInt    << 1)"
  },
  {
    "id" : "0e65376f-642b-4996-8386-98df5ac5bed0",
    "prId" : 8060,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/8060#pullrequestreview-348677348",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "337b3b8a-6105-4f09-b4ac-2accf814b311",
        "parentId" : null,
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "It would be good to check if we can move it earlier to simply the contract between phases.",
        "createdAt" : "2020-01-27T13:43:15Z",
        "updatedAt" : "2020-01-27T13:56:45Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "2e555409-87bb-45a0-b19d-4587757ef432",
        "parentId" : "337b3b8a-6105-4f09-b4ac-2accf814b311",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "That would also include `val` binding generated for repeated parameters.",
        "createdAt" : "2020-01-27T13:55:18Z",
        "updatedAt" : "2020-01-27T13:56:45Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      }
    ],
    "commit" : "c80644c5c384efa7ac6fed069206132a5c93459f",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +534,538 @@        // forwarders to mixin methods.\n        // See doc comment for ElimByName for speculation how we could improve this.\n      else MethodType(Nil, Nil, eraseResult(sym.info.finalResultType.underlyingIfRepeated(isJava)))\n    case tp: PolyType =>\n      eraseResult(tp.resultType) match {"
  },
  {
    "id" : "cc1e4fa5-a507-478a-9390-7d90c5b4729b",
    "prId" : 7417,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/7417#pullrequestreview-301051252",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c7aa49b8-8bed-4320-ae29-b5a9d8b0368b",
        "parentId" : null,
        "authorId" : "e625ae4c-fba4-4c8f-9728-a669f65f1bcb",
        "body" : "Was there some decision about mixing significant indentation syntax with braces syntax? (this `match` has no braces)",
        "createdAt" : "2019-10-13T14:36:08Z",
        "updatedAt" : "2019-10-13T14:39:54Z",
        "lastEditedBy" : "e625ae4c-fba4-4c8f-9728-a669f65f1bcb",
        "tags" : [
        ]
      },
      {
        "id" : "3dcb850a-51f6-4841-8f97-cdbc1c3064a6",
        "parentId" : "c7aa49b8-8bed-4320-ae29-b5a9d8b0368b",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "I currently use indentation syntax for all code I touch to get a better feeling for it. If we decide not to do indentation, we can rewrite to braces automatically. \r\n\r\nThe reason not to convert to indentation wholesale is that is would destroy commit history.\r\n",
        "createdAt" : "2019-10-13T14:43:14Z",
        "updatedAt" : "2019-10-13T14:43:14Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "ebbea1afc783d4d52509fec0b7ae47a85d072903",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +150,154 @@  /** Like value class erasure, but value classes erase to their underlying type erasure */\n  def fullErasure(tp: Type)(implicit ctx: Context): Type =\n    valueErasure(tp) match\n      case ErasedValueType(_, underlying) => erasure(underlying)\n      case etp => etp"
  },
  {
    "id" : "76fe9e6e-1fca-48f6-883c-289e97eeb561",
    "prId" : 5926,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/5926#pullrequestreview-203915839",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fb41d31e-4e4e-4fc4-930f-81084521a555",
        "parentId" : null,
        "authorId" : "aa14f673-3d29-4a61-bf43-a86828212cf2",
        "body" : "The diff is misleading: I only added the check at the start, but since the pattern matching expressions is no longer at the top level the whole thing is highlighted. ",
        "createdAt" : "2019-02-14T19:01:46Z",
        "updatedAt" : "2019-02-14T19:01:46Z",
        "lastEditedBy" : "aa14f673-3d29-4a61-bf43-a86828212cf2",
        "tags" : [
        ]
      }
    ],
    "commit" : "909117b25331f0ee124e256cd1264a730bec11cb",
    "line" : 53,
    "diffHunk" : "@@ -1,1 +250,254 @@   */\n  def erasedLub(tp1: Type, tp2: Type)(implicit ctx: Context): Type = {\n    // After erasure, C | {Null, Nothing} is just C, if C is a reference type.\n    // We need to short-circuit this case here because the regular lub logic below\n    // relies on the class hierarchy, which doesn't properly capture `Null`s subtyping"
  },
  {
    "id" : "4be3db44-8952-4edb-b67a-c45ef0cea153",
    "prId" : 4156,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/4156#pullrequestreview-106237820",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "51dda013-8022-4df8-b1fc-5ed5b1d2a86b",
        "parentId" : null,
        "authorId" : "348fab8e-49e2-442e-884d-850c7f41fdde",
        "body" : "Does this code match _twice_ against `WildcardType`? I don't get it. In fact, the latter matches appear to be erased away:\r\n\r\n```scala\r\nscala> def foo: Any => Any = { case _: String | Int => 1; case _: Int => 2 }\r\ndef foo: Any => Any\r\nscala> foo(1)\r\nval res0: Any = 2\r\nscala> def foo: Any => Any = { case _: String | AnyRef => 1; case _: AnyRef => 2 }\r\ndef foo: Any => Any\r\nscala> foo(new AnyRef())\r\nval res1: Any = 2\r\n```",
        "createdAt" : "2018-03-22T14:56:56Z",
        "updatedAt" : "2018-03-22T14:57:10Z",
        "lastEditedBy" : "348fab8e-49e2-442e-884d-850c7f41fdde",
        "tags" : [
        ]
      },
      {
        "id" : "7e8af8ef-385d-4b6c-9279-171bd41aa27e",
        "parentId" : "51dda013-8022-4df8-b1fc-5ed5b1d2a86b",
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "It first matches against the object `WildcardType`, then the case below matches against any instance of the class `WildcardType`.",
        "createdAt" : "2018-03-22T14:58:01Z",
        "updatedAt" : "2018-03-22T14:58:01Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "ef4374c9-caf5-4980-9517-73ba6ea13059",
        "parentId" : "51dda013-8022-4df8-b1fc-5ed5b1d2a86b",
        "authorId" : "348fab8e-49e2-442e-884d-850c7f41fdde",
        "body" : "Yeah sorry, Allan explained me what's going on. But do we really know that the only instance of `WildcardType(NoType)` is the `WildcardType` object?",
        "createdAt" : "2018-03-22T18:03:56Z",
        "updatedAt" : "2018-03-22T18:03:56Z",
        "lastEditedBy" : "348fab8e-49e2-442e-884d-850c7f41fdde",
        "tags" : [
        ]
      }
    ],
    "commit" : "1e34d2de47b1f0b19c3c1ec3137a3d9174f6d3aa",
    "line" : 8,
    "diffHunk" : "@@ -1,1 +553,557 @@        tpnme.WILDCARD\n      case tp: WildcardType =>\n        sigName(tp.optBounds)\n      case _ =>\n        val erasedTp = this(tp)"
  },
  {
    "id" : "d441b33d-8c4c-4743-9570-675968deb170",
    "prId" : 4046,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/4046#pullrequestreview-101120040",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "786c3cea-8b24-413e-8d81-1b10a2ffb329",
        "parentId" : null,
        "authorId" : "223e67d6-1873-432a-9af9-f40b82a7eedd",
        "body" : "Can you explain why for both `A & B` and `A | B`, you have `isGeneric(A) || isGeneric(B)`?",
        "createdAt" : "2018-02-28T15:48:09Z",
        "updatedAt" : "2018-02-28T17:10:53Z",
        "lastEditedBy" : "223e67d6-1873-432a-9af9-f40b82a7eedd",
        "tags" : [
        ]
      },
      {
        "id" : "bf76ddb0-261d-466d-9ab8-b6042664d971",
        "parentId" : "786c3cea-8b24-413e-8d81-1b10a2ffb329",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "It's an approximation that makes sure that the erasure would not depend on any possible instantiation of the type. Erasure of AndTypes and OrTypes is quite complex, so it's hard to come up with a narrower condition.",
        "createdAt" : "2018-03-05T11:04:02Z",
        "updatedAt" : "2018-03-05T11:04:02Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "32787a43e95a305a549d14f85ac9c7766a995df8",
    "line" : 10,
    "diffHunk" : "@@ -1,1 +223,227 @@    case tp: TypeProxy => isGeneric(tp.underlying)\n    case tp: AndType => isGeneric(tp.tp1) || isGeneric(tp.tp2)\n    case tp: OrType => isGeneric(tp.tp1) || isGeneric(tp.tp2)\n    case _ => false\n  }"
  },
  {
    "id" : "5b4d7c20-c0d3-449d-8844-13b881294070",
    "prId" : 3718,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/3718#pullrequestreview-88665683",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9c187b4a-bae6-4fc9-af2c-cf445d335088",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Would `hasStableErasure(tp.lo) && hasStableErasure(tp.hi)` be incorrect?",
        "createdAt" : "2017-12-31T16:21:05Z",
        "updatedAt" : "2017-12-31T16:23:41Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "f6e19347-6d59-48a2-a19b-d25eeea6871d",
        "parentId" : "9c187b4a-bae6-4fc9-af2c-cf445d335088",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "No, because we fall into this case also via TypeProxy. ",
        "createdAt" : "2018-01-13T19:42:48Z",
        "updatedAt" : "2018-01-13T19:42:58Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "c1643b1801d204fefa58be40f477e9d68f2d3771",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +321,325 @@      }\n    case tp: TypeParamRef => false\n    case tp: TypeBounds => false\n    case tp: TypeProxy => hasStableErasure(tp.superType)\n    case tp: AndOrType => hasStableErasure(tp.tp1) && hasStableErasure(tp.tp2)"
  },
  {
    "id" : "daeeea0c-3fad-4b13-8c2c-1986767b1685",
    "prId" : 1758,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/1758#pullrequestreview-10952864",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3cec0440-63b9-4882-ad41-c92ea8ace544",
        "parentId" : null,
        "authorId" : "6d71bb21-e402-4464-b2b1-8bdd8e068461",
        "body" : "Should we implement `isImplementedFunctionClass` instead to avoid the double negation?",
        "createdAt" : "2016-11-30T14:42:33Z",
        "updatedAt" : "2016-12-01T12:32:12Z",
        "lastEditedBy" : "6d71bb21-e402-4464-b2b1-8bdd8e068461",
        "tags" : [
        ]
      },
      {
        "id" : "5fd53527-cf71-49c5-af61-13aaa82a2739",
        "parentId" : "3cec0440-63b9-4882-ad41-c92ea8ace544",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "It's just one occurrence, so probably not.",
        "createdAt" : "2016-12-01T12:14:04Z",
        "updatedAt" : "2016-12-01T12:32:12Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "055f12f957ec176323e4e0bf01af51666b9ff433",
    "line" : 16,
    "diffHunk" : "@@ -1,1 +43,47 @@      sym.isClass &&\n      sym != defn.AnyClass && sym != defn.ArrayClass &&\n      !defn.isUnimplementedFunctionClass(sym)\n    case _: TermRef =>\n      true"
  }
]
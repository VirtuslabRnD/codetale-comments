[
  {
    "id" : "79d71454-1a01-49e3-b93b-e78a9186a841",
    "prId" : 12703,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/12703#pullrequestreview-678916994",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "935e8f79-42ba-4b2e-85dc-71f04adad256",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "It's not clear to me why useNecessaryEither is treated specially here, is there a good justification or test case that illustrates this? Also in practice we also call necessaryEither when inferring GADTs:\r\nhttps://github.com/lampepfl/dotty/blob/a82af21ff48ea07dbae042239286e5d80ef0e92e/compiler/src/dotty/tools/dotc/core/TypeComparer.scala#L1564\r\nShould that condition also appear here? /cc @abgruszecki ",
        "createdAt" : "2021-06-07T10:54:11Z",
        "updatedAt" : "2021-06-07T11:03:11Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "42eca2ec-47fb-44a6-b2e5-5b45fb6ab9ab",
        "parentId" : "935e8f79-42ba-4b2e-85dc-71f04adad256",
        "authorId" : "3a56b927-736f-4aab-8690-358cd24ca570",
        "body" : "Yes, it probably should. Perhaps no GADT tests failed, because the interaction of GADTs and wildcards is undertested.\r\n\r\nAs a side remark, I'm not sure when exactly we should consider `useNecessaryEither` in separation from the GADT mode. The name doesn't help either in reminding that we should do both. Perhaps we should hide this condition behind a definition and rename `useNecessaryEither`?",
        "createdAt" : "2021-06-07T13:27:05Z",
        "updatedAt" : "2021-06-07T13:27:05Z",
        "lastEditedBy" : "3a56b927-736f-4aab-8690-358cd24ca570",
        "tags" : [
        ]
      },
      {
        "id" : "6bc3945b-9dc0-40e4-b8e8-222552f7b946",
        "parentId" : "935e8f79-42ba-4b2e-85dc-71f04adad256",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "I believe 12677 is the test case that fails otherwise.\r\n\r\n",
        "createdAt" : "2021-06-08T16:58:12Z",
        "updatedAt" : "2021-06-08T16:58:12Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "3eb4ab4b-62a6-4db1-b21d-ce0f91cec93d",
        "parentId" : "935e8f79-42ba-4b2e-85dc-71f04adad256",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Not sure about GADT inference. Does it even come up?\r\n",
        "createdAt" : "2021-06-08T16:58:49Z",
        "updatedAt" : "2021-06-08T16:58:49Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "8838774d-404f-4754-b9ab-59b204a82e2a",
        "parentId" : "935e8f79-42ba-4b2e-85dc-71f04adad256",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "I verified that all tests pass with or without the added condition `ctx.mode.is(Mode.GadtConstraintInference)`. Someone else could go to the bottom of this in a separate PR.\r\n",
        "createdAt" : "2021-06-08T19:21:27Z",
        "updatedAt" : "2021-06-08T19:21:28Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "25e311fec1341cace733c1f0f2e016e5cb3514f2",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +143,147 @@   *  we are doing a necessary comparison, or the mode is TypeVarsMissContext.\n   *  The idea is that under either of these conditions we are not interested\n   *  in creating a fresh type variable to replace the wildcard. I verified\n   *  that several tests break if one or the other part of the disjunction is dropped.\n   *  (for instance, i12677.scala demands `useNecessaryEither` in the condition)"
  },
  {
    "id" : "5acf4969-95f4-48d6-8879-bc422558ac1e",
    "prId" : 12317,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/12317#pullrequestreview-651102195",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b5ef3218-acd9-46b5-a2e9-5a548a4c8590",
        "parentId" : null,
        "authorId" : "3a56b927-736f-4aab-8690-358cd24ca570",
        "body" : "Ah, interesting. We always compare with GADT bounds in frozen constraint, but that doesn't end up mattering, right? That is: do I understand correctly that even if we're not inferring constraints, we need to break down structural types on the RHS to properly check if there's subtyping between the left- and right-hand sides?",
        "createdAt" : "2021-05-04T09:20:39Z",
        "updatedAt" : "2021-05-04T09:22:15Z",
        "lastEditedBy" : "3a56b927-736f-4aab-8690-358cd24ca570",
        "tags" : [
        ]
      },
      {
        "id" : "7976bfb5-12c8-46c9-af0e-adc5dacd94e2",
        "parentId" : "b5ef3218-acd9-46b5-a2e9-5a548a4c8590",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "I think the same reasoning applies: If we end up comparing GADT constraints we need necessaryEither, and that means we need to decompose the RHS as much as possible so that necesssaryEither is sound. ",
        "createdAt" : "2021-05-04T10:44:32Z",
        "updatedAt" : "2021-05-04T10:44:32Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "fbf8949db53a4ef49c0dab50224f69070f6e2fc4",
    "line" : 197,
    "diffHunk" : "@@ -1,1 +1705,1709 @@    case OrType(tp1, tp2) => containsAnd(tp1) || containsAnd(tp2)\n    case tp: TypeParamRef => containsAnd(bounds(tp).hi)\n    case tp: TypeRef => containsAnd(tp.info.hiBound) || tp.symbol.onGadtBounds(gbounds => containsAnd(gbounds.hi))\n    case tp: TypeProxy => containsAnd(tp.superType)\n    case _ => false"
  },
  {
    "id" : "e8544fab-c937-49da-bb32-fb2a1bc1db51",
    "prId" : 10221,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/10221#pullrequestreview-525667940",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6a175354-aca7-4204-bd41-4fbe67cdde32",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "I'm not necessarily against changing it now if we believe it's worth it, but that was actually an intentional behavior, see the justification in https://github.com/lampepfl/dotty/commit/5fb13aad58cc554e7afc3b15f69d4d16698a1e5f:\r\n\r\n> I think the new behavior is arguably better since using type aliases now\r\ngives you more control on how type inference proceeds, even if it means\r\nthat some things that used to typecheck don't anymore.",
        "createdAt" : "2020-11-07T15:00:15Z",
        "updatedAt" : "2020-11-12T20:41:24Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "b30cbf1c-124a-4e7b-ab95-cf4861a008ce",
        "parentId" : "6a175354-aca7-4204-bd41-4fbe67cdde32",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "I think we should not simply infer something that does not follow from the constraint. Or at least we should do it under the strict control of `either`. i10129 is arguably a very natural way to express things.\r\n",
        "createdAt" : "2020-11-07T17:20:33Z",
        "updatedAt" : "2020-11-12T20:41:24Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "930632d1-a1a7-4bb6-ac5a-24f901b523e7",
        "parentId" : "6a175354-aca7-4204-bd41-4fbe67cdde32",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Or, let's put it that way. The _correct_ thing to do is to dealias. Unfortunately that breaks hk type inference. But hk type inference always was an ad-hoc best effort thing (some might call it a kludge). It's clear we can't do hk type inference in general. So it's good to push this as far as we can, but it should not compromise the correct behavior for other constraints.\r\n",
        "createdAt" : "2020-11-07T17:26:47Z",
        "updatedAt" : "2020-11-12T20:41:24Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "88dbba4fe3b576df10732708297c4e72c660689d",
    "line" : 51,
    "diffHunk" : "@@ -1,1 +1008,1012 @@          // This leads to the constraint Lifted[U] <: Lifted[Int]. If we just\n          // check the arguments this gives `U <: Int`. But this is wrong. Dealiasing\n          // `Lifted` gives `Err | U <: Err | Int`, hence it should be `U <: Err | Int`.\n          //\n          // So it's a conundrum. We need to check the immediate arguments for hk type inference,"
  },
  {
    "id" : "5c643c25-502b-4d29-8366-ff4cbbb9c50d",
    "prId" : 9523,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/9523#pullrequestreview-468419284",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1cc9016f-70c3-431f-a46c-242dfe0ddb53",
        "parentId" : null,
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Nice explanation!",
        "createdAt" : "2020-08-17T12:31:15Z",
        "updatedAt" : "2020-08-17T12:31:45Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "64e8797a97d98499ca0fd08ca532a1b903546bae",
    "line" : 51,
    "diffHunk" : "@@ -1,1 +897,901 @@     *  has one of its bounds constrained), for background see:\n     *  - The infamous SI-2712: https://github.com/scala/bug/issues/2712\n     *  - The PR against Scala 2.12 implementing -Ypartial-unification: https://github.com/scala/scala/pull/5102\n     *  - Some explanations on how this impacts API design: https://gist.github.com/djspiewak/7a81a395c461fd3a09a6941d4cd040f2\n     */"
  },
  {
    "id" : "cb20a5fd-501c-4855-a3cc-4f86a148386e",
    "prId" : 8704,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/8704#pullrequestreview-400877005",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5e397711-5263-402a-a1e0-fb3bcfba1913",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "I don't understand the comment above: \"We can only trust a \"no\" from `isSameType` when both `arg1` and `arg2` are fully instantiated.\". What does \"trust\" mean here? `isSameType(tp1, tp2)` returning false means \"I wasn't able to prove that tp1 and tp2 are the same type\", having or not having type variables in these types does not change that.",
        "createdAt" : "2020-04-10T14:39:11Z",
        "updatedAt" : "2020-04-10T14:39:22Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "7d4af035-31e4-4937-a150-ea56fea89666",
        "parentId" : "5e397711-5263-402a-a1e0-fb3bcfba1913",
        "authorId" : "6d71bb21-e402-4464-b2b1-8bdd8e068461",
        "body" : "It means we interpret `!isSameType(A, B)` as \"`A` and `B` are definetly different type\" when the conditions in `&& { ... }` are met. The alternative would be to write another recursive method `provablyNotSameType` in the same style as `provablyDisjoint` that would be used here to draw disjointness conclusions from invarant type parameters.",
        "createdAt" : "2020-04-11T08:32:10Z",
        "updatedAt" : "2020-04-11T08:32:10Z",
        "lastEditedBy" : "6d71bb21-e402-4464-b2b1-8bdd8e068461",
        "tags" : [
        ]
      },
      {
        "id" : "0decadb6-c48f-47a4-8d6c-7e0f2f389c31",
        "parentId" : "5e397711-5263-402a-a1e0-fb3bcfba1913",
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "> It means we interpret !isSameType(A, B) as \"A and B are definetly different type\"\r\n\r\nUnfortunately that's not true, even if you exclude type variables, type parameters and abstract types. For example `Nothing` and `Int & String` are the same type, but the compiler doesn't know that and `isSameType` will return false.\r\n\r\n> The alternative would be to write another recursive method provablyNotSameType in the same style as provablyDisjoint that would be used here to draw disjointness conclusions from invarant type parameters.\r\n\r\nThat seems like a good way forward yeah.",
        "createdAt" : "2020-04-11T14:22:24Z",
        "updatedAt" : "2020-04-11T14:22:24Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "a49dc31f-f54a-4d14-8d98-9f6d5d548a16",
        "parentId" : "5e397711-5263-402a-a1e0-fb3bcfba1913",
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : ">  The alternative would be to write another recursive method provablyNotSameType\r\n\r\nIt looks like scalac has something like this for deciding if it needs to emit an unchecked type test warning, this could be a good inspiration: https://github.com/scala/scala/blob/dfb8f7364a56fc01ad1eaea57980fba586ef6914/src/compiler/scala/tools/nsc/typechecker/Checkable.scala#L275\r\n(we may in fact want to use this in our own unchecked type tests which are currently pretty broken: https://github.com/lampepfl/dotty/pull/8808)",
        "createdAt" : "2020-04-27T11:51:40Z",
        "updatedAt" : "2020-04-27T11:51:41Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      }
    ],
    "commit" : "2a7296e6a605d57bee827842314687c726f5db54",
    "line" : 1,
    "diffHunk" : "@@ -1,1 +2357,2361 @@                def fullyInstantiated(tp: Type): Boolean = new TypeAccumulator[Boolean] {\n                  override def apply(x: Boolean, t: Type) =\n                    x && {\n                      t match {\n                        case tp: TypeRef if tp.symbol.isAbstractOrParamType => false"
  },
  {
    "id" : "bc45180b-b3f6-46dc-a6ef-387d4f865f65",
    "prId" : 8443,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/8443#pullrequestreview-371905620",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5b5ae5d2-d92f-42bb-aff5-f6e11703dd12",
        "parentId" : null,
        "authorId" : "3a56b927-736f-4aab-8690-358cd24ca570",
        "body" : "Discussed this change in-person w/ Martin: changing the order of arguments here is solely a performance optimization, not an actual change to logic.",
        "createdAt" : "2020-03-09T16:01:29Z",
        "updatedAt" : "2020-03-09T16:01:59Z",
        "lastEditedBy" : "3a56b927-736f-4aab-8690-358cd24ca570",
        "tags" : [
        ]
      },
      {
        "id" : "a7e25bd0-6b53-4e87-a1ab-9fe9174badda",
        "parentId" : "5b5ae5d2-d92f-42bb-aff5-f6e11703dd12",
        "authorId" : "00348044-aa34-44f1-847a-bd79483e589b",
        "body" : "`a || b` == `b || a`, so yes.",
        "createdAt" : "2020-03-09T22:04:28Z",
        "updatedAt" : "2020-03-09T22:04:29Z",
        "lastEditedBy" : "00348044-aa34-44f1-847a-bd79483e589b",
        "tags" : [
        ]
      },
      {
        "id" : "6bb4dc3f-eadf-4350-a5b1-304e5654b270",
        "parentId" : "5b5ae5d2-d92f-42bb-aff5-f6e11703dd12",
        "authorId" : "3a56b927-736f-4aab-8690-358cd24ca570",
        "body" : "@hepin1989 thank you for your astute observation! I was thinking about things such as the old RHS assuming the old LHS already handled some type shape, or that we do some evil tricks when loading code from Tasty and the check on new LHS is necessary so that the new RHS doesn't blow up, but I suppose it never hurts to be reminded of elementary laws of Boolean algebra.",
        "createdAt" : "2020-03-10T09:42:59Z",
        "updatedAt" : "2020-03-10T09:42:59Z",
        "lastEditedBy" : "3a56b927-736f-4aab-8690-358cd24ca570",
        "tags" : [
        ]
      },
      {
        "id" : "a49e869f-f485-4e7c-ada5-a9b86d392b77",
        "parentId" : "5b5ae5d2-d92f-42bb-aff5-f6e11703dd12",
        "authorId" : "348fab8e-49e2-442e-884d-850c7f41fdde",
        "body" : "Or otherwise, `a || b` and `b || a` differ when `a` and `b` are not pure :-)",
        "createdAt" : "2020-03-10T12:27:17Z",
        "updatedAt" : "2020-03-10T12:27:17Z",
        "lastEditedBy" : "348fab8e-49e2-442e-884d-850c7f41fdde",
        "tags" : [
        ]
      }
    ],
    "commit" : "3a2831e688add5a99be0643d099d6150f21bd403",
    "line" : 117,
    "diffHunk" : "@@ -1,1 +754,758 @@            }\n          case _ => false\n        comparePaths || isNewSubType(tp1.underlying.widenExpr)\n      case tp1: RefinedType =>\n        isNewSubType(tp1.parent)"
  },
  {
    "id" : "19a5dae0-e0a6-405d-847b-845e71d4e559",
    "prId" : 8443,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/8443#pullrequestreview-374673373",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c62d887f-9a6c-4134-878c-bee91255286d",
        "parentId" : null,
        "authorId" : "00348044-aa34-44f1-847a-bd79483e589b",
        "body" : "introduce an explicit boolean return?",
        "createdAt" : "2020-03-13T23:57:03Z",
        "updatedAt" : "2020-03-13T23:57:04Z",
        "lastEditedBy" : "00348044-aa34-44f1-847a-bd79483e589b",
        "tags" : [
        ]
      }
    ],
    "commit" : "3a2831e688add5a99be0643d099d6150f21bd403",
    "line" : 85,
    "diffHunk" : "@@ -1,1 +269,273 @@                && !(sym1.isClass && sym2.isClass)  // class types don't subtype each other\n                ) ||\n                thirdTryNamed(tp2)\n            case _ =>\n              secondTry"
  },
  {
    "id" : "5c7ca16d-b602-461f-bddf-7dcf36e214d3",
    "prId" : 8443,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/8443#pullrequestreview-376014678",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f7ddc795-608b-4e47-9842-21e16d026a13",
        "parentId" : null,
        "authorId" : "6d71bb21-e402-4464-b2b1-8bdd8e068461",
        "body" : "This binding doesn't seem necessary",
        "createdAt" : "2020-03-17T13:07:24Z",
        "updatedAt" : "2020-03-17T13:24:49Z",
        "lastEditedBy" : "6d71bb21-e402-4464-b2b1-8bdd8e068461",
        "tags" : [
        ]
      }
    ],
    "commit" : "3a2831e688add5a99be0643d099d6150f21bd403",
    "line" : 8,
    "diffHunk" : "@@ -1,1 +236,240 @@        def compareNamed(tp1: Type, tp2: NamedType): Boolean =\n          implicit val ctx: Context = this.ctx\n          val info2 = tp2.info\n          info2 match\n            case info2: TypeAlias =>"
  },
  {
    "id" : "4ed54320-1773-455f-9625-2e5e189d0fe2",
    "prId" : 8170,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/8170#pullrequestreview-353736351",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e2105487-85a6-4a16-8d4b-221656e9c6db",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Use `tp2.stripLazyRef` instead ? (same thing below and in lub)",
        "createdAt" : "2020-02-05T14:24:49Z",
        "updatedAt" : "2020-02-05T16:22:31Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      }
    ],
    "commit" : "2644e154804d61327dbef4af71ca5c95c3ce6acd",
    "line" : 3,
    "diffHunk" : "@@ -1,1 +1727,1731 @@    else if tp1.isAny && !tp2.isLambdaSub || tp1.isAnyKind || tp2.isRef(NothingClass) then tp2\n    else if tp2.isAny && !tp1.isLambdaSub || tp2.isAnyKind || tp1.isRef(NothingClass) then tp1\n    else tp2 match {  // normalize to disjunctive normal form if possible.\n      case tp2: LazyRef =>\n        glb(tp1, tp2.ref)"
  },
  {
    "id" : "2961801d-ff98-40d0-8a0c-e07d8a1964fc",
    "prId" : 8139,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/8139#pullrequestreview-366806451",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ad022677-b2d0-47fa-ace0-ef8cdc9df75c",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "The use of an Option here might noticeably increase our allocation rate, a tri-state enum could be used instead.",
        "createdAt" : "2020-02-22T19:27:01Z",
        "updatedAt" : "2020-02-29T16:34:31Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "282181d9-7b9b-4c61-9d99-91e39f5f563f",
        "parentId" : "ad022677-b2d0-47fa-ace0-ef8cdc9df75c",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "I don't think so, since the overwhelming majority of calls should give `None`. You get a `Some` only if both compared sides are consist of atoms. \r\n",
        "createdAt" : "2020-02-29T16:26:52Z",
        "updatedAt" : "2020-02-29T16:34:31Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "8a5ca005c7fa46d52003f66ecf7f1ef78b906334",
    "line" : 77,
    "diffHunk" : "@@ -1,1 +1176,1180 @@   *  in a Some, otherwise None.\n   */\n  def compareAtoms(tp1: Type, tp2: Type): Option[Boolean] =\n\n    /** Check whether we can compare the given set of atoms with another to determine"
  },
  {
    "id" : "34fc809d-d8e1-4950-83c3-cbe6af2156fa",
    "prId" : 8139,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/8139#pullrequestreview-363046222",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "de6c5734-bda4-4c02-a407-6332e4893d0a",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "The comment above applies to the `canCompare` method so it should be moved down.",
        "createdAt" : "2020-02-22T19:29:46Z",
        "updatedAt" : "2020-02-29T16:34:31Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      }
    ],
    "commit" : "8a5ca005c7fa46d52003f66ecf7f1ef78b906334",
    "line" : 74,
    "diffHunk" : "@@ -1,1 +1175,1179 @@  /** If both `tp1` and `tp2` have atoms information, compare the atoms\n   *  in a Some, otherwise None.\n   */\n  def compareAtoms(tp1: Type, tp2: Type): Option[Boolean] =\n"
  },
  {
    "id" : "6330d8d9-0640-48ba-b9be-86cb2773d398",
    "prId" : 8082,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/8082#pullrequestreview-350992530",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "12df8efd-85db-43f1-86db-8ef6e1a4a6a1",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "I don't get why we're doing something different with the variance depending on whether we have an AndType or an OrType, the variance position is the same. If I intersect `[+X] => Cov[X]` and `[-X] => Contra[X]` I get an invariant type parameter structurally: `[X] => Cov[X] & Contra[X]`, but it looks like this code would make the type parameter bivariant instead.",
        "createdAt" : "2020-01-30T13:12:56Z",
        "updatedAt" : "2020-01-31T13:40:50Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "2ed0e70a-af79-46de-a9c9-923e317d8fb1",
        "parentId" : "12df8efd-85db-43f1-86db-8ef6e1a4a6a1",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "It's because conceptually variances are attached to abstract types, not the lambdas. Say you have two abstract members\r\n```\r\ntrait A { def F[-X] }\r\ntrait B { def F[+X] }\r\nobject O extends A, B { ... }\r\n```\r\nHere, the only legal implementation of `F` in `O` is indeed bivariant.\r\n\r\nI have added a comment to the code.\r\n\r\n",
        "createdAt" : "2020-01-30T17:08:12Z",
        "updatedAt" : "2020-01-31T13:40:50Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "2396fe9ddec940c8f7bbadc99577e12fadadc752",
    "line" : 180,
    "diffHunk" : "@@ -1,1 +1934,1938 @@      if (t2.exists) t2\n      else if (isErased) erasedGlb(tp1, tp2, isJava = false)\n      else liftIfHK(tp1, tp2, op, original, _ | _)\n        // The ` | ` on variances is needed since variances are associated with bounds\n        // not lambdas. Example:"
  },
  {
    "id" : "cb275606-04bf-4c43-afb0-3bd322393877",
    "prId" : 6531,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/6531#pullrequestreview-240647973",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9146d506-425b-464a-8e7c-faac9cf6d4fe",
        "parentId" : null,
        "authorId" : "6d71bb21-e402-4464-b2b1-8bdd8e068461",
        "body" : "Is this just about error reporting (proper cyclic reference instead of a stack overflow), or do you actually have a type correct program that makes the compiler loop here?",
        "createdAt" : "2019-05-22T12:21:43Z",
        "updatedAt" : "2019-06-04T18:44:29Z",
        "lastEditedBy" : "6d71bb21-e402-4464-b2b1-8bdd8e068461",
        "tags" : [
        ]
      },
      {
        "id" : "5dc47817-c256-49a2-b8a8-5b208ed07ba2",
        "parentId" : "9146d506-425b-464a-8e7c-faac9cf6d4fe",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "The second: if we would follow the alias here instead of just doing a `mapOver` every recursive match type would loop.\r\n",
        "createdAt" : "2019-05-22T13:56:33Z",
        "updatedAt" : "2019-06-04T18:44:29Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "2afa89ce87a95ed0cb2f960ef9a98806a75c17f1",
    "line" : 17,
    "diffHunk" : "@@ -1,1 +2320,2324 @@              case info: MatchAlias =>\n                mapOver(tp)\n                  // TODO: We should follow the alias in this case, but doing so\n                  // risks infinite recursion\n              case TypeBounds(lo, hi) =>"
  },
  {
    "id" : "f42b7fab-e128-4d7d-8fdd-ac08c307311a",
    "prId" : 6398,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/6398#pullrequestreview-244270154",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1a13e9ca-c011-4845-82d4-218186322b49",
        "parentId" : null,
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "I wondered, can this somehow be combined with the GADTflexible mode? I guess this would mean that instead of setting the GADTflexible mode bit we create a context with a new type comparer where frozenGadt is true.\r\n\r\n...\r\n\r\nAfter looking further I see that frozenGadt and GADTflexible are not equivalent. `either` depends on GADTflexible but not frozenGadt. I assume that's intentional.\r\n\r\n\r\n",
        "createdAt" : "2019-05-31T11:02:54Z",
        "updatedAt" : "2019-06-06T09:39:12Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "b88848d5-8a13-4670-9c45-a3eb864376d1",
        "parentId" : "1a13e9ca-c011-4845-82d4-218186322b49",
        "authorId" : "3a56b927-736f-4aab-8690-358cd24ca570",
        "body" : "I can see how `GADTFlexible` and `frozenGadt` can appear to have the same purpose, though I don't really think of them this way. For me, `GADTFlexible` mode fundamentally alters `isSubType(tp, pt)` to mean \"what type constraints necessarily follow from `tp <: pt`?\", whereas `frozenGadt` is simply a temporary flag that `TypeComparer` sets for itself, much like `ApproxState` is a set of temporary flags that help with recording constraints.\r\n\r\nAt one point, `frozenGadt` was a part of `ApproxState`. Would it help if I called it `gadtApprox` and added more information to the comment?",
        "createdAt" : "2019-05-31T12:00:40Z",
        "updatedAt" : "2019-06-06T09:39:12Z",
        "lastEditedBy" : "3a56b927-736f-4aab-8690-358cd24ca570",
        "tags" : [
        ]
      }
    ],
    "commit" : "01096ffc5b90aa40a0270fa5101ba9d13216e0c2",
    "line" : 18,
    "diffHunk" : "@@ -1,1 +147,151 @@   *  to signify that we temporarily cannot record any GADT constraints.\n   */\n  private[this] var frozenGadt = false\n\n  protected def isSubType(tp1: Type, tp2: Type, a: ApproxState): Boolean = {"
  },
  {
    "id" : "7828e9e2-1a04-43c1-ab6f-414d402665cc",
    "prId" : 6299,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/6299#pullrequestreview-231899214",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a41ab555-de21-4b3b-978b-4e992e1e4bb0",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Isn't not using the sets a potential performance problem ? Have you considered having both `OrType#atoms` and `OrType#atomsUnifySkolems` instead, where the latter would replace all skolems referring to the same type by a single instance ?",
        "createdAt" : "2019-04-24T13:25:42Z",
        "updatedAt" : "2019-05-02T16:48:07Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "a82348e6-60d3-4656-af47-3a566986dbf2",
        "parentId" : "a41ab555-de21-4b3b-978b-4e992e1e4bb0",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "I believe skolems are sufficiently rare. If it turns out that we get a performance problem, what you suggest could be a good alternative.\r\n",
        "createdAt" : "2019-04-29T20:58:36Z",
        "updatedAt" : "2019-05-02T16:48:07Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "b940f116cabcd11557822efdd60edd5220e06b25",
    "line" : 60,
    "diffHunk" : "@@ -1,1 +1072,1076 @@   *  But in that case comparing two sets of atoms that contain skolems\n   *  for equality would give the wrong result, so we should not use the sets\n   *  for comparisons.\n   */\n  def canCompare(atoms: Set[Type]): Boolean ="
  },
  {
    "id" : "44883225-80e1-45ad-9178-8f83d3393b61",
    "prId" : 6299,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/6299#pullrequestreview-231903912",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d2cb593e-6fe1-47df-afae-a2f2ed2453f4",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Do we have examples of Scala 2 code that breaks without the `scala2Mode` here ?",
        "createdAt" : "2019-04-24T13:29:42Z",
        "updatedAt" : "2019-05-02T16:48:07Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "cc1edfe2-8b80-43e9-8da4-2dc1962e79ed",
        "parentId" : "d2cb593e-6fe1-47df-afae-a2f2ed2453f4",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "I haven't tried. But it's better to be conservative, I think.\r\n\r\n",
        "createdAt" : "2019-04-29T20:59:15Z",
        "updatedAt" : "2019-05-02T16:48:07Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "14ab1c10-fe22-468f-9703-077b8db2518d",
        "parentId" : "d2cb593e-6fe1-47df-afae-a2f2ed2453f4",
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "I'm not sure, all these inference differences (that we'll have to document at some point) make it more risky for a codebase to turn off Scala2 mode since there's a non-zero chance any of them could cause a slient change of runtime behavior (e.g. because a different implicit ends up being selected). They're also only lightly tested since most of our tests are run without Scala2 mode enabled, meaning a higher risk of unforeseen interactions. So I'd limit them to things that significantly help in cross-compilation, but we can revisit this some other time.",
        "createdAt" : "2019-04-29T21:09:05Z",
        "updatedAt" : "2019-05-02T16:48:07Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      }
    ],
    "commit" : "b940f116cabcd11557822efdd60edd5220e06b25",
    "line" : 77,
    "diffHunk" : "@@ -1,1 +1543,1547 @@  final def glb(tps: List[Type]): Type = ((AnyType: Type) /: tps)(glb)\n\n  def widenInUnions(implicit ctx: Context): Boolean = ctx.scala2Mode || ctx.erasedTypes\n\n  /** The least upper bound of two types"
  },
  {
    "id" : "fb400a1e-23b0-409d-ab44-02feafc2a2f1",
    "prId" : 6050,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/6050#pullrequestreview-213109063",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "633f5e2b-899b-4516-a99d-18a9a6b75e79",
        "parentId" : null,
        "authorId" : "6d71bb21-e402-4464-b2b1-8bdd8e068461",
        "body" : "Should the `inFrozenConstraint` be pushed inside? The way this is written, it's possible that `matchCase(case1)` returns `None` while still infer new constrains, which will then be visible when calling `matchCase(case2)` to `matchCase(caseN)`.",
        "createdAt" : "2019-03-11T10:53:06Z",
        "updatedAt" : "2019-03-11T22:22:25Z",
        "lastEditedBy" : "6d71bb21-e402-4464-b2b1-8bdd8e068461",
        "tags" : [
        ]
      },
      {
        "id" : "984bc4c3-7612-4f9a-af1b-4c5fc43ef564",
        "parentId" : "633f5e2b-899b-4516-a99d-18a9a6b75e79",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "I don't see how that could happen. Once the constraint is frozen is stays so (in the same typeComparer). Which constraints would be computed by `matchCase(case1)` and propagated to `matchCase(case2)`?\r\n",
        "createdAt" : "2019-03-11T22:04:21Z",
        "updatedAt" : "2019-03-11T22:22:25Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "33d3622eda81719631b79c67c31797272f315e7f",
    "line" : 74,
    "diffHunk" : "@@ -1,1 +2170,2174 @@\n    def recur(cases: List[Type]): Type = cases match {\n      case cas :: cases1 => matchCase(cas).getOrElse(recur(cases1))\n      case Nil => NoType\n    }"
  },
  {
    "id" : "50f7a460-0334-4dc0-9205-bcf3b348bd9a",
    "prId" : 6023,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/6023#pullrequestreview-212616037",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3cc7979e-588a-482d-8023-8c642a027975",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "The `isErased` argument is not passed down to `andTypeGen`.",
        "createdAt" : "2019-03-10T18:41:23Z",
        "updatedAt" : "2019-03-10T21:26:37Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "97375d6e-4b80-4fed-b086-58b5bba59166",
        "parentId" : "3cc7979e-588a-482d-8023-8c642a027975",
        "authorId" : "3a3c9c08-5985-41f6-a86b-7fc5a427f51a",
        "body" : "Oops :) updated it",
        "createdAt" : "2019-03-10T18:45:18Z",
        "updatedAt" : "2019-03-10T21:26:37Z",
        "lastEditedBy" : "3a3c9c08-5985-41f6-a86b-7fc5a427f51a",
        "tags" : [
        ]
      }
    ],
    "commit" : "7cdab929b993c2ef22844bcc73a89269fc944e25",
    "line" : 44,
    "diffHunk" : "@@ -1,1 +1674,1678 @@   *  In these cases, a MergeError is thrown.\n   */\n  final def andType(tp1: Type, tp2: Type, isErased: Boolean = ctx.erasedTypes): Type =\n    andTypeGen(tp1, tp2, AndType(_, _), isErased = isErased)\n"
  },
  {
    "id" : "7e71118c-38c6-44b2-86a4-c914d5001b54",
    "prId" : 5996,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/5996#pullrequestreview-210901576",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5ac6790f-7ce5-4a95-a349-ca52ddf2d029",
        "parentId" : null,
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Can concrete classes not be closed? Maybe rename to `isClosedSum`?",
        "createdAt" : "2019-03-05T20:48:50Z",
        "updatedAt" : "2019-03-06T14:04:39Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "ea04343f99a912cd94e2afd3106cd0c85e2c6cc1",
    "line" : 168,
    "diffHunk" : "@@ -1,1 +1893,1897 @@    /** Can we enumerate all instantiations of this type? */\n    def isClosedSum(tp: Symbol): Boolean =\n      tp.is(Sealed) && tp.is(AbstractOrTrait) && !tp.hasAnonymousChild\n\n    /** Splits a closed type into a disjunction of smaller types."
  },
  {
    "id" : "31c38b08-6140-42c5-94ca-f86c27f20eb4",
    "prId" : 5996,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/5996#pullrequestreview-211152595",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "79584eb8-e29d-4b99-91fa-67b477897e89",
        "parentId" : null,
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Why not use a tail-recursive function for matchCases?",
        "createdAt" : "2019-03-05T21:26:43Z",
        "updatedAt" : "2019-03-06T14:04:39Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "a25b3588-63a5-40ce-88a2-804afad9e107",
        "parentId" : "79584eb8-e29d-4b99-91fa-67b477897e89",
        "authorId" : "6d71bb21-e402-4464-b2b1-8bdd8e068461",
        "body" : "I don't want constraints created while trying to evaluate one case to be carried over to the following cases, but I'm not sure if having these extra constraints could change anything...",
        "createdAt" : "2019-03-06T10:29:56Z",
        "updatedAt" : "2019-03-06T14:04:39Z",
        "lastEditedBy" : "6d71bb21-e402-4464-b2b1-8bdd8e068461",
        "tags" : [
        ]
      }
    ],
    "commit" : "ea04343f99a912cd94e2afd3106cd0c85e2c6cc1",
    "line" : 326,
    "diffHunk" : "@@ -1,1 +2131,2135 @@    var result: Type = NoType\n    var remainingCases = cases\n    while (!remainingCases.isEmpty) {\n      val (cas :: cass) = remainingCases\n      remainingCases = cass"
  },
  {
    "id" : "867c2e66-9505-47b2-8547-9d65740a9f99",
    "prId" : 5957,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/5957#pullrequestreview-206395832",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c3e1a404-0c9e-486f-be08-63a62597c244",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "It's not obvious what's fresh here, add some documentation ?",
        "createdAt" : "2019-02-21T16:56:54Z",
        "updatedAt" : "2019-02-23T13:42:32Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      }
    ],
    "commit" : "d4306dd3ca6c963497b31c342695cfb5d9138557",
    "line" : 253,
    "diffHunk" : "@@ -1,1 +1917,1921 @@   *  in `isSubType`, but also leads to `leftRoot` being set there.\n   */\n  val FreshApprox: ApproxState = new ApproxState(4)\n\n  /** Show trace of comparison operations when performing `op` as result string */"
  },
  {
    "id" : "1aaf7b1c-8b14-4361-aeb9-f220b2544dc3",
    "prId" : 5957,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/5957#pullrequestreview-206567522",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "070820ae-1842-4ab5-8612-35f49985ae67",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "```suggestion\r\n         *\r\n         *   See also `adaptToSubType` in `Typer` where a type might be skolemized to allow `leftRoot` to be a path.\r\n         */\r\n```\r\n(there might be a better way to word this)",
        "createdAt" : "2019-02-21T22:18:26Z",
        "updatedAt" : "2019-02-23T13:42:32Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      }
    ],
    "commit" : "d4306dd3ca6c963497b31c342695cfb5d9138557",
    "line" : 176,
    "diffHunk" : "@@ -1,1 +1075,1079 @@         *  skolemizations, which are more expensive . And, besides, capture conversion on\n         *  paths is less intrusive than skolemization.\n         */\n        def compareCaptured(arg1: TypeBounds, arg2: Type) = tparam match {\n          case tparam: Symbol"
  },
  {
    "id" : "86b32c8a-8fa6-4149-9ca6-8f59d95cf346",
    "prId" : 5957,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/5957#pullrequestreview-206567522",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1e61d6ca-5771-4584-ab50-ed5ca1fd4273",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Not sure \"reset\" is the correct word since the value is saved and restored when leaving the nested isSubType. In any case, I think we can avoid having this variable at all by nesting `isSubArgs` inside `isSubType` and rename the parameters of `isSubType` from `tp1` and `tp2` to `origTp1`, `origTp2`. Then `leftRoot` can just be replaced by `origTp1`.",
        "createdAt" : "2019-02-21T22:28:39Z",
        "updatedAt" : "2019-02-23T13:42:32Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      }
    ],
    "commit" : "d4306dd3ca6c963497b31c342695cfb5d9138557",
    "line" : 9,
    "diffHunk" : "@@ -1,1 +135,139 @@  protected def approxState: ApproxState = approx\n\n  /** The original left-hand type of the comparison. Gets reset\n   *  everytime we compare components of the previous pair of types.\n   *  This type is used for capture conversion in `isSubArgs`."
  },
  {
    "id" : "9dab3533-9b86-4a08-b914-e78f750ee450",
    "prId" : 5950,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/5950#pullrequestreview-205755770",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bd33586d-538d-4f5b-a6ef-1ae9570a128b",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "To be really correct, shouldn't we check if `ref1` is realizable too ?",
        "createdAt" : "2019-02-20T10:36:31Z",
        "updatedAt" : "2019-02-20T13:32:01Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "87e0a2a4-b2ea-459d-82d2-81d561e6fdd5",
        "parentId" : "bd33586d-538d-4f5b-a6ef-1ae9570a128b",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Yes, we should.\r\n",
        "createdAt" : "2019-02-20T13:28:48Z",
        "updatedAt" : "2019-02-20T13:32:01Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "4d198ec4c582285b3cf28ef7e612697b1b2ea55b",
    "line" : 15,
    "diffHunk" : "@@ -1,1 +1150,1154 @@          tp2.refinedInfo match {\n            case rinfo2: TypeBounds if tp1.isStable =>\n              val ref1 = tp1.widenExpr.select(name)\n              isSubType(rinfo2.lo, ref1) && isSubType(ref1, rinfo2.hi)\n            case _ =>"
  },
  {
    "id" : "3f1faeb6-88b7-4add-8278-116b7028a631",
    "prId" : 5914,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/5914#pullrequestreview-203669386",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6dec09fa-cc95-4832-86bc-bf736552a013",
        "parentId" : null,
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "It would be good to have a test case that fails if the case is missing! Failing that, one can try to instrument the code to see whether the new logic makes a difference anywhere in the existing code base.\r\n",
        "createdAt" : "2019-02-14T10:09:25Z",
        "updatedAt" : "2019-03-07T12:17:30Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "6c63d567-18f1-4167-aee9-85602e196cf5",
        "parentId" : "6dec09fa-cc95-4832-86bc-bf736552a013",
        "authorId" : "3a56b927-736f-4aab-8690-358cd24ca570",
        "body" : "@odersky the following code fails without this case:\r\n```scala\r\nval a = newTypeVar(TypeBounds.empty)\r\nval b = newTypeVar(TypeBounds.empty)\r\na <:< b\r\nassert(a frozen_<:< b)\r\n```\r\nI think that seems potentially problematic. I believe I actually ran across this issue half a year ago, when I was trying to make my exhaustivity checker use `Constraint` as a constraint solver. That being said, I have 0 idea on how to make TypeComparer enter this case w/o manually triggering it.\r\n\r\nEDIT: for clarity, I meant to hand off this PR to @smarter. I think it's useful to know that a potential problem exists and that we already have a fix for it, even if it doesn't impact the codebase yet. It seems to me that `if (a <:< b) then a frozen_<:< b` is a useful invariant to have.",
        "createdAt" : "2019-02-14T10:30:44Z",
        "updatedAt" : "2019-03-07T12:17:30Z",
        "lastEditedBy" : "3a56b927-736f-4aab-8690-358cd24ca570",
        "tags" : [
        ]
      }
    ],
    "commit" : "f6d037a53a85f4d32f21ad1a2ea009a6d73fe781",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +453,457 @@            else isSubTypeWhenFrozen(tp1, tp2)\n          alwaysTrue ||\n          frozenConstraint && (tp1 match {\n            case tp1: TypeParamRef => constraint.isLess(tp1, tp2)\n            case _ => false"
  },
  {
    "id" : "423c07b7-5319-4a20-a17c-6d02b7f570b8",
    "prId" : 5836,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/5836#pullrequestreview-199816504",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6d7050d1-e142-4841-b916-9b2ee5df3fbf",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Is this comment still accurate ?",
        "createdAt" : "2019-02-04T15:01:43Z",
        "updatedAt" : "2019-02-04T21:32:35Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "be5057bb-3921-443e-afd8-8ca66f2e28d1",
        "parentId" : "6d7050d1-e142-4841-b916-9b2ee5df3fbf",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Yes, it refers to the first clause of the match that follows.",
        "createdAt" : "2019-02-04T21:30:31Z",
        "updatedAt" : "2019-02-04T21:32:35Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "75178c44e773a5514e630b4c4aeeb8306fc6ea80",
    "line" : 1,
    "diffHunk" : "@@ -1,1 +1225,1229 @@  }\n\n  /** Defer constraining type variables when compared against prototypes */\n  def isMatchedByProto(proto: ProtoType, tp: Type): Boolean = tp.stripTypeVar match {\n    case tp: TypeParamRef if constraint contains tp => true"
  },
  {
    "id" : "a36e4bda-20ec-4878-a940-fbefb89d0594",
    "prId" : 5736,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/5736#pullrequestreview-221068964",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6c020b03-f7cc-4ca9-b3c6-27c432894f4c",
        "parentId" : null,
        "authorId" : "3a56b927-736f-4aab-8690-358cd24ca570",
        "body" : "@smarter you might want to take a look at this and its original commit (the first in history). It seems to me that we might be missing an analogous case when comparing two TypeParamRefs in frozen constraint. Note that when _not_ in frozen constraint, `TypeComparer` will try to record a new bound, which will be a no-op.",
        "createdAt" : "2019-02-13T12:30:46Z",
        "updatedAt" : "2019-05-13T12:55:51Z",
        "lastEditedBy" : "3a56b927-736f-4aab-8690-358cd24ca570",
        "tags" : [
        ]
      },
      {
        "id" : "b0d1e0ad-ebb8-44cf-aac0-eaf2acd08efe",
        "parentId" : "6c020b03-f7cc-4ca9-b3c6-27c432894f4c",
        "authorId" : "3a56b927-736f-4aab-8690-358cd24ca570",
        "body" : "Reminder to self post-coversation w/ @smarter: create an issue for this after this is merged.",
        "createdAt" : "2019-02-13T12:59:09Z",
        "updatedAt" : "2019-05-13T12:55:51Z",
        "lastEditedBy" : "3a56b927-736f-4aab-8690-358cd24ca570",
        "tags" : [
        ]
      },
      {
        "id" : "c7dca1dc-5fcc-4c8c-a92e-97bba76bc239",
        "parentId" : "6c020b03-f7cc-4ca9-b3c6-27c432894f4c",
        "authorId" : "3a56b927-736f-4aab-8690-358cd24ca570",
        "body" : "Already merged in #5914.",
        "createdAt" : "2019-04-01T12:16:58Z",
        "updatedAt" : "2019-05-13T12:55:51Z",
        "lastEditedBy" : "3a56b927-736f-4aab-8690-358cd24ca570",
        "tags" : [
        ]
      }
    ],
    "commit" : "3c3b3db63be69936c391db3a965ebda1aff03391",
    "line" : 11,
    "diffHunk" : "@@ -1,1 +450,454 @@                  // We do not need similar code in fourthTry, since we only need to care about\n                  // comparing two constrained types, and that case will be handled here first.\n                  ctx.gadt.isLess(tp1.symbol, tp2.symbol) && GADTusage(tp1.symbol) && GADTusage(tp2.symbol)\n                case _ => false\n              }) ||"
  },
  {
    "id" : "1cafe926-da30-47b6-8c8b-d7fb280f10a7",
    "prId" : 5611,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/5611#pullrequestreview-185562824",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fa767d57-5e10-45b9-b520-633ff44facbb",
        "parentId" : null,
        "authorId" : "3a56b927-736f-4aab-8690-358cd24ca570",
        "body" : "I tried to adjust for https://github.com/lampepfl/dotty/pull/5611#discussion_r241851303 by basing `.explained` on `.explaining`. Basing it the other way around doesn't work, since we can't assing `null` to `var res: T`.\r\n\r\nTo clarify: `.toString()` on `ExplainingTypeComparer` was replaced with `.lastTrace()`, because the previous implementation interacted badly with debugging. Every time I stopped in TypeComparer, its `.toString` was called by the debugger, which got rid of the stack trace. ",
        "createdAt" : "2018-12-17T12:19:39Z",
        "updatedAt" : "2018-12-17T12:21:37Z",
        "lastEditedBy" : "3a56b927-736f-4aab-8690-358cd24ca570",
        "tags" : [
        ]
      }
    ],
    "commit" : "d1fa5d73c4194448e1ab0d4d4e39a764b6e1f651",
    "line" : 183,
    "diffHunk" : "@@ -1,1 +1833,1837 @@    var trace: String = null\n    explaining(trace = _)(op)\n    trace\n  }\n}"
  },
  {
    "id" : "8fdd4701-9a69-4077-bdac-cf53ba1789c2",
    "prId" : 5568,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/5568#pullrequestreview-182216070",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "36aac08c-7de9-4aae-b409-bda085b10dbf",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "This comment is now attached to the wrong line (it refers to isLambdaSub above)",
        "createdAt" : "2018-12-05T14:41:39Z",
        "updatedAt" : "2018-12-06T12:25:28Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "4fa3ae66-f009-4c38-aa55-a8939a4831c1",
        "parentId" : "36aac08c-7de9-4aae-b409-bda085b10dbf",
        "authorId" : "348fab8e-49e2-442e-884d-850c7f41fdde",
        "body" : "Addressed.",
        "createdAt" : "2018-12-06T12:31:28Z",
        "updatedAt" : "2018-12-06T12:31:28Z",
        "lastEditedBy" : "348fab8e-49e2-442e-884d-850c7f41fdde",
        "tags" : [
        ]
      }
    ],
    "commit" : "483a595e25c4f77a4bd60dfb302f3ea720e595a5",
    "line" : 16,
    "diffHunk" : "@@ -1,1 +407,411 @@            if (tp1.isRef(NothingClass)) return true\n            if (tp1.isLambdaSub) return false\n              // Note: We would like to replace this by `if (tp1.hasHigherKind)`\n              // but right now we cannot since some parts of the standard library rely on the\n              // idiom that e.g. `List <: Any`. We have to bootstrap without scalac first."
  },
  {
    "id" : "85fa0300-855a-430a-834e-fbf4961ca7b7",
    "prId" : 4626,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/4626#pullrequestreview-127197692",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "53793cd4-2691-4aad-9983-a12b3a09f927",
        "parentId" : null,
        "authorId" : "70ef1594-3bb7-4579-b053-2189b409b5dc",
        "body" : "I'm not sure when a type constructor would have a `RefiningAnnotation`, but wouldn't it in principle be okay to widen here, regardless of whether the annotation is refining?",
        "createdAt" : "2018-06-07T18:38:11Z",
        "updatedAt" : "2018-06-08T08:58:32Z",
        "lastEditedBy" : "70ef1594-3bb7-4579-b053-2189b409b5dc",
        "tags" : [
        ]
      },
      {
        "id" : "d0600648-3de9-49a3-94ac-54d675c252f1",
        "parentId" : "53793cd4-2691-4aad-9983-a12b3a09f927",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Yes, well spotted. Narrowing the lower bound is always safe, and it is the only thing we can do in this case.",
        "createdAt" : "2018-06-08T06:07:35Z",
        "updatedAt" : "2018-06-08T08:58:32Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "2625c4d0-0d10-45aa-a8b5-cffd8677f3e1",
        "parentId" : "53793cd4-2691-4aad-9983-a12b3a09f927",
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Looks like this PR was merged without addressing this comment?",
        "createdAt" : "2018-06-08T15:00:41Z",
        "updatedAt" : "2018-06-08T15:00:41Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      }
    ],
    "commit" : "dde7ce94e35697a6daa3c37e1c7740510c9580aa",
    "line" : 86,
    "diffHunk" : "@@ -1,1 +706,710 @@            case tycon1: TypeVar =>\n              isMatchingApply(tycon1.underlying)\n            case tycon1: AnnotatedType if !tycon1.isRefining =>\n              isMatchingApply(tycon1.underlying)\n            case _ =>"
  },
  {
    "id" : "bc1c4d6b-2ee7-40f9-bca9-a8028aa6eff4",
    "prId" : 4626,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/4626#pullrequestreview-127198844",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "dbabf6f1-ff82-4055-bf40-c001ce399d8e",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Why not rewrap the annotation around the intersection if it's a refining annotation?",
        "createdAt" : "2018-06-08T15:03:20Z",
        "updatedAt" : "2018-06-08T15:03:20Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      }
    ],
    "commit" : "dde7ce94e35697a6daa3c37e1c7740510c9580aa",
    "line" : 120,
    "diffHunk" : "@@ -1,1 +1554,1558 @@      tp1.underlying & tp2\n    case tp1: AnnotatedType if !tp1.isRefining =>\n      tp1.underlying & tp2\n    case _ =>\n      NoType"
  },
  {
    "id" : "453db722-ba9f-4911-934f-7b95a07f29fb",
    "prId" : 3918,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/3918#pullrequestreview-93462392",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "833832b1-85a2-4ce7-a80f-318ae3aa234e",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Is subapprox needed here given that `tycon2bounds.lo eq tycon2bounds.hi` ?",
        "createdAt" : "2018-02-01T22:31:53Z",
        "updatedAt" : "2018-02-03T11:04:56Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      }
    ],
    "commit" : "e07af3fe773b8c0610d80e6c4edf8c797c1fe7df",
    "line" : 1293,
    "diffHunk" : "@@ -1,1 +769,773 @@        if (tycon2bounds.lo eq tycon2bounds.hi)\n          if (tyconIsTypeRef) recur(tp1, tp2.superType)\n          else isSubApproxHi(tp1, tycon2bounds.lo.applyIfParameterized(args2))\n        else\n          fallback(tycon2bounds.lo)"
  },
  {
    "id" : "3546a796-3488-4b0a-b91f-cf0c90f2fc8a",
    "prId" : 3713,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/3713#pullrequestreview-86036850",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ce21b623-fc18-4177-a931-fbc92a708c08",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Can be written `EtaExpansion(tp1)` I think.",
        "createdAt" : "2017-12-30T19:07:40Z",
        "updatedAt" : "2017-12-30T21:19:32Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "c76fdccc-c223-4306-b872-b202ab3b073c",
        "parentId" : "ce21b623-fc18-4177-a931-fbc92a708c08",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "EtaExpansion only works for class type constructors. I tried to change that, but it would be quite involved, so I thought it was simpler to write the code directly here.",
        "createdAt" : "2017-12-30T21:23:36Z",
        "updatedAt" : "2017-12-30T21:23:42Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "2a285cd281b692bb04456bb1e76f65b953e21031",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +479,483 @@            val tparams1 = tp1.typeParams\n            return isSubType(\n              HKTypeLambda.fromParams(tparams1, tp1.appliedTo(tparams1.map(_.paramRef))),\n              tp2\n            )"
  },
  {
    "id" : "1ed573e4-c521-4ef2-a7af-62e5ec41c7e8",
    "prId" : 3061,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/3061#pullrequestreview-60855219",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "01b213d8-53e3-4c5d-9e6f-983e349790e0",
        "parentId" : null,
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Complication: Need to compare baseclasses of lhs against full rhs if it is an AppliedType",
        "createdAt" : "2017-09-06T09:39:01Z",
        "updatedAt" : "2017-09-20T15:20:34Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "2e65bd581c7506e1a382d906a9c8a961fafabfff",
    "line" : 202,
    "diffHunk" : "@@ -1,1 +772,776 @@        isMatchingApply(tp1) || {\n          tycon2.info match {\n            case info2: TypeBounds =>\n              compareLower(info2, tyconIsTypeRef = true)\n            case info2: ClassInfo =>"
  },
  {
    "id" : "6221e88a-e18e-47f8-814c-f07b0d6ef09a",
    "prId" : 3061,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/3061#pullrequestreview-60855465",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2aadf8f5-bd35-4bf4-be91-41a45f0f7414",
        "parentId" : null,
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Complication: Need to do capture conversion when comparing an applied type with wildcard arguments.",
        "createdAt" : "2017-09-06T09:39:56Z",
        "updatedAt" : "2017-09-20T15:20:34Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "2e65bd581c7506e1a382d906a9c8a961fafabfff",
    "line" : 258,
    "diffHunk" : "@@ -1,1 +821,825 @@      val v = tparam.paramVariance\n\n      def compareCaptured(arg1: Type, arg2: Type): Boolean = arg1 match {\n        case arg1: TypeBounds =>\n          val captured = TypeArgRef.fromParam(tp1, tparam.asInstanceOf[TypeSymbol])"
  },
  {
    "id" : "73998887-4e3f-4a3e-87c3-f5efb14bfef8",
    "prId" : 3061,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/3061#pullrequestreview-60855836",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "49204605-a38e-4861-a185-1e86e1ef573c",
        "parentId" : null,
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Complication: Need to adapt higher-kinded variances when comparing applied types as well as refined types.",
        "createdAt" : "2017-09-06T09:41:16Z",
        "updatedAt" : "2017-09-20T15:20:34Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "2e65bd581c7506e1a382d906a9c8a961fafabfff",
    "line" : 286,
    "diffHunk" : "@@ -1,1 +847,851 @@        // last effort: try to adapt variances of higher-kinded types if this is sound.\n        // TODO: Move this to eta-expansion?\n        val adapted2 = arg2.adaptHkVariances(tparam.paramInfo)\n        adapted2.ne(arg2) && isSubArg(arg1, adapted2)\n      }"
  },
  {
    "id" : "67c4959f-8ca5-4bcf-b69a-6888cde0d8b7",
    "prId" : 3061,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/3061#pullrequestreview-61809474",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "49f90b95-5cb5-424c-87e1-31ce7414d79f",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "The comment above refers to the parameter `tycon1a` which is now called `tycon1`",
        "createdAt" : "2017-09-11T16:56:02Z",
        "updatedAt" : "2017-09-20T15:20:34Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      }
    ],
    "commit" : "2e65bd581c7506e1a382d906a9c8a961fafabfff",
    "line" : 140,
    "diffHunk" : "@@ -1,1 +699,703 @@       *\n       *  such that the resulting type application is a supertype of `tp1`.\n       */\n      def appOK(tp1base: Type) = tp1base match {\n        case tp1base: AppliedType =>"
  },
  {
    "id" : "c6194863-ae29-4a57-828e-c6824c7b6b49",
    "prId" : 3061,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/3061#pullrequestreview-62716728",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f91d81e5-68ab-4baf-8415-a7c5a738f660",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Could be a `val`",
        "createdAt" : "2017-09-11T16:56:24Z",
        "updatedAt" : "2017-09-20T15:20:34Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "02be1d80-fb56-4e80-a79c-edb67bcf34ef",
        "parentId" : "f91d81e5-68ab-4baf-8415-a7c5a738f660",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "No, it's reassigned later.",
        "createdAt" : "2017-09-14T11:21:00Z",
        "updatedAt" : "2017-09-20T15:20:35Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "2e65bd581c7506e1a382d906a9c8a961fafabfff",
    "line" : 158,
    "diffHunk" : "@@ -1,1 +702,706 @@      def appOK(tp1base: Type) = tp1base match {\n        case tp1base: AppliedType =>\n          var tycon1 = tp1base.tycon\n          val args1 = tp1base.args\n          val tparams1all = tycon1.typeParams"
  },
  {
    "id" : "8bff1efe-4c29-43ee-a789-fa779ac236d6",
    "prId" : 3061,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/3061#pullrequestreview-61809474",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4a5362e4-c01c-4791-98cc-50ad40e5b94c",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "This case is very similar to the default case in `thirdTryNamed`, but I don't know if there's a clean way to extract the similarity to a common function.",
        "createdAt" : "2017-09-11T16:59:59Z",
        "updatedAt" : "2017-09-20T15:20:34Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      }
    ],
    "commit" : "2e65bd581c7506e1a382d906a9c8a961fafabfff",
    "line" : 204,
    "diffHunk" : "@@ -1,1 +774,778 @@            case info2: TypeBounds =>\n              compareLower(info2, tyconIsTypeRef = true)\n            case info2: ClassInfo =>\n              val base = tp1.baseType(info2.cls)\n              if (base.exists && base.ne(tp1)) isSubType(base, tp2)"
  },
  {
    "id" : "5e002896-6adb-4195-9fa2-bb9afe1e8e58",
    "prId" : 3061,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/3061#pullrequestreview-61809474",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "24d547c8-781d-4916-916a-886da431d108",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Yes, that would be nice :).",
        "createdAt" : "2017-09-11T17:04:13Z",
        "updatedAt" : "2017-09-20T15:20:34Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      }
    ],
    "commit" : "2e65bd581c7506e1a382d906a9c8a961fafabfff",
    "line" : 285,
    "diffHunk" : "@@ -1,1 +846,850 @@      isSubArg(arg1, arg2) || {\n        // last effort: try to adapt variances of higher-kinded types if this is sound.\n        // TODO: Move this to eta-expansion?\n        val adapted2 = arg2.adaptHkVariances(tparam.paramInfo)\n        adapted2.ne(arg2) && isSubArg(arg1, adapted2)"
  },
  {
    "id" : "7053d4b8-d36b-43df-acae-2f97d3ad3b17",
    "prId" : 2205,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/2205#pullrequestreview-31724742",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3e66c2a4-01f4-4c04-af1e-183cee542783",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "I have an alternative fix for #2201  at https://github.com/lampepfl/dotty/pull/2204. Your fix looks like it might help in some other situations, but we would need a testcase for that.",
        "createdAt" : "2017-04-09T13:23:12Z",
        "updatedAt" : "2017-04-09T13:23:12Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "36ca428c-0634-41d2-be3d-bc776911e8d2",
        "parentId" : "3e66c2a4-01f4-4c04-af1e-183cee542783",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Just merged #2204. I don't have a separate test case for this change, but would argue that the fact that we missed the case before means we cannot exclude that we will miss it in the future. So better play it safe.",
        "createdAt" : "2017-04-09T14:30:47Z",
        "updatedAt" : "2017-04-09T14:30:47Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "a321a982a6ebdaaa924a2538866959abe0b9eb18",
    "line" : 9,
    "diffHunk" : "@@ -1,1 +728,732 @@      case param2: TypeParamRef =>\n        isMatchingApply(tp1) ||\n        canConstrain(param2) && canInstantiate(param2) ||\n        compareLower(bounds(param2), tyconIsTypeRef = false)\n      case tycon2: TypeRef =>"
  },
  {
    "id" : "06fc8d39-e7dc-4959-b6d7-a52cb4d27ccc",
    "prId" : 1893,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/1893#pullrequestreview-16054117",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0dc6c822-7331-4fb2-9149-321ce0fe7bf0",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "I don't see a widening of `tp1` in the code below?",
        "createdAt" : "2017-01-10T15:29:02Z",
        "updatedAt" : "2017-01-11T01:50:11Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "354aa532-4633-435b-ad3e-ff01a46e071d",
        "parentId" : "0dc6c822-7331-4fb2-9149-321ce0fe7bf0",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "The widening is done by all the other parts of subtyping. The important part is not to narrow the lower bound of tp2 before we had a chance to widen tp1. ",
        "createdAt" : "2017-01-11T01:46:44Z",
        "updatedAt" : "2017-01-11T01:50:11Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "918a3fba3ceeebf0bc3e0087f9ead63f4ae30381",
    "line" : 11,
    "diffHunk" : "@@ -1,1 +381,385 @@          // where the subtype relation is true without needing to add a constraint\n          // It's tricky because we might need to either appriximate tp2 by its\n          // lower bound or else widen tp1 and check that the result is a subtype of tp2.\n          // So if the constraint is not yet frozen, we do the same comparison again\n          // with a frozen constraint, which means that we get a chance to do the"
  },
  {
    "id" : "1b316500-9cf9-4d90-bf87-c712d1c85181",
    "prId" : 1760,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/1760#pullrequestreview-10786965",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "811428ce-e7eb-4856-bf3b-dd73698f17d6",
        "parentId" : null,
        "authorId" : "2dc29bea-17b2-4800-bf4f-843c62cca7de",
        "body" : "strange indentation here?",
        "createdAt" : "2016-11-30T15:52:55Z",
        "updatedAt" : "2016-11-30T15:53:12Z",
        "lastEditedBy" : "2dc29bea-17b2-4800-bf4f-843c62cca7de",
        "tags" : [
        ]
      },
      {
        "id" : "ec650ca8-2d35-450a-af52-5c6c3032469d",
        "parentId" : "811428ce-e7eb-4856-bf3b-dd73698f17d6",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "I use this style on occasion. Basically, if an end of line comment is too long I put several\r\nindented lines after the commented statement. I find it sometimes clearer than having the comments before (depends on the wording of the comment).\r\n",
        "createdAt" : "2016-11-30T16:09:47Z",
        "updatedAt" : "2016-11-30T16:09:47Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "eab74a33579636f385d4687e30e811f262d13a0e",
    "line" : 10,
    "diffHunk" : "@@ -1,1 +546,550 @@              isSubType(tp1, tp2i)\n                // see z1720.scala for a case where this can arise even in typer.\n                // Also, i1753.scala, to show why the dealias above is necessary.\n            case _ => false\n          }"
  },
  {
    "id" : "57f78368-9240-47af-8205-e6ae0f48184f",
    "prId" : 12786,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/12786#pullrequestreview-720187490",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fef156be-4084-4a00-9edb-935e11e80c37",
        "parentId" : null,
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "What is the consideration of using `isEnumValue` instead of `isEnumValueOrModule` here?",
        "createdAt" : "2021-07-30T21:05:43Z",
        "updatedAt" : "2021-07-30T21:07:12Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "03920a8a-1f93-4805-8b6b-a056d37bfe9e",
        "parentId" : "fef156be-4084-4a00-9edb-935e11e80c37",
        "authorId" : "6d71bb21-e402-4464-b2b1-8bdd8e068461",
        "body" : "So far I haven't found a need for it, the existing infrastructure doesn't need special treatment to handle modules...",
        "createdAt" : "2021-08-02T13:14:00Z",
        "updatedAt" : "2021-08-02T13:14:00Z",
        "lastEditedBy" : "6d71bb21-e402-4464-b2b1-8bdd8e068461",
        "tags" : [
        ]
      }
    ],
    "commit" : "4d6d72d4ecbe3e7d8ecb8edc6d5b8c4d3d23ae0e",
    "line" : 76,
    "diffHunk" : "@@ -1,1 +2617,2621 @@      case (tp1: TermRef, tp2: TermRef) if isEnumValueOrModule(tp1) && isEnumValueOrModule(tp2) =>\n        tp1.termSymbol != tp2.termSymbol\n      case (tp1: TermRef, tp2: TypeRef) if isEnumValue(tp1) =>\n        fullyInstantiated(tp2) && !tp1.classSymbols.exists(_.derivesFrom(tp2.symbol))\n      case (tp1: TypeRef, tp2: TermRef) if isEnumValue(tp2) =>"
  },
  {
    "id" : "79eebd99-c3db-411b-8591-7b85b67bfc00",
    "prId" : 12786,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/12786#pullrequestreview-720187490",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7701faa3-3234-4353-a6f7-3eeadf38e367",
        "parentId" : null,
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "What is the consideration of using `isEnumValue` instead of `isEnumValueOrModule` here?",
        "createdAt" : "2021-07-30T21:05:43Z",
        "updatedAt" : "2021-07-30T21:07:12Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "2cc63ead-108c-4567-8139-dd06e04895da",
        "parentId" : "7701faa3-3234-4353-a6f7-3eeadf38e367",
        "authorId" : "6d71bb21-e402-4464-b2b1-8bdd8e068461",
        "body" : "So far I haven't found a need for it, the existing infrastructure doesn't need special treatment to handle modules...",
        "createdAt" : "2021-08-02T13:14:00Z",
        "updatedAt" : "2021-08-02T13:14:00Z",
        "lastEditedBy" : "6d71bb21-e402-4464-b2b1-8bdd8e068461",
        "tags" : [
        ]
      }
    ],
    "commit" : "4d6d72d4ecbe3e7d8ecb8edc6d5b8c4d3d23ae0e",
    "line" : 76,
    "diffHunk" : "@@ -1,1 +2617,2621 @@      case (tp1: TermRef, tp2: TermRef) if isEnumValueOrModule(tp1) && isEnumValueOrModule(tp2) =>\n        tp1.termSymbol != tp2.termSymbol\n      case (tp1: TermRef, tp2: TypeRef) if isEnumValue(tp1) =>\n        fullyInstantiated(tp2) && !tp1.classSymbols.exists(_.derivesFrom(tp2.symbol))\n      case (tp1: TypeRef, tp2: TermRef) if isEnumValue(tp2) =>"
  },
  {
    "id" : "79507b62-90c7-4273-be35-37b28bddfdcf",
    "prId" : 12786,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/12786#pullrequestreview-720187490",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e999ceb9-7b8b-455b-a767-85cfba197b0e",
        "parentId" : null,
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "What is the consideration of using `isEnumValue` instead of `isEnumValueOrModule` here?",
        "createdAt" : "2021-07-30T21:05:43Z",
        "updatedAt" : "2021-07-30T21:07:12Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "0aea83e3-109a-4c58-af0b-a47f6e07f7a7",
        "parentId" : "e999ceb9-7b8b-455b-a767-85cfba197b0e",
        "authorId" : "6d71bb21-e402-4464-b2b1-8bdd8e068461",
        "body" : "So far I haven't found a need for it, the existing infrastructure doesn't need special treatment to handle modules...",
        "createdAt" : "2021-08-02T13:14:00Z",
        "updatedAt" : "2021-08-02T13:14:00Z",
        "lastEditedBy" : "6d71bb21-e402-4464-b2b1-8bdd8e068461",
        "tags" : [
        ]
      }
    ],
    "commit" : "4d6d72d4ecbe3e7d8ecb8edc6d5b8c4d3d23ae0e",
    "line" : 76,
    "diffHunk" : "@@ -1,1 +2617,2621 @@      case (tp1: TermRef, tp2: TermRef) if isEnumValueOrModule(tp1) && isEnumValueOrModule(tp2) =>\n        tp1.termSymbol != tp2.termSymbol\n      case (tp1: TermRef, tp2: TypeRef) if isEnumValue(tp1) =>\n        fullyInstantiated(tp2) && !tp1.classSymbols.exists(_.derivesFrom(tp2.symbol))\n      case (tp1: TypeRef, tp2: TermRef) if isEnumValue(tp2) =>"
  }
]
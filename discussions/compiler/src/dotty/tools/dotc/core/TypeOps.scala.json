[
  {
    "id" : "972a07c0-8d47-463c-8dbf-d3fa04fe405e",
    "prId" : 12272,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/12272#pullrequestreview-648103881",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "50920bf3-5fdf-4e86-9245-b448d9296335",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "While this addresses the most common issue, I don't think that's enough to handle things like `Tag[Long] | (Tag[Int] & SomeTrait)` or `type Tag2[X] <: Tag[X]; Tag[Long] | Tag2[Int]`. But to properly deal with all possible cases it seems that we'd need a generalization of `baseClasses` that also returns base abstract types.",
        "createdAt" : "2021-04-29T10:38:40Z",
        "updatedAt" : "2021-04-29T10:38:40Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "97cd9e62-a0f0-4a0b-b2b0-78e77f14fa48",
        "parentId" : "50920bf3-5fdf-4e86-9245-b448d9296335",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Since what we do here is an approximation anyway, I'd leave that under possible future improvement.\r\n",
        "createdAt" : "2021-04-29T11:40:53Z",
        "updatedAt" : "2021-04-29T11:40:54Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "2bde14e3-819c-4368-b469-20bf8f752eb7",
        "parentId" : "50920bf3-5fdf-4e86-9245-b448d9296335",
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Sounds good to me.",
        "createdAt" : "2021-04-29T11:43:47Z",
        "updatedAt" : "2021-04-29T11:43:50Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      }
    ],
    "commit" : "759d3bbad6dc8c7c844e57d903de200ff1358364",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +345,349 @@      case tp: OrType =>\n        (tp.tp1.dealias, tp.tp2.dealias) match\n          case (tp1 @ AppliedType(tycon1, args1), tp2 @ AppliedType(tycon2, args2))\n          if tycon1.typeSymbol == tycon2.typeSymbol && (tycon1 =:= tycon2) =>\n            mergeRefinedOrApplied(tp1, tp2)"
  },
  {
    "id" : "8df480fa-8af1-4c1a-b8b7-2dc1175d28fb",
    "prId" : 11979,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/11979#pullrequestreview-627573073",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "65d6e19f-6833-4e16-9eb1-1074026d632e",
        "parentId" : null,
        "authorId" : "75c8b660-aff3-44c8-9783-7c2d813cea08",
        "body" : "I don't think we need `derivesFrom` here. Can we just look up `ObjectClass` in cs2? `cs2.contains(defn.ObjectClass)`",
        "createdAt" : "2021-04-04T15:55:07Z",
        "updatedAt" : "2021-04-04T21:14:48Z",
        "lastEditedBy" : "75c8b660-aff3-44c8-9783-7c2d813cea08",
        "tags" : [
        ]
      },
      {
        "id" : "b3d50faf-7f18-4120-b273-5afb0dd1b29d",
        "parentId" : "65d6e19f-6833-4e16-9eb1-1074026d632e",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Looking it up is actually less efficient. ",
        "createdAt" : "2021-04-04T21:14:23Z",
        "updatedAt" : "2021-04-04T21:14:48Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "cbaac3f2a1e2890f06120b063807e1b5be4ff48e",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +199,203 @@      if cs1.head == defn.NothingClass then cs2\n      else if cs2.head == defn.NothingClass then cs1\n      else if cs1.head == defn.NullClass && !ctx.explicitNulls && cs2.head.derivesFrom(defn.ObjectClass) then cs2\n      else if cs2.head == defn.NullClass && !ctx.explicitNulls && cs1.head.derivesFrom(defn.ObjectClass) then cs1\n      else"
  },
  {
    "id" : "ea042e8a-3ffc-4bd0-bbba-39e50935d69c",
    "prId" : 11465,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/11465#pullrequestreview-602147516",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7b694337-ca26-4af2-b43f-5b72d5482984",
        "parentId" : null,
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "@smarter The CI confirmed the assertion. See https://github.com/lampepfl/dotty/actions/runs/614834038",
        "createdAt" : "2021-03-02T18:43:30Z",
        "updatedAt" : "2021-03-02T18:47:19Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      }
    ],
    "commit" : "5ff7b104f4b23367eaa9e602a330d82c107dcf1d",
    "line" : 18,
    "diffHunk" : "@@ -1,1 +435,439 @@          // Therefore, either they don't appear in the type to be avoided, or\n          // it must be a class that encloses the block whose type is to be avoided.\n          tp\n        case tp: SkolemType if partsToAvoid(Nil, tp.info).nonEmpty =>\n          range(defn.NothingType, apply(tp.info))"
  },
  {
    "id" : "48dd6a0b-b23b-4bd3-9b59-1901a75af25d",
    "prId" : 6454,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/6454#pullrequestreview-234530780",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b6f0a015-3716-4cf6-9401-19db81427bbd",
        "parentId" : null,
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "I don't understand the change in logic here. Why set `approximated = true` only if variance < 0? ",
        "createdAt" : "2019-05-06T20:23:49Z",
        "updatedAt" : "2019-05-07T16:42:27Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "1563a470-5f84-47e3-90bd-f17b27c8d164",
        "parentId" : "b6f0a015-3716-4cf6-9401-19db81427bbd",
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "If variance = 0 then we return a range, and if this range happens to be the prefix of a path, then we might be able to get away with not approximating the type by dealiasing (this is handled by the logic in ApproximatingTypeMap). On the other hand, if we do approximate then ApproximatingTypeMap will inevitably call `expandBounds` which will set the approximated flag. Maybe I could add this explanation as a comment in the code ?",
        "createdAt" : "2019-05-06T20:53:27Z",
        "updatedAt" : "2019-05-07T16:42:27Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "b549bd92-21db-48a9-b8c1-abea879323a7",
        "parentId" : "b6f0a015-3716-4cf6-9401-19db81427bbd",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Yes, would be good to add this as an explanation.\r\n",
        "createdAt" : "2019-05-07T13:57:51Z",
        "updatedAt" : "2019-05-07T16:42:27Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "502c7c9fd700ad449cf8383cf75153999ee90ba9",
    "line" : 49,
    "diffHunk" : "@@ -1,1 +69,73 @@          case _ =>\n            if (thiscls.derivesFrom(cls) && pre.baseType(thiscls).exists)\n              if (variance <= 0 && !isLegalPrefix(pre)) {\n                if (variance < 0) {\n                  approximated = true"
  },
  {
    "id" : "d8123544-bb53-4755-92f8-e55896c7d110",
    "prId" : 3061,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/3061#pullrequestreview-60857576",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "282def29-32bc-4f2d-b75f-06c879081a51",
        "parentId" : null,
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Improvement: Don't simplify & and | types given as types",
        "createdAt" : "2017-09-06T09:47:42Z",
        "updatedAt" : "2017-09-20T15:20:34Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "2e65bd581c7506e1a382d906a9c8a961fafabfff",
    "line" : 72,
    "diffHunk" : "@@ -1,1 +104,108 @@    case tp: TypeAlias =>\n      tp.derivedTypeAlias(simplify(tp.alias, theMap))\n    case AndType(l, r) if !ctx.mode.is(Mode.Type) =>\n      simplify(l, theMap) & simplify(r, theMap)\n    case OrType(l, r) if !ctx.mode.is(Mode.Type) =>"
  },
  {
    "id" : "52996709-010b-4050-8436-11840d16e04d",
    "prId" : 3061,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/3061#pullrequestreview-60857788",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5c51e9c9-ee41-447d-ac2d-c6f282339d03",
        "parentId" : null,
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Complication: need to duplicate merge logic between RefinedTypes and AppliedTypes",
        "createdAt" : "2017-09-06T09:48:38Z",
        "updatedAt" : "2017-09-20T15:20:34Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "2e65bd581c7506e1a382d906a9c8a961fafabfff",
    "line" : 95,
    "diffHunk" : "@@ -1,1 +157,161 @@            case _ => fail\n          }\n        case tp1 @ AppliedType(tycon1, args1) =>\n          tp2 match {\n            case AppliedType(tycon2, args2) =>"
  },
  {
    "id" : "ee4608e9-903f-46df-af6a-75d8466c4f34",
    "prId" : 2331,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/2331#pullrequestreview-35656297",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "78d635c2-7511-47ee-8522-e0dca8305bfb",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "`enterArgBindings` sets the info using a `LazyType`, shouldn't the same thing be done here?",
        "createdAt" : "2017-05-01T21:07:41Z",
        "updatedAt" : "2017-05-01T21:14:49Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "f8a6e48b-d93b-4c41-b863-9772c11922d2",
        "parentId" : "78d635c2-7511-47ee-8522-e0dca8305bfb",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "It seems we get away with it. I have a tendency to wait for an actual CyclicReference popping up before we take that measure.",
        "createdAt" : "2017-05-01T21:40:43Z",
        "updatedAt" : "2017-05-01T21:40:43Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "1ebff50e53f2e83662ea13cf26320c62d1c248e7",
    "line" : 117,
    "diffHunk" : "@@ -1,1 +402,406 @@      case info @ TypeAlias(TypeRef(_: ThisType, `from`)) if info.variance == to.variance =>\n        val existing = decls.lookup(argSym.name)\n        if (existing.exists) existing.info = existing.info & to\n        else enterArgBinding(argSym, to, cls, decls)\n      case _ =>"
  },
  {
    "id" : "3b4a150b-de93-4521-af7f-abd4e75817ea",
    "prId" : 2331,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/2331#pullrequestreview-35649697",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "711b1198-8f60-4c5d-a48b-7a506f52ca77",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "The params are not in the same order in the doc than in the declaration.",
        "createdAt" : "2017-05-01T21:08:58Z",
        "updatedAt" : "2017-05-01T21:14:49Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      }
    ],
    "commit" : "1ebff50e53f2e83662ea13cf26320c62d1c248e7",
    "line" : 104,
    "diffHunk" : "@@ -1,1 +389,393 @@   *  If multiple forwarders would be generated, join their `to` types with an `&`.\n   *\n   *  @param cls           The class for which parameter bindings should be forwarded\n   *  @param decls\t       Its scope\n   *  @param parentRefs    The parent type references of `cls`"
  },
  {
    "id" : "65cca0fb-73d4-4480-a16e-102d776b131e",
    "prId" : 1848,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/1848#pullrequestreview-14030456",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fea1695c-16a5-467c-8565-7295d4df9ca2",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Unrelated change?",
        "createdAt" : "2016-12-21T17:46:09Z",
        "updatedAt" : "2016-12-21T19:19:28Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "4ae234e4-5bca-409d-b0ca-0efbcd78f00d",
        "parentId" : "fea1695c-16a5-467c-8565-7295d4df9ca2",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "No it's related. Before we were running into the member/asSeenFrom mutual recursion we stackoverflowed here. Avoiding this by not piling up the same annotation makes sense independently.\r\n",
        "createdAt" : "2016-12-21T19:15:21Z",
        "updatedAt" : "2016-12-21T19:19:28Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "d1b7f2c39561ae64c95b94242fe3bc91beb8af25",
    "line" : 16,
    "diffHunk" : "@@ -1,1 +70,74 @@              ctx.base.unsafeNonvariant = ctx.runId\n              pre match {\n                case AnnotatedType(_, ann) if ann.symbol == defn.UnsafeNonvariantAnnot => pre\n                case _ => AnnotatedType(pre, Annotation(defn.UnsafeNonvariantAnnot, Nil))\n              }"
  }
]
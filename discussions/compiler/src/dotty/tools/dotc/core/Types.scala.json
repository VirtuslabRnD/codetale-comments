[
  {
    "id" : "d1d6a9ea-0a00-463c-8c5a-5cc3817848e4",
    "prId" : 12928,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/12928#pullrequestreview-692942356",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "545a650f-f488-416e-9f2f-702388ab8f7f",
        "parentId" : null,
        "authorId" : "128563de-a925-4397-af34-450c7978a8d2",
        "body" : "```suggestion\r\n    /** If this is a OrType, the number of factors that match `soft`,\r\n```",
        "createdAt" : "2021-06-25T15:30:35Z",
        "updatedAt" : "2021-06-28T12:14:43Z",
        "lastEditedBy" : "128563de-a925-4397-af34-450c7978a8d2",
        "tags" : [
        ]
      }
    ],
    "commit" : "15d54c9ccbef8a8857f857d1e3b4dec7223817e6",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +1720,1724 @@    def andFactorCount: Int = 1\n\n    /** If this is a OrType, the number of factors if that match `soft`,\n     *  1 for all other types.\n     */"
  },
  {
    "id" : "679bc76c-a699-4ac8-90bf-c6cec9551cdd",
    "prId" : 12153,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/12153#pullrequestreview-639822674",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "53034e6b-ab55-485b-afd8-75aebc96c69c",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Why do this in translucentSuperType and not superType? At the very least it means the documentation of the base translucentSuperType in https://github.com/lampepfl/dotty/blob/f618dd66a93a962c99c22eb586dbc93d7d410988/compiler/src/dotty/tools/dotc/core/Types.scala#L1891-L1892 is now incorrect.",
        "createdAt" : "2021-04-20T09:48:51Z",
        "updatedAt" : "2021-04-20T12:33:32Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "f7e9c35c-e352-416e-8a3d-365238c04a07",
        "parentId" : "53034e6b-ab55-485b-afd8-75aebc96c69c",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "I fixed the comment, which now also explains why we can't do it in `superType`.\r\n",
        "createdAt" : "2021-04-20T11:05:33Z",
        "updatedAt" : "2021-04-20T12:33:32Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "c52ae89f-535a-4b33-8181-bf8cc5e632e8",
        "parentId" : "53034e6b-ab55-485b-afd8-75aebc96c69c",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "As far as I can see we did not normalize match types when computing the signatures and erasures of inherited members. That means we did not detect logical overrides, and that means we did not generate bridges where they would have been necessary. \r\n\r\nMatch types that can be reduced directly in signatures were reduced. For instance in\r\n```scala\r\n\r\n  type M[X] = X match\r\n    case Int => String\r\n    case _ => X\r\n\r\n  def test(x: M[Int]): Int = ???\r\n```\r\nthe signature of `test` is `String => Int`.\r\n",
        "createdAt" : "2021-04-20T11:17:26Z",
        "updatedAt" : "2021-04-20T12:33:32Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "71bac46255857a16f75af3904c700b0bf92e9af5",
    "line" : 22,
    "diffHunk" : "@@ -1,1 +4020,4024 @@        tycon.translucentSuperType.applyIfParameterized(args)\n      case _ =>\n        tryNormalize.orElse(superType)\n    }\n"
  },
  {
    "id" : "9f20deb4-e6a8-455e-9e5a-337a5674512c",
    "prId" : 12153,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/12153#pullrequestreview-639824528",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "eb43cca4-5903-4b90-826e-93a62d8d6766",
        "parentId" : null,
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "```suggestion\r\n     *   - applied types are matchtype-reduced if possible\r\n```",
        "createdAt" : "2021-04-20T11:19:43Z",
        "updatedAt" : "2021-04-20T12:33:32Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "71bac46255857a16f75af3904c700b0bf92e9af5",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +1891,1895 @@    /** Same as superType, except for two differences:\n     *   - opaque types are treated as transparent aliases\n     *   - applied type are matchtype-reduced if possible\n     *\n     *  Note: the reason to reduce match type aliases here and not in `superType`"
  },
  {
    "id" : "016d128f-06e0-4126-8f9e-efbf0a75cbf3",
    "prId" : 10985,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/10985#pullrequestreview-563578890",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "209f32d9-b495-4336-8ffd-51dcd5de9655",
        "parentId" : null,
        "authorId" : "128563de-a925-4397-af34-450c7978a8d2",
        "body" : "should there be a case for `RecType`?",
        "createdAt" : "2021-01-07T15:27:26Z",
        "updatedAt" : "2021-01-07T16:02:19Z",
        "lastEditedBy" : "128563de-a925-4397-af34-450c7978a8d2",
        "tags" : [
        ]
      }
    ],
    "commit" : "1ecc48baa1e86a9c4f45ac00921355b69938d2c7",
    "line" : 19,
    "diffHunk" : "@@ -1,1 +347,351 @@    def unusableForInference(using Context): Boolean = widenDealias match\n      case AppliedType(tycon, args) => tycon.unusableForInference || args.exists(_.unusableForInference)\n      case RefinedType(parent, _, rinfo) => parent.unusableForInference || rinfo.unusableForInference\n      case TypeBounds(lo, hi) => lo.unusableForInference || hi.unusableForInference\n      case tp: AndOrType => tp.tp1.unusableForInference || tp.tp2.unusableForInference"
  },
  {
    "id" : "21bf5ffa-2ece-4377-8b91-a2f2d844d325",
    "prId" : 9884,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/9884#pullrequestreview-566165467",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bc7edc9f-6e31-4ac8-8fe1-e585bbf71aca",
        "parentId" : null,
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Doc comment needs to be updated to reflect ctx.explicitNulls behavior.",
        "createdAt" : "2021-01-12T11:19:19Z",
        "updatedAt" : "2021-03-10T04:37:05Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "68b79fae26e20a05e0f72943d2d0a4a332ad8ff2",
    "line" : 120,
    "diffHunk" : "@@ -1,1 +1089,1093 @@     *  check the types. This is because we are using a relaxed rule (ignoring `Null` types)\n     *  to check overriding Java methods.\n     */\n    def matches(that: Type)(using Context): Boolean = {\n      record(\"matches\")"
  },
  {
    "id" : "a302aa8f-ca20-49c7-b7f5-9379222842b2",
    "prId" : 9618,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/9618#pullrequestreview-473209515",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b75af19f-12f2-4cdd-91bc-e476a6d9cfcb",
        "parentId" : null,
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "In `map` and `fold`, do we need to recurse on `typcon`? The semantics is quite different from `TypeMap` and `TypeAccumulator`, and is specific to `Substituters`. Maybe add a note here to avoid misuse?",
        "createdAt" : "2020-08-24T08:10:13Z",
        "updatedAt" : "2020-08-24T17:19:12Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      }
    ],
    "commit" : "eaf6033fbfb36ce82a7d83aeceb6fbbfb404e3ff",
    "line" : 151,
    "diffHunk" : "@@ -1,1 +3856,3860 @@        case arg :: rest => foldArgs(op(x, arg), rest)\n        case nil => x\n      foldArgs(op(x, tycon), args)\n\n    override def tryNormalize(using Context): Type = tycon match {"
  },
  {
    "id" : "d14b9be2-0619-4265-bf2b-666db9b69759",
    "prId" : 9617,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/9617#pullrequestreview-473244358",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "538069fd-9b77-42e9-8389-225ee3b7d7da",
        "parentId" : null,
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "This change is in conflict with the changes in #9618.",
        "createdAt" : "2020-08-24T08:59:15Z",
        "updatedAt" : "2020-08-24T08:59:35Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      }
    ],
    "commit" : "cc8a73e6eab2ca68920d211f5210ef03839aa738",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +3221,3225 @@          nil\n      companion(paramNames)(\n          x => substParams(paramInfos, x),\n          x => resType.subst(this, x))\n"
  },
  {
    "id" : "21fe2350-6f37-4761-be94-aacd05f39ec0",
    "prId" : 8819,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/8819#pullrequestreview-404606896",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6ce19696-06cb-4d65-94af-c17091f6eef2",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "`currentSignature` is passed as an argument to `disambiguate` which passes it to `Denotation#atSignature`. If we're after erasure and the signature of the denotation is different from the pre-erasure signature that `currentSignature`, then `atSignature` would fail to match anything, wouldn't it? Or is it this OK because overloaded denotations do not appear after erasure at all? If so then `currentSignature` wouldn't need to do anything special.",
        "createdAt" : "2020-04-29T11:31:36Z",
        "updatedAt" : "2020-05-22T16:46:52Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "fb493864-8e73-4d85-8e32-e643b405068f",
        "parentId" : "6ce19696-06cb-4d65-94af-c17091f6eef2",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Yes, after erasure all references should be symbolic, so there's no need to do overloading resolution.\r\n",
        "createdAt" : "2020-05-03T11:09:08Z",
        "updatedAt" : "2020-05-22T16:46:52Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "1818b99f7cec44e70ea75eb41e63e4fd0b7d7647",
    "line" : 27,
    "diffHunk" : "@@ -1,1 +1913,1917 @@     *  some symbols change their signature at erasure.\n     */\n    private def currentSignature(implicit ctx: Context): Signature =\n      if ctx.runId == mySignatureRunId then mySignature\n      else"
  },
  {
    "id" : "1e2db93a-1c05-4b49-854f-0e9333677946",
    "prId" : 8529,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/8529#pullrequestreview-378912037",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d84b15de-51e2-4764-bea3-f8bfc4fe507f",
        "parentId" : null,
        "authorId" : "998ba0f7-d6a6-448f-a3ba-0d2237ed0cf9",
        "body" : "I guess there's no good way to handle parameter names when intersecting two method types?\r\n\r\nAnd sorry about the off-topic remark, but I'm a bit surprised to see infix with multiple parameter lists, isn't that an anti-pattern? I see it was discussed on https://github.com/lampepfl/dotty/pull/4311#issuecomment-381104279",
        "createdAt" : "2020-03-16T07:57:31Z",
        "updatedAt" : "2020-03-16T07:57:38Z",
        "lastEditedBy" : "998ba0f7-d6a6-448f-a3ba-0d2237ed0cf9",
        "tags" : [
        ]
      },
      {
        "id" : "d51c622c-9744-42e7-aff7-78c30710c4c4",
        "parentId" : "d84b15de-51e2-4764-bea3-f8bfc4fe507f",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "\r\nYes, we should change the infix part. ",
        "createdAt" : "2020-03-21T11:32:05Z",
        "updatedAt" : "2020-03-21T11:32:06Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "465b81b2586e64c02d07841ca813122b7fbba1f2",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +674,678 @@        }\n        else\n          val joint = pdenot & (\n            new JointRefDenotation(NoSymbol, rinfo, Period.allInRun(ctx.runId), pre),\n            pre,"
  },
  {
    "id" : "29d33e9a-042f-47d0-9ad9-7b9bb544af50",
    "prId" : 8082,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/8082#pullrequestreview-350263262",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f77015dc-49a9-4bc7-ad9b-e79923e00b6b",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Maybe a bit more clear:\r\n```suggestion\r\n      def expand(tp: Type, useGivenVariances: Boolean) =\r\n```",
        "createdAt" : "2020-01-30T13:19:02Z",
        "updatedAt" : "2020-01-31T13:40:50Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      }
    ],
    "commit" : "2396fe9ddec940c8f7bbadc99577e12fadadc752",
    "line" : 327,
    "diffHunk" : "@@ -1,1 +3601,3605 @@     */\n    def boundsFromParams[PI <: ParamInfo.Of[TypeName]](params: List[PI], bounds: TypeBounds)(implicit ctx: Context): TypeBounds = {\n      def expand(tp: Type, useVariances: Boolean) =\n        if params.nonEmpty && useVariances then\n          apply(params.map(_.paramName), params.map(_.paramVariance))("
  },
  {
    "id" : "cf7e5a01-713d-431d-8efa-99af56116162",
    "prId" : 8082,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/8082#pullrequestreview-350263262",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "498217ef-1ca0-46f8-87b7-ca58f4b1cde0",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Could be called `useGivenVariances` for extra clarity.",
        "createdAt" : "2020-01-30T13:50:32Z",
        "updatedAt" : "2020-01-31T13:40:50Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      }
    ],
    "commit" : "2396fe9ddec940c8f7bbadc99577e12fadadc752",
    "line" : 327,
    "diffHunk" : "@@ -1,1 +3601,3605 @@     */\n    def boundsFromParams[PI <: ParamInfo.Of[TypeName]](params: List[PI], bounds: TypeBounds)(implicit ctx: Context): TypeBounds = {\n      def expand(tp: Type, useVariances: Boolean) =\n        if params.nonEmpty && useVariances then\n          apply(params.map(_.paramName), params.map(_.paramVariance))("
  },
  {
    "id" : "9c1dbd1f-b6e4-4dd9-8711-6cce46bc5a35",
    "prId" : 6050,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/6050#pullrequestreview-213109410",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d0e523d6-4ab9-41de-a202-eca9188489c0",
        "parentId" : null,
        "authorId" : "6d71bb21-e402-4464-b2b1-8bdd8e068461",
        "body" : "Having to do this kind of distinction in `TypeMap` makes me wonder if reusing `LambdaType`-s to encode cases of `MatchType` is the correct approach. Maybe `MatchCase` should simply be its own independent type...",
        "createdAt" : "2019-03-11T10:56:33Z",
        "updatedAt" : "2019-03-11T22:22:25Z",
        "lastEditedBy" : "6d71bb21-e402-4464-b2b1-8bdd8e068461",
        "tags" : [
        ]
      },
      {
        "id" : "3e4af025-94e2-4417-8d6b-5f3f77851b28",
        "parentId" : "d0e523d6-4ab9-41de-a202-eca9188489c0",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "There's a lot of machinery associated with LambdaType which would have to be duplicated. So I think what we have is the lesser evil.\r\n",
        "createdAt" : "2019-03-11T22:05:25Z",
        "updatedAt" : "2019-03-11T22:22:25Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "33d3622eda81719631b79c67c31797272f315e7f",
    "line" : 16,
    "diffHunk" : "@@ -1,1 +4420,4424 @@            val restpe = tp.resultType\n            val saved = variance\n            variance = if (defn.MatchCase.isInstance(restpe)) 0 else -variance\n            val ptypes1 = tp.paramInfos.mapConserve(this).asInstanceOf[List[tp.PInfo]]\n            variance = saved"
  },
  {
    "id" : "dbc6e0ef-5082-445c-9f97-e320f2f68b1a",
    "prId" : 5287,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/5287#pullrequestreview-168765497",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a7e479e2-59b8-49c1-82e0-a78952970d0e",
        "parentId" : null,
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "`validated` is not used?",
        "createdAt" : "2018-10-22T19:40:40Z",
        "updatedAt" : "2018-10-22T21:10:36Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "5aff7244-6c22-424a-95ba-5acd5fbc80e0",
        "parentId" : "a7e479e2-59b8-49c1-82e0-a78952970d0e",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Yes, I do use if occasionally for debugging, and decided to leave it in for others to use as well if needed.",
        "createdAt" : "2018-10-26T10:39:08Z",
        "updatedAt" : "2018-10-26T10:39:09Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "378ddce365b68717363e8f29abddcd45b9815880",
    "line" : 63,
    "diffHunk" : "@@ -1,1 +2209,2213 @@    def validated(implicit ctx: Context): this.type = {\n      this\n    }\n  }\n"
  },
  {
    "id" : "447e489c-262e-4b8d-9bc1-c2c491b8c042",
    "prId" : 5287,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/5287#pullrequestreview-168765702",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "18b63378-f7c7-4568-acd2-b8c30839d9eb",
        "parentId" : null,
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "I guess `adapted.eq(this)` is a performance tweak, semantically we can drop it without changing the result.",
        "createdAt" : "2018-10-22T20:12:19Z",
        "updatedAt" : "2018-10-22T21:10:36Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "7f67b9aa-a809-4313-bd38-077161a7e591",
        "parentId" : "18b63378-f7c7-4568-acd2-b8c30839d9eb",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Exact.\r\n",
        "createdAt" : "2018-10-26T10:39:47Z",
        "updatedAt" : "2018-10-26T10:39:47Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "378ddce365b68717363e8f29abddcd45b9815880",
    "line" : 51,
    "diffHunk" : "@@ -1,1 +2104,2108 @@          else this\n        result.setDenot(denot)\n        result.asInstanceOf[ThisType]\n      }\n      else // don't assign NoDenotation, we might need to recover later. Test case is pos/avoid.scala."
  },
  {
    "id" : "b1bfd212-578c-4fdf-955b-5b979e83a526",
    "prId" : 4672,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/4672#pullrequestreview-243731706",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "390dfb05-0685-49eb-9c0a-956132fa5649",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "`Signature#prepend` ends up calling `TypeErasure#sigName`, changing that method to handle PolyFunction should avoid the need for a special case here.",
        "createdAt" : "2019-05-29T19:49:00Z",
        "updatedAt" : "2019-05-30T13:05:55Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "93595677-f42f-4dc3-a0db-dc0ebd9b28a7",
        "parentId" : "390dfb05-0685-49eb-9c0a-956132fa5649",
        "authorId" : "2c02aea2-3019-42f4-9678-8a2da637c660",
        "body" : "Done.",
        "createdAt" : "2019-05-30T10:39:06Z",
        "updatedAt" : "2019-05-30T13:05:55Z",
        "lastEditedBy" : "2c02aea2-3019-42f4-9678-8a2da637c660",
        "tags" : [
        ]
      }
    ],
    "commit" : "112aa55d80bfd626b336fbc57fb4f3b5caeec31c",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +3198,3202 @@    def computeSignature(implicit ctx: Context): Signature = {\n      val params = if (isErasedMethod) Nil else paramInfos\n      resultSignature.prepend(params, isJavaMethod)\n    }\n"
  },
  {
    "id" : "4dc35dc8-d85e-4ba0-b532-8c386eaa6ab3",
    "prId" : 4626,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/4626#pullrequestreview-127234791",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4497b256-7dd4-492c-b019-d574ae169eaf",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Shouldn't the cache be invalidated at the start of a new run?",
        "createdAt" : "2018-06-08T15:05:47Z",
        "updatedAt" : "2018-06-08T15:05:47Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "fe07fbab-fb12-4329-8b43-7af2d4adaed1",
        "parentId" : "4497b256-7dd4-492c-b019-d574ae169eaf",
        "authorId" : "70ef1594-3bb7-4579-b053-2189b409b5dc",
        "body" : "I was thinking about that too, but decided that it's probably fine given the internal nature of such annotations. Then again, we do expose RefiningAnnotation in the public `scala.annotation` package.",
        "createdAt" : "2018-06-08T16:43:02Z",
        "updatedAt" : "2018-06-08T16:43:02Z",
        "lastEditedBy" : "70ef1594-3bb7-4579-b053-2189b409b5dc",
        "tags" : [
        ]
      }
    ],
    "commit" : "dde7ce94e35697a6daa3c37e1c7740510c9580aa",
    "line" : 155,
    "diffHunk" : "@@ -1,1 +3721,3725 @@\n    def isRefining(implicit ctx: Context) = {\n      if (!isRefiningKnown) {\n        isRefiningCache = annot.symbol.derivesFrom(defn.RefiningAnnotationClass)\n        isRefiningKnown = true"
  },
  {
    "id" : "4fd28359-7e11-4b06-bff9-08bbe0b8968f",
    "prId" : 4411,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/4411#pullrequestreview-116171730",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "cd31b443-e9fc-471e-b059-3af027f8a688",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Might be worth explicitly checking that an error happened like other commits in this PR do, e.g.:\r\n```scala\r\nif (!given.isValueType) {\r\n  assert(!given.exists || ctx.reporter.errorsReported)\r\n  appliedRef\r\n}\r\n```",
        "createdAt" : "2018-04-29T14:34:02Z",
        "updatedAt" : "2018-04-29T16:45:57Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "87a46974-8fcc-4745-bbf2-31755ff368b2",
        "parentId" : "cd31b443-e9fc-471e-b059-3af027f8a688",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "The given type might be higher-kinded (in fact that's what it was in the test) but this would be detected only later.\r\n",
        "createdAt" : "2018-04-29T14:40:18Z",
        "updatedAt" : "2018-04-29T16:45:57Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "266c3830-01d1-4316-8837-38ae8a719bd0",
        "parentId" : "cd31b443-e9fc-471e-b059-3af027f8a688",
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "OK, in that case maybe just add a comment explaining that non-value types self can only happen with erroneous code? Otherwise readers of this code might be puzzled.",
        "createdAt" : "2018-04-29T16:26:40Z",
        "updatedAt" : "2018-04-29T16:45:57Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      }
    ],
    "commit" : "690321d2aa75001873bf4a2e5183cacf6bffe61f",
    "line" : 73,
    "diffHunk" : "@@ -1,1 +3479,3483 @@        selfTypeCache = {\n          val given = cls.givenSelfType\n          if (!given.isValueType) appliedRef\n          else if (cls is Module) given\n          else if (ctx.erasedTypes) appliedRef"
  },
  {
    "id" : "8417b08f-a4fa-4c13-a288-68e748c9b4cc",
    "prId" : 4385,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/4385#pullrequestreview-115667891",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d1a74e75-f967-4405-a418-ad4c50a034e5",
        "parentId" : null,
        "authorId" : "348fab8e-49e2-442e-884d-850c7f41fdde",
        "body" : "Nit: why change formatter to `s`?",
        "createdAt" : "2018-04-26T15:03:59Z",
        "updatedAt" : "2018-06-04T16:47:35Z",
        "lastEditedBy" : "348fab8e-49e2-442e-884d-850c7f41fdde",
        "tags" : [
        ]
      },
      {
        "id" : "1c0f5643-4d16-4057-a781-e357f9726117",
        "parentId" : "d1a74e75-f967-4405-a418-ad4c50a034e5",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Avoid possible crashes when trying to show `pre`.",
        "createdAt" : "2018-04-26T17:09:13Z",
        "updatedAt" : "2018-06-04T16:47:35Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "7fea20774f89ad11c728546e11ffa54e06128def",
    "line" : 38,
    "diffHunk" : "@@ -1,1 +670,674 @@      catch {\n        case ex: Throwable =>\n          core.println(s\"findMember exception for $this member $name, pre = $pre, recCount = $recCount\")\n\n          def showPrefixSafely(pre: Type)(implicit ctx: Context): String = pre.stripTypeVar match {"
  },
  {
    "id" : "d97b0156-314a-4120-84ab-16af0e279a3c",
    "prId" : 4156,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/4156#pullrequestreview-106156608",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "16467d8b-c87c-4994-a08a-7dab0cac6bd5",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Stray comment?",
        "createdAt" : "2018-03-22T14:59:24Z",
        "updatedAt" : "2018-03-22T14:59:24Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      }
    ],
    "commit" : "1e34d2de47b1f0b19c3c1ec3137a3d9174f6d3aa",
    "line" : 20,
    "diffHunk" : "@@ -1,1 +522,526 @@              go(tp.superType)\n          }\n        case tp: ThisType => // ??? inline\n          goThis(tp)\n        case tp: RefinedType =>"
  },
  {
    "id" : "0ea4687c-e7b8-4f9a-ba5d-8cb52d6f84ba",
    "prId" : 4152,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/4152#pullrequestreview-106522674",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ddb05fc4-84d9-41d3-be83-88609d2fe7fe",
        "parentId" : null,
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Is that really its type? By what means was that computed? I would have thought that it's unsound to assume the argument type as written.",
        "createdAt" : "2018-03-23T13:59:47Z",
        "updatedAt" : "2018-03-23T14:06:30Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "dd011c48-7a25-4fd9-af41-705c6a36d2d8",
        "parentId" : "ddb05fc4-84d9-41d3-be83-88609d2fe7fe",
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "That's the type I saw, it comes from `tp.abstractTermMembers` above where `tp` is an AppliedType, I guess this cannot happen in regular code because you would always have a TermRef at this point.",
        "createdAt" : "2018-03-23T14:48:45Z",
        "updatedAt" : "2018-03-23T14:48:45Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      }
    ],
    "commit" : "6127c5b4b4afac28a182e5fbeef4fed0b8580823",
    "line" : 42,
    "diffHunk" : "@@ -1,1 +3833,3837 @@              // the single abstract method will have type:\n              //\n              //     (x: Function[_ >: String, _ <: Int]#T): Function[_ >: String, _ <: Int]#R\n              //\n              // which is not implementable outside of the scope of Function."
  },
  {
    "id" : "daf560e2-2dc5-4d37-9598-46a9f929b3e8",
    "prId" : 4082,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/4082#pullrequestreview-102262001",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7ab8ee85-a70b-4243-9682-208592827704",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Why did this get turned off?",
        "createdAt" : "2018-03-08T09:33:59Z",
        "updatedAt" : "2018-03-08T09:33:59Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "2d0198c8-562f-4c56-8a4d-65aed20335c9",
        "parentId" : "7ab8ee85-a70b-4243-9682-208592827704",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "It's a field in every type, and we don't need it - it's used nowhere.",
        "createdAt" : "2018-03-08T11:05:09Z",
        "updatedAt" : "2018-03-08T11:05:09Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "743e8d8925586da03ef04740ebe65d3eee3c9311",
    "line" : 8,
    "diffHunk" : "@@ -1,1 +90,94 @@\n//    // debug only: a unique identifier for a type\n//    val uniqId = {\n//      nextId = nextId + 1\n//      if (nextId == 19555)"
  },
  {
    "id" : "d67448c3-b6db-482a-855e-01b4ea608a49",
    "prId" : 3978,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/3978#pullrequestreview-97538536",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "18c5876a-ee56-47da-a64a-459a49f54ca6",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Any reason to start at 1 and not 0?",
        "createdAt" : "2018-02-15T22:18:20Z",
        "updatedAt" : "2018-02-19T17:34:10Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "4150d30b-addd-43a0-b5d6-34c5f17fe637",
        "parentId" : "18c5876a-ee56-47da-a64a-459a49f54ca6",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "I just don't know how a 0 behaves for hashing.mix",
        "createdAt" : "2018-02-19T13:16:00Z",
        "updatedAt" : "2018-02-19T17:34:10Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "15644d68057de20490988ab7c1f075a323bfff08",
    "line" : 106,
    "diffHunk" : "@@ -1,1 +1548,1552 @@      avoidSpecialHashes(\n        if (bs == null) System.identityHashCode(this)\n        else recur(1, bs.tp, bs.next))\n    }\n"
  },
  {
    "id" : "e264b9d3-62e7-46a8-a38c-2b380f5759e5",
    "prId" : 3978,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/3978#pullrequestreview-97540608",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0539c46f-a967-44d8-826e-0fdfd0143c66",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Why is there no `iso` implementation for `MethodType` ?",
        "createdAt" : "2018-02-15T23:50:02Z",
        "updatedAt" : "2018-02-19T17:34:10Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "1742d376-0391-4759-9fd6-34f0ce218140",
        "parentId" : "0539c46f-a967-44d8-826e-0fdfd0143c66",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Good point; we need one since MethodTypes can appear in refinements.",
        "createdAt" : "2018-02-19T13:23:25Z",
        "updatedAt" : "2018-02-19T17:34:10Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "15644d68057de20490988ab7c1f075a323bfff08",
    "line" : 391,
    "diffHunk" : "@@ -1,1 +2868,2872 @@      paramInfosExp: MethodType => List[Type],\n      resultTypeExp: MethodType => Type)\n    extends MethodOrPoly with TermLambda with NarrowCached { thisMethodType =>\n    import MethodType._\n"
  },
  {
    "id" : "17fde6d1-f77e-487b-97be-07389695c967",
    "prId" : 3494,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/3494#pullrequestreview-81493848",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ad872530-ae4a-4923-94d9-d2a6d989c6fa",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "The `finish` call could be moved here to wrap the entire expression",
        "createdAt" : "2017-11-30T16:55:19Z",
        "updatedAt" : "2017-12-06T12:04:30Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "7e9564be-584e-4d86-a360-9f37cb091e48",
        "parentId" : "ad872530-ae4a-4923-94d9-d2a6d989c6fa",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "True. I left it like this for better debuggability. If checkDenot (called from setDenot) fails with an AssertionError, we know exactly how we got there.",
        "createdAt" : "2017-12-06T11:43:19Z",
        "updatedAt" : "2017-12-06T12:04:30Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "759af1e995b2ba9fd9d81ca6ccd79002a94a88b3",
    "line" : 284,
    "diffHunk" : "@@ -1,1 +1645,1649 @@      }\n\n      def fromDesignator = designator match {\n        case name: Name =>\n          val sym = lastSymbol"
  },
  {
    "id" : "126cccca-aa96-47e7-9322-3562e7d86e00",
    "prId" : 3494,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/3494#pullrequestreview-80198049",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f8a13a9a-813e-46d7-8479-6988235da63b",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "This comment does not seem to match the implementation: `infoDependsOnPrefix` calls `membersNeedAsSeenFrom(prefix)` which will return false if `prefix` is a statically accessible object.",
        "createdAt" : "2017-11-30T17:06:18Z",
        "updatedAt" : "2017-12-06T12:04:30Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      }
    ],
    "commit" : "759af1e995b2ba9fd9d81ca6ccd79002a94a88b3",
    "line" : 492,
    "diffHunk" : "@@ -1,1 +1771,1775 @@      symd.maybeOwner.membersNeedAsSeenFrom(prefix) && !symd.is(NonMember)\n\n    /** Is this a reference to a class or object member? */\n    def isMemberRef(implicit ctx: Context) = designator match {\n      case sym: Symbol => infoDependsOnPrefix(sym, prefix)"
  },
  {
    "id" : "ec0f00db-8cf3-4c53-b1a4-f788ce04a13f",
    "prId" : 3494,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/3494#pullrequestreview-81494752",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "979c909e-5100-44ea-bacd-a19a9fbd8598",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Given the name of this method and its documentation, it's surprising that it can mutate `this`.",
        "createdAt" : "2017-11-30T17:19:38Z",
        "updatedAt" : "2017-12-06T12:04:30Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "8c0f3407-b6f9-4360-b19c-71582a3ab654",
        "parentId" : "979c909e-5100-44ea-bacd-a19a9fbd8598",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Good point. I'll update the docs.",
        "createdAt" : "2017-12-06T11:47:15Z",
        "updatedAt" : "2017-12-06T12:04:30Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "759af1e995b2ba9fd9d81ca6ccd79002a94a88b3",
    "line" : 575,
    "diffHunk" : "@@ -1,1 +1911,1915 @@        if (adapted ne this) adapted.withDenot(denot).asInstanceOf[ThisType]\n        else {\n          setDenot(denot)\n          this\n        }"
  },
  {
    "id" : "b0993bd9-a629-426a-95f2-b3289057658e",
    "prId" : 3287,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/3287#pullrequestreview-67897627",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8e41f735-2e51-4e20-a8bc-4988f9f993c8",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "That was already the case before #3239, but why is this equals and not eq?",
        "createdAt" : "2017-10-08T19:40:55Z",
        "updatedAt" : "2017-10-09T07:05:30Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "bce7983a-7d85-4cda-a802-201436672a74",
        "parentId" : "8e41f735-2e51-4e20-a8bc-4988f9f993c8",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "I am not even sure that `equals` is needed. But the idea is that, since many types get a compiler generated `equals` since they are case classes, the rest of the types would conform to that.",
        "createdAt" : "2017-10-09T06:57:04Z",
        "updatedAt" : "2017-10-09T07:05:30Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "8d0109a3628d01a9dab4358b2daacc73280bf985",
    "line" : 33,
    "diffHunk" : "@@ -1,1 +2619,2623 @@        paramNames.equals(that.paramNames) &&\n        paramInfos.equals(that.paramInfos) &&\n        resType.equals(that.resType) &&\n        companion.eq(that.companion)\n      case _ =>"
  },
  {
    "id" : "4426105e-55e2-4c61-8015-6685afbe2350",
    "prId" : 3061,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/3061#pullrequestreview-60864761",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "da08f20f-072e-42d8-82a3-dc8544da6202",
        "parentId" : null,
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Complication: Handle missing parents due to incomplete denotations here. (But it's better than to do it via suspensions as was done before).",
        "createdAt" : "2017-09-06T10:17:01Z",
        "updatedAt" : "2017-09-20T15:20:34Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "2e65bd581c7506e1a382d906a9c8a961fafabfff",
    "line" : 279,
    "diffHunk" : "@@ -1,1 +1164,1168 @@        tycon.parents.map(_.subst(tycon.typeSymbol.typeParams, args)) // @!!! cache?\n      case tp: TypeRef =>\n        if (tp.info.isInstanceOf[TempClassInfo]) {\n          tp.reloadDenot()\n          assert(!tp.info.isInstanceOf[TempClassInfo])"
  },
  {
    "id" : "32bbe7a3-e3c5-47db-b0cf-b40bf6e99190",
    "prId" : 3061,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/3061#pullrequestreview-60905281",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "67c53e0b-7565-479c-9c6a-cd5138d38048",
        "parentId" : null,
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Complication: Need specific logic to substitute an actual argument for a formal parameter. This is somewhat more involved than the previous matchParams, which was removed.",
        "createdAt" : "2017-09-06T13:16:00Z",
        "updatedAt" : "2017-09-20T15:20:34Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "2e65bd581c7506e1a382d906a9c8a961fafabfff",
    "line" : 418,
    "diffHunk" : "@@ -1,1 +1786,1790 @@    /** The argument corresponding to class type parameter `tparam` as seen from\n     *  prefix `pre`.\n     */\n    def argForParam(pre: Type)(implicit ctx: Context): Type = {\n      val tparam = symbol"
  },
  {
    "id" : "42578e9c-6e1a-4a83-8a69-49b957244904",
    "prId" : 3061,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/3061#pullrequestreview-60905546",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e5056d5e-b351-4975-8569-353f8441cab7",
        "parentId" : null,
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Complication: New type TypeArgRef. \r\n\r\nThere's hope we can get rid of this again if we permit references to private type parameters as  general types.",
        "createdAt" : "2017-09-06T13:16:55Z",
        "updatedAt" : "2017-09-20T15:20:34Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "2e65bd581c7506e1a382d906a9c8a961fafabfff",
    "line" : 795,
    "diffHunk" : "@@ -1,1 +3134,3138 @@   *  where `p: C[... _ ...]`\n   */\n  abstract case class TypeArgRef(prefix: Type, clsRef: TypeRef, idx: Int) extends CachedProxyType with ValueType {\n    assert(prefix.isInstanceOf[ValueType])\n    assert(idx >= 0)"
  },
  {
    "id" : "fced08e6-6a6a-49c2-898b-ceaa21c4973c",
    "prId" : 3061,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/3061#pullrequestreview-60906220",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ac7ec689-b0a7-40d6-ac59-a7ce4a9c4155",
        "parentId" : null,
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Optimization: Spell out `mapArgs` instead of going through `zipwithConserve`.",
        "createdAt" : "2017-09-06T13:19:09Z",
        "updatedAt" : "2017-09-20T15:20:34Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "2e65bd581c7506e1a382d906a9c8a961fafabfff",
    "line" : 1227,
    "diffHunk" : "@@ -1,1 +3815,3819 @@\n        case tp: AppliedType =>\n          def mapArgs(args: List[Type], tparams: List[ParamInfo]): List[Type] = args match {\n            case arg :: otherArgs =>\n              val arg1 = arg match {"
  },
  {
    "id" : "54ad50d6-0cc5-4357-b361-cb67956e67e7",
    "prId" : 3061,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/3061#pullrequestreview-62726127",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d1056097-0062-4e02-aa52-89439fac4948",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "What happens if we do a union or intersection of TypeArgRefs?",
        "createdAt" : "2017-09-13T21:37:44Z",
        "updatedAt" : "2017-09-20T15:20:35Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "208ef846-108f-4a25-8a24-2064b43f8ad0",
        "parentId" : "d1056097-0062-4e02-aa52-89439fac4948",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "They are not treated specially here, AFAICS",
        "createdAt" : "2017-09-14T12:04:33Z",
        "updatedAt" : "2017-09-20T15:20:35Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "2e65bd581c7506e1a382d906a9c8a961fafabfff",
    "line" : 439,
    "diffHunk" : "@@ -1,1 +1807,1811 @@          }\n          NoType\n        case OrType(base1, base2) => argForParam(base1) | argForParam(base2)\n        case AndType(base1, base2) => argForParam(base1) & argForParam(base2)\n        case _ =>"
  },
  {
    "id" : "6315d75f-f7bb-4d5d-8532-a234db37c875",
    "prId" : 2945,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/2945#pullrequestreview-56105875",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "07724850-289f-4ac3-bda5-78388d9c8491",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Could `parent` be used instead of `tp.topType` ?",
        "createdAt" : "2017-08-13T22:05:41Z",
        "updatedAt" : "2017-08-17T15:57:19Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "10563890-2b92-48d1-bdce-014ab2b17a21",
        "parentId" : "07724850-289f-4ac3-bda5-78388d9c8491",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : " I added a comment explaining why not:\r\n\r\n                // Using `parent` instead of `tp.topType` would be better for normal refinements,\r\n                // but it would also turn *-types to a hk-types, which is not what we want.\r\n                // We should revisit this point in case we represent applied types not as refinements anymore. \r\n",
        "createdAt" : "2017-08-14T08:06:28Z",
        "updatedAt" : "2017-08-17T15:57:19Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "1d245f9a-b429-408c-8c82-84db42dc49b9",
        "parentId" : "07724850-289f-4ac3-bda5-78388d9c8491",
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "> it would also turn *-types to a hk-types\r\n\r\nWould it? `TypeApplications#isHK` only returns true for `HKTypeLambda`, and before this PR `avoid` used to return the parent for refinement types and it worked fine.",
        "createdAt" : "2017-08-14T14:21:52Z",
        "updatedAt" : "2017-08-17T15:57:19Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "92cf6860-ea74-4aa0-b0ab-4155986997a6",
        "parentId" : "07724850-289f-4ac3-bda5-78388d9c8491",
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Alternatively we could return derivedRefinedType(tp, parent, WildcardType) I think",
        "createdAt" : "2017-08-14T15:04:15Z",
        "updatedAt" : "2017-08-17T15:57:19Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      }
    ],
    "commit" : "491fe97b5cfdffe5cae7ef6dd9b2a711ee454e1b",
    "line" : 150,
    "diffHunk" : "@@ -1,1 +3958,3962 @@              else if (v1 < 0 && v2 < 0) propagate(infoHi, infoLo)\n              else if (!infoLo.isAlias && !infoHi.isAlias) propagate(infoLo, infoHi)\n              else range(tp.bottomType, tp.topType)\n                // Using `parent` instead of `tp.topType` would be better for normal refinements,\n                // but it would also turn *-types into hk-types, which is not what we want."
  },
  {
    "id" : "43cef0c0-2307-4a08-a8bb-dc40567a2ed5",
    "prId" : 2716,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/2716#pullrequestreview-44303534",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9bf4dd21-5de4-4e6d-97bc-fed68cd63fd0",
        "parentId" : null,
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "Why use backquotes around `ne`?",
        "createdAt" : "2017-06-15T14:01:53Z",
        "updatedAt" : "2017-06-23T17:35:45Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      }
    ],
    "commit" : "b7afd437f39955c288a9f72a299cbb43eab238e4",
    "line" : 30,
    "diffHunk" : "@@ -1,1 +784,788 @@          val this1 = widenNullary(this)\n          val that1 = widenNullary(that)\n          ((this1 `ne` this) || (that1 `ne` that)) && this1.overrides(this1, matchLoosely = false)\n        }\n      )"
  },
  {
    "id" : "0d84ede0-cdf8-4211-bed3-eb1a4024d839",
    "prId" : 2330,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/2330#pullrequestreview-35517653",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "99221ce8-39cf-4815-9114-408ad48af82a",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Incorrect indentation around here.",
        "createdAt" : "2017-04-30T14:15:26Z",
        "updatedAt" : "2017-04-30T14:15:26Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      }
    ],
    "commit" : "cdc4eece1d87b17c495160f35df592526374c2bf",
    "line" : 46,
    "diffHunk" : "@@ -1,1 +879,883 @@     *  Any remaining union types are replaced by their joins.\n     *\n\t   *  For instance, if `A` is an unconstrained type variable, then\n  \t *\n  \t * \t      ArrayBuffer[Int] | ArrayBuffer[A]"
  },
  {
    "id" : "c3d5ec1a-d824-4f46-9710-d28c13da6270",
    "prId" : 2215,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/2215#pullrequestreview-31868372",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3b17f2c3-3e5f-474e-b6f3-025a2d68b7af",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Was this change also needed to make a test pass? It seems more suspicious.",
        "createdAt" : "2017-04-10T14:36:31Z",
        "updatedAt" : "2017-04-10T15:09:01Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "7c340f4f-2a87-409d-9e37-5deb62ccfb8b",
        "parentId" : "3b17f2c3-3e5f-474e-b6f3-025a2d68b7af",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Yes, pos/z1720 started failing without the fix. The commit comment indicates this.",
        "createdAt" : "2017-04-10T15:01:29Z",
        "updatedAt" : "2017-04-10T15:09:01Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "0cf17c5f63b3ec37a05da920a81337067ac335db",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +109,113 @@    /** Does this type denote a stable reference (i.e. singleton type)? */\n    final def isStable(implicit ctx: Context): Boolean = stripTypeVar match {\n      case tp: TermRef => tp.termSymbol.isStable && tp.prefix.isStable || tp.info.isStable\n      case _: SingletonType | NoPrefix => true\n      case tp: RefinedOrRecType => tp.parent.isStable"
  },
  {
    "id" : "dd37b656-77ce-403e-9898-1aca8ab65ae9",
    "prId" : 2136,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/2136#pullrequestreview-35564569",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "cddaa8a6-6f3e-49ca-971a-5a8420f5c328",
        "parentId" : null,
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Could be: `topType.prefix.select(tpnme.Nothing)` or something close.",
        "createdAt" : "2017-05-01T10:52:28Z",
        "updatedAt" : "2017-05-08T17:04:11Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "ac2c28de-40f0-4a36-9107-5ef99710e924",
        "parentId" : "cddaa8a6-6f3e-49ca-971a-5a8420f5c328",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "It could. The advantage of this version is that computing a bottom type that would result in `scala.Nothing` is more efficient.",
        "createdAt" : "2017-05-01T13:06:28Z",
        "updatedAt" : "2017-05-08T17:04:11Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      }
    ],
    "commit" : "a21404ab4acb7159bd9b36a86c0d15d68d8cfab2",
    "line" : 29,
    "diffHunk" : "@@ -1,1 +197,201 @@     */\n    final def bottomType(implicit ctx: Context): Type = {\n      val lattice = phantomLatticeType\n      if (lattice.exists) lattice.select(tpnme.Nothing)\n      else defn.NothingType"
  },
  {
    "id" : "8bf308f4-f3e5-4acf-92a2-5b75fac19be2",
    "prId" : 2124,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/2124#pullrequestreview-27885135",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c48c48c6-26e6-480c-892a-2447ad5d9586",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Should we revert the addition of the `allowPrivate` parameter to `asMemberOf` since it is no longer useful for ParamForwarder and could mask other bugs that only show up under `-Ytest-pickler` ?",
        "createdAt" : "2017-03-20T15:45:58Z",
        "updatedAt" : "2017-03-20T16:40:57Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "cf66326d-f7b1-4f6b-b53e-82e6ca4be5bb",
        "parentId" : "c48c48c6-26e6-480c-892a-2447ad5d9586",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "I'd leave it in, because the logic makes sense anyway. ",
        "createdAt" : "2017-03-20T15:57:14Z",
        "updatedAt" : "2017-03-20T16:40:57Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "40a3b94fd8380c120634742239c5128e3fce664c",
    "line" : 18,
    "diffHunk" : "@@ -1,1 +1786,1790 @@      if (symbol.exists && !candidate.symbol.exists) { // recompute from previous symbol\n        val ownSym = symbol\n        val newd = asMemberOf(prefix, allowPrivate = ownSym.is(Private))\n        candidate.withDenot(newd.suchThat(_.signature == ownSym.signature))\n      }"
  },
  {
    "id" : "3c7e9693-6b21-424d-bed7-6d6176df0565",
    "prId" : 2043,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/2043#pullrequestreview-24493324",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "18e2002f-152e-490b-aa9d-dddac4d0f752",
        "parentId" : null,
        "authorId" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "body" : "this change is not necessary. It will still get tail-rec optimized even without it.\r\nYou can use https://github.com/lampepfl/dotty/issues/1221 to mark per-callsite `@tailrec`-s",
        "createdAt" : "2017-03-01T10:14:06Z",
        "updatedAt" : "2017-03-01T12:03:52Z",
        "lastEditedBy" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "tags" : [
        ]
      },
      {
        "id" : "26bff5ef-6ce2-4a57-9859-17e3500247bb",
        "parentId" : "18e2002f-152e-490b-aa9d-dddac4d0f752",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "Thanks, I used it in several places. In this instance it was easier to use the old notation.",
        "createdAt" : "2017-03-01T14:45:11Z",
        "updatedAt" : "2017-03-01T14:45:11Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      }
    ],
    "commit" : "be5720c18ca6768c7e72d4258677952848db2bb4",
    "line" : 206,
    "diffHunk" : "@@ -1,1 +1005,1009 @@          }\n        case pre: RecType =>\n          val candidate = pre.parent.lookupRefined(name)\n          if (candidate.exists && !pre.isReferredToBy(candidate)) {\n            //println(s\"lookupRefined ${this.toString} . $name, pre: $pre ---> $candidate / ${candidate.toString}\")"
  },
  {
    "id" : "36d20cdb-d5a0-4ad1-aab9-134fd0a70108",
    "prId" : 1817,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/1817#pullrequestreview-13447866",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7d551035-5d08-4f21-a914-a25f4b1b7110",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Could you add some documentation on the meaning of FlexType?",
        "createdAt" : "2016-12-17T15:09:38Z",
        "updatedAt" : "2016-12-17T21:01:23Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      }
    ],
    "commit" : "1f9990b58c23ba74a8d96166700e755704b78a49",
    "line" : null,
    "diffHunk" : "@@ -1,1 +3256,3260 @@   *  class are at the same time subtypes and supertypes of every other type.\n   */\n  abstract class FlexType extends UncachedGroundType with ValueType\n\n  class ErrorType(_msg: => Message) extends FlexType {"
  }
]
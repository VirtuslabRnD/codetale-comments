[
  {
    "id" : "4cf9c5da-a6e8-4858-8d08-9801aefaf213",
    "prId" : 10135,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/10135#pullrequestreview-521856302",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "64427e5d-e490-4a7b-8f5f-65447b0a6096",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "The `toTree` here means we're still forcing things early in some cases",
        "createdAt" : "2020-11-02T17:14:59Z",
        "updatedAt" : "2020-11-02T20:35:48Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "2791c10a-2010-444c-907d-150dc940cda1",
        "parentId" : "64427e5d-e490-4a7b-8f5f-65447b0a6096",
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "I guess if this works OK with JDK 14 we can merge as is but we should revisit it.",
        "createdAt" : "2020-11-02T17:15:20Z",
        "updatedAt" : "2020-11-02T20:35:48Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "0b746142-ec7a-4a08-a5db-ba879472b223",
        "parentId" : "64427e5d-e490-4a7b-8f5f-65447b0a6096",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "Yes, this is a recursive call, I see no other ways to deal with it elegantly.",
        "createdAt" : "2020-11-02T17:18:36Z",
        "updatedAt" : "2020-11-02T20:35:48Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "c9a3e291-0714-45e3-987e-d9826d804ba1",
        "parentId" : "64427e5d-e490-4a7b-8f5f-65447b0a6096",
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "We us this call to build up `elems` which is used in `Some(untpd.JavaSeqLiteral(elems, TypeTree()))`, if we want to delay things properly we'd have to propagate the delay to this construction too: replace EnumTag by `Context => untpd.Tree` again, and construct a new `Context => untpd.Tree` when any element in the Array is itself a `Context => untpd.Tree`",
        "createdAt" : "2020-11-02T17:21:45Z",
        "updatedAt" : "2020-11-02T20:35:48Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "e0681a8b-fe37-4fd9-b011-660a93e00ceb",
        "parentId" : "64427e5d-e490-4a7b-8f5f-65447b0a6096",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "Yes, if we go back to `Context => untpd.Tree`, things will work, but it will undo the micro-optimizations. I'd say being lazy enough is a good tradeoff. If a problem emerges, we can be lazier (the lazy problem might be in other places as well).",
        "createdAt" : "2020-11-02T17:39:25Z",
        "updatedAt" : "2020-11-02T20:35:48Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      }
    ],
    "commit" : "9dc145d51cb13fe681f4ee6f6562ba15d6eba17e",
    "line" : 50,
    "diffHunk" : "@@ -1,1 +563,567 @@          parseAnnotArg(skip) match {\n            case Some(c: untpd.Tree) => arr += c\n            case Some(tag: EnumTag) => arr += tag.toTree\n            case None => hasError = true\n          }"
  },
  {
    "id" : "91805613-9ae8-4434-be24-08a062181371",
    "prId" : 10037,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/10037#pullrequestreview-517693489",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "36213daf-7e57-4463-8664-605c4104246f",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Something I'm not sure about is whether like in Scala 2 `pool` should be set to `null` after `parseClass`. In Scala 2 the ClassfileParser is a field of the ClassfileLoader so it's important to not keep reference to unused things as that might prevent garbage-collection, in Dotty ClassfileParser is only ever allocated in a method of `ClassfileLoader` and we don't keep any direct reference to it, so it should be garbage-collected as soon as we're done using it, unless we accidentally keep a reference to it in a completer we set, but that should not be necessary and we should make sure that's not the case.",
        "createdAt" : "2020-10-26T21:30:34Z",
        "updatedAt" : "2020-10-30T15:57:18Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "860b6664-17a5-46c3-8d14-2b92c1e51fc8",
        "parentId" : "36213daf-7e57-4463-8664-605c4104246f",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "Good point. Regarding the `pool`, a more principled way is to pass it around, as we did for `DataReader`. As both have exactly the same life duration, it might be possible to create a facade to combine them --- ConstantPool can be reused too.\r\n\r\nThe refactoring will make it significantly different from Scala2, I think it's better to leave it to another PR for experiments.",
        "createdAt" : "2020-10-27T08:02:23Z",
        "updatedAt" : "2020-10-30T15:57:18Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "cb3b50fd-1084-467b-ad1f-a257bc9d9d64",
        "parentId" : "36213daf-7e57-4463-8664-605c4104246f",
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "OK, so until these refactorings are done it's important to set `pool = null` after `parseClass()` if we want to allow the ConstantPool to be garbage-collected while we keep references to the ClassfileParser.",
        "createdAt" : "2020-10-27T12:50:38Z",
        "updatedAt" : "2020-10-30T15:57:18Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "cbdab207-7db3-4443-9954-3ea5b7d60e1e",
        "parentId" : "36213daf-7e57-4463-8664-605c4104246f",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "Yes, good point, that is done now.",
        "createdAt" : "2020-10-27T13:21:00Z",
        "updatedAt" : "2020-10-30T15:57:18Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      }
    ],
    "commit" : "a8f1cfbbbc7a034d5f0d49c55a37e6eb2fb1beef",
    "line" : 21,
    "diffHunk" : "@@ -1,1 +86,90 @@    report.debuglog(\"[class] >> \" + classRoot.fullName)\n    parseHeader()\n    this.pool = new ConstantPool\n    val res = parseClass()\n    this.pool =  null"
  },
  {
    "id" : "51d5fa64-78fb-4be8-8173-242ddd4e45a3",
    "prId" : 10037,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/10037#pullrequestreview-517433530",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "db907c4c-a225-465b-8b66-89f3f32fbe74",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "I suggest moving this class outside of the ClassfileParser class to make sure we don't accidentally capture any reference to the class or one of its field.",
        "createdAt" : "2020-10-26T21:32:24Z",
        "updatedAt" : "2020-10-30T15:57:18Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "3e18869f-359e-4c5c-bfac-6a2ad07c1a34",
        "parentId" : "db907c4c-a225-465b-8b66-89f3f32fbe74",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "That is a good refactoring, but unfortunately it indirectly depends on `innerClasses` and some other member methods. We have to do some big operations for classfile parser class. I'm happy to do such a refactoring to make things more clear in the classfile parser in another PR, and make this PR simpler and single-purpose.",
        "createdAt" : "2020-10-27T08:07:32Z",
        "updatedAt" : "2020-10-30T15:57:18Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      }
    ],
    "commit" : "a8f1cfbbbc7a034d5f0d49c55a37e6eb2fb1beef",
    "line" : 124,
    "diffHunk" : "@@ -1,1 +245,249 @@  }\n\n  class MemberCompleter(name: SimpleName, jflags: Int, sig: String) extends LazyType {\n    var attrCompleter: AttributeCompleter = null\n"
  },
  {
    "id" : "e89982f4-64e9-418d-8403-2bd3dd399964",
    "prId" : 10037,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/10037#pullrequestreview-517435655",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "45a47eb8-6f55-449b-8c4a-10f2393b0c06",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Moving this class outside of ClassfileParser would also be useful for the same reason, but in fact it won't work currently as we're calling methods from the enclosing class (`sigToType`, `convertTo`) and so we're keeping a reference to it. Can we move these methods to the companion object to avoid this problem?",
        "createdAt" : "2020-10-26T21:37:23Z",
        "updatedAt" : "2020-10-30T15:57:18Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "9e02a287-3b69-44a5-9c5a-1470f9aeb412",
        "parentId" : "45a47eb8-6f55-449b-8c4a-10f2393b0c06",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "Yes, as you noticed, it depends on instance methods like `sigToType`, the same as `MemberCompleter`, therefore indirectly depend on `innerClasses` and etc. I think there is a refactoring opportunity to clean up things. As it will make classfile parser very different from it is now, I'd reserve it for another PR to make this PR simpler.",
        "createdAt" : "2020-10-27T08:10:37Z",
        "updatedAt" : "2020-10-30T15:57:18Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      }
    ],
    "commit" : "a8f1cfbbbc7a034d5f0d49c55a37e6eb2fb1beef",
    "line" : 355,
    "diffHunk" : "@@ -1,1 +634,638 @@   *  lazily.\n   */\n  class AttributeCompleter(sym: Symbol) {\n    var sig: String = null\n    var constant: Constant = null"
  },
  {
    "id" : "953bcd20-a590-424e-a29b-ae8c12a41c0d",
    "prId" : 8099,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/8099#pullrequestreview-348941118",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e3c9e7d2-9d1b-48b6-96a3-e98ffc321b51",
        "parentId" : null,
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "Why `NoSource`? Can't we recover it?",
        "createdAt" : "2020-01-27T14:26:21Z",
        "updatedAt" : "2020-01-27T20:06:05Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      },
      {
        "id" : "06c272db-e65c-4894-902f-b53a75cde58e",
        "parentId" : "e3c9e7d2-9d1b-48b6-96a3-e98ffc321b51",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "I tried `classRoot.source`, it's just NoSource.",
        "createdAt" : "2020-01-27T15:06:44Z",
        "updatedAt" : "2020-01-27T20:06:05Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "5a5f2725-2b8d-42a8-b273-1d1e646c597c",
        "parentId" : "e3c9e7d2-9d1b-48b6-96a3-e98ffc321b51",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "I tried several alternatives (see commit message), it seems `util.NoSource` is the right thing to do.",
        "createdAt" : "2020-01-27T20:07:44Z",
        "updatedAt" : "2020-01-27T20:07:45Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      }
    ],
    "commit" : "e2be19768fe385262825e871aca337e58a37258f",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +751,755 @@      def unpickleTASTY(bytes: Array[Byte]): Some[Embedded]  = {\n        val unpickler = new tasty.DottyUnpickler(bytes)\n        unpickler.enter(roots = Set(classRoot, moduleRoot, moduleRoot.sourceModule))(ctx.withSource(util.NoSource))\n        Some(unpickler)\n      }"
  },
  {
    "id" : "e9c89143-2da3-4957-bdf9-64faec239137",
    "prId" : 7019,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/7019#pullrequestreview-273098089",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "dace6022-0d0a-4edf-81d8-8fcace8c8da1",
        "parentId" : null,
        "authorId" : "223e67d6-1873-432a-9af9-f40b82a7eedd",
        "body" : "Aren't all java interfaces universal traits?",
        "createdAt" : "2019-08-09T08:42:56Z",
        "updatedAt" : "2019-08-25T14:46:09Z",
        "lastEditedBy" : "223e67d6-1873-432a-9af9-f40b82a7eedd",
        "tags" : [
        ]
      },
      {
        "id" : "dd3750da-be2e-4dbe-8369-0031d8e7ad57",
        "parentId" : "dace6022-0d0a-4edf-81d8-8fcace8c8da1",
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "You can do `eq` on a value whose type is a Java interface, but `eq` is not a member of `Any`. Here I'm just reproducing scalac's behavior to avoid inconsistencies.",
        "createdAt" : "2019-08-09T12:03:55Z",
        "updatedAt" : "2019-08-25T14:46:09Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      }
    ],
    "commit" : "37fab2238cd844b56b91015ab936115a4901973c",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +140,144 @@        else if (classRoot.symbol == defn.ComparableClass ||\n                 classRoot.symbol == defn.JavaCloneableClass ||\n                 classRoot.symbol == defn.JavaSerializableClass) {\n          // Treat these interfaces as universal traits\n          in.nextChar"
  },
  {
    "id" : "bc82067b-a3f5-4dcc-8d00-4966015ebadd",
    "prId" : 4467,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/4467#pullrequestreview-138232415",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f5e68a36-ce05-454d-9707-a5b70427e8d3",
        "parentId" : null,
        "authorId" : "223e67d6-1873-432a-9af9-f40b82a7eedd",
        "body" : "Are you sure we won't have to deal with the same issues using a `URLClassLoader`?",
        "createdAt" : "2018-07-16T11:50:35Z",
        "updatedAt" : "2018-07-19T13:59:22Z",
        "lastEditedBy" : "223e67d6-1873-432a-9af9-f40b82a7eedd",
        "tags" : [
        ]
      },
      {
        "id" : "c8d3f8f4-d9fe-4be3-97c5-2f842c1e4532",
        "parentId" : "f5e68a36-ce05-454d-9707-a5b70427e8d3",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "I would say no because the classloader never instanciates an class with a reference to it. Hence the classloader should be GCed at some point. I will experiment a bit with the profiler to see if I can observe any leaks.",
        "createdAt" : "2018-07-17T08:56:18Z",
        "updatedAt" : "2018-07-19T13:59:22Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      },
      {
        "id" : "f9c48143-130b-42bb-a911-07a4f33b538b",
        "parentId" : "f5e68a36-ce05-454d-9707-a5b70427e8d3",
        "authorId" : "223e67d6-1873-432a-9af9-f40b82a7eedd",
        "body" : "Not only leaks. Can the jar be read using an `URLClassLoader` while at the same time it is read using `nio.file.FileSystems`. What if someone close the `FileSystems` while you're reading the jar with `URLClassLoader`?",
        "createdAt" : "2018-07-17T09:27:54Z",
        "updatedAt" : "2018-07-19T13:59:22Z",
        "lastEditedBy" : "223e67d6-1873-432a-9af9-f40b82a7eedd",
        "tags" : [
        ]
      },
      {
        "id" : "1cc9dfb6-b296-4919-b169-8b3c514535e9",
        "parentId" : "f5e68a36-ce05-454d-9707-a5b70427e8d3",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "I tried it and it does not affect the class loader. I closed the file system in the middle of reading from the stream and some other places.",
        "createdAt" : "2018-07-18T12:35:56Z",
        "updatedAt" : "2018-07-19T13:59:22Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      }
    ],
    "commit" : "de291c1df5a52a2f9113e85ff5d64acb0882ccfc",
    "line" : 35,
    "diffHunk" : "@@ -1,1 +792,796 @@              Array.empty\n            case Some(jar: ZipArchive) => // We are in a jar\n              val cl = new URLClassLoader(Array(jar.jpath.toUri.toURL))\n              val path = classfile.path.stripSuffix(\".class\") + \".tasty\"\n              val stream = cl.getResourceAsStream(path)"
  },
  {
    "id" : "4e5f1eb6-d5b9-49b1-8fc9-958c647629b4",
    "prId" : 3285,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/3285#pullrequestreview-67856508",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6ed138d0-1814-47b7-a59a-53bec00b4d7f",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Micro-optimization: prefer !isEmpty, `nonEmpty` is a trait method",
        "createdAt" : "2017-10-08T12:51:18Z",
        "updatedAt" : "2017-10-08T12:51:18Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      }
    ],
    "commit" : "628cc75211a1ca26e6b84cdd2004656be6d0a78c",
    "line" : 8,
    "diffHunk" : "@@ -1,1 +28,32 @@  def cook(implicit ctx: Context) = new TypeMap {\n    def apply(tp: Type): Type = tp match {\n      case tp: TypeRef if tp.symbol.typeParams.nonEmpty =>\n        AppliedType(tp, tp.symbol.typeParams.map(Function.const(TypeBounds.empty)))\n      case tp @ AppliedType(tycon, args) =>"
  }
]
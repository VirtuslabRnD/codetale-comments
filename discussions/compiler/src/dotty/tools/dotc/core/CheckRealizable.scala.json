[
  {
    "id" : "05a268c4-47fa-4f28-86f4-91b6f8844446",
    "prId" : 5730,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/5730#pullrequestreview-193226560",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bdfa6b12-5998-436e-a971-0877c959fd84",
        "parentId" : null,
        "authorId" : "348fab8e-49e2-442e-884d-850c7f41fdde",
        "body" : "@abeln You asked questions (back in #5558) about stability and realizability, do you have a chance to take a look at this comment?",
        "createdAt" : "2019-01-16T16:24:28Z",
        "updatedAt" : "2019-01-22T15:21:34Z",
        "lastEditedBy" : "348fab8e-49e2-442e-884d-850c7f41fdde",
        "tags" : [
        ]
      }
    ],
    "commit" : "b0c8e68ffbfd380216183388a58dea3489adafd2",
    "line" : 18,
    "diffHunk" : "@@ -1,1 +51,55 @@}\n\n/** Compute realizability status.\n  *\n  * A type T is realizable iff it is inhabited by non-null values. This ensures that its type members have good bounds"
  },
  {
    "id" : "374878b2-1e7c-44ab-a974-fc6d15ae80d7",
    "prId" : 5522,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/5522#pullrequestreview-179792951",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0334b363-253f-4bd2-8296-4a7944282d83",
        "parentId" : null,
        "authorId" : "348fab8e-49e2-442e-884d-850c7f41fdde",
        "body" : "I looked at this time ago in #4036, I should look more closely, and I'm in a rush, but here are some initial comments.\r\n\r\nI agree this is a bug and this change should give the correct behavior; but this change risks being pretty computationally expensive (possible fix below). This can duplicate recursive calls, and that risks causing exponential slowdowns. Triggering it might require a chain of final lazy vals or be impossible, but it's more robust to not duplicate calls.\r\n\r\nIf `isLateInitialized(sym)`, this calls `realizability(tp.prefix)` again, and that can be too expensive. Caching only affects symbols, but we don't cache `realizability` on whole types; `tp` could not even be a `TermRef` and fall through `boundsRealizability(tp).andAlso(memberRealizability(tp))`.\r\n\r\nI asked dottybot for a performance test. But maybe one could just reorganize the logic.\r\nLooking at #4036 (which is where I \"studied\" this), I propose to add to your change the following:\r\n```diff\r\n-else if (!isLateInitialized(sym)) realizability(tp.prefix)\r\n+else if (!isLateInitialized(sym)) Realizable\r\n```\r\nbecause in this branch we can certainly mark the symbol as stable (that PR also achieves this goal, though in a hackier way). If that works, this PR can go in with that fix.\r\n\r\n## Optional requests\r\n\r\nHere's a couple of bonus requests one could fix here as well â€” if they are non-trivial, feel free to defer them. I should probably do these changes myself and PR them, I'm in a rush right now.\r\n\r\nOn performance: https://github.com/lampepfl/dotty/pull/4036/files#diff-0535d82f8f57a2204d6452bae575efc9 might be a useful test here (if it doesn't cause a stack overflow).\r\n\r\nOn error reporting, I think one could cherry-pick from #4036 the following:\r\n```diff\r\n-realizability(tp.prefix)\r\n+realizability(tp.prefix).mapError(r => new ProblemInUnderlying(tp.prefix, r))\r\n```",
        "createdAt" : "2018-11-29T13:27:27Z",
        "updatedAt" : "2018-11-29T23:06:13Z",
        "lastEditedBy" : "348fab8e-49e2-442e-884d-850c7f41fdde",
        "tags" : [
        ]
      }
    ],
    "commit" : "0eea5b3f7c96dc905fc861bac337236495e76d7f",
    "line" : 12,
    "diffHunk" : "@@ -1,1 +80,84 @@        r andAlso {\n          sym.setFlag(Stable)\n          realizability(tp.prefix)\n        }\n      }"
  },
  {
    "id" : "2a02d51c-38d2-49ca-868a-dff3f822f117",
    "prId" : 4122,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/4122#pullrequestreview-104472812",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e9ef15b4-186d-43cc-8563-66e89150d09f",
        "parentId" : null,
        "authorId" : "348fab8e-49e2-442e-884d-850c7f41fdde",
        "body" : "This comment should be updated.",
        "createdAt" : "2018-03-16T03:25:07Z",
        "updatedAt" : "2018-03-19T21:31:23Z",
        "lastEditedBy" : "348fab8e-49e2-442e-884d-850c7f41fdde",
        "tags" : [
        ]
      },
      {
        "id" : "3db9c877-ca25-47b9-8a2d-c710ff0fc6e2",
        "parentId" : "e9ef15b4-186d-43cc-8563-66e89150d09f",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Actually, the comment is now correct. The previous implementation did less than the comment implied.",
        "createdAt" : "2018-03-16T07:26:42Z",
        "updatedAt" : "2018-03-19T21:31:23Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "3f3f1ba4e0a9c60bda4cbb41722af44c57a6edb0",
    "line" : 27,
    "diffHunk" : "@@ -1,1 +113,117 @@   *    - base types do not appear in multiple instances with different arguments.\n   *      (depending on the simplification scheme for AndTypes employed, this could\n   *       also lead to base types with bad bounds).\n   */\n  private def boundsRealizability(tp: Type) = {"
  },
  {
    "id" : "7b5f82ee-a365-4363-bf66-a42a8bd2b71b",
    "prId" : 4122,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/4122#pullrequestreview-104548015",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4e3d5bf5-5454-4437-bbba-c686278ca907",
        "parentId" : null,
        "authorId" : "348fab8e-49e2-442e-884d-850c7f41fdde",
        "body" : "It seems that `A | B` would need a test? Confused what happens there with disjoint ranges.",
        "createdAt" : "2018-03-16T03:30:05Z",
        "updatedAt" : "2018-03-19T21:31:23Z",
        "lastEditedBy" : "348fab8e-49e2-442e-884d-850c7f41fdde",
        "tags" : [
        ]
      },
      {
        "id" : "f0b2e879-9529-492a-80d2-9f0633ea8647",
        "parentId" : "4e3d5bf5-5454-4437-bbba-c686278ca907",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "`refinedNames` only collects names that appear in a top-level refinement. So that's the same for & and |. The bounds checking is done later.\r\n",
        "createdAt" : "2018-03-16T07:25:07Z",
        "updatedAt" : "2018-03-19T21:31:23Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "d1e2c2fc-fe39-4561-aaa8-f692e74d1a1d",
        "parentId" : "4e3d5bf5-5454-4437-bbba-c686278ca907",
        "authorId" : "348fab8e-49e2-442e-884d-850c7f41fdde",
        "body" : "I meant I don't see a testcase exercising this path.",
        "createdAt" : "2018-03-16T12:33:18Z",
        "updatedAt" : "2018-03-19T21:31:23Z",
        "lastEditedBy" : "348fab8e-49e2-442e-884d-850c7f41fdde",
        "tags" : [
        ]
      }
    ],
    "commit" : "3f3f1ba4e0a9c60bda4cbb41722af44c57a6edb0",
    "line" : 18,
    "diffHunk" : "@@ -1,1 +100,104 @@    case tp: RefinedType => refinedNames(tp.parent) + tp.refinedName\n    case tp: AndType => refinedNames(tp.tp1) ++ refinedNames(tp.tp2)\n    case tp: OrType  => refinedNames(tp.tp1) ++ refinedNames(tp.tp2)\n    case tp: TypeProxy => refinedNames(tp.underlying)\n    case _ => Set.empty"
  },
  {
    "id" : "5d9950e1-8dc0-4e55-9ccd-25f457cccf0d",
    "prId" : 3061,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/3061#pullrequestreview-62746300",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "411fb9d7-3067-438d-b109-625b977fb19b",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Wait, why would we allow base type arguments to be wildcards? This does not compile with scalac:\r\n```scala\r\nscala> class A[T]\r\ndefined class A\r\n\r\nscala> class B extends A[_ <: String]\r\n<console>:12: error: class type required but A[_ <: String] found\r\n       class B extends A[_ <: String]\r\n                       ^\r\n```",
        "createdAt" : "2017-09-11T13:03:07Z",
        "updatedAt" : "2017-09-20T15:20:34Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "e7324973-8797-4496-8e62-45e1b54045df",
        "parentId" : "411fb9d7-3067-438d-b109-625b977fb19b",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Why not? Also, conflicting bounds might arise by siplification of AndTypes. I expanded the explanation.",
        "createdAt" : "2017-09-14T11:06:10Z",
        "updatedAt" : "2017-09-20T15:20:35Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "cac3e356-63a0-4950-a4b4-586dd98bb7c6",
        "parentId" : "411fb9d7-3067-438d-b109-625b977fb19b",
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "I guess for the same reason we don't want `new A[_ <:String]`, in the end we want instantiations to have concrete types.",
        "createdAt" : "2017-09-14T13:21:20Z",
        "updatedAt" : "2017-09-20T15:20:35Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      }
    ],
    "commit" : "2e65bd581c7506e1a382d906a9c8a961fafabfff",
    "line" : 23,
    "diffHunk" : "@@ -1,1 +100,104 @@   *\n   *    - all type members have good bounds\n   *    - all base types are class types, and if their arguments are wildcards\n   *      they have good bounds.\n   *    - base types do not appear in multiple instances with different arguments."
  }
]
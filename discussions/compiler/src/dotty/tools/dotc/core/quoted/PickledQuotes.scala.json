[
  {
    "id" : "e8c41520-7bd0-4360-8ffd-f0607751526d",
    "prId" : 8561,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/8561#pullrequestreview-385392223",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "81d4f81d-9439-4c2b-8840-18497fad7de2",
        "parentId" : null,
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "The syntax `(x:T) ?=> e` is deprecated in favor of `(using x:T) => e`\r\n\r\nIt's not clear why `qctx` is needed for creation of `TastyTreeExpr`, as from the code, it's not used.",
        "createdAt" : "2020-04-01T09:00:41Z",
        "updatedAt" : "2020-04-01T12:21:36Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      }
    ],
    "commit" : "cebfdd8f5b6249aa1f7d8f4870bf0da7b7349152",
    "line" : 70,
    "diffHunk" : "@@ -1,1 +76,80 @@          val reifiedArgs = args.map { arg =>\n            if (arg.isTerm) (using qctx: scala.quoted.QuoteContext) => new TastyTreeExpr(arg, QuoteContext.scopeId)\n            else new TreeType(arg, QuoteContext.scopeId)\n          }\n          if isTerm then"
  },
  {
    "id" : "3167e498-3f22-4491-8bd8-aeaf2f8451f4",
    "prId" : 8561,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/8561#pullrequestreview-385490652",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fa6fd774-c380-45fc-ad02-2109d6f35162",
        "parentId" : null,
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "Small opt: can we just do one pass for splicing? ",
        "createdAt" : "2020-04-01T09:24:30Z",
        "updatedAt" : "2020-04-01T12:21:36Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "47cdb39c-bb22-4942-906f-5c6250468729",
        "parentId" : "fa6fd774-c380-45fc-ad02-2109d6f35162",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "No, that was the first approach I tried. We need the types to be known when we expand the term holes as some of them may take some type parameters that the user inspects.  Note that `spliceTypes` is a no-op if the quote does not have type splices. ",
        "createdAt" : "2020-04-01T11:20:14Z",
        "updatedAt" : "2020-04-01T12:21:36Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      }
    ],
    "commit" : "cebfdd8f5b6249aa1f7d8f4870bf0da7b7349152",
    "line" : 42,
    "diffHunk" : "@@ -1,1 +58,62 @@    val inlineCtx = inlineContext(call)\n    val expansion1 = spliceTypes(expnasion, splices)(using inlineCtx)\n    val expansion2 = spliceTerms(expansion1, splices)(using inlineCtx)\n    cpy.Inlined(unpickled)(call, Nil, expansion2)\n  }"
  },
  {
    "id" : "aed9d312-6c05-4a52-8c9e-d2566165a565",
    "prId" : 8561,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/8561#pullrequestreview-385491840",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "efaf4fab-254c-45fc-be8f-10bc94d10cfb",
        "parentId" : null,
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "It would be nice to doc & spec this invariant: quoting & splicing do not change overloading resolution. The following can be an example to demonstrate:\r\n\r\n```Scala\r\nclass A[T] {\r\n  def foo(x: T): T = ???\r\n  def foo(x: Int): Int = ???\r\n}\r\n\r\nclass B extends A[Int]\r\n\r\nimport scala.quoted._\r\n\r\ninline def m[T](a: A[T], x: T) : T = ${  mImpl[T]('a, 'x) }\r\n\r\ndef mImpl[T: Type](a: Expr[A[T]], x: Expr[T])(using qctx: QuoteContext): Expr[T] =  '{\r\n  $a.foo($x)\r\n}\r\n\r\n// which `foo` will be called?\r\nm(new B,  5)\r\n```",
        "createdAt" : "2020-04-01T09:46:45Z",
        "updatedAt" : "2020-04-01T12:21:36Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "26dd8066-2ae9-44c8-a3f1-27fa3531f8db",
        "parentId" : "efaf4fab-254c-45fc-be8f-10bc94d10cfb",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "That is in part of the spec of inlining. We just did something else by mistake. I will try to place this in the docs.",
        "createdAt" : "2020-04-01T11:22:10Z",
        "updatedAt" : "2020-04-01T12:21:36Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      }
    ],
    "commit" : "cebfdd8f5b6249aa1f7d8f4870bf0da7b7349152",
    "line" : 89,
    "diffHunk" : "@@ -1,1 +95,99 @@          // Retain selected members\n          val qual = transform(tree.qualifier)\n          qual.select(tree.symbol).withSpan(tree.span)\n\n        case tree =>"
  },
  {
    "id" : "835aea87-a0b8-461a-ac9e-26b762c7d136",
    "prId" : 8561,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/8561#pullrequestreview-385497072",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2ef7b8f2-da70-42d4-87a9-403f715999f3",
        "parentId" : null,
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "What will happen if we remove the code above? Maybe add a doc for consequences if the action is not taken.",
        "createdAt" : "2020-04-01T09:57:24Z",
        "updatedAt" : "2020-04-01T12:21:36Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "83362972-eb10-4cf7-8c98-d7f3494c36a7",
        "parentId" : "2ef7b8f2-da70-42d4-87a9-403f715999f3",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "Some symbols and positions are not loaded early enough. Not sure why though. But it has been like that since the start. Dimitry mentioned the need for this for loading trees from tasty in general and we have keep this mechanism so far.",
        "createdAt" : "2020-04-01T11:30:46Z",
        "updatedAt" : "2020-04-01T12:21:36Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      }
    ],
    "commit" : "cebfdd8f5b6249aa1f7d8f4870bf0da7b7349152",
    "line" : 176,
    "diffHunk" : "@@ -1,1 +190,194 @@    new TreeTraverser {\n      def traverse(tree: Tree)(implicit ctx: Context): Unit = traverseChildren(tree)\n    }.traverse(tree)\n\n    quotePickling.println(i\"**** unpickled quote\\n$tree\")"
  },
  {
    "id" : "100f4ee7-3a58-4759-b39e-947e2c02035a",
    "prId" : 8342,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/8342#pullrequestreview-361703792",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3bd83584-419d-40d1-9ced-e9d83b2251d9",
        "parentId" : null,
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "why this change?",
        "createdAt" : "2020-02-19T19:05:31Z",
        "updatedAt" : "2020-02-24T17:39:36Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "ed5af329-845b-44ff-bc47-8a603870ffaa",
        "parentId" : "3bd83584-419d-40d1-9ced-e9d83b2251d9",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "For some reason the type aliases get transformed into type bounds with equivalent upper and lower bound but they do not get dealiased. I will investigate further.",
        "createdAt" : "2020-02-20T08:20:00Z",
        "updatedAt" : "2020-02-24T17:39:36Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      }
    ],
    "commit" : "e1b2378c6d0bba9e34c179668885b8600ef616b6",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +54,58 @@      val tp1 = tp match {\n        case tp: TypeRef if tp.typeSymbol.hasAnnotation(defn.InternalQuoted_QuoteTypeTagAnnot) =>\n          tp.symbol.info.hiBound\n        case _ => tp\n      }"
  },
  {
    "id" : "835417f3-93c3-4d96-b567-8bb86f9dd20e",
    "prId" : 6790,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/6790#pullrequestreview-257024347",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "323e6b4a-1cad-4a8f-a3eb-ba482913aebb",
        "parentId" : null,
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "Is it possible to have such blocks nested in `rest`?",
        "createdAt" : "2019-07-02T16:09:20Z",
        "updatedAt" : "2019-07-02T16:09:27Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "228d4c8e-d4eb-407d-bb25-d212e6419ba3",
        "parentId" : "323e6b4a-1cad-4a8f-a3eb-ba482913aebb",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "Those blocks would have been removed before being spliced in this one.",
        "createdAt" : "2019-07-02T16:55:11Z",
        "updatedAt" : "2019-07-02T16:55:12Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      },
      {
        "id" : "37dcf3b4-b2ea-4627-a5be-d8765e113b98",
        "parentId" : "323e6b4a-1cad-4a8f-a3eb-ba482913aebb",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "Therefore it should not be possible. If it happens it would be a bug and I would be caught by the assertion in `ReifyQuotes`",
        "createdAt" : "2019-07-02T16:56:21Z",
        "updatedAt" : "2019-07-02T16:56:21Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      }
    ],
    "commit" : "5f72cc333b6f7da5794c2429730ef511a20cc22f",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +41,45 @@          case Block(stat :: rest, expr1) if stat.symbol.hasAnnotation(defn.InternalQuoted_QuoteTypeTagAnnot) =>\n            assert(rest.forall { case tdef: TypeDef => tdef.symbol.hasAnnotation(defn.InternalQuoted_QuoteTypeTagAnnot) })\n            transform(expr1)\n          case tree => super.transform(tree).withType(dealiasTypeTags(tree.tpe))\n        }"
  },
  {
    "id" : "ba14fa02-86d2-43ca-af29-86f1a8aa5a83",
    "prId" : 4457,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/4457#pullrequestreview-117987505",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "11ad24d7-5893-4b8b-8f56-eda6f480e8de",
        "parentId" : null,
        "authorId" : "37519144-0f9f-4b2b-85f7-34dde9be2e11",
        "body" : "The `Nil` there makes me wonder what if this fix applies to non-inline functions.",
        "createdAt" : "2018-05-07T12:47:57Z",
        "updatedAt" : "2018-05-08T11:44:24Z",
        "lastEditedBy" : "37519144-0f9f-4b2b-85f7-34dde9be2e11",
        "tags" : [
        ]
      },
      {
        "id" : "cb21ded7-e0c1-4006-851e-b05601837a15",
        "parentId" : "11ad24d7-5893-4b8b-8f56-eda6f480e8de",
        "authorId" : "37519144-0f9f-4b2b-85f7-34dde9be2e11",
        "body" : "// ignore, I have just went through the second unit test and you do what I had in mind.",
        "createdAt" : "2018-05-07T13:01:51Z",
        "updatedAt" : "2018-05-08T11:44:24Z",
        "lastEditedBy" : "37519144-0f9f-4b2b-85f7-34dde9be2e11",
        "tags" : [
        ]
      }
    ],
    "commit" : "68e32ab018ab7710d6f39014d22eca4688e159f3",
    "line" : 21,
    "diffHunk" : "@@ -1,1 +39,43 @@    }.traverse(tree)\n    val pickled = pickleQuote(tree)\n    scala.runtime.quoted.Unpickler.unpickleExpr(pickled, Nil)\n  }\n"
  }
]
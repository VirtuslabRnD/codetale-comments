[
  {
    "id" : "166f8adf-3abd-4f07-8d59-d824962722f2",
    "prId" : 12506,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/12506#pullrequestreview-674600174",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e0cac6dd-41d6-4f84-bd05-b13358ab39b0",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "If you have a testcase for this, it'd be nice to refer to it here.",
        "createdAt" : "2021-06-02T19:22:37Z",
        "updatedAt" : "2021-06-02T19:24:59Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      }
    ],
    "commit" : "cb10bb77b3fefa923342d3439c809f8f524ef765",
    "line" : 76,
    "diffHunk" : "@@ -1,1 +155,159 @@        // Their info could, for an example, be an AndType. One example where\n        // this is important is an enum case that extends its parent and an\n        // additional trait - argument-less enum cases desugar to vals.\n        // See run/enum-Tree.scala.\n        if tp.classSymbol.exists then tp else tp.info"
  },
  {
    "id" : "7e9979c1-2765-4295-be5a-c77c447e38eb",
    "prId" : 12506,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/12506#pullrequestreview-674600174",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "04345541-6021-411b-9238-2bd95d3545d8",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "The documentation comment above still talks about skolem wrapping, presumably that needs to be updated with the new scheme?",
        "createdAt" : "2021-06-02T19:24:53Z",
        "updatedAt" : "2021-06-02T19:24:59Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      }
    ],
    "commit" : "cb10bb77b3fefa923342d3439c809f8f524ef765",
    "line" : 130,
    "diffHunk" : "@@ -1,1 +215,219 @@   *  case classes without also appropriately extending the relevant case class\n   *  (see `RefChecks#checkCaseClassInheritanceInvariant`).\n   */\n  def constrainSimplePatternType(patternTp: Type, scrutineeTp: Type, forceInvariantRefinement: Boolean): Boolean = {\n    def refinementIsInvariant(tp: Type): Boolean = tp match {"
  },
  {
    "id" : "87197459-6aab-46c7-aaa9-418abeed442e",
    "prId" : 11711,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/11711#pullrequestreview-610994931",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8bba0dee-c8b6-403d-86b0-d156853d3f9d",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "I don't quite understand what all this stuff is doing, but are we intentionally not dealiasing here?",
        "createdAt" : "2021-03-12T13:46:34Z",
        "updatedAt" : "2021-03-12T13:46:39Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "f15ad8ac-6b00-40a1-8679-e84dd08acd53",
        "parentId" : "8bba0dee-c8b6-403d-86b0-d156853d3f9d",
        "authorId" : "3a56b927-736f-4aab-8690-358cd24ca570",
        "body" : "The type is already dealiased in `constrainPatternType`, we need to dealias in order to correctly handle intersections, unions and other things.",
        "createdAt" : "2021-03-12T17:14:29Z",
        "updatedAt" : "2021-03-12T17:14:29Z",
        "lastEditedBy" : "3a56b927-736f-4aab-8690-358cd24ca570",
        "tags" : [
        ]
      }
    ],
    "commit" : "2d8849a77909e61ad0512973d10261751b19d520",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +190,194 @@    }\n\n    def widenVariantParams(tp: Type) = tp match {\n      case tp @ AppliedType(tycon, args) =>\n        val args1 = args.zipWithConserve(tycon.typeParams)((arg, tparam) =>"
  },
  {
    "id" : "028492c1-7669-4505-baca-9863d4dbe43b",
    "prId" : 6398,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/6398#pullrequestreview-244228833",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5a4ad627-dd0f-4ecc-a3ac-a3661c08a89f",
        "parentId" : null,
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "You don't need `stripRefinement`. Can just do\r\n```scala\r\nconstrainPatternType(pat, scrut.parent)\r\n```\r\n(in both places where it is used). That does not special-case the natural recursion of `constrainPatternType` and removes a method.\r\n\r\nOr is there something I overlooked?",
        "createdAt" : "2019-05-31T10:00:58Z",
        "updatedAt" : "2019-06-06T09:39:12Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "01096ffc5b90aa40a0270fa5101ba9d13216e0c2",
    "line" : 135,
    "diffHunk" : "@@ -1,1 +133,137 @@        constrainPatternType(pat, scrut1) && constrainPatternType(pat, scrut2)\n      case scrut: RefinedOrRecType =>\n        constrainPatternType(pat, stripRefinement(scrut))\n      case scrut => pat.dealias match {\n        case OrType(pat1, pat2) =>"
  }
]
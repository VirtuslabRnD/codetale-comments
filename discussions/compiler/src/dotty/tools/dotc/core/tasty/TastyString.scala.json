[
  {
    "id" : "d1391494-3733-430d-8527-4ff9c8c6b76d",
    "prId" : 3662,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/3662#pullrequestreview-88807069",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2dcc1770-e2e5-4f72-acd9-4169c74a7524",
        "parentId" : null,
        "authorId" : "223e67d6-1873-432a-9af9-f40b82a7eedd",
        "body" : "`new String(bytes)`?",
        "createdAt" : "2017-12-13T08:35:49Z",
        "updatedAt" : "2018-01-08T13:06:20Z",
        "lastEditedBy" : "223e67d6-1873-432a-9af9-f40b82a7eedd",
        "tags" : [
        ]
      },
      {
        "id" : "079b56bc-1c66-4d98-8f28-1dd55220aac3",
        "parentId" : "2dcc1770-e2e5-4f72-acd9-4169c74a7524",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "Same problem",
        "createdAt" : "2017-12-13T08:37:55Z",
        "updatedAt" : "2018-01-08T13:06:20Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      },
      {
        "id" : "2e1eea88-37fc-45e4-8ea6-9ebfb17f1d52",
        "parentId" : "2dcc1770-e2e5-4f72-acd9-4169c74a7524",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "This is a tricky problem. Looking at Stackoverflow, people say you should use a Codec for this, typically Base64. The scheme of mapping all bytes to ranges 0..255 looks like it would work, but it's not optimal. Strings are represented in Classfiles as UTF8 characters, with one byte for ranges 0.127 and two bytes for ranges 128-255. This means that, assuming a uniform bit distribution you get an overhead of 50%. Doing a 8->7 bit codec would give an overhead of less than 15%. \r\n\r\nThere's another problem of string size. Strings are limited to 65365 characters. This might not be enough for a larger quoted program. \r\n\r\nscalac solves both of these problems when serializing its pickles as annotations. I think we should copy that scheme. I tried to find it but could not. @retronym @lrytz @adriaanm does one of you have an idea where the code that serializes a Pickle as an annotation is?",
        "createdAt" : "2017-12-25T16:00:55Z",
        "updatedAt" : "2018-01-08T13:06:20Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "5e6f0934-8957-4341-94de-fd880cdf4637",
        "parentId" : "2dcc1770-e2e5-4f72-acd9-4169c74a7524",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "I think we can leave it like this for this PR, but then we should open an issue for future improvements.",
        "createdAt" : "2017-12-25T17:10:26Z",
        "updatedAt" : "2018-01-08T13:06:20Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "6d464cff-cfda-456b-9bc5-fb56f6d85b7c",
        "parentId" : "2dcc1770-e2e5-4f72-acd9-4169c74a7524",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "I will start looking at the alternatives. I also think we should start with this for now to unblock the next PRs and allow people to use it.",
        "createdAt" : "2017-12-25T17:20:07Z",
        "updatedAt" : "2018-01-08T13:06:20Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      },
      {
        "id" : "969772c4-8008-4e0c-b530-554b6a4989d3",
        "parentId" : "2dcc1770-e2e5-4f72-acd9-4169c74a7524",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Agreed.",
        "createdAt" : "2017-12-27T16:34:40Z",
        "updatedAt" : "2018-01-08T13:06:20Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "00706681-fc43-4d04-84b9-d4663fc0854b",
        "parentId" : "2dcc1770-e2e5-4f72-acd9-4169c74a7524",
        "authorId" : "998ba0f7-d6a6-448f-a3ba-0d2237ed0cf9",
        "body" : "@odersky https://github.com/scala/scala/blob/2f3791c3079d998d29788d121552c27517f58a6c/src/compiler/scala/tools/nsc/backend/jvm/BCodeHelpers.scala#L1036-L1119\r\n  ",
        "createdAt" : "2018-01-05T10:10:22Z",
        "updatedAt" : "2018-01-08T13:06:20Z",
        "lastEditedBy" : "998ba0f7-d6a6-448f-a3ba-0d2237ed0cf9",
        "tags" : [
        ]
      },
      {
        "id" : "945f3291-aee6-4291-aa2a-d66ecd2cfa00",
        "parentId" : "2dcc1770-e2e5-4f72-acd9-4169c74a7524",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "@lrytz thanks for the link. Could you also point me to the place where the `String`/`Array[Strings]` are converted back into an `Array[Byte]`. Thanks.",
        "createdAt" : "2018-01-12T20:59:52Z",
        "updatedAt" : "2018-01-12T20:59:52Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      },
      {
        "id" : "bd924261-51c7-4617-8f72-23e92c447742",
        "parentId" : "2dcc1770-e2e5-4f72-acd9-4169c74a7524",
        "authorId" : "998ba0f7-d6a6-448f-a3ba-0d2237ed0cf9",
        "body" : "It took me a while to find it.. Need to clean this up / document. Method [`parseScalaSigBytes`](https://github.com/scala/scala/blob/68d66968eede247adf6d784e0d8f0f343d9124d4/src/compiler/scala/tools/nsc/symtab/classfile/ClassfileParser.scala#L1125) calls `ConstantPool.getBytes` which goes through `ByteCodecs.decode`.\r\n\r\nThe encoding is explained here http://www.scala-lang.org/old/sites/default/files/sids/dubochet/Mon,%202010-05-31,%2015:25/Storage%20of%20pickled%20Scala%20signatures%20in%20class%20files.pdf\r\n  - first map all 8-bit bytes to 7 bits (shifting the rest)\r\n  - then increment all by 1 (in 7 bits), so 0x7f becomes 0x00\r\n  - then encode 0x00 as 0xc0 0x80, which is an overlong utf 8 encoding for zero. it's what the jvm classfile spec uses to avoid having 0x00 in strings. it's called \"modified utf 8\".\r\n\r\nthe reason for the incrementing by 1 that 0x7f is expected to be less common than 0x00, so the two byte encoding hits less often.\r\n\r\nThe confusing part is that the class `ScalaSigBytes` used in the backend to encode the signature uses `ByteCodecs.encode8to7`, but does the `+1` itself. It doesn't need to map 0x00 to the two byte version because ASM will do it when writing the annotation to the classfile. However, in the unpickler, we don't use ASM to read the annotation, but just get the bytes from the classfile directly. So there we'll see the two byte encoding. `ByteCodecs.decode` does the necessary work.",
        "createdAt" : "2018-01-15T12:43:09Z",
        "updatedAt" : "2018-01-15T12:43:48Z",
        "lastEditedBy" : "998ba0f7-d6a6-448f-a3ba-0d2237ed0cf9",
        "tags" : [
        ]
      }
    ],
    "commit" : "f86bcc55411329662f8930e8c74a145b51050099",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +12,16 @@\n  /** Encode TASTY bytes into a TASTY String */\n  def tastyToString(bytes: Array[Byte]): String = {\n    val chars = new Array[Char](bytes.length)\n    for (i <- bytes.indices) chars(i) = (bytes(i) & 0xff).toChar"
  }
]
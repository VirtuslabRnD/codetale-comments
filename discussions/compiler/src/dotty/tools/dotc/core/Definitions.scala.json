[
  {
    "id" : "60d0c4ee-f6cd-4895-b56c-27410b40dd9c",
    "prId" : 11803,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/11803#pullrequestreview-616391928",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f159bd64-5572-4d9f-9d7d-13f053ce60ae",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Could we use a TreeTypeMap to map the info instead?",
        "createdAt" : "2021-03-19T12:50:53Z",
        "updatedAt" : "2021-03-19T12:50:53Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "6dcf98c5-f5fd-4c6b-a115-5e359cc94ae9",
        "parentId" : "f159bd64-5572-4d9f-9d7d-13f053ce60ae",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "You mean for the `inline` tree in the annotation? It's quite complex -- we need to create a copy of all local symbols (e.g. for type, term symbols, symbols in the function body, etc.) and rewire them.\r\n\r\nFor non-inline symbols, we make strong assumptions on `symbol.info`, which seems to be simpler.",
        "createdAt" : "2021-03-19T12:56:20Z",
        "updatedAt" : "2021-03-19T12:56:20Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "9a1bdf86-bf7e-4755-a36f-0fe5e3d82d90",
        "parentId" : "f159bd64-5572-4d9f-9d7d-13f053ce60ae",
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "I meant for both, but I don't know if TreeTypeMap works on inline defs",
        "createdAt" : "2021-03-19T13:02:32Z",
        "updatedAt" : "2021-03-19T13:02:32Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "5274599b-9f7c-41b3-be7e-46365e1a9fd8",
        "parentId" : "f159bd64-5572-4d9f-9d7d-13f053ce60ae",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "I don't see a principled way to do this --- a map needs to make assumptions about `from` and `to`. We will not make fewer assumptions and the code will be complex.",
        "createdAt" : "2021-03-19T13:21:22Z",
        "updatedAt" : "2021-03-19T13:21:22Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      }
    ],
    "commit" : "1edd3ca1add08e39df8899a5fcd57a63631d4759",
    "line" : 39,
    "diffHunk" : "@@ -1,1 +1146,1150 @@          patch\n        else\n          // change `info` which might contain reference to the patch\n          patch.copy(\n            owner = denot.symbol,"
  },
  {
    "id" : "8448544d-8e7e-4e87-b67a-882073bec28f",
    "prId" : 11803,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/11803#pullrequestreview-616704491",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2e4dc1ab-b3d4-4c85-b559-1627af8b26d0",
        "parentId" : null,
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Why can't we use `patch.copy(...)` here? Would that not be shorter?",
        "createdAt" : "2021-03-19T18:36:14Z",
        "updatedAt" : "2021-03-19T18:36:48Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "c496abe4-a3b7-464a-b9ee-bcaf57a3164c",
        "parentId" : "2e4dc1ab-b3d4-4c85-b559-1627af8b26d0",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "The reason is that `info` and `symbol` depend on each other, and `Symbol.copy` does not support that.",
        "createdAt" : "2021-03-19T18:49:36Z",
        "updatedAt" : "2021-03-19T18:49:36Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      }
    ],
    "commit" : "1edd3ca1add08e39df8899a5fcd57a63631d4759",
    "line" : 11,
    "diffHunk" : "@@ -1,1 +1118,1122 @@\n      def makeClassSymbol(patch: Symbol, parents: List[Type], selfInfo: TypeOrSymbol) =\n        newClassSymbol(\n          owner = denot.symbol,\n          name = patch.name.asTypeName,"
  },
  {
    "id" : "adf6da2b-abd5-413c-94f5-67c7a67056e6",
    "prId" : 11803,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/11803#pullrequestreview-616726135",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "35437f9f-7cf7-45fe-9793-4cb76393e254",
        "parentId" : null,
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Would it not be shorter to use `derivedClassInfo` here?",
        "createdAt" : "2021-03-19T18:36:42Z",
        "updatedAt" : "2021-03-19T18:36:48Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "f000e409-4366-498c-a6cf-4cf171864c85",
        "parentId" : "35437f9f-7cf7-45fe-9793-4cb76393e254",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "That does not make much difference, as we change all fields here except `parents`. On the other hand, using the constructor makes the implicit assumptions explicit and clear here.",
        "createdAt" : "2021-03-19T19:20:45Z",
        "updatedAt" : "2021-03-22T07:01:17Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      }
    ],
    "commit" : "1edd3ca1add08e39df8899a5fcd57a63631d4759",
    "line" : 16,
    "diffHunk" : "@@ -1,1 +1123,1127 @@          flags = patch.flags,\n          // need to rebuild a fresh ClassInfo\n          infoFn = cls => ClassInfo(\n            prefix = denot.symbol.thisType,\n            cls = cls,"
  },
  {
    "id" : "e426fa66-014a-4ce9-9248-da8b2a29e2c7",
    "prId" : 9875,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/9875#pullrequestreview-496927336",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "56eed62f-3616-4751-b6ff-96ba6d5aaf7e",
        "parentId" : null,
        "authorId" : "317b625a-4db6-4333-bf57-152beea40aa0",
        "body" : "In the old days, we would move the condition to pattern guard in order to avoid parens. Now we will do it to avoid `then`.",
        "createdAt" : "2020-09-26T01:14:40Z",
        "updatedAt" : "2020-09-26T15:31:10Z",
        "lastEditedBy" : "317b625a-4db6-4333-bf57-152beea40aa0",
        "tags" : [
        ]
      }
    ],
    "commit" : "5396e712ff0719396e115bbee4c0865b339bc515",
    "line" : 19,
    "diffHunk" : "@@ -1,1 +1445,1449 @@        asContextFunctionType(TypeComparer.bounds(tp1).hiBound)\n      case tp1 =>\n        if tp1.typeSymbol.name.isContextFunction && isFunctionType(tp1) then tp1\n        else NoType\n"
  },
  {
    "id" : "0693ab59-1d64-410b-b411-1d5b2643fa3e",
    "prId" : 9487,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/9487#pullrequestreview-463330637",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f5e02785-1206-44b3-8957-548bb5b3ed87",
        "parentId" : null,
        "authorId" : "128563de-a925-4397-af34-450c7978a8d2",
        "body" : "could you also edit the commit message so that it fixes #7174?",
        "createdAt" : "2020-08-07T10:49:29Z",
        "updatedAt" : "2020-08-07T13:52:35Z",
        "lastEditedBy" : "128563de-a925-4397-af34-450c7978a8d2",
        "tags" : [
        ]
      },
      {
        "id" : "7aeb0d92-a4a5-4ccf-abb4-105c67026311",
        "parentId" : "f5e02785-1206-44b3-8957-548bb5b3ed87",
        "authorId" : "1614befc-b7c0-4881-9ad3-a889222eff91",
        "body" : "yup!",
        "createdAt" : "2020-08-07T13:52:52Z",
        "updatedAt" : "2020-08-07T13:52:52Z",
        "lastEditedBy" : "1614befc-b7c0-4881-9ad3-a889222eff91",
        "tags" : [
        ]
      }
    ],
    "commit" : "72d932228890e1fed73fb0b423b88019727e5812",
    "line" : 25,
    "diffHunk" : "@@ -1,1 +606,610 @@                }\n            }\n            val argConstr = constr.copy().entered\n            constr.info = noArgInfo\n            constr.termRef.recomputeDenot()"
  },
  {
    "id" : "3f9dd005-0dee-4ed7-9fc2-0699a17aca14",
    "prId" : 8386,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/8386#pullrequestreview-369896509",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "80254b12-b5c2-49e4-91c4-492e02ad1c37",
        "parentId" : null,
        "authorId" : "3a3c9c08-5985-41f6-a86b-7fc5a427f51a",
        "body" : "I think this object belongs at `Types.scala`.",
        "createdAt" : "2020-03-04T13:20:18Z",
        "updatedAt" : "2020-03-06T08:16:40Z",
        "lastEditedBy" : "3a3c9c08-5985-41f6-a86b-7fc5a427f51a",
        "tags" : [
        ]
      },
      {
        "id" : "6691c2ae-9fee-472f-9b35-fa75051d1197",
        "parentId" : "80254b12-b5c2-49e4-91c4-492e02ad1c37",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "One can debate this. I put it next to `isContextFunctionType` and `asContextFunctionType`, since it is related.",
        "createdAt" : "2020-03-05T20:38:40Z",
        "updatedAt" : "2020-03-06T08:16:40Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "cbd21a0fbfd0c566f55649dc1dcfcb054529f18b",
    "line" : 18,
    "diffHunk" : "@@ -1,1 +1272,1276 @@   *  types `As`, the result type `B` and a whether the type is an erased context function.\n   */\n  object ContextFunctionType:\n    def unapply(tp: Type)(using ctx: Context): Option[(List[Type], Type, Boolean)] =\n      if ctx.erasedTypes then unapply(tp)(using ctx.withPhase(ctx.erasurePhase))"
  },
  {
    "id" : "01ccaa04-8fc9-4ab1-a91a-630d7b13e748",
    "prId" : 7546,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/7546#pullrequestreview-331554735",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "226e40cd-e0e3-49f9-bcda-e7285ceefed8",
        "parentId" : null,
        "authorId" : "00348044-aa34-44f1-847a-bd79483e589b",
        "body" : "javax.validation.constraints.NotNull",
        "createdAt" : "2019-12-12T18:16:15Z",
        "updatedAt" : "2019-12-13T22:40:38Z",
        "lastEditedBy" : "00348044-aa34-44f1-847a-bd79483e589b",
        "tags" : [
        ]
      },
      {
        "id" : "d6cfc5bc-2432-4777-a1fe-02a6c3cc98ea",
        "parentId" : "226e40cd-e0e3-49f9-bcda-e7285ceefed8",
        "authorId" : "00348044-aa34-44f1-847a-bd79483e589b",
        "body" : "reactor.util.annotation. NonNull",
        "createdAt" : "2019-12-12T18:18:20Z",
        "updatedAt" : "2019-12-13T22:40:38Z",
        "lastEditedBy" : "00348044-aa34-44f1-847a-bd79483e589b",
        "tags" : [
        ]
      },
      {
        "id" : "94f6a222-b2ca-4da9-96ce-b52f7cad17e4",
        "parentId" : "226e40cd-e0e3-49f9-bcda-e7285ceefed8",
        "authorId" : "00348044-aa34-44f1-847a-bd79483e589b",
        "body" : "org.springframework.lang.NonNull",
        "createdAt" : "2019-12-12T18:20:27Z",
        "updatedAt" : "2019-12-13T22:40:38Z",
        "lastEditedBy" : "00348044-aa34-44f1-847a-bd79483e589b",
        "tags" : [
        ]
      },
      {
        "id" : "3c5304f1-3cd8-4c41-88ef-f4bc965c7b1d",
        "parentId" : "226e40cd-e0e3-49f9-bcda-e7285ceefed8",
        "authorId" : "00348044-aa34-44f1-847a-bd79483e589b",
        "body" : "org.springframework.lang.NonNullApi\r\norg.springframework.lang.NonNullFields",
        "createdAt" : "2019-12-12T18:24:58Z",
        "updatedAt" : "2019-12-13T22:40:38Z",
        "lastEditedBy" : "00348044-aa34-44f1-847a-bd79483e589b",
        "tags" : [
        ]
      },
      {
        "id" : "2baa29fd-25cb-4f0e-a19d-830f9a448bea",
        "parentId" : "226e40cd-e0e3-49f9-bcda-e7285ceefed8",
        "authorId" : "75c8b660-aff3-44c8-9783-7c2d813cea08",
        "body" : "Thanks, I have add them to the list",
        "createdAt" : "2019-12-12T22:02:27Z",
        "updatedAt" : "2019-12-13T22:40:38Z",
        "lastEditedBy" : "75c8b660-aff3-44c8-9783-7c2d813cea08",
        "tags" : [
        ]
      }
    ],
    "commit" : "85c08556cefabc64ca96079b5b891a1761f69c82",
    "line" : 120,
    "diffHunk" : "@@ -1,1 +839,843 @@    \"reactor.util.annotation.NonNull\" ::\n    \"reactor.util.annotation.NonNullApi\" ::\n    \"io.reactivex.annotations.NonNull\" :: Nil map PreNamedString)\n\n  // convenient one-parameter method types"
  },
  {
    "id" : "5e2819c9-c20d-43eb-8768-72de5583c9a0",
    "prId" : 7546,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/7546#pullrequestreview-331433596",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f8751443-bfa7-498e-8809-e96424a7c954",
        "parentId" : null,
        "authorId" : "00348044-aa34-44f1-847a-bd79483e589b",
        "body" : "NotNullAnnotations",
        "createdAt" : "2019-12-12T18:26:53Z",
        "updatedAt" : "2019-12-13T22:40:38Z",
        "lastEditedBy" : "00348044-aa34-44f1-847a-bd79483e589b",
        "tags" : [
        ]
      }
    ],
    "commit" : "85c08556cefabc64ca96079b5b891a1761f69c82",
    "line" : 102,
    "diffHunk" : "@@ -1,1 +821,825 @@  // We don't require that any of these annotations be present in the class path, but we want to\n  // create Symbols for the ones that are present, so they can be checked during nullification.\n  @tu lazy val NotNullAnnots: List[ClassSymbol] = ctx.getClassesIfDefined(\n    \"javax.annotation.Nonnull\" ::\n    \"javax.validation.constraints.NotNull\" ::"
  },
  {
    "id" : "e7bf321d-135e-494b-92e8-0b50d983984a",
    "prId" : 6624,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/6624#pullrequestreview-246682937",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f0d319e1-be92-4da4-80b5-c1903cc4719d",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "ping @sjrd, this might interact with Scala.js reimplementation of Enum: https://github.com/scala-js/scala-js/blob/master/javalanglib/src/main/scala/java/lang/Enum.scala",
        "createdAt" : "2019-06-06T16:00:00Z",
        "updatedAt" : "2019-06-06T16:00:00Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "c320563d-e22d-4c64-931c-4e4cf611c3c9",
        "parentId" : "f0d319e1-be92-4da4-80b5-c1903cc4719d",
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Also it'd be nice to add a comment explaining why this hijacking is necessary.",
        "createdAt" : "2019-06-06T16:00:21Z",
        "updatedAt" : "2019-06-06T16:00:21Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "e493a4e4-21ad-4c55-8562-89b11311b5ee",
        "parentId" : "f0d319e1-be92-4da4-80b5-c1903cc4719d",
        "authorId" : "5a9cd756-9120-4d5e-ac88-e9c636084f0e",
        "body" : "Hum, it's unclear how that would interact with the Scala.js implementation, indeed. However, that's not an immediate problem, because for now Dotty.js reuses the binaries of `java.lang.Enum.sjsir` from Scala.js for scalac.\r\n\r\nWorse come to worst, we would hard-code the .sjsir of `java.lang.Enum` in the distant future where we can actually compile Scala.js' standard library with Dotty.js.",
        "createdAt" : "2019-06-06T16:32:02Z",
        "updatedAt" : "2019-06-06T16:32:02Z",
        "lastEditedBy" : "5a9cd756-9120-4d5e-ac88-e9c636084f0e",
        "tags" : [
        ]
      }
    ],
    "commit" : "0a68c77f023456f0829f7d4423779fda6c783a79",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +617,621 @@\n   @threadUnsafe lazy val JavaEnumClass: ClassSymbol = {\n    val cls = ctx.requiredClass(\"java.lang.Enum\")\n    cls.infoOrCompleter match {\n      case completer: ClassfileLoader =>"
  },
  {
    "id" : "7f1aa2db-ef7c-42b1-9fda-5450edf8a277",
    "prId" : 5927,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/5927#pullrequestreview-204242983",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0fe3594b-12c4-4036-84c4-0e8919924e46",
        "parentId" : null,
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "For my own understanding: Why was this class moved?",
        "createdAt" : "2019-02-15T13:33:02Z",
        "updatedAt" : "2019-02-15T13:34:11Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "dfd14455-4c7e-44f4-9e46-4fe93a73d602",
        "parentId" : "0fe3594b-12c4-4036-84c4-0e8919924e46",
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "I moved it along with <:< and =:= in https://github.com/scala/scala/pull/7350 to keep Predef as lean as possible, classes can be defined at the top-level so I didn't see why these ones in particular should be nested in Predef.",
        "createdAt" : "2019-02-15T13:42:05Z",
        "updatedAt" : "2019-02-15T13:42:31Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      }
    ],
    "commit" : "37ec52c2e0b371f9e8f475d60b5893ca15fb7e95",
    "line" : 11,
    "diffHunk" : "@@ -1,1 +362,366 @@      ScalaPredefModule.requiredClass(\"<:<\")\n\n  def DummyImplicitClass(implicit ctx: Context): ClassSymbol =\n    if (isNewCollections)\n      ctx.requiredClass(\"scala.DummyImplicit\")"
  },
  {
    "id" : "cbb521e5-39f4-49e4-871c-abd083dc101d",
    "prId" : 4938,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/4938#pullrequestreview-152994642",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c7a9372d-b18a-46ba-ba8f-b96c66806406",
        "parentId" : null,
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "This logic looks is quite convoluted. Are there more direct approaches that do not require patching the completers?\r\n",
        "createdAt" : "2018-09-04T11:20:46Z",
        "updatedAt" : "2018-09-06T16:47:42Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      },
      {
        "id" : "635af90f-945c-4d76-8d0c-499bd6905138",
        "parentId" : "c7a9372d-b18a-46ba-ba8f-b96c66806406",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "I looked hard but did not find anything that would work better than patching the completers. The `syntheticParent` code can be simplified using an utility method that I introduced in the subsequent PR #4964. I'll do the simplification there.",
        "createdAt" : "2018-09-06T15:40:18Z",
        "updatedAt" : "2018-09-06T16:47:42Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "42a5a9df1ad852cc3154ee968c25372513aa4ede",
    "line" : 64,
    "diffHunk" : "@@ -1,1 +1246,1250 @@   *  Add the right `*:` instance as a parent to Tuple1..Tuple22\n   */\n  def fixTupleCompleter(cls: ClassSymbol): Unit = cls.infoOrCompleter match {\n    case completer: LazyType =>\n      cls.info = new LazyType {"
  },
  {
    "id" : "c44c3a1c-0e2d-41b8-99c1-d3e29cc72559",
    "prId" : 4672,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/4672#pullrequestreview-243468095",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d9abf36c-6fe5-4645-96e6-27b23f708e38",
        "parentId" : null,
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "This should follow the principle used elsewhere: The TypeRef is computed in the lazy val and the context-dependent symbol follows. This is to make sure that the system keeps functioning if Definition classes are edited and recompiled. If you deviate from this, you create confusion for others.\r\n",
        "createdAt" : "2019-05-24T09:00:03Z",
        "updatedAt" : "2019-05-30T13:05:55Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "74413a14-90ff-441e-b31f-d7f4f7759b35",
        "parentId" : "d9abf36c-6fe5-4645-96e6-27b23f708e38",
        "authorId" : "2c02aea2-3019-42f4-9678-8a2da637c660",
        "body" : "Looking nearby, the pattern seems to be the same as here: the symbol is defined as a lazy val and the typeref as a def. Can you point me to an example which is arranged the way you want it?",
        "createdAt" : "2019-05-24T13:49:58Z",
        "updatedAt" : "2019-05-30T13:05:55Z",
        "lastEditedBy" : "2c02aea2-3019-42f4-9678-8a2da637c660",
        "tags" : [
        ]
      },
      {
        "id" : "81f25b8f-87af-43a5-8ce2-99772846f5d5",
        "parentId" : "d9abf36c-6fe5-4645-96e6-27b23f708e38",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "E.g.\r\n```\r\n  lazy val StringBuilderType: TypeRef      = ctx.requiredClassRef(\"scala.collection.mutable.StringBuilder\")\r\n  def StringBuilderClass(implicit ctx: Context): ClassSymbol = StringBuilderType.symbol.asClass\r\n\r\n```\r\nBut I meant to go over `Definitions` anyway, trying to avoid the duplication and make it safe by design. The problem with the lazy val pattern as you wrote it is that it would not work in interactive mode if `PolyFunction` was edited. Then \r\nthe system would hang on to the first version computed instead of the edited ones. I agree that's a rather esoteric use case. So we can leave it for now.\r\n",
        "createdAt" : "2019-05-29T19:23:47Z",
        "updatedAt" : "2019-05-30T13:05:55Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "112aa55d80bfd626b336fbc57fb4f3b5caeec31c",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +1036,1040 @@    else FunctionClass(n, isContextual, isErased).typeRef\n\n  lazy val PolyFunctionClass = ctx.requiredClass(\"scala.PolyFunction\")\n  def PolyFunctionType = PolyFunctionClass.typeRef\n"
  },
  {
    "id" : "f8d3f88f-a4ff-4285-86a2-50d5964fd9d3",
    "prId" : 4567,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/4567#pullrequestreview-122668437",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d9c5e001-b504-48a9-a7e3-babc3e52657b",
        "parentId" : null,
        "authorId" : "37519144-0f9f-4b2b-85f7-34dde9be2e11",
        "body" : "I guess this should remain commented-out and not removed, right?",
        "createdAt" : "2018-05-23T16:13:24Z",
        "updatedAt" : "2018-05-23T16:29:21Z",
        "lastEditedBy" : "37519144-0f9f-4b2b-85f7-34dde9be2e11",
        "tags" : [
        ]
      },
      {
        "id" : "c1ddf5e2-ef9a-42c3-b19d-1e4073114171",
        "parentId" : "d9c5e001-b504-48a9-a7e3-babc3e52657b",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "Yes, in case we need it for something else again.  It was really useful the first time.",
        "createdAt" : "2018-05-23T16:31:43Z",
        "updatedAt" : "2018-05-23T16:31:43Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      }
    ],
    "commit" : "7cdecc6ef9b3e4a79de40ce437acedaef6c8552c",
    "line" : 25,
    "diffHunk" : "@@ -1,1 +1157,1161 @@  def typeTag(tp: Type)(implicit ctx: Context): Name = typeTags(scalaClassName(tp))\n\n//  /** The `Class[_]` of a primitive value type name */\n//  def valueTypeNameToJavaType(name: TypeName)(implicit ctx: Context): Option[Class[_]] =\n//    valueTypeNamesToJavaType.get(if (name.firstPart eq nme.scala_) name.lastPart.toTypeName else name)"
  },
  {
    "id" : "66c9eae1-a3e9-4f24-ae0b-0d0f03f4ce56",
    "prId" : 3961,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/3961#pullrequestreview-106868563",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d91b94b9-f263-44c2-9723-d83db14f6dac",
        "parentId" : null,
        "authorId" : "223e67d6-1873-432a-9af9-f40b82a7eedd",
        "body" : "@smarter Can you comment on this? Should we expose only the ones used in the optimisation (i.e. `StringContextRaw`, `StringContextS`, `StringContextModule_apply`)? Should these values be inlined in the mini phase and be initialised in `prepareForUnit`?",
        "createdAt" : "2018-03-26T11:52:42Z",
        "updatedAt" : "2018-04-15T19:40:40Z",
        "lastEditedBy" : "223e67d6-1873-432a-9af9-f40b82a7eedd",
        "tags" : [
        ]
      }
    ],
    "commit" : "449aff2adc01716a22d98e45fc7664ff6b725244",
    "line" : 12,
    "diffHunk" : "@@ -1,1 +592,596 @@  def StringContextModule(implicit ctx: Context) = StringContextClass.companionModule\n    lazy val StringContextModule_applyR = StringContextModule.requiredMethodRef(nme.apply)\n    def StringContextModule_apply(implicit ctx: Context) = StringContextModule_applyR.symbol\n\n  lazy val PartialFunctionType: TypeRef         = ctx.requiredClassRef(\"scala.PartialFunction\")"
  },
  {
    "id" : "3e0549e4-701c-4aa1-a90d-625fa71a0982",
    "prId" : 3869,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/3869#pullrequestreview-90255246",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f8acf000-70c5-4e92-9f83-ca2cfd8b833d",
        "parentId" : null,
        "authorId" : "aa14f673-3d29-4a61-bf43-a86828212cf2",
        "body" : "@smarter pre-calculated the set of methods here, as suggested\r\nPTAL",
        "createdAt" : "2018-01-19T21:46:45Z",
        "updatedAt" : "2018-01-22T23:21:55Z",
        "lastEditedBy" : "aa14f673-3d29-4a61-bf43-a86828212cf2",
        "tags" : [
        ]
      }
    ],
    "commit" : "54829163ceafae2a139f615dce08f39f4ce5d716",
    "line" : 12,
    "diffHunk" : "@@ -1,1 +340,344 @@    lazy val Predef_undefinedR = ScalaPredefModule.requiredMethodRef(\"???\")\n    def Predef_undefined(implicit ctx: Context) = Predef_undefinedR.symbol\n    // The set of all wrap{X, Ref}Array methods, where X is a value type\n    val Predef_wrapArray = new PerRun[collection.Set[Symbol]]({ implicit ctx =>\n      val methodNames = ScalaValueTypes.map(TreeGen.wrapArrayMethodName) + nme.wrapRefArray"
  },
  {
    "id" : "b87feaa1-a1e8-465d-98d4-892825901b2e",
    "prId" : 3342,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/3342#pullrequestreview-82440078",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9517853a-03b4-4c53-b77e-6390f7bf28e3",
        "parentId" : null,
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "I don't understand the logic here (and suspect it might be wrong). \r\n\r\n - what is the parent of an UnusedFunction?\r\n - what of an ImplicitUnusedFunction?\r\n\r\nWould be good to document this.",
        "createdAt" : "2017-12-07T16:10:53Z",
        "updatedAt" : "2018-02-21T10:25:44Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "e064ea0c-90c7-4c6e-a3cc-ef3265ce7952",
        "parentId" : "9517853a-03b4-4c53-b77e-6390f7bf28e3",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "I will add documentation.\r\n",
        "createdAt" : "2017-12-11T10:14:21Z",
        "updatedAt" : "2018-02-21T10:25:44Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      }
    ],
    "commit" : "68afbcd915c5f6e17f4d1347c6a784c9b1639b13",
    "line" : 49,
    "diffHunk" : "@@ -1,1 +135,139 @@        val methodType = MethodType.maker(isJava = false, name.isImplicitFunction, name.isUnusedFunction)\n        val parentTraits =\n          if (!name.isImplicitFunction) Nil\n          else FunctionType(arity, isUnused = name.isUnusedFunction).appliedTo(argParamRefs ::: resParamRef :: Nil) :: Nil\n        decls.enter(newMethod(cls, nme.apply, methodType(argParamRefs, resParamRef), Deferred))"
  },
  {
    "id" : "b934fceb-c6f5-46e4-b4e4-0e474bb6bac6",
    "prId" : 2398,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/2398#pullrequestreview-37516188",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "311fdc37-3d8f-4e81-9ac0-bbb9bacd23ad",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Where is the `ctx` parameter used here?",
        "createdAt" : "2017-05-08T17:27:03Z",
        "updatedAt" : "2017-05-08T17:27:03Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "a78284ea-bcf4-46c9-b196-20b6200ae6a1",
        "parentId" : "311fdc37-3d8f-4e81-9ac0-bbb9bacd23ad",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "This might be needed for other synthetic functions like the functions that take phantom parameters. ",
        "createdAt" : "2017-05-11T08:49:53Z",
        "updatedAt" : "2017-05-11T08:49:54Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      }
    ],
    "commit" : "71cadcea87220b89b7eff80c8ff7daaf5cb34b49",
    "line" : 17,
    "diffHunk" : "@@ -1,1 +193,197 @@    val cls = ScalaPackageVal.moduleClass.asClass\n    cls.info.decls.openForMutations.useSynthesizer(\n      name => ctx =>\n        if (name.isTypeName && name.isSyntheticFunction) newFunctionNTrait(name.asTypeName)\n        else NoSymbol)"
  },
  {
    "id" : "30255f14-c84b-481f-9807-ca9aad18a96d",
    "prId" : 1758,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/1758#pullrequestreview-10967069",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "df2ced7a-2d2a-4a6b-ab8d-4e582e82d119",
        "parentId" : null,
        "authorId" : "6d71bb21-e402-4464-b2b1-8bdd8e068461",
        "body" : "`functionArity(tp)` could be replaced with `arity`",
        "createdAt" : "2016-12-01T13:49:46Z",
        "updatedAt" : "2016-12-01T13:49:46Z",
        "lastEditedBy" : "6d71bb21-e402-4464-b2b1-8bdd8e068461",
        "tags" : [
        ]
      }
    ],
    "commit" : "055f12f957ec176323e4e0bf01af51666b9ff433",
    "line" : 337,
    "diffHunk" : "@@ -1,1 +732,736 @@    isFunctionClass(tp.dealias.typeSymbol) && {\n      val arity = functionArity(tp)\n      arity >= 0 && tp.isRef(FunctionType(functionArity(tp)).typeSymbol)\n    }\n"
  }
]
[
  {
    "id" : "3806070d-c39e-4efb-babe-51f9d0bbbb97",
    "prId" : 10916,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/10916#pullrequestreview-561974259",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9c1a3553-5420-4f7a-bcfc-ca89c0673d13",
        "parentId" : null,
        "authorId" : "6998ebc0-40b8-4e52-b4f8-721fd5d8c0a9",
        "body" : "Just to be sure, adding the `followIFT` argument will only affect the fall through case and will be dropped for recursive calls. Is this intended?",
        "createdAt" : "2021-01-04T10:35:44Z",
        "updatedAt" : "2021-01-04T10:35:48Z",
        "lastEditedBy" : "6998ebc0-40b8-4e52-b4f8-721fd5d8c0a9",
        "tags" : [
        ]
      },
      {
        "id" : "b1c360ed-a210-4a09-8187-e93bc57b5505",
        "parentId" : "9c1a3553-5420-4f7a-bcfc-ca89c0673d13",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Yes, because all recursive normalize calls are against the same `pt`, which determined the value of `followIFT`.\r\n",
        "createdAt" : "2021-01-05T09:35:42Z",
        "updatedAt" : "2021-01-05T09:35:42Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "47801586-1f7c-4a66-b441-122daa602792",
        "parentId" : "9c1a3553-5420-4f7a-bcfc-ca89c0673d13",
        "authorId" : "6998ebc0-40b8-4e52-b4f8-721fd5d8c0a9",
        "body" : "I just wondered whether the check can be inlined at 635 to \r\n```scala\r\nif iftp.exists && !defn.isContextFunctionType(pt) then ...\r\n```\r\nto avoid this additional argument. But this would not be a semantics preserving refactoring since the argument `followIFT` defaults to `true` for the next recursive call.",
        "createdAt" : "2021-01-05T13:11:43Z",
        "updatedAt" : "2021-01-05T13:12:00Z",
        "lastEditedBy" : "6998ebc0-40b8-4e52-b4f8-721fd5d8c0a9",
        "tags" : [
        ]
      },
      {
        "id" : "4b7c929f-3773-4f18-84df-b0ed859dbcf9",
        "parentId" : "9c1a3553-5420-4f7a-bcfc-ca89c0673d13",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "yes, exactly. ",
        "createdAt" : "2021-01-05T17:12:17Z",
        "updatedAt" : "2021-01-05T17:12:18Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "5b6c079a168b281a1406d61e0438cb9b2dfa3d44",
    "line" : 41,
    "diffHunk" : "@@ -1,1 +630,634 @@        }\n      case et: ExprType =>\n        normalize(et.resultType, pt)\n      case wtp =>\n        val iftp = defn.asContextFunctionType(wtp)"
  },
  {
    "id" : "64ad5faa-af2f-48c4-a341-3e5446c6ced3",
    "prId" : 10916,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/10916#pullrequestreview-562522813",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "07a348d5-565d-4703-a257-87919fbabeb1",
        "parentId" : null,
        "authorId" : "6998ebc0-40b8-4e52-b4f8-721fd5d8c0a9",
        "body" : "Sorry for so many questions on such a simple PR. But I noticed that you don't widen `pt` here anymore. Can't this change the result of comparing the types for other examples?",
        "createdAt" : "2021-01-06T10:14:41Z",
        "updatedAt" : "2021-01-06T10:14:41Z",
        "lastEditedBy" : "6998ebc0-40b8-4e52-b4f8-721fd5d8c0a9",
        "tags" : [
        ]
      },
      {
        "id" : "f0082e3a-3693-491e-be25-a87b678c5d84",
        "parentId" : "07a348d5-565d-4703-a257-87919fbabeb1",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "In theory it could, but in practice it did not. Conceptually, the correct thing is not to widen here, so unless we see an example where it causes a problem that should be the default.\r\n",
        "createdAt" : "2021-01-06T10:23:52Z",
        "updatedAt" : "2021-01-06T10:23:52Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "5b6c079a168b281a1406d61e0438cb9b2dfa3d44",
    "line" : 15,
    "diffHunk" : "@@ -1,1 +45,49 @@    def necessarilyCompatible(tp: Type, pt: Type)(using Context): Boolean =\n      val tpn = normalize(tp, pt, followIFT = !defn.isContextFunctionType(pt))\n      necessarySubType(tpn, pt) || tpn.isValueSubType(pt) || viewExists(tpn, pt)\n\n    /** Test compatibility after normalization."
  },
  {
    "id" : "aac3b4a0-01a9-4afe-9c8d-f07f6e6d7676",
    "prId" : 9742,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/9742#pullrequestreview-484048379",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "45533a01-04f3-4310-a371-03223bebc600",
        "parentId" : null,
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "Does the slight difference between `equals` and `eql` have a semantic difference or only a performance difference? In any case, for maintainability, it is worth some explanation here.",
        "createdAt" : "2020-09-08T08:19:17Z",
        "updatedAt" : "2020-09-08T08:19:44Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "60a61998-5136-4316-a97c-aad2780d7fc1",
        "parentId" : "45533a01-04f3-4310-a371-03223bebc600",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "It's only for performance.`eql` does a `eq` on all recursive calls, knowing that all elements are already hash-consed. I'll add an explanation in one of the next PRs\r\n",
        "createdAt" : "2020-09-08T11:40:17Z",
        "updatedAt" : "2020-09-08T11:40:18Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "b0ce52993234f6fde812046264a742253095030a",
    "line" : 61,
    "diffHunk" : "@@ -1,1 +217,221 @@      case _ =>\n        false\n    }\n  }\n"
  },
  {
    "id" : "088554a3-576f-4715-93f7-9a3a7a902fc7",
    "prId" : 9641,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/9641#pullrequestreview-475730084",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "82fe03c7-53ec-4704-bdde-4179243dcaca",
        "parentId" : null,
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "Does it matter?\r\n\r\n```suggestion\r\n      necessarySubType(tpw, ptw) || tpw.isValueSubType(ptw) || viewExists(tpw, ptw)\r\n```",
        "createdAt" : "2020-08-26T13:42:59Z",
        "updatedAt" : "2020-08-26T13:59:24Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "dc70effe-6e24-49a7-b061-8ac339123e67",
        "parentId" : "82fe03c7-53ec-4704-bdde-4179243dcaca",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "I think it would matter if there is an implicit conversion between singleton types. In this case it should be `viewExists(tp, pt)`",
        "createdAt" : "2020-08-26T18:00:43Z",
        "updatedAt" : "2020-08-26T18:00:43Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "812b9365b19005592f037ca9ba7e323614437d49",
    "line" : 18,
    "diffHunk" : "@@ -1,1 +45,49 @@      val tpw = tp.widenExpr\n      val ptw = pt.widenExpr\n      necessarySubType(tpw, ptw) || tpw.isValueSubType(ptw) || viewExists(tp, pt)\n\n    /** Test compatibility after normalization."
  },
  {
    "id" : "36b66463-1331-4be6-b374-3c85471d1f19",
    "prId" : 8824,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/8824#pullrequestreview-401990952",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "cf79a9bf-1b2e-4150-b078-1aca1d290201",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "The documentation above still says \"if result type depends on implicit parameter, replace with fresh type dependent parameter.\"",
        "createdAt" : "2020-04-28T16:07:22Z",
        "updatedAt" : "2020-04-28T20:35:40Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      }
    ],
    "commit" : "7f8a4dbd08cc3e3345af21374c3b18bd1fa44fa1",
    "line" : 36,
    "diffHunk" : "@@ -1,1 +570,574 @@        normalize(constrained(poly).resultType, pt)\n      case mt: MethodType =>\n        if (mt.isImplicitMethod) normalize(resultTypeApprox(mt, wildcardOnly = true), pt)\n        else if (mt.isResultDependent) tp\n        else {"
  },
  {
    "id" : "c7320550-c3a9-4ca2-82c4-4269bd6533b5",
    "prId" : 8728,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/8728#pullrequestreview-404184002",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a2b49588-0d3b-4124-8d66-fff0df85cb52",
        "parentId" : null,
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "Maybe we should introduce a proper internal construct for these trees. Maybe have a `scala.internal.bla.dummyTree[T]` .",
        "createdAt" : "2020-05-01T09:50:12Z",
        "updatedAt" : "2020-05-12T12:34:16Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      },
      {
        "id" : "4766a73f-2756-4e28-ac16-067f8f382291",
        "parentId" : "a2b49588-0d3b-4124-8d66-fff0df85cb52",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "Same for the `unapply`",
        "createdAt" : "2020-05-01T09:50:46Z",
        "updatedAt" : "2020-05-12T12:34:16Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      },
      {
        "id" : "d987d091-c64b-426b-a38c-e6250ba63e74",
        "parentId" : "a2b49588-0d3b-4124-8d66-fff0df85cb52",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "We can improve on this later. ",
        "createdAt" : "2020-05-01T09:51:09Z",
        "updatedAt" : "2020-05-12T12:34:16Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      },
      {
        "id" : "d986be27-a034-4068-8409-66256aecafeb",
        "parentId" : "a2b49588-0d3b-4124-8d66-fff0df85cb52",
        "authorId" : "3a56b927-736f-4aab-8690-358cd24ca570",
        "body" : "@nicolasstucki can you elaborate on what `scala.internal.bla.dummyTree[T]` should be? Some sort of special fictional value? I think creating a special `Tree` subclass for this purpose would work.",
        "createdAt" : "2020-05-01T11:56:55Z",
        "updatedAt" : "2020-05-12T12:34:16Z",
        "lastEditedBy" : "3a56b927-736f-4aab-8690-358cd24ca570",
        "tags" : [
        ]
      },
      {
        "id" : "d6d32577-873a-46b9-bd4b-05a70ae4fd90",
        "parentId" : "a2b49588-0d3b-4124-8d66-fff0df85cb52",
        "authorId" : "3a56b927-736f-4aab-8690-358cd24ca570",
        "body" : "@smarter it turned out that it was `dummyTreeOfType` that was the source of the `null` we talked about. Could you chime in with an opinion on whether it ever makes sense to `adapt` dummy trees created by this function?",
        "createdAt" : "2020-05-01T12:15:14Z",
        "updatedAt" : "2020-05-12T12:34:16Z",
        "lastEditedBy" : "3a56b927-736f-4aab-8690-358cd24ca570",
        "tags" : [
        ]
      },
      {
        "id" : "ff6f99e9-097c-49f1-972b-c3cfaeabfcd2",
        "parentId" : "a2b49588-0d3b-4124-8d66-fff0df85cb52",
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "honestly no clue, I myself only learned about dummyTreeOfType recently.",
        "createdAt" : "2020-05-01T14:19:36Z",
        "updatedAt" : "2020-05-12T12:34:16Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      }
    ],
    "commit" : "b98d94bcd5f6750f6cb312ad2f6726453d9006ab",
    "line" : 20,
    "diffHunk" : "@@ -1,1 +693,697 @@\n    def apply(tp: Type)(implicit src: SourceFile): Tree =\n      (untpd.Literal(Constant(null)) withTypeUnchecked tp).withAttachment(IsDummyTree, ())\n    def unapply(tree: untpd.Tree): Option[Type] = tree match {\n      case Literal(Constant(null)) => Some(tree.typeOpt)"
  },
  {
    "id" : "3554cfcf-9480-4d6a-bb0f-8963fdff8b0a",
    "prId" : 7065,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/7065#pullrequestreview-279104390",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6f7174af-6350-4d55-9e73-5fb9282da27e",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "The documentation is now misleading, also is there a reason why `alwaysAddTypeVars = ctx.typerState.isCommittable` is not a good default for the other overload ?",
        "createdAt" : "2019-08-19T12:42:16Z",
        "updatedAt" : "2019-08-24T17:44:43Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "06132ef6-f6fa-4309-bdf5-2d09ad0203fa",
        "parentId" : "6f7174af-6350-4d55-9e73-5fb9282da27e",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "it would be a good default, except that the default value would refer to the `ctx` which follows.",
        "createdAt" : "2019-08-23T16:35:29Z",
        "updatedAt" : "2019-08-24T17:44:43Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "bf0095d8c73cacee600cb282f85b67d68c1a81c0",
    "line" : 22,
    "diffHunk" : "@@ -1,1 +507,511 @@      alwaysAddTypeVars = tl.isInstanceOf[PolyType] && ctx.typerState.isCommittable)\n\n  /**  Same as `constrained(tl, EmptyTree)`, but returns just the created type lambda */\n  def constrained(tl: TypeLambda)(implicit ctx: Context): TypeLambda =\n    constrained(tl, EmptyTree)._1"
  },
  {
    "id" : "27a5399b-6fa4-44bb-af39-d6c978c25879",
    "prId" : 7065,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/7065#pullrequestreview-279115840",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c8c84d70-f3bf-45b4-9b48-2f6eccb3ab9e",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "If we change the assertion then this message also needs to be updated I think:\r\n```suggestion\r\n        s\"inconsistent: typevars were added to non-committable constraint ${state.constraint}\")\r\n```",
        "createdAt" : "2019-08-23T16:56:51Z",
        "updatedAt" : "2019-08-24T17:44:43Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "2392549a-a3fe-40f7-a6a0-650bbceb2fe7",
        "parentId" : "c8c84d70-f3bf-45b4-9b48-2f6eccb3ab9e",
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "ah nevermind I got confused, the current message is correct.",
        "createdAt" : "2019-08-23T17:00:16Z",
        "updatedAt" : "2019-08-24T17:44:43Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      }
    ],
    "commit" : "bf0095d8c73cacee600cb282f85b67d68c1a81c0",
    "line" : 11,
    "diffHunk" : "@@ -1,1 +485,489 @@    if (tl.isInstanceOf[PolyType])\n      assert(!ctx.typerState.isCommittable || addTypeVars,\n        s\"inconsistent: no typevars were added to committable constraint ${state.constraint}\")\n      // hk type lambdas can be added to constraints without typevars during match reduction\n"
  },
  {
    "id" : "e5575a96-7bb7-468f-9b9d-17d6cdbb397e",
    "prId" : 6132,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/6132#pullrequestreview-219173624",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "57c0843e-4a7f-44a3-9679-7fbe099a6b39",
        "parentId" : null,
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "Why not do it for partial functions too?",
        "createdAt" : "2019-03-25T09:04:29Z",
        "updatedAt" : "2019-03-26T21:47:19Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "778c69b6-2248-4534-b241-4a585407282a",
        "parentId" : "57c0843e-4a7f-44a3-9679-7fbe099a6b39",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "That's actually already the case since partial functions are also accepted by the `functionWithUnknownParamType` extractor. A added a sentence to the doc page that clarifies this.\r\n",
        "createdAt" : "2019-03-26T21:36:28Z",
        "updatedAt" : "2019-03-26T21:47:19Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "cd9e7e153c428cd5628e54115b06d330a2ced3bf",
    "line" : 69,
    "diffHunk" : "@@ -1,1 +287,291 @@            targ = arg.withType(defn.FunctionOf(paramTypes, WildcardType))\n          case Some(_) if !force =>\n            targ = arg.withType(WildcardType)\n          case _ =>\n            targ = typerFn(arg)"
  },
  {
    "id" : "01775b38-8504-4c06-aac8-b8c59329c845",
    "prId" : 5836,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/5836#pullrequestreview-199833491",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "298c5cc6-1a78-42d4-963a-886fb3a96db0",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Why the special case when one of the argument is polymorphic ?",
        "createdAt" : "2019-02-04T15:03:17Z",
        "updatedAt" : "2019-02-04T21:32:35Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "632c2dd4-a9d4-4e74-844d-020048a64f9a",
        "parentId" : "298c5cc6-1a78-42d4-963a-886fb3a96db0",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "It's in the comment.",
        "createdAt" : "2019-02-04T21:35:24Z",
        "updatedAt" : "2019-02-04T21:35:24Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "17611e9e-e46c-46cf-aa33-7ddc03ff5e3f",
        "parentId" : "298c5cc6-1a78-42d4-963a-886fb3a96db0",
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Sorry, not following, which comment ?",
        "createdAt" : "2019-02-04T22:12:26Z",
        "updatedAt" : "2019-02-04T22:12:26Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      }
    ],
    "commit" : "75178c44e773a5514e630b4c4aeeb8306fc6ea80",
    "line" : 68,
    "diffHunk" : "@@ -1,1 +256,260 @@      // See remark in normalizedCompatible for why we can't keep the constraint\n      // if one of the arguments has a PolyType.\n      typer.isApplicable(tp, Nil, args, resultType, keepConstraint && !args.exists(isPoly))\n    }\n"
  },
  {
    "id" : "8f3139d0-7f2d-41d6-b289-4bd5d3f23055",
    "prId" : 5836,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/5836#pullrequestreview-199817387",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "48cb705b-0aaf-4dbc-8412-2556c2582f1c",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Could we add a pending test that demonstrates the current limitation here ?",
        "createdAt" : "2019-02-04T15:17:05Z",
        "updatedAt" : "2019-02-04T21:32:35Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "e3ade068-14cc-4548-91ac-b9a7b31ccd2c",
        "parentId" : "48cb705b-0aaf-4dbc-8412-2556c2582f1c",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "I don't have a test for this (but agree it would be good to have one).\r\n",
        "createdAt" : "2019-02-04T21:32:27Z",
        "updatedAt" : "2019-02-04T21:32:35Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "75178c44e773a5514e630b4c4aeeb8306fc6ea80",
    "line" : 23,
    "diffHunk" : "@@ -1,1 +52,56 @@            // assertion failure in `constrained`. To do better, we'd have to change the\n            // constraint handling architecture so that some type parameters are committable\n            // and others are not. But that's a whole different ballgame.\n            normalizedCompatible(tp, pt, keepConstraint = false)\n          case _ => testCompat"
  },
  {
    "id" : "578d13b6-8fad-483e-bccc-e0f3ecac7774",
    "prId" : 5114,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/5114#pullrequestreview-181123257",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0271dd39-a1d4-469a-843a-65e1d532aac3",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Hmm what guarantee do we have that not mapping over the args is OK here ?",
        "createdAt" : "2018-12-03T00:28:31Z",
        "updatedAt" : "2018-12-05T21:52:21Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "9b33e6ef-2d85-453f-bd73-2ad722c14697",
        "parentId" : "0271dd39-a1d4-469a-843a-65e1d532aac3",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "The intuition is to be analogous to FunProto where argument types are also not transformed. The arguments of a PolyProto are conceptually program trees, which are not transformed, we only store them as types because we don't need the tree information. ",
        "createdAt" : "2018-12-04T07:48:33Z",
        "updatedAt" : "2018-12-05T21:52:21Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "49bae02f0265878818483442800c2e240cbeba5e",
    "line" : 66,
    "diffHunk" : "@@ -1,1 +436,440 @@\n    def map(tm: TypeMap)(implicit ctx: Context): PolyProto =\n      derivedPolyProto(targs, tm(resultType))\n\n    def fold[T](x: T, ta: TypeAccumulator[T])(implicit ctx: Context): T ="
  },
  {
    "id" : "20c00587-0990-470b-9659-559d0c9b1dca",
    "prId" : 4871,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/4871#pullrequestreview-142263307",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "cf8cb61b-7354-4f4e-aa74-455c358fc1ce",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "This wasn't done before either, but shouldn't `state.typedArgs` be reset to an empty map too?",
        "createdAt" : "2018-07-31T21:35:20Z",
        "updatedAt" : "2018-08-01T14:03:36Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "0fd6b3fd-7512-4c72-8840-92c8a517454a",
        "parentId" : "cf8cb61b-7354-4f4e-aa74-455c358fc1ce",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Maybe. But I only wanted to do the minimum change here. We have to come back to this at some point.",
        "createdAt" : "2018-08-01T07:55:44Z",
        "updatedAt" : "2018-08-01T14:03:36Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "2e708a1d3cf0b235c103aa0412910fd5a702d7be",
    "line" : 62,
    "diffHunk" : "@@ -1,1 +260,264 @@          typr.println(i\"need to invalidate $arg / ${state.typedArg(arg)}, ${tstateConstr._2}, current = ${ctx.typerState.constraint}\")\n          state.typedArg = state.typedArg.remove(arg)\n          state.evalState = state.evalState.remove(arg)\n        }\n      }"
  },
  {
    "id" : "b432171f-3bec-4d17-9fdc-80d764b60790",
    "prId" : 4411,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/4411#pullrequestreview-116168754",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6c4a527b-57ef-4045-951d-df32af40a904",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Here too, the error recovery case could be more explicit:\r\n```scala\r\nif (!tp.widenExpr.isValueTypeOrWildcard) {\r\n  assert(ctx.reporter.errorsReported)\r\n  WildcardType\r\n}\r\nelse if (ctx.mode.is(Mode.TypevarsMissContext))\r\n  WildcardType\r\nelse ...\r\n```",
        "createdAt" : "2018-04-29T14:35:46Z",
        "updatedAt" : "2018-04-29T16:45:57Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "a0904d1b-74b2-4d84-bd22-fbb9c1a85fa1",
        "parentId" : "6c4a527b-57ef-4045-951d-df32af40a904",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Same response: I am not sure the error would always be detected beforehand.\r\n",
        "createdAt" : "2018-04-29T14:40:53Z",
        "updatedAt" : "2018-04-29T16:45:57Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "690321d2aa75001873bf4a2e5183cacf6bffe61f",
    "line" : 17,
    "diffHunk" : "@@ -1,1 +483,487 @@      def replacement(tp: Type) =\n        if (ctx.mode.is(Mode.TypevarsMissContext) ||\n            !tp.widenExpr.isValueTypeOrWildcard) WildcardType\n        else newDepTypeVar(tp)\n      mt.resultType.substParams(mt, mt.paramInfos.map(replacement))"
  },
  {
    "id" : "c2e24e2a-6e10-4570-9769-e6692cada9a5",
    "prId" : 2892,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/2892#pullrequestreview-51022776",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c3f6c2c9-b3f8-4c6d-85aa-b7677fac41ae",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Wouldn't it be safer to do use a new TyperState? (ctx.fresh.setNewTyperState and then commit if we want to keep it)",
        "createdAt" : "2017-07-19T19:36:25Z",
        "updatedAt" : "2017-07-19T20:08:34Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "41a69a5c-cb1a-4d1f-984c-822110ea1c3a",
        "parentId" : "c3f6c2c9-b3f8-4c6d-85aa-b7677fac41ae",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Yes, except that constrainResult is called often, so copying the context each time would  likely be a hit in performance. Also, the logic here is analogous to isSubType, which makes sense.\r\n",
        "createdAt" : "2017-07-19T19:57:26Z",
        "updatedAt" : "2017-07-19T20:08:34Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "ba801d5ca48e1bfc4f284fd071b7571a32283928",
    "line" : 19,
    "diffHunk" : "@@ -1,1 +56,60 @@     */\n    def constrainResult(mt: Type, pt: Type)(implicit ctx: Context): Boolean = {\n      val savedConstraint = ctx.typerState.constraint\n      val res = pt match {\n        case pt: FunProto =>"
  }
]
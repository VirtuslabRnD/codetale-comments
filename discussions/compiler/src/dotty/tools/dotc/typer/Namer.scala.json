[
  {
    "id" : "7c72a98f-87b6-49f9-b837-1f5e5b2ae46f",
    "prId" : 10949,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/10949#pullrequestreview-562631006",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f52501fb-03b6-4751-a1d1-f933941ec510",
        "parentId" : null,
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "I don't understand the special treatment of `Given` here. I did not see anything in the issue that referred to that. Can you explain what happens here?",
        "createdAt" : "2021-01-01T12:47:55Z",
        "updatedAt" : "2021-01-12T17:34:31Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "6859532f-02c7-4246-aca3-0195ffa70bb7",
        "parentId" : "f52501fb-03b6-4751-a1d1-f933941ec510",
        "authorId" : "128563de-a925-4397-af34-450c7978a8d2",
        "body" : "When we discover a `given` definition and the import selector permits `given` definitions then here we only export that single definition. But we still want to count the name of that `given` as unseen, so we may export non-`given` overloads.\r\n\r\nIn the case that the visited definition is not `given` then we find all overloads that are not `given` and export those. We then add the name to the set of seen names so that we do not attempt to export the same overload twice, which causes a crash.",
        "createdAt" : "2021-01-06T11:39:00Z",
        "updatedAt" : "2021-01-12T17:34:31Z",
        "lastEditedBy" : "128563de-a925-4397-af34-450c7978a8d2",
        "tags" : [
        ]
      }
    ],
    "commit" : "7ebdc1c0a1d738faf1656bca7f088052c484f43f",
    "line" : 19,
    "diffHunk" : "@@ -1,1 +1099,1103 @@              // need to filter them out here (by contrast, Scala 3 superaccessors are Artifacts)\n              val alias = mbr.name.toTermName\n              if mbr.symbol.is(Given) then\n                if !seen.contains(alias) && mbr.matchesImportBound(givenBound) then\n                  addForwarder(alias, mbr, span)"
  },
  {
    "id" : "0673324f-cdea-426a-9b40-119c75076701",
    "prId" : 10428,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/10428#pullrequestreview-536540493",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "deba72f7-202b-4620-b776-486531a2c1fa",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "What happens when we pickle Predef.scala to Tasty, then unpickle it? As far as I can tell, since we're only adding symbols and not trees, the pickled Predef won't have the extra definitions, so we need to run `patchStdlibClass` in TreeUnpickler too.",
        "createdAt" : "2020-11-23T00:26:15Z",
        "updatedAt" : "2020-11-24T12:01:39Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "da53b63e-a5f9-4070-93fa-55ab629fd48a",
        "parentId" : "deba72f7-202b-4620-b776-486531a2c1fa",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "But do we ever unpickle Predef from Tasty? Why would we want to do that? ",
        "createdAt" : "2020-11-23T09:08:13Z",
        "updatedAt" : "2020-11-24T12:01:39Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "dca0f07d-865b-4c81-8bc4-3a228f52972a",
        "parentId" : "deba72f7-202b-4620-b776-486531a2c1fa",
        "authorId" : "3a56b927-736f-4aab-8690-358cd24ca570",
        "body" : "The doctool should probably see the unpickled Predef, for definition lookup purposes. I'd also worry about any user of Tasty Inspector that wants to look up definitions in `Predef`.",
        "createdAt" : "2020-11-23T10:22:48Z",
        "updatedAt" : "2020-11-24T12:01:39Z",
        "lastEditedBy" : "3a56b927-736f-4aab-8690-358cd24ca570",
        "tags" : [
        ]
      },
      {
        "id" : "ccea9c1e-325e-4233-b4d0-5c9f2e0d8609",
        "parentId" : "deba72f7-202b-4620-b776-486531a2c1fa",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "But so far nobody pickles Predef into Tasty, right?\r\n",
        "createdAt" : "2020-11-23T14:37:01Z",
        "updatedAt" : "2020-11-24T12:01:39Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "12889927-5cd7-4751-bd88-a0356a9851fc",
        "parentId" : "deba72f7-202b-4620-b776-486531a2c1fa",
        "authorId" : "3a56b927-736f-4aab-8690-358cd24ca570",
        "body" : "I checked and it seems a `Predef.tasty` file is created, we also document it in the doctool already:\r\nhttps://scala3doc.virtuslab.com/pr-master/scala3-stdlib/api/scala/-predef/index.html?query=%20object%20Predef%20extends%20LowPriorityImplicits",
        "createdAt" : "2020-11-23T14:46:50Z",
        "updatedAt" : "2020-11-24T12:01:39Z",
        "lastEditedBy" : "3a56b927-736f-4aab-8690-358cd24ca570",
        "tags" : [
        ]
      }
    ],
    "commit" : "c351094f371729bb83d74fbaa8face9252ca4f12",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +1200,1204 @@      if (cls.isNoInitsClass) cls.primaryConstructor.setFlag(StableRealizable)\n      processExports(using localCtx)\n      defn.patchStdLibClass(denot.asClass)\n    }\n  }"
  },
  {
    "id" : "a423a1c1-2943-4df9-9c16-b6a7fec51f03",
    "prId" : 9978,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/9978#pullrequestreview-506170432",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c5d5a798-eaab-4444-ad07-f44245cb1afc",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Alternatively I guess we could set these flags for superaccessors in Scala2Unpickler, that way we're sure they're treated like the dotty ones.",
        "createdAt" : "2020-10-10T17:17:16Z",
        "updatedAt" : "2020-10-10T17:17:16Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "6ee30824-8188-4c0b-ba65-4b1938e244ba",
        "parentId" : "c5d5a798-eaab-4444-ad07-f44245cb1afc",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "I'd consider that if we find other areas where the missing flag for super accessors messes things up. As it is now, we exercise the test a lot less often than if we have to test every symbol read from Scala 2 for whether it is a super accessor.\r\n",
        "createdAt" : "2020-10-11T11:32:19Z",
        "updatedAt" : "2020-10-11T11:32:19Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "6219b3f6509f39278b8f3ed14c0dc7f7d4850840",
    "line" : 9,
    "diffHunk" : "@@ -1,1 +1031,1035 @@          for mbr <- path.tpe.membersBasedOnFlags(required = EmptyFlags, excluded = PrivateOrSynthetic) do\n            if !mbr.symbol.isSuperAccessor then\n              // Scala 2 superaccessors have neither Synthetic nor Artfact set, so we\n              // need to filter them out here (by contrast, Scala 3 superaccessors are Artifacts)\n              val alias = mbr.name.toTermName"
  },
  {
    "id" : "13d41830-cb14-4068-8617-085773479d87",
    "prId" : 6842,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/6842#pullrequestreview-261939774",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e2d58296-3c7d-418e-be6c-f6f6cfbf2516",
        "parentId" : null,
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "I'd more the original comment here:\r\n\r\n  // If effective owner is a package `p`, widen `private` to `private[p]`",
        "createdAt" : "2019-07-15T16:46:58Z",
        "updatedAt" : "2019-07-15T18:05:14Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "b602d83b8972955578f3e49c3be182a8d351c1e6",
    "line" : 27,
    "diffHunk" : "@@ -1,1 +325,329 @@      if (flags.is(Private) && effectiveOwner.is(Package)) {\n        // If effective owner is a package p, widen private to private[p]\n        flags1 = flags1 &~ Private\n        privateWithin = effectiveOwner\n      }"
  },
  {
    "id" : "cf67c64c-42e3-4526-8f3b-a5e40c4a5d0c",
    "prId" : 6243,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/6243#pullrequestreview-223454602",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f184e380-861a-4d00-b0a3-1486567490ac",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Update the method documentation.",
        "createdAt" : "2019-04-05T19:59:15Z",
        "updatedAt" : "2019-04-09T12:37:37Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      }
    ],
    "commit" : "1ed5d3c7eada5b65dd38611e6da54e6771495a67",
    "line" : 16,
    "diffHunk" : "@@ -1,1 +1329,1333 @@          case _ => tp.widen.widenUnion\n        }\n        tp1.dropRepeatedAnnot\n      }\n"
  },
  {
    "id" : "518f83ff-11a3-4007-b276-25bd11c2c6d4",
    "prId" : 6169,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/6169#pullrequestreview-221692606",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8c10f280-311a-4b2a-84d4-1c28ac7ee4d4",
        "parentId" : null,
        "authorId" : "6d71bb21-e402-4464-b2b1-8bdd8e068461",
        "body" : "`Synthetic`?",
        "createdAt" : "2019-04-02T11:47:41Z",
        "updatedAt" : "2019-04-03T09:44:49Z",
        "lastEditedBy" : "6d71bb21-e402-4464-b2b1-8bdd8e068461",
        "tags" : [
        ]
      },
      {
        "id" : "d6f2ddde-7913-4161-a9c6-363d5f7cd7af",
        "parentId" : "8c10f280-311a-4b2a-84d4-1c28ac7ee4d4",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "No, I don't think we want to make them Synthetic . ",
        "createdAt" : "2019-04-02T14:24:37Z",
        "updatedAt" : "2019-04-03T09:44:49Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "1731ba770156c0ba6e1128f2e9cded9aa224f472",
    "line" : 67,
    "diffHunk" : "@@ -1,1 +989,993 @@                ctx.newSymbol(\n                  cls, alias,\n                  Method | Final | maybeStable | mbr.symbol.flags & ImplicitOrImplied,\n                  mbr.info.ensureMethodic,\n                  coord = span)"
  },
  {
    "id" : "b3300216-607f-44e3-8649-2361cd3b116b",
    "prId" : 5736,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/5736#pullrequestreview-234048640",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "dfbaa203-c4f3-48d8-9115-911e0a8536dd",
        "parentId" : null,
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Let's refactor this into a common method that is also called from `typedDefDef`.\r\n",
        "createdAt" : "2019-04-05T15:27:41Z",
        "updatedAt" : "2019-05-13T12:55:51Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "dae94af2-e963-4b7c-85f7-9df16185dfe1",
        "parentId" : "dfbaa203-c4f3-48d8-9115-911e0a8536dd",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "I did not understand why we need to add type parameters to GADT bounds here (or in typedDefDef). This should be documented.",
        "createdAt" : "2019-04-05T15:36:54Z",
        "updatedAt" : "2019-05-13T12:55:51Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "bf5dc0d8-47ec-449a-80f8-5e20eecdda30",
        "parentId" : "dfbaa203-c4f3-48d8-9115-911e0a8536dd",
        "authorId" : "3a56b927-736f-4aab-8690-358cd24ca570",
        "body" : "Comments were added to both places.",
        "createdAt" : "2019-05-06T15:37:37Z",
        "updatedAt" : "2019-05-13T12:55:51Z",
        "lastEditedBy" : "3a56b927-736f-4aab-8690-358cd24ca570",
        "tags" : [
        ]
      }
    ],
    "commit" : "3c3b3db63be69936c391db3a965ebda1aff03391",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +1338,1342 @@      var rhsCtx = ctx.fresh.addMode(Mode.InferringReturnType)\n      if (sym.isInlineMethod) rhsCtx = rhsCtx.addMode(Mode.InlineableBody)\n      if (typeParams.nonEmpty) {\n        // we'll be typing an expression from a polymorphic definition's body,\n        // so we must allow constraining its type parameters"
  },
  {
    "id" : "99410e68-bd92-4451-be8b-222e7631cd89",
    "prId" : 4622,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/4622#pullrequestreview-126248149",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "69986c79-dbce-4931-914b-df64ede0990f",
        "parentId" : null,
        "authorId" : "70ef1594-3bb7-4579-b053-2189b409b5dc",
        "body" : "Not sure if it's worth adding `Transparent` to the exception here, since the handling of return types of transparent methods in `widenRhs` will have to be more different anyways (it should be allowed to infer a TermRef, for instance; think `transparent def unapply(x: Foo) = x`)",
        "createdAt" : "2018-06-05T20:07:02Z",
        "updatedAt" : "2018-06-06T12:14:33Z",
        "lastEditedBy" : "70ef1594-3bb7-4579-b053-2189b409b5dc",
        "tags" : [
        ]
      },
      {
        "id" : "1b5d9828-ebf1-4bcd-a9ab-56105f6286b6",
        "parentId" : "69986c79-dbce-4931-914b-df64ede0990f",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Yes, that was only done as a temporary measure because I could not decide yet whether Java final constants should be called `inline(d)` or `transparent`. Probably `transparent`, but for now it's `inline`.\r\n",
        "createdAt" : "2018-06-06T06:34:23Z",
        "updatedAt" : "2018-06-06T12:14:33Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "b359c7dd2a24ffbfdf4bf85673a9ac789362d83a",
    "line" : 31,
    "diffHunk" : "@@ -1,1 +1114,1118 @@      // println(s\"final inherited for $sym: ${inherited.toString}\") !!!\n      // println(s\"owner = ${sym.owner}, decls = ${sym.owner.info.decls.show}\")\n      def isInline = sym.is(FinalOrInlineOrTransparent, butNot = Method | Mutable)\n\n      // Widen rhs type and eliminate `|' but keep ConstantTypes if"
  },
  {
    "id" : "aa480543-b151-43ce-9a6b-41ca3eb14c36",
    "prId" : 3686,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/3686#pullrequestreview-88666294",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "041bb91e-64cf-472f-956f-e13526d97ab1",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Why is `SecondCompleter` needed here now?",
        "createdAt" : "2018-01-13T20:19:29Z",
        "updatedAt" : "2018-01-15T09:25:08Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      }
    ],
    "commit" : "4d992aebf189f7c785bf1de83cdecdcebf5f5140",
    "line" : 84,
    "diffHunk" : "@@ -1,1 +754,758 @@\n  /** The completer of a symbol defined by a member def or import (except ClassSymbols) */\n  class Completer(val original: Tree)(implicit ctx: Context) extends LazyType with SymbolLoaders.SecondCompleter {\n\n    protected def localContext(owner: Symbol) = ctx.fresh.setOwner(owner).setTree(original)"
  }
]
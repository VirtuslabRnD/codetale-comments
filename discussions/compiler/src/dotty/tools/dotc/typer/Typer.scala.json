[
  {
    "id" : "ba0bf2d7-48d7-48c0-b19f-6997d0c0bd88",
    "prId" : 12506,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/12506#pullrequestreview-674460749",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b2e76757-53c5-428c-95b1-2fa4f64ba4c5",
        "parentId" : null,
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "How is this connected to the rest of the changes? Did the rest trigger a SO here?\r\n",
        "createdAt" : "2021-06-02T16:48:34Z",
        "updatedAt" : "2021-06-02T16:49:03Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "e271e6ae-13a7-4720-b4d6-21da7cbc56d3",
        "parentId" : "b2e76757-53c5-428c-95b1-2fa4f64ba4c5",
        "authorId" : "3a56b927-736f-4aab-8690-358cd24ca570",
        "body" : "Yes, this is the source of the SO that happened after restoring GADT constraints on failed subtype checks.",
        "createdAt" : "2021-06-02T16:56:47Z",
        "updatedAt" : "2021-06-02T16:56:47Z",
        "lastEditedBy" : "3a56b927-736f-4aab-8690-358cd24ca570",
        "tags" : [
        ]
      }
    ],
    "commit" : "cb10bb77b3fefa923342d3439c809f8f524ef765",
    "line" : 8,
    "diffHunk" : "@@ -1,1 +3844,3848 @@          def apply(tp: Type) = tp.dealias match\n            case tp: TypeRef if !tp.symbol.isClass =>\n              if alreadyExpanding contains tp then tp else\n                val saved = alreadyExpanding\n                alreadyExpanding ::= tp"
  },
  {
    "id" : "12961078-ad3f-4e0d-9b23-4c7c37f0b73b",
    "prId" : 11327,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/11327#pullrequestreview-596667154",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6f64f472-50b4-493f-9538-15b49c7fd287",
        "parentId" : null,
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Would it make sense to check this also for other values that are not modules? ",
        "createdAt" : "2021-02-23T18:25:30Z",
        "updatedAt" : "2021-02-23T18:26:10Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "e28bbdbb-5dd2-40ab-b2bb-37f702abe178",
        "parentId" : "6f64f472-50b4-493f-9538-15b49c7fd287",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "We cannot check non-module values due to aliasing.",
        "createdAt" : "2021-02-23T18:28:40Z",
        "updatedAt" : "2021-02-23T18:28:40Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      }
    ],
    "commit" : "b04150c708ddb1f67433e72d67bc768820096094",
    "line" : 19,
    "diffHunk" : "@@ -1,1 +3791,3795 @@        }\n\n        if tree.symbol.is(Module)\n           && !(tree.tpe frozen_<:< pt) // fast track\n           && !(tree.tpe frozen_<:< approx(pt))"
  },
  {
    "id" : "25a54824-4e08-474f-84ec-4d6509c28da9",
    "prId" : 11117,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/11117#pullrequestreview-575317061",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9949edb3-6998-4800-bd3e-cb32b0bb0db5",
        "parentId" : null,
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "Maybe merge this pattern match with the one above, to make the logic more clear.",
        "createdAt" : "2021-01-19T17:39:53Z",
        "updatedAt" : "2021-02-03T15:42:42Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "c341f80c-ecc4-4f2b-a199-cdb20d032a23",
        "parentId" : "9949edb3-6998-4800-bd3e-cb32b0bb0db5",
        "authorId" : "c12e3fb7-fbd4-4f04-9398-94a027d65d53",
        "body" : "I've done it that way because I wanted to avoid repeating `typed(tree.arg, pt)` three times, as it may be a source of errors when the logic would be changed. On the other hand, merging those two patterns is much more readable.",
        "createdAt" : "2021-01-25T11:45:08Z",
        "updatedAt" : "2021-02-03T15:42:42Z",
        "lastEditedBy" : "c12e3fb7-fbd4-4f04-9398-94a027d65d53",
        "tags" : [
        ]
      }
    ],
    "commit" : "e057a3e00b28b3f3f44dc6e21eeef7bd2d34a25a",
    "line" : 21,
    "diffHunk" : "@@ -1,1 +871,875 @@        }\n      case _ => typed(tree.arg, pt)\n    }\n\n    assignType(cpy.NamedArg(tree)(tree.name, arg1), arg1)"
  },
  {
    "id" : "3c6768bc-46dd-4805-b0d1-0fd22b7a2839",
    "prId" : 11037,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/11037#pullrequestreview-569124878",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c6927be9-5d0a-4852-8e90-a72f4afc70e6",
        "parentId" : null,
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "Isn't the result `tree1` already adapted w.r.t. to `pt` in the call `tryExtensionOrConversion`?",
        "createdAt" : "2021-01-14T10:58:54Z",
        "updatedAt" : "2021-01-15T12:29:30Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "68d56646-d31f-4e72-b220-0be401c2b53b",
        "parentId" : "c6927be9-5d0a-4852-8e90-a72f4afc70e6",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "No it isn't. `tryExtensionOrConversion` only does a `typedSelect`, not a full `typed`. `typedSelect` does not adapt.",
        "createdAt" : "2021-01-15T10:08:15Z",
        "updatedAt" : "2021-01-15T12:29:30Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "2dcbb6935ccd3f276b1cde0ca73bf4fe5fe4d033",
    "line" : 145,
    "diffHunk" : "@@ -1,1 +2911,2915 @@            val tree1 = tryExtensionOrConversion(tree, pt, pt, qual, locked, NoViewsAllowed, privateOK = false)\n            if tree1.isEmpty then None\n            else Some(adapt(tree1, pt, locked))\n          } { (_, _) => None\n          }"
  },
  {
    "id" : "ad7062c6-21c7-4920-842e-da141a1f8eac",
    "prId" : 10793,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/10793#pullrequestreview-552332508",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "24015e1f-216a-4cec-bca3-a1514399095b",
        "parentId" : null,
        "authorId" : "6998ebc0-40b8-4e52-b4f8-721fd5d8c0a9",
        "body" : "Did you check whether patching is still necessary here?",
        "createdAt" : "2020-12-15T10:30:00Z",
        "updatedAt" : "2020-12-15T17:19:26Z",
        "lastEditedBy" : "6998ebc0-40b8-4e52-b4f8-721fd5d8c0a9",
        "tags" : [
        ]
      },
      {
        "id" : "050f6ddc-0946-4586-856b-7a5169017df2",
        "parentId" : "24015e1f-216a-4cec-bca3-a1514399095b",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "It's to change the source code to help auto-migrate the code, I think it's still necessary.",
        "createdAt" : "2020-12-15T10:57:02Z",
        "updatedAt" : "2020-12-15T17:19:26Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      }
    ],
    "commit" : "95d394abeada970ad0689c07cd4f1d43b28d34e6",
    "line" : 12,
    "diffHunk" : "@@ -1,1 +1392,1396 @@                val isPatDef = checkMode == desugar.MatchCheck.IrrefutablePatDef\n                if (!checkIrrefutable(sel, pat, isPatDef) && sourceVersion == `3.1-migration`)\n                  if (isPatDef) patch(Span(tree.selector.span.end), \": @unchecked\")\n                  else patch(Span(pat.span.start), \"case \")\n"
  },
  {
    "id" : "6868992e-3ba5-4993-8633-e7425dc87d7e",
    "prId" : 10793,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/10793#pullrequestreview-552334347",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ee17a472-6ba6-49b9-bb17-f50ede9c03e5",
        "parentId" : null,
        "authorId" : "6998ebc0-40b8-4e52-b4f8-721fd5d8c0a9",
        "body" : "I am not sure, but doesn't this skip too many checks?",
        "createdAt" : "2020-12-15T10:40:57Z",
        "updatedAt" : "2020-12-15T17:19:26Z",
        "lastEditedBy" : "6998ebc0-40b8-4e52-b4f8-721fd5d8c0a9",
        "tags" : [
        ]
      },
      {
        "id" : "18063df4-31a8-4524-a5ee-7feb47f2adba",
        "parentId" : "ee17a472-6ba6-49b9-bb17-f50ede9c03e5",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "It's basically the same as before. Previously we add `@unchecked` blindly during desugaring. Due to the syntax change, we cannot do that anymore, thus we add them here.",
        "createdAt" : "2020-12-15T10:59:23Z",
        "updatedAt" : "2020-12-15T17:19:26Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      }
    ],
    "commit" : "95d394abeada970ad0689c07cd4f1d43b28d34e6",
    "line" : 21,
    "diffHunk" : "@@ -1,1 +1401,1405 @@                  selector = tpd.Typed(sel, tpd.TypeTree(uncheckedTpe)),\n                  cases = result.cases\n                )\n              case _ =>\n                result"
  },
  {
    "id" : "38e6f169-a26c-40ef-8cbc-814d2512f5fc",
    "prId" : 9957,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/9957#pullrequestreview-517673476",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a1848862-b04a-41ce-9923-c37fa85cb838",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "In many situation we will recover from an error without ever showing it to the user (e.g., in implicit search we might find another candidate), so it's important to delay computing anything we want to show to the user until we know we need it. Here things are a bit subtle but `missingArgMsg` returns a String and `report.error` takes as input a `Message`, this works because there is an implicit conversion from String to Message: https://github.com/lampepfl/dotty/blob/22c23a5cc648650bb6380dec0c11a5fdc34e1d73/compiler/src/dotty/tools/dotc/reporting/Message.scala#L15\r\nNote that this conversion takes a `=> String` as input and which means the call to `missingArgMsg` will be delayed, which is what we want. But it would be even better if `paramSyms` and `paramSymWithMethodTree` were also delayed, which can be achieved by computing them inside `missingArgMsg` (or making them both lazy vals)",
        "createdAt" : "2020-10-27T13:10:51Z",
        "updatedAt" : "2020-11-04T08:52:36Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      }
    ],
    "commit" : "1760da388e1ab491dc533f326e49dd12aa0e45eb",
    "line" : 28,
    "diffHunk" : "@@ -1,1 +3126,3130 @@            arg.tpe match {\n              case failure: SearchFailureType =>\n                report.error(\n                  missingArgMsg(arg, formal, implicitParamString(paramName, methodStr, tree), paramSymWithMethodTree(paramName)),\n                  tree.srcPos.endPos"
  },
  {
    "id" : "7baf2b51-afd3-4480-9fc4-293280f0520c",
    "prId" : 9870,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/9870#pullrequestreview-496179013",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "642ed3f1-0dc5-46aa-b545-37b919c29473",
        "parentId" : null,
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "I would have thought that the code here would be executed only rarely.",
        "createdAt" : "2020-09-24T17:30:59Z",
        "updatedAt" : "2020-09-25T09:18:57Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "217135b3-9215-434a-872d-3bf9d47944c0",
        "parentId" : "642ed3f1-0dc5-46aa-b545-37b919c29473",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "For a simple program (see below), the speedup is about 24% (34ms/op VS 45ms/op):\r\n\r\n```Scala\r\nclass MyInt(val x: Int) {\r\n  def eq(that: MyInt): Boolean = this.x == that.x\r\n}\r\n\r\nclass Test {\r\n  def foo(x: MyInt, y: MyInt): Boolean = x.eq(y)\r\n\r\n  val a = MyInt(2)\r\n  val b = MyInt(3)\r\n  foo(a, b)\r\n}\r\n```",
        "createdAt" : "2020-09-24T18:08:11Z",
        "updatedAt" : "2020-09-25T09:18:57Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "f82e4daf-d506-4fab-9bb8-fe28150beb48",
        "parentId" : "642ed3f1-0dc5-46aa-b545-37b919c29473",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Interesting. I just found out why: The code in question (including the expensive tryEither) is executed twice, once for each MyInt(...). I had not thought of that. So, yes, because of constructor syntax, failures in findRef are now not that uncommon. So this is a definite improvement. Unfortunately, the benchmarks are too noisy to see this immediately.\r\n",
        "createdAt" : "2020-09-25T07:37:08Z",
        "updatedAt" : "2020-09-25T09:18:57Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "db92078bc77e6b33c9b648a5dc8ad84ab5d5929c",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +504,508 @@      // `p` is the closest enclosing extension parameter, or else convert to `this.f`.\n      val xmethod = ctx.owner.enclosingExtensionMethod\n      if xmethod.exists then\n        val qualifier = untpd.ref(xmethod.extensionParam.termRef)\n        val selection = untpd.cpy.Select(tree)(qualifier, name)"
  },
  {
    "id" : "b327ecc1-18b9-44e2-82f7-1641ad4e342e",
    "prId" : 9753,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/9753#pullrequestreview-485634688",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "08c5727d-4ab6-403d-b8e2-91f397af9747",
        "parentId" : null,
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "`tree.isInstanceOf[Inlined]` : can an inlined tree be pure? What about handle inlined trees in `isPureExpr`?",
        "createdAt" : "2020-09-10T06:09:37Z",
        "updatedAt" : "2020-09-10T06:13:09Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "edaa456a-8072-4455-ae72-0b351f33fd0c",
        "parentId" : "08c5727d-4ab6-403d-b8e2-91f397af9747",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "The Inlined trees can be pure which is correctly identified in isPureExpr. Here we special case a\r\nInlined calls that inserted a pure expression in a statement position as these are only pure due to other constraints that may change. For example, the assert can take a reference to an Inlined true value which converts it in a no-op and we do not want to warn that this is a pure expression in statement position.",
        "createdAt" : "2020-09-10T06:36:11Z",
        "updatedAt" : "2020-09-10T06:39:11Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      },
      {
        "id" : "dbe950a7-c277-409f-bbba-ce9368ac64cd",
        "parentId" : "08c5727d-4ab6-403d-b8e2-91f397af9747",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "Thanks for the explanation. It might be good to add a short comment after the line.",
        "createdAt" : "2020-09-10T07:00:31Z",
        "updatedAt" : "2020-09-10T07:00:31Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      }
    ],
    "commit" : "c15936185c153781a0e055f5c6201075b6b84c14",
    "line" : 10,
    "diffHunk" : "@@ -1,1 +3634,3638 @@      && !tree.isInstanceOf[Inlined]\n      && isPureExpr(tree)\n      && !isSelfOrSuperConstrCall(tree)\n    then\n      report.warning(PureExpressionInStatementPosition(original, exprOwner), original.srcPos)"
  },
  {
    "id" : "3907c814-9fff-4317-b16a-d2f9d53ccc5e",
    "prId" : 9598,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/9598#pullrequestreview-471448257",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b0a32abe-8e3e-42d8-9d6f-13b5e27485a0",
        "parentId" : null,
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "Will `termName.endsWith(name.lastPart)` be always true, given that `termName = name.toTermName`?",
        "createdAt" : "2020-08-20T10:07:25Z",
        "updatedAt" : "2020-08-20T10:53:54Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      }
    ],
    "commit" : "7e45458159f540e41396f7e637ea0bfd52eb25bd",
    "line" : 8,
    "diffHunk" : "@@ -1,1 +218,222 @@        def adjustExtension(n: Name) =\n          if required.is(ExtensionMethod) && termName.endsWith(n.lastPart)\n               // pre-check to avoid forming a new string; form extension only if it has a chance of matching `termName`\n          then n.toExtensionName\n          else n"
  },
  {
    "id" : "c44af050-80f1-48ab-8007-b5958dbae0d1",
    "prId" : 9581,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/9581#pullrequestreview-472306835",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "936559b9-f32d-43f2-b832-2d8294075281",
        "parentId" : null,
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "Do we need this for `3.0-migration`?",
        "createdAt" : "2020-08-21T06:46:16Z",
        "updatedAt" : "2020-08-21T06:49:02Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      },
      {
        "id" : "1ba4242a-2a7f-407f-9b06-09dbc20452f6",
        "parentId" : "936559b9-f32d-43f2-b832-2d8294075281",
        "authorId" : "ae8a350c-513d-4e26-b751-b1b65838ca0b",
        "body" : "I think we dont. According to the [Dotty documentation](https://dotty.epfl.ch/docs/reference/changed-features/pattern-bindings.html), the type checking rules of pattern bindings will change in Dotty 3.1, not Dotty 3.0.\r\n\r\nThe following code compiles and runs successfully in 0.26-M1\r\n\r\n```scala\r\nval list: List[Int] = List(1)\r\nval head :: _ = list\r\n\r\nval listOpt: List[Option[Int]] = List(Some(1), None)\r\nfor (Some(value) <- listOpt)\r\n  println(value)\r\n```\r\n\r\n",
        "createdAt" : "2020-08-21T08:35:41Z",
        "updatedAt" : "2020-08-21T08:35:41Z",
        "lastEditedBy" : "ae8a350c-513d-4e26-b751-b1b65838ca0b",
        "tags" : [
        ]
      }
    ],
    "commit" : "eee0863c6536f662229a7dba1dad5a139cf47bfc",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +1365,1369 @@              case Some(checkMode) =>\n                val isPatDef = checkMode == desugar.MatchCheck.IrrefutablePatDef\n                if (!checkIrrefutable(pat, sel.tpe, isPatDef) && sourceVersion == `3.1-migration`)\n                  if (isPatDef) patch(Span(pat.span.end), \": @unchecked\")\n                  else patch(Span(pat.span.start), \"case \")"
  },
  {
    "id" : "1b66f3e9-1381-49f5-8ce4-eaa9fafeb02a",
    "prId" : 9303,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/9303#pullrequestreview-443576247",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "72244ae3-d29f-4717-b37b-8e32ac71017a",
        "parentId" : null,
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "This map can be done before the `toList`",
        "createdAt" : "2020-07-06T19:18:53Z",
        "updatedAt" : "2020-07-06T19:22:38Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      },
      {
        "id" : "5aaa0a7c-0afa-4e3c-924f-d52479ec1a7f",
        "parentId" : "72244ae3-d29f-4717-b37b-8e32ac71017a",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Yes, but that's not necessarily better, or is it? We are talking of iterators of length 1 - 2 on average",
        "createdAt" : "2020-07-06T20:08:23Z",
        "updatedAt" : "2020-07-06T20:08:23Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "1110eff4-0793-4c8c-8089-b422aa6102fc",
        "parentId" : "72244ae3-d29f-4717-b37b-8e32ac71017a",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "Then the extra allocation should be fine.",
        "createdAt" : "2020-07-07T05:42:04Z",
        "updatedAt" : "2020-07-07T05:42:04Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      }
    ],
    "commit" : "3d4260671de82920dde21eaaf86cd9eb880316fb",
    "line" : 97,
    "diffHunk" : "@@ -1,1 +1477,1481 @@          .toList\n          .reverse\n          .map(_.paramSymss.head)\n        instantiateCFT(rt, iftParamss)\n"
  },
  {
    "id" : "3aa5d122-c943-4d67-8234-3c21a58a9eae",
    "prId" : 9098,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/9098#pullrequestreview-425307401",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "887de25b-067f-4df5-8d05-ccd32f7548d9",
        "parentId" : null,
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "This .withSpan(call.span) should probably be around the tpd.Block",
        "createdAt" : "2020-06-03T15:20:19Z",
        "updatedAt" : "2020-06-05T13:35:48Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      },
      {
        "id" : "3cf5b22d-5b24-43f4-889f-26ea2133b521",
        "parentId" : "887de25b-067f-4df5-8d05-ccd32f7548d9",
        "authorId" : "128563de-a925-4397-af34-450c7978a8d2",
        "body" : "perhaps I overdid it?,",
        "createdAt" : "2020-06-03T15:42:12Z",
        "updatedAt" : "2020-06-05T13:35:48Z",
        "lastEditedBy" : "128563de-a925-4397-af34-450c7978a8d2",
        "tags" : [
        ]
      },
      {
        "id" : "52d9cb4b-ea4f-4423-8d7a-9204a87b10b8",
        "parentId" : "887de25b-067f-4df5-8d05-ccd32f7548d9",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "I removed some of them. Could you check it works with your example?",
        "createdAt" : "2020-06-05T13:02:18Z",
        "updatedAt" : "2020-06-05T13:35:48Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      },
      {
        "id" : "d8006748-e192-4b02-9332-2430793d7e09",
        "parentId" : "887de25b-067f-4df5-8d05-ccd32f7548d9",
        "authorId" : "128563de-a925-4397-af34-450c7978a8d2",
        "body" : "I'm not sure whats happening because the CI is passing but `testCompilation tests/pos/i8945.scala` fails for me",
        "createdAt" : "2020-06-05T13:20:23Z",
        "updatedAt" : "2020-06-05T13:35:48Z",
        "lastEditedBy" : "128563de-a925-4397-af34-450c7978a8d2",
        "tags" : [
        ]
      },
      {
        "id" : "190118f2-e749-4b4f-8a6a-0630faf7efc1",
        "parentId" : "887de25b-067f-4df5-8d05-ccd32f7548d9",
        "authorId" : "128563de-a925-4397-af34-450c7978a8d2",
        "body" : "wait CI is still running",
        "createdAt" : "2020-06-05T13:22:29Z",
        "updatedAt" : "2020-06-05T13:35:48Z",
        "lastEditedBy" : "128563de-a925-4397-af34-450c7978a8d2",
        "tags" : [
        ]
      },
      {
        "id" : "adac9c56-0b01-4648-be52-9f8abeb9d0a8",
        "parentId" : "887de25b-067f-4df5-8d05-ccd32f7548d9",
        "authorId" : "128563de-a925-4397-af34-450c7978a8d2",
        "body" : "`.withSpan` still needs to be added to `bundleVal` - I'll do it",
        "createdAt" : "2020-06-05T13:24:04Z",
        "updatedAt" : "2020-06-05T13:35:48Z",
        "lastEditedBy" : "128563de-a925-4397-af34-450c7978a8d2",
        "tags" : [
        ]
      },
      {
        "id" : "76ca9727-b96f-49d6-bf1c-88cbeb0d08d1",
        "parentId" : "887de25b-067f-4df5-8d05-ccd32f7548d9",
        "authorId" : "128563de-a925-4397-af34-450c7978a8d2",
        "body" : "@nicolasstucki the commit I just added also works with my scala 2 testing bd066e161c72c13f616c095b2014ef23e342587b",
        "createdAt" : "2020-06-05T13:39:48Z",
        "updatedAt" : "2020-06-05T13:40:07Z",
        "lastEditedBy" : "128563de-a925-4397-af34-450c7978a8d2",
        "tags" : [
        ]
      }
    ],
    "commit" : "bd066e161c72c13f616c095b2014ef23e342587b",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +3574,3578 @@          case Ident(name) => untpd.Ident(name.toTypeName).withSpan(tree.span)\n          case Select(qual, name) => untpd.Select(qual, name.toTypeName).withSpan(tree.span)\n        val bundle = untpd.Apply(untpd.Select(untpd.New(ref), nme.CONSTRUCTOR), untpd.Literal(Constant(null))).withSpan(call.span)\n        val bundle1 = typedExpr(bundle, defn.AnyType)\n        val bundleVal = SyntheticValDef(NameKinds.UniqueName.fresh(nme.bundle), bundle1).withSpan(call.span)"
  },
  {
    "id" : "3b221f89-c432-4a5a-b3ee-f22fcfda256c",
    "prId" : 8669,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/8669#pullrequestreview-392322435",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8b6b582f-71d5-4171-a3f5-0595cbe550b0",
        "parentId" : null,
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "nice!",
        "createdAt" : "2020-04-13T18:13:22Z",
        "updatedAt" : "2020-04-13T19:56:29Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "03d5d9b93274dfe66b454c840e7317e81380b240",
    "line" : 28,
    "diffHunk" : "@@ -1,1 +741,745 @@        val fromCls = if expr1.tpe.derivesFrom(defn.ArrayClass) then defn.ArrayClass else defn.SeqClass\n        val tpt1 = TypeTree(expr1.tpe.widen.translateToRepeated(fromCls)).withSpan(tree.tpt.span)\n        assignType(cpy.Typed(tree)(expr1, tpt1), tpt1)\n      }\n      cases("
  },
  {
    "id" : "e929c5e4-54a5-47b4-8e92-55c1d0206518",
    "prId" : 8413,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/8413#pullrequestreview-367118936",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "aa9e5ea7-6911-4b6a-9d00-99b81c53488e",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "There's an open issue related to this that could be linked here: https://github.com/lampepfl/dotty/issues/5469",
        "createdAt" : "2020-03-01T18:09:03Z",
        "updatedAt" : "2020-03-01T18:41:22Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "24adf7d0-19ff-4bce-8ff3-05d63d44525c",
        "parentId" : "aa9e5ea7-6911-4b6a-9d00-99b81c53488e",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "I added a link",
        "createdAt" : "2020-03-02T11:11:28Z",
        "updatedAt" : "2020-03-02T11:11:28Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "526670dac45be96fc8fb5aec503fb9d88f10e58c",
    "line" : 16,
    "diffHunk" : "@@ -1,1 +1584,1588 @@                                         // where T is GADT constrained to := Float. But the case body\n                                         // compiles only if the bound variable is Array[Float]. If\n                                         // it is Array[T] we get an implicit not found. To avoid fragility\n                                         // wrt to operand order for `&`, we include the explicit subtype test here.\n                                         // See also #5649."
  },
  {
    "id" : "a4306615-c8a2-4ae7-af23-f92b81ce780f",
    "prId" : 8413,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/8413#pullrequestreview-367118333",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c6efa850-bb78-4692-b01f-35b64b89bac3",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Do we need to check that `pt1.isValueType` to exclude potential ProtoTypes ?",
        "createdAt" : "2020-03-01T22:16:20Z",
        "updatedAt" : "2020-03-01T22:16:31Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "0db22a8b-1f83-473d-99c7-e3bb8cd07b98",
        "parentId" : "c6efa850-bb78-4692-b01f-35b64b89bac3",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "No, for pattern matching it is assured that `pt` is a value type.\r\n",
        "createdAt" : "2020-03-02T11:10:28Z",
        "updatedAt" : "2020-03-02T11:10:28Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "526670dac45be96fc8fb5aec503fb9d88f10e58c",
    "line" : 20,
    "diffHunk" : "@@ -1,1 +1588,1592 @@                                         // See also #5649.\n            then body1.tpe\n            else pt1 & body1.tpe\n          val sym = ctx.newPatternBoundSymbol(name, symTp, tree.span)\n          if (pt == defn.ImplicitScrutineeTypeRef || tree.mods.is(Given)) sym.setFlag(Given)"
  },
  {
    "id" : "8524aa9a-7a2f-44fa-99c8-87d0a78936ad",
    "prId" : 8024,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/8024#pullrequestreview-347459115",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "433b4096-9a77-4a59-81f8-5af75f3108ee",
        "parentId" : null,
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "This is interesting. Are there opportunities to use this extractor elsewhere?",
        "createdAt" : "2020-01-20T10:43:51Z",
        "updatedAt" : "2020-04-09T15:00:57Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "a7348ea8-68b3-47ad-b67b-ef6203cdae20",
        "parentId" : "433b4096-9a77-4a59-81f8-5af75f3108ee",
        "authorId" : "6d71bb21-e402-4464-b2b1-8bdd8e068461",
        "body" : "I haven't found any, is it ok to leave it nested in here until we found another use of it?",
        "createdAt" : "2020-01-23T16:59:29Z",
        "updatedAt" : "2020-04-09T15:00:57Z",
        "lastEditedBy" : "6d71bb21-e402-4464-b2b1-8bdd8e068461",
        "tags" : [
        ]
      }
    ],
    "commit" : "60cfa2dc34016cd0b11f432d7add5b96cf532cbe",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +1237,1241 @@\n        /** Extractor for match types hidden behind an AppliedType/MatchAlias */\n        object MatchTypeInDisguise {\n          def unapply(tp: AppliedType): Option[MatchType] = tp match {\n            case AppliedType(tycon: TypeRef, args) =>"
  },
  {
    "id" : "03f5c779-e550-4b35-8fa6-bbf3ce14bc32",
    "prId" : 6955,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/6955#pullrequestreview-268849309",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "55fc1fda-3e95-48ce-997b-b126557fb3ab",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Any reason we couldn't also do `readaptSimplified(tree.withType(alt))` here ?",
        "createdAt" : "2019-07-30T18:45:57Z",
        "updatedAt" : "2019-07-31T08:12:23Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "bb59c356-e407-4091-995c-e6b2ab643153",
        "parentId" : "55fc1fda-3e95-48ce-997b-b126557fb3ab",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "We add a `()` argument here, so the term changes.\r\n",
        "createdAt" : "2019-07-31T08:14:03Z",
        "updatedAt" : "2019-07-31T08:14:20Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "311b72614b1afc58e95b75f157ed576018f7e80c",
    "line" : 26,
    "diffHunk" : "@@ -1,1 +2438,2442 @@                case _ =>\n                  if (altDenots exists (_.info.paramInfoss == ListOfNil))\n                    typed(untpd.Apply(untpd.TypedSplice(tree), Nil), pt, locked)\n                  else\n                    noMatches"
  },
  {
    "id" : "fb1197b2-08bb-426e-85be-96ed3853b287",
    "prId" : 6919,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/6919#pullrequestreview-268493249",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0c7e2e11-f71d-45af-81c4-9eb419a33e98",
        "parentId" : null,
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "Where did this `Mode.Pattern` come from? \r\nWas it from the pattern of something like?\r\n```\r\nbigFloat match {\r\n  case 123_344_537_244_453E433 => ???\r\n}\r\n```",
        "createdAt" : "2019-07-29T09:21:29Z",
        "updatedAt" : "2019-08-30T10:13:04Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      },
      {
        "id" : "a2243b02-ff82-4465-8df8-cbff968e8bec",
        "parentId" : "0c7e2e11-f71d-45af-81c4-9eb419a33e98",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Yes, exacty. We might make it user-accessible syntax though.\r\n\r\n",
        "createdAt" : "2019-07-30T15:49:45Z",
        "updatedAt" : "2019-08-30T10:13:04Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "e0f2ea0be1419cc6f779acce53e99e5e1427c67e",
    "line" : 84,
    "diffHunk" : "@@ -1,1 +767,771 @@\n  def typedBlock(tree: untpd.Block, pt: Type)(implicit ctx: Context): Tree = {\n    val localCtx = ctx.retractMode(Mode.Pattern)\n    val (exprCtx, stats1) = typedBlockStats(tree.stats) given localCtx\n    val expr1 = typedExpr(tree.expr, pt.dropIfProto)(exprCtx)"
  },
  {
    "id" : "46c5d3dc-0c5b-4074-b8ff-703b652b95dd",
    "prId" : 6788,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/6788#pullrequestreview-256953960",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "03d1a617-e66f-4059-addb-e93fd69044cb",
        "parentId" : null,
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "What if the following code?\r\n\r\n```Scala\r\ninline def foo() = {\r\n  class A {\r\n    def bar = $(...)\r\n  }\r\n}\r\n```",
        "createdAt" : "2019-07-02T14:43:58Z",
        "updatedAt" : "2019-07-02T14:59:36Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "96fc800f-a1fa-4d11-884e-ab69ef5904bc",
        "parentId" : "03d1a617-e66f-4059-addb-e93fd69044cb",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "It will fall back to error message of the macro body checking .",
        "createdAt" : "2019-07-02T14:56:25Z",
        "updatedAt" : "2019-07-02T14:59:36Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      },
      {
        "id" : "1bc4bbf1-3db7-4e6a-ad7a-78477d410587",
        "parentId" : "03d1a617-e66f-4059-addb-e93fd69044cb",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "Those checks are performed by the `Splicer`",
        "createdAt" : "2019-07-02T15:00:16Z",
        "updatedAt" : "2019-07-02T15:00:16Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      }
    ],
    "commit" : "4f87b5aa821450a72a0a21aa2239f0e6324bbd4b",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +2083,2087 @@\n  private def checkSpliceOutsideQuote(tree: untpd.Tree)(implicit ctx: Context): Unit = {\n    if (level == 0 && !ctx.owner.ownersIterator.exists(_.is(Inline)))\n      ctx.error(\"Splice ${...} outside quotes '{...} or inline method\", tree.sourcePos)\n    else if (level < 0)"
  },
  {
    "id" : "dfc7527e-faea-44f2-9d80-e90e8d1bdfab",
    "prId" : 6746,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/6746#pullrequestreview-254638472",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "31852e50-72f9-4ae0-bfce-2fc6d7504457",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "The following alternative check passes all tests too:\r\n```suggestion\r\n                    if (curOwner.isConstructor)\r\n```\r\nThis looks more obviously correct to me, wdyt @odersky ?",
        "createdAt" : "2019-06-25T21:52:34Z",
        "updatedAt" : "2019-06-25T21:52:34Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "06e6e717-9bc5-43d5-8ee8-bf038cb4ff8e",
        "parentId" : "31852e50-72f9-4ae0-bfce-2fc6d7504457",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "No, I think `curOwner` could also be `localDummy`. `maybeOwner.isType` looks correct.",
        "createdAt" : "2019-06-26T14:07:17Z",
        "updatedAt" : "2019-06-26T14:07:37Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "e3286bb8717370c9a9a2d4ba1278dc3ead44aa36",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +301,305 @@                else {\n                  val effectiveOwner =\n                    if (curOwner.isTerm && defDenot.symbol.maybeOwner.isType)\n                      // Don't mix NoPrefix and thisType prefixes, since type comparer\n                      // would not detect types to be compatible."
  },
  {
    "id" : "b6be99c7-6a43-4a55-bae2-1620dfd449cf",
    "prId" : 6504,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/6504#pullrequestreview-256235166",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1fafe429-7055-47a8-b6fc-c04b3f5de083",
        "parentId" : null,
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Add a description of the scheme for translating patterns to doc comment above\r\n\r\n",
        "createdAt" : "2019-06-26T16:57:02Z",
        "updatedAt" : "2019-07-02T12:03:53Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "c918aef1-9b93-4384-b6c3-530046150f9a",
        "parentId" : "1fafe429-7055-47a8-b6fc-c04b3f5de083",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "Added",
        "createdAt" : "2019-07-01T09:47:28Z",
        "updatedAt" : "2019-07-02T12:03:53Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      }
    ],
    "commit" : "732033fea3e4e0248395c070156a73022d9654a0",
    "line" : 239,
    "diffHunk" : "@@ -1,1 +2190,2194 @@  }\n\n  /** Translate `${ t: Expr[T] }` into expression `t.splice` while tracking the quotation level in the context */\n  def typedSplice(tree: untpd.Splice, pt: Type)(implicit ctx: Context): Tree = track(\"typedSplice\") {\n    checkSpliceOutsideQuote(tree)"
  },
  {
    "id" : "0c24a721-99d4-47a9-97d7-9f10c0bbd93f",
    "prId" : 6254,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/6254#pullrequestreview-225065301",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a666f1e8-20cd-4062-b18a-07876c4c3cad",
        "parentId" : null,
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "The change here and above looks dubious to me. @odersky could you have a look?",
        "createdAt" : "2019-04-08T16:14:18Z",
        "updatedAt" : "2019-04-10T15:51:58Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "7fdad444-e13c-4f9d-ac40-dbb0d729d4c8",
        "parentId" : "a666f1e8-20cd-4062-b18a-07876c4c3cad",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "I am not sure a global substitution is the right thing here. I fear it would also affect nested varargs methods that would then become Seq methods. I'd do instead:\r\n```scala\r\nval patType = pat.tpe.widen\r\nval patType1 = patType.underlyingIfRepeated(isJava = false)\r\nval pat1 = if (patType eq patType1) pat else pat.withType(patType1)\r\n```\r\n",
        "createdAt" : "2019-04-10T10:26:25Z",
        "updatedAt" : "2019-04-10T15:51:58Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "a402f9a9-4176-4fd1-9c7e-e72905494edf",
        "parentId" : "a666f1e8-20cd-4062-b18a-07876c4c3cad",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "I use this code now and also updated another place that had the `subst` to use `underlyingIfRepeated`.",
        "createdAt" : "2019-04-10T15:55:43Z",
        "updatedAt" : "2019-04-10T15:55:43Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      }
    ],
    "commit" : "6af611be522d3fe39409a0de286e5dde3c03a037",
    "line" : 28,
    "diffHunk" : "@@ -1,1 +1974,1978 @@            val pat1 = if (patType eq patType1) pat else pat.withType(patType1)\n            patBuf += pat1\n          }\n        case _ =>\n          super.transform(tree)"
  },
  {
    "id" : "c11111ce-5725-46d6-a85f-c671a0e4ab0c",
    "prId" : 6179,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/6179#pullrequestreview-222656127",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0bf85684-bd13-472f-80ca-cd42aab8a18b",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Add some documentation explaining what this branch does exactly and what the assumptions are.",
        "createdAt" : "2019-04-03T15:48:36Z",
        "updatedAt" : "2019-04-04T09:39:09Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "647f8c5b-92ba-4c76-92b1-0afcaf1e9dc6",
        "parentId" : "0bf85684-bd13-472f-80ca-cd42aab8a18b",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "Added comments",
        "createdAt" : "2019-04-04T09:39:59Z",
        "updatedAt" : "2019-04-04T09:40:21Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      }
    ],
    "commit" : "89412a06ec6ab705fec634da927f8c4de1808d1b",
    "line" : 8,
    "diffHunk" : "@@ -1,1 +2758,2762 @@          ctx.warning(\"Scala 2 macro cannot be used in Dotty, this call will crash at runtime. See http://dotty.epfl.ch/docs/reference/dropped-features/macros.html\", tree.sourcePos)\n          tree\n        } else if (tree.symbol eq defn.StringContext_f) {\n          // As scala.StringContext.f is defined in the standard library which\n          // we currently do not bootstrap we cannot implement the macro the library."
  },
  {
    "id" : "bf85923b-0007-469e-84cd-d8fd97145f4c",
    "prId" : 6084,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/6084#pullrequestreview-219480543",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2eb35267-6850-45d2-a5e9-a3da54bbfb4e",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Add a comment explaining that NamedArg don't count since they cannot be used in new expressions.",
        "createdAt" : "2019-03-27T17:11:21Z",
        "updatedAt" : "2019-03-28T07:43:09Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      }
    ],
    "commit" : "52f2e63dd8ac10dbe36289bedb74d1530e725019",
    "line" : 88,
    "diffHunk" : "@@ -1,1 +2249,2253 @@        else {\n          def recur(tpt: Tree, pt: Type): Tree = pt.revealIgnored match {\n            case PolyProto(targs, pt1) if !targs.exists(_.isInstanceOf[NamedArg]) =>\n              // Applications with named arguments cannot be converted, since new expressions\n              // don't accept named arguments"
  },
  {
    "id" : "239d3200-9ebb-457f-a93e-ee6bba8f5f84",
    "prId" : 6084,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/6084#pullrequestreview-219480543",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b74f4ae2-403b-496f-8bb7-df2cad8ce991",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "I'm a little unclear on why we need to `tryNew` in two places, could this be explained somewhere ?",
        "createdAt" : "2019-03-27T17:13:00Z",
        "updatedAt" : "2019-03-28T07:43:09Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      }
    ],
    "commit" : "52f2e63dd8ac10dbe36289bedb74d1530e725019",
    "line" : 130,
    "diffHunk" : "@@ -1,1 +2324,2328 @@    def tryImplicit(fallBack: => Tree) =\n      tryInsertImplicitOnQualifier(tree, pt.withContext(ctx), locked)\n        .getOrElse(tryNew(tpd)(tree, pt, fallBack))\n\n    if (ctx.mode.is(Mode.SynthesizeExtMethodReceiver))"
  },
  {
    "id" : "6440cc55-4bce-43b0-85e6-7f557daaefd9",
    "prId" : 5957,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/5957#pullrequestreview-207109954",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c50e75b5-c9f5-4265-912b-e7bed6692893",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "I'm not 100% clear on the notion of \"top-level occurence\" here, why is in an occurence in a branch of an AndOrType top-level, but not in the widened type of an `ExprType` for example ?",
        "createdAt" : "2019-02-23T11:50:52Z",
        "updatedAt" : "2019-02-23T13:42:32Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "2bc132bb-4fed-4440-a4cd-944c21a5edaf",
        "parentId" : "c50e75b5-c9f5-4265-912b-e7bed6692893",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "It's because we have already widened the type before we pass it to `captureWildcards`.",
        "createdAt" : "2019-02-23T13:34:45Z",
        "updatedAt" : "2019-02-23T13:42:32Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "d4306dd3ca6c963497b31c342695cfb5d9138557",
    "line" : 30,
    "diffHunk" : "@@ -1,1 +2699,2703 @@    }\n\n    /** Replace every top-level occurrence of a wildcard type argument by\n     *  a fresh skolem type. The skolem types are of the form $i.CAP, where\n     *  $i is a skolem of type `scala.internal.TypeBox`, and `CAP` is its"
  },
  {
    "id" : "6d36f726-bdb8-4884-b883-007b3265db88",
    "prId" : 5896,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/5896#pullrequestreview-202526485",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3d19356d-2bb7-478d-96ee-76d53fcfd638",
        "parentId" : null,
        "authorId" : "223e67d6-1873-432a-9af9-f40b82a7eedd",
        "body" : "Should we move this check into the `SAMType` extractor?",
        "createdAt" : "2019-02-11T20:00:37Z",
        "updatedAt" : "2019-02-11T20:05:51Z",
        "lastEditedBy" : "223e67d6-1873-432a-9af9-f40b82a7eedd",
        "tags" : [
        ]
      },
      {
        "id" : "a0b271ce-a8a9-40d5-9cfd-03394a834e2b",
        "parentId" : "3d19356d-2bb7-478d-96ee-76d53fcfd638",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "No I think it's better here. An extractor is for extracting, not reporting errors.",
        "createdAt" : "2019-02-11T22:17:03Z",
        "updatedAt" : "2019-02-11T22:17:03Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "3fc82a92-e0ca-4970-b900-6b03cafef8f9",
        "parentId" : "3d19356d-2bb7-478d-96ee-76d53fcfd638",
        "authorId" : "223e67d6-1873-432a-9af9-f40b82a7eedd",
        "body" : "I didn't mean to report an error in the extractor, just have the extractor return `None` on `sealed` and `final` classes. It seemed arbitrary to have a special error message for this. In `scalac` I get a type mismatch instead.:\r\n```scala\r\nscala> sealed trait Foo { def f(x: Int): Int }; val foo: Foo = (x: Int) => x\r\n<console>:11: error: type mismatch;\r\n found   : Int => Int\r\n required: Foo\r\n       sealed trait Foo { def f(x: Int): Int }; val foo: Foo = (x: Int) => x\r\n```",
        "createdAt" : "2019-02-12T08:07:05Z",
        "updatedAt" : "2019-02-12T08:07:13Z",
        "lastEditedBy" : "223e67d6-1873-432a-9af9-f40b82a7eedd",
        "tags" : [
        ]
      }
    ],
    "commit" : "66532955a172313b18900ae2257db8ae7ff6e243",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +987,991 @@                if (!isFullyDefined(pt, ForceDegree.all))\n                  ctx.error(ex\"result type of lambda is an underspecified SAM type $pt\", tree.sourcePos)\n                else if (pt.classSymbol.is(FinalOrSealed)) {\n                  val offendingFlag = pt.classSymbol.flags & FinalOrSealed\n                  ctx.error(ex\"lambda cannot implement $offendingFlag ${pt.classSymbol}\", tree.sourcePos)"
  },
  {
    "id" : "fca98b6a-d07c-4c86-a52b-9a80ccda530d",
    "prId" : 5707,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/5707#pullrequestreview-192581786",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "81214f9a-0b73-41ee-bbc3-4614678c40d0",
        "parentId" : null,
        "authorId" : "37519144-0f9f-4b2b-85f7-34dde9be2e11",
        "body" : "In this condition, I removed all but the second and the test still passes. I also checked `isSimplyPure` which is stronger, instead of `isPureExpr`, and still passes. \r\n\r\n",
        "createdAt" : "2019-01-15T09:36:41Z",
        "updatedAt" : "2019-01-15T10:19:42Z",
        "lastEditedBy" : "37519144-0f9f-4b2b-85f7-34dde9be2e11",
        "tags" : [
        ]
      },
      {
        "id" : "eb4a432d-c68a-403f-84f3-ccdcc0cf33a5",
        "parentId" : "81214f9a-0b73-41ee-bbc3-4614678c40d0",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "Why only restrict warnings to SimplyPure if we can emit the warning for Pure as well?",
        "createdAt" : "2019-01-15T10:07:45Z",
        "updatedAt" : "2019-01-15T10:19:42Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      },
      {
        "id" : "97593640-af31-45b7-a4bf-2469aaea0e7a",
        "parentId" : "81214f9a-0b73-41ee-bbc3-4614678c40d0",
        "authorId" : "37519144-0f9f-4b2b-85f7-34dde9be2e11",
        "body" : "Ah yes, I agree. I just wanted to point out that there was a test case missing ;-)\r\nI merge when CI ends.",
        "createdAt" : "2019-01-15T10:42:53Z",
        "updatedAt" : "2019-01-15T10:43:13Z",
        "lastEditedBy" : "37519144-0f9f-4b2b-85f7-34dde9be2e11",
        "tags" : [
        ]
      }
    ],
    "commit" : "c29a53174374f9d1476bdfb9b8fa724f07c99e87",
    "line" : 33,
    "diffHunk" : "@@ -1,1 +2774,2778 @@\n  private def checkStatementPurity(tree: tpd.Tree)(original: untpd.Tree, exprOwner: Symbol)(implicit ctx: Context): Unit = {\n    if (!ctx.isAfterTyper && isPureExpr(tree) && !tree.tpe.isRef(defn.UnitClass) && !isSelfOrSuperConstrCall(tree))\n      ctx.warning(PureExpressionInStatementPosition(original, exprOwner), original.pos)\n  }"
  },
  {
    "id" : "97207130-ad58-4e00-afbc-ff138a130a74",
    "prId" : 5601,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/5601#pullrequestreview-184170532",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2748d117-9ed4-4929-afe1-4ba4d3ec85f7",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "I don't think `arg.tpe.exists` can occur here unlike `addTyped`, but we should check `arg.tpe.isError` since in case of implicit failure, the type will be an instance of `SearchFailureType` which is a subtype of `ErrorType`:\r\n```suggestion\r\n                  if (wtp.isParamDependent && !arg.tpe.isError)\r\n```\r\nI also suggest adding some negative test cases that exercises this code path.",
        "createdAt" : "2018-12-12T12:57:37Z",
        "updatedAt" : "2018-12-12T13:41:56Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "b4716fae-6df6-4c89-af6d-268a515b69a5",
        "parentId" : "2748d117-9ed4-4929-afe1-4ba4d3ec85f7",
        "authorId" : "2c02aea2-3019-42f4-9678-8a2da637c660",
        "body" : "We do need `exists` here. Switching to `!arg.tpe.isError` results in an assertion for a non-existent getter denotation.\r\n\r\nI'll add some negative test cases.",
        "createdAt" : "2018-12-12T13:15:39Z",
        "updatedAt" : "2018-12-12T13:41:56Z",
        "lastEditedBy" : "2c02aea2-3019-42f4-9678-8a2da637c660",
        "tags" : [
        ]
      }
    ],
    "commit" : "ccba10ca28814c0313602561bfe167c4ea73764f",
    "line" : 18,
    "diffHunk" : "@@ -1,1 +2366,2370 @@                // done for non-implicit parameter lists in Applications#matchArgs#addTyped.\n                val formals2 =\n                  if (wtp.isParamDependent && arg.tpe.exists)\n                    formals1.mapconserve(f1 => safeSubstParam(f1, wtp.paramRefs(argIndex), arg.tpe))\n                  else formals1"
  },
  {
    "id" : "8bc9da9e-2270-4d04-94c7-29a068ee4faf",
    "prId" : 5341,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/5341#pullrequestreview-170371144",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e0717948-da4d-41c0-974e-d2cb58e385b3",
        "parentId" : null,
        "authorId" : "e625ae4c-fba4-4c8f-9728-a669f65f1bcb",
        "body" : "Is this expected?",
        "createdAt" : "2018-10-30T16:36:15Z",
        "updatedAt" : "2018-11-01T05:38:10Z",
        "lastEditedBy" : "e625ae4c-fba4-4c8f-9728-a669f65f1bcb",
        "tags" : [
        ]
      },
      {
        "id" : "b133c56f-fb6a-4e3b-836c-e0f7b1c6d948",
        "parentId" : "e0717948-da4d-41c0-974e-d2cb58e385b3",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Yes. `isOverloaded` is a property of a denotation, not a symbol. A symbol's denotation always describes a specific definition of a symbol, so is never overloaded.",
        "createdAt" : "2018-10-31T17:10:26Z",
        "updatedAt" : "2018-11-01T05:38:10Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "be977d9a86ef730af9e14c11a8d25ec383662754",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +1237,1241 @@        ctx.error(PolymorphicMethodMissingTypeInParent(rsym, tpt1.symbol), refinement.pos)\n\n      val member = refineCls.info.member(rsym.name)\n      if (member.isOverloaded) {\n        ctx.error(OverloadInRefinement(rsym), refinement.pos)"
  },
  {
    "id" : "9ade9f57-5b06-4e8f-aa27-3995fac4f189",
    "prId" : 5322,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/5322#pullrequestreview-168261496",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a5e6c48a-09de-44b5-982f-1a939f6353e9",
        "parentId" : null,
        "authorId" : "348fab8e-49e2-442e-884d-850c7f41fdde",
        "body" : "Nitpick: I'd rename `elems1` to `elems` here.",
        "createdAt" : "2018-10-25T08:03:18Z",
        "updatedAt" : "2018-10-25T08:25:58Z",
        "lastEditedBy" : "348fab8e-49e2-442e-884d-850c7f41fdde",
        "tags" : [
        ]
      },
      {
        "id" : "528861a9-4489-479a-ab16-8b949af96612",
        "parentId" : "a5e6c48a-09de-44b5-982f-1a939f6353e9",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "Will do",
        "createdAt" : "2018-10-25T08:04:08Z",
        "updatedAt" : "2018-10-25T08:25:58Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      },
      {
        "id" : "c3e2b6f8-c778-4ece-9de7-a9f2acdea45f",
        "parentId" : "a5e6c48a-09de-44b5-982f-1a939f6353e9",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "Done",
        "createdAt" : "2018-10-25T08:27:43Z",
        "updatedAt" : "2018-10-25T08:27:43Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      }
    ],
    "commit" : "054cfaea25a6a9ab49f00f25502abc5bb2363292",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +1795,1799 @@  /** Translate tuples of all arities */\n  def typedTuple(tree: untpd.Tuple, pt: Type)(implicit ctx: Context): Tree = {\n    val arity = tree.trees.length\n    if (arity <= Definitions.MaxTupleArity)\n      typed(desugar.smallTuple(tree).withPos(tree.pos), pt)"
  },
  {
    "id" : "470c6d36-2661-427d-8708-cf0fcd126f8e",
    "prId" : 5190,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/5190#pullrequestreview-160658720",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0a63bdc0-ed52-433d-8a65-9fcfbf916562",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "What if tree.expr is a block itself? This is handled by https://github.com/lampepfl/dotty/blob/master/compiler/src/dotty/tools/dotc/transform/Splitter.scala",
        "createdAt" : "2018-10-02T09:22:39Z",
        "updatedAt" : "2018-10-19T12:18:57Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "94cab84f-5dba-4347-8232-6ada6d559985",
        "parentId" : "0a63bdc0-ed52-433d-8a65-9fcfbf916562",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "Just added an assert in `tpd.Apply`, it seems this can never happen.",
        "createdAt" : "2018-10-02T10:36:51Z",
        "updatedAt" : "2018-10-19T12:18:57Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      }
    ],
    "commit" : "9616be10ce1339827eeb3d80deda86c0dd19b60a",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +2368,2372 @@        else tree match {\n          case tree: Block =>\n            readaptSimplified(tpd.Block(tree.stats, tpd.Apply(tree.expr, args)))\n          case _ =>\n            readaptSimplified(tpd.Apply(tree, args))"
  },
  {
    "id" : "1f0490a9-d8d5-4f21-9a0c-604f367d7357",
    "prId" : 5114,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/5114#pullrequestreview-181165954",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4b20d70b-2d1e-4104-9a5b-389b10c16296",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Looks like `ExtMethodApply` is always created around the result of a call to `extMethodApply`, can `extMethodApply` be changed to directly return an `ExtMethodApply` ?",
        "createdAt" : "2018-12-03T00:42:59Z",
        "updatedAt" : "2018-12-05T21:52:21Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "d65111dc-c763-4d5c-8daf-79b014961d24",
        "parentId" : "4b20d70b-2d1e-4104-9a5b-389b10c16296",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "I don't see it being created when it comes from typedImplicit\r\n",
        "createdAt" : "2018-12-04T09:46:57Z",
        "updatedAt" : "2018-12-05T21:52:21Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "49bae02f0265878818483442800c2e240cbeba5e",
    "line" : 242,
    "diffHunk" : "@@ -1,1 +2618,2622 @@          if (!app.isEmpty && !nestedCtx.reporter.hasErrors) {\n            nestedCtx.typerState.commit()\n            return Applications.ExtMethodApply(app).withType(app.tpe)\n          }\n        case _ =>"
  },
  {
    "id" : "0e01401e-c7a0-4779-b556-1ab6d6fdbbc5",
    "prId" : 4902,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/4902#pullrequestreview-144162989",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f76421fe-279f-4a77-a881-5f034af14ba4",
        "parentId" : null,
        "authorId" : "348fab8e-49e2-442e-884d-850c7f41fdde",
        "body" : "IIUC, avoiding `C`'s parameters was a hack, and substituting them with asSeenFrom was always the correct fix? Makes sense to me.",
        "createdAt" : "2018-08-07T16:39:39Z",
        "updatedAt" : "2018-08-08T09:37:47Z",
        "lastEditedBy" : "348fab8e-49e2-442e-884d-850c7f41fdde",
        "tags" : [
        ]
      },
      {
        "id" : "e1df8df1-8542-4140-bd6c-6600a2ff7ba6",
        "parentId" : "f76421fe-279f-4a77-a881-5f034af14ba4",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Yes, I believe that's correct.\r\n",
        "createdAt" : "2018-08-07T20:06:36Z",
        "updatedAt" : "2018-08-08T09:37:47Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "3f639b6330abcdadd03ad2d0399da597bac229ca",
    "line" : 22,
    "diffHunk" : "@@ -1,1 +1264,1268 @@                // The transform does not apply for patterns, where empty bounds translate to\n                // wildcard identifiers `_` instead.\n                res = res.withType(tparamBounds)\n              case _ =>\n            }"
  },
  {
    "id" : "994127f2-8b8f-453a-aa42-ea9637c4b1a7",
    "prId" : 4902,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/4902#pullrequestreview-144308214",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d0467349-21b9-4927-89b9-2fef1ef073fb",
        "parentId" : null,
        "authorId" : "348fab8e-49e2-442e-884d-850c7f41fdde",
        "body" : "The test failure seems genuinely to appear with this new commit (not with my changes) — everything works with the parent.\r\n\r\n```\r\nsbt:dotty> dotc -d out -Ycheck:all tests/pos/t1786-cycle.scala -Yforce-sbt-phases\r\n[warn] Multiple main classes detected.  Run 'show discoveredMainClasses' to see the list\r\n[info] Running (fork) dotty.tools.dotc.Main -classpath /Users/pgiarrusso/git/dotty/library/../out/bootstrap/dotty-library-bootstrapped/scala-0.10/dotty-library_0.10-0.10.0-bin-SNAPSHOT.jar -d out -Ycheck:all tests/pos/t1786-cycle.scala -Yforce-sbt-phases\r\nchecking tests/pos/t1786-cycle.scala after phase frontend\r\nexception occurred while compiling tests/pos/t1786-cycle.scala\r\nException in thread \"main\" dotty.tools.dotc.core.TypeError: bad parameter reference LongTraversableLike#Repr at sbt-deps\r\nthe parameter is type Repr in trait LongTraversableLike but the prefix LongTraversableLike\r\ndoes not define any corresponding arguments.\r\n\tat dotty.tools.dotc.core.Types$NamedType.argDenot(Types.scala:1834)\r\n\tat dotty.tools.dotc.core.Types$NamedType.fromDesignator$1(Types.scala:1751)\r\n\tat dotty.tools.dotc.core.Types$NamedType.computeDenot(Types.scala:1769)\r\n\tat dotty.tools.dotc.core.Types$NamedType.denot(Types.scala:1725)\r\n\tat dotty.tools.dotc.core.Types$NamedType.info(Types.scala:1714)\r\n\r\n```\r\nEDIT: cut stacktrace.",
        "createdAt" : "2018-08-07T17:52:31Z",
        "updatedAt" : "2018-08-08T12:20:40Z",
        "lastEditedBy" : "348fab8e-49e2-442e-884d-850c7f41fdde",
        "tags" : [
        ]
      },
      {
        "id" : "447b7c52-fc50-4e21-a7f8-b4e6a9aa9981",
        "parentId" : "d0467349-21b9-4927-89b9-2fef1ef073fb",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "This is fixed in the latest commit.",
        "createdAt" : "2018-08-08T08:05:39Z",
        "updatedAt" : "2018-08-08T09:37:47Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "3f639b6330abcdadd03ad2d0399da597bac229ca",
    "line" : 1,
    "diffHunk" : "@@ -1,1 +1236,1240 @@        if (args.length != tparams.length) {\n          wrongNumberOfTypeArgs(tpt1.tpe, tparams, args, tree.pos)\n          args = args.take(tparams.length)\n        }\n        def typedArg(arg: untpd.Tree, tparam: ParamInfo) = {"
  },
  {
    "id" : "0fb89cbe-3b4d-4a9c-9262-c6fc8367a888",
    "prId" : 4827,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/4827#pullrequestreview-139812738",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7386e8b5-9ddb-4002-ac45-dfde569ab60b",
        "parentId" : null,
        "authorId" : "348fab8e-49e2-442e-884d-850c7f41fdde",
        "body" : "I love when people fix bugs by removing code! ❤️",
        "createdAt" : "2018-07-24T09:46:57Z",
        "updatedAt" : "2018-07-24T09:46:57Z",
        "lastEditedBy" : "348fab8e-49e2-442e-884d-850c7f41fdde",
        "tags" : [
        ]
      }
    ],
    "commit" : "99cd405a321198037914393ee17c9f8039ebc99d",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +1476,1480 @@    def maybeCall(ref: Tree, psym: Symbol, cinfo: Type): Tree = cinfo.stripPoly match {\n      case cinfo @ MethodType(Nil) if cinfo.resultType.isImplicitMethod =>\n        typedExpr(untpd.New(ref, Nil))(superCtx)\n      case cinfo @ MethodType(Nil) if !cinfo.resultType.isInstanceOf[MethodType] =>\n        ref"
  },
  {
    "id" : "c4c54b4d-d312-44ec-88bf-099bd12a1142",
    "prId" : 4003,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/4003#pullrequestreview-97607972",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5a84e685-2dd6-487f-babb-d15f12bdb2a3",
        "parentId" : null,
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "It seems `ctx` is not actually the context (which contains class members) used in checking member definitions, thus the following code fails the check:\r\n\r\n```Scala\r\nenum Color(val x: Int) {\r\n  case Green  extends Color(3)\r\n  case Red    extends Color(2)\r\n  case Violet extends Color(Green.x + Red.x)        // error\r\n}\r\n```\r\n\r\nIs this intentional?\r\n\r\nEdited: I was wrong, it's the right context, the problem is that when we `checkEnumCaseRefsLegal` for `Color$`, it checks `Green.x + Red.x`, of course it cannot be resolved!",
        "createdAt" : "2018-02-19T16:05:07Z",
        "updatedAt" : "2018-02-20T21:31:35Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "d38547cd-9f67-430e-a864-c586e4c160d4",
        "parentId" : "5a84e685-2dd6-487f-babb-d15f12bdb2a3",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Yes, I think we need a refinement here. This accessibility checking is quite a can of worms.",
        "createdAt" : "2018-02-19T16:57:51Z",
        "updatedAt" : "2018-02-20T21:31:35Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "f07d9ca4254ae0ba51cd9219817df6862f0c3422",
    "line" : 49,
    "diffHunk" : "@@ -1,1 +1840,1844 @@                    enumContexts(mdef1.symbol) = ctx\n                  case _ =>\n                }\n                buf += mdef1\n            }"
  },
  {
    "id" : "3250b6ff-2463-4f02-9315-8a3c2d71bdfd",
    "prId" : 3841,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/3841#pullrequestreview-93816317",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1b5c724a-d732-4060-9573-b20d97b99aca",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "`app` is always an `Apply` node so I don't see how we can fall into this case or the next?",
        "createdAt" : "2018-02-03T12:47:29Z",
        "updatedAt" : "2018-02-03T13:06:29Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "5c6dbd22-9de9-40d0-9457-01f8156451ba",
        "parentId" : "1b5c724a-d732-4060-9573-b20d97b99aca",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "No, `typedApply` can also produce an `Assign` node, namely if the application is an operator assignment. E.g.\r\n\r\n    x.+=(y)\r\n\r\ngives\r\n\r\n   x = x.+(y)\r\n\r\nI added a comment to typedApply pointing this out.",
        "createdAt" : "2018-02-03T13:07:53Z",
        "updatedAt" : "2018-02-03T13:07:54Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "355a8c75b26ed00033f280999e8594acd452efa3",
    "line" : 34,
    "diffHunk" : "@@ -1,1 +1691,1695 @@          if (app.tpe.isError) app\n          else tpd.cpy.Apply(app)(fn, LiftImpure.liftArgs(defs, fn.tpe, args))\n        case Assign(lhs, rhs) =>\n          tpd.cpy.Assign(app)(lhs, lift(rhs))\n        case Block(stats, expr) =>"
  },
  {
    "id" : "48a6ccb9-32c8-4f42-9119-bc9b109c291e",
    "prId" : 3802,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/3802#pullrequestreview-90736821",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ee075017-96b9-40c9-a777-c38e5f169e05",
        "parentId" : null,
        "authorId" : "223e67d6-1873-432a-9af9-f40b82a7eedd",
        "body" : "Doesn't `ctx.mode.is(Mode.InSuperCall)` implies `ctx.owner.isConstructor`?",
        "createdAt" : "2018-01-23T08:14:06Z",
        "updatedAt" : "2018-01-23T08:14:06Z",
        "lastEditedBy" : "223e67d6-1873-432a-9af9-f40b82a7eedd",
        "tags" : [
        ]
      },
      {
        "id" : "7ab3d7f5-88dd-42ef-a3cb-8751d7202b71",
        "parentId" : "ee075017-96b9-40c9-a777-c38e5f169e05",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "It might be a method super call with `super.xys`.",
        "createdAt" : "2018-01-23T08:18:47Z",
        "updatedAt" : "2018-01-23T08:18:47Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      }
    ],
    "commit" : "ffd28b3cc23fe1268213e0ec02adbc1a1551996f",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +397,401 @@      else if (name.toTermName == nme.ERROR)\n        UnspecifiedErrorType\n      else if (ctx.owner.isConstructor && ctx.mode.is(Mode.InSuperCall) &&\n          ctx.owner.owner.unforcedDecls.lookup(tree.name).exists) {\n        // When InSuperCall mode and in a constructor we are in the arguments"
  },
  {
    "id" : "935eb061-6ab5-420a-bc35-8fa6a2e9ab51",
    "prId" : 3723,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/3723#pullrequestreview-86618564",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7e949663-c770-4768-90b1-1e9d40098ead",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Actually thinking about this more, I think we should keep the `.widen` here.\r\nI think we can only reach this case when the user write:\r\n```scala\r\nval x = 1: @unchecked\r\n```\r\nIn this case I think it's fine to interpret this code as if the user had written:\r\n```scala\r\nval x = 1: Int @unchecked\r\n```\r\nIf the user really wants to put the annotation on the singleton type, which is rather unusual, he can still explicitly write:\r\n```scala\r\nval x = 1: 1 @unchecked\r\n```\r\nThis one will work fine because of the `.widen` which was dropped in `TypeAssigner`",
        "createdAt" : "2018-01-02T12:37:14Z",
        "updatedAt" : "2018-01-02T12:37:59Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "e3652ca9-8c20-45a2-9514-25ea9c455476",
        "parentId" : "7e949663-c770-4768-90b1-1e9d40098ead",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "But that means #3564 fails, because we have precisely the case where we annotate a singleton with @uncheckedVariance. \r\n\r\nAlso, I would argue that someone writing   \r\n\r\n    expr: @unchecked\r\n\r\nis really annotating the expression `expr`, not its type. The type is an artifact of the way we express annotated expressions. So it is better that the annotation does _not_ leak into inferred types of the lhs, say. See also #3427, which is another bug that would be fixed by this PR, but would not be fixed by the proposed change.",
        "createdAt" : "2018-01-02T16:06:50Z",
        "updatedAt" : "2018-01-02T16:07:03Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "21064b24-0354-4192-a1bd-b94ec89389dc",
        "parentId" : "7e949663-c770-4768-90b1-1e9d40098ead",
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "> But that means #3564 fails, because we have precisely the case where we annotate a singleton with @uncheckedvariance.\r\n\r\nI don't think so, in #3564 a singleton type is annotated, so `ctx.mode is Type` is true, this case is handled two lines above the current one, and only the `.widen` that was in `TypeAssigner` is relevant there.\r\n\r\n> So it is better that the annotation does not leak into inferred types of the lhs, say.\r\n\r\nOK. I'm fine with this but note that this is a change of behavior with respect to Scala 2.",
        "createdAt" : "2018-01-02T19:08:07Z",
        "updatedAt" : "2018-01-02T19:08:07Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "9f9ed03a-d046-49e5-b1fa-d030e16005d0",
        "parentId" : "7e949663-c770-4768-90b1-1e9d40098ead",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "No, I changed the logic in Typer only, and #3564 started failing again.",
        "createdAt" : "2018-01-04T12:12:57Z",
        "updatedAt" : "2018-01-04T12:12:58Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "862817f3f5c2c3c5dd3bf812ff1c094460509ad7",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +1594,1598 @@      assignType(cpy.Annotated(tree)(arg1, annot1), arg1, annot1)\n    else {\n      val tpt = TypeTree(AnnotatedType(arg1.tpe, Annotation(annot1)))\n      assignType(cpy.Typed(tree)(arg1, tpt), tpt)\n    }"
  },
  {
    "id" : "074217c3-20d6-4c38-afa1-eeb0cb2dc21d",
    "prId" : 3464,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/3464#pullrequestreview-76391113",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6836fa8d-dd91-4991-9d5b-e473c39c4ec1",
        "parentId" : null,
        "authorId" : "6d71bb21-e402-4464-b2b1-8bdd8e068461",
        "body" : "I'm a bit confused by this cast, args matches `ValDef()` and is casted to a `List[ValDef]`??",
        "createdAt" : "2017-11-14T15:02:55Z",
        "updatedAt" : "2017-11-27T14:52:13Z",
        "lastEditedBy" : "6d71bb21-e402-4464-b2b1-8bdd8e068461",
        "tags" : [
        ]
      },
      {
        "id" : "c0474259-7c54-47d6-9473-fcbcc7ee0087",
        "parentId" : "6836fa8d-dd91-4991-9d5b-e473c39c4ec1",
        "authorId" : "6d71bb21-e402-4464-b2b1-8bdd8e068461",
        "body" : "Oh I didn't see the `::`",
        "createdAt" : "2017-11-14T15:15:00Z",
        "updatedAt" : "2017-11-27T14:52:13Z",
        "lastEditedBy" : "6d71bb21-e402-4464-b2b1-8bdd8e068461",
        "tags" : [
        ]
      }
    ],
    "commit" : "28a29eabf7a64901706bae075402f2b023ec0e65",
    "line" : 112,
    "diffHunk" : "@@ -1,1 +757,761 @@    args match {\n      case ValDef(_, _, _) :: _ =>\n        typedDependent(args.asInstanceOf[List[ValDef]])(\n          ctx.fresh.setOwner(ctx.newRefinedClassSymbol).setNewScope)\n      case _ =>"
  },
  {
    "id" : "0418956e-d442-4076-b3b0-d41b6b3f8213",
    "prId" : 3342,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/3342#pullrequestreview-90728977",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "19cdb369-2694-40f1-bf50-6aa777a4bf65",
        "parentId" : null,
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Move into UnusedUtil?",
        "createdAt" : "2018-01-21T20:32:47Z",
        "updatedAt" : "2018-02-21T10:25:44Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "2f7fc3d6-0df9-4067-bc1d-12fd21aa31aa",
        "parentId" : "19cdb369-2694-40f1-bf50-6aa777a4bf65",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "Will remove `UnusedUtil`",
        "createdAt" : "2018-01-23T07:36:17Z",
        "updatedAt" : "2018-02-21T10:25:44Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      }
    ],
    "commit" : "68afbcd915c5f6e17f4d1347c6a784c9b1639b13",
    "line" : 74,
    "diffHunk" : "@@ -1,1 +2131,2135 @@            }\n        }\n        def eraseUnusedArgs(args: List[Tree]): List[Tree] = {\n          if (!wtp.isUnusedMethod) args\n          else args.map { arg =>"
  },
  {
    "id" : "8a7cd9cb-514e-4e47-8829-774b9fced4cb",
    "prId" : 3254,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/3254#pullrequestreview-67338155",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3d6138e8-edf0-4a6f-bf04-975a0715eacc",
        "parentId" : null,
        "authorId" : "223e67d6-1873-432a-9af9-f40b82a7eedd",
        "body" : "Does the order of the checks matter here? I see that `constrainResult` generates new constraints if it returns `true`.\r\nIf the order does not matter, then it should be less expensive to first check `!functionExpected`.",
        "createdAt" : "2017-10-05T10:10:54Z",
        "updatedAt" : "2017-10-05T10:10:54Z",
        "lastEditedBy" : "223e67d6-1873-432a-9af9-f40b82a7eedd",
        "tags" : [
        ]
      },
      {
        "id" : "8d70be9c-e1db-4391-a592-397ff3478a4b",
        "parentId" : "3d6138e8-edf0-4a6f-bf04-975a0715eacc",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Good observation. The order does matter, actually. `constrainResult` strenghtens the constraint if it succeeds so we want to always run it.",
        "createdAt" : "2017-10-05T11:01:20Z",
        "updatedAt" : "2017-10-05T11:01:41Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "539c203dbf94caf0934132d5262fc0e2d975ad7f",
    "line" : 319,
    "diffHunk" : "@@ -1,1 +2154,2158 @@          adaptInterpolated(tree.withType(wtp.resultType), pt)\n        case wtp: ImplicitMethodType\n        if constrainResult(wtp, followAlias(pt)) || !functionExpected =>\n          adaptNoArgsImplicitMethod(wtp)\n        case wtp: MethodType if !pt.isInstanceOf[SingletonType] =>"
  },
  {
    "id" : "8a217b97-0732-41f3-adad-e3d1e9cf664b",
    "prId" : 3061,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/3061#pullrequestreview-60936636",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a4061c42-e055-48a5-a029-83c1f8a1845a",
        "parentId" : null,
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Fix: Previous logic allowed some implicit failures to be discarded if the expected type was a ProtoType.",
        "createdAt" : "2017-09-06T14:46:50Z",
        "updatedAt" : "2017-09-20T15:20:34Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "2e65bd581c7506e1a382d906a9c8a961fafabfff",
    "line" : 112,
    "diffHunk" : "@@ -1,1 +2203,2207 @@      // try an implicit conversion\n      val prevConstraint = ctx.typerState.constraint\n      def recover(failure: SearchFailure) =\n        if (isFullyDefined(wtp, force = ForceDegree.all) &&\n            ctx.typerState.constraint.ne(prevConstraint)) adapt(tree, pt)"
  },
  {
    "id" : "c5cb8b9c-acd3-4510-931a-60277e9b4c98",
    "prId" : 2962,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/2962#pullrequestreview-55152610",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "66d2ba50-17cc-4bc9-badd-591d578a2913",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Why is an attachment needed instead of checking if the tree selects `nme.apply` ?",
        "createdAt" : "2017-08-08T15:33:42Z",
        "updatedAt" : "2017-08-08T15:33:42Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "04770e3c-966b-4287-96d6-ef4e14c65dd6",
        "parentId" : "66d2ba50-17cc-4bc9-badd-591d578a2913",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Good question. It depends how we want to specity it: \r\n\r\n1st choice: An `apply` is inserted on any expression in function position unless that expression is already an inserted apply.\r\n\r\n2nd choice: An `apply` is inserted on any expression in function position unless that expression is itself an `apply` selection or call.\r\n\r\nWhich way should we go? Here's where it makes a difference. Consider the case where we want to expand to\r\n\r\n    f.apply(...).apply(...)\r\n\r\nIf we give only one `apply`, which one should be the inserted one? According to the PR, it must be the second `apply`. If we followed 2nd choice, this would be rejected instead.",
        "createdAt" : "2017-08-09T07:19:07Z",
        "updatedAt" : "2017-08-09T07:19:07Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "7e5c0190-64d4-447b-85d9-0b13c602221d",
        "parentId" : "66d2ba50-17cc-4bc9-badd-591d578a2913",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "One reason to keep the current PR is that the first `apply` could be macro generated where the macro returns a map, say. Then it would seem sensical to insert the 2nd apply automatically, as for any other map.",
        "createdAt" : "2017-08-09T07:27:22Z",
        "updatedAt" : "2017-08-09T07:28:07Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "0b0cbb36ccbe72e948e1a4bf0d9a8dbadd046ac1",
    "line" : 22,
    "diffHunk" : "@@ -1,1 +1821,1825 @@\n    def isSyntheticApply(tree: Tree): Boolean = tree match {\n      case tree: Select => tree.getAttachment(InsertedApply).isDefined\n      case Apply(fn, _) => fn.getAttachment(InsertedApply).isDefined\n      case _ => false"
  },
  {
    "id" : "ffc8afc8-eb25-4df2-9931-eb80d9102067",
    "prId" : 2934,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/2934#pullrequestreview-53097990",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0c99cce9-26d9-466e-b414-c6fa0288f496",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "`testPickling` also failed, here's a simplified way to reproduce the failure:\r\n```shell\r\n./bin/dotc -Xprint-types -Ytest-pickler compiler/src/dotty/tools/io/File.scala compiler/src/dotty/tools/io/Jar.scala\r\n```\r\nThis fails with a pickling difference, here's the diff:\r\n```diff\r\n--- before-pickling.txt 2017-07-30 16:10:33.955539823 +0200\r\n+++ after-pickling.txt  2017-07-30 16:10:33.955539823 +0200\r\n@@ -111,7 +111,7 @@\r\n           <<new java.util.jar.JarFile:java.util.jar.JarFile>:\r\n             ((x$0: java.io.File): java.util.jar.JarFile)\r\n           >\r\n-        (<<Jar.this.file:dotty.tools.io.File>.jfile:=> dotty.tools.io.JFile>):\r\n+        (<<Jar.this.file:dotty.tools.io.File>.jfile:<notype>>):\r\n           java.util.jar.JarFile\r\n         >\r\n       lazy val manifest: scala.Option[java.util.jar.Manifest] = \r\n```",
        "createdAt" : "2017-07-30T14:11:16Z",
        "updatedAt" : "2017-07-31T15:50:45Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      }
    ],
    "commit" : "8683f665c16e8af2f8381c7494b5d2e9fa499ad1",
    "line" : 12,
    "diffHunk" : "@@ -1,1 +276,280 @@                      // 2nd condition by `defDenot.symbol.maybeOwner.isType` we get lots\n                      // of failures in the `tastyBootstrap` test. Trying to compile these\n                      // files in isolation works though.\n                      // TODO: Investigate why that happens.\n                      defDenot.symbol.owner"
  },
  {
    "id" : "90c886e5-f259-478a-b54e-4bfe6e958eaf",
    "prId" : 2701,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/2701#pullrequestreview-42705461",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fdaa7b97-052d-40da-ad52-9d7752b55e0f",
        "parentId" : null,
        "authorId" : "9bea7978-e768-47a3-b26a-30cdf07678c7",
        "body" : "Typo. Should be \"patter**n**\"",
        "createdAt" : "2017-06-07T19:10:19Z",
        "updatedAt" : "2017-06-14T14:59:31Z",
        "lastEditedBy" : "9bea7978-e768-47a3-b26a-30cdf07678c7",
        "tags" : [
        ]
      }
    ],
    "commit" : "ff32e6eaf9c14db51435c1e7ed852514827d8a59",
    "line" : 43,
    "diffHunk" : "@@ -1,1 +2043,2047 @@        // Reasons NOT to eta expand:\n        //  - we reference a constructor\n        //  - we are in a patterm\n        //  - the current tree is a synthetic apply which is not expandable (eta-expasion would simply undo that)\n        if (arity >= 0 &&"
  },
  {
    "id" : "6c014abe-c0ad-46c8-b643-ea477e0cf4b9",
    "prId" : 2691,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/2691#pullrequestreview-43712430",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b5454524-5007-4a6e-ac67-7141deec1a25",
        "parentId" : null,
        "authorId" : "9eb7e1a2-8927-4525-9474-5b5e4ce6afb0",
        "body" : "Since it's a map, wouldn't this miss the (unlikely) case where the same param (one key) occurs in multiple args (multiple values, of which only the last one is retained). I don't think it's a big deal, as this could not arise from the `_` syntax, but the other comments do mention \"exactly once\" as a requirement.",
        "createdAt" : "2017-06-08T23:36:48Z",
        "updatedAt" : "2017-06-08T23:46:48Z",
        "lastEditedBy" : "9eb7e1a2-8927-4525-9474-5b5e4ce6afb0",
        "tags" : [
        ]
      },
      {
        "id" : "0d076344-5eb2-4582-940d-dbd679fd06b3",
        "parentId" : "b5454524-5007-4a6e-ac67-7141deec1a25",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "The revised implementation of paramIndices makes sure that a parameter is entered in the map only if there is a unique occurrence in args.",
        "createdAt" : "2017-06-13T12:55:13Z",
        "updatedAt" : "2017-06-13T12:55:13Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "e91afd4a971b7cfcc32f06b81105d41d77ff22fc",
    "line" : 48,
    "diffHunk" : "@@ -1,1 +756,760 @@            yield param.name -> idx\n          }.toMap\n          if (paramIndex.size == params.length)\n            expr match {\n              case untpd.TypedSplice(expr1) =>"
  },
  {
    "id" : "d1b6b0e5-5873-498e-8414-ba13d1b9b8df",
    "prId" : 2691,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/2691#pullrequestreview-43040107",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0018e334-05c3-4917-8f04-85774db93e1d",
        "parentId" : null,
        "authorId" : "9eb7e1a2-8927-4525-9474-5b5e4ce6afb0",
        "body" : "As discussed, the [current implementation in Scala 2](https://github.com/scala/scala/blob/2.12.x/src/compiler/scala/tools/nsc/typechecker/Typers.scala#L2972) includes the known argument types / result type, to enable overload resolution. Would be good to indicate the difference in a comment.",
        "createdAt" : "2017-06-08T23:37:41Z",
        "updatedAt" : "2017-06-08T23:46:48Z",
        "lastEditedBy" : "9eb7e1a2-8927-4525-9474-5b5e4ce6afb0",
        "tags" : [
        ]
      }
    ],
    "commit" : "e91afd4a971b7cfcc32f06b81105d41d77ff22fc",
    "line" : 53,
    "diffHunk" : "@@ -1,1 +761,765 @@                expr1.tpe\n              case _ =>\n                val protoArgs = args map (_ withType WildcardType)\n                val callProto = FunProto(protoArgs, WildcardType, this)\n                val expr1 = typedExpr(expr, callProto)"
  },
  {
    "id" : "a133df68-450d-424f-9208-3ec89e67f720",
    "prId" : 2078,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/2078#pullrequestreview-26447609",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f12028c0-bc8e-4f30-b34a-5b0a47aa1fd9",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "typo: TyperAssigner -> TypeAssigner",
        "createdAt" : "2017-03-12T15:39:01Z",
        "updatedAt" : "2017-03-12T15:39:02Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      }
    ],
    "commit" : "e8c27da5855f59574ba00cb1a95be8fb36b1fb48",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +629,633 @@   *  symbols. This is done by adding a type ascription of a widened type that does\n   *  not refer to the locally defined symbols. The widened type is computed using\n   *  `TyperAssigner#avoid`. However, if the expected type is fully defined and not\n   *  a supertype of the widened type, we ascribe with the expected type instead.\n   *"
  },
  {
    "id" : "39cab08c-c696-4968-a5a0-e9d16f351977",
    "prId" : 1869,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/1869#pullrequestreview-15024248",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "03cd491b-1d31-4430-8844-40dd15e511b1",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "while you're at it, you could fix the typo here: \"in a such\" -> \"in such\"",
        "createdAt" : "2017-01-03T22:18:47Z",
        "updatedAt" : "2017-01-03T22:22:31Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      }
    ],
    "commit" : "7a5f27108080226569e7eee1dc9bb7ef6da2b7ac",
    "line" : 1,
    "diffHunk" : "@@ -1,1 +1148,1152 @@        case Some(exprOwner) if c.owner.isClass =>\n          // We need to evaluate annotation arguments in an expression context, since\n          // classes defined in a such arguments should not be entered into the\n          // enclosing class.\n          c.exprContext(mdef, exprOwner)"
  },
  {
    "id" : "0379e5b0-2847-447d-b64a-45e5cf6a30d9",
    "prId" : 12902,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/12902#pullrequestreview-715663312",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6e954735-d9ee-4d90-ad52-63b762f120fd",
        "parentId" : null,
        "authorId" : "4ebe10b7-4cc5-4c8a-bf32-b97a4396b1b2",
        "body" : "It should probably be matching `Singleton` as we also do not want to widen a `x.type`.",
        "createdAt" : "2021-06-29T12:06:06Z",
        "updatedAt" : "2021-06-29T12:09:03Z",
        "lastEditedBy" : "4ebe10b7-4cc5-4c8a-bf32-b97a4396b1b2",
        "tags" : [
        ]
      },
      {
        "id" : "2de67a96-0047-471d-b172-96e005f4bb7b",
        "parentId" : "6e954735-d9ee-4d90-ad52-63b762f120fd",
        "authorId" : "4ebe10b7-4cc5-4c8a-bf32-b97a4396b1b2",
        "body" : "I updated this and added a test case",
        "createdAt" : "2021-07-27T08:58:05Z",
        "updatedAt" : "2021-07-27T08:58:05Z",
        "lastEditedBy" : "4ebe10b7-4cc5-4c8a-bf32-b97a4396b1b2",
        "tags" : [
        ]
      }
    ],
    "commit" : "4bb42ac376b9c21b76ebc1a525651bc09f2bfcba",
    "line" : 8,
    "diffHunk" : "@@ -1,1 +1468,1472 @@        val rawSelectorTpe = fullyDefinedType(sel1.tpe, \"pattern selector\", tree.span)\n        val selType = rawSelectorTpe match\n          case c: ConstantType if tree.isInline => c\n          case otherTpe => otherTpe.widen\n        /** Extractor for match types hidden behind an AppliedType/MatchAlias */"
  },
  {
    "id" : "ce71f3fe-f97d-4bbe-a298-8c02d862cf37",
    "prId" : 12902,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/12902#pullrequestreview-715663312",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2e1bd59f-26b9-4324-bd7d-f90b6a611a06",
        "parentId" : null,
        "authorId" : "4ebe10b7-4cc5-4c8a-bf32-b97a4396b1b2",
        "body" : "It should probably be matching `Singleton` as we also do not want to widen a `x.type`.",
        "createdAt" : "2021-06-29T12:06:06Z",
        "updatedAt" : "2021-06-29T12:09:03Z",
        "lastEditedBy" : "4ebe10b7-4cc5-4c8a-bf32-b97a4396b1b2",
        "tags" : [
        ]
      },
      {
        "id" : "2b13bc5d-5c46-4454-b23c-988c1dcaa6fc",
        "parentId" : "2e1bd59f-26b9-4324-bd7d-f90b6a611a06",
        "authorId" : "4ebe10b7-4cc5-4c8a-bf32-b97a4396b1b2",
        "body" : "I updated this and added a test case",
        "createdAt" : "2021-07-27T08:58:05Z",
        "updatedAt" : "2021-07-27T08:58:05Z",
        "lastEditedBy" : "4ebe10b7-4cc5-4c8a-bf32-b97a4396b1b2",
        "tags" : [
        ]
      }
    ],
    "commit" : "4bb42ac376b9c21b76ebc1a525651bc09f2bfcba",
    "line" : 8,
    "diffHunk" : "@@ -1,1 +1468,1472 @@        val rawSelectorTpe = fullyDefinedType(sel1.tpe, \"pattern selector\", tree.span)\n        val selType = rawSelectorTpe match\n          case c: ConstantType if tree.isInline => c\n          case otherTpe => otherTpe.widen\n        /** Extractor for match types hidden behind an AppliedType/MatchAlias */"
  }
]
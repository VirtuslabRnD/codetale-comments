[
  {
    "id" : "28a7378d-6c80-44e0-a177-f9136afc7d91",
    "prId" : 5115,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/5115#pullrequestreview-167882724",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5d0f2831-5a01-4b5e-82e6-d65543cdfbea",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Why does this occur ?",
        "createdAt" : "2018-10-24T12:35:47Z",
        "updatedAt" : "2018-11-05T17:43:21Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "b2d65371-4fec-42f0-bba9-6ae3ce06ace4",
        "parentId" : "5d0f2831-5a01-4b5e-82e6-d65543cdfbea",
        "authorId" : "5a9cd756-9120-4d5e-ac88-e9c636084f0e",
        "body" : "Because we want a way to represent an infinite `while` loop, whose type is therefore `Nothing`. It's the whole point of the second commit in this PR.",
        "createdAt" : "2018-10-24T12:37:48Z",
        "updatedAt" : "2018-11-05T17:43:21Z",
        "lastEditedBy" : "5a9cd756-9120-4d5e-ac88-e9c636084f0e",
        "tags" : [
        ]
      }
    ],
    "commit" : "3084b1a9e5cf6e3014ae222d87891c6ea8f91527",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +487,491 @@\n  def assignType(tree: untpd.WhileDo)(implicit ctx: Context): WhileDo =\n    tree.withType(if (tree.cond eq EmptyTree) defn.NothingType else defn.UnitType)\n\n  def assignType(tree: untpd.Try, expr: Tree, cases: List[CaseDef])(implicit ctx: Context): Try ="
  },
  {
    "id" : "b5e237ee-f876-4329-bc82-f30202aaade1",
    "prId" : 3061,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/3061#pullrequestreview-60934541",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c9564635-b91b-4778-a909-67dfc58c30c6",
        "parentId" : null,
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Fix: classBound should have the same kind as the abstracted type.",
        "createdAt" : "2017-09-06T14:41:15Z",
        "updatedAt" : "2017-09-20T15:20:34Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "2e65bd581c7506e1a382d906a9c8a961fafabfff",
    "line" : 45,
    "diffHunk" : "@@ -1,1 +68,72 @@    val refinableDecls = info.decls.filter(isRefinable)\n    val raw = (parentType /: refinableDecls)(addRefinement)\n    HKTypeLambda.fromParams(cls.typeParams, raw) match {\n      case tl: HKTypeLambda => tl.derivedLambdaType(resType = close(tl.resType))\n      case tp => close(tp)"
  },
  {
    "id" : "d0438a90-cb15-4378-aca8-01eea637e70f",
    "prId" : 2945,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/2945#pullrequestreview-56630235",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "cdce6138-0382-4a93-8b1e-d9e243c89b7b",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "typo: IThen -> Then",
        "createdAt" : "2017-08-16T13:32:38Z",
        "updatedAt" : "2017-08-17T15:57:19Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      }
    ],
    "commit" : "491fe97b5cfdffe5cae7ef6dd9b2a711ee454e1b",
    "line" : 36,
    "diffHunk" : "@@ -1,1 +113,117 @@       *      the original prefix. Since the original prefix is known to\n       *      be a subtype of the returned prefix, this can improve results.\n       *   2. IThen, if the approximation result is a singleton reference C#x.type, we\n       *      replace by the widened type, which is usually more natural.\n       *   3. Finally, we need to handle the case where the prefix type does not have a member"
  },
  {
    "id" : "60b8b2e6-bb15-430b-8e34-df5ce816e8e3",
    "prId" : 2118,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/2118#pullrequestreview-27689995",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2b8e6a00-2893-40a2-9bfd-d54132484b58",
        "parentId" : null,
        "authorId" : "aa14f673-3d29-4a61-bf43-a86828212cf2",
        "body" : "Is this necessary, or can I just do `tree.withType(err)`?\r\nIn general, when I should I be using the tree copier?",
        "createdAt" : "2017-03-17T20:44:51Z",
        "updatedAt" : "2017-03-17T21:44:19Z",
        "lastEditedBy" : "aa14f673-3d29-4a61-bf43-a86828212cf2",
        "tags" : [
        ]
      },
      {
        "id" : "26e7bb07-b253-4e1b-9e9a-d13cf95f5adc",
        "parentId" : "2b8e6a00-2893-40a2-9bfd-d54132484b58",
        "authorId" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "body" : "Tree copier provides structural sharing and is used when you think that the tree might stay the same after your changes.\r\n",
        "createdAt" : "2017-03-17T20:46:29Z",
        "updatedAt" : "2017-03-17T21:44:19Z",
        "lastEditedBy" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "tags" : [
        ]
      },
      {
        "id" : "4ed20554-5825-41d1-b662-7781a2a5348c",
        "parentId" : "2b8e6a00-2893-40a2-9bfd-d54132484b58",
        "authorId" : "aa14f673-3d29-4a61-bf43-a86828212cf2",
        "body" : "Thanks. In this case, would it be ok/better to do `tree.withType(err)`?",
        "createdAt" : "2017-03-17T21:14:43Z",
        "updatedAt" : "2017-03-17T21:44:19Z",
        "lastEditedBy" : "aa14f673-3d29-4a61-bf43-a86828212cf2",
        "tags" : [
        ]
      }
    ],
    "commit" : "3920414761daf37106ff94ae75b87eb822d9430f",
    "line" : 15,
    "diffHunk" : "@@ -1,1 +293,297 @@    val mix = tree.mix\n    qual.tpe match {\n      case err: ErrorType => untpd.cpy.Super(tree)(qual, mix).withType(err)\n      case qtype @ ThisType(_) =>\n        val cls = qtype.cls"
  }
]
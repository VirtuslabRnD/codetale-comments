[
  {
    "id" : "551d807e-90fa-410f-80b8-23371b1b5095",
    "prId" : 12171,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/12171#pullrequestreview-643496861",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "96042c26-5092-4470-bf42-986b429018f6",
        "parentId" : null,
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "At first glance this looks too simplistic. We do a complicated dance not to overcommit by caching arguments that can be passed to several different expected types. How can we be sure that we can simply cache in this case? Maybe we can, but we'd need a detailed comment why.",
        "createdAt" : "2021-04-23T15:12:09Z",
        "updatedAt" : "2021-04-26T07:56:20Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "77838243-2cc4-44f6-9ddf-229c7e781e8b",
        "parentId" : "96042c26-5092-4470-bf42-986b429018f6",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "Yes, a comment is deserved here. Currently I see the rationale is this: the `expected type` for pretyping here come from all the overloading candidates and they (`commandParamTypes`) are all fully defined.\r\n\r\n> I just checked: it does not work with master anymore. I think #12138 is to blame.\r\n\r\nI rebased against master, it seems to work.",
        "createdAt" : "2021-04-23T16:58:12Z",
        "updatedAt" : "2021-04-26T07:56:20Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      }
    ],
    "commit" : "1bf1b3fab3da0b6af7ac13036a45b47c0450e9f8",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +2102,2106 @@          overload.println(i\"pretype arg $arg with expected type $commonFormal\")\n          if (commonParamTypes.forall(isFullyDefined(_, ForceDegree.flipBottom)))\n            withMode(Mode.ImplicitsEnabled) {\n              // We can cache the adapted argument here because the expected type\n              // is a common type shared by all overloading candidates."
  },
  {
    "id" : "896fa9b3-acd2-404e-85c0-eb1ff4ada338",
    "prId" : 11187,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/11187#pullrequestreview-591011658",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ba1f83c1-fa65-4728-bffb-0077ed8d8b00",
        "parentId" : null,
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "One question about the specification: if `D` or `E` is not available, maybe we can simply not suggest the extension method to the programmer. This might simplify the code a lot, so that we can simply use `isApplicableMethodRef` as in the original code.",
        "createdAt" : "2021-02-12T13:41:29Z",
        "updatedAt" : "2021-02-22T14:27:51Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "dac748e2-9c74-42a1-9120-2a61e27985ba",
        "parentId" : "ba1f83c1-fa65-4728-bffb-0077ed8d8b00",
        "authorId" : "5245b2da-2ff9-4276-9b2e-e1be5771149e",
        "body" : "As mentioned, `isApplicableMethodRef` doesn't work correctly if there are some leading using sections before the first explicit parameters list. Also as stated in the description of the PR suggesting a method if `D` or `E` are not in scope still makes sense as a user might provide the following implicits explicitly while leading implicits cannot be passed explicitly with dot syntax. This is also consistent with how completions work for implicit classes",
        "createdAt" : "2021-02-12T14:23:40Z",
        "updatedAt" : "2021-02-22T14:27:51Z",
        "lastEditedBy" : "5245b2da-2ff9-4276-9b2e-e1be5771149e",
        "tags" : [
        ]
      },
      {
        "id" : "8da56087-b560-4885-908c-94c3b0a9e30f",
        "parentId" : "ba1f83c1-fa65-4728-bffb-0077ed8d8b00",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "Maybe do some formatting of the documentation here.",
        "createdAt" : "2021-02-16T09:45:32Z",
        "updatedAt" : "2021-02-22T14:27:51Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      }
    ],
    "commit" : "d09fcc2726ed5e8b6fa2cf86b596bc8b4cab572e",
    "line" : 29,
    "diffHunk" : "@@ -1,1 +2148,2152 @@   *  might depend on the exact types of the found instances of the proceding implicits).\n   *  No implicit search is tried for implicits following the receiver or for parameters of the def (D, E).\n   */\n  def tryApplyingExtensionMethod(methodRef: TermRef, receiver: Tree)(using Context): Option[Tree] =\n    // Drop all parameters sections of an extension method following the receiver."
  },
  {
    "id" : "3f80f334-b4db-4293-a5b3-4179f9218a0b",
    "prId" : 10473,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/10473#pullrequestreview-540074981",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2d4306f2-037e-436f-934e-8912519b1963",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "You could check `!receiver.isBottomType` here to exclude Nothing and Null so you don't have to exclude them in the caller.",
        "createdAt" : "2020-11-26T17:30:25Z",
        "updatedAt" : "2020-11-27T17:49:04Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "342559eb-b0bd-4978-baf3-b3f35ec7dd72",
        "parentId" : "2d4306f2-037e-436f-934e-8912519b1963",
        "authorId" : "5245b2da-2ff9-4276-9b2e-e1be5771149e",
        "body" : "Right, I can move the check here but not sure we should exclude Null. The compiler still lets you define an extension on Null so I think for consistency this should be displayed in a completion",
        "createdAt" : "2020-11-27T08:53:03Z",
        "updatedAt" : "2020-11-27T17:49:04Z",
        "lastEditedBy" : "5245b2da-2ff9-4276-9b2e-e1be5771149e",
        "tags" : [
        ]
      },
      {
        "id" : "769093f1-236e-4bfd-9be7-3658501f3081",
        "parentId" : "2d4306f2-037e-436f-934e-8912519b1963",
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "> The compiler still lets you define an extension on Null so I think for consistency this should be displayed in a completion\r\n\r\nI don't think it's a big deal either way, but because by default `Null` is a subtype of every reference type, one should be careful to not include all the extension methods that apply to reference types in the list",
        "createdAt" : "2020-11-27T13:06:33Z",
        "updatedAt" : "2020-11-27T17:49:04Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "63f3a6dc-1ee9-4166-84f9-4c00cea452c8",
        "parentId" : "2d4306f2-037e-436f-934e-8912519b1963",
        "authorId" : "5245b2da-2ff9-4276-9b2e-e1be5771149e",
        "body" : "Checking `isBottomType` then",
        "createdAt" : "2020-11-27T15:59:48Z",
        "updatedAt" : "2020-11-27T17:49:04Z",
        "lastEditedBy" : "5245b2da-2ff9-4276-9b2e-e1be5771149e",
        "tags" : [
        ]
      }
    ],
    "commit" : "b9da708a219bb0552a8d1e66cb706d4a289926a2",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +2178,2182 @@  }\n\n  def isApplicableExtensionMethod(ref: TermRef, receiver: Type)(using Context) =\n    ref.symbol.is(ExtensionMethod)\n    && !receiver.isBottomType"
  },
  {
    "id" : "4b6ae6b7-2b4d-4a7d-8b78-da97c1da6eeb",
    "prId" : 10317,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/10317#pullrequestreview-531355540",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fa833184-bf48-4767-8423-7848a05cc382",
        "parentId" : null,
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "Can we instead check whether subtype conforms? The following code fails to type-check:\r\n\r\n```Scala\r\ndef foo(init: String ?=> Int ?=> Int) : Int = 1\r\ndef foo(s: String)(init: Int ?=> Int) : Int = 2\r\n\r\n\r\n@main def Test() =\r\n  implicit val ev: String = \"hello\"\r\n  assert(foo((using x:Int) => x) == 1)\r\n```",
        "createdAt" : "2020-11-16T12:28:19Z",
        "updatedAt" : "2020-11-16T14:00:28Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "4b4f0553-dc10-42e3-ab13-e185586cfedb",
        "parentId" : "fa833184-bf48-4767-8423-7848a05cc382",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "I think that goes beyond what's possible. That code also fails if only the first variant of `foo` is given. \r\n\r\nI don't see any way to improve the current solution.\r\n",
        "createdAt" : "2020-11-16T14:02:34Z",
        "updatedAt" : "2020-11-16T14:02:35Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "28eba0ed-f3d4-47be-8af8-82ae846da485",
        "parentId" : "fa833184-bf48-4767-8423-7848a05cc382",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "Yes, I see the eta-expansion is before type checking the argument, it's pretty subtle.",
        "createdAt" : "2020-11-16T14:13:00Z",
        "updatedAt" : "2020-11-16T14:13:00Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      }
    ],
    "commit" : "62c0c8d86b85af082a9fe695d4a8fd95a133e059",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +680,684 @@    def argType(arg: Tree, formal: Type): Type =\n      if untpd.isContextualClosure(arg) && defn.isContextFunctionType(formal) then arg.tpe\n      else normalize(arg.tpe, formal)\n    def treeToArg(arg: Tree): Tree = arg\n    def isVarArg(arg: Tree): Boolean = tpd.isWildcardStarArg(arg)"
  },
  {
    "id" : "08abbf74-30a8-4ff4-923e-749d7c54b948",
    "prId" : 9932,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/9932#pullrequestreview-501125218",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8beea6f6-86a0-414c-ba64-f1578678c40b",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Why is this check needed?",
        "createdAt" : "2020-10-02T11:05:45Z",
        "updatedAt" : "2020-10-02T13:16:13Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "9868c11d-6ac5-40d2-b3b0-742f41091b9d",
        "parentId" : "8beea6f6-86a0-414c-ba64-f1578678c40b",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "So that we don't widen partially applied applications.",
        "createdAt" : "2020-10-02T13:16:49Z",
        "updatedAt" : "2020-10-02T13:16:50Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "fe1355ae95d61527b7488c5479088e819dd23dd4",
    "line" : 45,
    "diffHunk" : "@@ -1,1 +1124,1128 @@    if sym.is(Synthetic) && (isEnumApply || isEnumCopy)\n       && tree.tpe.classSymbol.isEnumCase\n       && tree.tpe.widen.isValueType\n    then\n      val widened = TypeComparer.dropSuperTraits("
  },
  {
    "id" : "886eedc1-ccac-4eb4-b30c-a461346cda8f",
    "prId" : 9582,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/9582#pullrequestreview-470604844",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9392e66b-5bef-4d83-959b-db1e54b7212e",
        "parentId" : null,
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "Shouldn't we also check that the name of `fun` has a synthetic span?",
        "createdAt" : "2020-08-19T10:52:58Z",
        "updatedAt" : "2020-08-19T10:53:02Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      },
      {
        "id" : "d94d94b4-0835-40b2-814e-cce0ebebc497",
        "parentId" : "9392e66b-5bef-4d83-959b-db1e54b7212e",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "Oh, no",
        "createdAt" : "2020-08-19T10:53:51Z",
        "updatedAt" : "2020-08-19T10:53:52Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      },
      {
        "id" : "71d6c684-a277-4e0e-bdc6-34f021335ecc",
        "parentId" : "9392e66b-5bef-4d83-959b-db1e54b7212e",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "What kind of trees do we get here?",
        "createdAt" : "2020-08-19T10:55:02Z",
        "updatedAt" : "2020-08-19T10:55:02Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      },
      {
        "id" : "2fda3a43-95f1-4d72-a3d4-ec7e06dcd325",
        "parentId" : "9392e66b-5bef-4d83-959b-db1e54b7212e",
        "authorId" : "5a9cd756-9120-4d5e-ac88-e9c636084f0e",
        "body" : "Anything. For the test that was failing, it was `TypeApply(Ident(\"qual\"), List(oneTArg))`.",
        "createdAt" : "2020-08-19T11:05:14Z",
        "updatedAt" : "2020-08-19T11:05:14Z",
        "lastEditedBy" : "5a9cd756-9120-4d5e-ac88-e9c636084f0e",
        "tags" : [
        ]
      },
      {
        "id" : "5a3583b0-c28b-405d-a2d8-7dbfe4514650",
        "parentId" : "9392e66b-5bef-4d83-959b-db1e54b7212e",
        "authorId" : "5a9cd756-9120-4d5e-ac88-e9c636084f0e",
        "body" : "Where I was expecting `typedFunPart` to have returned `TypeApply(Select(Ident(\"qual\"), nme.apply), List(oneTarg))` instead, where the `Select` node would have had a synthetic span.",
        "createdAt" : "2020-08-19T11:06:26Z",
        "updatedAt" : "2020-08-19T11:06:26Z",
        "lastEditedBy" : "5a9cd756-9120-4d5e-ac88-e9c636084f0e",
        "tags" : [
        ]
      },
      {
        "id" : "133a5cf8-8c5d-4a67-b395-919bb4c9f07d",
        "parentId" : "9392e66b-5bef-4d83-959b-db1e54b7212e",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "I'm wondering if we can get a `TypeApply(Block(..., Select(..., nme.apply)), ...)`. I guess those would never be inserted applies.",
        "createdAt" : "2020-08-19T15:57:36Z",
        "updatedAt" : "2020-08-19T15:57:36Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      },
      {
        "id" : "e2397f8f-9cc9-4a18-a9e3-33377eed422b",
        "parentId" : "9392e66b-5bef-4d83-959b-db1e54b7212e",
        "authorId" : "5a9cd756-9120-4d5e-ac88-e9c636084f0e",
        "body" : "No, in that case, for an inserted apply, the `Select` should be around the `Block`, not inside it.",
        "createdAt" : "2020-08-19T16:01:24Z",
        "updatedAt" : "2020-08-19T16:01:25Z",
        "lastEditedBy" : "5a9cd756-9120-4d5e-ac88-e9c636084f0e",
        "tags" : [
        ]
      }
    ],
    "commit" : "22010f617ea3da1c2f3920509fc7d25c6c96dd97",
    "line" : 18,
    "diffHunk" : "@@ -1,1 +927,931 @@             * In the meantime, this makes tests pass.\n             */\n            case TypeApply(fun, _) => !fun.isInstanceOf[Select]\n            case _ => false\n          }"
  },
  {
    "id" : "f4dee5bd-f2aa-49f4-85b4-a3fe0c5144b3",
    "prId" : 6850,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/6850#pullrequestreview-342398483",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "744f41c6-d5e2-4533-a2be-1569e064b626",
        "parentId" : null,
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "Those this work with `type X = Boolean; def isEmpty: X = ...`?",
        "createdAt" : "2019-12-17T07:43:26Z",
        "updatedAt" : "2020-01-14T10:42:41Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      },
      {
        "id" : "a000251a-cc3d-4e83-9e26-9275d458763a",
        "parentId" : "744f41c6-d5e2-4533-a2be-1569e064b626",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "Yes, according to the definition of `isRef`, it will work.",
        "createdAt" : "2020-01-14T09:41:23Z",
        "updatedAt" : "2020-01-14T10:43:21Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      }
    ],
    "commit" : "435f02f77f4ee6f035176010630b918f70f1df12",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +72,76 @@   */\n  def isGetMatch(tp: Type, errorPos: SourcePosition = NoSourcePosition)(implicit ctx: Context): Boolean =\n    extractorMemberType(tp, nme.isEmpty, errorPos).widenSingleton.isRef(defn.BooleanClass) &&\n    extractorMemberType(tp, nme.get, errorPos).exists\n"
  },
  {
    "id" : "14957fb2-2707-432f-92dc-e4877a675296",
    "prId" : 6756,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/6756#pullrequestreview-255042686",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9d5ce9f5-1c3b-4bcc-88d2-1f6b09a03447",
        "parentId" : null,
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "I find this extremely dicey. alt.apply is not even a well formed term and its type refers an unbound param ref. So this does not look right to me. Scala 2's behavior is no excuse, since it has many situations where bound variables escape. So I do not think this is the right fix, and I am not sure we need a fix at all, since it seems impossible to describe the fix in terms that are simple and sound.\r\n",
        "createdAt" : "2019-06-26T19:47:39Z",
        "updatedAt" : "2019-06-27T14:24:48Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "9550c9b8-81f1-423d-9686-454046e3d812",
        "parentId" : "9d5ce9f5-1c3b-4bcc-88d2-1f6b09a03447",
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "> alt.apply is not even a well formed term\r\n\r\nBut this is also true for the case where `alt` is a monomorphic method since it's not a stable prefix, and yet the existing code will happily make up a TermRef for it. If we wanted to be stricter we could use `.narrow` instead.\r\n\r\n> its type refers an unbound param ref.\r\n\r\nTrue, since this is only used for overloading resolution, it seemed OK to me. If we want to avoid that, an alternative would be to make the resulting types polymorphic, e.g. if we start with:\r\n```scala\r\ndef foo2[T]: T => String\r\n```\r\nThen we could pretend that it really has type:\r\n```scala\r\n[T](x: T): String\r\n```\r\n\r\nThis would mean that switching between having a polymorphic method with a parameter list and a polymorphic method that returns an object with the same parameter list would not affect which overload gets chosen, this is a nice property to have and it matches what happens with monomorphic methods. The only downside I see is that it doesn't match Scala 2 behavior, but I don't think that's a big deal here (and the current behavior of dotty master can also select a different overload than Scala 2, so we wouldn't be regressing).",
        "createdAt" : "2019-06-26T20:39:30Z",
        "updatedAt" : "2019-06-27T14:24:48Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "cd89f6f2-f860-4b40-bad1-7601f008f52b",
        "parentId" : "9d5ce9f5-1c3b-4bcc-88d2-1f6b09a03447",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "You'd certainly get into problems if the polytype is already in use in the current constraint. Yes, we can move the PolyType around, onto the apply method, but these are complicated acrobatics which make the code base harder to understand. Do we have a hard reason for doing this? Being compatible with scalac is not reason enough by itself, I think.\r\n",
        "createdAt" : "2019-06-27T07:13:32Z",
        "updatedAt" : "2019-06-27T14:24:48Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "62fe5415a1a83b5a24c7c546b225e0509577791f",
    "line" : 12,
    "diffHunk" : "@@ -1,1 +1526,1530 @@            alt\n        }\n        qual.member(nme.apply).alternatives.map(TermRef(alt, nme.apply, _))\n      }\n      else alt :: Nil"
  },
  {
    "id" : "18b4cc65-50d9-4fd4-9416-e0e3d584c386",
    "prId" : 6418,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/6418#pullrequestreview-233480553",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "62171b7a-3a61-42be-9869-36ec146c570d",
        "parentId" : null,
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "Note that I used `.head` because `args` is  of type `List[Arg]` and\r\n```scala\r\n  case (arg @ Typed(Literal(Constant(null)), _)) :: Nil =>\r\n    addTyped(arg, formal)\r\n```\r\nwould fail with \r\n```scala\r\n[error] 560 |                addTyped(arg, formal)\r\n[error]     |                         ^^^\r\n[error]     |Found:    dotty.tools.dotc.ast.Trees.Typed[dotty.tools.dotc.ast.Trees.Untyped](arg)\r\n[error]     |Required: Arg\r\n```\r\n",
        "createdAt" : "2019-05-02T09:46:14Z",
        "updatedAt" : "2019-05-02T09:46:15Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      },
      {
        "id" : "dde19dfe-8470-4049-948c-7eb3bf0d301c",
        "parentId" : "62171b7a-3a61-42be-9869-36ec146c570d",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "What about just reject the code? We are moving towards null-safety, it seems it's better to reject. /cc: @abeln ",
        "createdAt" : "2019-05-02T16:33:37Z",
        "updatedAt" : "2019-05-02T16:34:45Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "5e5a5aab-1fc9-4bce-8f18-7951b842b441",
        "parentId" : "62171b7a-3a61-42be-9869-36ec146c570d",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "We should not always reject it. We could pass it to a Java varargs. Not sure if someone actually uses this pattern for performance reasons.",
        "createdAt" : "2019-05-02T20:05:55Z",
        "updatedAt" : "2019-05-02T20:05:56Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      },
      {
        "id" : "1b5bf89f-d118-48ed-8b48-d4853a638638",
        "parentId" : "62171b7a-3a61-42be-9869-36ec146c570d",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "In Java it is legal to pass `null` as the actual array of the varargs https://coderanch.com/t/631441/java/Varargs-null",
        "createdAt" : "2019-05-03T13:52:02Z",
        "updatedAt" : "2019-05-03T13:52:02Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      }
    ],
    "commit" : "11120a781abf4a8b1ea62e0b96f0998565a0e3f5",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +558,562 @@                addTyped(arg, formal)\n              case Typed(Literal(Constant(null)), _) :: Nil =>\n                addTyped(args.head, formal)\n              case _ =>\n                val elemFormal = formal.widenExpr.argTypesLo.head"
  },
  {
    "id" : "3e8de77a-f765-456e-af41-25e9692e5da3",
    "prId" : 6116,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/6116#pullrequestreview-216992502",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "69c06c99-8e96-4c91-98fe-18070aab5330",
        "parentId" : null,
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "What is the purpose of the dispatch here? Semantically it seems the same as:\r\n```Scala\r\ntp.memberBasedOnFlags(name, required = ExtensionMethod).hasAltWith(qualifies(_))\r\n```\r\n\r\nIs it for performance? It seems we save several `exists` check this way.",
        "createdAt" : "2019-03-20T15:56:45Z",
        "updatedAt" : "2019-03-20T16:28:06Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "1c053198-6ee1-4f14-a847-a1cd37402299",
        "parentId" : "69c06c99-8e96-4c91-98fe-18070aab5330",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Yes, it's for performance. We optimize for the common case where the member is not overloaded.\r\n",
        "createdAt" : "2019-03-20T21:29:14Z",
        "updatedAt" : "2019-03-20T21:29:15Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "1762d21b060f953b43e335046fc0179ce89c4653",
    "line" : 19,
    "diffHunk" : "@@ -1,1 +1211,1215 @@      case mbr: SingleDenotation => qualifies(mbr)\n      case mbr => mbr.hasAltWith(qualifies(_))\n    }\n  }\n"
  },
  {
    "id" : "01d97408-aa47-4475-adee-c1564915db70",
    "prId" : 6084,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/6084#pullrequestreview-219480543",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "aeae4738-2a69-422e-b1e1-b51f975d597f",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Some more detailed explanation of what \"integrated\" means here would be nice.",
        "createdAt" : "2019-03-27T17:00:46Z",
        "updatedAt" : "2019-03-28T07:43:09Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      }
    ],
    "commit" : "52f2e63dd8ac10dbe36289bedb74d1530e725019",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +187,191 @@    if (defs != null && defs.nonEmpty) tpd.Block(defs.toList, tree) else tree\n\n  /** A wrapper indicating that its `app` argument has already integrated the type arguments\n   *  of the expected type, provided that type is a (possibly ignored) PolyProto.\n   *  I.e., if the expected type is a PolyProto, then `app` will be a `TypeApply(_, args)` where"
  },
  {
    "id" : "613be565-d057-4fde-8a41-159cfa86044f",
    "prId" : 6001,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/6001#pullrequestreview-209884479",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3cb10248-f59e-49c6-b4ac-a33f45db37ef",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Why the special case for `isError` here ?",
        "createdAt" : "2019-03-02T10:14:01Z",
        "updatedAt" : "2019-03-02T21:36:12Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "d224cc58-10b6-4bee-a0fd-1cac192af807",
        "parentId" : "3cb10248-f59e-49c6-b4ac-a33f45db37ef",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "`isError = true` implies an error on the outer-most tree, thus `NotAnExtractor` error should be preferred.",
        "createdAt" : "2019-03-02T17:10:47Z",
        "updatedAt" : "2019-03-02T21:36:12Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "f1a9b656-d297-4cfa-8eb8-1795fb906b73",
        "parentId" : "3cb10248-f59e-49c6-b4ac-a33f45db37ef",
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "> thus NotAnExtractor error should be preferred\r\n\r\nDid you mean \"should _not_ be preferred\" ? You're not using the error from NotAnExtractor when isError is true.",
        "createdAt" : "2019-03-02T18:15:57Z",
        "updatedAt" : "2019-03-02T21:36:12Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "d4e381cc-94d6-4bd2-804c-bcdaebcc1b6b",
        "parentId" : "3cb10248-f59e-49c6-b4ac-a33f45db37ef",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "The check `!tree.tpe.isError && tree.tpe.isErroneous ` ensures that `isError = true` will go to the 2nd branch, which is a `NotAnExtractor` error.",
        "createdAt" : "2019-03-02T21:08:31Z",
        "updatedAt" : "2019-03-02T21:36:12Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "a8864b15-d216-4416-a10e-5af590fada78",
        "parentId" : "3cb10248-f59e-49c6-b4ac-a33f45db37ef",
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Ah right, got confused, but can you add a comment that gives an example where NotAnExtractor should be preferred to get a good error message ?",
        "createdAt" : "2019-03-02T21:17:07Z",
        "updatedAt" : "2019-03-02T21:36:12Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      }
    ],
    "commit" : "55e65cac5cd4e3a86d1b4fc317b6dfe5ad274712",
    "line" : 8,
    "diffHunk" : "@@ -1,1 +944,948 @@      // prefer inner errors\n      // e.g. report not found ident instead of not an extractor in tests/neg/i2950.scala\n      if (!tree.tpe.isError && tree.tpe.isErroneous) tree\n      else errorTree(tree, NotAnExtractor(qual))\n"
  },
  {
    "id" : "2784cf41-4147-4c71-ae09-bfc926b816b8",
    "prId" : 5989,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/5989#pullrequestreview-213088973",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "674f2397-aef2-4a81-8911-cd41ee1dab93",
        "parentId" : null,
        "authorId" : "6d71bb21-e402-4464-b2b1-8bdd8e068461",
        "body" : "Looks a bit convoluted, maybe something like this instead:?\r\n\r\n```scala\r\nval selTps = productSelectorTypes(tp, pos)\r\nselTps.init :+ unapplySeqTypeElemTp(selTps.last)\r\n```",
        "createdAt" : "2019-03-11T16:54:48Z",
        "updatedAt" : "2019-03-11T21:40:48Z",
        "lastEditedBy" : "6d71bb21-e402-4464-b2b1-8bdd8e068461",
        "tags" : [
        ]
      },
      {
        "id" : "c32e2424-46a4-43d5-bf30-8eb1a1e4a263",
        "parentId" : "674f2397-aef2-4a81-8911-cd41ee1dab93",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "This does not give exactly `argsNum` types.",
        "createdAt" : "2019-03-11T21:14:40Z",
        "updatedAt" : "2019-03-11T21:40:48Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      }
    ],
    "commit" : "ec5a391c81c200cfff208771dd8c77f7d3d05627",
    "line" : 72,
    "diffHunk" : "@@ -1,1 +141,145 @@      val arity = selTps.length\n      val elemTp = unapplySeqTypeElemTp(selTps.last)\n      (0 until argsNum).map(i => if (i < arity - 1) selTps(i) else elemTp).toList\n    }\n"
  },
  {
    "id" : "cb678463-b233-4413-ba07-1b572c792c74",
    "prId" : 5981,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/5981#pullrequestreview-208080441",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "35c3044a-5d2e-401e-8c2a-a03234a5c4d4",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Do we have some guarantee that the result of `argType` cannot be an ExprType here ? Even if we do, it seems more regular to widen both sides.",
        "createdAt" : "2019-02-25T12:26:01Z",
        "updatedAt" : "2019-02-25T12:26:12Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "c49a167d-06fa-4f30-93d7-0c2f58821460",
        "parentId" : "35c3044a-5d2e-401e-8c2a-a03234a5c4d4",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "The case we dropped in TypeComparer is where the RHS is an ExprType. `=> T` was never a subtype of `T`.",
        "createdAt" : "2019-02-25T13:01:43Z",
        "updatedAt" : "2019-02-25T13:01:43Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "8355226a-e07a-4395-bb38-0a98102d9b61",
        "parentId" : "35c3044a-5d2e-401e-8c2a-a03234a5c4d4",
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Right, but if both `argType` and `formal` are `=> T`, then `argOK` used to return true but will return false now that we widen `formal`.",
        "createdAt" : "2019-02-25T13:21:07Z",
        "updatedAt" : "2019-02-25T13:21:07Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "238bc30c-8207-48c8-b798-ee7c11c6686b",
        "parentId" : "35c3044a-5d2e-401e-8c2a-a03234a5c4d4",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "I see. I believe argTypes are never ExprTypes. They might be TermRefs with an underlying ExprType. But we skip the ExprType when we do a widen on these. `lub` also does `widen`, not `widenExpr`. So I think we are good.",
        "createdAt" : "2019-02-26T16:54:53Z",
        "updatedAt" : "2019-02-26T16:54:54Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "5de8dae1b2a5e167f79ed434c23fe821a1f85cf1",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +604,608 @@   */\n  class ApplicableToTreesDirectly(methRef: TermRef, targs: List[Type], args: List[Tree], resultType: Type)(implicit ctx: Context) extends ApplicableToTrees(methRef, targs, args, resultType)(ctx) {\n    override def argOK(arg: TypedArg, formal: Type): Boolean = argType(arg, formal) <:< formal.widenExpr\n  }\n"
  },
  {
    "id" : "bcf00e0b-13f3-4d44-b9d5-17975da03de7",
    "prId" : 5846,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/5846#pullrequestreview-211090803",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2e7bdbe0-7cfd-48fb-93d7-aaf6469fdd74",
        "parentId" : null,
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "The code seems to mark a macro also for quotes. So it seems comment and code disagree. Which is right?",
        "createdAt" : "2019-03-05T15:16:46Z",
        "updatedAt" : "2019-03-07T12:35:19Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "be831e76-eecc-4459-a67e-5f28410b46c1",
        "parentId" : "2e7bdbe0-7cfd-48fb-93d7-aaf6469fdd74",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "The comment is right. We used to overapproximate and mark them all as macros which was not ideal. I added a commit fixing this.",
        "createdAt" : "2019-03-06T08:16:28Z",
        "updatedAt" : "2019-03-07T12:35:19Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      }
    ],
    "commit" : "cc3a8dd30cd322add83353b9988618e9e7e6ae3f",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +187,191 @@  }\n\n  /** 1. If we are in an inline method but not in a nested quote, mark the inline method\n   *  as a macro.\n   *"
  },
  {
    "id" : "ff2bcb1a-2310-4449-a77b-ebfed2a28e13",
    "prId" : 5371,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/5371#pullrequestreview-172992230",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3a78b57e-5f50-4f1c-919b-e9d3eda5f17d",
        "parentId" : null,
        "authorId" : "5a9cd756-9120-4d5e-ac88-e9c636084f0e",
        "body" : "What about `Byte`s and `Short`s? (and `Char`s, if they are considered numeric after all?)",
        "createdAt" : "2018-11-05T10:26:21Z",
        "updatedAt" : "2018-11-09T16:19:07Z",
        "lastEditedBy" : "5a9cd756-9120-4d5e-ac88-e9c636084f0e",
        "tags" : [
        ]
      },
      {
        "id" : "9c10fb5d-6aac-433d-85c7-a53edc172818",
        "parentId" : "3a78b57e-5f50-4f1c-919b-e9d3eda5f17d",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "These are covered under `c.convertTo(cls.typeRef) != null`",
        "createdAt" : "2018-11-08T14:46:53Z",
        "updatedAt" : "2018-11-09T16:19:07Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "c13aa580943c0cfd4ddebfdb66809d702344dcbb",
    "line" : 52,
    "diffHunk" : "@@ -1,1 +1573,1577 @@    if (cls.exists) {\n      def lossOfPrecision(n: Int): Boolean =\n        cls == defn.FloatClass && n.toFloat.toInt != n\n      var canAdapt = true\n      val ts1 = ts.mapConserve { t =>"
  },
  {
    "id" : "557291c9-3e8f-41b7-9e67-08ca8bedf001",
    "prId" : 5259,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/5259#pullrequestreview-170992528",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "abb8bfb3-281e-454a-9c82-98c88b627647",
        "parentId" : null,
        "authorId" : "6d71bb21-e402-4464-b2b1-8bdd8e068461",
        "body" : "Maybe add a comment to explain why sel can be NoType here",
        "createdAt" : "2018-11-01T16:35:47Z",
        "updatedAt" : "2018-11-02T07:28:30Z",
        "lastEditedBy" : "6d71bb21-e402-4464-b2b1-8bdd8e068461",
        "tags" : [
        ]
      },
      {
        "id" : "c089dfcd-a282-45d6-92b8-1cf91131edca",
        "parentId" : "abb8bfb3-281e-454a-9c82-98c88b627647",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "added",
        "createdAt" : "2018-11-02T07:28:37Z",
        "updatedAt" : "2018-11-02T07:28:37Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      }
    ],
    "commit" : "1745af1ca0fca2bd86dff084fa29371b8ba94597",
    "line" : 10,
    "diffHunk" : "@@ -1,1 +64,68 @@      // extractorMemberType will return NoType if this is the tail of tuple with an unknown tail \n      // such as `Int *: T` where `T <: Tuple`.\n      if (sel.exists) sel :: tupleSelectors(n + 1, tp) else Nil\n    }\n    def genTupleSelectors(n: Int, tp: Type): List[Type] = tp match {"
  },
  {
    "id" : "b714567b-d6d2-4cf2-aeda-a5ae18013844",
    "prId" : 5114,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/5114#pullrequestreview-180977884",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fee40c66-dd30-48a2-8611-f4f49c7dbfc9",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Does this really need to be a tree instead of say, a tree attachment? I'm also unclear on whether this is just an intermediate form or something that you can observe when traversing a typed tree (I see that there's code to eliminate it but I'm not sure that it covers all code paths, e.g. if there's an error somewhere, this could be problematic for example in the IDE)\r\n\r\nIf it's supposed to always be eliminated then we should have a check somewhere (in TreeChecker ?) to enforce that.",
        "createdAt" : "2018-12-02T23:34:40Z",
        "updatedAt" : "2018-12-05T21:52:21Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "3488bf7f-0fe7-443d-a35f-000af0b8c226",
        "parentId" : "fee40c66-dd30-48a2-8611-f4f49c7dbfc9",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "I chose a wrapper since that way we are sure we can't ignore it. It's supposed to be always eliminated. In any case Pickler would fail if it encountered one of these. That's also why I think we don't need to burden TreeChecker with checking this separately.",
        "createdAt" : "2018-12-03T21:03:10Z",
        "updatedAt" : "2018-12-05T21:52:21Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "49bae02f0265878818483442800c2e240cbeba5e",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +166,170 @@    if (defs != null && defs.nonEmpty) tpd.Block(defs.toList, tree) else tree\n\n  /** A wrapper indicating that its argument is an application of an extension method.\n   */\n  case class ExtMethodApply(app: Tree) extends tpd.Tree {"
  },
  {
    "id" : "0a584edb-7087-4da9-8b88-0ef4cab6ff6b",
    "prId" : 3905,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/3905#pullrequestreview-91432395",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1322e809-f0dd-42a7-828a-b7bdfc2c50ee",
        "parentId" : null,
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "From the diagnosis, the type parameter could be further constrained by patterns, thus I'm not sure if this change is the right fix. However, given that there is no test case invalidated this change, maybe we can accept the fix for now.",
        "createdAt" : "2018-01-24T22:30:52Z",
        "updatedAt" : "2018-01-24T22:37:06Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "97b0b3ce-2b51-4cdb-80dc-a4f688a16466",
        "parentId" : "1322e809-f0dd-42a7-828a-b7bdfc2c50ee",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Yes, I think it is analogous to fully instantiating the match scrutinee. In pattern matching all information flows from the scrutinee via the expected type to the pattern, never the other way round.",
        "createdAt" : "2018-01-25T07:38:52Z",
        "updatedAt" : "2018-01-25T07:38:52Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "540b01119295a04c7e29f5430064a6214d3ebfb6",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +921,925 @@          if (selType <:< unapplyArgType) {\n            unapp.println(i\"case 1 $unapplyArgType ${ctx.typerState.constraint}\")\n            fullyDefinedType(unapplyArgType, \"pattern selector\", tree.pos)\n            selType\n          } else if (isSubTypeOfParent(unapplyArgType, selType)(ctx.addMode(Mode.GADTflexible))) {"
  },
  {
    "id" : "27fef8c9-e302-48ae-b77b-dc1c6fb17744",
    "prId" : 3276,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/3276#pullrequestreview-67644018",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9e5d48d7-309c-471e-82d2-d35b7dd9725f",
        "parentId" : null,
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "I have the impression it would be easier to just scan the type parameter bounds whether a fullyDefinedType is needed and, if yes, instantiate the whole type.",
        "createdAt" : "2017-10-06T11:46:08Z",
        "updatedAt" : "2017-10-06T13:22:08Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "f49e65351f323bb9bb747230e088a703183e1ef0",
    "line" : 21,
    "diffHunk" : "@@ -1,1 +1104,1108 @@\n          val tparams = ctx.newTypeParams(alt1.symbol, tp1.paramNames, EmptyFlags, tp1.instantiateBounds)\n          isAsSpecific(alt1, tp1.instantiate(tparams.map(_.typeRef)), alt2, tp2)\n        }\n      case _ => // (3)"
  },
  {
    "id" : "b1e86eb8-2bfe-409b-ac4a-7458f2f6d800",
    "prId" : 3272,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/3272#pullrequestreview-67626150",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "71f50b88-5110-4768-9e1e-0c1aac4a9307",
        "parentId" : null,
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "I wonder whether we could optimize this so that we do the fullyDefinedType only if the type parameter bounds are non-trivial. fullyDefinedType is somewhat expensive.",
        "createdAt" : "2017-10-06T10:14:24Z",
        "updatedAt" : "2017-10-06T10:14:24Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "eb2fdf273f7305e79196477347593f7417f19eb4",
    "line" : 15,
    "diffHunk" : "@@ -1,1 +1099,1103 @@          // uninstantiated TypeVars, this could lead to cycles in `isSubType`\n          // as a TypeVar might get constrained by a TypeRef it's part of.\n          val tp1a = fullyDefinedType(tp1, \"alternative\", alt1.symbol.pos).asInstanceOf[PolyType]\n\n          val tparams = ctx.newTypeParams(alt1.symbol, tp1.paramNames, EmptyFlags, tp1a.instantiateBounds)"
  },
  {
    "id" : "c29f4199-e555-4619-8f17-2c1e171be191",
    "prId" : 3272,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/3272#pullrequestreview-67626324",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e173decc-8843-48eb-b8e6-199cc8ee29a8",
        "parentId" : null,
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "I believe we can use TyperState.test here/ It's cheaper and easier to use.",
        "createdAt" : "2017-10-06T10:15:09Z",
        "updatedAt" : "2017-10-06T10:15:09Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "eb2fdf273f7305e79196477347593f7417f19eb4",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +1091,1095 @@      case tp1: PolyType => // (2)\n        val nestedCtx = ctx.fresh.setExploreTyperState()\n\n        {\n          implicit val ctx = nestedCtx"
  },
  {
    "id" : "f2cafd5a-90ec-4bee-80a0-8beee8f437df",
    "prId" : 3061,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/3061#pullrequestreview-60927256",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "83e86f77-2a29-494d-8913-81d1ccbb912e",
        "parentId" : null,
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Complication: The `flip` hack got now slightly trickier because we can't play with TypeAlias variances anymore.",
        "createdAt" : "2017-09-06T14:21:33Z",
        "updatedAt" : "2017-09-20T15:20:34Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "2e65bd581c7506e1a382d906a9c8a961fafabfff",
    "line" : 42,
    "diffHunk" : "@@ -1,1 +1148,1152 @@          def apply(t: Type) = t match {\n            case t: TypeBounds => t\n            case t @ AppliedType(tycon, args) =>\n              def mapArg(arg: Type, tparam: TypeParamInfo) =\n                if (variance > 0 && tparam.paramVariance < 0) defn.FunctionOf(arg :: Nil, defn.UnitType)"
  },
  {
    "id" : "c8367539-44b0-4cc2-aac8-52bc742ba282",
    "prId" : 2894,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/2894#pullrequestreview-51502272",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "97d2bda9-b37f-40ac-a104-78d8cd06acb7",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Maybe add some note that implicit search and SAM conversion are tried at the same time to justify checking ImplicitsEnabled here?",
        "createdAt" : "2017-07-21T15:10:34Z",
        "updatedAt" : "2017-07-21T15:10:39Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      }
    ],
    "commit" : "5c7199b3d9344f704de3a0fc75f8cad31cb394aa",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +485,489 @@          case _ => false\n        }\n        isCompatible(argtpe, formal) || ctx.mode.is(Mode.ImplicitsEnabled) && SAMargOK\n    }\n"
  },
  {
    "id" : "a04b478b-a101-44bb-b47d-274562be615e",
    "prId" : 2079,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/2079#pullrequestreview-26650226",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "02f76b20-d5a9-4480-9e14-ec66cf072ecb",
        "parentId" : null,
        "authorId" : "70ef1594-3bb7-4579-b053-2189b409b5dc",
        "body" : "Possible performance concern: The resulting type transformer is applied below using `formals1.mapconserve(substParam)`, so we do O(|formals|^2) substitutions.\r\n\r\nIt might be worth collecting just the substitution pairs, by returning `Option[(MethodParam, Type)]` instead, and whenever we finalize an argument i, we apply all of them using `formal_i.substParam(listOfMts, listOfTps)`. This would require adding a substituter that can handle multiple ParamTypes at once (cf. [Type.substParam](https://github.com/lampepfl/dotty/blob/b3194406d8e1a28690faee12257b53f9dcf49506/compiler/src/dotty/tools/dotc/core/Types.scala#L1201)).\r\n\r\nMoreover, when adding arg#i we could avoid mapping over the first i parameters in formals1, since only parameters j > i can depend on i.",
        "createdAt" : "2017-03-13T09:56:07Z",
        "updatedAt" : "2017-03-14T14:52:59Z",
        "lastEditedBy" : "70ef1594-3bb7-4579-b053-2189b409b5dc",
        "tags" : [
        ]
      },
      {
        "id" : "86bbdd76-f1e4-4be5-902a-97dc23a54a14",
        "parentId" : "02f76b20-d5a9-4480-9e14-ec66cf072ecb",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "I am not convinced it will be a problem. First, how many methods will be `paramDependent`? Then, how long is the typical parameter list? If it is 2, then the code given is the best (just one substitution). If it is 3 or 4, not much worse. Also, note that single parameter substitutions are faster than multiple parameter ones which require a linear search anyway. So, in summary, let's wait until the profiler indicates this is a hotspot.",
        "createdAt" : "2017-03-13T19:54:03Z",
        "updatedAt" : "2017-03-14T14:52:59Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "3c22580feccca384e83465afd38d3df689c61f88",
    "line" : 20,
    "diffHunk" : "@@ -1,1 +389,393 @@            addArg(typedArg(arg, formal), formal)\n            if (methodType.isParamDependent)\n              _.substParam(MethodParam(methodType, n), typeOfArg(arg))\n            else\n              identity"
  },
  {
    "id" : "5cee2c61-2f0b-400e-98d0-1975182a68e2",
    "prId" : 1764,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/1764#pullrequestreview-11044696",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2991fb35-b5d8-4b50-81d1-261add346606",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "I'm having trouble following this explanation, could you illustrate it with an example?",
        "createdAt" : "2016-12-01T19:59:53Z",
        "updatedAt" : "2016-12-02T08:04:47Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      }
    ],
    "commit" : "76aed5e468d6e9fa2279241fe8bd7f06b2c3f4e0",
    "line" : 12,
    "diffHunk" : "@@ -1,1 +257,261 @@        // instead of being spliced in literally. Otherwise, a type argument to a default\n        // method could be constructed as the definition site of the type variable for\n        // that default constructor. This would interpolate type variables too early,\n        // causing lots of tests (among them tasty_unpickleScala2) to fail.\n        //"
  }
]
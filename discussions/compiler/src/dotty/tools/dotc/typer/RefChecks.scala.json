[
  {
    "id" : "536a784b-34c7-4e5e-98bf-57f65ac19f3b",
    "prId" : 12041,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/12041#pullrequestreview-633249074",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c2a90612-a4b8-4d3d-9270-4ea3267661ee",
        "parentId" : null,
        "authorId" : "6998ebc0-40b8-4e52-b4f8-721fd5d8c0a9",
        "body" : "It is a good idea to check this one here, I didn't do that in #11059.",
        "createdAt" : "2021-04-12T08:07:34Z",
        "updatedAt" : "2021-04-12T08:07:35Z",
        "lastEditedBy" : "6998ebc0-40b8-4e52-b4f8-721fd5d8c0a9",
        "tags" : [
        ]
      }
    ],
    "commit" : "8c2656f19efc16d82cea49083d0e1356eb30ffc3",
    "line" : 23,
    "diffHunk" : "@@ -1,1 +144,148 @@          val args = termArgss(app).flatten\n          for (param, arg) <- params.lazyZip(args) do\n            if !param.is(Private) then // its type can be narrowed through intersection -> a check is needed\n              val paramType = cls.thisType.memberInfo(param)\n              if !(arg.tpe <:< paramType) then"
  },
  {
    "id" : "13efdbfc-072d-4022-a5c6-9001fb654a7a",
    "prId" : 12041,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/12041#pullrequestreview-633250120",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8e141c7b-ac36-4795-a3b1-5e3e7d7ba4ce",
        "parentId" : null,
        "authorId" : "6998ebc0-40b8-4e52-b4f8-721fd5d8c0a9",
        "body" : "yes, it's also a better idea to walk through the constructors.",
        "createdAt" : "2021-04-12T08:08:45Z",
        "updatedAt" : "2021-04-12T08:08:45Z",
        "lastEditedBy" : "6998ebc0-40b8-4e52-b4f8-721fd5d8c0a9",
        "tags" : [
        ]
      }
    ],
    "commit" : "8c2656f19efc16d82cea49083d0e1356eb30ffc3",
    "line" : 33,
    "diffHunk" : "@@ -1,1 +154,158 @@                  report.error(IllegalParameterInit(arg.tpe, paramType, param, cls), arg.srcPos)\n\n      for case app: Apply <- parentTrees do checkParamInits(app)\n    case _ =>\n  }"
  },
  {
    "id" : "f05e76e0-32c5-4794-82ea-bc71b9f75976",
    "prId" : 11059,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/11059#pullrequestreview-565418844",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a6205a44-0e04-47b7-b4fa-e277c497b20e",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "paramAccessors contains both type and term parameters, is this actually needed for soundness or is checking types enough?",
        "createdAt" : "2021-01-11T13:58:26Z",
        "updatedAt" : "2021-03-12T15:34:04Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "49b7d7b1-6896-414f-8312-232353976d15",
        "parentId" : "a6205a44-0e04-47b7-b4fa-e277c497b20e",
        "authorId" : "6998ebc0-40b8-4e52-b4f8-721fd5d8c0a9",
        "body" : "What I try to do here is check the different types of the constructor argument from different perspectives. I am using `paramAccessors` since I saw it used in `checkParameterizedTraitsOK` above.\r\nWhen you say \"checking types enough\", which types are you referring to?",
        "createdAt" : "2021-01-11T14:06:51Z",
        "updatedAt" : "2021-03-12T15:34:04Z",
        "lastEditedBy" : "6998ebc0-40b8-4e52-b4f8-721fd5d8c0a9",
        "tags" : [
        ]
      },
      {
        "id" : "6057976b-18da-417f-98a6-634907c71f20",
        "parentId" : "a6205a44-0e04-47b7-b4fa-e277c497b20e",
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "I mean, in the Scala 2 error for https://github.com/lampepfl/dotty/issues/11018#issuecomment-756777091, we get:\r\n>  class F inherits different type instances of class C:\r\nC[Foo] and C[Bar]\r\n\r\nSo it's checking the types, not the terms.",
        "createdAt" : "2021-01-11T14:12:08Z",
        "updatedAt" : "2021-03-12T15:34:04Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "9f4197a5-6191-41ce-b7cb-24a2773ad95b",
        "parentId" : "a6205a44-0e04-47b7-b4fa-e277c497b20e",
        "authorId" : "6998ebc0-40b8-4e52-b4f8-721fd5d8c0a9",
        "body" : "Ok, I'll try to port the Scala 2 implementation as an alternative.",
        "createdAt" : "2021-01-11T14:45:03Z",
        "updatedAt" : "2021-03-12T15:34:04Z",
        "lastEditedBy" : "6998ebc0-40b8-4e52-b4f8-721fd5d8c0a9",
        "tags" : [
        ]
      }
    ],
    "commit" : "960742b3cdebb999469618779d20b73f2275161e",
    "line" : 22,
    "diffHunk" : "@@ -1,1 +813,817 @@        cls = parentSym.asClass\n        if cls.paramAccessors.nonEmpty\n        param <- cls.paramAccessors\n      } {\n        val tpeFromParent = parent.memberInfo(param)"
  },
  {
    "id" : "e1982801-0a2c-44e7-9b73-be504dd20e56",
    "prId" : 11024,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/11024#pullrequestreview-563541394",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "03c547d5-e6bc-4b48-a26d-d51b04e9307e",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Would be nice to add a comment mentioning why we're skipping in these cases",
        "createdAt" : "2021-01-07T13:27:50Z",
        "updatedAt" : "2021-01-07T14:43:19Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "ce828b03-4dae-429b-91db-0afff8e98f10",
        "parentId" : "03c547d5-e6bc-4b48-a26d-d51b04e9307e",
        "authorId" : "128563de-a925-4397-af34-450c7978a8d2",
        "body" : "I've added the comment",
        "createdAt" : "2021-01-07T14:43:35Z",
        "updatedAt" : "2021-01-07T14:43:35Z",
        "lastEditedBy" : "128563de-a925-4397-af34-450c7978a8d2",
        "tags" : [
        ]
      }
    ],
    "commit" : "b8878c8cd43ef22f50a129e3b14ec2268f0525ea",
    "line" : 25,
    "diffHunk" : "@@ -1,1 +910,914 @@     *   module that declares `sym`.\n     */\n    def skipWarning(using Context) =\n      ctx.owner.ownersIterator.exists(if sym.isEnumCase then isDeprecatedOrEnum else _.isDeprecated)\n"
  },
  {
    "id" : "e99a83f0-48b7-432a-803a-a957e45207ce",
    "prId" : 9867,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/9867#pullrequestreview-495740379",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "32d46327-1164-4936-81d1-e046c196e5db",
        "parentId" : null,
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "`then` is required after #9859 -- the benchmarks fail due to this.",
        "createdAt" : "2020-09-24T16:18:32Z",
        "updatedAt" : "2020-10-06T16:04:27Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      }
    ],
    "commit" : "4ed6a3fda0c9fe160fad6f8222575c8326f589d5",
    "line" : 18,
    "diffHunk" : "@@ -1,1 +494,498 @@        for bc <- clazz.baseClasses; sym <- bc.info.decls.toList do\n          if sym.is(DeferredTerm) && !isImplemented(sym) && !ignoreDeferred(sym) then\n            buf += sym\n        buf.toList\n"
  },
  {
    "id" : "934a4471-85b3-441b-81a2-8d58afa9dacb",
    "prId" : 9430,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/9430#pullrequestreview-463489804",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "73f2823f-7c21-4a2e-b80e-f937bf4a829f",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Isn't the nested for equivalent to doing `annotation <- param.getAnnotation(defn.ImplicitNotFoundAnnot)` in the outer for directly?",
        "createdAt" : "2020-08-07T17:28:32Z",
        "updatedAt" : "2020-08-07T17:32:24Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "05eb9e8b-b556-4801-85f0-bdaec853ae70",
        "parentId" : "73f2823f-7c21-4a2e-b80e-f937bf4a829f",
        "authorId" : "c3648f9c-c83b-4524-be18-9a1b993e0540",
        "body" : "Sadly not, because `getAnnotation` returns an option and `paramSymss` returns a `List[List[Symbol]]`",
        "createdAt" : "2020-08-07T17:39:38Z",
        "updatedAt" : "2020-08-07T17:39:38Z",
        "lastEditedBy" : "c3648f9c-c83b-4524-be18-9a1b993e0540",
        "tags" : [
        ]
      }
    ],
    "commit" : "b1779712b37f54bb138f37edaee024941a9561e8",
    "line" : 53,
    "diffHunk" : "@@ -1,1 +966,970 @@      do\n        for\n          annotation <- param.getAnnotation(defn.ImplicitNotFoundAnnot)\n          l@Literal(c: Constant) <- annotation.argument(0)\n        do forEachTypeVariableReferenceIn(c.stringValue) { case (ref, start) =>"
  },
  {
    "id" : "a0fe3cd4-0c52-40e6-89e0-dfce2d0ec640",
    "prId" : 8543,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/8543#pullrequestreview-377551543",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fe799f65-b9a2-4daa-9547-b101b74344a1",
        "parentId" : null,
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "`inline` methods should be effectively final",
        "createdAt" : "2020-03-18T15:49:10Z",
        "updatedAt" : "2020-03-19T09:37:36Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      },
      {
        "id" : "98d5a4be-7ef4-4071-b6de-ba7c9b4647e2",
        "parentId" : "fe799f65-b9a2-4daa-9547-b101b74344a1",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "We now have a separate issue to discuss & track that.\r\n",
        "createdAt" : "2020-03-19T09:31:30Z",
        "updatedAt" : "2020-03-19T09:37:36Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "453319bb133c74f49dfa2ec5752f0ac783a5dcb6",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +158,162 @@   *    1.9.1  If M is erased, O is erased. If O is erased, M is erased or inline.\n   *    1.9.2  If M or O are extension methods, they must both be extension methods.\n   *    1.10   If O is inline, M must be inline\n   *    1.11.  If O is a Scala-2 macro, M must be a Scala-2 macro.\n   *  2. Check that only abstract classes have deferred members"
  },
  {
    "id" : "11815eb1-917b-468c-ab56-565943ead802",
    "prId" : 5178,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/5178#pullrequestreview-159848848",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6548b99c-25a3-449c-8e1a-f2b7cbc0753a",
        "parentId" : null,
        "authorId" : "223e67d6-1873-432a-9af9-f40b82a7eedd",
        "body" : "Is `dealias` required?",
        "createdAt" : "2018-09-28T12:27:06Z",
        "updatedAt" : "2018-09-28T14:45:16Z",
        "lastEditedBy" : "223e67d6-1873-432a-9af9-f40b82a7eedd",
        "tags" : [
        ]
      },
      {
        "id" : "7bd0caeb-129c-46f7-9035-2906c3910a4e",
        "parentId" : "6548b99c-25a3-449c-8e1a-f2b7cbc0753a",
        "authorId" : "1a7d8f9e-77a7-44d8-8e84-72ed77060419",
        "body" : "Without it the second test still fails (crashes). If you would dealias a bit sooner I think `def foo = { type T = Foo; val a = new T; class Foo }` would also emit an error, like in scalac.",
        "createdAt" : "2018-09-28T13:02:23Z",
        "updatedAt" : "2018-09-28T14:45:16Z",
        "lastEditedBy" : "1a7d8f9e-77a7-44d8-8e84-72ed77060419",
        "tags" : [
        ]
      }
    ],
    "commit" : "91eaf201d97e5e774cea98bb43918e143fd022e3",
    "line" : 9,
    "diffHunk" : "@@ -1,1 +1015,1019 @@    checkUndesiredProperties(sym, tree.pos)\n    currentLevel.enterReference(sym, tree.pos)\n    tpe.dealias.foreachPart {\n      case TermRef(_, s: Symbol) => currentLevel.enterReference(s, tree.pos)\n      case _ =>"
  },
  {
    "id" : "b079025f-f437-4f06-96f4-9a5b400ba2ed",
    "prId" : 4013,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/4013#pullrequestreview-99670099",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f7764a3d-b34c-4851-9d87-2c632e064b2c",
        "parentId" : null,
        "authorId" : "223e67d6-1873-432a-9af9-f40b82a7eedd",
        "body" : "Why `dropWhile` and not `filter`?",
        "createdAt" : "2018-02-27T13:06:26Z",
        "updatedAt" : "2018-03-16T17:13:47Z",
        "lastEditedBy" : "223e67d6-1873-432a-9af9-f40b82a7eedd",
        "tags" : [
        ]
      }
    ],
    "commit" : "4feda4e0161c13698cf94a84d33349db55a10d60",
    "line" : 30,
    "diffHunk" : "@@ -1,1 +621,625 @@            cls.info.parents.map(_.classSymbol)\n              .filter(_.is(AbstractOrTrait))\n              .dropWhile(_.is(JavaDefined | Scala2x))\n              .foreach(addDecls)\n          }"
  },
  {
    "id" : "679f0aab-1f8c-49eb-b6f5-68a313036067",
    "prId" : 3562,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/3562#pullrequestreview-79650660",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "78e50eb1-99ed-4026-b4eb-b5ec46ac1253",
        "parentId" : null,
        "authorId" : "223e67d6-1873-432a-9af9-f40b82a7eedd",
        "body" : "Your match is not exhaustive",
        "createdAt" : "2017-11-28T20:37:10Z",
        "updatedAt" : "2017-11-28T21:30:03Z",
        "lastEditedBy" : "223e67d6-1873-432a-9af9-f40b82a7eedd",
        "tags" : [
        ]
      },
      {
        "id" : "ead71b4e-a903-4f3b-8287-8fd49f09f8c1",
        "parentId" : "78e50eb1-99ed-4026-b4eb-b5ec46ac1253",
        "authorId" : "ae84714a-b670-4382-a891-773bafb271e0",
        "body" : "Fixed.",
        "createdAt" : "2017-11-28T20:46:59Z",
        "updatedAt" : "2017-11-28T21:30:03Z",
        "lastEditedBy" : "ae84714a-b670-4382-a891-773bafb271e0",
        "tags" : [
        ]
      }
    ],
    "commit" : "435a5f9537acb8598d741f7e33316d4c39468121",
    "line" : 11,
    "diffHunk" : "@@ -1,1 +688,692 @@    val xMigrationValue = ctx.settings.Xmigration.value\n    if (sym.hasAnnotation(defn.MigrationAnnot) && xMigrationValue != NoScalaVersion) {\n      sym.migrationVersion.get match {\n        case scala.util.Success(symVersion) if xMigrationValue < symVersion=>\n          ctx.warning(SymbolChangedSemanticsInVersion(sym, symVersion), pos)"
  },
  {
    "id" : "e428e927-338b-441d-898d-8cd3662e7790",
    "prId" : 2886,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/2886#pullrequestreview-51015258",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9c708d63-3379-40f9-b136-1ab7c5feaa6a",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Why isn't `other` eta-expanded like `member`?",
        "createdAt" : "2017-07-19T15:17:38Z",
        "updatedAt" : "2017-07-19T15:17:43Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "6c7912c2-6039-44f1-9fa7-05dc708e9191",
        "parentId" : "9c708d63-3379-40f9-b136-1ab7c5feaa6a",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Other cannot be a class anyway. Classes cannot be overridden.\r\n",
        "createdAt" : "2017-07-19T19:27:52Z",
        "updatedAt" : "2017-07-19T19:27:52Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "1a6d2ec8e8f2a5d7c7903729aeee7af1c501a9cf",
    "line" : 24,
    "diffHunk" : "@@ -1,1 +200,204 @@        if (member.isClass) TypeAlias(member.typeRef.EtaExpand(member.typeParams))\n        else self.memberInfo(member)\n      def otherTp(self: Type) = self.memberInfo(other)\n\n      ctx.debuglog(\"Checking validity of %s overriding %s\".format(member.showLocated, other.showLocated))"
  },
  {
    "id" : "2bc73fc2-ed53-4154-84f0-6b254fb225ad",
    "prId" : 2580,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/2580#pullrequestreview-40796591",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "df875b08-29d6-45e1-9291-b59a449dc0ff",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "I suggest using other names than `memberTp` and `otherTp` here, because `memberTp` and `otherTp` are already in scope at this point and they could easily be confused when reading the code.",
        "createdAt" : "2017-05-29T15:34:55Z",
        "updatedAt" : "2017-05-29T15:34:55Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      }
    ],
    "commit" : "ea3b7de951669ee5f0a25dcc6923c098d2eb5d82",
    "line" : 20,
    "diffHunk" : "@@ -1,1 +247,251 @@      }\n\n      def compatibleTypes(memberTp: Type, otherTp: Type): Boolean =\n        try\n          if (member.isType) { // intersection of bounds to refined types must be nonempty"
  },
  {
    "id" : "4d6aa184-5150-48a2-8059-d69b0a3c3f85",
    "prId" : 1968,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/1968#pullrequestreview-21408806",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9914e841-284a-4290-82d3-45154a9c5c3d",
        "parentId" : null,
        "authorId" : "2dc29bea-17b2-4800-bf4f-843c62cca7de",
        "body" : "Just looking at the compressed diff here - so I can't see the reason to cut `!alt.is(Final)`",
        "createdAt" : "2017-02-12T14:07:24Z",
        "updatedAt" : "2017-02-12T15:13:53Z",
        "lastEditedBy" : "2dc29bea-17b2-4800-bf4f-843c62cca7de",
        "tags" : [
        ]
      },
      {
        "id" : "dc115bd7-34bf-4b5d-b13b-aff3f397ba33",
        "parentId" : "9914e841-284a-4290-82d3-45154a9c5c3d",
        "authorId" : "f421cd57-a5f8-43f1-ba16-5141c1a2eba1",
        "body" : "The former error message listed only non-final methods with the same name, but I think it is useful to have even final methods in the \"not eligible\" list of methods so that one can easily see it as the modifiers are included.",
        "createdAt" : "2017-02-12T14:34:45Z",
        "updatedAt" : "2017-02-12T15:13:53Z",
        "lastEditedBy" : "f421cd57-a5f8-43f1-ba16-5141c1a2eba1",
        "tags" : [
        ]
      },
      {
        "id" : "52943729-9ed0-431c-8729-69fcc99fc171",
        "parentId" : "9914e841-284a-4290-82d3-45154a9c5c3d",
        "authorId" : "2dc29bea-17b2-4800-bf4f-843c62cca7de",
        "body" : "Sure, makes sense :)",
        "createdAt" : "2017-02-12T14:36:31Z",
        "updatedAt" : "2017-02-12T15:13:53Z",
        "lastEditedBy" : "2dc29bea-17b2-4800-bf4f-843c62cca7de",
        "tags" : [
        ]
      }
    ],
    "commit" : "bed557d01532392ead135d927ac69b6b79f68221",
    "line" : 17,
    "diffHunk" : "@@ -1,1 +626,630 @@        // for (bc <- clazz.info.baseClasses.tail) Console.println(\"\" + bc + \" has \" + bc.info.decl(member.name) + \":\" + bc.info.decl(member.name).tpe);//DEBUG\n\n        val nonMatching = clazz.info.member(member.name).altsWith(alt => alt.owner != clazz)\n        nonMatching match {\n          case Nil =>"
  },
  {
    "id" : "4ca20710-db3d-4b3d-970e-2eed248bf5d5",
    "prId" : 13092,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/13092#pullrequestreview-713631898",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "cf92be88-1fe2-4574-8ed3-a780e18e7456",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "PrepJSInterop also performs some overriding checks using Cursor, so I wonder if it should use a subclass of Cursor with the same logic we're now using here in RefChecks, or perhaps the checking logic in PrepJSInterop should be moved to RefChecks? /cc @sjrd",
        "createdAt" : "2021-07-21T11:06:53Z",
        "updatedAt" : "2021-07-21T11:09:37Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "7afc967a-9285-4dcf-8cba-ea4febdd3522",
        "parentId" : "cf92be88-1fe2-4574-8ed3-a780e18e7456",
        "authorId" : "5a9cd756-9120-4d5e-ac88-e9c636084f0e",
        "body" : "It should probably be the same logic as in RefChecks, yes.",
        "createdAt" : "2021-07-21T14:16:35Z",
        "updatedAt" : "2021-07-21T14:16:35Z",
        "lastEditedBy" : "5a9cd756-9120-4d5e-ac88-e9c636084f0e",
        "tags" : [
        ]
      },
      {
        "id" : "da2d43c3-25ed-4e38-8f79-0ece9b121865",
        "parentId" : "cf92be88-1fe2-4574-8ed3-a780e18e7456",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "OK, I let you experiment with it. But I am going to merge this as is, since I do not think I have the time to look at all code that considers overriding pairs.\r\n",
        "createdAt" : "2021-07-23T11:22:55Z",
        "updatedAt" : "2021-07-23T11:22:55Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "0a77f6bb174a915ee130b46487c851af72417b45",
    "line" : 84,
    "diffHunk" : "@@ -1,1 +470,474 @@    }\n\n    val opc = new OverridingPairs.Cursor(clazz):\n      override def matches(sym1: Symbol, sym2: Symbol): Boolean =\n        isOverridingPair(sym1, sym2, self)"
  }
]
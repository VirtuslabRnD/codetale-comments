[
  {
    "id" : "aeb23865-187c-4f2d-9f3e-0e02dd2a9b23",
    "prId" : 10928,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/10928#pullrequestreview-560438138",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b628b7af-822d-4efc-83dc-a8280c59b559",
        "parentId" : null,
        "authorId" : "3a56b927-736f-4aab-8690-358cd24ca570",
        "body" : "I don't understand the logic here. It seems that we always call `checkNoModuleClash` with a module symbol. If that's the case, then shouldn't this symbol always be non-absent? Or is it that this symbol was marked absent when we added the clashing class's symbol as a member?",
        "createdAt" : "2020-12-29T09:58:09Z",
        "updatedAt" : "2020-12-29T09:58:38Z",
        "lastEditedBy" : "3a56b927-736f-4aab-8690-358cd24ca570",
        "tags" : [
        ]
      },
      {
        "id" : "1ed28d4d-1a84-49ba-843e-4ab8a430fbcf",
        "parentId" : "b628b7af-822d-4efc-83dc-a8280c59b559",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Yes, the latter. ",
        "createdAt" : "2020-12-31T15:10:47Z",
        "updatedAt" : "2020-12-31T15:10:48Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "714eb745abb45184d48d3165784313e4930c18ec",
    "line" : 9,
    "diffHunk" : "@@ -1,1 +752,756 @@  def checkNoModuleClash(sym: Symbol)(using Context): Unit =\n    if sym.effectiveOwner.is(Package)\n       && sym.owner.info.member(sym.name.moduleClassName).symbol.isAbsent()\n    then\n      val conflicting = sym.owner.info.member(sym.name.toTypeName).symbol"
  },
  {
    "id" : "ebc68404-1331-4305-bf61-bdb46719c9dd",
    "prId" : 10182,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/10182#pullrequestreview-544011708",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "63f61a25-202c-478c-880d-b4d5c0ee47fe",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Add a comment mentioning that this restriction is due to incremental compilation issues with wildcards and referring to https://github.com/sbt/zinc/issues/226",
        "createdAt" : "2020-12-02T17:30:59Z",
        "updatedAt" : "2020-12-03T15:33:07Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "48957ef5-7e72-46c2-b4f5-5cdd3e060b3c",
        "parentId" : "63f61a25-202c-478c-880d-b4d5c0ee47fe",
        "authorId" : "128563de-a925-4397-af34-450c7978a8d2",
        "body" : "added a comment",
        "createdAt" : "2020-12-03T14:32:21Z",
        "updatedAt" : "2020-12-03T15:33:07Z",
        "lastEditedBy" : "128563de-a925-4397-af34-450c7978a8d2",
        "tags" : [
        ]
      }
    ],
    "commit" : "2c6eeb2ccb328650161487df6132d8061a12bad7",
    "line" : 27,
    "diffHunk" : "@@ -1,1 +740,744 @@      // register a dependency on \"all members of a package\" - see https://github.com/sbt/zinc/issues/226\n      report.error(\n        em\"Implementation restriction: ${path.tpe.classSymbol} is not a valid prefix \" +\n          \"for a wildcard export, as it is a package.\", path.srcPos)\n"
  },
  {
    "id" : "7d1e6b62-017b-4409-a700-b6b59ec831d4",
    "prId" : 8751,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/8751#pullrequestreview-396303970",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9f01ed2d-b6f8-4a41-ada5-058d688991d6",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Maybe stripOpaque should be a boolean parameter of `givenSelfTypes` ?",
        "createdAt" : "2020-04-20T08:51:12Z",
        "updatedAt" : "2020-04-20T08:51:36Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "37d47763-9e4c-4175-a69d-57239c944181",
        "parentId" : "9f01ed2d-b6f8-4a41-ada5-058d688991d6",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "I think it's safer to keep givenSelfType as is.  It's really just when checking that we need to strip the refinements.",
        "createdAt" : "2020-04-20T09:50:14Z",
        "updatedAt" : "2020-04-20T09:50:14Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "f3f537b480626b76ffc29f5976c9da8ed9f84912",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +185,189 @@          val stp = SkolemType(tp)\n          val selfType =\n            cls.asClass.givenSelfType.stripOpaques.asSeenFrom(stp, cls)\n          if (selfType.exists && !(stp <:< selfType))\n            ctx.error(DoesNotConformToSelfTypeCantBeInstantiated(tp, selfType), posd.sourcePos)"
  },
  {
    "id" : "a1f38482-628f-4e8d-8cbc-806436b7e1b8",
    "prId" : 8187,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/8187#pullrequestreview-352932333",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fafd40b6-4ebc-48bc-b27e-e8700a67421d",
        "parentId" : null,
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "Is `butNot = JavaDefined` necessary? Maybe add a doc for that.",
        "createdAt" : "2020-02-04T12:13:40Z",
        "updatedAt" : "2020-02-04T12:13:49Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "f3377895-255e-4551-924e-84a2ffa4ba9c",
        "parentId" : "fafd40b6-4ebc-48bc-b27e-e8700a67421d",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "It is in the commit message",
        "createdAt" : "2020-02-04T12:17:50Z",
        "updatedAt" : "2020-02-04T12:17:50Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      },
      {
        "id" : "19eb42d4-2464-4109-bbe6-c829a0471b7f",
        "parentId" : "fafd40b6-4ebc-48bc-b27e-e8700a67421d",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "It is in case a method is named `$init$` in a java interface.  It should not be considered as a constructor.",
        "createdAt" : "2020-02-04T12:19:25Z",
        "updatedAt" : "2020-02-04T12:19:26Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      }
    ],
    "commit" : "864f81d2acff9128a25029f44709b2e4330fa030",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +442,446 @@      fail(CannotExtendAnyVal(sym))\n    if (sym.isConstructor && !sym.isPrimaryConstructor && sym.owner.is(Trait, butNot = JavaDefined))\n      fail(\"Traits cannot have secondary constructors \" + sym.owner.flagsString)\n    checkCombination(Final, Open)\n    checkCombination(Sealed, Open)"
  },
  {
    "id" : "095de700-8148-4fac-8236-3f6f724476c9",
    "prId" : 6493,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/6493#pullrequestreview-236376237",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "aa5a2e38-2040-4403-b9fe-73278a3f8ee2",
        "parentId" : null,
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "The previous implementation would exclude NamedTypes with prefixes that are static module classes. These are now included. Are we sure that does not present problems? If not, maybe we should keep the old and the new behavior. I.e.\r\n```\r\nvar preSym = prefix.symbol\r\nif (preSym.is(ModuleVal)) preSym = preSym.moduleClass\r\n!preSym.isStaticOwner && isInteresting(prefix.prefix)\r\n```\r\n",
        "createdAt" : "2019-05-11T08:21:36Z",
        "updatedAt" : "2019-05-11T16:26:19Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "381bd911-ee14-4fc6-9f8d-74be4825138d",
        "parentId" : "aa5a2e38-2040-4403-b9fe-73278a3f8ee2",
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Ah indeed, I was expecting `moduleClass` to just return the current denotation if it's already a moduleClass. Do you think it'd be ok to change its definition to behave that way ?",
        "createdAt" : "2019-05-11T12:48:46Z",
        "updatedAt" : "2019-05-11T16:26:19Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "644a4e67-2900-474f-a8ab-d4a47a64ce3e",
        "parentId" : "aa5a2e38-2040-4403-b9fe-73278a3f8ee2",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "I think that would also be OK. Then do the same for `sourceModule`, for symmetry.\r\n",
        "createdAt" : "2019-05-11T12:53:16Z",
        "updatedAt" : "2019-05-11T16:26:19Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "a11de49a6dd6a2cc64cef419b0db76a864bbb0fa",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +241,245 @@            case prefix: NamedType =>\n              (!sym.is(Private) && prefix.derivesFrom(sym.owner)) ||\n              (!prefix.symbol.moduleClass.isStaticOwner && isInteresting(prefix.prefix))\n            case SuperType(thistp, _) => isInteresting(thistp)\n            case AndType(tp1, tp2) => isInteresting(tp1) || isInteresting(tp2)"
  },
  {
    "id" : "fb7aaae7-3516-4dfa-8978-07ac9165238d",
    "prId" : 6389,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/6389#pullrequestreview-233930451",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "dc2db224-5150-45b2-80cd-0a8cfe2b5e4a",
        "parentId" : null,
        "authorId" : "3a56b927-736f-4aab-8690-358cd24ca570",
        "body" : "For `UnApply`, we should also check if the extractor itself is irrefutable, i.e. if it returns `Some`, or `true`, or a product. The logic to do that is in `SpaceEngine#irrefutable`.\r\n\r\nAdditionally, for some reason unapplies are simply rejected as `val` definitions:\r\n```\r\nscala> {\r\n     |   object Positive { def unapply(i: Int): Option[Int] = Some(i).filter(_ > 0) }\r\n     |   val Positive(p) = 5\r\n     |   5 match { case Positive(p) => p }\r\n     | }\r\n3 |  val Positive(p) = 5\r\n  |      ^^^^^^^^^^^\r\n  | ((i: Int): Option[Int])(Positive.unapply) is not a valid result type of an unapply method of an extractor.\r\n```",
        "createdAt" : "2019-05-06T11:26:50Z",
        "updatedAt" : "2019-05-07T11:56:16Z",
        "lastEditedBy" : "3a56b927-736f-4aab-8690-358cd24ca570",
        "tags" : [
        ]
      }
    ],
    "commit" : "80a3a67445c5be2272c8b844d982811befd00ed5",
    "line" : 51,
    "diffHunk" : "@@ -1,1 +627,631 @@            val argPts = unapplyArgs(fn.tpe.widen.finalResultType, fn, pats, pat.sourcePos)\n            pats.corresponds(argPts)(checkIrrefutable)\n          }\n        case Alternative(pats) =>\n          pats.forall(checkIrrefutable(_, pt))"
  },
  {
    "id" : "16c463a9-8a7d-48c3-8b0c-877932fc1c1e",
    "prId" : 5886,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/5886#pullrequestreview-202017884",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7c1e4df6-c2e2-419e-827d-802f66700ebc",
        "parentId" : null,
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "`symToShow` and `clsSyms` are not used.",
        "createdAt" : "2019-02-11T09:53:58Z",
        "updatedAt" : "2019-02-11T10:38:30Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      }
    ],
    "commit" : "bb8d358452091c7b2cd835a7d2bb4f9bd5515ae3",
    "line" : 45,
    "diffHunk" : "@@ -1,1 +651,655 @@        checkFeature(defn.LanguageModuleClass, nme.implicitConversions,\n          i\"Use of implicit conversion ${conv.showLocated}\", NoSymbol, posd.sourcePos)\n    }\n\n  /** Issue a feature warning if feature is not enabled */"
  },
  {
    "id" : "a7d974f4-4658-4445-ad19-0f897bfb3e30",
    "prId" : 5200,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/5200#pullrequestreview-162251617",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ba112bae-230f-4b0f-a498-cb183bbb9211",
        "parentId" : null,
        "authorId" : "6d71bb21-e402-4464-b2b1-8bdd8e068461",
        "body" : "`.owner.isStatic` is tested both here and inside the allow condition",
        "createdAt" : "2018-10-05T15:00:12Z",
        "updatedAt" : "2018-10-06T12:21:29Z",
        "lastEditedBy" : "6d71bb21-e402-4464-b2b1-8bdd8e068461",
        "tags" : [
        ]
      },
      {
        "id" : "97bcf141-90e7-42c2-9e11-fb9209f2f785",
        "parentId" : "ba112bae-230f-4b0f-a498-cb183bbb9211",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "I will remove one of them",
        "createdAt" : "2018-10-06T09:50:03Z",
        "updatedAt" : "2018-10-06T12:21:29Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      }
    ],
    "commit" : "5a363f19db37e2c23e137a51f720914427108c76",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +683,687 @@          sym.name == nme.apply && sym.is(Synthetic) && sym.owner.is(Module) && sym.owner.companionClass.is(Case)\n        def isCaseClassNew(sym: Symbol): Boolean =\n          sym.isPrimaryConstructor && sym.owner.is(Case) && sym.owner.isStatic\n        def isCaseObject(sym: Symbol): Boolean = {\n          // TODO add alias to Nil in scala package"
  },
  {
    "id" : "f15c7c4e-d17b-4d46-af84-5658f1742d07",
    "prId" : 4229,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/4229#pullrequestreview-114112740",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6b3b87e1-3d6b-4392-877d-307ec424f5c2",
        "parentId" : null,
        "authorId" : "223e67d6-1873-432a-9af9-f40b82a7eedd",
        "body" : "Why not compare `symbol` here?",
        "createdAt" : "2018-04-20T14:35:29Z",
        "updatedAt" : "2018-04-20T14:50:08Z",
        "lastEditedBy" : "223e67d6-1873-432a-9af9-f40b82a7eedd",
        "tags" : [
        ]
      },
      {
        "id" : "86199159-d16b-44c4-ae41-6df0be5b38dc",
        "parentId" : "6b3b87e1-3d6b-4392-877d-307ec424f5c2",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "We don't want to force loading the symbol.",
        "createdAt" : "2018-04-20T20:17:27Z",
        "updatedAt" : "2018-04-20T20:17:27Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "1f69d70d771b96c2923fee3400fbcd02439e15cf",
    "line" : 30,
    "diffHunk" : "@@ -1,1 +603,607 @@      sym.info.finalResultType.classSymbols.exists(_.owner.isLinkedWith(sym.owner)) ||\n      defn.isPredefClass(sym.owner) ||\n      sym.name == nme.reflectiveSelectable && sym.maybeOwner.maybeOwner.maybeOwner == defn.ScalaPackageClass\n    if (!conversionOK)\n      checkFeature(defn.LanguageModuleClass, nme.implicitConversions,"
  },
  {
    "id" : "751c350f-56a9-4ee1-aa94-18374f9ca21f",
    "prId" : 4064,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/4064#pullrequestreview-102673800",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ac64adcb-6bf3-4d18-ba34-0ccb501102f6",
        "parentId" : null,
        "authorId" : "348fab8e-49e2-442e-884d-850c7f41fdde",
        "body" : "You must not drop the info on matching type signatures. Either you preserve it or you figure out why it's there by walking `git blame` (which leads for instance to #597) and then realize you should preserve it.\r\nMethods can be overloaded, but ths code reject attempts at overloading that define methods with matching signatures.\r\n\r\nFor instance, for this code from #597 we need to explain users that this sort of overload is not allowed:\r\n\r\n```scala\r\ntrait A\r\ntrait B\r\n\r\nclass Test {\r\n  def foo(x: List[A]): Function1[A, A] = ???\r\n  def foo(x: List[B]): Function2[B, B, B] = ??? //error\r\n}\r\n```\r\n\r\nI think this code would make a good testcase.",
        "createdAt" : "2018-03-08T20:36:02Z",
        "updatedAt" : "2018-03-12T14:19:27Z",
        "lastEditedBy" : "348fab8e-49e2-442e-884d-850c7f41fdde",
        "tags" : [
        ]
      },
      {
        "id" : "090c05ab-dd11-4949-abc6-671b62d62a78",
        "parentId" : "ac64adcb-6bf3-4d18-ba34-0ccb501102f6",
        "authorId" : "8cf1c556-7dee-4b31-ab90-e6f1c39bfdeb",
        "body" : "Thank you for your feedback. If I understand correctly, the code given in #597 should not compile. I added a test case in tests/neg/, but the tests failed because it compiles successfully.",
        "createdAt" : "2018-03-09T13:42:18Z",
        "updatedAt" : "2018-03-12T14:19:27Z",
        "lastEditedBy" : "8cf1c556-7dee-4b31-ab90-e6f1c39bfdeb",
        "tags" : [
        ]
      },
      {
        "id" : "6b4a762d-3b6e-4fab-9837-3340c7432d2b",
        "parentId" : "ac64adcb-6bf3-4d18-ba34-0ccb501102f6",
        "authorId" : "348fab8e-49e2-442e-884d-850c7f41fdde",
        "body" : "Uh! I just wanted to say \"please don't remove the message\", but I should still have tried.\r\n\r\nThe behavior of `decl.matches(other)` probably changed since #597 was filed. I did more experiments and asked around to figure this out.\r\n\r\nSo, here is the current behavior:\r\n```scala\r\nscala> class Test {\r\n           def foo(x: List[A]): Function1[A, A] = ???\r\n           def foo(x: List[B]): Function1[B, B] = ??? // error\r\n         }\r\n3 |    def foo(x: List[B]): Function1[B, B] = ??? // error\r\n  |        ^\r\n  |        method foo is already defined as method foo: (x: List[A]): A => A\r\n  |        (the definitions have matching type signatures)\r\n```\r\n\r\nThat code fails because, while the overload is \"acceptable\" (you can tell at call site which one to call, I forget the right word), the two functions erase to the same \"signature\" (which here means JVM signature, according to @smarter).\r\n\r\nThe regression I was observing is that here \"the definitions have matching type signatures\" is important. I'll accept this PR as soon as that message is restored with the same check (I'm not sure why `isRealMethod` is tested, please still keep it).\r\n\r\nHere or in further PRs, we might want some clearer message there. Scalac gives:\r\n```scala\r\n<console>:15: error: double definition:\r\ndef foo(x: List[A]): A => A at line 14 and\r\ndef foo(x: List[B]): B => B at line 15\r\nhave same type after erasure: (x: List)Function1\r\n                  def foo(x: List[B]): Function1[B, B] = ??? // error\r\n```\r\n\r\nInstead, \r\n```scala\r\nclass Test {\r\n  def foo(x: List[A]): Function1[A, A] = ???\r\n  def foo(x: List[B]): Function2[B, B, B] = ??? //error\r\n}\r\n```\r\nis supported because the overload is acceptable and they erase to different JVM signatures (because of the different return types).\r\n\r\nFinally, this code is rejected because this overload isn't acceptable:\r\n```scala\r\nscala> class Test {\r\n           def foo(x: List[A]): Function1[A, A] = ???\r\n           def foo(x: List[A]): Function2[B, B, B] = ??? // error\r\n         }\r\n3 |    def foo(x: List[A]): Function2[B, B, B] = ??? // error\r\n  |        ^\r\n  |        method foo is already defined as method foo: (x: List[A]): A => A\r\n  |        (the definitions have matching type signatures)\r\n```\r\nThis should arguably give a different error:\r\n\r\n```scala\r\nscala> class Test {\r\n     |            def foo(x: List[A]): Function1[A, A] = ???\r\n     |            def foo(x: List[A]): Function2[B, B, B] = ??? // error\r\n     |          }\r\n<console>:15: error: method foo is defined twice;\r\n  the conflicting method foo was defined at line 14:16\r\n                  def foo(x: List[A]): Function2[B, B, B] = ??? // error\r\n                      ^\r\n```",
        "createdAt" : "2018-03-09T14:59:20Z",
        "updatedAt" : "2018-03-12T14:19:27Z",
        "lastEditedBy" : "348fab8e-49e2-442e-884d-850c7f41fdde",
        "tags" : [
        ]
      }
    ],
    "commit" : "e4c64b7ee3774a5867bcb6bf8d6666c655fadb00",
    "line" : 24,
    "diffHunk" : "@@ -1,1 +624,628 @@        if (decl.matches(other)) {\n          def doubleDefError(decl: Symbol, other: Symbol): Unit = {\n            ctx.error(DoubleDeclaration(decl, other), decl.pos)\n          }\n          if (decl is Synthetic) doubleDefError(other, decl)"
  },
  {
    "id" : "ea1939f8-9a5a-489c-ab05-c4865b8eab22",
    "prId" : 3061,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/3061#pullrequestreview-60931091",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "74fc5852-7e35-48cc-92bd-2a8b8bcdb3dd",
        "parentId" : null,
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Complication: checking whether parent types are feasible now also has to take into account applied type, and the fact that parent types can be conjunctions.",
        "createdAt" : "2017-09-06T14:31:15Z",
        "updatedAt" : "2017-09-20T15:20:34Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "2e65bd581c7506e1a382d906a9c8a961fafabfff",
    "line" : 129,
    "diffHunk" : "@@ -1,1 +573,577 @@  def checkFeasibleParent(tp: Type, pos: Position, where: => String = \"\")(implicit ctx: Context): Type = {\n    def checkGoodBounds(tp: Type) = tp match {\n      case tp @ TypeBounds(lo, hi) if !(lo <:< hi) =>\n        ctx.error(ex\"no type exists between low bound $lo and high bound $hi$where\", pos)\n        TypeBounds(hi, hi)"
  },
  {
    "id" : "c9b75179-1061-4f13-a10d-9d4661d49641",
    "prId" : 2476,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/2476#pullrequestreview-50191604",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "849f282d-5bf7-4ade-9a7b-a2f08057ef7e",
        "parentId" : null,
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "Why is the `!sym.is(Synthetic)` needed here? Is it only for the `lazy val` of the modules?",
        "createdAt" : "2017-07-15T15:22:44Z",
        "updatedAt" : "2017-07-15T15:22:44Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      },
      {
        "id" : "9dc88e02-0f67-4fe9-a32a-9b5bf8e99027",
        "parentId" : "849f282d-5bf7-4ade-9a7b-a2f08057ef7e",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "For now yes, but there might be other synthetic symbols with conflicts. In any case, if it is synthetic we should not issue an error message to the user.",
        "createdAt" : "2017-07-15T15:32:49Z",
        "updatedAt" : "2017-07-15T15:32:49Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "8450ec3d-70ad-4b01-a76e-19ffa821569e",
        "parentId" : "849f282d-5bf7-4ade-9a7b-a2f08057ef7e",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "Ok",
        "createdAt" : "2017-07-15T15:41:12Z",
        "updatedAt" : "2017-07-15T15:41:12Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      }
    ],
    "commit" : "8213e9624e4ea4beacaad5c014aa428f83cb2cc1",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +318,322 @@        fail(i\"illegal combination of modifiers: `$flag1` and `$flag2` for: $sym\")\n    def checkApplicable(flag: FlagSet, ok: Boolean) =\n      if (!ok && !sym.is(Synthetic))\n        fail(i\"modifier `$flag` is not allowed for this definition\")\n"
  },
  {
    "id" : "9f1cbcc3-6aed-41d9-bd2c-67285ee2dd88",
    "prId" : 2079,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/2079#pullrequestreview-26650558",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "dc380ed9-1965-47b4-9403-850309dcbb9a",
        "parentId" : null,
        "authorId" : "70ef1594-3bb7-4579-b053-2189b409b5dc",
        "body" : "I'm sure there's a good reason, but it seems that here we are duplicating the checking provided by Config.checkMethodTypes. Why do we need both?",
        "createdAt" : "2017-03-13T10:09:09Z",
        "updatedAt" : "2017-03-14T14:52:59Z",
        "lastEditedBy" : "70ef1594-3bb7-4579-b053-2189b409b5dc",
        "tags" : [
        ]
      },
      {
        "id" : "c96f1646-3985-495a-9170-b6025dab62b3",
        "parentId" : "dc380ed9-1965-47b4-9403-850309dcbb9a",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "One is a source check, the other an internal assertion that results in an exception. Not all method types are created directly from source, so the assertion is useful.",
        "createdAt" : "2017-03-13T19:55:43Z",
        "updatedAt" : "2017-03-14T14:52:59Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "3c22580feccca384e83465afd38d3df689c61f88",
    "line" : 16,
    "diffHunk" : "@@ -1,1 +629,633 @@   *  or later parameters in the same parameter section.\n   */\n  def checkNoForwardDependencies(vparams: List[ValDef])(implicit ctx: Context): Unit = vparams match {\n    case vparam :: vparams1 =>\n      val check = new TreeTraverser {"
  }
]
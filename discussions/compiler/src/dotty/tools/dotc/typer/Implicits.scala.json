[
  {
    "id" : "e8bdd435-c802-44f1-8c0e-1ce672c402f5",
    "prId" : 9998,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/9998#pullrequestreview-513857822",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9368adc7-5082-4db2-abf1-071a6c231436",
        "parentId" : null,
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "It seems the code does not handle the following cases:\r\n\r\n```Scala\r\nimplicit def implicitLength[A](implicit a: A): String => Int = _.length\r\nimplicit def implicitLength(implicit a: Dummy): String => Int = _.length\r\n```\r\n\r\nThe following snippet might be useful:\r\n\r\n```Scala\r\ntpe match {\r\n  case tp: MethodOrPoly => isOldStyleFunctionConversion(tp.finalResultType)\r\n}\r\n```\r\n\r\nIt would be good to add a test case:\r\n\r\n``` Scala\r\ndef foo()(implicit x: String => Int) = ???\r\nimplicit val f: String => Int = _.size\r\nfoo()  // no warning\r\n```\r\n\r\n",
        "createdAt" : "2020-10-21T12:08:18Z",
        "updatedAt" : "2020-10-21T15:54:08Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "f07a4e57-86e5-4001-9171-d5e05cebc272",
        "parentId" : "9368adc7-5082-4db2-abf1-071a6c231436",
        "authorId" : "5245b2da-2ff9-4276-9b2e-e1be5771149e",
        "body" : "This is indeed quite surprising but in both cases below\r\n```\r\nimplicit def implicitLength[A](implicit a: A): String => Int = _.length\r\nimplicit def implicitLength(implicit a: Dummy): String => Int = _.length\r\n```\r\n`implicitLength` does NOT work as an implicit conversion but at least this behaviour is consistent between dotty and scala 2.13\r\n\r\nRegarding\r\n```\r\ndef foo()(implicit x: String => Int) = ???\r\nimplicit val f: String => Int = _.size\r\nfoo()  // no warning\r\n```\r\nwhich use case exactly is it going to check? If it's just to verify that no waring is raised if a function is passed as an implicit parameter but it's not used as an implicit conversion then this is already covered here\r\n```\r\nobject Test8 {\r\n  implicit def a2int[A](a: A)(implicit ev: A => Int): Int = ev(a) // ok\r\n}\r\n```",
        "createdAt" : "2020-10-21T13:33:00Z",
        "updatedAt" : "2020-10-21T15:54:08Z",
        "lastEditedBy" : "5245b2da-2ff9-4276-9b2e-e1be5771149e",
        "tags" : [
        ]
      },
      {
        "id" : "4ac129e1-d3db-4ab8-ae6b-617bd6431049",
        "parentId" : "9368adc7-5082-4db2-abf1-071a6c231436",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "> implicitLength does NOT work as an implicit conversion but at least this behaviour is consistent between dotty and scala 2.13\r\n\r\nThanks, that is good to know.\r\n\r\n> which use case exactly is it going to check?\r\n\r\nIt's intended to check that an implicit function is used as an implicit argument instead of implicit conversion.",
        "createdAt" : "2020-10-21T13:55:53Z",
        "updatedAt" : "2020-10-21T15:54:08Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "da5e9106-bf18-4c39-9001-fce58907268b",
        "parentId" : "9368adc7-5082-4db2-abf1-071a6c231436",
        "authorId" : "5245b2da-2ff9-4276-9b2e-e1be5771149e",
        "body" : "ok, so this case is already covered as stated above",
        "createdAt" : "2020-10-21T13:59:06Z",
        "updatedAt" : "2020-10-21T15:54:08Z",
        "lastEditedBy" : "5245b2da-2ff9-4276-9b2e-e1be5771149e",
        "tags" : [
        ]
      },
      {
        "id" : "72ea20bf-a991-420b-b14f-4fffbf860e6a",
        "parentId" : "9368adc7-5082-4db2-abf1-071a6c231436",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "A minor issue with the coverage: in `Test8`, `ev` is used _explicitly_. The test I suggested uses it _implicitly_.",
        "createdAt" : "2020-10-21T14:01:41Z",
        "updatedAt" : "2020-10-21T15:54:08Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "71ea899a-0611-4e45-b48c-da856dff1c01",
        "parentId" : "9368adc7-5082-4db2-abf1-071a6c231436",
        "authorId" : "5245b2da-2ff9-4276-9b2e-e1be5771149e",
        "body" : "I would say in your example `ev` is finally not used at all. But I added that case anyway.",
        "createdAt" : "2020-10-21T14:10:06Z",
        "updatedAt" : "2020-10-21T15:54:08Z",
        "lastEditedBy" : "5245b2da-2ff9-4276-9b2e-e1be5771149e",
        "tags" : [
        ]
      },
      {
        "id" : "247e2e91-8ce1-4448-ac9e-dbc56d07ec6b",
        "parentId" : "9368adc7-5082-4db2-abf1-071a6c231436",
        "authorId" : "5245b2da-2ff9-4276-9b2e-e1be5771149e",
        "body" : "It turns out that `case tp: MethodOrPoly => isOldStyleFunctionConversion(tp.finalResultType)` is wrong and it caused bootstrapped tests to fail. I reverted this change and added a new test case for that.",
        "createdAt" : "2020-10-21T14:56:22Z",
        "updatedAt" : "2020-10-21T15:54:08Z",
        "lastEditedBy" : "5245b2da-2ff9-4276-9b2e-e1be5771149e",
        "tags" : [
        ]
      },
      {
        "id" : "aeb17603-3db7-4343-b8d1-4fc8922c6488",
        "parentId" : "9368adc7-5082-4db2-abf1-071a6c231436",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "It would be good to figure out the cause. What about the following test case:\r\n\r\n```Scala\r\n  implicit def mySeq2seq[A]: Seq[A] = ???\r\n  def foo(implicit ev: Seq[Int]): Unit = ???\r\n  foo\r\n```",
        "createdAt" : "2020-10-21T15:02:50Z",
        "updatedAt" : "2020-10-21T15:54:08Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "656201e7-40ec-4925-8cab-706314aabfe3",
        "parentId" : "9368adc7-5082-4db2-abf1-071a6c231436",
        "authorId" : "5245b2da-2ff9-4276-9b2e-e1be5771149e",
        "body" : "It looks like `tp.finalResultType` simply goes too far. In the test case\r\n```\r\nobject Tes14 {\r\n  case class MySeq[A](underlying: Seq[A])\r\n\r\n  implicit def mySeq2seq[A](mySeq: MySeq[A]): Seq[A] = mySeq.underlying\r\n  val s: Seq[Int] = MySeq(Seq(1, 2, 3)) // ok\r\n}\r\n```\r\n`mySeq2seq` is a method so it shouldn't be reported as deprecated conversion and in this case `case PolyType(_, resType)`, `resType` is a MethodType while `tp.finalResultType` would return the final return type of that method, which is `Seq[A]` and which happens to be a subtype of `Function1` so `isOldStyleFunctionConversion` finally returns true.\r\n\r\nThe test case you're suggesting now succeeds for both implementation variants.\r\n",
        "createdAt" : "2020-10-21T15:55:09Z",
        "updatedAt" : "2020-10-21T15:55:09Z",
        "lastEditedBy" : "5245b2da-2ff9-4276-9b2e-e1be5771149e",
        "tags" : [
        ]
      },
      {
        "id" : "50e61c64-54a8-4df8-8c87-7366141674c3",
        "parentId" : "9368adc7-5082-4db2-abf1-071a6c231436",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "Thanks, it looks good to me now.",
        "createdAt" : "2020-10-21T16:10:17Z",
        "updatedAt" : "2020-10-21T16:10:17Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      }
    ],
    "commit" : "d52332e9694256e9d5981aad6f7dab9d22d5eec0",
    "line" : 9,
    "diffHunk" : "@@ -1,1 +784,788 @@        tpe match {\n          case PolyType(_, resType) => isOldStyleFunctionConversion(resType)\n          case _ => tpe.derivesFrom(defn.FunctionClass(1)) && !tpe.derivesFrom(defn.ConversionClass) && !tpe.derivesFrom(defn.SubTypeClass)\n        }\n"
  },
  {
    "id" : "b88bce7b-d4de-4128-a912-7f81902e4d96",
    "prId" : 9747,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/9747#pullrequestreview-483879448",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "30bc67aa-c785-4efc-ad63-17ae7978d2e2",
        "parentId" : null,
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "```suggestion\r\n```",
        "createdAt" : "2020-09-08T07:50:04Z",
        "updatedAt" : "2020-09-08T07:54:02Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      }
    ],
    "commit" : "3f873ec49278e1a2ab1ee1e39d6b0a60a120c712",
    "line" : 24,
    "diffHunk" : "@@ -1,1 +318,322 @@      if (tp.hash == NotCached)\n        Stats.record(i\"compute eligible not cached ${tp.getClass}\")\n        Stats.record(i\"compute eligible not cached\")\n        computeEligible(tp)\n      else {"
  },
  {
    "id" : "476e2a74-1d1e-49c6-b576-9b34787a3847",
    "prId" : 8611,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/8611#pullrequestreview-383595359",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "aa539e90-c58f-4dee-8ed4-d57e19c21260",
        "parentId" : null,
        "authorId" : "4107dafe-4e7b-4e85-8d5b-63e06e0e6318",
        "body" : "Note that there are (and there were) no tests to exercise this code path.",
        "createdAt" : "2020-03-30T07:34:33Z",
        "updatedAt" : "2020-04-06T07:21:55Z",
        "lastEditedBy" : "4107dafe-4e7b-4e85-8d5b-63e06e0e6318",
        "tags" : [
        ]
      }
    ],
    "commit" : "d525c595c3f3e87244bed1ef4961528b98695900",
    "line" : 17,
    "diffHunk" : "@@ -1,1 +1416,1420 @@              NoMatchingImplicitsFailure\n            else\n              SearchFailure(adapted.withType(new MismatchedImplicit(ref, pt, argument)))\n        }\n      }"
  },
  {
    "id" : "da421e9e-0b19-47e9-ac69-7d121b368627",
    "prId" : 7905,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/7905#pullrequestreview-339202063",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ae659849-f2b1-49b0-974c-918c46ec812f",
        "parentId" : null,
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "Not sure if it should be instead\r\n```scala\r\nfullyDefinedType(arg.dealias.normalized, \"ValueOf argument\", span)\r\n// or\r\nfullyDefinedType(arg.normalized.dealias, \"ValueOf argument\", span)\r\n```",
        "createdAt" : "2020-01-06T17:33:55Z",
        "updatedAt" : "2020-01-06T17:33:55Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      },
      {
        "id" : "834b6444-2bd1-469b-b96b-527802c84ece",
        "parentId" : "ae659849-f2b1-49b0-974c-918c46ec812f",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "I think it's most general this way.",
        "createdAt" : "2020-01-07T12:19:47Z",
        "updatedAt" : "2020-01-07T12:19:53Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "e094ced1939ed47220c7c9812a13c645a7fea513",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +862,866 @@      formal.argTypes match {\n        case arg :: Nil =>\n          fullyDefinedType(arg.dealias, \"ValueOf argument\", span).normalized match {\n            case ConstantType(c: Constant) =>\n              success(Literal(c))"
  },
  {
    "id" : "8c2a6609-5cf7-4520-ac9d-a7f8e33670dd",
    "prId" : 7557,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/7557#pullrequestreview-318404199",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "911a46aa-c790-4a2d-bf46-605a055962d8",
        "parentId" : null,
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "Maybe make 2 vals instead of a var",
        "createdAt" : "2019-11-18T11:02:30Z",
        "updatedAt" : "2019-11-18T15:12:54Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      },
      {
        "id" : "b434cdba-b0b9-4ccf-800a-887c1676231c",
        "parentId" : "911a46aa-c790-4a2d-bf46-605a055962d8",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "I think it comes out simpler with a `var`.\r\n",
        "createdAt" : "2019-11-18T15:12:17Z",
        "updatedAt" : "2019-11-18T15:12:54Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "1e455491-28b6-4334-9f0e-7802d8c3b80f",
        "parentId" : "911a46aa-c790-4a2d-bf46-605a055962d8",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "Ok",
        "createdAt" : "2019-11-18T15:13:42Z",
        "updatedAt" : "2019-11-18T15:13:42Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      }
    ],
    "commit" : "1dcc26d57354f67a9163015aa33d64c0b94a7ea9",
    "line" : 8,
    "diffHunk" : "@@ -1,1 +1458,1462 @@      def disambiguate(alt1: SearchResult, alt2: SearchSuccess) = alt1 match\n        case alt1: SearchSuccess =>\n          var diff = compareCandidate(alt1, alt2.ref, alt2.level)\n          assert(diff <= 0)   // diff > 0 candidates should already have been eliminated in `rank`\n          "
  },
  {
    "id" : "2514c56a-0f40-4e64-864a-bd930b36f6bf",
    "prId" : 6798,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/6798#pullrequestreview-257534607",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e0c6f9fc-b873-441e-9c83-15e4b4c46ec4",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Is there a way to provide a more detailed error that would let the user know more about how the search failed?",
        "createdAt" : "2019-07-03T14:23:15Z",
        "updatedAt" : "2019-07-03T14:23:21Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "4e042230-2a0a-4061-a991-3425df5d5a7b",
        "parentId" : "e0c6f9fc-b873-441e-9c83-15e4b4c46ec4",
        "authorId" : "2c02aea2-3019-42f4-9678-8a2da637c660",
        "body" : "In principle I guess so. But it's not obvious (to me) how to do that.",
        "createdAt" : "2019-07-03T14:38:42Z",
        "updatedAt" : "2019-07-03T14:38:42Z",
        "lastEditedBy" : "2c02aea2-3019-42f4-9678-8a2da637c660",
        "tags" : [
        ]
      }
    ],
    "commit" : "d8299501aebfd971605597e5b12d55e2281e994b",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +1843,1847 @@          implicitDictionary0 = null\n          if (pruned.isEmpty) result\n          else if (pruned.exists(_._2 == EmptyTree)) NoMatchingImplicitsFailure\n          else {\n            // If there are any dictionary entries remaining after pruning, construct a dictionary"
  },
  {
    "id" : "62c53663-f71a-48ed-8911-30f3c891f64a",
    "prId" : 6531,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/6531#pullrequestreview-245293213",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0f952eba-6070-49d5-b1e1-6f2eedf85f31",
        "parentId" : null,
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "I'd rename to `elemsType` for clarity (in both branches). I used `elems` as a cue that this was a list of types, and then got confused.",
        "createdAt" : "2019-06-04T08:15:37Z",
        "updatedAt" : "2019-06-04T18:44:30Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "2afa89ce87a95ed0cb2f960ef9a98806a75c17f1",
    "line" : 255,
    "diffHunk" : "@@ -1,1 +912,916 @@              val (monoType, elemsType) = mirroredType match {\n                case mirroredType: HKTypeLambda =>\n                  val elems =\n                    mirroredType.derivedLambdaType(\n                      resType = TypeOps.nestedPairs(accessors.map(mirroredType.memberInfo(_).widenExpr))"
  },
  {
    "id" : "a976bbba-efb3-499d-b6fc-dd55b4228e1b",
    "prId" : 6531,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/6531#pullrequestreview-245293213",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0fc244f6-1f88-406d-aa70-086d2b0feeaa",
        "parentId" : null,
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Comment needs to be updated.",
        "createdAt" : "2019-06-04T08:16:34Z",
        "updatedAt" : "2019-06-04T18:44:30Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "2afa89ce87a95ed0cb2f960ef9a98806a75c17f1",
    "line" : 227,
    "diffHunk" : "@@ -1,1 +884,888 @@  /** An implied instance for a type of the form `Mirror.Product { type MirroredType = T }`\n   *  where `T` is a generic product type or a case object or an enum case.\n   */\n  lazy val synthesizedProductMirror: SpecialHandler =\n    (formal: Type, span: Span) => implicit (ctx: Context) => {"
  },
  {
    "id" : "00202b00-1a98-4393-b77f-34adabc3c437",
    "prId" : 6531,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/6531#pullrequestreview-245293213",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8db46833-f23f-4d0f-a876-8e5653cf737b",
        "parentId" : null,
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Comment needs to be updated.\r\n",
        "createdAt" : "2019-06-04T08:16:54Z",
        "updatedAt" : "2019-06-04T18:44:30Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "2afa89ce87a95ed0cb2f960ef9a98806a75c17f1",
    "line" : 286,
    "diffHunk" : "@@ -1,1 +943,947 @@\n  /** An implied instance for a type of the form `Mirror.Sum { type MirroredType = T }`\n   *  where `T` is a generic sum type.\n   */\n  lazy val synthesizedSumMirror: SpecialHandler ="
  },
  {
    "id" : "75d19853-ec31-419c-9bee-ebc896b7698b",
    "prId" : 6531,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/6531#pullrequestreview-245293213",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "98a9c191-6157-45a9-b7ca-a7d5ce1d06fa",
        "parentId" : null,
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Same comment as for `synthesizedMirror` applies here.",
        "createdAt" : "2019-06-04T08:21:52Z",
        "updatedAt" : "2019-06-04T18:44:30Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "2afa89ce87a95ed0cb2f960ef9a98806a75c17f1",
    "line" : 279,
    "diffHunk" : "@@ -1,1 +936,940 @@      }\n\n      formal.member(tpnme.MirroredType).info match {\n        case TypeBounds(mirroredType, _) => mirrorFor(mirroredType)\n        case other => EmptyTree"
  },
  {
    "id" : "9c0ce367-d275-40dc-be3d-7125b4439a47",
    "prId" : 6342,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/6342#pullrequestreview-229501198",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "28500d6f-a32b-4168-a2e2-677bfdb8866f",
        "parentId" : null,
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "I'm not sure if _implicit search_ is the best place to put the logic --- what about put the logic in typer?",
        "createdAt" : "2019-04-21T08:08:31Z",
        "updatedAt" : "2019-04-23T13:40:09Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "0ea12547-019c-48c6-bc96-c391c4394bf9",
        "parentId" : "28500d6f-a32b-4168-a2e2-677bfdb8866f",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "We detect quotes and splices when we type. The issue here is that we will do not type this tree because we create it already typed.",
        "createdAt" : "2019-04-21T08:51:53Z",
        "updatedAt" : "2019-04-23T13:40:09Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      },
      {
        "id" : "ed48eb69-f990-40ee-acce-b89ebeea65fc",
        "parentId" : "28500d6f-a32b-4168-a2e2-677bfdb8866f",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "The concern I have here is about _modularity_. It seems the added code does not belong here. Is it due to concern about performance? Modularity could be sacrificed for performance.",
        "createdAt" : "2019-04-23T11:49:37Z",
        "updatedAt" : "2019-04-23T13:40:09Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      }
    ],
    "commit" : "a35d1bcf35b629de5c9ea85b6f3a11b073f8fdec",
    "line" : 22,
    "diffHunk" : "@@ -1,1 +672,676 @@        if (StagingContext.level == 0)\n          ctx.compilationUnit.needsStaging = true // We will need to run ReifyQuotes\n        ref(defn.InternalQuoted_typeQuote).appliedToType(t)\n      }\n      formal.argInfos match {"
  },
  {
    "id" : "f5809af1-7b6c-4c4b-b5a7-e0743a3c6b49",
    "prId" : 5981,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/5981#pullrequestreview-207364618",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3a4babb7-79e0-4d97-913f-6fed614e15a8",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Same question here.",
        "createdAt" : "2019-02-25T12:26:08Z",
        "updatedAt" : "2019-02-25T12:26:12Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      }
    ],
    "commit" : "5de8dae1b2a5e167f79ed434c23fe821a1f85cf1",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +99,103 @@                  var formal = widenSingleton(mt.paramInfos.head)\n                  if (approx) formal = wildApprox(formal)\n                  ctx.test(implicit ctx => argType relaxed_<:< formal.widenExpr)\n                })\n              Candidate.Conversion"
  },
  {
    "id" : "191bef5c-855e-46c9-9884-645cfb64450e",
    "prId" : 5657,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/5657#pullrequestreview-189114193",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "69ec3b66-c707-4ba5-9e4c-c2df11ac1357",
        "parentId" : null,
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Would it make sense to combine typerState and GADT map? ",
        "createdAt" : "2018-12-29T18:25:51Z",
        "updatedAt" : "2019-01-07T13:36:52Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "c7d48a95-6c29-420f-b1a3-4df85f9556ec",
        "parentId" : "69ec3b66-c707-4ba5-9e4c-c2df11ac1357",
        "authorId" : "3a56b927-736f-4aab-8690-358cd24ca570",
        "body" : "I'm keeping my eye on it. I tried to do that, but couldn't find a clean approach. The problem is we don't want to set fresh typer state when we set fresh GADT state, and vice versa - it's really easiest if the two are separate objects. If current approach turns out to be too clumsy, I'll find a way to merge the two.",
        "createdAt" : "2019-01-03T17:46:51Z",
        "updatedAt" : "2019-01-07T13:36:52Z",
        "lastEditedBy" : "3a56b927-736f-4aab-8690-358cd24ca570",
        "tags" : [
        ]
      }
    ],
    "commit" : "e772dbb799fe25a817c395fa389a304753597d84",
    "line" : 22,
    "diffHunk" : "@@ -1,1 +1006,1010 @@          if (cand.isExtension) Applications.ExtMethodApply(generated1).withType(generated1.tpe)\n          else generated1\n        SearchSuccess(generated2, ref, cand.level)(ctx.typerState, ctx.gadt)\n      }\n    }}"
  },
  {
    "id" : "046efbea-dd5b-40e4-8006-eb945f841b98",
    "prId" : 5647,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/5647#pullrequestreview-186941043",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7909e49e-f105-4f89-8f82-6b8934786909",
        "parentId" : null,
        "authorId" : "223e67d6-1873-432a-9af9-f40b82a7eedd",
        "body" : "Isn't `Unit` handled by the `ContantType` case?",
        "createdAt" : "2018-12-19T20:47:52Z",
        "updatedAt" : "2018-12-19T20:51:41Z",
        "lastEditedBy" : "223e67d6-1873-432a-9af9-f40b82a7eedd",
        "tags" : [
        ]
      },
      {
        "id" : "6295c4f3-d68a-4ff1-a982-a82966280c6e",
        "parentId" : "7909e49e-f105-4f89-8f82-6b8934786909",
        "authorId" : "2c02aea2-3019-42f4-9678-8a2da637c660",
        "body" : "No it isn't.",
        "createdAt" : "2018-12-19T21:08:39Z",
        "updatedAt" : "2018-12-19T21:08:40Z",
        "lastEditedBy" : "2c02aea2-3019-42f4-9678-8a2da637c660",
        "tags" : [
        ]
      },
      {
        "id" : "aea4e7c2-5692-4a18-bdae-045fd7174697",
        "parentId" : "7909e49e-f105-4f89-8f82-6b8934786909",
        "authorId" : "2c02aea2-3019-42f4-9678-8a2da637c660",
        "body" : "Perhaps it should be, but currently `Unit` isn't classified as a singleton type in either Scala 2 or Dotty.",
        "createdAt" : "2018-12-20T10:17:46Z",
        "updatedAt" : "2018-12-20T10:17:46Z",
        "lastEditedBy" : "2c02aea2-3019-42f4-9678-8a2da637c660",
        "tags" : [
        ]
      },
      {
        "id" : "db026d10-a688-423c-a462-1e7ed6db0ccf",
        "parentId" : "7909e49e-f105-4f89-8f82-6b8934786909",
        "authorId" : "98bdc06d-7937-462c-9d62-1f850e7819aa",
        "body" : "It should certainly be, at least conceptually. Isn't `Unit` the singleton type _par excellence_?",
        "createdAt" : "2018-12-20T10:50:14Z",
        "updatedAt" : "2018-12-20T10:50:14Z",
        "lastEditedBy" : "98bdc06d-7937-462c-9d62-1f850e7819aa",
        "tags" : [
        ]
      }
    ],
    "commit" : "0ac9326712e9f4b9b19a3f90c3427954aee340dc",
    "line" : 16,
    "diffHunk" : "@@ -1,1 +703,707 @@              success(Literal(c))\n            case TypeRef(_, sym) if sym == defn.UnitClass =>\n              success(Literal(Constant(())))\n            case n: NamedType =>\n              success(ref(n))"
  },
  {
    "id" : "2b4c1ad0-ed0a-4cd2-9481-dacb477dc97d",
    "prId" : 5300,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/5300#pullrequestreview-167297980",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "481d679a-720c-4cfb-b042-17f746b2951e",
        "parentId" : null,
        "authorId" : "348fab8e-49e2-442e-884d-850c7f41fdde",
        "body" : "Maybe avoid recomputing tp.widen.typSymbol? Widen isn’t constant-time (and I don’t assume CSE would tell this is safe). Or is that somehow not a problem?",
        "createdAt" : "2018-10-21T01:07:35Z",
        "updatedAt" : "2018-11-08T16:16:24Z",
        "lastEditedBy" : "348fab8e-49e2-442e-884d-850c7f41fdde",
        "tags" : [
        ]
      },
      {
        "id" : "0adb6063-c83f-4788-b633-a06221a15a64",
        "parentId" : "481d679a-720c-4cfb-b042-17f746b2951e",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Good point, that's an easy win.",
        "createdAt" : "2018-10-23T08:58:49Z",
        "updatedAt" : "2018-11-08T16:16:24Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "93757f502960d527d9b8ebb6baa88dcd9fed3bc3",
    "line" : 51,
    "diffHunk" : "@@ -1,1 +485,489 @@                addRef(ref)\n            }\n            if (tp.widen.typeSymbol.isOpaqueAlias) addCompanionOf(tp.widen.typeSymbol)\n            else tp.classSymbols(liftingCtx).foreach(addClassScope)\n          case _ =>"
  },
  {
    "id" : "841c3c3d-52a8-448f-a2b4-fc26a93f450b",
    "prId" : 5029,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/5029#pullrequestreview-152194355",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "983f9bcb-74ca-4c8a-b16e-22094787d5a0",
        "parentId" : null,
        "authorId" : "223e67d6-1873-432a-9af9-f40b82a7eedd",
        "body" : "This test is pretty cheap compared to the other ones. I'm wondering if it is better moved earlier",
        "createdAt" : "2018-08-28T10:39:55Z",
        "updatedAt" : "2018-08-28T10:39:55Z",
        "lastEditedBy" : "223e67d6-1873-432a-9af9-f40b82a7eedd",
        "tags" : [
        ]
      },
      {
        "id" : "9a19dc52-852f-463d-b9ff-b8001d23d980",
        "parentId" : "983f9bcb-74ca-4c8a-b16e-22094787d5a0",
        "authorId" : "348fab8e-49e2-442e-884d-850c7f41fdde",
        "body" : "Ah, I didn't wonder about that... `Super` is also pretty rare so I'm not sure, but https://github.com/scala/scala/commit/bed3304bf86 still puts it early.",
        "createdAt" : "2018-08-28T11:39:23Z",
        "updatedAt" : "2018-08-28T11:39:33Z",
        "lastEditedBy" : "348fab8e-49e2-442e-884d-850c7f41fdde",
        "tags" : [
        ]
      },
      {
        "id" : "5f40bb00-8620-4c7a-b1b5-444244d83d5b",
        "parentId" : "983f9bcb-74ca-4c8a-b16e-22094787d5a0",
        "authorId" : "348fab8e-49e2-442e-884d-850c7f41fdde",
        "body" : "Sorry — I meant to agree on your suggestion but I'm away. I can review your PR for this change.",
        "createdAt" : "2018-09-04T18:24:23Z",
        "updatedAt" : "2018-09-04T18:24:24Z",
        "lastEditedBy" : "348fab8e-49e2-442e-884d-850c7f41fdde",
        "tags" : [
        ]
      }
    ],
    "commit" : "140e57c6dea6e33a15c56afbd8a7e119b0b7e747",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +553,557 @@        || (from.tpe isRef defn.NullClass)\n        || !(ctx.mode is Mode.ImplicitsEnabled)\n        || from.isInstanceOf[Super]\n        || (from.tpe eq NoPrefix)) NoMatchingImplicitsFailure\n    else {"
  },
  {
    "id" : "e2920b6e-f02b-4fd6-a507-3d74a039019f",
    "prId" : 4738,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/4738#pullrequestreview-133257185",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "979d7e43-bfdc-4ab8-ba68-a917ebbe7b3a",
        "parentId" : null,
        "authorId" : "223e67d6-1873-432a-9af9-f40b82a7eedd",
        "body" : "`private[this]` to avoid generating accessors?",
        "createdAt" : "2018-06-29T14:48:37Z",
        "updatedAt" : "2018-06-29T16:05:12Z",
        "lastEditedBy" : "223e67d6-1873-432a-9af9-f40b82a7eedd",
        "tags" : [
        ]
      }
    ],
    "commit" : "673af1fd7b0b99bede6c70ccade4489657e82ddb",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +72,76 @@    def refs: List[ImplicitRef]\n\n    private var SingletonClass: ClassSymbol = null\n\n    /** Widen type so that it is neither a singleton type nor a type that inherits from scala.Singleton. */"
  },
  {
    "id" : "0b97655d-ea74-4207-95f7-8953c4552306",
    "prId" : 4738,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/4738#pullrequestreview-133298548",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5edbb146-d1d0-4953-b538-c7d9ef016cc6",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Why add a cache for SingletonClass?",
        "createdAt" : "2018-06-29T15:44:38Z",
        "updatedAt" : "2018-06-29T16:05:26Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "4a5247d1-8d57-4513-a73b-a7b7aa225175",
        "parentId" : "5edbb146-d1d0-4953-b538-c7d9ef016cc6",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Same reason as for the caches in TypeComparer. It's used a lot and as a lazy val access is not super fast. It was one of the performance tweaks I applied after we saw a slip. Not sure it was the one that made the difference.",
        "createdAt" : "2018-06-29T16:42:28Z",
        "updatedAt" : "2018-06-29T16:42:28Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "673af1fd7b0b99bede6c70ccade4489657e82ddb",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +72,76 @@    def refs: List[ImplicitRef]\n\n    private var SingletonClass: ClassSymbol = null\n\n    /** Widen type so that it is neither a singleton type nor a type that inherits from scala.Singleton. */"
  },
  {
    "id" : "98062a97-1655-4342-9f8c-fc0a0866acac",
    "prId" : 4436,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/4436#pullrequestreview-119156978",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b8ea9242-6bc7-4d4f-b8ce-eca85a8d8eea",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "In `synthesizedClassTag` there's a call to `fullyDefinedType`, I wonder if we should move this around here to do this consistently for all handlers.",
        "createdAt" : "2018-05-10T16:37:28Z",
        "updatedAt" : "2018-05-10T16:37:33Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      }
    ],
    "commit" : "0e9f17e22ba756f1414e16d03bb68f2602181bbb",
    "line" : 18,
    "diffHunk" : "@@ -1,1 +656,660 @@          if (base <:< formalValue) {\n            // With the subtype test we enforce that the searched type `formalValue` is of the right form\n            handler(base).orElse(ifNot)\n          }\n          else ifNot"
  }
]
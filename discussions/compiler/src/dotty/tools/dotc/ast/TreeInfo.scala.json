[
  {
    "id" : "6c4befa5-b7f1-485a-9bf4-a7e1ea8b27d1",
    "prId" : 8852,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/8852#pullrequestreview-404514315",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d998fc56-c821-4ba2-af2a-ada97ccde687",
        "parentId" : null,
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "```suggestion\r\n    tree1.tpe.widenTermRefExpr.normalized match {\r\n```\r\n\r\nI'm wondering if it will make a difference.",
        "createdAt" : "2020-05-01T16:48:48Z",
        "updatedAt" : "2020-05-01T16:49:19Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "f29700ad-6ad3-4946-964c-9f93766a30f9",
        "parentId" : "d998fc56-c821-4ba2-af2a-ada97ccde687",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "It does not work without the dealiasing ",
        "createdAt" : "2020-05-02T06:18:25Z",
        "updatedAt" : "2020-05-02T06:18:25Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      },
      {
        "id" : "98f5c999-5c21-4e70-aa5e-27a5c286c6a5",
        "parentId" : "d998fc56-c821-4ba2-af2a-ada97ccde687",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "Maybe we should refine `normalized`.",
        "createdAt" : "2020-05-02T08:35:50Z",
        "updatedAt" : "2020-05-02T08:35:50Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "141212ac-305c-4f16-aa58-9191dd0134a0",
        "parentId" : "d998fc56-c821-4ba2-af2a-ada97ccde687",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "@OlivierBlanvillain should `normalized` dealias?",
        "createdAt" : "2020-05-02T09:32:33Z",
        "updatedAt" : "2020-05-02T09:32:34Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      }
    ],
    "commit" : "47963c3339714466e56808a292c1b44a31341c11",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +511,515 @@  def constToLiteral(tree: Tree)(implicit ctx: Context): Tree = {\n    val tree1 = ConstFold(tree)\n    tree1.tpe.widenTermRefExpr.dealias.normalized match {\n      case ConstantType(value) =>\n        if (isIdempotentExpr(tree1)) Literal(value).withSpan(tree.span)"
  },
  {
    "id" : "2823b517-90f3-4b9e-b84d-c8a5162c624f",
    "prId" : 8840,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/8840#pullrequestreview-403785112",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3748980b-7ebe-464e-b0f1-376a32841fcb",
        "parentId" : null,
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "For later: maybe we should call `.normalized`, as `dealias` is just one of many possible normalization operations on types.",
        "createdAt" : "2020-04-30T18:18:46Z",
        "updatedAt" : "2020-04-30T18:22:12Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "d4376cbc-3a0d-490e-9c56-7e69cab25c69",
        "parentId" : "3748980b-7ebe-464e-b0f1-376a32841fcb",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "Yes, I have that in #8843. But when I tried to normalize it here it did not work. Maybe I need to deeply dealias and then normalize.",
        "createdAt" : "2020-04-30T18:45:03Z",
        "updatedAt" : "2020-04-30T18:45:04Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      }
    ],
    "commit" : "8b23e2ba38ecaf4284dc4ebfe66e948e6a481965",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +511,515 @@  def constToLiteral(tree: Tree)(implicit ctx: Context): Tree = {\n    val tree1 = ConstFold(tree)\n    tree1.tpe.widenTermRefExpr.dealias match {\n      case ConstantType(value) =>\n        if (isIdempotentExpr(tree1)) Literal(value).withSpan(tree.span)"
  },
  {
    "id" : "c22d2084-b7ee-4c3f-a852-d94a70a3537a",
    "prId" : 7789,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/7789#pullrequestreview-350954251",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "02a2b780-db42-4949-abca-30f5ac931ac6",
        "parentId" : null,
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "@nicolasstucki : I changed this extractor, as some anonymous functions do not use the name `nme.ANON_FUN`.",
        "createdAt" : "2020-01-28T14:01:54Z",
        "updatedAt" : "2020-02-13T13:59:50Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "4eb58ee0-640f-4e3a-8ff1-468a3821faa4",
        "parentId" : "02a2b780-db42-4949-abca-30f5ac931ac6",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "That looks good",
        "createdAt" : "2020-01-30T16:18:48Z",
        "updatedAt" : "2020-02-13T13:59:50Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      }
    ],
    "commit" : "6a4d06a40b13b72ae3468486d1c2d916400dea8e",
    "line" : 8,
    "diffHunk" : "@@ -1,1 +634,638 @@        Some(meth)\n      case Block(Nil, expr) =>\n        unapply(expr)\n      case Inlined(_, bindings, expr) if bindings.forall(isPureBinding) =>\n        unapply(expr)"
  },
  {
    "id" : "1694156e-8e99-4aae-9d47-ca87f89ccf2b",
    "prId" : 6599,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/6599#pullrequestreview-245873840",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6f14b7b4-8961-4cb6-a903-a0a4f1cda90b",
        "parentId" : null,
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "It would be good if we could find a more systematic way to do this. Ideally, we could mark `typeQuote` to be a pure function. We have a flag for that (it's `StableRealizable`), but so far this cannot be set from source. \r\n\r\nMaybe leave a TODO that we should do the change.\r\n",
        "createdAt" : "2019-06-05T07:47:26Z",
        "updatedAt" : "2019-06-05T08:40:06Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "a8606d68-5e9f-4dc8-89d7-8460a0792d6c",
        "parentId" : "6f14b7b4-8961-4cb6-a903-a0a4f1cda90b",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "Should we have some internal flag to mark those methods?",
        "createdAt" : "2019-06-05T08:39:34Z",
        "updatedAt" : "2019-06-05T08:40:06Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      }
    ],
    "commit" : "2b36c217fa7bb60208f26451e663acd3b3d2d554",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +389,393 @@      Pure\n    case TypeApply(fn, _) =>\n      if (fn.symbol.is(Erased) || fn.symbol == defn.InternalQuoted_typeQuote) Pure else exprPurity(fn)\n    case Apply(fn, args) =>\n      def isKnownPureOp(sym: Symbol) ="
  },
  {
    "id" : "a1119cf5-111e-46dd-9209-f6a046259134",
    "prId" : 6377,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/6377#pullrequestreview-231256979",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "503af859-ecfb-4d77-a617-2f83c78fcf69",
        "parentId" : null,
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "This change in the semantics of `x` deserves some documentation.",
        "createdAt" : "2019-04-26T16:48:33Z",
        "updatedAt" : "2019-04-27T13:29:21Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      }
    ],
    "commit" : "b9d8a2ac1f2ab5fbcaa84405376b7039490ffe19",
    "line" : 113,
    "diffHunk" : "@@ -1,1 +852,856 @@  class PurityLevel(val x: Int) extends AnyVal {\n    /** `this` contains the bits of `that` */\n    def >= (that: PurityLevel): Boolean = (x & that.x) == that.x\n\n    /** The intersection of the bits of `this` and `that` */"
  },
  {
    "id" : "8c4e7dc1-23e2-4364-bab4-2c77ae9cf090",
    "prId" : 5479,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/5479#pullrequestreview-177341833",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4853ceb4-7008-4d86-ba61-44b09a702e52",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "How do we know that this a primitive unary operator and not a user-defined one here ?",
        "createdAt" : "2018-11-21T16:11:25Z",
        "updatedAt" : "2018-11-21T20:21:22Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "29a36d0e-46e8-4f4d-86ef-7d23be62f1ae",
        "parentId" : "4853ceb4-7008-4d86-ba61-44b09a702e52",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "A user defined operator would not have a `ConstantType` as a type. The test contains that case.",
        "createdAt" : "2018-11-21T16:57:24Z",
        "updatedAt" : "2018-11-21T20:21:22Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "67012361b9bb99d21d95f8aa7aa11d7267056147",
    "line" : 30,
    "diffHunk" : "@@ -1,1 +502,506 @@        else tree1 match {\n          case Select(qual, _) if tree1.tpe.isInstanceOf[ConstantType] =>\n            // it's a primitive unary operator; Simplify `pre.op` to `{ pre; v }` where `v` is the value of `pre.op`\n            Block(qual :: Nil, Literal(value))\n          case _ =>"
  },
  {
    "id" : "cfe5999e-b79a-4887-9f2c-93ec5b5336a4",
    "prId" : 4616,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/4616#pullrequestreview-139254885",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1a4e7a49-82e1-447c-92ea-8e89c1de0307",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "This looks like a less complete version of what `tpd.desugarIdentPrefix` does",
        "createdAt" : "2018-07-20T22:19:33Z",
        "updatedAt" : "2018-07-26T14:54:44Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "eda0e1f3-7446-49c0-a571-2ff470ad4db1",
        "parentId" : "1a4e7a49-82e1-447c-92ea-8e89c1de0307",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Good point. ",
        "createdAt" : "2018-07-21T10:25:54Z",
        "updatedAt" : "2018-07-26T14:54:44Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "88e7d180574eda8a71037d1735ac6a3ff76a1c08",
    "line" : 70,
    "diffHunk" : "@@ -1,1 +711,715 @@    }\n\n  /** The qualifier part of a Select or Ident.\n   *  For an Ident, this is the `This` of the current class.\n   */"
  },
  {
    "id" : "dac64533-7ea3-44a2-a61c-e898335cead2",
    "prId" : 3839,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/3839#pullrequestreview-93675340",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3631a5d4-fe2d-44c9-9e81-d9115974b08c",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "How come a Closure is considered a PurePath? It can contain local definitions.",
        "createdAt" : "2018-02-01T19:38:51Z",
        "updatedAt" : "2018-02-02T21:08:22Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "86f18d75-6446-4cdc-8af9-4267069b4be4",
        "parentId" : "3631a5d4-fe2d-44c9-9e81-d9115974b08c",
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "ah no it doesn't, nevermind.",
        "createdAt" : "2018-02-02T16:25:34Z",
        "updatedAt" : "2018-02-02T21:08:22Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      }
    ],
    "commit" : "b1908a0245290ad7646435a3a20e17d35ac4ba3b",
    "line" : 39,
    "diffHunk" : "@@ -1,1 +346,350 @@       | Super(_, _)\n       | Literal(_)\n       | Closure(_, _, _) =>\n      SimplyPure\n    case Ident(_) =>"
  },
  {
    "id" : "a927619f-0ae8-411a-a4da-4313432cbddd",
    "prId" : 3143,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/3143#pullrequestreview-90562666",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "37a6fd64-091a-4e41-b33f-5412791e097c",
        "parentId" : null,
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "I don't understand the change. Can you give an example where this matters?",
        "createdAt" : "2017-10-07T16:25:31Z",
        "updatedAt" : "2018-02-12T13:01:53Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "e2bb9e4e-2045-4939-bdc7-2048ccdcd56d",
        "parentId" : "37a6fd64-091a-4e41-b33f-5412791e097c",
        "authorId" : "6d71bb21-e402-4464-b2b1-8bdd8e068461",
        "body" : "The test added in the same commit (e199fc838e8c437c6cf88b7f27bbb6f350ed3bb2) breaks with a match error before the change",
        "createdAt" : "2018-01-18T11:13:15Z",
        "updatedAt" : "2018-02-12T13:01:53Z",
        "lastEditedBy" : "6d71bb21-e402-4464-b2b1-8bdd8e068461",
        "tags" : [
        ]
      },
      {
        "id" : "2a957579-75c6-4f43-bdf3-095b4f982917",
        "parentId" : "37a6fd64-091a-4e41-b33f-5412791e097c",
        "authorId" : "223e67d6-1873-432a-9af9-f40b82a7eedd",
        "body" : "I think it would be much more efficient to implement this methods as:\r\n```scala\r\n  def decomposeCall(tree: Tree): (Tree, List[Tree], List[List[Tree]]) = {\r\n    @tailrec def loop(tree: Tree, targs: List[Tree], argss: List[List[Tree]]): (Tree, List[Tree], List[List[Tree]]) =\r\n      tree match {\r\n        case Apply(fn, args) =>\r\n          loop(fn, targs, args :: argss)\r\n        case TypeApply(fn, targs) =>\r\n          loop(fn, targs, argss)\r\n        case _ =>\r\n          (tree, targs, argss)\r\n      }\r\n    loop(tree, Nil, Nil)\r\n  }\r\n```",
        "createdAt" : "2018-01-22T17:45:41Z",
        "updatedAt" : "2018-02-12T13:01:53Z",
        "lastEditedBy" : "223e67d6-1873-432a-9af9-f40b82a7eedd",
        "tags" : [
        ]
      }
    ],
    "commit" : "66874ed79d01fddb1a36861945a28efdcd02e292",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +520,524 @@      (meth, targs, argss :+ args)\n    case TypeApply(fn, targs) =>\n      val (meth, targss, args) = decomposeCall(fn)\n      (meth, targs ++ targss, args)\n    case _ =>"
  },
  {
    "id" : "a6a0d12e-9c06-44ce-ba59-1f8e8d2ee683",
    "prId" : 2875,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/2875#pullrequestreview-50224246",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a6381a91-1074-45ff-bacf-0e7ee3d87f76",
        "parentId" : null,
        "authorId" : "98bdc06d-7937-462c-9d62-1f850e7819aa",
        "body" : "Am I correct in assuming that if an intersection type has a component `C` that has a (non-structural) member `f` then a selection of `.f` on a value of that type will have its symbol filled in before `isStructuralTermSelect` is called? \r\nThus the condition `!tree.symbol.exists` below will not be satisfied, and we will not be issuing unnecessary structural selections. This is even if the type intersection also has a structural type containing a field `f` (on the other hand it seems like such types are consistently converted into refinements on `C`, e.g. `C & {f:A}` is represented as `C{f:A}` or just `C` if `C#f =:= A`).",
        "createdAt" : "2017-07-17T00:01:50Z",
        "updatedAt" : "2017-07-17T00:02:21Z",
        "lastEditedBy" : "98bdc06d-7937-462c-9d62-1f850e7819aa",
        "tags" : [
        ]
      }
    ],
    "commit" : "a5d40982b485e1e425407e623f5754cc11125379",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +660,664 @@        case tp: TypeProxy =>\n          hasRefinement(tp.underlying)\n        case tp: AndOrType =>\n          hasRefinement(tp.tp1) || hasRefinement(tp.tp2)\n        case _ =>"
  },
  {
    "id" : "b75c764a-5053-4a49-b88a-9cda455022fa",
    "prId" : 2829,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/2829#pullrequestreview-48826541",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5ea2e051-f6d9-48ac-9a2b-51a33977c634",
        "parentId" : null,
        "authorId" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "body" : "A lot of code in Dotty has a habbit of needlessly wrapping code in Block(Nil, expr).\r\nIt would be nice to add a case here that handles blocks to make it more robust.",
        "createdAt" : "2017-07-10T07:41:23Z",
        "updatedAt" : "2017-07-10T11:35:59Z",
        "lastEditedBy" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "tags" : [
        ]
      }
    ],
    "commit" : "79493df1783147905c7f6a4507d53183363071ac",
    "line" : 20,
    "diffHunk" : "@@ -1,1 +680,684 @@      case (TypeApply(f1, ts1), TypeApply(f2, ts2)) =>\n        f1 === f2 && ts1.tpes.corresponds(ts2.tpes)(_ =:= _)\n      case _ =>\n        false\n    }"
  },
  {
    "id" : "0051472f-84b1-47b9-b4ae-2902f657d5f4",
    "prId" : 2829,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/2829#pullrequestreview-48826541",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "02993ef4-69dd-414e-868d-a156c823138d",
        "parentId" : null,
        "authorId" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "body" : "Dead code?",
        "createdAt" : "2017-07-10T07:43:12Z",
        "updatedAt" : "2017-07-10T11:35:59Z",
        "lastEditedBy" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "tags" : [
        ]
      }
    ],
    "commit" : "79493df1783147905c7f6a4507d53183363071ac",
    "line" : 23,
    "diffHunk" : "@@ -1,1 +683,687 @@        false\n    }\n    def hash(implicit ctx: Context): Int =\n      t1.getClass.hashCode * 37 + {\n        t1 match {"
  },
  {
    "id" : "dc606a6b-45fe-4366-bee5-ed1e232c1724",
    "prId" : 1881,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/1881#pullrequestreview-15615116",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ef7a0173-14a5-47d5-9f40-09a966ae9e46",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Aren't we mixing up the body of `OrType` and `AndType` here? To select `foo`, `foo` needs to be present in both sides of an `OrType`, but only one side of an `AndType`. In any case, we need some testcases for structural type selection on union/intersection types",
        "createdAt" : "2017-01-07T14:05:52Z",
        "updatedAt" : "2017-01-28T06:13:15Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "36fa51e1-e065-4b7f-997b-ed51c7b7f57d",
        "parentId" : "ef7a0173-14a5-47d5-9f40-09a966ae9e46",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "It needs to be present on both sides, but one side might be a regular class member. As long as one side comes from a refinement, the access is reflection based. For an AndType, it's the other way round. A single class member on one side is sufficient for regular access.",
        "createdAt" : "2017-01-07T23:55:29Z",
        "updatedAt" : "2017-01-28T06:13:15Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "e1f4157a-1894-4c11-b267-c7b261208ea0",
        "parentId" : "ef7a0173-14a5-47d5-9f40-09a966ae9e46",
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Ah, I see! The `AndType` case makes sense, the `OrType` case seems suspicious but I don't think it matters since we no longer allow calling a method on a union type that matches more than one symbol, e.g. the following doesn't compile:\r\n```scala\r\nclass Closeable {\r\n  def close(): Unit = {}\r\n}\r\n\r\n\r\nobject Test {\r\n  import scala.reflect.Selectable.reflectiveSelectable\r\n\r\n  def f(closeable: (Selectable { def close(): Unit }) | Closeable) =\r\n    closeable.close() // error: value `close` is not a member of (Selectable{close: ()Unit} | Closeable)(closeable)\r\n\r\n  def main(args: Array[String]): Unit = {\r\n    f(new Closeable)\r\n  }\r\n}\r\n```",
        "createdAt" : "2017-01-08T00:36:03Z",
        "updatedAt" : "2017-01-28T06:13:15Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      }
    ],
    "commit" : "678e8e47b630786df7548c1be5bee744342f826c",
    "line" : null,
    "diffHunk" : "@@ -1,1 +642,646 @@          hasRefinement(tp.underlying)\n        case tp: OrType =>\n          hasRefinement(tp.tp1) || hasRefinement(tp.tp2)\n        case tp: AndType =>\n          hasRefinement(tp.tp1) && hasRefinement(tp.tp2)"
  }
]
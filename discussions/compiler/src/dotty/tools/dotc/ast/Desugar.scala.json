[
  {
    "id" : "a033cef7-9d4f-46b7-b0e2-8f6d75b93909",
    "prId" : 11691,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/11691#pullrequestreview-612726317",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "326dec0f-41fa-46c5-a3bd-a24254121963",
        "parentId" : null,
        "authorId" : "128563de-a925-4397-af34-450c7978a8d2",
        "body" : "so instead of just swapping `(c: C)(using D)` with `(f: F)` we now swap `(c: C)(using D)` with `[E](f: F)`",
        "createdAt" : "2021-03-15T23:06:18Z",
        "updatedAt" : "2021-03-24T23:59:38Z",
        "lastEditedBy" : "128563de-a925-4397-af34-450c7978a8d2",
        "tags" : [
        ]
      }
    ],
    "commit" : "8505258eb8a522c000641a1807519435c600be08",
    "line" : 36,
    "diffHunk" : "@@ -1,1 +923,927 @@                        //     def %:[E](f: F)(g: G)(using H): Res = ???\n                        // will be encoded as\n                        //   def %:[A](using B)[E](f: F)(c: C)(using D)(g: G)(using H): Res = ???\n                        val (leadingUsing, otherExtParamss) = ext.paramss.span(isUsingOrTypeParamClause)\n                        leadingUsing ::: typaramss ::: params :: otherExtParamss ::: paramss1"
  },
  {
    "id" : "f4d594aa-ddc9-43e6-b5a3-77afdf256199",
    "prId" : 11623,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/11623#pullrequestreview-609644775",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3d1597f6-9d75-4d99-80c3-9bd9a27b3d7a",
        "parentId" : null,
        "authorId" : "128563de-a925-4397-af34-450c7978a8d2",
        "body" : "This leads to the situation where context bound on the leading extension clause desugars to a `using` param clause but on the extension method params desugars to an `implicit` param clause, this seems inconsistent to me.\r\n```scala\r\ntrait SemiGroup[T]:\r\n   extension [U: Conv[T]](x: U) // using ev: Conv[T]\r\n     def combine(y: T): T\r\n   extension (x: T)\r\n     def combine[U: Conv[T]](y: U): T  // implicit ev: Conv[T]\r\n```",
        "createdAt" : "2021-03-09T16:32:15Z",
        "updatedAt" : "2021-03-13T19:13:25Z",
        "lastEditedBy" : "128563de-a925-4397-af34-450c7978a8d2",
        "tags" : [
        ]
      },
      {
        "id" : "6364aecf-9acb-4a08-aacd-bbd114be08fa",
        "parentId" : "3d1597f6-9d75-4d99-80c3-9bd9a27b3d7a",
        "authorId" : "9a3f8e63-8dbd-4a0a-b77c-7b305ed895f1",
        "body" : "My first move was to use `using` for both, but I thought keeping `implicit` wherever possible might be better for compatibility. I have to use `using` at least in the extension clause, because the \"resugaring\" checks for it specifically, see https://github.com/lampepfl/dotty/blob/master/compiler/src/dotty/tools/dotc/printing/RefinedPrinter.scala#L822",
        "createdAt" : "2021-03-10T10:21:43Z",
        "updatedAt" : "2021-03-13T19:13:25Z",
        "lastEditedBy" : "9a3f8e63-8dbd-4a0a-b77c-7b305ed895f1",
        "tags" : [
        ]
      },
      {
        "id" : "3a737c89-458b-4193-9236-f446ce6b91d0",
        "parentId" : "3d1597f6-9d75-4d99-80c3-9bd9a27b3d7a",
        "authorId" : "f7c6b5d4-6d93-4f3d-b583-a110d7a49c7d",
        "body" : "I think in principle, while somewhat inconsistent, it's justifiable to use `using` in extension clauses instead of `implicit` because extensions are a new syntactic construct - there is no \"migrating\" Scala 2 code using them by definition, as such there are no compatibility concerns that could force desugaring to `implicit` instead of immediately to `using`.",
        "createdAt" : "2021-03-10T10:29:14Z",
        "updatedAt" : "2021-03-13T19:13:25Z",
        "lastEditedBy" : "f7c6b5d4-6d93-4f3d-b583-a110d7a49c7d",
        "tags" : [
        ]
      },
      {
        "id" : "1db2276d-689c-4fd7-9983-6f7dac5b4c16",
        "parentId" : "3d1597f6-9d75-4d99-80c3-9bd9a27b3d7a",
        "authorId" : "9a3f8e63-8dbd-4a0a-b77c-7b305ed895f1",
        "body" : "That was indeed my reasoning.",
        "createdAt" : "2021-03-10T11:02:43Z",
        "updatedAt" : "2021-03-13T19:13:25Z",
        "lastEditedBy" : "9a3f8e63-8dbd-4a0a-b77c-7b305ed895f1",
        "tags" : [
        ]
      },
      {
        "id" : "fcb1ac27-9dcb-45e5-8824-ad44af1d2a12",
        "parentId" : "3d1597f6-9d75-4d99-80c3-9bd9a27b3d7a",
        "authorId" : "128563de-a925-4397-af34-450c7978a8d2",
        "body" : "Yes it does appear that the parser explicitly forbids `implicit` parameters in the first parameter clauses of an extension, so this makes sense",
        "createdAt" : "2021-03-11T11:10:34Z",
        "updatedAt" : "2021-03-13T19:13:25Z",
        "lastEditedBy" : "128563de-a925-4397-af34-450c7978a8d2",
        "tags" : [
        ]
      }
    ],
    "commit" : "137630239f034a05faa08e2c25045d4df5217558",
    "line" : 32,
    "diffHunk" : "@@ -1,1 +244,248 @@    def desugarContextBounds(rhs: Tree): Tree = rhs match\n      case ContextBounds(tbounds, cxbounds) =>\n        val iflag = if ext || sourceVersion.isAtLeast(`future`) then Given else Implicit\n        evidenceParamBuf ++= makeImplicitParameters(\n          cxbounds, iflag, forPrimaryConstructor = isPrimaryConstructor)"
  },
  {
    "id" : "44bbf176-0823-49c5-b7a9-c69adf789537",
    "prId" : 9836,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/9836#pullrequestreview-501525097",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2d77f41a-d166-4efe-a7ca-68ec78aaa38f",
        "parentId" : null,
        "authorId" : "84d43def-b94c-4bc7-8d6b-73a77265c3a8",
        "body" : "@bishabosha Moved the method name check here (that disallows extension method definitions starting with `extension_`), instead of its original place in `normalizeName`. The reason is that originally the warning was a bit misleading:\r\n* before\r\n```\r\n8 |extension (x: Any) def extension_foo: String = \"foo\" // error: illegal name: extension_foo may not start with `extension_`\r\n  |                       ^^^^^^^^^^^^^\r\n  |                       illegal name: extension_extension_foo may not start with `extension_`\r\n```\r\n* after:\r\n```\r\n8 |extension (x: Any) def extension_foo: String = \"foo\" // error: illegal name: extension_foo may not start with `extension_`\r\n  |                       ^^^^^^^^^^^^^\r\n  |                       illegal name: extension_foo may not start with `extension_`\r\n```",
        "createdAt" : "2020-10-03T06:28:58Z",
        "updatedAt" : "2020-10-14T19:28:53Z",
        "lastEditedBy" : "84d43def-b94c-4bc7-8d6b-73a77265c3a8",
        "tags" : [
        ]
      }
    ],
    "commit" : "341afb3d034ce95e1f3a9e8e1de93f791a0a3671",
    "line" : 57,
    "diffHunk" : "@@ -1,1 +896,900 @@      defDef(\n        cpy.DefDef(mdef)(\n          name = normalizeName(mdef, ext).toExtensionName,\n          tparams = ext.tparams ++ mdef.tparams,\n          vparamss = mdef.vparamss match"
  },
  {
    "id" : "6d82bcc1-bb77-4fab-ae0c-33606eb0ca65",
    "prId" : 9836,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/9836#pullrequestreview-508192606",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "41f6f543-ddbc-4f99-8940-3e22feda3e21",
        "parentId" : null,
        "authorId" : "128563de-a925-4397-af34-450c7978a8d2",
        "body" : "perhaps `isSetterNeeded` could be a default parameter for `normalizeName` to avoid calling it twice, and then swap the conditions in the Valdef branch (`case vdef: ValDef if isSetterNeeded && name.isExtension`), but if the performance isn't impacted that much this is minor",
        "createdAt" : "2020-10-14T08:47:50Z",
        "updatedAt" : "2020-10-14T19:28:53Z",
        "lastEditedBy" : "128563de-a925-4397-af34-450c7978a8d2",
        "tags" : [
        ]
      },
      {
        "id" : "3cbb4180-c6ac-4769-9123-0180fcb2fd1a",
        "parentId" : "41f6f543-ddbc-4f99-8940-3e22feda3e21",
        "authorId" : "84d43def-b94c-4bc7-8d6b-73a77265c3a8",
        "body" : "Yes, I considered that as well, but decided against it in order not to particularize the arg list of `normalizeName` with a param that is relevant to one branch. The second call would happen only if the `valDef`'s name is `extension`, so I would expect it to be highly exceptional",
        "createdAt" : "2020-10-14T10:07:11Z",
        "updatedAt" : "2020-10-14T19:28:53Z",
        "lastEditedBy" : "84d43def-b94c-4bc7-8d6b-73a77265c3a8",
        "tags" : [
        ]
      }
    ],
    "commit" : "341afb3d034ce95e1f3a9e8e1de93f791a0a3671",
    "line" : 37,
    "diffHunk" : "@@ -1,1 +171,175 @@    val mods = vdef.mods\n\n    val valName = normalizeName(vdef, tpt).asTermName\n\n    if (isSetterNeeded(vdef)) {"
  },
  {
    "id" : "47d80b2d-6748-418d-a067-d0ebd4dffb46",
    "prId" : 9709,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/9709#pullrequestreview-484948712",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8bf7729e-1b72-4b4b-a19d-b6ae2580da23",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "For consistency, we should probably set Synthetic on the other derivedTypeParam and on derivedTermParam assuming that doesn't break things.",
        "createdAt" : "2020-09-07T18:28:04Z",
        "updatedAt" : "2020-09-07T18:39:26Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "db5e8e2e-1688-43cf-b269-624e848dd5ec",
        "parentId" : "8bf7729e-1b72-4b4b-a19d-b6ae2580da23",
        "authorId" : "128563de-a925-4397-af34-450c7978a8d2",
        "body" : "If I add synthetic flag in derivedTermParam it changes the positions in this test: https://github.com/lampepfl/dotty/blob/ce48f5a2c79373f8a33ced1d251de0206ed5cba9/language-server/test/dotty/tools/languageserver/DefinitionTest.scala#L182",
        "createdAt" : "2020-09-08T14:40:56Z",
        "updatedAt" : "2020-09-08T14:40:57Z",
        "lastEditedBy" : "128563de-a925-4397-af34-450c7978a8d2",
        "tags" : [
        ]
      },
      {
        "id" : "b0dd5eee-1c35-4fa2-954b-79962685940c",
        "parentId" : "8bf7729e-1b72-4b4b-a19d-b6ae2580da23",
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "yeah so maybe it's not worth it, what does it change the position to?",
        "createdAt" : "2020-09-08T14:43:29Z",
        "updatedAt" : "2020-09-08T14:43:29Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "df48c897-4081-45a4-b23d-f95c6e7c9d8f",
        "parentId" : "8bf7729e-1b72-4b4b-a19d-b6ae2580da23",
        "authorId" : "128563de-a925-4397-af34-450c7978a8d2",
        "body" : "from line 0-15:16 to line 0-11:14",
        "createdAt" : "2020-09-08T15:03:36Z",
        "updatedAt" : "2020-09-08T15:03:36Z",
        "lastEditedBy" : "128563de-a925-4397-af34-450c7978a8d2",
        "tags" : [
        ]
      },
      {
        "id" : "5e302911-9244-44f1-aff6-006d0521e414",
        "parentId" : "8bf7729e-1b72-4b4b-a19d-b6ae2580da23",
        "authorId" : "128563de-a925-4397-af34-450c7978a8d2",
        "body" : "is this worth investigating in this PR?",
        "createdAt" : "2020-09-09T09:05:50Z",
        "updatedAt" : "2020-09-09T09:06:08Z",
        "lastEditedBy" : "128563de-a925-4397-af34-450c7978a8d2",
        "tags" : [
        ]
      },
      {
        "id" : "ea32041d-45e4-49e7-9c82-2ae2a41a164d",
        "parentId" : "8bf7729e-1b72-4b4b-a19d-b6ae2580da23",
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Probably not",
        "createdAt" : "2020-09-09T12:19:25Z",
        "updatedAt" : "2020-09-09T12:19:25Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      }
    ],
    "commit" : "d4769b996fa19504b06829ba723551681cb26628",
    "line" : 8,
    "diffHunk" : "@@ -1,1 +139,143 @@  def derivedTypeParamWithVariance(sym: TypeSymbol)(using Context): TypeDef =\n    val variance = VarianceFlags & sym.flags\n    TypeDef(sym.name, DerivedFromParamTree().watching(sym)).withFlags(TypeParam | Synthetic | variance)\n\n  /** A value definition copied from `vdef` with a tpt typetree derived from it */"
  },
  {
    "id" : "16442341-90ff-4a04-af10-62c5ac01627c",
    "prId" : 9553,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/9553#pullrequestreview-467586900",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3a444744-cf4e-4f14-b6ca-748c3163a317",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "If this can only happen in case of error, maybe the parser should be changed to not try to parse extension methods in such positions?",
        "createdAt" : "2020-08-13T14:58:27Z",
        "updatedAt" : "2020-08-14T13:45:47Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "4fd53467-15e6-4f22-969b-27acc0cf341d",
        "parentId" : "3a444744-cf4e-4f14-b6ca-748c3163a317",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "Why would we special case extensions? Isn't it better to handle them the same as `def`s? I would expect that the following would befave similarly\r\n\r\n```scala\r\n\r\ndef f1: Unit = { def g = 0 }\r\ndef f2: Unit = { extension (x: Int) def g = 0 }\r\n\r\n\r\n```",
        "createdAt" : "2020-08-14T08:52:52Z",
        "updatedAt" : "2020-08-14T13:45:47Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      },
      {
        "id" : "61c25c91-8864-4c6d-97e5-f3e4639a1792",
        "parentId" : "3a444744-cf4e-4f14-b6ca-748c3163a317",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "Also, same error should be emitted for\r\n\r\n```scala\r\ndef f1: Int = { def g = 0 } // error: Found: Unit   Required: Int\r\ndef f2: Int = { extension (x: Int) def g = 0 } // error: Found: Unit   Required: Int\r\n```",
        "createdAt" : "2020-08-14T08:54:39Z",
        "updatedAt" : "2020-08-14T13:45:47Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      },
      {
        "id" : "173d7703-1613-4565-8552-439b0d0dde2d",
        "parentId" : "3a444744-cf4e-4f14-b6ca-748c3163a317",
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Ah ok then is it possible to have a pos test for this change?",
        "createdAt" : "2020-08-14T11:04:02Z",
        "updatedAt" : "2020-08-14T13:45:47Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "9e119235-1145-4455-b220-afba13e05d34",
        "parentId" : "3a444744-cf4e-4f14-b6ca-748c3163a317",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "Yes, ill add the test",
        "createdAt" : "2020-08-14T13:41:52Z",
        "updatedAt" : "2020-08-14T13:45:47Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      },
      {
        "id" : "7a7a188b-eecf-4945-bd4c-ffee83dedbd8",
        "parentId" : "3a444744-cf4e-4f14-b6ca-748c3163a317",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "Added these tests",
        "createdAt" : "2020-08-14T13:45:55Z",
        "updatedAt" : "2020-08-14T13:45:55Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      }
    ],
    "commit" : "1e14ba3a1191357cf48a69d57f5727b4710dc547",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +1717,1721 @@        flatTree(pats1 map (makePatDef(tree, mods, _, rhs)))\n      case ext: ExtMethods =>\n        Block(List(ext), Literal(Constant(())).withSpan(ext.span))\n    }\n    desugared.withSpan(tree.span)"
  },
  {
    "id" : "b5068fa3-29e8-400b-8a6c-636337765f00",
    "prId" : 9255,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/9255#pullrequestreview-441548546",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6c5143ff-7194-4f6b-8065-defadc5ccc7d",
        "parentId" : null,
        "authorId" : "128563de-a925-4397-af34-450c7978a8d2",
        "body" : "should we have a migration for this?",
        "createdAt" : "2020-07-02T08:51:56Z",
        "updatedAt" : "2020-07-05T10:03:18Z",
        "lastEditedBy" : "128563de-a925-4397-af34-450c7978a8d2",
        "tags" : [
        ]
      },
      {
        "id" : "f733e622-7d07-4566-95fe-09cd04a1945b",
        "parentId" : "6c5143ff-7194-4f6b-8065-defadc5ccc7d",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "I think it's not common enough to spend the effort.\r\n",
        "createdAt" : "2020-07-02T10:24:45Z",
        "updatedAt" : "2020-07-05T10:03:18Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "e1601400452edcac163e2d53a4fa60aaf191a95d",
    "line" : 80,
    "diffHunk" : "@@ -1,1 +1000,1004 @@    }\n    if name.isExtensionName && !mdef.mods.is(Extension) then\n      ctx.error(em\"illegal method name: $name may not start with `extension_`\", errPos)\n    name\n  }"
  },
  {
    "id" : "d83f3e91-6f05-4138-9d86-53bc8154ff65",
    "prId" : 9255,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/9255#pullrequestreview-442445903",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "dabea7d8-032f-4807-a5f3-c03aefd14e28",
        "parentId" : null,
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "Should this be dropped in this PR?",
        "createdAt" : "2020-07-03T11:46:09Z",
        "updatedAt" : "2020-07-05T10:03:18Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      },
      {
        "id" : "e9605a9a-7a20-4d11-a3ee-60794d59fd92",
        "parentId" : "dabea7d8-032f-4807-a5f3-c03aefd14e28",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "No, we need to wait one cycle until we can drop the old collective extension syntax\r\n",
        "createdAt" : "2020-07-03T14:23:55Z",
        "updatedAt" : "2020-07-05T10:03:18Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "e1601400452edcac163e2d53a4fa60aaf191a95d",
    "line" : 22,
    "diffHunk" : "@@ -1,1 +851,855 @@   *  taking type parameters `tparams` and a leading paramter `(x: T)`.\n   *  See: collectiveExtensionBody\n   *  TODO: drop this part\n   */\n  def moduleDef(mdef: ModuleDef)(implicit ctx: Context): Tree = {"
  },
  {
    "id" : "b46ada11-aefa-41cb-8950-091b4f669c47",
    "prId" : 9165,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/9165#pullrequestreview-470820201",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ca6ffbe5-3cd3-4b5b-9881-2df7547750b9",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Scalac is a bit weird:\r\n```scala\r\nscala> case class Foo(x: Int); object Foo\r\nclass Foo\r\nobject Foo\r\n\r\nscala> Foo\r\nval res0: Foo.type = Foo$@fe34b86\r\n\r\nscala> case class Foo(x: Int)\r\nclass Foo\r\n\r\nscala> Foo\r\nval res1: Foo.type = Foo\r\n```\r\nI'm not sure if it's worth replicating this exact behavior, but maybe worth checking the scalac logic which determines when toString is inserted.",
        "createdAt" : "2020-06-11T18:45:25Z",
        "updatedAt" : "2020-08-20T12:17:32Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "e26a7a06-16c2-4937-a9ca-ed328bf3a6c5",
        "parentId" : "ca6ffbe5-3cd3-4b5b-9881-2df7547750b9",
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Seems like scalac only adds the toString in the situations where it also adds Function1 as a parent of the object (to avoid getting \"\\<function1\\>\" as the toString), it's a bit weird but doing the same would make it easier to do bytecode diff between scalac and dotty.",
        "createdAt" : "2020-06-11T21:33:43Z",
        "updatedAt" : "2020-08-20T12:17:32Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "b12a6b4d-8fdb-497a-979f-2970f845852f",
        "parentId" : "ca6ffbe5-3cd3-4b5b-9881-2df7547750b9",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "There isn't a way to know if the module will extend `Function1` while desugaring. I can't find a place to do it while typing either. Any suggestions?",
        "createdAt" : "2020-06-12T07:52:36Z",
        "updatedAt" : "2020-08-20T12:17:32Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      },
      {
        "id" : "d50172fe-9a85-4fbf-b21c-5eda100acfd1",
        "parentId" : "ca6ffbe5-3cd3-4b5b-9881-2df7547750b9",
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Maybe check if the moduledef is compiler-generated (span.isZeroExtent) ?",
        "createdAt" : "2020-06-12T13:28:24Z",
        "updatedAt" : "2020-08-20T12:17:32Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "645bf5e0-abf4-49f5-8224-200feac4f7b2",
        "parentId" : "ca6ffbe5-3cd3-4b5b-9881-2df7547750b9",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "I could not find a tree here with a span that was different for explicit or non explicit modules.",
        "createdAt" : "2020-06-12T14:47:47Z",
        "updatedAt" : "2020-08-20T12:17:32Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      },
      {
        "id" : "5799c95e-a099-4f40-a14f-ce3f65fe3f62",
        "parentId" : "ca6ffbe5-3cd3-4b5b-9881-2df7547750b9",
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "> There isn't a way to know if the module will extend Function1 while desugaring\r\n\r\nActually this is implemented in desugaring, see `companionParent`",
        "createdAt" : "2020-06-12T15:17:45Z",
        "updatedAt" : "2020-08-20T12:17:32Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "6b606e27-12c8-422e-bad7-445ad56ca5aa",
        "parentId" : "ca6ffbe5-3cd3-4b5b-9881-2df7547750b9",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "Unfortunately, both the get a `Function` in `companionParent`, the explicit declaration loses it somewhere later (not sure where).",
        "createdAt" : "2020-06-15T06:45:14Z",
        "updatedAt" : "2020-08-20T12:17:32Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      },
      {
        "id" : "32d77150-c9f7-4cac-aeaa-b1e13ccb16f5",
        "parentId" : "ca6ffbe5-3cd3-4b5b-9881-2df7547750b9",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "Any other idea?",
        "createdAt" : "2020-06-18T11:27:10Z",
        "updatedAt" : "2020-08-20T12:17:32Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      },
      {
        "id" : "115add07-a1db-4a7c-bb5a-4a3bcfdbcb66",
        "parentId" : "ca6ffbe5-3cd3-4b5b-9881-2df7547750b9",
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "I think it's fine as is.",
        "createdAt" : "2020-08-19T19:57:46Z",
        "updatedAt" : "2020-08-20T12:17:32Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      }
    ],
    "commit" : "2b4e16407efc00ddff561bfcf05104a3cb25fb86",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +721,725 @@        }\n        val toStringMeth =\n          DefDef(nme.toString_, Nil, Nil, TypeTree(), Literal(Constant(className.toString))).withMods(Modifiers(Override | Synthetic))\n\n        companionDefs(companionParent, applyMeths ::: unapplyMeth :: toStringMeth :: companionMembers)"
  },
  {
    "id" : "0caf3252-8396-478d-8b5f-9c8521af33e1",
    "prId" : 7583,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/7583#pullrequestreview-319228633",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5870206a-ed93-41c7-a22a-19968509e6a4",
        "parentId" : null,
        "authorId" : "128563de-a925-4397-af34-450c7978a8d2",
        "body" : "As `selector` is called in a large loop, I think it makes more sense for it to be a function val, and only check `arity <= 22` once",
        "createdAt" : "2019-11-19T16:39:07Z",
        "updatedAt" : "2019-11-19T17:42:40Z",
        "lastEditedBy" : "128563de-a925-4397-af34-450c7978a8d2",
        "tags" : [
        ]
      },
      {
        "id" : "fc9df14e-e33f-43b4-b180-8310144b3700",
        "parentId" : "5870206a-ed93-41c7-a22a-19968509e6a4",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "Done",
        "createdAt" : "2019-11-19T17:43:00Z",
        "updatedAt" : "2019-11-19T17:43:00Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      }
    ],
    "commit" : "2e8ea243f50f7b086a9920ad3bec054b4d4bb478",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +1100,1104 @@              .withSpan(pat.span.union(rhs.span)).withMods(patMods)\n          val useSelectors = vars.length <= 22\n          def selector(n: Int) =\n            if useSelectors then Select(Ident(tmpName), nme.selectorName(n))\n            else Apply(Select(Ident(tmpName), nme.apply), Literal(Constant(n)) :: Nil)"
  },
  {
    "id" : "a1b510cb-04b6-4822-839a-0b8111b14974",
    "prId" : 6985,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/6985#pullrequestreview-271953803",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "89bcb7c9-1731-45a7-96ce-a67973bc6512",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "We should emit an error if one of the Ts and one of the Us have the same name.",
        "createdAt" : "2019-08-07T13:17:12Z",
        "updatedAt" : "2019-08-07T16:15:03Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      }
    ],
    "commit" : "d54c611b43b684113c601b6477e9bab75953065e",
    "line" : 49,
    "diffHunk" : "@@ -1,1 +902,906 @@   *  to\n   *\n   *     <extension> def foo[Ts ++ Us](x: T) parammss ...\n   *\n   *  If the given member `mdef` is not of this form, flag it as an error."
  },
  {
    "id" : "7cd0cd6f-51fc-480a-b204-8bdd683de08d",
    "prId" : 6733,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/6733#pullrequestreview-258316037",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2f7362b3-056d-42d2-9c34-4ba7eed74d02",
        "parentId" : null,
        "authorId" : "3a3c9c08-5985-41f6-a86b-7fc5a427f51a",
        "body" : "`ListBuffer[ValDef]` is unambiguous. Meaning there is no question whether it is a reference to an object or a constructor call here because of the type parameters. Can we drop `()` here in future?",
        "createdAt" : "2019-07-05T09:43:05Z",
        "updatedAt" : "2019-07-05T09:44:51Z",
        "lastEditedBy" : "3a3c9c08-5985-41f6-a86b-7fc5a427f51a",
        "tags" : [
        ]
      }
    ],
    "commit" : "f54266b745e30fd1287f1e20ef3fe32e536d7878",
    "line" : 69,
    "diffHunk" : "@@ -1,1 +214,218 @@    val methName = normalizeName(meth, tpt).asTermName\n    val mods = meth.mods\n    val epbuf = ListBuffer[ValDef]()\n    def desugarContextBounds(rhs: Tree): Tree = rhs match {\n      case ContextBounds(tbounds, cxbounds) =>"
  },
  {
    "id" : "542b0f63-77ae-4aff-b8eb-705858c06a11",
    "prId" : 6465,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/6465#pullrequestreview-234375096",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "923ff0dc-8073-4185-938c-bdd425985381",
        "parentId" : null,
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "Why not just `collect(expr)` and handle `Splice` and `TypeSplice` as two cases in the outer match?",
        "createdAt" : "2019-05-07T07:35:12Z",
        "updatedAt" : "2019-05-07T07:35:21Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "ca5aedef-e487-4f02-a9f8-113c51382a41",
        "parentId" : "923ff0dc-8073-4185-938c-bdd425985381",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "Because everything directly inside of the quote is quoted code that is not part of the pattern (not in pattern mode). It only enters back in pattern mode inside the splices\r\n\r\nFor example in \r\n```scala\r\ncase '{ StringContext(${ExprSeq(parts2)}: _*) }\r\n```\r\nwe use the traverser to traverse the trees `StringContext(XYZ: _*)` and then `collect` on `XYZ`, which in this case is a collect on the pattern `ExprSeq(parts2)` that will collect the variable `parts2`.\r\n\r\n",
        "createdAt" : "2019-05-07T08:22:50Z",
        "updatedAt" : "2019-05-07T08:22:50Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      }
    ],
    "commit" : "a36d90f8fa2e40303eff320fdea33c32e82e01e8",
    "line" : 11,
    "diffHunk" : "@@ -1,1 +1558,1562 @@            case _ => traverseChildren(tree)\n          }\n        }.traverse(expr)\n      case _ =>\n    }"
  },
  {
    "id" : "15f5ee17-7a3a-414b-a7e1-a1f09252dc01",
    "prId" : 6448,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/6448#pullrequestreview-236618672",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a55d9da6-3307-4901-bdd1-5084dede8db8",
        "parentId" : null,
        "authorId" : "3a56b927-736f-4aab-8690-358cd24ca570",
        "body" : "The fact that `@unchecked` is also added to irrefutable patterns really confused me until I understood that annotating the selector only affects exhaustivity checks and not irrefutability checks. Perhaps we could note this in the doc?\r\n\r\n```suggestion\r\n  /** The selector of a match, which depends of the given `checkMode`.\r\n   *\r\n   * The @unchecked annotation is added whenever `checkMode` is not `Exhaustive` to silence\r\n   * unnecessary inexhaustive match warnings.\r\n```\r\n```",
        "createdAt" : "2019-05-13T11:36:32Z",
        "updatedAt" : "2019-05-15T10:29:48Z",
        "lastEditedBy" : "3a56b927-736f-4aab-8690-358cd24ca570",
        "tags" : [
        ]
      }
    ],
    "commit" : "9a7c709314c70b1cbfd091a36f50845b5e642a92",
    "line" : 26,
    "diffHunk" : "@@ -1,1 +938,942 @@  }\n\n  /** The selector of a match, which depends of the given `checkMode`.\n   *  @param  sel  the original selector\n   *  @return if `checkMode` is"
  },
  {
    "id" : "48e9f277-2922-40d2-92e4-d75d0d9ab4ae",
    "prId" : 5837,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/5837#pullrequestreview-200587592",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "32edeaab-e7b2-4d53-8c15-30c241041595",
        "parentId" : null,
        "authorId" : "6d71bb21-e402-4464-b2b1-8bdd8e068461",
        "body" : "The comment above is out of date",
        "createdAt" : "2019-02-04T15:22:27Z",
        "updatedAt" : "2019-02-06T15:26:33Z",
        "lastEditedBy" : "6d71bb21-e402-4464-b2b1-8bdd8e068461",
        "tags" : [
        ]
      },
      {
        "id" : "1aa1327c-cdc9-498c-b997-d1d0668d01a5",
        "parentId" : "32edeaab-e7b2-4d53-8c15-30c241041595",
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "I'll just remove the comment since it doesn't give any information that's not already obvious from the code.",
        "createdAt" : "2019-02-06T13:59:01Z",
        "updatedAt" : "2019-02-06T15:26:33Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      }
    ],
    "commit" : "5fc21199cc6ead57844742857e97a7e40c63885c",
    "line" : 23,
    "diffHunk" : "@@ -1,1 +534,538 @@    if (isCaseClass | isCaseObject)\n      parents1 = parents1 :+ scalaDot(str.Product.toTypeName) :+ scalaDot(nme.Serializable.toTypeName)\n    else if (isObject)\n      parents1 = parents1 :+ scalaDot(nme.Serializable.toTypeName)\n    if (isEnum)"
  },
  {
    "id" : "06ab3df9-1ed9-470d-8fbd-b184deb30ca4",
    "prId" : 5723,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/5723#pullrequestreview-193418939",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9bd1f175-5167-4c39-af33-90cab649f209",
        "parentId" : null,
        "authorId" : "348fab8e-49e2-442e-884d-850c7f41fdde",
        "body" : "This should fix the crashes in http://dotty-ci.epfl.ch/lampepfl/dotty/9779/5",
        "createdAt" : "2019-01-17T00:41:48Z",
        "updatedAt" : "2019-01-19T13:20:44Z",
        "lastEditedBy" : "348fab8e-49e2-442e-884d-850c7f41fdde",
        "tags" : [
        ]
      }
    ],
    "commit" : "986c2dffb83d4193ed6204fd570bbeb323f3ce44",
    "line" : 15,
    "diffHunk" : "@@ -1,1 +713,717 @@      ctx.warning(hl\"\"\"$Final modifier is redundant for objects\"\"\", flagSourcePos(Final))\n\n    if (mods is Package)\n      PackageDef(Ident(moduleName), cpy.ModuleDef(mdef)(nme.PACKAGE, impl).withMods(mods &~ Package) :: Nil)\n    else if (isEnumCase)"
  },
  {
    "id" : "368eec26-41f0-4b5a-a10a-6055487425c7",
    "prId" : 5617,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/5617#pullrequestreview-185358637",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "374bf39e-b4b4-48e3-bf98-5c50df91c531",
        "parentId" : null,
        "authorId" : "223e67d6-1873-432a-9af9-f40b82a7eedd",
        "body" : "Maybe rename to `productElemNameMeth` to follow the naming scheme we use",
        "createdAt" : "2018-12-15T15:44:12Z",
        "updatedAt" : "2018-12-15T15:56:03Z",
        "lastEditedBy" : "223e67d6-1873-432a-9af9-f40b82a7eedd",
        "tags" : [
        ]
      }
    ],
    "commit" : "8fb74ff48a0cb30930ebd9e4ad2c494717b5d336",
    "line" : 15,
    "diffHunk" : "@@ -1,1 +487,491 @@      // TODO When the Scala library is updated to 2.13.x add the override keyword to this generated method.\n      // (because Product.scala was updated)\n      def productElemNameMethod = {\n        val methodParam = makeSyntheticParameter(tpt = scalaDot(tpnme.Int))\n        val paramRef = Ident(methodParam.name)"
  },
  {
    "id" : "0d220caf-72cc-4018-928f-05ee4d00b1f0",
    "prId" : 5383,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/5383#pullrequestreview-171483790",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "82ec7766-4747-4ca7-9b89-c8c9960b9c7c",
        "parentId" : null,
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "Maybe we should encourage to write such signatures as union types. \r\n\r\n```scala\r\ninline def f(x: Boolean) <: Int | String = if (x) 1 else \"\"\r\n// or \r\ninline def f(x: Boolean) <: 1 | \"\" = if (x) 1 else \"\"\r\n```\r\n",
        "createdAt" : "2018-11-05T09:36:42Z",
        "updatedAt" : "2018-11-08T13:24:27Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      },
      {
        "id" : "b21977e0-4169-4d50-989f-6595811abd6c",
        "parentId" : "82ec7766-4747-4ca7-9b89-c8c9960b9c7c",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "We can do that, but often it's more complicated than that.",
        "createdAt" : "2018-11-05T10:06:01Z",
        "updatedAt" : "2018-11-08T13:24:27Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "221d337c4dc9676afad2cf8496817874aae17ecb",
    "line" : 22,
    "diffHunk" : "@@ -1,1 +174,178 @@   *  3. Convert <: T to : T in specializing inline methods. E.g.\n   *\n   *      inline def f(x: Boolean) <: Any = if (x) 1 else \"\"\n   *  ==>\n   *      inline def f(x: Boolean): Any = if (x) 1 else \"\""
  },
  {
    "id" : "d01cf58c-50f1-42d8-a890-e7fa1247603b",
    "prId" : 4423,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/4423#pullrequestreview-116402700",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6c281486-ca2c-4a64-95b2-ec5d1f9147cf",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "I don't think that's enough in general, e.g. `enum Foo[F <: [X] => Any]`, but maybe we're ok with that since that's only a temporary solution.",
        "createdAt" : "2018-04-30T19:01:21Z",
        "updatedAt" : "2018-04-30T19:02:29Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "90bb394b-275f-4d57-a677-f599930dd6cc",
        "parentId" : "6c281486-ca2c-4a64-95b2-ec5d1f9147cf",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Yes, I think the right solution cannot be done at Desugar, it needs full type information.",
        "createdAt" : "2018-04-30T19:15:49Z",
        "updatedAt" : "2018-04-30T19:15:49Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "5636765cb5e6ac40855c477e2a1bee8814e649cd",
    "line" : 16,
    "diffHunk" : "@@ -1,1 +368,372 @@\n    def isHK(tparam: Tree): Boolean = tparam match {\n      case TypeDef(_, LambdaTypeTree(tparams, body)) => true\n      case TypeDef(_, rhs: DerivedTypeTree) => isHK(rhs.watched)\n      case _ => false"
  },
  {
    "id" : "d70082ee-b2d0-4e3d-add0-4c8233d9ff0f",
    "prId" : 4411,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/4411#pullrequestreview-116172188",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "806057ec-1738-4e7f-a3d6-0e24739802ea",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Wrong indentation.",
        "createdAt" : "2018-04-29T16:46:32Z",
        "updatedAt" : "2018-04-29T16:46:32Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      }
    ],
    "commit" : "690321d2aa75001873bf4a2e5183cacf6bffe61f",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +89,93 @@              def msg =\n                s\"no matching symbol for ${tp.symbol.showLocated} in ${defctx.owner} / ${defctx.effectiveScope.toList}\"\n\t\t\t  ErrorType(msg).assertingErrorsReported(msg)\n\t\t\t}\n          case _ =>"
  },
  {
    "id" : "7e66a56a-19c1-41e5-b1ae-38df56bec3b4",
    "prId" : 3713,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/3713#pullrequestreview-86036823",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "cc481659-84b2-4a2f-add4-8adda8e43908",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Any idea why we manage to hit this assertion in the IDE?",
        "createdAt" : "2017-12-30T19:08:10Z",
        "updatedAt" : "2017-12-30T21:19:32Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "c002b171-351a-4af7-b582-599f4eb94c63",
        "parentId" : "cc481659-84b2-4a2f-add4-8adda8e43908",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "No idea, I am afraid.",
        "createdAt" : "2017-12-30T21:21:10Z",
        "updatedAt" : "2017-12-30T21:21:10Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "2a285cd281b692bb04456bb1e76f65b953e21031",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +1066,1070 @@            New(ref(defn.RepeatedAnnotType), Nil :: Nil))\n        } else {\n          assert(ctx.mode.isExpr || ctx.reporter.hasErrors || ctx.mode.is(Mode.Interactive), ctx.mode)\n          Select(t, op.name)\n        }"
  },
  {
    "id" : "df280d6b-dfd0-435a-bef8-6dcff8fdc6cd",
    "prId" : 3527,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/3527#pullrequestreview-78489405",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e6dc2975-66c3-45fc-ac0f-8a3a9b403b8b",
        "parentId" : null,
        "authorId" : "223e67d6-1873-432a-9af9-f40b82a7eedd",
        "body" : "You can remove the `Parens` case in this pattern match",
        "createdAt" : "2017-11-22T15:46:09Z",
        "updatedAt" : "2017-11-23T12:52:36Z",
        "lastEditedBy" : "223e67d6-1873-432a-9af9-f40b82a7eedd",
        "tags" : [
        ]
      }
    ],
    "commit" : "7bce28eb19c1bc8fe784eefead9b9fe842f87b05",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +1028,1032 @@    }\n\n    val desugared = tree match {\n      case SymbolLit(str) =>\n        Apply("
  },
  {
    "id" : "4d926603-271b-4f22-ab52-f6c737b88031",
    "prId" : 2552,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/2552#pullrequestreview-40677076",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "714ee0c2-038f-42cf-81a9-6359ba3e2878",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Any reason to not use semantic names here?",
        "createdAt" : "2017-05-28T09:29:59Z",
        "updatedAt" : "2017-05-29T13:24:37Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "6e66e4d8-fd6d-4cb4-b52a-ebcae0d5cf71",
        "parentId" : "714ee0c2-038f-42cf-81a9-6359ba3e2878",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Yes, we could do that. ",
        "createdAt" : "2017-05-28T17:56:26Z",
        "updatedAt" : "2017-05-29T13:24:37Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "70da9ae3-152f-4627-94aa-aae28856d3a2",
        "parentId" : "714ee0c2-038f-42cf-81a9-6359ba3e2878",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "On the other hand, maybe it's not worth the hassle. The names literally don't matter.",
        "createdAt" : "2017-05-28T18:07:34Z",
        "updatedAt" : "2017-05-29T13:24:37Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "bce0df9cf1d5a2a908526838d87fbcce53ada743",
    "line" : 85,
    "diffHunk" : "@@ -1,1 +427,431 @@    def eqInstance = {\n      def append(tdef: TypeDef, str: String) = cpy.TypeDef(tdef)(name = tdef.name ++ str)\n      val leftParams = derivedTparams.map(append(_, \"$1\"))\n      val rightParams = derivedTparams.map(append(_, \"$2\"))\n      val subInstances = (leftParams, rightParams).zipped.map((param1, param2) =>"
  },
  {
    "id" : "f735e651-631a-495c-adb3-506e9f7a8a60",
    "prId" : 1958,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/1958#pullrequestreview-24318223",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "66d7e8b7-dbe3-4d6c-83eb-456e3418fbb7",
        "parentId" : null,
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "I may miss some point here, it seems to me the fold is useless here, because `constrVparamss` can only be of size 0? ",
        "createdAt" : "2017-02-28T15:09:24Z",
        "updatedAt" : "2017-04-06T07:03:29Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "c0c7e02d-6f84-4868-867c-470015b8ab15",
        "parentId" : "66d7e8b7-dbe3-4d6c-83eb-456e3418fbb7",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "size 0 or 1",
        "createdAt" : "2017-02-28T16:17:01Z",
        "updatedAt" : "2017-04-06T07:03:29Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "39b1cee0-f83c-4208-bfee-4324b6046b4c",
        "parentId" : "66d7e8b7-dbe3-4d6c-83eb-456e3418fbb7",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "size 0 or 1, actually.\r\n",
        "createdAt" : "2017-02-28T16:25:02Z",
        "updatedAt" : "2017-04-06T07:03:29Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "26f3649d-82a3-49ff-a335-f1b68ce29c05",
        "parentId" : "66d7e8b7-dbe3-4d6c-83eb-456e3418fbb7",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "Ah, I see, thanks, obviously I've some problems with basic math :)",
        "createdAt" : "2017-02-28T19:05:12Z",
        "updatedAt" : "2017-04-06T07:03:29Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      }
    ],
    "commit" : "30d8d878118c537ff82c88ef7ade8780b390bfae",
    "line" : 137,
    "diffHunk" : "@@ -1,1 +452,456 @@            // todo: also use anyRef if constructor has a dependent method type (or rule that out)!\n            (constrVparamss :\\ (if (isEnumCase) applyResultTpt else classTypeRef)) (\n              (vparams, restpe) => Function(vparams map (_.tpt), restpe))\n        val applyMeths =\n          if (mods is Abstract) Nil"
  }
]
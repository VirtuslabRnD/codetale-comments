[
  {
    "id" : "e1bdfe21-ffe4-4d16-a529-adf8a89b3119",
    "prId" : 12799,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/12799#pullrequestreview-687180648",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "68437e17-4154-4a99-994d-91716966f062",
        "parentId" : null,
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "Shouldn't we do it for other constants?",
        "createdAt" : "2021-06-15T06:28:09Z",
        "updatedAt" : "2021-06-15T06:28:09Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      },
      {
        "id" : "7373ce5f-db8b-4d1a-b8e0-e92835b327dd",
        "parentId" : "68437e17-4154-4a99-994d-91716966f062",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "The only constant types supporting the alternative comparison with `eq` are classes and strings. Class literals are hash consed, so `==` and `eq` are the same. So I believe `String` is the only type in need of a fix.",
        "createdAt" : "2021-06-15T11:34:25Z",
        "updatedAt" : "2021-06-15T11:34:47Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "886a4506-4909-4afe-9c51-c154ca2187ce",
        "parentId" : "68437e17-4154-4a99-994d-91716966f062",
        "authorId" : "7ecf1a75-b43a-4ea0-bcbf-cd68aa0379d1",
        "body" : "To add, I didn't find this issue with integer constants.",
        "createdAt" : "2021-06-17T08:42:57Z",
        "updatedAt" : "2021-06-17T08:42:57Z",
        "lastEditedBy" : "7ecf1a75-b43a-4ea0-bcbf-cd68aa0379d1",
        "tags" : [
        ]
      },
      {
        "id" : "8345ff70-4957-4288-b191-6af224e0e874",
        "parentId" : "68437e17-4154-4a99-994d-91716966f062",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "`Null` might also take advantage of this unless some other optimization is already handling it.",
        "createdAt" : "2021-06-18T08:50:28Z",
        "updatedAt" : "2021-06-18T08:50:28Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      }
    ],
    "commit" : "82b94e98d4cfabd8c318055f65806bba1b3c4824",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +964,968 @@    /** `tree.isInstanceOf[tp]`, with special treatment of singleton types */\n    def isInstance(tp: Type)(using Context): Tree = tp.dealias match {\n      case ConstantType(c) if c.tag == StringTag =>\n        singleton(tp).equal(tree)\n      case tp: SingletonType =>"
  },
  {
    "id" : "77f19123-887e-4b44-84af-76cf15785dff",
    "prId" : 6923,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/6923#pullrequestreview-282064065",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "550b7eaf-b0f8-48b6-b2e9-3341cd96add7",
        "parentId" : null,
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "What about curried methods that have implicit parameters as the 3rd parameter clause? Should we accept them? I guess there's no problem with those since we would not have to resolve them right away, right? If yes, it would be good to state this here as an explanation. ",
        "createdAt" : "2019-07-31T08:31:38Z",
        "updatedAt" : "2019-07-31T08:32:01Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "0b30a4f9-4fda-4112-8243-83e9e94544e5",
        "parentId" : "550b7eaf-b0f8-48b6-b2e9-3341cd96add7",
        "authorId" : "3a3c9c08-5985-41f6-a86b-7fc5a427f51a",
        "body" : "There can be a problem... It looks like `applyOverloaded` resolves a method name looking only at the first argument group. E.g.:\r\n\r\n```scala\r\ndef f(x: Int)(y: Int) given Z: Int\r\ndef f(x: String)(y: Int): Int\r\napplyOverloaded(\"f\", x: Any)\r\n```\r\n\r\nIn both cases, the logic above infers `x.isImplicitMethod` to be `false`, so it cannot differentiate and can select the one with the implicit args at the end. Which it will never be able to call if we are after Typer.",
        "createdAt" : "2019-07-31T09:51:51Z",
        "updatedAt" : "2019-07-31T09:51:52Z",
        "lastEditedBy" : "3a3c9c08-5985-41f6-a86b-7fc5a427f51a",
        "tags" : [
        ]
      },
      {
        "id" : "68ae3d50-4ddd-4351-aa0f-6f29d031bd84",
        "parentId" : "550b7eaf-b0f8-48b6-b2e9-3341cd96add7",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Ah, OK. So we need to exclude all implicit methods, even of the implicit comes later.\r\n",
        "createdAt" : "2019-08-02T11:25:22Z",
        "updatedAt" : "2019-08-02T11:25:23Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "d413d9d7-69b2-4f35-a668-09f1535606aa",
        "parentId" : "550b7eaf-b0f8-48b6-b2e9-3341cd96add7",
        "authorId" : "3a3c9c08-5985-41f6-a86b-7fc5a427f51a",
        "body" : "@odersky do you think this is no longer a problem?",
        "createdAt" : "2019-08-30T14:23:34Z",
        "updatedAt" : "2019-08-30T14:23:34Z",
        "lastEditedBy" : "3a3c9c08-5985-41f6-a86b-7fc5a427f51a",
        "tags" : [
        ]
      }
    ],
    "commit" : "160436b3887a41214aca5b0d27e649c69964c1f4",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +1151,1155 @@          .filter(tr => typeParamCount(tr) == targs.length)\n          .filter { _.widen match {\n            case MethodTpe(_, _, x: MethodType) => !x.isImplicitMethod\n            case _ => true\n          }}"
  },
  {
    "id" : "59721b55-ccb9-4bbc-9b15-e35f7f6d9556",
    "prId" : 6584,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/6584#pullrequestreview-243350941",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c3b92aba-59f1-4863-b430-8928f6bd7a96",
        "parentId" : null,
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "This line triggers the crash. I find it better to add `withSpan` for other constructors too.",
        "createdAt" : "2019-05-29T15:44:36Z",
        "updatedAt" : "2019-05-29T18:49:26Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      }
    ],
    "commit" : "6018c2b18c974b0d103c8f0bc671e80ff13f6ccc",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +919,923 @@      }\n      else tree.ensureConforms(defn.ObjectType)\n      receiver.select(defn.Object_ne).appliedTo(nullLiteral).withSpan(tree.span)\n    }\n"
  },
  {
    "id" : "da0749f7-e580-4d04-b1e1-1b4d866e64a8",
    "prId" : 6504,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/6504#pullrequestreview-254728760",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "185b9e8e-803b-4db9-ba97-c9e2b748b792",
        "parentId" : null,
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Rename to `nestedPairsTypeTree`, since we already have a `nestedPairs` in TypeOps which denotes a type.\r\n",
        "createdAt" : "2019-06-26T16:22:37Z",
        "updatedAt" : "2019-07-02T12:03:53Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "732033fea3e4e0248395c070156a73022d9654a0",
    "line" : 20,
    "diffHunk" : "@@ -1,1 +1350,1354 @@  }\n\n  /** Creates the nested pairs type tree repesentation of the type trees in `ts` */\n  def nestedPairsTypeTree(ts: List[Tree])(implicit ctx: Context): Tree =\n    ts.foldRight[Tree](TypeTree(defn.UnitType))((x, acc) => AppliedTypeTree(TypeTree(defn.PairType), x :: acc :: Nil))"
  },
  {
    "id" : "8b5da4b4-bec7-4e21-8945-741d0db8c26c",
    "prId" : 6180,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/6180#pullrequestreview-219879422",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1bb1c3db-cdbd-4571-b505-7b72e70aa317",
        "parentId" : null,
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "It seems type symbols should be skipped too? `isBinding` currently only ignores class symbols.",
        "createdAt" : "2019-03-28T08:19:25Z",
        "updatedAt" : "2019-03-28T10:39:20Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      }
    ],
    "commit" : "d6915a42d928b16478424331b1f48fda0a148764",
    "line" : 17,
    "diffHunk" : "@@ -1,1 +1022,1026 @@  class MapToUnderlying extends TreeMap {\n    override def transform(tree: Tree)(implicit ctx: Context): Tree = tree match {\n      case tree: Ident if isBinding(tree.symbol) && skipLocal(tree.symbol) =>\n        tree.symbol.defTree match {\n          case defTree: ValOrDefDef =>"
  },
  {
    "id" : "c88aa42a-9811-43d9-9f3c-8f8e7ce84c9b",
    "prId" : 6177,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/6177#pullrequestreview-219657590",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2d638d39-5f36-4bfb-87d8-d535e9905b37",
        "parentId" : null,
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "@liufengyun I added this other condition to fix a second bug with the same code",
        "createdAt" : "2019-03-27T13:15:20Z",
        "updatedAt" : "2019-03-27T13:15:20Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      },
      {
        "id" : "e69403bf-7f6d-43db-a79d-883e8dc30308",
        "parentId" : "2d638d39-5f36-4bfb-87d8-d535e9905b37",
        "authorId" : "223e67d6-1873-432a-9af9-f40b82a7eedd",
        "body" : "The guard is getting quite long. Maybe extract it into a `def` with a comment explaining when a symbol is skipped",
        "createdAt" : "2019-03-27T15:25:00Z",
        "updatedAt" : "2019-03-27T15:25:00Z",
        "lastEditedBy" : "223e67d6-1873-432a-9af9-f40b82a7eedd",
        "tags" : [
        ]
      },
      {
        "id" : "0b77cc88-1766-4bf6-8404-839febeb53c8",
        "parentId" : "2d638d39-5f36-4bfb-87d8-d535e9905b37",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "It will be simpler to refactor this in the next PR I'm working on in which I already have to change the `skipLocal`",
        "createdAt" : "2019-03-27T18:19:31Z",
        "updatedAt" : "2019-03-27T18:19:31Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      },
      {
        "id" : "a9ca9e37-9c2d-43a3-8562-9e8ccf94e45c",
        "parentId" : "2d638d39-5f36-4bfb-87d8-d535e9905b37",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "#6180",
        "createdAt" : "2019-03-27T18:43:54Z",
        "updatedAt" : "2019-03-27T18:43:54Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      }
    ],
    "commit" : "24b914e87bb5be65c09b275e18582cf5ce29e0d7",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +1019,1023 @@  class MapToUnderlying extends TreeMap {\n    override def transform(tree: Tree)(implicit ctx: Context): Tree = tree match {\n      case tree: Ident if tree.symbol.exists && !tree.symbol.owner.isClass && !tree.symbol.isAnonymousFunction && skipLocal(tree.symbol) =>\n        tree.symbol.defTree match {\n          case defTree: ValOrDefDef if !defTree.rhs.isEmpty => transform(defTree.rhs)"
  },
  {
    "id" : "a0ff98bc-5a36-489a-a1c8-37ef8c1d6ec4",
    "prId" : 5958,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/5958#pullrequestreview-206340879",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "32c7403e-1483-4230-ab12-3c45a246c465",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "More detailed comment:\r\n```scala\r\n          // The last guard is a conservative check: if `tree.tpe` is different from `expr.tpe`, then\r\n          // it was computed from widening `expr.tpe`, and tree transforms might cause `expr.tpe.widen`\r\n          // to change even if `expr.tpe` itself didn't change, e.g:\r\n          //     { val s = ...;  s }\r\n          // If the type of `s` changed, then the type of the block might have changed, even though `expr.tpe`\r\n          // will still be `TermRef(NoPrefix, s)`\r\n```",
        "createdAt" : "2019-02-21T14:50:03Z",
        "updatedAt" : "2019-02-21T16:06:00Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      }
    ],
    "commit" : "ff7a67cf086ed1c0d005de10e83881f0385875a3",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +574,578 @@      tree match {\n        case tree: Block if (expr.tpe eq tree.expr.tpe) && (expr.tpe eq tree.tpe) =>\n          // the second guard is needed in case avoid somehow widened the type.\n          // if it did it could potentially need to rewiden it\n          // eg {val s = ...; s}"
  },
  {
    "id" : "d7f61851-4c2c-41a2-b3e3-660159df91e7",
    "prId" : 5958,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/5958#pullrequestreview-206340879",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "838f783a-db41-40fb-bedb-9d7ca0c2f5a2",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "New comment:\r\n```scala\r\n          // The last guard is a conservative check similar to the one done in `Block` above,\r\n          // if `tree.tpe` is not identical to the type of one of its branch, it might have been\r\n          // computed from the widened type of the branches, so the same reasoning than\r\n          // in `Block` applies.\r\n```",
        "createdAt" : "2019-02-21T16:04:48Z",
        "updatedAt" : "2019-02-21T16:06:00Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      }
    ],
    "commit" : "ff7a67cf086ed1c0d005de10e83881f0385875a3",
    "line" : 21,
    "diffHunk" : "@@ -1,1 +588,592 @@        case tree: If if (thenp.tpe eq tree.thenp.tpe) && (elsep.tpe eq tree.elsep.tpe) &&\n          ((tree.tpe eq thenp.tpe) || (tree.tpe eq elsep.tpe)) =>\n          // last guard is needed in case previous if had computed a widened ORType that needs to be recomputed\n          // eg {val a = ...; val b = ...; if(...) a else b}\n          // changing type of a or b should change type of if, though types of both trees remain unchanged"
  },
  {
    "id" : "5f3c973d-bbfb-420f-9dce-75030ccda25a",
    "prId" : 5767,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/5767#pullrequestreview-195922028",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0288db8a-256e-467f-9711-3d0ee221ec5f",
        "parentId" : null,
        "authorId" : "223e67d6-1873-432a-9af9-f40b82a7eedd",
        "body" : "Can this be simplified further?\r\n```scala\r\ndef changeNonLocalOwners(newOwner: Symbol)(implicit ctx: Context): Tree = {\r\n  val localOwnerAcc = new TreeAccumulator[List[Symbol]] {\r\n    def apply(ss: List[Symbol], tree: Tree)(implicit ctx: Context) = tree match {\r\n      case tree: DefTree =>\r\n        if (tree.symbol.exists) tree.symbol :: ss\r\n        else ss\r\n      case _ =>\r\n        foldOver(ss, tree)\r\n      }\r\n    }\r\n  }\r\n  val nonLocalOwners = localOwnerAcc(Nil, tree).map(_.owner).distinct\r\n  val newOwners = nonLocalOwners.map(_ => newOwner)\r\n  new TreeTypeMap(oldOwners = nonLocalOwners, newOwners = newOwners).apply(tree)\r\n}\r\n```",
        "createdAt" : "2019-01-23T18:47:09Z",
        "updatedAt" : "2019-01-24T11:57:31Z",
        "lastEditedBy" : "223e67d6-1873-432a-9af9-f40b82a7eedd",
        "tags" : [
        ]
      },
      {
        "id" : "bf72e26e-2ac0-4b1d-9584-f536985e2468",
        "parentId" : "0288db8a-256e-467f-9711-3d0ee221ec5f",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "I think the idea of using an accumulator is good, but why the detour via lists? Let's use an accumulator over an immutable set instead.",
        "createdAt" : "2019-01-24T08:14:55Z",
        "updatedAt" : "2019-01-24T11:57:31Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "828a9731-c355-47e1-82ca-c6f28103d0d2",
        "parentId" : "0288db8a-256e-467f-9711-3d0ee221ec5f",
        "authorId" : "223e67d6-1873-432a-9af9-f40b82a7eedd",
        "body" : "Updated:\r\n```scala\r\ndef changeNonLocalOwners(newOwner: Symbol)(implicit ctx: Context): Tree = {\r\n  val ownerAcc = new TreeAccumulator[Set[Symbol]] {\r\n    def apply(ss: Set[Symbol], tree: Tree)(implicit ctx: Context) = tree match {\r\n      case tree: DefTree =>\r\n        if (tree.symbol.exists) ss + tree.symbol.owner\r\n        else ss\r\n      case _ =>\r\n        foldOver(ss, tree)\r\n      }\r\n    }\r\n  }\r\n  val owners = ownerAcc(Set.empty, tree)\r\n  val newOwners = List.fill(owners.size)(newOwner)\r\n  new TreeTypeMap(oldOwners = owners.toList, newOwners = newOwners).apply(tree)\r\n}\r\n```",
        "createdAt" : "2019-01-24T09:21:47Z",
        "updatedAt" : "2019-01-24T18:19:17Z",
        "lastEditedBy" : "223e67d6-1873-432a-9af9-f40b82a7eedd",
        "tags" : [
        ]
      }
    ],
    "commit" : "98a4f14f76f871bbeafdbf859e0c92dc33cda0a7",
    "line" : 30,
    "diffHunk" : "@@ -1,1 +748,752 @@      val newOwners = List.fill(owners.size)(newOwner)\n      new TreeTypeMap(oldOwners = owners, newOwners = newOwners).apply(tree)\n    }\n\n    /** After phase `trans`, set the owner of every definition in this tree that was formerly"
  },
  {
    "id" : "96953da9-4974-4ff2-a8e5-128059e53da2",
    "prId" : 5190,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/5190#pullrequestreview-166270098",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5abaccb8-e732-4449-abaa-baba5b3c5aa8",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "You could try to do the same for TypeApply.",
        "createdAt" : "2018-10-02T10:20:35Z",
        "updatedAt" : "2018-10-19T12:18:57Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "69431a34-79ea-4177-a7b0-2dd20ac10751",
        "parentId" : "5abaccb8-e732-4449-abaa-baba5b3c5aa8",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "Yes, we could do that. I'm wondering how `if/else` could possibly appear in `fun`. But it is always good to have these invariants if they don't incur much performance cost.",
        "createdAt" : "2018-10-02T10:27:13Z",
        "updatedAt" : "2018-10-19T12:18:57Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "d7331f6e-bd68-4a7b-99a4-ad581dc0961d",
        "parentId" : "5abaccb8-e732-4449-abaa-baba5b3c5aa8",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "You will probably not be able to. You could add the assertion to make sure.",
        "createdAt" : "2018-10-18T19:59:43Z",
        "updatedAt" : "2018-10-19T12:18:57Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      }
    ],
    "commit" : "9616be10ce1339827eeb3d80deda86c0dd19b60a",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +48,52 @@  def TypeApply(fn: Tree, args: List[Tree])(implicit ctx: Context): TypeApply = {\n    assert(fn.isInstanceOf[RefTree] || fn.isInstanceOf[GenericApply[_]])\n    ta.assignType(untpd.TypeApply(fn, args), fn, args)\n  }\n"
  },
  {
    "id" : "f99ad4c3-0a72-441b-923e-8a0813635795",
    "prId" : 5190,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/5190#pullrequestreview-166482164",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4ef45764-774d-4cb4-9f1a-acad0bb39037",
        "parentId" : null,
        "authorId" : "223e67d6-1873-432a-9af9-f40b82a7eedd",
        "body" : "Can we have nested `TypeApply`? Should we check `fn.isInstanceOf[Apply[_]]` instead of `fn.isInstanceOf[GenericApply[_]]`?",
        "createdAt" : "2018-10-19T11:25:05Z",
        "updatedAt" : "2018-10-19T12:18:57Z",
        "lastEditedBy" : "223e67d6-1873-432a-9af9-f40b82a7eedd",
        "tags" : [
        ]
      },
      {
        "id" : "b4f7cb50-99f8-4646-a782-44f7217da715",
        "parentId" : "4ef45764-774d-4cb4-9f1a-acad0bb39037",
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "With named type arguments yes I think so `foo[A=Int][String]`",
        "createdAt" : "2018-10-19T11:28:23Z",
        "updatedAt" : "2018-10-19T12:18:57Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "ebc04847-2300-4202-ab32-f9ffe68e7a85",
        "parentId" : "4ef45764-774d-4cb4-9f1a-acad0bb39037",
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "... also with curried type lambdas.",
        "createdAt" : "2018-10-19T11:28:34Z",
        "updatedAt" : "2018-10-19T12:18:57Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      }
    ],
    "commit" : "9616be10ce1339827eeb3d80deda86c0dd19b60a",
    "line" : 12,
    "diffHunk" : "@@ -1,1 +47,51 @@\n  def TypeApply(fn: Tree, args: List[Tree])(implicit ctx: Context): TypeApply = {\n    assert(fn.isInstanceOf[RefTree] || fn.isInstanceOf[GenericApply[_]])\n    ta.assignType(untpd.TypeApply(fn, args), fn, args)\n  }"
  },
  {
    "id" : "cebfdf9d-da04-40c2-8d66-f399c1f73ebd",
    "prId" : 4990,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/4990#pullrequestreview-149444780",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ee4666a7-0790-4be1-b0d7-9ddca3f19de1",
        "parentId" : null,
        "authorId" : "348fab8e-49e2-442e-884d-850c7f41fdde",
        "body" : "WIP further experiments suggest this can't be true, even tho this code works.",
        "createdAt" : "2018-08-23T13:49:14Z",
        "updatedAt" : "2018-08-23T13:49:15Z",
        "lastEditedBy" : "348fab8e-49e2-442e-884d-850c7f41fdde",
        "tags" : [
        ]
      },
      {
        "id" : "607bcc0f-541a-4c47-8cdc-8c2136376d6d",
        "parentId" : "ee4666a7-0790-4be1-b0d7-9ddca3f19de1",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "After normalization, we should not have them, so it should be fine or the normalization was not performed correctly.",
        "createdAt" : "2018-08-24T09:38:28Z",
        "updatedAt" : "2018-08-24T09:38:28Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      },
      {
        "id" : "2e302ce3-6b5f-408e-9c23-42af4c1b2ea9",
        "parentId" : "ee4666a7-0790-4be1-b0d7-9ddca3f19de1",
        "authorId" : "348fab8e-49e2-442e-884d-850c7f41fdde",
        "body" : "True after normalization — I thought that was also true before normalization, but that was wrong.",
        "createdAt" : "2018-08-24T20:10:35Z",
        "updatedAt" : "2018-08-24T20:10:35Z",
        "lastEditedBy" : "348fab8e-49e2-442e-884d-850c7f41fdde",
        "tags" : [
        ]
      }
    ],
    "commit" : "b5abba680d6e2ede470b1ccb5fc8b12d704ceb3a",
    "line" : 17,
    "diffHunk" : "@@ -1,1 +1085,1089 @@  /** Record an enclosing inlined call.\n    * EmptyTree calls (for parameters) cancel the next-enclosing call in the list instead of being added to it.\n    * We assume parameters are never nested inside parameters.\n    */\n  override def inlineContext(call: Tree)(implicit ctx: Context): Context = {"
  },
  {
    "id" : "ac6a8df0-28c4-42ea-9e10-5878bd422376",
    "prId" : 4199,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/4199#pullrequestreview-173469399",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "484cab60-1d60-4405-b9b4-9ab0f20edbee",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Missing documentation",
        "createdAt" : "2018-11-09T15:48:54Z",
        "updatedAt" : "2018-11-16T07:02:15Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      }
    ],
    "commit" : "f88ad867967c80e8827bef031f6188d620af5edf",
    "line" : 48,
    "diffHunk" : "@@ -1,1 +1192,1196 @@   * by `imp`.\n   */\n  def importSelections(imp: Import)(implicit ctx: Context): List[Select] = {\n    def imported(sym: Symbol, id: untpd.Ident, rename: Option[untpd.Ident]): List[Select] = {\n      // Give a zero-extent position to the qualifier to prevent it from being included several"
  },
  {
    "id" : "840578d3-bf01-4bb3-b2b9-7ecfd11837e4",
    "prId" : 4199,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/4199#pullrequestreview-175667202",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1ca74375-b78d-4fb6-8177-95e69ee3d6a8",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Why is this needed ?",
        "createdAt" : "2018-11-15T15:23:03Z",
        "updatedAt" : "2018-11-16T07:02:15Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "1b833a9c-ab53-4b0e-92cc-67b8e7cf5592",
        "parentId" : "1ca74375-b78d-4fb6-8177-95e69ee3d6a8",
        "authorId" : "e625ae4c-fba4-4c8f-9728-a669f65f1bcb",
        "body" : "This is to prevent the qualifier of the `Select` nodes that we generate from being added to the results and avoid duplicates. The original qualifier (with the real position) will already be considered in `namedTrees` when we handle the `Import` nodes.\r\n\r\nI added a comment in `def importSelections`.",
        "createdAt" : "2018-11-16T06:03:31Z",
        "updatedAt" : "2018-11-16T07:02:15Z",
        "lastEditedBy" : "e625ae4c-fba4-4c8f-9728-a669f65f1bcb",
        "tags" : [
        ]
      }
    ],
    "commit" : "f88ad867967c80e8827bef031f6188d620af5edf",
    "line" : 82,
    "diffHunk" : "@@ -1,1 +1226,1230 @@\n  /** Replaces all positions in `tree` with zero-extent positions */\n  private def focusPositions(tree: Tree)(implicit ctx: Context): Tree = {\n    val transformer = new tpd.TreeMap {\n      override def transform(tree: Tree)(implicit ctx: Context): Tree = {"
  },
  {
    "id" : "4d6604dd-8e59-40d7-9516-5112ff7682ce",
    "prId" : 1930,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/1930#pullrequestreview-19915731",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "00b6f22f-74be-4e76-929b-1f414999e926",
        "parentId" : null,
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "It might be cleaner to just override the `transform` as follows:\r\n```scala\r\noverride def transform(tree: Tree)(implicit ctx: Context): Tree = \r\n  if (tree.tpe.isError) tree else super.transform(tree)\r\n```",
        "createdAt" : "2017-02-02T10:44:03Z",
        "updatedAt" : "2017-02-02T10:44:03Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      },
      {
        "id" : "cee2f06a-2a1e-437f-98aa-021f6986b9a0",
        "parentId" : "00b6f22f-74be-4e76-929b-1f414999e926",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "I was debating what was simpler, and more efficient. I also first thought of overriding `transform`, but: (1) this requires a new `TreeMap` class in `tpd` (2) this adds a stackframe to each node traversal, which can add up. So I think the current approach is more lightweight in the end.",
        "createdAt" : "2017-02-02T23:15:01Z",
        "updatedAt" : "2017-02-02T23:15:01Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "4585dcbaeb75df072f1a50ea6b7a9cb3fcfad4ee",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +574,578 @@  }\n\n  override def skipTransform(tree: Tree)(implicit ctx: Context) = tree.tpe.isError\n\n  implicit class TreeOps[ThisTree <: tpd.Tree](val tree: ThisTree) extends AnyVal {"
  }
]
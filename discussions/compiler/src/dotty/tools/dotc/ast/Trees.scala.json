[
  {
    "id" : "1bb3b619-bc1a-434d-978b-0244343160c4",
    "prId" : 12541,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/12541#pullrequestreview-673019847",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bc2f0711-64f9-4c4e-992b-854265967b03",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Since this is an abstract method supposed to be implemented in a specific way by subclasses, it's important to document what it means.",
        "createdAt" : "2021-06-01T12:40:55Z",
        "updatedAt" : "2021-06-01T12:44:06Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      }
    ],
    "commit" : "c327d79104b6101a3f3a9535fa7103bd5f009442",
    "line" : 23,
    "diffHunk" : "@@ -1,1 +346,350 @@     *  code by `end this`, so it's `srcName` should return `this`.\n     */\n    protected def srcName(using Context): Name\n\n    final def withEndMarker(): self.type ="
  },
  {
    "id" : "e802d4df-c248-4b6e-ac22-9d2b11422996",
    "prId" : 11574,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/11574#pullrequestreview-604566445",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f6f708f9-bb9a-4aed-aedc-cc188fc09233",
        "parentId" : null,
        "authorId" : "128563de-a925-4397-af34-450c7978a8d2",
        "body" : "I tried this which did not need any attachments (I don't think its that important to do the point span for synthetic):\r\n```scala\r\ndef nameSpan(using Context): Span =\r\n  if span.exists then\r\n    val point = span.point\r\n    if name.toTermName == nme.ERROR then Span(point)\r\n    else if qualifier.span.start > span.start then // right associative\r\n      val realName = name.stripModuleClassSuffix.lastPart\r\n      Span(span.start, span.start + realName.length, point)\r\n    else\r\n      Span(point, span.end, point)\r\n  else span\r\n```",
        "createdAt" : "2021-03-04T21:14:14Z",
        "updatedAt" : "2021-03-05T10:25:47Z",
        "lastEditedBy" : "128563de-a925-4397-af34-450c7978a8d2",
        "tags" : [
        ]
      }
    ],
    "commit" : "a1b5b77612899e48057be8716f1c0a7366637ff4",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +417,421 @@        super.denot\n\n    def nameSpan(using Context): Span =\n      if span.exists then\n        val point = span.point"
  },
  {
    "id" : "d219d8c3-add6-49c6-b6ba-64260fba29e7",
    "prId" : 10182,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/10182#pullrequestreview-531533596",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9cd99aa2-a453-4b2b-9167-ee0ae408c13b",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Since they have the same fields and are handled in similar ways, Import and Export could have a common superclass, just like Apply and TypeApply inherit from GenericApply",
        "createdAt" : "2020-11-16T16:55:12Z",
        "updatedAt" : "2020-12-03T15:33:07Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "247165a4-ad69-4500-b0bc-948152f7d840",
        "parentId" : "9cd99aa2-a453-4b2b-9167-ee0ae408c13b",
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Ah, it looks like Export is not a DenotingTree unlike Import, but maybe it should? That would involve typing it with an ImportType just like Imports.",
        "createdAt" : "2020-11-16T16:57:17Z",
        "updatedAt" : "2020-12-03T15:33:07Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "ce8ee282-4a17-42db-8a71-043bb2757fa4",
        "parentId" : "9cd99aa2-a453-4b2b-9167-ee0ae408c13b",
        "authorId" : "128563de-a925-4397-af34-450c7978a8d2",
        "body" : "Thats a good idea I'll try that thanks, currently they are typed as Any lol",
        "createdAt" : "2020-11-16T17:14:15Z",
        "updatedAt" : "2020-12-03T15:33:07Z",
        "lastEditedBy" : "128563de-a925-4397-af34-450c7978a8d2",
        "tags" : [
        ]
      }
    ],
    "commit" : "2c6eeb2ccb328650161487df6132d8061a12bad7",
    "line" : 25,
    "diffHunk" : "@@ -1,1 +815,819 @@   *  an untyped thicket consisting of `name` and `rename`.\n   */\n  case class Export[-T >: Untyped] private[ast] (expr: Tree[T], selectors: List[untpd.ImportSelector])(implicit @constructorOnly src: SourceFile)\n    extends ImportOrExport[T] {\n      type ThisTree[-T >: Untyped] = Export[T]"
  },
  {
    "id" : "637ec24f-5843-4425-a4dc-ba210f5ab218",
    "prId" : 9900,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/9900#pullrequestreview-501330436",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "664c71fd-db5b-45ab-bb4f-89f6265e7c41",
        "parentId" : null,
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "I could not find which `hashCode` we are overriding. If it is indeed so we should just remove this override.",
        "createdAt" : "2020-10-02T14:23:32Z",
        "updatedAt" : "2020-10-03T12:03:32Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      },
      {
        "id" : "9ac25a46-ad78-46e7-942f-39db314d1c60",
        "parentId" : "664c71fd-db5b-45ab-bb4f-89f6265e7c41",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "We are overriding Object's hashcode, which is the same. But that way it is clear what we want. In fact, maybe we can emphasize this better by making `hasCode` and `equals` final.\r\n",
        "createdAt" : "2020-10-02T16:59:33Z",
        "updatedAt" : "2020-10-03T12:03:32Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "7e973efa-ca4c-4c37-8595-7ca0dbeb45d3",
        "parentId" : "664c71fd-db5b-45ab-bb4f-89f6265e7c41",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "Ok",
        "createdAt" : "2020-10-02T17:46:40Z",
        "updatedAt" : "2020-10-03T12:03:32Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      }
    ],
    "commit" : "0bb3107a9490c89f31af7b271ead2b6c02da9ea8",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +222,226 @@    }\n\n    override def hashCode(): Int = System.identityHashCode(this)\n    override def equals(that: Any): Boolean = this eq that.asInstanceOf[AnyRef]\n  }"
  },
  {
    "id" : "5debadb0-7a0b-4260-a81f-bd490a914ff8",
    "prId" : 9768,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/9768#pullrequestreview-492160250",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3ef85ced-9d37-48d7-b20d-e16b412cbc63",
        "parentId" : null,
        "authorId" : "223e67d6-1873-432a-9af9-f40b82a7eedd",
        "body" : "Is the `symbol.is(ExtensionMethod)` check necessary?",
        "createdAt" : "2020-09-19T17:50:43Z",
        "updatedAt" : "2020-09-19T17:50:43Z",
        "lastEditedBy" : "223e67d6-1873-432a-9af9-f40b82a7eedd",
        "tags" : [
        ]
      },
      {
        "id" : "e6eded6a-1544-4b3a-8567-9451a64460d7",
        "parentId" : "3ef85ced-9d37-48d7-b20d-e16b412cbc63",
        "authorId" : "128563de-a925-4397-af34-450c7978a8d2",
        "body" : "I was told once that mods may not always be copied over beyond some phase but I'm not sure about this ",
        "createdAt" : "2020-09-19T22:50:39Z",
        "updatedAt" : "2020-09-19T22:50:40Z",
        "lastEditedBy" : "128563de-a925-4397-af34-450c7978a8d2",
        "tags" : [
        ]
      }
    ],
    "commit" : "bc9438204f6446e00589d61f424ef07a9989ba72",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +345,349 @@          val realName = name.stripModuleClassSuffix.lastPart\n          var length = realName.length\n          if (mods.is(ExtensionMethod) || symbol.is(ExtensionMethod)) && name.isExtensionName then\n            length -= \"extension_\".length\n          Span(point, point + length, point)"
  },
  {
    "id" : "80b40ca2-3548-415b-a1db-3d97ea807f84",
    "prId" : 9605,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/9605#pullrequestreview-471782281",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "83b3bea6-8bd4-4f2e-b1c2-7550ebfafc0d",
        "parentId" : null,
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "In ee4b125, I'm trying:\r\n\r\n```Scala\r\n        var acc = x\r\n        var list = trees\r\n        while (!list.isEmpty) do\r\n          acc = apply(acc, list.head)\r\n          list = list.tail\r\n        acc\r\n```\r\n\r\nAfter tail-call optimization, the two versions are almost the same. Let's see if there is difference in benchmarks. ",
        "createdAt" : "2020-08-20T16:09:43Z",
        "updatedAt" : "2020-08-20T16:18:43Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "290c8f73-6a71-463b-a933-f35b3fe7319c",
        "parentId" : "83b3bea6-8bd4-4f2e-b1c2-7550ebfafc0d",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "I don't think there will be. If anything, the tail recursive version should be faster since it does a single type test per iteration instead of one each in isEmpty, head, and tail.\r\n",
        "createdAt" : "2020-08-20T16:21:18Z",
        "updatedAt" : "2020-08-20T16:21:18Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "38d49301-fb95-4566-9a2d-5ab40c66ffab",
        "parentId" : "83b3bea6-8bd4-4f2e-b1c2-7550ebfafc0d",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "In #9565, we get a slight speedup for Dotty. ",
        "createdAt" : "2020-08-20T16:24:06Z",
        "updatedAt" : "2020-08-20T16:24:07Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      }
    ],
    "commit" : "41aba4b6d71731a4a174900fc79f5310b10d6014",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +1384,1388 @@          case tree :: rest => fold(apply(x, tree), rest)\n          case Nil => x\n        fold(x, trees)\n\n      def foldOver(x: X, tree: Tree)(using Context): X ="
  },
  {
    "id" : "862355c7-cfa8-4b03-a308-9f95c0343b2d",
    "prId" : 9137,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/9137#pullrequestreview-427444453",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "60c1bad0-8b33-4117-8b9a-a57bc75b2326",
        "parentId" : null,
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "A conceptual question: if `Infix` and `Using` are mutually exclusive, would it be better to use attachment for `Infix` as well to avoid creating the class `InfixApply`? Something like:\r\n\r\n```Scala\r\ndef setApplyKind(kind: ApplyKind) = \r\n  putAttachment(untpd.ApplyKind, kind)\r\n  this\r\n\r\ndef applyKind: ApplyKind =\r\n  attachmentOrElse(untpd.ApplyKind, ApplyKind.Regular)\r\n```",
        "createdAt" : "2020-06-09T15:17:55Z",
        "updatedAt" : "2020-06-09T20:22:57Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "a92c2513-5cd7-4f30-844b-26030825c73e",
        "parentId" : "60c1bad0-8b33-4117-8b9a-a57bc75b2326",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Yes, I think that might be better. I'll try that out.\r\n",
        "createdAt" : "2020-06-09T18:46:04Z",
        "updatedAt" : "2020-06-09T20:22:57Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "6de432ae8bf12391d453e0fb3268ee1d288d083a",
    "line" : 18,
    "diffHunk" : "@@ -1,1 +456,460 @@    def setApplyKind(kind: ApplyKind) =\n      putAttachment(untpd.KindOfApply, kind)\n      this\n\n    def applyKind: ApplyKind ="
  },
  {
    "id" : "19cbc4da-e7dc-464e-a6d6-127f41430531",
    "prId" : 8808,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/8808#pullrequestreview-402002121",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "68bbe6b4-3502-4faa-9291-16d156e82365",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "This is good for uniformity but why would this make any difference for type test safety warnings ?",
        "createdAt" : "2020-04-28T16:00:59Z",
        "updatedAt" : "2020-04-29T12:04:28Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "e17094b1-a1da-43cd-9dd1-4faf2dfa7471",
        "parentId" : "68bbe6b4-3502-4faa-9291-16d156e82365",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "The following code shows why it matters:\r\n\r\n```Scala\r\ntrait Tree[-T]\r\n\r\nclass JavaSeqLiteral[T] extends Tree[T]\r\n\r\ntrait Type\r\n\r\nclass DummyTree extends JavaSeqLiteral[Any]\r\n\r\ndef foo1(tree: Tree[Type]) =\r\n  tree.isInstanceOf[JavaSeqLiteral[Type]]   // error\r\n\r\nfoo1(new DummyTree)\r\n```",
        "createdAt" : "2020-04-28T16:20:16Z",
        "updatedAt" : "2020-04-29T12:04:28Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      }
    ],
    "commit" : "841d19176f3fdc7da45e800634e9f3f6971c9add",
    "line" : 23,
    "diffHunk" : "@@ -1,1 +580,584 @@\n  /** Array(elems) */\n  class JavaSeqLiteral[-T >: Untyped] private[ast] (elems: List[Tree[T]], elemtpt: Tree[T])(implicit @constructorOnly src: SourceFile)\n    extends SeqLiteral(elems, elemtpt) {\n    override def toString: String = s\"JavaSeqLiteral($elems, $elemtpt)\""
  },
  {
    "id" : "69408dee-8fb3-4504-ad5f-e4105a3d6690",
    "prId" : 8360,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/8360#pullrequestreview-379042433",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0212069e-4176-4b57-b5fa-5131683398df",
        "parentId" : null,
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Why drop only implicit methods that are followed by some other method type? Should this not be done for all implicit methods?",
        "createdAt" : "2020-03-22T18:28:39Z",
        "updatedAt" : "2020-03-22T20:09:49Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "c84cf2f0-ce6f-440d-93a1-5a33487901fc",
        "parentId" : "0212069e-4176-4b57-b5fa-5131683398df",
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Note that I didn't write this code, I just moved it from tpd.scala That said, this drops methods whose result type is an implicit method, e.g. if you have `def foo(x: A)` and `def foo(x: A)(implicit y: B)`, it will pick the first alternative, which seems reasonable to me.",
        "createdAt" : "2020-03-22T20:07:41Z",
        "updatedAt" : "2020-03-22T20:09:49Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      }
    ],
    "commit" : "c41f1d4b2bc087cf5c678b1c2e391a371b4bfda3",
    "line" : 42,
    "diffHunk" : "@@ -1,1 +1537,1541 @@            .filter(tr => typeParamCount(tr) == targs.length)\n            .filter { _.widen match {\n              case MethodTpe(_, _, x: MethodType) => !x.isImplicitMethod\n              case _ => true\n            }}"
  },
  {
    "id" : "d6f405e7-24dc-4c0a-9cf3-25c4c125c020",
    "prId" : 6748,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/6748#pullrequestreview-255043762",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5c066006-d0a8-4e21-9fac-c804504ee4ab",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Do we have a test case that exercises this ?",
        "createdAt" : "2019-06-26T18:15:31Z",
        "updatedAt" : "2019-06-26T18:15:31Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "474aead1-8691-442a-8424-5252a933c651",
        "parentId" : "5c066006-d0a8-4e21-9fac-c804504ee4ab",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "The original test case was ErrorMessagesID, and I verified that the change here works for it. But c8265f1 fixes the problem by another means, so  it's no longer a test case.\r\n",
        "createdAt" : "2019-06-27T07:16:12Z",
        "updatedAt" : "2019-06-27T07:16:13Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "1a1f424958ed1df0face143ca473eb671f594a6c",
    "line" : 10,
    "diffHunk" : "@@ -1,1 +357,361 @@            if (point != span.start) point\n            else {\n              // Point might be too far away from start to be recorded. In this case we fall back to scanning\n              // forwards from the start offset for the name.\n              // Note: This might be inaccurate since scanning might hit accidentally the same"
  },
  {
    "id" : "b9c4af06-eabc-4e6b-a94f-d99f33d56f44",
    "prId" : 5883,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/5883#pullrequestreview-203722590",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1f71c0d7-fd66-436f-be13-ff3f02344a49",
        "parentId" : null,
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "I remember from #5892 there used to be a check `sameSourceFile` in the case, why it is not needed anymore?",
        "createdAt" : "2019-02-14T12:43:13Z",
        "updatedAt" : "2019-02-14T12:43:13Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      }
    ],
    "commit" : "ec208695a8ec9989b5d3788ba8ecfb9f9f76e969",
    "line" : 167,
    "diffHunk" : "@@ -1,1 +1113,1117 @@      }\n      def AppliedTypeTree(tree: Tree)(tpt: Tree, args: List[Tree])(implicit ctx: Context): AppliedTypeTree = tree match {\n        case tree: AppliedTypeTree if (tpt eq tree.tpt) && (args eq tree.args) => tree\n        case _ => finalize(tree, untpd.AppliedTypeTree(tpt, args)(sourceFile(tree)))\n      }"
  },
  {
    "id" : "de199c50-a64c-44c7-abed-7b52b02ae6e4",
    "prId" : 5540,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/5540#pullrequestreview-193047031",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "358476a9-ef42-4206-a529-4b80020c156f",
        "parentId" : null,
        "authorId" : "6d71bb21-e402-4464-b2b1-8bdd8e068461",
        "body" : "Should it be `Tree[T]` here? Then I think the two `.derived.asInstanceOf[List[TypeTree]]` casts in `TreeOpsImpl.scala` wouldn't be needed.",
        "createdAt" : "2019-01-15T14:58:37Z",
        "updatedAt" : "2019-01-19T16:40:59Z",
        "lastEditedBy" : "6d71bb21-e402-4464-b2b1-8bdd8e068461",
        "tags" : [
        ]
      },
      {
        "id" : "d4c04e55-6541-43a6-9d60-6357b1f09677",
        "parentId" : "358476a9-ef42-4206-a529-4b80020c156f",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "`derived` only exist as untyped trees. Typed trees contain `derived$...` members instead. It would be pointless to keep typed `derived` trees around, as the info in them is never relevant.\r\n\r\n",
        "createdAt" : "2019-01-16T09:44:06Z",
        "updatedAt" : "2019-01-19T16:40:59Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "5e4fa24b6ef68b20f91541da8b6a779426a5cd03",
    "line" : 28,
    "diffHunk" : "@@ -1,1 +753,757 @@\n    def parents: List[Tree[T]] = parentsOrDerived // overridden by DerivingTemplate\n    def derived: List[untpd.Tree] = Nil           // overridden by DerivingTemplate\n  }\n"
  },
  {
    "id" : "2fea3d94-2e8d-420e-a42b-a374dacb7c4b",
    "prId" : 4616,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/4616#pullrequestreview-138317885",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0e241a09-6a0e-470f-9d99-42e2fe2546d4",
        "parentId" : null,
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "Was there a specific reason to add it as an extra method?",
        "createdAt" : "2018-07-18T13:42:25Z",
        "updatedAt" : "2018-07-26T14:54:44Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      },
      {
        "id" : "46322239-dbaa-4b75-84ae-04177a4743c1",
        "parentId" : "0e241a09-6a0e-470f-9d99-42e2fe2546d4",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Performance. If we add a rare case, we only override `transformMoreCases`. Before the rare case was in the overridden `transform`. So every match had to first look at the rare cases before it would forward to `super.transform`.\r\n",
        "createdAt" : "2018-07-18T15:43:39Z",
        "updatedAt" : "2018-07-26T14:54:44Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "88e7d180574eda8a71037d1735ac6a3ff76a1c08",
    "line" : 47,
    "diffHunk" : "@@ -1,1 +1257,1261 @@            if (trees1 eq trees) tree else Thicket(trees1)\n          case _ =>\n            transformMoreCases(tree)\n        }\n      }"
  },
  {
    "id" : "ef125226-45b9-4255-af31-b4093b72550f",
    "prId" : 4616,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/4616#pullrequestreview-139254544",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b75bf9f0-5793-44dc-ba2a-eae59226684a",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "So, why define this case here instead of in TypedTreeMap?",
        "createdAt" : "2018-07-20T20:32:36Z",
        "updatedAt" : "2018-07-26T14:54:44Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "eba77389-94b1-426f-af6a-7fde04f7a9b8",
        "parentId" : "b75bf9f0-5793-44dc-ba2a-eae59226684a",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "There is no `TypedTreeMap` and this addition did not seem sufficient reason to me to create one.  Mostly because I was worried that creating more indirections in tree maps would hurt performance.",
        "createdAt" : "2018-07-21T10:06:46Z",
        "updatedAt" : "2018-07-26T14:54:44Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "88e7d180574eda8a71037d1735ac6a3ff76a1c08",
    "line" : 60,
    "diffHunk" : "@@ -1,1 +1274,1278 @@          // For a typed tree map: homomorphism on the untyped part with\n          // recursive mapping of typed splices.\n          // The case is overridden in UntypedTreeMap.##\n          val untpdMap = new untpd.UntypedTreeMap {\n            override def transform(tree: untpd.Tree)(implicit ctx: Context): untpd.Tree = tree match {"
  },
  {
    "id" : "c6b30c64-2533-4212-af88-6281cc5befe0",
    "prId" : 3366,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/3366#pullrequestreview-72130952",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1c8b0d82-09a7-4a11-bc5b-3ea27f27d11c",
        "parentId" : null,
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "I would add a comment describing which tag numbers can be reused and why. ",
        "createdAt" : "2017-10-25T14:17:47Z",
        "updatedAt" : "2017-10-26T12:40:32Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      },
      {
        "id" : "3157c71b-e8b0-47f2-b0c2-f876cb6fc740",
        "parentId" : "1c8b0d82-09a7-4a11-bc5b-3ea27f27d11c",
        "authorId" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "body" : "👍 It's not clear for me why are they reused.",
        "createdAt" : "2017-10-26T06:06:23Z",
        "updatedAt" : "2017-10-26T12:40:32Z",
        "lastEditedBy" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "tags" : [
        ]
      },
      {
        "id" : "edaf178a-9b0d-4056-b48d-8c4a912783d1",
        "parentId" : "1c8b0d82-09a7-4a11-bc5b-3ea27f27d11c",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "There's no re-use: NumTypeTreeTags is a counter, not a tag. I'll add a comment to make that clearer.",
        "createdAt" : "2017-10-26T09:34:29Z",
        "updatedAt" : "2017-10-26T12:40:32Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "5a41b3e7b0a8f522c82a3686a0e22481afcfbeb9",
    "line" : 57,
    "diffHunk" : "@@ -1,1 +73,77 @@    final val TypedSplice = 40\n    final val ModuleDef = 41\n    final val ParsedTry = 42\n    final val SymbolLit = 43\n    final val InterpolatedString = 44"
  },
  {
    "id" : "03f07d6e-9d3c-4890-a9db-ead814cb27d0",
    "prId" : 3366,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/3366#pullrequestreview-72132359",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "26cfa3be-6543-4d87-a233-59ec18390f73",
        "parentId" : null,
        "authorId" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "body" : "We can use the same tags that are used in tasty. WDYT?",
        "createdAt" : "2017-10-26T05:56:00Z",
        "updatedAt" : "2017-10-26T12:40:32Z",
        "lastEditedBy" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "tags" : [
        ]
      },
      {
        "id" : "8ca55c49-1147-444b-af89-340d17ae5814",
        "parentId" : "26cfa3be-6543-4d87-a233-59ec18390f73",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "We could try, but then the switches will not be dense anymore, so will most likely not be implemented by a table switch.",
        "createdAt" : "2017-10-26T09:37:41Z",
        "updatedAt" : "2017-10-26T12:40:32Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "d3cf521d-947c-4b71-a298-9caa2a7fc0e6",
        "parentId" : "26cfa3be-6543-4d87-a233-59ec18390f73",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Also, in that case unpickled trees would not have tags, so we could not use tags for e.g. typer.",
        "createdAt" : "2017-10-26T09:39:35Z",
        "updatedAt" : "2017-10-26T12:40:32Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "5a41b3e7b0a8f522c82a3686a0e22481afcfbeb9",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +23,27 @@\n  object Tag {\n    final val Ident = 0\n    final val Select = 1\n    final val This = 2"
  },
  {
    "id" : "cddf68b8-5218-47d3-8499-706eba78c045",
    "prId" : 1972,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/1972#pullrequestreview-22207257",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c363e38a-c0bf-4db9-bba7-b5b4d7fda3f7",
        "parentId" : null,
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "derived from",
        "createdAt" : "2017-02-16T09:45:43Z",
        "updatedAt" : "2017-02-16T09:46:32Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "f04f8db9143dab8960d4577974856ee9a62d5909",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +1079,1083 @@\n    /** For untyped trees, this is just the identity.\n     *  For typed trees, a context derived form `ctx` that records `call` as the\n     *  innermost enclosing call for which the inlined version is currently\n     *  processed."
  }
]
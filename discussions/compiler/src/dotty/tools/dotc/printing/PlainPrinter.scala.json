[
  {
    "id" : "3fa09feb-07f1-4d23-a67c-41436aa43f1c",
    "prId" : 9527,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/9527#pullrequestreview-464993108",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ed59de00-33a7-49db-9ff5-9004ab26effc",
        "parentId" : null,
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "The infinite recursion happens here. The message may print a tree that contains this error type again.",
        "createdAt" : "2020-08-11T09:02:41Z",
        "updatedAt" : "2020-08-11T09:02:41Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      },
      {
        "id" : "862f4a45-ad2e-4d85-9e76-eb3c2636ecd7",
        "parentId" : "ed59de00-33a7-49db-9ff5-9004ab26effc",
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "PlainPrinter already has some logic to avoid infinite loops with `limiter` and `maxToTextRecursions`, it'd be good to see if we can extend that to also account for the loops here",
        "createdAt" : "2020-08-11T11:55:33Z",
        "updatedAt" : "2020-08-11T11:55:33Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      }
    ],
    "commit" : "cf38826926e59ac38b36912fab50420885385155",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +181,185 @@        \"<error>\" // do not print previously reported error message because they may try to print this error type again recuresevely\n      case tp: ErrorType =>\n        s\"<error ${tp.msg.rawMessage}>\"\n      case tp: WildcardType =>\n        if (tp.optBounds.exists) \"<?\" ~ toTextRHS(tp.bounds) ~ \">\" else \"<?>\""
  },
  {
    "id" : "c50b8cdf-555c-499b-b1cb-604a039b0202",
    "prId" : 3705,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/3705#pullrequestreview-88670257",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "13c56326-d245-4a23-8c54-a5bbfbb55c8d",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Couldn't we do a null check first instead of catching NullPointerException ? This is fishy in general and is also not something that can be done on Scala.js by default (https://www.scala-js.org/doc/semantics.html)",
        "createdAt" : "2017-12-28T16:59:26Z",
        "updatedAt" : "2018-01-15T09:22:22Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "4941f38e-fab2-4347-a356-cfa50a184487",
        "parentId" : "13c56326-d245-4a23-8c54-a5bbfbb55c8d",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "No, hashCode is computed, the null could be in a referenced type.",
        "createdAt" : "2018-01-14T00:10:07Z",
        "updatedAt" : "2018-01-15T09:22:22Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "03c6526eb0c2fc97d64030d7c836c84b5882c30a",
    "line" : 21,
    "diffHunk" : "@@ -1,1 +225,229 @@    if (ctx.settings.uniqid.value)\n      try \"#\" + pt.hashCode\n      catch { case ex: NullPointerException => \"\" }\n    else \"\"\n"
  },
  {
    "id" : "568a6db3-a43d-4afe-9fe2-63f5f24b97b0",
    "prId" : 3705,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/3705#pullrequestreview-88670289",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "53f5091c-028f-45aa-ae90-a011fd623648",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Is this just to catch infinite loops in LazyRefs? If so I'd just catch StackOverflowException, though I think it'd be cleaner to do loop detection in `LazyRef#ref`.",
        "createdAt" : "2017-12-28T17:07:45Z",
        "updatedAt" : "2018-01-15T09:22:22Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "4410cd46-fa78-49ef-8e67-9f693f577cd7",
        "parentId" : "53f5091c-028f-45aa-ae90-a011fd623648",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Yes, it's to detect stack overflows. Evaluation of LazyRefs is not tail-recursive, so we will always get a stack overflow. Maybe we can do a better job in loop detection but I believe the two issues are separate.",
        "createdAt" : "2018-01-14T00:12:16Z",
        "updatedAt" : "2018-01-15T09:22:22Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "03c6526eb0c2fc97d64030d7c836c84b5882c30a",
    "line" : 8,
    "diffHunk" : "@@ -1,1 +200,204 @@          try toTextGlobal(tp.ref)\n          catch {\n            case ex: Throwable => Str(\"...\")\n          }\n        \"LazyRef(\" ~ refTxt ~ \")\""
  },
  {
    "id" : "910cc457-da20-4e3f-99b6-5b570e09cb4a",
    "prId" : 3464,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/3464#pullrequestreview-76743818",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0c7a0827-7aee-452e-be61-8b59e1375a89",
        "parentId" : null,
        "authorId" : "6d71bb21-e402-4464-b2b1-8bdd8e068461",
        "body" : "I think something is wrong with the way dependent function types are printed:\r\n\r\n```scala\r\nscala> val depfun1: DF = (x: C) => x.m\r\nval depfun1: (C => ){apply: (x: C): } = <function1>\r\n```",
        "createdAt" : "2017-11-14T10:34:16Z",
        "updatedAt" : "2017-11-27T14:52:13Z",
        "lastEditedBy" : "6d71bb21-e402-4464-b2b1-8bdd8e068461",
        "tags" : [
        ]
      },
      {
        "id" : "8266c804-172e-4bca-ac70-474922b7fdea",
        "parentId" : "0c7a0827-7aee-452e-be61-8b59e1375a89",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Should be fixed now.",
        "createdAt" : "2017-11-15T10:55:08Z",
        "updatedAt" : "2017-11-27T14:52:13Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "28a29eabf7a64901706bae075402f2b023ec0e65",
    "line" : 12,
    "diffHunk" : "@@ -1,1 +153,157 @@      case tp: TypeParamRef =>\n        ParamRefNameString(tp) ~ lambdaHash(tp.binder)\n      case tp: SingletonType =>\n        toTextLocal(tp.underlying) ~ \"(\" ~ toTextRef(tp) ~ \")\"\n      case AppliedType(tycon, args) =>"
  },
  {
    "id" : "3b05ea57-e2f6-4f26-83e7-b6d686267da9",
    "prId" : 3061,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/3061#pullrequestreview-62739344",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c87391df-b4ca-4475-9bd5-42917998a756",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Can `<unknown>` legitimately happen or is this always af bug?",
        "createdAt" : "2017-09-14T01:25:42Z",
        "updatedAt" : "2017-09-20T15:20:35Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "5db559dd-57d2-4bd8-883d-4044dc61888d",
        "parentId" : "c87391df-b4ca-4475-9bd5-42917998a756",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "It's a bug, but printers have to survive bugs.",
        "createdAt" : "2017-09-14T12:56:08Z",
        "updatedAt" : "2017-09-20T15:20:35Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "2e65bd581c7506e1a382d906a9c8a961fafabfff",
    "line" : 37,
    "diffHunk" : "@@ -1,1 +166,170 @@        val cls = clsRef.symbol\n        val tparams = cls.typeParams\n        val paramName = if (tparams.length > idx) nameString(tparams(idx)) else \"<unknown>\"\n        toTextPrefix(prefix) ~ s\"<parameter $paramName of \" ~ toText(cls) ~ \">\"\n      case AndType(tp1, tp2) =>"
  },
  {
    "id" : "19e3aee9-83e3-4dfc-b4b0-dd43fac01424",
    "prId" : 1918,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/1918#pullrequestreview-19949650",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "29353ff1-10cc-4323-82ec-8d7a57b11695",
        "parentId" : null,
        "authorId" : "6d71bb21-e402-4464-b2b1-8bdd8e068461",
        "body" : "Could we seal `SearchResult` instead of having a default case?",
        "createdAt" : "2017-01-31T11:24:04Z",
        "updatedAt" : "2017-02-08T08:36:15Z",
        "lastEditedBy" : "6d71bb21-e402-4464-b2b1-8bdd8e068461",
        "tags" : [
        ]
      },
      {
        "id" : "245c7304-e8f8-4b83-a796-2d05b6c64279",
        "parentId" : "29353ff1-10cc-4323-82ec-8d7a57b11695",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Looks like we can",
        "createdAt" : "2017-02-02T23:32:33Z",
        "updatedAt" : "2017-02-08T08:36:15Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "0985b186-dd42-4633-a431-44e3ecd07083",
        "parentId" : "29353ff1-10cc-4323-82ec-8d7a57b11695",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "No, in fact we cannot. There are too many other cases we'd have to handle. E.g. ExplainedSearchResult. Sometimes it's better not to seal.\r\n",
        "createdAt" : "2017-02-03T05:10:16Z",
        "updatedAt" : "2017-02-08T08:36:15Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "56d32fa7bd548870c8382824fe748c5c5fde1d27",
    "line" : 25,
    "diffHunk" : "@@ -1,1 +499,503 @@    case result: AmbiguousImplicits =>\n      \"Ambiguous Implicit: \" ~ toText(result.alt1) ~ \" and \" ~ toText(result.alt2)\n    case _ =>\n      \"?Unknown Implicit Result?\"\n  }"
  }
]
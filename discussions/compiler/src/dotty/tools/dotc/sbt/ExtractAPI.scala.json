[
  {
    "id" : "6096c788-bff7-482c-901a-c074d09713d5",
    "prId" : 8637,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/8637#pullrequestreview-384218863",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0a15fd56-e3ad-4fc6-9256-d4baf911f847",
        "parentId" : null,
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "@smarter I am not sure whether we need the parameter type `ptype`\r\nin the method type to produce an api type, or whether the type of the\r\nparameter symbol is enough. In the latter case, `paramLists` can be \r\nmuch simpler; a simple `nestedMap` instead of the recursion suffices.\r\n",
        "createdAt" : "2020-03-30T19:25:53Z",
        "updatedAt" : "2020-04-03T07:22:59Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "461b0583-8659-4156-aee7-d6f0c4ea2caa",
        "parentId" : "0a15fd56-e3ad-4fc6-9256-d4baf911f847",
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "We need the fully parameter type: if any of its part change, that's a possible API change and some code might need to be recompiled.",
        "createdAt" : "2020-03-30T19:36:04Z",
        "updatedAt" : "2020-04-03T07:22:59Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "fb375d9a-e38d-4ef0-97e7-e5121bda7442",
        "parentId" : "0a15fd56-e3ad-4fc6-9256-d4baf911f847",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "But `ptype` and the parameter symbol's type are usually isomorphic, right? It's just that one refers to internal parameter symbols and the other to external paramRefs.\r\n",
        "createdAt" : "2020-03-30T19:40:01Z",
        "updatedAt" : "2020-04-03T07:22:59Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "d3a7817d-aeb4-499d-9ff0-5407d452a289",
        "parentId" : "0a15fd56-e3ad-4fc6-9256-d4baf911f847",
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Ah I see, I haven't checked this PR in detail yet so I can't say but I guess it's fine then",
        "createdAt" : "2020-03-30T19:51:23Z",
        "updatedAt" : "2020-04-03T07:22:59Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "9af0f801-39e1-4c67-9909-c7b9f41f49a0",
        "parentId" : "0a15fd56-e3ad-4fc6-9256-d4baf911f847",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "I don't know about the fine print though. E.g. does internal vs external representation of varargs matter?\r\n",
        "createdAt" : "2020-03-30T20:00:00Z",
        "updatedAt" : "2020-04-03T07:22:59Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "8d30fca4-0344-4031-9563-4568c9c449f0",
        "parentId" : "0a15fd56-e3ad-4fc6-9256-d4baf911f847",
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "As long as the varargs gets represented by an api type which doesn't match some other non-varargs type it should be fine, both representations should have this propriety but I'll double-check. Are there other situations where the types differ?",
        "createdAt" : "2020-03-30T20:03:43Z",
        "updatedAt" : "2020-04-03T07:22:59Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "6ad11e2f-bed2-48eb-9954-99c4ee72ab2b",
        "parentId" : "0a15fd56-e3ad-4fc6-9256-d4baf911f847",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "I can't think of anything else.\r\n",
        "createdAt" : "2020-03-30T20:49:02Z",
        "updatedAt" : "2020-04-03T07:22:59Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "7e8014ebb26d54bf3c589321e4f2c83de44339a0",
    "line" : 30,
    "diffHunk" : "@@ -1,1 +344,348 @@        assert(paramss.nonEmpty && paramss.head.hasSameLengthAs(pnames),\n          i\"mismatch for $sym, ${sym.info}, ${sym.paramSymss}\")\n        val apiParams = paramss.head.lazyZip(ptypes).map((param, ptype) =>\n          api.MethodParameter.of(param.name.toString, apiType(ptype),\n          param.is(HasDefault), api.ParameterModifier.Plain))"
  },
  {
    "id" : "7db2d1be-42a0-4733-b63c-e02d421ad7a9",
    "prId" : 8359,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/8359#pullrequestreview-363078616",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f693396f-0920-4699-b9f8-0e550f359a92",
        "parentId" : null,
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "The comment above also needs to be updated",
        "createdAt" : "2020-02-23T08:31:26Z",
        "updatedAt" : "2020-02-26T19:07:23Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      }
    ],
    "commit" : "b952d4180cf43bf74e48c821b291f1cc8fd55dc3",
    "line" : 28,
    "diffHunk" : "@@ -1,1 +624,628 @@    api.Annotation.of(\n      apiType(annot.tree.tpe), // Used by sbt to find tests to run\n      Array(api.AnnotationArgument.of(\"FULLTREE\", annot.tree.toString)))\n  }\n}"
  },
  {
    "id" : "d2de9a59-2add-4ba6-b8e4-21c678b6ea76",
    "prId" : 6980,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/6980#pullrequestreview-270464669",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a9639670-4366-4d1f-a190-ce58a82abe30",
        "parentId" : null,
        "authorId" : "223e67d6-1873-432a-9af9-f40b82a7eedd",
        "body" : "Should this comment be moved to `hasMainMethod` where the test is performed?",
        "createdAt" : "2019-08-03T09:22:56Z",
        "updatedAt" : "2019-08-03T09:22:56Z",
        "lastEditedBy" : "223e67d6-1873-432a-9af9-f40b82a7eedd",
        "tags" : [
        ]
      },
      {
        "id" : "06a6288b-3438-4757-9f9d-da3d8893e1f9",
        "parentId" : "a9639670-4366-4d1f-a190-ce58a82abe30",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "There's another caller of hasMainMethod in the backend. Not knowing what\r\nthis does or expects, I am not sure whether the change\r\nis OK or not.",
        "createdAt" : "2019-08-03T10:10:39Z",
        "updatedAt" : "2019-08-03T10:10:39Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "e96195df-b4da-4ad7-a220-174126c33b99",
        "parentId" : "a9639670-4366-4d1f-a190-ce58a82abe30",
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "So the other caller is https://github.com/lampepfl/dotty/blob/95ae77c4748bd105de45601875b447ee1fe6a98b/compiler/src/dotty/tools/dotc/transform/CollectEntryPoints.scala#L66-L67\r\nwhich will emit a warning if there's a main method in an object and also a main method in the companion class of the object, and we do want the warning even if the main method in the companion class is not static, since its mere presence means that the backend will not generate a static forwarder from the main in the object to the companion class.",
        "createdAt" : "2019-08-03T14:01:53Z",
        "updatedAt" : "2019-08-03T14:01:54Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "102f38bf-4e1b-4794-8d8a-7eacfe12424b",
        "parentId" : "a9639670-4366-4d1f-a190-ce58a82abe30",
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "The situation is very confusing because there's two source files called CollectEntryPoints and none of them actually work, I've made a separate PR to cleanup things a bit: https://github.com/lampepfl/dotty/pull/6981/commits/89801f96a689b7626a99b5513c557e788a581717",
        "createdAt" : "2019-08-03T14:45:13Z",
        "updatedAt" : "2019-08-03T14:45:13Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "e2f609f6-e0f5-4eb0-8d36-a6513299a74e",
        "parentId" : "a9639670-4366-4d1f-a190-ce58a82abe30",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "@smarter Do you want to take this over, or should we merge as is? I don't have the time to do more work on this.\r\n",
        "createdAt" : "2019-08-03T16:02:08Z",
        "updatedAt" : "2019-08-03T16:02:08Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "8a3726716599e367de89ba5d7c388dc2779bc579",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +232,236 @@\n    if (sym.isStatic && !sym.is(Trait) && ctx.platform.hasMainMethod(sym)) {\n       // If sym is an object, all main methods count, otherwise only @static ones count.\n      _mainClasses += name\n    }"
  },
  {
    "id" : "143dce1d-8413-4b12-8bca-33e0b38f1d7e",
    "prId" : 6898,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/6898#pullrequestreview-267284481",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ed4624f9-5b54-4860-9b9d-f545ab33424a",
        "parentId" : null,
        "authorId" : "223e67d6-1873-432a-9af9-f40b82a7eedd",
        "body" : "I think you need to drop `sym.isStatic` to allow classes to have `main` method.",
        "createdAt" : "2019-07-26T16:26:33Z",
        "updatedAt" : "2019-07-29T16:55:34Z",
        "lastEditedBy" : "223e67d6-1873-432a-9af9-f40b82a7eedd",
        "tags" : [
        ]
      }
    ],
    "commit" : "eb374a15d3918a661e6d06098b26347dcad3319c",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +231,235 @@    allNonLocalClassesInSrc += cl\n\n    if (sym.isStatic && ctx.platform.hasMainMethod(sym)) {\n      _mainClasses += name\n    }"
  },
  {
    "id" : "df8feb74-8942-49c1-bdac-7bcb3977f3dd",
    "prId" : 3280,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/3280#pullrequestreview-67835670",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5fe99d21-dd5f-4d0e-b909-0cb8af00d884",
        "parentId" : null,
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "I have no idea what this is supposed to achieve.",
        "createdAt" : "2017-10-07T15:26:40Z",
        "updatedAt" : "2017-10-07T15:27:37Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "d2c7be25-0818-4016-9f64-ff4d13cbc220",
        "parentId" : "5fe99d21-dd5f-4d0e-b909-0cb8af00d884",
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Basically fitting a square peg in a round hole: sbt has its own representation of types which doesn't include anything like TypeArgRef, but we can still get incremental compilation to work correctly if we can find a bijection between dotty's types and sbt's types, since the only thing that matter is that the hash of the sbt type changes when the dotty type changes. Don't worry too much about it :).",
        "createdAt" : "2017-10-07T15:30:20Z",
        "updatedAt" : "2017-10-07T15:30:21Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      }
    ],
    "commit" : "0b565cb1326dccf96ced568424da34d37be0c2ee",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +346,350 @@\n  // Hack to represent dotty types which don't have an equivalent in xsbti\n  def combineApiTypes(apiTps: api.Type*): api.Type = {\n    new api.Structure(strict2lzy(apiTps.toArray),\n      strict2lzy(Array()), strict2lzy(Array()))"
  }
]
[
  {
    "id" : "5b91aab1-d0ea-43b3-bb77-ea58ca5d4be1",
    "prId" : 9864,
    "prUrl" : "https://github.com/digital-asset/daml/pull/9864",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "348e84b1-ac67-4a5f-8500-3b5e6881f290",
        "parentId" : null,
        "authorId" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "body" : "Is there an intuition for what we special case here and what we don’t?\r\nIt seems like it’s all monomorphized typeclass methods are special cased? If so I think `throw` should also fall under this.\r\nI’m not quite sure about `create` and friends. It seems like they should also fall under this but afaict we don’t special case them.\r\nOr am I just searching for a pattern that does not exist and the truth is that we do it more or less randomly?",
        "createdAt" : "2021-06-01T10:05:10Z",
        "updatedAt" : "2021-06-01T10:11:32Z",
        "lastEditedBy" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "tags" : [
        ]
      },
      {
        "id" : "86d41789-e46e-4817-83a9-6bc46d46ee40",
        "parentId" : "348e84b1-ac67-4a5f-8500-3b5e6881f290",
        "authorId" : "f7ed27fc-83ac-401f-af8b-91c645eda7e9",
        "body" : "I don't think there's a consistent pattern... :'-(\r\n\r\nMy intuition is that for something simple like create/throw/etc the simplifier eliminates the indirection, but for `UBind` and other expressions that introduce binders in the LF, or have an unusual form, it's going to struggle.",
        "createdAt" : "2021-06-01T10:19:55Z",
        "updatedAt" : "2021-06-01T10:19:55Z",
        "lastEditedBy" : "f7ed27fc-83ac-401f-af8b-91c645eda7e9",
        "tags" : [
        ]
      },
      {
        "id" : "d95a309e-ffa4-483d-8437-4fcabddb4b4a",
        "parentId" : "348e84b1-ac67-4a5f-8500-3b5e6881f290",
        "authorId" : "f7ed27fc-83ac-401f-af8b-91c645eda7e9",
        "body" : "Maybe the pattern is closer to \"does this have special control flow\"?  (And \"pure\" is special cased to make the output of LFConversion more readable.)",
        "createdAt" : "2021-06-01T10:24:38Z",
        "updatedAt" : "2021-06-01T10:24:38Z",
        "lastEditedBy" : "f7ed27fc-83ac-401f-af8b-91c645eda7e9",
        "tags" : [
        ]
      },
      {
        "id" : "1e7daae6-08c8-4e1f-9c93-5efbbf247e09",
        "parentId" : "348e84b1-ac67-4a5f-8500-3b5e6881f290",
        "authorId" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "body" : "Probably better to just admit that we don’t have a pattern and try to either introduce one or just accept that it’s a case by case decision. At least I can stop searching for a pattern now :slightly_smiling_face: ",
        "createdAt" : "2021-06-01T10:36:59Z",
        "updatedAt" : "2021-06-01T10:36:59Z",
        "lastEditedBy" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "tags" : [
        ]
      }
    ],
    "commit" : "85a640150eefb76ca445a8022bbc7c82290d5a10",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +1144,1148 @@            let bind' = EVal semi'{qualObject = mkVal \">>=\"}\n            pure $ mkEApps bind' [TyArg monad', TmArg dict', TyArg t1', TyArg t2', TmArg x', TmArg (ETmLam (mkVar \"_\", t1') y')]\n    go env tryCatch@(VarIn DA_Internal_Exception \"_tryCatch\") allArgs@(LType monad : LExpr _dict : LType t : LExpr x : LExpr (Lam b y) : args) = do\n        monad' <- convertType env monad\n        case monad' of"
  },
  {
    "id" : "7815462c-788e-4c74-b417-d8df1e6db918",
    "prId" : 9381,
    "prUrl" : "https://github.com/digital-asset/daml/pull/9381",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5c1febeb-aa6c-4a2d-8ede-cdcaa93eb3ad",
        "parentId" : null,
        "authorId" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "body" : "I assume that’s because in Core a pattern match on a literal is already an equality + a case on the result of that?",
        "createdAt" : "2021-04-12T14:01:47Z",
        "updatedAt" : "2021-04-13T13:24:40Z",
        "lastEditedBy" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "tags" : [
        ]
      },
      {
        "id" : "31887049-f92d-4a01-a94a-374f48e11065",
        "parentId" : "5c1febeb-aa6c-4a2d-8ede-cdcaa93eb3ad",
        "authorId" : "f7ed27fc-83ac-401f-af8b-91c645eda7e9",
        "body" : "Yes 🙃 ",
        "createdAt" : "2021-04-12T14:59:42Z",
        "updatedAt" : "2021-04-13T13:24:40Z",
        "lastEditedBy" : "f7ed27fc-83ac-401f-af8b-91c645eda7e9",
        "tags" : [
        ]
      }
    ],
    "commit" : "38e3a4b8c1178583667cdff57390fc6fe15f44b8",
    "line" : 24,
    "diffHunk" : "@@ -1,1 +1205,1209 @@    go env o@(Case scrutinee bind resultType [alt@(DataAlt con, vs, x)]) args = fmap (, args) $ do\n        convertType env (varType bind) >>= \\case\n            -- opaque types have no patterns that can be matched\n            TText -> asLet\n            TDecimal -> asLet"
  },
  {
    "id" : "163533e5-d84d-4296-bf53-d2b9ec78a136",
    "prId" : 9289,
    "prUrl" : "https://github.com/digital-asset/daml/pull/9289",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fd9bf1cc-96c3-4487-8975-fd92b3d67f1e",
        "parentId" : null,
        "authorId" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "body" : "Can this ever happen or are we save here because users have to specify literals as decimals? If the latter, maybe worth adding a comment that this is just for extra safety.",
        "createdAt" : "2021-03-31T08:16:03Z",
        "updatedAt" : "2021-03-31T10:17:15Z",
        "lastEditedBy" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "tags" : [
        ]
      },
      {
        "id" : "392bb2ed-2be3-49dd-a42a-c17c0ea979c3",
        "parentId" : "fd9bf1cc-96c3-4487-8975-fd92b3d67f1e",
        "authorId" : "f7ed27fc-83ac-401f-af8b-91c645eda7e9",
        "body" : "I think we're safe. It's just to prevent someone from misusing this function. I'll add a comment.",
        "createdAt" : "2021-03-31T09:16:10Z",
        "updatedAt" : "2021-03-31T10:17:15Z",
        "lastEditedBy" : "f7ed27fc-83ac-401f-af8b-91c645eda7e9",
        "tags" : [
        ]
      }
    ],
    "commit" : "844aafa18791479a1d1602c02d8a549951fa7c4e",
    "line" : 11,
    "diffHunk" : "@@ -1,1 +336,340 @@        || (scale > fromIntegral numericMaxScale)\n        || (abs (rational * 10 ^ scale) >= 10 ^ numericMaxPrecision)\n        || ((num * 10^scale) `mod` denom /= 0)\n            -- This includes checks against using this function incorrectly\n            -- that should never come up in practice, like"
  },
  {
    "id" : "9d3d8ee9-cf44-42c7-973e-e8283eb21683",
    "prId" : 8427,
    "prUrl" : "https://github.com/digital-asset/daml/pull/8427",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "62c98d3b-5ce1-4f3d-86b3-732643a152de",
        "parentId" : null,
        "authorId" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "body" : "probably too late now and doesn’t matter all that much but did we consider calling this `UserError` instead? General sounds a bit like it is the supertype of all exceptions.",
        "createdAt" : "2021-01-11T08:50:17Z",
        "updatedAt" : "2021-01-11T11:23:02Z",
        "lastEditedBy" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "tags" : [
        ]
      },
      {
        "id" : "d3db1839-f6e4-412d-90d5-9bc73cc6b9dd",
        "parentId" : "62c98d3b-5ce1-4f3d-86b3-732643a152de",
        "authorId" : "f7ed27fc-83ac-401f-af8b-91c645eda7e9",
        "body" : "The names/types/values of primitive exceptions are not final :) We decided to just go ahead with these for now and leave the final decisions (& bikeshedding) for later.",
        "createdAt" : "2021-01-11T10:59:05Z",
        "updatedAt" : "2021-01-11T11:23:02Z",
        "lastEditedBy" : "f7ed27fc-83ac-401f-af8b-91c645eda7e9",
        "tags" : [
        ]
      },
      {
        "id" : "aacff2a2-cf28-49b3-86bf-9bb2d91855ba",
        "parentId" : "62c98d3b-5ce1-4f3d-86b3-732643a152de",
        "authorId" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "body" : "sounds very sensible :slightly_smiling_face: ",
        "createdAt" : "2021-01-11T11:02:35Z",
        "updatedAt" : "2021-01-11T11:23:02Z",
        "lastEditedBy" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "tags" : [
        ]
      }
    ],
    "commit" : "2f82bb336a179d521cfbb08a931b3d273de57427",
    "line" : 18,
    "diffHunk" : "@@ -1,1 +1680,1684 @@                    else TUnit\n            \"AnyException\" -> pure (TBuiltin BTAnyException)\n            \"GeneralError\" -> pure (TBuiltin BTGeneralError)\n            \"ArithmeticError\" -> pure (TBuiltin BTArithmeticError)\n            \"ContractError\" -> pure (TBuiltin BTContractError)"
  },
  {
    "id" : "1801dab1-15f4-44ca-ba61-9f5e1c5ca69d",
    "prId" : 7956,
    "prUrl" : "https://github.com/digital-asset/daml/pull/7956",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "609dd367-ea77-492e-af56-b1fe0572cc7c",
        "parentId" : null,
        "authorId" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "body" : "What happens if we have a multi-param lambda?",
        "createdAt" : "2020-11-12T15:16:44Z",
        "updatedAt" : "2020-11-12T16:17:20Z",
        "lastEditedBy" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "tags" : [
        ]
      },
      {
        "id" : "ed7dace1-beff-4892-b8d0-ce850f5f4451",
        "parentId" : "609dd367-ea77-492e-af56-b1fe0572cc7c",
        "authorId" : "f7ed27fc-83ac-401f-af8b-91c645eda7e9",
        "body" : "Currying should handle it fine. I guess it's not optimal performance-wise to break a lambda apart like this, but I didn't want to change the existing transformation in this PR.",
        "createdAt" : "2020-11-12T15:20:27Z",
        "updatedAt" : "2020-11-12T16:17:20Z",
        "lastEditedBy" : "f7ed27fc-83ac-401f-af8b-91c645eda7e9",
        "tags" : [
        ]
      },
      {
        "id" : "d3e3ec2d-1ab6-42f3-bfa9-db051b48569f",
        "parentId" : "609dd367-ea77-492e-af56-b1fe0572cc7c",
        "authorId" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "body" : "That works as well. The transformation would insert the `let f = name ... in` after the first parameter. We want to insert it as soon as possible in the parameter list to avoid any shadowing/name capture issues but we also need to have at least one lambda before it such that we don't get a recursive top-level value. Does make sense?\r\n\r\n@sofiafaro-da We should probably also check that `f` and `v` are distinct, otherwise the binders for them don't commute and rewriting is illegal.",
        "createdAt" : "2020-11-12T15:25:11Z",
        "updatedAt" : "2020-11-12T16:17:20Z",
        "lastEditedBy" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "tags" : [
        ]
      },
      {
        "id" : "c87bbb63-2f6e-45e1-9109-e3eebd0e0f20",
        "parentId" : "609dd367-ea77-492e-af56-b1fe0572cc7c",
        "authorId" : "f7ed27fc-83ac-401f-af8b-91c645eda7e9",
        "body" : "Wondering off the top of my head: How would one trigger a shadowing here? Wouldn't shadowing prevent a recursive binding in the first place? E.g.\r\n\r\n```\r\nf f = f 10\r\n```\r\n\r\nis not recursive.",
        "createdAt" : "2020-11-12T15:32:26Z",
        "updatedAt" : "2020-11-12T16:17:20Z",
        "lastEditedBy" : "f7ed27fc-83ac-401f-af8b-91c645eda7e9",
        "tags" : [
        ]
      },
      {
        "id" : "b20df483-5704-42fe-aaf4-8de9c153aaf9",
        "parentId" : "609dd367-ea77-492e-af56-b1fe0572cc7c",
        "authorId" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "body" : "Makes sense, thanks!",
        "createdAt" : "2020-11-12T15:38:51Z",
        "updatedAt" : "2020-11-12T16:17:20Z",
        "lastEditedBy" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "tags" : [
        ]
      },
      {
        "id" : "7509e106-a6db-4633-a933-93c10866b98f",
        "parentId" : "609dd367-ea77-492e-af56-b1fe0572cc7c",
        "authorId" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "body" : "@sofiafaro-da You're totally right. 😅",
        "createdAt" : "2020-11-12T15:45:56Z",
        "updatedAt" : "2020-11-12T16:17:20Z",
        "lastEditedBy" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "tags" : [
        ]
      }
    ],
    "commit" : "d4c20723e1f9d9cea769e8da4055c7f8c4b66034",
    "line" : 23,
    "diffHunk" : "@@ -1,1 +766,770 @@    | let (params, body1) = collectBinders x\n    , let (lets, body2) = collectNonRecLets body1\n    , Let (Rec [(f, Lam v y)]) (Var f') <- body2\n    , f == f'\n    = convertBind env $ (,) name $ mkLams params $ makeNonRecLets lets $"
  },
  {
    "id" : "865afbfd-c5c7-41f9-acb7-fab27caba028",
    "prId" : 7815,
    "prUrl" : "https://github.com/digital-asset/daml/pull/7815",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "80b6ad2b-1638-4770-874c-fe5d04404c6f",
        "parentId" : null,
        "authorId" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "body" : "Why do we need all this special casing for default handling? Isn’t not specifying a minimal pragma equivalent to all methods being part of the default pragma and we can just aways reconstruct the pragma?",
        "createdAt" : "2020-10-27T14:50:23Z",
        "updatedAt" : "2020-10-28T09:48:00Z",
        "lastEditedBy" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "tags" : [
        ]
      },
      {
        "id" : "580ae119-8359-443e-a701-b1f11b186c83",
        "parentId" : "80b6ad2b-1638-4770-874c-fe5d04404c6f",
        "authorId" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "body" : "nvm, of course it isn’t equivalent.",
        "createdAt" : "2020-10-27T14:58:47Z",
        "updatedAt" : "2020-10-28T09:48:00Z",
        "lastEditedBy" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "tags" : [
        ]
      },
      {
        "id" : "2e08f4d1-545f-4ff7-93a2-9456c96a3f68",
        "parentId" : "80b6ad2b-1638-4770-874c-fe5d04404c6f",
        "authorId" : "f7ed27fc-83ac-401f-af8b-91c645eda7e9",
        "body" : "A good reason is to avoid encoding the minimal pragmas unless we have to, to keep DAR size down. A certain codebase has a lot of typeclasses...",
        "createdAt" : "2020-10-27T15:04:38Z",
        "updatedAt" : "2020-10-28T09:48:00Z",
        "lastEditedBy" : "f7ed27fc-83ac-401f-af8b-91c645eda7e9",
        "tags" : [
        ]
      }
    ],
    "commit" : "323977ef2324d231a554726a69744fffb86d151b",
    "line" : 27,
    "diffHunk" : "@@ -1,1 +556,560 @@                    | let names = [ name | BF.Var name <- map unLoc subclauses ]\n                    , length names == length subclauses\n                    -> sort names == methodsWithNoDefault\n                _ -> False\n        minimalType = encodeBooleanFormula minimal"
  },
  {
    "id" : "da6d565d-dcd6-4eac-9f9a-77c3f889e7b9",
    "prId" : 7809,
    "prUrl" : "https://github.com/digital-asset/daml/pull/7809",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "171d3002-4f20-4835-8007-4a0bce74f42f",
        "parentId" : null,
        "authorId" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "body" : "That’s quite a monad stack :slightly_smiling_face: ",
        "createdAt" : "2020-10-26T15:12:18Z",
        "updatedAt" : "2020-10-29T11:13:33Z",
        "lastEditedBy" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "tags" : [
        ]
      },
      {
        "id" : "3f2fe12f-86e1-418e-9f3c-5bed88e74ad2",
        "parentId" : "171d3002-4f20-4835-8007-4a0bce74f42f",
        "authorId" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "body" : "Yeah, I know. But what can we do about it in a language like Haskell? We need all these effects. We could put the `ConversionEnv` in the `ConversionState`, but I'm not sure that makes the situation better.",
        "createdAt" : "2020-10-26T15:31:23Z",
        "updatedAt" : "2020-10-29T11:13:33Z",
        "lastEditedBy" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "tags" : [
        ]
      },
      {
        "id" : "4a72353c-e091-4ab5-b730-258fbc36187a",
        "parentId" : "171d3002-4f20-4835-8007-4a0bce74f42f",
        "authorId" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "body" : "I don’t have an issue with it, I just got slightly amused :slightly_smiling_face: ",
        "createdAt" : "2020-10-26T15:33:31Z",
        "updatedAt" : "2020-10-29T11:13:33Z",
        "lastEditedBy" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "tags" : [
        ]
      }
    ],
    "commit" : "e9280b4557d441743df8cd9149f81d13363ee195",
    "line" : 62,
    "diffHunk" : "@@ -1,1 +244,248 @@    }\n\nnewtype ConvertM a = ConvertM (ReaderT ConversionEnv (StateT ConversionState (Except FileDiagnostic)) a)\n  deriving (Functor, Applicative, Monad, MonadError FileDiagnostic, MonadState ConversionState, MonadReader ConversionEnv)\n"
  },
  {
    "id" : "5cc3e07d-fcd6-433c-abcd-189a9a10466b",
    "prId" : 7809,
    "prUrl" : "https://github.com/digital-asset/daml/pull/7809",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1b43286b-d907-4ca8-af81-f19dcc5df97e",
        "parentId" : null,
        "authorId" : "f7ed27fc-83ac-401f-af8b-91c645eda7e9",
        "body" : "`withTyArg` should really add the type variable to the Env (like `envBindTypeVar` does), and pass a new env' to its descendants",
        "createdAt" : "2020-10-26T15:49:00Z",
        "updatedAt" : "2020-10-29T11:13:33Z",
        "lastEditedBy" : "f7ed27fc-83ac-401f-af8b-91c645eda7e9",
        "tags" : [
        ]
      }
    ],
    "commit" : "e9280b4557d441743df8cd9149f81d13363ee195",
    "line" : 197,
    "diffHunk" : "@@ -1,1 +1305,1309 @@    let (v, env') = envFreshTypeVar \"a\" env\n    (x, args) <- cont env' (TVar v) args\n    pure (ETyLam (v, k) x, args)\n\nwithTmArg :: Env -> LF.Type -> [LArg Var] -> (LF.Expr-> [LArg Var] -> ConvertM (LF.Expr, [LArg Var])) -> ConvertM (LF.Expr, [LArg Var])"
  },
  {
    "id" : "a71d9b5f-c1c9-4e70-9bc1-16bd488d4e72",
    "prId" : 7809,
    "prUrl" : "https://github.com/digital-asset/daml/pull/7809",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2f7fed83-2e52-4b3c-bbbf-e85cbe2fe301",
        "parentId" : null,
        "authorId" : "f7ed27fc-83ac-401f-af8b-91c645eda7e9",
        "body" : "Should you also reset the counters before each declaration, to prevent the order of declarations from affecting each other?",
        "createdAt" : "2020-10-27T10:21:24Z",
        "updatedAt" : "2020-10-29T11:13:33Z",
        "lastEditedBy" : "f7ed27fc-83ac-401f-af8b-91c645eda7e9",
        "tags" : [
        ]
      },
      {
        "id" : "9a8ab681-97d1-4c57-b1b3-79a73547d9fd",
        "parentId" : "2f7fed83-2e52-4b3c-bbbf-e85cbe2fe301",
        "authorId" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "body" : "I thought about that as well. My conclusion was that it's not important for deterministic compilation of the module since a changed order would change the result anyway. However, after thinking about it again, I realized that this sort of intra-definition determinism is desirable for testing the code generation of individual function. I'll reset the counter before each top-level declaration and each template.",
        "createdAt" : "2020-10-29T07:14:52Z",
        "updatedAt" : "2020-10-29T11:13:33Z",
        "lastEditedBy" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "tags" : [
        ]
      },
      {
        "id" : "76a2f22b-0e2c-4b4e-89c9-828c452300c4",
        "parentId" : "2f7fed83-2e52-4b3c-bbbf-e85cbe2fe301",
        "authorId" : "f7ed27fc-83ac-401f-af8b-91c645eda7e9",
        "body" : "👍  Thanks!",
        "createdAt" : "2020-10-29T10:07:19Z",
        "updatedAt" : "2020-10-29T11:13:33Z",
        "lastEditedBy" : "f7ed27fc-83ac-401f-af8b-91c645eda7e9",
        "tags" : [
        ]
      }
    ],
    "commit" : "e9280b4557d441743df8cd9149f81d13363ee195",
    "line" : 74,
    "diffHunk" : "@@ -1,1 +255,259 @@    st0 = ConversionState\n        { freshTmVarCounter = 0\n        }\n\nwithRange :: Maybe SourceLoc -> ConvertM a -> ConvertM a"
  },
  {
    "id" : "d8651170-3555-4645-bf47-9abfcfccb5e0",
    "prId" : 7809,
    "prUrl" : "https://github.com/digital-asset/daml/pull/7809",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ffd016d6-fa43-4eec-af51-52b1768a9516",
        "parentId" : null,
        "authorId" : "f7ed27fc-83ac-401f-af8b-91c645eda7e9",
        "body" : "Should we still use something like `$$t` here, as the name hint? It probably doesn't make a difference, given how careful we are with type variables, but it has less chance of colliding with other type variables already in the code. ",
        "createdAt" : "2020-10-29T10:19:10Z",
        "updatedAt" : "2020-10-29T11:13:33Z",
        "lastEditedBy" : "f7ed27fc-83ac-401f-af8b-91c645eda7e9",
        "tags" : [
        ]
      },
      {
        "id" : "c9fc0ade-f5b6-4d15-94ac-6a3194650683",
        "parentId" : "ffd016d6-fa43-4eec-af51-52b1768a9516",
        "authorId" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "body" : "Yeah, that's a good point. I'll use `$t` to save some money.",
        "createdAt" : "2020-10-29T10:21:36Z",
        "updatedAt" : "2020-10-29T11:13:33Z",
        "lastEditedBy" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "tags" : [
        ]
      }
    ],
    "commit" : "e9280b4557d441743df8cd9149f81d13363ee195",
    "line" : 195,
    "diffHunk" : "@@ -1,1 +1303,1307 @@    cont env t args\nwithTyArg env k args cont = do\n    let (v, env') = envFreshTypeVar \"a\" env\n    (x, args) <- cont env' (TVar v) args\n    pure (ETyLam (v, k) x, args)"
  },
  {
    "id" : "acf1c088-7361-440e-8452-4fd455098b9b",
    "prId" : 7765,
    "prUrl" : "https://github.com/digital-asset/daml/pull/7765",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5a691d97-c64a-49af-b14d-18cfbe71ffc4",
        "parentId" : null,
        "authorId" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "body" : "Do we really want to support this?",
        "createdAt" : "2020-10-22T13:18:48Z",
        "updatedAt" : "2020-10-22T13:21:03Z",
        "lastEditedBy" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "tags" : [
        ]
      },
      {
        "id" : "b12310d1-3bc8-486f-aee9-9a17386158c1",
        "parentId" : "5a691d97-c64a-49af-b14d-18cfbe71ffc4",
        "authorId" : "f7ed27fc-83ac-401f-af8b-91c645eda7e9",
        "body" : "As far as damlc is concerned, it's an \"overlap mode\" pragma like any other. In this light, I don't have any problem with it, or any reason to oppose it, compared to any other overlap modes.\r\n\r\nOne okay reason to support it is because instances marked \"INCOHERENT\" always have the lowest priority, so they have a kind of a unique function as an \"ultimate default option\", if you're going to be relying on overlapping instances at all. ",
        "createdAt" : "2020-10-22T14:24:42Z",
        "updatedAt" : "2020-10-22T14:24:42Z",
        "lastEditedBy" : "f7ed27fc-83ac-401f-af8b-91c645eda7e9",
        "tags" : [
        ]
      },
      {
        "id" : "306d5006-a9c5-4203-82b6-3690fb62f57a",
        "parentId" : "5a691d97-c64a-49af-b14d-18cfbe71ffc4",
        "authorId" : "f7ed27fc-83ac-401f-af8b-91c645eda7e9",
        "body" : "But I don't feel strongly either way. It is currently less work to support it than to emit a warning.",
        "createdAt" : "2020-10-22T14:35:08Z",
        "updatedAt" : "2020-10-22T14:35:08Z",
        "lastEditedBy" : "f7ed27fc-83ac-401f-af8b-91c645eda7e9",
        "tags" : [
        ]
      }
    ],
    "commit" : "c340f90b83721e8e33d79aa8f76e91309b67121a",
    "line" : 76,
    "diffHunk" : "@@ -1,1 +765,769 @@                Just (Overlapping _) -> Just \"OVERLAPPING\"\n                Just (Overlaps _) -> Just \"OVERLAPS\"\n                Just (Incoherent _) -> Just \"INCOHERENT\"\n        overlapModeDef =\n            [ defValue name (overlapModeName, TText) (EBuiltin (BEText mode))"
  },
  {
    "id" : "809e62dd-48ae-4c9b-b417-7f87b05d87f8",
    "prId" : 7765,
    "prUrl" : "https://github.com/digital-asset/daml/pull/7765",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "cf813434-70fb-4b0b-ad92-bccbd64f8b1d",
        "parentId" : null,
        "authorId" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "body" : "This refactoring reminds me of something I did a few days ago. Is that the change I reverted?",
        "createdAt" : "2020-10-22T13:20:13Z",
        "updatedAt" : "2020-10-22T13:21:03Z",
        "lastEditedBy" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "tags" : [
        ]
      },
      {
        "id" : "d5b7420c-8974-4201-ab83-83c80a7c256c",
        "parentId" : "cf813434-70fb-4b0b-ad92-bccbd64f8b1d",
        "authorId" : "f7ed27fc-83ac-401f-af8b-91c645eda7e9",
        "body" : "Yes ... I was working off the master that was reverted. This caused some merge conflicts due to the reversion, but actually having typeclass instances as a separate case in `convertBind` (as it is here) is more convenient, so the refactoring ended up sneaking back in. :) ",
        "createdAt" : "2020-10-22T14:16:29Z",
        "updatedAt" : "2020-10-22T14:16:30Z",
        "lastEditedBy" : "f7ed27fc-83ac-401f-af8b-91c645eda7e9",
        "tags" : [
        ]
      }
    ],
    "commit" : "c340f90b83721e8e33d79aa8f76e91309b67121a",
    "line" : 52,
    "diffHunk" : "@@ -1,1 +741,745 @@    = pure []\n\n    -- Typeclass instance dictionaries\n    | DFunId isNewtype <- idDetails name\n    = withRange (convNameLoc name) $ do"
  },
  {
    "id" : "19cee6f1-cb88-4037-a763-82c16b2d30c4",
    "prId" : 7725,
    "prUrl" : "https://github.com/digital-asset/daml/pull/7725",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a2c8fad8-7360-41bb-bc39-5dce81b11a1d",
        "parentId" : null,
        "authorId" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "body" : "Is this really only a problem in combination with typeclasses? I thought erased kinds cause problems everywhere.",
        "createdAt" : "2020-10-19T07:15:20Z",
        "updatedAt" : "2020-10-19T07:29:29Z",
        "lastEditedBy" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "tags" : [
        ]
      },
      {
        "id" : "1c1e40e8-9c06-4e11-a570-7fbaa133fecb",
        "parentId" : "a2c8fad8-7360-41bb-bc39-5dce81b11a1d",
        "authorId" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "body" : "You're right, erased kinds are problematic everywhere. With code using promoted kinds does not compile in the first case. Functions using promoted kinds in their signature will have a different signature after importing via data-dependencies. This might become annoying but does not stop a package from being imported. The problem with typeclasses is that you might end up with overlapping instances after kind erasure where there was no overlap before. This will prevent a package from being data-dependable. I still don't understand the full picture and I expect these warnings to extend to more places in the long run.",
        "createdAt" : "2020-10-19T08:13:47Z",
        "updatedAt" : "2020-10-19T08:13:47Z",
        "lastEditedBy" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "tags" : [
        ]
      }
    ],
    "commit" : "263edefbe9170285fb42164094fed7944166b805",
    "line" : 30,
    "diffHunk" : "@@ -1,1 +168,172 @@warnNotDataDependable what =\n    warn $ unlines\n        [ \"Using \" ++ what ++ \" in combination with type classes\"\n        , \"does not work properly with data-dependencies. This will stop the\"\n        , \"whole package from being extensible or upgradable using other versions\""
  },
  {
    "id" : "b87c5f07-fdbc-4d2a-8491-fae011c0d7a3",
    "prId" : 7698,
    "prUrl" : "https://github.com/digital-asset/daml/pull/7698",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6c5831a5-a799-4877-bb1d-795349680b65",
        "parentId" : null,
        "authorId" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "body" : "Perhaps worth adding a comment that we don’t care about this.",
        "createdAt" : "2020-10-15T14:02:20Z",
        "updatedAt" : "2020-10-15T14:15:49Z",
        "lastEditedBy" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "tags" : [
        ]
      },
      {
        "id" : "fd935c61-db68-415c-913f-a60a4e88555f",
        "parentId" : "6c5831a5-a799-4877-bb1d-795349680b65",
        "authorId" : "f7ed27fc-83ac-401f-af8b-91c645eda7e9",
        "body" : "Good idea, added. :-) ",
        "createdAt" : "2020-10-15T14:15:53Z",
        "updatedAt" : "2020-10-15T14:15:53Z",
        "lastEditedBy" : "f7ed27fc-83ac-401f-af8b-91c645eda7e9",
        "tags" : [
        ]
      }
    ],
    "commit" : "4479fba4bdac074e6f2798d5cb3c3870ee1a1255",
    "line" : 46,
    "diffHunk" : "@@ -1,1 +531,535 @@        funDepName = ExprValName (\"$fd\" <> getOccText tycon)\n        funDepType = TForalls funDepTyVars (encodeFunDeps funDeps')\n        funDepExpr = EBuiltin BEError `ETyApp` funDepType `ETmApp`\n            EBuiltin (BEText \"undefined\") -- We only care about the type, not the expr.\n        funDepDef = defValue tycon (funDepName, funDepType) funDepExpr"
  },
  {
    "id" : "29713984-6fd8-4c1b-84ff-00a7c1146f6b",
    "prId" : 7698,
    "prUrl" : "https://github.com/digital-asset/daml/pull/7698",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "018751e3-cb00-446c-b524-454eb5430acf",
        "parentId" : null,
        "authorId" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "body" : "Dictionaries start with `$f`. Can this become a problem? Should we try to find some definitely unoccupied space, like starting with `$$`?",
        "createdAt" : "2020-10-15T14:43:44Z",
        "updatedAt" : "2020-10-15T14:45:32Z",
        "lastEditedBy" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "tags" : [
        ]
      },
      {
        "id" : "c870115a-1e8e-4c94-8fa3-2dd20784025c",
        "parentId" : "018751e3-cb00-446c-b524-454eb5430acf",
        "authorId" : "f7ed27fc-83ac-401f-af8b-91c645eda7e9",
        "body" : "Oh, shoot. And the PR merged already... I'll open a new PR to rename this.\r\n\r\nFortunately I don't think a conflict is actually possible with `$fd` because dictionary functions names always start with `$fT` where `T` is the name of the class, and `T` can never start with a lowercase `d`. ",
        "createdAt" : "2020-10-15T14:54:53Z",
        "updatedAt" : "2020-10-15T14:54:54Z",
        "lastEditedBy" : "f7ed27fc-83ac-401f-af8b-91c645eda7e9",
        "tags" : [
        ]
      },
      {
        "id" : "84feae37-7270-4f0f-aefc-2ada2c62129a",
        "parentId" : "018751e3-cb00-446c-b524-454eb5430acf",
        "authorId" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "body" : "Can you write instances like\r\n```haskell\r\ninstance (Functor a, Show a) => Foo (d a) where\r\n```\r\nMaybe I'm just paranoid but I'd prefer to be on the really safe side. 😺 ",
        "createdAt" : "2020-10-15T15:03:22Z",
        "updatedAt" : "2020-10-15T15:03:22Z",
        "lastEditedBy" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "tags" : [
        ]
      },
      {
        "id" : "a0accf5a-f31a-4302-a27f-92fb8bbbc073",
        "parentId" : "018751e3-cb00-446c-b524-454eb5430acf",
        "authorId" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "body" : "And thanks for changing it.",
        "createdAt" : "2020-10-15T15:05:11Z",
        "updatedAt" : "2020-10-15T15:05:11Z",
        "lastEditedBy" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "tags" : [
        ]
      },
      {
        "id" : "79533926-5061-498c-9d0f-3e163060bb7d",
        "parentId" : "018751e3-cb00-446c-b524-454eb5430acf",
        "authorId" : "f7ed27fc-83ac-401f-af8b-91c645eda7e9",
        "body" : "No, the dictionary function would be `$fFood` in that case.\r\n\r\nHere's the PR: https://github.com/digital-asset/daml/pull/7701",
        "createdAt" : "2020-10-15T15:29:36Z",
        "updatedAt" : "2020-10-15T15:29:36Z",
        "lastEditedBy" : "f7ed27fc-83ac-401f-af8b-91c645eda7e9",
        "tags" : [
        ]
      },
      {
        "id" : "5876d692-2219-4add-96d0-c2e4a9b76900",
        "parentId" : "018751e3-cb00-446c-b524-454eb5430acf",
        "authorId" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "body" : "`$fFood`? That sounds yummy. 😋\r\n\r\nThanks for changing it.",
        "createdAt" : "2020-10-15T16:43:47Z",
        "updatedAt" : "2020-10-15T16:43:47Z",
        "lastEditedBy" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "tags" : [
        ]
      }
    ],
    "commit" : "4479fba4bdac074e6f2798d5cb3c3870ee1a1255",
    "line" : 44,
    "diffHunk" : "@@ -1,1 +529,533 @@            -- We use the the type variables as types in the fundep encoding,\n            -- not as whatever kind they were previously defined.\n        funDepName = ExprValName (\"$fd\" <> getOccText tycon)\n        funDepType = TForalls funDepTyVars (encodeFunDeps funDeps')\n        funDepExpr = EBuiltin BEError `ETyApp` funDepType `ETmApp`"
  },
  {
    "id" : "28c01c14-3b14-4563-a546-d29799676884",
    "prId" : 7252,
    "prUrl" : "https://github.com/digital-asset/daml/pull/7252",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "34a9f204-fd04-4f47-a7d8-401ef36d46f7",
        "parentId" : null,
        "authorId" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "body" : "Answering my own question: No we don’t have to worry about backwards compatibility. `data-dependencies` only rely on types not values so they do not care about this.",
        "createdAt" : "2020-08-27T15:35:10Z",
        "updatedAt" : "2020-08-28T11:39:11Z",
        "lastEditedBy" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "tags" : [
        ]
      }
    ],
    "commit" : "5cd8cd54f886d4b5d729f46c48c70c22c49f3082",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +887,891 @@    go env (VarIn DA_Action \"unless\") (LType monad : LExpr dict : LExpr x : LExpr y : args)\n        = fmap (, args) $ mkIf <$> convertExpr env x <*> mkPure env monad dict TUnit EUnit <*> convertExpr env y\n    go env submit@(VarIn DA_Internal_LF \"submit\") (LType m : LType cmds : LExpr dict : LType typ : LExpr callstack : LExpr pty : LExpr upd : args) = fmap (, args) $ do\n         m' <- convertType env m\n         typ' <- convertType env typ"
  },
  {
    "id" : "f5d7cdc7-746c-4436-9004-fe3ea2ed2836",
    "prId" : 6894,
    "prUrl" : "https://github.com/digital-asset/daml/pull/6894",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "612571f0-e652-4865-9849-11c09f69b134",
        "parentId" : null,
        "authorId" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "body" : "Is there a technical reason for moving this further down or is it just a stylistic thing? I'm fine either way but would like to understand the former if that's the case.",
        "createdAt" : "2020-07-28T12:06:48Z",
        "updatedAt" : "2020-07-28T13:34:05Z",
        "lastEditedBy" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "tags" : [
        ]
      },
      {
        "id" : "cd193f32-24ad-476c-8acb-99946b6b9214",
        "parentId" : "612571f0-e652-4865-9849-11c09f69b134",
        "authorId" : "f7ed27fc-83ac-401f-af8b-91c645eda7e9",
        "body" : "I moved it down below typeclasses and constraint tuples before realizing it doesn't make a difference anyway.",
        "createdAt" : "2020-07-28T12:32:33Z",
        "updatedAt" : "2020-07-28T13:34:05Z",
        "lastEditedBy" : "f7ed27fc-83ac-401f-af8b-91c645eda7e9",
        "tags" : [
        ]
      },
      {
        "id" : "b9472faa-774b-47ff-8458-db59d488d939",
        "parentId" : "612571f0-e652-4865-9849-11c09f69b134",
        "authorId" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "body" : "Thanks for the explanation.",
        "createdAt" : "2020-07-28T13:20:57Z",
        "updatedAt" : "2020-07-28T13:34:05Z",
        "lastEditedBy" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "tags" : [
        ]
      }
    ],
    "commit" : "dd8b14438d3d1adcf5a65aa01490d7b2fe3202d6",
    "line" : 18,
    "diffHunk" : "@@ -1,1 +435,439 @@    -- convert the synonyms we can so that we can expose them via data-dependencies.\n    | isTypeSynonymTyCon t\n    -> convertTypeSynonym env t\n\n    -- Simple record types. This includes newtypes, and"
  },
  {
    "id" : "f0e4a743-4212-4253-9bc4-6c176830cb8a",
    "prId" : 6894,
    "prUrl" : "https://github.com/digital-asset/daml/pull/6894",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a107baff-5cfa-4f3a-831c-36acfeec3486",
        "parentId" : null,
        "authorId" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "body" : "Aren't we translating empty type classes into empty structural records? Isn't that different from the unit type?",
        "createdAt" : "2020-07-28T12:07:46Z",
        "updatedAt" : "2020-07-28T13:34:05Z",
        "lastEditedBy" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "tags" : [
        ]
      },
      {
        "id" : "7d548f13-3b5b-47b1-bb2f-55e1ea4beb63",
        "parentId" : "a107baff-5cfa-4f3a-831c-36acfeec3486",
        "authorId" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "body" : "LF does not allow for empty structural records.",
        "createdAt" : "2020-07-28T12:14:05Z",
        "updatedAt" : "2020-07-28T13:34:05Z",
        "lastEditedBy" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "tags" : [
        ]
      },
      {
        "id" : "c6c1ce42-9aec-4dae-b6d4-bc9524c6b1e5",
        "parentId" : "a107baff-5cfa-4f3a-831c-36acfeec3486",
        "authorId" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "body" : "I wonder why we decided to do it like that. I have no recollection... 🤔 ",
        "createdAt" : "2020-07-28T13:20:38Z",
        "updatedAt" : "2020-07-28T13:34:05Z",
        "lastEditedBy" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "tags" : [
        ]
      }
    ],
    "commit" : "dd8b14438d3d1adcf5a65aa01490d7b2fe3202d6",
    "line" : 43,
    "diffHunk" : "@@ -1,1 +493,497 @@            TUnit -> pure []\n                -- We avoid converting TUnit type synonyms because it\n                -- clashes with the conversion of empty typeclasses.\n            _ -> pure [ defTypeSyn tsynName tsynParams tsynType ]\n"
  },
  {
    "id" : "32519ef4-7350-453d-a06b-87ff0093d8ff",
    "prId" : 6590,
    "prUrl" : "https://github.com/digital-asset/daml/pull/6590",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "44018886-dad4-4171-af9e-cd7b646af31b",
        "parentId" : null,
        "authorId" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "body" : "In your PR description you mention that this will be a major challenge. Could you expand on that? I certainly see how it can be annoying to implement but I don’t see what exactly makes it challenging.",
        "createdAt" : "2020-07-03T07:08:27Z",
        "updatedAt" : "2020-07-03T09:22:38Z",
        "lastEditedBy" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "tags" : [
        ]
      },
      {
        "id" : "01b99c16-9a37-49e8-89ad-03f8129dffcd",
        "parentId" : "44018886-dad4-4171-af9e-cd7b646af31b",
        "authorId" : "f7ed27fc-83ac-401f-af8b-91c645eda7e9",
        "body" : "I slept on it and I think there's an easy way to do it actually -- rewrite it as an `ELet` expression to force the \"record\" argument to be evaluated before the field. Before I thought it would have to branch on each constructor.",
        "createdAt" : "2020-07-03T09:00:18Z",
        "updatedAt" : "2020-07-03T09:22:38Z",
        "lastEditedBy" : "f7ed27fc-83ac-401f-af8b-91c645eda7e9",
        "tags" : [
        ]
      }
    ],
    "commit" : "e9376d837f80d18b52ddb67f6b5420b992417047",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +770,774 @@                withTmArg env (varV2, record') args $ \\x2 args ->\n                    pure (ERecUpd (fromTCon record') (mkField $ fsToText name) x2 x1, args)\n        -- TODO: Also fix evaluation order for sum-of-record types.\n    -- NOTE(SF): We will need a `setFieldPrim` rule regardless, because\n    -- GeneralizedNewtypeDeriving will skip the typeclass instance."
  },
  {
    "id" : "0a2d97fe-2288-4b57-9ad2-b282bb2fb4fe",
    "prId" : 4552,
    "prUrl" : "https://github.com/digital-asset/daml/pull/4552",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1371d9c3-c4df-47f8-9186-f4207590ef43",
        "parentId" : null,
        "authorId" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "body" : "There's a bit of code shared between the handling of `>>=` and `>>`. I'll do a slight refactoring in a separate PR if you think that would improve the situation.",
        "createdAt" : "2020-02-17T16:39:00Z",
        "updatedAt" : "2020-02-18T13:22:23Z",
        "lastEditedBy" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "tags" : [
        ]
      }
    ],
    "commit" : "e65fd8da34470a622c7f2e0a13f72ab5e3079ff7",
    "line" : 28,
    "diffHunk" : "@@ -1,1 +900,904 @@            EVal semi' <- convertExpr env semi\n            let bind' = EVal semi'{qualObject = mkVal \">>=\"}\n            pure $ mkEApps bind' [TyArg monad', TmArg dict', TyArg t1', TyArg t2', TmArg x', TmArg (ETmLam (mkVar \"_\", t1') y')]\n\n    go env (VarIn GHC_Types \"[]\") (LType (TypeCon (Is \"Char\") []) : args)"
  },
  {
    "id" : "d9d00e2a-6174-491d-8a97-de8ed0678689",
    "prId" : 4552,
    "prUrl" : "https://github.com/digital-asset/daml/pull/4552",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1e663f0f-f1ef-47e2-bacb-c7ab251e23b0",
        "parentId" : null,
        "authorId" : null,
        "body" : "Worried about the future possibility that `>>` and `>>=` will move to different modules, and this will be hard to debug. But the tests should catch this at least.",
        "createdAt" : "2020-02-18T10:48:20Z",
        "updatedAt" : "2020-02-18T13:22:23Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "e65fd8da34470a622c7f2e0a13f72ab5e3079ff7",
    "line" : 27,
    "diffHunk" : "@@ -1,1 +899,903 @@          _ -> do\n            EVal semi' <- convertExpr env semi\n            let bind' = EVal semi'{qualObject = mkVal \">>=\"}\n            pure $ mkEApps bind' [TyArg monad', TmArg dict', TyArg t1', TyArg t2', TmArg x', TmArg (ETmLam (mkVar \"_\", t1') y')]\n"
  },
  {
    "id" : "55b16a7d-d8eb-4903-8417-7afe01842883",
    "prId" : 3973,
    "prUrl" : "https://github.com/digital-asset/daml/pull/3973",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2f2dbcb1-0afd-4ae7-8294-660e99ac2eaa",
        "parentId" : null,
        "authorId" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "body" : "Do we really need to add `Optional` to that list? It's a list of types defined in `DA.Internal.LF` whereas `Optional` is defined in `DA.Internal.Prelude`.",
        "createdAt" : "2020-01-08T12:49:45Z",
        "updatedAt" : "2020-01-08T12:49:46Z",
        "lastEditedBy" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "tags" : [
        ]
      },
      {
        "id" : "0d932866-eb0f-488c-a18d-f4d46421aaaa",
        "parentId" : "2f2dbcb1-0afd-4ae7-8294-660e99ac2eaa",
        "authorId" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "body" : "Good catch, that was leftover from when I tried to move it to `DA.Internal.LF`. Fixed in https://github.com/digital-asset/daml/pull/3981",
        "createdAt" : "2020-01-08T12:54:23Z",
        "updatedAt" : "2020-01-08T12:54:23Z",
        "lastEditedBy" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "tags" : [
        ]
      }
    ],
    "commit" : "496f33167705e2653f7b3b2c2b6e8912a9e32853",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +780,784 @@-- deliberately remove 'GHC.Types.Opaque' as well.\ninternalTypes :: UniqSet FastString\ninternalTypes = mkUniqSet [\"Scenario\",\"Update\",\"ContractId\",\"Time\",\"Date\",\"Party\",\"Pair\", \"TextMap\", \"Map\", \"Any\", \"TypeRep\", \"Optional\"]\n\nconsumingTypes :: UniqSet FastString"
  },
  {
    "id" : "ac30a1b1-b9ac-469d-923e-f10a872f2bbd",
    "prId" : 3702,
    "prUrl" : "https://github.com/digital-asset/daml/pull/3702",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "36f65d86-8689-4c1d-a5b9-146ea8f4d41a",
        "parentId" : null,
        "authorId" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "body" : "It would be nice to document here what we are tracking in those two variables and why we need it.",
        "createdAt" : "2019-12-02T19:43:24Z",
        "updatedAt" : "2019-12-03T08:54:12Z",
        "lastEditedBy" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "tags" : [
        ]
      }
    ],
    "commit" : "c58a4a35d1fbcd28a5f6c3f8ca6c66310383f151",
    "line" : 12,
    "diffHunk" : "@@ -1,1 +164,168 @@    ,envTemplateKeyData :: MS.Map TypeConName TemplateKeyData\n    ,envIsGenerated :: Bool\n    ,envTypeVars :: !(MS.Map Var TypeVarName)\n        -- ^ Maps GHC type variables in scope to their LF type variable names\n    ,envTypeVarNames :: !(S.Set TypeVarName)"
  },
  {
    "id" : "c0384fb4-e07c-45f3-a97a-3c4b922677e3",
    "prId" : 3541,
    "prUrl" : "https://github.com/digital-asset/daml/pull/3541",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "dbddaeb3-e2c8-432e-b27d-bd6b280e1231",
        "parentId" : null,
        "authorId" : "0aa8e877-303a-4005-8f07-7003661da2a6",
        "body" : "Why is this `TUnit`?",
        "createdAt" : "2019-11-20T08:37:24Z",
        "updatedAt" : "2019-11-20T09:34:16Z",
        "lastEditedBy" : "0aa8e877-303a-4005-8f07-7003661da2a6",
        "tags" : [
        ]
      },
      {
        "id" : "91305e11-b189-4e67-b041-ae43eb1cf608",
        "parentId" : "dbddaeb3-e2c8-432e-b27d-bd6b280e1231",
        "authorId" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "body" : "Because we translate `TAny` to `TUnit` for DAML-LF versions that don’t support `Any` and this now uses `Any` directly.",
        "createdAt" : "2019-11-20T08:42:59Z",
        "updatedAt" : "2019-11-20T09:34:16Z",
        "lastEditedBy" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "tags" : [
        ]
      },
      {
        "id" : "3c0c734f-f7a5-41a0-9be7-9cf819d5cdc9",
        "parentId" : "dbddaeb3-e2c8-432e-b27d-bd6b280e1231",
        "authorId" : "0aa8e877-303a-4005-8f07-7003661da2a6",
        "body" : "Ah, got it. Thanks for explaining!",
        "createdAt" : "2019-11-20T08:54:26Z",
        "updatedAt" : "2019-11-20T09:34:16Z",
        "lastEditedBy" : "0aa8e877-303a-4005-8f07-7003661da2a6",
        "tags" : [
        ]
      }
    ],
    "commit" : "e4d320e108de235fc3db045fb1ce33afd8c40cba",
    "line" : 17,
    "diffHunk" : "@@ -1,1 +380,384 @@                                            (ETmLam (mkVar \"key\", keyType) $ EToAny keyType $ EVar $ mkVar \"key\"))\n                                  else EBuiltin BEError `ETyApp`\n                                       TForall (mkTypeVar \"proxy\", KArrow KStar KStar) (TApp (TVar $ mkTypeVar \"proxy\") polyType :-> keyType :-> TUnit) `ETmApp`\n                                       EBuiltin (BEText \"toAnyContractKey is not supported in this DAML-LF version\")\n                        let fromAnyContractKey ="
  },
  {
    "id" : "c31b7c40-ee95-464e-b433-a743347c0bf6",
    "prId" : 3477,
    "prUrl" : "https://github.com/digital-asset/daml/pull/3477",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a20fc104-f76f-4558-9cc2-ffd8325b436d",
        "parentId" : null,
        "authorId" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "body" : "Good catch, thanks!",
        "createdAt" : "2019-11-15T09:36:45Z",
        "updatedAt" : "2019-11-19T22:40:52Z",
        "lastEditedBy" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "tags" : [
        ]
      }
    ],
    "commit" : "df46a0c0ece38f03f22149c7964ffc4d607dc43b",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +383,387 @@                                  else EBuiltin BEError `ETyApp`\n                                       TForall (mkTypeVar \"proxy\", KArrow KStar KStar) (TApp (TVar $ mkTypeVar \"proxy\") polyType :-> keyType :-> typeConAppToType anyContractKeyTy) `ETmApp`\n                                       EBuiltin (BEText \"toAnyContractKey is not supported in this DAML-LF version\")\n                        let fromAnyContractKey =\n                                if envLfVersion env `supports` featureAnyType"
  },
  {
    "id" : "1c00f9ca-a700-4f65-a9b3-5c0036d5919e",
    "prId" : 3477,
    "prUrl" : "https://github.com/digital-asset/daml/pull/3477",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "626f6ae8-2d27-481b-a0bf-1a6ffb948681",
        "parentId" : null,
        "authorId" : "6bbb482c-d598-4c97-ac37-b89d94b27ee4",
        "body" : "This is just a let binding, right?",
        "createdAt" : "2019-11-19T12:15:53Z",
        "updatedAt" : "2019-11-19T22:40:52Z",
        "lastEditedBy" : "6bbb482c-d598-4c97-ac37-b89d94b27ee4",
        "tags" : [
        ]
      },
      {
        "id" : "9a494476-0da2-4596-969b-fd939837bf79",
        "parentId" : "626f6ae8-2d27-481b-a0bf-1a6ffb948681",
        "authorId" : "43409235-97e4-48dc-9ec7-403ee0a7de54",
        "body" : "yes",
        "createdAt" : "2019-11-19T16:07:56Z",
        "updatedAt" : "2019-11-19T22:40:52Z",
        "lastEditedBy" : "43409235-97e4-48dc-9ec7-403ee0a7de54",
        "tags" : [
        ]
      }
    ],
    "commit" : "df46a0c0ece38f03f22149c7964ffc4d607dc43b",
    "line" : 33,
    "diffHunk" : "@@ -1,1 +1663,1667 @@    | [pkgId, modStr, templName, choiceName, method] <- splitOn \":\" primId\n    , Just LF.Template {tplTypeCon,tplChoices} <- lookup pkgId modStr templName\n    , choice <- ChoiceName (T.pack choiceName)\n    , Just TemplateChoice {chcSelfBinder,chcArgBinder} <- NM.lookup choice tplChoices = do\n        let pkgRef = PRImport $ PackageId $ T.pack pkgId"
  },
  {
    "id" : "f362f214-1232-4e22-a2c7-073ca762650c",
    "prId" : 3477,
    "prUrl" : "https://github.com/digital-asset/daml/pull/3477",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "df2c0177-9527-408b-8020-03950d3bb326",
        "parentId" : null,
        "authorId" : "6bbb482c-d598-4c97-ac37-b89d94b27ee4",
        "body" : "Can  we not add the implementation already for the lf versions that support `Any`?",
        "createdAt" : "2019-11-19T12:17:09Z",
        "updatedAt" : "2019-11-19T22:40:52Z",
        "lastEditedBy" : "6bbb482c-d598-4c97-ac37-b89d94b27ee4",
        "tags" : [
        ]
      },
      {
        "id" : "f4e38c3b-7bec-48ff-92e5-e796c6cc5c6b",
        "parentId" : "df2c0177-9527-408b-8020-03950d3bb326",
        "authorId" : "43409235-97e4-48dc-9ec7-403ee0a7de54",
        "body" : "As discussed, let's leave this to a following PR",
        "createdAt" : "2019-11-19T16:18:05Z",
        "updatedAt" : "2019-11-19T22:40:52Z",
        "lastEditedBy" : "43409235-97e4-48dc-9ec7-403ee0a7de54",
        "tags" : [
        ]
      }
    ],
    "commit" : "df46a0c0ece38f03f22149c7964ffc4d607dc43b",
    "line" : 46,
    "diffHunk" : "@@ -1,1 +1676,1680 @@                EUpdate $ UExercise (qualify tplTypeCon) choice (EVar chcSelfBinder) Nothing (EVar choiceArg)\n          \"_toAnyChoice\" ->\n            -- TODO: envLfVersion env `supports` featureAnyType\n            EBuiltin BEError `ETyApp` lfType `ETmApp`\n            EBuiltin (BEText \"toAnyChoice is not supported in this DAML-LF version\")"
  },
  {
    "id" : "eb84c8c5-6554-4803-af23-21243c87a424",
    "prId" : 3477,
    "prUrl" : "https://github.com/digital-asset/daml/pull/3477",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "73db58a8-7107-4215-83eb-ebec69323844",
        "parentId" : null,
        "authorId" : "6bbb482c-d598-4c97-ac37-b89d94b27ee4",
        "body" : "Thanks for these!",
        "createdAt" : "2019-11-19T12:18:21Z",
        "updatedAt" : "2019-11-19T22:40:52Z",
        "lastEditedBy" : "6bbb482c-d598-4c97-ac37-b89d94b27ee4",
        "tags" : [
        ]
      },
      {
        "id" : "0d9e8932-6f69-4fbc-a000-c41297137381",
        "parentId" : "73db58a8-7107-4215-83eb-ebec69323844",
        "authorId" : "43409235-97e4-48dc-9ec7-403ee0a7de54",
        "body" : "you're welcome!",
        "createdAt" : "2019-11-19T16:08:10Z",
        "updatedAt" : "2019-11-19T22:40:52Z",
        "lastEditedBy" : "43409235-97e4-48dc-9ec7-403ee0a7de54",
        "tags" : [
        ]
      }
    ],
    "commit" : "df46a0c0ece38f03f22149c7964ffc4d607dc43b",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +393,397 @@                                  else EBuiltin BEError `ETyApp`\n                                       TForall (mkTypeVar \"proxy\", KArrow KStar KStar) (TApp (TVar $ mkTypeVar \"proxy\") polyType :-> typeConAppToType anyContractKeyTy :-> TOptional keyType) `ETmApp`\n                                       EBuiltin (BEText \"fromAnyContractKey is not supported in this DAML-LF version\")\n                        pure (Just $ TemplateKey keyType (applyThis key) (ETmApp maintainers hasKey), [hasKey, key, maintainers, fetchByKey, lookupByKey, toAnyContractKey, fromAnyContractKey], choices)\n                choices -> pure (Nothing, [], choices)"
  },
  {
    "id" : "74a0c62f-863e-4c9d-b4ee-a782ddda7c01",
    "prId" : 3434,
    "prUrl" : "https://github.com/digital-asset/daml/pull/3434",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bece8bd7-a0e4-4140-84fe-e9b44b9c90a5",
        "parentId" : null,
        "authorId" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "body" : "Good catch!",
        "createdAt" : "2019-11-12T18:59:55Z",
        "updatedAt" : "2019-11-12T19:01:24Z",
        "lastEditedBy" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "tags" : [
        ]
      }
    ],
    "commit" : "52581640eac42333bda95c3963414d7e418fa7e3",
    "line" : 23,
    "diffHunk" : "@@ -1,1 +965,969 @@            TScenario{} -> asLet\n            TAny{} -> asLet\n            tcon | isSimpleRecordCon con -> do\n                fields <- convertRecordFields env con id\n                case zipExactMay vs fields of"
  },
  {
    "id" : "0d4ac611-f47e-4ce5-b6d3-00a2e2ffc8b4",
    "prId" : 3434,
    "prUrl" : "https://github.com/digital-asset/daml/pull/3434",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6c5a6b3f-7579-40a8-97ac-2130ae203ab3",
        "parentId" : null,
        "authorId" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "body" : "![sad panda](https://i.kym-cdn.com/photos/images/newsfeed/000/092/706/Sad_Panda_Chibi_by_mongrelssister.png)\r\n\r\nPanda wants existentials :wink: ",
        "createdAt" : "2019-11-13T07:50:27Z",
        "updatedAt" : "2019-11-13T07:50:38Z",
        "lastEditedBy" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "tags" : [
        ]
      },
      {
        "id" : "19552376-021a-4cc7-a107-7a7a24a5ab0e",
        "parentId" : "6c5a6b3f-7579-40a8-97ac-2130ae203ab3",
        "authorId" : null,
        "body" : "hahahaha :-)",
        "createdAt" : "2019-11-13T10:07:00Z",
        "updatedAt" : "2019-11-13T10:07:00Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "52581640eac42333bda95c3963414d7e418fa7e3",
    "line" : 80,
    "diffHunk" : "@@ -1,1 +1190,1194 @@        SimpleVariantCon -> do\n            when (length vs /= dataConRepArity con) $\n                unsupported \"Pattern match with existential type\" alt\n            when (length vs >= 2) $\n                unsupported \"Data constructor with multiple unnamed fields\" alt"
  },
  {
    "id" : "7ddbac66-8738-4b1e-93d2-7e6d4ff6315d",
    "prId" : 3358,
    "prUrl" : "https://github.com/digital-asset/daml/pull/3358",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "67afc968-b617-4106-bfa0-977c02a51616",
        "parentId" : null,
        "authorId" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "body" : "Why do we try to cram all information into a single string that we then have to deconstruct? It seems easier to just give `external` multiple parameters.",
        "createdAt" : "2019-11-06T14:17:02Z",
        "updatedAt" : "2019-11-06T17:52:03Z",
        "lastEditedBy" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "tags" : [
        ]
      },
      {
        "id" : "01a94c35-2535-4cbe-94e5-7e6e41952038",
        "parentId" : "67afc968-b617-4106-bfa0-977c02a51616",
        "authorId" : "6bbb482c-d598-4c97-ac37-b89d94b27ee4",
        "body" : "I think the parameter number will be different for Choice instances and I wouldn't want to have a second primitive for those. If not, I'm happy to have a `external @pkg @mod @templ @method` primitive.",
        "createdAt" : "2019-11-06T17:51:01Z",
        "updatedAt" : "2019-11-06T17:52:03Z",
        "lastEditedBy" : "6bbb482c-d598-4c97-ac37-b89d94b27ee4",
        "tags" : [
        ]
      },
      {
        "id" : "3c4da697-ce19-45f8-86bf-876057ff790e",
        "parentId" : "67afc968-b617-4106-bfa0-977c02a51616",
        "authorId" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "body" : "we should be able to match on the number of parameters that `external` is applied to. That said, it doesn’t seem that unreasonable to have two primitives.",
        "createdAt" : "2019-11-06T17:52:48Z",
        "updatedAt" : "2019-11-06T17:52:48Z",
        "lastEditedBy" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "tags" : [
        ]
      }
    ],
    "commit" : "4b0aeb99ed4d3a42210e8653d7873d2ba828d51d",
    "line" : 89,
    "diffHunk" : "@@ -1,1 +1547,1551 @@convertExternal :: Env -> LF.PackageRef -> String -> LF.Type -> LF.Expr\nconvertExternal env stdlibRef primId lfType\n    | [pkgId, modStr, templName, method] <- splitOn \":\" primId\n    , Just LF.Template {..} <- lookup pkgId modStr templName =\n        let pkgRef = PRImport $ PackageId $ T.pack pkgId"
  },
  {
    "id" : "5561a0cf-7c4c-4825-8ee5-a650646b0ca4",
    "prId" : 3358,
    "prUrl" : "https://github.com/digital-asset/daml/pull/3358",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ed92644c-77b5-4c30-aba7-833142b60a04",
        "parentId" : null,
        "authorId" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "body" : "This code is somewhat sketchy. I can give you a DALF where `archive` does something completely different and you will happily generate a `Template` instance using this choice as the `archive` implementation. I don’t have a great solution here apart from verifying that this choice is actually the archive choice that we expect. Another hint that archive should really be a primitive.",
        "createdAt" : "2019-11-06T14:24:35Z",
        "updatedAt" : "2019-11-06T17:52:03Z",
        "lastEditedBy" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "tags" : [
        ]
      },
      {
        "id" : "b8466a17-0994-419c-8aa6-acec9182c39a",
        "parentId" : "ed92644c-77b5-4c30-aba7-833142b60a04",
        "authorId" : "6bbb482c-d598-4c97-ac37-b89d94b27ee4",
        "body" : "I think that would actually be fine. We would archive the template in the way the signatories agreed to upfront. But I wouldn't mind if it would be a primitive either so that a weird `archive` can't happen.",
        "createdAt" : "2019-11-06T16:21:54Z",
        "updatedAt" : "2019-11-06T17:52:03Z",
        "lastEditedBy" : "6bbb482c-d598-4c97-ac37-b89d94b27ee4",
        "tags" : [
        ]
      },
      {
        "id" : "cab0b710-26f5-480e-91fd-da542bc9c419",
        "parentId" : "ed92644c-77b5-4c30-aba7-833142b60a04",
        "authorId" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "body" : "It’s fine in the sense that you can’t do anything people haven’t agreed to before but it means that `archive` is now no longer guaranteed to archive a template, e.g., I could give you a nonconsuming choice that doesn’t archive anything.",
        "createdAt" : "2019-11-06T16:23:37Z",
        "updatedAt" : "2019-11-06T17:52:03Z",
        "lastEditedBy" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "tags" : [
        ]
      }
    ],
    "commit" : "4b0aeb99ed4d3a42210e8653d7873d2ba828d51d",
    "line" : 134,
    "diffHunk" : "@@ -1,1 +1592,1596 @@                                     \"convertExternal: archive is not implemented in external package\")\n                            Just TemplateChoice {..} ->\n                                case chcArgBinder of\n                                    (_, LF.TCon tcon) ->\n                                        let coid = mkVar \"$coid\""
  },
  {
    "id" : "194ad4e4-131a-4ba5-ba96-f7f4f7421c5a",
    "prId" : 3085,
    "prUrl" : "https://github.com/digital-asset/daml/pull/3085",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "56bdbe9c-94ad-498b-b2a4-038da68a440b",
        "parentId" : null,
        "authorId" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "body" : "Only catching this during LF conversion seems slightly ugly but admittedly I don’t know how to catch it earlier :disappointed: ",
        "createdAt" : "2019-10-02T13:21:30Z",
        "updatedAt" : "2019-10-02T13:29:09Z",
        "lastEditedBy" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "tags" : [
        ]
      }
    ],
    "commit" : "f9631283dd43576f6c41d5712f5867927ac1fabc",
    "line" : 45,
    "diffHunk" : "@@ -1,1 +659,663 @@        = fmap (, args) $ convertRationalNumericMono env n top bot\n    go env (VarIs \"fromRational\") (LType scaleTyCoRep : LExpr (VarIs \":%\" `App` tyInteger `App` Lit (LitNumber _ top _) `App` Lit (LitNumber _ bot _)) : args)\n        = unsupported \"Polymorphic numeric literal. Specify a fixed scale by giving the type, e.g. (1.2345 : Numeric 10)\" ()\n    go env (VarIs \"negate\") (tyInt : LExpr (VarIs \"$fAdditiveInt\") : LExpr (untick -> VarIs \"fromInteger\" `App` Lit (LitNumber _ x _)) : args)\n        = fmap (, args) $ convertInt64 (negate x)"
  },
  {
    "id" : "4b4fb684-5054-4720-bc26-036673741b93",
    "prId" : 2950,
    "prUrl" : "https://github.com/digital-asset/daml/pull/2950",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ba9aef97-7901-4c63-a8b5-09f5748e3b70",
        "parentId" : null,
        "authorId" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "body" : "There's no need for a multiway if here. ;)",
        "createdAt" : "2019-09-23T16:24:10Z",
        "updatedAt" : "2019-09-24T14:18:02Z",
        "lastEditedBy" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "tags" : [
        ]
      }
    ],
    "commit" : "bae243c1ecdc420b8ddb5e91675a9a0deec24993",
    "line" : 30,
    "diffHunk" : "@@ -1,1 +242,246 @@convertRationalNumericMono :: Env -> Integer -> Integer -> Integer -> ConvertM LF.Expr\nconvertRationalNumericMono env scale num denom =\n    if  | scale < 0 || scale > 37 ->\n            unsupported\n                (\"Tried to construct value of type Numeric \" ++ show scale ++ \", but scale is out of bounds. Scale must be between 0 through 37, not \" ++ show scale ++ \".\")"
  },
  {
    "id" : "4723de7b-852b-4d23-b51d-8f986687a8b3",
    "prId" : 2950,
    "prUrl" : "https://github.com/digital-asset/daml/pull/2950",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "eae76760-cb43-4070-97ed-5d6434cdc8db",
        "parentId" : null,
        "authorId" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "body" : "```suggestion\r\n    go env (VarIs \"fromRational\") (LType scaleTyCoRep : LExpr (VarIs \":%\" `App` tyInteger `App` Lit (LitNumber _ top _) `App` Lit (LitNumber _ bot _)) : args)\r\n        | Just n <- isNumLitTy scaleTyCoRep\r\n        = fmap (, args) $ convertRationalNumericMono env n top bot\r\n        | otherwise\r\n```\r\nand remove the case above. This will avoid some repetition.",
        "createdAt" : "2019-09-23T16:31:22Z",
        "updatedAt" : "2019-09-24T14:18:02Z",
        "lastEditedBy" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "tags" : [
        ]
      }
    ],
    "commit" : "bae243c1ecdc420b8ddb5e91675a9a0deec24993",
    "line" : 97,
    "diffHunk" : "@@ -1,1 +688,692 @@    go env (VarIs \"fromRational\") (LType (isNumLitTy -> Just n) : LExpr (VarIs \":%\" `App` tyInteger `App` Lit (LitNumber _ top _) `App` Lit (LitNumber _ bot _)) : args)\n        = fmap (, args) $ convertRationalNumericMono env n top bot\n    go env (VarIs \"fromRational\") (LType scaleTyCoRep : LExpr (VarIs \":%\" `App` tyInteger `App` Lit (LitNumber _ top _) `App` Lit (LitNumber _ bot _)) : args)\n        = do\n            scaleType <- convertType env scaleTyCoRep"
  },
  {
    "id" : "14109ccb-1489-4dc6-842c-84e832fc9433",
    "prId" : 2779,
    "prUrl" : "https://github.com/digital-asset/daml/pull/2779",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a7a8ef8d-90cc-4c8a-aac0-9793dc63f194",
        "parentId" : null,
        "authorId" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "body" : "Not really new in this PR and might be consistent with other parts of this module but for me shadowing the GHC identifiers with the converted DAML-LF identifiers makes things harder to understand. I would prefer something like `polyTypeLf <- convertType env polyType`. Since they have different types anyway the main advantage of shadowing namely that you can’t accidentally refer to the old identifier does not apply.",
        "createdAt" : "2019-09-05T16:58:00Z",
        "updatedAt" : "2019-09-10T11:14:25Z",
        "lastEditedBy" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "tags" : [
        ]
      },
      {
        "id" : "ff9c5fa7-920a-4470-b650-da543d355d39",
        "parentId" : "a7a8ef8d-90cc-4c8a-aac0-9793dc63f194",
        "authorId" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "body" : "I'll change this and a few other thing you mentioned in a cleanup PR. There's more stuff around there that needs some cleaning.",
        "createdAt" : "2019-09-05T19:47:19Z",
        "updatedAt" : "2019-09-10T11:14:25Z",
        "lastEditedBy" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "tags" : [
        ]
      }
    ],
    "commit" : "1ad2528d6a9763bf396a1c03fb414d73fa20ebee",
    "line" : 56,
    "diffHunk" : "@@ -1,1 +292,296 @@    = do\n        let tplLocation = convNameLoc monoTyCon\n        Ctors{_cCtors = [Ctor _ fields _]} <- toCtors env polyTyCon\n        polyType@(TConApp polyTyCon polyTyArgs) <- convertType env polyType\n        let polyTCA = TypeConApp polyTyCon polyTyArgs"
  },
  {
    "id" : "184d9082-5f96-4661-b5fd-6f414721eb2b",
    "prId" : 2779,
    "prUrl" : "https://github.com/digital-asset/daml/pull/2779",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a285e2b7-aa20-41e5-894e-5d7fe5738b0b",
        "parentId" : null,
        "authorId" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "body" : "```suggestion\r\n        let coerceRecord fromType toType fromExpr =\r\n```\r\n`rec` is too overloaded (recursive, record, I’m sure you can come up with other things) especially since you use it in a binding here.",
        "createdAt" : "2019-09-05T16:58:52Z",
        "updatedAt" : "2019-09-10T11:14:25Z",
        "lastEditedBy" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "tags" : [
        ]
      }
    ],
    "commit" : "1ad2528d6a9763bf396a1c03fb414d73fa20ebee",
    "line" : 64,
    "diffHunk" : "@@ -1,1 +297,301 @@        monoType@(TCon monoTyCon) <- convertTyCon env monoTyCon\n        let monoTCA = TypeConApp monoTyCon []\n        let coerceRec fromType toType fromExpr =\n                ELet (Binding (rec, typeConAppToType fromType) fromExpr) $\n                ERecCon toType $ map (\\field -> (field, ERecProj fromType field (EVar rec))) fields"
  },
  {
    "id" : "2a6c8dd0-cf7f-4bdf-afa5-5878deb362d7",
    "prId" : 2779,
    "prUrl" : "https://github.com/digital-asset/daml/pull/2779",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "396d3121-fe75-4679-82f3-0eeeeb0283bb",
        "parentId" : null,
        "authorId" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "body" : "This does look like it will make conversion more expensive both in runtime costs and codesize costs. Not necessarily an issue but worth keeping in mind.",
        "createdAt" : "2019-09-05T16:59:48Z",
        "updatedAt" : "2019-09-10T11:14:25Z",
        "lastEditedBy" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "tags" : [
        ]
      },
      {
        "id" : "53dab895-2989-45b1-a0cb-dfcf779e549c",
        "parentId" : "396d3121-fe75-4679-82f3-0eeeeb0283bb",
        "authorId" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "body" : "One way to make codesize smaller would be to factor this out into top-level functions so you don’t have to inline it into every choice.",
        "createdAt" : "2019-09-05T17:37:52Z",
        "updatedAt" : "2019-09-10T11:14:25Z",
        "lastEditedBy" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "tags" : [
        ]
      },
      {
        "id" : "8015cd01-aac2-4f0a-83fd-71ab15f4d63e",
        "parentId" : "396d3121-fe75-4679-82f3-0eeeeb0283bb",
        "authorId" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "body" : "That's a good idea. I'll do that in a separate PR.",
        "createdAt" : "2019-09-05T19:48:11Z",
        "updatedAt" : "2019-09-10T11:14:25Z",
        "lastEditedBy" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "tags" : [
        ]
      }
    ],
    "commit" : "1ad2528d6a9763bf396a1c03fb414d73fa20ebee",
    "line" : 71,
    "diffHunk" : "@@ -1,1 +303,307 @@                | null polyTyArgs = (id, id, id, id)\n                | otherwise =\n                    ( coerceRec monoTCA polyTCA\n                    , coerceRec polyTCA monoTCA\n                    , ETmApp $ mkETyApps (EBuiltin BECoerceContractId) [monoType, polyType]"
  },
  {
    "id" : "ff7ded41-ac6e-45cb-8dcc-907aa0091413",
    "prId" : 2779,
    "prUrl" : "https://github.com/digital-asset/daml/pull/2779",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d1859de5-795e-4c27-86c0-7a90da3e9a8a",
        "parentId" : null,
        "authorId" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "body" : "Do we really have no better way to detect this than to search for an `Instance` suffix? That seems quite easy to fool.",
        "createdAt" : "2019-09-05T17:00:37Z",
        "updatedAt" : "2019-09-10T11:14:25Z",
        "lastEditedBy" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "tags" : [
        ]
      },
      {
        "id" : "6090103a-8bc3-4a93-b14e-0c3b2e196ecb",
        "parentId" : "d1859de5-795e-4c27-86c0-7a90da3e9a8a",
        "authorId" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "body" : "Right now, I can't thing of any better. My plan is to change the class name from `FooInstance` to `Foo:Instance` or something similar that cannot be written by the user since it doesn't match the lexical rules.",
        "createdAt" : "2019-09-05T19:49:23Z",
        "updatedAt" : "2019-09-10T11:14:25Z",
        "lastEditedBy" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "tags" : [
        ]
      }
    ],
    "commit" : "1ad2528d6a9763bf396a1c03fb414d73fa20ebee",
    "line" : 105,
    "diffHunk" : "@@ -1,1 +427,431 @@    | isNewTyCon t\n    , ([], TypeCon tpl args) <- newTyConRhs t\n    , any (\\(c, args') -> getOccFS c == getOccFS tpl <> \"Instance\" && eqTypes args args') $ envInstances env\n    = do\n        ctors0 <- toCtors env tpl"
  },
  {
    "id" : "3e72d141-7140-4a8e-a75e-d97b442ba55b",
    "prId" : 2730,
    "prUrl" : "https://github.com/digital-asset/daml/pull/2730",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7f3be62e-4f65-4b76-bce7-9ef079afdf63",
        "parentId" : null,
        "authorId" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "body" : "I liked the way this was factored out into a separate function before.",
        "createdAt" : "2019-09-03T06:49:14Z",
        "updatedAt" : "2019-09-03T06:51:10Z",
        "lastEditedBy" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "tags" : [
        ]
      }
    ],
    "commit" : "4d1604d740ba4147cc7704c264ca375e2a788165",
    "line" : 19,
    "diffHunk" : "@@ -1,1 +250,254 @@              NonRec name body\n                -- NOTE(MH): We can't cope with the generated Typeable stuff, so remove those bindings\n                | any (`T.isPrefixOf` getOccText name) [\"$krep\", \"$tc\", \"$trModule\"] -> []\n                | otherwise -> [(name, body)]\n              Rec binds -> binds"
  },
  {
    "id" : "a9d01a77-38cc-4ed4-880d-045f46ca1959",
    "prId" : 2475,
    "prUrl" : "https://github.com/digital-asset/daml/pull/2475",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3546a59d-8b39-4e0f-9bd5-31d7c5c868a4",
        "parentId" : null,
        "authorId" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "body" : "@cocreature Unfortunately, comparing with `tupleDataCon Boxed 1` fails although that is exactly what we're looking for. Somehow the uniques don't match. Do you have an _immediate_ idea what could be going wrong?",
        "createdAt" : "2019-08-09T09:45:05Z",
        "updatedAt" : "2019-08-12T08:50:30Z",
        "lastEditedBy" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "tags" : [
        ]
      },
      {
        "id" : "00ceb75f-de91-4b86-941d-d041a621dcbd",
        "parentId" : "3546a59d-8b39-4e0f-9bd5-31d7c5c868a4",
        "authorId" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "body" : "@hurryabit Which part exactly is the one that ends up getting a different unique?",
        "createdAt" : "2019-08-09T09:47:29Z",
        "updatedAt" : "2019-08-12T08:50:30Z",
        "lastEditedBy" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "tags" : [
        ]
      },
      {
        "id" : "b81f418e-be06-4d4f-8036-06dc12809629",
        "parentId" : "3546a59d-8b39-4e0f-9bd5-31d7c5c868a4",
        "authorId" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "body" : "@cocreature The unique of `con` is different from the unique of `tupleDataCon Boxed 1` even when `con` matches the filter in line 1211. Does that answer your question?",
        "createdAt" : "2019-08-09T10:00:32Z",
        "updatedAt" : "2019-08-12T08:50:30Z",
        "lastEditedBy" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "tags" : [
        ]
      },
      {
        "id" : "8c5523b2-ccf2-41c4-8b12-7c3008e56d3f",
        "parentId" : "3546a59d-8b39-4e0f-9bd5-31d7c5c868a4",
        "authorId" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "body" : "Not sure what is going wrong here. Looking at the code, it seems like the unique in `tupleDataCon Boxed 1` should always be fixed so I guess the one in `con` is the one that varies? No idea why :confused: ",
        "createdAt" : "2019-08-09T10:47:50Z",
        "updatedAt" : "2019-08-12T08:50:30Z",
        "lastEditedBy" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "tags" : [
        ]
      }
    ],
    "commit" : "7623b54ec5f1094aed76e39eb7b121105c038996",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +1209,1213 @@      -- If we omit this workaround, `GHC.Tuple.Unit` gets translated into a\n      -- variant rather than a record and the `SugarUnit` test will fail.\n      || (getOccFS con == \"Unit\" && nameModule (getName con) == gHC_TUPLE)\n    = map (mkField . T.cons '_' . T.pack . show) [1..dataConSourceArity con]\n    | flv == NewtypeFlavour && null lbls"
  },
  {
    "id" : "ea25c726-27de-4615-85c4-202f0c18cca8",
    "prId" : 2466,
    "prUrl" : "https://github.com/digital-asset/daml/pull/2466",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6c07bdf5-8c8c-47f4-bbb8-9b7c8ff0eaff",
        "parentId" : null,
        "authorId" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "body" : "Maybe worth pulling `\\x -> mkVal $ \"$W\" <> x` into a top-level function? Having the assumptions about how GHC calls certain functions factored out into a few top-level functions seems much nicer than having this littered through the code.",
        "createdAt" : "2019-08-08T18:27:44Z",
        "updatedAt" : "2019-08-08T18:30:39Z",
        "lastEditedBy" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "tags" : [
        ]
      },
      {
        "id" : "9ec2334c-d857-43d1-aeee-ed85887dc277",
        "parentId" : "6c07bdf5-8c8c-47f4-bbb8-9b7c8ff0eaff",
        "authorId" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "body" : "Good point. I'll do it in a cleanup PR.",
        "createdAt" : "2019-08-08T18:35:29Z",
        "updatedAt" : "2019-08-08T18:35:29Z",
        "lastEditedBy" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "tags" : [
        ]
      }
    ],
    "commit" : "8ed4ea23a1498fbba4293b55a70c352da3a1a045",
    "line" : 10,
    "diffHunk" : "@@ -1,1 +413,417 @@  | isRecordCtor o\n  = pure $ [defDataType tconName tys $ DataRecord flds] ++\n      [ defValue name (mkVal $ \"$W\" <> getOccText ctor, mkTForalls tys $ mkTFuns fldTys (typeConAppToType tcon)) expr\n      | flavour == NewtypeFlavour\n      ]"
  },
  {
    "id" : "6e37dbd4-5df5-43f1-9e63-537b521ae258",
    "prId" : 2249,
    "prUrl" : "https://github.com/digital-asset/daml/pull/2249",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "88d91398-3b80-4b14-a2e0-bd28a26fb075",
        "parentId" : null,
        "authorId" : "c1c263c2-6852-4f5d-a507-38300d7a6e98",
        "body" : "Now `_createX` etc",
        "createdAt" : "2019-07-22T16:22:29Z",
        "updatedAt" : "2019-07-22T16:43:15Z",
        "lastEditedBy" : "c1c263c2-6852-4f5d-a507-38300d7a6e98",
        "tags" : [
        ]
      }
    ],
    "commit" : "0f35d92cf0b18616e2341e0b92ac7330dd26a60b",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +609,613 @@    = pure []\n    -- NOTE(MH): Desugaring `template X` will result in a type class\n    -- `XInstance` which has methods `createX`, `fetchX` and `exerciseXY`\n    -- (among others). The implementations of these methods are replaced\n    -- with DAML-LF primitives in `convertGenericChoice` below. As part of"
  }
]
[
  {
    "id" : "96996bc4-ce2b-471e-85fe-a5fd0638093b",
    "prId" : 7956,
    "prUrl" : "https://github.com/digital-asset/daml/pull/7956",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9301016f-83d1-42d6-b814-d4255a51b262",
        "parentId" : null,
        "authorId" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "body" : "You don't like `foldr`? ðŸ˜ƒ",
        "createdAt" : "2020-11-12T15:14:17Z",
        "updatedAt" : "2020-11-12T16:17:20Z",
        "lastEditedBy" : "695308fb-441d-4069-a1cc-f8c5944daace",
        "tags" : [
        ]
      },
      {
        "id" : "627994c2-050f-4c5f-86dd-dab5012ec8a1",
        "parentId" : "9301016f-83d1-42d6-b814-d4255a51b262",
        "authorId" : "f7ed27fc-83ac-401f-af8b-91c645eda7e9",
        "body" : "Changed to `foldr` :) ",
        "createdAt" : "2020-11-12T16:17:27Z",
        "updatedAt" : "2020-11-12T16:17:27Z",
        "lastEditedBy" : "f7ed27fc-83ac-401f-af8b-91c645eda7e9",
        "tags" : [
        ]
      }
    ],
    "commit" : "d4c20723e1f9d9cea769e8da4055c7f8c4b66034",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +276,280 @@\nmakeNonRecLets :: [(GHC.Var, GHC.Expr Var)] -> GHC.Expr Var -> GHC.Expr Var\nmakeNonRecLets lets body =\n    foldr (\\(x,y) b -> Let (NonRec x y) b) body lets"
  },
  {
    "id" : "ab65a37b-6bfd-43fd-9c4e-31a5c516787b",
    "prId" : 3667,
    "prUrl" : "https://github.com/digital-asset/daml/pull/3667",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "89cd5103-b267-4ff0-a907-e7944bdca02c",
        "parentId" : null,
        "authorId" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "body" : "GHC has the best names.",
        "createdAt" : "2019-11-28T16:13:42Z",
        "updatedAt" : "2019-11-28T16:35:51Z",
        "lastEditedBy" : "7ddbf119-9fd4-4e95-b47a-aa60f2648372",
        "tags" : [
        ]
      }
    ],
    "commit" : "5e7e947c49297bdbff942b9e807224650ca4f775",
    "line" : 15,
    "diffHunk" : "@@ -1,1 +102,106 @@-- | Break down a constraint tuple projection function name\n-- into an (index, arity) pair. These names have the form\n-- \"$p1(%,%)\" \"$p2(%,%)\" \"$p1(%,,%)\" etc.\nconstraintTupleProjection_maybe :: T.Text -> Maybe (Int, Int)\nconstraintTupleProjection_maybe t1 = do"
  }
]
[
  {
    "id" : "c976ce60-fee1-47f5-9de5-98b03e0b64d2",
    "prId" : 3798,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7cf19008-9e06-48b3-a355-2fe863574f81",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Is this consistent with the rules?\n\n```\nIn [5]: array(1)[(True,)]\nOut[5]: array([1])\n\nIn [6]: array(1)[[True]]\n---------------------------------------------------------------------------\nIndexError                                Traceback (most recent call last)\n<ipython-input-6-fc18d566cf7d> in <module>()\n----> 1 array(1)[[True]]\n\nIndexError: too many indices for array\n```\n",
        "createdAt" : "2014-02-02T05:38:59Z",
        "updatedAt" : "2014-02-07T14:07:27Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "59ffd48a-4d76-4d07-9728-d988c040f92e",
        "parentId" : "7cf19008-9e06-48b3-a355-2fe863574f81",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "It is a bit curious that scalar booleans return 1D arrays\n\n```\nIn [30]: a[True]\nOut[30]: array([1])\n```\n",
        "createdAt" : "2014-02-02T05:54:24Z",
        "updatedAt" : "2014-02-07T14:07:27Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "599f9d48-2553-4d80-8572-f771dd77d48a",
        "parentId" : "7cf19008-9e06-48b3-a355-2fe863574f81",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Hah, I first thought it looks like a bug too, but it is actually meant like that. I agree, it is non-obvious why this should be right, but of course I am convinced it is ;). The is this an example of why:\n\n```\ndef filter_subarrays_with_large_sum(array, large):\n    \"\"\"\n    arrays : ndarray {..., N}\n\n    out : ndarray {1, N}\n    \"\"\"\n    large_sum = array.sum(-1)\n    return array[large_sum >= large]\n```\n\nWith this change, the result will consistently add one dimension even if `array` is one dimensional and the 0-d change is the same. No dimension is removed (boolean index is 0-d) but as always one dimension is added. That said, it might be a large change.\n",
        "createdAt" : "2014-02-02T09:47:19Z",
        "updatedAt" : "2014-02-07T14:07:27Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      }
    ],
    "commit" : "d554c2954b82b120ce77c1fd9a74c4deb85503a3",
    "line" : 23,
    "diffHunk" : "@@ -1,1 +120,124 @@  * Boolean indexing into scalar arrays will always return a new 1-d array.\n    This means that ``array(1)[array(True)]`` gives ``array([1])`` and\n    not the original array.\n  * Advanced indexing into one dimensional arrays used to have (undocumented)\n    special handling regarding repeating the value array in assignments"
  },
  {
    "id" : "f08360cc-8fdb-4ed7-bc2f-467a30620e21",
    "prId" : 3798,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5ae41bfa-3877-4c42-a445-937ee3c34395",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "What is \"did not match\" when the value array was not too small?\n",
        "createdAt" : "2014-02-02T05:40:55Z",
        "updatedAt" : "2014-02-07T14:07:27Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "3aae8e1d-f84b-4e9b-8226-a784ec496c28",
        "parentId" : "5ae41bfa-3877-4c42-a445-937ee3c34395",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "`a = np.ones(10); a[np.arange(10)] = [1, 2, 3]`\n",
        "createdAt" : "2014-02-02T09:48:26Z",
        "updatedAt" : "2014-02-07T14:07:27Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      }
    ],
    "commit" : "d554c2954b82b120ce77c1fd9a74c4deb85503a3",
    "line" : 26,
    "diffHunk" : "@@ -1,1 +123,127 @@  * Advanced indexing into one dimensional arrays used to have (undocumented)\n    special handling regarding repeating the value array in assignments\n    when the shape of the value array was too small or did not match.\n    Code using this will raise an error. For compatibility you can use\n    ``arr.flat[index] = values``, which uses the old code branch."
  },
  {
    "id" : "25655f0e-d4e9-4f6d-9614-fda503f70520",
    "prId" : 3798,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ae26f5f9-71e7-489d-bd99-f45bf0f60243",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "When is a view returned?\n",
        "createdAt" : "2014-02-02T05:44:34Z",
        "updatedAt" : "2014-02-07T14:07:27Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "4bc4d1e9-2005-42b0-9663-79e5e0313c07",
        "parentId" : "ae26f5f9-71e7-489d-bd99-f45bf0f60243",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "oh, should add an example it is `a[...]` and the scalar special cases that used to do that.\n",
        "createdAt" : "2014-02-02T09:52:29Z",
        "updatedAt" : "2014-02-07T14:07:27Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      }
    ],
    "commit" : "d554c2954b82b120ce77c1fd9a74c4deb85503a3",
    "line" : 39,
    "diffHunk" : "@@ -1,1 +136,140 @@  * Equivalent to the iteration order, the memory layout of the advanced\n    indexing result is adapted for faster indexing and cannot be predicted.\n  * All indexing operations return a view or a copy. No indexing operation\n    will return the original array object. (For example `arr[...]`)\n  * In the future Boolean array-likes (such as lists of python bools)"
  },
  {
    "id" : "a27a5a4a-4952-4bae-9cd1-4c697b97b474",
    "prId" : 3798,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "64354c2a-125d-4336-9388-c60e592f7d4f",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "What determines the layout? Does this mean the result is not necessarily C or F contiguous even when new arrays are returned?\n",
        "createdAt" : "2014-02-02T05:46:45Z",
        "updatedAt" : "2014-02-07T14:07:27Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "96244489-ff84-41a4-94f9-2d364f612a7d",
        "parentId" : "64354c2a-125d-4336-9388-c60e592f7d4f",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Yes, should I note this? For fancy indexing with the fancy indexing not along the first axis this was always the case (maybe some exceptions for a Fortran order array being indexed)\n",
        "createdAt" : "2014-02-06T16:28:30Z",
        "updatedAt" : "2014-02-07T14:07:27Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "ad2e6f06-9b30-40b4-866b-e8f198d1f6fe",
        "parentId" : "64354c2a-125d-4336-9388-c60e592f7d4f",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Probably worth mentioning, just so people know. As you say, nothing much has changed, but folks might easily assume that it is C order. Is there a flag that can control the iterator behavior? That's not a suggestion to change things, just for my information.\n",
        "createdAt" : "2014-02-09T02:24:48Z",
        "updatedAt" : "2014-02-09T02:24:48Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "6d7e0d55-4570-4fe8-bb34-9941eafe1595",
        "parentId" : "64354c2a-125d-4336-9388-c60e592f7d4f",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Saw it only later. Basically to get back to the old behaviour would be pretty simple. To return a contiguous result would require a bit more (because of possible transposing). There is no switch to do that at the moment. Lets see how things turn out...\n",
        "createdAt" : "2014-02-10T12:15:41Z",
        "updatedAt" : "2014-02-10T12:15:41Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      }
    ],
    "commit" : "d554c2954b82b120ce77c1fd9a74c4deb85503a3",
    "line" : 37,
    "diffHunk" : "@@ -1,1 +134,138 @@    An example for this is ``arr[[0, 0], [1, 1]] = [1, 2]``, which may\n    set ``arr[0, 1]`` to either 1 or 2.\n  * Equivalent to the iteration order, the memory layout of the advanced\n    indexing result is adapted for faster indexing and cannot be predicted.\n  * All indexing operations return a view or a copy. No indexing operation"
  },
  {
    "id" : "396533dc-b0af-4afa-bcc8-072f859af688",
    "prId" : 3798,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "27cf4253-cb01-444d-ba2d-9196e368d68a",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Hmm... I suppose a FutureWarning wouldn't be severe enough.\n",
        "createdAt" : "2014-02-02T05:58:43Z",
        "updatedAt" : "2014-02-07T14:07:27Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "f9833919-c8c3-4a07-93e3-fce4596cb444",
        "parentId" : "27cf4253-cb01-444d-ba2d-9196e368d68a",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Didn't think about it too much, could also make it a futurewarning.  It is a pretty big corner case anyway since it only affects a single 0-d boolean array index into a not 0-d array.\n",
        "createdAt" : "2014-02-02T09:55:36Z",
        "updatedAt" : "2014-02-07T14:07:27Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      }
    ],
    "commit" : "d554c2954b82b120ce77c1fd9a74c4deb85503a3",
    "line" : 49,
    "diffHunk" : "@@ -1,1 +146,150 @@    equivalent to 1 and 0 if the result of the operation was a scalar.\n    This will raise an error in NumPy 1.9 and, as noted above, treated as a\n    boolean index in the future.\n  * All non-integer array-likes are deprecated, object arrays of custom\n    integer like objects may have to be cast explicitly."
  },
  {
    "id" : "3864df86-8e96-44c6-824e-1b9aabd777e0",
    "prId" : 3798,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0540e336-2f70-43bf-96f8-408e794a7968",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "What is an object inherits from int? That seems like it should still work.\n",
        "createdAt" : "2014-02-02T06:00:48Z",
        "updatedAt" : "2014-02-07T14:07:27Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "368d8c70-b59f-4fb0-b766-d1a9ca5bf9bc",
        "parentId" : "0540e336-2f70-43bf-96f8-408e794a7968",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Will have to think about it, since I don't think we have a machinery to \"safely\" cast object arrays to int. `np.array` won't touch the array and casting will also cast floats and strings.\n",
        "createdAt" : "2014-02-02T09:59:15Z",
        "updatedAt" : "2014-02-07T14:07:27Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      }
    ],
    "commit" : "d554c2954b82b120ce77c1fd9a74c4deb85503a3",
    "line" : 51,
    "diffHunk" : "@@ -1,1 +148,152 @@    boolean index in the future.\n  * All non-integer array-likes are deprecated, object arrays of custom\n    integer like objects may have to be cast explicitly.\n  * The error reporting for advanced indexing is more informative, however\n    the error type has changed in some cases. (Broadcasting errors of"
  },
  {
    "id" : "593c113e-9512-4751-a401-7b653cbfe46d",
    "prId" : 3984,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "791daf1d-180d-4d61-9806-7b454500c85f",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Should add the numpy version in which the change was. Also below where relevant.\n",
        "createdAt" : "2014-02-25T18:14:09Z",
        "updatedAt" : "2014-02-25T20:53:59Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "02da39f3-3210-4f24-b2e9-64c33c4004ef",
        "parentId" : "791daf1d-180d-4d61-9806-7b454500c85f",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "NVM, not in the release notes ;)\n",
        "createdAt" : "2014-02-25T18:14:32Z",
        "updatedAt" : "2014-02-25T20:53:59Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "1f9d4d2613d7c8bccf7e16720e8d0fa87e74e34a",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +182,186 @@promote_types and string dtype\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\npromote_types function now returns a valid string length when given an\ninteger or float dtype as one argument and a string dtype as another argument.\nPreviously it always returned the input string dtype, even if it wasn't"
  }
]
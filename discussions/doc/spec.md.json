[
  {
    "id" : "46c28eb3-2dd7-47fd-82fd-7f67ec2c2a0c",
    "prId" : 6512,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "dc9c4e1e-4593-499d-8ccb-1f42ee55ed53",
        "parentId" : null,
        "authorId" : "8ef7dcc8-4842-40e3-9f9a-182aa5f9b120",
        "body" : "You actually need to update the Word document (which is the authoritative source) and then run the `word2md` script to update this file.\n\nAlternatively, just skip this change and log a spec bug to handle the change.\n",
        "createdAt" : "2016-01-19T18:51:36Z",
        "updatedAt" : "2016-01-19T20:24:15Z",
        "lastEditedBy" : "8ef7dcc8-4842-40e3-9f9a-182aa5f9b120",
        "tags" : [
        ]
      }
    ],
    "commit" : "28840863a635b6803505a821bcb18d9638c38012",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +3886,3890 @@the inferred return type for 'f' and 'g' is Any because the functions reference themselves through a cycle with no return type annotations. Adding an explicit return type 'number' to either breaks the cycle and causes the return type 'number' to be inferred for the other.\n\nAn explicitly typed function whose return type isn't the Void type, the Any type, or a union type containing the Void or Any type as a constituent must have at least one return statement somewhere in its body. An exception to this rule is if the function implementation consists of a single 'throw' statement.\n\nThe type of 'this' in a function implementation is the Any type."
  },
  {
    "id" : "ca27b071-b534-4a4c-b819-f9fbe76cad77",
    "prId" : 4167,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1e0c9bce-2ea1-4d10-86cf-92716488a5d6",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "I'd consider rewriting \"encapsulate private fields and methods...\" to \"encapsulat_ing_ private fields and methods....\"\n",
        "createdAt" : "2015-08-05T16:40:43Z",
        "updatedAt" : "2015-08-05T18:56:46Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "312d9d1f-7f06-41bb-b567-bcf317b16658",
        "parentId" : "1e0c9bce-2ea1-4d10-86cf-92716488a5d6",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "We need an entirely new intro chapter. I will just leave this alone.\n",
        "createdAt" : "2015-08-05T18:58:49Z",
        "updatedAt" : "2015-08-05T18:58:49Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      }
    ],
    "commit" : "6ba3502de98215982953bf0c3b85d660e59804c7",
    "line" : 87,
    "diffHunk" : "@@ -1,1 +711,715 @@Classes and interfaces support large-scale JavaScript development by providing a mechanism for describing how to use a software component that can be separated from that component's implementation. TypeScript enforces *encapsulation* of implementation in classes at design time (by restricting use of private and protected members), but cannot enforce encapsulation at runtime because all object properties are accessible at runtime. Future versions of JavaScript may provide *private names* which would enable runtime enforcement of private and protected members.\n\nIn JavaScript, a very common way to enforce encapsulation at runtime is to use the module pattern: encapsulate private fields and methods using closure variables. The module pattern is a natural way to provide organizational structure and dynamic loading options by drawing a boundary around a software component. The module pattern can also provide the ability to introduce namespaces, avoiding use of the global namespace for most software components. \n\nThe following example illustrates the JavaScript module pattern."
  },
  {
    "id" : "44a31a9a-2549-4226-9663-c24c146a264b",
    "prId" : 4167,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e33b53b8-a64f-4f20-911a-3cd9f65e72c6",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "What is the reason that `any` is allowed as a constraint? I feel like I recall an issue relating to this.\n",
        "createdAt" : "2015-08-05T16:49:16Z",
        "updatedAt" : "2015-08-05T18:56:46Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "987899fa-58c6-445c-9a40-6c47a606aed1",
        "parentId" : "e33b53b8-a64f-4f20-911a-3cd9f65e72c6",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "It's always been allowed (any type can be a constraint because a constraint can be a type parameter). We now use it to indicate that additional properties are expected. See the last example in [this section](https://github.com/Microsoft/TypeScript/blob/updateLangSpec/doc/spec.md#3.11.5).\n",
        "createdAt" : "2015-08-05T18:24:44Z",
        "updatedAt" : "2015-08-05T18:56:46Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      }
    ],
    "commit" : "6ba3502de98215982953bf0c3b85d660e59804c7",
    "line" : 169,
    "diffHunk" : "@@ -1,1 +1438,1442 @@The scope of a type parameter extends over the entire declaration with which the type parameter list is associated, with the exception of static member declarations in classes.\n\nEach type parameter has an associated type parameter ***constraint*** that establishes an upper bound for type arguments. Omitting a constraint or specifying type `any` as the constraint corresponds to specifying the empty object type `{}`. Type parameters declared in a particular type parameter list may not be referenced in constraints in that type parameter list.\n\nThe ***base constraint*** of a type parameter *T* is defined as follows:"
  },
  {
    "id" : "fc41c8cc-f98a-456d-83b6-9f1bbb943777",
    "prId" : 900,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "550c691c-127e-4215-b222-50f14c663850",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Are we okay with these `�`s in the markdown? Can we convert smartquotes to regular quotes?\n",
        "createdAt" : "2014-10-16T06:54:58Z",
        "updatedAt" : "2014-10-16T06:54:58Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "698ace71-d6c7-4971-92fe-892397c58c1a",
        "parentId" : "550c691c-127e-4215-b222-50f14c663850",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "Fixed in #905.\n",
        "createdAt" : "2014-10-16T20:55:45Z",
        "updatedAt" : "2014-10-16T20:55:45Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      }
    ],
    "commit" : "881306d3c7b97ad4fc6e2b46db7020b67ed0d2ef",
    "line" : 99,
    "diffHunk" : "@@ -1,1 +1127,1131 @@***Union types*** represent values that may have one of several disjoint representations. A value of a union type *A* | *B* is a value that is *either* of type *A* or type *B*. Union types are written using union type literals (section [3.6.6](#3.6.6)).\n\nA union type encompasses an unordered set of unrelated types (that is, types that aren’t subtypes of each other). The following rules govern union types:\n\n* *A* | *B* is equivalent to *A* if *B* is a subtype of *A*."
  },
  {
    "id" : "7402fa53-4d46-48b7-96d5-4c37bdbd9cf6",
    "prId" : 784,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7279e68f-f4da-4fa0-b5a8-abfec6a66b64",
        "parentId" : null,
        "authorId" : "653c1a3f-9d47-48c5-8f19-f894f1744d89",
        "body" : "Error! Reference source not found << Is this an error in the word document or in the markdown conversion?\n(Edit: Sorry I saw danquirk already mentioned it)\n",
        "createdAt" : "2014-09-30T21:00:37Z",
        "updatedAt" : "2014-09-30T21:06:08Z",
        "lastEditedBy" : "653c1a3f-9d47-48c5-8f19-f894f1744d89",
        "tags" : [
        ]
      },
      {
        "id" : "2ed7fc4c-95cf-49b8-943e-bdc6ba918f88",
        "parentId" : "7279e68f-f4da-4fa0-b5a8-abfec6a66b64",
        "authorId" : "062f3bee-c17a-4517-ad46-ba1c73ac0962",
        "body" : "and to be clear, it's an error in the Word doc source not the markdown conversion\n",
        "createdAt" : "2014-09-30T22:07:00Z",
        "updatedAt" : "2014-09-30T22:07:00Z",
        "lastEditedBy" : "062f3bee-c17a-4517-ad46-ba1c73ac0962",
        "tags" : [
        ]
      }
    ],
    "commit" : "66b0b3d968ee80b2457a0d5a13eac97587b70bf0",
    "line" : 57,
    "diffHunk" : "@@ -1,1 +1069,1073 @@### <a name=\"3.3.2\"/>3.3.2 Array Types\n\n***Array types*** represent JavaScript arrays with a common element type. Array types are named type references created from the generic interface type ‘Array’ in the global module with the array element type as a type argument. Array type literals (section [Error! Reference source not found.](#Error! Reference source not found.)) provide a shorthand notation for creating such references.\n\nThe declaration of the ‘Array’ interface includes a property ‘length’ and a numeric index signature for the element type, along with other members:"
  },
  {
    "id" : "3a818fcd-adf1-4f37-9696-8780f31456b1",
    "prId" : 757,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "57e13240-a673-4958-ae0f-d37ab69135c1",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "The `A*rrayType*` output might be an issue with the formatting in the original document.\n",
        "createdAt" : "2014-09-26T15:58:09Z",
        "updatedAt" : "2014-09-26T15:58:23Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "9c4dc283-64fd-4b2d-a5b7-63d5023b3123",
        "parentId" : "57e13240-a673-4958-ae0f-d37ab69135c1",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "Yes, that's just a formatting error in the Word document.\n",
        "createdAt" : "2014-09-26T16:02:03Z",
        "updatedAt" : "2014-09-26T16:08:07Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      }
    ],
    "commit" : "59248ea9ee3cb8653721a6b9400e6b75c55008dc",
    "line" : 35,
    "diffHunk" : "@@ -1,1 +1355,1359 @@As the table above illustrates, an array type literal is shorthand for a reference to the generic interface type ‘Array’ in the global module, a function type literal is shorthand for an object type containing a single call signature, and a constructor type literal is shorthand for an object type containing a single construct signature. Note that function and constructor types with multiple call or construct signatures cannot be written as function or constructor type literals but must instead be written as object type literals.\n\nIn order to avoid grammar ambiguities, array type literals permit only a restricted set of notations for the element type. Specifically, an A*rrayType* cannot start with a *FunctionType* or *ConstructorType*. To use one of those forms for the element type, an array type must be written using the ‘Array&lt;T>’ notation. For example, the type\n\n```TypeScript"
  }
]
[
  {
    "id" : "3ac26900-f051-467c-8ac1-cb2720c18473",
    "prId" : 6377,
    "prUrl" : "https://github.com/numpy/numpy/pull/6377#pullrequestreview-159203394",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bcbcfb18-993c-4f16-b69e-b7c4f2647c2f",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "So there are some structures that have no `uint` alignment?",
        "createdAt" : "2018-09-26T18:00:06Z",
        "updatedAt" : "2018-09-27T19:44:05Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "7d5c78b4-3773-4cfc-9641-c780be1329d1",
        "parentId" : "bcbcfb18-993c-4f16-b69e-b7c4f2647c2f",
        "authorId" : "a4f03a99-2e43-482b-a9bc-5a9e359abb03",
        "body" : "Yes, that's one way to see it. Or, in pratice, those structs get assigned a `uint` alignment of 0.\r\n\r\nThe \"uint\" alignments are for use in the strided copy code, which only special-cases the 1,2,4,8, and 16 byte sizes. All other cases return a \"uint\" alignment of 0, which triggers `memmove` to be used instead.\r\n\r\nI'll correct/update the docs to better describe what happens for non-power-of-two sized types.",
        "createdAt" : "2018-09-26T21:19:26Z",
        "updatedAt" : "2018-09-27T19:44:05Z",
        "lastEditedBy" : "a4f03a99-2e43-482b-a9bc-5a9e359abb03",
        "tags" : [
        ]
      }
    ],
    "commit" : "12bd7c372ab5eeeff8bd2a46d765ccf28c6ce486",
    "line" : 34,
    "diffHunk" : "@@ -1,1 +32,36 @@alignment of 4 and \"uint\" alignment of 8 (equal to the true alignment of\n``uint64``).\n\nVariables in Numpy which control and describe alignment\n======================================================="
  }
]
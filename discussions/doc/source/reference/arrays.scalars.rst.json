[
  {
    "id" : "febeb274-d066-4742-8df2-e77c72e526dc",
    "prId" : 3526,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "dba9041e-8278-4898-9fd7-98bd63a939bf",
        "parentId" : null,
        "authorId" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "body" : "Instead of leaving the wrong information, and then putting in an addendum correcting it, can you just fix the text?\n\n![be_bold svg](https://f.cloud.github.com/assets/609896/812862/38846eaa-eef7-11e2-987d-5c4ee1020e9b.png)\n\nMaybe change \"Five of the scalar types...\" to \"Some of the scalar types...\", and then in the table say\n\n```\n:class:`IntType` (Python 2 only)\n```\n\n?\n",
        "createdAt" : "2013-07-17T15:42:26Z",
        "updatedAt" : "2013-08-10T19:28:30Z",
        "lastEditedBy" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "tags" : [
        ]
      }
    ],
    "commit" : "41e6f0617e198fe45427d3f63b58d940f0cdd3f8",
    "line" : 25,
    "diffHunk" : "@@ -1,1 +93,97 @@   The :class:`int_` type does **not** inherit from the\n   :class:`int` built-in under Python 3, because type :class:`int` is no\n   longer a fixed-width integer type.\n\n.. tip:: The default data type in Numpy is :class:`float_`."
  },
  {
    "id" : "c45adfbe-1c9a-4aae-a78d-18e0c33c143f",
    "prId" : 17331,
    "prUrl" : "https://github.com/numpy/numpy/pull/17331#pullrequestreview-489964722",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a74c0830-c4bf-4c86-b2ee-a45be2761ab0",
        "parentId" : null,
        "authorId" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "body" : "Rather than `..autoclass:: numpy.byte`, try\r\n```\r\n.. autosummary::\r\n    :toctree: generated\r\n    :nosignatures:\r\n\r\n    numpy.byte\r\n    numpy.short\r\n    ...\r\n```",
        "createdAt" : "2020-09-16T17:04:08Z",
        "updatedAt" : "2020-10-05T18:16:44Z",
        "lastEditedBy" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "tags" : [
        ]
      },
      {
        "id" : "50b8b2ce-e7ee-48ee-8c07-fd84248c41bf",
        "parentId" : "a74c0830-c4bf-4c86-b2ee-a45be2761ab0",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "That would probably work, but I don't really want a page per class, because then we lose the ability to see the character codes and aliases all in one place.",
        "createdAt" : "2020-09-16T17:21:14Z",
        "updatedAt" : "2020-10-05T18:16:44Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "bac9610a-62ea-4267-9c11-5b30b151ee51",
        "parentId" : "a74c0830-c4bf-4c86-b2ee-a45be2761ab0",
        "authorId" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "body" : "Then I think you need to create a template to override the default one in `doc/source/_templates/autosummary/class.rst` and use a `:template:` option on the [autosummary](https://www.sphinx-doc.org/en/master/usage/extensions/autosummary.html?highlight=templates#customizing-templates). I don't know if `:template:` works with `autoclass`",
        "createdAt" : "2020-09-16T19:22:39Z",
        "updatedAt" : "2020-10-05T18:16:44Z",
        "lastEditedBy" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "tags" : [
        ]
      },
      {
        "id" : "c5273f6f-d4e8-4aae-af8f-dfd161e7ef60",
        "parentId" : "a74c0830-c4bf-4c86-b2ee-a45be2761ab0",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Autosummary shouldn't be relevant here - it's built on top of autodoc, not vice versa. I think numpydoc is injecting an autosummary into the autodoc docstring or something.",
        "createdAt" : "2020-09-16T19:40:52Z",
        "updatedAt" : "2020-10-05T18:16:44Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "72b9f4995045e73cf4431b08877f8d2dbb5fa0d9",
    "line" : 139,
    "diffHunk" : "@@ -1,1 +106,110 @@   :exclude-members:\n\nSigned integer types\n++++++++++++++++++++\n"
  },
  {
    "id" : "a3f2d02e-eefe-4a43-b06e-a6ec10d4c4f3",
    "prId" : 18007,
    "prUrl" : "https://github.com/numpy/numpy/pull/18007#pullrequestreview-553705843",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a6d76aa5-0230-4916-b71e-2423db2abc7f",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "This reference is failing on CircleCI.\r\n```\r\nWARNING: undefined label: overflow-errors (if the link has no caption the label must precede a section header)\r\nmake: *** [Makefile:179: html-build] Error 1\r\n```",
        "createdAt" : "2020-12-16T13:54:19Z",
        "updatedAt" : "2020-12-27T17:40:44Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "4832edc55ffa7ba66ced716bfebbec05d93f8097",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +112,116 @@\n   The numpy integer types mirror the behavior of C integers, and can therefore\n   be subject to :ref:`overflow-errors`.\n\nSigned integer types"
  },
  {
    "id" : "a4f0cc32-cc6a-4d3d-9beb-2451aa2f77b6",
    "prId" : 18007,
    "prUrl" : "https://github.com/numpy/numpy/pull/18007#pullrequestreview-558948859",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "155a0c2b-16dd-458f-a1da-1017be094dc7",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Thoughts on extending this to:\r\n\r\n<details>\r\n\r\n```suggestion\r\n   Note that none of these floats hold the exact value :math:`\\frac{1}{10}`;\r\n   ``f16`` prints as ``0.1`` because it is as close to that value as possible,\r\n   whereas the other types do not as they have more precision and therefore have\r\n   closer values.\r\n   \r\n   Conversely, the same value approximated at different precisions may compare\r\n   unequal despite printing identically:\r\n   \r\n       >>> f16 = np.float16(\"0.1\")\r\n       >>> f32 = np.float32(\"0.1\")\r\n       >>> f64 = np.float64(\"0.1\")\r\n       >>> f16 == f32 == f64\r\n       False\r\n       >>> f16, f32, f64\r\n       (0.1, 0.1, 0.1)\r\n```\r\n\r\n</details>",
        "createdAt" : "2020-12-16T14:24:10Z",
        "updatedAt" : "2020-12-27T17:40:44Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "25a32eea-70dc-426d-8155-34f4d14c66b6",
        "parentId" : "155a0c2b-16dd-458f-a1da-1017be094dc7",
        "authorId" : "a4f03a99-2e43-482b-a9bc-5a9e359abb03",
        "body" : "I think this is good to add, but I might tweak the language:\r\n\r\n> Note that none of these floats hold the exact fraction :math:`\\frac{1}{10}`, which cannot be represented in binary with finite precision.  The ``f16`` scalar prints as ``0.1`` because it is the ``f16`` value which is closest to the decimal value 0.1 among all ``f16`` values,  whereas the ``f32`` and ``f64`` scalars do not as their datatypes have more precision and therefore have other values closer to decimal 0.1.\r\n\r\n> Conversely,  floating-point scalars of different precisions which approximate the same decimal value may compare unequal despite printing identically:",
        "createdAt" : "2020-12-16T17:16:51Z",
        "updatedAt" : "2020-12-27T17:40:44Z",
        "lastEditedBy" : "a4f03a99-2e43-482b-a9bc-5a9e359abb03",
        "tags" : [
        ]
      },
      {
        "id" : "c93b4194-b616-4b4e-9628-cd2ad63c0c69",
        "parentId" : "155a0c2b-16dd-458f-a1da-1017be094dc7",
        "authorId" : "a4f03a99-2e43-482b-a9bc-5a9e359abb03",
        "body" : "Perhaps consider adding:\r\n```\r\n>>> np.format_float_positional(np.float16('0.1'), unique=False, precision=40)\r\n'0.0999755859375000000000000000000000000000'\r\n>>> np.format_float_positional(np.float32('0.1'), unique=False, precision=40)\r\n'0.1000000014901161193847656250000000000000'\r\n>>> np.format_float_positional(np.float64('0.1'), unique=False, precision=40)\r\n'0.1000000000000000055511151231257827021182'\r\n```",
        "createdAt" : "2020-12-16T17:18:49Z",
        "updatedAt" : "2020-12-27T17:40:44Z",
        "lastEditedBy" : "a4f03a99-2e43-482b-a9bc-5a9e359abb03",
        "tags" : [
        ]
      },
      {
        "id" : "f00d7301-d2a4-4b23-a663-64771153c18c",
        "parentId" : "155a0c2b-16dd-458f-a1da-1017be094dc7",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "I think that last comment probably belongs in the docs for `format_float_positional`.",
        "createdAt" : "2020-12-27T17:39:02Z",
        "updatedAt" : "2020-12-27T17:40:44Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "538dc941-6ab2-4d9d-8908-b16236f6b2cd",
        "parentId" : "155a0c2b-16dd-458f-a1da-1017be094dc7",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Marking as unresolved as I have not taken @ahaldane's suggestion above, which feels a bit wordy:\r\n```suggestion\r\n   Note that none of these floats hold the exact fraction :math:`\\frac{1}{10}`,\r\n   which cannot be represented in binary with finite precision. The ``f16``\r\n   scalar prints as ``0.1`` because it is the ``f16`` value which is closest to the\r\n   decimal value ``0.1`` among all ``f16`` values, whereas the ``f32`` and ``f64``\r\n   scalars do not as their datatypes have more precision and therefore have\r\n   other values closer to decimal ``0.1``.\r\n```",
        "createdAt" : "2020-12-27T17:39:34Z",
        "updatedAt" : "2020-12-27T17:43:11Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "4832edc55ffa7ba66ced716bfebbec05d93f8097",
    "line" : 37,
    "diffHunk" : "@@ -1,1 +196,200 @@   ``f16`` prints as ``0.1`` because it is as close to that value as possible,\n   whereas the other types do not as they have more precision and therefore have\n   closer values.\n   \n   Conversely, floating-point scalars of different precisions which approximate"
  },
  {
    "id" : "c1fab243-6141-437c-8c2a-3ae3a81cc1a9",
    "prId" : 18007,
    "prUrl" : "https://github.com/numpy/numpy/pull/18007#pullrequestreview-553887876",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e8d17d26-f0c2-4827-817d-11489703aee6",
        "parentId" : null,
        "authorId" : "a4f03a99-2e43-482b-a9bc-5a9e359abb03",
        "body" : "It could be nice to point the reader to the docstrings of `np.set_printoptions`, and `np.format_float_positional/np.format_float_scientific` for descriptions of the \"unique\" printing option.\r\n\r\nMaybe we can even re-use the same language, as in:\r\n\r\n >  Inexact scalars are printed using the fewest decimal digits needed to uniquely identify the inexact number from other values of the same datatype, by judicious rounding. See the `unique` parameter of `np.format_float_positional` and `np.format_float_scientific`, and the `floatmode='unique' option of `np.set_printoptions` for more information.  This means that variables with equal binary values but whose datatypes are of different precisions may display differently::\r\n",
        "createdAt" : "2020-12-16T16:53:03Z",
        "updatedAt" : "2020-12-27T17:40:44Z",
        "lastEditedBy" : "a4f03a99-2e43-482b-a9bc-5a9e359abb03",
        "tags" : [
        ]
      }
    ],
    "commit" : "4832edc55ffa7ba66ced716bfebbec05d93f8097",
    "line" : 24,
    "diffHunk" : "@@ -1,1 +183,187 @@\n   This means that variables with equal binary values but whose datatypes are of\n   different precisions may display differently::\n\n       >>> f16 = np.float16(\"0.1\")"
  }
]
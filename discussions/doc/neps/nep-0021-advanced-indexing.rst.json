[
  {
    "id" : "bf4bcb1d-155e-4bb7-92ed-0236a3b4885c",
    "prId" : 6256,
    "prUrl" : "https://github.com/numpy/numpy/pull/6256#pullrequestreview-130571716",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "da38dc36-9cb0-4300-b34b-e9814f958e52",
        "parentId" : null,
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "My tendency would be to require that subclasses override the new methods if they need to; I don't like the extra code.\r\n\r\nBut one possible solution to ensure things \"just break\" might be to go through the `__getitem__` call with an extra keyword set, say `index_method='outer|vector|fancy|` - if a subclass cannot take this extra keyword, it will immediately fail. (Obviously, this keyword needs to have a default of `None` that can then change from meaning `fancy` to `outer`).\r\n\r\nIndeed, a keyword argument would be super-nice if [PEP 472](https://www.python.org/dev/peps/pep-0472/) were accepted...",
        "createdAt" : "2018-06-20T18:25:44Z",
        "updatedAt" : "2018-06-20T23:49:54Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      },
      {
        "id" : "c11bb5b5-9dee-476c-be31-3664b5628ea7",
        "parentId" : "da38dc36-9cb0-4300-b34b-e9814f958e52",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Probably, the that was hanging me was that getting masked arrays right was damn annoying, plus we also need to have a way for things like memmap. I am not sure why a kwarg is super nice if that PEP is accepted, we get a mix of different meanings for kwargs, so trying to not use kwargs because of the PEP might be a point?",
        "createdAt" : "2018-06-20T18:34:38Z",
        "updatedAt" : "2018-06-20T23:49:54Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "37dd8a4e-be5b-4706-b077-4e773a8b517f",
        "parentId" : "da38dc36-9cb0-4300-b34b-e9814f958e52",
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "Yes, on closer reading of the PEP, my suggestion would require the `kwarg` strategy; https://www.python.org/dev/peps/pep-0472/#strategy-kwargs-argument\r\n\r\nNow it doesn't look like the PEP is actually going anywhere...\r\n\r\nAnyway, my overall sense is that this should not hold up the NEP, or, indeed, the implementation.",
        "createdAt" : "2018-06-20T18:43:54Z",
        "updatedAt" : "2018-06-20T23:49:54Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      },
      {
        "id" : "6af59cdb-db3c-4d5a-90fc-6de05e13626f",
        "parentId" : "da38dc36-9cb0-4300-b34b-e9814f958e52",
        "authorId" : "576cec6e-8071-43f8-bce9-351a2589f050",
        "body" : "We could potentially call `self.__getitem__(indices, index_method='outer')` directly. We just can't write `self[indices, index_method='outer']`.",
        "createdAt" : "2018-06-20T18:55:40Z",
        "updatedAt" : "2018-06-20T23:49:54Z",
        "lastEditedBy" : "576cec6e-8071-43f8-bce9-351a2589f050",
        "tags" : [
        ]
      },
      {
        "id" : "6c7ecaeb-0f48-4e4b-987c-2ac54d527208",
        "parentId" : "da38dc36-9cb0-4300-b34b-e9814f958e52",
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "That is indeed what I had in mind, and I thought the PEP might eventually make that possible as well, but it turns out that is true only for one of its options. Anyway, at some level that is a separate concern. The main advantage of the `index_method` approach is that subclasses would fail automatically (and that one could change the default at some point).",
        "createdAt" : "2018-06-20T19:48:46Z",
        "updatedAt" : "2018-06-20T23:49:54Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      },
      {
        "id" : "180dce70-dc6b-48cf-9e0d-1e90d604a944",
        "parentId" : "da38dc36-9cb0-4300-b34b-e9814f958e52",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "I misread the PEP, my gut feeling is, if `arr[indices, index_method='outer']` would work, that would not be nice. Unless you want to use it instead of the `arr.oindex[indices]` syntax maybe. Simply because `index_method='outer'` could also mean get me \"outer\" from the axis \"index_method\"?",
        "createdAt" : "2018-06-20T20:01:56Z",
        "updatedAt" : "2018-06-20T23:49:54Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "6099327a-d64f-4834-8906-d58d7ff33d58",
        "parentId" : "da38dc36-9cb0-4300-b34b-e9814f958e52",
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "Yes, it would preclude having an axis called `index_method`!\r\n\r\nAnyway, right now we cannot use keywords inside `[...]` at all, so that part is not so relevant. The main question is whether it is worth solving the subclass issue by having `__getitem__` acquire an extra argument that we use internally (and `oindex` and `vindex` just being shortcuts to it).\r\n\r\nI should add that I don't really have an opinion one way or another; I do think it is fine to expect subclasses to pay attention and adjust to new `ndarray` features (we just have to try our best not to break existing features).",
        "createdAt" : "2018-06-20T20:18:04Z",
        "updatedAt" : "2018-06-20T23:49:54Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      }
    ],
    "commit" : "af2aa15684384493e3b9eac505c5d209b8298a3c",
    "line" : 208,
    "diffHunk" : "@@ -1,1 +206,210 @@and should preferably not subclass working versions of these attributes.\n\nAll subclasses will inherit the attributes, however, it seems possible\nto test ``subclass.__getitem__.__classobj__`` when getting i.e.\n``subclass.vindex``. If this is not ``ndarray``, the subclass has special"
  },
  {
    "id" : "9c646bab-6124-4916-ac85-b9600936a6e5",
    "prId" : 6256,
    "prUrl" : "https://github.com/numpy/numpy/pull/6256#pullrequestreview-130565629",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7ee5fe21-3fc4-4a44-ac70-0133027d1cd7",
        "parentId" : null,
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "I echo @jaimefrio's comment from way back that having `[0]` remove a dimension and `0` keep it is *extremely* confusing. But it may just mean I still do not understand fancy indexing...",
        "createdAt" : "2018-06-20T18:33:30Z",
        "updatedAt" : "2018-06-20T23:49:54Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      },
      {
        "id" : "099c15cd-b319-4deb-8808-9cd5e557cb48",
        "parentId" : "7ee5fe21-3fc4-4a44-ac70-0133027d1cd7",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Frankly, I am a bit confused what you mean :). Any index \"removes\" the dimension in some sense (for vindex, oindex in some sense replaces it), the question is just where to put the new dims. Jaime had a comment suggesting to maybe keep the axis swapping in a less confusing manner then it used to exist.\r\nRight now, I disagree with this. `vindex` should be as consistent as possible, there is nothing special enough about `[0]` compared to `[0, 1]`. There **might** be a \"less confusing then currently fancy indexing like transposing\" thing, but I personally believe you can use oindex then, it already does what you want, no?",
        "createdAt" : "2018-06-20T18:40:54Z",
        "updatedAt" : "2018-06-20T23:49:54Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "8681cc4d-4fb7-463d-97b3-783681341328",
        "parentId" : "7ee5fe21-3fc4-4a44-ac70-0133027d1cd7",
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "I just don't understand why here a leading `1` appears. But as said, my understanding of fancy indexing is quite hopeless.  I do agree with the always-transpose-to-the-front rule.",
        "createdAt" : "2018-06-20T18:50:58Z",
        "updatedAt" : "2018-06-20T23:49:54Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      },
      {
        "id" : "55808b47-0d83-4cce-8bb8-c9faca90879c",
        "parentId" : "7ee5fe21-3fc4-4a44-ac70-0133027d1cd7",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Well, the thing is, there is a 1 sized dimension created by the  `[1]` so it has to go somewhere? And in vindex that somewhere is the front? ",
        "createdAt" : "2018-06-20T19:30:40Z",
        "updatedAt" : "2018-06-20T23:49:54Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "312d9760-9683-46f9-8703-4406ba052eec",
        "parentId" : "7ee5fe21-3fc4-4a44-ac70-0133027d1cd7",
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "Yes, that is logical, but then why is it not happening in the examples right above? Or are those mistakes?",
        "createdAt" : "2018-06-20T19:54:28Z",
        "updatedAt" : "2018-06-20T23:49:54Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      },
      {
        "id" : "d6f1466d-6013-4f83-b19a-7c1f87be5b18",
        "parentId" : "7ee5fe21-3fc4-4a44-ac70-0133027d1cd7",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Well, its vindex, not oindex. All indexes (except slices I guess) are broadcast together for the result (just like legacy fancy indexing) and iterated together. So the extra dimension at the start has size 2 because it has the size of `[0]` and `[0, 1]` broadcast together.",
        "createdAt" : "2018-06-20T19:58:14Z",
        "updatedAt" : "2018-06-20T23:49:54Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "7a766702-a4d4-45f7-93ab-0e30586f1133",
        "parentId" : "7ee5fe21-3fc4-4a44-ac70-0133027d1cd7",
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "A, see, I knew I was missing something. Though this is particularly silly. Sorry for the noise.",
        "createdAt" : "2018-06-20T20:01:00Z",
        "updatedAt" : "2018-06-20T23:49:54Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      }
    ],
    "commit" : "af2aa15684384493e3b9eac505c5d209b8298a3c",
    "line" : 389,
    "diffHunk" : "@@ -1,1 +387,391 @@    >>> arr.vindex[:, [0], :, [0, 1]].shape\n    (2, 5, 7)\n    >>> arr.vindex[:, [0], 0, :].shape\n    (1, 5, 8)\n    >>> arr.vindex[:, [0], :, 0].shape"
  },
  {
    "id" : "7d396b30-a8ad-4162-96ec-1d167b8f6a5e",
    "prId" : 11414,
    "prUrl" : "https://github.com/numpy/numpy/pull/11414#pullrequestreview-131705521",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b1339365-3a70-46a2-9098-f6d3714c866e",
        "parentId" : null,
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "I do not disagree, but I have a bit of reservations.\r\n 1. We have to figure out subclasses internally, mostly for masked arrays (I do not care about matrix really, it is horribly broken, and maybe OK to not to support them. The mmap subclass is pretty simple so also not a big deal).\r\n 2. I am still not quite sure if ideas such as `__numpy_getitem__` (or a kwarg to getitem itself) may be the best way.\r\n\r\nOr should we just ignore it for MA. Probably I am just not doing enough with funny array-likes to have a quite clear plan.",
        "createdAt" : "2018-06-24T21:19:37Z",
        "updatedAt" : "2018-06-25T21:20:42Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "d793f8f1-fa61-4a5e-9656-0575e7c30622",
        "parentId" : "b1339365-3a70-46a2-9098-f6d3714c866e",
        "authorId" : "576cec6e-8071-43f8-bce9-351a2589f050",
        "body" : "I think it would be fine not to immediately implement oindex/vindex for masked arrays, as long as we don’t break existing behavior. Somebody who cares about masked arrays will need to work on it.",
        "createdAt" : "2018-06-25T05:04:36Z",
        "updatedAt" : "2018-06-25T21:20:42Z",
        "lastEditedBy" : "576cec6e-8071-43f8-bce9-351a2589f050",
        "tags" : [
        ]
      },
      {
        "id" : "03e939d2-92d5-4940-aa05-35860921052b",
        "parentId" : "b1339365-3a70-46a2-9098-f6d3714c866e",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "> or a kwarg to getitem itself\r\n\r\nOther alternatives I can think of for the meaning of `arr.oindex[a, b, c]`:\r\n\r\n* `arr[np.core.orthogonal_index((a, b, c))]` - will work fine by default on maskedarrays, and any subclasses that just forward the indexer to the base class\r\n* `arr[np.core.orthogonal_indexing, a, b, c]` (like C++ tag-dispatching)",
        "createdAt" : "2018-06-25T06:44:12Z",
        "updatedAt" : "2018-06-25T21:20:42Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "1d350308-e8ff-4c45-af4b-9de36394b095",
        "parentId" : "b1339365-3a70-46a2-9098-f6d3714c866e",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Well, one thing to consider is, that if MA does not support it and we implement DeprecationWarnings, for example matplotlib might have no way to go forward with the warnings? Though thta might be a general problem, since backward compatibility and avoiding warnings is tricky. It would be good to find a solution for that!",
        "createdAt" : "2018-06-25T14:43:54Z",
        "updatedAt" : "2018-06-25T21:20:42Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "625f153b-6280-417a-9097-2fbbae3bf0aa",
        "parentId" : "b1339365-3a70-46a2-9098-f6d3714c866e",
        "authorId" : "576cec6e-8071-43f8-bce9-351a2589f050",
        "body" : "it would probably be quite easy to make masked array’s ‘__getitem__‘ use ‘legacy_index‘ internally. That’s about as far as I would be willing to go, personally.",
        "createdAt" : "2018-06-25T14:58:23Z",
        "updatedAt" : "2018-06-25T21:20:42Z",
        "lastEditedBy" : "576cec6e-8071-43f8-bce9-351a2589f050",
        "tags" : [
        ]
      },
      {
        "id" : "809c489b-a300-450b-a64a-9064607db854",
        "parentId" : "b1339365-3a70-46a2-9098-f6d3714c866e",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Fair point, though it feels a bit half arsed to me :). With a bit of effort from someone not me we could have had that two years ago, hehe...",
        "createdAt" : "2018-06-25T17:23:09Z",
        "updatedAt" : "2018-06-25T21:20:42Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      }
    ],
    "commit" : "609eef0ee29dda6d6fe45d4d2e274392717db9ef",
    "line" : 401,
    "diffHunk" : "@@ -1,1 +332,336 @@Possibly a mixin could be provided to help implementation. These improvements\nare not essential to the initial implementation, so they are saved for\nfuture work.\n\nImplementation"
  },
  {
    "id" : "0ff43d73-d557-4a2c-be14-0aabd19ac5c4",
    "prId" : 11414,
    "prUrl" : "https://github.com/numpy/numpy/pull/11414#pullrequestreview-131640047",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "19b7624f-1a87-4ca4-a333-60a433d3eafa",
        "parentId" : null,
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Are you suggesting we do not allow higher dim bools in `oindex`? It seems rather useful to me, even if basically just a helper around nonzero.",
        "createdAt" : "2018-06-24T21:57:16Z",
        "updatedAt" : "2018-06-25T21:20:42Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "e3edd6b7-9712-4610-84f2-0f323d420731",
        "parentId" : "19b7624f-1a87-4ca4-a333-60a433d3eafa",
        "authorId" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "body" : "Maybe add it to `Alternatives` ?",
        "createdAt" : "2018-06-24T22:23:40Z",
        "updatedAt" : "2018-06-25T21:20:42Z",
        "lastEditedBy" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "tags" : [
        ]
      },
      {
        "id" : "6e6b1599-b735-43a1-a2f0-716f5af2b304",
        "parentId" : "19b7624f-1a87-4ca4-a333-60a433d3eafa",
        "authorId" : "576cec6e-8071-43f8-bce9-351a2589f050",
        "body" : "The possibility of allowing booleans with more than one dimension in oindex never occurred to me. I will need to ponder it.",
        "createdAt" : "2018-06-25T05:01:33Z",
        "updatedAt" : "2018-06-25T21:20:42Z",
        "lastEditedBy" : "576cec6e-8071-43f8-bce9-351a2589f050",
        "tags" : [
        ]
      },
      {
        "id" : "9e14e2fa-141e-4403-ade0-63405605f754",
        "parentId" : "19b7624f-1a87-4ca4-a333-60a433d3eafa",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "I think I tried to add support for that to `np.ix_` at some point in the past..",
        "createdAt" : "2018-06-25T06:46:56Z",
        "updatedAt" : "2018-06-25T21:20:42Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "356c09e4-f2d5-4d00-886f-a236d5ce71b4",
        "parentId" : "19b7624f-1a87-4ca4-a333-60a433d3eafa",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "I think it definitely makes sense, unless you want to do something like allow a higher D boolean, but not in combination with others, which seems strange to me. It is also a nice thing about forcing the correct dimension for the index itself, I think that might reduce bugs for such cases slightly.\r\n\r\nWhat I could imagine discussing is to not quite allow all such cases for the final state of plain indexing.\r\n\r\nAbout `np.ix_` I think adding it shouldn't be too hard (with the exception of 0d bools maybe, would have to think about it), but if this moves ahead...",
        "createdAt" : "2018-06-25T14:42:06Z",
        "updatedAt" : "2018-06-25T21:20:42Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      }
    ],
    "commit" : "609eef0ee29dda6d6fe45d4d2e274392717db9ef",
    "line" : 93,
    "diffHunk" : "@@ -1,1 +85,89 @@``x[np.ix_([0, 1], [0, 1])]``. However, there are no utilities for emulating\nfully general/mixed outer indexing, which could unambiguously allow for slices,\nintegers, and 1D boolean and integer arrays.\n\nMixed indexing"
  },
  {
    "id" : "e46589da-9024-4a4c-8563-6a6e825e7991",
    "prId" : 11414,
    "prUrl" : "https://github.com/numpy/numpy/pull/11414#pullrequestreview-131484542",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2ef64041-2c56-463b-b901-af48e9bc2264",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Probably worth noting why this is a good idea, and how the desired behavior can be built from `np.nonzero`",
        "createdAt" : "2018-06-25T06:50:35Z",
        "updatedAt" : "2018-06-25T21:20:42Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "2f3d0405-2b62-430c-9cde-29ee0b3128ec",
        "parentId" : "2ef64041-2c56-463b-b901-af48e9bc2264",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Nevermind, I see this is below",
        "createdAt" : "2018-06-25T06:51:20Z",
        "updatedAt" : "2018-06-25T21:20:42Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "609eef0ee29dda6d6fe45d4d2e274392717db9ef",
    "line" : 194,
    "diffHunk" : "@@ -1,1 +171,175 @@       \n   * Boolean indices are not supported. All indices must be integers,\n     integer arrays or slices.\n   * The integer index result dimensions are always the first axes\n     of the result array. No transpose is done, even for a single"
  },
  {
    "id" : "9e97aee4-3676-402d-b883-012785f96578",
    "prId" : 11414,
    "prUrl" : "https://github.com/numpy/numpy/pull/11414#pullrequestreview-131679618",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "03fb462a-9b4e-4dfe-8977-e2f7f70040f5",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Ok, here's where my comment about constructing special indexing objects should have gone. Just translate `arr.oindex[ind]` to `arr[np.core.oindex_object(ind)]`. As long as `oindex_object` does not attempt to duck-type `tuple`, then the subclass will just crash if it tried to actually inspect the index. For `ma.array` and `memmap`, the index is just passed through, so this would just work.",
        "createdAt" : "2018-06-25T06:56:28Z",
        "updatedAt" : "2018-06-25T21:20:42Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "3d480643-4b81-4d1b-ac68-7c35cc189c25",
        "parentId" : "03fb462a-9b4e-4dfe-8977-e2f7f70040f5",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Sounds like an ok suggestion for the implementation. Though such an object would have to explicitly not provide the sequence API or someone might still end up just using it... I doubt it is enough for MA, but it might make the MA implementation simple. Also this can provide help to the duck array, since this \"indexing object\" can provide extra information like \"a copy should be made\" or \"here I converted the boolean arrays for you\".",
        "createdAt" : "2018-06-25T13:22:47Z",
        "updatedAt" : "2018-06-25T21:20:42Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "2ff26ae3-648b-4e0f-881e-1d18ff2ca690",
        "parentId" : "03fb462a-9b4e-4dfe-8977-e2f7f70040f5",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Yep, a class like this would work:\r\n\r\n```\r\nclass oindex_object:\r\n    value: tuple\r\n```\r\n\r\nI think it would work just fine for `ma` - `ma.array.__getitem__` does nothing with `idx` other than `data[idx]` and `mask[idx]`",
        "createdAt" : "2018-06-25T16:11:42Z",
        "updatedAt" : "2018-06-25T21:20:42Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "609eef0ee29dda6d6fe45d4d2e274392717db9ef",
    "line" : 376,
    "diffHunk" : "@@ -1,1 +319,323 @@subclass has special handling for indexing and ``NotImplementedError``\nshould be raised, requiring that the indexing attributes is also explicitly\noverwritten. Likewise, implementations of ``__setitem__`` should check to see\nif ``__setitem__`` is overriden.\n"
  },
  {
    "id" : "1340e20e-e732-4f64-9753-7f7a038e5ef7",
    "prId" : 11414,
    "prUrl" : "https://github.com/numpy/numpy/pull/11414#pullrequestreview-131606700",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f53f3ced-b09e-4c0d-b8ee-2ddb3d385002",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "We already have hacks for this like `np.s_[some:slice]`.\r\n\r\nIs there a counter against `np.oindex[arr, the:actual:index]` or `arr[np.oindex[the:actual:index]]`?\r\nThe latter has the advantage of not taking up two more property names on subclasses.\r\nIf nothing else, I'd perhaps like to see these listed as rejected alternatives.",
        "createdAt" : "2018-06-25T07:00:32Z",
        "updatedAt" : "2018-06-25T21:20:42Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "cf9e53bc-4b88-480d-a66d-cab74f222752",
        "parentId" : "f53f3ced-b09e-4c0d-b8ee-2ddb3d385002",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "The second suggestion seems OK to me as such, though I think `np.oindex(arr)[...]` which ends up doing the opposite (as API, using a special indexing object) is nicer. The first suggestion, I personally do not like much, it just mangles up the index and the indexed array which IMO makes the square bracket notation much less clear (and actually saves no characters compared to `oindex(arr)[...]`!",
        "createdAt" : "2018-06-25T13:25:34Z",
        "updatedAt" : "2018-06-25T21:20:42Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "01a3a7a9-2c33-4afc-87d3-b92ae2b65d14",
        "parentId" : "f53f3ced-b09e-4c0d-b8ee-2ddb3d385002",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "However, if we implement a special index object, which would not be unreasonable, I am not sure the point below means too much, since it would not be much of a function call, it would just bind to `arr` and then call `arr.__getitem__`, it would not actually do anything with `arr` itself. `arr` could be in charge of doing some of the checks (such as that the dimension is good) inside its `__getitem__`. Or maybe easier, `arr` has to provide `ndim` or maybe even `.shape` but that would be the only thing.",
        "createdAt" : "2018-06-25T13:29:13Z",
        "updatedAt" : "2018-06-25T21:20:42Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      }
    ],
    "commit" : "609eef0ee29dda6d6fe45d4d2e274392717db9ef",
    "line" : 440,
    "diffHunk" : "@@ -1,1 +365,369 @@We don't think that new functions are a good alternative, because indexing\nnotation ``[]`` offer some syntactic advantages in Python (i.e., direct\ncreation of slice objects) compared to functions.\n\nA more reasonable alternative would be write new wrapper objects for alternative"
  }
]
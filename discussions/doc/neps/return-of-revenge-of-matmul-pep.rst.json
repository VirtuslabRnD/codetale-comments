[
  {
    "id" : "b516b70a-e400-4081-b320-2a8a59d7f5d3",
    "prId" : 4351,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c7b4a902-d42b-4d3c-aeb0-acc352bb5cfa",
        "parentId" : null,
        "authorId" : "576cec6e-8071-43f8-bce9-351a2589f050",
        "body" : "There is precedent for adding syntax to Python not used (to my knowledge) in the stdlib in the form of `x[...]` which is equivalent to `x[Ellipsis]`.\n",
        "createdAt" : "2014-02-23T16:54:39Z",
        "updatedAt" : "2014-04-06T20:55:33Z",
        "lastEditedBy" : "576cec6e-8071-43f8-bce9-351a2589f050",
        "tags" : [
        ]
      },
      {
        "id" : "6a835842-493f-4f88-87d8-a7119f941c03",
        "parentId" : "c7b4a902-d42b-4d3c-aeb0-acc352bb5cfa",
        "authorId" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "body" : "Good point, added a mention of that.\n",
        "createdAt" : "2014-02-24T04:55:43Z",
        "updatedAt" : "2014-04-06T20:55:33Z",
        "lastEditedBy" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "tags" : [
        ]
      }
    ],
    "commit" : "aadcf11a193a9523d557bc81060997d9cd3a9c8e",
    "line" : null,
    "diffHunk" : "@@ -1,1 +530,534 @@\n\nBut isn't it weird to add an operator with no stdlib uses?\n----------------------------------------------------------\n"
  },
  {
    "id" : "10a74a4b-941b-4c06-bbf6-22a5691b3d80",
    "prId" : 4351,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e9e43aa0-238b-45d6-9bb6-782c3fbee2c7",
        "parentId" : null,
        "authorId" : "acce7360-5cef-46f0-ab05-4fb0ffdffe3a",
        "body" : "Speaking of which, has anyone been in touch with the PyOpenGL about this PEP?\n",
        "createdAt" : "2014-02-23T22:02:43Z",
        "updatedAt" : "2014-04-06T20:55:33Z",
        "lastEditedBy" : "acce7360-5cef-46f0-ab05-4fb0ffdffe3a",
        "tags" : [
        ]
      },
      {
        "id" : "23c19b58-f1c6-4f1f-a8de-8f36b056c309",
        "parentId" : "e9e43aa0-238b-45d6-9bb6-782c3fbee2c7",
        "authorId" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "body" : "AFAICT PyOpenGL doesn't actually define a matrix type, it just has a few functions that can accept matrices as arguments (possibly represented as list-of-lists I guess). If you want matrix operators they refer you to numpy.\n",
        "createdAt" : "2014-02-24T03:46:21Z",
        "updatedAt" : "2014-04-06T20:55:33Z",
        "lastEditedBy" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "tags" : [
        ]
      }
    ],
    "commit" : "aadcf11a193a9523d557bc81060997d9cd3a9c8e",
    "line" : null,
    "diffHunk" : "@@ -1,1 +1229,1233 @@   In addition, the following tutorials could easily involve matrices:\n\n   * Introduction to game programming\n\n   * mrjob: Snakes on a Hadoop *(\"We'll introduce some data science"
  },
  {
    "id" : "1d33ebaa-c4a3-4377-9bca-313216251e0e",
    "prId" : 4351,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "26501f79-8f71-4f78-acd5-49577fd74ec3",
        "parentId" : null,
        "authorId" : "2e3d98a6-cf4b-4f29-965c-12617001a938",
        "body" : "Does this count uses of `np.matrix` as well?\n",
        "createdAt" : "2014-02-24T19:58:05Z",
        "updatedAt" : "2014-04-06T20:55:33Z",
        "lastEditedBy" : "2e3d98a6-cf4b-4f29-965c-12617001a938",
        "tags" : [
        ]
      },
      {
        "id" : "731c0733-e4f8-4652-aba2-f4577584e0a5",
        "parentId" : "26501f79-8f71-4f78-acd5-49577fd74ec3",
        "authorId" : "48d7d71b-9655-46b2-9a18-7c1fba7837d0",
        "body" : "nipy and scikit-learn do not appear to use `np.matrix` at all.\n(Except testing that it is cast to ndarray in some cornercase testcases.)\n",
        "createdAt" : "2014-02-24T20:06:21Z",
        "updatedAt" : "2014-04-06T20:55:33Z",
        "lastEditedBy" : "48d7d71b-9655-46b2-9a18-7c1fba7837d0",
        "tags" : [
        ]
      },
      {
        "id" : "4b77c5dd-bac7-405c-9fd9-a228426cb76a",
        "parentId" : "26501f79-8f71-4f78-acd5-49577fd74ec3",
        "authorId" : "ca95d614-21fc-41d3-bdbd-9aa4d803669f",
        "body" : "> Does this count uses of np.matrix as well?\n\nwho knows?  it could also be scipy.sparse\n",
        "createdAt" : "2014-02-24T20:08:39Z",
        "updatedAt" : "2014-04-06T20:55:33Z",
        "lastEditedBy" : "ca95d614-21fc-41d3-bdbd-9aa4d803669f",
        "tags" : [
        ]
      },
      {
        "id" : "9f8e160f-b896-4617-8014-22a9401237d2",
        "parentId" : "26501f79-8f71-4f78-acd5-49577fd74ec3",
        "authorId" : "48d7d71b-9655-46b2-9a18-7c1fba7837d0",
        "body" : "`sklearn` seems to encapsulate sparse matrix products to a `safe_sparse_dot` function, so probably only one of the `*` counted is scipy.sparse matrix product.\n",
        "createdAt" : "2014-02-24T20:16:47Z",
        "updatedAt" : "2014-04-06T20:55:33Z",
        "lastEditedBy" : "48d7d71b-9655-46b2-9a18-7c1fba7837d0",
        "tags" : [
        ]
      },
      {
        "id" : "4c96fee2-5001-416b-a734-ce0f667b2b6e",
        "parentId" : "26501f79-8f71-4f78-acd5-49577fd74ec3",
        "authorId" : "acce7360-5cef-46f0-ab05-4fb0ffdffe3a",
        "body" : "I don't think any of the sklearn uses of `*` is a matrix multiplication.\n",
        "createdAt" : "2014-04-09T19:38:37Z",
        "updatedAt" : "2014-04-09T19:38:37Z",
        "lastEditedBy" : "acce7360-5cef-46f0-ab05-4fb0ffdffe3a",
        "tags" : [
        ]
      },
      {
        "id" : "8cad28a7-cbf7-4623-b114-d24d32407975",
        "parentId" : "26501f79-8f71-4f78-acd5-49577fd74ec3",
        "authorId" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "body" : "@larsmans: This one is:\n  https://github.com/scikit-learn/scikit-learn/blob/master/sklearn/utils/extmath.py#L175\n\nNot that it matters...\n",
        "createdAt" : "2014-04-09T19:47:18Z",
        "updatedAt" : "2014-04-09T19:47:18Z",
        "lastEditedBy" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "tags" : [
        ]
      },
      {
        "id" : "48de0166-bab6-4aef-a9b6-d3af7db09175",
        "parentId" : "26501f79-8f71-4f78-acd5-49577fd74ec3",
        "authorId" : "54dad831-921a-4f39-bbd3-e45ff714a9b9",
        "body" : "```\nOn 09-Apr-2014 3:38 PM, Lars Buitinck wrote:\n  In doc/neps/return-of-revenge-of-matmul-pep.rst:\n  > +much larger than both projects put together (stdlib: 411575 SLOC,\n```\n\n> +scikit-learn: 50924 SLOC, nipy: 37078 SLOC). [#sloc-details]\n> +\n> +The **dot** row (marked `******`) counts how common matrix multiply\n> +operations are in each codebase.\n> +\n> +::\n> +\n> -    ====  ======  ============  ====  ========\n> -      op  stdlib  scikit-learn  nipy  combined\n> -    ====  ======  ============  ====  ========\n> -       =    2969          5536  4932      3376 / 10,000 SLOC\n> -       -     218           444   496       261\n> -       +     224           201   348       231\n> -      ==     177           248   334       196\n> -       \\*     156           284   465       192\n\n```\n  I don't think any of the sklearn uses of * is a\n    matrix multiplication.\n  —\n    Reply to this email directly or view\n      it on GitHub.\n\nPerhaps this is because much of the SciPy was developed before the\nthe Numarray (Space Telescope) people took over the maintenance.\nIt seems to me that  there is merit in recognizing the Matrix, and\nperhaps the Vector, as separate data types (Classes).\nColin W.\nColin W.\n```\n",
        "createdAt" : "2014-04-10T12:54:21Z",
        "updatedAt" : "2014-04-10T12:54:21Z",
        "lastEditedBy" : "54dad831-921a-4f39-bbd3-e45ff714a9b9",
        "tags" : [
        ]
      },
      {
        "id" : "38b77077-8a36-4577-b400-cf0671445afd",
        "parentId" : "26501f79-8f71-4f78-acd5-49577fd74ec3",
        "authorId" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "body" : "Hi Colin,\n\nI honestly have no idea what you're trying to insinuate about the\nconnection between the Space Telescope, SciPy, and scikit-learn (??), but I\ndon't think it's helping anything. Nor is simply posting over and over in\ndifferent forums that you like Matrix and Vector classes. We know that now\n:-). But just saying that is not going to convince anyone to like them with\nyou.\n\nRealistically, my best guess is that nothing you say is likely to convince\nanyone of anything, given that np.matrix has come to its present state of\npoor reputation through years of experience, and it isn't clear you even\nunderstand why most numpy developers and users are convinced that the\napproach is fundamentally flawed and unfixable. But if you really want to\ntry, then the place to do that is the numpy-discussion list, and the way to\ndo that is to understand and engage with specific the problems people have\nraised.\n\nHope that helps,\n-n\n\nOn Thu, Apr 10, 2014 at 1:54 PM, Colin J. Williams <notifications@github.com\n\n> wrote:\n> \n> In doc/neps/return-of-revenge-of-matmul-pep.rst:\n> \n> > +much larger than both projects put together (stdlib: 411575 SLOC,\n> > +scikit-learn: 50924 SLOC, nipy: 37078 SLOC). [#sloc-details]\n> > +\n> > +The **dot** row (marked `******`) counts how common matrix multiply\n> > +operations are in each codebase.\n> > +\n> > +::\n> > +\n> > -    ====  ======  ============  ====  ========\n> > -      op  stdlib  scikit-learn  nipy  combined\n> > -    ====  ======  ============  ====  ========\n> > -       =    2969          5536  4932      3376 / 10,000 SLOC\n> > -       -     218           444   496       261\n> > -       +     224           201   348       231\n> > -      ==     177           248   334       196\n> > -       \\*     156           284   465       192\n> \n> On 09-Apr-2014 3:38 PM, Lars Buitinck wrote: In\n> doc/neps/return-of-revenge-of-matmul-pep.rst: +much larger than both\n> projects put together (stdlib: 411575 SLOC,\n>  +scikit-learn: 50924 SLOC, nipy: 37078 SLOC). [#sloc-details] + +The\n> **dot** row (marked `******`) counts how common matrix multiply\n> +operations are in each codebase. + +:: + + ==== ====== ============ ====\n> ======== + op stdlib scikit-learn nipy combined + ==== ====== ============\n> ==== ======== + = 2969 5536 4932 3376 / 10,000 SLOC + - 218 444 496 261 + +\n> 224 201 348 231 + == 177 248 334 196 + \\* 156 284 465 192\n> I don't think any of the sklearn uses of \\* is a matrix multiplication. —\n> Reply to this email directly or view it on GitHub. Perhaps this is because\n> much of the SciPy was developed before the the Numarray (Space Telescope)\n> people took over the maintenance. It seems to me that  there is merit in\n> recognizing the Matrix, and perhaps the Vector, as separate data types\n> (Classes). Colin W. Colin W.\n> \n> —\n> Reply to this email directly or view it on GitHubhttps://github.com/numpy/numpy/pull/4351/files#r11482704\n> .\n\n## \n\nNathaniel J. Smith\nPostdoctoral researcher - Informatics - University of Edinburgh\nhttp://vorpus.org\n",
        "createdAt" : "2014-04-10T19:58:04Z",
        "updatedAt" : "2014-04-10T19:58:04Z",
        "lastEditedBy" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "tags" : [
        ]
      },
      {
        "id" : "eb91e441-caab-484a-99c2-256dee310618",
        "parentId" : "26501f79-8f71-4f78-acd5-49577fd74ec3",
        "authorId" : "b18343d1-fdd1-4dad-9df2-04040fbf4c83",
        "body" : "On Thu, Apr 10, 2014 at 12:58 PM, njsmith notifications@github.com wrote:\n\n> Hi Colin, I honestly have no idea what you're trying to insinuate about\n> the connection between the Space Telescope, SciPy, and scikit-learn (??),\n> but I don't think it's helping anything. Nor is simply posting over and\n> over in different forums that you like Matrix and Vector classes. We know\n> that now :-). But just saying that is not going to convince anyone to like\n> them with you. Realistically, my best guess is that nothing you say is\n> likely to convince anyone of anything, given that np.matrix has come to its\n> present state of poor reputation through years of experience, and it isn't\n> clear you even understand why most numpy developers and users are convinced\n> that the approach is fundamentally flawed and unfixable. But if you really\n> want to try, then the place to do that is the numpy-discussion list, and\n> the way to do that is to understand and engage with specific the problems\n> people have raised.\n> \n> This keeps coming up (and not by just one or two isolated people) because\n> the PEP doesn't convincingly show that a better Matrix class than np.matrix\n> isn't a viable alternative.\n",
        "createdAt" : "2014-04-10T21:05:52Z",
        "updatedAt" : "2014-04-10T21:05:52Z",
        "lastEditedBy" : "b18343d1-fdd1-4dad-9df2-04040fbf4c83",
        "tags" : [
        ]
      },
      {
        "id" : "b08ab4c9-3143-4073-ac86-a905617be520",
        "parentId" : "26501f79-8f71-4f78-acd5-49577fd74ec3",
        "authorId" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "body" : "I know it can be frustrating to feel like you're being ignored, and I'm\ntrying to be constructive, but if you're going to reply to my post saying\n\"please engage with the specific points instead of just repeating\nassertions over and over\" by repeating vague assertions and ignoring\nspecific points then I've kind of run out of responses.\n\nA PEP which has, in fact, convinced the BDFL and (apparently) the rest of\nthe Python core team is, by definition, convincing. Maybe we were all\n_wrong_ to be convinced, it's always possible. But asserting that it isn't\nconvincing and saying nothing else just makes it sound like you think we're\nall idiots.\n\n(To be clear, there's nothing wrong with thinking we're all idiots. That\ncould be true to. But as a practical matter it's not going to produce any\nof the changes in behaviour that you're hoping for.)\n\nOn Thu, Apr 10, 2014 at 10:05 PM, Robert Bradshaw\nnotifications@github.comwrote:\n\n> In doc/neps/return-of-revenge-of-matmul-pep.rst:\n> \n> > +much larger than both projects put together (stdlib: 411575 SLOC,\n> > +scikit-learn: 50924 SLOC, nipy: 37078 SLOC). [#sloc-details]\n> > +\n> > +The **dot** row (marked `******`) counts how common matrix multiply\n> > +operations are in each codebase.\n> > +\n> > +::\n> > +\n> > -    ====  ======  ============  ====  ========\n> > -      op  stdlib  scikit-learn  nipy  combined\n> > -    ====  ======  ============  ====  ========\n> > -       =    2969          5536  4932      3376 / 10,000 SLOC\n> > -       -     218           444   496       261\n> > -       +     224           201   348       231\n> > -      ==     177           248   334       196\n> > -       \\*     156           284   465       192\n> \n> On Thu, Apr 10, 2014 at 12:58 PM, njsmith notifications@github.com\n> wrote: Hi Colin, I honestly have no idea what you're trying to insinuate\n> about the connection between the Space Telescope, SciPy, and scikit-learn\n> (??), but I don't think it's helping anything. Nor is simply posting over\n> and over in different forums that you like Matrix and Vector classes. We\n> know that now :-). But just saying that is not going to convince anyone to\n> like them with you. Realistically, my best guess is that nothing you say is\n> likely to convince anyone of anything, given that np.matrix has come to its\n> present state of poor reputation through years of experience, and it isn't\n> clear you even understand why most numpy developers and users are convinced\n> that the approach is fundamentally flawed and unfixable. But if you really\n> want to try, then the place to do that is the numpy-discussion list, and\n> the way to do that is to understand and engage with specific the problems\n> people have raised.\n> This keeps coming up (and not by just one or two isolated people) because\n> the PEP doesn't convincingly show that a better Matrix class than np.matrix\n> isn't a viable alternative.\n> \n> —\n> Reply to this email directly or view it on GitHubhttps://github.com/numpy/numpy/pull/4351/files#r11506487\n> .\n\n## \n\nNathaniel J. Smith\nPostdoctoral researcher - Informatics - University of Edinburgh\nhttp://vorpus.org\n",
        "createdAt" : "2014-04-10T21:15:15Z",
        "updatedAt" : "2014-04-10T21:15:15Z",
        "lastEditedBy" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "tags" : [
        ]
      },
      {
        "id" : "5fdd4877-f891-4e8b-ba29-731757ca35e0",
        "parentId" : "26501f79-8f71-4f78-acd5-49577fd74ec3",
        "authorId" : "768f57c5-d516-44ee-8ac7-261e61a0680b",
        "body" : "Le 10/04/14 22:15, njsmith a écrit :\n\n> I know it can be frustrating to feel like you're being ignored, and I'm\n> trying to be constructive, but if you're going to reply to my post\n> saying \"please engage with the specific points instead of just repeating\n> assertions over and over\" by repeating vague assertions and ignoring\n> specific points then I've kind of run out of responses. A PEP which has,\n> in fact, convinced the BDFL and (apparently) the rest of the Python core\n> team is, by definition, convincing. Maybe we were all _wrong_ to be\n> convinced, it's always possible. But asserting that it isn't convincing\n> and saying nothing else just makes it sound like you think we're all\n> idiots. (To be clear, there's nothing wrong with thinking we're all\n> idiots. That could be true to. But as a practical matter it's not going\n> to produce any of the changes in behaviour that you're hoping for.)\n\nThat is, to put it mildly, a fallacy. It's quite obvious that Guido \ntrusted the PEP authors to produce a fair assessment of domain-specific \ntechnical issues and did not scrutinise each claim.\n",
        "createdAt" : "2014-04-10T22:10:32Z",
        "updatedAt" : "2014-04-10T22:10:32Z",
        "lastEditedBy" : "768f57c5-d516-44ee-8ac7-261e61a0680b",
        "tags" : [
        ]
      },
      {
        "id" : "cf75a8d1-5586-4a1d-aa80-25da2dd4a9e5",
        "parentId" : "26501f79-8f71-4f78-acd5-49577fd74ec3",
        "authorId" : "810880d7-9b25-4940-a0cb-9281ddc2d16a",
        "body" : "@robertwb Adding another class would mean that all packages that depend on NumPy would have to build in support for Matrices.  Or, we could just subclass from an ndarray, but that gives us the mess we're already in.\n",
        "createdAt" : "2014-04-10T22:41:47Z",
        "updatedAt" : "2014-04-10T22:41:47Z",
        "lastEditedBy" : "810880d7-9b25-4940-a0cb-9281ddc2d16a",
        "tags" : [
        ]
      },
      {
        "id" : "13cd3b35-a7a1-4505-b723-d03ec69cc545",
        "parentId" : "26501f79-8f71-4f78-acd5-49577fd74ec3",
        "authorId" : "54dad831-921a-4f39-bbd3-e45ff714a9b9",
        "body" : "```\nOn 10-Apr-2014 3:58 PM, njsmith wrote:\n\n  In doc/neps/return-of-revenge-of-matmul-pep.rst:\n  > +much larger than both projects put together (stdlib: 411575 SLOC,\n```\n\n> +scikit-learn: 50924 SLOC, nipy: 37078 SLOC). [#sloc-details]\n> +\n> +The **dot** row (marked `******`) counts how common matrix multiply\n> +operations are in each codebase.\n> +\n> +::\n> +\n> -    ====  ======  ============  ====  ========\n> -      op  stdlib  scikit-learn  nipy  combined\n> -    ====  ======  ============  ====  ========\n> -       =    2969          5536  4932      3376 / 10,000 SLOC\n> -       -     218           444   496       261\n> -       +     224           201   348       231\n> -      ==     177           248   334       196\n> -       \\*     156           284   465       192\n\n```\n  Hi Colin,\n    I honestly have no idea what you're trying to insinuate about\n    the\n    connection between the Space Telescope, SciPy, and scikit-learn\n    (??), but I\n    don't think it's helping anything. Nor is simply posting over\n    and over in\n    different forums that you like Matrix and Vector classes. We\n    know that now\n    :-). But just saying that is not going to convince anyone to\n    like them with\n    you.\n    Realistically, my best guess is that nothing you say is likely\n    to convince\n    anyone of anything, given that np.matrix has come to its present\n    state of\n    poor reputation through years of experience, and it isn't clear\n    you even\n    understand why most numpy developers and users are convinced\n    that the\n    approach is fundamentally flawed and unfixable. But if you\n    really want to\n    try, then the place to do that is the numpy-discussion list, and\n    the way to\n    do that is to understand and engage with specific the problems\n    people have\n    raised.\n    Hope that helps,\n    -n\n\nNathaniel,\nI'm not trying to insinuate anything.  You don't quote the words\nthat you are troubled by.\nWhat I intended to convey was that the scikit material was likely\ndeveloped prior to the Numarray period in the evolution of Numpy.  I\nbelieve that the Matrix class was introduce during the Numarray\ntime.  In about 2007, I think, Travis Olliphant took over\ndevelopment, under the original name - Numpy and continued the\nMatrix class.\nI was pleased to see that the Matrix class was introduced and\ncontinued, as it provides for provides for a different type of data.\nUnfortunately, you provide no examples of how the class failed to\nmeet your needs.  I hope to be be able to put together a critical\nanalysis of PEP 465.\nBest wishes,\nColin W.\nColin W.\n\n    On Thu, Apr 10, 2014 at 1:54 PM,\n      Colin J. Williams <notifications@github.com > wrote: In\n      doc/neps/return-of-revenge-of-matmul-pep.rst: > +much\n      larger than both projects put together (stdlib: 411575 SLOC,\n      > +scikit-learn: 50924 SLOC, nipy: 37078 SLOC).\n      [#sloc-details] > + > +The **dot** row (marked\n      ``******``) counts how common matrix multiply > +operations\n      are in each codebase. > + > +:: > + > + ====\n      ====== ============ ==== ======== > + op stdlib\n      scikit-learn nipy combined > + ==== ====== ============\n      ==== ======== > + = 2969 5536 4932 3376 / 10,000 SLOC >\n      + - 218 444 496 261 > + + 224 201 348 231 > + == 177 248\n      334 196 > + * 156 284 465 192 On 09-Apr-2014 3:38 PM, Lars\n      Buitinck wrote: In\n      doc/neps/return-of-revenge-of-matmul-pep.rst: +much larger\n      than both projects put together (stdlib: 411575 SLOC,\n      +scikit-learn: 50924 SLOC, nipy: 37078 SLOC). [#sloc-details]\n      + +The **dot** row (marked ``******``) counts how common\n      matrix multiply +operations are in each codebase. + +:: + +\n      ==== ====== ============ ==== ======== + op stdlib\n      scikit-learn nipy combined + ==== ====== ============ ====\n      ======== + = 2969 5536 4932 3376 / 10,000 SLOC + - 218 444 496\n      261 + + 224 201 348 231 + == 177 248 334 196 + * 156 284 465\n      192 I don't think any of the sklearn uses of * is a matrix\n      multiplication. — Reply to this email directly or view it on\n      GitHub. Perhaps this is because much of the SciPy was\n      developed before the the Numarray (Space Telescope) people\n      took over the maintenance. It seems to me that there is merit\n      in recognizing the Matrix, and perhaps the Vector, as separate\n      data types (Classes). Colin W. Colin W. — Reply to this email\n      directly or view it on GitHub<https://github.com/numpy/numpy/pull/4351/files#r11482704>\n\n      .\n\n    -- Nathaniel J. Smith\n      Postdoctoral researcher - Informatics - University of\n      Edinburgh\n      http://vorpus.org\n\n\n  —\n    Reply to this email directly or view\n      it on GitHub.\n```\n",
        "createdAt" : "2014-04-11T03:09:01Z",
        "updatedAt" : "2014-04-11T03:09:01Z",
        "lastEditedBy" : "54dad831-921a-4f39-bbd3-e45ff714a9b9",
        "tags" : [
        ]
      },
      {
        "id" : "004dd0f6-35f9-4379-9e7f-c71727fede23",
        "parentId" : "26501f79-8f71-4f78-acd5-49577fd74ec3",
        "authorId" : "85b881e8-d8a0-43d4-81d3-7e233dc5f1ae",
        "body" : "The `Matrix` class was in Numeric and predates numpy, numarray, scikit-learn, and nipy. This is why your message was so confusing.\n",
        "createdAt" : "2014-04-11T09:14:38Z",
        "updatedAt" : "2014-04-11T09:14:38Z",
        "lastEditedBy" : "85b881e8-d8a0-43d4-81d3-7e233dc5f1ae",
        "tags" : [
        ]
      },
      {
        "id" : "563e666c-2007-4c0e-a0b1-0c289447f4d2",
        "parentId" : "26501f79-8f71-4f78-acd5-49577fd74ec3",
        "authorId" : "85b881e8-d8a0-43d4-81d3-7e233dc5f1ae",
        "body" : "@robertwb The PEP does explain the problem with a 2-type-1-operator system, _any_ 2-type-1-operator system. It is not limited to the particular implementation choices of `numpy.matrix`.\n",
        "createdAt" : "2014-04-11T09:17:57Z",
        "updatedAt" : "2014-04-11T09:17:57Z",
        "lastEditedBy" : "85b881e8-d8a0-43d4-81d3-7e233dc5f1ae",
        "tags" : [
        ]
      },
      {
        "id" : "7ee8f69d-1cc2-4d17-a8de-1cc4709b3525",
        "parentId" : "26501f79-8f71-4f78-acd5-49577fd74ec3",
        "authorId" : "54dad831-921a-4f39-bbd3-e45ff714a9b9",
        "body" : "```\nOn 10-Apr-2014 5:15 PM, njsmith wrote:\n\n  In doc/neps/return-of-revenge-of-matmul-pep.rst:\n  > +much larger than both projects put together (stdlib: 411575 SLOC,\n```\n\n> +scikit-learn: 50924 SLOC, nipy: 37078 SLOC). [#sloc-details]\n> +\n> +The **dot** row (marked `******`) counts how common matrix multiply\n> +operations are in each codebase.\n> +\n> +::\n> +\n> -    ====  ======  ============  ====  ========\n> -      op  stdlib  scikit-learn  nipy  combined\n> -    ====  ======  ============  ====  ========\n> -       =    2969          5536  4932      3376 / 10,000 SLOC\n> -       -     218           444   496       261\n> -       +     224           201   348       231\n> -      ==     177           248   334       196\n> -       \\*     156           284   465       192\n\n```\n  I know it can be frustrating to feel\n    like you're being ignored, and I'm\n    trying to be constructive, but if you're going to reply to my\n    post saying\n    \"please engage with the specific points instead of just\n    repeating\n    assertions over and over\" by repeating vague assertions and\n    ignoring\n    specific points then I've kind of run out of responses.\n    A PEP which has, in fact, convinced the BDFL and (apparently)\n    the rest of\n    the Python core team is, by definition, convincing. Maybe we\n    were all\n    *wrong* to be convinced, it's always possible. But asserting\n    that it isn't\n    convincing and saying nothing else just makes it sound like you\n    think we're\n    all idiots.\n    (To be clear, there's nothing wrong with thinking we're all\n    idiots. That\n    could be true to. But as a practical matter it's not going to\n    produce any\n    of the changes in behaviour that you're hoping for.)\n  …\n\n    On Thu, Apr 10, 2014 at 10:05\n      PM, Robert Bradshaw <notifications@github.com>wrote: In\n      doc/neps/return-of-revenge-of-matmul-pep.rst: > +much\n      larger than both projects put together (stdlib: 411575 SLOC,\n      > +scikit-learn: 50924 SLOC, nipy: 37078 SLOC).\n      [#sloc-details] > + > +The **dot** row (marked\n      ``******``) counts how common matrix multiply > +operations\n      are in each codebase. > + > +:: > + > + ====\n      ====== ============ ==== ======== > + op stdlib\n      scikit-learn nipy combined > + ==== ====== ============\n      ==== ======== > + = 2969 5536 4932 3376 / 10,000 SLOC >\n      + - 218 444 496 261 > + + 224 201 348 231 > + == 177 248\n      334 196 > + * 156 284 465 192 On Thu, Apr 10, 2014 at 12:58\n      PM, njsmith <notifications@github.com> wrote: Hi Colin,\n      I honestly have no idea what you're trying to insinuate about\n      the connection between the Space Telescope, SciPy, and\n      scikit-learn (??), but I don't think it's helping anything.\n      Nor is simply posting over and over in different forums that\n      you like Matrix and Vector classes. We know that now :-). But\n      just saying that is not going to convince anyone to like them\n      with you. Realistically, my best guess is that nothing you say\n      is likely to convince anyone of anything, given that np.matrix\n      has come to its present state of poor reputation through years\n      of experience, and it isn't clear you even understand why most\n      numpy developers and users are convinced that the approach is\n      fundamentally flawed and unfixable. But if you really want to\n      try, then the place to do that is the numpy-discussion list,\n      and the way to do that is to understand and engage with\n      specific the problems people have raised. This keeps coming up\n      (and not by just one or two isolated people) because the PEP\n      doesn't convincingly show that a better Matrix class than\n      np.matrix isn't a viable alternative. — Reply to this email\n      directly or view it on GitHub<https://github.com/numpy/numpy/pull/4351/files#r11506487>\n\n      .\n\n    -- Nathaniel J. Smith\n      Postdoctoral researcher - Informatics - University of\n      Edinburgh\n      http://vorpus.org\n\n\n  —\n    Reply to this email directly or view\n      it on GitHub.\n\nNathaniel,\nI have explained to you that I am preparing a critique of the PEP\n465, which, in my view is flawed.\nIt provides no balanced view of the status quo.  You\nprovide an illustration of some calculations using @, but have not\nshown how objects of the Matrix Class fail to handle the similar\ncalculations.\nI suggest that balance is important as you need to convince those\noutside the Numpy community that the addition of two new operators\nis justified for all the Python users, most of whom are not users of\nlinear algebra.  It adds to the Python learning curve with no\nbenefit to most and very limited benefit to the users of linear\nalgebra.\nBest wishes,\nColin W.\n```\n",
        "createdAt" : "2014-04-11T12:05:55Z",
        "updatedAt" : "2014-04-11T12:05:55Z",
        "lastEditedBy" : "54dad831-921a-4f39-bbd3-e45ff714a9b9",
        "tags" : [
        ]
      },
      {
        "id" : "df67391f-484b-464e-99d1-ea6d5989fdba",
        "parentId" : "26501f79-8f71-4f78-acd5-49577fd74ec3",
        "authorId" : "85b881e8-d8a0-43d4-81d3-7e233dc5f1ae",
        "body" : "@cjw43 Can you please use the Github web interface for commenting? If you must use email, please make sure there are no signatures in your response or quoted content except for the smallest part that you are responding to. Your comments are unreadable, both in email and on Github.\n",
        "createdAt" : "2014-04-11T12:09:59Z",
        "updatedAt" : "2014-04-11T12:09:59Z",
        "lastEditedBy" : "85b881e8-d8a0-43d4-81d3-7e233dc5f1ae",
        "tags" : [
        ]
      },
      {
        "id" : "7fdfe5b1-af66-4db6-bc70-575268f94fad",
        "parentId" : "26501f79-8f71-4f78-acd5-49577fd74ec3",
        "authorId" : "54dad831-921a-4f39-bbd3-e45ff714a9b9",
        "body" : "```\nRobert,\nThanks for this clarification.  You have been very much closer to\nthese things than I have over the years.\nMy conjecture, as to the reason that SciKits was said not to mention\nMatrix, was clearly wrong.\nColin W.On 11-Apr-2014 5:14 AM, Robert Kern\n  wrote:\n\n  In doc/neps/return-of-revenge-of-matmul-pep.rst:\n  > +much larger than both projects put together (stdlib: 411575 SLOC,\n```\n\n> +scikit-learn: 50924 SLOC, nipy: 37078 SLOC). [#sloc-details]\n> +\n> +The **dot** row (marked `******`) counts how common matrix multiply\n> +operations are in each codebase.\n> +\n> +::\n> +\n> -    ====  ======  ============  ====  ========\n> -      op  stdlib  scikit-learn  nipy  combined\n> -    ====  ======  ============  ====  ========\n> -       =    2969          5536  4932      3376 / 10,000 SLOC\n> -       -     218           444   496       261\n> -       +     224           201   348       231\n> -      ==     177           248   334       196\n> -       \\*     156           284   465       192\n\n```\n  The Matrix class was in Numeric and predates\n    numpy, numarray, scikit-learn, and nipy. This is why your\n    message was so confusing.\n  —\n    Reply to this email directly or view\n      it on GitHub.\n```\n",
        "createdAt" : "2014-04-11T14:06:14Z",
        "updatedAt" : "2014-04-11T14:06:14Z",
        "lastEditedBy" : "54dad831-921a-4f39-bbd3-e45ff714a9b9",
        "tags" : [
        ]
      },
      {
        "id" : "1cf4567f-0ffb-4eed-a3cb-4a69e3563cb8",
        "parentId" : "26501f79-8f71-4f78-acd5-49577fd74ec3",
        "authorId" : "ca95d614-21fc-41d3-bdbd-9aa4d803669f",
        "body" : "I'm kind of reluctant to join this thread, but regarding scikit-learn and np.matrix I thought I'd just add some relevant links.  Here's the scikit-learn history page http://scikit-learn.org/stable/about.html, here's a 2011 scikit-learn thread about what to do about np.matrix http://osdir.com/ml/python-scikit-learn/2011-10/msg00212.html and here's a related sklearn github issue https://github.com/scikit-learn/scikit-learn/issues/392.  I haven't read these links in detail and I'm not trying to use them to make any argument regarding the PEP.\n",
        "createdAt" : "2014-04-11T15:45:37Z",
        "updatedAt" : "2014-04-11T15:45:37Z",
        "lastEditedBy" : "ca95d614-21fc-41d3-bdbd-9aa4d803669f",
        "tags" : [
        ]
      },
      {
        "id" : "bfc113f9-2c8f-4151-9930-7ae3f2672a5f",
        "parentId" : "26501f79-8f71-4f78-acd5-49577fd74ec3",
        "authorId" : "54dad831-921a-4f39-bbd3-e45ff714a9b9",
        "body" : "```\nOn 11-Apr-2014 11:45 AM, argriffing\n  wrote:\n\n  In doc/neps/return-of-revenge-of-matmul-pep.rst:\n\n\n  I'm kind of reluctant to join this thread, but regarding\n    scikit-learn and np.matrix I thought I'd just add some relevant\n    links. Here's the scikit-learn history page http://scikit-learn.org/stable/about.html,\n    here's a 2011 scikit-learn thread about what to do about\n    np.matrix http://osdir.com/ml/python-scikit-learn/2011-10/msg00212.html\n    and here's a related sklearn github issue scikit-learn/scikit-learn#392. I haven't\n    read these links in detail and I'm not trying to use them to\n    make any argument regarding the PEP.\n  —\n    Reply to this email directly or view\n      it on GitHub.\n\n\nThanks, this is helpful:The issue is: many modules currently fail when handed an\n  np.matrix. We\n  can resolve this by either:\n  CONVERTING to np.ndarray\n  * matrices are obviously array-like\n  * matrices may come about inadvertently, because some NumPy/SciPy\n  routines/methods happen to return them\n  * we loosely use the term \"matrix\" throughout the docs, so it\n  would be\n  strange to require a matrix not to be an np.matrix\n  * we are (or should be) doing input validation anyway, with\n  utils.{safe_asanyarray, as_float_array, atleast2d_or_csr}\n  * we already need to handle the matrix API in all modules that\n  accept\n  sparse input\n  * backwards compatibility\n  or\n  REJECTING np.matrix by throwing a TypeError\n  * mathematical operators may have different meanings than on array\n  (*\n  means dot product on matrix, Hadamard product on arrays)\n  * matrices are always 2-d, so ravel, flatten and reshape don't\n  behave\n  as expected\n  * converting to array is easy enough for the user: just call .A on\n  every matrix\n  * explicit is better than implicit\n  * we'd need to test every routine against matrices (but then, we\n  should be testing input validation anyway)   \nThree votes were in favour of Rejecting and six were in favour of \nConverting.\nNo consideration was given to addressing various problems raised in\nthe discussion, including improved testing routines.\nOne of the examples above: matrices may come about inadvertently, because some\n  NumPy/SciPy\n  routines/methods happen to return them\nThe documentation should make it clear what type(s) each function is\nexpected to return.  It is then up to the calling process to deal\nwith the returned object appropriately.\nColin W.\n```\n",
        "createdAt" : "2014-04-11T21:16:02Z",
        "updatedAt" : "2014-04-11T21:16:02Z",
        "lastEditedBy" : "54dad831-921a-4f39-bbd3-e45ff714a9b9",
        "tags" : [
        ]
      },
      {
        "id" : "962d80c4-2eec-4b36-9468-02f44dbfa850",
        "parentId" : "26501f79-8f71-4f78-acd5-49577fd74ec3",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "On Fri, Apr 11, 2014 at 3:16 PM, Colin J. Williams <notifications@github.com\n\n> wrote:\n> \n> In doc/neps/return-of-revenge-of-matmul-pep.rst:\n> \n> > +much larger than both projects put together (stdlib: 411575 SLOC,\n> > +scikit-learn: 50924 SLOC, nipy: 37078 SLOC). [#sloc-details]\n> > +\n> > +The **dot** row (marked `******`) counts how common matrix multiply\n> > +operations are in each codebase.\n> > +\n> > +::\n> > +\n> > -    ====  ======  ============  ====  ========\n> > -      op  stdlib  scikit-learn  nipy  combined\n> > -    ====  ======  ============  ====  ========\n> > -       =    2969          5536  4932      3376 / 10,000 SLOC\n> > -       -     218           444   496       261\n> > -       +     224           201   348       231\n> > -      ==     177           248   334       196\n> > -       \\*     156           284   465       192\n> \n> On 11-Apr-2014 11:45 AM, argriffing wrote: In\n> doc/neps/return-of-revenge-of-matmul-pep.rst: I'm kind of reluctant to join\n> this thread, but regarding scikit-learn and np.matrix I thought I'd just\n> add some relevant links. Here's the scikit-learn history page\n> http://scikit-learn.org/stable/about.html, here's a 2011 scikit-learn\n> thread about what to do about np.matrix\n> http://osdir.com/ml/python-scikit-learn/2011-10/msg00212.html and here's\n> a related sklearn github issue scikit-learn/scikit-learn#392https://github.com/scikit-learn/scikit-learn/issues/392.\n> I haven't read these links in detail and I'm not trying to use them to make\n> any argument regarding the PEP. -- Reply to this email directly or view it\n> on GitHub. Thanks, this is helpful:The issue is: many modules currently\n> fail when handed an np.matrix. We can resolve this by either: CONVERTING to\n> np.ndarray \\* matrices are obviously array-like \\* matrices may come about\n> inadvertently, because some NumPy/SciPy routines/methods happen to return\n> them \\* we loosely use the term \"matrix\" throughout the docs, so it would be\n> strange to require a matrix not to be an np.matrix \\* we are (or should be)\n> doing input validation anyway, with utils.{safe_asanyarray, as_float_array,\n> atleast2d_or_csr} \\* we already need to handle the matrix API in all modules\n> that accept sparse input \\* backwards compatibility or REJECTING np.matrix\n> by throwing a TypeError \\* mathematical operators may have different\n> meanings than on array (\\* means dot product on matrix, Hadamard product on\n> arrays) \\* matrices are always 2-d, so ravel, flatten and reshape don't\n> behave as expected \\* converting to array is easy enough for the user: just\n> call .A on every matrix \\* explicit is better than implicit \\* we'd need to\n> test every routine against matrices (but then, we should be testing input\n> validation anyway)   Three votes were in favour of Rejecting and six were\n> in favour of  Converting. No consideration was given to addressing various\n> problems raised in the discussion, including improved testing routines. One\n> of the examples above: matrices may come about inadvertently, because some\n> NumPy/SciPy routines/methods happen to return them The documentation should\n> make it clear what type(s) each function is expected to return.  It is then\n> up to the calling process to deal with the returned object appropriately.\n> Colin W.\n\nBut Colin, we are trying to make writing code easier, not more difficult ;)\n\nChuck\n",
        "createdAt" : "2014-04-11T21:36:37Z",
        "updatedAt" : "2014-04-11T21:36:37Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "aadcf11a193a9523d557bc81060997d9cd3a9c8e",
    "line" : 481,
    "diffHunk" : "@@ -1,1 +479,483 @@       +     224           201   348       231\n      ==     177           248   334       196\n       *     156           284   465       192\n       %     121           114   107       119\n      **      59           111   118        68"
  },
  {
    "id" : "de2b95f8-e13b-4c2b-a1eb-01959a9138f3",
    "prId" : 4351,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f2b6f7d8-a678-45a2-b444-631e70ac37e6",
        "parentId" : null,
        "authorId" : "855421c2-a5b9-4dc5-a633-aca7f743559e",
        "body" : "Maybe use `*` here... \n",
        "createdAt" : "2014-03-09T16:59:38Z",
        "updatedAt" : "2014-04-06T20:55:33Z",
        "lastEditedBy" : "855421c2-a5b9-4dc5-a633-aca7f743559e",
        "tags" : [
        ]
      }
    ],
    "commit" : "aadcf11a193a9523d557bc81060997d9cd3a9c8e",
    "line" : null,
    "diffHunk" : "@@ -1,1 +111,115 @@\n  [[1, 2],     [[11, 12],     [[1 * 11, 2 * 12],\n   [3, 4]]  x   [13, 14]]  =   [3 * 13, 4 * 14]]\n\nand the other is `matrix multiplication`_:"
  },
  {
    "id" : "6a518659-aeeb-4dcb-b94b-c9e66325784d",
    "prId" : 4351,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "80ee70b6-9290-45e3-af3b-994e4c496b83",
        "parentId" : null,
        "authorId" : "855421c2-a5b9-4dc5-a633-aca7f743559e",
        "body" : "... and `@` here (rather than `x`).\n",
        "createdAt" : "2014-03-09T17:00:00Z",
        "updatedAt" : "2014-04-06T20:55:33Z",
        "lastEditedBy" : "855421c2-a5b9-4dc5-a633-aca7f743559e",
        "tags" : [
        ]
      },
      {
        "id" : "e0a1cef8-912e-48ca-a5a5-6708551597a0",
        "parentId" : "80ee70b6-9290-45e3-af3b-994e4c496b83",
        "authorId" : "b18343d1-fdd1-4dad-9df2-04040fbf4c83",
        "body" : "This is the proposal, but it's very non-standard (the referenced wikipedia article has no such notation).\n",
        "createdAt" : "2014-03-16T06:51:07Z",
        "updatedAt" : "2014-04-06T20:55:33Z",
        "lastEditedBy" : "b18343d1-fdd1-4dad-9df2-04040fbf4c83",
        "tags" : [
        ]
      },
      {
        "id" : "c388ac6b-e361-44d5-b119-976bb5031029",
        "parentId" : "80ee70b6-9290-45e3-af3b-994e4c496b83",
        "authorId" : "b18343d1-fdd1-4dad-9df2-04040fbf4c83",
        "body" : "Could be worth typesetting though.\n",
        "createdAt" : "2014-03-16T06:52:15Z",
        "updatedAt" : "2014-04-06T20:55:33Z",
        "lastEditedBy" : "b18343d1-fdd1-4dad-9df2-04040fbf4c83",
        "tags" : [
        ]
      }
    ],
    "commit" : "aadcf11a193a9523d557bc81060997d9cd3a9c8e",
    "line" : 122,
    "diffHunk" : "@@ -1,1 +120,124 @@\n  [[1, 2],     [[11, 12],     [[1 * 11 + 2 * 13, 1 * 12 + 2 * 14],\n   [3, 4]]  x   [13, 14]]  =   [3 * 11 + 4 * 13, 3 * 12 + 4 * 14]]\n\nElementwise multiplication is useful because it lets us easily and"
  },
  {
    "id" : "b2aa569b-25ae-4c10-a813-060c04ec9c6c",
    "prId" : 4351,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ba8181ef-2811-4817-8ab6-9a9f6e866798",
        "parentId" : null,
        "authorId" : "b18343d1-fdd1-4dad-9df2-04040fbf4c83",
        "body" : "[Putting on mathematician hat.] This is because matrix multiplication correctly defines composition of linear operators. It's a \"natural\" definition independent of choice of basis. I don't even know what notation would be used for element-wise operations, short of \"Let c_{i,j} = a_{i,j}b_{i,j}.\"\n\nCarrying over this to code is of course an advantage of this PEP, but function call syntax isn't avoided in papers due to its readability. \n",
        "createdAt" : "2014-03-16T06:47:25Z",
        "updatedAt" : "2014-04-06T20:55:33Z",
        "lastEditedBy" : "b18343d1-fdd1-4dad-9df2-04040fbf4c83",
        "tags" : [
        ]
      },
      {
        "id" : "bed5d268-bab7-425e-8f15-fd381f45224b",
        "parentId" : "ba8181ef-2811-4817-8ab6-9a9f6e866798",
        "authorId" : "acce7360-5cef-46f0-ab05-4fb0ffdffe3a",
        "body" : "Elementwise products can be written [A ∘ B](https://en.wikipedia.org/wiki/Hadamard_product_%28matrices%29).\n",
        "createdAt" : "2014-04-11T14:38:05Z",
        "updatedAt" : "2014-04-11T14:38:05Z",
        "lastEditedBy" : "acce7360-5cef-46f0-ab05-4fb0ffdffe3a",
        "tags" : [
        ]
      }
    ],
    "commit" : "aadcf11a193a9523d557bc81060997d9cd3a9c8e",
    "line" : 227,
    "diffHunk" : "@@ -1,1 +225,229 @@very heavily in numerical programs -- often multiple times per line of\ncode -- and (b) it has an ancient and universally adopted tradition of\nbeing written using infix syntax.  This is because, for typical\nformulas, this notation is dramatically more readable than any\nfunction call syntax.  Here's an example to demonstrate:"
  },
  {
    "id" : "b27f12e6-c827-4c81-b22d-7d56aebeb2c7",
    "prId" : 4351,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "003b7eca-b49a-49aa-85b6-f09f23ba07c9",
        "parentId" : null,
        "authorId" : "acce7360-5cef-46f0-ab05-4fb0ffdffe3a",
        "body" : "Actually handling both types as input is not so hard if you do it like scikit-learn, were matrices may come in, but never come out. The trouble starts when you also produce np.matrix when you get it as input.\n",
        "createdAt" : "2014-04-11T10:48:28Z",
        "updatedAt" : "2014-04-11T10:48:28Z",
        "lastEditedBy" : "acce7360-5cef-46f0-ab05-4fb0ffdffe3a",
        "tags" : [
        ]
      },
      {
        "id" : "fb454cb7-3286-4247-be6a-648ada23ad83",
        "parentId" : "003b7eca-b49a-49aa-85b6-f09f23ba07c9",
        "authorId" : "810880d7-9b25-4940-a0cb-9281ddc2d16a",
        "body" : "The point is still that libraries have to be aware of this double-class\nconvention, otherwise only the broken sub-class solutions works (or\ndoesn't).\n",
        "createdAt" : "2014-04-11T11:39:16Z",
        "updatedAt" : "2014-04-11T11:39:16Z",
        "lastEditedBy" : "810880d7-9b25-4940-a0cb-9281ddc2d16a",
        "tags" : [
        ]
      },
      {
        "id" : "27406530-8786-4815-99c8-23dd9ddabedc",
        "parentId" : "003b7eca-b49a-49aa-85b6-f09f23ba07c9",
        "authorId" : "85b881e8-d8a0-43d4-81d3-7e233dc5f1ae",
        "body" : "Dealing with `matrix` in this fashion is not really an additional overhead to allowing lists or other sequences as inputs: you just always use `np.asarray()` on the inputs. If everyone did this, though, `matrix` would be useless since it would disappear whenever you passed one to a function. scikit-learn accepts this; it doesn't care about supporting `matrix` users except to transparently consume their data. It also doesn't have many functions that one would really use in expressions, so it's not much loss for `matrix` users. But there are a lot of other functions that do need to output `matrix` objects to be useful to `matrix` users, and this is difficult so few people do it right. That's why the status quo sucks. You can choose between having an operator for matrix multiplication by using the `matrix` type or having the full range of the community's code available to you. You can't have both. And just to be clear, there is nothing about this situation that depends on the implementation details of `numpy.matrix`. Subclass or not, all of these issues remain as long as you have two types that you want to interoperate.\n",
        "createdAt" : "2014-04-11T12:06:11Z",
        "updatedAt" : "2014-04-11T12:06:11Z",
        "lastEditedBy" : "85b881e8-d8a0-43d4-81d3-7e233dc5f1ae",
        "tags" : [
        ]
      },
      {
        "id" : "eb86984d-5d19-4d46-96f8-fffde155d3ee",
        "parentId" : "003b7eca-b49a-49aa-85b6-f09f23ba07c9",
        "authorId" : "acce7360-5cef-46f0-ab05-4fb0ffdffe3a",
        "body" : "@rkern I agree with you. What I was really trying to point out is that DTRT is ambiguous in this context, because to a new user there may seem to be two \"obvious\" ways of \"doing it right\".\n",
        "createdAt" : "2014-04-11T12:27:42Z",
        "updatedAt" : "2014-04-11T12:27:42Z",
        "lastEditedBy" : "acce7360-5cef-46f0-ab05-4fb0ffdffe3a",
        "tags" : [
        ]
      },
      {
        "id" : "da744efa-ef6a-404f-9589-131e934a9412",
        "parentId" : "003b7eca-b49a-49aa-85b6-f09f23ba07c9",
        "authorId" : "85b881e8-d8a0-43d4-81d3-7e233dc5f1ae",
        "body" : "Point.\n",
        "createdAt" : "2014-04-11T12:30:20Z",
        "updatedAt" : "2014-04-11T12:30:20Z",
        "lastEditedBy" : "85b881e8-d8a0-43d4-81d3-7e233dc5f1ae",
        "tags" : [
        ]
      },
      {
        "id" : "0273c9c2-6686-4d6d-ab9b-42de8970cda2",
        "parentId" : "003b7eca-b49a-49aa-85b6-f09f23ba07c9",
        "authorId" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "body" : "Ah, I see. That sentence was meant as an alternative to the previous one,\ni.e., the first point is that keeping track of which functions expect what\nis impossible, so the obvious alternative is to write functions in such a\nway that you don't need to keep track, but that is also impossible...\n\nOn Fri, Apr 11, 2014 at 1:27 PM, Lars Buitinck notifications@github.comwrote:\n\n> In doc/neps/return-of-revenge-of-matmul-pep.rst:\n> \n> > +possible to switch between the conventions, because numpy provides two\n> > +different types with different `__mul__` methods.  For\n> > +`numpy.ndarray` objects, `*` performs elementwise multiplication,\n> > +and matrix multiplication must use a function call (`numpy.dot`).\n> > +For `numpy.matrix` objects, `*` performs matrix multiplication,\n> > +and elementwise multiplication requires function syntax.  Writing code\n> > +using `numpy.ndarray` works fine.  Writing code using\n> > +`numpy.matrix` also works fine.  But trouble begins as soon as we\n> > +try to integrate these two pieces of code together.  Code that expects\n> > +an `ndarray` and gets a `matrix`, or vice-versa, may crash or\n> > +return incorrect results.  Keeping track of which functions expect\n> > +which types as inputs, and return which types as outputs, and then\n> > +converting back and forth all the time, is incredibly cumbersome and\n> > +impossible to get right at any scale.  Functions that defensively try\n> > +to handle both types as input and DTRT, find themselves floundering\n> > +into a swamp of `isinstance` and `if` statements.\n> \n> @rkern https://github.com/rkern I agree with you. What I was really\n> trying to point out is that DTRT is ambiguous in this context, because to a\n> new user there may seem to be two \"obvious\" ways of \"doing it right\".\n> \n> —\n> Reply to this email directly or view it on GitHubhttps://github.com/numpy/numpy/pull/4351/files#r11529482\n> .\n\n## \n\nNathaniel J. Smith\nPostdoctoral researcher - Informatics - University of Edinburgh\nhttp://vorpus.org\n",
        "createdAt" : "2014-04-11T12:30:31Z",
        "updatedAt" : "2014-04-11T12:30:31Z",
        "lastEditedBy" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "tags" : [
        ]
      },
      {
        "id" : "8bf416fe-aedb-4058-9ffa-9127137d5646",
        "parentId" : "003b7eca-b49a-49aa-85b6-f09f23ba07c9",
        "authorId" : "54dad831-921a-4f39-bbd3-e45ff714a9b9",
        "body" : "```\nOn 11-Apr-2014 7:39 AM, Stefan van der Walt wrote:\n  In doc/neps/return-of-revenge-of-matmul-pep.rst:\n  > +possible to switch between the conventions, because numpy provides two\n```\n\n> +different types with different `__mul__` methods.  For\n> +`numpy.ndarray` objects, `*` performs elementwise multiplication,\n> +and matrix multiplication must use a function call (`numpy.dot`).\n> +For `numpy.matrix` objects, `*` performs matrix multiplication,\n> +and elementwise multiplication requires function syntax.  Writing code\n> +using `numpy.ndarray` works fine.  Writing code using\n> +`numpy.matrix` also works fine.  But trouble begins as soon as we\n> +try to integrate these two pieces of code together.  Code that expects\n> +an `ndarray` and gets a `matrix`, or vice-versa, may crash or\n> +return incorrect results.  Keeping track of which functions expect\n> +which types as inputs, and return which types as outputs, and then\n> +converting back and forth all the time, is incredibly cumbersome and\n> +impossible to get right at any scale.  Functions that defensively try\n> +to handle both types as input and DTRT, find themselves floundering\n> +into a swamp of `isinstance` and `if` statements.\n\n```\n  The point is still that libraries have\n    to be aware of this double-class\n    convention, otherwise only the broken sub-class solutions works\n    (or\n    doesn't).\n\n\nStefan,\nThanks for this clarification.  \nYou say \"Code that expects  an ``ndarray`` and gets a ``matrix``, or\nvice-versa, may crash or return incorrect \nresults.\n\"\nI would look at this as an error in the existing code.  Would it not\nbe simpler to correct this than construct code for a new operator? \nHas this been explored?  It's been a long time since I looked at the\ncode.\nIt would help if some example of the need for \"converting back and\nforth\" could be given\nColin W.\n  —\n    Reply to this email directly or view\n      it on GitHub.\n```\n",
        "createdAt" : "2014-04-11T13:43:23Z",
        "updatedAt" : "2014-04-11T13:43:23Z",
        "lastEditedBy" : "54dad831-921a-4f39-bbd3-e45ff714a9b9",
        "tags" : [
        ]
      },
      {
        "id" : "1cf0ece9-f6b2-4621-8c8f-e3a5e5911091",
        "parentId" : "003b7eca-b49a-49aa-85b6-f09f23ba07c9",
        "authorId" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "body" : "On Fri, Apr 11, 2014 at 2:43 PM, Colin J. Williams <notifications@github.com\n\n> wrote:\n> \n>  Stefan, Thanks for this clarification.  You say \"Code that expects  an\n> `ndarray` and gets a `matrix`, or vice-versa, may crash or return\n> incorrect results. \" I would look at this as an error in the existing\n> code.  Would it not be simpler to correct this than construct code for a\n> new operator?  Has this been explored?\n\nNo, it wouldn't be simpler. Fixing every piece of code to handle both types\nas inputs and outputs means that every function must have special checks,\nwhich creates a combinatorial explosion in code complexity and is a serious\nobstacle to maintainability, testing, etc.\n\nThis is why if you look at actual code there are few (possibly zero)\nlibraries that actually handle mixed ndarray and matrix objects correctly\n(even numpy itself doesn't in many cases) -- it's just not doable. Everyone\nprefers to use ndarray objects with the cumbersome dot() function call\nsyntax for matrix multiplication. It's annoying, but it's still better than\nchecking that every single code path can handle arrays and matrices (and\ncombinations thereof etc). (In fact, there are some places where\nscikit-learn is forced to handle matrix objects because scipy.sparse only\nprovides a matrix-style API, and even in these cases they don't actually\nuse '*' for matrix multiplication -- which is the point that started this\nwhole thread. Instead they have a special safe_sparse_dot() function which\nprovides a dot()-style API that works for both arrays and matrices.)\n",
        "createdAt" : "2014-04-11T13:57:01Z",
        "updatedAt" : "2014-04-11T13:57:01Z",
        "lastEditedBy" : "762e53b3-7c6a-4fbb-8098-a2c522dd50a6",
        "tags" : [
        ]
      },
      {
        "id" : "9136d902-d1d8-4fe2-80b6-6e4e945ba1d7",
        "parentId" : "003b7eca-b49a-49aa-85b6-f09f23ba07c9",
        "authorId" : "810880d7-9b25-4940-a0cb-9281ddc2d16a",
        "body" : "@cjw43 Here's a library's code snippet for squaring the elements of an input array:\n\n```\ndef square_it(A):\n    return A * A\n```\n\nThat code is now broken, even though the library author has never even heard of a Matrix class.  The new, correct code, becomes:\n\n```\ndef square_it(A):\n    A = np.asarray(A)\n    return A * A\n```\n\nThat's not a problem as long as _all_ consumers out there are aware of this possibility, but you are forcing a convention on programmers you don't control, and one which is auxiliary their intention.  Contrast that to the following library code:\n\n```\ndef square_it(A):\n    return A * A\n```\n\nWe know what this does.  It squares the elements of the array.\n\n```\ndef square_it(A):\n    return A @ A\n```\n\nWe know what this does, it performs a dot product between the two matrices.\n",
        "createdAt" : "2014-04-11T14:04:21Z",
        "updatedAt" : "2014-04-11T14:04:21Z",
        "lastEditedBy" : "810880d7-9b25-4940-a0cb-9281ddc2d16a",
        "tags" : [
        ]
      }
    ],
    "commit" : "aadcf11a193a9523d557bc81060997d9cd3a9c8e",
    "line" : 174,
    "diffHunk" : "@@ -1,1 +172,176 @@impossible to get right at any scale.  Functions that defensively try\nto handle both types as input and DTRT, find themselves floundering\ninto a swamp of ``isinstance`` and ``if`` statements.\n\nPEP 238 split ``/`` into two operators: ``/`` and ``//``.  Imagine the"
  }
]
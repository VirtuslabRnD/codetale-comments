[
  {
    "id" : "75e62fa9-87b0-460a-9baa-1b43741e8b31",
    "prId" : 16723,
    "prUrl" : "https://github.com/numpy/numpy/pull/16723#pullrequestreview-441130302",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4c876455-ba3e-49c0-a637-6d781ad25529",
        "parentId" : null,
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "I think here it similarly must be possible to view, correct?\r\n\r\n(Since this is *very* close to what we do in `Quantity`, I'm happy to see this scheme!)",
        "createdAt" : "2020-07-01T19:43:16Z",
        "updatedAt" : "2020-10-13T22:38:19Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      }
    ],
    "commit" : "0936825af45f99b73e5566bf2c8ce82bda3c5ff2",
    "line" : 924,
    "diffHunk" : "@@ -1,1 +922,926 @@  resolved descriptors with with the desired actual loop descriptors.\n  The original ``resolve_descriptors`` function will be called between these\n  two calls, so that the output descriptors may not be set in the first call.\n  In the above example it will use the ``float64`` as returned (which might\n  have changed the byte-order), and further resolve the physical unit making"
  },
  {
    "id" : "1495e9a5-0c25-4686-a527-f3c71e33a00a",
    "prId" : 16723,
    "prUrl" : "https://github.com/numpy/numpy/pull/16723#pullrequestreview-441130302",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5ac713c6-faba-4786-aedd-6ea1c12b98f8",
        "parentId" : null,
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "The mock-up is very useful, but would be even better if `resolve_impl` had already been introduced! (perhaps via the larger mock-up I wondered about above).",
        "createdAt" : "2020-07-01T20:40:36Z",
        "updatedAt" : "2020-10-13T22:38:19Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      }
    ],
    "commit" : "0936825af45f99b73e5566bf2c8ce82bda3c5ff2",
    "line" : 1054,
    "diffHunk" : "@@ -1,1 +1052,1056 @@\n        # Could check that res[1] is actually Int64\n        return ufunc.resolve_impl(tuple(res))\n\nIn this case, just as a ``Timedelta64 * int64`` and ``int64 * timedelta64``"
  },
  {
    "id" : "a6ee95fa-76b1-48c3-9865-f5699e8426b9",
    "prId" : 16723,
    "prUrl" : "https://github.com/numpy/numpy/pull/16723#pullrequestreview-443515117",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "abdb66d5-8f17-49c7-8112-641803ac5c6e",
        "parentId" : null,
        "authorId" : "fe664d20-2239-4242-9bd1-2c7a4f010863",
        "body" : "I was wondering how this handles a case like np.add(Unit[Float64](\"m\"), Unit[Float64[\"km\"]) ? ",
        "createdAt" : "2020-07-07T01:32:48Z",
        "updatedAt" : "2020-10-13T22:38:19Z",
        "lastEditedBy" : "fe664d20-2239-4242-9bd1-2c7a4f010863",
        "tags" : [
        ]
      },
      {
        "id" : "4abeb405-eeda-42ba-ab27-21f43939e5cd",
        "parentId" : "abdb66d5-8f17-49c7-8112-641803ac5c6e",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Thanks, good point, I should explain that/give an example. For Units this uses `.view(np.float64)` in the inner loop effectively. In the outer loop, the descriptors will be set to `(Unit[Float64](\"m\"), Unit[Float64[\"m\"], Unit[Float64](\"m\"))`, so the casting machinery has to convert the `\"km\"` to `\"m\"`.",
        "createdAt" : "2020-07-07T02:10:57Z",
        "updatedAt" : "2020-10-13T22:38:19Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      }
    ],
    "commit" : "0936825af45f99b73e5566bf2c8ce82bda3c5ff2",
    "line" : 922,
    "diffHunk" : "@@ -1,1 +920,924 @@\n* ``wrap_outputs(Tuple[DType]: input_descr) -> Tuple[DType]`` replacing the\n  resolved descriptors with with the desired actual loop descriptors.\n  The original ``resolve_descriptors`` function will be called between these\n  two calls, so that the output descriptors may not be set in the first call."
  },
  {
    "id" : "8b07b605-65bb-4b40-a989-02b509ce7cee",
    "prId" : 16723,
    "prUrl" : "https://github.com/numpy/numpy/pull/16723#pullrequestreview-507681499",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0e91020c-bbe2-48ab-b8f6-5143ea4d79af",
        "parentId" : null,
        "authorId" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "body" : "I think you need dimension as well as strides. If dimensions are in the context, then strides could be as well. Also `# n: Number of` seems like a fragment.",
        "createdAt" : "2020-10-10T18:22:46Z",
        "updatedAt" : "2020-10-13T22:38:19Z",
        "lastEditedBy" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "tags" : [
        ]
      },
      {
        "id" : "17939a90-dc34-41c7-a698-bf66dc54cbf1",
        "parentId" : "0e91020c-bbe2-48ab-b8f6-5143ea4d79af",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Oh, this is a 1-D loop, so I only need the number of elements to visit in the loop (which is missing). One outstanding small question is whether we should pass the `user_data` with the context or explicitly.  (There is a downside that some fields of `context` shouldn't be used in `resolve_descriptors` since it makes sense to call that without doing any actual operation.)\r\n\r\nI will give it a pass today, and Ross as well and then plan to merge this to have a first rendered draft.",
        "createdAt" : "2020-10-13T17:39:34Z",
        "updatedAt" : "2020-10-13T22:38:19Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      }
    ],
    "commit" : "0936825af45f99b73e5566bf2c8ce82bda3c5ff2",
    "line" : 259,
    "diffHunk" : "@@ -1,1 +257,261 @@            # strides: strides to iterate all elements\n            num_chars1 = context.descriptors[0].itemsize\n            num_chars2 = context.descriptors[0].itemsize\n\n            # C code using the above information to compare the strings in"
  },
  {
    "id" : "2df3714f-13c8-430b-9de3-2a94ee7854d1",
    "prId" : 16723,
    "prUrl" : "https://github.com/numpy/numpy/pull/16723#pullrequestreview-507754123",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0007a9ce-2d20-4866-bf0e-05af2a8448e7",
        "parentId" : null,
        "authorId" : "2bbfef14-ac5b-44ae-a2a6-925f6f5b619a",
        "body" : "I think the type hints for the arguments are backwards in this code block: I think it's supposed to be `arg_name : type`. Not really a big deal since this is mostly for the purposes of illustration!",
        "createdAt" : "2020-10-13T20:22:18Z",
        "updatedAt" : "2020-10-13T22:38:19Z",
        "lastEditedBy" : "2bbfef14-ac5b-44ae-a2a6-925f6f5b619a",
        "tags" : [
        ]
      }
    ],
    "commit" : "0936825af45f99b73e5566bf2c8ce82bda3c5ff2",
    "line" : 411,
    "diffHunk" : "@@ -1,1 +409,413 @@a new ``ArrayMethod`` object:\n\n.. code-block:: python\n    :dedent: 0\n"
  }
]
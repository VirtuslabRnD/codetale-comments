[
  {
    "id" : "522d314d-9da4-4663-917c-93962f58eb42",
    "prId" : 17009,
    "prUrl" : "https://github.com/numpy/numpy/pull/17009#pullrequestreview-462906228",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b3750952-6a17-4d1c-8f46-09e6333c26c1",
        "parentId" : null,
        "authorId" : "576cec6e-8071-43f8-bce9-351a2589f050",
        "body" : "There is a case for making `order` keyword only as well, but this is certainly sufficiently for now.",
        "createdAt" : "2020-08-06T21:43:30Z",
        "updatedAt" : "2020-08-06T21:43:34Z",
        "lastEditedBy" : "576cec6e-8071-43f8-bce9-351a2589f050",
        "tags" : [
        ]
      },
      {
        "id" : "c61cf7b2-4a68-4a2e-9b30-d79a6ffe8b4f",
        "parentId" : "b3750952-6a17-4d1c-8f46-09e6333c26c1",
        "authorId" : "6e17f0b6-e8c6-47b6-83f4-6aa30f051dc0",
        "body" : "IMO, while it's good to have things match for future reference, they're of lesser importance given this is just an example, I suspect these will anyway drift from future API changes.",
        "createdAt" : "2020-08-06T22:01:45Z",
        "updatedAt" : "2020-08-06T22:01:46Z",
        "lastEditedBy" : "6e17f0b6-e8c6-47b6-83f4-6aa30f051dc0",
        "tags" : [
        ]
      }
    ],
    "commit" : "1ad017d6a64f55f70ff109497a88c047f7e994d0",
    "line" : 40,
    "diffHunk" : "@@ -1,1 +103,107 @@    @set_module('numpy')\n    @array_function_dispatch(_asarray_decorator)\n    def asarray(a, dtype=None, order=None, *, like=None):\n        return array(a, dtype, copy=False, order=order)\n"
  },
  {
    "id" : "b579a77c-ca8f-4c14-bfda-ba44978a5319",
    "prId" : 17093,
    "prUrl" : "https://github.com/numpy/numpy/pull/17093#pullrequestreview-468858911",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "546a3b6e-2ade-44a0-9cef-80e68fa86208",
        "parentId" : null,
        "authorId" : "b8653e43-28e1-47e5-8ea9-c1e36342f7b2",
        "body" : "This section is a nice read much clearer than what I tried to understand. Would it be possible to give a few sentences for the regular NumPy users who won't use this feature? ",
        "createdAt" : "2020-08-17T20:22:38Z",
        "updatedAt" : "2020-08-19T22:13:56Z",
        "lastEditedBy" : "b8653e43-28e1-47e5-8ea9-c1e36342f7b2",
        "tags" : [
        ]
      },
      {
        "id" : "7d6bf6a1-2319-42b6-afd9-8f7bb5992b30",
        "parentId" : "546a3b6e-2ade-44a0-9cef-80e68fa86208",
        "authorId" : "b8653e43-28e1-47e5-8ea9-c1e36342f7b2",
        "body" : "I mean what they would see and possibly avoid if this is implemented.",
        "createdAt" : "2020-08-17T20:23:02Z",
        "updatedAt" : "2020-08-19T22:13:56Z",
        "lastEditedBy" : "b8653e43-28e1-47e5-8ea9-c1e36342f7b2",
        "tags" : [
        ]
      },
      {
        "id" : "10794831-2b4b-4bab-bdfd-535ba7dc3915",
        "parentId" : "546a3b6e-2ade-44a0-9cef-80e68fa86208",
        "authorId" : "6e17f0b6-e8c6-47b6-83f4-6aa30f051dc0",
        "body" : "I added a sentence at the end, but to be honest, I'm not sure if that's what you meant. Let me know if that addresses your question or if I completely misunderstood your suggestion. :) ",
        "createdAt" : "2020-08-17T21:55:52Z",
        "updatedAt" : "2020-08-19T22:13:56Z",
        "lastEditedBy" : "6e17f0b6-e8c6-47b6-83f4-6aa30f051dc0",
        "tags" : [
        ]
      }
    ],
    "commit" : "57f78df125892eaa4539913759f3ac29ff4aef6a",
    "line" : 86,
    "diffHunk" : "@@ -1,1 +87,91 @@.. _neps.like-kwarg.usage-and-impact:\n\nUsage and Impact\n----------------\n"
  },
  {
    "id" : "303546a0-3212-4e55-96a5-5a96d2f71cb4",
    "prId" : 17093,
    "prUrl" : "https://github.com/numpy/numpy/pull/17093#pullrequestreview-468841052",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a1406cae-25ee-42f4-9730-d5241274bf91",
        "parentId" : null,
        "authorId" : "b8653e43-28e1-47e5-8ea9-c1e36342f7b2",
        "body" : "Whoa I didn't know this. Do we need any comparison over NEP 37 at this point? I know I am overreaching but sounds really interesting. I'll read that one after this.",
        "createdAt" : "2020-08-17T20:24:35Z",
        "updatedAt" : "2020-08-19T22:13:56Z",
        "lastEditedBy" : "b8653e43-28e1-47e5-8ea9-c1e36342f7b2",
        "tags" : [
        ]
      },
      {
        "id" : "89961455-4225-4628-a18f-2489b737e744",
        "parentId" : "a1406cae-25ee-42f4-9730-d5241274bf91",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Yup, the elephant in the room was never the syntax here :). NEP 37 is good context (I personally think the appendix may help understand some of the considerations). There are also these meeting notes (a lot in there was not actually discussed), but I am not sure it is approachable: https://github.com/numpy/archive/blob/master/other_meetings/2020-04-21-array-protocols_discussion_and_notes.md\r\n\r\nI made https://github.com/seberg/numpy-dispatch with the hope we can get try the NEP 37 idea in libraries, I guess @shoyer might be working on a JAX prototype?\r\n\r\nWell, this is just context for you though, if you are curious to dive into it.  In the end, I personally hope we can rope in library authors to help figure out what the right approach is probably, and ~the~ having something to play with helps, both with getting a feel of things and getting enthusiasm for experimenting.  (But that is just my sloppy way of saying it/take on this.)",
        "createdAt" : "2020-08-17T21:20:52Z",
        "updatedAt" : "2020-08-19T22:13:56Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      }
    ],
    "commit" : "57f78df125892eaa4539913759f3ac29ff4aef6a",
    "line" : 297,
    "diffHunk" : "@@ -1,1 +321,325 @@------------\n\nRecently a new protocol to replace ``__array_function__`` entirely was proposed\nby NEP 37 [6]_, which would require considerable rework by downstream libraries\nthat adopt ``__array_function__`` already, because of that we still believe the"
  },
  {
    "id" : "0f7a73b2-7c0a-4090-a037-212c297fb2e6",
    "prId" : 17093,
    "prUrl" : "https://github.com/numpy/numpy/pull/17093#pullrequestreview-471011847",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3cd1a0cf-f4c0-489c-8430-2333abb77c1a",
        "parentId" : null,
        "authorId" : "a6fec837-fb7a-4180-bb95-fbc0ebed412b",
        "body" : "This section is wonderful, thank you @pentschev for writing it. =) Definitely exactly what I was looking for. =) The only thing I think would be useful is to have a *complete* usage example, \"eg here is scikit-learn k-means now â€” without any option to create like, even if it works with a CuPy array as input it will end up with a NumPy array as output. But after this NEP and modifying the code to look like below, it will work completely within CuPy, or dask, or other arrays implementing this protocol.\"\r\n\r\n~~I was trying to rack my brain for examples in scikit-image that need this, but can't come up with any off the top of my head. Happy to go hunting for one, but I figure there might be existing examples that motivated this NEP in the first place and that would be simple enough to be included?~~\r\n\r\nUpdate: my_pad below is sufficient. I wonder whether it belongs in this section rather than the next one, ie move up to line 113 (cupy's TypeError) into this section, then start the next section.",
        "createdAt" : "2020-08-19T03:04:52Z",
        "updatedAt" : "2020-08-19T22:13:56Z",
        "lastEditedBy" : "a6fec837-fb7a-4180-bb95-fbc0ebed412b",
        "tags" : [
        ]
      },
      {
        "id" : "5bf6df54-ff49-4182-8f51-2487c42a27dd",
        "parentId" : "3cd1a0cf-f4c0-489c-8430-2333abb77c1a",
        "authorId" : "6e17f0b6-e8c6-47b6-83f4-6aa30f051dc0",
        "body" : "> This section is wonderful, thank you @pentschev for writing it. =) Definitely exactly what I was looking for. =)\r\n\r\nTo be fair this is not a new addition, it was already in the original text, it just got moved a bit. See https://numpy.org/neps/nep-0035-array-creation-dispatch-with-array-function.html#usage-guidance .\r\n\r\n> Update: my_pad below is sufficient.\r\n\r\nI'm not sure if you mean that `my_pad` already addresses the \"complete usage example\" you mentioned above or the strikethrough text. Are you confirming the existing example suffices?\r\n\r\n> I wonder whether it belongs in this section rather than the next one, ie move up to line 113 (cupy's TypeError) into this section, then start the next section.\r\n\r\nI tried to follow the [NEP X -- Template and Instructions](https://numpy.org/neps/nep-template.html#usage-and-impact). To my understanding, it should belong in the \"Motivation and Scope\" section, where it is now.\r\n\r\n\"Motivation and Scope: ... It should describe the existing problem, *who it affects*, what it is trying to solve, and why.\"",
        "createdAt" : "2020-08-19T15:58:21Z",
        "updatedAt" : "2020-08-19T22:13:56Z",
        "lastEditedBy" : "6e17f0b6-e8c6-47b6-83f4-6aa30f051dc0",
        "tags" : [
        ]
      },
      {
        "id" : "46b3d100-0bed-45b0-83bb-867d97a0fc3a",
        "parentId" : "3cd1a0cf-f4c0-489c-8430-2333abb77c1a",
        "authorId" : "a6fec837-fb7a-4180-bb95-fbc0ebed412b",
        "body" : "Yes, my_pad is sufficient, and I agree, it belongs in motivation and scope, but it is currently in Usage, and I was asking whether it should be moved to motivation and scope. ",
        "createdAt" : "2020-08-19T22:29:31Z",
        "updatedAt" : "2020-08-19T22:29:31Z",
        "lastEditedBy" : "a6fec837-fb7a-4180-bb95-fbc0ebed412b",
        "tags" : [
        ]
      },
      {
        "id" : "9949dd25-4551-4257-878f-d3677a4688c3",
        "parentId" : "3cd1a0cf-f4c0-489c-8430-2333abb77c1a",
        "authorId" : "6e17f0b6-e8c6-47b6-83f4-6aa30f051dc0",
        "body" : "> Yes, my_pad is sufficient, and I agree, it belongs in motivation and scope, but it is currently in Usage, and I was asking whether it should be moved to motivation and scope.\r\n\r\nAre we still talking about the paragraph saying \"We expect that this functionality will be mostly useful to library developers, ...\"? That is in Motivation and Scope already, not in Usage and Impact.",
        "createdAt" : "2020-08-19T22:38:17Z",
        "updatedAt" : "2020-08-19T22:38:17Z",
        "lastEditedBy" : "6e17f0b6-e8c6-47b6-83f4-6aa30f051dc0",
        "tags" : [
        ]
      }
    ],
    "commit" : "57f78df125892eaa4539913759f3ac29ff4aef6a",
    "line" : 78,
    "diffHunk" : "@@ -1,1 +79,83 @@allowing them to create new arrays for internal usage based on arrays passed\nby the user, preventing unnecessary creation of NumPy arrays that will\nultimately lead to an additional conversion into a downstream array type.\n\nSupport for Python 2.7 has been dropped since NumPy 1.17, therefore we make use"
  },
  {
    "id" : "24708faa-cd05-4273-90b5-6009ccb445de",
    "prId" : 17093,
    "prUrl" : "https://github.com/numpy/numpy/pull/17093#pullrequestreview-470707737",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c821182c-362c-4626-a9c7-c16fe163331e",
        "parentId" : null,
        "authorId" : "a6fec837-fb7a-4180-bb95-fbc0ebed412b",
        "body" : "This seems clunky... As a library writer, I want to *ignore* all cupy and dask code, but just have my library work seamlessly with them.\r\n\r\nI guess I have to see how this is implemented but I would *assume* that `like=` passes the responsibility of array creation to downstream libraries. If so, couldn't we use `like=arr`, and leave it up to dask to give us an array primitive with the correct `_meta`?\r\n\r\nWhat am I missing?",
        "createdAt" : "2020-08-19T03:24:54Z",
        "updatedAt" : "2020-08-19T22:13:56Z",
        "lastEditedBy" : "a6fec837-fb7a-4180-bb95-fbc0ebed412b",
        "tags" : [
        ]
      },
      {
        "id" : "88573c1a-302c-4dc1-a0a1-25b8e706dfc0",
        "parentId" : "c821182c-362c-4626-a9c7-c16fe163331e",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "I think this example is trying to solve the same problem as brought up in https://github.com/numpy/numpy/pull/17093/files#r472995422.\r\n\r\nI agree though, I'd expect `like=arr` to just work here.",
        "createdAt" : "2020-08-19T12:44:17Z",
        "updatedAt" : "2020-08-19T22:13:56Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "86b884db-0eff-42a3-8ddf-bb60dad138e9",
        "parentId" : "c821182c-362c-4626-a9c7-c16fe163331e",
        "authorId" : "6e17f0b6-e8c6-47b6-83f4-6aa30f051dc0",
        "body" : "Sorry, this is meant to explain how you would write the code for Dask as a Dask maintainer, and how it's expected to be written in a possible Dask implementation of that function. I do understand how it may look strange for a non-Dask developer, but I thought it would be useful to write code that would look real and work in their native environments -- in that case, Dask. I could remove it if you want and only leave the CuPy example, but today Dask is one of the largest users (if not _the_ largest) of `__array_function__`, so I thought I would clarify how that addresses a more complex case too.\r\n\r\n> I think this example is trying to solve the same problem as brought up in https://github.com/numpy/numpy/pull/17093/files#r472995422.\r\n> \r\n> I agree though, I'd expect `like=arr` to just work here.\r\n\r\nIt's not the same problem, it's just that here we want a CuPy array, which is the chunk type, not a new Dask array backed by CuPy.",
        "createdAt" : "2020-08-19T16:07:58Z",
        "updatedAt" : "2020-08-19T22:13:56Z",
        "lastEditedBy" : "6e17f0b6-e8c6-47b6-83f4-6aa30f051dc0",
        "tags" : [
        ]
      },
      {
        "id" : "bb5b4c5b-9640-44b3-bea8-ffd8cbc966d4",
        "parentId" : "c821182c-362c-4626-a9c7-c16fe163331e",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "If this is a dask specific example, then calling the function `my_dask_pad` would make that intent clear.",
        "createdAt" : "2020-08-19T17:05:50Z",
        "updatedAt" : "2020-08-19T22:13:56Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "87f9ac16-cd4a-450c-8c2b-176443ee1ea0",
        "parentId" : "c821182c-362c-4626-a9c7-c16fe163331e",
        "authorId" : "6e17f0b6-e8c6-47b6-83f4-6aa30f051dc0",
        "body" : "> If this is a dask specific example, then calling the function my_dask_pad would make that intent clear.\r\n\r\nFair enough, I did that change in https://github.com/numpy/numpy/pull/17093/commits/2e30534564aaf49cb0a12baf6b721b7b31402647 .",
        "createdAt" : "2020-08-19T17:54:32Z",
        "updatedAt" : "2020-08-19T22:13:56Z",
        "lastEditedBy" : "6e17f0b6-e8c6-47b6-83f4-6aa30f051dc0",
        "tags" : [
        ]
      }
    ],
    "commit" : "57f78df125892eaa4539913759f3ac29ff4aef6a",
    "line" : 149,
    "diffHunk" : "@@ -1,1 +150,154 @@\n    def my_dask_pad(arr, padding):\n        padding = np.array(padding, like=meta_from_array(arr))\n        return np.concatenate((padding, arr, padding))\n"
  },
  {
    "id" : "ae8c2265-8069-4fab-a439-fdaebadd6fa6",
    "prId" : 17093,
    "prUrl" : "https://github.com/numpy/numpy/pull/17093#pullrequestreview-471057695",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ad49eaec-a101-4565-a157-63b2299ef05b",
        "parentId" : null,
        "authorId" : "a6fec837-fb7a-4180-bb95-fbc0ebed412b",
        "body" : "Question: will `empty_like(<dask array>)` be the same as `empty(<dask array>.shape, like=<dask array>)`?\r\n\r\nIf not, then for me that seems to be an argument in favour of changing `like=` to `typeof=` as discussed on the mailing list. (Apologies if this is the wrong forum for this and/or if I'm late to the party.)\r\n\r\nIf so, then that affects the backwards compatibility section rather dramatically?",
        "createdAt" : "2020-08-19T03:34:28Z",
        "updatedAt" : "2020-08-19T22:13:56Z",
        "lastEditedBy" : "a6fec837-fb7a-4180-bb95-fbc0ebed412b",
        "tags" : [
        ]
      },
      {
        "id" : "f849098d-f6c7-4372-a416-0a2c3b351662",
        "parentId" : "ad49eaec-a101-4565-a157-63b2299ef05b",
        "authorId" : "6e17f0b6-e8c6-47b6-83f4-6aa30f051dc0",
        "body" : "> Question: will `empty_like(<dask array>)` be the same as `empty(<dask array>.shape, like=<dask array>)`?\r\n\r\nYes, it's the same, which is why I wrote those are \"redundant\".\r\n\r\n> If not, then for me that seems to be an argument in favour of changing `like=` to `typeof=` as discussed on the mailing list. (Apologies if this is the wrong forum for this and/or if I'm late to the party.)\r\n\r\nUsing `like=` was indeed due to the existing `empty_like` functions, `like` as an argument (proposed in NEP-35) has the same meaning as the `_like` suffix in a function.\r\n\r\n> If so, then that affects the backwards compatibility section rather dramatically?\r\n\r\nGiven my answers above, it shouldn't.",
        "createdAt" : "2020-08-19T16:12:00Z",
        "updatedAt" : "2020-08-19T22:13:56Z",
        "lastEditedBy" : "6e17f0b6-e8c6-47b6-83f4-6aa30f051dc0",
        "tags" : [
        ]
      },
      {
        "id" : "fbb092fe-54cb-4125-bc79-813157aa8b57",
        "parentId" : "ad49eaec-a101-4565-a157-63b2299ef05b",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "`empty_like` copies across the dtype, which is why I asked about that elsewhere in this PR..",
        "createdAt" : "2020-08-19T17:07:43Z",
        "updatedAt" : "2020-08-19T22:13:56Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "81192f01-75fd-408f-9afd-7ab0b18a116c",
        "parentId" : "ad49eaec-a101-4565-a157-63b2299ef05b",
        "authorId" : "6e17f0b6-e8c6-47b6-83f4-6aa30f051dc0",
        "body" : "> empty_like copies across the dtype, which is why I asked about that elsewhere in this PR..\r\n\r\nYeah, that's a good point. It's still possible to get the same behavior, although it's not going to happen automatically as this is part of `empty_like` implementation itself.",
        "createdAt" : "2020-08-19T18:02:43Z",
        "updatedAt" : "2020-08-19T22:13:56Z",
        "lastEditedBy" : "6e17f0b6-e8c6-47b6-83f4-6aa30f051dc0",
        "tags" : [
        ]
      },
      {
        "id" : "06b3f60f-719a-40fe-97f3-bb4f8fb762c4",
        "parentId" : "ad49eaec-a101-4565-a157-63b2299ef05b",
        "authorId" : "a6fec837-fb7a-4180-bb95-fbc0ebed412b",
        "body" : "> If so, then that affects the backwards compatibility section rather dramatically?\n\nCurrently, calling np.empty_like on a dask array will give a numpy array, right? And you're saying this proposal will change that behaviour to return a dask array? That is a massive behaviour change!",
        "createdAt" : "2020-08-19T22:34:26Z",
        "updatedAt" : "2020-08-19T22:34:26Z",
        "lastEditedBy" : "a6fec837-fb7a-4180-bb95-fbc0ebed412b",
        "tags" : [
        ]
      },
      {
        "id" : "1a0a3f0f-2f47-4c7f-af76-88a089747a9c",
        "parentId" : "ad49eaec-a101-4565-a157-63b2299ef05b",
        "authorId" : "6e17f0b6-e8c6-47b6-83f4-6aa30f051dc0",
        "body" : "> Currently, calling np.empty_like on a dask array will give a numpy array, right? And you're saying this proposal will change that behaviour to return a dask array? That is a massive behaviour change!\r\n\r\nNo, currently calling `np.empty_like` on a Dask array will return a Dask array. This NEP will _not_ change `empty_like`'s behavior whatsoever. However, calling `np.empty` on a Dask array will return a NumPy array, and this NEP adds a `like=` argument to `np.empty` (but not to `np.empty_like`), which allows it to return a Dask array _iff_ `like=dask_array`.",
        "createdAt" : "2020-08-19T22:42:07Z",
        "updatedAt" : "2020-08-19T22:42:07Z",
        "lastEditedBy" : "6e17f0b6-e8c6-47b6-83f4-6aa30f051dc0",
        "tags" : [
        ]
      },
      {
        "id" : "79db5fdd-67da-44ad-add8-08ab065ce19c",
        "parentId" : "ad49eaec-a101-4565-a157-63b2299ef05b",
        "authorId" : "a6fec837-fb7a-4180-bb95-fbc0ebed412b",
        "body" : "> No, currently calling np.empty_like on a Dask array will return a Dask array\r\n\r\nðŸ¤¯\r\n\r\nCarry on. ðŸ˜‚ ",
        "createdAt" : "2020-08-20T00:55:10Z",
        "updatedAt" : "2020-08-20T00:55:11Z",
        "lastEditedBy" : "a6fec837-fb7a-4180-bb95-fbc0ebed412b",
        "tags" : [
        ]
      }
    ],
    "commit" : "57f78df125892eaa4539913759f3ac29ff4aef6a",
    "line" : 267,
    "diffHunk" : "@@ -1,1 +245,249 @@numerical inputs such as ``range`` and ``identity``, as well as the ``empty``\nfamily of functions, even though that may be redundant, since specializations\nfor those already exist with the naming format ``empty_like``. As of the\nwriting of this NEP, a complete list of array creation functions can be\nfound in [5]_."
  },
  {
    "id" : "2e9c1b59-6f54-46b5-8d40-425feaa05eb1",
    "prId" : 17093,
    "prUrl" : "https://github.com/numpy/numpy/pull/17093#pullrequestreview-470642254",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c04725e5-f7d9-4b60-bbb3-0e01a6419cdd",
        "parentId" : null,
        "authorId" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "body" : "```suggestion\r\nThe mechanism as described above covers cases where the input is already an array.\r\nThese  arrays have to be created. NumPy provides `array creation routines` like \r\n`np.ones` but how to use these to create a CuPy or Dask array? For example,\r\nsay we have some CuPy array\r\n```",
        "createdAt" : "2020-08-19T11:26:50Z",
        "updatedAt" : "2020-08-19T22:13:56Z",
        "lastEditedBy" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "tags" : [
        ]
      },
      {
        "id" : "46402af9-d427-41a1-a2c3-b932e4024d82",
        "parentId" : "c04725e5-f7d9-4b60-bbb3-0e01a6419cdd",
        "authorId" : "b8653e43-28e1-47e5-8ea9-c1e36342f7b2",
        "body" : "This was one of the reasons why I got confused in the beginning. \"Why should I even be able to create other arrays if I am already using those libs? I can create via CuPy or Dask whatever I need\".\r\n\r\n That detail is being lost with this compact narrative. ",
        "createdAt" : "2020-08-19T12:01:23Z",
        "updatedAt" : "2020-08-19T22:13:56Z",
        "lastEditedBy" : "b8653e43-28e1-47e5-8ea9-c1e36342f7b2",
        "tags" : [
        ]
      },
      {
        "id" : "bd001b04-7c43-4452-891b-7360d1c89933",
        "parentId" : "c04725e5-f7d9-4b60-bbb3-0e01a6419cdd",
        "authorId" : "6e17f0b6-e8c6-47b6-83f4-6aa30f051dc0",
        "body" : "This was suggested in https://github.com/numpy/numpy/pull/17093#discussion_r471750471 . Given that the intent was to make the NEP clearer to users, I agree with @ilayn that the detail is getting lost.",
        "createdAt" : "2020-08-19T16:34:57Z",
        "updatedAt" : "2020-08-19T22:13:56Z",
        "lastEditedBy" : "6e17f0b6-e8c6-47b6-83f4-6aa30f051dc0",
        "tags" : [
        ]
      }
    ],
    "commit" : "57f78df125892eaa4539913759f3ac29ff4aef6a",
    "line" : 51,
    "diffHunk" : "@@ -1,1 +52,56 @@in their native library and brought back. Instead if it was possible to create\nthese objects through NumPy API then there would be an almost complete\nexperience, all using NumPy syntax. For example, say we have some CuPy array\n``cp_arr``, and want a similar CuPy array with identity matrix. We could still\nwrite the following:"
  },
  {
    "id" : "5b2485f3-ff78-4aea-8fc9-d38af549c937",
    "prId" : 17093,
    "prUrl" : "https://github.com/numpy/numpy/pull/17093#pullrequestreview-470643988",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d64d7a19-e96e-49a9-b427-8415b847b4c5",
        "parentId" : null,
        "authorId" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "body" : "```suggestion\r\nThe new ``like=`` keyword proposed is solely intended to dispatch to the\r\ndownstream library.  The object is used only as a reference, meaning that\r\nno modifications, copies or processing will be performed on that object.\r\n```",
        "createdAt" : "2020-08-19T11:28:29Z",
        "updatedAt" : "2020-08-19T22:13:56Z",
        "lastEditedBy" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "tags" : [
        ]
      },
      {
        "id" : "0eb64370-9120-456e-ac75-391413fcc765",
        "parentId" : "d64d7a19-e96e-49a9-b427-8415b847b4c5",
        "authorId" : "6e17f0b6-e8c6-47b6-83f4-6aa30f051dc0",
        "body" : "Same as in https://github.com/numpy/numpy/pull/17093#discussion_r473167902 . I think we'll be missing a small detail that might make things more confusing to users.",
        "createdAt" : "2020-08-19T16:37:06Z",
        "updatedAt" : "2020-08-19T22:13:56Z",
        "lastEditedBy" : "6e17f0b6-e8c6-47b6-83f4-6aa30f051dc0",
        "tags" : [
        ]
      }
    ],
    "commit" : "57f78df125892eaa4539913759f3ac29ff4aef6a",
    "line" : 73,
    "diffHunk" : "@@ -1,1 +74,78 @@The new ``like=`` keyword proposed is solely intended to identify the downstream\nlibrary where to dispatch and the object is used only as reference, meaning that\nno modifications, copies or processing will be performed on that object.\n\nWe expect that this functionality will be mostly useful to library developers,"
  },
  {
    "id" : "4087ac2f-776e-452f-8398-a945dbbb0d05",
    "prId" : 17093,
    "prUrl" : "https://github.com/numpy/numpy/pull/17093#pullrequestreview-470658103",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c8a35dc0-78e8-4231-b87f-44576af7623a",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "Perhaps out of scope, but... Should this copy the dtype from the `like` argument? How about cupy-specific metadata?",
        "createdAt" : "2020-08-19T11:51:30Z",
        "updatedAt" : "2020-08-19T22:13:56Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "c81adf32-a95b-4245-8b4a-4481d50fa2b0",
        "parentId" : "c8a35dc0-78e8-4231-b87f-44576af7623a",
        "authorId" : "48239ed9-0e9e-4f16-80c7-12419f1efd99",
        "body" : "This is a valid comment. It should create the array on the same GPU as the original. In the context of Dask, it would copy the chunk-sizes, and for Sparse, it would copy the format.\r\n\r\nHowever, I don't think this detail needs to be discussed, and currently `__array_function__` only passes through the type. One can cheat and copy from `self` though, as it isn't a `classmethod`.",
        "createdAt" : "2020-08-19T12:31:18Z",
        "updatedAt" : "2020-08-19T22:13:56Z",
        "lastEditedBy" : "48239ed9-0e9e-4f16-80c7-12419f1efd99",
        "tags" : [
        ]
      },
      {
        "id" : "91b0cb93-de48-4015-beb1-292080b4e89a",
        "parentId" : "c8a35dc0-78e8-4231-b87f-44576af7623a",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "I think the \"same GPU\" remark is most salient here. I think we should clarify the wording of:\r\n\r\n> no modifications, copies or processing will be performed on that object\r\n\r\nto either allow for this, forbid it, or declare it out of scope of this NEP.",
        "createdAt" : "2020-08-19T12:37:11Z",
        "updatedAt" : "2020-08-19T22:13:56Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "d30b8eff-776e-45fa-b58d-004d4a94a216",
        "parentId" : "c8a35dc0-78e8-4231-b87f-44576af7623a",
        "authorId" : "6e17f0b6-e8c6-47b6-83f4-6aa30f051dc0",
        "body" : "> Perhaps out of scope, but... Should this copy the dtype from the like argument? How about cupy-specific metadata?\r\n\r\nArray creation functions will generally specify this type of information via arguments, whereas `like=` is used to identify where to dispatch. I don't think we would be able to detect that, and I'm even less sure we would want that, as where we would expect `like=` to be used to already have the correct arguments defined by the library using it.\r\n\r\n> This is a valid comment. It should create the array on the same GPU as the original.\r\n> ...\r\n> I think the \"same GPU\" remark is most salient here\r\n\r\nThis is not possible, GPU arrays don't store this information, those arrays only know the pointer. The GPU where it's created is based on the current context selected by the library, such as `with cupy.cuda.Device(0):` . With that said, it's _always_ the responsibility of the code to define that, regardless of what this NEP is doing.",
        "createdAt" : "2020-08-19T16:53:01Z",
        "updatedAt" : "2020-08-19T22:13:56Z",
        "lastEditedBy" : "6e17f0b6-e8c6-47b6-83f4-6aa30f051dc0",
        "tags" : [
        ]
      }
    ],
    "commit" : "57f78df125892eaa4539913759f3ac29ff4aef6a",
    "line" : 64,
    "diffHunk" : "@@ -1,1 +65,69 @@.. code:: python\n\n    x = np.identity(3, like=cp_arr)\n\nAs if by magic, ``x`` will also be a CuPy array, as NumPy was capable to infer"
  },
  {
    "id" : "93299b83-4e7a-4b4f-bc23-ddf9d5518ff4",
    "prId" : 17093,
    "prUrl" : "https://github.com/numpy/numpy/pull/17093#pullrequestreview-470731568",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ab3a502d-1940-4bd9-a0a6-deafe99f2d5f",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "This begs the question _\"Why can't I just use the `my_pad` from earlier on dask arrays?\"_.",
        "createdAt" : "2020-08-19T18:08:53Z",
        "updatedAt" : "2020-08-19T22:13:56Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "6226b57a-01a3-4847-8f5b-695951a1e73c",
        "parentId" : "ab3a502d-1940-4bd9-a0a6-deafe99f2d5f",
        "authorId" : "6e17f0b6-e8c6-47b6-83f4-6aa30f051dc0",
        "body" : "That is what is explained in https://github.com/numpy/numpy/pull/17093/files#diff-e62e74367c379dd1a3b21bc549c1eba6R166-R173 .",
        "createdAt" : "2020-08-19T18:29:07Z",
        "updatedAt" : "2020-08-19T22:13:56Z",
        "lastEditedBy" : "6e17f0b6-e8c6-47b6-83f4-6aa30f051dc0",
        "tags" : [
        ]
      }
    ],
    "commit" : "57f78df125892eaa4539913759f3ac29ff4aef6a",
    "line" : 148,
    "diffHunk" : "@@ -1,1 +149,153 @@    from dask.array.utils import meta_from_array\n\n    def my_dask_pad(arr, padding):\n        padding = np.array(padding, like=meta_from_array(arr))\n        return np.concatenate((padding, arr, padding))"
  },
  {
    "id" : "e6d9a905-06cd-46c3-8960-0e392ee17c50",
    "prId" : 17093,
    "prUrl" : "https://github.com/numpy/numpy/pull/17093#pullrequestreview-473387763",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2951bc39-ad7e-49a9-a49d-deaaa9b79311",
        "parentId" : null,
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "This code would work just fine without the second line. To motivate it, perhaps:\r\n```suggestion\r\n    def my_pad(arr, padding):\r\n        # coerce `padding` just once, rather than letting `concatenate` do it twice\r\n        padding = np.array(padding, like=arr)\r\n        return np.concatenate((padding, arr, padding))\r\n```",
        "createdAt" : "2020-08-19T19:14:21Z",
        "updatedAt" : "2020-08-19T22:13:56Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      },
      {
        "id" : "8cdd84ca-aff5-45e8-ad24-dbb8172d6121",
        "parentId" : "2951bc39-ad7e-49a9-a49d-deaaa9b79311",
        "authorId" : "6e17f0b6-e8c6-47b6-83f4-6aa30f051dc0",
        "body" : "> This code would work just fine without the second line.\r\n\r\nI don't get this comment, are you saying it works without the `np.concatenate`?",
        "createdAt" : "2020-08-19T22:16:26Z",
        "updatedAt" : "2020-08-19T22:16:26Z",
        "lastEditedBy" : "6e17f0b6-e8c6-47b6-83f4-6aa30f051dc0",
        "tags" : [
        ]
      },
      {
        "id" : "6e21dd0b-6209-42c0-beba-8484e838ae4b",
        "parentId" : "2951bc39-ad7e-49a9-a49d-deaaa9b79311",
        "authorId" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "body" : "The naive reader may not understand why the call to `padding = np.array(padding, like=arr)` is needed.",
        "createdAt" : "2020-08-24T11:43:13Z",
        "updatedAt" : "2020-08-24T11:43:13Z",
        "lastEditedBy" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "tags" : [
        ]
      },
      {
        "id" : "4efdb3fe-45ca-4802-8355-174063d4382d",
        "parentId" : "2951bc39-ad7e-49a9-a49d-deaaa9b79311",
        "authorId" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "body" : ".. but then it is explained in the text below.",
        "createdAt" : "2020-08-24T11:44:03Z",
        "updatedAt" : "2020-08-24T11:44:04Z",
        "lastEditedBy" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "tags" : [
        ]
      }
    ],
    "commit" : "57f78df125892eaa4539913759f3ac29ff4aef6a",
    "line" : 106,
    "diffHunk" : "@@ -1,1 +107,111 @@    def my_pad(arr, padding):\n        padding = np.array(padding, like=arr)\n        return np.concatenate((padding, arr, padding))\n\n    my_pad(np.arange(5), [-1, -1])    # Returns np.ndarray"
  },
  {
    "id" : "9d0d4d78-2028-456e-a4c8-a203078835fb",
    "prId" : 17093,
    "prUrl" : "https://github.com/numpy/numpy/pull/17093#pullrequestreview-471002973",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e709869d-9526-473d-b6b9-3162682efbce",
        "parentId" : null,
        "authorId" : "8ffdfffb-d8d9-40f6-9de3-dd0dee381149",
        "body" : "this isn't rendering - need a blank line below a reST directive. \r\n\r\n(and same for the next example a few lines below)",
        "createdAt" : "2020-08-19T22:09:32Z",
        "updatedAt" : "2020-08-19T22:13:56Z",
        "lastEditedBy" : "8ffdfffb-d8d9-40f6-9de3-dd0dee381149",
        "tags" : [
        ]
      },
      {
        "id" : "c654706b-f48f-4737-8907-210914f1ea13",
        "parentId" : "e709869d-9526-473d-b6b9-3162682efbce",
        "authorId" : "6e17f0b6-e8c6-47b6-83f4-6aa30f051dc0",
        "body" : "Thanks @rgommers , I fixed that also in https://github.com/numpy/numpy/pull/17093/commits/57f78df125892eaa4539913759f3ac29ff4aef6a .",
        "createdAt" : "2020-08-19T22:16:46Z",
        "updatedAt" : "2020-08-19T22:16:46Z",
        "lastEditedBy" : "6e17f0b6-e8c6-47b6-83f4-6aa30f051dc0",
        "tags" : [
        ]
      }
    ],
    "commit" : "57f78df125892eaa4539913759f3ac29ff4aef6a",
    "line" : 55,
    "diffHunk" : "@@ -1,1 +56,60 @@write the following:\n\n.. code:: python\n\n     x = cupy.identity(3)"
  }
]
[
  {
    "id" : "0fbde997-c32d-43c2-ad41-fd17b27702ff",
    "prId" : 15507,
    "prUrl" : "https://github.com/numpy/numpy/pull/15507#pullrequestreview-353306916",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "df0185cd-acdb-4f10-a76d-125c0d8ca9a2",
        "parentId" : null,
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "It does seem that this whole part can be done after the move to a new class hierarchy - so at some level it may be fine to postpone deciding on it.",
        "createdAt" : "2020-02-04T19:33:39Z",
        "updatedAt" : "2020-06-11T23:40:59Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      },
      {
        "id" : "5dcafa3d-5a85-4585-8f96-5908c36928fe",
        "parentId" : "df0185cd-acdb-4f10-a76d-125c0d8ca9a2",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Right, class hierarchy (or at least having the classes to begin with) is the first step. I would like to push that forward already before settling on this, by agreeing on NEP 41. May have to move some of the information there though...",
        "createdAt" : "2020-02-04T21:16:20Z",
        "updatedAt" : "2020-06-11T23:40:59Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      }
    ],
    "commit" : "a69d3e78ef6bb54c46acd9f8b9fb5f778782e91c",
    "line" : 614,
    "diffHunk" : "@@ -1,1 +612,616 @@expanding it to e.g. list inputs ``np.add(np.array([8], dtype=\"uint8\"), [4])``\ngiving a ``uint8`` result.\nThis is mainly related to the question to how the common dtype is found above.\nIt seems unlikely that this is useful, and similar to a global, could be\nadded later if deemed necessary."
  },
  {
    "id" : "96386098-4cff-43d2-b437-6ebf9716a804",
    "prId" : 15507,
    "prUrl" : "https://github.com/numpy/numpy/pull/15507#pullrequestreview-353314093",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "01483566-eaba-445b-8c06-fa538adfa26a",
        "parentId" : null,
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "This seems a point worth breaking out a bit more: does one want the user to decide that `uint16`+`int16` should give `int24`, even inside any libraries the user uses? My sense is that the answer is yes, but with great big warnings in the docs.",
        "createdAt" : "2020-02-04T19:49:58Z",
        "updatedAt" : "2020-06-11T23:40:59Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      },
      {
        "id" : "eae06287-3784-4715-a7aa-a6be34d20d95",
        "parentId" : "01483566-eaba-445b-8c06-fa538adfa26a",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "My current sense is: Lets not go there :). These type of things run into scoping issues quickly. So if a user wants `uint16 + int16` to be `int24` they probably should be either using their own `uint16`, or use `dtype=int24`.\r\nI am also OK with adding it at some point, but I am scared of it, and I would prefer if we can agree to *not* do anything in this direction right now.",
        "createdAt" : "2020-02-04T21:20:40Z",
        "updatedAt" : "2020-06-11T23:40:59Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "5739d24d-1714-4cf5-a7cc-f4326e6c5cf8",
        "parentId" : "01483566-eaba-445b-8c06-fa538adfa26a",
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "OK, makes sense not to start with this!",
        "createdAt" : "2020-02-04T21:28:42Z",
        "updatedAt" : "2020-06-11T23:40:59Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      }
    ],
    "commit" : "a69d3e78ef6bb54c46acd9f8b9fb5f778782e91c",
    "line" : 783,
    "diffHunk" : "@@ -1,1 +781,785 @@the behaviour of an existing program.  For example, a new ``int24`` would be\nthe first valid common type for ``int16`` and ``uint16``, demoting the currently\ndefined behaviour of ``int32``.\nThis API extension could be allowed in the future, while adding it may be\nmore involved, the current proposal for defining casts is fully opaque in"
  },
  {
    "id" : "f8b2c42f-635a-4fb0-8b4c-1f47b1f846cf",
    "prId" : 15507,
    "prUrl" : "https://github.com/numpy/numpy/pull/15507#pullrequestreview-353311145",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7d6c3c44-64b1-4373-b8bc-e87109b53db2",
        "parentId" : null,
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "I like the analogy with ufuncs very much. Indeed, might it makes sense, at least conceptually, as seeing this whole part as adding loops to `np.positive`?  \r\n\r\nYour note certainly suggests that one should not set this part of the API in stone.",
        "createdAt" : "2020-02-04T19:55:57Z",
        "updatedAt" : "2020-06-11T23:40:59Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      },
      {
        "id" : "be7ce437-1073-4457-ad5d-014865531d3f",
        "parentId" : "7d6c3c44-64b1-4373-b8bc-e87109b53db2",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Currently, I am thinking: Make it analogous to ufuncs, *except* for the loop discovery itself. You could just have a `np.cast` ufunc as well. But I somewhat tend to casting being special enough to not do that. Plus, it ensures that (whatever you do for ufuncs) casting is a bit more contraint.\r\n\r\nI probably have to add some more reasons for that decision though.",
        "createdAt" : "2020-02-04T21:23:34Z",
        "updatedAt" : "2020-06-11T23:40:59Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      }
    ],
    "commit" : "a69d3e78ef6bb54c46acd9f8b9fb5f778782e91c",
    "line" : 1017,
    "diffHunk" : "@@ -1,1 +1015,1019 @@\nIn the future, we may consider adding a way to spell out that specific\ncasts are known to be *not* possible.\n\nIn the above text ``CastingImpl`` is described as a Python object. In practice,"
  },
  {
    "id" : "6dc6d3f1-68fb-407b-9c57-c02bfc649b56",
    "prId" : 15507,
    "prUrl" : "https://github.com/numpy/numpy/pull/15507#pullrequestreview-370795953",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5e4e0a0d-9ff2-4e7a-9400-dcbb3312950c",
        "parentId" : null,
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "Might it be possible to rely even less on custom items? (Sorry this is vague! Not really wrapped my head around new actual classes! so do ignore as appropriate!). Specifically, might `flexible` and `abstract` be defined already by the type of class they inherit from? Indeed, `abstract` is really like the ABC: the actual concrete instance does have appropriate methods/attributes. Can we use the ABC? (I vaguely recall it is rewritten in C so perhaps not totally crazy. Certainly good to use whatever they have to the extent possible.)\r\n",
        "createdAt" : "2020-02-04T20:11:18Z",
        "updatedAt" : "2020-06-11T23:40:59Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      },
      {
        "id" : "635d0578-ba97-49f7-8666-4de9290b8509",
        "parentId" : "5e4e0a0d-9ff2-4e7a-9400-dcbb3312950c",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "You are not inheriting from anything except DType here (unless its abstract). So yes, I could make an `AbstractDType` as a subclass (or superclass) of `np.dtype`, which is used to indicate that it is abstract.\r\nMy current thinking is that I want to be able to ensure that any abstract dtype cannot be simply instantiated, and this might be easiest. But hmmmm. The `flexible` part is unnecessary, but should allow some optimizations and also sanity checks because \"flexible\" dtypes require more logic.",
        "createdAt" : "2020-02-04T21:25:52Z",
        "updatedAt" : "2020-06-11T23:40:59Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "88fff0bd-fd19-4aa4-89b1-ee7645c890c2",
        "parentId" : "5e4e0a0d-9ff2-4e7a-9400-dcbb3312950c",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "We can use ABCs, I am not sure it is valuable though (plus I am a bit scared of python changing how they define ABCs). In fact ABCs are *effectively* defined in Python right now (they are optimized using C, but they do not use an `ExtenionMetaClass` as I do (that does not make things harder maybe though).\r\n\r\nOn the other hand, I expect the actual need we have is only overriding `isinstance`, etc. so I am not sure it is valuable to use ABCs, it seems like it may add more complexity then it solves.",
        "createdAt" : "2020-02-04T21:28:43Z",
        "updatedAt" : "2020-06-11T23:40:59Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "a26769d7-305b-4970-843b-9392e08d8559",
        "parentId" : "5e4e0a0d-9ff2-4e7a-9400-dcbb3312950c",
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "Indeed, not sure it adds enough, but really it was meant as encouragement (for you, I fear...) to look what they actually do so that we do not reinvent the wheel. The other part of ABCs is, of course, to ensure that any concrete instance has all the needed methods, etc., so they would ensure that abstract dtypes cannot be instantiated.",
        "createdAt" : "2020-02-04T21:31:11Z",
        "updatedAt" : "2020-06-11T23:40:59Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      },
      {
        "id" : "f903814e-d9f5-44c6-9234-0bc2a2293fe1",
        "parentId" : "5e4e0a0d-9ff2-4e7a-9400-dcbb3312950c",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Note to self: It could also be an option to include a version (maybe NPY_API_VERSION maybe another one) in these structs, that way we can add fields at to the end without breaking ABI (with the new fields being safe to ignore on old versions). Note sure I like it, and it would still only allow adding things at the end of the struct.",
        "createdAt" : "2020-03-08T00:09:34Z",
        "updatedAt" : "2020-06-11T23:40:59Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      }
    ],
    "commit" : "a69d3e78ef6bb54c46acd9f8b9fb5f778782e91c",
    "line" : 1087,
    "diffHunk" : "@@ -1,1 +1085,1089 @@      int flags                 /* flags (to be discussed) */\n      /* NULL terminated CastingImpl; is copied and references are stolen */\n      CastingImpl *castingimpls[];\n      PyType_Slot *slots;\n      PyTypeObject *baseclass;  /* Baseclass or NULL */"
  },
  {
    "id" : "752de226-307d-4a6b-ae18-f8b480b46ea4",
    "prId" : 15507,
    "prUrl" : "https://github.com/numpy/numpy/pull/15507#pullrequestreview-362951707",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "248f92c8-67d1-444c-a8f0-9b502c0d40fa",
        "parentId" : null,
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "Maybe I'm thinking too much from the python level, but wouldn't subclassing from a class that errors or defers make sense?",
        "createdAt" : "2020-02-04T20:13:33Z",
        "updatedAt" : "2020-06-11T23:40:59Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      },
      {
        "id" : "38d28f27-6ad9-494b-a6e6-80edd3ba1783",
        "parentId" : "248f92c8-67d1-444c-a8f0-9b502c0d40fa",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Often yes... But I think the issue is for container types (covariance vs. contravariance). It all confuses me a lot. The main thing is that it is never really *safe* to cast to the super class, but is it always *unsafe*? If I cast from Float64 to UnitFloat64 and it subclasses, should we allow that as \"unsafe\". Is `nonzero` still correct if I derive an NAInt64 from Int64?\r\n\r\nWikipedia says: Mutable data types which act as both sources and sinks should be invariant (https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)), but to be honest I have not fully grasped the theory. But whenever I tried to think about a good generalization something seemed to make it complicated...",
        "createdAt" : "2020-02-04T21:33:06Z",
        "updatedAt" : "2020-06-11T23:40:59Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "40584d0d-c730-4e57-b574-96d328d92b6d",
        "parentId" : "248f92c8-67d1-444c-a8f0-9b502c0d40fa",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "However, I think it might be fine on AbstractDTypes, and even inheriting \"defaults\" from the AbstractDType, even for slots/casting! You just must not subclass *concrete* dtypes. I am just thinking we can defer that a bit for now, probably.",
        "createdAt" : "2020-02-04T21:34:04Z",
        "updatedAt" : "2020-06-11T23:40:59Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "7a7765f1-c8f3-4b15-b952-7ec3799f7e89",
        "parentId" : "248f92c8-67d1-444c-a8f0-9b502c0d40fa",
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "Hmm, thinking more, I'm now wondering about not being allowed to subclass `float64` - and it may again be good to be super-explicit: I think from what you write as an dtype instance as something that completely describes what some pieces of memory mean - this to me makes sense (though would be good to be explicit how it goes for units like in datetime!). But what about the dtype above? Is it that the class knows what the meaning is, and the instance only defines possible details of the storage? But why would that need to prevent subclassing?\r\n\r\nThough probably none of this matters too much - there is real clarity about what the `AbstractDType` is, which I think is the more important distinction.",
        "createdAt" : "2020-02-04T22:03:10Z",
        "updatedAt" : "2020-06-11T23:40:59Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      },
      {
        "id" : "ccea4177-e630-4995-a415-355bd68656c2",
        "parentId" : "248f92c8-67d1-444c-a8f0-9b502c0d40fa",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "I am cautious about subclassing, and still think it is a bad idea. We can make it easy to wrap or fallback to other datatypes, but...\r\nThere is actually a *real* and valid use case for subclassing which for sure does not violate Liskov's substitution principle: In theory (not sure how realistic) CuPy, could subclass float64, to add information that they need to work on the GPU, but still share implementation (and even be compatible with) NumPy.\r\n(adding a sentence for that, may get a bit much, but it is an important possibility I think)",
        "createdAt" : "2020-02-21T22:18:51Z",
        "updatedAt" : "2020-06-11T23:40:59Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      }
    ],
    "commit" : "a69d3e78ef6bb54c46acd9f8b9fb5f778782e91c",
    "line" : 1118,
    "diffHunk" : "@@ -1,1 +1116,1120 @@* ``common_instance(self, other) -> dtype or NULL``\n\nIf not set, most slots are filled with slots which either error or defer automatically.\nNon-parametric dtypes do not have to implement:\n"
  },
  {
    "id" : "34564e4e-42c6-48f9-880d-947c32e5ccfb",
    "prId" : 15507,
    "prUrl" : "https://github.com/numpy/numpy/pull/15507#pullrequestreview-362960223",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "99e753df-2de4-402c-bba3-10a4133626b3",
        "parentId" : null,
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "What makes it impossible to make it identical to a ufunc loop?",
        "createdAt" : "2020-02-04T20:19:03Z",
        "updatedAt" : "2020-06-11T23:40:59Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      },
      {
        "id" : "f537093e-a013-471c-94fb-2f8a111346f0",
        "parentId" : "99e753df-2de4-402c-bba3-10a4133626b3",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "The ufunc loop will have the same `adjust_dtypes` function. And the UfuncLoop/Impl object may in the future be callable (on ndarray) from python. Which CastingImpl could inherit from it. Further the way the actual inner-loop is fetched, can be identical.",
        "createdAt" : "2020-02-04T21:38:20Z",
        "updatedAt" : "2020-06-11T23:40:59Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "e59423f2-06d2-45f1-a8a7-7a1bd51ec3a3",
        "parentId" : "99e753df-2de4-402c-bba3-10a4133626b3",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Hmm, good point, the `casting` is somewhat more central (we need a default one, ufuncs do not need that I think), but really I probably still need a `FromSpec` function, so small differences between the two can be moved there to keep it more similar.",
        "createdAt" : "2020-02-21T22:40:30Z",
        "updatedAt" : "2020-06-11T23:40:59Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      }
    ],
    "commit" : "a69d3e78ef6bb54c46acd9f8b9fb5f778782e91c",
    "line" : 1187,
    "diffHunk" : "@@ -1,1 +1185,1189 @@Although verbose, the API shall mimic the one for creating a new DType.\nThe ``PyArrayCastingImpl_Spec`` will include a field for ``dtypes`` and\nidentical to a ``PyArrayUFuncImpl_Spec``::\n\n    typedef struct{"
  },
  {
    "id" : "f4fb4d15-0070-462e-a0ab-651a1ade3ccc",
    "prId" : 15507,
    "prUrl" : "https://github.com/numpy/numpy/pull/15507#pullrequestreview-353361740",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ba09de66-a778-4d15-82ba-0c27178c0bc6",
        "parentId" : null,
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "This example seems worth highlighting throughout (perhaps also in one of the other NEPs?): I would think integer and datetime as dtypes only have in common a little bit of how they interpret bytes, but really they should not be allowed to cast at all - their physical interpretation is different. This influences a lot of things: they should not be convertible to python integer, etc.\r\n\r\nMore concretely, since I'm actually not quite sure how it would fit in the new scheme, it may be good to add `Datetime64` to your figure. In particular, how is the unit kept? Are there different instances for different units?",
        "createdAt" : "2020-02-04T20:35:52Z",
        "updatedAt" : "2020-06-11T23:40:59Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      },
      {
        "id" : "cdfad4ab-9efa-4156-a7fd-f5a9a062dac0",
        "parentId" : "ba09de66-a778-4d15-82ba-0c27178c0bc6",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Yes, each datetime64 with different unit is its own instance. It is a good example to use throughout, since units are one of the most complex use-cases. I think *unsafe* casting is OK for these (i.e. it is allowed to lose the unit).",
        "createdAt" : "2020-02-04T21:42:12Z",
        "updatedAt" : "2020-06-11T23:40:59Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "706c3d33-4e1d-4347-a22c-05a73b058987",
        "parentId" : "ba09de66-a778-4d15-82ba-0c27178c0bc6",
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "Great to use it!\r\n\r\nThough personally I do not think it should be OK to cast unsafely - you have not just thrown away precision or so, but the actual meaning of the number - just like you would if you cast from meters to seconds - I think this is something you should use  `.view(integer)` for. (In astropy, for any number with units we allow only 0, infinity, and nan to have arbitrary unit - which does break down for 0 for Celsius, but then, that is a bad unit!)",
        "createdAt" : "2020-02-04T22:09:46Z",
        "updatedAt" : "2020-06-11T23:40:59Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      },
      {
        "id" : "adf9dd1a-163c-4573-b801-af8191da14c9",
        "parentId" : "ba09de66-a778-4d15-82ba-0c27178c0bc6",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "That is a fair point, maybe we actually need an \"even more unsafe\" casting :). Note that precision loss in some sense covered by `\"same_kind\"` casting? I had not thought about it too much that our current \"unsafe\" casting. However, I think you could also do this:\r\n\r\n* `UnitFloat64[m] -> Float64` (cannot cast!)\r\n* `UnitFloat64[unitless] -> Float64` unsafe cast.\r\n\r\nNow the question is, how do you get from `UnitFloat64[m]` to `UnitFloat64[unitless]`. We could even decide that you need a UFunc to do that. Or that step is \"unsafe\" (and a view), and you simply need two steps to get to the actual `float64`. Requiring two steps seems completely fine to me, but it seems like we may still need another level of safeness, basically what you call `view` which currently means: ignore casting safety entirely.",
        "createdAt" : "2020-02-04T22:31:14Z",
        "updatedAt" : "2020-06-11T23:40:59Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "80dd9713-5829-403e-b7c0-a50fde60685d",
        "parentId" : "ba09de66-a778-4d15-82ba-0c27178c0bc6",
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "Your itemized example is how astropy works! But you are right that of course our quantities do have a `.value` property that just gives the unit-less version (it is just a view), and one uses this quite a bit (as one does the `to_value(new-unit)` which gives the value in the new unit). So, it may have to be that the dtype itself introduces a new casting rule? Maybe those casting strings can become dtype-specific? For now, probably best to leave open!!",
        "createdAt" : "2020-02-04T22:41:14Z",
        "updatedAt" : "2020-06-11T23:40:59Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      },
      {
        "id" : "f28a8801-6f8a-4ea4-8e87-b598543946a1",
        "parentId" : "ba09de66-a778-4d15-82ba-0c27178c0bc6",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Yes, we could specify (for new slots) that they have to allow for new casting rules to be added in the future. But I actually think that if you are concerned that \"unsafe\" is not enough, the custom ufunc is not unreasonable: If you make unit, add `units.force_unit(arr, dtype=units.Float64(\"m\"))` ufunc.",
        "createdAt" : "2020-02-04T22:55:41Z",
        "updatedAt" : "2020-06-11T23:40:59Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      }
    ],
    "commit" : "a69d3e78ef6bb54c46acd9f8b9fb5f778782e91c",
    "line" : 183,
    "diffHunk" : "@@ -1,1 +181,185 @@subclassing concrete DTypes directly.\nFor example, logic such as ``can_cast`` does not cleanly inherit from a\n``Int64`` to a ``Datetime64`` even though the ``Datetime64`` could be seen\nas an integer with only a unit attached (and thus implemented as a subclass).\n"
  },
  {
    "id" : "9a5ec12d-41a8-4035-bb9b-44e334f2c74e",
    "prId" : 15507,
    "prUrl" : "https://github.com/numpy/numpy/pull/15507#pullrequestreview-429148207",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "441f291e-1ce7-433a-8be9-d68100b62ec3",
        "parentId" : null,
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "I guess I'm not quite sure how this would actually work on the python side. What is `item_pointer`? A buffer? A `bytearray`?",
        "createdAt" : "2020-02-04T20:52:40Z",
        "updatedAt" : "2020-06-11T23:40:59Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      },
      {
        "id" : "7a0a81e8-c8b5-4196-b2e3-2dbceaeb9475",
        "parentId" : "441f291e-1ce7-433a-8be9-d68100b62ec3",
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "I wonder if it makes sense to think of this more as a file, and thus `read` and `write` methods with a correctly set file pointer.",
        "createdAt" : "2020-02-04T20:54:10Z",
        "updatedAt" : "2020-06-11T23:40:59Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      },
      {
        "id" : "1bbaee5b-4359-4d44-8f9f-0857050a2c18",
        "parentId" : "441f291e-1ce7-433a-8be9-d68100b62ec3",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "It doesn't work on the python side :), at least not for now... I guess it would have to be something like a file-like object as you say..",
        "createdAt" : "2020-02-04T21:45:53Z",
        "updatedAt" : "2020-06-11T23:40:59Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "85a09054-ceb9-4022-9517-b3afc3c0c315",
        "parentId" : "441f291e-1ce7-433a-8be9-d68100b62ec3",
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "In principle, I guess it could default to `<relevant-piece of memory>.view('u1')` or, equivalently, `array[index].view('u1')` ",
        "createdAt" : "2020-02-04T22:32:54Z",
        "updatedAt" : "2020-06-11T23:40:59Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      },
      {
        "id" : "22db72c0-3b93-474b-a693-9a769752be0a",
        "parentId" : "441f291e-1ce7-433a-8be9-d68100b62ec3",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Yes, note that I see this not as an actual Python API proposal, but only as a way to reason about it a bit easier then writing the C version.",
        "createdAt" : "2020-02-04T22:37:48Z",
        "updatedAt" : "2020-06-11T23:40:59Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "5e79ae48-ae93-412d-805c-3cf55d9a9cc3",
        "parentId" : "441f291e-1ce7-433a-8be9-d68100b62ec3",
        "authorId" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "body" : "If we added a python interface later, passing a `memoryview` would seem very reasonable here.",
        "createdAt" : "2020-06-11T17:50:50Z",
        "updatedAt" : "2020-06-11T23:40:59Z",
        "lastEditedBy" : "ab55dc5f-f626-43b1-ba83-3d8843d79a45",
        "tags" : [
        ]
      }
    ],
    "commit" : "a69d3e78ef6bb54c46acd9f8b9fb5f778782e91c",
    "line" : 328,
    "diffHunk" : "@@ -1,1 +326,330 @@Coercing to and from Python scalars requires two to three methods:\n\n1. ``__dtype_setitem__(self, item_pointer, value)``\n2. ``__dtype_getitem__(self, item_pointer, base_obj) -> object``\n   The ``base_obj`` should be ignored normally, it is provided *only* for"
  },
  {
    "id" : "e2796869-544d-44e5-9577-ce2d55052ffa",
    "prId" : 15507,
    "prUrl" : "https://github.com/numpy/numpy/pull/15507#pullrequestreview-353328089",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "289f2a58-51a1-4d68-826b-9b40f3bb7b6a",
        "parentId" : null,
        "authorId" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "body" : "To clarify: this method returns a numpy scalar with dtype=self?",
        "createdAt" : "2020-02-04T20:53:35Z",
        "updatedAt" : "2020-06-11T23:40:59Z",
        "lastEditedBy" : "1794b506-aeff-4fdc-9354-7fd193f97b33",
        "tags" : [
        ]
      },
      {
        "id" : "14a9e2ad-3e72-48bf-a1fe-510d38f1dad1",
        "parentId" : "289f2a58-51a1-4d68-826b-9b40f3bb7b6a",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Yeah, at least normally it should probably. There is some complexity about how we want user scalars to behave (should they have to be array scalars at all, should we allow them to choose to not use `PyArray_Return`, and if, would reductions return a scalar or not...)\r\nI currently see it: For now they probably should be array scalars (but it likely will be the users responsibility). But we could add at some point that dtypes can indicate that they do not want `PyArray_Return` to be called...",
        "createdAt" : "2020-02-04T21:52:23Z",
        "updatedAt" : "2020-06-11T23:40:59Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      }
    ],
    "commit" : "a69d3e78ef6bb54c46acd9f8b9fb5f778782e91c",
    "line" : 333,
    "diffHunk" : "@@ -1,1 +331,335 @@   memory management purposes, pointing to an object owning the data.\n   It exists only to allow support of structured datatypes with subarrays\n   within NumPy, which (currently) return views into the array.\n   The function returns an equivalent Python scalar (i.e. typically a NumPy\n   scalar)."
  },
  {
    "id" : "7f7bc79c-83da-45b4-a611-5a110c5d56e8",
    "prId" : 15507,
    "prUrl" : "https://github.com/numpy/numpy/pull/15507#pullrequestreview-413003464",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "587e88e8-5210-452c-9e92-c105fa82de06",
        "parentId" : null,
        "authorId" : "2bbfef14-ac5b-44ae-a2a6-925f6f5b619a",
        "body" : "```suggestion\r\nThere are multiple reasons for this:\r\n\r\n```\r\nNeed the extra line here to get the numbered list formatted properly",
        "createdAt" : "2020-05-15T23:41:09Z",
        "updatedAt" : "2020-06-11T23:40:59Z",
        "lastEditedBy" : "2bbfef14-ac5b-44ae-a2a6-925f6f5b619a",
        "tags" : [
        ]
      }
    ],
    "commit" : "a69d3e78ef6bb54c46acd9f8b9fb5f778782e91c",
    "line" : 140,
    "diffHunk" : "@@ -1,1 +138,142 @@The creation of DType classes has already been decided in NEP 41.\nHere we discuss the notion of **abstract** DTypes.\nThere are multiple reasons for this:\n\n1. It allows the definition of a class hierarchy, in principle allowing checks like"
  },
  {
    "id" : "bc2744f2-d893-4811-98cf-f45eae15bb93",
    "prId" : 17447,
    "prUrl" : "https://github.com/numpy/numpy/pull/17447#pullrequestreview-503111243",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "809f0cd4-a748-4177-afc9-f220b67e8fb6",
        "parentId" : null,
        "authorId" : "ebbd559e-4e98-4695-a417-e4a6bc303d63",
        "body" : "How about\r\n\r\n```suggestion\r\n    class UserScalar: ...\r\n    class UserDtype(np.dtype[UserScalar]): ...\r\n```\r\n\r\nor if we want the scalar type to be variable:\r\n\r\n```suggestion\r\n    T = typing.TypeVar(\"T\")\r\n    class UserDtype(np.dtype[T]): ...\r\n``` \r\n\r\nEDIT1: Made `np.generic` superclass of `UserScalar` and use it as bound for the typevar. \r\nEDIT2: Reverted the previous edit (see https://github.com/numpy/numpy/pull/17447#discussion_r500363376).",
        "createdAt" : "2020-10-04T17:29:02Z",
        "updatedAt" : "2020-10-06T15:45:51Z",
        "lastEditedBy" : "ebbd559e-4e98-4695-a417-e4a6bc303d63",
        "tags" : [
        ]
      },
      {
        "id" : "1d014f0f-4453-4a90-ae1b-a3fd1d901a1f",
        "parentId" : "809f0cd4-a748-4177-afc9-f220b67e8fb6",
        "authorId" : "0354b9b7-8a89-4c8d-85d2-b0f4bcddce0a",
        "body" : "I'm not sure-in the NEP there is this line:\r\n\r\n> The notation works equally well with built-in and user-defined DTypes\r\n\r\nbut I'm not actually sure _how_ the `__class_getitem__` would work with a user-defined scalar type. I have more been expecting that people would define new DType classes directly (maybe not even defining a corresponding scalar type!), which is why I emphasized the DType class here and left the scalars out.",
        "createdAt" : "2020-10-04T18:42:32Z",
        "updatedAt" : "2020-10-04T19:36:11Z",
        "lastEditedBy" : "0354b9b7-8a89-4c8d-85d2-b0f4bcddce0a",
        "tags" : [
        ]
      },
      {
        "id" : "3c4a9b00-ebd0-4ab3-a9a0-3b113f208f29",
        "parentId" : "809f0cd4-a748-4177-afc9-f220b67e8fb6",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "@person142 it will work for DTypes requesting it (not necessarily for all DTypes). And in that case it will work by NumPy having global `known_dtype` mapping basically.  The reason we need something in any case, is to support:\r\n```\r\nnp.array([user_scalar])\r\n```\r\nwithout explicitly passing a `dtype=`, which I would like to support.",
        "createdAt" : "2020-10-04T18:55:55Z",
        "updatedAt" : "2020-10-04T19:36:11Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "ad0685b5-9006-4044-86be-0eb7497bf07a",
        "parentId" : "809f0cd4-a748-4177-afc9-f220b67e8fb6",
        "authorId" : "0354b9b7-8a89-4c8d-85d2-b0f4bcddce0a",
        "body" : "Ah I see. Maybe I should include both examples then.",
        "createdAt" : "2020-10-04T19:05:12Z",
        "updatedAt" : "2020-10-04T19:36:11Z",
        "lastEditedBy" : "0354b9b7-8a89-4c8d-85d2-b0f4bcddce0a",
        "tags" : [
        ]
      },
      {
        "id" : "dec49f3b-4c8f-4ab5-aa4e-a72503e15745",
        "parentId" : "809f0cd4-a748-4177-afc9-f220b67e8fb6",
        "authorId" : "0354b9b7-8a89-4c8d-85d2-b0f4bcddce0a",
        "body" : "Update here https://github.com/numpy/numpy/pull/17447/commits/c564fcb12789b4bc43cc86cc858be0e886824051#diff-89eb8c11ba758f8d3a296f44372c3254R293 for user-defined scalar types. AFAICT supporting `np.dtype[UserScalar]` mapping to `UserDtype` will require adding a single overload inside the NumPy stubs, which seems ok since we'll already have the `known_dtype` mapping. LMK if you see a way around that though.",
        "createdAt" : "2020-10-04T19:38:42Z",
        "updatedAt" : "2020-10-04T19:38:42Z",
        "lastEditedBy" : "0354b9b7-8a89-4c8d-85d2-b0f4bcddce0a",
        "tags" : [
        ]
      },
      {
        "id" : "a5733468-35d1-4fca-9bdf-b9ad214fcb18",
        "parentId" : "809f0cd4-a748-4177-afc9-f220b67e8fb6",
        "authorId" : "ebbd559e-4e98-4695-a417-e4a6bc303d63",
        "body" : "> AFAICT supporting `np.dtype[UserScalar]` mapping to `UserDtype` will require adding a single overload inside the NumPy stubs, which seems ok since we'll already have the `known_dtype` mapping.\r\n\r\nSounds good to me, though lets wait with this a bit until NEP 42 is implemented.",
        "createdAt" : "2020-10-04T20:03:25Z",
        "updatedAt" : "2020-10-04T20:03:26Z",
        "lastEditedBy" : "ebbd559e-4e98-4695-a417-e4a6bc303d63",
        "tags" : [
        ]
      },
      {
        "id" : "a563a449-1833-44f7-866a-63d7afff4e49",
        "parentId" : "809f0cd4-a748-4177-afc9-f220b67e8fb6",
        "authorId" : "ebbd559e-4e98-4695-a417-e4a6bc303d63",
        "body" : "> it will work for DTypes requesting it (not necessarily for all DTypes). And in that case it will work by NumPy having global known_dtype mapping basically. The reason we need something in any case, is to support:\r\n> ``` python\r\n> np.array([user_scalar])\r\n> ```\r\n> without explicitly passing a dtype=, which I would like to support.\r\n\r\nJust a word of warning: I doubt we'll be able to describe such dynamic behavior with static typing.\r\nDepending on how the overloads will be structured the dtype will probably inferred as either \r\n`dtype[np.object_]` or `dtype[typing.Any]`.\r\n\r\nIt's different story if the dtype is explicitly specified  (`np.array([user_scalar], dtype=UserDType`), \r\nthen things will be quite simple.",
        "createdAt" : "2020-10-04T20:12:58Z",
        "updatedAt" : "2020-10-04T20:12:59Z",
        "lastEditedBy" : "ebbd559e-4e98-4695-a417-e4a6bc303d63",
        "tags" : [
        ]
      },
      {
        "id" : "12339da7-6f56-4cb0-b1de-1efcf3550103",
        "parentId" : "809f0cd4-a748-4177-afc9-f220b67e8fb6",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "@BvB93, I believe you that describing it will be difficult and I do hope that most  user-dtypes will rely more on explicitly passing it. It would be an interesting question whether we can get away with not allowing auto-discovery, but the fact is that currently user-dtypes pretty much always explicitly subclass `np.generic` and honestly the only reason why they have to (aside from copy pasting the `rational` code), is exactly this auto-discovery during coercion.\r\n\r\nJust read through these changes and they look good to me, thanks everyone! I am tempted to merge soon, or is there anything left to discuss?",
        "createdAt" : "2020-10-05T21:26:39Z",
        "updatedAt" : "2020-10-05T21:26:40Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "ab7bb195-6e62-4f0c-b38d-857a112b3ddf",
        "parentId" : "809f0cd4-a748-4177-afc9-f220b67e8fb6",
        "authorId" : "0354b9b7-8a89-4c8d-85d2-b0f4bcddce0a",
        "body" : "> I am tempted to merge soon, or is there anything left to discuss?\r\n\r\nWe're good on my end.\r\n\r\n> It's different story if the dtype is explicitly specified\r\n\r\nWe can also do something in the case of\r\n\r\n```python\r\nx: ArrayLike[UserDtype] = [user_scalar]\r\nnp.array(x)  # Can get ndarray[UserDtype] now\r\n```\r\n\r\nwhich hopefully gives users some reasonable options.",
        "createdAt" : "2020-10-06T03:43:02Z",
        "updatedAt" : "2020-10-06T03:43:03Z",
        "lastEditedBy" : "0354b9b7-8a89-4c8d-85d2-b0f4bcddce0a",
        "tags" : [
        ]
      },
      {
        "id" : "e64cfc22-463e-4bd7-b7a3-64d3d7143b34",
        "parentId" : "809f0cd4-a748-4177-afc9-f220b67e8fb6",
        "authorId" : "ebbd559e-4e98-4695-a417-e4a6bc303d63",
        "body" : "> It would be an interesting question whether we can get away with not allowing auto-discovery, but the fact is that currently user-dtypes pretty much always explicitly subclass `np.generic` and honestly the only reason why they have to (aside from copy pasting the `rational` code), is exactly this auto-discovery during coercion.\r\n\r\nTrue, _if_ a user-dtype is based on a `np.generic` generic subclass then the type checks will work right out of the box. Thing will only become tricky (from a static typing perspective at least) when this doesn't happen.\r\n\r\n~~Come to think of it, reflecting this in the example would probably be a good idea (_i.e._ make `UserScalar` a `np.generic` subclass).~~",
        "createdAt" : "2020-10-06T10:22:08Z",
        "updatedAt" : "2020-10-06T15:46:31Z",
        "lastEditedBy" : "ebbd559e-4e98-4695-a417-e4a6bc303d63",
        "tags" : [
        ]
      },
      {
        "id" : "4015dd72-75f4-4e8f-ba5b-e1cb397f8a61",
        "parentId" : "809f0cd4-a748-4177-afc9-f220b67e8fb6",
        "authorId" : "0354b9b7-8a89-4c8d-85d2-b0f4bcddce0a",
        "body" : "Isn’t it already a subclass in the example? (I meant for it to be.)",
        "createdAt" : "2020-10-06T13:52:19Z",
        "updatedAt" : "2020-10-06T13:52:20Z",
        "lastEditedBy" : "0354b9b7-8a89-4c8d-85d2-b0f4bcddce0a",
        "tags" : [
        ]
      },
      {
        "id" : "7d2d2885-ff3c-4cc2-8484-8a01d598213e",
        "parentId" : "809f0cd4-a748-4177-afc9-f220b67e8fb6",
        "authorId" : "ebbd559e-4e98-4695-a417-e4a6bc303d63",
        "body" : "I was specifically talking about the suggestion in https://github.com/numpy/numpy/pull/17447#discussion_r499269308.",
        "createdAt" : "2020-10-06T13:53:41Z",
        "updatedAt" : "2020-10-06T13:53:41Z",
        "lastEditedBy" : "ebbd559e-4e98-4695-a417-e4a6bc303d63",
        "tags" : [
        ]
      },
      {
        "id" : "55e67d11-8791-4e30-9eb0-c4cc296e8a19",
        "parentId" : "809f0cd4-a748-4177-afc9-f220b67e8fb6",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "It does say \"generic\" currently.  Further down, I say \"Scalars will be expected to derive from a NumPy scalar\", but honestly, I am not sure we need to stick with it. I do not see a huge advantage, because I do not believe in \"inheriting\" the `dtype` attributes.  When you inherit it, you mix up contra and covariance for a container and AFAIK that just doesn't work.\r\n\r\nThe reason for saying \"from a NumPy scalar\", is because I do not like `np.generic`. It comes with expectations on memory layout on the NumPy side and quite frankly I don't want to use it. When we reach this stage, I would rather consider creating a `np.generic` baseclass without all of those expectations.\r\n\r\nDoes subclassing even help with typing? It seems like there is a solution that will always work and it also seems to me like users will always have to define this once for runtime and once for static typing.",
        "createdAt" : "2020-10-06T14:59:38Z",
        "updatedAt" : "2020-10-06T14:59:39Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "38871f09-bb71-41a2-9d4a-63e00f9c607d",
        "parentId" : "809f0cd4-a748-4177-afc9-f220b67e8fb6",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Or from a different angle: Does subclassing really matter, as opposed to what is pretty much equivalent to an ABC you can register with?",
        "createdAt" : "2020-10-06T15:14:33Z",
        "updatedAt" : "2020-10-06T15:14:34Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "6e78ed87-680f-41c9-8b1d-7177a0f01905",
        "parentId" : "809f0cd4-a748-4177-afc9-f220b67e8fb6",
        "authorId" : "ebbd559e-4e98-4695-a417-e4a6bc303d63",
        "body" : "> Or from a different angle: Does subclassing really matter, as opposed to what is pretty much equivalent to an ABC you can register with?\r\n\r\nFor static typing the only important thing is that there is _some_ common baseclass or protocol for automatically annotating the likes of `np.array([user_scalar])`. \r\nExactly _how_ this is accomplished doesn't really matter (well, like you said, it might matter a lot during runtime...):\r\n* Directly subclassing `np.generic`.\r\n* Adding `np.generic` as a superclass only during type checking.\r\n* Adding a new ABC (which may or may not be available at runtime).\r\n* Adding a new protocol (which, again, may or may not be available at runtime).\r\n* _etc..._\r\n\r\n> When we reach this stage, I would rather consider creating a `np.generic` baseclass without all of those expectations.\r\n\r\n+1 to this suggestion!",
        "createdAt" : "2020-10-06T15:47:15Z",
        "updatedAt" : "2020-10-06T15:47:15Z",
        "lastEditedBy" : "ebbd559e-4e98-4695-a417-e4a6bc303d63",
        "tags" : [
        ]
      }
    ],
    "commit" : "c564fcb12789b4bc43cc86cc858be0e886824051",
    "line" : 39,
    "diffHunk" : "@@ -1,1 +288,292 @@user-defined DType::\n\n    class UserDtype(dtype): ...\n\none can do ``np.ndarray[UserDtype]``, keeping annotations concise in"
  },
  {
    "id" : "cc584740-ee51-41ca-9ab0-2fcd65b94d0d",
    "prId" : 17447,
    "prUrl" : "https://github.com/numpy/numpy/pull/17447#pullrequestreview-501649454",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6dfbd968-dd6c-431a-b031-dec13336ce5e",
        "parentId" : null,
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Good point including it in `numpy.typing`, might have to do this sooner rather than later to make solving the pickling issue simpler.",
        "createdAt" : "2020-10-04T18:53:40Z",
        "updatedAt" : "2020-10-04T19:36:11Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      }
    ],
    "commit" : "c564fcb12789b4bc43cc86cc858be0e886824051",
    "line" : 35,
    "diffHunk" : "@@ -1,1 +284,288 @@    Float64 = np.dtype[np.float64]\n\nin ``numpy.typing``, thus keeping annotations concise but still\navoiding crowding the ``np`` namespace as discussed above. For a\nuser-defined DType::"
  },
  {
    "id" : "7278ec6b-1965-4177-a76a-2c5acbbc9508",
    "prId" : 17920,
    "prUrl" : "https://github.com/numpy/numpy/pull/17920#pullrequestreview-546426835",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "017adbe3-0139-46ff-98fc-d10821fb0de2",
        "parentId" : null,
        "authorId" : "2bbfef14-ac5b-44ae-a2a6-925f6f5b619a",
        "body" : "It probably just doesn't show up in the diffs in this PR, but do you cover why the signature changed to include both DTypes & DTypeMeta?",
        "createdAt" : "2020-12-05T00:03:08Z",
        "updatedAt" : "2020-12-07T19:18:24Z",
        "lastEditedBy" : "2bbfef14-ac5b-44ae-a2a6-925f6f5b619a",
        "tags" : [
        ]
      },
      {
        "id" : "ca4f8920-ba8b-429c-a491-8001b9cdc7fb",
        "parentId" : "017adbe3-0139-46ff-98fc-d10821fb0de2",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "The `self` had a different meaning before, it may only be clearer in NEP 43, but I think that is fine.",
        "createdAt" : "2020-12-07T18:36:32Z",
        "updatedAt" : "2020-12-07T19:18:24Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      }
    ],
    "commit" : "9c3ac2e3bbe47624ea240fcd63fc8b921393bf99",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +204,208 @@        casting : casting\n\n        def resolve_descriptors(self, Tuple[DTypeMeta], Tuple[DType|None] : input) -> (casting, Tuple[DType]):\n            raise NotImplementedError\n"
  }
]
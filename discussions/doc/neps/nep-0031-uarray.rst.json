[
  {
    "id" : "be78b5b6-b088-4bae-873f-950dccc799ea",
    "prId" : 14389,
    "prUrl" : "https://github.com/numpy/numpy/pull/14389#pullrequestreview-283523143",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "712de288-d81e-4222-bd4f-2fdb306fabd8",
        "parentId" : null,
        "authorId" : "6637c892-b4b3-4c79-a2b7-6c2c0ea04ada",
        "body" : "What's the difference from simply ``import unumpy``? Also, I think it's very confusing that ``import numpy.overridable`` is an alias to a different top-level package with a completely different name.",
        "createdAt" : "2019-09-03T08:23:22Z",
        "updatedAt" : "2019-10-10T05:27:22Z",
        "lastEditedBy" : "6637c892-b4b3-4c79-a2b7-6c2c0ea04ada",
        "tags" : [
        ]
      },
      {
        "id" : "b547ddcd-2916-4ab7-af97-021143fe928c",
        "parentId" : "712de288-d81e-4222-bd4f-2fdb306fabd8",
        "authorId" : "48239ed9-0e9e-4f16-80c7-12419f1efd99",
        "body" : "What we're proposing here is that a completed version of `unumpy` be vendored into NumPy as `numpy.overridable`, with a soft dependency on `unumpy` in case it exists.",
        "createdAt" : "2019-09-03T08:35:02Z",
        "updatedAt" : "2019-10-10T05:27:22Z",
        "lastEditedBy" : "48239ed9-0e9e-4f16-80c7-12419f1efd99",
        "tags" : [
        ]
      },
      {
        "id" : "8be0a61a-51f0-46e9-9f6a-165fb8a3a985",
        "parentId" : "712de288-d81e-4222-bd4f-2fdb306fabd8",
        "authorId" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "body" : "then it should be explicit where this comes from and not a top-level import: `from numpy.uarray import overridable as unumpy` or even better `from numpy.uarray import unumpy`.",
        "createdAt" : "2019-09-03T09:51:33Z",
        "updatedAt" : "2019-10-10T05:27:22Z",
        "lastEditedBy" : "919d650d-5f9e-4069-90f7-968e2cf7bb16",
        "tags" : [
        ]
      },
      {
        "id" : "cc2c46fc-ab9f-4f82-b8f0-82f264e2fdbc",
        "parentId" : "712de288-d81e-4222-bd4f-2fdb306fabd8",
        "authorId" : "48239ed9-0e9e-4f16-80c7-12419f1efd99",
        "body" : "My reasoning was that people reach for `np` whenever using NumPy, so importing it as `np` keeps familiarity as the API is mirrored.",
        "createdAt" : "2019-09-03T09:54:34Z",
        "updatedAt" : "2019-10-10T05:27:22Z",
        "lastEditedBy" : "48239ed9-0e9e-4f16-80c7-12419f1efd99",
        "tags" : [
        ]
      },
      {
        "id" : "963a4a22-ed74-42e0-9256-04661d4d8520",
        "parentId" : "712de288-d81e-4222-bd4f-2fdb306fabd8",
        "authorId" : "48239ed9-0e9e-4f16-80c7-12419f1efd99",
        "body" : "I've changed the import to `from numpy import overridable as unumpy`.",
        "createdAt" : "2019-09-03T10:20:22Z",
        "updatedAt" : "2019-10-10T05:27:22Z",
        "lastEditedBy" : "48239ed9-0e9e-4f16-80c7-12419f1efd99",
        "tags" : [
        ]
      },
      {
        "id" : "f1e809cd-2b50-4083-98c7-552d91798f7d",
        "parentId" : "712de288-d81e-4222-bd4f-2fdb306fabd8",
        "authorId" : "48239ed9-0e9e-4f16-80c7-12419f1efd99",
        "body" : "> then it should be explicit where this comes from and not a top-level import: `from numpy.uarray import overridable as unumpy` or even better `from numpy.uarray import unumpy`.\r\n\r\n`unumpy` isn't a submodule of `uarray`, it's a separate module dependent on `uarray`.",
        "createdAt" : "2019-09-03T10:20:52Z",
        "updatedAt" : "2019-10-10T05:27:22Z",
        "lastEditedBy" : "48239ed9-0e9e-4f16-80c7-12419f1efd99",
        "tags" : [
        ]
      },
      {
        "id" : "854fd0a6-35ad-470c-86f7-c3acbe66ff6b",
        "parentId" : "712de288-d81e-4222-bd4f-2fdb306fabd8",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "I have difficulties really judging the technical aspects of this (which is fine, I just need to spend some real time on it, but it is probably better for developers familiar with array-like libraries to judge).\r\n\r\nMy main concern is whether `numpy.overridable` is a good idea, although maybe I am confused about `unumpy` vs. `uarray` (likely my error for not reading carefully enough).  I.e. we have to put definitions somewhere so that `uarray` can use `numpy` as a backend. If we endorse `uarray` (and I think this is what this NEP is really about) putting those definitions into numpy makes sense. What I am not clear about is why that actually changes the user facing API surface?",
        "createdAt" : "2019-09-03T16:01:22Z",
        "updatedAt" : "2019-10-10T05:27:22Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "becdcfa8-f85e-4f4d-bd08-47c8c2d836d1",
        "parentId" : "712de288-d81e-4222-bd4f-2fdb306fabd8",
        "authorId" : "48239ed9-0e9e-4f16-80c7-12419f1efd99",
        "body" : "> I have difficulties really judging the technical aspects of this (which is fine, I just need to spend some real time on it, but it is probably better for developers familiar with array-like libraries to judge).\r\n\r\nFeel free to make more concrete which parts are unclear and I'll add more detail.\r\n\r\n> My main concern is whether `numpy.overridable` is a good idea, although maybe I am confused about `unumpy` vs. `uarray` (likely my error for not reading carefully enough).\r\n\r\n`uarray` is a general override mechanism; `unumpy` is the set of definitions you speak of.\r\n\r\n> i.e. [sic] we have to put definitions somewhere so that `uarray` can use `numpy` as a backend. If we endorse `uarray` (and I think this is what this NEP is really about) putting those definitions into numpy makes sense. What I am not clear about is why that actually changes the user facing API surface?\r\n\r\nOn acceptance, `numpy.overridable` (the name can be discussed) becomes an alias to `unumpy` if available and the vendored version if not. I guess this can be made more concrete. The reason is, this way (a separate submodule), the override is opt-in for the user rather than being some magic on the function itself. It's a partial mirror of the NumPy API.",
        "createdAt" : "2019-09-03T17:23:35Z",
        "updatedAt" : "2019-10-10T05:27:23Z",
        "lastEditedBy" : "48239ed9-0e9e-4f16-80c7-12419f1efd99",
        "tags" : [
        ]
      },
      {
        "id" : "501d1fd9-88ea-49bd-b047-b7fd01320767",
        "parentId" : "712de288-d81e-4222-bd4f-2fdb306fabd8",
        "authorId" : "8ffdfffb-d8d9-40f6-9de3-dd0dee381149",
        "body" : "@seberg since we were aiming for the functionality to be opt-in (avoids some overhead and is safer, see e.g. the first reply from Nathaniel on the mailing list), there has to be a new part to the API somewhere right?\r\n\r\nOne could do this with a global switch to change the `np.<funcname>` behavior, but that's very ugly. So an explicit import with matching API seems cleanest. And there's only one thing to learn, a new import. So less mental overhead than when we're adding new functions like `asduckarray` etc.\r\n",
        "createdAt" : "2019-09-03T17:29:11Z",
        "updatedAt" : "2019-10-10T05:27:23Z",
        "lastEditedBy" : "8ffdfffb-d8d9-40f6-9de3-dd0dee381149",
        "tags" : [
        ]
      },
      {
        "id" : "7e28151e-4e70-45b3-991d-606bcc944fdb",
        "parentId" : "712de288-d81e-4222-bd4f-2fdb306fabd8",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Yes, there has to be an opt-in/new API somewhere, but what are the real advantages of having it inside numpy proper? As far as I can see:\r\n  1. `uarray` (really more general library than \"array\", which is fine) is the toolchain, a `unumpy` may want to vendor it to ensure stable API.\r\n       - If the proposal is to try import the non-vendored version, I am actually a bit less sure about that.\r\n  2. `unumpy` a reduced numpy-like API, which provides backend switching possibilities based on `uarray`.\r\n\r\nAn explicit import with matching API is of course the cleanest (and only reasonable thing). What I am missing is an argument why it should live within the numpy namespace or even within numpy at all and not just in the numpy organization (with documentation pointing it out).\r\n\r\nAlso maybe to be clear. Unlike `scipy.fft` the main target of `unumpy` I think are downstream packages such as `scikit-learn` or so, to allow them to easier support multiple array-likes with a single code base. These already have a big number of dependencies, so it is worth vendoring in the numpy namespace?",
        "createdAt" : "2019-09-03T17:48:07Z",
        "updatedAt" : "2019-10-10T05:27:23Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "eef68f1c-7f44-4cc5-830a-f5609277df19",
        "parentId" : "712de288-d81e-4222-bd4f-2fdb306fabd8",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Oh, there is actually:\r\n  3. The definitions for the `numpy` backend to `unumpy` (which maybe has to live within numpy?)",
        "createdAt" : "2019-09-03T17:49:53Z",
        "updatedAt" : "2019-10-10T05:27:23Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "f5a4a314-63e0-4677-8166-a86310260f67",
        "parentId" : "712de288-d81e-4222-bd4f-2fdb306fabd8",
        "authorId" : "48239ed9-0e9e-4f16-80c7-12419f1efd99",
        "body" : "> Oh, there is actually:\r\n> 3. The definitions for the numpy backend to unumpy (which maybe has to live within numpy?)\r\n\r\nThe backend can live as a separate package or inside `unumpy` as well, but the ideal place for it is `numpy`.",
        "createdAt" : "2019-09-03T18:01:13Z",
        "updatedAt" : "2019-10-10T05:27:23Z",
        "lastEditedBy" : "48239ed9-0e9e-4f16-80c7-12419f1efd99",
        "tags" : [
        ]
      },
      {
        "id" : "a368af25-a65d-4ed3-a99e-b984a03b5826",
        "parentId" : "712de288-d81e-4222-bd4f-2fdb306fabd8",
        "authorId" : "8ffdfffb-d8d9-40f6-9de3-dd0dee381149",
        "body" : "> These already have a big number of dependencies, so it is worth vendoring in the numpy namespace?\r\n\r\nThat's fair enough, perhaps it would be better to not vendor it. We can decide later. My main concern was that this NEP would become a discussion about adding a dependency to basically the whole scientific Python stack. Rather than about \"a unified unumpy approach vs. adding more and more one-off protocols within numpy\".\r\n\r\nSo, I'd like to have the latter discussion, and postpone the discussion on vendoring vs depending on.",
        "createdAt" : "2019-09-03T18:46:25Z",
        "updatedAt" : "2019-10-10T05:27:23Z",
        "lastEditedBy" : "8ffdfffb-d8d9-40f6-9de3-dd0dee381149",
        "tags" : [
        ]
      },
      {
        "id" : "4fec9f00-fc43-4acb-996f-4604ca1fc8d6",
        "parentId" : "712de288-d81e-4222-bd4f-2fdb306fabd8",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Sure, fair. Whether or not this can live in numpy, is not really the big deal about it, I agree. You are pointing out one thing that is currently completely missing IMO. The NEP reads as if numpy will keep spawning the need of overriding protocols. It might be worth noting that agreeing on one protocol/library (for the most part) means that it is OK if the need for new overriding protocols is not within numpy itself, but within the ecosystem.\r\n\r\nSciPy FFT already uses it, but I did not notice too much discussion on scipy (maybe I missed it). And the use case is probably quite a lot simpler.",
        "createdAt" : "2019-09-03T19:27:41Z",
        "updatedAt" : "2019-10-10T05:27:23Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "f19d004b-766c-4a00-89b5-9753b2649394",
        "parentId" : "712de288-d81e-4222-bd4f-2fdb306fabd8",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "In fact, if that is the main concern. Maybe the NEP should say so right in the abstract. That it is proposed that numpy provides `uarray` interface with `unumpy` and by doing so sets a precedence for allowing similar steps in the whole ecosystem (with `scipy.fft` basically anticipating the NEP).",
        "createdAt" : "2019-09-03T19:29:58Z",
        "updatedAt" : "2019-10-10T05:27:23Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "d2473b1c-ae43-4426-8421-51bb77fb7c17",
        "parentId" : "712de288-d81e-4222-bd4f-2fdb306fabd8",
        "authorId" : "8ffdfffb-d8d9-40f6-9de3-dd0dee381149",
        "body" : "> SciPy FFT already uses it, but I did not notice too much discussion on scipy (maybe I missed it). And the use case is probably quite a lot simpler.\r\n\r\nsimpler in some ways, but not strictly simpler. for example, there are multiple backends there that all consume numpy arrays. a protocol like `__array_function__` that's attached to the array itself cannot deal with that.\r\n\r\n> It might be worth noting that agreeing on one protocol/library (for the most part) means that it is OK if the need for new overriding protocols is not within numpy itself, but within the ecosystem.\r\n\r\nI'm not sure I got your point here. can you expand on this a bit?",
        "createdAt" : "2019-09-03T19:45:48Z",
        "updatedAt" : "2019-10-10T05:27:23Z",
        "lastEditedBy" : "8ffdfffb-d8d9-40f6-9de3-dd0dee381149",
        "tags" : [
        ]
      },
      {
        "id" : "52f7908b-4de9-4779-92cf-7f8362352c84",
        "parentId" : "712de288-d81e-4222-bd4f-2fdb306fabd8",
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "> simpler in some ways, but not strictly simpler. for example, there are multiple backends there that all consume numpy arrays. a protocol like __array_function__ that's attached to the array itself cannot deal with that.\r\n\r\nRight, it is different. I am actually very much interested in how the two would/can interact (but I already asked that a few times in the other comments I think).\r\n\r\n> I'm not sure I got your point here. can you expand on this a bit?\r\n\r\nWell, if Scipy uses this, and say scikit-learn uses `uarray` then you at least have the nice effect that library author can learn the same tool for many different things (and more users means better docs, etc.). Maybe not much of a point.",
        "createdAt" : "2019-09-03T19:53:08Z",
        "updatedAt" : "2019-10-10T05:27:23Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "3d21ddeb-94c7-4686-bda8-2143761290ee",
        "parentId" : "712de288-d81e-4222-bd4f-2fdb306fabd8",
        "authorId" : "8ffdfffb-d8d9-40f6-9de3-dd0dee381149",
        "body" : "Ah yes. Indeed, `uarray` is meant as a generic backend creation mechanism. There's not so many of those to choose from in Python land. Most backends are ad-hoc and specific to one library.",
        "createdAt" : "2019-09-03T20:10:31Z",
        "updatedAt" : "2019-10-10T05:27:23Z",
        "lastEditedBy" : "8ffdfffb-d8d9-40f6-9de3-dd0dee381149",
        "tags" : [
        ]
      },
      {
        "id" : "230c0024-c0a7-4f15-87eb-18ed048b7080",
        "parentId" : "712de288-d81e-4222-bd4f-2fdb306fabd8",
        "authorId" : "8ffdfffb-d8d9-40f6-9de3-dd0dee381149",
        "body" : "> I am actually very much interested in how the two would/can interact\r\n\r\nIt'll be nested - if there's a `unumpy` function that's also covered by `__array_ufunc__` or `__array_function__`, then those protocols will be used like normal when the `numpy` backend to `unumpy` is used. In case another backend is used (dask/sparse/etc), then of course the protocols do nothing.",
        "createdAt" : "2019-09-03T20:14:23Z",
        "updatedAt" : "2019-10-10T05:27:23Z",
        "lastEditedBy" : "8ffdfffb-d8d9-40f6-9de3-dd0dee381149",
        "tags" : [
        ]
      },
      {
        "id" : "e44a12a8-a330-49fd-943f-35ea56904fad",
        "parentId" : "712de288-d81e-4222-bd4f-2fdb306fabd8",
        "authorId" : "48239ed9-0e9e-4f16-80c7-12419f1efd99",
        "body" : "> Yes, there has to be an opt-in/new API somewhere, but what are the real advantages of having it inside numpy proper? As far as I can see:\r\n> \r\n>     1. `uarray` (really more general library than \"array\", which is fine) is the toolchain, a `unumpy` may want to vendor it to ensure stable API.\r\n>        \r\n>        * If the proposal is to try import the non-vendored version, I am actually a bit less sure about that.\r\n> \r\n>     2. `unumpy` a reduced numpy-like API, which provides backend switching possibilities based on `uarray`.\r\n> \r\n> \r\n> An explicit import with matching API is of course the cleanest (and only reasonable thing). What I am missing is an argument why it should live within the numpy namespace or even within numpy at all and not just in the numpy organization (with documentation pointing it out).\r\n> \r\n> Also maybe to be clear. Unlike `scipy.fft` the main target of `unumpy` I think are downstream packages such as `scikit-learn` or so, to allow them to easier support multiple array-likes with a single code base. These already have a big number of dependencies, so it is worth vendoring in the numpy namespace?\r\n\r\nWhile I don't mind either way, I'm +1 on moving `unumpy` into the NumPy ~~repo~~ org and +0.7 on vendoring.",
        "createdAt" : "2019-09-04T10:34:07Z",
        "updatedAt" : "2019-10-10T05:27:23Z",
        "lastEditedBy" : "48239ed9-0e9e-4f16-80c7-12419f1efd99",
        "tags" : [
        ]
      }
    ],
    "commit" : "7ad12e1d5821a3800f52f701729b3c3b39f49227",
    "line" : 236,
    "diffHunk" : "@@ -1,1 +234,238 @@\n    from numpy import overridable as unp\n    import numpy as np\n\nor::"
  },
  {
    "id" : "cdd4ebe4-cc63-4479-ac0a-fb8c3f0ea579",
    "prId" : 14389,
    "prUrl" : "https://github.com/numpy/numpy/pull/14389#pullrequestreview-282841189",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d6d0a1dc-5bfe-48a0-a31b-842f0d1a220c",
        "parentId" : null,
        "authorId" : "6637c892-b4b3-4c79-a2b7-6c2c0ea04ada",
        "body" : "Missing: CuPy, sparse",
        "createdAt" : "2019-09-03T08:25:22Z",
        "updatedAt" : "2019-10-10T05:27:22Z",
        "lastEditedBy" : "6637c892-b4b3-4c79-a2b7-6c2c0ea04ada",
        "tags" : [
        ]
      },
      {
        "id" : "55b12737-177f-4dfe-82d3-874d5f1054ae",
        "parentId" : "d6d0a1dc-5bfe-48a0-a31b-842f0d1a220c",
        "authorId" : "48239ed9-0e9e-4f16-80c7-12419f1efd99",
        "body" : "It's above in \"existing Numpy-like array implementations\". I don't believe CuPy would defer to other libraries, and while it is in the realm for PyData/Sparse, there are no plans for it currently.",
        "createdAt" : "2019-09-03T08:37:41Z",
        "updatedAt" : "2019-10-10T05:27:22Z",
        "lastEditedBy" : "48239ed9-0e9e-4f16-80c7-12419f1efd99",
        "tags" : [
        ]
      }
    ],
    "commit" : "7ad12e1d5821a3800f52f701729b3c3b39f49227",
    "line" : 383,
    "diffHunk" : "@@ -1,1 +381,385 @@* xarray: https://xarray.pydata.org/\n* TensorLy: http://tensorly.org/\n\nExisting alternate dtype implementations\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
  },
  {
    "id" : "767e9ef1-e137-40b9-8509-848c791ff65f",
    "prId" : 14389,
    "prUrl" : "https://github.com/numpy/numpy/pull/14389#pullrequestreview-283171642",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f8bbe6fb-09b2-4206-8ec5-81e3bf840c57",
        "parentId" : null,
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Well, I asked this earlier. What is the actual advantage of vendoring as opposed to making `unumpy` a numpy project and maybe vendoring `uarray` (for stability)?",
        "createdAt" : "2019-09-03T18:57:18Z",
        "updatedAt" : "2019-10-10T05:27:23Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      }
    ],
    "commit" : "7ad12e1d5821a3800f52f701729b3c3b39f49227",
    "line" : 158,
    "diffHunk" : "@@ -1,1 +156,160 @@repository/package (which we propose to vendor to avoid a hard dependency, and\nuse the separate ``unumpy`` package only if it is installed, rather than depend\non for the time being). In concrete terms, ``numpy.overridable`` becomes an\nalias for ``unumpy``, if available with a fallback to the a vendored version if\nnot. ``uarray`` and ``unumpy`` and will be developed primarily with the input"
  },
  {
    "id" : "86abf6b1-d87e-4c38-8235-34a14c114d91",
    "prId" : 14389,
    "prUrl" : "https://github.com/numpy/numpy/pull/14389#pullrequestreview-284180744",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "717cc8b1-a8bc-485d-b297-fd90ed6d42ea",
        "parentId" : null,
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "I honestly do not understand it. If `numpy.overideable` may or may not be `unumpy`, it seems might end up in a hell where it is hard to tell where a bug originates? Especially, what is the reason for \"faster changes\"? Because the numpy release cycle is too slow?",
        "createdAt" : "2019-09-03T18:59:21Z",
        "updatedAt" : "2019-10-10T05:27:23Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "4add2bc3-d00f-4f96-97f6-ca0ee83291f2",
        "parentId" : "717cc8b1-a8bc-485d-b297-fd90ed6d42ea",
        "authorId" : "48239ed9-0e9e-4f16-80c7-12419f1efd99",
        "body" : "Yes, but this could be solved by making it a separate package, as you say.",
        "createdAt" : "2019-09-04T11:24:19Z",
        "updatedAt" : "2019-10-10T05:27:23Z",
        "lastEditedBy" : "48239ed9-0e9e-4f16-80c7-12419f1efd99",
        "tags" : [
        ]
      },
      {
        "id" : "7fc481d0-769d-4993-8c14-31b04a5dc1f5",
        "parentId" : "717cc8b1-a8bc-485d-b297-fd90ed6d42ea",
        "authorId" : "48239ed9-0e9e-4f16-80c7-12419f1efd99",
        "body" : "> Because the numpy release cycle is too slow?\r\n\r\nThis, and the fact that it sometimes takes months to get something into NumPy.",
        "createdAt" : "2019-09-05T11:11:59Z",
        "updatedAt" : "2019-10-10T05:27:23Z",
        "lastEditedBy" : "48239ed9-0e9e-4f16-80c7-12419f1efd99",
        "tags" : [
        ]
      }
    ],
    "commit" : "7ad12e1d5821a3800f52f701729b3c3b39f49227",
    "line" : 170,
    "diffHunk" : "@@ -1,1 +168,172 @@  rather than breakages happening when it is least expected.\n  In simple terms, bugs in ``unumpy`` mean that ``numpy`` remains\n  unaffected.\n* For ``numpy.fft``, ``numpy.linalg`` and ``numpy.random``, the functions in\n  the main namespace will mirror those in the ``numpy.overridable`` namespace."
  },
  {
    "id" : "b7561937-32a1-48bb-9b9c-ca376487018a",
    "prId" : 14389,
    "prUrl" : "https://github.com/numpy/numpy/pull/14389#pullrequestreview-284187395",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2dd8cd75-f8a5-48a4-98f2-df8d97ebeb1c",
        "parentId" : null,
        "authorId" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "body" : "Can you expand on this with an example? I have a faint idea, but I am not sure how far this can/should go.",
        "createdAt" : "2019-09-03T19:11:59Z",
        "updatedAt" : "2019-10-10T05:27:23Z",
        "lastEditedBy" : "b0342685-bd89-441f-a04f-0e75db24c07f",
        "tags" : [
        ]
      },
      {
        "id" : "311ad820-a4be-4788-8c5b-e5b94a6ae9fa",
        "parentId" : "2dd8cd75-f8a5-48a4-98f2-df8d97ebeb1c",
        "authorId" : "48239ed9-0e9e-4f16-80c7-12419f1efd99",
        "body" : "See https://github.com/numpy/numpy/pull/14389#discussion_r320843228.",
        "createdAt" : "2019-09-05T11:25:31Z",
        "updatedAt" : "2019-10-10T05:27:23Z",
        "lastEditedBy" : "48239ed9-0e9e-4f16-80c7-12419f1efd99",
        "tags" : [
        ]
      }
    ],
    "commit" : "7ad12e1d5821a3800f52f701729b3c3b39f49227",
    "line" : 219,
    "diffHunk" : "@@ -1,1 +217,221 @@``coerce`` keyword in ``ua.set_backend``), and a protocol\nfor coercing not only arrays, but also ``dtype`` objects and ``ufunc`` objects\nwith similar ones from other libraries. This is due to the existence of actual,\nthird party dtype packages, and their desire to blend into the NumPy ecosystem\n(see [6]_). This is a separate issue compared to the C-level dtype redesign"
  }
]
[
  {
    "id" : "75f583b3-b3a0-4613-b179-73f5e8a3061a",
    "prId" : 116,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d7e55d88-4e1b-4e75-b27e-142e10b4ff23",
        "parentId" : null,
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "It might be simpler if copying the mask could be specified when making the view, something like a 'copymask' keyword.\n",
        "createdAt" : "2011-07-20T02:07:32Z",
        "updatedAt" : "2011-07-26T17:12:40Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      },
      {
        "id" : "5c1130ba-ff01-4c21-8595-8cdcb2f20c2f",
        "parentId" : "d7e55d88-4e1b-4e75-b27e-142e10b4ff23",
        "authorId" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "body" : "Nevermind, I see this is done below.\n",
        "createdAt" : "2011-07-20T02:08:20Z",
        "updatedAt" : "2011-07-26T17:12:40Z",
        "lastEditedBy" : "e6b1ca39-8ea5-45f7-ae52-a080cee1181b",
        "tags" : [
        ]
      }
    ],
    "commit" : "affea42d886e8233fdd6f3c5760708e3a9e9b1b8",
    "line" : 66,
    "diffHunk" : "@@ -1,1 +360,364 @@Second is 'arr.flags.ownmaskna', which is True if the array owns the\nmemory to the mask, and False if the array has no mask, or has a view\ninto the mask of another array. If this is set to False in a masked\narray, the array will create a copy of the mask so that further modifications\nto the mask will not affect the array being viewed."
  },
  {
    "id" : "ed3b6e1b-0f8d-4fdb-a1a5-a2065690d2af",
    "prId" : 116,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a40ba3d2-305e-4a91-bf48-5ee3af742c17",
        "parentId" : null,
        "authorId" : "9c86ea93-1d07-4f8a-8e79-89bd24009be8",
        "body" : "Just to clarify, the implication here is not to mix masked and bit-patterns? Consider the following:\n\n...\n\n> > > a = np.array([np.NA, 2, 5], maskna=True)\n> > > b = np.array([1, np.NA, 7], dtype='NA')\n> > > a + b\n> > > ...\n> > > What should be the result?  Now, let's say that -- somehow -- resulting array retains the distinction between the masked-NA and the bit-pattern NA. And the user wants to skip masked-NA values, but not skip bitpattern-NA values.  I don't see how that is going to be possible in the current framework.  Note, I am not saying that it should be possible, I am just raising a possible future issue with maintaining the distinction between bitpattern-NA and masked NA.\n",
        "createdAt" : "2011-07-20T15:40:28Z",
        "updatedAt" : "2011-07-26T17:12:40Z",
        "lastEditedBy" : "9c86ea93-1d07-4f8a-8e79-89bd24009be8",
        "tags" : [
        ]
      },
      {
        "id" : "6af82556-3d52-4828-b07a-4b985d13d015",
        "parentId" : "a40ba3d2-305e-4a91-bf48-5ee3af742c17",
        "authorId" : "95359633-f0b0-4899-8e46-e2146fd11511",
        "body" : "That's correct, it isn't about mixing masks and bitpatterns, its about having multiple distinct NAs in both masks and bitpatterns. The NEP makes no distinction between bitpattern-NA and masked NA with regard to computations, however the multi-NA idea would allow a user to distinguish between them by using different multi-NA payloads.\n",
        "createdAt" : "2011-07-20T15:47:33Z",
        "updatedAt" : "2011-07-26T17:12:40Z",
        "lastEditedBy" : "95359633-f0b0-4899-8e46-e2146fd11511",
        "tags" : [
        ]
      }
    ],
    "commit" : "affea42d886e8233fdd6f3c5760708e3a9e9b1b8",
    "line" : null,
    "diffHunk" : "@@ -1,1 +632,636 @@    >>> b = np.array([np.NA, 2, 5], maskna=True)\n    >>> a + b\n    array([NA(0), 5, NA(2)], maskna='multi')\n\nThe design of this NEP does not distinguish between NAs that come"
  }
]
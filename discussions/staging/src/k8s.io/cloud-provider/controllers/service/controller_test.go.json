[
  {
    "id" : "8158063f-5c08-4472-bde3-cfe1ddcea645",
    "prId" : 98774,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/98774#pullrequestreview-584612295",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "91fd6e20-5b19-4a15-b898-89c2318ccdf6",
        "parentId" : null,
        "authorId" : "c1166017-761f-41df-8ad7-07e3dd792799",
        "body" : "How about a testcase where number of services is > number of workers?",
        "createdAt" : "2021-02-04T21:15:48Z",
        "updatedAt" : "2021-03-04T18:02:18Z",
        "lastEditedBy" : "c1166017-761f-41df-8ad7-07e3dd792799",
        "tags" : [
        ]
      },
      {
        "id" : "4061079c-efaa-4fc2-b298-3ec5e0626e6e",
        "parentId" : "91fd6e20-5b19-4a15-b898-89c2318ccdf6",
        "authorId" : "e83108b8-1fb2-416b-9298-d5b70c14f708",
        "body" : "okay. will add that.",
        "createdAt" : "2021-02-05T18:46:29Z",
        "updatedAt" : "2021-03-04T18:02:18Z",
        "lastEditedBy" : "e83108b8-1fb2-416b-9298-d5b70c14f708",
        "tags" : [
        ]
      }
    ],
    "commit" : "4af1f4b30bbe024e64cf69998e96cf24f659f0f4",
    "line" : 103,
    "diffHunk" : "@@ -1,1 +481,485 @@\t\t},\n\t\t{\n\t\t\tdesc: \"One service has an external load balancer and one is nil: one call.\",\n\t\t\tservices: []*v1.Service{\n\t\t\t\tnewService(\"s0\", \"234\", v1.ServiceTypeLoadBalancer),"
  },
  {
    "id" : "6baafe70-182e-4f36-8361-ca92bffe23e3",
    "prId" : 98774,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/98774#pullrequestreview-602622712",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "07480dd6-6fe0-4b87-9735-d73053b6a42f",
        "parentId" : null,
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "instead of passing \"desc\" here, let's simply opaque the (e.g. lines 511-524) into:\r\n```\r\nt.Run(desc, func(t *testing.T) {\r\n})\r\n```\r\n\r\nthen calling t.Error will be nicely handled",
        "createdAt" : "2021-03-02T09:11:17Z",
        "updatedAt" : "2021-03-04T18:02:18Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      },
      {
        "id" : "b551c991-4aaf-4bbd-9772-f9b814051d6a",
        "parentId" : "07480dd6-6fe0-4b87-9735-d73053b6a42f",
        "authorId" : "e83108b8-1fb2-416b-9298-d5b70c14f708",
        "body" : "Fixed.",
        "createdAt" : "2021-03-03T05:17:42Z",
        "updatedAt" : "2021-03-04T18:02:18Z",
        "lastEditedBy" : "e83108b8-1fb2-416b-9298-d5b70c14f708",
        "tags" : [
        ]
      },
      {
        "id" : "1dc64593-bd28-48ee-810b-24862069efc5",
        "parentId" : "07480dd6-6fe0-4b87-9735-d73053b6a42f",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "Not fully - t.Errorf() (if runt via t.Run()) will have the desc internally. So you don't need to pass desc here at all.",
        "createdAt" : "2021-03-03T08:24:43Z",
        "updatedAt" : "2021-03-04T18:02:18Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "4af1f4b30bbe024e64cf69998e96cf24f659f0f4",
    "line" : 260,
    "diffHunk" : "@@ -1,1 +635,639 @@// compareUpdateCalls compares if the same update calls were made in both left and right inputs despite the order.\nfunc compareUpdateCalls(t *testing.T, left, right []fakecloud.UpdateBalancerCall) {\n\tif len(left) != len(right) {\n\t\tt.Errorf(\"expect len(left) == len(right), but got %v != %v\", len(left), len(right))\n\t}"
  },
  {
    "id" : "5c0a7e3b-0d02-4295-8e37-c68b8871b789",
    "prId" : 98774,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/98774#pullrequestreview-603382925",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8e75195a-3a65-48f4-ae84-b9307f135eb7",
        "parentId" : null,
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "Actually - on a second though, is this really needed?\r\nCan't we just:\r\n- sort both lists\r\n- and compare using DeepEqual\r\n?",
        "createdAt" : "2021-03-03T08:23:39Z",
        "updatedAt" : "2021-03-04T18:02:18Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      },
      {
        "id" : "67d3db72-0d27-44cb-91fb-f7a940acfc31",
        "parentId" : "8e75195a-3a65-48f4-ae84-b9307f135eb7",
        "authorId" : "e83108b8-1fb2-416b-9298-d5b70c14f708",
        "body" : "Yes. That would achieve the same effect. It is just that needs to add code to implement the interfaces needed for sorting. This struct would just be used for testing. So I am not sure if that is worth it. ",
        "createdAt" : "2021-03-03T21:48:51Z",
        "updatedAt" : "2021-03-04T18:02:18Z",
        "lastEditedBy" : "e83108b8-1fb2-416b-9298-d5b70c14f708",
        "tags" : [
        ]
      }
    ],
    "commit" : "4af1f4b30bbe024e64cf69998e96cf24f659f0f4",
    "line" : 236,
    "diffHunk" : "@@ -1,1 +613,617 @@\tif len(left) != len(right) {\n\t\tt.Errorf(\"expect len(left) == len(right), but got %v != %v\", len(left), len(right))\n\t}\n\n\tmismatch := false"
  }
]
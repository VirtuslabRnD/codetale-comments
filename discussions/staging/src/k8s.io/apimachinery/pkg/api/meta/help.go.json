[
  {
    "id" : "bd7fc343-98f8-4909-ac13-d2aca8c42c4d",
    "prId" : 75570,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/75570#pullrequestreview-217792212",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4f30f040-5b82-4215-a574-ff35879ab0c9",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "defer unlock? memory allocation from map assignment could fail and panic.",
        "createdAt" : "2019-03-22T13:12:41Z",
        "updatedAt" : "2019-03-22T17:27:11Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "7c42121b-8dd8-42d2-9f6f-5c89e16040db",
        "parentId" : "4f30f040-5b82-4215-a574-ff35879ab0c9",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "defer allocates.",
        "createdAt" : "2019-03-22T14:38:33Z",
        "updatedAt" : "2019-03-22T17:27:11Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      }
    ],
    "commit" : "0489d0b1cf139253b82f73b072578073bc5616d6",
    "line" : 51,
    "diffHunk" : "@@ -1,1 +58,62 @@\n\t\t// cache only the first 1024 types\n\t\tisListCache.lock.Lock()\n\t\tif len(isListCache.byType) < 1024 {\n\t\t\tisListCache.byType[t] = ok"
  },
  {
    "id" : "e6d5cc1b-139d-4749-be32-a5f643cd84d6",
    "prId" : 75570,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/75570#pullrequestreview-219127623",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0baa014e-631c-4b40-86e9-11edf620ac9b",
        "parentId" : null,
        "authorId" : "42b1e004-4fa7-4e43-84cf-5378839b49ad",
        "body" : "It seems before acquiring the lock, we can check the length.\r\nSince there is no eviction, the length would only grow.\r\nIf the length reaches 1024, there is no need to acquire the lock.",
        "createdAt" : "2019-03-23T01:51:59Z",
        "updatedAt" : "2019-03-23T01:51:59Z",
        "lastEditedBy" : "42b1e004-4fa7-4e43-84cf-5378839b49ad",
        "tags" : [
        ]
      },
      {
        "id" : "f5b776fc-6de5-4c7d-8f63-e88fe2e487b4",
        "parentId" : "0baa014e-631c-4b40-86e9-11edf620ac9b",
        "authorId" : "42b1e004-4fa7-4e43-84cf-5378839b49ad",
        "body" : "Created #75630",
        "createdAt" : "2019-03-23T14:25:44Z",
        "updatedAt" : "2019-03-23T14:25:44Z",
        "lastEditedBy" : "42b1e004-4fa7-4e43-84cf-5378839b49ad",
        "tags" : [
        ]
      },
      {
        "id" : "3bd01fdc-e1dc-4a12-b87b-9ddd7a09b8fe",
        "parentId" : "0baa014e-631c-4b40-86e9-11edf620ac9b",
        "authorId" : "7f521a0d-2137-47c7-a390-3b4bdcffe306",
        "body" : "len() is not thread safe. I don't think you can do it.",
        "createdAt" : "2019-03-25T21:14:40Z",
        "updatedAt" : "2019-03-25T21:14:41Z",
        "lastEditedBy" : "7f521a0d-2137-47c7-a390-3b4bdcffe306",
        "tags" : [
        ]
      },
      {
        "id" : "a97e3492-85ac-4f21-8399-130c66a357bf",
        "parentId" : "0baa014e-631c-4b40-86e9-11edf620ac9b",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "you can do it inside the RLock above",
        "createdAt" : "2019-03-25T21:17:01Z",
        "updatedAt" : "2019-03-25T21:17:02Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "1d5dc5c5-d863-490b-b4a2-b90401228f4f",
        "parentId" : "0baa014e-631c-4b40-86e9-11edf620ac9b",
        "authorId" : "d4f34d8f-5341-4ac1-b8b2-5e5f11e23a5d",
        "body" : "Yes, using a RWLock first use RLock() for the len check (read) and upgrade to write lock via Lock() only for the map update.",
        "createdAt" : "2019-03-25T22:01:42Z",
        "updatedAt" : "2019-03-25T22:07:42Z",
        "lastEditedBy" : "d4f34d8f-5341-4ac1-b8b2-5e5f11e23a5d",
        "tags" : [
        ]
      },
      {
        "id" : "97e959e3-4279-44f7-8759-5d030ff73beb",
        "parentId" : "0baa014e-631c-4b40-86e9-11edf620ac9b",
        "authorId" : "42b1e004-4fa7-4e43-84cf-5378839b49ad",
        "body" : "Does go support RWLock upgrade (from read to write) ?\r\n\r\nIf not, using the read lock doesn't seem necessary.\r\nSince the length of map only increases, if the map length reaches 1024 outside the lock, it wouldn't be lower than 1024 inside the lock.",
        "createdAt" : "2019-03-25T22:09:08Z",
        "updatedAt" : "2019-03-25T22:09:08Z",
        "lastEditedBy" : "42b1e004-4fa7-4e43-84cf-5378839b49ad",
        "tags" : [
        ]
      },
      {
        "id" : "e4e011c4-5e0f-4518-a6bf-822f6954b75a",
        "parentId" : "0baa014e-631c-4b40-86e9-11edf620ac9b",
        "authorId" : "d4f34d8f-5341-4ac1-b8b2-5e5f11e23a5d",
        "body" : "I don't think we can assume that a len check on a map being unsafely concurrently updated will return a sane value (I don't think we've guaranteed it won't panic either.. might be impl dependent.), even if you're only ever growing the map size.\r\n\r\nIn go RWLock isn't directly upgradable, so we'd just RLock around the list size read, then release the RLock, and then separately Lock around the write.\r\n\r\n",
        "createdAt" : "2019-03-25T22:16:51Z",
        "updatedAt" : "2019-03-25T22:18:20Z",
        "lastEditedBy" : "d4f34d8f-5341-4ac1-b8b2-5e5f11e23a5d",
        "tags" : [
        ]
      },
      {
        "id" : "b78e857f-402b-47d0-846c-d1b3f12ba0ab",
        "parentId" : "0baa014e-631c-4b40-86e9-11edf620ac9b",
        "authorId" : "7f521a0d-2137-47c7-a390-3b4bdcffe306",
        "body" : "My comment \"len() is not thread safe. I don't think you can do it.\" was not about the code, it was about Ted's comment. Yes, if there is a RLock you can do it, but as Joe described it clearly, you cannot check the len outside of a lock hence #75630 does not work.",
        "createdAt" : "2019-03-26T19:55:44Z",
        "updatedAt" : "2019-03-26T19:55:44Z",
        "lastEditedBy" : "7f521a0d-2137-47c7-a390-3b4bdcffe306",
        "tags" : [
        ]
      },
      {
        "id" : "df489fae-8f0d-44d5-b9a9-06922ca93c1e",
        "parentId" : "0baa014e-631c-4b40-86e9-11edf620ac9b",
        "authorId" : "42b1e004-4fa7-4e43-84cf-5378839b49ad",
        "body" : "That was closed.\r\n\r\nPlease take a look at #75702",
        "createdAt" : "2019-03-26T19:59:24Z",
        "updatedAt" : "2019-03-26T19:59:24Z",
        "lastEditedBy" : "42b1e004-4fa7-4e43-84cf-5378839b49ad",
        "tags" : [
        ]
      }
    ],
    "commit" : "0489d0b1cf139253b82f73b072578073bc5616d6",
    "line" : 52,
    "diffHunk" : "@@ -1,1 +59,63 @@\t\t// cache only the first 1024 types\n\t\tisListCache.lock.Lock()\n\t\tif len(isListCache.byType) < 1024 {\n\t\t\tisListCache.byType[t] = ok\n\t\t}"
  },
  {
    "id" : "7fccb573-b375-482e-9d63-21af20ef8390",
    "prId" : 44983,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/44983#pullrequestreview-34996970",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "64b6270e-d522-4991-84cc-d92db47233d9",
        "parentId" : null,
        "authorId" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "body" : "Explained here: https://github.com/kubernetes/kubernetes/pull/44523#discussion_r113587700",
        "createdAt" : "2017-04-27T00:46:53Z",
        "updatedAt" : "2017-04-27T16:44:51Z",
        "lastEditedBy" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "tags" : [
        ]
      }
    ],
    "commit" : "958903509c29fdfe216c0bbf0abce1ce0abd59a6",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +176,180 @@\tfor i := range objects {\n\t\tdest := slice.Index(i)\n\t\tif dest.Type() == reflect.TypeOf(runtime.RawExtension{}) {\n\t\t\tdest = dest.FieldByName(\"Object\")\n\t\t}"
  }
]
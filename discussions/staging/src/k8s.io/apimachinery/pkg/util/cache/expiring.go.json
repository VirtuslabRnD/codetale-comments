[
  {
    "id" : "625c28fd-b89f-432c-bec5-129dcfc8bdc0",
    "prId" : 84424,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/84424#pullrequestreview-316488046",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9bd68772-dc32-4287-8b00-ef0d235d96c1",
        "parentId" : null,
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "nit: I like to capture this sort of thing in a function to make sure an increment is always paired with a use.",
        "createdAt" : "2019-11-11T22:19:50Z",
        "updatedAt" : "2019-11-14T21:50:36Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "c4b13411-8d80-4d31-82ad-c3b974c3018c",
        "parentId" : "9bd68772-dc32-4287-8b00-ef0d235d96c1",
        "authorId" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "body" : "Can you explain a bit more?",
        "createdAt" : "2019-11-12T00:33:16Z",
        "updatedAt" : "2019-11-14T21:50:36Z",
        "lastEditedBy" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "tags" : [
        ]
      },
      {
        "id" : "32b40fef-f165-44d5-af48-939e47dbeb23",
        "parentId" : "9bd68772-dc32-4287-8b00-ef0d235d96c1",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "E.g.\r\n\r\n```go\r\nfunc (c *Expiring) nextGenerationLocked() int64 {\r\n  g := c.generation\r\n  c.generation++\r\n  return g\r\n}\r\n```\r\n\r\nIn this case it's optional since a) you're actually tracking the last value given rather than the next value to be used (which I hadn't realized when I wrote that comment) and b) this is the only place that needs to consume a generation.",
        "createdAt" : "2019-11-13T19:13:00Z",
        "updatedAt" : "2019-11-14T21:50:36Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      }
    ],
    "commit" : "3f194d5b413daeba93063f4610b9951069eaf13c",
    "line" : 90,
    "diffHunk" : "@@ -1,1 +88,92 @@\tdefer c.mu.Unlock()\n\n\tc.generation++\n\n\tc.cache[key] = entry{"
  },
  {
    "id" : "7689e917-ee56-4a6c-9d71-b014352369fd",
    "prId" : 84424,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/84424#pullrequestreview-316485808",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fbb6cc8e-1a9e-47e9-aafd-bba188e330ad",
        "parentId" : null,
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "Repeated sets for the same key will make a lot of entries in this list. We should document that callers shouldn't do that often, or we should fix it (by e.g. having the entry store a pointer to the heap entry).",
        "createdAt" : "2019-11-11T23:17:33Z",
        "updatedAt" : "2019-11-14T21:50:36Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "4555111b-c825-4319-be07-baec18786a4a",
        "parentId" : "fbb6cc8e-1a9e-47e9-aafd-bba188e330ad",
        "authorId" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "body" : "This is not so easy with a heap since we need an index to modify then fix. I'd be happy with just documenting for now.",
        "createdAt" : "2019-11-13T03:42:14Z",
        "updatedAt" : "2019-11-14T21:50:36Z",
        "lastEditedBy" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "tags" : [
        ]
      },
      {
        "id" : "1f198c20-a5f6-4684-88ab-5821c5463b79",
        "parentId" : "fbb6cc8e-1a9e-47e9-aafd-bba188e330ad",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "Yeah, that's true. You'd have to do this differently. Hm.",
        "createdAt" : "2019-11-13T19:09:27Z",
        "updatedAt" : "2019-11-14T21:50:36Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      }
    ],
    "commit" : "3f194d5b413daeba93063f4610b9951069eaf13c",
    "line" : 98,
    "diffHunk" : "@@ -1,1 +96,100 @@\t}\n\n\theap.Push(&c.heap, &expiringHeapEntry{\n\t\tkey:        key,\n\t\tgeneration: c.generation,"
  },
  {
    "id" : "6aeeb4f2-f75d-4dc8-89e8-ef87ec33d96a",
    "prId" : 84424,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/84424#pullrequestreview-315976833",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6fe67c0d-c25b-4532-aa23-ba0f2d8b4cce",
        "parentId" : null,
        "authorId" : "e58080d6-2177-419f-a546-b51075d7bcb8",
        "body" : "nit: type assertion to heap interface serves as nice \"doc\"",
        "createdAt" : "2019-11-12T17:50:11Z",
        "updatedAt" : "2019-11-14T21:50:36Z",
        "lastEditedBy" : "e58080d6-2177-419f-a546-b51075d7bcb8",
        "tags" : [
        ]
      },
      {
        "id" : "69477279-b546-45cc-9983-9be57688d786",
        "parentId" : "6fe67c0d-c25b-4532-aa23-ba0f2d8b4cce",
        "authorId" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "body" : "Done.",
        "createdAt" : "2019-11-13T03:06:44Z",
        "updatedAt" : "2019-11-14T21:50:36Z",
        "lastEditedBy" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "tags" : [
        ]
      }
    ],
    "commit" : "3f194d5b413daeba93063f4610b9951069eaf13c",
    "line" : 184,
    "diffHunk" : "@@ -1,1 +182,186 @@// expiring cache uses this as a priority queue efficiently organize entries to\n// be garbage collected once they expire.\ntype expiringHeap []*expiringHeapEntry\n\nvar _ heap.Interface = &expiringHeap{}"
  },
  {
    "id" : "5d84f98b-b3ad-4883-9a82-1fd348408d0b",
    "prId" : 84424,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/84424#pullrequestreview-316593559",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3de57ce1-0e75-44f1-a264-3b40f9d7a5ff",
        "parentId" : null,
        "authorId" : "e58080d6-2177-419f-a546-b51075d7bcb8",
        "body" : "This never shrinks the underlying array right?  If so, that could be something to handle in `gc` method.",
        "createdAt" : "2019-11-12T17:54:54Z",
        "updatedAt" : "2019-11-14T21:50:36Z",
        "lastEditedBy" : "e58080d6-2177-419f-a546-b51075d7bcb8",
        "tags" : [
        ]
      },
      {
        "id" : "0cc708c7-9fa4-433a-ae0b-bc36bb692ec5",
        "parentId" : "3de57ce1-0e75-44f1-a264-3b40f9d7a5ff",
        "authorId" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "body" : "Given that these are pointers (so 8 bytes), I'm not particularly concerned. We can store a million in 8MB and the scheme is simple and once it warms up, we don't need to do any allocations here. WDYT?",
        "createdAt" : "2019-11-13T02:56:31Z",
        "updatedAt" : "2019-11-14T21:50:36Z",
        "lastEditedBy" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "tags" : [
        ]
      },
      {
        "id" : "7aa5ae8c-cce1-457d-8f7c-52bb161f2416",
        "parentId" : "3de57ce1-0e75-44f1-a264-3b40f9d7a5ff",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "I think we'll have bigger problems if this cache gets big enough for this to be a problem.",
        "createdAt" : "2019-11-13T17:17:41Z",
        "updatedAt" : "2019-11-14T21:50:36Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "b7566def-d2b7-4c0c-88f5-90f67e78f9ab",
        "parentId" : "3de57ce1-0e75-44f1-a264-3b40f9d7a5ff",
        "authorId" : "e58080d6-2177-419f-a546-b51075d7bcb8",
        "body" : "Ah yeah I had not considered the fact that the pointers do not take up much space.  I think we can ignore the size of the underlying array.\r\n\r\nDo we need to explicitly do a `(*cq)[cq.Len()-1] = nil` to make sure the value can be gc'd?",
        "createdAt" : "2019-11-13T22:12:26Z",
        "updatedAt" : "2019-11-14T21:50:36Z",
        "lastEditedBy" : "e58080d6-2177-419f-a546-b51075d7bcb8",
        "tags" : [
        ]
      }
    ],
    "commit" : "3f194d5b413daeba93063f4610b9951069eaf13c",
    "line" : 206,
    "diffHunk" : "@@ -1,1 +204,208 @@func (cq *expiringHeap) Pop() interface{} {\n\tc := (*cq)[cq.Len()-1]\n\t*cq = (*cq)[:cq.Len()-1]\n\treturn c\n}"
  },
  {
    "id" : "a0a36487-3f6f-43cf-9584-0c42f4b276ba",
    "prId" : 84424,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/84424#pullrequestreview-315976795",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b7cb2e20-e255-45ec-a191-f5a8b310d294",
        "parentId" : null,
        "authorId" : "e58080d6-2177-419f-a546-b51075d7bcb8",
        "body" : "Comment about how the heap is ordered might add some clarity",
        "createdAt" : "2019-11-12T18:11:56Z",
        "updatedAt" : "2019-11-14T21:50:36Z",
        "lastEditedBy" : "e58080d6-2177-419f-a546-b51075d7bcb8",
        "tags" : [
        ]
      },
      {
        "id" : "d8919c5e-689e-4662-b57d-e90ad023f8b8",
        "parentId" : "b7cb2e20-e255-45ec-a191-f5a8b310d294",
        "authorId" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "body" : "Done.",
        "createdAt" : "2019-11-13T03:06:34Z",
        "updatedAt" : "2019-11-14T21:50:36Z",
        "lastEditedBy" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "tags" : [
        ]
      }
    ],
    "commit" : "3f194d5b413daeba93063f4610b9951069eaf13c",
    "line" : 184,
    "diffHunk" : "@@ -1,1 +182,186 @@// expiring cache uses this as a priority queue efficiently organize entries to\n// be garbage collected once they expire.\ntype expiringHeap []*expiringHeapEntry\n\nvar _ heap.Interface = &expiringHeap{}"
  },
  {
    "id" : "f76b1266-4838-4a7a-b8a5-24b124ff96f7",
    "prId" : 84424,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/84424#pullrequestreview-317123711",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "28367c5a-f57a-4860-9bcd-0dc04558c748",
        "parentId" : null,
        "authorId" : "e58080d6-2177-419f-a546-b51075d7bcb8",
        "body" : "Seems a bit often?",
        "createdAt" : "2019-11-12T18:12:14Z",
        "updatedAt" : "2019-11-14T21:50:36Z",
        "lastEditedBy" : "e58080d6-2177-419f-a546-b51075d7bcb8",
        "tags" : [
        ]
      },
      {
        "id" : "14143c1d-a5ff-47b5-9d66-236fa7e2a641",
        "parentId" : "28367c5a-f57a-4860-9bcd-0dc04558c748",
        "authorId" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "body" : "It needs to be quick enough to push back on cache growth. It's pretty in expensive from what I can tell from the benchmarks. What are your recommendations?",
        "createdAt" : "2019-11-13T03:05:17Z",
        "updatedAt" : "2019-11-14T21:50:36Z",
        "lastEditedBy" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "tags" : [
        ]
      },
      {
        "id" : "14288b62-be13-4b53-9c4a-8d55ec3ae70a",
        "parentId" : "28367c5a-f57a-4860-9bcd-0dc04558c748",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "Doing it more frequently should reduce how much needs to be cleaned.\r\n\r\nThe worst aspect of this is that new requests are blocked during this. I guess that's why sharding helps (ideally the shards wouldn't all GC at the same exact time).\r\n\r\nIf we e.g. produced a copy of the map each time and stored it with something like sync.Value (?), I think we could permit reads to proceed 100% of the time.",
        "createdAt" : "2019-11-13T17:16:13Z",
        "updatedAt" : "2019-11-14T21:50:36Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "c216dab6-90a6-4fb9-8eb4-e02187d5ff35",
        "parentId" : "28367c5a-f57a-4860-9bcd-0dc04558c748",
        "authorId" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "body" : "That's how sync.Map is implemented but it generates *a lot* of garbage. You are pushing the work to the (go) GC. The critical improvement to this cache strategy is reduction of cache misses that we saw from insufficient LRU cache size and scanning access patterns. We haven't identified contention as a problem. Benchmarks also show that a GC iteration is cheap.",
        "createdAt" : "2019-11-13T17:55:32Z",
        "updatedAt" : "2019-11-14T21:50:36Z",
        "lastEditedBy" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "tags" : [
        ]
      },
      {
        "id" : "c36f3c2b-7ad3-4e48-8927-8ab18008283f",
        "parentId" : "28367c5a-f57a-4860-9bcd-0dc04558c748",
        "authorId" : "e58080d6-2177-419f-a546-b51075d7bcb8",
        "body" : "In my head I was thinking something like `time.Second` but without actual measurements it is hard for me to know what kind of value makes sense here.",
        "createdAt" : "2019-11-13T22:17:14Z",
        "updatedAt" : "2019-11-14T21:50:36Z",
        "lastEditedBy" : "e58080d6-2177-419f-a546-b51075d7bcb8",
        "tags" : [
        ]
      },
      {
        "id" : "c0cadfaf-1b49-427f-a53b-8c2860a5dffd",
        "parentId" : "28367c5a-f57a-4860-9bcd-0dc04558c748",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "I think we can start with 50ms; we might want to have a metric for how long the gc periods take, I'm open to any other way of measuring.\r\n\r\nSomething else that could be considered is to just run a GC iteration whenever there's a set; we've already taken the lock at that point, so we might as well do a bit of work. That would amortize the cost and keep the average size lower when there's a lot of churn. Then we could potentially reduce this frequency by a bunch; when the requests are infrequent, there won't be too much garbage to clean up.",
        "createdAt" : "2019-11-14T17:15:35Z",
        "updatedAt" : "2019-11-14T21:50:36Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      }
    ],
    "commit" : "3f194d5b413daeba93063f4610b9951069eaf13c",
    "line" : 137,
    "diffHunk" : "@@ -1,1 +135,139 @@}\n\nconst gcInterval = 50 * time.Millisecond\n\n// Run runs the GC goroutine. The goroutine exits when the passed in context is"
  },
  {
    "id" : "5dbb4e16-ddbb-4f9d-848e-ddbb8ae7e126",
    "prId" : 84424,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/84424#pullrequestreview-316592721",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "54ce0736-55a1-4f76-9fda-15c3c5c61faa",
        "parentId" : null,
        "authorId" : "e58080d6-2177-419f-a546-b51075d7bcb8",
        "body" : "I find it a bit unexpected that `Set/Delete` keeps the map consistent, but the heap grows indefinitely on `Set` and does not shrink on `Delete`.",
        "createdAt" : "2019-11-12T18:20:06Z",
        "updatedAt" : "2019-11-14T21:50:36Z",
        "lastEditedBy" : "e58080d6-2177-419f-a546-b51075d7bcb8",
        "tags" : [
        ]
      },
      {
        "id" : "cc6914c6-7528-4814-91a4-b6e684cfd4e2",
        "parentId" : "54ce0736-55a1-4f76-9fda-15c3c5c61faa",
        "authorId" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "body" : "Heap doesn't always grow on Set... it just grows until it reaches it's peak size. We can implement this with a linked list of slices but there's runtime cost and complexity. I'm not convinced that the current design is problematic.",
        "createdAt" : "2019-11-13T03:21:48Z",
        "updatedAt" : "2019-11-14T21:50:36Z",
        "lastEditedBy" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "tags" : [
        ]
      },
      {
        "id" : "5fc7b769-3cd6-410c-9c2a-6fdc8c38a639",
        "parentId" : "54ce0736-55a1-4f76-9fda-15c3c5c61faa",
        "authorId" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "body" : "Discussing in another comment thread.",
        "createdAt" : "2019-11-13T22:10:55Z",
        "updatedAt" : "2019-11-14T21:50:36Z",
        "lastEditedBy" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "tags" : [
        ]
      }
    ],
    "commit" : "3f194d5b413daeba93063f4610b9951069eaf13c",
    "line" : 106,
    "diffHunk" : "@@ -1,1 +104,108 @@\n// Delete deletes an entry in the map.\nfunc (c *Expiring) Delete(key interface{}) {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()"
  },
  {
    "id" : "ae1f7359-93b3-46dc-8fa3-44ae915866a2",
    "prId" : 84424,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/84424#pullrequestreview-315970595",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d86e6fcf-72ba-4483-85cf-7d9e8aab39ac",
        "parentId" : null,
        "authorId" : "e58080d6-2177-419f-a546-b51075d7bcb8",
        "body" : "Should delete return the deleted value (if there was one)?",
        "createdAt" : "2019-11-12T18:22:08Z",
        "updatedAt" : "2019-11-14T21:50:36Z",
        "lastEditedBy" : "e58080d6-2177-419f-a546-b51075d7bcb8",
        "tags" : [
        ]
      },
      {
        "id" : "ee46ef8b-9250-46c3-9848-f68000cadc13",
        "parentId" : "d86e6fcf-72ba-4483-85cf-7d9e8aab39ac",
        "authorId" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "body" : "I'm trying to match the map[] API so this is delete(map)",
        "createdAt" : "2019-11-13T02:41:31Z",
        "updatedAt" : "2019-11-14T21:50:36Z",
        "lastEditedBy" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "tags" : [
        ]
      }
    ],
    "commit" : "3f194d5b413daeba93063f4610b9951069eaf13c",
    "line" : 106,
    "diffHunk" : "@@ -1,1 +104,108 @@\n// Delete deletes an entry in the map.\nfunc (c *Expiring) Delete(key interface{}) {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()"
  }
]
[
  {
    "id" : "f465d5bb-e086-4064-97da-d4b3c5776f4c",
    "prId" : 75853,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/75853#pullrequestreview-221401952",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a3fe7912-9c08-4b2a-8e87-ef97f4ca2f6e",
        "parentId" : null,
        "authorId" : "09e31512-b413-47a1-bc83-20b5a77064ee",
        "body" : "I wonder if it would be worth extracting this logic somewhere, since we do the same thing in handlers/rest.go. Probably not though..   ",
        "createdAt" : "2019-04-01T23:46:16Z",
        "updatedAt" : "2019-04-05T19:50:40Z",
        "lastEditedBy" : "09e31512-b413-47a1-bc83-20b5a77064ee",
        "tags" : [
        ]
      },
      {
        "id" : "f4623f37-0ab2-4837-8239-4de05cae207a",
        "parentId" : "a3fe7912-9c08-4b2a-8e87-ef97f4ca2f6e",
        "authorId" : "695b6860-569c-4e63-a215-7342e2279a94",
        "body" : "I agree. I'm not sure on this\r\n\r\non one hand, I'd imagine extracting this logic would result in one more function call in the call stack\r\n\r\non the other hand, I guess there are more places in our code base need this logic (I was about to add the logic [here](https://github.com/kubernetes/kubernetes/blob/dd96b15e5d1de1923645ef17c05dfdfb616163bf/staging/src/k8s.io/client-go/tools/cache/reflector.go#L179) until I saw https://github.com/kubernetes/kubernetes/pull/73137#discussion_r249467406)",
        "createdAt" : "2019-04-02T00:17:59Z",
        "updatedAt" : "2019-04-05T19:50:40Z",
        "lastEditedBy" : "695b6860-569c-4e63-a215-7342e2279a94",
        "tags" : [
        ]
      }
    ],
    "commit" : "999a02ceb6476fa2dd344ce37d820884ae4674ce",
    "line" : 42,
    "diffHunk" : "@@ -1,1 +149,153 @@\t\t// Same as stdlib http server code. Manually allocate stack trace buffer size\n\t\t// to prevent excessively large logs\n\t\tconst size = 64 << 10\n\t\tstacktrace := make([]byte, size)\n\t\tstacktrace = stacktrace[:runtime.Stack(stacktrace, false)]"
  },
  {
    "id" : "6ad10999-8d05-416d-add6-d5971b28b6ab",
    "prId" : 61087,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/61087#pullrequestreview-103747929",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5ef63cf3-9cd0-49e2-9ec6-710b60031fa4",
        "parentId" : null,
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "did the time.Since semantics change?",
        "createdAt" : "2018-03-14T09:27:09Z",
        "updatedAt" : "2018-03-14T09:27:10Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      },
      {
        "id" : "05e09ed9-21cb-45e4-b8c3-51f2a026fde9",
        "parentId" : "5ef63cf3-9cd0-49e2-9ec6-710b60031fa4",
        "authorId" : "c29e1906-5f0b-4d7b-af8b-d664805e8c8e",
        "body" : "https://golang.org/pkg/time/#hdr-Monotonic_Clocks",
        "createdAt" : "2018-03-14T09:46:25Z",
        "updatedAt" : "2018-03-14T09:46:25Z",
        "lastEditedBy" : "c29e1906-5f0b-4d7b-af8b-d664805e8c8e",
        "tags" : [
        ]
      },
      {
        "id" : "3c8b5f98-69ed-48fe-888a-743186bc1ba1",
        "parentId" : "5ef63cf3-9cd0-49e2-9ec6-710b60031fa4",
        "authorId" : "c29e1906-5f0b-4d7b-af8b-d664805e8c8e",
        "body" : "golang 1.9",
        "createdAt" : "2018-03-14T09:46:33Z",
        "updatedAt" : "2018-03-14T09:46:33Z",
        "lastEditedBy" : "c29e1906-5f0b-4d7b-af8b-d664805e8c8e",
        "tags" : [
        ]
      }
    ],
    "commit" : "93aa73e4922187a3a9a78a4ff24d7d061886c137",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +129,133 @@\tdefer r.lastErrorTimeLock.Unlock()\n\td := time.Since(r.lastErrorTime)\n\tif d < r.minPeriod {\n\t\t// If the time moves backwards for any reason, do nothing\n\t\ttime.Sleep(r.minPeriod - d)"
  },
  {
    "id" : "7b0ec24d-4bc2-4e6e-a0a3-17aff44d6f68",
    "prId" : 40497,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/40497#pullrequestreview-18613234",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2e296d8e-cf69-4334-ade0-cd283fad1346",
        "parentId" : null,
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "I'm not a fan of this solution.  Other controllers use a backoff requeue mechanism in the work queue instead.  A global backoff handler for the entire process doesn't seem like a reasonable solution.",
        "createdAt" : "2017-01-26T12:35:02Z",
        "updatedAt" : "2017-01-26T20:54:37Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      },
      {
        "id" : "6097a787-563f-42fc-ae80-0490b1a54030",
        "parentId" : "2e296d8e-cf69-4334-ade0-cd283fad1346",
        "authorId" : "11efe503-096f-46dd-a8c8-28ba38a0157a",
        "body" : "Ideally, I would like to see us formalizing error handling in the controller framework. Error handling differs between controllers and this is indeed a change that affects all controllers which is not good. Most of them already use a backoff mechanism as @deads2k mentioned.",
        "createdAt" : "2017-01-26T12:48:19Z",
        "updatedAt" : "2017-01-26T20:54:37Z",
        "lastEditedBy" : "11efe503-096f-46dd-a8c8-28ba38a0157a",
        "tags" : [
        ]
      }
    ],
    "commit" : "16b7bee56db55c0d5a3101b17bfb7f99dcef3ff6",
    "line" : 18,
    "diffHunk" : "@@ -1,1 +86,90 @@var ErrorHandlers = []func(error){\n\tlogError,\n\t(&rudimentaryErrorBackoff{\n\t\tlastErrorTime: time.Now(),\n\t\t// 1ms was the number folks were able to stomach as a global rate limit."
  }
]
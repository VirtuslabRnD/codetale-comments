[
  {
    "id" : "15ff6142-00b6-4de7-91a7-f7e675d631e2",
    "prId" : 102059,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/102059#pullrequestreview-669222238",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "21a963b0-70c0-4f23-867b-88d0b499b311",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "what are the performance implications of tripling this?",
        "createdAt" : "2021-05-26T14:31:53Z",
        "updatedAt" : "2021-05-26T14:31:53Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "503ecf26-6ee9-47d7-9e7b-72b8d0fa3a8c",
        "parentId" : "21a963b0-70c0-4f23-867b-88d0b499b311",
        "authorId" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "body" : "Almost none, I was able to get tens of thousands of /proc/mounts reads per second. So... under 1 ms?",
        "createdAt" : "2021-05-26T16:03:35Z",
        "updatedAt" : "2021-05-26T16:03:35Z",
        "lastEditedBy" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "tags" : [
        ]
      }
    ],
    "commit" : "f9a04f3bc4a028e67c88ba9fbe25de99784493c3",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +33,37 @@\texpectedAtLeastNumFieldsPerMountInfo = 10\n\t// How many times to retry for a consistent read of /proc/mounts.\n\tmaxListTries = 10\n)\n"
  },
  {
    "id" : "69516e95-a491-4f15-aad0-a3b562d7a4c0",
    "prId" : 101398,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/101398#pullrequestreview-644030168",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "59bae038-3fd8-42c4-a5f3-3fc7a216485d",
        "parentId" : null,
        "authorId" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "body" : "I wonder though - if we should separate corrupted mounts from socket/host not connected errors. But may be we could consider them same. cc @chakri-nelluri \r\n",
        "createdAt" : "2021-04-23T15:05:32Z",
        "updatedAt" : "2021-04-24T12:48:46Z",
        "lastEditedBy" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "tags" : [
        ]
      },
      {
        "id" : "85d3c266-fedf-4d9d-a42f-8f8a0ac1dc73",
        "parentId" : "59bae038-3fd8-42c4-a5f3-3fc7a216485d",
        "authorId" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "body" : "When the host is down does that actually mean the mount is gone and cleaned up on the client side? Wondering if this will cause stale/leaking mounts and we need to do something like a force unmount instead.",
        "createdAt" : "2021-04-23T20:55:34Z",
        "updatedAt" : "2021-04-24T12:48:46Z",
        "lastEditedBy" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "tags" : [
        ]
      },
      {
        "id" : "c57b4597-2774-4c30-9689-1cc7961eda9c",
        "parentId" : "59bae038-3fd8-42c4-a5f3-3fc7a216485d",
        "authorId" : "e0218e0a-9e55-43f5-8929-04673eea9015",
        "body" : "Here is the way how this `host is down` mount point is unmounted in CSI driver, SMB CSI driver invoke `CleanupMountPoint` func to unmount mount point:\r\n - without this PR, `PathExists` return `false, err` directly, and then `CleanupMountPoint` returns `Warning: Unmount skipped because path does not exist` (actually do nothing)\r\n - with this PR, `PathExists` return `true, err`, and finally invoke `doCleanupMountPoint` to unmount, that will fix this issue.\r\n\r\nSo by this PR, CSI driver should unmount corrupted mount point if using `CleanupMountPoint` func.  @jingxu97 \r\n\r\nhttps://github.com/kubernetes/kubernetes/blob/ea0764452222146c47ec826977f49d7001b0ea8c/staging/src/k8s.io/mount-utils/mount_helper_common.go#L137-L147\r\nhttps://github.com/kubernetes/kubernetes/blob/ea0764452222146c47ec826977f49d7001b0ea8c/staging/src/k8s.io/mount-utils/mount_helper_common.go#L31-L41",
        "createdAt" : "2021-04-24T01:08:01Z",
        "updatedAt" : "2021-04-24T12:48:46Z",
        "lastEditedBy" : "e0218e0a-9e55-43f5-8929-04673eea9015",
        "tags" : [
        ]
      },
      {
        "id" : "0205e740-91ee-490f-9d49-fc65a7354144",
        "parentId" : "59bae038-3fd8-42c4-a5f3-3fc7a216485d",
        "authorId" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "body" : "how about Windows case? Is windows version of function can already handle this case?",
        "createdAt" : "2021-04-24T05:52:09Z",
        "updatedAt" : "2021-04-24T12:48:46Z",
        "lastEditedBy" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "tags" : [
        ]
      },
      {
        "id" : "47696105-2237-45c9-9d5e-5ab98b6ea74c",
        "parentId" : "59bae038-3fd8-42c4-a5f3-3fc7a216485d",
        "authorId" : "e0218e0a-9e55-43f5-8929-04673eea9015",
        "body" : "@jingxu97 good point, I added windows fix.\r\nWhile this specific SMB unmount issue actually does not exists on Windows since `CleanupMountPoint` on Windows just removes directly. Anyway, should also fix `IsCorruptedMnt` issue on Windows.\r\n```\r\nfunc CleanupMountPoint(m *mount.SafeFormatAndMount, target string, extensiveMountCheck bool) error {\r\n\tproxy, ok := m.Interface.(*mounter.CSIProxyMounter)\r\n\tif !ok {\r\n\t\treturn fmt.Errorf(\"could not cast to csi proxy class\")\r\n\t}\r\n\treturn proxy.Rmdir(target)\r\n}\r\n```",
        "createdAt" : "2021-04-24T12:50:50Z",
        "updatedAt" : "2021-04-24T12:50:50Z",
        "lastEditedBy" : "e0218e0a-9e55-43f5-8929-04673eea9015",
        "tags" : [
        ]
      }
    ],
    "commit" : "4dde7439e635009759b1b8d655cde6221b9716f4",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +53,57 @@\t}\n\n\treturn underlyingError == syscall.ENOTCONN || underlyingError == syscall.ESTALE || underlyingError == syscall.EIO || underlyingError == syscall.EACCES || underlyingError == syscall.EHOSTDOWN\n}\n"
  }
]
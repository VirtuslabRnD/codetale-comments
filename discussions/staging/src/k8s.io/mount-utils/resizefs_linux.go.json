[
  {
    "id" : "f3b94011-ef35-48e7-92a1-434ece26e40b",
    "prId" : 99223,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/99223#pullrequestreview-596910680",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0b7e6029-ad44-4213-aebd-60e36e71f3de",
        "parentId" : null,
        "authorId" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "body" : "We should write unit tests for all this parsing logic. ",
        "createdAt" : "2021-02-23T18:52:21Z",
        "updatedAt" : "2021-04-12T21:37:59Z",
        "lastEditedBy" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "tags" : [
        ]
      },
      {
        "id" : "f172b9e2-4b3a-4419-8245-ef4cef3c0460",
        "parentId" : "0b7e6029-ad44-4213-aebd-60e36e71f3de",
        "authorId" : "b1f34dea-361a-45e8-9713-4d6fa8164b6d",
        "body" : "updated",
        "createdAt" : "2021-02-23T23:57:08Z",
        "updatedAt" : "2021-04-12T21:37:59Z",
        "lastEditedBy" : "b1f34dea-361a-45e8-9713-4d6fa8164b6d",
        "tags" : [
        ]
      }
    ],
    "commit" : "03106a152246d3346c5c00dafd137595dfa0283d",
    "line" : 68,
    "diffHunk" : "@@ -1,1 +157,161 @@\nfunc (resizefs *ResizeFs) getExtSize(devicePath string) (uint64, uint64, error) {\n\toutput, err := resizefs.exec.Command(\"dumpe2fs\", \"-h\", devicePath).CombinedOutput()\n\tif err != nil {\n\t\treturn 0, 0, fmt.Errorf(\"failed to read size of filesystem on %s: %s: %s\", devicePath, err, string(output))"
  },
  {
    "id" : "47de8253-c733-405d-99d3-780219b5108f",
    "prId" : 99223,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/99223#pullrequestreview-596910736",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f0cdbac3-2180-43cd-8db8-92dc6eecf070",
        "parentId" : null,
        "authorId" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "body" : "same as before. We need unit tests for the parsing logic.",
        "createdAt" : "2021-02-23T18:52:41Z",
        "updatedAt" : "2021-04-12T21:37:59Z",
        "lastEditedBy" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "tags" : [
        ]
      },
      {
        "id" : "c2cf595f-5acd-4a29-9758-1fe31a53c662",
        "parentId" : "f0cdbac3-2180-43cd-8db8-92dc6eecf070",
        "authorId" : "b1f34dea-361a-45e8-9713-4d6fa8164b6d",
        "body" : "updated",
        "createdAt" : "2021-02-23T23:57:16Z",
        "updatedAt" : "2021-04-12T21:37:59Z",
        "lastEditedBy" : "b1f34dea-361a-45e8-9713-4d6fa8164b6d",
        "tags" : [
        ]
      }
    ],
    "commit" : "03106a152246d3346c5c00dafd137595dfa0283d",
    "line" : 123,
    "diffHunk" : "@@ -1,1 +212,216 @@\t\t\t\treturn 0, 0, fmt.Errorf(\"failed to parse block count %s: %s\", value, err)\n\t\t\t}\n\t\t}\n\t}\n\treturn blockSize, blockCount, err"
  },
  {
    "id" : "2160ed8b-4e3f-44df-862b-43a530f067cd",
    "prId" : 99223,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/99223#pullrequestreview-596913419",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2b923559-801e-4919-a148-466349e3c074",
        "parentId" : null,
        "authorId" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "body" : "We should ensure that if provided filesystem is something we don't know how to parse, proper error and message is returned back to the caller.",
        "createdAt" : "2021-02-23T18:54:15Z",
        "updatedAt" : "2021-04-12T21:37:59Z",
        "lastEditedBy" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "tags" : [
        ]
      },
      {
        "id" : "f5dbab85-3077-4939-927b-7e49caf35bb9",
        "parentId" : "2b923559-801e-4919-a148-466349e3c074",
        "authorId" : "b1f34dea-361a-45e8-9713-4d6fa8164b6d",
        "body" : "Updated",
        "createdAt" : "2021-02-24T00:03:05Z",
        "updatedAt" : "2021-04-12T21:37:59Z",
        "lastEditedBy" : "b1f34dea-361a-45e8-9713-4d6fa8164b6d",
        "tags" : [
        ]
      }
    ],
    "commit" : "03106a152246d3346c5c00dafd137595dfa0283d",
    "line" : 43,
    "diffHunk" : "@@ -1,1 +132,136 @@\t\tklog.Errorf(\"Not able to parse given filesystem info. fsType: %s, will not resize\", format)\n\t\treturn false, fmt.Errorf(\"Could not parse fs info on given filesystem format: %s. Supported fs types are: xfs, ext3, ext4\", format)\n\t}\n\tif err != nil {\n\t\treturn false, err"
  },
  {
    "id" : "3604b9d5-97dd-418e-b309-5d3f3e9ef4c8",
    "prId" : 99223,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/99223#pullrequestreview-603168111",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "eebfbbf5-0084-4924-be27-a96cdc0d0bb9",
        "parentId" : null,
        "authorId" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "body" : "cc @sandeen for xfs_info parsing. ",
        "createdAt" : "2021-02-24T17:37:02Z",
        "updatedAt" : "2021-04-12T21:37:59Z",
        "lastEditedBy" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "tags" : [
        ]
      },
      {
        "id" : "2c817702-2825-4bb5-8f24-40d1e3a99149",
        "parentId" : "eebfbbf5-0084-4924-be27-a96cdc0d0bb9",
        "authorId" : "9cbc2365-8d89-4c2e-b94a-a3bc51f91dc6",
        "body" : "Why not just use statfs to get the size of /any/ filesystem, instead of hard-coding and scraping individual filesystem utilities? statfs is the generic interface to query the kernel about the size of a mounted filesystem.\r\n\r\nSee statfs(2) and the -f option in statfs(1)",
        "createdAt" : "2021-02-24T20:02:01Z",
        "updatedAt" : "2021-04-12T21:37:59Z",
        "lastEditedBy" : "9cbc2365-8d89-4c2e-b94a-a3bc51f91dc6",
        "tags" : [
        ]
      },
      {
        "id" : "586fcb41-fb02-4b8b-b099-94a3e1a6111c",
        "parentId" : "eebfbbf5-0084-4924-be27-a96cdc0d0bb9",
        "authorId" : "9cbc2365-8d89-4c2e-b94a-a3bc51f91dc6",
        "body" : "Hm, well, this doesn't count the log blocks I guess. Not sure what your threshold for \"should try to grow\" is.",
        "createdAt" : "2021-02-24T20:06:14Z",
        "updatedAt" : "2021-04-12T21:37:59Z",
        "lastEditedBy" : "9cbc2365-8d89-4c2e-b94a-a3bc51f91dc6",
        "tags" : [
        ]
      },
      {
        "id" : "d6ec0d85-611a-45cf-9e3b-a826d7fa1510",
        "parentId" : "eebfbbf5-0084-4924-be27-a96cdc0d0bb9",
        "authorId" : "9cbc2365-8d89-4c2e-b94a-a3bc51f91dc6",
        "body" : "Or even just:\r\n# df -B1 --output=size /boot\r\n 1B-blocks\r\n1063256064\r\n\r\nand again this ignores space consumed by journals or other internal fs housekeeping, but it may be better to use standard APIs like statfs(2) (which is how df gets its information)",
        "createdAt" : "2021-02-24T20:32:56Z",
        "updatedAt" : "2021-04-12T21:37:59Z",
        "lastEditedBy" : "9cbc2365-8d89-4c2e-b94a-a3bc51f91dc6",
        "tags" : [
        ]
      },
      {
        "id" : "1187374c-3b46-45be-8513-0d8bee1ef98c",
        "parentId" : "eebfbbf5-0084-4924-be27-a96cdc0d0bb9",
        "authorId" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "body" : "@sandeen, I may miss something here, but IMO `statfs` shows size of the filesystem available for actual files (i.e. without journal and other FS metadata), while xfs_info shows the actual size occupied by the filesystem on a device, incl. journal, inodes, and whatnot.\r\n\r\nWe need to reliably check if we should call `resize2fs` / `xfs_growfs`, i.e. there is some extra space on the device that the filesystem does not know about.\r\n\r\n```\r\n$ df  --output=size /boot\r\n1K-blocks\r\n   999320\r\n$ dumpe2fs /dev/nvme0n1p2\r\nBlock count:              262144\r\nBlock size:               4096\r\n```\r\n999320 * 1024 = 1023303680\r\n262144 * 4096 = 1073741824\r\n\r\nThat's quite a difference.",
        "createdAt" : "2021-02-25T19:46:16Z",
        "updatedAt" : "2021-04-12T21:37:59Z",
        "lastEditedBy" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "tags" : [
        ]
      },
      {
        "id" : "40bf0d20-39b0-4525-91df-b4321eabf440",
        "parentId" : "eebfbbf5-0084-4924-be27-a96cdc0d0bb9",
        "authorId" : "9cbc2365-8d89-4c2e-b94a-a3bc51f91dc6",
        "body" : "It's < 5%, or about 58MB.\r\n\r\nSo, yes - as I mentioned it won't count filesystem overhead like the journal, or inode tables & bitmaps on ext4.\r\n\r\nWhat is your typical image size, roughly?\r\n\r\nOn a 2G filesystem image, with default mkfs, filesystem overhead is about 5% for ext4, and < 1% for xfs.  If that is \"quite a difference\" and outside your threshold, then you may be stuck with the more fragile screenscraping as proposed.\r\n\r\nOr, you could  just do:\r\n\r\n```\r\nmount\r\nstat -f\r\nif device is more than 10% bigger than free blocks\r\n    try resize2fs/xfs_growfs\r\n    # if you guessed wrong, the resize will be a no-op.\r\n```\r\nOr, just try a growfs after each initial mount, which is going to be quick and harmless if the filesystem is already maximally sized.\r\n\r\nThat way you could dispense with the screenscraping, which has a reasonable chance of breaking in the future, because admin tool text output is really not an API, and unfortunately there is not any real API to tell you exactly what the last block known to a filesystem is.",
        "createdAt" : "2021-02-25T20:04:12Z",
        "updatedAt" : "2021-04-12T21:37:59Z",
        "lastEditedBy" : "9cbc2365-8d89-4c2e-b94a-a3bc51f91dc6",
        "tags" : [
        ]
      },
      {
        "id" : "0ff9f959-3871-466a-8940-cb2acb1edf5b",
        "parentId" : "eebfbbf5-0084-4924-be27-a96cdc0d0bb9",
        "authorId" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "body" : "> just try a growfs after each initial mount, which is going to be quick and harmless if the filesystem is already maximally sized.\r\n\r\nHow safe is this for xfs and ext3/ext4? Since we will do it with every mount() and containers can move around the cluster rather quickly, we need it to be fast enough (say same as mount()?) and reliable (won't ever harm the FS, even when it gets SIGINT).\r\n\r\n> What is your typical image size, roughly?\r\n\r\nIt starts with 1 GB and goes to hundreds of GB. But I am not sure it's relevant. If user extends the volume by 1% (which can be say 1GB), we'd like the volume to be be expanded.\r\n",
        "createdAt" : "2021-02-25T20:15:07Z",
        "updatedAt" : "2021-04-12T21:37:59Z",
        "lastEditedBy" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "tags" : [
        ]
      },
      {
        "id" : "ed868184-5a17-455f-94ff-f1a146ddeeb3",
        "parentId" : "eebfbbf5-0084-4924-be27-a96cdc0d0bb9",
        "authorId" : "9cbc2365-8d89-4c2e-b94a-a3bc51f91dc6",
        "body" : "Let's chat on IRC when you get a chance, higher bandwidth than github comments might help.",
        "createdAt" : "2021-02-25T21:02:20Z",
        "updatedAt" : "2021-04-12T21:37:59Z",
        "lastEditedBy" : "9cbc2365-8d89-4c2e-b94a-a3bc51f91dc6",
        "tags" : [
        ]
      },
      {
        "id" : "24ceeb24-8c14-4fe0-8f63-b8ceee297176",
        "parentId" : "eebfbbf5-0084-4924-be27-a96cdc0d0bb9",
        "authorId" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "body" : "summary of conversation on IRC, here are the options:\r\n```\r\n<sandeen> 1) use df, and accept a small % error\r\n<sandeen> 2) scrape filesystem utilities and hope they don't change \r\n<sandeen> 3) always call resize, which would be a no-op if already maximally sized\r\n<sandeen> 4) use filesystem-specific but more well-defined APIs where they exist\r\n<sandeen> ...\r\n<sandeen> 5) wait for a common kernel solution :(\r\n```\r\n\r\nWe'd prefer 4) if available and for xfs we were able to find `xfs_io -c statfs <mount>` , which is much easier to parse. In addition, it uses [`ioctl` to get the geometry](https://man7.org/linux/man-pages/man2/ioctl_xfs_fsgeometry.2.html). @AndyXiangLi can you try `ioctl` with some interface to make unit testing possible?\r\n\r\nThere is no ioctl for ext3/4, so 2) is IMO the best option and luckily `dumpe2fs` is not that horrible to parse.",
        "createdAt" : "2021-03-02T09:03:56Z",
        "updatedAt" : "2021-04-12T21:37:59Z",
        "lastEditedBy" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "tags" : [
        ]
      },
      {
        "id" : "5bdcf4c1-fc5e-4a6b-9a15-69784848e55e",
        "parentId" : "eebfbbf5-0084-4924-be27-a96cdc0d0bb9",
        "authorId" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "body" : "Correction: is go & `ioctl` portable to ARM / PPC / s390x and other weird architectures that Kubernetes supports? If not, do not hesitate to fall back to parsing `xfs_io -c statfs`.",
        "createdAt" : "2021-03-03T17:25:06Z",
        "updatedAt" : "2021-04-12T21:37:59Z",
        "lastEditedBy" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "tags" : [
        ]
      },
      {
        "id" : "17200e99-0ab3-4f94-9a70-d85b0bf5a864",
        "parentId" : "eebfbbf5-0084-4924-be27-a96cdc0d0bb9",
        "authorId" : "9cbc2365-8d89-4c2e-b94a-a3bc51f91dc6",
        "body" : "If you parse the xfs_io output, the field you want is \"geom.datablocks\" to get the actual, complete number of all blocks on the filesytem's data device. Note that this is only available when running the xfs_io \"statfs\" command on an xfs filesystem, non-xfs filesystems will only return the basic statfs(2) information, same as df.",
        "createdAt" : "2021-03-03T17:38:10Z",
        "updatedAt" : "2021-04-12T21:37:59Z",
        "lastEditedBy" : "9cbc2365-8d89-4c2e-b94a-a3bc51f91dc6",
        "tags" : [
        ]
      }
    ],
    "commit" : "03106a152246d3346c5c00dafd137595dfa0283d",
    "line" : 106,
    "diffHunk" : "@@ -1,1 +195,199 @@\tvar err error\n\n\tfor _, line := range lines {\n\t\ttokens := strings.Split(line, spliter)\n\t\tif len(tokens) != 2 {"
  }
]
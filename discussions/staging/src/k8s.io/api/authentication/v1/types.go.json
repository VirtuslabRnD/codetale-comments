[
  {
    "id" : "a5c8a374-9ca7-47c1-bc09-aeb1548c6bcb",
    "prId" : 99961,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/99961#pullrequestreview-699895993",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "32303d89-7959-4a11-aa89-b6626be398cb",
        "parentId" : null,
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "project standard capitalizes UID.  See `GetUID` as an example: https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/apimachinery/pkg/api/meta/meta.go#L501",
        "createdAt" : "2021-07-02T17:07:02Z",
        "updatedAt" : "2021-07-02T17:07:03Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      },
      {
        "id" : "a1747b37-ed0a-4744-8e2b-faf8e2cb7daa",
        "parentId" : "32303d89-7959-4a11-aa89-b6626be398cb",
        "authorId" : "3a8e27ad-fa44-467e-8e48-0b855fe8cf01",
        "body" : "https://github.com/kubernetes/kubernetes/pull/99961#discussion_r605211372 I actually changed this earlier because it seems like the canonicalized form for headers is `Impersonate-Uid`. Should it be capitalized even in the header?",
        "createdAt" : "2021-07-02T19:12:54Z",
        "updatedAt" : "2021-07-02T19:12:54Z",
        "lastEditedBy" : "3a8e27ad-fa44-467e-8e48-0b855fe8cf01",
        "tags" : [
        ]
      },
      {
        "id" : "193d2131-e4d2-48a1-9c12-dfd183d1309e",
        "parentId" : "32303d89-7959-4a11-aa89-b6626be398cb",
        "authorId" : "e58080d6-2177-419f-a546-b51075d7bcb8",
        "body" : "[http.CanonicalHeaderKey](https://golang.org/pkg/net/http/#CanonicalHeaderKey) will force this to be `Impersonate-Uid` on incoming requests and we want to make sure that `request.Header[\"Impersonate-Uid\"]` works (`request.Header.Get(\"Impersonate-Uid\")` always works because `Get` redoes the canonicalization).  IMO this is correct as-is.\r\n\r\n```go\r\ntype Request struct {\r\n\t// Header contains the request header fields either received\r\n\t// by the server or to be sent by the client.\r\n\t//\r\n\t// If a server received a request with header lines,\r\n\t//\r\n\t//\tHost: example.com\r\n\t//\taccept-encoding: gzip, deflate\r\n\t//\tAccept-Language: en-us\r\n\t//\tfOO: Bar\r\n\t//\tfoo: two\r\n\t//\r\n\t// then\r\n\t//\r\n\t//\tHeader = map[string][]string{\r\n\t//\t\t\"Accept-Encoding\": {\"gzip, deflate\"},\r\n\t//\t\t\"Accept-Language\": {\"en-us\"},\r\n\t//\t\t\"Foo\": {\"Bar\", \"two\"},\r\n\t//\t}\r\n\t//\r\n\t// ...\r\n\t//\r\n\t// HTTP defines that header names are case-insensitive. The\r\n\t// request parser implements this by using CanonicalHeaderKey,\r\n\t// making the first character and any characters following a\r\n\t// hyphen uppercase and the rest lowercase.\r\n\t//\r\n\t// ...\r\n\tHeader Header\r\n\r\n\t// ...\r\n}\r\n```",
        "createdAt" : "2021-07-04T15:15:04Z",
        "updatedAt" : "2021-07-04T15:15:04Z",
        "lastEditedBy" : "e58080d6-2177-419f-a546-b51075d7bcb8",
        "tags" : [
        ]
      },
      {
        "id" : "742224bb-47e3-443e-a046-46184a767c93",
        "parentId" : "32303d89-7959-4a11-aa89-b6626be398cb",
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "> we want to make sure that `request.Header[\"Impersonate-Uid\"]` works\r\n\r\nEh, the only reason to do that is if you actually care about case, but ok",
        "createdAt" : "2021-07-06T12:34:20Z",
        "updatedAt" : "2021-07-06T12:34:20Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      }
    ],
    "commit" : "74f5ed6b17287100b339a2b3a43fd4c6fb200978",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +33,37 @@\n\t// ImpersonateUIDHeader is used to impersonate a particular UID during an API server request\n\tImpersonateUIDHeader = \"Impersonate-Uid\"\n\n\t// ImpersonateUserExtraHeaderPrefix is a prefix for any header used to impersonate an entry in the"
  },
  {
    "id" : "64bb94b8-f50b-45d4-841d-9f2ef6ee546e",
    "prId" : 58027,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/58027#pullrequestreview-93414897",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2831ac89-9bfc-4307-83d0-1403a8d613f5",
        "parentId" : null,
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "To jordans comment, I do think this needs to either be in v1alpha1, or v2alpha1 (technically it could be v1alpha1 since this won't cause us to rev v1 authentication)",
        "createdAt" : "2018-01-19T20:29:47Z",
        "updatedAt" : "2018-02-05T19:39:37Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "2e3a188b-6f4d-43fc-96ff-3e65df3c9455",
        "parentId" : "2831ac89-9bfc-4307-83d0-1403a8d613f5",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "this is tricky, since we're wanting a subresource in api/v1/serviceaccounts/token ... whatever surfaces there sticks forever (hence replicationcontrollers/scale being stuck at extensions/v1beta1 Scale forever)",
        "createdAt" : "2018-01-19T20:37:47Z",
        "updatedAt" : "2018-02-05T19:39:37Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "4cdfe6ee-a8cb-4763-8343-d99899be5447",
        "parentId" : "2831ac89-9bfc-4307-83d0-1403a8d613f5",
        "authorId" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "body" : "What @liggitt said. I think the best approach is to use `authentication.k8s.io/v1` and be pretty confident (e.g. by keeping the API minimal) when we move this feature from alpha to beta. We can then begin to move serviceaccount out of the main API group into `authentication.k8s.io/v2alpha1` which will give us a chance to correct any problems we encounter.",
        "createdAt" : "2018-01-19T21:02:25Z",
        "updatedAt" : "2018-02-05T19:39:37Z",
        "lastEditedBy" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "tags" : [
        ]
      },
      {
        "id" : "e0740742-9230-4f20-8d31-ab3b9d8d17c9",
        "parentId" : "2831ac89-9bfc-4307-83d0-1403a8d613f5",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "The old \"shrug, we can't solve a hard problem so we'll do the thing we tell people not to do\" approach?\r\n\r\nI agree the subresource is hard.  Maybe we should just call the subresource `alphatokenrequest` to force it to be clear, and only promote once it's beta (to `tokenrequest`).",
        "createdAt" : "2018-01-30T17:54:33Z",
        "updatedAt" : "2018-02-05T19:39:37Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "9b15d24a-9c01-41c6-b2ab-05caa5592071",
        "parentId" : "2831ac89-9bfc-4307-83d0-1403a8d613f5",
        "authorId" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "body" : "Even if we make an `/alphatoken` we can't support two versions without creating a new version of this API group and leaving v1 sparse. The `/token` subresource will be alpha feature guarded so having an `/alphatoken` path during alpha doesn't add much value unless will eventually `/token` accept a separate type and both are served simultaneously.",
        "createdAt" : "2018-01-31T22:52:05Z",
        "updatedAt" : "2018-02-05T19:39:37Z",
        "lastEditedBy" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "tags" : [
        ]
      },
      {
        "id" : "b5f72a2c-4f9c-45df-aaea-9ffbccc5281b",
        "parentId" : "2831ac89-9bfc-4307-83d0-1403a8d613f5",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Since it's behind a gate we can punt on this.",
        "createdAt" : "2018-02-01T19:51:12Z",
        "updatedAt" : "2018-02-05T19:39:37Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      }
    ],
    "commit" : "ee48da13fcddca4ad82c01f0368d1b4ef8cd460e",
    "line" : 15,
    "diffHunk" : "@@ -1,1 +110,114 @@// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object\n\n// TokenRequest requests a token for a given service account.\ntype TokenRequest struct {\n\tmetav1.TypeMeta `json:\",inline\"`"
  }
]
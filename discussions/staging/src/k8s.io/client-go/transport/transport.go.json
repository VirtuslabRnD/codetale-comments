[
  {
    "id" : "01f3f740-dd18-4e3f-b7fc-0f17984c55ad",
    "prId" : 79083,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/79083#pullrequestreview-367516972",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0cf1bd14-0fbd-467c-a568-c897e7650cac",
        "parentId" : null,
        "authorId" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "body" : "Using a regular Mutex would make this a lot simpler.:\r\n```\r\nmu.Lock()\r\ndefer mu.Unlock()\r\nif current.isStale() {\r\n  current = refresh()\r\n}\r\nreturn current\r\n```\r\n\r\nGiven this is only required on connection initiation, I doubt there'll be significant benifit from using a RWMutex here. Unlocks that aren't guarded to the scope by defers will deadlock if anything panics in the function you are calling (which has happened before in Go cert parsing).",
        "createdAt" : "2020-03-02T20:50:04Z",
        "updatedAt" : "2020-03-02T20:50:04Z",
        "lastEditedBy" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "tags" : [
        ]
      }
    ],
    "commit" : "929b1559a0b855d996257ab3ad5364605edc253d",
    "line" : 84,
    "diffHunk" : "@@ -1,1 +287,291 @@\t\tcurrentMtx.RLock()\n\t\tif current.isStale() {\n\t\t\tcurrentMtx.RUnlock()\n\n\t\t\tcurrentMtx.Lock()"
  },
  {
    "id" : "a4df4852-e0ec-4f38-a2ec-b990bd4d5b6f",
    "prId" : 71757,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/71757#pullrequestreview-182910824",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f61aed22-f1c5-4778-a10b-ca0092eda491",
        "parentId" : null,
        "authorId" : "e81e699e-eb6c-4380-bfd5-16ab81ac51d6",
        "body" : "What implements WrappedRoundTripper?",
        "createdAt" : "2018-12-06T02:11:37Z",
        "updatedAt" : "2019-08-16T17:53:58Z",
        "lastEditedBy" : "e81e699e-eb6c-4380-bfd5-16ab81ac51d6",
        "tags" : [
        ]
      },
      {
        "id" : "84ff8fdb-e6c4-48fb-9c3e-0dc55cc35a64",
        "parentId" : "f61aed22-f1c5-4778-a10b-ca0092eda491",
        "authorId" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "body" : "Many transports in the k8s codebase that do not implement cancel:\r\n\r\n```\r\nstaging/src/k8s.io/apimachinery/pkg/util/proxy/upgradeaware.go\r\n121:// WrappedRoundTripper returns the round tripper that a caller would use.\r\n122:func (rt *upgradeRequestRoundTripper) WrappedRoundTripper() http.RoundTripper {\r\n455:func (rt *corsRemovingTransport) WrappedRoundTripper() http.RoundTripper {\r\n\r\nstaging/src/k8s.io/apimachinery/pkg/util/proxy/transport.go\r\n128:func (rt *Transport) WrappedRoundTripper() http.RoundTripper {\r\n\r\nstaging/src/k8s.io/apimachinery/pkg/util/net/http.go\r\n121:    WrappedRoundTripper() http.RoundTripper\r\n146:            return DialerFor(transport.WrappedRoundTripper())\r\n167:            return TLSClientConfig(transport.WrappedRoundTripper())\r\n\r\nstaging/src/k8s.io/client-go/transport/round_trippers.go\r\n150:func (rt *authProxyRoundTripper) WrappedRoundTripper() http.RoundTripper { return rt.rt }\r\n178:func (rt *userAgentRoundTripper) WrappedRoundTripper() http.RoundTripper { return rt.rt }\r\n209:func (rt *basicAuthRoundTripper) WrappedRoundTripper() http.RoundTripper { return rt.rt }\r\n269:func (rt *impersonatingRoundTripper) WrappedRoundTripper() http.RoundTripper { return rt.delegate }\r\n328:func (rt *bearerAuthRoundTripper) WrappedRoundTripper() http.RoundTripper { return rt.rt }\r\n455:func (rt *debuggingRoundTripper) WrappedRoundTripper() http.RoundTripper {\r\n\r\nstaging/src/k8s.io/client-go/discovery/round_tripper.go\r\n62:func (rt *cacheRoundTripper) WrappedRoundTripper() http.RoundTripper { return rt.rt.Transport }\r\n\r\nstaging/src/k8s.io/client-go/plugin/pkg/client/auth/azure/azure.go\r\n144:func (r *azureRoundTripper) WrappedRoundTripper() http.RoundTripper { return r.roundTripper }\r\n\r\nstaging/src/k8s.io/client-go/plugin/pkg/client/auth/openstack/openstack.go\r\n135:func (t *tokenRoundTripper) WrappedRoundTripper() http.RoundTripper { return t.RoundTripper }\r\n\r\nstaging/src/k8s.io/client-go/plugin/pkg/client/auth/gcp/gcp.go\r\n383:func (t *conditionalTransport) WrappedRoundTripper() http.RoundTripper { return t.oauthTransport.Base }\r\n\r\nstaging/src/k8s.io/client-go/plugin/pkg/client/auth/oidc/oidc.go\r\n218:func (t *roundTripper) WrappedRoundTripper() http.RoundTripper { return t.wrapped }\r\n```",
        "createdAt" : "2018-12-06T02:41:06Z",
        "updatedAt" : "2019-08-16T17:53:58Z",
        "lastEditedBy" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "tags" : [
        ]
      },
      {
        "id" : "8ef19f11-7960-40d5-8d68-a6d567292d3c",
        "parentId" : "f61aed22-f1c5-4778-a10b-ca0092eda491",
        "authorId" : "e81e699e-eb6c-4380-bfd5-16ab81ac51d6",
        "body" : "Ack, then in your test use something that implements WrappedRoundTripper and not CancelRequest (instead of oauth2.Transport)",
        "createdAt" : "2018-12-06T17:54:44Z",
        "updatedAt" : "2019-08-16T17:53:58Z",
        "lastEditedBy" : "e81e699e-eb6c-4380-bfd5-16ab81ac51d6",
        "tags" : [
        ]
      },
      {
        "id" : "f3cb2c59-400c-4cff-a939-9341c93292e1",
        "parentId" : "f61aed22-f1c5-4778-a10b-ca0092eda491",
        "authorId" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "body" : "Done.",
        "createdAt" : "2018-12-07T23:31:29Z",
        "updatedAt" : "2019-08-16T17:53:58Z",
        "lastEditedBy" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "tags" : [
        ]
      }
    ],
    "commit" : "a42e029e6905bee5b9d5489610c4fbe5988eeac6",
    "line" : 23,
    "diffHunk" : "@@ -1,1 +238,242 @@\t\trt.CancelRequest(req)\n\tcase utilnet.RoundTripperWrapper:\n\t\ttryCancelRequest(rt.WrappedRoundTripper(), req)\n\tdefault:\n\t\tklog.Warningf(\"Unable to cancel request for %T\", rt)"
  },
  {
    "id" : "9bc331fb-37fd-42d1-b6c9-4d90a150e7a5",
    "prId" : 71757,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/71757#pullrequestreview-182921924",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f6e3cdd9-c5a5-4d4a-a11e-5ac79594c2f2",
        "parentId" : null,
        "authorId" : "093f4806-3f92-4191-a80b-4e6cf3d6ffc0",
        "body" : "do you need a 'default' case, that is neither canceler or utilnet.RoundTripperWrapper?",
        "createdAt" : "2018-12-07T23:12:37Z",
        "updatedAt" : "2019-08-16T17:53:58Z",
        "lastEditedBy" : "093f4806-3f92-4191-a80b-4e6cf3d6ffc0",
        "tags" : [
        ]
      },
      {
        "id" : "c2643ec9-00e1-44b4-bd82-ca9af04f346e",
        "parentId" : "f6e3cdd9-c5a5-4d4a-a11e-5ac79594c2f2",
        "authorId" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "body" : "What do you think we should do other than give up silently? Log an error?",
        "createdAt" : "2018-12-07T23:31:51Z",
        "updatedAt" : "2019-08-16T17:53:58Z",
        "lastEditedBy" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "tags" : [
        ]
      },
      {
        "id" : "6cf2598c-895d-4a91-81d0-e1e0423bf9da",
        "parentId" : "f6e3cdd9-c5a5-4d4a-a11e-5ac79594c2f2",
        "authorId" : "093f4806-3f92-4191-a80b-4e6cf3d6ffc0",
        "body" : "I think log an error is good. since it is something unexpected.",
        "createdAt" : "2018-12-08T00:50:57Z",
        "updatedAt" : "2019-08-16T17:53:58Z",
        "lastEditedBy" : "093f4806-3f92-4191-a80b-4e6cf3d6ffc0",
        "tags" : [
        ]
      }
    ],
    "commit" : "a42e029e6905bee5b9d5489610c4fbe5988eeac6",
    "line" : 22,
    "diffHunk" : "@@ -1,1 +237,241 @@\tcase canceler:\n\t\trt.CancelRequest(req)\n\tcase utilnet.RoundTripperWrapper:\n\t\ttryCancelRequest(rt.WrappedRoundTripper(), req)\n\tdefault:"
  },
  {
    "id" : "d6172666-61d3-4775-aa00-edbbfbc53996",
    "prId" : 62649,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/62649#pullrequestreview-112854760",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2102a221-d4aa-49b0-bd09-8baf2de31c04",
        "parentId" : null,
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "if tls.Insecure is true, why don't we just return nil, nil?",
        "createdAt" : "2018-04-17T12:41:22Z",
        "updatedAt" : "2018-04-20T16:31:05Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      },
      {
        "id" : "1fd3b049-99a6-4adf-b6b4-30495e498064",
        "parentId" : "2102a221-d4aa-49b0-bd09-8baf2de31c04",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "anything that deviates from the defaults must return a custom tls.Config\r\n\r\nsetting Insecure=true or a custom ServerName requires a non-default tls.Config",
        "createdAt" : "2018-04-17T15:09:01Z",
        "updatedAt" : "2018-04-20T16:31:05Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "d421affd2df55c84a55a05c07dd9b76c87134230",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +53,57 @@// by the provided Config. Will return nil if no transport level security is requested.\nfunc TLSConfigFor(c *Config) (*tls.Config, error) {\n\tif !(c.HasCA() || c.HasCertAuth() || c.TLS.Insecure || len(c.TLS.ServerName) > 0) {\n\t\treturn nil, nil\n\t}"
  }
]
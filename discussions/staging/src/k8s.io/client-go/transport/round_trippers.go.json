[
  {
    "id" : "87c07817-7361-48d1-9c1c-da69a1c13291",
    "prId" : 96001,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/96001#pullrequestreview-528645837",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "044f43c1-d35b-49ff-b54d-25c8c3d83385",
        "parentId" : null,
        "authorId" : "b112ea13-32cd-4220-9b55-14ca54cb7a3c",
        "body" : "Far below, `requestInfo.RequestHeader` should be marked?  It was responsible for `CVE-2020-8565`.",
        "createdAt" : "2020-11-12T00:14:38Z",
        "updatedAt" : "2020-11-12T12:26:00Z",
        "lastEditedBy" : "b112ea13-32cd-4220-9b55-14ca54cb7a3c",
        "tags" : [
        ]
      }
    ],
    "commit" : "e29c568c4a9cd45d15665345aa015e21bcff52dd",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +168,172 @@type basicAuthRoundTripper struct {\n\tusername string\n\tpassword string `datapolicy:\"password\"`\n\trt       http.RoundTripper\n}"
  },
  {
    "id" : "49f0711b-e0cb-428c-a7fe-5069607b5644",
    "prId" : 95614,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/95614#pullrequestreview-509660129",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "783e1f52-1801-4d1e-9b75-d6926d697201",
        "parentId" : null,
        "authorId" : "698f4eb2-501b-44f5-9ff2-a2d82e9ac4f7",
        "body" : "\r\n\r\nüëç Comment matches the func.\r\n",
        "createdAt" : "2020-10-15T18:33:40Z",
        "updatedAt" : "2020-10-21T08:02:44Z",
        "lastEditedBy" : "698f4eb2-501b-44f5-9ff2-a2d82e9ac4f7",
        "tags" : [
        ]
      }
    ],
    "commit" : "889ffb04d03e49cdbb481b86ea233d0aa3143db6",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +262,266 @@}\n\n// NewBearerAuthWithRefreshRoundTripper adds the provided bearer token to a request\n// unless the authorization header has already been set.\n// If tokenFile is non-empty, it is periodically read,"
  },
  {
    "id" : "4f3be30a-28f0-4d7a-ad55-bd278104bd1e",
    "prId" : 81330,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/81330#pullrequestreview-274267628",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b5362803-7e61-42f9-9907-a17976896a2f",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "since this is now a separate function, can return early and unnest:\r\n\r\n```\r\nif !strings.EqualFold(key, \"Authorization\") {\r\n  return value\r\n}\r\n```\r\n...\r\n```\r\nif !knownAuthTypes[strings.ToLower(authType)] {\r\n  return \"<masked>\"\r\n}\r\n```\r\netc",
        "createdAt" : "2019-08-13T13:08:23Z",
        "updatedAt" : "2019-08-13T16:36:30Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "010d8382642119c73cb2405286b347c08d704287",
    "line" : 12,
    "diffHunk" : "@@ -1,1 +418,422 @@// maskValue masks credential content from authorization headers\n// See https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Authorization\nfunc maskValue(key string, value string) string {\n\tif !strings.EqualFold(key, \"Authorization\") {\n\t\treturn value"
  },
  {
    "id" : "2b503fdb-1444-4092-8b18-7a59c3436a15",
    "prId" : 65799,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/65799#pullrequestreview-136472224",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "52792440-9063-46a8-8d36-d6668b06d376",
        "parentId" : null,
        "authorId" : "e81e699e-eb6c-4380-bfd5-16ab81ac51d6",
        "body" : "How about removing `%` from `legalHeaderKeyBytes` and remove this func?",
        "createdAt" : "2018-07-12T00:32:24Z",
        "updatedAt" : "2018-07-16T18:45:25Z",
        "lastEditedBy" : "e81e699e-eb6c-4380-bfd5-16ab81ac51d6",
        "tags" : [
        ]
      },
      {
        "id" : "ec0156d8-b6d7-4601-9590-f2ef22e86e0a",
        "parentId" : "52792440-9063-46a8-8d36-d6668b06d376",
        "authorId" : "1f68015a-b968-47bc-b26f-0adff52fb6d8",
        "body" : "That's what I originally had.\r\nI feel that explicitly declaring '%' as header-key-legal, referencing the relevant RFC and appropriated code, and then explicitly encoding it anyway is more readable and less surprising.",
        "createdAt" : "2018-07-12T01:02:15Z",
        "updatedAt" : "2018-07-16T18:45:25Z",
        "lastEditedBy" : "1f68015a-b968-47bc-b26f-0adff52fb6d8",
        "tags" : [
        ]
      }
    ],
    "commit" : "f35e3d07c9898f8ec156209a868fa4451eb9afe2",
    "line" : 30,
    "diffHunk" : "@@ -1,1 +431,435 @@\t// url.PathUnescape() returns an error if any '%' is not followed by two\n\t// hexadecimal digits, so we'll intentionally encode it.\n\treturn !legalHeaderByte(b) || b == '%'\n}\n"
  },
  {
    "id" : "5ac7d4ef-b859-47b4-89e1-5e19ecec18d9",
    "prId" : 47353,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/47353#pullrequestreview-54161797",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2d40c9e4-57c7-40a8-a278-ed5cde786615",
        "parentId" : null,
        "authorId" : "f04ec747-f3ff-4334-a66e-6daaf4497091",
        "body" : "Should [MarkCachedResponses](https://godoc.org/github.com/gregjones/httpcache#Transport) be set to enable consumers to determine whether the response is cached? I can't decide if that would be an abstraction leak.",
        "createdAt" : "2017-08-02T20:50:44Z",
        "updatedAt" : "2017-08-04T21:39:32Z",
        "lastEditedBy" : "f04ec747-f3ff-4334-a66e-6daaf4497091",
        "tags" : [
        ]
      },
      {
        "id" : "68ae94f3-015b-417e-988d-6ca5be5988b8",
        "parentId" : "2d40c9e4-57c7-40a8-a278-ed5cde786615",
        "authorId" : "f04ec747-f3ff-4334-a66e-6daaf4497091",
        "body" : "Or should clients just rely on an HTTP 304 to assess the nature of the response?",
        "createdAt" : "2017-08-02T20:53:29Z",
        "updatedAt" : "2017-08-04T21:39:32Z",
        "lastEditedBy" : "f04ec747-f3ff-4334-a66e-6daaf4497091",
        "tags" : [
        ]
      },
      {
        "id" : "4acf1b02-9c58-49f2-8fef-381d130679c3",
        "parentId" : "2d40c9e4-57c7-40a8-a278-ed5cde786615",
        "authorId" : "a139439a-9f9e-4518-b4f3-9c602d956c57",
        "body" : "Yeah, I don't have a strong opinion on that. I'm trying to keep it minimal unless the feature is proved to be useful.",
        "createdAt" : "2017-08-02T20:57:59Z",
        "updatedAt" : "2017-08-04T21:39:32Z",
        "lastEditedBy" : "a139439a-9f9e-4518-b4f3-9c602d956c57",
        "tags" : [
        ]
      },
      {
        "id" : "49db6733-7b37-40c8-8438-6f86d6d997b2",
        "parentId" : "2d40c9e4-57c7-40a8-a278-ed5cde786615",
        "authorId" : "a139439a-9f9e-4518-b4f3-9c602d956c57",
        "body" : "No I don't think that's going to work, the status code will be changed to 200 I think.",
        "createdAt" : "2017-08-02T20:59:09Z",
        "updatedAt" : "2017-08-04T21:39:32Z",
        "lastEditedBy" : "a139439a-9f9e-4518-b4f3-9c602d956c57",
        "tags" : [
        ]
      },
      {
        "id" : "f9a269ec-61e0-4c09-b806-e933a744654b",
        "parentId" : "2d40c9e4-57c7-40a8-a278-ed5cde786615",
        "authorId" : "f04ec747-f3ff-4334-a66e-6daaf4497091",
        "body" : "Sorry, I'm just learning about the ETag spec. Looks like when `If-Modified-Since` is used (which the httpcache library does), the server should return an HTTP 304 (which this PR's implementation should preserve). So it seems like callers should have all the information they need.",
        "createdAt" : "2017-08-02T21:13:44Z",
        "updatedAt" : "2017-08-04T21:39:32Z",
        "lastEditedBy" : "f04ec747-f3ff-4334-a66e-6daaf4497091",
        "tags" : [
        ]
      },
      {
        "id" : "7c68ad45-6311-470a-8a33-3dab1e50b0d1",
        "parentId" : "2d40c9e4-57c7-40a8-a278-ed5cde786615",
        "authorId" : "a139439a-9f9e-4518-b4f3-9c602d956c57",
        "body" : "> Looks like when If-Modified-Since is used (which the httpcache library does), the server should return an HTTP 304\r\n\r\nYes,\r\n\r\n> (which this PR's implementation should preserve)\r\n\r\nIt [doesn't](https://github.com/gregjones/httpcache/blob/master/httpcache.go#L187)",
        "createdAt" : "2017-08-02T21:23:28Z",
        "updatedAt" : "2017-08-04T21:39:32Z",
        "lastEditedBy" : "a139439a-9f9e-4518-b4f3-9c602d956c57",
        "tags" : [
        ]
      },
      {
        "id" : "92d0574b-3e74-4039-afec-8da7a645bbc9",
        "parentId" : "2d40c9e4-57c7-40a8-a278-ed5cde786615",
        "authorId" : "f04ec747-f3ff-4334-a66e-6daaf4497091",
        "body" : "@apelisse \r\n>>Looks like when If-Modified-Since is used (which the httpcache library does), the server >>should return an HTTP 304\r\n\r\n>Yes,\r\n\r\n>>(which this PR's implementation should preserve)\r\n\r\n>It doesn't\r\n\r\nHrm. I found what looks like a  [relevant spec section](https://tools.ietf.org/html/rfc7234#section-4.3.2) but I don't have time to think about it too closely right now.\r\n\r\nThe [primary use case](https://github.com/kubernetes/kubernetes/issues/49966#issuecomment-319510084) @caesarxuchao and I were discussing to make use of this feature depends on the caller's ability to determine whether the response is cached. I'm hoping somebody more knowledgable can help me understand whether we have misguided expectations or whether httpcache is misbehaving.",
        "createdAt" : "2017-08-02T21:36:27Z",
        "updatedAt" : "2017-08-04T21:39:32Z",
        "lastEditedBy" : "f04ec747-f3ff-4334-a66e-6daaf4497091",
        "tags" : [
        ]
      },
      {
        "id" : "d883e077-7065-437a-b361-6037f9b34fcb",
        "parentId" : "2d40c9e4-57c7-40a8-a278-ed5cde786615",
        "authorId" : "a139439a-9f9e-4518-b4f3-9c602d956c57",
        "body" : "Thanks for providing more context!\r\n\r\nI don't think you should rely on that behavior, as it would heavily depend on what cache settings the server is using. If `cache-control` starts being set, then your assumption might break.",
        "createdAt" : "2017-08-02T21:50:27Z",
        "updatedAt" : "2017-08-04T21:39:32Z",
        "lastEditedBy" : "a139439a-9f9e-4518-b4f3-9c602d956c57",
        "tags" : [
        ]
      },
      {
        "id" : "43bd447d-b90b-47d8-a10a-d3c2cc735b3b",
        "parentId" : "2d40c9e4-57c7-40a8-a278-ed5cde786615",
        "authorId" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "body" : "@apelisse could you elaborate on what's `cache-control`? Thanks.",
        "createdAt" : "2017-08-02T23:18:43Z",
        "updatedAt" : "2017-08-04T21:39:32Z",
        "lastEditedBy" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "tags" : [
        ]
      },
      {
        "id" : "d7ebe25d-eb36-41b1-80a9-2a4ff5f0652d",
        "parentId" : "2d40c9e4-57c7-40a8-a278-ed5cde786615",
        "authorId" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "body" : "@apelisse can client only check if the ETag is up-to-date, but not receiving the latest openapi spec, which is a few MB? In our use case, the garbage collector only needs to determine if the registered API has changed, it doesn't need the openapi spec.",
        "createdAt" : "2017-08-02T23:24:32Z",
        "updatedAt" : "2017-08-04T21:39:32Z",
        "lastEditedBy" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "tags" : [
        ]
      },
      {
        "id" : "b1803a71-d8c5-48f5-ad82-d3ed1470f257",
        "parentId" : "2d40c9e4-57c7-40a8-a278-ed5cde786615",
        "authorId" : "a139439a-9f9e-4518-b4f3-9c602d956c57",
        "body" : "The server can use `cache-control` to let the client (and proxies) know how/when to cache the file, and when it needs to be downloaded again. As an example, the server can specify `stale-if-error` to say that the client can re-use the latest known version of the resource when the server is broken. If we would use that, then the client would return the version from cache (file hasn't changed and is coming from cache), even though the server is down. That's definitely going to break your use-case.\r\n\r\nI think you need a stronger semantic to know if something changed. It'd be more interesting for example, to use the version field of the openapi-spec to verify if the file has changed. The server would have to set this field to a different value based on changes, but that'd be much less flaky.",
        "createdAt" : "2017-08-02T23:59:18Z",
        "updatedAt" : "2017-08-04T21:39:32Z",
        "lastEditedBy" : "a139439a-9f9e-4518-b4f3-9c602d956c57",
        "tags" : [
        ]
      },
      {
        "id" : "c309cdcf-9ad7-4be1-a92b-7af9eae9b959",
        "parentId" : "2d40c9e4-57c7-40a8-a278-ed5cde786615",
        "authorId" : "f04ec747-f3ff-4334-a66e-6daaf4497091",
        "body" : "Hrm. I still don't quite understand. The spec seems to talk specifically about [how caching layers should propagate](https://tools.ietf.org/html/rfc7234#section-4.3.2) 304 when `If-Modified-Since` is used:\r\n\r\n```\r\nIf an If-None-Match header field is not present, a request containing\r\nan If-Modified-Since header field (Section 3.3 of [RFC7232])\r\nindicates that the client wants to validate one or more of its own\r\nstored responses by modification date.  A cache recipient SHOULD\r\ngenerate a 304 (Not Modified) response (using the metadata of the\r\nselected stored response) if one of the following cases is true: 1)\r\nthe selected stored response has a Last-Modified field-value that is\r\nearlier than or equal to the conditional timestamp; 2) no\r\nLast-Modified field is present in the selected stored response, but\r\nit has a Date field-value that is earlier than or equal to the\r\nconditional timestamp; or, 3) neither Last-Modified nor Date is\r\npresent in the selected stored response, but the cache recorded it as\r\nhaving been received at a time earlier than or equal to the\r\nconditional timestamp.\r\n```\r\n\r\nBased on that, I'm not sure why I as a client (via the caching layer) wouldn't receive a 304 in this case. I must be misunderstanding. Maybe this is a discussion for the httpcache project or a mailing list instead? I don't want to bog you all down with my questions if the caching layer semantics are ultimately a third-party concern with this change.",
        "createdAt" : "2017-08-03T13:39:26Z",
        "updatedAt" : "2017-08-04T21:39:32Z",
        "lastEditedBy" : "f04ec747-f3ff-4334-a66e-6daaf4497091",
        "tags" : [
        ]
      },
      {
        "id" : "6d47fc6a-ef84-43ce-b64d-cbbc348bae27",
        "parentId" : "2d40c9e4-57c7-40a8-a278-ed5cde786615",
        "authorId" : "a139439a-9f9e-4518-b4f3-9c602d956c57",
        "body" : "I think section 4.3.2 (Handling a Received Validation Request) applies to servers and proxies (and I think that's what they call \"cache recipient\" in your snippet). Then yes, if a proxy receives a request that is already cached, it should generate a 304 response, no doubt about that.\r\n\r\nThe relevant section, I think are 4.3.3 (Handling a Validation Response) and maybe 4.3.4 (Freshening Stored Responses upon Validation), but there is nothing specifically mentioning that.\r\n\r\nI really doubt you should rely on an implementation detail for that.\r\n\r\n",
        "createdAt" : "2017-08-03T16:23:43Z",
        "updatedAt" : "2017-08-04T21:39:32Z",
        "lastEditedBy" : "a139439a-9f9e-4518-b4f3-9c602d956c57",
        "tags" : [
        ]
      },
      {
        "id" : "8b2be134-be57-4bd7-a92f-b1b8e3575cdb",
        "parentId" : "2d40c9e4-57c7-40a8-a278-ed5cde786615",
        "authorId" : "f04ec747-f3ff-4334-a66e-6daaf4497091",
        "body" : "Thanks for the clarification!",
        "createdAt" : "2017-08-03T17:15:07Z",
        "updatedAt" : "2017-08-04T21:39:32Z",
        "lastEditedBy" : "f04ec747-f3ff-4334-a66e-6daaf4497091",
        "tags" : [
        ]
      }
    ],
    "commit" : "d6348cc1ff72be719e0830da2c64ef1689499956",
    "line" : 29,
    "diffHunk" : "@@ -1,1 +99,103 @@func NewCacheRoundTripper(cacheDir string, rt http.RoundTripper) http.RoundTripper {\n\td := diskv.New(diskv.Options{BasePath: cacheDir})\n\tt := httpcache.NewTransport(diskcache.NewWithDiskv(d))\n\tt.Transport = rt\n"
  },
  {
    "id" : "59346b66-85e2-42a2-a2a4-61b3287d2459",
    "prId" : 47353,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/47353#pullrequestreview-54406696",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d776dafc-fc52-47cd-a936-2f4ceb42e876",
        "parentId" : null,
        "authorId" : "47ec15eb-72b4-4618-9e01-e3b37b6bac00",
        "body" : "Lets add a test for this that will make sure we are using the caching libraries correctly.",
        "createdAt" : "2017-08-03T18:06:47Z",
        "updatedAt" : "2017-08-04T21:39:32Z",
        "lastEditedBy" : "47ec15eb-72b4-4618-9e01-e3b37b6bac00",
        "tags" : [
        ]
      },
      {
        "id" : "1d38a846-cd20-4a2c-8572-3cab380c0919",
        "parentId" : "d776dafc-fc52-47cd-a936-2f4ceb42e876",
        "authorId" : "a139439a-9f9e-4518-b4f3-9c602d956c57",
        "body" : "Added, PTAL",
        "createdAt" : "2017-08-04T15:56:22Z",
        "updatedAt" : "2017-08-04T21:39:32Z",
        "lastEditedBy" : "a139439a-9f9e-4518-b4f3-9c602d956c57",
        "tags" : [
        ]
      }
    ],
    "commit" : "d6348cc1ff72be719e0830da2c64ef1689499956",
    "line" : 28,
    "diffHunk" : "@@ -1,1 +98,102 @@// corresponding requests.\nfunc NewCacheRoundTripper(cacheDir string, rt http.RoundTripper) http.RoundTripper {\n\td := diskv.New(diskv.Options{BasePath: cacheDir})\n\tt := httpcache.NewTransport(diskcache.NewWithDiskv(d))\n\tt.Transport = rt"
  },
  {
    "id" : "aa52b533-a202-47a5-87f7-3c56cd93dc77",
    "prId" : 47353,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/47353#pullrequestreview-54549094",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d83a61c8-a065-4062-870c-07ff086b99cd",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "This is a really significant change. Wrapping the whole transport affects every aspect of the clients, for streaming, spdy, etc. Given that we immediately saw issues with this for websocket use, I think we should revert this until the wrapping transports are more thoroughly reviewed, or we can scope this to just the discovery/openapi endpoints for now. ",
        "createdAt" : "2017-08-07T00:10:28Z",
        "updatedAt" : "2017-08-07T00:10:52Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "1b768015-399f-48fe-bb83-a4f89a14883e",
        "parentId" : "d83a61c8-a065-4062-870c-07ff086b99cd",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "Looks like this also results in all get/list resources getting persisted to disk:\r\n\r\n```sh\r\n$ kubectl get secrets\r\n\r\nNAME                  TYPE                                  DATA      AGE\r\ndefault-token-gqj6t   kubernetes.io/service-account-token   3         13m\r\n\r\n$ more .kube/http-cache/499e4e6a4f2a2b827ce93a2349098106\r\n\r\nHTTP/2.0 200 OK\r\nContent-Length: 3680\r\nContent-Type: application/json\r\nDate: Mon, 07 Aug 2017 00:54:25 GMT\r\n\r\n{\"kind\":\"SecretList\",\"apiVersion\":\"v1\",\"metadata\":{\"selfLink\":\"/api/v1/namespaces/default/secrets\",\"resourceVersion\":\"1105\"},\"items\":[{\"metadata\":{\"name\":\"default-token-gqj6t\"...",
        "createdAt" : "2017-08-07T00:56:03Z",
        "updatedAt" : "2017-08-07T00:56:03Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "d6348cc1ff72be719e0830da2c64ef1689499956",
    "line" : 15,
    "diffHunk" : "@@ -1,1 +61,65 @@\t}\n\tif len(config.CacheDir) > 0 {\n\t\trt = NewCacheRoundTripper(config.CacheDir, rt)\n\t}\n\treturn rt, nil"
  }
]
[
  {
    "id" : "ce2b29a9-d495-4b14-a23b-26034fba912f",
    "prId" : 81030,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/81030#pullrequestreview-274917360",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f422897e-1e6a-4355-857a-4470c1dabed2",
        "parentId" : null,
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "Copying some comments from the previous version:\r\n@liggitt \r\n> if this already exists, and we do not verify the object that already exists matches the LeaderElectionRecord we intended to create, doesn't that cause problems?\r\n\r\n> doesn't this also put the configmap holder in an invalid state (it makes the internal cm variable nil in an AlreadyExists case)?\r\n\r\n@ricky1993 \r\n\r\n> I think I get your point.\r\nIf two clients start for a initial cluster, they may Get() and both get NotFound error, then try to Create() and both return true.\r\nThe problem is Get() and Create() is not atomic.\r\n\r\n> How about masking AlreadyExists errors when the primary lock is created by the client.\r\nThe reason about masking AlreadyExists errors is that Get() return NotFound error, but we don't know which lock is not found, so we try to create both of them.\r\nIt the primary lock is belong to the client, the secondary lock is NotFound, and we would create it, else if the primary is created by other client, we would return error and tryAcquireOrRenew would fail.",
        "createdAt" : "2019-08-14T09:24:49Z",
        "updatedAt" : "2019-09-26T11:25:06Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      },
      {
        "id" : "04568e6a-36ef-43f5-97a0-c134b5740b8e",
        "parentId" : "f422897e-1e6a-4355-857a-4470c1dabed2",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "If we assume, that there never should be situation that Primary doesn't exist and Secondary exists (which I think is actually a valid asusmption), then masking Primary sounds fine to me.\r\nBut this has to be very clearly documented at the very least.\r\n\r\n@liggitt - WDYT?",
        "createdAt" : "2019-08-14T11:11:15Z",
        "updatedAt" : "2019-09-26T11:25:06Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      },
      {
        "id" : "2b55d15f-adf2-4358-b9d1-69c917eaa573",
        "parentId" : "f422897e-1e6a-4355-857a-4470c1dabed2",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "> If we assume, that there never should be situation that Primary doesn't exist and Secondary exists\r\n\r\nThat seems like exactly the case we need to worry about when another of the members is an n+1 controller that only pays attention to Lease objects",
        "createdAt" : "2019-08-14T14:08:04Z",
        "updatedAt" : "2019-09-26T11:25:06Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "4c1318b2-ab50-423a-91e0-6962f2696f9d",
        "parentId" : "f422897e-1e6a-4355-857a-4470c1dabed2",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "My assumption for that case was that there are two cases:\r\n- either at some point there was \"n\" controller, which already created those objects (so basically we are upgrading) [technically it can also be removed by sth, but I wouldn't consider that as a high risk]\r\n- or there weren't (and we create directly cluster in n+1 version) and that's not a problem",
        "createdAt" : "2019-08-14T14:12:16Z",
        "updatedAt" : "2019-09-26T11:25:06Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      },
      {
        "id" : "0706a5af-0f97-4206-b650-06bb25485a45",
        "parentId" : "f422897e-1e6a-4355-857a-4470c1dabed2",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "That doesn't seem like a good assumption. two-object leader election needs to be bulletproof (within the assumptions that the electing clients are well-behaved and aren't deleting each other's objects)\r\n\r\nThis should be a valid use case:\r\n* Start version n+1 looking only at Lease objects\r\n* Then start version n looking at ConfigMap+Lease objects\r\n\r\nDeletion of leader lock objects is not an unreasonable thing for a deployer to do during an upgrade where it knows all controller instances are shut down, in order to get faster startup time",
        "createdAt" : "2019-08-14T14:16:40Z",
        "updatedAt" : "2019-09-26T11:25:06Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "447295aff2bd8cdc92a2376553d83546a4d6eb41",
    "line" : 65,
    "diffHunk" : "@@ -1,1 +63,67 @@func (ml *MultiLock) Create(ler LeaderElectionRecord) error {\n\terr := ml.Primary.Create(ler)\n\tif err != nil && !apierrors.IsAlreadyExists(err) {\n\t\treturn err\n\t}"
  },
  {
    "id" : "ad96d776-dbd8-4aec-9943-99058ef9d3bc",
    "prId" : 81030,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/81030#pullrequestreview-282969596",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "80d52cb3-eff3-4f22-a73c-ab82af1d2228",
        "parentId" : null,
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "If you're changing primary, you also need to recompute primaryRaw.",
        "createdAt" : "2019-09-03T12:49:37Z",
        "updatedAt" : "2019-09-26T11:25:06Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "447295aff2bd8cdc92a2376553d83546a4d6eb41",
    "line" : 53,
    "diffHunk" : "@@ -1,1 +51,55 @@\n\tif primary.HolderIdentity != secondary.HolderIdentity {\n\t\tprimary.HolderIdentity = UnknownLeader\n\t\tprimaryRaw, err = json.Marshal(primary)\n\t\tif err != nil {"
  }
]
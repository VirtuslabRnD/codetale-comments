[
  {
    "id" : "92927ccd-17dd-4176-a604-ffd1a29ef9a9",
    "prId" : 99195,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/99195#pullrequestreview-595952330",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "29fffaec-3ad3-4387-9c49-7d330f673d43",
        "parentId" : null,
        "authorId" : "06a18a1b-6ca5-44b8-9cdc-5bb944ae4e29",
        "body" : "Please note that this PR does not solve the issue I reported https://github.com/kubernetes/kubernetes/issues/99177. The error would still be logged here, just like it is today.",
        "createdAt" : "2021-02-19T10:38:54Z",
        "updatedAt" : "2021-02-23T02:29:24Z",
        "lastEditedBy" : "06a18a1b-6ca5-44b8-9cdc-5bb944ae4e29",
        "tags" : [
        ]
      },
      {
        "id" : "9d093f3d-0e43-465b-b347-4d9381cb84ca",
        "parentId" : "29fffaec-3ad3-4387-9c49-7d330f673d43",
        "authorId" : "5e225159-999d-430a-8b58-d5220dc1429d",
        "body" : "I fixed it in the last push.\r\nWhen the error matches `context canceled`, avoid error logs here.",
        "createdAt" : "2021-02-20T02:47:03Z",
        "updatedAt" : "2021-02-23T02:29:24Z",
        "lastEditedBy" : "5e225159-999d-430a-8b58-d5220dc1429d",
        "tags" : [
        ]
      },
      {
        "id" : "34226f04-7653-42f2-9b99-70bcf89eac4d",
        "parentId" : "29fffaec-3ad3-4387-9c49-7d330f673d43",
        "authorId" : "06a18a1b-6ca5-44b8-9cdc-5bb944ae4e29",
        "body" : "AFAIK client-go does not use gRPC.",
        "createdAt" : "2021-02-20T09:46:52Z",
        "updatedAt" : "2021-02-23T02:29:24Z",
        "lastEditedBy" : "06a18a1b-6ca5-44b8-9cdc-5bb944ae4e29",
        "tags" : [
        ]
      },
      {
        "id" : "b09b93ab-d1a9-417e-932f-25f2b02c5662",
        "parentId" : "29fffaec-3ad3-4387-9c49-7d330f673d43",
        "authorId" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "body" : "Agreeing with @ash2k here, I don't think grpc plays a role here. I asked @ask2k to clarify how to reproduce the issue in https://github.com/kubernetes/kubernetes/issues/99177#issuecomment-782745968.\r\n\r\nAlso @pacoxu can you split this to two PRs? Keeping this one to convert to structured log, and let's resolve #99177 in a new PR.",
        "createdAt" : "2021-02-20T20:40:21Z",
        "updatedAt" : "2021-02-23T02:29:24Z",
        "lastEditedBy" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "tags" : [
        ]
      },
      {
        "id" : "d38a8a81-f528-4e06-9f26-941371295e9a",
        "parentId" : "29fffaec-3ad3-4387-9c49-7d330f673d43",
        "authorId" : "5e225159-999d-430a-8b58-d5220dc1429d",
        "body" : "OK. I will remove the  #99177 part here.\r\n@caesarxuchao ",
        "createdAt" : "2021-02-23T02:21:50Z",
        "updatedAt" : "2021-02-23T02:29:24Z",
        "lastEditedBy" : "5e225159-999d-430a-8b58-d5220dc1429d",
        "tags" : [
        ]
      }
    ],
    "commit" : "c4dc34e8cbad41968c50763f79280e7cd14dabee",
    "line" : 19,
    "diffHunk" : "@@ -1,1 +128,132 @@\t\t}\n\n\t\tklog.ErrorS(err, msg)\n\t\t// Retry\n\t\treturn false, 0"
  },
  {
    "id" : "64b5d73a-1e8b-48e7-916b-0495ab04eaad",
    "prId" : 67350,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/67350#pullrequestreview-202778163",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bd330620-272d-45fc-bc75-1a5b7f1174ce",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "This is closing the same channel that is closed by RetryWatcher#Stop. Won't that cause a panic?\r\n\r\nedit: I'm blind. doneChan != stopChan",
        "createdAt" : "2019-02-12T16:41:49Z",
        "updatedAt" : "2019-02-26T15:25:44Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "d526dadd12731903ee1418a86d816389ecc40fc6",
    "line" : 237,
    "diffHunk" : "@@ -1,1 +235,239 @@// receive reads the result from a watcher, restarting it if necessary.\nfunc (rw *RetryWatcher) receive() {\n\tdefer close(rw.doneChan)\n\tdefer close(rw.resultChan)\n"
  },
  {
    "id" : "7445d9bd-9ae3-41b3-9de5-ee93d29fa335",
    "prId" : 67350,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/67350#pullrequestreview-204896951",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a9611a3f-cdb3-4833-ad47-7aabafcf5916",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "won't this hot-loop retry on network errors, permission errors, etc?",
        "createdAt" : "2019-02-12T16:44:14Z",
        "updatedAt" : "2019-02-26T15:25:44Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "2bdbf2ce-26c4-4b99-b24e-a61b7ad447f9",
        "parentId" : "a9611a3f-cdb3-4833-ad47-7aabafcf5916",
        "authorId" : "443f9b92-20b0-45c2-a13f-20c6f64f89eb",
        "body" : "It will, but it will always check for the stop channel so the timeout (context) from Until cancels it. This used to hard fail, but in this last iteration I have decided for approach more similar to informers. I am  open to other views on how we should treat errors here, but my latest thinking is proceed at all cost, unless you know for sure you can't - network errors, permissions it all can be transilient",
        "createdAt" : "2019-02-12T18:16:58Z",
        "updatedAt" : "2019-02-26T15:25:44Z",
        "lastEditedBy" : "443f9b92-20b0-45c2-a13f-20c6f64f89eb",
        "tags" : [
        ]
      },
      {
        "id" : "3a485832-7892-4133-9e17-1d03967ace43",
        "parentId" : "a9611a3f-cdb3-4833-ad47-7aabafcf5916",
        "authorId" : "443f9b92-20b0-45c2-a13f-20c6f64f89eb",
        "body" : "added artificial waits for hard failures",
        "createdAt" : "2019-02-18T17:34:02Z",
        "updatedAt" : "2019-02-26T15:25:44Z",
        "lastEditedBy" : "443f9b92-20b0-45c2-a13f-20c6f64f89eb",
        "tags" : [
        ]
      }
    ],
    "commit" : "d526dadd12731903ee1418a86d816389ecc40fc6",
    "line" : 119,
    "diffHunk" : "@@ -1,1 +117,121 @@\tcase io.ErrUnexpectedEOF:\n\t\tklog.V(1).Infof(\"Watch closed with unexpected EOF: %v\", err)\n\t\treturn false, 0\n\n\tdefault:"
  },
  {
    "id" : "9cfe808c-7973-452a-8a2e-c9e4e9886aac",
    "prId" : 67350,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/67350#pullrequestreview-204897114",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b2e030d5-b1b7-445f-a688-c20e41381f8d",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "if `rw.lastResourceVersion` is `\"\"` or `\"0\"`, send an error and `return true, 0`",
        "createdAt" : "2019-02-12T17:14:16Z",
        "updatedAt" : "2019-02-26T15:25:44Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "aa51520e-48dc-433d-9335-eed6352ab7bf",
        "parentId" : "b2e030d5-b1b7-445f-a688-c20e41381f8d",
        "authorId" : "443f9b92-20b0-45c2-a13f-20c6f64f89eb",
        "body" : "done in the constructor",
        "createdAt" : "2019-02-18T17:34:34Z",
        "updatedAt" : "2019-02-26T15:25:44Z",
        "lastEditedBy" : "443f9b92-20b0-45c2-a13f-20c6f64f89eb",
        "tags" : [
        ]
      }
    ],
    "commit" : "d526dadd12731903ee1418a86d816389ecc40fc6",
    "line" : 102,
    "diffHunk" : "@@ -1,1 +100,104 @@// doReceive returns true when it is done, false otherwise.\n// If it is not done the second return value holds the time to wait before calling it again.\nfunc (rw *RetryWatcher) doReceive() (bool, time.Duration) {\n\twatcher, err := rw.watcherClient.Watch(metav1.ListOptions{\n\t\tResourceVersion: rw.lastResourceVersion,"
  },
  {
    "id" : "86f13fe8-f0cb-4060-999b-eacaa982597a",
    "prId" : 67350,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/67350#pullrequestreview-207794432",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3efad7c2-4465-42e8-af22-e948bc7061e5",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "anywhere this does `return false, 0`, we're still setting ourselves up for a hotloop, right?",
        "createdAt" : "2019-02-19T14:14:23Z",
        "updatedAt" : "2019-02-26T15:25:44Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "7111e27f-e9e7-4614-8899-7c78b9661f27",
        "parentId" : "3efad7c2-4465-42e8-af22-e948bc7061e5",
        "authorId" : "443f9b92-20b0-45c2-a13f-20c6f64f89eb",
        "body" : "I think on the normal path, WATCH should be restarted immediately. \r\n\r\nWhat is a normal path could be the question. If you are unlucky to open a connection to apiserver that is just about to terminate, you likely want to start again by trying another watch as that wasn't error path you'd have to backoff on.\r\n\r\nIf your watch timeouts, you shouldn't sleep but try immediately.\r\n\r\nI guess we could count consequent failures before getting to the processing phase but splitting failures into ones we want to retry immediately and ones we want to apply delay to seemed good enough for this use.",
        "createdAt" : "2019-02-19T15:23:54Z",
        "updatedAt" : "2019-02-26T15:25:44Z",
        "lastEditedBy" : "443f9b92-20b0-45c2-a13f-20c6f64f89eb",
        "tags" : [
        ]
      },
      {
        "id" : "0a24e4e2-408d-4689-8d2d-329c4becae22",
        "parentId" : "3efad7c2-4465-42e8-af22-e948bc7061e5",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "> If your watch timeouts, you shouldn't sleep but try immediately.\r\n\r\nwhy? reflectors delay for a second in exactly that scenario, so they don't hotloop:\r\n\r\nhttps://github.com/kubernetes/kubernetes/blob/8d6f20ea4342327bb778a80c70c47ec9ad47e182/staging/src/k8s.io/client-go/tools/cache/reflector.go#L113\r\n\r\nhttps://github.com/kubernetes/kubernetes/blob/8d6f20ea4342327bb778a80c70c47ec9ad47e182/staging/src/k8s.io/client-go/tools/cache/reflector.go#L133-L137\r\n\r\nI think retryAfter should be a minimum of 1 second.",
        "createdAt" : "2019-02-22T15:41:17Z",
        "updatedAt" : "2019-02-26T15:25:44Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "9a568d35-6601-44e3-b529-b7c8bb602d0b",
        "parentId" : "3efad7c2-4465-42e8-af22-e948bc7061e5",
        "authorId" : "443f9b92-20b0-45c2-a13f-20c6f64f89eb",
        "body" : "To me, the difference is that informers are caches and this is a form of direct api call.\r\n\r\nCaches are ok with a delay, I don't expect delays to be injected into a real-time api call on the happy path.",
        "createdAt" : "2019-02-26T07:17:32Z",
        "updatedAt" : "2019-02-26T15:25:44Z",
        "lastEditedBy" : "443f9b92-20b0-45c2-a13f-20c6f64f89eb",
        "tags" : [
        ]
      },
      {
        "id" : "d6297025-4779-4fa8-993b-fc5c71d1fa22",
        "parentId" : "3efad7c2-4465-42e8-af22-e948bc7061e5",
        "authorId" : "443f9b92-20b0-45c2-a13f-20c6f64f89eb",
        "body" : "but I think there is a way to address both concerns, let me update the PR...",
        "createdAt" : "2019-02-26T07:24:15Z",
        "updatedAt" : "2019-02-26T15:25:44Z",
        "lastEditedBy" : "443f9b92-20b0-45c2-a13f-20c6f64f89eb",
        "tags" : [
        ]
      }
    ],
    "commit" : "d526dadd12731903ee1418a86d816389ecc40fc6",
    "line" : 115,
    "diffHunk" : "@@ -1,1 +113,117 @@\tcase io.EOF:\n\t\t// watch closed normally\n\t\treturn false, 0\n\n\tcase io.ErrUnexpectedEOF:"
  },
  {
    "id" : "35cf8b40-d956-42e4-a022-d130a8810f11",
    "prId" : 67350,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/67350#pullrequestreview-205280914",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "af9d2bf4-7ac0-4efe-911a-3a323f255466",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "a default switch case with a fallthrough to specific status codes reads really strangely... is there a clearer way to express this?",
        "createdAt" : "2019-02-19T14:20:09Z",
        "updatedAt" : "2019-02-26T15:25:44Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "99935420-13fe-47de-b699-ba559f87ce74",
        "parentId" : "af9d2bf4-7ac0-4efe-911a-3a323f255466",
        "authorId" : "443f9b92-20b0-45c2-a13f-20c6f64f89eb",
        "body" : "moved it to a variable avoiding the fallthrough",
        "createdAt" : "2019-02-19T15:33:12Z",
        "updatedAt" : "2019-02-26T15:25:44Z",
        "lastEditedBy" : "443f9b92-20b0-45c2-a13f-20c6f64f89eb",
        "tags" : [
        ]
      }
    ],
    "commit" : "d526dadd12731903ee1418a86d816389ecc40fc6",
    "line" : 209,
    "diffHunk" : "@@ -1,1 +207,211 @@\t\t\t\t\treturn false, statusDelay\n\n\t\t\t\tdefault:\n\t\t\t\t\t// We retry by default. RetryWatcher is meant to proceed unless it is certain\n\t\t\t\t\t// that it can't. If we are not certain, we proceed with retry and leave it"
  },
  {
    "id" : "99db0bc1-f627-42e8-955f-30a378ed1e4e",
    "prId" : 67350,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/67350#pullrequestreview-207949734",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8b029737-291b-460c-8abd-965f256f8fcd",
        "parentId" : null,
        "authorId" : "443f9b92-20b0-45c2-a13f-20c6f64f89eb",
        "body" : "@liggitt this is addressing your hot loop concern without affecting the happy path.\r\n\r\nIn the end no matter what happens it won't restart sooner then in 1 second. But if a long running call (WATCH) fails e.g. after a minute it will restart immediately. If the restart fails, it won't get tried again sooner then in 1 sec.",
        "createdAt" : "2019-02-26T09:18:02Z",
        "updatedAt" : "2019-02-26T15:25:44Z",
        "lastEditedBy" : "443f9b92-20b0-45c2-a13f-20c6f64f89eb",
        "tags" : [
        ]
      },
      {
        "id" : "42ef15c4-0600-44a6-90f3-4c6c953fbc12",
        "parentId" : "8b029737-291b-460c-8abd-965f256f8fcd",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "looks good, thanks",
        "createdAt" : "2019-02-26T13:23:33Z",
        "updatedAt" : "2019-02-26T15:25:44Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "d526dadd12731903ee1418a86d816389ecc40fc6",
    "line" : 257,
    "diffHunk" : "@@ -1,1 +255,259 @@\t// We use non sliding until so we don't introduce delays on happy path when WATCH call\n\t// timeouts or gets closed and we need to reestablish it while also avoiding hot loops.\n\twait.NonSlidingUntilWithContext(ctx, func(ctx context.Context) {\n\t\tdone, retryAfter := rw.doReceive()\n\t\tif done {"
  },
  {
    "id" : "aeb94c4c-2e8a-4b60-9ae1-be19dab41a51",
    "prId" : 67350,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/67350#pullrequestreview-207977541",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e7d1be8f-ded5-4fa5-82e9-2dec51dc0f06",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "don't we need to `defer close(rw.resultChan)` as well? doc says it will be closed when `Stop()` is called, and I don't see that happening (needs a test as well):\r\n\r\n```\r\n// Returns a chan which will receive all the events. If an error occurs\r\n// or Stop() is called, this channel will be closed, in which case the\r\n// watch should be completely cleaned up.\r\nResultChan() <-chan Event\r\n```",
        "createdAt" : "2019-02-26T13:23:26Z",
        "updatedAt" : "2019-02-26T15:25:44Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "af6af19e-6595-4351-a93e-f52145cb1bed",
        "parentId" : "e7d1be8f-ded5-4fa5-82e9-2dec51dc0f06",
        "authorId" : "443f9b92-20b0-45c2-a13f-20c6f64f89eb",
        "body" : "good catch, fixed",
        "createdAt" : "2019-02-26T14:16:00Z",
        "updatedAt" : "2019-02-26T15:25:44Z",
        "lastEditedBy" : "443f9b92-20b0-45c2-a13f-20c6f64f89eb",
        "tags" : [
        ]
      }
    ],
    "commit" : "d526dadd12731903ee1418a86d816389ecc40fc6",
    "line" : 237,
    "diffHunk" : "@@ -1,1 +235,239 @@// receive reads the result from a watcher, restarting it if necessary.\nfunc (rw *RetryWatcher) receive() {\n\tdefer close(rw.doneChan)\n\tdefer close(rw.resultChan)\n"
  }
]
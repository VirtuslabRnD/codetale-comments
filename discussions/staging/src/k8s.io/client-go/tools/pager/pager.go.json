[
  {
    "id" : "71f38874-fa20-4baf-989f-5b0d806b8cdb",
    "prId" : 86430,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/86430#pullrequestreview-352533090",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2e43c67e-7f59-4a50-973a-c10900d4c8a2",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "is there a reasonable way to do this without changing the signature?",
        "createdAt" : "2020-01-31T07:19:35Z",
        "updatedAt" : "2020-01-31T10:50:48Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "9ff153b1-f605-4a15-8fe7-51377c626a61",
        "parentId" : "2e43c67e-7f59-4a50-973a-c10900d4c8a2",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "I didn't come up with anything else.\r\nThe only other option that comes to my mind is to track it at the `ListPager` level and add a method to ListPager like `WasLastListPaginated`. But then the semantic is strange if you use pager for multiple requests at the same time.\r\n\r\nI was also afraid of it, but it seems that it's not widely used, so maybe it's fine.",
        "createdAt" : "2020-01-31T08:22:44Z",
        "updatedAt" : "2020-01-31T10:50:48Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      },
      {
        "id" : "3b6d283f-5cbc-4a46-b947-74e39959c82c",
        "parentId" : "2e43c67e-7f59-4a50-973a-c10900d4c8a2",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "it's not ideal, but our current requirement to match levels of k8s.io libraries allows it, and the work to update client-go to plumb context into client signatures means 1.18.x client-go will not be compatible with 1.17.x apiserver go signatures already",
        "createdAt" : "2020-02-03T20:15:57Z",
        "updatedAt" : "2020-02-03T20:19:32Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "5dcf08c1993718e94cf6537af50e0a411dd2878c",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +74,78 @@// server to reduce the impact on the server. If the chunk attempt fails, it will load\n// the full list instead. The Limit field on options, if unset, will default to the page size.\nfunc (p *ListPager) List(ctx context.Context, options metav1.ListOptions) (runtime.Object, bool, error) {\n\tif options.Limit == 0 {\n\t\toptions.Limit = p.PageSize"
  },
  {
    "id" : "4109e765-5c10-48f8-b3b8-1d2926edfdac",
    "prId" : 75849,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/75849#pullrequestreview-223481033",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b5ca1bd9-a0b1-4b0d-8aad-b5aa24a6d2d9",
        "parentId" : null,
        "authorId" : "24ab4292-a16f-4d8f-b5cb-bf0e1ea4f6ff",
        "body" : "If listing chunk in the background fails (such as due to resource expired), we will still finish processing the existing chunks in the buffer before return?",
        "createdAt" : "2019-04-05T01:52:06Z",
        "updatedAt" : "2019-04-10T22:04:00Z",
        "lastEditedBy" : "24ab4292-a16f-4d8f-b5cb-bf0e1ea4f6ff",
        "tags" : [
        ]
      },
      {
        "id" : "25b1857e-bf1d-458e-bfed-e34418c3989f",
        "parentId" : "b5ca1bd9-a0b1-4b0d-8aad-b5aa24a6d2d9",
        "authorId" : "d4f34d8f-5341-4ac1-b8b2-5e5f11e23a5d",
        "body" : "Yes, I think from an API contract perspective, when a error occurs listing chunks, i think it's valid to either (1) stop calling fn as soon as possible, or (2) call fn on as many items as have been successfully retrieved.  I went with #1 since it was trivial to implement. I imagine in different situations a client might benefit more from one of these and in other situations the other. Thoughts?",
        "createdAt" : "2019-04-05T21:10:49Z",
        "updatedAt" : "2019-04-10T22:04:00Z",
        "lastEditedBy" : "d4f34d8f-5341-4ac1-b8b2-5e5f11e23a5d",
        "tags" : [
        ]
      }
    ],
    "commit" : "6a64ee638780de4dcfa2ab2b4fc739dd23127c49",
    "line" : 103,
    "diffHunk" : "@@ -1,1 +184,188 @@\t}()\n\n\tfor o := range chunkC {\n\t\terr := fn(o)\n\t\tif err != nil {"
  },
  {
    "id" : "c0e3a9d3-95c2-4fd6-985c-fd682f85eefa",
    "prId" : 75849,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/75849#pullrequestreview-225235717",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "80aa0aa3-414e-4f3a-ba22-91851fe2b275",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "`defer runtime.HandleCrash()` at the top of the goroutine?",
        "createdAt" : "2019-04-05T03:21:25Z",
        "updatedAt" : "2019-04-10T22:04:00Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "7302b822-d49c-4996-9056-4121519db10e",
        "parentId" : "80aa0aa3-414e-4f3a-ba22-91851fe2b275",
        "authorId" : "d4f34d8f-5341-4ac1-b8b2-5e5f11e23a5d",
        "body" : "Good catch, I should do something with panics.  I've gone with `runtime.RecoverFromPanic` here. Hopefully it's appropriate.",
        "createdAt" : "2019-04-05T21:12:09Z",
        "updatedAt" : "2019-04-10T22:04:00Z",
        "lastEditedBy" : "d4f34d8f-5341-4ac1-b8b2-5e5f11e23a5d",
        "tags" : [
        ]
      },
      {
        "id" : "da757391-a39f-4d4f-8ba2-ce341753fced",
        "parentId" : "80aa0aa3-414e-4f3a-ba22-91851fe2b275",
        "authorId" : "d4f34d8f-5341-4ac1-b8b2-5e5f11e23a5d",
        "body" : "`runtime.RecoverFromPanic` didn't work as I had expected (and from a quick grep, doesn't look like we use it in the k8s codebase), so I did a more direct recover.",
        "createdAt" : "2019-04-05T22:50:19Z",
        "updatedAt" : "2019-04-10T22:04:00Z",
        "lastEditedBy" : "d4f34d8f-5341-4ac1-b8b2-5e5f11e23a5d",
        "tags" : [
        ]
      },
      {
        "id" : "00a79d9d-cd06-45b4-a0c4-46d1dc1fdc89",
        "parentId" : "80aa0aa3-414e-4f3a-ba22-91851fe2b275",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "Why you can't use runtime.HandleCrash() - it's pretty widely used in the codebase and allows to use additional custom handler too.",
        "createdAt" : "2019-04-10T11:17:47Z",
        "updatedAt" : "2019-04-10T22:04:00Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      },
      {
        "id" : "709dd81a-60fb-4606-a754-e0446dc3686c",
        "parentId" : "80aa0aa3-414e-4f3a-ba22-91851fe2b275",
        "authorId" : "d4f34d8f-5341-4ac1-b8b2-5e5f11e23a5d",
        "body" : "I had initially misunderstood it to catch the panic and swallow it. But it does still crash. Updating the PR to use it now.",
        "createdAt" : "2019-04-10T21:45:59Z",
        "updatedAt" : "2019-04-10T22:04:00Z",
        "lastEditedBy" : "d4f34d8f-5341-4ac1-b8b2-5e5f11e23a5d",
        "tags" : [
        ]
      }
    ],
    "commit" : "6a64ee638780de4dcfa2ab2b4fc739dd23127c49",
    "line" : 85,
    "diffHunk" : "@@ -1,1 +166,170 @@\tchunkC := make(chan runtime.Object, p.PageBufferSize)\n\tbgResultC := make(chan error, 1)\n\tgo func() {\n\t\tdefer utilruntime.HandleCrash()\n"
  },
  {
    "id" : "6b287eb1-8d8e-41e5-a6fd-ab804a86b523",
    "prId" : 75849,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/75849#pullrequestreview-223478409",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "861ac83d-a8d8-4704-a0ea-f8459d3dc0a0",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "error if `p.PageBufferSize <= 0`?",
        "createdAt" : "2019-04-05T03:29:34Z",
        "updatedAt" : "2019-04-10T22:04:00Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "cb7c6bd5-dd40-4fb1-9ab4-a43900c9d9d0",
        "parentId" : "861ac83d-a8d8-4704-a0ea-f8459d3dc0a0",
        "authorId" : "d4f34d8f-5341-4ac1-b8b2-5e5f11e23a5d",
        "body" : "Yes, set it to < since 0 size buffer is supported (tests demo this).",
        "createdAt" : "2019-04-05T21:03:28Z",
        "updatedAt" : "2019-04-10T22:04:00Z",
        "lastEditedBy" : "d4f34d8f-5341-4ac1-b8b2-5e5f11e23a5d",
        "tags" : [
        ]
      }
    ],
    "commit" : "6a64ee638780de4dcfa2ab2b4fc739dd23127c49",
    "line" : 83,
    "diffHunk" : "@@ -1,1 +164,168 @@\tdefer cancel()\n\n\tchunkC := make(chan runtime.Object, p.PageBufferSize)\n\tbgResultC := make(chan error, 1)\n\tgo func() {"
  },
  {
    "id" : "0d44ef68-915f-46eb-a9a3-b6f2f2bf7a79",
    "prId" : 75849,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/75849#pullrequestreview-225710714",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fd1adeb9-5e07-411b-9f2b-417b2135cf03",
        "parentId" : null,
        "authorId" : "42b1e004-4fa7-4e43-84cf-5378839b49ad",
        "body" : "I wonder if the buffer should be defined by the memory consumption instead of number of pages.\r\n\r\nWe can evaluate the size of a few chunks to dynamically determine the number of chunks to buffer, based on desired buffer size (in terms of memory).",
        "createdAt" : "2019-04-11T15:33:59Z",
        "updatedAt" : "2019-04-11T17:24:42Z",
        "lastEditedBy" : "42b1e004-4fa7-4e43-84cf-5378839b49ad",
        "tags" : [
        ]
      },
      {
        "id" : "74dc76b1-2699-46be-9f83-24d6aae140c7",
        "parentId" : "fd1adeb9-5e07-411b-9f2b-417b2135cf03",
        "authorId" : "d4f34d8f-5341-4ac1-b8b2-5e5f11e23a5d",
        "body" : "Interesting. Maybe wait and see how this approach works out and then optimize as needed from there? We previously had quite a bit of code doing full lists, and so as we transition to paginated lists and this sort of incremental processing my expectation is we'll reduce memory usage, particularly for object kinds that have large counts. If we still hit scalability/performance limits once this is in use, that would seem like a good time to look into optimizing this further .",
        "createdAt" : "2019-04-11T18:21:52Z",
        "updatedAt" : "2019-04-11T18:21:53Z",
        "lastEditedBy" : "d4f34d8f-5341-4ac1-b8b2-5e5f11e23a5d",
        "tags" : [
        ]
      },
      {
        "id" : "2e5b991f-858e-4673-8ba9-a655394cdbdc",
        "parentId" : "fd1adeb9-5e07-411b-9f2b-417b2135cf03",
        "authorId" : "42b1e004-4fa7-4e43-84cf-5378839b49ad",
        "body" : "Sounds good.",
        "createdAt" : "2019-04-11T18:24:42Z",
        "updatedAt" : "2019-04-11T18:24:42Z",
        "lastEditedBy" : "42b1e004-4fa7-4e43-84cf-5378839b49ad",
        "tags" : [
        ]
      }
    ],
    "commit" : "6a64ee638780de4dcfa2ab2b4fc739dd23127c49",
    "line" : 18,
    "diffHunk" : "@@ -1,1 +53,57 @@\n\t// Number of pages to buffer\n\tPageBufferSize int32\n}\n"
  },
  {
    "id" : "53c889f3-1739-4951-a705-13d09a79873c",
    "prId" : 48921,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/48921#pullrequestreview-51960882",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ad95eaa0-a658-46c8-a94e-2a808c7b76a0",
        "parentId" : null,
        "authorId" : "d4f34d8f-5341-4ac1-b8b2-5e5f11e23a5d",
        "body" : "I'm a bit concerned with falling back to the full list if the continuation expires, since it might be surprising to clients and they might not realize what's happened, particularly if the client is in somewhere in a larger software stack that makes assumptions about what it's getting back from the client.\r\n\r\nAre the immediate use cases that need this?\r\n\r\n@mbohlool any thoughts?",
        "createdAt" : "2017-07-24T22:29:53Z",
        "updatedAt" : "2017-09-01T14:50:06Z",
        "lastEditedBy" : "d4f34d8f-5341-4ac1-b8b2-5e5f11e23a5d",
        "tags" : [
        ]
      },
      {
        "id" : "c35ef3ea-ff11-4149-9a83-3ee7fad834c0",
        "parentId" : "ad95eaa0-a658-46c8-a94e-2a808c7b76a0",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Pager should not implicitly allow a Continuation (valuable to allow it to be explicitly specified).  Pager hides the details of how the List is returned - clients never see the partial behavior.\r\n\r\nIf we expire during a continuation, we are very likely to expire retrying the continuation.  The fallback is for informers, which can reasonably make the decision that full list is the correct thing to do (especially controller informers).",
        "createdAt" : "2017-07-25T05:09:21Z",
        "updatedAt" : "2017-09-01T14:50:06Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "7bf187b5-aa2b-4f45-93df-a55b83417a27",
        "parentId" : "ad95eaa0-a658-46c8-a94e-2a808c7b76a0",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Concretely, it is not intended that the consumer of this make any assumptions about what is returned by PageFn (and would definitely make it clear that PageFn may be invoked multiple times, out of order, etc).",
        "createdAt" : "2017-07-25T05:10:11Z",
        "updatedAt" : "2017-09-01T14:50:06Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      }
    ],
    "commit" : "9b8e42afa6d6abb459c332690c931585c0177b9c",
    "line" : 51,
    "diffHunk" : "@@ -1,1 +49,53 @@\tPageFn   ListPageFunc\n\n\tFullListIfExpired bool\n}\n"
  }
]
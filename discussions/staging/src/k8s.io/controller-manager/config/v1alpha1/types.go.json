[
  {
    "id" : "63bda0e6-d49b-414d-9386-951baba84bf6",
    "prId" : 94205,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/94205#pullrequestreview-495745732",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7db719d1-603a-4b37-8371-8996526dfccf",
        "parentId" : null,
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "I'd kinda like to see the validation code, I assume this will be checked on startup and controller manager will fail if it refers to an unknown controller?",
        "createdAt" : "2020-09-23T23:15:08Z",
        "updatedAt" : "2020-09-29T20:59:35Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "4e43ca61-5b11-4797-aec3-907f3c393731",
        "parentId" : "7db719d1-603a-4b37-8371-8996526dfccf",
        "authorId" : "7aca96c2-45d7-4567-99be-0323d7556c55",
        "body" : "+1. However that seems like the validation comes in more with the config load PR than the config schema. I think the controller manager should only fail if name matches the referenced controller manager and component is an unknown controller.",
        "createdAt" : "2020-09-24T16:25:03Z",
        "updatedAt" : "2020-09-29T20:59:35Z",
        "lastEditedBy" : "7aca96c2-45d7-4567-99be-0323d7556c55",
        "tags" : [
        ]
      }
    ],
    "commit" : "5e4f445df3d6387123008df2f2d14dc0808d01e7",
    "line" : 43,
    "diffHunk" : "@@ -1,1 +41,45 @@type ControllerLeaderConfiguration struct {\n\t// Name is the name of the controller being migrated\n\t// E.g. service-controller, route-controller, cloud-node-controller, etc\n\tName string `json:\"name\"`\n"
  },
  {
    "id" : "ca2c58a0-cc2b-41bd-baa4-61fe6a04779a",
    "prId" : 94205,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/94205#pullrequestreview-495754802",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ee355fff-d066-4f18-ad9c-84ebe47ade74",
        "parentId" : null,
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "I'm not sure I understand the rationale for plumbing this as a config file, which I guess is the plan? It seems like it will be easy to accidentally get it different between controller managers.\r\n\r\nDid you think about maybe using a configmap to make sure that all controller binaries can agree on this?\r\n\r\nSorry for not asking this in the KEP :)\r\n\r\n@cheftako @liggitt ",
        "createdAt" : "2020-09-23T23:18:38Z",
        "updatedAt" : "2020-09-29T20:59:35Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "39f9ccf0-e6af-47d8-981a-fdead00ac980",
        "parentId" : "ee355fff-d066-4f18-ad9c-84ebe47ade74",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "Consuming as a file lets you feed in config from practically any source, including a configmap.\r\n\r\nTying directly to an API-observed configmap either assumes that you'll consume the config from the same cluster you're managing (which isn't always desired) or requires adding a second API client config path.\r\n\r\ncc @deads2k for opinions on config via file vs API-fetched configmap.",
        "createdAt" : "2020-09-24T13:53:57Z",
        "updatedAt" : "2020-09-29T20:59:35Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "bbbf2fdc-6f11-4be3-a51a-7b7045b98549",
        "parentId" : "ee355fff-d066-4f18-ad9c-84ebe47ade74",
        "authorId" : "7aca96c2-45d7-4567-99be-0323d7556c55",
        "body" : "So the plan is a config file. I prefer the config file as its local to the control plane and safe from something like being accidentally deleted be a customer etc. Also we can ensure that the config files exist as part of all relevant version deployments as they are in the image, in either direction (upgrade or downgrade). Ensuring that the resource exists seems more error prone, especially in the downgrade case. Also the clean up of the file seems more natural. The 1.21 to 1.22 migration file exists in all 1.21 and 1.22 control plane releases. For the resource I have to worry about when its safe to delete (and re-add) the resource.",
        "createdAt" : "2020-09-24T16:32:42Z",
        "updatedAt" : "2020-09-29T20:59:35Z",
        "lastEditedBy" : "7aca96c2-45d7-4567-99be-0323d7556c55",
        "tags" : [
        ]
      },
      {
        "id" : "8bd3e534-a4f0-44f2-82a7-5f2b052eb84a",
        "parentId" : "ee355fff-d066-4f18-ad9c-84ebe47ade74",
        "authorId" : "7aca96c2-45d7-4567-99be-0323d7556c55",
        "body" : "Also as a resource this becomes and extension point for customers to disable built in controllers. Not sure that is something I want to \"accidentally\" implement.",
        "createdAt" : "2020-09-24T16:35:47Z",
        "updatedAt" : "2020-09-29T20:59:35Z",
        "lastEditedBy" : "7aca96c2-45d7-4567-99be-0323d7556c55",
        "tags" : [
        ]
      }
    ],
    "commit" : "5e4f445df3d6387123008df2f2d14dc0808d01e7",
    "line" : 25,
    "diffHunk" : "@@ -1,1 +23,27 @@// LeaderMigrationConfiguration provides versioned configuration for all migrating leader locks.\n// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object\ntype LeaderMigrationConfiguration struct {\n\tmetav1.TypeMeta `json:\",inline\"`\n"
  }
]
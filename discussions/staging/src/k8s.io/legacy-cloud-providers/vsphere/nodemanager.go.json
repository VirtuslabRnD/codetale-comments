[
  {
    "id" : "c360dc81-96bc-470a-af01-900b12e95e7e",
    "prId" : 98546,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/98546#pullrequestreview-580685374",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b53bc10f-6754-4bbd-82cd-9117aad05b31",
        "parentId" : null,
        "authorId" : "6dd71efb-88b1-4bb0-b30a-0df658362f14",
        "body" : "nit: group this import with other k8s.io imports below",
        "createdAt" : "2021-02-01T18:14:31Z",
        "updatedAt" : "2021-02-20T00:31:21Z",
        "lastEditedBy" : "6dd71efb-88b1-4bb0-b30a-0df658362f14",
        "tags" : [
        ]
      },
      {
        "id" : "8c465296-bee2-4202-9528-0f05649e280f",
        "parentId" : "b53bc10f-6754-4bbd-82cd-9117aad05b31",
        "authorId" : "c13045f9-cfc0-48e5-80df-ee48ddaa9fdc",
        "body" : "done.",
        "createdAt" : "2021-02-01T19:19:51Z",
        "updatedAt" : "2021-02-20T00:31:21Z",
        "lastEditedBy" : "c13045f9-cfc0-48e5-80df-ee48ddaa9fdc",
        "tags" : [
        ]
      }
    ],
    "commit" : "3e91ac26fbda2a2e82e56f809edfc8136384e83d",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +27,31 @@\t\"github.com/vmware/govmomi/object\"\n\t\"github.com/vmware/govmomi/vim25/mo\"\n\t\"k8s.io/klog/v2\"\n\n\tv1 \"k8s.io/api/core/v1\""
  },
  {
    "id" : "e4f88523-2edc-41b3-82f5-b60f2ad3d069",
    "prId" : 96689,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/96689#pullrequestreview-534262003",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "52a6c644-0361-4885-9b12-e52eb661e57b",
        "parentId" : null,
        "authorId" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "body" : "Missing godoc of a public func.",
        "createdAt" : "2020-11-19T10:08:38Z",
        "updatedAt" : "2020-11-19T11:32:03Z",
        "lastEditedBy" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "tags" : [
        ]
      }
    ],
    "commit" : "1a323279a287fdd73c6f3424c4ea3ca3b999ed1f",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +314,318 @@// GetNodeNames returns list of nodes that are known to vsphere cloudprovider.\n// These are typically nodes that make up k8s cluster.\nfunc (nm *NodeManager) GetNodeNames() []k8stypes.NodeName {\n\tnodes := nm.getNodes()\n\tvar nodeNameList []k8stypes.NodeName"
  },
  {
    "id" : "26900ee7-d829-46ca-86bc-0b8d40235e53",
    "prId" : 93971,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/93971#pullrequestreview-471416323",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4b44f259-2d37-4b33-965d-fd409bdd63b7",
        "parentId" : null,
        "authorId" : "e544b637-90c1-4f4b-8b7d-2481fbe23f92",
        "body" : "Should this be copying the nodes so that we don't mutate them later? Where is registered nodes updated, is this also done under lock?",
        "createdAt" : "2020-08-18T13:47:48Z",
        "updatedAt" : "2020-08-18T13:47:48Z",
        "lastEditedBy" : "e544b637-90c1-4f4b-8b7d-2481fbe23f92",
        "tags" : [
        ]
      },
      {
        "id" : "a0a5c162-07cb-4c37-b56b-a5ae9ae2e39c",
        "parentId" : "4b44f259-2d37-4b33-965d-fd409bdd63b7",
        "authorId" : "c13045f9-cfc0-48e5-80df-ee48ddaa9fdc",
        "body" : "`registeredNodes` returned from here are not updated in the workflow. \r\n\r\nI see in the `(nm *NodeManager) refreshNodes()` we are just iterating over the key `nodeName` and do not update the node object.\r\n\r\nwe can return copy of nodes instead of a pointer. This will require further refactoring as other methods in the workflow are accepting node pointer as argument.",
        "createdAt" : "2020-08-19T19:31:31Z",
        "updatedAt" : "2020-08-19T19:31:32Z",
        "lastEditedBy" : "c13045f9-cfc0-48e5-80df-ee48ddaa9fdc",
        "tags" : [
        ]
      },
      {
        "id" : "6aa55576-f1df-4d02-8e4f-796195eb64a6",
        "parentId" : "4b44f259-2d37-4b33-965d-fd409bdd63b7",
        "authorId" : "f0d74c44-88a9-4517-b04d-d11da56c6036",
        "body" : "@JoelSpeed Every operation with registeredNodes is now done under lock supervision, and none of them requires special isolation except the one provided by the defined operations like add or delete, which already locking the resource themselves for the further processing. Each resource operating on the node pointer will update the Node object under the pointer, which is the intent of the method - but will do this while locking the needed resource.",
        "createdAt" : "2020-08-20T01:27:35Z",
        "updatedAt" : "2020-08-20T01:27:36Z",
        "lastEditedBy" : "f0d74c44-88a9-4517-b04d-d11da56c6036",
        "tags" : [
        ]
      },
      {
        "id" : "a7b61ac9-d78f-4ee8-b08a-1c9ea0f338af",
        "parentId" : "4b44f259-2d37-4b33-965d-fd409bdd63b7",
        "authorId" : "e544b637-90c1-4f4b-8b7d-2481fbe23f92",
        "body" : "Just to clarify, what I meant was should we do `registerdNodes[nodeName] = node.DeepCopy()` which would return a copy that is still a pointer, it would be a very minor change that wouldn't need refactoring anywhere else.\r\n\r\nIf would seem like the point of this function is to create a copy of `nm.registeredNodes` so that outside actors aren't mutating the NodeManager's internal state, if we aren't doing a DeepCopy before returning the nodes, then outside actors can still modify the internal state.\r\n\r\nHaving looked at where this is used, the only thing we are actually using from the result of this function is the names of the objects anyway, so it is safe as it currently is, my concern would be if someone started using it to modify stuff later down the line.\r\n\r\nIt also looks like this could be simplified, we don't actually need the node object where it is being used, but that doesn't need to be addressed now.",
        "createdAt" : "2020-08-20T09:24:07Z",
        "updatedAt" : "2020-08-20T09:25:49Z",
        "lastEditedBy" : "e544b637-90c1-4f4b-8b7d-2481fbe23f92",
        "tags" : [
        ]
      }
    ],
    "commit" : "f67774bdb0ec3c3152b869385e4048a9e5fd8d44",
    "line" : 9,
    "diffHunk" : "@@ -1,1 +265,269 @@\tregisteredNodes := make(map[string]*v1.Node, len(nm.registeredNodes))\n\tfor nodeName, node := range nm.registeredNodes {\n\t\tregisteredNodes[nodeName] = node\n\t}\n\treturn registeredNodes"
  }
]
[
  {
    "id" : "520b62da-1e30-488c-8cae-9589e46de62d",
    "prId" : 99664,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/99664#pullrequestreview-609428842",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f94fa936-90ae-43cc-be9b-c258ba8c1f3b",
        "parentId" : null,
        "authorId" : "ddc05ecb-1a86-4393-8e22-f1bb528c2d50",
        "body" : "nit: add a return statement to remove a nest level. ",
        "createdAt" : "2021-03-11T06:36:16Z",
        "updatedAt" : "2021-03-15T17:59:59Z",
        "lastEditedBy" : "ddc05ecb-1a86-4393-8e22-f1bb528c2d50",
        "tags" : [
        ]
      }
    ],
    "commit" : "1f156016e663446e81b9e637537cd771b69d74c9",
    "line" : 35,
    "diffHunk" : "@@ -1,1 +2613,2617 @@\t\t\tif newDiskError != nil {\n\t\t\t\tklog.Errorf(\"Failed to delete the volume %v due to error: %v\", volumeName, newDiskError)\n\t\t\t} else {\n\t\t\t\tif _, deleteVolumeError := awsDisk.deleteVolume(); deleteVolumeError != nil {\n\t\t\t\t\tklog.Errorf(\"Failed to delete the volume %v due to error: %v\", volumeName, deleteVolumeError)"
  },
  {
    "id" : "d1791d0d-e280-4898-b9d5-dd9d233d4dd7",
    "prId" : 97431,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/97431#pullrequestreview-557423300",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f341c2bf-d81b-4159-b2fa-176066d50f6a",
        "parentId" : null,
        "authorId" : "ffc18181-54e6-47cb-b4d7-20ba5f2495ba",
        "body" : "i believe we are missing a `continue` here",
        "createdAt" : "2020-12-22T23:18:33Z",
        "updatedAt" : "2021-01-22T18:01:05Z",
        "lastEditedBy" : "ffc18181-54e6-47cb-b4d7-20ba5f2495ba",
        "tags" : [
        ]
      },
      {
        "id" : "1bba695f-76c9-44db-a991-5835192cbd31",
        "parentId" : "f341c2bf-d81b-4159-b2fa-176066d50f6a",
        "authorId" : "ba0afbcf-5c9d-474a-8aa1-0440347c4d34",
        "body" : "yes",
        "createdAt" : "2020-12-22T23:25:07Z",
        "updatedAt" : "2021-01-22T18:01:05Z",
        "lastEditedBy" : "ba0afbcf-5c9d-474a-8aa1-0440347c4d34",
        "tags" : [
        ]
      }
    ],
    "commit" : "778e97d3301e68b08f45f4fa12523a989e44388a",
    "line" : 54,
    "diffHunk" : "@@ -1,1 +3484,3488 @@\t\t\tif subnetHasClusterTag {\n\t\t\t\tsubnetsByAZ[az] = subnet\n\t\t\t}\n\t\t\tcontinue\n\t\t}"
  },
  {
    "id" : "8ad1de40-aa53-440a-ab50-99ae3bcd9c13",
    "prId" : 97431,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/97431#pullrequestreview-574480860",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3b6f4c01-9b0b-48eb-b289-f3037cfb52cf",
        "parentId" : null,
        "authorId" : "6dd71efb-88b1-4bb0-b30a-0df658362f14",
        "body" : "If `existing` has tags but `subnet` doesn't, wouldn't this use `subnet` when `existing` is preferred? ",
        "createdAt" : "2021-01-08T20:24:20Z",
        "updatedAt" : "2021-01-22T18:01:05Z",
        "lastEditedBy" : "6dd71efb-88b1-4bb0-b30a-0df658362f14",
        "tags" : [
        ]
      },
      {
        "id" : "63608458-2a4c-4832-baf0-89f92a667d44",
        "parentId" : "3b6f4c01-9b0b-48eb-b289-f3037cfb52cf",
        "authorId" : "ba0afbcf-5c9d-474a-8aa1-0440347c4d34",
        "body" : "In this case, `subnetHasClusterTag` wouldn't be true. So `subnet` doesn't replace `existing`.",
        "createdAt" : "2021-01-22T17:45:56Z",
        "updatedAt" : "2021-01-22T18:01:05Z",
        "lastEditedBy" : "ba0afbcf-5c9d-474a-8aa1-0440347c4d34",
        "tags" : [
        ]
      }
    ],
    "commit" : "778e97d3301e68b08f45f4fa12523a989e44388a",
    "line" : 53,
    "diffHunk" : "@@ -1,1 +3483,3487 @@\t\tif existingHasClusterTag != subnetHasClusterTag {\n\t\t\tif subnetHasClusterTag {\n\t\t\t\tsubnetsByAZ[az] = subnet\n\t\t\t}\n\t\t\tcontinue"
  },
  {
    "id" : "3a4a3585-daa5-45df-8b97-1d52aa0f95c5",
    "prId" : 97431,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/97431#pullrequestreview-574480860",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "72ba545c-bcb3-4c3b-a3c1-804856206515",
        "parentId" : null,
        "authorId" : "6dd71efb-88b1-4bb0-b30a-0df658362f14",
        "body" : "I might be misreading some code here, but wouldn't this check and the one above it be the same as \"all subnets regardless of tags\"?",
        "createdAt" : "2021-01-08T20:35:50Z",
        "updatedAt" : "2021-01-22T18:01:05Z",
        "lastEditedBy" : "6dd71efb-88b1-4bb0-b30a-0df658362f14",
        "tags" : [
        ]
      },
      {
        "id" : "f7155e71-c8f2-4e5e-8ccd-d9bed946a0cf",
        "parentId" : "72ba545c-bcb3-4c3b-a3c1-804856206515",
        "authorId" : "ba0afbcf-5c9d-474a-8aa1-0440347c4d34",
        "body" : "The `hasClusterTag` returns true only if the subnet is tagged for the current cluster. The `hasNoClusterPrefixTag` returns true only if the subnet has no tags with the `kubernetes.io/cluster/` prefix.\r\n\r\nThis returns all subnets but the ones tagged for different clusters.",
        "createdAt" : "2021-01-22T17:49:37Z",
        "updatedAt" : "2021-01-22T18:01:05Z",
        "lastEditedBy" : "ba0afbcf-5c9d-474a-8aa1-0440347c4d34",
        "tags" : [
        ]
      }
    ],
    "commit" : "778e97d3301e68b08f45f4fa12523a989e44388a",
    "line" : 30,
    "diffHunk" : "@@ -1,1 +3395,3399 @@\t\tif c.tagging.hasClusterTag(subnet.Tags) {\n\t\t\tmatches = append(matches, subnet)\n\t\t} else if c.tagging.hasNoClusterPrefixTag(subnet.Tags) {\n\t\t\tmatches = append(matches, subnet)\n\t\t}"
  },
  {
    "id" : "ef8d584d-02f1-4b7e-bb13-60844636b1ad",
    "prId" : 92839,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/92839#pullrequestreview-443303688",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "994b41d3-2e75-4582-9a06-a6094648aee1",
        "parentId" : null,
        "authorId" : "ffc18181-54e6-47cb-b4d7-20ba5f2495ba",
        "body" : "this should be the first statement",
        "createdAt" : "2020-07-06T18:12:29Z",
        "updatedAt" : "2020-07-14T06:21:58Z",
        "lastEditedBy" : "ffc18181-54e6-47cb-b4d7-20ba5f2495ba",
        "tags" : [
        ]
      }
    ],
    "commit" : "2dc4e6e6772eaae3c56a2cbf6980e2be05318d00",
    "line" : 23,
    "diffHunk" : "@@ -1,1 +4079,4083 @@func (c *Cloud) GetLoadBalancer(ctx context.Context, clusterName string, service *v1.Service) (*v1.LoadBalancerStatus, bool, error) {\n\tif isLBExternal(service.Annotations) {\n\t\treturn nil, false, nil\n\t}\n\tloadBalancerName := c.GetLoadBalancerName(ctx, clusterName, service)"
  },
  {
    "id" : "48946b75-0618-4ae2-aec0-7b8df5eb0256",
    "prId" : 92224,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/92224#pullrequestreview-435089629",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4bfdc379-856e-4c81-a54d-bee3b9ba57c3",
        "parentId" : null,
        "authorId" : "ee440732-7dd1-4a2c-b440-de4b66a84d9d",
        "body" : "Can you clarify that the auto-created or `CloudConfig.Global.ElbSecurityGroup` SG comes in the middle?",
        "createdAt" : "2020-06-22T16:29:40Z",
        "updatedAt" : "2020-06-22T16:35:31Z",
        "lastEditedBy" : "ee440732-7dd1-4a2c-b440-de4b66a84d9d",
        "tags" : [
        ]
      }
    ],
    "commit" : "549f9f35d497cdcafd6cb9f81f02be16d0a33ed0",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +3606,3610 @@// sortELBSecurityGroupList returns a list of sorted securityGroupIDs based on the original order\n// from buildELBSecurityGroupList. The logic is:\n//  * securityGroups specified by ServiceAnnotationLoadBalancerSecurityGroups appears first in order\n//  * securityGroups specified by ServiceAnnotationLoadBalancerExtraSecurityGroups appears last in order\nfunc (c *Cloud) sortELBSecurityGroupList(securityGroupIDs []string, annotations map[string]string) {"
  },
  {
    "id" : "1a399731-29b1-4bf2-b2de-acfe66bc03bf",
    "prId" : 92224,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/92224#pullrequestreview-435097932",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c83785a6-ad32-4b8d-a7f0-a68861a0f687",
        "parentId" : null,
        "authorId" : "ee440732-7dd1-4a2c-b440-de4b66a84d9d",
        "body" : "```suggestion\r\n//  * securityGroups specified by ServiceAnnotationLoadBalancerSecurityGroups appears first in order\r\n//  * global.ElbSecurityGroup or auto_created appears next\r\n//  * securityGroups specified by ServiceAnnotationLoadBalancerExtraSecurityGroups appears last in order\r\n```",
        "createdAt" : "2020-06-22T16:40:08Z",
        "updatedAt" : "2020-06-22T16:40:09Z",
        "lastEditedBy" : "ee440732-7dd1-4a2c-b440-de4b66a84d9d",
        "tags" : [
        ]
      }
    ],
    "commit" : "549f9f35d497cdcafd6cb9f81f02be16d0a33ed0",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +3607,3611 @@// from buildELBSecurityGroupList. The logic is:\n//  * securityGroups specified by ServiceAnnotationLoadBalancerSecurityGroups appears first in order\n//  * securityGroups specified by ServiceAnnotationLoadBalancerExtraSecurityGroups appears last in order\nfunc (c *Cloud) sortELBSecurityGroupList(securityGroupIDs []string, annotations map[string]string) {\n\tannotatedSGList := getSGListFromAnnotation(annotations[ServiceAnnotationLoadBalancerSecurityGroups])"
  },
  {
    "id" : "9e2caa6b-a8ac-42d8-b24c-ce4281d95f9d",
    "prId" : 92109,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/92109#pullrequestreview-434315479",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4695c99f-dfeb-4e5f-b817-fee4b22b38d6",
        "parentId" : null,
        "authorId" : "9be482a0-90db-482a-8b45-44658adcfdf1",
        "body" : "If `port.Protocol` is UDP, it doesn't make sense to register that port for TCP health-checks. And AWS NLB only offers the options of [HTTP, HTTPS, and TCP](https://docs.aws.amazon.com/elasticloadbalancing/latest/network/target-group-health-checks.html#health-check-settings).",
        "createdAt" : "2020-06-13T10:52:43Z",
        "updatedAt" : "2020-06-13T10:52:44Z",
        "lastEditedBy" : "9be482a0-90db-482a-8b45-44658adcfdf1",
        "tags" : [
        ]
      },
      {
        "id" : "dea98622-580b-4512-a37a-d73dfbe7986f",
        "parentId" : "4695c99f-dfeb-4e5f-b817-fee4b22b38d6",
        "authorId" : "9be482a0-90db-482a-8b45-44658adcfdf1",
        "body" : "Perhaps we can leave these unset in the UDP case (or use `elbv2.ProtocolEnumUdp` in case somehow that becomes valid), and catch that in `ensureTargetGroup`  where `externalTrafficPolicy == Local` is applied, and fail if we end up with an invalid health-check config. At least for a first iteration, it'd be an improvement on where we are now.",
        "createdAt" : "2020-06-13T11:29:45Z",
        "updatedAt" : "2020-06-16T19:50:22Z",
        "lastEditedBy" : "9be482a0-90db-482a-8b45-44658adcfdf1",
        "tags" : [
        ]
      },
      {
        "id" : "66b09167-ae2f-4da9-8814-8786d757c905",
        "parentId" : "4695c99f-dfeb-4e5f-b817-fee4b22b38d6",
        "authorId" : "ba0afbcf-5c9d-474a-8aa1-0440347c4d34",
        "body" : "Currently, AWS NLB doesn't support disabling the health check completely. Since the ( protocol, port) values are required, default (TCP, traffic-port) will get used if `externalTrafficPolicy` is set to `Cluster`. This will at least provide an option to run an auxiliary service that responds to the LB health queries.",
        "createdAt" : "2020-06-16T02:17:18Z",
        "updatedAt" : "2020-06-16T02:17:19Z",
        "lastEditedBy" : "ba0afbcf-5c9d-474a-8aa1-0440347c4d34",
        "tags" : [
        ]
      },
      {
        "id" : "98332fca-ac99-4a47-b199-62b428fe2970",
        "parentId" : "4695c99f-dfeb-4e5f-b817-fee4b22b38d6",
        "authorId" : "9be482a0-90db-482a-8b45-44658adcfdf1",
        "body" : "Is that worth the trade-off for surprising \"LB refuses to send you traffic\" results when there _isn't_ such an auxiliary service?",
        "createdAt" : "2020-06-16T19:50:06Z",
        "updatedAt" : "2020-06-16T19:50:06Z",
        "lastEditedBy" : "9be482a0-90db-482a-8b45-44658adcfdf1",
        "tags" : [
        ]
      },
      {
        "id" : "e0ca8a69-2bbd-461d-a05d-96a9f50c59db",
        "parentId" : "4695c99f-dfeb-4e5f-b817-fee4b22b38d6",
        "authorId" : "ba0afbcf-5c9d-474a-8aa1-0440347c4d34",
        "body" : "If all registered targets are unhealthy, NLB routes the requests across the unhealthy targets. Since a functional LB is still possible, IMO it doesn't add much value to fail the lb creation.\r\n\r\nThis does provide us an opportunity to have additional parameters for the health check configuration in future.",
        "createdAt" : "2020-06-19T19:31:17Z",
        "updatedAt" : "2020-06-19T19:31:17Z",
        "lastEditedBy" : "ba0afbcf-5c9d-474a-8aa1-0440347c4d34",
        "tags" : [
        ]
      },
      {
        "id" : "7c287596-0a88-4d34-9382-1f0ece757677",
        "parentId" : "4695c99f-dfeb-4e5f-b817-fee4b22b38d6",
        "authorId" : "ba0afbcf-5c9d-474a-8aa1-0440347c4d34",
        "body" : "https://github.com/kubernetes/kubernetes/issues/92321",
        "createdAt" : "2020-06-19T20:05:01Z",
        "updatedAt" : "2020-06-19T20:05:02Z",
        "lastEditedBy" : "ba0afbcf-5c9d-474a-8aa1-0440347c4d34",
        "tags" : [
        ]
      }
    ],
    "commit" : "f76c21cce6237b89f81883cef27b182f825dbab5",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +3681,3685 @@\t\t\t\tHealthCheckPort:     int64(port.NodePort),\n\t\t\t\tHealthCheckProtocol: elbv2.ProtocolEnumTcp,\n\t\t\t}\n\n\t\t\tcertificateARN := annotations[ServiceAnnotationLoadBalancerCertificate]"
  },
  {
    "id" : "79d11964-b803-4c60-85cb-64ed3bde55b6",
    "prId" : 91889,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/91889#pullrequestreview-426728752",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c6660b44-59e0-4063-9b7f-6ed15f58629c",
        "parentId" : null,
        "authorId" : "ffc18181-54e6-47cb-b4d7-20ba5f2495ba",
        "body" : "i'm not sure under which case will trigger(or even will them trigger?)\r\n`num, err := strconv.Atoi(strings.TrimSpace(numStr))` or `macID == \"\"` in above loop(which makes `macDevNum[mac] == 0`)\r\nwhich will be sorted same as `eth0`, that seems something we don't want üòÉ , \r\nmaybe \r\n      1. sort by order but make macDevNum[macID] to be biggest int(if above two case triggers)\r\n      2. ignore these macIDs. (personally prefer this)",
        "createdAt" : "2020-06-08T23:53:36Z",
        "updatedAt" : "2020-06-11T00:37:26Z",
        "lastEditedBy" : "ffc18181-54e6-47cb-b4d7-20ba5f2495ba",
        "tags" : [
        ]
      },
      {
        "id" : "bebf7d86-0712-419f-b197-cab418c4f1e0",
        "parentId" : "c6660b44-59e0-4063-9b7f-6ed15f58629c",
        "authorId" : "58cf89ce-9cc3-4dce-b99b-49ae3682cc9a",
        "body" : "Good call.  I've tweaked the loop a bit to ignore those bogus macIDs",
        "createdAt" : "2020-06-09T01:30:52Z",
        "updatedAt" : "2020-06-11T00:37:26Z",
        "lastEditedBy" : "58cf89ce-9cc3-4dce-b99b-49ae3682cc9a",
        "tags" : [
        ]
      }
    ],
    "commit" : "5a18f58dbd68887295f427502b91fd9bba3e24bc",
    "line" : 20,
    "diffHunk" : "@@ -1,1 +1438,1442 @@\n\t\t// Sort macIDs by interface device-number\n\t\tsort.Slice(macIDs, func(i, j int) bool {\n\t\t\treturn macDevNum[macIDs[i]] < macDevNum[macIDs[j]]\n\t\t})"
  },
  {
    "id" : "b41cfb89-fd0c-4e3c-9f44-77a01af65cbf",
    "prId" : 87839,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/87839#pullrequestreview-362769763",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "81f8d3cb-c1e7-4b3c-80ac-aeb12063e2de",
        "parentId" : null,
        "authorId" : "6dd71efb-88b1-4bb0-b30a-0df658362f14",
        "body" : "Is this a behavioral change from the AWS API? It seems like before you could never get a `InstanceNotFound` error from `DescribeInstances` (plural), but now you can if all instance IDs in the request are not found? \r\n",
        "createdAt" : "2020-02-06T20:08:42Z",
        "updatedAt" : "2020-02-21T16:33:22Z",
        "lastEditedBy" : "6dd71efb-88b1-4bb0-b30a-0df658362f14",
        "tags" : [
        ]
      },
      {
        "id" : "69e4fde4-0e62-4631-9a96-f691b063c7ed",
        "parentId" : "81f8d3cb-c1e7-4b3c-80ac-aeb12063e2de",
        "authorId" : "41981c80-b404-4c55-bd22-5f96c0512a61",
        "body" : "This is not a behavioral change. After a node got deleted, `DescribeInstances` shows it in terminated state for several hours. And after that `DescribeInstances` returns error with `InvalidInstanceID.NotFound `. ",
        "createdAt" : "2020-02-07T06:46:18Z",
        "updatedAt" : "2020-02-21T16:33:22Z",
        "lastEditedBy" : "41981c80-b404-4c55-bd22-5f96c0512a61",
        "tags" : [
        ]
      },
      {
        "id" : "d1841248-7f2c-4114-bdad-95e9ccdd6eeb",
        "parentId" : "81f8d3cb-c1e7-4b3c-80ac-aeb12063e2de",
        "authorId" : "6dd71efb-88b1-4bb0-b30a-0df658362f14",
        "body" : "Is that only if all instance IDs are terminated for several hours?",
        "createdAt" : "2020-02-07T17:55:25Z",
        "updatedAt" : "2020-02-21T16:33:22Z",
        "lastEditedBy" : "6dd71efb-88b1-4bb0-b30a-0df658362f14",
        "tags" : [
        ]
      },
      {
        "id" : "3cf0b46d-e961-4b50-b4f1-5fbe8961660a",
        "parentId" : "81f8d3cb-c1e7-4b3c-80ac-aeb12063e2de",
        "authorId" : "41981c80-b404-4c55-bd22-5f96c0512a61",
        "body" : "Only for this specific case, where only one instance ID is passed in, `InvalidInstanceID.NotFound` will be returned when that instance is terminated after several hours. Haven‚Äôt tested the behavior for list all case which is irrelevant here",
        "createdAt" : "2020-02-21T16:32:30Z",
        "updatedAt" : "2020-02-21T16:38:33Z",
        "lastEditedBy" : "41981c80-b404-4c55-bd22-5f96c0512a61",
        "tags" : [
        ]
      },
      {
        "id" : "c34f3ad8-3411-446d-80f7-aee7c58e5723",
        "parentId" : "81f8d3cb-c1e7-4b3c-80ac-aeb12063e2de",
        "authorId" : "6dd71efb-88b1-4bb0-b30a-0df658362f14",
        "body" : "One more clarifying question -- is the same error returned when we fetch for only 1 instance (i.e. `DescribeInstance`) or is there a separate error value for that? \r\n\r\nConcerned about future changes using `isAWSErrorInstanceNotFound` assuming it also handles error from `DescribeInstance`. ",
        "createdAt" : "2020-02-21T16:47:35Z",
        "updatedAt" : "2020-02-21T16:47:35Z",
        "lastEditedBy" : "6dd71efb-88b1-4bb0-b30a-0df658362f14",
        "tags" : [
        ]
      },
      {
        "id" : "91b7bfc3-8f0f-4ba7-aaa4-7e1f37c0efe8",
        "parentId" : "81f8d3cb-c1e7-4b3c-80ac-aeb12063e2de",
        "authorId" : "6dd71efb-88b1-4bb0-b30a-0df658362f14",
        "body" : "nvm I see there's no `DescribeInstance` method anyways.. thought there was for some reason",
        "createdAt" : "2020-02-21T16:50:03Z",
        "updatedAt" : "2020-02-21T16:50:03Z",
        "lastEditedBy" : "6dd71efb-88b1-4bb0-b30a-0df658362f14",
        "tags" : [
        ]
      }
    ],
    "commit" : "2568b552c840f8ad99dd11b88bc4c607a8528a84",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +1590,1594 @@\tif err != nil {\n\t\t// if err is InstanceNotFound, return false with no error\n\t\tif isAWSErrorInstanceNotFound(err) {\n\t\t\treturn false, nil\n\t\t}"
  },
  {
    "id" : "1cb91ffd-0075-4573-b734-7382e93de78a",
    "prId" : 84265,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/84265#pullrequestreview-342062989",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "94b0330c-e0bc-4013-a64f-d86948e8dcfe",
        "parentId" : null,
        "authorId" : "ffc18181-54e6-47cb-b4d7-20ba5f2495ba",
        "body" : "nit: can be replaced by `sgList = append(sgList, extraSGList...)`",
        "createdAt" : "2020-01-13T18:38:43Z",
        "updatedAt" : "2020-01-13T20:56:42Z",
        "lastEditedBy" : "ffc18181-54e6-47cb-b4d7-20ba5f2495ba",
        "tags" : [
        ]
      },
      {
        "id" : "63e8e053-941d-43e0-bafd-309cfca6093e",
        "parentId" : "94b0330c-e0bc-4013-a64f-d86948e8dcfe",
        "authorId" : "5c48d1d9-a919-4a0d-9137-1aa038525e28",
        "body" : "Yeah , I was looking at the Golang doc I couldn't figure out if we have something to just append without own loop.",
        "createdAt" : "2020-01-13T18:54:56Z",
        "updatedAt" : "2020-01-13T20:56:42Z",
        "lastEditedBy" : "5c48d1d9-a919-4a0d-9137-1aa038525e28",
        "tags" : [
        ]
      }
    ],
    "commit" : "1ee86328ae679e70b461cf5902e8b0c33346cf6e",
    "line" : 71,
    "diffHunk" : "@@ -1,1 +3542,3546 @@\t}\n\n\textraSGList := getSGListFromAnnotation(annotations[ServiceAnnotationLoadBalancerExtraSecurityGroups])\n\tsgList = append(sgList, extraSGList...)\n"
  },
  {
    "id" : "2f372852-b645-4aaf-a6cc-b5e140f400e3",
    "prId" : 84265,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/84265#pullrequestreview-342062989",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2703e416-4ceb-405a-b156-35ef1a607227",
        "parentId" : null,
        "authorId" : "ffc18181-54e6-47cb-b4d7-20ba5f2495ba",
        "body" : "nit, while whole part can be reorganized to like to make the logic more clear. But current one is ok too.\r\n```\r\nif len(sgList) == 0 {\r\n    var securityGroupID string\r\n    if c.cfg.Global.ElbSecurityGroup != \"\" {\r\n       ...\r\n    } else {\r\n        ...\r\n    }\r\n    sgList = append(sgList, securityGroupID)\r\n}\r\n```",
        "createdAt" : "2020-01-13T18:40:44Z",
        "updatedAt" : "2020-01-13T20:56:42Z",
        "lastEditedBy" : "ffc18181-54e6-47cb-b4d7-20ba5f2495ba",
        "tags" : [
        ]
      },
      {
        "id" : "a1727bef-be4a-4663-b0a4-41378d48b4d9",
        "parentId" : "2703e416-4ceb-405a-b156-35ef1a607227",
        "authorId" : "5c48d1d9-a919-4a0d-9137-1aa038525e28",
        "body" : "Good point , Thanks for the tip.",
        "createdAt" : "2020-01-13T18:54:18Z",
        "updatedAt" : "2020-01-13T20:56:42Z",
        "lastEditedBy" : "5c48d1d9-a919-4a0d-9137-1aa038525e28",
        "tags" : [
        ]
      }
    ],
    "commit" : "1ee86328ae679e70b461cf5902e8b0c33346cf6e",
    "line" : 47,
    "diffHunk" : "@@ -1,1 +3524,3528 @@\t// The below code changes makes sure that when we have Security Groups  specified with the ServiceAnnotationLoadBalancerSecurityGroups\n\t// annotation we don't create a new default Security Groups\n\n\t// If no Security Groups have been specified with the ServiceAnnotationLoadBalancerSecurityGroups annotation, we add the default one.\n\tif len(sgList) == 0 {"
  },
  {
    "id" : "b5ab7a41-7158-4a12-ba58-2beeed795f81",
    "prId" : 84265,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/84265#pullrequestreview-342062989",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ed8ceed5-f870-48d2-b49d-1cb9aae77533",
        "parentId" : null,
        "authorId" : "ffc18181-54e6-47cb-b4d7-20ba5f2495ba",
        "body" : "how about ServiceAnnotationLoadBalancerExtraSecurityGroups :D ",
        "createdAt" : "2020-01-13T18:41:17Z",
        "updatedAt" : "2020-01-13T20:56:42Z",
        "lastEditedBy" : "ffc18181-54e6-47cb-b4d7-20ba5f2495ba",
        "tags" : [
        ]
      },
      {
        "id" : "43faf277-6a97-404e-95c4-bcd40b7b4f43",
        "parentId" : "ed8ceed5-f870-48d2-b49d-1cb9aae77533",
        "authorId" : "5c48d1d9-a919-4a0d-9137-1aa038525e28",
        "body" : "Yes Sure can be and should be added.",
        "createdAt" : "2020-01-13T18:55:09Z",
        "updatedAt" : "2020-01-13T20:56:42Z",
        "lastEditedBy" : "5c48d1d9-a919-4a0d-9137-1aa038525e28",
        "tags" : [
        ]
      }
    ],
    "commit" : "1ee86328ae679e70b461cf5902e8b0c33346cf6e",
    "line" : 81,
    "diffHunk" : "@@ -1,1 +4352,4356 @@\t\tsecurityGroupIDs := map[string]struct{}{}\n\t\tannotatedSgSet := map[string]bool{}\n\t\tannotatedSgsList := getSGListFromAnnotation(service.Annotations[ServiceAnnotationLoadBalancerSecurityGroups])\n\t\tannotatedExtraSgsList := getSGListFromAnnotation(service.Annotations[ServiceAnnotationLoadBalancerExtraSecurityGroups])\n\t\tannotatedSgsList = append(annotatedSgsList, annotatedExtraSgsList...)"
  },
  {
    "id" : "685284d9-7c01-4b18-9026-0f84dafb6da5",
    "prId" : 84181,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/84181#pullrequestreview-305422163",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6b3cb4b9-e172-4f26-ae6c-3370c4c0886e",
        "parentId" : null,
        "authorId" : "241ab19e-f85a-4d22-92e2-88f2b6287d14",
        "body" : "very very good idea. üëç ",
        "createdAt" : "2019-10-22T18:34:55Z",
        "updatedAt" : "2019-10-22T18:34:55Z",
        "lastEditedBy" : "241ab19e-f85a-4d22-92e2-88f2b6287d14",
        "tags" : [
        ]
      }
    ],
    "commit" : "b3bd620b2a47fa3ed7397a4afef3a7ac3d604adf",
    "line" : 40,
    "diffHunk" : "@@ -1,1 +2121,2125 @@\t// polling DescribeVolumes before some initial delay to let AWS\n\t// process the request.\n\ttime.Sleep(getInitialAttachDetachDelay(status))\n\n\tvar attachment *ec2.VolumeAttachment"
  },
  {
    "id" : "d82a306c-4f0f-495f-93dd-a3f442e4b78b",
    "prId" : 84181,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/84181#pullrequestreview-305688528",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7beefc7e-f648-416a-b96f-14854a6e78e8",
        "parentId" : null,
        "authorId" : "241ab19e-f85a-4d22-92e2-88f2b6287d14",
        "body" : "any ideas for metrics that could help us tune this more in the future, if necessary? How did you figure out that 2s is average?",
        "createdAt" : "2019-10-22T18:36:30Z",
        "updatedAt" : "2019-10-22T18:36:31Z",
        "lastEditedBy" : "241ab19e-f85a-4d22-92e2-88f2b6287d14",
        "tags" : [
        ]
      },
      {
        "id" : "31410d84-ced5-4168-a2f5-7a073489fc0b",
        "parentId" : "7beefc7e-f648-416a-b96f-14854a6e78e8",
        "authorId" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "body" : "I set really high frequency of DescribeVolumes polling and ran bunch of tests.\r\n\r\nWe still have metric `storage_operation_duration_seconds_sum{volume_plugin=\" kubernetes.io/aws-ebs\", operation_name=\"volume_attach\"}`, but it includes `DescribeInstance` + `AttachVolume` calls + `DescribeVolumes` polling.",
        "createdAt" : "2019-10-23T07:43:51Z",
        "updatedAt" : "2019-10-23T07:43:51Z",
        "lastEditedBy" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "tags" : [
        ]
      }
    ],
    "commit" : "b3bd620b2a47fa3ed7397a4afef3a7ac3d604adf",
    "line" : 44,
    "diffHunk" : "@@ -1,1 +2125,2129 @@\tvar attachment *ec2.VolumeAttachment\n\n\terr := wait.ExponentialBackoff(backoff, func() (bool, error) {\n\t\tinfo, err := d.describeVolume()\n\t\tif err != nil {"
  },
  {
    "id" : "54fdd4cd-0479-4f04-90a3-ba41f53083d8",
    "prId" : 83446,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/83446#pullrequestreview-337079628",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ea052c0c-5b55-47ac-8e00-aafcbfafe925",
        "parentId" : null,
        "authorId" : "241ab19e-f85a-4d22-92e2-88f2b6287d14",
        "body" : "I think we want to return a map[string]bool to make it possible to express that only the kubernetes-created securitygroup should be setup. I don't mind complicating this function's signature as long as it's documented and tested",
        "createdAt" : "2019-12-23T21:50:45Z",
        "updatedAt" : "2020-01-25T19:23:48Z",
        "lastEditedBy" : "241ab19e-f85a-4d22-92e2-88f2b6287d14",
        "tags" : [
        ]
      },
      {
        "id" : "d0e0a568-565b-4a86-89ca-c189bbd5922b",
        "parentId" : "ea052c0c-5b55-47ac-8e00-aafcbfafe925",
        "authorId" : "39701c5d-fe0a-4486-a319-47925bbceb10",
        "body" : "So this is ok I understad as it is exactly doing this (the bool is only true if a SG has been setup because neighter `service.beta.kubernetes.io/aws-load-balancer-security-groups` was specified nor a global `ElbSecurityGroup`.",
        "createdAt" : "2019-12-30T11:40:46Z",
        "updatedAt" : "2020-01-25T19:23:48Z",
        "lastEditedBy" : "39701c5d-fe0a-4486-a319-47925bbceb10",
        "tags" : [
        ]
      }
    ],
    "commit" : "ed2f1a6f42816498d866c167bab4d234632674d5",
    "line" : 17,
    "diffHunk" : "@@ -1,1 +3511,3515 @@// new groups. The annotation \"ServiceAnnotationLoadBalancerSecurityGroups\" allows for\n// setting the security groups specified.\nfunc (c *Cloud) buildELBSecurityGroupList(serviceName types.NamespacedName, loadBalancerName string, annotations map[string]string) ([]string, bool, error) {\n\tvar err error\n\tvar securityGroupID string"
  },
  {
    "id" : "bc7c98c8-9729-47b2-ac7b-91dae3c2ebf7",
    "prId" : 83446,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/83446#pullrequestreview-363198751",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5cf4e2c1-9945-4426-b387-9cd3f30a7a93",
        "parentId" : null,
        "authorId" : "5c48d1d9-a919-4a0d-9137-1aa038525e28",
        "body" : "Duplicating the same code , the previous version was good I think.",
        "createdAt" : "2020-02-22T19:53:22Z",
        "updatedAt" : "2020-02-22T20:02:47Z",
        "lastEditedBy" : "5c48d1d9-a919-4a0d-9137-1aa038525e28",
        "tags" : [
        ]
      },
      {
        "id" : "a62a9ae0-532a-4edd-9d05-3685b2d319f7",
        "parentId" : "5cf4e2c1-9945-4426-b387-9cd3f30a7a93",
        "authorId" : "39701c5d-fe0a-4486-a319-47925bbceb10",
        "body" : "Hmm code duplication is something else for me. It would not save any line if intermediate variable is used here and the add to list is consolidated into the outer block and for me I did it to have it more readable / understandable what happens in which branch, but yes can change it back if other like the previous way more.",
        "createdAt" : "2020-02-23T08:27:34Z",
        "updatedAt" : "2020-02-23T08:27:35Z",
        "lastEditedBy" : "39701c5d-fe0a-4486-a319-47925bbceb10",
        "tags" : [
        ]
      },
      {
        "id" : "b574fc00-ad88-42dc-b5d0-da3579d4bb67",
        "parentId" : "5cf4e2c1-9945-4426-b387-9cd3f30a7a93",
        "authorId" : "5c48d1d9-a919-4a0d-9137-1aa038525e28",
        "body" : "If we think this improves the readability then I am good with that.\r\n\r\nWas just thinking the codebase like kubernetes/Kubernetes if we have similar code then it would be too many duplicate coding.\r\nLike in this change itself , the setupSg was set to false and was not updated again in the if block\r\n```\r\nif c.cfg.Global.ElbSecurityGroup != \"\" {\r\n\r\n```\r\nBecause its duplicate but would definitely add readability that ok the value is  set to false irrespective of what has been set earlier.\r\n\r\n",
        "createdAt" : "2020-02-23T09:36:15Z",
        "updatedAt" : "2020-02-23T09:37:10Z",
        "lastEditedBy" : "5c48d1d9-a919-4a0d-9137-1aa038525e28",
        "tags" : [
        ]
      },
      {
        "id" : "be381bf8-69e3-418d-afaa-a80c1ea0ca46",
        "parentId" : "5cf4e2c1-9945-4426-b387-9cd3f30a7a93",
        "authorId" : "39701c5d-fe0a-4486-a319-47925bbceb10",
        "body" : "I think an append to array line is not something very different to an assignment so no additional duplicated code. But at the end I'd be fine with both ways.\r\n\r\nFor the setupSg the intention was to show: it's always as default False and should only in explicit case be set to true. Of course we could set it a 2nd time to false in `if c.cfg.Global.ElbSecurityGroup != \"\" {` block and another time in an else block to the `if len(sgList) == 0 {` but for me this would be too much.\r\n\r\nAnyway at the end I'm fine to change the code style, I just want the fix :-D",
        "createdAt" : "2020-02-24T07:22:09Z",
        "updatedAt" : "2020-02-24T07:22:09Z",
        "lastEditedBy" : "39701c5d-fe0a-4486-a319-47925bbceb10",
        "tags" : [
        ]
      }
    ],
    "commit" : "ed2f1a6f42816498d866c167bab4d234632674d5",
    "line" : 32,
    "diffHunk" : "@@ -1,1 +3522,3526 @@\tif len(sgList) == 0 {\n\t\tif c.cfg.Global.ElbSecurityGroup != \"\" {\n\t\t\tsgList = append(sgList, c.cfg.Global.ElbSecurityGroup)\n\t\t} else {\n\t\t\t// Create a security group for the load balancer"
  },
  {
    "id" : "20f82e82-ea97-4b0e-91c1-4bfd126df0bc",
    "prId" : 83446,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/83446#pullrequestreview-365348745",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6ac50b05-01bf-4636-a702-e582a38a5f3f",
        "parentId" : null,
        "authorId" : "ddc05ecb-1a86-4393-8e22-f1bb528c2d50",
        "body" : "Might be more clear to return the default SG separately instead of the bool, that way you can check for its existence and its obvious that we're only passing that one to `setSecurityGroupIngress().` ",
        "createdAt" : "2020-02-26T19:10:27Z",
        "updatedAt" : "2020-02-26T19:10:49Z",
        "lastEditedBy" : "ddc05ecb-1a86-4393-8e22-f1bb528c2d50",
        "tags" : [
        ]
      },
      {
        "id" : "3f286aff-f386-4245-9afc-510e1cf18973",
        "parentId" : "6ac50b05-01bf-4636-a702-e582a38a5f3f",
        "authorId" : "5c48d1d9-a919-4a0d-9137-1aa038525e28",
        "body" : "@nckturner ,\r\n\r\nBut here is the problem with that in case of SG is coming from c.cfg.Global.ElbSecurityGroup we would not be able to understand the difference in the calling function and based on the behavior we don't want to change the Ingress of Global SG.",
        "createdAt" : "2020-02-27T00:51:47Z",
        "updatedAt" : "2020-02-27T00:51:47Z",
        "lastEditedBy" : "5c48d1d9-a919-4a0d-9137-1aa038525e28",
        "tags" : [
        ]
      }
    ],
    "commit" : "ed2f1a6f42816498d866c167bab4d234632674d5",
    "line" : 17,
    "diffHunk" : "@@ -1,1 +3511,3515 @@// new groups. The annotation \"ServiceAnnotationLoadBalancerSecurityGroups\" allows for\n// setting the security groups specified.\nfunc (c *Cloud) buildELBSecurityGroupList(serviceName types.NamespacedName, loadBalancerName string, annotations map[string]string) ([]string, bool, error) {\n\tvar err error\n\tvar securityGroupID string"
  },
  {
    "id" : "81057ac6-5b55-4047-a461-fc47de35c0d3",
    "prId" : 83446,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/83446#pullrequestreview-365733325",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c0a058f6-09a7-412f-8229-33c38d0f97aa",
        "parentId" : null,
        "authorId" : "2d9afee7-a404-4340-8fd9-d3187ed4f1da",
        "body" : "s/setupSg/setUpSG/",
        "createdAt" : "2020-02-27T14:56:39Z",
        "updatedAt" : "2020-02-27T14:56:40Z",
        "lastEditedBy" : "2d9afee7-a404-4340-8fd9-d3187ed4f1da",
        "tags" : [
        ]
      }
    ],
    "commit" : "ed2f1a6f42816498d866c167bab4d234632674d5",
    "line" : 21,
    "diffHunk" : "@@ -1,1 +3515,3519 @@\tvar securityGroupID string\n\t// We do not want to make changes to a Global defined SG\n\tvar setupSg = false\n\n\tsgList := getSGListFromAnnotation(annotations[ServiceAnnotationLoadBalancerSecurityGroups])"
  },
  {
    "id" : "122fdc22-26cf-436c-902d-81528a9e67cd",
    "prId" : 80747,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/80747#pullrequestreview-276526162",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "67933852-444b-44b6-a05b-2e626c15248a",
        "parentId" : null,
        "authorId" : "4aab55a0-5299-4d58-b630-6d54a352dba8",
        "body" : "If I'm reading that, this assumes that when you query for, say, `network/interfaces/macs/00:11:22:33:44:55/device-number`, that the device numbers will be stable and that the lowest numbered one will always be the primary IP.  Is that correct?  If so, I'd like you to add a comment stating this assumption (preferably that AWS guarantees not to renumber interfaces behind our back).",
        "createdAt" : "2019-08-19T12:34:41Z",
        "updatedAt" : "2019-08-19T14:14:24Z",
        "lastEditedBy" : "4aab55a0-5299-4d58-b630-6d54a352dba8",
        "tags" : [
        ]
      }
    ],
    "commit" : "a4bac275faa56fc44ba1564b9954c0f24d288428",
    "line" : 26,
    "diffHunk" : "@@ -1,1 +1422,1426 @@\t\t\t}\n\t\t\tipPath := path.Join(\"network/interfaces/macs/\", macID, \"local-ipv4s\")\n\t\t\tmacIPs[num], err = c.metadata.GetMetadata(ipPath)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"error querying AWS metadata for %q: %q\", ipPath, err)"
  },
  {
    "id" : "9d5f7013-02a7-48d3-8a6b-0a2fd663f550",
    "prId" : 80747,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/80747#pullrequestreview-425946088",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "273e9367-36bc-4444-a9f5-b7560638dafa",
        "parentId" : null,
        "authorId" : "ffc18181-54e6-47cb-b4d7-20ba5f2495ba",
        "body" : "i'm not sure how much impact it will cause, but this code itself is not safe. \r\nyou can easily have cases where there are only `eth0` and `eth2` by detach interfaces. and this code will miss eth2.",
        "createdAt" : "2020-06-04T17:32:00Z",
        "updatedAt" : "2020-06-04T17:32:00Z",
        "lastEditedBy" : "ffc18181-54e6-47cb-b4d7-20ba5f2495ba",
        "tags" : [
        ]
      },
      {
        "id" : "b1991d1c-652b-4d06-ab93-6b0e066e0a2b",
        "parentId" : "273e9367-36bc-4444-a9f5-b7560638dafa",
        "authorId" : "58cf89ce-9cc3-4dce-b99b-49ae3682cc9a",
        "body" : "Opened https://github.com/kubernetes/kubernetes/issues/91888",
        "createdAt" : "2020-06-08T06:34:48Z",
        "updatedAt" : "2020-06-08T06:34:54Z",
        "lastEditedBy" : "58cf89ce-9cc3-4dce-b99b-49ae3682cc9a",
        "tags" : [
        ]
      }
    ],
    "commit" : "a4bac275faa56fc44ba1564b9954c0f24d288428",
    "line" : 32,
    "diffHunk" : "@@ -1,1 +1428,1432 @@\t\t}\n\n\t\tfor i := 0; i < len(macIPs); i++ {\n\t\t\tinternalIPs := macIPs[i]\n\t\t\tif internalIPs == \"\" {"
  },
  {
    "id" : "f2b89510-f933-4f4e-b41f-5ceabe1d58fe",
    "prId" : 78601,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/78601#pullrequestreview-248787225",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e74118b4-9de6-4fbb-9988-256c7f6496ec",
        "parentId" : null,
        "authorId" : "255dd885-bee4-4c1f-baef-ba11f903dc5c",
        "body" : "> it has not been silently removed by AWS\r\n\r\nSeems like this is no longer accurate",
        "createdAt" : "2019-06-12T14:10:18Z",
        "updatedAt" : "2019-06-24T17:58:55Z",
        "lastEditedBy" : "255dd885-bee4-4c1f-baef-ba11f903dc5c",
        "tags" : [
        ]
      }
    ],
    "commit" : "2eeb863da80c6e4b64a80c2a36fb877bff5066fe",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +227,231 @@\n\t// volumeCreate* is configuration of exponential backoff for created volume.\n\t// On a random AWS account (shared among several developers) it took 4s on\n\t// average, 8s max.\n\tvolumeCreateInitialDelay  = 5 * time.Second"
  },
  {
    "id" : "9e037a48-0161-4104-b20d-7076c06c514c",
    "prId" : 78601,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/78601#pullrequestreview-250102654",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0edc0683-2a6b-4a74-a874-38c20c60b128",
        "parentId" : null,
        "authorId" : "255dd885-bee4-4c1f-baef-ba11f903dc5c",
        "body" : "> It might even be better to not poll volume immediately after creation at all because volume is never available immediately after creation. But I see that ExponentialBackoff does not offer a way to do that.\r\n\r\nYeah, that could save us a `DescribeVolume` request, which might be helpful for clusters hitting the AWS quota limit.\r\n\r\nWhat if we use `PollUntil` instead? `PollUntil` waits the interval before firing the function.",
        "createdAt" : "2019-06-12T14:40:37Z",
        "updatedAt" : "2019-06-24T17:58:55Z",
        "lastEditedBy" : "255dd885-bee4-4c1f-baef-ba11f903dc5c",
        "tags" : [
        ]
      },
      {
        "id" : "db036fc1-58d7-4b1a-953a-527b0836c3d1",
        "parentId" : "0edc0683-2a6b-4a74-a874-38c20c60b128",
        "authorId" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "body" : "I am fine with adding `time.Sleep(5 * time.Second)` before proceeding with exponential backoff.  It has same effect as anything else and works with exponential backoff..",
        "createdAt" : "2019-06-14T20:16:54Z",
        "updatedAt" : "2019-06-24T17:58:55Z",
        "lastEditedBy" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "tags" : [
        ]
      }
    ],
    "commit" : "2eeb863da80c6e4b64a80c2a36fb877bff5066fe",
    "line" : 30,
    "diffHunk" : "@@ -1,1 +2426,2430 @@\t\tSteps:    volumeCreateBackoffSteps,\n\t}\n\terr = wait.ExponentialBackoff(backoff, func() (done bool, err error) {\n\t\tvol, err := disk.describeVolume()\n\t\tif err != nil {"
  },
  {
    "id" : "da17bd1d-bf24-4368-92b0-7d98d95c332b",
    "prId" : 78140,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/78140#pullrequestreview-256652277",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7ec710f5-929c-4882-b5c2-4f15fd743e44",
        "parentId" : null,
        "authorId" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "body" : "Does this require a RBAC policy change so as AWS cloudprovider can list nodes?",
        "createdAt" : "2019-07-01T14:48:53Z",
        "updatedAt" : "2019-07-01T16:14:36Z",
        "lastEditedBy" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "tags" : [
        ]
      },
      {
        "id" : "1e70ceeb-e390-4b19-b393-9c8694d419a2",
        "parentId" : "7ec710f5-929c-4882-b5c2-4f15fd743e44",
        "authorId" : "3f2a59ab-16d4-4e6a-90df-56d3c62d3d44",
        "body" : "Good question! I checked that after v1.15, we have deprecated auto-provisioned cloud provider role, and have user to create them https://github.com/kubernetes/kubernetes/pull/66635\r\n\r\nI will modify the release note about the face that we need \"list\" permission now.",
        "createdAt" : "2019-07-01T16:01:54Z",
        "updatedAt" : "2019-07-01T16:16:52Z",
        "lastEditedBy" : "3f2a59ab-16d4-4e6a-90df-56d3c62d3d44",
        "tags" : [
        ]
      },
      {
        "id" : "6202138f-9730-41db-96dd-9ccb374a6d05",
        "parentId" : "7ec710f5-929c-4882-b5c2-4f15fd743e44",
        "authorId" : "3f2a59ab-16d4-4e6a-90df-56d3c62d3d44",
        "body" : "Also, @justinsb we might want to modify kops in this case as well? https://github.com/kubernetes/kops/pull/6899",
        "createdAt" : "2019-07-01T16:17:15Z",
        "updatedAt" : "2019-07-01T16:17:15Z",
        "lastEditedBy" : "3f2a59ab-16d4-4e6a-90df-56d3c62d3d44",
        "tags" : [
        ]
      },
      {
        "id" : "25015f59-33ea-47ff-8483-2345ce77532c",
        "parentId" : "7ec710f5-929c-4882-b5c2-4f15fd743e44",
        "authorId" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "body" : "I do not remember if we need a RBAC rule if we are using a shared informer. If we do not - we are probably fine.  We need to confirm that...",
        "createdAt" : "2019-07-01T21:40:21Z",
        "updatedAt" : "2019-07-01T21:40:21Z",
        "lastEditedBy" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "tags" : [
        ]
      },
      {
        "id" : "763af243-f100-475c-aa35-d92d87d5e68c",
        "parentId" : "7ec710f5-929c-4882-b5c2-4f15fd743e44",
        "authorId" : "3f2a59ab-16d4-4e6a-90df-56d3c62d3d44",
        "body" : "actually @justinsb I did some tests and verified that we do not need additional RBAC rules for `system:aws-cloud-provider` to use shared informer. Our clusters are provisioned using kops and all roles contain default values",
        "createdAt" : "2019-07-02T03:43:55Z",
        "updatedAt" : "2019-07-02T03:43:55Z",
        "lastEditedBy" : "3f2a59ab-16d4-4e6a-90df-56d3c62d3d44",
        "tags" : [
        ]
      }
    ],
    "commit" : "6ae76205d7a63a64a0178fb0edded9967d11a66e",
    "line" : 87,
    "diffHunk" : "@@ -1,1 +4549,4553 @@\n\tnode, err := c.nodeInformer.Lister().Get(string(nodeName))\n\tif err != nil {\n\t\treturn \"\", err\n\t}"
  },
  {
    "id" : "7f21e824-09a9-4ef7-a7fa-c6d70b6b0c43",
    "prId" : 76976,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/76976#pullrequestreview-240396421",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e16c97a4-4701-4dae-bf9d-7f2f29c80eaa",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "what behavior is being attached to these labels in this PR? Since these are ad hoc, it is not expected these labels will implicitly drive behavior of kubernetes components (the only existing example of LB routing not including nodes with a master label is considered a bug)",
        "createdAt" : "2019-05-22T03:31:14Z",
        "updatedAt" : "2019-05-22T03:31:14Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "74067f19-caa6-41a0-ba9c-11e01bdcb6f5",
        "parentId" : "e16c97a4-4701-4dae-bf9d-7f2f29c80eaa",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Yeah, components of kube may not rely on role labels for proper function.  Node role labels are informational only and optional",
        "createdAt" : "2019-05-22T03:44:53Z",
        "updatedAt" : "2019-05-22T03:44:53Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      }
    ],
    "commit" : "97b221d925de8db7a00389c26ab1d192197bb5b9",
    "line" : 18,
    "diffHunk" : "@@ -1,1 +211,215 @@\tnodeMasterRole      = \"master\"\n\tnodeMinionRole      = \"node\"\n\tlabelKeyNodeMaster  = \"node-role.kubernetes.io/master\"\n\tlabelKeyNodeCompute = \"node-role.kubernetes.io/compute\"\n\tlabelKeyNodeMinion  = \"node-role.kubernetes.io/node\""
  },
  {
    "id" : "6f233d8e-fe9b-433e-9fcc-1e8f6d5bf63a",
    "prId" : 76976,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/76976#pullrequestreview-240395108",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8d0d8206-fa13-47ff-9d52-edc28ad66252",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "this is elevating an ad hoc label to implicitly drive behavior. these labels are not uniformly applied, and are not maintained by kubernetes components (unlike the os/arch labels), so I would not expect them to be used this way",
        "createdAt" : "2019-05-22T03:36:00Z",
        "updatedAt" : "2019-05-22T03:36:01Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "97b221d925de8db7a00389c26ab1d192197bb5b9",
    "line" : 120,
    "diffHunk" : "@@ -1,1 +1651,1655 @@\n// isMasterNode checks if the node is labeled as master\nfunc (c *Cloud) isMasterNode(node *v1.Node) bool {\n\t// Master node has one or more of the following labels:\n\t//"
  },
  {
    "id" : "83963961-d6aa-4ffd-9088-33a33f9797de",
    "prId" : 76976,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/76976#pullrequestreview-240396062",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "71b9cdc3-1378-4cf8-9987-7f3b8878dca2",
        "parentId" : null,
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "This check is not safe.  Nothing guarantees these labels and a conformant cluster is not required to set them.  This would break backwards compatibility with existing clusters on upgrade as well.",
        "createdAt" : "2019-05-22T03:42:24Z",
        "updatedAt" : "2019-05-22T03:42:32Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      }
    ],
    "commit" : "97b221d925de8db7a00389c26ab1d192197bb5b9",
    "line" : 137,
    "diffHunk" : "@@ -1,1 +1666,1670 @@\n// isMinionNode checks if the node is labeled as minion\nfunc (c *Cloud) isMinionNode(node *v1.Node) bool {\n\t// Minion node has one or more oof the following labels:\n\t//"
  },
  {
    "id" : "49fcba84-fd87-4a83-862c-a0d5d9084bcc",
    "prId" : 76976,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/76976#pullrequestreview-240815958",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5756056a-7284-46bf-bfdd-0095d9a48583",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "yes, this should list from an informer-fed cache. rapidly repeatedly listing all nodes (in the example scenario of provisioning 50 PVs in 30 seconds) in a 5000 node cluster is problematic.",
        "createdAt" : "2019-05-22T13:31:46Z",
        "updatedAt" : "2019-05-22T13:31:46Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "f29ecf49-bbba-48a8-bea8-33a23e76c438",
        "parentId" : "5756056a-7284-46bf-bfdd-0095d9a48583",
        "authorId" : "3f2a59ab-16d4-4e6a-90df-56d3c62d3d44",
        "body" : "üëç I do have plan to optimize that part further(#78140 is another example that can benefit from informer), as cloud provider is now out of tree, making such change would be easier.\r\n\r\nThe intention is to move away unnecessary ‚Äúlist‚Äù calls from cloud provider, which has degree of inefficiency even compared with listing from apiserver and would cause cross cluster effect.",
        "createdAt" : "2019-05-22T13:44:01Z",
        "updatedAt" : "2019-05-22T13:50:01Z",
        "lastEditedBy" : "3f2a59ab-16d4-4e6a-90df-56d3c62d3d44",
        "tags" : [
        ]
      },
      {
        "id" : "7887de62-c20c-48d7-a850-ff9f701f27cf",
        "parentId" : "5756056a-7284-46bf-bfdd-0095d9a48583",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "a useful example could be the informer-fed node zone cache GCE maintains (see https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/legacy-cloud-providers/gce/gce.go#L683-L745)\r\n\r\nAWS has the extra wrinkle of excluding masters, but I wonder if that could be done as a much smaller metadata query that is marked as needing to be run when nodes are added/removed",
        "createdAt" : "2019-05-22T13:55:15Z",
        "updatedAt" : "2019-05-22T13:55:15Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "074207ea-80fa-4f99-a9b0-571fed54f58a",
        "parentId" : "5756056a-7284-46bf-bfdd-0095d9a48583",
        "authorId" : "3f2a59ab-16d4-4e6a-90df-56d3c62d3d44",
        "body" : "Ah seems GCE has been doing it for a while, thanks a lot Jordan! tbh having a dedicated zone for master is probably not a common, or even recommended practice, and for non-topology-aware storage class, it's a good check here though as in such case, having volume provisioner to provision a volume in a zone that is more likely to get pod scheduled can reduce operational overhead",
        "createdAt" : "2019-05-22T14:13:53Z",
        "updatedAt" : "2019-05-22T14:13:53Z",
        "lastEditedBy" : "3f2a59ab-16d4-4e6a-90df-56d3c62d3d44",
        "tags" : [
        ]
      },
      {
        "id" : "c552f4e7-2a4f-4d8a-8015-cc69594d5e09",
        "parentId" : "5756056a-7284-46bf-bfdd-0095d9a48583",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "I'd recommend talking with @msau42 about how best to filter the available zones (and whether there's additional info in the CreateVolume call that could be used to narrow down which nodes' zones should be considered)",
        "createdAt" : "2019-05-22T14:26:12Z",
        "updatedAt" : "2019-05-22T14:26:13Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "066e5e4a-ed6f-45f9-97b7-6ed19492be1a",
        "parentId" : "5756056a-7284-46bf-bfdd-0095d9a48583",
        "authorId" : "3f2a59ab-16d4-4e6a-90df-56d3c62d3d44",
        "body" : "Thanks Jordan. Pinged Michelle for inputs from him.",
        "createdAt" : "2019-05-22T18:53:57Z",
        "updatedAt" : "2019-05-22T18:53:57Z",
        "lastEditedBy" : "3f2a59ab-16d4-4e6a-90df-56d3c62d3d44",
        "tags" : [
        ]
      }
    ],
    "commit" : "97b221d925de8db7a00389c26ab1d192197bb5b9",
    "line" : 47,
    "diffHunk" : "@@ -1,1 +1611,1615 @@\tzones := sets.NewString()\n\n\t// TODO: list from cache?\n\tnodes, err := c.kubeClient.CoreV1().Nodes().List(metav1.ListOptions{})\n\tif err != nil {"
  },
  {
    "id" : "5f69fc46-58d7-4a67-ace2-aac778f0755a",
    "prId" : 76976,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/76976#pullrequestreview-240698154",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1de93952-3f8f-4ae2-98af-90f6b9bc97c5",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "node readiness is not the same as the `running` condition in the aws query... will being more restrictive here cause problems?",
        "createdAt" : "2019-05-22T13:39:09Z",
        "updatedAt" : "2019-05-22T13:39:09Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "b4de899f-4543-4e2c-b646-ff919b8e43df",
        "parentId" : "1de93952-3f8f-4ae2-98af-90f6b9bc97c5",
        "authorId" : "3f2a59ab-16d4-4e6a-90df-56d3c62d3d44",
        "body" : "I think the intention of this function is to prevent the case that we create a volume in a region that the pod cannot even be scheduled on to. From cloud provider info, ‚Äúrunning‚Äù is the most we can do but ‚ÄúNodeReady‚Äù brings more confidence.",
        "createdAt" : "2019-05-22T13:48:38Z",
        "updatedAt" : "2019-05-22T13:48:38Z",
        "lastEditedBy" : "3f2a59ab-16d4-4e6a-90df-56d3c62d3d44",
        "tags" : [
        ]
      },
      {
        "id" : "36bfd22a-d18e-4f8c-b68e-f7af5432d99a",
        "parentId" : "1de93952-3f8f-4ae2-98af-90f6b9bc97c5",
        "authorId" : "4db268bc-8c08-4dfd-b61f-0c35b28567bd",
        "body" : "I agree with @zhan849 the more correct status is that the node is Ready according to the API server vs simply running according to the EC2 control plane. It's possible that a node is running but has not yet joined the cluster or may never join for a variety of reasons.",
        "createdAt" : "2019-05-22T15:09:03Z",
        "updatedAt" : "2019-05-22T15:09:03Z",
        "lastEditedBy" : "4db268bc-8c08-4dfd-b61f-0c35b28567bd",
        "tags" : [
        ]
      }
    ],
    "commit" : "97b221d925de8db7a00389c26ab1d192197bb5b9",
    "line" : 62,
    "diffHunk" : "@@ -1,1 +1619,1623 @@\n\tfor _, n := range nodes.Items {\n\t\tif !c.isNodeReady(&n) {\n\t\t\tklog.V(4).Infof(\"Ignoring not ready node %q in zone discovery\", n.Name)\n\t\t\tcontinue"
  },
  {
    "id" : "8c5f7da0-1574-4092-a51a-a173b09c4d76",
    "prId" : 75990,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/75990#pullrequestreview-237411107",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b73b0bb1-e5ff-4203-a8cb-687542c592b0",
        "parentId" : null,
        "authorId" : "6dd71efb-88b1-4bb0-b30a-0df658362f14",
        "body" : "Would it be worthwhile to have unit tests that runs against the set of well known regions? Might be useful to catch updates in the SDK that we weren't expected. It may not catch new regions but it will at least validate against the ones we know are used",
        "createdAt" : "2019-05-13T22:11:55Z",
        "updatedAt" : "2019-05-14T18:48:55Z",
        "lastEditedBy" : "6dd71efb-88b1-4bb0-b30a-0df658362f14",
        "tags" : [
        ]
      },
      {
        "id" : "f918c12d-eaa9-4316-ad35-47c1cfab3318",
        "parentId" : "b73b0bb1-e5ff-4203-a8cb-687542c592b0",
        "authorId" : "4db268bc-8c08-4dfd-b61f-0c35b28567bd",
        "body" : "I'm happy to write the test but I'm not sure what value they would add. The SDK regions are generated from an internal system and this code-path is really just used to validate that if a user provided a region override that it's valid. Previously this was also used to generate credential providers but that's no longer the case. If the user doesn't override the region then we just trust what the metadata service returns and don't fail.",
        "createdAt" : "2019-05-13T22:20:12Z",
        "updatedAt" : "2019-05-14T18:48:55Z",
        "lastEditedBy" : "4db268bc-8c08-4dfd-b61f-0c35b28567bd",
        "tags" : [
        ]
      },
      {
        "id" : "478c3b12-290b-43fe-a3c2-091394c50d83",
        "parentId" : "b73b0bb1-e5ff-4203-a8cb-687542c592b0",
        "authorId" : "6dd71efb-88b1-4bb0-b30a-0df658362f14",
        "body" : "Ah, so `endpoints.DefaultPartitions` is checking metadata for all existing regions? ",
        "createdAt" : "2019-05-13T22:50:34Z",
        "updatedAt" : "2019-05-14T18:48:55Z",
        "lastEditedBy" : "6dd71efb-88b1-4bb0-b30a-0df658362f14",
        "tags" : [
        ]
      },
      {
        "id" : "1b2cae35-699d-4aa2-8a68-87f711d6f859",
        "parentId" : "b73b0bb1-e5ff-4203-a8cb-687542c592b0",
        "authorId" : "6dd71efb-88b1-4bb0-b30a-0df658362f14",
        "body" : "I had the impression that the regions list was still hardcoded but at least it's hard coded into the SDK. If it's hard-coded in the SDK than unit tests to validate that the SDK allows for (at least) the existing well known regions could be useful to make sure we're not regressing on this behavior when we bump the SDK versions to support new regoisn",
        "createdAt" : "2019-05-13T22:56:16Z",
        "updatedAt" : "2019-05-14T18:48:55Z",
        "lastEditedBy" : "6dd71efb-88b1-4bb0-b30a-0df658362f14",
        "tags" : [
        ]
      },
      {
        "id" : "c3d9710b-bf25-4e9a-b11e-4b592de27b1e",
        "parentId" : "b73b0bb1-e5ff-4203-a8cb-687542c592b0",
        "authorId" : "4db268bc-8c08-4dfd-b61f-0c35b28567bd",
        "body" : "Well the list in the SDK is generated from a data management system so it's not really hard-coded. But it's a decent idea to test it anyhow so I've added a test to validate this functionality. WDYT?",
        "createdAt" : "2019-05-13T23:44:57Z",
        "updatedAt" : "2019-05-14T18:48:55Z",
        "lastEditedBy" : "4db268bc-8c08-4dfd-b61f-0c35b28567bd",
        "tags" : [
        ]
      },
      {
        "id" : "ae298dff-8a49-431c-bb47-767e39f40b00",
        "parentId" : "b73b0bb1-e5ff-4203-a8cb-687542c592b0",
        "authorId" : "6dd71efb-88b1-4bb0-b30a-0df658362f14",
        "body" : "Looks great! Can we also add 1 error case (invalid region, not in metadata)? ",
        "createdAt" : "2019-05-13T23:49:25Z",
        "updatedAt" : "2019-05-14T18:48:55Z",
        "lastEditedBy" : "6dd71efb-88b1-4bb0-b30a-0df658362f14",
        "tags" : [
        ]
      },
      {
        "id" : "d27a04d9-2583-4313-97f1-367b1b1c59b3",
        "parentId" : "b73b0bb1-e5ff-4203-a8cb-687542c592b0",
        "authorId" : "4db268bc-8c08-4dfd-b61f-0c35b28567bd",
        "body" : "Added another test case. LGTY?",
        "createdAt" : "2019-05-14T18:00:55Z",
        "updatedAt" : "2019-05-14T18:48:55Z",
        "lastEditedBy" : "4db268bc-8c08-4dfd-b61f-0c35b28567bd",
        "tags" : [
        ]
      }
    ],
    "commit" : "3af7a72719373d97c3846b0f5897f6e2ef785849",
    "line" : 42,
    "diffHunk" : "@@ -1,1 +1302,1306 @@// EC2 metadata service to be a valid region as it's only available on a host\n// running in a valid AWS region.\nfunc isRegionValid(region string, metadata EC2Metadata) bool {\n\t// Does the AWS SDK know about the region?\n\tfor _, p := range endpoints.DefaultPartitions() {"
  },
  {
    "id" : "742e106d-a90a-4354-b2d0-fa06e40b83c8",
    "prId" : 75990,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/75990#pullrequestreview-237434584",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "849033c2-fd3d-401e-8f65-529c4b936435",
        "parentId" : null,
        "authorId" : "6dd71efb-88b1-4bb0-b30a-0df658362f14",
        "body" : "Wondering if `isRegionValid` should return an error. If `getAvailabilityZone` returns `\"\", nil`, unlikely but still possible, then `IsRegionValid` would return true because we ignore the error below. Thoughts?",
        "createdAt" : "2019-05-14T18:34:36Z",
        "updatedAt" : "2019-05-14T18:48:55Z",
        "lastEditedBy" : "6dd71efb-88b1-4bb0-b30a-0df658362f14",
        "tags" : [
        ]
      },
      {
        "id" : "49f3c22f-d598-481d-9c68-28110c4ffbf1",
        "parentId" : "849033c2-fd3d-401e-8f65-529c4b936435",
        "authorId" : "4db268bc-8c08-4dfd-b61f-0c35b28567bd",
        "body" : "That's a good point. I added a check for the error in that condition. I don't like the idea of returning an error here because it makes the function interface much less intuitive and the handling of the result ambiguous.",
        "createdAt" : "2019-05-14T18:46:39Z",
        "updatedAt" : "2019-05-14T18:48:55Z",
        "lastEditedBy" : "4db268bc-8c08-4dfd-b61f-0c35b28567bd",
        "tags" : [
        ]
      }
    ],
    "commit" : "3af7a72719373d97c3846b0f5897f6e2ef785849",
    "line" : 63,
    "diffHunk" : "@@ -1,1 +1323,1327 @@\t// build of Kubernetes in a new region that wasn't compiled into the SDK\n\t// when Kubernetes was built.\n\tif az, err := getAvailabilityZone(metadata); err == nil {\n\t\tif r, err := azToRegion(az); err == nil && region == r {\n\t\t\treturn true"
  }
]
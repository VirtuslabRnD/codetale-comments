[
  {
    "id" : "7a4d9e76-a2c0-4d24-82f1-dc3396fa1966",
    "prId" : 94942,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/94942#pullrequestreview-692435983",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f2251dce-f41b-4491-b2a6-ce3b341982d7",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "if tp is nil, should we just do `return handler`?",
        "createdAt" : "2021-06-18T15:45:32Z",
        "updatedAt" : "2021-06-18T15:45:32Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "c794c359-d2a9-4514-8ecc-66e04bedbbea",
        "parentId" : "f2251dce-f41b-4491-b2a6-ce3b341982d7",
        "authorId" : "d2b16581-e7e9-48b8-9f76-6f6bcb9ec300",
        "body" : "A tracer provider is required to export traces, but even without a tracer provider we can still propagate context.  That would allow, for example, linking etcd traces with API requests even if trace collection is not configured for the api server.  I added a comment linking to otel documentation.",
        "createdAt" : "2021-06-18T18:47:28Z",
        "updatedAt" : "2021-06-18T18:47:28Z",
        "lastEditedBy" : "d2b16581-e7e9-48b8-9f76-6f6bcb9ec300",
        "tags" : [
        ]
      },
      {
        "id" : "f21228e1-0dec-496d-9721-1298c0227867",
        "parentId" : "f2251dce-f41b-4491-b2a6-ce3b341982d7",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "interesting. is there any reason someone would not want that once this feature has graduated to GA and can't be disabled via gate?",
        "createdAt" : "2021-06-23T05:27:21Z",
        "updatedAt" : "2021-06-23T05:27:21Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "de83bc9e-da89-4c5b-937d-21d8e256d245",
        "parentId" : "f2251dce-f41b-4491-b2a6-ce3b341982d7",
        "authorId" : "d2b16581-e7e9-48b8-9f76-6f6bcb9ec300",
        "body" : "Generally not, although there may be some users that want a different set of propagators, like the zipkin B3 propagators.\r\n\r\nThere is a related use-case in which the kube endpoint is public, and you don't trust the context from incoming requests.  For that case we wouldn't want to remove propagators, though.  We would want to use the [WithPublicEndpoint](https://github.com/open-telemetry/opentelemetry-go-contrib/blob/main/instrumentation/net/http/otelhttp/config.go#L103) option on the handler to change the relationships with incoming SpanContext from being a Child to a Link.",
        "createdAt" : "2021-06-23T13:42:08Z",
        "updatedAt" : "2021-06-23T13:42:09Z",
        "lastEditedBy" : "d2b16581-e7e9-48b8-9f76-6f6bcb9ec300",
        "tags" : [
        ]
      },
      {
        "id" : "24f2d58d-e3e4-4210-9c04-a215d58c0e0d",
        "parentId" : "f2251dce-f41b-4491-b2a6-ce3b341982d7",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "> There is a related use-case in which the kube endpoint is public, and you don't trust the context from incoming requests. For that case we wouldn't want to remove propagators, though. We would want to use the WithPublicEndpoint option on the handler to change the relationships with incoming SpanContext from being a Child to a Link.\r\n\r\nGiven the filter is added so it runs before authn/authz, including on generally-accessible endpoints like /healthz, isn't that effectively already possible?",
        "createdAt" : "2021-06-23T17:04:08Z",
        "updatedAt" : "2021-06-23T17:05:26Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "b35e3348-d98d-45d5-bdc9-93587243613b",
        "parentId" : "f2251dce-f41b-4491-b2a6-ce3b341982d7",
        "authorId" : "d2b16581-e7e9-48b8-9f76-6f6bcb9ec300",
        "body" : "We should probably restrict tracing only to authenticated endpoints (and I moved the tracing filter so it only runs on authenticated requests).  Is there a good list somewhere of endpoints that are authenticated?  Or should I just start with  only tracing requests to `/api`?",
        "createdAt" : "2021-06-23T17:55:36Z",
        "updatedAt" : "2021-06-23T17:55:36Z",
        "lastEditedBy" : "d2b16581-e7e9-48b8-9f76-6f6bcb9ec300",
        "tags" : [
        ]
      },
      {
        "id" : "cd55a063-aef0-456a-bb24-96c86ef4d0b8",
        "parentId" : "f2251dce-f41b-4491-b2a6-ce3b341982d7",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "> I moved the tracing filter so it only runs on authenticated requests\r\n\r\nfor most clusters that permit anonymous requests to some endpoints, that filter can just decorate a request with no credentials with the \"system:anonymous\" user :)\r\n\r\nwhat are the implications of an anonymous user (or authenticated-but-untrusted user, which is potentially all clusters) having control over Child relationships vs Link relationships?",
        "createdAt" : "2021-06-23T18:57:32Z",
        "updatedAt" : "2021-06-23T18:57:33Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "f6eb61f9-ec30-4f45-a698-696068bc1dfd",
        "parentId" : "f2251dce-f41b-4491-b2a6-ce3b341982d7",
        "authorId" : "d2b16581-e7e9-48b8-9f76-6f6bcb9ec300",
        "body" : "Ah, the important distinction is actually that a Link ignores the incoming span context (other than linking it), and doesn't use it for determining whether to sample or not.  If an anonymous user can create children, it can make all requests sampled.\r\n\r\nIn general, we want to be able to create children, rather than links, because debugging re-entrant API calls from webhook admission controllers is one of the core use-cases we want to solve.  Ideally we can do that without allowing anyone to generate a bunch of spans.  How do we solve that problem with audit logs?  Do we still audit unauthenticated requests?",
        "createdAt" : "2021-06-23T19:21:34Z",
        "updatedAt" : "2021-06-23T19:21:34Z",
        "lastEditedBy" : "d2b16581-e7e9-48b8-9f76-6f6bcb9ec300",
        "tags" : [
        ]
      },
      {
        "id" : "7b705808-d087-4a44-a259-30ed86fb7351",
        "parentId" : "f2251dce-f41b-4491-b2a6-ce3b341982d7",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "We do audit unauthenticated requests, though most unauthenticated requests would get stopped at the authorization layer.",
        "createdAt" : "2021-06-24T15:17:45Z",
        "updatedAt" : "2021-06-24T15:17:45Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "b37ed097-d5cc-458b-9ea7-3f2a6f4f80a5",
        "parentId" : "f2251dce-f41b-4491-b2a6-ce3b341982d7",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "Putting this after the authorization check would mean you could only influence tracing for endpoints/verbs you were actually authorized to request.\r\n\r\nI still don't have a clear picture of what \"influencing tracing\" means for an unauthenticated or authenticated-but-untrusted user.\r\n\r\nIf all users (anonymous or otherwise) are authorized to `GET /api/v1/namespaces/kube-public/configmaps/cluster-info` (as they are on kubeadm clusters), what info/headers/params could they pass in that would affect totally unrelated traces?",
        "createdAt" : "2021-06-24T15:21:37Z",
        "updatedAt" : "2021-06-24T15:21:37Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "4edf4849-ce08-423f-b1c3-d9ab371d131b",
        "parentId" : "f2251dce-f41b-4491-b2a6-ce3b341982d7",
        "authorId" : "d2b16581-e7e9-48b8-9f76-6f6bcb9ec300",
        "body" : "It wouldn't affect completely unrelated traces, except that you might be able to DOS your tracing backend.  Is that something I should be worrying about?",
        "createdAt" : "2021-06-24T15:23:21Z",
        "updatedAt" : "2021-06-24T15:27:55Z",
        "lastEditedBy" : "d2b16581-e7e9-48b8-9f76-6f6bcb9ec300",
        "tags" : [
        ]
      },
      {
        "id" : "5857a00e-d545-47c1-9789-8860fcacfc35",
        "parentId" : "f2251dce-f41b-4491-b2a6-ce3b341982d7",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "> It wouldn't affect completely unrelated traces\r\n\r\ndoes the info passed in via headers determine what is unrelated? is there anything an anonymous/untrusted requester could pass in in a header that would make tracing think this request was related to another request incorrectly?",
        "createdAt" : "2021-06-24T15:25:09Z",
        "updatedAt" : "2021-06-24T15:25:09Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "929cfe91-3cae-4744-be32-d42d5018e9cf",
        "parentId" : "f2251dce-f41b-4491-b2a6-ce3b341982d7",
        "authorId" : "09e31512-b413-47a1-bc83-20b5a77064ee",
        "body" : "they'd need access to that other request though.. otherwise how would they generate the trace id they shouldn't have?",
        "createdAt" : "2021-06-24T15:28:44Z",
        "updatedAt" : "2021-06-24T15:28:44Z",
        "lastEditedBy" : "09e31512-b413-47a1-bc83-20b5a77064ee",
        "tags" : [
        ]
      },
      {
        "id" : "917c8d2e-05d1-4539-a5a8-2410118bbed8",
        "parentId" : "f2251dce-f41b-4491-b2a6-ce3b341982d7",
        "authorId" : "d2b16581-e7e9-48b8-9f76-6f6bcb9ec300",
        "body" : "It is possible to append spans to an existing trace, if you know the trace ID, and one of the span IDs.  But spans are independent, so you wouldn't be able to alter any existing spans in the trace.",
        "createdAt" : "2021-06-24T15:34:34Z",
        "updatedAt" : "2021-06-24T15:34:35Z",
        "lastEditedBy" : "d2b16581-e7e9-48b8-9f76-6f6bcb9ec300",
        "tags" : [
        ]
      },
      {
        "id" : "facef91a-9360-41b0-ab9f-6f0a196fd73d",
        "parentId" : "f2251dce-f41b-4491-b2a6-ce3b341982d7",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "> It wouldn't affect completely unrelated traces, except that you might be able to DOS your tracing backend. Is that something I should be worrying about?\r\n\r\nUm... maybe? I see pros/cons the further back in the filter chain we put this:\r\n\r\n* after authentication\r\n  * pro: prevents requests with bad credentials from initiating traces (but not valid credentials or anonymous requests)\r\n  * con: means tracing doesn't have visibility to costs of remote authentication methods like webhook authentication\r\n* after priority-and-fairness\r\n  * pro: prevents requests rejected because they exceed allowed priority-and-fairness threshholds from initiating traces\r\n  * con: means tracing doesn't have visibility to requests delayed/rejected for this reason\r\n* after authorization\r\n  * pro: prevents unauthorized requests from initiating traces\r\n  * con: means tracing doesn't have visibility to costs of remote authorization methods like webhook authorization\r\n\r\nEven it we put it after all of those, it still sounds like an authorized request could saturate the tracing backend. What's the failure mode in that scenario?\r\n\r\n> they'd need access to that other request though.. otherwise how would they generate the trace id they shouldn't have?\r\n\r\nif the trace id is considered sufficiently obscure/secure to prevent abuse, that seems positive, and might limit them to influencing traces related to their own requests.\r\n\r\ndoes a new trace id established for a request get returned to the user making that request? are there bad implications of them passing that into subsequent requests and establishing bogus child relationships (like the trace backend retaining the parent traces longer, running out of memory, etc)?",
        "createdAt" : "2021-06-24T15:42:52Z",
        "updatedAt" : "2021-06-24T15:42:52Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "dce7d3a6-aeec-461a-88c4-23798d6477b4",
        "parentId" : "f2251dce-f41b-4491-b2a6-ce3b341982d7",
        "authorId" : "d2b16581-e7e9-48b8-9f76-6f6bcb9ec300",
        "body" : "The failure mode for saturation depends on the backend, but probably involves dropping trace data.\r\n\r\nIf a user sends a request without a trace id, it isn't ever returned to them.  But they can start a new trace (by creating a span without a parent themselves), and send it with the request to the apiserver.\r\n\r\nThe answer again will probably depend on the backend, but I dug into jaeger, and it looks like jaeger has a max duration for a trace (determined by the `max-span-age` flag) and it will ignore spans older than that age.  That would prevent creating traces that are ~infinitely long.  I haven't heard of that causing OOM, or anything like that.",
        "createdAt" : "2021-06-24T16:17:47Z",
        "updatedAt" : "2021-06-24T16:17:47Z",
        "lastEditedBy" : "d2b16581-e7e9-48b8-9f76-6f6bcb9ec300",
        "tags" : [
        ]
      },
      {
        "id" : "16d00ab3-ce5d-48c5-9ad5-a4fa6041a0c2",
        "parentId" : "f2251dce-f41b-4491-b2a6-ce3b341982d7",
        "authorId" : "d2b16581-e7e9-48b8-9f76-6f6bcb9ec300",
        "body" : "Having visibility into the costs of remote authentication would be really nice... ",
        "createdAt" : "2021-06-24T16:27:31Z",
        "updatedAt" : "2021-06-24T16:27:31Z",
        "lastEditedBy" : "d2b16581-e7e9-48b8-9f76-6f6bcb9ec300",
        "tags" : [
        ]
      },
      {
        "id" : "0f568b98-f687-49cc-a06f-c36651b8a6a9",
        "parentId" : "f2251dce-f41b-4491-b2a6-ce3b341982d7",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "> Having visibility into the costs of remote authentication would be really nice...\r\n\r\nagreed... mostly trying to get my head around the risks this exposes. @lavalamp, you've thought about the abuse vectors more w.r.t. priority and fairness... do you have thoughts on this?",
        "createdAt" : "2021-06-24T19:09:55Z",
        "updatedAt" : "2021-06-24T19:09:55Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "2a75bc6f-0801-4b7c-995f-519bb5edb01b",
        "parentId" : "f2251dce-f41b-4491-b2a6-ce3b341982d7",
        "authorId" : "d2b16581-e7e9-48b8-9f76-6f6bcb9ec300",
        "body" : "I went ahead and added WithPublicEndpoint, which makes it ignore the incoming span context.  If that is acceptable, we can start with that and continue the discussion in an issue.",
        "createdAt" : "2021-06-24T22:16:22Z",
        "updatedAt" : "2021-06-24T22:16:22Z",
        "lastEditedBy" : "d2b16581-e7e9-48b8-9f76-6f6bcb9ec300",
        "tags" : [
        ]
      },
      {
        "id" : "dc5e4204-281e-4d07-a015-44c5e056eae8",
        "parentId" : "f2251dce-f41b-4491-b2a6-ce3b341982d7",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "sgtm, mind including a link to this thread (or hoisting relevant content) in the issue?",
        "createdAt" : "2021-06-25T04:17:32Z",
        "updatedAt" : "2021-06-25T04:17:33Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "79550ed40c67a70534c1cb697e1fb7e7dbf96335",
    "line" : 34,
    "diffHunk" : "@@ -1,1 +32,36 @@\t\totelhttp.WithPublicEndpoint(),\n\t}\n\tif tp != nil {\n\t\topts = append(opts, otelhttp.WithTracerProvider(*tp))\n\t}"
  },
  {
    "id" : "8450f36d-4584-435f-99f2-557e69ec4dd3",
    "prId" : 94942,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/94942#pullrequestreview-692775380",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0d79fbba-3ae9-4e9e-883e-23e8163b0b11",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "just realized this is in k8s.io/apiserver, not specific to kube-apiserver... if there are multiple servers built on this library, does each need to have a unique id, or is it ok if they all report `KubernetesAPI`",
        "createdAt" : "2021-06-25T12:25:32Z",
        "updatedAt" : "2021-06-25T12:25:32Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "729bfd77-08dd-47a3-afb3-51820bf6ee7e",
        "parentId" : "0d79fbba-3ae9-4e9e-883e-23e8163b0b11",
        "authorId" : "d2b16581-e7e9-48b8-9f76-6f6bcb9ec300",
        "body" : "This controls the name of the span, so it should be whatever would best identify the server, and it doesn't have to be unique.  https://github.com/kubernetes/kubernetes/pull/94942/files#diff-0e1453d49880a4f88f0353b9902c7e914513dd1274e3115100ea42c2d116136bR101-R106 is where we set the resource tags that should distinguish different instances of the apiserver.  Right now, we tag it with the service name, \"kube-apiserver\", and the API Server ID, which has the pattern kube-apiserver-<UUID>.",
        "createdAt" : "2021-06-25T12:35:28Z",
        "updatedAt" : "2021-06-25T12:35:28Z",
        "lastEditedBy" : "d2b16581-e7e9-48b8-9f76-6f6bcb9ec300",
        "tags" : [
        ]
      },
      {
        "id" : "beefda14-0088-468e-b64e-630ddfda551a",
        "parentId" : "0d79fbba-3ae9-4e9e-883e-23e8163b0b11",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "ok... looks like APIServerID is overrideable by consumers of the k8s.io/apiserver library, so that's a reasonable thing to use... hard-coding kube-apiserver isn't good long-term, but can be adjusted in a follow-up",
        "createdAt" : "2021-06-25T12:39:57Z",
        "updatedAt" : "2021-06-25T12:39:58Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "79550ed40c67a70534c1cb697e1fb7e7dbf96335",
    "line" : 39,
    "diffHunk" : "@@ -1,1 +37,41 @@\t// Even if there is no TracerProvider, the otelhttp still handles context propagation.\n\t// See https://github.com/open-telemetry/opentelemetry-go/tree/main/example/passthrough\n\treturn otelhttp.NewHandler(handler, \"KubernetesAPI\", opts...)\n}"
  }
]
[
  {
    "id" : "4ea3be33-5ece-400b-adae-2c681bd11a25",
    "prId" : 85410,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/85410#pullrequestreview-340536388",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "760daf4d-b3cb-4a10-8102-3a210fbe5195",
        "parentId" : null,
        "authorId" : "c67fd0c8-b4a0-45e6-b808-28edbb7bc636",
        "body" : "Hi @answer1991 , why do we need this when we already have the watcher to be closed after timeout in `cacheWatcher.process()`.",
        "createdAt" : "2020-01-09T13:57:42Z",
        "updatedAt" : "2020-01-09T13:57:49Z",
        "lastEditedBy" : "c67fd0c8-b4a0-45e6-b808-28edbb7bc636",
        "tags" : [
        ]
      }
    ],
    "commit" : "b911aa6471a83b1d2b4ea346e5c6b442dfa9b53b",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +65,69 @@// TODO: the functionality in this method and in WatchServer.Serve is not cleanly decoupled.\nfunc serveWatch(watcher watch.Interface, scope *RequestScope, mediaTypeOptions negotiation.MediaTypeOptions, req *http.Request, w http.ResponseWriter, timeout time.Duration) {\n\tdefer watcher.Stop()\n\n\toptions, err := optionsForTransform(mediaTypeOptions, req)"
  },
  {
    "id" : "934866c5-67b1-4b25-89f2-f1deec876b9e",
    "prId" : 84693,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/84693#pullrequestreview-313700288",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f233b869-e6a8-4ce3-96b6-43bddbe12554",
        "parentId" : null,
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "Is it OK to double-stop this thing? (e.g. for line 298 it is likely already stopped)",
        "createdAt" : "2019-11-07T23:07:50Z",
        "updatedAt" : "2019-11-07T23:07:51Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "46915d2f-5aaa-4edb-8c53-68af018ae10e",
        "parentId" : "f233b869-e6a8-4ce3-96b6-43bddbe12554",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "FWIW, that's exactly the path exercised by line 204/226 above in the normal case of the watch channel closing",
        "createdAt" : "2019-11-07T23:16:25Z",
        "updatedAt" : "2019-11-07T23:16:25Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "639af77d463a4d07bc5d7d19366bd98310b55724",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +287,291 @@\tch := s.Watching.ResultChan()\n\n\tdefer s.Watching.Stop()\n\n\tfor {"
  },
  {
    "id" : "2843561b-fcd7-4904-8de6-d12bbf898a4f",
    "prId" : 71548,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/71548#pullrequestreview-212154834",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "385d84fe-65ba-4c3b-bd3e-2280e1d05bc9",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "this sets NoHeaders=true after rendering the first object, so headers on subsequent objects are not sent? bears a comment",
        "createdAt" : "2019-03-06T07:03:28Z",
        "updatedAt" : "2019-03-08T18:04:12Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "5bb18d83-8291-4a40-bee7-d995d5bfc82a",
        "parentId" : "385d84fe-65ba-4c3b-bd3e-2280e1d05bc9",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "correct, will comment",
        "createdAt" : "2019-03-06T16:51:10Z",
        "updatedAt" : "2019-03-08T18:04:12Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "e164cd5e-c373-4cbc-9bcc-c0b2bdfc19cb",
        "parentId" : "385d84fe-65ba-4c3b-bd3e-2280e1d05bc9",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "is mutating original `options` safe? I guess we get our own local copy back from optionsForTransform, so it wasn't passed in and possibly shared.\r\n\r\ndo we need to check if `tableOptions` is non-nil?",
        "createdAt" : "2019-03-08T06:28:01Z",
        "updatedAt" : "2019-03-08T18:04:12Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "3230a0b4fd14a6166f8362d4732e199e8779c426",
    "line" : 107,
    "diffHunk" : "@@ -1,1 +132,136 @@\t\t\t// and omit them on subsequent events.\n\t\t\tif tableOptions, ok := options.(*metav1beta1.TableOptions); ok {\n\t\t\t\ttableOptions.NoHeaders = true\n\t\t\t}\n\t\t\treturn result"
  },
  {
    "id" : "2b43b703-f904-4d1d-bdd8-eee3365e5306",
    "prId" : 71548,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/71548#pullrequestreview-212148779",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "123893b0-d91e-4785-aeb7-7e9ad4429648",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "there's a lot of stuff in mediaTypeOptions, and we're ignoring almost all of it. we pull media type from serializer like this:\r\n```\r\n// TODO: next step, get back mediaTypeOptions from negotiate and return the exact value here\r\nmediaType := serializer.MediaType\r\nif mediaType != runtime.ContentTypeJSON {\r\n\tmediaType += \";stream=watch\"\r\n}\r\n```\r\ninstead of using `mediaTypeOptions.Accepted`\r\n\r\nwe also don't check if `mediaTypeOptions.Accepted.Serializer` is set\r\n\r\nis there a way to get the information we need more crisply?",
        "createdAt" : "2019-03-08T05:34:51Z",
        "updatedAt" : "2019-03-08T18:04:12Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "c018832a-b686-4220-b640-86a5e216cca0",
        "parentId" : "123893b0-d91e-4785-aeb7-7e9ad4429648",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Serializer is always set - it's not allowed to be. nil.",
        "createdAt" : "2019-03-08T05:52:40Z",
        "updatedAt" : "2019-03-08T18:04:12Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "b69438f3-d977-40d7-8276-abae1b74feba",
        "parentId" : "123893b0-d91e-4785-aeb7-7e9ad4429648",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "And this doesn't change the negotiation that we had before (in terms of behavior relative to 1.13).",
        "createdAt" : "2019-03-08T05:54:15Z",
        "updatedAt" : "2019-03-08T18:04:12Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      }
    ],
    "commit" : "3230a0b4fd14a6166f8362d4732e199e8779c426",
    "line" : 25,
    "diffHunk" : "@@ -1,1 +64,68 @@// serveWatch will serve a watch response.\n// TODO: the functionality in this method and in WatchServer.Serve is not cleanly decoupled.\nfunc serveWatch(watcher watch.Interface, scope RequestScope, mediaTypeOptions negotiation.MediaTypeOptions, req *http.Request, w http.ResponseWriter, timeout time.Duration) {\n\toptions, err := optionsForTransform(mediaTypeOptions, req)\n\tif err != nil {"
  },
  {
    "id" : "7ddb7b53-d2c3-4e54-a117-2d45f137314d",
    "prId" : 71548,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/71548#pullrequestreview-212150564",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5fd1240f-798f-47fc-8419-8bfa2b6edea5",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "break?",
        "createdAt" : "2019-03-08T06:04:22Z",
        "updatedAt" : "2019-03-08T18:04:12Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "3230a0b4fd14a6166f8362d4732e199e8779c426",
    "line" : 72,
    "diffHunk" : "@@ -1,1 +98,102 @@\t\tfor _, supported := range contentSerializer.SupportedMediaTypes() {\n\t\t\tif supported.MediaType == serializer.MediaType {\n\t\t\t\tembedded = supported.Serializer\n\t\t\t}\n\t\t}"
  }
]
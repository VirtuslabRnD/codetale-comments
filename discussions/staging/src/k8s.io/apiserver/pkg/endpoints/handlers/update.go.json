[
  {
    "id" : "60ec0067-701e-4787-8a1e-38244ba9be50",
    "prId" : 87508,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/87508#pullrequestreview-359204500",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1ca4b9fd-9557-40ac-9e32-1c2c2413af79",
        "parentId" : null,
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "This makes the code pretty twisty-turny, I don't have a better idea but maybe you can add a comment explaining why this is important? To all the places where we retry.",
        "createdAt" : "2020-02-14T20:36:11Z",
        "updatedAt" : "2020-02-27T20:42:44Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      }
    ],
    "commit" : "ccd9e4e2de32b8708f3a7be159f7a4316449c433",
    "line" : 61,
    "diffHunk" : "@@ -1,1 +197,201 @@\t\t\t// If the object wasn't committed to storage because it's serialized size was too large,\n\t\t\t// it is safe to remove managedFields (which can be large) and try again.\n\t\t\tif isTooLargeError(err) && scope.FieldManager != nil {\n\t\t\t\tif accessor, accessorErr := meta.Accessor(obj); accessorErr == nil {\n\t\t\t\t\taccessor.SetManagedFields(nil)"
  },
  {
    "id" : "5ad00006-eab5-49bf-bb5b-91ce9b944306",
    "prId" : 72576,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/72576#pullrequestreview-190900793",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f4b8f3fc-9a1a-43a8-a64c-d5ed162efec6",
        "parentId" : null,
        "authorId" : "a139439a-9f9e-4518-b4f3-9c602d956c57",
        "body" : "Ditto",
        "createdAt" : "2019-01-09T18:12:20Z",
        "updatedAt" : "2019-01-09T21:21:59Z",
        "lastEditedBy" : "a139439a-9f9e-4518-b4f3-9c602d956c57",
        "tags" : [
        ]
      },
      {
        "id" : "835cfd2a-fd6a-4db5-8fe3-10c54679303d",
        "parentId" : "f4b8f3fc-9a1a-43a8-a64c-d5ed162efec6",
        "authorId" : "500960f8-0ed2-4739-b582-fd7135d2ce87",
        "body" : "@apelisse this way?",
        "createdAt" : "2019-01-09T19:55:17Z",
        "updatedAt" : "2019-01-09T21:21:59Z",
        "lastEditedBy" : "500960f8-0ed2-4739-b582-fd7135d2ce87",
        "tags" : [
        ]
      }
    ],
    "commit" : "a39936a6d2322d57a51e3720a0639c4422738b97",
    "line" : 18,
    "diffHunk" : "@@ -1,1 +126,130 @@\t\t\ttransformers = append(transformers, func(_ context.Context, liveObj, newObj runtime.Object) (runtime.Object, error) {\n\t\t\t\tif obj, err = scope.FieldManager.Update(liveObj, newObj, \"update\"); err != nil {\n\t\t\t\t\treturn nil, fmt.Errorf(\"failed to update object managed fields: %v\", err)\n\t\t\t\t}\n\t\t\t\treturn obj, nil"
  },
  {
    "id" : "2c6e9b77-b344-41e1-a18e-af1013c85e22",
    "prId" : 71583,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/71583#pullrequestreview-183229261",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "236583ce-f656-45b6-b480-5ce4f7dce8ac",
        "parentId" : null,
        "authorId" : "a139439a-9f9e-4518-b4f3-9c602d956c57",
        "body" : "It'd be nice if we didn't have to create the type converter on every request. Can it be updated during the lifetime of the apiserver @jennybuckley ?",
        "createdAt" : "2018-12-06T18:37:18Z",
        "updatedAt" : "2018-12-12T21:16:07Z",
        "lastEditedBy" : "a139439a-9f9e-4518-b4f3-9c602d956c57",
        "tags" : [
        ]
      },
      {
        "id" : "313fc60f-9500-4b24-aa59-f92a22e11970",
        "parentId" : "236583ce-f656-45b6-b480-5ce4f7dce8ac",
        "authorId" : "500960f8-0ed2-4739-b582-fd7135d2ce87",
        "body" : "Thought about this as well. Same for the VersionConverter?",
        "createdAt" : "2018-12-06T22:21:10Z",
        "updatedAt" : "2018-12-12T21:16:07Z",
        "lastEditedBy" : "500960f8-0ed2-4739-b582-fd7135d2ce87",
        "tags" : [
        ]
      },
      {
        "id" : "46944f43-6ac6-4f1b-8c5f-b8911449abb7",
        "parentId" : "236583ce-f656-45b6-b480-5ce4f7dce8ac",
        "authorId" : "a139439a-9f9e-4518-b4f3-9c602d956c57",
        "body" : "the VersionConverter is almost free to build, so I don't care as much",
        "createdAt" : "2018-12-06T23:09:32Z",
        "updatedAt" : "2018-12-12T21:16:07Z",
        "lastEditedBy" : "a139439a-9f9e-4518-b4f3-9c602d956c57",
        "tags" : [
        ]
      },
      {
        "id" : "4dbad290-b78c-47a9-b7c5-6749ab0daeaf",
        "parentId" : "236583ce-f656-45b6-b480-5ce4f7dce8ac",
        "authorId" : "37324129-fa96-456d-92ea-e5f9b41f8c7f",
        "body" : "would it be a problem at all if we had separate processes concurrently using the same typeConverter?",
        "createdAt" : "2018-12-06T23:22:05Z",
        "updatedAt" : "2018-12-12T21:16:07Z",
        "lastEditedBy" : "37324129-fa96-456d-92ea-e5f9b41f8c7f",
        "tags" : [
        ]
      },
      {
        "id" : "70a4fcd1-9e85-4870-bc76-90615bfbba4a",
        "parentId" : "236583ce-f656-45b6-b480-5ce4f7dce8ac",
        "authorId" : "500960f8-0ed2-4739-b582-fd7135d2ce87",
        "body" : "I don't think so. As long as we ensure it is there when concurrent processes use it, this should be fine.\r\nWhere would it be best to store then @jennybuckley ?",
        "createdAt" : "2018-12-10T15:04:19Z",
        "updatedAt" : "2018-12-12T21:16:07Z",
        "lastEditedBy" : "500960f8-0ed2-4739-b582-fd7135d2ce87",
        "tags" : [
        ]
      }
    ],
    "commit" : "b3b778f6f63bb322ae39691d7bfc070d92235cbf",
    "line" : 27,
    "diffHunk" : "@@ -1,1 +124,128 @@\t\t\t\tklog.Warningf(\"No OpenAPI for: %v\", scope.Kind)\n\t\t\t} else {\n\t\t\t\tconverter, err := apply.NewTypeConverter(scope.OpenAPIModels)\n\t\t\t\tif err != nil {\n\t\t\t\t\tscope.err(err, w, req)"
  },
  {
    "id" : "7ddea339-fba3-44b0-9441-b7f988c01cfe",
    "prId" : 65572,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/65572#pullrequestreview-138704062",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "411ac687-b772-42e8-a2e3-398869ad0028",
        "parentId" : null,
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "The old admission code (at least for quota) used to compare against nil.  Am I to understand the old code was wrong?",
        "createdAt" : "2018-07-19T14:38:33Z",
        "updatedAt" : "2018-07-19T14:38:33Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      },
      {
        "id" : "8e177873-c4f6-48aa-9384-c1e9024d2806",
        "parentId" : "411ac687-b772-42e8-a2e3-398869ad0028",
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "> The old admission code (at least for quota) used to compare against nil. Am I to understand the old code was wrong?\r\n\r\nAh, it probably was for create on update, but not for create.  That kind of makes sense.  I'm glad this is getting fixed.",
        "createdAt" : "2018-07-19T14:39:33Z",
        "updatedAt" : "2018-07-19T14:39:33Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      }
    ],
    "commit" : "ccb1ec7a3695082326fe60ec06890f91004dc043",
    "line" : 10,
    "diffHunk" : "@@ -1,1 +100,104 @@\t\tif mutatingAdmission, ok := admit.(admission.MutationInterface); ok {\n\t\t\ttransformers = append(transformers, func(ctx context.Context, newObj, oldObj runtime.Object) (runtime.Object, error) {\n\t\t\t\tisNotZeroObject, err := hasUID(oldObj)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, fmt.Errorf(\"unexpected error when extracting UID from oldObj: %v\", err.Error())"
  }
]
[
  {
    "id" : "abf56318-c678-4cec-aa0a-0baa491c9f70",
    "prId" : 69582,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/69582#pullrequestreview-165150816",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "73928af8-89d5-4030-bae6-553188876450",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "TODO to take implicit audiences at requestHeaderAuthRequestHandler construction time, and if ctx is audience-limited, ensure it intersects with the implicit audiences, and echo an audience in the response",
        "createdAt" : "2018-10-16T13:25:35Z",
        "updatedAt" : "2018-10-22T19:11:52Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "809f278b032103cd24fcbb5ea2196c6c7caa6f63",
    "line" : 17,
    "diffHunk" : "@@ -1,1 +127,131 @@\t}\n\n\treturn &authenticator.Response{\n\t\tUser: &user.DefaultInfo{\n\t\t\tName:   name,"
  },
  {
    "id" : "168e1898-d4bd-4f31-a833-77d8232ea0a1",
    "prId" : 65799,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/65799#pullrequestreview-136450922",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "825e10d6-fdfa-40cb-a42e-85326f3fecbd",
        "parentId" : null,
        "authorId" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "body" : "why does PathUnescape work here?",
        "createdAt" : "2018-07-09T17:57:41Z",
        "updatedAt" : "2018-07-16T18:45:25Z",
        "lastEditedBy" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "tags" : [
        ]
      },
      {
        "id" : "8d84624e-c4d2-4353-96e3-65ac156fedab",
        "parentId" : "825e10d6-fdfa-40cb-a42e-85326f3fecbd",
        "authorId" : "1f68015a-b968-47bc-b26f-0adff52fb6d8",
        "body" : "PathEscape is under-aggressive for our needs, but PathUnescape blindly converts %-encoded bytes back to regular bytes: https://golang.org/src/net/url/url.go?s=5075:5118#L173",
        "createdAt" : "2018-07-09T19:14:01Z",
        "updatedAt" : "2018-07-16T18:45:25Z",
        "lastEditedBy" : "1f68015a-b968-47bc-b26f-0adff52fb6d8",
        "tags" : [
        ]
      },
      {
        "id" : "5ec314ea-0c35-4191-a32f-3ecbdb7bb9ed",
        "parentId" : "825e10d6-fdfa-40cb-a42e-85326f3fecbd",
        "authorId" : "e81e699e-eb6c-4380-bfd5-16ab81ac51d6",
        "body" : "Can you show some examples where `url.PathEscape`/`url.QueryEscape` are lacking?",
        "createdAt" : "2018-07-11T16:36:20Z",
        "updatedAt" : "2018-07-16T18:45:25Z",
        "lastEditedBy" : "e81e699e-eb6c-4380-bfd5-16ab81ac51d6",
        "tags" : [
        ]
      },
      {
        "id" : "0a43f3bb-bed1-4920-9624-ef5ef4edee51",
        "parentId" : "825e10d6-fdfa-40cb-a42e-85326f3fecbd",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "> PathEscape is under-aggressive for our needs\r\n\r\nthat's unfortunate... what characters does it not escape for us?",
        "createdAt" : "2018-07-11T20:45:15Z",
        "updatedAt" : "2018-07-16T18:45:25Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "8d145ea7-6863-49f4-9319-dcb213611aa1",
        "parentId" : "825e10d6-fdfa-40cb-a42e-85326f3fecbd",
        "authorId" : "1f68015a-b968-47bc-b26f-0adff52fb6d8",
        "body" : "Looks like it's \"@\", \"=\", and \":\" are unreserved in path components but forbidden in header keys. I'll add explicit tests for that.\r\nQueryEscape is lacking because we want to maximize compatibility with (i.e. minimize escaping of) existing legal header key strings. We don't want to be over-aggressivley escaping legal strings (which unnecessarily garbles legal keys keys being sent from a new client to an old API server).\r\n\r\nI set up a playground to test the interactions between new/old clients/servers with various escaping/unescaping algorithms:\r\nhttps://play.golang.org/p/eors6oEbRpT",
        "createdAt" : "2018-07-11T22:21:59Z",
        "updatedAt" : "2018-07-16T18:45:25Z",
        "lastEditedBy" : "1f68015a-b968-47bc-b26f-0adff52fb6d8",
        "tags" : [
        ]
      },
      {
        "id" : "8f4db8cf-1827-4b88-9d59-47706fe3b17e",
        "parentId" : "825e10d6-fdfa-40cb-a42e-85326f3fecbd",
        "authorId" : "e81e699e-eb6c-4380-bfd5-16ab81ac51d6",
        "body" : "Does QueryEscape's aggressive escaping break anything?\r\nI'm very skeptical about having to maintain complex encoding logic for the sake of making headers less garbled/readable.",
        "createdAt" : "2018-07-11T22:32:21Z",
        "updatedAt" : "2018-07-16T18:45:25Z",
        "lastEditedBy" : "e81e699e-eb6c-4380-bfd5-16ab81ac51d6",
        "tags" : [
        ]
      },
      {
        "id" : "dfa87d3a-5fa0-42d5-a905-8af5393a5e1f",
        "parentId" : "825e10d6-fdfa-40cb-a42e-85326f3fecbd",
        "authorId" : "e81e699e-eb6c-4380-bfd5-16ab81ac51d6",
        "body" : "Also, can we offload bulk of escaping to Path/QueryEscape and post-process the output to catch any extra characters we care about?",
        "createdAt" : "2018-07-11T22:34:00Z",
        "updatedAt" : "2018-07-16T18:45:25Z",
        "lastEditedBy" : "e81e699e-eb6c-4380-bfd5-16ab81ac51d6",
        "tags" : [
        ]
      },
      {
        "id" : "e1195241-3867-4721-98b3-9cefe6fd2cdd",
        "parentId" : "825e10d6-fdfa-40cb-a42e-85326f3fecbd",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "> Does QueryEscape's aggressive escaping break anything?\r\n\r\nThe `'+' -> ' '` seems problematic",
        "createdAt" : "2018-07-11T22:36:54Z",
        "updatedAt" : "2018-07-16T18:45:25Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "19ea9fe9-ba8d-4524-bc86-8430bc8ae3b0",
        "parentId" : "825e10d6-fdfa-40cb-a42e-85326f3fecbd",
        "authorId" : "e81e699e-eb6c-4380-bfd5-16ab81ac51d6",
        "body" : "> The '+' -> ' ' seems problematic\r\n\r\nThat would be for Unescape, right? QueryEscape is the other way around, which seems fine?",
        "createdAt" : "2018-07-11T22:42:19Z",
        "updatedAt" : "2018-07-16T18:45:25Z",
        "lastEditedBy" : "e81e699e-eb6c-4380-bfd5-16ab81ac51d6",
        "tags" : [
        ]
      },
      {
        "id" : "331917a0-0eb3-4422-895e-9c63c8ca585f",
        "parentId" : "825e10d6-fdfa-40cb-a42e-85326f3fecbd",
        "authorId" : "1f68015a-b968-47bc-b26f-0adff52fb6d8",
        "body" : "> Does QueryEscape's aggressive escaping break anything?\r\nI'm very skeptical about having to maintain complex encoding logic for the sake of making headers less garbled/readable.\r\n\r\nYes, anyone currently using non-alphanumeric strings and mismatched client/server versions. \r\n\r\n> Also, can we offload bulk of escaping to Path/QueryEscape and post-process the output to catch any extra characters we care about?\r\n\r\nOnly if it's acceptable to permanently garble keys that are percent-encoded by the caller.\r\nDouble-encoding seems more complicated/fragile than simply whitelisting all header chars.",
        "createdAt" : "2018-07-11T22:50:53Z",
        "updatedAt" : "2018-07-16T18:45:25Z",
        "lastEditedBy" : "1f68015a-b968-47bc-b26f-0adff52fb6d8",
        "tags" : [
        ]
      },
      {
        "id" : "1ff82c98-b146-45d8-966a-ce1e5f981f17",
        "parentId" : "825e10d6-fdfa-40cb-a42e-85326f3fecbd",
        "authorId" : "1f68015a-b968-47bc-b26f-0adff52fb6d8",
        "body" : ">>The '+' -> ' ' seems problematic\r\n\r\n>That would be for Unescape, right? QueryEscape is the other way around, which seems fine?\r\n\r\nIf it's acceptable to additionally break old clients sending '+'-containing keys to new API servers, sure.",
        "createdAt" : "2018-07-11T22:54:12Z",
        "updatedAt" : "2018-07-16T18:45:25Z",
        "lastEditedBy" : "1f68015a-b968-47bc-b26f-0adff52fb6d8",
        "tags" : [
        ]
      }
    ],
    "commit" : "f35e3d07c9898f8ec156209a868fa4451eb9afe2",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +163,167 @@\nfunc unescapeExtraKey(encodedKey string) string {\n\tkey, err := url.PathUnescape(encodedKey) // Decode %-encoded bytes.\n\tif err != nil {\n\t\treturn encodedKey // Always record extra strings, even if malformed/unencoded."
  },
  {
    "id" : "ed99b35c-4030-4c26-b407-08821155ac81",
    "prId" : 65799,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/65799#pullrequestreview-136301273",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ea1bbcc3-0cc0-4695-b9ca-66dcefce5eb3",
        "parentId" : null,
        "authorId" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "body" : "The why of this comment is not obvious to me.",
        "createdAt" : "2018-07-10T18:42:44Z",
        "updatedAt" : "2018-07-16T18:45:25Z",
        "lastEditedBy" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "tags" : [
        ]
      },
      {
        "id" : "8eb56bd4-3a0e-4211-99f8-c7277b36a866",
        "parentId" : "ea1bbcc3-0cc0-4695-b9ca-66dcefce5eb3",
        "authorId" : "1f68015a-b968-47bc-b26f-0adff52fb6d8",
        "body" : "From the [discussion in the original issue](https://github.com/kubernetes/kubernetes/issues/63682#issuecomment-401938132), it seemed like it was decided to always record these extra values (even when 'malformed'), so I made it a no-op on error and added test cases for strings like \"foo%xxbar\" which can't be PathUnescaped.",
        "createdAt" : "2018-07-11T15:38:44Z",
        "updatedAt" : "2018-07-16T18:45:25Z",
        "lastEditedBy" : "1f68015a-b968-47bc-b26f-0adff52fb6d8",
        "tags" : [
        ]
      }
    ],
    "commit" : "f35e3d07c9898f8ec156209a868fa4451eb9afe2",
    "line" : 15,
    "diffHunk" : "@@ -1,1 +165,169 @@\tkey, err := url.PathUnescape(encodedKey) // Decode %-encoded bytes.\n\tif err != nil {\n\t\treturn encodedKey // Always record extra strings, even if malformed/unencoded.\n\t}\n\treturn key"
  }
]
[
  {
    "id" : "6790bdfb-88c4-42c6-8787-de87b9ccf9c8",
    "prId" : 102511,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/102511#pullrequestreview-677053004",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "be8bc790-f58c-46bd-9c21-908045904e36",
        "parentId" : null,
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "I'm assuming this removal is a cleanup - not an actual fix, right?\r\n\r\nIf it is actual fix, can you clarify what was wrong before?",
        "createdAt" : "2021-06-02T14:15:44Z",
        "updatedAt" : "2021-06-02T14:22:04Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      },
      {
        "id" : "b0bcdce0-7116-42a2-b795-a96596d9197d",
        "parentId" : "be8bc790-f58c-46bd-9c21-908045904e36",
        "authorId" : "3e6e337f-0beb-4609-abc3-11b8e8cf5688",
        "body" : "it's a bit of both really:\r\n- `hardStop` calls `t.Fatalf` from a goroutine created during the test, this triggers the data race, below is one of the writes that contributed to the data race \r\n- we don't need `hardStop` really, the client is wired with a timeout, so in case the httptest Server does not come up the request will time out and the test will call `t.Fatalf` from inside the the goroutine that is running the test.\r\n\r\n\r\n```\r\nPrevious write at 0x00c0025d92a1 by goroutine 428:\r\n  testing.(*common).FailNow()\r\n      /usr/local/go/src/testing/testing.go:740 +0x4f\r\n  testing.(*common).Fatalf()\r\n      /usr/local/go/src/testing/testing.go:815 +0x9d\r\n  k8s.io/kubernetes/vendor/k8s.io/apiserver/pkg/server/filters.hardStop()\r\n      /home/prow/go/src/k8s.io/kubernetes/_output/local/go/src/k8s.io/kubernetes/vendor/k8s.io/apiserver/pkg/server/filters/priority-and-fairness_test.go:1011 +0x1a4\r\n```",
        "createdAt" : "2021-06-02T16:48:51Z",
        "updatedAt" : "2021-06-02T16:48:52Z",
        "lastEditedBy" : "3e6e337f-0beb-4609-abc3-11b8e8cf5688",
        "tags" : [
        ]
      },
      {
        "id" : "3e903c15-fe3a-47d3-9194-d4691b58ce9f",
        "parentId" : "be8bc790-f58c-46bd-9c21-908045904e36",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "Yeah - I actually realized that later too (just forgot to remove this comment). Makes sense.",
        "createdAt" : "2021-06-07T07:05:39Z",
        "updatedAt" : "2021-06-07T07:05:39Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "8847a25026711f51ae694fe8288e285a48e70675",
    "line" : 22,
    "diffHunk" : "@@ -1,1 +452,456 @@\t\tdefer server.Close()\n\n\t\t// send a request synchronously with a client timeout of requestTimeout*2 seconds\n\t\t// this ensures the test does not block indefinitely if the server does not respond.\n\t\tvar ("
  },
  {
    "id" : "846b0e1c-3bb1-42c6-aa2f-cb3abfffd3d0",
    "prId" : 102171,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/102171#pullrequestreview-673102831",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f12d1d3c-7fb1-4050-9f86-4b7afc4c4081",
        "parentId" : null,
        "authorId" : "7a59a326-58b3-4590-b70a-297d2e27daa5",
        "body" : "This is testing the `httptest.NewServer` rather than the server we actually use.  Why is it interesting anyway?",
        "createdAt" : "2021-06-01T05:54:25Z",
        "updatedAt" : "2021-06-01T05:56:12Z",
        "lastEditedBy" : "7a59a326-58b3-4590-b70a-297d2e27daa5",
        "tags" : [
        ]
      },
      {
        "id" : "574af039-c5cb-4c97-9ed0-7cf1e6b1ef5e",
        "parentId" : "f12d1d3c-7fb1-4050-9f86-4b7afc4c4081",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "httptest.Server is actually sharing most o the logic with http.Server.\r\nIt's basically how we test in unit tests.",
        "createdAt" : "2021-06-01T07:51:46Z",
        "updatedAt" : "2021-06-01T07:52:03Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      },
      {
        "id" : "4896bd17-97fa-4574-b356-9720b7e21212",
        "parentId" : "f12d1d3c-7fb1-4050-9f86-4b7afc4c4081",
        "authorId" : "7a59a326-58b3-4590-b70a-297d2e27daa5",
        "body" : "I was thinking that maybe there should be a comment explaining that among the logic shared is what matters here, the logic regarding the request context's Done channel.",
        "createdAt" : "2021-06-01T13:53:53Z",
        "updatedAt" : "2021-06-01T13:54:18Z",
        "lastEditedBy" : "7a59a326-58b3-4590-b70a-297d2e27daa5",
        "tags" : [
        ]
      }
    ],
    "commit" : "8054b0f808d116658ac086e4b71fb34d1502cd57",
    "line" : 288,
    "diffHunk" : "@@ -1,1 +519,523 @@}\n\n// TestContextClosesOnRequestProcessed ensures that the request context is cancelled\n// automatically even if the server doesn't cancel is explicitly.\n// This is required to ensure we won't be leaking goroutines that wait for context"
  },
  {
    "id" : "559160c9-2669-4de6-88cf-50bce9db5477",
    "prId" : 97471,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/97471#pullrequestreview-576004908",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "af574fce-444c-44eb-a662-931d56636e22",
        "parentId" : null,
        "authorId" : "7a59a326-58b3-4590-b70a-297d2e27daa5",
        "body" : "The timing in this test is pretty tight, I am concerned this will make for a flaky test.  I recommend slowing it down.  Perhaps a requestTimeout of 10 seconds or more, and make the requestHandler wait something like 5 seconds more than the requestTimeout.\r\n\r\nSimilar concerns apply to the other tests added in this PR.",
        "createdAt" : "2020-12-28T05:59:09Z",
        "updatedAt" : "2021-01-29T03:32:05Z",
        "lastEditedBy" : "7a59a326-58b3-4590-b70a-297d2e27daa5",
        "tags" : [
        ]
      },
      {
        "id" : "6442a482-1b6b-40ff-8079-bef4069f8756",
        "parentId" : "af574fce-444c-44eb-a662-931d56636e22",
        "authorId" : "3e6e337f-0beb-4609-abc3-11b8e8cf5688",
        "body" : "@MikeSpreitzer I have used channel based sync as opposed to using sleep, this should be flake free, please take a look.",
        "createdAt" : "2021-01-25T21:20:45Z",
        "updatedAt" : "2021-01-29T03:32:05Z",
        "lastEditedBy" : "3e6e337f-0beb-4609-abc3-11b8e8cf5688",
        "tags" : [
        ]
      },
      {
        "id" : "0a31f210-2e00-444a-9274-19010c367b08",
        "parentId" : "af574fce-444c-44eb-a662-931d56636e22",
        "authorId" : "7a59a326-58b3-4590-b70a-297d2e27daa5",
        "body" : "Very good, the exact synchronization in this revision looks like it should make for reliable tests.",
        "createdAt" : "2021-01-26T04:43:40Z",
        "updatedAt" : "2021-01-29T03:32:05Z",
        "lastEditedBy" : "7a59a326-58b3-4590-b70a-297d2e27daa5",
        "tags" : [
        ]
      }
    ],
    "commit" : "1d691ddb44e8dfa54008977469201a811410f7e9",
    "line" : 126,
    "diffHunk" : "@@ -1,1 +414,418 @@\t})\n\n\tt.Run(\"priority level concurrency is set to 1, request times out and inner handler hasn't written to the response yet\", func(t *testing.T) {\n\t\tconst (\n\t\t\trequestTimeout                                        = 3 * time.Second"
  },
  {
    "id" : "6752e2a4-57cf-4fcc-93c5-39153c59eb36",
    "prId" : 97471,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/97471#pullrequestreview-576004908",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bd60184d-d2b2-4cd1-a167-3522591e6ad4",
        "parentId" : null,
        "authorId" : "7a59a326-58b3-4590-b70a-297d2e27daa5",
        "body" : "I would move the `!executed` test up to here; if ever `executed` is false for some reason, the `<-reqHandlerCompletedCh` will hang and it would be good for that to be preceded by a revelatory log message.",
        "createdAt" : "2021-01-26T04:50:05Z",
        "updatedAt" : "2021-01-29T03:32:05Z",
        "lastEditedBy" : "7a59a326-58b3-4590-b70a-297d2e27daa5",
        "tags" : [
        ]
      }
    ],
    "commit" : "1d691ddb44e8dfa54008977469201a811410f7e9",
    "line" : 168,
    "diffHunk" : "@@ -1,1 +456,460 @@\t\t\tresponse, err = requestGetter(rquestTimesOutPath)\n\t\t}()\n\n\t\tif !executed {\n\t\t\tt.Errorf(\"Expected inner handler to be executed for request: %q\", rquestTimesOutPath)"
  },
  {
    "id" : "b0e8724b-88f1-4918-8540-e36fedaee1e3",
    "prId" : 97471,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/97471#pullrequestreview-576734988",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "426146a8-9c84-44d5-9086-efe99c5fd152",
        "parentId" : null,
        "authorId" : "7a59a326-58b3-4590-b70a-297d2e27daa5",
        "body" : "Given that it is immediately followed by another wait, do we need this wait?",
        "createdAt" : "2021-01-26T04:55:52Z",
        "updatedAt" : "2021-01-29T03:32:05Z",
        "lastEditedBy" : "7a59a326-58b3-4590-b70a-297d2e27daa5",
        "tags" : [
        ]
      },
      {
        "id" : "ba04ec79-debe-478c-b38f-1b7732042a4e",
        "parentId" : "426146a8-9c84-44d5-9086-efe99c5fd152",
        "authorId" : "3e6e337f-0beb-4609-abc3-11b8e8cf5688",
        "body" : "@MikeSpreitzer The second (enqueued) request may be timed out promptly ( within `1/4th` of the request timeout, if we fix p&f in the future)  and the following synchronization issue might happen: \r\nA: T+0s: first request being executed (timeout = `60s` for example)\r\nB: T+1s: second request arrives and is enqueued (timeout = `60s`)\r\nC: T+16s: second request is rejected with a 429 \r\nD: `secondReqRoundTripDoneCh` unblocks and the first request executes and it does not time out as designed.\r\n\r\nThe test does not assume when the enqueued request is expected to time out, thoughts?",
        "createdAt" : "2021-01-26T19:15:35Z",
        "updatedAt" : "2021-01-29T03:32:05Z",
        "lastEditedBy" : "3e6e337f-0beb-4609-abc3-11b8e8cf5688",
        "tags" : [
        ]
      },
      {
        "id" : "0b971514-c51b-4794-bdb6-dd3526072185",
        "parentId" : "426146a8-9c84-44d5-9086-efe99c5fd152",
        "authorId" : "7a59a326-58b3-4590-b70a-297d2e27daa5",
        "body" : "Good answer.  In short, we need both waits because the design is to wait for the later of two events and the test deliberately does not make an assumption about which one happens later.",
        "createdAt" : "2021-01-26T20:29:46Z",
        "updatedAt" : "2021-01-29T03:32:05Z",
        "lastEditedBy" : "7a59a326-58b3-4590-b70a-297d2e27daa5",
        "tags" : [
        ]
      }
    ],
    "commit" : "1d691ddb44e8dfa54008977469201a811410f7e9",
    "line" : 338,
    "diffHunk" : "@@ -1,1 +626,630 @@\n\t\t\t\tclose(firstReqInProgressCh)\n\t\t\t\t<-firstReqRoundTripDoneCh\n\n\t\t\t\t// make sure we wait until the caller of the second request returns, this is to"
  },
  {
    "id" : "18910730-5edb-4901-8206-546f5cc528d9",
    "prId" : 97471,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/97471#pullrequestreview-579526637",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "31548e44-6e34-4df5-a5aa-0f3f07186ad5",
        "parentId" : null,
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "are you worried about this falling out of sync with the real one?",
        "createdAt" : "2021-01-29T16:21:37Z",
        "updatedAt" : "2021-01-29T16:21:38Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      },
      {
        "id" : "071e6ab4-7ce1-4cea-ae2e-08a1bc26ee35",
        "parentId" : "31548e44-6e34-4df5-a5aa-0f3f07186ad5",
        "authorId" : "7a59a326-58b3-4590-b70a-297d2e27daa5",
        "body" : "This is a unit test, so I think it is OK to not match the full real handler chain.",
        "createdAt" : "2021-01-29T18:48:43Z",
        "updatedAt" : "2021-01-29T18:48:43Z",
        "lastEditedBy" : "7a59a326-58b3-4590-b70a-297d2e27daa5",
        "tags" : [
        ]
      }
    ],
    "commit" : "1d691ddb44e8dfa54008977469201a811410f7e9",
    "line" : 454,
    "diffHunk" : "@@ -1,1 +808,812 @@\thandler = WithTimeoutForNonLongRunningRequests(handler, longRunningRequestCheck)\n\t// we don't have any request with invalid timeout, so leaving audit policy and sink nil.\n\thandler = apifilters.WithRequestDeadline(handler, nil, nil, longRunningRequestCheck, nil, requestTimeout)\n\thandler = apifilters.WithRequestInfo(handler, requestInfoFactory)\n\thandler = WithPanicRecovery(handler, requestInfoFactory)"
  },
  {
    "id" : "ab064368-feda-476f-bc25-8110adf0fd00",
    "prId" : 97206,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/97206#pullrequestreview-554333043",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9418e4c6-3a5f-4f48-9708-011470fea8b2",
        "parentId" : null,
        "authorId" : "7a59a326-58b3-4590-b70a-297d2e27daa5",
        "body" : "A server concurrency limit of 1 will be simplest and will be adequate for this test.  Remember the `Ceil` in https://github.com/kubernetes/apiserver/blob/a7ed7d2749703632c8eea6f91bc179500737dd7e/pkg/util/flowcontrol/apf_controller.go#L535 .  We do not need reverse engineering like in `getServerConcurrency`.  Simply setting the server concurrency limit to 1 means that every priority level will get a concurrency limit of 1.",
        "createdAt" : "2020-12-17T07:19:44Z",
        "updatedAt" : "2020-12-19T03:13:42Z",
        "lastEditedBy" : "7a59a326-58b3-4590-b70a-297d2e27daa5",
        "tags" : [
        ]
      }
    ],
    "commit" : "13cedca0eb5337b13e5176983ea5e784ec38df22",
    "line" : 52,
    "diffHunk" : "@@ -1,1 +361,365 @@\t\t// this test does not rely on resync, so resync period is set to zero\n\t\tfactory := informers.NewSharedInformerFactory(clientset, 0)\n\t\tcontroller := utilflowcontrol.New(factory, clientset.FlowcontrolV1beta1(), serverConcurrency, requestTimeout/4)\n\n\t\tstopCh, controllerCompletedCh := make(chan struct{}), make(chan struct{})"
  },
  {
    "id" : "5a3639ee-37cb-4b60-bb3b-966e2207d02c",
    "prId" : 93877,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/93877#pullrequestreview-471901440",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5a5ce698-2cfb-4347-a228-4dad92020654",
        "parentId" : null,
        "authorId" : "7a59a326-58b3-4590-b70a-297d2e27daa5",
        "body" : "`queueNoteFn(true)` should be paired with `queueNoteFn(false)`",
        "createdAt" : "2020-08-20T05:22:40Z",
        "updatedAt" : "2020-11-02T03:46:20Z",
        "lastEditedBy" : "7a59a326-58b3-4590-b70a-297d2e27daa5",
        "tags" : [
        ]
      },
      {
        "id" : "ae605ce4-3042-4a48-8bd1-93a33fdbbe12",
        "parentId" : "5a5ce698-2cfb-4347-a228-4dad92020654",
        "authorId" : "171bb666-1454-4ba5-866b-e46f2bd90421",
        "body" : "Thanks for the details in the new PR. I hope I've faked right this time...",
        "createdAt" : "2020-08-20T17:04:12Z",
        "updatedAt" : "2020-11-02T03:46:20Z",
        "lastEditedBy" : "171bb666-1454-4ba5-866b-e46f2bd90421",
        "tags" : [
        ]
      },
      {
        "id" : "927b439b-e2d2-43e2-9f68-72add90b26ad",
        "parentId" : "5a5ce698-2cfb-4347-a228-4dad92020654",
        "authorId" : "7a59a326-58b3-4590-b70a-297d2e27daa5",
        "body" : "Looks good now",
        "createdAt" : "2020-08-20T19:04:14Z",
        "updatedAt" : "2020-11-02T03:46:20Z",
        "lastEditedBy" : "7a59a326-58b3-4590-b70a-297d2e27daa5",
        "tags" : [
        ]
      }
    ],
    "commit" : "833ce487b9fab1650d5aaba2a8b295f8a90e07bd",
    "line" : 76,
    "diffHunk" : "@@ -1,1 +74,78 @@\t\texecFn()\n\tcase decisionQueuingExecute:\n\t\tqueueNoteFn(true)\n\t\tt.postEnqueue()\n\t\tqueueNoteFn(false)"
  },
  {
    "id" : "5c94a134-493f-4f87-8fb4-75f5b53bf028",
    "prId" : 93877,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/93877#pullrequestreview-520344725",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c9f6be15-ea37-428f-b3ed-65c713096dba",
        "parentId" : null,
        "authorId" : "7a59a326-58b3-4590-b70a-297d2e27daa5",
        "body" : "In this case k/apiserver/pkg/util/flowcontrol.Interface.Handle should not even be called.  The test could be enhanced to check that.",
        "createdAt" : "2020-08-20T05:25:19Z",
        "updatedAt" : "2020-11-02T03:46:20Z",
        "lastEditedBy" : "7a59a326-58b3-4590-b70a-297d2e27daa5",
        "tags" : [
        ]
      },
      {
        "id" : "61ada584-fddd-4745-b618-70a7cdc31a97",
        "parentId" : "c9f6be15-ea37-428f-b3ed-65c713096dba",
        "authorId" : "171bb666-1454-4ba5-866b-e46f2bd90421",
        "body" : "Done. Will `panic` if Handle gets called. Thanks for the suggestion.",
        "createdAt" : "2020-08-20T16:49:35Z",
        "updatedAt" : "2020-11-02T03:46:20Z",
        "lastEditedBy" : "171bb666-1454-4ba5-866b-e46f2bd90421",
        "tags" : [
        ]
      },
      {
        "id" : "167bd3a0-4319-4f17-9fab-a4899fe91422",
        "parentId" : "c9f6be15-ea37-428f-b3ed-65c713096dba",
        "authorId" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "body" : "please clarify that the request is skipped because it is a watch request, it took me a while to figure that out.",
        "createdAt" : "2020-10-30T15:04:01Z",
        "updatedAt" : "2020-11-02T03:46:20Z",
        "lastEditedBy" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "tags" : [
        ]
      }
    ],
    "commit" : "833ce487b9fab1650d5aaba2a8b295f8a90e07bd",
    "line" : 150,
    "diffHunk" : "@@ -1,1 +148,152 @@}\n\nfunc TestApfSkipLongRunningRequest(t *testing.T) {\n\tepmetrics.Register()\n"
  },
  {
    "id" : "a1b24bc1-625d-4dd0-a39d-fc1f40896716",
    "prId" : 93877,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/93877#pullrequestreview-471250100",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d41c6d26-bbfe-4d8c-9d0e-d4badecb6783",
        "parentId" : null,
        "authorId" : "7a59a326-58b3-4590-b70a-297d2e27daa5",
        "body" : "When I run these tests, I get failures:\r\n\r\n```\r\n--- FAIL: TestApfCanceledRequest (1.00s)\r\n    priority-and-fairness_test.go:168: Expected metrics count 3, but got 2\r\n--- FAIL: TestApfExecutingRequest (1.00s)\r\n    priority-and-fairness_test.go:168: Expected metrics count 3, but got 2\r\n```",
        "createdAt" : "2020-08-20T05:48:13Z",
        "updatedAt" : "2020-11-02T03:46:20Z",
        "lastEditedBy" : "7a59a326-58b3-4590-b70a-297d2e27daa5",
        "tags" : [
        ]
      }
    ],
    "commit" : "833ce487b9fab1650d5aaba2a8b295f8a90e07bd",
    "line" : 218,
    "diffHunk" : "@@ -1,1 +216,220 @@\tcheckForExpectedMetricsWithRetry(t, []string{\n\t\t\"apiserver_current_inflight_requests\",\n\t\t\"apiserver_current_inqueue_requests\",\n\t\t\"apiserver_flowcontrol_read_vs_write_request_count_watermarks\",\n\t\t\"apiserver_flowcontrol_read_vs_write_request_count_samples\","
  },
  {
    "id" : "336fb788-b714-4e26-ac88-a7e3051fabe4",
    "prId" : 93877,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/93877#pullrequestreview-471813580",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e37d1a9e-e415-484e-b012-9c82eb34b596",
        "parentId" : null,
        "authorId" : "7a59a326-58b3-4590-b70a-297d2e27daa5",
        "body" : "apiserver_flowcontrol_read_vs_write_request_count_watermarks appears if and only if apiserver_flowcontrol_read_vs_write_request_count_samples appears.  They are not guaranteed to appear in such a quick test.  OTOH, if the test waits at least a millisecond (see https://github.com/kubernetes/apiserver/blob/09eab1cf2cce55a46e5d9042c90f136d91383e19/pkg/util/flowcontrol/metrics/metrics.go#L125, and wait longer to be safe) between `fcmetrics.Register()` and invoking the APF filter, then those two should appear.",
        "createdAt" : "2020-08-20T06:02:32Z",
        "updatedAt" : "2020-11-02T03:46:20Z",
        "lastEditedBy" : "7a59a326-58b3-4590-b70a-297d2e27daa5",
        "tags" : [
        ]
      },
      {
        "id" : "02fa027f-a455-4d52-8470-9145f886a80b",
        "parentId" : "e37d1a9e-e415-484e-b012-9c82eb34b596",
        "authorId" : "171bb666-1454-4ba5-866b-e46f2bd90421",
        "body" : "Thanks for the explanation. Fixed the possible race here.",
        "createdAt" : "2020-08-20T16:59:04Z",
        "updatedAt" : "2020-11-02T03:46:20Z",
        "lastEditedBy" : "171bb666-1454-4ba5-866b-e46f2bd90421",
        "tags" : [
        ]
      }
    ],
    "commit" : "833ce487b9fab1650d5aaba2a8b295f8a90e07bd",
    "line" : 219,
    "diffHunk" : "@@ -1,1 +217,221 @@\t\t\"apiserver_current_inflight_requests\",\n\t\t\"apiserver_current_inqueue_requests\",\n\t\t\"apiserver_flowcontrol_read_vs_write_request_count_watermarks\",\n\t\t\"apiserver_flowcontrol_read_vs_write_request_count_samples\",\n\t})"
  },
  {
    "id" : "5c03a38f-65f5-4bf2-93ed-76719b99a8dd",
    "prId" : 93877,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/93877#pullrequestreview-473020273",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a55ea742-8c7d-46fd-af9c-2e6e2e748189",
        "parentId" : null,
        "authorId" : "7a59a326-58b3-4590-b70a-297d2e27daa5",
        "body" : "The logic here would be simpler if it first makes a map containing all the metric names from `metricsFamily` and then iterates through `expectedMetrics` to check for presence.",
        "createdAt" : "2020-08-20T19:09:27Z",
        "updatedAt" : "2020-11-02T03:46:20Z",
        "lastEditedBy" : "7a59a326-58b3-4590-b70a-297d2e27daa5",
        "tags" : [
        ]
      },
      {
        "id" : "82567d91-4217-4fd4-b784-c8e4203de8b9",
        "parentId" : "a55ea742-8c7d-46fd-af9c-2e6e2e748189",
        "authorId" : "171bb666-1454-4ba5-866b-e46f2bd90421",
        "body" : "Done",
        "createdAt" : "2020-08-23T15:24:01Z",
        "updatedAt" : "2020-11-02T03:46:20Z",
        "lastEditedBy" : "171bb666-1454-4ba5-866b-e46f2bd90421",
        "tags" : [
        ]
      }
    ],
    "commit" : "833ce487b9fab1650d5aaba2a8b295f8a90e07bd",
    "line" : 322,
    "diffHunk" : "@@ -1,1 +320,324 @@\t\t\tt.Fatalf(\"Failed to gather metrics %v\", err)\n\t\t}\n\n\t\tmetrics := map[string]interface{}{}\n\t\tfor _, mf := range metricsFamily {"
  },
  {
    "id" : "92fee6fb-27cb-4a6b-8bd1-92b19708ebee",
    "prId" : 93877,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/93877#pullrequestreview-519819190",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2ead985d-e26c-459e-b428-229364dc2d36",
        "parentId" : null,
        "authorId" : "7a59a326-58b3-4590-b70a-297d2e27daa5",
        "body" : "This one also fails when I run it in commit 3121fe16a20e046d85419a4aff06edbe220b39b2:\r\n```\r\n--- FAIL: TestApfExecuteRequest (1.57s)\r\n    priority-and-fairness_test.go:208: Scraped metrics did not include expected metric apiserver_current_inqueue_requests\r\n```\r\n",
        "createdAt" : "2020-08-20T19:23:06Z",
        "updatedAt" : "2020-11-02T03:46:20Z",
        "lastEditedBy" : "7a59a326-58b3-4590-b70a-297d2e27daa5",
        "tags" : [
        ]
      },
      {
        "id" : "c76223ae-6dff-43c4-a7d2-d0dee8336d15",
        "parentId" : "2ead985d-e26c-459e-b428-229364dc2d36",
        "authorId" : "7a59a326-58b3-4590-b70a-297d2e27daa5",
        "body" : "Passing now.",
        "createdAt" : "2020-10-29T15:55:24Z",
        "updatedAt" : "2020-11-02T03:46:20Z",
        "lastEditedBy" : "7a59a326-58b3-4590-b70a-297d2e27daa5",
        "tags" : [
        ]
      }
    ],
    "commit" : "833ce487b9fab1650d5aaba2a8b295f8a90e07bd",
    "line" : 231,
    "diffHunk" : "@@ -1,1 +229,233 @@\t// so that an observation will cause some data to go into the Prometheus metrics.\n\ttime.Sleep(time.Millisecond * 50)\n\n\tconcurrentRequests := 5\n\tvar preStartExecute, postStartExecute, preEnqueue, postEnqueue, preDequeue, postDequeue, finishExecute sync.WaitGroup"
  },
  {
    "id" : "7a8511d9-efd3-4888-b0a9-959fd2c87220",
    "prId" : 93877,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/93877#pullrequestreview-504457684",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fe522df6-0ee3-42b0-a2d0-a0563cedea36",
        "parentId" : null,
        "authorId" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "body" : "is there a deterministic way to ensure that? what happens if the metrics were not collected in time?",
        "createdAt" : "2020-10-05T20:54:27Z",
        "updatedAt" : "2020-11-02T03:46:20Z",
        "lastEditedBy" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "tags" : [
        ]
      },
      {
        "id" : "96d7dde0-ee57-4da7-aa62-84bf1b944b7d",
        "parentId" : "fe522df6-0ee3-42b0-a2d0-a0563cedea36",
        "authorId" : "7a59a326-58b3-4590-b70a-297d2e27daa5",
        "body" : "See above.",
        "createdAt" : "2020-10-08T06:18:57Z",
        "updatedAt" : "2020-11-02T03:46:20Z",
        "lastEditedBy" : "7a59a326-58b3-4590-b70a-297d2e27daa5",
        "tags" : [
        ]
      }
    ],
    "commit" : "833ce487b9fab1650d5aaba2a8b295f8a90e07bd",
    "line" : 207,
    "diffHunk" : "@@ -1,1 +205,209 @@\t// Wait for at least one sampling window to pass since creation of metrics.ReadWriteConcurrencyObserverPairGenerator,\n\t// so that an observation will cause some data to go into the Prometheus metrics.\n\ttime.Sleep(time.Millisecond * 50)\n\n\tserver := newApfServerWithSingleRequest(decisionQueuingExecute, t)"
  },
  {
    "id" : "5e2be42e-948a-434a-9a5f-44e31ad78796",
    "prId" : 93877,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/93877#pullrequestreview-504457407",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "26da5d16-a34d-4147-a99d-d36a5072042b",
        "parentId" : null,
        "authorId" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "body" : "is this really necessary? do we do such a thing in prod code? if so, it is better to try and make this deterministic, for example read the metrics we care about and check that they have the expected initial value/state.",
        "createdAt" : "2020-10-05T21:54:18Z",
        "updatedAt" : "2020-11-02T03:46:20Z",
        "lastEditedBy" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "tags" : [
        ]
      },
      {
        "id" : "9e9cb9d0-58e0-4a6a-aa04-58847bdf3279",
        "parentId" : "26da5d16-a34d-4147-a99d-d36a5072042b",
        "authorId" : "7a59a326-58b3-4590-b70a-297d2e27daa5",
        "body" : "I think you misunderstood what is going on here.  I have suggested an update to the comment that should point the reader in the right direction.",
        "createdAt" : "2020-10-08T06:18:17Z",
        "updatedAt" : "2020-11-02T03:46:20Z",
        "lastEditedBy" : "7a59a326-58b3-4590-b70a-297d2e27daa5",
        "tags" : [
        ]
      }
    ],
    "commit" : "833ce487b9fab1650d5aaba2a8b295f8a90e07bd",
    "line" : 185,
    "diffHunk" : "@@ -1,1 +183,187 @@\t// Wait for at least one sampling window to pass since creation of metrics.ReadWriteConcurrencyObserverPairGenerator,\n\t// so that an observation will cause some data to go into the Prometheus metrics.\n\ttime.Sleep(time.Millisecond * 50)\n\n\tserver := newApfServerWithSingleRequest(decisionNoQueuingExecute, t)"
  },
  {
    "id" : "38b1572a-e081-4ee2-bcf1-72080baf3a20",
    "prId" : 93877,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/93877#pullrequestreview-504931742",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4f958c53-52c5-4187-9411-f53f87f8a827",
        "parentId" : null,
        "authorId" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "body" : "is the expectation that the metrics will not exist if they didn't get set at least once? can check for explicit values? we can reset the metrics at the beginning of each test I think (or assert on some delta).",
        "createdAt" : "2020-10-05T22:18:58Z",
        "updatedAt" : "2020-11-02T03:46:20Z",
        "lastEditedBy" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "tags" : [
        ]
      },
      {
        "id" : "f5ba8788-3948-423c-b556-491a6e07c8a4",
        "parentId" : "4f958c53-52c5-4187-9411-f53f87f8a827",
        "authorId" : "7a59a326-58b3-4590-b70a-297d2e27daa5",
        "body" : "Yes, Prometheus `HistogramVector` objects are being used, which means the actual metrics do not exist until data is put into at least one Histogram in the Vector.",
        "createdAt" : "2020-10-08T06:22:04Z",
        "updatedAt" : "2020-11-02T03:46:20Z",
        "lastEditedBy" : "7a59a326-58b3-4590-b70a-297d2e27daa5",
        "tags" : [
        ]
      },
      {
        "id" : "8ec056f4-d979-4e91-80e7-066413bad126",
        "parentId" : "4f958c53-52c5-4187-9411-f53f87f8a827",
        "authorId" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "body" : "can we check for specific values instead of just checking that the metric exist?",
        "createdAt" : "2020-10-08T13:08:57Z",
        "updatedAt" : "2020-11-02T03:46:20Z",
        "lastEditedBy" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "tags" : [
        ]
      },
      {
        "id" : "5a689a1f-a8d9-42b2-b472-b9904f266cf5",
        "parentId" : "4f958c53-52c5-4187-9411-f53f87f8a827",
        "authorId" : "7a59a326-58b3-4590-b70a-297d2e27daa5",
        "body" : "yes, if the test func waits for at least one sampling period, after any activity, before reading the metrics.",
        "createdAt" : "2020-10-08T15:55:32Z",
        "updatedAt" : "2020-11-02T03:46:20Z",
        "lastEditedBy" : "7a59a326-58b3-4590-b70a-297d2e27daa5",
        "tags" : [
        ]
      }
    ],
    "commit" : "833ce487b9fab1650d5aaba2a8b295f8a90e07bd",
    "line" : 340,
    "diffHunk" : "@@ -1,1 +338,342 @@}\n\nfunc checkForExpectedMetrics(expectedMetrics []string, metrics map[string]interface{}) []error {\n\tvar errs []error\n\tfor _, metricName := range expectedMetrics {"
  },
  {
    "id" : "caac2096-4de8-4885-b977-afb655b54841",
    "prId" : 93877,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/93877#pullrequestreview-504454295",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "feb3c566-a51b-473e-94d9-efdf96816f8d",
        "parentId" : null,
        "authorId" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "body" : "where is this metric defined?",
        "createdAt" : "2020-10-05T22:34:56Z",
        "updatedAt" : "2020-11-02T03:46:20Z",
        "lastEditedBy" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "tags" : [
        ]
      },
      {
        "id" : "69fc4f78-ea84-4401-8d50-8cc940da16d1",
        "parentId" : "feb3c566-a51b-473e-94d9-efdf96816f8d",
        "authorId" : "7a59a326-58b3-4590-b70a-297d2e27daa5",
        "body" : "https://github.com/kubernetes/apiserver/blob/8dc7971548234eb6700b52291a7dd817ddc8d323/pkg/endpoints/metrics/metrics.go#L166",
        "createdAt" : "2020-10-08T06:11:02Z",
        "updatedAt" : "2020-11-02T03:46:20Z",
        "lastEditedBy" : "7a59a326-58b3-4590-b70a-297d2e27daa5",
        "tags" : [
        ]
      }
    ],
    "commit" : "833ce487b9fab1650d5aaba2a8b295f8a90e07bd",
    "line" : 195,
    "diffHunk" : "@@ -1,1 +193,197 @@\n\tcheckForExpectedMetricsWithRetry(t, []string{\n\t\t\"apiserver_current_inflight_requests\",\n\t\t\"apiserver_flowcontrol_read_vs_write_request_count_watermarks\",\n\t\t\"apiserver_flowcontrol_read_vs_write_request_count_samples\","
  }
]
[
  {
    "id" : "7c1ebad5-cb0f-4661-adce-e1c1c8a826e4",
    "prId" : 103660,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/103660#pullrequestreview-705509159",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "94653e39-81b0-46b5-999f-60ed0fe392f1",
        "parentId" : null,
        "authorId" : "3e6e337f-0beb-4609-abc3-11b8e8cf5688",
        "body" : "should we defer the `cancel` func here so it always gets canceled - `defer handleCtxCancel()`?",
        "createdAt" : "2021-07-13T14:16:44Z",
        "updatedAt" : "2021-07-13T15:51:41Z",
        "lastEditedBy" : "3e6e337f-0beb-4609-abc3-11b8e8cf5688",
        "tags" : [
        ]
      },
      {
        "id" : "1d70f8bc-ec1a-455b-aab4-8182033f7679",
        "parentId" : "94653e39-81b0-46b5-999f-60ed0fe392f1",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "put it in defer as soon as it is created below",
        "createdAt" : "2021-07-13T18:19:31Z",
        "updatedAt" : "2021-07-13T18:27:04Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "faed88bb7200cc4693b7a3f9cecff1a99ea1fc95",
    "line" : 149,
    "diffHunk" : "@@ -1,1 +200,204 @@\t\t\t\t\t// Ensure that the result is put into resultCh independently of the panic.\n\t\t\t\t\tresultCh <- err\n\t\t\t\t}()\n\n\t\t\t\t// We create handleCtx with explicit cancelation function."
  },
  {
    "id" : "13b7ede6-f4e7-447a-ac09-00754ac6ddd3",
    "prId" : 103660,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/103660#pullrequestreview-705509159",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a20a20d7-7284-4007-85ee-07d1550f3b51",
        "parentId" : null,
        "authorId" : "3e6e337f-0beb-4609-abc3-11b8e8cf5688",
        "body" : "nit: can we add a comment here that says this defer applies to the main goroutine?",
        "createdAt" : "2021-07-13T14:24:20Z",
        "updatedAt" : "2021-07-13T15:51:41Z",
        "lastEditedBy" : "3e6e337f-0beb-4609-abc3-11b8e8cf5688",
        "tags" : [
        ]
      },
      {
        "id" : "4314062a-1c87-4bec-b2a5-ef90d639bd84",
        "parentId" : "a20a20d7-7284-4007-85ee-07d1550f3b51",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "I think this is obvious from the code - we should avoid comments that are clear from just reading the code.",
        "createdAt" : "2021-07-13T18:25:58Z",
        "updatedAt" : "2021-07-13T18:27:04Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "faed88bb7200cc4693b7a3f9cecff1a99ea1fc95",
    "line" : 168,
    "diffHunk" : "@@ -1,1 +219,223 @@\t\t\t\tfcIfc.Handle(handleCtx, digest, note, queueNote, execute)\n\t\t\t}()\n\n\t\t\tselect {\n\t\t\tcase <-shouldStartWatchCh:"
  },
  {
    "id" : "ee9ac9ac-b37a-4f9f-8f3d-facb4d3a11e6",
    "prId" : 103660,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/103660#pullrequestreview-705509159",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4d205237-5630-4fce-bdfc-f6670e8716c6",
        "parentId" : null,
        "authorId" : "3e6e337f-0beb-4609-abc3-11b8e8cf5688",
        "body" : "nit: can we add a comment here saying that `fcIfc.Handle` will return irrespective of whether the request executes or is rejected. if a request is rejected after waiting for some time in the queue `fcIfc.Handle` will return and the `execute` function will not be executed.",
        "createdAt" : "2021-07-13T15:21:08Z",
        "updatedAt" : "2021-07-13T15:51:41Z",
        "lastEditedBy" : "3e6e337f-0beb-4609-abc3-11b8e8cf5688",
        "tags" : [
        ]
      },
      {
        "id" : "44c67d62-e0c8-4c00-8bb9-a23e14684fc5",
        "parentId" : "4d205237-5630-4fce-bdfc-f6670e8716c6",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "done",
        "createdAt" : "2021-07-13T18:18:54Z",
        "updatedAt" : "2021-07-13T18:27:04Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "faed88bb7200cc4693b7a3f9cecff1a99ea1fc95",
    "line" : 162,
    "diffHunk" : "@@ -1,1 +213,217 @@\t\t\t\thandleCtx, handleCtxCancel := context.WithCancel(ctx)\n\t\t\t\tdefer handleCtxCancel()\n\n\t\t\t\t// Note that Handle will return irrespective of whether the request\n\t\t\t\t// executes or is rejected. In the latter case, the function will return"
  },
  {
    "id" : "a47c7cca-be61-4262-b81f-361a3672b069",
    "prId" : 103660,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/103660#pullrequestreview-705509159",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c96ae963-c5c5-4494-85dd-3df310f75d0d",
        "parentId" : null,
        "authorId" : "3e6e337f-0beb-4609-abc3-11b8e8cf5688",
        "body" : "if the goroutine executing `fcIfc.Handle` panics after we are here (it's an edge case) then the following block `err := <-resultCh:` never executes and we don't propagate the error to the caller go routine.\r\n\r\nso the goroutine executing `fcIfc.Handle` can run for some time after `handler.ServeHTTP(w, watchReq)` starts executing.\r\n\r\nmaybe we can split it like below?\r\n```\r\nselect {\r\n\t\t\tcase <-shouldStartWatchCh:\r\n\t\t\t\thandler.ServeHTTP(w, watchReq)\r\n\t\t\t\tif err := <-resultCh; err != nil {\r\n\t\t\t\t\tpanic(err)\r\n\t\t\t\t}\r\n\t\t\tcase <-handleCtx.Done():\r\n}\r\n\r\n// the following channel should not block forever.\r\nerr := <-resultCh:\r\nif err != nil {\r\n    if served {\r\n          // log the error\r\n    } else {\t\r\n       panic(err)\r\n   }\r\n}\r\n```",
        "createdAt" : "2021-07-13T15:37:17Z",
        "updatedAt" : "2021-07-13T15:51:41Z",
        "lastEditedBy" : "3e6e337f-0beb-4609-abc3-11b8e8cf5688",
        "tags" : [
        ]
      },
      {
        "id" : "903ba460-b03e-4553-9d1e-e0f4dd4cbd8b",
        "parentId" : "c96ae963-c5c5-4494-85dd-3df310f75d0d",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "I think I'm not fully following your suggestion (I understand the problem you're pointing, but not the solution).\r\n\r\nCan you clarify?",
        "createdAt" : "2021-07-13T15:59:52Z",
        "updatedAt" : "2021-07-13T16:00:31Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      },
      {
        "id" : "9813d746-2571-48b2-a8ce-7816fbc54ed3",
        "parentId" : "c96ae963-c5c5-4494-85dd-3df310f75d0d",
        "authorId" : "3e6e337f-0beb-4609-abc3-11b8e8cf5688",
        "body" : "oh, i missed the part where you read from `resultCh` and panic if there is an error\r\n```\r\n\t\t\tcase <-shouldStartWatchCh:\r\n\t\t\t\thandler.ServeHTTP(w, watchReq)\r\n\t\t\t\tif err := <-resultCh; err != nil {\r\n\t\t\t\t\tpanic(err)\r\n\t\t\t\t}\r\n```\r\n\r\nI think this resolves the problem. The question is should we panic here or log the error? The watch request has completed after `handler.ServeHTTP(w, watchReq)` and the response has already been set appropriately. I think panic is the right approach, it makes the error more visible. \r\nIdeally we should terminate the request as soon as `fcIfc.Handle` panics, but this can be a follow up.",
        "createdAt" : "2021-07-13T16:59:15Z",
        "updatedAt" : "2021-07-13T16:59:15Z",
        "lastEditedBy" : "3e6e337f-0beb-4609-abc3-11b8e8cf5688",
        "tags" : [
        ]
      },
      {
        "id" : "e426216f-025b-4a3d-a3e8-17942d15d310",
        "parentId" : "c96ae963-c5c5-4494-85dd-3df310f75d0d",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "Added a todo about termination.",
        "createdAt" : "2021-07-13T18:25:24Z",
        "updatedAt" : "2021-07-13T18:27:04Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "faed88bb7200cc4693b7a3f9cecff1a99ea1fc95",
    "line" : 170,
    "diffHunk" : "@@ -1,1 +221,225 @@\n\t\t\tselect {\n\t\t\tcase <-shouldStartWatchCh:\n\t\t\t\twatchCtx := utilflowcontrol.WithInitializationSignal(ctx, watchInitializationSignal)\n\t\t\t\twatchReq = r.WithContext(watchCtx)"
  },
  {
    "id" : "1353165a-1a38-4825-91ac-a25212099309",
    "prId" : 103660,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/103660#pullrequestreview-708040195",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "68adb7cd-a641-4275-8b82-f39784afe53f",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "APF doesn't care how many parallel watchers you establish? I would have expected that to matter to APF, and telling APF the request has finished before it actually has makes it impossible for APF to track that, right?",
        "createdAt" : "2021-07-15T15:54:48Z",
        "updatedAt" : "2021-07-15T15:54:48Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "c577386c-2a9d-47cd-8cd8-82a02d10bafa",
        "parentId" : "68adb7cd-a641-4275-8b82-f39784afe53f",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "It's hard to explain in few words. if you're interested in more details it's in these two keps:\r\nhttps://github.com/kubernetes/enhancements/pull/2669/files\r\nhttps://github.com/kubernetes/enhancements/pull/2700\r\n\r\nBut trying to put it short, we divide watch into two phases:\r\n1) initialization\r\n2) keeping up with incoming events\r\n\r\n(1) is what we handle here exactly [and we finish the goroutine as soon as watch is initialized]\r\n(2) after that, the cost of watch is kind-of connected to the write request, for multiple different reasons described in the KEP",
        "createdAt" : "2021-07-15T16:08:22Z",
        "updatedAt" : "2021-07-15T16:11:31Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      },
      {
        "id" : "f0b9474a-a6c6-4ce4-b79d-fff7e16bfd4f",
        "parentId" : "68adb7cd-a641-4275-8b82-f39784afe53f",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "> after that, the cost of watch is kind-of connected to the write request, for multiple different reasons described in the KEP\r\n\r\nbut who is the cost attributed to, the watcher(s) or the writer? I would expect APF to prevent a user from opening a ton of parallel watches rather than keep a writer from doing a single write to a resource that happens to have a lot of watches on it.",
        "createdAt" : "2021-07-15T22:44:29Z",
        "updatedAt" : "2021-07-15T22:44:29Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "5b2917db-9c0e-4925-b844-6ad6d9c63915",
        "parentId" : "68adb7cd-a641-4275-8b82-f39784afe53f",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "we can hoist this out of this PR... it's clearly a bigger discussion... it just seems like this PR is wiring up stuff that will have to be undone to get APF to behave the way I (probably naively) expected it to",
        "createdAt" : "2021-07-15T22:49:12Z",
        "updatedAt" : "2021-07-15T22:49:13Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "087fa06b-04a8-4757-8048-16322327452e",
        "parentId" : "68adb7cd-a641-4275-8b82-f39784afe53f",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "> it just seems like this PR is wiring up stuff that will have to be undone to get APF to behave the way I (probably naively) expected it to\r\n\r\nNo - the initialization will remain as is [the initialization is kind-of done as no-longrunning requests - from POV of APF the watch request finishes after initialization is done.]\r\n\r\nRe \"keeping watch up-to-date\" (which is a separate problem) - let's take it out of this PR [it's an orthogonal discussion.]",
        "createdAt" : "2021-07-16T06:22:55Z",
        "updatedAt" : "2021-07-16T06:30:43Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "faed88bb7200cc4693b7a3f9cecff1a99ea1fc95",
    "line" : 156,
    "diffHunk" : "@@ -1,1 +207,211 @@\t\t\t\t// we don't want to wait until the whole watch request is processed (which is\n\t\t\t\t// when it context is actually cancelled) - we want to unblock the goroutine as\n\t\t\t\t// soon as the request is processed from the APF point of view.\n\t\t\t\t//\n\t\t\t\t// Note that we explicitly do NOT call the actuall handler using that context"
  },
  {
    "id" : "593df662-5df7-40db-81fc-30c44a0c984d",
    "prId" : 103660,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/103660#pullrequestreview-707563086",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f41d5950-c02b-42db-aa63-12868fc5161c",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "I'm surprised the APF filter starts a goroutine per request. Does that need to be revisited now that not all requests passed to APF are short-lived?",
        "createdAt" : "2021-07-15T15:55:49Z",
        "updatedAt" : "2021-07-15T15:56:24Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "d385c8d0-42f9-421c-af25-f3cbbda4e233",
        "parentId" : "f41d5950-c02b-42db-aa63-12868fc5161c",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "This is only the \"isWatchRequest\" branch.\r\n\r\nAlso note - that this gorotuine is short-living - it finishes as soon as the initialization is done (and not living for the whole life of the request).\r\nThat's the main point behind this PR :)",
        "createdAt" : "2021-07-15T16:03:45Z",
        "updatedAt" : "2021-07-15T16:11:31Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "faed88bb7200cc4693b7a3f9cecff1a99ea1fc95",
    "line" : 152,
    "diffHunk" : "@@ -1,1 +203,207 @@\n\t\t\t\t// We create handleCtx with explicit cancelation function.\n\t\t\t\t// The reason for it is that Handle() underneath may start additional goroutine\n\t\t\t\t// that is blocked on context cancellation. However, from APF point of view,\n\t\t\t\t// we don't want to wait until the whole watch request is processed (which is"
  },
  {
    "id" : "dd58485f-afa3-4319-b2ef-f2422a8c6672",
    "prId" : 103660,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/103660#pullrequestreview-707563086",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "112fb932-9b1c-4ab1-a295-51e77df96dd8",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "If I'm reading this correctly, this means that APF handling of watch requests can result in 2 (or maybe more) additional goroutines per request (the one spawned here and the one spawned inside Handle), and we're still not getting the benefit of APF controlling the number of active watches by a given bucket of users/groups. Is that correct?",
        "createdAt" : "2021-07-15T16:03:45Z",
        "updatedAt" : "2021-07-15T16:03:45Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "169ba7cb-c013-4814-9441-aabbbb6b924e",
        "parentId" : "112fb932-9b1c-4ab1-a295-51e77df96dd8",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "There is one goroutine that is spinned up for every request (which was added before - and i would like to ideally get rid of it).\r\nThis is the second one.\r\n\r\nBoth of these after this PR merges are short-living and live only during watch initialization. So effectively in 5k-node scalability test, we don't see any visible increase in the number of currently running goroutines.",
        "createdAt" : "2021-07-15T16:10:58Z",
        "updatedAt" : "2021-07-15T16:11:31Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "faed88bb7200cc4693b7a3f9cecff1a99ea1fc95",
    "line" : 134,
    "diffHunk" : "@@ -1,1 +185,189 @@\t\t\t// the number of running goroutines - so we run the shorter thing in a\n\t\t\t// dedicated goroutine and the actual watch handler in the main one.\n\t\t\tgo func() {\n\t\t\t\tdefer func() {\n\t\t\t\t\terr := recover()"
  },
  {
    "id" : "464ac1a7-dd3e-4e77-a221-2a0d31edf9d4",
    "prId" : 103660,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/103660#pullrequestreview-708239483",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "31c768df-dbd3-4000-b2ec-87c783a1a727",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "`watchReq` would be easier to reason about if it were initialized here instead of inside `execute()`, and had a comment explaining its purpose\r\n\r\n```go\r\n// This wraps the request passed to handler.ServeHTTP(), setting a context that plumbs watchInitializationSignal to storage\r\n```",
        "createdAt" : "2021-07-16T01:24:26Z",
        "updatedAt" : "2021-07-16T02:02:20Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "523a961d-ac8a-4dc5-a316-5d19d226c639",
        "parentId" : "31c768df-dbd3-4000-b2ec-87c783a1a727",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "Added a comment - left unitialized as mentioned above.",
        "createdAt" : "2021-07-16T06:21:00Z",
        "updatedAt" : "2021-07-16T06:30:43Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      },
      {
        "id" : "5da6b56a-8e63-4608-bf62-84e316d8014c",
        "parentId" : "31c768df-dbd3-4000-b2ec-87c783a1a727",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "the creation of the watch context and watch request can actually be moved to point of use just before we invoke handler.ServeHTTP, right? that would make it clearer there's no race on those and avoid allocation of unused context/request, right?",
        "createdAt" : "2021-07-16T10:31:06Z",
        "updatedAt" : "2021-07-16T11:39:19Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "e939f97d-541d-496a-8014-9aa69cfc394f",
        "parentId" : "31c768df-dbd3-4000-b2ec-87c783a1a727",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "ok - that's a good point; changed",
        "createdAt" : "2021-07-16T10:42:09Z",
        "updatedAt" : "2021-07-16T10:42:41Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "faed88bb7200cc4693b7a3f9cecff1a99ea1fc95",
    "line" : 85,
    "diffHunk" : "@@ -1,1 +137,141 @@\t\t\t// This wraps the request passed to handler.ServeHTTP(),\n\t\t\t// setting a context that plumbs watchInitializationSignal to storage\n\t\t\tvar watchReq *http.Request\n\t\t\t// This is set inside execute(), prior to closing shouldStartWatchCh.\n\t\t\t// If the request is rejected by APF it is left nil."
  },
  {
    "id" : "724496ce-3969-47b9-8448-5c22091a46c9",
    "prId" : 103660,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/103660#pullrequestreview-708040195",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "30c705cf-9547-4386-a9b2-25670605a46b",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "a comment like the following would be helpful:\r\n```go\r\n// This channel blocks calling handler.ServeHTTP() until closed, and is closed inside execute().\r\n// If APF rejects the request, it is never closed.\r\n```",
        "createdAt" : "2021-07-16T01:28:57Z",
        "updatedAt" : "2021-07-16T02:02:20Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "4777e77c-ffae-496e-bcd5-324588083163",
        "parentId" : "30c705cf-9547-4386-a9b2-25670605a46b",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "done",
        "createdAt" : "2021-07-16T06:17:35Z",
        "updatedAt" : "2021-07-16T06:30:43Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "faed88bb7200cc4693b7a3f9cecff1a99ea1fc95",
    "line" : 80,
    "diffHunk" : "@@ -1,1 +132,136 @@\t\t\t// This channel blocks calling handler.ServeHTTP() until closed, and is closed inside execute().\n\t\t\t// If APF rejects the request, it is never closed.\n\t\t\tshouldStartWatchCh := make(chan struct{})\n\n\t\t\twatchInitializationSignal := newInitializationSignal()"
  },
  {
    "id" : "bb020b57-c0e2-42f1-8cb9-2d95d9ad3b0d",
    "prId" : 103660,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/103660#pullrequestreview-708040195",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "98aee4f2-1d7a-4f69-88c3-55b3fe1b4fd5",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "comment where/when this is set?\r\n```go\r\n// This is set inside execute(), prior to closing shouldStartWatchCh.\r\n// If the request is rejected by APF it is left nil.\r\n```",
        "createdAt" : "2021-07-16T01:48:01Z",
        "updatedAt" : "2021-07-16T02:02:20Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "f926e7fb-480b-444f-b969-2543d2b30b6a",
        "parentId" : "98aee4f2-1d7a-4f69-88c3-55b3fe1b4fd5",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "done",
        "createdAt" : "2021-07-16T06:21:17Z",
        "updatedAt" : "2021-07-16T06:30:43Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "faed88bb7200cc4693b7a3f9cecff1a99ea1fc95",
    "line" : 88,
    "diffHunk" : "@@ -1,1 +140,144 @@\t\t\t// This is set inside execute(), prior to closing shouldStartWatchCh.\n\t\t\t// If the request is rejected by APF it is left nil.\n\t\t\tvar forgetWatch utilflowcontrol.ForgetWatchFunc\n\n\t\t\tdefer func() {"
  },
  {
    "id" : "8890cd42-96db-4bc6-af85-a64774d1337b",
    "prId" : 103660,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/103660#pullrequestreview-708314240",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f64b25bc-ff56-4201-b9e3-1c5a1bfac876",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "nit: can move the declaration of watchReq here, rather than declaring above",
        "createdAt" : "2021-07-16T11:52:37Z",
        "updatedAt" : "2021-07-16T11:53:38Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "e711ebc4-aa5b-419a-acf5-810834467619",
        "parentId" : "f64b25bc-ff56-4201-b9e3-1c5a1bfac876",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "OK - will do in a follow up to let this PR merge.",
        "createdAt" : "2021-07-16T12:01:00Z",
        "updatedAt" : "2021-07-16T12:01:00Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "faed88bb7200cc4693b7a3f9cecff1a99ea1fc95",
    "line" : 172,
    "diffHunk" : "@@ -1,1 +223,227 @@\t\t\tcase <-shouldStartWatchCh:\n\t\t\t\twatchCtx := utilflowcontrol.WithInitializationSignal(ctx, watchInitializationSignal)\n\t\t\t\twatchReq = r.WithContext(watchCtx)\n\t\t\t\thandler.ServeHTTP(w, watchReq)\n\t\t\t\t// Protect from the situation when request will not reach storage layer"
  },
  {
    "id" : "6ad98a66-4488-4d1c-9f38-f378b95b2c88",
    "prId" : 103481,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/103481#pullrequestreview-705201547",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "caaa552c-5c69-417d-bd58-1b19a7901965",
        "parentId" : null,
        "authorId" : "7a59a326-58b3-4590-b70a-297d2e27daa5",
        "body" : "The costs are two-dimensional, so should not be summarized by the word \"width\" (which refers to only one of the two dimensions).",
        "createdAt" : "2021-07-06T20:10:56Z",
        "updatedAt" : "2021-07-06T20:11:14Z",
        "lastEditedBy" : "7a59a326-58b3-4590-b70a-297d2e27daa5",
        "tags" : [
        ]
      },
      {
        "id" : "50f8fa14-70ac-4280-a12c-c24a7e77216b",
        "parentId" : "caaa552c-5c69-417d-bd58-1b19a7901965",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "Is your comment about the naming only (i.e. we should rename `width` to something else (e.g. `cost`)) or something else. I guess I'm not fully following.",
        "createdAt" : "2021-07-07T07:02:41Z",
        "updatedAt" : "2021-07-07T07:05:36Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      },
      {
        "id" : "24bafac6-ee5c-4206-899f-048ab2d0db26",
        "parentId" : "caaa552c-5c69-417d-bd58-1b19a7901965",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "[If it's just about naming - can we merge that since code freeze is coming in a day (and I will open a follow up for the naming change.]",
        "createdAt" : "2021-07-07T07:05:30Z",
        "updatedAt" : "2021-07-07T07:05:36Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      },
      {
        "id" : "c57dab3d-3c92-4b15-9e76-f0cae61a6052",
        "parentId" : "caaa552c-5c69-417d-bd58-1b19a7901965",
        "authorId" : "7a59a326-58b3-4590-b70a-297d2e27daa5",
        "body" : "My objection is primarily about naming.\r\nRegarding grouping, there are additional questions that could be asked.",
        "createdAt" : "2021-07-08T14:47:22Z",
        "updatedAt" : "2021-07-08T14:47:22Z",
        "lastEditedBy" : "7a59a326-58b3-4590-b70a-297d2e27daa5",
        "tags" : [
        ]
      },
      {
        "id" : "76d1445e-f899-4b43-acec-4454f6d3aab2",
        "parentId" : "caaa552c-5c69-417d-bd58-1b19a7901965",
        "authorId" : "7a59a326-58b3-4590-b70a-297d2e27daa5",
        "body" : "There are two places where the struct currently named `Width` appear:\r\n- in the struct named `RequestDigest`\r\n- along with `hashValue uint64, flowDistinguisher, fsName string, descr1, descr2 interface{}, queueNoteFn fq.QueueNoteFn` in many places in the queueset code, which arguably should be collected into a struct.\r\n\r\nIf indeed that longer parameter list is coalesced into a struct, then the struct currently named `Width` will always appear inside another struct and could arguably be replaced there by its current one field (future two or three fields).  The potential third field I am thinking about is the estimated execution duration.  Note that today this is a constant in queuest but a variable (derived from deadline in context) in the higher layer.  Not entirely sure right now which is best to do in queuest.",
        "createdAt" : "2021-07-08T15:05:35Z",
        "updatedAt" : "2021-07-08T15:05:35Z",
        "lastEditedBy" : "7a59a326-58b3-4590-b70a-297d2e27daa5",
        "tags" : [
        ]
      },
      {
        "id" : "57142b37-f8fb-41e5-b6a0-691754709312",
        "parentId" : "caaa552c-5c69-417d-bd58-1b19a7901965",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "It's also part of WidthEstimator: https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/apiserver/pkg/util/flowcontrol/request/width.go\r\n\r\nwhich I think should return a single thing. How about calling it Cost (it would be request.Cost) [and renaming to CostEstimator]?\r\nDo you have a better suggestions?\r\n\r\n\r\nGiven the above I think we still need that. I agree that we may want to collect the params into single struct, but I don't have a reasonable proposal how to name that struct.",
        "createdAt" : "2021-07-09T06:33:03Z",
        "updatedAt" : "2021-07-09T06:33:03Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      },
      {
        "id" : "e77fa8a1-195b-4ef9-9275-d7a9361f82e8",
        "parentId" : "caaa552c-5c69-417d-bd58-1b19a7901965",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "We discussed this yesterday with Mike and the conclusion was that the above arguments make sense.\r\n\r\nSo we just want to rename it (WorkEstimate [or less preferrably Work if it won't appear to really be estimate across the code] were decided).\r\n\r\nI will work on renaming in the upcoming days.",
        "createdAt" : "2021-07-13T09:32:27Z",
        "updatedAt" : "2021-07-13T09:32:27Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      },
      {
        "id" : "ffa73aaa-328e-4c39-ba12-77fe3c8ea267",
        "parentId" : "caaa552c-5c69-417d-bd58-1b19a7901965",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "I opened https://github.com/kubernetes/kubernetes/pull/103664 to address this.",
        "createdAt" : "2021-07-13T13:40:01Z",
        "updatedAt" : "2021-07-13T13:40:02Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "cea1dcfeed2fc4e8ab89cd43e5a0e402251c8df5",
    "line" : 21,
    "diffHunk" : "@@ -1,1 +167,171 @@\n\t\t// find the estimated \"width\" of the request\n\t\t// TODO: Maybe just make it costEstimator and let it return additionalLatency too for the watch?\n\t\t// TODO: Estimate cost should also take fcIfc.GetWatchCount(requestInfo) as a parameter.\n\t\twidth := widthEstimator.EstimateWidth(r)"
  },
  {
    "id" : "da54dd3c-7a96-47af-89fe-70180eb53ca6",
    "prId" : 103481,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/103481#pullrequestreview-701043264",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bba8382f-9d93-4bff-93ed-1f17479e19b4",
        "parentId" : null,
        "authorId" : "3e6e337f-0beb-4609-abc3-11b8e8cf5688",
        "body" : "`requestInfo` can be obtained from the request context, so i don't think we will need to change signature of `EstimateWidth`",
        "createdAt" : "2021-07-07T13:53:25Z",
        "updatedAt" : "2021-07-07T13:53:40Z",
        "lastEditedBy" : "3e6e337f-0beb-4609-abc3-11b8e8cf5688",
        "tags" : [
        ]
      },
      {
        "id" : "66dc2049-dc02-41b7-9d7c-e524bda509e9",
        "parentId" : "bba8382f-9d93-4bff-93ed-1f17479e19b4",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "Yes - I will address that as part of https://github.com/kubernetes/kubernetes/pull/103539",
        "createdAt" : "2021-07-07T13:58:51Z",
        "updatedAt" : "2021-07-07T13:58:52Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "cea1dcfeed2fc4e8ab89cd43e5a0e402251c8df5",
    "line" : 22,
    "diffHunk" : "@@ -1,1 +168,172 @@\t\t// find the estimated \"width\" of the request\n\t\t// TODO: Maybe just make it costEstimator and let it return additionalLatency too for the watch?\n\t\t// TODO: Estimate cost should also take fcIfc.GetWatchCount(requestInfo) as a parameter.\n\t\twidth := widthEstimator.EstimateWidth(r)\n\t\tdigest := utilflowcontrol.RequestDigest{RequestInfo: requestInfo, User: user, Width: width}"
  },
  {
    "id" : "e4e0072a-c91a-4d58-902f-8412bad8d459",
    "prId" : 102171,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/102171#pullrequestreview-668856487",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "205a8041-ecac-4277-833b-4b4735d5acb8",
        "parentId" : null,
        "authorId" : "7a59a326-58b3-4590-b70a-297d2e27daa5",
        "body" : "The `r.Clone()` also is only needed if `isWatchRequest`.",
        "createdAt" : "2021-05-25T16:56:39Z",
        "updatedAt" : "2021-05-25T17:17:51Z",
        "lastEditedBy" : "7a59a326-58b3-4590-b70a-297d2e27daa5",
        "tags" : [
        ]
      },
      {
        "id" : "a5524095-538d-4198-b955-9996f7f2ff1c",
        "parentId" : "205a8041-ecac-4277-833b-4b4735d5acb8",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "done",
        "createdAt" : "2021-05-26T10:34:16Z",
        "updatedAt" : "2021-05-26T10:34:16Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "8054b0f808d116658ac086e4b71fb34d1502cd57",
    "line" : 81,
    "diffHunk" : "@@ -1,1 +129,133 @@\t\t\t\tinnerCtx = utilflowcontrol.WithInitializationSignal(ctx, watchInitializationSignal)\n\t\t\t\tinnerReq = r.Clone(innerCtx)\n\t\t\t}\n\t\t\tsetResponseHeaders(classification, w)\n"
  },
  {
    "id" : "3aaab3b0-56b5-4dc8-9d21-ceb373e1be87",
    "prId" : 102171,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/102171#pullrequestreview-670143155",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ec3a4d97-3fb9-4e5c-8b3d-9c510e116356",
        "parentId" : null,
        "authorId" : "3e6e337f-0beb-4609-abc3-11b8e8cf5688",
        "body" : "is `defer utilruntime.HandleCrash()` enough here? If the `handler.ServeHTTP(w, innerReq)` panics inside this goroutine then we need to propagate the panic to the caller goroutine, so `WithPanicRecovery` can do the proper accounting. \r\n\r\nIt's similar to how we have timeout filter today: https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/apiserver/pkg/server/filters/timeout.go#L94-L108\r\n\r\n```\r\n\tgo func() {\r\n\t\tdefer func() {\r\n\t\t\terr := recover()\r\n\t\t\t// do not wrap the sentinel ErrAbortHandler panic value\r\n\t\t\tif err != nil && err != http.ErrAbortHandler {\r\n\t\t\t\t// Same as stdlib http server code. Manually allocate stack\r\n\t\t\t\t// trace buffer size to prevent excessively large logs\r\n\t\t\t\tconst size = 64 << 10\r\n\t\t\t\tbuf := make([]byte, size)\r\n\t\t\t\tbuf = buf[:runtime.Stack(buf, false)]\r\n\t\t\t\terr = fmt.Sprintf(\"%v\\n%s\", err, buf)\r\n\t\t\t}\r\n\t\t\tresultCh <- err\r\n\t\t}()\r\n\t\tt.handler.ServeHTTP(tw, r)\r\n\t}()\r\n```\r\n\r\nI am not fully aware of how differently we handle a `Watch` than a regular request, but `WithPanicRecovery` seems to apply to all requests, I believe.\r\n",
        "createdAt" : "2021-05-26T15:26:59Z",
        "updatedAt" : "2021-05-26T16:06:44Z",
        "lastEditedBy" : "3e6e337f-0beb-4609-abc3-11b8e8cf5688",
        "tags" : [
        ]
      },
      {
        "id" : "4cdfbee1-185c-4f9f-ada5-720d4d86c29a",
        "parentId" : "ec3a4d97-3fb9-4e5c-8b3d-9c510e116356",
        "authorId" : "7a59a326-58b3-4590-b70a-297d2e27daa5",
        "body" : "Yes, I think we need this.  Good catch.",
        "createdAt" : "2021-05-26T17:49:16Z",
        "updatedAt" : "2021-05-26T17:49:16Z",
        "lastEditedBy" : "7a59a326-58b3-4590-b70a-297d2e27daa5",
        "tags" : [
        ]
      },
      {
        "id" : "c942dfd1-067f-4d7b-87b1-a06215dc6040",
        "parentId" : "ec3a4d97-3fb9-4e5c-8b3d-9c510e116356",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "Good catch.\r\nI added the necessary code (didn't do handling as in timeout to ensure that what is returned doesn't really change with this change). The changes are in the second commit for easier review.",
        "createdAt" : "2021-05-27T12:54:06Z",
        "updatedAt" : "2021-05-27T12:54:06Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "8054b0f808d116658ac086e4b71fb34d1502cd57",
    "line" : 86,
    "diffHunk" : "@@ -1,1 +133,137 @@\n\t\t\tif isWatchRequest {\n\t\t\t\tgo func() {\n\t\t\t\t\tdefer func() {\n\t\t\t\t\t\terr := recover()"
  },
  {
    "id" : "b58fbc02-3f75-4426-9ae3-b66be7f054c2",
    "prId" : 102171,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/102171#pullrequestreview-673497862",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d5010c6c-8dc6-497e-b31a-75f50715b92b",
        "parentId" : null,
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "Readding the other comment from @tkashem \r\n\r\nwith Watch included now, I think we might have a forever blocked goroutine.\r\nStartRequest 1 function spins up a go routine 2 and it waits until the request is done using _ = <-ctx.Done(). If I am not mistaken the request context for watch is never canceled or does not have any deadline, this will cause the goroutine to block forever, I think.\r\n\r\nWe might need to do some plumbing so we have something similar to:\r\n\r\nselect {\r\ncase <-ctx.Done():\r\ncase <-watchInitializationSignal.Wait():\r\n}\r\n\r\n...\r\n\r\n\r\nso I just did a quick scan of the filters and looks like for a Watch we do not apply any WithCancel or WithTimeout to the request context.\r\nThe only filter that sets a deadline to a request before the APF filter is WithRequestDeadline and it only applies it to non long running requests.\r\n\r\nI also checked the net/http2 library, looks like just before the http handler is called, net/http creates a context with WithCancel\r\n\r\n\tctx, cancelCtx := context.WithCancel(sc.baseCtx)\r\n\tst := &http2stream{\r\n\t\tsc:        sc,\r\n\t\tid:        id,\r\n\t\tstate:     state,\r\n\t\tctx:       ctx,\r\n\t\tcancelCtx: cancelCtx,\r\n\t}\r\n``\r\nand then creates a new `http.Request` with this context and then invokes the handler. So I think I may have been wrong when I said that `tx.Done() == nil` and we never create that go routine. (let me do some tests to verify that)",
        "createdAt" : "2021-05-27T12:58:33Z",
        "updatedAt" : "2021-05-27T12:58:41Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      },
      {
        "id" : "7ad8c4ec-3bbb-49f0-9483-6ebc32460743",
        "parentId" : "d5010c6c-8dc6-497e-b31a-75f50715b92b",
        "authorId" : "3e6e337f-0beb-4609-abc3-11b8e8cf5688",
        "body" : "I will write a one-time test to double check the `ctx.Done()` channel on a brand new HTTP request, but I think the goroutine will live as long the watch request lives, it should not hang forever, the `context` associated with the http2 stream of the request should get canceled when the watch ends.\r\n",
        "createdAt" : "2021-05-27T13:32:43Z",
        "updatedAt" : "2021-05-27T13:32:43Z",
        "lastEditedBy" : "3e6e337f-0beb-4609-abc3-11b8e8cf5688",
        "tags" : [
        ]
      },
      {
        "id" : "0dfe2bb8-d185-496c-a79e-737d1829a4e0",
        "parentId" : "d5010c6c-8dc6-497e-b31a-75f50715b92b",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "OK - I added a unit test to ensure that's the case.\r\nThis PR seem to be ready for re-review now.",
        "createdAt" : "2021-05-31T10:03:40Z",
        "updatedAt" : "2021-05-31T10:03:41Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      },
      {
        "id" : "e38e200c-fb55-4150-a853-60170a7d752a",
        "parentId" : "d5010c6c-8dc6-497e-b31a-75f50715b92b",
        "authorId" : "3e6e337f-0beb-4609-abc3-11b8e8cf5688",
        "body" : "thanks for the unit test @wojtek-t, so now the goroutine will run as long as the watch request lasts. One optimization we can think of is that this goroutine can wait until the watch initialization is signaled as opposed to waiting for the watch request to complete (this can be addressed in a separate PR though)",
        "createdAt" : "2021-06-01T19:19:12Z",
        "updatedAt" : "2021-06-01T19:19:12Z",
        "lastEditedBy" : "3e6e337f-0beb-4609-abc3-11b8e8cf5688",
        "tags" : [
        ]
      }
    ],
    "commit" : "8054b0f808d116658ac086e4b71fb34d1502cd57",
    "line" : 105,
    "diffHunk" : "@@ -1,1 +152,156 @@\t\t\t\t\tdefer watchInitializationSignal.Signal()\n\n\t\t\t\t\thandler.ServeHTTP(w, innerReq)\n\t\t\t\t}()\n"
  },
  {
    "id" : "f1e161ac-09c8-445f-acfb-b4168e02a755",
    "prId" : 102171,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/102171#pullrequestreview-673206593",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0311bb51-455c-43b7-bc75-62589e155272",
        "parentId" : null,
        "authorId" : "3e6e337f-0beb-4609-abc3-11b8e8cf5688",
        "body" : "nit: can we update the comment above? if the request gets rejected then `resultCh` will be closed and `err` will be `nil` as a consequence. (just to call it out that `err` being `nil` does not always mean that the request has been executed)  \r\n\r\nso basically we are waiting here until `the request itself finishes or is rejected`",
        "createdAt" : "2021-06-01T19:02:30Z",
        "updatedAt" : "2021-06-01T19:34:30Z",
        "lastEditedBy" : "3e6e337f-0beb-4609-abc3-11b8e8cf5688",
        "tags" : [
        ]
      }
    ],
    "commit" : "8054b0f808d116658ac086e4b71fb34d1502cd57",
    "line" : 131,
    "diffHunk" : "@@ -1,1 +189,193 @@\t\t// 2) rejected\n\t\tif isWatchRequest {\n\t\t\terr := <-resultCh\n\t\t\tif err != nil {\n\t\t\t\tpanic(err)"
  },
  {
    "id" : "13c6a6ad-fb8d-45ac-a16f-fdab5ad84596",
    "prId" : 93877,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/93877#pullrequestreview-521318896",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "cf91574e-737a-4618-ba69-678f02f92f95",
        "parentId" : null,
        "authorId" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "body" : "this is not addressing an actual bug because either `WithPriorityAndFairness` or `WithMaxInFlightLimit` will be invoked, but never both, right?",
        "createdAt" : "2020-10-30T02:52:25Z",
        "updatedAt" : "2020-11-02T03:46:20Z",
        "lastEditedBy" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "tags" : [
        ]
      },
      {
        "id" : "a48ad72c-5485-4f07-8ada-f61fd7198a01",
        "parentId" : "cf91574e-737a-4618-ba69-678f02f92f95",
        "authorId" : "171bb666-1454-4ba5-866b-e46f2bd90421",
        "body" : "Right. Separating `startOnce` of the two filters is used to avoid race condition when running `maxinflight_test.go` and `priority-and-fairness_test.go` together, in which case both `WithPriorityAndFairness` and `WithMaxInFlightLimit` are invoked.",
        "createdAt" : "2020-11-02T03:57:28Z",
        "updatedAt" : "2020-11-02T03:57:28Z",
        "lastEditedBy" : "171bb666-1454-4ba5-866b-e46f2bd90421",
        "tags" : [
        ]
      }
    ],
    "commit" : "833ce487b9fab1650d5aaba2a8b295f8a90e07bd",
    "line" : 23,
    "diffHunk" : "@@ -1,1 +84,88 @@\t\tstartRecordingUsage(watermark)\n\t})\n\tapfStartOnce.Do(func() {\n\t\tstartRecordingUsage(waitingMark)\n\t})"
  },
  {
    "id" : "e010ab77-c445-4c07-9cb2-c32115a0a75c",
    "prId" : 93877,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/93877#pullrequestreview-521919541",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f726dd87-a914-4fe9-abb1-59f05febf7de",
        "parentId" : null,
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "Just a note that all these globals make it impossible to e.g. install a second APF filter with different settings for long-running requests, which might be one thing we eventually want to do.\r\n\r\nNot asking for a change now.",
        "createdAt" : "2020-11-02T19:10:00Z",
        "updatedAt" : "2020-11-02T19:10:00Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      }
    ],
    "commit" : "833ce487b9fab1650d5aaba2a8b295f8a90e07bd",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +65,69 @@\n// apfStartOnce is used to avoid sharing one-time mutex with maxinflight handler\nvar apfStartOnce sync.Once\n\nvar atomicMutatingExecuting, atomicReadOnlyExecuting int32"
  },
  {
    "id" : "2ce52703-b9c8-4fef-9f1e-056aa3dde903",
    "prId" : 88149,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/88149#pullrequestreview-360812680",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2cac2ff4-8c93-4e07-91b3-47888719d8aa",
        "parentId" : null,
        "authorId" : "b451f401-2153-49b2-a815-0e09fafa590b",
        "body" : "Actually, I think it's probably better to use the names rather than the UIDs here?",
        "createdAt" : "2020-02-18T17:14:30Z",
        "updatedAt" : "2020-02-19T02:52:20Z",
        "lastEditedBy" : "b451f401-2153-49b2-a815-0e09fafa590b",
        "tags" : [
        ]
      },
      {
        "id" : "0e72206c-c1d3-4ee5-b552-dc15a317689b",
        "parentId" : "2cac2ff4-8c93-4e07-91b3-47888719d8aa",
        "authorId" : "7a59a326-58b3-4590-b70a-297d2e27daa5",
        "body" : "We discussed this in a previous meeting.  The concern is that the names might contain sensitive information.  It is somewhat like allowing listing of these objects without permission from RBAC.",
        "createdAt" : "2020-02-18T19:29:39Z",
        "updatedAt" : "2020-02-19T02:52:20Z",
        "lastEditedBy" : "7a59a326-58b3-4590-b70a-297d2e27daa5",
        "tags" : [
        ]
      },
      {
        "id" : "3eff8692-5909-46be-8aa2-f7f2e288ef04",
        "parentId" : "2cac2ff4-8c93-4e07-91b3-47888719d8aa",
        "authorId" : "b451f401-2153-49b2-a815-0e09fafa590b",
        "body" : "Oh, right, I remember even pointing that out myself. Thanks :)",
        "createdAt" : "2020-02-18T20:33:23Z",
        "updatedAt" : "2020-02-19T02:52:20Z",
        "lastEditedBy" : "b451f401-2153-49b2-a815-0e09fafa590b",
        "tags" : [
        ]
      },
      {
        "id" : "73e69308-82b2-4b9e-86de-8b91ac41e8cd",
        "parentId" : "2cac2ff4-8c93-4e07-91b3-47888719d8aa",
        "authorId" : "bc182326-9017-48d6-8ee0-4609046c1366",
        "body" : "marking this resolved as it's addressed",
        "createdAt" : "2020-02-19T02:53:22Z",
        "updatedAt" : "2020-02-19T02:53:23Z",
        "lastEditedBy" : "bc182326-9017-48d6-8ee0-4609046c1366",
        "tags" : [
        ]
      }
    ],
    "commit" : "da6f89217d357a6683ca4a7825c673d7c2af92f0",
    "line" : 16,
    "diffHunk" : "@@ -1,1 +103,107 @@\t\t\tinnerCtx := context.WithValue(ctx, priorityAndFairnessKey, classification)\n\t\t\tinnerReq := r.Clone(innerCtx)\n\t\t\tw.Header().Set(responseHeaderMatchedPriorityLevelConfigurationUID, string(classification.PriorityLevelUID))\n\t\t\tw.Header().Set(responseHeaderMatchedFlowSchemaUID, string(classification.FlowSchemaUID))\n\t\t\thandler.ServeHTTP(w, innerReq)"
  }
]
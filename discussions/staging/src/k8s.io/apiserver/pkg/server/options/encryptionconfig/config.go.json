[
  {
    "id" : "64ec5201-3863-4908-8381-32b550a7ffba",
    "prId" : 85828,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/85828#pullrequestreview-328516294",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "39f49b54-a821-44be-adef-34942c9cd3dd",
        "parentId" : null,
        "authorId" : "6a76eaae-b750-44a3-afa5-0d64814ae70a",
        "body" : "I think this is still too much for the integration test to pass.\r\nI believe this would need to be under 30 seconds, so I suggest 20.\r\nWe can follow up with a PR to expose cache TTL so that the integration test could run in reasonable amount of time.",
        "createdAt" : "2019-12-06T23:22:55Z",
        "updatedAt" : "2019-12-06T23:59:40Z",
        "lastEditedBy" : "6a76eaae-b750-44a3-afa5-0d64814ae70a",
        "tags" : [
        ]
      },
      {
        "id" : "f653e211-2f4e-49f3-bd3e-87779099309a",
        "parentId" : "39f49b54-a821-44be-adef-34942c9cd3dd",
        "authorId" : "f64c354b-61cb-4b89-b58f-f464e7ad4f94",
        "body" : "done",
        "createdAt" : "2019-12-06T23:59:42Z",
        "updatedAt" : "2019-12-06T23:59:42Z",
        "lastEditedBy" : "f64c354b-61cb-4b89-b58f-f464e7ad4f94",
        "tags" : [
        ]
      }
    ],
    "commit" : "c084d57b18a7c90c14bc13dc2daa256e84037a74",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +51,55 @@\tkmsPluginHealthzNegativeTTL  = 3 * time.Second\n\tkmsPluginHealthzPositiveTTL  = 20 * time.Second\n)\n\ntype kmsPluginHealthzResponse struct {"
  },
  {
    "id" : "66b1e354-7523-47a6-bd49-afdbc277d395",
    "prId" : 85363,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/85363#pullrequestreview-323208466",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ee140d96-5b95-427e-a583-280603deb904",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "add a default case that errors just to make sure we don't accept a config we don't understand?",
        "createdAt" : "2019-11-25T21:35:27Z",
        "updatedAt" : "2019-12-02T21:21:26Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "7d59410b-5e39-4695-aef0-bddb41832191",
        "parentId" : "ee140d96-5b95-427e-a583-280603deb904",
        "authorId" : "6a76eaae-b750-44a3-afa5-0d64814ae70a",
        "body" : "I can certainly do this. However, this check is done in validator.validateSingleProvider.",
        "createdAt" : "2019-11-26T00:40:06Z",
        "updatedAt" : "2019-12-02T21:21:26Z",
        "lastEditedBy" : "6a76eaae-b750-44a3-afa5-0d64814ae70a",
        "tags" : [
        ]
      },
      {
        "id" : "0b15c319-d93f-4482-8d38-d1b693f4e41b",
        "parentId" : "ee140d96-5b95-427e-a583-280603deb904",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "belt and suspenders :)",
        "createdAt" : "2019-11-26T03:13:47Z",
        "updatedAt" : "2019-12-02T21:21:26Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "36a32573-bdd5-4c50-9e2c-5a2195e33710",
        "parentId" : "ee140d96-5b95-427e-a583-280603deb904",
        "authorId" : "6a76eaae-b750-44a3-afa5-0d64814ae70a",
        "body" : "Done.",
        "createdAt" : "2019-11-26T18:50:50Z",
        "updatedAt" : "2019-12-02T21:21:26Z",
        "lastEditedBy" : "6a76eaae-b750-44a3-afa5-0d64814ae70a",
        "tags" : [
        ]
      }
    ],
    "commit" : "a151aa35dc21881d178e498141e5f58df13fb400",
    "line" : 135,
    "diffHunk" : "@@ -1,1 +249,253 @@\t\t\t\tTransformer: identity.NewEncryptCheckTransformer(),\n\t\t\t\tPrefix:      []byte{},\n\t\t\t}\n\t\tdefault:\n\t\t\treturn nil, errors.New(\"provider does not contain any of the expected providers: KMS, AESGCM, AESCBC, Secretbox, Identity\")"
  },
  {
    "id" : "b931dac7-5201-4195-9991-129afeecf71d",
    "prId" : 78540,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/78540#pullrequestreview-250158103",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "05af45c7-279f-4304-a062-d669ce4cad90",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "this connects the KMS directly to the apiserver /healthz endpoint (which is typically allowed to be triggered unauthenticated). do we want a 1:1 relationship or do we need to make sure the KMS isn't asked to encode/decode that frequently?",
        "createdAt" : "2019-06-11T20:34:35Z",
        "updatedAt" : "2019-07-03T17:03:42Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "988b95c0-d1e3-42b2-be53-e0ac0da96456",
        "parentId" : "05af45c7-279f-4304-a062-d669ce4cad90",
        "authorId" : "6a76eaae-b750-44a3-afa5-0d64814ae70a",
        "body" : "I feel that rate-limiting should be the responsibility of the plugin (for example, Google's CloudKMS plugin implements client-side rate-limiting), so I think 1:1 is OK from kube-apiserver's point of view.\r\n",
        "createdAt" : "2019-06-11T21:11:47Z",
        "updatedAt" : "2019-07-03T17:03:42Z",
        "lastEditedBy" : "6a76eaae-b750-44a3-afa5-0d64814ae70a",
        "tags" : [
        ]
      },
      {
        "id" : "ff009468-8869-40fc-bc14-197dc10c8d12",
        "parentId" : "05af45c7-279f-4304-a062-d669ce4cad90",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "would you expect the plugin to rate limit by failing or blocking requests? either way, since the plugin can't distinguish between this health check and encrypt/decrypt requests made in service of secret reads/writes, it doesn't seem great to allow pings of the /healthz endpoint to interfere to that degree with KMS operations needed to service the API",
        "createdAt" : "2019-06-14T18:01:05Z",
        "updatedAt" : "2019-07-03T17:03:42Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "667849fd-22f4-4648-af14-b527bcda04b1",
        "parentId" : "05af45c7-279f-4304-a062-d669ce4cad90",
        "authorId" : "6a76eaae-b750-44a3-afa5-0d64814ae70a",
        "body" : "You are right - the issue here is that KMS Plugin can't tell whether it is being health-checked or is servicing a valid request.\r\n\r\nI would like to address this issue (on a separate PR) by adding support for a Health Checking Protocol for KMS-Plugin's gRPC (as was suggested by @awly  ).\r\nSee: https://github.com/grpc/grpc/blob/master/doc/health-checking.md\r\nThis way, kms-plugin can make more stringent rate-limiting decisions when receiving high volume of traffic on the Health endpoint.\r\n\r\nFrom kube-apiserver's point of view, it could first try the Health endpoint and fall-back to what is currently implemented in this PR (encrypt/decrypt round-trip).\r\n\r\nLet me know if it would make sense to add Health Checking to KMS-Plugin on this PR.",
        "createdAt" : "2019-06-14T18:28:43Z",
        "updatedAt" : "2019-07-03T17:03:42Z",
        "lastEditedBy" : "6a76eaae-b750-44a3-afa5-0d64814ae70a",
        "tags" : [
        ]
      },
      {
        "id" : "d9cca7bf-1b8c-4f67-9da2-9a76b19d3bf1",
        "parentId" : "05af45c7-279f-4304-a062-d669ce4cad90",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "a separate PR for a dedicated KMS health check RPC is fine, but I would rate limit how frequently we hit the KMS encrypt/decrypt endpoints for health-checking purposes in this PR",
        "createdAt" : "2019-06-14T18:40:30Z",
        "updatedAt" : "2019-07-03T17:03:42Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "3d8ac650-75ce-4ac8-aca9-0d1878f0a51c",
        "parentId" : "05af45c7-279f-4304-a062-d669ce4cad90",
        "authorId" : "6a76eaae-b750-44a3-afa5-0d64814ae70a",
        "body" : "Added a rate-limiter - 1 healthz check per second.",
        "createdAt" : "2019-06-14T23:04:21Z",
        "updatedAt" : "2019-07-03T17:03:42Z",
        "lastEditedBy" : "6a76eaae-b750-44a3-afa5-0d64814ae70a",
        "tags" : [
        ]
      }
    ],
    "commit" : "05fdbb201ffbaff4e92f0899f9e2ca038febb88d",
    "line" : 114,
    "diffHunk" : "@@ -1,1 +140,144 @@\t}\n\n\tp, err := h.Service.Encrypt([]byte(\"ping\"))\n\tif err != nil {\n\t\th.lastResponse = &kmsPluginHealthzResponse{err: err, received: time.Now()}"
  },
  {
    "id" : "d3d370f8-1941-4365-8a37-320b7348748d",
    "prId" : 72540,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/72540#pullrequestreview-189387494",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "18339c0d-f9f0-4a57-bd38-b31d315363f3",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "if specified, verify the duration is greater than zero and return error for negative numbers",
        "createdAt" : "2019-01-04T14:33:28Z",
        "updatedAt" : "2019-01-05T08:51:37Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "39aca564749cd92ed1cfec7129eb3f6593549137",
    "line" : 9,
    "diffHunk" : "@@ -1,1 +179,183 @@\t\t\t\t\treturn nil, fmt.Errorf(\"could not configure KMS plugin %q, timeout should be a positive value\", provider.KMS.Name)\n\t\t\t\t}\n\t\t\t\ttimeout = provider.KMS.Timeout.Duration\n\t\t\t}\n"
  },
  {
    "id" : "db807dfb-98ef-4a5e-b730-3c6c463ea66c",
    "prId" : 49742,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/49742#pullrequestreview-53050472",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3e44166e-2681-4a4b-9969-bd356cc2a88a",
        "parentId" : null,
        "authorId" : "7aca96c2-45d7-4567-99be-0323d7556c55",
        "body" : "It feels wrong that we are trying to open/read the file here. It would seem better to just pass this location down to the factory and let it do the read. Especially as in something like a hybrid case this could be a key into a config server or be a file+coordinate into a larger config file. We should need to know or care about such things. However if we insist on opening+reading the file then we end up having to care about these things.",
        "createdAt" : "2017-07-28T17:53:55Z",
        "updatedAt" : "2017-07-28T22:39:27Z",
        "lastEditedBy" : "7aca96c2-45d7-4567-99be-0323d7556c55",
        "tags" : [
        ]
      },
      {
        "id" : "4cae7c7b-333d-4ea6-9739-08a20997d1a0",
        "parentId" : "3e44166e-2681-4a4b-9969-bd356cc2a88a",
        "authorId" : "992c4ffe-40aa-4314-8c54-4b38052f13fd",
        "body" : "The admissions factory used this format, which is why I stuck with this. We can change this in a follow-up.\r\nOnce this PR is merged, I'll open a new one to change this and remove the reflect mentioned in your 2nd comment, along with some other cleanup.",
        "createdAt" : "2017-07-28T18:42:52Z",
        "updatedAt" : "2017-07-28T22:39:27Z",
        "lastEditedBy" : "992c4ffe-40aa-4314-8c54-4b38052f13fd",
        "tags" : [
        ]
      },
      {
        "id" : "e51a7a5b-2bfc-4ac4-a5ee-8640348ff58f",
        "parentId" : "3e44166e-2681-4a4b-9969-bd356cc2a88a",
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "> It feels wrong that we are trying to open/read the file here. It would seem better to just pass this location down to the factory and let it do the read. Especially as in something like a\r\n\r\nTo make this API congruent to the admission config, there will be a choice of separate file or embedded content depending the sensitivity (which we don't know since its pluggable) of the config in question.",
        "createdAt" : "2017-07-28T19:35:13Z",
        "updatedAt" : "2017-07-28T22:39:27Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      },
      {
        "id" : "2e8df79d-2156-482e-81c3-4b5bf1cdc383",
        "parentId" : "3e44166e-2681-4a4b-9969-bd356cc2a88a",
        "authorId" : "992c4ffe-40aa-4314-8c54-4b38052f13fd",
        "body" : "An approach which I've proposed earlier, and I've seen used in the cloudproviders package:\r\nHave a field `config map[string]interface{}` on the `KMSConfig` struct. Send it to the plugin factory. The plugin factory would use the `mapstructure` library to parse it into a struct safely. This library is used in certain cloudproviders like openstack.\r\nSo this way you can support both `config:` and `configfile:` attributes on the `kms` configuration.\r\n\r\nMay not be acceptable though, due to a point in the flow where the config is unstructured (it will still be read in a structured form later on). Just putting this out here.",
        "createdAt" : "2017-07-28T20:49:48Z",
        "updatedAt" : "2017-07-28T22:39:27Z",
        "lastEditedBy" : "992c4ffe-40aa-4314-8c54-4b38052f13fd",
        "tags" : [
        ]
      },
      {
        "id" : "9537c3eb-9503-40f3-8dde-68e13db5605b",
        "parentId" : "3e44166e-2681-4a4b-9969-bd356cc2a88a",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "The reader interface lets you load a structured config from an external file or an inlined config. All our config files should be structured and versioned (see scheduler config, ABAC config, admission config, etc)",
        "createdAt" : "2017-07-28T22:09:24Z",
        "updatedAt" : "2017-07-28T22:39:27Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "68a32c06b4d69970ac2489ff5177d5703ca604cd",
    "line" : 29,
    "diffHunk" : "@@ -1,1 +152,156 @@\t\t\t\treturn nil, fmt.Errorf(\"more than one provider specified in a single element, should split into different list elements\")\n\t\t\t}\n\t\t\tf, err := os.Open(provider.KMS.ConfigFile)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"error opening KMS provider configuration file %q: %v\", provider.KMS.ConfigFile, err)"
  },
  {
    "id" : "fd8f5432-c13e-4a7b-bf2e-63437ba54727",
    "prId" : 46916,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/46916#pullrequestreview-42747972",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b9418d05-9cf7-4121-8510-a87e8baea846",
        "parentId" : null,
        "authorId" : "992c4ffe-40aa-4314-8c54-4b38052f13fd",
        "body" : "@smarterclayton\r\n\r\nContext:\r\n> sakshamsharma 23 hours ago\r\n> I would ideally think that we need shorter prefixes. Like: gcm, cbc, secb.\r\n> smarterclayton 9 hours ago\r\n> We will almost certainly need to version them in the future, and we want to ensure we have enough key space to evolve if we have to.\r\n\r\nVersioned prefixes are fine, what I mean is, we could do `k8s:enc:secb:v1` etc, because these prefixes are not user/developer/admin facing. Of course, the premise is that these long prefixes are a storage overhead. If this premise is not significant, we can ignore this.",
        "createdAt" : "2017-06-07T22:05:54Z",
        "updatedAt" : "2017-06-07T22:06:20Z",
        "lastEditedBy" : "992c4ffe-40aa-4314-8c54-4b38052f13fd",
        "tags" : [
        ]
      }
    ],
    "commit" : "13073407422c62ee2131968060c85ce8b6488de4",
    "line" : 20,
    "diffHunk" : "@@ -1,1 +39,43 @@\taesGCMTransformerPrefixV1    = \"k8s:enc:aesgcm:v1:\"\n\tsecretboxTransformerPrefixV1 = \"k8s:enc:secretbox:v1\"\n)\n\n// GetTransformerOverrides returns the transformer overrides by reading and parsing the encryption provider configuration file"
  },
  {
    "id" : "95955f72-533e-464f-9dfd-096a7113218a",
    "prId" : 46916,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/46916#pullrequestreview-45881150",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e88b86ea-689c-44f6-81bd-8c22d83ca896",
        "parentId" : null,
        "authorId" : "21b457d2-6f88-4a9f-8d5a-debafbcb6cfe",
        "body" : "Is there are reason why we're validating key length only for Secretbox?\r\n\r\nLooks we can do the same for AES-GCM (16,24,32) and AES-CBC (32).\r\n\r\n@smarterclayton Let me know if you agree and I'll prepare PR for that.",
        "createdAt" : "2017-06-22T16:08:41Z",
        "updatedAt" : "2017-06-22T16:08:42Z",
        "lastEditedBy" : "21b457d2-6f88-4a9f-8d5a-debafbcb6cfe",
        "tags" : [
        ]
      },
      {
        "id" : "cb1caf95-6603-48ad-937a-10c857944b3e",
        "parentId" : "e88b86ea-689c-44f6-81bd-8c22d83ca896",
        "authorId" : "992c4ffe-40aa-4314-8c54-4b38052f13fd",
        "body" : "We're validating it only for secretbox because it requires a fixed size array as input. AES-GCM returns a sane error itself, if the key size is not valid. For secretbox, if we did not validate and convert it to a `[32]byte` safely, it may throw a runtime error. We need to throw a sane error, and AES-GCM already does that. I'm not sure about CBC though.",
        "createdAt" : "2017-06-23T01:07:24Z",
        "updatedAt" : "2017-06-23T01:07:25Z",
        "lastEditedBy" : "992c4ffe-40aa-4314-8c54-4b38052f13fd",
        "tags" : [
        ]
      }
    ],
    "commit" : "13073407422c62ee2131968060c85ce8b6488de4",
    "line" : 137,
    "diffHunk" : "@@ -1,1 +233,237 @@\t\t}\n\n\t\tif len(key) != 32 {\n\t\t\treturn result, fmt.Errorf(\"expected key size 32 for aes-cbc provider, got %v\", len(key))\n\t\t}"
  },
  {
    "id" : "74a6c37f-d767-4f22-85ef-2ccc8cd62238",
    "prId" : 46916,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/46916#pullrequestreview-45949215",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "40840054-a9db-4ef8-8264-e82ea1ab61c5",
        "parentId" : null,
        "authorId" : "21b457d2-6f88-4a9f-8d5a-debafbcb6cfe",
        "body" : "@smarterclayton Copying the key looks useless. Why we can't use `DecodeString()` result as-is?",
        "createdAt" : "2017-06-22T16:11:18Z",
        "updatedAt" : "2017-06-22T16:11:18Z",
        "lastEditedBy" : "21b457d2-6f88-4a9f-8d5a-debafbcb6cfe",
        "tags" : [
        ]
      },
      {
        "id" : "5c243094-16c2-49f2-8d5c-72c21e466fbe",
        "parentId" : "40840054-a9db-4ef8-8264-e82ea1ab61c5",
        "authorId" : "992c4ffe-40aa-4314-8c54-4b38052f13fd",
        "body" : "The intention of copying was to convert a byte slice to a `[32]byte`, and, however ugly, this came up as the best way to do it when I verified it via some quick google search :smile:",
        "createdAt" : "2017-06-23T01:08:40Z",
        "updatedAt" : "2017-06-23T01:08:40Z",
        "lastEditedBy" : "992c4ffe-40aa-4314-8c54-4b38052f13fd",
        "tags" : [
        ]
      },
      {
        "id" : "c946dd9e-e3cf-4b5a-a5c7-f94e44990f34",
        "parentId" : "40840054-a9db-4ef8-8264-e82ea1ab61c5",
        "authorId" : "21b457d2-6f88-4a9f-8d5a-debafbcb6cfe",
        "body" : "Thank you for the explanation!",
        "createdAt" : "2017-06-23T10:19:54Z",
        "updatedAt" : "2017-06-23T10:19:54Z",
        "lastEditedBy" : "21b457d2-6f88-4a9f-8d5a-debafbcb6cfe",
        "tags" : [
        ]
      }
    ],
    "commit" : "13073407422c62ee2131968060c85ce8b6488de4",
    "line" : 142,
    "diffHunk" : "@@ -1,1 +238,242 @@\n\t\tkeyArray := [32]byte{}\n\t\tcopy(keyArray[:], key)\n\n\t\t// Create a new PrefixTransformer for this key"
  },
  {
    "id" : "c82c0f78-4658-4dfd-a0ca-bf3b717a2a27",
    "prId" : 46460,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/46460#pullrequestreview-41368018",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7fabd93d-ddae-45e9-a946-78d134c32349",
        "parentId" : null,
        "authorId" : "992c4ffe-40aa-4314-8c54-4b38052f13fd",
        "body" : "Separated the actual parsing from file reading so we don't have to write the configuration to file during tests. Was suggested by @destijl",
        "createdAt" : "2017-05-31T21:21:50Z",
        "updatedAt" : "2017-06-02T03:36:16Z",
        "lastEditedBy" : "992c4ffe-40aa-4314-8c54-4b38052f13fd",
        "tags" : [
        ]
      },
      {
        "id" : "51169c8a-82a8-4760-a6f8-b52b47a8d89e",
        "parentId" : "7fabd93d-ddae-45e9-a946-78d134c32349",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Yes this is fine",
        "createdAt" : "2017-05-31T21:53:19Z",
        "updatedAt" : "2017-06-02T03:36:16Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      }
    ],
    "commit" : "9760d00d08ef0619e30a7b1b90fd290cab960069",
    "line" : 55,
    "diffHunk" : "@@ -1,1 +53,57 @@\n// ParseEncryptionConfiguration parses configuration data and returns the transformer overrides\nfunc ParseEncryptionConfiguration(f io.Reader) (map[schema.GroupResource]value.Transformer, error) {\n\tconfigFileContents, err := ioutil.ReadAll(f)\n\tif err != nil {"
  },
  {
    "id" : "63d8ab36-8440-4175-98e1-93d603b46b7e",
    "prId" : 46460,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/46460#pullrequestreview-42029216",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b6de56fd-f69a-4ca6-9a48-c0afe75ddc6c",
        "parentId" : null,
        "authorId" : "e58080d6-2177-419f-a546-b51075d7bcb8",
        "body" : "So we use this prefix to determine if and how we encrypted an object on disk?  Wouldn't it be easier to use something like `go-jose` / `JWE` to store this information in a tamper proof way?  We may still need `k8s:enc:` to prevent any collisions, but the algorithm would not need to be part of the prefix.",
        "createdAt" : "2017-06-05T12:06:01Z",
        "updatedAt" : "2017-06-05T12:06:01Z",
        "lastEditedBy" : "e58080d6-2177-419f-a546-b51075d7bcb8",
        "tags" : [
        ]
      }
    ],
    "commit" : "9760d00d08ef0619e30a7b1b90fd290cab960069",
    "line" : 36,
    "diffHunk" : "@@ -1,1 +34,38 @@\nconst (\n\taesTransformerPrefixV1 = \"k8s:enc:aes:v1:\"\n)\n"
  }
]
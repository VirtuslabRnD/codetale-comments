[
  {
    "id" : "e8ed51d1-040e-460f-b3c4-61dd96fb1896",
    "prId" : 96266,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/96266#pullrequestreview-530097902",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "cf329491-19a7-4b71-8ec2-a6ae84503b06",
        "parentId" : null,
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "Going back to my original comment about adding a test - can't you use FakeClock to test this?",
        "createdAt" : "2020-11-13T08:56:30Z",
        "updatedAt" : "2020-11-13T08:56:30Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      },
      {
        "id" : "9b5a388c-caad-4007-92d6-38763bfaa864",
        "parentId" : "cf329491-19a7-4b71-8ec2-a6ae84503b06",
        "authorId" : "0aa379a2-dc46-4e1f-81d1-8ea59923ffcd",
        "body" : "The essence of this problem is that the display clock changes, but the mononotonic clock does not change.\r\nThe FakeClock time can be changed using either of the following methods: SetTime and Step, both methods change FakeClock.time. The display clock and monotonic clock change simultaneously. Therefore, the problem cannot be simulated.",
        "createdAt" : "2020-11-13T09:12:46Z",
        "updatedAt" : "2020-11-13T09:12:46Z",
        "lastEditedBy" : "0aa379a2-dc46-4e1f-81d1-8ea59923ffcd",
        "tags" : [
        ]
      },
      {
        "id" : "180981fd-3b72-430c-8e71-7b5598c304f4",
        "parentId" : "cf329491-19a7-4b71-8ec2-a6ae84503b06",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "OK - that sounds reasonable.\r\n\r\n@liggitt - do you have any suggestions what else can we do here? Or can we go with as is?",
        "createdAt" : "2020-11-13T09:37:58Z",
        "updatedAt" : "2020-11-13T09:37:59Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      },
      {
        "id" : "7062e8ac-5b07-4bf7-8e13-9847f85fe616",
        "parentId" : "cf329491-19a7-4b71-8ec2-a6ae84503b06",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "I also don't see a way to exercise the bug with the new code, so I'd be happy with this fix as is",
        "createdAt" : "2020-11-13T14:18:45Z",
        "updatedAt" : "2020-11-13T14:18:46Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "36d5db95f8598bc64071c663c6f44a453c662102",
    "line" : 27,
    "diffHunk" : "@@ -1,1 +185,189 @@\t\treturn false\n\t}\n\tbucketID := int64(nextTime.Sub(t.createTime) / time.Second)\n\tt.lock.Lock()\n\tdefer t.lock.Unlock()"
  },
  {
    "id" : "0ce06b73-c7f5-426e-b0e7-3f09b19a6825",
    "prId" : 91260,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/91260#pullrequestreview-416445596",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "aeb7e0fe-caec-42a8-83e0-ec0271868684",
        "parentId" : null,
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "Can we not keep this as a *maximum*? I thought we had agreed that a cap was useful?",
        "createdAt" : "2020-05-19T20:33:46Z",
        "updatedAt" : "2020-05-19T20:33:46Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "a4f48593-6f1d-4331-8f22-f139f15a9bdc",
        "parentId" : "aeb7e0fe-caec-42a8-83e0-ec0271868684",
        "authorId" : "efa0987e-7d25-471d-9dea-9daaf77c2120",
        "body" : "There is a cap. With this change it will simply always default to this value - https://github.com/kubernetes/kubernetes/blob/442a69c3bdf6fe8e525b05887e57d89db1e2f3a5/staging/src/k8s.io/apiserver/pkg/storage/cacher/watch_cache.go#L61",
        "createdAt" : "2020-05-20T08:49:52Z",
        "updatedAt" : "2020-05-20T08:51:07Z",
        "lastEditedBy" : "efa0987e-7d25-471d-9dea-9daaf77c2120",
        "tags" : [
        ]
      },
      {
        "id" : "d449bccc-c626-451c-b1d6-7f72c9785eb0",
        "parentId" : "aeb7e0fe-caec-42a8-83e0-ec0271868684",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "Yes - the cap is for sure needed. And it already there as Matt wrote above.\r\n\r\nI also discussed that with @jpbetz some time ago and the conclusion was that different caps for different resources is probably an overkill.",
        "createdAt" : "2020-05-20T11:38:44Z",
        "updatedAt" : "2020-05-20T11:38:45Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      },
      {
        "id" : "b63cfe5e-f96f-4c1c-85e6-e5e3e7e3a53f",
        "parentId" : "aeb7e0fe-caec-42a8-83e0-ec0271868684",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "OK if you don't need different caps for different types, then this seems fine.",
        "createdAt" : "2020-05-21T19:02:35Z",
        "updatedAt" : "2020-05-21T19:02:35Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "f0e0f57b-1752-4131-8ca2-5d424db36b30",
        "parentId" : "aeb7e0fe-caec-42a8-83e0-ec0271868684",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "Yeah - the cap is more like a last resort and shouldn't really be reached. So introducing more complication about that seems unneeded (at least for now where we don't have any evidence for the need of it).",
        "createdAt" : "2020-05-21T19:54:27Z",
        "updatedAt" : "2020-05-21T19:54:27Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "99dff90d613e2014873dc2fae0a00acaf95c3bd2",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +63,67 @@\t// Maximum size of the history cached in memory.\n\t//\n\t// DEPRECATED: Cache capacity is dynamic and this field is no longer used.\n\tCacheCapacity int\n"
  },
  {
    "id" : "faeaed9b-fe4f-41d3-9e95-b09cc9888afc",
    "prId" : 91260,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/91260#pullrequestreview-414868362",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5c994202-2d11-46d7-8b0f-93d0b103119c",
        "parentId" : null,
        "authorId" : "68945228-6a0a-4c9d-b579-588c5a8b5f4b",
        "body" : "Config struct {",
        "createdAt" : "2020-05-19T22:29:54Z",
        "updatedAt" : "2020-05-19T22:32:16Z",
        "lastEditedBy" : "68945228-6a0a-4c9d-b579-588c5a8b5f4b",
        "tags" : [
        ]
      }
    ],
    "commit" : "99dff90d613e2014873dc2fae0a00acaf95c3bd2",
    "line" : 2,
    "diffHunk" : "@@ -1,1 +60,64 @@\n// Config contains the configuration for a given Cache.\ntype Config struct {\n\t// Maximum size of the history cached in memory.\n\t//"
  },
  {
    "id" : "706f9614-76b3-4974-a98e-628e5f1f3e73",
    "prId" : 91260,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/91260#pullrequestreview-415246115",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d8ee7bcb-44aa-4fc0-b944-8a901cfbef36",
        "parentId" : null,
        "authorId" : "efa0987e-7d25-471d-9dea-9daaf77c2120",
        "body" : "Question, why we just don't simply delete the field?",
        "createdAt" : "2020-05-20T08:50:33Z",
        "updatedAt" : "2020-05-20T08:51:07Z",
        "lastEditedBy" : "efa0987e-7d25-471d-9dea-9daaf77c2120",
        "tags" : [
        ]
      },
      {
        "id" : "ff5330e7-cfff-4e25-b92e-0224ae20fc03",
        "parentId" : "d8ee7bcb-44aa-4fc0-b944-8a901cfbef36",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "It's being set in some places. I would like to remove it, but in case we learn that something with this PR will not work over the next couple weeks, it will be easier to revert.",
        "createdAt" : "2020-05-20T11:39:42Z",
        "updatedAt" : "2020-05-20T11:39:43Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "99dff90d613e2014873dc2fae0a00acaf95c3bd2",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +64,68 @@\t//\n\t// DEPRECATED: Cache capacity is dynamic and this field is no longer used.\n\tCacheCapacity int\n\n\t// An underlying storage.Interface."
  },
  {
    "id" : "76827cd1-73ea-4d85-bd61-b57d50fc961e",
    "prId" : 90249,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/90249#pullrequestreview-399066552",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e9a6e747-5a95-4e7e-8a9b-28dce67c738e",
        "parentId" : null,
        "authorId" : "efa0987e-7d25-471d-9dea-9daaf77c2120",
        "body" : "QQ: Is it possible (watch without deadline/timeout) or is it just a safe check? ",
        "createdAt" : "2020-04-23T12:44:08Z",
        "updatedAt" : "2020-04-23T12:56:40Z",
        "lastEditedBy" : "efa0987e-7d25-471d-9dea-9daaf77c2120",
        "tags" : [
        ]
      },
      {
        "id" : "895b98c6-25a6-4b8d-a346-a435c249a609",
        "parentId" : "e9a6e747-5a95-4e7e-8a9b-28dce67c738e",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "If you're using our framework like reflector - it will always be set:\r\nhttps://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/client-go/tools/cache/reflector.go#L387\r\nWe also try to default it it is't not provided:\r\nhttps://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/apiserver/pkg/endpoints/handlers/get.go#L249\r\n\r\nBut you may configure it in a way to not provide minRequestTimeout, and then it may happen (though in properly configuder custer it shouldn't happen).",
        "createdAt" : "2020-04-23T12:56:08Z",
        "updatedAt" : "2020-04-23T12:56:41Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "d4b532e7190c2ad12a0317ff946e2cd0b33f0ada",
    "line" : 32,
    "diffHunk" : "@@ -1,1 +1251,1255 @@\t// now as possible - this covers 99% of cases.\n\theartbeatTime := now.Add(bookmarkHeartbeatFrequency)\n\tif c.deadline.IsZero() {\n\t\treturn heartbeatTime\n\t}"
  },
  {
    "id" : "981f4186-bcbe-418b-8908-0abffba0de6d",
    "prId" : 89828,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/89828#pullrequestreview-553411539",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bddb23c0-63b5-43dd-8d88-b546d3401f65",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "maybe comment why we're deep copying (since we modify resourceVersion when serializing the suggested object)",
        "createdAt" : "2020-12-15T14:57:50Z",
        "updatedAt" : "2020-12-16T07:53:27Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "6eb8f79f-eeba-4bb8-b100-14846107c0d3",
        "parentId" : "bddb23c0-63b5-43dd-8d88-b546d3401f65",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "done",
        "createdAt" : "2020-12-16T07:17:48Z",
        "updatedAt" : "2020-12-16T07:58:43Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "7bab6a9c6ed7d4e54da3e010a7bf0a30786d28f9",
    "line" : 16,
    "diffHunk" : "@@ -1,1 +442,446 @@\t\t// DeepCopy the object since we modify resource version when serializing the\n\t\t// current object.\n\t\tcurrObj := elem.(*storeElement).Object.DeepCopyObject()\n\t\treturn c.storage.Delete(ctx, key, out, preconditions, validateDeletion, currObj)\n\t}"
  },
  {
    "id" : "9741414f-a2de-43f5-8703-22d410445fe6",
    "prId" : 81914,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/81914#pullrequestreview-292343870",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "88c4be1a-30f1-444d-8b05-49b1ab297390",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "a comment here would be helpful that this is safe to return without deep copying because we deep copied when we constructed the cacheable object",
        "createdAt" : "2019-09-20T14:19:11Z",
        "updatedAt" : "2019-09-30T08:49:44Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "584850cd-6ded-4bb1-aa4b-6d15bb3e9594",
        "parentId" : "88c4be1a-30f1-444d-8b05-49b1ab297390",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "done",
        "createdAt" : "2019-09-24T11:14:17Z",
        "updatedAt" : "2019-09-30T08:49:44Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "25a728ae5eb0ae067d21679fad915c0555242470",
    "line" : 58,
    "diffHunk" : "@@ -1,1 +1209,1213 @@\t\t// It is safe to return without deep-copy, because the underlying\n\t\t// object was already deep-copied during construction.\n\t\treturn object\n\t}\n\treturn object.DeepCopyObject()"
  },
  {
    "id" : "16932710-e5c7-4282-8a69-4b722956f5b5",
    "prId" : 80788,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/80788#pullrequestreview-269546659",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6173e9c7-0637-4b8f-a8e9-46f6c62ec0b6",
        "parentId" : null,
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "1. Please also update the comment in line 859\r\n",
        "createdAt" : "2019-08-01T11:05:14Z",
        "updatedAt" : "2019-08-02T11:33:21Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "0b3c07a98c7c03e3edcf4f21ff96ea74082a54e5",
    "line" : 15,
    "diffHunk" : "@@ -1,1 +928,932 @@\tc.dispatching = false\n\tfor _, watcher := range c.watchersToStop {\n\t\twatcher.stopThreadUnsafe()\n\t}\n\tc.watchersToStop = c.watchersToStop[:0]"
  },
  {
    "id" : "78c61ae2-013e-4d50-9445-51d82c4f50ba",
    "prId" : 80788,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/80788#pullrequestreview-269546659",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e28ffc49-1564-4143-890b-a05a1f11f67d",
        "parentId" : null,
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "Please also update comme in line 974.",
        "createdAt" : "2019-08-01T11:05:34Z",
        "updatedAt" : "2019-08-02T11:33:21Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "0b3c07a98c7c03e3edcf4f21ff96ea74082a54e5",
    "line" : 24,
    "diffHunk" : "@@ -1,1 +943,947 @@\t\tc.watchersToStop = append(c.watchersToStop, watcher)\n\t} else {\n\t\twatcher.stopThreadUnsafe()\n\t}\n}"
  },
  {
    "id" : "dbf645ec-038b-4259-9940-7bfe140c73e6",
    "prId" : 80788,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/80788#pullrequestreview-269546659",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ec4a204c-144b-4caf-80dc-042e642d8944",
        "parentId" : null,
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "1. Please add a comment to cacheWatcher structure that this is not-thread-safe.\r\n\r\n2. Here please add a comment that we rely on the fact that stopThredunsafe is actually protected by Cacher.Lock()\r\n\r\n3. Remove mutex from cacheWatcher structure.",
        "createdAt" : "2019-08-01T11:06:34Z",
        "updatedAt" : "2019-08-02T11:33:21Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "0b3c07a98c7c03e3edcf4f21ff96ea74082a54e5",
    "line" : 58,
    "diffHunk" : "@@ -1,1 +1118,1122 @@\n// we rely on the fact that stopThredUnsafe is actually protected by Cacher.Lock()\nfunc (c *cacheWatcher) stopThreadUnsafe() {\n\tif !c.stopped {\n\t\tc.stopped = true"
  },
  {
    "id" : "173b84d7-d327-4242-808b-eed55bec8ff9",
    "prId" : 80788,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/80788#pullrequestreview-270084022",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e453880d-d04f-424d-a611-64dcd355d05d",
        "parentId" : null,
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "nit: can you also make it explicit that here c.Lock() is also held.",
        "createdAt" : "2019-08-02T09:44:11Z",
        "updatedAt" : "2019-08-02T11:33:21Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "0b3c07a98c7c03e3edcf4f21ff96ea74082a54e5",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +858,862 @@\t\tfor _, watcher := range watchers {\n\t\t\t// c.Lock() is held here.\n\t\t\t// watcher.stopThreadUnsafe() is protected by c.Lock()\n\t\t\tif watcher.stopped {\n\t\t\t\tcontinue"
  },
  {
    "id" : "c18368f0-b707-47f2-80a7-dd52e2346e4e",
    "prId" : 80692,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/80692#pullrequestreview-267665867",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "09f11590-3e24-4ca8-9373-4957b9a139f2",
        "parentId" : null,
        "authorId" : "20555cdb-65b0-41d0-aea2-5598a3439d50",
        "body" : "bookmarkWatchers struct is NOT thread-safe.\r\nI think we should lock here.",
        "createdAt" : "2019-07-29T09:21:48Z",
        "updatedAt" : "2019-07-30T13:49:16Z",
        "lastEditedBy" : "20555cdb-65b0-41d0-aea2-5598a3439d50",
        "tags" : [
        ]
      },
      {
        "id" : "c2761ad4-9660-45f1-a192-a44a27a5cc21",
        "parentId" : "09f11590-3e24-4ca8-9373-4957b9a139f2",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "This PR is changing that",
        "createdAt" : "2019-07-29T09:29:26Z",
        "updatedAt" : "2019-07-30T13:49:16Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "0204bc7e2594c297f146701132ee969721ada2ab",
    "line" : 31,
    "diffHunk" : "@@ -1,1 +791,795 @@\t\t\tif lastProcessedResourceVersion == 0 {\n\t\t\t\t// pop expired watchers in case there has been no update\n\t\t\t\tc.bookmarkWatchers.popExpiredWatchers()\n\t\t\t\tcontinue\n\t\t\t}"
  },
  {
    "id" : "a2253249-62d1-47fc-8dec-e0f21e6b5839",
    "prId" : 80692,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/80692#pullrequestreview-267844623",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d19f8d56-6deb-49e8-b9c4-8f7759fcea01",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "do we also need to pop expired bookmark watchers on the other handler paths that return (line 783 and 807)?",
        "createdAt" : "2019-07-29T13:47:41Z",
        "updatedAt" : "2019-07-30T13:49:16Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "0c05a060-f5a6-4e94-aa77-424bdbb91203",
        "parentId" : "d19f8d56-6deb-49e8-b9c4-8f7759fcea01",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "by only removing expired watchers when there's no resource change, does that mean a constantly changing resource (like endpoints) would still effectively leak?",
        "createdAt" : "2019-07-29T13:48:34Z",
        "updatedAt" : "2019-07-30T13:49:16Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "1bfa3277-d7f4-4777-b6e2-3478b3f4bafa",
        "parentId" : "d19f8d56-6deb-49e8-b9c4-8f7759fcea01",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "how expensive is popExpiredWatchers to call? is it concerning to call it approximately once a second?",
        "createdAt" : "2019-07-29T13:49:03Z",
        "updatedAt" : "2019-07-30T13:49:16Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "5242d99d-8973-4295-9ea5-18bfee361632",
        "parentId" : "d19f8d56-6deb-49e8-b9c4-8f7759fcea01",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "> do we also need to pop expired bookmark watchers on the other handler paths that return (line 783 and 807)?\r\n\r\nI don't think so - those effectively can happen only when we're closing cacher.\r\n\r\n> by only removing expired watchers when there's no resource change, does that mean a constantly changing resource (like endpoints) would still effectively leak?\r\n\r\nnot sure I understand your question - can you please clarify?\r\n\r\n> how expensive is popExpiredWatchers to call? is it concerning to call it approximately once a second?\r\n\r\ncheap enough - we're calling it every 1s anyway as part of dispatchEvent call (somewhere down the stack)",
        "createdAt" : "2019-07-29T13:55:51Z",
        "updatedAt" : "2019-07-30T13:49:16Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      },
      {
        "id" : "8083a5d0-b9cc-4d10-a227-003f91f69acb",
        "parentId" : "d19f8d56-6deb-49e8-b9c4-8f7759fcea01",
        "authorId" : "42b1e004-4fa7-4e43-84cf-5378839b49ad",
        "body" : "For the two places Jordan mentioned, c.dispatchEvent would handle expired watchers (via startDispatching).\r\nSo there is no source for leak after this fix goes in.\r\n\r\nI also thought about whether the expired bookmark watchers need to be popped for every period in case there is no update.\r\nWe can use a counter - beyond a threshold, say 5, we pop the watchers.\r\n\r\nI am open to suggestion in this regard.",
        "createdAt" : "2019-07-29T14:01:38Z",
        "updatedAt" : "2019-07-30T13:49:16Z",
        "lastEditedBy" : "42b1e004-4fa7-4e43-84cf-5378839b49ad",
        "tags" : [
        ]
      },
      {
        "id" : "7e64b1dd-6c38-4f61-88e5-988ad78ff72f",
        "parentId" : "d19f8d56-6deb-49e8-b9c4-8f7759fcea01",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : ">> by only removing expired watchers when there's no resource change, does that mean a constantly changing resource (like endpoints) would still effectively leak?\r\n>\r\n> not sure I understand your question - can you please clarify?\r\n\r\nI misread the code... this is skipping pruning expired watchers if this cacher has **never** received a watch event for the resource type. Same question exists, but in the opposite direction now. ~~By only removing expired watchers when there's a resource change, does that mean an almost never-changing resource (like APIService) would still effectively leak?~~\r\n\r\nedit: finished reading the dispatchEvent() code, and see that popExpiredWatchers is called when handling the sent bookmark event",
        "createdAt" : "2019-07-29T14:05:04Z",
        "updatedAt" : "2019-07-30T13:49:16Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "4319aea2-a12e-44e8-b95d-367da8d957f2",
        "parentId" : "d19f8d56-6deb-49e8-b9c4-8f7759fcea01",
        "authorId" : "42b1e004-4fa7-4e43-84cf-5378839b49ad",
        "body" : "Jordan:\r\nI see you modified previous comment\r\nDo you have any more question ?",
        "createdAt" : "2019-07-29T15:01:06Z",
        "updatedAt" : "2019-07-30T13:49:16Z",
        "lastEditedBy" : "42b1e004-4fa7-4e43-84cf-5378839b49ad",
        "tags" : [
        ]
      }
    ],
    "commit" : "0204bc7e2594c297f146701132ee969721ada2ab",
    "line" : 31,
    "diffHunk" : "@@ -1,1 +791,795 @@\t\t\tif lastProcessedResourceVersion == 0 {\n\t\t\t\t// pop expired watchers in case there has been no update\n\t\t\t\tc.bookmarkWatchers.popExpiredWatchers()\n\t\t\t\tcontinue\n\t\t\t}"
  },
  {
    "id" : "808aa297-f902-49e8-a3ac-3d42bf24e9dc",
    "prId" : 80692,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/80692#pullrequestreview-268801391",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "436389d6-cde4-4a38-b55f-d3b59784cc99",
        "parentId" : null,
        "authorId" : "2298dd66-0920-41ef-85a0-e8d08cffdc22",
        "body" : "As comments above, this structure is not thread-safe. Watchers and bookmark buckets are synchronized by mutex in Cacher, can we keep this pattern with current implementation?",
        "createdAt" : "2019-07-31T03:13:57Z",
        "updatedAt" : "2019-07-31T03:13:57Z",
        "lastEditedBy" : "2298dd66-0920-41ef-85a0-e8d08cffdc22",
        "tags" : [
        ]
      },
      {
        "id" : "4a87305e-6d21-489c-9b1e-d7117508c419",
        "parentId" : "436389d6-cde4-4a38-b55f-d3b59784cc99",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "We should update the comment - this is more tricky now. Previously, it was locked by mutex in Cacher just out-of-the-box. With the changes in this PR, we would need to add locking in one more place, and there is already quite a bit of contention on that lock.\r\nI think this is better approach.\r\n\r\n@tedyu - can you please remove the \"NOT thread-safe\" comment above?",
        "createdAt" : "2019-07-31T06:12:47Z",
        "updatedAt" : "2019-07-31T06:12:47Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "0204bc7e2594c297f146701132ee969721ada2ab",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +166,170 @@// This is NOT thread-safe.\ntype watcherBookmarkTimeBuckets struct {\n\tlock            sync.Mutex\n\twatchersBuckets map[int64][]*cacheWatcher\n\tstartBucketID   int64"
  },
  {
    "id" : "6302df0c-fb98-4c89-84f5-7c9b927b3569",
    "prId" : 80692,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/80692#pullrequestreview-268766528",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "dcbd55a6-011c-4417-9c42-d419bd8b9c29",
        "parentId" : null,
        "authorId" : "2298dd66-0920-41ef-85a0-e8d08cffdc22",
        "body" : "Wrap this line with c.Lock() c.Unlock()",
        "createdAt" : "2019-07-31T03:16:13Z",
        "updatedAt" : "2019-07-31T03:16:14Z",
        "lastEditedBy" : "2298dd66-0920-41ef-85a0-e8d08cffdc22",
        "tags" : [
        ]
      }
    ],
    "commit" : "0204bc7e2594c297f146701132ee969721ada2ab",
    "line" : 31,
    "diffHunk" : "@@ -1,1 +791,795 @@\t\t\tif lastProcessedResourceVersion == 0 {\n\t\t\t\t// pop expired watchers in case there has been no update\n\t\t\t\tc.bookmarkWatchers.popExpiredWatchers()\n\t\t\t\tcontinue\n\t\t\t}"
  },
  {
    "id" : "9965d37c-dd95-4b0c-9f7e-80979bf1a0a9",
    "prId" : 79599,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/79599#pullrequestreview-256300981",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0b241733-c454-4487-8278-5675d904d376",
        "parentId" : null,
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "Deleting changes potentially the amount of allocations in the future.\r\nBut terminateAll is supposed to happen rarely enough, that it shouldn't matter that much.",
        "createdAt" : "2019-07-01T12:19:09Z",
        "updatedAt" : "2019-07-01T12:19:09Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "a06daff032f981672a47c71b23c62b9b85793893",
    "line" : 9,
    "diffHunk" : "@@ -1,1 +158,162 @@\t\twatchers.terminateAll(done)\n\t}\n\ti.valueWatchers = map[string]watchersMap{}\n}\n"
  },
  {
    "id" : "0fa00090-cc1f-4f42-bc67-c82c0154869f",
    "prId" : 78029,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/78029#pullrequestreview-238948087",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1591841e-8d1a-4eef-b8a9-58d971a74441",
        "parentId" : null,
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "cute.",
        "createdAt" : "2019-05-17T14:12:20Z",
        "updatedAt" : "2019-05-17T17:34:25Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      }
    ],
    "commit" : "ea464235a8e10b2b8c83fc929885295dd1a5adb7",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +352,356 @@\tgo func() {\n\t\tdefer cacher.stopWg.Done()\n\t\tdefer cacher.terminateAllWatchers()\n\t\twait.Until(\n\t\t\tfunc() {"
  },
  {
    "id" : "383cf9a2-60d7-4c83-9db4-52fa0d01283f",
    "prId" : 76702,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/76702#pullrequestreview-323479771",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b8b8bdba-1363-45ce-98e1-e6087971655d",
        "parentId" : null,
        "authorId" : "45dd2de9-356e-489a-83ed-c1e36ec08903",
        "body" : "Should we need keep these code ? Have any reason to keep?",
        "createdAt" : "2019-11-27T06:49:01Z",
        "updatedAt" : "2019-11-27T06:49:01Z",
        "lastEditedBy" : "45dd2de9-356e-489a-83ed-c1e36ec08903",
        "tags" : [
        ]
      },
      {
        "id" : "c103d20b-d46b-4251-ab1b-436f64393bae",
        "parentId" : "b8b8bdba-1363-45ce-98e1-e6087971655d",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "Yes - we need this code, because we create above time.NewTimer(0).\r\nSo in order to not have any element in the .C channel, we need to consume it here.",
        "createdAt" : "2019-11-27T07:52:59Z",
        "updatedAt" : "2019-11-27T07:52:59Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "e6e43828284c6e83cf2b4658fa377b4cc7dec0c3",
    "line" : 38,
    "diffHunk" : "@@ -1,1 +328,332 @@\n\t// Ensure that timer is stopped.\n\tif !cacher.timer.Stop() {\n\t\t// Consume triggered (but not yet received) timer event\n\t\t// so that future reuse does not get a spurious timeout."
  },
  {
    "id" : "8c9d0d33-3443-49ad-ae38-ce47de5dd6e7",
    "prId" : 76065,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/76065#pullrequestreview-222777619",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f465e8df-900d-4f03-ae72-0d02cbd8802a",
        "parentId" : null,
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "Hmm - I started wondering about this one.\r\nGiven that we want for \"ctx.Done\", and we compute timeout purely based on \"ctx.Deadline()\", do we even need timer here?\r\nCan't we purely rely on \"ctx.Done\"?",
        "createdAt" : "2019-04-04T13:01:44Z",
        "updatedAt" : "2019-04-04T13:49:52Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      },
      {
        "id" : "1901823d-2e15-49e7-b9d8-e4083d68688e",
        "parentId" : "f465e8df-900d-4f03-ae72-0d02cbd8802a",
        "authorId" : "2298dd66-0920-41ef-85a0-e8d08cffdc22",
        "body" : "ctx.Done is triggered externally(for cancellation), the timer is triggered internally(for timeout).",
        "createdAt" : "2019-04-04T13:09:24Z",
        "updatedAt" : "2019-04-04T13:49:52Z",
        "lastEditedBy" : "2298dd66-0920-41ef-85a0-e8d08cffdc22",
        "tags" : [
        ]
      },
      {
        "id" : "d1949662-f3e5-4805-bd82-28782ce68f47",
        "parentId" : "f465e8df-900d-4f03-ae72-0d02cbd8802a",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "but when timeout (attached to context) fires, the ctx.Done is also closed:\r\n\r\nSo what's the difference?",
        "createdAt" : "2019-04-04T13:12:45Z",
        "updatedAt" : "2019-04-04T13:49:52Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      },
      {
        "id" : "aec5924c-a125-46ff-8cf7-043ee1d41f9d",
        "parentId" : "f465e8df-900d-4f03-ae72-0d02cbd8802a",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "I mean, do we really need to differentate ctx.Done() from timeout (that was computed based on context.Deadline() anyway)?",
        "createdAt" : "2019-04-04T13:13:22Z",
        "updatedAt" : "2019-04-04T13:49:52Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      },
      {
        "id" : "62daa082-00a6-49a0-bfbb-c59dfe080cdc",
        "parentId" : "f465e8df-900d-4f03-ae72-0d02cbd8802a",
        "authorId" : "2298dd66-0920-41ef-85a0-e8d08cffdc22",
        "body" : "leave the ctx.Done which will be triggered by the timer in handler/watch.go",
        "createdAt" : "2019-04-04T13:51:12Z",
        "updatedAt" : "2019-04-04T13:51:13Z",
        "lastEditedBy" : "2298dd66-0920-41ef-85a0-e8d08cffdc22",
        "tags" : [
        ]
      },
      {
        "id" : "99048671-7afb-4940-a7cf-fe29f10a1789",
        "parentId" : "f465e8df-900d-4f03-ae72-0d02cbd8802a",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "looks good - thanks",
        "createdAt" : "2019-04-04T13:56:10Z",
        "updatedAt" : "2019-04-04T13:56:11Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "b304a1f96d85cd351a0e22a091e17064d5edb35e",
    "line" : 36,
    "diffHunk" : "@@ -1,1 +1054,1058 @@\t\t\t\tc.sendWatchCacheEvent(event)\n\t\t\t}\n\t\tcase <-ctx.Done():\n\t\t\treturn\n\t\t}"
  },
  {
    "id" : "0452c76f-09c7-4f9a-bf7a-f5eedb12e95b",
    "prId" : 75717,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/75717#pullrequestreview-219299094",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "cdd786f5-1bf5-4b96-88a8-85d2c55cc507",
        "parentId" : null,
        "authorId" : "d4f34d8f-5341-4ac1-b8b2-5e5f11e23a5d",
        "body" : "Comments are very helpful in this PR!\r\n\r\nMaybe comment here that emptyFunc is a placeholder until the watcher.forget function can be computed?",
        "createdAt" : "2019-03-26T23:15:56Z",
        "updatedAt" : "2019-03-26T23:16:13Z",
        "lastEditedBy" : "d4f34d8f-5341-4ac1-b8b2-5e5f11e23a5d",
        "tags" : [
        ]
      },
      {
        "id" : "190272d7-772a-421b-a74c-22b4e3b2095d",
        "parentId" : "cdd786f5-1bf5-4b96-88a8-85d2c55cc507",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "SG - https://github.com/kubernetes/kubernetes/pull/75760 out for review (given that this one already merged).",
        "createdAt" : "2019-03-27T07:26:09Z",
        "updatedAt" : "2019-03-27T07:26:09Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "010cb4480825b54afb85c9fa97e2edc950a6d185",
    "line" : 36,
    "diffHunk" : "@@ -1,1 +366,370 @@\t// Create a watcher here to reduce memory allocations under lock,\n\t// given that memory allocation may trigger GC and block the thread.\n\twatcher := newCacheWatcher(chanSize, filterWithAttrsFunction(key, pred), emptyFunc, c.versioner)\n\n\t// We explicitly use thread unsafe version and do locking ourself to ensure that"
  },
  {
    "id" : "86332859-f135-44e5-80eb-51bbfcbaf414",
    "prId" : 75547,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/75547#pullrequestreview-220512647",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "dde2a736-f8bf-4b54-b25c-c11a504c38d6",
        "parentId" : null,
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "I just realized that this won't work.\r\nThe problem is that if one of the watcher times out, the next one won't get anything from the \"timer.C\" and may hang for a very long time.\r\nIt's possible to fix this problem by using context.WithTimeout() (that closes the underlying channel), that allocates timer on every call, so it's probably even worse.\r\n\r\nSo I don't know if we can fix this approach, so I'm afraid we probably should revert to what there was previously (unless you have better suggestions) - sorry for that.",
        "createdAt" : "2019-03-29T10:56:05Z",
        "updatedAt" : "2019-04-02T03:10:56Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      },
      {
        "id" : "9aca0242-948e-4a5e-9d76-49bb2bff9716",
        "parentId" : "dde2a736-f8bf-4b54-b25c-c11a504c38d6",
        "authorId" : "2298dd66-0920-41ef-85a0-e8d08cffdc22",
        "body" : "Achieved by a little more codes which makes the add() is similar to nonblocking().",
        "createdAt" : "2019-03-29T12:28:27Z",
        "updatedAt" : "2019-04-02T03:10:56Z",
        "lastEditedBy" : "2298dd66-0920-41ef-85a0-e8d08cffdc22",
        "tags" : [
        ]
      }
    ],
    "commit" : "8910abfdf3d13faf2bf415dc1019006fb06cbc9f",
    "line" : 40,
    "diffHunk" : "@@ -1,1 +696,700 @@\t\t\t}\n\t\t}\n\t\tif !c.timer.Stop() {\n\t\t\t// Consume triggered (but not yet received) timer event\n\t\t\t// so that future reuse does not get a spurious timeout."
  },
  {
    "id" : "8ec960cb-25b6-4517-b0c1-d739e83399b4",
    "prId" : 75547,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/75547#pullrequestreview-222571475",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9336746f-713f-4b8d-92a6-03aeaa534f57",
        "parentId" : null,
        "authorId" : "42b1e004-4fa7-4e43-84cf-5378839b49ad",
        "body" : "Looking at line 973 below, isn't this equivalent to skipping the event for rest of the watchers ?",
        "createdAt" : "2019-04-03T15:56:53Z",
        "updatedAt" : "2019-04-03T15:57:56Z",
        "lastEditedBy" : "42b1e004-4fa7-4e43-84cf-5378839b49ad",
        "tags" : [
        ]
      },
      {
        "id" : "0aeec283-1796-4fad-a65f-b5fe9cf3d17a",
        "parentId" : "9336746f-713f-4b8d-92a6-03aeaa534f57",
        "authorId" : "2298dd66-0920-41ef-85a0-e8d08cffdc22",
        "body" : "Not exactly. The following ones should get a chance at the end of the period when some watcher is blocked.",
        "createdAt" : "2019-04-04T06:12:25Z",
        "updatedAt" : "2019-04-04T06:12:25Z",
        "lastEditedBy" : "2298dd66-0920-41ef-85a0-e8d08cffdc22",
        "tags" : [
        ]
      }
    ],
    "commit" : "8910abfdf3d13faf2bf415dc1019006fb06cbc9f",
    "line" : 37,
    "diffHunk" : "@@ -1,1 +693,697 @@\t\t\tif !watcher.add(event, timer) {\n\t\t\t\t// No time left, clean the timer by set it to nil.\n\t\t\t\ttimer = nil\n\t\t\t}\n\t\t}"
  },
  {
    "id" : "6ac91934-716e-445a-93e3-5dc9dc40ba53",
    "prId" : 75547,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/75547#pullrequestreview-222593115",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5aeb4b33-058e-4b37-a766-0165337da6d2",
        "parentId" : null,
        "authorId" : "42b1e004-4fa7-4e43-84cf-5378839b49ad",
        "body" : "Is it possible to continuously delay delivery to slow watcher(s) ?\r\nIn some situation, there maybe even starvation.",
        "createdAt" : "2019-04-03T15:57:52Z",
        "updatedAt" : "2019-04-03T15:57:56Z",
        "lastEditedBy" : "42b1e004-4fa7-4e43-84cf-5378839b49ad",
        "tags" : [
        ]
      },
      {
        "id" : "bfd34a96-12d5-459b-a6d4-fa63f7bcd591",
        "parentId" : "5aeb4b33-058e-4b37-a766-0165337da6d2",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "There is a timeout - if we won't be able to send event, we will simply close the watcher.",
        "createdAt" : "2019-04-04T07:25:36Z",
        "updatedAt" : "2019-04-04T07:25:36Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "8910abfdf3d13faf2bf415dc1019006fb06cbc9f",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +671,675 @@\t// Since add() can block, we explicitly add when cacher is unlocked.\n\n\t// Dispatching event in nonblocking way first, which make faster watchers\n\t// not be blocked by slower ones.\n\tc.blockedWatchers = c.blockedWatchers[:0]"
  },
  {
    "id" : "16100093-764f-4848-ab5b-19382a5bdb1c",
    "prId" : 75547,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/75547#pullrequestreview-223587069",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "601c7dcf-399c-413b-af4e-6c1c9c8dec05",
        "parentId" : null,
        "authorId" : "5af3a49e-2ce9-4046-8a13-ee66b8cbca2e",
        "body" : "I think this is incorrect. https://golang.org/pkg/time/#Timer.Stop says that this pattern can be used to drain the timer ONLY if we know that the program has not received from c.timer.C.\r\n\r\nIt's not the case here (it was before the change) -- in case of timeout, watcher.add will consume c.timer.C and return false. Then we will try to call timer.Stop (it will return false as the timer has already expired) and here we will try to read from the channel again, hanging forever. ",
        "createdAt" : "2019-04-05T13:53:35Z",
        "updatedAt" : "2019-04-05T13:53:42Z",
        "lastEditedBy" : "5af3a49e-2ce9-4046-8a13-ee66b8cbca2e",
        "tags" : [
        ]
      },
      {
        "id" : "7726480e-fe8d-4240-8e2a-622f614033eb",
        "parentId" : "601c7dcf-399c-413b-af4e-6c1c9c8dec05",
        "authorId" : "5af3a49e-2ce9-4046-8a13-ee66b8cbca2e",
        "body" : "I think it's worth to add a test case for timeout scenario. It will be a way easier to find regressions like that instead of debugging 5000 machines test.",
        "createdAt" : "2019-04-05T13:57:47Z",
        "updatedAt" : "2019-04-05T13:57:47Z",
        "lastEditedBy" : "5af3a49e-2ce9-4046-8a13-ee66b8cbca2e",
        "tags" : [
        ]
      },
      {
        "id" : "762324a0-14fd-4031-8e25-6d6a81efd4cd",
        "parentId" : "601c7dcf-399c-413b-af4e-6c1c9c8dec05",
        "authorId" : "2298dd66-0920-41ef-85a0-e8d08cffdc22",
        "body" : "sorry for the mistack, I will fix it with a test.",
        "createdAt" : "2019-04-07T14:56:46Z",
        "updatedAt" : "2019-04-07T14:56:47Z",
        "lastEditedBy" : "2298dd66-0920-41ef-85a0-e8d08cffdc22",
        "tags" : [
        ]
      }
    ],
    "commit" : "8910abfdf3d13faf2bf415dc1019006fb06cbc9f",
    "line" : 43,
    "diffHunk" : "@@ -1,1 +699,703 @@\t\t\t// Consume triggered (but not yet received) timer event\n\t\t\t// so that future reuse does not get a spurious timeout.\n\t\t\t<-c.timer.C\n\t\t}\n"
  },
  {
    "id" : "30e51b8b-89ab-4d94-b301-9b7715451447",
    "prId" : 75474,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/75474#pullrequestreview-226445960",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e1363c8c-b3e8-42d8-af3f-7222cc4ff7be",
        "parentId" : null,
        "authorId" : "d4f34d8f-5341-4ac1-b8b2-5e5f11e23a5d",
        "body" : "Let's try to keep TODOs out of merged code. Is this something we can resolve in this PR? If not would it be appropriate to open an issue to track it?",
        "createdAt" : "2019-04-12T18:44:01Z",
        "updatedAt" : "2019-04-16T11:06:05Z",
        "lastEditedBy" : "d4f34d8f-5341-4ac1-b8b2-5e5f11e23a5d",
        "tags" : [
        ]
      },
      {
        "id" : "910e1455-e033-4f51-a62d-244ab7f43335",
        "parentId" : "e1363c8c-b3e8-42d8-af3f-7222cc4ff7be",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "I would like to avoid mixing these changes with this PR - this todo can be attached to this issue:\r\nhttps://github.com/kubernetes/kubernetes/issues/73958\r\n\r\nTODO(#73958): stop() is ....",
        "createdAt" : "2019-04-12T19:33:36Z",
        "updatedAt" : "2019-04-16T11:06:05Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      },
      {
        "id" : "94638305-a894-422e-bd99-be427dea440a",
        "parentId" : "e1363c8c-b3e8-42d8-af3f-7222cc4ff7be",
        "authorId" : "2298dd66-0920-41ef-85a0-e8d08cffdc22",
        "body" : "thanks, add ref#73958 ",
        "createdAt" : "2019-04-15T04:03:15Z",
        "updatedAt" : "2019-04-16T11:06:05Z",
        "lastEditedBy" : "2298dd66-0920-41ef-85a0-e8d08cffdc22",
        "tags" : [
        ]
      }
    ],
    "commit" : "d70edd3d39d4430d71c4b7c9adba8df5ba7f16c8",
    "line" : 281,
    "diffHunk" : "@@ -1,1 +1062,1066 @@// TODO(#73958)\n// stop() is protected by Cacher.Lock(), rename it to\n// stopThreadUnsafe and remove the sync.Mutex.\nfunc (c *cacheWatcher) stop() {\n\tc.Lock()"
  },
  {
    "id" : "55376269-c303-4be7-8772-3b04deab5424",
    "prId" : 75474,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/75474#pullrequestreview-226445904",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c8097edb-ae82-4748-8768-77af8110ffca",
        "parentId" : null,
        "authorId" : "d4f34d8f-5341-4ac1-b8b2-5e5f11e23a5d",
        "body" : "clarify what deadline is here? It's not obvious.",
        "createdAt" : "2019-04-12T19:10:40Z",
        "updatedAt" : "2019-04-16T11:06:05Z",
        "lastEditedBy" : "d4f34d8f-5341-4ac1-b8b2-5e5f11e23a5d",
        "tags" : [
        ]
      },
      {
        "id" : "b7895e8a-9949-461f-a7ee-b6aec4f8878f",
        "parentId" : "c8097edb-ae82-4748-8768-77af8110ffca",
        "authorId" : "55c0e4a8-86f8-4426-a163-752ee421c57e",
        "body" : "or make the naming more specific.",
        "createdAt" : "2019-04-13T04:33:11Z",
        "updatedAt" : "2019-04-16T11:06:05Z",
        "lastEditedBy" : "55c0e4a8-86f8-4426-a163-752ee421c57e",
        "tags" : [
        ]
      },
      {
        "id" : "39458361-b39e-4133-9c2c-bfc5e145cfc5",
        "parentId" : "c8097edb-ae82-4748-8768-77af8110ffca",
        "authorId" : "2298dd66-0920-41ef-85a0-e8d08cffdc22",
        "body" : "add a comment here",
        "createdAt" : "2019-04-15T04:02:44Z",
        "updatedAt" : "2019-04-16T11:06:05Z",
        "lastEditedBy" : "2298dd66-0920-41ef-85a0-e8d08cffdc22",
        "tags" : [
        ]
      }
    ],
    "commit" : "d70edd3d39d4430d71c4b7c9adba8df5ba7f16c8",
    "line" : 249,
    "diffHunk" : "@@ -1,1 +1032,1036 @@\t// The watcher will be closed by server after the deadline,\n\t// save it here to send bookmark events before that.\n\tdeadline            time.Time\n\tallowWatchBookmarks bool\n}"
  },
  {
    "id" : "54b674fd-7ad6-46a2-911e-597e533d6726",
    "prId" : 75474,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/75474#pullrequestreview-226480904",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "efb38329-4408-49bf-a044-39edf9c54bd0",
        "parentId" : null,
        "authorId" : "d4f34d8f-5341-4ac1-b8b2-5e5f11e23a5d",
        "body" : "It's possible that no deadline is set here, right? We should be explicit about what happens in that case, either by checking `ok` (`deadline, ok := ctx.Deadline()` ... `if !ok { ... }`) or by adding a comment explaining the behavior here.",
        "createdAt" : "2019-04-12T19:16:40Z",
        "updatedAt" : "2019-04-16T11:06:05Z",
        "lastEditedBy" : "d4f34d8f-5341-4ac1-b8b2-5e5f11e23a5d",
        "tags" : [
        ]
      },
      {
        "id" : "89d3a933-8668-4468-8ee4-5ab456a39d06",
        "parentId" : "efb38329-4408-49bf-a044-39edf9c54bd0",
        "authorId" : "2298dd66-0920-41ef-85a0-e8d08cffdc22",
        "body" : "add a comment here, and change a little bit.",
        "createdAt" : "2019-04-15T07:10:12Z",
        "updatedAt" : "2019-04-16T11:06:05Z",
        "lastEditedBy" : "2298dd66-0920-41ef-85a0-e8d08cffdc22",
        "tags" : [
        ]
      }
    ],
    "commit" : "d70edd3d39d4430d71c4b7c9adba8df5ba7f16c8",
    "line" : 127,
    "diffHunk" : "@@ -1,1 +439,443 @@\n\t// Determine watch timeout('0' means deadline is not set, ignore checking)\n\tdeadline, _ := ctx.Deadline()\n\t// Create a watcher here to reduce memory allocations under lock,\n\t// given that memory allocation may trigger GC and block the thread."
  },
  {
    "id" : "6ab604dd-0536-4f19-b0c3-307434500ce0",
    "prId" : 75474,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/75474#pullrequestreview-226480966",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5d8bfebb-dbae-42e2-9954-1415c2d2e28c",
        "parentId" : null,
        "authorId" : "55c0e4a8-86f8-4426-a163-752ee421c57e",
        "body" : "nit: adding this branch makes the indentation looks a little bit crazy. ideally, we probably should add a two helper funcs or try to reduce the indentations for readability. ",
        "createdAt" : "2019-04-13T04:31:54Z",
        "updatedAt" : "2019-04-16T11:06:05Z",
        "lastEditedBy" : "55c0e4a8-86f8-4426-a163-752ee421c57e",
        "tags" : [
        ]
      },
      {
        "id" : "3102edf7-9a17-4369-b7fd-4e803e57bed9",
        "parentId" : "5d8bfebb-dbae-42e2-9954-1415c2d2e28c",
        "authorId" : "2298dd66-0920-41ef-85a0-e8d08cffdc22",
        "body" : "add a helper function here.",
        "createdAt" : "2019-04-15T07:10:25Z",
        "updatedAt" : "2019-04-16T11:06:05Z",
        "lastEditedBy" : "2298dd66-0920-41ef-85a0-e8d08cffdc22",
        "tags" : [
        ]
      }
    ],
    "commit" : "d70edd3d39d4430d71c4b7c9adba8df5ba7f16c8",
    "line" : 234,
    "diffHunk" : "@@ -1,1 +832,836 @@\tc.watchersBuffer = c.watchersBuffer[:0]\n\n\tif event.Type == watch.Bookmark {\n\t\tc.startDispatchingBookmarkEvents()\n\t\t// return here to reduce following code indentation and diff"
  },
  {
    "id" : "f7bd72fe-56f3-41e0-8ab4-621b3b1014a6",
    "prId" : 75474,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/75474#pullrequestreview-227516527",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "263276e4-7f0d-47d5-9a79-5dce9df17f11",
        "parentId" : null,
        "authorId" : "42b1e004-4fa7-4e43-84cf-5378839b49ad",
        "body" : "Do we need to check return value here ?",
        "createdAt" : "2019-04-16T17:45:57Z",
        "updatedAt" : "2019-04-16T17:46:08Z",
        "lastEditedBy" : "42b1e004-4fa7-4e43-84cf-5378839b49ad",
        "tags" : [
        ]
      },
      {
        "id" : "7b284162-076e-4477-8c19-2a15445d30e3",
        "parentId" : "263276e4-7f0d-47d5-9a79-5dce9df17f11",
        "authorId" : "2298dd66-0920-41ef-85a0-e8d08cffdc22",
        "body" : "Ignored intentionally, bookmark is not necessary when watch is blocked(which means there are many events recently).",
        "createdAt" : "2019-04-17T01:34:51Z",
        "updatedAt" : "2019-04-17T01:34:53Z",
        "lastEditedBy" : "2298dd66-0920-41ef-85a0-e8d08cffdc22",
        "tags" : [
        ]
      }
    ],
    "commit" : "d70edd3d39d4430d71c4b7c9adba8df5ba7f16c8",
    "line" : 202,
    "diffHunk" : "@@ -1,1 +790,794 @@\tif event.Type == watch.Bookmark {\n\t\tfor _, watcher := range c.watchersBuffer {\n\t\t\twatcher.nonblockingAdd(event)\n\t\t}\n\t} else {"
  },
  {
    "id" : "86001e23-2567-4631-a3e2-201008cf50da",
    "prId" : 73959,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/73959#pullrequestreview-205899185",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "44de05f6-db1c-497d-9d21-3fe4a84428f7",
        "parentId" : null,
        "authorId" : "d4f34d8f-5341-4ac1-b8b2-5e5f11e23a5d",
        "body" : "With `[:0]` go is not allowed to GC the elements of the slice, because it's required to preserve them if the slice is later reextended. Only if subsequent appends replace elements in the underlying array can they be GCd (https://play.golang.org/p/hnrAVAr0mYc). Is that safe here?",
        "createdAt" : "2019-02-14T06:20:34Z",
        "updatedAt" : "2019-02-14T09:03:43Z",
        "lastEditedBy" : "d4f34d8f-5341-4ac1-b8b2-5e5f11e23a5d",
        "tags" : [
        ]
      },
      {
        "id" : "946752a3-1ac3-40b9-94a7-56b60649d008",
        "parentId" : "44de05f6-db1c-497d-9d21-3fe4a84428f7",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "Yes - this is exactly the trick I want (I already used it couple times before, e.g. in kube-proxy here:\r\nhttps://github.com/kubernetes/kubernetes/blob/master/pkg/proxy/iptables/proxier.go#L762 )\r\n\r\nBasically what you get from it is that we don't need to allocate this slice from scratch every time. Yes - it's possible that some itmes that are \"behind its current length\" can't be GCed, but that's fine, as there is limited number of those (equal to the mix size of this slice over time).\r\nAnd reducing amount of allocations is one of the biggest improvement we can do in apiserver now.\r\nI added explicit comment about it.",
        "createdAt" : "2019-02-14T08:55:31Z",
        "updatedAt" : "2019-02-14T09:03:47Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      },
      {
        "id" : "d9ab61ac-1d22-4c9a-91aa-dc7bef4d2622",
        "parentId" : "44de05f6-db1c-497d-9d21-3fe4a84428f7",
        "authorId" : "d4f34d8f-5341-4ac1-b8b2-5e5f11e23a5d",
        "body" : "Thanks for explaining!",
        "createdAt" : "2019-02-20T17:33:36Z",
        "updatedAt" : "2019-02-20T17:33:37Z",
        "lastEditedBy" : "d4f34d8f-5341-4ac1-b8b2-5e5f11e23a5d",
        "tags" : [
        ]
      }
    ],
    "commit" : "9452adc5c89a834cd34a7758089804db0063f316",
    "line" : 102,
    "diffHunk" : "@@ -1,1 +689,693 @@\t// of the slice, but there is only a limited number of those and the\n\t// gain from avoiding memory allocations is much bigger.\n\tc.watchersBuffer = c.watchersBuffer[:0]\n\n\t// Iterate over \"allWatchers\" no matter what the trigger function is."
  }
]
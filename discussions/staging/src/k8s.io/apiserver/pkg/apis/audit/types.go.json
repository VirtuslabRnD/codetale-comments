[
  {
    "id" : "c6733d61-cec5-40b8-8154-a36e5a965664",
    "prId" : 49280,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/49280#pullrequestreview-74323363",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "18f2ae99-7f46-4105-8ffd-86961007f7bc",
        "parentId" : null,
        "authorId" : "087d84fc-07af-43a9-8be7-af7ed27f5df4",
        "body" : "should we mark this as optional?",
        "createdAt" : "2017-11-06T04:35:31Z",
        "updatedAt" : "2017-11-06T04:35:32Z",
        "lastEditedBy" : "087d84fc-07af-43a9-8be7-af7ed27f5df4",
        "tags" : [
        ]
      },
      {
        "id" : "46161c67-d827-4267-82c1-53aab76a35e2",
        "parentId" : "18f2ae99-7f46-4105-8ffd-86961007f7bc",
        "authorId" : "b41ac763-2378-4c8a-a9bf-7a3dd4082826",
        "body" : "Yes, we should.",
        "createdAt" : "2017-11-06T05:42:14Z",
        "updatedAt" : "2017-11-06T05:42:14Z",
        "lastEditedBy" : "b41ac763-2378-4c8a-a9bf-7a3dd4082826",
        "tags" : [
        ]
      },
      {
        "id" : "14a7c3ca-a8da-4705-a262-1c8289ea3802",
        "parentId" : "18f2ae99-7f46-4105-8ffd-86961007f7bc",
        "authorId" : "b41ac763-2378-4c8a-a9bf-7a3dd4082826",
        "body" : "Added here together:\r\nhttps://github.com/kubernetes/kubernetes/pull/54634",
        "createdAt" : "2017-11-06T06:02:45Z",
        "updatedAt" : "2017-11-06T06:02:45Z",
        "lastEditedBy" : "b41ac763-2378-4c8a-a9bf-7a3dd4082826",
        "tags" : [
        ]
      }
    ],
    "commit" : "b50acbdf0152f59e5fd6b065560aed4f85717a7a",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +210,214 @@\n\t// OmitStages specify events generated in which stages will not be emitted to backend.\n\t// An empty list means no restrictions will apply.\n\tOmitStages []Stage\n}"
  },
  {
    "id" : "63e3f53c-5998-4c4c-a42b-281154e3784c",
    "prId" : 46065,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/46065#pullrequestreview-39087169",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "99655823-5446-4da0-abd8-d87b31e09b3e",
        "parentId" : null,
        "authorId" : "0adf587c-aaa2-4e47-be0f-a26d4fde14ac",
        "body" : "Let's move the discussion of whether audit IDs should be 1 or many to here.\r\n\r\n@deads2k - I think part of my reservation around multiple audit IDs is I don't understand what threat the audit trace would help to capture. Can you elaborate?",
        "createdAt" : "2017-05-19T00:24:25Z",
        "updatedAt" : "2017-05-24T14:45:33Z",
        "lastEditedBy" : "0adf587c-aaa2-4e47-be0f-a26d4fde14ac",
        "tags" : [
        ]
      }
    ],
    "commit" : "4c54970d31f0e35f21247514fb946081e6ee0be5",
    "line" : 9,
    "diffHunk" : "@@ -1,1 +28,32 @@\t// Audit-ID header should be set by the first server to receive the request (e.g. the federation\n\t// server or kube-aggregator).\n\tHeaderAuditID = \"Audit-ID\"\n)\n"
  },
  {
    "id" : "c02af5b4-71ac-41d9-b00a-ddaf14c3d7ea",
    "prId" : 46065,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/46065#pullrequestreview-39144685",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f277146a-30ef-473e-a151-a32c7aeb66f6",
        "parentId" : null,
        "authorId" : "0adf587c-aaa2-4e47-be0f-a26d4fde14ac",
        "body" : "Stage? Phase? Reason? - I'm open to naming suggestions here, but would prefer an enum to a boolean.",
        "createdAt" : "2017-05-19T00:24:59Z",
        "updatedAt" : "2017-05-24T14:45:33Z",
        "lastEditedBy" : "0adf587c-aaa2-4e47-be0f-a26d4fde14ac",
        "tags" : [
        ]
      },
      {
        "id" : "750cf1bd-4e2f-4539-a80b-ad55fa561b6e",
        "parentId" : "f277146a-30ef-473e-a151-a32c7aeb66f6",
        "authorId" : "b7d2a698-a6e1-4031-bb69-8b45505badb5",
        "body" : "👍 for stage",
        "createdAt" : "2017-05-19T05:35:43Z",
        "updatedAt" : "2017-05-24T14:45:33Z",
        "lastEditedBy" : "b7d2a698-a6e1-4031-bb69-8b45505badb5",
        "tags" : [
        ]
      },
      {
        "id" : "f4b6f384-d694-48d7-aeb5-dd8f68142dc0",
        "parentId" : "f277146a-30ef-473e-a151-a32c7aeb66f6",
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "stage",
        "createdAt" : "2017-05-19T09:04:03Z",
        "updatedAt" : "2017-05-24T14:45:33Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      }
    ],
    "commit" : "4c54970d31f0e35f21247514fb946081e6ee0be5",
    "line" : 43,
    "diffHunk" : "@@ -1,1 +79,83 @@\tAuditID types.UID\n\t// Stage of the request handling when this event instance was generated.\n\tStage Stage\n\n\t// RequestURI is the request URI as sent by the client to a server."
  },
  {
    "id" : "ad44850d-6c7d-44b8-8360-dc628629274b",
    "prId" : 46065,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/46065#pullrequestreview-39955953",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "01e2d736-8bf3-46c2-ae45-e7fd309b5438",
        "parentId" : null,
        "authorId" : "0adf587c-aaa2-4e47-be0f-a26d4fde14ac",
        "body" : "@sttts  does the response started vs. completed distinction make sense for long running and short requests? I thought that having both send response completed, but reserve `ResponseStarted` for long running requests made more sense than the other way around.",
        "createdAt" : "2017-05-19T00:26:00Z",
        "updatedAt" : "2017-05-24T14:45:33Z",
        "lastEditedBy" : "0adf587c-aaa2-4e47-be0f-a26d4fde14ac",
        "tags" : [
        ]
      },
      {
        "id" : "e1d332a9-97b9-4c9e-a8ad-31849cdd0735",
        "parentId" : "01e2d736-8bf3-46c2-ae45-e7fd309b5438",
        "authorId" : "b7d2a698-a6e1-4031-bb69-8b45505badb5",
        "body" : "Started vs Complete does make sense. I'm not sure received vs started does? Can there be a received but not started, or that will hang for a while and then started?",
        "createdAt" : "2017-05-19T05:35:26Z",
        "updatedAt" : "2017-05-24T14:45:33Z",
        "lastEditedBy" : "b7d2a698-a6e1-4031-bb69-8b45505badb5",
        "tags" : [
        ]
      },
      {
        "id" : "e7bff916-cf47-484f-a181-1e0e939d37dd",
        "parentId" : "01e2d736-8bf3-46c2-ae45-e7fd309b5438",
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "- RequestReceived => meta data\r\n- ResponseStarted => header is complete, http status code is filled in, RequestObject is written\r\n- ResponseComplete => ResponseObject is written\r\n\r\nMakes sense.\r\n\r\nWe will create these events:\r\n\r\n- short-running reading => ResponseComplete\r\n- short-running writing => RequestReceived + ResponseComplete\r\n- long-running reading => ResponseStarted + ResponseComplete\r\n- long-running writing (e.g. proxy, exec, ...) => all 3\r\n- if we don't know: all three (?)\r\n\r\nDoes this make sense? Do we need RequestResponseStarted also for short-running-reading?",
        "createdAt" : "2017-05-19T09:16:31Z",
        "updatedAt" : "2017-05-24T14:45:33Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      },
      {
        "id" : "341367c7-60bc-45ae-8729-6437dff9bdf7",
        "parentId" : "01e2d736-8bf3-46c2-ae45-e7fd309b5438",
        "authorId" : "0adf587c-aaa2-4e47-be0f-a26d4fde14ac",
        "body" : "While I agree that `RequestReceived` is less useful for read-only requests, should we really be hardcoding that? Or do you think we need to extend the policy to include that?\r\n\r\n@soltysh - Unfortunately the distinction between received & started is tied to the implementation (i.e. before the request is passed from the audit http handler to the delegate). From the user perspective, maybe this can be thought of as before the request is handled, vs before the request is handled but the response hasn't been sent? \"Started\" really only makes sense for long running requests anyway.",
        "createdAt" : "2017-05-19T15:42:52Z",
        "updatedAt" : "2017-05-24T14:45:33Z",
        "lastEditedBy" : "0adf587c-aaa2-4e47-be0f-a26d4fde14ac",
        "tags" : [
        ]
      },
      {
        "id" : "3f7da41b-769c-487a-909d-4afce14669d5",
        "parentId" : "01e2d736-8bf3-46c2-ae45-e7fd309b5438",
        "authorId" : "0af48e59-4be9-46ce-9275-aa218813b6fd",
        "body" : "RequestReceived seems like it'd be somewhat useful for aggregated API servers where the request would be forwarded to another server after RequestReceived and before ResponseComplete.\r\n\r\nRegardless this doesn't actually impact the types, right? Just the implementation? I could imagine us being vague about what stages other than ResponseComplete actually get sent for the alpha implementation.",
        "createdAt" : "2017-05-22T20:30:31Z",
        "updatedAt" : "2017-05-24T14:45:33Z",
        "lastEditedBy" : "0af48e59-4be9-46ce-9275-aa218813b6fd",
        "tags" : [
        ]
      },
      {
        "id" : "02cd20ff-7b5e-49a8-958e-0ff1996fca54",
        "parentId" : "01e2d736-8bf3-46c2-ae45-e7fd309b5438",
        "authorId" : "0adf587c-aaa2-4e47-be0f-a26d4fde14ac",
        "body" : "@ericchiang agreed",
        "createdAt" : "2017-05-22T20:32:56Z",
        "updatedAt" : "2017-05-24T14:45:33Z",
        "lastEditedBy" : "0adf587c-aaa2-4e47-be0f-a26d4fde14ac",
        "tags" : [
        ]
      },
      {
        "id" : "b6631eff-bc6b-4901-888b-323a43b3878e",
        "parentId" : "01e2d736-8bf3-46c2-ae45-e7fd309b5438",
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "I am fine with a hard-coded logic as above for alpha. We can extend this later.",
        "createdAt" : "2017-05-23T07:17:12Z",
        "updatedAt" : "2017-05-24T14:45:33Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      },
      {
        "id" : "c2c67a69-382d-4e0e-bb55-c00327fa0951",
        "parentId" : "01e2d736-8bf3-46c2-ae45-e7fd309b5438",
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "What about the panic handler? Technically a panic can happen in any phase. We could add another stage for panic.",
        "createdAt" : "2017-05-24T08:19:52Z",
        "updatedAt" : "2017-05-24T14:45:33Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      }
    ],
    "commit" : "4c54970d31f0e35f21247514fb946081e6ee0be5",
    "line" : 32,
    "diffHunk" : "@@ -1,1 +61,65 @@\t// The stage for events generated once the response body has been completed, and no more bytes\n\t// will be sent.\n\tStageResponseComplete = \"ResponseComplete\"\n)\n"
  },
  {
    "id" : "b884da66-8609-45fc-b24c-c8e5e414e21a",
    "prId" : 46065,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/46065#pullrequestreview-39147265",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d847e89d-ac4a-46d1-9398-48fb48d8bf47",
        "parentId" : null,
        "authorId" : "0adf587c-aaa2-4e47-be0f-a26d4fde14ac",
        "body" : "Actually, there's no precedent for using `runtime.Unkown` directly, so I changed to using a pointer type here /cc @sttts ",
        "createdAt" : "2017-05-19T00:27:42Z",
        "updatedAt" : "2017-05-24T14:45:33Z",
        "lastEditedBy" : "0adf587c-aaa2-4e47-be0f-a26d4fde14ac",
        "tags" : [
        ]
      },
      {
        "id" : "3ba555f7-77ad-4332-920c-c3908cc10f5e",
        "parentId" : "d847e89d-ac4a-46d1-9398-48fb48d8bf47",
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : ":+1:",
        "createdAt" : "2017-05-19T09:16:48Z",
        "updatedAt" : "2017-05-24T14:45:33Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      }
    ],
    "commit" : "4c54970d31f0e35f21247514fb946081e6ee0be5",
    "line" : 59,
    "diffHunk" : "@@ -1,1 +114,118 @@\t// at Response Level.\n\t// +optional\n\tResponseObject *runtime.Unknown\n}\n"
  },
  {
    "id" : "27287af2-1a2a-4500-ab5e-94f9051f0863",
    "prId" : 45315,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/45315#pullrequestreview-38909987",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ca21d81f-4b8a-4886-a12f-2fd9956f6456",
        "parentId" : null,
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "How does this help with filters? Filters will not be done by the backend, but before writing it into the event.",
        "createdAt" : "2017-05-18T07:14:41Z",
        "updatedAt" : "2017-05-18T17:39:24Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      },
      {
        "id" : "b7daed07-466d-4b42-a8b8-d504a0a910c6",
        "parentId" : "ca21d81f-4b8a-4886-a12f-2fd9956f6456",
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "I would suggest to use runtime.Object in the internal type and have a serialization to string during conversion to the external type. @deads2k wdyt?",
        "createdAt" : "2017-05-18T07:30:39Z",
        "updatedAt" : "2017-05-18T17:39:24Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      },
      {
        "id" : "e3bdf3fd-6b57-487f-aaaa-b14d5f16b6bc",
        "parentId" : "ca21d81f-4b8a-4886-a12f-2fd9956f6456",
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "> I would suggest to use runtime.Object in the internal type and have a serialization to string during conversion to the external type. @deads2k wdyt?\r\n\r\nI think I'll leave the exact mechanism to be the easiest available, but I wanted to make certain it wasn't a string.  I think that `runtime.Unknown` will be guaranteed to pass straight through without anything trying to encode or decode directly.  If we use a `runtime.Object` it will be affected by the outer encoding structure (again, I think).  `runtime.RawExtension` may work internal and external as well.\r\n\r\nI really just wanted to guarantee this didn't end up as a string so that we'd be able to directly inspect with a jsonpath filter or the like against incoming data if we wished without having to pull out the information.  Someday jsonpath may catch up to xml and we'll get streaming evaluators.",
        "createdAt" : "2017-05-18T11:21:05Z",
        "updatedAt" : "2017-05-18T17:39:24Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      },
      {
        "id" : "d45a177b-8de6-4a7f-be0f-78aaf1dab96c",
        "parentId" : "ca21d81f-4b8a-4886-a12f-2fd9956f6456",
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "The jsonpath idea is a good point. If `runtime.Unknown` comes through as a sub-expression of the object, that's perfect. This is also true for protobuf, i.e. if the `Event` is serialized as protobuf, will the `runtime.Unknown` come through correctly, i.e. either as JSON or as some protobuf encoding of JSON?",
        "createdAt" : "2017-05-18T11:24:54Z",
        "updatedAt" : "2017-05-18T17:39:24Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      },
      {
        "id" : "f862bfc2-3e24-4119-8350-aef9e0d53d7f",
        "parentId" : "ca21d81f-4b8a-4886-a12f-2fd9956f6456",
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "> How does this help with filters? Filters will not be done by the backend, but before writing it into the event.\r\n\r\nI'd like the object shape to be inspectable if the sync does something like write it directly to a different etcd. Not nice, not good, but having the object directly embedded means that anyone looking at an `Event.audit.k8s.io` can run jsonpath and jq sanely against the object itself. I don't think that stringifying json inside of (likely) json is path we'd be happy with.  We encouraged servicecatalog to avoid it for much the same reason.",
        "createdAt" : "2017-05-18T11:26:52Z",
        "updatedAt" : "2017-05-18T17:39:24Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      },
      {
        "id" : "5355c76a-a024-4111-a202-c5aa5cba9c31",
        "parentId" : "ca21d81f-4b8a-4886-a12f-2fd9956f6456",
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "> This is also true for protobuf, i.e. if the Event is serialized as protobuf, will the runtime.Unknown come through correctly, i.e. either as JSON or as some protobuf encoding of JSON?\r\n\r\n`runtime.Unknown` should come through as its native encoding.  So the event fields would be protobuf, but this element would be json inside of it.  We use this for `Template.templates.openshift.io` which have an outer proto encoding with an inner json one.",
        "createdAt" : "2017-05-18T11:30:08Z",
        "updatedAt" : "2017-05-18T17:39:24Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      }
    ],
    "commit" : "dd9e0ecd06e7f11cb61c1549b00a6e6185b85e47",
    "line" : 57,
    "diffHunk" : "@@ -1,1 +82,86 @@\t// Omitted for non-resource requests.  Only logged at Request Level and higher.\n\t// +optional\n\tRequestObject runtime.Unknown\n\t// API object returned in the response, in JSON. The ResponseObject is recorded after conversion\n\t// to the external type, and serialized as JSON.  Omitted for non-resource requests.  Only logged"
  },
  {
    "id" : "b1f6e389-228f-403a-9f02-8fa4019415c3",
    "prId" : 45315,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/45315#pullrequestreview-38909457",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6fa9699f-53de-4288-828c-2535004e9c52",
        "parentId" : null,
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "why? Which infrastructure?",
        "createdAt" : "2017-05-18T07:14:59Z",
        "updatedAt" : "2017-05-18T17:39:24Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      },
      {
        "id" : "222674e3-841f-4481-aace-8db3a8d8b5cd",
        "parentId" : "6fa9699f-53de-4288-828c-2535004e9c52",
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "> why? Which infrastructure?\r\n\r\nGeneration, generic clients, scope naming, API installer infrastructure (if we ever want it).  I've been down the path of excluding this before and you get whacky errors.  I don't see a reason to fight our infrastructure on a few fields, several of which we probably want in the end like annotations.",
        "createdAt" : "2017-05-18T11:22:33Z",
        "updatedAt" : "2017-05-18T17:39:24Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      },
      {
        "id" : "3ae590db-3382-40bb-8b23-f1c9c3311292",
        "parentId" : "6fa9699f-53de-4288-828c-2535004e9c52",
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "Ok, all the arguments I had with my previous pull https://github.com/kubernetes/kubernetes/pull/45765. I don't argue against this, quite the opposite!",
        "createdAt" : "2017-05-18T11:27:08Z",
        "updatedAt" : "2017-05-18T17:39:24Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      }
    ],
    "commit" : "dd9e0ecd06e7f11cb61c1549b00a6e6185b85e47",
    "line" : 74,
    "diffHunk" : "@@ -1,1 +105,109 @@\t// ObjectMeta is included for interoperability with API infrastructure.\n\t// +optional\n\tmetav1.ObjectMeta\n\n\t// Rules specify the audit Level a request should be recorded at."
  },
  {
    "id" : "3e78acea-290d-4b8f-bb17-0b12f382cc4b",
    "prId" : 45315,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/45315#pullrequestreview-38908646",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fbe22567-6d1b-40e7-bd06-09bb1f363ef9",
        "parentId" : null,
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "why?",
        "createdAt" : "2017-05-18T07:15:30Z",
        "updatedAt" : "2017-05-18T17:39:24Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      },
      {
        "id" : "1097479f-64b8-49a5-a699-a11358a7e0d8",
        "parentId" : "fbe22567-6d1b-40e7-bd06-09bb1f363ef9",
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "> why? Which infrastructure?\r\n\r\nGeneration, generic clients, scope naming, API installer infrastructure (if we ever want it).  I've been down the path of excluding this before and you get whacky errors.  I don't see a reason to fight our infrastructure on a few fields, several of which we probably want in the end like annotations.",
        "createdAt" : "2017-05-18T11:22:37Z",
        "updatedAt" : "2017-05-18T17:39:24Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      }
    ],
    "commit" : "dd9e0ecd06e7f11cb61c1549b00a6e6185b85e47",
    "line" : 24,
    "diffHunk" : "@@ -1,1 +45,49 @@\t// ObjectMeta is included for interoperability with API infrastructure.\n\t// +optional\n\tmetav1.ObjectMeta\n\n\t// AuditLevel at which event was generated"
  },
  {
    "id" : "0074f38c-e3f2-4efc-8002-723ec18da87e",
    "prId" : 45315,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/45315#pullrequestreview-39003109",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3f2c83d0-1aa9-4a5e-9a5d-e3e00ac35652",
        "parentId" : null,
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "They are ordered anyway. To be consistent this must be LevelMetaRequestResponse. No I don't like that.",
        "createdAt" : "2017-05-18T07:16:39Z",
        "updatedAt" : "2017-05-18T17:39:24Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      },
      {
        "id" : "48dd6aa0-d30e-4eaa-8151-862c93a78ce7",
        "parentId" : "3f2c83d0-1aa9-4a5e-9a5d-e3e00ac35652",
        "authorId" : "0adf587c-aaa2-4e47-be0f-a26d4fde14ac",
        "body" : "The idea was that you the user would always want metadata, and it's just the request/response part that doesn't have a well defined \"ordering\". Anyhow, let's follow up elsewhere.",
        "createdAt" : "2017-05-18T17:23:13Z",
        "updatedAt" : "2017-05-18T17:39:24Z",
        "lastEditedBy" : "0adf587c-aaa2-4e47-be0f-a26d4fde14ac",
        "tags" : [
        ]
      }
    ],
    "commit" : "dd9e0ecd06e7f11cb61c1549b00a6e6185b85e47",
    "line" : 16,
    "diffHunk" : "@@ -1,1 +37,41 @@\t// LevelRequestResponse provides Request level of auditing, and additionally\n\t// logs the response object (does not apply for non-resource requests).\n\tLevelRequestResponse Level = \"RequestResponse\"\n)\n"
  },
  {
    "id" : "8736c30a-7a4b-4300-ac4d-d71e6fb462df",
    "prId" : 45315,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/45315#pullrequestreview-39309876",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1f3b58eb-f2aa-4449-a502-10824305e3b8",
        "parentId" : null,
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "Just noticed: runtime.Unknown is a struct, not an interface. So detection whether this field is set, is a bit awkward. Maybe we should make it a pointer (assuming the encoding stays the same in json).",
        "createdAt" : "2017-05-18T11:50:00Z",
        "updatedAt" : "2017-05-18T17:39:24Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      },
      {
        "id" : "6ee43bac-a03c-4a5f-be74-dce8843bde85",
        "parentId" : "1f3b58eb-f2aa-4449-a502-10824305e3b8",
        "authorId" : "0adf587c-aaa2-4e47-be0f-a26d4fde14ac",
        "body" : "Yeah, I originally had it as a pointer type (both the runtime.Unknown and runtime.RawExtension) but I noticed that everywhere else it's used (well, runtime.Unknown doesn't appear to be used directly anywhere) in our code without a pointer, even where it's optional (e.g. [here](https://github.com/kubernetes/kubernetes/blob/e9b02c2e2b206ab0f4beb146e5fd1edcc385b70b/staging/src/k8s.io/apiserver/pkg/apis/apiserver/v1alpha1/types.go#L47) and [here](https://github.com/kubernetes/kubernetes/blob/e9b02c2e2b206ab0f4beb146e5fd1edcc385b70b/pkg/watch/json/types.go#L41)).\r\n\r\n@deads2k how is this handled in openshift?",
        "createdAt" : "2017-05-18T16:14:32Z",
        "updatedAt" : "2017-05-18T17:39:24Z",
        "lastEditedBy" : "0adf587c-aaa2-4e47-be0f-a26d4fde14ac",
        "tags" : [
        ]
      },
      {
        "id" : "a9412947-b691-4546-9bf1-a4889cad3b6c",
        "parentId" : "1f3b58eb-f2aa-4449-a502-10824305e3b8",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "For internal types, runtime.Unknown will be \"set\" if internal data is nil or not.",
        "createdAt" : "2017-05-19T22:06:10Z",
        "updatedAt" : "2017-05-19T22:06:10Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      }
    ],
    "commit" : "dd9e0ecd06e7f11cb61c1549b00a6e6185b85e47",
    "line" : 64,
    "diffHunk" : "@@ -1,1 +87,91 @@\t// at Response Level.\n\t// +optional\n\tResponseObject runtime.Unknown\n}\n"
  }
]
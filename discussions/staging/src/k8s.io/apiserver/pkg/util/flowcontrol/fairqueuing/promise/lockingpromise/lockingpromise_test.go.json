[
  {
    "id" : "4098e263-520e-4dc0-b930-a13b7ca6b65e",
    "prId" : 87362,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/87362#pullrequestreview-347796969",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "aad7d424-b0ca-4e91-aec0-167b4d366e46",
        "parentId" : null,
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "I think this is racy/flaky, there could be an arbitrary delay between the broadcast and the wake?",
        "createdAt" : "2020-01-23T23:43:29Z",
        "updatedAt" : "2020-01-24T19:35:34Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "04ac19ef-4f16-49cd-a9f8-e236ba51b51f",
        "parentId" : "aad7d424-b0ca-4e91-aec0-167b4d366e46",
        "authorId" : "7a59a326-58b3-4590-b70a-297d2e27daa5",
        "body" : "No, `clock.Run` takes care of this if the code is correct.  Before every attempt to advance the fake time, it waits for all counted goroutines to finish or block.  The sleep is only there to catch bugs.",
        "createdAt" : "2020-01-24T08:11:20Z",
        "updatedAt" : "2020-01-24T19:35:34Z",
        "lastEditedBy" : "7a59a326-58b3-4590-b70a-297d2e27daa5",
        "tags" : [
        ]
      }
    ],
    "commit" : "cbdd3a279e6161d73f2c4e8a2b916ae74b258621",
    "line" : 32,
    "diffHunk" : "@@ -1,1 +50,54 @@\twr.Set(aval)\n\tclock.Run(nil)\n\ttime.Sleep(time.Second)\n\tif atomic.LoadInt32(&gots) != 1 {\n\t\tt.Error(\"Get did not return after Set\")"
  },
  {
    "id" : "11c241c6-6720-4ebe-b5e0-1e346b487224",
    "prId" : 87362,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/87362#pullrequestreview-347797383",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8da5f17d-b7c4-45bd-bc89-6158af99e827",
        "parentId" : null,
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "It's more traditional to use a channel close (or write/read) for things like this. It makes it easier to wait as long as needed but no longer, e.g.\r\n\r\n```\r\nselect {\r\n  case <-readCompletions:\r\n  case time.After(30*time.Second):\r\n    t.Fatalf(\"failed after an excessively generous timeout\")\r\n}\r\n```\r\n",
        "createdAt" : "2020-01-23T23:46:06Z",
        "updatedAt" : "2020-01-24T19:35:34Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "8cefa749-7cfc-4d60-9a3d-6b47ea7a3b40",
        "parentId" : "8da5f17d-b7c4-45bd-bc89-6158af99e827",
        "authorId" : "7a59a326-58b3-4590-b70a-297d2e27daa5",
        "body" : "These promisoids are explicitly intended to participate in the goroutine counting that FakeEventClock uses, so it is proper for the test to exercise that.",
        "createdAt" : "2020-01-24T08:12:25Z",
        "updatedAt" : "2020-01-24T19:35:34Z",
        "lastEditedBy" : "7a59a326-58b3-4590-b70a-297d2e27daa5",
        "tags" : [
        ]
      }
    ],
    "commit" : "cbdd3a279e6161d73f2c4e8a2b916ae74b258621",
    "line" : 33,
    "diffHunk" : "@@ -1,1 +51,55 @@\tclock.Run(nil)\n\ttime.Sleep(time.Second)\n\tif atomic.LoadInt32(&gots) != 1 {\n\t\tt.Error(\"Get did not return after Set\")\n\t}"
  }
]
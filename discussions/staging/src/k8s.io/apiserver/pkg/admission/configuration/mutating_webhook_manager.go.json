[
  {
    "id" : "bdbcf57f-4a16-409e-988f-1a5d4855284e",
    "prId" : 56478,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/56478#pullrequestreview-95815345",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ff661f0e-c64a-4591-b81e-b66f00ceefdf",
        "parentId" : null,
        "authorId" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "body" : "If the informer encounters errors, we should surface them here. We don't want an apiserver to apply stale webhook configurations if the informer has been out of sync for a long time. I don't know how feasible it is to expose informer errors though. @liggitt wdyt?\r\n\r\nI checked the rbac authorizer code, it didn't surface any informer error. It's ok for the rbac authorizer, since it's using a loopback client so the chance of informer being stale is low. But the webhook configuration manager might run on a different machine than the kube-apiserver, so we need to handle informer errors.",
        "createdAt" : "2017-12-06T22:26:58Z",
        "updatedAt" : "2018-02-08T11:10:56Z",
        "lastEditedBy" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "tags" : [
        ]
      },
      {
        "id" : "a8036c66-eb66-40f3-b213-2b8eb560ff62",
        "parentId" : "ff661f0e-c64a-4591-b81e-b66f00ceefdf",
        "authorId" : "c29e1906-5f0b-4d7b-af8b-d664805e8c8e",
        "body" : "This way is much like controllers usage.  They all wait for cache sync before use, and then the add/update/delete operations handled by event handler. Your meaning is more like a network issue, which is handled by lower level, right?",
        "createdAt" : "2017-12-07T01:20:07Z",
        "updatedAt" : "2018-02-08T11:10:56Z",
        "lastEditedBy" : "c29e1906-5f0b-4d7b-af8b-d664805e8c8e",
        "tags" : [
        ]
      },
      {
        "id" : "40c3774b-4cea-4a9d-a071-08f0e6482121",
        "parentId" : "ff661f0e-c64a-4591-b81e-b66f00ceefdf",
        "authorId" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "body" : "Kubernetes controllers only need to guarantee eventual consistency. Controllers can retry after the network issue is resolved. But for the webhook admission controller, if it makes admission decision based on stale configuration, it doesn't have a chance to retry.\r\n\r\nOn the other hand, maybe we can argue that if an network issue affects the informer, then aggregator won't be able to delegate the API request to the extension apiserver either.",
        "createdAt" : "2017-12-07T01:59:41Z",
        "updatedAt" : "2018-02-08T11:10:56Z",
        "lastEditedBy" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "tags" : [
        ]
      },
      {
        "id" : "d8380e92-8082-488d-bb9f-31f00b7868ed",
        "parentId" : "ff661f0e-c64a-4591-b81e-b66f00ceefdf",
        "authorId" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "body" : "The PR lgtm except this issue. I'll be OOO until the new year, so I'm re-assigning it to @cheftako.",
        "createdAt" : "2017-12-12T01:35:40Z",
        "updatedAt" : "2018-02-08T11:10:56Z",
        "lastEditedBy" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "tags" : [
        ]
      },
      {
        "id" : "0be8e10c-f0dc-438f-b6f6-f20005c4ccc8",
        "parentId" : "ff661f0e-c64a-4591-b81e-b66f00ceefdf",
        "authorId" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "body" : "> If the informer encounters errors, we should surface them here. We don't want an apiserver to apply stale webhook configurations if the informer has been out of sync for a long time. \r\n\r\n@sttts @hzxuzhonghu Have we started a solution for this issue? I can start a design on how to expose apiserver's observed configurations. We mentioned CRD needed a similar mechanism in the sig meeting, what are the exact requirements of CRD?",
        "createdAt" : "2018-01-18T02:24:22Z",
        "updatedAt" : "2018-02-08T11:10:56Z",
        "lastEditedBy" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "tags" : [
        ]
      },
      {
        "id" : "b16acdcc-07a0-45b0-83f5-f73dfafa676c",
        "parentId" : "ff661f0e-c64a-4591-b81e-b66f00ceefdf",
        "authorId" : "c29e1906-5f0b-4d7b-af8b-d664805e8c8e",
        "body" : "Not yet.",
        "createdAt" : "2018-01-18T02:51:58Z",
        "updatedAt" : "2018-02-08T11:10:56Z",
        "lastEditedBy" : "c29e1906-5f0b-4d7b-af8b-d664805e8c8e",
        "tags" : [
        ]
      },
      {
        "id" : "1be3133b-8cab-4a59-a6ba-06c698b5d4e8",
        "parentId" : "ff661f0e-c64a-4591-b81e-b66f00ceefdf",
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "We're only talking about degrees of staleness.  Without server fencing or checkpointing of some kind, you face the same problem.  I think the rbac comparison is very pertinent since the same arguments about \"you shouldn't have been able to create this\" apply.  When an aggregated apiserver loses its connection to the kube-apiserver, it's going to start rejecting requests on 403's anyway.\r\n\r\nWhile I think the idea of exposing the state of the lister is good idea, I don't think it should block the overall improvement we get out of this pull.  ",
        "createdAt" : "2018-02-12T14:54:16Z",
        "updatedAt" : "2018-02-12T14:54:16Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      }
    ],
    "commit" : "ea7a71301009fb3e0426ea93f070c27538e59f86",
    "line" : 76,
    "diffHunk" : "@@ -1,1 +56,60 @@\n// Webhooks returns the merged MutatingWebhookConfiguration.\nfunc (m *MutatingWebhookConfigurationManager) Webhooks() *v1beta1.MutatingWebhookConfiguration {\n\treturn m.configuration.Load().(*v1beta1.MutatingWebhookConfiguration)\n}"
  },
  {
    "id" : "b988178f-e83e-46f9-9966-2a0b0b3b421c",
    "prId" : 56478,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/56478#pullrequestreview-88404934",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c287a30f-8051-4eea-b4b6-699003dd5dc8",
        "parentId" : null,
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "why public? Also the prefix `MutatingWebhook` is implicit due to the package.",
        "createdAt" : "2018-01-12T08:08:29Z",
        "updatedAt" : "2018-02-08T11:10:56Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      },
      {
        "id" : "f3777d7d-94db-402b-a7a2-ba0dac213288",
        "parentId" : "c287a30f-8051-4eea-b4b6-699003dd5dc8",
        "authorId" : "c29e1906-5f0b-4d7b-af8b-d664805e8c8e",
        "body" : "ok",
        "createdAt" : "2018-01-12T08:24:03Z",
        "updatedAt" : "2018-02-08T11:10:56Z",
        "lastEditedBy" : "c29e1906-5f0b-4d7b-af8b-d664805e8c8e",
        "tags" : [
        ]
      }
    ],
    "commit" : "ea7a71301009fb3e0426ea93f070c27538e59f86",
    "line" : 119,
    "diffHunk" : "@@ -1,1 +83,87 @@type MutatingWebhookConfigurationSorter []*v1beta1.MutatingWebhookConfiguration\n\nfunc (a MutatingWebhookConfigurationSorter) ByName(i, j int) bool {\n\treturn a[i].Name < a[j].Name\n}"
  },
  {
    "id" : "49fc9599-feb9-4f02-9941-3a65e111483b",
    "prId" : 55282,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/55282#pullrequestreview-75598635",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "60db7619-5fbd-44b3-be57-25439ee0f610",
        "parentId" : null,
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "Isn't this list coming from the lister, i.e. a local cache? Does line 83 mutate that object?",
        "createdAt" : "2017-11-08T16:29:12Z",
        "updatedAt" : "2017-11-09T23:34:03Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      },
      {
        "id" : "92ddca93-6d28-4b39-ba06-37311661c4ff",
        "parentId" : "60db7619-5fbd-44b3-be57-25439ee0f610",
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "Our standard listers create temporary lists at least. But it doesn't look like it's specified that the callee is the owner of the list. In any case, `mergeMutatingWebhookConfigurations` does not give any hint that it mutates its arguments.",
        "createdAt" : "2017-11-08T16:34:39Z",
        "updatedAt" : "2017-11-09T23:34:03Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      },
      {
        "id" : "216174cf-f4bd-49b3-9db6-a0c5355e17e9",
        "parentId" : "60db7619-5fbd-44b3-be57-25439ee0f610",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "This is copied from the existing one-- if the existing one is broken we should fix it both places.",
        "createdAt" : "2017-11-08T22:31:31Z",
        "updatedAt" : "2017-11-09T23:34:03Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "869f3ff3-59cb-4d82-b93f-e2c9158efe5f",
        "parentId" : "60db7619-5fbd-44b3-be57-25439ee0f610",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "This modifies the List object but the List object is constructed each time?",
        "createdAt" : "2017-11-08T22:32:30Z",
        "updatedAt" : "2017-11-09T23:34:03Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "46d1f837-80c7-4d93-be5f-3b75f8a64d46",
        "parentId" : "60db7619-5fbd-44b3-be57-25439ee0f610",
        "authorId" : "7f521a0d-2137-47c7-a390-3b4bdcffe306",
        "body" : "the function should not mutate that list. Will fix.",
        "createdAt" : "2017-11-08T22:32:32Z",
        "updatedAt" : "2017-11-09T23:34:03Z",
        "lastEditedBy" : "7f521a0d-2137-47c7-a390-3b4bdcffe306",
        "tags" : [
        ]
      },
      {
        "id" : "78d9ba38-6922-4cdc-9253-46f17aeaf212",
        "parentId" : "60db7619-5fbd-44b3-be57-25439ee0f610",
        "authorId" : "7f521a0d-2137-47c7-a390-3b4bdcffe306",
        "body" : "@lavalamp Even if the list object is constructed each time, the function should either document that it modifies its parameters or not modify them. It is easier not to modify them. Also existing code does not have this issue because we do not sort validating webhooks. They are called in parallel so the order does not matter.",
        "createdAt" : "2017-11-08T23:03:54Z",
        "updatedAt" : "2017-11-09T23:34:03Z",
        "lastEditedBy" : "7f521a0d-2137-47c7-a390-3b4bdcffe306",
        "tags" : [
        ]
      },
      {
        "id" : "8bbfbadc-0f59-4522-aedd-1870a672d3c2",
        "parentId" : "60db7619-5fbd-44b3-be57-25439ee0f610",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "ah, thanks for the explanation.",
        "createdAt" : "2017-11-09T21:50:07Z",
        "updatedAt" : "2017-11-09T23:34:03Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      }
    ],
    "commit" : "4568e0530c53df81d1bbd5e700daca041a1d8439",
    "line" : 51,
    "diffHunk" : "@@ -1,1 +49,53 @@\t\t\treturn nil, err\n\t\t}\n\t\treturn mergeMutatingWebhookConfigurations(list), nil\n\t}\n"
  },
  {
    "id" : "0c82a220-c17c-492c-89d2-ff14233a24c7",
    "prId" : 55282,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/55282#pullrequestreview-75691083",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "eacd062e-e4d8-487a-b4a0-1e9b1114d693",
        "parentId" : null,
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : ":+1:",
        "createdAt" : "2017-11-10T08:43:02Z",
        "updatedAt" : "2017-11-10T08:43:02Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      }
    ],
    "commit" : "4568e0530c53df81d1bbd5e700daca041a1d8439",
    "line" : 79,
    "diffHunk" : "@@ -1,1 +77,81 @@\tlist *v1alpha1.MutatingWebhookConfigurationList,\n) *v1alpha1.MutatingWebhookConfiguration {\n\tconfigurations := append([]v1alpha1.MutatingWebhookConfiguration{}, list.Items...)\n\tvar ret v1alpha1.MutatingWebhookConfiguration\n\t// The internal order of webhooks for each configuration is provided by the user"
  }
]
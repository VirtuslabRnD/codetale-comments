[
  {
    "id" : "6ac6d171-5f2e-4338-88b8-9aa71d1560a2",
    "prId" : 79495,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/79495#pullrequestreview-258963592",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3e11b021-9f95-4d1d-b67a-fe27050788d2",
        "parentId" : null,
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "add a comment why we do this hack. Otherwise lgtm.",
        "createdAt" : "2019-07-08T15:00:15Z",
        "updatedAt" : "2019-07-08T15:09:21Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      }
    ],
    "commit" : "4346919ed3fa500a846295e2763329ed19ec7843",
    "line" : 16,
    "diffHunk" : "@@ -1,1 +42,46 @@\t// In 1.13, only no-op custom resource conversion is possible, so setting the group version is sufficient to \"convert\".\n\t// In 1.14+, this was fixed correctly in http://issue.k8s.io/74154 by plumbing the actual object converter here.\n\tif runtime.IsNotRegisteredError(err) {\n\t\tif u, ok := obj.(*unstructured.Unstructured); ok {\n\t\t\tu.GetObjectKind().SetGroupVersionKind(gvk)"
  },
  {
    "id" : "e2fcec40-2e4b-4815-9083-229b7f825a2c",
    "prId" : 78135,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/78135#pullrequestreview-242353264",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9dab92ac-b103-409e-8b3c-502ddd5885dd",
        "parentId" : null,
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "this case feels asymmetric: if `attr.VersionedKind == gvk` we don't write back to `GetObject()´. But if we convert, we do. Why don't we keep converting from versioned object to versioned object, keeping attr dirty?",
        "createdAt" : "2019-05-27T14:14:42Z",
        "updatedAt" : "2019-05-28T18:30:39Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      },
      {
        "id" : "aba16983-21a5-4304-af4e-14f0d8335a2d",
        "parentId" : "9dab92ac-b103-409e-8b3c-502ddd5885dd",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "> this case feels asymmetric: if attr.VersionedKind == gvk we don't write back to `GetObject()´. But if we convert, we do.\r\n\r\nThe goal of this method is to provide a VersionedObject in the requested version as cheaply as possible. If we already have the requested version, we no-op.\r\n\r\n> Why don't we keep converting from versioned object to versioned object, keeping attr dirty?\r\n\r\nIf we don't have the requested version, we *have* to convert via `attr.GetObject()` because that's our internal version (we can't convert directly from extension/v1beta1 Deployment to apps/v1 Deployment). As long as we're updating attr.GetObject() to match VersionedObject anyway, we might as well clear the dirty flag to avoid needing to redo the same conversion at the end of the mutating Dispatch() method\r\n\r\nI'll update the docs on the fields and this method to try to clarify that",
        "createdAt" : "2019-05-27T14:44:45Z",
        "updatedAt" : "2019-05-28T18:30:39Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "4a3c6df1-7d57-4426-9ca0-b4606c86fd08",
        "parentId" : "9dab92ac-b103-409e-8b3c-502ddd5885dd",
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "right. Am too much in the CRD world without internal versions. Nvmd.",
        "createdAt" : "2019-05-27T17:25:01Z",
        "updatedAt" : "2019-05-28T18:30:39Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      }
    ],
    "commit" : "8c194ea615459ddab09938528eca3a3a228da8a3",
    "line" : 53,
    "diffHunk" : "@@ -1,1 +91,95 @@\t\t// convert the existing versioned object to internal\n\t\tif attr.Dirty {\n\t\t\terr := o.GetObjectConvertor().Convert(attr.VersionedObject, attr.Attributes.GetObject(), nil)\n\t\t\tif err != nil {\n\t\t\t\treturn err"
  }
]
[
  {
    "id" : "7348b740-9ee5-445e-afd3-9a19dbc5e75d",
    "prId" : 65288,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/65288#pullrequestreview-130745799",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fa66f55d-a03d-4c51-9972-d34cd1e50de9",
        "parentId" : null,
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "nit: no need for the func, pass isWatchCachePrimed directly (eta conversion...).",
        "createdAt" : "2018-06-21T07:12:57Z",
        "updatedAt" : "2018-06-22T18:20:24Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      },
      {
        "id" : "650697d5-91e7-4a7e-9cfa-78da97c53db3",
        "parentId" : "fa66f55d-a03d-4c51-9972-d34cd1e50de9",
        "authorId" : "7f521a0d-2137-47c7-a390-3b4bdcffe306",
        "body" : "How do I pass crd  and dynamicClientSet to it?",
        "createdAt" : "2018-06-21T09:41:08Z",
        "updatedAt" : "2018-06-22T18:20:24Z",
        "lastEditedBy" : "7f521a0d-2137-47c7-a390-3b4bdcffe306",
        "tags" : [
        ]
      },
      {
        "id" : "c4dda799-3708-43ab-9b86-5d946a92a4dd",
        "parentId" : "fa66f55d-a03d-4c51-9972-d34cd1e50de9",
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "nvmd. Misread.",
        "createdAt" : "2018-06-21T09:56:37Z",
        "updatedAt" : "2018-06-22T18:20:24Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      }
    ],
    "commit" : "335d42165f2c889a1f232e318c1567a518206b79",
    "line" : 12,
    "diffHunk" : "@@ -1,1 +260,264 @@\t// before like the created RV could be too old to watch.\n\terr = wait.PollImmediate(500*time.Millisecond, 30*time.Second, func() (bool, error) {\n\t\treturn isWatchCachePrimed(crd, dynamicClientSet)\n\t})\n\tif err != nil {"
  },
  {
    "id" : "2107bb77-d6a2-4354-b57c-348b57f96020",
    "prId" : 65288,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/65288#pullrequestreview-130744745",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "954343c9-1a80-4007-97d8-7761137a1ef7",
        "parentId" : null,
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "what I still miss is an explaination (comment? reference to axiom) that a `rv=createdInstance.GetResourceVersion()` will drain the watch cache for a following `rv=0` watch. All this here is based on that behaviour. And it is far from obvious.",
        "createdAt" : "2018-06-21T07:16:56Z",
        "updatedAt" : "2018-06-22T18:20:24Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      },
      {
        "id" : "66797783-4944-4893-b959-35a93d23fb98",
        "parentId" : "954343c9-1a80-4007-97d8-7761137a1ef7",
        "authorId" : "7f521a0d-2137-47c7-a390-3b4bdcffe306",
        "body" : "Will add a comment. I couldn't find an official document describing the behaviour. I looked at the code and tested it.",
        "createdAt" : "2018-06-21T09:42:29Z",
        "updatedAt" : "2018-06-22T18:20:24Z",
        "lastEditedBy" : "7f521a0d-2137-47c7-a390-3b4bdcffe306",
        "tags" : [
        ]
      },
      {
        "id" : "95a777e8-2649-42d3-a2d3-6a6e826705f5",
        "parentId" : "954343c9-1a80-4007-97d8-7761137a1ef7",
        "authorId" : "7f521a0d-2137-47c7-a390-3b4bdcffe306",
        "body" : "~~~Also getResourceVersion does not drain anything. Abwatch cache has a items that has not been sent to any watch. When a watch is created with rc=0, it will get all of those. If those events drained by being sent to another watch (or skipped because the watch is requesting a more recent rc and actually getting something), they will not be sent to watch with rc=0 in future.~~~ next comment is more clear. ignore this one.",
        "createdAt" : "2018-06-21T09:47:01Z",
        "updatedAt" : "2018-06-22T18:20:24Z",
        "lastEditedBy" : "7f521a0d-2137-47c7-a390-3b4bdcffe306",
        "tags" : [
        ]
      },
      {
        "id" : "d397800c-23ed-419c-9a3b-7f65db209bb6",
        "parentId" : "954343c9-1a80-4007-97d8-7761137a1ef7",
        "authorId" : "7f521a0d-2137-47c7-a390-3b4bdcffe306",
        "body" : "Basically when you get an event from a watch channel by any client at t0, and another client creates a watch at t1 with rc=0, it may only get events after the event sent at t0. I said may because it is a circular buffer and there is no guarantee that all events after t0 will be delivered. Watch uses one cache per resource/kind/version so I guess it was tricky not to do that (some other concurrent watches may miss events if we drain cache on new watches with rc=0. Not impossible to fix but maybe tricky). Fixing that behaviour is not in the scope of this PR and I'm not sure it ever get fixed. A watch with rc not zero is predictable and recommend if we want predictibility.  ",
        "createdAt" : "2018-06-21T09:54:06Z",
        "updatedAt" : "2018-06-22T18:20:24Z",
        "lastEditedBy" : "7f521a0d-2137-47c7-a390-3b4bdcffe306",
        "tags" : [
        ]
      }
    ],
    "commit" : "335d42165f2c889a1f232e318c1567a518206b79",
    "line" : 89,
    "diffHunk" : "@@ -1,1 +332,336 @@\n\t\tselect {\n\t\tcase watchEvent := <-noxuWatch.ResultChan():\n\t\t\tif watch.Error == watchEvent.Type {\n\t\t\t\treturn false, nil"
  },
  {
    "id" : "39fd09b1-7365-4286-b01c-28b606f028f1",
    "prId" : 64796,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/64796#pullrequestreview-127554342",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "58d9751b-3226-46e3-afd1-4e0fbd8779d1",
        "parentId" : null,
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "isn't there a chance that we multiple delete events if this func returns false once? I would prefer having another wait loop here, waiting until the watch returns no error anymore.",
        "createdAt" : "2018-06-11T07:56:14Z",
        "updatedAt" : "2018-06-14T23:15:24Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      },
      {
        "id" : "d5bc3dd2-563c-4336-bd72-8c90714c4de7",
        "parentId" : "58d9751b-3226-46e3-afd1-4e0fbd8779d1",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "> I would prefer having another wait loop here, waiting until the watch returns no error anymore\r\n\r\nif the watch cache initializes after `createdInstance.GetResourceVersion()`, it will never be able to establish a watch at that version (it will always report 'too old'). in that case, we have to go out and come back in again.",
        "createdAt" : "2018-06-11T12:36:03Z",
        "updatedAt" : "2018-06-14T23:15:24Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "bdf4aadf-0e53-49db-a731-56a10e952439",
        "parentId" : "58d9751b-3226-46e3-afd1-4e0fbd8779d1",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "> isn't there a chance that we multiple delete events if this func returns false once?\r\n\r\nwe always start from the resourceVersion of our created instance, which avoids delete events from any previous iterations. I'd take this as-is to clear up the flakes",
        "createdAt" : "2018-06-11T12:37:54Z",
        "updatedAt" : "2018-06-14T23:15:24Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "5bb39c78-3ac0-42b2-8a35-576dcdc2d5eb",
        "parentId" : "58d9751b-3226-46e3-afd1-4e0fbd8779d1",
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "> we always start from the resourceVersion of our created instance\r\n\r\nmakes sense.",
        "createdAt" : "2018-06-11T12:54:18Z",
        "updatedAt" : "2018-06-14T23:15:24Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      }
    ],
    "commit" : "602ddef1587c5424a878b5977acb769f0042efc5",
    "line" : 150,
    "diffHunk" : "@@ -1,1 +310,314 @@\t}\n\n\tnoxuWatch, err := resourceClient.Watch(metav1.ListOptions{ResourceVersion: createdInstance.GetResourceVersion()})\n\tif err != nil {\n\t\treturn false, err"
  },
  {
    "id" : "36731860-ee51-45be-a2da-0f703326105d",
    "prId" : 63830,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/63830#pullrequestreview-122276615",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c26f9902-2b9a-40a7-81e8-51cf91512683",
        "parentId" : null,
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "reuse the old func (and extend it with the version string).",
        "createdAt" : "2018-05-22T08:24:27Z",
        "updatedAt" : "2018-05-22T20:54:46Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      },
      {
        "id" : "266ead73-3466-43c7-857c-cc7cf3fe773b",
        "parentId" : "c26f9902-2b9a-40a7-81e8-51cf91512683",
        "authorId" : "7f521a0d-2137-47c7-a390-3b4bdcffe306",
        "body" : "Added to follow up issue.",
        "createdAt" : "2018-05-22T17:37:46Z",
        "updatedAt" : "2018-05-22T20:54:46Z",
        "lastEditedBy" : "7f521a0d-2137-47c7-a390-3b4bdcffe306",
        "tags" : [
        ]
      }
    ],
    "commit" : "c25514a1ee513e1a7ad1c3c572ab9dd32a395d28",
    "line" : 40,
    "diffHunk" : "@@ -1,1 +137,141 @@}\n\nfunc NewVersionedNoxuInstance(namespace, name, version string) *unstructured.Unstructured {\n\treturn &unstructured.Unstructured{\n\t\tObject: map[string]interface{}{"
  },
  {
    "id" : "1fd2fc1f-4778-43d8-a166-fa5393b360e3",
    "prId" : 51873,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/51873#pullrequestreview-60301948",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ad3790fc-5930-49b8-a3d1-34ff6ecb632f",
        "parentId" : null,
        "authorId" : "5a764df5-fdf3-4b03-8549-b0e2d9c30dad",
        "body" : "why this change part of this PR?",
        "createdAt" : "2017-09-03T17:15:01Z",
        "updatedAt" : "2017-09-03T17:15:50Z",
        "lastEditedBy" : "5a764df5-fdf3-4b03-8549-b0e2d9c30dad",
        "tags" : [
        ]
      },
      {
        "id" : "c05c0fe7-ed46-4e99-9fb0-b9371b280b87",
        "parentId" : "ad3790fc-5930-49b8-a3d1-34ff6ecb632f",
        "authorId" : "bfe6ebf1-cfa7-4758-abb1-9960fa09b194",
        "body" : "otherwise arm 32 bit fails due to that the constant is larger than int32 (default on arm) can handle",
        "createdAt" : "2017-09-03T18:19:42Z",
        "updatedAt" : "2017-09-03T18:19:42Z",
        "lastEditedBy" : "bfe6ebf1-cfa7-4758-abb1-9960fa09b194",
        "tags" : [
        ]
      },
      {
        "id" : "fccdfc57-4869-4a1d-8981-cf7b1d2334b2",
        "parentId" : "ad3790fc-5930-49b8-a3d1-34ff6ecb632f",
        "authorId" : "5a764df5-fdf3-4b03-8549-b0e2d9c30dad",
        "body" : "okay",
        "createdAt" : "2017-09-03T18:22:30Z",
        "updatedAt" : "2017-09-03T18:22:31Z",
        "lastEditedBy" : "5a764df5-fdf3-4b03-8549-b0e2d9c30dad",
        "tags" : [
        ]
      }
    ],
    "commit" : "64be85e9dee08c133375704d66820cb9945acaf6",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +34,38 @@)\n\nconst (\n\tnoxuInstanceNum int64 = 9223372036854775807\n)"
  },
  {
    "id" : "b7e19c8a-e379-43d7-bbc6-58fb914ac9b7",
    "prId" : 47263,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/47263#pullrequestreview-52772876",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "93203351-9c24-4a06-b252-9166e4e81b2f",
        "parentId" : null,
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "thanks :)",
        "createdAt" : "2017-07-27T20:14:56Z",
        "updatedAt" : "2017-08-29T16:05:36Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      }
    ],
    "commit" : "6ba1523a8e36c3121a9e08bfac7b4f342bb8ccb3",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +214,218 @@\t}\n\n\tinstanceName := \"setup-instance\"\n\tinstance := &unstructured.Unstructured{\n\t\tObject: map[string]interface{}{"
  }
]
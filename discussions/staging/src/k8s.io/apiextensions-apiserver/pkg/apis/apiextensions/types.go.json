[
  {
    "id" : "480b2be3-beae-4691-8f20-b3bb8f0d3a5c",
    "prId" : 99661,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/99661#pullrequestreview-606860787",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "940ecf9c-3056-4fa1-8470-12d4260a59ef",
        "parentId" : null,
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "Does this change belong in this PR?",
        "createdAt" : "2021-03-08T20:08:38Z",
        "updatedAt" : "2021-03-10T01:02:29Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "a71d92fc-8f4d-437d-8041-474530d7faeb",
        "parentId" : "940ecf9c-3056-4fa1-8470-12d4260a59ef",
        "authorId" : "f4ac3f8f-7ffb-4966-8247-0d4dc4a5bca1",
        "body" : "The way that we test status wiping is by applying a change with a new dummy condition in the .status.conditions.\r\n\r\nFor CRDs, the CRD controller updates the conditions as part of the test after the initial create is called but before the status updating Apply call is made. Without the change, the conditions list is atomic and so the apply that adds a new condition will always fail with a conflict. \r\n\r\nThere are no other fields on a CRD status that the apply can update instead, and it is incorrect anyways for the conditions to be atomic, so we changed it here. After we get approval, when we go to squash commits, it would make sense to have this as a separate commit. ",
        "createdAt" : "2021-03-08T20:20:16Z",
        "updatedAt" : "2021-03-10T01:02:29Z",
        "lastEditedBy" : "f4ac3f8f-7ffb-4966-8247-0d4dc4a5bca1",
        "tags" : [
        ]
      },
      {
        "id" : "30100b3b-8485-4ee6-b7bf-99f9841e2569",
        "parentId" : "940ecf9c-3056-4fa1-8470-12d4260a59ef",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "I agree that it's correct it's just surprising to combine it with this change. Does this have any compatibility implications?",
        "createdAt" : "2021-03-09T01:07:46Z",
        "updatedAt" : "2021-03-10T01:02:29Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "c1e6754e-1dd1-4a5c-9afc-08ae26186fd8",
        "parentId" : "940ecf9c-3056-4fa1-8470-12d4260a59ef",
        "authorId" : "a139439a-9f9e-4518-b4f3-9c602d956c57",
        "body" : "Joe has worked specifically on making this possible.",
        "createdAt" : "2021-03-09T01:40:42Z",
        "updatedAt" : "2021-03-10T01:02:29Z",
        "lastEditedBy" : "a139439a-9f9e-4518-b4f3-9c602d956c57",
        "tags" : [
        ]
      }
    ],
    "commit" : "a1fac8cbd9289d95db4831a83239292ed56ce59d",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +328,332 @@\t// Conditions indicate state for particular aspects of a CustomResourceDefinition\n\t// +listType=map\n\t// +listMapKey=type\n\tConditions []CustomResourceDefinitionCondition\n"
  },
  {
    "id" : "a9001fdc-8d83-405c-ac3a-8fbaa767d594",
    "prId" : 92329,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/92329#pullrequestreview-440998969",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4a5683ba-8aa2-4926-a1f5-038365047616",
        "parentId" : null,
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "Why don't we simply require someone to write their own DeprecationWarning and avoid having a bool?  I haven't read all the way down, but I doubt we have a very good stock message on these since versions don't follow kube versions.",
        "createdAt" : "2020-07-01T15:53:10Z",
        "updatedAt" : "2020-07-01T15:53:11Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      },
      {
        "id" : "8974d0cf-d449-478b-9de8-5ab12865316c",
        "parentId" : "4a5683ba-8aa2-4926-a1f5-038365047616",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "The normal case of \"X is deprecated\" or \"X is deprecated; use Y instead\" is easy for us to automatically construct, and seemed valuable for consistency with built-in API deprecation warnings in the absence of specific additional information about removal timeframes.\r\n\r\nCRD authors indicating a version is deprecated without knowledge of the cadence at which consumers plan to deploy the revision of the CRD which stops serving the deprecated version would not be able to provide a much better message than the one we're generating by default.",
        "createdAt" : "2020-07-01T15:54:52Z",
        "updatedAt" : "2020-07-01T16:18:49Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "30e39c71e2e5c5d6bb3fd64c71571a04beef5368",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +181,185 @@\t// When set to true, API requests to this version receive a warning header in the server response.\n\t// Defaults to false.\n\tDeprecated bool\n\t// deprecationWarning overrides the default warning returned to API clients.\n\t// May only be set when `deprecated` is true."
  },
  {
    "id" : "c512ef1f-3b6a-49a5-b506-bb660d25a237",
    "prId" : 70211,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/70211#pullrequestreview-168402054",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e56c8835-b4e6-401d-b456-730aac03a220",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "for all the alpha, feature-gated fields, add both of those details to the field documentation. For example:\r\n\r\n```\r\n// This field is alpha-level and is only honored by servers that enable the XYZ feature.\r\n```",
        "createdAt" : "2018-10-25T14:09:51Z",
        "updatedAt" : "2018-11-07T17:39:27Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "5b545bbc13095f9708cf0d352451137fe841157f",
    "line" : 34,
    "diffHunk" : "@@ -1,1 +163,167 @@\t// Per-version schemas must not all be set to identical values (top-level validation schema should be used instead)\n\t// This field is alpha-level and is only honored by servers that enable the CustomResourceWebhookConversion feature.\n\t// +optional\n\tSchema *CustomResourceValidation\n\t// Subresources describes the subresources for CustomResource"
  },
  {
    "id" : "5df968fd-1e75-4d15-a719-3ef5d2b494b2",
    "prId" : 70211,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/70211#pullrequestreview-172613090",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4d053d4e-7cae-4ddf-a778-b8478db50827",
        "parentId" : null,
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "The \"Defaults to a created-at column.\" is not really correct, is it? It only defaults if at least one version has additionalPrinterColumns. Otherwise, the global field is defaulted.",
        "createdAt" : "2018-11-06T09:52:16Z",
        "updatedAt" : "2018-11-07T17:39:27Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      },
      {
        "id" : "200fc4db-1cf2-49c9-8cd6-7043907fa110",
        "parentId" : "4d053d4e-7cae-4ddf-a778-b8478db50827",
        "authorId" : "695b6860-569c-4e63-a215-7342e2279a94",
        "body" : "> It only defaults if at least one version has additionalPrinterColumns. Otherwise, the global field is defaulted\r\n\r\nThat was the previous approach. @mbohlool [pointed out](https://github.com/kubernetes/kubernetes/pull/70211#discussion_r230518621) that in this way, we have the problem that if a user first created a CRD without specifying global/per-version columns, and then tries to patch per-version columns, the patch request will fail the mutual-exclusive validation.\r\n\r\nWe decided to drop the validation and only do logical default to improve the user experience for new CRDs. For CRDs created prior to 1.13, we cannot avoid the issue so we document in the API and in release note. The change is in 6th commit.",
        "createdAt" : "2018-11-06T18:07:51Z",
        "updatedAt" : "2018-11-07T17:39:27Z",
        "lastEditedBy" : "695b6860-569c-4e63-a215-7342e2279a94",
        "tags" : [
        ]
      },
      {
        "id" : "3b394ec9-a30a-4590-b1da-f4a39f631bd6",
        "parentId" : "4d053d4e-7cae-4ddf-a778-b8478db50827",
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "Found it. Is it written in the release notes? Is it a breaking API change to change (remove) defaults? Strictly speaking I think it is. /cc @liggitt ",
        "createdAt" : "2018-11-07T09:49:10Z",
        "updatedAt" : "2018-11-07T17:39:27Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      },
      {
        "id" : "7305ae95-810f-4d8f-bb6b-5a5419764ebc",
        "parentId" : "4d053d4e-7cae-4ddf-a778-b8478db50827",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "> Is it a breaking API change to change (remove) defaults? Strictly speaking I think it is.\r\n\r\nMaking the existing defaulted field mutually exclusive with the per-version fields (which is required if we want to only have per-version fields in v1) unavoidably requires changing the defaulting behavior.\r\n\r\nI can't think of any scenarios this change causes problems with:\r\n* existing persisted CRDs retain current behavior (with respect to what columns are returned by server-side printing)\r\n* existing CRD manifests retain current behavior when submitted to a new API server (with respect to what columns are returned by server-side printing)\r\n* skewed HA API servers across a 1.12/1.13 boundary would serve a CRD without this field identically\r\n* the field is marked as optional in the openapi schema, so generated clients will tolerate it being unset\r\n\r\nI'm comfortable proceeding as is",
        "createdAt" : "2018-11-07T17:41:00Z",
        "updatedAt" : "2018-11-07T17:46:10Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "5b545bbc13095f9708cf0d352451137fe841157f",
    "line" : 46,
    "diffHunk" : "@@ -1,1 +175,179 @@\t// Per-version columns must not all be set to identical values (top-level columns should be used instead)\n\t// This field is alpha-level and is only honored by servers that enable the CustomResourceWebhookConversion feature.\n\t// NOTE: CRDs created prior to 1.13 populated the top-level additionalPrinterColumns field by default. To apply an\n\t// update that changes to per-version additionalPrinterColumns, the top-level additionalPrinterColumns field must\n\t// be explicitly set to null"
  },
  {
    "id" : "6d082fb3-14ae-4897-a41d-f48cb7026519",
    "prId" : 67795,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/67795#pullrequestreview-169461581",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "88851445-e3c3-49fe-b512-ed7ecd3f8c61",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "how do we know what version of a ConversionReview object to send to the webhook? if we make it implicit now, and send `apiextensions.k8s.io/v1beta1` ConversionReview objects now, what is our plan for transitioning to sending `apiextensions.k8s.io/v1` ConversionReview objects in the future?",
        "createdAt" : "2018-10-27T21:26:27Z",
        "updatedAt" : "2018-10-31T21:47:29Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "79912609-98ec-4e87-9952-ecdc16d37843",
        "parentId" : "88851445-e3c3-49fe-b512-ed7ecd3f8c61",
        "authorId" : "7f521a0d-2137-47c7-a390-3b4bdcffe306",
        "body" : "We need a mechanism to determine what version webhook host supports in case of multiple versions. This was also discussed for Admission/Mutating webhooks. These are the options (that all of them are backward compatible):\r\n\r\n- Active negotiation: API server sends a HEAD request with some headers and expect supported versions in response headers.\r\n- Upgrade response: Start with v1beta1 and let the host send an upgrade response to request for other versions (very similar to first one, except no HEAD request in case that has some backward compatibility issue)\r\n- Config field: Adding a field to webhookClientConfig to specify the version the host expects.\r\n\r\nIn all case, I don't think we need to do anything here before we add a new version (e.g. `apiextensions.k8s.io/v1`)",
        "createdAt" : "2018-10-29T18:32:11Z",
        "updatedAt" : "2018-10-31T21:47:29Z",
        "lastEditedBy" : "7f521a0d-2137-47c7-a390-3b4bdcffe306",
        "tags" : [
        ]
      },
      {
        "id" : "c80199ca-5ce1-4cd2-ba6b-c7439bbf482d",
        "parentId" : "88851445-e3c3-49fe-b512-ed7ecd3f8c61",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "> These are the options (that all of them are backward compatible):\r\n> \r\n> * Active negotiation: API server sends a HEAD request with some headers and expect supported versions in response headers.\r\n> * Upgrade response: Start with v1beta1 and let the host send an upgrade response to request for other versions (very similar to first one, except no HEAD request in case that has some backward compatibility issue)\r\n> * Config field: Adding a field to webhookClientConfig to specify the version the host expects.\r\n> \r\n> In all case, I don't think we need to do anything here before we add a new version (e.g. `apiextensions.k8s.io/v1`)\r\n\r\nI agree we can decide when we introduce v1, but wanted to mention the issue here for consideration. Of the three options, I have a strong preference for the last, with the version defaulting to the version used to create the CRD (creating a v1beta1 CRD defaults to sending v1beta1 to the conversion webhook, creating a v1 CRD defaults to sending v1 to the webhook).\r\n\r\n* Support for HEAD requests is not consistent in all proxies/frameworks, and we'd be inventing our own query/response format for supported versions\r\n* Blindly sending versions, either expecting recognizable errors for unsupported versions, or side-channel upgrade indicators in the response also means inventing new serialized negotiation formats, and either pins the default version to v1beta1 or trusts pre-existing webhooks to do strict version checking on the incoming conversion review",
        "createdAt" : "2018-10-29T18:47:34Z",
        "updatedAt" : "2018-10-31T21:47:29Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "e27096cdb468ace668f4f333e9acb46daf33df3f",
    "line" : 33,
    "diffHunk" : "@@ -1,1 +74,78 @@\tStrategy ConversionStrategyType\n\n\t// `webhookClientConfig` is the instructions for how to call the webhook if strategy is `Webhook`.\n\tWebhookClientConfig *WebhookClientConfig\n}"
  },
  {
    "id" : "fc185cc2-270e-4063-b5d8-3d86c7a2f720",
    "prId" : 64215,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/64215#pullrequestreview-122762968",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1e58fc86-57fe-4c7e-b9d4-e22daa3084e8",
        "parentId" : null,
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "maybe simpler: \"where GA is a version without an alpha or beta suffix\". But I am not a native speaker.",
        "createdAt" : "2018-05-23T18:25:24Z",
        "updatedAt" : "2018-05-23T18:25:25Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      },
      {
        "id" : "c4cfe881-26c2-4825-a205-9e2eee3b404b",
        "parentId" : "1e58fc86-57fe-4c7e-b9d4-e22daa3084e8",
        "authorId" : "7f521a0d-2137-47c7-a390-3b4bdcffe306",
        "body" : "I don't have strong feeling here too. If you are OK, I will merge this one for now as Jordan is OK with it too.",
        "createdAt" : "2018-05-23T20:54:00Z",
        "updatedAt" : "2018-05-23T20:54:00Z",
        "lastEditedBy" : "7f521a0d-2137-47c7-a390-3b4bdcffe306",
        "tags" : [
        ]
      }
    ],
    "commit" : "e73475311ce50649a7fff9698ce24890e705a731",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +46,50 @@\t// lexicographically. \"Kube-like\" versions start with a \"v\", then are followed by a number (the major version),\n\t// then optionally the string \"alpha\" or \"beta\" and another number (the minor version). These are sorted first\n\t// by GA > beta > alpha (where GA is a version with no suffix such as beta or alpha), and then by comparing\n\t// major version, then minor version. An example sorted list of versions:\n\t// v10, v2, v1, v11beta2, v10beta3, v3beta1, v12alpha1, v11alpha2, foo1, foo10."
  },
  {
    "id" : "e3437c8f-fb4d-4a53-b0af-bbded647b6ed",
    "prId" : 63830,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/63830#pullrequestreview-120095056",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "61bae2eb-8ed8-4cac-bf8c-188978ba2222",
        "parentId" : null,
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "commented before: why do we keep this field in the internal types? Let's use conversion to recreate it it from the `Versions` slice",
        "createdAt" : "2018-05-15T05:36:34Z",
        "updatedAt" : "2018-05-22T20:54:46Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      },
      {
        "id" : "09eeca0f-544c-4618-9761-70aaaa30ce67",
        "parentId" : "61bae2eb-8ed8-4cac-bf8c-188978ba2222",
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "We discussed offline: this is needed because validation is done on internal types. Without Version here we would have to validate in conversion that it matches the first item in Versions.",
        "createdAt" : "2018-05-15T06:03:24Z",
        "updatedAt" : "2018-05-22T20:54:46Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      }
    ],
    "commit" : "c25514a1ee513e1a7ad1c3c572ab9dd32a395d28",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +28,32 @@\t// Should be always first item in Versions field if provided.\n\t// Optional, but at least one of Version or Versions must be set.\n\t// Deprecated: Please use `Versions`.\n\tVersion string\n\t// Names are the names used to describe this custom resource"
  },
  {
    "id" : "16fabf1b-d490-4a88-bc16-b4fff573a055",
    "prId" : 63830,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/63830#pullrequestreview-122277320",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ccf50ec3-bc1a-4240-867d-348f935471ce",
        "parentId" : null,
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "GA is not defined",
        "createdAt" : "2018-05-22T08:17:54Z",
        "updatedAt" : "2018-05-22T20:54:46Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      },
      {
        "id" : "5a163f62-715e-470a-950d-64b5a6ce1074",
        "parentId" : "ccf50ec3-bc1a-4240-867d-348f935471ce",
        "authorId" : "7f521a0d-2137-47c7-a390-3b4bdcffe306",
        "body" : "Added to follow up",
        "createdAt" : "2018-05-22T17:39:39Z",
        "updatedAt" : "2018-05-22T20:54:46Z",
        "lastEditedBy" : "7f521a0d-2137-47c7-a390-3b4bdcffe306",
        "tags" : [
        ]
      }
    ],
    "commit" : "c25514a1ee513e1a7ad1c3c572ab9dd32a395d28",
    "line" : 22,
    "diffHunk" : "@@ -1,1 +46,50 @@\t// lexicographically. \"Kube-like\" versions start with a \"v\", then are followed by a number (the major version),\n\t// then optionally the string \"alpha\" or \"beta\" and another number (the minor version). These are sorted first\n\t// by GA > beta > alpha, and then by comparing major version, then minor version. An example sorted list of\n\t// versions: v10, v2, v1, v11beta2, v10beta3, v3beta1, v12alpha1, v11alpha2, foo1, foo10.\n\tVersions []CustomResourceDefinitionVersion"
  },
  {
    "id" : "58eaabb6-55db-43f7-8f31-8cd36e31ee96",
    "prId" : 47263,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/47263#pullrequestreview-59222466",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1f0f2096-2bc6-4241-8a4d-21037f30e9c7",
        "parentId" : null,
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "How big are these normally?  What max size limit is imposed (our 1m value limit)?",
        "createdAt" : "2017-08-23T17:04:12Z",
        "updatedAt" : "2017-08-29T16:05:36Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "f8616198-6530-46e5-98ee-bf1c840b4584",
        "parentId" : "1f0f2096-2bc6-4241-8a4d-21037f30e9c7",
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "Per CRD? more like 10-100 KB. It's per type.",
        "createdAt" : "2017-08-23T17:11:10Z",
        "updatedAt" : "2017-08-29T16:05:36Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      },
      {
        "id" : "7ed31891-da10-49ca-a466-53236561c39a",
        "parentId" : "1f0f2096-2bc6-4241-8a4d-21037f30e9c7",
        "authorId" : "7f521a0d-2137-47c7-a390-3b4bdcffe306",
        "body" : "I think @lavalamp [suggested](https://github.com/kubernetes/kubernetes/pull/50625#issuecomment-323874407) we change this to a RawExtension type instead of representing Schema in our struct. Does that make things easier? (e.g. does problem of protobuf @smarterclayton pointed out will fade away if we do that) I think representing this in our API caused some trouble for us and we don't really benefit from it. We can accept a RawExtension and deserialize it to `JSONSchemaProps` at our backend code. WDYT?",
        "createdAt" : "2017-08-23T21:11:29Z",
        "updatedAt" : "2017-08-29T16:05:36Z",
        "lastEditedBy" : "7f521a0d-2137-47c7-a390-3b4bdcffe306",
        "tags" : [
        ]
      },
      {
        "id" : "491f72c3-780d-4467-a4c2-426e87d14031",
        "parentId" : "1f0f2096-2bc6-4241-8a4d-21037f30e9c7",
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "It doesn't make it easier.",
        "createdAt" : "2017-08-24T13:25:53Z",
        "updatedAt" : "2017-08-29T16:05:36Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      },
      {
        "id" : "223fe50e-03e1-4618-baf5-2a0af67138c1",
        "parentId" : "1f0f2096-2bc6-4241-8a4d-21037f30e9c7",
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "The only left issue is protobuf. And we have two working approaches. Just a little patience.",
        "createdAt" : "2017-08-24T13:28:12Z",
        "updatedAt" : "2017-08-29T16:05:36Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      },
      {
        "id" : "80b32ced-0283-4f6a-ad71-8f803fed8524",
        "parentId" : "1f0f2096-2bc6-4241-8a4d-21037f30e9c7",
        "authorId" : "7f521a0d-2137-47c7-a390-3b4bdcffe306",
        "body" : "I know we can make it work with defining our own type and it is hard to throw away code/reviews. But other than cost of coding, there would be cost of maintenance and bugs etc. Adding it as RawExtension would only add an unmarshall call to this code and get rid of many types/conversions/issues (solved and unsolved). I personally vote for simpler code in this case (and in any case). We don't need to know the content of validation schema and we won't change it (unless we change the whole version of it). That is an standard spec.",
        "createdAt" : "2017-08-24T17:43:15Z",
        "updatedAt" : "2017-08-29T16:05:36Z",
        "lastEditedBy" : "7f521a0d-2137-47c7-a390-3b4bdcffe306",
        "tags" : [
        ]
      },
      {
        "id" : "f9cc1240-a541-4d9d-9018-b50f43f7cfb8",
        "parentId" : "1f0f2096-2bc6-4241-8a4d-21037f30e9c7",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "If we don't actually use the schema and pass it through to other libraries, then do we really want to bless it by writing it up in our API language? The only reason I see to do that is to ensure backwards compatibility, and I'm not sure if that's persuasive.",
        "createdAt" : "2017-08-24T21:16:02Z",
        "updatedAt" : "2017-08-29T16:05:36Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "5ba37887-7087-4bef-a734-adbdca7acfc9",
        "parentId" : "1f0f2096-2bc6-4241-8a4d-21037f30e9c7",
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "We cannot rely on an external library to basically do our validation and to follow our api guidelines. So yes, it's about compatibility. We were discussing this in the proposal up and down and voted for this solution for essentially the reason of having control. Still I don't get the argument. The complexity is not big, look at the validations. It's completely straight forward. What is left is a proto marshaller.",
        "createdAt" : "2017-08-25T06:23:09Z",
        "updatedAt" : "2017-08-29T16:05:36Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      },
      {
        "id" : "98a5ac41-64c1-4c95-abc7-cb3473516dac",
        "parentId" : "1f0f2096-2bc6-4241-8a4d-21037f30e9c7",
        "authorId" : "7f521a0d-2137-47c7-a390-3b4bdcffe306",
        "body" : "What is discussed before was possibility of including the external type in our API (that I agree not a good idea) but the suggestion here is to use rawExtension. What we unmarshall it to is totally an implementation detail not a design one. So two things here:\r\n\r\n- What exposed in our API! Can be RawExtension with a comment that this is standard Vxxx. Or can be our defined type (that may be slightly different than standard)\r\n- How we implement it internally. With RawExtension we can unmarshall it to an internal type or go-openapi type. It is not user faced. With our defined type exposed, no options here.\r\n\r\nThe reason I think rawExtension is a good idea is that we don't/can't apply our API standards to an already defined standard (without changing the standard, e.g. StringOrStringArray). Having control over spec means we can diverge from the standard and I don't think having that power is a good thing.\r\n\r\nHaving RawExtension can also let us support different version of Spec without adding new fields. The standard has the version in it, so we can just look at it first before unmarshall it to the right type.\r\n\r\nSo in the v1beta1/ type we can have a RawExtension called `validationSpec rawExtension` or something like that and the internal type can have different specs in different versions and a conversion function can take care of converting RawExtension to the internal type.",
        "createdAt" : "2017-08-28T21:56:38Z",
        "updatedAt" : "2017-08-29T16:05:36Z",
        "lastEditedBy" : "7f521a0d-2137-47c7-a390-3b4bdcffe306",
        "tags" : [
        ]
      },
      {
        "id" : "b129501a-7e2f-495d-867f-36f53b9b84d6",
        "parentId" : "1f0f2096-2bc6-4241-8a4d-21037f30e9c7",
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "We discussed RawExtension as well. It does not make a big difference how the unmarshaling works, whether via RawExtenions or our own types. In the end we define an external API surface we have to support and RawExtensions are an implementation detail to delegate the unmarshaling. It does not solve any of the API validation and stability problems. Moreover, we know that go-openapi's validation of JSON Schema is weak at best. IMO we cannot trust it for this purpose and have no control over it. We also discussed to use the `$scheme` field for the version before and decided against it (that's why we have `OpenAPIv3` now btw).\r\n\r\nIn general, we have been through all of these considerations in the proposal and yet again for some here in the implementation PR. I would very much appreciate participation in the proposal process for these kinds of discussions. The proposal was posted to the relevant lists and people were CC'ed on the proposal PR and this implementation PR very early on. It's pretty tiresome to reopen these discussions again and again so late in the process when the PR is ready.",
        "createdAt" : "2017-08-29T06:42:39Z",
        "updatedAt" : "2017-08-29T16:05:36Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      },
      {
        "id" : "0403ce84-2495-4d9b-a68a-1270dd223771",
        "parentId" : "1f0f2096-2bc6-4241-8a4d-21037f30e9c7",
        "authorId" : "7f521a0d-2137-47c7-a390-3b4bdcffe306",
        "body" : "You are completely right. I am sorry that we didn't catch this in the design phase. But I am just worried that we add something here that we would stuck supporting while there is, to my opinion, a better option. Using RawExtension is not an implementation detail here and should not impose a lot of changes (we can still keep our type just make it internal, if we want to use go-openapi or not is at another level that can be changed or kept later without changing the surface of our API). I would leave this to @lavalamp to give his final opinion.",
        "createdAt" : "2017-08-29T08:50:33Z",
        "updatedAt" : "2017-08-29T16:05:36Z",
        "lastEditedBy" : "7f521a0d-2137-47c7-a390-3b4bdcffe306",
        "tags" : [
        ]
      },
      {
        "id" : "3847ba59-5642-4e64-b6b8-ce070187585c",
        "parentId" : "1f0f2096-2bc6-4241-8a4d-21037f30e9c7",
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "> If we don't actually use the schema and pass it through to other libraries, then do we really want to bless it by writing it up in our API language? The only reason I see to do that is to ensure backwards compatibility, and I'm not sure if that's persuasive.\r\n\r\nThe compatibility and control over the serialization both matter since a change in a backing API can easily produce breaking API changes in your exposed (and already serialized!) objects.  In OpenShift, we found this out the hard way by \"hiding\" a docker library behind a raw serialization.  We could still deserialize the code, but it not longer worked.  If we want it in our API, with our stability guarantees, saying \"the backing library changed so that json you sent us broke, it wasn't *really* part of our API\" isn't a stance that is consistent with the API guarantees that we have.\r\n\r\nWe must control the serialization.",
        "createdAt" : "2017-08-29T12:26:20Z",
        "updatedAt" : "2017-08-29T16:05:36Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      }
    ],
    "commit" : "6ba1523a8e36c3121a9e08bfac7b4f342bb8ccb3",
    "line" : 20,
    "diffHunk" : "@@ -1,1 +145,149 @@type CustomResourceValidation struct {\n\t// OpenAPIV3Schema is the OpenAPI v3 schema to be validated against.\n\tOpenAPIV3Schema *JSONSchemaProps\n}"
  }
]
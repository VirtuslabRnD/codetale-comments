[
  {
    "id" : "2eede499-992a-4892-818e-931e675b9af4",
    "prId" : 74532,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/74532#pullrequestreview-207613354",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "929e8fa9-068f-469f-99ef-47e24c53b681",
        "parentId" : null,
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "This is true for readiness check, but not for liveness check. If we aren't healthy, kubelet will restart us. Is that what we want?",
        "createdAt" : "2019-02-25T19:48:50Z",
        "updatedAt" : "2019-02-27T21:00:36Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "3b0d83b6-c7bb-400c-bfe1-8eaac28d37d7",
        "parentId" : "929e8fa9-068f-469f-99ef-47e24c53b681",
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "> This is true for readiness check, but not for liveness check. If we aren't healthy, kubelet will restart us. Is that what we want?\r\n\r\n`HasSynced` is a \"past the post\" function that never returns to a false state.",
        "createdAt" : "2019-02-25T20:24:12Z",
        "updatedAt" : "2019-02-27T21:00:36Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      }
    ],
    "commit" : "62c32fd04425966d960763abe4df8cfabfe19339",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +212,216 @@\t})\n\t// we don't want to report healthy until we can handle all CRDs that have already been registered.  Waiting for the informer\n\t// to sync makes sure that the lister will be valid before we begin.  There may still be races for CRDs added after startup,\n\t// but we won't go healthy until we can handle the ones already present.\n\ts.GenericAPIServer.AddPostStartHookOrDie(\"crd-informer-synced\", func(context genericapiserver.PostStartHookContext) error {"
  },
  {
    "id" : "03d6e0bf-4ba9-42b0-9ee4-2542f1192456",
    "prId" : 74532,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/74532#pullrequestreview-208865437",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "73ffbb05-c8b6-4b7c-b575-d2a8ede1d21c",
        "parentId" : null,
        "authorId" : "09e31512-b413-47a1-bc83-20b5a77064ee",
        "body" : "Oh sweet! Thanks for doing that! ðŸ˜ƒ ",
        "createdAt" : "2019-02-28T02:28:51Z",
        "updatedAt" : "2019-02-28T02:30:17Z",
        "lastEditedBy" : "09e31512-b413-47a1-bc83-20b5a77064ee",
        "tags" : [
        ]
      }
    ],
    "commit" : "62c32fd04425966d960763abe4df8cfabfe19339",
    "line" : 15,
    "diffHunk" : "@@ -1,1 +214,218 @@\t// to sync makes sure that the lister will be valid before we begin.  There may still be races for CRDs added after startup,\n\t// but we won't go healthy until we can handle the ones already present.\n\ts.GenericAPIServer.AddPostStartHookOrDie(\"crd-informer-synced\", func(context genericapiserver.PostStartHookContext) error {\n\t\treturn wait.PollImmediateUntil(100*time.Millisecond, func() (bool, error) {\n\t\t\treturn s.Informers.Apiextensions().InternalVersion().CustomResourceDefinitions().Informer().HasSynced(), nil"
  },
  {
    "id" : "9aa76429-e1aa-4175-a57f-9a8301a665d9",
    "prId" : 72947,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/72947#pullrequestreview-198886089",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2f2445e8-ae80-4995-93b0-68225beb1c21",
        "parentId" : null,
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "I won't ask for a change but making large reorganizations to import lists doesn't make this PR any smaller :)\r\n",
        "createdAt" : "2019-01-31T23:26:00Z",
        "updatedAt" : "2019-02-04T21:52:39Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "62e5a3f9-df0e-46fc-b861-a52c7c7e175b",
        "parentId" : "2f2445e8-ae80-4995-93b0-68225beb1c21",
        "authorId" : "a139439a-9f9e-4518-b4f3-9c602d956c57",
        "body" : "But ... there was an extra empty line that shouldn't be there? :-)",
        "createdAt" : "2019-02-01T00:48:00Z",
        "updatedAt" : "2019-02-04T21:52:39Z",
        "lastEditedBy" : "a139439a-9f9e-4518-b4f3-9c602d956c57",
        "tags" : [
        ]
      }
    ],
    "commit" : "fcd4985ce4732be7c4dfa62f8e54d92d53496e15",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +22,26 @@\t\"time\"\n\n\t\"k8s.io/apiextensions-apiserver/pkg/apis/apiextensions\"\n\t\"k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/install\"\n\t\"k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1beta1\""
  },
  {
    "id" : "9a4ebe29-50b6-466e-a1dd-8fa3896c4fed",
    "prId" : 63068,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/63068#pullrequestreview-127673861",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ccc09a9e-190c-457d-b160-38f8b92e7f26",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "this only applies when the `master-count` endpoint reconciler is used. that reconciler is no longer the default and is deprecated in 1.11 due to its inability to remove dead apiservers (https://github.com/kubernetes/kubernetes/pull/63383)",
        "createdAt" : "2018-06-11T16:13:59Z",
        "updatedAt" : "2018-06-11T16:14:14Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "fa7a3ce2-6c89-4475-afa3-0b6e5deea94e",
        "parentId" : "ccc09a9e-190c-457d-b160-38f8b92e7f26",
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "In that case in HA we are not much better than before, but certainly not worse. We can switch to a default timeout by default. Longterm we need some checkpointing mechanism to really solve this.\r\n\r\nWith the new lease type, is there a similarly simple way to detect HA?",
        "createdAt" : "2018-06-11T16:18:43Z",
        "updatedAt" : "2018-06-11T16:18:43Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      },
      {
        "id" : "c6309006-ee7f-4589-b366-edac4cd079b6",
        "parentId" : "ccc09a9e-190c-457d-b160-38f8b92e7f26",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "> With the new lease type, is there a similarly simple way to detect HA?\r\n\r\n@rphillips ^",
        "createdAt" : "2018-06-11T17:54:06Z",
        "updatedAt" : "2018-06-11T17:54:06Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "2bf66c377d60276e017e78ab9dbc0490f26baa17",
    "line" : 37,
    "diffHunk" : "@@ -1,1 +176,180 @@\t\tc.GenericConfig.AdmissionControl,\n\t\testablishingController,\n\t\tc.ExtraConfig.MasterCount,\n\t)\n\ts.GenericAPIServer.Handler.NonGoRestfulMux.Handle(\"/apis\", crdHandler)"
  },
  {
    "id" : "1238c63c-2f8d-4054-a747-5847e67ce7c3",
    "prId" : 57228,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/57228#pullrequestreview-90178142",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2ac4f6b5-a717-4a97-8376-f2a5ee165067",
        "parentId" : null,
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "Still reading, but I might have tried to go the other way.  I haven't seen value from the registry.  I think I'd enable anything and everything in a scheme and then separately control API exposure.",
        "createdAt" : "2018-01-05T13:43:50Z",
        "updatedAt" : "2018-01-22T11:11:29Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      },
      {
        "id" : "b8c5b7a6-8f63-49c5-9c1d-552614bf0589",
        "parentId" : "2ac4f6b5-a717-4a97-8376-f2a5ee165067",
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "It's only used for the validation of the given GVs on the command line.",
        "createdAt" : "2018-01-05T13:47:38Z",
        "updatedAt" : "2018-01-22T11:11:29Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      },
      {
        "id" : "902d4a78-fb15-4023-9131-c1472d8bf401",
        "parentId" : "2ac4f6b5-a717-4a97-8376-f2a5ee165067",
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "> It's only used for the validation of the given GVs on the command line.\r\n\r\nI think the interface to that method should be much tighter.  I'd define a local interface that does what you need and then if you want to use this as your impl, I guess I could live with it, but I'd really like to see the registry die as as thing.",
        "createdAt" : "2018-01-05T14:02:04Z",
        "updatedAt" : "2018-01-22T11:11:29Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      },
      {
        "id" : "ffe8cc57-1f50-401c-8ae3-bdd196384a7b",
        "parentId" : "2ac4f6b5-a717-4a97-8376-f2a5ee165067",
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "this is done",
        "createdAt" : "2018-01-19T17:00:13Z",
        "updatedAt" : "2018-01-22T11:11:29Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      }
    ],
    "commit" : "eff1f20ff14cc450968788974d77b472c82fface",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +55,59 @@var (\n\tgroupFactoryRegistry = make(announced.APIGroupFactoryRegistry)\n\tRegistry             = registered.NewOrDie(\"\")\n\tScheme               = runtime.NewScheme()\n\tCodecs               = serializer.NewCodecFactory(Scheme)"
  },
  {
    "id" : "65db19b8-d39d-4e8b-b803-ffc95852538e",
    "prId" : 57228,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/57228#pullrequestreview-86908123",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d7645558-b742-4f76-a3f1-b16705ebb4e5",
        "parentId" : null,
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "@sttts so I'm guessing this is why you added it.  What if we controlled the addition of this delegation target inside of the kube-apiserver which is doing the composition?  Then the individual API servers (the vast majority of things that will exist) don't end up with logic blocks like this.",
        "createdAt" : "2018-01-05T13:45:23Z",
        "updatedAt" : "2018-01-22T11:11:29Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      },
      {
        "id" : "54bfaedb-f61d-4ead-aee3-4b240d587509",
        "parentId" : "d7645558-b742-4f76-a3f1-b16705ebb4e5",
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "It's optional anyway. The apiservers which do not care about runtime config (and don't add the APIEnablementOptions) will not have to use this. The kube-apiserver also opts-in to pass a runtime config to the apiextension-apiserver that comes from its flags. I think the actual logic belongs here. We could decide whether we want APIEnablementOptions by default in the standalone version.",
        "createdAt" : "2018-01-05T13:49:28Z",
        "updatedAt" : "2018-01-22T11:11:29Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      },
      {
        "id" : "3bb733ef-bac1-4363-a26f-99d05e32f87a",
        "parentId" : "d7645558-b742-4f76-a3f1-b16705ebb4e5",
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "> t's optional anyway. The apiservers which do not care about runtime config (and don't add the APIEnablementOptions) will not have to use this. The kube-apiserver also opts-in to pass a runtime config to the apiextension-apiserver that comes from its flags. I think the actual logic belongs here. We could decide whether we want APIEnablementOptions by default in the standalone version.\r\n\r\nas long as the code properly handles the nil case (enable everything), then I'm ok with it.",
        "createdAt" : "2018-01-05T14:02:48Z",
        "updatedAt" : "2018-01-22T11:11:29Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      }
    ],
    "commit" : "eff1f20ff14cc450968788974d77b472c82fface",
    "line" : 39,
    "diffHunk" : "@@ -1,1 +135,139 @@\tapiResourceConfig := c.GenericConfig.MergedResourceConfig\n\tapiGroupInfo := genericapiserver.NewDefaultAPIGroupInfo(apiextensions.GroupName, Registry, Scheme, metav1.ParameterCodec, Codecs)\n\tif apiResourceConfig.AnyResourcesForVersionEnabled(v1beta1.SchemeGroupVersion) {\n\t\tapiGroupInfo.GroupMeta.GroupVersion = v1beta1.SchemeGroupVersion\n\t\tstorage := map[string]rest.Storage{}"
  }
]
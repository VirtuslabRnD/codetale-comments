[
  {
    "id" : "7214956c-8b68-41de-9426-9e6671ef70c0",
    "prId" : 99237,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/99237#pullrequestreview-617278443",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4f0736a0-10a4-469c-aa7f-79002daf49d4",
        "parentId" : null,
        "authorId" : "13c01cb8-6052-4a98-b6fd-20d3acd6332f",
        "body" : "have you checked `newReq.Header = utilnet.CloneHeader(req.Header)` ?\r\n\r\n`req` should already have the `AuditID` header set by the filter",
        "createdAt" : "2021-03-18T13:11:59Z",
        "updatedAt" : "2021-03-18T13:12:02Z",
        "lastEditedBy" : "13c01cb8-6052-4a98-b6fd-20d3acd6332f",
        "tags" : [
        ]
      },
      {
        "id" : "3b613b51-d88a-47e5-b2eb-cc65bc62251e",
        "parentId" : "4f0736a0-10a4-469c-aa7f-79002daf49d4",
        "authorId" : "3e6e337f-0beb-4609-abc3-11b8e8cf5688",
        "body" : "If the user specify an audit ID only then `req` will already have the `Audit-ID` header. If we generate an audit ID then we save it in the context. \r\nif the context already has an audit ID then it has higher precedence, and we want to set it to the new `req`.",
        "createdAt" : "2021-03-19T18:58:12Z",
        "updatedAt" : "2021-03-19T18:58:12Z",
        "lastEditedBy" : "3e6e337f-0beb-4609-abc3-11b8e8cf5688",
        "tags" : [
        ]
      },
      {
        "id" : "baf30fab-f1af-4e66-bd54-1e35f214a20e",
        "parentId" : "4f0736a0-10a4-469c-aa7f-79002daf49d4",
        "authorId" : "13c01cb8-6052-4a98-b6fd-20d3acd6332f",
        "body" : "okay, makes sense, thx.",
        "createdAt" : "2021-03-22T09:01:00Z",
        "updatedAt" : "2021-03-22T09:01:00Z",
        "lastEditedBy" : "13c01cb8-6052-4a98-b6fd-20d3acd6332f",
        "tags" : [
        ]
      }
    ],
    "commit" : "b607ca1bf3e1cf6152c446ea61ac7fdd9014e1f1",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +205,209 @@\t// If the original request has an audit ID, let's make sure we propagate this\n\t// to the aggregated server.\n\tif auditID, found := genericapirequest.AuditIDFrom(req.Context()); found {\n\t\tnewReq.Header.Set(auditinternal.HeaderAuditID, string(auditID))\n\t}"
  },
  {
    "id" : "ef04ecac-0b5c-4949-8d68-f05ebd1c3f01",
    "prId" : 87515,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/87515#pullrequestreview-348282767",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a8fdf02b-925c-496a-b456-743f9da707dc",
        "parentId" : null,
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "same comments I made here: https://github.com/kubernetes/kubernetes/pull/85870#discussion_r369279460\r\n\r\n* pass this around via options struct, not by adding parameters to functions\r\n* use a no-op implementation so that this nil check isn't needed.\r\n\r\ncc @Jefftree ",
        "createdAt" : "2020-01-24T17:10:29Z",
        "updatedAt" : "2020-02-01T18:38:54Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "8ebb3872-8431-47de-9b9f-d177b23351c0",
        "parentId" : "a8fdf02b-925c-496a-b456-743f9da707dc",
        "authorId" : "2c727fdb-29e7-42eb-9c57-a26df4cf39d5",
        "body" : "@lavalamp hmm it's already passed via the `proxyHandler` struct. Or do you mean adding a `APIOptionsStruct` as a parameter to the function? (Which is adding a parameter ðŸ˜…, cause adding the field to `apiService` seems weird.)\r\n\r\nFor the second point would that be a helper function taking the egress selector + the dialer and returning either the egress selector dialer or the passed one? (`nil` check would still be made in the helper though right?)",
        "createdAt" : "2020-01-24T17:41:00Z",
        "updatedAt" : "2020-02-01T18:38:54Z",
        "lastEditedBy" : "2c727fdb-29e7-42eb-9c57-a26df4cf39d5",
        "tags" : [
        ]
      },
      {
        "id" : "541c72c4-7565-42fa-84d7-e07c9072fe5d",
        "parentId" : "a8fdf02b-925c-496a-b456-743f9da707dc",
        "authorId" : "3f579bf7-089d-41f0-abf9-3bf5462ec695",
        "body" : "@lavalamp: Per your second point, there are a lot of other egress endpoints implemented without the no-op implementation that have already been merged. I can make the change requested in the other PR (#85870), but can we look at this PR independent of the no-op and do another refactor PR later?\r\n\r\ncc @caesarxuchao ",
        "createdAt" : "2020-01-24T18:26:22Z",
        "updatedAt" : "2020-02-01T18:38:54Z",
        "lastEditedBy" : "3f579bf7-089d-41f0-abf9-3bf5462ec695",
        "tags" : [
        ]
      },
      {
        "id" : "8db7429f-01c0-4794-954e-fb158ac3d3a0",
        "parentId" : "a8fdf02b-925c-496a-b456-743f9da707dc",
        "authorId" : "2c727fdb-29e7-42eb-9c57-a26df4cf39d5",
        "body" : "agree that no-op could be changed across all egress in its own PR",
        "createdAt" : "2020-01-24T19:31:18Z",
        "updatedAt" : "2020-02-01T18:38:54Z",
        "lastEditedBy" : "2c727fdb-29e7-42eb-9c57-a26df4cf39d5",
        "tags" : [
        ]
      },
      {
        "id" : "4e45b88d-795a-4c7a-82d7-6a303495a6a7",
        "parentId" : "a8fdf02b-925c-496a-b456-743f9da707dc",
        "authorId" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "body" : "RE. the second point, @jefftreee will send a follow-up refactor PR after this one and #85870 are merged.",
        "createdAt" : "2020-01-24T23:45:31Z",
        "updatedAt" : "2020-02-01T18:38:54Z",
        "lastEditedBy" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "tags" : [
        ]
      }
    ],
    "commit" : "df9b4e92e84849e2b9fdb5b4849c9c4ebfae8040",
    "line" : 24,
    "diffHunk" : "@@ -1,1 +265,269 @@\t\tserviceAvailable: apiregistrationv1apihelper.IsAPIServiceConditionTrue(apiService, apiregistrationv1api.Available),\n\t}\n\tif r.egressSelector != nil {\n\t\tnetworkContext := egressselector.Cluster.AsNetworkContext()\n\t\tvar egressDialer utilnet.DialFunc"
  },
  {
    "id" : "163a1f41-1bdc-428c-84ba-3f141b682139",
    "prId" : 87515,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/87515#pullrequestreview-351844954",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5fcabf71-32ed-4c85-82e0-7cc062f736fa",
        "parentId" : null,
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "So, if set, `proxyTransport.DialContext` is no longer used?\r\n\r\nDoes this change the behavior / meaning of the \"--enable-aggregator-routing\" flag?",
        "createdAt" : "2020-02-01T00:04:50Z",
        "updatedAt" : "2020-02-01T18:38:54Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "811f39d1-2da4-4c1c-a45b-d9baf399ac18",
        "parentId" : "5fcabf71-32ed-4c85-82e0-7cc062f736fa",
        "authorId" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "body" : "proxyTransport.DialContext contains the ssh dial if ssh is enabled. So the logic here says, if egressSelector is enabled, use it to get a dialer, otherwise use the ssh dialer if there is one.\r\n\r\n\"--enable-aggregator-routing\": Turns on aggregator routing requests to endpoints IP rather than cluster IP.\r\n\r\nEither IP will be in the cluster network, so I think using the egressSelector doesn't change the behavior.",
        "createdAt" : "2020-02-01T00:20:17Z",
        "updatedAt" : "2020-02-01T18:38:54Z",
        "lastEditedBy" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "tags" : [
        ]
      },
      {
        "id" : "5543e8e0-aaeb-43c6-904b-4c9ad092c99f",
        "parentId" : "5fcabf71-32ed-4c85-82e0-7cc062f736fa",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "OK thanks.",
        "createdAt" : "2020-02-01T00:21:50Z",
        "updatedAt" : "2020-02-01T18:38:54Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      }
    ],
    "commit" : "df9b4e92e84849e2b9fdb5b4849c9c4ebfae8040",
    "line" : 33,
    "diffHunk" : "@@ -1,1 +274,278 @@\t\t\tnewInfo.restConfig.Dial = egressDialer\n\t\t}\n\t} else if r.proxyTransport != nil && r.proxyTransport.DialContext != nil {\n\t\tnewInfo.restConfig.Dial = r.proxyTransport.DialContext\n\t}"
  },
  {
    "id" : "b7996a18-90de-4c2d-a5e6-82b84fa66a42",
    "prId" : 82146,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/82146#pullrequestreview-282150829",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8ca16e20-7ae9-4a98-8d7a-6faed5f59a5e",
        "parentId" : null,
        "authorId" : "7aca96c2-45d7-4567-99be-0323d7556c55",
        "body" : "Any chance we might want to configure this?",
        "createdAt" : "2019-08-30T17:10:58Z",
        "updatedAt" : "2019-08-30T17:10:59Z",
        "lastEditedBy" : "7aca96c2-45d7-4567-99be-0323d7556c55",
        "tags" : [
        ]
      }
    ],
    "commit" : "c24a36610eaf3a93a1f3ffe7a43dd660ee6a345d",
    "line" : 26,
    "diffHunk" : "@@ -1,1 +45,49 @@\taggregatorComponent string = \"aggregator\"\n\n\taggregatedDiscoveryTimeout = 5 * time.Second\n)\n"
  },
  {
    "id" : "fd665439-ff84-4414-aaf7-19b05f2c2271",
    "prId" : 49534,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/49534#pullrequestreview-54369134",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e99b1e83-3811-4935-b0b8-399f4438d0fe",
        "parentId" : null,
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "also odd here that `w` is ignored. Am not through the whole PR yet, but I guess there will a use of that `Error` signature somewhere.",
        "createdAt" : "2017-08-02T08:26:52Z",
        "updatedAt" : "2017-08-04T16:48:43Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      },
      {
        "id" : "52ce4022-ba87-4e51-9856-488efbda3bba",
        "parentId" : "e99b1e83-3811-4935-b0b8-399f4438d0fe",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "This is just the behavior of the old code - the responder was used in several code spots in storage side.",
        "createdAt" : "2017-08-04T13:41:48Z",
        "updatedAt" : "2017-08-04T16:48:43Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      }
    ],
    "commit" : "c42531cc51b67c7ab67ba6b5d94db2320feec66e",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +183,187 @@\nfunc (r *responder) Error(_ http.ResponseWriter, _ *http.Request, err error) {\n\thttp.Error(r.w, err.Error(), http.StatusInternalServerError)\n}\n"
  },
  {
    "id" : "d0c8db3c-2053-48ba-89bc-1b74f3d7b13a",
    "prId" : 43383,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/43383#pullrequestreview-28088218",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f65d9918-9d2e-4e18-803a-cc4e44664bed",
        "parentId" : null,
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "This is the knob you mean? Yes, it will enforce host verification against this hostname, while avoiding DNS resolution if the `destinationHost` is an IP. We also use this for loopback connections with a fake `ServerName` to route SNI to a special cert.",
        "createdAt" : "2017-03-21T07:04:21Z",
        "updatedAt" : "2017-03-27T16:33:25Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      },
      {
        "id" : "3ee66505-0f5a-4093-91f7-c82032572d92",
        "parentId" : "f65d9918-9d2e-4e18-803a-cc4e44664bed",
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "> This is the knob you mean? Yes, it will enforce host verification against this hostname, while avoiding DNS resolution if the destinationHost is an IP.\r\n\r\nYep.  Does exactly what I need.",
        "createdAt" : "2017-03-21T11:58:18Z",
        "updatedAt" : "2017-03-27T16:33:25Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      }
    ],
    "commit" : "3414231672e59b750fe135bdccc076eb3a72498d",
    "line" : 21,
    "diffHunk" : "@@ -1,1 +188,192 @@\t\t\tTLSClientConfig: restclient.TLSClientConfig{\n\t\t\t\tInsecure:   apiService.Spec.InsecureSkipTLSVerify,\n\t\t\t\tServerName: apiService.Spec.Service.Name + \".\" + apiService.Spec.Service.Namespace + \".svc\",\n\t\t\t\tCertData:   r.proxyClientCert,\n\t\t\t\tKeyData:    r.proxyClientKey,"
  },
  {
    "id" : "6ac6025e-3c84-42e6-9063-824d99e084ce",
    "prId" : 42801,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/42801#pullrequestreview-26554681",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "db784183-df10-452a-9af0-5cb2c0bee562",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "this will panic if nothing has been stored in the value yet, handle not-ok casts with not found error or something",
        "createdAt" : "2017-03-11T07:21:31Z",
        "updatedAt" : "2017-03-13T14:10:52Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "38ea5d80-fd35-4e65-a536-694a573f560b",
        "parentId" : "db784183-df10-452a-9af0-5cb2c0bee562",
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "> this will panic if nothing has been stored in the value yet, handle not-ok casts with not found error or something\r\n\r\nPrivate struct.  It's always initialized before it's exposed.",
        "createdAt" : "2017-03-13T13:58:00Z",
        "updatedAt" : "2017-03-13T14:10:52Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      }
    ],
    "commit" : "b27de102cb211384f2bd0298b2257862f035d4e9",
    "line" : 40,
    "diffHunk" : "@@ -1,1 +65,69 @@\nfunc (r *proxyHandler) ServeHTTP(w http.ResponseWriter, req *http.Request) {\n\thandlingInfo := r.handlingInfo.Load().(proxyHandlingInfo)\n\tif handlingInfo.local {\n\t\tr.localDelegate.ServeHTTP(w, req)"
  },
  {
    "id" : "0bece2c7-1d4a-4f70-b438-5120eea40105",
    "prId" : 42801,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/42801#pullrequestreview-26554897",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fac7f3f3-2869-4a30-be9b-87cbfb236f16",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "is this the case where they registered a service with a bad CA bundle or something? not sure I'd expect that the details of that error to bubble to an external user",
        "createdAt" : "2017-03-11T07:23:55Z",
        "updatedAt" : "2017-03-13T14:10:52Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "07fde433-0ff7-4d64-9b0f-fe4ffcb44a72",
        "parentId" : "fac7f3f3-2869-4a30-be9b-87cbfb236f16",
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "> is this the case where they registered a service with a bad CA bundle or something? not sure I'd expect that the details of that error to bubble to an external user\r\n\r\nDon't plan to change that in this pull.  I considered hiding it, but then I couldn't come up with a way for a cluster-admin to debug it.",
        "createdAt" : "2017-03-13T13:58:48Z",
        "updatedAt" : "2017-03-13T14:10:52Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      }
    ],
    "commit" : "b27de102cb211384f2bd0298b2257862f035d4e9",
    "line" : 46,
    "diffHunk" : "@@ -1,1 +71,75 @@\t}\n\n\tif handlingInfo.transportBuildingError != nil {\n\t\thttp.Error(w, handlingInfo.transportBuildingError.Error(), http.StatusInternalServerError)\n\t\treturn"
  }
]
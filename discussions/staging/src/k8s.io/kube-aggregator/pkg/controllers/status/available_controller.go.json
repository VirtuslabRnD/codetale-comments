[
  {
    "id" : "dcc3cd05-e1f9-416c-9f34-45912ee6fb5a",
    "prId" : 101420,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/101420#pullrequestreview-648361676",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9e26fe44-9f3c-44b3-bc28-e63212e2aca9",
        "parentId" : null,
        "authorId" : "7aca96c2-45d7-4567-99be-0323d7556c55",
        "body" : "Seems like most of the add/update logs are V(4). Do we want this one at V(2)?",
        "createdAt" : "2021-04-26T21:07:22Z",
        "updatedAt" : "2021-04-29T12:40:54Z",
        "lastEditedBy" : "7aca96c2-45d7-4567-99be-0323d7556c55",
        "tags" : [
        ]
      },
      {
        "id" : "8da84b55-2078-4b33-879c-b6bacba8a0d0",
        "parentId" : "9e26fe44-9f3c-44b3-bc28-e63212e2aca9",
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "This is so important for cluster/API availability, I think `V(2)` makes super sense here. When this flaps, it is critical for the cluster.",
        "createdAt" : "2021-04-29T12:35:18Z",
        "updatedAt" : "2021-04-29T12:40:54Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      },
      {
        "id" : "01c873c9-1d75-4fd7-bf57-7afa5506edd7",
        "parentId" : "9e26fe44-9f3c-44b3-bc28-e63212e2aca9",
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "I would even go one step further and create events (in an follow-up) if we don't have that yet.",
        "createdAt" : "2021-04-29T15:37:15Z",
        "updatedAt" : "2021-04-29T15:37:16Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      }
    ],
    "commit" : "ae3d0d50310d6578dacbecd76694e9fb297df686",
    "line" : 17,
    "diffHunk" : "@@ -1,1 +472,476 @@\t}\n\tif *orig != *now {\n\t\tklog.V(2).InfoS(\"changing APIService availability\", \"name\", newAPIService.Name, \"oldStatus\", orig.Status, \"newStatus\", now.Status, \"message\", now.Message, \"reason\", now.Reason)\n\t}\n"
  },
  {
    "id" : "28920afe-f343-4e37-95be-60eb0096c1b2",
    "prId" : 101420,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/101420#pullrequestreview-648153846",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e42e97de-e68a-4cc2-ad44-add4754edecf",
        "parentId" : null,
        "authorId" : "7aca96c2-45d7-4567-99be-0323d7556c55",
        "body" : "What if now is nil? (Eg. the test failure)\r\ngoroutine 148 [running]:\r\ntesting.tRunner.func1.2(0x1f2e340, 0x2e1d980)\r\n\t/usr/local/go/src/testing/testing.go:1143 +0x49f\r\ntesting.tRunner.func1(0xc0004b8300)\r\n\t/usr/local/go/src/testing/testing.go:1146 +0x695\r\npanic(0x1f2e340, 0x2e1d980)\r\n\t/usr/local/go/src/runtime/panic.go:971 +0x499\r\nk8s.io/kubernetes/vendor/k8s.io/kube-aggregator/pkg/controllers/status.(*AvailableConditionController).updateAPIServiceStatus(0xc0000c9e00, 0xc0004b8480, 0xc0004b8600, 0x0, 0x0, 0x0)\r\n\t/home/prow/go/src/k8s.io/kubernetes/_output/local/go/src/k8s.io/kubernetes/vendor/k8s.io/kube-aggregator/pkg/controllers/status/available_controller.go:469 +0x1f1\r\nk8s.io/kubernetes/vendor/k8s.io/kube-aggregator/pkg/controllers/status.TestUpdateAPIServiceStatus(0xc0004b8300)\r\n\t/home/prow/go/src/k8s.io/kubernetes/_output/local/go/src/k8s.io/kubernetes/vendor/k8s.io/kube-aggregator/pkg/controllers/status/available_controller_test.go:473 +0x385\r\ntesting.tRunner(0xc0004b8300, 0x2186808)\r\n\t/usr/local/go/src/testing/testing.go:1193 +0x203\r\ncreated by testing.(*T).Run\r\n\t/usr/local/go/src/testing/testing.go:1238 +0x5d8",
        "createdAt" : "2021-04-26T21:15:33Z",
        "updatedAt" : "2021-04-29T12:40:54Z",
        "lastEditedBy" : "7aca96c2-45d7-4567-99be-0323d7556c55",
        "tags" : [
        ]
      },
      {
        "id" : "9e434898-27f6-42ca-9e1f-71fa43248d7b",
        "parentId" : "e42e97de-e68a-4cc2-ad44-add4754edecf",
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "fixed",
        "createdAt" : "2021-04-29T12:40:50Z",
        "updatedAt" : "2021-04-29T12:40:54Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      }
    ],
    "commit" : "ae3d0d50310d6578dacbecd76694e9fb297df686",
    "line" : 16,
    "diffHunk" : "@@ -1,1 +471,475 @@\t\tnow = &unknown\n\t}\n\tif *orig != *now {\n\t\tklog.V(2).InfoS(\"changing APIService availability\", \"name\", newAPIService.Name, \"oldStatus\", orig.Status, \"newStatus\", now.Status, \"message\", now.Message, \"reason\", now.Reason)\n\t}"
  },
  {
    "id" : "9d637d42-6459-45e5-898d-bcd4baad7fcc",
    "prId" : 96421,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/96421#pullrequestreview-534231471",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "615a83df-62cb-4f0a-b4c9-c9897242a150",
        "parentId" : null,
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "// metrics registered into legacy registry",
        "createdAt" : "2020-11-19T09:33:00Z",
        "updatedAt" : "2020-11-19T10:21:52Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      }
    ],
    "commit" : "b525f9e0ed0003471438fb42fa37ff4ebe36d653",
    "line" : 24,
    "diffHunk" : "@@ -1,1 +100,104 @@\n\t// metrics registered into legacy registry\n\tmetrics *availabilityMetrics\n}\n"
  },
  {
    "id" : "e265d7c8-0d42-42c6-88af-6f455871e63c",
    "prId" : 96421,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/96421#pullrequestreview-534231994",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8363e86e-7238-4fd8-a82c-49aeb8984149",
        "parentId" : null,
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "// TODO: decouple from legacyregistry",
        "createdAt" : "2020-11-19T09:33:36Z",
        "updatedAt" : "2020-11-19T10:21:52Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      }
    ],
    "commit" : "b525f9e0ed0003471438fb42fa37ff4ebe36d653",
    "line" : 41,
    "diffHunk" : "@@ -1,1 +213,217 @@\n\t// TODO: decouple from legacyregistry\n\tvar err error\n\tregisterIntoLegacyRegistryOnce.Do(func() {\n\t\terr = c.metrics.Register(legacyregistry.Register, legacyregistry.CustomRegister)"
  },
  {
    "id" : "3c5f02e9-46c1-4afd-bc5d-0b7daf3ff05e",
    "prId" : 91525,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/91525#pullrequestreview-422343806",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6c06da3a-753d-4633-bebb-f79124bb4af1",
        "parentId" : null,
        "authorId" : "bc182326-9017-48d6-8ee0-4609046c1366",
        "body" : "aggregator should skip health-checks when the apiservice is marked as \"local\", can you elaborate?",
        "createdAt" : "2020-05-28T14:51:23Z",
        "updatedAt" : "2020-06-09T05:30:40Z",
        "lastEditedBy" : "bc182326-9017-48d6-8ee0-4609046c1366",
        "tags" : [
        ]
      },
      {
        "id" : "2e03f3a5-dfc5-42a5-a19a-85e0d905a519",
        "parentId" : "6c06da3a-753d-4633-bebb-f79124bb4af1",
        "authorId" : "171bb666-1454-4ba5-866b-e46f2bd90421",
        "body" : "The aggregator skips health check of apiservices marked local. This line will only be executed when the service reference is not nil, which means delegating to a service.\r\n\r\nIf we configure APIService v1. with a service reference, this health check will always fail (as the legacy group doesn't apply to the health check rule here). That's why I add the skip check.",
        "createdAt" : "2020-05-28T15:58:23Z",
        "updatedAt" : "2020-06-09T05:30:40Z",
        "lastEditedBy" : "171bb666-1454-4ba5-866b-e46f2bd90421",
        "tags" : [
        ]
      },
      {
        "id" : "05758189-8222-4709-833a-c27bc4b82bf8",
        "parentId" : "6c06da3a-753d-4633-bebb-f79124bb4af1",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "Is this the correct fix? I guess I would have expected it to proceed, but with a different path?",
        "createdAt" : "2020-05-29T22:57:04Z",
        "updatedAt" : "2020-06-09T05:30:40Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "c1df632a-4821-40e9-936d-270f35660bcb",
        "parentId" : "6c06da3a-753d-4633-bebb-f79124bb4af1",
        "authorId" : "171bb666-1454-4ba5-866b-e46f2bd90421",
        "body" : "You're right. There's no reason to make an exception here. Updated the health check path for the legacy api.",
        "createdAt" : "2020-06-02T05:03:26Z",
        "updatedAt" : "2020-06-09T05:30:40Z",
        "lastEditedBy" : "171bb666-1454-4ba5-866b-e46f2bd90421",
        "tags" : [
        ]
      }
    ],
    "commit" : "c8ac95321d6470e476ed878ef1e3a3c760f7fdae",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +287,291 @@\t\t\t\t}\n\t\t\t\t// render legacyAPIService health check path when it is delegated to a service\n\t\t\t\tif apiService.Name == \"v1.\" {\n\t\t\t\t\tdiscoveryURL.Path = \"/api/\" + apiService.Spec.Version\n\t\t\t\t} else {"
  },
  {
    "id" : "6462b245-35c5-4a65-b874-109cafab72d3",
    "prId" : 91160,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/91160#pullrequestreview-415066196",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ade095a8-ef88-4cec-95ec-7f082f1390e3",
        "parentId" : null,
        "authorId" : "13c01cb8-6052-4a98-b6fd-20d3acd6332f",
        "body" : "good catch, it can block on sending to a chan on a timeout",
        "createdAt" : "2020-05-20T07:36:18Z",
        "updatedAt" : "2020-05-20T07:36:19Z",
        "lastEditedBy" : "13c01cb8-6052-4a98-b6fd-20d3acd6332f",
        "tags" : [
        ]
      }
    ],
    "commit" : "c5f73de4fd6a566621e586986352383d3a84bc9a",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +288,292 @@\t\t\t\tdiscoveryURL.Path = \"/apis/\" + apiService.Spec.Group + \"/\" + apiService.Spec.Version\n\n\t\t\t\terrCh := make(chan error, 1)\n\t\t\t\tgo func() {\n\t\t\t\t\t// be sure to check a URL that the aggregated API server is required to serve"
  },
  {
    "id" : "1aa2e209-bada-4b4b-ac4f-c54f7a273944",
    "prId" : 82095,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/82095#pullrequestreview-281752947",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f0c1cf74-b8e9-4aac-b465-4a15610d6d1d",
        "parentId" : null,
        "authorId" : "7aca96c2-45d7-4567-99be-0323d7556c55",
        "body" : "I think that extracting the twin for loops as a helper function would be easier to read/maintain than the labelled break. However it does seem correct.",
        "createdAt" : "2019-08-29T22:24:56Z",
        "updatedAt" : "2019-09-11T16:01:49Z",
        "lastEditedBy" : "7aca96c2-45d7-4567-99be-0323d7556c55",
        "tags" : [
        ]
      }
    ],
    "commit" : "31581e7cb5b26786ab4a9122bb62fb8ce0ec5b79",
    "line" : 12,
    "diffHunk" : "@@ -1,1 +240,244 @@\t\t}\n\t\thasActiveEndpoints := false\n\touter:\n\t\tfor _, subset := range endpoints.Subsets {\n\t\t\tif len(subset.Addresses) == 0 {"
  },
  {
    "id" : "6279e9bc-3f18-4640-90e3-de51c56359a5",
    "prId" : 79999,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/79999#pullrequestreview-261263576",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1f24f305-59bb-4104-b856-c8ca52b42a47",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "the entire implementation of getAPIServicesFor() should look something like this:\r\n\r\n```\r\nmetadata, err := meta.Accessor(obj)\r\nif err != nil {\r\n  utilruntime.HandleError(err)\r\n  return nil\r\n}\r\nc.RLock()\r\ndefer c.RUnlock()\r\nreturn c.cache[metadata.GetNamespace()][metadata.GetName()]\r\n```\r\n\r\nthe work to build/maintain c.cache would be done in the event handlers for APIService",
        "createdAt" : "2019-07-12T13:41:48Z",
        "updatedAt" : "2019-08-13T03:26:08Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "7db2c859bc9f4ccda33ccce9b988ac7a2634088b",
    "line" : 72,
    "diffHunk" : "@@ -1,1 +460,464 @@}\n\nfunc (c *AvailableConditionController) getAPIServicesFor(obj runtime.Object) []string {\n\tmetadata, err := meta.Accessor(obj)\n\tif err != nil {"
  },
  {
    "id" : "9c258afa-d7cb-48b5-ad45-7d82cbe77f8c",
    "prId" : 79999,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/79999#pullrequestreview-261337705",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f4f904c8-2208-4ed0-a278-c842d1b230cd",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "if this apiservice previously had a non-nil service, it would need to be removed from the cache. rather than trying to mutate the cache in-place, it would be much simpler to rebuild the cache from scratch, then overwrite `c.cache`",
        "createdAt" : "2019-07-12T15:47:27Z",
        "updatedAt" : "2019-08-13T03:26:08Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "7db2c859bc9f4ccda33ccce9b988ac7a2634088b",
    "line" : 92,
    "diffHunk" : "@@ -1,1 +479,483 @@\tfor _, apiService := range apiServiceList {\n\t\tif apiService.Spec.Service == nil {\n\t\t\tcontinue\n\t\t}\n\t\tif newCache[apiService.Spec.Service.Namespace] == nil {"
  },
  {
    "id" : "718f4660-453f-4bb8-9128-836569a23a34",
    "prId" : 79999,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/79999#pullrequestreview-261542064",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7f86a741-b798-4493-a6f0-617557191489",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "this function needs unit tests",
        "createdAt" : "2019-07-12T15:49:07Z",
        "updatedAt" : "2019-08-13T03:26:08Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "389d5469-f08a-4ced-8caf-c01cac0cfdef",
        "parentId" : "7f86a741-b798-4493-a6f0-617557191489",
        "authorId" : "42b1e004-4fa7-4e43-84cf-5378839b49ad",
        "body" : "available_controller_test doesn't exercise this part of code.\r\n\r\nTrying to find an existing test which runs thru this code before adding new test.",
        "createdAt" : "2019-07-12T16:10:28Z",
        "updatedAt" : "2019-08-13T03:26:08Z",
        "lastEditedBy" : "42b1e004-4fa7-4e43-84cf-5378839b49ad",
        "tags" : [
        ]
      },
      {
        "id" : "858c81a6-0530-4d40-a5e4-fdb0d827b5a3",
        "parentId" : "7f86a741-b798-4493-a6f0-617557191489",
        "authorId" : "42b1e004-4fa7-4e43-84cf-5378839b49ad",
        "body" : "I am adding TestBuildCache to available_controller_test.go (work in progress)\r\n",
        "createdAt" : "2019-07-12T23:57:45Z",
        "updatedAt" : "2019-08-13T03:26:08Z",
        "lastEditedBy" : "42b1e004-4fa7-4e43-84cf-5378839b49ad",
        "tags" : [
        ]
      },
      {
        "id" : "39df27b8-c4e6-4910-9754-e7643b2fcf50",
        "parentId" : "7f86a741-b798-4493-a6f0-617557191489",
        "authorId" : "42b1e004-4fa7-4e43-84cf-5378839b49ad",
        "body" : "Currently aPIServiceLister#List returns nothing in the new test.\r\nNeed to figure out how to populate the list.",
        "createdAt" : "2019-07-13T03:02:49Z",
        "updatedAt" : "2019-08-13T03:26:08Z",
        "lastEditedBy" : "42b1e004-4fa7-4e43-84cf-5378839b49ad",
        "tags" : [
        ]
      },
      {
        "id" : "d59ecdfd-e638-4564-a92a-8e6add7660d6",
        "parentId" : "7f86a741-b798-4493-a6f0-617557191489",
        "authorId" : "42b1e004-4fa7-4e43-84cf-5378839b49ad",
        "body" : "@liggitt \r\nI have added a basic test.\r\nCan you take a look ?",
        "createdAt" : "2019-07-13T13:42:47Z",
        "updatedAt" : "2019-08-13T03:26:08Z",
        "lastEditedBy" : "42b1e004-4fa7-4e43-84cf-5378839b49ad",
        "tags" : [
        ]
      }
    ],
    "commit" : "7db2c859bc9f4ccda33ccce9b988ac7a2634088b",
    "line" : 87,
    "diffHunk" : "@@ -1,1 +474,478 @@// (which will get processed an extra time - this doesn't matter),\n// and miss a newly relevant apiservice (which will get queued by the apiservice handler)\nfunc (c *AvailableConditionController) rebuildAPIServiceCache() {\n\tapiServiceList, _ := c.apiServiceLister.List(labels.Everything())\n\tnewCache := map[string]map[string][]string{}"
  },
  {
    "id" : "fddb2e8e-4ca1-47f6-9bfa-7e23095aa65a",
    "prId" : 79999,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/79999#pullrequestreview-262788833",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6764e875-ef9e-4fc3-bc5a-13e7c4dc0a01",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "needs a comment documenting each key/value meaning, e.g.\r\n\r\n// map of service-namespace -> service-name -> apiservice names",
        "createdAt" : "2019-07-17T03:41:58Z",
        "updatedAt" : "2019-08-13T03:26:08Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "7db2c859bc9f4ccda33ccce9b988ac7a2634088b",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +76,80 @@\tqueue workqueue.RateLimitingInterface\n\t// map from service-namespace -> service-name -> apiservice names\n\tcache map[string]map[string][]string\n\t// this lock protects operations on the above cache\n\tcacheLock sync.RWMutex"
  },
  {
    "id" : "755cdb2c-e124-4c07-9bce-8ba3dea8a01b",
    "prId" : 79999,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/79999#pullrequestreview-265561932",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "32907596-eada-4f62-93ad-22fefca95c6f",
        "parentId" : null,
        "authorId" : "bc182326-9017-48d6-8ee0-4609046c1366",
        "body" : "an alternative will be inserting another indexer into the apiService informer e.g. https://github.com/kubernetes/kubernetes/blob/7e806a2dd6efb156858706aca78f8a9850315f7b/pkg/controller/nodelifecycle/node_lifecycle_controller.go#L368-L380\r\n\r\nso that we dont need to deal w/ the cache managed in a nested-map in addition to the lock instance. an indexer and index function will achieve the same @liggitt wdyt?",
        "createdAt" : "2019-07-23T17:26:46Z",
        "updatedAt" : "2019-08-13T03:26:08Z",
        "lastEditedBy" : "bc182326-9017-48d6-8ee0-4609046c1366",
        "tags" : [
        ]
      }
    ],
    "commit" : "7db2c859bc9f4ccda33ccce9b988ac7a2634088b",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +76,80 @@\tqueue workqueue.RateLimitingInterface\n\t// map from service-namespace -> service-name -> apiservice names\n\tcache map[string]map[string][]string\n\t// this lock protects operations on the above cache\n\tcacheLock sync.RWMutex"
  },
  {
    "id" : "78a784ca-6da7-4e26-9009-74905bbee13c",
    "prId" : 79999,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/79999#pullrequestreview-266617249",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d23988eb-6d40-434c-bf7d-c26d29fe9d7d",
        "parentId" : null,
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "explain why this is done synchronously on this thread.",
        "createdAt" : "2019-07-25T13:06:37Z",
        "updatedAt" : "2019-08-13T03:26:08Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      },
      {
        "id" : "df4379dc-25a8-42d3-b248-825f1ec55f95",
        "parentId" : "d23988eb-6d40-434c-bf7d-c26d29fe9d7d",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "It was slow moving and guaranteed the cache was up to date before ensuring the apiservice for checking",
        "createdAt" : "2019-07-25T13:16:50Z",
        "updatedAt" : "2019-08-13T03:26:08Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "7db2c859bc9f4ccda33ccce9b988ac7a2634088b",
    "line" : 39,
    "diffHunk" : "@@ -1,1 +424,428 @@\tklog.V(4).Infof(\"Adding %s\", castObj.Name)\n\tif castObj.Spec.Service != nil {\n\t\tc.rebuildAPIServiceCache()\n\t}\n\tc.queue.Add(castObj.Name)"
  },
  {
    "id" : "980a485e-6ebc-49d4-868e-8d7f04d61c9a",
    "prId" : 79999,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/79999#pullrequestreview-266667907",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e99c7dbf-ad53-474f-8a2d-87d92df9ae14",
        "parentId" : null,
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "this is logically dependent on services too, so rebuilding a cache on only apiservice change is incorrect.",
        "createdAt" : "2019-07-25T13:07:30Z",
        "updatedAt" : "2019-08-13T03:26:08Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      },
      {
        "id" : "541f51d9-ab71-473e-9616-d9c8933962e3",
        "parentId" : "e99c7dbf-ad53-474f-8a2d-87d92df9ae14",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "Really? It's keyed by service name and namespace, regardless of whether such a service actually exists, right?",
        "createdAt" : "2019-07-25T13:15:46Z",
        "updatedAt" : "2019-08-13T03:26:08Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "e86370bc-ffa8-49a0-b56a-cd9ce7faa09c",
        "parentId" : "e99c7dbf-ad53-474f-8a2d-87d92df9ae14",
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "> this is logically dependent on services too, so rebuilding a cache on only apiservice change is incorrect.\r\n\r\nActually, playing out the full scenario looks like this\r\n\r\n1. threadA sees apiservice update and starts rebuilding the map\r\n2. threadB sees service update and issues \"which apiservices depend on this service\".\r\n3. threadB checks before threadA writes the new map and gets \"not watched\". (this is different than before this pull because the apiservice lister always matches the change notifications)\r\n4. threadB fails to queue interested apiservice\r\n5. threadA finishes rebuilding and queues the apiservice that threadB skipped.\r\n\r\n\r\nit is different, but it may not be wrong.  It's certainly worth an explanation laying out the change and defending why it is safe.",
        "createdAt" : "2019-07-25T13:25:01Z",
        "updatedAt" : "2019-08-13T03:26:08Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      },
      {
        "id" : "32595306-08a1-44de-b2d1-78f0a4ac2095",
        "parentId" : "e99c7dbf-ad53-474f-8a2d-87d92df9ae14",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "Service/endpoint handling was already working off the cache, so this didn't seem different in character to me",
        "createdAt" : "2019-07-25T13:33:14Z",
        "updatedAt" : "2019-08-13T03:26:08Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "4d05c571-edb7-48d8-a7a2-309e7cf1b95c",
        "parentId" : "e99c7dbf-ad53-474f-8a2d-87d92df9ae14",
        "authorId" : "bc182326-9017-48d6-8ee0-4609046c1366",
        "body" : "wiring an add-on indexer into informer as the cache can help us make sure the caching entries refreshed before the notification arrives. so the lister-cache and addon-cache will be always consistent",
        "createdAt" : "2019-07-25T13:38:00Z",
        "updatedAt" : "2019-08-13T03:26:08Z",
        "lastEditedBy" : "bc182326-9017-48d6-8ee0-4609046c1366",
        "tags" : [
        ]
      },
      {
        "id" : "2994e051-e878-477e-bc07-5df055cb9291",
        "parentId" : "e99c7dbf-ad53-474f-8a2d-87d92df9ae14",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "spoke with @deads2k, a comment about why a race between service/endpoint handling and apiservice cache rebuild doesn't matter would be fine. Something like \"if the service/endpoint handler wins the race against the cache rebuild, it might queue a no-longer-relevant apiservice (which will get processed an extra time, which doesn't matter), and miss a newly relevant apiservice (which will get queued by the apiservice handler)\"",
        "createdAt" : "2019-07-25T14:32:19Z",
        "updatedAt" : "2019-08-13T03:26:08Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "d32be92c-27a2-4121-987d-3bba3cda863e",
        "parentId" : "e99c7dbf-ad53-474f-8a2d-87d92df9ae14",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "> wiring an add-on indexer into informer as the cache can help us make sure the caching entries refreshed before the notification arrives. so the lister-cache and addon-cache will be always consistent\r\n\r\nwe could benchmark that, but listing from cache and building the cache key takes allocations which I'd like to avoid in the service/endpoint handler path",
        "createdAt" : "2019-07-25T14:32:56Z",
        "updatedAt" : "2019-08-13T03:26:08Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "7db2c859bc9f4ccda33ccce9b988ac7a2634088b",
    "line" : 87,
    "diffHunk" : "@@ -1,1 +474,478 @@// (which will get processed an extra time - this doesn't matter),\n// and miss a newly relevant apiservice (which will get queued by the apiservice handler)\nfunc (c *AvailableConditionController) rebuildAPIServiceCache() {\n\tapiServiceList, _ := c.apiServiceLister.List(labels.Everything())\n\tnewCache := map[string]map[string][]string{}"
  },
  {
    "id" : "374df4d9-21bf-4b64-9524-043f3d70b7f3",
    "prId" : 79999,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/79999#pullrequestreview-274044058",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5c7bec35-9f61-4fc1-9a20-96ca05080a4e",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "old and new objects passed to informer update handlers are both non-nil... this should be sufficient:\r\n\r\n```\r\nif !reflect.DeepEqual(castObj.Spec.Service, oldCastObj.Spec.Service) {\r\n...\r\n}\r\n```",
        "createdAt" : "2019-08-13T03:15:30Z",
        "updatedAt" : "2019-08-13T03:26:08Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "7db2c859bc9f4ccda33ccce9b988ac7a2634088b",
    "line" : 54,
    "diffHunk" : "@@ -1,1 +435,439 @@\tif !reflect.DeepEqual(castObj.Spec.Service, oldCastObj.Spec.Service) {\n\t\tc.rebuildAPIServiceCache()\n\t}\n\tc.queue.Add(oldCastObj.Name)\n}"
  },
  {
    "id" : "6bb1f421-cfa5-45cb-a23b-bac2b88af4b3",
    "prId" : 79895,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/79895#pullrequestreview-259014417",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c08a0689-a6d8-418f-8569-339a92f9b02b",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "should probably do `discoveryURL.Path = \"/apis/\"+apiService.Spec.Group+\"/\"+apiService.Spec.Version` instead (or make a new URL copying over scheme+host), rather than appending to whatever path was included in the URL returned  from ResolveEndpoint.\r\n\r\n(we also ignore the returned path when proxying at https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/kube-aggregator/pkg/apiserver/handler_proxy.go#L140)",
        "createdAt" : "2019-07-08T16:19:10Z",
        "updatedAt" : "2019-07-08T17:27:50Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "a84db7e9de80c224681c9f5b6c9a0680b4c9482c",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +263,267 @@\t\t\t\t}\n\t\t\t\tdiscoveryURL.Path = \"/apis/\" + apiService.Spec.Group + \"/\" + apiService.Spec.Version\n\n\t\t\t\terrCh := make(chan error)\n\t\t\t\tgo func() {"
  },
  {
    "id" : "3376c719-034d-4ee1-b07d-562ba620d81c",
    "prId" : 75217,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/75217#pullrequestreview-224619347",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6b977444-8db5-4bf1-8f1b-5a91372ac9dd",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "why 5?",
        "createdAt" : "2019-03-11T23:36:24Z",
        "updatedAt" : "2019-04-09T18:31:29Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "a2c3fa8b-e22a-43cf-b263-f787941715a9",
        "parentId" : "6b977444-8db5-4bf1-8f1b-5a91372ac9dd",
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "> why 5?\r\n\r\nChosen not quite at random.  We run HA with three masters and I wanted a good chance of trying each of them.",
        "createdAt" : "2019-03-19T17:52:33Z",
        "updatedAt" : "2019-04-09T18:31:29Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      },
      {
        "id" : "9389057f-c9db-4dc4-a6e8-01cd31f364e5",
        "parentId" : "6b977444-8db5-4bf1-8f1b-5a91372ac9dd",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "Maybe it would be better to modify the service resolver to return the current list of endpoints.",
        "createdAt" : "2019-03-19T23:45:40Z",
        "updatedAt" : "2019-04-09T18:31:29Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "c2e33214-6b0a-4b6a-abbc-bef5b2f9203d",
        "parentId" : "6b977444-8db5-4bf1-8f1b-5a91372ac9dd",
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "@lavalamp See above, dns, service ips, and load balancers are all allowed.  The list may not have more than one endpoint, but still needs to be tried more than once",
        "createdAt" : "2019-03-20T00:31:11Z",
        "updatedAt" : "2019-04-09T18:31:29Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      },
      {
        "id" : "a56027c2-e1cc-4a98-819a-ac18ef725615",
        "parentId" : "6b977444-8db5-4bf1-8f1b-5a91372ac9dd",
        "authorId" : "7aca96c2-45d7-4567-99be-0323d7556c55",
        "body" : "Are we getting value from duplicate requests to the same discoveryURL? Would it make sense to get the list of urls and dedup?",
        "createdAt" : "2019-04-09T18:59:49Z",
        "updatedAt" : "2019-04-09T18:59:50Z",
        "lastEditedBy" : "7aca96c2-45d7-4567-99be-0323d7556c55",
        "tags" : [
        ]
      },
      {
        "id" : "c3293020-5cab-44e3-8374-f92cbe39a5aa",
        "parentId" : "6b977444-8db5-4bf1-8f1b-5a91372ac9dd",
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "> Are we getting value from duplicate requests to the same discoveryURL? Would it make sense to get the list of urls and dedup?\r\n\r\nSame question from jordan above.  The answer is yes.  The same URL can actually be backed by multiple destinations (kube-proxy IP mapping and DNS name mapping come to mind) and even if you have one, multiple requests to a flaky endpoint also have value.  Falling out of this list is severely disruptive to controllers like quota and lifecycle.",
        "createdAt" : "2019-04-09T19:51:19Z",
        "updatedAt" : "2019-04-09T19:51:19Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      }
    ],
    "commit" : "0f7185e7a53037a9a91f7a2e03a226ffaae80b97",
    "line" : 8,
    "diffHunk" : "@@ -1,1 +243,247 @@\t// actually try to hit the discovery endpoint when it isn't local and when we're routing as a service.\n\tif apiService.Spec.Service != nil && c.serviceResolver != nil {\n\t\tattempts := 5\n\t\tresults := make(chan error, attempts)\n\t\tfor i := 0; i < attempts; i++ {"
  },
  {
    "id" : "561f041b-7bef-4636-8759-d86c325aa63f",
    "prId" : 75126,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/75126#pullrequestreview-226293137",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c16b8f19-985d-4f6e-a197-e1ab6db1864e",
        "parentId" : null,
        "authorId" : "42b1e004-4fa7-4e43-84cf-5378839b49ad",
        "body" : "Looking at http.go, it seems code 300 is not treated as error:\r\n```\r\n\t\tif res.StatusCode >= http.StatusMultipleChoices { // Redirect\r\n\t\t\tklog.V(4).Infof(\"Probe terminated redirects for %s, Response: %v\", url.String(), *res)\r\n\t\t\treturn probe.Warning, body, nil\r\n```",
        "createdAt" : "2019-04-12T21:20:25Z",
        "updatedAt" : "2019-04-12T21:20:26Z",
        "lastEditedBy" : "42b1e004-4fa7-4e43-84cf-5378839b49ad",
        "tags" : [
        ]
      }
    ],
    "commit" : "f9e162086fad14db91268458fd4ce82aa7f8a8fa",
    "line" : 105,
    "diffHunk" : "@@ -1,1 +277,281 @@\t\t\t\t\t\tresp.Body.Close()\n\t\t\t\t\t\t// we should always been in the 200s or 300s\n\t\t\t\t\t\tif resp.StatusCode < http.StatusOK || resp.StatusCode >= http.StatusMultipleChoices {\n\t\t\t\t\t\t\terrCh <- fmt.Errorf(\"bad status from %v: %v\", discoveryURL, resp.StatusCode)\n\t\t\t\t\t\t\treturn"
  },
  {
    "id" : "8740d7b3-b94f-4da6-94f0-f2056603772a",
    "prId" : 71785,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/71785#pullrequestreview-182651472",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "159d6570-87fb-4d76-aad8-57b78bde014c",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "can we add a test that would have caught the issue?",
        "createdAt" : "2018-12-07T05:13:03Z",
        "updatedAt" : "2018-12-07T11:22:35Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "6829fc05-a29b-46d8-a437-429f96d2ad26",
        "parentId" : "159d6570-87fb-4d76-aad8-57b78bde014c",
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "done",
        "createdAt" : "2018-12-07T11:22:35Z",
        "updatedAt" : "2018-12-07T11:22:35Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      }
    ],
    "commit" : "7db6f7a89c1f1b4aeed8ae89b1c02e5921300383",
    "line" : 16,
    "diffHunk" : "@@ -1,1 +155,159 @@\t\tType:               apiregistration.Available,\n\t\tStatus:             apiregistration.ConditionTrue,\n\t\tLastTransitionTime: metav1.Now(),\n\t}\n"
  },
  {
    "id" : "38778dd7-ad99-4ef2-91f9-1d4903005d75",
    "prId" : 68678,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/68678#pullrequestreview-155547837",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7ca39dbc-64d9-4074-8ff2-04290c60d18d",
        "parentId" : null,
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "the default that is used for most controllers has a max retry time of 1000*seconds instead of 30 seconds like I've done here.",
        "createdAt" : "2018-09-14T15:30:17Z",
        "updatedAt" : "2018-09-14T15:30:17Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      }
    ],
    "commit" : "ed6b5a77df3372d35c1e7e98c8c727ebba9ae917",
    "line" : 9,
    "diffHunk" : "@@ -1,1 +93,97 @@\t\t\t// service network, it is possible for an external, non-watchable factor to affect availability.  This keeps\n\t\t\t// the maximum disruption time to a minimum, but it does prevent hot loops.\n\t\t\tworkqueue.NewItemExponentialFailureRateLimiter(5*time.Millisecond, 30*time.Second),\n\t\t\t\"AvailableConditionController\"),\n\t}"
  },
  {
    "id" : "420f4f83-0929-469f-b23e-fd8ecfc21a6e",
    "prId" : 55165,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/55165#pullrequestreview-74428077",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3a9bf248-5816-4f30-9ff5-de97b2e0b3cf",
        "parentId" : null,
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "How many threads does the controller have? Each will be blocked for 30 seconds in the worst-case.",
        "createdAt" : "2017-11-06T13:49:52Z",
        "updatedAt" : "2017-11-09T14:49:32Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      },
      {
        "id" : "d72dfaae-4b8b-4142-8468-cb6fe3a27524",
        "parentId" : "3a9bf248-5816-4f30-9ff5-de97b2e0b3cf",
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "> How many threads does the controller have? Each will be blocked for 30 seconds in the worst-case.\r\n\r\nEach will be blocked at most 6 seconds, right?  We have a time.After block.  I've updated the code to start 5. \r\n\r\nWe don't back up infinitely since the queue.Add is fair (first in, first out) and eliminates duplicates.  I can make it more if you like.",
        "createdAt" : "2017-11-06T14:12:12Z",
        "updatedAt" : "2017-11-09T14:49:32Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      },
      {
        "id" : "6afcf403-4aeb-499f-acba-f5c4a9519efa",
        "parentId" : "3a9bf248-5816-4f30-9ff5-de97b2e0b3cf",
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "Sounds good now. If we handle a handful external apiservers, it's ok.",
        "createdAt" : "2017-11-06T14:16:01Z",
        "updatedAt" : "2017-11-09T14:49:32Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      }
    ],
    "commit" : "b7bc9b11dd192afd9f9e155757a7e6f4b895408a",
    "line" : 47,
    "diffHunk" : "@@ -1,1 +116,120 @@\t\t\tDeleteFunc: c.deleteAPIService,\n\t\t},\n\t\t30*time.Second)\n\n\tserviceInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs{"
  },
  {
    "id" : "20c81ef8-9b13-4477-8d22-3670b039f9b9",
    "prId" : 55165,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/55165#pullrequestreview-75522062",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "53ac36ba-3029-4e40-ab6e-55c88e3dfe10",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "pre-existing, but call SetTransportDefaults on this?",
        "createdAt" : "2017-11-09T17:31:58Z",
        "updatedAt" : "2017-11-09T17:31:58Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "b7bc9b11dd192afd9f9e155757a7e6f4b895408a",
    "line" : 26,
    "diffHunk" : "@@ -1,1 +95,99 @@\t// that's not so bad) and sets a very short timeout.\n\tdiscoveryClient := &http.Client{\n\t\tTransport: &http.Transport{\n\t\t\tTLSClientConfig: &tls.Config{InsecureSkipVerify: true},\n\t\t},"
  },
  {
    "id" : "ad95aaff-c04c-4796-903c-2d701f8c48b5",
    "prId" : 47347,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/47347#pullrequestreview-70549563",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b084893b-d699-42c4-9022-9ed9c79dc6c5",
        "parentId" : null,
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "worth a retry on conflict?",
        "createdAt" : "2017-10-19T07:39:56Z",
        "updatedAt" : "2017-10-19T14:07:10Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      },
      {
        "id" : "db9c2c2a-9399-47f2-98a7-c30ada6caefd",
        "parentId" : "b084893b-d699-42c4-9022-9ed9c79dc6c5",
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "> worth a retry on conflict?\r\n\r\nNo.  It'll retry with a backoff based on the normal controller flow.",
        "createdAt" : "2017-10-19T11:04:39Z",
        "updatedAt" : "2017-10-19T14:07:10Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      },
      {
        "id" : "36a215c1-bcc3-4c61-a2f2-8c251ee04b39",
        "parentId" : "b084893b-d699-42c4-9022-9ed9c79dc6c5",
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "Which might take a while, but maybe good enough here.",
        "createdAt" : "2017-10-19T11:08:36Z",
        "updatedAt" : "2017-10-19T14:07:10Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      },
      {
        "id" : "2474f581-6f26-4e58-8bac-65af1b61c630",
        "parentId" : "b084893b-d699-42c4-9022-9ed9c79dc6c5",
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "> Which might take a while, but maybe good enough here.\r\n\r\nBy default, it retries fast a few times and slows down.",
        "createdAt" : "2017-10-19T14:07:01Z",
        "updatedAt" : "2017-10-19T14:07:10Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      }
    ],
    "commit" : "f6fde0ba549b2af985367ecf1729bb4129d43567",
    "line" : 99,
    "diffHunk" : "@@ -1,1 +234,238 @@\t\t\t_, updateErr := c.apiServiceClient.APIServices().UpdateStatus(apiService)\n\t\t\tif updateErr != nil {\n\t\t\t\treturn updateErr\n\t\t\t}\n\t\t\t// force a requeue to make it very obvious that this will be retried at some point in the future"
  },
  {
    "id" : "95c21c03-03db-4351-b9b1-763d9ee59a98",
    "prId" : 47347,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/47347#pullrequestreview-70900280",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9a41b640-9a3f-4ba2-be4a-51ab5d71410b",
        "parentId" : null,
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : ":+1:",
        "createdAt" : "2017-10-20T16:41:16Z",
        "updatedAt" : "2017-10-20T16:41:16Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      }
    ],
    "commit" : "f6fde0ba549b2af985367ecf1729bb4129d43567",
    "line" : 86,
    "diffHunk" : "@@ -1,1 +221,225 @@\t\tcase err = <-errCh:\n\n\t\t// we had trouble with slow dial and DNS responses causing us to wait too long.\n\t\t// we added this as insurance\n\t\tcase <-time.After(6 * time.Second):"
  },
  {
    "id" : "ccfe817c-0865-46f7-81a3-bce288763eca",
    "prId" : 45432,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/45432#pullrequestreview-37005632",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2ed116d3-8703-4d91-b296-0e3576443f8d",
        "parentId" : null,
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "a nil cloner should work here too. You don't have embedded runtime.Objects where you need that.",
        "createdAt" : "2017-05-09T10:02:53Z",
        "updatedAt" : "2017-05-09T13:52:54Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      },
      {
        "id" : "f8be8714-f283-4acd-8b32-c947c3dacf84",
        "parentId" : "2ed116d3-8703-4d91-b296-0e3576443f8d",
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "> a nil cloner should work here too. You don't have embedded runtime.Objects where you need that.\r\n\r\nI tried nil.  It panic'ed.  I didn't dig into why.",
        "createdAt" : "2017-05-09T11:38:56Z",
        "updatedAt" : "2017-05-09T13:52:54Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      }
    ],
    "commit" : "272aa2434dd81fd24857f687fd32750e1ca2294a",
    "line" : 117,
    "diffHunk" : "@@ -1,1 +115,119 @@\n\tapiService := &apiregistration.APIService{}\n\tif err := apiregistration.DeepCopy_apiregistration_APIService(inAPIService, apiService, cloner); err != nil {\n\t\treturn err\n\t}"
  }
]
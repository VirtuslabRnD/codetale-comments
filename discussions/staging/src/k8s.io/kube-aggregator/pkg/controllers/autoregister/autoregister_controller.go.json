[
  {
    "id" : "e883f32d-efe5-4bcf-b323-d2e4ac6948f0",
    "prId" : 72919,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/72919#pullrequestreview-192981419",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "064d62f6-7016-4f17-886c-c3dde7a553e8",
        "parentId" : null,
        "authorId" : "bc182326-9017-48d6-8ee0-4609046c1366",
        "body" : "i was doubting the unconditional deletion here is the cause of flooding error reported in this thread previously [https://github.com/kubernetes/kubernetes/issues/70287](https://github.com/kubernetes/kubernetes/issues/70287). ocassionally, we might hit similar problem where the aggregators in HA setup is racing between creating/deleting apiservices. the same apiservice keeps being created by one aggregator but instantly deleted by another aggregator. so even an invalid apiservice might be popped from backoff queuing if it's ephemeral one.  (am not really sure so i didn't submit this change w/ a conclusion)\r\n\r\n[https://github.com/kubernetes/kubernetes/blob/3478647333c91689cf4c737012a60e6d70a661e7/staging/src/k8s.io/kube-aggregator/pkg/controllers/status/available_controller.go#L145-L147](https://github.com/kubernetes/kubernetes/blob/3478647333c91689cf4c737012a60e6d70a661e7/staging/src/k8s.io/kube-aggregator/pkg/controllers/status/available_controller.go#L145-L147)",
        "createdAt" : "2019-01-16T05:47:30Z",
        "updatedAt" : "2019-01-16T05:47:31Z",
        "lastEditedBy" : "bc182326-9017-48d6-8ee0-4609046c1366",
        "tags" : [
        ]
      }
    ],
    "commit" : "42f23bda18f574893ca9eebab2995197851f13d1",
    "line" : 25,
    "diffHunk" : "@@ -1,1 +260,264 @@\tcase desired == nil:\n\t\topts := &metav1.DeleteOptions{Preconditions: metav1.NewUIDPreconditions(string(curr.UID))}\n\t\terr := c.apiServiceClient.APIServices().Delete(curr.Name, opts)\n\t\tif apierrors.IsNotFound(err) || apierrors.IsConflict(err) {\n\t\t\t// deleted or changed in the meantime, we'll get called again"
  }
]
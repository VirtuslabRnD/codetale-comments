[
  {
    "id" : "99fea8d1-eede-4862-b247-7412ec9f1062",
    "prId" : 70995,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/70995#pullrequestreview-174710840",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2b9cafcd-8f39-4701-8c52-50e3744646c0",
        "parentId" : null,
        "authorId" : "fa530650-5886-4415-a42f-0dee2e0e9ae3",
        "body" : "Wish Go would catch these automatically...",
        "createdAt" : "2018-11-13T12:34:25Z",
        "updatedAt" : "2018-11-13T12:34:25Z",
        "lastEditedBy" : "fa530650-5886-4415-a42f-0dee2e0e9ae3",
        "tags" : [
        ]
      },
      {
        "id" : "ea70f732-8c74-401e-aa58-2ba57c3870ad",
        "parentId" : "2b9cafcd-8f39-4701-8c52-50e3744646c0",
        "authorId" : "05637862-b60e-403e-8519-09d1b3f0c9c2",
        "body" : "will find some check tool exists or not",
        "createdAt" : "2018-11-14T06:21:03Z",
        "updatedAt" : "2018-11-14T06:21:04Z",
        "lastEditedBy" : "05637862-b60e-403e-8519-09d1b3f0c9c2",
        "tags" : [
        ]
      }
    ],
    "commit" : "217dbeafaf3293d193d6bdf3a8a220329d55dfe9",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +150,154 @@// workers to finish processing their current work items.\nfunc (c *Controller) Run(threadiness int, stopCh <-chan struct{}) error {\n\tdefer utilruntime.HandleCrash()\n\tdefer c.workqueue.ShutDown()\n"
  },
  {
    "id" : "263b21a5-9132-4f7c-8319-1d2a6b3740c1",
    "prId" : 70031,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/70031#pullrequestreview-168951460",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "48ba4183-0f7f-449e-bbc5-22b03bdc25f9",
        "parentId" : null,
        "authorId" : "093f4806-3f92-4191-a80b-4e6cf3d6ffc0",
        "body" : "could you check whether the error is transient before adding it back to the queue?",
        "createdAt" : "2018-10-25T21:22:25Z",
        "updatedAt" : "2018-10-25T21:22:25Z",
        "lastEditedBy" : "093f4806-3f92-4191-a80b-4e6cf3d6ffc0",
        "tags" : [
        ]
      },
      {
        "id" : "a44f0aea-b814-4c94-b0f1-60d8703f02e6",
        "parentId" : "48ba4183-0f7f-449e-bbc5-22b03bdc25f9",
        "authorId" : "189f8426-5405-480f-a4c5-03829abcf69b",
        "body" : "I'm not sure how the error checking would work from here. Its currently up to the syncHandler to decide which errors are transient and which aren't. If an error is transient then the syncHandler method returns that error as it does [here](https://github.com/kubernetes/kubernetes/blob/8f86654b8e23bbf960a286712df35c003f7389f8/staging/src/k8s.io/sample-controller/controller.go#L304-L309). If its a non-transient error then the syncHandler calls `runtime.HandleError(...)` and returns nil as it does [here](https://github.com/kubernetes/kubernetes/blob/8f86654b8e23bbf960a286712df35c003f7389f8/staging/src/k8s.io/sample-controller/controller.go#L266-L272).\r\n\r\nThis change just ensures that the transient errors are actually put back on the queue.",
        "createdAt" : "2018-10-26T18:39:14Z",
        "updatedAt" : "2018-10-26T18:39:15Z",
        "lastEditedBy" : "189f8426-5405-480f-a4c5-03829abcf69b",
        "tags" : [
        ]
      }
    ],
    "commit" : "8f86654b8e23bbf960a286712df35c003f7389f8",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +220,224 @@\t\t// Foo resource to be synced.\n\t\tif err := c.syncHandler(key); err != nil {\n\t\t\t// Put the item back on the workqueue to handle any transient errors.\n\t\t\tc.workqueue.AddRateLimited(key)\n\t\t\treturn fmt.Errorf(\"error syncing '%s': %s, requeuing\", key, err.Error())"
  },
  {
    "id" : "d309c91b-72f6-44e5-862b-0cfe08f2fcca",
    "prId" : 60021,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/60021#pullrequestreview-108904448",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "11c209a1-9e42-487f-bbe9-053337f718dd",
        "parentId" : null,
        "authorId" : "fa530650-5886-4415-a42f-0dee2e0e9ae3",
        "body" : "Just added a comment here.",
        "createdAt" : "2018-02-23T17:31:22Z",
        "updatedAt" : "2018-02-23T17:31:22Z",
        "lastEditedBy" : "fa530650-5886-4415-a42f-0dee2e0e9ae3",
        "tags" : [
        ]
      },
      {
        "id" : "aa12b980-306f-423f-a413-7b6c0d436aa6",
        "parentId" : "11c209a1-9e42-487f-bbe9-053337f718dd",
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : ":+1:",
        "createdAt" : "2018-04-03T11:12:44Z",
        "updatedAt" : "2018-04-03T11:12:44Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      }
    ],
    "commit" : "68db7fe8b040d43fc2b888f1331b2845c31a201b",
    "line" : 12,
    "diffHunk" : "@@ -1,1 +332,336 @@\t// UpdateStatus will not allow changes to the Spec of the resource,\n\t// which is ideal for ensuring nothing other than resource status has been updated.\n\t_, err := c.sampleclientset.SamplecontrollerV1alpha1().Foos(foo.Namespace).Update(fooCopy)\n\treturn err\n}"
  },
  {
    "id" : "bbebbb22-07d7-4e6a-95fb-f2717e670529",
    "prId" : 52753,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/52753#pullrequestreview-68208053",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "cc6d225a-8d24-4025-9cd5-e52414d82b3a",
        "parentId" : null,
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "UpdateStatus is just created in the client, but has no server counterpart (until we have subresources for CRDs, proposal is being discussed).\r\n\r\nTo get rid of UpdateStatue here, please use the noStatus tag, compare https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/code-generator/cmd/client-gen/generators/generator_for_type.go#L535.",
        "createdAt" : "2017-10-10T07:47:59Z",
        "updatedAt" : "2017-10-18T23:22:10Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      },
      {
        "id" : "5924f85e-3e71-498b-a5bf-a7bdd31ea1f6",
        "parentId" : "cc6d225a-8d24-4025-9cd5-e52414d82b3a",
        "authorId" : "c5a78ad1-2727-48a6-8217-285a102b94de",
        "body" : "Done",
        "createdAt" : "2017-10-10T08:55:57Z",
        "updatedAt" : "2017-10-18T23:22:10Z",
        "lastEditedBy" : "c5a78ad1-2727-48a6-8217-285a102b94de",
        "tags" : [
        ]
      }
    ],
    "commit" : "740afa0e65bf44a95752fb863017a7cf14b476ad",
    "line" : 330,
    "diffHunk" : "@@ -1,1 +328,332 @@\tfooCopy := foo.DeepCopy()\n\tfooCopy.Status.AvailableReplicas = deployment.Status.AvailableReplicas\n\t// Until #38113 is merged, we must use Update instead of UpdateStatus to\n\t// update the Status block of the Foo resource. UpdateStatus will not\n\t// allow changes to the Spec of the resource, which is ideal for ensuring"
  },
  {
    "id" : "c4b19c4b-e28f-41e2-88a1-930a37c940cc",
    "prId" : 52753,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/52753#pullrequestreview-68208171",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b21f4ffa-e620-4bdf-8121-10ceb4c2b750",
        "parentId" : null,
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "for the delete case we get a tombstone here, i.e. the cast will fail. This need special logic in the informer event handler.",
        "createdAt" : "2017-10-10T07:51:36Z",
        "updatedAt" : "2017-10-18T23:22:10Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      },
      {
        "id" : "055c6899-0786-473d-b1bf-2235c2e98749",
        "parentId" : "b21f4ffa-e620-4bdf-8121-10ceb4c2b750",
        "authorId" : "c5a78ad1-2727-48a6-8217-285a102b94de",
        "body" : "I've updated this accordingly. Please check over the changes here to make sure they look okay: https://github.com/kubernetes/kubernetes/pull/52753/commits/9151172943a50f28b16735e9e29890012cdc7017\r\n",
        "createdAt" : "2017-10-10T08:56:22Z",
        "updatedAt" : "2017-10-18T23:22:10Z",
        "lastEditedBy" : "c5a78ad1-2727-48a6-8217-285a102b94de",
        "tags" : [
        ]
      }
    ],
    "commit" : "740afa0e65bf44a95752fb863017a7cf14b476ad",
    "line" : 359,
    "diffHunk" : "@@ -1,1 +357,361 @@\tvar object metav1.Object\n\tvar ok bool\n\tif object, ok = obj.(metav1.Object); !ok {\n\t\ttombstone, ok := obj.(cache.DeletedFinalStateUnknown)\n\t\tif !ok {"
  },
  {
    "id" : "a61c645e-88e6-48c1-aa1b-1ef34c030382",
    "prId" : 52753,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/52753#pullrequestreview-78907405",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "49e81711-6834-46d5-af87-282dda980bd2",
        "parentId" : null,
        "authorId" : "11efe503-096f-46dd-a8c8-28ba38a0157a",
        "body" : "You need to add the key back to the queue here with ratelimiting. At least, that's what most if not all of the core controllers are doing since most of the errors are transient.",
        "createdAt" : "2017-10-12T17:44:12Z",
        "updatedAt" : "2017-10-18T23:22:10Z",
        "lastEditedBy" : "11efe503-096f-46dd-a8c8-28ba38a0157a",
        "tags" : [
        ]
      },
      {
        "id" : "e9dc9e5e-d7f1-4d99-9825-0f22bb1d0daf",
        "parentId" : "49e81711-6834-46d5-af87-282dda980bd2",
        "authorId" : "c5a78ad1-2727-48a6-8217-285a102b94de",
        "body" : "I didn't think this was required with a rate limit queue (explicitly putting the item back on the queue).\r\n\r\nBy not calling `Forget` on the key here due to the error, I thought the item was automatically requeued? (we instead only call `Done` a few lines above with `defer c.workqueue.Done(obj)`).\r\n\r\nI'll update the Add call to use `AddRateLimited`. Please do correct me if I'm wrong above as that's how I've designed most of my controllers!",
        "createdAt" : "2017-10-12T17:46:46Z",
        "updatedAt" : "2017-10-18T23:22:10Z",
        "lastEditedBy" : "c5a78ad1-2727-48a6-8217-285a102b94de",
        "tags" : [
        ]
      },
      {
        "id" : "6be82569-f97b-4267-a707-6c0ef64a7560",
        "parentId" : "49e81711-6834-46d5-af87-282dda980bd2",
        "authorId" : "11efe503-096f-46dd-a8c8-28ba38a0157a",
        "body" : "cc @deads2k ",
        "createdAt" : "2017-10-12T17:54:45Z",
        "updatedAt" : "2017-10-18T23:22:10Z",
        "lastEditedBy" : "11efe503-096f-46dd-a8c8-28ba38a0157a",
        "tags" : [
        ]
      },
      {
        "id" : "ff68ba34-51cb-46d6-a851-c47d80cf913a",
        "parentId" : "49e81711-6834-46d5-af87-282dda980bd2",
        "authorId" : "3711ddf4-736b-4962-a90f-2670674bd3f1",
        "body" : "@munnerz  I think either your assumption is wrong or there's something wrong with how rate limiting queue is implemented. If you don't add the key back it won't be requeued. Here's a simple test:\r\n```\r\nqueue := workqueue.NewNamedRateLimitingQueue(workqueue.DefaultControllerRateLimiter(), \"TEST\")\r\nqueue.AddRateLimited(\"stuff\")\r\n\r\ngot, _ := queue.Get()\r\nfmt.Printf(\"%s\\n\", got)\r\nqueue.Done(got)\r\n\r\ngot2, _ := queue.Get()\r\nfmt.Printf(\"%s\\n\", got2)\r\n```\r\nThe sesond `Get()` will never return even though we didn't call `Forget()` and we expect the object to still be in the queue.",
        "createdAt" : "2017-11-24T12:53:19Z",
        "updatedAt" : "2017-11-24T12:54:54Z",
        "lastEditedBy" : "3711ddf4-736b-4962-a90f-2670674bd3f1",
        "tags" : [
        ]
      }
    ],
    "commit" : "740afa0e65bf44a95752fb863017a7cf14b476ad",
    "line" : 226,
    "diffHunk" : "@@ -1,1 +224,228 @@\t\t// Foo resource to be synced.\n\t\tif err := c.syncHandler(key); err != nil {\n\t\t\treturn fmt.Errorf(\"error syncing '%s': %s\", key, err.Error())\n\t\t}\n\t\t// Finally, if no error occurs we Forget this item so it does not"
  }
]
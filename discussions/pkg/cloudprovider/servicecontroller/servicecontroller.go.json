[
  {
    "id" : "9ad8126c-554a-4d2d-b6a6-b296783939f7",
    "prId" : 7251,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "cd851b2d-6a4b-4071-8df3-b094c43ae45e",
        "parentId" : null,
        "authorId" : "c2b5c827-efcd-438f-8db5-52d917b1cde9",
        "body" : "This looks like a func that should be in a util package (or might be already). If you think it's reusable, I'd move it there so that we don't get similar functions sprinkled around the code base. \n",
        "createdAt" : "2015-04-24T04:15:00Z",
        "updatedAt" : "2015-04-24T18:44:37Z",
        "lastEditedBy" : "c2b5c827-efcd-438f-8db5-52d917b1cde9",
        "tags" : [
        ]
      },
      {
        "id" : "1cdc604d-dd0c-41cf-9da5-db8297ce3d59",
        "parentId" : "cd851b2d-6a4b-4071-8df3-b094c43ae45e",
        "authorId" : "7766e039-aa4c-4476-9091-5cc8763fa8d6",
        "body" : "It could be reusable, but would be a bit of a trap since it can sometimes modify the inputs if they have the same length and aren't already sorted. I'm hesitant to move it somewhere common for that reason.\n",
        "createdAt" : "2015-04-24T17:40:04Z",
        "updatedAt" : "2015-04-24T18:44:37Z",
        "lastEditedBy" : "7766e039-aa4c-4476-9091-5cc8763fa8d6",
        "tags" : [
        ]
      }
    ],
    "commit" : "5d9564b1cc5c4c9b7226490a002f3a9125f2bd4b",
    "line" : 50,
    "diffHunk" : "@@ -1,1 +468,472 @@}\n\nfunc intSlicesEqual(x, y []int) bool {\n\tif len(x) != len(y) {\n\t\treturn false"
  },
  {
    "id" : "6ff5e0bc-f71b-4e0d-912f-f701616f8a15",
    "prId" : 7251,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c2448ca1-0713-4f36-ab4c-18694b88b932",
        "parentId" : null,
        "authorId" : "c2b5c827-efcd-438f-8db5-52d917b1cde9",
        "body" : "same here\n",
        "createdAt" : "2015-04-24T04:15:05Z",
        "updatedAt" : "2015-04-24T18:44:37Z",
        "lastEditedBy" : "c2b5c827-efcd-438f-8db5-52d917b1cde9",
        "tags" : [
        ]
      }
    ],
    "commit" : "5d9564b1cc5c4c9b7226490a002f3a9125f2bd4b",
    "line" : 72,
    "diffHunk" : "@@ -1,1 +486,490 @@}\n\nfunc stringSlicesEqual(x, y []string) bool {\n\tif len(x) != len(y) {\n\t\treturn false"
  },
  {
    "id" : "2d2e53a1-3cd8-4665-9e5c-c95b3f1baea7",
    "prId" : 7251,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "931a0ea4-defd-4e0f-b1dc-3d0816f7f199",
        "parentId" : null,
        "authorId" : "c2b5c827-efcd-438f-8db5-52d917b1cde9",
        "body" : "if err := ...; err == nil { return nil }\n",
        "createdAt" : "2015-04-24T04:20:36Z",
        "updatedAt" : "2015-04-24T18:44:37Z",
        "lastEditedBy" : "c2b5c827-efcd-438f-8db5-52d917b1cde9",
        "tags" : [
        ]
      },
      {
        "id" : "b07cf4a5-4af4-40b2-ab17-6830ed4aea80",
        "parentId" : "931a0ea4-defd-4e0f-b1dc-3d0816f7f199",
        "authorId" : "7766e039-aa4c-4476-9091-5cc8763fa8d6",
        "body" : "We should chat about this sometime. It appears we have very different opinions about the usefulness of this style that come up all the time, and it'd be nice to get one of us on the same page as the other.\n",
        "createdAt" : "2015-04-24T17:33:20Z",
        "updatedAt" : "2015-04-24T18:44:37Z",
        "lastEditedBy" : "7766e039-aa4c-4476-9091-5cc8763fa8d6",
        "tags" : [
        ]
      }
    ],
    "commit" : "5d9564b1cc5c4c9b7226490a002f3a9125f2bd4b",
    "line" : 153,
    "diffHunk" : "@@ -1,1 +573,577 @@\n\tname := cloudprovider.GetLoadBalancerName(service)\n\terr := s.balancer.UpdateTCPLoadBalancer(name, s.zone.Region, hosts)\n\tif err == nil {\n\t\treturn nil"
  },
  {
    "id" : "bf5cb180-4a30-4c7c-b455-003af498dbd7",
    "prId" : 6271,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d5ceb063-8830-4512-becd-2b722ba8c9c2",
        "parentId" : null,
        "authorId" : null,
        "body" : "Having an arbitrarily long sleep buried deep in your code like this can be dangerous.   Let me go through the rest of your code before proposing alternatives.  \n",
        "createdAt" : "2015-04-02T23:03:29Z",
        "updatedAt" : "2015-04-15T00:30:35Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "63825a4f-6568-462d-8fc7-f1ea502e207f",
        "parentId" : "d5ceb063-8830-4512-becd-2b722ba8c9c2",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Retry and waits should be handled outside this loop - I believe lavalamp was in the process of establishing a generic controller framework for retryable errors based in part on work @ironcladlou had done for Openshift.  Don't know how far that has progressed.  If it's lower in the queue we can push on that a bit more (Ben recently added qps limits on retries to our version which prevents hot failure loops)\n",
        "createdAt" : "2015-04-03T04:15:11Z",
        "updatedAt" : "2015-04-15T00:30:35Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      }
    ],
    "commit" : "fc08a0a71b7a8b00271da28c14c4d0897c502988",
    "line" : null,
    "diffHunk" : "@@ -1,1 +145,149 @@\t\t\t// Add the failed service back to the queue so we'll retry it.\n\t\t\tglog.Errorf(\"Failed to process service delta. Retrying: %v\", err)\n\t\t\ttime.Sleep(5 * time.Second)\n\t\t\tserviceQueue.AddIfNotPresent(deltas)\n\t\t} else if err != nil {"
  },
  {
    "id" : "52aff1c3-8e4d-4f4f-9fdb-3dddf4fb1104",
    "prId" : 6271,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b4098599-8633-4b12-9501-062aae34af08",
        "parentId" : null,
        "authorId" : null,
        "body" : "Won't this create an unnecessarily long break in network connectivity to the service?  Can it not rather be updated in place?\n",
        "createdAt" : "2015-04-02T23:06:25Z",
        "updatedAt" : "2015-04-15T00:30:35Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "73e67a4a-6a1e-465e-906e-034b3ace2a73",
        "parentId" : "b4098599-8633-4b12-9501-062aae34af08",
        "authorId" : "7766e039-aa4c-4476-9091-5cc8763fa8d6",
        "body" : "That's a very fair point. Unfortunately, GCE forwarding rules can't be updated in place other than to point them at a different target pool.\n\nHowever, we can break down the problem a bit. The reasons we may need to update an external load balancer (as you can determine from the needsUpdate function) are if (a) the public IPs changed, or (b) the ports changed.\n\nThere are a couple alternative ways to handle these that might be worth considering. For changing ports, we could:\n1. Create a new forwarding rule pointed at the same target pool with the new ports, then update the REST object with the new IP address this would create, then delete the old one. The downside is that this would require changing the IP and tracking the names of the forwarding rules rather than knowing exactly what the name could be.\n2. Always set the port range to be 1-65535, regardless of which ports the service actually uses. Then we can disregard changes to the port numbers.\n3. Accept a bit of downtime, but at least keep the IP around. Reserve the IP the FW is using, then delete the old FW, then create the new one with the correct IP, then un-reserve the IP. However, reserving IPs is GCE-specific, so it'd have to go in the GCE cloud provider implementation of create and update load balancer.\n\nFor changing IP addresses, we could:\n1. The same as option 1 above.\n2. Put the IP address in the name of the load balancer, so that we could easily create the new one while the old one still exists while still having deterministic names. It'd be tricky to do this for new load balancers, though.\n\nFor now, accepting a bit of downtime on service update doesn't seem absurd, but we could try one of these other options as a future issue.\n\nReally, it seems like IP addresses chosen by the cloud provider should be in the service's status, not the service's spec, since this code can't determine whether the IP address was user-specified and needs to be respected vs whether it was arbitrarily chosen by the cloud provider when the previous balancer was created. Do you or @thockin think this sort of change is feasible given the recent switch to v1beta3?\n",
        "createdAt" : "2015-04-03T18:19:06Z",
        "updatedAt" : "2015-04-15T00:30:35Z",
        "lastEditedBy" : "7766e039-aa4c-4476-9091-5cc8763fa8d6",
        "tags" : [
        ]
      }
    ],
    "commit" : "fc08a0a71b7a8b00271da28c14c4d0897c502988",
    "line" : null,
    "diffHunk" : "@@ -1,1 +221,225 @@\tif cachedService != nil {\n\t\t// If the service already exists but needs to be updated, delete it so that\n\t\t// we can recreate it cleanly.\n\t\tif cachedService.Spec.CreateExternalLoadBalancer {\n\t\t\tglog.Infof(\"Deleting existing load balancer for service %s that needs an updated load balancer.\", namespacedName)"
  },
  {
    "id" : "5e477069-d5c0-4aea-bef5-64ddd8e027ab",
    "prId" : 6271,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "402d1809-dc46-4ee1-8bcc-1126069f526d",
        "parentId" : null,
        "authorId" : null,
        "body" : "How do you avoid the situation where the rate of change of services exceeds the rate at which you are able to update the external load balancers?  Given the serial way in which you do updates (if I'm reading the code correctly), and the number of places in which you sleep for seconds at a time, I'm concerned. \n",
        "createdAt" : "2015-04-02T23:12:42Z",
        "updatedAt" : "2015-04-15T00:30:35Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "86cf400d-a3c6-439b-b917-d094d9e86406",
        "parentId" : "402d1809-dc46-4ee1-8bcc-1126069f526d",
        "authorId" : "7766e039-aa4c-4476-9091-5cc8763fa8d6",
        "body" : "Yeah, this is pretty terrible. I'll add in the parallelism now, such that each service can be processed separately from each other, but changes to an individual service will be done serially.\n",
        "createdAt" : "2015-04-03T18:20:07Z",
        "updatedAt" : "2015-04-15T00:30:35Z",
        "lastEditedBy" : "7766e039-aa4c-4476-9091-5cc8763fa8d6",
        "tags" : [
        ]
      }
    ],
    "commit" : "fc08a0a71b7a8b00271da28c14c4d0897c502988",
    "line" : 303,
    "diffHunk" : "@@ -1,1 +301,305 @@\t\tglog.Warningf(\"Failed to persist updated PublicIPs to service %s after creating its external load balancer: %v\",\n\t\t\tservice.Name, err)\n\t\ttime.Sleep(clientRetryInterval)\n\t}\n\treturn err"
  },
  {
    "id" : "14715011-5fb7-43c8-ab3f-d6ec47104cd2",
    "prId" : 6271,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0230ce22-a44d-43f1-8cc6-36412d933d29",
        "parentId" : null,
        "authorId" : null,
        "body" : "Do you need to consider identical sets that are ordered differently?  Perhaps sort before comparing?\n",
        "createdAt" : "2015-04-02T23:31:47Z",
        "updatedAt" : "2015-04-15T00:30:35Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "9a0b9bc7-480d-4f51-b91a-03ed09241c71",
        "parentId" : "0230ce22-a44d-43f1-8cc6-36412d933d29",
        "authorId" : "7766e039-aa4c-4476-9091-5cc8763fa8d6",
        "body" : "I just pulled this code from the REST handler, but that's a fair point, since it doesn't look like our validation functions require them to be sorted.\n\nSince go's sorting functions are in-place and I'd rather not modify the user-specified order, I just used a map for checking the equality.\n",
        "createdAt" : "2015-04-03T18:41:56Z",
        "updatedAt" : "2015-04-15T00:30:35Z",
        "lastEditedBy" : "7766e039-aa4c-4476-9091-5cc8763fa8d6",
        "tags" : [
        ]
      }
    ],
    "commit" : "fc08a0a71b7a8b00271da28c14c4d0897c502988",
    "line" : null,
    "diffHunk" : "@@ -1,1 +451,455 @@\tsort.Ints(xPorts)\n\tsort.Ints(yPorts)\n\tfor i := range xPorts {\n\t\tif xPorts[i] != yPorts[i] {\n\t\t\treturn false"
  },
  {
    "id" : "1d6cd8e9-f8e1-4d38-83ee-381e15632995",
    "prId" : 6271,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9d56ef0d-75d1-4513-88c5-6993afb65e27",
        "parentId" : null,
        "authorId" : null,
        "body" : "You're masking the error here again buy just logging it an returning success. You need to return an error so that the caller can reget and retry to update against the new version.\n",
        "createdAt" : "2015-04-13T23:06:48Z",
        "updatedAt" : "2015-04-15T00:30:35Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "38e89fcd-b8ee-4042-8a21-6fbfaa85786f",
        "parentId" : "9d56ef0d-75d1-4513-88c5-6993afb65e27",
        "authorId" : "7766e039-aa4c-4476-9091-5cc8763fa8d6",
        "body" : "What's the error? Unless If the service no longer exists, it must have been deleted. If it was deleted, we don't want to re-create it, we just want to bail out so that we can process the deletion event. I've tried explaining this in a new comment, but please tell me if I'm missing something or this isn't clear.\n",
        "createdAt" : "2015-04-14T18:32:47Z",
        "updatedAt" : "2015-04-15T00:30:35Z",
        "lastEditedBy" : "7766e039-aa4c-4476-9091-5cc8763fa8d6",
        "tags" : [
        ]
      },
      {
        "id" : "717bd3be-4c0e-44c8-9ac1-aaf2624232a0",
        "parentId" : "9d56ef0d-75d1-4513-88c5-6993afb65e27",
        "authorId" : null,
        "body" : "Good point.  Agreed.\n",
        "createdAt" : "2015-04-14T18:52:36Z",
        "updatedAt" : "2015-04-15T00:30:35Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "fc08a0a71b7a8b00271da28c14c4d0897c502988",
    "line" : null,
    "diffHunk" : "@@ -1,1 +289,293 @@\t\t// if we haven't already.\n\t\tif errors.IsNotFound(err) {\n\t\t\tglog.Infof(\"Not persisting update to service that no longer exists: %v\", err)\n\t\t\treturn nil\n\t\t}"
  }
]
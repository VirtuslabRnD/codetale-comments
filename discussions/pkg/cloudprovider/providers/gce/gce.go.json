[
  {
    "id" : "bbfaa67e-754a-42b7-a2dd-5ecb19ff0041",
    "prId" : 71547,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/71547#pullrequestreview-180317761",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "50b9dee2-f499-4cff-9789-9f78f7090515",
        "parentId" : null,
        "authorId" : "7aca96c2-45d7-4567-99be-0323d7556c55",
        "body" : "Missing \"var _ cloudprovider.Clusters = (*Cloud)(nil)\"",
        "createdAt" : "2018-11-29T22:38:36Z",
        "updatedAt" : "2018-11-30T15:33:45Z",
        "lastEditedBy" : "7aca96c2-45d7-4567-99be-0323d7556c55",
        "tags" : [
        ]
      },
      {
        "id" : "64cf9c12-f87f-4806-a0b4-dc1ef87d5c9f",
        "parentId" : "50b9dee2-f499-4cff-9789-9f78f7090515",
        "authorId" : "6dd71efb-88b1-4bb0-b30a-0df658362f14",
        "body" : "updated!",
        "createdAt" : "2018-11-30T15:33:51Z",
        "updatedAt" : "2018-11-30T15:33:51Z",
        "lastEditedBy" : "6dd71efb-88b1-4bb0-b30a-0df658362f14",
        "tags" : [
        ]
      }
    ],
    "commit" : "4b0f2ab4428d58c530415de308b041e395cdfb22",
    "line" : 9,
    "diffHunk" : "@@ -1,1 +104,108 @@var _ cloudprovider.Routes = (*Cloud)(nil)\nvar _ cloudprovider.Zones = (*Cloud)(nil)\nvar _ cloudprovider.PVLabeler = (*Cloud)(nil)\nvar _ cloudprovider.Clusters = (*Cloud)(nil)\n"
  },
  {
    "id" : "34ec24f0-d1f0-4aee-8bfa-365fc4f906ad",
    "prId" : 70099,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/70099#pullrequestreview-167654062",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3c1c3988-460b-44ab-b6a8-39956ee04a00",
        "parentId" : null,
        "authorId" : "b714f738-aa05-4f49-a624-eaaf3e0cbb70",
        "body" : "We should be reducing the gceHcUnhealthyThreshold to 3, otherwise it will be very unresponsive.",
        "createdAt" : "2018-10-23T09:16:08Z",
        "updatedAt" : "2018-10-25T00:55:49Z",
        "lastEditedBy" : "b714f738-aa05-4f49-a624-eaaf3e0cbb70",
        "tags" : [
        ]
      },
      {
        "id" : "95aa022f-2ccd-46bc-a1cd-1f92f4fdd400",
        "parentId" : "3c1c3988-460b-44ab-b6a8-39956ee04a00",
        "authorId" : "80560558-3a5b-4f4a-99dd-e7c57c8394b7",
        "body" : "Done.",
        "createdAt" : "2018-10-23T21:54:54Z",
        "updatedAt" : "2018-10-25T00:55:49Z",
        "lastEditedBy" : "80560558-3a5b-4f4a-99dd-e7c57c8394b7",
        "tags" : [
        ]
      }
    ],
    "commit" : "40ab479f06d061106581173b8543a49d086fb710",
    "line" : 10,
    "diffHunk" : "@@ -1,1 +85,89 @@\tgceHcTimeoutSeconds       = int64(1)\n\t// Start sending requests as soon as a pod is found on the node.\n\tgceHcHealthyThreshold = int64(1)\n\t// Defaults to 3 * 8 = 24 seconds before the LB will steer traffic away.\n\tgceHcUnhealthyThreshold = int64(3)"
  },
  {
    "id" : "a2f62db0-4d7b-43a5-b96c-ca7878217acc",
    "prId" : 69388,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/69388#pullrequestreview-163034151",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bdc622d1-4072-47dc-aa15-a434c7e15d8f",
        "parentId" : null,
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "regional and multimaster have somewhat different meanings (I can imagine multi master but all in the same zone, for example). Can we converge on a single term and use it everywhere?",
        "createdAt" : "2018-10-05T19:54:50Z",
        "updatedAt" : "2018-10-09T18:29:02Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "65f5ed61-c6fb-483c-9f95-93edc5299ffe",
        "parentId" : "bdc622d1-4072-47dc-aa15-a434c7e15d8f",
        "authorId" : "7aca96c2-45d7-4567-99be-0323d7556c55",
        "body" : "Switched to using regional up front. Also added comment/warning at beginning over changes needed for HA/Zonal.",
        "createdAt" : "2018-10-09T18:29:49Z",
        "updatedAt" : "2018-10-09T18:29:49Z",
        "lastEditedBy" : "7aca96c2-45d7-4567-99be-0323d7556c55",
        "tags" : [
        ]
      }
    ],
    "commit" : "8b3099ced7ed84f90f6ac04ae38eb33e07205853",
    "line" : 30,
    "diffHunk" : "@@ -1,1 +338,342 @@\t// Determine if its a regional cluster\n\tif configFile != nil && configFile.Global.Regional {\n\t\tcloudConfig.Regional = true\n\t}\n"
  },
  {
    "id" : "1a039075-b6d4-4c65-9804-bf10eb5ba719",
    "prId" : 56394,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/56394#pullrequestreview-96896125",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "522d2523-8e08-44a7-9ac3-a032d5fc7335",
        "parentId" : null,
        "authorId" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "body" : "Can you also add a jitter parameter? maybe 0.2",
        "createdAt" : "2018-02-15T15:46:51Z",
        "updatedAt" : "2018-02-15T15:46:51Z",
        "lastEditedBy" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "tags" : [
        ]
      }
    ],
    "commit" : "3a5d48700cbb8bcbd928bb2c6621e4da13a9be1a",
    "line" : 9,
    "diffHunk" : "@@ -1,1 +832,836 @@\t\tDuration: time.Second,\n\t\tFactor:   1.4,\n\t\tSteps:    10,\n\t}\n\tif err := wait.ExponentialBackoff(backoff, func() (bool, error) {"
  },
  {
    "id" : "b4ba7e4e-3e7a-4038-b2fc-7cb4e344d57f",
    "prId" : 52437,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/52437#pullrequestreview-66222101",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e0ba04a8-9656-47c4-8004-498b2bbc254d",
        "parentId" : null,
        "authorId" : "b714f738-aa05-4f49-a624-eaaf3e0cbb70",
        "body" : "Should probably send exact version, including prelease tags to be completely accurate.",
        "createdAt" : "2017-09-29T17:43:27Z",
        "updatedAt" : "2017-09-29T20:56:02Z",
        "lastEditedBy" : "b714f738-aa05-4f49-a624-eaaf3e0cbb70",
        "tags" : [
        ]
      }
    ],
    "commit" : "7aa9a46067a9adc829017540e47f6f7e17e13acf",
    "line" : 20,
    "diffHunk" : "@@ -1,1 +346,350 @@// If managedZones is nil / empty all zones in the region will be managed.\nfunc CreateGCECloud(config *CloudConfig) (*GCECloud, error) {\n\t// Remove any pre-release version and build metadata from the semver, leaving only the MAJOR.MINOR.PATCH portion.\n\t// See http://semver.org/.\n\tversion := strings.TrimLeft(strings.Split(strings.Split(version.Get().GitVersion, \"-\")[0], \"+\")[0], \"v\")"
  },
  {
    "id" : "3ec50d29-1367-4642-a306-0fb07b1492c8",
    "prId" : 52322,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/52322#pullrequestreview-77860893",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e70eb00b-8cb2-4b26-b87f-e1ddc3682aea",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "on large scale clusters, this can get called 5000 times every 10 seconds. short-circuit if `newNode.Labels[kubeletapis.LabelZoneFailureDomain] == prevNode.Labels[kubeletapis.LabelZoneFailureDomain]`?",
        "createdAt" : "2017-11-20T17:27:49Z",
        "updatedAt" : "2017-11-21T00:04:36Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "e5aec8645d740123dfc8f1400b66bca05673b833",
    "line" : 86,
    "diffHunk" : "@@ -1,1 +606,610 @@\t\tUpdateFunc: func(prev, obj interface{}) {\n\t\t\tprevNode := prev.(*v1.Node)\n\t\t\tnewNode := obj.(*v1.Node)\n\t\t\tif newNode.Labels[kubeletapis.LabelZoneFailureDomain] ==\n\t\t\t\tprevNode.Labels[kubeletapis.LabelZoneFailureDomain] {"
  },
  {
    "id" : "f8306712-a616-4aeb-b010-776c5192955b",
    "prId" : 50467,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/50467#pullrequestreview-56706916",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "40832d9b-1c13-46fc-8788-36fd7f208503",
        "parentId" : null,
        "authorId" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "body" : "I assume this is exported so that other controllers (e.g., ingress) can check the value. ",
        "createdAt" : "2017-08-16T16:07:14Z",
        "updatedAt" : "2017-08-22T18:05:27Z",
        "lastEditedBy" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "tags" : [
        ]
      },
      {
        "id" : "494175d5-dd37-4d60-a023-d9c29c1341e7",
        "parentId" : "40832d9b-1c13-46fc-8788-36fd7f208503",
        "authorId" : "e83108b8-1fb2-416b-9298-d5b70c14f708",
        "body" : "Yeah I think so. ",
        "createdAt" : "2017-08-16T17:35:50Z",
        "updatedAt" : "2017-08-22T18:05:28Z",
        "lastEditedBy" : "e83108b8-1fb2-416b-9298-d5b70c14f708",
        "tags" : [
        ]
      }
    ],
    "commit" : "c04ba4eab5e7e0c8b6c51d852eac18d9c6a24da8",
    "line" : 8,
    "diffHunk" : "@@ -1,1 +123,127 @@\t// the corresponding api is enabled.\n\t// If not enabled, it should return error.\n\tAlphaFeatureGate *AlphaFeatureGate\n}\n"
  },
  {
    "id" : "1d749d93-e8d1-46fb-94df-25e483b99ae3",
    "prId" : 50467,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/50467#pullrequestreview-57333254",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "92d765e5-a6a6-4a0d-a1fb-ef091a5d9041",
        "parentId" : null,
        "authorId" : "b714f738-aa05-4f49-a624-eaaf3e0cbb70",
        "body" : "add an example to what the alpha feature flag (MyFeatureFlag)",
        "createdAt" : "2017-08-18T23:45:49Z",
        "updatedAt" : "2017-08-22T18:05:28Z",
        "lastEditedBy" : "b714f738-aa05-4f49-a624-eaaf3e0cbb70",
        "tags" : [
        ]
      }
    ],
    "commit" : "c04ba4eab5e7e0c8b6c51d852eac18d9c6a24da8",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +122,126 @@\t// Related wrapper functions that interacts with gce alpha api should examine whether\n\t// the corresponding api is enabled.\n\t// If not enabled, it should return error.\n\tAlphaFeatureGate *AlphaFeatureGate\n}"
  },
  {
    "id" : "802f0638-3aec-4c62-be49-07e617da40c9",
    "prId" : 49215,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/49215#pullrequestreview-51300470",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9b9c76e3-fe76-4d00-9a23-593fc8cc74ea",
        "parentId" : null,
        "authorId" : "a5ac91f3-1cbc-4fd9-af85-741ee28dd9c8",
        "body" : "Golint naming: receiver name gce should be consistent with previous receiver name g for GCECloud. [More info](https://golang.org/wiki/CodeReviewComments#receiver-names). <!-- golint -->",
        "createdAt" : "2017-07-19T20:08:44Z",
        "updatedAt" : "2017-08-10T13:42:29Z",
        "lastEditedBy" : "a5ac91f3-1cbc-4fd9-af85-741ee28dd9c8",
        "tags" : [
        ]
      },
      {
        "id" : "7b95a3d7-1a7a-429f-ac87-8709625594aa",
        "parentId" : "9b9c76e3-fe76-4d00-9a23-593fc8cc74ea",
        "authorId" : "aee8926e-0646-4183-b0d7-65633cf782b0",
        "body" : "This is not correct.  What I have is consistent with existing code",
        "createdAt" : "2017-07-20T11:49:27Z",
        "updatedAt" : "2017-08-10T13:42:29Z",
        "lastEditedBy" : "aee8926e-0646-4183-b0d7-65633cf782b0",
        "tags" : [
        ]
      },
      {
        "id" : "4ec269d6-6e1a-431b-be2b-fb7703df025c",
        "parentId" : "9b9c76e3-fe76-4d00-9a23-593fc8cc74ea",
        "authorId" : "c532215f-ed76-4a19-b066-8676d269eaf1",
        "body" : "I see. It's [g](https://github.com/kubernetes/kubernetes/blob/088141ca3a193feab943375bcc564db1a66ef58a/pkg/cloudprovider/providers/gce/gce.go#L159-L172) at one part of the file and [gce](https://github.com/kubernetes/kubernetes/blob/088141ca3a193feab943375bcc564db1a66ef58a/pkg/cloudprovider/providers/gce/gce.go#L342-L396) for the rest. Your code is fine here, feel free to ignore the lint message :)",
        "createdAt" : "2017-07-20T17:07:38Z",
        "updatedAt" : "2017-08-10T13:42:29Z",
        "lastEditedBy" : "c532215f-ed76-4a19-b066-8676d269eaf1",
        "tags" : [
        ]
      },
      {
        "id" : "ace28fcd-37fc-43c9-8bcc-923db4339384",
        "parentId" : "9b9c76e3-fe76-4d00-9a23-593fc8cc74ea",
        "authorId" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "body" : "Or fix the other part of the file.",
        "createdAt" : "2017-07-20T17:28:05Z",
        "updatedAt" : "2017-08-10T13:42:29Z",
        "lastEditedBy" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "tags" : [
        ]
      },
      {
        "id" : "2fa5d044-1b95-4e91-b7bc-4a41f5c766f1",
        "parentId" : "9b9c76e3-fe76-4d00-9a23-593fc8cc74ea",
        "authorId" : "aee8926e-0646-4183-b0d7-65633cf782b0",
        "body" : "I could rather do that cleanup as a part of a separate PR.  It really isn't related to this PR.",
        "createdAt" : "2017-07-20T19:04:24Z",
        "updatedAt" : "2017-08-10T13:42:29Z",
        "lastEditedBy" : "aee8926e-0646-4183-b0d7-65633cf782b0",
        "tags" : [
        ]
      }
    ],
    "commit" : "926f070719f98a1fd3a811898cbcb90c919b3d56",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +471,475 @@\n// HasClusterID returns true if the cluster has a clusterID\nfunc (gce *GCECloud) HasClusterID() bool {\n\treturn true\n}"
  },
  {
    "id" : "156487ae-1e90-4e06-8d95-6cc03fa9ea75",
    "prId" : 48902,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/48902#pullrequestreview-49907914",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "201f3e26-7baa-4ca1-81a0-2d02457c75a1",
        "parentId" : null,
        "authorId" : "3e4fca9c-38d2-48b7-8f51-aa84ce73e592",
        "body" : "There are a few other calls to `gceNetworkURL` - why do they get apiEndpiont instead of \"\"?",
        "createdAt" : "2017-07-13T21:13:19Z",
        "updatedAt" : "2017-07-13T21:13:19Z",
        "lastEditedBy" : "3e4fca9c-38d2-48b7-8f51-aa84ce73e592",
        "tags" : [
        ]
      }
    ],
    "commit" : "a471140e13531f94378c8f87b6b1d8ac190c0ddf",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +189,193 @@\t\treturn nil, err\n\t}\n\tnetworkURL := gceNetworkURL(\"\", projectID, networkName)\n\tsubnetworkURL := \"\"\n"
  },
  {
    "id" : "61a43643-9153-4b8f-a94b-5cba4dc07aca",
    "prId" : 48642,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/48642#pullrequestreview-49059114",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1e2376e2-63c2-4a70-9db2-2ec8b6e06f18",
        "parentId" : null,
        "authorId" : "b714f738-aa05-4f49-a624-eaaf3e0cbb70",
        "body" : "`err` seems to be not checked here",
        "createdAt" : "2017-07-10T23:48:09Z",
        "updatedAt" : "2017-07-12T22:10:30Z",
        "lastEditedBy" : "b714f738-aa05-4f49-a624-eaaf3e0cbb70",
        "tags" : [
        ]
      },
      {
        "id" : "eec20771-dc2c-4413-9a12-56c2bab9c7c0",
        "parentId" : "1e2376e2-63c2-4a70-9db2-2ec8b6e06f18",
        "authorId" : "b714f738-aa05-4f49-a624-eaaf3e0cbb70",
        "body" : "fix the instance above too",
        "createdAt" : "2017-07-10T23:48:35Z",
        "updatedAt" : "2017-07-12T22:10:30Z",
        "lastEditedBy" : "b714f738-aa05-4f49-a624-eaaf3e0cbb70",
        "tags" : [
        ]
      }
    ],
    "commit" : "3e8b4a27c48aae548234bef0a4e87c54e4a03ef2",
    "line" : 47,
    "diffHunk" : "@@ -1,1 +278,282 @@\t}\n\n\tclient, err = newOauthClient(tokenSource)\n\tif err != nil {\n\t\treturn nil, err"
  },
  {
    "id" : "7dc9e409-4c1c-4834-8d0f-2f0792d0d407",
    "prId" : 48642,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/48642#pullrequestreview-49059114",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8a922c98-e959-4c81-8822-f55d91019368",
        "parentId" : null,
        "authorId" : "b714f738-aa05-4f49-a624-eaaf3e0cbb70",
        "body" : "`err` seems to be not checked here",
        "createdAt" : "2017-07-10T23:48:14Z",
        "updatedAt" : "2017-07-12T22:10:30Z",
        "lastEditedBy" : "b714f738-aa05-4f49-a624-eaaf3e0cbb70",
        "tags" : [
        ]
      }
    ],
    "commit" : "3e8b4a27c48aae548234bef0a4e87c54e4a03ef2",
    "line" : 56,
    "diffHunk" : "@@ -1,1 +287,291 @@\t}\n\n\tclient, err = newOauthClient(tokenSource)\n\tif err != nil {\n\t\treturn nil, err"
  },
  {
    "id" : "e84de9a5-01c0-4ef6-a4bf-724427d7a796",
    "prId" : 48574,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/48574#pullrequestreview-59050258",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5bf598ab-1e22-4f31-8a80-24689dfed72a",
        "parentId" : null,
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "I take it, this is the dependency you weren't sure of?  I'm ok with this, I'd also be ok moving out of the cloudprovider proper and doing it inside of a wiring package that knows about both.  Having the dependency go like this is better than the other way around.",
        "createdAt" : "2017-08-28T18:15:11Z",
        "updatedAt" : "2017-08-29T05:48:04Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      },
      {
        "id" : "41d8fafb-650f-4b10-95ad-bfbaa4da47cc",
        "parentId" : "5bf598ab-1e22-4f31-8a80-24689dfed72a",
        "authorId" : "bfe6ebf1-cfa7-4758-abb1-9960fa09b194",
        "body" : "Agree that this dep is ok; the other way around would not",
        "createdAt" : "2017-08-28T20:00:43Z",
        "updatedAt" : "2017-08-29T05:48:04Z",
        "lastEditedBy" : "bfe6ebf1-cfa7-4758-abb1-9960fa09b194",
        "tags" : [
        ]
      }
    ],
    "commit" : "3e11baf702a25a83ca79cd5d335c8ebe19ee61ce",
    "line" : 28,
    "diffHunk" : "@@ -1,1 +445,449 @@\tkmsPluginRegisterOnce.Do(func() {\n\t\t// Register the Google Cloud KMS based service in the KMS plugin registry.\n\t\tencryptionconfig.KMSPluginRegistry.Register(KMSServiceName, func(config io.Reader) (envelope.Service, error) {\n\t\t\treturn gce.getGCPCloudKMSService(config)\n\t\t})"
  },
  {
    "id" : "1ba4b259-d245-4537-97f5-3a935edcb3b0",
    "prId" : 46457,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/46457#pullrequestreview-40853765",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3f2700c1-c6eb-4781-b13a-a275d48af4ff",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "Why does this need to be public?  If it does, comment.  It is different than all the others, so explain.",
        "createdAt" : "2017-05-30T03:16:40Z",
        "updatedAt" : "2017-05-30T03:40:10Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "2bcd762c-a6eb-4e5f-8450-8f4b3aa8bc7a",
        "parentId" : "3f2700c1-c6eb-4781-b13a-a275d48af4ff",
        "authorId" : "3e4fca9c-38d2-48b7-8f51-aa84ce73e592",
        "body" : "I'll add a comment to this affect - other controllers, such as ingress, can utilize this instead of having their own logic. ",
        "createdAt" : "2017-05-30T05:12:40Z",
        "updatedAt" : "2017-05-30T05:12:40Z",
        "lastEditedBy" : "3e4fca9c-38d2-48b7-8f51-aa84ce73e592",
        "tags" : [
        ]
      }
    ],
    "commit" : "9063526dfb50918f20b3cde941aba3ac45966afc",
    "line" : 12,
    "diffHunk" : "@@ -1,1 +79,83 @@// GCECloud is an implementation of Interface, LoadBalancer and Instances for Google Compute Engine.\ntype GCECloud struct {\n\tClusterID ClusterID\n\n\tservice                  *compute.Service"
  },
  {
    "id" : "5e67d886-0e0f-4e8f-b54c-8cb0b172f076",
    "prId" : 46366,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/46366#pullrequestreview-40175867",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a6ee925e-d4bd-4858-9ee8-428a4abda29d",
        "parentId" : null,
        "authorId" : "b714f738-aa05-4f49-a624-eaaf3e0cbb70",
        "body" : "seems like the args should just be a struct, but we can do that in a different PR",
        "createdAt" : "2017-05-24T23:27:44Z",
        "updatedAt" : "2017-05-24T23:28:40Z",
        "lastEditedBy" : "b714f738-aa05-4f49-a624-eaaf3e0cbb70",
        "tags" : [
        ]
      }
    ],
    "commit" : "e7ee3913d7083c51e8e310f03f986382e0bc093b",
    "line" : 53,
    "diffHunk" : "@@ -1,1 +185,189 @@// If no tokenSource is specified, uses oauth2.DefaultTokenSource.\n// If managedZones is nil / empty all zones in the region will be managed.\nfunc CreateGCECloud(projectID, region, zone string, managedZones []string, networkURL, subnetworkURL string, nodeTags []string,\n\tnodeInstancePrefix string, tokenSource oauth2.TokenSource, useMetadataServer bool) (*GCECloud, error) {\n"
  },
  {
    "id" : "7f151ea1-cbd7-4ac0-9522-37c1e69c85a6",
    "prId" : 46147,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/46147#pullrequestreview-39554383",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e2b86b84-ddd8-44f9-a931-ea0266a57286",
        "parentId" : null,
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "I'm not familiar with this bit of the code. Which process is calling this?",
        "createdAt" : "2017-05-22T13:03:18Z",
        "updatedAt" : "2017-05-23T21:11:54Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      },
      {
        "id" : "c083ed8c-4655-4d0c-abbc-018fc90be725",
        "parentId" : "e2b86b84-ddd8-44f9-a931-ea0266a57286",
        "authorId" : "3e4fca9c-38d2-48b7-8f51-aa84ce73e592",
        "body" : "`kube-controller-manager` & `cloud-controller-manager` do.\r\n\r\nThe GCE cloud provider is hitting some growing pains with regard to the rigid *cloud* interface. With the eventual removal of cloud providers from the kubernetes repo (and cloud-dependent controllers), `Initialize` should become defunct in the long run. ",
        "createdAt" : "2017-05-22T18:36:31Z",
        "updatedAt" : "2017-05-23T21:11:54Z",
        "lastEditedBy" : "3e4fca9c-38d2-48b7-8f51-aa84ce73e592",
        "tags" : [
        ]
      }
    ],
    "commit" : "729303f0dedd92a88c5995315737fe2a7d584ec9",
    "line" : 17,
    "diffHunk" : "@@ -1,1 +239,243 @@// Initialize takes in a clientBuilder and spawns a goroutine for watching the clusterid configmap.\n// This must be called before utilizing the funcs of gce.ClusterId\nfunc (gce *GCECloud) Initialize(clientBuilder controller.ControllerClientBuilder) {\n\tgce.clientBuilder = clientBuilder\n\tgo gce.watchClusterId()"
  },
  {
    "id" : "ac3e5706-e8ee-4d15-9963-c68964d72fbc",
    "prId" : 46147,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/46147#pullrequestreview-39827870",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "57dbe074-d3ee-46f3-9c44-985761a312ec",
        "parentId" : null,
        "authorId" : "b714f738-aa05-4f49-a624-eaaf3e0cbb70",
        "body" : "Seems to be a abstract leakage to document so specifically (eg. the watch), probably should just state that `Initialize` may spawn go routines to perform housekeeping activities.",
        "createdAt" : "2017-05-23T18:23:56Z",
        "updatedAt" : "2017-05-23T21:11:54Z",
        "lastEditedBy" : "b714f738-aa05-4f49-a624-eaaf3e0cbb70",
        "tags" : [
        ]
      }
    ],
    "commit" : "729303f0dedd92a88c5995315737fe2a7d584ec9",
    "line" : 15,
    "diffHunk" : "@@ -1,1 +237,241 @@}\n\n// Initialize takes in a clientBuilder and spawns a goroutine for watching the clusterid configmap.\n// This must be called before utilizing the funcs of gce.ClusterId\nfunc (gce *GCECloud) Initialize(clientBuilder controller.ControllerClientBuilder) {"
  },
  {
    "id" : "5461fc07-10e8-42da-8898-409879e85998",
    "prId" : 46147,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/46147#pullrequestreview-39929407",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "462f27d8-e29a-4278-ae88-dda300c567ae",
        "parentId" : null,
        "authorId" : "b714f738-aa05-4f49-a624-eaaf3e0cbb70",
        "body" : "Should this block waiting for the initialization? Is the rest of the code ok with this as an async update?",
        "createdAt" : "2017-05-24T05:58:00Z",
        "updatedAt" : "2017-05-24T05:58:09Z",
        "lastEditedBy" : "b714f738-aa05-4f49-a624-eaaf3e0cbb70",
        "tags" : [
        ]
      }
    ],
    "commit" : "729303f0dedd92a88c5995315737fe2a7d584ec9",
    "line" : 17,
    "diffHunk" : "@@ -1,1 +239,243 @@// Initialize takes in a clientBuilder and spawns a goroutine for watching the clusterid configmap.\n// This must be called before utilizing the funcs of gce.ClusterId\nfunc (gce *GCECloud) Initialize(clientBuilder controller.ControllerClientBuilder) {\n\tgce.clientBuilder = clientBuilder\n\tgo gce.watchClusterId()"
  },
  {
    "id" : "e0268a5f-cdfa-4a82-b04f-6d0395b93143",
    "prId" : 45524,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/45524#pullrequestreview-40589661",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "35a8f7ac-85f7-44ad-8a10-0afdd24d8cf2",
        "parentId" : null,
        "authorId" : "b714f738-aa05-4f49-a624-eaaf3e0cbb70",
        "body" : "[minor] move to top in its own block as this is public",
        "createdAt" : "2017-05-26T18:26:50Z",
        "updatedAt" : "2017-05-26T20:19:31Z",
        "lastEditedBy" : "b714f738-aa05-4f49-a624-eaaf3e0cbb70",
        "tags" : [
        ]
      }
    ],
    "commit" : "897da549bc37390e4847946da63da29dc9d1b4c2",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +82,86 @@\tcontainerService         *container.Service\n\tclientBuilder            controller.ControllerClientBuilder\n\tClusterID                ClusterID\n\tprojectID                string\n\tregion                   string"
  },
  {
    "id" : "bf0bdd99-3851-4f6f-a01d-675c3e357107",
    "prId" : 40338,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/40338#pullrequestreview-29726212",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7072de5b-bef9-4f37-bb21-1249979f1f29",
        "parentId" : null,
        "authorId" : "a7f673a6-4b23-4df6-aa10-f123fa9dcd5f",
        "body" : "are seconds too high for latency?",
        "createdAt" : "2017-03-29T13:36:28Z",
        "updatedAt" : "2017-03-29T13:36:28Z",
        "lastEditedBy" : "a7f673a6-4b23-4df6-aa10-f123fa9dcd5f",
        "tags" : [
        ]
      },
      {
        "id" : "fe098686-b52b-4f3f-a994-54b636318c47",
        "parentId" : "7072de5b-bef9-4f37-bb21-1249979f1f29",
        "authorId" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "body" : "According to https://prometheus.io/docs/practices/naming/#metric-names metrics should use base units. I guess we should be okay, since we are reporting seconds as floats anyways. ",
        "createdAt" : "2017-03-29T13:49:32Z",
        "updatedAt" : "2017-03-29T13:49:32Z",
        "lastEditedBy" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "tags" : [
        ]
      }
    ],
    "commit" : "c4aaf47282fe6bf1c370eb6d7ef958045e2384b3",
    "line" : 52,
    "diffHunk" : "@@ -1,1 +130,134 @@\n\tapiResponseReceived := func(resp *http.Response) {\n\t\ttimeTaken := time.Since(requestTime).Seconds()\n\t\tif mi, ok := gceMetricMap[apiNamespace.apiCall]; ok {\n\t\t\tmi.WithLabelValues(apiNamespace.namespace).Observe(timeTaken)"
  },
  {
    "id" : "81986e52-7668-4ba0-85c4-07d981991a81",
    "prId" : 34859,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/34859#pullrequestreview-6153382",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7a466f2b-4901-4586-bf1c-a54462111ba3",
        "parentId" : null,
        "authorId" : "8fc8f958-3c0e-47dd-a0fb-b8cc483b4efb",
        "body" : "Do we want to require that we return InstanceNotFound here, as we do for ExternalID?\n",
        "createdAt" : "2016-10-26T18:42:58Z",
        "updatedAt" : "2016-10-28T16:25:23Z",
        "lastEditedBy" : "8fc8f958-3c0e-47dd-a0fb-b8cc483b4efb",
        "tags" : [
        ]
      },
      {
        "id" : "02e04c26-f266-421f-8fe7-4a15d93f2da3",
        "parentId" : "7a466f2b-4901-4586-bf1c-a54462111ba3",
        "authorId" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "body" : "Could you please point to me where ExternalID you mean? Here the logic is if instance does not exist from cloud provider, we assume volumes are all detached. Please let me know if you think this is any issue in this assumption.\n",
        "createdAt" : "2016-10-26T21:54:50Z",
        "updatedAt" : "2016-10-28T16:25:23Z",
        "lastEditedBy" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "tags" : [
        ]
      },
      {
        "id" : "b1effb16-b11d-4544-8526-feaa0e76cd5d",
        "parentId" : "7a466f2b-4901-4586-bf1c-a54462111ba3",
        "authorId" : "8fc8f958-3c0e-47dd-a0fb-b8cc483b4efb",
        "body" : "What you're doing is fine.  In `ExternalID` in the cloudprovider, we just always return cloudprovider.InstanceNotFound if the instance is not found.  Here it would avoid the duplication of code for this case across the providers.\n",
        "createdAt" : "2016-10-27T21:52:51Z",
        "updatedAt" : "2016-10-28T16:25:23Z",
        "lastEditedBy" : "8fc8f958-3c0e-47dd-a0fb-b8cc483b4efb",
        "tags" : [
        ]
      }
    ],
    "commit" : "abbde4337485d0286ab51bbebff54ff02eb33694",
    "line" : 29,
    "diffHunk" : "@@ -1,1 +2670,2674 @@\t\t\t\tinstanceName,\n\t\t\t\tdiskNames)\n\t\t\treturn attached, nil\n\t\t}\n"
  },
  {
    "id" : "3988865d-2906-45e3-8dcb-1ee41401e230",
    "prId" : 31828,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "af523d2d-aacf-4769-85ee-716671c58062",
        "parentId" : null,
        "authorId" : "395f4f9a-98be-4485-b436-51f0897d7c9f",
        "body" : "can you clarify in a comment when/if we come through and cleanup this leak in the case of an error? \n",
        "createdAt" : "2016-09-02T22:13:00Z",
        "updatedAt" : "2016-09-06T18:36:06Z",
        "lastEditedBy" : "395f4f9a-98be-4485-b436-51f0897d7c9f",
        "tags" : [
        ]
      }
    ],
    "commit" : "81b36aaba612995bd2aac3fb5d27981c1dde734a",
    "line" : null,
    "diffHunk" : "@@ -1,1 +1471,1475 @@\t\t// during HC deletion in a prior pass through EnsureLoadBalancer.\n\t\t// The HC name matches the load balancer name - normally this is expected to fail.\n\t\tif err := gce.DeleteHttpHealthCheck(name); err == nil {\n\t\t\t// We only print a warning if this deletion actually succeeded (which\n\t\t\t// means there was indeed a stale health check with the LB name."
  },
  {
    "id" : "6ec2307b-9005-4160-937c-0123344c43b1",
    "prId" : 31828,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6e18df2d-2a0e-41a5-9972-7e9108edad46",
        "parentId" : null,
        "authorId" : "395f4f9a-98be-4485-b436-51f0897d7c9f",
        "body" : "if the previous call to GetHttpHealthCheck flaked for some random network connectivity reason throwing an error, and you create it again here, you'll get a StatusConflict and end up retrying (good, because we should've retried the first get anway) but the error message will be wrong. \n\nSuggest checking the error and returning the right message, and only creating if we need to. \n",
        "createdAt" : "2016-09-02T22:13:03Z",
        "updatedAt" : "2016-09-06T18:36:06Z",
        "lastEditedBy" : "395f4f9a-98be-4485-b436-51f0897d7c9f",
        "tags" : [
        ]
      }
    ],
    "commit" : "81b36aaba612995bd2aac3fb5d27981c1dde734a",
    "line" : null,
    "diffHunk" : "@@ -1,1 +740,744 @@\t\t\ttpNeedsUpdate = true\n\t\t}\n\t\thcToCreate, err = gce.ensureHttpHealthCheck(loadBalancerName, path, healthCheckNodePort)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"Failed to ensure health check for localized service %v on node port %v: %v\", loadBalancerName, healthCheckNodePort, err)"
  },
  {
    "id" : "cd6dd410-18ab-46c8-9ec5-0c15b254c64d",
    "prId" : 31828,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6b110d9c-69cb-48a1-a410-71952934c794",
        "parentId" : null,
        "authorId" : "395f4f9a-98be-4485-b436-51f0897d7c9f",
        "body" : "won't we leak a health check in this case? \n",
        "createdAt" : "2016-09-02T22:13:06Z",
        "updatedAt" : "2016-09-06T18:36:06Z",
        "lastEditedBy" : "395f4f9a-98be-4485-b436-51f0897d7c9f",
        "tags" : [
        ]
      }
    ],
    "commit" : "81b36aaba612995bd2aac3fb5d27981c1dde734a",
    "line" : 48,
    "diffHunk" : "@@ -1,1 +774,778 @@\t\t\thcExisting, err = gce.GetHttpHealthCheck(loadBalancerName)\n\t\t\tif err != nil && !isHTTPErrorCode(err, http.StatusNotFound) {\n\t\t\t\tglog.Infof(\"Failed to retrieve health check %v:%v\", loadBalancerName, err)\n\t\t\t}\n\t\t}"
  },
  {
    "id" : "40ebbac2-5d27-4e8f-93e6-730df9d25519",
    "prId" : 31828,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ee431ab3-3db4-47f5-9638-7864d3787eb3",
        "parentId" : null,
        "authorId" : "395f4f9a-98be-4485-b436-51f0897d7c9f",
        "body" : "we should make the implications of toggling the annotation very clear in the alpha limitations section of the official doc (it'll lead to recreating targetpools which causes downtime). \n",
        "createdAt" : "2016-09-09T18:22:26Z",
        "updatedAt" : "2016-09-09T18:22:26Z",
        "lastEditedBy" : "395f4f9a-98be-4485-b436-51f0897d7c9f",
        "tags" : [
        ]
      }
    ],
    "commit" : "81b36aaba612995bd2aac3fb5d27981c1dde734a",
    "line" : 18,
    "diffHunk" : "@@ -1,1 +734,738 @@\t\t\t// This logic exists to detect a transition for a pre-existing service and turn on\n\t\t\t// the tpNeedsUpdate flag to delete/recreate fwdrule/tpool adding the health check\n\t\t\t// to the target pool.\n\t\t\tglog.V(2).Infof(\"Annotation %s=%s added to new or pre-existing service\",\n\t\t\t\tapiservice.AnnotationExternalTraffic,"
  },
  {
    "id" : "831e6ded-3afa-4e76-888e-d0059a341094",
    "prId" : 29082,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "127b9247-701d-41a7-a5d6-da2fb8ce5ec3",
        "parentId" : null,
        "authorId" : "8076e56f-768c-4f89-90e6-045ef34e1525",
        "body" : "Not sure about this one. I think SessionAffinity == \"\" might be equivalent to SessionAffinity NONE.\n",
        "createdAt" : "2016-07-18T02:48:52Z",
        "updatedAt" : "2016-07-18T05:00:42Z",
        "lastEditedBy" : "8076e56f-768c-4f89-90e6-045ef34e1525",
        "tags" : [
        ]
      },
      {
        "id" : "44c8a2dd-ac63-4495-b863-fffaf8a70de5",
        "parentId" : "127b9247-701d-41a7-a5d6-da2fb8ce5ec3",
        "authorId" : "395f4f9a-98be-4485-b436-51f0897d7c9f",
        "body" : "safety first? this will just prevent the resync for session affinity. or would you prefer treating empty as none? \n",
        "createdAt" : "2016-07-18T02:50:45Z",
        "updatedAt" : "2016-07-18T05:00:42Z",
        "lastEditedBy" : "395f4f9a-98be-4485-b436-51f0897d7c9f",
        "tags" : [
        ]
      },
      {
        "id" : "fe31fe12-184b-4c57-ad8c-c47f7e69ca71",
        "parentId" : "127b9247-701d-41a7-a5d6-da2fb8ce5ec3",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "yeah, can we get clarity on that and document it here?\n",
        "createdAt" : "2016-07-18T03:02:04Z",
        "updatedAt" : "2016-07-18T05:00:42Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "00521d7f-be5d-4b4e-8b44-bfdc519301d9",
        "parentId" : "127b9247-701d-41a7-a5d6-da2fb8ce5ec3",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "Can you comnment this REALLY REALLY well, please?  Explain what we're checking and why.\n",
        "createdAt" : "2016-07-18T03:09:42Z",
        "updatedAt" : "2016-07-18T05:00:42Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "a9426a19c96ff893025644315bf5989a764607d6",
    "line" : null,
    "diffHunk" : "@@ -1,1 +841,845 @@\t// target pool (which results in downtime). Fix this when we have formally\n\t// defined the defaults on either side.\n\tif tp.SessionAffinity != \"\" && translateAffinityType(affinityType) != tp.SessionAffinity {\n\t\tglog.Infof(\"LoadBalancer target pool %v changed affinity from %v to %v\", name, tp.SessionAffinity, affinityType)\n\t\treturn true, true, nil"
  },
  {
    "id" : "2ac33988-301c-4e9f-808f-5b0199f618ff",
    "prId" : 29082,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a31046e7-cb9e-46db-9251-e210139e2f43",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "Can you comment this better, something like \"if the user asked for an IP, check we are using it\"\n",
        "createdAt" : "2016-07-18T03:08:17Z",
        "updatedAt" : "2016-07-18T05:00:42Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "a9426a19c96ff893025644315bf5989a764607d6",
    "line" : null,
    "diffHunk" : "@@ -1,1 +775,779 @@\t// TODO: we report loadbalancer IP through status, so we want to verify if\n\t// that matches the forwarding rule as well.\n\tif loadBalancerIP != \"\" && loadBalancerIP != fwd.IPAddress {\n\t\tglog.Infof(\"LoadBalancer ip for forwarding rule %v was expected to be %v, but was actually %v\", fwd.Name, fwd.IPAddress, loadBalancerIP)\n\t\treturn true, true, fwd.IPAddress, nil"
  },
  {
    "id" : "703efc95-3497-4b03-ae54-ad5d8417f058",
    "prId" : 27741,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0793b528-d06f-4dae-a115-e98cfd9e6ba7",
        "parentId" : null,
        "authorId" : "395f4f9a-98be-4485-b436-51f0897d7c9f",
        "body" : "can you add a comment describing the exact use of nodeInstancePrefix and impact of passing in an empty string? \n",
        "createdAt" : "2016-06-21T16:53:05Z",
        "updatedAt" : "2016-06-21T16:53:05Z",
        "lastEditedBy" : "395f4f9a-98be-4485-b436-51f0897d7c9f",
        "tags" : [
        ]
      },
      {
        "id" : "96509a5f-23b5-460b-9d82-b0ac8095ee52",
        "parentId" : "0793b528-d06f-4dae-a115-e98cfd9e6ba7",
        "authorId" : "a92f8f9e-31fd-4510-b4d9-3553f7025485",
        "body" : "Didn't see this before it merged. To clarify it here (and I'll have a PR later): It's an advisory prefix to help GCE searches for nodes in the cluster. If nodes happen to join that violate the `nodeInstancePrefix`, the `nodeInstancePrefix` is ignored and the entire GCE project is enumerated.\n",
        "createdAt" : "2016-06-21T16:59:32Z",
        "updatedAt" : "2016-06-21T16:59:32Z",
        "lastEditedBy" : "a92f8f9e-31fd-4510-b4d9-3553f7025485",
        "tags" : [
        ]
      },
      {
        "id" : "3907e7db-c32f-45a2-bff9-bfbffc452b84",
        "parentId" : "0793b528-d06f-4dae-a115-e98cfd9e6ba7",
        "authorId" : "a92f8f9e-31fd-4510-b4d9-3553f7025485",
        "body" : "Oh, and if it's empty, we enumerate the whole project.\n",
        "createdAt" : "2016-06-21T17:01:41Z",
        "updatedAt" : "2016-06-21T17:01:41Z",
        "lastEditedBy" : "a92f8f9e-31fd-4510-b4d9-3553f7025485",
        "tags" : [
        ]
      }
    ],
    "commit" : "dd4dae4a57129c40d4496ca6ad37ee3a4fa045fa",
    "line" : 52,
    "diffHunk" : "@@ -1,1 +297,301 @@// If no networkUrl is specified, loads networkName via rest call.\n// If no tokenSource is specified, uses oauth2.DefaultTokenSource.\n// If managedZones is nil / empty all zones in the region will be managed.\nfunc CreateGCECloud(projectID, region, zone string, managedZones []string, networkURL string, nodeTags []string, nodeInstancePrefix string, tokenSource oauth2.TokenSource, useMetadataServer bool) (*GCECloud, error) {\n\tif tokenSource == nil {"
  },
  {
    "id" : "3b328d37-37e4-41a7-ba8b-a047fda4026b",
    "prId" : 27553,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2a6644bd-117f-49f2-bdda-2924eae45cf4",
        "parentId" : null,
        "authorId" : "395f4f9a-98be-4485-b436-51f0897d7c9f",
        "body" : "I'm guessing it's easier to do this than make it a private method in the same module, like we did for aws ? \n",
        "createdAt" : "2016-06-19T22:28:49Z",
        "updatedAt" : "2016-06-21T19:23:57Z",
        "lastEditedBy" : "395f4f9a-98be-4485-b436-51f0897d7c9f",
        "tags" : [
        ]
      },
      {
        "id" : "b93d4c02-5955-4fac-b1c3-e504761d8913",
        "parentId" : "2a6644bd-117f-49f2-bdda-2924eae45cf4",
        "authorId" : "8fc8f958-3c0e-47dd-a0fb-b8cc483b4efb",
        "body" : "Correct.  The GCE PD creation code is split between here and the volumes package; AWS has a cleaner separation of code.  So the zone is determine in the cloudprovider in AWS, and in the volumes code in GCE.\n\nNote that this method is public, but is not part of the public interface.  i.e. it is public on GCECloud, not cloudprovider.Interface\n",
        "createdAt" : "2016-06-20T01:31:40Z",
        "updatedAt" : "2016-06-21T19:23:57Z",
        "lastEditedBy" : "8fc8f958-3c0e-47dd-a0fb-b8cc483b4efb",
        "tags" : [
        ]
      }
    ],
    "commit" : "dd949976199b4cb741ef0175353c2601dd9a8c90",
    "line" : 19,
    "diffHunk" : "@@ -1,1 +2070,2074 @@\n// GetAllZones returns all the zones in which nodes are running\nfunc (gce *GCECloud) GetAllZones() (sets.String, error) {\n\t// Fast-path for non-multizone\n\tif len(gce.managedZones) == 1 {"
  },
  {
    "id" : "d896b574-109f-4b9e-a2f4-f76980b7957e",
    "prId" : 27553,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e1662934-3747-4b73-8199-6894316b6804",
        "parentId" : null,
        "authorId" : "395f4f9a-98be-4485-b436-51f0897d7c9f",
        "body" : "is there a reson we're listing all instances here and only running instances above ? is it simpler to not account for instance state, since one can't guess if all instances will go down right after we allocate the pv anyway\n",
        "createdAt" : "2016-06-19T22:28:50Z",
        "updatedAt" : "2016-06-21T19:23:57Z",
        "lastEditedBy" : "395f4f9a-98be-4485-b436-51f0897d7c9f",
        "tags" : [
        ]
      },
      {
        "id" : "3c56c70d-c5c4-4cc9-a562-b86928462832",
        "parentId" : "e1662934-3747-4b73-8199-6894316b6804",
        "authorId" : "8fc8f958-3c0e-47dd-a0fb-b8cc483b4efb",
        "body" : "I debated this, and am happy to change.  I tried to sum it up in \"No filter: we assume that a zone is either used or unused\".  My view was that here we should probably just keep it simple, and if an instance was starting up we would still count it as a zone in use.  The above method is constrained to exclude them, but I thought it probably simpler to just keep this method simple for now (we can always filter out instances that are shutting down later...)\n",
        "createdAt" : "2016-06-20T01:36:07Z",
        "updatedAt" : "2016-06-21T19:23:57Z",
        "lastEditedBy" : "8fc8f958-3c0e-47dd-a0fb-b8cc483b4efb",
        "tags" : [
        ]
      }
    ],
    "commit" : "dd949976199b4cb741ef0175353c2601dd9a8c90",
    "line" : 32,
    "diffHunk" : "@@ -1,1 +2083,2087 @@\tfor _, zone := range gce.managedZones {\n\t\t// We only retrieve one page in each zone - we only care about existence\n\t\tlistCall := gce.service.Instances.List(gce.projectID, zone)\n\n\t\t// No filter: We assume that a zone is either used or unused"
  },
  {
    "id" : "8e7d61ef-92dc-4c67-8d07-7ed517c48bf5",
    "prId" : 27553,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0d2609c7-afee-411e-b8d4-0599cad93de7",
        "parentId" : null,
        "authorId" : "395f4f9a-98be-4485-b436-51f0897d7c9f",
        "body" : "how bad would it be to always get by unknown zone, then match zone and throw an error/log? it might save us in the case where something fishy happens and we end up with cross matched zones\n",
        "createdAt" : "2016-06-19T22:28:52Z",
        "updatedAt" : "2016-06-21T19:23:57Z",
        "lastEditedBy" : "395f4f9a-98be-4485-b436-51f0897d7c9f",
        "tags" : [
        ]
      },
      {
        "id" : "efe8a838-1de1-41e8-b0ca-8028647ecb6d",
        "parentId" : "0d2609c7-afee-411e-b8d4-0599cad93de7",
        "authorId" : "8fc8f958-3c0e-47dd-a0fb-b8cc483b4efb",
        "body" : "Ah... so this is subtle.  This is actually a workaround for #27656 and #27657.  The problem is that in the volumes admission controller the cloudprovider is not configured with multizone=true.  This would prevent getDiskByNameUnknownZone from working at all unless the PD was in the master zone.  However, the workaround here is to allow creation in a non-master zone by looking to this zone parameter, which is derived by the admission controller when the zone annotation is already set.\n\nAlso, we actually want to be moving away getDiskByNameUnknownZone and towards volumes that always have an associated zone on GCE, because volume names on GCE are unique per zone, not per region.  i.e. the correct specifier for a GCE PD is probably `<zone>/<name>`, not `<name>`.  Thankfully with dynamic provisioning we can just use the annotation (which is painful for a human but fine for code), and static provisioning never really made sense on a cloud anyway...\n\nI guess this needs a comment!\n",
        "createdAt" : "2016-06-20T01:49:48Z",
        "updatedAt" : "2016-06-21T19:23:57Z",
        "lastEditedBy" : "8fc8f958-3c0e-47dd-a0fb-b8cc483b4efb",
        "tags" : [
        ]
      }
    ],
    "commit" : "dd949976199b4cb741ef0175353c2601dd9a8c90",
    "line" : null,
    "diffHunk" : "@@ -1,1 +2275,2279 @@\t\t// However, wherever possible the zone should be passed (and it is passed\n\t\t// for most cases that we can control, e.g. dynamic volume provisioning)\n\t\tdisk, err = gce.getDiskByNameUnknownZone(name)\n\t\tif err != nil {\n\t\t\treturn nil, err"
  },
  {
    "id" : "971c64d9-8832-4e8c-a110-ec601da37095",
    "prId" : 27553,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "edaca61b-12b8-4517-9576-9b36906739ef",
        "parentId" : null,
        "authorId" : "395f4f9a-98be-4485-b436-51f0897d7c9f",
        "body" : "@zmerlynn fyi another list call on fields, but I think this ones ok since it's just checking for exit code 0, essentially\n",
        "createdAt" : "2016-06-21T21:02:51Z",
        "updatedAt" : "2016-06-21T21:02:51Z",
        "lastEditedBy" : "395f4f9a-98be-4485-b436-51f0897d7c9f",
        "tags" : [
        ]
      },
      {
        "id" : "8e5bacf7-78a8-43d7-b43f-7c495155e4f8",
        "parentId" : "edaca61b-12b8-4517-9576-9b36906739ef",
        "authorId" : "a92f8f9e-31fd-4510-b4d9-3553f7025485",
        "body" : "This looks fine. The function could be a bit more pessimistic about which zones it uses if the `nodeInstancePrefix` I added in #27741 wasn't actually advisory, but right now we let people join arbitrary garbage to a master, so this sort of check is about all that you can do.\n",
        "createdAt" : "2016-06-21T21:10:48Z",
        "updatedAt" : "2016-06-21T21:10:48Z",
        "lastEditedBy" : "a92f8f9e-31fd-4510-b4d9-3553f7025485",
        "tags" : [
        ]
      }
    ],
    "commit" : "dd949976199b4cb741ef0175353c2601dd9a8c90",
    "line" : 46,
    "diffHunk" : "@@ -1,1 +2097,2101 @@\n\t\t// Just a minimal set of fields - we only care about existence\n\t\tlistCall = listCall.Fields(\"items(name)\")\n\n\t\tres, err := listCall.Do()"
  },
  {
    "id" : "cd4a46a3-ab06-4925-8644-0599db9947a1",
    "prId" : 26615,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "61cf726c-f3e0-4737-9f07-71afa2398427",
        "parentId" : null,
        "authorId" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "body" : "Godoc on type?  this is exported.\n",
        "createdAt" : "2016-06-03T21:57:24Z",
        "updatedAt" : "2016-06-08T12:30:32Z",
        "lastEditedBy" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "tags" : [
        ]
      },
      {
        "id" : "3955f42b-acf5-4c09-b039-577babf1d545",
        "parentId" : "61cf726c-f3e0-4737-9f07-71afa2398427",
        "authorId" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "body" : "fixed\n",
        "createdAt" : "2016-06-08T10:33:40Z",
        "updatedAt" : "2016-06-08T12:30:32Z",
        "lastEditedBy" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "tags" : [
        ]
      }
    ],
    "commit" : "5cd5ae8d82a57d883032ee3faf159c57d910cff4",
    "line" : null,
    "diffHunk" : "@@ -1,1 +102,106 @@\n// Disks is interface for manipulation with GCE PDs.\ntype Disks interface {\n\t// AttachDisk attaches given disk to given instance. Current instance\n\t// is used when instanceID is empty string."
  },
  {
    "id" : "7d7680f3-193b-4393-b640-499b5260b19f",
    "prId" : 25178,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b6ee803c-4831-4266-a674-d876480091d3",
        "parentId" : null,
        "authorId" : "395f4f9a-98be-4485-b436-51f0897d7c9f",
        "body" : "@kubernetes/goog-cluster fyi\n",
        "createdAt" : "2016-05-05T01:58:00Z",
        "updatedAt" : "2016-05-10T04:45:10Z",
        "lastEditedBy" : "395f4f9a-98be-4485-b436-51f0897d7c9f",
        "tags" : [
        ]
      },
      {
        "id" : "d4d55400-eeba-4ab1-839e-6b1374536099",
        "parentId" : "b6ee803c-4831-4266-a674-d876480091d3",
        "authorId" : "a92f8f9e-31fd-4510-b4d9-3553f7025485",
        "body" : "Internal b/28566577, FYI\n",
        "createdAt" : "2016-05-05T02:37:44Z",
        "updatedAt" : "2016-05-10T04:45:10Z",
        "lastEditedBy" : "a92f8f9e-31fd-4510-b4d9-3553f7025485",
        "tags" : [
        ]
      }
    ],
    "commit" : "faf0c44429cfb285cdce811be61b5b39ac37e233",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +72,76 @@\n\t// TargetPools can only support 1000 VMs.\n\tmaxInstancesPerTargetPool = 1000\n)\n"
  },
  {
    "id" : "175e88f1-8506-4c05-8b1a-a38f6614197c",
    "prId" : 23541,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9f0e597c-bd8a-473d-90a5-f7b22132d2ff",
        "parentId" : null,
        "authorId" : "3cd3a661-80f4-45b3-bae0-5a78fbaedc59",
        "body" : "If we do this, we'll also need to change the functionality of the `firewallObject()` method. It currently takes a list of ports, but uses port[0]'s protocol for all of the ports. Can you add a TODO down there also? (~line 910)\n",
        "createdAt" : "2016-03-28T17:53:24Z",
        "updatedAt" : "2016-03-28T18:06:33Z",
        "lastEditedBy" : "3cd3a661-80f4-45b3-bae0-5a78fbaedc59",
        "tags" : [
        ]
      },
      {
        "id" : "978b2668-88d5-4446-967a-b45133d7f07c",
        "parentId" : "9f0e597c-bd8a-473d-90a5-f7b22132d2ff",
        "authorId" : "395f4f9a-98be-4485-b436-51f0897d7c9f",
        "body" : "Added TODO, PTAL.\n",
        "createdAt" : "2016-03-28T18:07:10Z",
        "updatedAt" : "2016-03-28T18:07:10Z",
        "lastEditedBy" : "395f4f9a-98be-4485-b436-51f0897d7c9f",
        "tags" : [
        ]
      }
    ],
    "commit" : "7436fc6261968443f6e86069bb86934b7b8b1343",
    "line" : 18,
    "diffHunk" : "@@ -1,1 +1245,1249 @@\t// TODO: Currently the only consumer of this method is the GCE L7\n\t// loadbalancer controller, which never needs a protocol other than TCP.\n\t// We should pipe through a mapping of port:protocol and default to TCP\n\t// if UDP ports are required. This means the method signature will change\n\t// forcing downstream clients to refactor interfaces."
  },
  {
    "id" : "a050ff87-c047-41cc-8243-05c352ec8c76",
    "prId" : 22094,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "00ddad10-f536-4bd2-9ab8-cc1ea37c330d",
        "parentId" : null,
        "authorId" : "82da2b23-9f40-4abd-8af5-56ba07c1fc0a",
        "body" : "In a followup PR, perhaps augment this comment to make it clearer that if you want to scale the cluster beyond 12,500 nodes, you need to increase this number. Or maybe just increase this to some number higher than we ever expect one cluster to reach (e.g. maxPages = 100)?\n",
        "createdAt" : "2016-02-29T04:56:29Z",
        "updatedAt" : "2016-02-29T04:56:29Z",
        "lastEditedBy" : "82da2b23-9f40-4abd-8af5-56ba07c1fc0a",
        "tags" : [
        ]
      }
    ],
    "commit" : "0816fa20727faeae1a4104cff23c48b2b9feb0df",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +70,74 @@\t// Each page can have 500 results, but we cap how many pages\n\t// are iterated through to prevent infinite loops if the API\n\t// were to continuously return a nextPageToken.\n\tmaxPages = 25\n)"
  },
  {
    "id" : "12d857f5-9a5a-4302-b4ee-8d158103a311",
    "prId" : 21431,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "762212d0-e17f-48ed-8126-df3b1826c31d",
        "parentId" : null,
        "authorId" : "395f4f9a-98be-4485-b436-51f0897d7c9f",
        "body" : "what does the servicecontroller do with this error? retry till the annotation is correct? do we send an event or something\n",
        "createdAt" : "2016-02-18T01:29:25Z",
        "updatedAt" : "2016-02-19T01:06:22Z",
        "lastEditedBy" : "395f4f9a-98be-4485-b436-51f0897d7c9f",
        "tags" : [
        ]
      },
      {
        "id" : "dcf1ea74-bac8-4b9d-b3c4-dbef3d0581b3",
        "parentId" : "762212d0-e17f-48ed-8126-df3b1826c31d",
        "authorId" : "e83108b8-1fb2-416b-9298-d5b70c14f708",
        "body" : "Service controller will record a event if validation failed and retry until someone fix the problem\n",
        "createdAt" : "2016-02-18T19:34:51Z",
        "updatedAt" : "2016-02-19T01:06:22Z",
        "lastEditedBy" : "e83108b8-1fb2-416b-9298-d5b70c14f708",
        "tags" : [
        ]
      }
    ],
    "commit" : "7ffb123abebb93c2483ff500863b30f139ca2fbe",
    "line" : null,
    "diffHunk" : "@@ -1,1 +583,587 @@\tif ok {\n\t\tif err := validateSourceRangeAnnotation(annotations); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tsourceRanges = strings.Split(val, \",\")"
  },
  {
    "id" : "e227239d-e6e9-4180-ba68-42590c1304df",
    "prId" : 21431,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0f35a615-c0d4-4661-8328-93f5ae437fb9",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "service.beta.kubernetes.io/load-balancer-source-ranges ?\n",
        "createdAt" : "2016-02-22T19:41:31Z",
        "updatedAt" : "2016-02-22T19:41:31Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "cc27d9a4-3a8c-4985-9498-faed73d0a5c9",
        "parentId" : "0f35a615-c0d4-4661-8328-93f5ae437fb9",
        "authorId" : "395f4f9a-98be-4485-b436-51f0897d7c9f",
        "body" : "dont' we want to make it explicit that this is cloudprovider specific? (by putting gce- in there) \n",
        "createdAt" : "2016-02-22T19:48:24Z",
        "updatedAt" : "2016-02-22T19:48:24Z",
        "lastEditedBy" : "395f4f9a-98be-4485-b436-51f0897d7c9f",
        "tags" : [
        ]
      },
      {
        "id" : "ca5e2240-6f8f-41a4-819a-629994cf8f46",
        "parentId" : "0f35a615-c0d4-4661-8328-93f5ae437fb9",
        "authorId" : "8fc8f958-3c0e-47dd-a0fb-b8cc483b4efb",
        "body" : "Presumably not if we do #21651 \n",
        "createdAt" : "2016-02-22T20:42:25Z",
        "updatedAt" : "2016-02-22T20:42:25Z",
        "lastEditedBy" : "8fc8f958-3c0e-47dd-a0fb-b8cc483b4efb",
        "tags" : [
        ]
      },
      {
        "id" : "3a4710c2-063e-4349-b35d-06cdfdd1bb23",
        "parentId" : "0f35a615-c0d4-4661-8328-93f5ae437fb9",
        "authorId" : "395f4f9a-98be-4485-b436-51f0897d7c9f",
        "body" : "Yeah if we get > 1 cloudprovider to implement support for this, it's better to remove gce, but otherwise having gce in the annotation name is probably the clearest way to say it works nowhere else (if someone is just copy pasting kubectl -o output, for example)\n",
        "createdAt" : "2016-02-22T21:21:26Z",
        "updatedAt" : "2016-02-22T21:21:26Z",
        "lastEditedBy" : "395f4f9a-98be-4485-b436-51f0897d7c9f",
        "tags" : [
        ]
      }
    ],
    "commit" : "7ffb123abebb93c2483ff500863b30f139ca2fbe",
    "line" : 8,
    "diffHunk" : "@@ -1,1 +66,70 @@\n\t//Expected annotations for GCE\n\tgceLBAllowSourceRange = \"net.beta.kubernetes.io/gce-source-ranges\"\n)\n"
  },
  {
    "id" : "e12a50b4-b201-4166-8b8c-63a1254a9668",
    "prId" : 21431,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6e4dcd1b-a6d1-4359-b4df-cd856ead968d",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "document here the expected format of the value\n",
        "createdAt" : "2016-02-22T19:41:59Z",
        "updatedAt" : "2016-02-22T19:41:59Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "7ffb123abebb93c2483ff500863b30f139ca2fbe",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +65,69 @@\tdefaultLBSourceRange = \"0.0.0.0/0\"\n\n\t//Expected annotations for GCE\n\tgceLBAllowSourceRange = \"net.beta.kubernetes.io/gce-source-ranges\"\n)"
  },
  {
    "id" : "106d13de-1efc-4ebc-8944-52d5a5ef3de1",
    "prId" : 21319,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "01909897-386a-4649-9637-4c147f2b7713",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "@ArtfulCoder NB that this is a change for your firewall stuff - do you think it is OK?  Is this obvious enough?  We could add another label that says \"is kube managed\" but I don't think we need to.\n",
        "createdAt" : "2016-02-22T18:46:13Z",
        "updatedAt" : "2016-02-24T15:21:40Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "efe82d3f-262e-4f1c-bd5b-7690f21a5151",
        "parentId" : "01909897-386a-4649-9637-4c147f2b7713",
        "authorId" : "0970b119-085d-41b4-8f33-e10409965eba",
        "body" : "The only thing to consider is that description might be used by user for other purposes too.\nIf we want to play nice, we should assume that this string could potentially be a substring of the larger description text.\nIn that case, should we have pre and post delimiters around the JSON to clearly indicate that kubernetes will parse anything within that ?\n",
        "createdAt" : "2016-02-23T01:49:37Z",
        "updatedAt" : "2016-02-24T15:21:40Z",
        "lastEditedBy" : "0970b119-085d-41b4-8f33-e10409965eba",
        "tags" : [
        ]
      },
      {
        "id" : "e0579a6e-ad34-4eea-b2c5-844e18c7ee65",
        "parentId" : "01909897-386a-4649-9637-4c147f2b7713",
        "authorId" : "11725e10-43c9-4a8c-96d0-5118a3e67a6a",
        "body" : "What would such delimiters look like?\n",
        "createdAt" : "2016-02-23T15:47:30Z",
        "updatedAt" : "2016-02-24T15:21:40Z",
        "lastEditedBy" : "11725e10-43c9-4a8c-96d0-5118a3e67a6a",
        "tags" : [
        ]
      },
      {
        "id" : "71ff2490-e094-46e8-9153-f324992d759b",
        "parentId" : "01909897-386a-4649-9637-4c147f2b7713",
        "authorId" : "0970b119-085d-41b4-8f33-e10409965eba",
        "body" : "Currently, we have \"KubernetesManaged_\" prefix and the content must be on its own line.\n",
        "createdAt" : "2016-02-23T19:01:15Z",
        "updatedAt" : "2016-02-24T15:21:40Z",
        "lastEditedBy" : "0970b119-085d-41b4-8f33-e10409965eba",
        "tags" : [
        ]
      },
      {
        "id" : "53155619-7a66-4a06-8cf0-6edc497a154f",
        "parentId" : "01909897-386a-4649-9637-4c147f2b7713",
        "authorId" : "11725e10-43c9-4a8c-96d0-5118a3e67a6a",
        "body" : "I changed it, but for me now it amounts to even more esoteric functionality than gRPC health checks ;-)\n",
        "createdAt" : "2016-02-23T21:59:46Z",
        "updatedAt" : "2016-02-24T15:21:40Z",
        "lastEditedBy" : "11725e10-43c9-4a8c-96d0-5118a3e67a6a",
        "tags" : [
        ]
      }
    ],
    "commit" : "af4507b1aed000dfdb52a80056a30886977bbec3",
    "line" : 98,
    "diffHunk" : "@@ -1,1 +782,786 @@\nfunc makeFirewallDescription(serviceName, ipAddress string) string {\n\treturn fmt.Sprintf(`{\"kubernetes.io/service-ip\":\"%s\", \"kubernetes.io/service-name\":\"%s\"}`,\n\t\tipAddress, serviceName)\n}"
  },
  {
    "id" : "d62c5b74-2c03-4af4-a696-61d587529cdf",
    "prId" : 20662,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6150044d-bb88-4591-bf5b-5fa531a8f1e4",
        "parentId" : null,
        "authorId" : "7766e039-aa4c-4476-9091-5cc8763fa8d6",
        "body" : "I have another crazy situation for you:\n1. Alice creates LB without a requested IP\n2. Alice takes the IP that got assigned to the LB and puts it in the requestedIP field (which appears to be supported, given all the code being added)\n3. Alice updates the service in a way that requires deleting and recreating the forwarding rule\n4. The first time through this code, we promote the IP to static in the `if requestedIP.String() == fwdRuleIP` condition\n5. We delete the fwd rule but fail to recreate it, causing the IP to be kept around\n6. On retry, this isStatic check evaluates to true because the requested IP was temporarily promoted to static last time around, causing us to think it's a user-owned IP and not release it when we're done.\n\nThis is such a minor case that it may not be worth handling at this point given the more urgent issues, but it's at least worth making note of somewhere.\n",
        "createdAt" : "2016-02-05T23:38:00Z",
        "updatedAt" : "2016-02-07T05:15:12Z",
        "lastEditedBy" : "7766e039-aa4c-4476-9091-5cc8763fa8d6",
        "tags" : [
        ]
      },
      {
        "id" : "60082203-24cc-429b-8dec-7208c3fe41e6",
        "parentId" : "6150044d-bb88-4591-bf5b-5fa531a8f1e4",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "Alice explicitly promoted it to a user-owned IP by putting it in the loadBalancerIP field.  We don't, in general, have a way for users to assume responsibility for cloud-provider objects.  In fact, the EnsureLoadBalancerDeleted() logic deletes any IP with the same Name as the LB, without question, so it is only a temporary promotion anyway.  If we want to support this properly we might need a notion of an IP address, but I don't think we should go there, yet.\n\nUntil/unless we can update() GCE forwarding rules, we need this fugly promote/demote dance, and there's not much we can do that isn't heuristic in nature.   We could use description fields as \"ownership\" but...meh.\n",
        "createdAt" : "2016-02-06T21:03:41Z",
        "updatedAt" : "2016-02-07T05:15:12Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "fecb71420c72677780a6c16754ffcb15fd7ffc72",
    "line" : 48,
    "diffHunk" : "@@ -1,1 +498,502 @@\t\t// ephemeral IP (or it was a different static IP owned by the user, in which\n\t\t// case we shouldn't delete it anyway).\n\t\tif isStatic, err := gce.projectOwnsStaticIP(name, region, requestedIP.String()); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to test if this GCE project owns the static IP %s: %v\", requestedIP.String(), err)\n\t\t} else if isStatic {"
  },
  {
    "id" : "b4ad6fbd-474e-484b-a6a7-b87a87afc7a4",
    "prId" : 20662,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4dfe4980-cb48-4289-beda-ae84dd5c70fa",
        "parentId" : null,
        "authorId" : "7766e039-aa4c-4476-9091-5cc8763fa8d6",
        "body" : "It really feels like we should be using a different variable for this part (the locking before/after deleting/creating the forwarding rule), to make sure we don't set this to true when up above we had set it to false\n",
        "createdAt" : "2016-02-05T23:51:21Z",
        "updatedAt" : "2016-02-07T05:15:12Z",
        "lastEditedBy" : "7766e039-aa4c-4476-9091-5cc8763fa8d6",
        "tags" : [
        ]
      },
      {
        "id" : "c52500ff-323d-4199-9b94-0a1ec443877a",
        "parentId" : "4dfe4980-cb48-4289-beda-ae84dd5c70fa",
        "authorId" : "7766e039-aa4c-4476-9091-5cc8763fa8d6",
        "body" : "Nevermind -- looking at each of the cases it's used in, this is right. `isUserOwnedIP` is really managing that second bit, so disregard this\n",
        "createdAt" : "2016-02-05T23:54:41Z",
        "updatedAt" : "2016-02-07T05:15:12Z",
        "lastEditedBy" : "7766e039-aa4c-4476-9091-5cc8763fa8d6",
        "tags" : [
        ]
      }
    ],
    "commit" : "fecb71420c72677780a6c16754ffcb15fd7ffc72",
    "line" : 167,
    "diffHunk" : "@@ -1,1 +622,626 @@\t\t// of a user-requested IP, the \"is user-owned\" flag will be set,\n\t\t// preventing it from actually being released.\n\t\tisSafeToReleaseIP = true\n\t\tglog.V(4).Infof(\"EnsureLoadBalancer(%v): created forwarding rule, IP %s\", name, ipAddress)\n\t}"
  },
  {
    "id" : "4568d194-7418-488c-a5a3-b957b60ec7b9",
    "prId" : 20210,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9d1ca429-b79f-49b7-8e2b-5cda93e95fb6",
        "parentId" : null,
        "authorId" : "727fc82d-d969-41a4-a614-7fefce94f9a6",
        "body" : "Godoc convention is to start the comment with the function name.\n",
        "createdAt" : "2016-01-27T16:08:28Z",
        "updatedAt" : "2016-01-27T17:16:25Z",
        "lastEditedBy" : "727fc82d-d969-41a4-a614-7fefce94f9a6",
        "tags" : [
        ]
      },
      {
        "id" : "94740760-a232-48f1-b82a-460753ea47e4",
        "parentId" : "9d1ca429-b79f-49b7-8e2b-5cda93e95fb6",
        "authorId" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "body" : "Description updated.\n",
        "createdAt" : "2016-01-27T17:16:36Z",
        "updatedAt" : "2016-01-27T17:16:36Z",
        "lastEditedBy" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "tags" : [
        ]
      }
    ],
    "commit" : "23cd0913f7c6dadb6a38fdbc8fc2fe4983ed4e7c",
    "line" : null,
    "diffHunk" : "@@ -1,1 +1637,1641 @@// the specified zone. It stores specified tags endoced in JSON in Description\n// field.\nfunc (gce *GCECloud) CreateDisk(name string, zone string, sizeGb int64, tags map[string]string) error {\n\ttagsStr, err := gce.encodeDiskTags(tags)\n\tif err != nil {"
  },
  {
    "id" : "2e9f4141-1dc3-42b9-b2a9-8559037937ce",
    "prId" : 20210,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7c615e5a-60d8-4312-b4d7-b4f0da9599ad",
        "parentId" : null,
        "authorId" : "727fc82d-d969-41a4-a614-7fefce94f9a6",
        "body" : "I don't know if unexported functions are part of Godoc, but following the same naming convention can't hurt.\n",
        "createdAt" : "2016-01-27T16:09:12Z",
        "updatedAt" : "2016-01-27T17:16:25Z",
        "lastEditedBy" : "727fc82d-d969-41a4-a614-7fefce94f9a6",
        "tags" : [
        ]
      },
      {
        "id" : "4ca46306-ded6-401c-a71f-338f06961595",
        "parentId" : "7c615e5a-60d8-4312-b4d7-b4f0da9599ad",
        "authorId" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "body" : "Description updated.\n",
        "createdAt" : "2016-01-27T17:16:33Z",
        "updatedAt" : "2016-01-27T17:16:33Z",
        "lastEditedBy" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "tags" : [
        ]
      }
    ],
    "commit" : "23cd0913f7c6dadb6a38fdbc8fc2fe4983ed4e7c",
    "line" : null,
    "diffHunk" : "@@ -1,1 +1621,1625 @@// encodeDiskTags encodes requested volume tags into JSON string, as GCE does\n// not support tags on GCE PDs and we use Description field as fallback.\nfunc (gce *GCECloud) encodeDiskTags(tags map[string]string) (string, error) {\n\tif len(tags) == 0 {\n\t\t// No tags -> empty JSON"
  },
  {
    "id" : "85c0f7ef-429e-4a93-88f9-bb0488e0a85c",
    "prId" : 20098,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "87ca20eb-5664-47db-903b-0dfa7f037b9e",
        "parentId" : null,
        "authorId" : "719d0e19-fcef-4b47-afac-404318b9514f",
        "body" : "maybe rather than exposing this, create a `ListForwardingRules` function analogous to the `ListGlobalForwardingRules` function we already have?\n",
        "createdAt" : "2016-01-29T01:08:05Z",
        "updatedAt" : "2016-02-01T23:35:07Z",
        "lastEditedBy" : "719d0e19-fcef-4b47-afac-404318b9514f",
        "tags" : [
        ]
      },
      {
        "id" : "41750d67-bba3-40a4-9543-a881acbf9e98",
        "parentId" : "87ca20eb-5664-47db-903b-0dfa7f037b9e",
        "authorId" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "body" : "hrm, I'm doing really specific things that I don't intend to generalize.  I'd rather not define an general interface until its needed for Kubernetes proper, not just testing.\n",
        "createdAt" : "2016-01-29T21:01:03Z",
        "updatedAt" : "2016-02-01T23:35:07Z",
        "lastEditedBy" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "tags" : [
        ]
      },
      {
        "id" : "45bbc5a6-9d94-4d74-8637-770bd0c4cb64",
        "parentId" : "87ca20eb-5664-47db-903b-0dfa7f037b9e",
        "authorId" : "719d0e19-fcef-4b47-afac-404318b9514f",
        "body" : "I guess this is probably fine, though leaking the interface still feels kinda dirty (and I worry that folks might abuse this)? it almost seems like `ListForwardingRules` should have been included in #16142. @bprashanth\n",
        "createdAt" : "2016-01-29T21:56:16Z",
        "updatedAt" : "2016-02-01T23:35:07Z",
        "lastEditedBy" : "719d0e19-fcef-4b47-afac-404318b9514f",
        "tags" : [
        ]
      },
      {
        "id" : "bf3a49b3-112d-444e-a720-41597f7e175f",
        "parentId" : "87ca20eb-5664-47db-903b-0dfa7f037b9e",
        "authorId" : "395f4f9a-98be-4485-b436-51f0897d7c9f",
        "body" : "I like raw access to resources so downstream controllers are free to define their own interfaces. ListForwardingRules is only used by L4 loadbalancers though, which already has a TCPLoadBalancer interface that's more tightly coupled with the servicecontroller. List_Global_ForwardingRules is used for L7 and there's no coupling. I think a big difference between these 2 is that configuring an L4 is kind of similar on AWS and GCE (if you squint), so an interface makes more sense. They're very different at L7.\n",
        "createdAt" : "2016-01-30T00:24:15Z",
        "updatedAt" : "2016-02-01T23:35:07Z",
        "lastEditedBy" : "395f4f9a-98be-4485-b436-51f0897d7c9f",
        "tags" : [
        ]
      },
      {
        "id" : "5b18f011-fdfb-4c36-b02d-772c92011451",
        "parentId" : "87ca20eb-5664-47db-903b-0dfa7f037b9e",
        "authorId" : "395f4f9a-98be-4485-b436-51f0897d7c9f",
        "body" : "Personally, I wouldn't care about leaking the interface. Most people who create a cloudprovider through our library probably really want to.\n",
        "createdAt" : "2016-01-30T00:25:23Z",
        "updatedAt" : "2016-02-01T23:35:07Z",
        "lastEditedBy" : "395f4f9a-98be-4485-b436-51f0897d7c9f",
        "tags" : [
        ]
      },
      {
        "id" : "7d22a485-3fa0-43fb-90ab-4ce3bcf6691a",
        "parentId" : "87ca20eb-5664-47db-903b-0dfa7f037b9e",
        "authorId" : "395f4f9a-98be-4485-b436-51f0897d7c9f",
        "body" : "Sorry for the follow up comments. The risk of leaking the interface is that someone will forget to do something like `WaitForGlobal/RegionalOp`, or some other gce boilerplate, which will manifest as weird races till they realize. \n",
        "createdAt" : "2016-01-30T00:34:24Z",
        "updatedAt" : "2016-02-01T23:35:07Z",
        "lastEditedBy" : "395f4f9a-98be-4485-b436-51f0897d7c9f",
        "tags" : [
        ]
      },
      {
        "id" : "71750af4-05d8-46fc-93f2-d9990395ec4b",
        "parentId" : "87ca20eb-5664-47db-903b-0dfa7f037b9e",
        "authorId" : "719d0e19-fcef-4b47-afac-404318b9514f",
        "body" : "So I'm a bit confused by your follow-up comments. Do you think this is fine as-is? Or should we instead export a `ListForwardingRules()` function?\n",
        "createdAt" : "2016-01-30T00:51:58Z",
        "updatedAt" : "2016-02-01T23:35:07Z",
        "lastEditedBy" : "719d0e19-fcef-4b47-afac-404318b9514f",
        "tags" : [
        ]
      },
      {
        "id" : "a4834961-8f70-4b63-8fe7-9620473e00f8",
        "parentId" : "87ca20eb-5664-47db-903b-0dfa7f037b9e",
        "authorId" : "395f4f9a-98be-4485-b436-51f0897d7c9f",
        "body" : "Suggest a warning comment indicating that anyone who wanted access to a particular resource should probably go through the interface because of the error prone nature of handling and waiting for cloud operations. \n",
        "createdAt" : "2016-01-30T00:59:24Z",
        "updatedAt" : "2016-02-01T23:35:07Z",
        "lastEditedBy" : "395f4f9a-98be-4485-b436-51f0897d7c9f",
        "tags" : [
        ]
      }
    ],
    "commit" : "2aa5dc317b91f4837f4dc0482cbe3d33d774394b",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +88,92 @@}\n\n// Raw access to the underlying GCE service, probably should only be used for e2e tests\nfunc (g *GCECloud) GetComputeService() *compute.Service {\n\treturn g.service"
  },
  {
    "id" : "46eaca77-fa93-44cf-b183-fc0a46c0229e",
    "prId" : 17919,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "32cebec2-0d83-458e-8b2a-ae681d64a0e2",
        "parentId" : null,
        "authorId" : null,
        "body" : "nit: It seems that the API can do this filtering for you:\n\nhttps://github.com/google/google-api-go-client/blob/master/compute/v1/compute-api.json#L13925\n\nLess code is better :-)\n",
        "createdAt" : "2016-01-07T20:55:14Z",
        "updatedAt" : "2016-01-21T04:04:59Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "43cbfb74fec10f9cf0af346e373b4d01e1b9efa6",
    "line" : 35,
    "diffHunk" : "@@ -1,1 +161,165 @@\t}\n\tzones := []string{}\n\tfor _, zone := range res.Items {\n\t\tregionName := lastComponent(zone.Region)\n\t\tif regionName == region {"
  },
  {
    "id" : "7870f681-f310-4ded-b157-63a034c7cb47",
    "prId" : 17919,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2bf4a8f8-764e-4d8a-abe1-d0fc500423e4",
        "parentId" : null,
        "authorId" : null,
        "body" : "You actually set it to nil above.\n",
        "createdAt" : "2016-01-07T21:04:27Z",
        "updatedAt" : "2016-01-21T04:04:59Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "003998a1-d975-4bf5-a7f4-59eae10d748b",
        "parentId" : "2bf4a8f8-764e-4d8a-abe1-d0fc500423e4",
        "authorId" : "8fc8f958-3c0e-47dd-a0fb-b8cc483b4efb",
        "body" : "Only in the case when multizone is set though, right?  This looks correct to me.\n\nThe weird structuring comes because when we are parsing the configuration, we don't yet have a GCE client, so we can't yet query the list of zones in the region.  So we pass nil to mean \"all zones in region\".\n",
        "createdAt" : "2016-01-17T20:20:11Z",
        "updatedAt" : "2016-01-21T04:04:59Z",
        "lastEditedBy" : "8fc8f958-3c0e-47dd-a0fb-b8cc483b4efb",
        "tags" : [
        ]
      }
    ],
    "commit" : "43cbfb74fec10f9cf0af346e373b4d01e1b9efa6",
    "line" : 94,
    "diffHunk" : "@@ -1,1 +257,261 @@\t}\n\n\tif len(managedZones) == 0 {\n\t\tmanagedZones, err = getZonesForRegion(svc, projectID, region)\n\t\tif err != nil {"
  },
  {
    "id" : "34ff8dac-4c9f-4941-a0ba-40f4fabee7ca",
    "prId" : 17919,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "816599bd-0e1b-4a21-9ec1-a4766cf81326",
        "parentId" : null,
        "authorId" : null,
        "body" : "I don't think that this or the next diff belong in this PR?\n",
        "createdAt" : "2016-01-07T21:30:20Z",
        "updatedAt" : "2016-01-21T04:04:59Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "daaccc63-966b-4683-a2fd-9b49b5fec3d5",
        "parentId" : "816599bd-0e1b-4a21-9ec1-a4766cf81326",
        "authorId" : null,
        "body" : "Oh, never mind, I see why lower down.\n",
        "createdAt" : "2016-01-07T21:31:31Z",
        "updatedAt" : "2016-01-21T04:04:59Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "43cbfb74fec10f9cf0af346e373b4d01e1b9efa6",
    "line" : null,
    "diffHunk" : "@@ -1,1 +428,432 @@\tglog.V(2).Infof(\"EnsureLoadBalancer(%v, %v, %v, %v, %v)\", name, region, requestedIP, ports, hostNames)\n\n\tif len(hostNames) == 0 {\n\t\treturn nil, fmt.Errorf(\"Cannot EnsureLoadBalancer() with no hosts\")\n\t}"
  },
  {
    "id" : "27a71373-354d-46bc-8f3c-6df33b257264",
    "prId" : 17919,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "542aa7a5-0a9a-4ca3-94ae-e4fecc6719d1",
        "parentId" : null,
        "authorId" : null,
        "body" : "indentation?\n",
        "createdAt" : "2016-01-07T22:07:36Z",
        "updatedAt" : "2016-01-21T04:04:59Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "b57eb693-f9fc-432c-bd7e-a6f109b6f167",
        "parentId" : "542aa7a5-0a9a-4ca3-94ae-e4fecc6719d1",
        "authorId" : "8fc8f958-3c0e-47dd-a0fb-b8cc483b4efb",
        "body" : "I don't understand.  I think this is gofmt-ed...\n",
        "createdAt" : "2016-01-17T20:21:52Z",
        "updatedAt" : "2016-01-21T04:04:59Z",
        "lastEditedBy" : "8fc8f958-3c0e-47dd-a0fb-b8cc483b4efb",
        "tags" : [
        ]
      }
    ],
    "commit" : "43cbfb74fec10f9cf0af346e373b4d01e1b9efa6",
    "line" : 221,
    "diffHunk" : "@@ -1,1 +802,806 @@\n\tfor zone, hostNames := range hostNamesByZone {\n\t\tlistCall := gce.service.Instances.List(gce.projectID, zone)\n\n\t\t// Add the filter for hosts"
  },
  {
    "id" : "c8c6bb2e-c2e5-4c11-8995-b3cec94f7051",
    "prId" : 17919,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f1e16b25-d9dd-4163-8e18-1467abda0510",
        "parentId" : null,
        "authorId" : null,
        "body" : "Whooah!  This actually seems to call into GKE to list clusters?  Seems that it does not belong in the GCE interface here?  No your fault, at all, but surprising, nonetheless.\n",
        "createdAt" : "2016-01-07T23:21:19Z",
        "updatedAt" : "2016-01-21T04:04:59Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "67f049ff-d11b-4879-9b05-acca6529cd88",
        "parentId" : "f1e16b25-d9dd-4163-8e18-1467abda0510",
        "authorId" : null,
        "body" : "@roberthbailey @a-robinson any idea what's going on here?\n",
        "createdAt" : "2016-01-07T23:23:24Z",
        "updatedAt" : "2016-01-21T04:04:59Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "87617978-29e3-4172-b15b-bf6c12db4f6e",
        "parentId" : "f1e16b25-d9dd-4163-8e18-1467abda0510",
        "authorId" : "c2b5c827-efcd-438f-8db5-52d917b1cde9",
        "body" : "@brendandburns should have a good answer since he added it in https://github.com/kubernetes/kubernetes/pull/2355. \n",
        "createdAt" : "2016-01-08T09:09:33Z",
        "updatedAt" : "2016-01-21T04:04:59Z",
        "lastEditedBy" : "c2b5c827-efcd-438f-8db5-52d917b1cde9",
        "tags" : [
        ]
      },
      {
        "id" : "26003081-6285-4388-ac31-a7d73bcf5b0e",
        "parentId" : "f1e16b25-d9dd-4163-8e18-1467abda0510",
        "authorId" : "8fc8f958-3c0e-47dd-a0fb-b8cc483b4efb",
        "body" : "I kinda assumed this was for internal use by the GKE code?  It isn't used anywhere that _I_ can see...\n",
        "createdAt" : "2016-01-17T20:55:24Z",
        "updatedAt" : "2016-01-21T04:04:59Z",
        "lastEditedBy" : "8fc8f958-3c0e-47dd-a0fb-b8cc483b4efb",
        "tags" : [
        ]
      }
    ],
    "commit" : "43cbfb74fec10f9cf0af346e373b4d01e1b9efa6",
    "line" : 683,
    "diffHunk" : "@@ -1,1 +1773,1777 @@\nfunc (gce *GCECloud) listClustersInZone(zone string) ([]string, error) {\n\tlist, err := gce.containerService.Projects.Zones.Clusters.List(gce.projectID, zone).Do()\n\tif err != nil {\n\t\treturn nil, err"
  },
  {
    "id" : "08bf9510-2aa9-4d9d-888e-66d250673025",
    "prId" : 17919,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b307a8ba-d864-45f9-814f-3c6b45d47ea4",
        "parentId" : null,
        "authorId" : null,
        "body" : "See above.  It looks like we might be able to delete this entire thing, or just return nil (like AWS and all other cloud providers seem to do).\n",
        "createdAt" : "2016-01-07T23:30:04Z",
        "updatedAt" : "2016-01-21T04:04:59Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "43cbfb74fec10f9cf0af346e373b4d01e1b9efa6",
    "line" : 691,
    "diffHunk" : "@@ -1,1 +1784,1788 @@}\n\nfunc (gce *GCECloud) ListClusters() ([]string, error) {\n\tallClusters := []string{}\n"
  },
  {
    "id" : "af59eb68-e610-4f44-b9ca-8add28dc408a",
    "prId" : 17919,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9c4d3e52-9eba-45a9-a3a9-9bd6e9e3d77c",
        "parentId" : null,
        "authorId" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "body" : "If `isHTTPErrorCode(err, http.StatusNotFound)` is true, line 1886 below will try to access `res.Zone`, causing nil-pointer dereference.\n",
        "createdAt" : "2016-01-21T23:46:37Z",
        "updatedAt" : "2016-01-21T23:46:37Z",
        "lastEditedBy" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "tags" : [
        ]
      }
    ],
    "commit" : "43cbfb74fec10f9cf0af346e373b4d01e1b9efa6",
    "line" : 786,
    "diffHunk" : "@@ -1,1 +1879,1883 @@\t\tres, err := gce.service.Instances.Get(gce.projectID, zone, name).Do()\n\t\tif err != nil {\n\t\t\tif !isHTTPErrorCode(err, http.StatusNotFound) {\n\t\t\t\treturn nil, err\n\t\t\t}"
  },
  {
    "id" : "6f820ede-f4ff-4da9-a572-bc7ff9b27a77",
    "prId" : 17276,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "29780dfc-1f7d-4bd5-b238-b550ed9eb3bd",
        "parentId" : null,
        "authorId" : "c2b5c827-efcd-438f-8db5-52d917b1cde9",
        "body" : "It is going to be less reliable for machines running in GCE to hit the GCE API than the local metadata server. In the past we've seen it do things like exhaust the quota limit for the user making it impossible for them to use their project for a day. \n",
        "createdAt" : "2015-11-16T05:20:34Z",
        "updatedAt" : "2015-11-20T19:50:28Z",
        "lastEditedBy" : "c2b5c827-efcd-438f-8db5-52d917b1cde9",
        "tags" : [
        ]
      },
      {
        "id" : "e4aab003-b951-4ed4-9015-b77e84aa44bc",
        "parentId" : "29780dfc-1f7d-4bd5-b238-b550ed9eb3bd",
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "I'll fork the code to use Metadata to fetch network name when running inside the cluster, and a REST API call when outside (E2E).\n",
        "createdAt" : "2015-11-16T19:39:59Z",
        "updatedAt" : "2015-11-20T19:50:28Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      }
    ],
    "commit" : "882469dd7bbe8b4bc98dcb8dfcd9ee27c437ab9b",
    "line" : null,
    "diffHunk" : "@@ -1,1 +134,138 @@\nfunc getNetworkNameViaAPICall(svc *compute.Service, projectID string) (string, error) {\n\tnetworkList, err := svc.Networks.List(projectID).Do()\n\tif err != nil {\n\t\treturn \"\", err"
  },
  {
    "id" : "48498603-2190-4d79-bdbd-17fc68026cc8",
    "prId" : 17276,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c2643d25-a155-43fc-abed-4cd6c0a927c2",
        "parentId" : null,
        "authorId" : "c2b5c827-efcd-438f-8db5-52d917b1cde9",
        "body" : "Are all of these scopes necessary?\n",
        "createdAt" : "2015-11-16T05:21:47Z",
        "updatedAt" : "2015-11-20T19:50:28Z",
        "lastEditedBy" : "c2b5c827-efcd-438f-8db5-52d917b1cde9",
        "tags" : [
        ]
      },
      {
        "id" : "196c1358-74ec-4861-a931-72ed76f1e8e3",
        "parentId" : "c2643d25-a155-43fc-abed-4cd6c0a927c2",
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "I think we can get away with just `Compute` and `CloudPlatform`. I'll remove `DevStorage`.\n",
        "createdAt" : "2015-11-16T19:43:03Z",
        "updatedAt" : "2015-11-20T19:50:28Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      }
    ],
    "commit" : "882469dd7bbe8b4bc98dcb8dfcd9ee27c437ab9b",
    "line" : null,
    "diffHunk" : "@@ -1,1 +191,195 @@\t\tvar err error\n\t\ttokenSource, err = google.DefaultTokenSource(\n\t\t\toauth2.NoContext,\n\t\t\tcompute.CloudPlatformScope,\n\t\t\tcompute.ComputeScope)"
  },
  {
    "id" : "d1f61678-9ddd-417d-8848-82a193003327",
    "prId" : 16053,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "29fdf93b-b835-477f-9525-3efedda7dc5a",
        "parentId" : null,
        "authorId" : "3cd3a661-80f4-45b3-bae0-5a78fbaedc59",
        "body" : "Was removing this intentional?\n",
        "createdAt" : "2015-10-21T22:21:43Z",
        "updatedAt" : "2015-10-23T18:59:08Z",
        "lastEditedBy" : "3cd3a661-80f4-45b3-bae0-5a78fbaedc59",
        "tags" : [
        ]
      },
      {
        "id" : "d84acd17-f426-4b94-af25-83c3f769c42d",
        "parentId" : "29fdf93b-b835-477f-9525-3efedda7dc5a",
        "authorId" : "3cd3a661-80f4-45b3-bae0-5a78fbaedc59",
        "body" : "I see now it probably was.\n",
        "createdAt" : "2015-10-21T22:22:23Z",
        "updatedAt" : "2015-10-23T18:59:08Z",
        "lastEditedBy" : "3cd3a661-80f4-45b3-bae0-5a78fbaedc59",
        "tags" : [
        ]
      },
      {
        "id" : "73c6a925-f0b6-489e-aaee-d08633680d0c",
        "parentId" : "29fdf93b-b835-477f-9525-3efedda7dc5a",
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "Yep, intentional. If the disk is already attached, I want this to error out, and let the PD attach/detach code resolve it.\n",
        "createdAt" : "2015-10-22T00:11:40Z",
        "updatedAt" : "2015-10-23T18:59:08Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      }
    ],
    "commit" : "19115b2a222a4bdf4555a39dc721ed6dfdd9fc56",
    "line" : 110,
    "diffHunk" : "@@ -1,1 +1455,1459 @@\tattachOp, err := gce.service.Instances.AttachDisk(gce.projectID, gce.zone, gce.instanceID, attachedDisk).Do()\n\tif err != nil {\n\t\treturn err\n\t}\n"
  },
  {
    "id" : "d19259d6-d72a-4e70-a6a2-7ae1bb34fa26",
    "prId" : 15286,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5681d07c-1134-4eae-88b1-300022028f88",
        "parentId" : null,
        "authorId" : "3cd3a661-80f4-45b3-bae0-5a78fbaedc59",
        "body" : "I think it'd be clearer to structure this a little differently (because this logic is damn confusing).\n\nI was thinking\n\n```\nif fwdRuleNeedsUpdate || tpNeedsUpdate {\n    if fwdRuleExists {\n        // delete forwarding rule.\n    }\n    if tpNeedsUpdate {\n        if tpExists {\n            // delete target pool.\n        }\n        // create target pool.\n    }\n    // create forwarding rule\n}\n```\n\nI'm also fine if you think it's clearer as is.\n",
        "createdAt" : "2015-10-08T23:26:38Z",
        "updatedAt" : "2015-10-09T20:46:52Z",
        "lastEditedBy" : "3cd3a661-80f4-45b3-bae0-5a78fbaedc59",
        "tags" : [
        ]
      },
      {
        "id" : "021afbdd-0ca3-4033-a036-f091b8f0f14e",
        "parentId" : "5681d07c-1134-4eae-88b1-300022028f88",
        "authorId" : "7766e039-aa4c-4476-9091-5cc8763fa8d6",
        "body" : "I played around with it, and it didn't really seem to make anything clearer, just much more heavily nested. The code was exactly the same, just nested more, which to me made it look even less understandable. Happy to chat about this offline if you'd like.\n",
        "createdAt" : "2015-10-09T17:26:58Z",
        "updatedAt" : "2015-10-09T20:46:52Z",
        "lastEditedBy" : "7766e039-aa4c-4476-9091-5cc8763fa8d6",
        "tags" : [
        ]
      },
      {
        "id" : "7f0e7bfa-08ce-4224-bbb8-a02d5cc77f17",
        "parentId" : "5681d07c-1134-4eae-88b1-300022028f88",
        "authorId" : "3cd3a661-80f4-45b3-bae0-5a78fbaedc59",
        "body" : "I'll buy the excessive nesting argument... I still think it would make it clearer/harder to mess up, but it's not worth holding up this PR.\n",
        "createdAt" : "2015-10-09T21:10:54Z",
        "updatedAt" : "2015-10-09T21:10:54Z",
        "lastEditedBy" : "3cd3a661-80f4-45b3-bae0-5a78fbaedc59",
        "tags" : [
        ]
      }
    ],
    "commit" : "29c607bed672db124462f1b20dc75cc03ced436d",
    "line" : null,
    "diffHunk" : "@@ -1,1 +391,395 @@\t}\n\n\t// Now we get to some slightly more interesting logic.\n\t// First, neither target pools nor forwarding rules can be updated in place -\n\t// they have to be deleted and recreated."
  },
  {
    "id" : "95e5c588-1ad5-4501-9452-a88b714827eb",
    "prId" : 15286,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b83b2664-f130-4f81-9129-7e3d6bbdf273",
        "parentId" : null,
        "authorId" : "3cd3a661-80f4-45b3-bae0-5a78fbaedc59",
        "body" : "Can you add a comment indicating that requestedIP == nil is how you specify no requested IP.\n",
        "createdAt" : "2015-10-09T00:11:47Z",
        "updatedAt" : "2015-10-09T20:46:52Z",
        "lastEditedBy" : "3cd3a661-80f4-45b3-bae0-5a78fbaedc59",
        "tags" : [
        ]
      },
      {
        "id" : "ffb718b8-20a7-47b4-a85a-e0156c96f65b",
        "parentId" : "b83b2664-f130-4f81-9129-7e3d6bbdf273",
        "authorId" : "3cd3a661-80f4-45b3-bae0-5a78fbaedc59",
        "body" : "Also comment that the ipAddress returned is the IP address currently in use by the forwarding rule.\n",
        "createdAt" : "2015-10-09T00:20:47Z",
        "updatedAt" : "2015-10-09T20:46:52Z",
        "lastEditedBy" : "3cd3a661-80f4-45b3-bae0-5a78fbaedc59",
        "tags" : [
        ]
      },
      {
        "id" : "45075cf5-bea4-4ea2-986a-cdaf2d692cbf",
        "parentId" : "b83b2664-f130-4f81-9129-7e3d6bbdf273",
        "authorId" : "7766e039-aa4c-4476-9091-5cc8763fa8d6",
        "body" : "Comment added.\n",
        "createdAt" : "2015-10-09T17:22:33Z",
        "updatedAt" : "2015-10-09T20:46:52Z",
        "lastEditedBy" : "7766e039-aa4c-4476-9091-5cc8763fa8d6",
        "tags" : [
        ]
      }
    ],
    "commit" : "29c607bed672db124462f1b20dc75cc03ced436d",
    "line" : null,
    "diffHunk" : "@@ -1,1 +437,441 @@// Returns whether the forwarding rule exists, whether it needs to be updated,\n// what its IP address is (if it exists), and any error we encountered.\nfunc (gce *GCECloud) forwardingRuleNeedsUpdate(name, region string, requestedIP net.IP, ports []*api.ServicePort) (exists bool, needsUpdate bool, ipAddress string, err error) {\n\tfwd, err := gce.service.ForwardingRules.Get(gce.projectID, region, name).Do()\n\tif err != nil {"
  },
  {
    "id" : "6eff375d-44be-4d37-bb86-1bcbece76dfb",
    "prId" : 15286,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "808388cb-2b21-4236-b67b-2186239e9254",
        "parentId" : null,
        "authorId" : "3cd3a661-80f4-45b3-bae0-5a78fbaedc59",
        "body" : "We really need an `(op, error)` handling function :wink:\n",
        "createdAt" : "2015-10-09T00:43:29Z",
        "updatedAt" : "2015-10-09T20:46:52Z",
        "lastEditedBy" : "3cd3a661-80f4-45b3-bae0-5a78fbaedc59",
        "tags" : [
        ]
      },
      {
        "id" : "2c5375e9-ab66-43d3-a502-8924b8f8bbf7",
        "parentId" : "808388cb-2b21-4236-b67b-2186239e9254",
        "authorId" : "7766e039-aa4c-4476-9091-5cc8763fa8d6",
        "body" : "Yeah, yeah, yeah... A little extra motivation is all I needed\n",
        "createdAt" : "2015-10-09T17:28:28Z",
        "updatedAt" : "2015-10-09T20:46:52Z",
        "lastEditedBy" : "7766e039-aa4c-4476-9091-5cc8763fa8d6",
        "tags" : [
        ]
      },
      {
        "id" : "31b38e88-0e33-435a-86bb-fa341c5ba6a9",
        "parentId" : "808388cb-2b21-4236-b67b-2186239e9254",
        "authorId" : "7766e039-aa4c-4476-9091-5cc8763fa8d6",
        "body" : "Actually, I'm not convinced it's all that useful, since I don't see any more than 2 functions that poll in the exact same way - some places have a regional op to poll while others have a global op; some consider StatusConflict a success, others consider StatusNotFound a success, while others consider them both failures; the delete functions give useful resource-specific wrappers around the errors.\n\nI'm going to skip this for now.\n",
        "createdAt" : "2015-10-09T17:38:29Z",
        "updatedAt" : "2015-10-09T20:46:52Z",
        "lastEditedBy" : "7766e039-aa4c-4476-9091-5cc8763fa8d6",
        "tags" : [
        ]
      }
    ],
    "commit" : "29c607bed672db124462f1b20dc75cc03ced436d",
    "line" : 431,
    "diffHunk" : "@@ -1,1 +587,591 @@\t\tSessionAffinity: translateAffinityType(affinityType),\n\t}\n\top, err := gce.service.TargetPools.Insert(gce.projectID, region, pool).Do()\n\tif err != nil && !isHTTPErrorCode(err, http.StatusConflict) {\n\t\treturn err"
  },
  {
    "id" : "aa24e72e-4af0-49ce-8517-03123bad9bad",
    "prId" : 14964,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ef994c1d-5408-40c2-9c1f-2acdce9990e5",
        "parentId" : null,
        "authorId" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "body" : "This line seems to duplicate line https://github.com/kubernetes/kubernetes/blob/master/pkg/cloudprovider/providers/gce/gce.go#L403\n",
        "createdAt" : "2015-10-02T17:09:42Z",
        "updatedAt" : "2015-10-05T22:43:35Z",
        "lastEditedBy" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "tags" : [
        ]
      },
      {
        "id" : "564f82da-fdfa-4d56-9b20-8eb4bad3b6c4",
        "parentId" : "ef994c1d-5408-40c2-9c1f-2acdce9990e5",
        "authorId" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "body" : "We can delete L403, as loadBalancerIP won't be nil now.\n",
        "createdAt" : "2015-10-02T17:55:19Z",
        "updatedAt" : "2015-10-05T22:43:35Z",
        "lastEditedBy" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "tags" : [
        ]
      },
      {
        "id" : "15e2be1f-5cb8-4a46-9598-a515b0c98bd8",
        "parentId" : "ef994c1d-5408-40c2-9c1f-2acdce9990e5",
        "authorId" : "7766e039-aa4c-4476-9091-5cc8763fa8d6",
        "body" : "Indeed, good catch. I should have caught that in the initial review\n",
        "createdAt" : "2015-10-05T20:30:23Z",
        "updatedAt" : "2015-10-05T22:43:35Z",
        "lastEditedBy" : "7766e039-aa4c-4476-9091-5cc8763fa8d6",
        "tags" : [
        ]
      }
    ],
    "commit" : "90a9e01a689de36e5143575e8e8d7bf9741112c4",
    "line" : 86,
    "diffHunk" : "@@ -1,1 +455,459 @@\treq := &compute.ForwardingRule{\n\t\tName:       name,\n\t\tIPAddress:  loadBalancerIP.String(),\n\t\tIPProtocol: \"TCP\",\n\t\tPortRange:  fmt.Sprintf(\"%d-%d\", minPort, maxPort),"
  },
  {
    "id" : "04cd4cc8-4fce-46e2-93d8-1aabd34f1efd",
    "prId" : 14964,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "dcda5791-0edc-44f4-a162-8ac395cb5c95",
        "parentId" : null,
        "authorId" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "body" : "Just to be sure, can one static IP be matched to multiple forwarding rules? I assume the answer is yes.\n",
        "createdAt" : "2015-10-02T17:52:32Z",
        "updatedAt" : "2015-10-05T22:43:35Z",
        "lastEditedBy" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "tags" : [
        ]
      },
      {
        "id" : "6e0f9959-1c13-45c4-b40c-723c94f6c69b",
        "parentId" : "dcda5791-0edc-44f4-a162-8ac395cb5c95",
        "authorId" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "body" : "To answer to my own question, the answer is no, one static IP can only be bound to one forwarding rule.\n\nThis doesn't seem to cause any problem, because GCE's API will fail the forwarding rule creation anyway. I'm considering if we can maintain a list of static IPs that have already bound to a forwarding rule, so that we can return an error before making a remote call.\n",
        "createdAt" : "2015-10-05T16:57:04Z",
        "updatedAt" : "2015-10-05T22:43:35Z",
        "lastEditedBy" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "tags" : [
        ]
      },
      {
        "id" : "e03b59e0-e243-419f-8d1d-0b1e9aa74f6c",
        "parentId" : "dcda5791-0edc-44f4-a162-8ac395cb5c95",
        "authorId" : "7766e039-aa4c-4476-9091-5cc8763fa8d6",
        "body" : "Correct - each static IP can only be bound to one forwarding rule. However, because we name the address and forwarding rule the same (based on the service UID), we shouldn't hit a case where a particular static IP is already bound to a different forwarding rule.\n",
        "createdAt" : "2015-10-05T20:29:16Z",
        "updatedAt" : "2015-10-05T22:43:35Z",
        "lastEditedBy" : "7766e039-aa4c-4476-9091-5cc8763fa8d6",
        "tags" : [
        ]
      },
      {
        "id" : "38571001-6835-427c-a104-f45d02506201",
        "parentId" : "dcda5791-0edc-44f4-a162-8ac395cb5c95",
        "authorId" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "body" : "I disagree. `loadBalancerIP` is parsed from `service.Spec.LoadBalancerIP`, it can be any value specified by the user, so it's possible to be a static IP that has already bound to a different forwarding rule.\ni.e, if a user calls EnsureTCPLoadBalancer with a new name but existing loadBalancerIP, then it will hit the case described above.\n",
        "createdAt" : "2015-10-05T20:49:12Z",
        "updatedAt" : "2015-10-05T22:43:35Z",
        "lastEditedBy" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "tags" : [
        ]
      },
      {
        "id" : "84bb571c-46e2-40e5-83fc-30d74e221302",
        "parentId" : "dcda5791-0edc-44f4-a162-8ac395cb5c95",
        "authorId" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "body" : "Anyway, this may not be a problem. In such a case, the service controller will keep failing creating the load balancer, which is a fair behavior. I'm just suggesting maybe we can fail such requests before making a remote call to save a roundtrip.\n",
        "createdAt" : "2015-10-05T20:52:18Z",
        "updatedAt" : "2015-10-05T22:43:35Z",
        "lastEditedBy" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "tags" : [
        ]
      },
      {
        "id" : "8a5b5201-511f-44aa-8de1-04293b4fc710",
        "parentId" : "dcda5791-0edc-44f4-a162-8ac395cb5c95",
        "authorId" : "7766e039-aa4c-4476-9091-5cc8763fa8d6",
        "body" : "Yes, you're absolutely right, I forgot we had added that option.\n\nForwarding rule creation will fail with the error that the IP address is already in use. Relying on that seems fine since it should fail quickly, but we could short-circuit things by using the attributes of the address returned from the list request. The attributes include whether it's in use and by what.\n",
        "createdAt" : "2015-10-05T21:06:57Z",
        "updatedAt" : "2015-10-05T22:43:35Z",
        "lastEditedBy" : "7766e039-aa4c-4476-9091-5cc8763fa8d6",
        "tags" : [
        ]
      },
      {
        "id" : "de75b8ae-c332-4625-86dd-ff2e50dcccb2",
        "parentId" : "dcda5791-0edc-44f4-a162-8ac395cb5c95",
        "authorId" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "body" : "Good to know the attributes already contain the information. It sounds like a good idea. I will not block the PR on this possible improvement. I will LGTM it when you delete line 403. \n",
        "createdAt" : "2015-10-05T21:18:28Z",
        "updatedAt" : "2015-10-05T22:43:35Z",
        "lastEditedBy" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "tags" : [
        ]
      }
    ],
    "commit" : "90a9e01a689de36e5143575e8e8d7bf9741112c4",
    "line" : 75,
    "diffHunk" : "@@ -1,1 +414,418 @@\t\tif !ownsAddress(loadBalancerIP, addresses.Items) {\n\t\t\treturn nil, fmt.Errorf(\"this gce project don't own the IP address: %s\", loadBalancerIP.String())\n\t\t}\n\t}\n"
  },
  {
    "id" : "0fb45b29-bf40-4cfc-969f-7828440fc342",
    "prId" : 14430,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1e382176-585f-4f20-b339-87be2737cb39",
        "parentId" : null,
        "authorId" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "body" : "We should return an error in this case.\n",
        "createdAt" : "2015-09-23T17:14:10Z",
        "updatedAt" : "2015-09-23T17:14:10Z",
        "lastEditedBy" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "tags" : [
        ]
      },
      {
        "id" : "3709b23e-7d50-4edc-b01e-7b8299668e7c",
        "parentId" : "1e382176-585f-4f20-b339-87be2737cb39",
        "authorId" : "537fd325-3646-446a-b1d0-2c1c5569384f",
        "body" : "See  #13035, creating the rule without tags should not be an error case if none of the instances have tags.\n",
        "createdAt" : "2015-09-23T17:24:00Z",
        "updatedAt" : "2015-09-23T18:24:57Z",
        "lastEditedBy" : "537fd325-3646-446a-b1d0-2c1c5569384f",
        "tags" : [
        ]
      }
    ],
    "commit" : "65ad351c7fb3b5ca4f42a5d2fc56a366abdc20ec",
    "line" : 67,
    "diffHunk" : "@@ -1,1 +488,492 @@\n\tif len(tags) == 0 {\n\t\tglog.V(2).Info(\"No instances had tags, creating rule without target tags\")\n\t}\n"
  },
  {
    "id" : "701f3e36-a941-42e5-b01f-811d8e218ee6",
    "prId" : 14430,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "05d4fe38-cc76-4093-b5cf-a96da56b6fa1",
        "parentId" : null,
        "authorId" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "body" : "Why would there ever be more than one tag?\n",
        "createdAt" : "2015-09-23T17:14:53Z",
        "updatedAt" : "2015-09-23T17:14:53Z",
        "lastEditedBy" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "tags" : [
        ]
      },
      {
        "id" : "279a515d-7110-41e8-b1ed-8754620ae615",
        "parentId" : "05d4fe38-cc76-4093-b5cf-a96da56b6fa1",
        "authorId" : "537fd325-3646-446a-b1d0-2c1c5569384f",
        "body" : "See  #13035, only in the current GKE case can you assume that all instances will be tagged the same.  This allows for setting separate tags per instance and when the pool logic only adds the instances serving the pods to the pool, you will end up with only those instances allowed to receive that traffic.\n",
        "createdAt" : "2015-09-23T17:25:25Z",
        "updatedAt" : "2015-09-23T18:25:03Z",
        "lastEditedBy" : "537fd325-3646-446a-b1d0-2c1c5569384f",
        "tags" : [
        ]
      },
      {
        "id" : "5445de57-9c0a-4b77-93e5-a1db21f7aa57",
        "parentId" : "05d4fe38-cc76-4093-b5cf-a96da56b6fa1",
        "authorId" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "body" : "Ok, I'm convinced.   Please add unit tests for this function.\n",
        "createdAt" : "2015-09-26T03:39:48Z",
        "updatedAt" : "2015-09-26T03:39:48Z",
        "lastEditedBy" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "tags" : [
        ]
      }
    ],
    "commit" : "65ad351c7fb3b5ca4f42a5d2fc56a366abdc20ec",
    "line" : 36,
    "diffHunk" : "@@ -1,1 +458,462 @@// * If any instance has a prefix tag, all instances must\n// * If no instances have a prefix tag, no tags are used\nfunc (gce *GCECloud) computeHostTags(hosts []string) ([]string, error) {\n\tlistCall := gce.service.Instances.List(gce.projectID, gce.zone)\n"
  },
  {
    "id" : "df391564-ac11-4056-be2d-52353abf7611",
    "prId" : 13946,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "87446ce1-be5b-4a6a-a639-87e43dd8d9d4",
        "parentId" : null,
        "authorId" : "3cd3a661-80f4-45b3-bae0-5a78fbaedc59",
        "body" : "If we want this to be a generic method in the cloudprovider Interface (do we?), it shouldn't take/return compute pkg structs. But I suppose we can cross that bridge when we come to it.\n",
        "createdAt" : "2015-09-15T00:23:08Z",
        "updatedAt" : "2015-09-15T00:23:08Z",
        "lastEditedBy" : "3cd3a661-80f4-45b3-bae0-5a78fbaedc59",
        "tags" : [
        ]
      },
      {
        "id" : "69de0306-0801-42f7-ae45-3510450c6565",
        "parentId" : "87446ce1-be5b-4a6a-a639-87e43dd8d9d4",
        "authorId" : "395f4f9a-98be-4485-b436-51f0897d7c9f",
        "body" : "You mean like Route does right? https://github.com/kubernetes/kubernetes/blob/master/pkg/cloudprovider/cloud.go#L119\nI didn't want to impose the concept of urlmap/targetproxy/instance groups on all cloudproviders. At this point it'll be boilerplate for the other providers. I'll revist this when I figure out what these concepts map to on the other providers.  \n",
        "createdAt" : "2015-09-15T16:40:56Z",
        "updatedAt" : "2015-09-15T16:40:56Z",
        "lastEditedBy" : "395f4f9a-98be-4485-b436-51f0897d7c9f",
        "tags" : [
        ]
      },
      {
        "id" : "e18babde-c974-4dc7-ae80-0ea1f3382431",
        "parentId" : "87446ce1-be5b-4a6a-a639-87e43dd8d9d4",
        "authorId" : "3cd3a661-80f4-45b3-bae0-5a78fbaedc59",
        "body" : "I think that's the right approach (to not worry about other providers right now).\n",
        "createdAt" : "2015-09-15T16:42:10Z",
        "updatedAt" : "2015-09-15T16:42:47Z",
        "lastEditedBy" : "3cd3a661-80f4-45b3-bae0-5a78fbaedc59",
        "tags" : [
        ]
      }
    ],
    "commit" : "bd0eb34aec4d8ce33a8e18be3b527fafc647f04a",
    "line" : 12,
    "diffHunk" : "@@ -1,1 +575,579 @@\n// CreateUrlMap creates an url map, using the given backend service as the default service.\nfunc (gce *GCECloud) CreateUrlMap(backend *compute.BackendService, name string) (*compute.UrlMap, error) {\n\turlMap := &compute.UrlMap{\n\t\tName:           name,"
  },
  {
    "id" : "dc2462d0-dcd9-4e30-9fb1-f48499dd8640",
    "prId" : 13336,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bb6a3506-b66c-4fac-96a8-dc46865d21fc",
        "parentId" : null,
        "authorId" : "c2b5c827-efcd-438f-8db5-52d917b1cde9",
        "body" : "errors should start with a lower case letter :/ \n\nhttps://github.com/golang/go/wiki/CodeReviewComments#error-strings\n",
        "createdAt" : "2015-09-03T17:53:17Z",
        "updatedAt" : "2015-09-03T17:53:17Z",
        "lastEditedBy" : "c2b5c827-efcd-438f-8db5-52d917b1cde9",
        "tags" : [
        ]
      }
    ],
    "commit" : "cb7d3f01485d26679ca1d69adaf90c20aebbf2d3",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +354,358 @@func (gce *GCECloud) EnsureTCPLoadBalancer(name, region string, externalIP net.IP, ports []*api.ServicePort, hosts []string, affinityType api.ServiceAffinity) (*api.LoadBalancerStatus, error) {\n\tif len(hosts) == 0 {\n\t\treturn nil, fmt.Errorf(\"Cannot EnsureTCPLoadBalancer() with no hosts\")\n\t}\n"
  },
  {
    "id" : "18af3674-0b12-4f61-b2ec-be8a0ad3183a",
    "prId" : 13005,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fd55d935-ee71-4708-bbde-59d4343d94ab",
        "parentId" : null,
        "authorId" : "58cf89ce-9cc3-4dce-b99b-49ae3682cc9a",
        "body" : "(This TODO should probably be removed as part of this change)\n",
        "createdAt" : "2015-09-01T05:16:02Z",
        "updatedAt" : "2015-09-11T04:05:24Z",
        "lastEditedBy" : "58cf89ce-9cc3-4dce-b99b-49ae3682cc9a",
        "tags" : [
        ]
      },
      {
        "id" : "179df618-17ed-4771-8dda-ec6f12387793",
        "parentId" : "fd55d935-ee71-4708-bbde-59d4343d94ab",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "+1\n",
        "createdAt" : "2015-09-09T16:45:08Z",
        "updatedAt" : "2015-09-11T04:05:24Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "3180bd5f-cee1-416c-8316-745e4f1fae86",
        "parentId" : "fd55d935-ee71-4708-bbde-59d4343d94ab",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "Still +1\n",
        "createdAt" : "2015-09-11T00:29:17Z",
        "updatedAt" : "2015-09-11T04:05:24Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "44ce4aa423fca40dc392c625b83d1ccc635c4248",
    "line" : 2,
    "diffHunk" : "@@ -1,1 +351,355 @@\n// EnsureTCPLoadBalancer is an implementation of TCPLoadBalancer.EnsureTCPLoadBalancer.\n// TODO(a-robinson): Don't just ignore specified IP addresses. Check if they're\n// owned by the project and available to be used, and use them if they are.\nfunc (gce *GCECloud) EnsureTCPLoadBalancer(name, region string, loadBalancerIP net.IP, ports []*api.ServicePort, hosts []string, affinityType api.ServiceAffinity) (*api.LoadBalancerStatus, error) {"
  },
  {
    "id" : "493072b9-00ed-4a3b-9f83-92da2e746804",
    "prId" : 13005,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c739e0e7-718e-4f1f-8d03-93912ba68647",
        "parentId" : null,
        "authorId" : "58cf89ce-9cc3-4dce-b99b-49ae3682cc9a",
        "body" : "This.  I think my question is: Why isn't this entire change just the addition of:\n\n``` go\nif externalIP != nil {\n        req.IPAddress = externalIP.String()\n}\n```\n\n... and nothing else?\n",
        "createdAt" : "2015-09-01T05:16:43Z",
        "updatedAt" : "2015-09-11T04:05:24Z",
        "lastEditedBy" : "58cf89ce-9cc3-4dce-b99b-49ae3682cc9a",
        "tags" : [
        ]
      },
      {
        "id" : "dc771232-829f-4955-acdf-147af48b7000",
        "parentId" : "c739e0e7-718e-4f1f-8d03-93912ba68647",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "externalIPs are \"unmanaged\".  People typically use them, for example, to\nstick VM IPs in and expose a Service on a low NodePort.  I don't LIKE it as\nan API, but there were enough voices complaining when we tried to take it\naway...\n\nThe fundamental difference between externalIPs[] and\ntype=LoadBalancer+loadBalancerIP is that the latter is managed by\nkubernetes and the former are not.  Kubernetes will instantiate a\nloadbalancer and continually ensure that it is alive and valid for the\nmanaged case, and do nothing at all with the unmanaged case.\n\nTim\n\nOn Mon, Aug 31, 2015 at 10:17 PM, Angus Lees notifications@github.com\nwrote:\n\n> In pkg/cloudprovider/providers/gce/gce.go\n> https://github.com/kubernetes/kubernetes/pull/13005#discussion_r38386270\n> :\n> \n> > @@ -394,6 +394,10 @@ func (gce *GCECloud) EnsureTCPLoadBalancer(name, region string, externalIP net.I\n> >         PortRange:  fmt.Sprintf(\"%d-%d\", minPort, maxPort),\n> >         Target:     gce.targetPoolURL(name, region),\n> >     }\n> > -   if loadBalancerIP != nil {\n> > -       req.IPAddress = loadBalancerIP.String()\n> \n> This. I think my question is: Why isn't this entire change just the\n> addition of:\n> \n> if externalIP != nil {\n>         req.IPAddress = externalIP.String()\n> }\n> \n> ... and nothing else?\n> \n> \n> Reply to this email directly or view it on GitHub\n> https://github.com/kubernetes/kubernetes/pull/13005/files#r38386270.\n",
        "createdAt" : "2015-09-01T05:32:34Z",
        "updatedAt" : "2015-09-11T04:05:24Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "b230688d-3827-4cdf-8ba9-e57d4accd19c",
        "parentId" : "c739e0e7-718e-4f1f-8d03-93912ba68647",
        "authorId" : "58cf89ce-9cc3-4dce-b99b-49ae3682cc9a",
        "body" : "Aha, thanks - I think I finally understand now.  The OpenStack plugin has always (perhaps mistakenly) implemented externalIP exactly as you're trying to do with this change, hence my confusion (ie: a single externalIP and type=LoadBalancer uses some existing IP allocated outside k8s; no externalIP allocates/destroys a new IP along with the loadbalancer).  On the upside, that means the plugin should just continue to work once we formalise that interpretation :)\n",
        "createdAt" : "2015-09-01T06:13:49Z",
        "updatedAt" : "2015-09-11T04:05:24Z",
        "lastEditedBy" : "58cf89ce-9cc3-4dce-b99b-49ae3682cc9a",
        "tags" : [
        ]
      },
      {
        "id" : "dc1cdfe2-a7bf-41a5-bd3c-96fba1f17766",
        "parentId" : "c739e0e7-718e-4f1f-8d03-93912ba68647",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "Where does it get the IP from today?\n\nOn Mon, Aug 31, 2015 at 11:14 PM, Angus Lees notifications@github.com\nwrote:\n\n> In pkg/cloudprovider/providers/gce/gce.go\n> https://github.com/kubernetes/kubernetes/pull/13005#discussion_r38388282\n> :\n> \n> > @@ -394,6 +394,10 @@ func (gce *GCECloud) EnsureTCPLoadBalancer(name, region string, externalIP net.I\n> >         PortRange:  fmt.Sprintf(\"%d-%d\", minPort, maxPort),\n> >         Target:     gce.targetPoolURL(name, region),\n> >     }\n> > -   if loadBalancerIP != nil {\n> > -       req.IPAddress = loadBalancerIP.String()\n> \n> Aha, thanks - I think I finally understand now. The OpenStack plugin has\n> always (perhaps mistakenly) implemented externalIP exactly as you're trying\n> to do with this change, hence my confusion. On the upside, that means the\n> plugin should just continue to work once we formalise that interpretation :)\n> \n> \n> Reply to this email directly or view it on GitHub\n> https://github.com/kubernetes/kubernetes/pull/13005/files#r38388282.\n",
        "createdAt" : "2015-09-01T06:35:30Z",
        "updatedAt" : "2015-09-11T04:05:24Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "d5a8b7a0-278e-4f20-95e0-a39eef26d00c",
        "parentId" : "c739e0e7-718e-4f1f-8d03-93912ba68647",
        "authorId" : "58cf89ce-9cc3-4dce-b99b-49ae3682cc9a",
        "body" : "It uses the `externalIP` arg passed to `EnsureTCPLoadBalancer` (if non-nil) - exactly as is proposed for gce above (if I understand the gce API).\n\nSo there's two cases (as I understand the existing code):\n- type=LoadBalancer and no ExternalIPs:  the plugin allocates a new public IP, uses it, and destroys it when you remove the service/loadbalancer.\n- type=LoadBalancer and ExternalIPs: the plugin is passed the first externalIP and the openstack plugin just uses it as the loadbalancer IP.  If the user provided an invalid IP for some reason, it will return an error.  How/where the user got that IP is up to them.\n\nIn other words, if you were to create a type=loadbalancer service and put a VM IP in ExternalIPs (as in your example above), the openstack plugin would throw an error - and it's been that way for some time.\n",
        "createdAt" : "2015-09-01T07:53:30Z",
        "updatedAt" : "2015-09-11T04:05:24Z",
        "lastEditedBy" : "58cf89ce-9cc3-4dce-b99b-49ae3682cc9a",
        "tags" : [
        ]
      },
      {
        "id" : "583424b1-57ed-4e01-b883-d33c5013a12b",
        "parentId" : "c739e0e7-718e-4f1f-8d03-93912ba68647",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "Right, so it DOES sound like the OS balancer is ready for this feature,\njust using the wrong field :)\n\nOn Tue, Sep 1, 2015 at 12:54 AM, Angus Lees notifications@github.com\nwrote:\n\n> In pkg/cloudprovider/providers/gce/gce.go\n> https://github.com/kubernetes/kubernetes/pull/13005#discussion_r38393572\n> :\n> \n> > @@ -394,6 +394,10 @@ func (gce *GCECloud) EnsureTCPLoadBalancer(name, region string, externalIP net.I\n> >         PortRange:  fmt.Sprintf(\"%d-%d\", minPort, maxPort),\n> >         Target:     gce.targetPoolURL(name, region),\n> >     }\n> > -   if loadBalancerIP != nil {\n> > -       req.IPAddress = loadBalancerIP.String()\n> \n> It uses the externalIP arg passed to EnsureTCPLoadBalancer (if non-nil).\n> \n> So there's two cases (as I understand the existing code):\n> - type=LoadBalancer and no ExternalIPs: the plugin allocates a new\n>   public IP, uses it, and destroys it when you remove the\n>   service/loadbalancer.\n> - type=LoadBalancer and ExternalIPs: the plugin is passed the first\n>   externalIP and the openstack plugin just uses it as the loadbalancer IP. If\n>   the user provided an invalid IP for some reason, it will return an error.\n>   How/where the user got that IP is up to them.\n> \n> \n> Reply to this email directly or view it on GitHub\n> https://github.com/kubernetes/kubernetes/pull/13005/files#r38393572.\n",
        "createdAt" : "2015-09-01T17:05:21Z",
        "updatedAt" : "2015-09-11T04:05:24Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "36006db9-9575-4894-9bfe-a6597e671112",
        "parentId" : "c739e0e7-718e-4f1f-8d03-93912ba68647",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "@anguslees we're getting close to \"code complete\" for v1.1 - if we get this PR in, will you be able to make time to test/fix openstack?\n\n@artfulcoder we should be able to make the first-order change (use the new field instead of externalIPs[0])\n",
        "createdAt" : "2015-09-09T16:46:57Z",
        "updatedAt" : "2015-09-11T04:05:24Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "44ce4aa423fca40dc392c625b83d1ccc635c4248",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +401,405 @@\t}\n\tif loadBalancerIP != nil {\n\t\treq.IPAddress = loadBalancerIP.String()\n\t}\n"
  }
]
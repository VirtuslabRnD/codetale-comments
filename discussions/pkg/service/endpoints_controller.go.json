[
  {
    "id" : "66b6d6ba-8493-493e-bb66-6e3c325993bb",
    "prId" : 8917,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5cb95ee1-12b4-405d-992c-5119bdf48103",
        "parentId" : null,
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "@thockin Is this the expected behavior in v1beta3 and v1?\n",
        "createdAt" : "2015-05-28T16:47:16Z",
        "updatedAt" : "2015-05-30T00:18:05Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "7f820b31-e858-4538-be3d-ed7f795521d1",
        "parentId" : "5cb95ee1-12b4-405d-992c-5119bdf48103",
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "Based on in-person discussion, this seems ok. \n\nTargetPort is initialized here:\nhttps://github.com/GoogleCloudPlatform/kubernetes/blob/master/pkg/api/v1beta3/defaults.go#L91\n",
        "createdAt" : "2015-05-28T20:06:35Z",
        "updatedAt" : "2015-05-30T00:18:05Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "1edbc8a4-4453-49da-826b-e80ed1b5a724",
        "parentId" : "5cb95ee1-12b4-405d-992c-5119bdf48103",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "LGTM\n",
        "createdAt" : "2015-05-29T05:46:18Z",
        "updatedAt" : "2015-05-30T00:18:05Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "cae548a4-e0da-4715-8e37-3c1c1a779edd",
        "parentId" : "5cb95ee1-12b4-405d-992c-5119bdf48103",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "NB: we still have a conflict here if the same port name is used on two containers, but thta is not this PR's problem.\n",
        "createdAt" : "2015-05-29T05:46:57Z",
        "updatedAt" : "2015-05-30T00:18:05Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "f4e2c738f6dea089af9b6253477d436a686c084f",
    "line" : 43,
    "diffHunk" : "@@ -1,1 +391,395 @@}\n\n// findPort locates the container port for the given pod and portName.  If the\n// targetPort is a number, use that.  If the targetPort is a string, look that\n// string up in all named ports in all containers in the target pod.  If no"
  },
  {
    "id" : "cba938d6-d0fa-442f-9dd3-6c2e9fae19fa",
    "prId" : 6943,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "efd5a3a7-302a-48d4-ad1e-4a1a2863c376",
        "parentId" : null,
        "authorId" : "df06b0d6-fd6c-44d1-8008-efeaccd16cd5",
        "body" : "What does this function do? When does it exit? Comment would be welcomed :)\n",
        "createdAt" : "2015-04-17T08:58:13Z",
        "updatedAt" : "2015-04-17T22:32:58Z",
        "lastEditedBy" : "df06b0d6-fd6c-44d1-8008-efeaccd16cd5",
        "tags" : [
        ]
      }
    ],
    "commit" : "a2953fdc7ef5a9705f9e595a8c332eab055af4a2",
    "line" : null,
    "diffHunk" : "@@ -1,1 +231,235 @@// workqueue guarantees that they will not end up processing the same service\n// at the same time.\nfunc (e *EndpointController) worker() {\n\tfor {\n\t\tfunc() {"
  },
  {
    "id" : "f9ce8f53-5508-4e04-89f7-e6ccdea4c82c",
    "prId" : 6943,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d74e1540-6e55-43bd-82e1-255f7dfbf815",
        "parentId" : null,
        "authorId" : "df06b0d6-fd6c-44d1-8008-efeaccd16cd5",
        "body" : "Shouldn't we requeue this service in case of error? It could fail because it was rate limited.\n",
        "createdAt" : "2015-04-17T09:04:57Z",
        "updatedAt" : "2015-04-17T22:32:58Z",
        "lastEditedBy" : "df06b0d6-fd6c-44d1-8008-efeaccd16cd5",
        "tags" : [
        ]
      },
      {
        "id" : "1209f21a-5eda-44dd-a5ff-aee6b6210331",
        "parentId" : "d74e1540-6e55-43bd-82e1-255f7dfbf815",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "Hm-- We could do so. I was thinking that endpoint controller now won't require a rate limit. But it won't hurt to re add it.\n\n...does the rate limit fail requests? I'd have expected it to just delay them. hm.\n",
        "createdAt" : "2015-04-17T17:17:15Z",
        "updatedAt" : "2015-04-17T22:32:58Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      }
    ],
    "commit" : "a2953fdc7ef5a9705f9e595a8c332eab055af4a2",
    "line" : null,
    "diffHunk" : "@@ -1,1 +268,272 @@\t\terr = e.client.Endpoints(namespace).Delete(name)\n\t\tif err != nil && !errors.IsNotFound(err) {\n\t\t\tglog.Errorf(\"Error deleting endpoint %q: %v\", key, err)\n\t\t\te.queue.Add(key) // Retry\n\t\t}"
  },
  {
    "id" : "ec0625ed-2c58-448b-ace8-173b92efda57",
    "prId" : 6943,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "54e11810-fa48-4f1b-9fb6-9f7d870c6089",
        "parentId" : null,
        "authorId" : "df06b0d6-fd6c-44d1-8008-efeaccd16cd5",
        "body" : "Is it possible to update selector, such that it's empty? If yes, than I think we have a race:\n1. Endpoints controller should delete endpoints (right?)\n2. User might have created new endpoints already\n\nI think this is not something we should worry about too much, but maybe we should add a comment that it's possible. WDYT?\n",
        "createdAt" : "2015-04-17T09:09:02Z",
        "updatedAt" : "2015-04-17T22:32:58Z",
        "lastEditedBy" : "df06b0d6-fd6c-44d1-8008-efeaccd16cd5",
        "tags" : [
        ]
      }
    ],
    "commit" : "a2953fdc7ef5a9705f9e595a8c332eab055af4a2",
    "line" : null,
    "diffHunk" : "@@ -1,1 +277,281 @@\tif service.Spec.Selector == nil {\n\t\t// services without a selector receive no endpoints from this controller;\n\t\t// these services will receive the endpoints that are created out-of-band via the REST API.\n\t\treturn\n\t}"
  },
  {
    "id" : "c766864e-bed4-42a7-af14-577c6cffee40",
    "prId" : 6943,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e6f94031-43da-4afe-bb2e-82411e221957",
        "parentId" : null,
        "authorId" : "df06b0d6-fd6c-44d1-8008-efeaccd16cd5",
        "body" : "Requeue?\n",
        "createdAt" : "2015-04-17T09:10:56Z",
        "updatedAt" : "2015-04-17T22:32:58Z",
        "lastEditedBy" : "df06b0d6-fd6c-44d1-8008-efeaccd16cd5",
        "tags" : [
        ]
      }
    ],
    "commit" : "a2953fdc7ef5a9705f9e595a8c332eab055af4a2",
    "line" : null,
    "diffHunk" : "@@ -1,1 +286,290 @@\t\t// Since we're getting stuff from a local cache, it is\n\t\t// basically impossible to get this error.\n\t\tglog.Errorf(\"Error syncing service %q: %v\", key, err)\n\t\te.queue.Add(key) // Retry\n\t\treturn"
  },
  {
    "id" : "c1d4ed07-842b-4505-897a-9ccfc280bb85",
    "prId" : 6943,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0fc2a994-7772-4238-ad89-9ea93f9a36a0",
        "parentId" : null,
        "authorId" : "df06b0d6-fd6c-44d1-8008-efeaccd16cd5",
        "body" : "requeue?\n",
        "createdAt" : "2015-04-17T09:36:38Z",
        "updatedAt" : "2015-04-17T22:32:58Z",
        "lastEditedBy" : "df06b0d6-fd6c-44d1-8008-efeaccd16cd5",
        "tags" : [
        ]
      }
    ],
    "commit" : "a2953fdc7ef5a9705f9e595a8c332eab055af4a2",
    "line" : null,
    "diffHunk" : "@@ -1,1 +354,358 @@\t\t\tglog.Errorf(\"Error getting endpoints: %v\", err)\n\t\t\te.queue.Add(key) // Retry\n\t\t\treturn\n\t\t}\n\t}"
  },
  {
    "id" : "b961cd52-df4f-4325-afd5-28da888ab210",
    "prId" : 6943,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6e3d6754-18ec-461c-b30c-7c60ea7fa2c6",
        "parentId" : null,
        "authorId" : "df06b0d6-fd6c-44d1-8008-efeaccd16cd5",
        "body" : "requeue?\n",
        "createdAt" : "2015-04-17T09:37:44Z",
        "updatedAt" : "2015-04-17T22:32:58Z",
        "lastEditedBy" : "df06b0d6-fd6c-44d1-8008-efeaccd16cd5",
        "tags" : [
        ]
      },
      {
        "id" : "6d7d5b9d-3d97-408d-be87-c2a53ca183bc",
        "parentId" : "6e3d6754-18ec-461c-b30c-7c60ea7fa2c6",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "done\n",
        "createdAt" : "2015-04-17T18:41:05Z",
        "updatedAt" : "2015-04-17T22:32:58Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      }
    ],
    "commit" : "a2953fdc7ef5a9705f9e595a8c332eab055af4a2",
    "line" : 452,
    "diffHunk" : "@@ -1,1 +373,377 @@\t}\n\tif err != nil {\n\t\tglog.Errorf(\"Error updating endpoints: %v\", err)\n\t\te.queue.Add(key) // Retry\n\t}"
  },
  {
    "id" : "6c9ca5a9-016b-499a-b80b-e5caecdc0c31",
    "prId" : 4580,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0da0e710-8646-4ede-ae5a-ce4f09e6fe74",
        "parentId" : null,
        "authorId" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "body" : "no cute names...\n",
        "createdAt" : "2015-02-19T07:03:44Z",
        "updatedAt" : "2015-02-19T07:03:44Z",
        "lastEditedBy" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "tags" : [
        ]
      },
      {
        "id" : "8e773753-a75b-4937-8828-4044bee04df8",
        "parentId" : "0da0e710-8646-4ede-ae5a-ce4f09e6fe74",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "I generally agree with that sentiment, except that \"haystack\" and \"needle\" go back to K&R C's definition of strstr() - in this case I think it improves readability.  I could be haggled down to something like allEndpoints and endpoint, if you feel stringly.\n",
        "createdAt" : "2015-02-19T07:42:44Z",
        "updatedAt" : "2015-02-19T07:42:44Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "ae0062d00109b1ef13f31c73770b99c8076c0563",
    "line" : 52,
    "diffHunk" : "@@ -1,1 +127,131 @@}\n\nfunc containsEndpoint(haystack *api.Endpoints, needle *api.Endpoint) bool {\n\tif haystack == nil || needle == nil {\n\t\treturn false"
  },
  {
    "id" : "099605e5-ffee-47e5-a30b-9b10b84338c1",
    "prId" : 3729,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "391cf77d-f759-4e39-ae76-cac93c3d90a4",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "We should land on one syntax for printing namespace and name (for all sorts of objects) \"namespace/name\" vs \"name.namespace\" vs other.\n\nnamepsace/name has an advantage when both name and namespace are DNS subdomains: \"foo.bar/quux.zorb\" is clear, while \"quux.zorb.foo.bar\" is ambiguous.\n\nIf we all agree, we should start enforcing it in code reviews and fixing it up when we find it.\n",
        "createdAt" : "2015-01-22T20:30:26Z",
        "updatedAt" : "2015-01-22T20:30:26Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "8f700168-b0cb-462d-8326-9d3e301004fd",
        "parentId" : "391cf77d-f759-4e39-ae76-cac93c3d90a4",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "Maybe write a util.JoinName(namespace, name string) string function?\n",
        "createdAt" : "2015-01-22T20:31:02Z",
        "updatedAt" : "2015-01-22T20:31:02Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "cdd75c43-6950-44ff-97b9-4841a133fd32",
        "parentId" : "391cf77d-f759-4e39-ae76-cac93c3d90a4",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Also UID and ResourceVersion\n\n----- Original Message -----\n\n> > @@ -56,10 +56,10 @@ func (e *EndpointController) SyncServiceEndpoints()\n> > error {\n> >             continue\n> >         }\n> > -       glog.V(3).Infof(\"About to update endpoints for service %v\",\n> >   service.Name)\n> > -       glog.V(5).Infof(\"About to update endpoints for service %s/%s\",\n> >   service.Namespace, service.Name)\n> \n> We should land on one syntax for printing namespace and name (for all sorts\n> of objects) \"namespace/name\" vs \"name.namespace\" vs other.\n> \n> namepsace/name has an advantage when both name and namespace are DNS\n> subdomains: \"foo.bar/quux.zorb\" is clear, while \"quux.zorb.foo.bar\" is\n> ambiguous.\n> \n> If we all agree, we should start enforcing it in code reviews and fixing it\n> up when we find it.\n> \n> ---\n> \n> Reply to this email directly or view it on GitHub:\n> https://github.com/GoogleCloudPlatform/kubernetes/pull/3729/files#r23407088\n",
        "createdAt" : "2015-01-22T20:32:01Z",
        "updatedAt" : "2015-01-22T20:32:01Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "b8f547f4-c812-4efc-a002-a802d15c1ece",
        "parentId" : "391cf77d-f759-4e39-ae76-cac93c3d90a4",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "I'm thinking maybe meta.Identify(runtime.Object) or something.  We need to be able to crack the object efficiently and work for runtime.Unknown as well.\n\n----- Original Message -----\n\n> > @@ -56,10 +56,10 @@ func (e *EndpointController) SyncServiceEndpoints()\n> > error {\n> >             continue\n> >         }\n> > -       glog.V(3).Infof(\"About to update endpoints for service %v\",\n> >   service.Name)\n> > -       glog.V(5).Infof(\"About to update endpoints for service %s/%s\",\n> >   service.Namespace, service.Name)\n> \n> Maybe write a util.JoinName(namespace, name string) string function?\n> \n> ---\n> \n> Reply to this email directly or view it on GitHub:\n> https://github.com/GoogleCloudPlatform/kubernetes/pull/3729/files#r23407127\n",
        "createdAt" : "2015-01-22T20:32:35Z",
        "updatedAt" : "2015-01-22T20:32:35Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      }
    ],
    "commit" : "7932bda3b3a19f3d7a0b22adeada0d7e2ca3a7aa",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +57,61 @@\t\t}\n\n\t\tglog.V(5).Infof(\"About to update endpoints for service %s/%s\", service.Namespace, service.Name)\n\t\tpods, err := e.client.Pods(service.Namespace).List(labels.Set(service.Spec.Selector).AsSelector())\n\t\tif err != nil {"
  },
  {
    "id" : "8dfecbfc-2af3-4f2c-a0b2-9a33f81d2730",
    "prId" : 2198,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4bd13ab3-777c-4c11-8aea-7864f5b0979f",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "if StrVal = \"\", you're now going to spend time looking for it, when you know it doesn't exist.  Actually, worse, you're going to hit on the first port that doesn't have a name (name is optional).\n\nI think you need to short-circuit if kind = string && StrVal == \"\" && first == -1\n",
        "createdAt" : "2014-11-06T06:52:19Z",
        "updatedAt" : "2014-11-07T05:56:09Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "2cb9c71c-84b1-4b67-8caf-1b5ea9713ae5",
        "parentId" : "4bd13ab3-777c-4c11-8aea-7864f5b0979f",
        "authorId" : "8c68bf8e-c808-4363-8a6e-4019eace89fe",
        "body" : "You are right. I was following the original logic. I was not sure if the shortcut worths the effort. \n\nI will add a test to catch the the worse case and fix it in the implementation.  \n\nSounds good?\n",
        "createdAt" : "2014-11-06T06:57:58Z",
        "updatedAt" : "2014-11-07T05:56:09Z",
        "lastEditedBy" : "8c68bf8e-c808-4363-8a6e-4019eace89fe",
        "tags" : [
        ]
      }
    ],
    "commit" : "5a7c00754f676ceec713d9b8d3f0ca35e75327fa",
    "line" : null,
    "diffHunk" : "@@ -1,1 +152,156 @@\t\t\tbreak\n\t\t}\n\t\tname := portName.StrVal\n\t\tfor _, container := range manifest.Containers {\n\t\t\tfor _, port := range container.Ports {"
  },
  {
    "id" : "b0fe57fd-ccb1-475e-913f-a3b4277855e9",
    "prId" : 2198,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "efe0cda6-8db5-4cdf-9e11-df6486fdca65",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "likewise, you'll return 0, nil here, which is invalid.\n",
        "createdAt" : "2014-11-06T06:53:15Z",
        "updatedAt" : "2014-11-07T05:56:09Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "a101e955-f28e-49f8-9b59-9f373e6f582c",
        "parentId" : "efe0cda6-8db5-4cdf-9e11-df6486fdca65",
        "authorId" : "8c68bf8e-c808-4363-8a6e-4019eace89fe",
        "body" : "yea. same thing happens for the original implementation. i will add a test to catch this.\n",
        "createdAt" : "2014-11-06T07:00:30Z",
        "updatedAt" : "2014-11-07T05:56:09Z",
        "lastEditedBy" : "8c68bf8e-c808-4363-8a6e-4019eace89fe",
        "tags" : [
        ]
      }
    ],
    "commit" : "5a7c00754f676ceec713d9b8d3f0ca35e75327fa",
    "line" : null,
    "diffHunk" : "@@ -1,1 +167,171 @@\t\t\tbreak\n\t\t}\n\t\treturn portName.IntVal, nil\n\t}\n"
  },
  {
    "id" : "b74ff210-0fd3-40b6-aad0-2b471e2f17b5",
    "prId" : 1465,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "13df87a7-23b5-40d4-a1d3-296bfbb28c18",
        "parentId" : null,
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "argh argh argh :(\n\nIs it really more than a handful of lines of code to fix the client? @smarterclayton has a bunch of functions that would be good for this in pkg/api/errors.\n\nI guess I won't block the PR on this, but only if we have a pact that the next person to use a client's error has to fix it.\n",
        "createdAt" : "2014-09-26T23:17:09Z",
        "updatedAt" : "2014-09-26T23:44:35Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "8e5b180e-9a14-4af6-9cb2-4c846fb669fe",
        "parentId" : "13df87a7-23b5-40d4-a1d3-296bfbb28c18",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "The client error is being returned all the way back - I'm 99% sure you can check api/errors.IsNotFound() on it.\n\n> On Sep 26, 2014, at 7:17 PM, Daniel Smith notifications@github.com wrote:\n> \n> In pkg/service/endpoints_controller.go:\n> \n> > @@ -72,11 +73,34 @@ func (e *EndpointController) SyncServiceEndpoints() error {\n> >             }\n> >             endpoints[ix] = net.JoinHostPort(pod.CurrentState.PodIP, strconv.Itoa(port))\n> >         }\n> > -       // TODO: this is totally broken, we need to compute this and store inside an AtomicUpdate loop.\n> > -       err = e.serviceRegistry.UpdateEndpoints(api.NewContext(), &api.Endpoints{\n> > -           JSONBase:  api.JSONBase{ID: service.ID},\n> > -       currentEndpoints, err := e.client.GetEndpoints(service.ID)\n> > -       if err != nil {\n> > -           // TODO this is brittle as all get out, refactor the client libraries to return a structured error.\n> > -           if strings.Contains(err.Error(), \"(404)\") {\n> >   argh argh argh :(\n> \n> Is it really more than a handful of lines of code to fix the client? @smarterclayton has a bunch of functions that would be good for this in pkg/api/errors.\n> \n> I guess I won't block the PR on this, but only if we have a pact that the next person to use a client's error has to fix it.\n> \n> —\n> Reply to this email directly or view it on GitHub.\n",
        "createdAt" : "2014-09-26T23:23:38Z",
        "updatedAt" : "2014-09-26T23:44:35Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "177be59c-01a9-4d5b-9293-93ca3e6ad8be",
        "parentId" : "13df87a7-23b5-40d4-a1d3-296bfbb28c18",
        "authorId" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "body" : "It's getting back to the client, but the client is swallowing it in Client.doRequest...\n",
        "createdAt" : "2014-09-26T23:36:38Z",
        "updatedAt" : "2014-09-26T23:44:35Z",
        "lastEditedBy" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "tags" : [
        ]
      },
      {
        "id" : "4dc2b716-f763-4b55-bfc8-36a9ce769409",
        "parentId" : "13df87a7-23b5-40d4-a1d3-296bfbb28c18",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Bah.  Open an issue for me, I'll need it for the auth stuff anyway.\n\n> On Sep 26, 2014, at 7:36 PM, Brendan Burns notifications@github.com wrote:\n> \n> In pkg/service/endpoints_controller.go:\n> \n> > @@ -72,11 +73,34 @@ func (e *EndpointController) SyncServiceEndpoints() error {\n> >             }\n> >             endpoints[ix] = net.JoinHostPort(pod.CurrentState.PodIP, strconv.Itoa(port))\n> >         }\n> > -       // TODO: this is totally broken, we need to compute this and store inside an AtomicUpdate loop.\n> > -       err = e.serviceRegistry.UpdateEndpoints(api.NewContext(), &api.Endpoints{\n> > -           JSONBase:  api.JSONBase{ID: service.ID},\n> > -       currentEndpoints, err := e.client.GetEndpoints(service.ID)\n> > -       if err != nil {\n> > -           // TODO this is brittle as all get out, refactor the client libraries to return a structured error.\n> > -           if strings.Contains(err.Error(), \"(404)\") {\n> >   It's getting back to the client, but the client is swallowing it in Client.doRequest...\n> \n> —\n> Reply to this email directly or view it on GitHub.\n",
        "createdAt" : "2014-09-26T23:42:53Z",
        "updatedAt" : "2014-09-26T23:44:35Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      }
    ],
    "commit" : "17c82606eb7868e40eddc9846ca436d883f2cf5f",
    "line" : null,
    "diffHunk" : "@@ -1,1 +77,81 @@\t\tif err != nil {\n\t\t\t// TODO this is brittle as all get out, refactor the client libraries to return a structured error.\n\t\t\tif strings.Contains(err.Error(), \"(404)\") {\n\t\t\t\tcurrentEndpoints = &api.Endpoints{\n\t\t\t\t\tJSONBase: api.JSONBase{"
  },
  {
    "id" : "a1787168-625c-4904-b028-73c86cfd5e61",
    "prId" : 1465,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2bbfd98c-fc36-45a5-a695-81b6e6738248",
        "parentId" : null,
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "(Nit; suggest in the future: `newEndpoints := *currentEndpoints`)\n",
        "createdAt" : "2014-09-26T23:57:33Z",
        "updatedAt" : "2014-09-26T23:57:33Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      }
    ],
    "commit" : "17c82606eb7868e40eddc9846ca436d883f2cf5f",
    "line" : 32,
    "diffHunk" : "@@ -1,1 +89,93 @@\t\t}\n\t\tnewEndpoints := &api.Endpoints{}\n\t\t*newEndpoints = *currentEndpoints\n\t\tnewEndpoints.Endpoints = endpoints\n"
  },
  {
    "id" : "f86f91c1-54d4-40eb-9d8a-5960f824959a",
    "prId" : 899,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d5108e62-a2cf-4975-ad17-5697e4753f4a",
        "parentId" : null,
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "I guess if I were doing this, I'd probably make this its own package. Maybe controller/endpoint? I guess I'd expect it to take in both service and endpoint registries and read from the one and write to the other?\n",
        "createdAt" : "2014-08-23T00:20:45Z",
        "updatedAt" : "2014-08-27T19:50:01Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "468b84c7-c4c2-4562-9f52-ca500ca28b4a",
        "parentId" : "d5108e62-a2cf-4975-ad17-5697e4753f4a",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Right.  Later pull?  :)\n",
        "createdAt" : "2014-08-23T18:28:00Z",
        "updatedAt" : "2014-08-27T19:50:01Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "76c90823-87a1-41a7-a003-ad9f4a3db00a",
        "parentId" : "d5108e62-a2cf-4975-ad17-5697e4753f4a",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "Sure.\n",
        "createdAt" : "2014-08-26T01:17:13Z",
        "updatedAt" : "2014-08-27T19:50:01Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      }
    ],
    "commit" : "9006eadcfee2e0493590fce7dc2968db2779bb43",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +15,19 @@*/\n\npackage service\n\nimport ("
  }
]
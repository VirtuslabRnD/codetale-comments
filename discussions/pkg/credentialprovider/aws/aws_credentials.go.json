[
  {
    "id" : "609c5a8a-1dd8-4534-9353-a8c08c1c2be4",
    "prId" : 93260,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/93260#pullrequestreview-533872440",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a8fcb557-ddad-4e2b-ac76-7d50b7dce501",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "this means that Provide() will be called for all images on all platforms, log v(3) output about the image not being a valid ECR repository URL for non-ECR images, and try to acquire ECR credentials for images matching the ECR regex.\r\n\r\nWould it make sense to also:\r\n\r\n1. drop the `klog.V(3).Info(err)` output if a non-ECR image is passed to provide... this isn't something we need to log\r\n\r\n2. move the current Enabled() check to a once.Do check we call before calling `getFromECR`. If that fails, make future calls to Provide() no-op",
        "createdAt" : "2020-11-18T19:47:13Z",
        "updatedAt" : "2021-03-19T23:39:01Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "3641f5c8-bbdb-4383-a8b6-651b0c2f076a",
        "parentId" : "a8fcb557-ddad-4e2b-ac76-7d50b7dce501",
        "authorId" : "ddc05ecb-1a86-4393-8e22-f1bb528c2d50",
        "body" : "I think both of those sound fine to me. ",
        "createdAt" : "2020-11-18T20:08:55Z",
        "updatedAt" : "2021-03-19T23:39:01Z",
        "lastEditedBy" : "ddc05ecb-1a86-4393-8e22-f1bb528c2d50",
        "tags" : [
        ]
      },
      {
        "id" : "9d8a16b3-ea3a-4b77-968b-55935f37a070",
        "parentId" : "a8fcb557-ddad-4e2b-ac76-7d50b7dce501",
        "authorId" : "ddc05ecb-1a86-4393-8e22-f1bb528c2d50",
        "body" : "@liggitt The only issue with this is we have to be careful with failures, i.e. we don't want a temporary ECR outage to cause permanent unhealthiness in kubelet.",
        "createdAt" : "2020-11-18T20:58:42Z",
        "updatedAt" : "2021-03-19T23:39:01Z",
        "lastEditedBy" : "ddc05ecb-1a86-4393-8e22-f1bb528c2d50",
        "tags" : [
        ]
      },
      {
        "id" : "bf92509a-5d35-4c5a-965a-a150562acce8",
        "parentId" : "a8fcb557-ddad-4e2b-ac76-7d50b7dce501",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "sure... by moving the existing check to a single run-once that happens only after we are asked to provide credentials for an ECR image, I *think* we do the following:\r\n* maintain current behavior on AWS\r\n* remove lag on non-AWS on a cluster that never tries to pull an ECR image\r\n* limits lag on a non-AWS cluster that tries to pull an ECR image to a single attempt",
        "createdAt" : "2020-11-18T21:01:30Z",
        "updatedAt" : "2021-03-19T23:39:01Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "d422a92e661209a23fcfec8039b132fce1eecea5",
    "line" : 115,
    "diffHunk" : "@@ -1,1 +141,145 @@\t}\n\tklog.V(5).Infof(\"found aws credentials, enabling legacy AWS credential provider\")\n\treturn true\n}\n"
  },
  {
    "id" : "d87d3f6d-6111-43e9-8dad-dfff5f6a4bee",
    "prId" : 93260,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/93260#pullrequestreview-611204141",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "35b6ac05-89f5-43b8-838c-78ea6206f6b1",
        "parentId" : null,
        "authorId" : "fa3dbd1f-8e18-448a-b3b2-da8acd0d8306",
        "body" : "Is this the location for `Get the UUID from DMI`?",
        "createdAt" : "2021-03-12T21:43:38Z",
        "updatedAt" : "2021-03-19T23:39:01Z",
        "lastEditedBy" : "fa3dbd1f-8e18-448a-b3b2-da8acd0d8306",
        "tags" : [
        ]
      },
      {
        "id" : "cbeefd3c-3351-40ed-9325-b915b034d164",
        "parentId" : "35b6ac05-89f5-43b8-838c-78ea6206f6b1",
        "authorId" : "ddc05ecb-1a86-4393-8e22-f1bb528c2d50",
        "body" : "Correct",
        "createdAt" : "2021-03-12T22:47:31Z",
        "updatedAt" : "2021-03-19T23:39:01Z",
        "lastEditedBy" : "ddc05ecb-1a86-4393-8e22-f1bb528c2d50",
        "tags" : [
        ]
      }
    ],
    "commit" : "d422a92e661209a23fcfec8039b132fce1eecea5",
    "line" : 69,
    "diffHunk" : "@@ -1,1 +91,95 @@func tryValidateEC2UUID() bool {\n\thypervisor_uuid := \"/sys/hypervisor/uuid\"\n\tproduct_uuid := \"/sys/devices/virtual/dmi/id/product_uuid\"\n\tasset_tag := \"/sys/devices/virtual/dmi/id/board_asset_tag\"\n"
  },
  {
    "id" : "1691cbec-3d87-4b4f-9168-fbeefd01fc22",
    "prId" : 93260,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/93260#pullrequestreview-611200054",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3e36afc4-bc3b-4f9e-b507-2c92020d0feb",
        "parentId" : null,
        "authorId" : "fa3dbd1f-8e18-448a-b3b2-da8acd0d8306",
        "body" : "Assuming this is the UUID from DMI, this won't work for little endian machines (if we care about that):\r\n\r\n> In the following example output, the UUID is represented in little-endian format.\r\n> 45E12AEC-DCD1-B213-94ED-01234ABCDEF\r\n",
        "createdAt" : "2021-03-12T21:45:37Z",
        "updatedAt" : "2021-03-19T23:39:01Z",
        "lastEditedBy" : "fa3dbd1f-8e18-448a-b3b2-da8acd0d8306",
        "tags" : [
        ]
      },
      {
        "id" : "63fbcbec-660d-41f2-9588-2fa8b6793adc",
        "parentId" : "3e36afc4-bc3b-4f9e-b507-2c92020d0feb",
        "authorId" : "ddc05ecb-1a86-4393-8e22-f1bb528c2d50",
        "body" : "Interesting.  It doesn't have to be perfect, we still try to initialize credentials after doing these checks. The advantage to being able to shortcut the credential checks is that in the case the metadata endpoint is down temporarily, we can still verify the machine is on EC2.  Since we're now using a `once.Do()` check, if the endpoint was down we would disable the provider and the operator would have to restart kubelet.  With these checks, the operator would only have to restart kubelet if these file checks don't work (e.g. little endian), and the credentials fail to initialize because of an outage.  ",
        "createdAt" : "2021-03-12T22:37:31Z",
        "updatedAt" : "2021-03-19T23:39:01Z",
        "lastEditedBy" : "ddc05ecb-1a86-4393-8e22-f1bb528c2d50",
        "tags" : [
        ]
      }
    ],
    "commit" : "d422a92e661209a23fcfec8039b132fce1eecea5",
    "line" : 86,
    "diffHunk" : "@@ -1,1 +108,112 @@\t\tif err != nil {\n\t\t\tklog.Errorf(\"error checking if this is an EC2 instance: %v\", err)\n\t\t} else if strings.HasPrefix(string(b), \"EC2\") || strings.HasPrefix(string(b), \"ec2\") {\n\t\t\tklog.V(5).Infof(\"found 'ec2' in uuid %v from %v, enabling legacy AWS credential provider\", string(b), product_uuid)\n\t\t\treturn true"
  },
  {
    "id" : "a5e61e7b-d4b8-4d4a-8985-ac76be9cf8c0",
    "prId" : 93260,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/93260#pullrequestreview-616848942",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9abc8ea0-952e-46f3-be63-4926fdaff40e",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "is this guaranteed or will this expand/change in the future?",
        "createdAt" : "2021-03-17T14:03:43Z",
        "updatedAt" : "2021-03-19T23:39:01Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "0f98b65a-4ca1-466b-93e3-be23a1858fc7",
        "parentId" : "9abc8ea0-952e-46f3-be63-4926fdaff40e",
        "authorId" : "ddc05ecb-1a86-4393-8e22-f1bb528c2d50",
        "body" : "Very unlikely to change anytime soon because it was increased a few years ago in order to become large enough to account for forseeable future growth.",
        "createdAt" : "2021-03-19T23:34:47Z",
        "updatedAt" : "2021-03-19T23:39:01Z",
        "lastEditedBy" : "ddc05ecb-1a86-4393-8e22-f1bb528c2d50",
        "tags" : [
        ]
      }
    ],
    "commit" : "d422a92e661209a23fcfec8039b132fce1eecea5",
    "line" : 98,
    "diffHunk" : "@@ -1,1 +120,124 @@\t\t\tklog.Errorf(\"error checking if this is an EC2 instance: %v\", err)\n\t\t} else if strings.HasPrefix(s, \"i-\") && len(s) == 19 {\n\t\t\t// Instance ID's are 19 characters plus newline\n\t\t\tklog.V(5).Infof(\"found instance ID in %v from %v, enabling legacy AWS credential provider\", string(b), asset_tag)\n\t\t\treturn true"
  },
  {
    "id" : "28bcf0b2-4000-4339-8ae8-ded82d1bba0e",
    "prId" : 93260,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/93260#pullrequestreview-614344770",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "94b9dab2-9881-4b21-8b6f-2f7f419e9ee2",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "verified the regex didn't change, this is just a formatting change to be in a var block",
        "createdAt" : "2021-03-17T14:07:06Z",
        "updatedAt" : "2021-03-19T23:39:01Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "d422a92e661209a23fcfec8039b132fce1eecea5",
    "line" : 16,
    "diffHunk" : "@@ -1,1 +42,46 @@\nvar (\n\tecrPattern = regexp.MustCompile(`^(\\d{12})\\.dkr\\.ecr(\\-fips)?\\.([a-zA-Z0-9][a-zA-Z0-9-_]*)\\.amazonaws\\.com(\\.cn)?$`)\n\tonce       sync.Once\n\tisEC2      bool"
  },
  {
    "id" : "baeb8581-df38-42ac-8c74-18d8b9cca1f1",
    "prId" : 75587,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/75587#pullrequestreview-218584664",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "34506a96-c9b4-469b-ac19-9b5e304143a1",
        "parentId" : null,
        "authorId" : "6dd71efb-88b1-4bb0-b30a-0df658362f14",
        "body" : "I think this function would read better like this:\r\n```go\r\nfunc (p *ecrProvider) getFromCache(parsed *parsedURL) (credentialprovider.DockerConfig, bool) {\r\n      cfg := credentialprovider.DockerConfig{}\r\n      \r\n       obj, exists, err := p.cache.GetByKey(parsed.registry)\r\n       if err != nil {\r\n              klog.Errorf(\"error getting ECR credentials from cache: %v\", err)\r\n              return cfg, false\r\n       }\r\n\r\n       if !exists {\r\n              return cfg, false\r\n       }\r\n\r\n      entry := obj.(*cacheEntry) // maybe do a type check?\r\n      cfg[entry.registry] = entry.credentials\r\n      return cfg, true\r\n```\r\nwydt?",
        "createdAt" : "2019-03-25T21:05:12Z",
        "updatedAt" : "2019-03-28T07:17:06Z",
        "lastEditedBy" : "6dd71efb-88b1-4bb0-b30a-0df658362f14",
        "tags" : [
        ]
      }
    ],
    "commit" : "0d63fa4543b022a9bcb47cde8a6d2f98f4ea429c",
    "line" : 136,
    "diffHunk" : "@@ -1,1 +112,116 @@\n// getFromCache attempts to get credentials from the cache\nfunc (p *ecrProvider) getFromCache(parsed *parsedURL) (credentialprovider.DockerConfig, bool) {\n\tcfg := credentialprovider.DockerConfig{}\n"
  },
  {
    "id" : "32087c18-86d1-42e2-9b28-e52b39c1225e",
    "prId" : 75587,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/75587#pullrequestreview-218651983",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fb41b9fa-4a4a-41d9-9402-77742f7a9726",
        "parentId" : null,
        "authorId" : "8fc8f958-3c0e-47dd-a0fb-b8cc483b4efb",
        "body" : "Does this need a mutex to protect against concurrent access?",
        "createdAt" : "2019-03-26T00:58:19Z",
        "updatedAt" : "2019-03-28T07:17:06Z",
        "lastEditedBy" : "8fc8f958-3c0e-47dd-a0fb-b8cc483b4efb",
        "tags" : [
        ]
      }
    ],
    "commit" : "0d63fa4543b022a9bcb47cde8a6d2f98f4ea429c",
    "line" : 338,
    "diffHunk" : "@@ -1,1 +244,248 @@\tdefer f.mutex.Unlock()\n\n\tif getter, ok := f.cache[region]; ok {\n\t\treturn getter, nil\n\t}"
  },
  {
    "id" : "e42d1fed-510b-43d7-98e5-bcfd1ee968a5",
    "prId" : 75587,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/75587#pullrequestreview-218651983",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4d2067d9-d459-4ac8-822e-94faa7f6cb2d",
        "parentId" : null,
        "authorId" : "8fc8f958-3c0e-47dd-a0fb-b8cc483b4efb",
        "body" : "Probably double check that there are 2 parts",
        "createdAt" : "2019-03-26T01:00:43Z",
        "updatedAt" : "2019-03-28T07:17:06Z",
        "lastEditedBy" : "8fc8f958-3c0e-47dd-a0fb-b8cc483b4efb",
        "tags" : [
        ]
      }
    ],
    "commit" : "0d63fa4543b022a9bcb47cde8a6d2f98f4ea429c",
    "line" : 414,
    "diffHunk" : "@@ -1,1 +282,286 @@\t\treturn nil, errors.New(\"error getting username and password from authorization token\")\n\t}\n\tcreds := credentialprovider.DockerConfigEntry{\n\t\tUsername: parts[0],\n\t\tPassword: parts[1],"
  },
  {
    "id" : "f2555033-9680-4e0d-aa51-dd59571c071e",
    "prId" : 75587,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/75587#pullrequestreview-218656213",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3db1c8d6-1787-45ce-99b8-2fbc4498fd23",
        "parentId" : null,
        "authorId" : "8fc8f958-3c0e-47dd-a0fb-b8cc483b4efb",
        "body" : "Ah - I guess an attacker would also have to guess the registry-id, so it's much less likely.",
        "createdAt" : "2019-03-26T01:21:36Z",
        "updatedAt" : "2019-03-28T07:17:06Z",
        "lastEditedBy" : "8fc8f958-3c0e-47dd-a0fb-b8cc483b4efb",
        "tags" : [
        ]
      }
    ],
    "commit" : "0d63fa4543b022a9bcb47cde8a6d2f98f4ea429c",
    "line" : 187,
    "diffHunk" : "@@ -1,1 +137,141 @@\t\treturn cfg, err\n\t}\n\tparams := &ecr.GetAuthorizationTokenInput{RegistryIds: []*string{aws.String(parsed.registryID)}}\n\toutput, err := getter.GetAuthorizationToken(params)\n\tif err != nil {"
  },
  {
    "id" : "963aeeb7-8d7f-4f49-9950-4147921fd96b",
    "prId" : 75587,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/75587#pullrequestreview-218701933",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e3161c6d-3aec-42b1-8226-863812a9e8b7",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "this logs errors in all cases that don't return true... does that mean the kubelet log will be spammed with \"while validating AWS credentials\" errors on every image pull in non-aws environments?",
        "createdAt" : "2019-03-26T05:35:39Z",
        "updatedAt" : "2019-03-28T07:17:06Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "bb0f29c3-42a4-4bf4-a54c-e815f4b02efa",
        "parentId" : "e3161c6d-3aec-42b1-8226-863812a9e8b7",
        "authorId" : "63623da0-ebaf-4220-ade8-ce4ae99efd05",
        "body" : "Good point. Those should be a log of some level.",
        "createdAt" : "2019-03-26T05:38:47Z",
        "updatedAt" : "2019-03-28T07:17:06Z",
        "lastEditedBy" : "63623da0-ebaf-4220-ade8-ce4ae99efd05",
        "tags" : [
        ]
      },
      {
        "id" : "e8b82cc7-cf76-4b2f-945e-14a3d490d41f",
        "parentId" : "e3161c6d-3aec-42b1-8226-863812a9e8b7",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "if this runs in a non-aws environment, I wouldn't really expect any logging in that case (do the other credential providers log when returning false because they are not in their effective environment?)",
        "createdAt" : "2019-03-26T05:40:56Z",
        "updatedAt" : "2019-03-28T07:17:06Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "8579be36-2ba3-4038-97f3-dd990c78f435",
        "parentId" : "e3161c6d-3aec-42b1-8226-863812a9e8b7",
        "authorId" : "63623da0-ebaf-4220-ade8-ce4ae99efd05",
        "body" : "Yes, GCP and Azure do. And it's not so much not being in their effective environment as opposed to not being able to enable to provider. The extent of AWS environment is having AWS credentials.\r\n\r\nI think it is important to be able to see logging at some sort of level to know the provider isn't enabled.\r\n\r\nGCP\r\n```go\r\n// Returns true if it finds a local GCE VM.\r\n// Looks at a product file that is an undocumented API.\r\nfunc onGCEVM() bool {\r\n\tdata, err := ioutil.ReadFile(gceProductNameFile)\r\n\tif err != nil {\r\n\t\tklog.V(2).Infof(\"Error while reading product_name: %v\", err)\r\n\t\treturn false\r\n\t}\r\n\tname := strings.TrimSpace(string(data))\r\n\treturn name == \"Google\" || name == \"Google Compute Engine\"\r\n}\r\n\r\n// Enabled implements DockerConfigProvider for all of the Google implementations.\r\nfunc (g *metadataProvider) Enabled() bool {\r\n\treturn onGCEVM()\r\n}\r\n```\r\nAzure\r\n```go\r\nfunc (a *acrProvider) Enabled() bool {\r\n\tif a.file == nil || len(*a.file) == 0 {\r\n\t\tklog.V(5).Infof(\"Azure config unspecified, disabling\")\r\n\t\treturn false\r\n\t}\r\n\r\n\tf, err := os.Open(*a.file)\r\n\tif err != nil {\r\n\t\tklog.Errorf(\"Failed to load config from file: %s\", *a.file)\r\n\t\treturn false\r\n\t}\r\n\tdefer f.Close()\r\n\r\n\terr = a.loadConfig(f)\r\n\tif err != nil {\r\n\t\tklog.Errorf(\"Failed to load config from file: %s\", *a.file)\r\n\t\treturn false\r\n\t}\r\n\r\n\ta.servicePrincipalToken, err = auth.GetServicePrincipalToken(a.config, a.environment)\r\n\tif err != nil {\r\n\t\tklog.Errorf(\"Failed to create service principal token: %v\", err)\r\n\t\treturn false\r\n\t}\r\n\r\n\ta.registryClient = newAzRegistriesClient(a.config.SubscriptionID, a.environment.ResourceManagerEndpoint, a.servicePrincipalToken)\r\n\treturn true\r\n}\r\n```",
        "createdAt" : "2019-03-26T05:54:36Z",
        "updatedAt" : "2019-03-28T07:17:06Z",
        "lastEditedBy" : "63623da0-ebaf-4220-ade8-ce4ae99efd05",
        "tags" : [
        ]
      },
      {
        "id" : "748282ab-9964-4115-b9f1-bd9253e5baab",
        "parentId" : "e3161c6d-3aec-42b1-8226-863812a9e8b7",
        "authorId" : "432f5354-abdd-4e2d-b39a-3b4a44782702",
        "body" : "> The extent of AWS environment is having AWS credentials.\r\n\r\n:+1: You are not required to run in EC2 in order to use ECR, you just need to have valid AWS credentials.",
        "createdAt" : "2019-03-26T06:03:54Z",
        "updatedAt" : "2019-03-28T07:17:06Z",
        "lastEditedBy" : "432f5354-abdd-4e2d-b39a-3b4a44782702",
        "tags" : [
        ]
      },
      {
        "id" : "54b437aa-4f2b-40e4-a79d-28cb4b63d4de",
        "parentId" : "e3161c6d-3aec-42b1-8226-863812a9e8b7",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "> Yes, GCP and Azure do. And it's not so much not being in their effective environment as opposed to not being able to enable to provider. The extent of AWS environment is having AWS credentials.\r\n\r\nok",
        "createdAt" : "2019-03-26T06:06:03Z",
        "updatedAt" : "2019-03-28T07:17:06Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "0d63fa4543b022a9bcb47cde8a6d2f98f4ea429c",
    "line" : 76,
    "diffHunk" : "@@ -1,1 +66,70 @@// Enabled implements DockerConfigProvider.Enabled. Enabled is true if AWS\n// credentials are found.\nfunc (p *ecrProvider) Enabled() bool {\n\tsess, err := session.NewSessionWithOptions(session.Options{\n\t\tSharedConfigState: session.SharedConfigEnable,"
  },
  {
    "id" : "9fc1b40f-eb19-43ef-8cb1-215d431cd1f1",
    "prId" : 75587,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/75587#pullrequestreview-219058241",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0cf90a21-0819-4275-9241-c467d71744bd",
        "parentId" : null,
        "authorId" : "6dd71efb-88b1-4bb0-b30a-0df658362f14",
        "body" : "nit: we should get rid of the returned error here if we aren't doing a type check against `obj`. ",
        "createdAt" : "2019-03-26T16:41:28Z",
        "updatedAt" : "2019-03-28T07:17:06Z",
        "lastEditedBy" : "6dd71efb-88b1-4bb0-b30a-0df658362f14",
        "tags" : [
        ]
      },
      {
        "id" : "6215dfbd-05bd-47bc-9d7b-ba58551995d0",
        "parentId" : "0cf90a21-0819-4275-9241-c467d71744bd",
        "authorId" : "4db268bc-8c08-4dfd-b61f-0c35b28567bd",
        "body" : "That's the [interface](https://github.com/kubernetes/client-go/blob/master/tools/cache/store.go#L51) required by the cache store.",
        "createdAt" : "2019-03-26T17:08:57Z",
        "updatedAt" : "2019-03-28T07:17:06Z",
        "lastEditedBy" : "4db268bc-8c08-4dfd-b61f-0c35b28567bd",
        "tags" : [
        ]
      },
      {
        "id" : "487d9041-4b62-498a-a704-7d9bea6e0b40",
        "parentId" : "0cf90a21-0819-4275-9241-c467d71744bd",
        "authorId" : "6dd71efb-88b1-4bb0-b30a-0df658362f14",
        "body" : "ah, good to know, thanks",
        "createdAt" : "2019-03-26T17:42:13Z",
        "updatedAt" : "2019-03-28T07:17:06Z",
        "lastEditedBy" : "6dd71efb-88b1-4bb0-b30a-0df658362f14",
        "tags" : [
        ]
      }
    ],
    "commit" : "0d63fa4543b022a9bcb47cde8a6d2f98f4ea429c",
    "line" : 434,
    "diffHunk" : "@@ -1,1 +301,305 @@\n// stringKeyFunc returns the cache key as a string\nfunc stringKeyFunc(obj interface{}) (string, error) {\n\tkey := obj.(*cacheEntry).registry\n\treturn key, nil"
  },
  {
    "id" : "985dc984-8e24-4ac5-9c0f-305bfec9a97e",
    "prId" : 75587,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/75587#pullrequestreview-220813435",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "336e0fc2-6c2e-46f9-8477-f12807e928c1",
        "parentId" : null,
        "authorId" : "42b1e004-4fa7-4e43-84cf-5378839b49ad",
        "body" : "Should there be a check on the number of parts in splitURL before accessing ?",
        "createdAt" : "2019-03-30T08:51:08Z",
        "updatedAt" : "2019-03-30T08:56:02Z",
        "lastEditedBy" : "42b1e004-4fa7-4e43-84cf-5378839b49ad",
        "tags" : [
        ]
      }
    ],
    "commit" : "0d63fa4543b022a9bcb47cde8a6d2f98f4ea429c",
    "line" : 256,
    "diffHunk" : "@@ -1,1 +181,185 @@\t\treturn nil, fmt.Errorf(\"%s is not a valid ECR repository URL\", parsed.Hostname())\n\t}\n\treturn &parsedURL{\n\t\tregistryID: splitURL[1],\n\t\tregion:     splitURL[3],"
  },
  {
    "id" : "e1c38437-474a-48f5-9f9f-fc893c6bb222",
    "prId" : 75587,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/75587#pullrequestreview-220813435",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0999c275-bfcb-48cb-9100-b396a3268f36",
        "parentId" : null,
        "authorId" : "42b1e004-4fa7-4e43-84cf-5378839b49ad",
        "body" : "It seems we can introduce RWLock and use read lock here, write lock for line 253.",
        "createdAt" : "2019-03-30T08:54:37Z",
        "updatedAt" : "2019-03-30T08:56:02Z",
        "lastEditedBy" : "42b1e004-4fa7-4e43-84cf-5378839b49ad",
        "tags" : [
        ]
      }
    ],
    "commit" : "0d63fa4543b022a9bcb47cde8a6d2f98f4ea429c",
    "line" : 338,
    "diffHunk" : "@@ -1,1 +244,248 @@\tdefer f.mutex.Unlock()\n\n\tif getter, ok := f.cache[region]; ok {\n\t\treturn getter, nil\n\t}"
  },
  {
    "id" : "97ead052-c9eb-4150-b28e-002d38ff7966",
    "prId" : 38880,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/38880#pullrequestreview-14515348",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4e2f4ef9-ddf6-4c96-80aa-4128aa3bbea1",
        "parentId" : null,
        "authorId" : "75116688-a62a-47be-90a5-3d780ac59886",
        "body" : "Do we have this documented anywhere?  If so do we need to update the docs?",
        "createdAt" : "2016-12-28T01:04:08Z",
        "updatedAt" : "2017-01-18T14:18:04Z",
        "lastEditedBy" : "75116688-a62a-47be-90a5-3d780ac59886",
        "tags" : [
        ]
      }
    ],
    "commit" : "04b787b9464cddc59236fc0d3484ea80241b1dc9",
    "line" : 33,
    "diffHunk" : "@@ -1,1 +81,85 @@var _ credentialprovider.DockerConfigProvider = &ecrProvider{}\n\n// RegisterCredentialsProvider registers a credential provider for the specified region.\n// It creates a lazy provider for each AWS region, in order to support\n// cross-region ECR access. They have to be lazy because it's unlikely, but not"
  },
  {
    "id" : "b328ddf5-47c4-496f-a178-594fdacdc2a3",
    "prId" : 24369,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "712a78ad-566b-4ac0-82c6-73e9aa40d0bb",
        "parentId" : null,
        "authorId" : "c06b2845-79d9-4151-8aa6-dc7c6eb52bbf",
        "body" : "What do you think instead of having the code here inside the if, move the code to create the actualProvider to another function, and do something like:\n\n```\nif p.actualProvider == nil {\n  p.actualProvider = <func to create the actualProvider here>\n}\nentry := p.actualProvider.Provide()[p.regionURL]\nreturn &entry\n```\n\nI'm not sure how the k8s code styling is (will check next week :)), but this is a small detail but it seems slightly more readable for me. And it's not like TONs of parameters will be needed in the func to create the actual provider.\n\nWhat do you think?\n",
        "createdAt" : "2016-04-16T22:24:59Z",
        "updatedAt" : "2016-05-10T16:04:40Z",
        "lastEditedBy" : "c06b2845-79d9-4151-8aa6-dc7c6eb52bbf",
        "tags" : [
        ]
      },
      {
        "id" : "b093aad7-6955-4396-976e-bd9c502b7ae7",
        "parentId" : "712a78ad-566b-4ac0-82c6-73e9aa40d0bb",
        "authorId" : "11725e10-43c9-4a8c-96d0-5118a3e67a6a",
        "body" : "Yes, I was going to try a helper function next. And perhaps, instead of creating N lazy providers, just one, which does a string match against the image getting loaded, figuring the region, then maintaining a map of ecrProviders.\n",
        "createdAt" : "2016-04-17T02:27:28Z",
        "updatedAt" : "2016-05-10T16:04:40Z",
        "lastEditedBy" : "11725e10-43c9-4a8c-96d0-5118a3e67a6a",
        "tags" : [
        ]
      },
      {
        "id" : "cdda7ef4-3ade-4885-b533-65586ad0da59",
        "parentId" : "712a78ad-566b-4ac0-82c6-73e9aa40d0bb",
        "authorId" : "c06b2845-79d9-4151-8aa6-dc7c6eb52bbf",
        "body" : "I'm not sure about that. The code this way is pretty simple and the N lazy providers shouldn't make noticiable difference in mem or cpu, and as no real provider is created for the unused, not even messages with the cloud provider are used.\n\nSo, I'd do it only if it is equally or more readable than now, and equally or less error prone. If the code gets more messy, I don't think it's worth the effort.\n\nBut your call :)\n",
        "createdAt" : "2016-04-17T18:22:34Z",
        "updatedAt" : "2016-05-10T16:04:40Z",
        "lastEditedBy" : "c06b2845-79d9-4151-8aa6-dc7c6eb52bbf",
        "tags" : [
        ]
      },
      {
        "id" : "ddf6e4e6-cbb3-439b-aea9-eb99f090d1bc",
        "parentId" : "712a78ad-566b-4ac0-82c6-73e9aa40d0bb",
        "authorId" : "11725e10-43c9-4a8c-96d0-5118a3e67a6a",
        "body" : "Helper/constructor added. I'm still tempted to have one lazy provider (which would definitely require more tests).\n",
        "createdAt" : "2016-04-17T21:22:33Z",
        "updatedAt" : "2016-05-10T16:04:40Z",
        "lastEditedBy" : "11725e10-43c9-4a8c-96d0-5118a3e67a6a",
        "tags" : [
        ]
      }
    ],
    "commit" : "684517f74ffc4cdd9c33a196525f5cd1dc10aa25",
    "line" : 114,
    "diffHunk" : "@@ -1,1 +126,130 @@// provider only when we actually need it the first time.\nfunc (p *lazyEcrProvider) LazyProvide() *credentialprovider.DockerConfigEntry {\n\tif p.actualProvider == nil {\n\t\tglog.V(2).Infof(\"Creating ecrProvider for %s\", p.region)\n\t\tp.actualProvider = &credentialprovider.CachingDockerConfigProvider{"
  },
  {
    "id" : "caedad84-b20b-4ec5-ae27-918158b4f819",
    "prId" : 24369,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bf7519be-82c2-4f53-8fd5-642407bf4a9d",
        "parentId" : null,
        "authorId" : "8fc8f958-3c0e-47dd-a0fb-b8cc483b4efb",
        "body" : "Tip: I personally like to do this:\n\n```\nvar _ DockerConfigProvider = &lazyEcrProvider{}\n```\n\nApparently there's some debate as to whether or not to do it, but I like that it makes the intent very clear and that it is then checked immediately by the golang compiler.\n",
        "createdAt" : "2016-04-17T16:21:30Z",
        "updatedAt" : "2016-05-10T16:04:40Z",
        "lastEditedBy" : "8fc8f958-3c0e-47dd-a0fb-b8cc483b4efb",
        "tags" : [
        ]
      },
      {
        "id" : "2534e9dc-5719-43e2-a410-390a3d9e5ec7",
        "parentId" : "bf7519be-82c2-4f53-8fd5-642407bf4a9d",
        "authorId" : "11725e10-43c9-4a8c-96d0-5118a3e67a6a",
        "body" : "Added both.\n",
        "createdAt" : "2016-04-17T21:26:11Z",
        "updatedAt" : "2016-05-10T16:04:40Z",
        "lastEditedBy" : "11725e10-43c9-4a8c-96d0-5118a3e67a6a",
        "tags" : [
        ]
      }
    ],
    "commit" : "684517f74ffc4cdd9c33a196525f5cd1dc10aa25",
    "line" : 61,
    "diffHunk" : "@@ -1,1 +78,82 @@}\n\n// lazyEcrProvider is a DockerConfigProvider that creates on demand an\n// ecrProvider for a given region and then proxies requests to it.\ntype lazyEcrProvider struct {"
  },
  {
    "id" : "cce1c19b-b90a-402f-9636-cf68602f7a5c",
    "prId" : 24369,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bac6ac9f-b815-4516-a02b-702dfbd79730",
        "parentId" : null,
        "authorId" : "8fc8f958-3c0e-47dd-a0fb-b8cc483b4efb",
        "body" : "actualProvider.Enabled?\n",
        "createdAt" : "2016-04-17T16:36:41Z",
        "updatedAt" : "2016-05-10T16:04:40Z",
        "lastEditedBy" : "8fc8f958-3c0e-47dd-a0fb-b8cc483b4efb",
        "tags" : [
        ]
      },
      {
        "id" : "4217bc08-d809-4d66-a5f2-ddca072e7923",
        "parentId" : "bac6ac9f-b815-4516-a02b-702dfbd79730",
        "authorId" : "c06b2845-79d9-4151-8aa6-dc7c6eb52bbf",
        "body" : "The actual provider (p.actualProvider) may not exist, IIUC. So, the lazy provider reports as \"always enabled\" to the credentialprovider and when it is used, the lazy provider creates an actual provider. _IIUC_\n",
        "createdAt" : "2016-04-17T18:28:26Z",
        "updatedAt" : "2016-05-10T16:04:40Z",
        "lastEditedBy" : "c06b2845-79d9-4151-8aa6-dc7c6eb52bbf",
        "tags" : [
        ]
      },
      {
        "id" : "6fb509c6-2dc0-4ff5-877f-e8c7c5262800",
        "parentId" : "bac6ac9f-b815-4516-a02b-702dfbd79730",
        "authorId" : "11725e10-43c9-4a8c-96d0-5118a3e67a6a",
        "body" : "@rata is correct. actualProvider is only created the first time an image is pulled. Enabled() gets called much earlier than that.\n",
        "createdAt" : "2016-04-17T18:50:26Z",
        "updatedAt" : "2016-05-10T16:04:40Z",
        "lastEditedBy" : "11725e10-43c9-4a8c-96d0-5118a3e67a6a",
        "tags" : [
        ]
      },
      {
        "id" : "fb6f0b0a-1c8a-4b04-91db-116baca68d32",
        "parentId" : "bac6ac9f-b815-4516-a02b-702dfbd79730",
        "authorId" : "11725e10-43c9-4a8c-96d0-5118a3e67a6a",
        "body" : "I added a comment explaining why we always return true.\n",
        "createdAt" : "2016-04-17T21:27:35Z",
        "updatedAt" : "2016-05-10T16:04:40Z",
        "lastEditedBy" : "11725e10-43c9-4a8c-96d0-5118a3e67a6a",
        "tags" : [
        ]
      }
    ],
    "commit" : "684517f74ffc4cdd9c33a196525f5cd1dc10aa25",
    "line" : null,
    "diffHunk" : "@@ -1,1 +119,123 @@// later at image pulling time (if ever), always return true.\nfunc (p *lazyEcrProvider) Enabled() bool {\n\treturn true\n}\n"
  },
  {
    "id" : "52fa06e6-cb88-4dfa-908d-9bb36a551324",
    "prId" : 24369,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "538ea3d1-29a8-4048-a6d1-471956e4beaf",
        "parentId" : null,
        "authorId" : "8fc8f958-3c0e-47dd-a0fb-b8cc483b4efb",
        "body" : "I think we probably should guard against the region being nil, but there's only a tiny number of non-regional calls AFAIK, and I think they are all S3 calls, so maybe it doesn't matter.\n",
        "createdAt" : "2016-05-12T13:48:54Z",
        "updatedAt" : "2016-05-12T13:49:03Z",
        "lastEditedBy" : "8fc8f958-3c0e-47dd-a0fb-b8cc483b4efb",
        "tags" : [
        ]
      }
    ],
    "commit" : "684517f74ffc4cdd9c33a196525f5cd1dc10aa25",
    "line" : 53,
    "diffHunk" : "@@ -1,1 +61,65 @@\t}\n\n\tglog.V(3).Infof(\"AWS request: %s:%s in %s\", service, name, *region)\n}\n"
  },
  {
    "id" : "353ff633-2349-4061-8b91-35d2885220bb",
    "prId" : 24369,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c79f7bf9-a783-4f14-91d4-15f74926a12c",
        "parentId" : null,
        "authorId" : "8fc8f958-3c0e-47dd-a0fb-b8cc483b4efb",
        "body" : "I think we should probably guard against an error meaning the region is not present in the DockerConfig map.\n",
        "createdAt" : "2016-05-12T13:52:08Z",
        "updatedAt" : "2016-05-12T13:52:08Z",
        "lastEditedBy" : "8fc8f958-3c0e-47dd-a0fb-b8cc483b4efb",
        "tags" : [
        ]
      }
    ],
    "commit" : "684517f74ffc4cdd9c33a196525f5cd1dc10aa25",
    "line" : 126,
    "diffHunk" : "@@ -1,1 +137,141 @@\t\t}\n\t}\n\tentry := p.actualProvider.Provide()[p.regionURL]\n\treturn &entry\n}"
  },
  {
    "id" : "894bc02d-6bd2-4be2-90a0-e8ffcd7a7dcf",
    "prId" : 24369,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c0fe9121-24b1-4064-b323-a7ed8a3ebf65",
        "parentId" : null,
        "authorId" : "8fc8f958-3c0e-47dd-a0fb-b8cc483b4efb",
        "body" : "Should we remove the Provide() method from the DockerConfigProvider interface?  I find it confusing that there are now two methods on the interface - it really isn't clear (to me) what is called when.  But I guess that isn't this PR.\n",
        "createdAt" : "2016-05-12T13:56:40Z",
        "updatedAt" : "2016-05-12T13:56:40Z",
        "lastEditedBy" : "8fc8f958-3c0e-47dd-a0fb-b8cc483b4efb",
        "tags" : [
        ]
      }
    ],
    "commit" : "684517f74ffc4cdd9c33a196525f5cd1dc10aa25",
    "line" : 131,
    "diffHunk" : "@@ -1,1 +142,146 @@\n// Provide implements DockerConfigProvider.Provide, creating dummy credentials.\n// Client code will call Provider.LazyProvide() at image pulling time.\nfunc (p *lazyEcrProvider) Provide() credentialprovider.DockerConfig {\n\tentry := credentialprovider.DockerConfigEntry{"
  },
  {
    "id" : "992f0f75-9743-47bb-b4a7-c69c53cfe588",
    "prId" : 20129,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "73c37a62-e38f-4b45-b621-8ed7053e95d8",
        "parentId" : null,
        "authorId" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "body" : "Add a comment above saying something like \"// Not using the package init() function: this module should be initialized only if using the AWS cloud provider.  This avoids timeout waiting for non-existent provider.\"\n",
        "createdAt" : "2016-01-26T00:34:29Z",
        "updatedAt" : "2016-01-26T03:18:51Z",
        "lastEditedBy" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "tags" : [
        ]
      }
    ],
    "commit" : "76e29ed455674361ca99e5c896d4499e1ba787ec",
    "line" : null,
    "diffHunk" : "@@ -1,1 +69,73 @@// if using the AWS cloud provider. This way, we avoid timeouts waiting for a\n// non-existent provider.\nfunc Init() {\n\tcredentialprovider.RegisterCredentialProvider(\"aws-ecr-key\",\n\t\t&credentialprovider.CachingDockerConfigProvider{"
  }
]
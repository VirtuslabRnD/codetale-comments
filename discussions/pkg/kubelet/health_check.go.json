[
  {
    "id" : "06a82ea1-1215-4737-9877-4b1d1718c2ae",
    "prId" : 365,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "946426e8-e854-4e1b-a87f-0905cc326107",
        "parentId" : null,
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "What about other non-error status codes?\n\nAdditionally, it would be convenient to be able to use the same handler as the load balancer health (readiness) checks. However, those checks return error codes (e.g., 503) during temporary unavailability. \n\nAlso, errors due to misconfiguration are unlikely to be resolved by killing and restarting a container.\n\nSince liveness probes are mainly a safeguard against deadlock, livelock, excessive queue lengths, etc., typically any response could be interpreted as \"live\". \n",
        "createdAt" : "2014-07-07T22:06:41Z",
        "updatedAt" : "2014-07-09T19:01:52Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "300b0357-2ea5-4ae8-b16e-d180bc528aaa",
        "parentId" : "946426e8-e854-4e1b-a87f-0905cc326107",
        "authorId" : "ec51f754-9844-4e72-8c9e-8d1105d99228",
        "body" : "On success, `res.Close()` should be called, otherwise, there will be a memory leak. You may want to put it in a defer to make it more idiomatic.\n\nSee the [http package document](http://golang.org/pkg/net/http/#Client.Do):\n\n> Callers should close resp.Body when done reading from it. \n",
        "createdAt" : "2014-07-07T22:53:28Z",
        "updatedAt" : "2014-07-09T19:01:52Z",
        "lastEditedBy" : "ec51f754-9844-4e72-8c9e-8d1105d99228",
        "tags" : [
        ]
      },
      {
        "id" : "deafa1a9-193e-4645-b1c8-d73af84966d1",
        "parentId" : "946426e8-e854-4e1b-a87f-0905cc326107",
        "authorId" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "body" : "@monnand Done.\n@bgrant0607 What is your suggestion?  Should we only fail if we get a network error?  And return true healthy on any HTTP response?  That's not the traditional /healthz contract...\n\nThat\n",
        "createdAt" : "2014-07-08T05:36:14Z",
        "updatedAt" : "2014-07-09T19:01:52Z",
        "lastEditedBy" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "tags" : [
        ]
      },
      {
        "id" : "9110d6ec-8340-4faa-8c68-fb7e8a1c62b8",
        "parentId" : "946426e8-e854-4e1b-a87f-0905cc326107",
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "Yes, I meant that we should return healthy == true on any HTTP response. However, I now take that back. Nevermind. I'm not sure it would work as intended given failure modes of popular external webservers (e.g., apache, nginx, php, nodejs), and it definitely wouldn't work if a proxy or load balancer or somesuch were in between Kubelet and the application.\n\nMaybe we can make the failure condition configurable in the future.\n\nIt does mean that your example of using index.html (or even /healthz) as the path to probe is unlikely to work in many cases, such as webservers that return 503 when offline during data reloading, draining, and/or maintenance, since returning 503 is intended behavior in such cases.\n\nOnce we have a means to report it to the user, we should record the HTTP status code that triggered the failure. HTTP errors (and non-200 success status codes, such as 204) are likely to be the result of misconfiguration more than anything else.\n",
        "createdAt" : "2014-07-08T07:22:54Z",
        "updatedAt" : "2014-07-09T19:01:52Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      }
    ],
    "commit" : "41c6680943c620b90c598dc6d12a817cfb625820",
    "line" : null,
    "diffHunk" : "@@ -1,1 +96,100 @@\t\treturn false, nil\n\t}\n\treturn res.StatusCode == http.StatusOK, nil\n}"
  },
  {
    "id" : "53af4a3a-af75-4fd4-a4ba-f8d56df70d45",
    "prId" : 365,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "450062bf-0b55-4160-a568-6b307a8e27c9",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "why int64?  ports are small to start with.\n",
        "createdAt" : "2014-07-09T23:12:46Z",
        "updatedAt" : "2014-07-09T23:12:46Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "7a6957af-9086-43e9-946f-21a6b5dedd3a",
        "parentId" : "450062bf-0b55-4160-a568-6b307a8e27c9",
        "authorId" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "body" : "on x86_64, I'm pretty certain that int is 64 bits in golang anyway.\n",
        "createdAt" : "2014-07-09T23:29:09Z",
        "updatedAt" : "2014-07-09T23:29:09Z",
        "lastEditedBy" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "tags" : [
        ]
      },
      {
        "id" : "015c5115-5933-4e62-b5bd-6345c22233a1",
        "parentId" : "450062bf-0b55-4160-a568-6b307a8e27c9",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "my point being that as soon as I see int64 I immediately think \"the fact that it is 64 bits is important\" as opposed to plain old int.\n",
        "createdAt" : "2014-07-09T23:31:46Z",
        "updatedAt" : "2014-07-09T23:31:46Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "41c6680943c620b90c598dc6d12a817cfb625820",
    "line" : 67,
    "diffHunk" : "@@ -1,1 +65,69 @@\t\tif port.Name == portName {\n\t\t\t// TODO This means you can only health check exposed ports\n\t\t\treturn int64(port.HostPort)\n\t\t}\n\t}"
  }
]
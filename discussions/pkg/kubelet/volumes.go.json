[
  {
    "id" : "98e2b59c-d45c-42b7-a112-4c4fcbdd40e4",
    "prId" : 26351,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "16020c8e-7f79-486c-b4a1-64cd87b6066d",
        "parentId" : null,
        "authorId" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "body" : "weird phrasing here (not yours, but you're touching it): `can't use`\n",
        "createdAt" : "2016-06-01T21:19:50Z",
        "updatedAt" : "2016-06-02T23:47:38Z",
        "lastEditedBy" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "tags" : [
        ]
      },
      {
        "id" : "f24ffe33-de34-48d5-b7f7-33ee7666ee84",
        "parentId" : "16020c8e-7f79-486c-b4a1-64cd87b6066d",
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "This code's getting nuked, not worth rewording in this PR.\n",
        "createdAt" : "2016-06-02T00:30:01Z",
        "updatedAt" : "2016-06-02T23:47:38Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      },
      {
        "id" : "91c0082b-d708-4fbd-bcf0-16b0e0ad9291",
        "parentId" : "16020c8e-7f79-486c-b4a1-64cd87b6066d",
        "authorId" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "body" : "Fine with me.\n",
        "createdAt" : "2016-06-03T05:05:47Z",
        "updatedAt" : "2016-06-03T05:05:47Z",
        "lastEditedBy" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "tags" : [
        ]
      }
    ],
    "commit" : "9dbe943491d69762068c0ac021e1964d9c14873e",
    "line" : 103,
    "diffHunk" : "@@ -1,1 +390,394 @@\tplugin, err := kl.volumePluginMgr.FindAttachablePluginBySpec(spec)\n\tif err != nil {\n\t\treturn nil, nil, fmt.Errorf(\"can't use volume plugins for %s: %v\", spec.Name(), err)\n\t}\n\tif plugin == nil {"
  },
  {
    "id" : "5ca8fcaf-7ab9-4a3f-b583-31b415930d76",
    "prId" : 23122,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "72e776f7-9b9d-46ac-af7b-a03d2e176c07",
        "parentId" : null,
        "authorId" : null,
        "body" : "Same here unless I am missing something.\n`return plugin.NewUnmounter(spec.Name(), podUID)`\n",
        "createdAt" : "2016-04-05T18:53:36Z",
        "updatedAt" : "2016-04-07T13:55:14Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "8b260ee6-a44c-4e6f-b4eb-b54e97dc3b9d",
        "parentId" : "72e776f7-9b9d-46ac-af7b-a03d2e176c07",
        "authorId" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "body" : "You're not missing anything, good point.\n",
        "createdAt" : "2016-04-05T19:20:00Z",
        "updatedAt" : "2016-04-07T13:55:14Z",
        "lastEditedBy" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "tags" : [
        ]
      }
    ],
    "commit" : "36970deecac302b99c13033a5ced71a7218dab7f",
    "line" : null,
    "diffHunk" : "@@ -1,1 +86,90 @@\n\treturn plugin.NewUnmounter(spec.Name(), podUID)\n}\n\nfunc (vh *volumeHost) GetCloudProvider() cloudprovider.Interface {"
  },
  {
    "id" : "8cd8c92d-12f9-4be5-9e87-2e7dd81fa593",
    "prId" : 23122,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e4a1db23-b65e-4803-93cf-db1fc82c93c0",
        "parentId" : null,
        "authorId" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "body" : "This needs to move to the definition of `FindAttachablePluginBySpec`\n",
        "createdAt" : "2016-04-05T20:18:31Z",
        "updatedAt" : "2016-04-07T13:55:14Z",
        "lastEditedBy" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "tags" : [
        ]
      },
      {
        "id" : "ceae2d7f-9daa-4438-b282-af0a39df88a4",
        "parentId" : "e4a1db23-b65e-4803-93cf-db1fc82c93c0",
        "authorId" : "e15ef128-90ac-4a14-8795-b5be15e790ce",
        "body" : "@pmorie - I removed from here as the def of FindAttachablePluginBySpec already has a good godoc\n",
        "createdAt" : "2016-04-05T21:32:07Z",
        "updatedAt" : "2016-04-07T13:55:14Z",
        "lastEditedBy" : "e15ef128-90ac-4a14-8795-b5be15e790ce",
        "tags" : [
        ]
      }
    ],
    "commit" : "36970deecac302b99c13033a5ced71a7218dab7f",
    "line" : null,
    "diffHunk" : "@@ -1,1 +274,278 @@//  - nil if there is no appropriate attacher for this volume\nfunc (kl *Kubelet) newVolumeAttacherFromPlugins(spec *volume.Spec, pod *api.Pod, opts volume.VolumeOptions) (volume.Attacher, error) {\n\tplugin, err := kl.volumePluginMgr.FindAttachablePluginBySpec(spec)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"can't use volume plugins for %s: %v\", spec.Name(), err)"
  },
  {
    "id" : "7ab0bc2a-0c0a-441f-aee0-0b372bedfa8f",
    "prId" : 23122,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bc441267-3c81-4c0d-bf30-81c09c517582",
        "parentId" : null,
        "authorId" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "body" : "This is kind of the exception to the whole sentence rule -- this is fine as is re: the specification of return values\n",
        "createdAt" : "2016-04-07T13:12:44Z",
        "updatedAt" : "2016-04-07T13:55:14Z",
        "lastEditedBy" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "tags" : [
        ]
      }
    ],
    "commit" : "36970deecac302b99c13033a5ced71a7218dab7f",
    "line" : 107,
    "diffHunk" : "@@ -1,1 +272,276 @@//  - an error if no plugin was found for the volume\n//    or the attacher failed to instantiate\n//  - nil if there is no appropriate attacher for this volume\nfunc (kl *Kubelet) newVolumeAttacherFromPlugins(spec *volume.Spec, pod *api.Pod, opts volume.VolumeOptions) (volume.Attacher, error) {\n\tplugin, err := kl.volumePluginMgr.FindAttachablePluginBySpec(spec)"
  },
  {
    "id" : "0aade66c-b5b6-4ca2-b9cd-4978fe981f79",
    "prId" : 21709,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "aec34b23-6fee-4941-81cb-7c115aedb466",
        "parentId" : null,
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "Again not your code, but this `IsLikelyNotMountPoint` stuff always confuses me. Over here we decide to attach and mount if the path is not a mount point? When would the opposite case happen?\n",
        "createdAt" : "2016-05-13T22:05:50Z",
        "updatedAt" : "2016-05-22T12:28:46Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      },
      {
        "id" : "dfdba789-30cc-4c67-acc7-f9634666ee3f",
        "parentId" : "aec34b23-6fee-4941-81cb-7c115aedb466",
        "authorId" : null,
        "body" : "This function keeps getting called every iteration of the  syncloop (and more) so the SetUp functions used the existence of a global which which is mounting _something_ to indication that their work is done and short circuit calling to the cloud provider in every iteration of the loop. During the first iteration the global path either does not exist or is not a mount point.\nWithout this check pods stay in containerCreating for over a minute and a half \n",
        "createdAt" : "2016-05-13T22:35:51Z",
        "updatedAt" : "2016-05-22T12:28:46Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "6c1b0a7c-ebd5-4a98-b3fd-f57ffba464de",
        "parentId" : "aec34b23-6fee-4941-81cb-7c115aedb466",
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "Ok, that makes sense for GCE. What about volumes that don't do global mount, like NFS? Also, why is `mounter.SetUp(fsGroup)` called out side of this. Is it because we expect plugins that do Attach to all do a global mount?\n",
        "createdAt" : "2016-05-13T22:48:14Z",
        "updatedAt" : "2016-05-22T12:28:46Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      },
      {
        "id" : "27887f82-3434-4541-9deb-7405d70ea8a5",
        "parentId" : "aec34b23-6fee-4941-81cb-7c115aedb466",
        "authorId" : null,
        "body" : "presumably all volumes which implement Attacher (ie `attacher != nil`) do do the global mount. I think that assumption is fair since we expect them to implement `GetDeviceMountPath`\nSo NFS wont be handled inside this `if attach != nil` statement.\n`mounter.SetUp()` is expected to implement its own short circuiting and it is implemented by both Attachable and non-Attachable plugins\n",
        "createdAt" : "2016-05-14T11:52:53Z",
        "updatedAt" : "2016-05-22T12:28:46Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "0668a9a9-75c1-4841-a312-0f558e1ab428",
        "parentId" : "aec34b23-6fee-4941-81cb-7c115aedb466",
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "Ack. I still don't like having Attacher and Mounter be two different \"types\" of plugins. I'd love to see, all plugins that are attachers also implement the mounter interface but we can do that refactor at another point.\n",
        "createdAt" : "2016-05-17T07:28:53Z",
        "updatedAt" : "2016-05-22T12:28:46Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      }
    ],
    "commit" : "4858d0ab6f612248f356c4cdcd0353b5667fc359",
    "line" : null,
    "diffHunk" : "@@ -1,1 +169,173 @@\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tif notMountPoint {\n\t\t\t\terr = attacher.Attach(volSpec, kl.hostname)\n\t\t\t\tif err != nil {"
  },
  {
    "id" : "8544b8e3-6b0d-41e7-a514-9fee132ac61e",
    "prId" : 19503,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "30018f53-60c9-4941-b0b3-22ce01f9c016",
        "parentId" : null,
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "I'm not sure if \"tuple\" is the right noun for this object. For clarity, how about calling this struct just `cleaner`, and rename `volume.Cleaner` to `volume.Unmounter`?\n",
        "createdAt" : "2016-01-13T00:54:23Z",
        "updatedAt" : "2016-02-07T22:38:46Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      },
      {
        "id" : "e70c3932-db03-4246-9b2c-bb5fcf6fdcbe",
        "parentId" : "30018f53-60c9-4941-b0b3-22ce01f9c016",
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "Let's rename Builder to Mounter and Cleaner to Unmounter to everywhere.\n",
        "createdAt" : "2016-01-13T01:05:31Z",
        "updatedAt" : "2016-02-07T22:38:46Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      },
      {
        "id" : "a6a0aab4-8205-4777-b2f5-66f2da44608a",
        "parentId" : "30018f53-60c9-4941-b0b3-22ce01f9c016",
        "authorId" : "727fc82d-d969-41a4-a614-7fefce94f9a6",
        "body" : "`cleanerTuple` here can be renamed to `cleaner` after the big rename in #19599.\n\nThere's `volumeTuple` in this file, so there is some precedent for this naming convention.\n",
        "createdAt" : "2016-01-13T15:39:08Z",
        "updatedAt" : "2016-02-07T22:38:46Z",
        "lastEditedBy" : "727fc82d-d969-41a4-a614-7fefce94f9a6",
        "tags" : [
        ]
      }
    ],
    "commit" : "a242a3d5fe618444edc44b6194df2c48a9799251",
    "line" : 54,
    "diffHunk" : "@@ -1,1 +209,213 @@// some volumes require detachment but not all.  Cleaner cannot be nil but Detacher is optional.\ntype cleanerTuple struct {\n\tCleaner  volume.Cleaner\n\tDetacher *volume.Detacher\n}"
  },
  {
    "id" : "9cbd4108-338f-4e3f-a535-000751da9216",
    "prId" : 19503,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4cea9f90-ead1-4a36-a165-39f3b8c61a8e",
        "parentId" : null,
        "authorId" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "body" : "Minor nit: why not move this block to after `internal` is declared, so builder declaration is near the call to setup.\n",
        "createdAt" : "2016-01-20T17:53:13Z",
        "updatedAt" : "2016-02-07T22:38:46Z",
        "lastEditedBy" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "tags" : [
        ]
      },
      {
        "id" : "d5e7ebc2-dff6-46a2-8620-c12dc03b04d2",
        "parentId" : "4cea9f90-ead1-4a36-a165-39f3b8c61a8e",
        "authorId" : "727fc82d-d969-41a4-a614-7fefce94f9a6",
        "body" : "Is there any benefit to knowing you have a builder (for mounting) before an attempt to attach is made?  Error handling would prevent an attachment for a non-existent builder.\n",
        "createdAt" : "2016-01-20T18:08:59Z",
        "updatedAt" : "2016-02-07T22:38:46Z",
        "lastEditedBy" : "727fc82d-d969-41a4-a614-7fefce94f9a6",
        "tags" : [
        ]
      }
    ],
    "commit" : "a242a3d5fe618444edc44b6194df2c48a9799251",
    "line" : 28,
    "diffHunk" : "@@ -1,1 +136,140 @@\t\t\treturn nil, errUnsupportedVolumeType\n\t\t}\n\n\t\t// some volumes require attachment before builder's setup.\n\t\t// The plugin can be nil, but non-nil errors are legitimate errors."
  },
  {
    "id" : "e06e4422-5d8a-41d7-a09f-3d1e3b5caa1f",
    "prId" : 5122,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0251f9f0-eb6d-42cf-a81a-e64b07f49fc4",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "I think this is going to fail in the masterless case (e.g. ContainerVM).\n\n@lavalamp what are we going to do about this?  Is this an inappropriate use of ObjectRef in your view?  What should we be passing around inside Kubelet to carry namespace, name, and UID?\n",
        "createdAt" : "2015-03-06T07:59:46Z",
        "updatedAt" : "2015-03-10T18:40:27Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "5c154869-a979-4f65-8c7d-316291c4ffdc",
        "parentId" : "0251f9f0-eb6d-42cf-a81a-e64b07f49fc4",
        "authorId" : "727fc82d-d969-41a4-a614-7fefce94f9a6",
        "body" : "This fails.   BoundPod has no refLink, so the call to GetReference returns an error.\n\nThe former commit (adding namespace as an arg) worked and passed Travis.\n",
        "createdAt" : "2015-03-06T13:14:55Z",
        "updatedAt" : "2015-03-10T18:40:27Z",
        "lastEditedBy" : "727fc82d-d969-41a4-a614-7fefce94f9a6",
        "tags" : [
        ]
      },
      {
        "id" : "625a0190-60d9-4e8b-aa0e-123a7a8cacf2",
        "parentId" : "0251f9f0-eb6d-42cf-a81a-e64b07f49fc4",
        "authorId" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "body" : "I still think we should be passing an ObjectReference, personally\n",
        "createdAt" : "2015-03-06T16:42:00Z",
        "updatedAt" : "2015-03-10T18:40:27Z",
        "lastEditedBy" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "tags" : [
        ]
      },
      {
        "id" : "9b027677-fcb6-4e72-9eff-85802a7fe001",
        "parentId" : "0251f9f0-eb6d-42cf-a81a-e64b07f49fc4",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "I'm going to talk to @lavalamp and @bgrant0607 when they get in.\n",
        "createdAt" : "2015-03-06T16:52:14Z",
        "updatedAt" : "2015-03-10T18:40:27Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "848b8d98-0bb2-4a2d-9a0a-af212fdbe37b",
        "parentId" : "0251f9f0-eb6d-42cf-a81a-e64b07f49fc4",
        "authorId" : "727fc82d-d969-41a4-a614-7fefce94f9a6",
        "body" : "It's a nice little wrapper around UID and Namespace, for sure.\n\nI'd like some guidance on how to make this work.\n",
        "createdAt" : "2015-03-06T16:53:50Z",
        "updatedAt" : "2015-03-10T18:40:27Z",
        "lastEditedBy" : "727fc82d-d969-41a4-a614-7fefce94f9a6",
        "tags" : [
        ]
      },
      {
        "id" : "c8de87bd-d561-4962-82d5-d9e3dd6fa037",
        "parentId" : "0251f9f0-eb6d-42cf-a81a-e64b07f49fc4",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "IMO it should be possible to take references to all pods kubelet knows about, including ones from config file, http, etc., so those methods should test that this is possible. This is because we'll need to checkpoint & recover from crashes, even if the config file changes while kubelet restarts. But that should be an extremely rare edge case, so I'm not sure if it's worth changing it now.\n",
        "createdAt" : "2015-03-06T19:04:42Z",
        "updatedAt" : "2015-03-10T18:40:27Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "9584ffa7-1ea4-4a6c-9977-c0a337651d32",
        "parentId" : "0251f9f0-eb6d-42cf-a81a-e64b07f49fc4",
        "authorId" : "727fc82d-d969-41a4-a614-7fefce94f9a6",
        "body" : "@lavalamp can you provide more clarity?  I'm afraid I don't understand.\n\nThe code as written above fails because BoundPod does not have a refLink.   If you're saying I can use an ObjectRef safely here, how would I do that?\n",
        "createdAt" : "2015-03-06T19:48:35Z",
        "updatedAt" : "2015-03-10T18:40:27Z",
        "lastEditedBy" : "727fc82d-d969-41a4-a614-7fefce94f9a6",
        "tags" : [
        ]
      },
      {
        "id" : "d35d5071-a6f8-478e-8264-a3b3d007acef",
        "parentId" : "0251f9f0-eb6d-42cf-a81a-e64b07f49fc4",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "Sorry for not being clear-- I meant \"should\" as in \"it is desirable but would require some work before it is possible\". :)\n\napi.BoundPod has a spot for a SelfLink. We should fill that in when we read a pod from config file.\n\nOr--and this would make @erictune your friend for life--we could make GetReference not fail when the SelfLink is blank.\n",
        "createdAt" : "2015-03-06T20:15:33Z",
        "updatedAt" : "2015-03-10T18:40:27Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "ccc5930e-4d73-4e2e-a77b-03c7f2f23da0",
        "parentId" : "0251f9f0-eb6d-42cf-a81a-e64b07f49fc4",
        "authorId" : "727fc82d-d969-41a4-a614-7fefce94f9a6",
        "body" : "@thockin already said he will buy me a yard of beer in the future.  If I make @erictune my friend for life, I might get another yard when I make one of these meet-ups.\n\nShould all blank SelfLinks not fail or would I make it specific to type (in this case, BoundPods)?  That seems like a trivial change in ref.go, unless I'm missing something. \n",
        "createdAt" : "2015-03-06T20:40:28Z",
        "updatedAt" : "2015-03-10T18:40:27Z",
        "lastEditedBy" : "727fc82d-d969-41a4-a614-7fefce94f9a6",
        "tags" : [
        ]
      },
      {
        "id" : "089ce301-04ff-45e0-8d47-e6e2277f4cab",
        "parentId" : "0251f9f0-eb6d-42cf-a81a-e64b07f49fc4",
        "authorId" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "body" : "+1 to make GetReference not fail on a blank selflink.  @derekwaynecarr any opinion on that?\n",
        "createdAt" : "2015-03-06T20:49:40Z",
        "updatedAt" : "2015-03-10T18:40:27Z",
        "lastEditedBy" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "tags" : [
        ]
      },
      {
        "id" : "3e0fb170-67c6-4670-bdfc-e4ec71865d77",
        "parentId" : "0251f9f0-eb6d-42cf-a81a-e64b07f49fc4",
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "See also #1490.\n",
        "createdAt" : "2015-03-07T03:58:58Z",
        "updatedAt" : "2015-03-10T18:40:27Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "10bd97f8-4414-4479-b582-70e5b4661e47",
        "parentId" : "0251f9f0-eb6d-42cf-a81a-e64b07f49fc4",
        "authorId" : "727fc82d-d969-41a4-a614-7fefce94f9a6",
        "body" : "I'm wondering now if allowing an empty SelfLink for a BoundPod is correct or if, perhaps, I found a bug.\n\nIt seems like the BoundPod _should_ have a SelfLink:\n\nhttps://github.com/GoogleCloudPlatform/kubernetes/blob/master/pkg/registry/pod/bound_pod_factory.go#L36\n",
        "createdAt" : "2015-03-09T15:06:37Z",
        "updatedAt" : "2015-03-10T18:40:27Z",
        "lastEditedBy" : "727fc82d-d969-41a4-a614-7fefce94f9a6",
        "tags" : [
        ]
      },
      {
        "id" : "623f74cd-127d-45cd-b1b5-9b9466eda453",
        "parentId" : "0251f9f0-eb6d-42cf-a81a-e64b07f49fc4",
        "authorId" : "727fc82d-d969-41a4-a614-7fefce94f9a6",
        "body" : "@lavalamp My question to you is whether or not you expect SelfLink to be empty based on the above factory code?\n\nHere is the output from hack/test-integration.sh\n\n```\nE0309 12:03:20.939413   26261 kubelet.go:1067] Unable to mount volumes for pod \"container-vm-guestbook.url-85ad08d5.http\": selfLink was empty, can't make reference; skipping pod\nE0309 12:03:20.939423   26261 pod_workers.go:90] Error syncing pod bb78274544e7fd9d0bc51f571eb161a7, skipping: selfLink was empty, can't make reference\nE0309 12:03:20.939442   26261 event.go:199] Could not construct reference to: '&api.BoundPod{TypeMeta:api.TypeMeta{Kind:\"\", APIVersion:\"\"}, ObjectMeta:api.ObjectMeta{Name:\"container-vm-guestbook\", GenerateName:\"\", Namespace:\"url-85ad08d5\", SelfLink:\"\", UID:\"bb78274544e7fd9d0bc51f571eb161a7\", ResourceVersion:\"\", CreationTimestamp:util.Time{Time:time.Time{sec:0, nsec:0, loc:(*time.Location)(nil)}}, Labels:map[string]string(nil), Annotations:map[string]string{\"kubernetes.io/config.source\":\"http\"}}, Spec:api.PodSpec{Volumes:[]api.Volume{api.Volume{Name:\"redis-data\", VolumeSource:api.VolumeSource{HostPath:(*api.HostPathVolumeSource)(nil), EmptyDir:(*api.EmptyDirVolumeSource)(0xed8cf0), GCEPersistentDisk:(*api.GCEPersistentDiskVolumeSource)(nil), GitRepo:(*api.GitRepoVolumeSource)(nil), Secret:(*api.SecretVolumeSource)(nil)}}}, Containers:[]api.Container{api.Container{Name:\"redis\", Image:\"dockerfile/redis\", Command:[]string(nil), WorkingDir:\"\", Ports:[]api.ContainerPort(nil), Env:[]api.EnvVar(nil), Resources:api.ResourceRequirements{Limits:api.ResourceList(nil)}, VolumeMounts:[]api.VolumeMount{api.VolumeMount{Name:\"redis-data\", ReadOnly:false, MountPath:\"/data\"}}, LivenessProbe:(*api.Probe)(nil), ReadinessProbe:(*api.Probe)(nil), Lifecycle:(*api.Lifecycle)(nil), TerminationMessagePath:\"/dev/termination-log\", Privileged:false, ImagePullPolicy:\"IfNotPresent\", Capabilities:api.Capabilities{Add:[]api.CapabilityType(nil), Drop:[]api.CapabilityType(nil)}}, api.Container{Name:\"guestbook\", Image:\"google/guestbook-python-redis\", Command:[]string(nil), WorkingDir:\"\", Ports:[]api.ContainerPort{api.ContainerPort{Name:\"www\", HostPort:80, ContainerPort:80, Protocol:\"TCP\", HostIP:\"\"}}, Env:[]api.EnvVar(nil), Resources:api.ResourceRequirements{Limits:api.ResourceList(nil)}, VolumeMounts:[]api.VolumeMount(nil), LivenessProbe:(*api.Probe)(nil), ReadinessProbe:(*api.Probe)(nil), Lifecycle:(*api.Lifecycle)(nil), TerminationMessagePath:\"/dev/termination-log\", Privileged:false, ImagePullPolicy:\"IfNotPresent\", Capabilities:api.Capabilities{Add:[]api.CapabilityType(nil), Drop:[]api.CapabilityType(nil)}}}, RestartPolicy:api.RestartPolicy{Always:(*api.RestartPolicyAlways)(0xed8cf0), OnFailure:(*api.RestartPolicyOnFailure)(nil), Never:(*api.RestartPolicyNever)(nil)}, DNSPolicy:\"ClusterFirst\", NodeSelector:map[string]string(nil), Host:\"\"}}' due to: 'selfLink was empty, can't make reference'. Will not report event: 'failedSync' 'Error syncing pod, skipping: selfLink was empty, can't make reference'\n```\n",
        "createdAt" : "2015-03-09T16:08:22Z",
        "updatedAt" : "2015-03-10T18:40:27Z",
        "lastEditedBy" : "727fc82d-d969-41a4-a614-7fefce94f9a6",
        "tags" : [
        ]
      },
      {
        "id" : "9a6a24b1-0dd4-4e76-9dcb-051e7eb2166a",
        "parentId" : "0251f9f0-eb6d-42cf-a81a-e64b07f49fc4",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "@markturansky the pods with empty self links are not going through that factory code-- they're being read from disk from the static config file. :)\n",
        "createdAt" : "2015-03-09T17:31:57Z",
        "updatedAt" : "2015-03-10T18:40:27Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "5c8fd7a2-3016-4dc3-b8fd-8a68454f5b99",
        "parentId" : "0251f9f0-eb6d-42cf-a81a-e64b07f49fc4",
        "authorId" : "727fc82d-d969-41a4-a614-7fefce94f9a6",
        "body" : "I think I understand.  They wouldn't have a SelfLink because they are not persisted in etcd.  Only objects from etcd would have a SelfLink.\n",
        "createdAt" : "2015-03-09T18:30:45Z",
        "updatedAt" : "2015-03-10T18:40:27Z",
        "lastEditedBy" : "727fc82d-d969-41a4-a614-7fefce94f9a6",
        "tags" : [
        ]
      },
      {
        "id" : "8a1f3bb4-6479-4d79-8a12-358619621286",
        "parentId" : "0251f9f0-eb6d-42cf-a81a-e64b07f49fc4",
        "authorId" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "body" : "@lavalamp @markturansky Where does this leave us on object references to things without a selfLink?\n",
        "createdAt" : "2015-03-09T21:04:41Z",
        "updatedAt" : "2015-03-10T18:40:27Z",
        "lastEditedBy" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "tags" : [
        ]
      },
      {
        "id" : "29a91c15-0307-45e0-8774-713aeac38b8d",
        "parentId" : "0251f9f0-eb6d-42cf-a81a-e64b07f49fc4",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "@markturansky It's not an etcd thing. It's that the object didn't come from apiserver, which fills in the self links.\n\n@pmorie IMO I think for resiliency we should make GetReference fail gracefully (return a mostly-complete ObjectReference) if it can't parse the self link.\n",
        "createdAt" : "2015-03-09T21:19:06Z",
        "updatedAt" : "2015-03-10T18:40:27Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "1005910d-1580-4fcf-8689-bb7612c54f05",
        "parentId" : "0251f9f0-eb6d-42cf-a81a-e64b07f49fc4",
        "authorId" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "body" : "@lavalamp that seems sensible to me\n\nOn Mon, Mar 9, 2015 at 5:19 PM, Daniel Smith notifications@github.com\nwrote:\n\n> In pkg/kubelet/volumes.go\n> https://github.com/GoogleCloudPlatform/kubernetes/pull/5122#discussion_r26077446\n> :\n> \n> > @@ -77,12 +77,18 @@ func (kl *Kubelet) mountExternalVolumes(pod *api.BoundPod) (volumeMap, error) {\n> >     for i := range pod.Spec.Volumes {\n> >         volSpec := &pod.Spec.Volumes[i]\n> > -       podRef, err := api.GetReference(pod)\n> \n> @markturansky https://github.com/markturansky It's not an etcd thing.\n> It's that the object didn't come from apiserver, which fills in the self\n> links.\n> \n> @pmorie https://github.com/pmorie IMO I think for resiliency we should\n> make GetReference fail gracefully (return a mostly-complete\n> ObjectReference) if it can't parse the self link.\n> \n> —\n> Reply to this email directly or view it on GitHub\n> https://github.com/GoogleCloudPlatform/kubernetes/pull/5122/files#r26077446\n> .\n",
        "createdAt" : "2015-03-09T21:32:14Z",
        "updatedAt" : "2015-03-10T18:40:27Z",
        "lastEditedBy" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "tags" : [
        ]
      },
      {
        "id" : "38500c02-dfdd-4aba-973c-9a7e1ae11440",
        "parentId" : "0251f9f0-eb6d-42cf-a81a-e64b07f49fc4",
        "authorId" : "727fc82d-d969-41a4-a614-7fefce94f9a6",
        "body" : "@lavalamp thanks for the clarification.  I can make those changes and have them available for you to review.\n",
        "createdAt" : "2015-03-09T21:39:40Z",
        "updatedAt" : "2015-03-10T18:40:27Z",
        "lastEditedBy" : "727fc82d-d969-41a4-a614-7fefce94f9a6",
        "tags" : [
        ]
      }
    ],
    "commit" : "a486ab078f2d7679107dc0dc95d5266b011b0822",
    "line" : 22,
    "diffHunk" : "@@ -1,1 +78,82 @@\t\tvolSpec := &pod.Spec.Volumes[i]\n\n\t\tpodRef, err := api.GetReference(pod)\n\t\tif err != nil {\n\t\t\tglog.Errorf(\"Error getting object reference for pod: %v\", pod, err)"
  }
]
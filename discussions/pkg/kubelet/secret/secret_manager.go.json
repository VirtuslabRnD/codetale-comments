[
  {
    "id" : "e2ee0897-f9db-471f-9429-3562f2e73af5",
    "prId" : 40796,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/40796#pullrequestreview-19959061",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "03b7801e-6f94-45e0-8b6f-b9bf99a805f0",
        "parentId" : null,
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "@yujuhong - do you want to review the whole PR, or just the kubelet part and I should find someone else for the controller part?",
        "createdAt" : "2017-02-01T11:27:14Z",
        "updatedAt" : "2017-02-09T13:50:36Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      },
      {
        "id" : "491c0ba7-ee80-431a-918d-46a1c2fdccff",
        "parentId" : "03b7801e-6f94-45e0-8b6f-b9bf99a805f0",
        "authorId" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "body" : "I'll review everything, but it'd be better if you find someone who's more well-versed in controllers to take a look at that part.",
        "createdAt" : "2017-02-01T19:12:23Z",
        "updatedAt" : "2017-02-09T13:50:36Z",
        "lastEditedBy" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "tags" : [
        ]
      },
      {
        "id" : "e197ba82-c7e7-4791-aea5-8c7ee552af77",
        "parentId" : "03b7801e-6f94-45e0-8b6f-b9bf99a805f0",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "Ack",
        "createdAt" : "2017-02-03T07:53:10Z",
        "updatedAt" : "2017-02-09T13:50:36Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "dcf8a85fdf8cfb9445074d6bd2ead5663cbc6056",
    "line" : 23,
    "diffHunk" : "@@ -1,1 +73,77 @@}\n\ntype GetObjectTTLFunc func() (time.Duration, bool)\n\ntype objectKey struct {"
  },
  {
    "id" : "7f0a15df-3f0f-456b-809a-eb72808f28ab",
    "prId" : 40796,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/40796#pullrequestreview-20034938",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b49ba9cb-81df-42f4-b759-0b0bc6bd7482",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "make sure intValue is positive",
        "createdAt" : "2017-02-03T15:27:00Z",
        "updatedAt" : "2017-02-09T13:50:36Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "dcf8a85fdf8cfb9445074d6bd2ead5663cbc6056",
    "line" : 62,
    "diffHunk" : "@@ -1,1 +168,172 @@\t\tif node != nil && node.Annotations != nil {\n\t\t\tif value, ok := node.Annotations[v1.ObjectTTLAnnotationKey]; ok {\n\t\t\t\tif intValue, err := strconv.Atoi(value); err == nil {\n\t\t\t\t\treturn time.Duration(intValue) * time.Second, true\n\t\t\t\t}"
  },
  {
    "id" : "045dce48-2b2d-424e-942a-fdc7e2630be9",
    "prId" : 40208,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/40208#pullrequestreview-17939667",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f52024a5-07ec-464d-934a-0a9ea602b0a8",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "also need to iterate over container EnvFrom",
        "createdAt" : "2017-01-20T15:10:26Z",
        "updatedAt" : "2017-01-23T15:10:12Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "2d415865-306b-4682-90f7-aa3933cd1688",
        "parentId" : "f52024a5-07ec-464d-934a-0a9ea602b0a8",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "What is using EnvFrom ? From what I found in the code, volume secret plugin is not using them...",
        "createdAt" : "2017-01-23T14:38:36Z",
        "updatedAt" : "2017-01-23T15:10:12Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      },
      {
        "id" : "52a2143c-4ddf-4f16-9baf-4217fbcdd7bf",
        "parentId" : "f52024a5-07ec-464d-934a-0a9ea602b0a8",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "https://github.com/kubernetes/kubernetes/pull/40195 is open to use it",
        "createdAt" : "2017-01-23T14:57:00Z",
        "updatedAt" : "2017-01-23T15:10:12Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "e0784f2e00e1aa7f5a89309b1220982354fe9597",
    "line" : 11,
    "diffHunk" : "@@ -1,1 +223,227 @@\t\t\t\tresult.Insert(envVar.ValueFrom.SecretKeyRef.Name)\n\t\t\t}\n\t\t}\n\t}\n\tfor i := range pod.Spec.Volumes {"
  },
  {
    "id" : "8219f145-eb8b-4717-aaa3-a46c6b2d5d93",
    "prId" : 36984,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/36984#pullrequestreview-15157289",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3ea0ef9d-2a1a-42cd-9b81-aaeb1ed67f68",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "is it safe to assume this pod is immutable, since we're storing the pointer in `registeredPods`?",
        "createdAt" : "2017-01-03T15:33:06Z",
        "updatedAt" : "2017-01-19T19:12:15Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "db250933-ab6d-4702-975a-9a458a66a9c3",
        "parentId" : "3ea0ef9d-2a1a-42cd-9b81-aaeb1ed67f68",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "I think it should be safe. Noone should modify pods. ",
        "createdAt" : "2017-01-04T08:15:16Z",
        "updatedAt" : "2017-01-19T19:12:15Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      },
      {
        "id" : "1407f006-4729-48cc-8062-8ffb1f7c6ed8",
        "parentId" : "3ea0ef9d-2a1a-42cd-9b81-aaeb1ed67f68",
        "authorId" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "body" : "Yes, typically no components modify the pods in kubelet. ",
        "createdAt" : "2017-01-04T18:00:58Z",
        "updatedAt" : "2017-01-19T19:12:15Z",
        "lastEditedBy" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "tags" : [
        ]
      }
    ],
    "commit" : "3c0d2bb1f0259b6b826b2a12d4e76b2db1e619ed",
    "line" : 232,
    "diffHunk" : "@@ -1,1 +230,234 @@}\n\nfunc (c *cachingSecretManager) RegisterPod(pod *v1.Pod) {\n\tnames := getSecretNames(pod)\n\tc.lock.Lock()"
  },
  {
    "id" : "7af136a9-0222-489d-909d-b616cd25af3e",
    "prId" : 36984,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/36984#pullrequestreview-15896094",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1e8d41a7-2797-485e-995a-d1e2f7c5c285",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "are RegisterPod/UnregisterPod called from multiple goroutines? if so, the secretStore Add/Delete calls need to be inside the lock, right? (otherwise an unregister followed by a register could race and end up deleting after adding)",
        "createdAt" : "2017-01-03T15:35:34Z",
        "updatedAt" : "2017-01-19T19:12:15Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "7039246f-fa8d-49a1-9649-501e449ab28a",
        "parentId" : "1e8d41a7-2797-485e-995a-d1e2f7c5c285",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "From what I know, there won't be multiple calls in parallel to that. But @yujuhong probably can confirm.",
        "createdAt" : "2017-01-04T08:19:01Z",
        "updatedAt" : "2017-01-19T19:12:15Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      },
      {
        "id" : "aa6d6ea3-84b7-4776-b3b6-20b0b2137774",
        "parentId" : "1e8d41a7-2797-485e-995a-d1e2f7c5c285",
        "authorId" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "body" : "There is only one goroutine in kubelet managing pods in the podManager, which is the caller of these functions. So, no, there won't be multiple goroutines. \r\n\r\nHowever, it'd be nice to add comments in the interface to make it clear that these functions are not thread-safe, or simply use a lock.",
        "createdAt" : "2017-01-04T17:56:40Z",
        "updatedAt" : "2017-01-19T19:12:15Z",
        "lastEditedBy" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "tags" : [
        ]
      },
      {
        "id" : "050248d1-0fe9-41dd-ad9d-0384cf6b60b6",
        "parentId" : "1e8d41a7-2797-485e-995a-d1e2f7c5c285",
        "authorId" : "0adf587c-aaa2-4e47-be0f-a26d4fde14ac",
        "body" : "Since this object has a lock, I would assume it is thread safe. If it's not thread safe, the lock should be removed...",
        "createdAt" : "2017-01-05T23:42:59Z",
        "updatedAt" : "2017-01-19T19:12:15Z",
        "lastEditedBy" : "0adf587c-aaa2-4e47-be0f-a26d4fde14ac",
        "tags" : [
        ]
      },
      {
        "id" : "9ca80c0b-73d6-4d88-8ac4-abcf5c4fa8cb",
        "parentId" : "1e8d41a7-2797-485e-995a-d1e2f7c5c285",
        "authorId" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "body" : "I agree with @timstclair. Also, the lock usage pattern (what's thread-safe and what's not) is not very clear in the latest commit. It's important to make sure some thread (e.g., SyncLoop) doesn't get blocked on network operations.",
        "createdAt" : "2017-01-09T22:38:18Z",
        "updatedAt" : "2017-01-19T19:12:15Z",
        "lastEditedBy" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "tags" : [
        ]
      },
      {
        "id" : "8c6c035f-08b1-4f4f-b6e7-66e975190257",
        "parentId" : "1e8d41a7-2797-485e-995a-d1e2f7c5c285",
        "authorId" : "3c437914-616b-4cfb-88a0-28dc812ff2b2",
        "body" : "Yeah - I somehow missed this comment.",
        "createdAt" : "2017-01-10T11:27:37Z",
        "updatedAt" : "2017-01-19T19:12:15Z",
        "lastEditedBy" : "3c437914-616b-4cfb-88a0-28dc812ff2b2",
        "tags" : [
        ]
      }
    ],
    "commit" : "3c0d2bb1f0259b6b826b2a12d4e76b2db1e619ed",
    "line" : null,
    "diffHunk" : "@@ -1,1 +241,245 @@\tprev = c.registeredPods[key]\n\tc.registeredPods[key] = pod\n\tif prev != nil {\n\t\tfor name := range getSecretNames(prev) {\n\t\t\tc.secretStore.Delete(prev.Namespace, name)"
  },
  {
    "id" : "0a535f48-6786-4375-bb7c-451d120d5191",
    "prId" : 36984,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/36984#pullrequestreview-15218775",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "87723b5e-f6a6-4963-839a-f1cc06164996",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "also unsure about races when transitioning into or out of error states.\r\n\r\nexample 1:\r\n1. pod is created, referencing a secret which doesn't exist yet\r\n2. secret fetch fails with 404 which gets cached\r\n3. Refresh() starts running\r\n4. Refresh() fetches secret, also gets 404\r\n5. secret is created\r\n6. resync occurs, pod is re-added, secret fetch succeeds and gets cached\r\n7. Refresh() completes, overwrites successful fetch with stale 404 error\r\n\r\nexample 2:\r\n1. pod is created referencing a valid secret\r\n2. secret fetch succeeds, gets cached\r\n3. Refresh() starts running\r\n4. Refresh() fetches secret, also gets success\r\n5. secret is deleted\r\n6. resync occurs, pod is re-added, secret fetch fails and gets cached\r\n7. Refresh() completes, overwrites failed fetch with stale secret",
        "createdAt" : "2017-01-03T16:01:22Z",
        "updatedAt" : "2017-01-19T19:12:15Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "3ff3e558-8b50-4d0c-a38f-e138c00bfdfd",
        "parentId" : "87723b5e-f6a6-4963-839a-f1cc06164996",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "We can introduce much more complicated locking scheme to avoid it, though I'm not sure how well we should handle such cases. We don't give any guarantees about how often we resync pods secrets, right? If so, this is mostly about delay, because this situation will self recover after the next resync, right?\r\n@yujuhong - any thoughts?",
        "createdAt" : "2017-01-04T08:14:39Z",
        "updatedAt" : "2017-01-19T19:12:15Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      },
      {
        "id" : "739e1cf6-2264-4f72-9890-52064494e0fe",
        "parentId" : "87723b5e-f6a6-4963-839a-f1cc06164996",
        "authorId" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "body" : "I think delay is tolerable since there is no guarantee, but the race conditions still seem undesirable. \r\n\r\nCould we try simplifying the logic? One direction off the top of my head is to only fetch the secret on `Get()` when the cached secret has expired. No background refreshing is needed at all. This would cause a slight delay for the first pod asking for the secret, but I think that's tolerable.\r\n\r\nThe tricky part would be that we'll need to force a fetch (cache update) if the pod was added/modified after the secret was fetched to ensure that a newly added pod always observes the latest secret.",
        "createdAt" : "2017-01-04T18:14:28Z",
        "updatedAt" : "2017-01-19T19:12:15Z",
        "lastEditedBy" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "tags" : [
        ]
      },
      {
        "id" : "57a68a32-8570-463f-b654-e33f86920855",
        "parentId" : "87723b5e-f6a6-4963-839a-f1cc06164996",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "I'm not sure I understand your suggestion. When the secret \"expires\" in your approach?\r\n\r\nIn the ideal world, I think that the logic should be: \"when we observe a pod that is referencing a secret, we fetch current version and start watching for its changes\". That would pretty much solve all problems. However the main problem with this approach is that in 5000-node clusters, this may result in hundreds thousands of open watches, which may not even fit in open file descriptors limit. So the solution would be an api call \"watch all secrets attached to pods from my node\". But we don't wan't to introduce a complicated logic to serve it in apiserver, I guess (and even if so, I don't think it's doable in 1.6 timeframe - @lavalamp ). So I don't know how to do it in clean and very efficient way.\r\n",
        "createdAt" : "2017-01-04T20:15:49Z",
        "updatedAt" : "2017-01-19T19:12:15Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      },
      {
        "id" : "fe3c1bb2-e8d6-4b8b-a3bb-6fb997386b2f",
        "parentId" : "87723b5e-f6a6-4963-839a-f1cc06164996",
        "authorId" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "body" : "Agreed that \"watch\" a limited set of secrets is the best approach, but not attainable for 1.6. \r\n\r\nWhat I suggested was that we keep the cache as simple/stupid as possible. Don't fetch until kubelet asks for the secret. If the secret is >1min old, or if the pod was updated after the last fetch, block the request until we can retrieve the latest secret from the apiserver.\r\n",
        "createdAt" : "2017-01-04T23:10:16Z",
        "updatedAt" : "2017-01-19T19:12:15Z",
        "lastEditedBy" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "tags" : [
        ]
      }
    ],
    "commit" : "3c0d2bb1f0259b6b826b2a12d4e76b2db1e619ed",
    "line" : null,
    "diffHunk" : "@@ -1,1 +182,186 @@\t\t\t// We have unitialized secretData - return current result.\n\t\t\treturn secret, err\n\t\t}\n\t}\n\treturn data.secret, data.err"
  },
  {
    "id" : "1f5e7cc8-0e55-4017-a0a1-153c5f7e7708",
    "prId" : 36984,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/36984#pullrequestreview-16940524",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a4fc0744-4f23-44be-ae97-c13e5caa10a6",
        "parentId" : null,
        "authorId" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "body" : "Another way to implement this is to invalidate the cache entry on `Add`, so that it's guarantee that the next `Get` will fetch the latest version from the apiserver. ",
        "createdAt" : "2017-01-09T19:55:24Z",
        "updatedAt" : "2017-01-19T19:12:15Z",
        "lastEditedBy" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "tags" : [
        ]
      },
      {
        "id" : "9664d79d-eccd-400a-8c57-d525d08d721c",
        "parentId" : "a4fc0744-4f23-44be-ae97-c13e5caa10a6",
        "authorId" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "body" : "Either way, I think some logic should be consolidated and shared by `Get()` and `Add()`.",
        "createdAt" : "2017-01-09T20:00:23Z",
        "updatedAt" : "2017-01-19T19:12:15Z",
        "lastEditedBy" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "tags" : [
        ]
      },
      {
        "id" : "e53da615-77d9-4565-a739-9750b9499399",
        "parentId" : "a4fc0744-4f23-44be-ae97-c13e5caa10a6",
        "authorId" : "3c437914-616b-4cfb-88a0-28dc812ff2b2",
        "body" : "Done.",
        "createdAt" : "2017-01-10T12:06:31Z",
        "updatedAt" : "2017-01-19T19:12:15Z",
        "lastEditedBy" : "3c437914-616b-4cfb-88a0-28dc812ff2b2",
        "tags" : [
        ]
      },
      {
        "id" : "189afd73-84a0-43d5-941e-fd8958a7fd1f",
        "parentId" : "a4fc0744-4f23-44be-ae97-c13e5caa10a6",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "rewritten",
        "createdAt" : "2017-01-17T10:58:40Z",
        "updatedAt" : "2017-01-19T19:12:15Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "3c0d2bb1f0259b6b826b2a12d4e76b2db1e619ed",
    "line" : null,
    "diffHunk" : "@@ -1,1 +112,116 @@\nfunc (s *secretStore) Add(namespace, name string) {\n\tkey := objectKey{namespace: namespace, name: name}\n\n\t// Add is called from RegisterPod, thus it needs to be efficient."
  },
  {
    "id" : "c71a612c-ef72-4ca3-ad0d-d4ea7cd15761",
    "prId" : 36984,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/36984#pullrequestreview-16940524",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "77a90232-bf40-4970-85dd-d3cab84fc724",
        "parentId" : null,
        "authorId" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "body" : "nit: Add in the comment that RegisterPod and UnregisterPod should be efficient, i.e., should not block on network operations.",
        "createdAt" : "2017-01-12T23:04:01Z",
        "updatedAt" : "2017-01-19T19:12:15Z",
        "lastEditedBy" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "tags" : [
        ]
      },
      {
        "id" : "7d181d86-64e8-4809-837b-938a03ea1bde",
        "parentId" : "77a90232-bf40-4970-85dd-d3cab84fc724",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "done",
        "createdAt" : "2017-01-17T08:32:40Z",
        "updatedAt" : "2017-01-19T19:12:15Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "3c0d2bb1f0259b6b826b2a12d4e76b2db1e619ed",
    "line" : null,
    "diffHunk" : "@@ -1,1 +40,44 @@\n\t// RegisterPod registers all secrets from a given pod.\n\tRegisterPod(pod *v1.Pod)\n\n\t// UnregisterPod unregisters secrets from a given pod that are not"
  },
  {
    "id" : "4f212e74-477a-42c6-b96a-16beb8dd8ad9",
    "prId" : 36984,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/36984#pullrequestreview-17107178",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "097b502d-83f9-4ff9-b788-24a23eac508d",
        "parentId" : null,
        "authorId" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "body" : "I agree with @timstclair's previous comment. If we use locks, might as well make this function thread-safe. If it's not thread-safe, there is no use of locks. ",
        "createdAt" : "2017-01-12T23:06:11Z",
        "updatedAt" : "2017-01-19T19:12:15Z",
        "lastEditedBy" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "tags" : [
        ]
      },
      {
        "id" : "0403b109-d0c3-4adf-8dff-55acc03c69d0",
        "parentId" : "097b502d-83f9-4ff9-b788-24a23eac508d",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "Actually, now they are thread-safe. So I removed the comment.",
        "createdAt" : "2017-01-17T11:06:49Z",
        "updatedAt" : "2017-01-19T19:12:15Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      },
      {
        "id" : "09006ebf-2205-478e-b72f-aad463458bad",
        "parentId" : "097b502d-83f9-4ff9-b788-24a23eac508d",
        "authorId" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "body" : "sg",
        "createdAt" : "2017-01-17T23:08:18Z",
        "updatedAt" : "2017-01-19T19:12:15Z",
        "lastEditedBy" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "tags" : [
        ]
      }
    ],
    "commit" : "3c0d2bb1f0259b6b826b2a12d4e76b2db1e619ed",
    "line" : 234,
    "diffHunk" : "@@ -1,1 +232,236 @@func (c *cachingSecretManager) RegisterPod(pod *v1.Pod) {\n\tnames := getSecretNames(pod)\n\tc.lock.Lock()\n\tdefer c.lock.Unlock()\n\tfor name := range names {"
  },
  {
    "id" : "d3541d05-b901-45e1-9802-6f3a0cae00fb",
    "prId" : 36984,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/36984#pullrequestreview-16477126",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9ffc3475-2504-4c5d-a8e6-d540de26e7f8",
        "parentId" : null,
        "authorId" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "body" : "Use an internal clock (`pkg.util.clock.Clock`) for better testability.",
        "createdAt" : "2017-01-12T23:24:59Z",
        "updatedAt" : "2017-01-19T19:12:15Z",
        "lastEditedBy" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "tags" : [
        ]
      }
    ],
    "commit" : "3c0d2bb1f0259b6b826b2a12d4e76b2db1e619ed",
    "line" : null,
    "diffHunk" : "@@ -1,1 +87,91 @@\n// secretStore is a local cache of secrets.\ntype secretStore struct {\n\tkubeClient clientset.Interface\n\tclock      clock.Clock"
  },
  {
    "id" : "5b29c331-81ac-4e2f-b358-717318a655c9",
    "prId" : 36984,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/36984#pullrequestreview-17396560",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ea9994d9-baa2-428f-b1a8-80b70afe6439",
        "parentId" : null,
        "authorId" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "body" : "I think I've suggested using an internal clock (`util/clock`) before. It'd also make testing TTL easier.",
        "createdAt" : "2017-01-19T00:47:03Z",
        "updatedAt" : "2017-01-19T19:12:15Z",
        "lastEditedBy" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "tags" : [
        ]
      },
      {
        "id" : "b1786a37-bed8-4ac4-90a0-3034dcaa3795",
        "parentId" : "ea9994d9-baa2-428f-b1a8-80b70afe6439",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "Sorry - I must have missed it during the rebases etc.",
        "createdAt" : "2017-01-19T07:32:55Z",
        "updatedAt" : "2017-01-19T19:12:15Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "3c0d2bb1f0259b6b826b2a12d4e76b2db1e619ed",
    "line" : null,
    "diffHunk" : "@@ -1,1 +90,94 @@\tkubeClient clientset.Interface\n\tclock      clock.Clock\n\n\tlock  sync.Mutex\n\titems map[objectKey]*secretStoreItem"
  },
  {
    "id" : "7a7db0c6-f5bc-480a-a346-b105cb451021",
    "prId" : 36984,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/36984#pullrequestreview-17535975",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8c249788-7401-4370-9cab-3e24019f777e",
        "parentId" : null,
        "authorId" : "0adf587c-aaa2-4e47-be0f-a26d4fde14ac",
        "body" : "What's the point of this? Is the idea that the `Get` method should only return `nil` iff `err != nil`? Otherwise it makes it more difficult for the caller to reason about whether a secret was fetched.",
        "createdAt" : "2017-01-19T19:11:36Z",
        "updatedAt" : "2017-01-19T19:15:26Z",
        "lastEditedBy" : "0adf587c-aaa2-4e47-be0f-a26d4fde14ac",
        "tags" : [
        ]
      },
      {
        "id" : "36b520e2-6893-4aef-9a9f-f024de9f1178",
        "parentId" : "8c249788-7401-4370-9cab-3e24019f777e",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "This will never be returned to the user - please take a look into code below (or talk to @yujuhong it might be easier as she understands it)",
        "createdAt" : "2017-01-19T19:22:22Z",
        "updatedAt" : "2017-01-19T19:22:22Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      },
      {
        "id" : "51968c2b-e15e-49d3-addd-9689246f55a4",
        "parentId" : "8c249788-7401-4370-9cab-3e24019f777e",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "To clarify - this is just initialized here, then it is filled below before returning to the user.",
        "createdAt" : "2017-01-19T19:24:10Z",
        "updatedAt" : "2017-01-19T19:24:10Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "3c0d2bb1f0259b6b826b2a12d4e76b2db1e619ed",
    "line" : 159,
    "diffHunk" : "@@ -1,1 +157,161 @@\t\t}\n\t\tif item.secret == nil {\n\t\t\titem.secret = &secretData{}\n\t\t}\n\t\treturn item.secret"
  }
]
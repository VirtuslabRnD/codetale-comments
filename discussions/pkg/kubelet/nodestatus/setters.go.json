[
  {
    "id" : "0e6a8913-afc2-4d4a-a7d4-987db7fb91e3",
    "prId" : 85850,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/85850#pullrequestreview-326428757",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "24b24c79-9e80-48d3-ae74-0eb0d030d7d3",
        "parentId" : null,
        "authorId" : "203dfb85-d185-4057-88b3-a1b4f09fd1fd",
        "body" : "this is great",
        "createdAt" : "2019-12-03T20:31:25Z",
        "updatedAt" : "2020-01-16T21:44:00Z",
        "lastEditedBy" : "203dfb85-d185-4057-88b3-a1b4f09fd1fd",
        "tags" : [
        ]
      }
    ],
    "commit" : "ce68edf70099642389f4712bec3a1fa773661fdf",
    "line" : 70,
    "diffHunk" : "@@ -1,1 +196,200 @@\t\t\t//\n\t\t\t// For steps 3 and 4, IPv4 addresses are preferred to IPv6 addresses\n\t\t\t// unless nodeIP is \"::\", in which case it is reversed.\n\t\t\tif nodeIPSpecified {\n\t\t\t\tipAddr = nodeIP"
  },
  {
    "id" : "37dec5d6-0be7-48ff-8b86-f0ef806270a9",
    "prId" : 75229,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/75229#pullrequestreview-213162947",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d9c5665a-cdf2-4eff-b2bd-90c58dd3a1d6",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "is cloud `nil` when we have an external cloud provider?",
        "createdAt" : "2019-03-12T01:02:48Z",
        "updatedAt" : "2019-05-17T15:06:58Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "8754c5e7-30b7-4b4d-ad01-e6aad7652dbd",
        "parentId" : "d9c5665a-cdf2-4eff-b2bd-90c58dd3a1d6",
        "authorId" : "7aca96c2-45d7-4567-99be-0323d7556c55",
        "body" : "It comes from https://github.com/kubernetes/cloud-provider/blob/master/plugins.go#L109, so yes. Occasional think we would be better of with an explicit ExternalCloudProvider implementation but the current mechanisms (KCM, Kubelet, ...) have cloud set to nil when external.",
        "createdAt" : "2019-03-12T01:50:01Z",
        "updatedAt" : "2019-05-17T15:06:58Z",
        "lastEditedBy" : "7aca96c2-45d7-4567-99be-0323d7556c55",
        "tags" : [
        ]
      }
    ],
    "commit" : "0d8861114d9db67e0d93c7ec7403afbecd25e23e",
    "line" : 15,
    "diffHunk" : "@@ -1,1 +90,94 @@\t\t\t}\n\t\t}\n\t\tif cloud != nil {\n\t\t\tnodeAddresses, err := nodeAddressesFunc()\n\t\t\tif err != nil {"
  },
  {
    "id" : "2910eece-6d45-4dfa-99f9-9e420a742148",
    "prId" : 70805,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/70805#pullrequestreview-181749606",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "cc627dab-bce9-43c8-b71c-d4897b042b1b",
        "parentId" : null,
        "authorId" : "c63e1ceb-64bd-4726-b8ef-e647d73dae0c",
        "body" : "this panics in case `nodeAddress.Type` key does not exist (e.g. in case `nodeAddress.Address != nodeIP.String()`):\r\n\r\n```go\r\ntype, exists := nodeIPTypes[nodeAddress.Type]; (!exists || !type)\r\n```",
        "createdAt" : "2018-11-22T12:50:30Z",
        "updatedAt" : "2018-11-22T12:50:39Z",
        "lastEditedBy" : "c63e1ceb-64bd-4726-b8ef-e647d73dae0c",
        "tags" : [
        ]
      },
      {
        "id" : "c01b9a21-f5bb-46ab-acff-a3e6db318b84",
        "parentId" : "cc627dab-bce9-43c8-b71c-d4897b042b1b",
        "authorId" : "c490e441-2b9f-41f2-8559-d47be0ea8836",
        "body" : "Hm? No, reading a non-existent map value is allowed. It just returns the zero value, which does the right thing here. (You're thinking of typecasting, where it *does* panic if you use the 1-return-value form and it fails.)",
        "createdAt" : "2018-11-27T17:32:50Z",
        "updatedAt" : "2018-11-27T17:32:51Z",
        "lastEditedBy" : "c490e441-2b9f-41f2-8559-d47be0ea8836",
        "tags" : [
        ]
      },
      {
        "id" : "2848f0ed-6cc0-4c22-b416-85e914b693cc",
        "parentId" : "cc627dab-bce9-43c8-b71c-d4897b042b1b",
        "authorId" : "c63e1ceb-64bd-4726-b8ef-e647d73dae0c",
        "body" : "Oh, you are right. Interesting :) ",
        "createdAt" : "2018-12-05T13:19:07Z",
        "updatedAt" : "2018-12-05T13:19:07Z",
        "lastEditedBy" : "c63e1ceb-64bd-4726-b8ef-e647d73dae0c",
        "tags" : [
        ]
      }
    ],
    "commit" : "863c6ca241aaadfd637f0d6b85155893a1551ca6",
    "line" : 17,
    "diffHunk" : "@@ -1,1 +100,104 @@\t\t\t\tif len(enforcedNodeAddresses) > 0 {\n\t\t\t\t\tfor _, nodeAddress := range nodeAddresses {\n\t\t\t\t\t\tif !nodeIPTypes[nodeAddress.Type] && nodeAddress.Type != v1.NodeHostName {\n\t\t\t\t\t\t\tenforcedNodeAddresses = append(enforcedNodeAddresses, v1.NodeAddress{Type: nodeAddress.Type, Address: nodeAddress.Address})\n\t\t\t\t\t\t}"
  },
  {
    "id" : "ae1ce251-26e4-4b53-bcbd-76505afbb1e2",
    "prId" : 70805,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/70805#pullrequestreview-181799402",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c8e9b2cf-9775-4412-ae47-219b818e049b",
        "parentId" : null,
        "authorId" : "c63e1ceb-64bd-4726-b8ef-e647d73dae0c",
        "body" : "Right. Before the `break` was introduced this loop appended both external and internal ip address with `ip == nodeIP.String()`. After the `break`, the second loop in `if len(enforcedNodeAddresses) > 0` branch actually appended all internal ip addresses (not just `nodeIP`) which comes in random order so instead of returning `(external nodeIP, internal nodeIP, hostname)`, the `enforcedNodeAddresses` now returns `(external nodeIP, internal nodeIP, internal ip1, ...)` or `(external nodeIP, internal ip1, internal nodeIP, ...)`. This is quite a regression.",
        "createdAt" : "2018-12-05T15:00:34Z",
        "updatedAt" : "2018-12-05T15:00:34Z",
        "lastEditedBy" : "c63e1ceb-64bd-4726-b8ef-e647d73dae0c",
        "tags" : [
        ]
      }
    ],
    "commit" : "863c6ca241aaadfd637f0d6b85155893a1551ca6",
    "line" : 11,
    "diffHunk" : "@@ -1,1 +95,99 @@\t\t\t\t\tif nodeAddress.Address == nodeIP.String() {\n\t\t\t\t\t\tenforcedNodeAddresses = append(enforcedNodeAddresses, v1.NodeAddress{Type: nodeAddress.Type, Address: nodeAddress.Address})\n\t\t\t\t\t\tnodeIPTypes[nodeAddress.Type] = true\n\t\t\t\t\t}\n\t\t\t\t}"
  },
  {
    "id" : "153e3c57-ab7e-45fd-b430-739123ae0a72",
    "prId" : 67739,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/67739#pullrequestreview-150165072",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8dd3c3b2-193c-4ddc-a39b-1179690d7958",
        "parentId" : null,
        "authorId" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "body" : "log a warning?",
        "createdAt" : "2018-08-28T14:47:02Z",
        "updatedAt" : "2018-08-28T15:27:22Z",
        "lastEditedBy" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "tags" : [
        ]
      },
      {
        "id" : "6579ddbe-8737-40e0-8983-82d251ff9ed8",
        "parentId" : "8dd3c3b2-193c-4ddc-a39b-1179690d7958",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "sure",
        "createdAt" : "2018-08-28T14:54:37Z",
        "updatedAt" : "2018-08-28T15:27:22Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "2857de73ce387473463ac90f3205e7fdf9236bb8",
    "line" : 30,
    "diffHunk" : "@@ -1,1 +127,131 @@\t\t\t\t// the hostname was force-set via flag/config.\n\t\t\t\t// this means the hostname might not be able to be validated via cloud provider metadata,\n\t\t\t\t// but was a choice by the kubelet deployer we should honor\n\t\t\t\tvar existingHostnameAddress *v1.NodeAddress\n\t\t\t\tfor i := range nodeAddresses {"
  },
  {
    "id" : "5ca0dd4f-33aa-40d9-a1a1-79ef3452358f",
    "prId" : 65660,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/65660#pullrequestreview-136400629",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f3ff2d0d-a27d-48a4-8eb1-819ae6ae1fd0",
        "parentId" : null,
        "authorId" : "d2b16581-e7e9-48b8-9f76-6f6bcb9ec300",
        "body" : "an interface which is a subset of containerManager would be useful here too.",
        "createdAt" : "2018-07-11T20:26:47Z",
        "updatedAt" : "2018-07-16T16:11:14Z",
        "lastEditedBy" : "d2b16581-e7e9-48b8-9f76-6f6bcb9ec300",
        "tags" : [
        ]
      }
    ],
    "commit" : "0f8976bf8412289290bb57fd68cdc826be49291d",
    "line" : 171,
    "diffHunk" : "@@ -1,1 +169,173 @@\tpodsPerCore int,\n\tmachineInfoFunc func() (*cadvisorapiv1.MachineInfo, error), // typically Kubelet.GetCachedMachineInfo\n\tcapacityFunc func() v1.ResourceList, // typically Kubelet.containerManager.GetCapacity\n\tdevicePluginResourceCapacityFunc func() (v1.ResourceList, v1.ResourceList, []string), // typically Kubelet.containerManager.GetDevicePluginResourceCapacity\n\tnodeAllocatableReservationFunc func() v1.ResourceList, // typically Kubelet.containerManager.GetNodeAllocatableReservation"
  }
]
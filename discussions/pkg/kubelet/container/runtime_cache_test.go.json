[
  {
    "id" : "42fda233-09db-4ed7-a657-24d609039b5b",
    "prId" : 7749,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "10c52854-6c13-4ef3-891f-201ad04bb91a",
        "parentId" : null,
        "authorId" : "395f4f9a-98be-4485-b436-51f0897d7c9f",
        "body" : "nit: these tests don't make the problem clear (to me at least), would be good to have one in pod_worker that actually creates fake containers during a list that started at the wrong time, sets minRuntimeCacheTime and confirms that we get the containers previously created. You can send a follow up pr for that if that makes sense.\n",
        "createdAt" : "2015-05-06T00:04:23Z",
        "updatedAt" : "2015-05-06T01:28:53Z",
        "lastEditedBy" : "395f4f9a-98be-4485-b436-51f0897d7c9f",
        "tags" : [
        ]
      },
      {
        "id" : "2d823a25-6ce8-43e0-b4f3-d2e8f2853c8b",
        "parentId" : "10c52854-6c13-4ef3-891f-201ad04bb91a",
        "authorId" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "body" : "Yes, the tests here do not directly reflect a single failure case, but I think they are testing the more fundamental problem, which is the cache could be updated to older pods. It doesn't have to be related to the specific pod worker case you mentioned.\n\nAs previously discussed in this PR, only the updatingThread could potentially cause the false updates if no safeguard is implemented. Given that, the test you want would be like this:\n1. pod_worker1 creates containers A\n2. pod_worker1 calls `ForceUpdateIfOlder`\n3. Dial back the clock in the cache. Set fakeDocker container list to not include A. Call `GetPods` to trigger an update. Make sure the updating thread tries to update the cache but failed(?). \n4. Restore the clock in the cache. Call `GetPods` to confirm that container A exists.\n\nThis doesn't see clear or cleaner to me...\n",
        "createdAt" : "2015-05-06T00:52:23Z",
        "updatedAt" : "2015-05-06T01:28:53Z",
        "lastEditedBy" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "tags" : [
        ]
      },
      {
        "id" : "0d80fa95-7e52-4f31-b9b0-ee04843eca2d",
        "parentId" : "10c52854-6c13-4ef3-891f-201ad04bb91a",
        "authorId" : "395f4f9a-98be-4485-b436-51f0897d7c9f",
        "body" : "Upto you, that conveys the intent of minCacheTime and what staleness guarantees a pod worker can tolerate (it really doesn't care about stale pods managed by other workers as long as the cache has the pods it modified). Most people understand how a simple cache works even without tests :)\n",
        "createdAt" : "2015-05-06T01:07:50Z",
        "updatedAt" : "2015-05-06T01:28:53Z",
        "lastEditedBy" : "395f4f9a-98be-4485-b436-51f0897d7c9f",
        "tags" : [
        ]
      },
      {
        "id" : "367eb93c-4350-47e6-9162-74c92aae5590",
        "parentId" : "10c52854-6c13-4ef3-891f-201ad04bb91a",
        "authorId" : "395f4f9a-98be-4485-b436-51f0897d7c9f",
        "body" : "I get where you're coming from though, the test looks a little hairy. lets keep this pr about just the cache, would still be nice to convey intent in some way\n",
        "createdAt" : "2015-05-06T01:25:29Z",
        "updatedAt" : "2015-05-06T01:28:53Z",
        "lastEditedBy" : "395f4f9a-98be-4485-b436-51f0897d7c9f",
        "tags" : [
        ]
      },
      {
        "id" : "ad3b3460-d4d4-48cd-81a6-bf10aafb82ea",
        "parentId" : "10c52854-6c13-4ef3-891f-201ad04bb91a",
        "authorId" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "body" : "> Most people understand how a simple cache works even without tests :)\n\nI beg to differ. It's easy to make mistakes while touching code like this ;)\nThe tests at least provide _some_ sanity check for this kind of purposes.\n\nI understand the value of demonstrating and verifying the pod worker use case, but I also found the test to be confusing and clunky as I pointed out earlier. The current implementation updatingThread'd make the test unnecessarily complicated. Refactoring runtimeCache may help with the the testability, but I am hesitant to prioritize that... \n",
        "createdAt" : "2015-05-06T01:44:40Z",
        "updatedAt" : "2015-05-06T01:44:40Z",
        "lastEditedBy" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "tags" : [
        ]
      },
      {
        "id" : "db897b40-54d5-477b-a3d9-9ee1d7dabef2",
        "parentId" : "10c52854-6c13-4ef3-891f-201ad04bb91a",
        "authorId" : "395f4f9a-98be-4485-b436-51f0897d7c9f",
        "body" : "SG, you know best what's worth the time and effort for modules you maintain :)\n",
        "createdAt" : "2015-05-06T02:17:36Z",
        "updatedAt" : "2015-05-06T02:17:36Z",
        "lastEditedBy" : "395f4f9a-98be-4485-b436-51f0897d7c9f",
        "tags" : [
        ]
      }
    ],
    "commit" : "c075719f05f163e0e70a3cd20b4dc26f8ab73f19",
    "line" : 24,
    "diffHunk" : "@@ -1,1 +22,26 @@\t\"time\"\n)\n\n// testRunTimeCache embeds runtimeCache with some additional methods for\n// testing."
  },
  {
    "id" : "99def9c5-a5aa-4d2d-927e-7449467640e4",
    "prId" : 7749,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "52320c70-6d7c-4ee4-a42d-5cf3874d1eba",
        "parentId" : null,
        "authorId" : "395f4f9a-98be-4485-b436-51f0897d7c9f",
        "body" : "Another (more paranoid) way to do this would be to use a util.Clock in the runtime_cache and replace it with a FakeClock in the unittest. I'll leave it to you, since clocks mostly work fine.\n",
        "createdAt" : "2015-05-06T00:04:25Z",
        "updatedAt" : "2015-05-06T01:28:53Z",
        "lastEditedBy" : "395f4f9a-98be-4485-b436-51f0897d7c9f",
        "tags" : [
        ]
      },
      {
        "id" : "d36a4d6b-7851-46a8-9270-b83c4a85069e",
        "parentId" : "52320c70-6d7c-4ee4-a42d-5cf3874d1eba",
        "authorId" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "body" : "util.Clock would not be good here because `ForceUpdateIfOlder(minExpectedCacheTime time.Time)` would accept external time and compare with the internal clock.\n",
        "createdAt" : "2015-05-06T01:29:47Z",
        "updatedAt" : "2015-05-06T01:29:47Z",
        "lastEditedBy" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "tags" : [
        ]
      },
      {
        "id" : "af4dbe22-6c77-4d77-a042-35a0e67082ce",
        "parentId" : "52320c70-6d7c-4ee4-a42d-5cf3874d1eba",
        "authorId" : "395f4f9a-98be-4485-b436-51f0897d7c9f",
        "body" : "You'd have to change every related thing that does rely on system clock in a unittest :( \nDefer SG\n",
        "createdAt" : "2015-05-06T01:32:28Z",
        "updatedAt" : "2015-05-06T01:32:28Z",
        "lastEditedBy" : "395f4f9a-98be-4485-b436-51f0897d7c9f",
        "tags" : [
        ]
      },
      {
        "id" : "173f91b3-ef57-4b23-9595-4a33d3c1e6ca",
        "parentId" : "52320c70-6d7c-4ee4-a42d-5cf3874d1eba",
        "authorId" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "body" : "Ohh... I wasn't actually talking about the unit tests. If I add util.Clock in the runtimeCache itself, I'd expect all the public methods to provide relative time (e.g. time.Duration), but not the absolute time. Since we expose methods that accepts caller's time, it's strange to keep an internal clock that we don't completely rely on.\n",
        "createdAt" : "2015-05-06T01:38:31Z",
        "updatedAt" : "2015-05-06T01:38:31Z",
        "lastEditedBy" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "tags" : [
        ]
      },
      {
        "id" : "b0d4e32b-d023-49ee-9d06-a0c9a27bf8b5",
        "parentId" : "52320c70-6d7c-4ee4-a42d-5cf3874d1eba",
        "authorId" : "395f4f9a-98be-4485-b436-51f0897d7c9f",
        "body" : "so tl;dr i don't want to rewrite this module, good enough\n",
        "createdAt" : "2015-05-06T02:15:05Z",
        "updatedAt" : "2015-05-06T02:15:05Z",
        "lastEditedBy" : "395f4f9a-98be-4485-b436-51f0897d7c9f",
        "tags" : [
        ]
      }
    ],
    "commit" : "c075719f05f163e0e70a3cd20b4dc26f8ab73f19",
    "line" : 98,
    "diffHunk" : "@@ -1,1 +96,100 @@\tcache.Lock()\n\tcache.pods = newpods\n\tcache.cacheTime = time.Now().Add(20 * time.Minute)\n\tcache.Unlock()\n"
  }
]
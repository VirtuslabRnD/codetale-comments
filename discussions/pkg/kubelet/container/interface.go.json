[
  {
    "id" : "32cff4cd-ecf7-4eaf-883a-a7d62d2254d8",
    "prId" : 25899,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0d628ba0-70c5-400c-8171-ed6621ac3b7b",
        "parentId" : null,
        "authorId" : "5328b1c0-0dbd-4fd8-869d-e914880959c2",
        "body" : "Should probably include paths to all shared namespaces for completeness.\n",
        "createdAt" : "2016-05-19T21:45:35Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "5328b1c0-0dbd-4fd8-869d-e914880959c2",
        "tags" : [
        ]
      },
      {
        "id" : "e8c9a21a-f0c2-4f72-a617-6c10febf2b2c",
        "parentId" : "0d628ba0-70c5-400c-8171-ed6621ac3b7b",
        "authorId" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "body" : "We can approach this in two different ways. One is, as you suggested, returning everything for completeness. The other is to add fields when we need it. I went with the second approach, and we can iterate and add more fields if required.\n",
        "createdAt" : "2016-05-27T18:48:25Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "tags" : [
        ]
      }
    ],
    "commit" : "08dc66113399c89e31f6872f3c638695a6ec6a8d",
    "line" : null,
    "diffHunk" : "@@ -1,1 +184,188 @@\n// Namespaces contains paths to the namespaces.\ntype Namespaces struct {\n\t// Network is the path to the network namespace.\n\tNetwork string"
  },
  {
    "id" : "9fb8dd11-c783-4bc7-a778-5c718562b953",
    "prId" : 25899,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c612c397-5d8c-45cb-8dd3-47e4b9e64667",
        "parentId" : null,
        "authorId" : "5328b1c0-0dbd-4fd8-869d-e914880959c2",
        "body" : "Could follow the OCI spec as it covers all use cases https://github.com/opencontainers/runtime-spec/blob/master/specs-go/config.go#L150\n",
        "createdAt" : "2016-05-19T21:56:15Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "5328b1c0-0dbd-4fd8-869d-e914880959c2",
        "tags" : [
        ]
      },
      {
        "id" : "842cf5f3-cee9-4935-8446-034a26bf5e02",
        "parentId" : "c612c397-5d8c-45cb-8dd3-47e4b9e64667",
        "authorId" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "body" : "@mrunalp I think the difference is that kubelet doesn't directly enforce namespaces, and it only asks whether the runtime _support_ features that we expose to the users. We may not know (or need to know) namespace paths in most cases. Does that make sense to you? \n",
        "createdAt" : "2016-05-24T17:46:11Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "tags" : [
        ]
      },
      {
        "id" : "9a8da358-3ef3-45c8-9505-fe7b12314f8b",
        "parentId" : "c612c397-5d8c-45cb-8dd3-47e4b9e64667",
        "authorId" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "body" : "To add to that, we can't ask docker to use a given namespace directly, so exposing more details than what the runtime is not desired. Runtime will have to error out if it cannot apply the configs.\n",
        "createdAt" : "2016-05-27T18:43:57Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "tags" : [
        ]
      }
    ],
    "commit" : "08dc66113399c89e31f6872f3c638695a6ec6a8d",
    "line" : null,
    "diffHunk" : "@@ -1,1 +110,114 @@\t// NamespaceOptions contains configurations for the sandbox's namespaces.\n\t// This will be used only if the PodSandbox uses namespace for isolation.\n\tNamespaceOptions NamespaceOptions\n}\n"
  },
  {
    "id" : "6bf138b3-2763-4fb2-8ce5-cab02b42b0d9",
    "prId" : 25899,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f6d24af3-7981-4771-8e8f-18c5c54eaa22",
        "parentId" : null,
        "authorId" : "2fa5a4c6-e0a7-4dbe-a80e-7770a5dc92a1",
        "body" : "Why have logging be defined by a path?\n\nIt seems wrong for the kubelet to mandate that it has to be FS accessible (and supplying only a path also mandates it's in a single format the kubelet expects).\n\nWouldn't it make more sense for the container runtime to provide a method to get a stream of logs (stdout, stdin), or a batch of logs given an input timestamp? I know docker provides that, and other runtimes can write code of varying complexity as needed.\n",
        "createdAt" : "2016-05-20T02:29:49Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "2fa5a4c6-e0a7-4dbe-a80e-7770a5dc92a1",
        "tags" : [
        ]
      },
      {
        "id" : "e2632b6c-189c-49c3-9758-ec84bd02a7a2",
        "parentId" : "f6d24af3-7981-4771-8e8f-18c5c54eaa22",
        "authorId" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "body" : "We want to provide better storage and IO isolation for containers.\nDisk isolation is a big pain point today mainly because runtimes choose to manage disk resources in a diverse manner.\nWe also want the containers to have as little dependencies as possible. Funneling log files through a single daemon introduces a SPOF. \nFeedback we have received from users is to avoid adding any metadata to logs from the runtime. \nSo I don't see why runtimes have to deal with logging at all.\n\nBy writing to files initially, we do not preclude usage of other logging agents like journald, fluentd, splunk, etc.\n\n> It seems wrong for the kubelet to mandate that it has to be FS accessible (and supplying only a path also mandates it's in a single format the kubelet expects).\n\nWhy?\n",
        "createdAt" : "2016-05-24T18:01:50Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "tags" : [
        ]
      },
      {
        "id" : "c5e5d22d-ba12-4385-886e-7bae48af657c",
        "parentId" : "f6d24af3-7981-4771-8e8f-18c5c54eaa22",
        "authorId" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "body" : "Related issue: #24677\n",
        "createdAt" : "2016-05-27T19:03:55Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "tags" : [
        ]
      },
      {
        "id" : "320b404d-ced5-47fd-bf29-8e10fae00f37",
        "parentId" : "f6d24af3-7981-4771-8e8f-18c5c54eaa22",
        "authorId" : "2fa5a4c6-e0a7-4dbe-a80e-7770a5dc92a1",
        "body" : "My concerns are echoed in that issue as well; a file-path doesn't play well with journald (nor other logging solutions IMO).\n\n> We want to provide better storage and IO isolation for containers.\n\nWill that actually occur in practice? Right now, both Docker and rkt store logs in locations of their own choosing in their own formats (json and journald respectively). If you require the runtimes to store logs in one additional location in a plainer format (presumably logs.stderr, logs.stdout), you'll end up with two copies of the logs, only one of which is managed as you want. Perhaps I'm misunderstanding something there.\n\n> > It seems wrong for the kubelet to mandate that it has to be FS accessible (and supplying only a path also mandates it's in a single format the kubelet expects).\n> \n> Why?\n\nSome users may want to log directly to a remote server. Some users may want to take advantage of logging features their container runtimes provide (e.g. additional metadata). So long as the runtime can provide a streaming interface to stdout/err, why should we get in the way of doing such things?\n",
        "createdAt" : "2016-05-31T19:48:03Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "2fa5a4c6-e0a7-4dbe-a80e-7770a5dc92a1",
        "tags" : [
        ]
      },
      {
        "id" : "b6cd3d3f-9b76-4b49-b21e-120daae60ab6",
        "parentId" : "f6d24af3-7981-4771-8e8f-18c5c54eaa22",
        "authorId" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "body" : "@euank \n\n> My concerns are echoed in that issue as well; a file-path doesn't play well with journald (nor other logging solutions IMO).\n\nWhy does `journald` have to be in the critical path between a container and its logs? Users of kuberentes will most likely run a cluster level logging service and/or use the `kubectl logs` interface to consume logs. As an end user of kubernetes, why would one care about journald? Journald does not seem to provide the isolation that is required for kubernetes. \n\n> Will that actually occur in practice? Right now, both Docker and rkt store logs in locations of their own choosing in their own formats (json and journald respectively). If you require the runtimes to store logs in one additional location in a plainer format (presumably logs.stderr, logs.stdout), you'll end up with two copies of the logs, only one of which is managed as you want. Perhaps I'm misunderstanding something there.\n\nThis proposal is not meant to just provide compatibility with all existing FOSS. It is rather meant to define how a runtime for kubernetes should be. Continuing to design against all the various design assumptions being made in various FOSS projects is not really adding much value to k8s end users.\nIn the near future, we might have new runtimes that meet all the requirements of this API and provide better integration with Kubernetes. \nAs for the existing runtimes, we will document known issues with each runtime and let users make their choice. So if docker cannot provide better isolation for log files, it is up to the user to decide if they want to use docker as the runtime.\nAs for docker support, kubelet creates symlinks to the log files being created by docker. We can continue doing that, even though it does not meet all the requirements.\n\n> Some users may want to log directly to a remote server. Some users may want to take advantage of logging features their container runtimes provide (e.g. additional metadata). So long as the runtime can provide a streaming interface to stdout/err, why should we get in the way of doing such things?\n\nThe main reason is to provide a stable extension point for logging agents to collect logs from kubernetes pods. By letting each runtime handle logs in its own manner, we will have a pretty fragmented ecosystem, with logging vendors not knowing how (& where) to integrate with k8s.\nA standalone use case of a container runtime might not match completely with that of k8s use case.\n",
        "createdAt" : "2016-05-31T23:07:04Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "tags" : [
        ]
      },
      {
        "id" : "ba772f73-9ac4-4ab5-a39e-0d9f1b2fea98",
        "parentId" : "f6d24af3-7981-4771-8e8f-18c5c54eaa22",
        "authorId" : "2fa5a4c6-e0a7-4dbe-a80e-7770a5dc92a1",
        "body" : "Journald is becoming ubiquitous. It makes sense to consider it. Journald also has better integration with containers than many logging daemons via its machinectl / nspawn integration.\n\nMy concerns are lessened if what you want is _just_ a path (as indicated in the referenced issue) and totally arbitrary log-formats can be stored there, such as journald journals. However, I still am not convinced that's the case. You talk about logging agents interpreting those logs, but I it seems like kubelet will have to as well because there's no `GetLogs` in the runtime interface, so the only way it will have to implement the `kubectl logs` call will be via parsing this directory.\nGiven that, no runtime will really work with k8s unless the kubelet also understands its chosen log format. However, if there _is_ a `GetLogs` api in the runtime, the burden of understanding its own log format is moved there which I think makes a lot more sense for, at the least, the `kubectl logs` usecase.\n\nIs there some other way `kubectl logs` can work? Is it okay for the kubelet to gate what formats are supported in that manner?\n",
        "createdAt" : "2016-06-01T00:30:43Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "2fa5a4c6-e0a7-4dbe-a80e-7770a5dc92a1",
        "tags" : [
        ]
      },
      {
        "id" : "83d8eb4c-32df-4b14-9eed-0bcd0412f09f",
        "parentId" : "f6d24af3-7981-4771-8e8f-18c5c54eaa22",
        "authorId" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "body" : "> Journald is becoming ubiquitous\n\nSure. But it doesn't satisfy k8s isolation requirements when shared with containers.\nIs it possible to limit disk usage and IO of each container while using journald today? At least with rkt?\n",
        "createdAt" : "2016-06-01T05:00:36Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "tags" : [
        ]
      },
      {
        "id" : "11568715-74eb-420f-bb72-db304fe16629",
        "parentId" : "f6d24af3-7981-4771-8e8f-18c5c54eaa22",
        "authorId" : "2fa5a4c6-e0a7-4dbe-a80e-7770a5dc92a1",
        "body" : "Anything is possible if you write your own stage1 :)\n\nReally though, right now each journal is written to a separate file and each journald process runs in its own cgroup slice, so presumably you could use blkio limitations on each of those different journals, though I don't think rkt gives you knobs to trivially configure that (cc @jonboulle).\n\nThis is made possible with a separate journald process per pod (I'm not sure if you can do it without).\n",
        "createdAt" : "2016-06-01T17:44:46Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "2fa5a4c6-e0a7-4dbe-a80e-7770a5dc92a1",
        "tags" : [
        ]
      },
      {
        "id" : "626903f7-a08e-45d5-b41d-dce17e9c592b",
        "parentId" : "f6d24af3-7981-4771-8e8f-18c5c54eaa22",
        "authorId" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "body" : "The functionality that kubelet intends to provide wrt. to logging are as follows:\n1. Rotate log files per container whenever a container is using a lot of disk. This will help prevent evicting the container's pod whenever there is disk pressure.\n2. Keep the log files from the first and most recent runs of a container and delete logs from other instances to free up disk space for the container.\n3. Eventually impose disk IO limits on a per-container basis to avoid having a side-car container bring down all the containers on that node, by thrashing the disk. Pod level disk IO limits is definitely better than today's situation, but our API only supports container limits as of now.\n4. Keep log files from dead pods around on a best-effort basis and evict them whenever there is disk pressure.\n\nIf all the above requirements can be met by rkt, we can let rkt deal with logging all together. FWIW, the current design doesn't allow for these features to be supported.\nThis is an issue with docker too and we might just have to treat them as legacy runtimes. I'd like to provide the features mentioned above at-least with new runtimes.\n",
        "createdAt" : "2016-06-01T19:18:39Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "tags" : [
        ]
      },
      {
        "id" : "62c5b986-1ffc-4f18-90ce-5d9cb4c9d521",
        "parentId" : "f6d24af3-7981-4771-8e8f-18c5c54eaa22",
        "authorId" : "2fa5a4c6-e0a7-4dbe-a80e-7770a5dc92a1",
        "body" : "I'm quite confused by this discussion now.\n\nFirstly, I don't think you answered my above question of effectively \"How will `kubectl logs` work off just a logdirectory\" and related details. I'm still convinced that a `GetLogs` method on the ContainerRuntime interface is the most sane way to support that operation, if not all logs operations (sure, something like your log collector probably should do something else, but hey, why should that be a log directory vs just knowing to forward journald logs?)\n\nIf the eventual goal is each of this functionalities you mentioned, then why not require that the Pod/Container Config structs have a log rotation policy, a log retention policy, and a diskio limit?\n\nExpressing the desire for those features to a runtime in this contract seems like the clear way to make it have a chance of it happening. Not asking the runtimes to toss data at some directory and adding more code in the runtime to try and rotate log-format XYZ without corrupting it.\n\nIf you're okay with rkt dealing with logging altogether, then why care at all about the logpath in general? If one container runtime need not use it (because of the above), then it doesn't really make sense for it to be in a general interface.\n",
        "createdAt" : "2016-06-02T05:31:04Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "2fa5a4c6-e0a7-4dbe-a80e-7770a5dc92a1",
        "tags" : [
        ]
      },
      {
        "id" : "4686c3f6-367f-491d-b4d6-b5175d9ba9d4",
        "parentId" : "f6d24af3-7981-4771-8e8f-18c5c54eaa22",
        "authorId" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "body" : "> I'm quite confused by this discussion now.\n\nMe too. There hasn't been any disagreement with the need for better isolation and yet we are continuing to talk about `journald` which clearly isn't satisfying all the requirements for kubernetes. If there is an alternative solution that provides all the isolation requirements I mentioned, I'm all ears. My goal is to get most kubernetes deployments to provide better isolation.  \n\n> Firstly, I don't think you answered my above question of effectively \"How will kubectl logs work off just a logdirectory\" and related details. I'm still convinced that a GetLogs method on the ContainerRuntime interface is the most sane way to support that operation, if not all logs operations (sure, something like your log collector probably should do something else, but hey, why should that be a log directory vs just knowing to forward journald logs?)\n\n`kubectl logs` issue can be solved for example by injecting a wrapper binary between the docker daemon and the actual container process. The wrapper binary can re-direct logs to a kubelet specified file path and then exec the user process. \nFrankly, the integration plan for existing runtimes isn't clear atm. For example, we can provide a backdoor legacy logging API for docker and rkt to begin with. But, I'd prefer at least the new runtimes to follow certain best practices when it comes to logging and disk usage.\n\n> If the eventual goal is each of this functionalities you mentioned, then why not require that the Pod/Container Config structs have a log rotation policy, a log retention policy, and a diskio limit?\n\nLog rotation and retention will be provided on a best effort basis. The recommendation is to ship log files off the nodes to a central logging service. So I don't see a need for it to be in the API at all. \nBut for Disk IO, we can wait for user feedback to see if they want to configure it. Until then, kubelet can at-least expose disk IO metrics accurately per container and let users kill offending pods.\n\n> Expressing the desire for those features to a runtime in this contract seems like the clear way to make it have a chance of it happening. Not asking the runtimes to toss data at some directory and adding more code in the runtime to try and rotate log-format XYZ without corrupting it.\n\nIf I was not clear, apologies. This proposal is excepting runtimes to re-direct stdout & stderr to a kubelet specified file, without clobbering the log lines, at-least keeping it human readable. If you run journald as well, thats probably fine, but the disk usage needs to be accounted appropriately. \n\n> If you're okay with rkt dealing with logging altogether, then why care at all about the logpath in general? If one container runtime need not use it (because of the above), then it doesn't really make sense for it to be in a general interface.\n\nI disagree. Design choices of one runtime should not ideally affect the entire ecosystem.\n",
        "createdAt" : "2016-06-03T00:20:16Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "tags" : [
        ]
      },
      {
        "id" : "b63093d4-0a68-475d-a6f9-03575b961a70",
        "parentId" : "f6d24af3-7981-4771-8e8f-18c5c54eaa22",
        "authorId" : "2fa5a4c6-e0a7-4dbe-a80e-7770a5dc92a1",
        "body" : "I'm absolutely not suggesting journald be the solution of choice and that was a bit of a tangent.\n\nHowever, I do think we disagree on one point: whether the kubelet should be a log management daemon (possibly in addition to runtimes), or whether the runtimes should make their own decisions (whether that be to manage logs themselves or offload that onto some other daemon like journald is irrelevant) and simply be given enough information by the kubelet to do the right thing.\n\nI think we also both agree that further isolation would be awesome... however I think that that isolation can be provided better by the container runtime by expressing the desired isolation because a container-runtime-X probably better understands how its logs are handled than the kubelet does, rather than applying policies on top of the kubelet's copy of the logs (which might not be the only one).\n\n> If I was not clear, apologies. This proposal is excepting runtimes to re-direct stdout & stderr to a kubelet specified file, without clobbering the log lines, at-least keeping it human readable\n\nIn the linked issue, I got the impression that arbitrary data could live at said location. Thanks for clarifying.\n\nLet's discuss this in the community sync or, if not there, in a separate hangout/discussion. I feel like we've reached the limit of github issues :smile: \n",
        "createdAt" : "2016-06-03T17:44:34Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "2fa5a4c6-e0a7-4dbe-a80e-7770a5dc92a1",
        "tags" : [
        ]
      }
    ],
    "commit" : "08dc66113399c89e31f6872f3c638695a6ec6a8d",
    "line" : null,
    "diffHunk" : "@@ -1,1 +283,287 @@\t// https://issues.k8s.io/24677. There *may* be future change of direction\n\t// for logging as the discussion carries on.\n\tLogPath string\n\n\t// Variables for interactive containers, these have very specialized"
  },
  {
    "id" : "979eb68c-db9c-41d5-a163-50cfa2323d30",
    "prId" : 25899,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f165d9a9-e5d7-4a20-8424-5678f0ed4b9d",
        "parentId" : null,
        "authorId" : "2fa5a4c6-e0a7-4dbe-a80e-7770a5dc92a1",
        "body" : "What does \"in the privileged mode\" mean? Isn't this redundant given the above `AddCapabilities` with `CAP_SYSADMIN` and such?\n\nOther questions, what does that mean in VMs and is it not linux-specific?\n",
        "createdAt" : "2016-05-20T02:32:39Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "2fa5a4c6-e0a7-4dbe-a80e-7770a5dc92a1",
        "tags" : [
        ]
      },
      {
        "id" : "8069a40d-00c2-4f3f-bb3d-cbcc6a58b1cb",
        "parentId" : "f165d9a9-e5d7-4a20-8424-5678f0ed4b9d",
        "authorId" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "body" : "@euank When Privileged is set, containers typically runs as `root`. \n",
        "createdAt" : "2016-05-24T17:54:15Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "tags" : [
        ]
      },
      {
        "id" : "e422d413-59de-488c-8fed-6cca069831a2",
        "parentId" : "f165d9a9-e5d7-4a20-8424-5678f0ed4b9d",
        "authorId" : "2fa5a4c6-e0a7-4dbe-a80e-7770a5dc92a1",
        "body" : "I know in the docker world privileged and user are not related (e.g. `docker run --privileged jenkins whoami # outputs jenkins`)... it adds capabilities which are basically what root on the host has is perhaps what you mean... but again, can't that just be `AddCapabilities(allCapabilities)`?\n\nI don't think runc nor rkt have an exact analogue to `privileged`, but both have capabilities.\n\nSame questions as before, what does it mean, isn't it redundant, what does it mean otherwise?\n",
        "createdAt" : "2016-05-24T18:46:27Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "2fa5a4c6-e0a7-4dbe-a80e-7770a5dc92a1",
        "tags" : [
        ]
      },
      {
        "id" : "5c39df4f-4ceb-4d89-bc5f-55b5a2fa2b02",
        "parentId" : "f165d9a9-e5d7-4a20-8424-5678f0ed4b9d",
        "authorId" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "body" : "AFAIK, `Privileged` is not related just to `Capabilities`. I'd expect it to disable SELinux, AppArmor, Seccomp, etc. as well..\n",
        "createdAt" : "2016-05-24T19:23:53Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "tags" : [
        ]
      },
      {
        "id" : "db0f05be-e32e-4172-bd0f-b7318ca8ceb5",
        "parentId" : "f165d9a9-e5d7-4a20-8424-5678f0ed4b9d",
        "authorId" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "body" : "@euank The concept of privileged can definitely be expressed using underlying knobs too. It is a fair argument. We can have kubelet dictate what `Privileged` translated to in terms of specific OS features.\n",
        "createdAt" : "2016-05-24T19:25:14Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "tags" : [
        ]
      },
      {
        "id" : "9d217dfe-3bdb-495c-b78b-b323d9f64558",
        "parentId" : "f165d9a9-e5d7-4a20-8424-5678f0ed4b9d",
        "authorId" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "body" : "This field is copied directly from the [k8s api](https://github.com/kubernetes/kubernetes/blob/edda8371423db7b4991733c1fa4d6b97e3b4a6e0/pkg/api/types.go#L2783). We should clarify what `Privileged` means.\n",
        "createdAt" : "2016-05-27T19:02:19Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "tags" : [
        ]
      },
      {
        "id" : "d18c2bdc-365f-4ecc-b267-7a9529b4a77e",
        "parentId" : "f165d9a9-e5d7-4a20-8424-5678f0ed4b9d",
        "authorId" : "0adf587c-aaa2-4e47-be0f-a26d4fde14ac",
        "body" : "This API doesn't need to match the k8s API 1 to 1. I think there are several places where it makes sense to have user-facing options for common operations in k8s API, but the kubelet could translate those into the explicit options that get passed through the container runtime API. For this API, I think less overlap over options is a good thing.\n",
        "createdAt" : "2016-06-01T01:29:03Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "0adf587c-aaa2-4e47-be0f-a26d4fde14ac",
        "tags" : [
        ]
      },
      {
        "id" : "3caf492a-7c2e-4f9a-a11a-8937133df98d",
        "parentId" : "f165d9a9-e5d7-4a20-8424-5678f0ed4b9d",
        "authorId" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "body" : "True. I agree that less overlap is a good thing. In this case specifically, we also need to consider what \"privileged\" means and whether kubelet can interpret all the requirements. For example, I checked docker, besides capabilities, it does not apply the default seccomp profile, and also does not meddle with paths under /proc/ (i.e., mount it as read-only or mask it). Due to the lack of clear definition in the k8s api, and the fact that kubelet doesn't have access to some low-level configuration settings (i.e., oci) in the runtime, this may be hard to achieve(?)\n",
        "createdAt" : "2016-06-03T19:18:20Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "tags" : [
        ]
      },
      {
        "id" : "f58f0022-2f96-402b-b3ec-e5be966794f2",
        "parentId" : "f165d9a9-e5d7-4a20-8424-5678f0ed4b9d",
        "authorId" : "b56795d9-0816-4d28-b233-275e1ee4baf1",
        "body" : "The fact that this chain went on for 8 replies and we don't have a clearer definition of what this `Privileged` field means should make us consider removing it and instead specifying the fields it modifies/appends to in this spec.\n",
        "createdAt" : "2016-06-07T01:53:54Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "b56795d9-0816-4d28-b233-275e1ee4baf1",
        "tags" : [
        ]
      },
      {
        "id" : "0d725fbe-eabc-4967-b237-9a8d5470a6da",
        "parentId" : "f165d9a9-e5d7-4a20-8424-5678f0ed4b9d",
        "authorId" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "body" : "@yujuhong If we can disable any security feature that is not exposed via this API, then I think we can get rid of this `Privileged` flag. \n",
        "createdAt" : "2016-06-07T19:42:57Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "tags" : [
        ]
      }
    ],
    "commit" : "08dc66113399c89e31f6872f3c638695a6ec6a8d",
    "line" : 271,
    "diffHunk" : "@@ -1,1 +269,273 @@\tAnnotations map[string]string\n\t// Privileged runs the container in the privileged mode.\n\tPrivileged bool\n\t// ReadOnlyRootFS sets the root filesystem of the container to be\n\t// read-only."
  },
  {
    "id" : "8044220d-764c-4e3d-8bd1-9ac7acd18709",
    "prId" : 25899,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1bdd444d-0029-47b3-881c-c84f848ee011",
        "parentId" : null,
        "authorId" : "6eca0ade-9879-4dd7-ad14-547e16f5c041",
        "body" : "Any reason why the pod is not visible?\n\nUse case I am thinking about is a vendor wants to support certain cgroup extensions not enabled by the underlying container runtime possibly for performance sensitive pods.  It seems like a vendor could compile in there own special sandbox manager that introspective we data on a pod.  Are the annotations the same set as on the persisted pod or are they separate?\n",
        "createdAt" : "2016-05-25T00:13:06Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "6eca0ade-9879-4dd7-ad14-547e16f5c041",
        "tags" : [
        ]
      },
      {
        "id" : "dd292028-6739-4faa-9951-0483794b935e",
        "parentId" : "1bdd444d-0029-47b3-881c-c84f848ee011",
        "authorId" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "body" : "@derekwaynecarr This sounds like a request to make our resource manager in kubelet pluggable... \n",
        "createdAt" : "2016-05-25T18:33:33Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "tags" : [
        ]
      },
      {
        "id" : "cf32a9cb-5522-4900-86ff-ece19b6bf0a3",
        "parentId" : "1bdd444d-0029-47b3-881c-c84f848ee011",
        "authorId" : "6eca0ade-9879-4dd7-ad14-547e16f5c041",
        "body" : "@jeremyeder and I have been discussing what it takes to support performance sensitive pods, and this is more probing what my potential options would be.  One topic we discussed was plugging in alternate sandbox managers, but I needed a way to pass through some values down to the sandbox.\n",
        "createdAt" : "2016-05-25T19:21:02Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "6eca0ade-9879-4dd7-ad14-547e16f5c041",
        "tags" : [
        ]
      },
      {
        "id" : "523072ae-d797-445b-bffa-d4a9410021af",
        "parentId" : "1bdd444d-0029-47b3-881c-c84f848ee011",
        "authorId" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "body" : "@derekwaynecarr what values do you want to pass? Is it just annotations? In general, I don't think it's a good idea to pass the entire pod to the sandbox manager since we want to tell the manager what to do explicitly.\n",
        "createdAt" : "2016-05-27T18:32:55Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "tags" : [
        ]
      },
      {
        "id" : "5a1b550a-2ce9-4c37-b023-11effe5b4b95",
        "parentId" : "1bdd444d-0029-47b3-881c-c84f848ee011",
        "authorId" : "2fa5a4c6-e0a7-4dbe-a80e-7770a5dc92a1",
        "body" : "Passing the pod would also help in the hyper case of needing mounts of all containers up-front without adding a mounts field that other runtimes may not need (but rather a pod field that other runtimes may not need :)\n\nI don't see why the sandbox manager knowing what containers it's creating a sandbox for is an issue; most could ignore it, some could make some optimizations perhaps (like loading optional modules early as mentioned above, or warming the image cache in some manner).\nI understand that there's an abstraction here that we don't want to break, but I don't think this breaks the important part of the abstractions; the separation between the sandbox and containers lifecycles. \n",
        "createdAt" : "2016-06-02T20:01:13Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "2fa5a4c6-e0a7-4dbe-a80e-7770a5dc92a1",
        "tags" : [
        ]
      },
      {
        "id" : "929c6fbd-232f-4e7e-8329-f0cc910ca16f",
        "parentId" : "1bdd444d-0029-47b3-881c-c84f848ee011",
        "authorId" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "body" : "We talked to hyper folks yesterday and they were fine handling the mounts per container @feiskyer  :)\n\nWe should try not to pass additional information to the sandbox manager that can be interpreted differently. Speaking k8s api directly can also be misleading here.\n",
        "createdAt" : "2016-06-03T18:20:25Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "tags" : [
        ]
      }
    ],
    "commit" : "08dc66113399c89e31f6872f3c638695a6ec6a8d",
    "line" : 50,
    "diffHunk" : "@@ -1,1 +48,52 @@// PodSandboxConfig holds all the required and optional fields for creating a\n// sandbox.\ntype PodSandboxConfig struct {\n\t// Name is the name of the sandbox. The string should conform to\n\t// [a-zA-Z0-9_-]+."
  },
  {
    "id" : "bf106aa1-0ce0-4203-a3af-d0e274bbd1b2",
    "prId" : 25899,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "069acd7b-5c1a-4bbb-a6fe-44390db703bd",
        "parentId" : null,
        "authorId" : "6eca0ade-9879-4dd7-ad14-547e16f5c041",
        "body" : "In what format?  cgroupfs or slice?  Either?  Opaque to Kubelet?\n",
        "createdAt" : "2016-05-25T00:14:43Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "6eca0ade-9879-4dd7-ad14-547e16f5c041",
        "tags" : [
        ]
      },
      {
        "id" : "1dfc9f8e-0349-4b22-b0f8-0881dfeafae3",
        "parentId" : "069acd7b-5c1a-4bbb-a6fe-44390db703bd",
        "authorId" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "body" : "@derekwaynecarr I was thinking of `cgroupsfs` format even for systemd slices. The runtime code might have to convert that path into a systemd compatible one. \nBTW how was this addressed in docker?\n",
        "createdAt" : "2016-05-25T18:32:11Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "tags" : [
        ]
      },
      {
        "id" : "7121f539-31b4-4326-bb3e-f89f2893ad4c",
        "parentId" : "069acd7b-5c1a-4bbb-a6fe-44390db703bd",
        "authorId" : "6eca0ade-9879-4dd7-ad14-547e16f5c041",
        "body" : "@vishh - it takes the `systemd` naming convention for `.slice` when passing `-cgroup-parent`\n\nsee:\nhttps://github.com/opencontainers/runc/blob/master/libcontainer/cgroups/systemd/apply_systemd.go#L335\n\nhttps://github.com/opencontainers/runc/blob/master/libcontainer/cgroups/systemd/apply_systemd.go#L374\n\nAt this point, kubelet `cgroup-root` also was opaque, so I planned to use that to launch in `machine.slice` soon on our platforms.\n\nWe discussed a `cgroup-driver` flag for the `kubelet` per the systemd node spec, I think we should use the syntax consistent with that flag.  I am not sure I see another option.  Passing a `cgroupfs` syntax to a container runtime expecting `systemd` syntax will not work from what I can tell.\n\n@mrunalp - is there a way to detect the cgroup driver the docker daemon is using remotely?\n",
        "createdAt" : "2016-05-25T19:34:41Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "6eca0ade-9879-4dd7-ad14-547e16f5c041",
        "tags" : [
        ]
      },
      {
        "id" : "9b65c84a-8508-466d-9626-214354226096",
        "parentId" : "069acd7b-5c1a-4bbb-a6fe-44390db703bd",
        "authorId" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "body" : "@derekwaynecarr Is it OK to run systemd agnostic runtimes on a machine running systemd? I'd hope the answer is yes. Kubelet can create a slice for the pod and then let the runtime use the slice cgroups for managing containers.\n\nKubelet can accept cgroup paths based on the driver. Not doing that will definitely affect usability. \n\nWhen interacting with runtimes, can we have the kubelet use cgroupfs path and let runtimes convert to an appropriate format based on their needs?\n",
        "createdAt" : "2016-05-25T20:10:46Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "tags" : [
        ]
      },
      {
        "id" : "aeca4121-b65d-4a3a-a59c-f5b4f80c2a92",
        "parentId" : "069acd7b-5c1a-4bbb-a6fe-44390db703bd",
        "authorId" : "6eca0ade-9879-4dd7-ad14-547e16f5c041",
        "body" : "@vishh \n\n> Is it OK to run systemd agnostic runtimes on a machine running systemd?\n\nYes, of course.  I am just trying to reason through how to handle both gracefully so that a systemd aware runtime gets the input it expects.  Right now, using `cgroupfs` paths exclusively would be problematic running `docker` with `systemd` cgroup driver based on current realities which is why I inquired about ability to know what format a container runtime expects as input.\n\n> When interacting with runtimes, can we have the kubelet use cgroupfs path and let runtimes convert to an appropriate format based on their needs?\n\nWe would need to do that conversion _prior_ to invoking docker runtime based on docker 1.10 and docker 1.12+ code base, and there is no way to ask the container runtime what format it expects as input.\n\nI think it doesn't make sense to support a `--cgroup-driver=systemd` at kubelet level and use `--cgroup-driver=cgroupfs` at the container runtime level.  I think they are incompatible.  For example, it would make no sense for kubelet to create a slice for a pod, and then tell the container runtime to put the container there and have it not create a `scope`.\n\nSo from a support matrix, I think if we say that the --cgroup manager associated with the sandbox MUST match the cgroup manager associated with the runtime.\n\nWDYT?\n",
        "createdAt" : "2016-05-25T21:20:31Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "6eca0ade-9879-4dd7-ad14-547e16f5c041",
        "tags" : [
        ]
      },
      {
        "id" : "5bdd3f6d-8e12-4e35-8e28-955fc81befab",
        "parentId" : "069acd7b-5c1a-4bbb-a6fe-44390db703bd",
        "authorId" : "6eca0ade-9879-4dd7-ad14-547e16f5c041",
        "body" : "For example, if you were to create slices for pods, and used the cgroupfs driver in `docker`, it would just not work, agree?\n",
        "createdAt" : "2016-05-25T21:21:26Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "6eca0ade-9879-4dd7-ad14-547e16f5c041",
        "tags" : [
        ]
      },
      {
        "id" : "3c25c44a-ed1b-45d1-a4e8-88884886c788",
        "parentId" : "069acd7b-5c1a-4bbb-a6fe-44390db703bd",
        "authorId" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "body" : "@derekwaynecarr \n\n> So from a support matrix, I think if we say that the --cgroup manager associated with the sandbox MUST match the cgroup manager associated with the runtime.\n\nWhat if kubelet were to create slices and the runtime were to treat those slices as just regular cgroups? It might not be the recommended pattern, but technically, there is no reason to not support it right?\n\n> We would need to do that conversion prior to invoking docker runtime based on docker 1.10 and docker 1.12+ code base, and there is no way to ask the container runtime what format it expects as input.\n\nJust like how runc is doing, why can't the runtimes translate the cgroups path to a systemd compatible one if required?\n\n>  For example, it would make no sense for kubelet to create a slice for a pod, and then tell the container runtime to put the container there and have it not create a scope\n\nWhy? It is technically possible to create cgroups manually under slices right? Unless one wants systemd to manage all containers, it doesn't really matter if we create a scope or cgroups directly.\n",
        "createdAt" : "2016-05-25T21:38:00Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "tags" : [
        ]
      },
      {
        "id" : "c07db826-346d-42a8-8cfa-7e4be99a2eca",
        "parentId" : "069acd7b-5c1a-4bbb-a6fe-44390db703bd",
        "authorId" : "6eca0ade-9879-4dd7-ad14-547e16f5c041",
        "body" : "@vishh - this is complicated, and I want to clarify a few things.\n1. ability to manage usage per qos-tier (not covered in this spec, but stating for awareness)\n2. ability to manage usage per pod\n3. ability to manage usage per container\n\nThe first thing we should clarify is who creates the `cgroups` associated with 2 and 3.\n- Does the pod sandbox manager create both?  \n- Or does it just create 2 and it delegates to the runtime to create 3 as a child?\n\nLet's assume its the latter, and evaluate two runtime options: `docker` and `runc`.\n\nIf `kubelet` ran with `--cgroup-driver=systemd`, and user creates `podA` with container B and C:\n- pod sandbox manager creates a `podA.slice`\n- instructs container runtime to create container B and C\n  - docker with `--exec-opt native.cgroupdriver=systemd`, the runtime _requires_ systemd style cgroup name\n  - docker with `--exec-opt native.cgroupdriver=cgroupfs`, the runtime will expect a cgroupfs style cgroup name, if we wanted to pass a cgroupfs syntax of the slice, then `podA.slice` would have had to set `Delegate=yes`\n  - `runc --systemd-cgroup start` would need to covert the name `podA.slice:runc:containerId`\n  - `runc` without that global option would need `Delegate=yes` on the `podA.slice`\n\nIn the `runc` case, I suspect we would always pass the `--systemd-cgroup` option if the `kubelet` was launched with `--cgroup-driver=systemd`.\n\nI suspect with `rkt` they will want the `slice` name in `systemd` format to launch but maybe @jonboulle can weigh in.\n\nSummary:\n- How the kubelet creates the slice is dependent upon the container runtime configuration for how to set `Delegate`.\n- How the runtime is configured has an impact on how the path is expected to be passed.\n\n@mrunalp - fyi per discussion on having a way to introspect cgroup driver for docker so we can know the expected input format.\n",
        "createdAt" : "2016-05-27T21:28:32Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "6eca0ade-9879-4dd7-ad14-547e16f5c041",
        "tags" : [
        ]
      },
      {
        "id" : "8ae23c9c-cbd9-4054-ab50-90e2dd66590e",
        "parentId" : "069acd7b-5c1a-4bbb-a6fe-44390db703bd",
        "authorId" : "6eca0ade-9879-4dd7-ad14-547e16f5c041",
        "body" : "@vishh @mrunalp and myself met today, and I agree that the this can be the cgroupfs style syntax everywhere, and the container runtime implementation can convert to systemd semantics where needed by a particular runtime daemon.\n",
        "createdAt" : "2016-06-02T21:17:17Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "6eca0ade-9879-4dd7-ad14-547e16f5c041",
        "tags" : [
        ]
      }
    ],
    "commit" : "08dc66113399c89e31f6872f3c638695a6ec6a8d",
    "line" : null,
    "diffHunk" : "@@ -1,1 +107,111 @@\t// syntax will be used, but the container runtime can convert it to systemd\n\t// semantices if needed.\n\tCgroupParent string\n\t// NamespaceOptions contains configurations for the sandbox's namespaces.\n\t// This will be used only if the PodSandbox uses namespace for isolation."
  },
  {
    "id" : "9dc64219-8d1b-4a2c-aeec-1d85ab1dfe13",
    "prId" : 25899,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9be68f1c-64ba-44f6-832a-6ce4b9639746",
        "parentId" : null,
        "authorId" : "2fa5a4c6-e0a7-4dbe-a80e-7770a5dc92a1",
        "body" : "Is there a reason to have both annotations and labels? Could labels just be annotations under some namespace the kubelet agrees is used for these purposes?\n",
        "createdAt" : "2016-05-26T21:59:50Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "2fa5a4c6-e0a7-4dbe-a80e-7770a5dc92a1",
        "tags" : [
        ]
      },
      {
        "id" : "c5cbcb51-43f8-43fb-a25a-3f956c09808d",
        "parentId" : "9be68f1c-64ba-44f6-832a-6ce4b9639746",
        "authorId" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "body" : "Labels are meant for grouping whereas annotations are meant to pass\narbitrary information around.\n\nOn Thu, May 26, 2016 at 3:00 PM, Euan Kemp notifications@github.com wrote:\n\n> In pkg/kubelet/container/interface.go\n> https://github.com/kubernetes/kubernetes/pull/25899#discussion_r64828709\n> :\n> \n> > -   Hostname string\n> > -   // DNSOptions sets the DNS options for the sandbox.\n> > -   DNSOptions DNSOptions\n> > -   // PortMappings lists the port mappings for the sandbox.\n> > -   PortMappings []PortMapping\n> > -   // Mounts lists the mounts to be added to the sandbox's filesystem.\n> > -   Mounts []Mount\n> > -   // Resources specifies the resource requirements for the sandbox.\n> > -   // Note: On a Linux host, kubelet will create a pod-level cgroup and pass\n> > -   // it as the cgroup parent for the PodSandbox. For some runtimes, this is\n> > -   // sufficent to fulfill pod-level resource requirements, and this field\n> > -   // will not be used. For others, e.g., hypervisor-based runtimes, explicit\n> > -   // resource requirements for the sandbox are needed at creation time.\n> > -   Resources PodSandboxResources\n> > -   // Labels are key value pairs that may be used to scope and select individual resources.\n> > -   Labels Labels\n> \n> Is there a reason to have both annotations and labels? Could labels just\n> be annotations under some namespace the kubelet agrees is used for these\n> purposes?\n> \n> —\n> You are receiving this because you were mentioned.\n> Reply to this email directly or view it on GitHub\n> https://github.com/kubernetes/kubernetes/pull/25899/files/7674a3563e076840baf54e0ef6d24dd7b0c916b0#r64828709\n",
        "createdAt" : "2016-05-26T22:04:08Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "tags" : [
        ]
      },
      {
        "id" : "7b0ad80d-684e-4748-961f-a1f6cdb49065",
        "parentId" : "9be68f1c-64ba-44f6-832a-6ce4b9639746",
        "authorId" : "2fa5a4c6-e0a7-4dbe-a80e-7770a5dc92a1",
        "body" : "That doesn't answer why labels can't or shouldn't just be a specialization of annotations (e.g. `io.kuberentes.label/foo=bar`) which is interpreted further\n",
        "createdAt" : "2016-05-26T22:14:54Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "2fa5a4c6-e0a7-4dbe-a80e-7770a5dc92a1",
        "tags" : [
        ]
      },
      {
        "id" : "d2a3607f-49aa-4c35-9b64-022f3cc60ee7",
        "parentId" : "9be68f1c-64ba-44f6-832a-6ce4b9639746",
        "authorId" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "body" : "Labels have to adhere to a standard schema. Applying such schema to\nspecific annotations keys or expecting runtimes to support grouping on\nspecial annotation keys sounds a bit weird.\n\nOn Thu, May 26, 2016 at 3:15 PM, Euan Kemp notifications@github.com wrote:\n\n> In pkg/kubelet/container/interface.go\n> https://github.com/kubernetes/kubernetes/pull/25899#discussion_r64830621\n> :\n> \n> > -   Hostname string\n> > -   // DNSOptions sets the DNS options for the sandbox.\n> > -   DNSOptions DNSOptions\n> > -   // PortMappings lists the port mappings for the sandbox.\n> > -   PortMappings []PortMapping\n> > -   // Mounts lists the mounts to be added to the sandbox's filesystem.\n> > -   Mounts []Mount\n> > -   // Resources specifies the resource requirements for the sandbox.\n> > -   // Note: On a Linux host, kubelet will create a pod-level cgroup and pass\n> > -   // it as the cgroup parent for the PodSandbox. For some runtimes, this is\n> > -   // sufficent to fulfill pod-level resource requirements, and this field\n> > -   // will not be used. For others, e.g., hypervisor-based runtimes, explicit\n> > -   // resource requirements for the sandbox are needed at creation time.\n> > -   Resources PodSandboxResources\n> > -   // Labels are key value pairs that may be used to scope and select individual resources.\n> > -   Labels Labels\n> \n> That doesn't answer why labels can't or shouldn't just be a specialization\n> of annotations (e.g. io.kuberentes.label/foo=bar) which is interpreted\n> further\n> \n> —\n> You are receiving this because you were mentioned.\n> Reply to this email directly or view it on GitHub\n> https://github.com/kubernetes/kubernetes/pull/25899/files/7674a3563e076840baf54e0ef6d24dd7b0c916b0#r64830621\n",
        "createdAt" : "2016-05-26T22:20:43Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "tags" : [
        ]
      }
    ],
    "commit" : "08dc66113399c89e31f6872f3c638695a6ec6a8d",
    "line" : null,
    "diffHunk" : "@@ -1,1 +83,87 @@\t// Labels are key value pairs that may be used to scope and select\n\t// individual resources.\n\tLabels Labels\n\t// Annotations is an unstructured key value map that may be set by external\n\t// tools to store and retrieve arbitrary metadata."
  },
  {
    "id" : "6d056ecb-eaab-452e-839a-3fe990fc190e",
    "prId" : 25899,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "eb886279-95da-458a-9213-0e589ac9e1de",
        "parentId" : null,
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "Following the sysctl proposal https://github.com/kubernetes/kubernetes/pull/26057 we would need in addition:\n\n``` go\n// Sysctl defines a kernel parameter to be set\ntype Sysctl struct {\n    // Name of a property to set\n    Name string `json:\"name\"`\n    // Value of a property to set\n    Value string `json:\"value\"`\n}\n\ntype LinuxPodSandboxConfig struct {\n    // Sysctls hold a list of namespaced sysctls used for the pod. They are only allowed\n    // if the respective host namespace setting pod.spec.hostIPC or pod.spec.hostNetwork\n    // are false.\n    Sysctls []Sysctl\n}\n```\n\nMaybe, alternatively just:\n\n``` go\nSysCtls map[string]string\n```\n",
        "createdAt" : "2016-05-27T07:37:21Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      },
      {
        "id" : "252aaac0-207f-46c1-a1d2-90bb30a91d91",
        "parentId" : "eb886279-95da-458a-9213-0e589ac9e1de",
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "Compare OCI spec: https://github.com/opencontainers/runtime-spec/blob/master/specs-go/config.go#L123\n",
        "createdAt" : "2016-05-27T07:38:19Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      },
      {
        "id" : "7e4d209d-426e-4733-8dbc-ffc1ff823e83",
        "parentId" : "eb886279-95da-458a-9213-0e589ac9e1de",
        "authorId" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "body" : "I'm fine with supporting sysctl. Since the sysctl proposal is still WIP, we can wait until it's finalized and then extend the sandbox/runtime api.\n",
        "createdAt" : "2016-05-27T19:40:20Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "tags" : [
        ]
      }
    ],
    "commit" : "08dc66113399c89e31f6872f3c638695a6ec6a8d",
    "line" : 105,
    "diffHunk" : "@@ -1,1 +103,107 @@// LinuxPodSandboxConfig holds platform-specific configuraions for Linux\n// host platforms and Linux-based containers.\ntype LinuxPodSandboxConfig struct {\n\t// CgroupParent is the parent cgroup of the sandbox. The cgroupfs style\n\t// syntax will be used, but the container runtime can convert it to systemd"
  },
  {
    "id" : "5581b9e6-e817-41b2-9676-c51b3f931e8d",
    "prId" : 25899,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "eb883645-5717-4f68-85df-21df5cc5341a",
        "parentId" : null,
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "Why no `map[string]string`?\n",
        "createdAt" : "2016-05-27T07:40:36Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      },
      {
        "id" : "5c17b798-b25d-42bb-b318-f46da0d37dd4",
        "parentId" : "eb883645-5717-4f68-85df-21df5cc5341a",
        "authorId" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "body" : "List retains the order during serialization \n",
        "createdAt" : "2016-05-27T19:38:29Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "tags" : [
        ]
      },
      {
        "id" : "6eeb012d-b886-4b70-a12e-c88d0b48946c",
        "parentId" : "eb883645-5717-4f68-85df-21df5cc5341a",
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "Maybe naive question: why do we need that here? Because it's easier to compare?\n",
        "createdAt" : "2016-05-30T05:19:01Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      },
      {
        "id" : "8a219ea2-dccd-4d63-9c5f-2c25e4e0d4c1",
        "parentId" : "eb883645-5717-4f68-85df-21df5cc5341a",
        "authorId" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "body" : "@sttts I am not sure if I understand your question. k8s allows user to specify environment variables for their containers, so it needs to inject them into the container.\n",
        "createdAt" : "2016-06-01T00:04:57Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "tags" : [
        ]
      },
      {
        "id" : "8f47c447-fe65-44f3-835d-64aae0e91e53",
        "parentId" : "eb883645-5717-4f68-85df-21df5cc5341a",
        "authorId" : "2fa5a4c6-e0a7-4dbe-a80e-7770a5dc92a1",
        "body" : "Why does it matter that order is retained? Why does it need to be a list instead of a map? Couldn't whatever creates the map apply any needed precedence / order rules?\n",
        "createdAt" : "2016-06-01T00:08:42Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "2fa5a4c6-e0a7-4dbe-a80e-7770a5dc92a1",
        "tags" : [
        ]
      },
      {
        "id" : "f9dcf698-2eb2-4730-ace2-6c2f2f5a2687",
        "parentId" : "eb883645-5717-4f68-85df-21df5cc5341a",
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "@yujuhong my question was about the order, why we need one.\n",
        "createdAt" : "2016-06-01T06:21:32Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      },
      {
        "id" : "bd6e58e8-2c37-4c8b-bb51-c39bea713b9e",
        "parentId" : "eb883645-5717-4f68-85df-21df5cc5341a",
        "authorId" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "body" : "kubelet does expand environment variables when it can, but keeping the ordering seems like a good practice anyway. \n",
        "createdAt" : "2016-06-02T00:42:03Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "tags" : [
        ]
      },
      {
        "id" : "1c1a7422-c486-498d-b09e-c37d207666f8",
        "parentId" : "eb883645-5717-4f68-85df-21df5cc5341a",
        "authorId" : "227eb550-8b08-4420-9a78-279f840bd8de",
        "body" : "+1 on maps, same for the client / server interface. @feiskyer \n",
        "createdAt" : "2016-06-29T23:13:24Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "227eb550-8b08-4420-9a78-279f840bd8de",
        "tags" : [
        ]
      },
      {
        "id" : "bf9dd5fa-8ecc-4b0a-9ed8-0967ed7d6097",
        "parentId" : "eb883645-5717-4f68-85df-21df5cc5341a",
        "authorId" : "0d2d9977-2328-4ade-b6a6-ba60c2dd5bd5",
        "body" : "I'd be in favor or using a map to be consistent with the client/server proposal, or maybe change that one too?\n",
        "createdAt" : "2016-06-30T12:30:45Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "0d2d9977-2328-4ade-b6a6-ba60c2dd5bd5",
        "tags" : [
        ]
      }
    ],
    "commit" : "08dc66113399c89e31f6872f3c638695a6ec6a8d",
    "line" : 262,
    "diffHunk" : "@@ -1,1 +260,264 @@\tWorkingDir string\n\t// List of environment variable to set in the container\n\tEnv []KeyValue\n\t// Mounts specifies mounts for the container\n\tMounts []Mount"
  },
  {
    "id" : "d1d49d18-0ced-4414-9384-709a7bc5926c",
    "prId" : 25899,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "69bcc809-2b78-4f59-ad73-de8c0550cffb",
        "parentId" : null,
        "authorId" : "2fa5a4c6-e0a7-4dbe-a80e-7770a5dc92a1",
        "body" : "Why should the sandbox have a hostname? Shouldn't each container have a hostname? I know that right now each container has the same hostname (and it matches the pod name), but even for that instance it seems like the container configuration is the place where that would fit.\n",
        "createdAt" : "2016-05-31T23:23:28Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "2fa5a4c6-e0a7-4dbe-a80e-7770a5dc92a1",
        "tags" : [
        ]
      },
      {
        "id" : "86953c97-5b8f-4caa-aac5-12aff15b91bd",
        "parentId" : "69bcc809-2b78-4f59-ad73-de8c0550cffb",
        "authorId" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "body" : "Containers in a pod share the same hostname (and hopefully the same UTS namespace in the future #1615). Given that hostname is not a per-container setting, it makes sense for the hostname to be at the sandbox level.\n",
        "createdAt" : "2016-05-31T23:45:41Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "tags" : [
        ]
      },
      {
        "id" : "46cc44a4-63dc-428a-a6ed-73a6bebd5884",
        "parentId" : "69bcc809-2b78-4f59-ad73-de8c0550cffb",
        "authorId" : "2fa5a4c6-e0a7-4dbe-a80e-7770a5dc92a1",
        "body" : "Silly question, oops. Thanks for answering and the link.\n",
        "createdAt" : "2016-06-01T00:09:35Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "2fa5a4c6-e0a7-4dbe-a80e-7770a5dc92a1",
        "tags" : [
        ]
      }
    ],
    "commit" : "08dc66113399c89e31f6872f3c638695a6ec6a8d",
    "line" : null,
    "diffHunk" : "@@ -1,1 +53,57 @@\tName string\n\t// Hostname is the hostname of the sandbox.\n\tHostname string\n\t// DNSOptions sets the DNS options for the sandbox.\n\tDNSOptions DNSOptions"
  },
  {
    "id" : "9d898aed-11e8-41b4-b124-c4db9e3289d9",
    "prId" : 25899,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f8caa97d-4431-4b4f-81fa-fa982d2884fa",
        "parentId" : null,
        "authorId" : "0adf587c-aaa2-4e47-be0f-a26d4fde14ac",
        "body" : "What does a resource request mean in this context? Limit is clear enough.\n",
        "createdAt" : "2016-06-01T01:01:06Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "0adf587c-aaa2-4e47-be0f-a26d4fde14ac",
        "tags" : [
        ]
      },
      {
        "id" : "eb395a04-8e8b-43d3-a99e-2ccb121cddbc",
        "parentId" : "f8caa97d-4431-4b4f-81fa-fa982d2884fa",
        "authorId" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "body" : "This should be the resource request of the sandbox in the case of VMs. How kubelet translates the container resource requests/limits to the sandbox resource is debatable. /cc @vishh \n",
        "createdAt" : "2016-06-02T00:01:59Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "tags" : [
        ]
      },
      {
        "id" : "570697a1-7ece-47d9-8474-111c1c372382",
        "parentId" : "f8caa97d-4431-4b4f-81fa-fa982d2884fa",
        "authorId" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "body" : "Spoke with hyper and @vishh, this will be the resource limits of all containers in the pod.\n",
        "createdAt" : "2016-06-03T18:23:38Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "tags" : [
        ]
      }
    ],
    "commit" : "08dc66113399c89e31f6872f3c638695a6ec6a8d",
    "line" : null,
    "diffHunk" : "@@ -1,1 +64,68 @@\t// sufficent. For others, e.g., hypervisor-based runtimes, explicit\n\t// resource limits for the sandbox are needed at creation time.\n\tResources PodSandboxResources\n\t// Path to the directory on the host in which container log files are\n\t// stored."
  },
  {
    "id" : "3d39a77b-c3a0-482d-ac2a-df40289610bc",
    "prId" : 25899,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6b6bfc68-bcf6-4335-ab25-d187a29d99e4",
        "parentId" : null,
        "authorId" : "0adf587c-aaa2-4e47-be0f-a26d4fde14ac",
        "body" : "Is this synchronous or asynchronous? In other words, would a timeout return a timeout error?\n",
        "createdAt" : "2016-06-01T01:14:19Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "0adf587c-aaa2-4e47-be0f-a26d4fde14ac",
        "tags" : [
        ]
      },
      {
        "id" : "44a635bc-5396-43b4-96e3-4f1e0cee4e32",
        "parentId" : "6b6bfc68-bcf6-4335-ab25-d187a29d99e4",
        "authorId" : "0adf587c-aaa2-4e47-be0f-a26d4fde14ac",
        "body" : "Same question applies to all other operations.\n",
        "createdAt" : "2016-06-01T01:14:31Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "0adf587c-aaa2-4e47-be0f-a26d4fde14ac",
        "tags" : [
        ]
      },
      {
        "id" : "36aba10a-8707-4d2a-8395-5a3c91bd5995",
        "parentId" : "6b6bfc68-bcf6-4335-ab25-d187a29d99e4",
        "authorId" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "body" : "It's mentioned in the proposal that these are synchronous calls. I'll repeat it in the interface as well.\n",
        "createdAt" : "2016-06-01T22:57:54Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "tags" : [
        ]
      }
    ],
    "commit" : "08dc66113399c89e31f6872f3c638695a6ec6a8d",
    "line" : 219,
    "diffHunk" : "@@ -1,1 +217,221 @@\tStart(id RawContainerID) error\n\t// Stop stops a running container with a grace period (i.e., timeout).\n\tStop(id RawContainerID, timeout int) error\n\t// Remove removes the container.\n\tRemove(id RawContainerID) error"
  },
  {
    "id" : "cb1d01b4-9bdc-406b-a216-1a57ab4b24d1",
    "prId" : 25899,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "30b1c2d9-8213-491a-b1e0-ec0cb8a6d9bb",
        "parentId" : null,
        "authorId" : "0adf587c-aaa2-4e47-be0f-a26d4fde14ac",
        "body" : "Are the pointer types just for efficiency? If so, are they expected to be read-only (or, for example, would the runtime fill in optional values)?\n",
        "createdAt" : "2016-06-01T01:17:18Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "0adf587c-aaa2-4e47-be0f-a26d4fde14ac",
        "tags" : [
        ]
      },
      {
        "id" : "41adc182-7d51-48a9-83a5-bcfa1e3e843a",
        "parentId" : "30b1c2d9-8213-491a-b1e0-ec0cb8a6d9bb",
        "authorId" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "body" : "Yes, just for efficiency. It's expected to be read-only, but this only matters to the non-remote implementation\n",
        "createdAt" : "2016-06-01T22:59:48Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "tags" : [
        ]
      }
    ],
    "commit" : "08dc66113399c89e31f6872f3c638695a6ec6a8d",
    "line" : null,
    "diffHunk" : "@@ -1,1 +213,217 @@\t// Create creates a container in the sandbox, and returns the ID\n\t// of the created container.\n\tCreate(config *ContainerConfig, sandboxConfig *PodSandboxConfig, sandboxID PodSandboxID) (RawContainerID, error)\n\t// Start starts a created container.\n\tStart(id RawContainerID) error"
  },
  {
    "id" : "8c1ff3cd-3266-45fc-a16d-01b2c9c0694c",
    "prId" : 25899,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a70d8f08-29ea-4cb3-8a40-a309ed3c464e",
        "parentId" : null,
        "authorId" : "0adf587c-aaa2-4e47-be0f-a26d4fde14ac",
        "body" : "Would it make sense to include containers running in the PodSandbox here?\n",
        "createdAt" : "2016-06-01T01:18:47Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "0adf587c-aaa2-4e47-be0f-a26d4fde14ac",
        "tags" : [
        ]
      },
      {
        "id" : "02bd97fd-4289-44ef-a4d1-8335bc84b1fb",
        "parentId" : "a70d8f08-29ea-4cb3-8a40-a309ed3c464e",
        "authorId" : "0df1da34-610c-4ce5-b0cf-bbda668bf9c1",
        "body" : "Agree. Including containers will avoid calling `containerStatus` for each container belonging to this Sandbox.\n",
        "createdAt" : "2016-06-01T08:46:58Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "0df1da34-610c-4ce5-b0cf-bbda668bf9c1",
        "tags" : [
        ]
      },
      {
        "id" : "3a7e8a84-a1ee-4e07-b6eb-b01e3ca9f96a",
        "parentId" : "a70d8f08-29ea-4cb3-8a40-a309ed3c464e",
        "authorId" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "body" : "I feel like that this ties the sandbox status to the containers unnecessarily. I'd rather keep them separate.\n",
        "createdAt" : "2016-06-01T23:05:03Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "tags" : [
        ]
      },
      {
        "id" : "efcf8e8b-1759-4297-82c6-56c7bd25a47c",
        "parentId" : "a70d8f08-29ea-4cb3-8a40-a309ed3c464e",
        "authorId" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "body" : "@feiskyer, this may be good for pod-based runtimes such as hyper, but it's not the case for other runtimes. Having them separately simplifies the code in kubelet.\n",
        "createdAt" : "2016-06-03T18:29:20Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "tags" : [
        ]
      }
    ],
    "commit" : "08dc66113399c89e31f6872f3c638695a6ec6a8d",
    "line" : null,
    "diffHunk" : "@@ -1,1 +176,180 @@\t// Annotations is an unstructured key value map.\n\tAnnotations map[string]string\n}\n\n// PodSandboxNetworkStatus is the status of the network for a PodSandbox."
  },
  {
    "id" : "e9a38f47-5a28-4906-af00-c9fe96459b8a",
    "prId" : 25899,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ba1b6578-eb23-4f6d-9483-fc9647c6fe94",
        "parentId" : null,
        "authorId" : "0adf587c-aaa2-4e47-be0f-a26d4fde14ac",
        "body" : "Maybe add an optional `PodSandboxId`?\n",
        "createdAt" : "2016-06-01T01:19:37Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "0adf587c-aaa2-4e47-be0f-a26d4fde14ac",
        "tags" : [
        ]
      },
      {
        "id" : "4fa7a6e1-e762-4bff-abd4-aed233f939d3",
        "parentId" : "ba1b6578-eb23-4f6d-9483-fc9647c6fe94",
        "authorId" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "body" : "Answered before but here it is: I was thinking that we could just use the LabelSelector to filter containers belonging to the same sandbox. This makes it easier for runtimes that don't implement a sandbox natively. However, since this draws questions repeatedly, I'll just add one.\n",
        "createdAt" : "2016-06-01T23:12:05Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "tags" : [
        ]
      }
    ],
    "commit" : "08dc66113399c89e31f6872f3c638695a6ec6a8d",
    "line" : null,
    "diffHunk" : "@@ -1,1 +366,370 @@\t// Only api.MatchLabels is supported for now and the requirements\n\t// are ANDed. MatchExpressions is not supported yet.\n\tLabelSelector unversioned.LabelSelector\n}\n"
  },
  {
    "id" : "3789408a-d0d0-4a50-9bd9-c82aebc6dd50",
    "prId" : 25899,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "51e45c97-ab46-4fc3-a7f1-4d0ef6f9c4bc",
        "parentId" : null,
        "authorId" : "0adf587c-aaa2-4e47-be0f-a26d4fde14ac",
        "body" : "Why do we need `Command` and `Args` here? Alternatively, why does `Command` need to be a slice if we also have `Args`?\n",
        "createdAt" : "2016-06-01T01:21:22Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "0adf587c-aaa2-4e47-be0f-a26d4fde14ac",
        "tags" : [
        ]
      },
      {
        "id" : "394b7c54-574d-4bf0-b2d2-59bb1402df7b",
        "parentId" : "51e45c97-ab46-4fc3-a7f1-4d0ef6f9c4bc",
        "authorId" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "body" : "Docker needs to distinguish `entrypoint` and `command`, which we are overriding separately with `command` and `args`. This is also how we express them in the k8s api. \n",
        "createdAt" : "2016-06-01T23:14:55Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "tags" : [
        ]
      }
    ],
    "commit" : "08dc66113399c89e31f6872f3c638695a6ec6a8d",
    "line" : 258,
    "diffHunk" : "@@ -1,1 +256,260 @@\tCommand []string\n\t// Args for the Command (i.e., command for docker)\n\tArgs []string\n\t// Current working directory of the command.\n\tWorkingDir string"
  },
  {
    "id" : "81281f20-69bc-44ef-868b-ed8ed4d2ffcb",
    "prId" : 25899,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b0f62e34-7d08-45ee-a4cf-8d3d2e219e18",
        "parentId" : null,
        "authorId" : "0adf587c-aaa2-4e47-be0f-a26d4fde14ac",
        "body" : "Are these fields optional? If so, do you need to distinguish the zero value from unset? If so, they should be pointers.\n",
        "createdAt" : "2016-06-01T01:35:02Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "0adf587c-aaa2-4e47-be0f-a26d4fde14ac",
        "tags" : [
        ]
      },
      {
        "id" : "2a6aec31-df01-4ee3-947e-1f894a9ff7ed",
        "parentId" : "b0f62e34-7d08-45ee-a4cf-8d3d2e219e18",
        "authorId" : "0df1da34-610c-4ce5-b0cf-bbda668bf9c1",
        "body" : "Yes, we should distinguish those cases. Check https://github.com/kubernetes/kubernetes/pull/17048 for required and optional options for more clear.\n",
        "createdAt" : "2016-06-01T08:41:00Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "0df1da34-610c-4ce5-b0cf-bbda668bf9c1",
        "tags" : [
        ]
      },
      {
        "id" : "44007ed5-5b1c-40f9-995a-08f0a2bde58a",
        "parentId" : "b0f62e34-7d08-45ee-a4cf-8d3d2e219e18",
        "authorId" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "body" : "yes. changing them to pointers.\n",
        "createdAt" : "2016-06-01T23:23:41Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "tags" : [
        ]
      },
      {
        "id" : "605d1214-97f3-42a3-a5ef-01a7f9fcbb2c",
        "parentId" : "b0f62e34-7d08-45ee-a4cf-8d3d2e219e18",
        "authorId" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "body" : "As for `required` and `optional` in protobuf, the [warning in the guide](https://developers.google.com/protocol-buffers/docs/proto#specifying-field-rules) makes me think that we should be more careful.\n",
        "createdAt" : "2016-06-06T22:14:03Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "tags" : [
        ]
      }
    ],
    "commit" : "08dc66113399c89e31f6872f3c638695a6ec6a8d",
    "line" : 342,
    "diffHunk" : "@@ -1,1 +340,344 @@// TODO: Consider using Resources from opencontainers/runtime-spec/specs-go\n// directly.\ntype LinuxContainerResources struct {\n\t// CPU CFS (Completely Fair Scheduler) period\n\tCPUPeriod *int64"
  },
  {
    "id" : "a0e77006-ed20-4b55-8f19-a8040400245b",
    "prId" : 25899,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bc3de48a-b306-4a12-a45f-ffea64d51d85",
        "parentId" : null,
        "authorId" : "0adf587c-aaa2-4e47-be0f-a26d4fde14ac",
        "body" : "nit: Container and Pod interfaces take an ID where additional information is not needed.\n",
        "createdAt" : "2016-06-01T01:41:18Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "0adf587c-aaa2-4e47-be0f-a26d4fde14ac",
        "tags" : [
        ]
      },
      {
        "id" : "4aacdb28-1f53-40a8-b27f-d41f66716a5b",
        "parentId" : "bc3de48a-b306-4a12-a45f-ffea64d51d85",
        "authorId" : "0df1da34-610c-4ce5-b0cf-bbda668bf9c1",
        "body" : "Image apis take an ImageSpec (instead of image id) because it is more easier to take in new image formats.\n",
        "createdAt" : "2016-06-01T08:38:43Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "0df1da34-610c-4ce5-b0cf-bbda668bf9c1",
        "tags" : [
        ]
      },
      {
        "id" : "1b6516d6-8deb-48d4-be0f-282603ee6cdf",
        "parentId" : "bc3de48a-b306-4a12-a45f-ffea64d51d85",
        "authorId" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "body" : "Yes, we settle for ImageSpec now for extensibility.\n",
        "createdAt" : "2016-06-01T23:27:45Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "tags" : [
        ]
      }
    ],
    "commit" : "08dc66113399c89e31f6872f3c638695a6ec6a8d",
    "line" : null,
    "diffHunk" : "@@ -1,1 +391,395 @@\tPull(image ImageSpec, auth AuthConfig, sandboxConfig *PodSandboxConfig) error\n\t// Remove removes an image.\n\tRemove(image ImageSpec) error\n\t// Status returns the status of an image.\n\tStatus(image ImageSpec) (Image, error)"
  },
  {
    "id" : "a04a020a-4d77-4336-bf65-62dd1e00725c",
    "prId" : 25899,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d43bdaf3-ec14-4354-b29a-35d37fc5a569",
        "parentId" : null,
        "authorId" : "0adf587c-aaa2-4e47-be0f-a26d4fde14ac",
        "body" : "I believe we currently use ImagePullSecrets, a `[]api.Secret`. Would that make more sense or generalize better here?\n",
        "createdAt" : "2016-06-01T01:46:32Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "0adf587c-aaa2-4e47-be0f-a26d4fde14ac",
        "tags" : [
        ]
      },
      {
        "id" : "4423498b-e66a-4d49-8129-3af141844854",
        "parentId" : "d43bdaf3-ec14-4354-b29a-35d37fc5a569",
        "authorId" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "body" : "Answered before. kubelet [does a bunch of things with the secret](https://github.com/kubernetes/kubernetes/blob/7796b619fdfd4e492616346cd61913ff1173b248/pkg/kubelet/dockertools/docker.go#L167) (rkt does the same). The remote runtime may not have the knowledge\n",
        "createdAt" : "2016-06-01T23:30:47Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "tags" : [
        ]
      }
    ],
    "commit" : "08dc66113399c89e31f6872f3c638695a6ec6a8d",
    "line" : 400,
    "diffHunk" : "@@ -1,1 +398,402 @@// AuthConfig contains authorization information for connecting to a registry.\n// TODO: This is copied from docker's Authconfig. We should re-evaluate to\n// support other registries.\ntype AuthConfig struct {\n\tUsername      string"
  },
  {
    "id" : "73fafcc2-e590-41c7-a9a7-733e2c39c192",
    "prId" : 25899,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "20ce79f9-aa22-4b07-b7b0-859d0d514b9b",
        "parentId" : null,
        "authorId" : "0adf587c-aaa2-4e47-be0f-a26d4fde14ac",
        "body" : "Are there any expectations around how the runtime treats the name?\n",
        "createdAt" : "2016-06-01T01:56:13Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "0adf587c-aaa2-4e47-be0f-a26d4fde14ac",
        "tags" : [
        ]
      },
      {
        "id" : "c0df2a79-271b-4b4e-9df3-ae08ceee1b66",
        "parentId" : "20ce79f9-aa22-4b07-b7b0-859d0d514b9b",
        "authorId" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "body" : "good question. add the format `a-zA-Z0-9_-`\n",
        "createdAt" : "2016-06-01T23:36:28Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "tags" : [
        ]
      }
    ],
    "commit" : "08dc66113399c89e31f6872f3c638695a6ec6a8d",
    "line" : null,
    "diffHunk" : "@@ -1,1 +250,254 @@type ContainerConfig struct {\n\t// Name of the container. The string should conform to [a-zA-Z0-9_-]+.\n\tName string\n\t// Image to use.\n\tImage ImageSpec"
  },
  {
    "id" : "0e5da3c3-0a85-4c03-8835-0834b16dd2db",
    "prId" : 25899,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "391c8bcf-22fb-4c9b-b5a1-726cfc2420cc",
        "parentId" : null,
        "authorId" : "0adf587c-aaa2-4e47-be0f-a26d4fde14ac",
        "body" : "Where do these come from? Are these just a copy of the PodSandbox annotations?\n",
        "createdAt" : "2016-06-01T01:58:44Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "0adf587c-aaa2-4e47-be0f-a26d4fde14ac",
        "tags" : [
        ]
      },
      {
        "id" : "40081122-f843-4f0f-9367-49d1fcb3e5a9",
        "parentId" : "391c8bcf-22fb-4c9b-b5a1-726cfc2420cc",
        "authorId" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "body" : "Yeah. We have annotations that are handled by the runtime now and kubelet will have to pass them to runtimes.\n",
        "createdAt" : "2016-06-01T23:18:30Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "tags" : [
        ]
      },
      {
        "id" : "2a14253c-fde5-4c51-9a25-57780d983a36",
        "parentId" : "391c8bcf-22fb-4c9b-b5a1-726cfc2420cc",
        "authorId" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "body" : "No, these are annotations for the container. kubelet may use annotations as temporary checkpoints (e.g., restart count, etc). I'll make this clear by adding a new `RawContainerStatus` type.\n",
        "createdAt" : "2016-06-01T23:58:33Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "tags" : [
        ]
      },
      {
        "id" : "088cd2a0-551b-4d85-b8db-98661fd58e77",
        "parentId" : "391c8bcf-22fb-4c9b-b5a1-726cfc2420cc",
        "authorId" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "body" : "We should be passing pod/container annotations passed down via the API as well. For example, rkt has a stage 1 configuration that can be specified via annotations today.\n",
        "createdAt" : "2016-06-07T19:31:24Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "tags" : [
        ]
      }
    ],
    "commit" : "08dc66113399c89e31f6872f3c638695a6ec6a8d",
    "line" : 269,
    "diffHunk" : "@@ -1,1 +267,271 @@\t// Annotations is an unstructured key value map that may be set by external\n\t// tools to store and retrieve arbitrary metadata.\n\tAnnotations map[string]string\n\t// Privileged runs the container in the privileged mode.\n\tPrivileged bool"
  },
  {
    "id" : "a381a2c5-00cc-42d9-a770-b33c3ed3c263",
    "prId" : 25899,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b0422893-a34f-4ef4-a62b-3e78ba0bba86",
        "parentId" : null,
        "authorId" : "2fa5a4c6-e0a7-4dbe-a80e-7770a5dc92a1",
        "body" : "Correct me if I'm wrong, but as implemented today, labels are constructs stored in etcd and all scoping/selecting with them is done in the abstractions above the runtime.\n\nIn what case will labels actually need to be known about by the runtime itself? When would the kubelet run a List with a label filter? Or am I totally wrong and the container runtimes already know about and use labels?\n",
        "createdAt" : "2016-06-02T19:41:08Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "2fa5a4c6-e0a7-4dbe-a80e-7770a5dc92a1",
        "tags" : [
        ]
      },
      {
        "id" : "ace8530b-48f3-4f04-abb7-d7c609932685",
        "parentId" : "b0422893-a34f-4ef4-a62b-3e78ba0bba86",
        "authorId" : "4e418bc8-21fb-4523-80c1-9c751c193126",
        "body" : "The label here is not the kubernetes label.\n\nWe already use these kind of labels now. When kubelet starts docker and rkt containers, it'll set some labels on the container, such as PodName, PodUID, ContainerName etc. These labels help kubelet better manage the containers. For example, when kubelet lists and checks container, it could use the label as filter to select containers belong to a specific pod.\n(See https://github.com/kubernetes/kubernetes/issues/15089)\n",
        "createdAt" : "2016-06-02T20:23:55Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "4e418bc8-21fb-4523-80c1-9c751c193126",
        "tags" : [
        ]
      },
      {
        "id" : "24355313-cabf-49b9-87dd-918cb38275e9",
        "parentId" : "b0422893-a34f-4ef4-a62b-3e78ba0bba86",
        "authorId" : "2fa5a4c6-e0a7-4dbe-a80e-7770a5dc92a1",
        "body" : "Thanks for the clarification, it does help.. however, this comment is on the pod's `labels` field, not the container's. I guess those are wanted for a similar reason?\n\nSpeaking more generally of pod/container labels though:\nIf they're only used to do a match/filter of the things you mention, then they seem redundant in light of the `PodSandboxFilter` and `ContainerFilter` struct already containing all of those selectors (which I imagine will be implemented via labels).\nPerhaps labels-as-the-search-mechanism should be an implementation detail not exposed in this interface? \n",
        "createdAt" : "2016-06-02T23:21:10Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "2fa5a4c6-e0a7-4dbe-a80e-7770a5dc92a1",
        "tags" : [
        ]
      },
      {
        "id" : "1f03e98f-d357-4fcc-9eec-84b17bea4581",
        "parentId" : "b0422893-a34f-4ef4-a62b-3e78ba0bba86",
        "authorId" : "4e418bc8-21fb-4523-80c1-9c751c193126",
        "body" : "Kubelet use labels to better manage sandboxes and containers, just like kubernetes users use labels to help manage their pods. That's why we expose labels in kubernetes api, and that's also why we want runtime to expose labels from runtime interface. :)\n",
        "createdAt" : "2016-06-02T23:35:32Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "4e418bc8-21fb-4523-80c1-9c751c193126",
        "tags" : [
        ]
      },
      {
        "id" : "582e0f25-5bcd-46b1-a856-c1c94665019a",
        "parentId" : "b0422893-a34f-4ef4-a62b-3e78ba0bba86",
        "authorId" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "body" : "The selectors in the filters are based on labels. Without labels applied to the containers/sandbox, the selectors will have no use. \n",
        "createdAt" : "2016-06-03T18:26:29Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "tags" : [
        ]
      },
      {
        "id" : "8266b285-ea90-464b-8311-07deb0b0b331",
        "parentId" : "b0422893-a34f-4ef4-a62b-3e78ba0bba86",
        "authorId" : "2fa5a4c6-e0a7-4dbe-a80e-7770a5dc92a1",
        "body" : "The selectors will have a use; they'll tell the runtime that they must provide a way to list containers by PodUID,etc. The fact that that's done with labels in the docker runtime is an implementation detail which I don't think necessarily has to be exposed in this interface. E.g. the docker manager can create those labels even though they're not specified via the create call because it knows that to support `List(PodUID=foo)` it will filter by label.\n\nI  think the argument \"k8s provides users with labels, kubelet should too\" is a false equivalence. K8s is providing flexibility to users, a lower level interface between kubelet and a container runtime doesn't need that flexibility necessarily (unless you provide concrete examples), it just needs a way to filter by a limited set of items. And those items can be edited over time to ask runtimes to implement further filters (be it by labels or what have you).\n",
        "createdAt" : "2016-06-03T19:04:08Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "2fa5a4c6-e0a7-4dbe-a80e-7770a5dc92a1",
        "tags" : [
        ]
      },
      {
        "id" : "4fecb722-7811-4baa-b35c-0f6fd4288f0c",
        "parentId" : "b0422893-a34f-4ef4-a62b-3e78ba0bba86",
        "authorId" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "body" : "Kubelet _wants_ the flexibility to write labels to sandboxes/containers and to filter the sandboxes/containers by their labels. It allows kubelet to hide some implementation details and does not rely on runtimes to support a new filter field whenever there is a change.\n\nThe `ContainerFilter` type provides mostly selector that kubelet cannot write as labels:\n- Name: kubelet can write this as a label too, but it'll be quite redundant.\n- ID: kubelet doesn't know the ID beforehand.\n- State: This obviously cannot be a label\n",
        "createdAt" : "2016-06-06T22:39:09Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "tags" : [
        ]
      }
    ],
    "commit" : "08dc66113399c89e31f6872f3c638695a6ec6a8d",
    "line" : null,
    "diffHunk" : "@@ -1,1 +83,87 @@\t// Labels are key value pairs that may be used to scope and select\n\t// individual resources.\n\tLabels Labels\n\t// Annotations is an unstructured key value map that may be set by external\n\t// tools to store and retrieve arbitrary metadata."
  },
  {
    "id" : "a1ad4420-0ac7-4824-a0b8-89ac36e6a265",
    "prId" : 25899,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6c396077-9a61-4cd4-b955-d4d37cfbb056",
        "parentId" : null,
        "authorId" : "b56795d9-0816-4d28-b233-275e1ee4baf1",
        "body" : "Is the file format and filesystem layout specified somewhere for the log files?\n",
        "createdAt" : "2016-06-07T01:44:12Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "b56795d9-0816-4d28-b233-275e1ee4baf1",
        "tags" : [
        ]
      },
      {
        "id" : "b77c8352-2e5a-486c-9e1f-ff51ff74aa31",
        "parentId" : "6c396077-9a61-4cd4-b955-d4d37cfbb056",
        "authorId" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "body" : "Nope. @yujuhong we should add it. Kubelet doesn't care about the file format. The less we clobber a container's output, the easier it will be for logging agents to integrate easily with kubernetes.\nAs for directory structure how about,\n\n```\nPodSandboxConfig.LogDirectory = `/var/log/<podUID>/`\nContainerConfig.LogPath = `containerName_Instance#.log`\n```\n",
        "createdAt" : "2016-06-07T19:27:42Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "tags" : [
        ]
      },
      {
        "id" : "dd6e9645-2268-4c0b-aa45-f753a5b50f2e",
        "parentId" : "6c396077-9a61-4cd4-b955-d4d37cfbb056",
        "authorId" : "0df1da34-610c-4ce5-b0cf-bbda668bf9c1",
        "body" : "@vishh It's better to put all podsandbox logs in same directory insider `/var/log`, e.g. `/var/log/containers`, so we could put:\n\n```\nPodSandboxConfig.LogDirectory = `/var/log/containers/<podUID>/`\nContainerConfig.LogPath = `containerName_Instance#.log`\n```\n",
        "createdAt" : "2016-06-08T00:56:25Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "0df1da34-610c-4ce5-b0cf-bbda668bf9c1",
        "tags" : [
        ]
      },
      {
        "id" : "714ed580-801c-4e5d-b943-38fb78b41d82",
        "parentId" : "6c396077-9a61-4cd4-b955-d4d37cfbb056",
        "authorId" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "body" : "How about\n\n```\nPodSandboxConfig.LogDirectory = `/var/log/pods/<podUID>/`\nContainerConfig.LogPath = `containerName_Instance#.log`\n```\n",
        "createdAt" : "2016-06-09T01:02:55Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "tags" : [
        ]
      },
      {
        "id" : "85e315bc-5966-468f-ae9e-2b57aba677e1",
        "parentId" : "6c396077-9a61-4cd4-b955-d4d37cfbb056",
        "authorId" : "0df1da34-610c-4ce5-b0cf-bbda668bf9c1",
        "body" : "@yujuhong LGTM\n",
        "createdAt" : "2016-06-09T01:17:53Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "0df1da34-610c-4ce5-b0cf-bbda668bf9c1",
        "tags" : [
        ]
      }
    ],
    "commit" : "08dc66113399c89e31f6872f3c638695a6ec6a8d",
    "line" : null,
    "diffHunk" : "@@ -1,1 +80,84 @@\t// https://issues.k8s.io/24677. There *may* be future change of direction\n\t// for logging as the discussion carries on.\n\tLogDirectory string\n\t// Labels are key value pairs that may be used to scope and select\n\t// individual resources."
  },
  {
    "id" : "cc1ac53f-a416-47b1-a39c-0b33e6f732c6",
    "prId" : 25899,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "866a1bff-7688-4c22-b4e0-f6c744d65b30",
        "parentId" : null,
        "authorId" : "b56795d9-0816-4d28-b233-275e1ee4baf1",
        "body" : "What happens if I have a path to a network namespace and set this to true? I feel like we aren't sure what we want if we are doing both of these things.\n",
        "createdAt" : "2016-06-07T01:50:48Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "b56795d9-0816-4d28-b233-275e1ee4baf1",
        "tags" : [
        ]
      },
      {
        "id" : "14ad12f5-c2f7-4349-9000-06de26a27bbb",
        "parentId" : "866a1bff-7688-4c22-b4e0-f6c744d65b30",
        "authorId" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "body" : "How will the path to a netns be specified via this API?\n",
        "createdAt" : "2016-06-07T19:29:58Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "tags" : [
        ]
      },
      {
        "id" : "fd0351d5-be12-450e-8f28-a59582258b7b",
        "parentId" : "866a1bff-7688-4c22-b4e0-f6c744d65b30",
        "authorId" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "body" : "@philips kubelet can't pass a network namespace to the runtime via this API. \n",
        "createdAt" : "2016-06-09T01:10:08Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "tags" : [
        ]
      },
      {
        "id" : "f438d5cf-3b45-4a7a-86bd-5a5f1ad3d1f8",
        "parentId" : "866a1bff-7688-4c22-b4e0-f6c744d65b30",
        "authorId" : "e7821a6e-e1ed-44c2-912a-b058e6ed17cb",
        "body" : "@yujuhong So it'll be used to delegate the creation of the network sandbox for the pod? It's also important to design this so that it's possible to indicate the sandbox type, e.g. network namespace or hypervisor. The network sandbox creation is different per sandbox type, and it will have to be indicated to the network plugins.\n",
        "createdAt" : "2016-06-23T22:33:26Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "e7821a6e-e1ed-44c2-912a-b058e6ed17cb",
        "tags" : [
        ]
      }
    ],
    "commit" : "08dc66113399c89e31f6872f3c638695a6ec6a8d",
    "line" : 118,
    "diffHunk" : "@@ -1,1 +116,120 @@type NamespaceOptions struct {\n\t// HostNetwork uses the host's network namespace.\n\tHostNetwork bool\n\t// HostPID uses the host's pid namesapce.\n\tHostPID bool"
  },
  {
    "id" : "bcc71055-0921-470b-8fd0-50b27814a9c7",
    "prId" : 25899,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "aae245ed-bea8-457a-b298-613b105b3412",
        "parentId" : null,
        "authorId" : "b56795d9-0816-4d28-b233-275e1ee4baf1",
        "body" : "I am still confused about the logging plan with this system. What file descriptors is this hooked up to? \n",
        "createdAt" : "2016-06-07T01:55:08Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "b56795d9-0816-4d28-b233-275e1ee4baf1",
        "tags" : [
        ]
      },
      {
        "id" : "2a7a0d6b-cd99-4d90-a186-52b3394c42bf",
        "parentId" : "aae245ed-bea8-457a-b298-613b105b3412",
        "authorId" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "body" : "`stdout` and `stderr`. The field name needs to be more explicit. How about `StdoutLogFilePath` & `StderrLogFilePath`?\n",
        "createdAt" : "2016-06-07T19:45:05Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "tags" : [
        ]
      },
      {
        "id" : "c35a91e5-32c5-417d-b7fc-bfcf0b81b528",
        "parentId" : "aae245ed-bea8-457a-b298-613b105b3412",
        "authorId" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "body" : "I think we've cleared up a few things offline. I'll add more comments based on your suggestion.\n\n@vishh I think we've decided to combine stdout and stderr to stay consistent with our current implementation. I'll leave the name as it is and add more comments.\n",
        "createdAt" : "2016-06-09T01:14:12Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "tags" : [
        ]
      }
    ],
    "commit" : "08dc66113399c89e31f6872f3c638695a6ec6a8d",
    "line" : null,
    "diffHunk" : "@@ -1,1 +283,287 @@\t// https://issues.k8s.io/24677. There *may* be future change of direction\n\t// for logging as the discussion carries on.\n\tLogPath string\n\n\t// Variables for interactive containers, these have very specialized"
  },
  {
    "id" : "39a28da7-3cb2-487a-b82d-ee156040d217",
    "prId" : 25899,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0da4a1bc-499e-4ca5-a64c-c91c906b80c0",
        "parentId" : null,
        "authorId" : "0d2d9977-2328-4ade-b6a6-ba60c2dd5bd5",
        "body" : "Passing `PodSandboxResources` is a good, but why is the Kubelet coupled to cgroups?\n",
        "createdAt" : "2016-06-07T13:55:27Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "0d2d9977-2328-4ade-b6a6-ba60c2dd5bd5",
        "tags" : [
        ]
      },
      {
        "id" : "a9dfa09b-09f5-4614-aac7-ca9ea85019a3",
        "parentId" : "0da4a1bc-499e-4ca5-a64c-c91c906b80c0",
        "authorId" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "body" : "To provide Quality of Service in a portable manner.\n",
        "createdAt" : "2016-06-07T19:24:02Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "tags" : [
        ]
      },
      {
        "id" : "cd895386-1d63-4d2f-83fd-97f33be7a51f",
        "parentId" : "0da4a1bc-499e-4ca5-a64c-c91c906b80c0",
        "authorId" : "0d2d9977-2328-4ade-b6a6-ba60c2dd5bd5",
        "body" : "Can you expand a bit on the portable QoS?\n",
        "createdAt" : "2016-06-07T19:33:00Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "0d2d9977-2328-4ade-b6a6-ba60c2dd5bd5",
        "tags" : [
        ]
      }
    ],
    "commit" : "08dc66113399c89e31f6872f3c638695a6ec6a8d",
    "line" : 66,
    "diffHunk" : "@@ -1,1 +64,68 @@\t// sufficent. For others, e.g., hypervisor-based runtimes, explicit\n\t// resource limits for the sandbox are needed at creation time.\n\tResources PodSandboxResources\n\t// Path to the directory on the host in which container log files are\n\t// stored."
  },
  {
    "id" : "4fb6ff8f-d19d-45e3-acae-9b857e338d02",
    "prId" : 25899,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e98e4fa2-7b17-4754-8b89-d7b906009672",
        "parentId" : null,
        "authorId" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "body" : "Add a TODO to include other missing features like seccomp.\n",
        "createdAt" : "2016-06-07T19:47:36Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "tags" : [
        ]
      },
      {
        "id" : "5f501746-187c-4993-91d0-a052551bdc31",
        "parentId" : "e98e4fa2-7b17-4754-8b89-d7b906009672",
        "authorId" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "body" : "done.\n",
        "createdAt" : "2016-06-09T02:04:40Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "tags" : [
        ]
      },
      {
        "id" : "c2ceb0d5-bf62-4204-9812-24999ad873b6",
        "parentId" : "e98e4fa2-7b17-4754-8b89-d7b906009672",
        "authorId" : "0d2d9977-2328-4ade-b6a6-ba60c2dd5bd5",
        "body" : "This platform specific types will probably cause code duplication problems like the ones we're having right now with the multiple runtimes.\n",
        "createdAt" : "2016-06-30T12:34:52Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "0d2d9977-2328-4ade-b6a6-ba60c2dd5bd5",
        "tags" : [
        ]
      }
    ],
    "commit" : "08dc66113399c89e31f6872f3c638695a6ec6a8d",
    "line" : 334,
    "diffHunk" : "@@ -1,1 +332,336 @@\tCapabilities *api.Capabilities\n\t// SELinux is the SELinux context to be applied.\n\tSELinux *api.SELinuxOptions\n\t// TODO: Add support for seccomp.\n}"
  },
  {
    "id" : "74e08916-02c4-4c57-bcd9-c4a58dea35c0",
    "prId" : 25899,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "01f25d56-98e0-49fd-9c58-3b25da034dec",
        "parentId" : null,
        "authorId" : "b56795d9-0816-4d28-b233-275e1ee4baf1",
        "body" : "Hrm, where is `instance#` in the ContainerConfig struct?\n",
        "createdAt" : "2016-06-13T20:26:38Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "b56795d9-0816-4d28-b233-275e1ee4baf1",
        "tags" : [
        ]
      },
      {
        "id" : "8b90b0b3-cae1-4ba2-a21b-06ee1feb8feb",
        "parentId" : "01f25d56-98e0-49fd-9c58-3b25da034dec",
        "authorId" : "b56795d9-0816-4d28-b233-275e1ee4baf1",
        "body" : "@yujuhong Ping, where is instance# in the ContainerConfig struct?\n",
        "createdAt" : "2016-06-15T14:42:29Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "b56795d9-0816-4d28-b233-275e1ee4baf1",
        "tags" : [
        ]
      },
      {
        "id" : "96e0f8e6-1931-4318-9a81-28004fc06c9e",
        "parentId" : "01f25d56-98e0-49fd-9c58-3b25da034dec",
        "authorId" : "227eb550-8b08-4420-9a78-279f840bd8de",
        "body" : "@philips That refers to a random uuid of (or maps to) the container, which is used to separate the current container life from the previous ones (e.g. in a crashloop), so logs don't get overridden.\n@yujuhong Maybe just replace `Instance#` with `containerID` ?\n",
        "createdAt" : "2016-06-29T23:27:13Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "227eb550-8b08-4420-9a78-279f840bd8de",
        "tags" : [
        ]
      }
    ],
    "commit" : "08dc66113399c89e31f6872f3c638695a6ec6a8d",
    "line" : 285,
    "diffHunk" : "@@ -1,1 +283,287 @@\t// https://issues.k8s.io/24677. There *may* be future change of direction\n\t// for logging as the discussion carries on.\n\tLogPath string\n\n\t// Variables for interactive containers, these have very specialized"
  },
  {
    "id" : "dded851e-502a-4f55-983c-57b6a8dc33e9",
    "prId" : 25899,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "faa4740a-2933-4c21-beb9-b15ee7141258",
        "parentId" : null,
        "authorId" : "227eb550-8b08-4420-9a78-279f840bd8de",
        "body" : "The sandbox here will be related to the cni plugin rework in k8s. cc @steveej @dcbw \n",
        "createdAt" : "2016-06-23T22:19:05Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "227eb550-8b08-4420-9a78-279f840bd8de",
        "tags" : [
        ]
      }
    ],
    "commit" : "08dc66113399c89e31f6872f3c638695a6ec6a8d",
    "line" : 59,
    "diffHunk" : "@@ -1,1 +57,61 @@\tDNSOptions DNSOptions\n\t// PortMappings lists the port mappings for the sandbox.\n\tPortMappings []PortMapping\n\t// Resources specifies the resource limits for the sandbox (i.e., the\n\t// aggregate cpu/memory resources limits of all containers)."
  },
  {
    "id" : "bcd66eed-22c5-4dd8-9fe9-105b1c1852ea",
    "prId" : 25899,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4a68c533-9534-4cec-9500-97a03e4d2b94",
        "parentId" : null,
        "authorId" : "57f729dd-988a-4d1a-83bf-ee70bf637c64",
        "body" : "We're already looking at multiple pod IPs in the Net SIG, so can we make this a list of IPs?  Or better yet a list where each element is a struct that contains an IP item and perhaps some labels.\n",
        "createdAt" : "2016-06-27T20:29:29Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "57f729dd-988a-4d1a-83bf-ee70bf637c64",
        "tags" : [
        ]
      },
      {
        "id" : "329ec4bc-eaa2-4120-b031-09c03e237fae",
        "parentId" : "4a68c533-9534-4cec-9500-97a03e4d2b94",
        "authorId" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "body" : "Sure.\n",
        "createdAt" : "2016-06-29T21:51:42Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "tags" : [
        ]
      },
      {
        "id" : "1b8e7e82-4529-4b17-bad1-2b04ec5fa5ba",
        "parentId" : "4a68c533-9534-4cec-9500-97a03e4d2b94",
        "authorId" : "227eb550-8b08-4420-9a78-279f840bd8de",
        "body" : "+1\ncc @feiskyer We probably want to do the same for the client/server interface.  We not just talking about ipv4 / ipv6 here.\n\n@dcbw @steveeJ But in the current implementation, in most cases, the runtime is not aware of the network info, it needs help from cni/kubenet plugin driver to return that info.\n",
        "createdAt" : "2016-06-29T21:55:31Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "227eb550-8b08-4420-9a78-279f840bd8de",
        "tags" : [
        ]
      },
      {
        "id" : "d24cc181-dec3-435d-958f-687ca3b33e21",
        "parentId" : "4a68c533-9534-4cec-9500-97a03e4d2b94",
        "authorId" : "227eb550-8b08-4420-9a78-279f840bd8de",
        "body" : "Maybe something like \n\n``` go\n...\nNetworks []*Network\n...\ntype Network struct {\n        Name string\n        IPv4 string\n        IPv6 string ?         \n}\n```\n",
        "createdAt" : "2016-06-29T21:58:18Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "227eb550-8b08-4420-9a78-279f840bd8de",
        "tags" : [
        ]
      },
      {
        "id" : "5c278ba0-b733-4f83-aa88-9c5823558903",
        "parentId" : "4a68c533-9534-4cec-9500-97a03e4d2b94",
        "authorId" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "body" : "@yifan-gu how about opening a separate issue since this requires more design?\n",
        "createdAt" : "2016-06-30T00:34:57Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "tags" : [
        ]
      },
      {
        "id" : "f2800cd8-bf89-4a63-921a-a3038168430f",
        "parentId" : "4a68c533-9534-4cec-9500-97a03e4d2b94",
        "authorId" : "0df1da34-610c-4ce5-b0cf-bbda668bf9c1",
        "body" : "> @yifan-gu how about opening a separate issue since this requires more design?\n> Add a line note\n\n+1\n",
        "createdAt" : "2016-06-30T07:44:34Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "0df1da34-610c-4ce5-b0cf-bbda668bf9c1",
        "tags" : [
        ]
      },
      {
        "id" : "8e1acf8e-e4b5-4398-b579-987af1d9f072",
        "parentId" : "4a68c533-9534-4cec-9500-97a03e4d2b94",
        "authorId" : "227eb550-8b08-4420-9a78-279f840bd8de",
        "body" : "Agree\n",
        "createdAt" : "2016-07-01T18:48:33Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "227eb550-8b08-4420-9a78-279f840bd8de",
        "tags" : [
        ]
      },
      {
        "id" : "752cf80b-4626-48bb-84b5-c565d97bd674",
        "parentId" : "4a68c533-9534-4cec-9500-97a03e4d2b94",
        "authorId" : "57f729dd-988a-4d1a-83bf-ee70bf637c64",
        "body" : "Is there a link to that separate issue?  Also note that a \"network\" may return multiple IP addresses, especially for IPv6 with a LL and a routable address.\n",
        "createdAt" : "2016-07-22T19:12:10Z",
        "updatedAt" : "2016-07-22T19:12:10Z",
        "lastEditedBy" : "57f729dd-988a-4d1a-83bf-ee70bf637c64",
        "tags" : [
        ]
      },
      {
        "id" : "48eb06e9-3a53-4326-88e0-fb8eee89a1f8",
        "parentId" : "4a68c533-9534-4cec-9500-97a03e4d2b94",
        "authorId" : "0df1da34-610c-4ce5-b0cf-bbda668bf9c1",
        "body" : "@dcbw See #28667.\n",
        "createdAt" : "2016-07-23T01:34:36Z",
        "updatedAt" : "2016-07-23T01:34:36Z",
        "lastEditedBy" : "0df1da34-610c-4ce5-b0cf-bbda668bf9c1",
        "tags" : [
        ]
      }
    ],
    "commit" : "08dc66113399c89e31f6872f3c638695a6ec6a8d",
    "line" : 181,
    "diffHunk" : "@@ -1,1 +179,183 @@\n// PodSandboxNetworkStatus is the status of the network for a PodSandbox.\ntype PodSandboxNetworkStatus struct {\n\tIPs []string\n}"
  },
  {
    "id" : "4f58d9c1-b953-4242-a15b-553589eaac99",
    "prId" : 25899,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e09636e7-1c10-4aa4-80a8-ca0d57538ef5",
        "parentId" : null,
        "authorId" : "57f729dd-988a-4d1a-83bf-ee70bf637c64",
        "body" : "What in kubelet itself or the k8s API is expected to use the netns path?  I think that's really an implementation detail of the runtime itself and should be isolated in the runtime code and network plugins.  I don't see kubelet or API consumers needing the netns path at all.\n\nObviously the network plugins care, but since they are called by the runtime itself I think we should enhance the network plugin API to allow passing namespace/VM-id/whatever into the plugin at SetUpPod/TearDownPod/GetPodNetworkStatus time.  But I don't think this needs to be part of the kubelet <-> runtime API at all?  Kubelet shouldn't care.\n",
        "createdAt" : "2016-06-27T20:58:08Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "57f729dd-988a-4d1a-83bf-ee70bf637c64",
        "tags" : [
        ]
      },
      {
        "id" : "46d70091-0a45-4004-aa53-00fb64d9796a",
        "parentId" : "e09636e7-1c10-4aa4-80a8-ca0d57538ef5",
        "authorId" : "0df1da34-610c-4ce5-b0cf-bbda668bf9c1",
        "body" : "@dcbw Agree for enhancing network plugin interface, but it's better in a separate issue.\n",
        "createdAt" : "2016-06-27T22:50:12Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "0df1da34-610c-4ce5-b0cf-bbda668bf9c1",
        "tags" : [
        ]
      },
      {
        "id" : "ebcbf7ef-fabd-40e4-99c1-55a273aa0b25",
        "parentId" : "e09636e7-1c10-4aa4-80a8-ca0d57538ef5",
        "authorId" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "body" : "@dcbw as of today, kubenet still calls the runtime to get the network namespace directly, while being part of kubelet. Again, these are good points, but this PR does not intend to solve everything in one shot. Feel free to open a separate issue for discussion.\n",
        "createdAt" : "2016-06-29T21:47:28Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "tags" : [
        ]
      },
      {
        "id" : "c2a83d48-7477-4603-9918-d132b51f757b",
        "parentId" : "e09636e7-1c10-4aa4-80a8-ca0d57538ef5",
        "authorId" : "227eb550-8b08-4420-9a78-279f840bd8de",
        "body" : "> but since they are called by the runtime itself\n\nDo you mean called by **kubelet** itself? @dcbw \n",
        "createdAt" : "2016-06-29T22:48:50Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "227eb550-8b08-4420-9a78-279f840bd8de",
        "tags" : [
        ]
      }
    ],
    "commit" : "08dc66113399c89e31f6872f3c638695a6ec6a8d",
    "line" : 192,
    "diffHunk" : "@@ -1,1 +190,194 @@\n// LinuxSandBoxStatus contains status specific to Linux sandboxes.\ntype LinuxPodSandboxStatus struct {\n\t// Namespaces contains paths to the sandbox's namespaces.\n\tNamespaces *Namespaces"
  },
  {
    "id" : "cade5e5a-954f-4fea-947f-71f2fa340873",
    "prId" : 25899,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d920b08f-dd4c-4848-b291-072d2339aca7",
        "parentId" : null,
        "authorId" : "227eb550-8b08-4420-9a78-279f840bd8de",
        "body" : "Can just call it PodSandbox?\n",
        "createdAt" : "2016-06-29T21:53:33Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "227eb550-8b08-4420-9a78-279f840bd8de",
        "tags" : [
        ]
      },
      {
        "id" : "767b1a28-c25c-4cd4-9eed-97002124a70c",
        "parentId" : "d920b08f-dd4c-4848-b291-072d2339aca7",
        "authorId" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "body" : "It has minimal information as the comment suggests, so it'd be misleading to do that.\n",
        "createdAt" : "2016-06-30T00:10:25Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "tags" : [
        ]
      }
    ],
    "commit" : "08dc66113399c89e31f6872f3c638695a6ec6a8d",
    "line" : 157,
    "diffHunk" : "@@ -1,1 +155,159 @@\n// PodSandboxListItem contains minimal information about a sandbox.\ntype PodSandboxListItem struct {\n\tID    PodSandboxID\n\tState PodSandboxState"
  },
  {
    "id" : "babd16cc-157d-4da7-9bcb-485647a56f8d",
    "prId" : 25899,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2b28edfd-c45e-43a6-a56d-b17a523ddef4",
        "parentId" : null,
        "authorId" : "227eb550-8b08-4420-9a78-279f840bd8de",
        "body" : "ditto, can just be called Container ?\n",
        "createdAt" : "2016-06-29T23:10:44Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "227eb550-8b08-4420-9a78-279f840bd8de",
        "tags" : [
        ]
      },
      {
        "id" : "86fc01c1-8360-4f0a-9f45-6d0a6c67db0d",
        "parentId" : "2b28edfd-c45e-43a6-a56d-b17a523ddef4",
        "authorId" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "body" : "It doesn't have all the information. If we want to call it `Container`, we should probably include the config as well. \n",
        "createdAt" : "2016-06-30T00:33:18Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "tags" : [
        ]
      }
    ],
    "commit" : "08dc66113399c89e31f6872f3c638695a6ec6a8d",
    "line" : 234,
    "diffHunk" : "@@ -1,1 +232,236 @@// ContainerListItem provides the runtime information for a container returned\n// by List().\ntype ContainerListItem struct {\n\t// The ID of the container, used by the container runtime to identify\n\t// a container."
  },
  {
    "id" : "e96e7f7b-5eca-4de8-8db7-f09abdfecdb3",
    "prId" : 25899,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3f0f5771-1380-42c5-b536-5b9d8373c8e6",
        "parentId" : null,
        "authorId" : "227eb550-8b08-4420-9a78-279f840bd8de",
        "body" : "Why we don't have image name here?\n",
        "createdAt" : "2016-06-29T23:11:07Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "227eb550-8b08-4420-9a78-279f840bd8de",
        "tags" : [
        ]
      },
      {
        "id" : "a06ec9f5-304c-4d63-9700-f13a866484aa",
        "parentId" : "3f0f5771-1380-42c5-b536-5b9d8373c8e6",
        "authorId" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "body" : "I don't think we use it in kubelet currently.\n",
        "createdAt" : "2016-06-30T00:30:40Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "tags" : [
        ]
      }
    ],
    "commit" : "08dc66113399c89e31f6872f3c638695a6ec6a8d",
    "line" : 243,
    "diffHunk" : "@@ -1,1 +241,245 @@\t// Reference to the image in use. For most runtimes, this should be an\n\t// image ID.\n\tImageRef string\n\t// State is the state of the container.\n\tState ContainerState"
  },
  {
    "id" : "99e3d285-a954-49fe-9810-73ed4b062d55",
    "prId" : 25899,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "691c279c-95b7-4d3f-8357-dd8bea9d3202",
        "parentId" : null,
        "authorId" : "227eb550-8b08-4420-9a78-279f840bd8de",
        "body" : "nit: Why not just call it ContainerStatus?\n",
        "createdAt" : "2016-06-29T23:30:29Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "227eb550-8b08-4420-9a78-279f840bd8de",
        "tags" : [
        ]
      },
      {
        "id" : "07816ab5-46be-4109-bda0-e671a236556b",
        "parentId" : "691c279c-95b7-4d3f-8357-dd8bea9d3202",
        "authorId" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "body" : "The name is already used in the same package. Let's keep this as it is to distinguish between the two.\n",
        "createdAt" : "2016-06-30T00:28:15Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "tags" : [
        ]
      },
      {
        "id" : "3787c8e3-1b1b-4826-97f6-ec2934c8f8a0",
        "parentId" : "691c279c-95b7-4d3f-8357-dd8bea9d3202",
        "authorId" : "0d2d9977-2328-4ade-b6a6-ba60c2dd5bd5",
        "body" : "We should split this into multiple packages to comply with idiomatic Go naming, which would be `container.Status` for this type.\n",
        "createdAt" : "2016-06-30T12:32:38Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "0d2d9977-2328-4ade-b6a6-ba60c2dd5bd5",
        "tags" : [
        ]
      }
    ],
    "commit" : "08dc66113399c89e31f6872f3c638695a6ec6a8d",
    "line" : 300,
    "diffHunk" : "@@ -1,1 +298,302 @@\n// RawContainerStatus represents the status of a container.\ntype RawContainerStatus struct {\n\t// ID of the container.\n\tID ContainerID"
  },
  {
    "id" : "1afcd00e-9614-48fc-af8d-b65592788cf2",
    "prId" : 25899,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "71864312-9e03-49bc-8843-f019358a2bb9",
        "parentId" : null,
        "authorId" : "227eb550-8b08-4420-9a78-279f840bd8de",
        "body" : "Same, don't we need image name as well?\n",
        "createdAt" : "2016-06-29T23:31:01Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "227eb550-8b08-4420-9a78-279f840bd8de",
        "tags" : [
        ]
      },
      {
        "id" : "a2ead84b-9dfc-4fde-b21a-91f3f2ec24e3",
        "parentId" : "71864312-9e03-49bc-8843-f019358a2bb9",
        "authorId" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "body" : "I don't think we use image name from the container status anywhere in the code.\n",
        "createdAt" : "2016-06-30T00:28:41Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "tags" : [
        ]
      },
      {
        "id" : "fa798a50-94b0-4224-8d8c-5cc47b3aeb83",
        "parentId" : "71864312-9e03-49bc-8843-f019358a2bb9",
        "authorId" : "0d2d9977-2328-4ade-b6a6-ba60c2dd5bd5",
        "body" : "We should probably type alias the ImageRef to avoid any confusion\n",
        "createdAt" : "2016-06-30T12:33:17Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "0d2d9977-2328-4ade-b6a6-ba60c2dd5bd5",
        "tags" : [
        ]
      }
    ],
    "commit" : "08dc66113399c89e31f6872f3c638695a6ec6a8d",
    "line" : 317,
    "diffHunk" : "@@ -1,1 +315,319 @@\t// Reference to the image in use. For most runtimes, this should be an\n\t// image ID.\n\tImageRef string\n\t// Labels are key value pairs that may be used to scope and select individual resources.\n\tLabels Labels"
  },
  {
    "id" : "a1b02495-3265-4f16-a696-4f37771fac9f",
    "prId" : 25899,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3705c440-9d87-4043-9d40-3b46b4d5c4c7",
        "parentId" : null,
        "authorId" : "0d2d9977-2328-4ade-b6a6-ba60c2dd5bd5",
        "body" : "Using maps should eliminate this\n",
        "createdAt" : "2016-06-30T12:36:03Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "0d2d9977-2328-4ade-b6a6-ba60c2dd5bd5",
        "tags" : [
        ]
      },
      {
        "id" : "8fdd98b5-c5eb-42bf-9266-cd44c0d30f7a",
        "parentId" : "3705c440-9d87-4043-9d40-3b46b4d5c4c7",
        "authorId" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "body" : "Discussed this before. Using lists instead of maps to keep the order.\n",
        "createdAt" : "2016-07-01T18:24:24Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "tags" : [
        ]
      }
    ],
    "commit" : "08dc66113399c89e31f6872f3c638695a6ec6a8d",
    "line" : 379,
    "diffHunk" : "@@ -1,1 +377,381 @@\n// KeyValue represents a key-value pair.\ntype KeyValue struct {\n\tKey   string\n\tValue string"
  },
  {
    "id" : "51761891-72f5-4463-bd91-10ac17170130",
    "prId" : 25899,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "179641af-08b7-497e-b2c0-9c094f9d07ac",
        "parentId" : null,
        "authorId" : "0d2d9977-2328-4ade-b6a6-ba60c2dd5bd5",
        "body" : "Sorry, but I missed why we migrated from `ContainerManager` to `ContainerRuntime`. Mapping `ContainerManager` and pod 1 to 1 makes sense as opposed to a single `ContainerRuntime` having access to every container on the host.\n",
        "createdAt" : "2016-06-30T13:01:05Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "0d2d9977-2328-4ade-b6a6-ba60c2dd5bd5",
        "tags" : [
        ]
      },
      {
        "id" : "84fc02f3-d271-491e-a6b4-d130435cc782",
        "parentId" : "179641af-08b7-497e-b2c0-9c094f9d07ac",
        "authorId" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "body" : "We didn't actually _migrate_ anything. It was simply a renaming. The interface and the meaning itself never changed. Are you proposing on changing how kubelet interacts with the runtime, how how kubelet implements this internally?\n",
        "createdAt" : "2016-07-01T18:35:55Z",
        "updatedAt" : "2016-07-01T22:42:19Z",
        "lastEditedBy" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "tags" : [
        ]
      }
    ],
    "commit" : "08dc66113399c89e31f6872f3c638695a6ec6a8d",
    "line" : 212,
    "diffHunk" : "@@ -1,1 +210,214 @@// well as listing or inspecting existing containers. These methods should\n// either return an error or block until the operation succeeds.\ntype ContainerRuntime interface {\n\t// Create creates a container in the sandbox, and returns the ID\n\t// of the created container."
  },
  {
    "id" : "f4482689-da76-4e2e-9c0d-f217b121fa86",
    "prId" : 25899,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "057f55c4-d527-4a82-8b65-3cf92eca62f4",
        "parentId" : null,
        "authorId" : "79676760-e10b-4a9f-aaf8-ec1c2b8e0ec3",
        "body" : "is there any particular issue in having an `User` property in `PodSandboxConfig` above? OCI would want to specify an user in the config.json as part of running a container with a specified user. Having the CRI proto to support that would let OCI containers to run with a particular user. @mrunalp @yujuhong @vishh \n",
        "createdAt" : "2016-07-15T15:53:40Z",
        "updatedAt" : "2016-07-15T15:57:21Z",
        "lastEditedBy" : "79676760-e10b-4a9f-aaf8-ec1c2b8e0ec3",
        "tags" : [
        ]
      },
      {
        "id" : "a99bd786-4d7d-4fc7-934b-de2f830142f0",
        "parentId" : "057f55c4-d527-4a82-8b65-3cf92eca62f4",
        "authorId" : "2fa5a4c6-e0a7-4dbe-a80e-7770a5dc92a1",
        "body" : "Since the `securityContext` of a container can have a `runAsUser`, we need something in this interface to be able to handle that. However, I think it should be solely part of a container's config, not pod sandbox.\n\nWant to file a followup issue or make a PR to add this and discuss there instead?\n",
        "createdAt" : "2016-07-15T18:40:43Z",
        "updatedAt" : "2016-07-15T18:40:43Z",
        "lastEditedBy" : "2fa5a4c6-e0a7-4dbe-a80e-7770a5dc92a1",
        "tags" : [
        ]
      },
      {
        "id" : "d0f136a3-0044-4d07-9707-ec2bc273624b",
        "parentId" : "057f55c4-d527-4a82-8b65-3cf92eca62f4",
        "authorId" : "5328b1c0-0dbd-4fd8-869d-e914880959c2",
        "body" : "I agree that adding this at the container level makes sense. PodSandbox could be left upto the runtime. \n",
        "createdAt" : "2016-07-15T18:45:32Z",
        "updatedAt" : "2016-07-15T18:45:32Z",
        "lastEditedBy" : "5328b1c0-0dbd-4fd8-869d-e914880959c2",
        "tags" : [
        ]
      },
      {
        "id" : "3534c8e9-b624-47e7-9252-6fbedfd655bf",
        "parentId" : "057f55c4-d527-4a82-8b65-3cf92eca62f4",
        "authorId" : "79676760-e10b-4a9f-aaf8-ec1c2b8e0ec3",
        "body" : ":+1: I'll make a PR to discuss that then\n",
        "createdAt" : "2016-07-15T18:46:28Z",
        "updatedAt" : "2016-07-15T18:46:28Z",
        "lastEditedBy" : "79676760-e10b-4a9f-aaf8-ec1c2b8e0ec3",
        "tags" : [
        ]
      },
      {
        "id" : "d3311bc6-8dc3-4ac0-ac04-9048787fbcdd",
        "parentId" : "057f55c4-d527-4a82-8b65-3cf92eca62f4",
        "authorId" : "79676760-e10b-4a9f-aaf8-ec1c2b8e0ec3",
        "body" : "BTW, @euank sorry for the confusion, I did mean `ContainerConfig` not `PodSandboxConfig`\n",
        "createdAt" : "2016-07-15T18:48:08Z",
        "updatedAt" : "2016-07-15T18:48:08Z",
        "lastEditedBy" : "79676760-e10b-4a9f-aaf8-ec1c2b8e0ec3",
        "tags" : [
        ]
      },
      {
        "id" : "4b9eb548-66b4-4396-8281-bb2526a87abd",
        "parentId" : "057f55c4-d527-4a82-8b65-3cf92eca62f4",
        "authorId" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "body" : "+1 for adding user to container config.\n",
        "createdAt" : "2016-07-15T20:43:36Z",
        "updatedAt" : "2016-07-15T20:43:36Z",
        "lastEditedBy" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "tags" : [
        ]
      }
    ],
    "commit" : "08dc66113399c89e31f6872f3c638695a6ec6a8d",
    "line" : 92,
    "diffHunk" : "@@ -1,1 +90,94 @@\t// Linux contains configurations specific to Linux hosts.\n\tLinux *LinuxPodSandboxConfig\n}\n\n// Labels are key value pairs that may be used to scope and select individual"
  },
  {
    "id" : "2df02ed9-1f2c-48ce-beb1-eae077f03b1a",
    "prId" : 25899,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d5e92d35-f244-4ce2-8372-45f07220b5b8",
        "parentId" : null,
        "authorId" : "7a59a326-58b3-4590-b70a-297d2e27daa5",
        "body" : "From where do these labels come?\nWhat if the container runtime needs to know the origin of this container in k8s API terms, such as k8s namespace, k8s pod name, and user container name in the pod --- how could the runtime know those?\n",
        "createdAt" : "2016-07-19T18:35:25Z",
        "updatedAt" : "2016-07-19T18:35:25Z",
        "lastEditedBy" : "7a59a326-58b3-4590-b70a-297d2e27daa5",
        "tags" : [
        ]
      },
      {
        "id" : "81a030cc-3039-4f2d-a08d-9ac17e446283",
        "parentId" : "d5e92d35-f244-4ce2-8372-45f07220b5b8",
        "authorId" : "2fa5a4c6-e0a7-4dbe-a80e-7770a5dc92a1",
        "body" : "This interface abstracts those details away. Those labels realistically do contain such information, but it's an internal contract for the kubelet to use for itself only, not something the runtime is supposed to interpret in any way.\n\nRight now those come mostly from [here](https://github.com/kubernetes/kubernetes/blob/9ada26d6cd7eae61a9d75a27b57381d4f5b21dfa/pkg/kubelet/dockertools/labels.go#L37) iirc and are used for things like calculating restart count and checkpointing data.\n\nThe interface explicitly does not express more to the runtime than it needs to know.\n\nThat being said, a sufficiently smart runtime could lookup a container it manages in the kubelet's `pods` endpoint based on its container ID I expect.\nRealistically though, k8s namespaces and pod names and so on are all higher level details that the runtime should not have to care about.\n",
        "createdAt" : "2016-07-19T21:08:37Z",
        "updatedAt" : "2016-07-19T21:10:55Z",
        "lastEditedBy" : "2fa5a4c6-e0a7-4dbe-a80e-7770a5dc92a1",
        "tags" : [
        ]
      }
    ],
    "commit" : "08dc66113399c89e31f6872f3c638695a6ec6a8d",
    "line" : 266,
    "diffHunk" : "@@ -1,1 +264,268 @@\tMounts []Mount\n\t// Labels are key value pairs that may be used to scope and select individual resources.\n\tLabels Labels\n\t// Annotations is an unstructured key value map that may be set by external\n\t// tools to store and retrieve arbitrary metadata."
  }
]
[
  {
    "id" : "d7e75fe2-55c4-4f57-b29d-565acd468587",
    "prId" : 63328,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/63328#pullrequestreview-121083803",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "acde4d74-26d4-426d-a689-26bac31820b9",
        "parentId" : null,
        "authorId" : "9f030d50-62db-4b00-a28c-847709b74d97",
        "body" : "`com.mycompany.my-plugin`?",
        "createdAt" : "2018-05-16T21:27:24Z",
        "updatedAt" : "2018-05-29T16:00:59Z",
        "lastEditedBy" : "9f030d50-62db-4b00-a28c-847709b74d97",
        "tags" : [
        ]
      },
      {
        "id" : "30156438-0a62-402e-a600-c59ea77eed51",
        "parentId" : "acde4d74-26d4-426d-a689-26bac31820b9",
        "authorId" : "51f59c69-efc0-451a-bd8f-d9fa2c281fd3",
        "body" : "Yes. Current implementation does not support hierarchical paths like \"mycompany.com/my-plugin\". But is in the plan as mentioned.",
        "createdAt" : "2018-05-17T13:41:03Z",
        "updatedAt" : "2018-05-29T16:00:59Z",
        "lastEditedBy" : "51f59c69-efc0-451a-bd8f-d9fa2c281fd3",
        "tags" : [
        ]
      },
      {
        "id" : "1370b58f-27ec-48b8-9385-f1abacb0a80f",
        "parentId" : "acde4d74-26d4-426d-a689-26bac31820b9",
        "authorId" : "54b8eb75-28dd-421d-a52b-63bf897147a9",
        "body" : "If the PluginsSockDir is flat, I think you should at least have PluginsSockDir/csi and PluginsSockDir/devices with two watcher instances.  That way you can avoid name collisions between csi and device plugin names.",
        "createdAt" : "2018-05-17T15:18:56Z",
        "updatedAt" : "2018-05-29T16:00:59Z",
        "lastEditedBy" : "54b8eb75-28dd-421d-a52b-63bf897147a9",
        "tags" : [
        ]
      }
    ],
    "commit" : "3a2e3bcc70ef9810b871db8bcf0599c4712f6bc2",
    "line" : 23,
    "diffHunk" : "@@ -1,1 +21,25 @@  by any other potential plugins. Currently we only support flat fs namespace\n  under PluginsSockDir but will soon support recursive inotify watch for\n  hierarchical socket paths.\n- A plugin should clean up its own socket upon exiting or when a new instance\n  comes up. A plugin should NOT remove any sockets belonging to other plugins."
  },
  {
    "id" : "84d9a2a0-616f-4b59-b29e-cd02e7401b59",
    "prId" : 63328,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/63328#pullrequestreview-124218031",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "08cad343-0781-436d-922d-579440c1a0dd",
        "parentId" : null,
        "authorId" : "54b8eb75-28dd-421d-a52b-63bf897147a9",
        "body" : "Is there anyway to prevent a plugin from removing sockets dir from another plugin ?  This could be a big issue.",
        "createdAt" : "2018-05-17T15:28:47Z",
        "updatedAt" : "2018-05-29T16:00:59Z",
        "lastEditedBy" : "54b8eb75-28dd-421d-a52b-63bf897147a9",
        "tags" : [
        ]
      },
      {
        "id" : "cd8f3d17-2d1d-45b7-819f-0450e9e6a872",
        "parentId" : "08cad343-0781-436d-922d-579440c1a0dd",
        "authorId" : "51f59c69-efc0-451a-bd8f-d9fa2c281fd3",
        "body" : "I dont have a approach for this on top of my mind. Would love to hear suggestions.",
        "createdAt" : "2018-05-18T10:53:39Z",
        "updatedAt" : "2018-05-29T16:00:59Z",
        "lastEditedBy" : "51f59c69-efc0-451a-bd8f-d9fa2c281fd3",
        "tags" : [
        ]
      },
      {
        "id" : "412aa3f6-be42-4abd-a6f3-152e2d174797",
        "parentId" : "08cad343-0781-436d-922d-579440c1a0dd",
        "authorId" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "body" : "One option would be that of using a directory per plugin where a plugin can be restricted to only create sockets within a specific directory.\r\nUnless plugins stop running as privileged or uid `0`, attempts to secure plugins from one-another would be moot.",
        "createdAt" : "2018-05-30T00:35:06Z",
        "updatedAt" : "2018-05-30T00:35:07Z",
        "lastEditedBy" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "tags" : [
        ]
      }
    ],
    "commit" : "3a2e3bcc70ef9810b871db8bcf0599c4712f6bc2",
    "line" : 25,
    "diffHunk" : "@@ -1,1 +23,27 @@  hierarchical socket paths.\n- A plugin should clean up its own socket upon exiting or when a new instance\n  comes up. A plugin should NOT remove any sockets belonging to other plugins.\n- A plugin should make sure it has service ready for any supported service API\n  version listed in the PluginInfo."
  },
  {
    "id" : "482212c0-f605-421a-949b-81e2f65afb33",
    "prId" : 63328,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/63328#pullrequestreview-122281281",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "498992ff-4f02-4167-a05d-09b58f615a19",
        "parentId" : null,
        "authorId" : "54b8eb75-28dd-421d-a52b-63bf897147a9",
        "body" : "Is it too late to turn watcher into a service? The plugin calls the watcher at a prescribed UDS location to register itself instead of the watcher doing inotify on a flat directory.  That way the watcher can apply stricter registration rules including voiding name clashes, etc.  ",
        "createdAt" : "2018-05-17T15:37:19Z",
        "updatedAt" : "2018-05-29T16:00:59Z",
        "lastEditedBy" : "54b8eb75-28dd-421d-a52b-63bf897147a9",
        "tags" : [
        ]
      },
      {
        "id" : "51d7a584-0af4-460b-a732-ca8d6d96d5af",
        "parentId" : "498992ff-4f02-4167-a05d-09b58f615a19",
        "authorId" : "51f59c69-efc0-451a-bd8f-d9fa2c281fd3",
        "body" : "If i understood correctly, you are suggesting model 1, where plugin starts the communication. As explained the design doc, there is a problem in re-registration case with model 1. Therefore we decided to implement model 2. \r\nflat directory is just for initial implementation and will be extended to hierarchical in successive PR. \r\nI think in model 1 also onus of avoiding plugin name conflict is on plugins. I am not sure how model 1 is better than model 2 in avoiding name clashes. ",
        "createdAt" : "2018-05-18T10:43:55Z",
        "updatedAt" : "2018-05-29T16:00:59Z",
        "lastEditedBy" : "51f59c69-efc0-451a-bd8f-d9fa2c281fd3",
        "tags" : [
        ]
      },
      {
        "id" : "048d859a-568a-4cea-ab32-d615bfc9a2b1",
        "parentId" : "498992ff-4f02-4167-a05d-09b58f615a19",
        "authorId" : "54b8eb75-28dd-421d-a52b-63bf897147a9",
        "body" : "@vikaschoudhary16 I am concerned with plugin name clash between plugin types of CSI and DevicePlugin plugins.  If PluginsSockDir is flat then a plugin name from CSI may clash with a plugin from DevicePlugin. ",
        "createdAt" : "2018-05-22T17:49:49Z",
        "updatedAt" : "2018-05-29T16:00:59Z",
        "lastEditedBy" : "54b8eb75-28dd-421d-a52b-63bf897147a9",
        "tags" : [
        ]
      }
    ],
    "commit" : "3a2e3bcc70ef9810b871db8bcf0599c4712f6bc2",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +3,7 @@It discovers plugins by monitoring inotify events under the directory returned by\nkubelet.getPluginsDir(). Lets refer this directory as PluginsSockDir.\nFor any discovered plugin, pluginwatcher issues Registration.GetInfo grpc call\nto get plugin type, name and supported service API versions. For any registered plugin type,\npluginwatcher calls the registered callback function with the received plugin"
  }
]
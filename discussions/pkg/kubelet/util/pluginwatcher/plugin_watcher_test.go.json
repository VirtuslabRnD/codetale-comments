[
  {
    "id" : "98fb0e57-a528-40eb-a993-7cb96fae743e",
    "prId" : 75110,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/75110#pullrequestreview-227322276",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b74cb0d6-8d0f-42b7-ace7-8a946d34a9fd",
        "parentId" : null,
        "authorId" : "255dd885-bee4-4c1f-baef-ba11f903dc5c",
        "body" : "Since we're processing serially now, there're would be a lot of contention [here](https://github.com/bertinatto/kubernetes/blob/832822b41808f54f563fa513dbb3371164803e44/pkg/kubelet/util/pluginwatcher/example_plugin.go#L103). To avoid that, this starts the channel-reading goroutines earlier.",
        "createdAt" : "2019-04-16T16:54:39Z",
        "updatedAt" : "2019-04-23T20:24:53Z",
        "lastEditedBy" : "255dd885-bee4-4c1f-baef-ba11f903dc5c",
        "tags" : [
        ]
      }
    ],
    "commit" : "f56455753b0e9054bfe756807c002f1a67704dcd",
    "line" : 24,
    "diffHunk" : "@@ -1,1 +190,194 @@\tw := newWatcherWithHandler(t, hdlr, false /* testDeprecatedDir */)\n\tdefer func() { require.NoError(t, w.Stop()) }()\n\n\tc := make(chan struct{})\n\tgo func() {"
  },
  {
    "id" : "d000dd60-5f90-488a-be8a-ee816982a5dc",
    "prId" : 75110,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/75110#pullrequestreview-229744710",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "90593165-ad03-4702-9899-d26a60388458",
        "parentId" : null,
        "authorId" : "9f030d50-62db-4b00-a28c-847709b74d97",
        "body" : "alternatively, you can just do this serially at the end of the test and rely on the whole test timing out for the failure condition.",
        "createdAt" : "2019-04-23T17:49:09Z",
        "updatedAt" : "2019-04-23T20:24:53Z",
        "lastEditedBy" : "9f030d50-62db-4b00-a28c-847709b74d97",
        "tags" : [
        ]
      },
      {
        "id" : "0b7eca40-d847-488e-8f12-4f7b50441631",
        "parentId" : "90593165-ad03-4702-9899-d26a60388458",
        "authorId" : "255dd885-bee4-4c1f-baef-ba11f903dc5c",
        "body" : "Since we're processing plugins serially now, `newWatcherWithHandler` below would block forever trying to write to the event/registration channels. This goroutine prevents that by receiving info from these channels beforehand.",
        "createdAt" : "2019-04-23T19:26:26Z",
        "updatedAt" : "2019-04-23T20:24:53Z",
        "lastEditedBy" : "255dd885-bee4-4c1f-baef-ba11f903dc5c",
        "tags" : [
        ]
      }
    ],
    "commit" : "f56455753b0e9054bfe756807c002f1a67704dcd",
    "line" : 46,
    "diffHunk" : "@@ -1,1 +245,249 @@\t\trequire.True(t, waitForEvent(t, exampleEventValidate, hdlr.EventChan(p.pluginName)))\n\t\trequire.False(t, waitForPluginRegistrationStatus(t, p.registrationStatus))\n\t}()\n\n\tw := newWatcherWithHandler(t, hdlr, false /* testDeprecatedDir */)"
  },
  {
    "id" : "d5055e21-7234-4a6f-b6a1-8b7458453e51",
    "prId" : 64660,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/64660#pullrequestreview-129259909",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "eed27b5a-6d0e-4ab9-880f-3e1bdd48ee82",
        "parentId" : null,
        "authorId" : "ac146833-f0d6-4680-968a-749269c0d55d",
        "body" : "Why does this need to be in a goroutine?",
        "createdAt" : "2018-06-13T15:32:55Z",
        "updatedAt" : "2018-06-26T00:33:25Z",
        "lastEditedBy" : "ac146833-f0d6-4680-968a-749269c0d55d",
        "tags" : [
        ]
      },
      {
        "id" : "2485e5b0-7684-47b5-9ef6-877190e96306",
        "parentId" : "eed27b5a-6d0e-4ab9-880f-3e1bdd48ee82",
        "authorId" : "bc94d261-7b05-4d36-85d9-895265d6df26",
        "body" : "it is just a way to wait two events without order, the alternative would be: wait one first, and wait another which is not optimal.",
        "createdAt" : "2018-06-14T01:33:04Z",
        "updatedAt" : "2018-06-26T00:33:25Z",
        "lastEditedBy" : "bc94d261-7b05-4d36-85d9-895265d6df26",
        "tags" : [
        ]
      },
      {
        "id" : "a17e3010-5dd9-4751-bf88-8310b1cafd24",
        "parentId" : "eed27b5a-6d0e-4ab9-880f-3e1bdd48ee82",
        "authorId" : "ac146833-f0d6-4680-968a-749269c0d55d",
        "body" : "sounds good",
        "createdAt" : "2018-06-15T17:39:58Z",
        "updatedAt" : "2018-06-26T00:33:25Z",
        "lastEditedBy" : "ac146833-f0d6-4680-968a-749269c0d55d",
        "tags" : [
        ]
      }
    ],
    "commit" : "d04f5968293293668c675ef6c76439b37afe790f",
    "line" : 273,
    "diffHunk" : "@@ -1,1 +167,171 @@\tvar csiStatus string\n\tgo func() {\n\t\tdpStatus = strconv.FormatBool(waitForPluginRegistrationStatus(t, dp.registrationStatus))\n\t\twg.Done()\n\t}()"
  },
  {
    "id" : "b45c550b-71b9-4897-affa-b5c6d3afc4ac",
    "prId" : 64660,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/64660#pullrequestreview-130672920",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "81d87aeb-a672-4e9e-a43a-2bcccf08506c",
        "parentId" : null,
        "authorId" : "51f59c69-efc0-451a-bd8f-d9fa2c281fd3",
        "body" : "Why this is required to be `False`? Why plugin registration is not expected? \r\nAhh, nevermind. due to empty endpoint. ignore this comment.",
        "createdAt" : "2018-06-21T05:41:03Z",
        "updatedAt" : "2018-06-26T00:33:25Z",
        "lastEditedBy" : "51f59c69-efc0-451a-bd8f-d9fa2c281fd3",
        "tags" : [
        ]
      }
    ],
    "commit" : "d04f5968293293668c675ef6c76439b37afe790f",
    "line" : 153,
    "diffHunk" : "@@ -1,1 +62,66 @@\tp := NewTestExamplePlugin(PluginName, registerapi.DevicePlugin, \"\")\n\trequire.NoError(t, p.Serve(socketPath))\n\trequire.False(t, waitForPluginRegistrationStatus(t, p.registrationStatus))\n\trequire.NoError(t, p.Stop())\n"
  },
  {
    "id" : "67a75c20-9b2c-4e49-b500-f46a91d24ff7",
    "prId" : 64660,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/64660#pullrequestreview-132747901",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d590b3c0-57a0-4f87-bf75-0db16fd6e476",
        "parentId" : null,
        "authorId" : "51f59c69-efc0-451a-bd8f-d9fa2c281fd3",
        "body" : "Why successful registration is not expected in this case? \r\nPurpose of existing goroutine is to have a channel open in `waitForPluginRegistrationStatus`, which will be written into eventually during registration process. By removing goroutine, registration process is timed out on waiting for channel.",
        "createdAt" : "2018-06-21T05:48:06Z",
        "updatedAt" : "2018-06-26T00:33:25Z",
        "lastEditedBy" : "51f59c69-efc0-451a-bd8f-d9fa2c281fd3",
        "tags" : [
        ]
      },
      {
        "id" : "58f81de2-824b-49c1-b4ad-5b9fcb6be7f4",
        "parentId" : "d590b3c0-57a0-4f87-bf75-0db16fd6e476",
        "authorId" : "bc94d261-7b05-4d36-85d9-895265d6df26",
        "body" : "this is two questions, \r\nto answer the first question, the example handler has been modified to know which plugin name already registered, so when a plugin been restarted (watcher does not), it try to register again with same name, it will getting an error from handler.\r\n\r\ncould you clarify a little bit for the second question:\r\nthe plugin gRPC server is always there until p.Stop() been called,\r\nso `waitForPluginRegistrationStatus` should work fine, my test does shows working fine, thanks\r\n\r\n",
        "createdAt" : "2018-06-22T00:34:44Z",
        "updatedAt" : "2018-06-26T00:33:25Z",
        "lastEditedBy" : "bc94d261-7b05-4d36-85d9-895265d6df26",
        "tags" : [
        ]
      },
      {
        "id" : "46688c44-a55d-43e9-bd20-aa6f1f0f1d07",
        "parentId" : "d590b3c0-57a0-4f87-bf75-0db16fd6e476",
        "authorId" : "51f59c69-efc0-451a-bd8f-d9fa2c281fd3",
        "body" : "> to answer the first question, the example handler has been modified to know which plugin name already registered, so when a plugin been restarted (watcher does not), it try to register again with same name, it will getting an error from handler.\r\n\r\n@figo at L#77 plugin is stopped. Should not this unregister it? and if yes, registration at L79 should not fail? WDYT?",
        "createdAt" : "2018-06-28T04:20:32Z",
        "updatedAt" : "2018-06-28T04:20:38Z",
        "lastEditedBy" : "51f59c69-efc0-451a-bd8f-d9fa2c281fd3",
        "tags" : [
        ]
      },
      {
        "id" : "3e9f0c61-f275-4de2-9210-8b727a3a8a6a",
        "parentId" : "d590b3c0-57a0-4f87-bf75-0db16fd6e476",
        "authorId" : "bc94d261-7b05-4d36-85d9-895265d6df26",
        "body" : "@vikaschoudhary16 thanks for take a good again, please correct me if my understand is wrong since this change is based on your change, \r\n\r\nPluginWatcher and handler does not handle unregistration at this moment, i saw you are actively discuss it at #64637,  before unregistration been implemented, L77 will not trigger anything.\r\n\r\nand this change introduced a change on example handler:  each handler will remember registered plugin names,\r\n\r\nwhen L79 trigger a registration process, \r\nhandler will return error of \"plugin name already exist\".\r\n\r\nonce unregistration been implemented, this test do need be updated.\r\n\r\n ",
        "createdAt" : "2018-06-28T05:12:13Z",
        "updatedAt" : "2018-06-28T05:12:14Z",
        "lastEditedBy" : "bc94d261-7b05-4d36-85d9-895265d6df26",
        "tags" : [
        ]
      },
      {
        "id" : "6acd50d5-3a1f-4eb7-8358-009920bc086c",
        "parentId" : "d590b3c0-57a0-4f87-bf75-0db16fd6e476",
        "authorId" : "51f59c69-efc0-451a-bd8f-d9fa2c281fd3",
        "body" : "/lgtm\r\nmake sense. Thanks!",
        "createdAt" : "2018-06-28T08:55:56Z",
        "updatedAt" : "2018-06-28T08:55:57Z",
        "lastEditedBy" : "51f59c69-efc0-451a-bd8f-d9fa2c281fd3",
        "tags" : [
        ]
      }
    ],
    "commit" : "d04f5968293293668c675ef6c76439b37afe790f",
    "line" : 174,
    "diffHunk" : "@@ -1,1 +77,81 @@\trequire.NoError(t, p.Stop())\n\trequire.Nil(t, p.Serve(socketPath))\n\trequire.False(t, waitForPluginRegistrationStatus(t, p.registrationStatus))\n\n\t// Starting another plugin with the same name got verification error."
  }
]
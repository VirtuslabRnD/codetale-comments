[
  {
    "id" : "c274f111-59b0-454a-b117-67325295b046",
    "prId" : 5748,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d3663a5f-d208-4760-bd8a-e13e3ac30ac8",
        "parentId" : null,
        "authorId" : "b7abca6a-d6be-4008-a014-3b5ca0e90529",
        "body" : "Sorry, this one is unfixed from one of my PRs: instead of newPods and updatedPods should be podSyncTypes\n",
        "createdAt" : "2015-03-23T17:40:10Z",
        "updatedAt" : "2015-03-23T22:13:57Z",
        "lastEditedBy" : "b7abca6a-d6be-4008-a014-3b5ca0e90529",
        "tags" : [
        ]
      },
      {
        "id" : "4eb15721-7da0-4023-996c-b057df1dce6b",
        "parentId" : "d3663a5f-d208-4760-bd8a-e13e3ac30ac8",
        "authorId" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "body" : "Nope, this is only used by testing to simply set the internal pods. We still use UpdatePods in real code. I added a comment to clarify this.\n",
        "createdAt" : "2015-03-23T18:50:41Z",
        "updatedAt" : "2015-03-23T22:13:57Z",
        "lastEditedBy" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "tags" : [
        ]
      },
      {
        "id" : "8a3ad606-1718-4442-9fcc-9486d4d28f06",
        "parentId" : "d3663a5f-d208-4760-bd8a-e13e3ac30ac8",
        "authorId" : "b7abca6a-d6be-4008-a014-3b5ca0e90529",
        "body" : "Sorry, I meant that the comment was incorrect :) there is no newPods and updatedPods, only a podSyncTypes\n",
        "createdAt" : "2015-03-23T18:54:53Z",
        "updatedAt" : "2015-03-23T22:13:57Z",
        "lastEditedBy" : "b7abca6a-d6be-4008-a014-3b5ca0e90529",
        "tags" : [
        ]
      }
    ],
    "commit" : "f4409890178636db36abd98661e160e18879736a",
    "line" : 68,
    "diffHunk" : "@@ -1,1 +66,70 @@\n// Update the internal pods with those provided by the update.\n// Records new and updated pods in newPods and updatedPods.\nfunc (self *basicPodManager) UpdatePods(u PodUpdate, podSyncTypes map[types.UID]metrics.SyncPodType) {\n\tself.lock.Lock()"
  },
  {
    "id" : "38ce115a-92f2-4a8c-a136-da92d50b59ad",
    "prId" : 5748,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "151cf569-d025-44f2-894c-f188a446f650",
        "parentId" : null,
        "authorId" : "b7abca6a-d6be-4008-a014-3b5ca0e90529",
        "body" : "I think we need to lock around here since the type is thread-compatible and we can update the mirror pods while its working (it doesn't today in practice because it is called by the same thread, but that my not always be true)\n",
        "createdAt" : "2015-03-23T17:40:13Z",
        "updatedAt" : "2015-03-23T22:13:57Z",
        "lastEditedBy" : "b7abca6a-d6be-4008-a014-3b5ca0e90529",
        "tags" : [
        ]
      },
      {
        "id" : "925eca28-23a5-4169-a3a6-15872f82c1cf",
        "parentId" : "151cf569-d025-44f2-894c-f188a446f650",
        "authorId" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "body" : "Yes and no. \n\nIn kubelet, a copy of pods and mirrorPods are passed to `SyncPods()`. These copies are read-only and no one modifies it. We simply pass the read-only copy to `DeleteOrphanedMirrorPods` to avoid any lock acquiring. I added a comment here to clarify.\n",
        "createdAt" : "2015-03-23T18:54:59Z",
        "updatedAt" : "2015-03-23T22:13:57Z",
        "lastEditedBy" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "tags" : [
        ]
      },
      {
        "id" : "5889a8c5-6fe2-4b72-b59c-f4759c6336bf",
        "parentId" : "151cf569-d025-44f2-894c-f188a446f650",
        "authorId" : "b7abca6a-d6be-4008-a014-3b5ca0e90529",
        "body" : "Ah I see now. No need for the comment, just me being dumb, but we'll keep since we have it.\n",
        "createdAt" : "2015-03-23T19:23:16Z",
        "updatedAt" : "2015-03-23T22:13:57Z",
        "lastEditedBy" : "b7abca6a-d6be-4008-a014-3b5ca0e90529",
        "tags" : [
        ]
      }
    ],
    "commit" : "f4409890178636db36abd98661e160e18879736a",
    "line" : null,
    "diffHunk" : "@@ -1,1 +185,189 @@// because it assumes the a copy of the mirrorPod is passed as an argument.\nfunc (self *basicPodManager) DeleteOrphanedMirrorPods(mirrorPods *mirrorPods) {\n\tpodFullNames := mirrorPods.GetOrphanedMirrorPodNames()\n\tfor _, podFullName := range podFullNames {\n\t\tself.mirrorManager.DeleteMirrorPod(podFullName)"
  }
]
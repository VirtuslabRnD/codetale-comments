[
  {
    "id" : "426a5db7-ef53-4e51-b09d-a2c23a6493e7",
    "prId" : 87933,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/87933#pullrequestreview-360814747",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6fb3d151-9f27-4b2a-a87e-72d0e6e8bf7d",
        "parentId" : null,
        "authorId" : "9f030d50-62db-4b00-a28c-847709b74d97",
        "body" : "Note that it is possible to write past the limit. Imagine 2 write requests coming in simultaneously with only a few bytes left in the limit, both read the same limit, write their output, and then subtract from that limit. The end result is the limit has been passed.\r\n\r\nIf you care, you could use a `CompareAndSwapInt64` call to decrement the limit before writing to the delegate, but i'm not sure it's worth the trouble...",
        "createdAt" : "2020-02-19T02:23:17Z",
        "updatedAt" : "2020-02-19T02:24:16Z",
        "lastEditedBy" : "9f030d50-62db-4b00-a28c-847709b74d97",
        "tags" : [
        ]
      },
      {
        "id" : "f29a18de-c7fc-47ef-901f-7d7f1edf1fd7",
        "parentId" : "6fb3d151-9f27-4b2a-a87e-72d0e6e8bf7d",
        "authorId" : "aefa6d0d-0ad0-4062-966c-ddc56e70652b",
        "body" : "Yes, you're right. I intended to keep this implementation simple, especially given that the LimitBytes API doesn't guarantee a hard limit (only a soft one). I don't think it's worth the trouble/complexity to implement a hard limit here.",
        "createdAt" : "2020-02-19T03:01:15Z",
        "updatedAt" : "2020-02-19T03:01:16Z",
        "lastEditedBy" : "aefa6d0d-0ad0-4062-966c-ddc56e70652b",
        "tags" : [
        ]
      }
    ],
    "commit" : "0e178f9341405d974bc493c75a4188b83f2ba189",
    "line" : 29,
    "diffHunk" : "@@ -1,1 +408,412 @@\t\treturn 0, nil\n\t}\n\tlimit := atomic.LoadInt64(w.limit)\n\tif limit <= 0 {\n\t\treturn 0, errMaximumWrite"
  },
  {
    "id" : "0f7de594-3dee-402a-b523-6269868fbf6a",
    "prId" : 46236,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/46236#pullrequestreview-62199320",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b9689347-6800-46b0-8485-5dde29950785",
        "parentId" : null,
        "authorId" : "8e9f49fc-1050-4601-b81c-83bf660c5eb8",
        "body" : "Why is `/.docker` on the search path?",
        "createdAt" : "2017-09-12T02:17:28Z",
        "updatedAt" : "2017-09-12T02:17:28Z",
        "lastEditedBy" : "8e9f49fc-1050-4601-b81c-83bf660c5eb8",
        "tags" : [
        ]
      },
      {
        "id" : "aeadcb6b-4a44-4691-ad80-a0a8f5216385",
        "parentId" : "b9689347-6800-46b0-8485-5dde29950785",
        "authorId" : "e04b6e5f-a5f2-46ec-809d-3141642b1b3c",
        "body" : "It's there to be compatible with `pkg/credentialprovider/config.go:DefaultDockercfgPaths`, the other place that uses docker config to pull images. IIRC, putting docker config in `/` was a common enough (anti?) pattern to warrant support.",
        "createdAt" : "2017-09-12T16:59:59Z",
        "updatedAt" : "2017-09-12T16:59:59Z",
        "lastEditedBy" : "e04b6e5f-a5f2-46ec-809d-3141642b1b3c",
        "tags" : [
        ]
      }
    ],
    "commit" : "d44c458a194d89c6044e7de2c7d3f369c7e00967",
    "line" : 20,
    "diffHunk" : "@@ -1,1 +378,382 @@// ensureSandboxImageExists pulls the sandbox image when it's not present.\nfunc ensureSandboxImageExists(client libdocker.Interface, image string) error {\n\tdockerCfgSearchPath := []string{\"/.docker\", filepath.Join(os.Getenv(\"HOME\"), \".docker\")}\n\treturn ensureSandboxImageExistsDockerCfg(client, image, dockerCfgSearchPath)\n}"
  },
  {
    "id" : "97c40c7d-ddd4-4f45-b09e-d8aac3b3cfc7",
    "prId" : 34811,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/34811#pullrequestreview-7352350",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d30c5393-614a-4271-b6ab-587cb437529c",
        "parentId" : null,
        "authorId" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "body" : "Might as well handle this TODO now that #33663 has merged, IMO.\n",
        "createdAt" : "2016-11-06T22:58:08Z",
        "updatedAt" : "2016-11-07T03:41:32Z",
        "lastEditedBy" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "tags" : [
        ]
      },
      {
        "id" : "16b6db42-320c-41dc-8fa5-b8bc5e10a048",
        "parentId" : "d30c5393-614a-4271-b6ab-587cb437529c",
        "authorId" : "0df1da34-610c-4ce5-b0cf-bbda668bf9c1",
        "body" : "@pmorie Already handled this at [here](https://github.com/kubernetes/kubernetes/pull/34811/files#diff-44f60dd6d99cb695e5f333647ebd0703R250), here's todo should be removed.\n",
        "createdAt" : "2016-11-07T03:15:01Z",
        "updatedAt" : "2016-11-07T03:41:32Z",
        "lastEditedBy" : "0df1da34-610c-4ce5-b0cf-bbda668bf9c1",
        "tags" : [
        ]
      }
    ],
    "commit" : "f8e5f81fedd5243b9d7f690a9c0738794db15899",
    "line" : null,
    "diffHunk" : "@@ -1,1 +134,138 @@\t\t// the container's randomly allocated MCS label. This would restrict access\n\t\t// to the volume to the container which mounts it first.\n\t\tif m.GetSelinuxRelabel() {\n\t\t\tif readOnly {\n\t\t\t\tbind += \",Z\""
  },
  {
    "id" : "88e0b011-9944-4d17-9f5f-d56e7b83a463",
    "prId" : 32835,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/32835#pullrequestreview-389044",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "cf9307af-9960-408d-bcb4-40021b8b5c21",
        "parentId" : null,
        "authorId" : "0df1da34-610c-4ce5-b0cf-bbda668bf9c1",
        "body" : "do we need to make `annotationPrefix` longer, e.g. `io.kubernetes.annotation.`?\n",
        "createdAt" : "2016-09-16T03:21:32Z",
        "updatedAt" : "2016-09-16T18:31:30Z",
        "lastEditedBy" : "0df1da34-610c-4ce5-b0cf-bbda668bf9c1",
        "tags" : [
        ]
      },
      {
        "id" : "a63c2725-ed41-43ad-8cfa-10e432105d49",
        "parentId" : "cf9307af-9960-408d-bcb4-40021b8b5c21",
        "authorId" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "body" : "We can do that, but I was afraid that this would grow too long. E.g., the annotation key could be `io.kubernetes.terminationmessage`. After this, it becomes `io.kubernetes.annotation.io.kubernetes.terminationmessage`\n",
        "createdAt" : "2016-09-16T16:53:46Z",
        "updatedAt" : "2016-09-16T18:31:30Z",
        "lastEditedBy" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "tags" : [
        ]
      }
    ],
    "commit" : "73f30b18e4c4fe08a666cbd8abff4e04c4fa0c6f",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +32,36 @@\nconst (\n\tannotationPrefix = \"annotation.\"\n)\n"
  },
  {
    "id" : "c48ad430-aca5-4622-a983-380e168f5ab9",
    "prId" : 29553,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d95a7af6-f1fd-4fb8-a42a-4b4953be604e",
        "parentId" : null,
        "authorId" : "4e418bc8-21fb-4523-80c1-9c751c193126",
        "body" : "Port original comment here.\n",
        "createdAt" : "2016-07-28T00:05:03Z",
        "updatedAt" : "2016-07-28T01:30:32Z",
        "lastEditedBy" : "4e418bc8-21fb-4523-80c1-9c751c193126",
        "tags" : [
        ]
      },
      {
        "id" : "d0be1c5e-f2f7-4fc5-ba26-6cd517116931",
        "parentId" : "d95a7af6-f1fd-4fb8-a42a-4b4953be604e",
        "authorId" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "body" : "done.\n",
        "createdAt" : "2016-07-28T00:55:56Z",
        "updatedAt" : "2016-07-28T01:30:32Z",
        "lastEditedBy" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "tags" : [
        ]
      }
    ],
    "commit" : "03d11bcf4e5fce9acc5a9de1d00edb0a734d4871",
    "line" : null,
    "diffHunk" : "@@ -1,1 +58,62 @@// '<HostPath>:<ContainerPath>:Z', if the volume requires SELinux\n// relabeling and the pod provides an SELinux label\nfunc generateMountBindings(mounts []*runtimeApi.Mount) (result []string) {\n\t// TODO: resolve podHasSELinuxLabel\n\tfor _, m := range mounts {"
  }
]
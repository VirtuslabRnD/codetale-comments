[
  {
    "id" : "c5f54b5e-020a-4cba-8ab9-4b07a1f21d7b",
    "prId" : 25896,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8e962c2f-cbc0-4c1b-9f72-1f054c707b23",
        "parentId" : null,
        "authorId" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "body" : "@vishh @smarterclayton \n",
        "createdAt" : "2016-05-19T19:25:23Z",
        "updatedAt" : "2016-05-19T19:25:23Z",
        "lastEditedBy" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "tags" : [
        ]
      },
      {
        "id" : "848f3fe2-73a7-45b0-83cc-2e765fb42fa7",
        "parentId" : "8e962c2f-cbc0-4c1b-9f72-1f054c707b23",
        "authorId" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "body" : "LGTM\n",
        "createdAt" : "2016-05-19T20:28:10Z",
        "updatedAt" : "2016-05-19T20:28:10Z",
        "lastEditedBy" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "tags" : [
        ]
      }
    ],
    "commit" : "b57fbee557a5c006c30e24bd851c4f2583b4ecb7",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +1414,1418 @@\nfunc (dm *DockerManager) applyOOMScoreAdj(container *api.Container, containerInfo *dockertypes.ContainerJSON) error {\n\tif containerInfo.State.Pid == 0 {\n\t\t// Container exited. We cannot do anything about it. Ignore this error.\n\t\tglog.V(2).Infof(\"Failed to apply OOM score adj on container %q with ID %q. Init process does not exist.\", containerInfo.Name, containerInfo.ID)"
  },
  {
    "id" : "aec8440d-1ac9-48c2-a6b4-c631ff6389d9",
    "prId" : 25324,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "00dd7b03-a6c5-4e17-92fa-80179f747b5a",
        "parentId" : null,
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "Should this really be the compacted file content or the filename itself? Compare https://docs.docker.com/engine/security/seccomp/\n",
        "createdAt" : "2016-06-08T10:20:45Z",
        "updatedAt" : "2016-06-08T10:20:45Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      },
      {
        "id" : "d1892f65-3b66-46f3-84fe-a9897e357fba",
        "parentId" : "00dd7b03-a6c5-4e17-92fa-80179f747b5a",
        "authorId" : "b15d5707-82a8-4448-b49d-a2d6502b10f9",
        "body" : "Yes it needs to be the file contents. The docker cli takes a file name,\nreads its contents, and transmits the contents to the daemon.\n\nOn Wednesday, June 8, 2016, Dr. Stefan Schimanski notifications@github.com\nwrote:\n\n> In pkg/kubelet/dockertools/manager.go\n> https://github.com/kubernetes/kubernetes/pull/25324#discussion_r66230042\n> :\n> \n> > +\n> > -   if !strings.HasPrefix(profile, \"localhost\") {\n> > -       return nil, fmt.Errorf(\"unknown seccomp profile option: %s\", profile)\n> > -   }\n> >   +\n> > -   file, err := ioutil.ReadFile(filepath.Join(dm.seccompProfileRoot, strings.TrimPrefix(profile, \"localhost/\")))\n> > -   if err != nil {\n> > -       return nil, err\n> > -   }\n> >   +\n> > -   b := bytes.NewBuffer(nil)\n> > -   if err := json.Compact(b, file); err != nil {\n> > -       return nil, err\n> > -   }\n> >   +\n> > -   return []string{fmt.Sprintf(\"seccomp=%s\", b.Bytes())}, nil\n> \n> Should this really be the compacted file content or the filename itself?\n> Compare https://docs.docker.com/engine/security/seccomp/\n> \n> —\n> You are receiving this because you commented.\n> Reply to this email directly, view it on GitHub\n> https://github.com/kubernetes/kubernetes/pull/25324/files/aa8c72adaaab6cba51ff868516ac5b423a95f069#r66230042,\n> or mute the thread\n> https://github.com/notifications/unsubscribe/AAABYoMSK4m547F8EFFS3otQ56-RjCKAks5qJpe1gaJpZM4IZwJt\n> .\n",
        "createdAt" : "2016-06-08T10:49:58Z",
        "updatedAt" : "2016-06-08T10:49:58Z",
        "lastEditedBy" : "b15d5707-82a8-4448-b49d-a2d6502b10f9",
        "tags" : [
        ]
      }
    ],
    "commit" : "aa8c72adaaab6cba51ff868516ac5b423a95f069",
    "line" : 119,
    "diffHunk" : "@@ -1,1 +1028,1032 @@\t}\n\n\treturn []string{fmt.Sprintf(\"seccomp=%s\", b.Bytes())}, nil\n}\n"
  },
  {
    "id" : "6ab2d91c-960b-426c-b764-dd9dd37f15af",
    "prId" : 25324,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "288803dc-1e3e-4c83-af03-959e37065317",
        "parentId" : null,
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "Do we check anywhere that profile is not equal to `localhost/../../../../dev/mem`?\n",
        "createdAt" : "2016-06-08T10:36:22Z",
        "updatedAt" : "2016-06-08T10:36:37Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      }
    ],
    "commit" : "aa8c72adaaab6cba51ff868516ac5b423a95f069",
    "line" : 109,
    "diffHunk" : "@@ -1,1 +1018,1022 @@\t}\n\n\tfile, err := ioutil.ReadFile(filepath.Join(dm.seccompProfileRoot, strings.TrimPrefix(profile, \"localhost/\")))\n\tif err != nil {\n\t\treturn nil, err"
  },
  {
    "id" : "891a4eaa-d0bb-476f-9fb4-fa596cd93e25",
    "prId" : 24843,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "88b9a449-a04d-4fbb-ad8f-ebc44283e402",
        "parentId" : null,
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Godoc on why no one should use gracePeriodOverride \n",
        "createdAt" : "2016-04-29T18:52:50Z",
        "updatedAt" : "2016-05-06T16:14:52Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      }
    ],
    "commit" : "7bab6999d408a120f962841f4ca1dd37b80f2490",
    "line" : null,
    "diffHunk" : "@@ -1,1 +1296,1300 @@// during hard eviction scenarios.  All other code paths in kubelet must never provide a grace period override otherwise\n// data corruption could occur in the end-user application.\nfunc (dm *DockerManager) killContainer(containerID kubecontainer.ContainerID, container *api.Container, pod *api.Pod, reason string, gracePeriodOverride *int64) error {\n\tID := containerID.ID\n\tname := ID"
  },
  {
    "id" : "76b1353a-7a38-4e78-b41b-64b21e440136",
    "prId" : 24836,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "dc43d40c-df4b-48f2-841b-6308f0935a7d",
        "parentId" : null,
        "authorId" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "body" : "What happens in docker if I have privileged and I want to use hostPath to map in the whole /dev directory?  Does that work?\n",
        "createdAt" : "2016-05-03T22:57:26Z",
        "updatedAt" : "2016-05-09T23:20:23Z",
        "lastEditedBy" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "tags" : [
        ]
      },
      {
        "id" : "1037942f-deab-4170-a3f0-0bac2e24b7c5",
        "parentId" : "dc43d40c-df4b-48f2-841b-6308f0935a7d",
        "authorId" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "body" : "@erictune that should work. If you are \"privileged\", you get to access all devices.\n",
        "createdAt" : "2016-05-03T23:02:46Z",
        "updatedAt" : "2016-05-09T23:20:23Z",
        "lastEditedBy" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "tags" : [
        ]
      }
    ],
    "commit" : "362c763fca4c7c6c148532c6f4e68422899b5297",
    "line" : 15,
    "diffHunk" : "@@ -1,1 +585,589 @@\tif nvidiaGPULimit.Value() != 0 {\n\t\t// Experimental. For now, we hardcode /dev/nvidia0 no matter what the user asks for\n\t\t// (we only support one device per node).\n\t\tdevices = []dockercontainer.DeviceMapping{\n\t\t\t{\"/dev/nvidia0\", \"/dev/nvidia0\", \"mrw\"},"
  },
  {
    "id" : "72b10c0a-108b-434c-a392-aee8bc76fa86",
    "prId" : 24836,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "82b0701b-7b58-40b3-85a7-22df0966614b",
        "parentId" : null,
        "authorId" : "227eb550-8b08-4420-9a78-279f840bd8de",
        "body" : "@alban @iaguis @jonboulle So what we need to do here for rkt?\nBesides adding those mount path and add capabilities?\n",
        "createdAt" : "2016-05-09T18:53:05Z",
        "updatedAt" : "2016-05-09T23:20:23Z",
        "lastEditedBy" : "227eb550-8b08-4420-9a78-279f840bd8de",
        "tags" : [
        ]
      },
      {
        "id" : "d20b0b97-c72b-4ea0-bbc1-bd9702b1e743",
        "parentId" : "82b0701b-7b58-40b3-85a7-22df0966614b",
        "authorId" : "227eb550-8b08-4420-9a78-279f840bd8de",
        "body" : "Also cc @euank @tmrts  @sjpotter\n",
        "createdAt" : "2016-05-10T18:51:58Z",
        "updatedAt" : "2016-05-10T18:51:58Z",
        "lastEditedBy" : "227eb550-8b08-4420-9a78-279f840bd8de",
        "tags" : [
        ]
      },
      {
        "id" : "6593a756-77af-4caa-88dc-f8e422e1ee35",
        "parentId" : "82b0701b-7b58-40b3-85a7-22df0966614b",
        "authorId" : "2fa5a4c6-e0a7-4dbe-a80e-7770a5dc92a1",
        "body" : "As a datapoint, I manually verified that a gpu bindmount in rkt worked (prior to capabilities working though; 1.3 or 1.4 iirc). That implies to me that gpu bindmounting should work if we grant sufficient capabilities. Things that might matter: it should be mode `crw-rw-----` or thereabouts (which bindmounting accomplishes correctly for me on recent rkt 1.5). We might have to do some fiddling with `cgroup/devices/devices.{allow,deny}` as well, but I think we currently don't touch either so that too should just work.\n",
        "createdAt" : "2016-05-10T22:06:13Z",
        "updatedAt" : "2016-05-10T22:06:13Z",
        "lastEditedBy" : "2fa5a4c6-e0a7-4dbe-a80e-7770a5dc92a1",
        "tags" : [
        ]
      },
      {
        "id" : "3ac0bd97-4495-4db1-8d92-45dab28ff507",
        "parentId" : "82b0701b-7b58-40b3-85a7-22df0966614b",
        "authorId" : "227eb550-8b08-4420-9a78-279f840bd8de",
        "body" : "@euank Cool, I am going to create an issue tracking this. maybe for rktnetes 1.1?\n",
        "createdAt" : "2016-05-11T04:31:40Z",
        "updatedAt" : "2016-05-11T04:31:40Z",
        "lastEditedBy" : "227eb550-8b08-4420-9a78-279f840bd8de",
        "tags" : [
        ]
      },
      {
        "id" : "d0ccfb3c-ac34-4779-9574-e8c04346b65e",
        "parentId" : "82b0701b-7b58-40b3-85a7-22df0966614b",
        "authorId" : "4c30e665-5e6c-4a02-81a0-563b610a6d75",
        "body" : "I don't know. it looks like it to me.\n",
        "createdAt" : "2016-05-11T09:58:04Z",
        "updatedAt" : "2016-05-11T09:58:17Z",
        "lastEditedBy" : "4c30e665-5e6c-4a02-81a0-563b610a6d75",
        "tags" : [
        ]
      }
    ],
    "commit" : "362c763fca4c7c6c148532c6f4e68422899b5297",
    "line" : 17,
    "diffHunk" : "@@ -1,1 +587,591 @@\t\t// (we only support one device per node).\n\t\tdevices = []dockercontainer.DeviceMapping{\n\t\t\t{\"/dev/nvidia0\", \"/dev/nvidia0\", \"mrw\"},\n\t\t\t{\"/dev/nvidiactl\", \"/dev/nvidiactl\", \"mrw\"},\n\t\t\t{\"/dev/nvidia-uvm\", \"/dev/nvidia-uvm\", \"mrw\"},"
  },
  {
    "id" : "85ce62c0-416d-40ca-8245-113210b33f05",
    "prId" : 23969,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "399056de-d6ba-4c11-8626-918b7936d8ce",
        "parentId" : null,
        "authorId" : "47ec15eb-72b4-4618-9e01-e3b37b6bac00",
        "body" : "Why is this needed?\n",
        "createdAt" : "2016-04-08T00:13:23Z",
        "updatedAt" : "2016-06-17T20:43:09Z",
        "lastEditedBy" : "47ec15eb-72b4-4618-9e01-e3b37b6bac00",
        "tags" : [
        ]
      },
      {
        "id" : "6413a879-c7f9-49b0-ae97-9c8fa4516dff",
        "parentId" : "399056de-d6ba-4c11-8626-918b7936d8ce",
        "authorId" : "4e418bc8-21fb-4523-80c1-9c751c193126",
        "body" : "This fixed the termination message path. (See #23658)\nOnly with it, the termination message path can work correctly, but unfortunately, it hasn't been merged.\nTo test termination message, we should let it work right first, so I cherry-pick that commit here. Will rebase after #23658 get merged.\n",
        "createdAt" : "2016-04-08T00:17:15Z",
        "updatedAt" : "2016-06-17T20:43:09Z",
        "lastEditedBy" : "4e418bc8-21fb-4523-80c1-9c751c193126",
        "tags" : [
        ]
      },
      {
        "id" : "277c124a-5e6b-4490-a29c-76c0170bc9af",
        "parentId" : "399056de-d6ba-4c11-8626-918b7936d8ce",
        "authorId" : "47ec15eb-72b4-4618-9e01-e3b37b6bac00",
        "body" : "Does this mean termination message was broken and your test caught it?\n",
        "createdAt" : "2016-04-08T00:24:15Z",
        "updatedAt" : "2016-06-17T20:43:09Z",
        "lastEditedBy" : "47ec15eb-72b4-4618-9e01-e3b37b6bac00",
        "tags" : [
        ]
      },
      {
        "id" : "733c7ae9-0717-46f3-99a2-57485d608f79",
        "parentId" : "399056de-d6ba-4c11-8626-918b7936d8ce",
        "authorId" : "4e418bc8-21fb-4523-80c1-9c751c193126",
        "body" : "I found it was broken before. The test proves that. :)\nWe don't have test for termination message before, in fact it was broken from 1.1, I just occasionally found it recently. With node e2e test, this tragedy would never happen again! :)\n",
        "createdAt" : "2016-04-08T00:34:19Z",
        "updatedAt" : "2016-06-17T20:43:09Z",
        "lastEditedBy" : "4e418bc8-21fb-4523-80c1-9c751c193126",
        "tags" : [
        ]
      }
    ],
    "commit" : "19f5a90528d42ea7dc2bb0271fe4de941d83c213",
    "line" : null,
    "diffHunk" : "@@ -1,1 +429,433 @@\t\tterminationMessagePath := containerInfo.TerminationMessagePath\n\t\tif terminationMessagePath != \"\" {\n\t\t\tfor _, mount := range iResult.Mounts {\n\t\t\t\tif mount.Destination == terminationMessagePath {\n\t\t\t\t\tpath := mount.Source"
  },
  {
    "id" : "c337acbd-b526-40dd-b484-5516fa10c28b",
    "prId" : 23907,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "14f3eaa0-10c0-4528-a4c0-681940807488",
        "parentId" : null,
        "authorId" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "body" : "I don't see where go-dockerclient uses the \"Logs\" option at all. Did I miss anything?\n",
        "createdAt" : "2016-04-21T16:46:42Z",
        "updatedAt" : "2016-04-21T19:03:01Z",
        "lastEditedBy" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "tags" : [
        ]
      },
      {
        "id" : "53be9804-64aa-450c-9455-8d5c19c4867a",
        "parentId" : "14f3eaa0-10c0-4528-a4c0-681940807488",
        "authorId" : "4e418bc8-21fb-4523-80c1-9c751c193126",
        "body" : "`Logs` is an argument in docker remote api https://docs.docker.com/engine/reference/api/docker_remote_api_v1.22/#attach-to-a-container, go-dockerclient only needs to accept it and encoding it into json.\n\nFYI, I have a issue for this https://github.com/kubernetes/kubernetes/issues/24070.\n",
        "createdAt" : "2016-04-21T18:37:44Z",
        "updatedAt" : "2016-04-21T19:03:01Z",
        "lastEditedBy" : "4e418bc8-21fb-4523-80c1-9c751c193126",
        "tags" : [
        ]
      }
    ],
    "commit" : "d981fee2ee1b880cc9f720a93ea85936959c440a",
    "line" : 247,
    "diffHunk" : "@@ -1,1 +1063,1067 @@\nfunc (dm *DockerManager) AttachContainer(containerID kubecontainer.ContainerID, stdin io.Reader, stdout, stderr io.WriteCloser, tty bool) error {\n\t// TODO(random-liu): Do we really use the *Logs* field here?\n\topts := dockertypes.ContainerAttachOptions{\n\t\tStream: true,"
  },
  {
    "id" : "be181ca1-6410-4a28-b075-bf2ad1aaf520",
    "prId" : 23800,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3119ec4a-6293-4222-b134-bb6023401b54",
        "parentId" : null,
        "authorId" : "698f4eb2-501b-44f5-9ff2-a2d82e9ac4f7",
        "body" : "If you want the default docker behavior of \"remove all the untagged images when the last tag is gone\" you must set the `PruneChildren` bool argument to `true`.\n\nSee [here](https://github.com/docker/swarm/pull/1982/commits/1e22226b71c43f6698ce617ca3f544650091d61d#diff-a28a4b7a97d2368507318a8565e27ff2R481) for how I set it in docker/swarm.\n",
        "createdAt" : "2016-04-22T17:53:36Z",
        "updatedAt" : "2016-04-23T14:36:07Z",
        "lastEditedBy" : "698f4eb2-501b-44f5-9ff2-a2d82e9ac4f7",
        "tags" : [
        ]
      }
    ],
    "commit" : "a3939473d3a3973df5708880ea32f9cedeae5310",
    "line" : 23,
    "diffHunk" : "@@ -1,1 +822,826 @@func (dm *DockerManager) RemoveImage(image kubecontainer.ImageSpec) error {\n\t// TODO(harryz) currently Runtime interface does not provide other remove options.\n\t_, err := dm.client.RemoveImage(image.Image, dockertypes.ImageRemoveOptions{})\n\treturn err\n}"
  },
  {
    "id" : "4b460320-6d6b-49d6-b7eb-9be6f5354824",
    "prId" : 23699,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "af0db695-abc5-4366-b36c-bb428f04ffd9",
        "parentId" : null,
        "authorId" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "body" : "Does this commit include your terminationMessagePath fix? \n",
        "createdAt" : "2016-03-31T23:37:39Z",
        "updatedAt" : "2016-04-15T00:05:57Z",
        "lastEditedBy" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "tags" : [
        ]
      },
      {
        "id" : "430ac2f3-92b9-4756-9abd-20512c979428",
        "parentId" : "af0db695-abc5-4366-b36c-bb428f04ffd9",
        "authorId" : "4e418bc8-21fb-4523-80c1-9c751c193126",
        "body" : "Yeah, we could close that one. I didn't expect the submit queue working so slow. =..=\n",
        "createdAt" : "2016-03-31T23:41:56Z",
        "updatedAt" : "2016-04-15T00:05:57Z",
        "lastEditedBy" : "4e418bc8-21fb-4523-80c1-9c751c193126",
        "tags" : [
        ]
      },
      {
        "id" : "c2c4a8a5-02f4-42f8-a06d-9a340592fbdc",
        "parentId" : "af0db695-abc5-4366-b36c-bb428f04ffd9",
        "authorId" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "body" : "I'd prefer getting that one in separately though since it's a bug fix. \n",
        "createdAt" : "2016-03-31T23:44:45Z",
        "updatedAt" : "2016-04-15T00:05:57Z",
        "lastEditedBy" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "tags" : [
        ]
      }
    ],
    "commit" : "d3d98b372b461002cccdcc72ab0fd674a5f4aa0f",
    "line" : null,
    "diffHunk" : "@@ -1,1 +416,420 @@\t\tterminationMessagePath := containerInfo.TerminationMessagePath\n\t\tif terminationMessagePath != \"\" {\n\t\t\tfor _, mount := range iResult.Mounts {\n\t\t\t\tif mount.Destination == terminationMessagePath {\n\t\t\t\t\tpath := mount.Source"
  },
  {
    "id" : "9460df0e-53b3-414a-bf79-6cc6502edfa5",
    "prId" : 23567,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "475aa371-4ecc-4017-8823-fe50d259a69e",
        "parentId" : null,
        "authorId" : "395f4f9a-98be-4485-b436-51f0897d7c9f",
        "body" : "each invocation of SyncPod will only start one container, and there's a lag between invocations? Or did I miss a for loop somewhere here. \n\nI think this runs in a podworker goroutine, if that's the case we should just be able to wait for all init's to start/exit synchrounsly?\n",
        "createdAt" : "2016-04-08T20:41:25Z",
        "updatedAt" : "2016-05-17T04:30:20Z",
        "lastEditedBy" : "395f4f9a-98be-4485-b436-51f0897d7c9f",
        "tags" : [
        ]
      },
      {
        "id" : "512de1f2-c289-41ec-b449-4c7edd00fc98",
        "parentId" : "475aa371-4ecc-4017-8823-fe50d259a69e",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Yeah, PLEG will drive sync loop, so we'll start (then exit), then get\ntriggered by the complete from the PLEG, then record that we started and\nstart the next one, etc.  If we started synchronously we would block PLEG\nevents, so this is the more natural way within the current pod worker (it's\nnot adding latency, since PLEG gives us just in time invocation).\n\nOn Fri, Apr 8, 2016 at 4:41 PM, Prashanth B notifications@github.com\nwrote:\n\n> In pkg/kubelet/dockertools/manager.go\n> https://github.com/kubernetes/kubernetes/pull/23567#discussion_r59086268\n> :\n> \n> > @@ -1861,7 +1972,94 @@ func (dm *DockerManager) SyncPod(pod *api.Pod, _ api.PodStatus, podStatus *kubec\n> >         }\n> >     }\n> > -   // Start everything\n> > -   next, status, done := findActiveInitContainer(pod, podStatus)\n> \n> each invocation of SyncPod will only start one container, and there's a\n> lag between invocations? Or did I miss a for loop somewhere here.\n> \n> I think this runs in a podworker goroutine, if that's the case we should\n> just be able to wait for all init's to start/exit synchrounsly?\n> \n> —\n> You are receiving this because you were mentioned.\n> Reply to this email directly or view it on GitHub\n> https://github.com/kubernetes/kubernetes/pull/23567/files/21f0e955e3f1d05950fed76280c28d3e81d90742..ad7a96fe3b9dda804fee77e41f7e14ad0b4513d7#r59086268\n",
        "createdAt" : "2016-04-13T00:47:03Z",
        "updatedAt" : "2016-05-17T04:30:20Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      }
    ],
    "commit" : "2a53330700ac39ee61109c748fe665cf38581a5d",
    "line" : 206,
    "diffHunk" : "@@ -1,1 +1968,1972 @@\t}\n\n\tnext, status, done := findActiveInitContainer(pod, podStatus)\n\tif status != nil {\n\t\tif status.ExitCode != 0 {"
  },
  {
    "id" : "c11a5301-1810-49ba-90b4-dffed8dd098b",
    "prId" : 23567,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c51760b5-6892-4d34-9ad4-bc6bd172d866",
        "parentId" : null,
        "authorId" : "395f4f9a-98be-4485-b436-51f0897d7c9f",
        "body" : "Why are we checking this here? the init containers are immutable so we should never ignore backoff right? \n",
        "createdAt" : "2016-04-08T20:41:27Z",
        "updatedAt" : "2016-05-17T04:30:20Z",
        "lastEditedBy" : "395f4f9a-98be-4485-b436-51f0897d7c9f",
        "tags" : [
        ]
      },
      {
        "id" : "0de714ae-48cf-454c-827f-114cb4c2f2d7",
        "parentId" : "c51760b5-6892-4d34-9ad4-bc6bd172d866",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Old comment, will remove.\n\nOn Fri, Apr 8, 2016 at 4:41 PM, Prashanth B notifications@github.com\nwrote:\n\n> In pkg/kubelet/dockertools/manager.go\n> https://github.com/kubernetes/kubernetes/pull/23567#discussion_r59086271\n> :\n> \n> > -   }\n> >   +\n> > -   if next != nil {\n> > -       if len(containerChanges.ContainersToStart) == 0 {\n> > -           glog.V(2).Infof(\"No containers to start, stopping at init container %+v in pod %v\", next.Name, format.Pod(pod))\n> > -           return\n> > -       }\n> >   +\n> > -       // If we need to start the next container, do so now then exit\n> > -       container := next\n> > -       startContainerResult := kubecontainer.NewSyncResult(kubecontainer.StartContainer, container.Name)\n> > -       result.AddSyncResult(startContainerResult)\n> >   +\n> > -       // containerChanges.StartInfraContainer causes the containers to be restarted for config reasons\n> > -       // ignore backoff\n> > -       if !containerChanges.StartInfraContainer {\n> \n> Why are we checking this here? the init containers are immutable so we\n> should never ignore backoff right?\n> \n> —\n> You are receiving this because you were mentioned.\n> Reply to this email directly or view it on GitHub\n> https://github.com/kubernetes/kubernetes/pull/23567/files/21f0e955e3f1d05950fed76280c28d3e81d90742..ad7a96fe3b9dda804fee77e41f7e14ad0b4513d7#r59086271\n",
        "createdAt" : "2016-04-13T00:45:59Z",
        "updatedAt" : "2016-05-17T04:30:20Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "71f0a796-6d3c-431a-a3a3-3e64825eda0c",
        "parentId" : "c51760b5-6892-4d34-9ad4-bc6bd172d866",
        "authorId" : "395f4f9a-98be-4485-b436-51f0897d7c9f",
        "body" : "remove ?\n",
        "createdAt" : "2016-05-05T02:22:03Z",
        "updatedAt" : "2016-05-17T04:30:20Z",
        "lastEditedBy" : "395f4f9a-98be-4485-b436-51f0897d7c9f",
        "tags" : [
        ]
      }
    ],
    "commit" : "2a53330700ac39ee61109c748fe665cf38581a5d",
    "line" : null,
    "diffHunk" : "@@ -1,1 +2002,2006 @@\n\t\t// containerChanges.StartInfraContainer causes the containers to be restarted for config reasons\n\t\tif !containerChanges.StartInfraContainer {\n\t\t\tisInBackOff, err, msg := dm.doBackOff(pod, container, podStatus, backOff)\n\t\t\tif isInBackOff {"
  },
  {
    "id" : "34509a8a-53a1-431d-961f-e022d9ee9447",
    "prId" : 22241,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "163248ad-0808-4b56-8503-5e346a48f23c",
        "parentId" : null,
        "authorId" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "body" : "nit: add a comment explaining that you are looking for the most recent exited container.\n",
        "createdAt" : "2016-03-02T00:21:32Z",
        "updatedAt" : "2016-03-02T01:37:11Z",
        "lastEditedBy" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "tags" : [
        ]
      },
      {
        "id" : "7a98db3f-cfc3-4f4c-ac1c-10447f1e0bb7",
        "parentId" : "163248ad-0808-4b56-8503-5e346a48f23c",
        "authorId" : "4e418bc8-21fb-4523-80c1-9c751c193126",
        "body" : "ACK\n",
        "createdAt" : "2016-03-02T00:26:17Z",
        "updatedAt" : "2016-03-02T01:37:11Z",
        "lastEditedBy" : "4e418bc8-21fb-4523-80c1-9c751c193126",
        "tags" : [
        ]
      }
    ],
    "commit" : "a88dad1c3e6c7d1042f2c60fcf2e561e5a3a1717",
    "line" : null,
    "diffHunk" : "@@ -1,1 +1953,1957 @@\t// Use the finished time of the latest exited container as the start point to calculate whether to do back-off.\n\t// TODO(random-liu): Better define backoff start point; add unit and e2e test after we finalize this. (See github issue #22240)\n\tfor _, c := range podStatus.ContainerStatuses {\n\t\tif c.Name == container.Name && c.State == kubecontainer.ContainerStateExited {\n\t\t\tcStatus = c"
  },
  {
    "id" : "0c1a8c06-8101-48a3-9ded-4f8c2de2620e",
    "prId" : 22241,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "63476e14-6d2c-4715-b702-25ecae31548a",
        "parentId" : null,
        "authorId" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "body" : "nit: Is this check no longer required? - `!containerStatus.FinishedAt.IsZero()`?\n",
        "createdAt" : "2016-03-02T20:27:20Z",
        "updatedAt" : "2016-03-02T20:27:20Z",
        "lastEditedBy" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "tags" : [
        ]
      },
      {
        "id" : "948e9b2e-1c3f-4111-a645-36b7ad336f74",
        "parentId" : "63476e14-6d2c-4715-b702-25ecae31548a",
        "authorId" : "4e418bc8-21fb-4523-80c1-9c751c193126",
        "body" : "In the [original PR](https://github.com/kubernetes/kubernetes/pull/12648/files#diff-0db82891d463ba14dd59da9c77f4776eR1835), `FinishedAt.IsZero()` is used to check whether container status is found in the previous loop. I kept it before just in case, but in fact it is not required now. :)\n",
        "createdAt" : "2016-03-02T21:13:38Z",
        "updatedAt" : "2016-03-02T21:13:38Z",
        "lastEditedBy" : "4e418bc8-21fb-4523-80c1-9c751c193126",
        "tags" : [
        ]
      }
    ],
    "commit" : "a88dad1c3e6c7d1042f2c60fcf2e561e5a3a1717",
    "line" : 17,
    "diffHunk" : "@@ -1,1 +1960,1964 @@\t}\n\tif cStatus != nil {\n\t\tts := cStatus.FinishedAt\n\t\t// found a container that requires backoff\n\t\tdockerName := KubeletContainerName{"
  },
  {
    "id" : "74f44d71-7545-4346-879d-76e83826f553",
    "prId" : 21790,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "61b63878-c543-44d4-bf48-f863394a755d",
        "parentId" : null,
        "authorId" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "body" : "`err` is unused?\n",
        "createdAt" : "2016-02-23T23:00:37Z",
        "updatedAt" : "2016-02-24T18:26:30Z",
        "lastEditedBy" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "tags" : [
        ]
      },
      {
        "id" : "df22d1cc-7aa5-4fc2-a410-60a423201b05",
        "parentId" : "61b63878-c543-44d4-bf48-f863394a755d",
        "authorId" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "body" : "I re-used existing code :( Adding a check for err here.\n",
        "createdAt" : "2016-02-24T00:39:15Z",
        "updatedAt" : "2016-02-24T18:26:30Z",
        "lastEditedBy" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "tags" : [
        ]
      }
    ],
    "commit" : "5db37b0b2da33330ed80c0fc553ef43d1e085070",
    "line" : 64,
    "diffHunk" : "@@ -1,1 +957,961 @@\t}\n\t// seccomp is to be disabled on docker versions >= v1.10\n\tresult, err := version.Compare(dockerV110APIVersion)\n\tif err != nil {\n\t\treturn nil, err"
  },
  {
    "id" : "4d2a8651-a001-47eb-96af-8aa37cbe8d2c",
    "prId" : 21790,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "00322db1-05ba-4283-8e01-94761b047b5f",
        "parentId" : null,
        "authorId" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "body" : "nit: add a comment explaining this is the api version of docker v1.10 (just because I had some trouble parsing V110 when I first saw it).\n",
        "createdAt" : "2016-02-23T23:00:40Z",
        "updatedAt" : "2016-02-24T18:26:30Z",
        "lastEditedBy" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "tags" : [
        ]
      },
      {
        "id" : "e75ed98c-47d5-4bad-8556-5e85b8cb144e",
        "parentId" : "00322db1-05ba-4283-8e01-94761b047b5f",
        "authorId" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "body" : "Adding comments.\n",
        "createdAt" : "2016-02-24T00:40:25Z",
        "updatedAt" : "2016-02-24T18:26:30Z",
        "lastEditedBy" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "tags" : [
        ]
      }
    ],
    "commit" : "5db37b0b2da33330ed80c0fc553ef43d1e085070",
    "line" : null,
    "diffHunk" : "@@ -1,1 +83,87 @@\t// Remote API version for docker daemon version v1.10\n\t// https://docs.docker.com/engine/reference/api/docker_remote_api/\n\tdockerV110APIVersion = \"1.22\"\n)\n"
  },
  {
    "id" : "1d555f6d-c0c7-4ce5-9318-e3c04c51a499",
    "prId" : 21741,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3e5ebbf5-ec1e-4040-9b70-cde52560e239",
        "parentId" : null,
        "authorId" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "body" : "nit: Did you rebase? https://github.com/kubernetes/kubernetes/pull/21790/files already introduced version check for docker v1.10\n",
        "createdAt" : "2016-03-02T22:17:58Z",
        "updatedAt" : "2016-04-13T04:47:35Z",
        "lastEditedBy" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "tags" : [
        ]
      }
    ],
    "commit" : "c31ec5607ac9a47c4ddf9ecbaa4c4c5bc4857f84",
    "line" : null,
    "diffHunk" : "@@ -1,1 +64,68 @@\tminimumDockerAPIVersion = \"1.20\"\n\n\tdockerv110APIVersion = \"1.21\"\n\n\t// ndots specifies the minimum number of dots that a domain name must contain for the resolver to consider it as FQDN (fully-qualified)"
  },
  {
    "id" : "2c1a0679-a2b4-41fc-bd3e-df110dd91450",
    "prId" : 20954,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b71ba1b0-6c76-4cbe-a717-8b4e3a958b20",
        "parentId" : null,
        "authorId" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "body" : "The fix lgtm. However, it's easy for new bugs to creep in. Maybe we should invest more time to prevent that.\n",
        "createdAt" : "2016-02-10T17:57:01Z",
        "updatedAt" : "2016-02-10T17:57:01Z",
        "lastEditedBy" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "tags" : [
        ]
      },
      {
        "id" : "1968626a-27a8-4fd4-a50e-8bf2715ce911",
        "parentId" : "b71ba1b0-6c76-4cbe-a717-8b4e3a958b20",
        "authorId" : "4e418bc8-21fb-4523-80c1-9c751c193126",
        "body" : "Yeah, it would be better if we could think of a less intrusive way to do this, or else people don't quite understand this may easily miss it.\n",
        "createdAt" : "2016-02-10T18:28:46Z",
        "updatedAt" : "2016-02-10T18:28:46Z",
        "lastEditedBy" : "4e418bc8-21fb-4523-80c1-9c751c193126",
        "tags" : [
        ]
      },
      {
        "id" : "535eb519-eaa5-4d6e-abcd-f4ec716d98e7",
        "parentId" : "b71ba1b0-6c76-4cbe-a717-8b4e3a958b20",
        "authorId" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "body" : "I think these all go down to the fact that `SyncPod` is a huge function that does millions things. The best way, IMO, to handle this is to separate out each action/func, and wrap each func with something like\n\n```\n    result := kubecontainer.NewSyncResult(kubecontainer.StartContainer, container.Name)\n    defer func() {\n        if err != nil {\n            result.Fail(err, msg) \n        }           \n    }()\n    err, msg  = func() {\n       // Actual work\n       return kubecontainer.ErrRunContainer, err.Error()\n    }\n```\n",
        "createdAt" : "2016-02-10T21:57:25Z",
        "updatedAt" : "2016-02-10T21:57:25Z",
        "lastEditedBy" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "tags" : [
        ]
      },
      {
        "id" : "6cd59b5b-abd4-4741-942e-174a85e3bef0",
        "parentId" : "b71ba1b0-6c76-4cbe-a717-8b4e3a958b20",
        "authorId" : "4e418bc8-21fb-4523-80c1-9c751c193126",
        "body" : "Yeah. I'll have a try later. :)\n",
        "createdAt" : "2016-02-11T00:15:38Z",
        "updatedAt" : "2016-02-11T00:15:38Z",
        "lastEditedBy" : "4e418bc8-21fb-4523-80c1-9c751c193126",
        "tags" : [
        ]
      }
    ],
    "commit" : "b7292f66724cc2a7ea180c2a995f3dcec58908d0",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +1205,1209 @@\t\t\terr = fmt.Errorf(\"Error inspecting container %v: %v\", networkContainer.ID.ID, err)\n\t\t\tglog.Error(err)\n\t\t\tresult.Fail(err)\n\t\t\treturn\n\t\t}"
  },
  {
    "id" : "a98546ff-679a-4bc1-bcda-a2e10409dabe",
    "prId" : 20615,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8692692d-d1cf-4f67-8e68-4559ca4a4a39",
        "parentId" : null,
        "authorId" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "body" : "Might want to explicitly point out that this is not the docker container id\n",
        "createdAt" : "2016-02-04T22:10:06Z",
        "updatedAt" : "2016-02-04T23:35:24Z",
        "lastEditedBy" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "tags" : [
        ]
      },
      {
        "id" : "c854cdcb-ae8e-4ae1-9ba4-d13ae97e1631",
        "parentId" : "8692692d-d1cf-4f67-8e68-4559ca4a4a39",
        "authorId" : "4e418bc8-21fb-4523-80c1-9c751c193126",
        "body" : "ACK.\n",
        "createdAt" : "2016-02-04T22:13:20Z",
        "updatedAt" : "2016-02-04T23:35:24Z",
        "lastEditedBy" : "4e418bc8-21fb-4523-80c1-9c751c193126",
        "tags" : [
        ]
      }
    ],
    "commit" : "8118092d11e35cc7fffec50e7a93f2727b0a2802",
    "line" : 51,
    "diffHunk" : "@@ -1,1 +691,695 @@\tif opts.PodContainerDir != \"\" && len(container.TerminationMessagePath) != 0 {\n\t\t// Because the PodContainerDir contains pod uid and container name which is unique enough,\n\t\t// here we just add an unique container id to make the path unique for different instances\n\t\t// of the same container.\n\t\t// Notice that the \"container id\" is just a unique number generated in BuildDockerName(),"
  },
  {
    "id" : "83050cc7-b90d-427f-b3d4-a07a91518eee",
    "prId" : 20020,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fb034bc2-65fc-4474-8545-a81e57e5a618",
        "parentId" : null,
        "authorId" : "f81960f6-a033-4403-bebf-c8ebb484e444",
        "body" : "@dchen1107 | @vishh ?\n",
        "createdAt" : "2016-01-22T22:19:59Z",
        "updatedAt" : "2016-01-23T01:15:54Z",
        "lastEditedBy" : "f81960f6-a033-4403-bebf-c8ebb484e444",
        "tags" : [
        ]
      },
      {
        "id" : "8f798eef-96c3-4ffc-b806-6d7c9e62d275",
        "parentId" : "fb034bc2-65fc-4474-8545-a81e57e5a618",
        "authorId" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "body" : "A TODO is OK for now, although a subsequent refactoring PR would be much appreciated :)\n",
        "createdAt" : "2016-01-22T22:42:13Z",
        "updatedAt" : "2016-01-23T01:15:54Z",
        "lastEditedBy" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "tags" : [
        ]
      },
      {
        "id" : "4fa515e7-1f11-428d-a72c-4330610fb66b",
        "parentId" : "fb034bc2-65fc-4474-8545-a81e57e5a618",
        "authorId" : "d73d9d81-a5c8-4de5-a4be-626e5ab82041",
        "body" : "I can. Wanted to call it out, but wanted this change in in short order.\n",
        "createdAt" : "2016-01-22T22:44:30Z",
        "updatedAt" : "2016-01-23T01:15:54Z",
        "lastEditedBy" : "d73d9d81-a5c8-4de5-a4be-626e5ab82041",
        "tags" : [
        ]
      },
      {
        "id" : "59467e0f-df3b-47f3-9489-d39f702b8982",
        "parentId" : "fb034bc2-65fc-4474-8545-a81e57e5a618",
        "authorId" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "body" : "SGTM!\n\nOn Fri, Jan 22, 2016 at 2:45 PM, Ken Robertson notifications@github.com\nwrote:\n\n> In pkg/kubelet/dockertools/manager.go\n> https://github.com/kubernetes/kubernetes/pull/20020#discussion_r50601433\n> :\n> \n> > @@ -944,18 +945,47 @@ func (dm *DockerManager) podInfraContainerChanged(pod *api.Pod, podInfraContaine\n> >     return podInfraContainerStatus.Hash != kubecontainer.HashContainer(expectedPodInfraContainer), nil\n> >  }\n> > \n> > -type dockerVersion docker.APIVersion\n> > +// dockerVersion implementes kubecontainer.Version interface by implementing\n> > +// Compare() and String() (which is implemented by the underlying semver.Version)\n> > +// TODO: this code is the same as rktVersion and may make sense to be moved to\n> \n> I can. Wanted to call it out, but wanted this change in in short order.\n> \n> —\n> Reply to this email directly or view it on GitHub\n> https://github.com/kubernetes/kubernetes/pull/20020/files#r50601433.\n",
        "createdAt" : "2016-01-22T22:46:22Z",
        "updatedAt" : "2016-01-23T01:15:54Z",
        "lastEditedBy" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "tags" : [
        ]
      }
    ],
    "commit" : "66c99d5e9c01c5eef9b4ce195564e1221ba75379",
    "line" : 15,
    "diffHunk" : "@@ -1,1 +948,952 @@// dockerVersion implementes kubecontainer.Version interface by implementing\n// Compare() and String() (which is implemented by the underlying semver.Version)\n// TODO: this code is the same as rktVersion and may make sense to be moved to\n// somewhere shared.\ntype dockerVersion struct {"
  },
  {
    "id" : "a05d8a79-e5fc-46ef-a6a0-1e3cb784de3f",
    "prId" : 20020,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d692fe4f-746d-4ff7-a779-a1c117cadfa5",
        "parentId" : null,
        "authorId" : "f81960f6-a033-4403-bebf-c8ebb484e444",
        "body" : "I don't know the semantics of Compare operation, but returning -1 on the error seems kind of odd to me, where others return 0. \n",
        "createdAt" : "2016-01-22T22:24:32Z",
        "updatedAt" : "2016-01-23T01:15:54Z",
        "lastEditedBy" : "f81960f6-a033-4403-bebf-c8ebb484e444",
        "tags" : [
        ]
      },
      {
        "id" : "b0205608-f142-4ca0-a546-ff47aa018977",
        "parentId" : "d692fe4f-746d-4ff7-a779-a1c117cadfa5",
        "authorId" : "d73d9d81-a5c8-4de5-a4be-626e5ab82041",
        "body" : "The `rktVersion` struct does the same: https://github.com/kubernetes/kubernetes/blob/master/pkg/kubelet/rkt/version.go#L45\n\nAny preference on what to do? I'd go either way.\n",
        "createdAt" : "2016-01-22T22:46:35Z",
        "updatedAt" : "2016-01-23T01:15:54Z",
        "lastEditedBy" : "d73d9d81-a5c8-4de5-a4be-626e5ab82041",
        "tags" : [
        ]
      }
    ],
    "commit" : "66c99d5e9c01c5eef9b4ce195564e1221ba75379",
    "line" : 32,
    "diffHunk" : "@@ -1,1 +965,969 @@\tv, err := semver.NewVersion(other)\n\tif err != nil {\n\t\treturn -1, err\n\t}\n"
  },
  {
    "id" : "8cf24459-0cb1-467d-974d-699b211b3065",
    "prId" : 20020,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "90178fea-6951-4aa5-8004-4e0aea7d5f89",
        "parentId" : null,
        "authorId" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "body" : "@thockin: You favorite `semver` :)\n",
        "createdAt" : "2016-01-22T22:39:44Z",
        "updatedAt" : "2016-01-23T01:15:54Z",
        "lastEditedBy" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "tags" : [
        ]
      }
    ],
    "commit" : "66c99d5e9c01c5eef9b4ce195564e1221ba75379",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +32,36 @@\t\"time\"\n\n\t\"github.com/coreos/go-semver/semver\"\n\tdocker \"github.com/fsouza/go-dockerclient\"\n\t\"github.com/golang/glog\""
  },
  {
    "id" : "4e701636-5357-463f-9a78-d53da01086d2",
    "prId" : 20019,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d75cdede-fc18-4760-a5d8-5c10ebd547e8",
        "parentId" : null,
        "authorId" : "395f4f9a-98be-4485-b436-51f0897d7c9f",
        "body" : "you have access to the pod.Spec here too right?\n",
        "createdAt" : "2016-01-27T16:11:46Z",
        "updatedAt" : "2016-01-27T23:43:40Z",
        "lastEditedBy" : "395f4f9a-98be-4485-b436-51f0897d7c9f",
        "tags" : [
        ]
      },
      {
        "id" : "23837183-78da-4106-a1ab-cb3e6d4676e6",
        "parentId" : "d75cdede-fc18-4760-a5d8-5c10ebd547e8",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "pod might be nil.  I could test if it is not and use that instead, but why bother?\n",
        "createdAt" : "2016-01-27T23:25:19Z",
        "updatedAt" : "2016-01-27T23:43:40Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "fe2aa020-cf48-4da8-91c6-3b04e12f944e",
        "parentId" : "d75cdede-fc18-4760-a5d8-5c10ebd547e8",
        "authorId" : "4e418bc8-21fb-4523-80c1-9c751c193126",
        "body" : "The pod could be nil indeed, when kubelet deletes a pod without pod spec (For example cleanup a unkown pod). Although it is wired but it really happens to kubelet now. I didn't notice that before and it took me some time to debug...\n",
        "createdAt" : "2016-02-02T09:29:38Z",
        "updatedAt" : "2016-02-02T09:53:56Z",
        "lastEditedBy" : "4e418bc8-21fb-4523-80c1-9c751c193126",
        "tags" : [
        ]
      }
    ],
    "commit" : "df4c1ccd14acc4977fbc15170c0cd07ceb0cc538",
    "line" : 45,
    "diffHunk" : "@@ -1,1 +1337,1341 @@\t}\n\tif networkContainer != nil {\n\t\tins, err := dm.client.InspectContainer(networkContainer.ID.ID)\n\t\tif err != nil {\n\t\t\tglog.Errorf(\"Error inspecting container %v: %v\", networkContainer.ID.ID, err)"
  },
  {
    "id" : "064040e1-bde9-45de-808d-3cfdaf1483c0",
    "prId" : 20019,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e545d74a-4ee3-4c31-8329-e29adce1d774",
        "parentId" : null,
        "authorId" : "57f729dd-988a-4d1a-83bf-ee70bf637c64",
        "body" : "All the Hairpin mode stuff can go under the !HostNetwork check too, since it's only relevant when there is pod networking.\n\nAnd the dm.determineContainerIP() too, since the pod won't have an IP address when it's using host networking, right?\n",
        "createdAt" : "2016-01-27T16:31:23Z",
        "updatedAt" : "2016-01-27T23:43:40Z",
        "lastEditedBy" : "57f729dd-988a-4d1a-83bf-ee70bf637c64",
        "tags" : [
        ]
      },
      {
        "id" : "bb4d0d2f-2bc5-4f73-9e57-4c23decf29f8",
        "parentId" : "e545d74a-4ee3-4c31-8329-e29adce1d774",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "hairpin is already guarded\n\ncontainerIP is the hostIP in this case\n",
        "createdAt" : "2016-01-27T23:37:01Z",
        "updatedAt" : "2016-01-27T23:43:40Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "d61bc66b-3c88-402b-ab37-bf034709f551",
        "parentId" : "e545d74a-4ee3-4c31-8329-e29adce1d774",
        "authorId" : "57f729dd-988a-4d1a-83bf-ee70bf637c64",
        "body" : "determineContainerIP() here cannot possibly return any interesting result here for two reasons:\n\n1) if the network plugin wasn't called to set up the container, it seems really odd to ask the network plugin for the containers IP address.  Yes, this might work, but is really weird.\n\n2) docker '--net=host' doesn't report any IP address for the container, so plugins that chain up to DockerManager.GetContainerIP() won't return anything either.\n\n # sudo docker run --net=host -it dcbw/fedora-net /bin/bash\n...\n # sudo docker inspect 0a0685f13f6c | grep \"NetworkMode\\|IPAddress\"\n        \"IPAddress\": \"\",\n        \"SecondaryIPAddresses\": null,\n        \"NetworkMode\": \"host\",\n\nwhile the patch LGTM now, I think there's definitely room for further optimization.  I'm happy to do that if you like.\n",
        "createdAt" : "2016-01-28T19:58:17Z",
        "updatedAt" : "2016-01-28T19:58:43Z",
        "lastEditedBy" : "57f729dd-988a-4d1a-83bf-ee70bf637c64",
        "tags" : [
        ]
      }
    ],
    "commit" : "df4c1ccd14acc4977fbc15170c0cd07ceb0cc538",
    "line" : 135,
    "diffHunk" : "@@ -1,1 +1927,1931 @@\t\t}\n\n\t\t// Setup the host interface unless the pod is on the host's network (FIXME: move to networkPlugin when ready)\n\t\tvar podInfraContainer *docker.Container\n\t\tpodInfraContainer, err = dm.client.InspectContainer(string(podInfraContainerID))"
  },
  {
    "id" : "73f791d2-b7ce-4bbd-afa1-104c80ab9de7",
    "prId" : 19675,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "eb00d451-100e-4b0c-b9e3-13bf1ffd3b78",
        "parentId" : null,
        "authorId" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "body" : "Can we instead update the `container.Version` interface to provide both API and engine version?\n",
        "createdAt" : "2016-01-19T19:16:28Z",
        "updatedAt" : "2016-01-21T00:43:00Z",
        "lastEditedBy" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "tags" : [
        ]
      },
      {
        "id" : "6da075be-076a-451c-8b7f-87ce91551593",
        "parentId" : "eb00d451-100e-4b0c-b9e3-13bf1ffd3b78",
        "authorId" : "d73d9d81-a5c8-4de5-a4be-626e5ab82041",
        "body" : "Sure, should I just have rkt report its own version?\n",
        "createdAt" : "2016-01-19T19:31:42Z",
        "updatedAt" : "2016-01-21T00:43:00Z",
        "lastEditedBy" : "d73d9d81-a5c8-4de5-a4be-626e5ab82041",
        "tags" : [
        ]
      },
      {
        "id" : "4e878e0b-5aaf-4493-a899-b843dfc5e815",
        "parentId" : "eb00d451-100e-4b0c-b9e3-13bf1ffd3b78",
        "authorId" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "body" : "Yes.\n\nOn Tue, Jan 19, 2016 at 11:32 AM, Ken Robertson notifications@github.com\nwrote:\n\n> In pkg/kubelet/dockertools/manager.go\n> https://github.com/kubernetes/kubernetes/pull/19675#discussion_r50162131\n> :\n> \n> > @@ -979,11 +979,26 @@ func (dm *DockerManager) Version() (kubecontainer.Version, error) {\n> >         return nil, fmt.Errorf(\"docker: failed to get docker version: %v\", err)\n> >     }\n> > -   engineVersion := env.Get(\"Version\")\n> > -   version, err := docker.NewAPIVersion(engineVersion)\n> > -   if err != nil {\n> > -       glog.Errorf(\"docker: failed to parse docker server version %q: %v\", engineVersion, err)\n> > -       return nil, fmt.Errorf(\"docker: failed to parse docker server version %q: %v\", engineVersion, err)\n> > -   }\n> > -   return dockerVersion(version), nil\n> >   +}\n> >   +\n> >   +func (dm *DockerManager) APIVersion() (kubecontainer.Version, error) {\n> \n> Sure, should I just have rkt report its own version?\n> \n> —\n> Reply to this email directly or view it on GitHub\n> https://github.com/kubernetes/kubernetes/pull/19675/files#r50162131.\n",
        "createdAt" : "2016-01-19T19:34:44Z",
        "updatedAt" : "2016-01-21T00:43:00Z",
        "lastEditedBy" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "tags" : [
        ]
      }
    ],
    "commit" : "a7b07c01df197d40c677709d953ad0d538d49b75",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +990,994 @@}\n\nfunc (dm *DockerManager) APIVersion() (kubecontainer.Version, error) {\n\tenv, err := dm.client.Version()\n\tif err != nil {"
  },
  {
    "id" : "ca5289c9-5f29-49bd-9166-35de49148f32",
    "prId" : 18172,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b4a07101-beb3-4846-979a-b669b5081388",
        "parentId" : null,
        "authorId" : "227eb550-8b08-4420-9a78-279f840bd8de",
        "body" : "@Random-Liu It's not your fault, but we need to remove `wg.Add(1)` in to loop and use `wg.Add(len(runningPod.Containers)` prior to the loop, because otherwise it will make race detector angry for go 1.5. See https://groups.google.com/forum/#!topic/golang-nuts/W5fol0e4qt8\nand https://groups.google.com/forum/#!topic/golang-nuts/q7gmFZEF618\n\ncc @yujuhong \n",
        "createdAt" : "2015-12-29T21:02:30Z",
        "updatedAt" : "2016-01-17T08:43:08Z",
        "lastEditedBy" : "227eb550-8b08-4420-9a78-279f840bd8de",
        "tags" : [
        ]
      },
      {
        "id" : "a20d2fe2-838e-40a5-93b5-c05756a93d16",
        "parentId" : "b4a07101-beb3-4846-979a-b669b5081388",
        "authorId" : "4e418bc8-21fb-4523-80c1-9c751c193126",
        "body" : "I agree that `wg.Add(len(runningPod.Containers)` is better, but I didn't see any race in the current implementation. It seems that the links mainly told us that we should not do `Wait` when the wg could be `zero` at first, or could be `Add`ed soon after becoming zero.\nHowever, we are sure that `Wait` is called after the \"root\" `Add` here.\n",
        "createdAt" : "2015-12-29T23:25:52Z",
        "updatedAt" : "2016-01-17T08:43:08Z",
        "lastEditedBy" : "4e418bc8-21fb-4523-80c1-9c751c193126",
        "tags" : [
        ]
      },
      {
        "id" : "708a07b3-96df-4afc-b992-cff264cc7621",
        "parentId" : "b4a07101-beb3-4846-979a-b669b5081388",
        "authorId" : "227eb550-8b08-4420-9a78-279f840bd8de",
        "body" : "@Random-Liu You are right. Sorry, I misread the code :)\n",
        "createdAt" : "2015-12-30T00:57:48Z",
        "updatedAt" : "2016-01-17T08:43:08Z",
        "lastEditedBy" : "227eb550-8b08-4420-9a78-279f840bd8de",
        "tags" : [
        ]
      }
    ],
    "commit" : "0e612afa98402c9ef33dcf4b9cb27d0990276443",
    "line" : 43,
    "diffHunk" : "@@ -1,1 +1275,1279 @@\t}\n\twg.Wait()\n\tclose(containerResults)\n\tfor containerResult := range containerResults {\n\t\tresult.AddSyncResult(containerResult)"
  },
  {
    "id" : "5f9a8f97-2a97-4a26-9ea7-872052e56a76",
    "prId" : 18172,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5810e527-be61-4381-bf26-85bc36966fca",
        "parentId" : null,
        "authorId" : "4e418bc8-21fb-4523-80c1-9c751c193126",
        "body" : "Document the return value\n",
        "createdAt" : "2015-12-29T22:31:07Z",
        "updatedAt" : "2016-01-17T08:43:08Z",
        "lastEditedBy" : "4e418bc8-21fb-4523-80c1-9c751c193126",
        "tags" : [
        ]
      },
      {
        "id" : "81837770-49d1-49f1-b50e-73d89b7f5cbe",
        "parentId" : "5810e527-be61-4381-bf26-85bc36966fca",
        "authorId" : "227eb550-8b08-4420-9a78-279f840bd8de",
        "body" : "ditto: like createPodInfraContainer(), maybe just return (bool, SyncResult)?\n",
        "createdAt" : "2015-12-29T22:53:58Z",
        "updatedAt" : "2016-01-17T08:43:08Z",
        "lastEditedBy" : "227eb550-8b08-4420-9a78-279f840bd8de",
        "tags" : [
        ]
      }
    ],
    "commit" : "0e612afa98402c9ef33dcf4b9cb27d0990276443",
    "line" : null,
    "diffHunk" : "@@ -1,1 +2003,2007 @@// backoff deadline. However, because that won't cause error and the chance is really slim, we can just ignore it for now.\n// If a container is still in backoff, the function will return a brief backoff error and a detailed error message.\nfunc (dm *DockerManager) doBackOff(pod *api.Pod, container *api.Container, podStatus *kubecontainer.PodStatus, backOff *util.Backoff) (bool, error, string) {\n\tcontainerStatus := podStatus.FindContainerStatusByName(container.Name)\n\tif containerStatus != nil && containerStatus.State == kubecontainer.ContainerStateExited && !containerStatus.FinishedAt.IsZero() {"
  },
  {
    "id" : "74a6ca86-ddd8-405f-b810-c9b7db0bc7a2",
    "prId" : 18172,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f5bdbac0-dc63-42a3-a6f6-7ca0e1f318f7",
        "parentId" : null,
        "authorId" : "227eb550-8b08-4420-9a78-279f840bd8de",
        "body" : "nits: any reason for this change?\n",
        "createdAt" : "2015-12-29T22:50:04Z",
        "updatedAt" : "2016-01-17T08:43:08Z",
        "lastEditedBy" : "227eb550-8b08-4420-9a78-279f840bd8de",
        "tags" : [
        ]
      },
      {
        "id" : "e54455d0-0f6d-4998-a92b-db4602ecdd66",
        "parentId" : "f5bdbac0-dc63-42a3-a6f6-7ca0e1f318f7",
        "authorId" : "4e418bc8-21fb-4523-80c1-9c751c193126",
        "body" : "Inspect doesn't change anything, so it's more like a `SyncPod` error, not a specific sync action error. It's confusing...right?\n",
        "createdAt" : "2015-12-29T22:55:20Z",
        "updatedAt" : "2016-01-17T08:43:08Z",
        "lastEditedBy" : "4e418bc8-21fb-4523-80c1-9c751c193126",
        "tags" : [
        ]
      },
      {
        "id" : "84b58066-7d85-49ac-8c69-78384349db44",
        "parentId" : "f5bdbac0-dc63-42a3-a6f6-7ca0e1f318f7",
        "authorId" : "4e418bc8-21fb-4523-80c1-9c751c193126",
        "body" : "The `SyncResult` thing still needs some more thought, any suggestion or idea is welcome! :)\nI think the similar problem should also happen in rkt side implementation.\n",
        "createdAt" : "2015-12-29T22:57:41Z",
        "updatedAt" : "2016-01-17T08:43:08Z",
        "lastEditedBy" : "4e418bc8-21fb-4523-80c1-9c751c193126",
        "tags" : [
        ]
      }
    ],
    "commit" : "0e612afa98402c9ef33dcf4b9cb27d0990276443",
    "line" : 215,
    "diffHunk" : "@@ -1,1 +1862,1866 @@\n\t\t// Setup the host interface unless the pod is on the host's network (FIXME: move to networkPlugin when ready)\n\t\tvar podInfraContainer *docker.Container\n\t\tpodInfraContainer, err = dm.client.InspectContainer(string(podInfraContainerID))\n\t\tif err != nil {"
  },
  {
    "id" : "a75d59aa-87b2-4c79-8d88-f98697f85881",
    "prId" : 18172,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a9a1ac94-e851-4c01-80c2-2b00e8884d0d",
        "parentId" : null,
        "authorId" : "227eb550-8b08-4420-9a78-279f840bd8de",
        "body" : "Is this really necessary? Can we use a lock and do `result.AddSyncResult(containerResult)` in each goroutine?\n",
        "createdAt" : "2016-01-13T21:18:38Z",
        "updatedAt" : "2016-01-17T08:43:08Z",
        "lastEditedBy" : "227eb550-8b08-4420-9a78-279f840bd8de",
        "tags" : [
        ]
      },
      {
        "id" : "88806380-3e46-47e6-affc-95838a8c92bb",
        "parentId" : "a9a1ac94-e851-4c01-80c2-2b00e8884d0d",
        "authorId" : "4e418bc8-21fb-4523-80c1-9c751c193126",
        "body" : "At first I tried to avoid using a lock. But on second thought, I think you are right. If `SyncPodResult` is defined in \"container/\" and used in different runtimes, it is safer to add lock, because I don't know how they will use it.\n",
        "createdAt" : "2016-01-13T21:28:44Z",
        "updatedAt" : "2016-01-17T08:43:08Z",
        "lastEditedBy" : "4e418bc8-21fb-4523-80c1-9c751c193126",
        "tags" : [
        ]
      },
      {
        "id" : "a5d6c704-8615-4d4f-8282-6d7b9ef629dd",
        "parentId" : "a9a1ac94-e851-4c01-80c2-2b00e8884d0d",
        "authorId" : "227eb550-8b08-4420-9a78-279f840bd8de",
        "body" : "@Random-Liu Maybe you can just use a local lock in this function if you don't want to make the AddSyncResult thread safe\n",
        "createdAt" : "2016-01-13T21:38:43Z",
        "updatedAt" : "2016-01-17T08:43:08Z",
        "lastEditedBy" : "227eb550-8b08-4420-9a78-279f840bd8de",
        "tags" : [
        ]
      },
      {
        "id" : "29cbcae6-89d6-44ec-8002-a58e0e741041",
        "parentId" : "a9a1ac94-e851-4c01-80c2-2b00e8884d0d",
        "authorId" : "4e418bc8-21fb-4523-80c1-9c751c193126",
        "body" : "We may use `PodSyncResult` for a few different purposes in `kubelet`, it is a little annoying to add a lock in `PodSyncResult`. While there is no much difference using a local lock or a channel here, so I think I can just keep the channel for now. :)\n",
        "createdAt" : "2016-01-13T23:01:26Z",
        "updatedAt" : "2016-01-17T08:43:08Z",
        "lastEditedBy" : "4e418bc8-21fb-4523-80c1-9c751c193126",
        "tags" : [
        ]
      },
      {
        "id" : "1e62b3bd-eab1-47f5-afd9-f46691d604b9",
        "parentId" : "a9a1ac94-e851-4c01-80c2-2b00e8884d0d",
        "authorId" : "227eb550-8b08-4420-9a78-279f840bd8de",
        "body" : "ok\n",
        "createdAt" : "2016-01-20T17:36:29Z",
        "updatedAt" : "2016-01-20T17:36:29Z",
        "lastEditedBy" : "227eb550-8b08-4420-9a78-279f840bd8de",
        "tags" : [
        ]
      }
    ],
    "commit" : "0e612afa98402c9ef33dcf4b9cb27d0990276443",
    "line" : 16,
    "diffHunk" : "@@ -1,1 +1233,1237 @@\t// Send the kills in parallel since they may take a long time.\n\t// There may be len(runningPod.Containers) or len(runningPod.Containers)-1 of result in the channel\n\tcontainerResults := make(chan *kubecontainer.SyncResult, len(runningPod.Containers))\n\twg := sync.WaitGroup{}\n\tvar ("
  },
  {
    "id" : "f74d8849-6dad-48e1-bee1-754e50de67a4",
    "prId" : 17420,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8a513a17-681e-4207-816c-7211fac1511f",
        "parentId" : null,
        "authorId" : "227eb550-8b08-4420-9a78-279f840bd8de",
        "body" : "@Random-Liu @yujuhong Is there any particular reason for the pod status to have all exited the containers rather than the latest one?\n",
        "createdAt" : "2015-12-03T00:25:41Z",
        "updatedAt" : "2015-12-05T01:38:22Z",
        "lastEditedBy" : "227eb550-8b08-4420-9a78-279f840bd8de",
        "tags" : [
        ]
      },
      {
        "id" : "d27e2fc3-fdd4-44bc-ae27-39351fb4250e",
        "parentId" : "8a513a17-681e-4207-816c-7211fac1511f",
        "authorId" : "4e418bc8-21fb-4523-80c1-9c751c193126",
        "body" : "@yujuhong @yifan-gu It seems that we could really just keep the latest two now?\n",
        "createdAt" : "2015-12-03T00:36:48Z",
        "updatedAt" : "2015-12-05T01:38:22Z",
        "lastEditedBy" : "4e418bc8-21fb-4523-80c1-9c751c193126",
        "tags" : [
        ]
      },
      {
        "id" : "f010e764-8e2a-405c-a377-a09390558d15",
        "parentId" : "8a513a17-681e-4207-816c-7211fac1511f",
        "authorId" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "body" : "@yifan-gu, there is no reason to keep all for syncing pods. We still keep all of them because this is a representation of what we have on the node and it provides the flexibility of letting other components (e.g., GC?) consume this data in the future.\n",
        "createdAt" : "2015-12-03T01:30:30Z",
        "updatedAt" : "2015-12-05T01:38:22Z",
        "lastEditedBy" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "tags" : [
        ]
      },
      {
        "id" : "19902b78-d802-4384-9ead-871f59fa9ded",
        "parentId" : "8a513a17-681e-4207-816c-7211fac1511f",
        "authorId" : "4e418bc8-21fb-4523-80c1-9c751c193126",
        "body" : "Got it! :)\n",
        "createdAt" : "2015-12-03T01:32:36Z",
        "updatedAt" : "2015-12-05T01:38:22Z",
        "lastEditedBy" : "4e418bc8-21fb-4523-80c1-9c751c193126",
        "tags" : [
        ]
      },
      {
        "id" : "376cd65f-eafc-4c51-addc-4329e6e69293",
        "parentId" : "8a513a17-681e-4207-816c-7211fac1511f",
        "authorId" : "227eb550-8b08-4420-9a78-279f840bd8de",
        "body" : "ACK. So I think it's ok for rkt to just return one latest pod in this case.  But in gc, it can't know all the history container status merely by querying with pod UID then.\n\nAnyway this is because the docker gc runs at container level, I need to think about it.\n",
        "createdAt" : "2015-12-03T01:56:39Z",
        "updatedAt" : "2015-12-05T01:38:22Z",
        "lastEditedBy" : "227eb550-8b08-4420-9a78-279f840bd8de",
        "tags" : [
        ]
      }
    ],
    "commit" : "3cbdf79f8c5fc3f9e5c68633fd78f5d2e3ee152a",
    "line" : 615,
    "diffHunk" : "@@ -1,1 +2075,2079 @@\t\t\treturn podStatus, err\n\t\t}\n\t\tcontainerStatuses = append(containerStatuses, result)\n\t\tif ip != \"\" {\n\t\t\tpodStatus.IP = ip"
  },
  {
    "id" : "0ad93472-0da6-491b-a6a3-dbc704dcb35d",
    "prId" : 15965,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b07865de-9ed4-4dfb-9476-0a863a9d82fd",
        "parentId" : null,
        "authorId" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "body" : "I think we may not need this now that we write the restart count as a label. kubelet would only lose the count if the most recently died container had been GC'd before we create a new container. I think the chance is slim (though higher now due to container restart backoff). \n\nYou may also want to remove the hacky fix in https://github.com/kubernetes/kubernetes/blob/master/pkg/kubelet/kubelet.go#L2633\n",
        "createdAt" : "2015-10-21T02:11:51Z",
        "updatedAt" : "2015-10-23T20:03:11Z",
        "lastEditedBy" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "tags" : [
        ]
      },
      {
        "id" : "4dfc4513-ed60-4512-b323-ee06bb2c3ee4",
        "parentId" : "b07865de-9ed4-4dfb-9476-0a863a9d82fd",
        "authorId" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "body" : "Remove line 527 to 530 since you've removed the hacky fix. The function here will not get the latest status anyway.\n",
        "createdAt" : "2015-10-22T18:38:58Z",
        "updatedAt" : "2015-10-23T20:03:11Z",
        "lastEditedBy" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "tags" : [
        ]
      },
      {
        "id" : "a2c668d5-4127-4966-81c5-f58174960e30",
        "parentId" : "b07865de-9ed4-4dfb-9476-0a863a9d82fd",
        "authorId" : "4e418bc8-21fb-4523-80c1-9c751c193126",
        "body" : "Let me see...If we really lost all the containers, would it be better to retain the restart count in old status although it may not be up-to-date? Or do you think this effort is inefficient, and the chance is really slim, we can really just ignore it?\n",
        "createdAt" : "2015-10-22T21:49:18Z",
        "updatedAt" : "2015-10-23T20:03:11Z",
        "lastEditedBy" : "4e418bc8-21fb-4523-80c1-9c751c193126",
        "tags" : [
        ]
      },
      {
        "id" : "4113897d-7021-4c16-acf5-eeb707574786",
        "parentId" : "b07865de-9ed4-4dfb-9476-0a863a9d82fd",
        "authorId" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "body" : "The hacky fix actually passes the latest status known to kubelet to this function. Now that you've removed that, this only prevents once situation -- where the containers were removed during kubelet restarts. This should not happen often, but I suppose we can keep this :)\n",
        "createdAt" : "2015-10-22T23:04:08Z",
        "updatedAt" : "2015-10-23T20:03:11Z",
        "lastEditedBy" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "tags" : [
        ]
      },
      {
        "id" : "7aa062e5-bbe9-4d4b-bbee-78616946e0f2",
        "parentId" : "b07865de-9ed4-4dfb-9476-0a863a9d82fd",
        "authorId" : "4e418bc8-21fb-4523-80c1-9c751c193126",
        "body" : "OK, I'll keep it now, maybe remove it someday in the future. :)\n",
        "createdAt" : "2015-10-22T23:16:52Z",
        "updatedAt" : "2015-10-23T20:03:11Z",
        "lastEditedBy" : "4e418bc8-21fb-4523-80c1-9c751c193126",
        "tags" : [
        ]
      }
    ],
    "commit" : "67a763320261df3207644aabe7cd1f982dc01f87",
    "line" : 140,
    "diffHunk" : "@@ -1,1 +533,537 @@\n\t// Handle the containers for which we cannot find any associated active or dead docker containers or are in restart backoff\n\t// Fetch old containers statuses from old pod status.\n\toldStatuses := make(map[string]api.ContainerStatus, len(manifest.Containers))\n\tfor _, status := range pod.Status.ContainerStatuses {"
  },
  {
    "id" : "8cf3f138-f20d-4d21-b03e-e47c77cd17b5",
    "prId" : 15965,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "21cb0de2-5405-40d3-8c1a-1901a96f6307",
        "parentId" : null,
        "authorId" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "body" : "Suggestion: add a comment here stating the limitation of this function. E.g., if all dead containers were garbage collected, the container status may be inaccurate (including state and restart count).\n",
        "createdAt" : "2015-10-22T18:48:41Z",
        "updatedAt" : "2015-10-23T20:03:11Z",
        "lastEditedBy" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "tags" : [
        ]
      }
    ],
    "commit" : "67a763320261df3207644aabe7cd1f982dc01f87",
    "line" : 57,
    "diffHunk" : "@@ -1,1 +462,466 @@\t// these limitations now.\n\tpodFullName := kubecontainer.GetPodFullName(pod)\n\tuid := pod.UID\n\tmanifest := pod.Spec\n\tvar podStatus api.PodStatus"
  },
  {
    "id" : "8bac14f7-8124-4864-93aa-15d0c156737e",
    "prId" : 15464,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5e7b03b2-04f8-4cd4-b434-8464ed0b0508",
        "parentId" : null,
        "authorId" : "e207abea-b610-4808-be75-0ad08ef4a235",
        "body" : "question: Is it worth logging a generic reason when there will be a log line stating that the pod was killed already?\n",
        "createdAt" : "2015-10-21T19:16:38Z",
        "updatedAt" : "2015-11-09T15:42:38Z",
        "lastEditedBy" : "e207abea-b610-4808-be75-0ad08ef4a235",
        "tags" : [
        ]
      },
      {
        "id" : "b988434c-9a9f-41d5-87bd-a405c49f277d",
        "parentId" : "5e7b03b2-04f8-4cd4-b434-8464ed0b0508",
        "authorId" : "3c7fea1e-9d61-4b20-8af9-584361c1b59a",
        "body" : "This is for distinguishing killing container for restarting container and terminating whole Pod. From this point, it's not generic. We can get more details in log file but we can't get Pod delete  event now. I considered logging specific killPod reason also. But I found it had several kinds of reason and some killPod function call was caused by containerRuntime internal logic which may different between docker and rkt. So I logging a generic killPod reason for now. Surely logging specific killPod reason is better. I think we can record Pod create/delete event to improve it in future. What do you think?\n",
        "createdAt" : "2015-10-22T02:57:40Z",
        "updatedAt" : "2015-11-09T15:42:38Z",
        "lastEditedBy" : "3c7fea1e-9d61-4b20-8af9-584361c1b59a",
        "tags" : [
        ]
      },
      {
        "id" : "b64fe723-0232-4d4b-8d8c-5dedce77d37a",
        "parentId" : "5e7b03b2-04f8-4cd4-b434-8464ed0b0508",
        "authorId" : "e207abea-b610-4808-be75-0ad08ef4a235",
        "body" : "That makes sense. Can we make the `reason` a bit more descriptive noting that the pod is being killed and will [not] be restarted?\n",
        "createdAt" : "2015-10-22T13:42:18Z",
        "updatedAt" : "2015-11-09T15:42:38Z",
        "lastEditedBy" : "e207abea-b610-4808-be75-0ad08ef4a235",
        "tags" : [
        ]
      },
      {
        "id" : "ff64b386-d037-44e0-be3f-0b682bfde327",
        "parentId" : "5e7b03b2-04f8-4cd4-b434-8464ed0b0508",
        "authorId" : "3c7fea1e-9d61-4b20-8af9-584361c1b59a",
        "body" : "This pr focus on container killing reason. It describes details if container will be restart or re-created after being killed. \"will not be restart\" may be omitted.\n",
        "createdAt" : "2015-10-22T14:52:30Z",
        "updatedAt" : "2015-11-09T15:42:38Z",
        "lastEditedBy" : "3c7fea1e-9d61-4b20-8af9-584361c1b59a",
        "tags" : [
        ]
      },
      {
        "id" : "7681a8fe-dab4-4ce0-9ea3-ad6d19af7791",
        "parentId" : "5e7b03b2-04f8-4cd4-b434-8464ed0b0508",
        "authorId" : "e207abea-b610-4808-be75-0ad08ef4a235",
        "body" : "OK, if it is describing it somewhere else I don't see any issue.\n",
        "createdAt" : "2015-10-22T14:56:30Z",
        "updatedAt" : "2015-11-09T15:42:38Z",
        "lastEditedBy" : "e207abea-b610-4808-be75-0ad08ef4a235",
        "tags" : [
        ]
      }
    ],
    "commit" : "b0f0c294d998cb3ed0ee329f0d2a8a8a7329418a",
    "line" : 44,
    "diffHunk" : "@@ -1,1 +1329,1333 @@\t\t\terrs <- err\n\t\t}\n\t\tif err := dm.KillContainerInPod(networkContainer.ID, networkSpec, pod, \"Need to kill pod.\"); err != nil {\n\t\t\tglog.Errorf(\"Failed to delete container: %v; Skipping pod %q\", err, runningPod.ID)\n\t\t\terrs <- err"
  },
  {
    "id" : "4b3c6c3d-08d6-49b2-beb7-5004ce910b5c",
    "prId" : 15323,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "07eb9bd1-c646-4139-beaa-ec7fed6c7d94",
        "parentId" : null,
        "authorId" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "body" : "We only want to do this for the first container that mounts the volume, so we need to have the pod and the containers passed into this method.  We should only relabel each volume a single time.\n",
        "createdAt" : "2015-10-09T07:08:46Z",
        "updatedAt" : "2015-10-28T13:27:06Z",
        "lastEditedBy" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "tags" : [
        ]
      },
      {
        "id" : "3d406ce0-4bbc-4682-8eeb-ff8b56dce5f5",
        "parentId" : "07eb9bd1-c646-4139-beaa-ec7fed6c7d94",
        "authorId" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "body" : "Also, if the pod uses the hostPid namespace, we will need to chcon the volume in the docker manager instead of relying on docker.  I think we should extract the `ChconRunner` interface into its own package.  I'm going to add siblings to it.  Following the pattern of mount, I was thinking: `pkg/chmod/chmod.go`:\n\n``` go\npackage chmod\n\ntype Interface interface {\n  Chmod(path, mode string) error\n}\n```\n\nThoughts about that?\n",
        "createdAt" : "2015-10-09T07:15:58Z",
        "updatedAt" : "2015-10-28T13:27:06Z",
        "lastEditedBy" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "tags" : [
        ]
      },
      {
        "id" : "70e285c3-cd37-4292-bbea-ac98800b914e",
        "parentId" : "07eb9bd1-c646-4139-beaa-ec7fed6c7d94",
        "authorId" : null,
        "body" : "> I think we should extract the ChconRunner interface into its own package.\n\nHow about 'pkg/selinux/selinux.go' ? we can add all the SELinux utils there\n",
        "createdAt" : "2015-10-13T20:59:54Z",
        "updatedAt" : "2015-10-28T13:27:06Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "51db06a1-9c76-4d72-a846-fdb6a66343a0",
        "parentId" : "07eb9bd1-c646-4139-beaa-ec7fed6c7d94",
        "authorId" : null,
        "body" : "> We only want to do this for the first container that mounts the volume, so we need to have the pod and the containers passed into this method. We should only relabel each volume a single time.\n\nImplemented here: https://github.com/kubernetes/kubernetes/commit/042f3a4920bcee730fb84a13b494b5d82a9cc09c\n",
        "createdAt" : "2015-10-13T21:03:28Z",
        "updatedAt" : "2015-10-28T13:27:06Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "1d352a16b8e766eabe7ab75ebddc43f07a6fcdd0",
    "line" : null,
    "diffHunk" : "@@ -1,1 +622,626 @@\t\t// This would restrict access to the volume to the\n\t\t// container which mounts it first.\n\t\tif m.SELinuxRelabel && podHasSELinuxLabel {\n\t\t\tif m.ReadOnly {\n\t\t\t\tbind += \",Z\""
  },
  {
    "id" : "05462de0-0185-43d8-aacc-7fbbf4d6621f",
    "prId" : 15082,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d5e332a8-e43a-4ad0-a5fe-df0033c3696d",
        "parentId" : null,
        "authorId" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "body" : "could use a comment here to explain what the conditions are for.\n",
        "createdAt" : "2015-10-05T19:20:15Z",
        "updatedAt" : "2015-10-07T01:20:46Z",
        "lastEditedBy" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "tags" : [
        ]
      }
    ],
    "commit" : "e20d599ace750559e50cc6da5d08eeedd609c659",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +346,350 @@\t\t\t}\n\t\t}\n\t} else if !inspectResult.State.FinishedAt.IsZero() || inspectResult.State.ExitCode != 0 {\n\t\t// When a container fails to start State.ExitCode is non-zero, FinishedAt and StartedAt are both zero\n\t\treason := \"\""
  },
  {
    "id" : "6faabdeb-cde8-4d33-886c-d1d89f4651b5",
    "prId" : 14525,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3869a67f-69b3-4180-aeb5-6334901857c9",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "For future fixup: Could this just be private to the CNI plugin?\n",
        "createdAt" : "2015-09-26T04:33:51Z",
        "updatedAt" : "2015-09-26T04:33:51Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "39109009-4f7c-4080-a3b9-005b26d6e999",
        "parentId" : "3869a67f-69b3-4180-aeb5-6334901857c9",
        "authorId" : "57f729dd-988a-4d1a-83bf-ee70bf637c64",
        "body" : "> For future fixup: Could this just be private to the CNI plugin?\n\nYeah, it probably could be.  I think Rajat just put in the docker stuff for symmetry, but I think in the future this code will go away when we get the IP from AddNetwork or add a STATUS call to the CNI spec.\n",
        "createdAt" : "2015-09-26T04:40:13Z",
        "updatedAt" : "2015-09-26T04:40:13Z",
        "lastEditedBy" : "57f729dd-988a-4d1a-83bf-ee70bf637c64",
        "tags" : [
        ]
      }
    ],
    "commit" : "01dd813ce39163dffa3f7f8694c4086a77b5ed70",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +1194,1198 @@\n// Get the IP address of a container's interface using nsenter\nfunc (dm *DockerManager) GetContainerIP(containerID, interfaceName string) (string, error) {\n\t_, lookupErr := exec.LookPath(\"nsenter\")\n\tif lookupErr != nil {"
  },
  {
    "id" : "6b63c6f8-cb06-4ec0-9a72-4e5dfa16b07f",
    "prId" : 14279,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "10a1d4b0-4582-4347-8d18-7423e6979fc6",
        "parentId" : null,
        "authorId" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "body" : "+1 to this note.\n",
        "createdAt" : "2015-09-21T16:54:53Z",
        "updatedAt" : "2015-09-21T16:54:53Z",
        "lastEditedBy" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "tags" : [
        ]
      }
    ],
    "commit" : "20361e33f2c4d19302c24461f62d5ddd9c0e7718",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +1804,1808 @@\n\t\t// TODO(dawnchen): Check RestartPolicy.DelaySeconds before restart a container\n\t\t// Note: when configuring the pod's containers anything that can be configured by pointing\n\t\t// to the namespace of the infra container should use namespaceMode.  This includes things like the net namespace\n\t\t// and IPC namespace.  PID mode cannot point to another container right now."
  },
  {
    "id" : "f5578c8c-df47-418d-bd86-8bc9b68c7dbf",
    "prId" : 13542,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "686f5f89-b071-4ec2-a1f6-290cb0b87a04",
        "parentId" : null,
        "authorId" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "body" : "I hope we don't increment again once we restart.\n",
        "createdAt" : "2015-09-03T17:24:10Z",
        "updatedAt" : "2015-09-03T17:24:10Z",
        "lastEditedBy" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "tags" : [
        ]
      },
      {
        "id" : "e7fbd768-dd9c-4d97-9f85-178047e489d3",
        "parentId" : "686f5f89-b071-4ec2-a1f6-290cb0b87a04",
        "authorId" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "body" : "We might if we don't persist it to the apiserver.\n\nThis part of the code is really messy, and we should clean it up sometime.\n",
        "createdAt" : "2015-09-03T19:50:23Z",
        "updatedAt" : "2015-09-03T19:50:23Z",
        "lastEditedBy" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "tags" : [
        ]
      }
    ],
    "commit" : "9cdb00485150d5dba853b8a6d7fb05daae231f3b",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +479,483 @@\t\t\t\t// We need to increment the restart count if we are going to\n\t\t\t\t// move the current state to last terminated state.\n\t\t\t\tif containerStatus.State.Terminated != nil {\n\t\t\t\t\tlastObservedTime, ok := lastObservedTime[container.Name]\n\t\t\t\t\tif !ok || containerStatus.State.Terminated.FinishedAt.After(lastObservedTime.Time) {"
  },
  {
    "id" : "5af4d6ef-ad02-439a-ba36-1da339786e94",
    "prId" : 13447,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "405a1741-357d-4c91-b028-6ec94e80723a",
        "parentId" : null,
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "SHouldn't this be a constant?  Or is this docker specific and the client doesn't offer a constant?\n",
        "createdAt" : "2015-09-14T16:32:52Z",
        "updatedAt" : "2015-09-15T17:52:04Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "e1e4af2a-84bc-4be2-842b-1f8492813761",
        "parentId" : "405a1741-357d-4c91-b028-6ec94e80723a",
        "authorId" : "fb0525d4-54d0-4bfa-8b41-17f8b31b43fd",
        "body" : "I did not see a constant for this in the docker client packages.  UTS mode and host network also are using `\"host\"` in `manager.go` so I went with that approach. \n",
        "createdAt" : "2015-09-14T16:51:43Z",
        "updatedAt" : "2015-09-15T17:52:04Z",
        "lastEditedBy" : "fb0525d4-54d0-4bfa-8b41-17f8b31b43fd",
        "tags" : [
        ]
      },
      {
        "id" : "9e6baaf9-a572-4f97-94d4-efa4634a938d",
        "parentId" : "405a1741-357d-4c91-b028-6ec94e80723a",
        "authorId" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "body" : "@smarterclayton if we can get #12823 in I woukd really like this to go in\nafterward.\n\nOn Monday, September 14, 2015, Paul Weil notifications@github.com wrote:\n\n> In pkg/kubelet/dockertools/manager.go\n> https://github.com/kubernetes/kubernetes/pull/13447#discussion_r39417286\n> :\n> \n> > @@ -1889,3 +1891,12 @@ func (dm *DockerManager) doBackOff(pod *api.Pod, container *api.Container, podSt\n> >     dm.clearReasonCache(pod, container)\n> >     return false\n> >  }\n> > +\n> > +// getPidMode returns the pid mode to use on the docker container based on pod.Spec.HostPID.\n> > +func getPidMode(pod *api.Pod) string {\n> > -   pidMode := \"\"\n> > -   if pod.Spec.HostPID {\n> > -       pidMode = \"host\"\n> \n> I did not see a constant for this in the docker client packages. UTS mode\n> and host network also are using \"host\" in manager.go so I went with that\n> approach.\n> \n> —\n> Reply to this email directly or view it on GitHub\n> https://github.com/kubernetes/kubernetes/pull/13447/files#r39417286.\n",
        "createdAt" : "2015-09-14T16:56:06Z",
        "updatedAt" : "2015-09-15T17:52:04Z",
        "lastEditedBy" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "tags" : [
        ]
      }
    ],
    "commit" : "ed80c2b940b842a5cd28de123154de10bcdb0948",
    "line" : 63,
    "diffHunk" : "@@ -1,1 +1897,1901 @@\tpidMode := \"\"\n\tif pod.Spec.HostPID {\n\t\tpidMode = \"host\"\n\t}\n\treturn pidMode"
  },
  {
    "id" : "2bcd4893-9714-4e8e-a0c7-b6cbdb2c6b8d",
    "prId" : 13320,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8efc4a5d-e246-4c8f-b766-bcfd05ccbf6b",
        "parentId" : null,
        "authorId" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "body" : "This breaks on restarts right?\n",
        "createdAt" : "2015-08-28T18:55:24Z",
        "updatedAt" : "2015-08-28T18:55:24Z",
        "lastEditedBy" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "tags" : [
        ]
      },
      {
        "id" : "c190b851-12e8-4298-9617-3e67734ef9ed",
        "parentId" : "8efc4a5d-e246-4c8f-b766-bcfd05ccbf6b",
        "authorId" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "body" : "Not really. We get the restart count that we last persisted to the apiserver. In most cases, you should still see monotonically increasing restart counts. (I tried this by killing the kubelet in my cluster). This, however, does break for static pods over restarts. \n",
        "createdAt" : "2015-08-28T19:04:47Z",
        "updatedAt" : "2015-08-28T21:04:27Z",
        "lastEditedBy" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "tags" : [
        ]
      }
    ],
    "commit" : "f707ca08d5860285123937f87a982c1ee98dfb12",
    "line" : 37,
    "diffHunk" : "@@ -1,1 +445,449 @@\t\t\t}\n\t\t\t// Only count dead containers terminated after last time we observed,\n\t\t\tlastObservedTime, ok := lastObservedTime[dockerContainerName]\n\t\t\tif !ok || terminationState.Terminated.FinishedAt.After(lastObservedTime.Time) {\n\t\t\t\tcontainerStatus.RestartCount += 1"
  },
  {
    "id" : "27b8e7d0-10e2-43ee-900d-1519e675cd32",
    "prId" : 13052,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1d671ceb-f244-4501-b1a3-eb2bdf64262b",
        "parentId" : null,
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "godoc\n",
        "createdAt" : "2015-08-23T00:46:53Z",
        "updatedAt" : "2015-08-31T23:19:40Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      }
    ],
    "commit" : "4ff66bd70ad128d05f26ad9615e48ed5d167ee23",
    "line" : null,
    "diffHunk" : "@@ -1,1 +290,294 @@// podDependsOnIP returns whether any containers in a pod depend on using the pod IP via\n// the downward API.\nfunc podDependsOnPodIP(pod *api.Pod) bool {\n\tfor _, container := range pod.Spec.Containers {\n\t\tfor _, env := range container.Env {"
  },
  {
    "id" : "4ff75406-4583-4667-af27-1cba2640efcb",
    "prId" : 12648,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5633aa4c-0e34-4227-a9b4-77bbf9cc4c3a",
        "parentId" : null,
        "authorId" : "a6409368-42e0-44a9-bf79-9d3042ac3b65",
        "body" : "Shouldn't reason for transferring ContainerState to Waiting is \"Backoff\" now?\n",
        "createdAt" : "2015-08-20T23:22:37Z",
        "updatedAt" : "2015-08-24T11:59:06Z",
        "lastEditedBy" : "a6409368-42e0-44a9-bf79-9d3042ac3b65",
        "tags" : [
        ]
      },
      {
        "id" : "92aad382-dd29-41cd-b36e-803ae5795724",
        "parentId" : "5633aa4c-0e34-4227-a9b4-77bbf9cc4c3a",
        "authorId" : "9cc094e0-7e7f-440a-a8ef-def474688ae2",
        "body" : "reason (the variable) at this point contains ErrCrashLoopBackOff.Error(), which is fetched from the reasonCache.\n",
        "createdAt" : "2015-08-21T06:53:05Z",
        "updatedAt" : "2015-08-24T11:59:06Z",
        "lastEditedBy" : "9cc094e0-7e7f-440a-a8ef-def474688ae2",
        "tags" : [
        ]
      }
    ],
    "commit" : "995cb15bb6509b56925a35152d8b032055f642ec",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +475,479 @@\t\t\tif ok && reason == kubecontainer.ErrCrashLoopBackOff.Error() {\n\t\t\t\tcontainerStatus.LastTerminationState = containerStatus.State\n\t\t\t\tcontainerStatus.State.Waiting = &api.ContainerStateWaiting{Reason: reason}\n\t\t\t\tcontainerStatus.State.Running = nil\n\t\t\t}"
  },
  {
    "id" : "b451e985-4a88-43f7-b20b-a8dd975590b3",
    "prId" : 12470,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "30b95ab5-4b2f-49ec-9cc2-787b277deb58",
        "parentId" : null,
        "authorId" : "fb0525d4-54d0-4bfa-8b41-17f8b31b43fd",
        "body" : "Nit.  I think while this technically works it doesn't follow the pattern that we take for the `netMode`.    For things that can point to another container (netMode & ipcMode - pidMode cannot) so far what we've done is configure the infra container and point the pod's containers to the infra container.\n\nIn other words - you can always use `namespaceMode` on this line which points to the infra container using \"host\".\n\n@vishh - thoughts?  @simon3z is going on PTO, if this is a must fix for this to merge I can do it or I can do it as a quick follow up post-merge.\n",
        "createdAt" : "2015-09-18T20:07:29Z",
        "updatedAt" : "2015-09-18T20:07:29Z",
        "lastEditedBy" : "fb0525d4-54d0-4bfa-8b41-17f8b31b43fd",
        "tags" : [
        ]
      },
      {
        "id" : "21fcdd84-376f-4d2d-a72e-4f5a68c61824",
        "parentId" : "30b95ab5-4b2f-49ec-9cc2-787b277deb58",
        "authorId" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "body" : "I also think it's more correct to use `namespaceMode` as @pweil- has suggested above.  I'm fine with a follow up from @pweil- that fixes this and adds some unit tests for validation.\n",
        "createdAt" : "2015-09-18T20:09:20Z",
        "updatedAt" : "2015-09-18T20:09:20Z",
        "lastEditedBy" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "tags" : [
        ]
      },
      {
        "id" : "96f4bf0c-34d2-43fc-80df-168f7cb36f83",
        "parentId" : "30b95ab5-4b2f-49ec-9cc2-787b277deb58",
        "authorId" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "body" : "+1. Let's stick to re-using infra container's namespaces. I think its ok to fix this in a subsequent PR. \n",
        "createdAt" : "2015-09-18T21:19:35Z",
        "updatedAt" : "2015-09-18T21:19:35Z",
        "lastEditedBy" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "tags" : [
        ]
      }
    ],
    "commit" : "f21d9ac9e40830cc566252a7008fa760192380fd",
    "line" : 23,
    "diffHunk" : "@@ -1,1 +1805,1809 @@\t\t// TODO(dawnchen): Check RestartPolicy.DelaySeconds before restart a container\n\t\tnamespaceMode := fmt.Sprintf(\"container:%v\", podInfraContainerID)\n\t\t_, err = dm.runContainerInPod(pod, container, namespaceMode, getIPCMode(pod, namespaceMode), getPidMode(pod))\n\t\tdm.updateReasonCache(pod, container, \"RunContainerError\", err)\n\t\tif err != nil {"
  },
  {
    "id" : "b95e18bf-0a67-4da7-a770-84cd7413efba",
    "prId" : 12283,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c91720f2-a083-4dca-bd72-d4b6fe2d114e",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "make this conditional on `stream != nil`? Was it actually valid to pass a nil stream before, or were the test cases just doing that for expedience?\n",
        "createdAt" : "2015-09-21T16:17:46Z",
        "updatedAt" : "2015-10-01T00:03:59Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "44078587-0748-4a67-9001-dcd929d02aa1",
        "parentId" : "c91720f2-a083-4dca-bd72-d4b6fe2d114e",
        "authorId" : "b15d5707-82a8-4448-b49d-a2d6502b10f9",
        "body" : "It's not valid to have a nil stdin for port forwarding.\n",
        "createdAt" : "2015-09-21T18:43:29Z",
        "updatedAt" : "2015-10-01T00:03:59Z",
        "lastEditedBy" : "b15d5707-82a8-4448-b49d-a2d6502b10f9",
        "tags" : [
        ]
      }
    ],
    "commit" : "ed021fed4c38b5c82696fea84b3173e98bc16922",
    "line" : 35,
    "diffHunk" : "@@ -1,1 +1204,1208 @@\t// The work around is to use StdinPipe(), as Wait() (called by Run()) closes the pipe\n\t// when the command (socat) exits.\n\tinPipe, err := command.StdinPipe()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"unable to do port forwarding: error creating stdin pipe: %v\", err)"
  },
  {
    "id" : "a11711f2-557a-4bfe-903a-5f94b94a8a94",
    "prId" : 11669,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d6f04c11-5bf7-4306-b2b7-a75569176841",
        "parentId" : null,
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Do we not have this elsewhere?\n",
        "createdAt" : "2015-07-21T18:11:15Z",
        "updatedAt" : "2015-08-10T17:30:40Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "238b4a08-5c91-4795-86d7-87eae30bffb9",
        "parentId" : "d6f04c11-5bf7-4306-b2b7-a75569176841",
        "authorId" : "fb0525d4-54d0-4bfa-8b41-17f8b31b43fd",
        "body" : "We inspect the image in the IsImagePresent method and in the GetPodStatus method.  They both use the client this way.\n",
        "createdAt" : "2015-07-21T18:16:32Z",
        "updatedAt" : "2015-08-10T17:30:40Z",
        "lastEditedBy" : "fb0525d4-54d0-4bfa-8b41-17f8b31b43fd",
        "tags" : [
        ]
      }
    ],
    "commit" : "e490c20c22fffa7c78b9ddd596dcd8605d93aabd",
    "line" : 45,
    "diffHunk" : "@@ -1,1 +1670,1674 @@// false and return the error.\nfunc (dm *DockerManager) isImageRoot(image string) (bool, error) {\n\timg, err := dm.client.InspectImage(image)\n\tif err != nil {\n\t\treturn false, err"
  },
  {
    "id" : "39351aee-8956-4a39-a6b5-eec16c72815e",
    "prId" : 11669,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b0d9af94-4ffb-4885-8117-6d17db50334f",
        "parentId" : null,
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Needs a test\n",
        "createdAt" : "2015-07-21T18:13:11Z",
        "updatedAt" : "2015-08-10T17:30:40Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "ad6a99c6-2d3b-4f9c-9e30-ae57bbdf56a8",
        "parentId" : "b0d9af94-4ffb-4885-8117-6d17db50334f",
        "authorId" : "fb0525d4-54d0-4bfa-8b41-17f8b31b43fd",
        "body" : "tested (includes all cases of the `isImageRoot` method it calls as well\n",
        "createdAt" : "2015-07-21T20:54:15Z",
        "updatedAt" : "2015-08-10T17:30:40Z",
        "lastEditedBy" : "fb0525d4-54d0-4bfa-8b41-17f8b31b43fd",
        "tags" : [
        ]
      }
    ],
    "commit" : "e490c20c22fffa7c78b9ddd596dcd8605d93aabd",
    "line" : 43,
    "diffHunk" : "@@ -1,1 +1668,1672 @@// isImageRoot returns true if the user directive is not set on the image, the user is set to 0\n// or the user is set to root.  If there is an error inspecting the image this method will return\n// false and return the error.\nfunc (dm *DockerManager) isImageRoot(image string) (bool, error) {\n\timg, err := dm.client.InspectImage(image)"
  },
  {
    "id" : "79675e57-eafe-47d8-898d-5acd4d2574c6",
    "prId" : 10266,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "662cb1f4-f93f-4ddc-b714-76461ae973f8",
        "parentId" : null,
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Will this fail if the file doesn't exist (due to another issue, like docker getting stopped and tearing down the container) and if so will it be a clean error?\n",
        "createdAt" : "2015-06-24T15:49:42Z",
        "updatedAt" : "2015-06-25T06:34:30Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      }
    ],
    "commit" : "23caf446ae69236641da0fdc432d4cfb5fff098d",
    "line" : null,
    "diffHunk" : "@@ -1,1 +1263,1267 @@\nfunc appendToFile(filePath, stringToAppend string) error {\n\tf, err := os.OpenFile(filePath, os.O_APPEND|os.O_WRONLY, 0644)\n\tif err != nil {\n\t\treturn err"
  },
  {
    "id" : "eb9a3bd7-1448-4024-9fd5-fcfbfcb836f9",
    "prId" : 9824,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ace6d5e2-aaf9-429d-835e-c11bf45f11f3",
        "parentId" : null,
        "authorId" : "227eb550-8b08-4420-9a78-279f840bd8de",
        "body" : "Maybe add a comment here explaining why we need to explicit set the oom score adj here?\n",
        "createdAt" : "2015-06-15T23:02:49Z",
        "updatedAt" : "2015-06-15T23:17:00Z",
        "lastEditedBy" : "227eb550-8b08-4420-9a78-279f840bd8de",
        "tags" : [
        ]
      }
    ],
    "commit" : "14f78b74ccf9f87ab2b958bc3108d63b7b29b21f",
    "line" : null,
    "diffHunk" : "@@ -1,1 +1203,1207 @@\t\t// daemon process. We explicitly apply OOM score 0 by default to the user\n\t\t// containers to avoid daemons or POD containers are killed by oom killer.\n\t\tutil.ApplyOomScoreAdj(containerInfo.State.Pid, userContainerOomScoreAdj)\n\t}\n"
  },
  {
    "id" : "f88e8a5b-b41f-417c-be56-19ceeb4b4817",
    "prId" : 9646,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ae16aa44-87ed-4f55-a411-bc9052291d20",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "What's the status of net plugin support in the rkt path?  Does it even apply?\n",
        "createdAt" : "2015-08-07T04:13:41Z",
        "updatedAt" : "2015-08-07T04:13:41Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "057943d6-4e29-4665-9444-3a322956de9c",
        "parentId" : "ae16aa44-87ed-4f55-a411-bc9052291d20",
        "authorId" : "9c668715-22fc-4e1d-a673-80ba46f7bd46",
        "body" : "It applies, but other parts of rkt need to be brought up to speed before this can be useful.\n",
        "createdAt" : "2015-08-07T16:10:42Z",
        "updatedAt" : "2015-08-07T16:10:42Z",
        "lastEditedBy" : "9c668715-22fc-4e1d-a673-80ba46f7bd46",
        "tags" : [
        ]
      }
    ],
    "commit" : "1ce6d80a89eb4d26d8911c115e4c036a77807e34",
    "line" : 21,
    "diffHunk" : "@@ -1,1 +295,299 @@\t\t\t// override the above if a network plugin exists\n\t\t\tif dm.networkPlugin.Name() != network.DefaultPluginName {\n\t\t\t\tnetStatus, err := dm.networkPlugin.Status(pod.Namespace, pod.Name, kubeletTypes.DockerID(dockerID))\n\t\t\t\tif err != nil {\n\t\t\t\t\tglog.Errorf(\"NetworkPlugin %s failed on the status hook for pod '%s' - %v\", dm.networkPlugin.Name(), pod.Name, err)"
  },
  {
    "id" : "d777713d-9385-4220-a5df-d53b6347353d",
    "prId" : 9165,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7137b1f3-c6ae-49b4-b92a-13a809006b63",
        "parentId" : null,
        "authorId" : "b7abca6a-d6be-4008-a014-3b5ca0e90529",
        "body" : "2s not 1m?\n",
        "createdAt" : "2015-06-03T17:47:20Z",
        "updatedAt" : "2015-08-18T13:08:12Z",
        "lastEditedBy" : "b7abca6a-d6be-4008-a014-3b5ca0e90529",
        "tags" : [
        ]
      },
      {
        "id" : "1a2159e7-1ab8-4620-881f-369907adc3b9",
        "parentId" : "7137b1f3-c6ae-49b4-b92a-13a809006b63",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "This is really just to guard against _forcing_ SIGKILL.  We default pod.Spec.TerminationGracePeriodSceonds to 30 - this just guarantees you never get less than 2s to respond to SIGTERM.\n",
        "createdAt" : "2015-06-03T17:49:22Z",
        "updatedAt" : "2015-08-18T13:08:12Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      }
    ],
    "commit" : "266e6226e52b55f8a6d5278c1264299d7c713820",
    "line" : null,
    "diffHunk" : "@@ -1,1 +61,65 @@\t// hence, setting ndots to be 5.\n\tndotsDNSOption = \"options ndots:5\\n\"\n\t// In order to avoid unnecessary SIGKILLs, give every container a minimum grace\n\t// period after SIGTERM. Docker will guarantee the termination, but SIGTERM is\n\t// potentially dangerous."
  },
  {
    "id" : "97f00d4a-7017-4e7c-bf44-d29ef878b7df",
    "prId" : 9165,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4435602b-c633-4478-82a8-138d4ca0cc62",
        "parentId" : null,
        "authorId" : "b7abca6a-d6be-4008-a014-3b5ca0e90529",
        "body" : "Can't we rely on the data one below?\n",
        "createdAt" : "2015-06-03T17:55:12Z",
        "updatedAt" : "2015-08-18T13:08:12Z",
        "lastEditedBy" : "b7abca6a-d6be-4008-a014-3b5ca0e90529",
        "tags" : [
        ]
      },
      {
        "id" : "22559185-bbd6-4436-bd03-a1642c8c1347",
        "parentId" : "4435602b-c633-4478-82a8-138d4ca0cc62",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "It's only set when Prestop is used - I didn't want to force it to always be encoded (although that's an option in the future).\n",
        "createdAt" : "2015-06-03T17:58:10Z",
        "updatedAt" : "2015-08-18T13:08:12Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      }
    ],
    "commit" : "266e6226e52b55f8a6d5278c1264299d7c713820",
    "line" : 38,
    "diffHunk" : "@@ -1,1 +607,611 @@\t\tkubernetesNameLabel: namespacedName.String(),\n\t}\n\tif pod.Spec.TerminationGracePeriodSeconds != nil {\n\t\tlabels[kubernetesTerminationGracePeriodLabel] = strconv.FormatInt(*pod.Spec.TerminationGracePeriodSeconds, 10)\n\t}"
  },
  {
    "id" : "77dcd55f-8dbe-4341-a58d-6d9aa8f180b1",
    "prId" : 9165,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f3907c8c-1326-4677-9eda-d40bad603922",
        "parentId" : null,
        "authorId" : "b7abca6a-d6be-4008-a014-3b5ca0e90529",
        "body" : "WDYT: Two different functions? `KillContainerByID()` and `KillContainer()`\n",
        "createdAt" : "2015-06-03T18:00:21Z",
        "updatedAt" : "2015-08-18T13:08:12Z",
        "lastEditedBy" : "b7abca6a-d6be-4008-a014-3b5ca0e90529",
        "tags" : [
        ]
      },
      {
        "id" : "6097654f-197d-4a9a-a922-f3ada448115a",
        "parentId" : "f3907c8c-1326-4677-9eda-d40bad603922",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Better yes.  I was concerned about the existing duplication (I looked at removing it) but more concerned about breaking something accidentally.\n\n> On Jun 3, 2015, at 2:00 PM, Victor Marmol notifications@github.com wrote:\n> \n> In pkg/kubelet/dockertools/manager.go:\n> \n> > -func (dm *DockerManager) KillContainerInPod(container api.Container, pod *api.Pod) error {\n> > -   // Locate the container.\n> > -   pods, err := dm.GetPods(false)\n> > -   if err != nil {\n> > -       return err\n> > -   }\n> > -   targetPod := kubecontainer.Pods(pods).FindPod(kubecontainer.GetPodFullName(pod), pod.UID)\n> > -   targetContainer := targetPod.FindContainerByName(container.Name)\n> > -   if targetContainer == nil {\n> > -       return fmt.Errorf(\"unable to find container %q in pod %q\", container.Name, targetPod.Name)\n> > -   }\n> > -   return dm.killContainer(targetContainer.ID)\n> >   -}\n> >   +// KillContainerInPod kills a container in the pod. It must be passed either a container ID or a container and pod,\n> >   +// and will attempt to lookup the other information if missing.\n> >   +func (dm *DockerManager) KillContainerInPod(containerID types.UID, container *api.Container, pod *api.Pod) error {\n> >   WDYT: Two different functions? KillContainerByID() and KillContainer()\n> \n> —\n> Reply to this email directly or view it on GitHub.\n",
        "createdAt" : "2015-06-03T18:03:52Z",
        "updatedAt" : "2015-08-18T13:08:12Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      }
    ],
    "commit" : "266e6226e52b55f8a6d5278c1264299d7c713820",
    "line" : 134,
    "diffHunk" : "@@ -1,1 +1187,1191 @@// KillContainerInPod kills a container in the pod. It must be passed either a container ID or a container and pod,\n// and will attempt to lookup the other information if missing.\nfunc (dm *DockerManager) KillContainerInPod(containerID types.UID, container *api.Container, pod *api.Pod) error {\n\tswitch {\n\tcase len(containerID) == 0:"
  },
  {
    "id" : "d05ebd32-0c98-48b5-8fe3-dd2b6ffd87fe",
    "prId" : 8641,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d01c5016-f17b-48f3-a262-56a933cfdd58",
        "parentId" : null,
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "What is the reason to store the termination grace period as a docker label?\n\nWhat will happen if the user updates the termination grace period?\n",
        "createdAt" : "2015-05-22T19:29:47Z",
        "updatedAt" : "2015-06-01T23:24:09Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "6926e2fe-7e63-43d3-b23f-02b7f8f14f58",
        "parentId" : "d01c5016-f17b-48f3-a262-56a933cfdd58",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "> On May 22, 2015, at 3:30 PM, Brian Grant notifications@github.com wrote:\n> \n> In pkg/kubelet/dockertools/manager.go:\n> \n> > @@ -560,7 +569,10 @@ func (dm *DockerManager) runContainer(\n> >     }\n> >     namespacedName := types.NamespacedName{pod.Namespace, pod.Name}\n> >     labels := map[string]string{\n> > -       \"io.kubernetes.pod.name\": namespacedName.String(),\n> > -       kubernetesNameLabel: namespacedName.String(),\n> > -   }\n> > -   if pod.Spec.TerminationGracePeriodSeconds != nil {\n> > -       labels[kubernetesTerminationGracePeriodLabel] = strconv.FormatInt(*pod.Spec.TerminationGracePeriodSeconds, 10)\n> >   What is the reason to store the termination grace period as a docker label?\n> \n> It's to defend if the kubelet is restarted and cannot find the pod - so that we guarantee that we don't super aggressively kill the pod.  I refactored the kubelet to ensure we pass the most current pod everywhere we can.\n> What will happen if the user updates the termination grace period?\n> \n> An update to the pod (I believe) would not restart the containers, but would not update the label.  I don't think we can change labels without a container restart, but I can check.  Tempted to say \"requires a restart to get a longer grace period\".\n> —\n> Reply to this email directly or view it on GitHub.\n",
        "createdAt" : "2015-05-22T19:35:59Z",
        "updatedAt" : "2015-06-01T23:24:09Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "34f2f8ed-ab88-4ed9-b1a5-2e0300668c25",
        "parentId" : "d01c5016-f17b-48f3-a262-56a933cfdd58",
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "That would be ironic.\n",
        "createdAt" : "2015-05-23T00:13:32Z",
        "updatedAt" : "2015-06-01T23:24:09Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      }
    ],
    "commit" : "f12a68cd60ccfe2f0926386df771805c0993d783",
    "line" : 35,
    "diffHunk" : "@@ -1,1 +578,582 @@\t}\n\tif pod.Spec.TerminationGracePeriodSeconds != nil {\n\t\tlabels[kubernetesTerminationGracePeriodLabel] = strconv.FormatInt(*pod.Spec.TerminationGracePeriodSeconds, 10)\n\t}\n\tif container.Lifecycle != nil && container.Lifecycle.PreStop != nil {"
  },
  {
    "id" : "436ec9c1-0116-46be-bc60-4f662a6f1f71",
    "prId" : 8641,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "dd4d5a1d-ddb1-43c8-95b3-6f04dc35300b",
        "parentId" : null,
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "Please note this TODO in the issue (or file a new one).\n",
        "createdAt" : "2015-05-22T19:31:58Z",
        "updatedAt" : "2015-06-01T23:24:09Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      }
    ],
    "commit" : "f12a68cd60ccfe2f0926386df771805c0993d783",
    "line" : null,
    "diffHunk" : "@@ -1,1 +1203,1207 @@\t\tglog.V(4).Infof(\"Running preStop hook for container %q\", name)\n\t\tstart := util.Now()\n\t\t// TODO: timebox PreStop execution to at most gracePeriod\n\t\tif err := dm.runner.Run(ID, pod, container, container.Lifecycle.PreStop); err != nil {\n\t\t\tglog.Errorf(\"preStop hook for container %q failed: %v\", name, err)"
  },
  {
    "id" : "91e9b4fc-32ac-47f4-bf78-709f8a4c92e2",
    "prId" : 8641,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8b90b4fa-61a3-4de2-80a3-e7e44fb5bbcd",
        "parentId" : null,
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "If there are multiple containers with prestop hooks within the pod, it appears we execute those hooks sequentially? Maybe we should pass in the start time, or else execute the hooks concurrently, so they all start around the same time. Otherwise, the grace periods will only be partially overlapping. \n",
        "createdAt" : "2015-06-01T20:23:22Z",
        "updatedAt" : "2015-06-01T23:24:09Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "95576cea-b2c4-4880-889a-479755f142c8",
        "parentId" : "8b90b4fa-61a3-4de2-80a3-e7e44fb5bbcd",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "KillPod does the right thing, but KillContainerInPod doesn't (run concurrently).  We should be going into the KillPod path in SyncPod because ContainersToKeep == 0 && ContainersToStart == 0, so we _should_ be doing concurrent stop hooks.\n\n----- Original Message -----\n\n> > -           if container != nil {\n> > -               glog.V(1).Infof(\"Running preStop hook\")\n> > -               if err := dm.runner.Run(ID, &pod, container,\n> >   container.Lifecycle.PreStop); err != nil {\n> > -                   glog.Errorf(\"failed to run preStop hook: %v\", err)\n> > -               }\n> > -           } else {\n> > -               glog.Errorf(\"unable to find container %v, %s\", pod, name)\n> > -           }\n> >   +\n> > -   gracePeriod := uint(minimumGracePeriodInSeconds)\n> > -   if pod != nil && pod.DeletionGracePeriodSeconds != nil {\n> > -       gracePeriod = uint(*pod.DeletionGracePeriodSeconds)\n> > -   }\n> > -   glog.V(2).Infof(\"Killing container %q with %d grace period\", name,\n> >   gracePeriod)\n> >   +\n> > -   if pod != nil && container != nil && container.Lifecycle != nil &&\n> >   container.Lifecycle.PreStop != nil {\n> \n> If there are multiple containers with prestop hooks within the pod, it\n> appears we execute those hooks sequentially? Maybe we should pass in the\n> start time, or else execute the hooks concurrently, so they all start around\n> the same time. Otherwise, the grace periods will only be partially\n> overlapping.\n> \n> ---\n> \n> Reply to this email directly or view it on GitHub:\n> https://github.com/GoogleCloudPlatform/kubernetes/pull/8641/files#r31465996\n",
        "createdAt" : "2015-06-01T20:29:30Z",
        "updatedAt" : "2015-06-01T23:24:09Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "2e60bbc5-8b3c-4a35-819a-5cb8373549bf",
        "parentId" : "8b90b4fa-61a3-4de2-80a3-e7e44fb5bbcd",
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "Got it, thanks.\n",
        "createdAt" : "2015-06-01T21:01:27Z",
        "updatedAt" : "2015-06-01T23:24:09Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      }
    ],
    "commit" : "f12a68cd60ccfe2f0926386df771805c0993d783",
    "line" : null,
    "diffHunk" : "@@ -1,1 +1200,1204 @@\tglog.V(2).Infof(\"Killing container %q with %d second grace period\", name, gracePeriod)\n\n\tif pod != nil && container != nil && container.Lifecycle != nil && container.Lifecycle.PreStop != nil {\n\t\tglog.V(4).Infof(\"Running preStop hook for container %q\", name)\n\t\tstart := util.Now()"
  },
  {
    "id" : "e4b2c633-4ad8-4be9-8232-7ebc1b47f554",
    "prId" : 8604,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2e2aaa5d-682e-480d-a74e-630b3ef92bee",
        "parentId" : null,
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "Same line appears in pkg/kubelet/rkt/rkt.go \n",
        "createdAt" : "2015-05-26T22:05:53Z",
        "updatedAt" : "2015-05-27T22:47:45Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "8e9a49ef-7ed0-4f4f-ac57-dadadd502c7f",
        "parentId" : "2e2aaa5d-682e-480d-a74e-630b3ef92bee",
        "authorId" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "body" : "done.\n",
        "createdAt" : "2015-05-27T02:49:04Z",
        "updatedAt" : "2015-05-27T22:47:45Z",
        "lastEditedBy" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "tags" : [
        ]
      }
    ],
    "commit" : "2ec4b409e1548d437bed551e259f9578d78fd0ac",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +1022,1026 @@\t\tif stdin != nil {\n\t\t\t// Use an os.Pipe here as it returns true *os.File objects.\n\t\t\t// This way, if you run 'kubectl exec <pod> -i bash' (no tty) and type 'exit',\n\t\t\t// the call below to command.Run() can unblock because its Stdin is the read half\n\t\t\t// of the pipe."
  },
  {
    "id" : "21017e77-aab5-4e06-a683-2b1615637811",
    "prId" : 8149,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c8ef201e-ba13-4ccf-af31-1b677c8eff34",
        "parentId" : null,
        "authorId" : "7766e039-aa4c-4476-9091-5cc8763fa8d6",
        "body" : "I assume that Rocket is going to need a version of this as well? The current way this function is laid out doesn't seem to lend itself to reuse for Rocket\n",
        "createdAt" : "2015-05-19T21:54:38Z",
        "updatedAt" : "2015-05-27T04:14:15Z",
        "lastEditedBy" : "7766e039-aa4c-4476-9091-5cc8763fa8d6",
        "tags" : [
        ]
      },
      {
        "id" : "45d51956-6b6f-43f2-b8c7-7a021fed219d",
        "parentId" : "c8ef201e-ba13-4ccf-af31-1b677c8eff34",
        "authorId" : "6eca0ade-9879-4dd7-ad14-547e16f5c041",
        "body" : "I could see value in moving the expansion logic into `pkg/kubelet/containers` and having a function that took a command, and slice of args, and returned back the expanded values.\n",
        "createdAt" : "2015-05-20T01:59:22Z",
        "updatedAt" : "2015-05-27T04:14:15Z",
        "lastEditedBy" : "6eca0ade-9879-4dd7-ad14-547e16f5c041",
        "tags" : [
        ]
      },
      {
        "id" : "dc30531a-cba5-4cbf-acc7-d3588db9b44f",
        "parentId" : "c8ef201e-ba13-4ccf-af31-1b677c8eff34",
        "authorId" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "body" : "Yep, agree, and will move the shared code into `pkg/kubelet/containers`\n",
        "createdAt" : "2015-05-20T21:02:04Z",
        "updatedAt" : "2015-05-27T04:14:15Z",
        "lastEditedBy" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "tags" : [
        ]
      },
      {
        "id" : "12d1bb4a-ee5c-441c-91a1-5ad557770b16",
        "parentId" : "c8ef201e-ba13-4ccf-af31-1b677c8eff34",
        "authorId" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "body" : "Fixed, will be in next push.\n",
        "createdAt" : "2015-05-22T22:09:56Z",
        "updatedAt" : "2015-05-27T04:14:15Z",
        "lastEditedBy" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "tags" : [
        ]
      }
    ],
    "commit" : "8b338860aa740a05b3b27ce7c7aaef50d215b6d7",
    "line" : null,
    "diffHunk" : "@@ -1,1 +662,666 @@}\n\nfunc setEntrypointAndCommand(container *api.Container, opts *kubecontainer.RunContainerOptions, dockerOpts *docker.CreateContainerOptions) {\n\tcommand, args := kubecontainer.ExpandContainerCommandAndArgs(container, opts.Envs)\n"
  },
  {
    "id" : "f5e04c34-cda2-4309-9cc3-59e87b1f9405",
    "prId" : 8011,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9306a42e-1f66-46a7-b40c-85509a640f01",
        "parentId" : null,
        "authorId" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "body" : "Should we have some timeout here, just to be safe?\n",
        "createdAt" : "2015-05-12T16:27:02Z",
        "updatedAt" : "2015-05-12T16:27:02Z",
        "lastEditedBy" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "tags" : [
        ]
      },
      {
        "id" : "64ceedda-f6a8-45eb-b723-c2816457ca8d",
        "parentId" : "9306a42e-1f66-46a7-b40c-85509a640f01",
        "authorId" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "body" : "Hrm, we were already blocking (detach is set to 'false') so to be honest this loop is probably never actually executed.\n\nI'd rather not have a timeout here.\n",
        "createdAt" : "2015-05-12T19:40:23Z",
        "updatedAt" : "2015-05-12T19:40:23Z",
        "lastEditedBy" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "tags" : [
        ]
      },
      {
        "id" : "30cd2035-c685-46f7-b4b6-863ef6a7b9d7",
        "parentId" : "9306a42e-1f66-46a7-b40c-85509a640f01",
        "authorId" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "body" : "Ack\n",
        "createdAt" : "2015-05-12T19:43:07Z",
        "updatedAt" : "2015-05-12T19:43:07Z",
        "lastEditedBy" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "tags" : [
        ]
      }
    ],
    "commit" : "c9324e6e382530f1ecbcd9aeddb0882c7ed1b134",
    "line" : 16,
    "diffHunk" : "@@ -1,1 +900,904 @@\t}\n\ttick := time.Tick(2 * time.Second)\n\tfor {\n\t\tinspect, err2 := dm.client.InspectExec(execObj.ID)\n\t\tif err2 != nil {"
  },
  {
    "id" : "e9b3ed8e-1eaa-4c41-83b5-82fd70ee41f0",
    "prId" : 7974,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bc25a1ab-7be6-4982-8428-73d3e4652bb7",
        "parentId" : null,
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "It feels weird to me that SyncPod gets the secrets passed in. Is there a reason why SyncPod can't get the secrets itself? Or better yet, can that be pushed all the way down into the pullImage call?\n",
        "createdAt" : "2015-05-18T20:48:55Z",
        "updatedAt" : "2015-05-19T16:41:15Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "69faee30-01a6-451e-aa07-a973339c432c",
        "parentId" : "bc25a1ab-7be6-4982-8428-73d3e4652bb7",
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "> It feels weird to me that SyncPod gets the secrets passed in. Is there a reason why SyncPod can't get the secrets itself?\n\nThe `DockerManager` doesn't contain a `Client` pointing to the apiserver in order to get the contents of the secrets.  I think it would be strange to have a `DockerManager` contain knowledge about the apiserver, so I added it to the `SyncPod` call.\n",
        "createdAt" : "2015-05-18T21:38:22Z",
        "updatedAt" : "2015-05-19T16:41:15Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      },
      {
        "id" : "c8c597d5-6014-4b61-8a76-6f21530ec05f",
        "parentId" : "bc25a1ab-7be6-4982-8428-73d3e4652bb7",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "OK\n",
        "createdAt" : "2015-05-18T21:56:10Z",
        "updatedAt" : "2015-05-19T16:41:15Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "bc533205-b7ae-4060-90fa-c9432553e387",
        "parentId" : "bc25a1ab-7be6-4982-8428-73d3e4652bb7",
        "authorId" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "body" : "+1 to this factoring\n",
        "createdAt" : "2015-05-19T15:59:17Z",
        "updatedAt" : "2015-05-19T16:41:15Z",
        "lastEditedBy" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "tags" : [
        ]
      }
    ],
    "commit" : "72c0709f18cbeff1efef3c2bd601db5f1e117509",
    "line" : 41,
    "diffHunk" : "@@ -1,1 +1462,1466 @@\n// Sync the running pod to match the specified desired pod.\nfunc (dm *DockerManager) SyncPod(pod *api.Pod, runningPod kubecontainer.Pod, podStatus api.PodStatus, pullSecrets []api.Secret) error {\n\tpodFullName := kubecontainer.GetPodFullName(pod)\n\tcontainerChanges, err := dm.computePodContainerChanges(pod, runningPod, podStatus)"
  },
  {
    "id" : "0cde2624-6e92-4f02-ba05-2efe76cf9a5e",
    "prId" : 7610,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "94d84cea-0dd0-44ba-a6da-baddd02988e8",
        "parentId" : null,
        "authorId" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "body" : "Just wanted to make sure: the code in SyncPod was moved from kubelet, so I am assuming it's safe. Is there any change that's worth paying more attention to?\n",
        "createdAt" : "2015-05-01T16:45:22Z",
        "updatedAt" : "2015-05-01T18:11:25Z",
        "lastEditedBy" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "tags" : [
        ]
      }
    ],
    "commit" : "3b9eba2c1b3201e116c881792e7c65ad9977cca6",
    "line" : 159,
    "diffHunk" : "@@ -1,1 +1363,1367 @@\n// Sync the running pod to match the specified desired pod.\nfunc (dm *DockerManager) SyncPod(pod *api.Pod, runningPod kubecontainer.Pod, podStatus api.PodStatus) error {\n\tpodFullName := kubecontainer.GetPodFullName(pod)\n\tcontainerChanges, err := dm.computePodContainerChanges(pod, runningPod, podStatus)"
  },
  {
    "id" : "4f505b59-6d21-4ace-864b-54deb77bb92e",
    "prId" : 7449,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5a68a579-7ec5-4f6e-af9d-61861e9afc47",
        "parentId" : null,
        "authorId" : "227eb550-8b08-4420-9a78-279f840bd8de",
        "body" : "Seems `errs<- err` will block when in the worst case, teardown + all kill container fails.\n",
        "createdAt" : "2015-04-28T18:58:52Z",
        "updatedAt" : "2015-04-28T23:59:06Z",
        "lastEditedBy" : "227eb550-8b08-4420-9a78-279f840bd8de",
        "tags" : [
        ]
      },
      {
        "id" : "628e5996-f2e5-4e98-9383-906befd944e8",
        "parentId" : "5a68a579-7ec5-4f6e-af9d-61861e9afc47",
        "authorId" : "b7abca6a-d6be-4008-a014-3b5ca0e90529",
        "body" : "The won't block since the channel is buffered no? (this is the same code we had before btw)\n",
        "createdAt" : "2015-04-28T20:07:50Z",
        "updatedAt" : "2015-04-28T23:59:06Z",
        "lastEditedBy" : "b7abca6a-d6be-4008-a014-3b5ca0e90529",
        "tags" : [
        ]
      },
      {
        "id" : "95a94c25-29bf-4eab-b93a-5cface5635e9",
        "parentId" : "5a68a579-7ec5-4f6e-af9d-61861e9afc47",
        "authorId" : "227eb550-8b08-4420-9a78-279f840bd8de",
        "body" : "Yes. I just noticed that, it seems to be a historical problem. So the buffered size is `len(pod.Containers)`, while we will send at most `len(pod.Containers) + 1` (the 1 came from the tear down) errors. And since no one is receiving the channel, it can block I think?\n",
        "createdAt" : "2015-04-28T20:51:58Z",
        "updatedAt" : "2015-04-28T23:59:06Z",
        "lastEditedBy" : "227eb550-8b08-4420-9a78-279f840bd8de",
        "tags" : [
        ]
      },
      {
        "id" : "dff07b00-9473-4a12-b3b8-207e9e047f44",
        "parentId" : "5a68a579-7ec5-4f6e-af9d-61861e9afc47",
        "authorId" : "b7abca6a-d6be-4008-a014-3b5ca0e90529",
        "body" : "You're completely right, nice catch :) will fix.\n",
        "createdAt" : "2015-04-28T21:20:43Z",
        "updatedAt" : "2015-04-28T23:59:06Z",
        "lastEditedBy" : "b7abca6a-d6be-4008-a014-3b5ca0e90529",
        "tags" : [
        ]
      },
      {
        "id" : "41147bc0-cb24-49b4-9531-68da168c5e7b",
        "parentId" : "5a68a579-7ec5-4f6e-af9d-61861e9afc47",
        "authorId" : "b7abca6a-d6be-4008-a014-3b5ca0e90529",
        "body" : "Pushed a fix.\n",
        "createdAt" : "2015-04-28T23:59:13Z",
        "updatedAt" : "2015-04-28T23:59:13Z",
        "lastEditedBy" : "b7abca6a-d6be-4008-a014-3b5ca0e90529",
        "tags" : [
        ]
      }
    ],
    "commit" : "787d42d50b5af68d4cad535746ff73b08f045068",
    "line" : 58,
    "diffHunk" : "@@ -1,1 +964,968 @@\t\t\t\tif err != nil {\n\t\t\t\t\tglog.Errorf(\"Failed tearing down the infra container: %v\", err)\n\t\t\t\t\terrs <- err\n\t\t\t\t}\n\t\t\t}"
  },
  {
    "id" : "12448ef4-8daf-4280-bdc6-5eb4138255b8",
    "prId" : 7277,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "879da7ba-5802-4678-8fae-26b52d21d946",
        "parentId" : null,
        "authorId" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "body" : "I assume this option will be silently ignored with older versions of docker.\n",
        "createdAt" : "2015-04-24T01:34:53Z",
        "updatedAt" : "2015-04-30T17:42:35Z",
        "lastEditedBy" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "tags" : [
        ]
      },
      {
        "id" : "7053d9de-14ed-481b-86e5-b2bfbd6cfe75",
        "parentId" : "879da7ba-5802-4678-8fae-26b52d21d946",
        "authorId" : "4caaea84-5487-49da-9802-d8039e22a66d",
        "body" : "Yep. I tested with Docker 1.4.1. Containers just launch under the default `/docker` cgroup. \n",
        "createdAt" : "2015-04-24T02:03:01Z",
        "updatedAt" : "2015-04-30T17:42:35Z",
        "lastEditedBy" : "4caaea84-5487-49da-9802-d8039e22a66d",
        "tags" : [
        ]
      }
    ],
    "commit" : "b96c4046a8db538f0a341ff01126c814a8da3783",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +557,561 @@\t\thc.DNSSearch = opts.DNSSearch\n\t}\n\tif len(opts.CgroupParent) > 0 {\n\t\thc.CgroupParent = opts.CgroupParent\n\t}"
  },
  {
    "id" : "f9f8b999-7e9f-470f-930f-5a1a6da78f6a",
    "prId" : 7271,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4254a37a-1b01-4718-80a8-4f0dcca7ac8a",
        "parentId" : null,
        "authorId" : "a6409368-42e0-44a9-bf79-9d3042ac3b65",
        "body" : "I found myself really start to hate name HandlerRunner :-) Of course no need to change here. Also I don't have a good candidate to replace it. \n",
        "createdAt" : "2015-04-23T23:50:24Z",
        "updatedAt" : "2015-04-23T23:50:24Z",
        "lastEditedBy" : "a6409368-42e0-44a9-bf79-9d3042ac3b65",
        "tags" : [
        ]
      },
      {
        "id" : "fa3671c1-ae7a-4c64-b025-c5cb98a8cdd4",
        "parentId" : "4254a37a-1b01-4718-80a8-4f0dcca7ac8a",
        "authorId" : "227eb550-8b08-4420-9a78-279f840bd8de",
        "body" : "Sorry :( I am bad at naming..\n",
        "createdAt" : "2015-04-24T02:01:50Z",
        "updatedAt" : "2015-04-24T02:01:50Z",
        "lastEditedBy" : "227eb550-8b08-4420-9a78-279f840bd8de",
        "tags" : [
        ]
      },
      {
        "id" : "2f92ed2c-0aa0-48ce-9388-889c925dcf79",
        "parentId" : "4254a37a-1b01-4718-80a8-4f0dcca7ac8a",
        "authorId" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "body" : "Naming is hard.\n\nOn Thu, Apr 23, 2015 at 10:02 PM, Yifan Gu notifications@github.com wrote:\n\n> In pkg/kubelet/dockertools/manager.go\n> https://github.com/GoogleCloudPlatform/kubernetes/pull/7271#discussion_r29019328\n> :\n> \n> > @@ -911,3 +902,35 @@ func (dm *DockerManager) KillContainer(containerID types.UID) error {\n> >     }\n> >     return err\n> >  }\n> > +\n> > +// Run a single container from a pod. Returns the docker container ID\n> > +func (dm *DockerManager) RunContainer(pod *api.Pod, container *api.Container, generator kubecontainer.RunContainerOptionsGenerator, runner kubecontainer.HandlerRunner, netMode, ipcMode string) (DockerID, error) {\n> \n> Sorry :( I am bad at naming..\n> \n> —\n> Reply to this email directly or view it on GitHub\n> https://github.com/GoogleCloudPlatform/kubernetes/pull/7271/files#r29019328\n> .\n",
        "createdAt" : "2015-04-24T02:08:54Z",
        "updatedAt" : "2015-04-24T02:08:54Z",
        "lastEditedBy" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "tags" : [
        ]
      }
    ],
    "commit" : "b5a1b32aa43509e74665a38725ee8137e6e84dbf",
    "line" : 52,
    "diffHunk" : "@@ -1,1 +905,909 @@\n// Run a single container from a pod. Returns the docker container ID\nfunc (dm *DockerManager) RunContainer(pod *api.Pod, container *api.Container, generator kubecontainer.RunContainerOptionsGenerator, runner kubecontainer.HandlerRunner, netMode, ipcMode string) (DockerID, error) {\n\tref, err := kubecontainer.GenerateContainerRef(pod, container)\n\tif err != nil {"
  },
  {
    "id" : "49672caa-4089-4a9a-992f-f8a5d2dc233e",
    "prId" : 6794,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "23afa4d8-856e-407a-8732-0df2d2b5d8ba",
        "parentId" : null,
        "authorId" : "b7abca6a-d6be-4008-a014-3b5ca0e90529",
        "body" : "I know this is slightly unrelated, but I'm worried this is gonna bite us in the future. containerStatus is actually a copy of what's inside statuses which is why we have to re-add it. Do you think that's clear in the flow today? I worry if someone adds a continue somewhere and silently we don't update the status after we edited it. A possible fix is to have the value be pointers instead of objects.\n",
        "createdAt" : "2015-04-14T16:16:35Z",
        "updatedAt" : "2015-04-14T22:06:51Z",
        "lastEditedBy" : "b7abca6a-d6be-4008-a014-3b5ca0e90529",
        "tags" : [
        ]
      },
      {
        "id" : "4dc6cf70-b291-4887-bc65-8b1ef3d9a2bb",
        "parentId" : "23afa4d8-856e-407a-8732-0df2d2b5d8ba",
        "authorId" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "body" : "Changed to use a pointer. I wholeheartedly agree that the flow here can be improved. It's very easy to break something. We should clean up the code sometime.\n",
        "createdAt" : "2015-04-14T17:13:44Z",
        "updatedAt" : "2015-04-14T22:06:51Z",
        "lastEditedBy" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "tags" : [
        ]
      },
      {
        "id" : "90151a45-5786-48bc-90fc-64311d8ef7f3",
        "parentId" : "23afa4d8-856e-407a-8732-0df2d2b5d8ba",
        "authorId" : "b7abca6a-d6be-4008-a014-3b5ca0e90529",
        "body" : "We end up having this conversation a lot :) Overall I think we're getting better not worse though!\n",
        "createdAt" : "2015-04-14T20:08:41Z",
        "updatedAt" : "2015-04-14T22:06:51Z",
        "lastEditedBy" : "b7abca6a-d6be-4008-a014-3b5ca0e90529",
        "tags" : [
        ]
      }
    ],
    "commit" : "fd34441d2d5b108b5e32f556536a326c720bb88b",
    "line" : null,
    "diffHunk" : "@@ -1,1 +292,296 @@\t\t}\n\n\t\tif containerStatus, found := statuses[dockerContainerName]; found {\n\t\t\tif containerStatus.LastTerminationState.Termination == nil && terminationState != nil {\n\t\t\t\t// Populate the last termination state."
  },
  {
    "id" : "d2836228-deb7-43d2-9f35-fe61a856c002",
    "prId" : 6634,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6987d0a2-5837-4470-bc11-0d9a4e6437fb",
        "parentId" : null,
        "authorId" : "b7abca6a-d6be-4008-a014-3b5ca0e90529",
        "body" : "nit: make private\n",
        "createdAt" : "2015-04-09T17:09:47Z",
        "updatedAt" : "2015-04-09T17:09:47Z",
        "lastEditedBy" : "b7abca6a-d6be-4008-a014-3b5ca0e90529",
        "tags" : [
        ]
      },
      {
        "id" : "30e45029-24d3-4b4e-8449-e24e757d99cd",
        "parentId" : "6987d0a2-5837-4470-bc11-0d9a4e6437fb",
        "authorId" : "b7abca6a-d6be-4008-a014-3b5ca0e90529",
        "body" : "Ah I see, nvm :)\n",
        "createdAt" : "2015-04-09T17:10:14Z",
        "updatedAt" : "2015-04-09T17:10:14Z",
        "lastEditedBy" : "b7abca6a-d6be-4008-a014-3b5ca0e90529",
        "tags" : [
        ]
      }
    ],
    "commit" : "b868f421e0c20c970ca57708642e0453eb14594f",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +44,48 @@\t// TODO(yifan): PodInfraContainerImage can be unexported once\n\t// we move createPodInfraContainer into dockertools.\n\tPodInfraContainerImage string\n}\n"
  }
]
[
  {
    "id" : "9ec424f3-12cb-428d-89ca-e8a640fdc735",
    "prId" : 69753,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/69753#pullrequestreview-166269245",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ff5f9d16-d3bd-4a8c-b905-f4ad81296145",
        "parentId" : null,
        "authorId" : "4186ed58-9575-4126-b730-073268bc67cb",
        "body" : "Also note the change here. We need this return value to know if pod CIDR is actually changed or not.",
        "createdAt" : "2018-10-18T19:57:32Z",
        "updatedAt" : "2018-11-07T19:59:54Z",
        "lastEditedBy" : "4186ed58-9575-4126-b730-073268bc67cb",
        "tags" : [
        ]
      }
    ],
    "commit" : "98fc4a107a8e6da008669b2792044a154f4a75a7",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +57,61 @@// updatePodCIDR updates the pod CIDR in the runtime state if it is different\n// from the current CIDR. Return true if pod CIDR is actually changed.\nfunc (kl *Kubelet) updatePodCIDR(cidr string) (bool, error) {\n\tkl.updatePodCIDRMux.Lock()\n\tdefer kl.updatePodCIDRMux.Unlock()"
  },
  {
    "id" : "b273806f-930d-4229-8b70-0f3dfb040142",
    "prId" : 35490,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/35490#pullrequestreview-6507736",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "90fee609-2112-4d5f-a98f-51ea5a8da16e",
        "parentId" : null,
        "authorId" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "body" : "When using CRI, will this block of code get executed, and if so, what's the consequence of sending duplicated events?\n",
        "createdAt" : "2016-10-31T17:05:13Z",
        "updatedAt" : "2016-11-01T01:24:36Z",
        "lastEditedBy" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "tags" : [
        ]
      },
      {
        "id" : "9554b61f-e940-4bda-9ee2-288127c44dee",
        "parentId" : "90fee609-2112-4d5f-a98f-51ea5a8da16e",
        "authorId" : "395f4f9a-98be-4485-b436-51f0897d7c9f",
        "body" : "nothing, but good question. Added some comments around networkPlugin=nil. \n",
        "createdAt" : "2016-10-31T19:26:47Z",
        "updatedAt" : "2016-11-01T01:24:36Z",
        "lastEditedBy" : "395f4f9a-98be-4485-b436-51f0897d7c9f",
        "tags" : [
        ]
      }
    ],
    "commit" : "2941aea88e80e94f2698241a4ac9925145664470",
    "line" : null,
    "diffHunk" : "@@ -1,1 +219,223 @@\t// kubelet -> network plugin\n\t// cri runtime shims are responsible for their own network plugins\n\tif kl.networkPlugin != nil {\n\t\tdetails := make(map[string]interface{})\n\t\tdetails[network.NET_PLUGIN_EVENT_POD_CIDR_CHANGE_DETAIL_CIDR] = cidr"
  },
  {
    "id" : "a0574221-e3e5-444f-b13d-19fb2be647d9",
    "prId" : 33862,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/33862#pullrequestreview-2949543",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e9e7f300-f6a9-44be-963e-9c0023644e71",
        "parentId" : null,
        "authorId" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "body" : "we still want a flag that does this probably. flannelExperimentalOverlay is the wrong name.\n",
        "createdAt" : "2016-09-30T22:34:14Z",
        "updatedAt" : "2016-10-04T09:45:43Z",
        "lastEditedBy" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "tags" : [
        ]
      },
      {
        "id" : "275488d5-4790-40e6-bcd9-e499902e1c8d",
        "parentId" : "e9e7f300-f6a9-44be-963e-9c0023644e71",
        "authorId" : "e83108b8-1fb2-416b-9298-d5b70c14f708",
        "body" : "One can use the CNI flannel plugin. But that needs extra setup for flannel daemon and etc. \n\nI think that is much cleaner than having a flag for flannel. \n",
        "createdAt" : "2016-09-30T23:33:59Z",
        "updatedAt" : "2016-10-04T09:45:43Z",
        "lastEditedBy" : "e83108b8-1fb2-416b-9298-d5b70c14f708",
        "tags" : [
        ]
      },
      {
        "id" : "e7b9b958-c69e-4628-8003-94b9ae203eec",
        "parentId" : "e9e7f300-f6a9-44be-963e-9c0023644e71",
        "authorId" : "bfe6ebf1-cfa7-4758-abb1-9960fa09b194",
        "body" : "At least, this isn't a regression. \nNobody (at least not many) has used the experimental flannel overlay, and if we want to add a new flag for this specific case, we can do it later\n",
        "createdAt" : "2016-10-01T13:21:10Z",
        "updatedAt" : "2016-10-04T09:45:43Z",
        "lastEditedBy" : "bfe6ebf1-cfa7-4758-abb1-9960fa09b194",
        "tags" : [
        ]
      },
      {
        "id" : "ad1bb37b-341e-4fa6-9905-ba30b3c8ad9d",
        "parentId" : "e9e7f300-f6a9-44be-963e-9c0023644e71",
        "authorId" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "body" : "@freehan I think we have the same problem for not just flannel. If I'm using the gce cloud provider with weave and I don't want to configure routes, kubelet will report not ready. There is no way of opting out of gce routes with the gce cloud provider. Is that an issue?\n",
        "createdAt" : "2016-10-01T17:50:53Z",
        "updatedAt" : "2016-10-04T09:45:43Z",
        "lastEditedBy" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "tags" : [
        ]
      },
      {
        "id" : "cef27df8-afd2-4fbb-8c3b-38628a4c5211",
        "parentId" : "e9e7f300-f6a9-44be-963e-9c0023644e71",
        "authorId" : "e83108b8-1fb2-416b-9298-d5b70c14f708",
        "body" : "@mikedanese what does kubelet complain in the weave case? I do not recall kubelet checks podCIDR unless it comes from network plugin. I think the assigned route can be ignored by configuration. \n",
        "createdAt" : "2016-10-03T17:20:43Z",
        "updatedAt" : "2016-10-04T09:45:43Z",
        "lastEditedBy" : "e83108b8-1fb2-416b-9298-d5b70c14f708",
        "tags" : [
        ]
      },
      {
        "id" : "17ed04c9-8d35-49f8-95d0-16df5731c9f4",
        "parentId" : "e9e7f300-f6a9-44be-963e-9c0023644e71",
        "authorId" : "bfe6ebf1-cfa7-4758-abb1-9960fa09b194",
        "body" : "I think you should open a separate issue for that discussion.\nPlease do that and keep focusing on the PR itself\n",
        "createdAt" : "2016-10-03T19:37:46Z",
        "updatedAt" : "2016-10-04T09:45:43Z",
        "lastEditedBy" : "bfe6ebf1-cfa7-4758-abb1-9960fa09b194",
        "tags" : [
        ]
      },
      {
        "id" : "a1302940-cbfb-454c-80a1-460bdb864814",
        "parentId" : "e9e7f300-f6a9-44be-963e-9c0023644e71",
        "authorId" : "57f729dd-988a-4d1a-83bf-ee70bf637c64",
        "body" : "I brought this up in https://github.com/kubernetes/kubernetes/pull/33573#issuecomment-251719452.  It's a problem for OpenShift when run on GCE too, as we use an overlay and don't need Routes created for pod<->pod communication, but the NetworkUnavailable condition is set anyway.\n\nBut I think this should be solved differently and more cleanly than repurposing the flannelExperimentalOverlay flag.\n",
        "createdAt" : "2016-10-05T16:20:06Z",
        "updatedAt" : "2016-10-05T16:20:06Z",
        "lastEditedBy" : "57f729dd-988a-4d1a-83bf-ee70bf637c64",
        "tags" : [
        ]
      }
    ],
    "commit" : "4e52f84e084ed43806e6bccd4496f016bf479488",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +89,93 @@\t// true for cloud providers if they implement Routes() interface and\n\t// we are not using overlay networking.\n\tif kl.cloud == nil || kl.cloud.ProviderName() != \"gce\" {\n\t\treturn false\n\t}"
  },
  {
    "id" : "68679555-69a5-4716-9c8b-502e37f393c0",
    "prId" : 29666,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/29666#pullrequestreview-17529658",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ecdedce1-ec7a-45f1-a19b-af21c537f908",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "This is tricky enough that it warrants a unit test.  If this is all I find, I'll approve without it, and you can follow-up ",
        "createdAt" : "2017-01-18T06:39:31Z",
        "updatedAt" : "2017-01-18T06:46:29Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "b7f006df-39f7-4c0f-82cb-c11ad90f33d2",
        "parentId" : "ecdedce1-ec7a-45f1-a19b-af21c537f908",
        "authorId" : "94b8bf8e-9b43-4688-80ab-ca5d0064d3e0",
        "body" : "I've added unit test for checking return value of formDNSSearch, which consists of omitDuplicates call and formDNSSearchFitsLimits, you think it's not enough?",
        "createdAt" : "2017-01-19T18:55:42Z",
        "updatedAt" : "2017-01-19T18:55:42Z",
        "lastEditedBy" : "94b8bf8e-9b43-4688-80ab-ca5d0064d3e0",
        "tags" : [
        ]
      }
    ],
    "commit" : "d9254397272c238feda03abcc57ff3a58bebc20b",
    "line" : 15,
    "diffHunk" : "@@ -1,1 +94,98 @@\tuniqueDomains := map[string]bool{}\n\n\tfor _, dnsDomain := range combinedSearch {\n\t\tif _, exists := uniqueDomains[dnsDomain]; !exists {\n\t\t\tcombinedSearch[len(uniqueDomains)] = dnsDomain"
  },
  {
    "id" : "47ec93a7-f5e7-41d4-bb0c-c8bddf35856b",
    "prId" : 29666,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/29666#pullrequestreview-17529647",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "33be144c-1e52-4d6e-b3e9-288b76b0b52c",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "typo: Doamins",
        "createdAt" : "2017-01-18T06:41:13Z",
        "updatedAt" : "2017-01-18T06:46:29Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "dc9aafcb-4ba9-4b91-bbf7-91b77c1b7d3e",
        "parentId" : "33be144c-1e52-4d6e-b3e9-288b76b0b52c",
        "authorId" : "94b8bf8e-9b43-4688-80ab-ca5d0064d3e0",
        "body" : "will fix",
        "createdAt" : "2017-01-19T18:55:40Z",
        "updatedAt" : "2017-01-19T18:55:40Z",
        "lastEditedBy" : "94b8bf8e-9b43-4688-80ab-ca5d0064d3e0",
        "tags" : [
        ]
      }
    ],
    "commit" : "d9254397272c238feda03abcc57ff3a58bebc20b",
    "line" : 41,
    "diffHunk" : "@@ -1,1 +120,124 @@\tif resolvSearchhLineStrLen := len(strings.Join(composedSearch, \" \")); resolvSearchhLineStrLen > resolvSearchLineLenLimit {\n\t\tcutDomainsNum := 0\n\t\tcutDoaminsLen := 0\n\t\tfor i := len(composedSearch) - 1; i >= 0; i-- {\n\t\t\tcutDoaminsLen += len(composedSearch[i]) + 1"
  },
  {
    "id" : "668804ad-6ea7-4939-af60-42010270c906",
    "prId" : 29666,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/29666#pullrequestreview-17822861",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "590d6cc1-95ac-4251-a954-1c79b2915e98",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "I still feel like this could merge into omitDuplicates() and just send an event to both destinations.  But it's not qorth another back-and-forth",
        "createdAt" : "2017-01-18T06:46:13Z",
        "updatedAt" : "2017-01-18T06:46:29Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "abb67274-506e-4311-86ae-3e671827055f",
        "parentId" : "590d6cc1-95ac-4251-a954-1c79b2915e98",
        "authorId" : "94b8bf8e-9b43-4688-80ab-ca5d0064d3e0",
        "body" : "I think this resolver.conf check should be done periodically as it more relates to node's status, and this was a compromise of not making node unhealth and exclude it from cluster until the issue exists. Also in case of cluster in more or less stable state, when all pods deployed, such events will be cleared after 1h.\r\n\r\nAlso I think we can't just add into omitDuplicates() as pods could be added and updated by bunches and it doesn't make sense to check several times at once and  generate bunches of the same events and logs. \r\n\r\nSo if you still want to get rid of checking it inside goroutune, then maybe the right place will be to call it inside syncLoopIteration for ADD and Update ops, WDYT?",
        "createdAt" : "2017-01-19T18:54:36Z",
        "updatedAt" : "2017-01-19T18:54:36Z",
        "lastEditedBy" : "94b8bf8e-9b43-4688-80ab-ca5d0064d3e0",
        "tags" : [
        ]
      },
      {
        "id" : "5e8a1bc7-5615-4571-ad5a-5a80e5b8e1f3",
        "parentId" : "590d6cc1-95ac-4251-a954-1c79b2915e98",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "OK, I can live with it as a goroutine.  Would be nice to have a function that captured the duplicate logic and logged the appropriate event.  Can you send a followup, since this merged?\r\n\r\nThanks!",
        "createdAt" : "2017-01-22T07:59:17Z",
        "updatedAt" : "2017-01-22T07:59:17Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "d9254397272c238feda03abcc57ff3a58bebc20b",
    "line" : 83,
    "diffHunk" : "@@ -1,1 +162,166 @@}\n\nfunc (kl *Kubelet) checkLimitsForResolvConf() {\n\t// resolver file Search line current limitations\n\tresolvSearchLineDNSDomainsLimit := 6"
  }
]
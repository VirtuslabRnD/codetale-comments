[
  {
    "id" : "c2fde652-987b-4cdc-95ec-d01e661cc422",
    "prId" : 67978,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/67978#pullrequestreview-151122671",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f90859f5-e2f0-4e1d-9202-d6174218ae8e",
        "parentId" : null,
        "authorId" : "e81e699e-eb6c-4380-bfd5-16ab81ac51d6",
        "body" : "grab `m.cacheMutex`",
        "createdAt" : "2018-08-30T18:23:17Z",
        "updatedAt" : "2018-10-23T02:24:22Z",
        "lastEditedBy" : "e81e699e-eb6c-4380-bfd5-16ab81ac51d6",
        "tags" : [
        ]
      }
    ],
    "commit" : "060f3a84d97f4a7b792f0f58f7adb703b8bedc70",
    "line" : 17,
    "diffHunk" : "@@ -1,1 +105,109 @@\tm.cacheMutex.Lock()\n\tdefer m.cacheMutex.Unlock()\n\tfor k, tr := range m.cache {\n\t\tif tr.Spec.BoundObjectRef.UID == podUID {\n\t\t\tdelete(m.cache, k)"
  },
  {
    "id" : "82fc1d2e-d24b-4776-b55e-a06336c35a73",
    "prId" : 62005,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/62005#pullrequestreview-125718806",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e7ab8d22-0e9b-4f0d-be53-693d62cd8556",
        "parentId" : null,
        "authorId" : "9f030d50-62db-4b00-a28c-847709b74d97",
        "body" : "Is `name` the service account name, or pod name? In either case, should this include a UID?",
        "createdAt" : "2018-06-04T18:50:27Z",
        "updatedAt" : "2018-06-05T00:22:45Z",
        "lastEditedBy" : "9f030d50-62db-4b00-a28c-847709b74d97",
        "tags" : [
        ]
      },
      {
        "id" : "f1deefba-d570-499b-ae1d-fb4c21139ef6",
        "parentId" : "e7ab8d22-0e9b-4f0d-be53-693d62cd8556",
        "authorId" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "body" : "The name, namespace are of the service account. The actual TokenRequest has pod name and pod UID included in the object binding, which is validated on the apiserver. We can't include service account UID because that information is not present on the pod object.",
        "createdAt" : "2018-06-04T19:53:57Z",
        "updatedAt" : "2018-06-05T00:22:45Z",
        "lastEditedBy" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "tags" : [
        ]
      }
    ],
    "commit" : "91feb345aa021fd69161a6635f5d6fcf50af8680",
    "line" : 71,
    "diffHunk" : "@@ -1,1 +69,73 @@// * If refresh fails and the old token is still valid, log an error and return the old token.\n// * If refresh fails and the old token is no longer valid, return an error\nfunc (m *Manager) GetServiceAccountToken(name, namespace string, tr *authenticationv1.TokenRequest) (*authenticationv1.TokenRequest, error) {\n\tkey := keyFunc(name, namespace, tr)\n\tctr, ok := m.get(key)"
  },
  {
    "id" : "e208e88a-9b04-4b43-aca8-220c64958d15",
    "prId" : 62005,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/62005#pullrequestreview-125727966",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8b5f85ba-53ca-4c77-85e3-6a9d7be4f239",
        "parentId" : null,
        "authorId" : "9f030d50-62db-4b00-a28c-847709b74d97",
        "body" : "Does this need to include expiration time? If it's encoded in the token, then I think the answer is yes. If it just controls the cache, then maybe not?",
        "createdAt" : "2018-06-04T18:52:42Z",
        "updatedAt" : "2018-06-05T00:22:45Z",
        "lastEditedBy" : "9f030d50-62db-4b00-a28c-847709b74d97",
        "tags" : [
        ]
      },
      {
        "id" : "8741bf10-d965-4e3d-ba06-2c437b8a8e5c",
        "parentId" : "8b5f85ba-53ca-4c77-85e3-6a9d7be4f239",
        "authorId" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "body" : "It doesn't need an expiration time. The cache is essentially a map from TokenRequestSpec to TokenRequestStatus so an expiration timestamp is an attribute of the status.",
        "createdAt" : "2018-06-04T19:51:24Z",
        "updatedAt" : "2018-06-05T00:22:45Z",
        "lastEditedBy" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "tags" : [
        ]
      },
      {
        "id" : "dba393a6-97b3-46e8-a970-c247563a77b9",
        "parentId" : "8b5f85ba-53ca-4c77-85e3-6a9d7be4f239",
        "authorId" : "9f030d50-62db-4b00-a28c-847709b74d97",
        "body" : "Er, sorry, I meant `ExpirationSeconds`. I.e. I'm wondering if 2 volumes with the same spec but different expirations could share a cache entry. I expect this to be a pretty unlikely scenario, so it's probably not worth changing.",
        "createdAt" : "2018-06-04T20:04:02Z",
        "updatedAt" : "2018-06-05T00:22:45Z",
        "lastEditedBy" : "9f030d50-62db-4b00-a28c-847709b74d97",
        "tags" : [
        ]
      },
      {
        "id" : "59ccf2a4-5b94-4ab9-a111-f221a86ee38d",
        "parentId" : "8b5f85ba-53ca-4c77-85e3-6a9d7be4f239",
        "authorId" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "body" : "The ExpirationSeconds is in tr.Spec so the requested expiration is included in the cache key. Right now the requested expiration seconds will always be the expiration seconds, because we aren't implementing any sort of softmax. Two volume projections with the same spec should always project the same token.",
        "createdAt" : "2018-06-04T20:21:42Z",
        "updatedAt" : "2018-06-05T00:22:45Z",
        "lastEditedBy" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "tags" : [
        ]
      }
    ],
    "commit" : "91feb345aa021fd69161a6635f5d6fcf50af8680",
    "line" : 146,
    "diffHunk" : "@@ -1,1 +144,148 @@// keys should be nonconfidential and safe to log\nfunc keyFunc(name, namespace string, tr *authenticationv1.TokenRequest) string {\n\treturn fmt.Sprintf(\"%q/%q/%#v\", name, namespace, tr.Spec)\n}"
  },
  {
    "id" : "b1d262db-ddec-48a6-b03e-fea40e95a1f5",
    "prId" : 62005,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/62005#pullrequestreview-125765377",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "155eb5a3-fd39-4b1e-a059-627d3fadb15e",
        "parentId" : null,
        "authorId" : "9f030d50-62db-4b00-a28c-847709b74d97",
        "body" : "I think this is growing unbounded? It should grow slowly, but you need some way of clearing out old tokens.",
        "createdAt" : "2018-06-04T22:32:24Z",
        "updatedAt" : "2018-06-05T00:22:45Z",
        "lastEditedBy" : "9f030d50-62db-4b00-a28c-847709b74d97",
        "tags" : [
        ]
      }
    ],
    "commit" : "91feb345aa021fd69161a6635f5d6fcf50af8680",
    "line" : 92,
    "diffHunk" : "@@ -1,1 +90,94 @@\t}\n\n\tm.set(key, tr)\n\treturn tr, nil\n}"
  }
]
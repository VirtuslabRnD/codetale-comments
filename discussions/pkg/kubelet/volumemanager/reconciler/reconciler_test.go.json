[
  {
    "id" : "be7e262f-d7c9-407a-a813-f9c007f1be65",
    "prId" : 100215,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/100215#pullrequestreview-611676380",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "dde7b718-c512-477f-9b78-6f581b39e261",
        "parentId" : null,
        "authorId" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "body" : "is there a test failure for this?",
        "createdAt" : "2021-03-13T19:06:49Z",
        "updatedAt" : "2021-03-14T05:21:07Z",
        "lastEditedBy" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "tags" : [
        ]
      },
      {
        "id" : "d891b3f1-eea3-4d24-8d99-c3940374e82e",
        "parentId" : "dde7b718-c512-477f-9b78-6f581b39e261",
        "authorId" : "5e225159-999d-430a-8b58-d5220dc1429d",
        "body" : "similiar issue, I found it in local ‘stress’ testing.",
        "createdAt" : "2021-03-14T05:07:22Z",
        "updatedAt" : "2021-03-14T05:21:07Z",
        "lastEditedBy" : "5e225159-999d-430a-8b58-d5220dc1429d",
        "tags" : [
        ]
      },
      {
        "id" : "55fd6eef-092e-42d4-b660-2c2a265d7e25",
        "parentId" : "dde7b718-c512-477f-9b78-6f581b39e261",
        "authorId" : "5e225159-999d-430a-8b58-d5220dc1429d",
        "body" : "#94568 I checked the error message is the same.",
        "createdAt" : "2021-03-14T09:36:32Z",
        "updatedAt" : "2021-03-14T09:36:32Z",
        "lastEditedBy" : "5e225159-999d-430a-8b58-d5220dc1429d",
        "tags" : [
        ]
      }
    ],
    "commit" : "0bb911f90a62be9647b23b37d86770f79dcc16f6",
    "line" : 44,
    "diffHunk" : "@@ -1,1 +1837,1841 @@\t\tt.Logf(\"UnmountDevice called\")\n\t\tgeneratedVolumeName, err = dsw.AddPodToVolume(\n\t\t\tpodName, pod, volumeSpecCopy, volumeSpec.Name(), \"\" /* volumeGidValue */)\n\t\tdsw.MarkVolumesReportedInUse([]v1.UniqueVolumeName{generatedVolumeName})\n\t\treturn nil"
  },
  {
    "id" : "413cc365-fdfe-4ccf-a90a-0de469cebe5b",
    "prId" : 100215,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/100215#pullrequestreview-612892002",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0c7afd2c-01a1-4bff-8b8a-0c8f126ec4a2",
        "parentId" : null,
        "authorId" : "87fae8a2-4751-4356-ba8a-ce265708b853",
        "body" : "this `defer` is interesting, in what case `reconciler.Run` would throw an error so that `close` is not called?",
        "createdAt" : "2021-03-15T16:05:16Z",
        "updatedAt" : "2021-03-15T16:05:16Z",
        "lastEditedBy" : "87fae8a2-4751-4356-ba8a-ce265708b853",
        "tags" : [
        ]
      },
      {
        "id" : "05c2ea2f-664c-410a-9d92-b642606c0753",
        "parentId" : "0c7afd2c-01a1-4bff-8b8a-0c8f126ec4a2",
        "authorId" : "5e225159-999d-430a-8b58-d5220dc1429d",
        "body" : "I just think “defer” would be better. It can avoid hanging here.\r\n\r\nThis `defer` is not related to the date race. If it doesn't make sense, I'd revert the code here.",
        "createdAt" : "2021-03-16T00:55:21Z",
        "updatedAt" : "2021-03-16T01:46:34Z",
        "lastEditedBy" : "5e225159-999d-430a-8b58-d5220dc1429d",
        "tags" : [
        ]
      },
      {
        "id" : "65dd81af-cb14-43c0-a649-3edf8d4677bf",
        "parentId" : "0c7afd2c-01a1-4bff-8b8a-0c8f126ec4a2",
        "authorId" : "87fae8a2-4751-4356-ba8a-ce265708b853",
        "body" : "I was just curious about the why, I believe that if there's an error in `reconciler.Run` the test would fail and cleanup at that point wouldn't affect the result of the test, I don't think that reverting this part is necessary, thanks for the explanation",
        "createdAt" : "2021-03-16T06:37:12Z",
        "updatedAt" : "2021-03-16T06:37:12Z",
        "lastEditedBy" : "87fae8a2-4751-4356-ba8a-ce265708b853",
        "tags" : [
        ]
      }
    ],
    "commit" : "0bb911f90a62be9647b23b37d86770f79dcc16f6",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +1142,1146 @@\t\t\tgo func() {\n\t\t\t\tdefer close(stoppedChan)\n\t\t\t\treconciler.Run(stopChan)\n\t\t\t}()\n\t\t\twaitForMount(t, fakePlugin, volumeName, asw)"
  },
  {
    "id" : "2ac733fc-641a-421d-97bd-a88d21eae648",
    "prId" : 94676,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/94676#pullrequestreview-487665149",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f7f2f2d6-4f03-4e2b-9db0-0a2fd559edd7",
        "parentId" : null,
        "authorId" : "9e6ce3ed-e2f7-40ea-b6d7-b1b04fc48f70",
        "body" : "I am not quite familiar with the reconcile process, is it expected that `fakePlugin.NewAttacher()` still get invoked even after the reconciler has been stopped? This seems a bit strange to me.",
        "createdAt" : "2020-09-11T13:56:57Z",
        "updatedAt" : "2020-10-19T08:29:57Z",
        "lastEditedBy" : "9e6ce3ed-e2f7-40ea-b6d7-b1b04fc48f70",
        "tags" : [
        ]
      },
      {
        "id" : "c4ae5eff-d56d-4d42-b488-4c2780ea157c",
        "parentId" : "f7f2f2d6-4f03-4e2b-9db0-0a2fd559edd7",
        "authorId" : "5c4757f6-5a7a-438b-b77f-778928cb6979",
        "body" : "yeah, maybe it's just in execution. .from the error output. In the code,  It 's just a routine. The call chains like this from the outside to inner.\r\n> reconciler.Run(stopChan) ->  rc.mountAttachVolumes() -> rc.operationExecutor.MountVolume(...) -> oe.pendingOperations.Run(....) -> generatedOperations.Run()（this will new a routine to run）-> o.OperationFunc() -> deviceMountableVolumePlugin.NewDeviceMounter()  ->  fakeVolumePlugin.NewAttacher().",
        "createdAt" : "2020-09-14T11:35:06Z",
        "updatedAt" : "2020-10-19T08:29:57Z",
        "lastEditedBy" : "5c4757f6-5a7a-438b-b77f-778928cb6979",
        "tags" : [
        ]
      }
    ],
    "commit" : "b6b462beba42f5edfca27d310484b0348221ee92",
    "line" : 25,
    "diffHunk" : "@@ -1,1 +1792,1796 @@\n\tfinished := make(chan interface{})\n\tfakePlugin.Lock()\n\tfakePlugin.UnmountDeviceHook = func(mountPath string) error {\n\t\t// Act:"
  },
  {
    "id" : "8dbfb537-0c0e-4ce0-9ae2-aea3695ae5c3",
    "prId" : 73404,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/73404#pullrequestreview-198339617",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "eaa3226a-9803-4b9f-92b1-c56bfc86080e",
        "parentId" : null,
        "authorId" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "body" : "can we not acquire locks before setting those hooks? The approach works as well but it may be bit cleaner to do that. So basically I am thinking that test should define a function called `SetWaitForAttach` or something which acquires lock and then sets the hook. ",
        "createdAt" : "2019-01-28T15:15:53Z",
        "updatedAt" : "2019-01-28T15:16:35Z",
        "lastEditedBy" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "tags" : [
        ]
      },
      {
        "id" : "b913fb26-f426-4295-aed1-c4db67fa8bf4",
        "parentId" : "eaa3226a-9803-4b9f-92b1-c56bfc86080e",
        "authorId" : "d0f794d1-a9d4-4c31-aacc-fb35543cf586",
        "body" : "I copied this from other place in the tests so this approach is already being used. I don't know how much easier would it be to introduce another locking mechanism between the fake plugin and the reconciler. The reconciler just needs to be prevented from reading/using the plugin for a moment and this way it seems to be actually quite readable.",
        "createdAt" : "2019-01-28T15:45:48Z",
        "updatedAt" : "2019-01-28T15:45:48Z",
        "lastEditedBy" : "d0f794d1-a9d4-4c31-aacc-fb35543cf586",
        "tags" : [
        ]
      },
      {
        "id" : "50e9e0c9-560c-4002-a682-87b6b7215425",
        "parentId" : "eaa3226a-9803-4b9f-92b1-c56bfc86080e",
        "authorId" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "body" : "It may be matter of preference. I personally find creating multiple channels and stopping and starting reconciler - hard to read and reason about.  ",
        "createdAt" : "2019-01-28T16:15:40Z",
        "updatedAt" : "2019-01-28T16:15:40Z",
        "lastEditedBy" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "tags" : [
        ]
      },
      {
        "id" : "f9c78169-b6b4-44f2-b998-e3bcce6d8260",
        "parentId" : "eaa3226a-9803-4b9f-92b1-c56bfc86080e",
        "authorId" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "body" : "It didn't seem like a deal breaker, so I am going to lgtm for now. ",
        "createdAt" : "2019-01-30T22:26:06Z",
        "updatedAt" : "2019-01-30T22:26:06Z",
        "lastEditedBy" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "tags" : [
        ]
      }
    ],
    "commit" : "45464f03494bf5c7efb09e44cc07e7125c748cb3",
    "line" : 24,
    "diffHunk" : "@@ -1,1 +1263,1267 @@\t// Start the reconciler again.\n\tgo reconciler.Run(wait.NeverStop)\n\n\t// 2. Delete the volume from DSW (and wait for callbacks)\n\tdsw.DeletePodFromVolume(podName, generatedVolumeName)"
  },
  {
    "id" : "23ee619b-92d8-46df-9d3d-f69b9e50ea27",
    "prId" : 36280,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/36280#pullrequestreview-7520959",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8e985f06-d014-43b1-ba66-473bc56ad6ef",
        "parentId" : null,
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "nit: when it is not obvious what a variable is that you are passing, stick the parameter name as a comment next to it. e.g.:\n\n``` GO\nNewOperationExecutor(kubeClient, volumePluginMgr, fakeRecorder, false /* checkNodeCapabilitiesBeforeMount */)\n```\n",
        "createdAt" : "2016-11-07T21:59:41Z",
        "updatedAt" : "2016-11-09T23:16:22Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      },
      {
        "id" : "90620617-693e-4af8-a485-66e406b5327d",
        "parentId" : "8e985f06-d014-43b1-ba66-473bc56ad6ef",
        "authorId" : "3493bb4b-b4bb-4e5d-b6dc-7c87de7da51b",
        "body" : "Done\n",
        "createdAt" : "2016-11-07T22:34:04Z",
        "updatedAt" : "2016-11-09T23:16:22Z",
        "lastEditedBy" : "3493bb4b-b4bb-4e5d-b6dc-7c87de7da51b",
        "tags" : [
        ]
      }
    ],
    "commit" : "d81e216fc6b421bd15be5bf17c3983f959809083",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +324,328 @@\tkubeClient := createTestClient()\n\tfakeRecorder := &record.FakeRecorder{}\n\toex := operationexecutor.NewOperationExecutor(kubeClient, volumePluginMgr, fakeRecorder, false)\n\treconciler := NewReconciler(\n\t\tkubeClient,"
  },
  {
    "id" : "0e6e4228-9396-4ede-a34c-165eb7c7e25e",
    "prId" : 27778,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c17266f1-8369-42b5-908a-2d08a5107276",
        "parentId" : null,
        "authorId" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "body" : "nit: you can save a couple lines total with an object mother method for this test that just adds in the fake recorder and uses a supplied client and volume plugin manager\n",
        "createdAt" : "2016-07-22T01:14:07Z",
        "updatedAt" : "2016-08-17T13:54:17Z",
        "lastEditedBy" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "tags" : [
        ]
      }
    ],
    "commit" : "782d7d9815c18bcbf1272803c25027ebdad7995e",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +59,63 @@\tasw := cache.NewActualStateOfWorld(nodeName, volumePluginMgr)\n\tkubeClient := createTestClient()\n\tfakeRecorder := &record.FakeRecorder{}\n\toex := operationexecutor.NewOperationExecutor(kubeClient, volumePluginMgr, fakeRecorder)\n\treconciler := NewReconciler("
  }
]
[
  {
    "id" : "83fb4462-87e6-45a6-8754-d41ea07026bd",
    "prId" : 100465,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/100465#pullrequestreview-618190985",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "830cd013-7166-4e67-a31a-ddcfa4959ad6",
        "parentId" : null,
        "authorId" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "body" : "maybe add a comment above err != nil mentioning reconstructedVolume will be nil when err != nil to avoid such mistakes in the future. ",
        "createdAt" : "2021-03-23T04:13:57Z",
        "updatedAt" : "2021-03-23T04:13:57Z",
        "lastEditedBy" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "tags" : [
        ]
      }
    ],
    "commit" : "f756bd518922c2761a370cb800565267ac0f83eb",
    "line" : 1,
    "diffHunk" : "@@ -1,1 +402,406 @@\t\treconstructedVolume, err := rc.reconstructVolume(volume)\n\t\tif err != nil {\n\t\t\tif volumeInDSW {\n\t\t\t\t// Some pod needs the volume, don't clean it up and hope that\n\t\t\t\t// reconcile() calls SetUp and reconstructs the volume in ASW."
  },
  {
    "id" : "dda1d0e0-3049-4eaf-8a72-ff18a8e7c71a",
    "prId" : 98850,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/98850#pullrequestreview-602341283",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6bd7afa3-b215-4956-8595-47fe0fe6dfab",
        "parentId" : null,
        "authorId" : "31a2ac00-6c67-4307-a4bc-bfd13f41ef27",
        "body" : "In another comment, @serathius asked for these to be refactored so we no longer need to call this GenerateMsgDetailed here. I agree but let's do that in a follow-up PR.",
        "createdAt" : "2021-03-02T23:15:01Z",
        "updatedAt" : "2021-03-17T00:59:37Z",
        "lastEditedBy" : "31a2ac00-6c67-4307-a4bc-bfd13f41ef27",
        "tags" : [
        ]
      }
    ],
    "commit" : "01a4e4facebda8a643383625d3cece724efe2a66",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +183,187 @@\t\tif !rc.desiredStateOfWorld.PodExistsInVolume(mountedVolume.PodName, mountedVolume.VolumeName) {\n\t\t\t// Volume is mounted, unmount it\n\t\t\tklog.V(5).InfoS(mountedVolume.GenerateMsgDetailed(\"Starting operationExecutor.UnmountVolume\", \"\"))\n\t\t\terr := rc.operationExecutor.UnmountVolume(\n\t\t\t\tmountedVolume.MountedVolume, rc.actualStateOfWorld, rc.kubeletPodsDir)"
  },
  {
    "id" : "9704d35c-a4ef-43ca-9911-9f5c58c27b79",
    "prId" : 84218,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/84218#pullrequestreview-307617788",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c6e77827-0a61-414e-b343-644eadc4d8aa",
        "parentId" : null,
        "authorId" : "e4e7c71f-23b5-4203-b65d-3f5f3c503b64",
        "body" : "I replace `AttachableVolumePlugin` with `DeviceMounter` (DeviceMountableVolumePlugin) because:\r\n\r\n1) `AttachableVolumePlugin` wraps `DeviceMounter`, so all plugins implementing `AttachableVolumePlugin` implement `DeviceMounter` and can get device mount path via `GetDeviceMountPath()` method\r\n2) local plugin (and only this plugin) does not implement `AttachableVolumePlugin` but implements `DeviceMountableVolumePlugin`",
        "createdAt" : "2019-10-28T02:13:13Z",
        "updatedAt" : "2019-10-31T13:09:23Z",
        "lastEditedBy" : "e4e7c71f-23b5-4203-b65d-3f5f3c503b64",
        "tags" : [
        ]
      }
    ],
    "commit" : "0fd4cbcac445314956f9040a2b8c2500224a1dba",
    "line" : 8,
    "diffHunk" : "@@ -1,1 +357,361 @@\tdevicePath          string\n\tmounter             volumepkg.Mounter\n\tdeviceMounter       volumepkg.DeviceMounter\n\tblockVolumeMapper   volumepkg.BlockVolumeMapper\n}"
  },
  {
    "id" : "471717e8-754b-4656-b7cc-015b90f5c00a",
    "prId" : 84173,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/84173#pullrequestreview-304968151",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d358f1f1-943b-4cb4-9b9b-ce9bdbe20d96",
        "parentId" : null,
        "authorId" : "e4e7c71f-23b5-4203-b65d-3f5f3c503b64",
        "body" : "check `blockVolumeMapper` first because:\r\n\r\n- for local volume, AttachableVolumePlugin is not needed and not implemented\r\n- if it's not nil, deviceMountPath returned from `volumeAttacher.GetDeviceMountPath` is overridden",
        "createdAt" : "2019-10-22T05:26:29Z",
        "updatedAt" : "2019-10-23T11:32:26Z",
        "lastEditedBy" : "e4e7c71f-23b5-4203-b65d-3f5f3c503b64",
        "tags" : [
        ]
      }
    ],
    "commit" : "46b1e264dcef1f0583233abc5891efe7d1faa6ad",
    "line" : 18,
    "diffHunk" : "@@ -1,1 +588,592 @@func getDeviceMountPath(volume *reconstructedVolume) (string, error) {\n\tif volume.blockVolumeMapper != nil {\n\t\t// for block volume, we return its global map path\n\t\treturn volume.blockVolumeMapper.GetGlobalMapPath(volume.volumeSpec)\n\t} else if volume.attachablePlugin != nil {"
  },
  {
    "id" : "b68ba2db-084a-477b-b32c-9fa191c3a5ab",
    "prId" : 84173,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/84173#pullrequestreview-304968217",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fb57a6c6-9966-46ac-ae2f-da5005fcfc22",
        "parentId" : null,
        "authorId" : "e4e7c71f-23b5-4203-b65d-3f5f3c503b64",
        "body" : "unreachable but clearer",
        "createdAt" : "2019-10-22T05:26:50Z",
        "updatedAt" : "2019-10-23T11:32:26Z",
        "lastEditedBy" : "e4e7c71f-23b5-4203-b65d-3f5f3c503b64",
        "tags" : [
        ]
      }
    ],
    "commit" : "46b1e264dcef1f0583233abc5891efe7d1faa6ad",
    "line" : 28,
    "diffHunk" : "@@ -1,1 +598,602 @@\t\treturn volumeAttacher.GetDeviceMountPath(volume.volumeSpec)\n\t} else {\n\t\treturn \"\", fmt.Errorf(\"blockVolumeMapper or attachablePlugin required\")\n\t}\n}"
  },
  {
    "id" : "ac041ae3-4f58-4854-9fb7-c740bf4d7620",
    "prId" : 84173,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/84173#pullrequestreview-306940863",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c0158b07-b4ce-4d12-8c1b-b0fa7bbfc0ab",
        "parentId" : null,
        "authorId" : "e4e7c71f-23b5-4203-b65d-3f5f3c503b64",
        "body" : "local volume does not implement AttachableVolumePlugin but we need device path returned from `blockVolumeMapper.GetGlobalMapPath`",
        "createdAt" : "2019-10-22T05:27:57Z",
        "updatedAt" : "2019-10-23T11:32:26Z",
        "lastEditedBy" : "e4e7c71f-23b5-4203-b65d-3f5f3c503b64",
        "tags" : [
        ]
      },
      {
        "id" : "9c6d5065-b750-4124-8d1e-43c3a5385c17",
        "parentId" : "c0158b07-b4ce-4d12-8c1b-b0fa7bbfc0ab",
        "authorId" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "body" : "I would appreciate if the information above was captured as comment in the code, so we don't forget why it's the way it is.",
        "createdAt" : "2019-10-22T14:25:46Z",
        "updatedAt" : "2019-10-23T11:32:26Z",
        "lastEditedBy" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "tags" : [
        ]
      },
      {
        "id" : "682847a0-80a2-4851-bb3e-7c053dfc3940",
        "parentId" : "c0158b07-b4ce-4d12-8c1b-b0fa7bbfc0ab",
        "authorId" : "e4e7c71f-23b5-4203-b65d-3f5f3c503b64",
        "body" : "done\r\nit applies for all volume plugins which didn't implement `AttachableVolumePlugin` but implemented `BlockVolumeMapper`",
        "createdAt" : "2019-10-23T01:27:34Z",
        "updatedAt" : "2019-10-23T11:32:26Z",
        "lastEditedBy" : "e4e7c71f-23b5-4203-b65d-3f5f3c503b64",
        "tags" : [
        ]
      },
      {
        "id" : "f3da13d2-adab-4ef9-be57-af592c61c5fc",
        "parentId" : "c0158b07-b4ce-4d12-8c1b-b0fa7bbfc0ab",
        "authorId" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "body" : "Should it be attachable plugin or deviceMountable plugin?",
        "createdAt" : "2019-10-23T22:26:26Z",
        "updatedAt" : "2019-10-23T23:21:04Z",
        "lastEditedBy" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "tags" : [
        ]
      },
      {
        "id" : "7e090255-5af2-4360-8c1f-ea1b1658d18e",
        "parentId" : "c0158b07-b4ce-4d12-8c1b-b0fa7bbfc0ab",
        "authorId" : "e4e7c71f-23b5-4203-b65d-3f5f3c503b64",
        "body" : "It should be deviceMountable plugin (or check devideMounter). I will fix it in a follow PR which is going to support block fs local volume reconstruction. less change in this pr.",
        "createdAt" : "2019-10-24T00:09:02Z",
        "updatedAt" : "2019-10-24T00:09:03Z",
        "lastEditedBy" : "e4e7c71f-23b5-4203-b65d-3f5f3c503b64",
        "tags" : [
        ]
      },
      {
        "id" : "254c8539-3db5-4a22-9aaa-1f244c2cea42",
        "parentId" : "c0158b07-b4ce-4d12-8c1b-b0fa7bbfc0ab",
        "authorId" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "body" : "Can we also test a non-attachable plugin that implements block, like iscsi, to make sure this change is ok for them?",
        "createdAt" : "2019-10-24T02:46:12Z",
        "updatedAt" : "2019-10-24T02:46:12Z",
        "lastEditedBy" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "tags" : [
        ]
      },
      {
        "id" : "9c3f8308-9cba-48ce-891c-4f901a092071",
        "parentId" : "c0158b07-b4ce-4d12-8c1b-b0fa7bbfc0ab",
        "authorId" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "body" : "This succeeded: `[sig-storage] In-tree Volumes [Driver: iscsi][Feature:Volumes] [Testpattern: Pre-provisioned PV (block volmode)] disruptive[Disruptive] Should test that pv used in a pod that is force deleted while the kubelet is down cleans up when the kubelet returns.`",
        "createdAt" : "2019-10-24T10:44:24Z",
        "updatedAt" : "2019-10-24T10:44:24Z",
        "lastEditedBy" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "tags" : [
        ]
      },
      {
        "id" : "7aa7617f-d453-4a76-9799-a4dc52b7a6a0",
        "parentId" : "c0158b07-b4ce-4d12-8c1b-b0fa7bbfc0ab",
        "authorId" : "e4e7c71f-23b5-4203-b65d-3f5f3c503b64",
        "body" : "Thanks!",
        "createdAt" : "2019-10-24T19:13:16Z",
        "updatedAt" : "2019-10-24T19:13:16Z",
        "lastEditedBy" : "e4e7c71f-23b5-4203-b65d-3f5f3c503b64",
        "tags" : [
        ]
      },
      {
        "id" : "19b6d417-57f7-43e2-84e4-2f8876eaa675",
        "parentId" : "c0158b07-b4ce-4d12-8c1b-b0fa7bbfc0ab",
        "authorId" : "e4e7c71f-23b5-4203-b65d-3f5f3c503b64",
        "body" : "hi, I've checked all plugins, `iscsi` [implements AttachableVolumePlugin](https://github.com/kubernetes/kubernetes/blob/master/pkg/volume/iscsi/attacher.go#L45). Right now only local volume does not implement AttachableVolumePlugin but implements BlockVolumePlugin. So this code change only affects local volume.\r\n\r\n\r\n\r\n",
        "createdAt" : "2019-10-25T01:17:15Z",
        "updatedAt" : "2019-10-25T01:17:16Z",
        "lastEditedBy" : "e4e7c71f-23b5-4203-b65d-3f5f3c503b64",
        "tags" : [
        ]
      }
    ],
    "commit" : "46b1e264dcef1f0583233abc5891efe7d1faa6ad",
    "line" : 40,
    "diffHunk" : "@@ -1,1 +629,633 @@\t\tklog.V(4).Infof(\"Volume: %s (pod UID %s) is marked as mounted and added into the actual state\", volume.volumeName, volume.podName)\n\t\t// If the volume has device to mount, we mark its device as mounted.\n\t\tif volume.attachablePlugin != nil || volume.blockVolumeMapper != nil {\n\t\t\tdeviceMountPath, err := getDeviceMountPath(volume)\n\t\t\tif err != nil {"
  },
  {
    "id" : "e760aafd-608a-4d30-ad96-6286220afc38",
    "prId" : 82492,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/82492#pullrequestreview-286265062",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "932cb7f4-07c6-49ae-b4ca-f778d2fdcd7a",
        "parentId" : null,
        "authorId" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "body" : "PodExistsInVolume() returns true for MountUncertain volumes too?",
        "createdAt" : "2019-09-09T22:59:00Z",
        "updatedAt" : "2019-12-12T03:10:37Z",
        "lastEditedBy" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "tags" : [
        ]
      },
      {
        "id" : "275a63ef-49a9-4142-a82a-c112bc386102",
        "parentId" : "932cb7f4-07c6-49ae-b4ca-f778d2fdcd7a",
        "authorId" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "body" : "good catch! fixed and added test.",
        "createdAt" : "2019-09-10T16:01:00Z",
        "updatedAt" : "2019-12-12T03:10:37Z",
        "lastEditedBy" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "tags" : [
        ]
      }
    ],
    "commit" : "ca532c6fb2c08f859eca13e0557f3b2aec9a18e0",
    "line" : 32,
    "diffHunk" : "@@ -1,1 +202,206 @@\t// Ensure volumes that should be attached/mounted are attached/mounted.\n\tfor _, volumeToMount := range rc.desiredStateOfWorld.GetVolumesToMount() {\n\t\tvolMounted, devicePath, err := rc.actualStateOfWorld.PodExistsInVolume(volumeToMount.PodName, volumeToMount.VolumeName)\n\t\tvolumeToMount.DevicePath = devicePath\n\t\tif cache.IsVolumeNotAttachedError(err) {"
  },
  {
    "id" : "aea5ed95-fac3-4440-84a3-2fa676ac54d2",
    "prId" : 82492,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/82492#pullrequestreview-327188328",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bf0d55d5-2a10-4e71-aa9e-e7aece0f426a",
        "parentId" : null,
        "authorId" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "body" : "not a big issue, but this function could be implemented locally?",
        "createdAt" : "2019-12-03T19:37:42Z",
        "updatedAt" : "2019-12-12T03:10:37Z",
        "lastEditedBy" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "tags" : [
        ]
      },
      {
        "id" : "c58d243f-9f47-4125-9f50-c54507a184dd",
        "parentId" : "bf0d55d5-2a10-4e71-aa9e-e7aece0f426a",
        "authorId" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "body" : "I am thinking of leaving it as it is - since the resulting if statement looks quite big when placed inline and I do not like making a local helper function in this file.. :(",
        "createdAt" : "2019-12-04T19:56:50Z",
        "updatedAt" : "2019-12-12T03:10:37Z",
        "lastEditedBy" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "tags" : [
        ]
      },
      {
        "id" : "0c26ad8c-6a0c-4c6f-bdef-1aef1b11896c",
        "parentId" : "bf0d55d5-2a10-4e71-aa9e-e7aece0f426a",
        "authorId" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "body" : "I mean you can have a local function to check device maybe mounted?",
        "createdAt" : "2019-12-04T22:09:48Z",
        "updatedAt" : "2019-12-12T03:10:37Z",
        "lastEditedBy" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "tags" : [
        ]
      }
    ],
    "commit" : "ca532c6fb2c08f859eca13e0557f3b2aec9a18e0",
    "line" : 46,
    "diffHunk" : "@@ -1,1 +296,300 @@\t\tif !rc.desiredStateOfWorld.VolumeExists(attachedVolume.VolumeName) &&\n\t\t\t!rc.operationExecutor.IsOperationPending(attachedVolume.VolumeName, nestedpendingoperations.EmptyUniquePodName) {\n\t\t\tif attachedVolume.DeviceMayBeMounted() {\n\t\t\t\t// Volume is globally mounted to device, unmount it\n\t\t\t\tklog.V(5).Infof(attachedVolume.GenerateMsgDetailed(\"Starting operationExecutor.UnmountDevice\", \"\"))"
  },
  {
    "id" : "acd0d274-4e87-44b7-8b30-a5f87738e274",
    "prId" : 82492,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/82492#pullrequestreview-327103395",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1a99b20a-fdae-4462-bdc7-9dc8d11f7013",
        "parentId" : null,
        "authorId" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "body" : "not your change, but I forgot why we need to check operationPending only for unmountDevice?",
        "createdAt" : "2019-12-03T19:43:00Z",
        "updatedAt" : "2019-12-12T03:10:37Z",
        "lastEditedBy" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "tags" : [
        ]
      },
      {
        "id" : "86ff651b-e4f0-48d6-80a3-360590ac7da9",
        "parentId" : "1a99b20a-fdae-4462-bdc7-9dc8d11f7013",
        "authorId" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "body" : "Here is the PR that implemented this - https://github.com/kubernetes/kubernetes/pull/40417 ",
        "createdAt" : "2019-12-04T19:40:00Z",
        "updatedAt" : "2019-12-12T03:10:37Z",
        "lastEditedBy" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "tags" : [
        ]
      }
    ],
    "commit" : "ca532c6fb2c08f859eca13e0557f3b2aec9a18e0",
    "line" : 44,
    "diffHunk" : "@@ -1,1 +295,299 @@\t\t// Check IsOperationPending to avoid marking a volume as detached if it's in the process of mounting.\n\t\tif !rc.desiredStateOfWorld.VolumeExists(attachedVolume.VolumeName) &&\n\t\t\t!rc.operationExecutor.IsOperationPending(attachedVolume.VolumeName, nestedpendingoperations.EmptyUniquePodName) {\n\t\t\tif attachedVolume.DeviceMayBeMounted() {\n\t\t\t\t// Volume is globally mounted to device, unmount it"
  },
  {
    "id" : "c033bf24-9bf0-46cd-af6a-239ec6cb51eb",
    "prId" : 75071,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/75071#pullrequestreview-267391050",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b1143c65-8319-4780-8d8d-3616ac4de895",
        "parentId" : null,
        "authorId" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "body" : "Is having nil mounter safe to return in `reconstructedVolume`?",
        "createdAt" : "2019-07-12T01:26:05Z",
        "updatedAt" : "2019-08-01T21:10:57Z",
        "lastEditedBy" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "tags" : [
        ]
      },
      {
        "id" : "d089a3f4-2291-4d27-b9b2-ac0e5156c82e",
        "parentId" : "b1143c65-8319-4780-8d8d-3616ac4de895",
        "authorId" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "body" : "That's goal of this PR. CSI's `NewMounter` would create directory and a json file for a **block** volume, which we don't want. `reconstructedVolume` should have either `mounter` **or** `mapper`, same as regular volumes in DSW.",
        "createdAt" : "2019-07-12T11:40:08Z",
        "updatedAt" : "2019-08-01T21:10:57Z",
        "lastEditedBy" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "tags" : [
        ]
      },
      {
        "id" : "a619ee83-3d88-43d6-96c3-b589e727250e",
        "parentId" : "b1143c65-8319-4780-8d8d-3616ac4de895",
        "authorId" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "body" : "just to make sure, for block volume, mounter is not needed at all.",
        "createdAt" : "2019-07-17T20:32:09Z",
        "updatedAt" : "2019-08-01T21:10:57Z",
        "lastEditedBy" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "tags" : [
        ]
      },
      {
        "id" : "9b845556-bb88-4d60-b531-8e3b923baa4e",
        "parentId" : "b1143c65-8319-4780-8d8d-3616ac4de895",
        "authorId" : "9ce7bd1a-5286-4173-88a4-039146bf0d46",
        "body" : "@jingxu97\r\n\r\nThank you for your comment.\r\n\r\n> just to make sure, for block volume, mounter is not needed at all.\r\n\r\nAs I checked operation_executor/operation_generator code paths for block volume, mounter is not directly used in these paths, except [`GenerateExpandInUseVolumeFunc`](https://github.com/kubernetes/kubernetes/blob/master/pkg/volume/util/operationexecutor/operation_generator.go#L1633) .\r\nAnd I guess that this path won’t be reached for block volume, because `FSResizeRequired` won’t be set due to [this check](https://github.com/kubernetes/kubernetes/blob/master/pkg/kubelet/volumemanager/populator/desired_state_of_world_populator.go#L374).\r\n\r\nIs my understanding right? @gnufied @mlmhl\r\n\r\nAlso, could you double check if we should check any other paths deeper? @jsafrane\r\n\r\n```\r\nAttachVolume  --> GenerateAttachVolumeFunc --> <Attacher>\r\nDetachVolume --> GenerateDetachVolumeFunc --> <Detacher>\r\nMountVolume --> GenerateMapVolumeFunc --> <BlockVolumeMapper>\r\nUnmountVolume --> GenerateUnmapVolumeFunc --> <BlockVolumeUnmapper>\r\nUnmountDevice --> GenerateUnmapDeviceFunc --> <BlockVolumeUnmapper>\r\n\r\nExpandInUseVolume --> GenerateExpandInUseVolumeFunc --> <Attacher, Mounter>\r\n\r\nVerifyVolumesAreAttached --> GenerateBulkVolumeVerifyFunc --> <Attacher>\r\nVerifyVolumesAreAttachedPerNode --> GenerateVolumesAreAttachedFunc --> <Attacher>\r\nVerifyControllerAttachedVolume --> GenerateVerifyControllerAttachedVolumeFunc --> <None>\r\n\r\nReconstructVolumeOperation --> <None>\r\nCheckVolumeExistenceOperation --> <None>\r\n```\r\n",
        "createdAt" : "2019-07-18T18:21:17Z",
        "updatedAt" : "2019-08-01T21:10:57Z",
        "lastEditedBy" : "9ce7bd1a-5286-4173-88a4-039146bf0d46",
        "tags" : [
        ]
      },
      {
        "id" : "2d81ce3b-e6ce-4a09-bf10-ea7af2d3f4e0",
        "parentId" : "b1143c65-8319-4780-8d8d-3616ac4de895",
        "authorId" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "body" : "@mkimuram, thanks for your analysis! It confirms my finding that mounter is not really needed for block volumes.",
        "createdAt" : "2019-07-19T09:25:41Z",
        "updatedAt" : "2019-08-01T21:10:57Z",
        "lastEditedBy" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "tags" : [
        ]
      },
      {
        "id" : "a7b817ae-f2f2-49d1-9d7c-b86a1aa79298",
        "parentId" : "b1143c65-8319-4780-8d8d-3616ac4de895",
        "authorId" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "body" : "I was checking here, and thought there might be issue. But since it only loops over container.VolumeMounts which does not contain blockvolumes, it should be fine then.\r\nhttps://github.com/kubernetes/kubernetes/blob/master/pkg/kubelet/kubelet_pods.go#L146\r\n",
        "createdAt" : "2019-07-26T20:28:15Z",
        "updatedAt" : "2019-08-01T21:10:57Z",
        "lastEditedBy" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "tags" : [
        ]
      },
      {
        "id" : "1d14ad99-be95-4181-acb0-efef71dd85cc",
        "parentId" : "b1143c65-8319-4780-8d8d-3616ac4de895",
        "authorId" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "body" : "Maybe in MountedVolume definition, we can add the comment to make it clear that mounter is required for file system volumes, but not required for BlockVolumes, and BlockVolumeMapper is the opposite. \r\n",
        "createdAt" : "2019-07-26T20:31:14Z",
        "updatedAt" : "2019-08-01T21:10:57Z",
        "lastEditedBy" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "tags" : [
        ]
      }
    ],
    "commit" : "c130b77a4848b87b29a1b7dcc1cc8d83247e50e8",
    "line" : 50,
    "diffHunk" : "@@ -1,1 +521,525 @@\t\t}\n\t\tcheckPath, _ = volumeMapper.GetPodDeviceMapPath()\n\t} else {\n\t\tvar err error\n\t\tvolumeMounter, err = plugin.NewMounter("
  },
  {
    "id" : "66ac4c46-6928-4201-ac9c-40c224d544e6",
    "prId" : 75071,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/75071#pullrequestreview-268613996",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "14633b6a-b86f-4b7d-a330-2911c376f2ec",
        "parentId" : null,
        "authorId" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "body" : "Can you indicate this change into the PR's title and comment since this is a code change, not just test change?",
        "createdAt" : "2019-07-26T20:34:41Z",
        "updatedAt" : "2019-08-01T21:10:57Z",
        "lastEditedBy" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "tags" : [
        ]
      },
      {
        "id" : "9123df5b-a31c-46bc-a1de-2178ce59e46f",
        "parentId" : "14633b6a-b86f-4b7d-a330-2911c376f2ec",
        "authorId" : "9ce7bd1a-5286-4173-88a4-039146bf0d46",
        "body" : "@jingxu97 \r\n\r\nThank you for your review.\r\n\r\nI've changed the PR's title and comments and added comments in `MountedVolume` definition.\r\n(New code change is merged to \"Don't create mounter when reconstructing block volume\" commit.)\r\n\r\nPTAL \r\n",
        "createdAt" : "2019-07-30T19:22:02Z",
        "updatedAt" : "2019-08-01T21:10:57Z",
        "lastEditedBy" : "9ce7bd1a-5286-4173-88a4-039146bf0d46",
        "tags" : [
        ]
      }
    ],
    "commit" : "c130b77a4848b87b29a1b7dcc1cc8d83247e50e8",
    "line" : 29,
    "diffHunk" : "@@ -1,1 +500,504 @@\n\tvar volumeMapper volumepkg.BlockVolumeMapper\n\tvar volumeMounter volumepkg.Mounter\n\t// Path to the mount or block device to check\n\tvar checkPath string"
  },
  {
    "id" : "c3c4c3c0-c6ad-4cbc-870b-58589e44d73a",
    "prId" : 74653,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/74653#pullrequestreview-210390723",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "80e847f0-7254-4392-8eee-57f4979943df",
        "parentId" : null,
        "authorId" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "body" : "@jingxu97 can this check be removed?  This means that the directory still exists and should be cleaned up.\r\n\r\nAlso this assumes that all volumes use mounts, which is not necessarily true (esp for ephemeral types).",
        "createdAt" : "2019-02-28T02:10:54Z",
        "updatedAt" : "2019-02-28T02:10:54Z",
        "lastEditedBy" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "tags" : [
        ]
      },
      {
        "id" : "161794a1-47f0-4a1a-ae9d-85f508fe893f",
        "parentId" : "80e847f0-7254-4392-8eee-57f4979943df",
        "authorId" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "body" : "For reference, this is the PR that introduced this check.  Reading through the original bug and discussion, I'm not sure how this fix actually addresses the original issue... cc @chakri-nelluri \r\n\r\nhttps://github.com/kubernetes/kubernetes/pull/51985",
        "createdAt" : "2019-03-04T19:28:02Z",
        "updatedAt" : "2019-03-04T19:28:03Z",
        "lastEditedBy" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "tags" : [
        ]
      },
      {
        "id" : "480e5f49-e98c-4f84-a025-d25192a6bb9f",
        "parentId" : "80e847f0-7254-4392-8eee-57f4979943df",
        "authorId" : "cb578771-ab57-49a0-afd6-27da11c87c6d",
        "body" : "@msau42 PR #51985 adds an extra check to make sure that the volume is mounted on a reboot and return a failure for volume reconstruction, if it is not. Hope this clarifies the need for check.",
        "createdAt" : "2019-03-04T19:56:10Z",
        "updatedAt" : "2019-03-04T19:56:10Z",
        "lastEditedBy" : "cb578771-ab57-49a0-afd6-27da11c87c6d",
        "tags" : [
        ]
      },
      {
        "id" : "7968009d-c51f-42b3-9081-3cf4038bdb9d",
        "parentId" : "80e847f0-7254-4392-8eee-57f4979943df",
        "authorId" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "body" : "Ok @jingxu97 and I discussed and I understand now.\r\n\r\nIf the volume was partially torn down (ie the mount point is gone, but the directory still exists), then we don't want reconstruction to add the volume back to the ASW (because it's actually not mounted) and cause an empty directory to be mounted into the pod.  Let's update the comment here to make that reason more obvious.\r\n\r\nHowever, this brings up some other issues:\r\n* What happens if the volume plugin doesn't actually use mounts? Maybe this isn't an issue for attachable plugins. I can't think of a real attachable plugin that is not mount-based.\r\n* If there was a case of kubelet/node crash in the middle of cleanup, then we may not be able to properly cleanup the directories for CSI because we only try reconstruction once during kubelet initialization, when the CSI plugin may not be registered yet.  This is also more of a corner case and we don't need to consider fixing it urgently for now.\r\n\r\n\r\n\r\n",
        "createdAt" : "2019-03-04T19:58:40Z",
        "updatedAt" : "2019-03-04T19:58:40Z",
        "lastEditedBy" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "tags" : [
        ]
      },
      {
        "id" : "afe1edbe-669d-4756-b865-bcf6a41b9496",
        "parentId" : "80e847f0-7254-4392-8eee-57f4979943df",
        "authorId" : "cb578771-ab57-49a0-afd6-27da11c87c6d",
        "body" : "> @jingxu97 can this check be removed? This means that the directory still exists and should be cleaned up.\r\n> \r\n> Also this assumes that all volumes use mounts, which is not necessarily true (esp for ephemeral types).\r\n\r\n@msau42 This code is conditional and was only meant for plugins which support attach and needs to be reattached and mounted on a node reboot.",
        "createdAt" : "2019-03-04T19:58:55Z",
        "updatedAt" : "2019-03-04T19:58:55Z",
        "lastEditedBy" : "cb578771-ab57-49a0-afd6-27da11c87c6d",
        "tags" : [
        ]
      },
      {
        "id" : "284d7b52-8eea-4943-8400-7a4a589b0519",
        "parentId" : "80e847f0-7254-4392-8eee-57f4979943df",
        "authorId" : "cb578771-ab57-49a0-afd6-27da11c87c6d",
        "body" : "> * What happens if the volume plugin doesn't actually use mounts? Maybe this isn't an issue for attachable plugins. I can't think of a real attachable plugin that is not mount-based.\r\n\r\nBlock devices?",
        "createdAt" : "2019-03-04T21:03:50Z",
        "updatedAt" : "2019-03-04T21:03:50Z",
        "lastEditedBy" : "cb578771-ab57-49a0-afd6-27da11c87c6d",
        "tags" : [
        ]
      },
      {
        "id" : "3e3bdbc6-79c6-4f34-9fe2-ee1d01e1fd2f",
        "parentId" : "80e847f0-7254-4392-8eee-57f4979943df",
        "authorId" : "cb578771-ab57-49a0-afd6-27da11c87c6d",
        "body" : "> * If there was a case of kubelet/node crash in the middle of cleanup, then we may not be able to properly cleanup the directories for CSI because we only try reconstruction once during kubelet initialization, when the CSI plugin may not be registered yet.  This is also more of a corner case and we don't need to consider fixing it urgently for now.\r\n\r\n@msau42 This might show up if we restart Kubelet to recover for any other issues..",
        "createdAt" : "2019-03-04T21:04:42Z",
        "updatedAt" : "2019-03-04T21:04:42Z",
        "lastEditedBy" : "cb578771-ab57-49a0-afd6-27da11c87c6d",
        "tags" : [
        ]
      },
      {
        "id" : "6e29d7fe-b919-462c-9575-1653cf4b4a11",
        "parentId" : "80e847f0-7254-4392-8eee-57f4979943df",
        "authorId" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "body" : "This CheckVolumeExistance function does handle raw block, although I wonder if it possible to the link to change across reboots? I think this is what the losetup is supposed to protect against. cc @wongma7 ",
        "createdAt" : "2019-03-04T21:17:59Z",
        "updatedAt" : "2019-03-04T21:17:59Z",
        "lastEditedBy" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "tags" : [
        ]
      },
      {
        "id" : "5bc8f37f-6702-47a9-a98e-913ab5ddeaa2",
        "parentId" : "80e847f0-7254-4392-8eee-57f4979943df",
        "authorId" : "241ab19e-f85a-4d22-92e2-88f2b6287d14",
        "body" : "only kubelet manipulates these links, technically it can change but so can a mount device (we check that a mount point exists only, not if it points to the right thing). (losetup doesn't help here as the failure scenario the losetup code is intended to prevent is something different like: volume at /dev/sda somehow gets attached then another volume gets attached at /dev/sda, silently. The loop device holding onto /dev/sda is supposed to prevent detach from happening at all. If there's a reboot, I don't believe the loop devices persist anyhow.)\r\n\r\n\r\n",
        "createdAt" : "2019-03-04T21:56:53Z",
        "updatedAt" : "2019-03-04T21:56:54Z",
        "lastEditedBy" : "241ab19e-f85a-4d22-92e2-88f2b6287d14",
        "tags" : [
        ]
      },
      {
        "id" : "b5cb0129-5a8e-439b-8658-18af802aeb01",
        "parentId" : "80e847f0-7254-4392-8eee-57f4979943df",
        "authorId" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "body" : "We should test the reboot behavior for raw block separately to make sure we're not going to accidentally give the wrong device to container if the device names change on a reboot.",
        "createdAt" : "2019-03-04T22:01:22Z",
        "updatedAt" : "2019-03-04T22:01:22Z",
        "lastEditedBy" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "tags" : [
        ]
      }
    ],
    "commit" : "8940976602430f083f0c7dc00d7ed67a05c41d58",
    "line" : 43,
    "diffHunk" : "@@ -1,1 +513,517 @@\t\treturn nil, checkErr\n\t}\n\t// If mount or symlink doesn't exist, volume reconstruction should be failed\n\tif !isExist {\n\t\treturn nil, fmt.Errorf(\"Volume: %q is not mounted\", uniqueVolumeName)"
  },
  {
    "id" : "2cc93c66-c77a-4503-8f2d-3c4ffc9d849c",
    "prId" : 74653,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/74653#pullrequestreview-211627601",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1d400e08-5349-4be0-a7ff-214e2ce95d05",
        "parentId" : null,
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "Can you update comment.",
        "createdAt" : "2019-03-07T02:30:15Z",
        "updatedAt" : "2019-03-07T02:30:48Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      },
      {
        "id" : "788839dc-c6c8-4e05-a4d3-18b827c7fcc9",
        "parentId" : "1d400e08-5349-4be0-a7ff-214e2ce95d05",
        "authorId" : "e4e7c71f-23b5-4203-b65d-3f5f3c503b64",
        "body" : "This comment describes how `CheckVolumeExistenceOperation` works internally to check volume existence. It's correct.",
        "createdAt" : "2019-03-07T03:24:48Z",
        "updatedAt" : "2019-03-07T03:24:48Z",
        "lastEditedBy" : "e4e7c71f-23b5-4203-b65d-3f5f3c503b64",
        "tags" : [
        ]
      },
      {
        "id" : "006ea22f-9cfb-4186-b571-57877a40624b",
        "parentId" : "1d400e08-5349-4be0-a7ff-214e2ce95d05",
        "authorId" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "body" : "I think @saad-ali means to add a comment about the change? Instead of using volume.volumePath, we need to use volumeMounter.GetPath() because the mount point setup is different for different plugins. We have to be careful about this when adding/modifying code.",
        "createdAt" : "2019-03-07T07:08:22Z",
        "updatedAt" : "2019-03-07T07:08:22Z",
        "lastEditedBy" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "tags" : [
        ]
      },
      {
        "id" : "ec1f7887-243e-4d09-9880-33ad77165ccc",
        "parentId" : "1d400e08-5349-4be0-a7ff-214e2ce95d05",
        "authorId" : "e4e7c71f-23b5-4203-b65d-3f5f3c503b64",
        "body" : "oh, sorry, because it's already merged, we can add it later.",
        "createdAt" : "2019-03-07T07:15:09Z",
        "updatedAt" : "2019-03-07T07:15:10Z",
        "lastEditedBy" : "e4e7c71f-23b5-4203-b65d-3f5f3c503b64",
        "tags" : [
        ]
      }
    ],
    "commit" : "8940976602430f083f0c7dc00d7ed67a05c41d58",
    "line" : 38,
    "diffHunk" : "@@ -1,1 +508,512 @@\t}\n\n\t// Check existence of mount point for filesystem volume or symbolic link for block volume\n\tisExist, checkErr := rc.operationExecutor.CheckVolumeExistenceOperation(volumeSpec, volumeMounter.GetPath(), volumeSpec.Name(), rc.mounter, uniqueVolumeName, volume.podName, pod.UID, attachablePlugin)\n\tif checkErr != nil {"
  },
  {
    "id" : "deccbe34-d1c8-4ecb-894d-1efec9d2d98f",
    "prId" : 60888,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/60888#pullrequestreview-103966569",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c7be9961-d335-4583-b1df-60285684be98",
        "parentId" : null,
        "authorId" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "body" : "Should we move this part right after line 367? If desired state has the volume and the volume directory already exist, we can mark the ReportInUse in the desired state.\r\n\r\nIdeally, we can check node status to make sure the reportinuse field has the volume",
        "createdAt" : "2018-03-14T18:03:34Z",
        "updatedAt" : "2018-03-14T19:35:02Z",
        "lastEditedBy" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "tags" : [
        ]
      },
      {
        "id" : "d28e63c1-7f45-4fb5-92e6-4e52279ab762",
        "parentId" : "c7be9961-d335-4583-b1df-60285684be98",
        "authorId" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "body" : "I originally put it here because I did not want volumes that failed reconstruction to be reported. I'll move the check up as you suggest.",
        "createdAt" : "2018-03-14T19:26:59Z",
        "updatedAt" : "2018-03-14T19:35:02Z",
        "lastEditedBy" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "tags" : [
        ]
      }
    ],
    "commit" : "c51e843f3c800f610ed03bda484a592170133fb1",
    "line" : 30,
    "diffHunk" : "@@ -1,1 +380,384 @@\t\t\tcontinue\n\t\t}\n\t\tif volumeInDSW {\n\t\t\t// Some pod needs the volume. And it exists on disk. Some previous\n\t\t\t// kubelet must have created the directory, therefore it must have"
  },
  {
    "id" : "f7b68d07-1747-4350-ab83-5b0ecff6f399",
    "prId" : 58177,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/58177#pullrequestreview-90178824",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fa0d177e-b84d-48e1-b3c9-a13fc64a8811",
        "parentId" : null,
        "authorId" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "body" : "I might be missing something but the proposal says - \"f volume plugins cannot support reconstruction, reconciler clean up the mounts directly with a go routine (operation executor) to avoid delay. If it fails, reconciler will not retry.\" - but it appears that we are trying again here right?",
        "createdAt" : "2018-01-19T02:58:22Z",
        "updatedAt" : "2018-02-05T21:14:19Z",
        "lastEditedBy" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "tags" : [
        ]
      },
      {
        "id" : "6afc37b4-b6b8-4aa0-b209-61aa58da4ecf",
        "parentId" : "fa0d177e-b84d-48e1-b3c9-a13fc64a8811",
        "authorId" : "ea65316b-7fdf-4fe0-99b0-2d437bf2580e",
        "body" : "The call stack is `syncFunc` -> `sync` -> `syncStates` -> `cleanupMounts`, `sync` is invoked only once before the `reconcile` loop started.",
        "createdAt" : "2018-01-19T03:41:01Z",
        "updatedAt" : "2018-02-05T21:14:19Z",
        "lastEditedBy" : "ea65316b-7fdf-4fe0-99b0-2d437bf2580e",
        "tags" : [
        ]
      },
      {
        "id" : "98f05dea-101c-4140-bbda-0248fbe0bd4a",
        "parentId" : "fa0d177e-b84d-48e1-b3c9-a13fc64a8811",
        "authorId" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "body" : "ack. I missed `pollUntil`",
        "createdAt" : "2018-01-19T17:02:38Z",
        "updatedAt" : "2018-02-05T21:14:19Z",
        "lastEditedBy" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "tags" : [
        ]
      }
    ],
    "commit" : "9588d2098a64c579ed351ba946dc900db79700f7",
    "line" : 150,
    "diffHunk" : "@@ -1,1 +394,398 @@}\n\nfunc (rc *reconciler) cleanupMounts(volume podVolume) {\n\tglog.V(2).Infof(\"Reconciler sync states: could not find information (PID: %s) (Volume SpecName: %s) in desired state, clean up the mount points\",\n\t\tvolume.podName, volume.volumeSpecName)"
  },
  {
    "id" : "888c436e-a911-4c08-8558-d9b2032a50a3",
    "prId" : 58177,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/58177#pullrequestreview-90960936",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0e60a59c-e3a9-41b1-8e7d-71ba24c4d8e2",
        "parentId" : null,
        "authorId" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "body" : "We are not using this `reportednUse` variable are we?",
        "createdAt" : "2018-01-19T03:12:44Z",
        "updatedAt" : "2018-02-05T21:14:19Z",
        "lastEditedBy" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "tags" : [
        ]
      },
      {
        "id" : "6398a265-e15b-44b8-8e9b-227a167f5e77",
        "parentId" : "0e60a59c-e3a9-41b1-8e7d-71ba24c4d8e2",
        "authorId" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "body" : "We do. When reconciler at kubelet tries to VerifyControllerAttachedVolume, it checked whether volume is also reportedInUse in node status to make sure we only try to mount after volume is reported in use (this is checked by reconciler running on master during detach)",
        "createdAt" : "2018-01-23T19:58:20Z",
        "updatedAt" : "2018-02-05T21:14:19Z",
        "lastEditedBy" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "tags" : [
        ]
      }
    ],
    "commit" : "9588d2098a64c579ed351ba946dc900db79700f7",
    "line" : 57,
    "diffHunk" : "@@ -1,1 +344,348 @@\tvolumeGidValue      string\n\tdevicePath          string\n\treportedInUse       bool\n\tmounter             volumepkg.Mounter\n\tblockVolumeMapper   volumepkg.BlockVolumeMapper"
  },
  {
    "id" : "454ddf80-5948-4e44-94b5-05d0b654ebb4",
    "prId" : 58177,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/58177#pullrequestreview-90970465",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0b05b1eb-72dd-4e00-8dc9-4b4af93b1bd9",
        "parentId" : null,
        "authorId" : "967a712d-9784-41d4-920d-42eaba99fb24",
        "body" : "@jingxu97 \r\n\r\nGenerateUnmapVolumeFunc() depends on volumeSpec to get global map path using GetGlobalMapPath()\r\nDo you plan to change implementation of GetGlobalMapPath() in operation_generator and plugins too?\r\nOtherwise, unmap volume hit panic with null volume spec reference in plugin.",
        "createdAt" : "2018-01-22T20:55:38Z",
        "updatedAt" : "2018-02-05T21:14:19Z",
        "lastEditedBy" : "967a712d-9784-41d4-920d-42eaba99fb24",
        "tags" : [
        ]
      },
      {
        "id" : "dbd913a5-b671-4636-8bf0-f33ec0cc02e7",
        "parentId" : "0b05b1eb-72dd-4e00-8dc9-4b4af93b1bd9",
        "authorId" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "body" : "Thanks for pointing this out. I added the globalMountPath in the MountedVolume data structure so it can directly get the path instead of constructing from VolumeSpec.",
        "createdAt" : "2018-01-23T19:50:25Z",
        "updatedAt" : "2018-02-05T21:14:19Z",
        "lastEditedBy" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "tags" : [
        ]
      },
      {
        "id" : "0520caf4-ac29-4607-840b-a824d2bdedec",
        "parentId" : "0b05b1eb-72dd-4e00-8dc9-4b4af93b1bd9",
        "authorId" : "967a712d-9784-41d4-920d-42eaba99fb24",
        "body" : "I see. In that case, we don't need to change plugins.",
        "createdAt" : "2018-01-23T20:30:56Z",
        "updatedAt" : "2018-02-05T21:14:19Z",
        "lastEditedBy" : "967a712d-9784-41d4-920d-42eaba99fb24",
        "tags" : [
        ]
      }
    ],
    "commit" : "9588d2098a64c579ed351ba946dc900db79700f7",
    "line" : 167,
    "diffHunk" : "@@ -1,1 +411,415 @@\t// TODO: Currently cleanupMounts only includes UnmountVolume operation. In the next PR, we will add\n\t// to unmount both volume and device in the same routine.\n\terr = volumeHandler.UnmountVolumeHandler(mountedVolume, rc.actualStateOfWorld)\n\tif err != nil {\n\t\tglog.Errorf(mountedVolume.GenerateErrorDetailed(fmt.Sprintf(\"volumeHandler.UnmountVolumeHandler for UnmountVolume failed\"), err).Error())"
  },
  {
    "id" : "bf7babdd-73ab-44af-a9e0-631fda921ee7",
    "prId" : 58177,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/58177#pullrequestreview-92425342",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "07344556-0eb4-49a0-a4ee-ec1f8a992645",
        "parentId" : null,
        "authorId" : "ea65316b-7fdf-4fe0-99b0-2d437bf2580e",
        "body" : "For some local volumes `node.Status.VolumesAttached.DevicePath` maybe empty, we should check this scenario and fetch the real device path from global mount path if it is empty.",
        "createdAt" : "2018-01-27T08:46:39Z",
        "updatedAt" : "2018-02-05T21:14:19Z",
        "lastEditedBy" : "ea65316b-7fdf-4fe0-99b0-2d437bf2580e",
        "tags" : [
        ]
      },
      {
        "id" : "5f098c30-1d55-4a96-a143-366c7e50631f",
        "parentId" : "07344556-0eb4-49a0-a4ee-ec1f8a992645",
        "authorId" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "body" : "In the proposal, I plan to change all local volumes (iscsi etc) fail to reconstruct volume spec. For the plugins that can be reconstructed, read device path from node status should be fine. \r\n\r\nAnother approach is that instead of reading from node status, we can get device path from mount references directly. I might use this approach in the following PR. ",
        "createdAt" : "2018-01-29T18:50:12Z",
        "updatedAt" : "2018-02-05T21:14:19Z",
        "lastEditedBy" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "tags" : [
        ]
      },
      {
        "id" : "2ec9c1a0-f0f3-4b0a-a5fa-86a83a50d8d9",
        "parentId" : "07344556-0eb4-49a0-a4ee-ec1f8a992645",
        "authorId" : "ea65316b-7fdf-4fe0-99b0-2d437bf2580e",
        "body" : "ACK",
        "createdAt" : "2018-01-30T02:22:18Z",
        "updatedAt" : "2018-02-05T21:14:19Z",
        "lastEditedBy" : "ea65316b-7fdf-4fe0-99b0-2d437bf2580e",
        "tags" : [
        ]
      }
    ],
    "commit" : "9588d2098a64c579ed351ba946dc900db79700f7",
    "line" : 254,
    "diffHunk" : "@@ -1,1 +532,536 @@\n// updateDevicePath gets the node status to retrieve volume device path information.\nfunc (rc *reconciler) updateDevicePath(volumesNeedUpdate map[v1.UniqueVolumeName]*reconstructedVolume) {\n\tnode, fetchErr := rc.kubeClient.CoreV1().Nodes().Get(string(rc.nodeName), metav1.GetOptions{})\n\tif fetchErr != nil {"
  },
  {
    "id" : "1fefc91c-913c-4354-b06c-d044bc252bc4",
    "prId" : 58177,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/58177#pullrequestreview-94117674",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "92e33020-c9fb-4cbf-b655-f94fc12afcbf",
        "parentId" : null,
        "authorId" : "967a712d-9784-41d4-920d-42eaba99fb24",
        "body" : "@jingxu97 \r\nCurrently blockVolumeMapper is only nil if plugin doesn't support Block volume.\r\nIf a volume plugin supports `block volume` and the volumeMode is `filesystem`, blockVolumeMapper is initialized during reconstructVolume(), so the volume.blockVolumeMapper isn't nil.\r\nAs a result, deviceMountPath return wrong information for `Filesystem` volumeMode case.\r\n\r\nWe have two choices here.\r\n- reconstructVolume() doesn't initialize blockVolumeMapper if volumeMode is `Filesystem`.\r\n- Check volumeMode when getDeviceMountPath() obtains deviceMountPath.\r\n\r\nI suppose either way would work. Any thought?\r\n\r\n",
        "createdAt" : "2018-02-05T16:59:18Z",
        "updatedAt" : "2018-02-05T21:14:19Z",
        "lastEditedBy" : "967a712d-9784-41d4-920d-42eaba99fb24",
        "tags" : [
        ]
      },
      {
        "id" : "5e73fb22-18ef-4cb2-ae44-0e555b312be9",
        "parentId" : "92e33020-c9fb-4cbf-b655-f94fc12afcbf",
        "authorId" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "body" : "I think the first option is good for me. Update the code to fix the issue now. Thanks!",
        "createdAt" : "2018-02-05T19:43:34Z",
        "updatedAt" : "2018-02-05T21:14:19Z",
        "lastEditedBy" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "tags" : [
        ]
      }
    ],
    "commit" : "9588d2098a64c579ed351ba946dc900db79700f7",
    "line" : 283,
    "diffHunk" : "@@ -1,1 +558,562 @@\t}\n\n\tif volume.blockVolumeMapper != nil {\n\t\tdeviceMountPath, err =\n\t\t\tvolume.blockVolumeMapper.GetGlobalMapPath(volume.volumeSpec)"
  },
  {
    "id" : "7800bd4f-552b-4e40-b1f1-63e9019579ac",
    "prId" : 51985,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/51985#pullrequestreview-63730864",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "025f4ccc-7627-4a83-8a51-61d9252948b8",
        "parentId" : null,
        "authorId" : "9f5e3cfe-0c8a-43e2-8374-3cbe3b3568ab",
        "body" : "@msau42 @jingxu97 @jsafrane - do we need to use IsNotMountPoint here instead of IsLikelyNotMountPoint to avoid issues in the reconciler with respect to local volumes? For reference... https://github.com/kubernetes/kubernetes/pull/48402",
        "createdAt" : "2017-09-19T02:26:38Z",
        "updatedAt" : "2017-09-19T02:26:56Z",
        "lastEditedBy" : "9f5e3cfe-0c8a-43e2-8374-3cbe3b3568ab",
        "tags" : [
        ]
      },
      {
        "id" : "8fb505f7-31f6-473c-8be5-3ab9a0557428",
        "parentId" : "025f4ccc-7627-4a83-8a51-61d9252948b8",
        "authorId" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "body" : "@ianchakeres thanks for bring this up. I think we do need to consider this . But since IsNotMountPoint will list all the mounts, to reduce the overhead, maybe we can cache the mounts?",
        "createdAt" : "2017-09-19T05:55:06Z",
        "updatedAt" : "2017-09-19T05:55:06Z",
        "lastEditedBy" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "tags" : [
        ]
      },
      {
        "id" : "d25b09b6-5039-46bc-a557-ab0af3b582e0",
        "parentId" : "025f4ccc-7627-4a83-8a51-61d9252948b8",
        "authorId" : "cb578771-ab57-49a0-afd6-27da11c87c6d",
        "body" : "@jingxu97 This particular check is for only attachable volumes and isLikelyNotMountPoint should work for attachable volumes. Do we still need it?",
        "createdAt" : "2017-09-19T14:11:52Z",
        "updatedAt" : "2017-09-19T14:11:52Z",
        "lastEditedBy" : "cb578771-ab57-49a0-afd6-27da11c87c6d",
        "tags" : [
        ]
      },
      {
        "id" : "7206d53c-fdaa-426f-ac81-25dee9d2f5ca",
        "parentId" : "025f4ccc-7627-4a83-8a51-61d9252948b8",
        "authorId" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "body" : "@chakri-nelluri  I first thought we should check the mount path for both attachable and non-attachable plugins. But in the current code workflow, if volume is not attachable, we only reconstruct if the the volume is not in desired state. So the reconstructed state will only be used by teardown operation (umount). So it is ok to not check the mount path exist or not. \r\nI am ok with this part of code. Thanks!",
        "createdAt" : "2017-09-19T16:58:33Z",
        "updatedAt" : "2017-09-19T16:58:33Z",
        "lastEditedBy" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "tags" : [
        ]
      }
    ],
    "commit" : "b8d1c3bcd878e62fb468a6b8df55454bd8264d00",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +450,454 @@\n\tif attachablePlugin != nil {\n\t\tif isNotMount, mountCheckErr := rc.mounter.IsLikelyNotMountPoint(volume.mountPath); mountCheckErr != nil {\n\t\t\treturn nil, fmt.Errorf(\"Could not check whether the volume %q (spec.Name: %q) pod %q (UID: %q) is mounted with: %v\",\n\t\t\t\tuniqueVolumeName,"
  },
  {
    "id" : "69b886aa-3d9f-44da-9b66-3bb4305a627a",
    "prId" : 51494,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/51494#pullrequestreview-59862942",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "37b272cb-e700-476b-9bbb-c7cd7daf7e66",
        "parentId" : null,
        "authorId" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "body" : "who fills `attachedVolume.GloballyMounted` for block devices? IMO it's filled at the end of `attacher.MountDevice`, but that applies only to filesystem volumes, right?",
        "createdAt" : "2017-08-31T13:09:47Z",
        "updatedAt" : "2017-11-20T19:12:48Z",
        "lastEditedBy" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "tags" : [
        ]
      },
      {
        "id" : "a615cd43-4e46-423a-9c97-dc9d7248b193",
        "parentId" : "37b272cb-e700-476b-9bbb-c7cd7daf7e66",
        "authorId" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "body" : "found it, `GenerateMapVolumeFunc`",
        "createdAt" : "2017-08-31T13:40:20Z",
        "updatedAt" : "2017-11-20T19:12:48Z",
        "lastEditedBy" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "tags" : [
        ]
      },
      {
        "id" : "fb4ddaf4-81e7-4670-850a-fcab3c628623",
        "parentId" : "37b272cb-e700-476b-9bbb-c7cd7daf7e66",
        "authorId" : "967a712d-9784-41d4-920d-42eaba99fb24",
        "body" : "The attachedVolume.GloballyMounted is set via MarkDeviceAsMounted().\r\nFor filesystem volume case, MarkDeviceAsMounted() is called in the GenerateMountVolumeFunc().\r\nAnd for Block volume case,  MarkDeviceAsMounted() is called in the GenerateMapVolumeFunc().\r\n\r\n```\r\n- GenerateMountVolumeFunc()\r\n    -> volumeAttacher.MountDevice()\r\n    -> MarkDeviceAsMounted()\r\n\r\n- GenerateMapVolumeFunc()\r\n     -> mapDevice()\r\n     -> MarkDeviceAsMounted()\r\n```",
        "createdAt" : "2017-08-31T13:47:18Z",
        "updatedAt" : "2017-11-20T19:12:48Z",
        "lastEditedBy" : "967a712d-9784-41d4-920d-42eaba99fb24",
        "tags" : [
        ]
      }
    ],
    "commit" : "9329dd5b91a099888f0cfb2aeeb79659a093f6ed",
    "line" : 64,
    "diffHunk" : "@@ -1,1 +273,277 @@\t\tif !rc.desiredStateOfWorld.VolumeExists(attachedVolume.VolumeName) &&\n\t\t\t!rc.operationExecutor.IsOperationPending(attachedVolume.VolumeName, nestedpendingoperations.EmptyUniquePodName) {\n\t\t\tif attachedVolume.GloballyMounted {\n\t\t\t\tvolumeHandler, err := operationexecutor.NewVolumeHandler(attachedVolume.VolumeSpec, rc.operationExecutor)\n\t\t\t\tif err != nil {"
  },
  {
    "id" : "53d31323-a294-4d99-8321-f0ce9b8fe0a3",
    "prId" : 51494,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/51494#pullrequestreview-78222221",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "17d65df0-1b77-4287-9405-6a1da02d2fa5",
        "parentId" : null,
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "I don't understand this pattern. Why is a a `NewVolumeHandler` constructed before each usage?",
        "createdAt" : "2017-11-21T08:03:13Z",
        "updatedAt" : "2017-11-21T08:09:29Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      },
      {
        "id" : "cd8ab1ba-58f5-48d7-a10d-7e66736ee4a2",
        "parentId" : "17d65df0-1b77-4287-9405-6a1da02d2fa5",
        "authorId" : "967a712d-9784-41d4-920d-42eaba99fb24",
        "body" : "`NewVolumeHandler` chooses a handler for filesystem or block volume based on `volumeMode` in mountedVolume.VolumeSpec. Since the volumeMode differs on each volume, we need to choose proper handler for a volume before each unmount volume operation.",
        "createdAt" : "2017-11-21T15:16:00Z",
        "updatedAt" : "2017-11-21T15:16:00Z",
        "lastEditedBy" : "967a712d-9784-41d4-920d-42eaba99fb24",
        "tags" : [
        ]
      },
      {
        "id" : "a2027c5d-b2ba-4798-8b51-c61e2b799fcc",
        "parentId" : "17d65df0-1b77-4287-9405-6a1da02d2fa5",
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "`VolumeHandler` does not need to be a separate object that is constructed inline like this. You can create a new operation, e.g. `UnmountOperation` to which you pass the spec, and it can return either a `UnmountVolume` or `UnmapVolume`.",
        "createdAt" : "2017-11-21T18:58:19Z",
        "updatedAt" : "2017-11-21T23:09:28Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      }
    ],
    "commit" : "9329dd5b91a099888f0cfb2aeeb79659a093f6ed",
    "line" : 33,
    "diffHunk" : "@@ -1,1 +175,179 @@\tfor _, mountedVolume := range rc.actualStateOfWorld.GetMountedVolumes() {\n\t\tif !rc.desiredStateOfWorld.PodExistsInVolume(mountedVolume.PodName, mountedVolume.VolumeName) {\n\t\t\tvolumeHandler, err := operationexecutor.NewVolumeHandler(mountedVolume.VolumeSpec, rc.operationExecutor)\n\t\t\tif err != nil {\n\t\t\t\tglog.Errorf(mountedVolume.GenerateErrorDetailed(fmt.Sprintf(\"operationExecutor.NewVolumeHandler for UnmountVolume failed\"), err).Error())"
  },
  {
    "id" : "4776d530-0cc5-4d53-871d-b2cf2dec3ab5",
    "prId" : 44781,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/44781#pullrequestreview-34427848",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9954951a-cc22-4656-ab80-8d11bac990cf",
        "parentId" : null,
        "authorId" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "body" : "remove the extra empty space?",
        "createdAt" : "2017-04-24T21:32:40Z",
        "updatedAt" : "2017-05-09T22:30:32Z",
        "lastEditedBy" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "tags" : [
        ]
      },
      {
        "id" : "88a9916e-27b4-4942-a3c9-28a6e33c2da6",
        "parentId" : "9954951a-cc22-4656-ab80-8d11bac990cf",
        "authorId" : "241ab19e-f85a-4d22-92e2-88f2b6287d14",
        "body" : "I'm copying the other multi-line parameter comments which are indented by 2 spaces if you mean the spaces at the beginning",
        "createdAt" : "2017-04-24T21:54:49Z",
        "updatedAt" : "2017-05-09T22:30:32Z",
        "lastEditedBy" : "241ab19e-f85a-4d22-92e2-88f2b6287d14",
        "tags" : [
        ]
      }
    ],
    "commit" : "bbe82a26888431b49ff79ec961c17f87f950f282",
    "line" : 22,
    "diffHunk" : "@@ -1,1 +81,85 @@// actualStateOfWorld - cache containing the actual state of the world\n// populatorHasAddedPods - checker for whether the populator has finished\n//   adding pods to the desiredStateOfWorld cache at least once after sources\n//   are all ready (before sources are ready, pods are probably missing)\n// operationExecutor - used to trigger attach/detach/mount/unmount operations"
  },
  {
    "id" : "05e9f52f-4f4c-40d1-bab3-4d6039e383e9",
    "prId" : 44781,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/44781#pullrequestreview-34434784",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d72bc228-3e1f-4a0c-9a1d-170674e7858c",
        "parentId" : null,
        "authorId" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "body" : "just want to double check what is the benefit of using a function instead of passing the pointer to desiredStatePopulator?",
        "createdAt" : "2017-04-24T21:34:16Z",
        "updatedAt" : "2017-05-09T22:30:32Z",
        "lastEditedBy" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "tags" : [
        ]
      },
      {
        "id" : "47beb17a-98e3-4d47-a737-683ac050bed8",
        "parentId" : "d72bc228-3e1f-4a0c-9a1d-170674e7858c",
        "authorId" : "241ab19e-f85a-4d22-92e2-88f2b6287d14",
        "body" : "Imo it's cleaner to expose it via the interface.\r\n\r\nAnd actually this made me think, the bool is not threadsafe, we could read and write to the bool at the same time? I need to add a lock I think",
        "createdAt" : "2017-04-24T21:48:29Z",
        "updatedAt" : "2017-05-09T22:30:32Z",
        "lastEditedBy" : "241ab19e-f85a-4d22-92e2-88f2b6287d14",
        "tags" : [
        ]
      },
      {
        "id" : "c4a09d8e-fc6c-47c7-bc54-63eef1ff617c",
        "parentId" : "d72bc228-3e1f-4a0c-9a1d-170674e7858c",
        "authorId" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "body" : "I don't think we need lock before reading/writing that variable. afaict - it is not being called concurrently by any other goroutine. \r\n\r\nThe volume manager calls `dswp.Run` and that in turn loops the function infinitely between the sleep durations. I don't see any concurrent execution of `dswp.Run` ..\r\n",
        "createdAt" : "2017-04-24T22:19:34Z",
        "updatedAt" : "2017-05-09T22:30:32Z",
        "lastEditedBy" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "tags" : [
        ]
      },
      {
        "id" : "1995ddda-b4c8-4e36-bef0-239cfc9c03d6",
        "parentId" : "d72bc228-3e1f-4a0c-9a1d-170674e7858c",
        "authorId" : "241ab19e-f85a-4d22-92e2-88f2b6287d14",
        "body" : "OK, I added a lock which justifies using a function. It's quite ugly to have to lock, unlock, set and check it forever, when we only need to do it once but yeah, this should prevent any concurrency problem between populator & reconciler at startup",
        "createdAt" : "2017-04-24T22:21:00Z",
        "updatedAt" : "2017-05-09T22:30:32Z",
        "lastEditedBy" : "241ab19e-f85a-4d22-92e2-88f2b6287d14",
        "tags" : [
        ]
      },
      {
        "id" : "4a53668b-1e97-4123-876a-d976685c371d",
        "parentId" : "d72bc228-3e1f-4a0c-9a1d-170674e7858c",
        "authorId" : "241ab19e-f85a-4d22-92e2-88f2b6287d14",
        "body" : "@gnufied I highly highly doubt it is ever going to happen ,but I don't think it's impossible for dswp.Run's write and reconciler.Run's read to coincide. :/ You're right it would have to happen the first time at startup, after that there's no chance of concurrent read/write.",
        "createdAt" : "2017-04-24T22:23:22Z",
        "updatedAt" : "2017-05-09T22:30:32Z",
        "lastEditedBy" : "241ab19e-f85a-4d22-92e2-88f2b6287d14",
        "tags" : [
        ]
      },
      {
        "id" : "3969224c-bbb0-4d9d-a8d4-070ed14501f9",
        "parentId" : "d72bc228-3e1f-4a0c-9a1d-170674e7858c",
        "authorId" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "body" : "Ah, I missed that reconciler is reading the value. In that case yeah, we perhaps do need the lock. ",
        "createdAt" : "2017-04-24T22:36:45Z",
        "updatedAt" : "2017-05-09T22:30:32Z",
        "lastEditedBy" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "tags" : [
        ]
      }
    ],
    "commit" : "bbe82a26888431b49ff79ec961c17f87f950f282",
    "line" : 31,
    "diffHunk" : "@@ -1,1 +97,101 @@\tdesiredStateOfWorld cache.DesiredStateOfWorld,\n\tactualStateOfWorld cache.ActualStateOfWorld,\n\tpopulatorHasAddedPods func() bool,\n\toperationExecutor operationexecutor.OperationExecutor,\n\tmounter mount.Interface,"
  },
  {
    "id" : "772ddded-07cb-4114-91f8-d9f36f3c90f5",
    "prId" : 36616,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/36616#pullrequestreview-8246633",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "40c7849d-693b-4253-9ae3-b9585d91c185",
        "parentId" : null,
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "`uniqueVolumeName` remains uninitialized if `if attachablePlugin == nil`?\n",
        "createdAt" : "2016-11-11T01:31:19Z",
        "updatedAt" : "2016-11-11T02:06:18Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      },
      {
        "id" : "10aa9466-e3fe-4d16-a2a2-2b70a4437042",
        "parentId" : "40c7849d-693b-4253-9ae3-b9585d91c185",
        "authorId" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "body" : "There is an else to set the volume name\n\n} else {\n        uniqueVolumeName = volumehelper.GetUniqueVolumeNameForNonAttachableVolume(volume.podName, plugin, volumeSpec)               uniqueVolumeName = volumehelper.GetUniqueVolumeNameForNonAttachableVolume(volume.podName, plugin, volumeSpec)\n    }           }\n",
        "createdAt" : "2016-11-11T06:34:54Z",
        "updatedAt" : "2016-11-11T06:34:54Z",
        "lastEditedBy" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "tags" : [
        ]
      },
      {
        "id" : "ef8f7821-71f0-4eb7-b554-f27f57d63446",
        "parentId" : "40c7849d-693b-4253-9ae3-b9585d91c185",
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "Ah, github hid it below the fold.\n",
        "createdAt" : "2016-11-11T18:53:43Z",
        "updatedAt" : "2016-11-11T18:53:43Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      }
    ],
    "commit" : "c1248302786025cbc7ff5d301f4291087a9887e8",
    "line" : 39,
    "diffHunk" : "@@ -1,1 +530,534 @@\n\treconstructedVolume := &reconstructedVolume{\n\t\tvolumeName: uniqueVolumeName,\n\t\tpodName:    volume.podName,\n\t\tvolumeSpec: volumeSpec,"
  },
  {
    "id" : "0284f6ba-bf05-4f61-aceb-5252bf61a03d",
    "prId" : 33616,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/33616#pullrequestreview-3030116",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1d4cbba0-ea23-4e46-b9a9-30f6cb1d8f6b",
        "parentId" : null,
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "Why is this necessary?\n",
        "createdAt" : "2016-10-05T00:21:31Z",
        "updatedAt" : "2016-10-25T19:29:27Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      },
      {
        "id" : "3c376141-cda8-41dd-804f-88e6fdaedbc5",
        "parentId" : "1d4cbba0-ea23-4e46-b9a9-30f6cb1d8f6b",
        "authorId" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "body" : "I think since we can get this information out of node state, then just put it. Otherwise devicePath will be empty and DeviceOpened will not work. \n",
        "createdAt" : "2016-10-06T00:35:06Z",
        "updatedAt" : "2016-10-25T19:29:27Z",
        "lastEditedBy" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "tags" : [
        ]
      }
    ],
    "commit" : "b02481708a369f2f5bc49f59fb71ee8d5a0c8c12",
    "line" : null,
    "diffHunk" : "@@ -1,1 +542,546 @@\nfunc (rc *reconciler) updateStates(volumesNeedUpdate map[api.UniqueVolumeName]*reconstructedVolume) error {\n\t// Get the node status to retrieve volume device path information.\n\tnode, fetchErr := rc.kubeClient.Core().Nodes().Get(string(rc.nodeName))\n\tif fetchErr != nil {"
  },
  {
    "id" : "91325992-ec89-4ea2-a687-ae7f295bf726",
    "prId" : 33616,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/33616#pullrequestreview-5540276",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9d6c4173-48f7-44e1-8288-852f86dce7ec",
        "parentId" : null,
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "You said that this is necessary because:\n\n> The reason I put this check is because, without this check when kubelet restarts, the following events might happen\n> 1. pod manager gets existing pods and add volume info into desired state\n> 2. syncStates process scans existing directory, it checks the volume is already in desired state, skip it \n> 3. After the first SyncState finishes, kubelet node status updater will update the list of mounted volumes and the skipped volume from step 2 will not in the list\n\nHowever, `GetVolumesInUse()` reports _both_ volumes in desired state and actual state, and since this volume would be in desired state, it should still be reported.\n",
        "createdAt" : "2016-10-20T04:34:40Z",
        "updatedAt" : "2016-10-25T19:29:27Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      },
      {
        "id" : "cc82ed9e-c082-4672-8156-ab9836f5fb45",
        "parentId" : "9d6c4173-48f7-44e1-8288-852f86dce7ec",
        "authorId" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "body" : "The logic here is only if actual state already has the volume, it skip. Otherwise, no matter desired state has it or not, it will add the scanned volume to actual/desired state. So I am not quite sure about your question\n",
        "createdAt" : "2016-10-21T22:37:12Z",
        "updatedAt" : "2016-10-25T19:29:27Z",
        "lastEditedBy" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "tags" : [
        ]
      },
      {
        "id" : "024daeac-7a84-4afb-b65c-5ae60ddf15a3",
        "parentId" : "9d6c4173-48f7-44e1-8288-852f86dce7ec",
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "Spoke offline. This makes sense. Let's add this comment, for clarification:\n\n``` GO\n// This is to prevent node status from being updated to empty for attachable\n// volumes in the case that a volume is discovered on disk, not in the AWS, is\n// part of DSW, but is then quickly deleted from the DSW. This may happen on\n// kubelet restart when a pod is evicted quickly after start (it is discovered\n// running on the machine, added to the pod manager, and then killed because\n// it was deleted on the API server.\n```\n",
        "createdAt" : "2016-10-24T19:41:28Z",
        "updatedAt" : "2016-10-25T19:29:27Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      },
      {
        "id" : "b242916f-3417-4e7d-b90f-8d2277a9d312",
        "parentId" : "9d6c4173-48f7-44e1-8288-852f86dce7ec",
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "Also double check if `pending` operations possible. If so, we should skip.\n",
        "createdAt" : "2016-10-24T19:41:55Z",
        "updatedAt" : "2016-10-25T19:29:27Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      },
      {
        "id" : "4061c500-7557-4e5e-af4d-38ca407c85be",
        "parentId" : "9d6c4173-48f7-44e1-8288-852f86dce7ec",
        "authorId" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "body" : "No mount pending operations for attachable volume during the first time syncing states. The reason is that at this moment, StatesHasBeenSynced will return false, and then node status updater will not update mounted volume list, so mount operation could not be issued because VerifyControllerAttachedVolume will fail the the check volumeToMount.ReportedInUse.\n",
        "createdAt" : "2016-10-24T21:11:01Z",
        "updatedAt" : "2016-10-25T19:29:27Z",
        "lastEditedBy" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "tags" : [
        ]
      }
    ],
    "commit" : "b02481708a369f2f5bc49f59fb71ee8d5a0c8c12",
    "line" : null,
    "diffHunk" : "@@ -1,1 +458,462 @@\t\t\t// not get this volume from either actual or desired state. In turn, this might cause master controller\n\t\t\t// detaching while the volume is still mounted.\n\t\t\tif aswExist || !reconstructedVolume.pluginIsAttachable {\n\t\t\t\tcontinue\n\t\t\t}"
  },
  {
    "id" : "4228e3ab-72ff-4408-9dd3-a70f2157afb1",
    "prId" : 28714,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e1cdb3df-8322-44b0-ba22-3822849e5561",
        "parentId" : null,
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "nit: update comment\n",
        "createdAt" : "2016-07-14T06:10:11Z",
        "updatedAt" : "2016-07-18T23:20:15Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      }
    ],
    "commit" : "e13c678e3b04becd6131442e069f1d910241992d",
    "line" : 22,
    "diffHunk" : "@@ -1,1 +74,78 @@\tactualStateOfWorld cache.ActualStateOfWorld,\n\toperationExecutor operationexecutor.OperationExecutor,\n\tmounter mount.Interface) Reconciler {\n\treturn &reconciler{\n\t\tkubeClient:                    kubeClient,"
  },
  {
    "id" : "213c4f11-d347-42e6-b3a7-d725fc1e012b",
    "prId" : 27970,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0e180fa2-dcb4-4371-9b1a-a34711d61602",
        "parentId" : null,
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "Please add `reconstructDuration` new parameter to comment explaining what it is.\n",
        "createdAt" : "2016-08-05T21:14:30Z",
        "updatedAt" : "2016-08-15T18:29:44Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      },
      {
        "id" : "b2737702-6c0f-478b-ad01-15d6a8b89998",
        "parentId" : "0e180fa2-dcb4-4371-9b1a-a34711d61602",
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "Remainder to update comments on this method.\n",
        "createdAt" : "2016-08-10T03:42:48Z",
        "updatedAt" : "2016-08-15T18:29:44Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      },
      {
        "id" : "ea55c8a6-1430-459d-ba44-5aef2811ecb9",
        "parentId" : "0e180fa2-dcb4-4371-9b1a-a34711d61602",
        "authorId" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "body" : "done\n",
        "createdAt" : "2016-08-12T16:24:01Z",
        "updatedAt" : "2016-08-15T18:29:44Z",
        "lastEditedBy" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "tags" : [
        ]
      }
    ],
    "commit" : "f19a1148db1b7584be6b6b60abaf8c0bd1503ed3",
    "line" : 52,
    "diffHunk" : "@@ -1,1 +81,85 @@// volumePluginMrg - volume plugin manager passed from kubelet\nfunc NewReconciler(\n\tkubeClient internalclientset.Interface,\n\tcontrollerAttachDetachEnabled bool,\n\tloopSleepDuration time.Duration,"
  },
  {
    "id" : "486b0935-34c1-41e9-8eae-9d6e30a84d5d",
    "prId" : 27970,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1ca68c0b-bc81-4be1-99d6-08099e6a629a",
        "parentId" : null,
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "Maybe call this first with a defer so that it is set even if reconstructFromDisk fails with panic\n",
        "createdAt" : "2016-08-05T21:20:26Z",
        "updatedAt" : "2016-08-15T18:29:44Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      },
      {
        "id" : "60845819-fdc8-4e21-9f83-d449ebfc2791",
        "parentId" : "1ca68c0b-bc81-4be1-99d6-08099e6a629a",
        "authorId" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "body" : "done\n",
        "createdAt" : "2016-08-09T18:43:45Z",
        "updatedAt" : "2016-08-15T18:29:44Z",
        "lastEditedBy" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "tags" : [
        ]
      }
    ],
    "commit" : "f19a1148db1b7584be6b6b60abaf8c0bd1503ed3",
    "line" : null,
    "diffHunk" : "@@ -1,1 +377,381 @@\nfunc (rc *reconciler) updateReconstructTime() {\n\trc.timeOfLastReconstruct = time.Now()\n}\n"
  },
  {
    "id" : "853590c1-eb10-4bda-a312-bb33d3d24af9",
    "prId" : 27970,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "59e86098-99d0-4dc8-8513-bfbda82dc49d",
        "parentId" : null,
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "Update comments with new parameter\n",
        "createdAt" : "2016-08-10T03:19:42Z",
        "updatedAt" : "2016-08-15T18:29:44Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      },
      {
        "id" : "10583178-70d1-4f5a-8621-7e131989dddd",
        "parentId" : "59e86098-99d0-4dc8-8513-bfbda82dc49d",
        "authorId" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "body" : "done\n",
        "createdAt" : "2016-08-11T00:52:01Z",
        "updatedAt" : "2016-08-15T18:29:44Z",
        "lastEditedBy" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "tags" : [
        ]
      }
    ],
    "commit" : "f19a1148db1b7584be6b6b60abaf8c0bd1503ed3",
    "line" : null,
    "diffHunk" : "@@ -1,1 +91,95 @@\toperationExecutor operationexecutor.OperationExecutor,\n\tmounter mount.Interface,\n\tvolumePluginMgr *volume.VolumePluginMgr,\n\tkubeletPodsDir string) Reconciler {\n\treturn &reconciler{"
  },
  {
    "id" : "41c2d8fa-6fa4-4eca-87ad-ce877ac8e08d",
    "prId" : 27970,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "20dbac46-590b-4425-b8c5-f76e62511c23",
        "parentId" : null,
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "nit: Spell check comments. \n",
        "createdAt" : "2016-08-10T03:22:43Z",
        "updatedAt" : "2016-08-15T18:29:44Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      },
      {
        "id" : "d537c66c-70de-49b5-9fff-cf0592721d58",
        "parentId" : "20dbac46-590b-4425-b8c5-f76e62511c23",
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "Do this for all comments, please.\n",
        "createdAt" : "2016-08-10T03:25:44Z",
        "updatedAt" : "2016-08-15T18:29:44Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      },
      {
        "id" : "f4ef3ff6-a82c-403f-a3b3-f7c11e3f4a8f",
        "parentId" : "20dbac46-590b-4425-b8c5-f76e62511c23",
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "Ping on this. e.g. `reconstruc` -> `reconstruct`\n",
        "createdAt" : "2016-08-12T03:28:23Z",
        "updatedAt" : "2016-08-15T18:29:44Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      }
    ],
    "commit" : "f19a1148db1b7584be6b6b60abaf8c0bd1503ed3",
    "line" : null,
    "diffHunk" : "@@ -1,1 +371,375 @@// the volumes and udpate the actual and desired states. In the following reconciler loop, those volumes will\n// be cleaned up.\nfunc (rc *reconciler) reconstruct() {\n\tdefer rc.updateReconstructTime()\n\trc.reconstructStates(rc.kubeletPodsDir)"
  },
  {
    "id" : "e165062a-b4a2-4127-ab4d-5d8f5044365f",
    "prId" : 27970,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8923a7b8-1e5c-49d0-b63d-d446cc2bbcb4",
        "parentId" : null,
        "authorId" : "9680f0db-1c00-49c9-968a-be3d5084d153",
        "body" : "@saad-ali @jingxu97 Is this worth logging for later? Would we want to know this incase we are debugging?\n",
        "createdAt" : "2016-08-10T06:43:55Z",
        "updatedAt" : "2016-08-15T18:29:44Z",
        "lastEditedBy" : "9680f0db-1c00-49c9-968a-be3d5084d153",
        "tags" : [
        ]
      },
      {
        "id" : "fc0050ca-85dd-40a7-9219-20ff1c08da75",
        "parentId" : "8923a7b8-1e5c-49d0-b63d-d446cc2bbcb4",
        "authorId" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "body" : "Do you mean logging if the operation is pending?\n",
        "createdAt" : "2016-08-11T05:34:03Z",
        "updatedAt" : "2016-08-15T18:29:44Z",
        "lastEditedBy" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "tags" : [
        ]
      }
    ],
    "commit" : "f19a1148db1b7584be6b6b60abaf8c0bd1503ed3",
    "line" : null,
    "diffHunk" : "@@ -1,1 +413,417 @@\t\t// 2. An operation for the given pod finishes and the actual state is updated.\n\t\t// 3. Checking and there is no pending operation for the given pod.\n\t\tif rc.operationExecutor.IsOperationPending(volumeToMount.VolumeName, volumeToMount.PodName) {\n\t\t\tcontinue\n\t\t}"
  },
  {
    "id" : "2edade9c-49c6-4f84-ad72-2b061e9aa6e8",
    "prId" : 27970,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "15a4ca2b-731d-4bc7-82ba-82923c5adf5e",
        "parentId" : null,
        "authorId" : "9680f0db-1c00-49c9-968a-be3d5084d153",
        "body" : "@jingxu97 @saad-ali I think if we restructure the code in lines 153 to 177 then we might get more readable and simpler flow. Let me show you tomorrow in person. It will only take a second.\n",
        "createdAt" : "2016-08-10T07:01:08Z",
        "updatedAt" : "2016-08-15T18:29:44Z",
        "lastEditedBy" : "9680f0db-1c00-49c9-968a-be3d5084d153",
        "tags" : [
        ]
      },
      {
        "id" : "7ffd6db4-8b14-43e2-88f9-aec9814fb4e2",
        "parentId" : "15a4ca2b-731d-4bc7-82ba-82923c5adf5e",
        "authorId" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "body" : "Will create a new PR to refactor this code later. Leave it as it is for now.\n",
        "createdAt" : "2016-08-11T05:35:43Z",
        "updatedAt" : "2016-08-15T18:29:44Z",
        "lastEditedBy" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "tags" : [
        ]
      }
    ],
    "commit" : "f19a1148db1b7584be6b6b60abaf8c0bd1503ed3",
    "line" : 138,
    "diffHunk" : "@@ -1,1 +154,158 @@\t// Ensure volumes that should be unmounted are unmounted.\n\tfor _, mountedVolume := range rc.actualStateOfWorld.GetMountedVolumes() {\n\t\tif !rc.desiredStateOfWorld.PodExistsInVolume(mountedVolume.PodName, mountedVolume.VolumeName) {\n\t\t\t// Volume is mounted, unmount it\n\t\t\tglog.V(12).Infof(\"Attempting to start UnmountVolume for volume %q (spec.Name: %q) from pod %q (UID: %q).\","
  }
]
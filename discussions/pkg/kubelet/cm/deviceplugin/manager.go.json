[
  {
    "id" : "e267a1ca-1ccb-4387-92c7-227513dd2c60",
    "prId" : 57278,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/57278#pullrequestreview-84323458",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4bf55073-56de-4152-86c6-9f66009868cf",
        "parentId" : null,
        "authorId" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "body" : "What if limits are not set? I think this change should validate if requests==limits prior to using requests.",
        "createdAt" : "2017-12-18T19:17:19Z",
        "updatedAt" : "2017-12-18T19:17:19Z",
        "lastEditedBy" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "tags" : [
        ]
      },
      {
        "id" : "d5460781-35c1-4a1f-a991-973676e58ec9",
        "parentId" : "4bf55073-56de-4152-86c6-9f66009868cf",
        "authorId" : "51f59c69-efc0-451a-bd8f-d9fa2c281fd3",
        "body" : "@vishh if requests != limits for ERs, it will fail here on validation step:\r\nhttps://github.com/kubernetes/kubernetes/blob/master/pkg/apis/core/validation/validation.go#L4380\r\nAnd if limits are not set, then it should not be a problem because now with this change, requests are being scanned.\r\n\r\nOr i missed your question?",
        "createdAt" : "2017-12-18T21:07:30Z",
        "updatedAt" : "2017-12-18T21:07:30Z",
        "lastEditedBy" : "51f59c69-efc0-451a-bd8f-d9fa2c281fd3",
        "tags" : [
        ]
      },
      {
        "id" : "1c43bfe5-993d-4650-81d5-0419ab3536c5",
        "parentId" : "4bf55073-56de-4152-86c6-9f66009868cf",
        "authorId" : "7dd504ec-7e63-45b3-98f8-6eb1c683e9c2",
        "body" : "@vishh Yeah, I raised the same question before, while found that it is actually ensured by validation indeed.\r\n\r\nThat's why I suggested to update this comment to make it more clear. ðŸ˜† ",
        "createdAt" : "2017-12-19T01:47:34Z",
        "updatedAt" : "2017-12-19T04:07:52Z",
        "lastEditedBy" : "7dd504ec-7e63-45b3-98f8-6eb1c683e9c2",
        "tags" : [
        ]
      }
    ],
    "commit" : "bf1fb46347836e8446530272fa0e184ed3eddaf1",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +553,557 @@\t// NOTE: Skipping the Resources.Limits is safe here because:\n\t// 1. If container Spec mentions Limits only, implicitly Requests, equal to Limits, will get added to the Spec.\n\t// 2. If container Spec mentions Limits, which are greater than or less than Requests, will fail at validation.\n\tfor k, v := range container.Resources.Requests {\n\t\tresource := string(k)"
  },
  {
    "id" : "e86a924c-b119-425a-a862-c072bd994c76",
    "prId" : 57266,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/57266#pullrequestreview-86504226",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "589a3608-5a96-4bb5-a2b1-a29d7ba7f777",
        "parentId" : null,
        "authorId" : "784d1027-6681-40bf-820f-6ec72067791f",
        "body" : "I'm just wondering is there any benefits we keep `unhealthyDevices` in cache here. Maybe we can make more discussions about this :)",
        "createdAt" : "2017-12-16T12:05:43Z",
        "updatedAt" : "2018-01-09T16:39:49Z",
        "lastEditedBy" : "784d1027-6681-40bf-820f-6ec72067791f",
        "tags" : [
        ]
      },
      {
        "id" : "e0ca5bad-9cb1-420f-8af3-1dd4072eb647",
        "parentId" : "589a3608-5a96-4bb5-a2b1-a29d7ba7f777",
        "authorId" : "51f59c69-efc0-451a-bd8f-d9fa2c281fd3",
        "body" : "Kubelet needs to update node status taking into account unhealthy devices also(in the capacity). If we dont store unhealthy devices here in device manager, i am not sure how kubelet will sync this info. Would love to hear any suggestions?",
        "createdAt" : "2017-12-16T13:12:45Z",
        "updatedAt" : "2018-01-09T16:39:49Z",
        "lastEditedBy" : "51f59c69-efc0-451a-bd8f-d9fa2c281fd3",
        "tags" : [
        ]
      },
      {
        "id" : "08f48267-df9a-4a32-a89b-7bef8546b15e",
        "parentId" : "589a3608-5a96-4bb5-a2b1-a29d7ba7f777",
        "authorId" : "611b3189-700b-4eda-8a2a-2c4280218d7c",
        "body" : "I think the main benefit is to surface unhealthy device information more clearly through node status to facilitate monitoring and problem detection.",
        "createdAt" : "2018-01-03T21:59:54Z",
        "updatedAt" : "2018-01-09T16:39:49Z",
        "lastEditedBy" : "611b3189-700b-4eda-8a2a-2c4280218d7c",
        "tags" : [
        ]
      }
    ],
    "commit" : "e9cf3f1ac4c97bea716fbac03d2cd71c5189d5c4",
    "line" : 10,
    "diffHunk" : "@@ -1,1 +78,82 @@\n\t// unhealthyDevices contains all of the unhealthy devices and their exported device IDs.\n\tunhealthyDevices map[string]sets.String\n\n\t// allocatedDevices contains allocated deviceIds, keyed by resourceName."
  },
  {
    "id" : "d0a76db6-ec65-45ed-8417-4f42425ae22a",
    "prId" : 57266,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/57266#pullrequestreview-87972567",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5d5c85e4-1322-47d9-9e42-462d32b959e5",
        "parentId" : null,
        "authorId" : "611b3189-700b-4eda-8a2a-2c4280218d7c",
        "body" : "What if resource doesn't exist in capacity yet? Would we get a segfault here? Can we add some unit test for this?\r\n  ",
        "createdAt" : "2018-01-03T22:27:05Z",
        "updatedAt" : "2018-01-09T16:39:49Z",
        "lastEditedBy" : "611b3189-700b-4eda-8a2a-2c4280218d7c",
        "tags" : [
        ]
      },
      {
        "id" : "367c8d2e-7049-4eb4-8aea-a7784296170f",
        "parentId" : "5d5c85e4-1322-47d9-9e42-462d32b959e5",
        "authorId" : "51f59c69-efc0-451a-bd8f-d9fa2c281fd3",
        "body" : "Test is already there: https://github.com/vikaschoudhary16/kubernetes/blob/dc541fa0365de94d1c201baa74bce84d20bd9553/pkg/kubelet/cm/deviceplugin/manager_test.go#L203-L211\r\n\r\nLooks like it wont crash. Just take a look here:\r\nhttps://play.golang.org/p/pi1bI3caJRL\r\n",
        "createdAt" : "2018-01-09T16:23:35Z",
        "updatedAt" : "2018-01-09T16:39:49Z",
        "lastEditedBy" : "51f59c69-efc0-451a-bd8f-d9fa2c281fd3",
        "tags" : [
        ]
      },
      {
        "id" : "0ff50762-e0bb-4f1c-8da0-aa5b90837802",
        "parentId" : "5d5c85e4-1322-47d9-9e42-462d32b959e5",
        "authorId" : "611b3189-700b-4eda-8a2a-2c4280218d7c",
        "body" : "Interesting to know. I guess the map lookup just returns struct with zero values when the key doesn't exist.",
        "createdAt" : "2018-01-10T20:38:55Z",
        "updatedAt" : "2018-01-10T20:38:55Z",
        "lastEditedBy" : "611b3189-700b-4eda-8a2a-2c4280218d7c",
        "tags" : [
        ]
      }
    ],
    "commit" : "e9cf3f1ac4c97bea716fbac03d2cd71c5189d5c4",
    "line" : 105,
    "diffHunk" : "@@ -1,1 +422,426 @@\t\t\tcapacityCount := capacity[v1.ResourceName(resourceName)]\n\t\t\tunhealthyCount := *resource.NewQuantity(int64(devices.Len()), resource.DecimalSI)\n\t\t\tcapacityCount.Add(unhealthyCount)\n\t\t\tcapacity[v1.ResourceName(resourceName)] = capacityCount\n\t\t}"
  },
  {
    "id" : "b72ad1e3-f26a-4897-b754-3cd158ce816d",
    "prId" : 56818,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/56818#pullrequestreview-81110647",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2e185dd9-fc0e-4904-b4dc-6d122c4c3cc7",
        "parentId" : null,
        "authorId" : "784d1027-6681-40bf-820f-6ec72067791f",
        "body" : "nit: can we add new field `devicesToReuse` in `m.podDevices` or `ManagerImpl` , so we can stop passing `devicesToReuse` everywhere :)",
        "createdAt" : "2017-12-05T09:08:23Z",
        "updatedAt" : "2017-12-05T09:09:44Z",
        "lastEditedBy" : "784d1027-6681-40bf-820f-6ec72067791f",
        "tags" : [
        ]
      }
    ],
    "commit" : "d4244f3dede646c5292c8200755d428ae4fbad83",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +241,245 @@func (m *ManagerImpl) Allocate(node *schedulercache.NodeInfo, attrs *lifecycle.PodAdmitAttributes) error {\n\tpod := attrs.Pod\n\tdevicesToReuse := make(map[string]sets.String)\n\t// TODO: Reuse devices between init containers and regular containers.\n\tfor _, container := range pod.Spec.InitContainers {"
  },
  {
    "id" : "328c1508-3a85-4fe2-a5f3-0cf2b0a5158c",
    "prId" : 55730,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/55730#pullrequestreview-77582850",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "983b4d65-62f0-4cd3-9e25-ecb89e8d83e1",
        "parentId" : null,
        "authorId" : "087d84fc-07af-43a9-8be7-af7ed27f5df4",
        "body" : "prefer promoting such a function to be a method of ManagerImpl.\r\nHowever, it's better be done in a follow-up PR to avoid inflating this one.",
        "createdAt" : "2017-11-17T03:01:05Z",
        "updatedAt" : "2017-11-20T21:38:00Z",
        "lastEditedBy" : "087d84fc-07af-43a9-8be7-af7ed27f5df4",
        "tags" : [
        ]
      },
      {
        "id" : "536d8ed0-a521-460f-bc2f-9b9e8edb87cc",
        "parentId" : "983b4d65-62f0-4cd3-9e25-ecb89e8d83e1",
        "authorId" : "1d17743f-ea4f-43e8-a6b8-ee46cf44ae48",
        "body" : "You need to close over the `updateCapacityFunc` in the closure, so that the callback can make changes within the container manager (from endpoint). I don't like the callback - but minimizing the diff to a move, if possible.",
        "createdAt" : "2017-11-17T22:48:00Z",
        "updatedAt" : "2017-11-20T21:38:00Z",
        "lastEditedBy" : "1d17743f-ea4f-43e8-a6b8-ee46cf44ae48",
        "tags" : [
        ]
      }
    ],
    "commit" : "b16bfc768d83095b3012e11c5f937540847ca3a7",
    "line" : 91,
    "diffHunk" : "@@ -1,1 +99,103 @@\t}\n\n\tmanager.callback = func(resourceName string, added, updated, deleted []pluginapi.Device) {\n\t\tvar capacity = v1.ResourceList{}\n\t\tkept := append(updated, added...)"
  },
  {
    "id" : "7569858f-ca1b-4a1b-abdf-df87343a4a1a",
    "prId" : 55730,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/55730#pullrequestreview-77929742",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1efa401c-2a25-4336-988a-9a8972cfab2d",
        "parentId" : null,
        "authorId" : "ac146833-f0d6-4680-968a-749269c0d55d",
        "body" : "Maybe rename this function to `checkpointFile` ?",
        "createdAt" : "2017-11-19T17:12:41Z",
        "updatedAt" : "2017-11-20T21:38:00Z",
        "lastEditedBy" : "ac146833-f0d6-4680-968a-749269c0d55d",
        "tags" : [
        ]
      },
      {
        "id" : "6b095f9b-0a56-4595-b9e3-b6d882316d2f",
        "parentId" : "1efa401c-2a25-4336-988a-9a8972cfab2d",
        "authorId" : "1d17743f-ea4f-43e8-a6b8-ee46cf44ae48",
        "body" : "Good idea - getting that in.",
        "createdAt" : "2017-11-20T21:33:03Z",
        "updatedAt" : "2017-11-20T21:38:00Z",
        "lastEditedBy" : "1d17743f-ea4f-43e8-a6b8-ee46cf44ae48",
        "tags" : [
        ]
      }
    ],
    "commit" : "b16bfc768d83095b3012e11c5f937540847ca3a7",
    "line" : 142,
    "diffHunk" : "@@ -1,1 +166,170 @@// checkpointFile returns device plugin checkpoint file path.\nfunc (m *ManagerImpl) checkpointFile() string {\n\treturn filepath.Join(m.socketdir, kubeletDevicePluginCheckpoint)\n}\n"
  },
  {
    "id" : "b1027d66-af02-4d5c-82e0-314b4250fbfe",
    "prId" : 55340,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/55340#pullrequestreview-76654643",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9d8a3083-46c4-4598-9d51-5d22e4ce9f51",
        "parentId" : null,
        "authorId" : "784d1027-6681-40bf-820f-6ec72067791f",
        "body" : "Just wondering why not count the `successful` registrationï¼Ÿ",
        "createdAt" : "2017-11-14T08:43:31Z",
        "updatedAt" : "2017-11-21T21:44:25Z",
        "lastEditedBy" : "784d1027-6681-40bf-820f-6ec72067791f",
        "tags" : [
        ]
      },
      {
        "id" : "de92b7ea-475d-44a7-ab11-54e97481002b",
        "parentId" : "9d8a3083-46c4-4598-9d51-5d22e4ce9f51",
        "authorId" : "611b3189-700b-4eda-8a2a-2c4280218d7c",
        "body" : "I think it is also useful to track failed ones. For now, we can start with a single metric to track both. If needs come, we can consider to add separate metrics for failed and successful registrations.",
        "createdAt" : "2017-11-14T22:09:37Z",
        "updatedAt" : "2017-11-21T21:44:25Z",
        "lastEditedBy" : "611b3189-700b-4eda-8a2a-2c4280218d7c",
        "tags" : [
        ]
      },
      {
        "id" : "edc56e89-e83a-4542-8a21-a5f578197e2d",
        "parentId" : "9d8a3083-46c4-4598-9d51-5d22e4ce9f51",
        "authorId" : "784d1027-6681-40bf-820f-6ec72067791f",
        "body" : "lgtm",
        "createdAt" : "2017-11-15T01:44:29Z",
        "updatedAt" : "2017-11-21T21:44:25Z",
        "lastEditedBy" : "784d1027-6681-40bf-820f-6ec72067791f",
        "tags" : [
        ]
      }
    ],
    "commit" : "048bafdd0b2f32bfc5fdc9122a46c80da3c911ee",
    "line" : 20,
    "diffHunk" : "@@ -1,1 +268,272 @@func (m *ManagerImpl) Register(ctx context.Context, r *pluginapi.RegisterRequest) (*pluginapi.Empty, error) {\n\tglog.Infof(\"Got registration request from device plugin with resource name %q\", r.ResourceName)\n\tmetrics.DevicePluginRegistrationCount.WithLabelValues(r.ResourceName).Inc()\n\tif r.Version != pluginapi.Version {\n\t\terrorString := fmt.Sprintf(errUnsuportedVersion, r.Version, pluginapi.Version)"
  },
  {
    "id" : "8f8d9a9a-1205-431f-9bbd-ee7508acacaa",
    "prId" : 52149,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/52149#pullrequestreview-76982275",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b44e1154-9914-4675-acf9-210f1e9de39d",
        "parentId" : null,
        "authorId" : "087d84fc-07af-43a9-8be7-af7ed27f5df4",
        "body" : "this looks ugly to me ... it could have been implemented differently, using a single, short lock while avoiding reregistration:\r\n\r\n```\r\nfunc (m *ManagerImpl) addEndpoint(r *pluginapi.RegisterRequest) {\r\n\r\n    // The call involves an initial dial up which may take time to conclude\r\n    e, err := newEndpoint(m, r)\r\n    if err != nil {\r\n        glog.Errorf(\"Failed to initialize endpoint %v: %v\", r.Endpoint, err)\r\n        return\r\n    }\r\n\r\n    // Now we lock the endpoints for mutation\r\n    registered := false\r\n    m.mutex.Lock()\r\n    curr, ok := m.endpoints[r.ResourceName]\r\n    if ok & curr != nil {\r\n       registered = true\r\n    } else {\r\n       m.endpoints[r.ResourceName] = e\r\n    }\r\n    m.mutex.Unlock()\r\n\r\n    if registered {\r\n       e.stop()\r\n       e = curr\r\n    } else {\r\n       curr.stop()\r\n    }\r\n\r\n    go func() {\r\n       e.run()\r\n       ...\r\n    }()\r\n}\r\n```\r\n\r\nIn pkg/kubelet/cm/deviceplugin/endpoint.go:\r\n\r\n```\r\nfunc newEndpoint(m *Manager, resourceName string, r *pluginapi.RegisterRequest) (*endpoint, error) {\r\n    socketPath := filepath.Join(m.SocketPath(), r.Endpoint)\r\n    client, c, err := dial(socketPath)\r\n    if err != nil {\r\n        return nil, err\r\n    }\r\n    return &endpoint{\r\n       client: client,\r\n       clientConn: c,\r\n       socketPath: socketPath,\r\n       resourceName: resourceName,\r\n       callback: m.callback,\r\n    }, nil\r\n}\r\n```",
        "createdAt" : "2017-11-15T09:22:48Z",
        "updatedAt" : "2017-11-15T09:29:46Z",
        "lastEditedBy" : "087d84fc-07af-43a9-8be7-af7ed27f5df4",
        "tags" : [
        ]
      },
      {
        "id" : "15217635-d261-4722-b7fe-f2713236e6c2",
        "parentId" : "b44e1154-9914-4675-acf9-210f1e9de39d",
        "authorId" : "1a75d411-1ce5-48f2-9967-25f88794c451",
        "body" : "Well, the issue of re-registration is raised by the original purpose of passing existing devs into `newEndpoint` , plz take a look at #55179 and comments above",
        "createdAt" : "2017-11-15T09:36:28Z",
        "updatedAt" : "2017-11-15T09:36:28Z",
        "lastEditedBy" : "1a75d411-1ce5-48f2-9967-25f88794c451",
        "tags" : [
        ]
      },
      {
        "id" : "27479038-75f4-4dc6-8de6-357c3597031e",
        "parentId" : "b44e1154-9914-4675-acf9-210f1e9de39d",
        "authorId" : "087d84fc-07af-43a9-8be7-af7ed27f5df4",
        "body" : "well, I will check that PR review history. At the same time, I would suggest you to try review the logic I suggested above and see if it help simplify the whole function. It would also be a help to me so I know if I'm misunderstanding something.",
        "createdAt" : "2017-11-16T01:01:05Z",
        "updatedAt" : "2017-11-16T01:01:05Z",
        "lastEditedBy" : "087d84fc-07af-43a9-8be7-af7ed27f5df4",
        "tags" : [
        ]
      }
    ],
    "commit" : "4fa0fa5ad17fd8484102e8d4e553d8cc28d86704",
    "line" : 52,
    "diffHunk" : "@@ -1,1 +230,234 @@\t\te.stop()\n\t\treturn\n\t}\n\t// Associates the newly created endpoint with the corresponding resource name.\n\t// Stops existing endpoint if there is any."
  },
  {
    "id" : "77007cdf-fef7-45c4-98fe-20f1b4264bad",
    "prId" : 52149,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/52149#pullrequestreview-76944501",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "14b95046-15fe-4ac9-b9df-17092a11a31c",
        "parentId" : null,
        "authorId" : "ac146833-f0d6-4680-968a-749269c0d55d",
        "body" : "This should not be in the lock",
        "createdAt" : "2017-11-15T21:57:42Z",
        "updatedAt" : "2017-11-15T21:57:42Z",
        "lastEditedBy" : "ac146833-f0d6-4680-968a-749269c0d55d",
        "tags" : [
        ]
      }
    ],
    "commit" : "4fa0fa5ad17fd8484102e8d4e553d8cc28d86704",
    "line" : 24,
    "diffHunk" : "@@ -1,1 +206,210 @@\tm.mutex.Lock()\n\told, ok := m.endpoints[r.ResourceName]\n\tif ok && old != nil {\n\t\t// Pass devices of previous endpoint into re-registered one,\n\t\t// to avoid potential orphaned devices upon re-registration"
  }
]
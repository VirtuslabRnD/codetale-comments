[
  {
    "id" : "4c8b3d91-9762-4aff-8f9d-5aed82b38f76",
    "prId" : 78587,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/78587#pullrequestreview-244593917",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ac4f56be-1f7e-4eac-9710-8a5ae104a283",
        "parentId" : null,
        "authorId" : "d7870cae-47b0-4c8e-8527-be8fc4be86de",
        "body" : "I'm having a little trouble understanding how the previous version of this test passed? It seems like if the mask bit is 0, then there should be no 1's right? similarly, if the mask bit is 42, shouldn't the count of 1s be more than 1?",
        "createdAt" : "2019-06-01T14:36:06Z",
        "updatedAt" : "2019-06-01T16:56:01Z",
        "lastEditedBy" : "d7870cae-47b0-4c8e-8527-be8fc4be86de",
        "tags" : [
        ]
      },
      {
        "id" : "bfa65417-6454-40d9-aa1f-84d944d34fcf",
        "parentId" : "ac4f56be-1f7e-4eac-9710-8a5ae104a283",
        "authorId" : "8eff55b7-2f52-4dd6-b8a6-b75a1c427179",
        "body" : "The previous test sets bit 0 in the mask, so 1 bit is set. The new test just changes this to set bit 42 instead. There is no real reason to pick bit 42 over bit 0. It doesn't change the outcome.",
        "createdAt" : "2019-06-01T15:15:12Z",
        "updatedAt" : "2019-06-01T16:56:01Z",
        "lastEditedBy" : "8eff55b7-2f52-4dd6-b8a6-b75a1c427179",
        "tags" : [
        ]
      },
      {
        "id" : "506d9e72-d8a2-4fdb-9bb0-9bcecfa01f0a",
        "parentId" : "ac4f56be-1f7e-4eac-9710-8a5ae104a283",
        "authorId" : "659c7c1f-39ba-41a7-8331-fcc6b3b5f2fb",
        "body" : "@mattjmcnaughton previous version of the test sets first bit. For function that supposed to count amount of 1s in the bitmask, is a very trivial case. It would be of course better to have test completely rewritten to have it tested 2-3 bits set in the beginning/middle/end of the range... But well, I think checking that mask has 1 bit set somewhere in the middle is good enough for updated code that uses standard library.",
        "createdAt" : "2019-06-01T16:47:32Z",
        "updatedAt" : "2019-06-01T16:56:01Z",
        "lastEditedBy" : "659c7c1f-39ba-41a7-8331-fcc6b3b5f2fb",
        "tags" : [
        ]
      }
    ],
    "commit" : "89481f8c27cb3cb96e9055eec6fb314fcd138f33",
    "line" : 96,
    "diffHunk" : "@@ -1,1 +254,258 @@\t\t{\n\t\t\tname:          \"Count number of bits set in full mask\",\n\t\t\tmaskBit:       42,\n\t\t\texpectedCount: 1,\n\t\t},"
  },
  {
    "id" : "eecc3430-ac1a-403a-b3f5-40c5a1b52fcc",
    "prId" : 73920,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/73920#pullrequestreview-275108679",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "dadbbdea-572c-41f7-be40-3f4217493043",
        "parentId" : null,
        "authorId" : "8b309230-89cb-4a04-bf89-29a323dad0d8",
        "body" : "nit: interval is [1, 2^n] IIUC.\r\nBut, üëç for this simplification",
        "createdAt" : "2019-08-14T19:33:17Z",
        "updatedAt" : "2019-08-14T19:33:17Z",
        "lastEditedBy" : "8b309230-89cb-4a04-bf89-29a323dad0d8",
        "tags" : [
        ]
      },
      {
        "id" : "22fc20ea-9c98-4199-a04f-52b73b60732d",
        "parentId" : "dadbbdea-572c-41f7-be40-3f4217493043",
        "authorId" : "8eff55b7-2f52-4dd6-b8a6-b75a1c427179",
        "body" : "I'm pretty sure it's the range [1, 2^n-1].\r\n\r\nFor example, with 2 sockets we get: {01, 10, 11}\r\nWhich has 3 elements (i.e. 2^n -1 elements) representing the numbers 1, 2, and 3 (i.e. [1, 2^n-1])",
        "createdAt" : "2019-08-14T19:43:00Z",
        "updatedAt" : "2019-08-14T19:43:11Z",
        "lastEditedBy" : "8eff55b7-2f52-4dd6-b8a6-b75a1c427179",
        "tags" : [
        ]
      }
    ],
    "commit" : "b3f4bed97f3f47035a68032bd1c33a2f8782fbd6",
    "line" : 40,
    "diffHunk" : "@@ -1,1 +379,383 @@\t\t// Calculate the expected number of masks. Since we always have masks\n\t\t// with sockets from 0..n, this is just (2^n - 1) since we want 1 mask\n\t\t// represented by each integer between 1 and 2^n-1.\n\t\texpectedNumMasks := (1 << uint(tc.numSockets)) - 1\n"
  }
]
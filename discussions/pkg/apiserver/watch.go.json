[
  {
    "id" : "36e481cd-16eb-4ebf-8352-827ed1fcfac9",
    "prId" : 26085,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9174a188-56c5-4653-af37-e687bff4c721",
        "parentId" : null,
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "I'm not convinced about this change. If the chrun in the cluster is big enough, ch can potentially never be empty.\n\nI think we should flush no matter what at least 1 per X milliseconds.\n",
        "createdAt" : "2016-05-23T17:11:23Z",
        "updatedAt" : "2016-05-23T17:11:23Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      },
      {
        "id" : "848affec-dd40-48c5-aebd-50a46b150a8c",
        "parentId" : "9174a188-56c5-4653-af37-e687bff4c721",
        "authorId" : "55c0e4a8-86f8-4426-a163-752ee421c57e",
        "body" : "see my suggestion. we can have a simple pending number.\n",
        "createdAt" : "2016-05-23T17:13:00Z",
        "updatedAt" : "2016-05-23T17:13:00Z",
        "lastEditedBy" : "55c0e4a8-86f8-4426-a163-752ee421c57e",
        "tags" : [
        ]
      },
      {
        "id" : "dd48ab94-a1a0-4177-adaf-849a0a53337f",
        "parentId" : "9174a188-56c5-4653-af37-e687bff4c721",
        "authorId" : "55c0e4a8-86f8-4426-a163-752ee421c57e",
        "body" : "also shouldnt http layer will do a auto flush if the http buffer is getting large?\n",
        "createdAt" : "2016-05-23T17:13:45Z",
        "updatedAt" : "2016-05-23T17:13:45Z",
        "lastEditedBy" : "55c0e4a8-86f8-4426-a163-752ee421c57e",
        "tags" : [
        ]
      },
      {
        "id" : "2be05468-357e-46ce-ae94-99d70658c12f",
        "parentId" : "9174a188-56c5-4653-af37-e687bff4c721",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Flush will happen under the covers for us - if we had enough items that the\ncluster would never be full, we would never have to flush because Go would\nbe flushing for us.\n\nOn Mon, May 23, 2016 at 1:11 PM, Wojciech Tyczynski <\nnotifications@github.com> wrote:\n\n> In pkg/apiserver/watch.go\n> https://github.com/kubernetes/kubernetes/pull/26085#discussion_r64252864\n> :\n> \n> > @@ -196,7 +197,9 @@ func (s *WatchServer) ServeHTTP(w http.ResponseWriter, req *http.Request) {\n> >                 // client disconnect.\n> >                 return\n> >             }\n> > -           flusher.Flush()\n> > -           if len(ch) == 0 {\n> \n> I'm not convinced about this change. If the chrun in the cluster is big\n> enough, ch can potentially never be empty.\n> \n> I think we should flush no matter what at least 1 per X milliseconds.\n> \n> 窶能n> You are receiving this because you authored the thread.\n> Reply to this email directly or view it on GitHub\n> https://github.com/kubernetes/kubernetes/pull/26085/files/c4bec1585fe9c31303c928c11ac45e380d2eaf77#r64252864\n",
        "createdAt" : "2016-05-23T17:14:35Z",
        "updatedAt" : "2016-05-23T17:14:35Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "67296ce7-d4c0-443b-b032-a9831d3b9814",
        "parentId" : "9174a188-56c5-4653-af37-e687bff4c721",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "To your last question, yes, we merely want to ensure we always flush if we\nreceive the \"last\" event.  In all other cases Go will handle flushing for\nus.\n\nOn Mon, May 23, 2016 at 1:14 PM, Xiang Li notifications@github.com wrote:\n\n> In pkg/apiserver/watch.go\n> https://github.com/kubernetes/kubernetes/pull/26085#discussion_r64253208\n> :\n> \n> > @@ -196,7 +197,9 @@ func (s *WatchServer) ServeHTTP(w http.ResponseWriter, req *http.Request) {\n> >                 // client disconnect.\n> >                 return\n> >             }\n> > -           flusher.Flush()\n> > -           if len(ch) == 0 {\n> \n> also shouldnt http layer will do a auto flush if the http buffer is\n> getting large?\n> \n> 窶能n> You are receiving this because you authored the thread.\n> Reply to this email directly or view it on GitHub\n> https://github.com/kubernetes/kubernetes/pull/26085/files/c4bec1585fe9c31303c928c11ac45e380d2eaf77#r64253208\n",
        "createdAt" : "2016-05-23T17:15:13Z",
        "updatedAt" : "2016-05-23T17:15:13Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "570bee05-1a8c-4266-b210-7e211f72ce8b",
        "parentId" : "9174a188-56c5-4653-af37-e687bff4c721",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "Do we have any guarantee on how frequently it will happen?\nI know that this will happen, but if it waits for say tens of MB, that may not be good enough for us.\n",
        "createdAt" : "2016-05-23T17:22:04Z",
        "updatedAt" : "2016-05-23T17:22:04Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      },
      {
        "id" : "2623642d-a9af-49d9-8a11-77182be3b100",
        "parentId" : "9174a188-56c5-4653-af37-e687bff4c721",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "It wouldn't wait - once you reached the net/http buffer you'd get written.\nI think the buffer is 32kb or 64kb by default.\n\nOn Mon, May 23, 2016 at 1:22 PM, Wojciech Tyczynski <\nnotifications@github.com> wrote:\n\n> In pkg/apiserver/watch.go\n> https://github.com/kubernetes/kubernetes/pull/26085#discussion_r64254422\n> :\n> \n> > @@ -196,7 +197,9 @@ func (s *WatchServer) ServeHTTP(w http.ResponseWriter, req *http.Request) {\n> >                 // client disconnect.\n> >                 return\n> >             }\n> > -           flusher.Flush()\n> > -           if len(ch) == 0 {\n> \n> Do we have any guarantee on how frequently it will happen?\n> I know that this will happen, but if it waits for say tens of MB, that may\n> not be good enough for us.\n> \n> 窶能n> You are receiving this because you authored the thread.\n> Reply to this email directly or view it on GitHub\n> https://github.com/kubernetes/kubernetes/pull/26085/files/c4bec1585fe9c31303c928c11ac45e380d2eaf77#r64254422\n",
        "createdAt" : "2016-05-23T17:36:35Z",
        "updatedAt" : "2016-05-23T17:36:36Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "5315af9c-1af2-49cb-8249-7d46b2f1dff9",
        "parentId" : "9174a188-56c5-4653-af37-e687bff4c721",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "ok  - SGTM;\nthanks for clarification\n",
        "createdAt" : "2016-05-23T17:45:39Z",
        "updatedAt" : "2016-05-23T17:45:39Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "c4bec1585fe9c31303c928c11ac45e380d2eaf77",
    "line" : 21,
    "diffHunk" : "@@ -1,1 +198,202 @@\t\t\t\treturn\n\t\t\t}\n\t\t\tif len(ch) == 0 {\n\t\t\t\tflusher.Flush()\n\t\t\t}"
  },
  {
    "id" : "7f448ccf-4ff2-4f30-bf54-1929bae7c6de",
    "prId" : 23806,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "18a304a5-2958-4ba4-81d1-8f1e2cd3ad9f",
        "parentId" : null,
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "So that means that we are always sending \"runtim.Unknown\" as part of our watch.\nI'm not saying it's bad, but maybe we should document it somewhere.\n\n@lavalamp - FYI ^^\n",
        "createdAt" : "2016-04-04T17:00:51Z",
        "updatedAt" : "2016-04-11T15:22:09Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      },
      {
        "id" : "2bce488e-c01b-4ce2-9ba1-e0e62213daea",
        "parentId" : "18a304a5-2958-4ba4-81d1-8f1e2cd3ad9f",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "No, the serialization of runtime.Unknown is unwrapped to send the actual\nbody for JSON and is the normal serialization for protobuf.\n\nOn Mon, Apr 4, 2016 at 1:01 PM, Wojciech Tyczynski <notifications@github.com\n\n> wrote:\n> \n> In pkg/apiserver/watch.go\n> https://github.com/kubernetes/kubernetes/pull/23806#discussion_r58409606\n> :\n> \n> > ```\n> >         if !ok {\n> >             // End of results.\n> >             return\n> >         }\n> > ```\n> > -           self.fixup(event.Object)\n> > -           if err := encoder.Encode(&event); err != nil {\n> > -               // Client disconnect.\n> > -           obj := event.Object\n> > -           s.fixup(obj)\n> > -           if err := s.embeddedEncoder.EncodeToStream(obj, buf); err != nil {\n> > -               // unexpected error\n> > -               utilruntime.HandleError(fmt.Errorf(\"unable to encode watch object: %v\", err))\n> > -               return\n> > -           }\n> > -           event.Object = &runtime.Unknown{\n> \n> So that means that we are always sending \"runtim.Unknown\" as part of our\n> watch.\n> I'm not saying it's bad, but maybe we should document it somewhere.\n> \n> @lavalamp https://github.com/lavalamp - FYI ^^\n> \n> 窶能n> You are receiving this because you authored the thread.\n> Reply to this email directly or view it on GitHub\n> https://github.com/kubernetes/kubernetes/pull/23806/files/26e6630171ddc8f3653bbcfa270efb87e1073818#r58409606\n",
        "createdAt" : "2016-04-04T17:05:56Z",
        "updatedAt" : "2016-04-11T15:22:09Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "9b21a631-3495-42bf-aabb-13ba3c5519d5",
        "parentId" : "18a304a5-2958-4ba4-81d1-8f1e2cd3ad9f",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "Sorry - I'm probably missing something. So the \"Encode\" method in case of runtime.Unknown is not serializating the Unknown object, but is just taking the Raw field and returns it? Is that the case?\n",
        "createdAt" : "2016-04-04T17:50:43Z",
        "updatedAt" : "2016-04-11T15:22:09Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      },
      {
        "id" : "0ee2bcbd-baf1-49c8-a5f1-4a2f02b8cdd1",
        "parentId" : "18a304a5-2958-4ba4-81d1-8f1e2cd3ad9f",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Each serializer handles runtime.Unknown being passed to it.  The behavior should roughly be - if you get a runtime.Unknown without a content type, assume the content type is the same as the object and encode the raw bytes.  However, since some protobuf output needs to be wrapped with type info, the Serializer and RawSerializer for protobuf behave differently.  The serializer would write the runtime.Unknown itself (with type info added).  The raw serializer would write the byte contents only.\n\nBy passing runtime.Unknown here we're saying \"we've already encoded this object\".  The embedded encoder _must_ add type info (since the event is a true generic runtime.Unknown).  The stream encoder is a raw serializer, and only writes the raw event protobuf fields (since events aren't typed themselves, don't have TypeMeta)\n",
        "createdAt" : "2016-04-04T18:05:30Z",
        "updatedAt" : "2016-04-11T15:22:09Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "6937c89a-3ff9-40cf-b1c8-a24ed391f5f2",
        "parentId" : "18a304a5-2958-4ba4-81d1-8f1e2cd3ad9f",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "Thanks for explanation,\n",
        "createdAt" : "2016-04-04T20:06:06Z",
        "updatedAt" : "2016-04-11T15:22:09Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "34749117364be27ac7c6d5826043687210dfed34",
    "line" : 259,
    "diffHunk" : "@@ -1,1 +203,207 @@\t\t\t\treturn\n\t\t\t}\n\t\t\tevent.Object = &runtime.Unknown{\n\t\t\t\tRaw: buf.Bytes(),\n\t\t\t\t// ContentType is not required here because we are defaulting to the serializer"
  },
  {
    "id" : "67b7fcae-9242-4696-9dc9-ad7206351ab3",
    "prId" : 23806,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5d954717-298f-4728-a357-665fbedff9c9",
        "parentId" : null,
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "In general - shouldn't we do the conversion here? Maybe add a TODO about it? WDYT?\n",
        "createdAt" : "2016-04-04T17:37:07Z",
        "updatedAt" : "2016-04-11T15:22:09Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      },
      {
        "id" : "3fc7e656-a35d-4e6a-85cd-dc056a4d43be",
        "parentId" : "5d954717-298f-4728-a357-665fbedff9c9",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "The encoder is responsible for understanding how to convert an internal event to the proper format and version.  I can add a comment to that effect.\n",
        "createdAt" : "2016-04-04T17:47:52Z",
        "updatedAt" : "2016-04-11T15:22:09Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      }
    ],
    "commit" : "34749117364be27ac7c6d5826043687210dfed34",
    "line" : null,
    "diffHunk" : "@@ -1,1 +250,254 @@\t\t\t}\n\t\t\t// the internal event will be versioned by the encoder\n\t\t\tinternalEvent := versioned.InternalEvent(event)\n\t\t\tif err := s.encoder.EncodeToStream(&internalEvent, streamBuf); err != nil {\n\t\t\t\t// encoding error"
  },
  {
    "id" : "c702d36c-5f55-4c98-a877-9229847b5c6e",
    "prId" : 4299,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "647f3247-1838-468f-a40f-b1e8005723e8",
        "parentId" : null,
        "authorId" : "b7abca6a-d6be-4008-a014-3b5ca0e90529",
        "body" : "this makes me slightly worries that in the future changes we'll forget to add this annotation\n",
        "createdAt" : "2015-02-11T00:24:51Z",
        "updatedAt" : "2015-02-11T00:24:51Z",
        "lastEditedBy" : "b7abca6a-d6be-4008-a014-3b5ca0e90529",
        "tags" : [
        ]
      }
    ],
    "commit" : "ab62b689a54b33c2667aa6c77a0a15b261f6d577",
    "line" : 36,
    "diffHunk" : "@@ -1,1 +109,113 @@\tif storage == nil {\n\t\tnotFound(w, req)\n\t\thttpCode = http.StatusNotFound\n\t\treturn\n\t}"
  }
]
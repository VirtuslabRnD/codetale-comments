[
  {
    "id" : "dd9c46f1-fcf9-437d-8c3c-91809f6e41cc",
    "prId" : 35806,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/35806#pullrequestreview-6326000",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bfcaf0f8-79f9-4410-b367-fb93774b6000",
        "parentId" : null,
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "please add a test to apiserver_test.go that verifies the 3 permutations (body+query, body, query)\n",
        "createdAt" : "2016-10-28T20:37:27Z",
        "updatedAt" : "2016-11-04T17:59:07Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "d19b2699-108c-4969-b876-cbc03f2e9955",
        "parentId" : "bfcaf0f8-79f9-4410-b367-fb93774b6000",
        "authorId" : "8af2a32b-decc-43ef-8ba4-bebd2819128c",
        "body" : "Added, please take a look\n",
        "createdAt" : "2016-10-28T21:56:56Z",
        "updatedAt" : "2016-11-04T17:59:07Z",
        "lastEditedBy" : "8af2a32b-decc-43ef-8ba4-bebd2819128c",
        "tags" : [
        ]
      }
    ],
    "commit" : "2e7195fbcb41cc7c8a53023af2eef16450d735fe",
    "line" : 23,
    "diffHunk" : "@@ -1,1 +783,787 @@\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif values := req.Request.URL.Query(); len(values) > 0 {\n\t\t\t\t\tif err := scope.ParameterCodec.DecodeParameters(values, scope.Kind.GroupVersion(), options); err != nil {\n\t\t\t\t\t\tscope.err(err, res.ResponseWriter, req.Request)"
  },
  {
    "id" : "c12f4357-6394-45d3-9293-b650dd6d7ffa",
    "prId" : 25787,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e1991d2c-375a-4d1f-b463-675cf169d83d",
        "parentId" : null,
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "second condition dominates the first, right?\n",
        "createdAt" : "2016-05-23T13:27:00Z",
        "updatedAt" : "2016-05-24T01:11:47Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      }
    ],
    "commit" : "29252acd1ad80ca492c800713d9bc329282e9ed8",
    "line" : null,
    "diffHunk" : "@@ -1,1 +555,559 @@\n\t\tswitch {\n\t\tcase len(originalObjJS) == 0 || len(originalPatchedObjJS) == 0:\n\t\t\t// first time through,\n\t\t\t// 1. apply the patch"
  },
  {
    "id" : "c37d4ca0-8a8c-4418-8da8-ab18c36fe5d5",
    "prId" : 25787,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "42d497fc-33e1-43fe-93f7-a70df981a915",
        "parentId" : null,
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "short circuit on empty currentObject?  I'm hard pressed to see a case where a patch on an object that used to exist, that was subsequently deleted should have a shot at creating a new object.  I'm not certain of the \"create using update\" path, but I'm concerned about accidentally hitting it.\n",
        "createdAt" : "2016-05-23T13:32:40Z",
        "updatedAt" : "2016-05-24T01:11:47Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      },
      {
        "id" : "d5af7452-0a10-405a-be48-1091ebe0e97f",
        "parentId" : "42d497fc-33e1-43fe-93f7-a70df981a915",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "added check for persisted object (and a test)\n",
        "createdAt" : "2016-05-23T19:37:05Z",
        "updatedAt" : "2016-05-24T01:11:47Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "29252acd1ad80ca492c800713d9bc329282e9ed8",
    "line" : 104,
    "diffHunk" : "@@ -1,1 +546,550 @@\t// applyPatch is called every time GuaranteedUpdate asks for the updated object,\n\t// and is given the currently persisted object as input.\n\tapplyPatch := func(_ api.Context, _, currentObject runtime.Object) (runtime.Object, error) {\n\t\t// Make sure we actually have a persisted currentObject\n\t\tif hasUID, err := hasUID(currentObject); err != nil {"
  },
  {
    "id" : "8ee49ab7-da30-4b43-becf-634ade797aed",
    "prId" : 25787,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0e2b0596-3e40-4312-ad6c-8dd2d2c92bc7",
        "parentId" : null,
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "seems like delete ought to get a shot at any existing resource.\n",
        "createdAt" : "2016-05-23T13:35:09Z",
        "updatedAt" : "2016-05-24T01:11:47Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      },
      {
        "id" : "bbf5f8fd-c6da-489d-bf42-c3c7988d0de6",
        "parentId" : "0e2b0596-3e40-4312-ad6c-8dd2d2c92bc7",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "I'll add to the follow up list, looks like the storage only fetches the old object on graceful deletes. that's not a straightforward bit of code, so I'd need to think about the implications a bit.\n",
        "createdAt" : "2016-05-23T15:04:18Z",
        "updatedAt" : "2016-05-24T01:11:47Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "2c3d9868-5c3d-4e32-afa4-41ab858b06e4",
        "parentId" : "0e2b0596-3e40-4312-ad6c-8dd2d2c92bc7",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "I'll add to the follow up list. Looks like rest storage only gets the resource in case of graceful delete. That's not a straightforward bit of code, so it'll take some thought to make work.\n",
        "createdAt" : "2016-05-23T15:14:55Z",
        "updatedAt" : "2016-05-24T01:11:47Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "41125845-6221-468a-bafd-3010d725dd60",
        "parentId" : "0e2b0596-3e40-4312-ad6c-8dd2d2c92bc7",
        "authorId" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "body" : "Could you give an example on why knowing the oldObj is useful for the admission a deletion?\n",
        "createdAt" : "2016-05-24T00:17:13Z",
        "updatedAt" : "2016-05-24T01:11:47Z",
        "lastEditedBy" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "tags" : [
        ]
      },
      {
        "id" : "9fe25c23-d54a-4d1c-b7c2-6232b92942d3",
        "parentId" : "0e2b0596-3e40-4312-ad6c-8dd2d2c92bc7",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Additional state semantics around deletion - reject if controller still\nexists, for example.\n\nOn May 23, 2016, at 8:17 PM, Chao Xu notifications@github.com wrote:\n\nIn pkg/apiserver/resthandler.go\nhttps://github.com/kubernetes/kubernetes/pull/25787#discussion_r64311017:\n\n> @@ -753,7 +781,7 @@ func DeleteResource(r rest.GracefulDeleter, checkBody bool, scope RequestScope,\n>       if admit != nil && admit.Handles(admission.Delete) {\n>           userInfo, _ := api.UserFrom(ctx)\n> -         err = admit.Admit(admission.NewAttributesRecord(nil, scope.Kind, namespace, name, scope.Resource, scope.Subresource, admission.Delete, userInfo))\n> -         err = admit.Admit(admission.NewAttributesRecord(nil, nil, scope.Kind, namespace, name, scope.Resource, scope.Subresource, admission.Delete, userInfo))\n\nCould you give an example on why knowing the oldObj is useful for the\nadmission a deletion?\n\n—\nYou are receiving this because you were mentioned.\nReply to this email directly or view it on GitHub\nhttps://github.com/kubernetes/kubernetes/pull/25787/files/bf47e5790193381752c396876a2ce9950fe01e6d#r64311017\n",
        "createdAt" : "2016-05-24T00:41:48Z",
        "updatedAt" : "2016-05-24T01:11:47Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "052a1538-8e51-41a9-8f6e-a1aa58faa6af",
        "parentId" : "0e2b0596-3e40-4312-ad6c-8dd2d2c92bc7",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "just off the top of my head, hints for releasing quota based on the old object, the ability to have admission limit access to objects with certain fields, etc\n",
        "createdAt" : "2016-05-24T00:43:50Z",
        "updatedAt" : "2016-05-24T01:11:47Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "c86afc8d-7586-4d07-a14e-a41cb0f12288",
        "parentId" : "0e2b0596-3e40-4312-ad6c-8dd2d2c92bc7",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Good point, current admission for quota has to look up the old object to\ndetermine which scope it falls under.  This would replace the need for that.\n\nOn May 23, 2016, at 8:44 PM, Jordan Liggitt notifications@github.com\nwrote:\n\nIn pkg/apiserver/resthandler.go\nhttps://github.com/kubernetes/kubernetes/pull/25787#discussion_r64313140:\n\n> @@ -753,7 +781,7 @@ func DeleteResource(r rest.GracefulDeleter, checkBody bool, scope RequestScope,\n>       if admit != nil && admit.Handles(admission.Delete) {\n>           userInfo, _ := api.UserFrom(ctx)\n> -         err = admit.Admit(admission.NewAttributesRecord(nil, scope.Kind, namespace, name, scope.Resource, scope.Subresource, admission.Delete, userInfo))\n> -         err = admit.Admit(admission.NewAttributesRecord(nil, nil, scope.Kind, namespace, name, scope.Resource, scope.Subresource, admission.Delete, userInfo))\n\njust off the top of my head, hints for releasing quota based on the old\nobject, the ability to have admission limit access to objects with certain\nfields, etc\n\n—\nYou are receiving this because you were mentioned.\nReply to this email directly or view it on GitHub\nhttps://github.com/kubernetes/kubernetes/pull/25787/files/bf47e5790193381752c396876a2ce9950fe01e6d#r64313140\n",
        "createdAt" : "2016-05-24T00:50:46Z",
        "updatedAt" : "2016-05-24T01:11:47Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      }
    ],
    "commit" : "29252acd1ad80ca492c800713d9bc329282e9ed8",
    "line" : 243,
    "diffHunk" : "@@ -1,1 +789,793 @@\t\t\tuserInfo, _ := api.UserFrom(ctx)\n\n\t\t\terr = admit.Admit(admission.NewAttributesRecord(nil, nil, scope.Kind, namespace, name, scope.Resource, scope.Subresource, admission.Delete, userInfo))\n\t\t\tif err != nil {\n\t\t\t\tscope.err(err, res.ResponseWriter, req.Request)"
  },
  {
    "id" : "4dbd52c2-5152-4f03-98f0-850b8a7fc670",
    "prId" : 23145,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e8d7d463-3e0b-49f7-991a-ad7e565e3e1e",
        "parentId" : null,
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "Who owns versionedObj? Is it shared between multiple requests? \n",
        "createdAt" : "2016-03-17T20:44:54Z",
        "updatedAt" : "2016-03-17T20:44:54Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "9b199b22-abd2-41ee-a1d4-a816b679ecf4",
        "parentId" : "e8d7d463-3e0b-49f7-991a-ad7e565e3e1e",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "If so, should make a copy.\n",
        "createdAt" : "2016-03-17T20:45:29Z",
        "updatedAt" : "2016-03-17T20:45:29Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "e3789322-7967-4068-8253-62d15e3fa639",
        "parentId" : "e8d7d463-3e0b-49f7-991a-ad7e565e3e1e",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "versionedObj is given to this func to use as the schema for patch computation\n",
        "createdAt" : "2016-03-17T20:46:54Z",
        "updatedAt" : "2016-03-17T20:46:54Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "1369da41-f524-4105-8b94-50abbfbe15ae",
        "parentId" : "e8d7d463-3e0b-49f7-991a-ad7e565e3e1e",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "per-request, built here: https://github.com/kubernetes/kubernetes/pull/23145/files/ea8669661aa9f376e1a08ee77f65aa6ca452ed49#diff-fe6dbe5fa548ea5c031a5be1669a6376R460\n",
        "createdAt" : "2016-03-17T20:47:25Z",
        "updatedAt" : "2016-03-17T20:47:25Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "e00629e9-d8cc-4cf4-bd87-125ce2fcdf26",
        "parentId" : "e8d7d463-3e0b-49f7-991a-ad7e565e3e1e",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "and already being passed to strategic patch computation at https://github.com/kubernetes/kubernetes/pull/23145/files#diff-fe6dbe5fa548ea5c031a5be1669a6376R531 (which is why the normal, non-conflict case works in OpenShift today)\n",
        "createdAt" : "2016-03-17T20:49:31Z",
        "updatedAt" : "2016-03-17T20:49:55Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "0bbb484f-496d-47b0-868b-68e3267b5912",
        "parentId" : "e8d7d463-3e0b-49f7-991a-ad7e565e3e1e",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "OK, so CreateStrategicMergePatch only reads versionedObj, correct?\n",
        "createdAt" : "2016-03-18T17:57:23Z",
        "updatedAt" : "2016-03-18T17:57:23Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "c685d9f8-d324-4ccd-a0cf-c54acaf25b60",
        "parentId" : "e8d7d463-3e0b-49f7-991a-ad7e565e3e1e",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "CreateStrategicMergePatch requires objects with json tags, so it should only be given versioned objects, yes\n\nedit: oh, you're asking about read vs write... yes... it only reads the json tags off the passed-in struct\n",
        "createdAt" : "2016-03-18T18:09:04Z",
        "updatedAt" : "2016-03-18T18:09:39Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "c9acde2c-9035-4b34-a3a9-2eebf2842408",
        "parentId" : "e8d7d463-3e0b-49f7-991a-ad7e565e3e1e",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "OK. LGTM then.\n",
        "createdAt" : "2016-03-18T18:11:12Z",
        "updatedAt" : "2016-03-18T18:11:12Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      }
    ],
    "commit" : "ea8669661aa9f376e1a08ee77f65aa6ca452ed49",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +568,572 @@\t\t\t}\n\n\t\t\tcurrentPatch, err := strategicpatch.CreateStrategicMergePatch(originalObjJS, currentObjectJS, versionedObj)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err"
  },
  {
    "id" : "7d42ef44-c556-402f-b1e3-f61f05a9d263",
    "prId" : 21723,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f648ab62-c2b0-4fb9-8fc0-2e7d50e7a27a",
        "parentId" : null,
        "authorId" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "body" : "I can pass in the gvk as a input parameter to patchResource, but it seems a little redundant. Your call.\n",
        "createdAt" : "2016-02-23T01:15:33Z",
        "updatedAt" : "2016-02-23T01:15:33Z",
        "lastEditedBy" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "tags" : [
        ]
      },
      {
        "id" : "6f17f380-e70b-4f98-a28f-5ffaab451603",
        "parentId" : "f648ab62-c2b0-4fb9-8fc0-2e7d50e7a27a",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "Close enough :)\n",
        "createdAt" : "2016-02-23T23:08:15Z",
        "updatedAt" : "2016-02-23T23:08:15Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      }
    ],
    "commit" : "78fc311f1ff15b7f0d944a3c6a7c55f6e4ad0fab",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +590,594 @@\t\t\t}\n\t\t\tif hasConflicts {\n\t\t\t\tglog.V(4).Infof(\"patchResource failed for resource %s, becauase there is a meaningful conflict.\\n diff1=%v\\n, diff2=%v\\n\", name, diff1, diff2)\n\t\t\t\treturn updateObject, updateErr\n\t\t\t}"
  },
  {
    "id" : "7063fac3-9051-464b-80b9-879529664a6d",
    "prId" : 19481,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b0a3b772-cce7-4887-9630-3d1555451de9",
        "parentId" : null,
        "authorId" : "6eca0ade-9879-4dd7-ad14-547e16f5c041",
        "body" : ":100: \n\nI like this since it lets systems like quota remain ignorant of patch and just code against update.\n",
        "createdAt" : "2016-01-11T19:31:33Z",
        "updatedAt" : "2016-01-20T21:21:29Z",
        "lastEditedBy" : "6eca0ade-9879-4dd7-ad14-547e16f5c041",
        "tags" : [
        ]
      },
      {
        "id" : "b77462ff-56b0-4317-9935-c1d9daeed5c3",
        "parentId" : "b0a3b772-cce7-4887-9630-3d1555451de9",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "Why does update not take both old and new objects?\n",
        "createdAt" : "2016-01-19T20:55:43Z",
        "updatedAt" : "2016-01-20T21:21:29Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "ca95a23c-db25-4cec-b683-2db06f37022f",
        "parentId" : "b0a3b772-cce7-4887-9630-3d1555451de9",
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "> Why does update not take both old and new objects?\n\nThat was more than I wanted to tear off here.  This pull closes up an existing gap in admission logic.  Restructuring admission of updates is beyond what I wanted to do to close off the field level admission failures.\n",
        "createdAt" : "2016-01-19T21:01:42Z",
        "updatedAt" : "2016-01-20T21:21:29Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      }
    ],
    "commit" : "e90c2bd7dcf506dee91f30ea35b3c72f83a38fba",
    "line" : 30,
    "diffHunk" : "@@ -1,1 +492,496 @@\t\t\tif admit != nil && admit.Handles(admission.Update) {\n\t\t\t\tuserInfo, _ := api.UserFrom(ctx)\n\t\t\t\treturn admit.Admit(admission.NewAttributesRecord(updatedObject, scope.Kind.GroupKind(), namespace, name, scope.Resource.GroupResource(), scope.Subresource, admission.Update, userInfo))\n\t\t\t}\n"
  },
  {
    "id" : "fdc6b925-b836-47c9-8678-6f089264bfbe",
    "prId" : 19481,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fad91fa5-3bd6-463c-97c3-07fa160a541d",
        "parentId" : null,
        "authorId" : "6eca0ade-9879-4dd7-ad14-547e16f5c041",
        "body" : "not obvious to me on why this is here, can you give some background?\n",
        "createdAt" : "2016-01-11T19:34:11Z",
        "updatedAt" : "2016-01-20T21:21:29Z",
        "lastEditedBy" : "6eca0ade-9879-4dd7-ad14-547e16f5c041",
        "tags" : [
        ]
      },
      {
        "id" : "8dbb4be3-015f-4ed1-86e7-5a0a24e85857",
        "parentId" : "fad91fa5-3bd6-463c-97c3-07fa160a541d",
        "authorId" : "6eca0ade-9879-4dd7-ad14-547e16f5c041",
        "body" : "ah, so this is in case of error, just give a comment maybe\n",
        "createdAt" : "2016-01-11T19:35:03Z",
        "updatedAt" : "2016-01-20T21:21:29Z",
        "lastEditedBy" : "6eca0ade-9879-4dd7-ad14-547e16f5c041",
        "tags" : [
        ]
      }
    ],
    "commit" : "e90c2bd7dcf506dee91f30ea35b3c72f83a38fba",
    "line" : 67,
    "diffHunk" : "@@ -1,1 +601,605 @@\t\t\t}\n\n\t\t\tif err := admit(objToUpdate); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}"
  },
  {
    "id" : "6123a412-6706-4caa-a008-16c2b3e69561",
    "prId" : 17956,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ed01e633-4f78-4d96-a7df-15a3da7e4f6e",
        "parentId" : null,
        "authorId" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "body" : "Why do we need the internalKind, why can't we do it the old way, using scope.InternalVersion?\n",
        "createdAt" : "2015-12-01T18:59:19Z",
        "updatedAt" : "2015-12-01T21:50:28Z",
        "lastEditedBy" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "tags" : [
        ]
      },
      {
        "id" : "ba9a1dd1-bcd4-41e6-bf2e-b68bbbb4ba0d",
        "parentId" : "ed01e633-4f78-4d96-a7df-15a3da7e4f6e",
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "> Why do we need the internalKind, why can't we do it the old way, using scope.InternalVersion?\n\n`scope.InternalVersion` is the internal version of the object you're returning.  This method needs to have the internal version of your `getOptions`.  The two are always different except for the legacy kube group.\n",
        "createdAt" : "2015-12-01T19:08:49Z",
        "updatedAt" : "2015-12-01T21:50:28Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      }
    ],
    "commit" : "a7dd09ec47d6031a39d2090fc4cb10e13e44b995",
    "line" : 84,
    "diffHunk" : "@@ -1,1 +155,159 @@\t\treturn nil, errors.NewBadRequest(err.Error())\n\t}\n\tout, err := scope.Convertor.ConvertToVersion(versioned, internalKind.GroupVersion().String())\n\tif err != nil {\n\t\t// programmer error"
  },
  {
    "id" : "7c946894-733c-435d-addd-9cd915cc2ba4",
    "prId" : 17163,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "77b6d358-7ee3-4db8-86e3-8ee1598bb43f",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "Can we hold on using ServerAPIVersion in more places? I don't think it is correct to have multiple groups using \"v1\" types… \n",
        "createdAt" : "2015-11-20T00:15:03Z",
        "updatedAt" : "2015-11-20T00:15:03Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "4fa7e2bc-b87b-49cb-a99a-8138e05826e1",
        "parentId" : "77b6d358-7ee3-4db8-86e3-8ee1598bb43f",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "This one is just move from the other place in this file - I will keep that in mind when touching ServerAPIVersion again.\n",
        "createdAt" : "2015-11-20T07:15:57Z",
        "updatedAt" : "2015-11-20T07:15:57Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      },
      {
        "id" : "fcda2d5f-0bc3-4d23-a79d-9ef16f8eebab",
        "parentId" : "77b6d358-7ee3-4db8-86e3-8ee1598bb43f",
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "> Can we hold on using ServerAPIVersion in more places? I don't think it is correct to have multiple groups using \"v1\" types…\n\nI'd actually like to have an explicit dependency expressed upon the internal types accepted by the API.  That means plumbing down Sets of types (or group,version,kind), then using the scheme to see whether the incoming object can be coerced to the expected type.\n\n`ServerAPIVersion` isn't sufficient for the task and tends to operate a silent dependency on an external type.\n",
        "createdAt" : "2015-11-20T13:07:59Z",
        "updatedAt" : "2015-11-20T13:07:59Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      },
      {
        "id" : "689ad92e-61c4-4e04-92fe-59b76fffe61e",
        "parentId" : "77b6d358-7ee3-4db8-86e3-8ee1598bb43f",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "@deads2k I agree we need to not hard code stuff. But baby steps. This isn't making the problem worse.\n",
        "createdAt" : "2015-11-20T18:40:06Z",
        "updatedAt" : "2015-11-20T18:40:06Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      }
    ],
    "commit" : "d7b098b0e98277f6315e9a9ae7c46c3f95067566",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +148,152 @@\t\tquery = newQuery\n\t}\n\tversioned, err := scope.Creater.New(scope.ServerAPIVersion, kind)\n\tif err != nil {\n\t\t// programmer error"
  },
  {
    "id" : "cad89b40-99b2-4b3b-9ca0-a4979ba6c2e2",
    "prId" : 17163,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "983852da-6b33-4586-9272-4e121e54ac80",
        "parentId" : null,
        "authorId" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "body" : "Out of curiosity, why do we need to decode the query to a versioned object and then convert it to unversioned?\n",
        "createdAt" : "2015-11-20T01:44:04Z",
        "updatedAt" : "2015-11-20T01:44:04Z",
        "lastEditedBy" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "tags" : [
        ]
      },
      {
        "id" : "9f83ffba-9317-4357-a5a2-b6e0c35bf8ae",
        "parentId" : "983852da-6b33-4586-9272-4e121e54ac80",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "We are sending versioned object serialized into url params over the network. But internally we are looking internal version - this is how everything works, right?\n",
        "createdAt" : "2015-11-20T07:17:00Z",
        "updatedAt" : "2015-11-20T07:17:00Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      },
      {
        "id" : "c19811ba-78ce-4ec1-b450-e22cdcd66a0c",
        "parentId" : "983852da-6b33-4586-9272-4e121e54ac80",
        "authorId" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "body" : "Sure. Sorry my question is not clear. I'm thinking because `DecodeParametersInto` bears a similar name as `DecodeInto`, which is capable of doing the deserialization and conversion in one step, why can't we make `DecodeParametersInto` doing that, too?\n\nI recall there is a discussion on that Codec should only do deserialization and convertor should be explicitly called to do the conversion. Is that why you are doing desserialization and conversion here?\n",
        "createdAt" : "2015-11-20T18:34:37Z",
        "updatedAt" : "2015-11-20T18:34:37Z",
        "lastEditedBy" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "tags" : [
        ]
      },
      {
        "id" : "aecbc4b2-ba7e-4e01-be7a-c838a8cea680",
        "parentId" : "983852da-6b33-4586-9272-4e121e54ac80",
        "authorId" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "body" : "I see the code is copied from queryToObject. I'll take a look if it's necessary to deserialize to the ServerVersion first.\n",
        "createdAt" : "2015-11-20T18:37:34Z",
        "updatedAt" : "2015-11-20T18:37:34Z",
        "lastEditedBy" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "tags" : [
        ]
      },
      {
        "id" : "10807608-272a-424b-9d49-cc3a7181d4d5",
        "parentId" : "983852da-6b33-4586-9272-4e121e54ac80",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "I think `[]byte` data passed into DecodeInto is required to have kind/apiVersion info embedded that allows the codec to know what conversions need to be done in order to get the data into the passed object. Query parameter data does not have that identifying info, which is why this is decoding into a versioned object (though I'd argue ServerVersion is the wrong version) then doing a conversion into an internal (or eventually unversioned?) object itself\n",
        "createdAt" : "2015-11-20T18:39:46Z",
        "updatedAt" : "2015-11-20T18:39:46Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "b4afe085-d55a-4761-84db-dbb677a4199e",
        "parentId" : "983852da-6b33-4586-9272-4e121e54ac80",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "IMO, it is correct to do the deserialization and conversion separately. This is because the conversion is to a format that the _infrastructure_ needs; therefore that logic should be locate with the infrastructure. We should continue to mutate things until the _versioned_ object is passed into the REST.List() method (if it's not already). If we do deserialization and conversion at the same time, then we'll have to do _two_ deserializations, one for the infrastructure code and one for the strategy code.\n",
        "createdAt" : "2015-11-20T18:43:21Z",
        "updatedAt" : "2015-11-20T18:43:21Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "73b658ff-3796-40f6-a4c1-056636ae2907",
        "parentId" : "983852da-6b33-4586-9272-4e121e54ac80",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "Yes, also, as @liggitt says, query parameters do _not_ contain their own type and therefore can't be auto-converted.\n",
        "createdAt" : "2015-11-20T18:45:18Z",
        "updatedAt" : "2015-11-20T18:45:18Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "a1e2fdf3-2436-461a-a8a6-e686624f37dc",
        "parentId" : "983852da-6b33-4586-9272-4e121e54ac80",
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "> Yes, also, as @liggitt says, query parameters do not contain their own type and therefore can't be auto-converted.\n\nBut at some point we should probably be able to encode those so that different API groups can do something reasonable with them instead of just asking \"are you my mother?\" to every possible target.\n",
        "createdAt" : "2015-11-20T18:50:44Z",
        "updatedAt" : "2015-11-20T18:50:44Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      },
      {
        "id" : "bed0d533-00d0-49a8-a572-019d93451e08",
        "parentId" : "983852da-6b33-4586-9272-4e121e54ac80",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "We do not ask that, at least not in the server. We should have a `NewOptions() runtime.Object` method in the list strategy object.\n\n(The client does that sort of thing, which I agree is totally broken.)\n",
        "createdAt" : "2015-11-20T18:53:09Z",
        "updatedAt" : "2015-11-20T18:53:09Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      }
    ],
    "commit" : "d7b098b0e98277f6315e9a9ae7c46c3f95067566",
    "line" : 10,
    "diffHunk" : "@@ -1,1 +153,157 @@\t\treturn nil, err\n\t}\n\tif err := scope.Codec.DecodeParametersInto(query, versioned); err != nil {\n\t\treturn nil, errors.NewBadRequest(err.Error())\n\t}"
  },
  {
    "id" : "e41e120e-781b-4e69-94a1-b6eee48fb3bd",
    "prId" : 14874,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "31bee95e-6c2d-4b2f-80cd-a7a6845d8b3a",
        "parentId" : null,
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "Effectively this is broken if people send anything other than UTF-8. Should we check? Maybe just add a TODO?\n",
        "createdAt" : "2015-10-01T20:26:05Z",
        "updatedAt" : "2015-10-01T20:26:05Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "7fcf2312-59fd-405b-8a1d-a29c1fd098bf",
        "parentId" : "31bee95e-6c2d-4b2f-80cd-a7a6845d8b3a",
        "authorId" : "625aa63f-7185-453c-9db6-330c20486b28",
        "body" : "I think if anything a TODO would be fine. Do you want me to add one before it gets merged, or leave it for now?\n",
        "createdAt" : "2015-10-02T00:12:04Z",
        "updatedAt" : "2015-10-02T00:12:04Z",
        "lastEditedBy" : "625aa63f-7185-453c-9db6-330c20486b28",
        "tags" : [
        ]
      },
      {
        "id" : "619e2c84-58d8-4c84-a7c7-f9cf9f779c4d",
        "parentId" : "31bee95e-6c2d-4b2f-80cd-a7a6845d8b3a",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "I guess we can leave it for now, since it merged :)\n\nOn Thu, Oct 1, 2015 at 5:12 PM, Derek Parker notifications@github.com\nwrote:\n\n> In pkg/apiserver/resthandler.go\n> https://github.com/kubernetes/kubernetes/pull/14874#discussion_r40981753\n> :\n> \n> > @@ -736,6 +737,10 @@ func setListSelfLink(obj runtime.Object, req *restful.Request, namer ScopeNamer)\n> >  }\n> > \n> >  func getPatchedJS(contentType string, originalJS, patchJS []byte, obj runtime.Object) ([]byte, error) {\n> > -   // Remove \"; charset=\" if included in header.\n> \n> I think if anything a TODO would be fine. Do you want me to add one before\n> it gets merged, or leave it for now?\n> \n> —\n> Reply to this email directly or view it on GitHub\n> https://github.com/kubernetes/kubernetes/pull/14874/files#r40981753.\n",
        "createdAt" : "2015-10-02T17:00:33Z",
        "updatedAt" : "2015-10-02T17:00:33Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      }
    ],
    "commit" : "4745cc9d9afbebf74320fb1ebc2aa820774bd4d7",
    "line" : 12,
    "diffHunk" : "@@ -1,1 +738,742 @@\nfunc getPatchedJS(contentType string, originalJS, patchJS []byte, obj runtime.Object) ([]byte, error) {\n\t// Remove \"; charset=\" if included in header.\n\tif idx := strings.Index(contentType, \";\"); idx > 0 {\n\t\tcontentType = contentType[:idx]"
  },
  {
    "id" : "cdee769b-bcfb-452d-a50c-98edb33aa2e2",
    "prId" : 14758,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fe2a7ddf-1d01-44a9-9ab1-4126d0b3d571",
        "parentId" : null,
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "I just realized this can be done outside of the loop, but I don't think it's worth asking you for another change.\n",
        "createdAt" : "2015-10-02T17:36:00Z",
        "updatedAt" : "2015-10-05T18:38:02Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      }
    ],
    "commit" : "05e84fafbe5418b2c54f665229cbb32771a602e4",
    "line" : 134,
    "diffHunk" : "@@ -1,1 +484,488 @@\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\toriginalPatch, err := strategicpatch.CreateStrategicMergePatch(originalObjJS, originalPatchedObjJS, patcher.New())\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err"
  },
  {
    "id" : "6edc4e13-8ba6-4e61-9926-de719c0f1843",
    "prId" : 6027,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7bbea3f1-47c7-4f92-bad2-6d8d40a05cfc",
        "parentId" : null,
        "authorId" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "body" : "This should take `contentType PatchType` and switch on PatchType e.g.\n\n```\nswitch {\ncase JSONPatchType:\n...\n```\n",
        "createdAt" : "2015-03-27T00:42:30Z",
        "updatedAt" : "2015-04-03T18:51:04Z",
        "lastEditedBy" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "tags" : [
        ]
      },
      {
        "id" : "2598dbab-aed6-4cbf-9f50-ba03362a5c01",
        "parentId" : "7bbea3f1-47c7-4f92-bad2-6d8d40a05cfc",
        "authorId" : "f22a9095-b804-4932-8c62-ecb134b86477",
        "body" : "I agree with the abstraction but it makes deciding where to put PatchType a little more difficult. If PatchType stays in the client, it probably is weird for resthandler to reference the client package to do its work. But if PatchType moves to the server, the client has to reference internal server details to construct a request. Hmm...\n",
        "createdAt" : "2015-03-27T21:10:41Z",
        "updatedAt" : "2015-04-03T18:51:04Z",
        "lastEditedBy" : "f22a9095-b804-4932-8c62-ecb134b86477",
        "tags" : [
        ]
      },
      {
        "id" : "5d54e951-3922-45b8-bdc6-792d845c9589",
        "parentId" : "7bbea3f1-47c7-4f92-bad2-6d8d40a05cfc",
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "Our current code organization has a lot of problems. Comment on #4851 if you have ideas. Code needed by the client and server should be factored out into a common/shared package.\n",
        "createdAt" : "2015-04-01T22:20:52Z",
        "updatedAt" : "2015-04-03T18:51:04Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      }
    ],
    "commit" : "2c977db1b3af70fd60e0d111e6b6ac9dfe80e0ff",
    "line" : 90,
    "diffHunk" : "@@ -1,1 +565,569 @@}\n\nfunc getPatchedJS(contentType string, originalJS, patchJS []byte, obj runtime.Object) ([]byte, error) {\n\tpatchType := api.PatchType(contentType)\n\tswitch patchType {"
  },
  {
    "id" : "2f3ef012-aba3-4254-9182-b3f202d192ef",
    "prId" : 5763,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "43f8b1ce-8874-45ab-bce7-8aba85b31745",
        "parentId" : null,
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "We're working on making all such errors more specific. Is the field selector included in the error message at least?\n",
        "createdAt" : "2015-03-25T02:01:45Z",
        "updatedAt" : "2015-03-27T19:04:23Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "a18d3c7b-98a5-427c-9674-284828f1f7ad",
        "parentId" : "43f8b1ce-8874-45ab-bce7-8aba85b31745",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "This error should never occur, unless a programming error has been made (no conversion registered for a particular field label).\n\n----- Original Message -----\n\n> > ```\n> >     if err != nil {\n> > ```\n> > -           errorJSON(err, codec, w)\n> > -           errorJSON(err, scope.Codec, w)\n> > -           return\n> > -       }\n> > -       opts := _out.(_api.ListOptions)\n> >   +\n> > -       // transform fields\n> > -       fn := func(label, value string) (newLabel, newValue string, err error) {\n> > -           return scope.Convertor.ConvertFieldLabel(scope.APIVersion, scope.Kind,\n> >   label, value)\n> > -       }\n> > -       if opts.FieldSelector, err = opts.FieldSelector.Transform(fn); err !=\n> >   nil {\n> > -           // TODO: allow bad request to set field causes based on query\n> >   parameters\n> > -           err = errors.NewBadRequest(err.Error())\n> \n> We're working on making all such errors more specific. Is the field selector\n> included in the error message at least?\n> \n> ---\n> \n> Reply to this email directly or view it on GitHub:\n> https://github.com/GoogleCloudPlatform/kubernetes/pull/5763/files#r27090151\n",
        "createdAt" : "2015-03-25T20:58:30Z",
        "updatedAt" : "2015-03-27T19:04:23Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      }
    ],
    "commit" : "870da687d0c2477dc7be1c659a379cfa35a2e850",
    "line" : 71,
    "diffHunk" : "@@ -1,1 +125,129 @@\t\tif opts.FieldSelector, err = opts.FieldSelector.Transform(fn); err != nil {\n\t\t\t// TODO: allow bad request to set field causes based on query parameters\n\t\t\terr = errors.NewBadRequest(err.Error())\n\t\t\terrorJSON(err, scope.Codec, w)\n\t\t\treturn"
  },
  {
    "id" : "89c3becc-3d25-48a4-a48f-234bcc5dfc10",
    "prId" : 5085,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "65ca0a66-dc49-4104-9ff7-a0a6d4619c6d",
        "parentId" : null,
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "It might make sense to create options if none were provided and then run them through the defaulting pass. Otherwise, code all over will presumably need to reason about default behavior in the absence of options.\n",
        "createdAt" : "2015-03-19T00:48:18Z",
        "updatedAt" : "2015-03-19T19:33:39Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "d9bd56b5-9d65-4718-a775-5d5255435d53",
        "parentId" : "65ca0a66-dc49-4104-9ff7-a0a6d4619c6d",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "This is partially to distinguish between old behavior and new behavior (nil to rest storage means old behavior, ie delete immediately).  That might not be required anymore, but a few places pass nil to a storage object instead of each spot trying to load it's own default.  Agree it's non-obvious as is.\n\n> On Mar 18, 2015, at 8:48 PM, Brian Grant notifications@github.com wrote:\n> \n> In pkg/apiserver/resthandler.go:\n> \n> > @@ -347,6 +347,21 @@ func DeleteResource(r RESTDeleter, ctxFn ContextFunc, namer ScopeNamer, codec ru\n> >             ctx = api.WithNamespace(ctx, namespace)\n> >         }\n> > -       options := &api.DeleteOptions{}\n> > -       if checkBody {\n> > -           body, err := readBody(req.Request)\n> > -           if err != nil {\n> > -               errorJSON(err, codec, w)\n> > -               return\n> > -           }\n> > -           if len(body) > 0 {\n> >   It might make sense to create options if none were provided and then run them through the defaulting pass. Otherwise, code all over will presumably need to reason about default behavior in the absence of options.\n> \n> —\n> Reply to this email directly or view it on GitHub.\n",
        "createdAt" : "2015-03-19T03:40:41Z",
        "updatedAt" : "2015-03-19T19:33:39Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "74b707b1-b326-46d7-8362-5e196c7f6b6a",
        "parentId" : "65ca0a66-dc49-4104-9ff7-a0a6d4619c6d",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "I'd like to preserve the nil behavior and then potentially remove support in the future.  It's not out of place in our codebase for nil to mean something different than passing an initialized DeleteOptions(0), and once we have a few implementations graceful delete I'll feel more comfortable about removing the old callers of Delete(2)\n",
        "createdAt" : "2015-03-19T14:50:39Z",
        "updatedAt" : "2015-03-19T19:33:39Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      }
    ],
    "commit" : "428d2263e5966e830ce9c1172b48da05d8ce0e44",
    "line" : 20,
    "diffHunk" : "@@ -1,1 +355,359 @@\t\t\t\treturn\n\t\t\t}\n\t\t\tif len(body) > 0 {\n\t\t\t\tif err := codec.DecodeInto(body, options); err != nil {\n\t\t\t\t\terrorJSON(err, codec, w)"
  },
  {
    "id" : "db9a4669-ed75-472c-a03b-45befd4444c4",
    "prId" : 4706,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "96332b76-e808-405b-937b-36dc51257634",
        "parentId" : null,
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "This results in two successive reads that are not controlled by the resource version, which I think is wrong.  The client has to be able to specify which version to check against.  So there's at least a check missing here for the input version against the get version.\n\nI'm mentally debating whether passing a structured type down into Update would be more appropriate (delta, with attached api version).  Even a generic patch resource being passed down would work.  I mildly dislike reading here then reading again on update - I'd prefer to do it exactly once, in the storage.  That's something we could fix later, but it still seems messy.\n",
        "createdAt" : "2015-02-23T02:18:40Z",
        "updatedAt" : "2015-03-10T17:57:26Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "71eda901-a3e2-404c-89dd-666ba8bcfb0a",
        "parentId" : "96332b76-e808-405b-937b-36dc51257634",
        "authorId" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "body" : "Makes sense. We could validate that the client passes a resource version in their patch. The intent was to add PATCH without needing to add an extra Patch method to the registry's RESTs. What's the reason that the registry does a get from etcd after update?\n",
        "createdAt" : "2015-02-23T04:37:33Z",
        "updatedAt" : "2015-03-10T17:57:26Z",
        "lastEditedBy" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "tags" : [
        ]
      },
      {
        "id" : "ba46a8da-ccbb-401e-a931-036c94f3218c",
        "parentId" : "96332b76-e808-405b-937b-36dc51257634",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "----- Original Message -----\n\n> > +func PatchResource(r RESTPatcher, ctxFn ContextFunc, namer ScopeNamer,\n> > codec runtime.Codec, resource string, admit admission.Interface)\n> > restful.RouteFunction {\n> > -   return func(req *restful.Request, res *restful.Response) {\n> > -       w := res.ResponseWriter\n> >   +\n> > -       // TODO: we either want to remove timeout or document it (if we\n> >   document, move timeout out of this function and declare it in\n> >   api_installer)\n> > -       timeout := parseTimeout(req.Request.URL.Query().Get(\"timeout\"))\n> >   +\n> > -       namespace, name, err := namer.Name(req)\n> > -       if err != nil {\n> > -           notFound(w, req.Request)\n> > -           return\n> > -       }\n> > -       ctx := ctxFn(req)\n> > -       ctx = api.WithNamespace(ctx, namespace)\n> >   +\n> > -       original, err := r.Get(ctx, name)\n> \n> Makes sense. We could validate that the client passes a resource version in\n> their patch. The intent was to add PATCH without needing to add an extra\n> Patch method to the registry's RESTs. What's the reason that the registry\n> does a get from etcd after update?\n\nGet before update - it's so that we know that what is stored so we can do a CAS.  In the pod changes I made the REST logic happen between the initial get and the CAS, so that you had the existing state to compare to.  There's a problem there which is merging - when we merge what the server has with the client's input, we have to make the decision at that time about what to preserve (that's why pod/status was going to exist, so it could have a different decision).  Right now we throw away the status section and combine it with the spec (so that users who naively GET -> PUT overwrite don't overwrite status).  If we didn't do that, all clients would have to do merges correctly (which they aren't) and some users _should_ be prevented from changing status like pod.status.host, which they aren't today.  Admission control probably would be better to run given both the old and the new value as well, and being able to calculate exact deltas for authorization is a nice to have.\n\nLet's slate a time to sit down and go through all the edge cases here - I like the approach, it just highlights how we're not doing everything right for Update today.\n\n> ---\n> \n> Reply to this email directly or view it on GitHub:\n> https://github.com/GoogleCloudPlatform/kubernetes/pull/4706/files#r25143674\n",
        "createdAt" : "2015-02-23T15:07:12Z",
        "updatedAt" : "2015-03-10T17:57:26Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "1a36a05e-1717-4589-b5fa-fd8e4002ba6f",
        "parentId" : "96332b76-e808-405b-937b-36dc51257634",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "Agree with @smarterclayton. There's probably some refactoring of Update in which we pass in a function that takes the old object with status removed etc and merges the new object, such that both PATCH and PUT could produce such a function.\n",
        "createdAt" : "2015-02-23T21:30:02Z",
        "updatedAt" : "2015-03-10T17:57:26Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "80a231be-27bb-43d1-830a-493cd13f19a6",
        "parentId" : "96332b76-e808-405b-937b-36dc51257634",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Yeah - same thought here.  We needed that on client update as well (the way merge is handled is ugly right now).\n\n> On Feb 23, 2015, at 4:30 PM, Daniel Smith notifications@github.com wrote:\n> \n> In pkg/apiserver/resthandler.go:\n> \n> > +func PatchResource(r RESTPatcher, ctxFn ContextFunc, namer ScopeNamer, codec runtime.Codec, resource string, admit admission.Interface) restful.RouteFunction {\n> > -   return func(req *restful.Request, res *restful.Response) {\n> > -       w := res.ResponseWriter\n> >   +\n> > -       // TODO: we either want to remove timeout or document it (if we document, move timeout out of this function and declare it in api_installer)\n> > -       timeout := parseTimeout(req.Request.URL.Query().Get(\"timeout\"))\n> >   +\n> > -       namespace, name, err := namer.Name(req)\n> > -       if err != nil {\n> > -           notFound(w, req.Request)\n> > -           return\n> > -       }\n> > -       ctx := ctxFn(req)\n> > -       ctx = api.WithNamespace(ctx, namespace)\n> >   +\n> > -       original, err := r.Get(ctx, name)\n> >   Agree with @smarterclayton. There's probably some refactoring of Update in which we pass in a function that takes the old object with status removed etc and merges the new object, such that both PATCH and PUT could produce such a function.\n> \n> —\n> Reply to this email directly or view it on GitHub.\n",
        "createdAt" : "2015-02-23T21:45:55Z",
        "updatedAt" : "2015-03-10T17:57:26Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "8eca2710-b87d-47f6-a7f4-78eeeeaa2acc",
        "parentId" : "96332b76-e808-405b-937b-36dc51257634",
        "authorId" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "body" : "@lavalamp The only issue with that is only a few Update implementations do reads before update. RESTs that use AtomicUpdate do read and most that use SetObj do not read. It might be nice to standardize on an Update mechanism that could skip the initial read when unnecessary.\n",
        "createdAt" : "2015-03-01T19:08:32Z",
        "updatedAt" : "2015-03-10T17:57:26Z",
        "lastEditedBy" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "tags" : [
        ]
      },
      {
        "id" : "1d269abe-4454-40c5-a86c-4b8dc2ce9aa7",
        "parentId" : "96332b76-e808-405b-937b-36dc51257634",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "My next set of changes to update will make implementing patch under AtomicUpdate feasible.  For now, that doesn't need to block this change.  We should leave a todo here to that effect.\n\n> On Mar 1, 2015, at 2:08 PM, Mike Danese notifications@github.com wrote:\n> \n> In pkg/apiserver/resthandler.go:\n> \n> > +func PatchResource(r RESTPatcher, ctxFn ContextFunc, namer ScopeNamer, codec runtime.Codec, resource string, admit admission.Interface) restful.RouteFunction {\n> > -   return func(req *restful.Request, res *restful.Response) {\n> > -       w := res.ResponseWriter\n> >   +\n> > -       // TODO: we either want to remove timeout or document it (if we document, move timeout out of this function and declare it in api_installer)\n> > -       timeout := parseTimeout(req.Request.URL.Query().Get(\"timeout\"))\n> >   +\n> > -       namespace, name, err := namer.Name(req)\n> > -       if err != nil {\n> > -           notFound(w, req.Request)\n> > -           return\n> > -       }\n> > -       ctx := ctxFn(req)\n> > -       ctx = api.WithNamespace(ctx, namespace)\n> >   +\n> > -       original, err := r.Get(ctx, name)\n> >   @lavalamp The only issue with that is only a few Update implementations do reads before update. RESTs that use AtomicUpdate do read and most that use SetObj do not read. It might be nice to standardize on an Update mechanism that could skip the initial read when unnecessary.\n> \n> —\n> Reply to this email directly or view it on GitHub.\n",
        "createdAt" : "2015-03-01T20:32:54Z",
        "updatedAt" : "2015-03-10T17:57:26Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      }
    ],
    "commit" : "46ec5807719d901a0f5b716fdbf674b93d18a676",
    "line" : null,
    "diffHunk" : "@@ -1,1 +214,218 @@\t\tctx = api.WithNamespace(ctx, namespace)\n\n\t\toriginal, err := r.Get(ctx, name)\n\t\tif err != nil {\n\t\t\terrorJSON(err, codec, w)"
  },
  {
    "id" : "f360b368-6f6b-4d39-8444-871179c71d68",
    "prId" : 4395,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f49b3958-a8e7-4059-9751-11640aaa9607",
        "parentId" : null,
        "authorId" : "c2b5c827-efcd-438f-8db5-52d917b1cde9",
        "body" : "Exported types need documentation. Each of the exported methods in the interface do as well. \n",
        "createdAt" : "2015-02-12T21:12:37Z",
        "updatedAt" : "2015-02-16T21:31:38Z",
        "lastEditedBy" : "c2b5c827-efcd-438f-8db5-52d917b1cde9",
        "tags" : [
        ]
      }
    ],
    "commit" : "eebe00c25950b79328cc574905a1ead761315e94",
    "line" : 33,
    "diffHunk" : "@@ -1,1 +36,40 @@\n// ScopeNamer handles accessing names from requests and objects\ntype ScopeNamer interface {\n\t// Namespace returns the appropriate namespace value from the request (may be empty) or an\n\t// error."
  },
  {
    "id" : "8f322a16-8a8e-4e0b-bcff-20d92bff086a",
    "prId" : 3707,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "af454104-d1b4-4960-a40f-65c8be882f30",
        "parentId" : null,
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Wouldn't it just be easier to remove operation completely, and replace it with the code from op.WaitFor with a simple timeout?  We already have the http level max client timeout on the server, and I'd like to remove the extra locking operations on Operations and the two go routines it creates.\n",
        "createdAt" : "2015-01-27T01:45:30Z",
        "updatedAt" : "2015-01-28T02:48:15Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "60702b5e-e30e-405d-8ebb-d77f464adaa6",
        "parentId" : "af454104-d1b4-4960-a40f-65c8be882f30",
        "authorId" : "f2369046-26b1-4b8c-a8cd-5671ab22066c",
        "body" : "I am trying to break this into multiple small manageable changes.\nThis PR is to make all operations synchronous and hence never return operations to users.\nThen, in next PR, we can delete the /operations endpoint.\nOnce these 2 are submitted, we can delete operations all together in a final PR.\n\nDoes that sound good or do you think its better to do it all at once?\n",
        "createdAt" : "2015-01-27T18:52:25Z",
        "updatedAt" : "2015-01-28T02:48:15Z",
        "lastEditedBy" : "f2369046-26b1-4b8c-a8cd-5671ab22066c",
        "tags" : [
        ]
      },
      {
        "id" : "be4b683a-1e30-4f68-a8de-2487f131dc9d",
        "parentId" : "af454104-d1b4-4960-a40f-65c8be882f30",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "That's fine - I just wasn't sure what the plan was.\n\n----- Original Message -----\n\n> > ```\n> > op := h.ops.NewOperation(out, onReceive)\n> > ```\n> > -   if sync {\n> > -       op.WaitFor(timeout)\n> > -   } else if h.asyncOpWait != 0 {\n> > -       op.WaitFor(h.asyncOpWait)\n> > -   }\n> > -   op.WaitFor(timeout)\n> \n> I am trying to break this into multiple small manageable changes.\n> This PR is to make all operations synchronous and hence never return\n> operations to users.\n> Then, in next PR, we can delete the /operations endpoint.\n> Once these 2 are submitted, we can delete operations all together in a final\n> PR.\n> \n> Does that sound good or do you think its better to do it all at once?\n> \n> ---\n> \n> Reply to this email directly or view it on GitHub:\n> https://github.com/GoogleCloudPlatform/kubernetes/pull/3707/files#r23631838\n",
        "createdAt" : "2015-01-27T18:53:47Z",
        "updatedAt" : "2015-01-28T02:48:15Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      }
    ],
    "commit" : "de606006087e805c72c1de7e52435fbd3dd4811c",
    "line" : 62,
    "diffHunk" : "@@ -1,1 +309,313 @@func (h *RESTHandler) createOperation(out <-chan RESTResult, timeout time.Duration, onReceive func(RESTResult)) *Operation {\n\top := h.ops.NewOperation(out, onReceive)\n\top.WaitFor(timeout)\n\treturn op\n}"
  },
  {
    "id" : "d7f69998-1180-486b-a083-2b81ae72116b",
    "prId" : 3707,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0d49f655-c7ae-4a2d-a841-53c81dd32ab1",
        "parentId" : null,
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "Please add a TODO to document the timeout parameter.\n",
        "createdAt" : "2015-01-27T19:30:09Z",
        "updatedAt" : "2015-01-28T02:48:15Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "9dabf14d-4c09-4d95-8b0f-cc65cd84bc75",
        "parentId" : "0d49f655-c7ae-4a2d-a841-53c81dd32ab1",
        "authorId" : "f2369046-26b1-4b8c-a8cd-5671ab22066c",
        "body" : "Done.\n",
        "createdAt" : "2015-01-28T02:48:22Z",
        "updatedAt" : "2015-01-28T02:48:22Z",
        "lastEditedBy" : "f2369046-26b1-4b8c-a8cd-5671ab22066c",
        "tags" : [
        ]
      }
    ],
    "commit" : "de606006087e805c72c1de7e52435fbd3dd4811c",
    "line" : null,
    "diffHunk" : "@@ -1,1 +149,153 @@\tctx := api.WithNamespace(api.NewContext(), namespace)\n\t// TODO: Document the timeout query parameter.\n\ttimeout := parseTimeout(req.URL.Query().Get(\"timeout\"))\n\tswitch req.Method {\n\tcase \"GET\":"
  },
  {
    "id" : "91343c10-fe46-4295-a6ae-1605ef05bea5",
    "prId" : 2813,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d81d1e79-dac6-475c-8b3e-8c89e7c694ae",
        "parentId" : null,
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "Hm-- is there an easy way to avoid using the query param? would be great to switch to the /ns/blah format. Maybe add a TODO if you want to leave for another PR?\n",
        "createdAt" : "2014-12-10T21:46:27Z",
        "updatedAt" : "2014-12-18T20:27:39Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "9bcae3bf-7ef0-4e0a-9000-d78d60e47ac4",
        "parentId" : "d81d1e79-dac6-475c-8b3e-8c89e7c694ae",
        "authorId" : "6eca0ade-9879-4dd7-ad14-547e16f5c041",
        "body" : "I was maintaining the query param more for backwards compatibility.\n\nSo if your incoming request was of the form:\n\n/pods/foo?namespace=bar\n\nYour selfLink would continue to be as you initially requested it.\n\nI thought about changing how `newURL.Path` was constructed, but the produced code was more complicated versus keeping it consistent with how the request came in.\n",
        "createdAt" : "2014-12-10T21:51:49Z",
        "updatedAt" : "2014-12-18T20:27:39Z",
        "lastEditedBy" : "6eca0ade-9879-4dd7-ad14-547e16f5c041",
        "tags" : [
        ]
      },
      {
        "id" : "95228ba7-9dac-47c0-9d80-f086e34ea895",
        "parentId" : "d81d1e79-dac6-475c-8b3e-8c89e7c694ae",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "Hm, that's a good point, but-- I think we would eventually like to stop supporting the ?namespace= form, and as a step in that process we should (eventually) canonicalize the path here. So perhaps it would be good to leave a TODO.\n",
        "createdAt" : "2014-12-10T22:01:11Z",
        "updatedAt" : "2014-12-18T20:27:39Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      }
    ],
    "commit" : "cbbe61d115011acd2cf428e8ee170a7e40010fa0",
    "line" : 31,
    "diffHunk" : "@@ -1,1 +68,72 @@\t}\n\n\t// we need to add namespace as a query param, if its not in the resource path\n\tif len(namespace) > 0 {\n\t\tparts := splitPath(req.URL.Path)"
  },
  {
    "id" : "7869b580-2c53-43bc-b6b0-08ef7876a329",
    "prId" : 2568,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2dd2bf8c-1ef7-4dea-83d0-35360bc5d91a",
        "parentId" : null,
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "Must be in setSelfLink, too.\n",
        "createdAt" : "2014-11-24T19:24:45Z",
        "updatedAt" : "2014-12-05T22:37:23Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "c2cb44e9-32c3-4423-8ad7-03eebd46a717",
        "parentId" : "2dd2bf8c-1ef7-4dea-83d0-35360bc5d91a",
        "authorId" : "6eca0ade-9879-4dd7-ad14-547e16f5c041",
        "body" : "Good catch, was looking at the items in a list and not the list itself.  Will add.\n",
        "createdAt" : "2014-11-24T19:38:28Z",
        "updatedAt" : "2014-12-05T22:37:23Z",
        "lastEditedBy" : "6eca0ade-9879-4dd7-ad14-547e16f5c041",
        "tags" : [
        ]
      }
    ],
    "commit" : "ef25520baa736ae7ec2afbd19bb7dfb17a1be164",
    "line" : 32,
    "diffHunk" : "@@ -1,1 +109,113 @@\tnewURL.Fragment = \"\"\n\t// TODO Remove this when namespace is in path\n\tif len(namespace) > 0 {\n\t\tquery := newURL.Query()\n\t\tquery.Set(\"namespace\", namespace)"
  },
  {
    "id" : "42d7f2c0-8eb9-47c6-835e-52da55088dc5",
    "prId" : 1564,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "73f87ad2-0bec-4595-a878-fce52f9530bd",
        "parentId" : null,
        "authorId" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "body" : "I think it will seem odd for the \"average\" user that normal GET and POST operate only on one namespace, but list and watch can operate on all namespaces.  The things that need to list/watch all objects are special cases like controllers.  I wonder if we should put the burden on those special cases to explicitly say they want to see all namespaces. \n\nTo that end, what if namespace is required to be specified for list and watch, but you can optionally specify \"__ALL\" in the namespace parameter to match all namespaces?  What do you think?\n\nAlso thinking about the three different types of \"default\" namespaces and whether those should have their own special identifiers.\n",
        "createdAt" : "2014-10-06T18:11:04Z",
        "updatedAt" : "2014-10-16T17:06:32Z",
        "lastEditedBy" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "tags" : [
        ]
      },
      {
        "id" : "d8c06d41-03a2-449f-b0f4-47c68973209d",
        "parentId" : "73f87ad2-0bec-4595-a878-fce52f9530bd",
        "authorId" : "6eca0ade-9879-4dd7-ad14-547e16f5c041",
        "body" : "My take on this is its less of a concern when we move away from the query parameter and instead namespace is in the resource path.\n",
        "createdAt" : "2014-10-06T18:14:09Z",
        "updatedAt" : "2014-10-16T17:06:32Z",
        "lastEditedBy" : "6eca0ade-9879-4dd7-ad14-547e16f5c041",
        "tags" : [
        ]
      }
    ],
    "commit" : "085ca40291dc5d40f8e9fccb83352fc6226fdf4f",
    "line" : null,
    "diffHunk" : "@@ -1,1 +106,110 @@\t// TODO for now, we pull namespace from query parameter, but according to spec, it must go in resource path in future PR\n\t// if a namespace if specified, it's always used.\n\t// for list/watch operations, a namespace is not required if omitted.\n\t// for all other operations, if namespace is omitted, we will default to default namespace.\n\tnamespace := req.URL.Query().Get(\"namespace\")"
  }
]
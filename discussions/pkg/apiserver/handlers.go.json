[
  {
    "id" : "2ac6919c-1ca3-4a2b-ad00-da1a2e8f93c0",
    "prId" : 33164,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/33164#pullrequestreview-937764",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bd54c00c-b094-4034-a523-659b418546e4",
        "parentId" : null,
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "If a == nil, let's be friendly, skip adding this, and glog a warning.\n",
        "createdAt" : "2016-09-21T12:12:40Z",
        "updatedAt" : "2016-09-23T10:08:36Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      },
      {
        "id" : "e7a90bc5-a721-4d43-bde4-4a4f1370ecc4",
        "parentId" : "bd54c00c-b094-4034-a523-659b418546e4",
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "Most filters just return the passed handler when the parameters are nil. Will do the same here.\n",
        "createdAt" : "2016-09-21T12:16:40Z",
        "updatedAt" : "2016-09-23T10:08:36Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      }
    ],
    "commit" : "87356c0623cd759df5879dc753c8a885bce4ef64",
    "line" : 355,
    "diffHunk" : "@@ -1,1 +150,154 @@\n// WithAuthorizationCheck passes all authorized requests on to handler, and returns a forbidden error otherwise.\nfunc WithAuthorization(handler http.Handler, getAttribs RequestAttributeGetter, a authorizer.Authorizer) http.Handler {\n\tif a == nil {\n\t\tglog.Warningf(\"Authorization is disabled\")"
  },
  {
    "id" : "4385517d-fcfb-4d98-8e86-04a5a9fab814",
    "prId" : 32786,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/32786#pullrequestreview-217729",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "59332d37-95b0-4414-9a46-7974f34e92b0",
        "parentId" : null,
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "This protects against 304's and is probably fine.\n\nI was hoping to not log on _any_ response that's just being echoed by our proxy, though. Which is harder.:(\n",
        "createdAt" : "2016-09-15T17:45:42Z",
        "updatedAt" : "2016-09-15T17:45:42Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      }
    ],
    "commit" : "b97b685b96a5e55fd7764e4e0849822640f0912b",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +153,157 @@\t\t\t\thttp.StatusUnauthorized,\n\t\t\t\thttp.StatusForbidden,\n\t\t\t\thttp.StatusNotModified,\n\t\t\t\terrors.StatusUnprocessableEntity,\n\t\t\t\thttp.StatusSwitchingProtocols,"
  },
  {
    "id" : "7b8316bc-b0b0-4669-b18a-afbab9e7ad0b",
    "prId" : 29594,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e26ab714-96db-4176-925e-bc30653d711a",
        "parentId" : null,
        "authorId" : "55c0e4a8-86f8-4426-a163-752ee421c57e",
        "body" : "@lavalamp @smarterclayton It seems that what Brad suggested might not work for us, since we actually try to recover the panic ourselves somehow in RecoverPanics? \n\nI can fix the recoverPanics thing if you think this is the way to move forward.\n",
        "createdAt" : "2016-07-26T03:57:08Z",
        "updatedAt" : "2016-08-09T19:39:48Z",
        "lastEditedBy" : "55c0e4a8-86f8-4426-a163-752ee421c57e",
        "tags" : [
        ]
      },
      {
        "id" : "d1bdf654-07f5-4a74-958b-9c5678752fe0",
        "parentId" : "e26ab714-96db-4176-925e-bc30653d711a",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Which level of recover panics?  Would that be outside of the golang http server/client code?\n",
        "createdAt" : "2016-07-27T17:56:12Z",
        "updatedAt" : "2016-08-09T19:39:48Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "70a0fe8a-d5e7-480f-be15-2f7da5ceef78",
        "parentId" : "e26ab714-96db-4176-925e-bc30653d711a",
        "authorId" : "55c0e4a8-86f8-4426-a163-752ee421c57e",
        "body" : "panic in ServeHTTP. We want to throw that out directly to go HTTP Server, so it can gracefully kill the connection/stream. Right now we catch all panics in the handler, so it wont propagate to HTTP Server at all.\n",
        "createdAt" : "2016-07-27T18:23:00Z",
        "updatedAt" : "2016-08-09T19:39:48Z",
        "lastEditedBy" : "55c0e4a8-86f8-4426-a163-752ee421c57e",
        "tags" : [
        ]
      },
      {
        "id" : "0f1471a9-ee50-4b2a-adea-d597fc5a4cc9",
        "parentId" : "e26ab714-96db-4176-925e-bc30653d711a",
        "authorId" : "ad0a3561-db60-47a9-b82f-ac613199f968",
        "body" : "The original crash was caused because panics weren't being handed back up to the HTTP server to recover. I'm fine with a panic here, because it would be handed back to the server. \n\nWe should invert the nesting of timeout and `RecoverPanics` (in genericapiserver.go) so that we are again protected from panic crashes.\n",
        "createdAt" : "2016-08-08T17:51:28Z",
        "updatedAt" : "2016-08-09T19:39:48Z",
        "lastEditedBy" : "ad0a3561-db60-47a9-b82f-ac613199f968",
        "tags" : [
        ]
      },
      {
        "id" : "9460558c-d320-4566-b2bd-823f037bc513",
        "parentId" : "e26ab714-96db-4176-925e-bc30653d711a",
        "authorId" : "55c0e4a8-86f8-4426-a163-752ee421c57e",
        "body" : "@krousey I want this panic to be propagated to the actual go HTTP Server. So that it can cleanly kill http stream/connections. But now it is recovered by panicHandler in API server.\n",
        "createdAt" : "2016-08-08T22:29:23Z",
        "updatedAt" : "2016-08-09T19:39:48Z",
        "lastEditedBy" : "55c0e4a8-86f8-4426-a163-752ee421c57e",
        "tags" : [
        ]
      },
      {
        "id" : "12e20b73-2907-4cc2-9e99-043f37d1bd3b",
        "parentId" : "e26ab714-96db-4176-925e-bc30653d711a",
        "authorId" : "ad0a3561-db60-47a9-b82f-ac613199f968",
        "body" : "Yep. We agree.\n",
        "createdAt" : "2016-08-08T22:49:28Z",
        "updatedAt" : "2016-08-09T19:39:48Z",
        "lastEditedBy" : "ad0a3561-db60-47a9-b82f-ac613199f968",
        "tags" : [
        ]
      }
    ],
    "commit" : "c995050ee34cd0c11652007b5411557688667413",
    "line" : 114,
    "diffHunk" : "@@ -1,1 +313,317 @@\t\t// the connection for HTTP1 or reset stream for HTTP2.\n\t\t//\n\t\t// Note from: Brad Fitzpatrick\n\t\t// if the ServeHTTP goroutine panics, that will do the best possible thing for both\n\t\t// HTTP/1 and HTTP/2. In HTTP/1, assuming you're replying with at least HTTP/1.1 and"
  },
  {
    "id" : "9dcb5f89-2524-4175-b57c-0572e7b9869c",
    "prId" : 29594,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8b0d7028-4cc8-45dc-a89f-f0f03ba84563",
        "parentId" : null,
        "authorId" : "ad0a3561-db60-47a9-b82f-ac613199f968",
        "body" : "This is the crash path. Panic in a goroutine bringing down the API server. In addition to inverting the timeout and recover handlers in genericapiserver.go, it wouldn't hurt to add a recover here as well just to be safe.\n",
        "createdAt" : "2016-08-08T17:53:44Z",
        "updatedAt" : "2016-08-09T19:39:48Z",
        "lastEditedBy" : "ad0a3561-db60-47a9-b82f-ac613199f968",
        "tags" : [
        ]
      },
      {
        "id" : "d3ed5605-a8f0-4b5e-b3f4-d4cf61094984",
        "parentId" : "8b0d7028-4cc8-45dc-a89f-f0f03ba84563",
        "authorId" : "55c0e4a8-86f8-4426-a163-752ee421c57e",
        "body" : "Will this bring down the server? I thought server was recovered from panic. Also the log in the original issue showed that the API server recovered from the panic. We just did not handle the request correctly. \n",
        "createdAt" : "2016-08-08T22:31:41Z",
        "updatedAt" : "2016-08-09T19:39:48Z",
        "lastEditedBy" : "55c0e4a8-86f8-4426-a163-752ee421c57e",
        "tags" : [
        ]
      },
      {
        "id" : "f923e6b9-3a8f-4d1c-b1d1-0424ea09e242",
        "parentId" : "8b0d7028-4cc8-45dc-a89f-f0f03ba84563",
        "authorId" : "ad0a3561-db60-47a9-b82f-ac613199f968",
        "body" : "Yes. And the server did crash. Here. There was one that was recovered by [`apiserver.InstallRecoverHandler`](https://github.com/kubernetes/kubernetes/blob/master/pkg/apiserver/apiserver.go#L192), but it was soon followed by one that crashed with: \n\n``` console\nI0715 12:14:23.388150    3511 handlers.go:164] GET /api/v1/nodes/10.180.1.92: (154.464521ms) 200 [[kubemark/v1.4.0 (linux/amd64) kubernetes/12483d9] 104.197.214.41:58039]\npanic: Header called after Handler finished [recovered]\n        panic: Header called after Handler finished\n\ngoroutine 54829830 [running]:\npanic(0x20f0220, 0xc821e07010)\n        /usr/local/go/src/runtime/panic.go:481 +0x3e6\nnet/http.(*http2responseWriter).Header(0xc956288948, 0x7fe725a76c88)\n        /usr/local/go/src/net/http/h2_bundle.go:4452 +0x78\n...\nk8s.io/kubernetes/pkg/apiserver.(*timeoutHandler).ServeHTTP.func1(0xc8216ec9c0, 0x7fe725b36ba8, 0xc8fc256620, 0xc83c513260, 0xc90d296720)\n        /go/src/k8s.io/kubernetes/_output/dockerized/go/src/k8s.io/kubernetes/pkg/apiserver/handlers.go:194 +0x91\ncreated by k8s.io/kubernetes/pkg/apiserver.(*timeoutHandler).ServeHTTP\n        /go/src/k8s.io/kubernetes/_output/dockerized/go/src/k8s.io/kubernetes/pkg/apiserver/handlers.go:196 +0x15b\n```\n\n`t.handler` here does not have any recover wrapper around it, and the code shouldn't rely on it to have one either.\n",
        "createdAt" : "2016-08-08T22:47:59Z",
        "updatedAt" : "2016-08-09T19:39:48Z",
        "lastEditedBy" : "ad0a3561-db60-47a9-b82f-ac613199f968",
        "tags" : [
        ]
      },
      {
        "id" : "186e61e0-40a5-4845-b3f3-0198413453d9",
        "parentId" : "8b0d7028-4cc8-45dc-a89f-f0f03ba84563",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "(not sure if relevant, but we now crash for real when there's a panic, so\nif you don't want to bring down the whole process you'll need to intercept\nit somewhere.)\n\nOn Mon, Aug 8, 2016 at 3:31 PM, Xiang Li notifications@github.com wrote:\n\n> In pkg/apiserver/handlers.go\n> https://github.com/kubernetes/kubernetes/pull/29594#discussion_r73968141\n> :\n> \n> > @@ -188,11 +190,11 @@ func (t *timeoutHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n> >         return\n> >     }\n> > -   done := make(chan struct{}, 1)\n> > -   done := make(chan struct{})\n> >   tw := newTimeoutWriter(w)\n> >   go func() {\n> >       t.handler.ServeHTTP(tw, r)\n> \n> Will this bring down the server? I thought server was recovered from\n> panic. Also the log in the original issue showed that the API server\n> recovered from the panic. We just did not handle the request correctly.\n> \n> —\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> https://github.com/kubernetes/kubernetes/pull/29594/files/b9129837e9db2272de6f73ba88552451ae1438de#r73968141,\n> or mute the thread\n> https://github.com/notifications/unsubscribe-auth/AAnglkdhiOpVhhS3g754tu4FbvYiujbHks5qd65XgaJpZM4JUwp4\n> .\n",
        "createdAt" : "2016-08-08T22:57:34Z",
        "updatedAt" : "2016-08-09T19:39:48Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "1b0d2805-cf46-4800-a0ee-5864058ec803",
        "parentId" : "8b0d7028-4cc8-45dc-a89f-f0f03ba84563",
        "authorId" : "ad0a3561-db60-47a9-b82f-ac613199f968",
        "body" : "@lavalamp This is exactly what I was trying to point out. In the spirit of `http.Server`'s calls to `ServeHTTP`, we should squash any panic in this goroutine.\n",
        "createdAt" : "2016-08-09T00:13:51Z",
        "updatedAt" : "2016-08-09T19:39:48Z",
        "lastEditedBy" : "ad0a3561-db60-47a9-b82f-ac613199f968",
        "tags" : [
        ]
      },
      {
        "id" : "1cb20857-5bbc-4856-b032-92e6ff3e388e",
        "parentId" : "8b0d7028-4cc8-45dc-a89f-f0f03ba84563",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "No-- we now deliberately bring down the entire process on a panic, this is something that changed a few weeks ago. I mean, you could `defer kruntime.HandlePanics()` or whatever but it now re-panics after catching panics.\n",
        "createdAt" : "2016-08-09T17:50:30Z",
        "updatedAt" : "2016-08-09T19:39:48Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "ed9136ca-1295-40c7-8fae-c10cf883a4c1",
        "parentId" : "8b0d7028-4cc8-45dc-a89f-f0f03ba84563",
        "authorId" : "ad0a3561-db60-47a9-b82f-ac613199f968",
        "body" : "Oh so the crash is desired. Ok.\n",
        "createdAt" : "2016-08-09T17:55:08Z",
        "updatedAt" : "2016-08-09T19:39:48Z",
        "lastEditedBy" : "ad0a3561-db60-47a9-b82f-ac613199f968",
        "tags" : [
        ]
      },
      {
        "id" : "01b6f9f1-247e-41d9-8a48-f2b9464976bd",
        "parentId" : "8b0d7028-4cc8-45dc-a89f-f0f03ba84563",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "Yeah, it makes it more obvious to monitoring tools. It also means that\nsomeone who figures out how to trigger one can potentially DOS apiserver--\nfor this reason we did leave the mechanism in place and it can be turned on\nby setting kruntime.ReallyCrash = false. (So you probably should defer\nHandleCrash to keep that working...)\n\nOn Tue, Aug 9, 2016 at 10:55 AM, krousey notifications@github.com wrote:\n\n> In pkg/apiserver/handlers.go\n> https://github.com/kubernetes/kubernetes/pull/29594#discussion_r74110174\n> :\n> \n> > @@ -188,11 +190,11 @@ func (t *timeoutHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n> >         return\n> >     }\n> > -   done := make(chan struct{}, 1)\n> > -   done := make(chan struct{})\n> >   tw := newTimeoutWriter(w)\n> >   go func() {\n> >       t.handler.ServeHTTP(tw, r)\n> \n> Oh so the crash is desired. Ok.\n> \n> —\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> https://github.com/kubernetes/kubernetes/pull/29594/files/b9129837e9db2272de6f73ba88552451ae1438de#r74110174,\n> or mute the thread\n> https://github.com/notifications/unsubscribe-auth/AAnglkqF0mNAB8rRVGWU-W1HG82nHT1oks5qeL8HgaJpZM4JUwp4\n> .\n",
        "createdAt" : "2016-08-09T17:59:12Z",
        "updatedAt" : "2016-08-09T19:39:48Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "1ee28988-13fb-4733-b7cd-55693055b3a4",
        "parentId" : "8b0d7028-4cc8-45dc-a89f-f0f03ba84563",
        "authorId" : "55c0e4a8-86f8-4426-a163-752ee421c57e",
        "body" : "@krousey @lavalamp \n\nEven with your recent change at https://github.com/kubernetes/kubernetes/pull/28800. HTTP server will not really panic the whole process by default I think. HTTP server has internal mechanism to recover.\n\nSee this example:\n\n``` go\npackage main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"net/http\"\n)\n\nfunc main() {\n    http.HandleFunc(\"/panic\", func(w http.ResponseWriter, r *http.Request) {\n        defer func() {\n            if r := recover(); r != nil {\n                fmt.Println(\"handle panic\")\n                panic(r)\n            }\n        }()\n\n        fmt.Fprintf(w, \"panic\")\n        panic(\"panic\")\n    })\n\n    log.Fatal(http.ListenAndServe(\":8080\", nil))\n}\n```\n\n``` bash\nhandle panic\n2016/08/09 11:12:51 http: panic serving 127.0.0.1:61476: panic\ngoroutine 20 [running]:\nnet/http.(*conn).serve.func1(0xc820086200)\n    /usr/local/go/src/net/http/server.go:1389 +0xc1\npanic(0x28bca0, 0xc82006eee0)\n    /usr/local/go/src/runtime/panic.go:426 +0x4e9\nmain.main.func1.1()\n    /Users/xiangli/playground/panic.go:14 +0x121\npanic(0x28bca0, 0xc82006eee0)\n    /usr/local/go/src/runtime/panic.go:426 +0x4e9\nmain.main.func1(0x7857a8, 0xc8200756c0, 0xc8200ec1c0)\n    /Users/xiangli/playground/panic.go:19 +0xee\nnet/http.HandlerFunc.ServeHTTP(0x4062c0, 0x7857a8, 0xc8200756c0, 0xc8200ec1c0)\n    /usr/local/go/src/net/http/server.go:1618 +0x3a\nnet/http.(*ServeMux).ServeHTTP(0xc820072a80, 0x7857a8, 0xc8200756c0, 0xc8200ec1c0)\n    /usr/local/go/src/net/http/server.go:1910 +0x17d\nnet/http.serverHandler.ServeHTTP(0xc820086080, 0x7857a8, 0xc8200756c0, 0xc8200ec1c0)\n    /usr/local/go/src/net/http/server.go:2081 +0x19e\nnet/http.(*conn).serve(0xc820086200)\n    /usr/local/go/src/net/http/server.go:1472 +0xf2e\ncreated by net/http.(*Server).Serve\n    /usr/local/go/src/net/http/server.go:2137 +0x44e\nhandle panic\n2016/08/09 11:12:56 http: panic serving 127.0.0.1:61477: panic\ngoroutine 21 [running]:\nnet/http.(*conn).serve.func1(0xc820086380)\n    /usr/local/go/src/net/http/server.go:1389 +0xc1\npanic(0x28bca0, 0xc82006ef90)\n    /usr/local/go/src/runtime/panic.go:426 +0x4e9\nmain.main.func1.1()\n    /Users/xiangli/playground/panic.go:14 +0x121\npanic(0x28bca0, 0xc82006ef90)\n    /usr/local/go/src/runtime/panic.go:426 +0x4e9\nmain.main.func1(0x7857a8, 0xc820075790, 0xc8200ec2a0)\n    /Users/xiangli/playground/panic.go:19 +0xee\nnet/http.HandlerFunc.ServeHTTP(0x4062c0, 0x7857a8, 0xc820075790, 0xc8200ec2a0)\n    /usr/local/go/src/net/http/server.go:1618 +0x3a\nnet/http.(*ServeMux).ServeHTTP(0xc820072a80, 0x7857a8, 0xc820075790, 0xc8200ec2a0)\n    /usr/local/go/src/net/http/server.go:1910 +0x17d\nnet/http.serverHandler.ServeHTTP(0xc820086080, 0x7857a8, 0xc820075790, 0xc8200ec2a0)\n    /usr/local/go/src/net/http/server.go:2081 +0x19e\nnet/http.(*conn).serve(0xc820086380)\n    /usr/local/go/src/net/http/server.go:1472 +0xf2e\ncreated by net/http.(*Server).Serve\n    /usr/local/go/src/net/http/server.go:2137 +0x44e\nhandle panic\n2016/08/09 11:12:57 http: panic serving 127.0.0.1:61478: panic\ngoroutine 22 [running]:\nnet/http.(*conn).serve.func1(0xc820086480)\n    /usr/local/go/src/net/http/server.go:1389 +0xc1\npanic(0x28bca0, 0xc82006f020)\n    /usr/local/go/src/runtime/panic.go:426 +0x4e9\nmain.main.func1.1()\n    /Users/xiangli/playground/panic.go:14 +0x121\npanic(0x28bca0, 0xc82006f020)\n    /usr/local/go/src/runtime/panic.go:426 +0x4e9\nmain.main.func1(0x7857a8, 0xc820075930, 0xc8200ec380)\n    /Users/xiangli/playground/panic.go:19 +0xee\nnet/http.HandlerFunc.ServeHTTP(0x4062c0, 0x7857a8, 0xc820075930, 0xc8200ec380)\n    /usr/local/go/src/net/http/server.go:1618 +0x3a\nnet/http.(*ServeMux).ServeHTTP(0xc820072a80, 0x7857a8, 0xc820075930, 0xc8200ec380)\n    /usr/local/go/src/net/http/server.go:1910 +0x17d\nnet/http.serverHandler.ServeHTTP(0xc820086080, 0x7857a8, 0xc820075930, 0xc8200ec380)\n    /usr/local/go/src/net/http/server.go:2081 +0x19e\nnet/http.(*conn).serve(0xc820086480)\n    /usr/local/go/src/net/http/server.go:1472 +0xf2e\ncreated by net/http.(*Server).Serve\n    /usr/local/go/src/net/http/server.go:2137 +0x44e\n```\n",
        "createdAt" : "2016-08-09T18:15:00Z",
        "updatedAt" : "2016-08-09T19:39:48Z",
        "lastEditedBy" : "55c0e4a8-86f8-4426-a163-752ee421c57e",
        "tags" : [
        ]
      },
      {
        "id" : "b660e252-be74-4963-acf3-97d23e0e134e",
        "parentId" : "8b0d7028-4cc8-45dc-a89f-f0f03ba84563",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "huh, that was not the way I thought it worked. I'll have to look into that.\n\nOn Tue, Aug 9, 2016 at 11:15 AM, Xiang Li notifications@github.com wrote:\n\n> In pkg/apiserver/handlers.go\n> https://github.com/kubernetes/kubernetes/pull/29594#discussion_r74114258\n> :\n> \n> > @@ -188,11 +190,11 @@ func (t *timeoutHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n> >         return\n> >     }\n> > -   done := make(chan struct{}, 1)\n> > -   done := make(chan struct{})\n> >   tw := newTimeoutWriter(w)\n> >   go func() {\n> >       t.handler.ServeHTTP(tw, r)\n> \n> @krousey https://github.com/krousey @lavalamp\n> https://github.com/lavalamp\n> \n> Even with your recent change at #28800\n> https://github.com/kubernetes/kubernetes/pull/28800. HTTP server will\n> not really panic the whole process by default I think. HTTP server has\n> internal mechanism to recover.\n> \n> See this example:\n> \n> package main\n> import (\n>     \"fmt\"\n>     \"log\"\n>     \"net/http\"\n> )\n> func main() {\n>     http.HandleFunc(\"/panic\", func(w http.ResponseWriter, r *http.Request) {\n>         defer func() {\n>             if r := recover(); r != nil {\n>                 fmt.Println(\"handle panic\")\n>                 panic(r)\n>             }\n>         }()\n> \n> ```\n>     fmt.Fprintf(w, \"panic\")\n>     panic(\"panic\")\n> })\n> \n> log.Fatal(http.ListenAndServe(\":8080\", nil))\n> ```\n> \n> }\n> \n> handle panic\n> 2016/08/09 11:12:51 http: panic serving 127.0.0.1:61476: panic\n> goroutine 20 [running]:\n> net/http.(_conn).serve.func1(0xc820086200)\n>     /usr/local/go/src/net/http/server.go:1389 +0xc1\n> panic(0x28bca0, 0xc82006eee0)\n>     /usr/local/go/src/runtime/panic.go:426 +0x4e9main.main.func1.1()\n>     /Users/xiangli/playground/panic.go:14 +0x121\n> panic(0x28bca0, 0xc82006eee0)\n>     /usr/local/go/src/runtime/panic.go:426 +0x4e9\n> main.main.func1(0x7857a8, 0xc8200756c0, 0xc8200ec1c0)\n>     /Users/xiangli/playground/panic.go:19 +0xee\n> net/http.HandlerFunc.ServeHTTP(0x4062c0, 0x7857a8, 0xc8200756c0, 0xc8200ec1c0)\n>     /usr/local/go/src/net/http/server.go:1618 +0x3a\n> net/http.(_ServeMux).ServeHTTP(0xc820072a80, 0x7857a8, 0xc8200756c0, 0xc8200ec1c0)\n>     /usr/local/go/src/net/http/server.go:1910 +0x17d\n> net/http.serverHandler.ServeHTTP(0xc820086080, 0x7857a8, 0xc8200756c0, 0xc8200ec1c0)\n>     /usr/local/go/src/net/http/server.go:2081 +0x19e\n> net/http.(_conn).serve(0xc820086200)\n>     /usr/local/go/src/net/http/server.go:1472 +0xf2e\n> created by net/http.(_Server).Serve\n>     /usr/local/go/src/net/http/server.go:2137 +0x44e\n> handle panic\n> 2016/08/09 11:12:56 http: panic serving 127.0.0.1:61477: panic\n> goroutine 21 [running]:\n> net/http.(_conn).serve.func1(0xc820086380)\n>     /usr/local/go/src/net/http/server.go:1389 +0xc1\n> panic(0x28bca0, 0xc82006ef90)\n>     /usr/local/go/src/runtime/panic.go:426 +0x4e9main.main.func1.1()\n>     /Users/xiangli/playground/panic.go:14 +0x121\n> panic(0x28bca0, 0xc82006ef90)\n>     /usr/local/go/src/runtime/panic.go:426 +0x4e9\n> main.main.func1(0x7857a8, 0xc820075790, 0xc8200ec2a0)\n>     /Users/xiangli/playground/panic.go:19 +0xee\n> net/http.HandlerFunc.ServeHTTP(0x4062c0, 0x7857a8, 0xc820075790, 0xc8200ec2a0)\n>     /usr/local/go/src/net/http/server.go:1618 +0x3a\n> net/http.(_ServeMux).ServeHTTP(0xc820072a80, 0x7857a8, 0xc820075790, 0xc8200ec2a0)\n>     /usr/local/go/src/net/http/server.go:1910 +0x17d\n> net/http.serverHandler.ServeHTTP(0xc820086080, 0x7857a8, 0xc820075790, 0xc8200ec2a0)\n>     /usr/local/go/src/net/http/server.go:2081 +0x19e\n> net/http.(_conn).serve(0xc820086380)\n>     /usr/local/go/src/net/http/server.go:1472 +0xf2e\n> created by net/http.(_Server).Serve\n>     /usr/local/go/src/net/http/server.go:2137 +0x44e\n> handle panic\n> 2016/08/09 11:12:57 http: panic serving 127.0.0.1:61478: panic\n> goroutine 22 [running]:\n> net/http.(_conn).serve.func1(0xc820086480)\n>     /usr/local/go/src/net/http/server.go:1389 +0xc1\n> panic(0x28bca0, 0xc82006f020)\n>     /usr/local/go/src/runtime/panic.go:426 +0x4e9main.main.func1.1()\n>     /Users/xiangli/playground/panic.go:14 +0x121\n> panic(0x28bca0, 0xc82006f020)\n>     /usr/local/go/src/runtime/panic.go:426 +0x4e9\n> main.main.func1(0x7857a8, 0xc820075930, 0xc8200ec380)\n>     /Users/xiangli/playground/panic.go:19 +0xee\n> net/http.HandlerFunc.ServeHTTP(0x4062c0, 0x7857a8, 0xc820075930, 0xc8200ec380)\n>     /usr/local/go/src/net/http/server.go:1618 +0x3a\n> net/http.(_ServeMux).ServeHTTP(0xc820072a80, 0x7857a8, 0xc820075930, 0xc8200ec380)\n>     /usr/local/go/src/net/http/server.go:1910 +0x17d\n> net/http.serverHandler.ServeHTTP(0xc820086080, 0x7857a8, 0xc820075930, 0xc8200ec380)\n>     /usr/local/go/src/net/http/server.go:2081 +0x19e\n> net/http.(_conn).serve(0xc820086480)\n>     /usr/local/go/src/net/http/server.go:1472 +0xf2e\n> created by net/http.(_Server).Serve\n>     /usr/local/go/src/net/http/server.go:2137 +0x44e\n> \n> —\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> https://github.com/kubernetes/kubernetes/pull/29594/files/b9129837e9db2272de6f73ba88552451ae1438de#r74114258,\n> or mute the thread\n> https://github.com/notifications/unsubscribe-auth/AAngloRStcN-ps15GfkfEHFn3RSVeLTXks5qeMOwgaJpZM4JUwp4\n> .\n",
        "createdAt" : "2016-08-09T18:34:53Z",
        "updatedAt" : "2016-08-09T19:39:48Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "1f7abad5-9c4f-4a9e-ac8f-cf843e13441f",
        "parentId" : "8b0d7028-4cc8-45dc-a89f-f0f03ba84563",
        "authorId" : "55c0e4a8-86f8-4426-a163-752ee421c57e",
        "body" : "@lavalamp OK. If you want a really panic on HTTP sever, I can help you fix it... But I will let you confirm that is what you want first...\n",
        "createdAt" : "2016-08-09T18:36:58Z",
        "updatedAt" : "2016-08-09T19:39:48Z",
        "lastEditedBy" : "55c0e4a8-86f8-4426-a163-752ee421c57e",
        "tags" : [
        ]
      },
      {
        "id" : "2bcbfb8c-4970-48ca-b357-10e373a6a925",
        "parentId" : "8b0d7028-4cc8-45dc-a89f-f0f03ba84563",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "We can worry about that separately, it doesn't need to block this PR :)\n\nOn Tue, Aug 9, 2016 at 11:37 AM, Xiang Li notifications@github.com wrote:\n\n> In pkg/apiserver/handlers.go\n> https://github.com/kubernetes/kubernetes/pull/29594#discussion_r74118789\n> :\n> \n> > @@ -188,11 +190,11 @@ func (t *timeoutHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n> >         return\n> >     }\n> > -   done := make(chan struct{}, 1)\n> > -   done := make(chan struct{})\n> >   tw := newTimeoutWriter(w)\n> >   go func() {\n> >       t.handler.ServeHTTP(tw, r)\n> \n> @lavalamp https://github.com/lavalamp OK. If you want a really panic on\n> HTTP sever, I can help you fix it... But I will let you confirm that is\n> what you want first...\n> \n> —\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> https://github.com/kubernetes/kubernetes/pull/29594/files/b9129837e9db2272de6f73ba88552451ae1438de#r74118789,\n> or mute the thread\n> https://github.com/notifications/unsubscribe-auth/AAngllAkcd926RDDAOmUu-LfPh95Jl9sks5qeMjUgaJpZM4JUwp4\n> .\n",
        "createdAt" : "2016-08-09T19:02:42Z",
        "updatedAt" : "2016-08-09T19:39:48Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "28932739-b789-434e-976e-fead2fd43e04",
        "parentId" : "8b0d7028-4cc8-45dc-a89f-f0f03ba84563",
        "authorId" : "55c0e4a8-86f8-4426-a163-752ee421c57e",
        "body" : "> We can worry about that separately, it doesn't need to block this PR :)\n\nHa... That is also my point:https://github.com/kubernetes/kubernetes/pull/29594#discussion_r73968141\n\nI created another issue for this: see https://github.com/kubernetes/kubernetes/issues/30305.\n",
        "createdAt" : "2016-08-09T20:00:02Z",
        "updatedAt" : "2016-08-09T20:00:02Z",
        "lastEditedBy" : "55c0e4a8-86f8-4426-a163-752ee421c57e",
        "tags" : [
        ]
      }
    ],
    "commit" : "c995050ee34cd0c11652007b5411557688667413",
    "line" : 17,
    "diffHunk" : "@@ -1,1 +194,198 @@\ttw := newTimeoutWriter(w)\n\tgo func() {\n\t\tt.handler.ServeHTTP(tw, r)\n\t\tclose(done)\n\t}()"
  },
  {
    "id" : "7e2ecb81-51fc-4f2e-89a4-ad39d155f92f",
    "prId" : 28281,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f91294c5-c457-4f1d-a729-bd3d7e96e176",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "need to `return` early\n",
        "createdAt" : "2016-06-30T12:56:42Z",
        "updatedAt" : "2016-07-18T10:50:55Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "fa0dd46ab7369dbca900273587a49268fb7dbaf0",
    "line" : null,
    "diffHunk" : "@@ -1,1 +493,497 @@\t\tif !authorized {\n\t\t\tglog.V(4).Infof(\"Forbidden: %#v, Reason: %s\", req.RequestURI, reason)\n\t\t\tforbidden(w, req)\n\t\t\treturn\n\t\t}"
  },
  {
    "id" : "f59931fd-1b1d-40dd-94ea-4bc8f115b02d",
    "prId" : 24795,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7c366866-b3f9-4910-95ba-940bfa766cd0",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "I have a slight preference for an if/else rather than setting to `users`,`<name>` and overriding here, but otherwise LGTM\n",
        "createdAt" : "2016-04-26T14:05:30Z",
        "updatedAt" : "2016-04-26T14:05:42Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "af99b97c-ead8-4f9d-aeaf-374878064fcf",
        "parentId" : "7c366866-b3f9-4910-95ba-940bfa766cd0",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "as-is is fine with me.\n",
        "createdAt" : "2016-05-02T22:53:59Z",
        "updatedAt" : "2016-05-02T22:53:59Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      }
    ],
    "commit" : "622932422db2541bd4a77d55071fbf11d487a9a1",
    "line" : 29,
    "diffHunk" : "@@ -1,1 +442,446 @@\t\t\tactingAsAttributes.Namespace = namespace\n\t\t\tactingAsAttributes.Name = name\n\t\t}\n\n\t\terr := a.Authorize(actingAsAttributes)"
  },
  {
    "id" : "fb69b21a-06f2-4468-9a87-ef3967bd7de0",
    "prId" : 23549,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "839cb2d1-7793-4cf8-aec2-0ba84add3773",
        "parentId" : null,
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "Don't ignore error?\n",
        "createdAt" : "2016-03-29T00:08:18Z",
        "updatedAt" : "2016-04-14T16:49:17Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "68f95aee-6406-4445-86dc-6478ba0a40e4",
        "parentId" : "839cb2d1-7793-4cf8-aec2-0ba84add3773",
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "> Don't ignore error?\n>  Add a line note\n\nIt's an `exists` bool for a context that we just set a few lines up\n",
        "createdAt" : "2016-03-29T11:48:02Z",
        "updatedAt" : "2016-04-14T16:49:17Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      }
    ],
    "commit" : "ac4c545b91345122801e19919e917cedd3cb4753",
    "line" : 64,
    "diffHunk" : "@@ -1,1 +461,465 @@\t\t}\n\n\t\tnewCtx, _ := requestContextMapper.Get(req)\n\t\toldUser, _ := api.UserFrom(ctx)\n\t\tnewUser, _ := api.UserFrom(newCtx)"
  },
  {
    "id" : "42217d27-749c-46e1-b86d-346d2306ca0d",
    "prId" : 23549,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "502bfbdf-8b58-4f18-aa7d-255bbb373d62",
        "parentId" : null,
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "And I ignored this one because we just did a `Get` (and checked `exists`) a few lines up from here.\n",
        "createdAt" : "2016-03-29T11:49:07Z",
        "updatedAt" : "2016-04-14T16:49:17Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      }
    ],
    "commit" : "ac4c545b91345122801e19919e917cedd3cb4753",
    "line" : 61,
    "diffHunk" : "@@ -1,1 +458,462 @@\t\t\t\tName: requestedSubject,\n\t\t\t}\n\t\t\trequestContextMapper.Update(req, api.WithUser(ctx, newUser))\n\t\t}\n"
  },
  {
    "id" : "5cf3033d-3850-40f8-8064-7fa41886a7ca",
    "prId" : 23549,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "47147f91-dba3-4de7-b5f0-4651c3907dc8",
        "parentId" : null,
        "authorId" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "body" : "If I approve the \"GetExtra\" PR the would you put requestor user.Info.GetExtras[\"full-username\"] or something like that? \n",
        "createdAt" : "2016-03-30T16:58:05Z",
        "updatedAt" : "2016-04-14T16:49:17Z",
        "lastEditedBy" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "tags" : [
        ]
      },
      {
        "id" : "8ce6b7a5-cd40-49b3-8b60-df887f2cd66d",
        "parentId" : "47147f91-dba3-4de7-b5f0-4651c3907dc8",
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "> If I approve the \"GetExtra\" PR the would you put requestor user.Info.GetExtras[\"full-username\"] or something like that?\n\nI think I'd like to namespace the key, but I'm ok with that.  Would you prefer that to filling in something more structured on the context itself?\n",
        "createdAt" : "2016-03-30T17:11:48Z",
        "updatedAt" : "2016-04-14T16:49:17Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      }
    ],
    "commit" : "ac4c545b91345122801e19919e917cedd3cb4753",
    "line" : null,
    "diffHunk" : "@@ -1,1 +435,439 @@\t\t\tAPIGroup: api.GroupName,\n\t\t\tResource: \"users\",\n\t\t\t// ResourceName:    requestedSubject,\n\t\t\tResourceRequest: true,\n\t\t}"
  },
  {
    "id" : "0500f085-f2d8-4e41-88b6-b1c676f6a75c",
    "prId" : 22916,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "32a828fb-fd48-45bd-8f4b-78c63ab435d9",
        "parentId" : null,
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "In order to be a subresource reference, it must not have another url segment.  If there's another segment, it seems more likely to an attempt on a namespaced resource and I'd expect our API server to route it accordingly.\n",
        "createdAt" : "2016-03-14T11:46:12Z",
        "updatedAt" : "2016-03-14T17:03:29Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      },
      {
        "id" : "712e9d69-2c12-4534-85df-e6c88195e79a",
        "parentId" : "32a828fb-fd48-45bd-8f4b-78c63ab435d9",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "> In order to be a subresource reference, it must not have another url segment\n\nnope, `/namespaces/myns/pods/mypod/proxy/foo/bar/baz` routes as a subresource\n",
        "createdAt" : "2016-03-14T15:46:19Z",
        "updatedAt" : "2016-03-14T17:03:29Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "d5c41895-8445-42b7-980e-d5b7432a94a6",
        "parentId" : "32a828fb-fd48-45bd-8f4b-78c63ab435d9",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "As do our web hooks.  Anything that implements GetOptions has the ability.\n",
        "createdAt" : "2016-03-14T17:02:11Z",
        "updatedAt" : "2016-03-14T17:03:29Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      }
    ],
    "commit" : "ad20045c8dfe5adfc4453824b715b6e66d95b5da",
    "line" : 19,
    "diffHunk" : "@@ -1,1 +557,561 @@\t\t\t// if there is another step after the namespace name and it is not a known namespace subresource\n\t\t\t// move currentParts to include it as a resource in its own right\n\t\t\tif len(currentParts) > 2 && !namespaceSubresources.Has(currentParts[2]) {\n\t\t\t\tcurrentParts = currentParts[2:]\n\t\t\t}"
  },
  {
    "id" : "cf9c677a-4259-4876-8b63-617fc3f8232b",
    "prId" : 22916,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fb197f78-9044-4533-bf5c-ec6d658ec164",
        "parentId" : null,
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "In openshift, we split our creation of `map[string]rest.Storage` to be able to keep code like this in sync and ensure that code that needed handle particular resources was able to write a unit test to make sure it doesn't slip.\n\nCan you either do that refactor and test or take an issue to do it?  Otherwise this is going to slip-prone.\n",
        "createdAt" : "2016-03-17T12:07:57Z",
        "updatedAt" : "2016-03-17T12:07:57Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      }
    ],
    "commit" : "ad20045c8dfe5adfc4453824b715b6e66d95b5da",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +48,52 @@// namespaceSubresources contains subresources of namespace\n// this list allows the parser to distinguish between a namespace subresource, and a namespaced resource\nvar namespaceSubresources = sets.NewString(\"status\", \"finalize\")\n\n// NamespaceSubResourcesForTest exports namespaceSubresources for testing in pkg/master/master_test.go, so we never drift"
  },
  {
    "id" : "5b325495-cc2e-4649-a78d-a466e222d3ef",
    "prId" : 21497,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c9ab3de2-bf17-4fa0-800d-b16b2ec0a375",
        "parentId" : null,
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "What prevents me from adding ?watch=true to all of my requests to avoid the rate limiter?\n",
        "createdAt" : "2016-02-18T23:45:55Z",
        "updatedAt" : "2016-02-24T15:20:26Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "9720c9df-8f9b-4222-a469-8ba0bdede3bb",
        "parentId" : "c9ab3de2-bf17-4fa0-800d-b16b2ec0a375",
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "> What prevents me from adding ?watch=true to all of my requests to avoid the rate limiter?\n\nNothing.  How much logic do we want to put in here to inspect the request?  It's possible to run a `RequestInfo` parse and make a more definitive determination.\n",
        "createdAt" : "2016-02-19T00:47:46Z",
        "updatedAt" : "2016-02-24T15:20:26Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      },
      {
        "id" : "73b0d047-4b37-433d-985f-c84490d5ab93",
        "parentId" : "c9ab3de2-bf17-4fa0-800d-b16b2ec0a375",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Originally we discussed implementing this inside the restful stack and\nhaving a catchall for everything outside, so the stack would have access to\nAPIRequestInfo and potentially the request.Scope.  It's probably too much\nwork to do now, but we should queue it up for 1.3 (in fact, I bet there is\nan issue I opened over a year ago on this).\n\nOn Thu, Feb 18, 2016 at 7:48 PM, David Eads notifications@github.com\nwrote:\n\n> In pkg/apiserver/handlers.go\n> https://github.com/kubernetes/kubernetes/pull/21497#discussion_r53408004\n> :\n> \n> > @@ -72,13 +72,35 @@ func ReadOnly(handler http.Handler) http.Handler {\n> >     })\n> >  }\n> > \n> > +type LongRunningRequestCheck func(r *http.Request) bool\n> > +\n> > +// BasicLongRunningRequestCheck pathRegex operates against the url path, the queryParams match is case insensitive.\n> > +// Any one match flags the request\n> > +func BasicLongRunningRequestCheck(pathRegex *regexp.Regexp, queryParams map[string]string) LongRunningRequestCheck {\n> > -   return func(r *http.Request) bool {\n> \n> What prevents me from adding ?watch=true to all of my requests to avoid\n> the rate limiter?\n> \n> Nothing. How much logic do we want to put in here to inspect the request?\n> It's possible to run a RequestInfo parse and make a more definitive\n> determination.\n> \n> —\n> Reply to this email directly or view it on GitHub\n> https://github.com/kubernetes/kubernetes/pull/21497/files#r53408004.\n",
        "createdAt" : "2016-02-19T00:51:15Z",
        "updatedAt" : "2016-02-24T15:20:26Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "44224625-29c2-428d-9ed3-91713836f2fd",
        "parentId" : "c9ab3de2-bf17-4fa0-800d-b16b2ec0a375",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "We should be as precise as possible, but maybe not in this PR. @deads2k can you file an issue and add a TODO if you see this before it merges?\n",
        "createdAt" : "2016-02-19T23:50:26Z",
        "updatedAt" : "2016-02-24T15:20:26Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      }
    ],
    "commit" : "357aebc89c1f9f95c74539247f143c6246a13cf7",
    "line" : null,
    "diffHunk" : "@@ -1,1 +80,84 @@// to bypass the rate limitter.  This could be done using a full parse and special casing the bits we need.\nfunc BasicLongRunningRequestCheck(pathRegex *regexp.Regexp, queryParams map[string]string) LongRunningRequestCheck {\n\treturn func(r *http.Request) bool {\n\t\tif pathRegex.MatchString(r.URL.Path) {\n\t\t\treturn true"
  },
  {
    "id" : "34bfed1b-7707-4b0e-a3d9-55d1b6a5f6b8",
    "prId" : 14291,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8937fb20-6cdf-48c5-a334-82311fa99083",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "should we return an error if we encounter an unknown request verb? not sure what HEAD, OPTIONS, and TRACE should map to, but right now they map to nothing\n",
        "createdAt" : "2015-09-21T18:04:11Z",
        "updatedAt" : "2015-09-21T18:09:39Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "4e160e30-a5bd-4250-a885-b778af3cc155",
        "parentId" : "8937fb20-6cdf-48c5-a334-82311fa99083",
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "> should we return an error if we encounter an unknown request verb? not sure what HEAD, OPTIONS, and TRACE should map to, but right now they map to nothing\n\nI'm not opposed to lowercasing the http verb, but I wasn't prepared to change that behavior here.\n",
        "createdAt" : "2015-09-21T18:04:59Z",
        "updatedAt" : "2015-09-21T18:09:39Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      },
      {
        "id" : "47358b4c-ad76-4542-baae-4c4aafd1e4d3",
        "parentId" : "8937fb20-6cdf-48c5-a334-82311fa99083",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "fair enough\n",
        "createdAt" : "2015-09-21T18:07:22Z",
        "updatedAt" : "2015-09-21T18:09:39Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "630c6cc16aa25ebdb7bc896cf2f61a55e841e148",
    "line" : 8,
    "diffHunk" : "@@ -1,1 +500,504 @@\t\tcase \"DELETE\":\n\t\t\trequestInfo.Verb = \"delete\"\n\t\t}\n\n\t}"
  },
  {
    "id" : "feef5190-7cb9-4f98-9a97-fd7a8cc254bf",
    "prId" : 10656,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e3b60ea6-1c94-4976-8c88-0c5738622b36",
        "parentId" : null,
        "authorId" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "body" : "Document the expectations of this function.  (in particular that returning nil is allowed and cauases it to early terminate.\n",
        "createdAt" : "2015-07-22T20:07:07Z",
        "updatedAt" : "2015-07-22T20:07:07Z",
        "lastEditedBy" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "tags" : [
        ]
      },
      {
        "id" : "e1e7ab6a-8d33-4beb-abeb-ac7fdf2e8f70",
        "parentId" : "e3b60ea6-1c94-4976-8c88-0c5738622b36",
        "authorId" : "ad0a3561-db60-47a9-b82f-ac613199f968",
        "body" : "Actually returning nil will not cause it to terminate early. A nil return will in effect be no timeout. And this is documented in that last sentence of the public function 7 lines above.\n",
        "createdAt" : "2015-07-22T20:14:06Z",
        "updatedAt" : "2015-07-22T20:14:06Z",
        "lastEditedBy" : "ad0a3561-db60-47a9-b82f-ac613199f968",
        "tags" : [
        ]
      }
    ],
    "commit" : "1d033b99123311e47057c0be83b0b77899008488",
    "line" : 35,
    "diffHunk" : "@@ -1,1 +155,159 @@type timeoutHandler struct {\n\thandler http.Handler\n\ttimeout func(*http.Request) (<-chan time.Time, string)\n}\n"
  },
  {
    "id" : "502d97b1-2db5-4c89-874d-7fed3ead59d3",
    "prId" : 6683,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "194485b3-2adc-498d-af5e-5b5d9a076411",
        "parentId" : null,
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "this is confusing me-- if a path is just namespace/blah you want this to mean \"object blah of type namespace in namespace blah\"? Doesn't that preclude useful behavior like listing all the resource types in a namespace?\n",
        "createdAt" : "2015-04-10T22:22:57Z",
        "updatedAt" : "2015-04-10T22:22:57Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "3ea223d8-7f06-46df-865a-0ad978c5fb27",
        "parentId" : "194485b3-2adc-498d-af5e-5b5d9a076411",
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "> if a path is just namespace/blah you want this to mean \"object blah of type namespace in namespace blah\"?\n\nYes.\n\n> Doesn't that preclude useful behavior like listing all the resource types in a namespace?\n\nI missed the original discussion on this (Note that this isn't changing behavior, simply making existing behavior a little more clear), but I the kubernetes `Authorizer` interface isn't really built to handle containment cleanly.  This is not a comment on the expression of policy, but on the `Authorizer` API itself.  It is built around a request operating against a single resource, not a resource that contains other resources.\n\nBecause of that, expressing an `Authorizer` that allows `ReadOnly` access to a `namespace` resource would be unable to reasonably apply rules to the contained resources.  Since the `Authorizer` operates as a single filter on the request, it would not have the opportunity to authorize access to the contained resources.\n\nWhile agree that having a way to authorize requests against contained resources would be interesting, I don't think I want to change the existing behavior of `authorizer.AttributesRecord` here.\n",
        "createdAt" : "2015-04-13T12:09:02Z",
        "updatedAt" : "2015-04-13T12:09:02Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      },
      {
        "id" : "7641b1de-58d1-432d-bc07-0db83fc57b72",
        "parentId" : "194485b3-2adc-498d-af5e-5b5d9a076411",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Probably `/namespaces/foo` should also return the resources included in that namespace.  Or we could explicitly handle `/namespaces/foo/` with the extra slash on the end.\n\nThe advantage of the current path setup is that \"DELETE /namespaces/foo\" results in \"/namespaces/foo/*\" no longer existing. \n",
        "createdAt" : "2015-04-13T13:32:43Z",
        "updatedAt" : "2015-04-13T13:32:43Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      }
    ],
    "commit" : "c17ffb7c4c87b1f292d3ba1a8e34dcac8a01c75c",
    "line" : 60,
    "diffHunk" : "@@ -1,1 +339,343 @@\t\t\t// if there is another step after the namespace name and it is not a known namespace subresource\n\t\t\t// move currentParts to include it as a resource in its own right\n\t\t\tif len(currentParts) > 2 {\n\t\t\t\tcurrentParts = currentParts[2:]\n\t\t\t}"
  },
  {
    "id" : "e444cd5c-5983-462f-bba9-bf3e08a94afa",
    "prId" : 6207,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c13db4af-37ee-4258-9345-ff7aeeb4a073",
        "parentId" : null,
        "authorId" : null,
        "body" : "Retry-After and Rate Limits should be settable parameters, or at least constants with comments indicating how the values were arrived at (even if that's just \"I sucked my thumb\" :-) )\n",
        "createdAt" : "2015-03-31T14:49:40Z",
        "updatedAt" : "2015-04-01T22:08:24Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "361a9249-5a85-49dc-a9bc-e2e4025f4163",
        "parentId" : "c13db4af-37ee-4258-9345-ff7aeeb4a073",
        "authorId" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "body" : "Constantized the RetryAfter.\nChanged the error message, since it wasn't accurate anyway.\n",
        "createdAt" : "2015-03-31T17:49:21Z",
        "updatedAt" : "2015-04-01T22:08:24Z",
        "lastEditedBy" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "tags" : [
        ]
      }
    ],
    "commit" : "f327e97661f317d884d39e1db3ccc6cd97ed5080",
    "line" : null,
    "diffHunk" : "@@ -1,1 +108,112 @@\tw.WriteHeader(errors.StatusTooManyRequests)\n\tfmt.Fprintf(w, \"Too many requests, please try again later.\")\n}\n\n// RecoverPanics wraps an http Handler to recover and log panics."
  },
  {
    "id" : "4a1e72e7-1cb9-4d77-bdd1-f069aa4fc234",
    "prId" : 6207,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ff415cde-3ea7-4d13-9c65-46f52349fda7",
        "parentId" : null,
        "authorId" : null,
        "body" : "Is tooManyRequests logged as an error somewhere?  I assume so, but not sure where.  Just checking.\n",
        "createdAt" : "2015-03-31T14:53:09Z",
        "updatedAt" : "2015-04-01T22:08:24Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "9d83593e-caf9-48d6-90d5-b3ea1410cdc2",
        "parentId" : "ff415cde-3ea7-4d13-9c65-46f52349fda7",
        "authorId" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "body" : "All error HTTP codes are logged at the top of the API server.\n",
        "createdAt" : "2015-03-31T17:50:14Z",
        "updatedAt" : "2015-04-01T22:08:24Z",
        "lastEditedBy" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "tags" : [
        ]
      }
    ],
    "commit" : "f327e97661f317d884d39e1db3ccc6cd97ed5080",
    "line" : 32,
    "diffHunk" : "@@ -1,1 +88,92 @@\t\tdefault:\n\t\t\ttooManyRequests(w)\n\t\t}\n\t})\n}"
  },
  {
    "id" : "34dcae9f-3e2e-49c4-b0af-26f33ba34326",
    "prId" : 3980,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ba946b5a-5346-4aa2-b2d0-e87f8b66a1ba",
        "parentId" : null,
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "Could you parameterize this string with the flags?\n",
        "createdAt" : "2015-01-30T17:19:31Z",
        "updatedAt" : "2015-01-30T19:59:22Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "cd51e844-5c42-468b-b6d6-2c37f1154585",
        "parentId" : "ba946b5a-5346-4aa2-b2d0-e87f8b66a1ba",
        "authorId" : "9d07de69-76c2-43bd-9590-55d9aded200d",
        "body" : "I don't think the flag variables are in scope in the package `apiserver` so I'd have to plumb them in (which was more than I wanted to do for a quick fix).\n",
        "createdAt" : "2015-01-30T17:30:45Z",
        "updatedAt" : "2015-01-30T19:59:22Z",
        "lastEditedBy" : "9d07de69-76c2-43bd-9590-55d9aded200d",
        "tags" : [
        ]
      },
      {
        "id" : "5b35f7a2-4fb5-43a9-b74f-e6d18fb920fd",
        "parentId" : "ba946b5a-5346-4aa2-b2d0-e87f8b66a1ba",
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "Add a TODO\n",
        "createdAt" : "2015-01-30T18:19:34Z",
        "updatedAt" : "2015-01-30T19:59:22Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "fb7311a6-9333-473b-8d0c-8513cac76098",
        "parentId" : "ba946b5a-5346-4aa2-b2d0-e87f8b66a1ba",
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "Actually, change the RateLimiter interface to provide an error message if CanAccept is not true.\n",
        "createdAt" : "2015-01-30T18:21:11Z",
        "updatedAt" : "2015-01-30T19:59:22Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "d6054e08-8515-4b42-8f26-e9d2e58043a7",
        "parentId" : "ba946b5a-5346-4aa2-b2d0-e87f8b66a1ba",
        "authorId" : "9d07de69-76c2-43bd-9590-55d9aded200d",
        "body" : "Removed TODO, filed issue #3987\n",
        "createdAt" : "2015-01-30T20:01:40Z",
        "updatedAt" : "2015-01-30T20:01:40Z",
        "lastEditedBy" : "9d07de69-76c2-43bd-9590-55d9aded200d",
        "tags" : [
        ]
      }
    ],
    "commit" : "d8bda4006a58154416246f2fec436afa8cb40f3e",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +76,80 @@\t\tw.Header().Set(\"Retry-After\", \"1\")\n\t\tw.WriteHeader(errors.StatusTooManyRequests)\n\t\tfmt.Fprintf(w, \"Rate limit is 10 QPS or a burst of 200\")\n\t})\n}"
  },
  {
    "id" : "8b0109d9-8d60-459a-b7c1-c2fcb941bf68",
    "prId" : 2122,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "21f76b48-29c7-4e39-919b-5b57d27ec184",
        "parentId" : null,
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "@derekwaynecarr when we iterate on the internal representation of default namespace this will have to be changed.\n",
        "createdAt" : "2014-11-02T17:56:43Z",
        "updatedAt" : "2014-11-04T01:45:33Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "799a3165-fb29-4e70-8d0d-022fe525d562",
        "parentId" : "21f76b48-29c7-4e39-919b-5b57d27ec184",
        "authorId" : "6eca0ade-9879-4dd7-ad14-547e16f5c041",
        "body" : "I have a growing distaste for some of our handler code and its mechanism to parse parts - especially in parts of the kubelet code.  Can we just a put a TODO where we know a change will be needed when I look to put namespace in the resource path and not as query param?\n",
        "createdAt" : "2014-11-03T02:53:47Z",
        "updatedAt" : "2014-11-04T01:45:33Z",
        "lastEditedBy" : "6eca0ade-9879-4dd7-ad14-547e16f5c041",
        "tags" : [
        ]
      }
    ],
    "commit" : "1668c6f10701c9ee1bec9a952cfbf58e07679a6d",
    "line" : null,
    "diffHunk" : "@@ -1,1 +191,195 @@\t// If the request specifies a namespace, then the namespace is filled in.\n\t// Assumes there is no empty string namespace.  Unspecified results\n\t// in empty (does not understand defaulting rules.)\n\tattribs.Namespace = req.URL.Query().Get(\"namespace\")\n"
  },
  {
    "id" : "0d59e998-7722-4b77-af8c-9771d38adc6d",
    "prId" : 1916,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "28573a95-fb2f-4a81-bdfe-3a0865db39cc",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "can't you do like C and return handler.ServeHTTP(...) even if it return void?\n",
        "createdAt" : "2014-10-20T23:18:31Z",
        "updatedAt" : "2014-10-20T23:33:06Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "004b62bb-36c0-4e1f-8745-10732b84ff41",
        "parentId" : "28573a95-fb2f-4a81-bdfe-3a0865db39cc",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "Just now tried-- compiler says nope.\n",
        "createdAt" : "2014-10-20T23:33:32Z",
        "updatedAt" : "2014-10-20T23:33:32Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      }
    ],
    "commit" : "9356ed7fe777158074b26215978517b2445c733f",
    "line" : 12,
    "diffHunk" : "@@ -1,1 +33,37 @@\treturn http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {\n\t\tif req.Method == \"GET\" {\n\t\t\thandler.ServeHTTP(w, req)\n\t\t\treturn\n\t\t}"
  },
  {
    "id" : "8daf1208-b37a-43f7-9464-6b874106f513",
    "prId" : 1133,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "880dfb66-5cde-4fdb-a768-ca00a6a69ea5",
        "parentId" : null,
        "authorId" : "c2b5c827-efcd-438f-8db5-52d917b1cde9",
        "body" : "You check 'allowed' to set response headers but never reject any requests (everything falls through to the next handler):\n1. If we are enforcing CORS and the \"Origin\" field in the header isn't set, should we accept or reject the request? I think we are trusting web browsers to implement the standard by letting through requests that don't set this field, which means that older browsers defeat the server side protections (http://caniuse.com/#feat=cors).\n2. If the Origin header is set but it doesn't match any of the patterns, we should return an error (403?). \n",
        "createdAt" : "2014-09-03T19:42:24Z",
        "updatedAt" : "2014-09-11T20:48:09Z",
        "lastEditedBy" : "c2b5c827-efcd-438f-8db5-52d917b1cde9",
        "tags" : [
        ]
      },
      {
        "id" : "ca3d492d-cfca-4579-8d35-282962daf96d",
        "parentId" : "880dfb66-5cde-4fdb-a768-ca00a6a69ea5",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "I'm not sure that the point of CORS is to protect older browsers that somehow manage to make a cross domain request - that's CSRF protection which should be covered by requiring Bearer auth (instead of basic or cookie auth).  Enforcing the extra protection doesn't seem dangerous, but it does introduce an extra level of hard to debug failure (set Origin header from a browser that doesn't support CORS?).  Cribbing from w3:\n\nhttp://www.w3.org/wiki/CORS\n\ndoesn't seem like they mandate server enforcement - the server is free to do that.  Is it valuable here?\n",
        "createdAt" : "2014-09-03T19:50:16Z",
        "updatedAt" : "2014-09-11T20:48:09Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "49a6d286-b091-42b8-9456-b76521237dfc",
        "parentId" : "880dfb66-5cde-4fdb-a768-ca00a6a69ea5",
        "authorId" : "80f34a24-30a1-428f-b1a4-f0a97621bb6f",
        "body" : "I would argue against rejecting at the server strictly based on Origin.  CORS headers are generally considered to be client-side enforcement.  Old browsers either a) don't allow cross-domain XmlHTTPRequests or b) allow them when the domains are explicitly added to a list of trusted domains.  In IE you can have a list of sites in the Trusted zone and anything in that list can talk cross-domain to anything else in that list (whether cors headers are there or not).\n",
        "createdAt" : "2014-09-03T20:07:00Z",
        "updatedAt" : "2014-09-11T20:48:09Z",
        "lastEditedBy" : "80f34a24-30a1-428f-b1a4-f0a97621bb6f",
        "tags" : [
        ]
      },
      {
        "id" : "051ed6c7-8f66-491c-8307-30f8c68dacf6",
        "parentId" : "880dfb66-5cde-4fdb-a768-ca00a6a69ea5",
        "authorId" : "c2b5c827-efcd-438f-8db5-52d917b1cde9",
        "body" : "I agree that there is no mandate for server enforcement (\"Based on the value of the Origin header in cross-origin requests it can decide to return no data at all...\") and that we are already relying on the client for enforcement. I guess it just makes me a bit uncomfortable to relinquish complete control to the client (you still leak data because the network traffic is visible on the client machine even if the web browser decides to hide it from the user). \n",
        "createdAt" : "2014-09-03T20:08:52Z",
        "updatedAt" : "2014-09-11T20:48:09Z",
        "lastEditedBy" : "c2b5c827-efcd-438f-8db5-52d917b1cde9",
        "tags" : [
        ]
      },
      {
        "id" : "7466190b-3941-47a3-a5f3-9299d25bbe25",
        "parentId" : "880dfb66-5cde-4fdb-a768-ca00a6a69ea5",
        "authorId" : "80f34a24-30a1-428f-b1a4-f0a97621bb6f",
        "body" : "If we were going to reject requests when Origin is passed and we dont find a match, then we would need to _always_ do that.  This means that even if the administrator runs the API with nothing in the cors_allowed_origins list then we would still have to run the CORS handler on every request in case someone passes us an Origin header.\n",
        "createdAt" : "2014-09-03T20:21:39Z",
        "updatedAt" : "2014-09-11T20:48:09Z",
        "lastEditedBy" : "80f34a24-30a1-428f-b1a4-f0a97621bb6f",
        "tags" : [
        ]
      },
      {
        "id" : "0c218507-5047-4fa0-a30b-62d44ac1caf9",
        "parentId" : "880dfb66-5cde-4fdb-a768-ca00a6a69ea5",
        "authorId" : "9ebd32c2-a201-4916-b445-508ea7e87449",
        "body" : "I don't see any advantage in enforcing CORS on the server either. You basically reimplementing what's already in any browser that supports CORS. Those that don't support simply won't allow cross-origin requests. It could be as simple as a couple apiserver daemon cmd line opts, no handler logic. The handler would then relay those cmd line opts in the approriate headers.\n",
        "createdAt" : "2014-09-04T10:25:44Z",
        "updatedAt" : "2014-09-11T20:48:09Z",
        "lastEditedBy" : "9ebd32c2-a201-4916-b445-508ea7e87449",
        "tags" : [
        ]
      },
      {
        "id" : "9cc62d4e-1812-438e-9048-4cf846706a0d",
        "parentId" : "880dfb66-5cde-4fdb-a768-ca00a6a69ea5",
        "authorId" : "c2b5c827-efcd-438f-8db5-52d917b1cde9",
        "body" : "This still makes me a bit uncomfortable (how much do we trust non-browser clients anyway) but it seems to be the standard way CORS works and we should trust that folks who enable CORS know what they are doing. \n",
        "createdAt" : "2014-09-04T21:56:44Z",
        "updatedAt" : "2014-09-11T20:48:09Z",
        "lastEditedBy" : "c2b5c827-efcd-438f-8db5-52d917b1cde9",
        "tags" : [
        ]
      }
    ],
    "commit" : "0f2b8f4f9f68fe621bc8dd7b5df361f934aa9b79",
    "line" : 71,
    "diffHunk" : "@@ -1,1 +69,73 @@\t\t\t\t}\n\t\t\t}\n\t\t\tif allowed {\n\t\t\t\tw.Header().Set(\"Access-Control-Allow-Origin\", origin)\n\t\t\t\t// Set defaults for methods and headers if nothing was passed"
  },
  {
    "id" : "637c2938-813a-4dc0-9c43-e677226ff123",
    "prId" : 1133,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4e35d387-6952-4eb0-a7d1-dfcd20b76db6",
        "parentId" : null,
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "Can you move this function back?\n",
        "createdAt" : "2014-09-03T20:22:29Z",
        "updatedAt" : "2014-09-11T20:48:09Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "08902d3e-7eac-41a0-a895-8d59bade65c3",
        "parentId" : "4e35d387-6952-4eb0-a7d1-dfcd20b76db6",
        "authorId" : "80f34a24-30a1-428f-b1a4-f0a97621bb6f",
        "body" : "@smarterclayton what was the reason you wanted it pulled out into a separate file?\n",
        "createdAt" : "2014-09-03T20:23:30Z",
        "updatedAt" : "2014-09-11T20:48:09Z",
        "lastEditedBy" : "80f34a24-30a1-428f-b1a4-f0a97621bb6f",
        "tags" : [
        ]
      },
      {
        "id" : "beeaf1bd-89b5-4881-b89d-8932b4883cda",
        "parentId" : "4e35d387-6952-4eb0-a7d1-dfcd20b76db6",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "To keep apiserver.go smaller - these are one off handlers that can be used independently.\n",
        "createdAt" : "2014-09-03T20:24:25Z",
        "updatedAt" : "2014-09-11T20:48:09Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "fff2b276-ea4b-4122-8dfb-d1eee551e5ca",
        "parentId" : "4e35d387-6952-4eb0-a7d1-dfcd20b76db6",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "And call this file cors.go? :)\n",
        "createdAt" : "2014-09-03T20:26:02Z",
        "updatedAt" : "2014-09-11T20:48:09Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "daa8f98d-a617-4183-8ada-f88fddff5b41",
        "parentId" : "4e35d387-6952-4eb0-a7d1-dfcd20b76db6",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "Ah, I don't care that much, just seemed like a separate thing from the point of this PR.\n",
        "createdAt" : "2014-09-03T20:30:01Z",
        "updatedAt" : "2014-09-11T20:48:09Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      }
    ],
    "commit" : "0f2b8f4f9f68fe621bc8dd7b5df361f934aa9b79",
    "line" : 31,
    "diffHunk" : "@@ -1,1 +29,33 @@\n// RecoverPanics wraps an http Handler to recover and log panics.\nfunc RecoverPanics(handler http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {\n\t\tdefer func() {"
  },
  {
    "id" : "fde07ffc-741e-433c-b04d-9b49ae41e450",
    "prId" : 1133,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "64942fb8-3b8f-4b7a-be31-383fc9e68194",
        "parentId" : null,
        "authorId" : "9ebd32c2-a201-4916-b445-508ea7e87449",
        "body" : "@jwforres I've just realized this won't work when apiserver is reverse-proxied by Nginx + Basic Auth.\nPreflight request (OPTIONS) does not include credentials, Basic Auth in this case. So, OPTIONS request will never reach apiserver as Nginx will respond with 401 authentication required error.\n",
        "createdAt" : "2014-09-05T14:16:52Z",
        "updatedAt" : "2014-09-11T20:48:09Z",
        "lastEditedBy" : "9ebd32c2-a201-4916-b445-508ea7e87449",
        "tags" : [
        ]
      },
      {
        "id" : "13b13b0b-367f-4b73-8546-505fcac311cc",
        "parentId" : "64942fb8-3b8f-4b7a-be31-383fc9e68194",
        "authorId" : "9ebd32c2-a201-4916-b445-508ea7e87449",
        "body" : "What I'm saying is Nginx doesn't look like a good option overall, really. Kubernetes desperately needs a proper authentication.\n",
        "createdAt" : "2014-09-05T14:34:15Z",
        "updatedAt" : "2014-09-11T20:48:09Z",
        "lastEditedBy" : "9ebd32c2-a201-4916-b445-508ea7e87449",
        "tags" : [
        ]
      },
      {
        "id" : "d1a96112-f513-4bfe-92d3-ac4ab65c7cfe",
        "parentId" : "64942fb8-3b8f-4b7a-be31-383fc9e68194",
        "authorId" : "80f34a24-30a1-428f-b1a4-f0a97621bb6f",
        "body" : "There is a simple fix for that, I tried it locally with nginx running, you do basic auth, with an exception for the OPTIONS method.  I tried it out the other day and that worked. I'll add that patch to the kubernetes-site nginx config file.\n",
        "createdAt" : "2014-09-05T15:09:00Z",
        "updatedAt" : "2014-09-11T20:48:09Z",
        "lastEditedBy" : "80f34a24-30a1-428f-b1a4-f0a97621bb6f",
        "tags" : [
        ]
      },
      {
        "id" : "c70c9711-729e-463f-8c6a-35b46a5ebe9d",
        "parentId" : "64942fb8-3b8f-4b7a-be31-383fc9e68194",
        "authorId" : "80f34a24-30a1-428f-b1a4-f0a97621bb6f",
        "body" : "For reference in the mean time, this is what im referring to:\n\n```\n      limit_except OPTIONS {\n        auth_basic            \"Restricted\";\n        auth_basic_user_file  /usr/share/nginx/htpasswd;\n      }\n```\n",
        "createdAt" : "2014-09-05T15:13:05Z",
        "updatedAt" : "2014-09-11T20:48:09Z",
        "lastEditedBy" : "80f34a24-30a1-428f-b1a4-f0a97621bb6f",
        "tags" : [
        ]
      }
    ],
    "commit" : "0f2b8f4f9f68fe621bc8dd7b5df361f934aa9b79",
    "line" : 85,
    "diffHunk" : "@@ -1,1 +83,87 @@\n\t\t\t\t// Stop here if its a preflight OPTIONS request\n\t\t\t\tif req.Method == \"OPTIONS\" {\n\t\t\t\t\tw.WriteHeader(http.StatusNoContent)\n\t\t\t\t\treturn"
  }
]
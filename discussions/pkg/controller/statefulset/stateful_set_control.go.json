[
  {
    "id" : "7d2a6ca9-4dac-4a2a-874b-03dcf199e00e",
    "prId" : 86097,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/86097#pullrequestreview-333564726",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d396767d-f183-4295-a41d-309b01e300e3",
        "parentId" : null,
        "authorId" : "9976b70a-b2de-40bb-9ee8-0738e6d1942a",
        "body" : "Why was this change made ? I dont see this being used in the patch.",
        "createdAt" : "2019-12-17T17:05:14Z",
        "updatedAt" : "2020-02-18T18:43:44Z",
        "lastEditedBy" : "9976b70a-b2de-40bb-9ee8-0738e6d1942a",
        "tags" : [
        ]
      },
      {
        "id" : "f579aaa2-7e4b-4f59-92b4-faaf2bc6798a",
        "parentId" : "d396767d-f183-4295-a41d-309b01e300e3",
        "authorId" : "77d9a573-96ca-4cd7-807c-2fcd0c1c44d9",
        "body" : "It seems Intellij configuration automatically added it. To avoid reverting every time, I would prefer to leave it here.",
        "createdAt" : "2019-12-17T20:38:46Z",
        "updatedAt" : "2020-02-18T18:43:44Z",
        "lastEditedBy" : "77d9a573-96ca-4cd7-807c-2fcd0c1c44d9",
        "tags" : [
        ]
      }
    ],
    "commit" : "89bb7d845415206a25b6676eba99a95b6d94af94",
    "line" : 8,
    "diffHunk" : "@@ -1,1 +22,26 @@\n\tapps \"k8s.io/api/apps/v1\"\n\tv1 \"k8s.io/api/core/v1\"\n\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n\tutilerrors \"k8s.io/apimachinery/pkg/util/errors\""
  },
  {
    "id" : "edc6b7c6-9228-435c-8b19-a2b67cd297c4",
    "prId" : 62943,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/62943#pullrequestreview-115421566",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e916ea8d-2b9f-457c-9666-59e79757f495",
        "parentId" : null,
        "authorId" : "ec801d33-3a38-47a2-a267-f72db1de574b",
        "body" : "don't you need to change this also in https://github.com/kubernetes/kubernetes/pull/62943/files#diff-daa5b073ddfa8e3390bee583280edb5bR383 ?",
        "createdAt" : "2018-04-25T12:18:57Z",
        "updatedAt" : "2018-04-26T01:46:29Z",
        "lastEditedBy" : "ec801d33-3a38-47a2-a267-f72db1de574b",
        "tags" : [
        ]
      },
      {
        "id" : "aff1dc4d-9460-473e-8811-c9b29c35e8f7",
        "parentId" : "e916ea8d-2b9f-457c-9666-59e79757f495",
        "authorId" : "a0924036-651c-4b13-860f-aec6bfa99f4e",
        "body" : "Yes I will have updated PR soon. Thanks. ",
        "createdAt" : "2018-04-25T21:07:31Z",
        "updatedAt" : "2018-04-26T01:46:29Z",
        "lastEditedBy" : "a0924036-651c-4b13-860f-aec6bfa99f4e",
        "tags" : [
        ]
      },
      {
        "id" : "27e62553-4a4a-4d01-b893-90ca43f0daf0",
        "parentId" : "e916ea8d-2b9f-457c-9666-59e79757f495",
        "authorId" : "a0924036-651c-4b13-860f-aec6bfa99f4e",
        "body" : "@mfojtik pushed an update, PTAL",
        "createdAt" : "2018-04-26T03:37:44Z",
        "updatedAt" : "2018-04-26T03:37:44Z",
        "lastEditedBy" : "a0924036-651c-4b13-860f-aec6bfa99f4e",
        "tags" : [
        ]
      }
    ],
    "commit" : "594e228a17d340c14a46b6673b25f4941acc1baf",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +299,303 @@\t\t\t\tstatus.CurrentReplicas++\n\t\t\t}\n\t\t\tif getPodRevision(pods[i]) == updateRevision.Name {\n\t\t\t\tstatus.UpdatedReplicas++\n\t\t\t}"
  },
  {
    "id" : "587233aa-24f5-46d5-ac53-5f57fb0a2908",
    "prId" : 55316,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/55316#pullrequestreview-87479254",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3837464c-eb8a-4f05-8d57-d90c50ef2f5c",
        "parentId" : null,
        "authorId" : "ec801d33-3a38-47a2-a267-f72db1de574b",
        "body" : "if the pod fail after recreate, because no nodes are available or something is permanently broken in the pod (like a service it depends on is down), how often will this event occur?",
        "createdAt" : "2018-01-09T10:31:32Z",
        "updatedAt" : "2018-01-09T10:31:32Z",
        "lastEditedBy" : "ec801d33-3a38-47a2-a267-f72db1de574b",
        "tags" : [
        ]
      },
      {
        "id" : "3011cfe6-bbab-44e0-90f2-7c50741fa6e4",
        "parentId" : "3837464c-eb8a-4f05-8d57-d90c50ef2f5c",
        "authorId" : "443f9b92-20b0-45c2-a13f-20c6f64f89eb",
        "body" : "It should be a one off. Pods with restart policy Always can fail on node down, but won't get scheduled there again as the node is down.",
        "createdAt" : "2018-01-09T10:58:04Z",
        "updatedAt" : "2018-01-09T10:58:04Z",
        "lastEditedBy" : "443f9b92-20b0-45c2-a13f-20c6f64f89eb",
        "tags" : [
        ]
      }
    ],
    "commit" : "f6af1904cd0e017c6181c23d41e1281fd4a9b198",
    "line" : 32,
    "diffHunk" : "@@ -1,1 +371,375 @@\t\t// delete and recreate failed pods\n\t\tif isFailed(replicas[i]) {\n\t\t\tssc.recorder.Eventf(set, v1.EventTypeWarning, \"RecreatingFailedPod\",\n\t\t\t\t\"StatefulSet %s/%s is recreating failed Pod %s\",\n\t\t\t\tset.Namespace,"
  },
  {
    "id" : "bfc8ca04-a05e-49a0-ab5d-3ceb0125144f",
    "prId" : 51199,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/51199#pullrequestreview-64663476",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1e01697b-0a5f-4cc0-849a-7b0dd8edae6f",
        "parentId" : null,
        "authorId" : "97dce74b-9a86-4bd2-812f-a7a70df47473",
        "body" : "I tried a manual test of this and found a bug. We also need to put the check for hostname/subdomain back into `identityMatches()`, or else this doesn't trigger.",
        "createdAt" : "2017-09-22T18:32:46Z",
        "updatedAt" : "2017-09-25T22:36:28Z",
        "lastEditedBy" : "97dce74b-9a86-4bd2-812f-a7a70df47473",
        "tags" : [
        ]
      }
    ],
    "commit" : "4373f33c0ef53dc259fe4d5ff07858825527038c",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +408,412 @@\t\t// controller can be notified of identity changes if a Pod becomes unready due to a DNS inconsistency with respect\n\t\t// to the Pods identity.\n\t\tif !identityMatches(set, replicas[i]) || !storageMatches(set, replicas[i]) {\n\t\t\t// Make a deep copy so we don't mutate the shared cache\n\t\t\tcopy, err := scheme.Scheme.DeepCopy(replicas[i])"
  },
  {
    "id" : "4d4afad2-1969-449b-89d5-7421a4295c3c",
    "prId" : 46669,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/46669#pullrequestreview-41321918",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f831d035-5968-44de-96b6-33fa6bc5b45f",
        "parentId" : null,
        "authorId" : "224e1088-78fe-4bdd-99d1-31be3e464996",
        "body" : "what do you mean by destructive update ? burst mode ?",
        "createdAt" : "2017-05-31T05:33:18Z",
        "updatedAt" : "2017-06-06T20:47:39Z",
        "lastEditedBy" : "224e1088-78fe-4bdd-99d1-31be3e464996",
        "tags" : [
        ]
      },
      {
        "id" : "904ba056-3404-442e-b21c-70036546e8b4",
        "parentId" : "f831d035-5968-44de-96b6-33fa6bc5b45f",
        "authorId" : "6935d5b2-c3de-4596-9c98-055bd55df973",
        "body" : "Its destructive in that we have to kill the Pod to recreate it at the correct revision because in place updates are not possible.",
        "createdAt" : "2017-05-31T18:48:09Z",
        "updatedAt" : "2017-06-06T20:47:39Z",
        "lastEditedBy" : "6935d5b2-c3de-4596-9c98-055bd55df973",
        "tags" : [
        ]
      }
    ],
    "commit" : "1a784ef86ff94994e984753d885ffeff6e1772ac",
    "line" : 500,
    "diffHunk" : "@@ -1,1 +482,486 @@\t}\n\n\t// we compute the minimum ordinal of the target sequence for a destructive update based on the strategy.\n\tupdateMin := 0\n\tif set.Spec.UpdateStrategy.Type == apps.PartitionStatefulSetStrategyType {"
  },
  {
    "id" : "0055ab09-8019-4ca1-ba84-350855aa7c81",
    "prId" : 46669,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/46669#pullrequestreview-41948839",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "72b5ce1a-bbda-4fb7-84e1-45ecbf937aac",
        "parentId" : null,
        "authorId" : "224e1088-78fe-4bdd-99d1-31be3e464996",
        "body" : "can you burst in the partitioned strategy case ? Dont see it handled here ",
        "createdAt" : "2017-05-31T05:49:11Z",
        "updatedAt" : "2017-06-06T20:47:39Z",
        "lastEditedBy" : "224e1088-78fe-4bdd-99d1-31be3e464996",
        "tags" : [
        ]
      },
      {
        "id" : "b410ecec-9538-44bc-9503-09830135b02e",
        "parentId" : "72b5ce1a-bbda-4fb7-84e1-45ecbf937aac",
        "authorId" : "6935d5b2-c3de-4596-9c98-055bd55df973",
        "body" : "burst is handled in the partitioned case. You can't burst the update, but you can remove ordering from Pod creation. stateful_set_control.go adds a test for this.",
        "createdAt" : "2017-06-01T03:16:18Z",
        "updatedAt" : "2017-06-06T20:47:39Z",
        "lastEditedBy" : "6935d5b2-c3de-4596-9c98-055bd55df973",
        "tags" : [
        ]
      },
      {
        "id" : "1f7bfca7-08ad-4931-9be7-098ba1f95083",
        "parentId" : "72b5ce1a-bbda-4fb7-84e1-45ecbf937aac",
        "authorId" : "224e1088-78fe-4bdd-99d1-31be3e464996",
        "body" : "I see Partitioned handled only for deletion but not for updation, probably i am not understanding it @kow3ns ",
        "createdAt" : "2017-06-01T04:04:31Z",
        "updatedAt" : "2017-06-06T20:47:39Z",
        "lastEditedBy" : "224e1088-78fe-4bdd-99d1-31be3e464996",
        "tags" : [
        ]
      },
      {
        "id" : "811e78bd-d83e-4281-9d18-57abc6cd8aa5",
        "parentId" : "72b5ce1a-bbda-4fb7-84e1-45ecbf937aac",
        "authorId" : "6935d5b2-c3de-4596-9c98-055bd55df973",
        "body" : "The code you point to above decides if a Pod should be deleted. \r\n1. The method short circuits for OnDeleteStatefulSetStrategy. As in the designm Pods are not terminated with this strategy. Update occurs only when the pod is terminated externally.\r\n1. updateMin is set to 0 by default, we can't have an OnDeleteStatefulSetStrategy here because we've returned control above if did.\r\n1. If the strategy is PartitionedStatefulSetStrategy than the updateMin is set to the Partition, otherwise it's still 0, and we have a RollingUpdateStatefulSetStrategy.\r\n1. In the loop below, we walk backward across the replicas to determine the first one that does not match the update revision. We terminate that replica, and we wait for it to be completely deleted before we attempt to apply another update.\r\n1. Therefore, if we are partitioned, we only considered the update partition sequence for targeted termination, and if we are rolling, we consider the entire sequence. For on delete, we do nothing.\r\n1. Also note that, as per the design, scaling takes precedence and is handled prior to termination for update.\r\n\r\nThe code below creates new replicas\r\n```golang\r\nreplicas[i] = newVersionedStatefulSetPod(currentSet,updateSet,currentRevision.Name,updateRevision.Nam,i)\r\n```\r\n\r\nIf you look at the internals of that method, you will see that it decides which version a replica should be at based on whether it is being tracked as a current or updated replica and on the selected strategy.\r\n\r\n```golang\r\n// newVersionedStatefulSetPod creates a new Pod for a StatefulSet. currentSet is the representation of the set at the\r\n// current revision. updateSet is the representation of the set at the updateRevision. currentRevision is the name of\r\n// the current revision. updateRevision is the name of the update revision. ordinal is the ordinal of the Pod. If the\r\n// returned error is nil, the returned Pod is valid.\r\nfunc newVersionedStatefulSetPod(currentSet *apps.StatefulSet, updateSet *apps.StatefulSet, currentRevision string, updateRevision string, ordinal int) *v1.Pod {\r\n\tif (currentSet.Spec.UpdateStrategy.Type == apps.RollingUpdateStatefulSetStrategyType &&\r\n\t\tordinal < int(currentSet.Status.CurrentReplicas)) ||\r\n\t\t(currentSet.Spec.UpdateStrategy.Type == apps.PartitionStatefulSetStrategyType &&\r\n\t\t\tordinal < int(currentSet.Spec.UpdateStrategy.Partition.Ordinal)) {\r\n\t\tpod := newStatefulSetPod(currentSet, ordinal)\r\n\t\tsetPodRevision(pod, currentRevision)\r\n\t\treturn pod\r\n\t}\r\n\tpod := newStatefulSetPod(updateSet, ordinal)\r\n\tsetPodRevision(pod, updateRevision)\r\n\treturn pod\r\n}\r\n```\r\n1. If its a current replica we create the replica from the current revision, respecting the partition for the PartitionedStatefulSetStrategy.\r\n1. Otherwise we create it from the update version.\r\n\r\n",
        "createdAt" : "2017-06-02T00:34:36Z",
        "updatedAt" : "2017-06-06T20:47:39Z",
        "lastEditedBy" : "6935d5b2-c3de-4596-9c98-055bd55df973",
        "tags" : [
        ]
      },
      {
        "id" : "d9746e7c-f02b-442e-9d6b-69e6f3207803",
        "parentId" : "72b5ce1a-bbda-4fb7-84e1-45ecbf937aac",
        "authorId" : "224e1088-78fe-4bdd-99d1-31be3e464996",
        "body" : "@kow3ns thanks very helpful.",
        "createdAt" : "2017-06-04T19:16:12Z",
        "updatedAt" : "2017-06-06T20:47:39Z",
        "lastEditedBy" : "224e1088-78fe-4bdd-99d1-31be3e464996",
        "tags" : [
        ]
      }
    ],
    "commit" : "1a784ef86ff94994e984753d885ffeff6e1772ac",
    "line" : 502,
    "diffHunk" : "@@ -1,1 +484,488 @@\t// we compute the minimum ordinal of the target sequence for a destructive update based on the strategy.\n\tupdateMin := 0\n\tif set.Spec.UpdateStrategy.Type == apps.PartitionStatefulSetStrategyType {\n\t\tupdateMin = int(set.Spec.UpdateStrategy.Partition.Ordinal)\n\t}"
  },
  {
    "id" : "e1aae558-0d34-4623-80b7-fe5c15f18012",
    "prId" : 46669,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/46669#pullrequestreview-41410481",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f668f2d1-3b8b-441d-ac82-c135e65cbe91",
        "parentId" : null,
        "authorId" : "224e1088-78fe-4bdd-99d1-31be3e464996",
        "body" : "may be add a comment. It seems we will always make a new revision for statefulset during update, even though equivalent previous revisions exist , right ?",
        "createdAt" : "2017-06-01T03:48:28Z",
        "updatedAt" : "2017-06-06T20:47:39Z",
        "lastEditedBy" : "224e1088-78fe-4bdd-99d1-31be3e464996",
        "tags" : [
        ]
      },
      {
        "id" : "dac69799-8d0d-4ecc-b61c-51dc250babbe",
        "parentId" : "f668f2d1-3b8b-441d-ac82-c135e65cbe91",
        "authorId" : "6935d5b2-c3de-4596-9c98-055bd55df973",
        "body" : "It may not create it",
        "createdAt" : "2017-06-01T03:53:44Z",
        "updatedAt" : "2017-06-06T20:47:39Z",
        "lastEditedBy" : "6935d5b2-c3de-4596-9c98-055bd55df973",
        "tags" : [
        ]
      }
    ],
    "commit" : "1a784ef86ff94994e984753d885ffeff6e1772ac",
    "line" : 171,
    "diffHunk" : "@@ -1,1 +187,191 @@\n\t// create a new revision from the current set\n\tupdateRevision, err := newRevision(set, nextRevision(revisions))\n\tif err != nil {\n\t\treturn nil, nil, err"
  },
  {
    "id" : "21bdb165-cf4c-4c48-be2a-07c6012507fb",
    "prId" : 46669,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/46669#pullrequestreview-41410520",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3311b8b9-0a41-4082-9b24-221015610c0b",
        "parentId" : null,
        "authorId" : "224e1088-78fe-4bdd-99d1-31be3e464996",
        "body" : "since you are comparing with last equalRevisions, the equalRevisions should be sorted.",
        "createdAt" : "2017-06-01T03:49:48Z",
        "updatedAt" : "2017-06-06T20:47:39Z",
        "lastEditedBy" : "224e1088-78fe-4bdd-99d1-31be3e464996",
        "tags" : [
        ]
      },
      {
        "id" : "8da23077-e75f-461c-8e3e-211b886bc182",
        "parentId" : "3311b8b9-0a41-4082-9b24-221015610c0b",
        "authorId" : "6935d5b2-c3de-4596-9c98-055bd55df973",
        "body" : "it is sorted by I will add a comment about the methods expectation of the supplied parameter.",
        "createdAt" : "2017-06-01T03:54:22Z",
        "updatedAt" : "2017-06-06T20:47:39Z",
        "lastEditedBy" : "6935d5b2-c3de-4596-9c98-055bd55df973",
        "tags" : [
        ]
      }
    ],
    "commit" : "1a784ef86ff94994e984753d885ffeff6e1772ac",
    "line" : 180,
    "diffHunk" : "@@ -1,1 +196,200 @@\tequalCount := len(equalRevisions)\n\n\tif equalCount > 0 && history.EqualRevision(revisions[revisionCount-1], equalRevisions[equalCount-1]) {\n\t\t// if the equivalent revision is immediately prior the update revision has not changed\n\t\tupdateRevision = revisions[revisionCount-1]"
  },
  {
    "id" : "09cc049a-3723-4d56-b65f-e7da4e272a71",
    "prId" : 46669,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/46669#pullrequestreview-41414137",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e11bf62c-ff9a-47f1-8066-a89118c5ebad",
        "parentId" : null,
        "authorId" : "224e1088-78fe-4bdd-99d1-31be3e464996",
        "body" : "it looks like this is the only case when we should be creating a new revision, move the line `updateRevision, err := newRevision(set, nextRevision(revisions))` here ",
        "createdAt" : "2017-06-01T03:51:47Z",
        "updatedAt" : "2017-06-06T20:47:39Z",
        "lastEditedBy" : "224e1088-78fe-4bdd-99d1-31be3e464996",
        "tags" : [
        ]
      },
      {
        "id" : "efe9f48b-1d63-488c-95d2-291d294669c1",
        "parentId" : "e11bf62c-ff9a-47f1-8066-a89118c5ebad",
        "authorId" : "6935d5b2-c3de-4596-9c98-055bd55df973",
        "body" : "We need to create the revision in order to search for any equal revisions prior to the first conditional branch test.",
        "createdAt" : "2017-06-01T04:45:24Z",
        "updatedAt" : "2017-06-06T20:47:39Z",
        "lastEditedBy" : "6935d5b2-c3de-4596-9c98-055bd55df973",
        "tags" : [
        ]
      }
    ],
    "commit" : "1a784ef86ff94994e984753d885ffeff6e1772ac",
    "line" : 193,
    "diffHunk" : "@@ -1,1 +209,213 @@\t\t}\n\t} else {\n\t\t//if there is no equivalent revision we create a new one\n\t\tupdateRevision, err = ssc.controllerHistory.CreateControllerRevision(set, updateRevision)\n\t\tif err != nil {"
  },
  {
    "id" : "c2e2147e-17ef-4b2c-86ff-b1db9d4f4e2e",
    "prId" : 46669,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/46669#pullrequestreview-41952195",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c219a3a8-a37b-486a-92f8-83f2e53798b4",
        "parentId" : null,
        "authorId" : "224e1088-78fe-4bdd-99d1-31be3e464996",
        "body" : "nit: why do we care about the firstUnhealthyPod, when you get time, may be add a comment in subsequent PR",
        "createdAt" : "2017-06-04T19:41:49Z",
        "updatedAt" : "2017-06-06T20:47:39Z",
        "lastEditedBy" : "224e1088-78fe-4bdd-99d1-31be3e464996",
        "tags" : [
        ]
      },
      {
        "id" : "22d11202-91cd-4c43-9f2c-6dc5dc530340",
        "parentId" : "c219a3a8-a37b-486a-92f8-83f2e53798b4",
        "authorId" : "6935d5b2-c3de-4596-9c98-055bd55df973",
        "body" : "The are comments above where each check against the variable is made",
        "createdAt" : "2017-06-04T22:07:37Z",
        "updatedAt" : "2017-06-06T20:47:39Z",
        "lastEditedBy" : "6935d5b2-c3de-4596-9c98-055bd55df973",
        "tags" : [
        ]
      }
    ],
    "commit" : "1a784ef86ff94994e984753d885ffeff6e1772ac",
    "line" : 300,
    "diffHunk" : "@@ -1,1 +315,319 @@\tsort.Sort(ascendingOrdinal(condemned))\n\n\t// find the first unhealthy Pod\n\tfor i := range replicas {\n\t\tif !isHealthy(replicas[i]) {"
  },
  {
    "id" : "6fe8b060-6982-4783-a4fe-f1b968bf21fc",
    "prId" : 46669,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/46669#pullrequestreview-41952229",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ca93a13f-92ad-44c3-909f-9bfa64dbee69",
        "parentId" : null,
        "authorId" : "224e1088-78fe-4bdd-99d1-31be3e464996",
        "body" : "nit: add comment about the special handling of firstUnhealthPod",
        "createdAt" : "2017-06-04T19:44:12Z",
        "updatedAt" : "2017-06-06T20:47:39Z",
        "lastEditedBy" : "224e1088-78fe-4bdd-99d1-31be3e464996",
        "tags" : [
        ]
      },
      {
        "id" : "3e5fb9b6-451b-460a-a563-3378907c1844",
        "parentId" : "ca93a13f-92ad-44c3-909f-9bfa64dbee69",
        "authorId" : "224e1088-78fe-4bdd-99d1-31be3e464996",
        "body" : "is this checking saying that before we can delete or scale down, the extra pods must be healthy and running ? Is it for safety of clustered applications ?",
        "createdAt" : "2017-06-04T19:47:09Z",
        "updatedAt" : "2017-06-06T20:47:39Z",
        "lastEditedBy" : "224e1088-78fe-4bdd-99d1-31be3e464996",
        "tags" : [
        ]
      },
      {
        "id" : "ead35edc-26a6-4a82-8823-c8d02d320d25",
        "parentId" : "ca93a13f-92ad-44c3-909f-9bfa64dbee69",
        "authorId" : "6935d5b2-c3de-4596-9c98-055bd55df973",
        "body" : "Yes. As documented, the StatefulSet guarantees for monotonic mode (the original mode) is that the predecessors (wrt ordinal) of every Pod are running and ready before a new Pod is created. ",
        "createdAt" : "2017-06-04T22:09:46Z",
        "updatedAt" : "2017-06-06T20:47:39Z",
        "lastEditedBy" : "6935d5b2-c3de-4596-9c98-055bd55df973",
        "tags" : [
        ]
      }
    ],
    "commit" : "1a784ef86ff94994e984753d885ffeff6e1772ac",
    "line" : 467,
    "diffHunk" : "@@ -1,1 +451,455 @@\t\t}\n\t\t// if we are in monotonic mode and the condemned target is not the first unhealthy Pod block\n\t\tif !isRunningAndReady(condemned[target]) && monotonic && condemned[target] != firstUnhealthyPod {\n\t\t\tglog.V(4).Infof(\n\t\t\t\t\"StatefulSet %s/%s is waiting for Pod %s to be Running and Ready prior to scale down\","
  },
  {
    "id" : "e50eb37c-db25-4485-9752-ba98a6621359",
    "prId" : 44899,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/44899#pullrequestreview-35505939",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3d64f37f-11c1-451a-ac11-2b5bf50505f0",
        "parentId" : null,
        "authorId" : "11efe503-096f-46dd-a8c8-28ba38a0157a",
        "body" : "You want to continue here?",
        "createdAt" : "2017-04-27T09:08:24Z",
        "updatedAt" : "2017-05-21T20:01:36Z",
        "lastEditedBy" : "11efe503-096f-46dd-a8c8-28ba38a0157a",
        "tags" : [
        ]
      },
      {
        "id" : "2396fe1d-d78e-4609-ba52-78a481044cd7",
        "parentId" : "3d64f37f-11c1-451a-ac11-2b5bf50505f0",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "yes, if you are in burst mode we scale all them up immediately.",
        "createdAt" : "2017-04-28T15:29:59Z",
        "updatedAt" : "2017-05-21T20:01:36Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "31e7b7fe-1588-4c3a-a8b8-964bfc0431df",
        "parentId" : "3d64f37f-11c1-451a-ac11-2b5bf50505f0",
        "authorId" : "11efe503-096f-46dd-a8c8-28ba38a0157a",
        "body" : "I mean\r\n```go\r\nif !isCreated(replicas[i]) {\r\n   if err := ssc.podControl.CreateStatefulPod(set, replicas[i]); err != nil {\r\n\t\treturn err\r\n\t}\r\n   if monotonic {\r\n\t\treturn nil\r\n\t}\r\n   continue\r\n}\r\n```\r\nsince the replica you just created is not going to fall under any of the following cases.",
        "createdAt" : "2017-04-28T15:52:03Z",
        "updatedAt" : "2017-05-21T20:01:36Z",
        "lastEditedBy" : "11efe503-096f-46dd-a8c8-28ba38a0157a",
        "tags" : [
        ]
      },
      {
        "id" : "56308129-291b-4b70-86c2-39ef2bce141a",
        "parentId" : "3d64f37f-11c1-451a-ac11-2b5bf50505f0",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Ah, yes, thanks.",
        "createdAt" : "2017-04-29T22:47:53Z",
        "updatedAt" : "2017-05-21T20:01:36Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      }
    ],
    "commit" : "e40648de68a165a5abc0ccc45d813f7efde52731",
    "line" : 36,
    "diffHunk" : "@@ -1,1 +145,149 @@\t\t\tif monotonic {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\t// pod created, no more work possible for this round\n\t\t\tcontinue"
  },
  {
    "id" : "0fef0c45-822f-4038-ba45-8990b12f553b",
    "prId" : 44730,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/44730#pullrequestreview-34064639",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "37094fa1-fad1-4aa9-b743-ffe36681fb1c",
        "parentId" : null,
        "authorId" : "11efe503-096f-46dd-a8c8-28ba38a0157a",
        "body" : "This is debugging info - our prod installations run with v(2) and it's unlike that admins will care about these logs. Anyway, since v(2) is used across the controller, we can discuss in a follow-up issue.",
        "createdAt" : "2017-04-21T08:05:35Z",
        "updatedAt" : "2017-04-21T15:38:51Z",
        "lastEditedBy" : "11efe503-096f-46dd-a8c8-28ba38a0157a",
        "tags" : [
        ]
      },
      {
        "id" : "d1eb64fe-a88e-4203-8309-a4d744fe8014",
        "parentId" : "37094fa1-fad1-4aa9-b743-ffe36681fb1c",
        "authorId" : "11efe503-096f-46dd-a8c8-28ba38a0157a",
        "body" : "Opened https://github.com/kubernetes/community/issues/558 for more general discussion on the topic since it has come up lately quite a few times",
        "createdAt" : "2017-04-21T08:21:22Z",
        "updatedAt" : "2017-04-21T15:38:51Z",
        "lastEditedBy" : "11efe503-096f-46dd-a8c8-28ba38a0157a",
        "tags" : [
        ]
      },
      {
        "id" : "bda63d21-faee-4cbc-ab9b-58eb18311609",
        "parentId" : "37094fa1-fad1-4aa9-b743-ffe36681fb1c",
        "authorId" : "6935d5b2-c3de-4596-9c98-055bd55df973",
        "body" : "I think the log statements in this function are informational. Informational logs should meet the criteria of being useful to an administrator for diagnostics and mitigation on a running cluster. If a StatefulSet has been deployed, and if it is not making progress due to a Pod's condition, imo, this is useful to surface to an administrator via logs. \r\nI agree that the exhaust we produce in the controller manager logs make it difficult to discriminate what is useful vs what is not, and we need to look across the controllers at large and apply the existing, or another, convention to apply better filtering to our exhaust.",
        "createdAt" : "2017-04-21T15:52:04Z",
        "updatedAt" : "2017-04-21T15:52:04Z",
        "lastEditedBy" : "6935d5b2-c3de-4596-9c98-055bd55df973",
        "tags" : [
        ]
      },
      {
        "id" : "ae1ad587-33db-407f-89c6-db4c4dd46138",
        "parentId" : "37094fa1-fad1-4aa9-b743-ffe36681fb1c",
        "authorId" : "6935d5b2-c3de-4596-9c98-055bd55df973",
        "body" : "Also, other than the statements in this function that relate to Pod state and creation, which are considered to be V2 based on our conventions, everything else is V4, which is debug. ",
        "createdAt" : "2017-04-21T16:12:08Z",
        "updatedAt" : "2017-04-21T16:12:08Z",
        "lastEditedBy" : "6935d5b2-c3de-4596-9c98-055bd55df973",
        "tags" : [
        ]
      }
    ],
    "commit" : "7d22e642845fb0b87c5ef0157473ea3540b64fd8",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +136,140 @@\t\t// completes before we continue to make  progress.\n\t\tif isTerminating(replicas[i]) {\n\t\t\tglog.V(2).Infof(\"StatefulSet %s is waiting for Pod %s to Terminate\",\n\t\t\t\tset.Name, replicas[i].Name)\n\t\t\treturn nil"
  },
  {
    "id" : "7eb4aeb8-65ae-4920-86fb-b749007ef480",
    "prId" : 42080,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/42080#pullrequestreview-24946231",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a13c444c-8f11-419b-a8c8-946e1180a2a8",
        "parentId" : null,
        "authorId" : "11efe503-096f-46dd-a8c8-28ba38a0157a",
        "body" : "@kow3ns we should have a helper that would do just that - iterate over all pods and update the status accordingly.",
        "createdAt" : "2017-03-03T10:37:35Z",
        "updatedAt" : "2017-03-06T18:40:43Z",
        "lastEditedBy" : "11efe503-096f-46dd-a8c8-28ba38a0157a",
        "tags" : [
        ]
      },
      {
        "id" : "854465da-92d6-4e21-b0b0-51654a2d0947",
        "parentId" : "a13c444c-8f11-419b-a8c8-946e1180a2a8",
        "authorId" : "11efe503-096f-46dd-a8c8-28ba38a0157a",
        "body" : "For now, it seems that this check is in the right place.",
        "createdAt" : "2017-03-03T10:39:22Z",
        "updatedAt" : "2017-03-06T18:40:43Z",
        "lastEditedBy" : "11efe503-096f-46dd-a8c8-28ba38a0157a",
        "tags" : [
        ]
      }
    ],
    "commit" : "399c19a2ad551df4440e725266637d332bbbcd26",
    "line" : 15,
    "diffHunk" : "@@ -1,1 +116,120 @@\t// status.\n\tif set.DeletionTimestamp != nil {\n\t\treturn nil\n\t}\n"
  }
]
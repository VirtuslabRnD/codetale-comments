[
  {
    "id" : "26e25854-856d-44f3-bdcd-bae31c6bf812",
    "prId" : 92743,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/92743#pullrequestreview-504737781",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bb7d670e-6fad-4a48-9c74-dbd852f75c74",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "move to the top of the if block... honoring reality over virtual delete is the most important thing here",
        "createdAt" : "2020-10-08T13:48:39Z",
        "updatedAt" : "2020-11-17T15:49:59Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "e491c3bc7056530d82590d95f0af0e8c4d8dded5",
    "line" : 269,
    "diffHunk" : "@@ -1,1 +736,740 @@\t\t\t} else if existingNode.identity != deletedIdentity {\n\t\t\t\t// do not remove the existing real node from the graph based on a virtual delete event\n\t\t\t\tremoveExistingNode = false\n\n\t\t\t\t// our existing node which was observed via informer disagrees with the virtual delete event's coordinates"
  },
  {
    "id" : "4a38ac6d-4763-4eeb-9760-3de4e873253c",
    "prId" : 92743,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/92743#pullrequestreview-529489802",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "21d5ae0d-9db4-4773-ba91-24c284c3ca59",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "moved markObserved after cloning/replacing, so we don't mark the virtual node that disagreed with our coordinates as observed",
        "createdAt" : "2020-11-12T20:55:22Z",
        "updatedAt" : "2020-11-17T15:49:59Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "e491c3bc7056530d82590d95f0af0e8c4d8dded5",
    "line" : 200,
    "diffHunk" : "@@ -1,1 +655,659 @@\t\t\tgb.uidToNode.Write(existingNode)\n\t\t}\n\t\texistingNode.markObserved()\n\t}\n\tswitch {"
  },
  {
    "id" : "7f38855b-184e-4de5-8540-e4792d299fa4",
    "prId" : 63444,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/63444#pullrequestreview-123338924",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fb1e8003-da5e-477b-860c-c6d840d8e572",
        "parentId" : null,
        "authorId" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "body" : "This is going to increase the memory usage, as the metaonly client will only store the metadata of the objects. \r\n\r\nThis only affects custom resources and aggregated resources. It doesn't matter for kubernetes core resources, which are stored in the shared informer and won't hit this line.\r\n\r\nCan we plumb a \"metaonly\" decoder to the simple dynamic client?",
        "createdAt" : "2018-05-04T19:17:02Z",
        "updatedAt" : "2018-05-07T13:00:58Z",
        "lastEditedBy" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "tags" : [
        ]
      },
      {
        "id" : "304688cf-cdfd-487f-a0d9-c2a22f5d55de",
        "parentId" : "fb1e8003-da5e-477b-860c-c6d840d8e572",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "we weren't using the metaonly client before, were we?",
        "createdAt" : "2018-05-04T19:24:56Z",
        "updatedAt" : "2018-05-07T13:00:58Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "11aec644-3529-4d72-9a6e-29f67b78afc2",
        "parentId" : "fb1e8003-da5e-477b-860c-c6d840d8e572",
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "> This is going to increase the memory usage, as the metaonly client will only store the metadata of the objects.\r\n> \r\n> This only affects custom resources and aggregated resources. It doesn't matter for kubernetes core resources, which are stored in the shared informer and won't hit this line.\r\n> \r\n> Can we plumb a \"metaonly\" decoder to the simple dynamic client?\r\n\r\nmetaonly was just a normal dynamic client pool..  The name was a lie! :)\r\n\r\n",
        "createdAt" : "2018-05-04T19:37:23Z",
        "updatedAt" : "2018-05-07T13:00:58Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      },
      {
        "id" : "fd34b08a-0226-47ff-b9cd-41610b0762cd",
        "parentId" : "fb1e8003-da5e-477b-860c-c6d840d8e572",
        "authorId" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "body" : "Ah, right.",
        "createdAt" : "2018-05-04T21:03:47Z",
        "updatedAt" : "2018-05-07T13:00:58Z",
        "lastEditedBy" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "tags" : [
        ]
      },
      {
        "id" : "849e725d-bc48-48a7-a5f5-35c5b43896c5",
        "parentId" : "fb1e8003-da5e-477b-860c-c6d840d8e572",
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "placebo optimization by renaming :D",
        "createdAt" : "2018-05-25T11:40:09Z",
        "updatedAt" : "2018-05-25T11:40:10Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      }
    ],
    "commit" : "cf4f7aab65ff3e0f639384743d9514ef1d050c5f",
    "line" : 51,
    "diffHunk" : "@@ -1,1 +190,194 @@\tglog.V(5).Infof(\"create storage for resource %s\", resource)\n\t_, monitor := cache.NewInformer(\n\t\tlistWatcher(gb.dynamicClient, resource),\n\t\tnil,\n\t\tResourceResyncTime,"
  },
  {
    "id" : "448c5f14-88e9-4324-a68a-c674b3bce8fb",
    "prId" : 55772,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/55772#pullrequestreview-76790827",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4c525e25-79ba-44e6-8297-5ec4ec3467a6",
        "parentId" : null,
        "authorId" : "f04ec747-f3ff-4334-a66e-6daaf4497091",
        "body" : "D'oh, good catch!",
        "createdAt" : "2017-11-15T14:03:06Z",
        "updatedAt" : "2017-11-15T14:03:06Z",
        "lastEditedBy" : "f04ec747-f3ff-4334-a66e-6daaf4497091",
        "tags" : [
        ]
      }
    ],
    "commit" : "dbfc43f723001a532557785891a6f0696c9404c6",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +231,235 @@\tadded := 0\n\tfor resource := range resources {\n\t\tif _, ok := gb.ignoredResources[resource.GroupResource()]; ok {\n\t\t\tcontinue\n\t\t}"
  },
  {
    "id" : "09fa790f-e9db-4f53-83ef-b779ca33f08d",
    "prId" : 47665,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/47665#pullrequestreview-46245325",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c39985bc-8f5b-400b-8ff0-7a2d330f8d6b",
        "parentId" : null,
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "Why don't we make them stop channels here?",
        "createdAt" : "2017-06-22T19:31:34Z",
        "updatedAt" : "2017-07-28T14:00:27Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      },
      {
        "id" : "ab80803c-153d-4fde-b6c5-1fff85d9ee2f",
        "parentId" : "c39985bc-8f5b-400b-8ff0-7a2d330f8d6b",
        "authorId" : "f04ec747-f3ff-4334-a66e-6daaf4497091",
        "body" : "Using a `nil` stop channel to indicate the monitor's start/stopped state.",
        "createdAt" : "2017-06-22T21:24:22Z",
        "updatedAt" : "2017-07-28T14:00:27Z",
        "lastEditedBy" : "f04ec747-f3ff-4334-a66e-6daaf4497091",
        "tags" : [
        ]
      },
      {
        "id" : "2988b48c-66ce-49bc-af31-083936c77366",
        "parentId" : "c39985bc-8f5b-400b-8ff0-7a2d330f8d6b",
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "> Using a nil stop channel to indicate the monitor's start/stopped state.\r\n\r\ndoced and I didn't read to it before commenting her?",
        "createdAt" : "2017-06-26T12:23:05Z",
        "updatedAt" : "2017-07-28T14:00:27Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      }
    ],
    "commit" : "d08dfb92c71960dba663f7a8e6465a93ddf5c560",
    "line" : 141,
    "diffHunk" : "@@ -1,1 +251,255 @@\t\t\tcontinue\n\t\t}\n\t\tcurrent[resource] = &monitor{controller: c}\n\t\tadded++\n\t}"
  },
  {
    "id" : "dd6e1ce3-03c5-40b4-8a6d-87b2338ddfcb",
    "prId" : 45427,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/45427#pullrequestreview-39069652",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "55d4cb7f-371c-444a-9e5c-412d6ae6625a",
        "parentId" : null,
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "I don't see where you're restarting the shared informers.  This could suddenly start watching a previously unwatched resource, so you'll need to be sure that you start the informers again.",
        "createdAt" : "2017-05-08T15:12:38Z",
        "updatedAt" : "2017-05-22T16:51:54Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      },
      {
        "id" : "28ff0a4c-df37-473e-be00-434d9a34436a",
        "parentId" : "55d4cb7f-371c-444a-9e5c-412d6ae6625a",
        "authorId" : "b15d5707-82a8-4448-b49d-a2d6502b10f9",
        "body" : "Good point",
        "createdAt" : "2017-05-16T02:20:52Z",
        "updatedAt" : "2017-05-22T16:51:54Z",
        "lastEditedBy" : "b15d5707-82a8-4448-b49d-a2d6502b10f9",
        "tags" : [
        ]
      },
      {
        "id" : "81e63909-51d4-44aa-8444-9febe3ab443a",
        "parentId" : "55d4cb7f-371c-444a-9e5c-412d6ae6625a",
        "authorId" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "body" : "Yeah, the informer needs to restart when gc restarts.",
        "createdAt" : "2017-05-16T03:04:41Z",
        "updatedAt" : "2017-05-22T16:51:54Z",
        "lastEditedBy" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "tags" : [
        ]
      },
      {
        "id" : "9db3031d-f2e8-48f4-abe7-c1fbf004174c",
        "parentId" : "55d4cb7f-371c-444a-9e5c-412d6ae6625a",
        "authorId" : "b15d5707-82a8-4448-b49d-a2d6502b10f9",
        "body" : "The current flow with this PR looks like this:\r\n\r\n1. Create GC controller\r\n    1. Create \"monitors\" aka controllers and set up event handlers\r\n1. Run GC controller\r\n    1. Call `Run()` on all the monitors. If the monitor is a dummy controller from a shared informer, this will be a no-op. Otherwise, it will start the lister/watcher/reflector from the non-shared controller.\r\n1. Instantiate and run various other controllers\r\n1. Start the shared informers\r\n\r\nGiven that the GC controller doesn't currently reread discovery and create new monitors for newly seen resources (or does it???), can we punt on this for now?",
        "createdAt" : "2017-05-16T15:07:41Z",
        "updatedAt" : "2017-05-22T16:51:54Z",
        "lastEditedBy" : "b15d5707-82a8-4448-b49d-a2d6502b10f9",
        "tags" : [
        ]
      },
      {
        "id" : "568683a2-58ce-430c-bdd8-24c7a365330c",
        "parentId" : "55d4cb7f-371c-444a-9e5c-412d6ae6625a",
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "> Given that the GC controller doesn't currently reread discovery and create new monitors for newly seen resources (or does it???), can we punt on this for now?\r\n\r\nIt will happens in 1.7.  I guess it doesn't have to be this pull, but definitely place a comment.",
        "createdAt" : "2017-05-16T15:13:10Z",
        "updatedAt" : "2017-05-22T16:51:54Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      },
      {
        "id" : "d60642c9-91e5-41c9-a0ad-04c98515ae35",
        "parentId" : "55d4cb7f-371c-444a-9e5c-412d6ae6625a",
        "authorId" : "b15d5707-82a8-4448-b49d-a2d6502b10f9",
        "body" : "I actually thought about it some more and I think I can put the plumbing in place that you'll need, but not use it yet.",
        "createdAt" : "2017-05-16T15:15:51Z",
        "updatedAt" : "2017-05-22T16:51:54Z",
        "lastEditedBy" : "b15d5707-82a8-4448-b49d-a2d6502b10f9",
        "tags" : [
        ]
      },
      {
        "id" : "2dea2226-79e5-49ca-b463-15eeb5c87902",
        "parentId" : "55d4cb7f-371c-444a-9e5c-412d6ae6625a",
        "authorId" : "b15d5707-82a8-4448-b49d-a2d6502b10f9",
        "body" : "Actually, it's not like custom resources are going to have generated shared informers for them...",
        "createdAt" : "2017-05-16T15:17:00Z",
        "updatedAt" : "2017-05-22T16:51:54Z",
        "lastEditedBy" : "b15d5707-82a8-4448-b49d-a2d6502b10f9",
        "tags" : [
        ]
      },
      {
        "id" : "f7a67767-f050-41c8-b49f-7f63909635a9",
        "parentId" : "55d4cb7f-371c-444a-9e5c-412d6ae6625a",
        "authorId" : "b15d5707-82a8-4448-b49d-a2d6502b10f9",
        "body" : "Updated, PTAL",
        "createdAt" : "2017-05-16T15:39:35Z",
        "updatedAt" : "2017-05-22T16:51:54Z",
        "lastEditedBy" : "b15d5707-82a8-4448-b49d-a2d6502b10f9",
        "tags" : [
        ]
      },
      {
        "id" : "d606d963-b352-494c-85d5-987009986c76",
        "parentId" : "55d4cb7f-371c-444a-9e5c-412d6ae6625a",
        "authorId" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "body" : "Let me check what sharedInformer.Run() does.",
        "createdAt" : "2017-05-16T23:47:59Z",
        "updatedAt" : "2017-05-22T16:51:54Z",
        "lastEditedBy" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "tags" : [
        ]
      },
      {
        "id" : "971a1c73-690c-4cdf-a929-e308ebac8ed3",
        "parentId" : "55d4cb7f-371c-444a-9e5c-412d6ae6625a",
        "authorId" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "body" : "Do all controllers (gc, replicaset controller, etc.) always restart at the same time? I think it's true, so i think the current PR works.",
        "createdAt" : "2017-05-17T00:14:03Z",
        "updatedAt" : "2017-05-22T16:51:54Z",
        "lastEditedBy" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "tags" : [
        ]
      },
      {
        "id" : "b22ca8f4-b371-4d12-a65a-84ac8a95e286",
        "parentId" : "55d4cb7f-371c-444a-9e5c-412d6ae6625a",
        "authorId" : "b15d5707-82a8-4448-b49d-a2d6502b10f9",
        "body" : "@caesarxuchao what are you referring to re controllers restarting? AFAIK all controllers start when the kube-controller-manager starts, and they all stop when that process terminates.",
        "createdAt" : "2017-05-17T01:26:39Z",
        "updatedAt" : "2017-05-22T16:51:54Z",
        "lastEditedBy" : "b15d5707-82a8-4448-b49d-a2d6502b10f9",
        "tags" : [
        ]
      },
      {
        "id" : "49104191-2e57-422f-b546-2063f6712772",
        "parentId" : "55d4cb7f-371c-444a-9e5c-412d6ae6625a",
        "authorId" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "body" : "Please ignore the \"restarting\" part. What i was concerned with is the following situation: the shared informer had started by other controllers, then GC starts, and it misses the earlier events. This case seems to be impossible since GC calls Run() on all monitors when it starts.\r\n\r\nBut will other controllers call Run() on a shared informer? Will that cause GC see duplicate events (though GC should operate correctly if there are duplicate events)?",
        "createdAt" : "2017-05-17T21:37:15Z",
        "updatedAt" : "2017-05-22T16:51:54Z",
        "lastEditedBy" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "tags" : [
        ]
      },
      {
        "id" : "bdab943a-dd49-4284-9eab-ae24e1607c59",
        "parentId" : "55d4cb7f-371c-444a-9e5c-412d6ae6625a",
        "authorId" : "b15d5707-82a8-4448-b49d-a2d6502b10f9",
        "body" : "There are 3 similar functions that can start these things:\r\n\r\n1. shared informer factory `Start()` - this starts any initialized but unstarted shared informers in the factory. It's a no-op for ones that are already started.\r\n1. shared informer `Run()` - this starts running the given shared informer, and is what (1) calls. This is never invoked anywhere in the GC controller code.\r\n1. controller `Run()` - this runs a controller, and is what the GC controller calls when it's starting monitors. For shared informers, they return a dummy controller whose Run() implementation is a no-op, so we're safe here.\r\n\r\nThere is a potential danger if multiple callers invoke a shared informer's Run() function, and we should probably guard against that happening, but it's not in the code right now.\r\n\r\nDoes this answer your question?",
        "createdAt" : "2017-05-18T15:05:56Z",
        "updatedAt" : "2017-05-22T16:51:54Z",
        "lastEditedBy" : "b15d5707-82a8-4448-b49d-a2d6502b10f9",
        "tags" : [
        ]
      },
      {
        "id" : "12417eb0-0971-4f2b-a7bf-9ca3473505cc",
        "parentId" : "55d4cb7f-371c-444a-9e5c-412d6ae6625a",
        "authorId" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "body" : "\r\nThanks for the explanation, @ncdc .\r\n\r\n> this runs a controller, and is what the GC controller calls when it's starting monitors. For shared informers, they return a dummy controller whose Run() implementation is a no-op, so we're safe here.\r\n\r\nDoes this mean the gc will miss the ADD events for the objects that are already in the sharedInformer before gc invokes the `dummyController.Run()`?",
        "createdAt" : "2017-05-18T22:11:23Z",
        "updatedAt" : "2017-05-22T16:51:54Z",
        "lastEditedBy" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "tags" : [
        ]
      }
    ],
    "commit" : "2480f2ceb669365a1991cceda890a836d405cd93",
    "line" : 64,
    "diffHunk" : "@@ -1,1 +158,162 @@\t}\n\n\tshared, err := gb.sharedInformers.ForResource(resource)\n\tif err == nil {\n\t\tglog.V(4).Infof(\"using a shared informer for resource %q, kind %q\", resource.String(), kind.String())"
  },
  {
    "id" : "09881803-adc5-4eb0-bb6f-1a1ad15f808a",
    "prId" : 45427,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/45427#pullrequestreview-38417883",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f47d5f0d-3e73-44ce-9312-8018a5503bad",
        "parentId" : null,
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "build up the string, don't rely on the stringification for display purposes.",
        "createdAt" : "2017-05-08T15:16:47Z",
        "updatedAt" : "2017-05-22T16:51:54Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      },
      {
        "id" : "22cef643-1703-4e26-b58e-9a24b4ead2f9",
        "parentId" : "f47d5f0d-3e73-44ce-9312-8018a5503bad",
        "authorId" : "b15d5707-82a8-4448-b49d-a2d6502b10f9",
        "body" : "IIRC `typeAccessor.GetAPIVersion()` is doing exactly this, but I can build it up instead.",
        "createdAt" : "2017-05-16T02:23:29Z",
        "updatedAt" : "2017-05-22T16:51:54Z",
        "lastEditedBy" : "b15d5707-82a8-4448-b49d-a2d6502b10f9",
        "tags" : [
        ]
      },
      {
        "id" : "587f3980-6ef6-434e-86ef-51d735281367",
        "parentId" : "f47d5f0d-3e73-44ce-9312-8018a5503bad",
        "authorId" : "b15d5707-82a8-4448-b49d-a2d6502b10f9",
        "body" : "Chatted with @deads2k on irc. typeAccessor.GetAPIVersion() just does this under the covers:\r\n\r\n```go\r\nobj.GetObjectKind().GroupVersionKind().GroupVersion().String()\r\n```\r\n\r\nwhich is a multi-line function that has some special casing for \"v1\" vs everything else. David said he won't block the PR on this (given that it's not a change in functionality).",
        "createdAt" : "2017-05-16T15:08:52Z",
        "updatedAt" : "2017-05-22T16:51:54Z",
        "lastEditedBy" : "b15d5707-82a8-4448-b49d-a2d6502b10f9",
        "tags" : [
        ]
      }
    ],
    "commit" : "2480f2ceb669365a1991cceda890a836d405cd93",
    "line" : 164,
    "diffHunk" : "@@ -1,1 +468,472 @@\t\t\tidentity: objectReference{\n\t\t\t\tOwnerReference: metav1.OwnerReference{\n\t\t\t\t\tAPIVersion: event.gvk.GroupVersion().String(),\n\t\t\t\t\tKind:       event.gvk.Kind,\n\t\t\t\t\tUID:        accessor.GetUID(),"
  },
  {
    "id" : "ac505415-24c4-4f62-a438-572c03003a5a",
    "prId" : 43235,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/43235#pullrequestreview-27461955",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "172a91e2-8cf8-44d5-9004-77a9cfd0e701",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "just print the nonCoreMsg once, if we encounter any restmapper errors, along with all the restmapper errors for resources we couldn't handle",
        "createdAt" : "2017-03-16T20:57:30Z",
        "updatedAt" : "2017-03-16T21:19:26Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "74974003-a722-4262-a72b-982c195a1ef1",
        "parentId" : "172a91e2-8cf8-44d5-9004-77a9cfd0e701",
        "authorId" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "body" : "If there are multiple restmapper failures and only one of them print the nonCoreMsg, readers may miss it. I think it's worthwhile to print nonCoreMsg multiple times, given that this function is only called at initialization time, so it won't spam the log much.",
        "createdAt" : "2017-03-16T21:17:54Z",
        "updatedAt" : "2017-03-16T21:19:26Z",
        "lastEditedBy" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "tags" : [
        ]
      }
    ],
    "commit" : "33da82bc6782721a371fa126c792cea96f596827",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +167,171 @@\t\tif err != nil {\n\t\t\tnonCoreMsg := fmt.Sprintf(nonCoreMessage, resource)\n\t\t\tutilruntime.HandleError(fmt.Errorf(\"%v. %s\", err, nonCoreMsg))\n\t\t\tcontinue\n\t\t}"
  }
]
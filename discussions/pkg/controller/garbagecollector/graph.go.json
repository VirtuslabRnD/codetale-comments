[
  {
    "id" : "a1686073-c6d9-441a-850d-b4d8f732fbf2",
    "prId" : 38676,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/38676#pullrequestreview-23605046",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "51d0c203-94f7-41a8-ac2e-426e2339dbbc",
        "parentId" : null,
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "no change needed, but I think you can use something out of sync/atomic for this.",
        "createdAt" : "2017-02-23T23:50:21Z",
        "updatedAt" : "2017-03-01T07:05:50Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      }
    ],
    "commit" : "31cb266340ac5d702a650ea30c730bb909cd99b5",
    "line" : 55,
    "diffHunk" : "@@ -1,1 +53,57 @@\t// this records if the object's deletionTimestamp is non-nil.\n\tbeingDeleted     bool\n\tbeingDeletedLock sync.RWMutex\n\t// when processing an Update event, we need to compare the updated\n\t// ownerReferences with the owners recorded in the graph."
  },
  {
    "id" : "c2842426-d792-4585-ae75-2d50a87fdd87",
    "prId" : 38676,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/38676#pullrequestreview-24063404",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "099fcfe2-a68a-4951-a2ef-9c396dac61e4",
        "parentId" : null,
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "delete this, there is no possible way to use it safely (I think?), and it looks unused.",
        "createdAt" : "2017-02-25T01:05:21Z",
        "updatedAt" : "2017-03-01T07:05:50Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "804714a4-5bde-4eb2-8400-050696a96240",
        "parentId" : "099fcfe2-a68a-4951-a2ef-9c396dac61e4",
        "authorId" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "body" : "Why it's never safe? It's used in garbagecollector.go, before GC deletes an object, it checks object.dependentsLength(), if it's 0, GC deletes the object with PropagationPolicy=background, to avoid the cycle of adding/removing finalizers.",
        "createdAt" : "2017-02-27T02:06:42Z",
        "updatedAt" : "2017-03-01T07:05:50Z",
        "lastEditedBy" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "tags" : [
        ]
      },
      {
        "id" : "dbf13605-dee8-46b4-b1e1-be7b42a40d59",
        "parentId" : "099fcfe2-a68a-4951-a2ef-9c396dac61e4",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "How could it know that nothing else is about to add a dependent? You need to lock around the add/delete object command, no?\r\n\r\nOtherwise you can have a situation:\r\nthread 1: (get node N) (check dependent length) (delete node)\r\nthread 2: (get node N) (add dependent) (but node N is no longer in the graph)\r\n",
        "createdAt" : "2017-02-27T18:26:38Z",
        "updatedAt" : "2017-03-01T07:05:50Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "372c1adb-d62e-404e-97c1-3e6d4ff2b72c",
        "parentId" : "099fcfe2-a68a-4951-a2ef-9c396dac61e4",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "Chao explained in person that deleting means send a request to apiserver, not removing from the graph directly. I think we can probably improve this later but I guess it doesn't block the PR.",
        "createdAt" : "2017-02-27T18:51:34Z",
        "updatedAt" : "2017-03-01T07:05:50Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      }
    ],
    "commit" : "31cb266340ac5d702a650ea30c730bb909cd99b5",
    "line" : 99,
    "diffHunk" : "@@ -1,1 +97,101 @@}\n\nfunc (ownerNode *node) dependentsLength() int {\n\townerNode.dependentsLock.RLock()\n\tdefer ownerNode.dependentsLock.RUnlock()"
  }
]
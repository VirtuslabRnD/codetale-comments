[
  {
    "id" : "eef9be04-5d12-4d79-9584-ef8261ed6677",
    "prId" : 31044,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9542f9b2-c513-4041-b1f1-b1eb13baa4ca",
        "parentId" : null,
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "what if another controller has a client for the same resource? won't that register the same metric twice?\n\n(or in the dynamic garbage collector scenario, what if the user adds a 3rd party resource, then deletes it, then adds it again?)\n",
        "createdAt" : "2016-08-22T22:30:47Z",
        "updatedAt" : "2016-08-22T22:30:47Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "e0b72e83-7895-4505-b639-0adbd757f141",
        "parentId" : "9542f9b2-c513-4041-b1f1-b1eb13baa4ca",
        "authorId" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "body" : "> what if another controller has a client for the same resource? won't that register the same metric twice?\n\n`prefix` is different so the metric's name will be different. Also, different controller has uses different clientPool, so the same ratelimiter won't get registered twice.\n\n> or in the dynamic garbage collector scenario, what if the user adds a 3rd party resource, then deletes it, then adds it again?\n\nI left a TODO on line 36 saying this approach is not dynamic.\n",
        "createdAt" : "2016-08-23T01:21:59Z",
        "updatedAt" : "2016-08-23T01:21:59Z",
        "lastEditedBy" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "tags" : [
        ]
      }
    ],
    "commit" : "992afd9c45f6f266cb753f96ddae4b54786dd789",
    "line" : 41,
    "diffHunk" : "@@ -1,1 +55,59 @@\t\tif rateLimiter := client.GetRateLimiter(); rateLimiter != nil {\n\t\t\tgroup := strings.Replace(gv.Group, \".\", \":\", -1)\n\t\t\tmetrics.RegisterMetricAndTrackRateLimiterUsage(fmt.Sprintf(\"%s_%s_%s\", prefix, group, gv.Version), rateLimiter)\n\t\t}\n\t})"
  },
  {
    "id" : "375d8c7f-3771-4e46-bf0a-978b9ebebf7c",
    "prId" : 28387,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "51746177-ef36-4a32-8337-da5b179d33f1",
        "parentId" : null,
        "authorId" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "body" : "@gmarek PTAL. Thanks!\n",
        "createdAt" : "2016-08-10T23:40:00Z",
        "updatedAt" : "2016-08-10T23:40:00Z",
        "lastEditedBy" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "tags" : [
        ]
      }
    ],
    "commit" : "41572cb22dc6c8b37e242761b7cfed7fcde40e49",
    "line" : 43,
    "diffHunk" : "@@ -1,1 +41,45 @@}\n\nfunc (r *RegisteredRateLimiter) registerIfNotPresent(gv unversioned.GroupVersion, client *dynamic.Client, prefix string) {\n\tr.lock.RLock()\n\t_, ok := r.rateLimiters[gv]"
  }
]
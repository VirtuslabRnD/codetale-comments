[
  {
    "id" : "3c734673-8355-40a2-bc74-0701efe3435a",
    "prId" : 26619,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "49d25070-91da-4be8-a8d7-ba6e832afe5c",
        "parentId" : null,
        "authorId" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "body" : "The entering for loop condition is &, so what is the difference between the old version and new one if the path comes to this point? After finished is set true at this line, it will quit waiting, I think.\n",
        "createdAt" : "2016-06-01T20:15:57Z",
        "updatedAt" : "2016-06-01T20:15:57Z",
        "lastEditedBy" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "tags" : [
        ]
      },
      {
        "id" : "55c38ad7-1b60-449d-bb71-7a40101bacdc",
        "parentId" : "49d25070-91da-4be8-a8d7-ba6e832afe5c",
        "authorId" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "body" : "yes, when `finished` is `true` the loop exits. But `finished` is set at different condition now.\n\nBefore it was set when there was no event in channel. This has proven to be racy, I got the controller waiting for CPU to send an event and the event was missed in this loop. Now we wait 1 minute and only after that `finished` is set.\n\nOf course, when sender closes the channel, `finished` is set immediately in both cases.\n",
        "createdAt" : "2016-06-02T08:04:56Z",
        "updatedAt" : "2016-06-02T08:04:56Z",
        "lastEditedBy" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "tags" : [
        ]
      }
    ],
    "commit" : "ee74cc4354d3201b6095fec805e5c5a95700a54f",
    "line" : 19,
    "diffHunk" : "@@ -1,1 +374,378 @@\t\t\t} else {\n\t\t\t\tglog.V(5).Infof(\"event recorder finished\")\n\t\t\t\tfinished = true\n\t\t\t}\n\t\tcase _, _ = <-timer.C:"
  },
  {
    "id" : "47a103e8-bf94-402b-8eb3-77cabb1ba74a",
    "prId" : 26410,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ae9f8f2b-ee32-4e81-821b-b4267d9e0c26",
        "parentId" : null,
        "authorId" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "body" : "I am wondering whether the clone operation in this func and deleteVolumeWithEvent function can be put before the lock?\n",
        "createdAt" : "2016-05-31T18:09:07Z",
        "updatedAt" : "2016-06-01T06:57:09Z",
        "lastEditedBy" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "tags" : [
        ]
      },
      {
        "id" : "a733fbfc-d4cc-4a8d-ad3d-3d418353e542",
        "parentId" : "ae9f8f2b-ee32-4e81-821b-b4267d9e0c26",
        "authorId" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "body" : "It could, however... would the code be more effective? I doubt so. Would it be more readable? IMO it's clearer as it is.\n",
        "createdAt" : "2016-06-01T06:42:59Z",
        "updatedAt" : "2016-06-01T06:57:09Z",
        "lastEditedBy" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "tags" : [
        ]
      }
    ],
    "commit" : "2d43e4549e76ab1444f6febbecdd159d3dc0c40b",
    "line" : 31,
    "diffHunk" : "@@ -1,1 +500,504 @@\t// Generate deletion event. Cloned volume is needed to prevent races (and we\n\t// would get a clone from etcd too).\n\tclone, _ := conversion.NewCloner().DeepCopy(claim)\n\tclaimClone := clone.(*api.PersistentVolumeClaim)\n\tr.claimSource.Delete(claimClone)"
  }
]
[
  {
    "id" : "d41b841f-ee69-4d95-90e9-2987cbc357c8",
    "prId" : 27128,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c0592bd4-37b3-4b5d-8c1a-23bc84b4a487",
        "parentId" : null,
        "authorId" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "body" : "I think this should be checked at the site that does the provisioning and this method just not invoked if it shouldn't be.\n",
        "createdAt" : "2016-06-10T17:32:25Z",
        "updatedAt" : "2016-06-20T05:15:34Z",
        "lastEditedBy" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "tags" : [
        ]
      },
      {
        "id" : "b1b9ff85-52a5-400f-b646-162ef93780d7",
        "parentId" : "c0592bd4-37b3-4b5d-8c1a-23bc84b4a487",
        "authorId" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "body" : "IMO result would be the same and `syncUnboundClaim` is complicated enough.\n",
        "createdAt" : "2016-06-13T07:56:05Z",
        "updatedAt" : "2016-06-20T05:15:34Z",
        "lastEditedBy" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "tags" : [
        ]
      }
    ],
    "commit" : "16ec36c59117bbc3ae1af07a7ab27dfc834336f2",
    "line" : 39,
    "diffHunk" : "@@ -1,1 +1064,1068 @@// provisionClaim starts new asynchronous operation to provision a claim if provisioning is enabled.\nfunc (ctrl *PersistentVolumeController) provisionClaim(claim *api.PersistentVolumeClaim) error {\n\tif !ctrl.enableDynamicProvisioning {\n\t\treturn nil\n\t}"
  },
  {
    "id" : "6eb11fc1-98d3-48cc-b3e7-c5e7405b359b",
    "prId" : 24331,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bb5e5cc8-0f34-4ea9-94b4-e971af45d76d",
        "parentId" : null,
        "authorId" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "body" : "Add a note saying we are designing for active/passive and not active/active.\n",
        "createdAt" : "2016-05-13T16:22:18Z",
        "updatedAt" : "2016-05-18T08:07:18Z",
        "lastEditedBy" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "tags" : [
        ]
      },
      {
        "id" : "4844f08b-7fe5-4d3c-9d58-3e7021dba7cf",
        "parentId" : "bb5e5cc8-0f34-4ea9-94b4-e971af45d76d",
        "authorId" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "body" : "Note added:\n\n```\n// This controller is designed to work in active-passive high availability mode.\n// It *could* work also in active-active HA mode, all the object transitions are\n// designed to cope with this, however performance could be lower as these two\n// active controllers will step on each other toes frequently.\n//\n```\n",
        "createdAt" : "2016-05-14T06:54:06Z",
        "updatedAt" : "2016-05-18T08:07:18Z",
        "lastEditedBy" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "tags" : [
        ]
      }
    ],
    "commit" : "01b20d8e77776dda3b7ec3389bd200ed80716d46",
    "line" : 43,
    "diffHunk" : "@@ -1,1 +41,45 @@// is complicated to manage in a transactionless system, but without it we\n// can't ensure sane behavior in the face of different forms of trouble.  For\n// example, a rogue HA controller instance could end up racing and making\n// multiple bindings that are indistinguishable, resulting in potential data\n// loss."
  }
]
[
  {
    "id" : "63b6f7f5-2f97-494f-bb32-444e3e5ee517",
    "prId" : 20900,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a6bf546e-097d-40a6-88a2-6a0385c6d40a",
        "parentId" : null,
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "Where is `pv.Name` set?\n",
        "createdAt" : "2016-02-10T01:11:52Z",
        "updatedAt" : "2016-02-12T08:50:57Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      },
      {
        "id" : "7b7b55b5-72ac-49fa-a4a6-917dad305d5e",
        "parentId" : "a6bf546e-097d-40a6-88a2-6a0385c6d40a",
        "authorId" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "body" : "In Provisioners of individual volume plugins, currently as `PV.GenerateName = \"pv-cinder-\"`. (pv-aws-, pv-gce-)\n\nE.g. https://github.com/kubernetes/kubernetes/blob/master/pkg/volume/cinder/cinder.go#L434\n",
        "createdAt" : "2016-02-10T10:55:03Z",
        "updatedAt" : "2016-02-12T08:50:57Z",
        "lastEditedBy" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "tags" : [
        ]
      },
      {
        "id" : "da0126ed-f21e-4f7f-88f5-fb4a1930fdd0",
        "parentId" : "a6bf546e-097d-40a6-88a2-6a0385c6d40a",
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "> `pv-name` is guaranteed to be unique in Kubernetes cluster\n\nI don't understand how the name is guaranteed to be unique then. For example, won't this make the volume name `someCluster-dynamic-pv-cinder-`?\n",
        "createdAt" : "2016-02-10T22:25:15Z",
        "updatedAt" : "2016-02-12T08:50:57Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      },
      {
        "id" : "6ffca369-736a-41c6-94a6-f0c67434ab2c",
        "parentId" : "a6bf546e-097d-40a6-88a2-6a0385c6d40a",
        "authorId" : "727fc82d-d969-41a4-a614-7fefce94f9a6",
        "body" : "A comment would help.\n\nIt is guaranteed unique because we first persist the PV with, for example, `GenerateName: \"pv-aws-\", objectMeta.GenerateName`\n\nWe then want to use that PV name as the resource name to tie them together.\n",
        "createdAt" : "2016-02-10T23:10:22Z",
        "updatedAt" : "2016-02-12T08:50:57Z",
        "lastEditedBy" : "727fc82d-d969-41a4-a614-7fefce94f9a6",
        "tags" : [
        ]
      },
      {
        "id" : "6a86790a-e571-49c1-b617-a26a7725ca4b",
        "parentId" : "a6bf546e-097d-40a6-88a2-6a0385c6d40a",
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "Got it, thanks Mark! Yes, a comment would help.\n\nSo one more question: why set the final name in such a roundabout fashion? i.e. `NewPersistentVolumeTemplate()` will set it to `pv-aws-UID` then `CreateVolume(...)` will set it to `clusterName-dynamic-pv-aws-UID`. Why not just set it to the final name directly in `NewPersistentVolumeTemplate()`?\n",
        "createdAt" : "2016-02-10T23:21:38Z",
        "updatedAt" : "2016-02-12T08:50:57Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      },
      {
        "id" : "5b91c39c-ac43-4bd8-8ae6-dc55e3b97f8d",
        "parentId" : "a6bf546e-097d-40a6-88a2-6a0385c6d40a",
        "authorId" : "727fc82d-d969-41a4-a614-7fefce94f9a6",
        "body" : "What kind of name is guaranteed to be unique in the cluster besides a new UUID?  objMeta.GenerateName allows a human-readable prefix with a suffix that makes a unique name.\n\nAlso, once the PV is persisted, we get more than a name.  We get a marker (with a future Provisioning Condition) that makes the provisioning process async.  We use annotations today but that is better expressed as a Condition (can put meaningful status on the CLI).\n",
        "createdAt" : "2016-02-10T23:30:48Z",
        "updatedAt" : "2016-02-12T08:50:57Z",
        "lastEditedBy" : "727fc82d-d969-41a4-a614-7fefce94f9a6",
        "tags" : [
        ]
      },
      {
        "id" : "4e1cc8c8-e311-4348-acf0-b85ab6250529",
        "parentId" : "a6bf546e-097d-40a6-88a2-6a0385c6d40a",
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "Makes sense, so we want/expect the name of the PV in the provider to be different then (contain more info then) the name of the API PV object. \n",
        "createdAt" : "2016-02-10T23:47:06Z",
        "updatedAt" : "2016-02-12T08:50:57Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      },
      {
        "id" : "1001a1cf-5420-4d27-b733-847ad909efce",
        "parentId" : "a6bf546e-097d-40a6-88a2-6a0385c6d40a",
        "authorId" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "body" : "I added a note describing where pv.Name comes from.\n",
        "createdAt" : "2016-02-11T13:01:16Z",
        "updatedAt" : "2016-02-12T08:50:57Z",
        "lastEditedBy" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "tags" : [
        ]
      },
      {
        "id" : "18157bb3-af50-47a9-ae3b-8c552f2453b6",
        "parentId" : "a6bf546e-097d-40a6-88a2-6a0385c6d40a",
        "authorId" : "727fc82d-d969-41a4-a614-7fefce94f9a6",
        "body" : "@saad-ali strictly speaking, we are assigning PV.Name from Kube to GCEPD.Name in the provider.  The name field exists on both, so we think it would be beneficial for them to match.\n",
        "createdAt" : "2016-02-11T13:38:28Z",
        "updatedAt" : "2016-02-12T08:50:57Z",
        "lastEditedBy" : "727fc82d-d969-41a4-a614-7fefce94f9a6",
        "tags" : [
        ]
      }
    ],
    "commit" : "1d0b1c227b85a836988bedf15fd3f12c1e372a3f",
    "line" : 57,
    "diffHunk" : "@@ -1,1 +352,356 @@\n\tif pv != nil {\n\t\tvolumeOptions.PVName = pv.Name\n\t}\n"
  },
  {
    "id" : "c1181d87-effa-48f3-92dc-82f65b6b476f",
    "prId" : 19868,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f1e532a6-228d-427a-bca2-ea12772957c6",
        "parentId" : null,
        "authorId" : "727fc82d-d969-41a4-a614-7fefce94f9a6",
        "body" : "per our IRC discussion, please update the local cache with the latest and greatest version.\n",
        "createdAt" : "2016-01-29T16:26:55Z",
        "updatedAt" : "2016-02-02T13:00:11Z",
        "lastEditedBy" : "727fc82d-d969-41a4-a614-7fefce94f9a6",
        "tags" : [
        ]
      },
      {
        "id" : "2eb21e61-1508-4c9a-8f53-552b4ceb1530",
        "parentId" : "f1e532a6-228d-427a-bca2-ea12772957c6",
        "authorId" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "body" : "Is it safe to update `controller.claimStore` here? Won't it generate a new 'claim updated' event?\n",
        "createdAt" : "2016-02-01T10:13:38Z",
        "updatedAt" : "2016-02-02T13:00:11Z",
        "lastEditedBy" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "tags" : [
        ]
      },
      {
        "id" : "e454ee5d-fe19-4e91-b37c-a7293159661a",
        "parentId" : "f1e532a6-228d-427a-bca2-ea12772957c6",
        "authorId" : "727fc82d-d969-41a4-a614-7fefce94f9a6",
        "body" : "It is safe.  API updates generate events.  The watch gets the events and puts them in the local store.  \n",
        "createdAt" : "2016-02-01T12:31:59Z",
        "updatedAt" : "2016-02-02T13:00:11Z",
        "lastEditedBy" : "727fc82d-d969-41a4-a614-7fefce94f9a6",
        "tags" : [
        ]
      },
      {
        "id" : "5986030e-252d-463a-900d-3adf2bab4b95",
        "parentId" : "f1e532a6-228d-427a-bca2-ea12772957c6",
        "authorId" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "body" : "I added update few lines below.\n",
        "createdAt" : "2016-02-05T14:19:35Z",
        "updatedAt" : "2016-02-05T14:19:35Z",
        "lastEditedBy" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "tags" : [
        ]
      }
    ],
    "commit" : "1edf34a4e578de0651a31d8c335e2f0e037d106b",
    "line" : 12,
    "diffHunk" : "@@ -1,1 +162,166 @@\t\treturn fmt.Errorf(\"Cannot reload claim %s/%s: %v\", claim.Namespace, claim.Name, err)\n\t}\n\tclaim = newClaim\n\terr = controller.claimStore.Update(claim)\n\tif err != nil {"
  },
  {
    "id" : "2367cf17-1c8f-4892-bd53-b1cf7d6fd669",
    "prId" : 18957,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "04b53303-f3c0-47a6-8895-983a1a71695a",
        "parentId" : null,
        "authorId" : "727fc82d-d969-41a4-a614-7fefce94f9a6",
        "body" : "When would PV be nil?  We first make the PV from the template and persist it with ClaimRef to the PVC.\n\nIt seems like nil PV here should be an error.\n",
        "createdAt" : "2015-12-21T15:51:29Z",
        "updatedAt" : "2016-01-08T18:47:39Z",
        "lastEditedBy" : "727fc82d-d969-41a4-a614-7fefce94f9a6",
        "tags" : [
        ]
      },
      {
        "id" : "4ab2d092-b1c8-453d-a620-0e86b5dd4361",
        "parentId" : "04b53303-f3c0-47a6-8895-983a1a71695a",
        "authorId" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "body" : "`newProvisioner` is called twice and at the first call the PV is not yet availabe, it's created by the returned provisioner.\n\nhttps://github.com/kubernetes/kubernetes/pull/18957/files#diff-fc923807bec23504369a29c0f94b6055R175\n",
        "createdAt" : "2016-01-04T12:27:58Z",
        "updatedAt" : "2016-01-08T18:47:39Z",
        "lastEditedBy" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "tags" : [
        ]
      },
      {
        "id" : "04c780b9-7b9c-4afe-83f6-2545de477939",
        "parentId" : "04b53303-f3c0-47a6-8895-983a1a71695a",
        "authorId" : "6eca0ade-9879-4dd7-ad14-547e16f5c041",
        "body" : "can you add a comment to that effect?  I am less familiar with this area when doing the review and had a similar thought.\n",
        "createdAt" : "2016-01-04T18:10:31Z",
        "updatedAt" : "2016-01-08T18:47:39Z",
        "lastEditedBy" : "6eca0ade-9879-4dd7-ad14-547e16f5c041",
        "tags" : [
        ]
      },
      {
        "id" : "ade438fa-6a25-4144-8824-4cb9ce8dbd42",
        "parentId" : "04b53303-f3c0-47a6-8895-983a1a71695a",
        "authorId" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "body" : "I added a short note.\n",
        "createdAt" : "2016-01-05T09:29:55Z",
        "updatedAt" : "2016-01-08T18:47:39Z",
        "lastEditedBy" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "tags" : [
        ]
      }
    ],
    "commit" : "8c48250a558130b003da587255dd8a6ae22b4399",
    "line" : null,
    "diffHunk" : "@@ -1,1 +337,341 @@\n\t// pv can be nil when the provisioner has not created the PV yet\n\tif pv != nil {\n\t\ttags[cloudVolumeCreatedForVolumeNameTag] = pv.Name\n\t}"
  },
  {
    "id" : "57ed45a2-bd36-4a4f-8d06-a03565c6517d",
    "prId" : 14537,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "366085d3-893e-4c90-ba9f-f704dd003f8a",
        "parentId" : null,
        "authorId" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "body" : "Is this a WIP symptom or is the flow really the same?\n",
        "createdAt" : "2015-12-09T21:36:16Z",
        "updatedAt" : "2015-12-11T15:33:59Z",
        "lastEditedBy" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "tags" : [
        ]
      }
    ],
    "commit" : "4fc1bf1f2314b213af2f540ebe86d169ccfadd9c",
    "line" : null,
    "diffHunk" : "@@ -1,1 +151,155 @@\t// The flow for Update is the same as Add.\n\t// A volume is only provisioned for a claim if not done so already.\n\tcontroller.handleAddClaim(newObj)\n}\n"
  },
  {
    "id" : "73192eba-a2a6-433e-8f45-52f39cd3f8de",
    "prId" : 14537,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3879fa5e-df87-4f0b-8c00-7c8e034cc9a0",
        "parentId" : null,
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "Possible values are \"false\" and \"volume.experimental.kubernetes.io/provisioning-completed\"? If so, a little confusing.\n",
        "createdAt" : "2015-12-10T06:56:56Z",
        "updatedAt" : "2015-12-11T15:33:59Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      },
      {
        "id" : "2d09055c-634f-415a-9f7f-c03d43926aa9",
        "parentId" : "3879fa5e-df87-4f0b-8c00-7c8e034cc9a0",
        "authorId" : "727fc82d-d969-41a4-a614-7fefce94f9a6",
        "body" : "The value constant is kind of magic, I suppose.  _Any_ value other than that constant is considered \"not provisioned\".\n\nWhen the value of \"requires provisioning\" == \"provisioning completed\", we can move on.\n\nWe had talked months ago about using annotations as the interlock between controllers.  I presume this is what you guys had in mind, but I'm open to alternatives.\n",
        "createdAt" : "2015-12-10T13:53:26Z",
        "updatedAt" : "2015-12-11T15:33:59Z",
        "lastEditedBy" : "727fc82d-d969-41a4-a614-7fefce94f9a6",
        "tags" : [
        ]
      },
      {
        "id" : "af69e799-c161-4a95-a92e-cab5ef102227",
        "parentId" : "3879fa5e-df87-4f0b-8c00-7c8e034cc9a0",
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "Ack. Not a big issue.\n",
        "createdAt" : "2015-12-10T22:16:18Z",
        "updatedAt" : "2015-12-11T15:33:59Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      }
    ],
    "commit" : "4fc1bf1f2314b213af2f540ebe86d169ccfadd9c",
    "line" : 497,
    "diffHunk" : "@@ -1,1 +495,499 @@\t// that provisioning has not yet occurred.\n\tpvProvisioningRequiredAnnotationKey    = \"volume.experimental.kubernetes.io/provisioning-required\"\n\tpvProvisioningCompletedAnnotationValue = \"volume.experimental.kubernetes.io/provisioning-completed\"\n)"
  },
  {
    "id" : "82f96c05-8278-413b-b31d-ae18ed31c4a6",
    "prId" : 14537,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d5a40f58-db58-49ba-982f-fca638ae9055",
        "parentId" : null,
        "authorId" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "body" : "what's the pattern for other controllers that use these stores?  Do they handle the !ok case?\n",
        "createdAt" : "2015-12-10T16:18:16Z",
        "updatedAt" : "2015-12-11T15:33:59Z",
        "lastEditedBy" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "tags" : [
        ]
      },
      {
        "id" : "88d0450e-7447-47e3-b176-80f544237603",
        "parentId" : "d5a40f58-db58-49ba-982f-fca638ae9055",
        "authorId" : "727fc82d-d969-41a4-a614-7fefce94f9a6",
        "body" : "Some return.  Some log an error and return.  \n",
        "createdAt" : "2015-12-10T19:00:41Z",
        "updatedAt" : "2015-12-11T15:33:59Z",
        "lastEditedBy" : "727fc82d-d969-41a4-a614-7fefce94f9a6",
        "tags" : [
        ]
      }
    ],
    "commit" : "4fc1bf1f2314b213af2f540ebe86d169ccfadd9c",
    "line" : 125,
    "diffHunk" : "@@ -1,1 +123,127 @@\t\t\tglog.Errorf(\"Error reconciling volume %s: %+v\", pv.Name, err)\n\t\t}\n\t}\n}\n"
  },
  {
    "id" : "a8b7d980-3964-45da-8f80-91406cfb9360",
    "prId" : 14537,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4c5126a2-1e0b-4269-81f3-174c373ccf37",
        "parentId" : null,
        "authorId" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "body" : "why not just call `handleAddClaim` `handleAddOrUpdateClaim` and just register the same method for both handlers instead of having update wrap add?\n",
        "createdAt" : "2015-12-10T16:19:39Z",
        "updatedAt" : "2015-12-11T15:33:59Z",
        "lastEditedBy" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "tags" : [
        ]
      },
      {
        "id" : "94306abb-09b2-49f2-b2a1-ad2c565412cf",
        "parentId" : "4c5126a2-1e0b-4269-81f3-174c373ccf37",
        "authorId" : "727fc82d-d969-41a4-a614-7fefce94f9a6",
        "body" : "Different signatures for the handler funcs, hence the wrap.\n",
        "createdAt" : "2015-12-10T19:01:05Z",
        "updatedAt" : "2015-12-11T15:33:59Z",
        "lastEditedBy" : "727fc82d-d969-41a4-a614-7fefce94f9a6",
        "tags" : [
        ]
      },
      {
        "id" : "ac96f4fd-a7dc-4c73-be8b-0a95c2165336",
        "parentId" : "4c5126a2-1e0b-4269-81f3-174c373ccf37",
        "authorId" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "body" : "Ack\n",
        "createdAt" : "2015-12-11T16:22:34Z",
        "updatedAt" : "2015-12-11T16:22:34Z",
        "lastEditedBy" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "tags" : [
        ]
      }
    ],
    "commit" : "4fc1bf1f2314b213af2f540ebe86d169ccfadd9c",
    "line" : 150,
    "diffHunk" : "@@ -1,1 +148,152 @@}\n\nfunc (controller *PersistentVolumeProvisionerController) handleUpdateClaim(oldObj, newObj interface{}) {\n\t// The flow for Update is the same as Add.\n\t// A volume is only provisioned for a claim if not done so already."
  }
]
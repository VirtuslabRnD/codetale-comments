[
  {
    "id" : "7273748d-1e31-482c-9ad7-39e980275386",
    "prId" : 19365,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "22c47178-8159-4592-a8a7-c8f4c8c7b179",
        "parentId" : null,
        "authorId" : "727fc82d-d969-41a4-a614-7fefce94f9a6",
        "body" : "please add a comment for what the func does.\n",
        "createdAt" : "2016-01-22T13:27:45Z",
        "updatedAt" : "2016-02-05T16:02:22Z",
        "lastEditedBy" : "727fc82d-d969-41a4-a614-7fefce94f9a6",
        "tags" : [
        ]
      },
      {
        "id" : "f9a99d7d-e496-47ce-bdcd-dd306752c808",
        "parentId" : "22c47178-8159-4592-a8a7-c8f4c8c7b179",
        "authorId" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "body" : "Added\n",
        "createdAt" : "2016-01-25T14:22:30Z",
        "updatedAt" : "2016-02-05T16:02:22Z",
        "lastEditedBy" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "tags" : [
        ]
      }
    ],
    "commit" : "76b6449715a5d450ba1f07b1852efda5f87555c1",
    "line" : null,
    "diffHunk" : "@@ -1,1 +126,130 @@// recycled right now. Otherwise it returns an error with reason why it should\n// not be recycled.\nfunc (recycler *PersistentVolumeRecycler) shouldRecycle(pv *api.PersistentVolume) error {\n\tif pv.Spec.ClaimRef == nil {\n\t\treturn fmt.Errorf(\"Volume does not have a reference to claim\")"
  },
  {
    "id" : "5e4502ef-d7fd-4d78-a4bc-e59f19655082",
    "prId" : 19365,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "178633de-e983-4854-ba52-a8107dce8012",
        "parentId" : null,
        "authorId" : null,
        "body" : "Hmm.. I am not too comfortable with this approach. Wouldn't the volume state be better stored as an annotation on the PV ? You should be able to look in one place and figure out the sate of a PV. This makes it easier people other than the original author to debug volume problems. In addition if we end up using the State design pattern to clean volume states up we'll have to undo this and put it back in the volume.\n",
        "createdAt" : "2016-01-29T20:29:19Z",
        "updatedAt" : "2016-02-05T16:02:22Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "b37226d0-5b45-4e87-b2d2-e6ffff88308b",
        "parentId" : "178633de-e983-4854-ba52-a8107dce8012",
        "authorId" : "727fc82d-d969-41a4-a614-7fefce94f9a6",
        "body" : "See buried comment above https://github.com/kubernetes/kubernetes/pull/19365#discussion_r49107689\n\nUsing PV annotations generated many events as the PV was saved over and over. Also require more keys.  Code was smaller after switching to local state.  In the case of controller restart, all PVs start at 0, so the MaxRetries var is not guaranteed (it would be w/ PV annotation), but that doesn't seem important.\n",
        "createdAt" : "2016-01-29T21:03:27Z",
        "updatedAt" : "2016-02-05T16:02:22Z",
        "lastEditedBy" : "727fc82d-d969-41a4-a614-7fefce94f9a6",
        "tags" : [
        ]
      },
      {
        "id" : "3141e037-3dad-4da9-80e5-d096001333c2",
        "parentId" : "178633de-e983-4854-ba52-a8107dce8012",
        "authorId" : null,
        "body" : "I see... as @jsafrane has noted already though we'll pay the price of having scattered state. I wont block this though since you and Jan are aware of the trade off.\n",
        "createdAt" : "2016-02-02T14:41:39Z",
        "updatedAt" : "2016-02-05T16:02:22Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "76b6449715a5d450ba1f07b1852efda5f87555c1",
    "line" : null,
    "diffHunk" : "@@ -1,1 +51,55 @@\t// Local cache of failed recycle / delete operations. Map volume.Name -> status of the volume.\n\t// Only PVs in Released state have an entry here.\n\treleasedVolumes map[string]releasedVolumeStatus\n}\n"
  },
  {
    "id" : "7dd98dcf-5012-47ca-b01f-096d61481a91",
    "prId" : 19365,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "138b3b8a-1d1b-422f-99c1-04d347e3d6db",
        "parentId" : null,
        "authorId" : "727fc82d-d969-41a4-a614-7fefce94f9a6",
        "body" : "It's interesting now that we're thinking about Conditions.  These are the kinds of fileds on a Condition (type, timestamp, etc).  \n",
        "createdAt" : "2016-02-05T16:48:14Z",
        "updatedAt" : "2016-02-05T16:48:14Z",
        "lastEditedBy" : "727fc82d-d969-41a4-a614-7fefce94f9a6",
        "tags" : [
        ]
      }
    ],
    "commit" : "76b6449715a5d450ba1f07b1852efda5f87555c1",
    "line" : 20,
    "diffHunk" : "@@ -1,1 +61,65 @@\tretryCount int\n\t// Timestamp of the last attempt.\n\tlastAttempt time.Time\n}\n"
  },
  {
    "id" : "84d0dfc7-9b5e-4f80-813b-9cb699a6305a",
    "prId" : 18083,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3609127f-c216-473a-a0a4-1b5ea4a5bfe4",
        "parentId" : null,
        "authorId" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "body" : "just `return` above and drop this conditional.\n",
        "createdAt" : "2015-12-02T17:50:03Z",
        "updatedAt" : "2015-12-10T23:23:54Z",
        "lastEditedBy" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "tags" : [
        ]
      },
      {
        "id" : "24d2d90f-2f80-4ccb-a9c1-90fd5bca58ce",
        "parentId" : "3609127f-c216-473a-a0a4-1b5ea4a5bfe4",
        "authorId" : "727fc82d-d969-41a4-a614-7fefce94f9a6",
        "body" : "I can't do that here (same with your comment in the handleDelete function) because the phase is set to Failed in the code above and must be persisted later in the function.\n\nI added a comment to both that explains what's going on and why to make it clear.  \n",
        "createdAt" : "2015-12-03T03:42:11Z",
        "updatedAt" : "2015-12-10T23:23:54Z",
        "lastEditedBy" : "727fc82d-d969-41a4-a614-7fefce94f9a6",
        "tags" : [
        ]
      }
    ],
    "commit" : "34c063cfe16792808890c482c0e79ed6625d5a81",
    "line" : null,
    "diffHunk" : "@@ -1,1 +138,142 @@\t// we don't need to attempt recycling when plugin is nil, but we do need to persist the next/failed phase\n\t// of the volume so that subsequent syncs won't attempt recycling through this handler func.\n\tif plugin != nil {\n\t\tvolRecycler, err := plugin.NewRecycler(spec)\n\t\tif err != nil {"
  },
  {
    "id" : "d9e8767a-335a-483b-9bff-e2ef1f92249d",
    "prId" : 18083,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3cce59b3-a1f1-465c-be0d-177bf5964000",
        "parentId" : null,
        "authorId" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "body" : "I don't think we should give up in this case, this may be a transient error.\n",
        "createdAt" : "2015-12-02T17:51:18Z",
        "updatedAt" : "2015-12-10T23:23:54Z",
        "lastEditedBy" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "tags" : [
        ]
      },
      {
        "id" : "fc56a12e-cb4c-4af2-93e2-dfccb9e0f190",
        "parentId" : "3cce59b3-a1f1-465c-be0d-177bf5964000",
        "authorId" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "body" : "(ah, I see that this isn't a change from the existing behavior...  but it still doesn't seem quite right)\n",
        "createdAt" : "2015-12-02T17:53:00Z",
        "updatedAt" : "2015-12-10T23:23:54Z",
        "lastEditedBy" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "tags" : [
        ]
      },
      {
        "id" : "483a4526-4243-4415-8f82-8a50f4907c37",
        "parentId" : "3cce59b3-a1f1-465c-be0d-177bf5964000",
        "authorId" : "727fc82d-d969-41a4-a614-7fefce94f9a6",
        "body" : "How do you suggest counting the number failures before giving up as a non-transient error?  Keep an internal map with volumeName/count and only set to Failed if count > x ?\n",
        "createdAt" : "2015-12-02T19:21:14Z",
        "updatedAt" : "2015-12-10T23:23:54Z",
        "lastEditedBy" : "727fc82d-d969-41a4-a614-7fefce94f9a6",
        "tags" : [
        ]
      }
    ],
    "commit" : "34c063cfe16792808890c482c0e79ed6625d5a81",
    "line" : null,
    "diffHunk" : "@@ -1,1 +147,151 @@\t\t\tglog.Errorf(\"PersistentVolume[%s] failed recycling: %+v\", pv.Name, err)\n\t\t\tpv.Status.Message = fmt.Sprintf(\"Recycling error: %s\", err)\n\t\t\tnextPhase = api.VolumeFailed\n\t\t} else {\n\t\t\tglog.V(5).Infof(\"PersistentVolume[%s] successfully recycled\\n\", pv.Name)"
  },
  {
    "id" : "722509c1-5335-4cb2-849c-ef9044d93df6",
    "prId" : 18083,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d52b1b13-ce09-4c22-99ba-dc089d13e3c9",
        "parentId" : null,
        "authorId" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "body" : "as above wrt early return\n",
        "createdAt" : "2015-12-02T17:53:47Z",
        "updatedAt" : "2015-12-10T23:23:54Z",
        "lastEditedBy" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "tags" : [
        ]
      }
    ],
    "commit" : "34c063cfe16792808890c482c0e79ed6625d5a81",
    "line" : null,
    "diffHunk" : "@@ -1,1 +183,187 @@\t// we don't need to attempt deleting when plugin is nil, but we do need to persist the next/failed phase\n\t// of the volume so that subsequent syncs won't attempt deletion through this handler func.\n\tif plugin != nil {\n\t\tdeleter, err := plugin.NewDeleter(spec)\n\t\tif err != nil {"
  },
  {
    "id" : "0da8a6bf-dfeb-434a-bd9f-8fbc972239f4",
    "prId" : 18083,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "818702f7-d434-40bc-a23e-c90c03ef1861",
        "parentId" : null,
        "authorId" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "body" : "inline if and err check.\n",
        "createdAt" : "2015-12-02T17:54:12Z",
        "updatedAt" : "2015-12-10T23:23:54Z",
        "lastEditedBy" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "tags" : [
        ]
      },
      {
        "id" : "60b3aef1-3ec9-4e59-9a12-0625171a1f7f",
        "parentId" : "818702f7-d434-40bc-a23e-c90c03ef1861",
        "authorId" : "727fc82d-d969-41a4-a614-7fefce94f9a6",
        "body" : "inlined\n",
        "createdAt" : "2015-12-03T03:39:35Z",
        "updatedAt" : "2015-12-10T23:23:54Z",
        "lastEditedBy" : "727fc82d-d969-41a4-a614-7fefce94f9a6",
        "tags" : [
        ]
      }
    ],
    "commit" : "34c063cfe16792808890c482c0e79ed6625d5a81",
    "line" : null,
    "diffHunk" : "@@ -1,1 +189,193 @@\t\t}\n\t\t// blocks until completion\n\t\terr = deleter.Delete()\n\t\tif err != nil {\n\t\t\tglog.Errorf(\"PersistentVolume[%s] failed deletion: %+v\", pv.Name, err)"
  },
  {
    "id" : "b9b095a5-9c80-45db-8a6f-76657ff16aa2",
    "prId" : 9870,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "639c1819-a554-4bd1-9a56-fc543f7bd4a9",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "separate PR?\n",
        "createdAt" : "2015-08-24T22:50:04Z",
        "updatedAt" : "2015-09-15T17:28:06Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "bd4705c414a31ed34eb9afa5d965f2494639ff3f",
    "line" : null,
    "diffHunk" : "@@ -1,1 +36,40 @@)\n\nvar _ volume.VolumeHost = &PersistentVolumeRecycler{}\n\n// PersistentVolumeRecycler is a controller that watches for PersistentVolumes that are released from their claims."
  },
  {
    "id" : "1fbd1c2e-994a-4731-9b74-2c2c0b1c24bb",
    "prId" : 9870,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "707da54a-bcfa-4a64-8259-2b8ab0865553",
        "parentId" : null,
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "What does this do?\n",
        "createdAt" : "2015-09-10T04:36:25Z",
        "updatedAt" : "2015-09-15T17:28:06Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      },
      {
        "id" : "e3e0cf7b-3062-40a1-9d19-9124b8d616e4",
        "parentId" : "707da54a-bcfa-4a64-8259-2b8ab0865553",
        "authorId" : "727fc82d-d969-41a4-a614-7fefce94f9a6",
        "body" : "This is an interface assertion.   It verifies that PersistentVolumeRecycler implements VolumeHost.\n",
        "createdAt" : "2015-09-10T12:11:15Z",
        "updatedAt" : "2015-09-15T17:28:06Z",
        "lastEditedBy" : "727fc82d-d969-41a4-a614-7fefce94f9a6",
        "tags" : [
        ]
      },
      {
        "id" : "6f3084b0-07b0-456d-b7d6-566d262e992c",
        "parentId" : "707da54a-bcfa-4a64-8259-2b8ab0865553",
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "Ah, cool\n",
        "createdAt" : "2015-09-10T18:23:44Z",
        "updatedAt" : "2015-09-15T17:28:06Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      }
    ],
    "commit" : "bd4705c414a31ed34eb9afa5d965f2494639ff3f",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +36,40 @@)\n\nvar _ volume.VolumeHost = &PersistentVolumeRecycler{}\n\n// PersistentVolumeRecycler is a controller that watches for PersistentVolumes that are released from their claims."
  }
]
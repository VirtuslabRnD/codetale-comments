[
  {
    "id" : "13fd5275-a2c6-404e-8c0e-61fd0863f7d3",
    "prId" : 18957,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9831a7d7-6644-4e95-823a-7f8d1dda141c",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "This should fail validation - only one / is allowed\n",
        "createdAt" : "2016-01-12T00:06:34Z",
        "updatedAt" : "2016-01-12T00:06:34Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "c7a25334-0902-468f-9b39-d55e0ea6057b",
        "parentId" : "9831a7d7-6644-4e95-823a-7f8d1dda141c",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "Sorry, I interpreted this as a k8s label, not a cloud tag\n",
        "createdAt" : "2016-01-12T00:07:19Z",
        "updatedAt" : "2016-01-12T00:07:19Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "8c48250a558130b003da587255dd8a6ae22b4399",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +33,37 @@\t// Name of a tag attached to a real volume in cloud (e.g. AWS EBS or GCE PD)\n\t// with namespace of a persistent volume claim used to create this volume.\n\tcloudVolumeCreatedForClaimNamespaceTag = \"kubernetes.io/created-for/pvc/namespace\"\n\t// Name of a tag attached to a real volume in cloud (e.g. AWS EBS or GCE PD)\n\t// with name of a persistent volume claim used to create this volume."
  },
  {
    "id" : "6ff390f0-1592-4e95-81a0-b5502138a10b",
    "prId" : 16432,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b65187ee-2dd9-4e7a-b69a-9be4ec018eb0",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "is this a new feature? not sure why it's in this PR\n",
        "createdAt" : "2015-10-30T02:06:44Z",
        "updatedAt" : "2015-11-12T19:12:55Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "a2ba2583-81b1-45e0-acdb-89912eb31e2a",
        "parentId" : "b65187ee-2dd9-4e7a-b69a-9be4ec018eb0",
        "authorId" : "727fc82d-d969-41a4-a614-7fefce94f9a6",
        "body" : "\"pre-binding\" was added in a previous PR.  It is useful to take advantage of now to help remove this race.\n",
        "createdAt" : "2015-10-30T03:22:07Z",
        "updatedAt" : "2015-11-12T19:12:55Z",
        "lastEditedBy" : "727fc82d-d969-41a4-a614-7fefce94f9a6",
        "tags" : [
        ]
      },
      {
        "id" : "80c6875d-364f-4069-a049-897b2cb9056d",
        "parentId" : "b65187ee-2dd9-4e7a-b69a-9be4ec018eb0",
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "> \"pre-binding\" was added in a previous PR. It is useful to take advantage of now to help remove this race.\n\nI've chased this through.  Have you planned a way to resolve this problem without using an experimental feature?\n",
        "createdAt" : "2015-11-03T18:22:24Z",
        "updatedAt" : "2015-11-12T19:12:55Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      },
      {
        "id" : "4046e0a5-9426-4ff2-8b9f-7ebb986cb892",
        "parentId" : "b65187ee-2dd9-4e7a-b69a-9be4ec018eb0",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "I don't see what benefit this gives us now that the claimRef is being added to the volume directly\n",
        "createdAt" : "2015-11-03T18:31:08Z",
        "updatedAt" : "2015-11-12T19:12:55Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "e91477d6-7701-4c89-812f-501ac74aa6f2",
        "parentId" : "b65187ee-2dd9-4e7a-b69a-9be4ec018eb0",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "if anything, I would expect this to find a volume with a claimRef set to the claim\n",
        "createdAt" : "2015-11-03T18:31:38Z",
        "updatedAt" : "2015-11-12T19:12:55Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "d5fb67af-5068-4255-84ef-fa475a5b6789",
        "parentId" : "b65187ee-2dd9-4e7a-b69a-9be4ec018eb0",
        "authorId" : "727fc82d-d969-41a4-a614-7fefce94f9a6",
        "body" : "I believe I can remove the annotation-based pre-bind altogether, but that was merged earlier and this PR slightly changes the binding behavior.  I wasn't sure who might be affected by that, so I figured I would remove the annotation in the future when dynamic provisioning goes from experimental to real feature.\n",
        "createdAt" : "2015-11-03T18:37:30Z",
        "updatedAt" : "2015-11-12T19:12:55Z",
        "lastEditedBy" : "727fc82d-d969-41a4-a614-7fefce94f9a6",
        "tags" : [
        ]
      },
      {
        "id" : "16ba12ed-7afa-4cf8-add1-f4dad37eda0f",
        "parentId" : "b65187ee-2dd9-4e7a-b69a-9be4ec018eb0",
        "authorId" : "727fc82d-d969-41a4-a614-7fefce94f9a6",
        "body" : "Per the previous comment, I removed the whole annotation bit.\n",
        "createdAt" : "2015-11-04T05:29:04Z",
        "updatedAt" : "2015-11-12T19:12:55Z",
        "lastEditedBy" : "727fc82d-d969-41a4-a614-7fefce94f9a6",
        "tags" : [
        ]
      }
    ],
    "commit" : "b9b8cf7fff297df724d9236240e84ba1fd97537e",
    "line" : 20,
    "diffHunk" : "@@ -1,1 +100,104 @@\t// but the fail to update claim.Spec.VolumeName fails.  This check allows the claim to find the volume\n\t// that's already bound to the claim.\n\tpreboundClaim := \"\"\n\tif createdFor, ok := searchPV.Annotations[createdForKey]; ok {\n\t\tpreboundClaim = createdFor"
  },
  {
    "id" : "0e14d3c7-3a68-4ef9-a887-530a53b43c52",
    "prId" : 16432,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c75bc5b6-147a-4651-9455-ccddad1a8df8",
        "parentId" : null,
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "How about reorganizing this block.  Looks like the logic is \n\n``` go\nif volume has [createdForKey] and it doesn't match prebound claim, skip\nif volume has createdForKey and it does match prebound claim, return it\nif volume doesn't have a spec claim ref, add it to the list\nif volume does have a spec claim ref that matches our preboundClaim, return it\n```\n\nCan you make that a switch case?\n",
        "createdAt" : "2015-11-03T18:41:43Z",
        "updatedAt" : "2015-11-12T19:12:55Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      },
      {
        "id" : "1d8a4094-51fb-48c5-a08d-cfa525fc16b9",
        "parentId" : "c75bc5b6-147a-4651-9455-ccddad1a8df8",
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "> How about reorganizing this block. Looks like the logic is\n\nAlso, if that's the logic, its currently broken.\n",
        "createdAt" : "2015-11-03T18:44:19Z",
        "updatedAt" : "2015-11-12T19:12:55Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      },
      {
        "id" : "96a76ef2-6e9c-40ae-9990-a8b11daf8754",
        "parentId" : "c75bc5b6-147a-4651-9455-ccddad1a8df8",
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "With the changes, is this now?\n\n``` go\nif volume.Spec.ClaimRef == nil{\n    unboundVolumes = append(unboundVolumes, volume)\n    continue\n}\n\nboundClaim := volume.Spec.ClaimRef.Namespace + \"/\" + volume.Spec.ClaimRef.Name\nif boundClaim == preboundClaim{\n    return volume, nil\n}\n```\n",
        "createdAt" : "2015-11-04T13:59:52Z",
        "updatedAt" : "2015-11-12T19:12:55Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      },
      {
        "id" : "9ebda563-06c0-4bb3-bc2f-f8c40ad5888a",
        "parentId" : "c75bc5b6-147a-4651-9455-ccddad1a8df8",
        "authorId" : "727fc82d-d969-41a4-a614-7fefce94f9a6",
        "body" : "Yes, this is more concisely written.\n",
        "createdAt" : "2015-11-04T16:09:25Z",
        "updatedAt" : "2015-11-12T19:12:55Z",
        "lastEditedBy" : "727fc82d-d969-41a4-a614-7fefce94f9a6",
        "tags" : [
        ]
      }
    ],
    "commit" : "b9b8cf7fff297df724d9236240e84ba1fd97537e",
    "line" : 31,
    "diffHunk" : "@@ -1,1 +115,119 @@\t\t// return the exact pre-binding match, if found\n\t\tunboundVolumes := []*api.PersistentVolume{}\n\t\tfor _, volume := range volumes {\n\t\t\tif volume.Spec.ClaimRef == nil {\n\t\t\t\t// volume isn't currently bound or pre-bound."
  },
  {
    "id" : "954b8eb2-e675-4148-b8db-36f5597b9493",
    "prId" : 10833,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bb90f88f-09a5-4453-94d6-990dc32140c9",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "I'm not sure I understand why this is two index calls.\n\n1) get a list of lists of modes that satisfy\n2) get a list of volumes with each list\n\nwhy can't it just get a list of volumes that satisfy in a single call to the index?\n",
        "createdAt" : "2015-08-21T05:50:07Z",
        "updatedAt" : "2015-08-27T19:35:32Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "42c9e6cc-054c-4e29-9966-4462cae52288",
        "parentId" : "bb90f88f-09a5-4453-94d6-990dc32140c9",
        "authorId" : "727fc82d-d969-41a4-a614-7fefce94f9a6",
        "body" : "This was, to me, the easiest way to search.\n\nEach PV is indexed exactly once using a string key that is the PV's stringified access modes.\n\nDifferent sets of access modes might match what the user asked for, but the index beneath the distinct stringified access modes might not contain the PV.  \n\nThis code calls into the index for each, as you noted.  Changing how the index keeps volumes and searches for them is a bigger change than simply dipping into the index more than once to find a match.\n",
        "createdAt" : "2015-08-27T19:45:45Z",
        "updatedAt" : "2015-08-27T20:08:49Z",
        "lastEditedBy" : "727fc82d-d969-41a4-a614-7fefce94f9a6",
        "tags" : [
        ]
      },
      {
        "id" : "d13bdb24-a6e0-4eea-a65a-8b0a26577992",
        "parentId" : "bb90f88f-09a5-4453-94d6-990dc32140c9",
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "This code is pretty hard to follow, mostly because of the multiple levels of indirection: a mapping from a fixed key (`accessmodes`) to an indexing function that takes a PV object and spits out an array of strings of length one which is a concatenation of modes in a specific order.\n\nI'd love to see this simplified, if at all possible.\n\nWithout fully understanding all the constraints you're working with, how about something like maintaining a max heaps of PVs (sorted by storage capacity) for each possible mode (RWO, ROX, RWX), where each PV could be in multiple heaps depending on the modes they support?\n",
        "createdAt" : "2015-08-31T23:54:00Z",
        "updatedAt" : "2015-08-31T23:54:00Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      },
      {
        "id" : "ed7a19db-4d5f-4733-a764-295a25e1a1fe",
        "parentId" : "bb90f88f-09a5-4453-94d6-990dc32140c9",
        "authorId" : "727fc82d-d969-41a4-a614-7fefce94f9a6",
        "body" : "@saad-ali Is there a way to make this current implementation more clear?  \n\nWhat you are proposing is a rewrite of the PV index.  That is, to me, riskier and more time consuming than this issue warrants.\n\nI think, too, there is an equivalence here.\n1.  Figure out all the possible combinations of access modes a PV can have (or are requested) and index the PV in each.  This allows us to query the index once.\n2.  Figure out all possible combinations that satisfy a request for a PV and query the index for each.  Keep the PV in a single index.\n\nEither way, It seems like one piece has to go from 1 to Many.  I choose the second option because it was simpler than trying to rewrite the index, which is riskier, IMHO.\n\nThoughts?\n",
        "createdAt" : "2015-09-02T17:15:46Z",
        "updatedAt" : "2015-09-02T17:15:46Z",
        "lastEditedBy" : "727fc82d-d969-41a4-a614-7fefce94f9a6",
        "tags" : [
        ]
      },
      {
        "id" : "5c871c50-c3cc-48a5-8e27-847b99871361",
        "parentId" : "bb90f88f-09a5-4453-94d6-990dc32140c9",
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "@markturansky That's fair. I don't see a way of easily simplifying this short of rewriting the indexing code and that's out-of-scope for this PR.\n",
        "createdAt" : "2015-09-03T22:34:27Z",
        "updatedAt" : "2015-09-03T22:34:27Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      }
    ],
    "commit" : "0b6030f50ce54d5caa8f131880ef8fa2d5df8001",
    "line" : 36,
    "diffHunk" : "@@ -1,1 +86,90 @@\t// Searches are performed against a set of access modes, so we can attempt not only the exact matching modes but also\n\t// potential matches (the GCEPD example above).\n\tallPossibleModes := pvIndex.allPossibleMatchingAccessModes(pv.Spec.AccessModes)\n\n\tfor _, modes := range allPossibleModes {"
  }
]
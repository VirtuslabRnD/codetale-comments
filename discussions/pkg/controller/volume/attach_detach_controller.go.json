[
  {
    "id" : "b250037f-a2f2-4fb8-aecb-da0ee2e8fd91",
    "prId" : 26351,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "760adf7c-4e53-4a1e-ae66-0e79045313e6",
        "parentId" : null,
        "authorId" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "body" : "Nit: log messages are supposed to start with lowercase letters -- no need to fix now, perhaps in a follow up.\n",
        "createdAt" : "2016-06-01T19:39:23Z",
        "updatedAt" : "2016-06-02T23:47:38Z",
        "lastEditedBy" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "tags" : [
        ]
      },
      {
        "id" : "b3f64fcb-ad78-4735-95c5-65df9a716c64",
        "parentId" : "760adf7c-4e53-4a1e-ae66-0e79045313e6",
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "My understanding is that rule is for error strings, since they may be concatenated at a higher level before being printed. But log messages are basically the end of the line so it is ok to capitalize in a way that makes it user readable. \n\nGoLang guidence (https://github.com/golang/go/wiki/CodeReviewComments#error-strings) seems to align with this: `This does not apply to logging, which is implicitly line-oriented and not combined inside other messages.`\n",
        "createdAt" : "2016-06-01T23:16:07Z",
        "updatedAt" : "2016-06-02T23:47:38Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      }
    ],
    "commit" : "9dbe943491d69762068c0ac021e1964d9c14873e",
    "line" : 85,
    "diffHunk" : "@@ -1,1 +304,308 @@\t\t\tif err != nil {\n\t\t\t\tglog.V(10).Infof(\n\t\t\t\t\t\"Failed to delete volume %q for pod %q/%q from desiredStateOfWorld. GenerateUniqueDeviceName failed with %v\",\n\t\t\t\t\tpodVolume.Name,\n\t\t\t\t\tpod.Namespace,"
  },
  {
    "id" : "3438ca58-2e2f-4d10-9141-4f560237f007",
    "prId" : 26351,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e5713ca9-8f38-43db-ae22-bd1cf8befd25",
        "parentId" : null,
        "authorId" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "body" : "You dropped the comment here.\n",
        "createdAt" : "2016-06-01T19:41:58Z",
        "updatedAt" : "2016-06-02T23:47:38Z",
        "lastEditedBy" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "tags" : [
        ]
      },
      {
        "id" : "81c140b5-ed00-4f01-afd6-abae060f11e9",
        "parentId" : "e5713ca9-8f38-43db-ae22-bd1cf8befd25",
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "Re-added comment.\n",
        "createdAt" : "2016-06-01T23:35:28Z",
        "updatedAt" : "2016-06-02T23:47:38Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      }
    ],
    "commit" : "9dbe943491d69762068c0ac021e1964d9c14873e",
    "line" : null,
    "diffHunk" : "@@ -1,1 +482,486 @@// corresponding volume in the actual state of the world to indicate that it is\n// mounted.\nfunc (adc *attachDetachController) processVolumesInUse(\n\tnodeName string, volumesInUse []api.UniqueDeviceName) {\n\tfor _, attachedVolume := range adc.actualStateOfWorld.GetAttachedVolumesForNode(nodeName) {"
  },
  {
    "id" : "8171b093-2814-4864-a606-706969d32e82",
    "prId" : 25457,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e012aca9-8663-4df5-adff-392104293d2a",
        "parentId" : null,
        "authorId" : null,
        "body" : "I am still reading the PR but is it possible to use the same data structure for actual and desired state of the world ? if so wouldn't that make the reconcile easier ?\n",
        "createdAt" : "2016-05-13T20:09:52Z",
        "updatedAt" : "2016-05-25T06:02:46Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "7ef3f642-4f17-49a5-b495-454dccb00c8f",
        "parentId" : "e012aca9-8663-4df5-adff-392104293d2a",
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "That was my original plan, but I when I started implementing it, turns out it's much easier to maintain two independent data structures especially because we have pods \"trickling\" in and not all available at once.\n",
        "createdAt" : "2016-05-13T20:30:10Z",
        "updatedAt" : "2016-05-25T06:02:46Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      }
    ],
    "commit" : "92500a20d72712f3ef8e825ee41c38a84288c4a3",
    "line" : 128,
    "diffHunk" : "@@ -1,1 +113,117 @@\n\tadc.desiredStateOfWorld = cache.NewDesiredStateOfWorld(&adc.volumePluginMgr)\n\tadc.actualStateOfWorld = cache.NewActualStateOfWorld(&adc.volumePluginMgr)\n\tadc.attacherDetacher = attacherdetacher.NewAttacherDetacher(&adc.volumePluginMgr)\n\tadc.reconciler = reconciler.NewReconciler("
  },
  {
    "id" : "63e538e8-4f1a-4077-a07e-d045fe4c14b6",
    "prId" : 25457,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "16604b2b-e05a-4cb1-b54f-6a73dc0affc1",
        "parentId" : null,
        "authorId" : null,
        "body" : "totally optional nit: s/getPVCFromCacheExtractPV/getPVName especially if you will always use the cache\n",
        "createdAt" : "2016-05-13T21:45:22Z",
        "updatedAt" : "2016-05-25T06:02:46Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "9ef51542-7000-41a2-93de-11bd27996b20",
        "parentId" : "16604b2b-e05a-4cb1-b54f-6a73dc0affc1",
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "I'll leave it as is. A little verbose, but I want the reader to not forget what is happening and where it is coming from.\n",
        "createdAt" : "2016-05-13T23:38:11Z",
        "updatedAt" : "2016-05-25T06:02:46Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      }
    ],
    "commit" : "92500a20d72712f3ef8e825ee41c38a84288c4a3",
    "line" : 400,
    "diffHunk" : "@@ -1,1 +371,375 @@// with the given namespace/name.\n// This method returns an error if the PVC object's phase is not \"Bound\".\nfunc (adc *attachDetachController) getPVCFromCacheExtractPV(\n\tnamespace string, name string) (string, types.UID, error) {\n\tkey := name"
  },
  {
    "id" : "c8f0dcc4-a96d-437e-953e-b4860dbad522",
    "prId" : 25457,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1634202e-b9e1-468e-93ee-dea095bbde4b",
        "parentId" : null,
        "authorId" : null,
        "body" : "So if a node is deleted should we not detach all volumes ?.. ie mark all its volumes SafeToDetach ?\n",
        "createdAt" : "2016-05-22T23:47:51Z",
        "updatedAt" : "2016-05-25T06:02:46Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "3f33d8e5-9ecd-4f4b-9bbf-a549db388854",
        "parentId" : "1634202e-b9e1-468e-93ee-dea095bbde4b",
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "The node will only be deleted from the \"actual state of the world\" if there are no volumes already attached. If there are, it we will let the node controller start deleting pods which will trigger the detaches (we will not implicitly delete the pods).\n",
        "createdAt" : "2016-05-23T19:19:57Z",
        "updatedAt" : "2016-05-25T06:02:46Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      }
    ],
    "commit" : "92500a20d72712f3ef8e825ee41c38a84288c4a3",
    "line" : null,
    "diffHunk" : "@@ -1,1 +241,245 @@\t}\n\n\tadc.processSafeToDetachAnnotations(nodeName, node.Annotations)\n}\n"
  },
  {
    "id" : "30501094-d976-40bc-b755-16d3ef18c59f",
    "prId" : 25457,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d3c54d98-7ffd-4ae2-92b0-baa963f13a6b",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "exactly what is running at 10 Hz?\n",
        "createdAt" : "2016-05-24T21:32:43Z",
        "updatedAt" : "2016-05-25T06:02:46Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "23fc1384-756e-46a9-92d5-9c2f70d3a2b9",
        "parentId" : "d3c54d98-7ffd-4ae2-92b0-baa963f13a6b",
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "The amount of time the reconciler waits between successive executions. Each execution looks at \"actual state of world\" and \"desired state of world\" and triggers actions required to reconcile.\n",
        "createdAt" : "2016-05-24T21:43:54Z",
        "updatedAt" : "2016-05-25T06:02:46Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      }
    ],
    "commit" : "92500a20d72712f3ef8e825ee41c38a84288c4a3",
    "line" : null,
    "diffHunk" : "@@ -1,1 +52,56 @@\t// loopPeriod is the ammount of time the reconciler loop waits between\n\t// successive executions\n\treconcilerLoopPeriod time.Duration = 100 * time.Millisecond\n\n\t// reconcilerMaxSafeToDetachDuration is the maximum amount of time the"
  },
  {
    "id" : "b296ec95-c6ae-48c7-81e3-5c981172cd59",
    "prId" : 25457,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7a30594f-5cef-4885-a716-a1a3d3e1982d",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "This issue is resolved and the fix is merged.  \n",
        "createdAt" : "2016-05-24T21:34:32Z",
        "updatedAt" : "2016-05-25T06:02:46Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "f7071ae6-c8bd-43cc-aab1-351d5be1cf86",
        "parentId" : "7a30594f-5cef-4885-a716-a1a3d3e1982d",
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "Was going to do this in a follow-up PR, but since that issue is now merged, I'll do it now.\n",
        "createdAt" : "2016-05-24T21:44:56Z",
        "updatedAt" : "2016-05-25T06:02:46Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      },
      {
        "id" : "58654ab7-4ca6-41bd-90a7-ce4862209de9",
        "parentId" : "7a30594f-5cef-4885-a716-a1a3d3e1982d",
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "So looks like the only thing I have to do is update the [MinResyncPeriod](https://github.com/kubernetes/kubernetes/blob/master/cmd/kube-controller-manager/app/options/options.go#L66). However since I am using shared informers this change will affect other controllers that use the shared informers. Therefore, I will do it in a separate/isolated/explicit PR saying \"I'm changing the default Resync period for shared informers from from 12 hours to 1 minute, because PR #24142 made it so Resync does not result in relist\".\n\nFor this PR I will leave this comment.\n",
        "createdAt" : "2016-05-25T03:50:39Z",
        "updatedAt" : "2016-05-25T06:02:46Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      }
    ],
    "commit" : "92500a20d72712f3ef8e825ee41c38a84288c4a3",
    "line" : 97,
    "diffHunk" : "@@ -1,1 +80,84 @@\t// time, we don't want to have to wait 12hrs before processing the pod\n\t// again.\n\t// Luckily https://github.com/kubernetes/kubernetes/issues/23394 is being\n\t// worked on and will split resync in to resync and relist. Once that\n\t// happens the resync period can be set to something much faster (30"
  },
  {
    "id" : "71c6bd00-19a5-4122-9c62-7e3d374cec9e",
    "prId" : 25457,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "eb6b3e05-7855-406f-b04d-51f957b71822",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "is there a reason for this?  paranoia is fun, but there ought to be a limit\n",
        "createdAt" : "2016-05-24T21:53:16Z",
        "updatedAt" : "2016-05-25T06:02:46Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "17ab01af-36b4-4dda-9df6-ac4e7c3e6fa4",
        "parentId" : "eb6b3e05-7855-406f-b04d-51f957b71822",
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "Paranoia == defensive programming =P\n",
        "createdAt" : "2016-05-24T22:46:13Z",
        "updatedAt" : "2016-05-25T06:02:46Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      },
      {
        "id" : "1de31ae6-906e-45c0-ba06-daad8fc9dd02",
        "parentId" : "eb6b3e05-7855-406f-b04d-51f957b71822",
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "As discussed above, safeToDetach annotation stuff will be removed in follow up PR in favor of new Node Status field.\n",
        "createdAt" : "2016-05-25T02:58:05Z",
        "updatedAt" : "2016-05-25T06:02:46Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      }
    ],
    "commit" : "92500a20d72712f3ef8e825ee41c38a84288c4a3",
    "line" : 495,
    "diffHunk" : "@@ -1,1 +466,470 @@\tfor annotation := range annotations {\n\t\t// Check annotations for \"safe to detach\" volumes\n\t\tannotation = strings.ToLower(annotation)\n\t\tif strings.HasPrefix(annotation, SafeToDetachAnnotation) {\n\t\t\t// If volume exists in \"actual state of world\" mark it as safe to detach"
  },
  {
    "id" : "624cba37-8aa1-41ca-81a7-ac7a782e6c15",
    "prId" : 25457,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fa6b436d-3793-495a-a45e-f8fe2c591d88",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "use pkg/types/namespacedname.go ?  string type aliases (for strings in particular) are your friend\n",
        "createdAt" : "2016-05-24T21:56:51Z",
        "updatedAt" : "2016-05-25T06:02:46Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "5441b29a-5d67-4354-87a0-f9c284c9a48e",
        "parentId" : "fa6b436d-3793-495a-a45e-f8fe2c591d88",
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "Ah, nice.\n",
        "createdAt" : "2016-05-24T22:47:14Z",
        "updatedAt" : "2016-05-25T06:02:46Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      },
      {
        "id" : "35a1ad64-a8d0-4f38-96c6-9a1c28583f09",
        "parentId" : "fa6b436d-3793-495a-a45e-f8fe2c591d88",
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "My data structures are keyed off strings, and I don't want to go in and flip them all to `NamespacedName`. To avoid identical code, I modified `getUniquePodName` to use `NamespacedName` internally to generate the string .\n",
        "createdAt" : "2016-05-25T03:07:36Z",
        "updatedAt" : "2016-05-25T06:02:46Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      },
      {
        "id" : "cad5f5a6-40ab-4a05-87bc-f584de9d15d7",
        "parentId" : "fa6b436d-3793-495a-a45e-f8fe2c591d88",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "Add a TODO to use `NamespacedName` rather than `string` ?\n",
        "createdAt" : "2016-05-25T05:28:36Z",
        "updatedAt" : "2016-05-25T06:02:46Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "6f49b712-b2ea-49e1-92b5-7690f819f1f8",
        "parentId" : "fa6b436d-3793-495a-a45e-f8fe2c591d88",
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "I'd prefer to leave the actual/desired/etc data structures keyed off a string rather than a struct of namespace/name. There is no reason the data structs need to be aware of the intricacies of what makes up a unique pod name. All they care about is a unique key for a given pod, that's it. How/what the caller (attach_detach_controller) does do generate that key is up to the caller. Separation of responsibilities and all that.\n",
        "createdAt" : "2016-05-25T05:40:54Z",
        "updatedAt" : "2016-05-25T06:02:46Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      },
      {
        "id" : "7c8bcc68-a1f5-4fad-b884-d87aa5da2c96",
        "parentId" : "fa6b436d-3793-495a-a45e-f8fe2c591d88",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "I'll turn it around on you then - you should have defined an opaque type\nfrom the start.  any time you start keying on strings in objects, it's a\nsmell.  Consider strong types where formatted content matters.\n\n```\ntype MyKey NamespacedName\n```\n\ngives you your type safety (never accidentally set the wrong format string)\nand opacity.\n\nOn Tue, May 24, 2016 at 10:41 PM, Saad Ali notifications@github.com wrote:\n\n> In pkg/controller/volume/attach_detach_controller.go\n> https://github.com/kubernetes/kubernetes/pull/25457#discussion_r64517837\n> :\n> \n> > -       if strings.HasPrefix(annotation, SafeToDetachAnnotation) {\n> > -           // If volume exists in \"actual state of world\" mark it as safe to detach\n> > -           safeToAttachVolume := strings.TrimPrefix(annotation, SafeToDetachAnnotation)\n> > -           if err := adc.actualStateOfWorld.MarkVolumeNodeSafeToDetach(safeToAttachVolume, nodeName); err != nil {\n> > -               // If volume doesn't exist in \"actual state of world\" remove\n> > -               // the \"safe to detach\" annotation from the node\n> > -               annotationsToRemove = append(annotationsToRemove, annotation)\n> > -           }\n> > -       }\n> > -   }\n> >   +\n> > -   // TODO: Call out to API server to delete annotationsToRemove from Node\n> >   +}\n> >   +\n> >   +// getUniquePodName returns a unique name to reference pod by in memory caches\n> >   +func getUniquePodName(pod *api.Pod) string {\n> \n> I'd prefer to leave the actual/desired/etc data structures keyed off a\n> string rather than a struct of namespace/name. There is no reason the data\n> structs need to be aware of the intricacies of what makes up a unique pod\n> name. All they care about is a unique key for a given pod, that's it.\n> How/what the caller (attach_detach_controller) does do generate that key is\n> up to the caller. Separation of responsibilities and all that.\n> \n> â€”\n> You are receiving this because you were assigned.\n> Reply to this email directly or view it on GitHub\n> https://github.com/kubernetes/kubernetes/pull/25457/files/6303cf96f7e05cf57ebcdcf5585ea4db5f27ed39#r64517837\n",
        "createdAt" : "2016-05-25T06:06:55Z",
        "updatedAt" : "2016-05-25T06:06:55Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "c8aeaa99-1e58-4cc2-99c8-967f2324f118",
        "parentId" : "fa6b436d-3793-495a-a45e-f8fe2c591d88",
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "type safety == good point. It's easy to pass in the wrong string value. It's a lot harder to construct and pass in the wrong object. It doesn't have to be the `NamespacedName` object, but I agree the keys should be opaque types. Opened https://github.com/kubernetes/kubernetes/issues/26250 to track\n",
        "createdAt" : "2016-05-25T06:28:22Z",
        "updatedAt" : "2016-05-25T06:28:22Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      }
    ],
    "commit" : "92500a20d72712f3ef8e825ee41c38a84288c4a3",
    "line" : 511,
    "diffHunk" : "@@ -1,1 +482,486 @@\n// getUniquePodName returns a unique name to reference pod by in memory caches\nfunc getUniquePodName(pod *api.Pod) string {\n\treturn types.NamespacedName{Namespace: pod.Namespace, Name: pod.Name}.String()\n}"
  },
  {
    "id" : "3ebff699-93ba-437f-8550-9acd6e50cf8d",
    "prId" : 25008,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fed3f07d-da4f-4e78-8cea-12bd0b54b283",
        "parentId" : null,
        "authorId" : null,
        "body" : "Why is this needed ? Do you anticipate getting uninitialized informers ? If not it would make the code simpler to remove this and the boolean check below.\n",
        "createdAt" : "2016-05-06T14:46:28Z",
        "updatedAt" : "2016-05-09T18:34:33Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "0ff6eb30-88a2-40f8-9aca-f0b9932e5a48",
        "parentId" : "fed3f07d-da4f-4e78-8cea-12bd0b54b283",
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "It's for testing--following similar pattern to existing controllers using the shared informers\n",
        "createdAt" : "2016-05-06T18:07:45Z",
        "updatedAt" : "2016-05-09T18:34:33Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      }
    ],
    "commit" : "214b4c28bc5f4df4ce961550ca60fc42ad3c9f82",
    "line" : null,
    "diffHunk" : "@@ -1,1 +70,74 @@\t\tnodeInformer = informers.CreateSharedNodeIndexInformer(kubeClient, resyncPeriod)\n\t\tselfCreatedNodeInformer = true\n\t}\n\n\tadc := &attachDetachController{"
  }
]
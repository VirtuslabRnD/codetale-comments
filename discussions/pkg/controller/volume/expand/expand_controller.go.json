[
  {
    "id" : "58b363ed-b56b-472e-86a0-94880b93a536",
    "prId" : 94489,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/94489#pullrequestreview-487232988",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a1a28e91-cf46-4bac-8e84-422c857bbee5",
        "parentId" : null,
        "authorId" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "body" : "spoke with @msau42 offline and I think we don't need to read storageclass at all in expand_controller. Can you just get resizer name from `volumePlugin.GetPluginName()` which should be same as provisioner name for all intree plugin types and for out of tree plugins, we don't really set those here anyways.\r\n\r\n",
        "createdAt" : "2020-09-10T19:56:09Z",
        "updatedAt" : "2020-09-19T14:34:01Z",
        "lastEditedBy" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "tags" : [
        ]
      },
      {
        "id" : "b4aea069-5f4d-4ce3-b3d8-9c3d92f9409c",
        "parentId" : "a1a28e91-cf46-4bac-8e84-422c857bbee5",
        "authorId" : "018d6ca2-feee-4457-ae9c-f599edb91f62",
        "body" : "Nice suggestion indeed, thank you! I now adapted to `volumePlugin.GetPluginName()` and removed the StorageClass lister. You can have another look.",
        "createdAt" : "2020-09-12T14:23:28Z",
        "updatedAt" : "2020-09-19T14:34:01Z",
        "lastEditedBy" : "018d6ca2-feee-4457-ae9c-f599edb91f62",
        "tags" : [
        ]
      }
    ],
    "commit" : "3bc560225e1bca19b57985a443b72c5f8d19a712",
    "line" : 90,
    "diffHunk" : "@@ -1,1 +282,286 @@\n\tvolumeResizerName := volumePlugin.GetPluginName()\n\treturn expc.expand(pvc, pv, volumeResizerName)\n}\n"
  },
  {
    "id" : "6f627319-f28d-4edb-8e56-519710bc5bf7",
    "prId" : 94144,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/94144#pullrequestreview-485920159",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2c4dde96-c397-4421-9c21-26d6843b6056",
        "parentId" : null,
        "authorId" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "body" : "Did you consider adding a PV to `expc.pvLister` after the PV is saved with the new size? Would that save us from an API call?",
        "createdAt" : "2020-09-10T12:55:20Z",
        "updatedAt" : "2020-09-10T14:03:37Z",
        "lastEditedBy" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "tags" : [
        ]
      },
      {
        "id" : "049e18a4-6af1-4fef-a44d-01f08f8119ae",
        "parentId" : "2c4dde96-c397-4421-9c21-26d6843b6056",
        "authorId" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "body" : "I did. it is kind of complicated to do that because expansion call is handled by operation_generator(and we don't have informer there) and it will require some larger re-factoring to do that correctly. I think overall since this call is only made after it has been determined expansion is needed and we don't expect people to be resizing volumes that often, it is I think acceptable tradeoff.\r\n",
        "createdAt" : "2020-09-10T13:01:13Z",
        "updatedAt" : "2020-09-10T14:03:37Z",
        "lastEditedBy" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "tags" : [
        ]
      },
      {
        "id" : "0cfa96fa-c411-4ce2-9df6-39d19a089d98",
        "parentId" : "2c4dde96-c397-4421-9c21-26d6843b6056",
        "authorId" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "body" : "Ack",
        "createdAt" : "2020-09-10T13:19:20Z",
        "updatedAt" : "2020-09-10T14:03:37Z",
        "lastEditedBy" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "tags" : [
        ]
      }
    ],
    "commit" : "46148171000eae92aecfa952be95e2209d407b78",
    "line" : 21,
    "diffHunk" : "@@ -1,1 +227,231 @@\t}\n\n\tpv, err := expc.getPersistentVolume(pvc)\n\tif err != nil {\n\t\tklog.V(5).Infof(\"Error getting Persistent Volume for PVC %q (uid: %q) from informer : %v\", util.GetPersistentVolumeClaimQualifiedName(pvc), pvc.UID, err)"
  },
  {
    "id" : "11a8f53c-660f-4703-bd52-d173410698a6",
    "prId" : 77994,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/77994#pullrequestreview-243430398",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "522d2d6b-4917-42c7-9081-70224bfb334e",
        "parentId" : null,
        "authorId" : "41981c80-b404-4c55-bd22-5f96c0512a61",
        "body" : "Even if the plugin support CSI migration, should also check for whether the migration is enabled and supported by kubelet using [`nodeUsingCSIPlugin` ](https://github.com/kubernetes/kubernetes/blob/master/pkg/volume/util/operationexecutor/operation_generator.go#L1745)",
        "createdAt" : "2019-05-16T22:52:49Z",
        "updatedAt" : "2019-05-29T15:02:17Z",
        "lastEditedBy" : "41981c80-b404-4c55-bd22-5f96c0512a61",
        "tags" : [
        ]
      },
      {
        "id" : "26b214af-1d2f-4e83-b9cf-44b375fcf0d6",
        "parentId" : "522d2d6b-4917-42c7-9081-70224bfb334e",
        "authorId" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "body" : "Thats a good point but I do not think we can check if plugin is installed on the node via `nodeUsingCSIPlugin` because resize operation does not have a relationship with the node. \r\n\r\nThinking some more I think even if CSI plugin was not installed on the node and control-plane expansion was done using CSI resizer, the file system expansion can still be performed by in-tree driver and everything should just work.  ",
        "createdAt" : "2019-05-17T15:26:28Z",
        "updatedAt" : "2019-05-29T15:02:17Z",
        "lastEditedBy" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "tags" : [
        ]
      },
      {
        "id" : "e16ac226-b657-4e71-9f38-55671c8c9fa8",
        "parentId" : "522d2d6b-4917-42c7-9081-70224bfb334e",
        "authorId" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "body" : "Also, this will be less of a concern once https://github.com/kubernetes/enhancements/blob/master/keps/sig-storage/20190408-volume-scheduling-limits.md is impelemted, because then if CSI migration has been enabled for a plugin and plugin is not installed on the node, then the node will not have pod scheduled to the node.\r\n\r\nI am thinking we may be able to remove entire `nodeUsingCSIPlugin` logic, once volume limit KEP is implemented. \r\n\r\n",
        "createdAt" : "2019-05-17T19:34:18Z",
        "updatedAt" : "2019-05-29T15:02:17Z",
        "lastEditedBy" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "tags" : [
        ]
      },
      {
        "id" : "6c604ef6-5e76-4d4e-9b35-a2e047c76f80",
        "parentId" : "522d2d6b-4917-42c7-9081-70224bfb334e",
        "authorId" : "41981c80-b404-4c55-bd22-5f96c0512a61",
        "body" : "Node uses in-tree plugin while controller uses CSi driver is a combination we are trying to avoid in other cases. I remember is reason was it's hard to guarantee the compatibility between the two. \r\n\r\n@davidz627 How do you think?",
        "createdAt" : "2019-05-17T22:55:53Z",
        "updatedAt" : "2019-05-29T15:02:17Z",
        "lastEditedBy" : "41981c80-b404-4c55-bd22-5f96c0512a61",
        "tags" : [
        ]
      },
      {
        "id" : "0f2bde98-a3ef-414c-91f4-a23fa5bd3e23",
        "parentId" : "522d2d6b-4917-42c7-9081-70224bfb334e",
        "authorId" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "body" : "Sure - but:\r\n\r\na. We can't avoid it in this case.\r\nb. Since nodes which doesn't have CSI plugin will not have migrated volumes scheduled on them, this will be a non-issue.",
        "createdAt" : "2019-05-20T14:57:27Z",
        "updatedAt" : "2019-05-29T15:02:17Z",
        "lastEditedBy" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "tags" : [
        ]
      },
      {
        "id" : "e7891d8a-5fe1-4fb2-a9b3-320b52d9d6b3",
        "parentId" : "522d2d6b-4917-42c7-9081-70224bfb334e",
        "authorId" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "body" : "`IsMigratedToCSI()` checks if a particular plugin has necessary feature gates in controller-manager.\r\n\r\nIt can happen that a volume is migrated in the controller and is thus resized by CSI driver and then it is scheduled on a node that has disabled migration for this plugin. In-tree `NodeExpand()` will be called there. IMO, it should not be an issue, as both do just `resize2fs` (or something similar), but CSI driver authors must be aware of this and don't expect that `NodeExpand()` is always handled by the CSI driver.\r\n\r\n@davidz627 @ddebroy: we should also document this somehow - do we have a guide with requirements to CSI driver authors of the migrated drivers?\r\n",
        "createdAt" : "2019-05-27T12:48:47Z",
        "updatedAt" : "2019-05-29T15:02:17Z",
        "lastEditedBy" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "tags" : [
        ]
      },
      {
        "id" : "f5d73007-858c-4456-b939-52077c5d52cc",
        "parentId" : "522d2d6b-4917-42c7-9081-70224bfb334e",
        "authorId" : "542e5d2f-2ff9-4674-ab44-78f31768e7a1",
        "body" : "My preference would be to keep the same logic we use for attach/mount sync here - that we want to use one type of backend for both controller calls & node calls and therefore we should use `nodeUsingCSIPlugin`. I understand that theoretically there shouldn't be an issue but that is also the case for *most* of the plugins for attach/mount steps as well. The issue is that it is impossible to actually guarantee that the controller/node level operations are compatible between migrated/not-migrated since there can be driver specific quirks.\r\n\r\n@jsafrane I am working on a guide for requirements to CSI Driver authors.",
        "createdAt" : "2019-05-28T20:36:36Z",
        "updatedAt" : "2019-05-29T15:02:17Z",
        "lastEditedBy" : "542e5d2f-2ff9-4674-ab44-78f31768e7a1",
        "tags" : [
        ]
      },
      {
        "id" : "83c48920-9d6d-4710-a0a8-17df25a3679f",
        "parentId" : "522d2d6b-4917-42c7-9081-70224bfb334e",
        "authorId" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "body" : "The problem is - contrary to attach/mount operation, no such relationship exists between node and control-plane resize operation. \r\n\r\nThe volume may not be in-use by any pod when resize was attempted.",
        "createdAt" : "2019-05-28T20:41:40Z",
        "updatedAt" : "2019-05-29T15:02:17Z",
        "lastEditedBy" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "tags" : [
        ]
      },
      {
        "id" : "4722ed87-cead-440e-9254-f846701f2f3b",
        "parentId" : "522d2d6b-4917-42c7-9081-70224bfb334e",
        "authorId" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "body" : "There is an option for \"delayed resizing\" - wait until a pod is scheduled. But I don't like it, it breaks current behavior and looks ugly.\r\n\r\n> The issue is that it is impossible to actually guarantee that the controller/node level operations are compatible between migrated/not-migrated since there can be driver specific quirks.\r\n\r\nIMO, there are no driver specific quirks for filesystem resize in-tree. We can require the same behavior for migrated drivers.",
        "createdAt" : "2019-05-29T09:03:11Z",
        "updatedAt" : "2019-05-29T15:02:17Z",
        "lastEditedBy" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "tags" : [
        ]
      },
      {
        "id" : "b406dc92-788a-4dc8-a15e-9e1ddbe8ba49",
        "parentId" : "522d2d6b-4917-42c7-9081-70224bfb334e",
        "authorId" : "542e5d2f-2ff9-4674-ab44-78f31768e7a1",
        "body" : "ok, understood!",
        "createdAt" : "2019-05-29T18:08:15Z",
        "updatedAt" : "2019-05-29T18:08:16Z",
        "lastEditedBy" : "542e5d2f-2ff9-4674-ab44-78f31768e7a1",
        "tags" : [
        ]
      }
    ],
    "commit" : "7563b4d01b5e5dde148f746ccb1ff47c5b5b9272",
    "line" : 108,
    "diffHunk" : "@@ -1,1 +253,257 @@\t}\n\n\tif volumePlugin.IsMigratedToCSI() {\n\t\tmsg := fmt.Sprintf(\"CSI migration enabled for %s; waiting for external resizer to expand the pvc\", volumeResizerName)\n\t\texpc.recorder.Event(pvc, v1.EventTypeNormal, events.ExternalExpanding, msg)"
  },
  {
    "id" : "d9afe640-7342-4bda-84b6-4a6e0f4f4f84",
    "prId" : 77994,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/77994#pullrequestreview-238674333",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8fea572d-cc49-4c51-a66b-9d67fe21733c",
        "parentId" : null,
        "authorId" : "41981c80-b404-4c55-bd22-5f96c0512a61",
        "body" : "should add classlisterSynced to?\r\n```\r\nif !controller.WaitForCacheSync(\"expand\", stopCh, expc.pvcsSynced, expc.pvSynced) {\r\n```",
        "createdAt" : "2019-05-16T22:58:59Z",
        "updatedAt" : "2019-05-29T15:02:17Z",
        "lastEditedBy" : "41981c80-b404-4c55-bd22-5f96c0512a61",
        "tags" : [
        ]
      }
    ],
    "commit" : "7563b4d01b5e5dde148f746ccb1ff47c5b5b9272",
    "line" : 54,
    "diffHunk" : "@@ -1,1 +112,116 @@\t\tpvSynced:          pvInformer.Informer().HasSynced,\n\t\tclassLister:       scInformer.Lister(),\n\t\tclassListerSynced: scInformer.Informer().HasSynced,\n\t\tqueue:             workqueue.NewNamedRateLimitingQueue(workqueue.DefaultControllerRateLimiter(), \"volume_expand\"),\n\t}"
  },
  {
    "id" : "21ae7acc-b0e0-4b37-b370-19e47c92de82",
    "prId" : 77994,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/77994#pullrequestreview-243430711",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "465c9ed1-ef85-4f4b-b50c-2636237a5c40",
        "parentId" : null,
        "authorId" : "542e5d2f-2ff9-4674-ab44-78f31768e7a1",
        "body" : "looks like we log an error event whenever there is an error. Do we instead want to log the event at a higher level so as to not have to do an explicit event recording before each error case?",
        "createdAt" : "2019-05-28T20:48:28Z",
        "updatedAt" : "2019-05-29T15:02:17Z",
        "lastEditedBy" : "542e5d2f-2ff9-4674-ab44-78f31768e7a1",
        "tags" : [
        ]
      },
      {
        "id" : "1487fb1f-557f-41fd-9688-ab2a58c12539",
        "parentId" : "465c9ed1-ef85-4f4b-b50c-2636237a5c40",
        "authorId" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "body" : "but the logs will only be accessible to admin and I think we should surface any errors associated with resizing in PVC itself.",
        "createdAt" : "2019-05-29T14:28:22Z",
        "updatedAt" : "2019-05-29T15:02:17Z",
        "lastEditedBy" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "tags" : [
        ]
      },
      {
        "id" : "bc104b68-7d15-4891-ba09-26ed855a3662",
        "parentId" : "465c9ed1-ef85-4f4b-b50c-2636237a5c40",
        "authorId" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "body" : "I think the idea was to return error to caller and the caller records event, instead of individual event creation in this function.\r\n\r\nI can see there are paths that return `err` without creating event, not sure if they're worth creating an event or not.",
        "createdAt" : "2019-05-29T15:41:34Z",
        "updatedAt" : "2019-05-29T15:41:35Z",
        "lastEditedBy" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "tags" : [
        ]
      },
      {
        "id" : "f929faf3-e773-40c9-81b3-ef525c4ec606",
        "parentId" : "465c9ed1-ef85-4f4b-b50c-2636237a5c40",
        "authorId" : "542e5d2f-2ff9-4674-ab44-78f31768e7a1",
        "body" : "makes sense. I was under the impression any error was also logged as event. If that is not the case please ignore this comment",
        "createdAt" : "2019-05-29T18:08:51Z",
        "updatedAt" : "2019-05-29T18:08:51Z",
        "lastEditedBy" : "542e5d2f-2ff9-4674-ab44-78f31768e7a1",
        "tags" : [
        ]
      }
    ],
    "commit" : "7563b4d01b5e5dde148f746ccb1ff47c5b5b9272",
    "line" : 114,
    "diffHunk" : "@@ -1,1 +259,263 @@\t\tif err != nil {\n\t\t\terrorMsg := fmt.Sprintf(\"error getting CSI driver name for pvc %s, with error %v\", util.ClaimToClaimKey(pvc), err)\n\t\t\texpc.recorder.Event(pvc, v1.EventTypeWarning, events.ExternalExpanding, errorMsg)\n\t\t\treturn fmt.Errorf(errorMsg)\n\t\t}"
  },
  {
    "id" : "061de32a-87f8-4689-b6c2-e6c34851e56c",
    "prId" : 77883,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/77883#pullrequestreview-238408930",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3d3d3b30-77e3-437d-834c-213338df12d4",
        "parentId" : null,
        "authorId" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "body" : "`volumePlugin` is not really used in this function and `expand() / GenerateExpandVolumeFunc()` will looks for the plugin again shortly. Would it be possible to move check for non-resizeable volume plugin there?",
        "createdAt" : "2019-05-15T08:43:02Z",
        "updatedAt" : "2019-05-17T01:35:09Z",
        "lastEditedBy" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "tags" : [
        ]
      },
      {
        "id" : "fb51e70d-e1cd-48e2-8969-783e4c261c1f",
        "parentId" : "3d3d3b30-77e3-437d-834c-213338df12d4",
        "authorId" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "body" : "hmm, yeah we could.  but shortly after this change, we are going to make changes to annotate the PVC when migration is enabled and PVC should be resized by external resizer. I was thinking it is better to do this in `expand_controller.go` rather than inside operation_generator. \r\n\r\nIn worst case, this will cause plugin look up twice, which doesn't seem too expensive. wdyt?",
        "createdAt" : "2019-05-15T16:36:10Z",
        "updatedAt" : "2019-05-17T01:35:09Z",
        "lastEditedBy" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "tags" : [
        ]
      },
      {
        "id" : "a963dd3e-f8fa-40d5-b376-2d143135c474",
        "parentId" : "3d3d3b30-77e3-437d-834c-213338df12d4",
        "authorId" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "body" : "Performance-wise it's ok, I don't like big chunk of code almost copied on two places.",
        "createdAt" : "2019-05-15T17:04:06Z",
        "updatedAt" : "2019-05-17T01:35:09Z",
        "lastEditedBy" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "tags" : [
        ]
      },
      {
        "id" : "edcddda6-4f1a-449d-87c3-02520d2f36d3",
        "parentId" : "3d3d3b30-77e3-437d-834c-213338df12d4",
        "authorId" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "body" : "Ok, I can see this part spits an event about external resizer and we probably don't want to have this piece in OperationGenerator because it would mess up with metrics. So leave it as it is.",
        "createdAt" : "2019-05-16T13:56:38Z",
        "updatedAt" : "2019-05-17T01:35:09Z",
        "lastEditedBy" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "tags" : [
        ]
      }
    ],
    "commit" : "4886e8782c82e1484b04b9d14bb589548ebca83e",
    "line" : 214,
    "diffHunk" : "@@ -1,1 +209,213 @@\n\tvolumeSpec := volume.NewSpecFromPersistentVolume(pv, false)\n\tvolumePlugin, err := expc.volumePluginMgr.FindExpandablePluginBySpec(volumeSpec)\n\tif err != nil || volumePlugin == nil {\n\t\tmsg := fmt.Errorf(\"didn't find a plugin capable of expanding the volume; \" +"
  },
  {
    "id" : "8709c73c-1dc7-4f83-beb4-c6b17376af33",
    "prId" : 77883,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/77883#pullrequestreview-237962886",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "87d453f6-67b6-48be-8619-e85e2299d54d",
        "parentId" : null,
        "authorId" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "body" : "PVC remains \"marked\" even if `GenerateExpandVolumeFunc` below fails. It would be maybe better to swap these calls.",
        "createdAt" : "2019-05-15T08:44:30Z",
        "updatedAt" : "2019-05-17T01:35:09Z",
        "lastEditedBy" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "tags" : [
        ]
      },
      {
        "id" : "7c9035b8-994f-439f-a6d4-67333853eb95",
        "parentId" : "87d453f6-67b6-48be-8619-e85e2299d54d",
        "authorId" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "body" : "Since there is no resizing failure condition, presence of a perpetual resizing condition means volume is still being considered for resizing and resizing is pending on the volume. ",
        "createdAt" : "2019-05-15T16:30:23Z",
        "updatedAt" : "2019-05-17T01:35:09Z",
        "lastEditedBy" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "tags" : [
        ]
      },
      {
        "id" : "3e849352-26a0-453c-9006-b1941db7cb5d",
        "parentId" : "87d453f6-67b6-48be-8619-e85e2299d54d",
        "authorId" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "body" : "ack",
        "createdAt" : "2019-05-15T17:22:48Z",
        "updatedAt" : "2019-05-17T01:35:09Z",
        "lastEditedBy" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "tags" : [
        ]
      }
    ],
    "commit" : "4886e8782c82e1484b04b9d14bb589548ebca83e",
    "line" : 234,
    "diffHunk" : "@@ -1,1 +226,230 @@\nfunc (expc *expandController) expand(pvc *v1.PersistentVolumeClaim, pv *v1.PersistentVolume) error {\n\tpvc, err := util.MarkResizeInProgress(pvc, expc.kubeClient)\n\tif err != nil {\n\t\tklog.V(5).Infof(\"Error setting PVC %s in progress with error : %v\", util.GetPersistentVolumeClaimQualifiedName(pvc), err)"
  },
  {
    "id" : "4a277521-81b1-4631-a7dc-1a1911e613d0",
    "prId" : 77883,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/77883#pullrequestreview-238500027",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4a82e593-5d9a-4085-8328-caa441dce288",
        "parentId" : null,
        "authorId" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "body" : "The main reason why we still use operation generator is for the metrics?",
        "createdAt" : "2019-05-15T22:45:28Z",
        "updatedAt" : "2019-05-17T01:35:09Z",
        "lastEditedBy" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "tags" : [
        ]
      },
      {
        "id" : "17bb0fb8-521a-46de-8cbc-609e9ed8e1c8",
        "parentId" : "4a82e593-5d9a-4085-8328-caa441dce288",
        "authorId" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "body" : "main reason is metrics yes. But if we take the code out from operation_generator, we also have to give up on error utils etc embedded inside operation_generator (and they are nice to have!).\r\n\r\nI think having a general purpose `Run` function on `GeneratedOperations` is a small price. ",
        "createdAt" : "2019-05-16T16:18:28Z",
        "updatedAt" : "2019-05-17T01:35:09Z",
        "lastEditedBy" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "tags" : [
        ]
      }
    ],
    "commit" : "4886e8782c82e1484b04b9d14bb589548ebca83e",
    "line" : 242,
    "diffHunk" : "@@ -1,1 +232,236 @@\t}\n\n\tgeneratedOperations, err := expc.operationGenerator.GenerateExpandVolumeFunc(pvc, pv)\n\tif err != nil {\n\t\tklog.Errorf(\"Error starting ExpandVolume for pvc %s with %v\", util.GetPersistentVolumeClaimQualifiedName(pvc), err)"
  },
  {
    "id" : "8bd2eb80-93f2-4f15-91d1-6533c4c4440d",
    "prId" : 77883,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/77883#pullrequestreview-238913225",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e01896a7-1857-4578-aec9-958ca8db6c83",
        "parentId" : null,
        "authorId" : "42b1e004-4fa7-4e43-84cf-5378839b49ad",
        "body" : "It seems this (including the check on line 133) should be done before obtaining oldSize.",
        "createdAt" : "2019-05-17T13:05:37Z",
        "updatedAt" : "2019-05-17T13:26:26Z",
        "lastEditedBy" : "42b1e004-4fa7-4e43-84cf-5378839b49ad",
        "tags" : [
        ]
      }
    ],
    "commit" : "4886e8782c82e1484b04b9d14bb589548ebca83e",
    "line" : 105,
    "diffHunk" : "@@ -1,1 +130,134 @@\n\t\t\toldSize := oldPVC.Spec.Resources.Requests[v1.ResourceStorage]\n\t\t\tnewPVC, ok := new.(*v1.PersistentVolumeClaim)\n\t\t\tif !ok {\n\t\t\t\treturn"
  },
  {
    "id" : "92fe9cdf-04d7-4ba2-87d2-b46928c00de8",
    "prId" : 77883,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/77883#pullrequestreview-238913225",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c3561d56-fcc9-4e7a-823a-cd4c79d83ebe",
        "parentId" : null,
        "authorId" : "42b1e004-4fa7-4e43-84cf-5378839b49ad",
        "body" : "Maybe add a log saying why the request is ignored.",
        "createdAt" : "2019-05-17T13:06:14Z",
        "updatedAt" : "2019-05-17T13:26:26Z",
        "lastEditedBy" : "42b1e004-4fa7-4e43-84cf-5378839b49ad",
        "tags" : [
        ]
      }
    ],
    "commit" : "4886e8782c82e1484b04b9d14bb589548ebca83e",
    "line" : 112,
    "diffHunk" : "@@ -1,1 +137,141 @@\t\t\tif newSize.Cmp(oldSize) > 0 {\n\t\t\t\texpc.enqueuePVC(new)\n\t\t\t}\n\t\t},\n\t\tDeleteFunc: expc.enqueuePVC,"
  },
  {
    "id" : "98d10ae3-7b0d-48ce-b378-d57934b534b1",
    "prId" : 62005,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/62005#pullrequestreview-120366408",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "504ba300-e7f5-40ce-8479-06b610553ccf",
        "parentId" : null,
        "authorId" : "e81e699e-eb6c-4380-bfd5-16ab81ac51d6",
        "body" : "I feel like there should be some common RPC interface implementation where all methods are unimplemented and then you override the ones you need.",
        "createdAt" : "2018-05-15T18:50:38Z",
        "updatedAt" : "2018-06-05T00:22:45Z",
        "lastEditedBy" : "e81e699e-eb6c-4380-bfd5-16ab81ac51d6",
        "tags" : [
        ]
      }
    ],
    "commit" : "91feb345aa021fd69161a6635f5d6fcf50af8680",
    "line" : 12,
    "diffHunk" : "@@ -1,1 +297,301 @@}\n\nfunc (expc *expandController) GetServiceAccountTokenFunc() func(_, _ string, _ *authenticationv1.TokenRequest) (*authenticationv1.TokenRequest, error) {\n\treturn func(_, _ string, _ *authenticationv1.TokenRequest) (*authenticationv1.TokenRequest, error) {\n\t\treturn nil, fmt.Errorf(\"GetServiceAccountToken unsupported in expandController\")"
  },
  {
    "id" : "0fc481cf-2ba8-440b-8db1-30f658abfad0",
    "prId" : 49727,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/49727#pullrequestreview-59998113",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b8dec00e-1f21-4f43-a940-ac58e065959d",
        "parentId" : null,
        "authorId" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "body" : "Watching PVC update is not enough. You need to react to PVCs that were modified when the controller was down. I.e. AddFunc + check that PVC.Spec.Capacity > PVC.Status.Capacity and then check the bound PV.Spec.Capacity.",
        "createdAt" : "2017-08-28T13:02:52Z",
        "updatedAt" : "2017-09-04T07:08:19Z",
        "lastEditedBy" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "tags" : [
        ]
      },
      {
        "id" : "21d7b774-9b14-4f64-8264-7d96be3a3fc8",
        "parentId" : "b8dec00e-1f21-4f43-a940-ac58e065959d",
        "authorId" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "body" : "Reaction to Delete event might be useful too, as `resizeMap` should be updated when user deletes the PVC and thus is not interested in its resize.",
        "createdAt" : "2017-08-28T13:03:39Z",
        "updatedAt" : "2017-09-04T07:08:19Z",
        "lastEditedBy" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "tags" : [
        ]
      },
      {
        "id" : "d6c6f4e2-3299-4426-b2ca-0e9f70d058cf",
        "parentId" : "b8dec00e-1f21-4f43-a940-ac58e065959d",
        "authorId" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "body" : "We will add a separate populator loop to handle pvc updates while controller was down (not in this PR)",
        "createdAt" : "2017-08-28T20:35:24Z",
        "updatedAt" : "2017-09-04T07:08:19Z",
        "lastEditedBy" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "tags" : [
        ]
      },
      {
        "id" : "390bd092-233c-47cc-b530-b059d5d34366",
        "parentId" : "b8dec00e-1f21-4f43-a940-ac58e065959d",
        "authorId" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "body" : "I still miss reaction to Added events. When the controller is down when user resizes a PVC, all you get is a PVC Added event with different pvc.status.capacity and spec.capacity. You need to react to this.\r\n\r\nWhich brings me back to periodical reconcilation of all PVCs and just checking their pvc.status.capacity vs. pvc.spec.capacity. You don't need caches / queues and it's bulletproff to missed events (e.g. when the controller is down).",
        "createdAt" : "2017-08-29T16:00:19Z",
        "updatedAt" : "2017-09-04T07:08:19Z",
        "lastEditedBy" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "tags" : [
        ]
      },
      {
        "id" : "9534c8e3-b2cb-4459-a630-5bfc7648a0f7",
        "parentId" : "b8dec00e-1f21-4f43-a940-ac58e065959d",
        "authorId" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "body" : "Are you saying, we should replace event based handling of PVCs with periodic reconcilation of all PVCs? so basically - replace current event based design with one based on poll. Will that be *only* way of handling resizes or we still watch for events?",
        "createdAt" : "2017-08-29T16:05:22Z",
        "updatedAt" : "2017-09-04T07:08:19Z",
        "lastEditedBy" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "tags" : [
        ]
      },
      {
        "id" : "56073ab7-c2c8-4fc5-97cb-d63a600e0d07",
        "parentId" : "b8dec00e-1f21-4f43-a940-ac58e065959d",
        "authorId" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "body" : "I am not opposed to periodic reconcilation of all PVCs via polling with some sort of populator loop. I will add that in a follow up PR. It is mentioned in design doc too. Such a populator loop will run less frequently though, to avoid causing high cpu usage. \r\n\r\n@jsafrane you seem to be implying that, if we used periodic polling of all PVCs as *only* way of finding out PVCs which needed resizing then we won't need to cache/queue the PVCs.  While that is correct, in a large cluster with 10K PVCs or more, we will causing quite a bit of CPU usage. On other hand -  if we keep polling interval too long, then there could be significant delay in time user submits resize request and when resize requests get processed.\r\n\r\n",
        "createdAt" : "2017-08-29T16:23:03Z",
        "updatedAt" : "2017-09-04T07:08:19Z",
        "lastEditedBy" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "tags" : [
        ]
      },
      {
        "id" : "f42529a9-0b0e-454a-a83d-508b08d1695b",
        "parentId" : "b8dec00e-1f21-4f43-a940-ac58e065959d",
        "authorId" : "241ab19e-f85a-4d22-92e2-88f2b6287d14",
        "body" : "I think he means two things:\r\n- we need `AddFunc` to handle Add events, not just `UpdateFunc`\r\n- we should do periodic reconciliation of *all* PVCs to handle missed events. there is no need for a complicated cache in this case: AddFunc + UpdateFunc + periodic reconciliation will take care of everything. i.e. instead of having AddFunc/UpdateFunc add to a cache which is then acted upon (like right now*), simply act as soon as AddFunc/UpdateFunc occurs (then no cache is needed*)",
        "createdAt" : "2017-08-29T16:23:34Z",
        "updatedAt" : "2017-09-04T07:08:19Z",
        "lastEditedBy" : "241ab19e-f85a-4d22-92e2-88f2b6287d14",
        "tags" : [
        ]
      },
      {
        "id" : "7a5e5bb6-0729-4497-bf18-5e171fc7b945",
        "parentId" : "b8dec00e-1f21-4f43-a940-ac58e065959d",
        "authorId" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "body" : "Added a separate pvc_populator loop to handle case of missed events because of controller crash.",
        "createdAt" : "2017-08-31T21:37:57Z",
        "updatedAt" : "2017-09-04T07:08:19Z",
        "lastEditedBy" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "tags" : [
        ]
      }
    ],
    "commit" : "84029c2c1a798bab26781c0219186b278ad69af7",
    "line" : 130,
    "diffHunk" : "@@ -1,1 +128,132 @@\n\tpvcInformer.Informer().AddEventHandler(kcache.ResourceEventHandlerFuncs{\n\t\tUpdateFunc: expc.pvcUpdate,\n\t\tDeleteFunc: expc.deletePVC,\n\t})"
  },
  {
    "id" : "c5741a13-7282-4974-ade4-d3148d882fc2",
    "prId" : 49727,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/49727#pullrequestreview-59227886",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f9ff5b43-ccd4-4ea8-83d6-441065e7d86c",
        "parentId" : null,
        "authorId" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "body" : "I thought that OperationExecutor is attach/detach specific. It may be not, but is it worth using here? Won't simple GoRoutineMap do the same job?",
        "createdAt" : "2017-08-28T13:26:25Z",
        "updatedAt" : "2017-09-04T07:08:19Z",
        "lastEditedBy" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "tags" : [
        ]
      },
      {
        "id" : "2be5d4e8-afbe-443a-935f-7b41248608bf",
        "parentId" : "f9ff5b43-ccd4-4ea8-83d6-441065e7d86c",
        "authorId" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "body" : "As discussed one of the other benefits of using common operation executor is, we get recently introduced volume metrics for free. Using operation executor might be more desirable in that sense.",
        "createdAt" : "2017-08-28T16:14:39Z",
        "updatedAt" : "2017-09-04T07:08:19Z",
        "lastEditedBy" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "tags" : [
        ]
      },
      {
        "id" : "ef387a07-df32-48cd-b276-ed3dee39c25a",
        "parentId" : "f9ff5b43-ccd4-4ea8-83d6-441065e7d86c",
        "authorId" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "body" : "ok",
        "createdAt" : "2017-08-29T12:47:55Z",
        "updatedAt" : "2017-09-04T07:08:19Z",
        "lastEditedBy" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "tags" : [
        ]
      }
    ],
    "commit" : "84029c2c1a798bab26781c0219186b278ad69af7",
    "line" : 90,
    "diffHunk" : "@@ -1,1 +88,92 @@\n\t// Operation executor\n\topExecutor operationexecutor.OperationExecutor\n\n\t// populator for periodically polling all PVCs"
  }
]
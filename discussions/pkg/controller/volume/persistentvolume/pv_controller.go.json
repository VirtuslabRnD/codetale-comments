[
  {
    "id" : "cf90a3c0-856a-4941-8157-3ff3daeecfbe",
    "prId" : 99326,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/99326#pullrequestreview-605895586",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3e6e9376-5f38-4693-ba78-c8bda115a8a3",
        "parentId" : null,
        "authorId" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "body" : "I wonder if we can't parse here, we should simply revert to `volume.Spec.Capacity` rather than failing here. ",
        "createdAt" : "2021-03-05T20:34:33Z",
        "updatedAt" : "2021-03-09T07:56:27Z",
        "lastEditedBy" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "tags" : [
        ]
      },
      {
        "id" : "87fe2a05-3571-47fb-afda-e01f57b998d5",
        "parentId" : "3e6e9376-5f38-4693-ba78-c8bda115a8a3",
        "authorId" : "c4121125-5aca-4c2b-a2a2-5aabaa95ec29",
        "body" : "Sounds good.",
        "createdAt" : "2021-03-07T23:06:57Z",
        "updatedAt" : "2021-03-09T07:56:27Z",
        "lastEditedBy" : "c4121125-5aca-4c2b-a2a2-5aabaa95ec29",
        "tags" : [
        ]
      }
    ],
    "commit" : "5f69cf74d836ef08c3a340b7d0b48c4a463a3258",
    "line" : 16,
    "diffHunk" : "@@ -1,1 +788,792 @@\t\t\tif metav1.HasAnnotation(volume.ObjectMeta, util.AnnPreResizeCapacity) {\n\t\t\t\tklog.V(2).Infof(\"volume %q requires filesystem resize: setting pvc %s status capacity to %s\", volume.Name, claimToClaimKey(claim), volume.ObjectMeta.Annotations[util.AnnPreResizeCapacity])\n\t\t\t\tpreQty, err := resource.ParseQuantity(volume.ObjectMeta.Annotations[util.AnnPreResizeCapacity])\n\t\t\t\tif err != nil {\n\t\t\t\t\tklog.Warningf(\"Parsing pre-resize-capacity from PV(%q) failed\", volume.Name, err)"
  },
  {
    "id" : "1fda2ccd-ecce-4b93-925a-1b4d40d0dd75",
    "prId" : 99050,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/99050#pullrequestreview-591807212",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6660c9e0-74f5-4243-af1b-aa1fe3bad7a4",
        "parentId" : null,
        "authorId" : "34f61776-88da-4b26-aa20-3c4f92530d05",
        "body" : "Should the migrated field be part of provision and delete calls as well?",
        "createdAt" : "2021-02-17T02:45:36Z",
        "updatedAt" : "2021-02-17T02:50:12Z",
        "lastEditedBy" : "34f61776-88da-4b26-aa20-3c4f92530d05",
        "tags" : [
        ]
      },
      {
        "id" : "85223fc8-4761-46d0-be38-0770c2553359",
        "parentId" : "6660c9e0-74f5-4243-af1b-aa1fe3bad7a4",
        "authorId" : "d10fef96-5a18-44e7-b23e-735de7561af7",
        "body" : "For CSI Migration, if a plugin has been migrated, then provision and delete will be handle by csi-provisioner. So any call happens here is a non-csi migration call",
        "createdAt" : "2021-02-17T03:19:18Z",
        "updatedAt" : "2021-02-17T03:19:18Z",
        "lastEditedBy" : "d10fef96-5a18-44e7-b23e-735de7561af7",
        "tags" : [
        ]
      }
    ],
    "commit" : "9ec820a91af7e0857d7b613855eb64588cf7885d",
    "line" : 22,
    "diffHunk" : "@@ -1,1 +1560,1564 @@\topComplete := util.OperationCompleteHook(plugin.GetPluginName(), \"volume_provision\")\n\tvolume, err = provisioner.Provision(selectedNode, allowedTopologies)\n\topComplete(volumetypes.CompleteFuncParam{Err: &err})\n\tif err != nil {\n\t\t// Other places of failure have nothing to do with VolumeScheduling,"
  },
  {
    "id" : "0934b399-d001-45bd-9a80-fcb5dba52976",
    "prId" : 97086,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/97086#pullrequestreview-596488745",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9feeb00d-1f05-46ce-ae4d-072f723c2f26",
        "parentId" : null,
        "authorId" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "body" : "Can you please add an unit test somewhere in provision_test.go? Check e.g. how is `claimWithAnnotation()` used there and create `claimWithVolumeSource()` based on it. The rest should be trivial.",
        "createdAt" : "2021-02-10T18:27:53Z",
        "updatedAt" : "2021-02-25T15:28:02Z",
        "lastEditedBy" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "tags" : [
        ]
      },
      {
        "id" : "ba177e94-df84-4a0f-a447-56d1ad1e05c1",
        "parentId" : "9feeb00d-1f05-46ce-ae4d-072f723c2f26",
        "authorId" : "275dd783-53c3-4fed-8434-96ed6a2e0331",
        "body" : "Done.",
        "createdAt" : "2021-02-23T15:49:03Z",
        "updatedAt" : "2021-02-25T15:28:02Z",
        "lastEditedBy" : "275dd783-53c3-4fed-8434-96ed6a2e0331",
        "tags" : [
        ]
      }
    ],
    "commit" : "676a3a70129f06239994403770f19b94a7f77f12",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +1475,1479 @@\t// NOTE: checks on plugin/storageClass has been saved\n\tpluginName := plugin.GetPluginName()\n\tif pluginName != \"kubernetes.io/csi\" && claim.Spec.DataSource != nil {\n\t\t// Only CSI plugin can have a DataSource. Fail the operation\n\t\t// if Datasource in Claim is not nil and it is not a CSI plugin,"
  },
  {
    "id" : "d4ee7a1d-e826-42d3-82f3-626da4e515e9",
    "prId" : 89845,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/89845#pullrequestreview-391662403",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "627e28d2-70b7-4833-ab6b-924c365c6e60",
        "parentId" : null,
        "authorId" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "body" : "This is currently normal behavior a volume in \"Released\" phase. I don't think we need to post an event for this.\r\n\r\nRegarding your question, we intentionally do not unbind the volume here. The idea behind Retain is that an administrator may want to clean up the disk before making it available to users again. So once an administrator has confirmed that the disk is ready to be reused, then they can explicitly clear the ClaimRef, which will make it \"Available\" again.",
        "createdAt" : "2020-04-10T21:06:37Z",
        "updatedAt" : "2020-04-17T05:11:21Z",
        "lastEditedBy" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "tags" : [
        ]
      }
    ],
    "commit" : "5a4f1be19d5022060aa38b77d9eace021f304269",
    "line" : 29,
    "diffHunk" : "@@ -1,1 +615,619 @@\t\t\t\treturn err\n\t\t\t}\n\t\t\tif volume.Spec.PersistentVolumeReclaimPolicy == v1.PersistentVolumeReclaimRetain {\n\t\t\t\t// volume is being retained, it references a claim that does not exist now.\n\t\t\t\tklog.V(4).Infof(\"PersistentVolume[%s] references a claim %q (%s) that is not found\", volume.Name, claimrefToClaimKey(volume.Spec.ClaimRef), volume.Spec.ClaimRef.UID)"
  },
  {
    "id" : "d8dbb73d-72eb-4039-ae6f-ff769294a680",
    "prId" : 89845,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/89845#pullrequestreview-395916221",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2f26f186-dedb-4622-94b0-108fbb02bb7b",
        "parentId" : null,
        "authorId" : "42b1e004-4fa7-4e43-84cf-5378839b49ad",
        "body" : "It seems the two calls to ctrl.eventRecorder.Event added by this PR have the same arguments.\r\n\r\nNote the comment on line 426.\r\nHow about changing the message as in the following ?\r\n```\r\n                                        claimMsg := fmt.Sprintf(\"should not have happened: volume %q already bound to a different claim.\", volume.Name)\r\n```\r\nThis would allow users to distinguish the two events added.",
        "createdAt" : "2020-04-18T13:59:27Z",
        "updatedAt" : "2020-04-18T13:59:47Z",
        "lastEditedBy" : "42b1e004-4fa7-4e43-84cf-5378839b49ad",
        "tags" : [
        ]
      }
    ],
    "commit" : "5a4f1be19d5022060aa38b77d9eace021f304269",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +427,431 @@\t\t\t\t\t// AnnBindCompleted annotation on the claim.\n\t\t\t\t\tklog.V(4).Infof(\"synchronizing unbound PersistentVolumeClaim[%s]: volume already bound to different claim %q by controller, THIS SHOULD NEVER HAPPEN\", claimToClaimKey(claim), claimrefToClaimKey(volume.Spec.ClaimRef))\n\t\t\t\t\tclaimMsg := fmt.Sprintf(\"volume %q already bound to a different claim.\", volume.Name)\n\t\t\t\t\tctrl.eventRecorder.Event(claim, v1.EventTypeWarning, events.FailedBinding, claimMsg)\n"
  },
  {
    "id" : "eb0b99c7-13ed-4cb6-8f97-8f74f29ec8ca",
    "prId" : 87098,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/87098#pullrequestreview-349057224",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9cabdcc9-26b0-4e41-98b8-a0e665a61718",
        "parentId" : null,
        "authorId" : "5f2c1de8-4266-42c0-b343-ba247af3578f",
        "body" : "This does mean that worst case scenario puts us in a tight loop hitting this condition and never updates PV or PVC objects.",
        "createdAt" : "2020-01-24T01:58:44Z",
        "updatedAt" : "2020-01-28T00:15:26Z",
        "lastEditedBy" : "5f2c1de8-4266-42c0-b343-ba247af3578f",
        "tags" : [
        ]
      },
      {
        "id" : "b705738b-b9a2-49bb-80f9-4979b388fc8a",
        "parentId" : "9cabdcc9-26b0-4e41-98b8-a0e665a61718",
        "authorId" : "542e5d2f-2ff9-4674-ab44-78f31768e7a1",
        "body" : "this is the same behavior as any other PV/PVC update failure - see call sites of things like `updateClaimStatus`, `bind`,  `updateVolumePhase`, etc. This update is of similar importance going forward - without an annotation there is no migration - if migration is the default there is no storage without the annotation.",
        "createdAt" : "2020-01-27T22:10:00Z",
        "updatedAt" : "2020-01-28T00:15:26Z",
        "lastEditedBy" : "542e5d2f-2ff9-4674-ab44-78f31768e7a1",
        "tags" : [
        ]
      },
      {
        "id" : "584d49e0-0380-4688-a29e-bd5409d7f9ff",
        "parentId" : "9cabdcc9-26b0-4e41-98b8-a0e665a61718",
        "authorId" : "5f2c1de8-4266-42c0-b343-ba247af3578f",
        "body" : ":+1: ",
        "createdAt" : "2020-01-27T23:58:06Z",
        "updatedAt" : "2020-01-28T00:15:26Z",
        "lastEditedBy" : "5f2c1de8-4266-42c0-b343-ba247af3578f",
        "tags" : [
        ]
      }
    ],
    "commit" : "b7817a2981e3a76fa5573fc66d8643f02c14d1d7",
    "line" : 9,
    "diffHunk" : "@@ -1,1 +250,254 @@\tif err != nil {\n\t\t// Nothing was saved; we will fall back into the same\n\t\t// condition in the next call to this method\n\t\treturn err\n\t}"
  },
  {
    "id" : "fa475589-cf38-42b8-9a87-643103f08edc",
    "prId" : 78061,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/78061#pullrequestreview-242934906",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f183b22e-4085-4c8e-bbf5-aec3ca70ca26",
        "parentId" : null,
        "authorId" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "body" : "@davidz627 is the provision name going to be correct for the migration case?  we can address this separately if needed",
        "createdAt" : "2019-05-22T09:25:49Z",
        "updatedAt" : "2019-05-30T17:19:54Z",
        "lastEditedBy" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "tags" : [
        ]
      },
      {
        "id" : "8af4aba4-13a4-4f02-ab0f-3670ca6ab48b",
        "parentId" : "f183b22e-4085-4c8e-bbf5-aec3ca70ca26",
        "authorId" : "542e5d2f-2ff9-4674-ab44-78f31768e7a1",
        "body" : "@ddebroy could you take a look",
        "createdAt" : "2019-05-28T18:21:28Z",
        "updatedAt" : "2019-05-30T17:19:54Z",
        "lastEditedBy" : "542e5d2f-2ff9-4674-ab44-78f31768e7a1",
        "tags" : [
        ]
      },
      {
        "id" : "1174ac5d-cab8-4115-947a-4e92bd0bc0ae",
        "parentId" : "f183b22e-4085-4c8e-bbf5-aec3ca70ca26",
        "authorId" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "body" : "provisioner name looks correct if migration is enabled. I do not see a problem here.",
        "createdAt" : "2019-05-28T20:48:57Z",
        "updatedAt" : "2019-05-30T17:19:54Z",
        "lastEditedBy" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "tags" : [
        ]
      },
      {
        "id" : "d7359d30-91c8-4de1-adf0-70f4dc0dff20",
        "parentId" : "f183b22e-4085-4c8e-bbf5-aec3ca70ca26",
        "authorId" : "542e5d2f-2ff9-4674-ab44-78f31768e7a1",
        "body" : "looks like `getProvisionerName` currently accounts for migration; however, `getProvisionerNameFromVolume` does not.",
        "createdAt" : "2019-05-28T21:36:25Z",
        "updatedAt" : "2019-05-30T17:19:54Z",
        "lastEditedBy" : "542e5d2f-2ff9-4674-ab44-78f31768e7a1",
        "tags" : [
        ]
      }
    ],
    "commit" : "38a884aa047891f272f35e607080ed5034433219",
    "line" : 104,
    "diffHunk" : "@@ -1,1 +1359,1363 @@\t\t// key = claimKey, pluginName = provisionerName, operation = \"provision\"\n\t\tclaimKey := claimToClaimKey(claim)\n\t\tctrl.operationTimestamps.AddIfNotExist(claimKey, ctrl.getProvisionerName(plugin, storageClass), \"provision\")\n\t\tvar err error\n\t\tif plugin == nil || plugin.IsMigratedToCSI() {"
  },
  {
    "id" : "fd2d44dd-eb69-49fd-8c65-ac1c38930d04",
    "prId" : 78061,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/78061#pullrequestreview-242940903",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e4a0e038-7788-4cd3-996e-517b2cbf5bdf",
        "parentId" : null,
        "authorId" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "body" : "We aren't handling translated names correctly for delete operation - are we? it seems that, we should apply same logic we apply for provisioning operation. cc @davidz627 ",
        "createdAt" : "2019-05-28T21:10:39Z",
        "updatedAt" : "2019-05-30T17:19:54Z",
        "lastEditedBy" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "tags" : [
        ]
      },
      {
        "id" : "0fb65c3e-a0bd-4da0-a64e-856406194654",
        "parentId" : "e4a0e038-7788-4cd3-996e-517b2cbf5bdf",
        "authorId" : "87d7d25e-5586-44fd-93fa-024da6e91035",
        "body" : "the provisioner name for deletion is currently obtained from storage class's \"provisioner\" field. For provisioning, from my observation via e2e test, the same field is used for as the annotation \"storage-provisioner\" value for a PVC, as well as the annotation \"provisioned-by\" value of a PV.",
        "createdAt" : "2019-05-28T21:30:57Z",
        "updatedAt" : "2019-05-30T17:19:54Z",
        "lastEditedBy" : "87d7d25e-5586-44fd-93fa-024da6e91035",
        "tags" : [
        ]
      },
      {
        "id" : "023f5ea4-13bf-4b8f-aae5-aac0701f3057",
        "parentId" : "e4a0e038-7788-4cd3-996e-517b2cbf5bdf",
        "authorId" : "542e5d2f-2ff9-4674-ab44-78f31768e7a1",
        "body" : "Looks like `ctrl.getProvisionerName` does a translation if the volume is migrated, but `getProvisionerNameFromVolume` does not, they both should. Alternatively, could we just use: the `\"pv.kubernetes.io/provisioned-by\"` annotation which will be set correctly by migration path, instead of `GET`-ing the storage class inside these helper functions.",
        "createdAt" : "2019-05-28T21:35:49Z",
        "updatedAt" : "2019-05-30T17:19:54Z",
        "lastEditedBy" : "542e5d2f-2ff9-4674-ab44-78f31768e7a1",
        "tags" : [
        ]
      },
      {
        "id" : "c2ada871-2987-40de-ad2c-06ef377b0b1c",
        "parentId" : "e4a0e038-7788-4cd3-996e-517b2cbf5bdf",
        "authorId" : "87d7d25e-5586-44fd-93fa-024da6e91035",
        "body" : "@davidz627 for PV, is annotation \"volume.beta.kubernetes.io/storage-provisioner\" reliable enough as the annotation \"pv.kubernetes.io/provisioned-by\" for PV?",
        "createdAt" : "2019-05-28T21:51:29Z",
        "updatedAt" : "2019-05-30T17:19:54Z",
        "lastEditedBy" : "87d7d25e-5586-44fd-93fa-024da6e91035",
        "tags" : [
        ]
      }
    ],
    "commit" : "38a884aa047891f272f35e607080ed5034433219",
    "line" : 68,
    "diffHunk" : "@@ -1,1 +1044,1048 @@\t\t// create a start timestamp entry in cache for deletion operation if no one exists with\n\t\t// key = volume.Name, pluginName = provisionerName, operation = \"delete\"\n\t\tctrl.operationTimestamps.AddIfNotExist(volume.Name, ctrl.getProvisionerNameFromVolume(volume), \"delete\")\n\t\tctrl.scheduleOperation(opName, func() error {\n\t\t\t_, err := ctrl.deleteVolumeOperation(volume)"
  },
  {
    "id" : "f7feea78-a797-481f-b50f-ac4c1283607f",
    "prId" : 78061,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/78061#pullrequestreview-243514039",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8dd2edda-bbc7-4535-b51b-cd97296a65de",
        "parentId" : null,
        "authorId" : "542e5d2f-2ff9-4674-ab44-78f31768e7a1",
        "body" : "this needs to have migration specific logic to return the correct provisioner name. Is there any reason why we're not using \"pv.kubernetes.io/provisioned-by\" annotation on the PV?",
        "createdAt" : "2019-05-28T21:36:44Z",
        "updatedAt" : "2019-05-30T17:19:54Z",
        "lastEditedBy" : "542e5d2f-2ff9-4674-ab44-78f31768e7a1",
        "tags" : [
        ]
      },
      {
        "id" : "455548dd-9636-4f33-94c4-81c9a8cdc9b0",
        "parentId" : "8dd2edda-bbc7-4535-b51b-cd97296a65de",
        "authorId" : "87d7d25e-5586-44fd-93fa-024da6e91035",
        "body" : "thanks for clarifying. there was concern about \"provisioned-by\" could not be reliably used though my test seems showing that annotation is actually getting updated correctly by external provisioners. I am happy to switch to use \"provisioned-by\" annotation if its reliable. Does it also cover the in-tree case?",
        "createdAt" : "2019-05-28T21:44:51Z",
        "updatedAt" : "2019-05-30T17:19:54Z",
        "lastEditedBy" : "87d7d25e-5586-44fd-93fa-024da6e91035",
        "tags" : [
        ]
      },
      {
        "id" : "7e1bb469-8a8b-4fda-b2b8-a9df34be2a7a",
        "parentId" : "8dd2edda-bbc7-4535-b51b-cd97296a65de",
        "authorId" : "542e5d2f-2ff9-4674-ab44-78f31768e7a1",
        "body" : "I think the old code used to use `provisioned-by` implicitly through the return value of `findDeletablePlugin`. I can't comment on its reliability for general external provisioners. You're right that maybe it's safer to use the storage class provisioner name, lets just do a translation of that then",
        "createdAt" : "2019-05-28T22:30:21Z",
        "updatedAt" : "2019-05-30T17:19:54Z",
        "lastEditedBy" : "542e5d2f-2ff9-4674-ab44-78f31768e7a1",
        "tags" : [
        ]
      },
      {
        "id" : "1f71988e-1a62-4d08-83b5-ca4f4527a303",
        "parentId" : "8dd2edda-bbc7-4535-b51b-cd97296a65de",
        "authorId" : "87d7d25e-5586-44fd-93fa-024da6e91035",
        "body" : "@davidz627 yes indeed as you commented, the original logic to look for plugin/provisioner for deletion uses the annotation ([check here](https://github.com/kubernetes/kubernetes/blob/master/pkg/controller/volume/persistentvolume/pv_controller.go#L1636)) ONLY if it exists. otherwise, it uses volume spec for finding. That was the major reason why the reliability concern was raised above. I will keep the implementation as its for now then. thnx",
        "createdAt" : "2019-05-28T22:44:57Z",
        "updatedAt" : "2019-05-30T17:19:54Z",
        "lastEditedBy" : "87d7d25e-5586-44fd-93fa-024da6e91035",
        "tags" : [
        ]
      },
      {
        "id" : "f26435d0-0759-44c3-9432-ea715841044c",
        "parentId" : "8dd2edda-bbc7-4535-b51b-cd97296a65de",
        "authorId" : "542e5d2f-2ff9-4674-ab44-78f31768e7a1",
        "body" : "I still think the storage class gotten here is going to be the in-tree one when migration is on. But I see we also dont have the plugin information to check whether this volume has been migrated. Could we use `provisioned-by` and fall back to the storage class provisioner if we can't find the `provisioned-by` annotation. (at least for migration cases this annotation should exist)",
        "createdAt" : "2019-05-29T19:06:36Z",
        "updatedAt" : "2019-05-30T17:19:54Z",
        "lastEditedBy" : "542e5d2f-2ff9-4674-ab44-78f31768e7a1",
        "tags" : [
        ]
      },
      {
        "id" : "06ed2593-e4e7-4078-8b65-0dcadc433725",
        "parentId" : "8dd2edda-bbc7-4535-b51b-cd97296a65de",
        "authorId" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "body" : "I think this has to be fixed correctly. i.e - we should fetch the `DeletablePlugin` from Provisioner name retrieved from storageclass. Check if migration is enabled for the plugin and use CSI name otherwise use provisioner name present in SC. \r\n",
        "createdAt" : "2019-05-29T19:43:22Z",
        "updatedAt" : "2019-05-30T17:19:54Z",
        "lastEditedBy" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "tags" : [
        ]
      },
      {
        "id" : "dee11345-a4a4-4896-bd70-e8ec377d95c8",
        "parentId" : "8dd2edda-bbc7-4535-b51b-cd97296a65de",
        "authorId" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "body" : "@msau42 also clarified that using `provisioned-by` could cause explosion of metric names for local-storage volumes because `provisioned-by` annotation points to node name in that case. ",
        "createdAt" : "2019-05-29T19:45:41Z",
        "updatedAt" : "2019-05-30T17:19:54Z",
        "lastEditedBy" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "tags" : [
        ]
      },
      {
        "id" : "c28b3e12-8596-418e-b4c1-e3d5c85f19ec",
        "parentId" : "8dd2edda-bbc7-4535-b51b-cd97296a65de",
        "authorId" : "87d7d25e-5586-44fd-93fa-024da6e91035",
        "body" : "@gnufied @davidz627 \r\ninstead of using storageclass defined provisioner name, to find the DeletablePlugin (if exists), I am proposing the following for getting the deleter name:\r\nif has dynamic provisioned annotation, check the value of it, for external provisioner, use the value directly as the name, otherwise, use the plugin name to find DeletablePlugin and get the name.\r\nIf not dynamically provisioned, use spec to find plugin, falls back to \"N/A\" if none of the above.\r\nWDYT?",
        "createdAt" : "2019-05-29T20:41:01Z",
        "updatedAt" : "2019-05-30T17:19:54Z",
        "lastEditedBy" : "87d7d25e-5586-44fd-93fa-024da6e91035",
        "tags" : [
        ]
      },
      {
        "id" : "529d5254-09d4-41de-ac41-7712367316a9",
        "parentId" : "8dd2edda-bbc7-4535-b51b-cd97296a65de",
        "authorId" : "87d7d25e-5586-44fd-93fa-024da6e91035",
        "body" : "> @msau42 also clarified that using `provisioned-by` could cause explosion of metric names for local-storage volumes because `provisioned-by` annotation points to node name in that case.\r\n\r\n\"provision-by\" is not used in this case for the concerns listed above",
        "createdAt" : "2019-05-29T20:59:12Z",
        "updatedAt" : "2019-05-30T17:19:54Z",
        "lastEditedBy" : "87d7d25e-5586-44fd-93fa-024da6e91035",
        "tags" : [
        ]
      }
    ],
    "commit" : "38a884aa047891f272f35e607080ed5034433219",
    "line" : 265,
    "diffHunk" : "@@ -1,1 +1754,1758 @@\t\t}\n\t}\n\treturn class.Provisioner\n}\n"
  },
  {
    "id" : "d3a3771a-30d7-4fa0-942f-4b687dd74e74",
    "prId" : 78061,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/78061#pullrequestreview-243921214",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9803e9dd-071b-42fc-951e-2ee3e168878c",
        "parentId" : null,
        "authorId" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "body" : "Can this function be simplified to:\r\n\r\n```golang\r\nfunc (ctrl *PersistentVolumeController) getProvisionerNameFromVolume(volume *v1.PersistentVolume) string {\r\n\tplugin, _ := ctrl.findDeletablePlugin(volume)\r\n\tif plugin == nil {\r\n\t\tstorageClass := v1helper.GetPersistentVolumeClass(volume)\r\n\t\tclass, err := ctrl.classLister.Get(storageClass)\r\n\t\tif err != nil {\r\n\t\t\treturn \"N/A\"\r\n\t\t}\r\n\t\treturn class.Provisioner\r\n\t}\r\n\tif plugin.IsMigratedToCSI() {\r\n\t\t// use the CSI name instead of in-tree name\r\n\t\tprovisionerName, err = ctrl.getCSINameFromIntreeName(class.Provisioner)\r\n\t\tif err != nil {\r\n\t\t\treturn class.Provisioner\r\n\t\t}\r\n\t\treturn provisionerName\r\n\t}\r\n\treturn plugin.GetPluginName()\r\n}\r\n```\r\n",
        "createdAt" : "2019-05-30T14:04:39Z",
        "updatedAt" : "2019-05-30T17:19:54Z",
        "lastEditedBy" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "tags" : [
        ]
      },
      {
        "id" : "d61aa91e-9760-4d5b-ac7a-62c4f9f4c8dd",
        "parentId" : "9803e9dd-071b-42fc-951e-2ee3e168878c",
        "authorId" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "body" : "This is a minor nit though.. I don't mind either version of the function. ",
        "createdAt" : "2019-05-30T14:07:23Z",
        "updatedAt" : "2019-05-30T17:19:54Z",
        "lastEditedBy" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "tags" : [
        ]
      },
      {
        "id" : "19764b3f-8c21-425e-9518-b8a14c7f4efc",
        "parentId" : "9803e9dd-071b-42fc-951e-2ee3e168878c",
        "authorId" : "87d7d25e-5586-44fd-93fa-024da6e91035",
        "body" : "updated to return provisioner when getCSINameFromIntreeName fails",
        "createdAt" : "2019-05-30T17:23:25Z",
        "updatedAt" : "2019-05-30T17:23:25Z",
        "lastEditedBy" : "87d7d25e-5586-44fd-93fa-024da6e91035",
        "tags" : [
        ]
      }
    ],
    "commit" : "38a884aa047891f272f35e607080ed5034433219",
    "line" : 266,
    "diffHunk" : "@@ -1,1 +1755,1759 @@\t}\n\treturn class.Provisioner\n}\n\n// obtain plugin/external provisioner name from plugin and storage class"
  },
  {
    "id" : "7dc26559-7322-4cbe-b971-f1719b6b894d",
    "prId" : 78061,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/78061#pullrequestreview-244864501",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "916b84d3-5611-497e-934d-2f063aa0e268",
        "parentId" : null,
        "authorId" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "body" : "Local PV will end up with \"N/A\" as the plugin since it's not dynamically provisioned and the plugin itself doesn't implement delete.\r\n\r\nShould we let it fall through instead of returning \"N/A\" here?",
        "createdAt" : "2019-06-03T13:04:53Z",
        "updatedAt" : "2019-06-03T13:06:08Z",
        "lastEditedBy" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "tags" : [
        ]
      }
    ],
    "commit" : "38a884aa047891f272f35e607080ed5034433219",
    "line" : 243,
    "diffHunk" : "@@ -1,1 +1732,1736 @@\tplugin, err := ctrl.findDeletablePlugin(volume)\n\tif err != nil {\n\t\treturn \"N/A\"\n\t}\n\tif plugin != nil && !plugin.IsMigratedToCSI() {"
  },
  {
    "id" : "a7f07284-068f-4cfd-88e8-845122104aca",
    "prId" : 73653,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/73653#pullrequestreview-207238671",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d871399b-ae84-47a4-848e-ddd321a4d1db",
        "parentId" : null,
        "authorId" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "body" : "Please add an unit test for this. `\"11-17 - external provisioner\"` could be a good start. You need to inject a volume plugin that's migrated to CSI, some variant of `wrapTestWithPluginCalls` might be sufficient.",
        "createdAt" : "2019-02-05T13:51:13Z",
        "updatedAt" : "2019-02-26T16:40:33Z",
        "lastEditedBy" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "tags" : [
        ]
      },
      {
        "id" : "b904b169-ce5e-4378-a00b-39d102a66720",
        "parentId" : "d871399b-ae84-47a4-848e-ddd321a4d1db",
        "authorId" : "98986d5f-c846-4478-8363-8a016e3d6b89",
        "body" : "Updated PR with `11-21 - external provisioner for CSI migration` testcase to make sure for CSI migration scenarios, provisioning ends up waiting for a claim with annotation `vendor.com/MockCSIPlugin` and event `Normal ExternalProvisioning`.",
        "createdAt" : "2019-02-25T07:09:37Z",
        "updatedAt" : "2019-02-26T16:40:33Z",
        "lastEditedBy" : "98986d5f-c846-4478-8363-8a016e3d6b89",
        "tags" : [
        ]
      }
    ],
    "commit" : "23478f104f6ea26f752f1aae71301b637d2935a5",
    "line" : 40,
    "diffHunk" : "@@ -1,1 +1377,1381 @@\tprovisionerName := storageClass.Provisioner\n\tif plugin != nil {\n\t\tif plugin.IsMigratedToCSI() {\n\t\t\t// pluginName is not set here to align with existing behavior\n\t\t\t// of not setting pluginName for external provisioners (including CSI)"
  },
  {
    "id" : "1886836a-3cf2-4c71-8c56-cd0cf6a55e08",
    "prId" : 73653,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/73653#pullrequestreview-208239785",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4a359432-110f-4fe7-9aec-18ddab0433ac",
        "parentId" : null,
        "authorId" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "body" : "In long term it would be better if CSI translation library provided an interface instead of function calls so its callers can create fake implementations for unit tests. As a separate PR, of course, no need to fix it here.",
        "createdAt" : "2019-02-26T13:03:59Z",
        "updatedAt" : "2019-02-26T16:40:33Z",
        "lastEditedBy" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "tags" : [
        ]
      },
      {
        "id" : "3283ff9e-4989-4146-ab84-672edf768f78",
        "parentId" : "4a359432-110f-4fe7-9aec-18ddab0433ac",
        "authorId" : "98986d5f-c846-4478-8363-8a016e3d6b89",
        "body" : "Agree.",
        "createdAt" : "2019-02-26T16:41:51Z",
        "updatedAt" : "2019-02-26T16:41:51Z",
        "lastEditedBy" : "98986d5f-c846-4478-8363-8a016e3d6b89",
        "tags" : [
        ]
      },
      {
        "id" : "54ec5a6c-c487-49c7-a822-98d8459cbb05",
        "parentId" : "4a359432-110f-4fe7-9aec-18ddab0433ac",
        "authorId" : "542e5d2f-2ff9-4674-ab44-78f31768e7a1",
        "body" : "xref\" https://github.com/kubernetes/kubernetes/issues/74594",
        "createdAt" : "2019-02-26T22:17:19Z",
        "updatedAt" : "2019-02-26T22:17:19Z",
        "lastEditedBy" : "542e5d2f-2ff9-4674-ab44-78f31768e7a1",
        "tags" : [
        ]
      }
    ],
    "commit" : "23478f104f6ea26f752f1aae71301b637d2935a5",
    "line" : 15,
    "diffHunk" : "@@ -1,1 +235,239 @@\t// For testing only: hook to intercept CSI driver name <=> Intree plugin name mapping\n\t// Not used when set to nil\n\tcsiNameFromIntreeNameHook func(pluginName string) (string, error)\n}\n"
  },
  {
    "id" : "ec8f9053-2e83-4f93-b267-c3dc1962f8fc",
    "prId" : 70580,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/70580#pullrequestreview-171107874",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "334d2770-b5ca-4f47-b9e1-d7f0f67231a3",
        "parentId" : null,
        "authorId" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "body" : "Please add some comment why it's ok to recycle the volume when there is a PVC in cache.\r\n\"There is a new PVC with the same name as the deleted one. The new PVC must use a different PV, because we checked that the PV is unused in isVolumeReleased. So the old PV is safe to be recycled.\"",
        "createdAt" : "2018-11-02T13:10:47Z",
        "updatedAt" : "2018-11-15T15:39:18Z",
        "lastEditedBy" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "tags" : [
        ]
      },
      {
        "id" : "9c10d7da-bbe8-430c-87b7-f7c8fc8ca966",
        "parentId" : "334d2770-b5ca-4f47-b9e1-d7f0f67231a3",
        "authorId" : "d0f794d1-a9d4-4c31-aacc-fb35543cf586",
        "body" : "Yessir.",
        "createdAt" : "2018-11-02T13:50:22Z",
        "updatedAt" : "2018-11-15T15:39:18Z",
        "lastEditedBy" : "d0f794d1-a9d4-4c31-aacc-fb35543cf586",
        "tags" : [
        ]
      }
    ],
    "commit" : "f9c9ef6ec000acb1a05e1e6727e57b5f4a6f9ca0",
    "line" : 10,
    "diffHunk" : "@@ -1,1 +1133,1137 @@\t// a different PV -- we checked that the PV is unused in isVolumeReleased.\n\t// So the old PV is safe to be recycled.\n\tclaimName := claimrefToClaimKey(volume.Spec.ClaimRef)\n\t_, claimCached, err := ctrl.claims.GetByKey(claimName)\n\tif err != nil {"
  },
  {
    "id" : "d6285046-7505-4d64-aff2-5211eaa96810",
    "prId" : 67432,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/67432#pullrequestreview-146528201",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fc440812-4021-47f9-9a5a-2444ab7db9c9",
        "parentId" : null,
        "authorId" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "body" : "The annotation needs to move to beta too.  I would actually not prefix the annotation with \"beta\" either, it will make going to GA easier.",
        "createdAt" : "2018-08-15T16:57:40Z",
        "updatedAt" : "2018-08-29T02:30:34Z",
        "lastEditedBy" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "tags" : [
        ]
      }
    ],
    "commit" : "eefd337ba0e89b3c3d74ee57355370ad50f91992",
    "line" : 25,
    "diffHunk" : "@@ -1,1 +295,299 @@\t// provisioning by setting the \"annSelectedNode\" annotation\n\t// in the PVC\n\tif _, ok := claim.Annotations[annSelectedNode]; ok {\n\t\treturn false, nil\n\t}"
  },
  {
    "id" : "14fa68dc-05fc-4094-a1b7-8f046dc96a49",
    "prId" : 66292,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/66292#pullrequestreview-138094896",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "96e2891f-e09d-4106-aeab-e66d4104eb93",
        "parentId" : null,
        "authorId" : "fa530650-5886-4415-a42f-0dee2e0e9ae3",
        "body" : "@vishen :+1: thanks for catching this!",
        "createdAt" : "2018-07-18T03:49:15Z",
        "updatedAt" : "2018-07-18T03:49:15Z",
        "lastEditedBy" : "fa530650-5886-4415-a42f-0dee2e0e9ae3",
        "tags" : [
        ]
      }
    ],
    "commit" : "b4cab1be0ee11ccfa63aa5f6447087852490db7d",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +265,269 @@\trequestedClass := v1helper.GetPersistentVolumeClaimClass(claim)\n\tif v1helper.GetPersistentVolumeClass(volume) != requestedClass {\n\t\treturn fmt.Errorf(\"storageClassName does not match\")\n\t}\n"
  },
  {
    "id" : "9f36b838-261e-4cec-9d7c-c2dc749241cd",
    "prId" : 63232,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/63232#pullrequestreview-118132313",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "308f115b-6806-4e75-91c4-ea80e39fc296",
        "parentId" : null,
        "authorId" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "body" : "TODO at L312 can be removed",
        "createdAt" : "2018-05-07T20:20:24Z",
        "updatedAt" : "2018-05-24T09:13:24Z",
        "lastEditedBy" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "tags" : [
        ]
      }
    ],
    "commit" : "446f36559e933d3eeea666bd2165db21b7bb419e",
    "line" : 24,
    "diffHunk" : "@@ -1,1 +291,295 @@\t\t// provisioning by setting the \"annSelectedNode\" annotation\n\t\t// in the PVC\n\t\tif _, ok := claim.Annotations[annSelectedNode]; ok {\n\t\t\treturn false, nil\n\t\t}"
  },
  {
    "id" : "ac6208de-1de7-46b5-a3ef-fd44e7251c49",
    "prId" : 63232,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/63232#pullrequestreview-118132313",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1882102a-5251-4b6a-a146-e170095fc4b5",
        "parentId" : null,
        "authorId" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "body" : "Add a TODO here to modify the Provision() API to pass in topology info",
        "createdAt" : "2018-05-07T20:28:56Z",
        "updatedAt" : "2018-05-24T09:13:24Z",
        "lastEditedBy" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "tags" : [
        ]
      }
    ],
    "commit" : "446f36559e933d3eeea666bd2165db21b7bb419e",
    "line" : 55,
    "diffHunk" : "@@ -1,1 +1438,1442 @@\t// TODO: modify the Provision() interface to pass in the allowed topology information\n\t// of the provisioned volume.\n\tvolume, err = provisioner.Provision()\n\topComplete(&err)\n\tif err != nil {"
  },
  {
    "id" : "0803ffd8-30df-4ccb-a866-d3e2cca6fc6a",
    "prId" : 55039,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/55039#pullrequestreview-78339071",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0beba612-3d2b-410d-a60e-2576ddd85ce3",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "weird... double import?",
        "createdAt" : "2017-11-22T05:30:06Z",
        "updatedAt" : "2017-11-22T07:20:19Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "79475e27-508b-484a-b7b6-5db6d63d9f43",
        "parentId" : "0beba612-3d2b-410d-a60e-2576ddd85ce3",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "nm, misread because of weird line wrapping ",
        "createdAt" : "2017-11-22T05:30:25Z",
        "updatedAt" : "2017-11-22T07:20:19Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "6540850fa2b710060fa94a22e03ff7c39ba652e6",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +41,45 @@\t\"k8s.io/kubernetes/pkg/features\"\n\t\"k8s.io/kubernetes/pkg/util/goroutinemap\"\n\t\"k8s.io/kubernetes/pkg/util/goroutinemap/exponentialbackoff\"\n\tvol \"k8s.io/kubernetes/pkg/volume\"\n\t\"k8s.io/kubernetes/pkg/volume/util\""
  },
  {
    "id" : "e6b6096a-9f50-4c3a-a57c-26a7ec00b2e9",
    "prId" : 50036,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/50036#pullrequestreview-58162572",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b32e4e4e-ccaf-4dff-a5e4-017ea199dcbb",
        "parentId" : null,
        "authorId" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "body" : "@jsafrane was that an oversight that `provisionClaimOperation` function does not return error, even if provisioning fails for some reason? ",
        "createdAt" : "2017-08-23T15:02:08Z",
        "updatedAt" : "2017-08-23T18:27:55Z",
        "lastEditedBy" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "tags" : [
        ]
      },
      {
        "id" : "63d13a17-2656-4e63-a09e-a5b6e500124f",
        "parentId" : "b32e4e4e-ccaf-4dff-a5e4-017ea199dcbb",
        "authorId" : "241ab19e-f85a-4d22-92e2-88f2b6287d14",
        "body" : "curious too, but regardless of answer we decided to wrap Provision since wrapping provisionClaimOperation would include irrelevant API server delays",
        "createdAt" : "2017-08-23T15:54:27Z",
        "updatedAt" : "2017-08-23T18:27:55Z",
        "lastEditedBy" : "241ab19e-f85a-4d22-92e2-88f2b6287d14",
        "tags" : [
        ]
      },
      {
        "id" : "3485e69f-3cb2-4f3a-bfdf-bfd132d822ef",
        "parentId" : "b32e4e4e-ccaf-4dff-a5e4-017ea199dcbb",
        "authorId" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "body" : "Yeah I think - we can revisit this later, but I do not think it is a problem if API server delays are included in the metric. Similar metrics too include some API server delays as well.  My thinking is - it would have been cleaner to do this in `scheduleOperation` because then we don't need to modify each operation individually. ",
        "createdAt" : "2017-08-23T17:53:24Z",
        "updatedAt" : "2017-08-23T18:27:55Z",
        "lastEditedBy" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "tags" : [
        ]
      }
    ],
    "commit" : "3ed34183d023dbc51f711a2b83e9c1bfdd898552",
    "line" : 24,
    "diffHunk" : "@@ -1,1 +1331,1335 @@\t}\n\n\topComplete := util.OperationCompleteHook(plugin.GetPluginName(), \"volume_provision\")\n\tvolume, err = provisioner.Provision()\n\topComplete(err)"
  },
  {
    "id" : "c3b047ce-1289-4c34-b81e-8eafe3ff9bc3",
    "prId" : 44719,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/44719#pullrequestreview-37971598",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a36d2301-3486-48b7-b865-c67890bd0a5b",
        "parentId" : null,
        "authorId" : "8fc8f958-3c0e-47dd-a0fb-b8cc483b4efb",
        "body" : "Nit: I'm wondering if this would read better if we didn't use the \"inline\" if statement, but rather just handled the 3 cases explicitly",
        "createdAt" : "2017-05-13T04:10:25Z",
        "updatedAt" : "2017-08-29T07:48:40Z",
        "lastEditedBy" : "8fc8f958-3c0e-47dd-a0fb-b8cc483b4efb",
        "tags" : [
        ]
      }
    ],
    "commit" : "195d5c1546f1800217e3bfd441b56cbc3feec05c",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +1366,1370 @@\t\tglog.V(4).Infof(\"provisionClaimOperation [%s]: trying to save volume %s\", claimToClaimKey(claim), volume.Name)\n\t\tvar newVol *v1.PersistentVolume\n\t\tif newVol, err = ctrl.kubeClient.Core().PersistentVolumes().Create(volume); err == nil || apierrs.IsAlreadyExists(err) {\n\t\t\t// Save succeeded.\n\t\t\tif err != nil {"
  },
  {
    "id" : "e3541718-f383-411a-9584-522851f1bb7e",
    "prId" : 44719,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/44719#pullrequestreview-37971598",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e20b1592-9989-4d48-b2ee-a298be80cecd",
        "parentId" : null,
        "authorId" : "8fc8f958-3c0e-47dd-a0fb-b8cc483b4efb",
        "body" : "Review note: the name includes the UID of the PVC, so there is no (real) risk of a naming collision here.  :+1: ",
        "createdAt" : "2017-05-13T04:14:24Z",
        "updatedAt" : "2017-08-29T07:48:40Z",
        "lastEditedBy" : "8fc8f958-3c0e-47dd-a0fb-b8cc483b4efb",
        "tags" : [
        ]
      }
    ],
    "commit" : "195d5c1546f1800217e3bfd441b56cbc3feec05c",
    "line" : 17,
    "diffHunk" : "@@ -1,1 +1369,1373 @@\t\t\t// Save succeeded.\n\t\t\tif err != nil {\n\t\t\t\tglog.V(3).Infof(\"volume %q for claim %q already exists, reusing\", volume.Name, claimToClaimKey(claim))\n\t\t\t\terr = nil\n\t\t\t} else {"
  },
  {
    "id" : "562a6bd6-3bfd-4cc3-9f17-69aea457e4f7",
    "prId" : 42992,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/42992#pullrequestreview-30575927",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2a3ba9ae-54fa-4510-96c2-443e991c1e20",
        "parentId" : null,
        "authorId" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "body" : "You carefully craft a perfect error message in `checkVolumeSatisfyClaim`, which isn't then used anywhere. It would be  nice to log it in V(4) level or make it nicer in `checkVolumeSatisfyClaim` and use it directly as the event message sent to user.\r\n\r\nPerhaps `Can't bind the claim to volume %q, the claim requires storage class %q, while the volume has incompatible class %q`?",
        "createdAt" : "2017-04-03T12:32:38Z",
        "updatedAt" : "2017-04-03T17:07:28Z",
        "lastEditedBy" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "tags" : [
        ]
      },
      {
        "id" : "f1f256b3-2157-400a-b1ea-0e3a662f5348",
        "parentId" : "2a3ba9ae-54fa-4510-96c2-443e991c1e20",
        "authorId" : "cf088828-7f69-4b6e-8956-1842c94daa02",
        "body" : "Done",
        "createdAt" : "2017-04-03T17:08:14Z",
        "updatedAt" : "2017-04-03T17:08:14Z",
        "lastEditedBy" : "cf088828-7f69-4b6e-8956-1842c94daa02",
        "tags" : [
        ]
      }
    ],
    "commit" : "f922af5138f03c47f1ad4a016dc79de4a672ebdd",
    "line" : 31,
    "diffHunk" : "@@ -1,1 +315,319 @@\t\t\t\t// OBSERVATION: pvc is \"Pending\", pv is \"Available\"\n\t\t\t\tglog.V(4).Infof(\"synchronizing unbound PersistentVolumeClaim[%s]: volume is unbound, binding\", claimToClaimKey(claim))\n\t\t\t\tif err = checkVolumeSatisfyClaim(volume, claim); err != nil {\n\t\t\t\t\tglog.V(4).Infof(\"Can't bind the claim to volume %q: %v\", volume.Name, err)\n\t\t\t\t\t//send a event"
  },
  {
    "id" : "993fc3d2-28eb-4ea6-840a-3920c2a9de51",
    "prId" : 38615,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/38615#pullrequestreview-12477090",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ed804771-3682-49f5-b90b-b8679b7f88ed",
        "parentId" : null,
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "Do you want add it in a hot-loop like this or add it with a delay using the rate limited or time limits functions?",
        "createdAt" : "2016-12-12T14:51:30Z",
        "updatedAt" : "2017-01-02T14:18:23Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      },
      {
        "id" : "f8514cd0-5e1b-444d-a429-70c9009493c7",
        "parentId" : "ed804771-3682-49f5-b90b-b8679b7f88ed",
        "authorId" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "body" : "It's not a loop, it pokes a claim processing from code that processes a volume.",
        "createdAt" : "2016-12-12T15:26:56Z",
        "updatedAt" : "2017-01-02T14:18:23Z",
        "lastEditedBy" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "tags" : [
        ]
      }
    ],
    "commit" : "0fd5f2028d3ef9a618725c97920677d4995ee5be",
    "line" : 72,
    "diffHunk" : "@@ -1,1 +495,499 @@\t\t\t// only the new PV and it expects that next syncClaim will bind the\n\t\t\t// claim to it.\n\t\t\tctrl.claimQueue.Add(claimToClaimKey(claim))\n\t\t\treturn nil\n\t\t} else if claim.Spec.VolumeName == volume.Name {"
  }
]
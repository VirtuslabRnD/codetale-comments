[
  {
    "id" : "96fb295d-2875-415a-8531-877a5a8dff3b",
    "prId" : 102344,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/102344#pullrequestreview-690946711",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b9b46f7f-913e-46b7-83b9-acf5bee77c32",
        "parentId" : null,
        "authorId" : "4e418bc8-21fb-4523-80c1-9c751c193126",
        "body" : "What does the TODO mean here? Do we plan to update this function to use the new pod worker?",
        "createdAt" : "2021-06-10T06:37:36Z",
        "updatedAt" : "2021-06-11T07:11:56Z",
        "lastEditedBy" : "4e418bc8-21fb-4523-80c1-9c751c193126",
        "tags" : [
        ]
      },
      {
        "id" : "a16ca12c-9779-4d7d-82c7-e01faa05b573",
        "parentId" : "b9b46f7f-913e-46b7-83b9-acf5bee77c32",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "This is called from controller code so can't access the volume controller.  I was going to file an issue to sig-storage that they may need to ask more state to be returned by kubelet (perhaps a new condition) before they start tearing things down.  Alternatively, they may no longer need this \"optimization\".\r\n\r\nI think the bug right now is that a pod in Succeeded can have 2 containers that haven't started yet reported, then kubelet starts those (so it's not safe to detach), then kubelet catches up and terminates the containers and reports status.  We might actually need a \"Terminal\" condition for Succeeded/Failed pods if so.",
        "createdAt" : "2021-06-11T21:30:51Z",
        "updatedAt" : "2021-06-11T21:30:51Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "9c3b7726-2515-44cf-836c-5a1e2479afed",
        "parentId" : "b9b46f7f-913e-46b7-83b9-acf5bee77c32",
        "authorId" : "4e418bc8-21fb-4523-80c1-9c751c193126",
        "body" : "@jingax10 I remember the issue you mentioned to me is that:\r\n1) Volume manager sees the deletion timestamp and no containers running, so unmount the volume;\r\n2) Pod worker is actually still trying to start new containers;\r\n3) New containers come up with host path mount without the volume.\r\n\r\nDoes 1) happen in kubelet or the controller? If it happens in kubelet, this change should fix the issue. Or else this change will still not be sufficient.",
        "createdAt" : "2021-06-23T17:10:30Z",
        "updatedAt" : "2021-06-23T17:10:31Z",
        "lastEditedBy" : "4e418bc8-21fb-4523-80c1-9c751c193126",
        "tags" : [
        ]
      },
      {
        "id" : "c1ce8370-18a7-4943-8adb-8294f3bb3553",
        "parentId" : "b9b46f7f-913e-46b7-83b9-acf5bee77c32",
        "authorId" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "body" : "cc correct @jingxu97 ",
        "createdAt" : "2021-06-23T17:25:29Z",
        "updatedAt" : "2021-06-23T17:25:29Z",
        "lastEditedBy" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "tags" : [
        ]
      }
    ],
    "commit" : "3eadd1a9ead7a009a9abfbd603a5efd0560473cc",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +382,386 @@// IsPodTerminated checks if pod is terminated\nfunc IsPodTerminated(pod *v1.Pod, podStatus v1.PodStatus) bool {\n\t// TODO: the guarantees provided by kubelet status are not sufficient to guarantee it's safe to ignore a deleted pod,\n\t// even if everything is notRunning (kubelet does not guarantee that when pod status is waiting that it isn't trying\n\t// to start a container)."
  },
  {
    "id" : "6282acd7-e8f2-4812-87e2-9e500aea1bd1",
    "prId" : 102344,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/102344#pullrequestreview-687480728",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "238b7ede-d889-4cb8-8c63-542993ad4f3e",
        "parentId" : null,
        "authorId" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "body" : "does it mean that even if IsPodTerminated() return true, after that, pod might still try to start a container?",
        "createdAt" : "2021-06-17T00:55:06Z",
        "updatedAt" : "2021-06-17T00:55:06Z",
        "lastEditedBy" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "tags" : [
        ]
      },
      {
        "id" : "c3250587-19eb-4a73-997d-9061bf18b413",
        "parentId" : "238b7ede-d889-4cb8-8c63-542993ad4f3e",
        "authorId" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "body" : "talked to @Random-Liu about the logic here and checking the use case of isPodTerminated in this volume util, I think it could satisfy our use case to modify the function here so that if isPodTeminated() return true, there will be no more containers trying to start.",
        "createdAt" : "2021-06-17T15:31:49Z",
        "updatedAt" : "2021-06-17T15:49:58Z",
        "lastEditedBy" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "tags" : [
        ]
      },
      {
        "id" : "058c9de7-c81e-45c0-ac8a-e0c50a558a25",
        "parentId" : "238b7ede-d889-4cb8-8c63-542993ad4f3e",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "> it could satisfy our use case to modify the function here so that if isPodTeminated() return true, there will be no more containers trying to start.\r\n\r\nIt is impossible today for components other than the Kubelet (who read the pod api) to know when the kubelet will no longer restart containers, because the Kubelet does not communicate that via pod status in a way that components can use it.  So if you need that, Kubelet needs a change, or you need to weaken your guarantees.\r\n\r\nWithin the Kubelet, all kubelet sync loops should NOT be using pkg/volume/util (and I have changed code in the kubelet to not use it) and instead use the PodStateProvider style interfaces that the pod worker provides, which *can* guarantee the check.",
        "createdAt" : "2021-06-18T14:37:43Z",
        "updatedAt" : "2021-06-18T14:37:44Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      }
    ],
    "commit" : "3eadd1a9ead7a009a9abfbd603a5efd0560473cc",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +384,388 @@\t// TODO: the guarantees provided by kubelet status are not sufficient to guarantee it's safe to ignore a deleted pod,\n\t// even if everything is notRunning (kubelet does not guarantee that when pod status is waiting that it isn't trying\n\t// to start a container).\n\treturn podStatus.Phase == v1.PodFailed || podStatus.Phase == v1.PodSucceeded || (pod.DeletionTimestamp != nil && notRunning(podStatus.InitContainerStatuses) && notRunning(podStatus.ContainerStatuses) && notRunning(podStatus.EphemeralContainerStatuses))\n}"
  },
  {
    "id" : "15f416d9-f630-4dcd-8b56-47450babe7a4",
    "prId" : 89193,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/89193#pullrequestreview-508678852",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "450a46bb-fdfb-42dd-bcec-ac78894d50b2",
        "parentId" : null,
        "authorId" : "9f030d50-62db-4b00-a28c-847709b74d97",
        "body" : "I think there might be a couple problems with this logic, if I'm reading it correctly:\r\n\r\n1. A container could set the user in the container image. To get the image user, you can use the [`getImageUser(...)`](https://github.com/kubernetes/kubernetes/blob/205d5c58296357365bfa834ecabb384c1c1042c3/pkg/kubelet/kuberuntime/helpers.go#L122) function, but you'd need to plumb through the runtime and export the method. Also note that the username can't be depended on.\r\n2. A root user can only be ignored if it also has CAP_DAC_OVERRIDE (although it's included by default).\r\n\r\nEven with these precautions, it's still possible that the container could drop permissions at runtime, but I think it should be acceptable to just cover that case by documentation (i.e. use FSGroup)",
        "createdAt" : "2020-10-14T19:03:23Z",
        "updatedAt" : "2020-10-14T19:22:54Z",
        "lastEditedBy" : "9f030d50-62db-4b00-a28c-847709b74d97",
        "tags" : [
        ]
      },
      {
        "id" : "af8eb33d-1200-4ea0-b962-7fa0267eeaae",
        "parentId" : "450a46bb-fdfb-42dd-bcec-ac78894d50b2",
        "authorId" : "9f030d50-62db-4b00-a28c-847709b74d97",
        "body" : "Actually, looks like I was misreading the code... I think this says that if the user isn't explicitly specified in all the containers (and the explicit users don't match) then return `nil`. In that case, I think the code is correct but the comment is incorrect (since it doesn't care about non-root).",
        "createdAt" : "2020-10-14T19:31:10Z",
        "updatedAt" : "2020-10-14T19:31:10Z",
        "lastEditedBy" : "9f030d50-62db-4b00-a28c-847709b74d97",
        "tags" : [
        ]
      },
      {
        "id" : "cbfe9359-5dd3-4d32-a05f-377baa961e87",
        "parentId" : "450a46bb-fdfb-42dd-bcec-ac78894d50b2",
        "authorId" : "f64c354b-61cb-4b89-b58f-f464e7ad4f94",
        "body" : "using `getImageUser` would require a lot of changes in kubelet in terms of the image pulling and volume mounts.",
        "createdAt" : "2020-10-14T19:52:45Z",
        "updatedAt" : "2020-10-14T19:52:45Z",
        "lastEditedBy" : "f64c354b-61cb-4b89-b58f-f464e7ad4f94",
        "tags" : [
        ]
      }
    ],
    "commit" : "3db7275b549559696c42c0b5f51c9a2397e9571d",
    "line" : 20,
    "diffHunk" : "@@ -1,1 +618,622 @@\t\trunAsUser, ok := securitycontext.DetermineEffectiveRunAsUser(pod, container)\n\t\t// One container doesn't specify user or there are more than one\n\t\t// non-root UIDs.\n\t\tif !ok || (fsUser != nil && *fsUser != *runAsUser) {\n\t\t\tfsUser = nil"
  },
  {
    "id" : "a7965e65-5303-4833-9ec9-4fc4d39a55f0",
    "prId" : 83591,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/83591#pullrequestreview-300896106",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f53d62e9-97d9-4a0c-adf0-1f62e282774c",
        "parentId" : null,
        "authorId" : "542e5d2f-2ff9-4674-ab44-78f31768e7a1",
        "body" : "this is in a OS agnostic util package. Could you make the function name/comment/implementation more Windows specific?\r\n\r\neither `if runtime.GOOS == windows` do work otherwise just return nil.\r\nor just name it something super Windows specific",
        "createdAt" : "2019-10-08T23:41:04Z",
        "updatedAt" : "2019-10-16T17:12:49Z",
        "lastEditedBy" : "542e5d2f-2ff9-4674-ab44-78f31768e7a1",
        "tags" : [
        ]
      },
      {
        "id" : "4226bcf9-060e-40a7-93cc-ebaedbb8dbbe",
        "parentId" : "f53d62e9-97d9-4a0c-adf0-1f62e282774c",
        "authorId" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "body" : "fixed",
        "createdAt" : "2019-10-11T19:53:57Z",
        "updatedAt" : "2019-10-16T17:12:49Z",
        "lastEditedBy" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "tags" : [
        ]
      }
    ],
    "commit" : "1636b2b452e450cc8bfdeb90e5fd820faa7d9095",
    "line" : 32,
    "diffHunk" : "@@ -1,1 +586,590 @@\n//WriteVolumeCache flush disk data given the spcified mount path\nfunc WriteVolumeCache(deviceMountPath string, exec mount.Exec) error {\n\t// If runtime os is windows, execute Write-VolumeCache powershell command on the disk\n\tif runtime.GOOS == \"windows\" {"
  },
  {
    "id" : "6f98fda8-c386-450e-846f-2091a5eaddc4",
    "prId" : 81163,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/81163#pullrequestreview-275521694",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2658e840-3125-4944-832f-6734e1c34cef",
        "parentId" : null,
        "authorId" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "body" : "This may need to be updated again after https://github.com/kubernetes/kubernetes/pull/59484",
        "createdAt" : "2019-08-15T16:03:42Z",
        "updatedAt" : "2019-08-15T16:03:46Z",
        "lastEditedBy" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "tags" : [
        ]
      }
    ],
    "commit" : "2c79ffe274c3bb5a2dad38cde866425018033e10",
    "line" : 11,
    "diffHunk" : "@@ -1,1 +556,560 @@\tdevices = sets.NewString()\n\n\taddContainerVolumes(pod.Spec.Containers, mounts, devices)\n\taddContainerVolumes(pod.Spec.InitContainers, mounts, devices)\n\treturn"
  },
  {
    "id" : "eb8c3a43-72e6-4591-ad2b-d27f5debac2e",
    "prId" : 78648,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/78648#pullrequestreview-428846307",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6af169b6-a768-4e2d-8a4e-fcf748f2c83c",
        "parentId" : null,
        "authorId" : "d7870cae-47b0-4c8e-8527-be8fc4be86de",
        "body" : "Can we assume that `volume.EmptyDir.Medium != v1.StorageMediumMemory` is equivalent to `volume.EmptyDir.Medium == v1.StorageMediumDefault`?",
        "createdAt" : "2019-06-03T13:32:59Z",
        "updatedAt" : "2021-03-05T05:49:39Z",
        "lastEditedBy" : "d7870cae-47b0-4c8e-8527-be8fc4be86de",
        "tags" : [
        ]
      },
      {
        "id" : "2446fb7f-408d-424f-b9aa-b99228bdd48c",
        "parentId" : "6af169b6-a768-4e2d-8a4e-fcf748f2c83c",
        "authorId" : "e1ba72c9-3be8-432b-b345-ac2d180a8eab",
        "body" : "No, we can't.  `volume.EmptyDir.Medium` is `v1.StorageMediumDefault`, `v1.StorageMediumMemory` or `v1.StorageMediumHugePages`.  I think only `v1.StorageMediumDefault` is local volume, so I think the original code has a bug.",
        "createdAt" : "2019-06-03T14:10:19Z",
        "updatedAt" : "2021-03-05T05:49:39Z",
        "lastEditedBy" : "e1ba72c9-3be8-432b-b345-ac2d180a8eab",
        "tags" : [
        ]
      },
      {
        "id" : "d9a0ae05-cb11-401e-bad4-23786325b91a",
        "parentId" : "6af169b6-a768-4e2d-8a4e-fcf748f2c83c",
        "authorId" : "e1ba72c9-3be8-432b-b345-ac2d180a8eab",
        "body" : "According to [this](https://github.com/kubernetes/kubernetes/pull/55447#issue-151801859), HugePages is not a local ephemeral volume.\r\n",
        "createdAt" : "2019-06-05T07:54:53Z",
        "updatedAt" : "2021-03-05T05:49:39Z",
        "lastEditedBy" : "e1ba72c9-3be8-432b-b345-ac2d180a8eab",
        "tags" : [
        ]
      },
      {
        "id" : "9ee14295-18ac-497d-96d5-eba6e0fb376b",
        "parentId" : "6af169b6-a768-4e2d-8a4e-fcf748f2c83c",
        "authorId" : "e4e7c71f-23b5-4203-b65d-3f5f3c503b64",
        "body" : "why Secret volume is not an ephemeral volume?",
        "createdAt" : "2020-06-11T11:49:23Z",
        "updatedAt" : "2021-03-05T05:49:39Z",
        "lastEditedBy" : "e4e7c71f-23b5-4203-b65d-3f5f3c503b64",
        "tags" : [
        ]
      },
      {
        "id" : "2a9e3da2-15e2-4768-acab-0c5aa27e1e1e",
        "parentId" : "6af169b6-a768-4e2d-8a4e-fcf748f2c83c",
        "authorId" : "e1ba72c9-3be8-432b-b345-ac2d180a8eab",
        "body" : "@cofyc Please refer this.\r\nhttps://github.com/kubernetes/kubernetes/pull/82401#issuecomment-529743428",
        "createdAt" : "2020-06-11T12:06:38Z",
        "updatedAt" : "2021-03-05T05:49:39Z",
        "lastEditedBy" : "e1ba72c9-3be8-432b-b345-ac2d180a8eab",
        "tags" : [
        ]
      },
      {
        "id" : "d45f1347-6a63-4683-b1a2-8433fa702f9c",
        "parentId" : "6af169b6-a768-4e2d-8a4e-fcf748f2c83c",
        "authorId" : "e4e7c71f-23b5-4203-b65d-3f5f3c503b64",
        "body" : "Thanks!",
        "createdAt" : "2020-06-11T12:09:38Z",
        "updatedAt" : "2021-03-05T05:49:39Z",
        "lastEditedBy" : "e4e7c71f-23b5-4203-b65d-3f5f3c503b64",
        "tags" : [
        ]
      }
    ],
    "commit" : "fe7a862c2d14bf6f9aff92f11338ede0d3e1a9a1",
    "line" : 10,
    "diffHunk" : "@@ -1,1 +588,592 @@func IsLocalEphemeralVolume(volume v1.Volume) bool {\n\treturn volume.GitRepo != nil ||\n\t\t(volume.EmptyDir != nil && volume.EmptyDir.Medium == v1.StorageMediumDefault) ||\n\t\tvolume.ConfigMap != nil\n}"
  },
  {
    "id" : "b5d9f3c6-84bb-48cb-84db-74c14e372ce7",
    "prId" : 69484,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/69484#pullrequestreview-168458413",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1b996f64-9998-4822-9ece-47b59738182c",
        "parentId" : null,
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "nit, why is `goos` a parameter and not generated inside this method? ",
        "createdAt" : "2018-10-19T17:57:12Z",
        "updatedAt" : "2018-10-27T07:31:28Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      },
      {
        "id" : "082c5ba1-a113-40b6-9603-d571438e7d70",
        "parentId" : "1b996f64-9998-4822-9ece-47b59738182c",
        "authorId" : "98986d5f-c846-4478-8363-8a016e3d6b89",
        "body" : "`goos` as a parameter allows for an easy way to unit-test the function to make sure in other OS environments, there are no unexpected results.",
        "createdAt" : "2018-10-25T15:53:10Z",
        "updatedAt" : "2018-10-27T07:31:28Z",
        "lastEditedBy" : "98986d5f-c846-4478-8363-8a016e3d6b89",
        "tags" : [
        ]
      }
    ],
    "commit" : "5da66fd65fef91ac23cd3951cdf513881a238acd",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +949,953 @@// This can be used to skip any processing of paths\n// that point to SMB shares, local named pipes and local UNC path\nfunc IsWindowsUNCPath(goos, path string) bool {\n\tif goos != \"windows\" {\n\t\treturn false"
  },
  {
    "id" : "9780ae78-bbfb-450e-8d25-23b12f1857b5",
    "prId" : 69484,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/69484#pullrequestreview-169047250",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "83a679c0-a28a-4ad6-a9a1-5b07bce93188",
        "parentId" : null,
        "authorId" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "body" : "Should `MakeAbsolutePath` call this function instead?",
        "createdAt" : "2018-10-26T17:44:39Z",
        "updatedAt" : "2018-10-27T07:31:28Z",
        "lastEditedBy" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "tags" : [
        ]
      },
      {
        "id" : "45b683c7-7eb1-42ab-9398-5035daec9389",
        "parentId" : "83a679c0-a28a-4ad6-a9a1-5b07bce93188",
        "authorId" : "98986d5f-c846-4478-8363-8a016e3d6b89",
        "body" : "@yujuhong I would prefer to keep `MakeAbsolutePath` as is for now in the context of this PR. The scope of this PR is to enable named pipe mounting support in Windows and that code path skips `MakeAbsolutePath`. `MakeAbsolutePath` is called in a couple of contexts (not involving named pipes) and maybe refactored in a separate PR later?",
        "createdAt" : "2018-10-27T07:49:38Z",
        "updatedAt" : "2018-10-28T00:06:35Z",
        "lastEditedBy" : "98986d5f-c846-4478-8363-8a016e3d6b89",
        "tags" : [
        ]
      }
    ],
    "commit" : "5da66fd65fef91ac23cd3951cdf513881a238acd",
    "line" : 20,
    "diffHunk" : "@@ -1,1 +962,966 @@// IsWindowsLocalPath checks if path is a local path\n// prefixed with \"/\" or \"\\\" like \"/foo/bar\" or \"\\foo\\bar\"\nfunc IsWindowsLocalPath(goos, path string) bool {\n\tif goos != \"windows\" {\n\t\treturn false"
  },
  {
    "id" : "27250b97-afc9-476f-8265-f909e50b330c",
    "prId" : 67745,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/67745#pullrequestreview-150826626",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "29a76cf7-2abc-402a-b717-5de2495fcf8e",
        "parentId" : null,
        "authorId" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "body" : "Should we migrate azure disks to the new SelectZoneForVolume() util method and get rid of this ChooseZoneForVolume method?",
        "createdAt" : "2018-08-29T20:20:15Z",
        "updatedAt" : "2018-08-29T20:20:15Z",
        "lastEditedBy" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "tags" : [
        ]
      },
      {
        "id" : "34865a63-3fe6-4e65-a1c7-de1b187be0af",
        "parentId" : "29a76cf7-2abc-402a-b717-5de2495fcf8e",
        "authorId" : "98986d5f-c846-4478-8363-8a016e3d6b89",
        "body" : "Good point. It looks like Azure Disks is already using `SelectZoneForVolume`. However when this patch was submitted `SelectZoneForVolume` was evolving and was using `ChooseZoneForVolume` (which is no longer the case). So only the fix further down for `ChooseZonesForVolume` is necessary for the Azure Disks scenario. Cinder volume does appear to still have a dependency on `ChooseZonesForVolume` which we can evaluate and refactor to get rid of `ChooseZoneForVolume`.",
        "createdAt" : "2018-08-29T20:46:40Z",
        "updatedAt" : "2018-08-29T20:46:40Z",
        "lastEditedBy" : "98986d5f-c846-4478-8363-8a016e3d6b89",
        "tags" : [
        ]
      },
      {
        "id" : "7548f537-3127-4ace-9a35-c1446a7767b5",
        "parentId" : "29a76cf7-2abc-402a-b717-5de2495fcf8e",
        "authorId" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "body" : "Don't we also have a SelectZonesForVolume too?",
        "createdAt" : "2018-08-29T21:13:08Z",
        "updatedAt" : "2018-08-29T21:13:08Z",
        "lastEditedBy" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "tags" : [
        ]
      },
      {
        "id" : "188347c5-6b63-42cc-bf22-b3ebc31a8a9f",
        "parentId" : "29a76cf7-2abc-402a-b717-5de2495fcf8e",
        "authorId" : "98986d5f-c846-4478-8363-8a016e3d6b89",
        "body" : "Yes. `SelectZoneForVolume` is just a wrapper around `SelectZonesForVolume` for single zone volumes today. EBS, Azure and non regional PD invokes `SelectZoneForVolume`",
        "createdAt" : "2018-08-29T22:35:55Z",
        "updatedAt" : "2018-08-29T22:35:56Z",
        "lastEditedBy" : "98986d5f-c846-4478-8363-8a016e3d6b89",
        "tags" : [
        ]
      },
      {
        "id" : "ebc5b324-cc9a-4848-b12d-6510bf5a894b",
        "parentId" : "29a76cf7-2abc-402a-b717-5de2495fcf8e",
        "authorId" : "0df1da34-610c-4ce5-b0cf-bbda668bf9c1",
        "body" : "@msau42 @ddebroy Thanks. Let me address this in a separate PR.",
        "createdAt" : "2018-08-30T03:30:54Z",
        "updatedAt" : "2018-08-30T03:30:54Z",
        "lastEditedBy" : "0df1da34-610c-4ce5-b0cf-bbda668bf9c1",
        "tags" : [
        ]
      }
    ],
    "commit" : "8e4ab129e92cec77c3797f0d3057405c5511aaac",
    "line" : 3,
    "diffHunk" : "@@ -1,1 +520,524 @@// This means that a StatefulSet's volumes (`claimname-statefulsetname-id`) will spread across available zones,\n// assuming the id values are consecutive.\nfunc ChooseZoneForVolume(zones sets.String, pvcName string) string {\n\t// No zones available, return empty string.\n\tif zones.Len() == 0 {"
  },
  {
    "id" : "7464c208-7335-4b0f-9853-b2f5ed4d820e",
    "prId" : 67530,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/67530#pullrequestreview-148283576",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "986bb6af-8ad4-4815-9cb2-ea9a059f49f2",
        "parentId" : null,
        "authorId" : "34f61776-88da-4b26-aa20-3c4f92530d05",
        "body" : "The `volumeutil.ValidateZone()` logic is missing here",
        "createdAt" : "2018-08-21T18:54:17Z",
        "updatedAt" : "2018-08-24T21:38:44Z",
        "lastEditedBy" : "34f61776-88da-4b26-aa20-3c4f92530d05",
        "tags" : [
        ]
      },
      {
        "id" : "55581877-c4ba-4ccf-801c-2daa97e1c463",
        "parentId" : "986bb6af-8ad4-4815-9cb2-ea9a059f49f2",
        "authorId" : "98986d5f-c846-4478-8363-8a016e3d6b89",
        "body" : "Is it necessary? All `ValidateZone` is doing is making sure the string does not have spaces/tabs. The cloud API call for PD creation will fail for an invalid zone like that eventually. Maybe I can invoke `ValidateZone` on the list of returned zones from `SelectZonesForVolume` if it is important.",
        "createdAt" : "2018-08-21T23:07:22Z",
        "updatedAt" : "2018-08-24T21:38:44Z",
        "lastEditedBy" : "98986d5f-c846-4478-8363-8a016e3d6b89",
        "tags" : [
        ]
      }
    ],
    "commit" : "a2de7d2d8daf730ce943f4b28decf70dc2cea488",
    "line" : 87,
    "diffHunk" : "@@ -1,1 +389,393 @@\t// pick zone from parameters if present\n\tif zoneParameterPresent {\n\t\tif numReplicas > 1 {\n\t\t\treturn nil, fmt.Errorf(\"zone cannot be specified if desired number of replicas for pv is greather than 1. Please specify zones or allowedTopologies to specify desired zones\")\n\t\t}"
  },
  {
    "id" : "daa67fc1-be02-4563-a831-af8e2634b499",
    "prId" : 67530,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/67530#pullrequestreview-148713849",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3326584a-043d-4752-9e69-2d446623837a",
        "parentId" : null,
        "authorId" : "34f61776-88da-4b26-aa20-3c4f92530d05",
        "body" : "What if `zoneToInclude` is not in `zones`?",
        "createdAt" : "2018-08-21T19:17:06Z",
        "updatedAt" : "2018-08-24T21:38:44Z",
        "lastEditedBy" : "34f61776-88da-4b26-aa20-3c4f92530d05",
        "tags" : [
        ]
      },
      {
        "id" : "20d50144-8616-42a3-883d-9e4bcb7c8f90",
        "parentId" : "3326584a-043d-4752-9e69-2d446623837a",
        "authorId" : "34f61776-88da-4b26-aa20-3c4f92530d05",
        "body" : "If this function assumes `zoneToInclude` is always in `zones`, it'd be helpful to call it out in comments",
        "createdAt" : "2018-08-21T19:20:21Z",
        "updatedAt" : "2018-08-24T21:38:44Z",
        "lastEditedBy" : "34f61776-88da-4b26-aa20-3c4f92530d05",
        "tags" : [
        ]
      },
      {
        "id" : "00b2f70b-f418-4ee5-8c75-19568b1ca5b2",
        "parentId" : "3326584a-043d-4752-9e69-2d446623837a",
        "authorId" : "98986d5f-c846-4478-8363-8a016e3d6b89",
        "body" : "The logic here makes sure `zoneToInclude` and `zones` is mutually exclusive. If `zoneToInclude` is set, `zones` should not be specified and that is what the logic here detects and error below calls out. To specify a list of \"allowed\" zones, the error also instructs that `allowedTopologies` should be specified with the list of allowed zones since that is integrated into the scheduler while `zones` is not.",
        "createdAt" : "2018-08-21T23:11:13Z",
        "updatedAt" : "2018-08-24T21:38:44Z",
        "lastEditedBy" : "98986d5f-c846-4478-8363-8a016e3d6b89",
        "tags" : [
        ]
      },
      {
        "id" : "7b622da3-fe38-4595-91b9-3263d8bd5405",
        "parentId" : "3326584a-043d-4752-9e69-2d446623837a",
        "authorId" : "34f61776-88da-4b26-aa20-3c4f92530d05",
        "body" : "Maybe you are referring to a different function? Both calls to `choozeZonesForVolumeIncludingZone()` pass in non-empty `zones` and they both allow for the possibility of non-empty `zoneToInclude`",
        "createdAt" : "2018-08-22T19:00:43Z",
        "updatedAt" : "2018-08-24T21:38:44Z",
        "lastEditedBy" : "34f61776-88da-4b26-aa20-3c4f92530d05",
        "tags" : [
        ]
      },
      {
        "id" : "0a8692a3-56ce-429b-9df8-7b57f8354fbc",
        "parentId" : "3326584a-043d-4752-9e69-2d446623837a",
        "authorId" : "98986d5f-c846-4478-8363-8a016e3d6b89",
        "body" : "Sorry - I was indeed referring to a different function. Agree with your comment above - `choozeZonesForVolumeIncludingZone()` does expect `zoneToInclude` to be part of `zones` and I will clarify that in a comment.",
        "createdAt" : "2018-08-22T23:44:12Z",
        "updatedAt" : "2018-08-24T21:38:44Z",
        "lastEditedBy" : "98986d5f-c846-4478-8363-8a016e3d6b89",
        "tags" : [
        ]
      }
    ],
    "commit" : "a2de7d2d8daf730ce943f4b28decf70dc2cea488",
    "line" : 191,
    "diffHunk" : "@@ -1,1 +621,625 @@\t\treturn zones, nil\n\t}\n\tif zoneToInclude != \"\" {\n\t\tzones.Delete(zoneToInclude)\n\t\tnumReplicas = numReplicas - 1"
  },
  {
    "id" : "1190fd35-67c9-4413-875c-7910750d1999",
    "prId" : 67530,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/67530#pullrequestreview-148622304",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e2e3ff33-ff70-4375-9835-1987254dfe09",
        "parentId" : null,
        "authorId" : "34f61776-88da-4b26-aa20-3c4f92530d05",
        "body" : "`zoneFromNode` could be outside allowed zones",
        "createdAt" : "2018-08-21T19:28:57Z",
        "updatedAt" : "2018-08-24T21:38:44Z",
        "lastEditedBy" : "34f61776-88da-4b26-aa20-3c4f92530d05",
        "tags" : [
        ]
      },
      {
        "id" : "86d211a5-3aa0-46f6-b994-dca4537c06c0",
        "parentId" : "e2e3ff33-ff70-4375-9835-1987254dfe09",
        "authorId" : "98986d5f-c846-4478-8363-8a016e3d6b89",
        "body" : "Can you clarify what you are referring to as allowed zones here? If you are referring to the `zones` parameter, then `zonesParameterPresent` need to be set and we check and make sure `zonesParameterPresent` is not specified in this code path up above in L349 (since the zones parameter is not integrated well with the scheduler). Unit test `Node_with_Zone_labels_and_Zones_parameter_present` covers this as well. \r\n\r\nIf you are referring to zones from `allowedTopologies`, then the scheduler guarantees the node selected has a zone (i.e. `zoneFromNode`) that is part of `allowedTopologies`. Maybe I can add a comment here to clarify this.",
        "createdAt" : "2018-08-21T23:24:05Z",
        "updatedAt" : "2018-08-24T21:38:44Z",
        "lastEditedBy" : "98986d5f-c846-4478-8363-8a016e3d6b89",
        "tags" : [
        ]
      },
      {
        "id" : "996500d1-43f0-456e-baa5-8becb074c661",
        "parentId" : "e2e3ff33-ff70-4375-9835-1987254dfe09",
        "authorId" : "34f61776-88da-4b26-aa20-3c4f92530d05",
        "body" : "Sorry I was referring to `allowedTopologies`. Thanks for the explanation!",
        "createdAt" : "2018-08-22T18:52:24Z",
        "updatedAt" : "2018-08-24T21:38:44Z",
        "lastEditedBy" : "34f61776-88da-4b26-aa20-3c4f92530d05",
        "tags" : [
        ]
      }
    ],
    "commit" : "a2de7d2d8daf730ce943f4b28decf70dc2cea488",
    "line" : 51,
    "diffHunk" : "@@ -1,1 +359,363 @@\t\t// if single replica volume and node with zone found, return immediately\n\t\tif numReplicas == 1 {\n\t\t\treturn sets.NewString(zoneFromNode), nil\n\t\t}\n\t}"
  },
  {
    "id" : "69fafac4-30ae-42fa-b499-465364ca209f",
    "prId" : 67530,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/67530#pullrequestreview-148294661",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e4ec95e8-55fd-4c57-afff-04b3c2df03c8",
        "parentId" : null,
        "authorId" : "34f61776-88da-4b26-aa20-3c4f92530d05",
        "body" : "nit: Is it possible to do without some of these parameters? If we can reduce the input set, it'll help guarantee test coverage and possibly improve code maintainability",
        "createdAt" : "2018-08-21T19:58:00Z",
        "updatedAt" : "2018-08-24T21:38:44Z",
        "lastEditedBy" : "34f61776-88da-4b26-aa20-3c4f92530d05",
        "tags" : [
        ]
      },
      {
        "id" : "15aec2a9-d3e8-4e08-ad10-807bc8df037c",
        "parentId" : "e4ec95e8-55fd-4c57-afff-04b3c2df03c8",
        "authorId" : "542e5d2f-2ff9-4674-ab44-78f31768e7a1",
        "body" : "since a lot of these parameters are mutually exclusive to each other, it might be worth having a `SelectZonesForVolume` that only takes in one of these params called `zones`, and a wrapper function that does all this logic to determine mutual exclusivity as well as picking which of the `zone|zones|topology` to pass to `SelectZonesForVolume`",
        "createdAt" : "2018-08-21T20:13:36Z",
        "updatedAt" : "2018-08-24T21:38:44Z",
        "lastEditedBy" : "542e5d2f-2ff9-4674-ab44-78f31768e7a1",
        "tags" : [
        ]
      },
      {
        "id" : "94c3e43a-849f-4e46-acff-fafaa0d6d058",
        "parentId" : "e4ec95e8-55fd-4c57-afff-04b3c2df03c8",
        "authorId" : "98986d5f-c846-4478-8363-8a016e3d6b89",
        "body" : "@verult The idea behind `SelectZonesForVolume` is all the in-tree providers like EBS, Azure and GCE PD should be able to parse out volume zone and topology parameters from the storage class, invoke `SelectZoneForVolume`/`SelectZonesForVolume` and get a (set of) volume(s) back to pass to the cloud provider API without having to duplicate any of the logic to enforce the rules. So `SelectZonesForVolume` is the wrapper that implements all the common logic to determine mutual exclusivity and for that it needs the full set of parameters around zone/zones/node/topology. I agree that the long list of parameters is not pretty but to help with maintenance, we have an extensive set of unit tests in `TestSelectZonesForVolume` and `TestSelectZoneForVolume`. Those should make sure none of the rules around exclusivity of the parameters are broken.\r\n\r\n@davidz627  `SelectZonesForVolume` is the wrapper that enforces the compatibility rules among the parameters. `chooseZonesForVolumeIncludingZone`/`ChooseZonesForVolume` invoked from `SelectZonesForVolume` does the actual picking of zone(s) from a set of zones. Let me know if it makes sense and already aligns with the above suggestion.\r\n",
        "createdAt" : "2018-08-22T00:05:30Z",
        "updatedAt" : "2018-08-24T21:38:44Z",
        "lastEditedBy" : "98986d5f-c846-4478-8363-8a016e3d6b89",
        "tags" : [
        ]
      }
    ],
    "commit" : "a2de7d2d8daf730ce943f4b28decf70dc2cea488",
    "line" : 24,
    "diffHunk" : "@@ -1,1 +338,342 @@// node.zone, allowedTopologies, zone/zones parameters from storageclass,\n// zones with active nodes from the cluster. The number of zones = replicas.\nfunc SelectZonesForVolume(zoneParameterPresent, zonesParameterPresent bool, zoneParameter string, zonesParameter, zonesWithNodes sets.String, node *v1.Node, allowedTopologies []v1.TopologySelectorTerm, pvcName string, numReplicas uint32) (sets.String, error) {\n\tif zoneParameterPresent && zonesParameterPresent {\n\t\treturn nil, fmt.Errorf(\"both zone and zones StorageClass parameters must not be used at the same time\")"
  },
  {
    "id" : "ea350d2d-de7f-4126-a15f-8dbd6e3e3a1c",
    "prId" : 67444,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/67444#pullrequestreview-158866393",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "69599bd8-10ea-4457-aea5-d37c5d85851e",
        "parentId" : null,
        "authorId" : "bfb32501-a689-4c4c-941b-d6dcf433bb91",
        "body" : "returns",
        "createdAt" : "2018-09-26T07:42:40Z",
        "updatedAt" : "2018-09-26T07:42:40Z",
        "lastEditedBy" : "bfb32501-a689-4c4c-941b-d6dcf433bb91",
        "tags" : [
        ]
      }
    ],
    "commit" : "919f754da8324e14f46153cee8508b494dda7963",
    "line" : 23,
    "diffHunk" : "@@ -1,1 +196,200 @@}\n\n// IsCorruptedMnt return true if err is about corrupted mount point\nfunc IsCorruptedMnt(err error) bool {\n\tif err == nil {"
  },
  {
    "id" : "ed819e48-7b16-4ce0-be64-e870209d22f8",
    "prId" : 65730,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/65730#pullrequestreview-139365097",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "96673225-df06-430d-9f3e-d3dea8c2f0c5",
        "parentId" : null,
        "authorId" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "body" : "We should document somewhere that only `LabelZoneFailureDomain` is supported on AWS (in a separate PR).",
        "createdAt" : "2018-07-23T08:05:13Z",
        "updatedAt" : "2018-08-01T16:00:31Z",
        "lastEditedBy" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "tags" : [
        ]
      }
    ],
    "commit" : "217a3d890219abf7eb759e9b64c0403c6ee40e2c",
    "line" : 80,
    "diffHunk" : "@@ -1,1 +378,382 @@\tfor _, term := range allowedTopologies {\n\t\tfor _, exp := range term.MatchLabelExpressions {\n\t\t\tif exp.Key == kubeletapis.LabelZoneFailureDomain {\n\t\t\t\tfor _, value := range exp.Values {\n\t\t\t\t\tzones.Insert(value)"
  },
  {
    "id" : "5d84f839-c4b0-47fa-8a64-4f82d9edb609",
    "prId" : 59391,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/59391#pullrequestreview-94430267",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "149ecacb-8e39-482c-8ce7-a3a9db0ff3a8",
        "parentId" : null,
        "authorId" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "body" : "@jsafrane for storageclass, did the alpha annotation override beta?  Or the other way around?",
        "createdAt" : "2018-02-06T16:57:04Z",
        "updatedAt" : "2018-02-20T19:43:49Z",
        "lastEditedBy" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "tags" : [
        ]
      },
      {
        "id" : "d38fa05f-b9db-44c2-93d9-1167da7de4ec",
        "parentId" : "149ecacb-8e39-482c-8ce7-a3a9db0ff3a8",
        "authorId" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "body" : "Actually this is different, it is evaluating both if they both exist.",
        "createdAt" : "2018-02-06T17:19:30Z",
        "updatedAt" : "2018-02-20T19:43:49Z",
        "lastEditedBy" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "tags" : [
        ]
      }
    ],
    "commit" : "a6a225623b0e359b32dec34cb83ad4ad6d5c4f49",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +238,242 @@// This ensures that we don't mount a volume that doesn't belong to this node\nfunc CheckNodeAffinity(pv *v1.PersistentVolume, nodeLabels map[string]string) error {\n\tif err := checkAlphaNodeAffinity(pv, nodeLabels); err != nil {\n\t\treturn err\n\t}"
  },
  {
    "id" : "c0834be8-73bf-4569-86f0-58f47ab37969",
    "prId" : 52324,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/52324#pullrequestreview-80054365",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0ea8775e-f73e-4ed8-a93e-093f2a9c7609",
        "parentId" : null,
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "Will calling `Unmount(...)` if `err == syscall.ENOTCONN || err == syscall.ESTALE` succeed? ",
        "createdAt" : "2017-11-29T01:26:00Z",
        "updatedAt" : "2018-01-10T13:36:37Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      },
      {
        "id" : "492dce69-6a12-4665-969a-fdf51b7a6c01",
        "parentId" : "0ea8775e-f73e-4ed8-a93e-093f2a9c7609",
        "authorId" : "60a2148d-5cbe-4c5f-8c70-27925a3b117b",
        "body" : "Yes, in this case the mount point exists but  is corrupted,it needs to be umounted",
        "createdAt" : "2017-11-30T01:27:25Z",
        "updatedAt" : "2018-01-10T13:36:37Z",
        "lastEditedBy" : "60a2148d-5cbe-4c5f-8c70-27925a3b117b",
        "tags" : [
        ]
      }
    ],
    "commit" : "19003486bfa241d539b13b030979f31f7713450e",
    "line" : 67,
    "diffHunk" : "@@ -1,1 +136,140 @@\t}\n\n\t// Unmount the mount path\n\tglog.V(4).Infof(\"%q is a mountpoint, unmounting\", mountPath)\n\tif err := mounter.Unmount(mountPath); err != nil {"
  },
  {
    "id" : "08e8b411-7249-44ed-80da-480109a6fcc7",
    "prId" : 52324,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/52324#pullrequestreview-80661952",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d816eb9d-4d08-4403-a748-3a505132958e",
        "parentId" : null,
        "authorId" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "body" : "The comment is not applicable here? Maybe explain about isCorruptedMnt in the comment?",
        "createdAt" : "2017-12-01T17:22:13Z",
        "updatedAt" : "2018-01-10T13:36:37Z",
        "lastEditedBy" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "tags" : [
        ]
      },
      {
        "id" : "1b8e2eff-7815-431c-9d39-f9aeece82801",
        "parentId" : "d816eb9d-4d08-4403-a748-3a505132958e",
        "authorId" : "60a2148d-5cbe-4c5f-8c70-27925a3b117b",
        "body" : "isCorruptedMnt  is described at L112 :\r\n`// corruptedMnt should be true if the mountPath is a corrupted mount point`\r\n#L97 and #L98 describes parameter 'extensiveMountPointCheck '.",
        "createdAt" : "2017-12-02T01:36:44Z",
        "updatedAt" : "2018-01-10T13:36:37Z",
        "lastEditedBy" : "60a2148d-5cbe-4c5f-8c70-27925a3b117b",
        "tags" : [
        ]
      }
    ],
    "commit" : "19003486bfa241d539b13b030979f31f7713450e",
    "line" : 10,
    "diffHunk" : "@@ -1,1 +96,100 @@// if extensiveMountPointCheck is true\n// IsNotMountPoint will be called instead of IsLikelyNotMountPoint.\n// IsNotMountPoint is more expensive but properly handles bind mounts.\nfunc UnmountMountPoint(mountPath string, mounter mount.Interface, extensiveMountPointCheck bool) error {\n\tpathExists, pathErr := PathExists(mountPath)"
  },
  {
    "id" : "c50d701d-8ea5-40ab-8c06-2b75a3acd13e",
    "prId" : 52324,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/52324#pullrequestreview-84479693",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b09f6b88-bd17-4d89-844d-165bebbeb675",
        "parentId" : null,
        "authorId" : "a7f673a6-4b23-4df6-aa10-f123fa9dcd5f",
        "body" : "this can be refactored\r\n```go\r\nfunc isCorruptedMnt(err error) bool {\r\n  return err != nil && (err == syscall.ENOTCONN || err == syscall.ESTALE)\r\n}",
        "createdAt" : "2017-12-19T14:47:56Z",
        "updatedAt" : "2018-01-10T13:36:37Z",
        "lastEditedBy" : "a7f673a6-4b23-4df6-aa10-f123fa9dcd5f",
        "tags" : [
        ]
      },
      {
        "id" : "9be4a217-ddb5-4842-b6ca-b9200d3f32d9",
        "parentId" : "b09f6b88-bd17-4d89-844d-165bebbeb675",
        "authorId" : "60a2148d-5cbe-4c5f-8c70-27925a3b117b",
        "body" : "`if err == nil {\r\n  return false\r\n}`\r\nIf we have check the `err` ahead, it is no need to check it again when returning",
        "createdAt" : "2017-12-19T15:11:50Z",
        "updatedAt" : "2018-01-10T13:36:37Z",
        "lastEditedBy" : "60a2148d-5cbe-4c5f-8c70-27925a3b117b",
        "tags" : [
        ]
      }
    ],
    "commit" : "19003486bfa241d539b13b030979f31f7713450e",
    "line" : 89,
    "diffHunk" : "@@ -1,1 +167,171 @@\n// isCorruptedMnt return true if err is about corrupted mount point\nfunc isCorruptedMnt(err error) bool {\n\tif err == nil {\n\t\treturn false"
  },
  {
    "id" : "cd1353e7-86fb-4933-af98-ea396e952eec",
    "prId" : 52324,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/52324#pullrequestreview-84481372",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e533e5d8-4281-4196-b2a4-9982a511531f",
        "parentId" : null,
        "authorId" : "a7f673a6-4b23-4df6-aa10-f123fa9dcd5f",
        "body" : "I am not comfortable with `syscall` here, should be with platform dependent build.",
        "createdAt" : "2017-12-19T14:48:52Z",
        "updatedAt" : "2018-01-10T13:36:37Z",
        "lastEditedBy" : "a7f673a6-4b23-4df6-aa10-f123fa9dcd5f",
        "tags" : [
        ]
      },
      {
        "id" : "2c3c3d45-68da-4c0a-ba08-157b53526784",
        "parentId" : "e533e5d8-4281-4196-b2a4-9982a511531f",
        "authorId" : "60a2148d-5cbe-4c5f-8c70-27925a3b117b",
        "body" : "could you give me a hint about how to move \"syscall\" out here?\r\nI found many other files also use \"syscall\".",
        "createdAt" : "2017-12-19T15:16:24Z",
        "updatedAt" : "2018-01-10T13:36:37Z",
        "lastEditedBy" : "60a2148d-5cbe-4c5f-8c70-27925a3b117b",
        "tags" : [
        ]
      }
    ],
    "commit" : "19003486bfa241d539b13b030979f31f7713450e",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +24,28 @@\t\"path/filepath\"\n\t\"strings\"\n\t\"syscall\"\n\n\t\"github.com/golang/glog\""
  },
  {
    "id" : "8b86b234-354d-4ef6-9a47-6d61b40f599f",
    "prId" : 52324,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/52324#pullrequestreview-88148473",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1e1cc370-74d4-49ed-87a7-b704a780d95d",
        "parentId" : null,
        "authorId" : "3eb39df2-c27a-40ed-9fab-cabae1c6353d",
        "body" : "`isCorruptedMnt` a good name ? because the check is mainly on `ENOTCONN` or `STALE` , in that sense I feel this mount is more tangent to `stale` mount than `corrupted` mount. May be `isStaleMnt` is a better name for this function.",
        "createdAt" : "2018-01-11T11:39:31Z",
        "updatedAt" : "2018-01-11T11:39:59Z",
        "lastEditedBy" : "3eb39df2-c27a-40ed-9fab-cabae1c6353d",
        "tags" : [
        ]
      },
      {
        "id" : "44b921a7-187a-4bbf-9786-a597e09ca788",
        "parentId" : "1e1cc370-74d4-49ed-87a7-b704a780d95d",
        "authorId" : "60a2148d-5cbe-4c5f-8c70-27925a3b117b",
        "body" : "I think `corrupted` is more generic than `stale`",
        "createdAt" : "2018-01-11T12:21:31Z",
        "updatedAt" : "2018-01-11T12:21:31Z",
        "lastEditedBy" : "60a2148d-5cbe-4c5f-8c70-27925a3b117b",
        "tags" : [
        ]
      }
    ],
    "commit" : "19003486bfa241d539b13b030979f31f7713450e",
    "line" : 28,
    "diffHunk" : "@@ -1,1 +103,107 @@\t\treturn nil\n\t}\n\tcorruptedMnt := isCorruptedMnt(pathErr)\n\tif pathErr != nil && !corruptedMnt {\n\t\treturn fmt.Errorf(\"Error checking path: %v\", pathErr)"
  },
  {
    "id" : "501b85ed-88c4-4b5d-94a4-69dc4c7f6565",
    "prId" : 51667,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/51667#pullrequestreview-60211995",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "905c931d-1127-46b2-a969-c12b514825f0",
        "parentId" : null,
        "authorId" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "body" : "Where is this called?",
        "createdAt" : "2017-09-01T18:11:49Z",
        "updatedAt" : "2017-09-05T03:16:45Z",
        "lastEditedBy" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "tags" : [
        ]
      },
      {
        "id" : "0a7a0ff9-65e0-4952-80dd-a683102287f3",
        "parentId" : "905c931d-1127-46b2-a969-c12b514825f0",
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "In `pkg/cloudprovider/providers/gce/gce_disks.go`",
        "createdAt" : "2017-09-01T18:24:50Z",
        "updatedAt" : "2017-09-05T03:16:45Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      },
      {
        "id" : "2c36094a-198a-4dc9-a4ce-d796e4227ca6",
        "parentId" : "905c931d-1127-46b2-a969-c12b514825f0",
        "authorId" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "body" : "Nm the file was collapsed",
        "createdAt" : "2017-09-01T18:33:43Z",
        "updatedAt" : "2017-09-05T03:16:45Z",
        "lastEditedBy" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "tags" : [
        ]
      }
    ],
    "commit" : "8a2d1cd63a62e76cee94b9796198c7fecdc30a8f",
    "line" : 25,
    "diffHunk" : "@@ -1,1 +241,245 @@}\n\nfunc ZonesSetToLabelValue(strSet sets.String) string {\n\treturn strings.Join(strSet.UnsortedList(), kubeletapis.LabelMultiZoneDelimiter)\n}"
  },
  {
    "id" : "b2c51ce6-cf13-4798-ae11-2f5b941afb44",
    "prId" : 51494,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/51494#pullrequestreview-77598089",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9f4f142d-27c9-4137-b466-b0062eaf9b51",
        "parentId" : null,
        "authorId" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "body" : "Are you sure you want to remove all? In the normal successful case, there shouldn't be any content left in the directory right?",
        "createdAt" : "2017-11-16T23:45:46Z",
        "updatedAt" : "2017-11-20T19:12:48Z",
        "lastEditedBy" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "tags" : [
        ]
      },
      {
        "id" : "62fbc21f-d00c-4d89-807f-ebd913d8ec2a",
        "parentId" : "9f4f142d-27c9-4137-b466-b0062eaf9b51",
        "authorId" : "967a712d-9784-41d4-920d-42eaba99fb24",
        "body" : "We call RemoveMapPath() following two cases.\r\n\r\n(1) From GenerateUnmapVolumeFunc() -> remove only symlink under pod device map path \r\n(2) From GenerateUnmapDeviceFunc() -> remove whole global map path directory\r\n\r\nWhen we call case (2), we already confirmed that;\r\n- There is no reference from Pods to volume\r\n- TearDownDevice is completed. Plugin's stored data under global map path directory are unnecessary at this point.\r\n\r\nTherefore, I think we can global map path directory safely, otherwise the directory will be remained after volume is deleted.",
        "createdAt" : "2017-11-18T00:53:59Z",
        "updatedAt" : "2017-11-20T19:12:48Z",
        "lastEditedBy" : "967a712d-9784-41d4-920d-42eaba99fb24",
        "tags" : [
        ]
      }
    ],
    "commit" : "9329dd5b91a099888f0cfb2aeeb79659a093f6ed",
    "line" : 140,
    "diffHunk" : "@@ -1,1 +382,386 @@\t}\n\tglog.V(5).Infof(\"RemoveMapPath: mapPath %s\", mapPath)\n\terr := os.RemoveAll(mapPath)\n\tif err != nil && !os.IsNotExist(err) {\n\t\treturn err"
  },
  {
    "id" : "5b790489-7b1f-42da-acfe-f90ac1016f0a",
    "prId" : 50984,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/50984#pullrequestreview-77331840",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "827d8e9a-4d5a-4d7a-8948-0131237e98f0",
        "parentId" : null,
        "authorId" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "body" : "Why changing this? I'm not familiar with the codecs, so just a question.",
        "createdAt" : "2017-11-16T21:16:09Z",
        "updatedAt" : "2017-11-21T04:24:51Z",
        "lastEditedBy" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "tags" : [
        ]
      },
      {
        "id" : "fd591413-8cf4-436c-930d-316adc7e0e19",
        "parentId" : "827d8e9a-4d5a-4d7a-8948-0131237e98f0",
        "authorId" : "f81960f6-a033-4403-bebf-c8ebb484e444",
        "body" : "In testing that f(n) it was a bug.  ",
        "createdAt" : "2017-11-17T03:27:27Z",
        "updatedAt" : "2017-11-21T04:24:51Z",
        "lastEditedBy" : "f81960f6-a033-4403-bebf-c8ebb484e444",
        "tags" : [
        ]
      }
    ],
    "commit" : "763122ae4bc86a055e9c0cca5a3ac987caef23e2",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +234,238 @@\tpod := &v1.Pod{}\n\n\tcodec := legacyscheme.Codecs.UniversalDecoder()\n\tif err := runtime.DecodeInto(codec, podDef, pod); err != nil {\n\t\treturn nil, fmt.Errorf(\"failed decoding file: %v\", err)"
  },
  {
    "id" : "24c35335-e5b5-4aae-b39a-ea12ea6a709f",
    "prId" : 48402,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/48402#pullrequestreview-48114300",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4c022ba0-163b-4775-bbcf-cf80db596d00",
        "parentId" : null,
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "Also please add comment about perf implications about enabling this option.",
        "createdAt" : "2017-07-05T17:07:53Z",
        "updatedAt" : "2017-07-11T21:24:24Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      }
    ],
    "commit" : "2b18d3b6f71a1786c68dee630b0452d20c71f844",
    "line" : 9,
    "diffHunk" : "@@ -1,1 +81,85 @@// UnmountMountPoint is a common unmount routine that unmounts the given path and\n// deletes the remaining directory if successful.\n// if extensiveMountPointCheck is true\n// IsNotMountPoint will be called instead of IsLikelyNotMountPoint.\n// IsNotMountPoint is more expensive but properly handles bind mounts."
  },
  {
    "id" : "1c9bf0d8-ad61-4d37-b4e6-4ccc714062b9",
    "prId" : 31434,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "cbf6b338-4cf4-4da5-93c2-df9381ae8e9a",
        "parentId" : null,
        "authorId" : "2b1215ee-94d4-4f04-a67a-accf4895711a",
        "body" : "Is there a need to check if theres already a value set for the specified key?\n",
        "createdAt" : "2016-09-13T14:01:34Z",
        "updatedAt" : "2016-09-17T08:09:13Z",
        "lastEditedBy" : "2b1215ee-94d4-4f04-a67a-accf4895711a",
        "tags" : [
        ]
      },
      {
        "id" : "2f2ed2ff-d916-4a3c-8b2d-221eace7ac6a",
        "parentId" : "cbf6b338-4cf4-4da5-93c2-df9381ae8e9a",
        "authorId" : "a7f673a6-4b23-4df6-aa10-f123fa9dcd5f",
        "body" : "the annotation should be empty when the pv is provisioned. \n",
        "createdAt" : "2016-09-13T14:36:18Z",
        "updatedAt" : "2016-09-17T08:09:13Z",
        "lastEditedBy" : "a7f673a6-4b23-4df6-aa10-f123fa9dcd5f",
        "tags" : [
        ]
      }
    ],
    "commit" : "02db13b6208b2777c1b12d016235b98681438dfd",
    "line" : 20,
    "diffHunk" : "@@ -1,1 +136,140 @@\n\tfor k, v := range annotations {\n\t\tpv.Annotations[k] = v\n\t}\n}"
  },
  {
    "id" : "0f941006-0c06-4de9-93ff-2ab3dcb0b3a5",
    "prId" : 30661,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7c4ed033-5cae-45bc-a867-7bb4702504e8",
        "parentId" : null,
        "authorId" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "body" : "Could we add a log here showing that mountPath is removed?\n",
        "createdAt" : "2016-08-15T23:43:13Z",
        "updatedAt" : "2016-08-15T23:58:39Z",
        "lastEditedBy" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "tags" : [
        ]
      },
      {
        "id" : "2c70c029-8fee-4706-b24e-b057a33a56ce",
        "parentId" : "7c4ed033-5cae-45bc-a867-7bb4702504e8",
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "Done.\n",
        "createdAt" : "2016-08-15T23:54:50Z",
        "updatedAt" : "2016-08-15T23:58:39Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      }
    ],
    "commit" : "e73c51636638ac7e18074d924907d1f20f9e495b",
    "line" : null,
    "diffHunk" : "@@ -1,1 +78,82 @@\t\t// Only delete directory on successful unmount\n\t\tglog.V(5).Infof(\"Unmounted %q. Deleting path.\", mountPath)\n\t\treturn os.Remove(mountPath)\n\t}\n"
  }
]
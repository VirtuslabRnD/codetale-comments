[
  {
    "id" : "4232b72c-5aee-4403-b5fc-1c23528d4916",
    "prId" : 83098,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/83098#pullrequestreview-312183020",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f9876bfb-02db-404b-a548-ed6afc73024b",
        "parentId" : null,
        "authorId" : "5f2c1de8-4266-42c0-b343-ba247af3578f",
        "body" : "Is `FindPluginBySpec failed... with error: nil` a reasonable description of the problem when both `err` and `volumePlugin` are nil?",
        "createdAt" : "2019-11-06T02:26:09Z",
        "updatedAt" : "2019-11-15T01:28:24Z",
        "lastEditedBy" : "5f2c1de8-4266-42c0-b343-ba247af3578f",
        "tags" : [
        ]
      },
      {
        "id" : "fdf63685-938a-4dca-87ed-c242d1e8ecdc",
        "parentId" : "f9876bfb-02db-404b-a548-ed6afc73024b",
        "authorId" : "98986d5f-c846-4478-8363-8a016e3d6b89",
        "body" : "Good point ... will fix.",
        "createdAt" : "2019-11-06T03:57:15Z",
        "updatedAt" : "2019-11-15T01:28:24Z",
        "lastEditedBy" : "98986d5f-c846-4478-8363-8a016e3d6b89",
        "tags" : [
        ]
      }
    ],
    "commit" : "129f15328bfc159e759260408fedbb9ea1ab2b61",
    "line" : 19,
    "diffHunk" : "@@ -1,1 +644,648 @@\t\t\tif err != nil {\n\t\t\t\tklog.Errorf(\n\t\t\t\t\t\"VolumesAreAttached.FindPluginBySpec failed for volume %q (spec.Name: %q) on node %q with error: %v\",\n\t\t\t\t\tvolumeAttached.VolumeName,\n\t\t\t\t\tvolumeAttached.VolumeSpec.Name(),"
  },
  {
    "id" : "c214d526-62f9-4a95-9304-279220fefb09",
    "prId" : 82492,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/82492#pullrequestreview-286533105",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3f622bcd-cfec-4c2e-970b-fe5a30d39dcb",
        "parentId" : null,
        "authorId" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "body" : "do we really need this state?\r\nNormally we can just use a boolean value to indicate the volume is already mounted if it is true. If it is false, that means we are not sure it is mounted or not, but still add it into the state and reconciler will update the state after it successfully mounted.",
        "createdAt" : "2019-09-09T18:29:19Z",
        "updatedAt" : "2019-12-12T03:10:37Z",
        "lastEditedBy" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "tags" : [
        ]
      },
      {
        "id" : "536830e2-0ab3-49f7-9794-c0f940a6bb59",
        "parentId" : "3f622bcd-cfec-4c2e-970b-fe5a30d39dcb",
        "authorId" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "body" : "We can manage with boolean value of mount state but in a lot of places we typically have to carry a comment to explain a boolean value (/*MountUncertain*/) and stuff like that. I thought it might be best to be explicit and let the field document what it is and that way - it will be more clear. What do you think?\r\n",
        "createdAt" : "2019-09-10T16:03:07Z",
        "updatedAt" : "2019-12-12T03:10:37Z",
        "lastEditedBy" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "tags" : [
        ]
      },
      {
        "id" : "23dd9c98-a38b-4c7d-a341-0ffdaa24ee29",
        "parentId" : "3f622bcd-cfec-4c2e-970b-fe5a30d39dcb",
        "authorId" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "body" : "Another thing I am thinking is - if mount failed with timeout first time and on second attempt mount failed with non-timeout(final) error then the volume should be moved to `VolumeNotMounted` state. I will update the code to do that.",
        "createdAt" : "2019-09-11T03:02:50Z",
        "updatedAt" : "2019-12-12T03:10:37Z",
        "lastEditedBy" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "tags" : [
        ]
      }
    ],
    "commit" : "ca532c6fb2c08f859eca13e0557f3b2aec9a18e0",
    "line" : 80,
    "diffHunk" : "@@ -1,1 +406,410 @@\n\t// VolumeNotMounted means volume has not be mounted in pod's local path\n\tVolumeNotMounted VolumeMountState = \"VolumeNotMounted\"\n)\n"
  },
  {
    "id" : "020f151b-6b67-42aa-b568-7b8ad84d36bc",
    "prId" : 71581,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/71581#pullrequestreview-180403791",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6faf53f3-1990-4140-b235-f987a00bfcf6",
        "parentId" : null,
        "authorId" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "body" : "here you remove the return err because it is always nil? How about all the other GernerateXXXFunc?",
        "createdAt" : "2018-11-30T18:42:49Z",
        "updatedAt" : "2018-11-30T18:42:50Z",
        "lastEditedBy" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "tags" : [
        ]
      },
      {
        "id" : "39a7a75a-aaa7-49b9-aba3-b95a9e80afd3",
        "parentId" : "6faf53f3-1990-4140-b235-f987a00bfcf6",
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "Mount was the most problematic in terms of log/event spam because of the new CSI access pattern. I want to do the same for the others methods because the same issue technically exists with them.\r\n\r\nI'm leaning towards getting this merged quick to fix the known issue, and then doing a follow up to make the other methods follow this pattern. But also happy to those as additional commits to this PR if folks want that.",
        "createdAt" : "2018-11-30T19:00:33Z",
        "updatedAt" : "2018-11-30T19:00:33Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      }
    ],
    "commit" : "2251bf0c214156e4ab92fd5e500355f4941140ec",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +726,730 @@\t\t// Filesystem volume case\n\t\t// Mount/remount a volume when a volume is attached\n\t\tgeneratedOperations = oe.operationGenerator.GenerateMountVolumeFunc(\n\t\t\twaitForAttachTimeout, volumeToMount, actualStateOfWorld, isRemount)\n"
  },
  {
    "id" : "92b2d916-927c-4604-8c65-3f92d2451b78",
    "prId" : 71276,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/71276#pullrequestreview-191409684",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a609b274-6e43-41e8-8fcf-9c683cea4089",
        "parentId" : null,
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "Add interface documentation (comments).\r\n\r\n```GO\r\n\t// Marks the specified volume as *possibly* attached to the specified node.\r\n\t// If an attach or detach operation fails, the attach/detach controller does not know for certain if the volume is attached or not.\r\n\t// If the volume name is supplied, that volume name will be used.  If not, the\r\n\t// volume name is computed using the result from querying the plugin.\r\n\tMarkVolumeAsUncertain(...)\r\n```",
        "createdAt" : "2019-01-10T00:02:19Z",
        "updatedAt" : "2019-01-11T18:57:57Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      },
      {
        "id" : "85f6cbd7-729a-48cd-9410-869ee325087f",
        "parentId" : "a609b274-6e43-41e8-8fcf-9c683cea4089",
        "authorId" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "body" : "fixed",
        "createdAt" : "2019-01-10T20:53:58Z",
        "updatedAt" : "2019-01-11T18:57:57Z",
        "lastEditedBy" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "tags" : [
        ]
      }
    ],
    "commit" : "7bac6ca73ad6fa1b0b637e801a524d6a1df663ea",
    "line" : 8,
    "diffHunk" : "@@ -1,1 +197,201 @@\t// If the volume name is supplied, that volume name will be used.  If not, the\n\t// volume name is computed using the result from querying the plugin.\n\tMarkVolumeAsUncertain(volumeName v1.UniqueVolumeName, volumeSpec *volume.Spec, nodeName types.NodeName) error\n\n\t// Marks the specified volume as detached from the specified node"
  },
  {
    "id" : "30fdec00-627b-4527-b000-3d0aba4dd730",
    "prId" : 66928,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/66928#pullrequestreview-443228456",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0af8e68b-f8af-4203-858c-531f9a42b463",
        "parentId" : null,
        "authorId" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "body" : "sorry to comment the late. But where this DesiredSizeLimit is used?",
        "createdAt" : "2019-08-12T20:34:13Z",
        "updatedAt" : "2019-08-12T20:34:13Z",
        "lastEditedBy" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "tags" : [
        ]
      },
      {
        "id" : "5382650e-cd27-4488-a30a-58ce596cacb2",
        "parentId" : "0af8e68b-f8af-4203-858c-531f9a42b463",
        "authorId" : "4aab55a0-5299-4d58-b630-6d54a352dba8",
        "body" : "It will be used when we implement quota enforcement.",
        "createdAt" : "2019-08-12T21:54:45Z",
        "updatedAt" : "2019-08-12T21:54:46Z",
        "lastEditedBy" : "4aab55a0-5299-4d58-b630-6d54a352dba8",
        "tags" : [
        ]
      },
      {
        "id" : "20eec304-fdd7-43d1-8903-13853e19a5be",
        "parentId" : "0af8e68b-f8af-4203-858c-531f9a42b463",
        "authorId" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "body" : "shouldn't we hold from introducing this until we have a plan to use it? It seems like we introduced this field and almost an year later nobody is using it. ",
        "createdAt" : "2020-07-06T16:26:14Z",
        "updatedAt" : "2020-07-06T16:26:14Z",
        "lastEditedBy" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "tags" : [
        ]
      }
    ],
    "commit" : "38753efcc758e16cb501906b9a1aabb7308a0246",
    "line" : 15,
    "diffHunk" : "@@ -1,1 +351,355 @@\t// DesiredSizeLimit indicates the desired upper bound on the size of the volume\n\t// (if so implemented)\n\tDesiredSizeLimit *resource.Quantity\n}\n"
  },
  {
    "id" : "875a1c00-b77b-4460-9aa8-a7b57bd34689",
    "prId" : 58177,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/58177#pullrequestreview-233050352",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8916eb21-1a60-4483-a7d5-f00381070c1c",
        "parentId" : null,
        "authorId" : "e0218e0a-9e55-43f5-8929-04673eea9015",
        "body" : "hi @jingxu, do you know why `devicePath` is changed here in the volume info? After this code change, `devicePath` in volume will be updated with new value of `WaitForAttach` func here: \r\nhttps://github.com/kubernetes/kubernetes/blob/568afb4ecca99bc3b54fddc20927b3713369d357/pkg/volume/util/operationexecutor/operation_generator.go#L488-L489\r\nThis would work on Linux node, while on Windows node, it may have issue (on windows, `devicePath` is always a Windows disk number, we cannot tell that number is from original or updated in `WaitForAttach` func), can we skip update `devicePath`  on Windows?",
        "createdAt" : "2019-05-02T14:44:00Z",
        "updatedAt" : "2019-05-02T14:44:16Z",
        "lastEditedBy" : "e0218e0a-9e55-43f5-8929-04673eea9015",
        "tags" : [
        ]
      }
    ],
    "commit" : "9588d2098a64c579ed351ba946dc900db79700f7",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +169,173 @@\n\t// Marks the specified volume as having been globally mounted.\n\tMarkDeviceAsMounted(volumeName v1.UniqueVolumeName, devicePath, deviceMountPath string) error\n\n\t// Marks the specified volume as having its global mount unmounted."
  },
  {
    "id" : "3058b6f8-43b9-47d8-8ec2-2405817190a4",
    "prId" : 56454,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/56454#pullrequestreview-94931851",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1a40b4b4-6047-4765-bd6a-c0b256c90041",
        "parentId" : null,
        "authorId" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "body" : "Before, this used to have podName = \"\", but now it's filled in. Is that correct?",
        "createdAt" : "2018-02-08T00:40:18Z",
        "updatedAt" : "2018-02-09T20:41:28Z",
        "lastEditedBy" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "tags" : [
        ]
      },
      {
        "id" : "178b7240-a522-4d8a-bf33-e9880591a5f9",
        "parentId" : "1a40b4b4-6047-4765-bd6a-c0b256c90041",
        "authorId" : "967a712d-9784-41d4-920d-42eaba99fb24",
        "body" : "IIUC, `nestedpendingoperations.EmptyUniquePodName` is empty string of types.UniquePodName type.\r\nTherefore, either passing \r\n- empty `podName = \"\"`\r\nor\r\n- `podName = nestedpendingoperations.EmptyUniquePodName`\r\n\r\nis same meaning.(avoid unmount device from multiple pods)",
        "createdAt" : "2018-02-08T01:18:58Z",
        "updatedAt" : "2018-02-09T20:41:28Z",
        "lastEditedBy" : "967a712d-9784-41d4-920d-42eaba99fb24",
        "tags" : [
        ]
      },
      {
        "id" : "0052597b-f224-428f-aa8e-6d5d034a19aa",
        "parentId" : "1a40b4b4-6047-4765-bd6a-c0b256c90041",
        "authorId" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "body" : "Ah ok I'm blind, thanks!",
        "createdAt" : "2018-02-08T01:28:32Z",
        "updatedAt" : "2018-02-09T20:41:28Z",
        "lastEditedBy" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "tags" : [
        ]
      }
    ],
    "commit" : "bc86537f184da3b6344816578c05b73a9a8ab5dc",
    "line" : 216,
    "diffHunk" : "@@ -1,1 +803,807 @@\n\treturn oe.pendingOperations.Run(\n\t\tdeviceToDetach.VolumeName, podName, generatedOperations)\n}\n"
  },
  {
    "id" : "e9f289a0-9c78-41c6-b496-acc4d1d82b24",
    "prId" : 51494,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/51494#pullrequestreview-77153035",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5714a254-5d22-484c-94c9-1a6084c5c28f",
        "parentId" : null,
        "authorId" : "967a712d-9784-41d4-920d-42eaba99fb24",
        "body" : "@jingxu97 @msau42 \r\n\r\nComments picking up from #54752.\r\n```\r\njingxu97 15 hours ago  Member\r\ndo we need to make it public. Seems like all MountVolume or MapVolume in operation executor could be private?\r\n```\r\nI believe we could make all methods in OperationExecutor interfaceas as private since they always used via operation executor, but I think we shouldn't change all of them in this one PR.\r\nRelated methods are following. I agree on making them as private in this PR.\r\n\r\n- MountVolume, MapVolume\r\n- UnmountVolume, UnmapVolume\r\n- UnmountDevice, UnmapDevice\r\n",
        "createdAt" : "2017-11-16T15:24:51Z",
        "updatedAt" : "2017-11-20T19:12:48Z",
        "lastEditedBy" : "967a712d-9784-41d4-920d-42eaba99fb24",
        "tags" : [
        ]
      }
    ],
    "commit" : "9329dd5b91a099888f0cfb2aeeb79659a093f6ed",
    "line" : 23,
    "diffHunk" : "@@ -1,1 +117,121 @@\t// * Map the volume to the pod device map path using symbolic link.\n\t// * Update actual state of world to reflect volume is mounted/mapped to the pod path.\n\tMapVolume(waitForAttachTimeout time.Duration, volumeToMount VolumeToMount, actualStateOfWorld ActualStateOfWorldMounterUpdater) error\n\n\t// UnmapVolume unmaps symbolic link to the volume from both the pod device"
  },
  {
    "id" : "449dc2e5-6bd3-48e5-8dbb-760dfa6de310",
    "prId" : 51494,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/51494#pullrequestreview-78159611",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f42d385f-16c9-49eb-a46c-53c67585e21a",
        "parentId" : null,
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "How is this different then `OperationExecutor` itself and why is it needed?",
        "createdAt" : "2017-11-21T08:05:10Z",
        "updatedAt" : "2017-11-21T08:09:29Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      },
      {
        "id" : "c76cf036-8e3c-4d30-bf5c-6c92136429ba",
        "parentId" : "f42d385f-16c9-49eb-a46c-53c67585e21a",
        "authorId" : "967a712d-9784-41d4-920d-42eaba99fb24",
        "body" : "This is wrapper to choose corresponding volume operations based on volumeMode.\r\nTo avoid adding `if volumeMode = \"Block\" {abc} else {xyz}` everywhere, we introduced this handler to select volume operation from volumeSpec.",
        "createdAt" : "2017-11-21T15:51:21Z",
        "updatedAt" : "2017-11-21T15:53:29Z",
        "lastEditedBy" : "967a712d-9784-41d4-920d-42eaba99fb24",
        "tags" : [
        ]
      }
    ],
    "commit" : "9329dd5b91a099888f0cfb2aeeb79659a093f6ed",
    "line" : 139,
    "diffHunk" : "@@ -1,1 +844,848 @@\n// VolumeStateHandler defines a set of operations for handling mount/unmount/detach/reconstruct volume-related operations\ntype VolumeStateHandler interface {\n\t// Volume is attached, mount/map it\n\tMountVolumeHandler(waitForAttachTimeout time.Duration, volumeToMount VolumeToMount, actualStateOfWorld ActualStateOfWorldMounterUpdater, isRemount bool, remountingLogStr string) error"
  },
  {
    "id" : "f019ab7d-61ad-4e38-9b19-aafa7ea767c9",
    "prId" : 51494,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/51494#pullrequestreview-78156164",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8532ac52-d1c6-4480-a24b-ff350421ce18",
        "parentId" : null,
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "Why are new `MapVolume`/`UnmapVolume` operations needed. Why can't the exist `MountDevice`/`UnmountDevice`/MountVolume`/`UnmountVolume` could be extended to capture block behavior?",
        "createdAt" : "2017-11-21T08:07:52Z",
        "updatedAt" : "2017-11-21T08:09:29Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      },
      {
        "id" : "4839f1ad-0dcc-4ce2-9189-a6ec655e9afc",
        "parentId" : "8532ac52-d1c6-4480-a24b-ff350421ce18",
        "authorId" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "body" : "`MountDevice` mounts in plugin global directory for reference counting. `MapVolume` does something completely different.",
        "createdAt" : "2017-11-21T12:48:33Z",
        "updatedAt" : "2017-11-21T12:48:33Z",
        "lastEditedBy" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "tags" : [
        ]
      },
      {
        "id" : "c23c9779-217b-4167-9271-0742f9945b89",
        "parentId" : "8532ac52-d1c6-4480-a24b-ff350421ce18",
        "authorId" : "967a712d-9784-41d4-920d-42eaba99fb24",
        "body" : "We have three operations `MountVolume`/`UnmountVolume`/`UnmountDevice` for filesystem volume currently. These operations execute `mount volume`, `unmount volume` and `detach volume`(non-attachable) based on `mountpoint` and `mountpoint reference counting` information.\r\n\r\nAs for the Block Volume case, we uses `symbolic link` and `reference count using symbolic link` since the volume isn't formatted.\r\n\r\nAs @jsafrane mentioned, operations are completely different between filesystem and block, therefore we define new operations which indicates internal steps.\r\n\r\nFilesystem | Purpose\r\n-------------- | -------------\r\nMountVolume | Call plugin's MountDevice() and SetUp()\r\nUnmountVolume | Call plugin's TearDown()\r\nUnmountDevice | Call plugin's UnmountDevice() based on reference count of mountpoint\r\n\r\nBlock | Purpose\r\n-------------- | -------------\r\nMapVolume | Call plugin's SetUpDevice() and create symlink(`mapping volume`) under plugin dir and pod dir. Create loopbak for volume to avoid silent volume replacement\r\nUnmapVolume | Delete symlink(`unmapping volume`) under plugin dir and pod dir\r\nUnmapDevice | Call plugin's TearDownDevice() based on reference count of symlink. Delete loopback",
        "createdAt" : "2017-11-21T15:42:43Z",
        "updatedAt" : "2017-11-21T16:07:56Z",
        "lastEditedBy" : "967a712d-9784-41d4-920d-42eaba99fb24",
        "tags" : [
        ]
      }
    ],
    "commit" : "9329dd5b91a099888f0cfb2aeeb79659a093f6ed",
    "line" : 23,
    "diffHunk" : "@@ -1,1 +117,121 @@\t// * Map the volume to the pod device map path using symbolic link.\n\t// * Update actual state of world to reflect volume is mounted/mapped to the pod path.\n\tMapVolume(waitForAttachTimeout time.Duration, volumeToMount VolumeToMount, actualStateOfWorld ActualStateOfWorldMounterUpdater) error\n\n\t// UnmapVolume unmaps symbolic link to the volume from both the pod device"
  },
  {
    "id" : "b3109814-88c5-4dc9-98c0-257d6db5677d",
    "prId" : 51494,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/51494#pullrequestreview-78165823",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e3a99b92-ee90-4cac-8568-25e877453581",
        "parentId" : null,
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "Why is this necessary? `MountDevice`/`UnmountDevice` do not ref count.",
        "createdAt" : "2017-11-21T08:09:17Z",
        "updatedAt" : "2017-11-21T08:09:29Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      },
      {
        "id" : "d44acc21-c6bd-44f4-b9c3-2fdcaebaa82f",
        "parentId" : "e3a99b92-ee90-4cac-8568-25e877453581",
        "authorId" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "body" : "We must have some way how to do reference counting to un-map a device when a pod is deleted when kubelet is down. We do the same with bind mounts for filesystems and scanning /proc/mounts.",
        "createdAt" : "2017-11-21T12:48:30Z",
        "updatedAt" : "2017-11-21T12:48:30Z",
        "lastEditedBy" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "tags" : [
        ]
      },
      {
        "id" : "fc22e71d-4def-4f52-b044-6b586b6f765f",
        "parentId" : "e3a99b92-ee90-4cac-8568-25e877453581",
        "authorId" : "967a712d-9784-41d4-920d-42eaba99fb24",
        "body" : "Please see above matrix.",
        "createdAt" : "2017-11-21T16:06:45Z",
        "updatedAt" : "2017-11-21T16:06:45Z",
        "lastEditedBy" : "967a712d-9784-41d4-920d-42eaba99fb24",
        "tags" : [
        ]
      }
    ],
    "commit" : "9329dd5b91a099888f0cfb2aeeb79659a093f6ed",
    "line" : 34,
    "diffHunk" : "@@ -1,1 +128,132 @@\t// free a volume for detach.\n\t// It then updates the actual state of the world to reflect that.\n\tUnmapDevice(deviceToDetach AttachedVolume, actualStateOfWorld ActualStateOfWorldMounterUpdater, mounter mount.Interface) error\n\n\t// VerifyControllerAttachedVolume checks if the specified volume is present"
  },
  {
    "id" : "8fc879b5-33cf-420a-adf5-0b686c869679",
    "prId" : 35434,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/35434#pullrequestreview-6881127",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "227fad87-32ff-44af-b27f-c49b9754b646",
        "parentId" : null,
        "authorId" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "body" : "I'm not a huge fan of wrapping errors, it makes them harder to deal with later.  Define a new struct that implements `error`?\n",
        "createdAt" : "2016-11-01T05:09:42Z",
        "updatedAt" : "2016-11-03T19:02:22Z",
        "lastEditedBy" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "tags" : [
        ]
      },
      {
        "id" : "8e8e1d84-54f9-40c8-9126-faa52e16004e",
        "parentId" : "227fad87-32ff-44af-b27f-c49b9754b646",
        "authorId" : "a7f673a6-4b23-4df6-aa10-f123fa9dcd5f",
        "body" : "@brendandburns wrapping errors looks a pattern used throughout this file, do you mind dealing with them in a separate PR and/or updating coding guide later?\n",
        "createdAt" : "2016-11-01T13:46:14Z",
        "updatedAt" : "2016-11-03T19:02:22Z",
        "lastEditedBy" : "a7f673a6-4b23-4df6-aa10-f123fa9dcd5f",
        "tags" : [
        ]
      },
      {
        "id" : "44b317f5-af6b-482c-bb59-feab022f40a5",
        "parentId" : "227fad87-32ff-44af-b27f-c49b9754b646",
        "authorId" : "9680f0db-1c00-49c9-968a-be3d5084d153",
        "body" : "This is a lot better, but the full solution would be to change AttachedVolume or some other high level type so we can specify when we have volume tech that exhibits this behaviour. Putting the code here makes it hard to know if we don't have the device as intended or if it just happens to be gone. \n",
        "createdAt" : "2016-11-02T18:30:49Z",
        "updatedAt" : "2016-11-03T19:02:22Z",
        "lastEditedBy" : "9680f0db-1c00-49c9-968a-be3d5084d153",
        "tags" : [
        ]
      }
    ],
    "commit" : "901e084a9839ac5bb60e1c491c96f41da07eb051",
    "line" : 26,
    "diffHunk" : "@@ -1,1 +976,980 @@\t\t\tdeviceOpened, deviceOpenedErr = mounter.DeviceOpened(deviceToDetach.DevicePath)\n\t\t\tif deviceOpenedErr != nil {\n\t\t\t\treturn fmt.Errorf(\n\t\t\t\t\t\"UnmountDevice.DeviceOpened failed for volume %q (spec.Name: %q) with: %v\",\n\t\t\t\t\tdeviceToDetach.VolumeName,"
  },
  {
    "id" : "097d9654-3976-43e7-9ed7-4ddf6f9f4f13",
    "prId" : 34859,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/34859#pullrequestreview-5557308",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "98fb2231-c704-4d10-81ef-8cdec7568157",
        "parentId" : null,
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "You are using a pointer as a key in a map. This means that the map will compare memory address for equality--not the contents of `volume.Spec`. Is that what you want? Looks like you are doing this in multiple places.\n\nUp to you how you want to handle it. I suggest passing around `api.UniqueVolumeName` as needed and using that as the key where possible.\n",
        "createdAt" : "2016-10-24T22:20:02Z",
        "updatedAt" : "2016-10-28T16:25:23Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      },
      {
        "id" : "e39acc76-a3c6-4451-9df6-6f1775086bc8",
        "parentId" : "98fb2231-c704-4d10-81ef-8cdec7568157",
        "authorId" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "body" : "Yes, I am try to compare whether they are the same object(volume.Spec), not the content. The functions implemented for Attacher interface are all using volume.Spec as parameters. So it is not very convenient here since operations for actual/desired states use volume id.  \n",
        "createdAt" : "2016-10-24T22:45:54Z",
        "updatedAt" : "2016-10-28T16:25:23Z",
        "lastEditedBy" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "tags" : [
        ]
      },
      {
        "id" : "7eab877a-265d-4c47-8128-8b76b3fd1151",
        "parentId" : "98fb2231-c704-4d10-81ef-8cdec7568157",
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "Ack\n",
        "createdAt" : "2016-10-24T23:10:20Z",
        "updatedAt" : "2016-10-28T16:25:23Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      }
    ],
    "commit" : "abbde4337485d0286ab51bbebff54ff02eb33694",
    "line" : 48,
    "diffHunk" : "@@ -1,1 +496,500 @@\t// volumeSpecMap maps from a volume spec to its unique volumeName which will be used\n\t// when calling MarkVolumeAsDetached\n\tvolumeSpecMap := make(map[*volume.Spec]api.UniqueVolumeName)\n\t// Iterate each volume spec and put them into a map index by the pluginName\n\tfor _, volumeAttached := range attachedVolumes {"
  },
  {
    "id" : "e80ec906-79cc-4698-95b4-dea690e61dd9",
    "prId" : 34859,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/34859#pullrequestreview-6176337",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9970ad9a-e40c-4f87-a01f-1774776a9b54",
        "parentId" : null,
        "authorId" : "8fc8f958-3c0e-47dd-a0fb-b8cc483b4efb",
        "body" : "What is the thread safety guarantee here (genuinely asking - I just don't know how we're keeping things sane here)?  Do we serialize operations on a node?\n",
        "createdAt" : "2016-10-26T18:58:39Z",
        "updatedAt" : "2016-10-28T16:25:23Z",
        "lastEditedBy" : "8fc8f958-3c0e-47dd-a0fb-b8cc483b4efb",
        "tags" : [
        ]
      },
      {
        "id" : "cbe4bc02-87cc-433f-8642-20553a1086a1",
        "parentId" : "9970ad9a-e40c-4f87-a01f-1774776a9b54",
        "authorId" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "body" : "actualStateOfWorld has sync.RWMutex to pretect multiple read/writes. Mounting/Umounting attachable volumes are serialized by nestedpendingoperations for the same volume. But checking volumes are attached can be operated concurrently with other operations.  Please let me know if there is any concern.\n",
        "createdAt" : "2016-10-26T22:20:36Z",
        "updatedAt" : "2016-10-28T16:25:23Z",
        "lastEditedBy" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "tags" : [
        ]
      },
      {
        "id" : "32f401da-7652-4309-9a04-4b2c67048494",
        "parentId" : "9970ad9a-e40c-4f87-a01f-1774776a9b54",
        "authorId" : "8fc8f958-3c0e-47dd-a0fb-b8cc483b4efb",
        "body" : "My concern is that we do asw.GetAttachedVolumesPerNode, which has a read-lock, but that state of the world is then immediately out of date.  I think what you're doing here is safe, but I find it hard to think through all the edge cases :-)\n",
        "createdAt" : "2016-10-27T21:58:02Z",
        "updatedAt" : "2016-10-28T16:25:23Z",
        "lastEditedBy" : "8fc8f958-3c0e-47dd-a0fb-b8cc483b4efb",
        "tags" : [
        ]
      },
      {
        "id" : "a2e51649-15be-4cb2-a1b4-4ce7cf701fbd",
        "parentId" : "9970ad9a-e40c-4f87-a01f-1774776a9b54",
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "This code is racy, like you said after doing `GetAttachedVolumesPerNode` state could immediately be stale (there could be pending operations that complete, or if sync takes long enough other operations could be started and complete in the meantime). That said, after speaking with @jingxu97 we think that should be ok, because in the worst case scenario, a volume is incorrectly reported as detached when it is actually attached, in which case the controller will try to reattach it--since the operation is idempotent, that should succeed. There shouldn't be any cases where a volume is detached, and falsely reported as attached due to this code.\n",
        "createdAt" : "2016-10-28T01:48:38Z",
        "updatedAt" : "2016-10-28T16:25:23Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      }
    ],
    "commit" : "abbde4337485d0286ab51bbebff54ff02eb33694",
    "line" : 105,
    "diffHunk" : "@@ -1,1 +553,557 @@\t\t\tfor spec, check := range attached {\n\t\t\t\tif !check {\n\t\t\t\t\tactualStateOfWorld.MarkVolumeAsDetached(volumeSpecMap[spec], nodeName)\n\t\t\t\t\tglog.V(1).Infof(\"VerifyVolumesAreAttached determined volume %q (spec.Name: %q) is no longer attached to node %q, therefore it was marked as detached.\",\n\t\t\t\t\t\tvolumeSpecMap[spec], spec.Name())"
  },
  {
    "id" : "bd9aea34-c7b9-4e6b-9b38-5d264c62826f",
    "prId" : 30737,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bb1ae527-a695-4987-a43b-bda8e4564e01",
        "parentId" : null,
        "authorId" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "body" : "By returning nil here, it can unblock DetachVolume in operation_executor. But from our current workflow, something is still not very clear to me. When reconciler tries to attach the volume through gce service, the following cases might happen\n1. If the volume is still attached by another node, attach will fail. \n2. If the node to which the volume is originally attached is removed from API server (by kubectl delete), attach failed at first but succeed eventually    because volume is detached after timeout (waiting for unmount status update). In this case verifySafeToDetach is set to false\n3. If the node to which the volume is originally attached is deleted (by gcloud command), attach will succeed? I am not quite sure in this situation verifySafeToDetach is set to true or false in reconciler.\n4. If the previous operation on the volume failed, it will block on backoff\n\nSo it is not clear to me that in the issue #29903, during node upgrading, if the old node is deleted, the following attach to the new node should succeed. Also from the kubelet log I checked, kubelet verifyVolumeAttached succeed because the volume is in the attached list of the new node, but failed on checking the devicePath before trying to mount volume. I am thinking there might be some race condition issue in the attachdetach controller\n\nSo I just want to make sure we cover all the cases.\n",
        "createdAt" : "2016-08-17T10:25:51Z",
        "updatedAt" : "2016-08-17T17:16:34Z",
        "lastEditedBy" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "tags" : [
        ]
      },
      {
        "id" : "814defb6-6d77-4ed1-a5e1-97ba0a3d204f",
        "parentId" : "bb1ae527-a695-4987-a43b-bda8e4564e01",
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "> By returning nil here, it can unblock DetachVolume in operation_executor. \n\nReturning nil will not block the operation_executor, returning an error will.\n\n> 1. If the volume is still attached by another node, attach will fail. \n\nCorrect.\n\n> 1. If the node to which the volume is originally attached is removed from API server (by kubectl delete), attach failed at first but succeed eventually because volume is detached after timeout (waiting for unmount status update). In this case verifySafeToDetach is set to false\n\nDetach from the original node would fail because of the bug this PR is fixing. After this PR, what you stated will be correct.\n\n> 1. If the node to which the volume is originally attached is deleted (by gcloud command), attach will succeed? I am not quite sure in this situation verifySafeToDetach is set to true or false in reconciler.\n\nYes, volume will be detached thanks to PR #29485, and be ok to reattach to another node.\n\n> 1. If the previous operation on the volume failed, it will block on backoff\n\nNot sure what you mean here.\n\n> So it is not clear to me that in the issue #29903, during node upgrading, if the old node is deleted, the following attach to the new node should succeed. Also from the kubelet log I checked, kubelet verifyVolumeAttached succeed because the volume is in the attached list of the new node, but failed on checking the devicePath before trying to mount volume. I am thinking there might be some race condition issue in the attachdetach controller\n\nThe issue was that when the cluster is updated the old machine is deleted/removed from API server. Then the master would 1) unable to correctly update the list of attached volumes and 2) not be able to detach the volume with the node obj missing from the API server. This PR fixes those bugs.\n",
        "createdAt" : "2016-08-17T18:03:54Z",
        "updatedAt" : "2016-08-17T18:03:54Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      }
    ],
    "commit" : "0c72568247a15545ae0df82412510713fdebe75f",
    "line" : 67,
    "diffHunk" : "@@ -1,1 +589,593 @@\t\t\t\tvolumeToDetach.VolumeName,\n\t\t\t\tvolumeToDetach.VolumeSpec.Name())\n\t\t\treturn nil\n\t\t}\n"
  },
  {
    "id" : "003cbb74-ccec-4502-bf1c-13e8485d263b",
    "prId" : 28714,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1065b7dd-cdc2-4a7c-b0d3-9935f37f9fd9",
        "parentId" : null,
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "Maybe we should skip this check if `DevicePath` is empty? Once @jingxu97 makes her restart robustness change to unmount stray directories, her code may call UnmountDevice without a `DevicePath`. I'll defer to her.\n",
        "createdAt" : "2016-07-14T06:19:07Z",
        "updatedAt" : "2016-07-18T23:20:15Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      }
    ],
    "commit" : "e13c678e3b04becd6131442e069f1d910241992d",
    "line" : 58,
    "diffHunk" : "@@ -1,1 +874,878 @@\t\t// use mounter.DeviceOpened to check if the device is in use anywhere\n\t\t// else on the system. Retry if it returns true.\n\t\tdeviceOpened, deviceOpenedErr := mounter.DeviceOpened(deviceToDetach.DevicePath)\n\t\tif deviceOpenedErr != nil {\n\t\t\treturn fmt.Errorf("
  },
  {
    "id" : "9107f449-ed3e-4c0b-bc1b-5d535c55e0e1",
    "prId" : 28095,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fe783a75-d6a8-4ff5-9ff1-fb1e2441e211",
        "parentId" : null,
        "authorId" : "395f4f9a-98be-4485-b436-51f0897d7c9f",
        "body" : "please add a note here that this can take upto 10s from pod creation\n",
        "createdAt" : "2016-06-27T22:03:16Z",
        "updatedAt" : "2016-06-28T21:06:20Z",
        "lastEditedBy" : "395f4f9a-98be-4485-b436-51f0897d7c9f",
        "tags" : [
        ]
      },
      {
        "id" : "e91808c1-933b-4fbd-8f92-a0b094a37239",
        "parentId" : "fe783a75-d6a8-4ff5-9ff1-fb1e2441e211",
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "Done.\n",
        "createdAt" : "2016-06-28T00:02:18Z",
        "updatedAt" : "2016-06-28T21:06:20Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      }
    ],
    "commit" : "e06b32b1ef4ac5919ea24c2e158f0ab6b3b5fe87",
    "line" : 93,
    "diffHunk" : "@@ -1,1 +911,915 @@\t\t}\n\n\t\tif !volumeToMount.ReportedInUse {\n\t\t\t// If the given volume has not yet been added to the list of\n\t\t\t// VolumesInUse in the node's volume status, do not proceed, return"
  },
  {
    "id" : "d0eedc35-a47b-40c9-8ec1-a50575287973",
    "prId" : 28095,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5ef8672e-1818-4178-89ec-eb16df12abaa",
        "parentId" : null,
        "authorId" : "395f4f9a-98be-4485-b436-51f0897d7c9f",
        "body" : "is there a log line we can look for to check if a volume was detached in the case where this flag is false (so the timeout case)? if not, how hard is it to surface?\n",
        "createdAt" : "2016-06-28T01:09:14Z",
        "updatedAt" : "2016-06-28T21:06:20Z",
        "lastEditedBy" : "395f4f9a-98be-4485-b436-51f0897d7c9f",
        "tags" : [
        ]
      },
      {
        "id" : "611f9628-afc1-41b8-bc04-ffd637d13d59",
        "parentId" : "5ef8672e-1818-4178-89ec-eb16df12abaa",
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "Not sure what you mean here.\n",
        "createdAt" : "2016-06-28T02:11:35Z",
        "updatedAt" : "2016-06-28T21:06:20Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      },
      {
        "id" : "c1270cc5-ee7a-47eb-833a-32b8d0efe819",
        "parentId" : "5ef8672e-1818-4178-89ec-eb16df12abaa",
        "authorId" : "395f4f9a-98be-4485-b436-51f0897d7c9f",
        "body" : "I mean when this function is invoked with verifySafeToDetach=false, and the thing is in fact reported as \"in use\" by a node (so get the node and check), but we're going to go ahead and detach anyway because of the false boolean\n",
        "createdAt" : "2016-06-28T02:43:58Z",
        "updatedAt" : "2016-06-28T21:06:20Z",
        "lastEditedBy" : "395f4f9a-98be-4485-b436-51f0897d7c9f",
        "tags" : [
        ]
      },
      {
        "id" : "9c8405e0-8671-4fa0-92e0-1f15da1c0af8",
        "parentId" : "5ef8672e-1818-4178-89ec-eb16df12abaa",
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "Ah, I see, yes, that is logged by the reconciler.\n",
        "createdAt" : "2016-06-28T02:47:17Z",
        "updatedAt" : "2016-06-28T21:06:20Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      }
    ],
    "commit" : "e06b32b1ef4ac5919ea24c2e158f0ab6b3b5fe87",
    "line" : 49,
    "diffHunk" : "@@ -1,1 +510,514 @@\treturn func() error {\n\t\tif verifySafeToDetach {\n\t\t\t// Fetch current node object\n\t\t\tnode, fetchErr := oe.kubeClient.Core().Nodes().Get(volumeToDetach.NodeName)\n\t\t\tif fetchErr != nil {"
  },
  {
    "id" : "6dc96ed3-3ece-4990-9153-5ef496479ba7",
    "prId" : 28095,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "93fb15b9-f079-4bd3-890b-bfa3bc33e15a",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "Should we add a TODO somewhere that we could force an immediate flush of our cache?\n",
        "createdAt" : "2016-06-28T02:34:57Z",
        "updatedAt" : "2016-06-28T21:06:20Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "6de37e02-273f-4ace-8f84-a99c72321dd1",
        "parentId" : "93fb15b9-f079-4bd3-890b-bfa3bc33e15a",
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "https://github.com/kubernetes/kubernetes/issues/28141 Added comment as well\n",
        "createdAt" : "2016-06-28T02:41:45Z",
        "updatedAt" : "2016-06-28T21:06:20Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      }
    ],
    "commit" : "e06b32b1ef4ac5919ea24c2e158f0ab6b3b5fe87",
    "line" : 94,
    "diffHunk" : "@@ -1,1 +912,916 @@\n\t\tif !volumeToMount.ReportedInUse {\n\t\t\t// If the given volume has not yet been added to the list of\n\t\t\t// VolumesInUse in the node's volume status, do not proceed, return\n\t\t\t// error. Caller will log and retry. The node status is updated"
  },
  {
    "id" : "07086246-3a8f-4f19-b75d-2c99258d79d1",
    "prId" : 27970,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8a9f94f6-6f52-436a-b903-8a8361bf70d8",
        "parentId" : null,
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "Let's remove this unless it is intentional?\n",
        "createdAt" : "2016-08-05T22:27:56Z",
        "updatedAt" : "2016-08-15T18:29:44Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      },
      {
        "id" : "954e6e7a-d427-403f-82d1-1a0e2b051658",
        "parentId" : "8a9f94f6-6f52-436a-b903-8a8361bf70d8",
        "authorId" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "body" : "Yes, I think this check is needed. During kubelet restart experiments, I have seen the system may in a state that reconcile tries to unmount device but there are still some mounting references exist for the device. This check will prevent unmount device before all the mounting references are cleaned up.\n",
        "createdAt" : "2016-08-10T00:16:46Z",
        "updatedAt" : "2016-08-15T18:29:44Z",
        "lastEditedBy" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "tags" : [
        ]
      },
      {
        "id" : "d1d5a2b8-4a6a-4e7b-b84e-7423f81560d9",
        "parentId" : "8a9f94f6-6f52-436a-b903-8a8361bf70d8",
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "That's interesting. Could you share an example of this? I'd like to understand what would cause it get in this state. I want to make sure we don't get stuck being able to unmount indefinitely.\n",
        "createdAt" : "2016-08-10T03:53:21Z",
        "updatedAt" : "2016-08-15T18:29:44Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      },
      {
        "id" : "c642bd80-04ea-4c2b-ba24-d44b317f6960",
        "parentId" : "8a9f94f6-6f52-436a-b903-8a8361bf70d8",
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "Ping on this.\n",
        "createdAt" : "2016-08-12T03:16:29Z",
        "updatedAt" : "2016-08-15T18:29:44Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      },
      {
        "id" : "8ea621e0-50bf-4437-a026-e9cdecd87b30",
        "parentId" : "8a9f94f6-6f52-436a-b903-8a8361bf70d8",
        "authorId" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "body" : "This may happen as follows\n1. create a set of pods through replication controller\n2. delete replication controller (and their associated pods) with grace-period=0 AND at the same time restart kubelet\n3. after kubelet restarts, some of the pods (but not all of them) still in api server, kubelet will receive those pods information and add them to desired state. Then reconciler will add them to actual state too.  (Now actual and desired states have some pods volumes info, but not all of them)\n4. Some pod DELETE requests come in, the reconciler will try to unmount volumes and then unmountdevice. This will cause that unmount device when not all of the volumes are unmounted yet\n",
        "createdAt" : "2016-08-12T16:41:30Z",
        "updatedAt" : "2016-08-15T18:29:44Z",
        "lastEditedBy" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "tags" : [
        ]
      },
      {
        "id" : "7fce65f6-bffa-42f3-9a6f-95cd7636ad80",
        "parentId" : "8a9f94f6-6f52-436a-b903-8a8361bf70d8",
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "Ack. SGTM\n",
        "createdAt" : "2016-08-12T17:37:52Z",
        "updatedAt" : "2016-08-15T18:29:44Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      }
    ],
    "commit" : "f19a1148db1b7584be6b6b60abaf8c0bd1503ed3",
    "line" : 52,
    "diffHunk" : "@@ -1,1 +892,896 @@\t\t\t\terr)\n\t\t}\n\t\trefs, err := attachableVolumePlugin.GetDeviceMountRefs(deviceMountPath)\n\t\tif err != nil || len(refs) > 0 {\n\t\t\tif err == nil {"
  },
  {
    "id" : "9f499450-d6c9-4484-9804-a3ad133a15f2",
    "prId" : 27778,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "73c5a828-2503-43c6-8320-96f0753f584e",
        "parentId" : null,
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "Could you add Events for the other operations as well (Unmount, MountDevice, UnmountDevice, etc.)?\n",
        "createdAt" : "2016-06-21T18:52:40Z",
        "updatedAt" : "2016-08-17T13:54:17Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      },
      {
        "id" : "2078c4f0-0342-4bda-92c3-b021842bb135",
        "parentId" : "73c5a828-2503-43c6-8320-96f0753f584e",
        "authorId" : "e15ef128-90ac-4a14-8795-b5be15e790ce",
        "body" : "@saad-ali  -  yep, will add that in if everything looks good with what I have so far...\n",
        "createdAt" : "2016-06-21T21:28:01Z",
        "updatedAt" : "2016-08-17T13:54:17Z",
        "lastEditedBy" : "e15ef128-90ac-4a14-8795-b5be15e790ce",
        "tags" : [
        ]
      }
    ],
    "commit" : "782d7d9815c18bcbf1272803c25027ebdad7995e",
    "line" : null,
    "diffHunk" : "@@ -1,1 +768,772 @@\n\t\t// Update actual state of world\n\t\tmarkVolMountedErr := actualStateOfWorld.MarkVolumeAsMounted(\n\t\t\tvolumeToMount.PodName,\n\t\t\tvolumeToMount.Pod.UID,"
  },
  {
    "id" : "c56d45ed-deff-44e3-9ae0-98bf8b2c9310",
    "prId" : 27778,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fe363992-0d07-4ace-a3ca-f3844dca0ef2",
        "parentId" : null,
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "Ditto. Did you intend to fire an event here?\n",
        "createdAt" : "2016-08-10T01:12:18Z",
        "updatedAt" : "2016-08-17T13:54:17Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      }
    ],
    "commit" : "782d7d9815c18bcbf1272803c25027ebdad7995e",
    "line" : null,
    "diffHunk" : "@@ -1,1 +829,833 @@\t\t\t\tvolumeToUnmount.PodName,\n\t\t\t\tvolumeToUnmount.PodUID,\n\t\t\t\tunmountErr)\n\t\t}\n"
  },
  {
    "id" : "5657803d-ce16-4ab3-b950-cb7967c265d4",
    "prId" : 27778,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "202bcdfb-d4b0-4fff-91ff-45fba7a33fdc",
        "parentId" : null,
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "+3. Did you intend to fire an event here?\n",
        "createdAt" : "2016-08-10T01:12:30Z",
        "updatedAt" : "2016-08-17T13:54:17Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      },
      {
        "id" : "21e765a2-bd4a-463b-b8cb-f5b8fbf0e155",
        "parentId" : "202bcdfb-d4b0-4fff-91ff-45fba7a33fdc",
        "authorId" : "e15ef128-90ac-4a14-8795-b5be15e790ce",
        "body" : "@saad-ali  - well, actually I didn't intend to fire events for the volume detach and unmount device and volume unmount for this round, I really wanted to just focus on the failed mounts only for now.  Do you think we need that for this PR or can we follow on with another PR as we see the need?  Also for those events, I'm not clear what runtime object I would pass in for the event, the only time I have a pod object is in the VolumeToMount. \n",
        "createdAt" : "2016-08-10T18:43:42Z",
        "updatedAt" : "2016-08-17T13:54:17Z",
        "lastEditedBy" : "e15ef128-90ac-4a14-8795-b5be15e790ce",
        "tags" : [
        ]
      },
      {
        "id" : "cded8261-0e13-4b80-b92f-861efdb33434",
        "parentId" : "202bcdfb-d4b0-4fff-91ff-45fba7a33fdc",
        "authorId" : "e15ef128-90ac-4a14-8795-b5be15e790ce",
        "body" : "@saad-ali - I did add the err variable just in case we use in the future for an event (if we so decide), would you prefer I revert that back to `return fmt.Errorf(...)`  for this PR?\n",
        "createdAt" : "2016-08-15T16:07:17Z",
        "updatedAt" : "2016-08-17T13:54:17Z",
        "lastEditedBy" : "e15ef128-90ac-4a14-8795-b5be15e790ce",
        "tags" : [
        ]
      }
    ],
    "commit" : "782d7d9815c18bcbf1272803c25027ebdad7995e",
    "line" : null,
    "diffHunk" : "@@ -1,1 +923,927 @@\t\t\t\tdeviceToDetach.VolumeName,\n\t\t\t\tdeviceToDetach.VolumeSpec.Name(),\n\t\t\t\tunmountDeviceErr)\n\t\t}\n\t\t// Before logging that UnmountDevice succeeded and moving on,"
  },
  {
    "id" : "3e4eafaf-5e23-4173-95ea-fecfd47cd399",
    "prId" : 27567,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8b18d318-1a96-4407-8ff2-0fa937dad90c",
        "parentId" : null,
        "authorId" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "body" : "what if addVolumeNodeErr is not nil, is it still considered as successfully attached?\n\n'\n",
        "createdAt" : "2016-06-20T23:37:04Z",
        "updatedAt" : "2016-06-21T01:20:41Z",
        "lastEditedBy" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "tags" : [
        ]
      },
      {
        "id" : "d55101a8-02d9-40c3-b783-77e43991820f",
        "parentId" : "8b18d318-1a96-4407-8ff2-0fa937dad90c",
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "Yes, attach completed successfully and we must log that. \n",
        "createdAt" : "2016-06-21T01:15:10Z",
        "updatedAt" : "2016-06-21T01:20:41Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      }
    ],
    "commit" : "e716ddc771be0b4314590ca924547ab74b2ff684",
    "line" : 391,
    "diffHunk" : "@@ -1,1 +891,895 @@\t\t\t\taddVolumeNodeErr := actualStateOfWorld.MarkVolumeAsAttached(\n\t\t\t\t\tvolumeToMount.VolumeSpec, nodeName, volumeToMount.DevicePath)\n\t\t\t\tglog.Infof(\"Controller successfully attached volume %q (spec.Name: %q) pod %q (UID: %q)\",\n\t\t\t\t\tvolumeToMount.VolumeName,\n\t\t\t\t\tvolumeToMount.VolumeSpec.Name(),"
  },
  {
    "id" : "759a1c15-3e82-4c55-a369-9d69518baa8c",
    "prId" : 27567,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "13bc325c-ba3a-494e-9f47-616494790d48",
        "parentId" : null,
        "authorId" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "body" : "Just want to make sure, this error will be returned as func() error, or the second error?\n'\n",
        "createdAt" : "2016-06-20T23:41:53Z",
        "updatedAt" : "2016-06-21T01:20:41Z",
        "lastEditedBy" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "tags" : [
        ]
      },
      {
        "id" : "f6a16915-f949-43bd-b4fa-1441c1c8a023",
        "parentId" : "13bc325c-ba3a-494e-9f47-616494790d48",
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "Returned as the error to `func() error`\n",
        "createdAt" : "2016-06-21T01:16:38Z",
        "updatedAt" : "2016-06-21T01:20:41Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      }
    ],
    "commit" : "e716ddc771be0b4314590ca924547ab74b2ff684",
    "line" : 353,
    "diffHunk" : "@@ -1,1 +853,857 @@\t\t\t\t// On failure, return error. Caller will log and retry.\n\t\t\t\treturn fmt.Errorf(\n\t\t\t\t\t\"VerifyControllerAttachedVolume.MarkVolumeAsAttached failed for volume %q (spec.Name: %q) pod %q (UID: %q) with: %v.\",\n\t\t\t\t\tvolumeToMount.VolumeName,\n\t\t\t\t\tvolumeToMount.VolumeSpec.Name(),"
  },
  {
    "id" : "31b9c876-9826-4889-966c-ab6fd286a98a",
    "prId" : 27567,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a95a494e-6e21-4ed3-aa8e-b017a932eeeb",
        "parentId" : null,
        "authorId" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "body" : "does it mean the second error always be returned as nil?\n",
        "createdAt" : "2016-06-20T23:42:19Z",
        "updatedAt" : "2016-06-21T01:20:41Z",
        "lastEditedBy" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "tags" : [
        ]
      },
      {
        "id" : "0fd29e28-8fc2-4de5-83a0-9dc50c2a3014",
        "parentId" : "a95a494e-6e21-4ed3-aa8e-b017a932eeeb",
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "In this case yes. If you look at the other `generate*` methods you'll see that this permits pre-processing before the method is created and an error to be returned in that case.\n",
        "createdAt" : "2016-06-21T01:18:58Z",
        "updatedAt" : "2016-06-21T01:20:41Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      }
    ],
    "commit" : "e716ddc771be0b4314590ca924547ab74b2ff684",
    "line" : 417,
    "diffHunk" : "@@ -1,1 +917,921 @@\t\t\tvolumeToMount.PodName,\n\t\t\tvolumeToMount.Pod.UID)\n\t}, nil\n}"
  },
  {
    "id" : "a3238e5a-9e87-48d2-8810-19e731a1ac23",
    "prId" : 26801,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f085cf9a-e0e4-4c1d-b5a7-1cde1f24140a",
        "parentId" : null,
        "authorId" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "body" : "Shouldn't `OuterVolumeSpecName` point to `myclaim` ?\n",
        "createdAt" : "2016-06-08T20:11:31Z",
        "updatedAt" : "2016-06-15T16:35:11Z",
        "lastEditedBy" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "tags" : [
        ]
      },
      {
        "id" : "4cdb41db-9364-49e6-a170-5bf004d99741",
        "parentId" : "f085cf9a-e0e4-4c1d-b5a7-1cde1f24140a",
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "No. `OuterVolumeSpecName` is `podSpec.Volume[x].Name` which in this case is `mypd`\n",
        "createdAt" : "2016-06-08T22:26:47Z",
        "updatedAt" : "2016-06-15T16:35:11Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      }
    ],
    "commit" : "cfab5362d43adced535b08659a061a8ebd21cc2a",
    "line" : 244,
    "diffHunk" : "@@ -1,1 +242,246 @@\t//           name: mypd\n\t//     volumes:\n\t//       - name: mypd\t\t\t\t<- OuterVolumeSpecName\n\t//         persistentVolumeClaim:\n\t//           claimName: myclaim"
  },
  {
    "id" : "c0ddcb18-bd39-497d-8944-7fb3f24b7a02",
    "prId" : 26801,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "93c752fd-423e-4ea2-af69-31b6a4b72e98",
        "parentId" : null,
        "authorId" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "body" : "to mount or unmount\n",
        "createdAt" : "2016-06-08T20:11:52Z",
        "updatedAt" : "2016-06-15T16:35:11Z",
        "lastEditedBy" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "tags" : [
        ]
      },
      {
        "id" : "348d76af-f49d-4652-ad1f-0051395fb0fb",
        "parentId" : "93c752fd-423e-4ea2-af69-31b6a4b72e98",
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "No, it's only for unmounts since mounts use the volumespec.\n",
        "createdAt" : "2016-06-08T22:29:03Z",
        "updatedAt" : "2016-06-15T16:35:11Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      }
    ],
    "commit" : "cfab5362d43adced535b08659a061a8ebd21cc2a",
    "line" : 268,
    "diffHunk" : "@@ -1,1 +266,270 @@\t// PluginName is the \"Unescaped Qualified\" name of the volume plugin used to\n\t// mount and unmount this volume. It can be used to fetch the volume plugin\n\t// to unmount with, on demand. It is also the name that plugins use, though\n\t// escaped, in their pod mount path, i.e.\n\t// /var/lib/kubelet/pods/{podUID}/volumes/{escapeQualifiedPluginName}/{outerVolumeSpecName}/"
  },
  {
    "id" : "ff152ddb-7420-4ae4-9146-bdbc7398c338",
    "prId" : 26801,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "cfc29582-7a76-41b5-9b3e-9e37b44201cc",
        "parentId" : null,
        "authorId" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "body" : "does this need to be thread safe via an internal mutex?\n",
        "createdAt" : "2016-06-08T20:12:46Z",
        "updatedAt" : "2016-06-15T16:35:11Z",
        "lastEditedBy" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "tags" : [
        ]
      },
      {
        "id" : "92821f8f-7068-4442-9d8a-eab0d022ea11",
        "parentId" : "cfc29582-7a76-41b5-9b3e-9e37b44201cc",
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "Nope. Both `volumePluginMgr` and `pendingOperations` are already thread-safe via internal mutex.\n",
        "createdAt" : "2016-06-08T22:31:29Z",
        "updatedAt" : "2016-06-15T16:35:11Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      }
    ],
    "commit" : "cfab5362d43adced535b08659a061a8ebd21cc2a",
    "line" : null,
    "diffHunk" : "@@ -1,1 +284,288 @@}\n\ntype operationExecutor struct {\n\t// volumePluginMgr is the volume plugin manager used to create volume\n\t// plugin objects."
  },
  {
    "id" : "104c04a7-cab9-465d-a513-5f56bb385bb7",
    "prId" : 26801,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "eaeee42f-ec2a-4bc5-ba8e-ccf61918bd63",
        "parentId" : null,
        "authorId" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "body" : "what is `MountVolume` supposed to be in this context?\n",
        "createdAt" : "2016-06-08T20:24:09Z",
        "updatedAt" : "2016-06-15T16:35:11Z",
        "lastEditedBy" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "tags" : [
        ]
      },
      {
        "id" : "e01adb2b-16bb-4162-978b-99e97cf71dd5",
        "parentId" : "eaeee42f-ec2a-4bc5-ba8e-ccf61918bd63",
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "`MountVolume` is the wrapper call. It results in `WaitForAttach()`, `MountDevice()`, and `Setup()`\n",
        "createdAt" : "2016-06-08T22:36:11Z",
        "updatedAt" : "2016-06-15T16:35:11Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      }
    ],
    "commit" : "cfab5362d43adced535b08659a061a8ebd21cc2a",
    "line" : 549,
    "diffHunk" : "@@ -1,1 +547,551 @@\t\t\tif err != nil {\n\t\t\t\tglog.Errorf(\n\t\t\t\t\t\"MountVolume.WaitForAttach failed for volume %q (spec.Name: %q) pod %q (UID: %q) with: %v\",\n\t\t\t\t\tvolumeToMount.VolumeName,\n\t\t\t\t\tvolumeToMount.VolumeSpec.Name(),"
  },
  {
    "id" : "e57e8f0f-cc8f-4723-aa56-be5ba915144d",
    "prId" : 26801,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "47f0aaf3-ec24-4ae8-a2d7-ee9fee73932f",
        "parentId" : null,
        "authorId" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "body" : "What happens if there's an error marking the volume as mounted?  will it be re-mounted?\n",
        "createdAt" : "2016-06-08T20:25:12Z",
        "updatedAt" : "2016-06-15T16:35:11Z",
        "lastEditedBy" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "tags" : [
        ]
      },
      {
        "id" : "9a2cdd05-89d1-45cd-a01d-376767b0d7cf",
        "parentId" : "47f0aaf3-ec24-4ae8-a2d7-ee9fee73932f",
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "Yes, `MountVolume` will be called again by the reconciler so `WaitForAttach()`, `MountDevice()`, and `Setup()` will all be re-executed, but they should be idempotent so that shouldn't be a problem.\n",
        "createdAt" : "2016-06-08T22:40:06Z",
        "updatedAt" : "2016-06-15T16:35:11Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      }
    ],
    "commit" : "cfab5362d43adced535b08659a061a8ebd21cc2a",
    "line" : null,
    "diffHunk" : "@@ -1,1 +644,648 @@\t\t\tvolumeToMount.OuterVolumeSpecName,\n\t\t\tvolumeToMount.VolumeGidValue)\n\t\tif markVolMountedErr != nil {\n\t\t\t// On failure, just log and exit. The controller will retry\n\t\t\tglog.Errorf("
  },
  {
    "id" : "b76e831b-e1e0-4541-b3ea-8c5e10c14006",
    "prId" : 26801,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1b9fdcb6-e28c-47bd-82bc-ead06794cc54",
        "parentId" : null,
        "authorId" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "body" : "it's not clear to me why this only happens if the the attacher isn't nil -- don't we need to track this for all plugins, regardless of whether they're attachable or not?\n",
        "createdAt" : "2016-06-08T20:33:42Z",
        "updatedAt" : "2016-06-15T16:35:11Z",
        "lastEditedBy" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "tags" : [
        ]
      },
      {
        "id" : "c487b01c-5771-49c7-ad3a-db3f4365907d",
        "parentId" : "1b9fdcb6-e28c-47bd-82bc-ead06794cc54",
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "`MountDevice()` is a method of the `Attacher` interface. \"Non-attacher\" plugins get mounted by `volumeMounter.SetUp()`. Arguably, `Attacher.MountDevice` could be eliminated and `SetUp()` could take on the responsibility of mounting the device and bind mounting it to the pods. But we can consider that outside of this PR. \n",
        "createdAt" : "2016-06-08T23:28:30Z",
        "updatedAt" : "2016-06-15T16:35:11Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      }
    ],
    "commit" : "cfab5362d43adced535b08659a061a8ebd21cc2a",
    "line" : null,
    "diffHunk" : "@@ -1,1 +600,604 @@\n\t\t\t// Update actual state of world to reflect volume is globally mounted\n\t\t\tmarkDeviceMountedErr := actualStateOfWorld.MarkDeviceAsMounted(\n\t\t\t\tvolumeToMount.VolumeName)\n\t\t\tif markDeviceMountedErr != nil {"
  },
  {
    "id" : "1ce038b4-f224-4079-a668-1e816c07712d",
    "prId" : 26801,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8d7ed1c4-9a7c-45b9-b6fb-641db3c49ea3",
        "parentId" : null,
        "authorId" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "body" : "dead line\n",
        "createdAt" : "2016-06-08T21:46:19Z",
        "updatedAt" : "2016-06-15T16:35:11Z",
        "lastEditedBy" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "tags" : [
        ]
      },
      {
        "id" : "e7fa3f80-6d72-4486-bd92-cc335f4c89be",
        "parentId" : "8d7ed1c4-9a7c-45b9-b6fb-641db3c49ea3",
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "Removed.\n",
        "createdAt" : "2016-06-08T23:29:30Z",
        "updatedAt" : "2016-06-15T16:35:11Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      }
    ],
    "commit" : "cfab5362d43adced535b08659a061a8ebd21cc2a",
    "line" : null,
    "diffHunk" : "@@ -1,1 +772,776 @@\t\t\treturn err\n\t\t}\n\n\t\t// Execute unmount\n\t\tunmountDeviceErr := volumeDetacher.UnmountDevice(deviceMountPath)"
  },
  {
    "id" : "693ef89a-c23f-490f-9b7e-3a1202b05982",
    "prId" : 26801,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f6fbe2b1-2bed-43d9-938f-29d8d253fe43",
        "parentId" : null,
        "authorId" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "body" : "for all of these funcs i think a comment would be ehlpful describing the flow of the transaction script (these all implement transaction-script-like behaviors)\n",
        "createdAt" : "2016-06-08T21:46:51Z",
        "updatedAt" : "2016-06-15T16:35:11Z",
        "lastEditedBy" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "tags" : [
        ]
      },
      {
        "id" : "191d9667-ecf1-41a6-a6bf-e5d508596ff3",
        "parentId" : "f6fbe2b1-2bed-43d9-938f-29d8d253fe43",
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "Added more detailed comments to the Interface methods describing what each method does.\n",
        "createdAt" : "2016-06-09T00:30:00Z",
        "updatedAt" : "2016-06-15T16:35:11Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      }
    ],
    "commit" : "cfab5362d43adced535b08659a061a8ebd21cc2a",
    "line" : 743,
    "diffHunk" : "@@ -1,1 +759,763 @@\t\t\terr)\n\t}\n\n\treturn func() error {\n\t\tdeviceMountPath, err :="
  }
]
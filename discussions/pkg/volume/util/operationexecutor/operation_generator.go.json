[
  {
    "id" : "1556249d-7f8e-43a0-95c0-1f92fe434ccf",
    "prId" : 102028,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/102028#pullrequestreview-682264088",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d3de14d3-8de6-4f40-b516-9561803adb6d",
        "parentId" : null,
        "authorId" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "body" : "Just to confirm, if the feature gate is disabled and a PVC has `[ReadWriteOncePod]` from the time when the feature gate was enabled, the volume gets mounted without any access mode checks, just as like `ReadWriteOnce`, right?",
        "createdAt" : "2021-06-11T15:54:06Z",
        "updatedAt" : "2021-06-11T16:02:21Z",
        "lastEditedBy" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "tags" : [
        ]
      },
      {
        "id" : "badc1d7d-60a9-4c66-9659-ec645b0f8c04",
        "parentId" : "d3de14d3-8de6-4f40-b516-9561803adb6d",
        "authorId" : "ffc1d568-c5ed-4932-82f4-3ae9d3bee69a",
        "body" : "Correct",
        "createdAt" : "2021-06-11T23:14:00Z",
        "updatedAt" : "2021-06-11T23:14:00Z",
        "lastEditedBy" : "ffc1d568-c5ed-4932-82f4-3ae9d3bee69a",
        "tags" : [
        ]
      }
    ],
    "commit" : "b7d732d3d6f0f41f2962c674d8cccd92bf5845a9",
    "line" : 19,
    "diffHunk" : "@@ -1,1 +545,549 @@\n\t\t// Enforce ReadWriteOncePod access mode if it is the only one present. This is also enforced during scheduling.\n\t\tif utilfeature.DefaultFeatureGate.Enabled(features.ReadWriteOncePod) &&\n\t\t\tactualStateOfWorld.IsVolumeMountedElsewhere(volumeToMount.VolumeName, volumeToMount.PodName) &&\n\t\t\t// Because we do not know what access mode the pod intends to use if there are multiple."
  },
  {
    "id" : "2b8b7580-984c-4a34-aa68-cce612607c14",
    "prId" : 100567,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/100567#pullrequestreview-680022614",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "23316de3-5497-43fa-b507-53754eef026a",
        "parentId" : null,
        "authorId" : "5d64207d-3933-4932-8517-aace5b6574c0",
        "body" : "Why are we calling MarkVolumeMountAsUncertain here, but in the CustomBlockMapper case above, we markVolumeErrorState? Should't we be consistent in the two cases?",
        "createdAt" : "2021-04-13T01:31:17Z",
        "updatedAt" : "2021-04-13T01:31:17Z",
        "lastEditedBy" : "5d64207d-3933-4932-8517-aace5b6574c0",
        "tags" : [
        ]
      },
      {
        "id" : "93f91640-a8dd-4b12-95b2-4bb1e1dc97e9",
        "parentId" : "23316de3-5497-43fa-b507-53754eef026a",
        "authorId" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "body" : "I think it is mostly fine because `Setup` functions for CSI driver has been changed to return appropriate errors if operation finished with a final error or in-progress-uncertain error. So `makeVolumeErrorState` can take all of that into account.\r\n\r\nVolume expansion operation functions only return final errors and hence can't use `markVolumeErrorState` function. ",
        "createdAt" : "2021-06-09T18:42:08Z",
        "updatedAt" : "2021-06-09T18:42:08Z",
        "lastEditedBy" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "tags" : [
        ]
      }
    ],
    "commit" : "0fa01c371c9d1ef9530db06444229a007c3c8fdc",
    "line" : 32,
    "diffHunk" : "@@ -1,1 +1185,1189 @@\t\t\t// Considering the above situations, we mark volume as uncertain here so that reconciler will tigger\n\t\t\t// volume tear down when pod is deleted, and also makes sure pod will not start using it.\n\t\t\tif err := actualStateOfWorld.MarkVolumeMountAsUncertain(markVolumeOpts); err != nil {\n\t\t\t\tklog.Errorf(volumeToMount.GenerateErrorDetailed(\"MountVolume.MarkVolumeMountAsUncertain failed\", err).Error())\n\t\t\t}"
  },
  {
    "id" : "2fdd9bd3-a64d-4bc7-a33d-763eb2eb2faf",
    "prId" : 100183,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/100183#pullrequestreview-677527576",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "79f9fb87-24f7-4162-b89e-e1ba994b6829",
        "parentId" : null,
        "authorId" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "body" : "I see that we are marking device as uncertain even before unstage operation has started. This means that if `TearDownDevice` fails for a reason that is final (i.e which tells us unstage never really started) - then volume will still be treated as uncertain and hence a full stage has to be performed to make the volume usable again. \r\n\r\nThis seems very different from how we handled uncertain devices/volumes in other places.",
        "createdAt" : "2021-03-25T18:17:46Z",
        "updatedAt" : "2021-03-25T18:17:47Z",
        "lastEditedBy" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "tags" : [
        ]
      },
      {
        "id" : "76e14c86-4b31-439e-bca5-a99509a48385",
        "parentId" : "79f9fb87-24f7-4162-b89e-e1ba994b6829",
        "authorId" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "body" : "another way is perform teardown first. In case of error returned, mark it as uncertain. In case of no error, mark it as unmounted.",
        "createdAt" : "2021-03-25T19:31:40Z",
        "updatedAt" : "2021-03-25T19:31:40Z",
        "lastEditedBy" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "tags" : [
        ]
      },
      {
        "id" : "5093bfbb-8531-413d-ba1c-5c0d65f738dd",
        "parentId" : "79f9fb87-24f7-4162-b89e-e1ba994b6829",
        "authorId" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "body" : "I pointed out in the description of the PR, IMO it's not safe to assume that a mount is usable even after UnmountVolume / UnmountDevice final error. Better to call SetUp / MountDevice again when the mount is needed. It is a corner case already and one extra MountDevice / SetUp won't harm, especially if it's idempotent.\r\n\r\nI am marking the volume as uncertain at the beginning, because unmapping the volume is a long process - see below - and it makes the error handling much easier.",
        "createdAt" : "2021-04-14T14:50:38Z",
        "updatedAt" : "2021-04-14T14:50:39Z",
        "lastEditedBy" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "tags" : [
        ]
      },
      {
        "id" : "8f66e580-94de-4aed-b1ac-8cc56d535606",
        "parentId" : "79f9fb87-24f7-4162-b89e-e1ba994b6829",
        "authorId" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "body" : "I think my main concern is - other intree volume types do not benefit from being added to ASOW in uncertain state. Ideally all of `MountDevice` calls should be idempotent and hopefully nothing would break but it is somewhat of risky behaviour change and I am not sure if we have e2es that verify stuff like this. \r\n\r\nMay be it is fine or may be - we will see some regressions. \r\n",
        "createdAt" : "2021-06-03T14:11:18Z",
        "updatedAt" : "2021-06-03T14:11:44Z",
        "lastEditedBy" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "tags" : [
        ]
      },
      {
        "id" : "a3e6a9c7-ca38-4ce7-882e-13d6ad086750",
        "parentId" : "79f9fb87-24f7-4162-b89e-e1ba994b6829",
        "authorId" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "body" : "If any of the operation below fails (like `isDeviceOpened` check), the volume is still marked as mounted, while e.g. iscsi or FC volumes were already detached in `TearDownDevice`.  Therefore kubelet should mark it as uncertain. It is not related to CSI.",
        "createdAt" : "2021-06-07T14:59:59Z",
        "updatedAt" : "2021-06-07T14:59:59Z",
        "lastEditedBy" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "tags" : [
        ]
      }
    ],
    "commit" : "d5da73032f7882afe180af77a5fcc8f441d36807",
    "line" : 77,
    "diffHunk" : "@@ -1,1 +1362,1366 @@\t\t\treturn volumetypes.NewOperationContext(eventErr, detailedErr, migrated)\n\t\t}\n\n\t\t// Call TearDownDevice if blockVolumeUnmapper implements CustomBlockVolumeUnmapper\n\t\tif customBlockVolumeUnmapper, ok := blockVolumeUnmapper.(volume.CustomBlockVolumeUnmapper); ok {"
  },
  {
    "id" : "e3501c6c-b8c2-466c-a730-f1c26fe1640c",
    "prId" : 100183,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/100183#pullrequestreview-675577262",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "578bf60e-614b-4e97-8fe0-32664f58330b",
        "parentId" : null,
        "authorId" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "body" : "I think this could mean - if a pod running on a node has one or more of volume failing to unmount, then pod can still be deleted because volume is being marked as `uncertain` and hence `GetMountedVolumesForPod` won't find uncertain volumes? ",
        "createdAt" : "2021-03-25T18:30:39Z",
        "updatedAt" : "2021-03-25T18:30:39Z",
        "lastEditedBy" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "tags" : [
        ]
      },
      {
        "id" : "4f1e80e0-2a40-4bab-b24d-9e1838ca8aa9",
        "parentId" : "578bf60e-614b-4e97-8fe0-32664f58330b",
        "authorId" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "body" : "good point!\r\n\r\nIn current logic, pod will not be deleted though. GetMountedVolumesForPod will not find uncertain volumes, but it also check volumepaths from disk directly by calling getMountedVolumePathListFromDisk.\r\n\r\nNow thinking this, for pod deletion, I am thinking a safer approach for GetMountedVolumesForPod should include uncertain state..?",
        "createdAt" : "2021-03-25T19:29:57Z",
        "updatedAt" : "2021-03-25T19:29:57Z",
        "lastEditedBy" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "tags" : [
        ]
      },
      {
        "id" : "010db77e-9190-482b-a592-fc50a20c1cf8",
        "parentId" : "578bf60e-614b-4e97-8fe0-32664f58330b",
        "authorId" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "body" : "> n current logic, pod will not be deleted though. GetMountedVolumesForPod will not find uncertain volumes, but it also check volumepaths from disk directly by calling getMountedVolumePathListFromDisk.\r\n\r\nyeah I don't trust `getMountedVolumePathListFromDisk` completely. Also, what happens if driver created no mount points but `unpublish` still failed? ",
        "createdAt" : "2021-03-25T19:40:03Z",
        "updatedAt" : "2021-03-25T19:40:03Z",
        "lastEditedBy" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "tags" : [
        ]
      },
      {
        "id" : "0236265f-8598-4811-af44-409ddb343955",
        "parentId" : "578bf60e-614b-4e97-8fe0-32664f58330b",
        "authorId" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "body" : "Adding uncertain volumes to `GetMountedVolumesForPod` will run stats on them and could start pods. This needs to be smarter, perhaps extending only `podVolumesExist` to uncertain volumes.",
        "createdAt" : "2021-04-14T15:02:03Z",
        "updatedAt" : "2021-04-14T15:02:04Z",
        "lastEditedBy" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "tags" : [
        ]
      },
      {
        "id" : "95e3e250-ef49-4dcf-ad96-74d63a3b5a19",
        "parentId" : "578bf60e-614b-4e97-8fe0-32664f58330b",
        "authorId" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "body" : "I am trying to remember - in which cases we don't want an uncertain volume to be added in  `GetMountedVolumesForPod`? This would potentially prevent a pod from being deleted in some cases - but may be that is a good thing?",
        "createdAt" : "2021-05-27T18:32:20Z",
        "updatedAt" : "2021-05-27T18:32:21Z",
        "lastEditedBy" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "tags" : [
        ]
      },
      {
        "id" : "97a5b48d-515c-4cc9-b393-ad3bca4897ea",
        "parentId" : "578bf60e-614b-4e97-8fe0-32664f58330b",
        "authorId" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "body" : "When kubelet waits for all volumes to be mounted, it calls `verifyVolumesMountedFunc`, which calls `volumemanager.getUnmountedVolumes()`, which then calls  `GetMountedVolumesForPod`. If uncertain volumes are returned from `GetMountedVolumesForPod`, kubelet will interpret it as the volumes are mounted and it will start the pod.\r\n\r\n",
        "createdAt" : "2021-06-01T09:08:10Z",
        "updatedAt" : "2021-06-01T09:08:10Z",
        "lastEditedBy" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "tags" : [
        ]
      },
      {
        "id" : "df6a4e1a-387c-4c01-b0b1-9b4be1efc9be",
        "parentId" : "578bf60e-614b-4e97-8fe0-32664f58330b",
        "authorId" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "body" : "we could have separate logic in these cases.\r\n1. During pod start, when checking whether all volumes are already mounted, this check should not include uncertain volumes\r\n2. During pod deletion, when checking whether volumes are unmounted, it should include uncertain volumes. ",
        "createdAt" : "2021-06-01T16:08:34Z",
        "updatedAt" : "2021-06-01T16:08:34Z",
        "lastEditedBy" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "tags" : [
        ]
      },
      {
        "id" : "fd4daa81-fa37-4c3f-b8d6-647b89c171c9",
        "parentId" : "578bf60e-614b-4e97-8fe0-32664f58330b",
        "authorId" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "body" : "Yes I think that may work. I am thinking we should leave `GetMountedVolumesForPod` alone because it is also called from other places but may be introduce another function which would include uncertain and mounted volumes before allowing pod deletion.\r\n",
        "createdAt" : "2021-06-02T14:50:14Z",
        "updatedAt" : "2021-06-02T14:50:14Z",
        "lastEditedBy" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "tags" : [
        ]
      },
      {
        "id" : "e06a2e0e-4683-4893-bdd9-4523c849dd43",
        "parentId" : "578bf60e-614b-4e97-8fe0-32664f58330b",
        "authorId" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "body" : "/lgtm cancel\r\nThis needs to be reworked as suggested above.",
        "createdAt" : "2021-06-03T12:19:13Z",
        "updatedAt" : "2021-06-03T12:19:13Z",
        "lastEditedBy" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "tags" : [
        ]
      },
      {
        "id" : "a06c2f76-3158-4c3b-a78a-8c1154bb2ea3",
        "parentId" : "578bf60e-614b-4e97-8fe0-32664f58330b",
        "authorId" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "body" : "I added `GetPossiblyMountedVolumesForPod` for the case when `podVolumesExist` needs to know when all volumes were really unmounted (and are not uncertain).\r\n@gnufied @jingxu97, PTAL",
        "createdAt" : "2021-06-03T17:52:54Z",
        "updatedAt" : "2021-06-03T17:52:54Z",
        "lastEditedBy" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "tags" : [
        ]
      }
    ],
    "commit" : "d5da73032f7882afe180af77a5fcc8f441d36807",
    "line" : 54,
    "diffHunk" : "@@ -1,1 +1245,1249 @@\t\t}\n\t\tmarkVolumeUncertainErr := actualStateOfWorld.MarkVolumeMountAsUncertain(markVolumeOpts)\n\t\tif markVolumeUncertainErr != nil {\n\t\t\t// On failure, return error. Caller will log and retry.\n\t\t\teventErr, detailedErr := volumeToUnmount.GenerateError(\"UnmapVolume.MarkDeviceAsUncertain failed\", markVolumeUncertainErr)"
  },
  {
    "id" : "042a4fea-9e4d-467e-b8fb-a35e0605e6c1",
    "prId" : 99326,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/99326#pullrequestreview-635985310",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "282cedb5-b76e-4052-ab72-263a7e7a7a5b",
        "parentId" : null,
        "authorId" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "body" : "Is there a race here? Should the annotation be added before marking for fsresize?",
        "createdAt" : "2021-04-14T04:57:22Z",
        "updatedAt" : "2021-04-14T05:00:13Z",
        "lastEditedBy" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "tags" : [
        ]
      },
      {
        "id" : "1e647a54-2feb-467b-b38b-a6084eddf546",
        "parentId" : "282cedb5-b76e-4052-ab72-263a7e7a7a5b",
        "authorId" : "c4121125-5aca-4c2b-a2a2-5aabaa95ec29",
        "body" : "I can't think of scenarios where there can be a race from top of my head. Could you point to when race could happen?",
        "createdAt" : "2021-04-14T19:01:37Z",
        "updatedAt" : "2021-04-14T19:01:37Z",
        "lastEditedBy" : "c4121125-5aca-4c2b-a2a2-5aabaa95ec29",
        "tags" : [
        ]
      }
    ],
    "commit" : "5f69cf74d836ef08c3a340b7d0b48c4a463a3258",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +1553,1557 @@\t\t\t}\n\t\t\toldCapacity := pvc.Status.Capacity[v1.ResourceStorage]\n\t\t\terr = util.AddAnnPreResizeCapacity(pv, oldCapacity, og.kubeClient)\n\t\t\tif err != nil {\n\t\t\t\tdetailedErr := fmt.Errorf(\"error updating pv %s annotation (%s) with pre-resize capacity %s: %v\", pv.ObjectMeta.Name, util.AnnPreResizeCapacity, oldCapacity.String(), err)"
  },
  {
    "id" : "819c6624-b810-4268-a269-00873365e3b6",
    "prId" : 99050,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/99050#pullrequestreview-591691354",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "56ac2d15-81bc-4957-a586-2e11e2feeadb",
        "parentId" : null,
        "authorId" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "body" : "Do we actually do translation for the verify operations?",
        "createdAt" : "2021-02-16T17:45:25Z",
        "updatedAt" : "2021-02-16T17:54:24Z",
        "lastEditedBy" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "tags" : [
        ]
      },
      {
        "id" : "3a6f7cde-b5e2-4cf4-83e5-98681913e7e6",
        "parentId" : "56ac2d15-81bc-4957-a586-2e11e2feeadb",
        "authorId" : "d10fef96-5a18-44e7-b23e-735de7561af7",
        "body" : "We do translation when generate the VolumeSpec. So it does not matter if it is verify operation.\r\n\r\nverify is a bulk operation thus is difficult to differentiate. It will check attachedVolumes(which is a collection of VolumeSpec), and these VolumeSpecs, it can be partial CSI migrated specs and some real CSI specs. So we cannot tell the difference. ",
        "createdAt" : "2021-02-16T22:48:34Z",
        "updatedAt" : "2021-02-16T23:51:07Z",
        "lastEditedBy" : "d10fef96-5a18-44e7-b23e-735de7561af7",
        "tags" : [
        ]
      }
    ],
    "commit" : "9ec820a91af7e0857d7b613855eb64588cf7885d",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +228,232 @@\t\t}\n\n\t\t// It is hard to differentiate migrated status for all volumes for verify_volumes_are_attached_per_node\n\t\treturn volumetypes.NewOperationContext(nil, nil, false)\n\t}"
  },
  {
    "id" : "9d6b8b2f-a900-4748-aeeb-bb708a1ab2c3",
    "prId" : 93710,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/93710#pullrequestreview-462107136",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "54dca651-ff37-4024-b27e-5beba065b5eb",
        "parentId" : null,
        "authorId" : "d10fef96-5a18-44e7-b23e-735de7561af7",
        "body" : "@saad-ali I thought it through and I think we don't actually need any other check(e.g. inline check) in the CanAttach() function because we are expecting to get a attachableVolumePlugin from the return. The CanAttach() should never return false to the caller.\r\n\r\nThat said, in this case, as long as it is a CSI plugin, it should be detachable no matter it is attachable or not. Please correct me if I am wrong.",
        "createdAt" : "2020-08-05T06:33:15Z",
        "updatedAt" : "2020-08-25T00:15:34Z",
        "lastEditedBy" : "d10fef96-5a18-44e7-b23e-735de7561af7",
        "tags" : [
        ]
      },
      {
        "id" : "0779f10b-e8bf-4e29-9851-22dc51bb6ee3",
        "parentId" : "54dca651-ff37-4024-b27e-5beba065b5eb",
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "For CSI volume that are Ephemeral volume should not be attachable and therefore should not be detachable (which is checked by `CanAttach()`.\r\n\r\nThat said, if the proper checks happen on the attach side, detach may be less strict. So this should be fine though it makes me a little nervous.\r\n\r\n",
        "createdAt" : "2020-08-06T00:49:40Z",
        "updatedAt" : "2020-08-25T00:15:34Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      }
    ],
    "commit" : "a6d8e6c5c2e5e25a0dd6a003497519a226128161",
    "line" : 37,
    "diffHunk" : "@@ -1,1 +1742,1746 @@\t}\n\tif attachableVolumePlugin, ok := volumePlugin.(volume.AttachableVolumePlugin); ok {\n\t\tif attachableVolumePlugin.GetPluginName() == \"kubernetes.io/csi\" {\n\t\t\treturn attachableVolumePlugin, nil\n\t\t}"
  },
  {
    "id" : "cdced65b-8070-4d52-a8d4-7cc7e5711331",
    "prId" : 93710,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/93710#pullrequestreview-462234274",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "89291672-26cc-4737-959c-828d215f1f8d",
        "parentId" : null,
        "authorId" : "d10fef96-5a18-44e7-b23e-735de7561af7",
        "body" : "I dont understand why we are not passing the VolumeName instead create an empty name here. This prevents us from marking an unattachable volume as `Uncertain`. I did some manual tests locally and find change it this way causes no problem. Please let me know if there is some special reason behind the empty name.",
        "createdAt" : "2020-08-05T06:35:34Z",
        "updatedAt" : "2020-08-25T00:15:34Z",
        "lastEditedBy" : "d10fef96-5a18-44e7-b23e-735de7561af7",
        "tags" : [
        ]
      },
      {
        "id" : "a995b2d2-317c-464b-9be6-9f766ecd46fc",
        "parentId" : "89291672-26cc-4737-959c-828d215f1f8d",
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "@jingxu97 can you recall why this was empty?",
        "createdAt" : "2020-08-06T00:53:40Z",
        "updatedAt" : "2020-08-25T00:15:34Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      },
      {
        "id" : "72c1c5ad-9fa5-4152-8e9e-2791f42f6793",
        "parentId" : "89291672-26cc-4737-959c-828d215f1f8d",
        "authorId" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "body" : "I dig some old code, and think it might be historical reason. Before, MarkVolumeAsAttached has no uniqueVolumeName parameter. It only passes volume spec and use spec to find out the unique name. Later we added this parameter to fix some issue. It seems like we just continue to use volume spec to find out the volume name instead of passing it directly. \r\nSo far I don't see an issue directly setting it to volume name. ",
        "createdAt" : "2020-08-06T06:43:24Z",
        "updatedAt" : "2020-08-25T00:15:34Z",
        "lastEditedBy" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "tags" : [
        ]
      },
      {
        "id" : "51cc63b8-3ba8-42a2-9698-8a9fc525a9b2",
        "parentId" : "89291672-26cc-4737-959c-828d215f1f8d",
        "authorId" : "d10fef96-5a18-44e7-b23e-735de7561af7",
        "body" : "If that's the case, It should be safe to use the volumeName directly. Let's see the results of all e2e tests and unit tests to see if that changes the statement.",
        "createdAt" : "2020-08-07T05:26:32Z",
        "updatedAt" : "2020-08-25T00:15:34Z",
        "lastEditedBy" : "d10fef96-5a18-44e7-b23e-735de7561af7",
        "tags" : [
        ]
      }
    ],
    "commit" : "a6d8e6c5c2e5e25a0dd6a003497519a226128161",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +343,347 @@\t\t\t}\n\t\t\taddErr := actualStateOfWorld.MarkVolumeAsUncertain(\n\t\t\t\tvolumeToAttach.VolumeName,\n\t\t\t\tvolumeToAttach.VolumeSpec,\n\t\t\t\tuncertainNode)"
  },
  {
    "id" : "151ca73d-dca0-409f-b56e-2a78f7d8a989",
    "prId" : 93710,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/93710#pullrequestreview-462234274",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "dd3131e6-be9a-489b-8b70-49a1ff9d30b9",
        "parentId" : null,
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "Consider putting this in the same file as the other similar functions (e.g. `FindAttachablePluginByName`).",
        "createdAt" : "2020-08-06T00:53:14Z",
        "updatedAt" : "2020-08-25T00:15:34Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      },
      {
        "id" : "5f06561f-5ed3-4309-aefd-44ad43ec2558",
        "parentId" : "dd3131e6-be9a-489b-8b70-49a1ff9d30b9",
        "authorId" : "d10fef96-5a18-44e7-b23e-735de7561af7",
        "body" : "As we have discussed offline, to be safe that this function is only called by the GenerateDetachVolumeFunc() func, let's keep this function private and not used by other callers.",
        "createdAt" : "2020-08-06T21:50:01Z",
        "updatedAt" : "2020-08-25T00:15:34Z",
        "lastEditedBy" : "d10fef96-5a18-44e7-b23e-735de7561af7",
        "tags" : [
        ]
      }
    ],
    "commit" : "a6d8e6c5c2e5e25a0dd6a003497519a226128161",
    "line" : 31,
    "diffHunk" : "@@ -1,1 +1736,1740 @@// The intention here is that a CSI plugin volume can end up in an Uncertain state,  so that a detach\n// operation will help it to detach no matter it actually has the ability to attach/detach.\nfunc findDetachablePluginBySpec(spec *volume.Spec, pm *volume.VolumePluginMgr) (volume.AttachableVolumePlugin, error) {\n\tvolumePlugin, err := pm.FindPluginBySpec(spec)\n\tif err != nil {"
  },
  {
    "id" : "5cbd7b29-ec42-4f08-91e4-f5d93b2440e2",
    "prId" : 93710,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/93710#pullrequestreview-462140858",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "92e3ff18-df61-4874-80f8-b10e11f39a98",
        "parentId" : null,
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "How did you address the race we discussed? CSIDriver object is created (with `skipattach`) during first attach attempt, so uncertain state fails to set.",
        "createdAt" : "2020-08-06T01:00:21Z",
        "updatedAt" : "2020-08-25T00:15:34Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      },
      {
        "id" : "c15ab3c7-d073-4e66-a0e5-8b388eaf5ee1",
        "parentId" : "92e3ff18-df61-4874-80f8-b10e11f39a98",
        "authorId" : "d10fef96-5a18-44e7-b23e-735de7561af7",
        "body" : "This is a very interesting point. In fact, if we pass the volumeName to the MarkVolumeAsUncertain() function, the markasuncertain operation will not fail. So in that case, the race will not exist because MarkVolumeAsUncertain will always be able to happen no matter when do we deploy the CSIDriver. That's why I am curious about why we are giving an empty volumeName. \r\n\r\nIf we have to keep the empty volume name for some reason. What will happen is that the MarkVolumeAsUncertain will fail. And the volumeattachment object will be long existing. But the pod is able to bringup because kubelet will detect its attachability change. ",
        "createdAt" : "2020-08-06T02:14:37Z",
        "updatedAt" : "2020-08-25T00:15:34Z",
        "lastEditedBy" : "d10fef96-5a18-44e7-b23e-735de7561af7",
        "tags" : [
        ]
      }
    ],
    "commit" : "a6d8e6c5c2e5e25a0dd6a003497519a226128161",
    "line" : 3,
    "diffHunk" : "@@ -1,1 +342,346 @@\t\t\t\tuncertainNode = derr.CurrentNode\n\t\t\t}\n\t\t\taddErr := actualStateOfWorld.MarkVolumeAsUncertain(\n\t\t\t\tvolumeToAttach.VolumeName,\n\t\t\t\tvolumeToAttach.VolumeSpec,"
  },
  {
    "id" : "7ceec4c8-5417-443f-90e6-00188cd3d0bc",
    "prId" : 88759,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/88759#pullrequestreview-701245036",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fea88a07-8c8d-4184-9a33-bc6cc6ce2b19",
        "parentId" : null,
        "authorId" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "body" : "Is it possible to add unit tests for these changes?",
        "createdAt" : "2020-11-07T02:19:12Z",
        "updatedAt" : "2020-11-09T18:57:49Z",
        "lastEditedBy" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "tags" : [
        ]
      },
      {
        "id" : "ad3ab8f4-c3e0-4ac0-a245-1206e698d0a3",
        "parentId" : "fea88a07-8c8d-4184-9a33-bc6cc6ce2b19",
        "authorId" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "body" : "operation_generator.go does not have a big unit test coverage, I'll try to test it manually with a mock driver + some error injection.",
        "createdAt" : "2020-11-09T20:04:43Z",
        "updatedAt" : "2020-11-09T20:04:44Z",
        "lastEditedBy" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "tags" : [
        ]
      },
      {
        "id" : "bb68831c-4241-44dd-804a-6a5061209425",
        "parentId" : "fea88a07-8c8d-4184-9a33-bc6cc6ce2b19",
        "authorId" : "e0218e0a-9e55-43f5-8929-04673eea9015",
        "body" : "@jsafrane we have azure file csi driver that has implemented `NodeStageVolume`, and for this code change, it only call one `NodeStageVolume`, it would not work if that volume is going to mount on multiple nodes, shall we revert this code change, even `NodeStageVolume` is mounted multiple times on same node, CSI driver should ensure mount on same target work, right? find details here: https://github.com/kubernetes-sigs/azurefile-csi-driver/issues/620",
        "createdAt" : "2021-05-03T02:30:44Z",
        "updatedAt" : "2021-05-03T02:33:02Z",
        "lastEditedBy" : "e0218e0a-9e55-43f5-8929-04673eea9015",
        "tags" : [
        ]
      },
      {
        "id" : "2421571f-f714-4b7e-90dc-0bd3784b36a4",
        "parentId" : "fea88a07-8c8d-4184-9a33-bc6cc6ce2b19",
        "authorId" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "body" : "I am not sure I understand. The code above makes sure that `NodeStageVolume` should be called only once on each node where a shared volume is used. The volume can still be used in multiple nodes.",
        "createdAt" : "2021-05-03T13:51:01Z",
        "updatedAt" : "2021-05-03T13:51:01Z",
        "lastEditedBy" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "tags" : [
        ]
      },
      {
        "id" : "58d59a4e-bb41-4d79-a49a-c85aac61395d",
        "parentId" : "fea88a07-8c8d-4184-9a33-bc6cc6ce2b19",
        "authorId" : "e0218e0a-9e55-43f5-8929-04673eea9015",
        "body" : "from what I observe, there is a little possibility that `NodeStageVolume` is not invoked, only invoke `NodePublishVolume`, and it only happens from k8s v1.20.x, do you know what could be the root cause? thanks.\r\n```\r\nI0502 14:51:38.501550       1 utils.go:118] GRPC call: /csi.v1.Node/NodePublishVolume\r\nI0502 14:51:38.501574       1 utils.go:119] GRPC request: {\"staging_target_path\":\"/var/lib/kubelet/plugins/kubernetes.io/csi/pv/azurefile-4885-file.csi.azure.com-preprovsioned-pv-ql6t7/globalmount\",\"target_path\":\"/var/lib/kubelet/pods/ed800670-69de-4a1e-902c-e0ceeca4ec68/volumes/kubernetes.io~csi/azurefile-4885-file.csi.azure.com-preprovsioned-pv-ql6t7/mount\",\"volume_capability\":{\"AccessType\":{\"Mount\":{}},\"access_mode\":{\"mode\":1}},\"volume_context\":{\"csi.storage.k8s.io/ephemeral\":\"false\",\"csi.storage.k8s.io/pod.name\":\"azurefile-volume-tester-2tpth\",\"csi.storage.k8s.io/pod.namespace\":\"azurefile-4885\",\"csi.storage.k8s.io/pod.uid\":\"ed800670-69de-4a1e-902c-e0ceeca4ec68\",\"csi.storage.k8s.io/serviceAccount.name\":\"default\"},\"volume_id\":\"kubetest-u33fnt21#f7bf7d45cebcf4286987d85#pre-provisioned-multiple-pods#\"}\r\nI0502 14:51:38.501732       1 nodeserver.go:84] NodePublishVolume: mounting /var/lib/kubelet/plugins/kubernetes.io/csi/pv/azurefile-4885-file.csi.azure.com-preprovsioned-pv-ql6t7/globalmount at /var/lib/kubelet/pods/ed800670-69de-4a1e-902c-e0ceeca4ec68/volumes/kubernetes.io~csi/azurefile-4885-file.csi.azure.com-preprovsioned-pv-ql6t7/mount with mountOptions: [bind]\r\nI0502 14:51:38.501750       1 mount_linux.go:175] Mounting cmd (mount) with arguments ( -o bind /var/lib/kubelet/plugins/kubernetes.io/csi/pv/azurefile-4885-file.csi.azure.com-preprovsioned-pv-ql6t7/globalmount /var/lib/kubelet/pods/ed800670-69de-4a1e-902c-e0ceeca4ec68/volumes/kubernetes.io~csi/azurefile-4885-file.csi.azure.com-preprovsioned-pv-ql6t7/mount)\r\nE0502 14:51:38.503747       1 mount_linux.go:179] Mount failed: exit status 32\r\nMounting command: mount\r\nMounting arguments:  -o bind /var/lib/kubelet/plugins/kubernetes.io/csi/pv/azurefile-4885-file.csi.azure.com-preprovsioned-pv-ql6t7/globalmount /var/lib/kubelet/pods/ed800670-69de-4a1e-902c-e0ceeca4ec68/volumes/kubernetes.io~csi/azurefile-4885-file.csi.azure.com-preprovsioned-pv-ql6t7/mount\r\nOutput: mount: /var/lib/kubelet/pods/ed800670-69de-4a1e-902c-e0ceeca4ec68/volumes/kubernetes.io~csi/azurefile-4885-file.csi.azure.com-preprovsioned-pv-ql6t7/mount: special device /var/lib/kubelet/plugins/kubernetes.io/csi/pv/azurefile-4885-file.csi.azure.com-preprovsioned-pv-ql6t7/globalmount does not exist.\r\n\r\nE0502 14:51:38.503833       1 utils.go:123] GRPC error: rpc error: code = Internal desc = Could not mount \"/var/lib/kubelet/plugins/kubernetes.io/csi/pv/azurefile-4885-file.csi.azure.com-preprovsioned-pv-ql6t7/globalmount\" at \"/var/lib/kubelet/pods/ed800670-69de-4a1e-902c-e0ceeca4ec68/volumes/kubernetes.io~csi/azurefile-4885-file.csi.azure.com-preprovsioned-pv-ql6t7/mount\": mount failed: exit status 32\r\nMounting command: mount\r\nMounting arguments:  -o bind /var/lib/kubelet/plugins/kubernetes.io/csi/pv/azurefile-4885-file.csi.azure.com-preprovsioned-pv-ql6t7/globalmount /var/lib/kubelet/pods/ed800670-69de-4a1e-902c-e0ceeca4ec68/volumes/kubernetes.io~csi/azurefile-4885-file.csi.azure.com-preprovsioned-pv-ql6t7/mount\r\nOutput: mount: /var/lib/kubelet/pods/ed800670-69de-4a1e-902c-e0ceeca4ec68/volumes/kubernetes.io~csi/azurefile-4885-file.csi.azure.com-preprovsioned-pv-ql6t7/mount: special device /var/lib/kubelet/plugins/kubernetes.io/csi/pv/azurefile-4885-file.csi.azure.com-preprovsioned-pv-ql6t7/globalmount does not exist.\r\n```\r\n\r\nhttps://storage.googleapis.com/kubernetes-jenkins/pr-logs/pull/kubernetes-sigs_azurefile-csi-driver/642/pull-azurefile-csi-driver-e2e-vmss/1388861197100519424/build-log.txt",
        "createdAt" : "2021-05-03T14:14:23Z",
        "updatedAt" : "2021-05-03T14:14:45Z",
        "lastEditedBy" : "e0218e0a-9e55-43f5-8929-04673eea9015",
        "tags" : [
        ]
      },
      {
        "id" : "4b093307-ee4e-41d4-97b1-1498439ee26b",
        "parentId" : "fea88a07-8c8d-4184-9a33-bc6cc6ce2b19",
        "authorId" : "e0218e0a-9e55-43f5-8929-04673eea9015",
        "body" : "I think I found the issue, there are multiple pods referencing same volume(same volumeid) in the test case, those pods would be created, deleted in serial, so usually it won't have any issue, every pod creation and termination would have corresponding `NodeStageVolume` and then `NodePublishVolume` one by one; the error case could be `NodeUnstageVolume` takes some time(delay), and for next pod, it could be still in `DeviceGloballyMounted`, and then skip `NodeStageVolume` and after a while, the former `NodeUnstageVolume` completed, so for next pod, it only has `NodePublishVolume` func, is that possible @jsafrane ",
        "createdAt" : "2021-05-05T12:30:25Z",
        "updatedAt" : "2021-05-05T12:30:42Z",
        "lastEditedBy" : "e0218e0a-9e55-43f5-8929-04673eea9015",
        "tags" : [
        ]
      },
      {
        "id" : "1b622fe7-0d1d-42ea-a33d-9ed275ddd839",
        "parentId" : "fea88a07-8c8d-4184-9a33-bc6cc6ce2b19",
        "authorId" : "e0218e0a-9e55-43f5-8929-04673eea9015",
        "body" : "another common error case: if two csi driver PVs has the same `volumeHandle` value, `NodeStageVolume` will only happen once and the second PV mount won't have `NodeStageVolume`, it would fail.\r\n```\r\n Warning  FailedMount  90s (x259 over 8h)   kubelet, aks-nodepool1-18870927-vmss000003  MountVolume.SetUp failed for volume \"pvc-25b2474c-2d14-4666-9be8-a246a7f496e7\" : rpc error: code = Internal desc = Could not mount \"/var/lib/kubelet/plugins/kubernetes.io/csi/pv/pvc-25b2474c-2d14-4666-9be8-a246a7f496e7/globalmount\" at \"/var/lib/kubelet/pods/84a2ab61-55e6-4bb7-9fbf-95237cf7c47a/volumes/kubernetes.io~csi/pvc-25b2474c-2d14-4666-9be8-a246a7f496e7/mount\": mount failed: exit status 32\r\nMounting command: mount\r\nMounting arguments:  -o bind /var/lib/kubelet/plugins/kubernetes.io/csi/pv/pvc-25b2474c-2d14-4666-9be8-a246a7f496e7/globalmount /var/lib/kubelet/pods/84a2ab61-55e6-4bb7-9fbf-95237cf7c47a/volumes/kubernetes.io~csi/pvc-25b2474c-2d14-4666-9be8-a246a7f496e7/mount\r\nOutput: mount: /var/lib/kubelet/pods/84a2ab61-55e6-4bb7-9fbf-95237cf7c47a/volumes/kubernetes.io~csi/pvc-25b2474c-2d14-4666-9be8-a246a7f496e7/mount: special device /var/lib/kubelet/plugins/kubernetes.io/csi/pv/pvc-25b2474c-2d14-4666-9be8-a246a7f496e7/globalmount does not exist.\r\n```",
        "createdAt" : "2021-05-05T12:41:25Z",
        "updatedAt" : "2021-05-05T12:42:12Z",
        "lastEditedBy" : "e0218e0a-9e55-43f5-8929-04673eea9015",
        "tags" : [
        ]
      },
      {
        "id" : "5db19c25-122e-4c90-986d-c7af71ef0fc7",
        "parentId" : "fea88a07-8c8d-4184-9a33-bc6cc6ce2b19",
        "authorId" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "body" : "If they have the same `volumeHandle`, they're the same volumes and hence a single NodeStage is called. From CSI `volume_id` description:\r\n```\r\n  // This field MUST contain enough information to uniquely identify\r\n  // this specific volume vs all other volumes supported by this plugin.\r\n  // This field SHALL be used by the CO in subsequent calls to refer to\r\n  // this volume.\r\n  // The SP is NOT responsible for global uniqueness of volume_id across\r\n  // multiple SPs.\r\n  string volume_id = 2;\r\n```",
        "createdAt" : "2021-05-18T11:43:43Z",
        "updatedAt" : "2021-05-18T11:43:43Z",
        "lastEditedBy" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "tags" : [
        ]
      },
      {
        "id" : "5208a91b-c819-4f8a-9215-e2ceaafa92cb",
        "parentId" : "fea88a07-8c8d-4184-9a33-bc6cc6ce2b19",
        "authorId" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "body" : "> `NodeUnstageVolume` takes some time(delay), and for next pod, it could be still in `DeviceGloballyMounted`, and then skip `NodeStageVolume` and after a while, the former `NodeUnstageVolume` completed, so for next pod, it only has `NodePublishVolume` func, is that possible @jsafrane\r\n\r\nIt should not be possible. Kubelet should run only a single operator per volume (MountVolume or UnmountVolume). The aforementioned behavior would be a bug, if it really happens.",
        "createdAt" : "2021-05-18T11:46:54Z",
        "updatedAt" : "2021-05-18T11:46:54Z",
        "lastEditedBy" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "tags" : [
        ]
      },
      {
        "id" : "09af8b09-c7c7-40ab-a090-1a857cf3de71",
        "parentId" : "fea88a07-8c8d-4184-9a33-bc6cc6ce2b19",
        "authorId" : "e7c72227-b5bf-41fe-a4a0-b9505b0e203e",
        "body" : "This affects the following scenario, can you please share your thoughts:\r\n\r\nIf there is a pod(let's say part of a StatefulSet) running on a node which uses a volume and the pod is deleted, the `NodeUnstageVolume` RPC gets called.\r\n\r\nIf completion of this `NodeUnstageVolume` RPC call takes time(for example: due to a wait on completion of `umount` Linux command), for the new replacement pod(scheduled on the same node) kubelet will find the volume as `DeviceGloballyMounted` and call `NodePublishVolume` RPC without calling `NodeStageVolume` RPC. \r\n\r\nLater the `NodeUnstageVolume` RPC's unmount operation which was in progress would complete and unmount the volume. Thus, effectively for the new pod the staging doesn't happen.",
        "createdAt" : "2021-07-06T06:04:19Z",
        "updatedAt" : "2021-07-06T07:10:38Z",
        "lastEditedBy" : "e7c72227-b5bf-41fe-a4a0-b9505b0e203e",
        "tags" : [
        ]
      },
      {
        "id" : "abac4090-6cd3-433c-85ee-97548ed990a9",
        "parentId" : "fea88a07-8c8d-4184-9a33-bc6cc6ce2b19",
        "authorId" : "e0218e0a-9e55-43f5-8929-04673eea9015",
        "body" : "@rohitChaware did you hit such race condition issue recently?",
        "createdAt" : "2021-07-06T07:33:17Z",
        "updatedAt" : "2021-07-06T07:33:17Z",
        "lastEditedBy" : "e0218e0a-9e55-43f5-8929-04673eea9015",
        "tags" : [
        ]
      },
      {
        "id" : "b440de89-c172-4f61-b65d-613c0ba680d5",
        "parentId" : "fea88a07-8c8d-4184-9a33-bc6cc6ce2b19",
        "authorId" : "e7c72227-b5bf-41fe-a4a0-b9505b0e203e",
        "body" : "Yes @andyzhangx , reproduced the above scenario on K8s version 1.20.6. \r\n\r\n`NodeStageVolume` RPC isn't getting called in case when `NodeUnstageVolume` operation takes longer to complete(more than 2 minutes) and a new pod using the same volume is scheduled on the same node.\r\n\r\nThe flow of RPC calls go as expected for versions < 1.20.",
        "createdAt" : "2021-07-06T09:43:02Z",
        "updatedAt" : "2021-07-06T09:43:02Z",
        "lastEditedBy" : "e7c72227-b5bf-41fe-a4a0-b9505b0e203e",
        "tags" : [
        ]
      },
      {
        "id" : "23385016-40ef-48c7-b7df-a9eff63570ea",
        "parentId" : "fea88a07-8c8d-4184-9a33-bc6cc6ce2b19",
        "authorId" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "body" : "https://github.com/kubernetes/kubernetes/pull/100183 may help",
        "createdAt" : "2021-07-07T16:58:53Z",
        "updatedAt" : "2021-07-07T16:58:54Z",
        "lastEditedBy" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "tags" : [
        ]
      }
    ],
    "commit" : "6060c57ba3a944bd133968fd669980c97af846c6",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +569,573 @@\t\t}\n\n\t\tif volumeDeviceMounter != nil && actualStateOfWorld.GetDeviceMountState(volumeToMount.VolumeName) != DeviceGloballyMounted {\n\t\t\tdeviceMountPath, err :=\n\t\t\t\tvolumeDeviceMounter.GetDeviceMountPath(volumeToMount.VolumeSpec)"
  },
  {
    "id" : "bc7ea205-5ac6-42e4-bd1f-bd28271275ae",
    "prId" : 88660,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/88660#pullrequestreview-367322714",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "67fb59a4-b865-4e9f-bb8c-fdbaebd54297",
        "parentId" : null,
        "authorId" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "body" : "afaict nobody is setting `simpleErr` variable. Does it still make sense to perform this check?",
        "createdAt" : "2020-03-02T15:36:44Z",
        "updatedAt" : "2020-03-02T15:59:25Z",
        "lastEditedBy" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "tags" : [
        ]
      },
      {
        "id" : "90c3aa16-120f-4835-9fbf-76bb79def4a0",
        "parentId" : "67fb59a4-b865-4e9f-bb8c-fdbaebd54297",
        "authorId" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "body" : "It *should* be set by every `return`. Or I don't understand golang...",
        "createdAt" : "2020-03-02T16:04:14Z",
        "updatedAt" : "2020-03-02T16:04:15Z",
        "lastEditedBy" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "tags" : [
        ]
      },
      {
        "id" : "60267d28-9a32-48f5-b81a-501d337e6ff4",
        "parentId" : "67fb59a4-b865-4e9f-bb8c-fdbaebd54297",
        "authorId" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "body" : "duh - I forgot that about named return variable..",
        "createdAt" : "2020-03-02T16:08:19Z",
        "updatedAt" : "2020-03-02T16:08:34Z",
        "lastEditedBy" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "tags" : [
        ]
      }
    ],
    "commit" : "afcbb683865473a701cc491229039b8c2ae42f23",
    "line" : 52,
    "diffHunk" : "@@ -1,1 +996,1000 @@\t\t\t// From now on, the volume is mapped. Mark it as uncertain on error,\n\t\t\t// so it is is unmapped when corresponding pod is deleted.\n\t\t\tdefer func() {\n\t\t\t\tif simpleErr != nil {\n\t\t\t\t\terrText := simpleErr.Error()"
  },
  {
    "id" : "7be82e45-24b5-4995-97ea-48e5795c6fff",
    "prId" : 86968,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/86968#pullrequestreview-440979596",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8a5e0288-68e2-4fce-a43d-637c376f881f",
        "parentId" : null,
        "authorId" : "542e5d2f-2ff9-4674-ab44-78f31768e7a1",
        "body" : "Why are stage and mount path the same here",
        "createdAt" : "2020-01-13T22:49:17Z",
        "updatedAt" : "2020-07-01T16:21:33Z",
        "lastEditedBy" : "542e5d2f-2ff9-4674-ab44-78f31768e7a1",
        "tags" : [
        ]
      },
      {
        "id" : "7a14c754-37c4-4597-8c35-ff588a10f1ac",
        "parentId" : "8a5e0288-68e2-4fce-a43d-637c376f881f",
        "authorId" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "body" : "The reason `DeviceStagePath`  was introduced is to make it easier for drivers to find out the staging path if they support node-staging. So stage and mount path are always going to be same at the point where `NodeExpandVolume` is called after stage but before publish.                                                                                                                                                                       \r\n",
        "createdAt" : "2020-03-09T21:02:27Z",
        "updatedAt" : "2020-07-01T16:21:33Z",
        "lastEditedBy" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "tags" : [
        ]
      },
      {
        "id" : "4e13ecea-8b2a-47b3-b00b-36d67328d344",
        "parentId" : "8a5e0288-68e2-4fce-a43d-637c376f881f",
        "authorId" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "body" : "Can you add a comment describing this? It's very confusing. We call node expand after stage and again after publish. And the resize call after stage will have the same paths, but the one after publish will have different paths?",
        "createdAt" : "2020-04-17T18:51:21Z",
        "updatedAt" : "2020-07-01T16:21:33Z",
        "lastEditedBy" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "tags" : [
        ]
      },
      {
        "id" : "69e8aa52-9b9b-48f2-aa85-e3704c3bc8ce",
        "parentId" : "8a5e0288-68e2-4fce-a43d-637c376f881f",
        "authorId" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "body" : "Added a comment explaining this and also marked this code flow as deprecated because in future we will not be calling `NodeExpandVolume` in between stage and publish.\r\n",
        "createdAt" : "2020-07-01T15:31:28Z",
        "updatedAt" : "2020-07-01T16:21:33Z",
        "lastEditedBy" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "tags" : [
        ]
      }
    ],
    "commit" : "6342dad709626dcc6da600b33f50a29a33525868",
    "line" : 9,
    "diffHunk" : "@@ -1,1 +609,613 @@\t\t\t// in a future version of k8s.\n\t\t\tresizeOptions.DeviceMountPath = deviceMountPath\n\t\t\tresizeOptions.DeviceStagePath = deviceMountPath\n\t\t\tresizeOptions.CSIVolumePhase = volume.CSIVolumeStaged\n"
  },
  {
    "id" : "13abf725-8fc3-4bf0-804c-1ca393e62c92",
    "prId" : 83098,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/83098#pullrequestreview-312185606",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f5517156-191a-4698-bfea-c2b1aae914f2",
        "parentId" : null,
        "authorId" : "5f2c1de8-4266-42c0-b343-ba247af3578f",
        "body" : "Just confirming: is it OK that we are calling this earlier? It used to be invoked when `fsResizeFunc` is called. It will cause the same error to come from a different function.",
        "createdAt" : "2019-11-06T02:32:33Z",
        "updatedAt" : "2019-11-15T01:28:24Z",
        "lastEditedBy" : "5f2c1de8-4266-42c0-b343-ba247af3578f",
        "tags" : [
        ]
      },
      {
        "id" : "6054b93e-05f9-43de-8689-2118b9101abe",
        "parentId" : "f5517156-191a-4698-bfea-c2b1aae914f2",
        "authorId" : "98986d5f-c846-4478-8363-8a016e3d6b89",
        "body" : "Yes this change is intentional. The block here essentially maps to the code [below](https://github.com/kubernetes/kubernetes/pull/83098/files/259f931651ae99711db2b95c1a56a9d55d923e1a#diff-450e811a4953f760ff1594ede8b2037eL1671) which did return the error we return above.\r\nThe extra `FindPluginBySpec` at the point of invocation of the generated fsResizeFunc is not necessary any more as we don't need `useCSIPlugin` at the point of invocation.",
        "createdAt" : "2019-11-06T04:10:23Z",
        "updatedAt" : "2019-11-15T01:28:24Z",
        "lastEditedBy" : "98986d5f-c846-4478-8363-8a016e3d6b89",
        "tags" : [
        ]
      }
    ],
    "commit" : "129f15328bfc159e759260408fedbb9ea1ab2b61",
    "line" : 422,
    "diffHunk" : "@@ -1,1 +1383,1387 @@\n\tvolumePlugin, err :=\n\t\tog.volumePluginMgr.FindPluginBySpec(volumeToMount.VolumeSpec)\n\tif err != nil || volumePlugin == nil {\n\t\treturn volumetypes.GeneratedOperations{}, volumeToMount.GenerateErrorDetailed(\"NodeExpandVolume.FindPluginBySpec failed\", err)"
  },
  {
    "id" : "8f18d0f2-04da-4bfa-859b-2dde3a45ccc7",
    "prId" : 82492,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/82492#pullrequestreview-331818334",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "461f6155-e620-4176-be3f-04fbb62c04cc",
        "parentId" : null,
        "authorId" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "body" : "My thought is if you don't mark device as unmount when previously marked as uncertain. then you could simplify the logic. there is no need of TransientOperationError. MarkDeviceAsUnmounted will be triggered during volume tear down phase. \r\nWhat do you think?",
        "createdAt" : "2019-12-04T22:34:13Z",
        "updatedAt" : "2019-12-12T03:10:37Z",
        "lastEditedBy" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "tags" : [
        ]
      },
      {
        "id" : "3851459a-1fcb-4b50-b9c3-0bd8b8357267",
        "parentId" : "461f6155-e620-4176-be3f-04fbb62c04cc",
        "authorId" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "body" : "There are two reasons, I am not very sure about taking this path:\r\n1. volumemanager has been designed to not track volumes that are not mounted (or for which mount failed with 100% certainity). Now we are saying - we will keep volumes which have failed to mount in \"uncertain\" state and hence they will require \"teardown\" and \"unmountdevice\" calls.  This introduces additional design change into volumemanager and I hope that - no plugin breaks (or fail unmount call) when unmount is called for failed mounts.  My intention has been to stick to code paths which are known to work.\r\n\r\n2. The second reason is - what are we supposed to return when transient error does happen in mount calls? \r\n    * Mount is called and kubelet fails to fetch the secret(on first attempt): - If we return `uncertainProgressError` for them, then volume will be added to ASOW in uncertain state, even though mount call has not even been attempted.  It seems wrong to accept a volume in ASOW. This PR also made a change that, fetching secret call has been moved up and hence if there was an error fetching secret, call returns early without even creating volume directories.\r\n    * ~~If we return a regular error for transient errors - then that would cause volume directories to be removed. This is a problem if, previous error was \"UncertainProgressError\". We do not want a transient error to remove volume directories, in case previous mount operation is still in-progress~~\r\n\r\nGiven above reasons - IMO having a transientError is not problematic. It makes it easier to reason about state of volumemanager and mount failures.",
        "createdAt" : "2019-12-05T12:30:42Z",
        "updatedAt" : "2019-12-12T03:10:37Z",
        "lastEditedBy" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "tags" : [
        ]
      },
      {
        "id" : "15d66bec-a3b5-4c37-b4d5-6028150334bb",
        "parentId" : "461f6155-e620-4176-be3f-04fbb62c04cc",
        "authorId" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "body" : "Updated second case - since we moved secret fetching code to top of the function,  the defer is not executed if fetching secret fails.  But the main point IMO still stands.",
        "createdAt" : "2019-12-05T17:34:00Z",
        "updatedAt" : "2019-12-12T03:10:37Z",
        "lastEditedBy" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "tags" : [
        ]
      },
      {
        "id" : "f7fd89ec-a157-46d0-9a40-5148154eda01",
        "parentId" : "461f6155-e620-4176-be3f-04fbb62c04cc",
        "authorId" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "body" : "> volumemanager has been designed to not track volumes that are not mounted (or for which mount failed with 100% certainity). Now we are saying - we will keep volumes which have failed to mount in \"uncertain\" state and hence they will require \"teardown\" and \"unmountdevice\" calls. This introduces additional design change into volumemanager and I hope that - no plugin breaks (or fail unmount call) when unmount is called for failed mounts. My intention has been to stick to code paths which are known to work.\r\n\r\nFor this one, actually plugin has to deal with \"teardown while previous mount still in progress or actually failed mount already\" after adding this uncertain state, I think. The sequence of event would be like\r\n1. volume setup call returns with timeout error, add it into state\r\n2. pod is deleted, volume tear down is called (meantime the mount might still in process or might failed or might succeeded)\r\n\r\n> Mount is called and kubelet fails to fetch the secret(on first attempt): - If we return uncertainProgressError for them, then volume will be added to ASOW in uncertain state, even though mount call has not even been attempted. It seems wrong to accept a volume in ASOW. This PR also made a change that, fetching secret call has been moved up and hence if there was an error fetching secret, call returns early without even creating volume directories.\r\n\r\nI thought mount is called after fetching the secret?\r\n",
        "createdAt" : "2019-12-06T01:17:00Z",
        "updatedAt" : "2019-12-12T03:10:37Z",
        "lastEditedBy" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "tags" : [
        ]
      },
      {
        "id" : "68921a29-8b56-4916-93da-95aaf46af55a",
        "parentId" : "461f6155-e620-4176-be3f-04fbb62c04cc",
        "authorId" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "body" : "> I thought mount is called after fetching the secret?\r\n\r\nI have been thinking about this and I think we still have a problem. Lets say - `MountDevice` is called and first attempt returns in `UncertainProgressError` which causes volume to be added to uncertain state. Second attempt however fails with a final error (not secret fetching error but lets say NodeStage itself failed) then because error was a final error - https://github.com/kubernetes/kubernetes/blob/6dbd521cfaf3b2abe69dce376b3b2a1cda5406e1/pkg/volume/csi/csi_attacher.go#L270 will remove the deviceMountPath from node. But volume is still in \"Uncertain\" state and must be cleaned up, but https://github.com/kubernetes/kubernetes/blob/6dbd521cfaf3b2abe69dce376b3b2a1cda5406e1/pkg/volume/csi/csi_attacher.go#L484 will throw an error because data directory from `deviceMountPath` is already removed..\r\n",
        "createdAt" : "2019-12-12T04:04:23Z",
        "updatedAt" : "2019-12-12T04:04:24Z",
        "lastEditedBy" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "tags" : [
        ]
      },
      {
        "id" : "e35ce168-eb5e-41ed-9c98-413146d6509d",
        "parentId" : "461f6155-e620-4176-be3f-04fbb62c04cc",
        "authorId" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "body" : "What do we actually gain by removing `TransientOperationFailure` from this PR?",
        "createdAt" : "2019-12-12T04:10:00Z",
        "updatedAt" : "2019-12-12T04:10:00Z",
        "lastEditedBy" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "tags" : [
        ]
      },
      {
        "id" : "45c44114-60ea-457a-97cc-4b9515ba32b0",
        "parentId" : "461f6155-e620-4176-be3f-04fbb62c04cc",
        "authorId" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "body" : "My thought was if both with and without transaction error can work correctly, I prefer without transaction for simplicity. Later we don't need to worry about when other ppl work on this code, they need to understand this logic well and set correctly types of error to use.\r\n\r\nBut as you point it out, if mount fails, metadata will be cleaned. Then when reconciler calls unmount, it will fail to get metadata. The logic here can help remove volume from actual state cache, so unmount does not need to be triggered. \r\n\r\nSo I think this is good. Just to make sure we add enough comment about different types of errors",
        "createdAt" : "2019-12-13T11:38:36Z",
        "updatedAt" : "2019-12-13T11:39:12Z",
        "lastEditedBy" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "tags" : [
        ]
      }
    ],
    "commit" : "ca532c6fb2c08f859eca13e0557f3b2aec9a18e0",
    "line" : 54,
    "diffHunk" : "@@ -1,1 +688,692 @@\t\tactualStateOfWorld.GetDeviceMountState(volumeToMount.VolumeName) == DeviceMountUncertain {\n\t\t// Only devices which were uncertain can be marked as unmounted\n\t\tmarkDeviceUnmountError := actualStateOfWorld.MarkDeviceAsUnmounted(volumeToMount.VolumeName)\n\t\tif markDeviceUnmountError != nil {\n\t\t\tklog.Errorf(volumeToMount.GenerateErrorDetailed(\"MountDevice.MarkDeviceAsUnmounted failed\", markDeviceUnmountError).Error())"
  },
  {
    "id" : "0847934f-cad9-4c63-aa24-8c3124139e7e",
    "prId" : 81429,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/81429#pullrequestreview-278654413",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "79d5e574-87a6-48d3-a9ef-3b7f870e8a83",
        "parentId" : null,
        "authorId" : "61f426fc-ef91-47d4-9d27-f5a1dd2b265b",
        "body" : "This is definitely the wrong path for a raw block volume. It doesn't even exist.",
        "createdAt" : "2019-08-21T21:00:18Z",
        "updatedAt" : "2019-08-23T02:49:08Z",
        "lastEditedBy" : "61f426fc-ef91-47d4-9d27-f5a1dd2b265b",
        "tags" : [
        ]
      },
      {
        "id" : "44c51101-4fbe-41a6-b054-b21a7cca88ed",
        "parentId" : "79d5e574-87a6-48d3-a9ef-3b7f870e8a83",
        "authorId" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "body" : "should be fixed now.",
        "createdAt" : "2019-08-22T20:00:51Z",
        "updatedAt" : "2019-08-23T02:49:08Z",
        "lastEditedBy" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "tags" : [
        ]
      }
    ],
    "commit" : "9dbe0b3ad83fae61b631501a5636f56120a405e8",
    "line" : 137,
    "diffHunk" : "@@ -1,1 +1592,1596 @@\t\t\t\tresizeOptions.CSIVolumePhase = volume.CSIVolumeStaged\n\t\t\t\tresizeOptions.DevicePath = volumeToMount.DevicePath\n\t\t\t\tdmp, err := volumeAttacher.GetDeviceMountPath(volumeToMount.VolumeSpec)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn volumeToMount.GenerateError(\"NodeExpandVolume.GetDeviceMountPath failed\", err)"
  },
  {
    "id" : "861f62c3-b1e9-4dae-80c2-fb184ddc7ed4",
    "prId" : 80048,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/80048#pullrequestreview-260947450",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3a726c10-4037-468b-8b17-7f985df2b3d2",
        "parentId" : null,
        "authorId" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "body" : "I'm unsure how we would even get here since resizing is only triggered through the presence of a PV?",
        "createdAt" : "2019-07-11T20:38:35Z",
        "updatedAt" : "2019-07-11T20:41:34Z",
        "lastEditedBy" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "tags" : [
        ]
      },
      {
        "id" : "ee7b76f0-a7ce-40ce-9493-d896c5a46714",
        "parentId" : "3a726c10-4037-468b-8b17-7f985df2b3d2",
        "authorId" : "542e5d2f-2ff9-4674-ab44-78f31768e7a1",
        "body" : "The resize function is called directly after `MountDevice`:\r\nhttps://github.com/kubernetes/kubernetes/blob/d4d8daea7368e5fc9ad8c375efff74a65d0f91bf/pkg/volume/util/operationexecutor/operation_generator.go#L680\r\n\r\nI have no idea the reasons why, but it is.\r\n\r\nAlso migration creates a \"shadow PV\" so the resize function will \"see\" the PV in the VolumeSpec which is why it tries to continue with the resize\r\n@gnufied ",
        "createdAt" : "2019-07-11T20:51:21Z",
        "updatedAt" : "2019-07-11T21:19:43Z",
        "lastEditedBy" : "542e5d2f-2ff9-4674-ab44-78f31768e7a1",
        "tags" : [
        ]
      }
    ],
    "commit" : "93d6356d2f1cc6013e9fea2f9935928e101c8407",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +766,770 @@\tif volumeToMount.VolumeSpec != nil &&\n\t\tvolumeToMount.VolumeSpec.InlineVolumeSpecForCSIMigration {\n\t\tklog.V(4).Infof(\"This volume %s is a migrated inline volume and is not resizable\", volumeToMount.VolumeName)\n\t\treturn true, nil\n\t}"
  },
  {
    "id" : "1eb89b07-349f-45c7-ba0c-fa7d487eb1b3",
    "prId" : 77994,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/77994#pullrequestreview-243368423",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d23ef9dc-aca1-4961-a13e-539463bc4fdc",
        "parentId" : null,
        "authorId" : "c36d7654-ffec-4c9c-964e-b4b2e70085d0",
        "body" : "If we need provide detailed error info when volumePlugin is nil?",
        "createdAt" : "2019-05-29T15:41:17Z",
        "updatedAt" : "2019-05-29T15:41:36Z",
        "lastEditedBy" : "c36d7654-ffec-4c9c-964e-b4b2e70085d0",
        "tags" : [
        ]
      },
      {
        "id" : "d2e2ee51-8ebd-428c-bcf2-a20c6a8c0185",
        "parentId" : "d23ef9dc-aca1-4961-a13e-539463bc4fdc",
        "authorId" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "body" : "You mean like code below? I think `GenerateError` works as well here. Also it automatically returns two error values and hence is easier to satisfy constraints of the function.",
        "createdAt" : "2019-05-29T16:12:15Z",
        "updatedAt" : "2019-05-29T16:12:15Z",
        "lastEditedBy" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "tags" : [
        ]
      }
    ],
    "commit" : "7563b4d01b5e5dde148f746ccb1ff47c5b5b9272",
    "line" : 51,
    "diffHunk" : "@@ -1,1 +1593,1597 @@\t\tif err != nil || volumePlugin == nil {\n\t\t\treturn volumeToMount.GenerateError(\"VolumeFSResize.FindPluginBySpec failed\", err)\n\t\t}\n\n\t\tvar resizeDone bool"
  },
  {
    "id" : "14c48fd6-30fb-4c88-a085-6a85ae985072",
    "prId" : 77101,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/77101#pullrequestreview-231966693",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1fd00512-8e40-487a-aec5-d8e63a45c62d",
        "parentId" : null,
        "authorId" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "body" : "Do we still need to translate the spec here too since it's done earlier now?",
        "createdAt" : "2019-04-30T00:58:40Z",
        "updatedAt" : "2019-05-01T18:24:28Z",
        "lastEditedBy" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "tags" : [
        ]
      },
      {
        "id" : "1e35e013-99a7-4027-98fa-f5e95e0c5fb8",
        "parentId" : "1fd00512-8e40-487a-aec5-d8e63a45c62d",
        "authorId" : "542e5d2f-2ff9-4674-ab44-78f31768e7a1",
        "body" : "I think it is safer to as the one done earlier just swallows any errors it encounters. This issue can be resolved along with this: https://github.com/kubernetes/kubernetes/pull/77101/files#diff-450e811a4953f760ff1594ede8b2037eR388\r\n\r\nI think the idea would be to determine which plugin to emit the metric for when the operation is being run (since this now actually depends on some runtime state), instead of prior in the operation generator func.",
        "createdAt" : "2019-04-30T01:10:19Z",
        "updatedAt" : "2019-05-01T18:24:28Z",
        "lastEditedBy" : "542e5d2f-2ff9-4674-ab44-78f31768e7a1",
        "tags" : [
        ]
      }
    ],
    "commit" : "1271237d23bf828758a42eec531483d53cc006d5",
    "line" : 81,
    "diffHunk" : "@@ -1,1 +577,581 @@\n\t\t// Get mounter plugin\n\t\tif useCSIPlugin(og.volumePluginMgr, volumeToMount.VolumeSpec) {\n\t\t\tcsiSpec, err := translateSpec(volumeToMount.VolumeSpec)\n\t\t\tif err != nil {"
  },
  {
    "id" : "0882e681-3436-4c4c-972d-c88d7351c753",
    "prId" : 75986,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/75986#pullrequestreview-225036797",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "28406c27-f4a8-4ce7-bdd1-168d467c7b99",
        "parentId" : null,
        "authorId" : "2b5e7cd9-1cd6-4552-b858-212c3c30dc28",
        "body" : "I'm not sure about this if/else logic can be simplified like [this](https://gist.github.com/mucahitkurt/d6934c9a474ba3e862a1740c83cf23b9)",
        "createdAt" : "2019-04-02T04:38:25Z",
        "updatedAt" : "2019-04-24T20:47:03Z",
        "lastEditedBy" : "2b5e7cd9-1cd6-4552-b858-212c3c30dc28",
        "tags" : [
        ]
      },
      {
        "id" : "d189705d-d963-4a98-9479-b1c09952ef87",
        "parentId" : "28406c27-f4a8-4ce7-bdd1-168d467c7b99",
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "Seems reasonable to me. But I will let one of the CSI migration folks(@ddebroy @davidz627 @leakingtapan) verify.",
        "createdAt" : "2019-04-02T05:55:10Z",
        "updatedAt" : "2019-04-24T20:47:03Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      },
      {
        "id" : "09ebb129-1f51-4ee1-b857-1b38bd6b2069",
        "parentId" : "28406c27-f4a8-4ce7-bdd1-168d467c7b99",
        "authorId" : "98986d5f-c846-4478-8363-8a016e3d6b89",
        "body" : "SGTM too.",
        "createdAt" : "2019-04-04T19:12:43Z",
        "updatedAt" : "2019-04-24T20:47:03Z",
        "lastEditedBy" : "98986d5f-c846-4478-8363-8a016e3d6b89",
        "tags" : [
        ]
      },
      {
        "id" : "a839ee7d-bd15-4578-b129-ef380463cc9b",
        "parentId" : "28406c27-f4a8-4ce7-bdd1-168d467c7b99",
        "authorId" : "2b5e7cd9-1cd6-4552-b858-212c3c30dc28",
        "body" : "So, I'll simplify this",
        "createdAt" : "2019-04-04T21:17:27Z",
        "updatedAt" : "2019-04-24T20:47:03Z",
        "lastEditedBy" : "2b5e7cd9-1cd6-4552-b858-212c3c30dc28",
        "tags" : [
        ]
      },
      {
        "id" : "26af65cf-cdf0-4b8a-add0-fd0062c916f4",
        "parentId" : "28406c27-f4a8-4ce7-bdd1-168d467c7b99",
        "authorId" : "98986d5f-c846-4478-8363-8a016e3d6b89",
        "body" : "I was just speaking with @leakingtapan and he pointed out that @mkimuram raised some concerns around potential issues with handling reconstruction failures at https://github.com/kubernetes/kubernetes/pull/74844#discussion_r266272782 when he was thinking of switching from `FindAttachablePluginByName ` to `FindAttachablePluginBySpec`. @mkimuram would there be a similar concern here too with the proposed [simplification](https://gist.github.com/mucahitkurt/d6934c9a474ba3e862a1740c83cf23b9)?",
        "createdAt" : "2019-04-04T23:22:57Z",
        "updatedAt" : "2019-04-24T20:47:03Z",
        "lastEditedBy" : "98986d5f-c846-4478-8363-8a016e3d6b89",
        "tags" : [
        ]
      },
      {
        "id" : "a5c4a514-f5b4-41b0-9c41-0deaa27b6ed7",
        "parentId" : "28406c27-f4a8-4ce7-bdd1-168d467c7b99",
        "authorId" : "2b5e7cd9-1cd6-4552-b858-212c3c30dc28",
        "body" : "Thanks, @leakingtapan pointed out that discussion to me as an answer to my question in sig storage mailing list, when I checked the `GenerateAttachVolumeFunc` usage paths, I couldn't see the similar usage path(not setting the `volumeToAttach.VolumeSpec`).\r\n\r\nI see the similar usage of my proposed simplification in [`GenerateMountVolumeFunc`](https://github.com/kubernetes/kubernetes/blob/990ee3c09c0104cc1045b343040fe76082862d73/pkg/volume/util/operationexecutor/operation_generator.go#L529). But usage scenarios can be different.",
        "createdAt" : "2019-04-05T05:25:07Z",
        "updatedAt" : "2019-04-24T20:47:03Z",
        "lastEditedBy" : "2b5e7cd9-1cd6-4552-b858-212c3c30dc28",
        "tags" : [
        ]
      },
      {
        "id" : "27fe753f-c9ca-4156-9b23-e8906c43af3b",
        "parentId" : "28406c27-f4a8-4ce7-bdd1-168d467c7b99",
        "authorId" : "2b5e7cd9-1cd6-4552-b858-212c3c30dc28",
        "body" : "@vladimirvivien opened an [issue](https://github.com/kubernetes/kubernetes/issues/75838) about the usage of find plugin by spec vs find plugin by name, and he also pointed out this function.\r\n\r\n@vladimirvivien what do you think about my simplification? Thanks!",
        "createdAt" : "2019-04-09T05:19:45Z",
        "updatedAt" : "2019-04-24T20:47:03Z",
        "lastEditedBy" : "2b5e7cd9-1cd6-4552-b858-212c3c30dc28",
        "tags" : [
        ]
      },
      {
        "id" : "0733944a-5c77-495d-95bc-5c4d41d9dcd5",
        "parentId" : "28406c27-f4a8-4ce7-bdd1-168d467c7b99",
        "authorId" : "54b8eb75-28dd-421d-a52b-63bf897147a9",
        "body" : "@mucahitkurt my concern is consistency in using FindAttachablePluginBySpec vs ByName.  BySpec uses does a plugin.CanAttach check internally to determine if the provided spec can be attached.  But it looks like this PR removes FindAttachablePluginByName altogether.  ",
        "createdAt" : "2019-04-10T13:12:12Z",
        "updatedAt" : "2019-04-24T20:47:03Z",
        "lastEditedBy" : "54b8eb75-28dd-421d-a52b-63bf897147a9",
        "tags" : [
        ]
      },
      {
        "id" : "71249baa-8152-45a6-9807-60ea94088e34",
        "parentId" : "28406c27-f4a8-4ce7-bdd1-168d467c7b99",
        "authorId" : "2b5e7cd9-1cd6-4552-b858-212c3c30dc28",
        "body" : "@ddebroy, @leakingtapan I'll rollback this simplification to make this PR go forward.",
        "createdAt" : "2019-04-10T15:10:47Z",
        "updatedAt" : "2019-04-24T20:47:03Z",
        "lastEditedBy" : "2b5e7cd9-1cd6-4552-b858-212c3c30dc28",
        "tags" : [
        ]
      }
    ],
    "commit" : "1c1da755dc5fc35bef51c31b5d52cb51fa2dc998",
    "line" : 59,
    "diffHunk" : "@@ -1,1 +303,307 @@\n\t\t// useCSIPlugin will check both CSIMigration and the plugin specific feature gate\n\t\tif useCSIPlugin(og.volumePluginMgr, volumeToAttach.VolumeSpec) && nu {\n\t\t\t// The volume represented by this spec is CSI and thus should be migrated\n\t\t\tattachableVolumePlugin, err = og.volumePluginMgr.FindAttachablePluginByName(csi.CSIPluginName)"
  },
  {
    "id" : "89f16e76-bf66-46be-abac-8d52aaab5189",
    "prId" : 75986,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/75986#pullrequestreview-223559237",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "99af8a41-e803-4890-8dff-a580115d2d68",
        "parentId" : null,
        "authorId" : "41981c80-b404-4c55-bd22-5f96c0512a61",
        "body" : "When CSI migration is enabled, the `volumeToAttach.VolumeSpec` will be the migrated CSI spec. However, with this change, it will be the original spec, since the migration logic is moved inside `attachVolumeFunc`. Im not sure if this is okay. Have you tested your change with CSI migration enabled? And can you check how is `CompleteFunc` is used?",
        "createdAt" : "2019-04-04T21:44:15Z",
        "updatedAt" : "2019-04-24T20:47:03Z",
        "lastEditedBy" : "41981c80-b404-4c55-bd22-5f96c0512a61",
        "tags" : [
        ]
      },
      {
        "id" : "d25e4a86-c6de-466e-a12f-07dc8ed82b5f",
        "parentId" : "99af8a41-e803-4890-8dff-a580115d2d68",
        "authorId" : "2b5e7cd9-1cd6-4552-b858-212c3c30dc28",
        "body" : "Do you mean a non-automated test? I'm quite new to here, how can I do that kind of test? ",
        "createdAt" : "2019-04-05T05:45:07Z",
        "updatedAt" : "2019-04-24T20:47:03Z",
        "lastEditedBy" : "2b5e7cd9-1cd6-4552-b858-212c3c30dc28",
        "tags" : [
        ]
      },
      {
        "id" : "f287b417-a1d0-43ea-9c06-60b46c08dde8",
        "parentId" : "99af8a41-e803-4890-8dff-a580115d2d68",
        "authorId" : "41981c80-b404-4c55-bd22-5f96c0512a61",
        "body" : "We don't have automated test for CSI migration yet. You will need to turn on `CSIMigration` feature flag along with driver specific flag eg. (CSIMigrationAWS) when creating the cluster. Then deploy the CSI driver and verify that it still works.",
        "createdAt" : "2019-04-06T22:50:20Z",
        "updatedAt" : "2019-04-24T20:47:03Z",
        "lastEditedBy" : "41981c80-b404-4c55-bd22-5f96c0512a61",
        "tags" : [
        ]
      }
    ],
    "commit" : "1c1da755dc5fc35bef51c31b5d52cb51fa2dc998",
    "line" : 134,
    "diffHunk" : "@@ -1,1 +396,400 @@\t\tOperationFunc:     attachVolumeFunc,\n\t\tEventRecorderFunc: eventRecorderFunc,\n\t\tCompleteFunc:      util.OperationCompleteHook(util.GetFullQualifiedPluginNameForVolume(attachableVolumePluginName, volumeToAttach.VolumeSpec), \"volume_attach\"),\n\t}\n}"
  },
  {
    "id" : "6d049a94-e101-438b-93ad-cbabda8d1088",
    "prId" : 75986,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/75986#pullrequestreview-229833288",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9f9054a2-0772-4691-b423-d8d9fbff6cea",
        "parentId" : null,
        "authorId" : "54b8eb75-28dd-421d-a52b-63bf897147a9",
        "body" : "Variable `attachableVolumePlugin` seems to be shadowing the previous declaration (line 298).  ",
        "createdAt" : "2019-04-22T17:20:32Z",
        "updatedAt" : "2019-04-24T20:47:03Z",
        "lastEditedBy" : "54b8eb75-28dd-421d-a52b-63bf897147a9",
        "tags" : [
        ]
      },
      {
        "id" : "fbb2a705-04a2-448a-9e6c-1aee55ac807f",
        "parentId" : "9f9054a2-0772-4691-b423-d8d9fbff6cea",
        "authorId" : "2b5e7cd9-1cd6-4552-b858-212c3c30dc28",
        "body" : "It's intentional, first one is used only to find the plugin name, second one is used then the generated function is executed(`FindAttachablePluginByName` or `FindAttachablePluginBySpec` will assign to this second variable).",
        "createdAt" : "2019-04-23T03:49:13Z",
        "updatedAt" : "2019-04-24T20:47:03Z",
        "lastEditedBy" : "2b5e7cd9-1cd6-4552-b858-212c3c30dc28",
        "tags" : [
        ]
      },
      {
        "id" : "9be33ef6-47a8-428e-a1db-88abafb79155",
        "parentId" : "9f9054a2-0772-4691-b423-d8d9fbff6cea",
        "authorId" : "54b8eb75-28dd-421d-a52b-63bf897147a9",
        "body" : "I see.",
        "createdAt" : "2019-04-23T22:50:10Z",
        "updatedAt" : "2019-04-24T20:47:03Z",
        "lastEditedBy" : "54b8eb75-28dd-421d-a52b-63bf897147a9",
        "tags" : [
        ]
      }
    ],
    "commit" : "1c1da755dc5fc35bef51c31b5d52cb51fa2dc998",
    "line" : 35,
    "diffHunk" : "@@ -1,1 +295,299 @@\tactualStateOfWorld ActualStateOfWorldAttacherUpdater) volumetypes.GeneratedOperations {\n\tattachVolumeFunc := func() (error, error) {\n\t\tvar attachableVolumePlugin volume.AttachableVolumePlugin\n\t\toriginalSpec := volumeToAttach.VolumeSpec\n\t\tnu, err := nodeUsingCSIPlugin(og, volumeToAttach.VolumeSpec, volumeToAttach.NodeName)"
  },
  {
    "id" : "74258835-87fa-4453-bdfa-764e60d20c2b",
    "prId" : 74863,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/74863#pullrequestreview-210410603",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2e4a31ae-ef68-491e-bed9-700897ba655d",
        "parentId" : null,
        "authorId" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "body" : "Can you add a comment here explaining why there are two different times resize may be called?",
        "createdAt" : "2019-03-04T22:51:29Z",
        "updatedAt" : "2019-03-08T14:23:30Z",
        "lastEditedBy" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "tags" : [
        ]
      }
    ],
    "commit" : "1bd9ed06d34efb328ce514551e1a23d708f1e526",
    "line" : 44,
    "diffHunk" : "@@ -1,1 +675,679 @@\t\t//\t- Volume does not support DeviceMounter interface.\n\t\t//\t- In case of CSI the volume does not have node stage_unstage capability.\n\t\tif !resizeDone {\n\t\t\tresizeDone, resizeError = og.resizeFileSystem(volumeToMount, resizeOptions, volumePluginName)\n\t\t\tif resizeError != nil {"
  },
  {
    "id" : "fd0de023-56e9-4132-96da-770af9194260",
    "prId" : 74863,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/74863#pullrequestreview-210410603",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9fed1c9b-d0f9-445f-8bf1-2129e3506e71",
        "parentId" : null,
        "authorId" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "body" : "Add a comment here explaining why resize wouldn't return an error but would not be done",
        "createdAt" : "2019-03-04T22:54:23Z",
        "updatedAt" : "2019-03-08T14:23:30Z",
        "lastEditedBy" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "tags" : [
        ]
      }
    ],
    "commit" : "1bd9ed06d34efb328ce514551e1a23d708f1e526",
    "line" : 101,
    "diffHunk" : "@@ -1,1 +756,760 @@\t\t\t// does not have node stage_unstage capability but was asked to resize the volume before\n\t\t\t// node publish. In which case - we must retry resizing after node publish.\n\t\t\tif !resizeDone {\n\t\t\t\treturn false, nil\n\t\t\t}"
  },
  {
    "id" : "2923e344-06ad-409f-b32e-53d7bc9aaaa6",
    "prId" : 74863,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/74863#pullrequestreview-210750498",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bcffdf8e-b1b1-4545-a0c3-4581a33fcd2b",
        "parentId" : null,
        "authorId" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "body" : "Are device mountable plugins supported here? (doesn't support attach but does support global device mount)",
        "createdAt" : "2019-03-04T23:14:13Z",
        "updatedAt" : "2019-03-08T14:23:30Z",
        "lastEditedBy" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "tags" : [
        ]
      },
      {
        "id" : "3dd1415c-c138-4f01-8da6-4bed8813ccb3",
        "parentId" : "bcffdf8e-b1b1-4545-a0c3-4581a33fcd2b",
        "authorId" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "body" : "could use some unit tests here",
        "createdAt" : "2019-03-04T23:14:55Z",
        "updatedAt" : "2019-03-08T14:23:30Z",
        "lastEditedBy" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "tags" : [
        ]
      },
      {
        "id" : "8cd82903-9a9f-4d97-a324-d573cde714ec",
        "parentId" : "bcffdf8e-b1b1-4545-a0c3-4581a33fcd2b",
        "authorId" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "body" : "The only volume type that is not attachable but implements device mountable interface is local storage. So for in-tree volumes this check should be good. ",
        "createdAt" : "2019-03-05T15:34:34Z",
        "updatedAt" : "2019-03-08T14:23:30Z",
        "lastEditedBy" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "tags" : [
        ]
      },
      {
        "id" : "f992bda1-e395-4790-b3ce-fe47531cce36",
        "parentId" : "bcffdf8e-b1b1-4545-a0c3-4581a33fcd2b",
        "authorId" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "body" : "Also if CSI plugin is not attachable but supports node expansion, it should be resized after node publish and hence we should be covered there too. ",
        "createdAt" : "2019-03-05T15:37:50Z",
        "updatedAt" : "2019-03-08T14:23:30Z",
        "lastEditedBy" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "tags" : [
        ]
      }
    ],
    "commit" : "1bd9ed06d34efb328ce514551e1a23d708f1e526",
    "line" : 157,
    "diffHunk" : "@@ -1,1 +1491,1495 @@\t\t\tog.volumePluginMgr.FindAttachablePluginBySpec(volumeToMount.VolumeSpec)\n\n\t\tif attachableVolumePlugin != nil {\n\t\t\tvolumeAttacher, _ := attachableVolumePlugin.NewAttacher()\n\t\t\tif volumeAttacher != nil {"
  },
  {
    "id" : "a141c3eb-f951-4e01-914e-df7a53d8c8d0",
    "prId" : 74863,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/74863#pullrequestreview-212064449",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "30e4bd55-816d-4d3f-bebf-4c04765ed224",
        "parentId" : null,
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "nit: put a comment explaining what the expected values are that are returned here.",
        "createdAt" : "2019-03-07T21:33:46Z",
        "updatedAt" : "2019-03-08T14:23:30Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      },
      {
        "id" : "88d2cb3f-c311-46de-9be7-438054dbd20d",
        "parentId" : "30e4bd55-816d-4d3f-bebf-4c04765ed224",
        "authorId" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "body" : "I will follow up this in a follow up. ",
        "createdAt" : "2019-03-07T22:52:38Z",
        "updatedAt" : "2019-03-08T14:23:30Z",
        "lastEditedBy" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "tags" : [
        ]
      }
    ],
    "commit" : "1bd9ed06d34efb328ce514551e1a23d708f1e526",
    "line" : 59,
    "diffHunk" : "@@ -1,1 +714,718 @@}\n\nfunc (og *operationGenerator) resizeFileSystem(volumeToMount VolumeToMount, rsOpts volume.NodeResizeOptions, pluginName string) (bool, error) {\n\tif !utilfeature.DefaultFeatureGate.Enabled(features.ExpandPersistentVolumes) {\n\t\tklog.V(4).Infof(\"Resizing is not enabled for this volume %s\", volumeToMount.VolumeName)"
  },
  {
    "id" : "b6dc0706-d383-4f1b-bf8f-fffd8083dbff",
    "prId" : 74844,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/74844#pullrequestreview-210295901",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "821a33f4-b71b-423d-a7ec-34b2352faf99",
        "parentId" : null,
        "authorId" : "98986d5f-c846-4478-8363-8a016e3d6b89",
        "body" : "`FindMapperPluginBySpec` will not be able to return a plugin when `volumeToMount.VolumeSpec = csiSpec` is set right? Is the erroring out below when `blockVolumePlugin == nil`, okay?",
        "createdAt" : "2019-03-03T09:21:53Z",
        "updatedAt" : "2019-03-26T22:21:30Z",
        "lastEditedBy" : "98986d5f-c846-4478-8363-8a016e3d6b89",
        "tags" : [
        ]
      },
      {
        "id" : "716d7af1-5d45-4406-aa38-27cf5c9e2c08",
        "parentId" : "821a33f4-b71b-423d-a7ec-34b2352faf99",
        "authorId" : "41981c80-b404-4c55-bd22-5f96c0512a61",
        "body" : "Given my understanding, csi plugin is [registered](https://github.com/kubernetes/kubernetes/blob/48def74e641f8dff50fcf7c33c2a412593e2fede/cmd/kubelet/app/plugins.go#L101) with kubelet, so`FindMapperPluginBySpec` should return the csi plugin? Otherwise, my manual test on raw block volume migration won't work too.",
        "createdAt" : "2019-03-04T17:43:53Z",
        "updatedAt" : "2019-03-26T22:21:30Z",
        "lastEditedBy" : "41981c80-b404-4c55-bd22-5f96c0512a61",
        "tags" : [
        ]
      },
      {
        "id" : "503c9a46-f129-4d06-92a4-4a8310b0954e",
        "parentId" : "821a33f4-b71b-423d-a7ec-34b2352faf99",
        "authorId" : "98986d5f-c846-4478-8363-8a016e3d6b89",
        "body" : "Ah .. you are right. I was thinking of the spec pointing to the specific CSI plugin but that is not what the Spec/`Find*PluginBySpec` looks for.",
        "createdAt" : "2019-03-04T18:25:46Z",
        "updatedAt" : "2019-03-26T22:21:30Z",
        "lastEditedBy" : "98986d5f-c846-4478-8363-8a016e3d6b89",
        "tags" : [
        ]
      }
    ],
    "commit" : "f7050a04ce5dee118c5558d2d77806d173307a7d",
    "line" : 27,
    "diffHunk" : "@@ -1,1 +959,963 @@\t// Get block volume mapper plugin\n\tblockVolumePlugin, err :=\n\t\tog.volumePluginMgr.FindMapperPluginBySpec(volumeToMount.VolumeSpec)\n\tif err != nil {\n\t\treturn volumetypes.GeneratedOperations{}, volumeToMount.GenerateErrorDetailed(\"MapVolume.FindMapperPluginBySpec failed\", err)"
  },
  {
    "id" : "a6ca4984-b275-4eab-bbeb-0a51f72470ac",
    "prId" : 74844,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/74844#pullrequestreview-219189881",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "26e6c8fb-0eb3-4876-8214-a928997fa728",
        "parentId" : null,
        "authorId" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "body" : "I think we need to check for VolumeSpec == nil here, similar to GenerateUnmountVolumeFunc",
        "createdAt" : "2019-03-26T17:57:44Z",
        "updatedAt" : "2019-03-26T22:21:30Z",
        "lastEditedBy" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "tags" : [
        ]
      },
      {
        "id" : "2effc71d-2490-4174-bc8b-68ff82307b1d",
        "parentId" : "26e6c8fb-0eb3-4876-8214-a928997fa728",
        "authorId" : "41981c80-b404-4c55-bd22-5f96c0512a61",
        "body" : "Didn't notice https://github.com/kubernetes/kubernetes/pull/74493. So if the nil check is only added in `GenerateUnmountVolumeFunc`, should the same be added in `GenerateUnmapVolumeFunc`? Where `volumeToUnmount` has the nilable spec",
        "createdAt" : "2019-03-26T21:19:58Z",
        "updatedAt" : "2019-03-26T22:21:30Z",
        "lastEditedBy" : "41981c80-b404-4c55-bd22-5f96c0512a61",
        "tags" : [
        ]
      },
      {
        "id" : "f3c2f4f9-fdfc-401e-a43f-30e647302bda",
        "parentId" : "26e6c8fb-0eb3-4876-8214-a928997fa728",
        "authorId" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "body" : "Oh right it should be added to UnmapVolume.  When reconstruction fails (and spec == nil), then it only calls UnmountVolume => UnmapVolume.",
        "createdAt" : "2019-03-26T21:28:13Z",
        "updatedAt" : "2019-03-26T22:21:30Z",
        "lastEditedBy" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "tags" : [
        ]
      },
      {
        "id" : "8cdbd1a6-7a99-406b-80d5-8670b519036d",
        "parentId" : "26e6c8fb-0eb3-4876-8214-a928997fa728",
        "authorId" : "41981c80-b404-4c55-bd22-5f96c0512a61",
        "body" : "Updated",
        "createdAt" : "2019-03-26T22:21:44Z",
        "updatedAt" : "2019-03-26T22:21:44Z",
        "lastEditedBy" : "41981c80-b404-4c55-bd22-5f96c0512a61",
        "tags" : [
        ]
      }
    ],
    "commit" : "f7050a04ce5dee118c5558d2d77806d173307a7d",
    "line" : 100,
    "diffHunk" : "@@ -1,1 +1216,1220 @@\tvar err error\n\t// Translate to CSI spec if migration enabled\n\tif useCSIPlugin(og.volumePluginMgr, deviceToDetach.VolumeSpec) {\n\t\tcsiSpec, err := translateSpec(deviceToDetach.VolumeSpec)\n\t\tif err != nil {"
  },
  {
    "id" : "28ef503c-42a6-4959-b6b2-0a5c8f7d6dc7",
    "prId" : 74835,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/74835#pullrequestreview-210909241",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8373bdec-3450-4cac-a92a-933f9358ab6a",
        "parentId" : null,
        "authorId" : "2ce2b44c-9841-49e7-983e-fb7696974908",
        "body" : "i would move this check as the first one.\r\nit's the cheapest compared to the above conditions.\r\n\r\n",
        "createdAt" : "2019-03-05T20:56:00Z",
        "updatedAt" : "2019-03-08T01:17:26Z",
        "lastEditedBy" : "2ce2b44c-9841-49e7-983e-fb7696974908",
        "tags" : [
        ]
      }
    ],
    "commit" : "41b3579345ff761a54ec56e2afc2d2d2ce6f56e5",
    "line" : 104,
    "diffHunk" : "@@ -1,1 +1575,1579 @@\t}\n\n\tif len(nodeName) == 0 {\n\t\treturn false, goerrors.New(\"nodeName is empty\")\n\t}"
  },
  {
    "id" : "a6b1f0d1-feec-4145-ab8c-86808242f11a",
    "prId" : 74835,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/74835#pullrequestreview-211959843",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8ea8d15a-b292-4ce2-802e-30ad3616deee",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "I don't see useCSIPlugin checking the plugin specific feature gate... am I missing it?",
        "createdAt" : "2019-03-07T05:38:49Z",
        "updatedAt" : "2019-03-08T01:17:26Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "27975918-7db8-4f7a-b2a0-82df52e2215b",
        "parentId" : "8ea8d15a-b292-4ce2-802e-30ad3616deee",
        "authorId" : "542e5d2f-2ff9-4674-ab44-78f31768e7a1",
        "body" : "each plugin specific feature gate is encoded by the plugin itself and is checked by: `vpm.IsPluginMigratableBySpec(spec)`",
        "createdAt" : "2019-03-07T18:52:31Z",
        "updatedAt" : "2019-03-08T01:17:26Z",
        "lastEditedBy" : "542e5d2f-2ff9-4674-ab44-78f31768e7a1",
        "tags" : [
        ]
      },
      {
        "id" : "86562644-e387-48c8-9e2d-0900b53aa7f9",
        "parentId" : "8ea8d15a-b292-4ce2-802e-30ad3616deee",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "ah, I see it now, thanks.",
        "createdAt" : "2019-03-07T18:55:01Z",
        "updatedAt" : "2019-03-08T01:17:26Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "41b3579345ff761a54ec56e2afc2d2d2ce6f56e5",
    "line" : 41,
    "diffHunk" : "@@ -1,1 +415,419 @@\t\t}\n\n\t\t// useCSIPlugin will check both CSIMigration and the plugin specific feature gate\n\t\tif useCSIPlugin(og.volumePluginMgr, volumeToDetach.VolumeSpec) && nu {\n\t\t\t// The volume represented by this spec is CSI and thus should be migrated"
  },
  {
    "id" : "19e9b630-57d5-4936-bf78-d09363a5b08a",
    "prId" : 74493,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/74493#pullrequestreview-208172542",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "97627d2e-7c31-4849-9e2d-c4e77b634cee",
        "parentId" : null,
        "authorId" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "body" : "I think we should return an error in ConstructVolumeSpec() instead if we can't support reconstruction, like [here](https://sourcegraph.com/github.com/kubernetes/kubernetes/-/blob/pkg/volume/glusterfs/glusterfs.go#L232).\r\n\r\nThis will cause the Unmount() to happen, which will fix the filesystem-based paths, however block-based paths will not work because UnmountDevice() is still not called.",
        "createdAt" : "2019-02-25T21:35:24Z",
        "updatedAt" : "2019-02-25T21:35:25Z",
        "lastEditedBy" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "tags" : [
        ]
      },
      {
        "id" : "375d9314-2bb0-4e08-89c0-15d651cd2b93",
        "parentId" : "97627d2e-7c31-4849-9e2d-c4e77b634cee",
        "authorId" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "body" : "Does raw block reconstruction have a similar issue? We don't have tests for raw block reconstruction: https://github.com/kubernetes/kubernetes/issues/74545",
        "createdAt" : "2019-02-25T21:39:22Z",
        "updatedAt" : "2019-02-25T21:39:22Z",
        "lastEditedBy" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "tags" : [
        ]
      },
      {
        "id" : "5912d08a-a559-4edc-8a4c-99e6185cb224",
        "parentId" : "97627d2e-7c31-4849-9e2d-c4e77b634cee",
        "authorId" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "body" : "cc @gnufied ",
        "createdAt" : "2019-02-25T21:40:03Z",
        "updatedAt" : "2019-02-25T21:40:03Z",
        "lastEditedBy" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "tags" : [
        ]
      },
      {
        "id" : "1dff45ac-723f-4832-9450-0b69d0c88808",
        "parentId" : "97627d2e-7c31-4849-9e2d-c4e77b634cee",
        "authorId" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "body" : "I discussed some more with @jingxu97, and she pointed out that even if we return error in ConstructVolumeSpec(), the volumeSpec will still be nil here, so we still need this check.\r\n\r\nIt looks like this check was introduced as part of CSI migration. 1) This should be feature gated, and 2) can `useCSIPlugin` return false if volume spec is nil? Does that make sense for all operations? cc @davidz627 ",
        "createdAt" : "2019-02-25T23:45:45Z",
        "updatedAt" : "2019-02-25T23:45:45Z",
        "lastEditedBy" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "tags" : [
        ]
      },
      {
        "id" : "841fc7f2-e3cd-4389-8410-81c352a04265",
        "parentId" : "97627d2e-7c31-4849-9e2d-c4e77b634cee",
        "authorId" : "542e5d2f-2ff9-4674-ab44-78f31768e7a1",
        "body" : "for 1) I've submitted a PR to make sure we do the migration feature gate check before doing anything else.\r\n\r\nFor 2) I think I need to do some more investigation and address it in the CSI Migration Reconstruction design.",
        "createdAt" : "2019-02-26T19:51:46Z",
        "updatedAt" : "2019-02-26T19:51:46Z",
        "lastEditedBy" : "542e5d2f-2ff9-4674-ab44-78f31768e7a1",
        "tags" : [
        ]
      }
    ],
    "commit" : "618917e210d59d4c3f76e8f854f99114405df92f",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +733,737 @@\n\tvar pluginName string\n\tif volumeToUnmount.VolumeSpec != nil && useCSIPlugin(og.volumePluginMgr, volumeToUnmount.VolumeSpec) {\n\t\tpluginName = csi.CSIPluginName\n\t} else {"
  },
  {
    "id" : "2dc0aaec-afec-4bc8-acd3-d9867e75c521",
    "prId" : 73284,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/73284#pullrequestreview-196724239",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "25ccd186-bcb9-4bfd-8dfe-febd9ba74e80",
        "parentId" : null,
        "authorId" : "542e5d2f-2ff9-4674-ab44-78f31768e7a1",
        "body" : "duplicated this error case?",
        "createdAt" : "2019-01-25T21:46:32Z",
        "updatedAt" : "2019-02-18T04:55:56Z",
        "lastEditedBy" : "542e5d2f-2ff9-4674-ab44-78f31768e7a1",
        "tags" : [
        ]
      }
    ],
    "commit" : "6355186c3e7a82608a438a0c54da9ad4f8cf134e",
    "line" : 15,
    "diffHunk" : "@@ -1,1 +526,530 @@\n\t\tvolumePlugin, err := og.volumePluginMgr.FindPluginBySpec(volumeToMount.VolumeSpec)\n\t\tif err != nil || volumePlugin == nil {\n\t\t\treturn volumeToMount.GenerateError(\"MountVolume.FindPluginBySpec failed\", err)\n\t\t}"
  },
  {
    "id" : "7b121e98-e66e-473e-88e2-86570ab840df",
    "prId" : 73284,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/73284#pullrequestreview-198848781",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "31b776ec-ba27-4db6-add3-668830c30d83",
        "parentId" : null,
        "authorId" : "542e5d2f-2ff9-4674-ab44-78f31768e7a1",
        "body" : "do we need to do any of this translation work if we're not using it afterwards?",
        "createdAt" : "2019-01-25T21:47:32Z",
        "updatedAt" : "2019-02-18T04:55:56Z",
        "lastEditedBy" : "542e5d2f-2ff9-4674-ab44-78f31768e7a1",
        "tags" : [
        ]
      },
      {
        "id" : "4b787118-b884-4f19-b67d-d4e57be5893f",
        "parentId" : "31b776ec-ba27-4db6-add3-668830c30d83",
        "authorId" : "41981c80-b404-4c55-bd22-5f96c0512a61",
        "body" : "csiSpec is used after the error check:\r\n```\r\ndeviceToDetach.VolumeSpec = csiSpec\r\n```",
        "createdAt" : "2019-01-31T22:33:12Z",
        "updatedAt" : "2019-02-18T04:55:56Z",
        "lastEditedBy" : "41981c80-b404-4c55-bd22-5f96c0512a61",
        "tags" : [
        ]
      }
    ],
    "commit" : "6355186c3e7a82608a438a0c54da9ad4f8cf134e",
    "line" : 58,
    "diffHunk" : "@@ -1,1 +802,806 @@\tif useCSIPlugin(og.volumePluginMgr, deviceToDetach.VolumeSpec) {\n\t\tpluginName = csi.CSIPluginName\n\t\tcsiSpec, err := translateSpec(deviceToDetach.VolumeSpec)\n\t\tif err != nil {\n\t\t\treturn volumetypes.GeneratedOperations{}, deviceToDetach.GenerateErrorDetailed(\"UnmountDevice.TranslateSpec failed\", err)"
  },
  {
    "id" : "9bd28394-e059-4083-ab81-d68ed6503f9d",
    "prId" : 73284,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/73284#pullrequestreview-199293161",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "eb00cb8a-5616-418c-9d5a-fe7f1ecbd89a",
        "parentId" : null,
        "authorId" : "542e5d2f-2ff9-4674-ab44-78f31768e7a1",
        "body" : "nit: remove space",
        "createdAt" : "2019-02-01T22:23:53Z",
        "updatedAt" : "2019-02-18T04:55:56Z",
        "lastEditedBy" : "542e5d2f-2ff9-4674-ab44-78f31768e7a1",
        "tags" : [
        ]
      }
    ],
    "commit" : "6355186c3e7a82608a438a0c54da9ad4f8cf134e",
    "line" : 74,
    "diffHunk" : "@@ -1,1 +817,821 @@\t\treturn volumetypes.GeneratedOperations{}, deviceToDetach.GenerateErrorDetailed(\"UnmountDevice.FindDeviceMountablePluginByName failed\", err)\n\t}\n\n\tvolumeDeviceUmounter, err := deviceMountableVolumePlugin.NewDeviceUnmounter()\n\tif err != nil {"
  },
  {
    "id" : "899323ea-51f3-4df2-a404-2a7cba18c22e",
    "prId" : 71581,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/71581#pullrequestreview-180249250",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "cabf4e1d-52de-4d80-be12-ecb33dece198",
        "parentId" : null,
        "authorId" : "8fc8f958-3c0e-47dd-a0fb-b8cc483b4efb",
        "body" : "Note for other reviewers: helpful to turn on \"Hide whitespace changes\" in github diff settings",
        "createdAt" : "2018-11-30T12:44:04Z",
        "updatedAt" : "2018-11-30T12:47:33Z",
        "lastEditedBy" : "8fc8f958-3c0e-47dd-a0fb-b8cc483b4efb",
        "tags" : [
        ]
      }
    ],
    "commit" : "2251bf0c214156e4ab92fd5e500355f4941140ec",
    "line" : 16,
    "diffHunk" : "@@ -1,1 +87,91 @@type OperationGenerator interface {\n\t// Generates the MountVolume function needed to perform the mount of a volume plugin\n\tGenerateMountVolumeFunc(waitForAttachTimeout time.Duration, volumeToMount VolumeToMount, actualStateOfWorldMounterUpdater ActualStateOfWorldMounterUpdater, isRemount bool) volumetypes.GeneratedOperations\n\n\t// Generates the UnmountVolume function needed to perform the unmount of a volume plugin"
  },
  {
    "id" : "959bf33b-0627-4cbf-a802-675e2afca675",
    "prId" : 71276,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/71276#pullrequestreview-191424331",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a1bf7963-2622-4394-b85a-ef2df2ddf82c",
        "parentId" : null,
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "`DanglingAttachError` results in `MarkVolumeAsAttached`. Do we still want to do `MarkVolumeAsUncertain(...)` in that case?",
        "createdAt" : "2019-01-10T00:09:23Z",
        "updatedAt" : "2019-01-11T18:57:57Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      },
      {
        "id" : "2c8ebc9c-ea88-47fe-8115-5a184d1301c4",
        "parentId" : "a1bf7963-2622-4394-b85a-ef2df2ddf82c",
        "authorId" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "body" : "We don't need to. I modified it. PTAL",
        "createdAt" : "2019-01-10T21:31:39Z",
        "updatedAt" : "2019-01-11T18:57:57Z",
        "lastEditedBy" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "tags" : [
        ]
      }
    ],
    "commit" : "7bac6ca73ad6fa1b0b637e801a524d6a1df663ea",
    "line" : 2,
    "diffHunk" : "@@ -1,1 +321,325 @@\t\t\t\tif addErr != nil {\n\t\t\t\t\tklog.Errorf(\"AttachVolume.MarkVolumeAsAttached failed to fix dangling volume error for volume %q with %s\", volumeToAttach.VolumeName, addErr)\n\t\t\t\t}\n\n\t\t\t} else {"
  },
  {
    "id" : "1465dccb-bc8e-4b28-bb60-02a0407a2644",
    "prId" : 71276,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/71276#pullrequestreview-191411763",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7aa54418-1018-46d3-91eb-85700bbc00fe",
        "parentId" : null,
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "What about Detach failures? Should they also result in `MarkVolumeAsUncertain`?",
        "createdAt" : "2019-01-10T01:34:54Z",
        "updatedAt" : "2019-01-11T18:57:57Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      },
      {
        "id" : "f8a9443a-3202-4fda-81b3-7699ab4ef6d0",
        "parentId" : "7aa54418-1018-46d3-91eb-85700bbc00fe",
        "authorId" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "body" : "I don't think so. If detach failed or timed out, attach/detach controller just does not remove the volume from actual state. We don't need to use MarkVolumeAsUncertain to add it since the volume is already in actual state. Then in the next iteration, attach/detach controller just trigger a detach operation again.",
        "createdAt" : "2019-01-10T20:59:10Z",
        "updatedAt" : "2019-01-11T18:57:57Z",
        "lastEditedBy" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "tags" : [
        ]
      }
    ],
    "commit" : "7bac6ca73ad6fa1b0b637e801a524d6a1df663ea",
    "line" : 12,
    "diffHunk" : "@@ -1,1 +331,335 @@\t\t\t}\n\t\t\t// On failure, return error. Caller will log and retry.\n\t\t\treturn volumeToAttach.GenerateError(\"AttachVolume.Attach failed\", attachErr)\n\t\t}\n"
  },
  {
    "id" : "c0428006-1c14-4b3b-97cf-197ccd6ef8a1",
    "prId" : 69830,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/69830#pullrequestreview-166760813",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "da5c43c5-bfa9-4d31-bdaa-c899336c583d",
        "parentId" : null,
        "authorId" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "body" : "Well, the easiest is to mandate that migration of PVs and inline volumes for a plugin must happen at the same time. Otherwise it gets really messy.",
        "createdAt" : "2018-10-16T09:17:48Z",
        "updatedAt" : "2019-02-15T01:04:36Z",
        "lastEditedBy" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "tags" : [
        ]
      },
      {
        "id" : "b40d76db-525f-4a21-ba06-308893400cc5",
        "parentId" : "da5c43c5-bfa9-4d31-bdaa-c899336c583d",
        "authorId" : "542e5d2f-2ff9-4674-ab44-78f31768e7a1",
        "body" : "It is hard to do that since CSI In-line volume support is also going alpha this quarter so the dependency there is kind of tight. I guess during Q4 alpha of migration this specific functionality can be broken and fixed in 1.14. It is a non-standard codepath anyway (only hit on A/D controller restart when pod was deleted in meantime).\r\n/cc @saad-ali ",
        "createdAt" : "2018-10-17T18:14:35Z",
        "updatedAt" : "2019-02-15T01:04:36Z",
        "lastEditedBy" : "542e5d2f-2ff9-4674-ab44-78f31768e7a1",
        "tags" : [
        ]
      },
      {
        "id" : "f039b290-4dab-4aa0-abb9-c62b59b412d1",
        "parentId" : "da5c43c5-bfa9-4d31-bdaa-c899336c583d",
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "Coupling this feature with the CSI inline feature will slow everything down. This case is an edge case. Let's document it as a known issue with the alpha release.",
        "createdAt" : "2018-10-17T21:49:44Z",
        "updatedAt" : "2019-02-15T01:04:36Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      },
      {
        "id" : "6767fc28-dbe1-4dfb-8da0-296032446bfb",
        "parentId" : "da5c43c5-bfa9-4d31-bdaa-c899336c583d",
        "authorId" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "body" : "It's ok for alpha to develop them separately, but IMO inline volumes should go beta and GA before or together with the migration. It's not full feature if you migrate just the easier part :-).",
        "createdAt" : "2018-10-18T07:28:11Z",
        "updatedAt" : "2019-02-15T01:04:36Z",
        "lastEditedBy" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "tags" : [
        ]
      },
      {
        "id" : "a1a23559-ddab-4caa-bef9-94f66206582e",
        "parentId" : "da5c43c5-bfa9-4d31-bdaa-c899336c583d",
        "authorId" : "542e5d2f-2ff9-4674-ab44-78f31768e7a1",
        "body" : "@jsafrane we plan to have in-line volumes migrated by Q1 for alpha as well. Ideally they will go Beta together Q2",
        "createdAt" : "2018-10-20T20:00:42Z",
        "updatedAt" : "2019-02-15T01:04:36Z",
        "lastEditedBy" : "542e5d2f-2ff9-4674-ab44-78f31768e7a1",
        "tags" : [
        ]
      }
    ],
    "commit" : "5dde1df1cd438b7c2749fc08ad1d6bd8b173d010",
    "line" : 121,
    "diffHunk" : "@@ -1,1 +439,443 @@\t\t// TODO(dyzz): This case can't distinguish between PV and In-line which is necessary because\n\t\t// if it was PV it may have been migrated, but the same plugin with in-line may not have been.\n\t\t// Suggestions welcome...\n\t\tif csilib.IsMigratableByName(pluginName) && utilfeature.DefaultFeatureGate.Enabled(features.CSIMigration) {\n\t\t\t// The volume represented by this spec is CSI and thus should be migrated"
  },
  {
    "id" : "9165c101-cb84-4088-91ce-29e6044d6ac0",
    "prId" : 69830,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/69830#pullrequestreview-173596055",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8b41dfb1-ab9d-4d34-a34c-4a017f61f7c1",
        "parentId" : null,
        "authorId" : "41981c80-b404-4c55-bd22-5f96c0512a61",
        "body" : "Im wondering why do we need to `MarkVolumeAsAttached` with `originalSpec` but not migrated spec?",
        "createdAt" : "2018-11-07T05:52:23Z",
        "updatedAt" : "2019-02-15T01:04:36Z",
        "lastEditedBy" : "41981c80-b404-4c55-bd22-5f96c0512a61",
        "tags" : [
        ]
      },
      {
        "id" : "219e6bfa-3f7b-41a4-b1a9-53e67a430b73",
        "parentId" : "8b41dfb1-ab9d-4d34-a34c-4a017f61f7c1",
        "authorId" : "542e5d2f-2ff9-4674-ab44-78f31768e7a1",
        "body" : "since in desired state of world the desired volume is the original volume, we want to mark the original volume as attached. Otherwise the reconciler will continuously try to attach the object since we \"desire the in-tree volume to be attached\" and we have \"actually attached the CSI volume\"",
        "createdAt" : "2018-11-09T21:22:35Z",
        "updatedAt" : "2019-02-15T01:04:36Z",
        "lastEditedBy" : "542e5d2f-2ff9-4674-ab44-78f31768e7a1",
        "tags" : [
        ]
      }
    ],
    "commit" : "5dde1df1cd438b7c2749fc08ad1d6bd8b173d010",
    "line" : 76,
    "diffHunk" : "@@ -1,1 +370,374 @@\t\t// Update actual state of world\n\t\taddVolumeNodeErr := actualStateOfWorld.MarkVolumeAsAttached(\n\t\t\tv1.UniqueVolumeName(\"\"), originalSpec, volumeToAttach.NodeName, devicePath)\n\t\tif addVolumeNodeErr != nil {\n\t\t\t// On failure, return error. Caller will log and retry."
  },
  {
    "id" : "af363140-b5d4-41ab-9aa7-597323f20ed5",
    "prId" : 69830,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/69830#pullrequestreview-173595655",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "aaf8734b-24e4-41b5-81eb-2d1558ce2e6e",
        "parentId" : null,
        "authorId" : "41981c80-b404-4c55-bd22-5f96c0512a61",
        "body" : "I feels its more explicit/simply to do a translation from in-tree volume name to csi volume name in this case. This could be a new method provided by translation library. With this, the magic `isAttachment` logic in csi plugin is also avoided. ",
        "createdAt" : "2018-11-09T20:08:36Z",
        "updatedAt" : "2019-02-15T01:04:36Z",
        "lastEditedBy" : "41981c80-b404-4c55-bd22-5f96c0512a61",
        "tags" : [
        ]
      },
      {
        "id" : "01e2fe21-0e58-42d0-81d3-dbc4937a3baf",
        "parentId" : "aaf8734b-24e4-41b5-81eb-2d1558ce2e6e",
        "authorId" : "542e5d2f-2ff9-4674-ab44-78f31768e7a1",
        "body" : "Hmmm I think this might be possible:\r\nFor example for GCE the volume name will be the `PDName`, for CSI it will be `driverName^volumeHandle^` where the volume handle is the volume ID the driver returns which for GCE contains the project, zone, and PDName.\r\nHowever I dont know if all volumes will be able to have all the information from the volume name translated from in-tree to CSI and vice-versa...",
        "createdAt" : "2018-11-09T21:21:19Z",
        "updatedAt" : "2019-02-15T01:04:36Z",
        "lastEditedBy" : "542e5d2f-2ff9-4674-ab44-78f31768e7a1",
        "tags" : [
        ]
      }
    ],
    "commit" : "5dde1df1cd438b7c2749fc08ad1d6bd8b173d010",
    "line" : 131,
    "diffHunk" : "@@ -1,1 +449,453 @@\t\t\t// therefore a workaround is required. volumeToDetach.DevicePath\n\t\t\t// is the attachID which happens to be what volumeName is needed for in Detach.\n\t\t\t// Therefore we set volumeName to the attachID. And CSI Detach can detect and use that.\n\t\t\tvolumeName = volumeToDetach.DevicePath\n\t\t} else {"
  },
  {
    "id" : "d0173d3e-6aad-41f0-8d65-8c8302f7836d",
    "prId" : 69830,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/69830#pullrequestreview-201336582",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c97f4691-6142-4dd6-ab5d-ac4370f919ca",
        "parentId" : null,
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "Why isn't `originalSpec` saved and used later for detach?",
        "createdAt" : "2019-02-06T21:25:50Z",
        "updatedAt" : "2019-02-15T01:04:36Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      },
      {
        "id" : "b8b36366-2347-4a47-8239-efb9f085cc60",
        "parentId" : "c97f4691-6142-4dd6-ab5d-ac4370f919ca",
        "authorId" : "542e5d2f-2ff9-4674-ab44-78f31768e7a1",
        "body" : "we only need `volumeToDetach.VolumeName` to remove the volume from `actualStateOfWorld` here and we don't modify the original `volumeToDetach` at any point.\r\n\r\n`originalSpec` is saved in other operations in order to add to `asw`",
        "createdAt" : "2019-02-07T21:36:25Z",
        "updatedAt" : "2019-02-15T01:04:36Z",
        "lastEditedBy" : "542e5d2f-2ff9-4674-ab44-78f31768e7a1",
        "tags" : [
        ]
      }
    ],
    "commit" : "5dde1df1cd438b7c2749fc08ad1d6bd8b173d010",
    "line" : 101,
    "diffHunk" : "@@ -1,1 +414,418 @@\t\t\t}\n\n\t\t\tvolumeToDetach.VolumeSpec = csiSpec\n\t\t} else {\n\t\t\tattachableVolumePlugin, err ="
  },
  {
    "id" : "18fd570f-b812-487d-9b3f-8ae7515594c1",
    "prId" : 69830,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/69830#pullrequestreview-201336864",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3ac2d887-ffd3-4c37-9483-e3b9f8e573c7",
        "parentId" : null,
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "This code needs to be updated. `MarkVolumeAsUncertain(...)` was added since this PR was opened.",
        "createdAt" : "2019-02-06T21:29:44Z",
        "updatedAt" : "2019-02-15T01:04:36Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      },
      {
        "id" : "0bde9c18-02b8-4b76-b649-b830b3f4e2c7",
        "parentId" : "3ac2d887-ffd3-4c37-9483-e3b9f8e573c7",
        "authorId" : "542e5d2f-2ff9-4674-ab44-78f31768e7a1",
        "body" : "good catch, thanks",
        "createdAt" : "2019-02-07T21:37:10Z",
        "updatedAt" : "2019-02-15T01:04:36Z",
        "lastEditedBy" : "542e5d2f-2ff9-4674-ab44-78f31768e7a1",
        "tags" : [
        ]
      }
    ],
    "commit" : "5dde1df1cd438b7c2749fc08ad1d6bd8b173d010",
    "line" : 72,
    "diffHunk" : "@@ -1,1 +367,371 @@\t\t}\n\t\tklog.Infof(volumeToAttach.GenerateMsgDetailed(\"AttachVolume.Attach succeeded\", \"\"))\n\n\t\t// Update actual state of world\n\t\taddVolumeNodeErr := actualStateOfWorld.MarkVolumeAsAttached("
  },
  {
    "id" : "63ea8fa5-40bf-463b-99fe-1912759a15e9",
    "prId" : 69115,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/69115#pullrequestreview-161384169",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ffc33443-8d55-4b92-b2ef-fa841ed95d87",
        "parentId" : null,
        "authorId" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "body" : "Can you add a comment explaining that we need to call TearDownDevice afterwards because plugins that do local attach/detach will fail due to the refcnt on the loopback device.",
        "createdAt" : "2018-10-03T18:08:31Z",
        "updatedAt" : "2018-10-03T22:36:43Z",
        "lastEditedBy" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "tags" : [
        ]
      },
      {
        "id" : "bb1a90b3-42f9-4d32-bc9a-a28ffd3b57d0",
        "parentId" : "ffc33443-8d55-4b92-b2ef-fa841ed95d87",
        "authorId" : "9ce7bd1a-5286-4173-88a4-039146bf0d46",
        "body" : "I will add a comment.",
        "createdAt" : "2018-10-03T22:15:16Z",
        "updatedAt" : "2018-10-03T22:36:43Z",
        "lastEditedBy" : "9ce7bd1a-5286-4173-88a4-039146bf0d46",
        "tags" : [
        ]
      }
    ],
    "commit" : "4226ae7a6114413f1b4a3b06fe578b9ee4b7ba67",
    "line" : 29,
    "diffHunk" : "@@ -1,1 +1101,1105 @@\t\t}\n\n\t\t// Execute tear down device\n\t\tunmapErr := blockVolumeUnmapper.TearDownDevice(globalMapPath, deviceToDetach.DevicePath)\n\t\tif unmapErr != nil {"
  },
  {
    "id" : "aa27bb56-f5ca-4515-8caf-712034125a8b",
    "prId" : 67851,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/67851#pullrequestreview-152741313",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f5a7064b-e07c-4fe0-a3c9-cda983348a0c",
        "parentId" : null,
        "authorId" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "body" : "Can this entire if-else be solved by a instance of flexvolume plugin that is returned via `FindExapndablePlugin` call and performs a no-op resize when called and returns with success response?\r\n\r\n",
        "createdAt" : "2018-09-04T18:36:53Z",
        "updatedAt" : "2018-10-25T18:50:19Z",
        "lastEditedBy" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "tags" : [
        ]
      },
      {
        "id" : "2c441386-9582-4773-b196-16cbfb0e6d3f",
        "parentId" : "f5a7064b-e07c-4fe0-a3c9-cda983348a0c",
        "authorId" : "e24e46b9-2cd5-4377-bed6-b6507631afa9",
        "body" : "@gnufied to install a fake/no-op flexvolume plugin on the controller that will be found via `FindExpandablePlugin` for any driver name in the Spec - we'd have to do something like `if Spec.IsKubeletExpandable() { return noopExpandableInstance{} }` inside `FindExpandablePlugin`\r\n\r\nIf that's fine I will make that change. ",
        "createdAt" : "2018-09-06T01:07:15Z",
        "updatedAt" : "2018-10-25T18:50:19Z",
        "lastEditedBy" : "e24e46b9-2cd5-4377-bed6-b6507631afa9",
        "tags" : [
        ]
      }
    ],
    "commit" : "82f83a8f82640f94e582011edeb90e5cefd031ef",
    "line" : 57,
    "diffHunk" : "@@ -1,1 +1259,1263 @@\tif volumePlugin == nil {\n\t\treturn volumetypes.GeneratedOperations{}, fmt.Errorf(\"Can not find plugin for expanding volume: %q\", pvcWithResizeRequest.QualifiedName())\n\t}\n\n\texpandVolumeFunc := func() (error, error) {"
  },
  {
    "id" : "893205bf-15f1-4d29-bdfc-77dcd79709f9",
    "prId" : 66928,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/66928#pullrequestreview-244060907",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "89556554-8822-486c-8d6d-6f1e2ffb129d",
        "parentId" : null,
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "You don't have to add this argument here. It should be available via the `emptyDir` data structure in the `SetUp` method",
        "createdAt" : "2019-05-30T20:03:52Z",
        "updatedAt" : "2019-05-30T20:13:00Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      },
      {
        "id" : "efac5a80-646c-4a32-8e86-36bba8de7b9b",
        "parentId" : "89556554-8822-486c-8d6d-6f1e2ffb129d",
        "authorId" : "4aab55a0-5299-4d58-b630-6d54a352dba8",
        "body" : "If you want, I can remove it; I agree it's not really needed here.",
        "createdAt" : "2019-05-30T21:13:14Z",
        "updatedAt" : "2019-05-30T21:13:14Z",
        "lastEditedBy" : "4aab55a0-5299-4d58-b630-6d54a352dba8",
        "tags" : [
        ]
      },
      {
        "id" : "c3397761-e464-4805-882a-1c247d929e28",
        "parentId" : "89556554-8822-486c-8d6d-6f1e2ffb129d",
        "authorId" : "4aab55a0-5299-4d58-b630-6d54a352dba8",
        "body" : "As for accumulating quotas, it's not impossible that something could go wrong with the teardown and leave the quota in place applying to nothing.  It is possible to remove quotas later if need be.  We leave records in /etc/projects and /etc/projid with clearly defined names to make it possible to trace back to Kubernetes.",
        "createdAt" : "2019-05-30T21:19:16Z",
        "updatedAt" : "2019-05-30T21:19:17Z",
        "lastEditedBy" : "4aab55a0-5299-4d58-b630-6d54a352dba8",
        "tags" : [
        ]
      },
      {
        "id" : "f33496fd-953a-4d8f-b341-02f92513401f",
        "parentId" : "89556554-8822-486c-8d6d-6f1e2ffb129d",
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "> If you want, I can remove it; I agree it's not really needed here.\r\n\r\nIf you have time go for it, happy to reapply lgtm/approval. If not, no big deal.",
        "createdAt" : "2019-05-30T22:28:39Z",
        "updatedAt" : "2019-05-30T22:28:39Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      }
    ],
    "commit" : "38753efcc758e16cb501906b9a1aabb7308a0246",
    "line" : 8,
    "diffHunk" : "@@ -1,1 +705,709 @@\t\t\tFsGroup:     fsGroup,\n\t\t\tDesiredSize: volumeToMount.DesiredSizeLimit,\n\t\t\tPodUID:      string(volumeToMount.Pod.UID),\n\t\t})\n\t\tif mountErr != nil {"
  },
  {
    "id" : "80975725-2fb0-4cf5-804f-194beb55a675",
    "prId" : 66884,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/66884#pullrequestreview-145910037",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "92ce4154-8b99-44dd-bf82-e34500124422",
        "parentId" : null,
        "authorId" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "body" : "Can you add unit tests for these new plugin scenarios?",
        "createdAt" : "2018-08-13T19:55:27Z",
        "updatedAt" : "2018-08-14T03:15:11Z",
        "lastEditedBy" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "tags" : [
        ]
      },
      {
        "id" : "40403547-a8d4-4dea-bd45-6d6232e36394",
        "parentId" : "92ce4154-8b99-44dd-bf82-e34500124422",
        "authorId" : "cf088828-7f69-4b6e-8956-1842c94daa02",
        "body" : "I am not sure i understand the `scenarios`. Just added some UTs for Concurrent Mount operations for devicemountable plugins in the third commit. PTAL, thanks",
        "createdAt" : "2018-08-14T02:58:46Z",
        "updatedAt" : "2018-08-14T03:15:11Z",
        "lastEditedBy" : "cf088828-7f69-4b6e-8956-1842c94daa02",
        "tags" : [
        ]
      },
      {
        "id" : "d75679c3-746c-426a-9db5-97aeebed1581",
        "parentId" : "92ce4154-8b99-44dd-bf82-e34500124422",
        "authorId" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "body" : "I mean adding test cases for DeviceMountable-only plugins for Mount and Unmount  To ensure that we have correctly decoupled the attacher",
        "createdAt" : "2018-08-14T03:21:54Z",
        "updatedAt" : "2018-08-14T03:21:54Z",
        "lastEditedBy" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "tags" : [
        ]
      },
      {
        "id" : "8b9aec73-2b54-4f17-8f26-548eb37fd43f",
        "parentId" : "92ce4154-8b99-44dd-bf82-e34500124422",
        "authorId" : "cf088828-7f69-4b6e-8956-1842c94daa02",
        "body" : "We haven't implemented any DeviceMountable-only plugins for now, this PR is just interface refactor. We can add these UTs in my another PR: https://github.com/kubernetes/kubernetes/pull/63011\r\nWDYT ?",
        "createdAt" : "2018-08-14T04:03:59Z",
        "updatedAt" : "2018-08-14T04:03:59Z",
        "lastEditedBy" : "cf088828-7f69-4b6e-8956-1842c94daa02",
        "tags" : [
        ]
      }
    ],
    "commit" : "55784f88d443c4d9b6c5263721c0256faa935aa0",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +480,484 @@\n\t// get deviceMounter, if possible\n\tdeviceMountableVolumePlugin, _ := og.volumePluginMgr.FindDeviceMountablePluginBySpec(volumeToMount.VolumeSpec)\n\tvar volumeDeviceMounter volume.DeviceMounter\n\tif deviceMountableVolumePlugin != nil {"
  },
  {
    "id" : "dbfdafce-210c-49af-a93f-b2b92424b0b2",
    "prId" : 64094,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/64094#pullrequestreview-125700395",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1a55eb3d-0072-47cc-8293-4cc544304aeb",
        "parentId" : null,
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "`devicePath` comes from `volumeAttacher.WaitForAttach(...)` or `blockVolumeMapper.SetUpDevice()`. Is that correct? Will all plugins return `devicePath` in one of those functions? Will CSI?",
        "createdAt" : "2018-06-04T18:17:06Z",
        "updatedAt" : "2018-06-04T18:18:09Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      },
      {
        "id" : "510b0a78-78ff-4f44-8315-7d4cbf27a2bb",
        "parentId" : "1a55eb3d-0072-47cc-8293-4cc544304aeb",
        "authorId" : "54b8eb75-28dd-421d-a52b-63bf897147a9",
        "body" : "The original code assumes that devicePath comes from either a `volumeAttacher.WaitForAttach(...)` or from `blockVolumeMapper.SetupDevice()` .  If neither one return a path, code errors out.  So yes, it is a assume that a `blockVolumeMapper` will return a deviceMap.\r\n\r\nSince CSI does not return a devicePath with `WaitForAttach`, it uses `SetupDevice` to return the global map path (which is the path sent to the external driver for NodeStage call).",
        "createdAt" : "2018-06-04T18:36:15Z",
        "updatedAt" : "2018-06-04T18:36:15Z",
        "lastEditedBy" : "54b8eb75-28dd-421d-a52b-63bf897147a9",
        "tags" : [
        ]
      },
      {
        "id" : "32cbea30-fa6d-4ed7-9077-bfd7ebfb3104",
        "parentId" : "1a55eb3d-0072-47cc-8293-4cc544304aeb",
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "Ack!",
        "createdAt" : "2018-06-04T18:55:41Z",
        "updatedAt" : "2018-06-04T18:55:41Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      }
    ],
    "commit" : "3569287993ed5b04e85473a3d29c2a6cb441498f",
    "line" : 30,
    "diffHunk" : "@@ -1,1 +864,868 @@\t\t}\n\t\tif len(devicePath) == 0 {\n\t\t\treturn volumeToMount.GenerateError(\"MapVolume failed\", fmt.Errorf(\"Device path of the volume is empty\"))\n\t\t}\n"
  },
  {
    "id" : "bfabe389-95a3-4061-a70e-96078b378be7",
    "prId" : 62460,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/62460#pullrequestreview-122555495",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4c33fdac-045d-481d-8aa1-c607a3657af6",
        "parentId" : null,
        "authorId" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "body" : "ah now I see this. I am not sure `volume_fs_resize` name is consistent with how other metric names are generated here.",
        "createdAt" : "2018-05-22T15:02:54Z",
        "updatedAt" : "2018-05-31T09:12:23Z",
        "lastEditedBy" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "tags" : [
        ]
      },
      {
        "id" : "502bdffb-208a-46fa-acbd-4f5c09119a83",
        "parentId" : "4c33fdac-045d-481d-8aa1-c607a3657af6",
        "authorId" : "ea65316b-7fdf-4fe0-99b0-2d437bf2580e",
        "body" : "I think this name is consistent with other metrics, such as `volume_provision`, `volume_delete`, etc.",
        "createdAt" : "2018-05-23T12:17:00Z",
        "updatedAt" : "2018-05-31T09:12:23Z",
        "lastEditedBy" : "ea65316b-7fdf-4fe0-99b0-2d437bf2580e",
        "tags" : [
        ]
      }
    ],
    "commit" : "ca12c733239e8de8a5d20c0588d87b420075c614",
    "line" : 66,
    "diffHunk" : "@@ -1,1 +1362,1366 @@\t\tOperationFunc:     fsResizeFunc,\n\t\tEventRecorderFunc: eventRecorderFunc,\n\t\tCompleteFunc:      util.OperationCompleteHook(volumePlugin.GetPluginName(), \"volume_fs_resize\"),\n\t}, nil\n}"
  },
  {
    "id" : "807291f3-b687-4c9a-ab05-35eae2137a48",
    "prId" : 60036,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/60036#pullrequestreview-97931034",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d52c3574-f4f9-4d8d-a10c-16013d221372",
        "parentId" : null,
        "authorId" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "body" : "On reconstruction, how does this get set?",
        "createdAt" : "2018-02-20T18:07:05Z",
        "updatedAt" : "2018-02-20T18:07:09Z",
        "lastEditedBy" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "tags" : [
        ]
      },
      {
        "id" : "dea130fe-0da0-438c-8a42-423c1cc73e01",
        "parentId" : "d52c3574-f4f9-4d8d-a10c-16013d221372",
        "authorId" : "967a712d-9784-41d4-920d-42eaba99fb24",
        "body" : "I'd like to separate PR for `non-attachable plugin problem` and `volume reconstruction problem` to fix local volume plugin's problem quickly. This PR only fix local volume plugin problem.\r\n\r\nDuring reconstruction path, if the volumeMode is `Block`, kubelet can't find  globalUnmapPath without volumeSpec. Therefore, I think we should return error during `cleanupMounts()` for Block volume case. But I think we need to discuss with @jingxu97 about the fix.\r\n\r\n",
        "createdAt" : "2018-02-20T18:10:07Z",
        "updatedAt" : "2018-02-20T18:12:30Z",
        "lastEditedBy" : "967a712d-9784-41d4-920d-42eaba99fb24",
        "tags" : [
        ]
      }
    ],
    "commit" : "9ad102717fd16334174a1fc03c996196ff057f80",
    "line" : 31,
    "diffHunk" : "@@ -1,1 +961,965 @@\t\t// Try to unmap podUID symlink under global map path dir\n\t\t// plugins/kubernetes.io/{PluginName}/volumeDevices/{volumePluginDependentPath}/{podUID}\n\t\tglobalUnmapPath := volumeToUnmount.DeviceMountPath\n\t\tunmapDeviceErr = og.blkUtil.UnmapDevice(globalUnmapPath, string(volumeToUnmount.PodUID))\n\t\tif unmapDeviceErr != nil {"
  },
  {
    "id" : "97cdf1a8-3bab-4fab-a388-1057f50f95ce",
    "prId" : 60036,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/60036#pullrequestreview-98039054",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "dcaa50bc-b282-4e76-8dec-64364cf64d4e",
        "parentId" : null,
        "authorId" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "body" : "somehow my comment is not showing up.\r\nMy only concern is by moving actualStateOfWorld.MarkDeviceAsMounted() later, if any failure happened above it, actualstate will not have a record of this globalMapPath. \r\nMaybe it will be more clear if the code can show where part is for attachable and which part is for non-attacable, and when we should update the actual state.",
        "createdAt" : "2018-02-21T00:18:51Z",
        "updatedAt" : "2018-02-21T00:18:51Z",
        "lastEditedBy" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "tags" : [
        ]
      }
    ],
    "commit" : "9ad102717fd16334174a1fc03c996196ff057f80",
    "line" : 18,
    "diffHunk" : "@@ -1,1 +853,857 @@\t\t\t}\n\t\t}\n\t\t// Update actual state of world to reflect volume is globally mounted\n\t\tmarkDeviceMappedErr := actualStateOfWorld.MarkDeviceAsMounted(\n\t\t\tvolumeToMount.VolumeName, devicePath, globalMapPath)"
  },
  {
    "id" : "1aeaf8c5-06a8-4481-ab8d-91ec9753bb50",
    "prId" : 58177,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/58177#pullrequestreview-91364275",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "210e5678-053d-4cd0-a272-b87425705d95",
        "parentId" : null,
        "authorId" : "967a712d-9784-41d4-920d-42eaba99fb24",
        "body" : "Before MapDevice(), `len(globalMapPath)` should be checked. If globalMapPath is empty, we have to call blockVolumeMapper.GetGlobalMapPath() for non-attachable plugin too. Otherwise MapDevice fails.",
        "createdAt" : "2018-01-24T22:02:34Z",
        "updatedAt" : "2018-02-05T21:14:19Z",
        "lastEditedBy" : "967a712d-9784-41d4-920d-42eaba99fb24",
        "tags" : [
        ]
      },
      {
        "id" : "8668d140-8fb8-42f7-b4a2-66bc609b50ab",
        "parentId" : "210e5678-053d-4cd0-a272-b87425705d95",
        "authorId" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "body" : "I see. One question is what is the purpose of blockVolumeMapper.SetUpDevice()? All block volume plugins do nothing and returns empty string.",
        "createdAt" : "2018-01-24T22:19:11Z",
        "updatedAt" : "2018-02-05T21:14:19Z",
        "lastEditedBy" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "tags" : [
        ]
      },
      {
        "id" : "796a3864-38cb-474a-8c73-7617bc05153d",
        "parentId" : "210e5678-053d-4cd0-a272-b87425705d95",
        "authorId" : "967a712d-9784-41d4-920d-42eaba99fb24",
        "body" : "If plugin is non-attachable, the plugin should implement SetUpDevice() to attach ~and mount~ volume to kubelet node. This is the same purpose of SetUp() for Filesystem volume.\r\n\r\n>> All block volume plugins do nothing and returns empty string.\r\n\r\nyeah, currently we only have attachable plugins for block, so the method is empty.",
        "createdAt" : "2018-01-24T22:24:47Z",
        "updatedAt" : "2018-02-05T21:14:19Z",
        "lastEditedBy" : "967a712d-9784-41d4-920d-42eaba99fb24",
        "tags" : [
        ]
      },
      {
        "id" : "83f5026d-35f7-4646-9cfa-de64be53dc00",
        "parentId" : "210e5678-053d-4cd0-a272-b87425705d95",
        "authorId" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "body" : "If SetUpDevice() is also attach volume to kubelet node, what is the difference between attachable and non-attachable? For attachable plugins since SetUpDevice does nothing, we don't need to call it. Also the current workflow is that for attachable plugins, \r\n1. waitForAttach(): attach volume\r\n2. SetUpDevice(): does nothing\r\n3. MapDevice(): called twice\r\n4. AttachFileDevice()\r\nWhy not put at least 3 and 4 into same volume plugin function? If possible, I think we should just put one function for volume.Setup() and one function for volume.Teardown() since all the steps are done one the node side. ",
        "createdAt" : "2018-01-24T22:50:51Z",
        "updatedAt" : "2018-02-05T21:14:19Z",
        "lastEditedBy" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "tags" : [
        ]
      },
      {
        "id" : "2048afbb-8c2e-4236-a8b6-f2ca5cd5a5d6",
        "parentId" : "210e5678-053d-4cd0-a272-b87425705d95",
        "authorId" : "967a712d-9784-41d4-920d-42eaba99fb24",
        "body" : "@jingxu97 \r\nSince 3 and 4 are common operations for both attachable and non-attachable plugins, we decided to implement these in operation generator instead of in each plugin side.\r\n\r\n- 3  MapDevice(): create symbolic link for global map path and pod device map path\r\n- 4  AttachFileDevice(): Create loop device for attached volume on kubelet node\r\n\r\nAs a result, attachable plugins don't need anything in SetUpDevice(), and non-attachable plugin only do attach during SetUpDevice().\r\nOther operations are taken care by kubelet side.\r\n\r\n@msau42\r\nAny additional comments?",
        "createdAt" : "2018-01-24T23:07:50Z",
        "updatedAt" : "2018-02-05T21:14:19Z",
        "lastEditedBy" : "967a712d-9784-41d4-920d-42eaba99fb24",
        "tags" : [
        ]
      }
    ],
    "commit" : "9588d2098a64c579ed351ba946dc900db79700f7",
    "line" : 78,
    "diffHunk" : "@@ -1,1 +862,866 @@\t\t}\n\n\t\tmapErr = og.blkUtil.MapDevice(devicePath, globalMapPath, string(volumeToMount.Pod.UID))\n\t\tif mapErr != nil {\n\t\t\t// On failure, return error. Caller will log and retry."
  },
  {
    "id" : "45b31198-4b4d-4155-b926-cb2c8273dc8e",
    "prId" : 57260,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/57260#pullrequestreview-84290386",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4652b495-8680-49c8-bfab-09db6698c249",
        "parentId" : null,
        "authorId" : "e2ca6907-6765-444e-8bf6-1452233150d6",
        "body" : "@saad-ali @davidz627  - maybe we should wait until the new event [design proposal](https://github.com/kubernetes/community/blob/master/contributors/design-proposals/instrumentation/events-redesign.md) is out ?",
        "createdAt" : "2017-12-18T17:55:20Z",
        "updatedAt" : "2017-12-18T19:41:16Z",
        "lastEditedBy" : "e2ca6907-6765-444e-8bf6-1452233150d6",
        "tags" : [
        ]
      },
      {
        "id" : "1b745f65-ab5e-4174-b2b4-72e25972175e",
        "parentId" : "4652b495-8680-49c8-bfab-09db6698c249",
        "authorId" : "542e5d2f-2ff9-4674-ab44-78f31768e7a1",
        "body" : "Looks like the design proposal is trying to improve event performance as well as improve dev insight into the app.\r\n\r\nI believe this event should not impact performance significantly as it is a one-time success event on volume attach (which does not happen often or repeatedly). \r\n\r\nAdditionally it gives developers greater insight into debugging their app, as they can now tell in various volume failure modes whether the volume has been attached or not. Specifically: if a volume is successfully attached but a mount call was never made, without this event a developer would have no way of knowing whether an attach call was made, or if the volume is attached anywhere.",
        "createdAt" : "2017-12-18T19:47:33Z",
        "updatedAt" : "2017-12-18T19:47:33Z",
        "lastEditedBy" : "542e5d2f-2ff9-4674-ab44-78f31768e7a1",
        "tags" : [
        ]
      },
      {
        "id" : "8abff7e2-a010-44ba-afa4-7c2ea369ec61",
        "parentId" : "4652b495-8680-49c8-bfab-09db6698c249",
        "authorId" : "e2ca6907-6765-444e-8bf6-1452233150d6",
        "body" : "@davidz627 - the design proposal will introduce a new `#eventf()` that will handle event series. we'll have to migrate to it.\r\n\r\nbut I guess we can add it for now, and migrate it later.",
        "createdAt" : "2017-12-18T21:47:15Z",
        "updatedAt" : "2017-12-18T21:47:16Z",
        "lastEditedBy" : "e2ca6907-6765-444e-8bf6-1452233150d6",
        "tags" : [
        ]
      },
      {
        "id" : "cfe7e9d5-0f02-4f88-bda3-864965335565",
        "parentId" : "4652b495-8680-49c8-bfab-09db6698c249",
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "Agreed, I wouldn't block on this. We'll have to migrate the existing code anyway.",
        "createdAt" : "2017-12-18T22:26:43Z",
        "updatedAt" : "2017-12-18T22:26:44Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      }
    ],
    "commit" : "fffd152e0df522473ef289d924e2ab683f44834f",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +309,313 @@\t\tsimpleMsg, _ := volumeToAttach.GenerateMsg(\"AttachVolume.Attach succeeded\", \"\")\n\t\tfor _, pod := range volumeToAttach.ScheduledPods {\n\t\t\tog.recorder.Eventf(pod, v1.EventTypeNormal, kevents.SuccessfulAttachVolume, simpleMsg)\n\t\t}\n\t\tglog.Infof(volumeToAttach.GenerateMsgDetailed(\"AttachVolume.Attach succeeded\", \"\"))"
  },
  {
    "id" : "42f7e57e-33fc-4368-9f1a-cd2b95eff14f",
    "prId" : 56872,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/56872#pullrequestreview-89264751",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "46882636-4871-40f2-91dd-c01cf5a518ce",
        "parentId" : null,
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "Did you verify if the value of `volumeToAttach.ScheduledPods` is populated correctly when the operation is actually executed? Want to make sure there is no funkiness in referencing a variable that is no longer in scope.",
        "createdAt" : "2017-12-14T00:58:05Z",
        "updatedAt" : "2017-12-14T19:09:35Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      },
      {
        "id" : "37c70d59-6e42-48ba-a6bd-534a6ad4e2e9",
        "parentId" : "46882636-4871-40f2-91dd-c01cf5a518ce",
        "authorId" : "542e5d2f-2ff9-4674-ab44-78f31768e7a1",
        "body" : "Yep, the closure will keep the variable around. There is one nuance that we need to work through though is the fact that each of the \"pods\" in Scheduled Pods is a reference, so if the pod itself changes between the eventRecorderFunc being generated and called, it will use the new version of the pod. I think that is actually intended behavior if it is the same pod and has just been mutated slightly.\r\n\r\nIt will not, however, use any other version of \"ScheduledPods\" as it is passed by value so we will not have pods being added or removed in between generation and execution of this function.\r\n\r\nI believe both of these behaviors are working as intended. lmk if you think otherwise.",
        "createdAt" : "2017-12-14T01:20:30Z",
        "updatedAt" : "2017-12-14T19:09:35Z",
        "lastEditedBy" : "542e5d2f-2ff9-4674-ab44-78f31768e7a1",
        "tags" : [
        ]
      },
      {
        "id" : "a06329ba-aacd-4956-8c8a-6a1d24085469",
        "parentId" : "46882636-4871-40f2-91dd-c01cf5a518ce",
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "Seems like reasonable assumptions.",
        "createdAt" : "2017-12-14T20:36:59Z",
        "updatedAt" : "2017-12-14T20:36:59Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      },
      {
        "id" : "d1ddfc41-156d-4ccf-8373-e9ab893bc8fb",
        "parentId" : "46882636-4871-40f2-91dd-c01cf5a518ce",
        "authorId" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "body" : "I am not seeing benefit of these eventrecorder functions... The way they are being used is arbitrary too and there is a reason it is arbitrary. Depending on error each operation may want to emit one more more events (or more than one type of event) - this generalization that each operation will return a `GeneratedOperations` and that in turn will have one `EventRecorder` function simply breaks down in multiple places.",
        "createdAt" : "2018-01-16T20:01:59Z",
        "updatedAt" : "2018-01-16T20:01:59Z",
        "lastEditedBy" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "tags" : [
        ]
      },
      {
        "id" : "a97841ad-896a-43fb-929c-b950d61c3cce",
        "parentId" : "46882636-4871-40f2-91dd-c01cf5a518ce",
        "authorId" : "542e5d2f-2ff9-4674-ab44-78f31768e7a1",
        "body" : "The EventRecorder function can have arbitrary functionality to emit 0,1, or more events depending on necessity. This refactor just automates all the \"plumbing\" required to emit these events in one codepath. Therefore anyone wanting to emit new events or change existing events just has to add/modify the \"eventRecorderFunc\" of the GeneratedOperation they wish to modify.\r\n\r\nThe EventRecorder function to actual event emitted does not have to be 1 to 1.",
        "createdAt" : "2018-01-16T21:20:55Z",
        "updatedAt" : "2018-01-16T21:20:56Z",
        "lastEditedBy" : "542e5d2f-2ff9-4674-ab44-78f31768e7a1",
        "tags" : [
        ]
      },
      {
        "id" : "31ee75b7-6b4e-4b27-959e-2510ca301bb0",
        "parentId" : "46882636-4871-40f2-91dd-c01cf5a518ce",
        "authorId" : "542e5d2f-2ff9-4674-ab44-78f31768e7a1",
        "body" : "Discussed further with @gnufied offline. Seems like the issue is that this abstraction only has the ability to capture \"Error\" type events that are returned from the generated function. The abstraction \"breaks down\" when we try to use it for other types of events such as a Warning or Success.\r\n\r\nThe intended design of the abstraction was only for Error events, while warnings and success events would continue to use the direct og.recorder.Eventf method. This can be documented by changing the EventRecorderFunc to ErrorEventRecorderFunc so that it is no longer a misnomer.\r\n\r\n@gnufied please confirm or correct these statements per your understanding.",
        "createdAt" : "2018-01-16T21:44:51Z",
        "updatedAt" : "2018-01-16T21:44:51Z",
        "lastEditedBy" : "542e5d2f-2ff9-4674-ab44-78f31768e7a1",
        "tags" : [
        ]
      },
      {
        "id" : "bcc5b625-6a92-4843-91c0-ed5036dfb5aa",
        "parentId" : "46882636-4871-40f2-91dd-c01cf5a518ce",
        "authorId" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "body" : "hmm - I am not sure about net benefit of having this recorder in the first place. I have a use case - where I want to reduce severity of an event depending on error raised. I still want the whole operation to fail in general (because a non-failing operation will not respect exponential backoff) but in certain cases i want the error to be a warning (because operation will be retried anyways).\r\n",
        "createdAt" : "2018-01-16T22:02:54Z",
        "updatedAt" : "2018-01-16T22:02:55Z",
        "lastEditedBy" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "tags" : [
        ]
      }
    ],
    "commit" : "e3f8f64c1743e261fffa1df6795fa44ea226d3b1",
    "line" : 164,
    "diffHunk" : "@@ -1,1 +286,290 @@\t\tif *err != nil {\n\t\t\tfor _, pod := range volumeToAttach.ScheduledPods {\n\t\t\t\tog.recorder.Eventf(pod, v1.EventTypeWarning, kevents.FailedAttachVolume, (*err).Error())\n\t\t\t}\n\t\t}"
  },
  {
    "id" : "106e829d-5822-4dc8-87c5-aa290b3c7602",
    "prId" : 56587,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/56587#pullrequestreview-80065233",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2f31a4cd-48e0-43c0-8a6a-8a12054dd20e",
        "parentId" : null,
        "authorId" : "3c1422a0-6358-4857-8f56-961979171514",
        "body" : "This is useless?",
        "createdAt" : "2017-11-30T02:42:28Z",
        "updatedAt" : "2017-11-30T02:42:31Z",
        "lastEditedBy" : "3c1422a0-6358-4857-8f56-961979171514",
        "tags" : [
        ]
      },
      {
        "id" : "b556012d-acfb-4222-ab63-422e8750a1d6",
        "parentId" : "2f31a4cd-48e0-43c0-8a6a-8a12054dd20e",
        "authorId" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "body" : "This is not useless. This removes conditions set on PVC after resizing has been successful and that is why it exists as separate commit as well. ",
        "createdAt" : "2017-11-30T02:52:41Z",
        "updatedAt" : "2017-11-30T02:52:41Z",
        "lastEditedBy" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "tags" : [
        ]
      }
    ],
    "commit" : "c82d412993d3c4ebb929cb1ce82fc26e77e0964e",
    "line" : 26,
    "diffHunk" : "@@ -1,1 +1281,1285 @@\n\tpvcCopy.Status.Capacity = capacity\n\tpvcCopy.Status.Conditions = []v1.PersistentVolumeClaimCondition{}\n\tnewData, err := json.Marshal(pvcCopy)\n"
  },
  {
    "id" : "42254829-e499-4451-a03e-b3bd1f9bbb5b",
    "prId" : 55491,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/55491#pullrequestreview-77322402",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bc77cb8f-b051-49e6-beb3-cf8fdc32c142",
        "parentId" : null,
        "authorId" : "8fc8f958-3c0e-47dd-a0fb-b8cc483b4efb",
        "body" : "Is the empty volume name going to cause a problem... can we have a comment as to why not?",
        "createdAt" : "2017-11-17T00:00:45Z",
        "updatedAt" : "2017-11-17T00:58:09Z",
        "lastEditedBy" : "8fc8f958-3c0e-47dd-a0fb-b8cc483b4efb",
        "tags" : [
        ]
      },
      {
        "id" : "867dadc1-029a-4354-b980-61cc1f82b83b",
        "parentId" : "bc77cb8f-b051-49e6-beb3-cf8fdc32c142",
        "authorId" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "body" : "nah - the if volume spec is specified in `MarkVolumeAsAttached` then unique name is picked from volume spec rather than from first parameter. I am just filling out first parameter to satisfy function contract. ",
        "createdAt" : "2017-11-17T02:05:18Z",
        "updatedAt" : "2017-11-17T02:05:18Z",
        "lastEditedBy" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "tags" : [
        ]
      }
    ],
    "commit" : "5297c146c1f4f03e71a0914077ca7a2b234966fb",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +270,274 @@\t\t\tif derr, ok := attachErr.(*util.DanglingAttachError); ok {\n\t\t\t\taddErr := actualStateOfWorld.MarkVolumeAsAttached(\n\t\t\t\t\tv1.UniqueVolumeName(\"\"),\n\t\t\t\t\tvolumeToAttach.VolumeSpec,\n\t\t\t\t\tderr.CurrentNode,"
  },
  {
    "id" : "eded7af8-511c-49fe-9588-3e93fd01734c",
    "prId" : 55491,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/55491#pullrequestreview-77300226",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "38c73948-0915-448f-bb02-207fca675853",
        "parentId" : null,
        "authorId" : "8fc8f958-3c0e-47dd-a0fb-b8cc483b4efb",
        "body" : "Can we `glog.Info` (or warning) when we're doing this ... it's unusual enough that we want to know in the logs I think",
        "createdAt" : "2017-11-17T00:41:50Z",
        "updatedAt" : "2017-11-17T00:58:09Z",
        "lastEditedBy" : "8fc8f958-3c0e-47dd-a0fb-b8cc483b4efb",
        "tags" : [
        ]
      }
    ],
    "commit" : "5297c146c1f4f03e71a0914077ca7a2b234966fb",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +269,273 @@\t\tif attachErr != nil {\n\t\t\tif derr, ok := attachErr.(*util.DanglingAttachError); ok {\n\t\t\t\taddErr := actualStateOfWorld.MarkVolumeAsAttached(\n\t\t\t\t\tv1.UniqueVolumeName(\"\"),\n\t\t\t\t\tvolumeToAttach.VolumeSpec,"
  },
  {
    "id" : "3b5999a1-6234-4af6-933d-a67b4c20d75c",
    "prId" : 51494,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/51494#pullrequestreview-74219967",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b54aa04c-af24-4e93-8fb6-39a6960ba685",
        "parentId" : null,
        "authorId" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "body" : "This was already logged above? Which one do you want to keep?",
        "createdAt" : "2017-11-01T23:44:10Z",
        "updatedAt" : "2017-11-20T19:12:48Z",
        "lastEditedBy" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "tags" : [
        ]
      },
      {
        "id" : "b6db0880-6560-4f0a-80d1-5696c657d065",
        "parentId" : "b54aa04c-af24-4e93-8fb6-39a6960ba685",
        "authorId" : "967a712d-9784-41d4-920d-42eaba99fb24",
        "body" : "These messages are different.\r\n- Line 727 is for mapDevice of globalMapPath\r\n- Line 752 is for mapDevice of volumeMapPath",
        "createdAt" : "2017-11-03T22:09:06Z",
        "updatedAt" : "2017-11-20T19:12:48Z",
        "lastEditedBy" : "967a712d-9784-41d4-920d-42eaba99fb24",
        "tags" : [
        ]
      }
    ],
    "commit" : "9329dd5b91a099888f0cfb2aeeb79659a093f6ed",
    "line" : 219,
    "diffHunk" : "@@ -1,1 +771,775 @@\n\t\t// Device mapping for pod device map path succeeded\n\t\tsimpleMsg, detailedMsg = volumeToMount.GenerateMsg(\"MapVolume.MapDevice succeeded\", fmt.Sprintf(\"volumeMapPath %q\", volumeMapPath))\n\t\tverbosity = glog.Level(1)\n\t\tog.recorder.Eventf(volumeToMount.Pod, v1.EventTypeNormal, kevents.SuccessfulMountVolume, simpleMsg)"
  },
  {
    "id" : "7ea6eb8e-6e10-44bd-997c-405979bade22",
    "prId" : 44969,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/44969#pullrequestreview-35284103",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0d41a7db-7867-460c-91d6-14545a514a08",
        "parentId" : null,
        "authorId" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "body" : "This looks out of place compared to the original code",
        "createdAt" : "2017-04-27T20:18:53Z",
        "updatedAt" : "2017-05-04T20:29:29Z",
        "lastEditedBy" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "tags" : [
        ]
      },
      {
        "id" : "1d4d0432-be7f-4c1f-89a3-2284095d724e",
        "parentId" : "0d41a7db-7867-460c-91d6-14545a514a08",
        "authorId" : "9f5e3cfe-0c8a-43e2-8374-3cbe3b3568ab",
        "body" : "@msau42 It looks like the error message printing got lost in #34242 commit a1c7b8ff841aa9539fa7df04bf5ffc02dbc4342c ",
        "createdAt" : "2017-04-27T21:23:47Z",
        "updatedAt" : "2017-05-04T20:29:29Z",
        "lastEditedBy" : "9f5e3cfe-0c8a-43e2-8374-3cbe3b3568ab",
        "tags" : [
        ]
      },
      {
        "id" : "e280b7d6-4b7b-43ba-a406-eb134c6ea386",
        "parentId" : "0d41a7db-7867-460c-91d6-14545a514a08",
        "authorId" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "body" : "@tsmetana did you intentionally not want to check the error here and have it proceed further?",
        "createdAt" : "2017-04-27T22:36:31Z",
        "updatedAt" : "2017-05-04T20:29:29Z",
        "lastEditedBy" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "tags" : [
        ]
      },
      {
        "id" : "465267f6-9601-40fe-9031-d58df49eeba0",
        "parentId" : "0d41a7db-7867-460c-91d6-14545a514a08",
        "authorId" : "d0f794d1-a9d4-4c31-aacc-fb35543cf586",
        "body" : "No, this is an apparent mistake in my patch. The error should not have been ignored.",
        "createdAt" : "2017-04-28T06:35:04Z",
        "updatedAt" : "2017-05-04T20:29:29Z",
        "lastEditedBy" : "d0f794d1-a9d4-4c31-aacc-fb35543cf586",
        "tags" : [
        ]
      }
    ],
    "commit" : "bbc8859176f89e8f4a29c0e90407bcf1b6ab8ea8",
    "line" : 112,
    "diffHunk" : "@@ -1,1 +302,306 @@\t\tvolumeName, err =\n\t\t\tattachableVolumePlugin.GetVolumeName(volumeToDetach.VolumeSpec)\n\t\tif err != nil {\n\t\t\treturn nil, volumeToDetach.GenerateErrorDetailed(\"DetachVolume.GetVolumeName failed\", err)\n\t\t}"
  },
  {
    "id" : "9eeb05bd-57ef-453d-a471-dff67cd58173",
    "prId" : 44969,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/44969#pullrequestreview-35944408",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b53fc9d1-b3d4-4d8d-98c1-691b25b009c4",
        "parentId" : null,
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "Is the error from `pluginName, volumeName, err = volumehelper.SplitUniqueName(volumeToDetach.VolumeName)` above not logged on purpose? CC @tsmetana ",
        "createdAt" : "2017-04-29T00:40:20Z",
        "updatedAt" : "2017-05-04T20:29:29Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      },
      {
        "id" : "e3e358bc-ce28-4aae-9553-ac6d30f7c355",
        "parentId" : "b53fc9d1-b3d4-4d8d-98c1-691b25b009c4",
        "authorId" : "9f5e3cfe-0c8a-43e2-8374-3cbe3b3568ab",
        "body" : "@saad-ali & @tsmetana - I went ahead and added an error for this particular situation.\r\n",
        "createdAt" : "2017-05-03T01:33:58Z",
        "updatedAt" : "2017-05-04T20:29:29Z",
        "lastEditedBy" : "9f5e3cfe-0c8a-43e2-8374-3cbe3b3568ab",
        "tags" : [
        ]
      },
      {
        "id" : "2b904feb-704a-4454-9ceb-8596cde21e5b",
        "parentId" : "b53fc9d1-b3d4-4d8d-98c1-691b25b009c4",
        "authorId" : "d0f794d1-a9d4-4c31-aacc-fb35543cf586",
        "body" : "Sorry for the late response -- I missed the notification. GenereateDetachVolumeFunc is being called from OperationExecutor's DetachVolume which is being called by reconciler and the error is being passed up... So any error in this function should be logged by the reconciler. However it's safer not to rely on the callers to log the error (OperationExecutor doesn't log it too...) and rather print it several times than miss it altogether. So I think @ianchakeres' solution is correct.",
        "createdAt" : "2017-05-03T06:07:58Z",
        "updatedAt" : "2017-05-04T20:29:29Z",
        "lastEditedBy" : "d0f794d1-a9d4-4c31-aacc-fb35543cf586",
        "tags" : [
        ]
      }
    ],
    "commit" : "bbc8859176f89e8f4a29c0e90407bcf1b6ab8ea8",
    "line" : 11,
    "diffHunk" : "@@ -1,1 +313,317 @@\t\tif err != nil {\n\t\t\treturn nil, volumeToDetach.GenerateErrorDetailed(\"DetachVolume.SplitUniqueName failed\", err)\n\t\t}\n\t\tattachableVolumePlugin, err = og.volumePluginMgr.FindAttachablePluginByName(pluginName)\n\t\tif err != nil {"
  },
  {
    "id" : "e1de00f8-fd86-4b5f-ac04-f26263165a27",
    "prId" : 39732,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/39732#pullrequestreview-33676059",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2668b372-a69f-45f1-a061-45b0272c625f",
        "parentId" : null,
        "authorId" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "body" : "I see you now use uniqueName to get pluginName, but it seems not very safe to do this way. Although for current plulgins, it works but there is no guarantee the name will always construct like this. And what if there is / in the plugin name too? ",
        "createdAt" : "2017-03-23T19:02:32Z",
        "updatedAt" : "2017-04-20T11:05:10Z",
        "lastEditedBy" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "tags" : [
        ]
      },
      {
        "id" : "eacd51d0-662e-4011-94ff-0dc69633fdc4",
        "parentId" : "2668b372-a69f-45f1-a061-45b0272c625f",
        "authorId" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "body" : "What is the reason you change from reconstructSpec to this logic?",
        "createdAt" : "2017-03-23T19:03:52Z",
        "updatedAt" : "2017-04-20T11:05:10Z",
        "lastEditedBy" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "tags" : [
        ]
      },
      {
        "id" : "9da3fb39-0ccd-40d7-85d7-56cb9355801d",
        "parentId" : "2668b372-a69f-45f1-a061-45b0272c625f",
        "authorId" : "d0f794d1-a9d4-4c31-aacc-fb35543cf586",
        "body" : "I have always used the unique name to get the plugin name even in the previous version that was reconstructing the spec (the spec reconstruction was a plugin method so I had to have the plugin name first). Yes, this adds constraints on the plugin naming: it must follow the current pattern.",
        "createdAt" : "2017-03-24T09:24:34Z",
        "updatedAt" : "2017-04-20T11:05:10Z",
        "lastEditedBy" : "d0f794d1-a9d4-4c31-aacc-fb35543cf586",
        "tags" : [
        ]
      },
      {
        "id" : "65465371-b9f7-46bc-abe0-66b32f747b86",
        "parentId" : "2668b372-a69f-45f1-a061-45b0272c625f",
        "authorId" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "body" : "I talked with @jingxu97 bit offline and I think what we can do is - for now we should leave it - as it is but in future perhaps amend the node resource to store more information about volume, so as this hack need not be needed. \r\n",
        "createdAt" : "2017-03-24T13:43:57Z",
        "updatedAt" : "2017-04-20T11:05:10Z",
        "lastEditedBy" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "tags" : [
        ]
      },
      {
        "id" : "ac042a4d-cd4e-4ae6-8f92-20de78869c26",
        "parentId" : "2668b372-a69f-45f1-a061-45b0272c625f",
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "Agreed pretty funky should be improved in the future",
        "createdAt" : "2017-04-20T06:03:30Z",
        "updatedAt" : "2017-04-20T11:05:10Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      }
    ],
    "commit" : "852c44ae598e5d9f0dd936d8f8b3c7a2d41827d5",
    "line" : 56,
    "diffHunk" : "@@ -1,1 +340,344 @@\t\t// there's no VolumeSpec: this happens only on attach/detach controller crash recovery\n\t\t// when a pod has been deleted during the controller downtime\n\t\tpluginName, volumeName, err = volumehelper.SplitUniqueName(volumeToDetach.VolumeName)\n\t\tif err != nil {\n\t\t\treturn nil, err"
  }
]
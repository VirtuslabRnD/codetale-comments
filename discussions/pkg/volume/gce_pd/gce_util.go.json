[
  {
    "id" : "2a1b41f1-eae0-4fb6-a230-e6d666db02f4",
    "prId" : 67530,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/67530#pullrequestreview-148614726",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "21759075-5d30-4a78-9a29-9ba6382fd13d",
        "parentId" : null,
        "authorId" : "34f61776-88da-4b26-aa20-3c4f92530d05",
        "body" : "nit: Keep the same glog message as before: `glog.V(2).Infof(\"error getting zone information from GCE: %v\", err)`",
        "createdAt" : "2018-08-21T18:46:55Z",
        "updatedAt" : "2018-08-24T21:38:44Z",
        "lastEditedBy" : "34f61776-88da-4b26-aa20-3c4f92530d05",
        "tags" : [
        ]
      },
      {
        "id" : "211ba021-a73b-41fc-a06c-6b5ebd5d5c72",
        "parentId" : "21759075-5d30-4a78-9a29-9ba6382fd13d",
        "authorId" : "98986d5f-c846-4478-8363-8a016e3d6b89",
        "body" : "There was a review comment earlier to remove the log as the error already captures it. https://github.com/kubernetes/kubernetes/pull/67530#discussion_r210962582 . Do we really need it?",
        "createdAt" : "2018-08-21T22:51:36Z",
        "updatedAt" : "2018-08-24T21:38:44Z",
        "lastEditedBy" : "98986d5f-c846-4478-8363-8a016e3d6b89",
        "tags" : [
        ]
      },
      {
        "id" : "f76c6bc6-a54d-497d-bf90-c75882dec16d",
        "parentId" : "21759075-5d30-4a78-9a29-9ba6382fd13d",
        "authorId" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "body" : "Generally, we should avoid logging error messages that we also return because that creates duplicate log messages.",
        "createdAt" : "2018-08-21T23:01:38Z",
        "updatedAt" : "2018-08-24T21:38:44Z",
        "lastEditedBy" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "tags" : [
        ]
      },
      {
        "id" : "1ee0837c-5dcd-402a-9597-0b5d83217f13",
        "parentId" : "21759075-5d30-4a78-9a29-9ba6382fd13d",
        "authorId" : "34f61776-88da-4b26-aa20-3c4f92530d05",
        "body" : "ACK",
        "createdAt" : "2018-08-22T18:33:33Z",
        "updatedAt" : "2018-08-24T21:38:44Z",
        "lastEditedBy" : "34f61776-88da-4b26-aa20-3c4f92530d05",
        "tags" : [
        ]
      }
    ],
    "commit" : "a2de7d2d8daf730ce943f4b28decf70dc2cea488",
    "line" : 52,
    "diffHunk" : "@@ -1,1 +145,149 @@\tactivezones, err = cloud.GetAllCurrentZones()\n\tif err != nil {\n\t\treturn \"\", 0, nil, \"\", err\n\t}\n"
  },
  {
    "id" : "346744d1-ffea-4532-94e5-59d9ee4ac806",
    "prId" : 66832,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/66832#pullrequestreview-149924730",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a737e62d-fb23-4cc7-8514-41fefc83a0d2",
        "parentId" : null,
        "authorId" : "542e5d2f-2ff9-4674-ab44-78f31768e7a1",
        "body" : "@msau42 is this method going to be refactored out as part of the mount utilities refactor?\r\n\r\nAlso can this be made into a public interface?",
        "createdAt" : "2018-08-27T23:46:15Z",
        "updatedAt" : "2018-08-27T23:46:16Z",
        "lastEditedBy" : "542e5d2f-2ff9-4674-ab44-78f31768e7a1",
        "tags" : [
        ]
      },
      {
        "id" : "a3bc31e3-c2a8-4c6a-adb9-b91ff70202c5",
        "parentId" : "a737e62d-fb23-4cc7-8514-41fefc83a0d2",
        "authorId" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "body" : "It's not being considered as part of the Mount utils refactor, but we can look into adding this there after the initial refactor is done.  Right now, only GCE PD does this kind of checking.",
        "createdAt" : "2018-08-27T23:51:48Z",
        "updatedAt" : "2018-08-27T23:51:48Z",
        "lastEditedBy" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "tags" : [
        ]
      }
    ],
    "commit" : "cf107159b415f8195688733c4bc464c4bbe0bb0c",
    "line" : 43,
    "diffHunk" : "@@ -1,1 +271,275 @@\n// Returns the first path that exists, or empty string if none exist.\nfunc verifyDevicePath(devicePaths []string, sdBeforeSet sets.String, diskName string) (string, error) {\n\tif err := udevadmChangeToNewDrives(sdBeforeSet); err != nil {\n\t\t// It's possible udevadm was called on other disks so it should not block this"
  },
  {
    "id" : "f4c2b6a1-279c-472d-8394-c2e078251733",
    "prId" : 51667,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/51667#pullrequestreview-59754395",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "219d1604-00ad-436a-a34d-a88eb0c1da15",
        "parentId" : null,
        "authorId" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "body" : "After this log a message for successfully creating a regional PD",
        "createdAt" : "2017-08-31T02:31:41Z",
        "updatedAt" : "2017-09-05T03:16:45Z",
        "lastEditedBy" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "tags" : [
        ]
      },
      {
        "id" : "70337b8a-9f89-4367-a4d0-0969d292e2fc",
        "parentId" : "219d1604-00ad-436a-a34d-a88eb0c1da15",
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "Logging was inside the `CreateRegionalDisk` method, but I moved it here so it's easier to follow.",
        "createdAt" : "2017-08-31T04:41:39Z",
        "updatedAt" : "2017-09-05T03:16:45Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      }
    ],
    "commit" : "8a2d1cd63a62e76cee94b9796198c7fecdc30a8f",
    "line" : 81,
    "diffHunk" : "@@ -1,1 +142,146 @@\t\t\tc.options.CloudTags,\n\t\t\tcloud)\n\t\tif err != nil {\n\t\t\tglog.V(2).Infof(\"Error creating regional GCE PD volume: %v\", err)\n\t\t\treturn \"\", 0, nil, \"\", err"
  },
  {
    "id" : "470c8bd6-741a-424a-b077-97039985e860",
    "prId" : 51667,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/51667#pullrequestreview-59918032",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b469b35e-fff3-4a1b-be0e-6fcb508b54a4",
        "parentId" : null,
        "authorId" : "7dd504ec-7e63-45b3-98f8-6eb1c683e9c2",
        "body" : "What's `001` means here?",
        "createdAt" : "2017-08-31T07:36:41Z",
        "updatedAt" : "2017-09-05T03:16:45Z",
        "lastEditedBy" : "7dd504ec-7e63-45b3-98f8-6eb1c683e9c2",
        "tags" : [
        ]
      },
      {
        "id" : "8615427b-7a88-4d4d-a743-c7b4e4825f62",
        "parentId" : "b469b35e-fff3-4a1b-be0e-6fcb508b54a4",
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "Comment keeping track of the truth table for ` zonePresent, zonesPresent, replicaZonesPresent` to make sure I handle all cases.",
        "createdAt" : "2017-08-31T16:35:12Z",
        "updatedAt" : "2017-09-05T03:16:45Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      }
    ],
    "commit" : "8a2d1cd63a62e76cee94b9796198c7fecdc30a8f",
    "line" : 63,
    "diffHunk" : "@@ -1,1 +128,132 @@\n\tif !zonePresent && !zonesPresent && replicaZonesPresent {\n\t\t// 001 - \"replica-zones\" specified\n\t\treplicaZones, err := volumeutil.ZonesToSet(configuredReplicaZones)\n\t\tif err != nil {"
  },
  {
    "id" : "a1d5f603-6b4f-4c8c-a547-a00e9cba7f99",
    "prId" : 51667,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/51667#pullrequestreview-60029456",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "92986836-d9cf-4aa9-9dee-2766fceda194",
        "parentId" : null,
        "authorId" : "8fc8f958-3c0e-47dd-a0fb-b8cc483b4efb",
        "body" : "nit: the name maxRegionalPDZones is a little misleading, if we _must_ have exactly that many zones.",
        "createdAt" : "2017-09-01T01:41:55Z",
        "updatedAt" : "2017-09-05T03:16:45Z",
        "lastEditedBy" : "8fc8f958-3c0e-47dd-a0fb-b8cc483b4efb",
        "tags" : [
        ]
      }
    ],
    "commit" : "8a2d1cd63a62e76cee94b9796198c7fecdc30a8f",
    "line" : 160,
    "diffHunk" : "@@ -1,1 +209,213 @@\n\tautoZoneSelection := false\n\tif replicaZones.Len() != maxRegionalPDZones {\n\t\treplicaZonesList := replicaZones.UnsortedList()\n\t\tif replicaZones.Len() == 1 && replicaZonesList[0] == regionalPDZonesAuto {"
  },
  {
    "id" : "c44ac859-d53f-4274-88e0-4e02cf61ce0e",
    "prId" : 29006,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8db16d67-d118-433a-a462-af2502da5819",
        "parentId" : null,
        "authorId" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "body" : "I'm not sure why this is a todo, honestly.  Seems like selector and storage class annotation are mutually exclusive to me at this point.\n",
        "createdAt" : "2016-07-22T05:15:58Z",
        "updatedAt" : "2016-08-18T10:50:16Z",
        "lastEditedBy" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "tags" : [
        ]
      }
    ],
    "commit" : "bb5d562f37ab029d2b562e23bd23e906ee099a45",
    "line" : 26,
    "diffHunk" : "@@ -1,1 +95,99 @@\t}\n\n\t// TODO: implement c.options.ProvisionerSelector parsing\n\tif c.options.Selector != nil {\n\t\treturn \"\", 0, nil, fmt.Errorf(\"claim.Spec.Selector is not supported for dynamic provisioning on GCE\")"
  },
  {
    "id" : "a77cdebe-029c-4395-8406-5625758265e6",
    "prId" : 29006,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "48d52021-b5be-4f78-8b3a-9bb84753b95c",
        "parentId" : null,
        "authorId" : "8fc8f958-3c0e-47dd-a0fb-b8cc483b4efb",
        "body" : "Just FYI it isn't strictly random.  It will spread across the zones, realiably so for PetSets\n",
        "createdAt" : "2016-08-18T15:52:28Z",
        "updatedAt" : "2016-08-18T15:52:28Z",
        "lastEditedBy" : "8fc8f958-3c0e-47dd-a0fb-b8cc483b4efb",
        "tags" : [
        ]
      }
    ],
    "commit" : "bb5d562f37ab029d2b562e23bd23e906ee099a45",
    "line" : 33,
    "diffHunk" : "@@ -1,1 +102,106 @@\tif zone == \"\" {\n\t\t// No zone specified, choose one randomly in the same region as the\n\t\t// node is running.\n\t\tzones, err := cloud.GetAllZones()\n\t\tif err != nil {"
  },
  {
    "id" : "6d30089e-04ea-4ce7-9c12-313a11a80a9a",
    "prId" : 28714,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "46b77a92-7f0c-4fee-843a-6f7e8c0bc45d",
        "parentId" : null,
        "authorId" : "9680f0db-1c00-49c9-968a-be3d5084d153",
        "body" : "@saad-ali @ciwang And again\n",
        "createdAt" : "2016-07-12T04:34:23Z",
        "updatedAt" : "2016-07-18T23:20:15Z",
        "lastEditedBy" : "9680f0db-1c00-49c9-968a-be3d5084d153",
        "tags" : [
        ]
      }
    ],
    "commit" : "e13c678e3b04becd6131442e069f1d910241992d",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +128,132 @@// Does nothing if globalMountPath does not exist.\nfunc unmountPDAndRemoveGlobalPath(globalMountPath string, mounter mount.Interface) error {\n\tif pathExists, pathErr := pathExists(globalMountPath); pathErr != nil {\n\t\treturn fmt.Errorf(\"Error checking if path exists: %v\", pathErr)\n\t} else if !pathExists {"
  },
  {
    "id" : "92409a13-ac07-4d79-900c-1b6290388313",
    "prId" : 20210,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c50bc7a0-db5c-4b60-bff9-5e64f5e3550c",
        "parentId" : null,
        "authorId" : "727fc82d-d969-41a4-a614-7fefce94f9a6",
        "body" : "For `name`, what if we include the PV name?  You've already created a gce-specific name here:  https://github.com/kubernetes/kubernetes/blob/master/pkg/volume/gce_pd/gce_pd.go#L390\n\nInstead of another one \"kube-dynamic-UID\", we can use the unique name generated on the PV itself.\n\nThis obviates the need to put pv.Name in the description because both volumes (PV and GCE resource) are named exactly the same.\n",
        "createdAt" : "2016-01-27T18:30:15Z",
        "updatedAt" : "2016-01-27T18:30:50Z",
        "lastEditedBy" : "727fc82d-d969-41a4-a614-7fefce94f9a6",
        "tags" : [
        ]
      },
      {
        "id" : "4a0fb115-d13e-45b0-9fb0-fe91a9695a65",
        "parentId" : "c50bc7a0-db5c-4b60-bff9-5e64f5e3550c",
        "authorId" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "body" : "Is's a good idea, I'll implement it as separate PR (and also for AWS + OpenStack/Cinder).\n",
        "createdAt" : "2016-01-28T09:49:24Z",
        "updatedAt" : "2016-01-28T09:49:24Z",
        "lastEditedBy" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "tags" : [
        ]
      },
      {
        "id" : "61ec2b21-04c2-4a65-9a57-f55dcfbf1e2b",
        "parentId" : "c50bc7a0-db5c-4b60-bff9-5e64f5e3550c",
        "authorId" : "727fc82d-d969-41a4-a614-7fefce94f9a6",
        "body" : "A separate PR for the others makes sense, but why not this PR for this name?  Is getting the PV name onto the provisioner `c` object more invasive than I assume?\n",
        "createdAt" : "2016-01-29T13:16:25Z",
        "updatedAt" : "2016-01-29T13:16:25Z",
        "lastEditedBy" : "727fc82d-d969-41a4-a614-7fefce94f9a6",
        "tags" : [
        ]
      },
      {
        "id" : "c99e7d89-e46b-4d40-8038-61fa79697908",
        "parentId" : "c50bc7a0-db5c-4b60-bff9-5e64f5e3550c",
        "authorId" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "body" : "I need to add a new item into `VolumeOptions`, which would be ignored by the other clouds. It looks better to me if I implement its handling for all clouds in one PR.\n",
        "createdAt" : "2016-01-29T14:21:24Z",
        "updatedAt" : "2016-01-29T14:21:24Z",
        "lastEditedBy" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "tags" : [
        ]
      },
      {
        "id" : "ceaefdb8-56e6-47f3-acd7-c78b2d5f8054",
        "parentId" : "c50bc7a0-db5c-4b60-bff9-5e64f5e3550c",
        "authorId" : "727fc82d-d969-41a4-a614-7fefce94f9a6",
        "body" : "ok.  It's good, too, that AWS and Cinder support this.\n",
        "createdAt" : "2016-01-29T15:41:00Z",
        "updatedAt" : "2016-01-29T15:41:00Z",
        "lastEditedBy" : "727fc82d-d969-41a4-a614-7fefce94f9a6",
        "tags" : [
        ]
      }
    ],
    "commit" : "23cd0913f7c6dadb6a38fdbc8fc2fe4983ed4e7c",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +147,151 @@\t}\n\n\terr = cloud.CreateDisk(name, zone.FailureDomain, int64(requestGB), *c.options.CloudTags)\n\tif err != nil {\n\t\tglog.V(2).Infof(\"Error creating GCE PD volume: %v\", err)"
  },
  {
    "id" : "47d4b098-854b-4b3d-8e48-3064df4141c2",
    "prId" : 14526,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "749050bf-c931-442d-b42b-a41b1b13b4b8",
        "parentId" : null,
        "authorId" : "7766e039-aa4c-4476-9091-5cc8763fa8d6",
        "body" : "Is there any point in verifying the device path if we know confidently that the disk wasn't attached? Unless I'm misunderstanding the code, we should just `continue` in this case.\n",
        "createdAt" : "2015-09-27T15:57:39Z",
        "updatedAt" : "2015-09-29T21:32:22Z",
        "lastEditedBy" : "7766e039-aa4c-4476-9091-5cc8763fa8d6",
        "tags" : [
        ]
      },
      {
        "id" : "a6992a71-51da-4bf1-b766-a5d82943fa84",
        "parentId" : "749050bf-c931-442d-b42b-a41b1b13b4b8",
        "authorId" : "7766e039-aa4c-4476-9091-5cc8763fa8d6",
        "body" : "Although I acknowledge that the asymmetry with the detach code is somewhat annoying\n",
        "createdAt" : "2015-09-27T16:07:14Z",
        "updatedAt" : "2015-09-29T21:32:22Z",
        "lastEditedBy" : "7766e039-aa4c-4476-9091-5cc8763fa8d6",
        "tags" : [
        ]
      },
      {
        "id" : "d7f007d0-8c1f-469b-9fda-f8714a748b1b",
        "parentId" : "749050bf-c931-442d-b42b-a41b1b13b4b8",
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "The idea behind this is to catch the case that where we timeout waiting for an attach to succeed, but as soon as we retry attach, it fails (for whatever reason), but the previous attach actually succeeds (ideally the check timeout should be long enough to catch this, but doesn't hurt). So, I'll leave it as is for now.\n",
        "createdAt" : "2015-09-28T21:11:35Z",
        "updatedAt" : "2015-09-29T21:32:22Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      }
    ],
    "commit" : "77711517674653f8d1ee1673a648d7784b869c0d",
    "line" : 39,
    "diffHunk" : "@@ -1,1 +144,148 @@\t\t\t// Retry on error. See issue #11321. Continue and verify if disk is attached, because a\n\t\t\t// previous attach operation may still succeed.\n\t\t\tglog.Errorf(\"Error attaching PD %q: %v\", b.pdName, err)\n\t\t}\n"
  },
  {
    "id" : "85bbcb6f-099a-49d2-bc97-e13e3972b4ee",
    "prId" : 14526,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "95f858fb-f132-4dae-8fa3-ae2cc57b1a0d",
        "parentId" : null,
        "authorId" : "7766e039-aa4c-4476-9091-5cc8763fa8d6",
        "body" : "Not needed, but it may be worth pulling this logic out into its own function\n",
        "createdAt" : "2015-09-27T16:03:20Z",
        "updatedAt" : "2015-09-29T21:32:22Z",
        "lastEditedBy" : "7766e039-aa4c-4476-9091-5cc8763fa8d6",
        "tags" : [
        ]
      }
    ],
    "commit" : "77711517674653f8d1ee1673a648d7784b869c0d",
    "line" : null,
    "diffHunk" : "@@ -1,1 +227,231 @@\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\n\t\tif numRetries > 0 {"
  },
  {
    "id" : "fb1e489a-bee8-49a5-bebf-9e0ab136e8c0",
    "prId" : 11561,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e92e71b6-337d-49c5-b30e-838e7cf396b5",
        "parentId" : null,
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "shouldn't we add \"sleep X and continue\" here?\nIIUC, if AttachDisk returns an error, there is no chance that disk will be attached at some point.\n",
        "createdAt" : "2015-07-20T09:19:36Z",
        "updatedAt" : "2015-07-23T21:04:07Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      },
      {
        "id" : "ca51c8b3-c526-4128-9e8d-950701a2b9be",
        "parentId" : "e92e71b6-337d-49c5-b30e-838e7cf396b5",
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "Good catch. Added sleep.\n",
        "createdAt" : "2015-07-21T03:53:45Z",
        "updatedAt" : "2015-07-23T21:04:07Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      },
      {
        "id" : "58557360-2baf-429e-a618-d2f6c936eb01",
        "parentId" : "e92e71b6-337d-49c5-b30e-838e7cf396b5",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "Shouldn't we also add \"continue\" after this sleep? If not - can you please add a comment why it makes sense to verify whether disk is attached after AttachDisk returning error?\n\n(Same for detaching)\n",
        "createdAt" : "2015-07-21T08:06:10Z",
        "updatedAt" : "2015-07-23T21:04:07Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      },
      {
        "id" : "283ac127-fe6c-49f3-a51c-0ac76d268715",
        "parentId" : "e92e71b6-337d-49c5-b30e-838e7cf396b5",
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "Actually I just remembered I did this on prupose. A previous attach/detach operation could succeed therefore it is worth checking at every iteration whether the disk is attached/detached, instead of doing nothing and sleeping, we can do verification--so I remeoved the sleep as well. \n",
        "createdAt" : "2015-07-21T20:41:37Z",
        "updatedAt" : "2015-07-23T21:04:07Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      }
    ],
    "commit" : "234f3ed81441a931fc3c5e0101a5e455d4e6f4d9",
    "line" : null,
    "diffHunk" : "@@ -1,1 +145,149 @@\t\t\t// Retry on error. See issue #11321. Continue and verify if disk is attached, because a\n\t\t\t// previous attach operation may still succeed.\n\t\t\tglog.Errorf(\"Error attaching PD %q: %v\", pd.pdName, err)\n\t\t}\n"
  },
  {
    "id" : "de4ac931-317c-4663-a667-56b8244eaa56",
    "prId" : 10169,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fae4bba7-6efb-4b02-ae35-94fba3104fb2",
        "parentId" : null,
        "authorId" : null,
        "body" : "You should only do this if it is in fact a sym link.\n",
        "createdAt" : "2015-06-22T23:21:53Z",
        "updatedAt" : "2015-06-30T20:31:17Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "de4a4096-14ad-40c7-862e-b23edff1c09b",
        "parentId" : "fae4bba7-6efb-4b02-ae35-94fba3104fb2",
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "If a path is not a symlink `evalSymlinks` simply returns the same path, it does not error. For example, `/dev/sda` would just return `/dev/sda`. Since there is no harm in calling this on a non-symlink path and it helps avoid unnecessarily adding logic to decide when it should be called, I'll leave it as is. Let me know if you disagree.\n",
        "createdAt" : "2015-06-22T23:46:35Z",
        "updatedAt" : "2015-06-30T20:31:17Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      },
      {
        "id" : "a7d7dcc3-89ac-454b-afa2-a4aa9947cd6e",
        "parentId" : "fae4bba7-6efb-4b02-ae35-94fba3104fb2",
        "authorId" : null,
        "body" : "Aah - yes, that makes sense.\n",
        "createdAt" : "2015-06-23T19:15:22Z",
        "updatedAt" : "2015-06-30T20:31:17Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "c952ee23a70ad0fbecaa1e2c311225e8a7b5e17c",
    "line" : null,
    "diffHunk" : "@@ -1,1 +276,280 @@\n\t// Evaluate symlink, if any\n\tdrive, err := filepath.EvalSymlinks(drivePath)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"udevadmChangeToDrive: filepath.EvalSymlinks(%q) failed with %v.\", drivePath, err)"
  },
  {
    "id" : "7eb29669-37e4-47e1-a73f-885ae1d5b2eb",
    "prId" : 10169,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "03635b02-6c8a-47c7-ab1f-19798c27e113",
        "parentId" : null,
        "authorId" : null,
        "body" : "You should ideally return whether you succeeded or failed to the caller of this function.  Even if they choose not to do anything with that info other than log it.\n",
        "createdAt" : "2015-06-27T00:38:38Z",
        "updatedAt" : "2015-06-30T20:31:17Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "8dd7a16c-69f2-439d-a0e5-20f2b06348ad",
        "parentId" : "03635b02-6c8a-47c7-ab1f-19798c27e113",
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "I agree with you, but in this case this method is executed asynchronously as a go routine. Returning errors here doesn't make any sense.\n",
        "createdAt" : "2015-06-29T00:20:15Z",
        "updatedAt" : "2015-06-30T20:31:17Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      }
    ],
    "commit" : "c952ee23a70ad0fbecaa1e2c311225e8a7b5e17c",
    "line" : null,
    "diffHunk" : "@@ -1,1 +186,190 @@\t\t\tcase <-ch:\n\t\t\t\tglog.Warningf(\"Terminating GCE PD %q detach verification. Another attach/detach call was made for this PD.\", pd.pdName)\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\tallPathsRemoved := true"
  },
  {
    "id" : "96b02ea1-7eeb-479d-bf34-83c3b7760143",
    "prId" : 10169,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "038856ae-7a90-450e-a93e-3bf65cdd1fbc",
        "parentId" : null,
        "authorId" : null,
        "body" : "Same comment as above.\n",
        "createdAt" : "2015-06-27T00:39:15Z",
        "updatedAt" : "2015-06-30T20:31:17Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "5a030d60-cfe7-4f5d-976c-21253ad41b32",
        "parentId" : "038856ae-7a90-450e-a93e-3bf65cdd1fbc",
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "Reiterating above, since this method is executed as a go routine, it doesn't make sense for it to return anything. From the [golang spec](http://golang.org/ref/spec#Go_statements): `When the function terminates, its goroutine also terminates. If the function has any return values, they are discarded when the function completes.`\n",
        "createdAt" : "2015-06-29T00:23:26Z",
        "updatedAt" : "2015-06-30T20:31:17Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      },
      {
        "id" : "cbc04445-f18e-44d3-a58d-39949120a13c",
        "parentId" : "038856ae-7a90-450e-a93e-3bf65cdd1fbc",
        "authorId" : null,
        "body" : "Here it's executed as a go routine, but having it return a value would make it more useful generally.  But OK, leave as it is if you prefer.\n",
        "createdAt" : "2015-06-29T15:28:42Z",
        "updatedAt" : "2015-06-30T20:31:17Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "c952ee23a70ad0fbecaa1e2c311225e8a7b5e17c",
    "line" : 185,
    "diffHunk" : "@@ -1,1 +196,200 @@\t\t\t\t\tif exists, err := pathExists(path); err != nil {\n\t\t\t\t\t\tglog.Errorf(\"Error check path: %v\", err)\n\t\t\t\t\t\treturn\n\t\t\t\t\t} else {\n\t\t\t\t\t\tallPathsRemoved = allPathsRemoved && !exists"
  },
  {
    "id" : "2d0390d7-69f8-4862-8595-d7e0370b7bfa",
    "prId" : 10169,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4f428312-4e0e-41c2-898b-6f13a505f589",
        "parentId" : null,
        "authorId" : null,
        "body" : "It is possible for you to return success here when only one, and the not used symlink has been created.  Your subsequent attempt to stat the other symlink will then fail.  You don't want that.  I think we discussed this previously.\n",
        "createdAt" : "2015-06-27T00:43:57Z",
        "updatedAt" : "2015-06-30T20:31:17Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "e55b1027-affb-4361-80ec-8fc66d49f8b7",
        "parentId" : "4f428312-4e0e-41c2-898b-6f13a505f589",
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "The logic here is when a disk is attached there are multiple symlinks that are created--all of them link back to the same `/dev/sd*` drive. We watch all the possible symlinks and declare success when any one of them show up. This is not a problem, because we just need one handle to the PD and whichever symlink shows up first is sufficient for the PD to be considered attached and it can be used as the as the global mount point. And I'd argue that it's more robust to watch all of them, and grab on to the first one that shows up, rather than watch only one.\n",
        "createdAt" : "2015-06-29T00:33:33Z",
        "updatedAt" : "2015-06-30T20:31:17Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      },
      {
        "id" : "df7905c0-0a55-40da-ad00-a60bd811d6ee",
        "parentId" : "4f428312-4e0e-41c2-898b-6f13a505f589",
        "authorId" : null,
        "body" : "The problem is that I seem to recall that you mount the /dev/disk/by-id symlink, and not the /dev/sd device?  Let me check...\n",
        "createdAt" : "2015-06-29T15:33:09Z",
        "updatedAt" : "2015-06-30T20:31:17Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "324242bf-caa1-4b0f-a723-65a548470f5d",
        "parentId" : "4f428312-4e0e-41c2-898b-6f13a505f589",
        "authorId" : null,
        "body" : "Yes, definitely mounting the symlink. More later...\n",
        "createdAt" : "2015-06-29T16:00:56Z",
        "updatedAt" : "2015-06-30T20:31:17Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "56a42686-7fc6-4510-8eee-149c298e9cfa",
        "parentId" : "4f428312-4e0e-41c2-898b-6f13a505f589",
        "authorId" : null,
        "body" : "OK, I guess this will work.  It's just non-deterministic which symlink you'll mount (whichever one shows up first), which makes debugging a little tricky.  Lets leave it as it is.\n",
        "createdAt" : "2015-06-29T16:30:31Z",
        "updatedAt" : "2015-06-30T20:31:17Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "c952ee23a70ad0fbecaa1e2c311225e8a7b5e17c",
    "line" : 137,
    "diffHunk" : "@@ -1,1 +148,152 @@\t\t\t\t\t// A device path has succesfully been created for the PD\n\t\t\t\t\tglog.V(5).Infof(\"Succesfully attached GCE PD %q.\", pd.pdName)\n\t\t\t\t\treturn path, nil\n\t\t\t\t}\n\t\t\t}"
  },
  {
    "id" : "844fdeda-1c91-4fa0-90e1-ad2342604e97",
    "prId" : 10169,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d935cac6-42e6-41e2-9a03-ef6ce6020361",
        "parentId" : null,
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "do we have control of this prefix? If so, do we have to mix _ and -?\n",
        "createdAt" : "2015-06-30T19:18:23Z",
        "updatedAt" : "2015-06-30T20:31:17Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "e377061d-d55c-400f-9d66-06bed35bc750",
        "parentId" : "d935cac6-42e6-41e2-9a03-ef6ce6020361",
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "No, that's defined by GCE.\n",
        "createdAt" : "2015-06-30T19:21:42Z",
        "updatedAt" : "2015-06-30T20:31:17Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      }
    ],
    "commit" : "c952ee23a70ad0fbecaa1e2c311225e8a7b5e17c",
    "line" : 24,
    "diffHunk" : "@@ -1,1 +37,41 @@\tdiskByIdPath         = \"/dev/disk/by-id/\"\n\tdiskGooglePrefix     = \"google-\"\n\tdiskScsiGooglePrefix = \"scsi-0Google_PersistentDisk_\"\n\tdiskPartitionSuffix  = \"-part\"\n\tdiskSDPath           = \"/dev/sd\""
  },
  {
    "id" : "15383f2e-9047-4625-9687-f15596597d4c",
    "prId" : 10169,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a5ab2b7a-cce5-458b-9c7d-df5c57d0221d",
        "parentId" : null,
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "if this is intended to run as a goroutine, please add a comment to that effect, and defer util.HandleCrash.\n",
        "createdAt" : "2015-06-30T19:48:49Z",
        "updatedAt" : "2015-06-30T20:31:17Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "b9a2fc68-cab5-4240-8501-b70414ec23d4",
        "parentId" : "a5ab2b7a-cce5-458b-9c7d-df5c57d0221d",
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "Done.\n",
        "createdAt" : "2015-06-30T19:56:05Z",
        "updatedAt" : "2015-06-30T20:31:17Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      }
    ],
    "commit" : "c952ee23a70ad0fbecaa1e2c311225e8a7b5e17c",
    "line" : null,
    "diffHunk" : "@@ -1,1 +169,173 @@// Veify the specified persistent disk device has been succesfully detached, and retries if it fails.\n// This function is intended to be called asynchronously as a go routine.\nfunc verifyDetached(pd *gcePersistentDisk, gce cloudprovider.Interface) {\n\tdefer util.HandleCrash()\n"
  },
  {
    "id" : "827bcd3a-c67d-453b-8620-ba3bb32b253b",
    "prId" : 10169,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5692b7c6-9f5e-4be0-90b1-588140dbdd66",
        "parentId" : null,
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "Is this a permanent error? If not, please include something like \"will try again\" to keep down the number of support bugs opened.\n",
        "createdAt" : "2015-06-30T19:51:16Z",
        "updatedAt" : "2015-06-30T20:31:17Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "34b7f578-8401-4fad-ba6c-c53918350efc",
        "parentId" : "5692b7c6-9f5e-4be0-90b1-588140dbdd66",
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "This one is permanent, it means (10 second wait + detach) x 10 times all failed to detach the drive, so we're giving up (no further retries will happen).\n",
        "createdAt" : "2015-06-30T20:20:15Z",
        "updatedAt" : "2015-06-30T20:31:17Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      }
    ],
    "commit" : "c952ee23a70ad0fbecaa1e2c311225e8a7b5e17c",
    "line" : 210,
    "diffHunk" : "@@ -1,1 +221,225 @@\t}\n\n\tglog.Errorf(\"Could not detach GCE PD %q. One or more mount paths was not removed.\", pd.pdName)\n}\n"
  }
]
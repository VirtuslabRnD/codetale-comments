[
  {
    "id" : "50e9ebeb-5898-4e43-8738-715ab55af530",
    "prId" : 103244,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/103244#pullrequestreview-698625158",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ee5c6a22-539e-4ba5-8b2b-6173f0a64563",
        "parentId" : null,
        "authorId" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "body" : "If we are going to add a new type - does it make sense to roll all of existing params into same `DeviceMountArgs` type?",
        "createdAt" : "2021-06-30T20:23:13Z",
        "updatedAt" : "2021-07-01T16:00:29Z",
        "lastEditedBy" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "tags" : [
        ]
      },
      {
        "id" : "0c62b5a4-cfc5-4300-a2c0-2169fbe2898e",
        "parentId" : "ee5c6a22-539e-4ba5-8b2b-6173f0a64563",
        "authorId" : "34f61776-88da-4b26-aa20-3c4f92530d05",
        "body" : "My thinking was to keep the core, required arguments as method parameters and auxiliary, optional arguments in `DeviceMounterArgs`. WDYT? I could add a comment to clarify that preference.",
        "createdAt" : "2021-07-01T21:18:43Z",
        "updatedAt" : "2021-07-01T21:18:43Z",
        "lastEditedBy" : "34f61776-88da-4b26-aa20-3c4f92530d05",
        "tags" : [
        ]
      },
      {
        "id" : "712460f0-0b9d-43af-840c-1014e13bd004",
        "parentId" : "ee5c6a22-539e-4ba5-8b2b-6173f0a64563",
        "authorId" : "34f61776-88da-4b26-aa20-3c4f92530d05",
        "body" : "And the main reason to introduce an arg struct is to establish a pattern for future additions",
        "createdAt" : "2021-07-01T21:38:31Z",
        "updatedAt" : "2021-07-01T21:38:31Z",
        "lastEditedBy" : "34f61776-88da-4b26-aa20-3c4f92530d05",
        "tags" : [
        ]
      },
      {
        "id" : "97ba3dc6-a33b-4a1f-b096-b36274592566",
        "parentId" : "ee5c6a22-539e-4ba5-8b2b-6173f0a64563",
        "authorId" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "body" : "I personally would have made the choice of rolling everything in one `DeviceMountArgs` - but I can see, how your approach is fine too. I probably would not worry about it too much. ",
        "createdAt" : "2021-07-01T21:41:47Z",
        "updatedAt" : "2021-07-01T21:41:47Z",
        "lastEditedBy" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "tags" : [
        ]
      },
      {
        "id" : "8f41b8d5-e287-4664-8654-3835cf049b29",
        "parentId" : "ee5c6a22-539e-4ba5-8b2b-6173f0a64563",
        "authorId" : "34f61776-88da-4b26-aa20-3c4f92530d05",
        "body" : "Ack I left it as is",
        "createdAt" : "2021-07-03T23:26:11Z",
        "updatedAt" : "2021-07-03T23:26:12Z",
        "lastEditedBy" : "34f61776-88da-4b26-aa20-3c4f92530d05",
        "tags" : [
        ]
      }
    ],
    "commit" : "c50b3074fe876a91ac4a67d917b8f6c8caa922b2",
    "line" : 22,
    "diffHunk" : "@@ -1,1 +268,272 @@\nfunc (c *csiAttacher) MountDevice(spec *volume.Spec, devicePath string, deviceMountPath string, deviceMounterArgs volume.DeviceMounterArgs) error {\n\tklog.V(4).Infof(log(\"attacher.MountDevice(%s, %s)\", devicePath, deviceMountPath))\n\n\tif deviceMountPath == \"\" {"
  },
  {
    "id" : "76e24b63-d6b4-4aba-ad61-3c018a0aca8b",
    "prId" : 97834,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/97834#pullrequestreview-588244319",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f4f2b8fa-4837-49d9-be74-62bb12010c70",
        "parentId" : null,
        "authorId" : "47dfb7ab-db92-411d-a70b-1dc70d2a9420",
        "body" : "Is this optimization safe? Is it possible that volumeLister may be returning a stale attachment from cache?  ",
        "createdAt" : "2021-02-04T04:15:28Z",
        "updatedAt" : "2021-02-24T00:54:36Z",
        "lastEditedBy" : "47dfb7ab-db92-411d-a70b-1dc70d2a9420",
        "tags" : [
        ]
      },
      {
        "id" : "a232de29-c1c7-401d-96e7-aed6c6315302",
        "parentId" : "f4f2b8fa-4837-49d9-be74-62bb12010c70",
        "authorId" : "ffc1d568-c5ed-4932-82f4-3ae9d3bee69a",
        "body" : "I checked with someone on API machinery who suggested the staleness of data is usually on the order of hundreds of milliseconds, but in worst case scenarios it could be over a second.\r\n\r\nIn what scenario do you think this staleness could cause a problem?\r\n",
        "createdAt" : "2021-02-04T20:46:48Z",
        "updatedAt" : "2021-02-24T00:54:36Z",
        "lastEditedBy" : "ffc1d568-c5ed-4932-82f4-3ae9d3bee69a",
        "tags" : [
        ]
      },
      {
        "id" : "d811bab2-53d2-4e91-9a69-a0e074f34a4a",
        "parentId" : "f4f2b8fa-4837-49d9-be74-62bb12010c70",
        "authorId" : "47dfb7ab-db92-411d-a70b-1dc70d2a9420",
        "body" : "I do not know much about API machinery. Please ignore if you have already checked with an expert in this area. My scenario is:  Letâ€™s say vol1 is attached to node1 and is then detached and is being attached now. Is it possible for VALister to return success because of stale cache?",
        "createdAt" : "2021-02-10T05:12:26Z",
        "updatedAt" : "2021-02-24T00:54:36Z",
        "lastEditedBy" : "47dfb7ab-db92-411d-a70b-1dc70d2a9420",
        "tags" : [
        ]
      },
      {
        "id" : "50eedbef-b1b5-453b-be80-84b3c9a59c06",
        "parentId" : "f4f2b8fa-4837-49d9-be74-62bb12010c70",
        "authorId" : "ffc1d568-c5ed-4932-82f4-3ae9d3bee69a",
        "body" : "Yes it would be possible for the lister to return stale data which could cause it to think the VolumeAttachment already exists when it was just deleted. In this scenario the request would time out and then be retried next reconciler loop.\r\n\r\nIn the other race condition scenario where the VolumeAttachment doesn't show up in the lister (yet) but exists in the API, we ignore any \"AlreadyExists\" errors returned by the API and proceed with polling for the object until it's status shows a successful attachment.",
        "createdAt" : "2021-02-10T20:00:20Z",
        "updatedAt" : "2021-02-24T00:54:36Z",
        "lastEditedBy" : "ffc1d568-c5ed-4932-82f4-3ae9d3bee69a",
        "tags" : [
        ]
      },
      {
        "id" : "faa738b0-93fe-4f16-86fe-7be00e633f76",
        "parentId" : "f4f2b8fa-4837-49d9-be74-62bb12010c70",
        "authorId" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "body" : "if you are concern the case that VA still exist, but volume is already detached, I think the following verifyVolumeAttachment will check VA deletionTimeStamp is already set, and will return with error",
        "createdAt" : "2021-02-11T04:40:56Z",
        "updatedAt" : "2021-02-24T00:54:36Z",
        "lastEditedBy" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "tags" : [
        ]
      }
    ],
    "commit" : "f36fec997ad7abd619aecc0d4e95ab928e3acb09",
    "line" : 37,
    "diffHunk" : "@@ -1,1 +79,83 @@\tattachID := getAttachmentName(pvSrc.VolumeHandle, pvSrc.Driver, node)\n\n\tattachment, err := c.plugin.volumeAttachmentLister.Get(attachID)\n\tif err != nil && !apierrors.IsNotFound(err) {\n\t\treturn \"\", errors.New(log(\"failed to get volume attachment from lister: %v\", err))"
  },
  {
    "id" : "3b7f0c35-4089-413d-988a-4f96c775e2cd",
    "prId" : 97834,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/97834#pullrequestreview-587261449",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2c4a79f9-8969-4105-b2ad-6776c1501bd3",
        "parentId" : null,
        "authorId" : "47dfb7ab-db92-411d-a70b-1dc70d2a9420",
        "body" : "Can create fail here with alreadyExist error? What if the attachment was created after the lister call above.",
        "createdAt" : "2021-02-04T04:37:24Z",
        "updatedAt" : "2021-02-24T00:54:36Z",
        "lastEditedBy" : "47dfb7ab-db92-411d-a70b-1dc70d2a9420",
        "tags" : [
        ]
      },
      {
        "id" : "d65fdeca-baf7-4dfb-9027-f1af9787a6d6",
        "parentId" : "2c4a79f9-8969-4105-b2ad-6776c1501bd3",
        "authorId" : "ffc1d568-c5ed-4932-82f4-3ae9d3bee69a",
        "body" : "From my understanding, the reconciler can only process one attachment per attachment ID at a time, so in order for that to happen:\r\n\r\n- `Attach()` gets called once, creates attachment\r\n- An error gets thrown while waiting for the attachment, which causes the reconciler to try the attachment again\r\n- `Attach()` gets called again (faster than the \"staleness latency\" of the lister) and so it tries to create the attachment again (since it's not yet in the lister)\r\n- Attachment creation fails and the reconciler tries again until the object is present in the lister\r\n\r\nIf checking the lister before creating the object adds too much complexity in terms of thinking about possible race conditions, we can go back to the old behavior of trying to create the object. The only tradeoff is extra create calls to the API.",
        "createdAt" : "2021-02-04T20:56:20Z",
        "updatedAt" : "2021-02-24T00:54:36Z",
        "lastEditedBy" : "ffc1d568-c5ed-4932-82f4-3ae9d3bee69a",
        "tags" : [
        ]
      },
      {
        "id" : "9a35406a-b2c1-48a5-b56e-d62a0a79a3cd",
        "parentId" : "2c4a79f9-8969-4105-b2ad-6776c1501bd3",
        "authorId" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "body" : "after Create call, maybe use the same logic as before, if error type is alreadyExist, it can continue to waitForVolumeAttach instead of let reconciler to retry (this might cause a little bit delay due to exponential backoff)?",
        "createdAt" : "2021-02-09T03:01:08Z",
        "updatedAt" : "2021-02-24T00:54:36Z",
        "lastEditedBy" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "tags" : [
        ]
      },
      {
        "id" : "70850c0e-9be8-4c35-8384-04eade5b2166",
        "parentId" : "2c4a79f9-8969-4105-b2ad-6776c1501bd3",
        "authorId" : "47dfb7ab-db92-411d-a70b-1dc70d2a9420",
        "body" : "Looks like AlreadyExist error is now being handled below.",
        "createdAt" : "2021-02-10T05:12:45Z",
        "updatedAt" : "2021-02-24T00:54:36Z",
        "lastEditedBy" : "47dfb7ab-db92-411d-a70b-1dc70d2a9420",
        "tags" : [
        ]
      }
    ],
    "commit" : "f36fec997ad7abd619aecc0d4e95ab928e3acb09",
    "line" : 94,
    "diffHunk" : "@@ -1,1 +115,119 @@\t\t}\n\n\t\t_, err = c.k8s.StorageV1().VolumeAttachments().Create(context.TODO(), attachment, metav1.CreateOptions{})\n\t\tif err != nil {\n\t\t\tif !apierrors.IsAlreadyExists(err) {"
  },
  {
    "id" : "7ebd677c-c010-40d8-abf3-3a5920e0a925",
    "prId" : 97834,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/97834#pullrequestreview-588811333",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "57475042-034a-4b4e-aad1-6387fbd51366",
        "parentId" : null,
        "authorId" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "body" : "maybe first wait for pollInterval before get from lister to help avoid always retrying?",
        "createdAt" : "2021-02-09T03:41:09Z",
        "updatedAt" : "2021-02-24T00:54:36Z",
        "lastEditedBy" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "tags" : [
        ]
      },
      {
        "id" : "bb48b7d0-30c0-4a9d-9e7c-c68fca49394d",
        "parentId" : "57475042-034a-4b4e-aad1-6387fbd51366",
        "authorId" : "ffc1d568-c5ed-4932-82f4-3ae9d3bee69a",
        "body" : "This was the original approach. [See this comment thread](https://github.com/kubernetes/kubernetes/pull/97834#discussion_r569994822) for context on why I changed it. An advantage with this approach is that if the object is immediately available then we save one timer tick and attach faster. A disadvantage is this may not be likely for most VolumeAttachments so we may be performing extra work for something that is unlikely. I can always move it back if necessary.",
        "createdAt" : "2021-02-09T04:27:43Z",
        "updatedAt" : "2021-02-24T00:54:36Z",
        "lastEditedBy" : "ffc1d568-c5ed-4932-82f4-3ae9d3bee69a",
        "tags" : [
        ]
      },
      {
        "id" : "1eb102d7-8191-4bc8-9373-751abdd9ec9f",
        "parentId" : "57475042-034a-4b4e-aad1-6387fbd51366",
        "authorId" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "body" : "I remember you did some experiments about this. One tick is 500 ms. You can decide which way to go based on your data?",
        "createdAt" : "2021-02-09T05:20:03Z",
        "updatedAt" : "2021-02-24T00:54:36Z",
        "lastEditedBy" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "tags" : [
        ]
      },
      {
        "id" : "707f0b7c-4984-4e81-a416-86540988849e",
        "parentId" : "57475042-034a-4b4e-aad1-6387fbd51366",
        "authorId" : "ffc1d568-c5ed-4932-82f4-3ae9d3bee69a",
        "body" : "I tuned the ticker to be a bit more aggressive, this time 100ms. [These are the timings](https://gist.github.com/chrishenzie/2ed57c1a6bf45770c1bdffc93ee48036), compared with the [old timings when it was 500ms](https://gist.github.com/chrishenzie/237e9b06fffdbd3bbfd07c6dee121830). The speedup is somewhat negligible, around half a second to a second faster depending on test noise.",
        "createdAt" : "2021-02-09T18:16:26Z",
        "updatedAt" : "2021-02-24T00:54:36Z",
        "lastEditedBy" : "ffc1d568-c5ed-4932-82f4-3ae9d3bee69a",
        "tags" : [
        ]
      },
      {
        "id" : "7c0953e3-b3d6-40fc-b50d-5f3bdba909c5",
        "parentId" : "57475042-034a-4b4e-aad1-6387fbd51366",
        "authorId" : "ffc1d568-c5ed-4932-82f4-3ae9d3bee69a",
        "body" : "See the comment thread below. It seems like having an aggressive frequency (like 100ms) doesn't make sense since we're waiting on the result of a storage provider's API call which may take >10s. This should be tuned to something less frequent, like maybe 1 second.",
        "createdAt" : "2021-02-10T19:47:17Z",
        "updatedAt" : "2021-02-24T00:54:36Z",
        "lastEditedBy" : "ffc1d568-c5ed-4932-82f4-3ae9d3bee69a",
        "tags" : [
        ]
      },
      {
        "id" : "ebfce00b-bb67-49af-86f4-8a9f9c8feb95",
        "parentId" : "57475042-034a-4b4e-aad1-6387fbd51366",
        "authorId" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "body" : "what I mean is explicitly wait a little bit before getting to get VA from lister. I remember you mentioned that typically for the first time, this function will create VA, and then try to get VA from lister, which will fail mostly because VA has not yet in lister. Will it bring some benefit to wait a second so that lister will have the VA already when we check it here?",
        "createdAt" : "2021-02-11T04:44:59Z",
        "updatedAt" : "2021-02-24T00:54:36Z",
        "lastEditedBy" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "tags" : [
        ]
      },
      {
        "id" : "3cf593c1-76a1-48c4-a6d5-a34fdc688abc",
        "parentId" : "57475042-034a-4b4e-aad1-6387fbd51366",
        "authorId" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "body" : "also I agree 100ms is too aggressive, starting from 1 sec seems reasonable. ",
        "createdAt" : "2021-02-11T04:45:33Z",
        "updatedAt" : "2021-02-24T00:54:36Z",
        "lastEditedBy" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "tags" : [
        ]
      },
      {
        "id" : "bf7b9a95-0ed6-4fe9-a4f6-bcd0f4e210b9",
        "parentId" : "57475042-034a-4b4e-aad1-6387fbd51366",
        "authorId" : "ffc1d568-c5ed-4932-82f4-3ae9d3bee69a",
        "body" : "Ok, I've bumped it to 1 second",
        "createdAt" : "2021-02-11T17:31:05Z",
        "updatedAt" : "2021-02-24T00:54:36Z",
        "lastEditedBy" : "ffc1d568-c5ed-4932-82f4-3ae9d3bee69a",
        "tags" : [
        ]
      }
    ],
    "commit" : "f36fec997ad7abd619aecc0d4e95ab928e3acb09",
    "line" : 122,
    "diffHunk" : "@@ -1,1 +179,183 @@\t\tvolumeAttachment, err := c.plugin.volumeAttachmentLister.Get(attachID)\n\t\tif err != nil {\n\t\t\t// Ignore \"not found\" errors in case the VolumeAttachment was just created and hasn't yet made it into the lister.\n\t\t\tif !apierrors.IsNotFound(err) {\n\t\t\t\tklog.Error(log(\"unexpected error waiting for volume attachment, %v\", err))"
  },
  {
    "id" : "1adc58c8-63d4-4d6f-b21a-678ff1b7b810",
    "prId" : 91307,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/91307#pullrequestreview-422233898",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "421e29d8-9cc8-44ba-8267-e4368c06fda5",
        "parentId" : null,
        "authorId" : "90cfc0c5-e945-4584-be7e-3411fd993507",
        "body" : "Can this log be moved to line 204? ",
        "createdAt" : "2020-05-28T18:20:49Z",
        "updatedAt" : "2020-06-11T19:21:09Z",
        "lastEditedBy" : "90cfc0c5-e945-4584-be7e-3411fd993507",
        "tags" : [
        ]
      },
      {
        "id" : "8505328e-a1bb-4a00-9ee1-4e8c0c9c66f3",
        "parentId" : "421e29d8-9cc8-44ba-8267-e4368c06fda5",
        "authorId" : "47dfb7ab-db92-411d-a70b-1dc70d2a9420",
        "body" : "did some refactoring here. ",
        "createdAt" : "2020-06-01T22:53:19Z",
        "updatedAt" : "2020-06-11T19:21:09Z",
        "lastEditedBy" : "47dfb7ab-db92-411d-a70b-1dc70d2a9420",
        "tags" : [
        ]
      }
    ],
    "commit" : "2a895776592e674fdb6283e51effe23c23d78797",
    "line" : 15,
    "diffHunk" : "@@ -1,1 +209,213 @@\t\t// The cache lookup is not setup or the object is not found in the cache.\n\t\t// Get the object from the API server.\n\t\tklog.V(4).Info(log(\"probing attachment status for VolumeAttachment %v\", attachID))\n\t\tattach, err = c.k8s.StorageV1().VolumeAttachments().Get(context.TODO(), attachID, meta.GetOptions{})\n\t\tif err != nil {"
  },
  {
    "id" : "0e7df86c-2aa3-4ccc-a529-1f68ac24c0c5",
    "prId" : 91307,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/91307#pullrequestreview-426702638",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e278221c-f486-4563-81c3-1c3c942746b1",
        "parentId" : null,
        "authorId" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "body" : "Is the only time this is nil in unit tests?",
        "createdAt" : "2020-06-04T01:27:07Z",
        "updatedAt" : "2020-06-11T19:21:09Z",
        "lastEditedBy" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "tags" : [
        ]
      },
      {
        "id" : "4778e873-5134-43ad-afa3-67e486c73e22",
        "parentId" : "e278221c-f486-4563-81c3-1c3c942746b1",
        "authorId" : "47dfb7ab-db92-411d-a70b-1dc70d2a9420",
        "body" : "Yes, I think so.",
        "createdAt" : "2020-06-04T17:22:17Z",
        "updatedAt" : "2020-06-11T19:21:09Z",
        "lastEditedBy" : "47dfb7ab-db92-411d-a70b-1dc70d2a9420",
        "tags" : [
        ]
      },
      {
        "id" : "12375ed5-f39e-44b4-ab7c-2a39d6f24874",
        "parentId" : "e278221c-f486-4563-81c3-1c3c942746b1",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "adding different test-only code paths doesn't seem like a good idea, especially if it makes unit tests behave significantly differently than real runs",
        "createdAt" : "2020-06-04T19:30:42Z",
        "updatedAt" : "2020-06-11T19:21:09Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "afbeed52-d6f8-444b-bdab-970acd2b5ea8",
        "parentId" : "e278221c-f486-4563-81c3-1c3c942746b1",
        "authorId" : "47dfb7ab-db92-411d-a70b-1dc70d2a9420",
        "body" : "The unit-tests were modified to supply the VolumeAttachListers, so they do exercise the Listers(). ",
        "createdAt" : "2020-06-09T00:06:23Z",
        "updatedAt" : "2020-06-11T19:21:09Z",
        "lastEditedBy" : "47dfb7ab-db92-411d-a70b-1dc70d2a9420",
        "tags" : [
        ]
      }
    ],
    "commit" : "2a895776592e674fdb6283e51effe23c23d78797",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +199,203 @@\t\tattachID := getAttachmentName(volumeHandle, driverName, string(nodeName))\n\t\tvar attach *storage.VolumeAttachment\n\t\tif c.plugin.volumeAttachmentLister != nil {\n\t\t\tattach, err = c.plugin.volumeAttachmentLister.Get(attachID)\n\t\t\tif err == nil {"
  },
  {
    "id" : "5f26d362-cf8a-403e-a12a-ebc7979f5151",
    "prId" : 91307,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/91307#pullrequestreview-426702638",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8d661a9a-8d60-47f5-9b5b-b1c0670bbc5f",
        "parentId" : null,
        "authorId" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "body" : "Should we log the error?",
        "createdAt" : "2020-06-04T01:28:54Z",
        "updatedAt" : "2020-06-11T19:21:09Z",
        "lastEditedBy" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "tags" : [
        ]
      },
      {
        "id" : "cf209248-68e7-4966-b2fb-3a3d0632ab17",
        "parentId" : "8d661a9a-8d60-47f5-9b5b-b1c0670bbc5f",
        "authorId" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "body" : "Please handle NotFound error here - such volume is detached and you should mark them so.",
        "createdAt" : "2020-06-04T08:33:06Z",
        "updatedAt" : "2020-06-11T19:21:09Z",
        "lastEditedBy" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "tags" : [
        ]
      },
      {
        "id" : "d8828677-c271-4ff4-9fe0-83821e986f22",
        "parentId" : "8d661a9a-8d60-47f5-9b5b-b1c0670bbc5f",
        "authorId" : "47dfb7ab-db92-411d-a70b-1dc70d2a9420",
        "body" : "Ok. Will add the log under failure.\r\n\r\n>> Please handle NotFound error here\r\nI think you meant at line 212 (error from API server). If the object is not found in the informer/cache, it may be reasonable to Get() from API server?",
        "createdAt" : "2020-06-04T17:43:23Z",
        "updatedAt" : "2020-06-11T19:21:09Z",
        "lastEditedBy" : "47dfb7ab-db92-411d-a70b-1dc70d2a9420",
        "tags" : [
        ]
      },
      {
        "id" : "fed34753-ab77-4ed5-9879-67aae79284c4",
        "parentId" : "8d661a9a-8d60-47f5-9b5b-b1c0670bbc5f",
        "authorId" : "47dfb7ab-db92-411d-a70b-1dc70d2a9420",
        "body" : "Added a log in case of error from cache lookup. The current logic treats volume as detached for any error from api server (so NotFound is also covered.",
        "createdAt" : "2020-06-09T00:08:31Z",
        "updatedAt" : "2020-06-11T19:21:09Z",
        "lastEditedBy" : "47dfb7ab-db92-411d-a70b-1dc70d2a9420",
        "tags" : [
        ]
      }
    ],
    "commit" : "2a895776592e674fdb6283e51effe23c23d78797",
    "line" : 10,
    "diffHunk" : "@@ -1,1 +204,208 @@\t\t\t\tattached[spec] = attach.Status.Attached\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tklog.V(4).Info(log(\"attacher.VolumesAreAttached failed in AttachmentLister for attach.ID=%v: %v. Probing the API server.\", attachID, err))\n\t\t}"
  },
  {
    "id" : "f34f0d11-073b-46a3-807b-0d608a6fce91",
    "prId" : 91307,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/91307#pullrequestreview-424726983",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f5fff5d9-827d-4137-8a7f-7f46704d584e",
        "parentId" : null,
        "authorId" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "body" : "This isn't related to your change but I wonder if this logic is correct. If apiserver is temporarily down, then we mark the volume as detached? cc @jsafrane ",
        "createdAt" : "2020-06-04T01:30:16Z",
        "updatedAt" : "2020-06-11T19:21:09Z",
        "lastEditedBy" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "tags" : [
        ]
      },
      {
        "id" : "43f8c45e-13c2-489e-8835-1d7cbac8a71a",
        "parentId" : "f5fff5d9-827d-4137-8a7f-7f46704d584e",
        "authorId" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "body" : "Yes, it looks suspicious. `NotFound` should be handled, because only that means the volume is detached. Any other error does not mean anything.",
        "createdAt" : "2020-06-04T18:35:51Z",
        "updatedAt" : "2020-06-11T19:21:09Z",
        "lastEditedBy" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "tags" : [
        ]
      }
    ],
    "commit" : "2a895776592e674fdb6283e51effe23c23d78797",
    "line" : 18,
    "diffHunk" : "@@ -1,1 +211,215 @@\t\tklog.V(4).Info(log(\"probing attachment status for VolumeAttachment %v\", attachID))\n\t\tattach, err = c.k8s.StorageV1().VolumeAttachments().Get(context.TODO(), attachID, meta.GetOptions{})\n\t\tif err != nil {\n\t\t\tattached[spec] = false\n\t\t\tklog.Error(log(\"attacher.VolumesAreAttached failed for attach.ID=%v: %v\", attachID, err))"
  },
  {
    "id" : "1a7ca4e7-24a3-4e6f-956f-c17f211e8f64",
    "prId" : 91307,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/91307#pullrequestreview-428227508",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e015ca9b-efb8-466d-bde6-a93331426767",
        "parentId" : null,
        "authorId" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "body" : "From the discussion in https://github.com/kubernetes-csi/external-attacher/issues/215#issuecomment-601065201, we should only use the absence of the VolumeAttachment object to indicate that the volume is detached. If the `status.attached` is false, that could mean that we're in the process of attaching, and we probably don't want to mark it as detached here.  Same with L218.\r\n\r\nDo we want to make the change in this PR or separately? \r\n\r\nAlso can potentially be investigated separately, but is it possible to have a race where we're starting to Attach, but haven't created the VolumeAttachment object yet? Then this comes along and marks it as detached? AFIAK, the Attach operartion is launched as a separate go routine and we don't wait for it to complete before coming here.\r\n\r\ncc @jsafrane ",
        "createdAt" : "2020-06-04T01:46:19Z",
        "updatedAt" : "2020-06-11T19:21:09Z",
        "lastEditedBy" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "tags" : [
        ]
      },
      {
        "id" : "659b35a7-9798-4491-a10b-f8e27fd075b1",
        "parentId" : "e015ca9b-efb8-466d-bde6-a93331426767",
        "authorId" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "body" : "I think A/D controller calls `VolumesAreAttached` for volumes that are marked as attached. So in the worst case, A/D controller starts detach + `VolumesAreAttached` in parallel and `VolumesAreAttached` can mark the volume as detached earlier than `Detach()` would do.\r\n\r\nIs it possible to attach, call VolumesAreAttached, detach and attach a volume so quickly that the second attach succeeds before VolumesAreAttached evaluates the old attachment and considers it detached? As consequence, Attach would be called again and it succeeds immediately.",
        "createdAt" : "2020-06-04T08:29:32Z",
        "updatedAt" : "2020-06-11T19:21:09Z",
        "lastEditedBy" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "tags" : [
        ]
      },
      {
        "id" : "3c672323-5b82-429f-b76d-254de0e43f2e",
        "parentId" : "e015ca9b-efb8-466d-bde6-a93331426767",
        "authorId" : "47dfb7ab-db92-411d-a70b-1dc70d2a9420",
        "body" : ">> Do we want to make the change in this PR or separately?\r\nHow about limiting this PR for addressing the scalability issue!\r\n\r\nAs stated above, if `VolumesAreAttached` is called only on volumes that are already marked as `attached`, then probably the current logic is Ok. The attach/detach need not be set based on the presence/absense of the object?  \r\n",
        "createdAt" : "2020-06-04T17:38:42Z",
        "updatedAt" : "2020-06-11T19:21:09Z",
        "lastEditedBy" : "47dfb7ab-db92-411d-a70b-1dc70d2a9420",
        "tags" : [
        ]
      },
      {
        "id" : "4e71ba7b-34d8-4da5-8b6f-0d74314854b9",
        "parentId" : "e015ca9b-efb8-466d-bde6-a93331426767",
        "authorId" : "275dd783-53c3-4fed-8434-96ed6a2e0331",
        "body" : "Are you going to change this to check if the VolumeAttachment object exists or still check Status.Attached here?",
        "createdAt" : "2020-06-10T13:22:34Z",
        "updatedAt" : "2020-06-11T19:21:09Z",
        "lastEditedBy" : "275dd783-53c3-4fed-8434-96ed6a2e0331",
        "tags" : [
        ]
      },
      {
        "id" : "31ba92fb-645a-4d12-9598-11a5a9601ee8",
        "parentId" : "e015ca9b-efb8-466d-bde6-a93331426767",
        "authorId" : "47dfb7ab-db92-411d-a70b-1dc70d2a9420",
        "body" : "I prefer to keep the scope of this PR to address the slowness when number of volumeAttachments scale. I think the [cleanup](https://github.com/kubernetes/kubernetes/pull/91307#issuecomment-639141621) including setting the attach status based on presence of the object, can follow in a future PR.  ",
        "createdAt" : "2020-06-10T16:24:09Z",
        "updatedAt" : "2020-06-11T19:21:09Z",
        "lastEditedBy" : "47dfb7ab-db92-411d-a70b-1dc70d2a9420",
        "tags" : [
        ]
      }
    ],
    "commit" : "2a895776592e674fdb6283e51effe23c23d78797",
    "line" : 8,
    "diffHunk" : "@@ -1,1 +202,206 @@\t\t\tattach, err = c.plugin.volumeAttachmentLister.Get(attachID)\n\t\t\tif err == nil {\n\t\t\t\tattached[spec] = attach.Status.Attached\n\t\t\t\tcontinue\n\t\t\t}"
  },
  {
    "id" : "6b3db0c9-bf7e-425c-beb1-0f775e50a028",
    "prId" : 91307,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/91307#pullrequestreview-428452868",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9d3fe99b-b53f-4cd1-a38d-0372baa40ce2",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "are there any correctness implications if we get a stale attachment object here from the informer?",
        "createdAt" : "2020-06-04T19:31:12Z",
        "updatedAt" : "2020-06-11T19:21:09Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "7aa9f8a6-86de-452b-a4ec-bdebda9147dd",
        "parentId" : "9d3fe99b-b53f-4cd1-a38d-0372baa40ce2",
        "authorId" : "47dfb7ab-db92-411d-a70b-1dc70d2a9420",
        "body" : "I think you meant the object in the cache could be stale because the APi server has not notified the new state yet. We come here only for objects that are already Attached (see ref below). In case if this volume is detached, and if we get a stale object from the cache that says the volume is still Attached, I think its Ok as the correct state is notified probably by next cycle.\r\nref: https://github.com/kubernetes/kubernetes/blob/323f34858de18b862d43c40b2cced65ad8e24052/pkg/controller/volume/attachdetach/reconciler/reconciler.go#L133",
        "createdAt" : "2020-06-09T00:43:57Z",
        "updatedAt" : "2020-06-11T19:21:09Z",
        "lastEditedBy" : "47dfb7ab-db92-411d-a70b-1dc70d2a9420",
        "tags" : [
        ]
      },
      {
        "id" : "501cf379-b8b2-40bb-bbce-f4bb0f3450c8",
        "parentId" : "9d3fe99b-b53f-4cd1-a38d-0372baa40ce2",
        "authorId" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "body" : "Given that we shouldn't come here if the volume isn't attached yet, then I think we could remove the fallback to apiserver entirely. But we can handle that bigger change as part of a followup since we want to backport this.",
        "createdAt" : "2020-06-10T21:49:16Z",
        "updatedAt" : "2020-06-11T19:21:09Z",
        "lastEditedBy" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "tags" : [
        ]
      }
    ],
    "commit" : "2a895776592e674fdb6283e51effe23c23d78797",
    "line" : 17,
    "diffHunk" : "@@ -1,1 +210,214 @@\t\t// Get the object from the API server.\n\t\tklog.V(4).Info(log(\"probing attachment status for VolumeAttachment %v\", attachID))\n\t\tattach, err = c.k8s.StorageV1().VolumeAttachments().Get(context.TODO(), attachID, meta.GetOptions{})\n\t\tif err != nil {\n\t\t\tattached[spec] = false"
  },
  {
    "id" : "4d6e7d5c-f2f9-477f-b263-b0b7461c6da1",
    "prId" : 88569,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/88569#pullrequestreview-366367532",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "354616d5-6de7-4540-a457-ccb1e2c1edba",
        "parentId" : null,
        "authorId" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "body" : "I think actually we may want to skip this check altogether and just always call StagePublish. @gnufied @jsafrane do you see any problems with that? Ref https://github.com/kubernetes/kubernetes/issues/86784",
        "createdAt" : "2020-02-26T17:53:58Z",
        "updatedAt" : "2020-02-26T17:53:58Z",
        "lastEditedBy" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "tags" : [
        ]
      },
      {
        "id" : "77bf04c1-8376-493b-ac28-43f6cf0dbdb5",
        "parentId" : "354616d5-6de7-4540-a457-ccb1e2c1edba",
        "authorId" : "e0218e0a-9e55-43f5-8929-04673eea9015",
        "body" : "yes, we don't even need to do `os.MkdirAll(deviceMountPath, 0750)`, all leave csi driver to handle that logic:\r\nhttps://github.com/kubernetes/kubernetes/blob/e4a5012de6b49ca7c3b10c4647205fdca66014ee/pkg/volume/csi/csi_attacher.go#L290-L293\r\nthis looks like a big behavior change, is it ok to do this in this PR?",
        "createdAt" : "2020-02-27T01:25:14Z",
        "updatedAt" : "2020-02-27T01:25:14Z",
        "lastEditedBy" : "e0218e0a-9e55-43f5-8929-04673eea9015",
        "tags" : [
        ]
      },
      {
        "id" : "051a9d71-06c6-4386-a90f-601f7be33825",
        "parentId" : "354616d5-6de7-4540-a457-ccb1e2c1edba",
        "authorId" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "body" : "I am okay with removing the mounted check, but it requires uncertain mount fix to work reliably, so we won't be able to backport that change to versions without uncertain fix",
        "createdAt" : "2020-02-27T15:31:17Z",
        "updatedAt" : "2020-02-27T16:58:49Z",
        "lastEditedBy" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "tags" : [
        ]
      },
      {
        "id" : "b8b08107-27b0-4e5d-9645-eba58f0761f7",
        "parentId" : "354616d5-6de7-4540-a457-ccb1e2c1edba",
        "authorId" : "e0218e0a-9e55-43f5-8929-04673eea9015",
        "body" : "I would like to back port this fix to old release, so shall we go with this PR now?\r\nabout `removing the mounted check`, I could work out another PR that won't be back ported, is that ok?  @gnufied thanks.",
        "createdAt" : "2020-02-28T12:38:06Z",
        "updatedAt" : "2020-02-28T12:49:33Z",
        "lastEditedBy" : "e0218e0a-9e55-43f5-8929-04673eea9015",
        "tags" : [
        ]
      }
    ],
    "commit" : "5a6435ad768fb8cd3c8100c3ddc0575b74a97efd",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +230,234 @@\n\tcorruptedDir := false\n\tmounted, err := isDirMounted(c.plugin, deviceMountPath)\n\tif err != nil {\n\t\tklog.Error(log(\"attacher.MountDevice failed while checking mount status for dir [%s]\", deviceMountPath))"
  },
  {
    "id" : "8631f2df-4b5d-4df0-8d42-09864dc9dc51",
    "prId" : 79005,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/79005#pullrequestreview-269854024",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fa8b5344-7f39-4e79-8831-85194d811cdd",
        "parentId" : null,
        "authorId" : "54b8eb75-28dd-421d-a52b-63bf897147a9",
        "body" : "I think #79144 already does this.  Should you consider closing this PR ?",
        "createdAt" : "2019-08-01T20:14:46Z",
        "updatedAt" : "2019-08-28T03:18:40Z",
        "lastEditedBy" : "54b8eb75-28dd-421d-a52b-63bf897147a9",
        "tags" : [
        ]
      }
    ],
    "commit" : "28dc53f727c42b72fcc5846bf411008368e556ed",
    "line" : 25,
    "diffHunk" : "@@ -1,1 +517,521 @@\n\t\t\tcase watch.Error:\n\t\t\t\tklog.Warningf(\"waitForVolumeDetachmentInternal received watch error: %v\", event)\n\t\t\t}\n"
  },
  {
    "id" : "a9058e81-dfce-4371-9cf1-af2eae85662e",
    "prId" : 74086,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/74086#pullrequestreview-211997834",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1ac9f261-cb4c-4cc3-92a2-b7811ba84d6b",
        "parentId" : null,
        "authorId" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "body" : "does this need to be explicitly set?",
        "createdAt" : "2019-03-07T19:21:48Z",
        "updatedAt" : "2019-03-08T17:42:34Z",
        "lastEditedBy" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "tags" : [
        ]
      },
      {
        "id" : "5d7232e8-3350-4ac5-9dae-14e124ca87c3",
        "parentId" : "1ac9f261-cb4c-4cc3-92a2-b7811ba84d6b",
        "authorId" : "54b8eb75-28dd-421d-a52b-63bf897147a9",
        "body" : "Yes, if not it creates a bug that only shows up when there is an error where the `len(attached) != len(specs)`. It's bug that showed up during testing.",
        "createdAt" : "2019-03-07T20:15:58Z",
        "updatedAt" : "2019-03-08T17:42:34Z",
        "lastEditedBy" : "54b8eb75-28dd-421d-a52b-63bf897147a9",
        "tags" : [
        ]
      }
    ],
    "commit" : "923ad369c8a65c8aac47b22457e7e18bbcc1f335",
    "line" : 61,
    "diffHunk" : "@@ -1,1 +223,227 @@\t\tpvSrc, err := getPVSourceFromSpec(spec)\n\t\tif err != nil {\n\t\t\tattached[spec] = false\n\t\t\tklog.Error(log(\"attacher.VolumesAreAttached failed to get CSIPersistentVolumeSource: %v\", err))\n\t\t\tcontinue"
  },
  {
    "id" : "e65552dd-ba54-4bee-aa0c-87edcec74b5d",
    "prId" : 69830,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/69830#pullrequestreview-165955888",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "84c7f70f-c298-4be8-9281-efe1489804ef",
        "parentId" : null,
        "authorId" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "body" : "This is going to break if I have GCE PD with name \"csi-<something that looks like hash>\". Looking at the code, it will try to delete VolumeAttachment of given volume.\r\n\r\nCan it break things? To mis-use this to detach another volume, I need to craft GCE PD with name `csi-<another attachment>`, run a pod with it, restart controller and delete the pod. That does not look like a viable attack vector. Are there other attacks possible?",
        "createdAt" : "2018-10-16T08:56:36Z",
        "updatedAt" : "2019-02-15T01:04:36Z",
        "lastEditedBy" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "tags" : [
        ]
      },
      {
        "id" : "282a4934-ed09-417d-82e4-08df86a48a0e",
        "parentId" : "84c7f70f-c298-4be8-9281-efe1489804ef",
        "authorId" : "542e5d2f-2ff9-4674-ab44-78f31768e7a1",
        "body" : "you will not even be able to detach in-tree GCE PD as you would have had to switch between in-tree and migrated version of A/D Controller in the `restart controller` step. I am assuming if you have that much control over A/D Controller you have enough privileges that you could detach anything you pleased anyway.\r\n\r\nI don't believe there are any other attack vectors here as attachID is only used to delete volume attachment objects and waiting for them to be deleted.",
        "createdAt" : "2018-10-17T21:21:26Z",
        "updatedAt" : "2019-02-15T01:04:36Z",
        "lastEditedBy" : "542e5d2f-2ff9-4674-ab44-78f31768e7a1",
        "tags" : [
        ]
      },
      {
        "id" : "3eb8c315-f179-4284-97c6-acffb7d8c12d",
        "parentId" : "84c7f70f-c298-4be8-9281-efe1489804ef",
        "authorId" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "body" : "ack",
        "createdAt" : "2018-10-18T07:29:18Z",
        "updatedAt" : "2019-02-15T01:04:36Z",
        "lastEditedBy" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "tags" : [
        ]
      }
    ],
    "commit" : "5dde1df1cd438b7c2749fc08ad1d6bd8b173d010",
    "line" : 60,
    "diffHunk" : "@@ -1,1 +577,581 @@// isAttachmentName returns true if the string given is of the form of an Attach ID\n// and false otherwise\nfunc isAttachmentName(unknownString string) bool {\n\t// 68 == \"csi-\" + len(sha256hash)\n\tif strings.HasPrefix(unknownString, \"csi-\") && len(unknownString) == 68 {"
  },
  {
    "id" : "ff223d26-aaf9-4ddb-8a5e-ced8cd483e3e",
    "prId" : 65323,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/65323#pullrequestreview-132082709",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1019920c-85f4-42d9-9ea2-b293d42ae8d6",
        "parentId" : null,
        "authorId" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "body" : "Also should all the early error returns set err first so that the correct error will be logged here?  For example L311, 322, 331, 336, 345",
        "createdAt" : "2018-06-22T17:13:25Z",
        "updatedAt" : "2018-06-26T15:40:19Z",
        "lastEditedBy" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "tags" : [
        ]
      },
      {
        "id" : "1fa71721-7e2c-42d1-9fee-08da995fd578",
        "parentId" : "1019920c-85f4-42d9-9ea2-b293d42ae8d6",
        "authorId" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "body" : "Fixed 322, 331 336 and 345. I can't see anything wrong in 311.",
        "createdAt" : "2018-06-25T07:29:11Z",
        "updatedAt" : "2018-06-26T15:40:19Z",
        "lastEditedBy" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "tags" : [
        ]
      },
      {
        "id" : "2d2b9a71-3dbc-4fd7-8cc3-536fbb5a7d2b",
        "parentId" : "1019920c-85f4-42d9-9ea2-b293d42ae8d6",
        "authorId" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "body" : "My question regarding 311, 332, 337: is there a reason to log almost the same message first before returning the error, which will then be logged again in the defer?",
        "createdAt" : "2018-06-25T17:17:47Z",
        "updatedAt" : "2018-06-26T15:40:19Z",
        "lastEditedBy" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "tags" : [
        ]
      },
      {
        "id" : "4abc21ee-942a-43eb-99ad-095563d59996",
        "parentId" : "1019920c-85f4-42d9-9ea2-b293d42ae8d6",
        "authorId" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "body" : "I see, I removed these error logs.",
        "createdAt" : "2018-06-26T15:40:39Z",
        "updatedAt" : "2018-06-26T15:40:39Z",
        "lastEditedBy" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "tags" : [
        ]
      }
    ],
    "commit" : "9069efe73acf3b3956af8fd4d8e6e8df2c67abc4",
    "line" : 43,
    "diffHunk" : "@@ -1,1 +292,296 @@\t\tif err != nil {\n\t\t\t// clean up metadata\n\t\t\tglog.Errorf(log(\"attacher.MountDevice failed: %v\", err))\n\t\t\tif err := removeMountDir(c.plugin, deviceMountPath); err != nil {\n\t\t\t\tglog.Error(log(\"attacher.MountDevice failed to remove mount dir after errir [%s]: %v\", deviceMountPath, err))"
  },
  {
    "id" : "e29d9f73-6f53-4ff7-a1f1-a32eea04f1ad",
    "prId" : 64882,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/64882#pullrequestreview-130878997",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5cda7011-e3ef-4ee5-a8e9-fb40b54a3988",
        "parentId" : null,
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "Won't this end up putting the file in the same dir that is mounted?\r\nOn the mount side, it saves the file in `/blah/savefile.txt` and puts the mount in `/blah/mount/`",
        "createdAt" : "2018-06-20T07:23:01Z",
        "updatedAt" : "2018-06-20T07:29:35Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      },
      {
        "id" : "8a56f59c-cd82-490e-a5d5-ac025a3496e9",
        "parentId" : "5cda7011-e3ef-4ee5-a8e9-fb40b54a3988",
        "authorId" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "body" : "No, that's why there is `filepath.Dir`. It ends up in `/var/lib/kubelet/plugins/kubernetes.io/csi/pv/pvc-938861e4756911e8/vol_data.json` and the volume is mounted into `/var/lib/kubelet/plugins/kubernetes.io/csi/pv/pvc-938861e4756911e8/globalmount`.\r\n\r\n",
        "createdAt" : "2018-06-21T15:46:46Z",
        "updatedAt" : "2018-06-21T15:46:47Z",
        "lastEditedBy" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "tags" : [
        ]
      }
    ],
    "commit" : "acad9d89fa2915553a194fde3f515566cc2a8e05",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +270,274 @@\t}\n\n\tdataDir := filepath.Dir(deviceMountPath)\n\tif err := os.MkdirAll(dataDir, 0750); err != nil {\n\t\tglog.Error(log(\"attacher.MountDevice failed to create dir %#v:  %v\", dataDir, err))"
  },
  {
    "id" : "5426e948-67a8-435c-9dae-2d8a372814a1",
    "prId" : 64882,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/64882#pullrequestreview-130599382",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b3460409-6af0-4afd-a19d-e62c367b8b85",
        "parentId" : null,
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "The mount side saves a lot more:\r\n\r\n```GO\r\n\t\tvolDataKey.specVolID:    spec.Name(),\r\n\t\tvolDataKey.volHandle:    pvSource.VolumeHandle,\r\n\t\tvolDataKey.driverName:   pvSource.Driver,\r\n\t\tvolDataKey.nodeName:     node,\r\n\t\tvolDataKey.attachmentID: attachID,\r\n```\r\n\r\nAre we sure we don't need anything else from the spec?",
        "createdAt" : "2018-06-20T07:24:32Z",
        "updatedAt" : "2018-06-20T07:29:35Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      },
      {
        "id" : "b42d9e9d-47fe-4436-aa9e-a6dc704d1398",
        "parentId" : "b3460409-6af0-4afd-a19d-e62c367b8b85",
        "authorId" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "body" : "No, [UnstageVolume](https://github.com/container-storage-interface/spec/blob/master/spec.md#nodeunstagevolume) needs just volume id (+ driver).",
        "createdAt" : "2018-06-20T08:50:58Z",
        "updatedAt" : "2018-06-20T08:50:59Z",
        "lastEditedBy" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "tags" : [
        ]
      },
      {
        "id" : "ebcacbec-029c-496a-a1e0-3c4d912de8ca",
        "parentId" : "b3460409-6af0-4afd-a19d-e62c367b8b85",
        "authorId" : "54b8eb75-28dd-421d-a52b-63bf897147a9",
        "body" : "@saad-ali the mount side saves more info because it's needed to reconstruct the VolumeAttachment ID in subsequent steps.",
        "createdAt" : "2018-06-20T21:41:02Z",
        "updatedAt" : "2018-06-20T21:46:49Z",
        "lastEditedBy" : "54b8eb75-28dd-421d-a52b-63bf897147a9",
        "tags" : [
        ]
      }
    ],
    "commit" : "acad9d89fa2915553a194fde3f515566cc2a8e05",
    "line" : 12,
    "diffHunk" : "@@ -1,1 +278,282 @@\tdata := map[string]string{\n\t\tvolDataKey.volHandle:  csiSource.VolumeHandle,\n\t\tvolDataKey.driverName: csiSource.Driver,\n\t}\n\tif err := saveVolumeData(dataDir, volDataFileName, data); err != nil {"
  },
  {
    "id" : "02fdedf5-0cb9-4582-b5cf-6068c6752e54",
    "prId" : 64882,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/64882#pullrequestreview-130599382",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1005884d-986c-48ee-8de6-84b032766a67",
        "parentId" : null,
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "@vladimirvivien: you recently moved `saveVolumeData(...)` from `SetupAt(...)` to `NewMounter(...)`. Does something similar need to happen here?",
        "createdAt" : "2018-06-20T07:26:20Z",
        "updatedAt" : "2018-06-20T07:29:35Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      },
      {
        "id" : "36922fbe-ce31-46ab-94d5-7a5770a3c84e",
        "parentId" : "1005884d-986c-48ee-8de6-84b032766a67",
        "authorId" : "54b8eb75-28dd-421d-a52b-63bf897147a9",
        "body" : "@saad-ali unfortunately, the way the Attacher API is written, no params is available during `csi_plugin.go#NewAttacher/#NewDetacher` that would allow the volume info to be persisted at that point as is done wit NewMounter/Unmounter.  So, the saving of the volume info has to happen during `MountDevice` call.",
        "createdAt" : "2018-06-20T21:40:03Z",
        "updatedAt" : "2018-06-20T21:46:49Z",
        "lastEditedBy" : "54b8eb75-28dd-421d-a52b-63bf897147a9",
        "tags" : [
        ]
      }
    ],
    "commit" : "acad9d89fa2915553a194fde3f515566cc2a8e05",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +280,284 @@\t\tvolDataKey.driverName: csiSource.Driver,\n\t}\n\tif err := saveVolumeData(dataDir, volDataFileName, data); err != nil {\n\t\tglog.Error(log(\"failed to save volume info data: %v\", err))\n\t\tif err := os.RemoveAll(dataDir); err != nil {"
  },
  {
    "id" : "46430f74-e583-4be8-9436-993cbdba4270",
    "prId" : 64882,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/64882#pullrequestreview-130921436",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "dda4f2a7-cb38-4298-a339-f5bb5612a92f",
        "parentId" : null,
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "If the `MountDevice(...)` operation fails below, how is the save file cleaned up?",
        "createdAt" : "2018-06-20T07:27:55Z",
        "updatedAt" : "2018-06-20T07:29:35Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      },
      {
        "id" : "719a82e0-5201-43dc-b475-785848926bac",
        "parentId" : "dda4f2a7-cb38-4298-a339-f5bb5612a92f",
        "authorId" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "body" : "If `MounDevice` fails, then the whole directory is cleaned by `removeMountDir`. But you raised valid point, there are other error paths (e.g. failed to load secrets) that lead to uncleaned json file. I'll fix it.",
        "createdAt" : "2018-06-21T15:48:13Z",
        "updatedAt" : "2018-06-21T15:48:13Z",
        "lastEditedBy" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "tags" : [
        ]
      },
      {
        "id" : "24eac3ab-9421-4591-bb50-8b6b759c05fd",
        "parentId" : "dda4f2a7-cb38-4298-a339-f5bb5612a92f",
        "authorId" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "body" : "Filled #65323 + PR\r\n\r\n",
        "createdAt" : "2018-06-21T17:38:22Z",
        "updatedAt" : "2018-06-21T17:38:22Z",
        "lastEditedBy" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "tags" : [
        ]
      }
    ],
    "commit" : "acad9d89fa2915553a194fde3f515566cc2a8e05",
    "line" : 22,
    "diffHunk" : "@@ -1,1 +288,292 @@\t\treturn err\n\t}\n\n\tif c.csiClient == nil {\n\t\tc.csiClient = newCsiDriverClient(csiSource.Driver)"
  },
  {
    "id" : "99f4b905-6735-4bc5-8d9b-e73ef4bb5c5e",
    "prId" : 63303,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/63303#pullrequestreview-116798387",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "387a5bf7-f55b-4252-a733-6df1b8d36a5a",
        "parentId" : null,
        "authorId" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "body" : "btw I noticed that CSI has default attachment time of 15s. That seems awfully short - is there anything in CSI that can return how much expected waiting time is going to be?",
        "createdAt" : "2018-04-30T19:24:57Z",
        "updatedAt" : "2018-05-02T08:28:38Z",
        "lastEditedBy" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "tags" : [
        ]
      },
      {
        "id" : "82dc4ddd-0f31-442a-a08c-d07874d76742",
        "parentId" : "387a5bf7-f55b-4252-a733-6df1b8d36a5a",
        "authorId" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "body" : "No, there is no way how CSI driver could return estimated time.\r\n\r\nOn the other hand, attachment is handled by external attacher. External attacher still tries to attach the volume even when A/D controller timed out. A/D controller should periodically check (with exp. backoff?) if the volume got attached and does not need to wait in a blocking goroutine.",
        "createdAt" : "2018-05-02T07:50:33Z",
        "updatedAt" : "2018-05-02T08:28:38Z",
        "lastEditedBy" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "tags" : [
        ]
      }
    ],
    "commit" : "71e4449e1768f82e6c2187d94fc97361c6f49d89",
    "line" : 9,
    "diffHunk" : "@@ -1,1 +103,107 @@\t}\n\n\tif _, err := c.waitForVolumeAttachment(csiSource.VolumeHandle, attachID, csiTimeout); err != nil {\n\t\treturn \"\", err\n\t}"
  },
  {
    "id" : "2ff8a96f-4c56-497d-b562-17e8fe2aac4d",
    "prId" : 63303,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/63303#pullrequestreview-123886227",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "60a288c7-df47-421f-820e-ba3c5bcb5f63",
        "parentId" : null,
        "authorId" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "body" : "Could this cause API quota issues because now we could be retrying a lot of VolumeAttachment.Create() operations for objects that already exist?  Can we potentially check the informer cache first to see if we already created it?",
        "createdAt" : "2018-05-21T16:52:35Z",
        "updatedAt" : "2018-05-21T16:52:35Z",
        "lastEditedBy" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "tags" : [
        ]
      },
      {
        "id" : "8c3726ae-41cf-4d8f-872b-4c6230996e26",
        "parentId" : "60a288c7-df47-421f-820e-ba3c5bcb5f63",
        "authorId" : "54b8eb75-28dd-421d-a52b-63bf897147a9",
        "body" : "The `volAttachmentOK` var was mainly there for status indication.  This change should work as just like before.  @msau42 are you saying to check for pre-existence before attemting to create ?",
        "createdAt" : "2018-05-21T20:55:27Z",
        "updatedAt" : "2018-05-21T20:56:47Z",
        "lastEditedBy" : "54b8eb75-28dd-421d-a52b-63bf897147a9",
        "tags" : [
        ]
      },
      {
        "id" : "9f4cff4f-d01d-444d-a324-2ae379da7721",
        "parentId" : "60a288c7-df47-421f-820e-ba3c5bcb5f63",
        "authorId" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "body" : "Yes, because this change can cause Attach() to retry more than before.",
        "createdAt" : "2018-05-21T21:01:41Z",
        "updatedAt" : "2018-05-21T21:01:41Z",
        "lastEditedBy" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "tags" : [
        ]
      },
      {
        "id" : "90495dbb-a2a4-4e51-8e25-c78040e93328",
        "parentId" : "60a288c7-df47-421f-820e-ba3c5bcb5f63",
        "authorId" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "body" : "That belongs to a separate PR",
        "createdAt" : "2018-05-22T14:52:58Z",
        "updatedAt" : "2018-05-22T14:52:58Z",
        "lastEditedBy" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "tags" : [
        ]
      },
      {
        "id" : "b4d80c54-dfa0-46d2-bae1-feefa5b2dd66",
        "parentId" : "60a288c7-df47-421f-820e-ba3c5bcb5f63",
        "authorId" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "body" : "So, I checked how to fix this polling with something smarter, but it turns out that CSI volume plugin has no access to VolumeAttachment shared informer and the fix won't be simple one-liner. I filled #64429 to keep track of this, however, I am not actively working on it.",
        "createdAt" : "2018-05-29T08:11:53Z",
        "updatedAt" : "2018-05-29T08:11:54Z",
        "lastEditedBy" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "tags" : [
        ]
      }
    ],
    "commit" : "71e4449e1768f82e6c2187d94fc97361c6f49d89",
    "line" : 12,
    "diffHunk" : "@@ -1,1 +104,108 @@\n\tif _, err := c.waitForVolumeAttachment(csiSource.VolumeHandle, attachID, csiTimeout); err != nil {\n\t\treturn \"\", err\n\t}\n"
  },
  {
    "id" : "a209e1c7-c729-4827-b2cc-960beab60a39",
    "prId" : 60115,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/60115#pullrequestreview-99157618",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fcf03d36-627a-4490-ad25-e9f957664276",
        "parentId" : null,
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "Maybe sanity check assert that path terminates in `/globalmount` or `/globalmount/`?",
        "createdAt" : "2018-02-25T21:52:29Z",
        "updatedAt" : "2018-02-26T22:51:03Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      }
    ],
    "commit" : "cbd18965fd9c3d1a0bbfaa3de57eb9115337aad3",
    "line" : 249,
    "diffHunk" : "@@ -1,1 +541,545 @@\nfunc getDriverAndVolNameFromDeviceMountPath(k8s kubernetes.Interface, deviceMountPath string) (string, string, error) {\n\t// deviceMountPath structure: /var/lib/kubelet/plugins/kubernetes.io/csi/pv/{pvname}/globalmount\n\tdir := filepath.Dir(deviceMountPath)\n\tif file := filepath.Base(deviceMountPath); file != globalMountInGlobalPath {"
  },
  {
    "id" : "dca9f441-6dc8-496f-95a2-735e528fb089",
    "prId" : 60115,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/60115#pullrequestreview-99464949",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "983a4f3c-8dae-46ae-a61f-d32af89048be",
        "parentId" : null,
        "authorId" : "54b8eb75-28dd-421d-a52b-63bf897147a9",
        "body" : "Is `{pvname}` sanitized elsewhere (to remove path demarkation chars) ?  If so, it probably need to return back to its original state.  If no sanitization occurred, ignore.",
        "createdAt" : "2018-02-26T20:17:43Z",
        "updatedAt" : "2018-02-26T22:51:03Z",
        "lastEditedBy" : "54b8eb75-28dd-421d-a52b-63bf897147a9",
        "tags" : [
        ]
      },
      {
        "id" : "8c0c3baa-671a-4219-bae1-b8646c1cca77",
        "parentId" : "983a4f3c-8dae-46ae-a61f-d32af89048be",
        "authorId" : "542e5d2f-2ff9-4674-ab44-78f31768e7a1",
        "body" : "I am not doing sanitation anywhere, so the name should be same in both the creation and the extraction. ",
        "createdAt" : "2018-02-26T21:00:14Z",
        "updatedAt" : "2018-02-26T22:51:03Z",
        "lastEditedBy" : "542e5d2f-2ff9-4674-ab44-78f31768e7a1",
        "tags" : [
        ]
      }
    ],
    "commit" : "cbd18965fd9c3d1a0bbfaa3de57eb9115337aad3",
    "line" : 254,
    "diffHunk" : "@@ -1,1 +546,550 @@\t\treturn \"\", \"\", fmt.Errorf(\"getDriverAndVolNameFromDeviceMountPath failed, path did not end in %s\", globalMountInGlobalPath)\n\t}\n\t// dir is now /var/lib/kubelet/plugins/kubernetes.io/csi/pv/{pvname}\n\tpvName := filepath.Base(dir)\n"
  },
  {
    "id" : "ce8f2191-567c-4cb7-bba1-4982d4952a90",
    "prId" : 60115,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/60115#pullrequestreview-99464400",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "18b292bd-d010-4194-84e9-f064d4b6df02",
        "parentId" : null,
        "authorId" : "54b8eb75-28dd-421d-a52b-63bf897147a9",
        "body" : "Do we need to worry about `namespace` here?  If not, there maybe name collision.",
        "createdAt" : "2018-02-26T20:28:08Z",
        "updatedAt" : "2018-02-26T22:51:03Z",
        "lastEditedBy" : "54b8eb75-28dd-421d-a52b-63bf897147a9",
        "tags" : [
        ]
      },
      {
        "id" : "ef70ef0b-50f6-4773-bc58-6aaf1f35a8d6",
        "parentId" : "18b292bd-d010-4194-84e9-f064d4b6df02",
        "authorId" : "542e5d2f-2ff9-4674-ab44-78f31768e7a1",
        "body" : "PV's are not namespaced in Kubernetes.",
        "createdAt" : "2018-02-26T20:58:38Z",
        "updatedAt" : "2018-02-26T22:51:03Z",
        "lastEditedBy" : "542e5d2f-2ff9-4674-ab44-78f31768e7a1",
        "tags" : [
        ]
      }
    ],
    "commit" : "cbd18965fd9c3d1a0bbfaa3de57eb9115337aad3",
    "line" : 258,
    "diffHunk" : "@@ -1,1 +550,554 @@\n\t// Get PV and check for errors\n\tpv, err := k8s.CoreV1().PersistentVolumes().Get(pvName, meta.GetOptions{})\n\tif err != nil {\n\t\treturn \"\", \"\", err"
  },
  {
    "id" : "d053ffd8-2766-423e-bf87-1ed2fd054690",
    "prId" : 60115,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/60115#pullrequestreview-99464390",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4c138bbd-13b7-4ed9-a5fd-794a46c50fdd",
        "parentId" : null,
        "authorId" : "54b8eb75-28dd-421d-a52b-63bf897147a9",
        "body" : "Do a nil check here for `pv.Spec.CSI`",
        "createdAt" : "2018-02-26T20:29:02Z",
        "updatedAt" : "2018-02-26T22:51:03Z",
        "lastEditedBy" : "54b8eb75-28dd-421d-a52b-63bf897147a9",
        "tags" : [
        ]
      },
      {
        "id" : "28dc66a8-9c5d-4a35-9b28-6a22aaabf8a3",
        "parentId" : "4c138bbd-13b7-4ed9-a5fd-794a46c50fdd",
        "authorId" : "542e5d2f-2ff9-4674-ab44-78f31768e7a1",
        "body" : "Done 5 lines above already",
        "createdAt" : "2018-02-26T20:58:35Z",
        "updatedAt" : "2018-02-26T22:51:03Z",
        "lastEditedBy" : "542e5d2f-2ff9-4674-ab44-78f31768e7a1",
        "tags" : [
        ]
      }
    ],
    "commit" : "cbd18965fd9c3d1a0bbfaa3de57eb9115337aad3",
    "line" : 267,
    "diffHunk" : "@@ -1,1 +559,563 @@\n\t// Get VolumeHandle and PluginName from pv\n\tcsiSource := pv.Spec.CSI\n\tif csiSource.Driver == \"\" {\n\t\treturn \"\", \"\", fmt.Errorf(\"getDriverAndVolNameFromDeviceMountPath failed, driver name empty\")"
  },
  {
    "id" : "b6d7bbf8-7324-4513-81f9-5814147fc167",
    "prId" : 57194,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/57194#pullrequestreview-88210042",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "679819f4-07a4-4d86-bc23-e82939a9898c",
        "parentId" : null,
        "authorId" : "54b8eb75-28dd-421d-a52b-63bf897147a9",
        "body" : "Same here: use `glog.Error(log(...))` for consistency.",
        "createdAt" : "2018-01-11T16:00:21Z",
        "updatedAt" : "2018-02-02T09:41:25Z",
        "lastEditedBy" : "54b8eb75-28dd-421d-a52b-63bf897147a9",
        "tags" : [
        ]
      }
    ],
    "commit" : "ddf4c2d62ca0b005bc115a405ae3fb7c00bc36a9",
    "line" : 86,
    "diffHunk" : "@@ -1,1 +169,173 @@\t\t\t\t// if being deleted, fail fast\n\t\t\t\tif attach.GetDeletionTimestamp() != nil {\n\t\t\t\t\tglog.Error(log(\"VolumeAttachment [%s] has deletion timestamp, will not continue to wait for attachment\", attachID))\n\t\t\t\t\treturn \"\", errors.New(\"volume attachment is being deleted\")\n\t\t\t\t}"
  },
  {
    "id" : "c69f870f-c64c-4178-aee8-4595ddb5de52",
    "prId" : 56533,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/56533#pullrequestreview-80706377",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e45a96ba-9d3f-442a-8e0e-c15ef84d48e2",
        "parentId" : null,
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "@vladimirvivien per https://github.com/kubernetes/kubernetes/issues/56743 this should be the CSI driver name. Up to you if you want to include the one line fix in this PR or another PR.",
        "createdAt" : "2017-12-03T09:08:14Z",
        "updatedAt" : "2017-12-03T09:08:19Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      },
      {
        "id" : "d28e58a8-f01e-4f10-b495-cb5e6ff2e791",
        "parentId" : "e45a96ba-9d3f-442a-8e0e-c15ef84d48e2",
        "authorId" : "54b8eb75-28dd-421d-a52b-63bf897147a9",
        "body" : "@saad-ali will put in here!",
        "createdAt" : "2017-12-03T16:41:49Z",
        "updatedAt" : "2017-12-03T16:41:49Z",
        "lastEditedBy" : "54b8eb75-28dd-421d-a52b-63bf897147a9",
        "tags" : [
        ]
      }
    ],
    "commit" : "179d8e108e81ff189727659b4fd72b01f501d6f0",
    "line" : 20,
    "diffHunk" : "@@ -1,1 +66,70 @@\t\tSpec: storage.VolumeAttachmentSpec{\n\t\t\tNodeName: node,\n\t\t\tAttacher: csiPluginName,\n\t\t\tSource: storage.VolumeAttachmentSource{\n\t\t\t\tPersistentVolumeName: &pvName,"
  },
  {
    "id" : "cd6cb3a9-eef1-4c39-a780-9107369ba157",
    "prId" : 54529,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/54529#pullrequestreview-77398981",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "710e0945-3fc9-4f91-bcb3-34d677e07480",
        "parentId" : null,
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "Add an OWNERS file for the new directory. Add me, you, and Jan as approvers.",
        "createdAt" : "2017-11-16T01:32:37Z",
        "updatedAt" : "2017-11-22T01:22:10Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      },
      {
        "id" : "a6d64087-6408-4f01-a302-16cf7e70b208",
        "parentId" : "710e0945-3fc9-4f91-bcb3-34d677e07480",
        "authorId" : "54b8eb75-28dd-421d-a52b-63bf897147a9",
        "body" : "Will do.",
        "createdAt" : "2017-11-17T10:51:30Z",
        "updatedAt" : "2017-11-22T01:22:10Z",
        "lastEditedBy" : "54b8eb75-28dd-421d-a52b-63bf897147a9",
        "tags" : [
        ]
      }
    ],
    "commit" : "e489629895ffa82eb7cd8281f0a2b7e788a29812",
    "line" : 17,
    "diffHunk" : "@@ -1,1 +15,19 @@*/\n\npackage csi\n\nimport ("
  },
  {
    "id" : "e079eccd-34c8-4808-9836-60a0cf92f38c",
    "prId" : 54529,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/54529#pullrequestreview-78129444",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1668c139-336d-4cc4-838b-db35c4dc04d7",
        "parentId" : null,
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "If the object does not exist, this `waitForVolumeDetachment(...)` method should succeed immediately. I think you can check that with `apierrs.IsNotFound(err)`.",
        "createdAt" : "2017-11-21T05:42:32Z",
        "updatedAt" : "2017-11-22T01:22:10Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      },
      {
        "id" : "8bc2e748-7d37-43d1-804b-2fcede8e6890",
        "parentId" : "1668c139-336d-4cc4-838b-db35c4dc04d7",
        "authorId" : "54b8eb75-28dd-421d-a52b-63bf897147a9",
        "body" : "Good point, yes you can check with `IsNotFound`.",
        "createdAt" : "2017-11-21T14:37:48Z",
        "updatedAt" : "2017-11-22T01:22:11Z",
        "lastEditedBy" : "54b8eb75-28dd-421d-a52b-63bf897147a9",
        "tags" : [
        ]
      }
    ],
    "commit" : "e489629895ffa82eb7cd8281f0a2b7e788a29812",
    "line" : 127,
    "diffHunk" : "@@ -1,1 +230,234 @@\t\t\tglog.V(4).Info(log(\"probing VolumeAttachment [id=%v]\", attachID))\n\t\t\tattach, err := c.k8s.StorageV1alpha1().VolumeAttachments().Get(attachID, meta.GetOptions{})\n\t\t\tif err != nil {\n\t\t\t\tif apierrs.IsNotFound(err) {\n\t\t\t\t\t//object deleted or never existed, done"
  }
]